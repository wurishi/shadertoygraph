{"ver":"0.1","info":{"id":"XcBXRy","date":"1706462892","viewed":140,"name":"Brickwork Details","username":"spalmer","description":"fork of fork of a Fabrice toy.\nA simpler example of the directional derivative lighting hacks\nused to demonstrate my early attempt at brickwork mortar seams\nwhich would otherwise never be seen.\nHopefully one of those is useful to somebody.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["procedural","brick","hypertexture","carve","metamaterial","brickwork"],"hasliked":0,"parentid":"wsjfWK","parentname":"Detail Spheres"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of Detail Spheres http://shadertoy.com/view/wsjfWK\n// removed the detail spheres and replaced with the brickwork\n// that I initially developed at http://shadertoy.com/view/tlGXDK\n\n// currently implements a stretcher \"bond\" with \n// some phase shifting on alternate leafs but\n// it's not a true bond style for a load-bearing wall.\n// Lacks any bonding between leafs.\n\nconst float\n    rad = .3,    // torus large radius\n    rad2 = .2,   // torus small radius\n    grid = 18.,  // brick scale\n    size = .15 / grid, //.01   // detail radius \n    pi = acos(-1.);\n\nfloat dBox(vec3 q, vec3 e)\n{\n    q = abs(q) - e;\n    return min(0., max(q.x, max(q.y, q.z))) + length(max(q, 0.)); // iq way\n}\n\n// iq http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k)\n{\n\tfloat h = a - b;\n    return .5 * (a + b - sqrt(h * h + k));\n}\n// sqrt version is apparently best\nfloat smax(float a, float b, float k)\n{\n\treturn -smin(-a, -b, k);\n}\n\n// TODO should be able to do almost all this with creative abs() mirroring\n\n// FIXME should refactor the CSG parts out of this before proceeding any further\n\n// it's apparent to me that I require a better strategy\n// for dealing with brick shape tiling in general\n\n// carve bricks into dlod shape sdf\nfloat dBrickwork(vec3 q, float dlod)\n{\n    const float s = grid;\n    q *= s;\n    q *= .5;\n    q = fract(q) - .5;\n    //if (q.y > 0.) q.xz = q.zx; // this never worked out right\n    q.z += .25 * (2. * floor(2. * q.x) + floor(2. * q.y));\n    q.z = fract(q.z) - .5;\n    //q.xy = abs(q.xy);\n    q *= 2.;\n    q.xy = fract(q.xy) - .5;\n    float d = (dBox(q, vec3(.5,.5,1) - .03) - .01) / s;\n    d = smin(d, dlod + .061, 1e-4); // limit depth of mortar cracks\n    d = smax(d, dlod, 1e-4); // wow smoothmin makes a heckuva difference!\n    return d;\n}\n// TODO with a normal, could fade out the lines cutting the wrong way trilinear style\n\n// the general shape, uncarved\nfloat dShapeMain(vec3 q) \n{\n    float db = max(abs(max(abs(q.x), abs(q.y)) - rad), abs(q.z)) - rad2,\n        dt = length(vec2(length(q.xy) - rad, q.z)) - rad2;\n        //length(vec2(abs(max(abs(q.x), abs(q.y)) - rad), abs(q.z))) - rad2; //length(q - normalize(q * vec3(1, 1, 0)) * rad) - rad2; // weird way to make a torus but whatevs\n    //db = min(db, q.y + .46); // 'floor'\n    return q.y < -.2 ? db : q.y > .2 ? dt : mix(db, dt, .5 + .5/.2 * q.y);\n}\n\n// shim adding a meta-material sdf to an sdf\n// I had idea to do brickworks, tried out, voila\nfloat dScene(vec3 q)\n{\n    float d = dShapeMain(q);\n    if (abs(d) > 2. * size) return d - sign(d) * size;   // details evaluated only near surface\n    //vec3 e = ro - q;\n    // TODO fade out, don't just clip\n    // just do this very near the surface\n    if (true && abs(d) < .25) { // && dot(e, e) < 36.) {\n        float db = dBrickwork //dBrickworkDoubleFlemishWIP //\n            (q.yzx, d);\n        db = smin(db, d + .006, 1e-5); // limit depth of mortar cracks\n        d = smax(d, db, 1e-5);\n    }\n    // fine 'texture' bumps just so there's *some* texture at all\n    d += .006 * size * dot(vec3(.33), sin(73. * q.yzx * (1. - 79. * q.zxy))) * exp2(-d * d);\n    return d;\n}\n    //float dlod = d - 2. * size;         // bound shell around max detail protrusion\n    //if (d > dlod + 3. * size) return dlod; // low LOD for further queries\n\n// might be the most versatile lighting primitive ever\n// should probably make the length(L) into an argument, move to caller\nfloat liteHaxx(vec3 p, float v, vec3 L) // given point and known closest distance at point,\n{\n    float dl = dScene(p + L),          // another sample toward 'light'\n        dx = (dl - v) / length(L);     // cheap directional derivative\n    return clamp(dx, 0., 1.);          // approximates Lambert shading    \n}\n\n// look, ma, no normals!\n/* // simple forward difference gradient when you already know the distance at center sample\nvec3 gScene(vec3 p, float v, float e)\n{\n    vec2 f = vec2(e, 0);\n    return (vec3(\n        dScene(p + f.xyy),\n        dScene(p + f.yxy),\n        dScene(p + f.yyx)\n        ) - v) / e;\n}\n// but I found an even simpler way that doesn't even require obtaining the normal!\nfloat aoHaxx(vec3 p, float v)\n{\n    float e = .7 * size;\n    vec3 n = normalize(gScene(p, v, e));\n    return pow(liteHaxx(p, v, e * n), 2.);\n}\n*/\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         q = (2. * u - R) / R.y,\n         M = iMouse.xy / R;\n    if (M == vec2(0)) M = vec2(.5); // unattended\n    \n    // set camera\n    float theta = (.5 - M.x) * pi * 2., \n         phi = (.5 - M.y) * pi;\n    if (iMouse.z <= 0.) { // camera animate if no mouselook \n    \tfloat t = .7 * iTime, B = .02;\n        theta += B * cos(t) + 2. * B * t; phi += B * sin(t);\n    }\n    //#define rot(a)     mat2(cos(a), -sin(a), sin(a), cos(a))\n\n    // TODO golf this\n    vec3 eye = vec3(sin(theta) * cos(phi), sin(phi), cos(theta) * cos(phi)),\n        lookAt = vec3(0),\n        W = normalize(eye - lookAt),\n        U = vec3(W.z, 0, -W.x),\n        rayDir = normalize(mat2x3(U, cross(W, U)) * q - 1.5 * W);\n        //U = normalize(cross(vec3(0, 1, 0), W)),\n        //V = cross(W, U),\n        //rayDir = normalize(q.x * U + q.y * V -1.5 * W);\n\n    // ray-march a radial section,\n    // which bounds the scene around \n    // front of big shape for performance.\n    float l = .7 - rad - rad2, \n        bound = 1. + rad + rad2 + 2. * size, \n        d = 9e9;\n    vec3 p,\n        col; // = vec3(0);\n    //if (dot(q, q) < 2.) // HACK optimization: don't bother checking details in corners of screen\n    // ray-march\n    for (float i = 0.; i < 128.; ++i) {\n        p = eye + l * rayDir;\n        d = dScene(p); \n        l += d; // * .9;\n        if (d < .001            // \"hit\" on an object\n         || l > bound + 1.\n         || dot(p, p) > bound * bound)\n            break;\n    }\n    \n    const vec3\n        skyColor = vec3(.3,.5,.7),\n        lightDir = normalize(vec3(.8,.3,.2)),\n        ambient  = vec3(.15), \n        diffuse  = vec3(.8), \n        specular = vec3(.4);\n\n    //d = min(d, 1e2);\n    if (d < .001) {                           // hit\n        vec3 c = vec3(1,.8,.6);               // albedo\n        float shade = liteHaxx(p, d, .5 * size * lightDir)  // shading\n            * sqrt(liteHaxx(p, d, rad * lightDir)); // 'shadow'\n        c *= diffuse * shade\n            + ambient * liteHaxx(p, d, size * W); // * aoHaxx(p, d)\n        c += specular * shade * pow(liteHaxx(p, d, .8 * size * (lightDir + W)), 32.); // why not\n \t    col += c;\n    } else {\n        col += skyColor;\n        col += .7 * pow(dot(rayDir, lightDir) * .5 + .5, 4.);\n    }\n      \n    O = vec4(sqrt(col), 1);\n}\n\n","name":"Image","description":"","type":"image"}]}