{"ver":"0.1","info":{"id":"7dyfW1","date":"1658084643","viewed":375,"name":"Multitruchette","username":"Flopine","description":"Inspired by this article: \nhttps://christophercarlson.com/portfolio/multi-scale-truchet-patterns/","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","pattern","multiscale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Inspired by this article: \n// https://christophercarlson.com/portfolio/multi-scale-truchet-patterns/\n\n\n#define THIRD (1./3.)\n#define EIGHTH (1./8.)\n\n#define circle(u,s) (length(u)-s)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n\n//#define DEBUG\n\n\nvec2 mo (vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x)p=p.yx;\n    return p;\n}\n\nfloat tile1 (vec2 uv)\n{  \n    vec2 uu = uv;\n    float size = 0.5;\n    float diag = step(0., (uv.x+uv.y));   \n    \n    uv += (diag>0.5) ? -size : size;\n    float d = AAstep(size*THIRD, abs(circle(uv,size)));\n    \n    uv = uu;\n    uv = mo(uv, vec2(size));\n    d *= AAstep(EIGHTH*THIRD, abs(circle(uv, EIGHTH)));\n    \n    d += 1.-AAstep(0.001, circle(vec2(abs(uv.x)-size,uv.y), EIGHTH*2.*THIRD));\n    \n    d += 1.-AAstep(0.001, circle(vec2(uv.x,abs(uv.y)-size), EIGHTH*2.*THIRD));\n    \n    return d;\n}\n\nfloat tile2 (vec2 uv)\n{\n    vec2 uu = uv;\n    float size = 0.25;\n    float diag = step(0., (uv.x+uv.y));   \n\n    uv += (diag>0.5) ? -size : size;   \n    float d = AAstep(size*THIRD, abs(circle(uv,size))); \n    \n    uv = uu;\n    uv = mo(uv, vec2(size));\n    return d*AAstep(0.001, circle(uv, EIGHTH*2.*THIRD));\n    \n    return d;\n}\n\nfloat tile3 (vec2 uv)\n{  \n    float size = 0.125;\n    float diag = step(0., (uv.x+uv.y));   \n    \n    uv += (diag>0.5) ? -size : size;   \n    float d = AAstep(size*THIRD, abs(circle(uv,size)));\n    \n    return d;\n}\n\nvec3 grid (inout vec2 uv)\n{\n    vec2 id = floor(uv);\n    float noise = textureLod(iChannel0, vec2(atan(id.y,id.x)+iTime*0.006,length(id)), 0.0).x*3.;\n    bool switchcolor = false;\n\n    if (mod(id.x+id.y,2.) == 0.) uv.x = -uv.x; \n    //if (noise > 1.5) uv.x = -uv.x;\n    float tiles = 0.;\n    if (noise >= 0. && noise < 1.)\n    {     \n        uv = mod(uv, 1.)-.5;\n        tiles = tile1(uv);\n    }\n    \n    if (noise >= 1. && noise < 2.)\n    {\n        switchcolor = true;\n        uv = mod(uv, 0.5)-.25;\n        tiles = tile2(uv);\n    }\n    \n    if (noise >= 2. && noise < 3.1)\n    {\n        uv = mod(uv, 0.25)-.125;\n        tiles = tile3(uv);\n    }\n    tiles = clamp(tiles,0.,1.);\n    tiles = switchcolor ? 1.-tiles:tiles;\n    \n    return vec3(tiles);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 3.;\n    uv.y += iTime;\n    vec3 col = grid(uv);\n    \n    #ifdef DEBUG \n    col.rg =  uv*3.;\n    #endif\n   \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}