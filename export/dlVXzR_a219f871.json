{"ver":"0.1","info":{"id":"dlVXzR","date":"1685957520","viewed":133,"name":"RD12 cluster","username":"ChunderFPV","description":"I wanted to do more with this but I'm still getting the hang of raymarches so I'll come back to this later.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","honeycomb","dodecahedron","rhombic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RT(a) mat2(cos(m.a+vec4(0,11,33,0))) // rotate\n#define S s = min(s, rd12(p-round(p), .44)); // repeating this a few times\nfloat rd12(vec3 p, float r) // rhombic dodeca\n{\n    p = abs(p);\n    return max(p.x+max(p.y, p.z), p.z+max(p.y, p.x))/1.732-r/1.732;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float d = 0., e, s;\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy/R*4.)-2.;\n    vec3 v = vec3(0, 0, -50), // cam\n         u = normalize(vec3((U-.5*R)/R.y, 10)), // coords\n         p;\n    if (iMouse.z < 1.) m = vec2(iTime/3., -.6); // move when not clicking\n    mat2 pitch = RT(y), yaw = RT(x); // rotation\n    for (int i=0; i<50; i++) // raymarch\n    {\n        p = v+u*d;\n        p.yz *= pitch;\n        p.xz *= yaw;\n        s = rd12(p-round(p), .44); // first set\n        p.xy += .5; S // next set\n        p.yz += .5; S // etc.\n        p.xy -= .5; S\n        p.yz -= .5;\n        s = max(s, rd12(p, 2.4)); // big one to boolean\n        if (s < .001 || d > 100.) break;\n        d += s;\n    }\n    e = d/rd12(p, 0.); // inner shadow trick\n    C = vec4(vec3(pow(35./e, 25.)), 1);\n    //C = vec4(vec3(pow(e/37., 40.), .1, .2), 1); // alternate\n}","name":"Image","description":"","type":"image"}]}