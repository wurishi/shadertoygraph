{"ver":"0.1","info":{"id":"X33GRX","date":"1717167630","viewed":111,"name":"Delaunay Ball Pool","username":"coposuke","description":"When ParticleID overflows the memory (16 IDs) of Buffer B, a hole will be created. (Because the line does not connect)\nCBuffer stores up to 254*3360 ways (16*15*14 ways) valid triangle decisions.\n\nR: Reset","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["voronoi","tracking","jump","particle","delaunay","flooding","jfa"],"hasliked":0,"parentid":"433GW4","parentname":"Ball Pool"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Visualize delaunay diagram (and all particles)\n//\n// Buffer A: Particle Buffer\n// Buffer B: Voronoi Tracking Buffer\n// Buffer C: Circum Buffer\n// \nfloat sdLine(vec2 l0, vec2 l1, vec2 p)\n{\n    vec2 v01 = (l1 - l0);\n    vec2 v0p = ( p - l0);\n    vec2 vh = v0p - v01 * clamp(dot(v01, v0p) / dot(v01, v01), 0.0, 1.0);\n    return length(vh);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float particleRadius = getParticleRadius(iResolution.xy);\n\n    // Getting closest positions in advance\n    int [16] closest = getClosest(iChannel1, fragCoord);\n    \n    // Delaunay diagram Lines\n    float distLine = 1e+8;\n    vec3 debugColor = vec3(0.0);\n    for (int i = ZERO; i < 5; ++i)    // really need 16 loops\n    {\n        int targetPID = closest[i];\n        vec4 targetParticle = getParticle(iChannel0, iResolution.xy, targetPID);\n        int [16] targetClosest = getClosest(iChannel1, targetParticle.xy);\n        vec2 [16] targetClosestPosition;\n\n        for (int j = 0; j < 16; ++j)\n            targetClosestPosition[j] = getParticle(iChannel0, iResolution.xy, targetClosest[j]).xy;\n\n        for (int j =  ZERO; j < 1; ++j)   // really need 14 loops, but almost j == i.\n        for (int k = j + 1; k < 15; ++k)  // really need 15 loops\n        for (int l = k + 1; l < 16; ++l)  // really need 16 loops\n        {\n            int pid0 = targetClosest[j];\n            int pid1 = targetClosest[k];\n            int pid2 = targetClosest[l];\n\n            ivec4 circumID = ivec4(targetPID, j, k, l);\n            vec4 circum = getCircum(iChannel2, ivec2(iResolution.xy), circumID);\n\n            if(circum.w == 1.0)\n            {\n                // Debug visualize circumcircle\n                float sizeCircumCenter = particleRadius * 0.25;\n                float sizeCircumLine = particleRadius * 0.1;\n                float distCircum = distance(circum.xy, fragCoord);\n                debugColor += vec3(smoothstep(sizeCircumCenter, sizeCircumCenter * 0.8, distCircum));\n                debugColor += vec3(smoothstep(sizeCircumLine, sizeCircumLine * 0.1, abs(distCircum - circum.z)));\n\n                // Calculate minimum distance from lines of triangle\n                vec2 pos0 = targetClosestPosition[j];\n                vec2 pos1 = targetClosestPosition[k];\n                vec2 pos2 = targetClosestPosition[l];\n                distLine = min(distLine, sdLine(pos0, pos1, fragCoord));\n                distLine = min(distLine, sdLine(pos1, pos2, fragCoord));\n                distLine = min(distLine, sdLine(pos2, pos0, fragCoord));\n            }\n        }\n    }\n    \n    fragColor = vec4(0.0);\n    \n    // Colorize the delaunay lines\n    float lineWidth = particleRadius * 0.15;\n    float line = smoothstep(1.5, 0.0, distLine - lineWidth);\n    fragColor += vec4(line, line, line, 1.0);\n    \n    // Debug visualize circumcircle \n    //fragColor.rgb += debugColor * vec3(0.8, 0.4, 0.2) * 0.15;\n    \n    // Colorize the point\n    int particles = getParticleCount(iResolution.xy);\n    int particleID = closest[0];\n    vec2 particlePos = getParticle(iChannel0, iResolution.xy, particleID).xy;\n    \n    vec3 hsv = vec3(float(particleID) / float(particles), 0.25, 0.8);\n    float distPoint = distance(particlePos, fragCoord);\n    distPoint = smoothstep(1.5, 0.0, distPoint - particleRadius);\n    fragColor.rgb = mix(fragColor.rgb, hsv2rgb(hsv), distPoint);\n    \n    // Debug\n    //fragColor += vec4(distPoint / 50.0);\n    //vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = texture(iChannel0, uv);\n    //fragColor += texture(iChannel2, uv * vec2(1.0, 0.02)).yzwx;\n    //fragColor = texture(iChannel1, uv) / float(particles);\n    //for (int i = 0; i < 16; ++i)\n    //    fragColor.r += closest[i] == 0 ? 0.4 : 0.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Update Particle\n// \n// xy: position\n// zw: velocity\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\n    int particles = getParticleCount(iResolution.xy);\n    int particleID = getParticleID(fragCoord, iResolution.xy);\n    if (particleID >= particles)\n        return;\n        \n    vec4 particle = getParticle(iChannel0, iResolution.xy, particleID); // ==texture(iChannel0, fragCoord / iResolution.xy);\n    vec2 position = particle.xy;\n    vec2 velocity = particle.zw;\n\n    // Initialize & Reset\n    if (iFrame < 20 || 0.0 < getKeyR(iChannel2, 0))\n    {\n        position.x = hash(fragCoord.xy);\n        position.y = hash(fragCoord.xy * vec2(0.5, 0.5));\n        \n        float radian = hash(float(particleID)) * TAU;\n        velocity.x = sin(radian);\n        velocity.y = cos(radian);\n        \n        position *= iResolution.xy;\n        velocity *= PARTICLE_SPEED;\n    }\n    // Update\n    else\n    {\n        // Move\n        position += velocity * iTimeDelta;\n\n        // Coefficient of restitution\n        const float COR = 1.0;\n        const float COR2 = 1.0 + COR * COR;\n        \n        // Hit closest particles\n        float particleRadius = getParticleRadius(iResolution.xy);\n        int [16] closest = getClosest(iChannel1, position);\n        for (int i = 0; i < 4; i++) // really need 16 loops\n        {\n            if(closest[i] < 0 || closest[i] == particleID)\n                continue;\n        \n            vec4 particle = getParticle(iChannel0, iResolution.xy, closest[i]);\n            vec2 particlePos = particle.xy;\n            vec2 particleVel = particle.zw;\n            float dist = distance(position, particlePos);\n            \n            if (dist < particleRadius * 2.0)\n            {\n                float overlap = dist - particleRadius * 2.0;\n                vec2 normal = normalize(position - particlePos);\n                float dotNV = dot(velocity, normal);\n                \n                position -= overlap * normal;                // pushback\n                velocity = velocity - dotNV * normal * COR2; // repulsion\n            }\n        }\n        \n        // Hit wall\n        vec2 halfRes = iResolution.xy * 0.5;\n        vec2 diff  = position - halfRes;\n        vec2 velSign = sign(velocity);\n        vec2 wall = halfRes * velSign - particleRadius * velSign;\n\n        vec2 a = mix(diff, wall, velSign * 0.5 + 0.5);\n        vec2 b = mix(wall, diff, velSign * 0.5 + 0.5);\n\n        if (a.x < b.x)\n        {\n            float overlap = abs(diff.x) - halfRes.x;\n            position.x -= (overlap + particleRadius) * velSign.x; // pushback\n            velocity.x *= -COR;                                   // repulsion\n        }\n\n        if (a.y < b.y)\n        {\n            float overlap = abs(diff.y) - halfRes.y;\n            position.y -= (overlap + particleRadius) * velSign.y; // pushback\n            velocity.y *= -COR;                                   // repulsion\n        }\n    }\n    \n    particle.xy = position;\n    particle.zw = velocity;\n    fragColor = particle;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//\n// Visualize Delauney Diagram\n//\n// Buffer A: Particle Buffer\n// Buffer B: Voronoi Tracking Buffer\n// Buffer C: Circum Buffer\n// \n\n/// Other ///\n#define ZERO int(min(0.0, iTime))\nconst float PI = 3.14159265358979;\nconst float TAU = PI * 2.0;\n\nfloat getKeyR(sampler2D keyboardBuffer, int state)\n{\n    return texelFetch(keyboardBuffer, ivec2(82, state), 0).x;\n}\n\n/// Hash ///\nfloat hash(float v)\n{\n    return fract(sin(v) * 43758.5453123);\n}\n\nfloat hash(vec2 v)\n{\n    return fract(sin(dot(v, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n/// Particle ///\nconst int BUFFER_PER_PARTICLE = 16 * 15 * 14; // Pattern of closests 16 particleID (Not combinations)\nconst float PARTICLE_SPEED = 100.0;\n\nfloat getParticleRadius(vec2 resolution)\n{\n    return resolution.y / 800.0 * 20.0;\n}\n\nint getParticleCount(ivec2 resolution)\n{\n    // Minimum number of particles\n    // 254: in bBuffer, max number can be stored (0xff). but 255 is disable ID.\n    // res.x * res.y / (16*15*14): in cBuffer, max number can be stored.\n    int minNum = min(0xff - 1, resolution.x * resolution.y / BUFFER_PER_PARTICLE);\n    //minNum = 10;\n\n    float radius = getParticleRadius(vec2(resolution));\n    float fullCount = floor(float(resolution.x * resolution.y) / (4.0 * radius * radius));\n    return min(minNum, int(fullCount * 0.5));\n}\n\nint getParticleCount(vec2 resolution)\n{\n    return getParticleCount(ivec2(resolution));\n}\n\nint getParticleID(ivec2 fragCoord, ivec2 resolution)\n{\n    return fragCoord.x + fragCoord.y * resolution.x;\n}\n\nint getParticleID(vec2 fragCoord, vec2 resolution)\n{\n    return getParticleID(ivec2(fragCoord), ivec2(resolution));\n}\n\nvec4 getParticle(sampler2D aBuffer, vec2 resolution, int pid)\n{\n    int particles = getParticleCount(resolution);\n    pid = abs(pid) % particles; // round to within limit\n\n    int rx = int(resolution.x);\n    int ux = pid % rx;\n    int uy = pid / rx;\n    return texelFetch(aBuffer, ivec2(ux, uy), 0); // aBuffer = ParticleBuffer\n}\n\n\n/// Voronoi Tracking ///\nint [16] getClosest(sampler2D bBuffer, ivec2 fragCoord)\n{\n    vec4 v = texelFetch(bBuffer, fragCoord, 0);\n    uvec4 bits = floatBitsToUint(v);\n    \n    int [16] closest;\n    for (int i = 0; i < 4; ++i)\n    {\n        uint component = bits[i];\n        for (int b = 0; b < 4; ++b)\n        {\n            // order = [No.4][No.3][No.2][No.1]\n            int shift = b * 8;\n            int pid = int(0xffu & component >> shift);\n            if (pid < 0 || pid >= 0xff)\n                pid = -1;\n            \n            closest[i * 4 + b] = pid;\n        }\n    }\n    \n    return closest;\n}\n\nint [16] getClosest(sampler2D bBuffer, vec2 fragCoord)\n{\n    return getClosest(bBuffer, ivec2(fragCoord));\n}\n\n\n/// CircumCircle for Delaunay ///\nivec4 getCircumID(ivec2 fragCoord, ivec2 resolution)\n{\n    // ID Max: 255 * 16 * 15 * 14 / (3 * 2) = 142800\n    int uid = fragCoord.x + fragCoord.y * resolution.x;\n    int particleID = uid / BUFFER_PER_PARTICLE;\n    int combiID = uid % BUFFER_PER_PARTICLE;\n    \n    ivec4 id = ivec4(0);\n    id.x = particleID;\n    id.y = combiID / 16 / 15;\n    id.z = combiID / 16 % 15;\n    id.w = combiID % 16;\n    return id;\n}\n\nvec4 getCircum(sampler2D cBuffer, ivec2 resolution, ivec4 circumID)\n{\n    int idOffset = circumID.x * BUFFER_PER_PARTICLE;\n    int combiOffset0 = circumID.y * 16 * 15;\n    int combiOffset1 = circumID.z * 16;\n    int combiOffset2 = circumID.w;\n    int uid = idOffset + combiOffset0 + combiOffset1 + combiOffset2;\n\n    int ux = uid % resolution.x;\n    int uy = uid / resolution.x;\n    return texelFetch(cBuffer, ivec2(ux, uy), 0); // cBuffer = Circum Buffer\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// Voronoi Tracking\n// \n// x: closest no.1  &  2 &  3 &  4(8bit * 4)\n// y: closest no.5  &  6 &  7 &  8(8bit * 4)\n// z: closest no.9  & 10 & 11 & 12(8bit * 4)\n// w: closest no.13 & 14 & 15 & 16(8bit * 4)\n//\n\n//#define MODE_VERY_HIGH_PERFORMANCE\n#define MODE_HIGH_PERFORMANCE\n//#define MODE_MIDDLE_PERFORMANCE\n//#define MODE_LOW_PERFORMANCE\n\nvoid insertClosest(\n    inout int [16] srcIDs, inout float [16] srcDists,\n    in int dstID, in float dstDist)\n{\n    for (int i = 0; i < 16; ++i)\n    {\n        if(dstDist < srcDists[i])\n        {\n            for (int j = 15; j > i; --j)\n            {\n                srcIDs[j] = srcIDs[j - 1];\n                srcDists[j] = srcDists[j - 1];\n            }\n                \n            srcIDs[i] = dstID;\n            srcDists[i] = dstDist;\n            break;\n        }\n    }\n}\n\nbool anyEqual(int [16] srcIDs, int dstID)\n{\n    for (int i = 0; i < 16; ++i)\n        if(srcIDs[i] == dstID)\n            return true;\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Reset\n    if (0.0 < getKeyR(iChannel2, 1))\n    {\n        uint dv = uint(0xff & -1);\n        fragColor = vec4(uintBitsToFloat(dv));\n        return;\n    }\n    \n    int [16] closestList;    // new closest list (particleIDs)\n    float [16] distanceList; // new distance list\n    \n    // Setting default value to list\n    for (int i = 0; i <16; ++i)\n    {\n        closestList[i] = -1;\n        distanceList[i] = 1e+8;\n    }\n\n    // setting parameters (by mode performance)\n    float jfStart = min(4.0, floor(log2(max(iResolution.x, iResolution.y))));\n    int offsetLoops = 9;\n    const vec2 [9] OFFSETS = vec2[9]\n    (\n        vec2(-1.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(0.0, -1.0), vec2(0.0,  0.0), // Left, Up, Right, Down, Center\n        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0,  1.0), vec2(1.0,  1.0) // 4 corners\n    );\n    int closestLoopOffset = 1;\n    \n#ifdef MODE_VERY_HIGH_PERFORMANCE\n    // very high (max loops:  5 * 9 * 16 = 720)\n#elif defined(MODE_HIGH_PERFORMANCE)\n    // high      (max loops:  3 * 5 * 16 = 240)\n    jfStart = floor(jfStart * 0.5);\n    offsetLoops = 5;\n#elif defined(MODE_MIDDLE_PERFORMANCE)\n    // middle    (max loops:  2 * 5 * 8 = 80)\n    jfStart = floor(jfStart * 0.25);\n    offsetLoops = 5;\n    closestLoopOffset = 2;\n#else //MODE_LOW_PERFORMANCE\n    // low       (max loops:  2 * 4 * 8 = 64)\n    jfStart = floor(jfStart * 0.25);\n    offsetLoops = 4;\n    closestLoopOffset = 2;\n#endif\n\n    // jump flooding loops\n    for (float jf = jfStart; jf >= 0.0; jf--)\n    {\n        float jfLength = pow(2.0, jf);\n        \n        // getting neighbor closest particleID list\n        for (int o = ZERO; o < offsetLoops; ++o)\n        {\n            vec2 offset = OFFSETS[o];\n            int [16] neighbor = getClosest(iChannel1, fragCoord + offset * jfLength);\n\n            int ciStart = (iFrame + o) % closestLoopOffset;\n            for(int ci = ciStart; ci < 16; ci+=closestLoopOffset) // closest index\n            {\n                int particleID = neighbor[ci];\n                if (particleID < 0)\n                    continue;\n\n                // continue when closestList contain the particleID\n                if (anyEqual(closestList, particleID))\n                    continue;\n\n                vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n                vec2 particlePos = particle.xy;\n\n                // comparing distance fragCoord to particlePos, and insert one closest.\n                float dist = distance(fragCoord, particlePos);\n                insertClosest(closestList, distanceList, particleID, dist);\n            }\n        }\n    }\n    \n    // random pick a particleID, and insert one closest.\n    // we need to find closest particle IDs, with in the area between particles.\n    {\n        int particles = getParticleCount(iResolution.xy);\n    \n        int [2] particleIDs = int[2](0, 0);\n        particleIDs[0] = int(hash(fragCoord + iTime * 0.1) * float(particles)); // random pick\n        particleIDs[1] = getParticleID(fragCoord, iResolution.xy) % particles;  // fixed pick\n\n        for (int i = 0; i < 2; ++i)\n        {\n            int particleID = particleIDs[i];\n            \n            // Same as above\n            if (anyEqual(closestList, particleID))\n                continue;\n\n            vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n            vec2 particlePos = particle.xy;\n\n            float dist = distance(fragCoord, particlePos);\n            insertClosest(closestList, distanceList, particleID, dist);\n        }\n    }\n    \n    // Convert 16 particleID to 4 float(8 bit * 16)\n    for (int i = ZERO; i < 4; ++i)\n    {\n        uint component = 0u;\n        for (int b = ZERO; b < 4; ++b)\n        {\n            int pid = closestList[i * 4 + b];\n            if (pid < 0 || pid > 0xff)\n                pid = 0xff;\n            \n            // order = [No.4][No.3][No.2][No.1]\n            int shift = b * 8;\n            component = component | uint(0xff << shift & pid << shift);\n        }\n        \n        fragColor[i] = uintBitsToFloat(component);\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//\n// Calculation circumcircle of triangles\n//\n// x: circum center x\n// y: circum center y\n// z: circum radius\n// w: enable triangle (0: disable, 1: enable)\n// \nfloat cross2(vec2 v0, vec2 v1)\n{\n    return v0.x * v1.y - v0.y * v1.x;\n}\n\nbool allEqual(int [16] srcIDs, ivec3 dstIDs)\n{\n    ivec3 flag = ivec3(0);\n    for (int i = 0; i < 16; ++i)\n    {\n        if(srcIDs[i] == dstIDs.x) flag.x = 1;\n        if(srcIDs[i] == dstIDs.y) flag.y = 1;\n        if(srcIDs[i] == dstIDs.z) flag.z = 1;\n    }\n    \n    return all(equal(flag, ivec3(1)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\n    // Getting circum ID\n    // x: particleID\n    // y: in particleID, 1st pid in closest list\n    // z: in particleID, 2nd pid in closest list\n    // w: in particleID, 3rd pid in closest list\n    ivec4 circumID = getCircumID(ivec2(fragCoord), ivec2(iResolution.xy));\n    \n    int particleCount = getParticleCount(ivec2(iResolution.xy));\n    if (particleCount < circumID.x)\n        return;\n\n    vec4 particle = getParticle(iChannel0, iResolution.xy, circumID.x);\n    int [16] closest = getClosest(iChannel1, particle.xy);\n\n    // Collect enabled triangles\n    int pid0 = closest[circumID.y];\n    int pid1 = closest[circumID.z];\n    int pid2 = closest[circumID.w];\n    ivec3 pids = ivec3(pid0, pid1, pid2);\n    \n    // invalid particle id (-1)\n    if (any(lessThan(pids, ivec3(0))))\n        return;\n        \n    if (pid0 == pid1 || pid0 == pid2)\n        return;\n\n    vec2 pos0 = getParticle(iChannel0, iResolution.xy, pid0).xy;\n    vec2 pos1 = getParticle(iChannel0, iResolution.xy, pid1).xy;\n    vec2 pos2 = getParticle(iChannel0, iResolution.xy, pid2).xy;\n    vec2 v0 = pos1 - pos0;\n    vec2 v1 = pos2 - pos1;\n    vec2 v2 = pos0 - pos2;\n\n    // Calculate circum center by 2 Bisecting Normal\n    // the point where 2 Bisecting normals intersect is the center of circumcircle.\n    vec2 bn0 = vec2(-v0.y, v0.x);\n    vec2 bn1 = vec2(-v1.y, v1.x);\n    vec2 bp0 = (pos0 + pos1) * 0.5;\n    vec2 bp1 = (pos1 + pos2) * 0.5;\n    float t = cross2(bp1 - bp0, bn1) / cross2(bn0, bn1);\n    vec2 circumCenter = bp0 + bn0 * t;\n    float circumRadius = distance(circumCenter, pos0);\n\n    vec2 circumCenterClamp = clamp(circumCenter, vec2(0.0), iResolution.xy - vec2(1.0));\n    int [16] circumClosest = getClosest(iChannel1, circumCenterClamp);\n\n    // Check if any of the points are inside the circle\n    bool anyInside = false;\n    for (int n = ZERO; n < 5; n++) // really need 16 loops\n    {\n        int pid3 = circumClosest[n];\n        if (pid3 < 0)\n            break; // -1 is always at the tail.\n\n        if (any(equal(pids, ivec3(pid3))))\n            continue;\n\n        vec2 pos3 = getParticle(iChannel0, iResolution.xy, pid3).xy;\n        float dist = distance(pos3, circumCenter);\n        if (dist < circumRadius)\n        {\n            anyInside = true;\n            break;\n        }\n    }\n\n    if (anyInside)\n        return;\n    \n    // 3 points are included in the closestlist of each triangle point.(It means matching)\n    // The line that should be there disappears, but it can't be helped...\n    if (allEqual(getClosest(iChannel1, pos0), pids) &&\n        allEqual(getClosest(iChannel1, pos1), pids) &&\n        allEqual(getClosest(iChannel1, pos2), pids))\n    {\n        // Valid triangle\n        fragColor.xy = circumCenter;\n        fragColor.z = circumRadius;\n        fragColor.w = 1.0;\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"}]}