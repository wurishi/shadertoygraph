{"ver":"0.1","info":{"id":"ldyXR1","date":"1462820859","viewed":257,"name":"Noise zooming example","username":"piotrekli","description":"Examples of 'zooming' noise functions. Minecraft uses a similar method to generate biomes.\nEDIT 10.05.2016 - added comments and smootherMinecraftZoom()\nEDIT 21.02.2017 - fixed voronoiZoom() and perlinNoise()","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","fractal","voronoi","noise","perlin","minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXDEPTH 1000\n#define TWOPI 6.283185307179586\n\n// function from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat ivecnoise(ivec2 coord, int seed)\n{\n    return hash13(vec3(vec2(coord), seed));\n}\n\nvec2 circle(float angle)\n{\n    angle *= TWOPI;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlinNoise(vec2 coord, int seed)\n{\n    ivec2 cell = ivec2(coord);\n    if (coord.x < 0.0) cell.x--;\n    if (coord.y < 0.0) cell.y--;\n    vec2 posInCell = coord-vec2(cell);\n    float val00 = dot(circle(ivecnoise(cell+ivec2(0, 0), seed)), posInCell-vec2(0.0, 0.0));\n    float val01 = dot(circle(ivecnoise(cell+ivec2(0, 1), seed)), posInCell-vec2(0.0, 1.0));\n    float val10 = dot(circle(ivecnoise(cell+ivec2(1, 0), seed)), posInCell-vec2(1.0, 0.0));\n    float val11 = dot(circle(ivecnoise(cell+ivec2(1, 1), seed)), posInCell-vec2(1.0, 1.0));\n    vec2 mixAmount = posInCell*posInCell*posInCell*(posInCell*(posInCell*6.0-15.0)+10.0);\n    return mix(mix(val00, val10, mixAmount.x), mix(val01, val11, mixAmount.x), mixAmount.y);\n}\n\n// nearest-neighbour zoom, divides the plane into squares\nivec2 nearestZoom(ivec2 coord, int scale)\n{\n    return coord/scale;\n}\n\n// spreads pixels around 2x2 squares, creates islands and fuzzy borders\nivec2 spreadZoom(ivec2 coord, int baseSeed, int levels)\n{\n    coord *= 2;\n    for (int lvl=0; lvl<MAXDEPTH; ++lvl)\n    {\n        if (lvl >= levels) break;\n        ivec2 cell = coord/2;\n        int mv = int(ivecnoise(cell, baseSeed+lvl)*4.0);\n        if (mv==1 || mv==3) cell.x++;\n        if (mv==2 || mv==3) cell.y++;\n        coord = cell;\n    }\n    return coord;\n}\n\n// similar to spreadZoom, but never skips pixels\nivec2 minecraftZoom(ivec2 coord, int baseSeed, int levels)\n{\n    for (int lvl=0; lvl<MAXDEPTH; ++lvl)\n    {\n        if (lvl >= levels) break;\n        ivec2 cell = coord/2;\n        ivec2 cv = coord-cell*2;\n        int rv = int(ivecnoise(coord, baseSeed+lvl)*4.0);\n        if (cv.x==1) cell.x += rv/2;\n        if (cv.y==1) cell.y += rv-rv/2*2;\n        coord = cell;\n    }\n    return coord;\n}\n\n// like minecraftZoom, but never creates islands\nivec2 smootherMinecraftZoom(ivec2 coord, int baseSeed, int levels)\n{\n    for (int lvl=0; lvl<MAXDEPTH; ++lvl)\n    {\n        if (lvl >= levels) break;\n        ++baseSeed;\n        ivec2 cell = coord/2;\n        ivec2 mv = coord-cell*2;\n        if (mv.x==1 && mv.y==0) cell.x += int(ivecnoise(coord, baseSeed)*2.0);\n        else if (mv.y==1 && mv.x==0) cell.y += int(ivecnoise(coord, baseSeed)*2.0);\n        else if (mv.x==1 && mv.y==1)\n        {\n            int dir = int(ivecnoise(coord, baseSeed)*4.0);\n            if (dir==0 || dir==2) cell += ivec2(ivecnoise(ivec2(coord.x, dir-1+coord.y), baseSeed)*2.0, dir/2);\n            else cell += ivec2(dir/2, ivecnoise(ivec2(dir-2+coord.x, coord.y), baseSeed)*2.0);\n        }\n        coord = cell;\n    }\n    return coord;\n}\n\n// divides the plane into polygons\nivec2 voronoiZoom(ivec2 coord, int baseSeed, int size)\n{\n    ivec2 cell = coord/size;\n    vec2 posInCell = vec2(coord-cell*size)/float(size);\n    ivec2 newCell = cell;\n    float minDist2 = 4.0;\n    for (int i=-2; i<=2; ++i)\n        for (int j=-2; j<=2; ++j)\n        {\n            float cx = ivecnoise(cell+ivec2(i, j), baseSeed+0);\n            float cy = ivecnoise(cell+ivec2(i, j), baseSeed+1);\n            vec2 displacement = vec2(cx+float(i), cy+float(j))-posInCell;\n            float dist2 = dot(displacement, displacement);\n            if (dist2 < minDist2)\n            {\n                newCell = cell+ivec2(i, j);\n                minDist2 = dist2;\n            }\n        }\n    return newCell;\n}\n\n// warps using Perlin noise, makes anisotropy\nivec2 perlinNoiseWarp(ivec2 coord, int baseSeed, float strength, float scale)\n{\n    vec2 warpCoord = vec2(coord)/scale;\n    vec2 warpDisplacement = vec2(perlinNoise(warpCoord, baseSeed+0), perlinNoise(warpCoord, baseSeed+1));\n    return coord+ivec2(strength*warpDisplacement);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 c = ivec2(fragCoord.xy);\n    c += ivec2(0, iTime*300.0+2300.0);\n    c = minecraftZoom(c, 2, 5);\n    c = voronoiZoom(c, 4, 4);\n    c = perlinNoiseWarp(c, 3, 20.0, 30.0);\n    c = voronoiZoom(c, 4, 3);\n    c = spreadZoom(c, 9, 3);\n\tfragColor = vec4(ivecnoise(c, 0), ivecnoise(c, 1), ivecnoise(c, 2), 1.0);\n}","name":"Image","description":"","type":"image"}]}