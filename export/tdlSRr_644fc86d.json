{"ver":"0.1","info":{"id":"tdlSRr","date":"1550581990","viewed":539,"name":"Almost a Star","username":"martinsh","description":"'Gas giants are sometimes known as failed stars because they contain the same basic elements as a star.'\n\nMy attempt to swirl and distort a simplex noise to form somewhat believable turbulent clouds. Not a particularly fast shader","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["gasgiant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//attempt to simulate a semi-realistic gas giant\n//mostly based on Planet Funk by fizzer\n//https://www.shadertoy.com/view/XssGWN\n\n\n#define time iTime*0.8\n\nfloat gamma = 2.2;\nfloat scale = 1.0;\nfloat exposure = 7.0;\n\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n//changed this for my liking\nfloat fbm(vec3 p, vec3 n)\n{\n\tfloat f;\n    p = p*7.3;\n    f  = 0.60000*pow((simplex3D( p )),3.0)*0.7+0.8;\n    f += 0.35000*pow(abs(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(3.0))*1.0)),0.8 )*1.0; p = p*2.02;\n    f += 0.12500*pow(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*1.0),1.0 )*1.0; p = p*2.03;\n    f += 0.1250*(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*1.0) ); p = p*4.04;\n    f += 0.03125*(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*1.0) );\n\treturn f;\n}\n\n#define ONE vec2(1.0, 0.0)\n#define EPS vec2(1e-3, 0.0)\n\nconst float pi = 3.1415926;\n\nfloat N(vec2 p)\n{\n   p = mod(p, 4.0);\n   return fract(sin(p.x * 41784.0) + sin(p.y * 32424.0));\n}\n\nfloat smN2(vec2 p)\n{\n\tvec2 fp = floor(p);\n\tvec2 pf = smoothstep(0.0, 1.0, fract(p));\n\treturn mix( mix(N(fp), N(fp + ONE), pf.x), \n\t\t\t   mix(N(fp + ONE.yx), N(fp + ONE.xx), pf.x), pf.y);\n}\n\n\nfloat fbm2(vec2 p)\n{\n\tfloat f = 0.0, x;\n\tfor(int i = 1; i <= 9; ++i)\n\t{\n\t\tx = exp2(float(i));\n\t\tf += smN2(p * x) / x;\n\t}\n\treturn f;\n}\n\n// Scalar field for the surface undulations.\n\nfloat spots(vec2 p)//unused\n{\n\tp *= 2.5;\n\treturn smN2(p + EPS.xy * 2.0);\n}\n\nfloat field(vec2 p)\n{\n\tp *= 1.5;\n\treturn mix(smN2(p * 3.0), smN2(p * 4.0), 0.5 + 0.5 * cos(time * 0.02 + p.x*3.8 - 2.531)+ sin(time * 0.01 + p.y*4.2 + 1.536));\n}\n\nfloat field2(vec2 p)\n{\n\tp *= 6.5;\n\treturn mix(smN2(p * 2.0), smN2(p * 5.0), 0.5 + 0.5 * sin(time * 0.6 + p.x*2.0 + 83.123)+ cos(time * 0.5 + p.y*4.0 - 2.323));\n}\n\nfloat field3(vec2 p)\n{\n\tp *= 0.6;\n\treturn mix(smN2(p * 1.0), smN2(p * 2.0), 0.5 + 0.5 * cos(time * 0.5 + p.x*2.0 + 4.323));\n}\n\n// Vector field extracted from the scalar field.\nvec2 flow(vec2 p)\n{\n    vec2 flowout = vec2(0.0,0.0);\n\tfloat f0 = field(p);\n\tfloat f1 = field(p + EPS.xy);\n\tfloat f2 = field(p + EPS.yx);\n    flowout += (vec2(f1 - f0, f2 - f0)).yx * vec2(-1, 1) * 0.2;\n    float f20 = field2(p);\n\tfloat f21 = field2(p + EPS.xy);\n\tfloat f22 = field2(p + EPS.yx);\n    flowout += (vec2(f21 - f20, f22 - f20)).yx * vec2(-1, 1) * 0.05;\n    float f30 = field3(p);\n\tfloat f31 = field3(p + EPS.xy);\n\tfloat f32 = field3(p + EPS.yx);\n    flowout -= (vec2(f31 - f30, f32 - f30)).yx * vec2(-1, 1) * 0.1;\n\treturn flowout;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n    scale *= (1.0-(iMouse.y / iResolution.y))+0.5;\n    //exposure *= ((iMouse.x / iResolution.x))*0.5+0.01;\n    \n    vec2 R = iResolution.xy, \n         M = iMouse.xy/R;\n         U = (( U + U - R ) / R.y)*scale;     \n        \n    float l = length(U);\n    \n    vec3 N = vec3( U.x, U.y, sqrt(1.-l*l) );\n\n    vec2 uv = vec2(1.0-atan(N.z, N.x) / (2.0*pi),1.0-(atan(length(N.xz), N.y)) / pi);\n    uv.x -= ((iMouse.x / iResolution.x));   \n\tuv.x -= time*0.03+pow(cos(N.y*22.0)*0.03+0.97,2.5)*cos(N.y*1.0)*0.1;\n    \n\tconst int count = 5;\n    float csum = 0.0;\n    float wsum = 0.0;\n    \n\tfor(int i = 0; i < count; ++i)\n\t{\n\t\tfloat w = 1.0;\n        uv += flow(uv);\n        \n\t\tcsum += fbm(vec3(uv,time*0.002)*5.0, N) * 0.15 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n        csum += fbm(vec3(uv,time*0.002)*12.0, N) * 0.15 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n        csum += fbm(vec3(uv,time*0.002)*27.0, N) * 0.15 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n\n\t\twsum += w;\t\n\n\t}\n\n    \n \tO = vec4(1.0);\n    \n    //all artistic values below\n\tvec3 skyext = vec3(0.6, 0.5, 0.45)*0.1;//sky extinction\n    \n    vec3 color = vec3(0.1,0.2,0.2);\n    vec3 color1 = vec3(0.9,0.26,0.1)*0.7;\n    vec3 color2 = vec3(0.4,0.4,0.32)*0.3;\n    vec3 color3 = vec3(0.7,0.7,0.7);\n    \n    //mixing up the colors\n    vec3 planet = mix(color1,color3,pow(sin(uv.y*89.0-time*0.05)*0.5+0.5,2.5));\n    planet = mix(planet,color2,pow(sin(uv.y*25.0+0.3)*0.5+0.5,1.8));\n    planet = mix(color3,planet,pow(cos(uv.y*47.0)*0.5+0.5,0.5));\n    planet = mix(planet,planet*color,pow(cos(uv.y*9.0-1.3)*0.5+0.5,1.5));\n    \n    //more interesting mix between light and shadow\n    O.rgb = mix(vec3(0.2,0.7,1.0)*0.0005,planet,(pow(csum/wsum,2.9)*pow(N.z,1.5)*(-N.x*0.5+0.5)/skyext));\n\n    O.rgb *= exposure;\n    O *= smoothstep(0.,3./R.y,1.-l);//AA\n    O.rgb = pow(O.rgb,vec3(1.0/gamma));\n    //O.rgb = planet;\n    //O.rgb = vec3(uv.yy,0.0);\n}\n","name":"Image","description":"","type":"image"}]}