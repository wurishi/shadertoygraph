{"ver":"0.1","info":{"id":"dlXSRj","date":"1685395720","viewed":143,"name":"Asteroid field explorer","username":"tieutieu","description":"Hit an asteroid to land on it. SPACEBAR to get out of the asteroid. SHIFT for hyperspace. \nmyth0genesis's Simple & Fast DDA-Accelerated was an inspiration for that shader.\nI struggle with performance, feel free to drop some tips!\nEnjoy!","likes":4,"published":1,"flags":48,"usePreview":1,"tags":["ray","raymarch","space","dda","hash","march","asteroid","accelerated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n         \nfloat calculateAO(  in vec3 p,\n                    vec3 id,\n                    in vec3 n, \n                    float maxDist,\n                    float time,\n                    sampler2D iChannel1)\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n\t//const float falloff = .9;\n    for(float i=1.; i< nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        float dist = map( p + n*l, id, true, 1., time, iChannel1 ).x;\n        \n        ao += (l - dist)/(1. + l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1. - ao/nbIte, 0., 1.);\n}\n\n\n\n// https://www.shadertoy.com/view/Xs33Df\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = .001;\n    \n    p *= 7.0;\n    \n    vec3 p_offsetX = vec3(p.x - eps, p.y      , p.z      );\n    vec3 p_offsetY = vec3(p.x      , p.y - eps, p.z      );\n    vec3 p_offsetZ = vec3(p.x      , p.y      , p.z - eps);\n    \n    vec3 grad = vec3( getGrey( tex3D(tex, p_offsetX, nor) ),\n                      getGrey( tex3D(tex, p_offsetY, nor) ),\n                      getGrey( tex3D(tex, p_offsetZ, nor) ));\n    \n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\nfloat BinarySubdivisionDDA( in vec3 rO, \n                            in vec3 rD, \n                            vec2 t, \n                            vec3 id, \n                            float complexify,\n                            float time,\n                            sampler2D ch_displace)\n{\n    float halfwayT;\n  \n    for (int i = 0; i < 5; i++)\n    {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = map(  rO + rD*halfwayT,\n                        id,\n                        true,\n                        complexify,\n                        time,\n                        ch_displace).x; \n                                              \n                        \n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.00, d));\n    }\n\n\treturn halfwayT;\n}\n\n\nvec3 getNormal( vec3 p,\n                vec3 id,\n                float complexify,\n                float time,\n                sampler2D ch_displace)\n{\n\n    vec2 e = vec2(-1., 1.)*SAMPLE_NORMAL_VALUE;   \n\treturn normalize(     e.yxx*map(p + e.yxx,id , true,complexify,time,ch_displace).x \n                        + e.xxy*map(p + e.xxy,id , true,complexify,time,ch_displace).x \n                        + e.xyx*map(p + e.xyx,id , true,complexify,time,ch_displace).x \n                        + e.yyy*map(p + e.yyy,id , true,complexify,time,ch_displace).x );         \n\n}\n\n\nvec4 iPlane(vec3 ro, vec3 rd, vec3 offst) {\n    vec3 pRes = (-ro + offst) / rd;\n    float md = min(min(pRes.x, pRes.y), pRes.z);\n    \n    // .xyz values return a factor to mask out the next potential cell ID's offset\n    // If plane in x direction is closest, .xyz = vec3(1.0, 0.0, 0.0)\n    // If plane in y direction is closest, .xyz = vec3(0.0, 1.0, 0.0)\n    // If plane in z direction is closest, .xyz = vec3(0.0, 0.0, 1.0)\n    // .w returns distance to closest plane\n    return vec4(vec3(equal(pRes, vec3(md))), md);\n}\n\nvec4 rayMarchDDA(   inout vec3 ro,\n                    vec3 rd,\n                    vec3 id,\n                    vec3 rdsgn,\n                    out bool sdfht,\n                    out vec3 pf,\n                    float time,\n                    sampler2D ch_color,\n                    sampler2D ch_displace)\n{\n\n    bool is_inside = false;\n    bool plnht = false;\n    vec3 mf = max(rdsgn, 0.0);  // The amount to offset the plane position from the cell by (determined by ray direction)\n    vec3 qo = id + mf;          // The cell's planes' positions (along each of their respective axes)\n    vec4 hRes = iPlane(ro, rd, qo);\n    pf = hRes.xyz;\n    \n    float dO = 0.0;\n    float ns = 0.0;  \n\n    float complexify = 1.;\n    float t_old;\n    float t;\n    vec2 res;\n    for(int i = 0; i < maxstps; i++) {\n    \n        ns += 1.0;\n        \n        vec3 p = ro + rd * dO;\n\n\n        res = map(  p, \n                    id , \n                    true, \n                    complexify, \n                    time, \n                    ch_displace);\n                    \n        float dS = res.x;\n        \n        //analyse closest dist\n        is_inside = dS < -0.0001;\n        sdfht     = abs(dS) < mindst;\n        \n        //SAVE AND UPDATE StAte\n        t_old = t;\n        t     = dO;\n        \n        dO += dS;\n\n        //analyse next dist\n        plnht = dO > hRes.w;        \n \n\n        if( sdfht || plnht || is_inside) break;\n    }\n\n\n    \n    if( ( RAY_MARCH_BINARY_SUBDIVISION == 1 )&&( is_inside == true ) )\n    {\n       dO = BinarySubdivisionDDA(  ro, \n                                   rd, \n                                   vec2(t_old,t),\n                                   id,\n                                   complexify,\n                                   time,\n                                   ch_displace);\n                                   \n       sdfht = true;\n    } \n    \n    \n    // If a plane is hit, set ro to the plane's hit position\n    // If a plane isn't hit, set ro to the pixel's starting position to calculate normals\n    ro = plnht ? (ro + rd * hRes.w) : ro;\n    \n    // y returns distance to the closest plane\n    // z returns the number of steps the ray marcher took (both for debugging)\n    return vec4(dO, hRes.w, ns, res.y);\n}\n\n\nvec3 get_asteroid_field_color( vec3 p, \n                               vec3 n,\n                               mat4 mCam, \n                               float objHit, \n                               vec3 colorBase,\n                               sampler2D ch_color,\n                               float dist,\n                               bool land_walk_mode)\n{\n\n    vec3 id = floor(p);\n    mat4 m = get_asteroid_matrix( id, iTime );\n    \n    //vec3 color = get_asteroid_color_triplanar( m, p , 0.2+ 7., ch_color );\n    \n    float scale_in_land  = 60.;\n    float scale_in_space = 7.2;\n    \n    float scale_texture = 1.;\n    if( land_walk_mode )\n        scale_texture = scale_in_land;\n    else\n        scale_texture = scale_in_space;\n    \n    vec3 color = get_asteroid_color_tex3D( m, p, n , scale_texture, ch_color ); //7.2\n   \n    if( DEPTH_COLOR == 1 ){\n        color.x *= 1. - clamp(length(p - vec3( mCam[3][0], mCam[3][1], mCam[3][2] )-5. )/(DEPTH + 0. ),0.,1.);\n        color.y *= 1. - clamp(length(p - vec3( mCam[3][0], mCam[3][1], mCam[3][2] )-5. )/(DEPTH + 2. ),0.,1.);\n        color.z *= 1. - clamp(length(p - vec3( mCam[3][0], mCam[3][1], mCam[3][2] )-5. )/(DEPTH + 5.),0.,1.);\n    }\n    \n    float pn_bright    = clamp( perlin_noise(id*0.09)*2.+1., 1. , 2. );    \n    color *= pn_bright;\n        \n    \n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Get saved values\n    float travel_speed  = texelFetch( iChannel0, ivec2(8,0),0 ).x;\n\n    mat4 mCam;\n    mCam[0]= texelFetch( iChannel0, ivec2(0,0),0 );\n    mCam[1]= texelFetch( iChannel0, ivec2(1,0),0 );\n    mCam[2]= texelFetch( iChannel0, ivec2(2,0),0 );\n    mCam[3]= texelFetch( iChannel0, ivec2(3,0),0 ); \n\n    // Init info\n    vec3 dir_light   = vec3(-1.,-1.,-1.);\n    dir_light = normalize(dir_light);\n    \n    float sun_size = 0.0005;\n    float sun_sharpness = 6.;\n    vec3 sun_color = vec3(1.);\n    \n    // Init ray marching info\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float focal = 1.0 * max(1.0, travel_speed/(TRAVEL_STEP_SPACE*2.));\n    vec3 ro = mCam[3].xyz;\n    vec3 rayDirection = mCam[2].xyz*-1.0 + uv.x*mCam[0].xyz *focal + uv.y*mCam[1].xyz*focal;\n    vec3 rd = normalize(rayDirection);\n\n\n\n    // Draw\n    vec3 col         = vec3(0.,0.,0.);\n    \n    if( BACKGROUND == 1){\n        \n        // Draw stars\n        vec3 p_to_world = rd;\n        vec2 uv_cyclo = vec2(  atan(rd.x, rd.z )/pi*900. , rd.y/2.*900.);\n\n        col +=  vec3( clamp(perlin_noise(uv_cyclo.xyx)*4.0-1.5, 0., 1. ) );\n\n        // Draw sun       \n        sun_size = 0.02;\n        sun_sharpness = 7.;\n        sun_color = vec3(0.8,0.8,0.9)*0.7;\n        col += sun_color *  pow( clamp(dot(dir_light , rd )-( 1.0 - sun_size), 0. , 1. )*(1./sun_size) , sun_sharpness )  ;\n        col += sun_color *  pow( clamp(dot(dir_light , rd )-( 1.0 - sun_size), 0. , 1. )*(1./sun_size) , sun_sharpness )  ;\n\n        sun_size = 0.00005;\n        sun_sharpness = 6.;\n        sun_color = vec3(1.);\n        col += sun_color *  pow( clamp(dot(dir_light , rd )-( 1.0 - sun_size), 0. , 1. )*(1./sun_size) , sun_sharpness )  ;\n        col += sun_color *  pow( clamp(dot(dir_light , rd )-( 1.0 - sun_size), 0. , 1. )*(1./sun_size) , sun_sharpness )  ;\n\n\n        // Draw planete   \n        vec3 dir_neptune = normalize(vec3(1.,0.,0.));\n        float neptune_size = 0.2;\n        float neptune_sharpness =6.;\n        vec3 neptune_color = vec3(0.2,0.3,0.7);\n\n        vec3 neptune_col_out = neptune_color *  pow( clamp(dot(dir_neptune , rd )-( 1.0 - neptune_size), 0. , 1. )*(1./neptune_size) , neptune_sharpness )  ;\n        col += neptune_col_out *0.5;\n        if( 0.2 < neptune_col_out.z)\n            col = neptune_col_out;\n\n    }\n  \n\n    // Raymarch DDA-Accelerated    \n    // Copy from myth0genesis's Simple & Fast DDA-Accelerated RM shader https://www.shadertoy.com/view/DtsSWS     \n    vec3 sgn = sign(rd);\n    bool sdfhit = false;\n    vec3 id = floor(ro);\n    vec3 plnmask;\n    vec4 mRes = vec4(0.0);\n      \n    uvec4 hsh;\n    bvec4 hshtst0;\n    for (int i = 0; i < maxcells; i++) {\n        hsh = hash128(floatBitsToUint(vec4(id, 1.0)));\n        hshtst0 = bvec4(hsh & 1U);\n        \n        // If a cell boundary is hit, raymarch from that position in the next step\n        mRes = rayMarchDDA( ro, \n                            rd, \n                            id, \n                            sgn, \n                            sdfhit, \n                            plnmask, \n                            iTime, \n                            iChannel1, \n                            iChannel2);\n        if (sdfhit) break;\n        \n        id += sgn * plnmask; // Advance cell ID with a mask determined by plane intersection function\n    }\n    \n    // Get geometry point\n    vec3 p = ro + rd * mRes.x;\n    \n    id = floor(p);\n    bool land_walk_mode = false;\n    if( ( travel_speed == TRAVEL_STEP_SURFACE )&&(id == floor(mCam[3].xyz) ) )\n        land_walk_mode = true;\n    \n    \n    // Get geometry normal\n    float complexify = 1.;\n    vec3 n = getNormal( p, \n                        id, \n                        complexify, \n                        iTime, \n                        iChannel2);\n\n    // Get geometry ambiant occlusion\n    float ao = 1.;\n    if( OCCLUSION == 1 )\n    {\n        ao = calculateAO( p, id, n,8.71, iTime, iChannel1  );\n        ao = smoothstep( 0.3, 0.97, pow(ao,10.))+0.05;\n    }\n        \n    \n    // Get geometry normal with bump map\n    id = floor(p);\n    if( ( BUMP == 1)&&(land_walk_mode))\n    {\n        mat4 m_current = get_asteroid_matrix( id, iTime );\n        n = doBumpMap(iChannel1, (inverse(m_current)*vec4(p,1.)*1.).xyz, n, 0.004);//.007/(1. + t/FAR));\n    }\n    // Get geometry light\n    float dif = 1.;\n    if( LIGHT == 1){\n        dif = dot(n, dir_light) * 0.5 + 0.5;\n        dif =  smoothstep( \t0.3,0.7, dif)+0.2;\n    }\n        \n    // Get geometry color\n    vec3 color_base = vec3(1.);\n    if( TEXTURE == 1 )\n        color_base = get_asteroid_field_color( p,\n                                               n,\n                                               mCam, \n                                               mRes.w,\n                                               col, \n                                               iChannel1, \n                                               mRes.x,\n                                               land_walk_mode);\n    \n\n    // Geometry info into color\n    vec3 compute_color = color_base;\n    compute_color *= ao;\n    compute_color *= dif;\n\n    // Add background into color\n    col = sdfhit ? compute_color : col;\n    \n    // Add lens flare effect into color\n    if( LENS_FLARE == 1 ){\n        vec3 rd_lens = dir_light;\n        ro = mCam[3].xyz;\n\n        sgn = sign(rd_lens);\n        sdfhit = false;\n        id = floor(ro);\n        plnmask;\n        mRes = vec4(0.0);\n\n        int maxcells_lens = 10;\n\n        for (int i = 0; i < maxcells_lens; i++) {\n            hsh = hash128(floatBitsToUint(vec4(id, 1.0)));\n            hshtst0 = bvec4(hsh & 1U);\n\n            // If a cell boundary is hit, raymarch from that position in the next step\n            mRes = rayMarchDDA(ro, rd_lens, id, sgn, sdfhit, plnmask, iTime, iChannel1, iChannel2);\n            if (sdfhit) break;\n\n            id += sgn * plnmask; // Advance cell ID with a mask determined by plane intersection function\n        }\n\n        sun_size = 0.04;\n        sun_sharpness = 7.;\n        sun_color = vec3(0.8,0.8,0.9)*0.7; \n\n        if( sdfhit == false ){\n            /*\n            //GET BACK UV COORDS FROM LIGHT\n            vec3 vCamDir   = mCam[2].xyz*-1.;\n            vec3 vLightDir = dir_light;\n            vLightDir *= dot(vCamDir,vLightDir);\n\n            vec3 screenVector = vLightDir - vCamDir;\n\n            vec2 uv_light_coods;\n            uv_light_coods.x = clamp( dot(screenVector,normalize(mCam[0].xyz))/focal*1.25, -iResolution.x/iResolution.y, iResolution.x/iResolution.y );\n            uv_light_coods.y = clamp( dot(screenVector,normalize(mCam[1].xyz))/focal*1.25, -1., 1. );\n\n            col += flare(uv,uv_light_coods.xy, sun_color,0.5);\n            */\n            col += sun_color *  pow( clamp(dot(dir_light , rd )-( 1.0 - sun_size), 0. , 1. )*(1./sun_size) , sun_sharpness )  ;\n        }\n    }\n  \n    fragColor = vec4(col.x, col.y, col.z, 1.);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// keyboard input\nconst int KEY_LEFT     = 37;\nconst int KEY_UP       = 38;\nconst int KEY_RIGHT    = 39;\nconst int KEY_DOWN     = 40;\nconst int KEY_W        = 87;\nconst int KEY_S        = 83;\nconst int KEY_A        = 65;\nconst int KEY_D        = 68;  \nconst int KEY_SHIFT    = 16; \nconst int KEY_SPACEBAR = 32;\nconst int KEY_ALT      = 18;\nconst int KEY_F        = 70; \n\nconst int start_time = 10;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init variable\n    mat4 mCam_init;\n    mCam_init[0]= vec4( 1, 0, 0, 0);\n    mCam_init[1]= vec4( 0, 1, 0, 0);\n    mCam_init[2]= vec4( 0, 0, 1, 0);\n    mCam_init[3]= vec4( 0.5,1.0,5.5, 1.);\n        \n    mat4 mCamUserLook;\n    mCamUserLook[0]= vec4( 1, 0, 0, 0);\n    mCamUserLook[1]= vec4( 0, 1, 0, 0);\n    mCamUserLook[2]= vec4( 0, 0, 1, 0);\n    mCamUserLook[3]= vec4( 0.,0.,0, 1.);    \n    \n    mat4 m_relative;\n    m_relative[0] = vec4(1.,0.,0.,0.);\n    m_relative[1] = vec4(0.,1.,0.,0.);\n    m_relative[2] = vec4(0.,0.,1.,0.);\n    m_relative[3] = vec4(0.,0.,0.,1.);\n        \n    vec4 iMouseLast = iMouse;   \n    int navigation_mode = 0;   \n    vec3 snap_id = vec3(99999.99);\n    float travel_speed = TRAVEL_STEP_SPACE;    \n    int transition_count = 0; \n    vec3 space_up_ref = vec3(0.,1.,0.);\n    bool mouse_move_first = false;\n     \n    // Fill variable with buffer0 \n    if( start_time < iFrame ){   \n        \n        mCam_init[0] = texelFetch( iChannel0, ivec2(0,0),0 );\n        mCam_init[1] = texelFetch( iChannel0, ivec2(1,0),0 );\n        mCam_init[2] = texelFetch( iChannel0, ivec2(2,0),0 );\n        mCam_init[3] = texelFetch( iChannel0, ivec2(3,0),0 );\n        \n\n        mCamUserLook[0]= texelFetch( iChannel0, ivec2(20,0),0 ) ;\n        mCamUserLook[1]= texelFetch( iChannel0, ivec2(21,0),0 ) ;\n        mCamUserLook[2]= texelFetch( iChannel0, ivec2(22,0),0 ) ;\n        mCamUserLook[3]= texelFetch( iChannel0, ivec2(23,0),0 ) ; \n\n        m_relative[0] = texelFetch( iChannel0, ivec2(9 ,0),0 ) ;\n        m_relative[1] = texelFetch( iChannel0, ivec2(10,0),0 ) ;\n        m_relative[2] = texelFetch( iChannel0, ivec2(11,0),0 ) ;\n        m_relative[3] = texelFetch( iChannel0, ivec2(12,0),0 ) ;\n        \n        iMouseLast       = texelFetch( iChannel0, ivec2(5,0),0 );\n        snap_id          = texelFetch( iChannel0, ivec2(7,0),0 ).xyz; \n        travel_speed     = texelFetch( iChannel0, ivec2(8,0),0 ).x;\n        navigation_mode  = int(texelFetch( iChannel0, ivec2(15,0),0 ).x );    \n        transition_count = int(texelFetch( iChannel0, ivec2(24,0),0 ).x ) ;           \n        space_up_ref     = texelFetch( iChannel0, ivec2(25,0),0 ).xyz;   \n        mouse_move_first = bool(texelFetch( iChannel0, ivec2(4,0),0 ).x);\n    }\n    \n    \n    // Get keyboard variable\n    float moveFront          = travel_speed*texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x;\n    float moveBack           = travel_speed*texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x *-1.;\n    float moveRight          = travel_speed*texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x;\n    float moveLeft           = travel_speed*texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x *-1.;  \n    float hyperspace_pressed = texelFetch( iChannel1, ivec2(KEY_SHIFT,0), 0 ).x;\n    float lift_off_pressed   = texelFetch( iChannel1, ivec2(KEY_SPACEBAR,0), 0 ).x;\n\n\n    // Analize mouse mouvement\n    if( ( iMouse != iMouseLast )&&(mouse_move_first == false))\n        mouse_move_first = true;\n    else\n        mouse_move_first = false;\n        \n\n    // Camera add keyboard navigation \n    mat4 mCam= mCam_init;\n    mCam[3].xyz += mCam[2].xyz * moveFront; \n    mCam[3].xyz += mCam[2].xyz * moveBack; \n    mCam[3].xyz += mCam[0].xyz * moveRight; \n    mCam[3].xyz += mCam[0].xyz * moveLeft; \n    \n    \n    // Camera add keyboard navigation\n    vec3 current_id  = floor(mCam[3].xyz);\n        \n    mat4 m_asteroid = get_asteroid_matrix( current_id, iTime); \n    \n    float asteroid_ray = length(m_asteroid[0]);\n    \n    \n    if( 0. < hyperspace_pressed )//navigation________________________________HYPERSPACE\n    {\n    \n        navigation_mode = 0;\n        travel_speed += (TRAVEL_STEP_HYPERSPACE-travel_speed)*0.05;\n    \n    }\n    else if( 0.01 < (travel_speed - TRAVEL_STEP_SPACE) )//navigation________________________________HYPERSPACE2\n    {\n        travel_speed += (TRAVEL_STEP_SPACE - travel_speed)*0.1;\n    }\n    else if( navigation_mode == 0 )//navigation________________________________SPACE\n    {\n        travel_speed    = TRAVEL_STEP_SPACE;\n        \n        if( 0.001 < asteroid_ray ){\n             \n            //GET COL\n            vec3  v_col = mCam[3].xyz - m_asteroid[3].xyz;\n            float v_col_length = length(v_col);\n            float v_col_to_apply = asteroid_ray - v_col_length;\n\n            //CAMERA COLLISION\n            if( 0. < v_col_to_apply )\n            {\n                \n                //CHANGE STATE\n                navigation_mode = 2; //navigation: SPACE to sufrace\n                snap_id         = current_id;\n                            \n                //APPLY COLLISION\n                v_col = normalize(v_col);\n                v_col *= v_col_to_apply;\n                \n                mCam[3].xyz += v_col;\n                \n               \n                //SAVE RELATIVE MATRIX\n\n                m_asteroid = matrix_orthogonize(m_asteroid,2,1);\n                m_asteroid = matrix_normalize(m_asteroid);\n\n                mCam = matrix_orthogonize(mCam,2,1);\n                mCam = matrix_normalize(mCam); \n                \n                m_relative = inverse(m_asteroid)*mCam;\n\n\n            }\n       }\n\n        //CAMERA ROTATION WITH MOUSE - touch sreen   pointer dir - video game\n\n        if( mouse_move_first == false ){\n            vec4 vMouse = iMouse - iMouseLast;\n            vMouse = vMouse * CAMERA_MOUSE_ROTATION_POWER;\n         \n            mCam[1].xyz = space_up_ref;\n            mCam[2].xyz += vMouse.y * mCam[1].xyz + vMouse.x * mCam[0].xyz;\n           \n            mCam = matrix_orthogonize( mCam, 2, 1 );  \n            mCam = matrix_normalize(mCam); \n      \n        }  \n        \n        transition_count = 0;\n    }\n    else if( navigation_mode == 2 ){ //navigation________________________________SPACE TO SUFRACE\n    \n        travel_speed    = TRAVEL_STEP_SURFACE;\n\n        m_asteroid = matrix_orthogonize(m_asteroid,2,1);\n        m_asteroid = matrix_normalize(m_asteroid);\n\n\n        //SNAP TO THE ROTATION\n        mat4 mCam_delta = inverse(mCam_init)*mCam;\n        \n        mCam = m_asteroid*m_relative*mCam_delta;\n        \n        \n        //SNAP TO THE GROUND  \n        \n        vec3  v_col = mCam[3].xyz - m_asteroid[3].xyz;\n        v_col = normalize(v_col)*asteroid_ray;\n        mCam[3].xyz =  m_asteroid[3].xyz + v_col;\n        \n \n        \n        //FOLLOW THE SURFACE ORIENT\n        mat4 mCam_afterSnap = mCam; \n             \n        mCam_afterSnap[1].xyz = normalize(v_col);\n        mCam_afterSnap = matrix_orthogonize(mCam_afterSnap,1,2);\n        mCam_afterSnap = matrix_normalize(mCam_afterSnap);  \n        \n        float mixfactor = 0.1;\n        mCam = (mCam * (1.0 - mixfactor)) + (mCam_afterSnap * mixfactor);\n        mCam = matrix_orthogonize(mCam,1,2);\n        mCam = matrix_normalize(mCam);  \n               \n   \n        //SAVE RELATIVE\n        m_relative = inverse(m_asteroid)*mCam;\n        \n        transition_count += 1;\n        if( 20 < transition_count )\n            navigation_mode = 1;\n   \n    } \n    else if( navigation_mode == 1 ){//navigation________________________________SURFACE\n    \n        travel_speed    = TRAVEL_STEP_SURFACE;\n        \n        transition_count = 0;\n\n\n        m_asteroid = matrix_orthogonize(m_asteroid,2,1);\n        m_asteroid = matrix_normalize(m_asteroid);\n\n\n        //SNAP TO THE ROTATION\n        mat4 mCam_delta = inverse(mCam_init)*mCam;\n        \n        mCam = m_asteroid*m_relative*mCam_delta;\n \n        \n        //SNAP TO THE GROUND\n        vec3  v_col = mCam[3].xyz - m_asteroid[3].xyz;\n        v_col = normalize(v_col)*asteroid_ray;\n        mCam[3].xyz =  m_asteroid[3].xyz + v_col;\n        \n        //SNAP TO THE GROUND 2\n        if( WALK_ON_SUFRACE_FOLLOW_RELIEF == 1 )\n        {      \n            float dist_from_ground = map( mCam[3].xyz,\n                                          current_id,\n                                          true,\n                                          1.,                                          \n                                          iTime,\n                                          iChannel3).x;\n\n            vec3  v_col2 = normalize(m_asteroid[3].xyz - mCam[3].xyz)*dist_from_ground;\n            mCam[3].xyz =  mCam[3].xyz + v_col2*0.5;       \n        }\n        \n        //FOLLOW THE SURFACE ORIENT\n        mCam[1].xyz = normalize(v_col);\n        mCam = matrix_orthogonize(mCam,1,2);\n        mCam = matrix_normalize(mCam);  \n        \n       \n        //USER LOOK A       \n        mCam = mCam*mCamUserLook;\n        \n        if( mouse_move_first == false ){\n            vec4 vMouse = iMouse - iMouseLast;\n            vMouse = vMouse * CAMERA_MOUSE_ROTATION_POWER;\n            mCam[2].xyz += vMouse.y * mCam[1].xyz + vMouse.x * mCam[0].xyz;\n\n            mCam[1].xyz = vec3(0.,1.,0.);\n            mCam = matrix_orthogonize( mCam, 2, 1 );  \n            mCam = matrix_normalize(mCam);    \n        }\n        \n        mat4 mCam_afterUserLook = mCam;\n         \n      \n        //FOLLOW THE SURFACE ORIENT\n        mCam[1].xyz = normalize(v_col);\n        mCam = matrix_orthogonize(mCam,1,2);\n        mCam = matrix_normalize(mCam);  \n        \n        \n        //SAVE RELATIVE\n        m_relative = inverse(m_asteroid)*mCam;  \n        \n       \n        //INJECT BACK THE UP LOOK\n        mat4 mCam_beforUserLook = mCam;\n        \n        mCam[2] = mCam_afterUserLook[2];\n        mCam = matrix_orthogonize(mCam,2,0);\n        mCam = matrix_normalize(mCam);          \n        \n        \n        //SAVE USER LOOK\n        mCamUserLook = inverse(mCam_beforUserLook)*mCam;\n        \n        \n        //LIFT OFF\n        if( 0. < lift_off_pressed )\n        {\n            navigation_mode = 0;\n            mCam[3].xyz += (mCam[3].xyz - m_asteroid[3].xyz)*0.15;\n            space_up_ref = mCam[1].xyz;\n            travel_speed    = TRAVEL_STEP_SPACE;\n        }\n\n    }\n  \n  \n  \n    //SET OUTPUT\n    if( floor(fragCoord.y) == 0. ){\n        if( floor(fragCoord.x) == 0.  ) fragColor = mCam[0]; \n        if( floor(fragCoord.x) == 1.  ) fragColor = mCam[1];\n        if( floor(fragCoord.x) == 2.  ) fragColor = mCam[2];\n        if( floor(fragCoord.x) == 3.  ) fragColor = mCam[3];\n\n        if( floor(fragCoord.x) == 20. ) fragColor = mCamUserLook[0];\n        if( floor(fragCoord.x) == 21. ) fragColor = mCamUserLook[1];\n        if( floor(fragCoord.x) == 22. ) fragColor = mCamUserLook[2];\n        if( floor(fragCoord.x) == 23. ) fragColor = mCamUserLook[3];\n\n        if( floor(fragCoord.x) == 9.  ) fragColor = m_relative[0];\n        if( floor(fragCoord.x) == 10. ) fragColor = m_relative[1];\n        if( floor(fragCoord.x) == 11. ) fragColor = m_relative[2];\n        if( floor(fragCoord.x) == 12. ) fragColor = m_relative[3];\n        \n             \n        if( floor(fragCoord.x) == 5.  ) fragColor = iMouse;\n        if( floor(fragCoord.x) == 7.  ) fragColor.xyz = snap_id; \n        if( floor(fragCoord.x) == 8.  ) fragColor.x   = travel_speed;\n        if( floor(fragCoord.x) == 15. ) fragColor.x = float(navigation_mode);\n        if( floor(fragCoord.x) == 24. ) fragColor.x = float(transition_count);\n        if( floor(fragCoord.x) == 25. ) fragColor.xyz = space_up_ref;\n        if( floor(fragCoord.x) == 4.  ) fragColor.x = float(mouse_move_first);\n              \n    }\n      \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n\n\n\n\n\n\n\n\n\n// Constants\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\nconst uvec4 MB2 = uvec4(0x55555555U, 0xAAAAAAAAU, 0x33333333U, 0xCCCCCCCCU);\nconst float isq3 = 1.0 / sqrt(3.0);\nconst float sq3d3 = 0.57735025882720947265625;\nconst float sqrt2 = sqrt(2.0);\nconst float sqrt2d2 = sqrt2 * 0.5;\n\nconst float imf = 1.0 / float(0x7FFFFFFFU);\n\n\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nmat4 m_asteroid_init = mat4(0.5,0.,0.,0. , 0.,0.5,0.,0. , 0.,0.,0.5,0. , 0.5,0.5,0.5,1.);\n\n\n\n// Visual aspect\n#define DEPTH 100.\n#define DEPTH_COLOR 1\n#define ANIM 1\n\n#define DISPLACEMENT_VALUE -0.05 \n#define DISPLACEMENT_SCALE 1.65\n#define IMPACT_NBR_MAX 4 \n\n// Render raymarch DDA-Accelerated parameters\n//Copy from myth0genesis's Simple & Fast DDA-Accelerated RM shader https://www.shadertoy.com/view/DtsSWS\nconst int maxstps = 128; //128\nconst int maxcells = 100;\nconst float mindst = 0.0001;\n\n// Render parameters\n#define RAY_MARCH_BINARY_SUBDIVISION 1\n\n#define SAMPLE_NORMAL_VALUE .001\n\n// Navigation parameters\n#define TRAVEL_STEP_HYPERSPACE 1.\n#define TRAVEL_STEP_SPACE 0.1\n#define TRAVEL_STEP_SURFACE 0.001\n\n#define CAMERA_MOUSE_ROTATION_POWER -0.008\n#define WALK_ON_SUFRACE_FOLLOW_RELIEF 1\n\n// Debug field\n#define FIELD_POSITION_VARIATION 1\n#define FIELD_SCALE_VARIATION 1\n#define FIELD_VISIBILITY_VARIATION 1\n\n// Debug geometry steps\n#define GEOMETRY_ADD_DISPLACE 1\n#define GEOMETRY_ADD_IMPACTS 1\n\n// Debug draw steps\n#define BACKGROUND 1\n#define BUMP 1\n#define LIGHT 1\n#define TEXTURE 1 \n#define OCCLUSION 1\n#define LENS_FLARE 1\n\n\n\n// Functions utils - Hash\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\n\n\n//myth0genesis's collision-free 128-bit hash: https://www.shadertoy.com/view/ctXXRn\nuvec4 hash128(uvec4 p) {\n    p *= uvec4(0xCAF649A9U, 0x735A2D97U, 0xD35A2D97U, 0x450C2D35U);\n    uvec4 m0 = p & MB2.x;\n    uvec4 m1 = p & MB2.y;\n    p = m0 | m1.yzwx;\n    p ^= p >> 16;\n    p *= uvec4(0xEAF649A9U, 0x6AF649A9U, 0x050C2D35U, 0xAAF649A9U);\n    m0 = p & MB2.x;\n    m1 = p & MB2.y;\n    p = m0 | m1.zwxy;\n    p ^= p >> 15;\n    p *= uvec4(0x21F0AAADU, 0x0D0C2D35U, 0xE8F649A9U, 0xD30332D3U);\n    m0 = p & MB2.z;\n    m1 = p & MB2.w;\n    p = m0 | m1.wxyz;\n    p *= uvec4(0xC865C965U, 0x4D0C2D35U, 0x930332D3U, 0x410C2D35U);\n    p ^= p >> 16;\n    return p;\n}\n\n\n\n// Functions utils - matrix\n\nmat4 matrix_rotation(mat4 mBase, vec3 axis, float angle)\n{\n\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    vec3 vx = vec3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s);\n    vec3 vy = vec3(oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s);\n    vec3 vz = vec3(oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n    \n    vx *= length(mBase[0].xyz);\n    vy *= length(mBase[1].xyz);\n    vz *= length(mBase[2].xyz);\n    \n    \n    mat4 mRot = mat4(vx.x,       vx.y,       vx.z,       mBase[0].w,\n                     vy.x,       vy.y,       vy.z,       mBase[1].w,\n                     vz.x,       vz.y,       vz.z,       mBase[2].w,\n                     mBase[3].x, mBase[3].y, mBase[3].z, mBase[3].w);\n                   \n    return mRot;\n}\n\nmat4 matrix_normalize( mat4 in_matrix )\n{\n    in_matrix[0].xyz = normalize(in_matrix[0].xyz);\n    in_matrix[1].xyz = normalize(in_matrix[1].xyz);\n    in_matrix[2].xyz = normalize(in_matrix[2].xyz);\n    \n    return in_matrix;\n}\n\nmat4 matrix_orthogonize( mat4 in_matrix, int axePriorityA, int axePriorityB )\n{\n    \n    vec3 len_axes = vec3(  length(in_matrix[0].xyz),\n                           length(in_matrix[1].xyz),\n                           length(in_matrix[2].xyz) );\n    \n    ivec4 axeP = ivec4( axePriorityA, axePriorityB,-1,0 );\n    if( (axeP.x == 0)&&(axeP.y == 1) )axeP.zw = ivec2(2,-1);//-1 -1 \n    if( (axeP.x == 0)&&(axeP.y == 2) )axeP.zw = ivec2(1, 1);// 1  1\n    if( (axeP.x == 1)&&(axeP.y == 0) )axeP.zw = ivec2(2, 1);// 1  1\n    if( (axeP.x == 1)&&(axeP.y == 2) )axeP.zw = ivec2(0,-1);//-1 -1\n    if( (axeP.x == 2)&&(axeP.y == 1) )axeP.zw = ivec2(0, 1);// 1  1\n    if( (axeP.x == 2)&&(axeP.y == 0) )axeP.zw = ivec2(1,-1);//-1 -1\n    \n    in_matrix[axeP.z].xyz = cross( in_matrix[axeP.y].xyz, in_matrix[axeP.x].xyz );\n    if(axeP.w == -1 )\n        in_matrix[axeP.z].xyz *= -1.;\n    in_matrix[axeP.y].xyz = cross( in_matrix[axeP.x].xyz, in_matrix[axeP.z].xyz );\n    if(axeP.w == -1 )\n        in_matrix[axeP.y].xyz *= -1.;    \n    \n    \n    in_matrix = matrix_normalize( in_matrix );\n    \n    in_matrix[0].xyz *= len_axes.x;\n    in_matrix[1].xyz *= len_axes.y;\n    in_matrix[2].xyz *= len_axes.z;\n    \n    return in_matrix;\n}\n\n\nmat4 matrix_offset( mat4 m, vec3 p_offset, vec3 s_offset ){\n    m[3] += m[0]*p_offset.x + m[1]*p_offset.y + m[2]*p_offset.z;\n\n    \n    m[0] *= s_offset.x;\n    m[1] *= s_offset.y;\n    m[2] *= s_offset.z;\n    \n    return m;\n} \n\n\n\n// Functions utils - other\n\nfloat smax( float a, float b, float k ){\n    float h = clamp( (b-a)*0.5/k+ 0.5,0.,1.);\n    return mix(a, b, h) +k*h*(1.0-h);\n}\n\n\nfloat get_sphere_dist(vec3 p, mat4 m){\n\n    float ray = length(m[0]);\n    \n    float sphereDist = length( p - m[3].xyz)- ray ;\n    \n    sphereDist += (1. - step( 0.001 , ray ))*1000.;\n    \n    return sphereDist;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n// Functions utils - asteroid\n\nmat4 get_asteroid_matrix( vec3 id , float time ){\n\n    mat4 in_matrix = m_asteroid_init; \n    float pn_limit = 0.0;\n    float pn_small  = 1. - step( pn_limit, perlin_noise(id*1.2)  );\n    float pn_normal = 1. - step( pn_limit, perlin_noise(id*0.2)  );\n    float pn_big    = 1. - step( pn_limit, perlin_noise(id*0.06) );\n\n    in_matrix = matrix_orthogonize( in_matrix, 2, 1 );\n\n    in_matrix[3].xyz += id.xyz;\n\n\n    float id_color = perlin_noise(id*0.2)*3.;\n    \n    vec3 h = hash33(id);\n\n    //SCALE\n    float r_value_scale = 0.1;\n\n    if( FIELD_SCALE_VARIATION == 1)\n        r_value_scale = pow( abs(sin(h.x)),3.);\n\n    if( FIELD_VISIBILITY_VARIATION == 1){\n        r_value_scale *= pn_normal*pn_big*pn_small;\n\n    }\n\n\n\n    in_matrix[0][0] *= r_value_scale;//id_color;\n    in_matrix[0][1] *= r_value_scale;//id_color;\n    in_matrix[0][2] *= r_value_scale;//id_color;        \n\n    in_matrix[1][0] *= r_value_scale;//id_color;\n    in_matrix[1][1] *= r_value_scale;//id_color;\n    in_matrix[1][2] *= r_value_scale;//id_color; \n\n    in_matrix[2][0] *= r_value_scale;//id_color;\n    in_matrix[2][1] *= r_value_scale;//id_color;\n    in_matrix[2][2] *= r_value_scale;//id_color; \n\n\n    //ROT\n    if( ANIM == 1 )\n       in_matrix = matrix_rotation( in_matrix , h, time*0.3*id_color); \n\n    if( FIELD_POSITION_VARIATION == 1 ){\n        float amplitude = (0.5-r_value_scale*0.5);\n        vec3 r_value_pos = vec3( sin(h.x)*amplitude,sin(h.y)*amplitude,sin(h.z)*amplitude);\n        //pos\n        in_matrix[3][0] += r_value_pos.x;//rand.x*abs(sin(iTime));//1. - rand.x*0.5 ;\n        in_matrix[3][1] += r_value_pos.y;//1. - rand.x*0.5 ;\n        in_matrix[3][2] += r_value_pos.z;//1. - rand.x*0.5 ;\n    }\n\n      \n\n    \n    return in_matrix;\n}\n\n\n\nvec3 get_asteroid_color_triplanar( mat4 m, \n                                   vec3 p, \n                                   float texture_scale, \n                                   sampler2D iChannel1 )\n{\n    vec3 scale;\n    scale.x= length(m[0] * texture_scale);\n    scale.y= length(m[1] * texture_scale);\n    scale.z= length(m[2] * texture_scale); \n    \n    vec3 p_local = ( inverse(m)*vec4(p.xyz,1.) ).xyz;\n    \n\n    vec4 n_local_cube = normalize( vec4(p_local,1.) );\n    n_local_cube.xyz *= pow(n_local_cube.xyz,vec3(7.));\n    n_local_cube /= n_local_cube.x+n_local_cube.y+n_local_cube.z; //?\n\n    vec3 p_sample = p_local*scale;\n\n    vec3 col_cubeZY = texture( iChannel1, p_sample.zy ).xyz;\n    vec3 col_cubeXZ = texture( iChannel1, p_sample.xz ).xyz;\n    vec3 col_cubeXY = texture( iChannel1, p_sample.xy ).xyz; \n\n    vec3 color = col_cubeZY * abs(n_local_cube.x) + col_cubeXZ * abs(n_local_cube.y) + col_cubeXY * abs(n_local_cube.z);\n\n\n    return color;\n    \n}\n\nvec3 get_asteroid_color_tex3D( mat4 m, \n                               vec3 p, \n                               vec3 n,\n                               float texture_scale, \n                               sampler2D iChannel1 )\n{\n    vec3 scale;\n    scale.x= length(m[0] * texture_scale);\n    scale.y= length(m[1] * texture_scale);\n    scale.z= length(m[2] * texture_scale); \n    \n    vec3 p_local = ( inverse(m)*vec4(p.xyz,1.) ).xyz;\n    vec3 n_local = ( inverse(m)*vec4(n.xyz,1.) ).xyz;\n    \n    vec3 p_sample = p_local*scale;\n    vec3 n_sample = n_local*scale;\n\n    vec3 color = tex3D( iChannel1, p_sample,n_sample );\n\n    return color;\n    \n}\n\nfloat get_asteroid_dist(  vec3  p, \n                          mat4  m, \n                          int   type, \n                          float disp_power,  \n                          float disp_scale,\n                          float impact_size_min,\n                          float impact_size_max,\n                          bool  debug_impact,\n                          sampler2D iChannel1)\n    {\n    \n    float d_sphere = 99.;\n    \n\n    d_sphere  = get_sphere_dist(p,m);\n    \n    if( d_sphere < 0.001){\n        \n        if( GEOMETRY_ADD_DISPLACE == 1 )\n        {\n            d_sphere -= get_asteroid_color_triplanar(m, p, disp_scale, iChannel1 ).x*disp_power;   \n        }\n        \n        if( GEOMETRY_ADD_IMPACTS == 1 ){\n\n            for( int i = 0; i < IMPACT_NBR_MAX; i++ )\n            {\n                vec3 v_offset = hash33( vec3(float(i+5),float(i*-1),float(i+2)) );\n                v_offset = normalize(v_offset);\n\n                vec3 scale = vec3( max( impact_size_min, min( impact_size_max, hash33( vec3(i,i*i,i+i) ).x*impact_size_max) ) );\n                v_offset*= 1.+ disp_power+scale*0.5;\n\n                if( debug_impact ){\n                    d_sphere = min( d_sphere,     get_sphere_dist(p,matrix_offset(m, v_offset, scale)) );\n                }else{\n                    d_sphere = smax( d_sphere, -1.*get_sphere_dist(p,matrix_offset(m, v_offset, scale)), 0.15 );\n                }\n            }\n\n\n            \n        }\n        \n        if( GEOMETRY_ADD_DISPLACE == 1 )\n        {        \n            d_sphere -= get_asteroid_color_triplanar(m, p, disp_scale*5.01f, iChannel1 ).x*disp_power*0.1f;\n        }\n        \n        \n        \n    }\n    \n    return d_sphere;\n}\n\n\n// sdf map function\n\n\nvec2 map(vec3 p,\n         vec3 id,\n         bool skip_light,\n         float complexify,\n         float time,\n         sampler2D iChannel1 )\n{\n    \n    \n    bool debug_impact = false;\n    \n    mat4 m = get_asteroid_matrix( id, time );\n    \n    //SPHERE ASPECT\n    int   type            = 0;//int( 2.99*abs(sin(iTime*0.05))); \n    float disp_power      = DISPLACEMENT_VALUE*complexify;//*abs(sin(iTime));\n    float disp_scale      = DISPLACEMENT_SCALE;\n    float impact_size_min = 0.3;\n    float impact_size_max = 0.7;\n    \n    float d_sphere = 99999.;\n    \n    d_sphere = get_asteroid_dist( p, \n                                  m, \n                                  type, \n                                  disp_power,  \n                                  disp_scale,\n                                  impact_size_min,\n                                  impact_size_max,\n                                  debug_impact,\n                                  iChannel1); \n    \n    vec2 d_sphere_info = vec2( d_sphere, 1.0 );\n    \n    \n\n    \n    return d_sphere_info;\n}\n\n\n\n// copy from Fancy ties Yellow Moth Remix by ytktkd69\n//https://www.shadertoy.com/view/wdGBWR# \n\n//flare(p,vec2(0.,0.), vec3(1,.85,0.73),0.5);\nvec3 flare(in vec2 p, in vec2 pos, in vec3 lcol, in float sz)\n{\n\tvec2 q = p-pos;\n    q *= sz;\n\tfloat a = atan(q.x,q.y);\n    float r = length(q);\n    \n    float rz= 0.;\n    rz += .07/(length((q)*vec2(7.,200.))); //horiz streaks\n    rz += 0.3*(pow(abs(fract(a*.97+.52)-0.5),3.)*(sin(a*30.)*0.15+0.85)*exp2((-r*5.))); //Spokes\n\t\n    vec3 col = vec3(rz)*lcol;   \n    col += exp2((1.-length(q))*50.-50.)*lcol*vec3(3.);\n    col += exp2((1.-length(q))*20.-20.)*lcol*vec3(1,0.95,0.8)*0.5;    \n    return clamp(col,0.,1.);\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}