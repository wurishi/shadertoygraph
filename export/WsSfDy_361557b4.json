{"ver":"0.1","info":{"id":"WsSfDy","date":"1590682690","viewed":80,"name":"wreath","username":"darkfox","description":"fold twice, many many stella.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","polyhedron","stellation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// wreath.\n// reference:\n//   -- ray marching:https://www.shadertoy.com/view/XtXGRS\n//   -- folding space:https://www.shadertoy.com/view/XlX3zB\n// thanks!\n\nconst float pi = 3.14159;\n// global.\n//vec3 na; // mirror vector 1. (yz plane)\n//vec3 nb; // mirror vector 2. (xz plane)\nvec3 nc; // mirror vector 3. 60° with na, 36° with nb.\n// normal vector for mirror plane.\nvec3 pab; // na, nb.\nvec3 pbc; // nb, nc.\nvec3 pca; // nc, na.\n// palette.\nconst vec3 white = vec3(1.0);\nconst vec3 red = vec3(0.95, 0.3, 0.35);\nconst vec3 green = vec3(0.3, 0.9, 0.4);\nconst vec3 gold = vec3(0.75, 0.57, 0.14);\n// initialize for H3 Coxeter group.\nvoid initialize(float size){\n  float ratio = (1.0 + sqrt(5.0)) * 0.5; // golden ratio.\n  //na = vec3(1.0, 0.0, 0.0);\n  //nb = vec3(0.0, 1.0, 0.0);\n  nc = vec3(-0.5, -ratio * 0.5, (ratio - 1.0) * 0.5);\n  // vertices of fundamental domain.\n  pab = vec3(0.0, 0.0, ratio * 0.5) * size;\n  pbc = vec3(0.5, 0.0, ratio * 0.5) * size;\n  pca = vec3(0.0, ratio / 6.0, (2.0 * ratio + 1.0) / 6.0) * size;\n}\n// folding.\nvoid fold(inout vec3 p){\n  for(int i = 0; i < 5; i++){\n    //p -= 2.0 * min(0.0, dot(p, na)) * na;\n    //p -= 2.0 * min(0.0, dot(p, nb)) * nb;\n    p.xy = abs(p.xy);\n    p -= 2.0 * min(0.0, dot(p, nc)) * nc;\n  }\n}\n// rotation.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\n// x axis.\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\n// y axis.\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\n// z axis.\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n// update dist and set color.\nvoid updateDist(inout vec3 color, inout float dist, vec3 c, float d, int modeId){\n  if(d < dist && modeId == 0){ color = c; dist = d; }\n  if(d > dist && modeId == 1){ color = c; dist = d; }\n  if(-d > dist && modeId == 2){ color = c; dist = -d; }\n}\n// map function(main drawing code).\nvec4 map(vec3 p){\n  vec3 color;\n  fold(p);\n  float t = 1e20;\n  float k = (sqrt(5.0) + 1.0) / 2.0; // ratio\n  // draw Great stellated dodecahedron.\n  updateDist(color, t, red, dot(p - pca, vec3(0.0, -0.5 * k, 0.5)), 0);\n  vec3 c = (pab + pbc + pca) * 0.6;\n  p -= c;\n  p *= 3.5;\n  fold(p);\n  // draw small 120 Great stellated dodecahedrons.\n  updateDist(color, t, green, dot(p - pca, vec3(0.0, -0.5 * k, 0.5)), 0);\n  return vec4(color, t);\n}\n// get normal vector. (mathematical method)\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  vec3 n;\n  n.x = map(p + eps.xyy).w - map(p - eps.xyy).w;\n  n.y = map(p + eps.yxy).w - map(p - eps.yxy).w;\n  n.z = map(p + eps.yyx).w - map(p - eps.yyx).w;\n  return normalize(n);\n}\n// ray marching.\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // searching limit.\n  const float precis = 0.001; // precision.\n  const int ITERATION = 64; // iteration limit.\n  float h = precis * 2.0; // heuristics.\n\n  float t = 0.0; // current distance.\n\n  float result = -1.0;\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n    // adding heuristics value.\n    h = map(camera + t * ray).w;\n    t += h;\n  }\n  // if t < maxd, it means success(h < precis).\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera move.\nvoid transform(inout vec3 p){\n  float angleX = pi * iTime * 0.3;\n  float angleY = pi * iTime * 0.15;\n  p = rotateX(p, angleX);\n  p = rotateY(p, angleY);\n}\n// background(snowy).\nvec3 getBackground(vec2 p){\n  // gold.\n  vec3 color = mix(gold, white, 0.7) * (0.4 + p.y * 0.3);\n  float x = floor((p.x + 0.1) / 0.2) * 0.2;\n  float diff = mod(iTime * 0.2, 0.2); // snow falls.\n  float y = floor((p.y + 0.1 + diff) / 0.2) * 0.2 - diff;\n  if(mod(x * 5.0, 2.0) < 0.5){ y = floor((p.y + diff) / 0.2) * 0.2 - diff + 0.1; }\n  float d = length(p - vec2(x, y));\n  color = white + smoothstep(0.03, 0.07, d) * (color - white); // smoothstepを使って輪郭をぼかす\n  return color;\n}\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n  // ray vector.\n  vec3 ray = normalize(vec3(p, -1.8));\n  // camera position.\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // light vector.\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // camera rotation.\n  transform(ray);\n  transform(camera);\n  transform(light);\n  // preparation.\n  initialize(1.2);\n  color = getBackground(p);\n  // get ray marching result.\n  float t = march(ray, camera);\n  // if t > -0.001, it means success. if not, background color.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    // lighting.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    vec3 baseColor = map(pos).xyz;\n    baseColor *= diff;\n    // fadeout effect.\n    color = mix(baseColor, color, tanh(t * 0.02));\n  }\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}