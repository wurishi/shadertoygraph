{"ver":"0.1","info":{"id":"4l33DX","date":"1471909712","viewed":402,"name":"Alone in the Night","username":"stduhpf","description":"Just an attempt to use volumetric fog, also my first complex scene.\n\nupdate :now with volumertric light inspirated by : https://www.shadertoy.com/view/4tc3Wf","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","volumetric","scene","proceduralnormalmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define vlsamples 60\n\nstruct material\n{\n    vec3 c; //color\n    float sp; //specularity\n    vec4 nm; //normal map (nor,is normal mapped?)\n    bool e; //is emmisive?\n};\nconst float dist =100.;\n\nfloat rand( vec3 co)\n{\n    return fract(sin(\n            dot(vec3(30,1.3,320)*co*co,\n                vec3(12.9898,8.233,-19.848))\n                *43758.5453));\n    }\nfloat rand(vec2 co){\n     return fract(sin(dot(co.xy ,\n         vec2(12.9898,78.233))) * 43758.5453);\n      }\n\n    float mx(float a , float b , float x)\n    {\n        return (cos(x*3.1415)+1.)*(a-b)/2.+b;\n        }\nfloat bruit(vec3 co) //3d value noise(faster than perlin noise, that's why i don't use a true perlin noise)\n{\n    vec3 inco= floor(co);\n    vec3 frco= fract(co);\n    float x1 = mx(rand(inco),rand(inco+vec3(1,0,0)),frco.x);\n    float x2 = mx(rand(inco+vec3(0,1,0)),rand(inco+vec3(1,1,0)),frco.x);\n    float y1 = mx(x1,x2,frco.y);\n    float x3 = mx(rand(inco+vec3(0,0,1)),rand(inco+vec3(1,0,1)),frco.x);\n    float x4 = mx(rand(inco+vec3(0,1,1)),rand(inco+vec3(1,1,1)),frco.x);\n    float y2 = mx(x3,x4,frco.y);\n    return mx(y1,y2,frco.z);\n    }\nfloat fbm( vec3 p) // 3D fractional brownian motion\n{\nmat3 rot = mat3(cos(.5),sin(.5),0,-sin(.5),cos(.5),0,0,0,1);\nrot*=mat3(1,0,0,0,cos(.15),sin(.15),0,-sin(.15),cos(.15));\nrot*=mat3(cos(1.15),0,sin(1.15),0,1,0,-sin(1.15),0,cos(1.15));\n    return bruit(vec3(p))\n    +.5*bruit(2.001*vec3(p*rot))\n    +.25*bruit(4.041*vec3(p*rot*rot));\n    +.125*bruit(8.041*vec3(p*rot*rot*rot))\n    +.1*rand(10.*p);\n    }\n\nvec2 grad(vec2 co) //2d random gradiant for perlin noise\n{\nreturn vec2(rand(co.xy+10.1),rand(3.2654*co.yx))-.5;\n    }\nfloat perlin(vec2 uv)//true 2d perlin noise\n{\n\nvec2 relco = fract(uv);\nvec2 sqco  = floor(uv);\n\nfloat s = dot(grad(sqco),relco);\nfloat t = dot(grad(sqco +vec2(1,0)),relco-vec2(1,0));\nfloat u = dot(grad(sqco +1.),relco-1.);\nfloat v = dot(grad(sqco+ vec2(0,1)),relco-vec2(0,1));\n\nfloat noise1 = mix(s,t,smoothstep(0.,1.,relco.x));\nfloat noise2 = mix(v,u,smoothstep(0.,1.,relco.x));\nreturn  (10.*mix(noise1,noise2,smoothstep(0.,1.,relco.y)))/2.;\n\n    }\n\nmat3 r(float a,vec3 m) //3D rotation os a radiants around the axis m\n    {\n        float c = cos(a);\n        float s =sin (a);\n        return mat3(c+(1.-c)*m.x*m.x,\n            (1.-c)*m.x*m.y-s*m.z,\n            (1.-c)*m.x*m.z+s*m.y,\n            (1.-c)*m.x*m.y+s*m.z,\n            c+(1.-c)*m.y*m.y,\n            (1.-c)*m.y*m.z-s*m.x,\n            (1.-c)*m.x*m.z-s*m.y,\n            (1.-c)*m.y*m.z+s*m.x,\n            c+(1.-c)*m.z*m.z);\n        }\n\n//primitives\nfloat cube(vec3 p,vec3 shape)\n{\n    p+= vec3(0);\n    vec3 d = abs(p)-shape;\nfloat t = min(max(d.x,max(d.y,d.z)),0.)\n+length(max(d,.0));\nreturn t;\n}\nfloat sph(vec3 pos,float r)\n{\n    return length(pos)-r;\n    }\nfloat hplane(vec3 p,float h)\n{\n    return p.y-h;\n    }\n    float line( vec3 p, vec3 a, vec3 b, float r )\n    {\n        vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n     return length( pa - ba*h ) - r;\n      }\nfloat Cylinder( vec3 p, vec2 h )\n {\n     vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n      return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat RoundBox( vec3 p, vec3 b, float r )\n {\n    return length(max(abs(p)-b,0.0))-r;\n}\nfloat Prism( vec3 p, vec2 h )\n {\n     vec3 q = abs(p);\n      return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//distance operations\n    float smin( float a, float b,float k) //smooth minimum by iq\n{\n    return -log(exp(-k*a)+exp(-k*b))/k;\n}\n\nvec2 un (vec2 a, vec2 b)//opUnion\n{\n    float t=min(a,b).x;\nfloat m= b.y;\n    if (a.x == t)\n    m= a.y;\n    return vec2(t,m);\n    }\n\n//distance fields\nvec2 pot(vec3 p)\n{\n    p.x= mod(5.+p.x,10.)-5.-1.5*sign(p.z);\n    p.z=(abs(p.z)-6.);\n    float m= line(p,vec3(0,-1,0),vec3(0,5,0),.1);\n    m=smin(m,line(p,vec3(0,5,0),vec3(0,5.2,-1.),.1),20.);\nreturn un(vec2(m,2),\n    vec2(sph(p-vec3(0,5,-.5),.1),3));\n}\n\nfloat tro(vec3 p)\n{\n    return max(4.-abs(p.z),p.y+clamp(abs(p.z*.126)-2.,0.,2.)*(sin(.5+p.z*.1)+sin(p.x*.15)));\n\n}\n\nfloat car(vec3 p)\n{\n    p.x=mod(p.x-50.*time,400.)-10.;\n    p.z*=-1.;\n    p=.15*p.zyx;\n    vec3 q = p;\n    float c = RoundBox(p,vec3(.15,.03,.22),.01);\n    c= smin(c,RoundBox(p+vec3(0,-.06,0),\n        vec3(.15,.045,.11),0.)\n        ,25.+clamp(5.*(p.z),-10.,10.)\n        );\n\n        q=p.yxz;\n    q.yz= abs(q.yz+vec2(0,.01))-vec2(.16,.13);\n    q.xz+=vec2(.03,0);\n     c= min(c,Cylinder(q,vec2(.04,.03)));\n     c = min(c,Prism(p.zyx*vec3(1,-.75,1)+vec3(.19,.04,0),vec2(.01,.14)));\n    c= min(c,line(p,vec3(-.1,.1,.075),vec3(-.1,.15,0),.003));\n     return c/.15;\n     }\n\n\nvec2 map(vec3 pos)\n{\nvec2 m=vec2(hplane(pos,-.5),1);\nm=un(m,vec2(tro(pos),1));\nm=un(m,pot(pos));\nm= un(m,vec2(car(pos+vec3(0,0,-2)),4));\nreturn m;\n}\n\nvec2 itsc(vec3 o,vec3 d,float dis)//raycasting\n{\n    float t=0.;\n    for(int i=0;i<500;i++)\n    {\n    vec2 h= map(o+t*d);\n    if(h.x<.001)return vec2(h.y,t);\n    if(t>dis)\n    break;\n    t+=h.x*.85;//the *.85 is because the \"pot\" distance function seems broken \n    }\n    return vec2(-1,dis);\n    }\n\n\nvec3 normal(vec3 p)\n{\n    vec2 eps= vec2(.01,0);\n    vec3 n=\n        vec3(\n            map(p+eps.xyy).x-map(p-eps.xyy).x,\n        map(p+eps.yxy).x-map(p-eps.yxy).x,\n        map(p+eps.yyx).x-map(p-eps.yyx).x);\nreturn normalize(n);\n    }\n\n\nfloat ao(vec3 p,vec3 n,float d) //fast fake ambiant occlusion\n{\n    float h= map(p+d*n).x;\n    return d/(d+(d-h));\n}\n\nmaterial getm(float mtype, vec3 pos)\n{\n    material m;\n    m.nm=vec4(0);\n    m.sp=1.;\n    m.e=false;\n    if(mtype==4.)//cars\n    {\n        m.c=vec3(.1);\n        m.sp=.3;\n        }\n    if(mtype==3.) //lightsource\n    {\n        m.c=vec3(1,1,.5);\n        m.e = true;\n    }\n    if(mtype==2.)//streetlights\n    {\n    m.c=vec3(.4,.4,.4);\n    m.sp=2.;\n    }\n    if(mtype ==1.)//ground\n    {\n        vec2 co =20.*pos.xz;\n    vec2 e= vec2(.5,0);\n    m.nm.a=1.;\nm.nm.xyz= normalize(\n    vec3(perlin(co+e)-perlin(co-e),\n            perlin(co+e.yx)-perlin(co-e.yx),\n            3.));\n            m.sp=1.;\n    m.c=vec3(.1,.1,.15);\n    if(abs(pos.z)<.1&&mod(pos.x,2.)>.75)\n    m.c= vec3(.9);\n    if(abs(abs(pos.z)-4.4)<.5){\n    m.c = vec3(.5)*clamp(3.*mod(pos.x+sign(pos.z),2.9),.8,1.);\n    m.nm.a*=.0;\n    }\n    if(abs(pos.z)>4.5){\n    m.c = vec3(.0,.2,.0);\n    m.nm.xy*=2.;\n    m.sp=.1;\n    }\n    m.nm=normalize(m.nm);\n    }\n    return m;\n}\n\nfloat fog(vec3 p,float d)\n{\n    return clamp(fbm(\n        (p*2.2/(d+10.)+vec3(.02*time,0.,.05*time)))\n        *(2.-smoothstep(0.,2.,p.y+.5)),0.,1.);\n    }\nfloat marchvolfog(vec3 ro,vec3 rd,float d)\n{\n    float den=0.;\n    float t=.5;\n    for(int i=0;i<11;i++)\n    {\n        vec3 pos= ro+t*rd;\n        float n = fog(pos,t);\n        n= clamp(n-fog(pos+.7-float(i)*.1,t),.08,1.);\n        den+=clamp(n*smoothstep(t-.4,1.75*t+2.,d),0.,1.);\n        t*=1.6;\n        if(t>d)break;\n    }\n    return clamp(den,0.,1.);\n    }\n\n\nfloat calcscat(vec3 ro, vec3 rd, float d,vec2 fc)\n{\nfloat s=0.;\nfloat maxdist = min(dist,d);\nfloat w=1./float(vlsamples);\nfloat st = maxdist*w;\nvec3 pos = ro+rd*rand(vec3(fc,time))*.75;\nfor(int i =0;i<vlsamples;i++)\n{\n    vec3 p = pos;\n\tp.x= mod(5.+p.x,10.)-5.-1.5*sign(pos.z);\n    p.z=(abs(p.z)-3.);\n    vec3 ld = vec3(0,5.,2.5)-p;\n    s+=itsc(pos,normalize(ld),length(ld)-.2).x<0.\n        && \n        dot(normalize(vec3(0,5.,2.5)) ,normalize(ld))>.95 ?\n        .2+.8*fog(pos,float(i)*w):.0;\n    pos+=rd*st;\n}\nreturn clamp(s*w,0.,1.);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 ut = (iMouse.xy/iResolution.xy-.5)*vec2(8.,2.);\nif(iMouse.xy==vec2(0))\n    ut=vec2(1.7,0.);\n\nmat3 rotx= mat3(cos(ut.x),0,sin(ut.x),0,1,0,-sin(ut.x),0,cos(ut.x));\nmat3 roty = mat3(1,0,0,0,cos(ut.y),sin(ut.y),0,-sin(ut.y),cos(ut.y));\n\nvec2 uv = fragCoord.xy/iResolution.x-vec2(.5,.5*iResolution.y/iResolution.x);\n\nfloat t= 5.*smoothstep(0.,1.,time*.01)*time;\nvec3 ro =vec3(-t,\n    1.+.05*cos(2.*t),\n    -3.+.01*sin(4.*t));\nvec3 rd = normalize(vec3(uv,-1.))*roty*rotx;\n\nvec2 d = itsc(ro,rd,dist);\nvec3 c = vec3(0);\nvec3 ld = normalize(vec3(.4,2,-1.));\nld*=r(.01*time,normalize(vec3(0,1,.2)));\nfloat light=0.;\n    \nif (d.x>0.)//if the ray has hit an object\n{\n    vec3 pos= ro+d.y*rd;\n    material mat = getm(d.x,pos);\nvec3 nor = normalize(normal(pos)+mat.nm.xyz*mat.nm.a);\nvec3 rrd= reflect(rd,nor);\nlight=ao(pos,-nor,.5);\nlight+=(itsc(pos+.02*ld,ld,dist).x<0. ? mat.sp/distance(ld,rrd)*dot(nor,ld):0.)    ;\nc=mat.c*(mat.e? 1.:light*.1);\nvec3 p= pos;\n    p.x= mod(5.+p.x,10.)-5.-1.5*sign(pos.z);\n    p.z=(abs(p.z)-3.);\n    vec3 l = vec3(0,5.,2.5)-p;\n    \n    //then we apply the light the light from the floor lamps\nif(dot(normalize(vec3(0,5.,2.5))\n    ,normalize(l))>.95)\n{\n    nor.z*=sign(-pos.z);\n    rrd= reflect(rd,nor);\n    c+=5.*vec3(1.,1.,.2)*mat.c\n        *max(.1,(dot(nor,normalize(l))))\n        /length(l)\n        *(itsc(pos+.2*normalize(l),normalize(l),length(l)-.5).x<0.? 1.:0.)\n*mat.sp/distance(normalize(l),rrd)\n;\n}\n}else //we draw the sky\n{\n    vec3 bg = vec3(0,0,.1)+max(0.,(perlin(20.*rd.xz/rd.y)-1.2));\n    c= mix(bg,vec3(1),.1/distance(rd,ld));\n    if(1./distance(rd,ld)>10.)c=vec3(1.)+.45*(perlin(20.*rd.xz/rd.y));\n}\n\n    c= clamp(c,0.,1.);\n    float fog =marchvolfog(ro,rd,d.y);\n    vec3 fogcol=mix(vec3(.4,.3,.5),vec3(.55,.5,.2),calcscat(ro,rd,d.y,fragCoord)); //volumetric light\n\n    c= mix(c,fogcol,fog); // apply fog\n\n    fragColor = vec4(c,fog);\n}\n","name":"Image","description":"","type":"image"}]}