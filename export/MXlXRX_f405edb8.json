{"ver":"0.1","info":{"id":"MXlXRX","date":"1710044465","viewed":72,"name":"Luminance-based image sharpening","username":"mileslacey","description":"Had some ideas on how to sharpen images using per-pixel luminance.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["luminance","sharpening","luma","sparpen"],"hasliked":0,"parentid":"l3fSR7","parentname":"Channel-based image Sharpening"},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n\n#define NEARBY_TEXEL_DISTANCE vec2(0.25)\n\n// Use smoothstep, or linear, direction interpolation\n#define DIRECTION_VECTOR_INTERPOLATION 1\n\n// debug texture lookup direction\n#define DEBUG_DIRECTION_VECTORS 0\n\n// debug texture luminance\n#define DEBUG_LUMINANCE 0\n\n\n\n/*--------------------------------------\n RGB <-> YCoCg conversions\n--------------------------------------*/\nfloat rgb_to_luminance(vec4 rgb)\n{\n    //rgb = pow(rgb, vec4(2.2));\n    //return (rgb.r/4.0) + (rgb.g/2.0) + (rgb.b/4.0);\n    return dot(rgb.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\n\n\nfloat rgb_to_luminance2(vec4 rgb)\n{\n    return rgb_to_luminance(rgb) * 2.0 - 1.0;\n}\n\n\n\n/*--------------------------------------\n Colors as Geometry\n--------------------------------------*/\nvec4 colors_to_normal(in float c0, in float c1, in float c2)\n{\n#if 0\n    vec3 p0 = vec3(c0,  0.0, 0.0);\n    vec3 p1 = vec3(0.0, c1,  0.0);\n    vec3 p2 = vec3(0.0, 0.0, c2);\n    vec3 p  = cross(p1-p0, p2-p0);\n#else\n    vec3 p  = vec3(c1, c0, c0) * vec3(c2, c2, c1);\n#endif\n    return vec4(normalize(p), 0.0);\n}\n\n\n\nfloat safe_sign(float x)\n{\n    return x >= 0.0 ? 1.0 : -1.0;\n}\n\n\n\nfloat imix(in float a, in float b, in float t)\n{\n    return (t-a)/(b-a);\n}\n\n\n\nvec4 imix4(in vec4 a, in vec4 b, in vec4 t)\n{\n    return (t-a)/(b-a);\n}\n\n\n\n/*--------------------------------------\n Upscaling\n--------------------------------------*/\nvec4 upscale_image(in vec2 fragCoord, in vec2 resolution, in sampler2D texImage)\n{\n    vec2  dims   = vec2(textureSize(texImage, 0).xy);\n    vec2  scale  = resolution / dims;\n    vec2  offset = scale * NEARBY_TEXEL_DISTANCE;\n    vec2  uv0    = fragCoord;\n    vec2  uvn    = uv0 + vec2( 0.0,      offset.y);\n    vec2  uvs    = uv0 + vec2( 0.0,     -offset.y);\n    vec2  uve    = uv0 + vec2( offset.x,  0.0);\n    vec2  uvw    = uv0 + vec2(-offset.x,  0.0);\n    \n    // nearby texture values\n    vec4 c0 = texture(texImage, uv0/resolution);\n    vec4 cn = texture(texImage, uvn/resolution);\n    vec4 cs = texture(texImage, uvs/resolution);\n    vec4 ce = texture(texImage, uve/resolution);\n    vec4 cw = texture(texImage, uvw/resolution);\n    \n    float l0 = rgb_to_luminance2(c0);\n    float ln = rgb_to_luminance2(cn);\n    float ls = rgb_to_luminance2(cs);\n    float le = rgb_to_luminance2(ce);\n    float lw = rgb_to_luminance2(cw);\n    \n    // make triangles of each color triplet\n    float dir = safe_sign(l0);\n    vec4 nw = vec4( lw, -ln, 1.0, 0.0);\n    vec4 ne = vec4(-le, -ln, 1.0, 0.0);\n    vec4 sw = vec4( lw,  ls, 1.0, 0.0);\n    vec4 se = vec4(-le,  ls, 1.0, 0.0);\n    \n    // extract luminance vectors\n    vec4 lookupDirs = mat4(nw, ne, sw, se) * vec4(1.0);\n    \n    // luminance intensity modulation\n    #if DIRECTION_VECTOR_INTERPOLATION\n        lookupDirs = smoothstep(vec4(-dir), vec4(dir), lookupDirs) * 2.0 - 1.0;\n    #else\n        lookupDirs = imix4(vec4(-dir), vec4(dir), lookupDirs) * 2.0 - 1.0;\n    #endif\n    \n    // debug texture lookup direction\n    #if DEBUG_DIRECTION_VECTORS\n        #if DEBUG_LUMINANCE\n            return vec4(imix(-1.0, 1.0, dot(vec4(0.0, 0.0, -dir, 0.0), normalize(lookupDirs))))*4.0;\n        #else\n            lookupDirs = normalize(vec4(lookupDirs.xy, dir, 0.0)) * 0.5 + 0.5;\n            return vec4(lookupDirs.xyz, 0.0);\n        #endif\n    #endif\n    \n    // Load sharpened texture\n    vec2  coords = lookupDirs.xy * offset;\n    return texture(texImage, (uv0 - coords)/resolution);\n}\n\n\n\n/*--------------------------------------\n Main\n--------------------------------------*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#if 0\n    fragCoord = (fragCoord/2.0) + (iResolution.xy / 4.0);\n#endif\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Show results, with comparison against the original texture.\n    vec4 srcImage = texture(iChannel0, uv);\n    vec4 dstImage = upscale_image(fragCoord, iResolution.xy, iChannel0);\n    \n    fragColor = show_diff(fragCoord, iMouse, iTime, iResolution, srcImage, dstImage);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/*--------------------------------------\n Helper function to diff images\n--------------------------------------*/\nvec4 show_diff(\n    in vec2 fragCoord,\n    in vec4 iMouse,\n    in float iTime,\n    in vec3 iResolution,\n    in vec4 color0,\n    in vec4 color1)\n{\n    vec4 result;\n    const float dilation = 10.0;\n    float modulation;\n    float cursor;\n    \n    if (sign(iMouse.z) > 0.0)\n    {\n        modulation = step(fragCoord.x, iMouse.x);\n        cursor = iMouse.x;\n    }\n    else\n    {\n        float timedMod = cos(fract(iTime / dilation) * 3.14159265 * 2.0);\n        float t = timedMod * 0.5 + 0.5;\n        modulation = step(fragCoord.x/iResolution.x, t);\n        cursor = iResolution.x * t;\n    }\n    \n    float line = fragCoord.x - cursor;\n    if (line > 0.0 && line <= 1.0)\n    {\n        result = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        result = mix(color1, color0, modulation);\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}