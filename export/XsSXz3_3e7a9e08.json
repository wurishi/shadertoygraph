{"ver":"0.1","info":{"id":"XsSXz3","date":"1473001070","viewed":3118,"name":"Night Sky 01","username":"xaot88","description":"Moon, stars, clouds, etc.\nComments welcome!","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["procedural","clouds","sky","stars","moon","night","starfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define HASHSCALE1 .1031\n\n// From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Kind of a Perlin Noise replacement.\n// I can't remember where I got this function from.\n// If someone knows who to credit, please let me know.\nfloat smoothNoise13( in vec3 x )\n{\n\tvec3 p  = floor(x);\n\tvec3 f  = smoothstep(0.0, 1.0, fract(x));\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\treturn\tmix(\n        \t\tmix(\n                    mix( hash11( n + 0.0 ), hash11( n + 1.0 ), f.x ),\n\t\t\t\t\tmix( hash11( n + 57.0 ), hash11( n + 58.0 ), f.x ),\n                    f.y ),\n\t\t\t\tmix(\n                    mix( hash11( n + 113.0 ), hash11( n + 114.0 ), f.x ),\n\t\t\t\t\tmix( hash11( n + 170.0 ), hash11( n + 171.0 ), f.x),\n                    f.y ),\n        \t\tf.z );\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// I can't remember where I got this function from.\n// If someone knows who to credit, please let me know.\nfloat FractionalBrownianMotion( vec3 p )\n{\n\tfloat f = 0.5000 * smoothNoise13( p );\n    p = m * p * 1.2;\n\tf += 0.2500 * smoothNoise13( p );\n    p = m * p * 1.3;\n\tf += 0.1666 * smoothNoise13( p );\n    p = m * p * 1.4;\n\tf += 0.0834 * smoothNoise13( p );\n\treturn f;\n}\n\n// Convert hash12() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = hash12( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 0.1;\n    \n    vec2 vNormalizedUv = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\t\n\tvec3 col  = vec3(0.0, 0.0, 0.0);\n\t\n\t// render sky\n\tcol += vec3( 0.1, 0.2, 0.4 ) * vNormalizedUv.y;\n    \n\t// moon\n    vec2 vMoonPos = vec2(.5, 0.35);\n    vec2 vUvMoonDiff = uv - vMoonPos;\n    float fMoonDot = max( 0.0, 1.0 - dot( vUvMoonDiff, vUvMoonDiff ) );\n    col += vec3(0.6, 0.6, 0.6) * pow( fMoonDot, 350.0 );\n\t\n\t// moon haze\n\tcol += vec3(0.48, 0.54, 0.6) * pow( fMoonDot, 6.0 );\n    \n    // Note: Choose fThreshhold in the range [0.9, 0.9999].\n    // Higher values (i.e., closer to one) yield a sparser starfield.\n    float StarFieldThreshhold = 0.985;\n\n    // Stars with a slow spin.\n    float fSpinRate = 0.0005;\n    vec2 vInputPos = ( 2.0 * fragCoord.xy/iResolution.y ) - vec2( 1.0, 1.0 );\n    float fSampleAngle = fSpinRate * float( iFrame ) + atan( vInputPos.y, vInputPos.x );\n    vec2 vSamplePos = ( 0.5 * length( vInputPos ) * vec2( cos( fSampleAngle ), sin( fSampleAngle ) ) + vec2( 0.5, 0.5 ) ) * iResolution.y;\n    float StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    col += vec3( StarVal );\n\n    // clouds\n    vec3 vFbmInput = vec3( uv.x - time, uv.y, 0.0 );\n    vec3 vFogColor = vec3(0.7, 0.7, 0.9);\n    col += vNormalizedUv.y * vFogColor * FractionalBrownianMotion( vFbmInput );\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}