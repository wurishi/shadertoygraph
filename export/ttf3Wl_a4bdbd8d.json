{"ver":"0.1","info":{"id":"ttf3Wl","date":"1558145056","viewed":723,"name":"Sacred Computer Logo","username":"twenkid","description":"Логото на \"Свещеният сметач\". Създаден на основата на шейдъра ми за \"Хакафе\". ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["computer","sacred","ezine","bulgarian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  СВЕЩЕНИЯТ СМЕТАЧ - Sacred Computer Logo ... \n  #16-5-2019 - 18-5-2019 \n   \n  Свещеният\n   сметач\n\n  А - като Я, но горното изместено вляво\n\n   ####\n   #  #\n   ####\n  #   #\n  #   #\n\n  ###    ###\n  #  #  #  #\n  #  ####  #\n  #        #\n  \n   ####\n   #  #\n  ######\n  #    #\n  #    #\n\n  #   #\n  #   #\n   ####\n      #\n      #\n\n  Modified[\"Hackafe Logo\"]. Vers. 18/5/2019\n  Ugly dist code - whatever.\n\n  [Author]: Todor \"Tosh\" Arnaudov (Twenkid) http://artificial-mind.blogspot.bg | http://research.twenkid.com\n  [Credits and Thanks]: Shadertoy community, iq, Dave Hoskins, rear, LeGuignon; BigWings etc.\n                       \n  [История]\n  Свещненият сметач\", списанието на юнаците се възражда. Създадено в края на 2000 г.\n  от младия творчески хакер (юнак) Тош. Там са публикувани авангардни философски статии, проза, поезия,\n  технически статии, публицистика, исторически статии, сатра, юнашки разкази (технически-художествен),\n  Дружество за защита на българския език, дружество \"Разум\", класически български компютърни игри,\n  безплатен софтуер като синтезатора на реч \"Глас 2004\", текстовият редактор \"Писар\", речникът на юнашкото\n  наречие \"Езикотворец\" и др.\n\n  http://eim.twenkid.com  \n                        \n*/\n\nfloat z = 0.015;//5;\nfloat StepDiv = 35.;\nfloat StepBase = 0.30; //Blocks\nconst float cube = 3.; //(~) distance to distinguish the cube from space\nfloat step = 0.8; //Blocks\nconst vec2 cameraYz = vec2(2.5,-6.5); //vec2(2.65,-5.5); //the X is animated\nfloat cameraSpeed = 1.5; //2.4; //2.7;\n\nconst int STEPS = 50; //ray marching steps\nconst float EPS = 0.001; //precision (epsilon)\nconst float PI = 3.1415926;\n\n// from iq's \"Anels\", from Kali's Lonely Tree shader, from Analytical geometry textbooks - rotation around axis\nmat3 rotationMat(in vec3 v, in float angle) //, in out vec3 vOut)\n{\n    float c = cos(angle), s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, \n                (1.0 - c) * v.x * v.y - s * v.z,\n                (1.0 - c) * v.x * v.z + s * v.y,\n                \n                (1.0 - c) * v.x * v.y + s * v.z,\n                c + (1.0 - c) * v.y * v.y,\n                (1.0 - c) * v.y * v.z - s * v.x,\n                \n                (1.0 - c) * v.x * v.z - s * v.y,\n                (1.0 - c) * v.y * v.z + s * v.x,\n                c + (1.0 - c) * v.z * v.z);\n}\n\n// jerome, Electricity\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm8(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 8; i++) {\n        total += noise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n//Based on Electricity, but modified by Twenkid to look somewhat like a burst of hot gas.\n//Should be optimized and varied - e.g. arrays and cycles/more streams/more adjustible\nvec3 electricity(vec2 uv ){    \n   vec2 t = uv * vec2(2.0,1.0) - iTime*4.0;      \n   float ybase = 0.30, ystep = 0.03;\n   float ycenter = ybase+fbm8(t)*0.35;\n    \n   float ycenter2 = ybase+ystep+fbm8(t)*0.5;\n   float ycenter3 = ybase-ystep+fbm8(t)*0.5;    \n   float diff = abs(uv.y - ycenter);\n   float c1 = 1.0 - mix(0.0,0.3,diff*21.0);\n     \n    c1 = clamp(c1, 0., 1.);\n    vec3 col = vec3(c1*0.9, 0.9*c1,c1*0.2);\n        \n    float diff2 = abs(uv.y - ycenter2);\n    float c2 = 1.0 - mix(0.0,0.2,diff2*21.0);    \n    col = mix(col, vec3(c2*0.7, 0.4*c2, c2*0.1), 0.7);\n    \n    float d3 = abs(uv.y - ycenter3);\n    float c3 = 1.0 - mix(0.0,0.3,diff2*21.0);\n    col = mix(col, vec3(c3*0.5, 0.3*c3, c3*0.1), 0.5);\n    //col = mix(col, vec3(c3*0.7+abs(noise(uv)/5.), 0.3*c3, c3*0.1), 0.5); //noise - no, too jaggy\n   // col = min(col, vec3(c3*0.7+abs(fbm8(uv)/5.), 0.3*c3, c3*0.1));\n    col = max(vec3(0.), col); //avoid negative color - electricity is multiplied in the render\n    return col;\n}\n// jerome's end\n\n//// Dave Hoskins's? noise\nfloat N1(float t) { return fract(sin(t*10234.324)*123423.23512);  }\n\nvec2 N22(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW   //modified to vec2, vec2\n\tvec2 p2  = fract(vec2(p.xyx) * vec2(443.897, 441.423)); // 437.195));\n    p2 += dot(p2, p2.yx + 19.19);\n    return fract(vec2((p2.x + p2.y)*p2.x, (p2.y+p2.y)*p2.x));\n}\n\nvec2 fbm(vec2 v){ return N22(v)*0.5 + vec2(0.25*N1(v.x)) + vec2(0.25*N1(v.y)); }\n\n//iq's box\nfloat sdBox( vec3 p, vec3 b ) { // float zoom = 3.;   \n    vec3 d = (abs(p) - b);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxAngle( vec3 p, vec3 b, vec3 axis, float angle ) { // float zoom = 3.;      \n    axis = normalize(axis);\n    p = p*rotationMat(axis, angle);\n    float d = sdBox((p-b), b);//(abs(p) - b);\n    return d;\n    //d = d*rotationMat(d,a);\n    //return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//float sdPlane(vec3 p){return p.y;} //future use - grid plane?\n\nfloat distLimitBorder(vec3 r){ //26-12-2017\n   //float step = StepBase + sin(iTime)/STEPDIV;\n   //float d3 = sdBox(r-vec3(1.0,0.25, 0.0), vec3(0.1, 0.1, z));\n   //return d3;\n    \n   vec3 axis = normalize(vec3(1.0, 0.25, 0.0));  \n   r*= rotationMat(axis, mod(fract(iTime)*6.28, 6.28));    \n   float d1 = sdBox(r-vec3( 1.0,0.25, 0.0), vec3(0.1, 0.1, z));  \n   return d1;    \n}  \n/*\nfloat distLimitBig(vec3 r){ //26-12-2017 - right border/curtain\n   float step = StepBase+ sin(iTime)/StepDiv;\n   float d3 = sdBox(r-vec3(10.0,StepBase, 0.0), vec3(9., 10., z));\n   return d3;\n}\n*/\n  \n//Distance from the objects. Should be optimized, could use one or a few common formulas,\n//except for the rotating block.\nfloat dist(vec3 r)\n{      \n    float d9, d10, d11, d12,d13,d14,d15,d16, d17, d18,d19;\n   float step = StepBase + sin(iTime)/StepDiv;           \n    vec3 axis = normalize(vec3(1.0, 0.25, 0.0));     \n    vec3 r1 = r * rotationMat(axis, mod(fract(iTime)*6.28, 6.28)); \n    float d;\n    float d1,d2,d3,d4,d5,d6,d7,d8;\n    float d20,d21,d22,d23,d24,d25,d26,d27,d28,d29,d30,d31,d32,d33,d34,d35,d36,d37,d38,d39,d40;\n    float d41,d42,d43,d44,d45,d46,d47,d48,d49,d50,d51,d52,d53,d54,d55;\n    \n    /*\n    float d1 = sdBox(r1-vec3( 1.0,0.25, 0.0), vec3(0.1, 0.1, z));      \n    float d2 = sdBox(r-vec3(1.0-step,0.25, 0.0), vec3(0.1, 0.1, z));\n    float d3 = sdBox(r-vec3(1.0-step-step,0.25, 0.0), vec3(0.1, 0.1, z));\n        \n    float d4 = sdBox(r-vec3(1.0,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    float d5 = sdBox(r-vec3(1.0-step,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    float d6 = sdBox(r-vec3(1.0-step-step,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    \n    float d7 = sdBox(r-vec3(1.0,0.25-step, 0.0), vec3(0.1, 0.1, z));   \n    float d8 = sdBox(r-vec3(1.0-step-step,0.25-step, 0.0), vec3(0.1, 0.1, z));\n    */\n    \n    //С    \n    d1 = sdBox(r-vec3( 0.2,0.6, 0.0), vec3(0.12, 0.03, z));  //HORIZ    \n    d2 = sdBox(r-vec3( 0.09,0.465, 0.0), vec3(0.03, 0.13, z));  //VERT\n    d3 = sdBox(r-vec3( 0.2,0.33, 0.0), vec3(0.12, 0.03, z));  //HORIZ\n    \n    \n    //В\n    d4 = sdBox(r-vec3( 0.44, 0.5, 0.0), vec3(0.05, 0.01, z));  //HORIZ    \n    \n    d5 = sdBox(r-vec3( 0.375,0.42, 0.0), vec3(0.02, 0.09, z));  //VERTICAL LEFT\n    \n    d6 = sdBox(r-vec3( 0.43,0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    \n    d7 = sdBox(r-vec3( 0.43,0.42, 0.0), vec3(0.07, 0.01, z)); //HORIZ MIDDLE\n    \n    d8 = sdBox(r-vec3( 0.47,0.46, 0.0), vec3(0.02, 0.05, z)); //VERTICAL RIGHT UP\n    d9 = sdBox(r-vec3( 0.49,0.37, 0.0), vec3(0.02, 0.04, z)); //VERTICAL RIGHT DOWN    \n    \n    \n    float s = 0.18;\n    //Е\n    d10 = sdBox(r-vec3( 0.44+s, 0.5, 0.0), vec3(0.045, 0.01, z));  //z+ is UP!\n    //d2 = sdBox(r-vec3( 0.2,0.6, 0.0), vec3(0.03, 0.12, z));  //z+ is UP! +\n    //+\n    d11 = sdBox(r-vec3( 0.375+s,0.42, 0.0), vec3(0.02, 0.09, z));  //z+ is UP!    \n    d13 = sdBox(r-vec3( 0.435+s,0.41, 0.0), vec3(0.045, 0.01, z));\n    d12 = sdBox(r-vec3( 0.415+s,0.32, 0.0), vec3(0.06, 0.01, z));\n    \n    //Щ\n    float st = 0.44+s/2.;\n    float s1 = 0.07;\n    st+=s;\n    \n    d14 = sdBox(r-vec3(st ,0.42, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d15 = sdBox(r-vec3(st + s1 ,0.42, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d16 = sdBox(r-vec3(st + s1*2. ,0.42, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d17 = sdBox(r-vec3(st + s1, 0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    \n    d18 = sdBox(r-vec3(st + s1*2. + 0.03, 0.34, 0.0), vec3(0.02, 0.01, z)); //HORIZ DOWN RIGHT\n    //d19 = sdBox(r-vec3(st + s1*2. + 0.03 + 0.03, 0.34, 0.0), vec3(0.01, 0.03, z)); //HORIZ DOWN RIGHT - MIDDLE\n    d19 = sdBox(r-vec3(st + s1*2. + 0.03 + 0.012, 0.33, 0.0), vec3(0.01, 0.03, z)); //HORIZ DOWN RIGHT - MIDDLE\n    \n    \n    float sm = s + s/2.0 + 0.09 + s + 0.03;\n    //Е\n    d20 = sdBox(r-vec3( 0.44+sm, 0.5, 0.0), vec3(0.045, 0.01, z));  \n   \n    d21 = sdBox(r-vec3( 0.375+sm,0.42, 0.0), vec3(0.02, 0.09, z));   \n    d22 = sdBox(r-vec3( 0.435+sm,0.41, 0.0), vec3(0.045, 0.01, z));\n    d23 = sdBox(r-vec3( 0.415+sm,0.32, 0.0), vec3(0.06, 0.01, z));\n    \n    sm += 0.09;\n    //Н\n    //d24 = sdBox(r-vec3( 0.44+sm, 0.5, 0.0), vec3(0.045, 0.01, z));\n    d24 = sdBox(r-vec3( 0.44+sm,0.41, 0.0), vec3(0.02, 0.10, z));\n    d25 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    d26 = sdBox(r-vec3( 0.44+sm+0.04,0.41, 0.0), vec3(0.06, 0.01, z));\n    \n    sm+=0.09+0.075;\n    //И\n    d27 = sdBox(r-vec3( 0.44+sm,0.41, 0.0), vec3(0.02, 0.10, z));\n    d28 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    d29 = sdBox(r-vec3( 0.44+sm+0.04,0.32, 0.0), vec3(0.06, 0.01, z)); //HOR DOWN\n    \n    sm +=0.09+0.15;\n    float cor = 0.05;\n    //Я\n    d30 = sdBox(r-vec3( 0.44+sm, 0.5, 0.0), vec3(0.036, 0.01, z));  //HORIZ TOP    \n    \n    d31 = sdBox(r-vec3( 0.375+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));  //VERTICAL RIGHT\n    \n    //d32 = sdBox(r-vec3( 0.43+sm,0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    d32 = d31;\n    \n    d33 = sdBox(r-vec3( 0.41+sm,0.41, 0.0), vec3(0.06, 0.01, z)); //HORIZ MIDDLE\n    \n    d34 = sdBox(r-vec3( 0.39+sm,0.45, 0.0), vec3(0.013, 0.05, z)); //VERTICAL LEFT UP\n    d35 = sdBox(r-vec3( 0.36+sm,0.36, 0.0), vec3(0.02, 0.050, z)); //VERTICAL LEFT DOWN\n    float dq1 = min(d30,d31), dq2 = min(d32,d33), dq3 = min(d34,d35);\n    dq2 = min(dq2, dq3);\n    dq1 = min(dq1, dq2);\n    \n    //Т\n    sm+=0.09+0.03;    \n    d36 = sdBox(r-vec3( 0.44+sm+0.04,0.41, 0.0), vec3(0.02, 0.10, z)); //VER\n    //d37 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    d37 = sdBox(r-vec3( 0.44+sm+0.04,0.49, 0.0), vec3(0.09, 0.02, z)); //HOR MID   \n    d = min(d36,d37);\n    dq1 = min(dq1,d);\n    //dq1 = min(dq1, d38);\n    \n    float sy = 0.3;\n    sm = 0.2;\n    //SECOND LINE\n    //С   \n    /*\n    d38 = sdBox(r-vec3( 0.2 + sm,0.5-sy, 0.0), vec3(0.09, 0.015, z));    \n    d39 = sdBox(r-vec3( 0.11 + sm,0.41-sy, 0.0), vec3(0.02, 0.09, z));  //z+ is UP!\n    d40 = sdBox(r-vec3( 0.2 + sm,0.32-sy, 0.0), vec3(0.09, 0.015, z));  //VERT\n    d = min(d38, d39);\n    d = min(d, d40);\n    dq1 = min(dq1, d);\n    */\n    d38 = sdBox(r-vec3( 0.2 + sm + 0.02,0.5-sy, 0.0), vec3(0.06, 0.015, z));    \n    d39 = sdBox(r-vec3( 0.11 + sm + 0.04,0.41-sy, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d40 = sdBox(r-vec3( 0.2 + sm +0.02,0.32-sy, 0.0), vec3(0.06, 0.015, z));  \n    d = min(d38, d39);\n    d = min(d, d40);\n    dq1 = min(dq1, d);\n    \n    /*\n    //М - не, 16:50\n    //Наклонени линии - остри. НЕ, по-добре правоъгълни като другите!\n    //vec3(0.0,1.0,0.0)  ---- \n    sm = 0.15;\n    float angle = -PI/2.5; // fract(iTime)*6.28;\n    d41 = sdBoxAngle(r-vec3( 0.2+sm,-0.07, 0.0), vec3(0.12, 0.015, z), vec3(0.0, 0.0,1.0), angle);  \n    d42 = sdBoxAngle(r-vec3( 0.2+sm+0.05,0.15, 0.0), vec3(0.09, 0.015, z), vec3(0.0, 0.0,1.0), -angle);  \n    d43 = sdBoxAngle(r-vec3( 0.2+sm+0.14,-0.01, 0.0), vec3(0.09, 0.015, z), vec3(0.0, 0.0,1.0), angle);  \n    d44 = sdBoxAngle(r-vec3( 0.2+sm+0.17,0.15, 0.0), vec3(0.11, 0.015, z), vec3(0.0, 0.0,1.0), -angle); \n    //d45 = sdBox(r-vec3( 0.2+sm+0.12,0.0, 0.01), vec3(0.02, 0.015, z));\n    d = min(d41,d42);   \n    d = min(d, d43);\n    d = min(d, d44);\n    //d = min(d,d45);\n    dq1 = min(d,dq1);\n     */\n    \n    sm += -0.11;\n    //М\n    d41 = sdBox(r-vec3( 0.44+sm,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VERT\n    d42 = sdBox(r-vec3( 0.44+sm+0.18,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VERT\n    d43 = sdBox(r-vec3( 0.44+sm+0.09,0.41-sy-0.03, 0.0), vec3(0.025, 0.01, z)); //HORIZ down   \n    d = min(d41,d42);   \n    dq1 = min(dq1, d);\n    dq1 = min(dq1,d43);\n    d43 = sdBox(r-vec3( 0.44+sm+0.04,0.41-sy+0.07, 0.0), vec3(0.03, 0.01, z)); //HORIZ\n    d44 = sdBox(r-vec3( 0.44+sm+0.18-0.04,0.41-sy+0.07, 0.0), vec3(0.03, 0.01, z)); //HORIZ\n    dq1 = min(dq1,d43);\n    dq1 = min(dq1,d44);\n    \n    d41 = sdBox(r-vec3( 0.44+sm+0.065,0.41-sy+0.02, 0.0), vec3(0.015, 0.04, z)); //VERT\n    d42 = sdBox(r-vec3( 0.44+sm+0.18-0.065,0.41-sy+0.02, 0.0), vec3(0.015, 0.04, z)); //VERT\n    dq1 = min(dq1,d41);\n    dq1 = min(dq1,d42);\n\n    \n    //Е\n    sm+=0.32;\n    d40 = sdBox(r-vec3( 0.44+sm, 0.5-sy, 0.0), vec3(0.05, 0.01, z));  \n   \n    d41 = sdBox(r-vec3( 0.375+sm,0.42-sy, 0.0), vec3(0.02, 0.09, z));   \n    d42 = sdBox(r-vec3( 0.435+sm,0.41-sy, 0.0), vec3(0.045, 0.01, z));\n    d43 = sdBox(r-vec3( 0.415+sm,0.32-sy, 0.0), vec3(0.06, 0.01, z));\n    d = min(dq1, d40);\n    d = min(d, d41);\n    d = min(d,d42);\n    d = min(d,d43);\n    dq1 = min(d, dq1);\n    \n    //T\n    sm+=0.13;    \n    d36 = sdBox(r-vec3( 0.44+sm+0.04,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VER\n    //d37 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    //d37 = sdBox(r-vec3( 0.44+sm+0.04,0.49-sy, 0.0), vec3(0.09, 0.02, z)); //HOR MID THICK 0.02\n    d37 = sdBox(r-vec3( 0.44+sm+0.04,0.49-sy+0.01, 0.0), vec3(0.09, 0.015, z)); //HOR MID THINNER 0.015\n    d = min(d36,d37);\n    dq1 = min(dq1,d);\n    \n    //A    \n    sm += 0.24;        \n    d30 = sdBox(r-vec3( 0.44+sm-0.03, 0.5-sy, 0.0), vec3(0.035, 0.01, z));  //HORIZ TOP    \n    d34 = sdBox(r-vec3( 0.39+sm-0.02,0.45-sy, 0.0), vec3(0.013, 0.05, z)); //VERTICAL LEFT UP\n    \n    //d31 = sdBox(r-vec3( 0.375+sm+0.09,0.41-sy, 0.0), vec3(0.02, 0.10, z));  //VERTICAL RIGHT //LONG for Я\n    d31 = sdBox(r-vec3( 0.375+sm+0.09, 0.41-sy-0.05, 0.0), vec3(0.02, 0.05, z));  //VERTICAL RIGHT DOWN //LONG for Я        \n    d36 = sdBox(r-vec3( 0.375+sm+0.09-0.01, 0.41-sy+0.05, 0.0), vec3(0.013, 0.04, z)); //VERTICAL RIGHT UP\n    \n    //d32 = sdBox(r-vec3( 0.43+sm,0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    d32 = d31;\n    \n    d33 = sdBox(r-vec3( 0.41+sm+0.005,0.41-sy, 0.0), vec3(0.065, 0.01, z)); //HORIZ MIDDLE    \n    d35 = sdBox(r-vec3( 0.36+sm,0.36-sy, 0.0), vec3(0.02, 0.050, z)); //VERTICAL LEFT UP\n    \n    dq1 = min(dq1, d30);\n    dq2 = min(d31,d32); dq3 = min(d33,d34);\n    dq1 = min(dq1,dq2);\n    dq1 = min(dq1,dq3);\n    dq1 = min(dq1,d35);\n    dq1 = min(dq1,d36);\n           \n    sm += 0.09;\n    //Ч\n    d41 = sdBox(r-vec3( 0.44+sm,0.41-sy+0.05, 0.0), vec3(0.02, 0.05, z)); //VERT\n    d42 = sdBox(r-vec3( 0.44+sm+0.09,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VERT\n    d43 = sdBox(r-vec3( 0.44+sm+0.05,0.41-sy, 0.0), vec3(0.05, 0.01, z)); //HORIZ //A little step\n   // d43 = sdBox(r-vec3( 0.44+sm+0.04,0.41-sy, 0.0), vec3(0.06, 0.01, z)); //HORIZ //RECT connection\n    d = min(d41,d42);   \n    dq1 = min(dq1, d);\n    dq1 = min(dq1,d43);\n    //dq = min(d, d44);\n\n    //Е\n    \n    //Т\n    \n    //А\n    \n    //Ч\n        \n    \n       \n    d = min(d1,d2);\n    d = min(d, min(d3,d4));\n    d = min(d, min(d5,d6));\n    d = min(d, min(d7,d8));       \n    d = min(d, d9);\n    d = min(d, d10);\n    d = min(d, d11);\n    d = min(d, d12);\n    d = min(d, d13);\n    float dx = min(d14, d15);\n    d = min(d,dx);\n    dx = min(d16,d17);\n    d = min(d,dx);\n    float dy = min(d18,d19);\n    d = min(d,dy);\n    dx = min(d20,d21);\n    dy = min(d22,d23);\n    d = min(d,dx);\n    d = min(d,dy);\n   // dx = min(d24,d25);\n   // d = min(d,dx);\n    // = min(d,d26);\n    dx = min(d24,d25);\n    d = min(d,dx);\n    d = min(d26,d);\n    dx = min(d27,d28);\n    dy = min(d,d29);\n    d = min(dx,dy);\n    d = min(d, dq1);\n       \n    return d;\n}\n\n// Normal vector - http://www.pouet.net/topic.php?which=7920&page=10 by rear\nvec3 normal(vec3 p)\n{\n\t#define dr 1e-5\n\tvec3 drx = vec3(dr,0,0);\n\tvec3 dry = vec3(0,dr,0);\n\tvec3 drz = vec3(0,0,dr);\n\treturn ( vec3( dist(p+drx), dist(p+dry), dist(p+drz) ) - dist(p)) / dr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0.);    \n    vec2 r = (fragCoord.xy / iResolution.xy);\n\tr.x*=(iResolution.x/iResolution.y);\t           \n    r -=vec2(0.1, 0.8);    \t\t    \n    //r -=vec2(0.1, 0.6);  \n    //vec3 camera = vec3(1.05+(sin(iTime))*cameraSpeed,cameraYz); //more to the center      \t\n    vec3 camera = vec3(1.75+(sin(iTime)*0.6)*cameraSpeed,cameraYz); //\n    \n    //vec3 ro =  vec3(r.x, r.y+1.0, -1.0);    \n    //vec3 ro =  vec3(r.x+0.3, r.y+1.0 - cos(iTime)/4., -1.0 +sin(iTime)/3.);   \n    vec3 ro =  vec3(r.x+0.3, r.y+1.0, -1.0 +sin(iTime)/3.);   //Slight zoom\n    vec3 p = ro;  //ray origin          \n\tvec3 dir = normalize(p-camera); //ray direction\n    float d; //distance\n    \n\tfor(int i=0; i<STEPS; i++) //Ray marching\n\t{\n\t\td = dist(p);\n\t\tif(d < EPS) break;\n\t\tp = p+dir*d;\n\t}\n\n    vec3 materialcolor=vec3(0.);        \n    int m;  \n    if (d<=cube) { m = 0; materialcolor = vec3(0.9,.9,.2);} //cube;\n    else { m = 1; } //materialcolor = vec3(0.);}\n            \n\tvec3 nor = normal(p);  // normal vector\n    vec3 lightpos = vec3(1.5-sin(iTime)*5., 0.1+sin(iTime), 3.5+sin(iTime)*5.);           \n    lightpos.y +=sin(iTime); // [-1., +1]\n         \n    vec3 lightdir = normalize(vec3(0.3,0.3,0.3)-lightpos);\n   \t\n    float light = 1.0 + 0.01*(dot(nor,lightpos)); //intensity\n    \n    light *=  pow(dist(lightdir-p), 2.);\n    \n\t//vec3 color = vec3(light);\n    vec3 color = vec3(1.0-light/5.); //vec3(1.0, 1.0, 1.0);\n    color = clamp( materialcolor*color, 0., 1.0);\n    \n    //Phong\n    float dif = clamp( dot( nor, lightdir ), 0.0, 1.0 ); //iq diffuse\n    vec3  ref = reflect( dir, nor );  //reflection\n    float spe = pow(clamp( dot( ref, lightdir ), 0.0, 1.0 ),16.0); //specular component\n        \n    color+=dif/3. + spe/2.;\n        \n\tfragColor = vec4(color, 1.0);\n    fragColor.xyz = vec3(color);\n    fragColor.w = m ==0 ? 1. : 0.; //\n             \n    vec2 pos = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n   //The space, stars... #28-11-2017 & electricity\n   if ( fragColor.r < 0.001 && m==1)\n    {     \n        //To do: add more effects: specific stars, nebullas, planets, comets, black hole etc.... had meteors, but were removed;    \n        vec2 n1 = N22(pos);\n        float star = n1.x < 0.07 ? 0.1 : 0.;        \n        star+= n1.y > 0.97 ? N1(n1.x)/1.0*(max(star, sin(iTime))) : 0.0;\n        vec2 fb = fbm(pos);\n        star*=max(fb.x, fb.y);       \n        fragColor += star*1.4; //brighter stars\n        fragColor.a = 1.0;                                 \n        fragColor.xyzw+=vec4(clamp(abs(cos(iTime/3.5))*4.28, 1., 3.)*electricity(uv), 1.0); //thick line        \n    }\n    else //The blocks\n    {\n        \n     const float EPSLIMIT = EPS*5.; //0.06;\n        /*\n     float limit = 0.0;     \n     ro =  vec3(r.x, r.y+1.0, -1.0);    \n     p = ro;\n\t dir = normalize(p-camera);                     \n\t for(int i=0; i<STEPS/3; i++)  //Second marching for the rotating block and the burst. Fewer steps and lower precision are enough.\n\t {\n        d = distLimitBorder(p);\n\t\tif(d < EPSLIMIT) break;\n\t\tp = p + dir * d;\n\t  }\n        */\n        \n      if (d<EPSLIMIT) fragColor.xyz += electricity(uv);\n            \n      fragColor.w = 1.0; //Alpha\n      \n    }\n   \n    //Gamma correction\n     fragColor.xyz=pow(fragColor.xyz, vec3(1.4));\n    \n}","name":"Image","description":"","type":"image"}]}