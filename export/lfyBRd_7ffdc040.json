{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Star Nest by Pablo RomÃ¡n Andrioli\n// copied from https://www.shadertoy.com/view/XlfGRj\n//\n// This content is under the MIT License.\n// (copied for API availability + VR)\n\n#define iterations 10\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\nvec2 par(float t)\n{\n    return vec2(sin(t), cos(t) + 0.2 * atan(2. * iTime)) * (exp(cos(t + 0.2 * sin(iTime))) - 2. * cos(4. * t) - pow(sin(t / 12.), 5.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime;\n float s = 0.0, v = 0.0;\n  \n\tfloat t = time*0.005;\n\tuv.x += sin(t) * .3;\n\tfloat si = sin(t*1.5); // ...Squiffy rotation matrix!\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * .1, time * 0.0008);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z, 2.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\n\t\ts += .01;\n\t}\n    \n     vec2 screenspace = fragCoord/iResolution.xy;\n    vec2 clipspace = 2.*screenspace-1.;\n    clipspace = vec2(1.0,iResolution.y/iResolution.x)*clipspace;\n    float angle = atan(clipspace.y/clipspace.x);\n    float ray_count = 2.0*4.0; // always a multiple of 2\n    float sigma = 0.01*exp(cos(angle*ray_count))+0.4;\n    //fragColor = vec4(vec3(sigma),1);\n    vec4 fc2= vec4(vec3(exp(-dot(clipspace,clipspace)/sigma/sigma)),1);\n    \n    \n\tvec2 I=fragCoord;\n\t vec2 uv2 = 5. * (2. * I - iResolution.xy) / iResolution.y;\n    uv2.x = abs(uv2.x);\n    uv2*=dot(uv2.yx, uv2.xy);\n    float val = 0.;\n    val*=dot(uv2.x,uv2.y);\n    for(float t = 0.; t < 37.6991118431; t += 0.1)\n    {\n        val += 0.002 / distance(uv, par(t*10.));\n         \n        \n    }\n    \n     float s2 = 0.0, v2 = 0.0;\n    vec2 uv3 = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\tfloat t3 = time*0.005;\n\tuv3.x += sin(t3) * .3;\n\tfloat si3 = sin(t3*1.5); // ...Squiffy rotation matrix!\n\tfloat co3 = cos(t);\n\tuv3 *= mat2(co3, si3, -si3, co);\n\tvec3 col3 = vec3(0.0);\n\tvec3 init3 = vec3(0.25, 0.25 + sin(time * 0.001) * .1, time * 0.0008);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p = init3 + s2 * vec3(uv3, 0.143);\n\t\tp.z = mod(p.z, 2.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv2 += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s2) * .002;\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\n\t\tcol3 +=  vec3(v * 0.8, 1.1 - s2 * 0.5, .7 + v2 * 0.5) * v2 * 0.013;\n\t\ts2 += .01;\n\t}\n    val = exp(val) - 1.1;\n    vec3 col2 = vec3(val * 0.5, val * 0.5, val * val);\n\tvec3 from=vec3(1.,.5,0.5);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor+=vec4(col2*0.1+col3+fc2.xyz*0.7,1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":true,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfyBRd","date":"1734349906","viewed":136,"name":" shine star","username":"nayk","description":"combination source  https://www.shadertoy.com/view/lslyRn  https://www.shadertoy.com/view/lfVBRc https://www.shadertoy.com/view/Msl3WH","likes":2,"published":3,"flags":1,"usePreview":0,"tags":["galaxy","stars","universe"],"hasliked":0,"parentid":"","parentname":""}}