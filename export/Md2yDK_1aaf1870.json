{"ver":"0.1","info":{"id":"Md2yDK","date":"1493918012","viewed":670,"name":"Whirlpool Vortex","username":"decrooks","description":"Whirlpool ","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","swirl","spiral","vortex","whirlpool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n};\n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    Ray \t ray;\n    Material material;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2,light3;\nDirectionalLight dirLight;\n\nMaterial blackMat,whiteMat,bluishMat,yellowMat,oscMat,tableMat,tableDarkMat;\n\n\n    \nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nfloat smoothmin(float a, float b, float k)\n{\n    float x = exp(-k * a);\n    float y = exp(-k * b);\n    return (a * x + b * y) / (x + y);\n}\n\nfloat smoothmax(float a, float b, float k)\n{\n    return smoothmin( a,  b, -k);\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n   \n    float sd = smoothmax(d1.signedDistance,d2.signedDistance,3.0);\n    MapValue mv;\n  \tmv.material = d1.material;\n  \tmv.signedDistance = sd;\n  return mv;  \n    \n    /*if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }*/\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nMapValue subtractObjects( MapValue d1, MapValue d2 )\n{\n    \n    d1.signedDistance = -d1.signedDistance;\n    return intersectObjects(  d1, d2 );\n}\n\n\nvoid setMaterials() {\n    float t  = iTime;\n    float s = 0.4*(1.0+sin(t));\n    vec3 specular = vec3(0.3); \n    float shininess = 16.0;\n    blackMat = Material(LightColor(vec3(0.0,0.0,0.01),vec3(0.1,0.1,0.1)) ,35.0);\n    whiteMat = Material(LightColor(0.75*vec3(1.0,1.0,0.9),0.3*vec3(1.0,1.0,0.9)) ,shininess );\n\n}\n\n/////////////////////////   SDFs   ///////////////////////////////////\n\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n  vec3 a = p - origin;\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = dot(a,normal);\n  return mv;\n}\n\n\n\nfloat spiralWave(vec2 p, float ratio, float rate, float scale) {\n    \n    float r = length(p);\n    \n    float theta = atan(p.x,p.y);\n   \n    float logspiral = log(r)/ratio  + theta;\n   \n    return sin(rate*iTime + scale*logspiral);\n    \n}\n\n\nMapValue vortex( vec3 p ,vec3 c, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n    \n    vec2 v =  p.xz - c.xz;\n    \n float h1 = 0.03* spiralWave(v,0.618,3.0,5.0); \n    \n    float theta = 2.45*iTime;\n    \n  vec2 orbit = 0.2*vec2(sin(theta),cos(theta));  \n    \n     float h2 = 0.02*spiralWave(v+orbit,0.618,6.53,6.0);\n    \n  mv.signedDistance = length(v )  - exp(p.y + c.y + h1 + h2);\n  return mv;\n}\n\n\nMapValue sphere(vec3 p, vec3 center, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = distance(p, center) - radius;\n  return mv;\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n/////////////////////// Map The Scene ////////////////////////////////\n\nMapValue map(vec3 p){\n   \tfloat t  = iTime;\n   \t\n //   MapValue obj2  = sphere(p,vec3(-0.15),0.2, whiteMat);\n \n  //MapValue obj  = sphere(p,vec3(0.0),0.25, whiteMat);\n     MapValue vtx  = vortex(p,vec3(0.0,0.3,0.0), whiteMat);\n    \n    \n     MapValue pl = plane(p,vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0) ,whiteMat);\n      MapValue obj = subtractObjects( vtx,pl) ;  \n         \n         \n  //obj  = subtractObjects(obj2, obj);\n    \n  return obj;\n}\n\n\n//////////////////////////////////////////////////////////////////////\n/////////////////////// Raytracing ///////////////////////////////////\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    float dist = 0.01;\n    float presicion = 0.002;\n\tvec3 p;\n    MapValue mv;\n    \n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion || dist>maxDistance) break;\n       \n    }\n    \n    return Trace(dist,p,ray,mv.material);\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = traceRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\n/////////////////////// Lighting ////////////////////////////////\n\nvec3 diffuseLighting(in Trace trace, vec3 normal, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\nvec3 specularLighting(in Trace trace, vec3 normal, vec3 lightColor,vec3 lightDir){\n    //blinn-phong\n    //https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    vec3 viewDir = -trace.ray.direction;\n\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float specAngle = max(dot(halfDir, normal), 0.0);\n    float specular = pow(specAngle, trace.material.shininess);\n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\nvec3 pointLighting(in Trace trace, vec3 normal, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, normal, light.color.diffuse, lightDir);\n    \n    color += specularLighting(trace, normal, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, vec3 normal, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, normal, light.color.diffuse, light.direction);\n    \n    color += specularLighting(trace, normal, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(0.7);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(0.7),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(0.6),specular)); \n    light3 = PointLight(vec3(1.5*cos(1.6*time),0.15+ 0.15*sin(2.9*time),1.5*sin(1.6*time)),LightColor(vec3(0.6),specular));\n    dirLight = DirectionalLight(normalize(vec3(0.0,1.0,0.0)),LightColor(vec3(0.1),vec3(0.5)));\n} \n\n\nvec3 lighting(in Trace trace, vec3 normal){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, normal,light1);\n\tcolor += pointLighting(trace, normal,light2) ;\n    color += pointLighting(trace, normal,light3) ;\n\tcolor += directionalLighting(trace, normal,dirLight);\n    \n    return color;\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.7,1.4,-1.9);\n    \n    vec3 lookAt = vec3(0.0,-0.1,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.3);\n   \tTrace trace = traceRay(ray,12.0);\n    \n\tvec3 normal = calculateNormal(trace.p);\n    vec3 color = lighting(trace,normal);\n    \n   \treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}\n","name":"Image","description":"","type":"image"}]}