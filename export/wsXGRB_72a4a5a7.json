{"ver":"0.1","info":{"id":"wsXGRB","date":"1546800390","viewed":245,"name":"Mirror mirror on the ball","username":"Peetu","description":"who's the mirrorest of them all.\n\nMy first raytrace.\n\nYou can turn AA on by removing comments before #define AA 4.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.00001\n#define end 100.0\n#define start 0.01\n#define PI 3.14159265359\n#define SHADOW_ITERATIONS 8\n\n//remove comments for AA\n//#define AA 4.\n\nstruct Ray {\n\tvec3 orig;\n    vec3 dir;\n};\n    \nstruct Plane {\n\tvec3 pos;\n    vec3 normal;\n};\n    \nstruct Ball {\n\tvec3 pos;\n    float r;        \n};\n    \nstruct Cube {\n    vec3 pos;\n    float s;\n};\n    \nBall ball = Ball(vec3(0., 0.7, 0.), 0.5);\nBall greenball = Ball(vec3(.2, 0.37, 1.3), 0.15);\nCube cube = Cube(vec3(0., 0.25, -1.3), .25);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat3 rotationMatrixY(float rad) {\n    return mat3(\n        vec3(cos(rad), 0.0, sin(rad)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(rad), 0.0, cos(rad))\n    );\n}\n\nmat3 rotationMatrixX(float rad) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(rad), -sin(rad)),\n        vec3(0.0, sin(rad), cos(rad))\n    ); \n}\n\nmat3 rotationMatrixZ(float rad) {\n    return mat3(\n        vec3(cos(rad), -sin(rad), 0.0),\n        vec3(sin(rad), cos(rad), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nmat4 cubeMatrix(vec3 pos) {\n\treturn mat4( \n        vec4(1., 0., 0., 0.),\n        vec4(0., 1., 0., 0.),\n        vec4(0., 0., 1., 0.),\n        vec4(pos.x, pos.y, pos.z, 1.)\n    );\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nbool intersectBall(Ray ray, Ball ball, out float t) {\n    //L = hypotenuse\n    vec3 L = ball.pos - ray.orig;\n    //tca = cathetus from orig\n    float tca = dot(L, ray.dir);\n    //behind camera\n    if(tca < 0.0) return false;\n    //cathetus from ball center, pythagoran theorem, dot(a,a) = length(a)^2\n    float d = dot(L,L) - tca * tca;\n    //didn't hit\n    if(d > ball.r) return false;\n    //cathetus inside the ball from point of collision\n    float thc = sqrt(ball.r - d);\n    t = tca - thc;\n    return true;\n    \n}\n\n//ws = world space\nbool intersectCube(Ray wsRay, Cube cube, out float t) {\n    \n    //from world to local space\n    mat4 tr = inverse(cubeMatrix(cube.pos));\n    \n    vec4 o = tr * vec4(wsRay.orig, 1.);\n    vec4 d = tr * vec4(wsRay.dir, 0.);\n    Ray ray = Ray(o.xyz, d.xyz);\n    \n    vec3 m = 1.0/ray.dir;\n    vec3 n = m*ray.orig;\n    vec3 k = abs(m)*vec3(cube.s);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tNear = max( max( t1.x, t1.y ), t1.z );\n    float tFar = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tNear > tFar || tFar < 0.0) return false; // no intersection\n    \n    t = tNear;\n\n    return true;\n}\n   \nbool intersectPlane(Ray ray, Plane plane, out float t) {\n    vec3 p0 = plane.pos;\n    vec3 n = plane.normal;\n    vec3 l0 = ray.orig;\n    vec3 l = ray.dir;\n    \n    t = dot(p0 - l0, n) / dot(l, n);\n    return t > 0.;\n}\n\nbool shadow(vec3 orig, vec3 light) {\n    \n    float t;\n    Ray ray = Ray(orig, normalize(-light - orig));\n    return\n        intersectBall(ray, ball, t) ||\n        intersectBall(ray, greenball, t) ||\n        intersectCube(ray, cube, t);\n    \n}\n\nvec3 intersect(inout Ray ray, vec3 light, inout Ray reflection) {\n    \n    Plane plane = Plane(vec3(0.), vec3(0., 0.5, 0.));\n    Ball ball = Ball(vec3(0., 0.7, 0.), 0.5);\n    \n    Ray origRay = ray;\n    \n    float lowestT = end;\n    vec3 mirror = vec3(0.);\n        \n    float t;\n    //hit\n    vec3 p; //pos\n    vec3 n; //normal\n    vec3 col; //color\n    \n    bool hit = false;    \n        \n    //green ball\n    \n    if (intersectBall(ray, greenball, t)) {        \n        if(t < lowestT) {\n            lowestT = t;\n            p = ray.orig + ray.dir * t * (1.01);\n            n = normalize(p - greenball.pos);\n            \n            vec2 sphereCoordinates = vec2(\n                atan(n.x, n.z) / (2.*PI),\n                n.y\n            );\n            \n            col = vec3(0., 0.7, 0.) + texture(iChannel1, sphereCoordinates).rgb * 0.4;\n            \n            hit = true;\n        }\n    }\n    \n    if(intersectCube(ray, cube, t)) {\n        if(t < lowestT) {\n        \tlowestT = t;\n            p = ray.orig + ray.dir * (t - EPSILON);\n            n = normalize(trunc((p - cube.pos) / (cube.s - EPSILON))); \n            vec2 uv;\n            if(abs(n.x) > EPSILON) {\n            \tuv = p.yz - cube.pos.yz;\n            }\n            if(abs(n.y) > EPSILON) {\n            \tuv = p.xz - cube.pos.xz;\n            }\n            if(abs(n.z) > EPSILON) {\n            \tuv = p.xy - cube.pos.xy;\n            }\n            col = texture(iChannel2, uv).rgb * .4;\n            hit = true;           \n        }\n    }\n    \n    if (intersectPlane(ray, plane, t)) {\n        if(t < lowestT) {\n        \tlowestT = t;\n            p = ray.orig + ray.dir * t;\n            n = vec3(0., 1., 0.);\n            col = vec3(mod(floor(p.z) + floor(p.x), 2.) * .4 + .2 + 0.1);\n            hit = true;\n        }\n    }\n    \n    //mirror ball\n    \n    if (intersectBall(ray, ball, t)) {\n        if(t < lowestT) {\n            lowestT = t;\n            p = ray.orig + ray.dir * t;\n            n = normalize(p - ball.pos);\n            col = vec3(0.);\n            \n            //reflect\n            reflection = Ray(p, reflect(ray.dir, n));\n             \n            hit = true;\n        }\n    }\n    \n    if (hit) {\n        \n        //for penumbra\n        float lightAmt = 1.2;\n        \n        for(int i = 0; i < SHADOW_ITERATIONS * SHADOW_ITERATIONS; i++) {\n            float x = float(i % SHADOW_ITERATIONS);\n            float z = float(i / SHADOW_ITERATIONS);\n            float y = -2. * float(i) / float(SHADOW_ITERATIONS);\n            vec3 offset = vec3(x, y, z) * (4. / float(SHADOW_ITERATIONS));\n            \n        \tif (shadow(p, light + offset)) {\n        \t\tlightAmt -= 1./\n                    float(SHADOW_ITERATIONS * SHADOW_ITERATIONS);\n        \t}\n        }\n        \n        lightAmt = max(0., lightAmt - length(p.xz) * 0.06);\n        \n       \tvec3 viewDir = normalize(-ray.dir);\n        vec3 specularDir = reflect(normalize(light), n);\n        float diffuse = clamp(dot(n, normalize(-light)), 0.2, 3.0) * .7 + .3;\n        float specular = pow(max(dot(viewDir, specularDir), 0.0), 13.);\n        \n        specular *= max(0., pow(lightAmt, 2.) - 0.1);\n        \n        float smoothLight = (lightAmt * .8) + .2;\n        \n        return col * diffuse * smoothLight * .8 + vec3(specular);\n    }\n    \n    return vec3(pow(max(dot(normalize(-ray.dir), normalize(light-ray.orig)), 0.0), 20.)) * 3.;\n}\n    \n\nvec3 rayTrace(Ray ray, in vec3 light) {\n    //intersectPlane(ray, plane);\n    Ray reflection = Ray(vec3(0.), vec3(0.));\n    vec3 col = intersect(ray, light, reflection);\n    \n    //reflection\n    if(reflection.orig != vec3(0.)) {\n    \tcol += intersect(reflection, light, reflection) * 0.7 + 0.08;\n        \n        vec3 o = reflection.orig;\n        vec2 sphereCoordinates = vec2(\n            atan(o.x, o.z) / (2.*PI),\n            o.y\n        );\n        col += texture(iChannel0, sphereCoordinates.xy).rgb * .04;\n    }\n    \n    return col;\n}\n\n\nvec3 render(vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mat3 rot = rotationMatrixY(iTime * .5);\n\n    vec3 eye = rot * vec3(0.0, 0.8, 5.);\n    vec3 ray = rot * rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 light = vec3(8., -6., 12.);\n    \n    vec3 col = rayTrace(Ray(eye, ray), light);\n\n    // Output to screen\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n    #ifdef AA\n\t//AA code by JohnScholar\n    fragColor.rgb = render( fragCoord );\n    float c=(AA-1.)/AA;\n    vec3 txy =  render( fragCoord + vec2(c,c));\n    vec3 tx =  render( fragCoord + vec2(c,0.));\n    vec3 ty =  render( fragCoord + vec2(0.,c));\n    if (abs(fragColor.x - txy.x)>=3.0/256. || abs(fragColor.y - txy.y)>=3.0/256. || abs(fragColor.z - txy.z)>=3.0/256.  \n        || abs(fragColor.x - tx.x)>=3.0/256. || abs(fragColor.y - tx.y)>=3.0/256. || abs(fragColor.z - tx.z)>=3.0/256.   \n        || abs(fragColor.x - ty.x)>=3.0/256. || abs(fragColor.y - ty.y)>=3.0/256. || abs(fragColor.z - ty.z)>=3.0/256.)\n    {\n        fragColor.rgb += txy + tx + ty;\n\t    for (float x=0.; x<AA; ++x){\n    \t    for (float y=0.; y<AA; ++y){\n                if (!(y==0. && x==AA-1.) && !(x==0. && y==AA-1.)\n                    && !(y==0. && x==0.) && !(x==AA-1. && y==AA-1.)){\n    \t\t\t\tfragColor.rgb  += render( fragCoord + vec2(x/AA,y/AA) );\n                }\n        \t}\n    \t}\n\tfragColor.rgb /= AA*AA;\n    }\n    #else\n    fragColor.rgb = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}