{"ver":"0.1","info":{"id":"ttsGDM","date":"1556587549","viewed":195,"name":"Bernstein Basis Polynomials","username":"tpfto","description":"Plot the first few [url=https://en.wikipedia.org/wiki/Bernstein_polynomial]Bernstein basis polynomials[/url], which are used in evaluating Bézier curves.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","bezier","plot","polynomial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// plot first few Bernstein basis polynomials (https://en.wikipedia.org/wiki/Bernstein_polynomial)\n// the polynomials used to evaluate Bézier curves\n\n// plotter forked from https://www.shadertoy.com/view/4tB3WV\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// comment out to switch to light mode\n#define DARK_MODE\n\n// XY range of the display.\n#define DISP_SCALE 1.5\n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n// Tick thickness (in pixels).\n#define TICK_SIZE 1.0\n\n// Tick length.\n#define TICK_LENGTH 0.01 * DISP_SCALE\n\n// Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n// Number of grid lines per unit.\n#define GRID_LINES 4.0\n\n// degree of basis polynomials to plot; cubic (3) is the most popular case\n#define DEGREE 3\n\n// Kronecker delta\n#define kd(n, k) ((n == k) ? 1.0 : 0.0)\n\n// Horner-type algorithm for evaluating a Bernstein polynomial, from Farin (http://www.farinhansford.com/books/cagd/materials/allfiles.txt)\nfloat berneval(int n, float x)\n{\n\tint bc = 1;\n    float p = 1.0, y = 0.0;\n    float x1 = 1.0 - x;\n    \n    for (int k = 0; k < DEGREE; k++)\n    {\n        y = (y + p * float(bc) * kd(n, k)) * x1;\n        p *= x;\n        bc = (bc * (DEGREE - k))/(k + 1);\n    }\n    \n    return y + p * kd(n, DEGREE);\n}\n\nfloat Bernstein(int n, vec2 p)\n{\n\treturn p.y - berneval(n, p.x);\n}\n\nconst vec2 GRADH = vec2(0.01, 0);\n\n// central difference\n#define GRAD_BERN(n, p) (0.5 * vec2(Bernstein(n, p - GRADH.xy) - Bernstein(n, p + GRADH.xy), Bernstein(n, p - GRADH.yx) - Bernstein(n, p + GRADH.yx)) / GRADH.xx)\n\n// PLOT_Bernstein(Order, Color, Destination, Screen Position)\n#define PLOT_Bernstein(n, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(Bernstein(n, p) / length(GRAD_BERN(n, p)))))\n\n// generate golden angle colors from HSV\nvec3 colors( int k )\n{\n     return clamp( abs(mod(6.0 * fract(1.618 * float(k) + 0.142) + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0 );\n}\n\n#define MAKETICK(c) (clamp(1.0 + 0.5 * TICK_LENGTH - abs(c), 0.0, 1.0))\n\nfloat grid(vec2 p, bool showAxes, bool showTicks, bool showGrid)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\tfloat halfScale = 0.5 / GRID_LINES;\n    \n    float grid = 1.0;\n    float tick = 1.0;\n    float axis = 1.0;\n\t\n    if (showTicks) {\n\tfloat tickRad = (TICK_SIZE / iResolution.y) * DISP_SCALE;\n\ttick = halfScale - max( MAKETICK(p.y) * abs(uv.x - halfScale), MAKETICK(p.x) * abs(uv.y - halfScale));\n\ttick = smoothstep(0.0, tickRad, tick);\n    }\n    \n    if (showGrid) {\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tgrid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n    }\n\t\n    if (showAxes) {\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\taxis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad-0.05, axisRad, axis);\n    }\n\t\n\treturn min(tick, min(grid, axis));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\tuv *= DISP_SCALE;\n\t\n    vec3 col = WHITE;\n    \n    // set up axes and ticks\n    #ifdef DARK_MODE\n    col = mix(GRAY, DARK, grid(uv, true, true, false));\n    #else\n    col = mix(GRAY, LIGHT, grid(uv, true, true, false));\n    #endif\n    \n    for (int k = 0; k <= DEGREE; k++) PLOT_Bernstein(k, colors(k), col, uv);\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}