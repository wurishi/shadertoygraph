{"ver":"0.1","info":{"id":"Mts3Dr","date":"1436260116","viewed":191,"name":"Raymarching trash","username":"Izokina","description":"Playing with raymarching optimizations","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dummy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// #define DEBUG .01\n\nconst int COUNT = 2;\nconst int STEPS = 1000;\nconst int REFLECTIONS = 100;\nconst float DIST_EPS = .001;\nconst float EPS = .01;\nconst float FOG = .6;\nconst float BOTTOM = 1.;\nconst float FAR = 10.;\n\nvec2 start(vec2 coord) {\n    float scale = 2. / iResolution.x;\n    if (iResolution.y < iResolution.x)\n        scale = 2. / iResolution.y;\n    return vec2(coord.x - iResolution.x * .5, coord.y - iResolution.y * .5) * scale;\n}\n\nfloat touch(const in vec4 sphere, const in vec3 pos) {\n    return length(pos - sphere.xyz) - sphere.w;\n}\n\nstruct S {\n    vec4 pos;\n    vec4 col;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    S sphs[COUNT];\n    vec4 neg = vec4(0., 0., 1., 1.5);\n\tsphs[0] = S(vec4(0., 0., 1., 1.), vec4(1., 1., 0., .2));\n\tsphs[1] = S(vec4(sin(iTime), cos(iTime), .25, .25), vec4(0., 1., 0., .1));\n    vec3 pos = vec3(start(fragCoord), 0.);\n    vec3 dir = normalize(vec3(pos.xy, 1.5));\n    vec4 res = vec4(0., 0., 0., 1.);\n    for (int i = 0; i < REFLECTIONS; i++) {\n        float len = EPS;\n        float last = 0.;\n#ifdef DEBUG\n        float it = 0.;\n#endif\n        for (int j = 0; j < STEPS; j++) {\n#ifdef DEBUG\n            it += DEBUG;\n#endif\n            vec3 cur = pos + dir * len;\n            float dist = 0.;\n            if (dir.y < 0.)\n                dist = (cur.y + BOTTOM) / -dir.y;\n            else\n                dist = FAR;\n            dist = max(dist, -touch(neg, cur));\n            for (int g = 0; g < COUNT; g++)\n            \tdist = min(dist, touch(sphs[g].pos, cur));\n            len += dist;\n            if (len > FAR || (dist < DIST_EPS && dist < last))\n                break;\n            last = dist;\n        }\n        vec3 n;\n        vec4 col;\n        pos += dir * len;\n        float dist = pos.y + BOTTOM;\n        if (dist < DIST_EPS) {\n            if (dist < -DIST_EPS)\n                n = pos - neg.xyz;\n            else\n            \tn = vec3(0., 1., 0.);\n            if ((fract(pos.x) - .5) * (fract(pos.z) - .5) > 0.)\n                col = vec4(1., 0., 0., .2);\n            else\n                col = vec4(0., 0., 1., .6);\n        }\n        for (int g = 0; g < COUNT; g++) {\n            float cur = touch(sphs[g].pos, pos);\n            if (cur < dist) {\n                dist = cur;\n                n = pos - sphs[g].pos.xyz;\n                col = sphs[g].col;\n            }\n        }\n#ifdef DEBUG\n        res.r += it;\n#endif\n        dir -= n * dot(dir, n) / dot(n, n) * 2.;\n        float g = exp(-len * FOG);\n        res.a *= g;\n        float my = res.a * col.a;\n#ifdef DEBUG\n        res.gb += col.gb * my;\n#else\n        res.rgb += col.rgb * my;\n#endif\n        res.a -= my;\n        if (res.a < EPS)\n            break;\n    }\n    fragColor = res;\n}","name":"Image","description":"","type":"image"}]}