{"ver":"0.1","info":{"id":"mlXGDl","date":"1672769133","viewed":119,"name":"Filling Pie Timer","username":"Rutilius","description":"This is an animation of a circular filling timer \nI made this animation to learn the use of the font texture, and because I have seen this timer in the cinema as interval counter in the middle of the film","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["time","circle","number","font","pie","timer","filling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------- {\n// This is an animation of a circular filling timer \n//\n// I made this animation to learn the use of the font texture,\n// and because I have seen this timer in the cinema\n// as interval counter in the middle of the film\n// ---------------------------------------- }\n\n// Total duration of the timer\n// ----------------------------------------\n#define TIMER_SECONDS 300.\n// Size of the timer\n// ----------------------------------------\n#define SIZE 0.49\n// Timer speed put it to 1. to be in real time\n// ----------------------------------------\n#define TIMER_SPEED 1.\n// Timer background filling animation direction, true to go clockwise, false to go counter clockwise\n// ----------------------------------------\n#define IS_CLOCKWISE true\n\n// Constants\n// ----------------------------------------\n#define PI_TWO   1.570796326794897\n#define PI    3.141592653589793\n#define TWO_PI   6.283185307179586\n#define DEG2RAD    0.0174532925\n#define INVERSE_LOG10 0.434294481903\n#define ONE_MINUTE 60.\n\n// Macros\n// ----------------------------------------\n#define antialiasing(n) (n)/min(iResolution.x,iResolution.y)\n#define S(a, t) smoothstep(a, antialiasing(1.) + (a), t)\n#define log10(x) (INVERSE_LOG10 * log(x))\n#define deg2rad(degree) ((degree) * DEG2RAD)\n#define rotateDegree(theta, p) (rotate2d(deg2rad(theta)) * (p))\n#define saturate(x) clamp(x, 0., 1.)\n#define inv(f) (1. - (f))\n#define normCoords(coords) (((coords) - (.5 * iResolution.xy)) / (float(iResolution.x > iResolution.y) * iResolution.y + float(iResolution.x <= iResolution.y) * iResolution.x))\n\n// Common Rotate matrix 2d\n// ----------------------------------------\nmat2 rotate2d(float theta) { return mat2(cos(theta) , sin(theta), -sin(theta), cos(theta)); }\nvec2 rotate2d(float theta, vec2 p){ return rotate2d(theta) * p; }\n\n// Box signed distance from https://iquilezles.org/articles/distfunctions2d/\n// ----------------------------------------\nfloat sdBox(vec2 p, vec2 b){ vec2 d = abs(p) - b; return length(max(d, .0)) + min(max(d.x, d.y), .0);}\nfloat sdBoxRound(vec2 p, vec2 b, float r) { return sdBox(p, b) - r; }\n\n// This function return in position \"p\" the square of the character in the font at the coordinate \"coord\"\n// - Output:\n//     \"x\": The precalculate value of the character\n//     \"y\": The signed distance from the character in the x axis\n//     \"z\": The signed distance from the character in the y axis\n//     \"w\": The signed distance field from the character from 1. to 0.\n// - Inputs:\n//     \"p\": The center position of the character, will get the square between the positions (-1., -1.) and (1., 1.) \n//     \"coord\": The coordinate of the 16*16 matrix of the texture in the iChannel0 \n// ----------------------------------------\nvec4 sampleFontChar(vec2 p, ivec2 coord) {\n    const float fontElementsSide = 16.;\n    const float fontGridSide = 1. / fontElementsSide;\n    const vec2 centerOffset = vec2(fontGridSide / 2., -fontGridSide / 2.);\n    p *= fontGridSide;\n    p += centerOffset;\n    bool isChar = p.x > 0. && p.x <= fontGridSide && p.y < 0. && -p.y <= fontGridSide;\n    \n    if(!isChar) {\n        return vec4(0.);\n    }\n    \n    vec2 charOffset = vec2(-float(coord.x) * fontGridSide, float(coord.y) * fontGridSide); \n    vec2 charPos = vec2(p.x, p.y + 1.) - charOffset;\n    vec4 tex = texture(iChannel0, charPos);\n    tex.a = 1. - tex.a;\n    return tex;\n}\n \n// This function return in position \"p\" the square of the character of the required digit\n// - Output:\n//     \"x\": The precalculate value of the character digit\n//     \"y\": The signed distance from the character digit in the x axis\n//     \"z\": The signed distance from the character digit in the y axis\n//     \"w\": The signed distance field from the character digit from 1. to 0.\n// - Inputs:\n//     \"p\": The center position of the character digit, will get the square between the positions (-1., -1.) and (1., 1.) \n//     \"digit\": The digit value to obtain the value will be wrapped in the [0, 9] range\n// ----------------------------------------\nvec4 getDigit(vec2 p, int digit) {\n    return sampleFontChar(p, ivec2(abs(digit) % 10, 3)); \n}\n\n// This function return the number of digits of the value \"number\"\n// ----------------------------------------\nint countDigits(int number) {\n    bool isLowerThanOne = number < 1;\n    return int(isLowerThanOne) * 1 + int(!isLowerThanOne) * int(floor(log10(float(number)) + 1.));\n}\n\n// valid range [0, 9999989]\n// This function return in position \"p\" the characters of the number \"num\" with a specified distance \"dist\" between each character\n// - Output:\n//     \"x\": The precalculate value of the characters\n//     \"y\": The signed distance from the characters in the x axis\n//     \"z\": The signed distance from the characters in the y axis\n//     \"w\": The signed distance field from the characters from 1. to 0.\n// - Inputs:\n//     \"p\": The center position of the characters\n//     \"num\": The value to be converted in characters, the valid range of this value is [0, 9999989] cause the floating point precision\n//     \"dist\": The distance between the characters\n// ----------------------------------------\nvec4 getNumber(vec2 p, int num, float dist) {\n    num = abs(num);\n    float digits = float(countDigits(num));\n    \n    float totalSize = digits * dist;\n    p += vec2(totalSize / 2., 0.);\n    \n    float shift = floor(p.x / dist);\n    \n    if(shift + 1. > digits || shift < 0.) { return vec4(0.); }\n    \n    float inverseShift = digits - shift - 1.;\n    int currentDigit = int(floor(float(num) / pow(10., inverseShift)));\n   \n    vec2 offset = vec2(mod(p.x, dist) - (dist / 2.), p.y);\n    vec4 digit = getDigit(offset, currentDigit);\n    return digit;\n}\n\n// This function return the number of seconds in the time \"time\" with the max time \"resetTime\"\n// Meaning the result will be in the range [0, 60)\n// ----------------------------------------\nint getSeconds(float time, float resetTime) {\n    float cT = mod(time, resetTime);\n    int second = int(floor(abs(ONE_MINUTE - mod(cT - resetTime, ONE_MINUTE))));\n    return second;\n}\n\n// This function return the number of minutes in the time \"time\" with the max time \"resetTime\"\n// This value won't be wrapped around the 60 minutes of an hour\n// ----------------------------------------\nint getMinutes(float time, float resetTime) {\n    float cT = mod(time, resetTime);\n    float resetMinute = ceil(resetTime / ONE_MINUTE);\n    int minute = int(floor(abs(resetMinute - mod((cT - resetTime) / ONE_MINUTE, resetMinute))));\n    return minute;\n}\n\n// This function will draw the timer in position \"p\", at the time \"time\" wrapping it in the max time \"resetTime\"\n// Graph visualization: https://www.desmos.com/calculator/1746zvivxa\n// ----------------------------------------\nfloat timer(vec2 p, float time, float resetTime) {\n    const float dist = 0.5;\n    const float halfDist = dist / 2.;\n    \n    const float pointOffset = 0.1;\n    const float pointSize = 0.05;\n    const float pointRadius = 0.02;\n    \n    float f = 0.;\n\n    int seconds = getSeconds(time, resetTime); \n    int minute = getMinutes(time, resetTime);\n\n    if(minute > 0) {\n        float minuteDigits = float(countDigits(minute));\n        \n        p -= vec2(halfDist + halfDist / 2. + (minuteDigits - 1.) * pointSize, 0.);\n        p *= (1. + minuteDigits * 0.2);\n        \n        if(seconds > 9) {\n            f = getNumber(p, seconds, dist).a;    \n        } else {\n            f += getNumber(p + vec2(halfDist, 0.), 0, dist).a;\n            f += getNumber(p - vec2(halfDist, 0.), seconds, dist).a;\n        }\n       \n        f += step(sdBoxRound(p + vec2(dist + pointOffset, pointOffset), vec2(pointSize), pointRadius), 0.); \n        f += step(sdBoxRound(p + vec2(dist + pointOffset, -pointOffset), vec2(pointSize), pointRadius), 0.); \n        \n        f += getNumber(p + vec2(dist + (halfDist * minuteDigits) + pointOffset * 2., 0.), minute, dist).a;\n    } else {\n        if(seconds > 9) {\n            f = getNumber(p * 0.8, seconds, dist).a;\n        } else {\n            f = getNumber(p * 0.6, seconds, dist).a;\n        }\n    }\n    return S(0.49, f);\n}\n\n// This function return the angular distance field with origin at position \"p\" and\n// will be clockwise if \"isClockwise\" is true else will be counter clockwise\n// ----------------------------------------\nfloat angularDistanceField(vec2 p, bool isClockwise) {\n    vec2 pos = float(isClockwise) * rotate2d(-PI_TWO, p).xy + float(!isClockwise) * rotate2d(PI, p).yx;\n    float angle = atan(pos.x, pos.y);\n    return (angle + PI) / TWO_PI;\n}\n\n// This function return the filled angular slice with origin at position \"p\",\n// the result will have a fill quantity \"t\" in range [0., 1.],\n// the result will be clockwise if \"isClockwise\" is true else will be counter clockwise\n// ----------------------------------------\nfloat angularFillQuantity(vec2 p, bool clockwise, float t) {\n    float c = angularDistanceField(p,  clockwise);\n    return S(c, t);\n}\n\n// This function draw the notches of the seconds and minutes in the position \"p\" in a circular manner,\n// the number of notches is calculated by the max time \"resetTime\",\n// The \"size\" indicate the distance from the center to start draw the notches\n// the result will be clockwise if \"isClockwise\" is true else will be counter clockwise\n// ----------------------------------------\nfloat outerCircleTime(vec2 p, float resetTime, bool isClockwise, float size) {\n    const float ces = 0.015;\n    const float cis = 0.03;\n    float ce = step(0., length(p) - size + ces);\n    float ci = step(0., length(p) - size + cis);\n\n    float totalMinutes = float(getMinutes(0., resetTime));\n    float adf = angularDistanceField(p, isClockwise);\n    float adfTao = adf * TWO_PI;\n\n    float sc = cos(adfTao * floor(resetTime));\n    \n    float prcMinutes = floor(resetTime) / ONE_MINUTE;\n    float reminder = mod(prcMinutes, 1.) * TWO_PI;\n    float sm = float(totalMinutes > 0.) * cos(adfTao * prcMinutes - reminder) + float(totalMinutes <= 0.) * 0.;\n\n    return saturate((ce * S(0.7, sc)) + (ci * S(0.999, sm)));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = normCoords(fragCoord.xy);\n\n    float totalTime = TIMER_SECONDS;\n    float time = iTime * TIMER_SPEED;\n    float size =  SIZE;\n    bool clockwise = IS_CLOCKWISE;\n    \n    float prcTime = mod(time, totalTime) / totalTime;\n    \n    vec2 backPos = rotateDegree(-90., p);\n    float backFill = angularFillQuantity(backPos, clockwise, prcTime);\n    float backTime = outerCircleTime(backPos, totalTime, clockwise, size);\n    float back = (backFill + backTime) * S(length(p), size);\n    \n    vec2 textPos = p * (1. / size);\n    float text = timer(textPos, time, totalTime);\n\n    float f = saturate(back - text) + saturate(text - back);\n\n    vec3 color = vec3(f);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}