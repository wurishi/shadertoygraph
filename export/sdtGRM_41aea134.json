{"ver":"0.1","info":{"id":"sdtGRM","date":"1629456336","viewed":602,"name":"20210820","username":"0b5vr","description":"haha","likes":19,"published":1,"flags":32,"usePreview":1,"tags":["ifs","pathtracer"],"hasliked":0,"parentid":"NtSSDt","parentname":"20210813_two"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Present\n\n#define saturate(i) clamp(i,0.,1.)\n\nconst float WEIGHT_1 = 1.0 / 16.0;\nconst float WEIGHT_2 = 2.0 / 16.0;\nconst float WEIGHT_4 = 4.0 / 16.0;\n\nbool isValidUV( vec2 uv ) {\n  return all( lessThan( abs( uv - 0.5 ), vec2( 0.5 ) ) );\n}\n\nvec4 fetch( sampler2D sampler, vec2 uv, float level ) {\n  if ( !isValidUV( uv ) ) {\n    return vec4( 0.0 );\n  }\n\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25, 0.125...\n  vec2 uvt = level < 0.0 ? uv : ( ( 1.0 - p ) + 0.5 * uv * p );\n\n  vec4 tex = texture( sampler, uvt );\n  return tex;\n}\n\nvec4 tap9( sampler2D sampler, vec2 uv, float level ) {\n  vec2 deltaTexel = pow( 2.0, 1.0 + level ) / iResolution.xy;\n\n  // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n  vec4 tex = WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0, -1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  0.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  0.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  1.0 ), level );\n  return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec2 p = uv * 2.0 - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  vec4 tex = texture( iChannel0, uv );\n\n  vec3 col = saturate( tex.rgb / tex.a );\n  col += 0.5 * tap9( iChannel1, uv, 0.0 ).rgb;\n  col = pow( col, vec3( 0.4545 ) );\n  col *= 1.0 - 0.2 * length( p );\n\n  fragColor = vec4( col, 1 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Scene\n\n#define saturate(i) clamp(i,0.,1.)\n\nconst float PI = acos( -1. );\nconst float TAU = PI * 2.0;\nconst float EPSILON = 1E-4;\nconst float FAR = 1E3;\n\nvec4 seed;\n\nmat2 rotate2D( float t ) {\n  return mat2( cos( t ), sin( t ), -sin( t ), cos( t ) );\n}\n\n// Ref: https://cs.uwaterloo.ca/~thachisu/tdf2015.pdf\nfloat random() {\n  const vec4 q = vec4( 1225, 1585, 2457, 2098 );\n  const vec4 r = vec4( 1112, 367, 92, 265 );\n  const vec4 a = vec4( 3423, 2646, 1707, 1999 );\n  const vec4 m = vec4( 4194287, 4194277, 4194191, 4194167 );\n    vec4 beta = floor( seed / q );\n    vec4 p = a * ( seed - beta * q ) - beta * r;\n    beta = ( sign( -p ) + vec4( 1 ) ) * vec4( 0.5 ) * m;\n    seed = ( p + beta );\n    return fract( dot( seed / m, vec4( 1, -1, 1, -1 ) ) );\n}\n\nvec2 random2() {\n  return vec2( random(), random() );\n}\n\nvec3 randomSphere() {\n  float phi = TAU * random();\n  float theta = acos( 1.0 - 2.0 * random() );\n  return vec3(\n    cos( phi ) * sin( theta ),\n    sin( phi ) * sin( theta ),\n    cos( theta )\n  );\n}\n\nvec3 randomHemisphere( vec3 N ) {\n  vec3 d = randomSphere();\n  return dot( N, d ) < 0.0 ? -d : d;\n}\n\nmat3 orthBas( vec3 d ) {\n  vec3 z = normalize( d );\n  vec3 x = normalize( cross(\n    abs( z.y ) < 0.999 ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 ),\n    z\n  ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nvec3 cyclicNoise( vec3 p, vec3 b, float pump ) {\n  mat3 bas = orthBas( b );\n  vec4 sum = vec4( 0.0 );\n\n  for ( int i = 0; i < 6; i ++ ) {\n    p *= bas * 2.0;\n    p += sin( p.yzx );\n    sum = pump * sum + vec4( cross( sin( p.zxy ), cos( p ) ), 1.0 );\n  }\n\n  return sum.xyz / sum.w;\n}\n\nvec3 F_Schlick( vec3 f0, float VdotH ) {\n  float v = 1.0 - VdotH;\n  return mix( f0, vec3( 1.0 ), ( v * v ) * ( v * v ) * v );\n}\n\nfloat G_Smith( float roughness, float NdotV, float NdotL ) {\n  float k = roughness;\n  k = k * k;\n  k /= 2.0;\n\n  float G1V = NdotV / ( NdotV * ( 1.0 - k ) + k );\n  float G1L = NdotL / ( NdotL * ( 1.0 - k ) + k );\n\n  return G1V * G1L;\n}\n\nvec3 importanceSampleLambert( vec3 N ) {\n  float phi = TAU * random();\n  float cosTheta = random();\n  cosTheta = cos( asin( sqrt( cosTheta ) ) );\n  cosTheta = saturate( cosTheta );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nvec3 importanceSampleGGX( float roughness, vec3 N ) {\n  float phi = TAU * random();\n  float cosTheta = random();\n  cosTheta = sqrt( ( 1.0 - cosTheta ) / ( 1.0 + ( pow( roughness, 4.0 ) - 1.0 ) * cosTheta ) );\n  cosTheta = saturate( cosTheta );\n  float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\n  return orthBas( N ) * vec3(\n    cos( phi ) * sinTheta,\n    sin( phi ) * sinTheta,\n    cosTheta\n  );\n}\n\nstruct Material {\n  vec3 albedo;\n  float roughness;\n  float metallic;\n  vec3 emissive;\n};\n\nstruct MarchResult {\n  float d;\n  Material mtl;\n};\n\nfloat sdbox( vec3 p, vec3 s ) {\n  vec3 d = abs( p ) - s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nvec3 ifs( vec3 p, vec3 r, vec3 s, int iter ) {\n  mat3 b = orthBas( r );\n  for( int i = 0; i < 10; i ++ ) {\n    if ( i >= iter ) { break; }\n    p = abs( p );\n    p.xz = p.x < p.z ? p.xz : p.zx;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    p.yz = p.y < p.z ? p.yz : p.zy;\n    s *= b;\n    s *= 0.58;\n    p = abs( p ) - abs( s );\n  }\n  return p;\n}\n\nMarchResult map( vec3 p ) {\n  float d = 1E9;\n  float d2;\n  Material mtl;\n  \n  vec3 rot = vec3( -0.8, -1.7, 2.9 );\n  vec3 shift = vec3( 4.1, 2.8, 4.2 );\n  \n  vec3 pt = p;\n\n  pt = p;  \n  pt.y = mod( pt.y - 1.0, 2.0 ) - 1.0;\n  d2 = -sdbox( pt, vec3( 20.0 ) );\n  d2 = max( d2, length( abs( pt.y ) ) - 0.2 );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.04, 0.05, 0.06 );\n    mtl.roughness = 0.7;\n    mtl.metallic = 0.7;\n    mtl.emissive = vec3( 0.0 );\n  }\n  \n  pt = ifs( p, rot, shift, 7 );\n  d2 = sdbox( pt, vec3( 0.1 ) );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.14, 0.15, 0.16 );\n    mtl.roughness = 0.14 + 0.02 * cyclicNoise( 4.0 * p, vec3( -1.0, 3.0, 4.0 ), 2.0 ).x;\n    mtl.metallic = 0.9;\n    mtl.emissive = vec3( 0.0 );\n  }\n  \n  d2 = sdbox( p, vec2( 0.5, 100.0 ).xyx );\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.05;\n    mtl.metallic = 0.05;\n    mtl.emissive = 10.0 * vec3( 7.0, 1.0, 2.0 );\n  }\n  \n  pt = p;\n  d2 = 15.0 - p.y;\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.05;\n    mtl.metallic = 0.05;\n    mtl.emissive = 10.0 * vec3( 0.5, 0.5, 3.7 );\n  }\n  \n  pt = p;\n  d2 = p.y + 25.0;\n  if ( d2 < d ) {\n    d = d2;\n    mtl.albedo = vec3( 0.0 );\n    mtl.roughness = 0.05;\n    mtl.metallic = 0.05;\n    mtl.emissive = 10.0 * vec3( 1.1, 0.2, 1.7 );\n  }\n\n  return MarchResult( d, mtl );\n}\n\nvec3 nMap( vec3 p, vec2 d ) {\n  return normalize( vec3(\n    map( p + d.yxx ).d - map( p - d.yxx ).d,\n    map( p + d.xyx ).d - map( p - d.xyx ).d,\n    map( p + d.xxy ).d - map( p - d.xxy ).d\n  ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  seed = texture( iChannel0, uv );\n  seed += float( iFrame );\n  random();\n\n  vec2 p = ( fragCoord.xy + random2() - 0.5 ) / iResolution.xy - 0.5;\n  p.x *= iResolution.x / iResolution.y;\n  \n  vec3 cp = vec3( 5.0, 3.0, 5.0 );\n  vec3 ct = vec3( 0.0 );\n  mat3 cm = orthBas( normalize( cp - ct ) );\n\n  vec3 ro = cm * vec3( 12.0 * p, 11 );\n  vec3 rd = cm * vec3( 0, 0, -1 );\n\n  vec3 col = vec3( 0 );\n  vec3 colRem = vec3( 1 );\n\n  for ( int iRef = 0; iRef < 7; iRef ++ ) {\n    float rl = 1E-2;\n    vec3 rp = ro + rd * rl;\n    MarchResult result;\n    \n    for ( int i = 0; i < 100; i ++ ) {\n      result = map( rp );\n      rl += 0.7 * result.d;\n      rp = ro + rd * rl;\n    }\n\n    if ( result.d > 1E-2 ) {\n      // col += 0.5 * colRem;\n      break;\n    }\n    col += result.mtl.emissive * saturate( colRem );\n    \n    vec3 N = nMap( rp, vec2( 0.0, 1E-4 ) );\n\n    ro = rp + N * EPSILON;\n\n    vec3 albedo = mix( 0.96 * result.mtl.albedo, vec3( 0.0 ), result.mtl.metallic );\n    vec3 f0 = mix( vec3( 0.04 ), result.mtl.albedo, result.mtl.metallic );\n\n    if ( random() < 0.5 ) {\n      // specular\n      // Ref: http://gregory-igehy.hatenadiary.com/entry/2015/02/26/154142\n      vec3 H = importanceSampleGGX( result.mtl.roughness, N );\n      vec3 wo = reflect( rd, H );\n      if ( dot( wo, N ) < 0.0 ) { break; }\n\n      float VdotH = dot( -rd, H );\n      float NdotL = dot( N, wo );\n      float NdotH = dot( N, H );\n      float NdotV = dot( N, -rd );\n      vec3 F = F_Schlick( f0, VdotH );\n      float G = G_Smith( result.mtl.roughness, NdotV, NdotL );\n\n      colRem *= F * G * VdotH / ( NdotH * NdotV );\n      rd = wo;\n    } else {\n      // diffuse\n      vec3 wo = importanceSampleLambert( N );\n      vec3 H = normalize( -rd + wo );\n\n      float VdotH = dot( -rd, H );\n      vec3 F = F_Schlick( f0, VdotH );\n\n      colRem *= ( 1.0 - F ) * albedo;\n      rd = wo;\n    }\n\n    colRem *= 2.0;\n\n    if ( dot( colRem, colRem ) < EPSILON ) {\n      break;\n    }\n  };\n\n  fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Accumulate\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  // accumulate using backbuffer\n  fragColor = texture( iChannel0, uv );\n\n  if ( iFrame > 1 && iMouse.w < 0.5 ) {\n    fragColor += texture( iChannel1, uv );\n  }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Bloom downsample\n\nconst float WEIGHT_1 = 1.0;\nconst float WEIGHT_2 = 2.0;\nconst float WEIGHT_4 = 4.0;\nconst vec3 LUMA = vec3( 0.299, 0.587, 0.114 );\n\nbool isValidUV( vec2 uv ) {\n  return all( lessThan( abs( uv - 0.5 ), vec2( 0.5 ) ) );\n}\n\nvec4 fetch( sampler2D sampler, vec2 uv, float level ) {\n  if ( !isValidUV( uv ) ) {\n    return vec4( 0.0 );\n  }\n\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25, 0.125...\n  vec2 uvt = level < 0.0 ? uv : ( ( 1.0 - p ) + 0.5 * uv * p );\n\n  vec4 tex = texture( sampler, uvt );\n  vec3 col = tex.rgb / tex.a;\n  float luma = dot( LUMA, col );\n  return vec4( col, 1.0 + 0.5 * luma );\n  // return vec4( tex.xyz, 1.0 + luma );\n}\n\nvec4 tap13( sampler2D sampler, vec2 uv, float level ) {\n  vec2 deltaTexel = pow( 2.0, 1.0 + level ) / iResolution.xy;\n\n  // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n  vec4 tex = WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0, -1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0, -1.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2( -0.5, -0.5 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.5, -0.5 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  0.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2( -0.5,  0.5 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.5,  0.5 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  1.0 ), level );\n  return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  float level = floor( -log2( 1.0 - uv.x ) );\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25...\n\n  vec2 uv0 = vec2( 1.0 - p );\n  vec2 uv1 = uv0 + 0.5 * p;\n  uv = ( uv - uv0 ) / ( uv1 - uv0 );\n\n  if ( !isValidUV( uv ) ) {\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec4 tex;\n  if ( level == 0.0 ) {\n    tex = tap13( iChannel0, uv, level - 1.0 );\n  } else {\n    tex = tap13( iChannel1, uv, level - 1.0 );\n  }\n\n  vec3 col = tex.w > 1E-3 ? tex.rgb / tex.w : vec3( 0.0 );\n\n  if ( level == 0.0 ) {\n    float brightness = dot( LUMA, col );\n    vec3 normalized = brightness < 1E-4 ? vec3( brightness ) : col / brightness;\n    col = max( 0.0, brightness - 1.0 ) * normalized;\n  }\n\n  fragColor = vec4( col, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Bloom upsample\n\nconst float WEIGHT_1 = 1.0 / 16.0;\nconst float WEIGHT_2 = 2.0 / 16.0;\nconst float WEIGHT_4 = 4.0 / 16.0;\n\nbool isValidUV( vec2 uv ) {\n  return all( lessThan( abs( uv - 0.5 ), vec2( 0.5 ) ) );\n}\n\nvec4 fetch( sampler2D sampler, vec2 uv, float level ) {\n  if ( !isValidUV( uv ) ) {\n    return vec4( 0.0 );\n  }\n\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25, 0.125...\n  vec2 uvt = level < 0.0 ? uv : ( ( 1.0 - p ) + 0.5 * uv * p );\n\n  vec4 tex = texture( sampler, uvt );\n  return tex;\n}\n\nvec4 tap9( sampler2D sampler, vec2 uv, float level ) {\n  vec2 deltaTexel = pow( 2.0, 1.0 + level ) / iResolution.xy;\n\n  // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n  vec4 tex = WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0, -1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0, -1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  0.0 ), level );\n  tex += WEIGHT_4 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  0.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  0.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2( -1.0,  1.0 ), level );\n  tex += WEIGHT_2 * fetch( sampler, uv - deltaTexel * vec2(  0.0,  1.0 ), level );\n  tex += WEIGHT_1 * fetch( sampler, uv - deltaTexel * vec2(  1.0,  1.0 ), level );\n  return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n\n  float level = floor( -log2( 1.0 - uv.x ) );\n  float p = pow( 0.5, level ); // 1.0, 0.5, 0.25...\n\n  vec2 uv0 = vec2( 1.0 - p );\n  vec2 uv1 = vec2( 1.0 - 0.5 * p );\n  uv = ( uv - uv0 ) / ( uv1 - uv0 );\n\n  if ( !isValidUV( uv ) ) {\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec4 tex = tap9( iChannel0, uv, level + 1.0 );\n  if ( level < 5.0 ) {\n    tex += tap9( iChannel1, uv, level + 1.0 );\n  }\n\n  vec3 col = tex.rgb;\n\n  fragColor = vec4( col, 1.0 );\n}","name":"Buffer D","description":"","type":"buffer"}]}