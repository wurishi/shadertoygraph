{"ver":"0.1","info":{"id":"fs33zB","date":"1630209979","viewed":127,"name":"Stormy Sky","username":"andrew741","description":"A atmospheric stormy sky with lightning, rain, clouds, and volumetric god rays.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["storm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nWARNING; FLASHING LIGHTS (lightning)\n\n*/\n\n\nvec4 phaseParams = vec4(0.83, 0.3, 0.3, 0.15);  // forwardScattering, backScattering, baseBrightness, phaseFactor\n\n\n// specular reflection and diffusion (im not using the diffusion in this shader, its a hit or miss)\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec3 random2(vec3 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec3 p = co;\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    vec3 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\nvec3 srandom(vec3 co)\n{\n    vec3 l1 = random2(vec3(floor(co.x),  ceil(co.y), co.z));\n    vec3 l2 = random2(vec3( ceil(co.x),  ceil(co.y), co.z));\n    vec3 l3 = random2(vec3(floor(co.x), floor(co.y), co.z));\n    vec3 l4 = random2(vec3( ceil(co.x), floor(co.y), co.z));\n    float fx = fract(co.x);\n    return mix(mix(l3, l4, fx), mix(l1, l2, fx), fract(co.y));\n}\n\n\nvec2 srandom(vec2 co)\n{\n    vec2 l1 = random(vec2(floor(co.x),  ceil(co.y)));\n    vec2 l2 = random(vec2( ceil(co.x),  ceil(co.y)));\n    vec2 l3 = random(vec2(floor(co.x), floor(co.y)));\n    vec2 l4 = random(vec2( ceil(co.x), floor(co.y)));\n    float fx = fract(co.x);\n    return mix(mix(l3, l4, fx), mix(l1, l2, fx), fract(co.y));\n}\n\n\nvec3 sRandom(vec3 co)\n{\n    return mix(srandom(vec3(co.xy, floor(co.z))), srandom(vec3(co.xy, ceil(co.z))), fract(co.z));\n}\n\n\nfloat sampleNoise(vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\n\nfloat sampleRainMask (vec2 uv)\n{\n    return texture(iChannel0, uv).g;\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// 2d rotation matrix (the matrix was from some website because i dont know much about matricies)\nvec2 rot2D(vec2 v, float a)\n{\n    mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    return v * rot;\n}\n\n\nvec3 Transform(vec2 uv, vec2 m, float roll)\n{\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(rot2D(uv, roll), ro, vec3(0,0.,0), 1.);\n    return rd;\n}\n\n\n// from another website (finds where a ray intercets with a box)\nvec2 RayBox(vec3 boundsMin, vec3 boundsMax, vec3 ro, vec3 rd)\n{\n    vec3 t0 = (boundsMin - ro) / rd;\n    vec3 t1 = (boundsMax - ro) / rd;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float dstA = max(max(tmin.x, tmin.y), tmin.z);\n    float dstB = min(tmax.x, min(tmax.y, tmax.z));\n    \n    float dstToBox = max(0., dstA);\n    float dstInsideBox = max(0., dstB - dstToBox);\n    return vec2(dstToBox, dstInsideBox);\n}\n\n\nfloat GetScaler(float height)\n{\n    float h = height - 20.;\n    h /= 10.;\n    return pow(smoothstep(1., 0., abs(h - 1.)), 2.);\n}\n\n\nfloat sampleDensity(vec3 p)\n{\n    return sampleNoise(p.xz / 100. + 0.5) * GetScaler(p.y);\n}\n\n\n float hg(float a, float g)\n {\n    float g2 = g*g;\n    return (1.-g2) / (4.*3.1415*pow(1.+g2-2.*g*(a), 1.5));\n}\n\n\nfloat phase(float a)\n{\n    float blend = .5;\n    float hgBlend = hg(a,phaseParams.x) * (1.-blend) + hg(a,-phaseParams.y) * blend;\n    return phaseParams.z + hgBlend*phaseParams.w;\n}\n\n\nvoid RenderGodRays(vec3 rd, vec3 ro, vec2 dstCloudBox, vec3 sun_dir, inout vec3 col)\n{\n    if (dstCloudBox.y > 0. && sun_dir.y > 0.)\n    {\n        vec3 cp = ro + rd * dstCloudBox.x;\n        vec3 p = cp;\n        \n        float step_size = dstCloudBox.y / 101.;\n        vec3 stepSize = step_size * rd;\n        \n        float td = 0.;\n        \n        float s = 1. / 50.;\n        \n        for (int i = 0; i < 100; i++)\n        {\n            p += stepSize;\n        \n            vec2 dstB = RayBox(vec3(-50., 30., -50.), vec3(50., 40., 50.), p, sun_dir);\n            vec2 c = (p + sun_dir * dstB.x).xz * s + 0.5;\n            if (!(c.x <= 1. && c.x >= 0. && c.y <= 1. && c.y >= 0.) || !(dstB.y > 0.)) break;\n            float density = sampleNoise(c) * step_size;\n            td += density;\n        }\n        col *= exp(-td * 0.05) + 0.5;\n    }\n    else\n    {\n        col *= 1.5;\n    }\n}\n\n\nvoid RenderRain(vec3 rd, vec3 ro, vec2 dstCloudBox, vec3 wind_dir, inout vec3 col)\n{\n    if (dstCloudBox.y > 0. && wind_dir.y > 0.)\n    {\n        vec3 cp = ro + rd * dstCloudBox.x;\n        vec3 p = cp;\n        \n        float step_size = dstCloudBox.y / 276.;\n        vec3 stepSize = step_size * rd;\n        \n        float rain = 0.;\n\n        float s = 1. / 50.;\n        \n        for (int i = 0; i < 275; i++)\n        {\n            p += stepSize;\n        \n            vec2 dstB = RayBox(vec3(-50., 30., -50.), vec3(50., 40., 50.), p, wind_dir);\n            vec2 c = (p + wind_dir * dstB.x).xz * s + 0.5;\n            if (!(c.x <= 1. && c.x >= 0. && c.y <= 1. && c.y >= 0.) || !(dstB.y > 0.)) break;\n            float density = sampleRainMask(c) * step_size;\n            rain += density;\n        }\n        col = mix(col, vec3(0.8), 1. - exp(-rain * 0.015));\n    }\n}\n\nfloat RenderClouds(vec3 rd, vec3 ro, vec2 dstClouds, vec3 sun_dir, vec3 lp, inout vec3 col)\n{\n    if (dstClouds.y > 0.)\n    {\n        vec3 cp = ro + rd * dstClouds.x;\n        //vec3 exit = cp + rd * dstClouds.y;\n        \n        float sampleIn = 46.;\n        \n        float dstThrough = length(dstClouds.y) / sampleIn;\n        vec3 stepSize = dstThrough * rd;\n        \n        // Phase function makes clouds brighter around sun\n        float cosAngle = dot(rd, sun_dir);\n        float phaseVal = phase(cosAngle);\n        \n        float transmittance = 1.;\n        float inscattered = 0.;\n        \n        vec3 p = cp;\n        \n        for (int s = 0; s < int(sampleIn) - 1; s++)\n        {\n            p += stepSize;\n            \n            float density = sampleDensity(p) * dstThrough;\n            \n            if (density > 0.)\n            {\n                transmittance *= exp(-density);\n\n                vec3 sunP = p;\n                vec2 dstB = RayBox(vec3(-50., 20., -50.), vec3(50., 40., 50.), p, sun_dir);\n                float sunStepF = dstB.y / 16.;\n                vec3 sunStep = sunStepF * sun_dir;\n                \n                float totalSunDensity = 0.;\n                for (int sp = 0; sp < 15; sp++)\n                {\n                    sunP += sunStep;\n                    totalSunDensity += sampleDensity(sunP) * sunStepF;\n                }\n\n                inscattered += transmittance * density * exp(-totalSunDensity) * 3. * phaseVal;\n\n                if (transmittance < 0.05) break;\n            }\n        }\n        float le = 0.;\n        if (sampleRainMask(lp.xz) >= 0.4)\n        {\n            if (lp.x > -100.)\n            {\n                le = (1. - clamp(length(cp.xz - lp.xz) / 75., 0., 1.));\n            }\n        }\n        inscattered = inscattered * 0.85 + 0.15 * (1. - transmittance);\n        col = col * transmittance + inscattered + vec3(0., 0., 0.1 * (1. - transmittance)) * (1. - length(inscattered)) + le * (1. - transmittance) * (1. - length(inscattered));\n        return transmittance;\n    }\n    return 1.;\n}\n\n\nvoid RenderLightning(vec3 rd, vec3 ro, inout vec3 col)\n{\n    // checking if a bolt should strike\n    if (true)  // random(vec3(floor(iTime))).x < 0.1\n    {\n        vec3 lp = random2(vec3(floor(iTime))) * 70. - 35.;\n        if (sampleRainMask(lp.xz) >= 0.4)\n        {\n            vec3 ld = normalize(lp - ro);\n            float i = 0.75 * (sin(iTime * 20.) * 0.5 + 0.5);\n            i *= 1. - clamp(length(ro.xz - lp.xz) / 35., 0., 1.);\n            i = clamp(i, 0., 1.);\n            col += i;\n        }\n    }\n}\n\n\nvec3 RenderLightningBolt(vec3 rd, vec3 ro, inout vec3 col)\n{\n    // checking if a bolt should strike\n    if (true)  // random(vec3(floor(iTime))).x < 0.1\n    {\n        vec3 lp = random2(vec3(floor(iTime))) * 70. - 35.;\n        if (sampleRainMask(lp.xz) >= 0.4)\n        {\n            vec2 dst = RayBox(vec3(lp.x - 1., -20., lp.z - 1.), vec3(lp.x + 1., 30., lp.z + 1.), ro, rd);\n            if (dst.y > 0.)\n            {\n                col = mix(col, vec3(1.), 0.75 * (sin(iTime * 20.) * 0.5 + 0.5));\n            }\n        }\n        return lp;\n    }\n    return vec3(-150.);\n}\n\n\nvoid RenderFog(vec3 rd, vec3 ro, float depth, inout vec3 col)\n{\n    vec2 dst = RayBox(vec3(-50, -20, -50), vec3(50, -10, 50), ro, rd);\n    if (dst.y != 0.)\n    {\n        float scaler = 1. / 50.;\n    \n        vec3 p = ro + rd * dst.x;\n        float d_through = dst.y / 21.;\n        vec3 step_size = d_through * rd;\n        \n        float total_density = 0.;\n        \n        for (int s = 0; s < 20; s++)\n        {\n            total_density += texture(iChannel0, p.xz * scaler + 0.5).b * 0.1 * smoothstep(0.1, 1., 1. - (p.y * 0.1 + 2.));\n            p += step_size;\n        }\n        \n        col += (1. - exp(-total_density * 15. / dst.y)) * 0.5;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * 2.5;\n\n    vec3 rd = Transform(uv, iMouse.xy / iResolution.xy, 0.);\n    vec3 ro = vec3(0, (sin(iTime * 0.2) * 0.5 + 0.5) * 55. - 10., 0);\n    \n    float time = (5.03) * 0.25;\n    vec3 sun_dir = normalize(vec3(-cos(time) * 0.2, sin(time), cos(time)));\n    \n    vec3 col = vec3(0.25, 0.3, rd.y * 0.5 + 0.5);\n    \n    col = mix(col, vec3(1.) * 1.5, pow(max(dot(sun_dir, rd), 0.), 275.));\n    \n    vec2 ocean = RayBox(vec3(-50, -60, -50), vec3(50, -20, 50), ro, rd);\n    \n    vec2 dstClouds = RayBox(vec3(-50., 20., -50.), vec3(50., 40., 50.), ro, rd);\n    vec2 dstCloudBox = RayBox(vec3(-80, -20., -80.), vec3(80., 30., 80.), ro, rd);\n    \n    if (ocean.y > 0.)\n    {\n        vec3 cp = ro + rd * ocean.x;\n        \n        float dst = 1. - exp(-ocean.y * 0.075);\n        vec3 oceanCol = mix(vec3(0.1, 0.4, 0.6), vec3(0., 0.2, 0.5), dst) * 0.7;\n        vec3 cp2 = cp + vec3(iTime, 0., iTime);\n        float d = 1. - abs(sin(cp2.x + cp2.z) * 0.5 + 0.5) * 0.4;\n        d += 1. - abs(cos(cp2.z * 0.5) * sin(cp2.x * 0.2 + cp2.z) * 0.5 + 0.5);\n        d += 1. - abs(cos(cp2.z * 0.5) * sin(cp2.x * 0.2 + cp2.z) * 0.5 + 0.5);\n        d += 1. - abs(cos(cp.z * 0.4 + iTime * 0.5) * 0.5 * sin(cp.x * 0.2 + cp.z * 2. - iTime * 0.3) + 0.5);\n        for (float x = -1.; x < 2.; x++)\n        {\n            for (float y = -1.; y < 2.; y++)\n            {\n                //d += smoothstep(0.5, 0.8, dot2(cp.xz - (srandom(vec2(cp.x + x, cp.z + y)) + vec2(x, y))));\n            }\n        }\n        oceanCol *= d * 0.1 + 1.;\n        float highlight = pow(smoothstep(0.2, .3, pow(d * 0.15, 2.)), 2.2);\n        col = mix(col, oceanCol, dst) + highlight * 0.6;\n    }\n    \n    vec3 wind_dir = sRandom(vec3(iTime * 0.01));\n    wind_dir.y = 1.;\n    wind_dir.xz *= 0.5;\n    wind_dir = normalize(wind_dir);\n    \n    if (dstClouds.x > dstCloudBox.x)\n    {\n        vec3 lightningP = random2(vec3(floor(iTime))) * 100. - 50.;\n        float t = RenderClouds(rd, ro, dstClouds, sun_dir, lightningP, col);\n        RenderLightningBolt(rd, ro, col);\n        RenderRain(rd, ro, dstCloudBox, wind_dir, col);\n        RenderGodRays(rd, ro, dstCloudBox, sun_dir, col);\n        RenderFog(rd, ro, ocean.y == 0. ? 9999999. : ocean.x, col);\n        RenderLightning(rd, ro, col);\n    }\n    else\n    {\n        vec3 lightningP = RenderLightningBolt(rd, ro, col);\n        RenderRain(rd, ro, dstCloudBox, wind_dir, col);\n        RenderGodRays(rd, ro, dstCloudBox, sun_dir, col);\n        RenderFog(rd, ro, ocean.y == 0. ? 9999999. : ocean.x, col);\n        RenderClouds(rd, ro, dstClouds, sun_dir, lightningP, col);\n        RenderLightning(rd, ro, col);\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\nvec2 srandom(vec2 co)\n{\n    vec2 l1 = random(vec2(floor(co.x),  ceil(co.y)));\n    vec2 l2 = random(vec2( ceil(co.x),  ceil(co.y)));\n    vec2 l3 = random(vec2(floor(co.x), floor(co.y)));\n    vec2 l4 = random(vec2( ceil(co.x), floor(co.y)));\n    float fx = fract(co.x);\n    return mix(mix(l3, l4, fx), mix(l1, l2, fx), fract(co.y));\n}\n\n\nfloat noiseTexture(vec2 uv)\n{\n    vec2 sp = uv;\n    vec2 cell = floor(sp);\n    \n    vec2 cell1 = cell + vec2(-1, -1);\n    vec2 cell2 = cell + vec2(0 , -1);\n    vec2 cell3 = cell + vec2(1 , -1);\n    \n    vec2 cell4 = cell + vec2(-1, 0 );\n    vec2 cell5 = cell + vec2(0 , 0 );\n    vec2 cell6 = cell + vec2(1 , 0 );\n    \n    vec2 cell7 = cell + vec2(-1, 1 );\n    vec2 cell8 = cell + vec2(0 , 1 );\n    vec2 cell9 = cell + vec2(1 , 1 );\n    \n    vec2 offset1 = random(cell1);\n    vec2 offset2 = random(cell2);\n    vec2 offset3 = random(cell3);\n    vec2 offset4 = random(cell4);\n    vec2 offset5 = random(cell5);\n    vec2 offset6 = random(cell6);\n    vec2 offset7 = random(cell7);\n    vec2 offset8 = random(cell8);\n    vec2 offset9 = random(cell9);\n    \n    float dst1 = dot2(sp - (cell1 + offset1));\n    float dst2 = dot2(sp - (cell2 + offset2));\n    float dst3 = dot2(sp - (cell3 + offset3));\n    float dst4 = dot2(sp - (cell4 + offset4));\n    float dst5 = dot2(sp - (cell5 + offset5));\n    float dst6 = dot2(sp - (cell6 + offset6));\n    float dst7 = dot2(sp - (cell7 + offset7));\n    float dst8 = dot2(sp - (cell8 + offset8));\n    float dst9 = dot2(sp - (cell9 + offset9));\n    \n    float dst = min(min(min(dst1, dst2), min(dst3, dst4)), min(dst5, min(dst6, min(dst7, min(dst8, dst9)))));\n    return dst;\n}\n\n\nfloat roundB(float p, float b)\n{\n    return floor(p + b);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 1.;\n    float t = 0.;\n    float s = 0.01;\n    float dst = 0.;\n    vec2 u = fragCoord.xy / iResolution.xy * vec2(1280., 720.);\n    for (float o = 0.; o < 6.; o++)\n    {\n        t += a;\n        dst += noiseTexture(u * s + iTime * 0.25) * a;\n        a *= 0.4;\n        s *= 1.75;\n    }\n    dst /= t;\n    dst = dst * 1.5;\n    dst = 1. - clamp(dst, 0., 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    //dst /= smoothstep(1., clamp(length(srandom(uv * 14.)) * 4., 0.4, 0.7), length(uv));\n    \n    float d = dst * clamp(noiseTexture(fragCoord.xy * 0.001 + iTime * 0.1 + 10.) * 2.5 - 0.0025, 0., 1.);\n    float rainMask = roundB((noised(vec3(uv, -iTime * 0.025)).r) * pow(d, 2.) * 2.5 * (1. - pow(srandom(uv * 160. + iTime * 4.).r, 4.)), 0.95);\n\n    fragColor = vec4(d, clamp(rainMask, 0., 1.), noised(vec3(u.x * 0.005, u.y * 0.005, iTime)).x * 0.4 + 1., 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec2 random(vec2 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec2 p = co;\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    vec2 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\n","name":"Common","description":"","type":"common"}]}