{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n// Based on https://www.shadertoy.com/view/4ds3zn\n// Created by inigo quilez - iq/2013\n// Formula and raymarching modified by S.Guillitte \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n\nvec4 orb; \nfloat ss;\nfloat g=.85;\nvec3 CSize = vec3(1.0,0.8,1.1);\nvec3 C1 = vec3(1.0);\nfloat time;\nfloat t1;\n\n\nfloat map( vec3 p )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\n\tfor( int i=0; i<8;i++ )\n\t{\n\n\t\tp = (-1.0 + 2.0*fract(0.5*p*CSize+0.5))/CSize;\n\t\tp = clamp(p,-CSize,  CSize) * 2.0 - p;\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n\t\t//p=p.zyx;\n         orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = max(ss/r2,.1)*g;\n\n\n\t\tp     *= k;\n\t\tscale *= k;\n\n\t}\n\t//return 0.20*(-abs(p.x)+abs(p.y)+abs(p.z))/scale;\n\t//return 0.20*(abs(p.x)+abs(p.z))*abs(p.y)/scale;\n\t//return 0.20*(abs(p.x)+abs(p.z))/scale;\n\t//return 0.25*(length(p.xz)*abs(p.y))/scale;\n\t//return 0.2*(length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z))/scale;\n\tfloat d1= 0.2*(length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z)+length(p.yz)*abs(p.x))/scale;\n\tfloat d2 = 0.25*abs(p.y)/scale;\n\treturn (t1*d1+(1.-t1)*d2);\n}\n\nfloat map1( vec3 p )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\n\tfor( int i=0; i<3;i++ )\n\t{\n\n\t\tp = (-1.0 + 2.0*fract(0.5*p*CSize+0.5))/CSize;\n\t\tp = clamp(p,-CSize,  CSize) * 2.0 - p;\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n\t\t//p=p.zyx;\n         orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = max(ss/r2,.1)*g;\n\n\n\t\tp     *= k;\n\t\tscale *= k;\n\n\t}\n\t//return 0.20*(-abs(p.x)+abs(p.y)+abs(p.z))/scale;\n\t//return 0.20*(abs(p.x)+abs(p.z))*abs(p.y)/scale;\n\t//return 0.20*(abs(p.x)+abs(p.z))/scale;\n\t//return 0.25*(length(p.xz)*abs(p.y))/scale;\n\t//return 0.2*(length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z))/scale;\n\tfloat d1= 0.2*(length(p.xz)*abs(p.y)+length(p.xy)*abs(p.z)+length(p.yz)*abs(p.x))/scale;\n\tfloat d2 = 0.25*abs(p.y)/scale;\n\treturn (t1*d1+(1.-t1)*d2);\n}\n\n\nfloat trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 100.0;\n\tfloat precis = 0.001;\n        float approx = .1;\n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<200; i++ )\n    {\n\tif( t>maxd ) continue;//break;        \n\tif( abs(h)>approx||t>20.){\n            \n            t += h;\n\t    h = map1( ro+rd*t );\n            continue;}\n        if( abs(h)<precis*(1.+.2*t) ) continue;//break;//\n        \n        t += h;\n\th = map( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3  eps = vec3(.0001,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n\tnor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n\tnor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n\ttime = iTime*0.25 + 0.01*iMouse.x;\n\tt1 =  cos(0.1*iTime) ;\n    ss = 1.3 - 0.2*t1;\n\tt1 = step(  0.0, t1 );\n\t\n    // camera\n\tvec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.6 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n\tvec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.6 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n\tfloat roll = 0.2*cos(0.1*time);\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n\n    // trace\t\n\tvec3 col = vec3(0.0);\n\tfloat t = trace( ro, rd );\n\tif( t>0.0 )\n\t{\n\t\tvec4 tra = orb;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n\t\tfloat key = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat amb = (0.7+0.3*nor.y);\n\t\tfloat ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n\t\tvec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n\t\t\t brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n\t\t\t brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n\t\tvec3 rgb = vec3(1.0);\n\t\t//rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n\t\t//rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\t\trgb =(0.4*abs(sin(4.5+(vec3(tra.w,tra.y*tra.y,2.-tra.w))))+0.6*sin(vec3(-0.5,-0.2,0.8)+1.3+tra.x*9.5));//*.75 + .25;\n\t\t// color\n\t\tcol = rgb*brdf*exp(-0.2*t);\n\t}\n\n\tcol = sqrt(col);\n\t\n\tcol = mix( col, smoothstep( 0.0, 1.0, col ), 0.25 );\n\t\n\tfragColor=vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msj3zK","date":"1391190088","viewed":988,"name":"Apollonian revisited","username":"guil","description":"Based on https://www.shadertoy.com/view/4ds3zn by IQ","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal"],"hasliked":0,"parentid":"","parentname":""}}