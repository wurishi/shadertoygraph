{"ver":"0.1","info":{"id":"ddSfR1","date":"1689416036","viewed":54,"name":"raytracing_Yukina","username":"Yukina","description":"Implementing raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 単純なレイトレーシングの雛形\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(5.0, 2.0, 3.0); }\nvec3 CameraTo() { return vec3(0.2, 0.7, 0.2); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\nvec3 center() { return vec3(0.0, .0, -10.0); }\n    \nfloat radius() { return 3.0; }\n\n// ライトの方向と色\n// vec3 lightDir = normalize(vec3(-3.0, 2.0, -1.0));\n    \nvec3 lightCol = vec3(0.9);\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{\n    // TODO: ベクトル正規化normalize()や外積cross()を用いて実装する。\n    w = (from - to) / length(from - to);\n    u = cross(up, w) / length(cross(up, w));\n    v = cross(w, u);\n    e = from;\n    // return make_tuple(w, u, v, e);\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n    // TODO: ピクセル座標をカメラ座標系に変換する。\n    float x = FilmWidth()*(1.0-2.0*(pixelCoordinate.x+0.5)/iResolution.x);\n    float y = FilmHeight()*(1.0-2.0*(pixelCoordinate.y+0.5)/iResolution.y);\n    float z = FilmDistance();\n    return vec3(x, y, z);\n}\n\nvec3 lightDir() {\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    // vec3 mouse_cam = convertToCameraCoordinateSystem(mouse);\n    return normalize(vec3(mouse.x, mouse.y, -1.0));\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    // TODO: 以下を実装する。\n    // 1. ピクセル座標をカメラ座標系に変換\n    vec3 CameraCoordinate = convertToCameraCoordinateSystem(pixelCoordinate);\n    // 2. カメラパラメータからカメラ座標系の正規直交基底を計算。\n    vec3 u, v, w, e;\n    createOrthoNormalBasis(CameraFrom(), CameraTo(), CameraUp(), u, v, w, e);\n    // 3. ピクセル座標を基底を用いてワールド座標系に変換\n    vec3 pixel = CameraCoordinate.x*u+CameraCoordinate.y*v+CameraCoordinate.z*w+e;\n    // 4. カメラレイを計算。\n    Ray CameraRay = Ray(e, (e - pixel) / length(e - pixel)); \n    return CameraRay;\n}\n\nbool intersectToSphere(\n    vec3 center, float radius, Ray ray,\n    out Hit hit, out bool judge\n)\n{\n    // TODO: レイと球の交差判定を実装する。\n    // 二次方程式の解の計算に帰着する。\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0*dot(ray.dir, ray.org - center);\n    float c = dot(ray.org - center, ray.org - center) - radius * radius;\n    judge = false;\n    if (c < 0.0) judge = true;\n    else if (c > 0.0) {\n        if (((b*b-4.0*a*c) > 0.0) && (b/a < 0.0)) judge = true;\n        }\n    return judge;\n}\n\nbool intersect(Ray ray, out Hit hit, vec3 center, float radius, bool judge)\n{\n    hit.distanceToHitpoint = LargeFloat();\n\n    // TODO: intersectToSphere を用いて具体的な球との交差判定を行う。\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0*dot(ray.dir, ray.org - center);\n    float c = dot(ray.org - center, ray.org - center) - radius * radius;\n    if (intersectToSphere(center, radius, ray, hit, judge)) {\n        if (a > 0.0) hit.distanceToHitpoint = (-b+sqrt(b*b-4.0*a*c))/(2.0*a);\n        else if (a < 0.0) hit.distanceToHitpoint = (-b-sqrt(b*b-4.0*a*c))/(2.0*a);\n    }\n    vec3 p = ray.org + hit.distanceToHitpoint * ray.dir;\n    hit.normal = (p - center) / radius;\n\n    return hit.distanceToHitpoint < LargeFloat();\n}\n\n/*\nvec3 shade(Ray ray, Hit hit)\n{\n    // TODO: なんらかのシェーディングを行う。\n    return vec3(1.0, 0.0, 0.0);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n     \n    Hit hit;\n    bool judge;\n    if (intersect(ray, hit, center(), radius(), judge)) {\n        // ランバート反射\n        float diff = dot(hit.normal, lightDir());\n        fragColor = vec4(vec3(diff) * lightCol, 0.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}