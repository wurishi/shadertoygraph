{"ver":"0.1","info":{"id":"tsBBzV","date":"1590397859","viewed":97,"name":"First try at sphere raycasting","username":"mlaang","description":"Sphere raycasting.\n\nIt's possible to control the height of the sphere by left clicking in the window or dragging the mouse cursor upwards or downwards while holding the left mouse button pressed.\n\nSome tricks are used to allow CSG subtraction without SDF.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raysphereintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Parameters: Incoming ray: ray origin ro, ray direction rd\n *             Sphere: centre c, radius r\n *             Where the ray origin is outside the sphere.\n *             \n * Return value: If no intersection, a negative number,\n *               Otherwise the smallest positive t such that |ro + rd*t - c|=r\n */\nfloat ray_sphere_intersection(vec3 ro, vec3 rd, vec3 c, float r) {\n    //Is there some t so that the inequality dot(ro + rd*t - c, ro + rd*t - c) < r*r\n    //is satisfied?\n    //Let d = ro - c\n    \n    vec3 d = ro - c;\n    \n    //Then we have dot(d + rd*t, d + rd*t) < r*r\n    //Expanding, we obtain:\n    //dot(d,d) + dot(rd,rd)*t^2 + 2*dot(d,rd)*t < r*r\n    //Let e = r*r - dot(d,d)\n    \n    float e = r*r - dot(d,d);\n    \n    //Then the inequality is dot(rd,rd)*t^2 + 2*dot(d,rd)*t < e\n    //rd is chosen so that dot(rd,rd) is nonzero.\n    //Thus t^2 + 2*dot(d,rd)/dot(rd,rd)*t < e/dot(rd,rd).\n    //Let f = dot(d,rd)/dot(rd,rd) and g = e/dot(rd,rd);\n    \n    float f = dot(d,rd)/dot(rd,rd),\n          g = e/dot(rd,rd);\n    \n    //Then we have\n    //t^2 + 2f*t < g.\n    //Completing the square we obtain\n    //(t + f)^2 - f^2 < g.\n    //Let h = g + f^2\n    \n    float h = g + f*f;\n    \n    //Then the inequality is (t + f)^2 < h \n    //If h < 0 there is no solution. Otherwise the solution is the smallest number t\n    //such that (t+f)^2 = h.\n    \n    if(h < 0.0)\n        return -1.0;\n    else\n        return -sqrt(h)-f; //This is the smallest root of (t+f)^2=h for the reason that\n    \t\t\t\t\t   //f is always negative: this is because f = dot(d,rd)/dot(rd,rd)\n    \t\t\t\t\t   //and therefore has the same sign as dot(d,rd). d = ro - c\n    \t\t\t\t\t   //so dot(d,rd)=dot(ro-c,rd)= -dot(c-ro,rd); and c is always in front\n    \t\t\t\t\t   //of the ray, so c-ro is in the same direction as rd.\n}\n\n/* Parameters: Incoming ray: ray origin ro, ray direction rd\n *             Plane: normal plane_normal, point on the plane, plane_point.\n * Return value: If no intersection, a negative number,\n *               Otherwise the unique t such that ro + rd*t is on the plane.\n */\nfloat ray_plane_intersection(vec3 ro, vec3 rd, vec3 plane_normal, vec3 plane_point) {\n    //Is there some t so that dot(plane_normal, plane_point) = dot(plane_normal, ro + rd*t)?\n    //If so, that t is to be returned.\n    \n    //Bilinearity immediately ensures that\n    //dot(plane_normal, plane_point) = dot(plane_normal, ro) + dot(plane_normal, rd)*t\n    //Thus\n    //(dot(plane_normal, plane_point)-dot(plane_normal,ro))/dot(plane_normal, rd) = t\n    //This simplifies to\n    //dot(plane_normal, plane_point - ro)/dot(plane_normal, rd)=t\n    \n    //A solution exists if dot(plane_normal, rd) is not zero.    \n    if(dot(plane_normal, rd) == 0.0)\n        return -1.0;\n    else\n        return dot(plane_normal, plane_point - ro)/dot(plane_normal, rd);\n}\n\n/* Parameters: Incoming ray: ray origin ro, ray direction rd\n *             Sphere: centre c, radius r\n *             Where the ray origin is outside the sphere.\n *\n * Return value: If no intersection, a negative number,\n *               Otherwise the largest positive t such that |ro + rd*t - c|=r\n */\nfloat ray_antisphere_intersection(vec3 ro, vec3 rd, vec3 c, float r) {\n    //Calculating as in a ray-sphere intersection, but choosing the other root at the end.\n       \n    vec3 d = ro - c;\n    float e = r*r - dot(d,d);\n    float f = dot(d,rd)/dot(rd,rd),\n          g = e/dot(rd,rd);\n    float h = g + f*f;\n    \n    if(h < 0.0)\n        return -1.0;\n    else\n        return sqrt(h)-f; //This is the largest root of (t+f)^2=h for the same\n                          //reason that the corresponding return value in the ray_sphere_intersection\n                          //function is the smallest root.\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1.0 to 1.0) \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    \n    // Camera: ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 camera_direction = vec3(0.0, 0.0, 0.0) - ro;\n    vec3 rd = vec3(uv.xy, 0.0)-ro;\n    \n    //Objects\n    \n    //Large central sphere (object 0), having an antisphere on its surface.\n    vec3 c1 = vec3(0.0, 2.0*(iMouse.y/iResolution.y-0.5), 0.0);\n    float r1 = 0.9;\n    \n    vec3 ac1 = vec3(1.3, 0.0, -1.0);\n    float ar1 = 1.0;\n    \n    vec3 ac2 = vec3(0.0, 0.0, -1.0);\n    float ar2 = 0.3;\n    \n    //Smaller sphere orbiting around the large central sphere (object 1).\n    vec3 c2 = vec3(1.5*sin(iTime), 0.0, 1.5*cos(iTime));\n    float r2 = 0.2;\n    \n    //Plane (object 2).\n    vec3 plane_normal = vec3(0.0, 1.0, 0.0);\n    vec3 plane_point = vec3(0.0, -0.5, 0.0);\n    \n    //Sphere (object 3).\n    vec3 c3 = vec3(-10.0*cos(-iTime), 0.0, 10.0*sin(-iTime));\n    float r3 = 5.0;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0),\n         multiplier = vec3(1.0, 1.0, 1.0);\n    \n    float t[6];\n    const float epsilon = 0.000001;\n    \n    for(int j = 0; j != 15; ++j) {\n        t[0] = ray_sphere_intersection(ro, rd, c1, r1);\n        t[1] = ray_sphere_intersection(ro, rd, c2, r2);\n        t[2] = ray_plane_intersection(ro, rd, plane_normal, plane_point);\n        t[3] = ray_sphere_intersection(ro, rd, c3, r3);\n        t[4] = ray_antisphere_intersection(ro, rd, ac1, ar1);\n        t[5] = ray_antisphere_intersection(ro, rd, ac2, ar2);\n        \n        //In general, hits within a distance epsilon are disallowed and are to be ignored.\n        //This is because we are not nudging the intersection points to ensure that they are\n        //on the near side of the surface with which we intersect the ray, this in order\n        //to compute more exact reflections.\n        \n        //That having been said, we will now be concerned with resolving antisphere issues:\n        \n        //If the antisphere is not hit then we are not concerned with it\n        //if it is hit, however, a bunch of situations arise:\n        \n        //A hit going thorough the antisphere can hit the sphere or other objects\n        //this happens when the intersection with the antisphere lies outside the sphere\n        //and in that case the antisphere is to be ignored:\n        \n        if(t[4] > epsilon && dot(ro + rd*t[4]-c1, ro + rd*t[4]-c1) > r1*r1)\n            t[4] = -1.0;\n        \n        //Alternatively, a hit going through the antisphere can hit the concave surface\n        //defined by the antisphere. Then we must however ignore the sphere.\n        \n        if(t[4] > epsilon && dot(ro + rd*t[4]-c1, ro + rd*t[4]-c1) <= r1*r1)\n            t[0] = -1.0;\n        \n        //Finally we do it the same way for the second antisphere.\n        if(t[5] > epsilon && dot(ro + rd*t[5]-c1, ro + rd*t[5]-c1) > r1*r1)\n            t[5] = -1.0;\n        if(t[5] > epsilon && dot(ro + rd*t[5]-c1, ro + rd*t[5]-c1) <= r1*r1)\n            t[0] = -1.0;\n        \n        int chosen_object_along_ray = -1;\n        for(int i = 0; i != 6; ++i)\n            if(t[i] > epsilon)\n                chosen_object_along_ray = i;\n            \n        if(chosen_object_along_ray != -1)\n            for(int i = 0; i != 6; ++i)\n                if(t[i] < t[chosen_object_along_ray] && t[i] > epsilon)\n                    chosen_object_along_ray = i;\n                \n        vec3 intersection_point,\n             normal_component,\n             remainder,\n             new_direction;\n                \n        switch(chosen_object_along_ray) {\n            case 0:\n                //If we end up here we've hit object zero, a sphere, but not the antisphere\n                //that is part of this object.\n                    \n                intersection_point = ro + rd * t[0];\n                vec3 sphere_normal = normalize(intersection_point - c1);\n                    \n                //It is necessary to ensure that the intersection point is outside the sphere,\n                //or the next intersection of the ray may be with the sphere itself.\n            \n                //The incoming ray can be split into a component along the sphere normal and a remainder\n                \n                normal_component = sphere_normal * dot(rd, sphere_normal);\n                remainder = rd - normal_component;\n            \n                //The remainder will not be affected by being reflected\n                //But the normal component will be negated\n            \n                new_direction = remainder - normal_component;\n            \n                //We now have a new ray:\n                //with origin intersection_point and direction new_direction.\n                //We want to return the colour of whatever that hits\n            \n                ro = intersection_point;\n                rd = new_direction;\n            \n                col += (multiplier * vec3(0.0, 1.0, 0.0));\n                multiplier *= vec3(0.9, 0.9, 0.9);\n                break;\n            case 1:\n                col += (multiplier*vec3(1.0, 1.0, 1.0));\n                multiplier = vec3(0.0, 0.0, 0.0);\n                break;\n            case 2:\n                intersection_point = ro + rd * t[2];\n                \n                //The incoming ray is split into a component along the plane normal and a remainder\n            \n                normal_component = plane_normal * dot(rd, plane_normal);\n                remainder = rd - normal_component;\n            \n                //The remainder will not be affected by being reflected, but the normal component\n                //will be negated\n            \n                new_direction = remainder - normal_component;\n            \n                //We now have a new ray:\n            \n                ro = intersection_point;\n                rd = new_direction;\n            \n                col += (multiplier * vec3(0.0, 0.0, 0.7));\n                multiplier *= vec3(0.9, 0.9, 0.9);\n                break;\n            case 3:\n                col += (multiplier * vec3(1.0, 0.0, 0.0));\n                multiplier = vec3(0.0, 0.0, 0.0);\n            \n                //Because this is terminal and sets the multiplier vector to the zero vector\n                //it doesn't matter that we do not calculate a new ray.\n                break;\n            case 4:\n                //If we end up here we've hit both the antisphere and the sphere.\n                //We thus need to compute things as if though we hit the negative normal of\n                //the sphere that is the antisphere.\n                    \n                intersection_point = ro + rd * t[4];\n                   \n                vec3 antisphere_normal = -normalize(intersection_point - ac1);\n                    \n                normal_component = antisphere_normal * dot(rd, antisphere_normal);\n                remainder = rd - normal_component;\n                    \n                new_direction = remainder - normal_component;\n                    \n                ro = intersection_point;\n                rd = new_direction;\n                    \n                col += multiplier*vec3(0.0, 1.0, 0.0);\n                multiplier *= vec3(0.9, 0.9, 0.9);\n                break;\n            case 5:\n                //Here we do it the same way as above, but again\n            \n                intersection_point = ro + rd*t[5];\n                antisphere_normal = -normalize(intersection_point - ac2);\n                normal_component = antisphere_normal * dot(rd, antisphere_normal);\n                remainder = rd - normal_component;\n                new_direction = remainder - normal_component;\n                ro = intersection_point;\n                rd = new_direction;\n            \n                col += multiplier*vec3(0.0, 1.0, 0.0);\n                multiplier *= vec3(0.9, 0.9, 0.9);\n        }\n    }\n        \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}