{"ver":"0.1","info":{"id":"clcBz8","date":"1700929717","viewed":152,"name":"Konod's Apollonian fractal","username":"Konod","description":"An Apollonian fractal rendered with the Blinn-Phong model.\n\nThe shading follows the method of Unity's URP, as described here\nhttps://catlikecoding.com/unity/tutorials/rendering/part-4/\nClick and drag your mouse on the screen!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","blinnphong","metallicworkflow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Returns information on the corresponding pixel;\n// normalAndDist.xyz is the estimated normal.\n// normalAndDist.w is the distance to the camera.\n// If the pixel never reached the surface, normalAndDist will be equal to (0, 0, 0, -1).\nfloat apollonianSDF( vec3 p ) {\n    float s = 3.0f, e;\n    for ( int i = 0; i++ < 8; ) {\n        p = mod( p - 1.0f, 2.0f ) - 1.0f;\n        s *= e = FRACTALWIDTH / dot( p, p );\n        p *= e;\n    }\n    return length( p.yz ) / s;\n}\n\nvec3 rotation(vec3 pos, float theta, float omega) {\n    float cT = cos(theta);\n    float sT = sin(theta);\n    float cO = cos(omega);\n    float sO = sin(omega);\n    vec3 rotO = mat3(1.0, 0.0, 0.0,\n                    0.0, cO, sO,\n                    0.0, -sO, cO) * pos;\n    vec3 rotT = mat3(cT, 0.0, sT,\n                    0.0, 1.0, 0.0,\n                    -sT, 0.0, cT) * rotO;\n    return rotT;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 delta = vec2(SDFTHRESHOLD * .1f, 0.f);\n    return normalize(vec3(\n        (apollonianSDF(pos + delta.xyy) - apollonianSDF(pos - delta.xyy)),\n        (apollonianSDF(pos + delta.yxy) - apollonianSDF(pos - delta.yxy)),\n        (apollonianSDF(pos + delta.yyx) - apollonianSDF(pos - delta.yyx))\n        ));\n}\n\nvoid mainImage( out vec4 normalAndDist, in vec2 fragCoord )\n{\n    normalAndDist = vec4(0.f, 0.f, 0.f, -1.f);\n    vec2 cameraRot = (-2.f * (iMouse.xy - 0.5f * iResolution.xy)/iResolution.y) * MOUSESENSIBILITY;\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    vec3 camera = vec3(iTime * SPEED + 1.f, cos(iTime * UPANDDOWNMOVEMENTFREQ) * UPANDDOWNMOVEMENTAMP + 1., iTime * SPEED);\n    \n    vec3 pos = camera;\n    vec3 dir = rotation(DIR(uv), cameraRot.x - 0.71f, cameraRot.y);\n    \n    for (float i = 0.f; i++ < 200.f;) {\n        float d = apollonianSDF(pos);\n        if (d < SDFTHRESHOLD) {\n            normalAndDist.xyz = normal(pos);\n#ifdef DISTANCETOCAMERAPLANE\n            normalAndDist.w = pos.w;\n#else\n            normalAndDist.w = length(camera - pos);\n#endif\n#ifdef DISTANCELOG\n            normalAndDist.w = log(1.f + normalAndDist.w);\n#endif\n            break;\n        }\n        pos += d * dir;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DIR(uv) normalize(vec3(uv, FOCAL))\n\n//#define DISTANCETOCAMERAPLANE\n//#define DISTANCELOG\n\n\n//Home made enums, those are not parameters.\nconst int NOFOG = 0;\nconst int LINEARFOG = 1;\nconst int INVERTFOG = 2;\nconst int EXPFOG = 3;\nconst int DOUBLEEXPFOG = 4;\n//End of enums.\n\nconst vec2 MOUSESENSIBILITY = vec2(0.7f);\nconst float MOTIONBLUR = 0.2f; // Very sensitive, might cause motion sickness when approching 1.\n\nconst float FOCAL = 1.5f;\nconst float SPEED = 0.6f;\nconst float UPANDDOWNMOVEMENTAMP = 0.f; //Null by default because it might cause motion sickness.\nconst float UPANDDOWNMOVEMENTFREQ = 2.f;\n\nconst float SDFTHRESHOLD = 0.01f;\nconst float FRACTALWIDTH = 1.4f; // Very sensitive parameter.\n\nconst vec3 BACKGROUNDCOLOR = vec3(0.9, 0.9, 0.9);\nconst vec3 AMBIANTCOLOR = vec3(0.7f, 1.2f, 1.5f); // For spherical harmonics.\nconst vec3 LIGHTDIR = normalize(vec3(0.5f, 0.3f, 0.2f));\nconst vec3 LIGHTCOLOR = vec3(1.3f, 1.f, 1.0f);\n\nconst float SMOOTHNESS = 0.1f;\nconst float METALLIC = 0.6f;\nconst vec3 STRUCTCOLOR = vec3(0.5647f, 0.3216f,0.2706f);\nconst vec3 NONMETALLICSPECULAR = vec3(0.25f);\nconst float NONMETALLICREFLECT = 1.5f;\n\nconst int FOGMODE = LINEARFOG;\nconst vec3 FOGCOLOR = vec3(0.4314f, 0.5176f, 0.5843f);\nconst vec2 FOGLINEARSTARTANDEND = vec2(2.f, 13.f); // For linear mode.\nconst float FOGFACTOR = 0.5f; // For invert, exp and double exp modes.","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Spherical harmonics methods copied from https://www.shadertoy.com/view/lt2GRD\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients grace = SHCoefficients(\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = grace;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return max(vec3(0.f),\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    fragColor = vec4(BACKGROUNDCOLOR, 1.0);\n    vec4 normalAndDist = texture(iChannel0, fragCoord/iResolution.xy);\n    if (normalAndDist.w < 0.f) return;\n    \n    vec3 normal = normalAndDist.xyz;\n   for (int i = 0; i < 9; i++) {\n        vec2 offset = vec2(i%3 - 1, i/3 - 1)*0.333f;\n        normal += texture(iChannel0, (fragCoord + offset)/iResolution.xy).xyz;\n        if (i == 3) i++;\n    }\n    normal /= 9.0;\n    normal = normalize(normal);\n    \n\n#ifdef DISTANCELOG\n    float distLog = normalAndDist.w;\n    float dist = exp(distLog) - 1.f;\n#else\n    float dist = normalAndDist.w;\n    float distLog = log(1.f + dist);\n#endif\n    \n    float lighting = max(0.f, dot(-normalize(LIGHTDIR), normal));\n    \n    vec3 specularTint = mix(NONMETALLICSPECULAR, STRUCTCOLOR, METALLIC);\n    vec3 albedo = NONMETALLICREFLECT * STRUCTCOLOR * (1.f - METALLIC);\n    \n    // Not sure if this is the best way to add spherical harmonics, but it is looks satisfying.\n    vec3 diffuseLighting = albedo * mix(calcIrradiance(normal) * AMBIANTCOLOR, LIGHTCOLOR, lighting);\n    \n    vec3 halfVec = -normalize(DIR(uv) + LIGHTDIR);\n    vec3 specularLighting = specularTint * LIGHTCOLOR * pow(max(0.f, dot(halfVec, normal)), SMOOTHNESS * 100.f);\n    \n    vec3 color = diffuseLighting + specularLighting;\n    \n    float fogLerp;\n    switch (FOGMODE) {\n        case LINEARFOG:\n            fogLerp = clamp((FOGLINEARSTARTANDEND.y - dist)/(FOGLINEARSTARTANDEND.y - FOGLINEARSTARTANDEND.x), 0.f, 1.f);\n            break;\n        case INVERTFOG:\n            fogLerp = 1.f/(1.f + FOGFACTOR * dist);\n            break;\n        case EXPFOG:\n            fogLerp = exp2(-FOGFACTOR * dist);\n            break;\n        case DOUBLEEXPFOG:\n            fogLerp = exp2(-(FOGFACTOR * dist)*(FOGFACTOR * dist));\n            break;\n        default:\n            fogLerp = 1.f;\n    }\n    \n    color = mix(FOGCOLOR, color, fogLerp);\n    //color = pow(color, vec3(2.2f));\n        \n    fragColor = vec4(color, 1.0);\n    // Weird motion blur, I really like how it looks when MOTIONBLUR approach 1 (don't move the camera too much, though).\n    fragColor = mix(fragColor, texture(iChannel1, fragCoord/iResolution.xy), MOTIONBLUR);\n}","name":"Buffer B","description":"","type":"buffer"}]}