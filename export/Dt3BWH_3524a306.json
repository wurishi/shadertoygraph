{"ver":"0.1","info":{"id":"Dt3BWH","date":"1701176698","viewed":11,"name":"vug_tutorial_tryout_","username":"moerastrid","description":"Here I'm trying the tutorial @vug created in 2014 and now tracking off and making my own composition (but with the logic from the tutorial)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","tryout"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// constant values I need in multiple functions\nconst vec3 purple = vec3(163. / 255., 0.5, 237./255.);\nconst vec3 blue = vec3(163. / 255. / 2., 0.5, 237./255.);\nconst vec3 cyan = (vec3(163. / 255., 1., 237./255.) / 1.05);\nconst vec3 yellow = vec3(0.9, 0.9, 0.2);\nconst vec3 grey = vec3(0.8);\nconst float gridSize = 1.0 / 8.0;\nconst float PI = 3.14159265359;\n\n/* backGround function creates background. */\nvec3 backGround(vec2 r) {    \n    vec3 pixel;\n    float widthOfStrip = 0.35;\n    float startPosX = -1.3;    \n    float lineThickness = 0.02;    \n    float linePosY = 0.55;  \n    \n    if ((r.x > startPosX) && (r.x < startPosX + widthOfStrip)) {\n        pixel = blue;   \n    } else if (r.x < 0.67) {        \n        pixel = purple;        \n        if(abs(r.y - linePosY) < lineThickness)            \n            pixel = cyan;    \n    } else {        \n        pixel = cyan;    \n    }    \n    return (pixel);\n}\n\n// grid for debugging purposes\nvec3 Grid(vec2 r, vec3 pixel) {   \n    vec3 axesColor = yellow;    \n    vec3 gridColor = grey;       \n    float lineThickness = 0.002;    \n    \n    for (float i = -2.0; i < 2.; i += gridSize) {\n        if(abs(r.x - i) < lineThickness) pixel = gridColor;\n        if(abs(r.y - i) < lineThickness) pixel = gridColor;    \n    }    \n    \n    if( abs(r.x)<0.005 ) pixel = axesColor;    \n    if( abs(r.y)<0.006 ) pixel = axesColor;    \n    return (pixel);\n}\n\n/**/\nvec3 Circle(vec2 r, vec3 pixel, vec2 pos, float radius, vec3 color) {    \n    vec2 d = r - pos;    \n    \n    // Return if outside of cirle\n    if (length(d) > radius)        \n        return (pixel);\n       \n    // Set color    \n    pixel = vec3(color);        \n    \n// Do shading\n    // Strength of shade, stronger on the outside    \n    float strength = (length(d) / radius) * 0.8;\n    \n    // Calculate angle 0-360    \n    float angle = (180.0 * atan(d.y, d.x) / PI);    \n    \n    // Rotate angle 45 degrees (shadow in bottom right)    \n    angle = mod(angle + 45.0, 360.0);    \n    \n    // Normalize to 0 to 1    \n    float normalizedAngle = angle / 360.0;    \n    \n    // Change angle from 0-1 to 0-0.5-1-0.5-0    \n    normalizedAngle = abs(normalizedAngle - 0.5) * 2.0;    \n    \n    // Multiply normalized angle by strength and subtract from modifier    \n    normalizedAngle = 1.0 - (strength * normalizedAngle);    \n    \n    pixel *= normalizedAngle;\n    return (pixel);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){       \n    vec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );    \n    r = 2.0 * (r.xy / iResolution.y);    \n    vec3 pixel = backGround(r);        \n    //pixel = Grid(r, pixel);                                    // grid for debugging purposes\n    vec2 posA = vec2(-0.3, -0.3);    \n    vec2 posB = vec2(0.6, -0.2);      \n    posB += 0.4 * sin(iTime * length(posB));  \n    pixel = Circle(r, pixel, posA, 0.4, cyan);  \n    pixel = Circle(r, pixel, posB, 0.3, blue);    \n    \n    float alpha = 1.0;  \n    fragColor = vec4(pixel, alpha);\n}\n\n\n","name":"Image","description":"","type":"image"}]}