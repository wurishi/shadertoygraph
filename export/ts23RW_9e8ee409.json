{"ver":"0.1","info":{"id":"ts23RW","date":"1548398184","viewed":145,"name":"Warped Value Noise (fbm)","username":"Elyxian","description":"Based on the warping functions from IQ (https://www.shadertoy.com/view/lsl3RH) with inspiration from Dave Hoskins (https://www.shadertoy.com/view/MlSXDm)\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","warp","dirt","camo","camoflauge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p) {\n    float hashScale = 0.1031;\n\tvec3 p3  = fract(vec3(p.xyx) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst vec2 add = vec2(1.0,0.0);\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( hash12(p), hash12(p + add.xy),f.x),\n                    mix( hash12(p + add.yx), hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\n// Noise functions and warping methods inspired and modified from https://www.shadertoy.com/view/lsl3RH\n\nconst float angle = 0.2;\nconst float scale = 3.24;\nconst mat2 m = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * scale;\n\nfloat fbm4( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p ) {\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec3 warpedNoise(in vec2 q) {\n\n\tvec2 o = vec2(0.0);\n    o.x = 0.5*fbm6(vec2(2.0*q));\n    o.y = 0.5*fbm6(vec2(2.0*q));\n    \n    vec2 n = vec2(0.0);\n    n.x = fbm6(vec2(7.0*o+vec2(19.2)));\n    n.y = fbm6(vec2(7.0*o+vec2(15.7)));\n\n    vec2 p = 4.0*q + 4.0*n;\n    \n    float f = 0.5 + 0.5 * fbm4(p);\n    \n    // Rendering the value in different ways\n    float time = mod(iTime - 13.0, 4.0 * 4.0);\n    \n    // Option 1: Grayscale rendering\n    if (time < 4.0) {\n    \treturn 0.8 * vec3(f);\n    }\n    \n    // Option 2: Rendering with steps\n    if (time < 8.0) {\n    \tfloat steps = 10.0;\n    \treturn 0.8 * vec3(floor(f * steps) / steps);\n    }\n    \n    // Option 3: Dirt-like Colours\n    if (time < 12.0) {\n    \tfloat steps = 10.0;\n    \tfloat val = floor(f * steps) / steps;\n        val = min(max(val, 0.6), 0.8);\n    \treturn 0.45 + 0.35*sin(vec3(0.05,0.08,0.10)*(val*1583343.0));\n    }\n        \n    // Option 4: Camo-like Colours\n    else {\n    \tfloat steps = 10.0;\n    \tfloat val = floor(f * steps) / steps;\n        val = min(max(val, 0.6), 0.8);\n    \treturn 0.25 + 0.15*sin(vec3(0.05,0.08,0.10)*(val*1234.1));\n    }\n        \n    // Option 5: Time-based Colours (unused)\n    //float steps = 10.0;\n    //float val = floor(f * steps) / steps;\n    // Color function from iq: https://www.shadertoy.com/view/Xds3zN\n    //return 0.45 + 0.35*sin(vec3(0.05,0.08,0.10)*(val*iTime*10.0));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    p += vec2(0.0, iTime / 15.0);\n    \n    vec3 col = warpedNoise(p * 2.3);\n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}