{"ver":"0.1","info":{"id":"ddsfWr","date":"1688656129","viewed":76,"name":"Sierpiński Square Flake Inverse","username":"spalmer","description":"Inverse mapping of the space-filling curve I extracted from Marty's,\nalso forked from [url=http://shadertoy.com/view/cdScDc]this[/url]","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sierpinski","spacefillingcurve"],"hasliked":0,"parentid":"mtjSWc","parentname":"Inverse H-Curve"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" // show inverse of http://shadertoy.com/view/cdScDc\n /*\n I extracted from Marty McFly's H curve inverse at http://shadertoy.com/view/mtjSWc\n Got it working again as a stand-alone top-down\n Sierpinski Square Snowflake space-filling curve\n inverse mapping function.\n :D\n Enjoy!\n*/\n\n// inverse mapping function\n/*\n// extracted/modified from Marty McFly toy http://shadertoy.com/view/mtjSWc\n// basically took his H_curve_inverse and removed the H-specific parts of it.\n// since haven't really changed it much yet here, leaving the license since it's basically his code\n// and putting his name on it for attribution\n// but it still needs quite a bit of modification to become what I want it to be -spalmer\n// The MIT License\n// Copyright © 2023 Pascal Gilcher\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// \"a discrete variant of the Sierpinsky-Knopp Order / space filling curve.\"\nivec2 Sierp_inverse_McFly(int i, int level)\n{\n    ivec2 p; // = ivec2(0);\n    int N = (1<<level)*(1<<level);\n    while ((N >>= 2) > 0) { // I had to modify this quite a lot\n        int q = (i / N) & 3;  \n        p = 2 * p + ivec2(q>>1, (q ^ (q>>1)) & 1); // needs diagonally flipped\n        i += ((q * 2 + 5) & 7) * N >> 3; // had to remove the parenthesis around (N >> 3)\n    } // removed H table lookup etc.\n    return p; // basically Sierpinsky order\n}\n*/\n/*\n// extracted/modified from Marty McFly toy http://shadertoy.com/view/mtjSWc\nivec2 Sierp_inverse_orig(int i, int l)\n{\n    int n = 1 << 2*l;\n    ivec2 p = ivec2(0);\n    while ((n >>= 2) > 0) {\n        int q = (i / n) & 3;\n        p += p + ivec2((q ^ (q>>1)) & 1, q>>1);\n        i += (q ^ 2) * (n >> 2) + (n >> 3);\n    }\n    return p;\n}\n*/\n// extracted/modified from Marty McFly toy http://shadertoy.com/view/mtjSWc\nivec2 Sierp_inverse(int i, int l)\n{\n    int q, n = 1 << 2*l;\n    ivec2 p = ivec2(0);\n    while ((n /= 4) > 0) {\n        q = (i / n) & 3;\n        p += p + (ivec2(q, 0) &1 ^ q/2);\n        i += (q * 2 + 5 & 7) * n >> 3;\n    }\n    return p;\n}\n //p += p + ivec2((q ^ (q>>1)) & 1, q>>1); //p = 2*p + \n\n// :(\n#define F float\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o.xyz = iResolution;\n    // beware this gets really slow if increasing l\n    int l = int(3. * sqrt(cos(.3 * iTime) * .5 + .5)) + 1,\n        n = 1 << l, m = n-1, N = n * n, k, j;\n    u = F(n) * ((u - .5 * o.xy) / (o.y = min(o.x, o.y)) * 1.05 + .5) - .5;\n    F t, d = 9.;    \n    // extra super slow drawing of every segment!\n    ivec2 q, p = Sierp_inverse(0, l);\n    for (int k = N; k-- > 0; ) {\n        q = Sierp_inverse(k, l);\n        vec2 a = vec2(p), b = vec2(q) - a, s = u - a,\n          w = s - b * clamp(dot(s, b) / dot(b, b), 0., 1.); // vector to segment\n        t = dot(w, w);\n        if (t < d) d = t, j = k;\n        p = q;\n    }    \n    t = fract(F(j) / F(N) - .05 * iTime);\n    o = sqrt(mix(vec4(.5),\n        (1. - pow(t, exp2(F(l + 3)))) // dark red crease on violet side\n         * min(abs(fract(t + vec4(3,2,1,0) / 3.) * 6. - 3.) - 1., 1.), // hue\n        clamp(.5-.5*(sqrt(d) - .2) / F(n)*o.y, 0., 1.) // antialiasing\n         * F(p == (p&m)) // mask off repeat tilings\n        ));\n}\n\n\n/*\n pattern:\n \n 0 \n\n 0  1 \n 3  2 \n\n 2  3  5  6 \n 1  0  4  7 \n f  c  8  9 \n e  d  b  a \n\n 8  9  b  c 14 15 17 18 \n 7  6  a  d 13 12 16 19 \n 5  2  e  f 11 1e 1a 1b \n 4  3  1  0 10 1f 1d 1c \n3c 3d 3f 30 20 21 23 24 \n3b 3a 3e 31 2f 2e 22 25 \n39 36 32 33 2d 2a 26 27 \n38 37 35 34 2c 2b 29 28 \n*/\n\n/*\n// forward mapping function\n// based on http://shadertoy.com/view/mlS3Rm and http://shadertoy.com/view/cdScDc\n// I shifted it around, matches the inverse\nint Sierp(ivec2 p, int l)\n{\n    int i, s, n=1; \n    for (ivec2 z; s <= l; s++, n*=4)    \n       z = p<<s&n,\n       z = z.x^z.y + z+z,\n       i = (z.y/4 + i + 3*n/8&n-1) \n           + z.x;\n\treturn n/32\n\t\t- (i ^ n/8) - 1\n\t\t&n/4-1;\n}\n*/ ","name":"Image","description":"","type":"image"}]}