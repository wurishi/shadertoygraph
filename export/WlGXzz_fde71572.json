{"ver":"0.1","info":{"id":"WlGXzz","date":"1586112769","viewed":573,"name":"BotMaricarmen","username":"glk7","description":"A procedural 3D model of BotMaricarmen ([url]https://twitter.com/botMaricarmen[/url]). Original design by LabRat ([url]https://twitter.com/Lab___Rat[/url]). \n\nSelf reflections can be enabled/disabled setting the SELF_REFLECTION macro.","likes":16,"published":3,"flags":0,"usePreview":1,"tags":["sdf","modeling","vndf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by genis sole - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n// Visuals are based on a desing by LabRat (https://twitter.com/Lab___Rat) \n\n\n#define ZERO min(0, iFrame)\n\n#define AA 0\n#define SELF_REFLECTION 1\n\nconst int REFLECTION_SAMPLES = 10;\n\nconst float PI = 3.1415926536;\n\n\n//from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 cylIntersect( vec3 ro, vec3 rd, float r )\n{\n    float a = 1.0 - rd.y*rd.y;\n    float b = dot(ro, rd) - ro.y*rd.y;\n    float c = dot(ro, ro) - ro.y*ro.y - r*r;\n    float h = b*b - a*c;\n    \n    if( h < 0.0 ) return vec2(-1.0);\n    \n    h = sqrt(h);\n    \n    return vec2(-b-h,-b+h)/a;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n//https://iquilezles.org/articles/distfunctions2d\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdHeadRivetes(vec3 p, float d)\n{\n    p.x -= 0.2;\n    vec2 xp = vec2(length(p.yz), atan(p.z, p.y));\n    float tp = mod(xp.y + 0.05, 2.0*PI/15.) - PI/15.;\n    \n    vec3 tpp = vec3(p.x, sin(tp)*xp.x, cos(tp)*xp.x);\n\n   \treturn smax(length(tpp.yx) - 0.07, (d - 0.04), 0.03);\n}\n\nfloat sdArmsOverlay(vec3 p, float d)\n{\n    p.x = abs(p.x);\n    float o = sdEllipsoid(p - vec3(0.5, 1.1, 0.0), vec3(0.3, 1.0, 0.5));\n    \n    return smax((abs(d) - 0.02), o, 0.05);\n}\n\nfloat sdBodyOverlay(vec3 p, float d)\n{\n    float o = sdEllipsoid(p - vec3(2.0, -4.9, -0.5), vec3(1., 1.8, 1.5));\n   \t//float o = sdEllipsoid(p - vec3(1.9, -4.9, -0.5), vec3(1., 1.8, 1.9));\n    return smax((abs(d) - 0.02), o, 0.05);\n}\n\nfloat sdArmsRivetes(vec3 p, float d)\n{\n    float c = abs(p.y-1.1) - 1.0;\n    p.y = mod(p.y - 0.2, 0.6) - 0.5*0.6;\n    float rivetes = length(p.yz) - 0.085;\n    rivetes = smax((d - 0.05), rivetes, 0.05);\n    rivetes = max(c, rivetes);\n\n    return rivetes;\n}\n\nfloat sdBodyRivetes(vec3 p, float d)\n{ \n    float c = p.y-1.5;\n    \n    p.z = -abs(p.z + 0.4);\n    p.xz = (mat2(4, -3, 3, 4) / 5.0) * p.xz;\n \tp.z += 0.15;\n    \n    p.y = mod(p.y + 0.3, 0.7) - 0.5*0.5;\n    float r = length(p.yz) - 0.085;\n    r = smax(d - 0.05, r, 0.05); \n    \n    return max(c, r);\n}\n\nfloat sdHeadBase(vec3 p)\n{\n    float skull = sdEllipsoid(p - vec3(0.0, -1.1, 0.0), vec3(2.15, 1.5, 1.8));\n    skull = smin(sdEllipsoid(p - vec3(0.0, -0.35, 0.0), vec3(2.07, 2.07, 1.8)), skull,  0.5);\n    skull = smax(-p.y-1.8, skull, 1.0) - 0.505;\n    \n    return skull;\n}\n\nvec3 transformHeadSeam(vec3 p)\n{\n    p = p - vec3(0.8, -0.8, 0.0);\n    p.xz = (mat2(15,-8,8, 15) / 17.0) * p.xz;\n    p.x = abs(p.x);\n    return p;\n}\n\nfloat sdHeadSeam(vec3 p, float d)\n{\n    return max(p.x - 0.025, abs(d) - 0.1);\n}\n\nfloat sdMouthGap(vec3 p, float d)\n{\n    vec2 mp = p.xy - vec2(0.38, -0.64);\n    float mouth = abs(abs(mp.x - 0.45)) - 0.015;\n    mouth = max(mp.y + 0.05, mouth);\n    mouth = smax(abs(d) - 0.2, mouth, 0.15);\n\n    float tmouth = max(abs(p.z + 4.5) - 4.9, abs(length(mp.xy) - 0.45) - 0.03);\n    tmouth = smax(mp.y - 0.05, tmouth, 0.02);\n    tmouth = smax(min(-(p.x + 0.45), p.y + 0.4), tmouth, 0.05);\n    \n    tmouth = smax(abs(d) - 0.4, tmouth, 0.05);\n    return min(tmouth, mouth);\n}\n\nfloat sdHead(vec3 p, float d)\n{\n    vec3 bs = p - vec3(0.0, -1., 2.5);\n    bs.yz = (mat2(15,-8,8, 15) / 17.0) * bs.yz;\n    \n    d = smax(bs.z + 0.2, d, 0.7); \n\n    return d;\n}\n\nfloat sdEars(vec3 p)\n{\n    vec3 eap = p - vec3(0.9, 2.15, 0.0);\n    eap.xy = (mat2(3, 4, -4, 3) / 5.0) * eap.xy;\n    float ears = sdEllipsoid(eap, vec3(1.98, 1.4, 0.8)*1.17);\n    ears = smax(-length(eap.xy + vec2(12.38, 0.12)) + 12.5, ears, 0.6);\n    \n    float f = sdEllipsoid(eap - vec3(-4.5, 0., 0.15), vec3(5.0, 5.0, 0.3));\n    f = smax(ears, f, 0.2) - 0.03;\n    \n    \n    ears = smax(-eap.z, abs(ears - 0.05) - 0.08, 0.35);\n\tears = smin(f, ears, 0.02);\n    \n    return ears;\n    /*\n    vec3 pe = eap - vec3(1.3, -0.6, 0.3); \n    pe.xy = (mat2(187, -84, 84, 187)/ 205.0) * pe.xy;\n    \n    float pr1 = sdTriPrism(pe, vec2(1.5, 0.01));\n  \tpr1 = smax(pe.x, pr1, 0.05);\n    \n    float pr2 = sdTriPrism(pe - vec3(0.15, 0.0, 0.0), vec2(1.2, 0.01));\n    pr2 = smax(pe.x - 0.15, pr2, 0.05);\n    \n    return smin(ears, smin(pr1, pr2, 0.01) - 0.04, 0.01);*/\n}\n\nfloat sdCollar(vec3 p)\n{\n    vec3 cp = p - vec3(0.0, -1.4, -0.1);\n    float collar = smax(abs(cp.y) - 0.01, length(cp.xz) - 1.3, 0.1) - 0.15;\n    return collar;\n}\n\nfloat sdMedallion(vec3 p)\n{\n  \tvec3 mp = p - vec3(0.0, -2.0, -1.45);\n    mp.z = abs(mp.z);\n    float medallion = length(mp.xy) - 0.6;\n    medallion = max(medallion, (length(mp - vec3(0.0,0.0,-1.25)) - 1.5));//, 0.03);\n    \n    \n    float g = (length(mp.xy) - 0.23);\n    g = min(max(mp.y, abs(mp.x) - 0.03), g);\n    g = max((abs(medallion) - 0.1), g) - 0.01;\n    medallion = smax(-g, medallion, 0.05);\n    \n    return medallion;\n}\n\nvec3 transformTail(vec3 p)\n{\n    p -= vec3(0.0, -3.7, 1.65);\n    p.yz = (mat2(4, 3, -3, 4) / 5.0) * p.yz;\n    return p;\n}\n\nfloat sdTailRod(vec3 p)\n{\n\treturn max(abs(p.z + 0.1) - 0.3, length(p.xy) - 0.06);\n}\n\nfloat sdTailSphere(vec3 p)\n{\n    return length(p - vec3(0.0, 0.0, 0.1)) - 0.3;\n}\n\nfloat sdFeet(vec3 p, float d)\n{\n    float s = abs(max(p.z, d)) - 0.1;\n    s = max(abs(abs(p.x -0.7) - 0.2) - 0.0325, s);\n    s = smax(p.y + 6., s, 0.05);\n  \n    return smax(-s, d, 0.02);\n}\n\nvec3 transformArms(vec3 p)\n{\n    vec3 ap = p - vec3(2.4, -4.2, -0.3);\n    ap.xy = (mat2(187, -84, 84, 187)/ 205.0) * ap.xy;\n    ap.xz = (mat2(4, 3, -3, 4) / 5.0) * ap.xz;\n    \n    const float k = -0.07;\n    float c = cos(k*(p.y));\n    float s = sin(k*(p.y));\n    \n    mat2  m = mat2(c,s,-s,c);\n \tap = vec3(m*ap.yx,ap.z).yxz;\n    \n    return ap;\n}\n    \nfloat sdArms(vec3 p)\n{\n   \treturn sdRoundCone(p, 0.6, 0.3, 3.3);\n}\n\nfloat sdBodyBase(vec3 p)\n{\n\tvec3 ubp = p - vec3(0.0, -4., -0.2);\n\n    vec2 q = vec2(length(ubp.xz), ubp.y);  \n    \n    return sdRhombus(q, vec2(1.17, 6.0)) - 0.5;\n}\n\nfloat sdBody(vec3 p, float d)\n{\n    vec3 ubp = p - vec3(0.0, -4.2, -0.2);\n\n    float body = d;\n    float ls =  (length(ubp.xy - vec2(+6.2, -1.7)) - 5.975);\n    ls = smin(-(ubp.y + 0.2), ls, 0.2);\n   \n    body = smax(ls, body, 0.2);\n\n    body = smax(length(ubp.zy - vec2(5.8, 1.5)) - 7.0, body, 0.5);\n    body = smax(-(length(ubp.zy - vec2(4.0, -2.5)) - 3.5), body, 0.5);\n    body = smax((length(ubp.xy - vec2(-5.1, 0.3)) - 7.0), body, 0.5);\n    //body = smax((length(ubp - vec3(-5.0, 0.3, 0.0)) - 7.0), body, 0.5);\n\n    body = smax(-(ubp.y + 2.2), body, 0.1);\n    \n    return body;\n}\n\n/*\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//from https://iquilezles.org/articles/palettes\nvec3 colorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n*/\n\nvec3 background(vec3 p, float lod)\n{   \n    \n    return textureLod(iChannel0, normalize(p), lod).rgb;\n    /*\n    vec2 uv = vec2((atan(p.z, p.x) + PI) * (21.0/(2.0*PI)), (21.0 * p.y) / (2.0*PI*20.0));\n   \tvec2 id = vec2(floor(uv.x/1.5), 0.0);\n    \n    float ry = (hash23(vec3(id.x, 388.0, 342.0)).x - 0.5) * 2.0;\n    \n    uv.y += iTime*ry;\n    id.y = floor(uv.y/1.5);\n\n    vec2 t = hash23(vec3(id, 321.0));\n    \n    uv = vec2(mod(uv.x, 1.5) - 0.75, mod(uv.y, 1.5) - 0.75);\n     \n   \tfloat d0 = max(sdBox(uv, vec2(0.2, 0.4)) - 0.2, -(sdBox(uv, vec2(0.1, 0.3)) - 0.14));\n    float d1 = sdBox(uv - vec2(0.0, 0.0), vec2(0.1, 0.6));\n    \n    float d = mix(d0, d1, step(t.x, 0.5));\n    \n    vec3 c = colorPalette(t.x, vec3(1.0), vec3(0.7), vec3(1.0), vec3(0.0, 0.333, 0.666));\n    c *= smoothstep(0.1, 0.0, d);\n    return (c*c)*0.8 + 0.1;*/\n\n    \n}\n\nvec4 material(vec3 p, float lod)\n{\n    if (dot(p.xz, p.xz) > 19.0*19.0) return vec4(background(p, lod), -1.0);\n    \n    p.x = abs(p.x);\n    \n    if (p.y+6.4 < 0.002) return vec4(0.56, 0.57, 0.58, 0.1)*0.5;\n    \n    if (p.y < -1.2) {\n        if (p.z > 1.2) {\n            if (sdTailSphere(transformTail(p)) < 0.002) {\n                return vec4(0.93, 0.2, 0.3, 0.6);\n            }\n        }\n       \t\n        if (p.y > -2.6) {\n            float collar = sdCollar(p);\n    \t\tfloat medallion = smax(-collar, sdMedallion(p), 0.05);\n        \tif (medallion < 0.002) return vec4(1.00, 0.71, 0.29, 0.05);\n        \n    \t\tif (collar < 0.002) return vec4(0.95, 0.2, 0.2, 0.7);\n        }\n        \n        vec3 ap = transformArms(p);\n    \tfloat arms = sdArms(ap);\n    \tif (arms < 0.1) {\n            float aoverlay = sdArmsOverlay(ap, arms);\n            float arivetes = sdArmsRivetes(ap, aoverlay);;\n\n            if (aoverlay < 0.002) return vec4(0.56, 0.57, 0.58, 0.1);\n            if (arivetes < 0.002) return vec4(0.56, 0.57, 0.58, 0.3) *0.6;\n    \t}\n        \n        vec3 lp = p - vec3(0.925, -5.1, 0.0);\n        lp.xy = (mat2(-144, 17, 17, 144) / 145.0) * lp.xy;\n\n        float body = sdBody(p, sdBodyBase(p));\n        if (body < 0.1) {\n            \n            float feet = smax(lp.y + 0.3, body, 0.05);\n\t\t\tif (feet < 0.002) return vec4(0.56, 0.57, 0.58, 0.5);\n            \n            body = max(-(lp.y + 0.3), body);\n\t\t\tfloat boverlay = sdBodyOverlay(p, body);\n            float brivetes = sdBodyRivetes(lp, boverlay);\n            \n\t\t\tif (boverlay < 0.002) return vec4(0.56, 0.57, 0.58, 0.1);\n            if (brivetes < 0.002) return vec4(0.56, 0.57, 0.58, 0.3) *0.6;\n        }\n    }\n \n    if (p.y > -1.5 && p.z < 0.0) {\n        vec3 hp = p - vec3(0.0, 1.0, 0.0);\n    \tfloat head = sdHeadBase(hp);\n        vec3 hrp = transformHeadSeam(hp);\n        \n        if (hrp.x - 0.3 < 0.0) {\n            //return vec4(1.0);\n            if (sdHeadRivetes(hrp, head) < 0.002) {\n                return vec4(0.56, 0.57, 0.58, 0.3*0.6);\n            }\n        }\n    }\n    \n    return vec4(0.91, 0.92, 0.92, 0.35);\n}\n\nfloat map(vec3 p)\n{\n    p.x = abs(p.x);\n    \n    float head = -(p.y + 1.3);\n    if (head < 0.1) {\n    \tvec3 hp = p - vec3(0.0, 1.0, 0.0);\n    \thead = sdHeadBase(hp);\n    \n        if (head < 0.1 ) {\n            head = sdHead(hp, head);\n            if (p.z < 0.0) {\n                vec3 st = transformHeadSeam(hp);\n                float front = max(p.z + 0.15, head);\n            \tif (st.x < 0.3) {\n            \t\tfloat hs = sdHeadSeam(st, front);\n            \t\tfloat hr = sdHeadRivetes(st, front);\n                \thead = smax(head, -hs, 0.02);\n                    head = min(head, hr);\n                }\n                if (p.x < 1.0 && p.y < 0.5) {\n                    float hm = sdMouthGap(hp, front);\n                    head = smax(head, -hm, 0.02);\n                }\n            }\n        }\n        \n        float ears = min(length(p - vec3(1.9, 2.6, 0.6)) - 1.55, (head - 0.1));\n\n        if (ears < 0.1) {\n           //head = min(head, sdEars(hp));\n           ears = sdEars(p - vec3(0.0, 1.0, 0.0));\n           //if (ears < 0.1) ;\n        }\n        head = min(head, ears);\n    }\n\n    \n    float bodys = -min( -(p.y + 1.2), p.y + 6.4) ;\n    if (bodys < 0.1) {\n      \tfloat bbody = sdBodyBase(p);\n        float body = bbody;\n        \n        if (bbody < 0.1) {\n            body = sdBody(p, bbody);\n            if (body < 0.1) {\n                vec3 lp = p - vec3(0.925, -5.1, 0.0);\n                lp.xy = (mat2(-144, 17, 17, 144) / 145.0) * lp.xy;\n\n                float feet = 1000.0;\n                if (lp.y < 0.3) {\n                \tfeet = smax((lp.y + 0.3), body, 0.06);\n                \tfeet = max(sdFeet(p, feet), feet);\n                }\n                \n                body = smax(-(lp.y + 0.3), body, 0.06);\n\n                float boverlay = sdBodyOverlay(p, body);\n                \n                if (boverlay < 0.1) {\n                \tbody = smax(-(boverlay - 0.03), body, 0.03);\n                    body = min(boverlay, body);\n                    body = min(sdBodyRivetes(lp, body), body);\n                }\n                \n                body = min(feet, body);\n            }\n        }\n        \n        float collar = max(-p.y - 2.5, bbody - 0.3);\n        if(collar < 0.1) {\n       \t\tcollar = sdCollar(p);\n        \tfloat medallion = sdMedallion(p);\n            collar = min(body, min(collar, smax(-collar, medallion, 0.05)));\n        }\n        \n        float tail = max(-(p.z - 1.3), body - 0.6);\n        if (tail < 0.1) {\n            vec3 tp = transformTail(p);\n            tail = smin(body, sdTailRod(tp), 0.1);\n            tail = min(tail, sdTailSphere(tp));\n        }\n        \n        float arms = max(abs(p.z + 0.3) - 0.7, max(-(body + 0.1), bbody - 1.3));\n        if (arms < 0.2) {\n            vec3 ap = transformArms(p);\n            arms = sdArms(ap);\n            if (arms < 0.2) {\n            \tfloat aoverlay = sdArmsOverlay(ap, arms);\n                arms = smax(-(aoverlay - 0.02), arms, 0.02);\n                arms = min(aoverlay, arms);\n               \tarms = min(arms, sdArmsRivetes(ap, arms)); \n            }\n        }\n        \n        bodys = min(tail, min(arms, min(body, collar)));\n\t}\n    \n    \n    float base = p.y + 6.4;\n    if (base < 0.1) {\n     \tbase = smax(base, length(p.xz) - 3.4, 0.1);\n    }\n    \n    return min(head, min(base, bodys));\n\n}\n\nvec4 eyes(vec2 uv)\n{       \n    float l = length(uv);\n    vec2 uvw = fwidth(uv);\n    float duv = max(uvw.x, uvw.y);\n    \n    \n    if (l > 1.0 + duv + 0.02) return vec4(0.0);\n    \n\tvec4 oc = vec4(vec3(0.0), smoothstep(0.01,duv+0.02, -l + 1.0));\n    vec4 ic = vec4(vec3(1.0), smoothstep(0.01, duv+0.1, -l + 0.56));\n    \n    uv -= 0.5;\n    \n    float v = uv.y*10.0;\n    const float k = 2.;\n    float x = mod(iTime*35.0 + v, 45.)*0.01 + 1.5;\n    float h = (2.0*sqrt(k)*x/(1.0+k*x*x)) * (((abs(sin(uv.y*40.0 + iTime*1.0))) * 0.25)) ;\n    \n\treturn vec4(mix(oc.rgb, ic.rgb, ic.a), min(1.0, oc.a*(h + 0.8)));\n}\n\nvec3 normal(vec3 p)\n{\n    const float e = 0.001;\n    const vec2 s = vec2(1.0, -1.0);\n\n    return normalize( \n        s.xyy * map(p + s.xyy*e) + \n        s.yyx * map(p + s.yyx*e) + \n        s.yxy * map(p + s.yxy*e) + \n        s.xxx * map(p + s.xxx*e));\n}\n\nfloat ambient_occlusion(vec3 ro, vec3 n)\n{   \n    float occ = 0.0;\n    float ff = 1.0;\n    \n    for( int i = 0; i < 5; ++i ){\n        float d = 0.1 + 0.03*float(i);\n        \n        float sd = map(ro + n*d);\n        \n        occ += (sd - d)*-ff;\n        ff *= 0.4;\n    }\n    \n    return clamp(1.0 - 2.0*occ, 0.0, 1.0);    \n}\n\nfloat shadow_traversal(vec3 ro, vec3 rd)\n{   \n    float ci = cylIntersect(ro, rd, 3.5).y;\n    \n    float d = 0.0;\n    float s = 1.0;\n    \n    for( int i = ZERO; i < 1 << 7; ++i ){\n        float sd = map(ro + rd*d);\n        \n        if (sd < 0.0001) return 0.0;\n        \n        d += sd;\n        s = min(s, sd*64.0/d);\n        \n        if (d > ci || d > 10.) break;\n    }\n    \n    return s;\n}\n\nfloat traversal(vec3 ro, vec3 rd)\n{\n    vec2 ci = cylIntersect(ro, rd, 3.5);\n    \n   \tfloat sd = max(0.0, ci.x);\n    \n    float d = 1000.0;\n    for( int i = ZERO; i < 1 << 8; ++i ){\n        if (d < 0.001 || sd > ci.y) break;\n        \n        d = map(ro + rd*sd);\n        sd += d;\n    }\n    \n    if (d < 0.001) return sd;\n    \n    return cylIntersect(ro, rd, 20.).y;\n}\n\n//from http://jcgt.org/published/0007/04/01/paper.pdf\nvec3 ggx_vndf_normal(vec3 v, float alpha, vec2 xi)\n{\n\tv = normalize(vec3(alpha*v.xz, v.y).xzy);\n\n    vec3 t1 = v.y < 0.9999 ? normalize(cross(v, vec3(0.0, 1.0, 0.0))) : vec3(0.0, 0.0, 1.0);\n    vec3 t2 = cross(t1, v);\n    \n\tfloat a = 1.0 / (1.0 + v.y);\n\tfloat r = sqrt(xi.x);\n    float phi = (xi.y < a) ? (xi.y/a) * PI : PI + ((xi.y-a)/(1.0-a)) * PI; \n    \n\tfloat p1 = r*cos(phi);\n\tfloat p2 = r*sin(phi) * ((xi.y < a) ? 1.0 : v.y);\n\n\tvec3 n = p1*t1 + p2*t2 + sqrt(max(0.0, 1.0 - p1*p1 - p2*p2))*v;\n\t\n    return normalize(vec3(alpha * n.xz, max(0.0, n.y)).xzy);\n}\n\nfloat ggx_sample_lod(float ndoth, float alpha2, float inv_sa_alpha2)\n{\n\tfloat dd = ((ndoth * ndoth) * (alpha2 - 1.0) + 1.0);\n\n  \treturn 0.5 * log2(dd*dd*inv_sa_alpha2 + 0.0001);  \n}\n\nvec3 ggx_sample(vec3 ro, vec3 rd, vec3 n, vec4 mat)\n{\n    float a2 = mat.a*mat.a;\n    \n    mat3 b;\n    b[0] = (abs(n.y) < 0.9999) ? normalize(cross(n, vec3(0.0, 1.0, 0.0))) : vec3(0.0, 0.0, 1.0);\n    b[1] = n;\n    b[2] = cross(n, b[0]);\n\n    vec3 v = rd*b;\n    vec3 c = vec3(0.0);\n    \n    ro += n*0.01;\n    \n    float inv_sa_alpha2 = (1024.0*1024.0*6.0) / (float(REFLECTION_SAMPLES) * a2);\n    for (int i = ZERO; i < REFLECTION_SAMPLES; ++i){\n        \n        vec2 xi = hash23(ro*500.0 + float(i));\n        vec3 m = ggx_vndf_normal(-v, mat.a, xi.xy);\n \n        vec3 r = reflect(v, m);\n        \n        float rdotm = max(0.0, dot(r, m)); \n        \n        float g = 2.0 / (sqrt(1.0 + (a2*dot(r.xz, r.xz) / (r.y*r.y))) + 1.0); \n        \n        vec3 sd = b*r;\n        vec4 smat = vec4(0.0);\n        float lod = ggx_sample_lod(m.y, a2, inv_sa_alpha2);\n\n#if SELF_REFLECTION   \n        float d = abs(traversal(ro + sd*0.01, sd));\n       \n        vec3 p = ro + sd*(d+0.01);\n        \n        smat = material(p, lod);\n        \n        if (smat.a > 0.0) {\n            smat.rgb *= 0.3*ambient_occlusion(p, normal(p));// - xi.x*0.05; \n        }\n#else  \n        float bi = cylIntersect(ro, sd, 20.0).y;\n        smat.rgb = background(ro + bi*sd, lod);\n#endif\n        c += vec3(smat.rgb*g*rdotm);\n    }\n\n    vec3 scol = (c.rgb/float(REFLECTION_SAMPLES));    \n/*    \n#if !SELF_REFLECTION\n    vec3 refd = normalize(reflect(rd, n));\n    float d = abs(traversal(ro + refd*0.01, refd));\n    vec3 p = ro + refd*(d+0.01);\n    \n    vec4 rmat = material(p, 0.0);\n                                                              \n    if (rmat.a > 0.0) {\n        vec3 rcol = rmat.rgb*0.2*ambient_occlusion(p, normal(p));\n        \n        scol = mix(scol, rcol*mat.rgb, pow(1.0 - mat.a, 8.0));\n    }  \t\n#endif\n*/   \n   return scol;                        \n}    \n    \nvec3 shade(vec3 p, vec3 rd, float d)\n{\n    const vec3 l = normalize(vec3(0.0, 2.0, -2.0));\n    \n    vec4 mat = material(p, 0.0);\n    if (mat.a < 0.0) return mat.rgb + pow(max(0.0, dot(l, rd)), 20.0);\n    \n    vec3 n = normal(p);\n    \n    vec3 h = normalize(l - rd);\n    \n    float ndotv = max(0.0, dot(n, -rd));\n    float ndotl = max(0.0, dot(n, l));\n    float ndoth = max(0.0, dot(n, h));\n    \n    float a = mat.a;\n    float a2 = a*a;\n    float dd = (ndoth*ndoth * (a2 - 1.0) + 1.0);\n    float ggx_d = a2 / (PI * dd * dd);\n    \n    float r = a + 1.0;\n    float k = (r*r) / 8.0;\n\t\n    float ggx1 = ndotv / (ndotv * (1.0 - k) + k);\n    float ggx2 = ndotl / (ndotl * (1.0 - k) + k);\n \n    vec3 fr = mat.rgb;\n   \t//vec3 fr = f0 + (max(vec3(1.0 - a), f0) - f0) * pow(1.0 - ndoth, 5.0);\n    //fr = f0;\n    \n    vec3 spec = (ggx_d * ggx1 * ggx2 * fr) / \n        max(0.001, (4.0 * ndotv * ndotl));\n    \n    float s = shadow_traversal(p + l*0.05, l);\n    float ao = ambient_occlusion(p, n);\n    \n    vec3 refc = ggx_sample(p, rd, n, mat); \n    \n    return 0.6*spec*s*ndotl + ao*fr*0.25 + refc*mat.rgb;\n}\n\nmat3 camera(vec3 p, vec3 t)\n{\n\tvec3 uu = normalize(p - t);\n    vec3 vv = normalize(vec3(uu.z, 0.0001, -uu.x));\n    return mat3(vv, cross(uu, vv), uu);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 t = vec3(0.0);\n    vec3 ro = vec3(0.0);\n   \n    \n    if (dot(m, m) < 0.001) {\n        float k = iTime*0.8;\n        \n     \tm.xy = vec2(sin(k*0.5)*0.02 + 0.5, cos(k*0.4)*0.05 +  0.35);    \n    }\n    \n    m.x = (m.x - 0.5)*(3.0*PI) + PI;\n    \n    ro = vec3(sin(m.x), sin(m.y)*0.75 - 0.2, cos(m.x))*25.0;\n    mat3 cam = camera(ro, t);\n    \n    vec3 rd0 = cam * normalize(vec3(uv, -0.8));\n    \n    float d0 = traversal(ro, rd0);\n    vec3 c = shade(ro + rd0*abs(d0), rd0, abs(d0));\n\n#if AA > 0\n    for (int i = ZERO; i < 1 << (AA << 1); ++i)\n    {\n        vec2 so = (vec2(i & ((1 << AA) - 1), i >> AA) + 0.5) / float(1 << AA) - 0.5;\n        vec3 rd = cam * normalize(vec3(uv + so * e, -0.8));\n\n        float d = traversal(ro, rd);\n        c += shade(ro + rd*d, rd, d);\n    }\n\n    c /= float((1 << (AA << 1)) + 1);\n#endif\n   \n    float ed = -(ro.z + 2.23)/rd0.z;\n    vec2 ep = (ro + rd0*ed).xy;\n    ep.x = abs(ep.x);\n    ep = (ep * 1.38) - vec2(1.9, 1.75);\n    vec4 ec = eyes(ep);\n    c.rgb = mix(c.rgb, ec.rgb, step(ed, d0) * ec.a); \n        \n    vec2 v = uv*0.5;\n    c.rgb = clamp(c.rgb * (1.0 - dot(v, v)*10.0) , 0.0, 1.0);\n    c.rgb += hash23(vec3(uv * 500.0, 221.0)).x * 0.005;\n    \n    fragColor = vec4(pow(c.rgb, vec3(0.4545)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"const float PI = 3.1415926536;\n\n\n//from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//from https://iquilezles.org/articles/palettes\nvec3 color_palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 background(vec3 p)\n{   \n    vec2 uv = vec2((atan(p.z, p.x) + PI) * (21.0/(2.0*PI)), (21.0 * p.y) / (2.0*PI*20.0));\n   \tvec2 id = vec2(floor(uv.x/1.5), 0.0);\n    \n    float ry = (hash23(vec3(id.x, 388.0, 342.0)).x - 0.5) * 2.0;\n    \n    uv.y += iTime*ry;\n    id.y = floor(uv.y/1.5);\n\n    vec2 t = hash23(vec3(id, 321.0));\n    \n    uv = vec2(mod(uv.x, 1.5) - 0.75, mod(uv.y, 1.5) - 0.75);\n     \n   \tfloat d0 = max(sdBox(uv, vec2(0.2, 0.4)) - 0.2, -(sdBox(uv, vec2(0.1, 0.3)) - 0.14));\n    float d1 = sdBox(uv - vec2(0.0, 0.0), vec2(0.1, 0.6));\n    \n    float d = mix(d0, d1, step(t.x, 0.5));\n    \n    vec3 c = color_palette(t.x,\n                        vec3(1.0), vec3(0.7), vec3(1.0), vec3(0.0, 0.333, 0.666));\n    c *= smoothstep(0.1, 0.00, d);\n    return c*c*0.8 + 0.1;\n}\n\nvec2 cylIntersect( vec3 ro, vec3 rd, float r )\n{\n    float a = 1.0 - rd.y*rd.y;\n    float b = dot(ro, rd) - ro.y*rd.y;\n    float c = dot(ro, ro) - ro.y*ro.y - r*r;\n    float h = b*b - a*c;\n    \n    if( h < 0.0 ) return vec2(-1.0);\n    \n    h = sqrt(h);\n    \n    return vec2(-b-h,-b+h)/a;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 col = background(rayOri - rayDir*cylIntersect(rayOri, -rayDir, 20.0).x);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}