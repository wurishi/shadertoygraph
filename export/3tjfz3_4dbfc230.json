{"ver":"0.1","info":{"id":"3tjfz3","date":"1599580586","viewed":53,"name":"Raymarcher_LO","username":"loganobrien121","description":"A raymarcher","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100. //WE PUT A DECIMEL HERE AND NOT ON MAX STEPS BECAUSE MAX STEPS IS AN INT\n\t\t\t\t\t  //WHEREAS MAX_DIST IS A FLOAT\n#define SURF_DIST .01 //OUR \"SURFACE DIST\" IS WHEN THE SPHERE THAT SEEKS A HIT DURING OUR MARCH REACHES A SMALL SIZE, IN THIS CASE .01\n\t\t\t\t\t  //THEN WE HAVE A HIT\n\nfloat sdCapsule (vec3 p, vec3 a, vec3 b, float r)\n{ \n    vec3 ab = b-a; //THIS WOULD BE THE TOP VEC3 - BOTTOM VEC3\n    vec3 ap = p-a; //THIS IS THE SURFACE POINT - THE BOTTOM VEC3\n    \n    float t = dot(ab, ap) / dot(ab, ab); //DOT IS USED TO INTERSECT TWO VECTORS. \n    t = clamp(t, 0., 1.); //THIS CLAMPS IT TO MAKE SURE OUR VALUE IS ALWAYS BETWEEN 0 AND 1 \n    \n    vec3 c = a + t*ab; \n    return length(p-c) - r; \n}\n\nfloat sdTorus (vec3 p, vec2 r) \n{\n    float x = length(p.xz)-r.x; \n   \n    return length(vec2(x, p.y)) - r.y; \n    \n}\n\nfloat GetDist(vec3 p) //THIS TAKES A POINT  IN 3D SPACE AS AN INPUT\n    {\n        vec4 sphere = vec4(0,1,6,1); //THIS IS TO CALCULATE DISTANCE FROM ORIGIN TO A SPHERE. This would be different for other shapes. \n \n        float sphereDist = length(p-sphere.xyz) - sphere.w; //We find the distance to the center of the sphere by subracting its position\n        \t\t\t\t\t\t\t\t\t\t\t\t\t//from the camera position. Then, we subtract the radius of the sphere so that \n        \t\t\t\t\t\t\t\t\t\t\t\t\t//we're hitting its area, or \"shell\" for your dumbass, Logan. \n        \t\t\t\t\t\t\t\t\t\t\t\t\t//Not its center point.\n        \t\t\t\t\t\t\t\t\t\t\t\n        float planeDist = p.y; //Distance to the \"plane\" aka the ground. We find this by subtracting the plane y from the camera y.\n        \t\t\t\t\t\t//In simpler terms, if the camera is at 5y and the plane is the ground at 0, then our height is just \\\n        \t\t\t\t\t\t//the camera y, or p.y\n        \n        float cd = sdCapsule(p, vec3(0,1,6), vec3(1, 2, 6), .2); //THIS GIVES US THE CAPSULE DISTANCE AND FILLS OUT THE INPUTS NEEDED\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t//IN SD CAPSULE ABOVE. A = 1ST VEC3, B = 2ND VEC3 AND R = THE RADIUS AFTER \n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t//THE TWO\n        \n        float td = sdTorus(p-vec3(0, .2, 6), vec2(1.5, .2)); //THIS IS THE PARAMETERS FOR A TORUS. \n        \n        //float d = min(sphereDist, planeDist); //THIS IS FOR SPHERE. \n        \t\t\t\t\t\t\t\t\t   //To ensure we don't clip through an object we always find the MINIMUM distance.\n        \n        float d = min(cd, planeDist);  //THIS IS IF WE WANT TO RENDER A CAPSULE  \n        \n        //float d = min(td, planeDist);  //THIS IS IF WE WANT TO RENDER A TORUS  \n        d = min(d, td); \n        \n        return d; \n    }\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO = 0.; //Distance origin, or how far away we've marched from the origin. \n        \n        for(int i=0; i < MAX_STEPS; i++) //Loop that goes until you've reached max # of steps. \n        {\n            vec3 p = ro+dO*rd; //Point P is the blue point (\n            float dS = GetDist(p); //Distance to the scene. \n            dO += dS; //We add the distance to the scene to how far we've marched away from origin. \n            \n            if(dS<SURF_DIST || dO > MAX_DIST) break; //If distance to scene  is smaller than some defined surface distance, we have a hit. \n            \t\t\t\t\t\t\t\t\t\t    //Or if it's past our max distance and we haven't hit anything, we break out of it. \n        }\n        return dO; \n    }\n\nvec3 GetNormal(vec3 p) //THIS IS HOW WE FIND THE NORMAL VECTOR, IE THE ORIENTATION OF A SURFACE\n    \t\t\t\t\t//ESSENTIALLY BY DOING THE SAME ALGORITHM TO DETERMINE A SLOPE. WE MAKE 2 POINTS\n    \t\t\t\t\t//VERY CLOSE TOGETHER, THEN SUBTRACT THE DISTANCE A LITTLE TO THE RIGHT, UP AND\n    \t\t\t\t\t//BEHIND THE SURFACE BETWEEN THEM TO FIND WHICH WAY IT'S PORIENTED. \n{\n    \n    vec2 e = vec2(.01, 0); //THIS IS OUR NEW POINT. OUR X VALUE IS .01 AND OUR Y VALUE IS 0.\n    float d = GetDist(p); //THIS IS OUR ORIGINAL POINT IN 3D SPACE WE MADE ABOVE\n    \n    vec3 n = d - vec3( //THESE ARE THE SUBTRACTIONS TO GIVE US OUR NORMAL \n        GetDist(p-e.xyy), //TO THE RIGHT, IE - .01, 0, 0\n        GetDist(p-e.yxy), //UP, IE 0, .01, 0 BECAUSE WE USE THE XY VALUES DEFINED ABOVE, WHEN WE DEFINE VEC2 E\n        GetDist(p-e.yyx)); //BEHIND\n        \n        return normalize(n); \n    \n}\n        \nfloat GetLight(vec3 p)\n        {\n            vec3 lightPos = vec3(0,5,6); //HARDCODE THE LIGHT POSITION. FOR NOW WE'LL SAY IT'S AT THESE POINTS. \n            lightPos.xy += vec2(sin(iTime), cos(iTime))*2.; \n            vec3 l = normalize(lightPos-p); //THIS CALCULATES WHERE LIGHT IS COMING FROM, FROM THE PERSPECTIVE OF THE SURFACE POINT\n            vec3 n = GetNormal(p); \n            \n            float dif = clamp(dot(n, l), 0., 1.); //IF WE DON'T CLAMP IT BETWEEN 0 AND 1, THIS ACTUALLY GIVES US A VALUE BETWEEN -1 AND 1\n            \t\t\t\t\t\t\t\t\t  //WHICH IS FINE WITH A SIMPLE SHAPE LIKE A SPHERE BUT IF WE WANT TO WORK WITH MORE COMPLEX\n            \t\t\t\t\t\t\t\t\t  //STUFF, IT WOULD GIVE US TROUBLE. SO WE CLAMP IT BETWEEN 0 AND 1 \n            \n            float d = RayMarch(p+n*SURF_DIST, l); //THIS IS HOW WE CALCULATE SHADOW. WE RAYMARCH BETWEEN SURFACE POINT AND LIGHT POS AND RETURN A VALUE.\n            \n            if(d<length(lightPos - p)) dif *= .1; //IF THE VALUE WE GET IS SMALLER THAN THE LIGHT POS - SURFACE POSITION, WE KNOW THAT \n            \t\t\t\t\t\t\t\t\t  //WE'RE IN SHADOW. TO MAKE A SHADOW, WE JUST TAKE THE LIGHT VALUE DIF AND MULTIPLY IT BY \n            \t\t\t\t\t\t\t\t\t  //A SMALL AMOUNT TO CREATE THE SHADOW\n            return dif;\n        }\n            \n        \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1,0); //ray origin, or position of camera\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); //ray direction\n    \n    float d = RayMarch(ro, rd); \n    \n    vec3 p = ro + rd * d; //Camera + ray direction for as long as it takes to get to the intersection point. We use this \n    \t\t\t\t     //point, p, as an input through many of our functions in this raymarcher. \n    \t\t\t\t\t \n    \n    float dif = GetLight(p); //THIS IS THE DIFFUSE OF THE LIGHT\n    d /= 10.; \n    col = vec3(dif); // OUR COLOR IS DETERMINED BY THE DIFFUSE\n      \n    fragColor = vec4(col,1.0);\n}\n    \n    \n\n\n     \n\n        \n   \n","name":"Image","description":"","type":"image"}]}