{"ver":"0.1","info":{"id":"fdVcRm","date":"1654637458","viewed":122,"name":"SDF ray-marched lava lamp","username":"Alluysl","description":"An attempt at using a SDF to represent the wax of a lava lamp instead of ray-marching with a fixed stride.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","volumetric","lavalamp"],"hasliked":0,"parentid":"7tsfzX","parentname":"Blob ray-marched lava lamp"},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BACKGROUND_COLOR vec3(0.5f, 0.5f, 1.0f)\n\n// The amount of metaballs\n// The more there are, the quicker the same one will reach the same position again\n// This is because the noise texture is finite and sampled based on the ball and time\n// Doesn't actally control the amount of blobs (unrolled loop) but still used in calculations\n#define METABALLS 16\n\n#define METABALL_MIN_RADIUS 0.0625f\n#define METABALL_MAX_RADIUS 0.125f\n\n#define FLOW_TIME_SCALE 0.015625f\n#define UP_FLOW_TIME_SCALE 0.0625f\n#define ROTATION_TIME_SCALE 0.0981747705f\n\n#define CAMERA_OFFSET -2.0f\n#define SPHERE_RADIUS 0.375f\n\n#define CORE_DENSITY_FACTOR 1.125f\n#define RING_DENSITY_FALLOFF 0.0f\n\n#define SMOOTH_UNION_FACTOR 0.25f\n\n#define MAX_ITERATIONS 12\n#define SDF_EPSILON 1e-6\n\n#define SPECULAR_HIGHLIGHT 1\n#define POINT_LIGHT_POSITION vec3(1.0f, 0.5f, 0.0f)\n#define SPECULAR_DEGREE 6\n\n\n// Cubic interpolation http://paulbourke.net/miscellaneous/interpolation/\nfloat mixCubic(float y0, float y1, float y2, float y3, float mu)\n{\n   float a0, a1, a2, a3, mu2;\n\n   mu2 = mu * mu;\n   a0 = y3 - y2 - y0 + y1;\n   a1 = y0 - y1 - a0;\n   a2 = y2 - y0;\n   a3 = y1;\n\n   return a0 * mu * mu2 + a1 * mu2 + a2 * mu + a3;\n}\n\nvec4 mixCubic(vec4 z, vec4 a, vec4 b, vec4 c, float t){\n    return vec4(\n        mixCubic(z.x, a.x, b.x, c.x, t),\n        mixCubic(z.y, a.y, b.y, c.y, t),\n        mixCubic(z.z, a.z, b.z, c.z, t),\n        mixCubic(z.w, a.w, b.w, c.w, t)\n    );\n}\n\n\n// https://gist.github.com/h3r/3a92295517b2bee8a82c1de1456431dc\nfloat hash(float x, float y){\n    return fract(1e4 * sin(17.0 * x + y * 0.1) * (0.1 + abs(sin(y * 13.0 + x))));\n}\n\nvec4 hash4(float x, float y){\n    return vec4(\n        -0.25f + 0.5f * hash(x + 0.75f, y),\n        -0.25f + 0.5f * hash(x + 0.5f, y),\n        -0.25f + 0.5f * hash(x + 0.25f, y),\n        hash(x, y));\n}\n\n\n// Inigo Quilez MIT licence https://www.shadertoy.com/view/lt3BW2\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n\n// Samples the color from a gradient\nvec3 colorGradient(float x){\n    return vec3(smoothstep(0.25f, 0.4f, x), smoothstep(0.4f, 0.6f, x), smoothstep(0.65f, 0.875f, x));\n}\n\n\n// Samples the noise texture at the given index\nvec4 noiseAtId(int i){\n    return texture(iChannel0, vec3(float(i >> 10) / 32.0f, float(i << 5 >> 10) / 32.0f, float(i << 10 >> 10) / 32.0f));\n}\n\n\n// Samples the noise texture at the given time for the given metaball\nvec4 noise(int ballId, float time){\n    \n    float flooredTime = floor(time);    \n    // int stride = 32768 / METABALLS;\n    //int t = int(flooredTime);\n\n    // vec4 z = noiseAtId(stride * ballId + (t + stride - 1) % stride);\n    // vec4 a = noiseAtId(stride * ballId + t % stride);\n    // vec4 b = noiseAtId(stride * ballId + (t + 1) % stride);\n    // vec4 c = noiseAtId(stride * ballId + (t + 2) % stride);\n\n    vec4 z = hash4(float(ballId), flooredTime - 1.0f);\n    vec4 a = hash4(float(ballId), flooredTime);\n    vec4 b = hash4(float(ballId), flooredTime + 1.0f);\n    vec4 c = hash4(float(ballId), flooredTime + 2.0f);\n\n    return mixCubic(z, a, b, c, time - flooredTime);\n}\n\n\n// Gets the position and radius at a given time for the given metaball\nvec4 getBallInfo(int ballId, float time){\n\n    vec4 res = noise(ballId, time);\n\n    // Scale [0;1] -> [-1;1]\n    res.xyz *= 2.0f;\n    res.xyz += vec3(-1.0f, -1.0f, -1.0f);\n    \n    // Fit noise better\n    // For some reason it's actually on [-0.5,0.5] by now, so rescale\n    // with also some squeezing towards the center for a better look\n    res.x = res.x * res.x + res.x;\n    res.y *= 2.0f;\n    res.z = res.z * res.z + res.z;\n\n    // Updraft\n    res.y += 1.0f + iTime * UP_FLOW_TIME_SCALE;\n    res.y = fract(res.y);\n    res.y = -2.0f + 4.0f * res.y;\n\n    // Size\n    res.w = mix(METABALL_MIN_RADIUS, METABALL_MAX_RADIUS, res.w);\n    res.w *= min(mix(1.0f, 0.0f, res.y), mix(1.0f, 0.0f, -1.0f + 2.0f * length(res.xyz)));\n\n    // Scale to sphere\n    res.xyz *= SPHERE_RADIUS;\n    \n    // Rotate sphere\n    float angle = iTime * ROTATION_TIME_SCALE;\n    float c = cos(angle);\n    float s = sin(angle);\n    res.xyz = mat3(c, 0.0f, s, 0.0f, 1.0f, 0.0f, -s, 0.0f, c) * res.xyz;\n\n    return res;\n}\n\n\n// Samples the SDF at the given coordinates at the given time\nfloat sdfAt(vec3 coords, float time){\n\n    float value = abs(CAMERA_OFFSET) + 2.0 * SPHERE_RADIUS;\n    \n    for (int i = 0; i < METABALLS; ++i){\n    \n        vec4 ballInfo = getBallInfo(i, time);\n        vec3 delta = ballInfo.xyz - coords;\n        \n        value = opSmoothUnion(value, length(delta) - ballInfo.w, SMOOTH_UNION_FACTOR);\n    }\n\n    return value;\n}\n\n\n// Gets the full-alpha color of the sphere by sphere-marching\nvec3 getSphereColor(vec3 start, vec3 end, vec3 backgroundColor){\n    \n    vec3 diff = end - start;\n    float maxDist = length(diff);\n    vec3 dir = diff / maxDist;\n    \n    float sdf;\n    float dist = 0.0f;\n    vec3 color = backgroundColor;\n\n    for (int i = 0; dist < maxDist && i < MAX_ITERATIONS; ++i){\n        \n        sdf = sdfAt(start + dist * dir, iTime * FLOW_TIME_SCALE);\n        \n        if (abs(sdf) <= SDF_EPSILON){\n            color = mix(colorGradient(0.75f), color, CORE_DENSITY_FACTOR * dist / SPHERE_RADIUS);\n            break;\n        }\n        \n        color = mix(color, colorGradient(0.5f - 4.0f * sdf), (1.0f - RING_DENSITY_FALLOFF * sdf / SPHERE_RADIUS));\n        \n        dist += sdf;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = min(iResolution.x, iResolution.y);\n    \n    // The location of the pixel on the XY plane\n    vec2 viewPlaneLocation = (fragCoord - iResolution.xy* 0.5f) / vec2(resolution, resolution);\n\n    vec3 cameraPosition = vec3(0.0f, 0.0f, CAMERA_OFFSET);\n\n    // The direction of the pixel from the camera\n    vec3 dir = normalize(vec3(viewPlaneLocation, 0.0f) - cameraPosition);\n    \n    // The vector from the camera to the closest point on the ray from the origin\n    vec3 toClosest = dir * dot(dir, -cameraPosition);\n\n    // The distance from the camera to the closest point on the ray from the origin\n    float tcd = length(toClosest);\n    \n    // The vector from the origin to the closest point on the ray\n    vec3 closest = cameraPosition + toClosest;\n    \n    // The square distance from the origin to the closest point on the ray\n    float csd = dot(closest, closest);\n        \n    // The distance travelled by the ray inside of the sphere to the point\n    // closest to the origin, which is half the distance it travels there total\n    float ttcd = sqrt(abs(SPHERE_RADIUS * SPHERE_RADIUS - csd));\n\n    // The start and end of the ray through the sphere\n    vec3 start = cameraPosition + dir * (tcd - ttcd);\n    vec3 end   = cameraPosition + dir * (tcd + ttcd);\n\n    vec3 backgroundColor = BACKGROUND_COLOR;\n    vec3 color = csd <= SPHERE_RADIUS * SPHERE_RADIUS ? getSphereColor(start, end, backgroundColor) : backgroundColor;\n\n    // Previous version, marching with a fixed stride\n    // vec3 color = backgroundColor;\n    // for (float depth = 3.0f; depth > 1.0f; depth -= 0.0625)\n    //     color = march(color, cameraPosition + depth * dir);\n\n    // Take account of sphere depth\n    color = mix(backgroundColor, color, ttcd / SPHERE_RADIUS);\n\n#if SPECULAR_HIGHLIGHT\n    float plAngle = -iTime * ROTATION_TIME_SCALE;\n    float plc = cos(plAngle);\n    float pls = sin(plAngle);\n\n    vec3 pointLightPosition = mat3(plc, 0.0f, -pls, 0.0f, 1.0f, 0.0f, pls, 0.0f, plc) * POINT_LIGHT_POSITION;\n    vec3 pointLightDirection = -normalize(pointLightPosition - start);\n    vec3 normal = normalize(start);\n    float nDotPLD = dot(normal, pointLightDirection);\n    vec3 reflection = nDotPLD * 2.0f * normal - pointLightDirection;\n\n    float specularAmount = nDotPLD <= 0.0f ? dot(dir, reflection) : 0.0f;\n    for (int i = 0; i < SPECULAR_DEGREE - 1; ++i)\n        specularAmount *= specularAmount;\n    color = csd <= SPHERE_RADIUS * SPHERE_RADIUS ? mix(color, vec3(1.0f, 1.0f, 1.0f), specularAmount) : color;\n#endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}