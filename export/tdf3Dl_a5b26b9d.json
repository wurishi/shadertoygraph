{"ver":"0.1","info":{"id":"tdf3Dl","date":"1547790890","viewed":295,"name":"Sphere dist function using fBM","username":"edo_m18","description":"Sphere distance function using fBM.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 m = mat3( 0.00,  0.80,  0.60,\n                         -0.80,  0.36, -0.48,\n                         -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                                  mix(hash(n +  57.0), hash(n +   58.0), f.x), f.y),\n                            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                                   mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    f   = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nfloat sp_dist(in vec3 pos)\n{\n    return length(pos) - 2.0 + fbm(pos * 2.0 * sin(iTime));\n    //return 1.2 - length(pos) * 0.05 + fbm(pos * 0.5);\n}\n\nvec3 getNormal(in vec3 p)\n{\n    const float e = 0.01;\n    return normalize(vec3(sp_dist(vec3(p.x + e, p.y, p.z)) - sp_dist(vec3(p.x - e, p.y, p.z)),\n                                        sp_dist(vec3(p.x, p.y + e, p.z)) - sp_dist(vec3(p.x, p.y - e, p.z)),\n                                        sp_dist(vec3(p.x, p.y, p.z + e)) - sp_dist(vec3(p.x, p.y, p.z - e))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Camera\n    float camDist = 3.0;\n    vec3 target = vec3(0, 0, 0);\n    vec3 ori = vec3(sin(iTime) * camDist, 0, cos(iTime) * camDist);\n    vec3 ww = normalize(target - ori);\n    vec3 up = vec3(0, 1.0, 0.0);\n    vec3 uu = normalize(cross(up, ww));\n    vec3 vv = normalize(cross(ww, uu));\n    float targetDepth = 1.3;\n    \n    vec3 dir = normalize(uu * uv.x + vv * uv.y + ww * targetDepth);\n    \n    const int sampleCount = 64;\n    const float eps = 0.01;\n    \n    float dist = 0.0;\n    vec3 ray = ori;\n    \n    for (int i = 0; i < sampleCount; i++)\n    {\n        dist = sp_dist(ray);\n        \n        if (dist < eps)\n        {\n            break;\n        }\n        \n        ray += dir * dist;\n    }\n    \n    if (dist < eps)\n    {\n        vec3 ldir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 normal = getNormal(ray);\n        float diff = clamp(dot(ldir, normal), 0.5, 1.0);\n        \n        vec4 col = texture(iChannel0, normal);\n        \n        fragColor = vec4(col.xyz * diff, 1.0);\n    }\n    else\n    {\n        vec3 col = mix(vec3(1.0), vec3(0.0, 0.0, 0.0), pow(abs(uv.y), 0.4));\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}