{"ver":"0.1","info":{"id":"MsG3Wy","date":"1456154495","viewed":901,"name":"Carbon [TDF2016]","username":"gam0022","description":"Third place prize works in GLSL Compo, Tokyo Demo Fest 2016. This work expects to be combined with a BPM120 music.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// consts\nconst float EPS = 0.01;\nconst float OFFSET = EPS * 100.0;\nconst float PI = 3.14159;\n\n\n// globals\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\nvec3 cPos, cDir;\nvec3 sPos;\nfloat sSize;\nvec3 illuminationColor;\nfloat tempo;\n\nstruct Intersect {\n\tbool isHit;\n\n\tvec3 position;\n\tfloat distance;\n\tvec3 normal;\n\n\tint material;\n\tvec3 color;\n};\n\nconst int CIRCUIT_MATERIAL = 0;\nconst int MIRROR_MATERIAL = 1;\n\n\n// distance functions\nvec3 onRep( vec3 p, float interval ) {\n\n\treturn mod( p, interval ) - 0.5 * interval;\n\n}\n\n// thanks to https://www.shadertoy.com/view/MdVGRc\nfloat MBoxDist( vec3 p ) {\n\n  const float scale = 2.7;\n  const int n = 12;\n  vec4 q0 = vec4 (p, 1.);\n  vec4 q = q0;\n\n  for ( int i = 0; i < n; i++ ) {\n\n    q.xyz = clamp( q.xyz, -1.0, 1.0 ) * 2.0 - q.xyz;\n    q = q * scale / clamp( dot( q.xyz, q.xyz ), 0.5, 1.0 ) + q0;\n\n  }\n\n  return length( q.xyz ) / abs( q.w );\n\n}\n\nfloat sphereDist( vec3 p, vec3 c, float r ) {\n\n\treturn length( p - c ) - r;\n\n}\n\nfloat sceneDist( vec3 p ) {\n\n\treturn min(\n\t\tsphereDist( p, sPos, sSize ),\n\t\tMBoxDist( onRep( p, 7.0 ) )\n\t);\n\n}\n\n\n// color functions\nvec3 hsv2rgb( vec3 c ) {\n\n\tvec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n\tvec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\n\treturn c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\n\n}\n\n// thanks to http://glslsandbox.com/e#21290.5\nvec2 circuitPattern( vec2 p ) {\n\n\tp = fract(p);\n\tfloat r = 0.123;\n\tfloat v = 0.0, g = 0.0;\n\tr = fract(r * 9184.928);\n\tfloat cp, d;\n\t\n\td = p.x;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.x - 1.0;\n\tg += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);\n\t\n\tconst int iter = 12;\n\tfor(int i = 0; i < iter; i ++)\n\t{\n\t\tcp = 0.5 + (r - 0.5) * 0.9;\n\t\td = p.x - cp;\n\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);\n\t\tif(d > 0.0) {\n\t\t\tr = fract(r * 4829.013);\n\t\t\tp.x = (p.x - cp) / (1.0 - cp);\n\t\t\tv += 1.0;\n\t\t}\n\t\telse {\n\t\t\tr = fract(r * 1239.528);\n\t\t\tp.x = p.x / cp;\n\t\t}\n\t\tp = p.yx;\n\t}\n\tv /= float(iter);\n\treturn vec2(g, v);\n\n}\n\n\nIntersect minIntersect( Intersect a, Intersect b ) {\n\n\tif ( a.distance < b.distance ) {\n\t\treturn a;\n\t} else {\n\t\treturn b;\n\t}\n\n}\n\nIntersect sceneIntersect( vec3 p ) {\n\n\tIntersect a, b;\n\ta.distance = sphereDist( p, sPos, sSize );\n\ta.material = MIRROR_MATERIAL;\n\n\tb.distance = MBoxDist( onRep( p, 7.0 ) );\n\tb.material = CIRCUIT_MATERIAL;\n\n\treturn minIntersect( a, b );\n}\n\nvec3 getNormal( vec3 p ) {\n\n\treturn normalize(vec3(\n\t\tsceneDist(p + vec3( EPS, 0.0, 0.0 ) ) - sceneDist(p + vec3( -EPS, 0.0, 0.0 ) ),\n\t\tsceneDist(p + vec3( 0.0, EPS, 0.0 ) ) - sceneDist(p + vec3( 0.0, -EPS, 0.0 ) ),\n\t\tsceneDist(p + vec3( 0.0, 0.0, EPS ) ) - sceneDist(p + vec3( 0.0, 0.0, -EPS ) )\n\t));\n\n}\n\nfloat getShadow( vec3 ro, vec3 rd ) {\n\n\tfloat h = 0.0;\n\tfloat c = 0.0;\n\tfloat r = 1.0;\n\tfloat shadowCoef = 0.5;\n\n\tfor ( float t = 0.0; t < 50.0; t++ ) {\n\n\t\th = sceneDist( ro + rd * c );\n\n\t\tif ( h < EPS ) return shadowCoef;\n\n\t\tr = min( r, h * 16.0 / c );\n\t\tc += h;\n\n\t}\n\n\treturn 1.0 - shadowCoef + r * shadowCoef;\n\n}\n\nIntersect getRayColor( vec3 origin, vec3 ray ) {\n\n\t// marching loop\n\tfloat dist;\n\tfloat depth = 0.0;\n\tvec3 p = origin;\n\tint count = 0;\n\tIntersect nearest;\n\n\tfor ( int i = 0; i < 64; i++ ){\n\n\t\tdist = sceneDist( p );\n\t\tdepth += dist;\n\t\tp = origin + depth * ray;\n\n\t\tcount = i;\n\t\tif ( abs(dist) < EPS ) break;\n\n\t}\n\n\tif ( abs(dist) < EPS ) {\n\n\t\tnearest = sceneIntersect( p );\n\t\tnearest.position = p;\n\t\tnearest.normal = getNormal(p);\n\t\tfloat diffuse = clamp( dot( lightDir, nearest.normal ), 0.1, 1.0 );\n\t\tfloat specular = pow( clamp( dot( reflect( lightDir, nearest.normal ), ray ), 0.0, 1.0 ), 10.0 );\n\t\t//float shadow = getShadow( p + nearest.normal * OFFSET, lightDir );\n\n\t\tif ( nearest.material == CIRCUIT_MATERIAL ) {\n\n\t\t\tvec2 uv = p.yz;\n\t\t\tvec2 dg = circuitPattern(uv);\n\t\t\tfloat glow = max( sin( length( p ) - 1.8 * iTime ) * 2.5, 0.0 );\n           \tfloat pattern = max( dg.x - 1.0, 0.0 );\n\t\t\tnearest.color = vec3( 0.2, 0.2, 0.2 ) +  illuminationColor * pattern * glow * diffuse + specular /* * max( 0.5, shadow )*/;\n\n\t\t} else if ( nearest.material == MIRROR_MATERIAL ) {\n\n\t\t\tnearest.color = ( vec3( 1.0 ) - illuminationColor ) * diffuse * 0.5 + specular/* * max( 0.5, shadow )*/;\n\n\t\t}\n\n\t\tnearest.isHit = true;\n\n\t} else {\n\n\t\tnearest.color = vec3(0.1);\n\t\tnearest.isHit = false;\n\n\t}\n\n\tnearest.color += clamp( sin( iTime * 0.2 - 0.5 * PI ) * 0.2 * depth - 0.005 * float(count), -1.0, 1.0 );\n\treturn nearest;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t// fragment position\n\tvec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / min(  iResolution.x,  iResolution.y );\n\n\t// camera and ray\n\tcPos  = vec3( -0.8185093402862549, 4.509979248046875, iTime );\n\tcDir  = normalize( vec3( sin( iTime * 0.5 ), sin( iTime * 0.1 ), cos( iTime * 0.6 ) + 0.5 ) );\n\tvec3 cSide = normalize( cross( cDir, vec3( 1.0, 1.0 ,0.0 ) ) );\n\tvec3 cUp   = normalize( cross( cSide, cDir ) );\n\tfloat targetDepth = 1.3;\n\tvec3 ray = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth );\n\n\t// music's tempo\n\ttempo = sin( 4.0 * PI * iTime );\n\n\t// sphere pos\n\tfloat d = 0.2 + 0.1 * cos( iTime * 0.5 );\n\tsPos = cPos + vec3( 0.0, 0.0, d );\n\tsSize = 0.03 + 0.005 * tempo;\n\n\t// Illumination Color\n\tilluminationColor = hsv2rgb( vec3( iTime * 0.02 + 0.6, 1.0, 1.0 ) );\n\n\tvec3 color = vec3( 0.0 );\n\tfloat alpha = 1.0;\n\tIntersect nearest;\n\n\tfor ( int i = 0; i < 3; i++ ) {\n\n\t\tnearest = getRayColor( cPos, ray );\n\n\t\tcolor += alpha * nearest.color;\n\t\talpha *= 0.7;\n\t\tray = normalize( reflect( ray, nearest.normal ) );\n\t\tcPos = nearest.position + nearest.normal * OFFSET;\n\n\t\tif ( !nearest.isHit || nearest.material == CIRCUIT_MATERIAL ) break;\n\n\t}\n\n\tcolor += 0.2 * tempo;\n\n\tfragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}