{"ver":"0.1","info":{"id":"NlyfW1","date":"1664397622","viewed":308,"name":"Shaking Jello","username":"Alpaga","description":"Probably not physically accurate. Try changing the opacity with the mouse vertical position.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","transparency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Change opacity with mouse y-position.\n\n//#define VR\n//#define CROSS // VR crossing eyes\n\nconst vec3 lightColor = vec3(2);\nconst vec3 lightDirection = normalize(vec3(-1,1,-1));\nconst vec3 ambient = vec3(0.05);\n\nfloat eta = 0.7;// Refraction\nfloat opacity = 0.97;\n\nconst vec2 delta = vec2(0.0,0.01);\n\n// Varying position of the plate\nfloat getPosition() {\n    float t = mod(iTime, 2.0);\n    return -(smoothstep(0.0,0.3,t)-smoothstep(1.0,1.3,t)-0.5);\n    \n}\n// Jello shaking effect\nvec3 transform(vec3 p) {\n    p.x -= getPosition();\n    \n    float t = mod(iTime,1.0);\n    float strength = 0.25*(smoothstep(0.0,0.2,t)-smoothstep(0.2,0.9,t));\n    return p+vec3(sin(20.0*iTime+p.z)*sin(1.5*p.y)*strength,0,0);\n}\n// Taken from https://iquilezles.org/articles/distfunctions/\nfloat sdRdCyl(vec3 p, vec3 c, float r, float hh, float rd) {\n    p -= c;\n    vec2 q = vec2(abs(p.y)-hh+rd,length(p.xz)-r+rd);\n    return min(max(q.x,q.y),0.0)+length(max(q,0.0))-rd;\n}\n\n// Jello\nfloat sdJello(vec3 p) {\n    p = transform(p);\n    p.y -=.01;\n    float noise = 0.001*(texture(iChannel0,0.3*(p.xz+p.y)).r);\n    float c1 = sdRdCyl(p,vec3(0,0.58,0),1.5,0.5,0.5);\n    float c2 = sdRdCyl(p,vec3(0,0.33,0),1.5,0.25,0.05);\n    return min(c1,c2)+noise;\n}\n\nvec4 colJello(vec3 p) {\n    p = transform(p);\n    vec2 q = abs(p.xz);\n    float f = min(q.x,q.y);\n    float g = abs(dot(q,vec2(-.67,1.0)));\n    vec3 diag = mix(vec3(1,0,0),mix(vec3(1),vec3(0,0,1),\n        step(0.2,g)),step(0.1,g));\n    vec3 col = mix(vec3(1,0,0),mix(vec3(1),diag,\n        step(.35,f)), step(.2,f));\n    return vec4(col,opacity);\n}\n\n// Table\nfloat sdTable(vec3 p) {\n    return p.y + 0.03*(1.0-texture(iChannel1,0.1*p.xz).r);\n}\nvec4 colTable(vec3 p) {\n    vec4 tex = texture(iChannel1,0.1*p.xz);\n    return tex * tex;// Gamma\n}\n// Plate\nfloat sdPlate(vec3 p) {\n    p.x -= getPosition();\n    \n    float l = length(p.xz);\n    p.y -= 0.25*smoothstep(2.0,2.5,l);// Edge elevation\n    return 0.8*(length(vec2(p.y-0.02,max(l-2.5,0.0)))-0.02);\n}\nfloat pattern(vec2 p) {\n    return smoothstep(0.1,0.25,length(p-0.5));\n}\nvec4 colPlate(vec3 p) {\n    p.x -= getPosition();\n    \n    float a = atan(p.z,p.x);\n    float r = length(p.xz);\n    vec2 uv = vec2(fract(31.0*(a/6.2832+0.5)),(r-2.05)/0.35);\n    // Pattern\n    float l = smoothstep(-0.6,-0.5,-abs(uv.y-0.5))*pattern(uv);\n    // Circles\n    l += step(-2.0,-r)*smoothstep(-0.05,0.0,-abs(mod(r,0.1)-0.05));\n    // Outer circle\n    l += smoothstep(-0.07,0.0,-abs(r-2.47));\n    return vec4(mix(vec3(1.,.9,0.5),vec3(0,0,0.05),l),1);\n}\n\nfloat sd(vec3 p, out int id) {\n \tfloat minD = 1000.0;\n    float d;\n    \n    \n    d = sdTable(p);\n    if(d<minD) {\n        minD = d;\n        id = 0;\n    }\n\n    d = sdJello(p);\n    if(d<minD) {\n        minD = d;\n        id = 1;\n    }\n    \n    d = sdPlate(p);\n    if(d<minD) {\n        minD = d;\n        id = 2;\n    }\n\n    return minD;\n}\n// Color in .rgb channels\n// Opacity in .a channel\nvec4 color(vec3 p, int id) {\n \tvec4 col;\n    switch(id) {\n        case 0:\n            col = colTable(p);\n            break;\n        case 1:\n            col = colJello(p);\n            break;\n        case 2:\n            col = colPlate(p);\n            break;\n    }\n    return col;\n}\n// sig = 1. if ray travels outside objects\n// sig = -1. if ray travels inside (transparent) object\nfloat march(vec3 start, vec3 dir, float sig, out int id) {\n\tfloat d = 1.0;\n    float dist = 0.0;\n    vec3 p = start;\n    float epsilon = 0.1/iResolution.y;\n    for(int i=0; i<100; i++) {\n        if(d<epsilon) return dist;\n        if(d>50.0) {\n            id = -1;\n            return dist;\n        }\n        p = start + dist * dir;\n        d = sig * sd(p, id);\n        dist += d;\n    }\n    return dist;\n}\n// Ray color in transparent medium\nvec4 resultColor(vec3 start, vec3 dir, int id, float dOut) {\n    vec3 col = vec3(0.0);\n    float alpha = 1.0;\n    float di = 0.005;\n    \n    for(float i=.01; i<dOut; i+=di) {\n     \tvec3 p = start + i*dir;\n        vec4 c = color(p, id);\n        \n        float layerAlpha = 1.0-pow(1.0-c.a, di);        \n        col += alpha * c.rgb * layerAlpha ;\n        alpha *= (1.0 - layerAlpha);\n        if(alpha == 0.0) break;\n    }\n    return vec4(col,alpha);\n}\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p, id);\n    return normalize(vec3(\n        sd(p+delta.yxx, id),\n        sd(p+delta.xyx, id),\n        sd(p+delta.xxy, id)) - d);\n}\n\n// Color of coming froml ight source\n// No refraction here\nvec3 incomingLightColor(vec3 p) {\n    vec3 toLight = normalize(lightDirection);\n    int id;\n    float d = march(p+0.1*toLight, toLight, 1.0, id);\n    \n    if(id < 0) {\n        // No obstacle\n        return lightColor;\n    }\n    \n    p += (0.1+d)*toLight;\n    vec4 col = color(p,id);\n    if(col.a==1.0) {\n        // Opaque obstacle\n        return vec3(0);\n    }\n    \n    // Transparent obstacle\n    float dOut = march(p+0.1*toLight, toLight, -1.0, id);\n    vec4 c = resultColor(p, toLight, id, dOut);\n    \n    return mix(c.rgb,lightColor,c.a) * c.a;\n}\nfloat diffuse(vec3 pos, vec3 normal) {\n    return max(dot(lightDirection, normal),0.0);\n}\nfloat specular(vec3 pos, vec3 normal, float refl, vec3 toCam) {\n    vec3 h = normalize(toCam + lightDirection);\n    return 5.0 * refl * pow(max(dot(h, normal), 0.0), 1000.0);\n\n}\nvec3 rayColor(vec3 start ,vec3 dir) {\n    vec3 res = vec3(0);\n    int id;\n\n    float dIn = march(start, dir, 1.0, id);\n    \n    if(id<0) {\n        // No intersection\n        return vec3(0);\n    }\n    \n    vec3 p = start + dIn * dir;\n    vec3 n = normal(p);\n    vec3 incomingLight = incomingLightColor(p);\n\n    if(color(p,id).a < 1.0) {\n        // Transparent object\n        vec3 refr = refract(dir, n, eta);\n        float dOut = march(p+0.1*refr, refr, -1.0, id);\n    \n        vec4 col = resultColor(p, refr, id, dOut);\n        \n        res = specular(p, n, 0.5, -dir) * incomingLight;\n\n        // Beyond the transparent object\n        p += (0.1+dOut)*refr;\n        n = -normal(p);\n\n        dir = refract(refr, n, 1.0/eta);\n        if(dot(dir,vec3(1))==0.0) {\n            dir = refr;// Incorrect: we should actually reflect\n        }\n        \n        float dBeyond = march(p+0.1*dir, dir, 0.5, id);\n        p += (0.1+dBeyond)*dir;\n\n        vec3 colBeyond = color(p,id).rgb;\n        \n        res += mix(col.rgb,colBeyond,col.a);\n    } else {\n        // Opaque object\n        res = color(p,id).rgb * (ambient + diffuse(p, n) * incomingLight) + specular(p, n, 0.04, -dir) * incomingLight;\n    }\n    return res;    \n}\n\nmat3 lookAt(vec3 cam, vec3 center, vec3 up) {\n    vec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.z > 0.0) {\n        opacity = 1.0-pow(1.0-iMouse.y/iResolution.y,5.0);\n    }\n\n    vec3 col;\n    vec2 resolution;\n    \n    float azimuth = 0.2*iTime;\n    float altitude = .7+.3*sin(0.3*iTime);\n    float camDistance = 7.0;\n    \n    vec3 cam = camDistance * vec3(\n        sin(azimuth)*cos(altitude),\n        sin(altitude),\n        cos(azimuth)*cos(altitude));\n    vec3 center = vec3(0,-0.5,0);\n    vec3 up = vec3(0,1,0);\n    \n    mat3 m = lookAt(cam, center, up);\n\n    // VR\n#ifdef VR\n    float halfEyesDistance = 0.25;\n    resolution = iResolution.xy * vec2(0.5,1.0);\n    float right = floor(fragCoord.x/resolution.x);\n    fragCoord.x = mod(fragCoord.x, resolution.x);\n#ifdef CROSS\n    cam += m*vec3(-(2.0*right-1.0)*halfEyesDistance,0,0);\n    m = lookAt(cam, center, up);\n#else\n    cam += m*vec3((2.0*right-1.0)*halfEyesDistance,0,0);\n    m = lookAt(cam, center, up);\n#endif\n#else\n    resolution = iResolution.xy;\n#endif\n\n    vec2 uv = (2.0*fragCoord - resolution)/resolution.y;\n\n    \n    vec3 dir = normalize(m*vec3(uv,-3.0));\n\n    col = rayColor(cam, dir);\n        \n    // Vignette\n    // Taken from https://www.shadertoy.com/view/XsGyDh\n    uv = fragCoord/iResolution.xy,\n    col = mix(col, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)));\n\n    // Gamma correction\n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}