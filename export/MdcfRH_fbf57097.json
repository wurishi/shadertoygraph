{"ver":"0.1","info":{"id":"MdcfRH","date":"1588218651","viewed":101,"name":"bezier curves zwy","username":"asforever123","description":"bezier curves zwy","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//common\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define MAX_NUM 10.e+10\n#define TOLERANCE 1./0.\n\n//\n#define GRID_INTERVAL 1.\n#define SCALE 10.\n#define LINE_WIDTH SCALE/100.\n//color\n#define LINE_COLOR vec3(0.6,0.9,0.5);\n#define GRID_COLOR vec3(0.6,0.3,0.3);\n#define AXIS_COLOR vec3(0.1,0.2,0.3);\n//\n\nfloat percentTime(float t, float d){\n    return t / d;\n}\n\nfloat easeInBack(float t, float b, float c, float d){\n    float s = 1.70158;\n    float p = percentTime(t,d);\n    return c*p*p*((s+1.)*p - s) + b;\n}\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\nfloat bezierCurve(float x,vec2 a,vec2 b,vec2 c){\n\n    float s = (x - a.x)/(c.x - a.x);\n    vec2 p0 = a + (b - a) * s;\n    vec2 p1 = b + (c - b) * s;\n    vec2 m = p0+(p1-p0)*s;\n    \n    return m.y;\n}\n\nconst int num = 8;\nfloat bezierCurves(float x,vec2 points[num]){\n    float y;\n    for(int i =0;i<num-2;i++){\n        vec2 a = points[i];\n        vec2 b = points[i+1];\n        vec2 c = points[i+2];\n        \n        a = i==0?a:(a+b)/2.;\n        c = i==num-3?c:(b+c)/2.;\n     \n        if(bool(clamp(x,a.x,c.x)==x)){\n           \ty = bezierCurve(x,a,b,c);\n        \tbreak;\n        }\n    }\n    return y;    \n}\n\n\n\nfloat TEST_MATH(float x){\n    x = x/5.;\n  \n    vec2 points[num];\n  \tpoints[0] = vec2(0.0,0.0);\n    points[1] = vec2(0.3,1.5);\n    points[2] = vec2(0.6,0.6);\n    points[3] = vec2(1.4,1.4);\n    points[4] = vec2(0.0,0.0);\n    points[5] = vec2(0.0,0.0);\n    points[6] = vec2(0.0,0.0);\n    points[7] = vec2(0.0,0.0);\n\n \tfloat y = bezierCurves(x,points);\n   \n\treturn y*5.;\n}\n\nfloat math(vec2 uv,float y,float lineWidth){\n    if(y>MAX_NUM)return 0.;\n    if(abs(y)==TOLERANCE)return 0.;\n    \n\tfloat dx = dFdx(uv.x);\n    float dy = dFdx(y);\n    vec2 t = normalize(vec2(-dy,dx));\n    float width = dot(vec2(0.,uv.y - y),t);\n\n    return 1. - smoothstep(0.,lineWidth,abs(width));\n    \n}                           \n\nfloat drawGrid(vec2 uv,float lineWidth,float interval){\n\n    float ver = 1. - smoothstep(0.,lineWidth,mod(uv.x,GRID_INTERVAL));\n    float hor = 1. - smoothstep(0.,lineWidth,mod(uv.y,GRID_INTERVAL));\n\treturn ver + hor;\n}\n\nfloat drawAxis(vec2 uv,float lineWidth){\n    float yAxis = 1. - smoothstep(0.,lineWidth,abs(uv.x));\n    float xAxis = 1. - smoothstep(0.,lineWidth,abs(uv.y));\n    return xAxis+yAxis;\n}\n\nfloat drawMath(vec2 uv,float lineWidth){\n    float x = uv.x;\n    float y = TEST_MATH(x);\n    float sum = math(uv,y,lineWidth);\n    return min(1.,sum);\n}\n\nvec3 render(vec2 uv,float lineWidth,float interval){\n   \tvec3 line = drawMath(uv,lineWidth)*LINE_COLOR;\n    vec3 grid = drawGrid(uv,lineWidth,interval)*GRID_COLOR;\n    vec3 axis = drawAxis(uv,lineWidth)*AXIS_COLOR;\n\n    return grid+axis+line;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 uv = 2. * fragCoord/iResolution.xy-1.;\n    uv.x*=aspect;\n    uv*=SCALE;\n    \n    float width = SCALE*aspect*2.;\n    float height = SCALE*2.;\n    vec3 result;\n  \tresult = render(uv,LINE_WIDTH,GRID_INTERVAL);\n    \n    fragColor = vec4(result,1.);\n}","name":"Image","description":"","type":"image"}]}