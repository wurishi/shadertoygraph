{"ver":"0.1","info":{"id":"Ws2cWz","date":"1586463328","viewed":371,"name":"spectral prisms","username":"stduhpf","description":"Blackbody light diffracted by some prism, with montecarlo integration for the wavelengths","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["2d","montecarlo","blackbody","fresnel","spectralrendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 rein(vec4 c){\n    c*=.05;\n    float l = dot(c.rgb,vec3(.2126,.7152,.0722));\n    return c/(1.+l);\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = pow(rein(texture(iChannel0,uv)/float(iFrame+1)),vec4(1.0/2.4));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float size = 5.;\nfloat map(vec2 p){\n    float d = length(p-vec2(.5,-.0))-.1;\n    p*=size;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return min(d,-length(p)*sign(p.y)/size);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 grad(vec2 p){\n    vec2 e = vec2(1e-3,0);\n    return normalize(map(p)-vec2(map(p-e),map(p-e.yx)));\n}\n\n/* //low dispersion glass for comparison\nfloat sellmeier(float wl, float b1, float b2, float b3, float c1, float c2, float c3){\n    float l = wl*1e-3;\n    l = wl*wl;\n    float s =1.+ b1*l/(l-c1)+b2*l/(l-c2)+b3*l/(l-c3);\n    \n    return sqrt(max(s,0.));\n    \n}\n\nfloat iorGlass(float wl){ //https://refractiveindex.info/?shelf=glass&book=BK7&page=SCHOTT\n    return sellmeier(wl,1.03961212,0.231792344,1.01046945,.00600069867,.0200179144,103.560653);\n}*/\n\n//high dispersion cristal\nfloat iorGlass(float wl){//https://refractiveindex.info/?shelf=glass&book=OHARA-TIH&page=TIH6\n    float l = wl*wl*1e-4;\n    return sqrt(3.1200483-0.012774901*l+0.042416181/l+0.0025526467/(l*l)-0.00011907015/(l*l*l));\n}\n\nfloat seed;\nint base;\nconst int primes[25] = int[](2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n\nfloat haltonSeq(int i) {\n    #define PERIOD 1024\n    const float phi = .5+.5*sqrt(5.);//\"most irrational\" number\n   \tfloat off = fract(phi*float((base+1)*(i/PERIOD)));\n    i=int((i%PERIOD));\n    int b=primes[base++%25];\n\t\tfloat r = 0.;\n    float f = 1.;\n    while(i>0){\n        r += (f/=float(b))*float((i%b));\n        i = i/b;\n    }\n    return fract(r+off); \n}\n\nfloat hash()\n{\n    return fract(seed+float(iFrame+base++)*(.5+.5*sqrt(5.)));\n}\n\n\nmat3x2 min32(mat3x2 a,mat3x2 b){\n    return mat3x2(min(a[0],b[0]),min(a[1],b[1]),min(a[2],b[2]));\n}\n\nmat3x2 max32(mat3x2 a,mat3x2 b){\n    return mat3x2(max(a[0],b[0]),max(a[1],b[1]),max(a[2],b[2]));\n}\nmat3x2 abs32(mat3x2 a){\n    return mat3x2(abs(a[0]),abs(a[1]),abs(a[2]));\n}\nmat2x3 sq23(mat2x3 a){\n   return mat2x3(a[0]*a[0],a[1]*a[1]);\n}\n\nvec3 eq3(vec3 x, vec3 y){\n    vec3 d = x-y;\n    return step(vec3(0),d*d-vec3(.00001));\n}\n\nmat2x3 intersect3(mat3x2 ro, mat3x2 rd, mat3x2 box){\n    // axis-aligned 2d boxes intersection\n    mat3x2 tmin = -ro/rd;\n    mat3x2 tmax = (box-ro)/rd;\n    mat2x3 t1 = transpose(min32(tmin,tmax));\n    mat2x3 t2 = transpose(max32(tmin,tmax));\n    return mat2x3(max(t1[0],t1[1]),min(t2[0],t2[1]));\n}\n\nvec3 hitarea3(mat3x2 p1, mat3x2 p2, mat3x2 box, vec2 n){\n    \n    mat2x3 diff = transpose(abs32(p1-p2));\n    vec3 triarea = diff[0]*diff[1]/2.;\n    \n    mat2x3 p1n = transpose(p1/box),p2n = transpose(p2/box);\n    mat2x3 p1ns = sq23(p1n),p2ns = sq23(p2n);\n    \n    vec3 quadx = eq3(p1ns[0],p1n[0]) * eq3(p2ns[0],p2n[0]);\n    vec3 quady = eq3(p1ns[1],p1n[1]) * eq3(p2ns[1],p2n[1]);\n    vec3 quad = max((quadx) + (quady),1.);\n        \n    vec2 sn = -sign(n);\n    mat2x3 boxt = transpose(box);\n    vec3 boxarea = boxt[0]*boxt[1];\n    \n    p1 = min32(p1,box-p1);\n    p2 = min32(p2,box-p2);\n    \n    p1 = mat2(box[0].y,0,0,box[0].x)*min32(p1,p2);\n    \n    mat2x3 p1t = transpose(p1);\n\n    vec3 quadarea = triarea + (mix(p1t[0],p1t[1],quady));\n        \n    vec3 area = mix(triarea,quadarea,quad);\n    return area;\n}\n\nvec3 edgeIntegral3(mat3x2 lo, vec2 ln, vec2 box){\n    vec2 ld = vec2(-ln.y,ln.x);\n    \n    mat3x2 box3 = mat3x2(box,box,box);\n    mat3x2 ld3 = mat3x2(ld,ld,ld);\n     mat2x3 i = intersect3(lo,ld3,box3); \n       \n    mat3x2 p1 = lo+ld3*mat3(i[0].x,0,0,0,i[0].y,0,0,0,i[0].z);\n    mat3x2 p2 = lo+ld3*mat3(i[1].x,0,0,0,i[1].y,0,0,0,i[1].z);\n    \n    float boxarea = box.x*box.y;\n\n    vec3 hit = step(vec3(0),(i[1]-i[0]));\n    \n    vec3 area = hit*hitarea3(p1,p2,box3,ln);\n    area/=boxarea;\n    \n    area = mix(area,1.-area,step(ln*(box3*.5-lo),vec3(0.)));\n    \n    return area;\n}\n\n\nvec3 lineAA3(mat3x2 origin,vec2 orth,vec2 subpixelSize){\n    mat3x2 orth3 = mat3x2(orth,orth,orth);\n    origin-=orth3;\n    vec3 pxarea = edgeIntegral3(origin,orth,subpixelSize);\n\n    origin += 2.*orth3;\n\n    pxarea += edgeIntegral3(origin,-orth,subpixelSize);\n    return 1.-pxarea;\n}\n\nvec3 lineSPAA(vec2 origin,vec2 orth,vec2 subpixelSize){\n    //https://www.shadertoy.com/view/csjyRm\n    const vec3 LAYOUT_RGB = vec3(0.,1./3.,2./3.);\n    const vec3 LAYOUT_BGR = LAYOUT_RGB.bgr;\n    \n    const bool LAYOUT_VERTICAL = false;\n    \n    vec3 subpixel_layout = LAYOUT_RGB;\n    if(LAYOUT_VERTICAL) subpixelSize=subpixelSize.yx;\n    vec3 col = vec3(0.);\n\n    mat3x2 subpixelOffsets = LAYOUT_VERTICAL?\n        mat3x2(0,subpixel_layout.r,0,subpixel_layout.g,0,subpixel_layout.b):\n        mat3x2(subpixel_layout.r,0,subpixel_layout.g,0,subpixel_layout.b,0);\n    \n    mat3x2 pxros = subpixelOffsets + mat3x2(origin,origin,origin);\n\n    return lineAA3(pxros,orth,subpixelSize);\n}\n\nvec3 segmentSPAA(vec2 fragCoord, vec2 origin, vec2 end){\n    vec2 dir = end-origin;\n    vec2 orth = normalize(dir.yx)*vec2(1,-1)*.5;\n    \n    const vec2 subpixelSize = vec2(1./3.,1.);\n    vec2 pro = fragCoord-origin;\n    vec3 col = lineSPAA(pro,orth,subpixelSize) * float(dot(pro,dir)>=0. && dot(pro+origin-end,dir)<0.);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x-vec2(-0.2,0.0);\n    \n    vec4 bn = texture(iChannel1,fragCoord/iChannelResolution[1].xy);\n    \n    seed = 0.;// (bn.r*255.+bn.g)/256.;\n    //dithering adds too much divergence and lowers the performance, so i discarded it\n    base = 0;\n    vec2 lo = vec2(-1,-.7);\n    vec2 ld = normalize(vec2(1,.8));\n   \n    \n    float wl = 200.+700.*hash();\n    \n    vec3 l = spectrum_to_rgb(wl)*blackbody(wl,4000.)*.0000000001;\n    vec3 col = vec3(0);\n    for(int i=0;i++<2000;){\n        vec2 lop = lo;\n        float d = map(lo);\n        if(abs(d)<1e-4){\n            l*=.999;\n            vec2 n = grad(lo)*sign(d);\n            float ind = iorGlass(wl);\n            if(d>0.)\n                ind=1./ind;\n            vec2 rd = normalize(refract(ld,n,ind));\n            \n            float cti = dot(ld,n),ctt = dot(rd,n);\n            float fresnel = (cti-ind*ctt)/(cti+ind*ctt);\n            fresnel*=fresnel;\n            float fresnel2 = (ind*ctt-cti)/(cti+ind*ctt);\n            fresnel =clamp(.5*(fresnel+fresnel2*fresnel2),0.,1.);\n            \n           \tif(hash()<fresnel){\n                rd = reflect(ld,n);\n               \tlo+=2e-4*n;\n            }else{\n                lo-=2e-4*n;\n            }\n            ld=rd;\n            \n        }else{\n        \tlo+=abs(d)*ld;\n            /*\n            if(sign(d)<0.)\n            \tl*=exp2(-4.*abs(d));\n\t\t\t*/\n        }\n        vec2 plo = ((lo+vec2(-0.2,0.0))*iResolution.x+iResolution.xy)*.5;\n        vec2 plop = ((lop+vec2(-0.2,0.0))*iResolution.x+iResolution.xy)*.5;\n        col=max(\n        l*segmentSPAA(fragCoord,plo,plop)\n        ,col);\n        if(dot(lo,lo)>4.||dot(l,l)<.0000001)\n            break;\n    }\n    \n    \n    fragColor = texture(iChannel0,fragCoord/iResolution.xy)\n        +vec4(col+0.1*smoothstep(3./iResolution.x,0.,abs(map(uv))-.002),1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float red(float wl){\n    float a = 0.;\n    float b1 = wl-440.;\n    a+=exp2(-b1*b1*.004)*.3;\n    float b2 = wl-600.;\n\ta+=exp2(-b2*b2*(1.-sign(b2)*.4)*.001)*2.5;\n    return a;\n}\n\nfloat green(float wl){\n    float a = 0.;\n    float b1 = wl-540.;\n    a+=exp2(-b1*b1*.0008)*1.5;\n    return a;\n}\n\nfloat blue(float wl){\n    float a = 0.;\n    float b1 = wl-450.;\n    a+=exp2(-b1*b1*.0015)*2.;\n    return a;\n}\n\n\nfloat blackbody(float wl, float T){\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n   \twl*=1e-9;\n    return  2.*h*(c*c)/(wl*wl*wl*wl*wl*(exp(h*c/(T*wl*k))-1.));\n}\n\nvec3 getRGB(float wl){\n    return vec3(red(wl),green(wl),blue(wl));\n}\nfloat gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y/=y<0.?s1:s2;\n    return al*exp(-y*y*.5);\n}\n\n\nvec3 lambdatoXYZ(float wl){\n    return vec3( gaussian(wl, 1.056, 599.8, 37.9, 31.0)+gaussian(wl, 0.362, 442.0, 16.0, 26.7)+ gaussian(wl, -0.065, 501.1, 20.4, 26.2)\n                ,gaussian(wl, 0.821, 568.8, 46.9, 40.5)+gaussian(wl,0.286, 530.9, 16.3, 31.1)\n                ,gaussian(wl, 1.217, 437.0, 11.8, 36.0)+gaussian(wl, 0.681, 459.0, 26.0, 13.8));\n}\nconst mat3 xyz = mat3(\n\t3.240479, -1.537150, -0.498535,\n    -0.969256, 1.875992, 0.041556,\n    0.055648, -0.204043, 1.057311);\n\nvec3 spectrum_to_rgb(in float w){\n    return lambdatoXYZ(w)*xyz;\n}\n\nfloat bayer2(vec2 v)\n{\n    v=floor(v);\n return fract(v.y*v.y*.75+v.x*.5);   \n}\nfloat bayer4(vec2 v)\n{\n    return bayer2(.5*v)*.25+bayer2(v);\n}\nfloat bayer8(vec2 v)\n{\n    return bayer4(.5*v)*.25+bayer2(v);\n}\nfloat bayer16(vec2 v)\n{\n    return bayer8(.5*v)*.25+bayer2(v);\n}\nfloat bayer32(vec2 v)\n{\n    return bayer16(.5*v)*.25+bayer2(v);\n}\nfloat bayer64(vec2 v)\n{\n    return bayer32(.5*v)*.25+bayer2(v);\n}\nfloat bayer128(vec2 v)\n{\n    return bayer64(.5*v)*.25+bayer2(v);\n}","name":"Common","description":"","type":"common"}]}