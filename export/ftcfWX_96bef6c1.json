{"ver":"0.1","info":{"id":"ftcfWX","date":"1663788262","viewed":138,"name":"Flight of Marched Voxels!","username":"PrenexNormalForm","description":"Ray marcher specifically designed for solid voxel grids, avoids needing to compute a comparatively expensive sdf","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    Marches a ray one space at a time in a voxel grid while testing\n    for intersections, rather than using a signed distance field\n    \n    returns the distance to intersection\n*/\nmat3 voxelMarch(vec3 startPos, vec3 ray);\nint voxelTypeAt(vec3 pos);\n\nconst float MAX_DISTANCE = 128.;\n\n//for camera path calculus\nconst float OFFSET = 1.;\n\nconst int VOXEL_AIR = 0;\nconst int VOXEL_GROUND = 1;\nconst int VOXEL_FLOATIE1 = 2;\nconst int VOXEL_FLOATIE2 = 3;\nconst int VOXEL_FLOATIE3 = 4;\nconst int VOXEL_FLOATIE4 = 5;\nconst int VOXEL_FLOATIE5 = 6;\nconst vec3[] VOXEL_COLOR = vec3[] (\n    vec3(0.),\n    vec3(0.05,0.4,0.05),\n    vec3(0.4, 0.05, 0.7),\n    vec3(0.8, 0.8, 0.05),\n    vec3(0.8, 0.05, 0.05),\n    vec3(0.02, 0.5, 0.9),\n    vec3(0.9, 0.25, 0.6)\n);\n\n//helpers\nfloat lenSq(vec3 vec) {return dot(vec,vec);}\nfloat lenSq(vec2 vec) {return dot(vec,vec);}\nfloat lenSq(float vec) {return vec*vec;}\n\n//returns matrix with vectors: pos, normal, voxel\nmat3 voxelMarch(vec3 startPos, vec3 ray)\n{\n    vec3 pos = startPos;\n    float dist = 0.;\n    vec3 normal = vec3(0);\n    \n    vec3 nextBoundaries = vec3(0.);\n    vec3 boundaryDists;\n    nextBoundaries.x = float(ray.x >= 0.) * ceil(startPos.x) + float(ray.x < 0.) * floor(startPos.x);\n    nextBoundaries.y = float(ray.y >= 0.) * ceil(startPos.y) + float(ray.y < 0.) * floor(startPos.y);\n    nextBoundaries.z = float(ray.z >= 0.) * ceil(startPos.z) + float(ray.z < 0.) * floor(startPos.z);\n    boundaryDists = (nextBoundaries - startPos) / ray;\n    vec3 voxel = vec3(0);\n    \n    for (int i = 0; i < int(2. * MAX_DISTANCE); i++)\n    {\n        float minDist = min(boundaryDists.x, min(boundaryDists.y, boundaryDists.z));\n        if (boundaryDists.x == minDist)\n        {\n            nextBoundaries.x += sign(ray.x);\n            pos += ray * boundaryDists.x;\n            dist += boundaryDists.x;\n            normal = vec3(-sign(ray.x),0.,0.);\n        }\n        else if (boundaryDists.y == minDist)\n        {\n            nextBoundaries.y += sign(ray.y);\n            pos += ray * boundaryDists.y;\n            dist += boundaryDists.y;\n            normal = vec3(0.,-sign(ray.y),0.);\n        }\n        else\n        {\n            nextBoundaries.z += sign(ray.z);\n            pos += ray * boundaryDists.z;\n            dist += boundaryDists.z;\n            normal = vec3(0.,0.,-sign(ray.z));\n        }\n        voxel = pos - normal / 2.;\n        boundaryDists = (nextBoundaries - pos) / ray;\n        if (dist > MAX_DISTANCE + 1. || bool(voxelTypeAt(voxel))) break;\n    }\n    \n    return mat3(pos, normal, voxel);\n}\n\nvec3 shadeScene(vec3 cameraPos, mat3 march)\n{\n    float dist = distance(cameraPos, march[0]);\n    int voxelType = voxelTypeAt(march[2]);\n    \n    //sky\n    vec3 skyColor = vec3(0.2, 0.6, 0.9);\n    vec4 color = vec4(0.);\n    if (dist < MAX_DISTANCE)\n    {\n        //surface\n        color.rgb = VOXEL_COLOR[voxelType];\n        vec3 sunRay = normalize(vec3(0.7, 1.0, 0.8));\n        bool sunlit = distance(voxelMarch(march[0], sunRay)[0], march[0]) >= MAX_DISTANCE;\n        float light = max(0.0, float(sunlit) * dot(march[1], sunRay));\n        //ambient light\n        light = 0.8 * light + 0.2 * (0.8 + 0.2 * dot(march[1], sunRay));\n        color *= light;\n        color.a = 1. - smoothstep(0.8 * MAX_DISTANCE, MAX_DISTANCE, dist);\n    }\n    //alpha blend color over sky color\n    return color.a * color.rgb + (1. - color.a) * skyColor;\n}\n\n// rand function https://www.shadertoy.com/view/Xt23Ry\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nint voxelTypeAt(vec3 pos)\n{\n    pos = floor(pos);\n    bool voxel = false;\n    if (pos.y < -10. + 6. * cos(pos.x / 5.) * sin(pos.x / 7. +  pos.z / 13.))\n        return VOXEL_GROUND;\n    float random = rand(pos);\n    float random2 = rand(5.*pos + vec3(43.));\n    if (random > 0.00 && random < 0.002)\n        return VOXEL_FLOATIE1 + int(5. * random2);\n    \n    return VOXEL_AIR;\n}\n\nvec3 cameraPosition(float time)\n{\n    vec3 pos = 120. * vec3(2.*cos(time / 10.), 0., -sin(time / 5.));\n    pos.xz += vec2(-30.*cos(time / 3.), 3.*sin(time / 3.));\n    pos.y = 4. + 7. * sin(time / 4.);\n    return pos;\n}\n\nvec3 fragCoordToRay(float fov, vec2 fragCoord)\n{\n    float halfFOV = radians(fov) / 2.0;\n    float viewPlaneScale = tan(halfFOV);\n    vec2 centeredFragCoord = fragCoord - iResolution.xy * 0.5;\n    vec2 viewPlaneCoord = centeredFragCoord / iResolution.xx * 2.0;\n    vec3 ray = vec3(viewPlaneCoord * viewPlaneScale, -1.0);\n    return normalize(ray);\n}\n\nvoid rotateCameraRay(inout vec3 ray, float yaw, float pitch, float roll)\n{\n    mat2 yawMatrix = mat2(cos(yaw),sin(yaw),-sin(yaw),cos(yaw));\n    mat2 pitchMatrix = mat2(cos(pitch),sin(pitch),-sin(pitch),cos(pitch));\n    mat2 rollMatrix = mat2(cos(roll),sin(roll),-sin(roll),cos(roll));\n    \n    ray.xy *= rollMatrix;\n    ray.yz *= pitchMatrix;\n    ray.xz *= yawMatrix;\n}\n\n//from https://www.shadertoy.com/view/lscSzl\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = cameraPosition(iTime);\n    vec3 cameraPathT = cameraPosition(iTime + OFFSET) - cameraPos;\n    float cameraSpeed = length(cameraPathT);\n    cameraPathT = normalize(cameraPathT);\n    vec2 cameraPathxzT = normalize(cameraPathT.xz);\n    vec2 cameraPathxzK = (cameraPathxzT - normalize(cameraPos.xz - cameraPosition(iTime - OFFSET).xz)) / OFFSET;\n    float cameraYaw = acos(-cameraPathxzT.y) * -sign(cameraPathT.x);\n    float cameraPitch = -asin(cameraPathT.y);\n    vec3 cameraRay =  fragCoordToRay(80. + 0.5*cameraSpeed / OFFSET, fragCoord);\n    float curveDirection = cross(vec3(cameraPathxzT.x,0.,cameraPathxzT.y), normalize(vec3(cameraPathxzK.x,0.,cameraPathxzK.y))).y;\n    rotateCameraRay(cameraRay, cameraYaw, cameraPitch, 1.*length(cameraPathxzK)*-curveDirection);\n    //cameraRay.z *= -1.;\n    mat3 march = voxelMarch(cameraPos, cameraRay);\n    vec3 col = shadeScene(cameraPos, march);\n\n    // Output to screen\n    fragColor = vec4(encodeSRGB(col),1.0);\n}","name":"Image","description":"","type":"image"}]}