{"ver":"0.1","info":{"id":"4dGGzy","date":"1454974416","viewed":165,"name":"Light on Plates","username":"samuelotherion","description":"Light on Plates","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lightonplates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE  1000000000.\n#define _t_           iTime\n#define I3            mat3( +1., +0., +0.,  +0., +1., +0.,  +0., +0., +1. )\n#define NUM_OF_OBJS_X 3\n#define NUM_OF_OBJS_Y 3\n#define NUM_OF_OBJS   ( NUM_OF_OBJS_X * NUM_OF_OBJS_Y )\nprecision lowp float;\n\nstruct Loc { vec3 pos, ext; mat3 xyz; };\nstruct Inp { vec3 eye, ray; };\nstruct Out { vec3 pnt, nrm, col; float dst; };\nstruct Scn { Inp  inp; Loc loc[ NUM_OF_OBJS ]; };\n    \nScn\n    scn;\n\nInp\n    inp;\n\nOut\n    outp;\n\nint\nmb( in vec2 p_ri ) {\n\n    vec2\n    c = p_ri;\n    \n    float\n    tmpR;\n    \n    for( int i = 0; i < 255; i++ ) {\n    \n        tmpR = c.x;\n        \n    \tc.x = c.x * c.x - c.y * c.y - p_ri.x; \n    \tc.y = 2. * tmpR * c.y - p_ri.y;\n        \n        if( 16. < c.x * c.x + c.y * c.y ) {\n        \n        \treturn i;\n        }\n    }\n    \n    return 255;\n}\n\n/*mat3\n    transpose( in mat3 p_m ) {\n        \n        return mat3( p_m[ 0 ][ 0 ], p_m[ 1 ][ 0 ], p_m[ 2 ][ 0 ], p_m[ 0 ][ 1 ], p_m[ 1 ][ 1 ], p_m[ 2 ][ 1 ], p_m[ 0 ][ 2 ], p_m[ 1 ][ 2 ], p_m[ 2 ][ 2 ] );\n    }\n*/\nmat3\n    crss( in vec3 p_vecLHS ) {\n        \n        return mat3( +0., -p_vecLHS.z, +p_vecLHS.y, +p_vecLHS.z, +0., -p_vecLHS.x, -p_vecLHS.y, +p_vecLHS.x, +0. );\n    }\n\nmat3\n    parallel( in vec3 p_axeN ) {\n        \n        return mat3( p_axeN.x * p_axeN, p_axeN.y * p_axeN, p_axeN.z * p_axeN );\n    }\n\nvec3\n    parallel( in vec3 p_axeN, in vec3 p_vec ) {\n        \n        return dot( p_axeN, p_vec ) * p_axeN;\n    }\n\nmat3\n    orthogonal( in vec3 p_axeN ) {\n        \n        return I3 - parallel( p_axeN );\n    }\n\nvec3\n    orthogonal( in vec3 p_axeN, in vec3 p_vec ) {\n        \n        return p_vec - parallel( p_axeN, p_vec );\n    }\n\nmat3\n    rot( vec3 p_axe, float p_alpha ) {\n        \n        vec3\n            n = normalize( p_axe );\n        \n        return parallel( n ) + cos( p_alpha ) * orthogonal( n ) + sin( p_alpha ) * crss( n );\n    }\n\nvec3\n    rot( in vec3 p_axe, in vec3 p_vec, float p_alpha ) {\n        \n        vec3\n            n = normalize( p_axe ),\n            p = dot( n, p_vec ) * n;\n        \n        return p + cos( p_alpha ) * ( p_vec - p ) + sin( p_alpha ) * cross( n, p_vec );\n    }\n\nvoid\n    setOutput( in vec3 p_pnt, in vec3 p_norm, in vec3 p_col ) {\n        \n        vec3\n            dist = p_pnt - inp.eye;\n        \n        float\n            distSqr = dot( dist, dist );\n        \n        if( distSqr < outp.dst ) {\n        \n            outp.pnt = p_pnt;\n            outp.nrm = p_norm;\n            outp.col = p_col;\n        \toutp.dst = distSqr;\n        }\n    }\n\nvoid\n    intersectBox( in Loc p_loc ) {\n    \n        vec3\n            eye = inp.eye - p_loc.pos,\n            rog = orthogonal( -inp.ray, -eye );\n\n        float\n            de = dot( p_loc.ext, p_loc.ext ),\n            dr = dot( rog, rog );\n        \n        if( de < dr ) return;\n\n        vec3\n            eyeXYZ = p_loc.xyz * eye,\n            rayXYZ = p_loc.xyz * inp.ray,\n            front  = ( eyeXYZ - sign( eyeXYZ ) * p_loc.ext ) / rayXYZ;\n           \n        vec3\n            pxf = eyeXYZ - front.x * rayXYZ,\n            pyf = eyeXYZ - front.y * rayXYZ,\n            pzf = eyeXYZ - front.z * rayXYZ;\n        \n//        if( all( lessThan( abs( pxf.yz ), p_loc.ext.yz ) ) ) setOutput( pxf * p_loc.xyz + p_loc.pos, -sign( eyeXYZ.x ) * p_loc.xyz[ 0 ], mix( texture( iChannel0, pxf.yz ).rgb, vec3( 1.0, 0.8, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n//        if( all( lessThan( abs( pyf.zx ), p_loc.ext.zx ) ) ) setOutput( pyf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.y ) * p_loc.xyz[ 1 ], mix( texture( iChannel0, pyf.zx ).rgb, vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n//        if( all( lessThan( abs( pzf.xy ), p_loc.ext.xy ) ) ) setOutput( pzf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.z ) * p_loc.xyz[ 2 ], mix( texture( iChannel0, pzf.xy ).rgb, vec3( 0.8, 0.8, 1.0 ), .5 + .5 *sin( .3 * _t_ ) ) );\n        if( all( lessThan( abs( pxf.yz ), p_loc.ext.yz ) ) ) setOutput( pxf * p_loc.xyz + p_loc.pos, -sign( eyeXYZ.x ) * p_loc.xyz[ 0 ], mix( texture( iChannel0, pxf.yz ).rgb, vec3( 1.0, 0.8, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n        if( all( lessThan( abs( pyf.zx ), p_loc.ext.zx ) ) ) setOutput( pyf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.y ) * p_loc.xyz[ 1 ], mix( texture( iChannel0, pyf.zx ).rgb, vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n        if( all( lessThan( abs( pzf.xy ), p_loc.ext.xy ) ) ) {\n            \n            float\n                c = cos( .2 * _t_ ),\n                s = sin( .2 * _t_ );\n            \n            mat2\n                rotMB = mat2( c, -s, s, c );\n            \n//            setOutput( pzf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.z ) * p_loc.xyz[ 2 ], mix( texture( iChannel0, pzf.xy ).rgb, float( 255 - mb( rotMB * ( rotMB * ( pzf.xy / vec2( 1., p_loc.ext.x ) + vec2( +.8, .0 ) ) * vec2( 1., p_loc.ext.x ) - vec2( +.8, .0 )  ) * ( 3. + 2. * sin( .9 * _t_ ) ) ) ) / 255. * vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ) );\n              setOutput( pzf * p_loc.xyz + p_loc.pos, +sign( eyeXYZ.z ) * p_loc.xyz[ 2 ], mix( mix( texture( iChannel0, pzf.xy ).rgb, float( 255 - mb( inp.ray.xy *  ( 3. + sin( .12 * _t_ ) ) ) )  * ( 3. + 2. * sin( .23 * _t_ ) ) / 255. * vec3( 0.8, 1.0, 0.8 ), .5 + .5 *sin( .3 * _t_ ) ), float( mb( rotMB * ( rotMB * ( pzf.xy / vec2( 1., p_loc.ext.x ) ) ) * ( 3. + 2. * sin( .9 * _t_ ) ) ) ) / 255. * vec3( 1.0, 0.0, 0. ), .5 + .5 * sin( .73 * _t_ ) ));\n        }\n    }\n\nvec4\n    intersect( ) {\n    \n        outp = Out( vec3( 0., 0., -MAX_DISTANCE ), vec3( 0., 0., 1. ), vec3( .1, .1, .1 ), MAX_DISTANCE * MAX_DISTANCE );\n        \n        for( int i = 0; i < NUM_OF_OBJS; i++ ) {\n            \n            intersectBox( scn.loc[ i ] ); \n        }\n        \n        vec3\n            lit = vec3( 2. * sin( sin( _t_ ) ), -1. * cos( sin( _t_ ) ), 0.75 ) - outp.pnt;\n        \n        return vec4( outp.col * clamp( 2.75 * dot( lit, outp.nrm ) / dot( lit, lit ), 0., 1. ) , 1. );\n    }\n\nvoid\n    init( vec2 p_xy ) {\n        \n        mat3\n            rotAxe = rot( vec3( 0., 2. * cos( 2. * _t_ ), sin( 2. * _t_ ) ), 2. * 3.14 * pow( sin( _t_ / 6.283 ), 19. ) );\n        \n        vec3\n            xy0   = vec3( vec2( p_xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. ), 1. ),\n            eye  = vec3( 0., 0., 2. );\n        \n        inp = Inp( eye, normalize( eye - xy0 ) );\n        \n        vec3\n            ext = vec3( iResolution.xy / iResolution.x, .05 ),\n            pos0 = vec3( vec2( float( 1 - NUM_OF_OBJS_X ), float( 1 - NUM_OF_OBJS_Y ) ) * ext.xy, -1.44 ),\n            pos = pos0;\n        \n        vec2\n            dxy = 2. * ext.xy;\n        \n\t\tfor( int y = 0; y < NUM_OF_OBJS_Y; y++ ) {\n        \n        \tfor( int x = 0; x < NUM_OF_OBJS_X; x++ ) {\n        \n            \tscn.loc[ y * NUM_OF_OBJS_X + x ] = Loc( pos, ext, rotAxe );\n            \n                pos.x += dxy.x;\n            }\n            \n            pos.x = pos0.x;\n            pos.y += dxy.y;\n        }\n    }\n\nvoid\n    mainImage( out vec4 p_c, in vec2 p_xy ) {\n        \n        init( p_xy );\n       \n        p_c = intersect( );\n       \n    }","name":"Image","description":"","type":"image"}]}