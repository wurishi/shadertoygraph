{"ver":"0.1","info":{"id":"ftsXDB","date":"1626453789","viewed":78,"name":"Not Earth","username":"yunhai","description":"i'm try getting control of this wave, but it needs too much parameters and adjust to get a okey performence i think.\nand now it has been a mess.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["casual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOW_MARCH_STEPS\n#define iR iResolution.xy\n#define iT iTime\nconst float MAX_DIST=100.;\nconst float INV_MAX_DIST=.01;\nconst float MIN_DIST=1e-5;\nconst float MAX_STEP=60.;\nfloat tsin(float t){return pow(1.-abs(sin(t)),1.);}\nfloat tcos(float t){return pow(1.-abs(cos(t)),1.);}\nfloat hash21(vec2 uv,float t)\n{return fract(121.*(sin(uv.x*121.)+cos(uv.y*121.)));}\nfloat weight(vec3 p,float t)//to get some random\n{\n    vec2 e=vec2(0,1);\n    vec2 f=floor(p.xz),cf=p.xz-f;\n    float a=hash21(f,t),\n          b=hash21(f+e.yx,t),\n          c=hash21(f+e.xy,t),\n          d=hash21(f+e.yy,t);\n\n    cf=cf*cf*(3.-2.*cf);\n    a=mix(a,b,cf.x);\n    b=mix(c,d,cf.x);\n    return mix(a,b,cf.y);\n}\nfloat sw(vec3 p)//tip wave\n{\n    float s=tsin(p.x),c=tcos(p.z);\n    float wav=3.*s*s*s+2.*c*c;\n    return wav;\n}\nfloat fbmwave(vec3 p)\n{\n    float t=iT*2.;\n    mat2 rot=getRot(10.);\n    float det=0.,rate=1.;//detail\n    p*=.5;\n    for(float i=0.;i<5.;i++)\n    {\n        rate*=2.;\n        det+=sw(p*rate+t)/rate;\n        p+=vec3(3.);\n        p.xz*=rot;\n    \n    }\n    float wei=weight(p*2.,t)*2.;//weight\n    float bw=(sin((p.x+p.y)*(2.+wei*.01)+t*2.)*2.+4.)*.2;\n    bw*=bw;//big wave\n    return det*wei*bw;\n}\nfloat sdf(vec3 p,out int id)\n{\n    float sea=p.y+1.-.4*fbmwave(p*.3);\n    float sky=length(p+vec3(0,20,0))-50.;sky=-sky;\n    id=sea<sky?1:2;\n    return min(sea,sky);\n}\nvec3 getNormal(vec3 p)\n{\n    vec2 of=vec2(1e-1,0);\n    int t;\n    float a=sdf(p,t);\n    if(t==2) return normalize(vec3(0,-20,0)-p);\n    return normalize(vec3(sdf(p+of.xyy,t)-a,\n                          sdf(p+of.yxy,t)-a,\n                          sdf(p+of.yyx,t)-a));\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n   \n    vec2 uv = (C-.5*iR)/iR.y;\n    vec3 ro=vec3(0,1,-9)+20.*vec3(sin(iT),0,cos(iT)),\n    lookat=vec3(0,1,0)+3.*vec3(0,sin(iT),0),\n    camf=normalize(lookat-ro),\n    camr=cross(vec3(0,1,0),camf),\n    camu=cross(camf,camr);\n    vec3 rd=normalize(uv.x*camr+uv.y*camu+camf);\n    float t=0.;\n    int id;\n    float i=0.;\n    for(;i<MAX_STEP;++i)\n    {\n        float d=sdf(ro+t*rd,id);\n        t+=d;//*(t*INV_MAX_DIST*3.+1.);\n        if(abs(d)<MIN_DIST||t>MAX_DIST)\n            break;\n    }\n    if(t>MAX_DIST)\n        t=MAX_DIST;\n    vec3 pos=ro+t*rd;\n    vec3 nml=getNormal(pos);\n    vec3 col;\n    vec3 lp=vec3(0,25,20);\n    vec3 ld=normalize(lp-pos);\n    if(t<MAX_DIST&&t>0.)\n    {\n        if(id==1)\n        {\n            float fresnel=1.+pow(1.+dot(rd,nml),10.);\n            vec3 diff=vec3(.1,.2,.7)*3.*max(0.,\n            dot(nml,normalize(lp-pos)));\n            vec3 spec=vec3(1)*pow(dot(nml,(-rd+ld)*.5),10.);\n            col=diff*fresnel+spec;\n        }\n        else\n        {\n            float a=1./(pos.y*.035+2.);\n            a=a*a*a*12.;\n            vec3 sunset=vec3(a,a*a*a,a*a*a*a*a)\n                *pow(max(0.,dot(rd,vec3(0,0,1))),7.)*.7;\n            float b=(pos.y*.1+23.)/110.;\n            b=b*b*b*60.;\n            vec3 sky=vec3(b*b*b*b*b,b*b*b,b);\n            col=sunset+sky;\n        }\n        \n    }\n#ifdef SHOW_MARCH_STEPS\n    O.rgb=mix(vec3(.2,.9,.3),vec3(1,.2,.2),vec3(i/MAX_STEP));\n#else\n    O.rgb=col;\n#endif\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 getRot(float a)\n{\n    a*=3.1415/180.;\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}","name":"Common","description":"","type":"common"}]}