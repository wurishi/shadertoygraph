{"ver":"0.1","info":{"id":"ll3XDB","date":"1481412062","viewed":210,"name":"YA Apollonian Gasket","username":"rwoodley","description":"debugging","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mobiusapollonian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"     vec2 one = vec2(1.0, 0.0);\n    vec2 zero = vec2(0.0, 0.0);\n    vec2 i = vec2(0., 1.);\n \n        // ====== Math Utils =======\n\n    #define PI 3.1415926535897932384626433832795\n    #define cx_product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n    #define cx_conjugate(a) vec2(a.x,-a.y)\n    #define cx_divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n    // emulate OpenGL 4.5's mix(,,bool)\n    float mix(float x, float y, bool a) {\n        return a ? y : x;\n    }\n    //#define cx_abs(a) sqrt(a.x*a.x + a.y*a.y)\n    #define cx_modulus(a) length(a)\n    #define cx_conj(a) vec2(a.x,-a.y)\n    #define cx_arg(a) atan2(a.y,a.x)\n\n    float atan2(in float y, in float x) {\n        // http://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle\n        bool s = (abs(x) >= abs(y));\n        float res = mix(PI/2.0 - atan(x,y), atan(y,x), s);\n        return res;\n    }\n    // https://github.com/julesb/glsl-util/blob/master/complexvisual.glsl\n    vec2 cx_sqrt(vec2 a) {\n        float r = sqrt(a.x*a.x+a.y*a.y);\n        float rpart = sqrt(0.5*(r+a.x));\n        float ipart = sqrt(0.5*(r-a.x));\n        if (a.y < 0.0) ipart = -ipart;\n        return vec2(rpart,ipart);\n    }\n    vec2 cx_log(vec2 a) {\n        float rpart = sqrt((a.x*a.x)+(a.y*a.y));\n        float ipart = atan2(a.y,a.x);\n        if (ipart > PI) ipart=ipart-(2.0*PI);\n        return vec2(log(rpart),ipart);\n    }\n    vec2 cx_exp(vec2 z) {\n        return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n    }\n    vec2 cx_pow(vec2 z, vec2 y) {\n        return  cx_exp(cx_product(y, cx_log(z)));\n\n    }\n    vec3 complexToCartesian(vec2 c) {\n        float denom = 1.0 + c.x*c.x + c.y*c.y;\n        float x = 2.*c.x/denom;\n        float y = 2.*c.y/denom;\n        float z = (c.x*c.x + c.y*c.y - 1.0)/denom;\n        return vec3(x,y,z);\n    }\n// ====== Transformation Code\n// xform is a mobius transform.\nstruct xform { vec2 a; vec2 b; vec2 c; vec2 d; };\n\nxform xformCtor(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    xform x;\n    x.a = a; x.b = b; x.c = c; x.d = d;\n    return x;\n}\nxform inverseXformCtor(xform x) {\n    return xformCtor(x.d,-x.b,-x.c,x.a);\n}\nvec2 applyMobiusTransformation(in vec2 z, in xform t) {\n    vec2 top = cx_product(z,t.a)+t.b;\n    vec2 bottom = cx_product(z,t.c)+t.d;\n    return cx_divide(top,bottom);\n}\nvec2 applyInverseMobiusTransformation(in vec2 z, xform x) {\n    // inverse is (dz-b)/(-cz+a).\n    return applyMobiusTransformation(z,xformCtor(x.d,-x.b,-x.c,x.a));\n}\nvec2 transformForFixedPoints(in vec2 z, in vec2 e1, in vec2 e2) {\n    return applyMobiusTransformation(z,xformCtor(one,-e1,one,-e2));\n}\nvec2 bobMobius(in vec2 z) {\n    float xtheta = 3.14159/6.;\n    float cnst = 1./sin(xtheta);\n//    return applyMobiusTransformation(z,xformCtor(one,one,one,one));    \n    return applyMobiusTransformation(z, xformCtor(one*cnst,i*cos(xtheta)*cnst,-i*cos(xtheta)*cnst,one*cnst));\n}\nvec2 inverseTransformForFixedPoints(in vec2 z, in vec2 e1, in vec2 e2) {\n    // inverse is (dz-b)/(-cz+a). a and c are 1.\n    return applyInverseMobiusTransformation(z,xformCtor(one,-e1,one,-e2));\n}\nvec2 applyRotation(in vec2 z, in float radians) {\n    // vec2 exp = cx_exp(vec2(0.,radians));\n    vec2 exp = vec2(cos(radians), sin(radians));\n    vec2 ans = cx_product(z, exp);\n    return ans;\n}\nvec2 zoom(in vec2 z, in vec2 zoomDegree) {\n    // a real zoomDegree is a straight zoom without twist.\n    // a complex zoomDegree has a twist!\n    vec2 ans = cx_product(zoomDegree,z);\n    return ans;\n}\nvec2 anotherTransform(vec2 z) {\n    vec2 n = z-i;\n    vec2 d = z+i;\n    vec2 f = cx_divide(n,d);\n    vec2 res = 1. * cx_exp(4.*f);\n    return res;\n}\nstruct circle {\n    vec2 center;\n    float radius;\n    float radiusSquared;\n};\nstruct childCircle {\n    circle c;\n    xform x;\n};\nchildCircle children[100];\nint nChildren;\nstruct circleGroup {\n    circle a;   // 0\n    circle A;   // 1\n    circle b;\n    circle B;\n};\ncircleGroup initialCircles;\nxform group_a;\nxform group_b;\nxform group_A;\nxform group_B;\n\ncircle mobiusOnCircle(xform T, circle C) { // indra's pearls, page 91\n    circle D;\n    vec2 z;\n    vec2 zdenom = cx_conjugate(vec2(cx_divide(T.d, T.c) + C.center));\n    z = C.center - cx_divide(vec2(C.radius * C.radius,0.), zdenom);\n    D.center = applyMobiusTransformation(z, T);\n    D.radius = cx_modulus(D.center - \n        applyMobiusTransformation(C.center + vec2(C.radius,0.), T));\n    return D;\n}\ncircle getInitialCircle(int i) {\n    if (i == 0) return initialCircles.a;\n    if (i == 1) return initialCircles.A;\n    if (i == 2) return initialCircles.b;\n    return initialCircles.B;\n}\nxform getTransform(int i) {\n    if (i == 0) return group_a;\n    if (i == 1) return group_A;\n    if (i == 2) return group_b;\n    return group_B;\n}\nvoid defineInitialCircles1() {   // indra's necklace page 170\n    // kissing theta circles\n    float xradius = 1.;\n    float s2 = sqrt(2.0);\n\n    initialCircles.A.center = -i*s2;\n    initialCircles.A.radius = xradius;\n    initialCircles.a.center = i*s2;\n    initialCircles.a.radius = xradius;\n\n    initialCircles.B.center = vec2(-s2,0.);\n    initialCircles.B.radius = xradius;\n    initialCircles.b.center = vec2(s2,0.);\n    initialCircles.b.radius = xradius;\n\n    vec2 s2c = vec2(sqrt(2.0),0.);\n    vec2 zero = vec2(0.,0.);\n    vec2 one = vec2(1.,0.);\n    group_a = xformCtor(s2c,i,-i,s2c);\n    group_b = xformCtor(s2c,one,one,s2c);\n    group_A = inverseXformCtor(group_a);\n    group_B = inverseXformCtor(group_b);\n}\nvoid defineInitialCircles2() {   // indra's necklace page 118\n    // non-kissing circles\n    float xtheta = 3.14159/5.;\n    float s2 = sqrt(2.0);\n\n    float xctr = 1./cos(xtheta);\n    float xradius = tan(xtheta);\n    vec2 zero = vec2(0.,0.);\n    vec2 one = vec2(1.,0.);\n\n    initialCircles.a.center = i*xctr;\n    initialCircles.a.radius = xradius;\n    initialCircles.A.center = -i*xctr;\n    initialCircles.A.radius = xradius;\n\n    initialCircles.b.center = one*xctr;\n    initialCircles.b.radius = xradius;\n    initialCircles.B.center = -one*xctr;\n    initialCircles.B.radius = xradius;\n\n//    float cnst = 1./sin(xtheta);\n    float cnst = 1.;\n\n    group_a = xformCtor(one*cnst,i*cos(xtheta)*cnst,-i*cos(xtheta)*cnst,one*cnst);\n    //group_b = xformCtor(one*cnst,vec2(cos(xtheta),0.)*cnst,vec2(cos(xtheta),0)*cnst,one*cnst);\n    group_b = xformCtor(vec2(1.5,1.), vec2(s2,1.0606602), vec2(s2,-1.0606602), vec2(1.5,-1.));\n    group_A = inverseXformCtor(group_a);\n    group_B = inverseXformCtor(group_b);\n}\nvoid defineInitialCircles3() {   // indra's necklace page 165, 170\n    // kissing, different size circles. limit set = unit circle\n    float y = 1.684;\n    float x = sqrt(1. + y*y);\n\n    float u = 1.143;\n    float v = sqrt(u*u - 1.);\n    float k = 1.;\n\n    group_b = xformCtor(vec2(x,0.), vec2(y,0.), vec2(y,0.), vec2(x,0.));\n    group_a = xformCtor(vec2(u,0.), vec2(0.,k*v), vec2(0.,-k*v), vec2(u,0.));\n    group_A = inverseXformCtor(group_a);\n    group_B = inverseXformCtor(group_b);\n\n    initialCircles.a.center = vec2(0.,k*u/v);\n    initialCircles.a.radius = k/v;\n    initialCircles.A.center = vec2(0.,-k*u/v);\n    initialCircles.A.radius = k/v;\n\n    initialCircles.b.center = vec2(x/y,0.);\n    initialCircles.b.radius = 1./y;\n    initialCircles.B.center = vec2(-x/y,0.);\n    initialCircles.B.radius = 1./y;\n}\nvoid defineInitialCircles4() {   // indra's necklace page 201\n\n    group_a = xformCtor(vec2(1.,0.), vec2(0.,0.), vec2(0.,-2.), vec2(1.,0.));\n    group_b = xformCtor(vec2(1.,-1.), vec2(1.,0.), vec2(1.,0.), vec2(1.,1.));\n    group_A = inverseXformCtor(group_a);\n    group_B = inverseXformCtor(group_b);\n\n    initialCircles.a.center = vec2(0., 5000.);\n    initialCircles.a.radius = 5000.;\n    initialCircles.A.center = vec2(0.,-0.25);\n    initialCircles.A.radius = 0.25;\n\n    initialCircles.b.center = vec2(1.,-1.);\n    initialCircles.b.radius = 1.;\n    initialCircles.B.center = vec2(-1.,-1.);\n    initialCircles.B.radius = 1.;\n}\nvoid defineInitialCircles() {\n        defineInitialCircles4();\n}\nbool insideCircleOld(circle a, vec2 z) {\n    return distance(z,a.center) < a.radius;\n}\nbool insideCircle(circle a, vec2 z) {\n    float dx = z.x - a.center.x;\n    float dy = z.y - a.center.y;\n    float dsquared = dx*dx + dy*dy; \n    return dsquared < a.radius*a.radius;\n}\nbool nearCircleRim(circle a, vec2 z) {\n    float d = distance(z,a.center);\n    return d > .95 *  a.radius && d <= a.radius;\n}\nvec2 schottkyGroup(in vec2 z, in vec2 s, in vec2 t, int index) {\n    if (index > 0)\n        z = applyMobiusTransformation(z, group_a);\n   if (index < 0)\n        z = applyInverseMobiusTransformation(z, group_a);\n    return z;\n}\nvec2 applyInverseSchottkyTransformForCircle(vec2 z, int i) {\n    if (i == 0)\n        z = applyInverseMobiusTransformation(z, group_a);\n    if (i == 1)\n        z = applyInverseMobiusTransformation(z, group_b);\n    if (i == 2)\n        z = applyInverseMobiusTransformation(z, group_A);\n    if (i == 3)\n        z = applyInverseMobiusTransformation(z, group_B);\n    return z;\n}\nvec4 getTextureColor(vec2 z) {\n    if (insideCircle(initialCircles.a, z)) {\n        return vec4(1.,1.,0.,1.);\n    }\n    if (insideCircle(initialCircles.A, z)) {\n        return vec4(0.,1.,0.,1.);\n    }\n    if (insideCircle(initialCircles.b, z)) {\n        return vec4(0.,1.,1.,1.);\n    }\n    if (insideCircle(initialCircles.B, z)) {\n        return vec4(0.,0.,1.,1.);\n    }\n    return vec4(0.,0.,0.,1.);\n}\ncircle fromVec3(vec3 v) {\n    circle c;\n    c.center[0] = v.x;\n    c.center[1] = v.y;\n    c.radius = v.z;\n    return c;\n}\ncircle fromVec4(vec4 v) {\n    return fromVec3(vec3(v.x,v.y,v.z));\n}\nint getVec3ValForIndex(vec3 v, int i) {\n    if (i == 0) return int(v.x);\n    if (i == 1) return int(v.y);\n    return int(v.z);\n}\nvec4 highlightInnerCircle(vec2 z) {\n    circle c = initialCircles.A;\n    circle c1 = mobiusOnCircle(group_a, c);\n\n    if (insideCircle(c1, z)) {\n        return vec4(0,.0,1.,1.);\n    }\n    if (insideCircle(c, z)) {\n        return vec4(1.,.0,0.,1.);\n    }\n    return vec4(0.,1.,0.,1.);\n}\nint inverseTransformIndex(int i) {\n    if (i == 0) return 1;\n    if (i == 1) return 0;\n    if (i == 2) return 3;\n    if (i == 3) return 2;\n}\nxform xformForIndex(xform[6] xforms, int i) {\n    // i hate opengl.\n    if (i == 0) return xforms[0];\n    if (i == 1) return xforms[1];\n    if (i == 2) return xforms[2];\n    if (i == 3) return xforms[3];\n    if (i == 4) return xforms[4];\n    return xforms[5];\n}\nstruct schottkyResult {\n    int level;\n    float distance;\n    float radius;\n    xform inverseXform;\n    vec2 inverseZ;\n    vec2 glitchZ;   // just a pretty effect i got by doing something wrong.\n};\nschottkyResult getSchottkyResult(int n, xform[6] xforms, vec2 z, circle c) {\n    schottkyResult res;\n    res.level = n;\n    vec2 invZ = z;\n    vec2 glitchZ = z;\n    for (int i = 0; i < 6; i++) {\n        if (i <= n) {\n            xform T = xformForIndex(xforms, i);\n            glitchZ = applyMobiusTransformation(invZ, T);\n            invZ = applyInverseMobiusTransformation(invZ, T);\n        }\n    }\n    res.inverseZ = invZ;\n    res.glitchZ = glitchZ;\n    return res;\n}\ncircle applyTransformsToCircle(circle c, xform[6] xforms, int n) {\n    circle res = c;\n    for (int i = 6; i >= 0; i--) {\n        if (i <= n) \n            res = mobiusOnCircle(xformForIndex(xforms, i), res);\n    }\n    return res;\n}\nschottkyResult applySchottkyLoop(in vec2 z) {\n    defineInitialCircles();\n    vec4 clr;\n    xform xforms[6];\n    int level = -1;\n    for (int i = 0; i < 4; i++) {\n        circle c = getInitialCircle(i);     // 0 = a, 1 = A, 2 = b, 3 = B\n        if (insideCircle(c, z)) {\n            xform T = getTransform(i);   // which xform got us inside this circle?\n            level++;\n            xforms[0] = T;\n            int inverseTransformIndex_i = inverseTransformIndex(i);\n            for (int j = 0; j < 4; j++) {\n                if (j == inverseTransformIndex_i) continue;\n                circle c2 = applyTransformsToCircle(getInitialCircle(j), xforms, level);\n                if (insideCircle(c2, z)) {\n                    xform T1 = getTransform(j);\n                    level++;\n                    xforms[1] = T1;\n                    int inverseTransformIndex_j = inverseTransformIndex(j);\n                    for (int k = 0; k < 4; k++) {\n                        if (k == inverseTransformIndex_j) continue;\n                        circle c4 = applyTransformsToCircle(getInitialCircle(k), xforms, level);\n                        if (insideCircle(c4, z)) {\n                            xform T2 = getTransform(k);\n                            level++;\n                            xforms[2] = T2;\n                            int inverseTransformIndex_k = inverseTransformIndex(k);\n                            for (int l = 0; l < 4; l++) {\n                                if (l == inverseTransformIndex_k) continue;\n                                circle c6 = applyTransformsToCircle(getInitialCircle(l), xforms, level);\n                                if (insideCircle(c6, z)) {\n\n\n                                    xform T3 = getTransform(l);\n                                    level++;\n                                    xforms[3] = T3;\n                                    int inverseTransformIndex_l = inverseTransformIndex(l);\n                                    for (int m = 0; m < 4; m++) {\n                                        if (m == inverseTransformIndex_l) continue;\n                                        circle c8 = applyTransformsToCircle(getInitialCircle(m), xforms, level);\n                                        if (insideCircle(c8, z)) {\n                                            return getSchottkyResult(3, xforms, z, c8);\n                                        }\n                                    }\n\n\n                                    return getSchottkyResult(2, xforms, z, c6);\n                                }\n                            }\n                            return getSchottkyResult(2, xforms, z, c4);\n                        }\n                    }\n                    return getSchottkyResult(1, xforms, z, c2);\n                }\n            }\n            return getSchottkyResult(0, xforms, z, c);\n        }\n    }\n    // if we get here Z is in the fundamental domain.\n    schottkyResult rrr;\n    rrr.level = -1;  // -1\n    rrr.inverseZ = z;\n    return rrr;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = 10.;\n    vec2 a = vec2((uv.x-.5)*scale, (uv.y-.5)*scale);\n \tschottkyResult res = applySchottkyLoop(a/8.);\n    vec4 color = getTextureColor(res.inverseZ);\n    fragColor = color;    \n}\n","name":"Image","description":"","type":"image"}]}