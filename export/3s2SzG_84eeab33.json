{"ver":"0.1","info":{"id":"3s2SzG","date":"1556315802","viewed":83,"name":"Beadando","username":"boga","description":"Első beadandó feladat","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["cg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---- CAMERA and EVENTs ----\n\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, vec2 coord, out vec3 eye, out vec2 data2, out int frame)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    vec3 _eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    eye = _eye;\n    vec4 data = texelFetch(iChannel0, ivec2(ratio,0), 0);\n    vec2 _data2 = data.zw;\t// spherical coordinates\n    data2 = _data2;\n    frame = int(data.y);\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.1;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    if(fragCoord.x == 0.5 + float(ratio) && fragCoord.y == 0.5)\n    {\n    \tif (data2 != _data2 || eye != _eye || iMouse.z >= 0.0)\n        \tframe = 1;\n    \telse\n        \t++frame;\n    }\n\n    // Ray generation\n    vec2 px = (coord/iResolution.xy*2.-1.)*tan(fieldOfView)*normalize(iResolution.xy);\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\n// Set the main pixel's coords to the middle of the square\nvec2 centralize(vec2 px)\n{\n    return px - 0.5 + float(ratio)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (!isMainPx(fragCoord))\n        return;\n\n    // Generate ray from pixel\n    vec2 px = centralize(fragCoord);\n    vec3 eye;\n    vec2 data; // this will be saved into first two pixels\n    int frame;\n    Ray ray = Camera(fragCoord, px, eye, data, frame);\n\t//frame = 2;\n    // Set epsilon and maximum iteration\n    float tanFieldOfViewPx = ratio > 1 ? sqrt(2.0) * tan(fieldOfView) / length(iResolution) : 0.0;\n    SphereTraceDesc params = SphereTraceDesc(0.01, 64, tanFieldOfViewPx, ray.Tmin);\n    \n    // Raytrace\n    TraceResult result = sphere_trace_algorithm(ray, params);\n    fragColor = vec4(result.dist, 0.0, 0.0, 0.0);\n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixels (0,0)\n        fragColor.yzw = eye;\n    if(fragCoord.x == 0.5 + float(ratio) && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n    if(fragCoord.x == 0.5 + float(ratio) && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.y = float(frame);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\nconst float fieldOfView = 45.0;\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float dist;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon; // Stopping distance to surface\n    int maxiters;  // Maximum iteration count\n    float tanAlpha;   // Enable cone tracing if greater than 0.0\n    float dist; // Starting distance to increase resolution\n};\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n///SDF\n\nfloat sdf(in vec3 p)\n{\n    p -= vec3(0,0,2);\n    float f = sdSphere(p, 1.0);\n    float g = sdBox(p - vec3(2, 0, 0), vec3(1, 1, 1));\n    return min(min(f, g), p.y + 1.0);\n}\n\nfloat sdf(in Ray ray, float t, float tanAlpha)\n{\n    float dist = sdf(ray.P + t*ray.V);\n    return (dist - t*tanAlpha) / (1.0 + abs(tanAlpha));\n}\n\nconst int ratio = 2;\n\n// Returns true if the pixel is the top left of the ratio*ratio square\nbool isMainPx(in vec2 fragCoord)\n{\n    const float _ratio = float(ratio);\n    return mod(fragCoord.x, _ratio) == 0.5 && mod(fragCoord.y, _ratio) == 0.5;\n}\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(params.dist, 0);\n    float d;\n    \n    int i = 0;\n    do\n    {\n        d = sdf(ray, ret.dist, params.tanAlpha);\n        ret.dist += d;\n        ++i;\n    } while (\n\t\tret.dist < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  \t > params.epsilon * ret.dist &&\t// Stop if cone is close to surface\n\t\ti     \t < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.dist >= ray.Tmax)\n              | (int(d <= params.epsilon * ret.dist)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult relaxed_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    const float omega = 1.6;\n    TraceResult ret = TraceResult(params.dist, 0);\n    float d = sdf(ray, ret.dist, params.tanAlpha);\n    \n    int i = 0;\n    while (\n\t\tret.dist < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  \t > params.epsilon * ret.dist &&\t// Stop if cone is close to surface\n\t\ti     \t < params.maxiters\t        \t// Stop if too many iterations\n\t)\n    {\n        float step = d * omega;\n        float dNext = sdf(ray, ret.dist + step, params.tanAlpha);\n        if (step < d + dNext)\n        {\n        \t// Accept the larger step\n            d = dNext;\n            ret.dist += step;\n        }\n        else\n        {\n        \t// Fallback\n            ret.dist += d;\n            d = sdf(ray, ret.dist, params.tanAlpha);\n        }\n        ++i;\n    } \n    \n    ret.flags =  int(ret.dist >= ray.Tmax)\n              | (int(d <= params.epsilon * ret.dist)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult enhanced_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    const float omega = 0.9;\n    TraceResult ret = TraceResult(params.dist, 0);\n\n    float rPrevious = sdf(ray, ret.dist, params.tanAlpha);\n    float d = rPrevious;\n    ret.dist += d;\n    float rCurrent = sdf(ray, ret.dist, params.tanAlpha);\n    \n    int i = 0;\n    while (\n\t\tret.dist < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td \t\t > params.epsilon * ret.dist &&\t// Stop if cone is close to surface\n\t\ti     \t < params.maxiters\t        \t// Stop if too many iterations\n\t)\n    {\n        float rNext = rCurrent * (d - rPrevious + rCurrent) / (d + rPrevious - rCurrent);\n        d = rCurrent + omega*rNext;\n        float rNextReal = sdf(ray, ret.dist + d, params.tanAlpha);\n        \n        if (rNextReal + rCurrent > d) // Intersect\n        {\n        \t// Accept the larger step\n            rPrevious = rCurrent;\n            rCurrent = rNextReal;\n        }\n        else\n        {\n        \t// Fallback\n            d = rCurrent;\n            rPrevious = rCurrent;\n            rCurrent = sdf(ray, ret.dist + d, params.tanAlpha);\n        }\n\t\tret.dist += d;\n        ++i;\n    } \n    \n    ret.flags =  int(ret.dist >= ray.Tmax)\n              | (int(d <= params.epsilon * ret.dist)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nTraceResult sphere_trace_algorithm(in Ray ray, in SphereTraceDesc params)\n{\n\treturn enhanced_sphere_trace(ray, params);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray, float t, vec2 fragCoord, int frame)\n{\n    const int size = 2;\n    vec3 lightPoss[size];\n    lightPoss[0] = vec3(20.0, 10.0, 10.0);\n    lightPoss[1] = vec3(-20.0, 10.0, 10.0);\n    /*lightPoss[2] = vec3(10.0, 10.0, 10.0);\n    lightPoss[3] = vec3(10.0, 10.0, 10.0);\n    lightPoss[4] = vec3(10.0, 10.0, 10.0);*/\n\n    vec3 lightPos = lightPoss[(frame - 1) % size];\n    vec3 p = ray.P + ray.V*t;\n    vec3 l = normalize(lightPos - p);\n    \n    Ray shadowRay = Ray(p,0.05,l,distance(p,lightPos));\n    SphereTraceDesc params = SphereTraceDesc(0.01, 64, 0.0, shadowRay.Tmin);\n    TraceResult result = sphere_trace_algorithm(shadowRay, params);\n    \n    vec3 col;\n    vec3 n = normal(ray.P+ray.V*t);\n    if(bool(result.flags & 1))\n        col = vec3(1,1,0)*max(dot(n,l),0.);\n    else if(bool(result.flags & 2))\n        col=vec3(0,0,0);\n    else\n    \tcol =vec3(1,0,0);\n\n    ivec2 coord = ivec2(int((fragCoord - 0.5).x), int((fragCoord - 0.5).y));\n    vec3 color = texelFetch(iChannel3, coord, 0).xyz;\n    float fframe = float(frame);\n    return vec4(color*((fframe-1.0)/fframe) + col*(1.0/fframe), 1.0);\n}\n\n// ---- CAMERA and EVENTs ----\n\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, out int frame)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    vec3 eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    vec4 data = texelFetch(iChannel0, ivec2(ratio,0), 0);\t// spherical coordinates\n    vec2 data2 = data.zw;\n    frame = int(data.y);\n\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*tan(fieldOfView)*normalize(iResolution.xy);\n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame;\n    Ray ray = Camera(fragCoord, frame);\n\n    float x = fragCoord.x - mod(fragCoord.x, float(ratio)) + 0.5;\n    float y = fragCoord.y - mod(fragCoord.y, float(ratio)) + 0.5;\n\n    vec4 color = texelFetch(iChannel0, ivec2(x, y), 0);\n    float dist = color.x;\n\n    SphereTraceDesc params = SphereTraceDesc(0.01, 64, 0.0, dist);    \n    TraceResult result = sphere_trace_algorithm(ray, params);\n\n    if(bool(result.flags & 1))\n        fragColor = missColor(ray);    \n    else if(bool(result.flags & 2))\n        fragColor = hitColor(ray, result.dist, fragCoord, frame);\n    else\n        fragColor = errorColor(ray, result.dist);\n        \n    //Debug\n\t/*fragColor = vec4(0.0, 0.0, 0.0, 1.0); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.0;\n    if(bool(result.flags & 2)) fragColor.g=1.0;\n  \tif(bool(result.flags & 4)) fragColor.b=1.0;*/\n}\n","name":"Buffer B","description":"","type":"buffer"}]}