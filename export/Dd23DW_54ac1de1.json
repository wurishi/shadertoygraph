{"ver":"0.1","info":{"id":"Dd23DW","date":"1667608386","viewed":86,"name":"Glitchy wall ray thing","username":"Dubswitcher","description":"Was attempting to make an effect that converts images to extruded 3d objects. Attempting to debug an issue involving the image iterating out beyond where it is meant to go (and other problems) - wound up with an interesting effect. Brightness = iterations","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","test","sdf","rays","glitch","image"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct obj {float face; vec3 color;};\nstruct sdf {obj surf; int layer;};\nstruct model {obj surf; int layer; vec3 global;};\n\nstruct light {float diff; float spec;};\nstruct specular {float sharpness; float bias;};\nstruct pointlight {float brightness; float falloff; specular shine;};\n\nmat3 rotation(float x, float y, float z) {\n    float pi = 3.1415923; //precision before exacts break\n    vec3 c = cos(vec3(x,y,z)*pi/2.);\n    vec3 s = sin(vec3(x,y,z)*pi/2.);\n    return mat3(vec3(1, 0, 0),vec3(0, c.x, -s.x),vec3(0, s.x, c.x)) *\n           mat3(vec3(c.y, 0, s.y),vec3(0, 1, 0),vec3(-s.y, 0, c.y)) *\n           mat3(vec3(c.z, -s.z, 0),vec3(s.z, c.z, 0),vec3(0, 0, 1));\n}\n\nfloat extrude(float img, float depth, float zed)\n{\n    vec2 s = vec2(-img, abs(zed) - abs(img) - depth);\n    return min(max(s.x,s.y),0.0) + length(max(s,0.0));\n}\n\n#define ZOOM 1.\n\nfloat v32f(vec3 c)\n{\n    return (c.r+c.g+c.b) / 3.0;\n}\n\nsdf scene (vec3 p)\n{\n    vec2 s = p.xy*iResolution.yx/iResolution.x+0.5;\n    \n    float x = v32f(texture(iChannel0,s).rgb);\n    \n    //float t = min(abs(p.z)*x,0.1);\n    float a = extrude((1.0-x)*0.4-0.2, 0.01, p.z); // <- Target\n    float b = min(abs(p.z)*x,0.1); // <- Screwing around\n    float t = mix(a,b,smoothstep(-0.1,0.1,sin(iTime*1.5)));\n\n    return sdf(obj(t,vec3(1.0)),1);\n}\n\nmat3 camera(in vec3 cPos, in vec3 targ, in float roll)\n{\n    vec3 w = normalize(targ - cPos);\n    vec3 u = normalize(cross(w,vec3(sin(roll),cos(roll),0.0)));\n    return mat3(u, normalize(cross(u,w)), w);\n}\n\nmodel raycast_surf(vec3 eye, vec3 ray, float prec, float near, float far)\n{ //  Camera angle   Origin/Direction   Precision   Near and Far clipping\n    float field = 1e10, trace = near, dist = near;\n    int material = -1; vec3 surfPos = vec3(0.); vec3 surfCol = vec3(0.);   \n    for(int i = 0; i < 100; i++)\n    {\n        if(field < prec || trace > far) break;\n        surfPos = eye+ray*trace;\n        sdf model = scene(surfPos);\n        //if(field < prec || trace > far) break;\n        surfCol = vec3(float(i)/100.0);//model.surf.color;\n        material = model.layer;\n        field = model.surf.face;\n        trace += field;\n    }\n    if(trace < far && trace > near) dist = trace; else material = -1;    \n    \n    return model(obj(dist,surfCol), material, surfPos);\n}\n\nvec3 getNorm(in vec3 pos)\n{\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(pos+0.0005*e).surf.face;\n    }\n    return normalize(n);\n}\n\nlight getPointLight(vec3 Lpos, vec3 n, vec3 ray, pointlight param)\n{\n    float pNorm = max(dot(normalize(Lpos),n),0.);\n    float diff = max(pNorm *\n        (param.brightness-(length(Lpos)/param.falloff))+0.1,0.);\n    vec3 specDir = normalize(mix(normalize(Lpos),-ray,param.shine.bias));\n    float spec = pow(dot(specDir,n),abs(param.shine.sharpness));\n    float scom = dot(-ray,Lpos)*diff/2.;\n    spec = max(spec-1.-scom+diff-0.2,0.);\n    return light(diff*diff,spec*spec);\n}\n\nlight getDirLight(vec3 Lpos, vec3 n, vec3 ray, specular param) {\n    float diff = max(dot(Lpos,n)+0.1,0.);\n    vec3 specDir = normalize(mix(normalize(Lpos),-ray,param.bias));\n    float spec = pow(dot(specDir,n),abs(param.sharpness));\n    float scom = dot(-ray,Lpos)*diff/2.;\n    spec = max(spec-1.-scom+diff,0.);\n    return light(diff*diff,spec*spec);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //vec2 mp = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    //vec3 eye = vec3(0.,0.,ZOOM) * rotation(sin(iTime*1.43)*0.1,sin(iTime)*0.1,0.);\n    vec3 eye = vec3(0.,0.,ZOOM) * rotation(0.,sin(iTime*0.3)*0.8,0.);\n    vec3 targ = vec3(0.);\n    \n    mat3 cam = camera(eye, targ, 0.);\n    vec3 ray = normalize(cam*vec3(uv,1.));\n    \n    model pix = raycast_surf(eye, ray, 0.001, 0., 50.);\n    vec3 n = getNorm(pix.global);\n    \n    specular defspec = specular(10.,0.6);\n    \n    vec3 col = vec3(0.2,0.3,0.5);\n    vec3 bgcol = col;\n    if (pix.layer > -1) {\n        \n        vec3 L1 = normalize(vec3(0.,1.,1.));\n        vec3 P1 = vec3(-1.5,0.5,0.8)-pix.global;\n        vec3 P2 = vec3(0.2,-2.5,-2.5)-pix.global;\n        light sun = getDirLight(L1,n,ray,defspec);\n        light point1 = getPointLight(P1,n,ray,pointlight(1.,50.,defspec));\n        light point2 = getPointLight(P2,n,ray,pointlight(1.,50.,defspec));\n        \n        float fnorm = max(dot(-ray,n),0.);\n        \n        //col = vec3(0.1,0.1,0.1)*0.3; //Emit\n        col += sun.diff*vec3(1.); //Diffuse\n        col += point1.diff*vec3(0.5,0.7,1.)/2.;\n        col += point2.diff*vec3(1.,0.6,0.4)/2.;\n        \n        col *= pix.surf.color;\n        \n        col += sun.spec*0.8; //Specular\n        col += point1.spec*0.8;\n        col += point2.spec;\n    }\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}