{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Takashi Furuya, https://github.com/takfuruya\n// GPU Programming and Architecture Hackathon, University of Pennsylvania\n// http://www.seas.upenn.edu/~cis565/\n\n// Forked from:\n// https://www.shadertoy.com/view/XdsGDB\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float tau = 6.28318530717958647692;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec3 localRay;\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\n// Noise functions, distinguished by variable types\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n// hardware interpolation lacks precision\n//\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\tvec4 rg = mix( mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+1.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n\t\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x.xy);\n    vec2 f = fract(x.xy);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = p.xy + f.xy;\n\treturn texture( iChannel0, (uv+0.5)/256.0, -100.0 );\n}\n\nvec4 Noise( in ivec2 x )\n{\n\treturn texture( iChannel0, (vec2(x)+0.5)/256.0, -100.0 );\n}\n\nvec2 Noise( in ivec3 x )\n{\n\tvec2 uv = vec2(x.xy)+vec2(37.0,17.0)*float(x.z);\n\treturn texture( iChannel0, (uv+0.5)/256.0, -100.0 ).xz;\n}\n\n\nfloat Waves( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 6;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\tvec3 temp = texture( iChannel1, pos.xz/25.0, -100.0 ).xyz;\n\tf = (temp.x + temp.y + temp.z)/5.0;\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesDetail( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 8;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WavesSmooth( vec3 pos )\n{\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves = 2;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\t\tpos += iTime*vec3(0,.1,.1);\n\tfor ( int i=0; i < octaves; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\t//f  = f*2.0+abs(Noise(pos).x-.5)*2.0;\n\t\tf  = f*2.0+sqrt(pow(Noise(pos).x-.5,2.0)+.01)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tf /= exp2(float(octaves));\n\t\n\treturn (.5-f)*1.0;\n}\n\nfloat WaveCrests( vec3 ipos )\n{\n\tvec3 pos = ipos;\n\tpos *= .2*vec3(1,1,1);\n\t\n\tconst int octaves1 = 6;\n\tconst int octaves2 = 16;\n\tfloat f = 0.0;\n\n\t// need to do the octaves from large to small, otherwise things don't line up\n\t// (because I rotate by 45 degrees on each octave)\n\tpos += iTime*vec3(0,.1,.1);\n\tvec3 pos2 = pos;\n\tfor ( int i=0; i < octaves1; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*1.5+abs(Noise(pos).x-.5)*2.0;\n\t\tpos *= 2.0;\n\t}\n\tpos = pos2 * exp2(float(octaves1));\n\tpos.y = -.05*iTime;\n\tfor ( int i=octaves1; i < octaves2; i++ )\n\t{\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))/sqrt(2.0);\n\t\tf  = f*1.5+pow(abs(Noise(pos).x-.5)*2.0,1.0);\n\t\tpos *= 2.0;\n\t}\n\tf /= 1500.0;\n\t\n\tf -= Noise(ivec2(fragCoord.xy)).x*.01;\n\t\n\treturn pow(smoothstep(.4,-.1,f),6.0);\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn texture( iChannel2, ray.xy, -100.0 ).xyz * vec3(0.02);\n}\n\n\nfloat OceanDistanceField( vec3 pos )\n{\n\treturn pos.y - Waves(pos);\n}\n\nfloat OceanDistanceFieldDetail( vec3 pos )\n{\n\treturn pos.y - WavesDetail(pos);\n}\n\nvec3 OceanNormal( vec3 pos )\n{\n\tvec3 norm;\n\tvec2 d = vec2(.01*length(pos),0);\n\t\n\tnorm.x = OceanDistanceFieldDetail( pos+d.xyy )-OceanDistanceFieldDetail( pos-d.xyy );\n\tnorm.y = OceanDistanceFieldDetail( pos+d.yxy )-OceanDistanceFieldDetail( pos-d.yxy );\n\tnorm.z = OceanDistanceFieldDetail( pos+d.yyx )-OceanDistanceFieldDetail( pos-d.yyx );\n\n\treturn normalize(norm);\n}\n\nfloat Trace( vec3 pos, vec3 ray )\n{\n\tfloat h = 1.0;\n\tfloat t = 0.0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tif ( h < .01 || t > 100.0 )\n\t\t\tbreak;\n\t\th = OceanDistanceField( pos+t*ray );\n\t\tt += h;\n\t}\n\t\n\tif ( h > .1 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\n\nvec3 ShadeOcean( vec3 pos, vec3 ray )\n{\n\tvec3 norm = OceanNormal(pos);\n\tfloat ndotr = dot(ray,norm);\n\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\n\t\n\tvec3 reflectedRay = ray-2.0*norm*ndotr;\n\tvec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;\t\n\trefractedRay = normalize(refractedRay);\n\n\tconst float crackFudge = .0;\n\t\n\t// reflection\n\tvec3 reflection = Sky(reflectedRay);\n\t\n\t// refraction\n\t\n\t//vec3 col = vec3(.04,.04,.0); // under-sea colour\n\tvec3 col = texture( iChannel1, pos.xz/25.0, -100.0 ).xyz * vec3(0.1);\n\t\n\tcol = mix( col, reflection, fresnel );\n\t\n\t// foam\n\tcol = mix( col, vec3(1), WaveCrests(pos) );\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 camRot = vec2(.5,.5)+vec2(-.35,4.5)*(iMouse.yx/iResolution.yx);\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0), camRot, 3.0, 0.5 );\n\t\n\tfloat to = Trace( pos, ray );\n\t\n\tvec3 result;\n\tif ( to > 0.0)\n\t\tresult = ShadeOcean( pos+ray*to, ray );// * (0.4-to*0.01);\n\telse\n\t\tresult = Sky( ray );\n\t\n\t// vignette effect\n\tresult *= 1.1*smoothstep( .35, 1.0, localRay.z );\n\t\n\tfragColor = vec4(ToGamma(result),1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd23zD","date":"1384658370","viewed":284,"name":"Field in Cave","username":"takfuruya","description":"It is windy.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["field","cave"],"hasliked":0,"parentid":"","parentname":""}}