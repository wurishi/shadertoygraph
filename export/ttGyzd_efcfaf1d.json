{"ver":"0.1","info":{"id":"ttGyzd","date":"1611569623","viewed":116,"name":"Raytraced snowman","username":"dmitrytsgn","description":"Use mouse to move camera\n\nBare bones raytracing with no optimizations","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Variables you can change \n\n// the higher this number - \n// the better the quality and the worse the performance\nconst int samplesPerFrag = 10;\n// if this is too low, glass won't work. try it\nconst int maxDepth = 19;\n\n// Camera\nvec3 lookfrom = vec3(-7.5f, 5.f, 3.f);\nvec3 lookat =   vec3(0.f, 0.5f, 0.f);\nvec3 up =       vec3(0.f, 1.f, 0.f);\n\nconst float fovy = 60.f;\n\n#define USE_TIME_AS_SEED 1\n\n///////////\n\n\n\n// Math\n#define M_PI 3.1415926535897932384626433832795\n\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\nbool nearZero(vec3 v) {\n    float s = 1e-8;\n    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);\n}\n\nvec4 quaternionMultiply(vec4 q1, vec4 q2) {\n    vec3 v1 = q1.xyz;\n    vec3 v2 = q2.xyz;\n    \n    float w = q1.w * q2.w * dot(v1, v2);\n    \n    vec3 xyz = v1 * q2.w + v2 * q1.w + cross(v1, v2);\n    \n    return vec4(xyz, w);\n}\n\nvec3 rotate(float angle, vec3 axis, vec3 point) {\n    // point in quaternion form\n    vec4 p4 = vec4(point, 0.f);\n    float s = sin(angle / 2.f);\n    float c = cos(angle / 2.f);\n    \n    vec4 q = vec4(s * axis.x, s * axis.y, s * axis.z, c);\n    vec4 qConj = vec4(-q.xyz, c);\n    \n    return quaternionMultiply(quaternionMultiply(q, p4), qConj).xyz;\n}\n\nvoid rotateLeft(float angle, vec3 up, inout vec3 lookFrom) {\n    lookFrom = rotate(angle, up, lookFrom);\n}\n\nvoid rotateUp(float angle, inout vec3 up, inout vec3 lookFrom) {\n    vec3 axis = normalize(cross(lookFrom, up));\n    up = rotate(angle, axis, up);\n    lookFrom = rotate(angle, axis, lookFrom);\n}\n\n// 2D\n\nvec3 gradient(float start, float end, float border, vec3 colorA, vec3 colorB, float val) {\n    border = mix(start, end, border);\n    \n    float endA = start + (border - start) * 2.f;\n    float startA = end - (end - border) * 2.f;\n    \n    return\n        ((1.f - smoothstep(start, endA, val)) * step(start, val) * colorA  \n        + smoothstep(start, endA, val) * (1.f - step(end, val)) * colorB)\n        * (1.f - step(border, val))\n        \n        + ((1.f - smoothstep(startA, end, val)) * step(start, val) * colorA  \n        + smoothstep(startA, end, val) * (1.f - step(end, val)) * colorB)\n        * step(border, val);\n}\n\nvec3 gradient(float start, float end, float borderA, float borderB,\n   vec3 colorA, vec3 colorB, vec3 colorC, float val) {\n   float borderMiddle = mix(borderA, borderB, 0.5f);\n   float middle = mix(start, end, borderMiddle);\n   \n   borderA /= borderMiddle;\n   borderB = (borderB - borderMiddle) / (1.f - borderMiddle);\n   \n   return gradient(start, middle, borderA, colorA, colorB, val) +\n       gradient(middle, end, borderB, colorB, colorC, val);\n}\n\n// Presets\n\nvec3 sky(vec2 uv) {\n    vec3 color1 = vec3(0.9f, 0.9f, 0.9f);\n    vec3 color2 = vec3(0.8f, 0.97f, 1.f);\n    vec3 color3 = vec3(0.989f, 0.969f, 0.84f);\n\n    return gradient(0.f, 1.f, 0.1f + 0.1f * uv.x, 0.5f + 0.4f * uv.x,\n        color1, color2, color3, uv.y);\n}\n\n// Random\n\nint seed;\nint coordId;\n\nvoid encryptTea(inout uvec2 v)\n{\n    uint v0 = v[0], v1 = v[1], sum = 0u;\n    uint delta = 0x9E3779B9u,\n        k0 = 238450u, k1 = 89762u,\n        k2 = 10989532u, k3 = 909243993u;\n    \n    for (int i = 0; i < 5; i++) {\n        sum += delta;\n        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);\n        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);\n    }\n    v[0]=v0; v[1]=v1;\n}\n\nfloat getRandom(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nvec2 getRandom() {\n  \tuvec2 v = uvec2(coordId, seed++);\n  \tencryptTea(v);\n  \treturn fract(vec2(v) / vec2(0xffffffffu));\n}\n\nvec2 getRandom(float _min, float _max) {\n    vec2 v = getRandom();\n    return vec2(_min + (_max - _min) * v.x, _min + (_max - _min) * v.y);\n}\n\nvec3 randVec(float _min, float _max) {\n    return vec3(getRandom(_min, _max), getRandom(_min, _max).x);\n}\n\nvec3 randomInUnitSphere() {\n\twhile (true) {\n\t\tvec3 p = randVec(-1.f, 1.f);\n\t\tif (length(p) >= 1.f)\n            continue;\n\t\treturn p;\n\t}\n}\n\n// Effects\n\nfloat snow(vec2 uv) {   \n    float numberOfRegions = 200.f;\n    \n    float regionSize = 1.f / numberOfRegions;\n    float index = round(gl_FragCoord.x * numberOfRegions / iResolution.x);\n\n    float r = getRandom(index);\n    vec2 center;\n    \n    center.y = mod(1. - mod(iTime / (1.5f + 5.f * r), 1.f) + r, 1.f);\n    \n    float halfWavesPerScreen = 5.f;\n    float wave = sin(center.y * M_PI * halfWavesPerScreen) \n        * regionSize * 0.5f * getRandom(index * index);\n    \n    center.x = index * regionSize + wave;\n    return smoothstep(0.004f, 0.003f, length(uv - center));   \n}\n\n// Camera\nstruct Camera {\n    vec3 u;\n    vec3 v;\n    vec3 w;\n    \n    vec3 eye;\n    vec2 fov;  \n    \n    vec3 vertical;\n    vec3 horizontal;\n};\n\nvoid initCamera(out Camera cam, vec3 lookfrom, vec3 lookat, vec3 up, float fovy) {\n    cam.eye = lookfrom;\n    \n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(up, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    \n    cam.fov.y = radians(fovy);\n    cam.fov.x = 2.f * atan(iResolution.x / iResolution.y * tan(cam.fov.y / 2.f));\n    \n    cam.horizontal = tan(cam.fov.x / 2.f) * 2.f * cam.u;\n    cam.vertical = tan(cam.fov.y / 2.f) * 2.f * cam.v;\n}\n\nRay rayThroughFrag(vec2 uvc, in Camera cam) {\n    Ray r;\n    \n    r.orig = cam.eye;\n    r.dir = normalize(cam.horizontal * uvc.x + cam.vertical * uvc.y - cam.w);\n    \n    return r;\n}\n\n// Materials\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\nstruct Material {\n    int materialId;\n    vec3 color;\n    float fuzz;\n    float indexOfRefraction;\n};\n\n// Objects\nstruct Sphere {\n    float radius;\n    vec3 center;\n    vec3 scale;\n\n    Material material;\n};\n\n\nstruct CollisionInfo {\n    float t;\n    vec3 pos;\n    vec3 normal;\n    bool frontFace;\n    \n    Material material;\n};\n\n\nvoid setFaceNormal(Ray r, vec3 outwardNormal, inout CollisionInfo info) {\n    info.frontFace = dot(normalize(r.dir), outwardNormal) < 0.f;\n    info.normal = info.frontFace ? outwardNormal : -outwardNormal;\n}\n\nbool raySphereIntersection(Ray r, Sphere s, float tolerance, out CollisionInfo info) {\n    // Scaled ray\n    Ray rayI;\n    rayI.orig = r.orig / s.scale;\n    rayI.dir = normalize(r.dir / s.scale);\n    \n    vec3 oc = rayI.orig - s.center;\n\tfloat a = dot(rayI.dir, rayI.dir);\n\tfloat halfB = dot(rayI.dir, oc);\n\tfloat c = dot(oc, oc) - s.radius * s.radius;\n\n    float d = halfB * halfB - a * c;\n    if (d < 0.f)\n        return false;\n\n    float root = (-halfB - sqrt(d)) / a; \n    \n    if (root <= tolerance) {\n        root = (-halfB + sqrt(d)) / a;\n    }\n    \n    if (root > tolerance) {\n        // scale intersection point back\n        vec3 I = rayI.orig + rayI.dir * root;\n        info.pos = I * s.scale;\n        info.t = length(info.pos - r.orig);\n        \n        info.material = s.material;\n        \n        // note: we divide by radius insted of normalizing to get hollow sphere trick\n        vec3 outNormal = ((I - s.center) / s.radius) / s.scale;\n        setFaceNormal(r, normalize(outNormal), info);\n        \n        return true;\n    }\n    \n    return false;\n}\n\n\n// Arrays\n\n#define MAX_SPHERES 15\nint spheresCount = 0;\nSphere spheres[MAX_SPHERES];\n\nbool hitWorld(Ray r, out CollisionInfo resInfo) {\n    CollisionInfo info;\n    \n    bool res = false;\n    for(int i = 0; i < spheresCount; ++i) {\n        if (raySphereIntersection(r, spheres[i], 0.005f, info)) {\n            if (!res || info.t < resInfo.t) {\n                resInfo = info;\n                res = true;\n            }\n        }\n    }\n    \n    return res;\n}\n\n// Materials\n\nfloat reflectance(float cosinus, float refIdx) {\n    float r0 = (1.f - refIdx) / (1.f + refIdx);\n    r0 = r0 * r0;\n    return r0 + (1.f - r0) * pow((1.f - cosinus), 5.f);\n}\n\nbool scatterDiffuse(out Ray r, in CollisionInfo info) {\n    r.orig = info.pos;\n    r.dir = normalize(info.normal + randomInUnitSphere());\n    if (nearZero(r.dir)) {\n        r.dir = info.normal;\n    }\n    \n    return true;\n}\n\nbool scatterMetal(inout Ray r, in CollisionInfo info) {\n    vec3 reflected = reflect(r.dir, info.normal);\n    r.orig = info.pos;\n    r.dir = normalize(reflected + randomInUnitSphere() * info.material.fuzz);\n\n    return dot(r.dir, info.normal) > 0.f;\n}\n\nbool scatterDielectric(inout Ray r, in CollisionInfo info) {\n    float ir = info.material.indexOfRefraction;\n    float refractionRatio = info.frontFace ? (1.f / ir) : ir;\n\n    vec3 unitDirection = normalize(r.dir);\n    float cosinus = min(dot(-unitDirection, info.normal), 1.f);\n    float sinus = sqrt(1.0 - cosinus * cosinus);\n\n    bool cannotRefract = refractionRatio * sinus > 1.f;\n    vec3 direction;\n\n    if (cannotRefract || reflectance(cosinus, refractionRatio) > getRandom(0.f, 1.f).x)\n        direction = reflect(unitDirection, info.normal);\n    else\n        direction = refract(unitDirection, info.normal, refractionRatio);\n\n    r.orig = info.pos;\n    r.dir = normalize(direction);\n\n    return true;\n}\n\nbool scatter(inout Ray r, in CollisionInfo info) {\n    switch (info.material.materialId) {\n        case LAMBERTIAN:\n            return scatterDiffuse(r, info);\n        case METAL:\n            return scatterMetal(r, info);\n        case DIELECTRIC:\n            return scatterDielectric(r, info);\n    }\n}\n\nvec3 randomRayColor(vec2 uv, in Camera cam) {\n    vec2 coord = getRandom() / iResolution.xy + uv - vec2(0.5f);\n    Ray r = rayThroughFrag(coord, cam);\n    \n    int depth = maxDepth;\n    \n    vec3 color = vec3(1.f);\n    \n    Ray currentR = r;\n    \n    CollisionInfo info;\n    while(true) {\n        if (depth-- == 0) {\n            // can't find the light!\n            color = vec3(0.f);\n            break;\n        }\n        \n        if (hitWorld(currentR, info)) {\n            if (scatter(currentR, info)) {\n                color *= info.material.color;\n            } else {\n                // the surface absorbed the ray!\n                color = vec3(0.f);\n                break;\n            }\n        } else {\n            // found the light!\n            color *= sky(uv);\n\n            break;\n        }\n    }\n    \n    return color;\n}\n\nSphere insideGlassBall;    \nSphere snowPile;\nvec3 snowColor = vec3(1.f, 0.95f, 0.95f);\n\nvoid createObjects() {\n    Material snow;\n    snow.color = snowColor;\n    snow.materialId = LAMBERTIAN;\n    \n    Sphere lowerBody;\n    lowerBody.radius = 1.f;\n    lowerBody.material = snow;\n    lowerBody.scale = vec3(1.f);\n    lowerBody.center = vec3(0.f, lowerBody.radius - 1.5f, 0.f);\n    spheres[spheresCount++] = lowerBody;\n    \n    Sphere upperBody = lowerBody;\n    upperBody.radius *= 0.8f;\n    float upperY = upperBody.center.y + upperBody.radius * 1.8f;\n    upperBody.center = vec3(0.f, upperY, 0.f);\n    spheres[spheresCount++] = upperBody;\n    \n    Sphere head = upperBody;\n    head.radius *= 0.8f;\n    float headY = head.center.y + head.radius * 1.8f;\n    head.center = vec3(0.f, headY, 0.f);\n    spheres[spheresCount++] = head;\n    \n    Material carrotMat;\n    carrotMat.color = vec3(0.97f, 0.57f, 0.13f);\n    carrotMat.materialId = LAMBERTIAN;\n    \n    Sphere carrot = head;\n    carrot.center = vec3(0.f);\n    carrot.scale = vec3(1.f, 0.2f, 0.2f);\n    carrot.center.y = head.center.y / carrot.scale.y;\n    carrot.center.x -= head.radius;\n    carrot.material = carrotMat;\n    spheres[spheresCount++] = carrot;\n    \n    Material coal;\n    coal.color = vec3(0.21f, 0.27f, 0.31f);\n    coal.materialId = LAMBERTIAN;\n    \n    Sphere rightEye;\n    rightEye.radius = 0.1f;\n    rightEye.scale = vec3(1.f);\n    \n    rightEye.center = vec3(-head.radius * 0.8f,\n        head.center.y + head.radius / 2.f, -head.radius * 0.3f);\n    \n    rightEye.material = coal;\n    spheres[spheresCount++] = rightEye;\n    \n    Sphere leftEye = rightEye;\n    vec3 rightEyeCenter = rightEye.center;\n    leftEye.center = vec3(rightEyeCenter.x, rightEyeCenter.y, head.radius * 0.3f);\n    spheres[spheresCount++] = leftEye;\n    \n    Material ice;\n    ice.color = vec3(0.8f, 0.8f, 0.8f);\n    ice.materialId = METAL;\n    ice.fuzz = 0.045f;\n    \n    Sphere snowInGlass;\n    snowInGlass.radius = 2.f;\n    snowInGlass.material = snow;\n    snowInGlass.scale = vec3(1.f, 0.2f, 1.f);\n    float snowInGlassRadius = snowInGlass.radius * snowInGlass.scale.y;\n    vec3 snowInGlassCenter = lowerBody.center;\n    snowInGlassCenter.y -= (lowerBody.radius + snowInGlassRadius) / snowInGlass.scale.y;\n    snowInGlass.center = snowInGlassCenter;\n    spheres[spheresCount++] = snowInGlass; \n    float snowInGlassDiameter = snowInGlassRadius * 2.f;\n    \n    Sphere ground;\n    ground.radius = 7.f;\n    ground.material = ice;\n    ground.scale = vec3(1.f, 0.1f, 1.f);\n    float groundY = (lowerBody.center.y - lowerBody.radius - snowInGlassDiameter) \n        / ground.scale.y - ground.radius;\n    ground.center = vec3(0.f, groundY, 0.f);\n    spheres[spheresCount++] = ground;\n\n    snowPile.radius = 1.f;\n    snowPile.material = snow;\n    snowPile.scale = vec3(1.f, 9.f, 6.f);\n    snowPile.center = vec3(4.3f, 0.f, 0.f);\n    spheres[spheresCount++] = snowPile;\n    \n    Material glass;\n    glass.color = vec3(1.f);\n    glass.materialId = DIELECTRIC;\n    glass.indexOfRefraction = 1.5f;\n    \n    Sphere glassSphere;\n    glassSphere.radius = 3.1f;\n    glassSphere.material = glass;\n    glassSphere.scale = vec3(1.f);\n    glassSphere.center = vec3(0.f, glassSphere.radius - snowInGlassDiameter\n        + lowerBody.center.y - lowerBody.radius, 0.f);\n    spheres[spheresCount++] = glassSphere;\n    \n    insideGlassBall = glassSphere;\n    insideGlassBall.radius = -insideGlassBall.radius * 0.92f;\n    spheres[spheresCount++] = insideGlassBall;\n}\n\nvoid addSnow(vec2 uv, in Camera cam, inout vec3 color) {\n    vec2 coord = vec2(0.5f) / iResolution.xy + uv - vec2(0.5f);\n    Ray r = rayThroughFrag(coord, cam);\n    CollisionInfo info;\n    \n    if(raySphereIntersection(r, insideGlassBall, 0.005f, info)) {\n        CollisionInfo info2;\n        bool b = raySphereIntersection(r, snowPile, 0.005f, info2);\n        if (!b || info2.t > info.t) {\n            color = mix(color, snowColor, snow(uv));\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    createObjects();\n       \n#if USE_TIME_AS_SEED\n    seed = int(iTime * 100.f);\n#else\n    seed = 0;\n#endif\n\n    coordId = int(fragCoord.x + fragCoord.y * iResolution.x);\n    \n    vec4 mouse = iMouse / iResolution.xyxy;\n    \n    rotateLeft((mouse.x - abs(mouse.z)) * 2.f * M_PI, up, lookfrom);\n    rotateUp((mouse.y - abs(mouse.w)) * M_PI / 6.f, up, lookfrom);\n\n    Camera cam;\n    initCamera(cam, lookfrom, lookat, up, fovy);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color;\n    for(int i = 0; i < samplesPerFrag; ++i) {     \n        color += randomRayColor(uv, cam);\n    }\n    \n    color /= float(samplesPerFrag);\n\n    addSnow(uv, cam, color);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}