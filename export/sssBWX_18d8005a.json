{"ver":"0.1","info":{"id":"sssBWX","date":"1649990921","viewed":152,"name":".color dequantization","username":"xrx","description":"simple version @ https://www.shadertoy.com/view/NdVczz","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["color","dither","quantization","gamma","monitor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// select bit8/pic1\n// watch color banding limited by monitor (col4), vs smooth noised color (col5)\n\n// mostly visible when light bellow 5%, dark scenes, or in vr. \n// requires _float buffer for precission levels, this wont do much if buffer is _int quantized without precision (color fried)\n// - for low bit sim purpose, need late gamma adj\n// - for high bit native precission, need early gamma adj\n\n// - check 8bit (red) quantized color banding at low intensities\n// - check 8bit (green) no perceivable banding \n// - check 8bits+ (yellow) introduced banding, as beyond monitor support\n// - check quantized sim banding vs native monitor banding \n// - check low light test: amplify lightness on monitor, or set gamma 1.0 on monitor, or set variable GAMMA=8.\n// - use full screen mode, also dark ambient cond\n\n// col1: sim multi-precission quantized color simulation (limited by INT buffer, or by monitor (as seen))\n// col2: sim multi-precission dequantized color, mixing nearby quantization levels \n// col3: dequantized (good for low bits simulation, late gamma adj), incorrect for high bits (banding introduced)\n// col4: direct      (buffer/monitor limit test)\n// col5: dequantized (good for high bits, early gamma adj), incorrect for low bit sim\n\n// top:      ref gray solid (checker)\n// middle:   multiple buffers at different bit precisions\n// bottom+1: ref gray noisy\n// bottom:   ref gray solid (checker)\n\n// m.x: select different images\n// m.y: select nbit precisions levels\n\n//---------------------------------  imports\n//IQ\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame ){\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // hash by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n//---------------------------------\nfloat GAMMA = 2.25;        //compression (1:equal length), req same as monitor  \n\nfloat cmult = exp2(-0.);      // darkening\nbool  cmult_auto = bool(1);  \nconst float period_cmult = 30.; \nconst float period_img = period_cmult; // flip\n//---------------------------------\n\nint BITS = 8*2-1;              // buffer count\nint BITSmon;// = 8;          // for monitor test \nconst int BITSmon_d = 8;     //0..7\nconst int useimg_d=1;\nfloat GAMMA2 = 2.3;          // for marks intensity only\n\n//0:no adj\n//1:early    \n//2:late     (1bit distribution ok, but 8bit wrong/fuzzy - quantized signal shouldnt be gamma corrected)\n//dont matter if G1\n//int GAMMA_adj_stage= 1;    // 0:noadj 1:early before dither 2:late after dither. dynamic gamma\n\n//---------------------------------\n#define Color vec3\nfloat saturate(float a)            {return clamp(a,0.,1.);}\nvec3 gray(ivec2 p)                 {return vec3((p.x+p.y)%2>0?1.:0.); }//ref true gray (solid)\nvec3 grayr(ivec2 p)                {return vec3(frand()>.5?1.:0.); }//ref true gray (noisy)\nfloat wavesignal(float f)          {return -cos(iTime*6.2832*f)*.5+.5;}\n\nvec3 gammaadj(vec3 c, float g){    \n    return pow(c, vec3(1./g)); \n}\n\n// wip (only for low bit)\n// low bit monitor simulation on current monitor\n// 1bit needs no gamma adj (so such thing)\n// 8bit needs gamma adj\nvec3 gammaadjb(vec3 c, float g, int b)     {     \n    return gammaadj(c, GAMMA); \n    //return mix(c, gammaadj(c, g),saturate(float(b)/7.)); \n\n    g = mix(1.,g,float(b)/8.); // est\n    g = clamp(g, 1.,GAMMA);\n    return gammaadj(c, g); \n}\n\n//---------------------------------\nfloat levels(int b){    //b-=1;  \n    //return float((1<<b)-1);   // 1bit map: 0->[0], 1->[0..1]\n    return float(1<<b);       // 1bit map: 0->[0 .. .5], 1->[.5 .. 1] (+midtone)\n}\n\nvec3 quantize_core(vec3 c, int bits, float r){  \n    float l  = levels(bits);   \n    \n    //return floor(c*l+.5+r)/(l-0.);    \n    return round(c*l+r)/l;     // <<   //return floor(c*l+r+.5)/l;   // same \n}\n\n// +todo: simulation 1bit3tone gray should match refgray\nvec3 quantize(vec3 c, int bits){  \n    return quantize_core(c, bits, 0.);\n}\n\nvec3 dequantize(vec3 c, int bits){  \n    return quantize_core(c, bits, frand()-.5);\n}\n\nColor simple(ivec2 ip){\n    vec2 p = vec2(ip);    vec2 r = iResolution.xy;\n    \n    float z = 0.;\n    z += pow(.0001,length(p-vec2(50))/r.x/1.);\n    z += pow(.0001,length(p-(r-vec2(50)))/r.x/1.);\n    \n\n    return Color(1)*z;\n}\n\n//---------------------------------\nvoid mainImage(out vec4 C, in vec2 p){\n    srand(ivec2(p), iFrame*1);\n\n    int mons = 5;\n    ivec2 ip = ivec2(p);    ivec2 ir = ivec2(iResolution.xy);\n    float x = p.x/iResolution.x; x= fract(x*float(mons));\n\n    int mon = ip.x/(ir.x/mons);\n    int monw = ir.x/mons;\n\n    int nbands = 2+BITS+1;    \n    int bandh = int(iResolution.y/float(nbands));\n\n    BITSmon = 1+int(iMouse.y)/bandh-2; if(iMouse.y==0.) BITSmon=BITSmon_d;\n\n    float y = p.y/iResolution.y;\n    y = (p.y-1.*float(bandh))/(iResolution.y-2.*float(bandh));//only for img\n    \n    //int b = int(float(nbands)*y); //band\n    int bb = ip.y / bandh; // band\n    int bf = ip.y % bandh; // band fraction  \n    int b = 1+(bb-2);             // bits\n    //if (ip.y==int(iResolution.y)-1) bf = 0;\n    //int b2 = int(float(nbands)*y*2.)%2==0?0:1;\n    \n    //--------------------------------- signal\n    vec3 c1; \n    //c1 = vec3(.5); // gray test\n    c1 = vec3(x); // grad\n    //c1 = vec3(x,y,0); // r/g grad\n    \n    vec3 cimg = texture( iChannel0, vec2(x,3.*fract(y+iTime/30.))).rgb; cimg = pow(cimg,vec3(2.2)); // tx gamma est\n    int useimg = int(iMouse.x)/(ir.x/mons);   if(iMouse.x==0.) useimg=useimg_d;\n    \n    if (useimg>0 && fract(y+iTime/30.)>.333){\n        cimg = vec3(1.*x,3.*fract(y+iTime/30.)-1.,0);\n    }\n    if (useimg>0 && fract(y+iTime/30.)>.666){\n        cimg = vec3(x);\n    }\n    \n    if(useimg>0) c1=cimg;\n    //if(useimg==2) c1=fract(iTime/period_img*.5)<.5?c1:cimg;\n\n    //if (cmult_auto && fract(iTime*.5/20.)<.5){\n    if (cmult_auto) {\n        //cmult*=1.-wavesignal(1./period_cmult); // linear light chg, but level too fast low end\n        cmult *= exp2((GAMMA==1.?-5.:-11.)*wavesignal(1./period_cmult)); // rel to light level\n    }\n    //c1*= wavesignal(x*4.);\n    c1*= cmult; \n    if(b<0 || b>BITS) c1 = vec3(1,0,0);\n\n    // c1 = gammaadj(c1, GAMMA2); \n\n    //--------------------------------- bands\n    vec3 c;\n    if (b>=0 && b<=BITS)\n    switch(mon+1){\n        case 1: {\n            //c1 = gammaadj(c1, GAMMA); \n            c = quantize(c1,b);\n            c=gammaadj(c, GAMMA); \n            break;\n        }\n        case 2: {\n            //c1 = gammaadjb(c1, GAMMA, b); \n            c = dequantize(c1, b); \n            c=gammaadj(c, GAMMA); \n            break;\n        }\n        case 3: {\n            //c1 = gammaadjb(c1, GAMMA, BITSmon); \n            c = dequantize(c1, BITSmon);  \n            c=gammaadj(c, GAMMA); \n            break;\n        }\n        case 4: { // DIRECT\n            c1 = gammaadj(c1, GAMMA); \n            c = c1;\n            break;\n        }\n        case 5: { \n            c1 = gammaadjb(c1, GAMMA, BITSmon); \n            c = dequantize(c1, BITSmon);  \n            break;\n        }\n    }\n    //c = gammaadj(c, GAMMA2); \n\n    if (1==1 && cmult>.25){ // ref grays off near darks\n        if(bb==(2+BITS+0)) c = gray(ip);//0.;//c1;\n        //if(bb==1)          c = grayr(ip);\n        if(bb==0)          c = gray(ip);\n    }\n    \n    if (bf==0&& mon<2) { //lines\n        c=vec3(.5*cmult);\n        //c = gammaadj(c,GAMMA2);\n        //c1=clamp(c1,0.,.5);\n    }\n    //--------------------------------- img\n    C = vec4(c,0);\n    \n    if (false)\n    if (false\n    || ip.x==int(iResolution.x*.00)\n    || ip.x==int(iResolution.x*.25)\n    || ip.x==int(iResolution.x*.50)\n    || ip.x==int(iResolution.x*.75)\n    || ip.x==int(iResolution.x*1.)-1) cmult = 1.;\n    \n    float g = GAMMA2;\n    if (bf==0 && b>BITSmon_d && mon<2)                     C = vec4(gammaadj(vec3(1,1,0)*.99*cmult,g),0); //ylw\n    if (bf==0 && (b==BITSmon_d||b==BITSmon_d+1) && mon<2)  C = vec4(gammaadj((mon==1?vec3(0,1,0):vec3(1,0,0))*.99*cmult,g),0); //red/grn\n    if ( ip.x==int(iResolution.x*cmult) )                  C = vec4(gammaadj(vec3(1)*.5,g),0); // cmult\n    //if (bf==0 && (bb==0||bb==2)&& mon<3)                 C = vec4(gammaadj(vec3(1,1,1)*.99*cmult,g),0);//gray\n    \n    if (bf==0 && b>=BITSmon_d && (ip.x%(ir.x/mons)==0 && mon<3) )                   C = vec4(vec3(1,1,0),0);     //ylw //|| ip.x==ir.x-1\n    if (bf==0 && (b==BITSmon_d||b==BITSmon_d+1) && (ip.x%(ir.x/mons)==0) && mon<3 ) C = vec4((ip.x<ir.x/2?vec3(1,0,0):vec3(0,1,0)),0);   // r/g\n    //if (bf==bandh/2 && b==BITSmon && mon==0 && abs((x)-.1)<.05 )                     C = vec4(vec3(1,0,1),0); // mark\n    if (bf==bandh/2 && b==BITSmon && mon<=1 && b>=0 && b<=BITS && abs(ip.x-(useimg*monw+20))<10 )                     C = vec4(vec3(1,0,1),0); // mark\n    \n}","name":"Image","description":"","type":"image"}]}