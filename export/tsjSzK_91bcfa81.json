{"ver":"0.1","info":{"id":"tsjSzK","date":"1554385817","viewed":231,"name":"Marching rings","username":"dyla","description":"First raymarcher experiment based on signed distance functions.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","rings","raymarcher","infinity","toruses"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define FAR 300.0\n#define MAXSTEP 250\n#define EPS 0.001\n\nfloat distToTorus(vec3 p) {\n    float mul = 7.2;\n    vec3 pm = mod(p, mul)-0.5*mul;\n    vec3 pd = p - mod(p,mul);\n    float a = iTime*0.5 + pd.z*1.7 + pd.y*0.79 + pd.x;\n    pm = \n    mat3(\n        cos(a), 0.0, -sin(a),\n        0.0   , 1.0, 0.0,\n        sin(a), 0.0, cos(a)\n    )*\n    mat3(\n        1.0   , 0.0   ,  0.0,\n        0.0   , cos(a), -sin(a),\n        0.0   , sin(a), cos(a)\n    )*\n    pm;\n    \n    // https://iquilezles.org/articles/distfunctions\n    vec2 t = vec2(1.0, 0.4);\n    vec2 q = vec2(length(pm.xy)-t.x,pm.z);\n  \treturn length(q)-t.y;\n}\n\nvec3 getRayForPixel(vec2 p, float vAngle) {\n    vec2 uv = p - 0.5*iResolution.xy;\n    float cameraDistToScreen = 0.5*iResolution.y / tan(vAngle/2.0);\n    return normalize(vec3(uv, -cameraDistToScreen));\n}\n\nfloat castRay(vec3 eye, vec3 ray) {\n    float length = 0.0;\n    for (int i=0; i<MAXSTEP; i++) {\n        float dist = distToTorus(eye+length*ray);\n        if (dist<=EPS) {\n            return length;\n        }\n        if (length>=FAR) {\n            return FAR;\n        }\n        length += dist*0.8;\n    }\n    return FAR;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n       distToTorus(p+vec3(EPS,0.0,0.0)) - distToTorus(p-vec3(EPS,0.0,0.0)),\n       distToTorus(p+vec3(0.0,EPS,0.0)) - distToTorus(p-vec3(0.0,EPS,0.0)),\n       distToTorus(p+vec3(0.0,0.0,EPS)) - distToTorus(p-vec3(0.0,0.0,EPS))\n\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.0, iTime, mod(-2.0*iTime,-2048.0));\n    vec3 ray = getRayForPixel(fragCoord, PI/7.0);\n    float a = 2.0*PI * (iMouse.x-0.5*iResolution.x) / iResolution.x;\n    float b = 2.0*PI * (iMouse.y-0.5*iResolution.y) / iResolution.y;\n    ray = mat3(\n        1.0, 0.0   , 0.0,\n        0.0, cos(b), -sin(b), \n        0.0, sin(b), cos(b)\n    ) * mat3(\n        cos(a), 0.0, -sin(a), \n        0.0   , 1.0, 0.0,\n        sin(a), 0.0, cos(a)\n    )  * ray;\n    float len = castRay(eye, ray);\n    vec4 fogColor = vec4(0.75, 0.9, 1.0, 1.0);\n    float fogAmount = len/FAR;\n    fragColor = mix(texture(iChannel0, reflect(ray, getNormal(eye+len*ray))), fogColor, fogAmount);\n}","name":"Image","description":"","type":"image"}]}