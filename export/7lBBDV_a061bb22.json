{"ver":"0.1","info":{"id":"7lBBDV","date":"1652753350","viewed":155,"name":"Easy-to-read distance voronoi","username":"Dubswitcher","description":"Written with literal words to make it easier to figure out how the process works. Took me some time to get this right as I didn't start with nearly any reference on this one at all.\n\nTHIS DOES NOT use IQ's method. I'm still learning that.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","simple","tutorial","fast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(in vec2 uv)\n{ //Random value from coordinates\n    return fract(sin(dot(uv, vec2(14.478473612, 53.252567))) * 37482.1);\n}\n\nvec2 hash2(in vec2 uv)\n{ //Random position from coordinates\n    vec3 o = fract(vec3(uv.yxx*893.335)*vec3(0.146651, 0.185677, 0.135812));\n    o += dot(o.zxy, o.yzx+60.424);\n    return fract((o.yx+o.zy)*o.xz);\n}\n\nfloat voronoi (in vec2 uv, in float zPos, in float seed)\n{\n    float dist = 0., detect = 2.; //distance holder, distance detector\n    vec2 point[9]; //what holds our points for the second loop\n    int thispoint = 0, closest = 0, nextclosest = 0;\n    for (float x = -1.; x <= 1.; x++)\n    { // Loop through a 3x3 grid of cells. For 5x5, use -2 to 2, and increase\n        for (float y = -1.; y <= 1.; y++) // point[9] to point[25]\n        {\n            vec2 cell = vec2(x,y); // Converting to a vec2 for ease of use\n            vec2 ID = floor(uv)-cell+seed; // Identify the cell targeted\n            float rand = (zPos+hash(ID))*(hash(ID)*0.5+0.5); // Cell's random\n            float B = fract(rand); //Randomization blending variable\n            vec3 offs = vec3(floor(rand),ceil(rand),B*B*(3.-2.*B));\n            //All of this is meant to smooth randomness from step to step for\n            //each cell. This can be phased through with time, or a z-depth if\n            //so desired, but it is not true z-depth. Each cell moves at a random\n            //speed as well.\n            point[thispoint] = mix(hash2(ID+offs.x),hash2(ID+offs.y),offs.z)-cell;\n            //Storing the point\n            \n            dist = distance(point[thispoint],fract(uv)); //Find how close the\n            //pixel is to the target point. The detector variable finds which\n            //point is closest by seeing if it its value is greater than the\n            //distance to the point; and if so, setting its value to that distance,\n            //and in the same if-statement setting the closest point to the\n            //currently active point (thispoint).\n            if (dist<detect)\n            {\n                detect = dist;\n                closest = thispoint;\n            }\n            thispoint++;\n        }\n    }\n    detect = 2.; //Resetting the detector for the next round. This next loop\n    //figures out the second closest point by running through the points\n    //again but skipping over a loop if it's about to check the closest one.\n    //If the grid is 5x5, like point[25], set this loop to < 25 instead.\n    for (thispoint = 0; thispoint < 9; thispoint++)\n    {\n        if (thispoint != closest)\n        {\n            dist = distance(point[thispoint],fract(uv));\n            if (dist<detect)\n            {\n                detect = dist;\n                nextclosest = thispoint;\n            }\n        }\n    }\n    //This one is a bit complicated to explain the math of, but what this\n    //does is tell the pixel how far away it is from the intersection of\n    //the distances between the points. I myself barely got this to work\n    //as I am not much of a mathematician. But it works perfectly.\n    return dot(normalize(point[closest]-point[nextclosest]),\n               fract(uv)-point[nextclosest])\n               -distance(point[closest],point[nextclosest])/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y; //Square UV coords\n    float thispixel = voronoi(uv*4.,iTime,0.);\n    \n    thispixel = mix(thispixel,smoothstep(0.02,0.019,thispixel),\n                    smoothstep(-0.1,0.1,-sin(iTime*2.))); //Animation\n    \n    fragColor = vec4(thispixel,thispixel,thispixel,1.0);\n}","name":"Image","description":"","type":"image"}]}