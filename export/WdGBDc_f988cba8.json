{"ver":"0.1","info":{"id":"WdGBDc","date":"1608066779","viewed":252,"name":"Mach Diamonds","username":"xingyzt","description":"Replicating the mach diamonds of an underexpanded rocket exhaust. Generated from IQ's vesica SDF.","likes":11,"published":1,"flags":64,"usePreview":0,"tags":["jet","rocket","exhaust"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"llXXRH","filepath":"https://soundcloud.com/nasa/sls-test-fire","previewfilepath":"https://soundcloud.com/nasa/sls-test-fire","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mach Diamonds!\n\n#define PI     3.1416\n#define t     iTime\n#define start  3.1 // sync with the soundcloud audio\n#define end   23.6\n\nfloat shell(vec2 p,float offset)\n{\n    float main = mvesica(p);\n    float next = min(\n        mvesica(p+vec2(offset,0)),\n        mvesica(p-vec2(offset,0))\n    );\n    return smin(\n        main,\n        next,\n        .15\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime,end);\n\n    float offset = .8;\n    \n    float left = fragCoord.x/iResolution.x;\n    float right = 1.-left;\n\n    vec2 uv = (2.0*fragCoord-vec2(0,iResolution.y))/iResolution.y;\n    uv += .03*perlin(t*.5+left)*(.5+left);\n    uv += .01*perlin(t*7.+left)*(.5+left);\n    uv.y += .01*perlin(t*67.+left)*(.5+left);\n    uv.y += .005*perlin(t*101.+left)*(.5+left);\n    //uv.y /= sqrt(right)*.5+1.;\n    uv.x += .5*(.2-abs(uv.y))*perlin(t*3.);\n    offset += .02*perlin(t*3.);\n    uv*=1.;\n   \n    vec2 p = uv;\n    p.x = mod(p.x,offset)-offset/2.;\n\n    float diamonds = max(smin(\n        vesica(p-vec2(offset-.4,0),.3,.15),\n        max(vesica(p+vec2(offset-.4,0),.85,.7),0.)+.05*(1.-2.*abs(p.x-.1)),\n        .1\n    ),0.);\n    float exhaust = shell(p,offset);\n    float streams = 1.;\n    for(float i = 0.; i<6.; i++){\n        if(perlin(i+t)>.2) continue;\n        p.y+=perlin(i-t)*.05;\n        streams *= (abs(shell(\n            p+vec2(0,sign(p.y)*.005*i*i\n        ),offset))<.005) ? 0. : 1.;\n    }\n    \n    \n    float outside = max(sign(exhaust),0.);\n    float inside = 1.-outside;\n    \n    float soutside = (1.+smoothsign(.1,exhaust))/2.;\n    float sinside = 1.-soutside;\n\n    float d = smin(exhaust,-diamonds,-.03);\n    \n    d = abs(d);\n        \n    \n    float lum = (\n        1.-d\n        *(\n             2. * inside\n            +5. * outside / (left+.2)\n        )\n        *smoothstep(start,start+1.,t)\n        *smoothstep(end,end-1.,t)\n    );\n    lum = clamp(lum,0.,1.);\n    lum = pow(lum,(.9*(inside)+1.5*outside));\n    \n    //if (abs(d) < .005) d = 1.;\n    \n    \n    vec3 col = vec3(lum);\n        \n    col *= vec3(\n        (1.05*sinside+1.40*soutside-left*.0),\n        (1.00*sinside+1.00*soutside-left*.2),\n        (1.40*sinside+1.80*soutside-left*.6)\n    );\n    \n    col -= diamonds;\n    \n    col *= smoothstep(start,start+.1,t)*smoothstep(end,end-.9,t);\n    \n    col *= 1.;//-.1*streams*perlin(.5*uv.x-5.*t+perlin(uv.y+uv.x+t));\n    \n    //col = vec3(streams);\n\n    fragColor = vec4(col,1);\n    //fragColor = vec4(vec3(1.-abs(p.x-.1)),1);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 1D perlin noise by ikuto | https://www.shadertoy.com/view/lt3BWM\n// 2D vesica SDF by iq      | https://www.shadertoy.com/view/XtVfRW\n\n#define HASHSCALE 0.1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash31( vec3 p )\n{\n\tfloat h = dot(p,vec3(17, 1527, 113));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlin(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat vesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.x-b)*d > p.y*b) ? length(p-vec2(b,0.0))*sign(d)\n                               : length(p-vec2(0.0,-d))-r;\n}\n\nfloat mvesica(vec2 p)\n{\n    return vesica(p,1.,.8);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothsign( float s, float d )\n{\n    return smoothstep(-s,s,d)*2.-1.;\n}\n","name":"Common","description":"","type":"common"}]}