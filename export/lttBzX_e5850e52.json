{"ver":"0.1","info":{"id":"lttBzX","date":"1551972594","viewed":846,"name":"Bokeh DoF","username":"nnorm","description":"Based of http://blog.tuxedolabs.com/2018/05/04/bokeh-depth-of-field-in-single-pass.html\nNothing very interesting, I just wanted to try it. \nIt is interactive with the mouse:\nX -> focus scale\nY -> focus point distance","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["dof","bokeh","implementation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//src:  http://blog.tuxedolabs.com/2018/05/04/bokeh-depth-of-field-in-single-pass.html\n\nconst float GOLDEN_ANGLE = 2.39996323; \nconst float MAX_BLUR_SIZE = 8.0; \nconst float RAD_SCALE = 1.0; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n\treturn abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale, vec2 uPixelSize)\n{\n\tfloat centerDepth = texture(iChannel0, texCoord).a * t_max;\n\tfloat centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n\tvec3 color = texture(iChannel0, texCoord).rgb;\n\tfloat tot = 1.0;\n\tfloat radius = RAD_SCALE;\n\tfor (float ang = 0.0; radius<MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)\n\t{\n\t\tvec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n\t\tvec3 sampleColor = texture(iChannel0, tc).rgb;\n\t\tfloat sampleDepth = texture(iChannel0, tc).a * t_max;\n\t\tfloat sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n\t\tif (sampleDepth > centerDepth)\n\t\t\tsampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n\t\tfloat m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n\t\tcolor += mix(color/tot, sampleColor, m);\n\t\ttot += 1.0;   radius += RAD_SCALE/radius;\n\t}\n\treturn color /= tot;\n}\n\n/************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 mrt = texture(iChannel0, uv);\n    vec3 c = depthOfField(uv, 8.0 * (iMouse.y/iResolution.y), 8.0 * (iMouse.x/iResolution.x), 1.0/iResolution.xy);\n    \n    vec2 vuv = uv - vec2(0.5);\n    vuv.x *= iResolution.x/iResolution.y;\n    float vignette = pow(1.0 - length(vuv * vec2(1.0, 1.3)), 1.0/1.0);\n    \n    fragColor = mix(vec4(c, 1.0), vec4(c, 1.0) * vignette, 0.75);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct ObjectMaterial\n{\n    vec4 specGloss;\n    vec4 color;\n};\n    \nstruct SphereData\n{\n    vec4 offsetRadius;\n    ObjectMaterial mat;\n};\n\nconst SphereData spheres[4] = SphereData[4](\n    SphereData(vec4( 0.0, 0.0,  0.0, 0.3), ObjectMaterial(vec4(0.568, 0.0, 0.523,   0.9),    vec4(0.568, 0.0, 0.523, 1.0))),\n    SphereData(vec4(-1.0, -0.4, -0.5, 0.15), ObjectMaterial(vec4(0.268, 0.456, 0.80,  0.6),   vec4(0.268, 0.456, 0.80, 1.0))),\n    SphereData(vec4(-0.5, 0.0, -2.0, 0.5), ObjectMaterial(vec4(0.01, 0.01, 0.01,   0.0),    vec4(0.0, 0.693, 0.921, 1.0))),\n    SphereData(vec4( 0.8, 0.0, -3.0, 0.8), ObjectMaterial(vec4(0.461, 0.233, 0.686, 0.1), vec4(0.461, 0.233, 0.686, 1.0)))\n    );\n\n/************************************************************/\n\nfloat plane(in vec3 p, in vec3 n, in float d)\n{\n    return dot(p, n) + d;\n}\n\nfloat sphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\n/************************************************************/\n\nfloat map(in vec3 p)\n{\n    float sph0 = sphere(p - spheres[0].offsetRadius.xyz, spheres[0].offsetRadius.w);\n    float sph1 = sphere(p - spheres[1].offsetRadius.xyz, spheres[1].offsetRadius.w);\n    float sph2 = sphere(p - spheres[2].offsetRadius.xyz, spheres[2].offsetRadius.w);\n    float sph3 = sphere(p - spheres[3].offsetRadius.xyz, spheres[3].offsetRadius.w);\n    sph0 = min(sph0, min(sph1, min(sph2, sph3)));\n    float bottom_plane = plane(p, vec3(0.0, 1.0, 0.0), 0.5);\n    return min(sph0, bottom_plane);\n}\n  \n\nfloat traceRay(in vec3 ro, in vec3 rd)\n{\n    vec3 p = ro;\n    float d = map(p);\n    float dAcc = d;\n    bool hit = (d < epsilon || dAcc >= t_max);\n    for(int i = 0; i < MAX_SPHERETRACE_STEP; i++)\n    {\n        if(hit)\n            break;\n        else\n        {\n            p += d * rd;\n            d = map(p);\n            dAcc += d;\n            hit = (d < epsilon || dAcc >= t_max);\n        }\n    }\n    return dAcc;\n}\n\nfloat traceShadows(in vec3 pos, in mat4 viewMat)\n{\n    const vec3 lightPos = vec3(-0.8, -0.0, 0.0);\n    vec3 p = pos;\n    vec3 rd = (viewMat * vec4(normalize(lightPos - pos), 0.0)).xyz;\n    float d = map(p);\n    float dAcc = d;\n    const float eps = epsilon * 10.0;\n    bool hit = (d < eps || dAcc >= t_max);\n    for(int i = 0; i < 64; i++)\n    {\n        if(hit)\n            break;\n        else\n        {\n            p += d * rd;\n            d = map(p);\n            dAcc += d;\n            hit = (d < eps || dAcc >= t_max);\n        }\n    }\n    return dAcc;\n}\n\nObjectMaterial getMaterial(in vec3 p)\n{\n    float sph0 = sphere(p - spheres[0].offsetRadius.xyz, spheres[0].offsetRadius.w);\n    float sph1 = sphere(p - spheres[1].offsetRadius.xyz, spheres[1].offsetRadius.w);\n    float sph2 = sphere(p - spheres[2].offsetRadius.xyz, spheres[2].offsetRadius.w);\n    float sph3 = sphere(p - spheres[3].offsetRadius.xyz, spheres[3].offsetRadius.w);\n    \n    float d = map(p);\n    if(d == sph0)\n        return spheres[0].mat;\n    else if(d == sph1)\n        return spheres[1].mat;\n    else if(d == sph2)\n        return spheres[2].mat;\n    else if(d == sph3)\n        return spheres[3].mat;\n    else\n        return ObjectMaterial(vec4(0.5, 0.5, 0.5, 1.0), vec4(0.40, 0.40, 1.0, 1.0));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 eps = vec2(epsilon, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n \t\n    vec3 ro = vec3(-0.8, 0.1, 1.5);\n    mat4 viewMat = LookAtRH( ro, vec3(-0.8, 0.2, 0.0), vec3(0.0, 1.0, 0.0) );\n    vec4 camRd = viewMat * normalize(vec4(uv, -1.0, 0.0));\n    vec3 rd = camRd.xyz;\n    \n\tfloat tRes = traceRay(ro, rd);\n    \n    float lineardepth = tRes / t_max;\n    vec3 outputColor;\n    if(tRes >= t_max)\n        outputColor = mix(vec3(0.495,0.398,0.271), vec3(0.923,0.722,0.391), pow(length(uv + vec2(0.0, -0.1)), -1.0));\n    else\n    {\n        vec3 P = rd * tRes + ro;\n        vec3 N = calcNormal(ro + rd * tRes);\n        vec3 V = normalize(ro - P);\n        float NoV = max(0.0, dot(N, V));\n        ObjectMaterial mat = getMaterial(P);\n        vec3 lambertianDiffuse = mat.color.rgb * (1.0 - max(mat.specGloss.r, max(mat.specGloss.g, mat.specGloss.b)));\n        lambertianDiffuse /= PI;\n        vec3 lightPos = vec3(-0.8, -0.0, 0.0);\n\n        vec3 L = (lightPos - P); \n        vec3 H = normalize(L + V);\n\n        float NoL = max(0.0, dot(N, L));\n        float NoH = max(0.001, dot(N, H));\n\n        float att = length(L);\n        att = 1.0 / (att*att);\n        L = normalize(L);\n\n        float alpha = max(0.00001, (1.0-mat.specGloss.a));\n        alpha *= alpha;\n        vec3 spec =  d_trowbridge_reitz(NoH, alpha*alpha)\n                   * f_schlick(NoH, mat.specGloss.rgb)\n                   * g_smith(NoV, NoL, alpha);\n        spec /= 4.0*NoL*NoV;\n\n        outputColor = (lambertianDiffuse + max(vec3(0.000001), spec)) * NoL * att * 10.0;\n    }\n\n    //Ouput \"G-Buffer\"\n    // R  G  B  A\n    // [COLOR]  [DEPTH]    \n    fragColor = vec4(pow(outputColor, vec3(1.0/2.22)), lineardepth);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define MAX_SPHERETRACE_STEP 512\n\nconst float infinity = 9999999.9999999;\nconst float t_min = 0.0;\nconst float t_max = 1024.0;\nconst float epsilon = 0.0001;\n\n/************************************************************/\n\n//src: https://thebookofshaders.com/10/\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//src: https://www.3dgep.com/understanding-the-view-matrix/\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(eye - target);    // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);     // The \"up\" vector.\n \n    // Create a 4x4 view matrix from the right, up, forward and eye position vectors\n    mat4 viewMatrix = mat4(\n        vec4(      xaxis.x,            yaxis.x,            zaxis.x,       0 ),\n        vec4(      xaxis.y,            yaxis.y,            zaxis.y,       0 ),\n        vec4(      xaxis.z,            yaxis.z,            zaxis.z,       0 ),\n        vec4(-dot( xaxis, eye ), -dot( yaxis, eye ), -dot( zaxis, eye ),  1 )\n    );\n     \n    return viewMatrix;\n}\n\n/************************************************************/\n\nvec3 f_schlick(in float NoH, in vec3 R0)\n{\n    return R0 + (1.0-R0)*pow(1.0-NoH, 5.0);\n}\n\nfloat d_trowbridge_reitz(in float NoH, in float a2)\n{\n    return a2 / (PI*pow((NoH*NoH)*(a2-1.0)+1.0, 2.0));\n}\n\nfloat g_schlick_ggx(in float NoV, in float a)\n{\n    float k = a * 0.5;\n    return NoV / (NoV*(1.0-k) + k);\n}\n\nfloat g_smith(in float NoV, in float NoL, in float a)\n{\n    return g_schlick_ggx(NoV, a) * g_schlick_ggx(NoL, a);\n}\n","name":"Common","description":"","type":"common"}]}