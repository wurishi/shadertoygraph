{"ver":"0.1","info":{"id":"Dsc3DX","date":"1677903417","viewed":99,"name":"Car tires","username":"ianertson","description":"Some rusty old car tires, use the mouse to look around :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","raymarch","marching","textures","wheel","art","car","tire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_TIRE 2\n#define ID_TIRE_RIM 3\n#define ID_TIRE_RIM_SCREW 4\n\n\nvec3 snoise(\n    in vec2 uv,\n    in float seed,\n    in float lod,\n    in float freq,\n    in float warp,\n    const in int levels) {\n    uv += 1.002928281924;\n    return snoise(iChannel3, uv, seed, lod, freq, warp, levels);\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat tireSDF(in vec3 p, inout int id) {\n    id = ID_TIRE;\n  //  p.yz *= rot(T);\n    float thick = 0.3;\n    float size = 1.;\n    float ff = smoothstep(0.0, 0.6, max(0.0, abs(p.y)-0.2));\n    float base = torusSDF(p, size, max(0.001, thick - ff));\n    \n    \n    \n    float rimHeight = thick*0.8;\n    float rimRad = size*0.9;\n    float rim = cylSDF(p - vec3(0, -rimHeight/2., 0), vec3(0, 0, 0), vec3(0, rimHeight, 0), rimRad);\n    float bulgeHeight = rimHeight*0.41;\n    \n    float bulgeRad = rimRad*0.56;\n    float rimBulge = cylSDF(\n        vec3(p.x, abs(p.y), p.z) - vec3(0., bulgeHeight, 0), vec3(0, 0, 0), vec3(0, bulgeHeight, 0), bulgeRad) - 0.013;\n      \n    float rimBulgeIn = cylSDF(\n        vec3(p.x, abs(p.y), p.z) - vec3(0, bulgeHeight+(bulgeHeight*0.4), 0), vec3(0, 0, 0), vec3(0, bulgeHeight, 0), bulgeRad*0.7);\n    rimBulge = max(rimBulge, -rimBulgeIn);\n    rim = min(rim, rimBulge);\n    float bulgeOut = sphereSDF(vec3(p.x, abs(p.y), p.z) - vec3(0, bulgeHeight*0.1, 0), bulgeRad*0.64);\n   \n    rim = smin(rim, bulgeOut, 0.12);\n    float d = min(base, rim);\n    \n    if (rim < base) id = ID_TIRE_RIM;\n    \n    \n    \n    vec3 nn = normalize(p);\n    float v = atan(nn.x, nn.z)*2.0-1.0;\n    float screwHeight = 0.05;\n    float screwR = 0.05;\n\n    float screw1 = cylSDF(vec3(abs(p.x), abs(p.y), p.z) - vec3(0.4, rimHeight-0.06, 0.0), vec3(0, 0, 0), vec3(0, screwHeight, 0), screwR)-0.009;\n    float screw2 = cylSDF(vec3(p.x, abs(p.y), abs(p.z)) - vec3(0.0, rimHeight-0.06, 0.4), vec3(0, 0, 0), vec3(0, screwHeight, 0), screwR)-0.009;\n    \n\n    float screw = min(screw1, screw2);\n    \n    \n    \n    if (screw < d) { id = ID_TIRE_RIM_SCREW; };\n    \n    d = min(d, screw);\n    \n    return d;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int id = ID_NONE;\n    int skip = data.skip;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    SAMPLE(groundSDF(p), o, ID_GROUND);\n   \n    {\n        int tireId = 0;\n        float rt = T*0.6;\n        Object oTire = Object(vec3(0, 1.6, 0), vec3(cos(rt), rt, 0));\n        float tire = tireSDF(pointRot(p - oTire.p, oTire.r), tireId);\n        SAMPLE_CHECK(tire, oTire, tireId);\n    }\n    \n    {\n        int tireId = 0;\n        float rt = T*0.6;\n        Object oTire = Object(vec3(-0.9, 0.4, 3), vec3(0, 0, radians(-10.)));\n        float tire = tireSDF(pointRot(p - oTire.p, oTire.r), tireId);\n        SAMPLE_CHECK(tire, oTire, tireId);\n    }\n    \n    {\n        int tireId = 0;\n        float rt = T*0.6;\n        Object oTire = Object(vec3(-3., 0.2, 3), vec3(0, 0, 0));\n        float tire = tireSDF(pointRot(p - oTire.p, oTire.r), tireId);\n        SAMPLE_CHECK(tire, oTire, tireId);\n    }\n    \n    {\n        int tireId = 0;\n        float rt = T*0.6;\n        Object oTire = Object(vec3(2., 0.2, 0), vec3(0, 0, 0));\n        float tire = tireSDF(pointRot(p - oTire.p, oTire.r), tireId);\n        SAMPLE_CHECK(tire, oTire, tireId);\n    }\n    \n    data.id = id;\n    data.o = o;\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        float sd = sdf(data, ro+rd*d);\n        d += sd;\n        if (abs(sd) <= NEAR) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) -\n        vec3(sdf(data, p - e.xyy), sdf(data, p - e.yxy), sdf(data, p - e.yyx)));\n    data.p = p;\n    data.n = n;\n    data.d = d;\n    \n    return true;\n}\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        float sd = sdf(data, ro+rd*d);\n        d += sd;\n        if (abs(sd) <= NEAR) break;\n        if (abs(d) >= far) return 1.0;\n    }\n    return clamp(d/(1.0+d), AMBIENT, 1.0);\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(0, p+(n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p));\n        \n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec2 uv = rd.xz / rd.y;\n    vec3 blue = rgb(99, 171, 221);\n    vec3 col = pow(blue*blue, vec3(1.0 + (dotup*2.)));\n    return col;\n}\n\n//#define DEBUG_TEXTURE screwTexture\n\nvec3 screwTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n  //  uv = abs(uv);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 hf1 = snoise(uv, 16.3333333129, 0.0, 86., 0., 4);\n    vec3 hf2 = abs(normalize(reflect(mix(grain, hf1, 0.8), hf1)));\n    vec3 lf1 = snoise(uv, 0.2232921856, 0.5, 9., 0.9, 6);\n    vec3 lf2 = abs(normalize(cross(reflect(lf1, hf2), hf1)));\n    vec3 lf3 = snoise(uv, 7.74982872125, 0.1, 10., 0.1, 6);\n    \n    vec3 m1 = rgb(171, 164, 148);\n    vec3 m2 = rgb(167, 156, 148);\n    vec3 m3 = rgb(172, 163, 165);\n    vec3 m4 = rgb(83, 82, 88);\n    \n    vec3 metalColor = mix(mix(mix(m1, m2, lf1.x), m3, lf1.y), m4, lf1.z);\n    metalColor = mix(metalColor, mix(m3, m4, hf2.y), hf2.x*0.5);\n    col += metalColor;\n    \n    vec3 r1 = rgb(162, 122, 101);\n    vec3 r2 = rgb(158, 88, 71);\n    vec3 r3 = rgb(100, 58, 61);\n    vec3 r4 = rgb(170, 115, 38);\n    \n    vec3 rustCol = mix(mix(mix(r1, r2, grain.x), r3, grain.y), r4, grain.z);\n    rustCol = mix(rustCol, rustCol*rustCol, lf2.x*lf1.z);\n    \n    float rustReg = smoothstep(0.45, 1.0, lf3.x+(grain.x*0.05));\n    \n    rustReg += smoothstep(0.7, 1., length(p.xz))*(0.5+(0.5*grain.y));\n    \n    rustReg = clamp(rustReg, 0.0, 1.0);\n    \n    col = mix(col, rustCol*rustCol, rustReg);\n    \n    m.spec = clamp(max(0.0, 1.0 - rustReg), 0.0, lf3.x);\n    \n    vec2 cent = abs(uv*2.0-1.0);\n    \n    float lineV = smoothstep(0.3, 0.1, cent.x+0.2);\n    float lineH = smoothstep(0.4, 0.1, cent.y+0.2);\n    float line = mix(lineV, max(0.0, lineH-lineV), lineH);\n    \n    line = mix(line, 0.0, smoothstep(0.5, 1.2, length(cent)));\n    \n    col = mix(col, col*col*col*col, line);\n    col = mix(col, col*col, max(0.0, 1.0-smoothstep(0.4-0.05, 0.4+0.05, length(cent)+0.2)));\n    \n    \n    return col;\n}\n\nvec3 metalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 hf1 = snoise(uv, 3.3333333129, 0.0, 86., 0., 4);\n    vec3 hf2 = abs(normalize(reflect(mix(grain, hf1, 0.8), hf1)));\n    vec3 lf1 = snoise(uv, 2.2232921856, 0.5, 9., 0.9, 6);\n    vec3 lf2 = abs(normalize(cross(reflect(lf1, hf2), hf1)));\n    vec3 lf3 = snoise(uv, 14.4982872125, 0.1, 10., 0.1, 6);\n    \n    vec3 m1 = rgb(171, 164, 148);\n    vec3 m2 = rgb(167, 156, 148);\n    vec3 m3 = rgb(172, 163, 165);\n    vec3 m4 = rgb(83, 82, 88);\n    \n    vec3 metalColor = mix(mix(mix(m1, m2, lf1.x), m3, lf1.y), m4, lf1.z);\n    metalColor = mix(metalColor, mix(m3, m4, hf2.y), hf2.x*0.5);\n    col += metalColor;\n    \n    vec3 r1 = rgb(162, 122, 101);\n    vec3 r2 = rgb(158, 88, 71);\n    vec3 r3 = rgb(100, 58, 61);\n    vec3 r4 = rgb(170, 115, 38);\n    \n    vec3 rustCol = mix(mix(mix(r1, r2, grain.x), r3, grain.y), r4, grain.z);\n    rustCol = mix(rustCol, rustCol*rustCol, lf2.x*lf1.z);\n    \n    float rustReg = smoothstep(0.5, 1.0, lf3.x+(grain.x*0.05));\n    \n    rustReg += smoothstep(0.4, 0.6, length(p.xz))*(0.5+(0.5*grain.y));\n    \n    rustReg = clamp(rustReg, 0.0, 1.0);\n    \n    col = mix(col, rustCol*rustCol, rustReg);\n    \n    m.spec = clamp(max(0.0, 1.0 - rustReg), 0.0, lf3.x);\n    \n    return col;\n}\n\nvec3 tireTexture(in vec2 uv, in vec3 p, inout Material m, in float side) {\n    vec3 col = vec3(0.0);\n    \n    float tile = 2.0;\n    \n    vec2 uuv = uv*tile;\n    vec2 id = floor(uuv);\n    vec2 lv = fract(uuv);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float thick = 0.016;\n    float g = max(0.0, 1.0 - ceil(min(lv.x, lv.y)-thick));\n    \n    vec2 sublv = fract(lv * 4.0);\n    vec2 subid = floor(lv * 4.0);\n\n    \n    vec2 a = vec2(0, 0);\n    vec2 b = vec2(1, alv.x-alv.y);\n    vec2 pp = alv;\n    vec2 pa = pp - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float l = length(pa - ba * h);\n  \n    \n    \n    vec3 c1 = rgb(62, 63, 67);\n    vec3 c2 = rgb(76, 72, 79);\n    vec3 c3 = rgb(39, 39, 39);\n    vec3 c4 = rgb(51, 51, 51);\n    \n    vec3 hf1 = snoise(uv, 7.7391235, 0.0, 100., 0., 4);\n    \n    vec3 rubCol = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    \n    col += rubCol;\n    \n    vec3 grain = textureLod(iChannel3, uv*0.1, 0.0).xyz;\n    vec3 grainCol = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    col = mix(col, grainCol*grainCol, max(0.0, 1.0-(side*0.1)));\n  \n    float pat = clamp(1.0-(l/0.4), 0.0, 1.0)*side;\n\n    col = mix(col, col*col, pat);\n    \n    \n    m.spec = clamp(max(0.0, 1.0-side)*grain.x, 0.0, 1.0)*hf1.x*grain.y*0.2;\n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grain = textureLod(iChannel3, uv*0.5, 0.0).xyz;\n    vec3 hf1 = snoise(uv, 1.2018182, 0.0, 100., 0., 2);\n    vec3 hf2 = snoise(uv, 4.4492818, 0.0, 96., 0., 3);\n    vec3 lf1 = snoise(uv, 7.7793833, 1., 0.5, 0., 6);\n    vec3 lf2 = snoise(uv, 10.9992822, 2., 6.0, 0.2, 6);\n    \n    vec3 g1 = rgb(42, 75, 7);\n    vec3 g2 = rgb(83, 79, 48);\n    vec3 g3 = rgb(118, 116, 75);\n    vec3 g4 = rgb(100, 97, 48);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    grassCol = mix(grassCol, grassCol*grassCol, grain.x*hf1.x);\n    \n    vec3 d1 = rgb(122, 106, 91);\n    vec3 d2 = rgb(87, 69, 52);\n    vec3 d3 = rgb(155, 134, 98);\n    vec3 d4 = rgb(93, 88, 78);\n    \n    vec3 dirtCol = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n    dirtCol = mix(dirtCol, dirtCol*dirtCol, lf2.x);\n    \n    \n    col += grassCol;\n    \n    float dirtReg = clamp(pow(lf1.x, 3.0)*6., 0.0, 1.0);\n    \n    col = mix(col, dirtCol, dirtReg);\n    \n    col = mix(col, col*col, grain.z*grain.z*0.5);\n    col = mix(col, col*col, lf2.x*lf2.x);\n    \n    m.spec = clamp(mix(grain.x*lf1.x, hf1.y*lf1.y, dirtReg*lf2.y)*0.2, 0.0, dirtReg*lf1.x);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    \n    vec3 col = grassTexture(uv, p, data.m);\n    \n    return col;\n}\n\nvec3 getAlbedoTire(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.r);\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, pointRot(n, data.o.r))*3.;\n    vec3 col = vec3(0.0);\n    float side = smoothstep(0.9, 1.0, max(0.0, length(p.xz)-0.3));\n    col = tireTexture(uv, p, data.m, side);\n    return col;\n}\n\nvec3 getAlbedoTireRim(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.r);\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, pointRot(n, data.o.r));\n    vec3 col = vec3(0.0);\n    col = metalTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoTireRimScrew(inout Data data) {\n    vec3 p = abs(pointRot(data.p - data.o.p, data.o.r)) - vec3(-0.4, 0., -0.4);\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, pointRot(n, data.o.r));\n    vec3 col = vec3(0.0);\n    col = screwTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_TIRE: return getAlbedoTire(data); break;\n        case ID_TIRE_RIM: return getAlbedoTireRim(data); break;\n        case ID_TIRE_RIM_SCREW: return getAlbedoTireRimScrew(data); break;\n    }\n    return vec3(0.77);\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.71, 0.59), 2.0, LIGHT_AMBIENT);\n    \n    if (march(data, ro, rd)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        for (int i = 0; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd, diffuse);\n        }\n    } else {\n        col += getSky(rd);\n    }\n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -3.6);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (length(m.xy) > 0.0001 && m.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    \n    ro.y += 1.5;\n   \n    ro.y = max(1.5, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    Data data = NEW_DATA;\n    getRay(uv, m, ro, rd);\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    col /= 1.0 + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime+4.11)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define AMBIENT 0.05\n\n#define SAMPLE_CHECK(var, OB, id_) if (id_ != skip && var < dist) { dist = var; id = id_; o = OB; }\n#define SAMPLE(funcall, OB, id_) { float tmp = skip == id_ ? FAR : funcall; SAMPLE_CHECK(tmp, OB, id_); }\n\n\nfloat luma(in vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n\nstruct Material { float rough; float spec; float metallic; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Object { vec3 p; vec3 r; };\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Data { vec3 p; vec3 n; float d; int id; int skip; Material m; Object o; };\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, 0, 0, NEW_MATERIAL, NEW_OBJECT )\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * (pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 boxUvSoft(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.zy, (adot(n, vec3(1, 0, 0)))), p.xz, (adot(n, vec3(0, 1, 0))));\n\n}\n\nvec3 noise(in sampler2D tex, in vec2 p, in float seed, in float lod) { \n    return textureLod(tex, (p + (seed*10.0029281835))/256., lod).xyz;\n}\nvec3 snoise(in sampler2D tex, in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p); vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(noise(tex, id, seed, lod), noise(tex, id + vec2(1, 0), seed, lod), lv.x),\n        mix(noise(tex, id + vec2(0, 1), seed, lod), noise(tex, id + vec2(1, 1), seed, lod), lv.x),\n     lv.y);\n}\n\nvec3 snoise(\n    in sampler2D tex,\n    in vec2 p,\n    in float seed,\n    in float lod,\n    in float freq,\n    in float warp,\n    const in int levels\n) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.;\n        p += (vec2(n.x, n.y)*2.0-1.0)*warp;\n        seed += n.z*warp;\n    }\n    return n / div;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(float v, float mi, float ma, float k) {\n    return smax(mi, smin(ma, v, k), k);\n}\n\nfloat sabs(float a, float k) {\n    return smax(-a, a, k);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 pointRotInv(in vec3 p, in vec3 r) {\n    p.yz *= inverse(rot(r.x));\n    p.xz *= inverse(rot(r.y));\n    p.xy *= inverse(rot(r.z));\n    return p;\n}","name":"Common","description":"","type":"common"}]}