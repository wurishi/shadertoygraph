{"ver":"0.1","info":{"id":"WsyXzW","date":"1595479333","viewed":393,"name":"Mountain Fly-by","username":"wessles","description":"Simple ray-marched terrain.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CAM_ROTATE\n\n#define ITER 50\n#define BASE_FOV 1.0\n\nstruct HitResult {\n\tfloat dist;\n    vec3 col;\n};\n    \nfloat rand(vec2 co) {\n    return fract(sin(dot(co ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = rand(i);\n    float b = rand(i+vec2(1.,0.));\n    float c = rand(i+vec2(0.,1.));\n    float d = rand(i+vec2(1.,1.));\n    \n    vec2 u = f*f*(3.-2.*f);\n     \n    float n = mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;\n    n = abs(n);\n    n = 1.-n;\n    n*=pow(n,2.);\n    return n;\n}\n\n#define OCT 6\n#define SCL 2.1;\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float freq = 0.;\n    \n    for(int i = 0; i < OCT; i++) {\n        value += amplitude * (1.-pow(1.-noise(st),5.));\n        st *= SCL;\n        amplitude *= 0.45;\n    }\n    \n    return value;\n}\n\n\n#define scale 1.\nfloat dist(vec3 p) {\n    float d = p.y+fbm(p.xz);\n    d = min(d, p.y+0.6);\n    return d;\n}\n    \nvec3 calcNormal(vec3 pos)\n{\n    // Center sample\n    float c = dist(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.1, 0.0);\n    return normalize(vec3( dist(pos + eps_zero.xyy), dist(pos + eps_zero.yxy), dist(pos + eps_zero.yyx) ) - c);\n}\n\nHitResult march(vec3 o, vec3 r) {\n    HitResult result;\n    \n    result.col = vec3(1.,1.,1.);\n    result.dist = 0.;\n    \n    vec3 p = o;\n    \n    for(int i = 0; i < ITER; i++) {\n        float d = dist(p)*.7;\n        p += r*d;\n        result.dist += d;\n    }\n    vec3 normal = calcNormal(p);\n    float light = max(0., dot(normal, normalize(vec3(1.,10., 1.))));\n    result.col = mix(vec3(.9, 0.86, 0.87), vec3(0.1,0.5,0.1), (-p.y)*2.);\n    if(p.y < -0.58) result.col = vec3(0.,0.,1.);\n    result.col *= light;\n    \n    return result;\n}\n\n// hue2rgb function I ripped off.\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    float yrot = .43;\n    vec3 origin = vec3(0,yrot,0.);\n    \n    float r = iMouse.x/100. + iTime * .2;\n    mat2 rot = mat2(cos(r),-sin(r),sin(r),cos(r));\n    yrot /=2.;\n    ray.yz *= mat2(cos(yrot),-sin(yrot),sin(yrot),cos(yrot));\n    origin.xz *= rot;\n    ray.xz *= rot;\n    \n    origin += vec3(1000., 0, sin(iTime / 5.0) * 50.0);\n    \n    \n    if(ray.y >0.) {\n        fragColor = vec4(1.);\n    } else {\n        HitResult hit = march(origin, ray);\n        float t = hit.dist;\n\n\n        vec3 col = mix(hit.col, vec3(1.), t/20.);\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}