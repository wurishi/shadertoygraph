{"ver":"0.1","info":{"id":"cddBWn","date":"1697039228","viewed":36,"name":"SoundTest_Shadermaker","username":"shadermaker123","description":"sound","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(1);\n    col.xyz = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float time = iTime * bps / loopBeats;\n    float loopTime = time - floor(time); \n    float beatTime = iTime * bps;\n    float s = SampleImage(uv.x, uv.y);\n    s = 1. - (pow(1. - s, 32.));\n    col.xyz *= s;\n    col.xyz = max(col.xyz, vec3(1.-pow((uv.x - loopTime)*400., 2.)));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float spectrumFromImage(float baseNote, float time)\n{\n    float sum = 0.;\n    float weightSum = 0.;\n    float loopTime = time * bps / loopBeats;\n    loopTime -= floor(loopTime);\n    for(int i=0; i<spectrumSamples; i++){\n        float i01 = float(i) / float(spectrumSamples);\n        float i11 = i01 * 2. - 1.;\n        i11 = clamp(i11, -1., 1.);\n        float offset = i11 * noteRange;\n        float note = baseNote + offset;\n        float samplePosY = i01;\n        float weight = SampleImage(loopTime, samplePosY);\n        float freq = noteToFreq(note);\n        sum += Wave1(freq, time + sin(float(i))) * weight;\n        weightSum += weight;\n    }\n    float wave = sum/max(1., weightSum);\n    wave = sum/ float(spectrumSamples);\n    return wave;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float note = 12.;\n    float spectrumImageWave = spectrumFromImage(note, time);\n    return vec2(spectrumImageWave * masterVolume);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define bpm 300.\n#define bps bpm/60.\n#define loopBeats (4.*8.)\n#define noteRange 90.\n#define spectrumSamples 5000\n#define masterVolume 200.\n\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat rand(in vec2 p,in float t)\n{\n    return fract(sin(dot(p+mod(t,1.0),vec2(12.9898,78.2333)))*43758.5453);\n}\n\nfloat rand(float seed, float t)\n{\n    return rand(vec2(seed, seed+0.7534), t);\n}\n\nfloat stair(float v, float step){\n    v /= step;\n    return (v - floor(v)) * step;\n}\n\nfloat frac(float x)\n{\n    return x - floor(x);\n}\nfloat softFrac(float x)\n{\n    float fx = frac(x);\n    return min(fx, 10. - fx * 10.);\n}\n\n\nfloat evenlope(float relTime, float attack, float decay)\n{\n    return min(relTime * attack + exp(1. * -decay), exp(relTime * -decay));\n}\n\n\nfloat Wave0(float freq, float time)\n{\n    float t = freq * time;\n    t += sin(t * 0.1)*.2* sin(freq);\n    float tp = t * PI;\n    float r = ((t-floor(t))-0.5)*0.00;\n    return r + pow(abs(sin(tp)), 0.5) * sign(sin(tp));\n}\nfloat Wave1(float freq, float time)\n{\n    float t = freq * time;\n    //t += sin(t * 0.1)*.2* sin(freq);\n    float tp = t * PI * 2.;\n    float r = ((t-floor(t))-0.5)*0.00;\n    return sin(tp);\n}\n\nfloat noteToFreq(float note){\n    float c2 = 65.41;\n    return c2 * pow(2., note/12.);\n}\n\n\nfloat SampleImage(float x, float y)\n{\n    vec2 uv = vec2(x,y);\n    \n    float beatTime = x * (loopBeats);\n    float beatIndex = floor(beatTime);\n    float beatFrac = (beatTime - beatIndex);\n    float note = -6. - stair(beatIndex*1., 4.);\n    note += stair(ceil(-beatIndex*0.5 / 4.)-1., 2.);\n    \n    vec2 uvDist = uv;\n    //uvDist.y += sin(uv.x * 800.)*0.001;\n    float o;\n    \n    \n    float ev = evenlope(beatFrac, 15., 1.5);\n    \n    //ArpegioA\n    float a;\n    float freqFalloffA = (sin(x * 500.) + 1.5) * 80.;\n    a = (1. - abs(uv.y-0.5 + (note) / noteRange) * freqFalloffA) * ev;\n    a = clamp(a, 0., 1.);\n    a = pow(a, 8.);\n    \n    //ArpegioB\n    float b;\n    float freqFalloffB = (sin(x * 500.) + 1.5) * 80.;\n    b = (1. - abs(uv.y-0.5 + (note + 6.) / noteRange) * freqFalloffB) * ev;\n    b = clamp(b, 0., 1.);\n    b = pow(b, 8.);\n    \n    //ArpegioNoise\n    float c;\n    float freqFalloffC = 0.5;\n    float evC = evenlope(beatTime - floor(beatTime), 2., 0.8);\n    c = (1. - abs((uv.y - 0.6) * freqFalloffC)) * evC;\n    c = clamp(c, 0., 1.);\n    c = pow(c, 8.);\n    c *= (sin(beatFrac * 6. * PI) + 3.) * 0.2;\n    \n    //Chrash\n    float d;\n    float timeD = x*2.;\n    float evD = evenlope(timeD - floor(timeD), 50., 0.3);\n    evD = pow(evD, 4.);\n    float freqFalloffD = 4.;\n    d = (1. - abs((uv.y - 0.8) * freqFalloffD)) * evD;\n    d = clamp(d, 0., 1.);\n    d = pow(d, 8.);\n    \n    //HighHat\n    float e;\n    float timeE = x*16.;\n    bool fastHighHat = frac(x*2.) > 1.-1./8.;\n    if(fastHighHat) timeE *= 4.;\n    float evE = evenlope(timeE - floor(timeE), 40., fastHighHat?0.05:0.2);\n    evE = pow(evE, 6.);\n    float freqFalloffE = 5.;\n    e = (1. - abs((uv.y - 0.9 + cos(x * PI * 2.)*0.02) * freqFalloffE)) * evE;\n    e = clamp(e, 0., 1.);\n    e = pow(e, 8.);\n    //d *= (sin(beatFrac * 6. * PI) + 3.) * 0.2;\n    \n    \n    //Base\n    float f;\n    float timeF = x*4.;\n    float noteF = 2. + stair(ceil(-beatIndex*0.5 / 4.)-1., 2.)*4.;\n    float evF = evenlope(timeF - floor(timeF), 2., 0.5);\n    float freqFalloffF = 80.;\n    float freqMask = pow(max(0., sin(noteF + uv.y * 20000. * PI / noteRange)), 20.);\n    f =  clamp((1. - abs(uv.y-0.5 + (noteF   ) / noteRange) * freqFalloffF) * freqMask * evF, 0., 1.);\n    f += clamp((1. - abs(uv.y-0.5 + (noteF-8.) / noteRange) * freqFalloffF) * freqMask * evF, 0., 1.);\n    f = pow(f, 4.);\n    \n    //BaseNoise\n    float g;\n    float timeG = x*4.;\n    float noteG = -4.;\n    float freqFalloffG = 4.;\n    g =  clamp((1. - abs(uv.y-0.5 + noteG / noteRange) * freqFalloffG) * evF, 0., 1.);\n    g = pow(g, 2.);\n    \n    \n    \n    o= a*0.4 + b * 0.8 + c * 0.01 + d * 0.02 + e * 0.02 + f*0.5 + g*0.005;\n    o = clamp(o, 0., 1.);\n    \n    // Output to screen\n    return o;\n}","name":"Common","description":"","type":"common"}]}