{"ver":"0.1","info":{"id":"mtXyD7","date":"1690819994","viewed":3374,"name":"bomlka","username":"lamogui","description":"Bob-omb performing polka\nShader used for my 64k entry at evoke 2023 https://www.pouet.net/prod.php?which=94746","likes":57,"published":1,"flags":0,"usePreview":1,"tags":["intro","mario","64k","bobomb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float dLimit = 0.00001;\nconst float dFar = 80.;\n\n#define PI 3.14159265\n\n#define M_SKY        0.\n#define M_FLOOR      1.\n#define M_B          2.\n#define M_BFOOT  \t 3.\n#define M_BEYE  \t 4.\n#define M_BHAT  \t 5.\n#define M_BFIL  \t 6.\n#define M_BKEY  \t 7.\n#define M_TER  \t\t 8.\n\n#define mmin( d, n, m ) ( n < d.x ) ? vec2( n, m ) : d;\n\nfloat beat1 = 0.0;\nfloat beat2 = 0.0;\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nvec3 noise3( float n ) {\n\treturn vec3( rand( n ), rand(n*.520 + 1.546), rand(n*3.10 - 0.56) );\n}\nvec3 noise33( vec3 n ) {\n\treturn vec3( rand( n.x ), rand(n.y), rand(n.z) );\n}\n\nfloat box( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nmat2 rot( float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat2( c, s, -s, c );\n}\n\nfloat ell( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\nfloat rc( vec3 p, float r1, float r2, float h )\n{\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 map(vec3 p); \n\nvec3 grad( in vec3 p )\n{\n\tvec3 e = vec3(0.01, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+e.xyy).x-map(p-e.xyy).x,\n\t\tmap(p+e.yxy).x-map(p-e.yxy).x,\n\t\tmap(p+e.yyx).x-map(p-e.yyx).x\n\t) );\n}\n\nvec4 rm(vec3 ro, vec3 rd, out float st)\n{\n\tvec3 p = ro;\n\tfloat d;\n\tvec2 dmat = vec2( 100000.0, M_SKY);\n\tst = 1.;\n\tfor (float i = 0.; i < 150.; i++)\n\t{\n\t\tdmat = map(p);\n\t\td = distance(ro, p);\n\t\tif (abs(dmat.x) < dLimit || d > dFar)\n\t\t{\n\t\t\tst = i/150.;\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * dmat.x;\n\t}\n\treturn vec4(p, dmat.y);\n}\n\n\nvec3 fogged( vec3 c, float f ) {\n\treturn mix( c, vec3(.529, .808, .922 ), f );\n}\nfloat foggedR( float r, float f ) {\n\treturn mix( r, 0.0, f );\n}\n\n\nfloat shade( out vec3 c, float m, vec3 o, vec3 p, float st, vec3 n, vec3 rd ) {\n\t\n\tfloat f = 1.0 - exp( - 0.1 * distance(o,p) );\n\n\tif ( m < M_SKY + 0.5) {\n\t\tc = fogged( vec3( .529, .808, .922 ), f );\n\t\treturn foggedR( .0, f);\n\t} else if (  m < M_FLOOR + 0.5) {\n\t\tc = fogged( vec3( .5, .5, .5 ), f);\n\t\treturn foggedR( 0.5, f);\n\t} else if ( m < M_B +0.5) {\n\t\tc = fogged( vec3( .01, .01, .01 ), f );\n\t\tc *=st;\n\t\t//if ( track_time < 69.05 ) {\n\t\t\treturn foggedR( 0.2, f);\n\t\t//} else {\n\t\t//\tc = mix( c, n * .5 + .5, 0.1);\n\t\t//\treturn foggedR( 0.05, f);\n\t\t//}\n\t} else if ( m < M_BFOOT +0.5) {\n\t\tc = .8*(1.-st)*fogged( vec3( 1., .5, .0 ), f );\n\t\treturn 0.;\n\t}  else if ( m < M_BEYE +0.5) {\n\t\tc = fogged( vec3( 1., 1., 1.0 ), f );\n\t\treturn foggedR( 0.05, f );\n\t} else if ( m < M_BHAT +0.5) {\n\t\tc = fogged( vec3( 0., .5, 1.0 ), f );\n\t\treturn foggedR( 0.5, f);\n\t} else if ( m < M_BFIL +0.5) {\n\t\tc = fogged( sqrt(st)*mix(vec3( 0., 0., 0. ), vec3( 1., 1., 1. ), 11.-pow(p.y,2.) ), f );\n\t\treturn 0.;\n\t} else if ( m < M_BKEY +0.5) {\n\t\tc = fogged( vec3( 1., .5, .0 ), f );\n\t\treturn foggedR( 0.22, f);\n\t} else if (  m < M_TER + 0.5) {\n\t\tc = fogged( st*vec3( .5, .5, .5 ), f);\n\t\treturn foggedR( 0.5, f);\n\t}\n\treturn .0;\n}\n\n\nvec2 bomb( vec3 p, float e, float m, float f1, float f2, float r, float kr ) {\n\n\n\tvec2 d = vec2( 10., M_SKY);\n\n\tp.y -= 1.5;\n\n\n\tfloat c = ell( p, vec3(1.,1.,1.));\n\n\tvec3 g = p;\n\tg.yz *= rot(-.2 * r);\n\n\t// fesses \n\t//if( track_time > 69.05 ) {\n\t//\tvec3 pc = g;\n\t//\tpc.y += .5;\n\t//\tpc.z += .6;\n\t//\tpc.x += .2;\n\t//\tc = smin(c, ell( pc, vec3(.35,.4,.2)), .2);\n\t//\tpc.x -= .2*2.;\n\t//\tc = smin(c, ell( pc, vec3(.35,.4,.2)), .2);\n\t//}\n\td = mmin(d, c ,M_B);\n\n\tvec3 pe = g;\n\tpe.x = -abs(pe.x);\n\tpe.yz *= rot( -0.5);\n\tpe.zx *= rot( -0.4);\n\tpe = pe - vec3(0.0, 0.0, .92);\n\td = mmin( d, ell( pe, vec3(0.25,0.4 + 0.1 * e,0.1) ), M_BEYE);\n\n\t// foots\n\tvec3 pf = p;\n\tfloat f = (pf.x > 0.) ? f1 : f2;\n\tfloat del = PI/5.;\n\tfloat af = max(-PI/2., -(f+del*f) + del );\n\tpf.yz *= rot( af );\n\tpf.x = abs( -pf.x );\n\tpf.y += 1.0;\n\tpf.x -= 0.6 - pow(-pf.y,3.)*.2;\n\tfloat df = cyl( pf , .5, 0.2);\n\tpf.y += .5;\n\tpf.yz *= rot(1.5);\n\tif ( af > .0 ) {\n\t\tpf.yz *= rot(.3 * (1.-pow( p.y, 2. )));\n\t}\n\tdf = smin( df, rc( pf, 0.25, 0.3, 0.5), 0.1 );\n\tdf = max(df, -0.1 + pf.z);\n\td = mmin( d, df, M_BFOOT);\t\n\t\n\t// key\n\tvec3 pk = g;\n\n\tpk.yz *= rot(1.5);\n\n\tpk.zx *= rot( -kr * 2.*PI );\n\tpk.y += 1.;\n\tfloat k = cyl(pk, .15, 0.2);\n\t//pk.z = abs(-pk.z);\n\tpk.z +=.3;\n\tpk.y +=0.5;\n\tpk.xy *= rot(1.5);\n\tk = smin(k, max( cyl( pk, .1, .4), -cyl( pk, .3, .2) ), 0.2 );\n\tpk.z -=2.*0.3;\n\tk = smin(k, max( cyl( pk, .1, .4), -cyl( pk, .3, .2) ), 0.2 );\n\n\td = mmin( d, k, M_BKEY );\n\t\n\n\t// Hat\n\tvec3 ph = g;\n\tph.y -= .95;\n\td = mmin( d, cyl( ph , .1, .45), M_BHAT);\t\n\n\tvec3 pi = ph;\n\td = mmin( d, cyl( ph + 0.1*vec3( ph.y*cos(ph.y * 10.0), .0, (m*3.+2.)*pi.y*pi.y*pi.y) , 1., .1 + 0.01 * pow(cos(200.*pi.y),2.)), M_BFIL);\t\n\n\treturn d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    vec3 color = vec3(1.);\n\tvec2 uv = fragCoord/vec2(iResolution);\n    uv.x *= float(iResolution.x)/float(iResolution.y);\n    uv = uv *.5-.5;\n    float camTime= iTime *.3;\n   float camAmpl = 12.+2.*sin(iTime);\n\tvec3 ro = vec3(camAmpl*cos(-camTime),5.5+2.*sin(iTime),camAmpl*sin(-camTime));\n\tvec3 rd = normalize(vec3(uv, 0.5));//rotate_dir(cam_rotation, normalize(vec3(uv,2.0 * cam_fov)));\n    rd.xz *=rot(-PI/2.+camTime);\n    rd.xy *=rot(0.3*sin(iTime));\n\tvec3 n;\n\tvec4 pmat;\n\n\tfloat period = 0.5;\n\n\t//for ( float n = 40.0; n < 45.; ++n ) {\n\t//\tbeat1 = max(beat1, getNoteVelocity(n,5.) );\n\t//}\n\n    beat1 = exp( - 3.0 * mod( iTime, period ) / period );\n\t//beat1 = pow( beat1*2., 2.0);\n\t//if ( track_time > 28.1 ) {\n\t//\tfor ( float n = 35.0; n < 40.; ++n ) {\n\t//\t\tbeat2 = max(beat2, getNoteVelocity(n,5.) );\n\t//\t}\n\t//\tbeat2 = pow( beat2*1.5, 2.0);\t\t\n\t//}\n\n\n//exp( - 10.0 * mod( sequence_time, period ) / period );\n\tbeat2 = exp( - 3.0 * mod( iTime + period*0.5, period ) / period );\n\t//beat2 = pow( beat2*1.5, 2.0);\n\t//snare = max(\n\t//\t\t\t\t max(\n\t//\t\t\t\t\tmax(getNoteVelocity(81.,4.),getNoteVelocity(74.,4.)),\n\t//\t\t\t\t getNoteVelocity(62.,4.)),\n\t//\t\t\t\tgetNoteVelocity(86.,4.));\n\t\n  \n  float r = 1.;\n  for (int i = 0; i < 3; i++)\n\t{\n\t\tfloat st;\n\t\tpmat = rm(ro,rd, st);\n\t  n = grad(pmat.xyz);\n\t\tvec3 cr = n * 0.5 + 0.5;\n\t\tr *= shade(cr, pmat.w, ro, pmat.xyz, st, n, rd);\n\n\t\tcolor *= ( ( 1.-r) * cr.xyz * (1.-st*(r)) );\n\t\t\n\t\tif ( r > 0.01 ) {\n\t\t\tro = pmat.xyz + n*4.*dLimit;\n\t\t\trd = reflect(rd, n);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\n\tcolor = pow(color, vec3(1./2.2));\n\t//color *= 1.0 - smoothstep(71.5, 72.5, track_time);\n//color= vec3(uv,1.);\n    fragColor = vec4(color,1.0);\n}\n\nfloat ter( vec3 p ) {\n\tfloat per = 6.;\n\tvec3 g = p;\n\tvec3 n = vec3( ivec3( (g / per) ) );\n\tg.xz =\tmod( g.xz, per ) - per * .5;\n\nfloat t = per*.5; \n\nt= cyl(g,10.* rand(n.x), .25*per*rand(n.y+n.x));\n\t\tg = p;\n\t\tg.xz *= rot( .351 );\n\t\t n = vec3( ivec3( (g / per) ) );\n\n\tg.xz =\tmod( g.xz, per ) - per * .5;\n\t\tt = min(t,box(g, vec3(.5,2.,.1) + .25 * per * noise3(n .x+n.y ), 0.21 * beat1));\n\ng = p;\n\t\tg.xz *= rot( -.787 );\n\t\t n = vec3( ivec3( (g / per) ) );\n\tg.xz =\tmod( g.xz, per ) - per * .5;\n\t\tt = min(t,box(g, vec3(.5,2.,.1) + .25 * per * noise3(-n.x+n.y), 0.21 * beat2));\n\t\tt = max( t, 13.-length( p));\n\t\treturn t;\n}\n\nvec2 map(vec3 p) {\n\n\tvec2 d = vec2( 10., M_SKY);\n\n\td = mmin( d, p.y, M_FLOOR );\n\td = mmin( d, ter(p), M_TER);\n\n\tvec3 g = p;\n\t//if ( track_time > 36.0 ) {\n\t\tg.xz *= rot(iTime * .8);\n\t//}\n\n\tfloat per = PI/4.0;\n\tfloat a = mod( atan(g.z, g.x), per) - .5 * per;\n\tfloat l = length(g.zx) ;\n\n\tg.x = l * cos( a );\n\tg.z = l * sin( a );\n\t//if ( track_time < 28.1 || track_time > 36.1) {\n\t\tg.x -= 7.;\n\t//} else if ( track_time < 32. ){\n\t//\tg.x -= 7. + 3. * cos(sequence_time*.8);\n\t//} else {\n\t//\tg.x -= 7. - 3. * cos(sequence_time*.8);\n\t//}\n\n//if ( track_time < 36.1 ) {\n//\tg.zx *= rot(-PI/2.);\n//}\n\tvec2 b = bomb( g, beat1, beat2, beat1, beat2, max(beat1, beat2), iTime );\n\td =\tmmin( d, b.x, b.y );\n\n\treturn d;\n}","name":"Image","description":"","type":"image"}]}