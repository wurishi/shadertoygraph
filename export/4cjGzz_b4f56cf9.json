{"ver":"0.1","info":{"id":"4cjGzz","date":"1720500855","viewed":47,"name":"HYPERDRIVE","username":"joel_kenna","description":"HYPERDRIVE","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["space","warp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPS = 0.01;\nconst int N_MARCHES = 500;\nconst float MAX_DIST = 10000.0;\nconst vec3 NO_HIT = vec3(0.0, 0.0, 0.0);\nconst int NUM_SIZES = 4;\nconst float INF = 9999999.0;\nconst float ACTIVATE = 1.5;\nconst float START_JUMP = 1.9;\nconst float END_JUMP = 3.45;\nconst float pi = 3.1415;\n\n\n\nvec3 transformPoint(vec3 point, float uniformScale, vec3 t, vec3 r) {\n\n    mat4 rotZ = mat4(\n                    vec4(cos(r.z), sin(r.z), 0, 0),\n                    vec4(-sin(r.z), cos(r.z), 0, 0),\n                    vec4(0, 0, 1, 0),\n                    vec4(0, 0, 0, 1));\n\n   mat4 rotY = mat4(\n                    vec4(cos(r.y), 0, -sin(r.y), 0),\n                    vec4(0, 1, 0, 0),\n                    vec4(sin(r.y), 0, cos(r.y), 0),\n                    vec4(0, 0, 0, 1));\n\n   mat4 rotX = mat4(\n                    vec4(1, 0, 0, 0),\n                    vec4(0, cos(r.x), sin(r.x), 0),\n                    vec4(0, -sin(r.x), cos(r.x), 0),\n                    vec4(0, 0, 0, 1));\n\n    \n    vec4 Translation = vec4(t.x,t.y,t.z,1.0);\n    \n    mat4 Rotation = rotX*rotY*rotZ;\n    Rotation[3] = Translation;\n    vec3 transformedPoint = (inverse(Rotation) * vec4(point,1.0)).xyz  / uniformScale;\n    return transformedPoint;\n}\n\n\nfloat crossSDF(vec3 pos) {\n    \n    float arm1 = boxSDF(pos, vec3(1.0, 1.0, INF));\n    float arm2 = boxSDF(pos, vec3(1.0, INF, 1.0));\n    float arm3 = boxSDF(pos, vec3(INF, 1.0, 1.0));\n    return min(min(arm1, arm2), arm3);\n\n}\n\nfloat landSDF(vec3 pos) {\n\n    float scale = 100.;\n    pos = transformPoint(pos, scale, vec3(0), vec3(0, 0, 0));\n\n    //activate hyperdrive\n    if (iTime > ACTIVATE) {\n        pos = getTwistPoint(pos, (iTime - 1.5)*0.3);\n        pos = getBendPoint(pos, sin(iTime - 1.5)*3.0);\n    }\n\n    //This menger sponge implementation is from IQ's work - sponge SDF is not mine\n    float base = boxSDF(pos, vec3(1.));\n    float s = 1.0;\n    float subtractedSDF = base;\n    for (int i = 0; i < 5; i++) {\n        vec3 a = mod( pos*s, 2.0 )-1.0;\n        s = s * 3.0;\n        vec3 r = 1.0 - 3.0*(abs(a));\n        float cro = crossSDF(r) / s;\n        subtractedSDF = max(subtractedSDF, cro);\n    }\n    return subtractedSDF * scale;\n}\n\nfloat jumpSDF(vec3 pos) {\n    vec3 npos = transformPoint(pos, 1.0, vec3(0), vec3(3.1415/2.0, 0.0, 0.0));\n    vec3 c = vec3(1000.0, 1000.0, 5.0);\n    npos = mod(npos+0.5*c,c)-0.5*c;\n    return torusSDF(npos, vec2(1.0*length(pos), 0.5*length(pos)));\n}\n\nfloat finishedSDF(vec3 pos) {\n    vec3 worldPos = transformPoint(pos, 1.0, vec3(0), vec3(0, 0, 0));\n    float sdf1 = sphereSDF(worldPos, 1.);\n    vec3 sunPos = transformPoint(pos, 1.0, vec3(3,1000,1500), vec3(0, 0, 0));\n    float sunSDF = sphereSDF(sunPos, 500.);\n    return min(sdf1, sunSDF);\n}\n\n\nfloat worldSDF(vec3 pos) {\n    \n    float scale = 1.0; \n    float SDF;\n    if (iTime < START_JUMP) {\n        return landSDF(pos);\n    }\n    if (iTime < END_JUMP) {\n        return jumpSDF(pos);\n    }\n    \n    return finishedSDF(pos);\n    \n}\n\n//NORMALS CREDIT TO: //https://michaelwalczyk.com/blog-ray-marching.html\nvec3 getNorm (vec3 p) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = worldSDF(p + small_step.xyy) - worldSDF(p - small_step.xyy);\n    float gradient_y = worldSDF(p + small_step.yxy) - worldSDF(p - small_step.yxy);\n    float gradient_z = worldSDF(p + small_step.yyx) - worldSDF(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\n\n//no shadows or spec\nvec3 lighting(vec3 point, vec3 lightLoc, float amb) {\n    \n    vec3 sun = lightLoc;\n    vec3 norm = getNorm(point);\n    vec3 lightDir = normalize(sun - point);\n    \n    \n    float dir = dot(norm, lightDir);\n    dir = max(0.0, dir);\n    \n    vec3 col = vec3(1.0);\n    return 1.*dir*col + amb*col;\n}\n\nvec3 shadePlanet(vec3 point, vec3 lightLoc, vec3 lookVec) {\n\n    float l1 = (pi + atan(point.x, point.z)) / (2. * pi) * 1024.0;\n    float l2 = (pi + atan(point.y, point.z)) / (2. * pi) * 1024.0;\n    \n    ivec2 texLoc = ivec2(int(l1), int(l2));\n    \n    vec3 norm = getNorm(point);\n    \n    float fresnel = dot(norm, lookVec);\n    fresnel = pow(1.0 + fresnel, 2.);\n    \n    vec3 lt = lighting(point, lightLoc, 0.02);\n    return (texelFetch(iChannel0, texLoc, 0).xyz * vec3(1.4, 1.01,1.0)) * lt + lt*fresnel*vec3(0.7,0.3,0.1);\n}\n\nvec3 shadeSun(vec3 point, vec3 lightLoc, vec3 lookVec) {\n\n    vec3 pFromL = lightLoc - point;\n    \n    float l1 = (pi + atan(pFromL.x, pFromL.z)) / (2. * pi) * 1024.0;\n    float l2 = (pi + atan(pFromL.y, pFromL.z)) / (2. * pi) * 1024.0;\n    \n    ivec2 texLoc = ivec2(int(l1), int(l2));\n    vec3 texCol = texelFetch(iChannel1, texLoc, 0).xyz;\n    \n    float h = pow((lightLoc.y - point.y),2.) / length(lightLoc - point);\n    float s = cos((lightLoc.x - point.x) / length(lightLoc - point));\n    \n    return texCol * vec3(0.3+0.7*h,0.6,0.1);\n}\n\nvec3 sampleStar(vec3 view) {\n    return NO_HIT;\n}\n\nvec3 marcher(vec3 start, vec3 startDir){\n    \n    vec3 dir = startDir;\n    float depth = 0.0;\n    vec3 lightLoc = vec3(60.,200,50);\n    \n    for (int i= 0; i < 100; i++){\n        vec3 point = start + depth*dir;\n        float dist = worldSDF(point);\n    \n        if (dist < EPS) {\n            \n            vec3 col;\n            if (iTime > ACTIVATE && iTime < START_JUMP) {\n                col = vec3(0.2, 0.4, 0.8)*tan(iTime+100.+point.y*0.005);\n            } else {\n                if (iTime > ACTIVATE && iTime < END_JUMP) {\n                    col = vec3(0.2, 0.4, 0.8)*tan(iTime+1.2+point.y*0.005);\n                } else {\n                    if (iTime > END_JUMP) {\n                        lightLoc = vec3(3,1000,1500);\n                        if (length(point) > 1.0 && length(point) < 100.0) {\n                            return shadePlanet(point, lightLoc, dir);\n                        } else {\n                            return shadeSun(point, lightLoc, dir);\n                        }\n                        \n                    } else {\n                        col = vec3(1.0);\n                    }\n                }\n            }\n            \n            vec3 final = lighting(point, lightLoc, 0.4/*0.1*/)*vec3(1.0)*col;\n            return final;\n        }\n        \n        if (dist > MAX_DIST) {\n            \n            if (iTime > END_JUMP) {\n                float l2sun = dot(startDir, normalize(vec3(3,1000,1500)));\n                float sunRange = 0.85;\n                if (l2sun > sunRange) {\n                    float fallOff = (-sunRange + l2sun) * (1.0/(1.0 - sunRange));\n                    return vec3(0.0) +  fallOff*vec3(0.4, 0.05,0.0);\n                }\n            }\n\n            return sampleStar(startDir);\n        }\n        \n        depth += dist;\n    }\n    \n    return NO_HIT;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //circular centering\n    vec2 pos = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    \n    float accel = 0.0;\n    vec3 jumpFxCol = vec3(0.0);\n    vec3 camera;\n    if (iTime < END_JUMP) {\n        float accel = iTime*10.*1.1*iTime;\n        if (iTime > ACTIVATE) {\n            accel += (iTime - ACTIVATE) * iTime*10.0;\n        }\n        if (iTime > START_JUMP - 0.15) {\n            jumpFxCol = ((1.41 - length(pos)) / 1.41) * (-1.0 * vec3(0.2,0.4,0.8));\n            \n        }\n        if (iTime > START_JUMP) {\n            camera = vec3(0.0, 0.0, -5.0);\n        } else {\n            camera = vec3(0.0, 0.0, -1000.0 + 15.*iTime*accel);\n        }\n    } else {\n        float DECEL_TIME = 0.1;\n        float speed = 550.0 * min(iTime - END_JUMP, DECEL_TIME) + 0.1*(max(iTime- END_JUMP, DECEL_TIME)-DECEL_TIME);\n        \n        camera = vec3(3.0, 0.0, -60.0 + speed);\n    }\n    \n    vec3 lookVec = normalize(vec3(pos.x/2.0, pos.y/2.0, 1));\n    fragColor = vec4(marcher(camera, lookVec) + jumpFxCol, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//HASH FN CREDIT TO: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nvec3 hash(vec3 f )\n{\n\n    //uvec3 x = uvec3(f*iTime);\n    uvec3 x = uvec3(f*123.2315);\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return mod(vec3(x)*(1.0/float(0xffffffffU)), 1.0);\n}\n\n//SDF PRIMITIVES & OPERATORS CREDIT TO IQ: https://iquilezles.org/articles/distfunctions/\nvec3 getBendPoint(vec3 pos, float k) {\n    float c = cos(k*pos.x);\n    float s = sin(k*pos.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy,pos.z);\n    return q;\n}\n\nvec3 getTwistPoint(vec3 pos, float k) {\n  float c = cos(k*pos.y);\n  float s = sin(k*pos.y);\n  mat2  m = mat2(c,-s,s,c);\n  vec3  q = vec3(m*pos.xz,pos.y);\n  return q;\n}\n\nfloat sphereSDF(vec3 pos, float rad) {\n    return length(pos) - rad;\n}\n\nfloat boxSDF( vec3 pos, vec3 b )\n{\n  vec3 q = abs(pos) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}","name":"Common","description":"","type":"common"}]}