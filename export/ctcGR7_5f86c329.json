{"ver":"0.1","info":{"id":"ctcGR7","date":"1682202010","viewed":220,"name":"test cloud tunnel","username":"jojobavg","description":"I tried to rewrite my \"cloud tunnel\" shader.  https://www.shadertoy.com/view/tdGBRG","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n#define depth 70.0\n#define fogSize 25.0\nfloat fogCoef=1.0/(depth-fogSize);\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat cloud(in vec3 p,float distortion,float scale ) {\n\tfloat l = length(p*distortion);\n\tvec3 d = vec3(p.x+sin(l+time)*2.0,p.y+sin(l)*2.0,0.0);\n    float coef = length(d)-4.0;\n\tfloat c=1.0;\n\tfloat n1=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=1.0/c*abs(noise((p*c+time*1.0)*scale));\n\t\tc*=2.0;\n\t}\n\treturn n1*(coef);\n}\n\nfloat mapHyper(vec3 p){\n\n\treturn cloud(p,0.1,0.5);\n}  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 s=vec3(0.5,0.5,100);\n\tfloat t2=(time*1.5);\n\ts.xz *= rot(sin(t2)*0.005);\n\tvec3 t=vec3(0,0,0);\n\ts.x += cos(t2*0.2)*0.10*sin(time*0.01);\n\ts.y += sin(t2*0.2)*0.10*sin(time*0.01+10.0);\n\tvec3 cz=normalize(t-s);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=normalize(cross(cz,cx));\n\tvec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\ts.z+=time*8.0;\n\t\n\tvec3 p=s;\n\tfloat d;\n\tfloat seuil=mix(2.0,8.0,noise(time*0.5));\n\tfloat c= 0.0;\n\tfloat cl;\n\tfor(int i=0; i<500; ++i) {\n\t\tfloat d=0.0;\n\t\td = mapHyper(p);\n\t\tc+=d;  \n        if(c>seuil*10.0)break;\n        p+=r*(d-seuil)*0.09;\n\t}\n    c=0.0;\n    vec3 p2=p;\n    for(int i=0; i<20; ++i) {\n\t\tfloat d2=0.0;\n\t\td2= mapHyper(p2);\n\t\tc+=d2; \n        p2 +=normalize(vec3(0.0,0.0,-1.0))*(-d2)*0.09;\n\t}\n    cl = 1.0-length(p-p2)/15.0;\n\t\n\t//compositing\n\tvec3 col=vec3(0);\n\tcol = mix(vec3(0.0,0.0,0.2),vec3(0.88,0.88,0.9),cl);\n\tfloat fog =  clamp((length(p2-s)-fogSize)*fogCoef,0.0,1.0);\n\tcol = mix(col,vec3(0.88,0.88,0.9),fog);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}