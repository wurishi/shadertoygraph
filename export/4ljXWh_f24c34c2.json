{"ver":"0.1","info":{"id":"4ljXWh","date":"1443295458","viewed":10399,"name":"Beneath the Sea","username":"zel","description":"Sprites float in their underwater home.","likes":140,"published":1,"flags":0,"usePreview":0,"tags":["ray","terrain","rays","water","circle","marching","caustic","god"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// partially derived from the following\n// https://www.shadertoy.com/view/MlB3zh - terrain base\n// https://www.shadertoy.com/view/MdlXz8 - caustic tile\n\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\n\nfloat speck(vec2 pos, vec2 uv, float radius)\n{\n    pos.y += 0.05;\n    float color = distance(pos, uv);\n    vec3 tex = texture(iChannel0, sin(vec2(uv)*10.1)).xyz;\n    vec3 tex2 = texture(iChannel0, sin(vec2(pos)*10.1)).xyz;\n    color = clamp((1.0 - pow(color * (5.0 / radius), pow(radius,0.9))), 0.0, 1.0);\n    color *= clamp(mix(sin(tex.y)+0.1,cos(tex.x),0.5)*sin(tex2.x)+0.2,0.0,1.0);\n    return color;\n}\n\n\nvec3 caustic(vec2 uv)\n{\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n    float time = iTime * .5+23.0;\n\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n    \n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 color = vec3(pow(abs(c), 8.0));\n    color = clamp(color + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    color = mix(color, vec3(1.0,1.0,1.0),0.3);\n    \n    return color;\n}\n\n\n// perf increase for god ray, eliminates Y\nfloat causticX(float x, float power, float gtime)\n{\n    float p = mod(x*TAU, TAU)-250.0;\n    float time = gtime * .5+23.0;\n\n\tfloat i = p;;\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER/2; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + cos(t - i) + sin(t + i);\n\t\tc += 1.0/length(p / (sin(i+t)/inten));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, power);\n    \n    return c;\n}\n\n\nfloat GodRays(vec2 uv)\n{\n    float light = 0.0;\n\n    light += pow(causticX((uv.x+0.08*uv.y)/1.7+0.5, 1.8, iTime*0.65),10.0)*0.05;\n    light-=pow((1.0-uv.y)*0.3,2.0)*0.2;\n    light += pow(causticX(sin(uv.x), 0.3,iTime*0.7),9.0)*0.4; \n    light += pow(causticX(cos(uv.x*2.3), 0.3,iTime*1.3),4.0)*0.1;  \n        \n    light-=pow((1.0-uv.y)*0.3,3.0);\n    light=clamp(light,0.0,1.0);\n    \n    return light;\n}\n\n\nfloat noise(in vec2 p)\n{\n   \n    float height = mix(texture(iChannel0, p / 80.0, -100.0).x,1.0,0.85);\n    float height2 = mix(texture(iChannel1, p / 700.0, -200.0).x,0.0,-3.5);\n    \n    return height2-height-0.179;\n}\n\n\nfloat fBm(in vec2 p) \n{\n    float sum = 0.0;\n    float amp = 1.0;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        sum += amp * noise(p);\n        amp *= 0.5;\n        p *= 2.5;\n    }\n    return sum * 0.5 + 0.15;\n}\n\n\nvec3 raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n    float t = tmin;\n    vec3 res = vec3(-1.0);\n    \n    for (int i = 0; i < 110; i++) \n    {\n        vec3 p = ro + rd * t;\n        \n        res = vec3(vec2(0.0, p.y - fBm(p.xz)), t);\n        \n        float d = res.y;\n        \n        if (d < (0.001 * t) || t > tmax)\n        {\n            break;\n        }\n        \n        t += 0.5 * d;\n    }\n    \n    return res;\n}\n\n\nvec3 getTerrainNormal(in vec3 p) \n{\n    float eps = 0.025;\n    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 skyColor = vec3(0.3, 1.0, 1.0);\n\n    vec3 sunLightColor = vec3(1.7, 0.65, 0.65);\n    vec3 skyLightColor = vec3(0.8, 0.35, 0.15);\n    vec3 indLightColor = vec3(0.4, 0.3, 0.2);\n    vec3 horizonColor = vec3(0.0, 0.05, 0.2);\n    vec3 sunDirection = normalize(vec3(0.8, 0.8, 0.6));\n    \n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 1.25, 1.5);\n    vec2 rot = 6.2831 * (vec2(-0.05 + iTime * 0.01, 0.0 - sin(iTime * 0.5) * 0.01) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.5, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));\n\n    // background\n    vec3 color = skyColor;\n    float sky = 0.0;\n\n    // terrain marching\n    float tmin = 0.1;\n    float tmax = 20.0;\n    vec3 res = raymarchTerrain(ro, rd, tmin, tmax);\n    \n    vec3 colorBubble = vec3(0.0);\n    float bubble = 0.0;\n    bubble +=  speck(vec2(sin(iTime*0.32),cos(iTime)*0.2+0.1),rd.xy,-0.08*rd.z);\n\tbubble +=  speck(vec2(sin(1.0-iTime*0.39)+0.5,cos(1.0-iTime*0.69)*0.2+0.15),rd.xy,0.07*rd.z);   \n\tbubble +=  speck(vec2(cos(1.0-iTime*0.5)-0.5,sin(1.0-iTime*0.36)*0.2+0.1),rd.xy,0.12*rd.z);   \n \tbubble +=  speck(vec2(sin(iTime*0.44)-1.0,cos(1.0-iTime*0.32)*0.2+0.15),rd.xy,-0.09*rd.z);   \n \tbubble +=  speck(vec2(1.0-sin(1.0-iTime*0.6)-1.3,sin(1.0-iTime*0.82)*0.2+0.1),rd.xy,0.15*rd.z);\n\n    colorBubble = bubble*vec3(0.2,0.7,1.0);\n    if(rd.z < 0.1)\n    {\n        float y = 0.00;\n        for(float x = 0.39; x < 6.28; x += 0.39)\n        {\n            vec3 height = texture(iChannel0, vec2(x)).xyz;\n            y+= 0.03*height.x;\n\t\t\tbubble = speck(vec2(sin(iTime+x)*0.5+0.2,cos(iTime*height.z*2.1+height.x*1.7)*0.2+0.2),\n            rd.xy,(cos(iTime+height.y*2.3+rd.z*-1.0)*-0.01+0.25));\n            colorBubble += bubble*vec3(-0.1*rd.z,-0.5*rd.z,1.0);\n        }\n    }    \n         \n    float t = res.z;\n    \n    if (t < tmax) \n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor;\n        \n        // add bumps\n        nor = getTerrainNormal(pos);\n        nor = normalize(nor + 0.5 * getTerrainNormal(pos * 8.0));\n \n        float sun = clamp(dot(sunDirection, nor), 0.0, 1.0);\n        sky = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        vec3 diffuse=mix(texture(iChannel2, vec2(pos.x*pow(pos.y,0.01),pos.z*pow(pos.y,0.01))).xyz,vec3(1.0,1.0,1.0),clamp(1.1-pos.y,0.0,1.0));\n\n        diffuse *= caustic(vec2(mix(pos.x,pos.y,0.2),mix(pos.z,pos.y,0.2))*1.1);\n        vec3 lightColor = 1.0 * sun * sunLightColor;\n\n        lightColor += 0.7 * sky * skyLightColor;\n\n        color *= 0.8 * diffuse*lightColor;\n\n        // fog\n        color = mix(color, horizonColor, 1.0 - exp(-0.3 *pow(t,1.0) ));\n    }\n    else \n    {\n        sky = clamp(0.8 * (1.0 - 0.8 * rd.y), 0.0, 1.0);\n        color = sky * skyColor;\n        color += ((0.3*caustic(vec2(p.x,p.y*1.0)))+(0.3*caustic(vec2(p.x,p.y*2.7))))*pow(p.y,4.0);\n\n        // horizon\n        color = mix(color, horizonColor, pow(1.0 - pow(rd.y,4.0), 20.0));       \n    }\n    \n    // special effects\n    color += colorBubble;\n    color += GodRays(p)*mix(float(skyColor),1.0,p.y*p.y)*vec3(0.7,1.0,1.0);\n    \n    // gamma correction\n    vec3 gamma = vec3(0.46);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}","name":"","description":"","type":"image"}]}