{"ver":"0.1","info":{"id":"XsyXWV","date":"1466550772","viewed":293,"name":"First Raymarch - Cubes","username":"camargo","description":"This is my first raymarching shader.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ray","raymarch","cubes","first","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// First Raymarch - Cubes\n// Chris Camargo, June 2016\n\n// Distance function for box.\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n\n    return min(max(d.x,max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Repeater distance function for box.\nfloat rep(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n\n    return box(q, vec3(0.5, 0.5, 0.5));\n}\n\n// Raymarch, computing the distance at each step and incrementing the\n// ray parameter t.\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n\n        // Distance function.\n        float d = rep(p, vec3(2.0, 3.0, 2.0));\n\n        t += d;\n    }\n    return t;\n}\n\n// Image computation.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float x = fragCoord.x;            // Current pixel x-coordinate. Range: [0.5, iResolution.x - 0.5].\n    float y = fragCoord.y;            // Current pixel y-coordinate. Range: [0.5, iResolution.y - 0.5].\n    float minX = 0.5;                 // Min x-coordinate value.\n    float minY = 0.5;                 // Min y-coordinate value.\n    float maxX = iResolution.x - 0.5; // Viewport width.\n    float maxY = iResolution.y - 0.5; // Viewport height.\n\n    // Feature Scaling. Bring coords to value between [0, 1].\n    // https://en.wikipedia.org/wiki/Feature_scaling#Rescaling\n    vec2 uv = vec2((x - minX) / (maxX - minX), (y - minY) / (maxY - minY));\n\n    // Coords between [0, 1] so 'eye' is centered at (0.5, 0.5).\n    // We want 'eye' centered at (0, 0). Thus subtract 0.5 from\n    // each coord.\n    uv -= 0.5;\n\n    // Move coords away from 'eye' by a factor of 2.0.\n    // You can play with this number.\n    uv *= 2.0;\n    \n    // Scale x based on aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Ray origin.\n    vec3 o = vec3(0.0, iTime, iTime);\n\n    // Ray direction.\n    vec3 r = normalize(vec3(uv.x, uv.y, 1.0));\n\n    // Rotate direction r around y-axis by a fraction of time.\n    float theta = iTime * 0.25;\n    r.xz *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    // Trace ray from origin o in direction r.\n    float t = trace(o, r);\n    \n    // Set the color via 1 / (1. + t): Light attenuation.\n    vec3 color = vec3(0.2, 1.0 / (1. + t), 1.0 / (1. + t));\n    \n    // Set pixel color.\n    fragColor =  vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}