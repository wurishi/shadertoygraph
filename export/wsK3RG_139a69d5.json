{"ver":"0.1","info":{"id":"wsK3RG","date":"1570565447","viewed":75,"name":"Rotating shiny balls","username":"matan","description":"Ray tracing test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nfloat diffuse = 0.8;\nfloat ambient = 0.4;\nfloat specular = 0.6;\nfloat shininess = 300.0;\n\nvec3 light_p = vec3(-5.0, 10.0, -5.0);\n\nfloat kInfinity = 1000000.0;\n\nstruct Ray {\n    vec3 source;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n        \n    \n// Returns kInfinity in case of no hit\nvoid traceRayThroughSphere(\n    in Ray ray, in Sphere sphere, out float hit_t) {\n    \n\thit_t = kInfinity;  \n\n    vec3 v = ray.source - sphere.center;\n\n    float a = 1.0;\n    float b = 2.0*dot(v, ray.direction);\n    float c = dot(v, v) - sphere.radius * sphere.radius;\n\n    float det = b*b - 4.0*a*c;\n    if (det >= 0.0) {\n        float t1 = (-b + sqrt(det)) / (2.0 * a);\n        float t2 = (-b - sqrt(det)) / (2.0 * a);            \n        if (t1 > 0.0) {\n            hit_t = t1;\n        }\n        if (t2 > 0.0) {\n            hit_t = min(hit_t, t2);\n        }\n    }    \n}\n\nconst int num_spheres = 10;\nfloat spheres_radius = 2.0;\n\nSphere getSphere(in int sphere_i) {\n    \n    Sphere s;\n    s.center = vec3(0.0, 0.0, 0.0);\n    s.radius = 1.0;\n    s.color = vec3(0.5, 0.5, 0.7);\n    \n    if (sphere_i < num_spheres) {\n        float cur_sphere_radius = sin(float(sphere_i) + iTime * 5.0) * 0.6 + spheres_radius + 0.4;\n       \ts.center = vec3(cos(iTime * 2.0 + 2.0 * M_PI / float(num_spheres) * float(sphere_i)) * cur_sphere_radius, 0, sin(iTime * 2.0 + 2.0 * M_PI / float(num_spheres) * float(sphere_i)) * cur_sphere_radius);\n        s.radius = 0.5;\n        s.color = vec3(1.0 / float(num_spheres) * float(sphere_i), 0.2, 1.0 - 1.0 / float(num_spheres) * float(sphere_i));\n    } else {\n        float cur_sphere_height = sin(iTime * 3.0) * 0.4;\n        s.center = vec3(0.0, 0.0, cur_sphere_height);\n        s.radius = 1.0;\n        s.color = vec3(0.5, 0.5, 0.7);\n    }\n    return s;\n}\n\nvoid traceRay(in Ray ray, out float mint, out vec3 hit_p, out vec3 over_p, out vec3 norm, out vec3 color, out bool is_hit) {\n    mint = 99999.0;\n    \n    for (int sphere_i = 0; sphere_i <= num_spheres; ++sphere_i) {\n        Sphere sphere = getSphere(sphere_i);\n        float cur_t;\n        traceRayThroughSphere(ray, sphere, cur_t);\n        if (cur_t < mint) {\n            mint = cur_t;\n            hit_p = cur_t * ray.direction + ray.source;\n            norm = normalize(hit_p - sphere.center);\n            color = sphere.color;\n        }\n    }\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    is_hit = false;\n    \n    if (mint < 99998.0) {\n        vec3 light_v = normalize(light_p - hit_p);\n        vec3 light_reflect = light_v - 2.0 * norm * dot(light_v, norm);\n        \n\n        float cos_alpha = dot(norm, light_v);   \n        if (cos_alpha < 0.0) cos_alpha = 0.0;\n\n        float cos_ref_alpha = dot(light_reflect, ray.direction);\n        if (cos_ref_alpha < 0.0) cos_ref_alpha = 0.0;\n\n        col = ambient * color + diffuse * color * cos_alpha + specular * vec3(1.0, 1.0, 1.0) * pow(cos_ref_alpha, shininess);\n        \n        is_hit = true;\n    }\n    \n    color = col;\n    over_p = hit_p + norm * 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = gl_FragCoord.xy / iResolution.xy;  \n\n    \n    float distance = 20.0 + 10.0 * sin(iTime*0.5);\n    \n    vec3 camera_p = vec3(0.0, distance * cos(iTime * 0.6), distance * sin(iTime * 0.6));\n    \n    vec3 camera_look_at = vec3(0.0, 0.0, 0.0);\n    vec3 camera_up = vec3(0.0, -sin(iTime * 0.6), cos(iTime * 0.6));\n    vec3 camera_forward = normalize(camera_look_at - camera_p);\n    vec3 camera_right = cross(camera_forward, camera_up);\n    \n    float width = 2.0;\n    float height = width / iResolution.x * iResolution.y;  // 1.125\n    \n    vec3 screen_p = camera_forward * 5.0 + camera_p;\n    screen_p += (-width*0.5 + (p.x * width)) * camera_right;\n    screen_p += (-height*0.5 + p.y * height) * camera_up;\n    \n    vec3 d = normalize(screen_p - camera_p);\n\n    float mint = 99999.0;\n    vec3 hit_p;\n    vec3 over_p;\n    vec3 norm;\n    vec3 color;\n    bool is_hit;\n    \n    Ray ray;\n    ray.source = camera_p;\n    ray.direction = d;\n    \n    traceRay(ray, mint, hit_p, over_p, norm, color, is_hit);\n    \n    if (is_hit) {\n        for (int i = 0; i < 5; ++i) {\n            d = d - 2.0 * norm * dot(d, norm);\n            vec3 reflected_color;\n            vec3 new_over_p;\n            Ray ray;\n            ray.source = over_p;\n            ray.direction = d;\n            traceRay(ray, mint, hit_p, new_over_p, norm, reflected_color, is_hit);\n            over_p = new_over_p;\n            color += pow(0.4, float(i)) * reflected_color;\n            if (! is_hit) break;\n        }\n    }\n      \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}