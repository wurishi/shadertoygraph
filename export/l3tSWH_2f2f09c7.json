{"ver":"0.1","info":{"id":"l3tSWH","date":"1719015767","viewed":79,"name":"Mandel's Infinite 4D Circus","username":"gllama","description":"Not a bad raymarch. Welcome to Mandel's Circus. License CC0-1.0\n\nRecommended to try any of below.\n[code]\nvec3 raymarchRepeat=vec3(3.,1.,3.);// < Snakes\nconst float SURF_DIST = 0.0001;\nconst float BAILOUT = 2.0;\nconst float POWER = 4.0;\n[/code]","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","mandelbulb","projection","4d","4d","spherical","mandel","infinite","cc0","equirectangular"],"hasliked":0,"parentid":"M3cSWH","parentname":"MandleBulbin"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ⚛️ Mandel's Infinite 4D Circus (Spherical/Equirectangular projection)\n// License CC0-1.0\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Raymarched 4D mandlebulbs! Mostly a success :)\n//\n// A bit out of my depth here, but it works. I'm no stranger to 4D space\n// though still this is probably overkill for my first foray into raymarching.\n// \n//\n// EDIT: June 29, 2024\n// Finally figured out how to ID the bulbs for psuedo-unique \n// colors. My repeat function was hiding the secret info vis-via dropped quotient.\n// Also found a way to combine normal + distance lighting that I was happy with, \n// added some rotation to the camera, generally re-factored a few things, and made \n// the mandlebulbs snakes via vec3 raymarchRepeat=vec3(3.,1.,3).\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nbool flatmode=false; // < Removes equirectangular projection\nbool trippy4Dnormals=false; // < Shows you the 4D normals\nvec3 raymarchRepeat=vec3(3.,3.,3.); // The reapeat-frequency of bulbs in XYZ used for ray-marching \n//                      ^= (3.,1.,3) for mandlebulbsnakes\n\n// Raymarch Settings:\nconst int MAX_STEPS = 100;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 0.01; //< Smaller for higher quality\n\n// Mandel SDF Settings:\nconst int ITERATIONS = 10;\nconst float BAILOUT = 2.0;\nconst float POWER = 8.0;//< Play with this one\n\n// Tasty SDF function to calculate the distance to a 4D Mandelbulb. \nfloat sdMandelbulb4D(vec4 p) {\n\n\n    vec4 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n\n    for (int i = 0; i < ITERATIONS; i++) {\n        r = length(z);\n        if (r > BAILOUT) break;\n\n        // Convert to polar coordinates\n        float theta = acos(z.w / r);\n        float phi = atan(z.z, z.x);\n        float psi = atan(z.y, length(z.xz));\n\n        // Scale and rotate the point\n        dr = pow(r, POWER - 1.0) * POWER * dr + 1.0;\n        float zr = pow(r, POWER);\n        theta *= POWER;\n        phi *= POWER;\n        psi *= POWER;\n\n        // Convert back to Cartesian coordinates\n        z = zr * vec4(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) * cos(psi), cos(theta) * sin(psi));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// Function to repeat space in 4D\nvec4 repeat(vec4 p, vec4 c, out vec4 quotient) {\n    quotient = floor(p/c);\n    return mod(p,c) - 0.5 * c;\n}\n\n// Function to compute the normal using the gradient of the SDF\nvec4 getNormal(vec4 p) {\n    vec4 eps = vec4(0.001, 0.0, 0.0, 0.0);\n    float d = sdMandelbulb4D(p);\n    vec4 normal;\n    normal.x = sdMandelbulb4D(p + eps.xwww) - d;\n    normal.y = sdMandelbulb4D(p + eps.wxww) - d;\n    normal.z = sdMandelbulb4D(p + eps.wwxw) - d;\n    normal.w = sdMandelbulb4D(p + eps.wwwx) - d;\n    return normalize(normal);\n}\n\n// Does raymarching stuff w/mandelBulb4D SDF.\n// `out float marches` => used in our final color-mix.\n// `out vec4 p`        => used for normal calculations\n// `out vec4 id`       => usef for psuedo-unique bulb-color.\nfloat raymarch(vec4 ro, vec4 rd, out vec4 p, out float marches, out vec4 id) {\n    float t = 0.0;\n\n    marches=0.;\n    vec4 qTotal=vec4(0.);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec4 pos4D = ro + t * rd;\n        vec4 quotient;\n        vec4 repeatPos4D = repeat(pos4D, vec4(raymarchRepeat, 2.),quotient); // Repeat space in 4D\n        marches+=1.;\n        float d = sdMandelbulb4D(repeatPos4D);\n        if (d < SURF_DIST) {\n            p = repeatPos4D; // p for normals\n            id = quotient; // id for psuedo-unique color\n            return t;// return distance from bulb\n        }\n        t += d;\n        if (t > MAX_DIST) {\n            break;\n        }\n    }\n    return MAX_DIST;\n}\n\n// This function let's us jump from 2D-UV to spherical 3D-XYZ position\n// The jist is that XY of UV can represent 2-Sphere angles to get a point on the sphere.\n// The 2-Sphere point than gives you an XYZ normalized [-1,1].\nvec3 uv3D(vec2 uv) {\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    // { Dev Note }\n    // If you're porting this shader to a material, I strongly recommend you skip this function \n    // and just use the XYZ of your `varying vNormal` in place of the result you would get here.\n    // Should be suitable for all spheres and most round geometries\n    return vec3(x, y, z);\n}\nvec3 randomColor(float seed) {\n    float r = fract(sin(seed * 69.42069 + 70.333) * 43758.5453);\n    float g = mod(fract(sin((seed + 1.0) * 39.3467 + 57.583) * 43758.5453)+iTime,1.);\n    float b = fract(sin((seed + 2.0) * 73.1562 + 25.345) * 43758.5453);\n    return vec3(r, g, b);\n}\nvec3 rotateX(vec3 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 rotationMatrix = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c,   -s,\n        0.0, s,   c\n    );\n    return rotationMatrix * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Default color is black\n    vec3 color = vec3(0.0);\n\n    // Handle UVs for spherical 3D projection\n    vec2 uv = fragCoord/iResolution.xy; \n    vec3 pos = uv3D(uv);\n    if(flatmode){\n        vec2 uv2D = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        pos = vec3(uv2D,-1.);\n    }\n    pos=rotateX(pos,iTime/10.);\n\n    \n    // Ray Origin \n    // (XYZ)=> Your position in 3D space;\n    // (W)=>The 3D representation of 4D Mandel Bulb\n    // Ray Direction is based on UV/3D-Cartesian spherical XYZ\n    vec4 ro = vec4(cos(iTime)*1.5-1.5,iTime*2. , sin(iTime)*1.5-1.5, 1.+sin(iTime)/2.); \n    vec4 rd = normalize(vec4(pos,0.)); // Ray direction with zero w component\n\n    // Raymarch to find the distance to the bulb\n    vec4 p, id;\n    float marches;\n    float dist = raymarch(ro, rd, p, marches, id);\n\n    \n    // If we hit a MandelBulb do lighting and color calculations.\n    if (dist < 100.0) {\n    \n        vec4 normal = getNormal(p);\n        vec3 lightDir = normalize((p - rd).xyz);\n        float diffuse = max(dot(normalize(normal.xyz), lightDir), .8);// Dropping W & Z instead using XYY as it gave a more interesting effect IMO.\n        \n        // mix distance + \n        color = mix(1.-vec3(marches/100.),randomColor(length(floor(id.xzy))),.5);//mix(1.-vec3(marches/100.),(randomColor(length(ceil(p.xyz)))),.33);\n        // 4D normal color is very trippy\n        // You can rotate the normals by doing variations of XYZ/W, XWZ/Y, YZW/X, etc....\n        if(trippy4Dnormals){\n            color=normal.xyz/normal.w;\n        }\n        \n        //Scrapped diffuse lighting\n        color = color/(diffuse);\n    }\n\n    fragColor = vec4(color, 1.0);\n    }","name":"Image","description":"","type":"image"}]}