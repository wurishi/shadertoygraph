{"ver":"0.1","info":{"id":"ftfyD2","date":"1648730548","viewed":217,"name":"Polar Tech","username":"r33v01v3","description":"Polar coordinates tech circle thingy.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["polarcoordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//set number of box elements per layer\n#define elements 22\n\nfloat sdBox(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0));\n}\n\nfloat hash21(vec2 p){\n\tp = fract(p*vec2(978.231,658.17));\n\tp += dot(p,p+192.332);\n\treturn fract(p.x*p.y);\n}\n\nvec2 rotateVec2(vec2 v, float r)\n{\n\tvec2 cs = vec2(cos(r), sin(r));\n\treturn vec2(v.x * cs.x - v.y * cs.y,\n\t\t\t\tv.x * cs.y + v.y * cs.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    uv *= 5.0;\n    float t = iTime*0.6;\n    \n    \n    //setup and zoom uv's for layers\n    float rz = 875.85, gz = 321.10, bz = 12.87,zspeed = 1.0;\n    float za = 0.1;\n    vec2 uvr = uv, uvg = uv, uvb = uv;\n\tuvr *= (sin(t+rz)*za+0.5);\n    uvg *= (sin(t+gz)*za+0.5);\n    uvb *= (sin(t+bz)*za+0.5);\n    \n    //rotate layer uv's with offset\n    float rotspeed = 0.3;\n    float roffset = 0.0, goffset = 180.0, boffset = 300.42;\n    float rrot = sin((t+roffset)*rotspeed)* 3.1416;\n    float grot = sin((t+goffset)*rotspeed)* 3.1416;\n    float brot = sin((t+boffset)*rotspeed)* 3.1416;\n    vec2 tuv[3]; \n    tuv[0]= rotateVec2(uvr,rrot);\n    tuv[1]= rotateVec2(uvg,grot);\n    tuv[2]= rotateVec2(uvb,brot);\n    \n    //set colours for layers\n    vec3 bcol[3];\n    bcol[0] = vec3(1.0,0.0,0.0);\n    bcol[1] = vec3(0.0,1.0,0.0);\n    bcol[2] = vec3(0.0,0.0,1.0);\n    vec3 col[3]; \n    vec3 finalcol = vec3(0.0);\n\n    //cycle through different layer combinations\n    float seed = ceil(t*0.1);\n    \n    //draw layers\n    //thick = layer thickness, ypos = distance from center\n    float box_out = 0.0, my_box = 0.0, thick = 1.0, ypos = 0.7;\n    \n    for(int k = 0; k < 3; k++){\n        for(int i = 0; i < elements; i++){\n            //\"random\" box position\n            float r_box_x = sin(hash21(vec2(float(i)*seed + 945.93,float(i)*seed + 546.85)))*6.2832;\n            float r_box_y = sin(hash21(vec2(float(i)*seed + 786.43,float(i)*seed + 87.23)))*0.5;\n            \n            //polar coordinates\n            vec2 puv = vec2(atan(tuv[k].x,tuv[k].y),length(tuv[k]));\n            vec2 buv = vec2((puv.x-2.6+r_box_x)/6.2832,puv.y+r_box_y-ypos);\n            \n            //\"random\" box size\n            vec2  box_size = vec2(hash21(vec2(float(i)+50.57+seed,float(i)+645.84))*0.3,hash21(vec2(float(i)+345.98,float(i)+24.97+seed))*0.3);\n            \n            //draw box\n            box_out = sdBox(buv,vec2(box_size.x*0.5,(box_size.y*0.5)*thick));\n            my_box = smoothstep(0.01,0.009,box_out);\n\n            col[k] += my_box;//layer elements\n            col[k] *= bcol[k];//colour layer\n            }\n            \n            finalcol = mix(col[k],finalcol,0.8);\n            seed += 2.0;\n        }\n    finalcol = pow(finalcol, vec3(0.4545));\n    fragColor = vec4(finalcol,1.0);\n}","name":"Image","description":"","type":"image"}]}