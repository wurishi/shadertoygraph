{"ver":"0.1","info":{"id":"wltczf","date":"1609677848","viewed":197,"name":"Cornell Box (Diffuse Only)","username":"Mobeen","description":"Experimented with path tracing (diffuse only) to see how to do direct light sampling. This is for educational purposes only. Left is direct light sampling and right is no direct light sampling. Inset is shown to see details which can be moved using mouse ","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float insetL = 5.0f;\nconst float insetT = 188.0f;\nconst float insetR = 188.0f;\nconst float insetB = 5.0f;\nfloat scale = 2.0f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    // apply exposure (how long the shutter is open)\n    color *= c_exposure;\n\n    // convert unbounded HDR color range to SDR color range\n    color = ACESFilm(color);\n\n    // convert from linear to sRGB for display\n    color = LinearToSRGB(color);\n    \n    float splitCoord = iResolution.x/2.;\n    \n    //creating a more windows like splitter :P\n    if (abs(fragCoord.x - splitCoord) < 1.0) {\n\t\t color= vec3(0.75f,0.75f,0.75f);    \n\t}  \n    if (abs(fragCoord.x-2.f - splitCoord) < 1.0 ) {\n\t\t color= vec3(0.25f,0.25f,0.25f);    \n\t}  \n    if (abs(fragCoord.x+2.f - splitCoord) < 1.0) {\n\t\t color= vec3(1.0f,1.0f,1.0f);    \n\t}  \n    \n    //inset movement\n    float mX = iMouse.x;\n    float mY = iMouse.y;\n    \n    if(mX==0.f && mY==0.f)\n    {\n       mX=iResolution.x/2.f;\n       mY=iResolution.y/2.f;\n    } \n\n    float inv_scale = 1.f/scale;\n    float L = mX-50.f*inv_scale;\n    float B = mY-50.f*inv_scale;\n    float T = mY+50.f*inv_scale;\n    float R = mX+50.f*inv_scale;\n    \n    //drawing the inset on rendering output\n    if(fragCoord.x>=L && fragCoord.x<R && fragCoord.y>=B && fragCoord.y<T)\n    { \n        float distX = fragCoord.x-L;\n        float distY = fragCoord.y-B;\n        float distX2 = R-fragCoord.x;\n        float distY2 = T-fragCoord.y;\n        if(distX <1.f || distX2 <= 1.f || distY < 1.f || distY2 <= 1.f)\n            color = vec3(1.f,0.f,0.f); \n    }\n    \n    //draw the zoom view in lower left\n    if (fragCoord.x >=insetL && fragCoord.y>=insetB && fragCoord.x<insetR && fragCoord.y <insetT)\n    {\n        float xx = fragCoord.x; \n        float yy = fragCoord.y; \n       \n        xx = map(xx, insetL, insetR, L, R); \n        yy = map(yy, insetB, insetT, B, T); \n        color = texture(iChannel0, vec2(xx, yy) / iResolution.xy).xyz;   \n        color *= c_exposure;\n        color = ACESFilm(color);\n        fragColor.xyz = LinearToSRGB(color).xyz; \n    }\n    else\n    {\n        fragColor = vec4(color, 1.0f);\n    } \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// a pixel value multiplier of light before tone mapping and sRGB\nconst float c_exposure = 0.5f; \n// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.001f;\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 6.28318530718f;\n// number of ray bounces allowed\nconst int c_numBounces = 8;\n\n// to move the scene around, since we can't move the camera yet\nconst vec3 sceneTranslation = vec3(0.0f, 0.0f,50.0f);\nconst vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n \n\n// how many renders per frame - to get around the vsync limitation.\nconst int c_numRendersPerFrame = 1;\n\n//direct light sampling variables\nconst vec3  light_position=vec3(0.f, 23.99f, 23.f);\nconst float light_width = 18.f;\nconst float light_depth = 14.0f;\nconst float light_half_width = 9.f;\nconst float light_half_depth = 7.f;\nconst float light_area = light_width*light_depth;\nconst vec3  light_normal = vec3(1, 1, 1); \nconst vec3  light_emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{   \n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nfloat map(float value,float start1, float stop1, float start2, float stop2) \n{\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal; \n    vec3 albedo;\n    vec3 emissive;\n};\n \n     \nSRayHitInfo GetZeroedRayInfo()\n{\n    SRayHitInfo ret;\n    ret.albedo = vec3(0.0f, 0.0f, 0.0f);\n    ret.emissive = vec3(0.0f, 0.0f, 0.0f);\n    ret.normal =  vec3(0.0f, 0.0f, 0.0f);\n    ret.dist = c_superFar;\n    return ret;\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n \n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        //normal *= -1.0f;\n        normal = -normal;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n \nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{     \n\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-24.f, -24.f, 48.0f) + sceneTranslation;\n        vec3 B = vec3( 24.f, -24.f, 48.0f) + sceneTranslation;\n        vec3 C = vec3( 24.f,  24.f, 48.0f) + sceneTranslation;\n        vec3 D = vec3(-24.f,  24.f, 48.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}    \n    \n    // floor\n    {\n        vec3 A = vec3(-24.f, -24.f, 48.0f) + sceneTranslation;\n        vec3 B = vec3( 24.f, -24.f, 48.0f) + sceneTranslation;\n        vec3 C = vec3( 24.f, -24.f, 0.0f) + sceneTranslation;\n        vec3 D = vec3(-24.f, -24.f, 0.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-24.f, 24.f, 48.0f) + sceneTranslation;\n        vec3 B = vec3( 24.f, 24.f, 48.0f) + sceneTranslation;\n        vec3 C = vec3( 24.f, 24.f, 0.0f) + sceneTranslation;\n        vec3 D = vec3(-24.f, 24.f, 0.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-24.f, -24.f, 48.0f) + sceneTranslation;\n        vec3 B = vec3(-24.f, -24.f, 0.0f) + sceneTranslation;\n        vec3 C = vec3(-24.f,  24.f, 0.0f) + sceneTranslation;\n        vec3 D = vec3(-24.f,  24.f, 48.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 24.f, -24.f, 48.0f) + sceneTranslation;\n        vec3 B = vec3( 24.f, -24.f, 0.0f) + sceneTranslation;\n        vec3 C = vec3( 24.f,  24.f, 0.0f) + sceneTranslation;\n        vec3 D = vec3( 24.f,  24.f, 48.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.1f, 0.1f, 0.7f);\n            hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }    \n    \n   // light\n    {\n        vec3 A =  light_position + vec3(-light_half_width, 0.0f,  light_half_depth) + sceneTranslation;\n        vec3 B =  light_position + vec3( light_half_width, 0.0f,  light_half_depth) + sceneTranslation;\n        vec3 C =  light_position + vec3( light_half_width, 0.0f,  -light_half_depth) + sceneTranslation;\n        vec3 D =  light_position + vec3(-light_half_width, 0.0f,  -light_half_depth) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.emissive = light_emissive;\n        }        \n    }\n    \n    //left reflective sphere\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-12.0f, -16.f, 30.0f, 8.0f)+sceneTranslation4))\n    {\n        hitInfo.albedo = vec3(1.f, 1.f, 1.f);\n        hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);      \n    } \n    \n    //right refractive sphere\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(12.0f, -16.f, 20.0f, 8.0f)+sceneTranslation4))\n    {\n        hitInfo.albedo = vec3(1.f, 1.f, 1.f);\n        hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);   \n    }     \n\n}\n\nvec3 sampleLight(inout uint seed ) {\n    float r11 = RandomFloat01(seed) * 2.0f - 1.0f;\n    float r12 = RandomFloat01(seed) * 2.0f - 1.0f;\n    return light_position.xyz + vec3(r11 * light_half_width, 0.f,r12 * light_half_depth);\n    \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) \n{\n     \n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_superFar;\n    TestSceneTrace(ro, rd, hitInfo); \n    \n    return hitInfo.dist!=c_superFar && hitInfo.dist < dist; \n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState, bool directLightSampling)\n{\n    // initialize\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    bool next_emission = true;\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo = GetZeroedRayInfo();\n        \n        TestSceneTrace(rayPos, rayDir, hitInfo);\n         \n        // if the ray missed, we are done\n        if (hitInfo.dist == c_superFar)\n        {\n             \n            break;\n        }\n        \n        bool isLight = dot(hitInfo.emissive,hitInfo.emissive)>0.f;\n        if( isLight && next_emission) \n        {\n            ret += throughput*hitInfo.emissive;  \n            if( directLightSampling ) {\n                return ret;\n            }              \n        } \n        \n        \n        // update the ray position\n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n         \n        // calculate new ray direction, in a cosine weighted hemisphere oriented at normal\n        rayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));        \n         \n       \n        // add in emissive lighting\n        if(next_emission)\n            ret += hitInfo.emissive * throughput;\n         \n        // update the colorMultiplier\n        throughput *= hitInfo.albedo;\n        \n         \n        if( directLightSampling ) \n        {\n            vec3 on_light =  sampleLight( rngState ) + sceneTranslation;\n        \tvec3 to_light = on_light - rayPos;             \n\t\t\tvec3 nld = normalize(to_light);\n            if(!intersectShadow( rayPos, nld, length(to_light)) )\n            {                \n                float light_cosine = abs(nld.y);\n                float distance_squared = dot(to_light, to_light);\n                float pdf = distance_squared / (light_cosine * light_area);\n                pdf = max(pdf, 0.0001f); //to prevent NAN due to division by 0 and cause fireflies\n                ret += (throughput * light_emissive  * clamp(dot( nld,  hitInfo.normal  ), 0., 1.))/pdf;\n            }\n            next_emission = false;\n        } else {\n            next_emission = true;\n        }\n    }\n  \n    // return pixel color\n    return ret;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float splitCoord = iResolution.x/2.;\n    bool directLightSampling = fragCoord.x < splitCoord;\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // The ray starts at the camera position (the origin)\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    \n    // calculate the camera distance\n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);        \n     \n    // calculate coordinates of the ray target on the imaginary pixel plane.\n    // -1 to +1 on x,y axis. 1 unit away on the z axis\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    \n      // correct for aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    \n    // calculate a normalized vector for the ray direction.\n    // it's pointing from the ray position to the ray target.\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n     \n    // raytrace for this pixel\n    vec3 color = GetColorForRay(rayPosition, rayDir, rngState, directLightSampling);\n \n    // average the frames together\n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color = mix(lastFrameColor, color, 1.0f / float(iFrame+1));\n \n    // show the result\n    fragColor = vec4(color, 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"}]}