{"ver":"0.1","info":{"id":"fdf3zB","date":"1629478950","viewed":475,"name":"bokeh everything","username":"jake_r","description":"Evenly distributed fragments across the original image are turned into circles and scaled based on the fragment's brightness. Try a webcam!\nIMPORTANT: set texture filter to nearest, fullscreen shader (not sure how to fix for mipmap)","likes":9,"published":1,"flags":34,"usePreview":0,"tags":["circles","bokeh","brightness","scaling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float sampleDensity = 60.;\nconst float minRadius = 0.004; //the minimum radius\nconst float maxRadius = 0.007; //the maximum radius\n\nvec2 findNearest(vec2 coordinate){\n    vec2 modSample = coordinate * sampleDensity;\n    float roundedY = round(modSample.y);\n    return vec2(round(modSample.x+0.5*roundedY)-0.5*roundedY, roundedY)/sampleDensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord/iResolution.y;\n    \n    float stepSize = 1./sampleDensity;\n\tvec4 color = vec4(0, 0, 0, 1);\n\tfor(float i = -maxRadius; i <= maxRadius+stepSize; i+=stepSize){\n        for(float j = -maxRadius; j <= maxRadius+stepSize; j+=stepSize){\n            vec2 subCoord = uv + vec2(i, j); //uv + offset\n        \n            subCoord = findNearest(subCoord);\n\n            vec4 gotColor = texture(iChannel0, subCoord*vec2(iResolution.y/iResolution.x, 1.));\n            float brightness = max(max(gotColor.r, gotColor.g), max(gotColor.b, 0.01));\n            float dist = distance(uv, subCoord);\n            \n            color.rgb = max(color.rgb, gotColor.rgb*smoothstep(0.01, 0.3, 1.-min(max(dist-minRadius, 0.)/(brightness*maxRadius), 1.)));\n            \n            //some debug stuff\n            //color.g = max((1.-min(dist, maxRadius)/maxRadius)*0.2, color.g);\n            //color.b += brightness/10.;//max(color.b, brightness);\n            //color.r = max(color.rgb, gotColor.rgb*smoothstep(0.01, 0.3, 1.-min(max(dist-minRadius, 0.)/(brightness*maxRadius), 1.))).r;\n                        \n            //a blur but creepy\n            //color.rgb += gotColor.rgb*smoothstep(0.01, 0.3, 1.-dist/(brightness*maxRadius))*0.005;\n        }\n\t}\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.st/iResolution.xy;\n    float lod = 10.;\n\tfloat limit = 1./lod;\n\tvec2 modSample = uv * (iResolution.xy / lod);\n\tif(mod(modSample.x-0.5*floor(modSample.y), 1.) > limit || mod(modSample.y, 1.) > limit){\n        discard;\n\t}\n\tfragColor = texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(fragCoord.st/iResolution.xy,0.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}