{"ver":"0.1","info":{"id":"ttt3Wr","date":"1605869311","viewed":88,"name":"Light Importance Sampling","username":"matt77hias","description":"Test bed for \"Importance Sampling of Many Lights with Adaptive Tree Splitting\"","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["importancesampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct SampleLocation\n{\n\tvec3 m_position;\n\tvec3 m_normal;\n};\n\nstruct Node\n{\n    vec3  m_centroid;\n    float m_coneThetaE;\n    vec3  m_coneAxis;\n    float m_coneThetaO;\n    float m_radius;\n    float m_power;\n};\n    \nstruct Importance\n{\n    float m_I;\n    bool  m_inside;\n};\n\nImportance importantMeasure(Node node, SampleLocation location)\n{\n    float coneThetaO  = node.m_coneThetaO;\n    float coneThetaE  = node.m_coneThetaE;\n    float radius2     = node.m_radius * node.m_radius;\n    float E           = node.m_power;\n    vec3  dir         = node.m_centroid - location.m_position;\n    float dist2       = max(dot(dir, dir), 1e-7f * 1e-7f);\n    float dist        = sqrt(dist2);\n    vec3  ndir        = dir / dist;\n    \n    float cosThetaU   = sqrt(1.0f - radius2 / max(radius2, dist2));\n\tfloat thetaU      = acos(cosThetaU);\n    float cosThetaI   = clamp( dot(ndir, location.m_normal), -1.0f, 1.0f);\n    float thetaI      = acos(cosThetaI);\n    float cosTheta    = clamp(-dot(ndir, node.m_coneAxis),  -1.0f, 1.0f);\n    float theta       = acos(cosTheta);\n    \n    float thetaIP     = max(thetaI - thetaU, 0.0f);\n    float cosThetaIP  = cos(thetaIP); \n    float thetaP      = max(theta - coneThetaO - thetaU, 0.0f);\n    float cosThetaP   = cos(thetaP);\n    \n    float orientation = (thetaP <= coneThetaE) ? cosThetaP : 0.0f;\n    float brdf        = max(cosThetaIP, 0.0f);\n    \n    float Iin  = E / radius2;\n    float Iout = E * brdf * orientation / dist2;\n    \n    Importance importance;\n    importance.m_I      = (dist2 <= radius2) ? Iin : Iout;\n    importance.m_inside = (dist2 <= radius2);\n    return importance;\n}\n\nconst float g_step     = 1.0f;\nconst float g_exposure = 1.0f;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // [0,1]^2\n    vec2 uv   = fragCoord.xy / iResolution.xy;\n    vec2 cxy  = (2.0f * uv - vec2(1.0f)) * (iResolution.xy / iResolution.xx);\n    vec3 cxyz = g_step * vec3(cxy, 0.0f);\n    \n    vec2 tuv  = vec2(iMouse) / iResolution.xy;\n    vec2 txy  = (2.0f * tuv - vec2(1.0f)) * (iResolution.xy / iResolution.xx);\n    \n    SampleLocation location;\n    location.m_position = vec3(0.0f);\n    location.m_normal   = vec3(normalize(txy), 0.0f);\n    \n    vec3 dir = location.m_position - cxyz;\n    \n    Node node;\n    node.m_centroid   = cxyz;\n    node.m_coneThetaE = 0.523599f; // 30 degrees\n    node.m_coneAxis   = normalize(dir);\n    node.m_coneThetaO = 0.523599f; // 30 degrees\n    node.m_radius     = 0.1f;\n    node.m_power      = 1.0f;\n    \n    Importance importance = importantMeasure(node, location);\n    vec3 color;\n    if (length(dir) <= 0.01f)\n    {\n        color = vec3(0.0f, 1.0f, 0.0f);\n    }\n    else if (importance.m_inside)\n    {\n        color = vec3(0.0f, 0.0f, importance.m_I);\n    }\n    else\n    {\n        color = vec3(importance.m_I, 0.0f, 0.0f);\n    }\n    \n    fragColor = vec4(pow(color.rgb, vec3(g_exposure)), 1.0f);\n}","name":"Image","description":"","type":"image"}]}