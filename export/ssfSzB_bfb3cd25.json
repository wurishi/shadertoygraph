{"ver":"0.1","info":{"id":"ssfSzB","date":"1618776775","viewed":75,"name":"Copper Convolutions","username":"Hyeve","description":"More work on lighting systems & reflections, along with a slightly more interesting scene.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct mat\n{\n    vec3 col;\n    float diff;\n    float spec;\n    float refl;\n    float fres;\n};\n\nstruct obj\n{\n    float sdf;\n    mat mat;\n};\n\nstruct hit\n{\n    float rdf;\n    vec3 pos;\n    mat mat;\n};\n\n#define NMAT mat(vec3(0.1), 1., 0., 0., 0.)\n#define FMAT mat(vec3(0.3), 1., 1., 0.2, 0.7)\n#define OMAT mat(vec3(1.000,0.525,0.161) * 1.5, 1., 1., 0.5, 1.)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat bsdf(vec3 p, vec3 s)\n{\n    p.xy *= rot(iTime);\n    p.xz *= rot(-iTime);\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.) + length(max(q, 0.));\n}\n\nobj om(obj a, obj b)\n{\n    if(a.sdf < b.sdf) {return a;} else {return b;}\n}\n\nobj sceneR(vec3 p)\n{\n   obj b = obj(bsdf(p - vec3(0, 2, 5), vec3(1,0.2,1)), OMAT);\n   obj b1 = obj(bsdf(p - vec3(0, 1, 7), vec3(1,1,0.2)), OMAT);\n   obj b2 = obj(bsdf(p - vec3(-2, 2, 9), vec3(1.5,1.5,1.5)), OMAT);\n   obj b3 = obj(bsdf(p - vec3(2, 2, 7), vec3(0.2,2,1)), OMAT);\n   obj b4 = obj(bsdf(p - vec3(0, 3, 5), vec3(1,1,0.2)), OMAT);\n   \n   return om(b,om(b1,om(b2,om(b3,b4))));\n}\n\nobj scene(vec3 p)\n{\n    vec3 op = p;\n    p.x = abs(p.x) - 2.;  \n    p.x = abs(p.x) - 4.;\n    p.y += sin(p.x) / 4.;\n    //p.y = abs(p.y) - 0.5;\n    p.z = mix(abs(p.z - 4.) - 5., p.z, mod(iTime / 2., 3.2));  \n    if(p.z > 30.) p.z -= 29.;\n    \n    return om(sceneR(p), obj(op.y + 1., FMAT));\n}\n\nhit trace(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p;\n    obj s;\n    for(int i = 0; i < 256; i++)\n    {\n        p = ro + rd * d; \n        s = scene(p);\n        d += s.sdf;\n        if(s.sdf < 0.001) return hit(d, p, s.mat);\n        if(d > 128.) break;\n    }\n    return hit(-1., vec3(0), NMAT);\n}\n\nvec3 normal(hit h)\n{\n    vec2 e = vec2(0.01, 0.);\n    float d = scene(h.pos).sdf;\n    vec3 n = d - vec3(scene(h.pos - e.xyy).sdf, scene(h.pos - e.yxy).sdf, scene(h.pos - e.yyx).sdf);\n    return normalize(n);\n}\n\nvec3 lit(hit o, vec3 rd)\n{\n    vec3 n = normal(o);\n    vec3 ld = normalize(vec3(0,2,0) - o.pos);\n    float diff = max(dot(n,ld), 0.) * o.mat.diff;\n    float fres = pow(1. - abs(dot(n,rd)), 4.) * o.mat.fres;\n    float spec = pow(max(dot(reflect(-ld, n), -rd), 0.),40.) * o.mat.spec;\n    vec3 col = o.mat.col * (diff + fres) + spec;\n    return col;\n}\n\nvec3 col(vec3 ro, vec3 rd)\n{\n    mat ret = NMAT;\n    vec3 rfo = ro, rfd = rd;\n    float mxamnt = 1.;\n\n    for(int i = 0; i < 8; i++)\n    {\n        hit h = trace(rfo, rfd);\n        ret.col = mix(ret.col, lit(h, rfd), mxamnt);\n        if(h.mat.refl <= 0.) break;       \n        vec3 n = normal(h);  \n        rfd = reflect(rfd, n);\n        rfo = h.pos + n * 0.001 * 2.;\n        mxamnt = clamp(mxamnt - (1. - h.mat.refl), 0., 1.);\n    }\n    \n    return ret.col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,2,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y, 1.));\n    \n    // Output to screen\n    fragColor = vec4(col(ro,rd),1.0);\n}","name":"Image","description":"","type":"image"}]}