{"ver":"0.1","info":{"id":"ddscD4","date":"1686835551","viewed":105,"name":"raymarch uno","username":"bailesdtd","description":"Forgive the messy code, first try. If anyone sees any glaring issues or inefficiencies, please let me know.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float GAMMA = 2.2;\nconst vec3 UP = vec3(0.0,1.0,0.0);\nstruct Light {\n    vec3 diff;\n    vec3 spec;\n    vec3 dir;\n};\nmat3 rotationMatrix(vec3 axis, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0-c;\n    return mat3(\n        t*axis.x*axis.x+c,          t*axis.x*axis.y+axis.z*s,   t*axis.x*axis.z-axis.y*s,\n        t*axis.x*axis.y-axis.z*s,   t*axis.y*axis.y+c,          t*axis.y*axis.z+axis.x*s,\n        t*axis.x*axis.z+axis.y*s,   t*axis.y*axis.z-axis.x*s,   t*axis.z*axis.z+c\n    );\n}\n\nvec3 opTx(vec3 p, mat3 t)\n{\n\n    return transpose(t)*p;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0))-0.05;\n}\nfloat sdSphere(vec3 p, vec3 c, float r) {\n     return length(p - c) - r;\n }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere (vec3 p,\n              float r_ofst,\n              float t_ofst,\n              float freq,\n              float amp,\n              float r) {   \n    return sdSphere(p, rotationMatrix(UP, r_ofst)*vec3(sin(freq * iTime+t_ofst)*amp,0.0,0.0), r);\n              }\n\n\n\nfloat map(vec3 p) {\n    float s = 4.6;\n    float r = 0.4;\n    float freq = 0.2 * PI;\n\n    float bf = sdBoxFrame(opTx(p, rotationMatrix(vec3(0.0,1.0,0.0), -freq * iTime*1.0)), vec3(1.4), 0.15);\n    float pl = sdPlane(p, vec3(0.0,1.0,0.0), 2.0);\n    \n    float sph1 =  sphere(p,      0.0,      0.0,      freq, s, r);\n    float sph2 =  sphere(p,      0.25*PI,  0.25*PI,  freq, s, r);\n    float sph3 =  sphere(p,      0.5*PI,   0.5*PI,   freq, s, r);\n    float sph4 =  sphere(p,      0.75*PI,  0.75*PI,  freq, s, r);\n\n \n    return min(bf, min(pl, min(sph1, min(sph2, min(sph3, sph4))))); \n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 norm( in vec3 p )\n{\n#if 0    \n    float e = 0.00001;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return -normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001);\n    }\n    return -normalize(n);\n#endif    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat falloff(vec3 p ){\n    return 1.0-length(p)*0.05;\n}\n\nfloat inverse_lerp(float a, float b, float v){\n    return (v-a) / (b-a);\n}\n\nvec3 lighting(vec3 p, vec3 ro) {\n    float ks = 0.6;\n    float kd = 0.7;\n    float ka = 0.02;\n    float a = 10.0;\n    const int n_lights = 2;\n    Light lights[n_lights] = Light[n_lights](\n        Light(\n            vec3(0.7, 0.9, 1.0),\n            vec3(0.85, 0.95, 1.0),\n            normalize(vec3(-0.6, -0.5, 0.4))\n        ),\n        Light(\n            vec3(1.0, 0.8, 1.0),\n            vec3(1.0, 0.9, 1.0),\n            normalize(vec3(0.6, -0.5, 0.4))\n        )\n    );\n    float sh = 0.0;\n    vec3 am = vec3(0.0,0.0,0.0);\n    vec3 I = vec3(0.0);\n    vec3 n = -norm(p);\n    vec3 v = normalize(ro - p);\n    for (int i = 0; i < n_lights; i++) {\n        vec3 l = -lights[i].dir;\n        vec3 s = lights[i].spec;\n        vec3 d = lights[i].diff;\n        vec3 r = 2.0 * dot(l, n) * n - l;\n        am += d / float(n_lights);\n        sh = softshadow(p, l, 0.1, 16.0, 32.0);\n        I += sh * (kd * max(0.0, dot(l, n)) * d + ks * pow(max(0.0, dot(r, v)), a) * s);\n    }\n    float t = clamp(inverse_lerp(20.0, 30.0, length(p)),0.0,1.0);\n    return mix(I + am * ka, am, t);\n    //vec3(0.714,0.827,0.937)\n}\n\n\n\n\n\nvec3 march(vec3 ro, vec3 rd) {\n    float s = 0.0;\n    const int N = 256;\n    const float MIN = 0.001;\n    const float MAX = 100.0;\n    vec3 p = vec3(0.0);\n    for (int i = 0; i < N; ++i) {\n        p = ro + s * rd;\n        float d = map(p);\n        if (d < MIN) {\n             return lighting(p, ro);\n         }\n        if (s > MAX) {\n             break;\n         }\n         s += d;\n     }\n    return lighting(p, ro);\n }\nvec3 dir(vec2 uv) {\n     return normalize(vec3(uv, 1.0));\n }\n\nvec3 col(vec2 uv) {\n\n     //vec3 ro =  normalize(vec3(0.0, 1.0, -3.0)) * 5.0;\n     vec3 ro = rotationMatrix(vec3(0.0,1.0,0.0), -PI*0.125)*vec3(0.0,0.0,-4.0);\n     vec3 rd = rotationMatrix(vec3(0.0,1.0,0.0), -PI*0.125)*dir(uv);\n\n     vec3 c = march(ro, rd);\n     return c;\n }\n \nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n     vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n     vec3 c = col(uv);\n     c = pow(c, vec3(1.2));\n     c = clamp(c,0.0,1.0);\n     c = gamma(c, 1.0/GAMMA);\n     fragColor = vec4(c, 1.0);\n }","name":"Image","description":"","type":"image"}]}