{"ver":"0.1","info":{"id":"3lByDh","date":"1594223751","viewed":95,"name":"Borromean World Beta","username":"sl2c","description":"If you put the Borromean rings in the 3-sphere and double-cover the sphere branched around the rings, you get a manifold with Euclidean geometry.  This is effectively that manifold.  However, I don't know how to do shading yet.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","euclidean","wraparound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nfloat dist(vec2 z) {\n    vec2 r = vec2(z.x-0.5, min(z.y,1.0-z.y));\n    return sqrt(dot(r,r));\n}\n\nfloat scene(vec3 p) {\n    return min(min(dist(p.xy),dist(p.yz)),dist(p.zx)) - 0.05;\n}\n\nvoid borro(inout vec2 z, inout vec2 v) {\n    if (z.y < 0.0) {\n        z = vec2(1.0, 0.0) - z;\n        v = -v;\n    }\n    if (z.y > 1.0) {\n        z = vec2(1.0, 2.0) - z;\n        v = -v;\n    }\n}\n\nvoid rotate(inout vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    z = vec2(z.x * c - z.y * s,\n             z.y * c + z.x * s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float w = mod(iTime * 0.1 + 0.5, 1.0);\n    \n    vec3 loc = vec3(w);\n    vec3 dir = vec3(uv,0.5);\n    dir = normalize(dir);\n    \n    if (iMouse.x > 0.0) {\n        vec2 m = (tau / 2.5) * (iMouse.xy - iResolution.xy * 0.5)/iResolution.y;        \n        rotate(dir.yz, m.y);\n        rotate(dir.xz, m.x);\n    }\n    \n    float fog = 0.0; int i;\n    for(i=0; i<100; i++) {\n        float d = scene(loc);\n        if (d < 0.01) {\n            break;\n        }\n        loc += d * dir;\n        fog += d;\n        \n\t    borro(loc.xy, dir.xy); borro(loc.yz, dir.yz); borro(loc.zx, dir.zx);\n    }\n    \n    if (dist(loc.xy)<0.11) {\n        col = vec3(1.0,0.0,0.0);\n    } else if (dist(loc.yz)<0.11) {\n        col = vec3(0.0,1.0,0.0);\n    } else if (dist(loc.zx)<0.11) {\n        col = vec3(0.0,0.0,1.0);\n    } else {\n        col = vec3(0.5);\n    }\n\n    // Output to screen\n    fragColor = vec4(col * exp(-fog * 0.12) * 0.98,1.0);\n}","name":"Image","description":"","type":"image"}]}