{"ver":"0.1","info":{"id":"Xf3SDX","date":"1714495736","viewed":538,"name":"Analytical Penumbra Diagram","username":"chronos","description":" An analytical 2D visibility / soft shadow calculation.","likes":34,"published":1,"flags":0,"usePreview":1,"tags":["mouse","interactive","shadow","circle","penumbra","analytical","inversion","soft","tangents","diagram"],"hasliked":0,"parentid":"4ctSRX","parentname":"Analytical Penumbra via Tangents"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Analytical Penumbra Diagram by chronos\n    ---------------------------------------------------------\n    \n    This an explainer diagram of sorts for the forked shader :)\n    \n    Mouse-over the penumbra region!\n    \n    The mouse-controlled regions are regions where the angle\n    of the mouse-tangent intersection points to the occluder object (indicated as arrows in blue and green)\n    fall between the (inner and outer) mutual circle tangents (indicated as regions in blue and green).\n    When the corresponding color arrows are in their region, \n    it means that the query point is in the top or bottom penumbra region. \n    When they are in both, the query point is in the antumbra region. \n    This information can be used to determine how to 'clip' the light visibility cone against the occluder cone, \n    or form partial visibility cones for the top and bottom part of the penumbra.\n    By studying the relationship between the light and occluder cones to the colored regions,\n    one can figure out how this determination should be done.\n    \n    Self link: https://www.shadertoy.com/view/Xf3SDX\n    \n    \n\n    // Forked shader description:\n    ---------------------------------------------------------------------\n        \n        Analytical Penumbra via Tangents by chronos\n        --------------------------------------------\n\n        This is an implementation of an analytical occluded-visibility calculation for\n        an area light source, giving soft shadows.\n\n        It uses geometrical methods based on the (inner and outer) mutual tangents between two circles,\n        and as a special case, the tangents to a circle from a point.\n\n        There may be easier ways to go about this, but I found that getting all the subtle special cases\n        correct was very tricky! Hopefully I managed to weed them all out :)\n\n        Below of stippled line is the numerical brute force version for comparison.\n\n        Note to self: can use abs() symmetry across line through circle centers!\n\n\n        Code for circle tangents are from one of my previous shaders:\n        \"Circle Tangents via Inversion\"\n        https://www.shadertoy.com/view/MXfGzr\n\n        // Forked shader description:\n        ---------------------------------------------------------------------\n\n            Numerical Penumbra Doodle by chronos\n            --------------------------------------------\n\n            A 'brute force' numerical 2D visibility calculation.\n            Area light source to generate soft shadow and a single occluder.\n            Assumes the shapes don't overlap.\n            Not monte-carlo, just regular uniform sampling.\n            No accumulation, just a lot of samples :)\n\n            true sRGB makes a notable difference here (on my screen at least).\n*/\n\nconst float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat segment(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat line(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(dot(p,b)/dot(b,b) * b - p);\n}\n\nfloat linedots(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    float num_dots = 30.;\n    return length(round(num_dots*dot(p,b)/dot(b,b))/num_dots * b - p);\n}\n\n\nfloat linedash(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    float num_dashes = 30.;\n    float proj = dot(p,b)/dot(b,b);\n    \n    float gate = mod(floor(num_dashes*proj), 2.);\n    \n    float rounded = round(num_dashes*proj)/num_dashes;\n    \n    float nearest = mix(proj, rounded, gate);\n    \n    return length(nearest * b - p);\n}\n\nfloat linestippledash(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    float num_dashes = 30.;\n    float proj = dot(p,b)/dot(b,b);\n    \n    float gate = mod(round(num_dashes*proj), 2.);\n    \n    float rounded = round(num_dashes*proj)/num_dashes;\n    \n    float nearest = mix(proj, rounded, gate);\n    \n    return length(nearest * b - p);\n}\n\n\nvoid swap(inout vec2 a, inout vec2 b)\n{\n    vec2 temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid swap(inout float a, inout float b)\n{\n    float temp = a;\n    a = b;\n    b = temp;\n}\n\nfloat wedge(vec2 a, vec2 b) { return determinant(mat2(a, b)); }\n\nfloat side(vec2 a, vec2 b) { return sign(wedge(a,b)); }\n\n// v left of a\nfloat leftof(vec2 v, vec2 a) { return step(0., wedge(a, v)); }\n\nfloat rightof(vec2 v, vec2 a) { return step(0., wedge(v, a)); }\n\nfloat between(vec2 v, vec2 a, vec2 b)\n{\n    return step(0., side(a,b)*(side(a,v) + side(v,b))-1.) ;\n}\n\nvec2 rot90(vec2 v) { return vec2(-1,1) * v.yx; }\n\nfloat arrow(vec2 a, vec2 b, vec2 uv)\n{\n    vec2 ab = normalize(b-a);\n    vec2 n  = rot90(ab);\n    \n    return \n        min(min(segment(b-ab*0.05 + 0.01*n, b, uv), segment(b-ab*0.05 - 0.01*n, b, uv)), segment(a,b, uv));\n}\n\nmat2 get_circle_tangents(vec2 center, float r, vec2 q)\n{\n    q -= center;\n\n    vec2 circle_inverse_q = q * r * r / dot(q, q);     // This is the circle inversion!\n    \n    // Swap if Q is inside circle\n    if(length(circle_inverse_q) > length(q))\n    {\n        swap(q, circle_inverse_q);\n    }\n    \n    float h = length(circle_inverse_q);  // height ( 's' in the description )\n    \n    // we know y, which is equal to the height h, so we only need to find the two x values\n    // Use Pythagoras\n    // ('x' is 's' in the description)\n    \n    float x = sqrt(r*r - h*h); // intersection points are plus/minus x\n    \n    vec2 q_perp = x * normalize(rot90(q));\n    \n    vec2 p0 = circle_inverse_q + q_perp;\n    vec2 p1 = circle_inverse_q - q_perp;\n    \n    return mat2(p0+center, p1+center);\n}\n\nfloat get_circle_projection(vec2 center, float r, vec2 q)\n{\n    q -= center;\n\n    vec2 circle_inverse_q = q * r * r / dot(q, q);     // This is the circle inversion!\n    \n    // Swap if Q is inside circle\n    if(length(circle_inverse_q) > length(q))\n    {\n        swap(q, circle_inverse_q);\n    }\n    \n    float h = length(circle_inverse_q);  // height ( 's' in the description )\n    \n    // we know y, which is equal to the height h, so we only need to find the two x values\n    // Use Pythagoras\n    // ('x' is 's' in the description)\n    \n    float x = sqrt(r*r - h*h); // intersection points are plus/minus x\n    \n    vec2 p0 = circle_inverse_q + x * normalize(vec2(-1,1)*q.yx);\n    vec2 p1 = circle_inverse_q - x * normalize(vec2(-1,1)*q.yx);\n    \n    \n    return length(p0 - p1);\n}\n\nmat4x2 get_outer_tangents(vec2 pos0, float r0, vec2 pos1, float r1)\n{\n    vec2 smallest_circle_pos = pos0;\n    vec2 largest_circle_pos = pos1;\n    float smallest_circle_radius = r0;\n    float largest_circle_radius = r1;\n\n    if(r1 < r0)\n    {\n        swap(smallest_circle_pos, largest_circle_pos);\n        swap(smallest_circle_radius, largest_circle_radius);\n    }\n    \n    mat2 outer_tangents = get_circle_tangents(largest_circle_pos, largest_circle_radius-smallest_circle_radius, smallest_circle_pos);\n        \n    vec2 normal_dir = normalize(outer_tangents[0] - largest_circle_pos);\n    vec2 from0 = smallest_circle_pos + normal_dir * smallest_circle_radius;\n    vec2 to0 = outer_tangents[0] + normal_dir * smallest_circle_radius;\n\n    normal_dir = normalize(outer_tangents[1] - largest_circle_pos);\n    vec2 from1 = smallest_circle_pos + normal_dir * smallest_circle_radius;\n    vec2 to1   = outer_tangents[1] + normal_dir * smallest_circle_radius;\n\n    if(r1 < r0)\n    {\n        swap(from0, from1);\n        swap(to0, to1);\n    }\n\n    return mat4x2(from0, to0, from1, to1);\n}\n\nmat4x2 get_inner_tangents(vec2 pos0, float r0, vec2 pos1, float r1)\n{\n    vec2 smallest_circle_pos = pos0;\n    vec2 largest_circle_pos = pos1;\n    float smallest_circle_radius = r0;\n    float largest_circle_radius = r1;\n\n    if(r1 < r0)\n    {\n        swap(smallest_circle_pos, largest_circle_pos);\n        swap(smallest_circle_radius, largest_circle_radius);\n    }\n\n    mat2 inner_tangents = get_circle_tangents(largest_circle_pos, largest_circle_radius+smallest_circle_radius, smallest_circle_pos);\n                \n    vec2 normal_dir = normalize(inner_tangents[0] - largest_circle_pos);\n    vec2 from0 = smallest_circle_pos - normal_dir * smallest_circle_radius;\n    vec2 to0   = inner_tangents[0] - normal_dir * smallest_circle_radius;\n\n    normal_dir = normalize(inner_tangents[1] - largest_circle_pos);\n    vec2 from1 = smallest_circle_pos - normal_dir * smallest_circle_radius;\n    vec2 to1   = inner_tangents[1] - normal_dir * smallest_circle_radius;\n    \n    return mat4x2(from0, to0, from1, to1);\n}\n\n\nfloat winding(vec2 a, vec2 b, vec2 p)\n{\n    float sgn = sign(determinant(mat2(a-p, b-p)));\n    return sgn * acos(dot(normalize(a-p), normalize(b-p))) / (2. * PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 mouse = ( 2.*iMouse.xy - iResolution.xy ) / iResolution.y;\n    bool mouse_pressed = iMouse.z > 0.;\n\n    if(length(iMouse.xy) < 10.)\n    {\n        mouse = vec2(cos(.5*iTime), sin(iTime))*0.75 + vec2(0.5, 0.);\n        mouse_pressed = true;\n    }\n\n\n    float ps = 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 ro = uv;\n    vec2 rd = vec2(0);\n    \n    vec2 light_pos    = vec2(-1,0); //mouse;\n    vec2 occluder_pos = vec2(0.75 + .75 * sin(iTime*.75),0);\n    \n    float light_radius = 0.4 + 0.25 * cos(iTime);\n    \n    float occluder_radius = 0.2;\n    \n    float line_thickness = 0.0025;\n\n    // Analytical penumbra calculation\n    {\n        mat4x2 inner_tangents = get_inner_tangents(light_pos, light_radius, occluder_pos, occluder_radius);\n\n        vec2 from0 = inner_tangents[0];\n        vec2 to0   = inner_tangents[1];\n        if(light_radius < occluder_radius) swap(from0, to0);\n        vec2 from1 = inner_tangents[2];\n        vec2 to1   = inner_tangents[3];\n        if(light_radius < occluder_radius) swap(from1, to1);\n\n        mat4x2 outer_tangents = get_outer_tangents(light_pos, light_radius, occluder_pos, occluder_radius);\n        vec2 from2 = outer_tangents[0];\n        vec2 to2 = outer_tangents[1];\n        if(light_radius < occluder_radius) swap(from2, to2);\n        vec2 from3 = outer_tangents[2];\n        vec2 to3 = outer_tangents[3];\n        if(light_radius < occluder_radius) swap(from3, to3);\n\n        mat2 occluder_tangents_pixel = get_circle_tangents(occluder_pos, occluder_radius, uv);\n\n        float in_top_penumbra = \n            between(occluder_tangents_pixel[0]-occluder_pos, from1-occluder_pos, from3-occluder_pos)\n\n        ;\n\n        float in_bot_penumbra = \n            between(occluder_tangents_pixel[1]-occluder_pos, from0-occluder_pos, from2-occluder_pos)\n\n        ;\n\n        float in_umbra = \n            rightof(uv-from2, from3-from2)\n            * rightof(uv-to3, from3-to3)\n            * leftof(uv-to2, from2-to2)\n        ;\n\n        mat2 occluder_tangents = get_circle_tangents(occluder_pos, occluder_radius, uv);\n        mat2 light_tangents = get_circle_tangents(light_pos, light_radius, uv);\n\n        float top_penumbra = winding(light_tangents[0], occluder_tangents[0], uv);\n        float bot_penumbra = winding(occluder_tangents[1], light_tangents[1], uv);\n\n        float full_light = winding(light_tangents[0], light_tangents[1], uv);\n\n        float light = (1.-max(max(in_top_penumbra, in_bot_penumbra), in_umbra)) * full_light;\n\n        light += in_top_penumbra * top_penumbra;\n        light += in_bot_penumbra * bot_penumbra;\n\n        color += light;\n\n\n        float occluder_alpha = smoothstep(occluder_radius+ps, occluder_radius-ps, distance(uv, occluder_pos));\n        color = mix(color, vec3(0.5), occluder_alpha);\n\n        float light_alpha = smoothstep(light_radius+ps, light_radius-ps, distance(uv, light_pos));\n        color = max(color, light_alpha);\n    }\n\n    if (mouse_pressed)\n    { // Draw circle mouse tangents\n\n        mat2 occluder_tangents = get_circle_tangents(occluder_pos, occluder_radius, mouse);\n        \n        float t0dist = segment(mouse, occluder_tangents[0], uv);\n        color = mix(color, vec3(0,1,0), .5*smoothstep(line_thickness+ps, line_thickness-ps, t0dist));\n        \n        float t1dist = segment(mouse, occluder_tangents[1], uv);\n        color = mix(color, vec3(0,1,0), .5*smoothstep(line_thickness+ps, line_thickness-ps, t1dist));\n        \n        mat2 light_tangents = get_circle_tangents(light_pos, light_radius, mouse);\n        \n        t0dist = segment(mouse, light_tangents[0], uv);\n        color = mix(color, vec3(0,0,1), .5*smoothstep(line_thickness+ps, line_thickness-ps, t0dist));\n        \n        t1dist = segment(mouse, light_tangents[1], uv);\n        color = mix(color, vec3(0,0,1), .5*smoothstep(line_thickness+ps, line_thickness-ps, t1dist));\n\n        mat2 visibility_tangents = get_circle_tangents(light_pos, light_radius, uv);\n                \n        \n        /*\n            Occluder tangent query arrows\n        */\n        color = mix(color, vec3(0,1,0), .75*smoothstep(line_thickness+ps, line_thickness-ps, arrow(occluder_pos, occluder_tangents[0], uv)));\n        color = mix(color, vec3(0,0,1), .75*smoothstep(line_thickness+ps, line_thickness-ps, arrow(occluder_pos, occluder_tangents[1], uv)));\n        //color = mix(color, vec3(0,1,0), .75*smoothstep(line_thickness+ps, line_thickness-ps, arrow(light_pos, light_tangents[0], uv)));\n        //color = mix(color, vec3(0,0,1), .75*smoothstep(line_thickness+ps, line_thickness-ps, arrow(light_pos, light_tangents[1], uv)));\n    }\n    \n    #if 1\n    { // Draw mutual circle tangents\n                \n        /*\n            Inner tangents\n        */\n        \n        mat4x2 inner_tangents = get_inner_tangents(light_pos, light_radius, occluder_pos, occluder_radius);\n                \n        vec2 from0 = inner_tangents[0];\n        vec2 to0   = inner_tangents[1];\n        if(light_radius < occluder_radius) swap(from0, to0);\n        float t0dist = linedash(from0, to0, uv);\n        color = mix(color, vec3(1,0,1), smoothstep(line_thickness+ps, line_thickness-ps, t0dist));\n        color = mix(color, vec3(1,0,1), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-from0)));\n        color = mix(color, vec3(1,0,1), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-to0)));\n\n        vec2 from1 = inner_tangents[2];\n        vec2 to1   = inner_tangents[3];\n        if(light_radius < occluder_radius) swap(from1, to1);\n        float t1dist = linedash(from1, to1, uv);\n        color = mix(color, vec3(1,0,0), smoothstep(line_thickness+ps, line_thickness-ps, t1dist));\n        color = mix(color, vec3(1,0,0), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-from1)));\n        color = mix(color, vec3(0,1,0), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-to1)));\n\n\n\n        /*\n            Outer tangents\n        */\n        \n        mat4x2 outer_tangents = get_outer_tangents(light_pos, light_radius, occluder_pos, occluder_radius);\n        \n        vec2 from2 = outer_tangents[0];\n        vec2 to2 = outer_tangents[1];\n        if(light_radius < occluder_radius) swap(from2, to2);\n        t0dist = linestippledash(from2, to2, uv);\n        color = mix(color, vec3(1,1,0), smoothstep(line_thickness+ps, line_thickness-ps, t0dist));\n        color = mix(color, vec3(1,1,0), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-from2)));\n        color = mix(color, vec3(1,1,0), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-to2)));\n        \n        vec2 from3 = outer_tangents[2];\n        vec2 to3 = outer_tangents[3];\n        if(light_radius < occluder_radius) swap(from3, to3);\n        t1dist = linestippledash(from3, to3, uv);\n        color = mix(color, vec3(0,1,1), smoothstep(line_thickness+ps, line_thickness-ps, t1dist));\n        color = mix(color, vec3(0,1,1), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-from3)));\n        color = mix(color, vec3(0,1,1), smoothstep(4.*line_thickness+ps, 4.*line_thickness-ps, length(uv-to3)));\n        \n        color += vec3(0,0,0.9) * between(uv-occluder_pos, from0-occluder_pos, from2-occluder_pos) *\n            smoothstep(occluder_radius+ps, occluder_radius-ps, distance(uv, occluder_pos));\n\n        color += vec3(0,0.9,0) * between(uv-occluder_pos, from1-occluder_pos, from3-occluder_pos) *\n            smoothstep(occluder_radius+ps, occluder_radius-ps, distance(uv, occluder_pos));\n            \n\n        float occluder_alpha = smoothstep(occluder_radius+ps, occluder_radius-ps, distance(uv, occluder_pos));\n        mat2 occluder_tangents       = get_circle_tangents(occluder_pos, occluder_radius, mouse);\n        mat2 occluder_tangents_pixel = get_circle_tangents(occluder_pos, occluder_radius, uv);\n\n        if (mouse_pressed)\n        {\n            color += vec3(0,0.1,0)\n                * between(occluder_tangents[0]-occluder_pos, from1-occluder_pos, from3-occluder_pos)\n                * between(occluder_tangents_pixel[0]-occluder_pos, from1-occluder_pos, from3-occluder_pos)\n                *(1.-occluder_alpha)\n            ;\n\n            color += vec3(0,0,0.1)\n                * between(occluder_tangents[1]-occluder_pos, from0-occluder_pos, from2-occluder_pos)\n                * between(occluder_tangents_pixel[1]-occluder_pos, from0-occluder_pos, from2-occluder_pos)\n                *(1.-occluder_alpha)\n            ;\n\n            color += vec3(0.1,0,0)\n                * rightof(mouse-from2, from3-from2) \n\n                * rightof(uv-from2, from3-from2) \n\n                * rightof(mouse-to3, from3-to3)\n                * rightof(uv-to3, from3-to3)\n\n                * leftof(mouse-to2, from2-to2)\n                * leftof(uv-to2, from2-to2)\n            ;\n\n            color += vec3(0.1,0,0)\n                * between(occluder_tangents[0]-occluder_pos, from1-occluder_pos, from3-occluder_pos)\n                * between(occluder_tangents[1]-occluder_pos, from0-occluder_pos, from2-occluder_pos)\n                * between(occluder_tangents_pixel[0]-occluder_pos, from1-occluder_pos, from3-occluder_pos)\n                * between(occluder_tangents_pixel[1]-occluder_pos, from0-occluder_pos, from2-occluder_pos)\n                *(1.-occluder_alpha)\n            ;\n        }\n    }\n    #endif \n    \n    \n    #if 0\n    color = tanh(color);\n    #endif\n        \n    #if 1\n    color = sRGBencode(color); \n    #else\n    color = pow(color, vec3(1./2.2));\n    #endif\n    \n    #if 1\n    color += 1./255. * (-1. + 2.  * texture(iChannel0, fragCoord/1024.)[iFrame%4]);\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n/*\n\nif(0. <= light_scalar_proj && distance(proj_light_pos, light_pos) <= light_radius || distance(ro, light_pos) < light_radius)\n{\n    if(occluder_scalar_proj < 0. || light_scalar_proj < occluder_scalar_proj || occluder_radius < distance(proj_occluder_pos, occluder_pos))\n        color += 1.;\n}        \n*/\n","name":"Image","description":"","type":"image"}]}