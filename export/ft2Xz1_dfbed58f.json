{"ver":"0.1","info":{"id":"ft2Xz1","date":"1627095305","viewed":46,"name":"Retrowave__","username":"lazyllama","description":"retrowave__","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["retrowave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NONE  -1\n#define PLANE  0\n#define SPHERE 1\n\n#define TMAX 10000.\n\nconst float N = 50.0;\n\nconst vec4 skyTop = vec4(0.15f, 0.045f, 0.25f, 1.0f);\nconst vec4 skyBottom = vec4(0.60f, 0.18f, 0.996f, 1.0f);\n\n// see https://iquilezles.org/articles/checkerfiltering\nfloat gridTextureGradBoxFilter(vec2 uv, vec2 ddx, vec2 ddy)\n{\n\tuv += 0.5f;\n\tvec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\tvec2 a = uv + 0.5 * w;\n\tvec2 b = uv - 0.5 * w;\n\n\tvec2 i = (floor(a) + min(fract(a) * N, 1.0) -\n\t\tfloor(b) - min(fract(b) * N, 1.0)) / (N * w);\n\n\treturn (1.0 - i.x) * (1.0 - i.y);\n}\n\n// Generate color based on object uv and position\nfloat gridTexture(vec2 uv)\n{\n\tuv += 0.5f;\n\tvec2 i = step(fract(uv), vec2(1.0 / N, 1.0 / N));\n\treturn (1.0 - i.x) * (1.0 - i.y);\n}\n\n// Calculate uv coordinate of object\nvec2 texCoords(vec3 pos, int objectType)\n{\n\tvec2 uv;\n\tif (objectType == PLANE)\n\t{\n\t\tuv = pos.xz;\n\t}\n\telse if (objectType == SPHERE)\n\t{\n\t\t// Todo\n\t}\n\n\tuv.y -= iTime * 10.;\n\treturn 0.5 * uv;\n}\n\n// Check if ray intersects with an object and return position, distance along ray, normal and object type\nfloat traceRay(vec3 rayOrigin, vec3 rayDir, inout vec3 pos, inout vec3 nor, inout int objType)\n{\n\tfloat tmin = TMAX;\n\tpos = vec3(0.0f, 0.0f, 0.0f);\n\tnor = vec3(0.0f, 0.0f, 0.0f);\n\tobjType = NONE;\n\n\t// Raytrace plane\n\t// ray plane intersection, since normal is (0, 1, 0) only y component matters\n\t// simplified version of \n\t// float t = -dot(rayOrigin-0.01, nor)/dot(rayDir, nor);\n\tfloat t = (-1.0 - rayOrigin.y) / rayDir.y;\n\n\tif (t > 0.0)\n\t{\n\t\ttmin = t;\n\t\tnor = vec3(0.0f, 1.0f, 0.0f);\n\t\tpos = rayOrigin + rayDir * t;\n\t\tobjType = PLANE;\n\t}\n\n\treturn tmin;\n}\n\n// Creates ray based on camera position\nvoid createRay(in vec2 pixel, inout vec3 rayOrigin, inout vec3 rayDirection)\n{\n\t// Remap input position into ndc space in range -1..1\n\tvec2 p = (2. * pixel.xy - iResolution.xy) / iResolution.y;\n\n\tvec3 camPos = vec3(0.0f, 1.0f, 5.0f);\n\tvec3 camDir = vec3(0.0f, 1.0f, 0.0f);\n\n\t// Create look-at matrix with Gramâ€“Schmidt process\n\tvec3 dir   = normalize(camDir - camPos);\n\tvec3 right = normalize(cross(dir, vec3(0.0f, 1.0f, 0.0f)));\n\tvec3 up    = normalize(cross(right, dir));\n\n\t// View ray\n\trayDirection = normalize(p.x * right + p.y * up + 2.0f * dir);\n\trayOrigin = camPos;\n}\n\nfloat rand(float x)\n{\n\treturn fract(sin(x) * 100000.0f);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\t// Invert y\n\t// Remap input position into ndc space in range -1..1\n    vec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\n\tfloat radius = 0.5f;\n\tvec2 ctr = vec2(0.0f, 0.3f);\n\tvec2 diff = p - ctr;\n\n\t// get random heights of buildings\n\tfloat width = 50.0;\n\tfloat skylineHeight = rand((mod(trunc(p.x* width), width)));\n\n\t// have them get smaller along the edges\n\tfloat falloffFactor = 0.7;\n\tskylineHeight *= 1.0 - abs(p.x) * falloffFactor;\n\n\tfloat t = TMAX;\n\tif (p.y > 0.0 && p.y * 2.7 < skylineHeight)\n\t{\n\t\tfragColor = vec4(0.1, 0.1, 0.1, 1.0);\n\t\tfragColor *= rand(p.y) * rand(p.x) * 3.0f;\n\t\tt = 50.0f;\n\t}\n\telse if (dot(diff, diff) < (radius * radius) && p.y > 0.0f)\n\t{\n\t\t// Sun color\n\t\tfragColor = vec4(0.97f, 0.46f, 0.3f, 1.0f) * step(fract(p.y * 15.) - p.y/5., 8./10.0);\n\t\tt = 10.0;\n\t}\n\telse\n\t{\n\t\t// Sky\n\t\tfragColor = mix(skyTop, skyBottom, .5 - p.y/2.);\n\t}\n\n\tvec3 rayDir;\n\tvec3 rayOrigin;\n\tvec3 rayOriginDdx;\n\tvec3 rayDirDdx;\n\tvec3 rayOriginDdy;\n\tvec3 rayDirDdy;\n\n\t// Create main ray and rays for partial derivatives basically one pixel to right and one pixel down\n\tcreateRay(fragCoord, rayOrigin, rayDir);\n\tcreateRay(fragCoord + vec2(1.0, 0.0), rayOriginDdx, rayDirDdx);\n\tcreateRay(fragCoord + vec2(0.0, 1.0), rayOriginDdy, rayDirDdy);\n\n\t// Raytrace\n\tvec3 pos;\n\tvec3 nor;\n\tint objectType = NONE;\n\n\tfloat groundt = traceRay(rayOrigin, rayDir, pos, nor, objectType);\n\n\tt = min(groundt, t);\n\n\t// compute ray differentials, intersect ray with tangent plane to the surface\n\t//\n\t// Take the new position and subtract the hit position from original camera ray.\n\t// This will give us a ray from the position to the new ddx/ddy origin. Then\n\t// we take a dot product with the normal which projects the ray in the direction\n\t// of the normal. Basically it takes the component of the ray that is parallel\n\t// to the normal. Then we do the same with the ray direction and the normal and \n\t// this gives us a small amount, basically the amount of ray in the direction of \n\t// the same normal. Then we divide the ddx/y - position projection with the new ray\n\t// and we get the amnt we have to multiply to reach the new ddx pos on the tangent\n\t// plane.\n\tvec3 posDdx = rayOriginDdx - rayDirDdx * dot(rayOriginDdx - pos, nor) / dot(rayDirDdx, nor);\n\tvec3 posDdy = rayOriginDdy - rayDirDdy * dot(rayOriginDdy - pos, nor) / dot(rayDirDdy, nor);\n\n\t// Calculate uv coords\n\tvec2 uv = texCoords(pos, objectType);\n\n\t// Texture diffs\n\tvec2 uvDdx = texCoords(posDdx, objectType) - uv;\n\tvec2 uvDdy = texCoords(posDdy, objectType) - uv;\n\n\tif (objectType == PLANE)\n\t{\n\t\tfloat color = gridTextureGradBoxFilter(uv, uvDdx, uvDdy);\n\t\tfragColor = mix(vec4(217.0 / 255.0, 117.0 / 255.0, 217.0 / 255.0, 1.0f), vec4(133.0 / 255.0, 46.0 / 255.0, 106.0 / 255.0, 1.0f), color);\n\t}\n\n\t// fog\n\tif (t < TMAX)\n\t{\n\t\tfragColor = mix(fragColor, skyBottom, 1.0 - exp(-0.0001 * t * t));\n\t}\n    return;\n}","name":"Image","description":"","type":"image"}]}