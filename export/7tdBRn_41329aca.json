{"ver":"0.1","info":{"id":"7tdBRn","date":"1663263460","viewed":143,"name":"HW1+2 - my first shader","username":"mmay","description":"First homework for MIPT Gamedev Graphics cource","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["hwmipt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 eye = vec3(0, 0, 6);\nconst vec3 light = vec3(-3.0, 2.0, 10.0);\nvec3 aa = vec3(1, 1, -1);\nvec3 bb = vec3(1, 1, 2);\nconst float gamma = 2.2;\nconst float pi = 3.1415926;\nconst float FDiel = 0.02; \nconst vec3 lightColor = vec3 ( 1.0 );\n \n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat boxRounded ( in vec3 pos, in vec3 size, float r, in mat3 mv )\n{\n    vec3 q =  abs(pos ) - size;\n\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y, q.z)), 0.0)-r;\n}\n\n\nfloat cylinder ( in vec3 pos, in vec3 a, in vec3 b, in float r, in mat3 mv )\n{\n    vec3 pt =  abs(pos);\n    vec3  ba = b - a;\n    vec3  pa = pt - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y) < 0.0)?-min(x2,y2):(((x > 0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sphere ( in vec3 p, in mat3 mv )\n{\n   // vec2 vDisp = vec2(atan(p.x,p.z)/6.2832,p.y/3.)*.5;\n    float disp = 1.;\n    //disp = texture(iChannel2, vDisp).r;\n   // disp*=smoothstep(2., 1., abs(p.y));\n   //disp*=smoothstep(2., 1., abs(p.x));\n   //disp*=smoothstep(2., 1., abs(p.z));\n   disp*= abs(cos(iTime*0.2));\n   return length ( p - vec3(0,0,cos(iTime*0.05))) - 0.8 -.1*disp;\n}\n\nfloat dE ( in vec3 p, in mat3 m, out int hittedObj)\n{\n    vec3  pt = m * rotateY(.1*iTime) * p;\n    float d1 = cylinder(pt, aa, bb, 0.8, m);\n    \n    float d2 = boxRounded(pt, vec3(1,1,1), 0.5,m);\n    \n    float d3 = sphere (pt,m);\n    \n    float res = max(max(-d1,d2),-d3);\n    \n    hittedObj = (res == -d3) ? 3:((res == d2)?2:1);\n    \n    return res;\n}\n\nfloat dE ( in vec3 p, in mat3 m)\n{\n    vec3  pt = m * rotateY(.1*iTime) * p;\n    float d1 = cylinder(pt, aa, bb, 0.8, m);\n    \n    float d2 = boxRounded(pt, vec3(1,1,1), 0.5,m);\n    \n    float d3 = sphere (pt,m);\n    \n    float res = max(max(-d1,d2),-d3);\n    \n    return res;\n}\n\nvec3 trace ( vec3 from, vec3 dir, out int hit, in mat3 m )\n{\n\tvec3\tp = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = -1;\n\t\n\tfor ( int steps = 0; steps < 60; steps++ )\n\t{\n\t\tfloat\tdist = dE ( p, m, hit);\n        \n\t\t\n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\t//hit = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n        {\n            hit = -1;\n\t\t\tbreak;\n\t\t}\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal(vec3 z, in mat3 m)\n{\n    float e = 0.001;\n    float dx1 = dE(z + vec3(e,0,0), m);\n    float dx2 = dE(z - vec3(e,0,0), m);\n    float dy1 = dE(z + vec3(0,e,0), m);\n    float dy2 = dE(z - vec3(0,e,0), m);\n    float dz1 = dE(z + vec3(0,0,e), m);\n    float dz2 = dE(z - vec3(0,0,e), m);\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\n\nconst vec3 lum = vec3 ( 0.2126, 0.7152, 0.0722 );\n\nfloat height ( in vec2 tx  )\n{\n    return dot ( texture ( iChannel1, tx ).rgb * 2.0 - vec3 ( 1.0 ), lum );\n}\n\nvec3 bump ( in vec2 tx)\n{\n    \n    float v  = height ( tx );\n    float vx = height ( vec2 ( tx.x + cos(iTime), tx.y ) );\n    float vy = height ( vec2 ( tx.x, tx.y) );\n    \n    return normalize ( vec3 ( vx - v, vy - v, 0.5 ) );\n}\n\nvec3 bump1 ( in vec2 tx)\n{\n    \n    float v  = height ( tx );\n    float vx = height ( vec2 ( tx.x, tx.y ) );\n    float vy = height ( vec2 ( tx.x, tx.y) );\n    \n    return normalize ( vec3 ( vx - v, vy - v, 0.5 ) );\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = pow(abs(n),vec3(70));\n    \n\treturn triW/(triW.x+triW.y+triW.z);\n}\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\nproduct = clamp ( product, 0.0, 1.0 ); // saturate\nreturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    return exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    float d = (m2 - 1.0) * NdH2 + 1.0;\n    return m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n    return 0.25 / (V * L);\n}\n\nvec3 cookTorrance ( in float nl, in float nv, in float nh, in float vh, in vec3 f0, in float roughness )\n{\nfloat D = D_GGX ( roughness, nh );\nfloat G = G_schlick ( roughness, nv, nl );\nreturn f0 * D * G;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);\n    vec2 scale = 6.0 * iResolution.xy/max(iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2(0.5));\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    vec4 color = vec4 (0, 0, 0, 1);\n    vec3 p = trace(eye, dir, hit, m);\n    \n    if (hit>-1)\n    {\n        \n    \n        if (hit<3)\n        {\n             \n        \n        \n            vec3 n = generateNormal(p,m);\n            vec3 tx = getTriplanarWeights (m*rotateY(.1*iTime)*n);\n            vec3 q  =  m* rotateY(.1*iTime) * p;\n            \n            vec4 cx = texture (iChannel0, q.yz/scale+0.5);\n            vec4 cy = texture (iChannel0, q.zx/scale+0.5);\n            vec4 cz = texture (iChannel0, q.xy/scale+0.5);\n            \n            \n            \n            vec3 base = vec4(cx*tx.x+cy*tx.y+cz*tx.z).xyz;\n            \n            base = pow ( base, vec3 ( gamma ) );\n            vec3 l = normalize(light - p);\n            vec3 v = normalize(eye - p);\n            float roughness;\n            float metallness;\n            if (max(tx.x, max(tx.y, tx.z)) == tx.x)\n            {\n                roughness = texture ( iChannel2, q.yz/scale+0.5).x;\n                metallness = texture ( iChannel0, q.yz/scale+0.5 ).x;\n            } \n            else\n            {\n               if (max(tx.x, max(tx.y, tx.z)) == tx.y)\n                {\n                roughness = texture ( iChannel0, q.zx/scale+0.5).x;\n                metallness = texture ( iChannel2, q.zx/scale+0.5 ).x;\n                }\n                else\n                {\n                    if(max(tx.x, max(tx.y, tx.z)) == tx.z)\n                    {\n                        roughness = texture ( iChannel0, q.xy/scale+0.5).x;\n                        metallness = texture ( iChannel2, q.xy/scale+0.5 ).x;\n                    }\n                }\n            }\n            n = bump1((q).xy);\n            \n            vec3 h = normalize((l + v));\n            \n            float nv = max ( 0.0, dot ( n, v ));\n            float nl = max ( 0.0, dot ( n, l ));\n            float hn = max ( 0.0, dot ( n, h ));\n            float hl = max ( 0.0, dot ( h, l ));\n            float vh = max ( 0.0, dot ( h, v ));\n            \n            vec3 F0 = mix ( vec3 ( FDiel ), base, metallness );\n            vec3 specFresnel = fresnel ( F0, nv );\n            vec3 spec = cookTorrance ( nl, nv, hn, vh, specFresnel, roughness ) * nl /\n            max ( 0.001, 4.0 * nl * nv );\n            vec3 diff = (vec3(1.0) - specFresnel) * nl / pi;\n            float sp = pow(hn, 100.);\n            color = pow ( vec4 ( ( diff * mix ( base, vec3(0.0), metallness) + spec )\n            * lightColor, 1.0 ), vec4 ( 1.0 / gamma ) );\n            //color = color = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 1, 0, 0, 1 );\n            //color*=cx*tx.x+cy*tx.y+cz*tx.z;\n            //color = vec4(tx,1);\n        }\n        else\n        {\n            vec3 base = vec3 ( 1, 0, 0 );\n            base = pow ( base, vec3 ( gamma ) );\n            vec3 l = normalize(light - p);\n            vec3 v = normalize(eye - p);\n            vec3 q  =  m* rotateY(.1*iTime) * p;\n            float roughness = texture ( iChannel1, q.yz/scale+0.5).x;\n            float metallness = texture ( iChannel0, q.yz/scale+0.5 ).x;\n            vec3 n = bump((p).xy);\n            \n            vec3 h = normalize(l + v);\n            \n            float nv = max ( 0.0, dot ( n, v ));\n            float nl = max ( 0.0, dot ( n, l ));\n            float nh = max ( 0.0, dot ( n, h ));\n            float hl = max ( 0.0, dot ( h, l ));\n            float vh = max ( 0.0, dot ( v, h ));\n            \n            vec3 F0 = mix ( vec3 ( FDiel ), base, metallness );\n            vec3 specFresnel = fresnel ( F0, nv );\n            vec3 spec = cookTorrance ( nl, nv, nh, vh, specFresnel, roughness ) * nl /\n            max ( 0.001, 4.0 * nl * nv );\n            vec3 diff = (vec3(1.0) - specFresnel) * nl / pi;\n            color = pow ( vec4 ( ( diff * mix ( base, vec3(0.0), metallness) + spec )\n            * lightColor, 1.0 ), vec4 ( 1.0 / gamma ) );\n           // color = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 1, 0, 0, 1 );\n        }\n    }\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}