{"ver":"0.1","info":{"id":"MsyXRy","date":"1465071083","viewed":202,"name":"Another Lava Lamp","username":"sixstring982","description":"A lava lamp. Pretty cool!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lava","lamp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_DIST 100.0\n#define EPSILON 0.01\n#define INFTY 1e20\n\n#define PI 3.1415926535\n\n#define AUTO_SPIN_SPEED 0.1\n#define CAMERA_DIST 4.0\n#define MOUSE_SPEED 0.01\n\n#define ROT_X_90 mat3(1, 0, 0, 0, 0, -1, 0, 1, 0)\n#define ROT_X_270 mat3(1, 0, 0, 0, 0, 1, 0, -1, 0)\n#define ROT_Y_90 mat3(0, 0, 1, 0, 1, 0, -1, 0, 0)\n\n/* From iq */\nfloat sd_cone( vec3 p, vec2 c ) {\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n/* From iq */\nfloat sd_box( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat plane(float y) {\n    return y;\n}\n\n/* From iq */\nfloat sphere(in vec3 pos, in float radius) {\n    return length(pos) - radius;\n}\n\n/* From iq */\nfloat op_smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat op_union(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat op_intersect( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\nfloat op_subtract( float d1, float d2 )\n{\n    return max(d1,-d2);\n}\n\nfloat lava_map(in vec3 ro) {\n    float d = INFTY;\n    d = op_union(d, sphere(vec3(0.0, sin(iTime * 0.5), 0.0) - ro, 0.2));\n    d = op_smin(d, sphere(vec3(0.5 * cos(iTime * 0.15), sin(iTime * 0.13), 0.0) - ro, 0.2), 0.1);\n    d = op_smin(d, sphere(vec3(0.2 * sin(iTime * 0.2 + 3.14), sin(iTime * 0.27), 0.0) - ro, 0.2), 1.5);\n    d = op_smin(d, sphere(vec3(0.0, -1.5, 0.5) - ro, 0.75), 1.5);\n    return d;\n}\n\nfloat lamp_map(in vec3 ro) {\n    float d = sd_cone(vec3(0.0, 0.0, 0.0) - ROT_X_90 * ro, normalize(vec2(2.0, 1.0)));\n    d = op_intersect(d, sd_box(vec3(0.0, -1.0, 0.0) - ro, vec3(3.0, 0.5, 3.0)));\n    return d;\n}\n\nfloat lamp_base_map(in vec3 ro) {\n    float d = sphere(vec3(0.0, 0.0, 0.0) - ro, 1.9);\n    d = op_subtract(d, sphere(vec3(0.0, 0.0, 0.0) - ro, 1.85));\n    d = op_union(d, sphere(vec3(0.0, -2.0, 0.0) - ro, 1.0));\n    d = op_intersect(d, sd_box(vec3(0.0, -1.1, 0.0) - ro, vec3(3.0, 0.9, 3.0)));\n    return d;\n}\n\nfloat floor_map(in vec3 ro) {\n    return plane(ro.y);\n}\n\nfloat map(in vec3 ro) {\n    return op_union(op_union(op_union(lava_map(ro), \n                                      lamp_map(ro - vec3(0.0, 3.0, 0.0))),\n                             lamp_base_map(ro + vec3(0.0, 0.5, 0.0))),\n                    floor_map(ro + vec3(0.0, 2.5, 0.0)));\n}\n\nfloat glass_map(in vec3 ro) {\n    vec3 orig_ro = ro;\n    ro = orig_ro - vec3(0.0, 3.0, 0.0);\n    float top = sd_cone(vec3(0.0, 0.0, 0.0) - ROT_X_90 * ro, normalize(vec2(2.0, 1.0)));\n    top = op_intersect(top, sd_box(vec3(0.0, -2.6, 0.0) - ro, vec3(3.0, 1.1, 3.0)));\n    ro = orig_ro + vec3(0.0, 4.0, 0.0);\n    \n    return top;\n}\n\nvec3 map_normal(in vec3 ro) {\n    vec2 v = vec2(EPSILON, 0.0);\n    return normalize(vec3(map(ro + v.xyy) - map(ro - v.xyy),\n                          map(ro + v.yxy) - map(ro - v.yxy),\n                          map(ro + v.yyx) - map(ro - v.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n    float td = 0.0;\n    float dist = EPSILON;\n    for (int i = 0; i < 100; i++) {\n        if (abs(dist) < EPSILON || td >= MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = map(ro);\n        td += dist;\n        ro += rd * dist;\n    }\n    \n    if (abs(dist) < EPSILON) {\n        return td;\n    } else {\n        return INFTY;\n    }\n}\n\nfloat march_glass(in vec3 ro, in vec3 rd) {\n    float td = 0.0;\n    float dist = EPSILON;\n    for (int i = 0; i < 100; i++) {\n        if (abs(dist) < EPSILON || td >= MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = glass_map(ro);\n        td += dist;\n        ro += rd * dist;\n    }\n    \n    if (abs(dist) < EPSILON) {\n        return td;\n    }\n    \n    return INFTY;\n}\n\n#define LIGHT_COUNT 1.0\nvec3 light_at(in float idx) {\n    if (idx < 4.0) {\n        return vec3(50.0 * sin(iTime + idx * PI / 2.0), 20.0, 50.0 * cos(iTime + idx * PI / 2.0));\n    }\n    return vec3(0.0);\n}\n\nvec3 color_at(in vec3 ro) {\n    return vec3(1.0);\n}\n\nfloat occlusion(in vec3 p, in vec3 n, in float k) {\n    float s = 0.0;\n    float delta = 0.5;\n    for (float i = 1.0; i <= 5.0; i++) {\n        float c = (1.0 / pow(2.0, i)) *\n                  (i * delta -\n                   map(p + n * i * delta));\n        s += c;//clamp(c, 0.0, 1.0);\n    }\n    \n    return 1.0 - k * s;\n}\n\nfloat lighting(in vec3 ro, in vec3 rd) {\n    vec3 normal = map_normal(ro);\n    vec3 eye = -rd;\n    \n    float specular = 0.0;\n    float diffuse = 0.0;\n    \n    for (float i = 0.0; i < LIGHT_COUNT; i++) {\n        vec3 light_pos = light_at(i);\n        vec3 light_dir = normalize(ro - light_pos);\n        \n        float shadow_dist = march(light_pos, light_dir);\n        vec3 shadow_ro = light_pos + light_dir * shadow_dist;\n        \n        if (length(shadow_ro - ro) < 0.1) {\n        \tvec3 ref = reflect(light_dir, normal);\n\t\t\tdiffuse = min(1.0, diffuse + dot(ref, eye));\n        \tspecular = min(1.0, pow(diffuse, 12.0));\n        }\n    }\n    \n    return min(1.0, (diffuse + specular) * occlusion(ro, normal, 0.9));\n}\n\nvoid setup_camera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float mouse_theta = iMouse.x * MOUSE_SPEED;\n    float theta = iTime * AUTO_SPIN_SPEED + mouse_theta;\n    float mouse_rho = iMouse.y * MOUSE_SPEED + PI;\n    \n    ro = vec3(CAMERA_DIST * sin(theta), 1.5 * cos(mouse_rho) + 1.5, CAMERA_DIST * cos(theta));\n    vec3 target = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 camera_dir = normalize(target - ro);\n    vec3 camera_right = normalize(cross(up, ro));\n    vec3 camera_up = cross(camera_right, camera_dir);\n    \n    rd = normalize(uv.x * camera_right + uv.y * camera_up + camera_dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy)  - vec2(0.5)) * vec2(2.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro, rd;\n    setup_camera(uv, ro, rd);\n    float dist = march(ro, rd);\n    float glass_dist = march_glass(ro, rd);\n    \n    vec3 base_color = vec3(0.0);\n    if (glass_dist < dist) {\n        base_color += vec3(0.0, 0.2, 0.2);\n    }\n    \n    if (dist < INFTY) {\n        ro += rd * dist;\n        base_color += color_at(ro) * lighting(ro, rd);\n    }\n    \n    fragColor = vec4(base_color, 1.0);\n}","name":"Image","description":"","type":"image"}]}