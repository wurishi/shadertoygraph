{"ver":"0.1","info":{"id":"mst3z4","date":"1677243035","viewed":132,"name":"Raytracer 1 .","username":"Fir3c0w","description":"My first attempt at creating a raytracer.\nI didn't watch any tutorial and did all the maths by myself, so there might be errors..\nI also don't completely understand GLSL yet so I might not be using the right functions.","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["3d","raytracing","reflection","raytracer","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float saturation = 1.6;\n//const float bloom = .9;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Post processing layer\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 rendered = texture(iChannel0, uv).xyz;\n    rendered *= saturation;\n    \n    fragColor = vec4(rendered,0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Sphere\n{\n    float radius;\n};\n\nstruct Light\n{\n    vec3 position;\n    float intensity;\n    vec3 color;\n};\n\nstruct Plane\n{\n    vec3 normal;\n};\n\nstruct Object\n{\n    vec3 position;\n    vec3 color;\n    float roughness; // 0 -> 1\n    \n    Plane plane;\n    Sphere sphere;\n    bool isPlane;\n};\n\nstruct Collision\n{\n//Struct returned by the intersection function\n    bool collides;\n    vec3 position;\n    float dist;\n};\n\n\nstruct RayCollision\n{\n//Struct returned by the cast_ray function\n    bool collides;\n    vec3 color;\n    vec3 position;\n    vec3 normal;\n    float roughness;\n};\n\nconst Plane nullPlane = Plane(vec3(1.0,1.0,1.0));\nconst Sphere nullSphere = Sphere(0.0);\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//USER INPUT\n\n//Keyboard input\nconst float KEY_W = .341;\nconst float KEY_A = .255;\nconst float KEY_S = .325;\nconst float KEY_D = .267;\nconst float KEY_SPACE = .126;\nconst float KEY_SHIFT = .064;\n\nbool keyDown(in float key)\n{\n    return texture(iChannel0, vec2(key, 0.2)).x == 1.0;\n}\n\nconst float speed = .1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixelData = vec3(0.);\n    vec2 mouseUV =  iMouse.xy / iResolution.xy;\n\n    switch (int(fragCoord.x))\n    {\n        case 0: //X\n            pixelData = vec3(\n            texelFetch(iChannel1, ivec2(0, 0), 0).x \n            + float(keyDown(KEY_W)) * iTimeDelta * speed\n            - float(keyDown(KEY_S)) * iTimeDelta * speed, \n            0.,0.);\n            break;\n            \n        case 1: //Y\n            pixelData = vec3(\n            texelFetch(iChannel1, ivec2(1, 0), 0).x \n            + float(keyDown(KEY_D)) * iTimeDelta * speed\n            - float(keyDown(KEY_A)) * iTimeDelta * speed,\n            0.,0.);\n            break;\n            \n        case 2: //Z\n            pixelData = vec3(\n            texelFetch(iChannel1, ivec2(2, 0), 0).x \n            + float(keyDown(KEY_SPACE)) * iTimeDelta * speed\n            - float(keyDown(KEY_SHIFT)) * iTimeDelta * speed,\n            0.,0.);\n            break;\n        case 3: //Mouse\n            pixelData = vec3(mouseUV.xy, 0.);\n            break;\n    }\n    \n    fragColor = vec4(pixelData,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//MAIN PROGRAM\n\n#define PI 3.1415\n\n//Scene setup\nconst vec3 bg_color = vec3(107.0 / 255.0, 208.0 / 255.0, 255.0 / 255.0);\nconst float sky_light_level = 1.0;\nconst float distanceToScreen = 7.0;\nconst float screen_size = 2.0;\n\nObject objects[] = Object[]\n(\n    Object(vec3(0.0,-0.3,6.0), vec3(1.0,1.0,1.0), 0., nullPlane, Sphere(.5), false),\n    Object(vec3(0.0,-0.4,6.0), vec3(1.0,0.0,0.0), 0.3, nullPlane, Sphere(.3), false),\n    Object(vec3(0.0,-0.4,6.0), vec3(1.0,0.0,0.0), 0.2, nullPlane, Sphere(.3), false),\n    Object(vec3(0.0,-1.0,0), vec3(1.0,1.0,1.0), 0.7, Plane(normalize(vec3(0.0, 1.0, 0.0))), nullSphere, true)\n);\n\nLight lights[] = Light[]\n(\n    Light(vec3(0, 5, -5), 5.0, vec3(1.0,1.0,1.0))\n    //Light(vec3(0, 5, 8), 5.0, vec3(1.0,.1,.1))\n);\n\nvoid update()\n{\n    objects[0].position.y += cos(iTime) / 10.0;\n    objects[1].position.x += cos(iTime) * 2.0;\n    objects[1].position.z += sin(iTime) * 2.0;\n    \n    objects[2].position.x += cos(iTime + 3.14) * (2.0 + sin(iTime));\n    objects[2].position.z += sin(iTime + 3.14) * 3.0;\n}\n\nconst int reflection_depth = 10;\n\n//Ray calculations\n\nCollision objectRay(vec3 ray_origin, vec3 ray_direction, Object obj)\n{\n    // ray = ray_origin + t * ray_direction\n\n    if (obj.isPlane)\n    {\n        if (dot(obj.plane.normal, ray_direction) >= 0.) //If right side of plane (Backface culling)\n        {\n            return Collision(false, vec3(0.0,0.0,0.0), 0.0);\n        }\n        float t = dot(obj.plane.normal, obj.position - ray_origin) / dot(ray_direction, obj.plane.normal);\n        \n        if (t > 0.0)\n        {\n            vec3 p = ray_origin + t * ray_direction;\n            return Collision(true, p, t);\n        }\n        \n        return Collision(false, vec3(0.0,0.0,0.0), 0.0);\n    }\n    \n    else\n    {\n        float t = dot(ray_direction, obj.position - ray_origin);\n\n        vec3 p = ray_origin + t * ray_direction;\n        if (length(p - obj.position) <= obj.sphere.radius && t > 0.0) //Collides with the sphere\n        {\n            float y = length(p - obj.position);\n            float x = sqrt(obj.sphere.radius * obj.sphere.radius - y * y);\n\n            float t1 = t - x;\n            float t2 = t + x;\n\n            vec3 intersection_position = ray_origin + t1 * ray_direction;\n\n            return Collision(true, intersection_position, t1);\n        }\n\n        return Collision(false, vec3(0.0,0.0,0.0), 0.0);\n    }\n\n}\n\nvec3 cameraPosition()\n{\n    return vec3(\n    texelFetch(iChannel0, ivec2(0,0), 0).r,\n    texelFetch(iChannel0, ivec2(1,0), 0).r,\n    texelFetch(iChannel0, ivec2(2,0), 0).r\n    );\n}\nvec2 cameraRotation()\n{\n    return vec2(\n    (texelFetch(iChannel0, ivec2(3,0), 0).r -.5) * 2. * PI,\n    (texelFetch(iChannel0, ivec2(3,0), 0).g  -.5) * 2. * PI\n    );\n}\n\nRayCollision cast_ray(vec3 ro, vec3 rd)\n{\n    //Casts a ray from ro (ray_origin) toward rd (ray_direction), finds intersection and computes\n    //the light level at the intersection point\n    //Complexity: O(n^3) (Very bad)\n    \n    rd = normalize(rd);\n    vec3 col = 1.0 * texture(iChannel1, rd).xyz;\n    float collision_distance = 10000.0;\n    \n    vec3 normal;\n    vec3 position;\n    bool collides = false;\n    float roughness = 1.;\n    \n    for (int i = 0; i < objects.length(); i++)\n    {\n        Collision ray_S = objectRay(ro, rd, objects[i]);\n        \n        if (ray_S.collides && ray_S.dist < collision_distance)\n        {\n            collision_distance = ray_S.dist;\n            col = vec3(0.0,0.0,0.0);   \n        }\n        else {continue;}\n        \n        position = ray_S.position;\n        collides = true;\n        roughness = objects[i].roughness;\n        \n        if (objects[i].isPlane)\n        {\n            normal = objects[i].plane.normal;\n        }\n        else\n        {\n            normal = normalize(ray_S.position - objects[i].position);\n        }\n        \n        for (int j = 0; j < lights.length(); j++)\n        {\n            vec3 light_ray_direction = normalize(lights[j].position - ray_S.position);\n\n            float cos_light_angle = dot(normal, light_ray_direction) / (length(normal) * length(light_ray_direction));\n            \n            bool light_blocked = false;\n            for (int s = 0; s < objects.length(); s++)\n            {\n                Collision ray_light = objectRay(ray_S.position, light_ray_direction, objects[s]);\n                if (ray_light.collides)\n                {\n                    light_blocked = true;\n                }\n            }\n            \n            if (!light_blocked)\n            {\n                col += cos_light_angle * lights[j].color * objects[i].color * lights[j].intensity / length(ray_S.position - lights[j].position);\n            }\n        }\n\n        col = col / float(lights.length()); //Averages the light level\n    }\n    \n    return RayCollision(collides, col, position, normal, roughness);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x / iResolution.y; //Aspect ratio\n    \n    //Pixel coordinates from -1 to 1 on the Y axis and from -ratio to ratio on the X axis\n    vec2 rc = uv * screen_size - screen_size / 2.;\n    rc.x *= ar;\n    \n    \n    //RAY COORDINATES\n    vec3 ro = vec3(rc + cameraPosition().yz * 100.0, cameraPosition().x * 100.0); //Ray origin\n    vec3 rd = vec3(rc / distanceToScreen, 1.0);\n    \n    /*\n    vec2 camRot = cameraRotation();\n    \n    float angle_x = atan(rc.x / distanceToScreen) + camRot.x;\n    float angle_y = atan(rc.y / distanceToScreen) + camRot.y;\n    \n    vec3 rd = normalize(vec3(\n        cos(angle_y) * cos(angle_x),\n        sin(angle_y),\n        cos(angle_y) * sin(angle_x)\n    ));\n    \n    vec3 ro = \n        cameraPosition().yzx * 100.0 + rd * length(vec3(rc.xy, distanceToScreen));\n    */\n    //UPDATING SCENE\n    update();\n    \n    //RENDERING\n\n    RayCollision ray;\n    int iterations;\n    \n    vec3 col = vec3(0.);\n    float totalRoughness = 1.0;\n    \n    for (iterations = 1; iterations <= reflection_depth; iterations++)\n    {\n        RayCollision ray = cast_ray(ro, rd);\n        \n        col += vec3(totalRoughness * ray.roughness) * ray.color;\n        totalRoughness -= ray.roughness;\n        \n        if (!ray.collides || totalRoughness <= 0.) {break;}\n        \n        rd = normalize(rd - 2.0 * ray.normal * dot(rd, ray.normal)); //Reflected ray direction\n        ro = ray.position; //Reflected ray origin\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}