{"ver":"0.1","info":{"id":"McySDh","date":"1715099533","viewed":71,"name":"Raymarching simple test","username":"neeh","description":"Experimenting with raymarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.001\n#define MAX_DIST 50.0\n#define MAX_ITER 128\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 smin(vec2 d1, vec2 d2, float h) {\n  float k = clamp((d1.x - d2.x) / h * 0.5 + 0.5, 0.0, 1.0);\n  return mix(d1, d2, k) - k * (1.0 - k) * h;\n}\n\nvec2 map(in vec3 pos) {\n  vec2 res = vec2(MAX_DIST, -1.0);\n  res = opU(res, vec2(sdSphere(pos - vec3(sin(iTime) * 1.5, 0.0, 0.0), 1.0), 1.0));\n  res = smin(res, vec2(sdBox(pos - vec3(sin(iTime) * -1.5, 0.0, 0.0), vec3(0.85)), 1.0), 0.75);\n  return res;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n  vec2 res = vec2(-1.0);\n  float t = 0.0;\n  for (int i = 0; i < MAX_ITER && t < MAX_DIST; i++) {\n    vec2 h = map(ro + rd * t);\n    if (h.x < EPS) {\n      res = vec2(t, h.y);\n      break;\n    }\n    t += h.x;\n  }\n  return res;\n}\n\nvec3 calcNormal(in vec3 pos) {\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n  return normalize(\n    e.xyy*map(pos + e.xyy).x +\n    e.yyx*map(pos + e.yyx).x +\n    e.yxy*map(pos + e.yxy).x +\n    e.xxx*map(pos + e.xxx).x\n  );\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  // background\n  // vec3 col = vec3(0.25) * (1.0 - length(rd.xy) * 0.15);\n  vec3 col = vec3(0.25) - max(rd.y + 0.25, 0.0) * 0.3;\n  \n  vec2 res = trace(ro, rd);\n  float t = res.x;\n  float m = res.y;\n  if (m > -0.5) {\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n    \n    vec3 lin = vec3(0.0);\n    float ks = 1.0;\n    \n    if (res.y > 0.5) col = vec3(1.0, 0.0, 0.0);\n    \n    // sun\n    {\n      vec3 lig = normalize(vec3(-0.5, 0.4, -0.6));\n      vec3 hal = normalize(lig - rd);\n      float dif = clamp(dot(nor, lig), 0.0, 1.0);\n      float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0);\n      spe *= dif;\n      spe *= 0.04 + 0.96 * pow(clamp(1.0 - dot(hal, lig), 0.0, 1.0), 5.0);\n      lin += col * 2.2 * dif * vec3(1.3, 1.0, 0.7);\n      lin += 5.0 * spe * vec3(1.3, 1.0, 0.7) * ks;\n    }\n    // sky\n    {\n      float dif = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));\n      float spe = smoothstep(-0.2, 0.2, ref.y);\n      spe *= dif;\n      spe *= 0.04 + 0.96 * pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 5.0);\n      lin += col * 0.6 * dif * vec3(0.4, 0.6, 1.15);\n      lin += 2.0 * spe * vec3(0.2, 0.3, 0.6) * ks;\n    }\n    // back\n    {\n      float dif = clamp(dot(nor, normalize(vec3(0.5, 0.0, 0.6))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n      lin += col * 0.55 * dif * vec3(0.25);\n    }\n    \n    col = lin;\n  }\n  return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n  vec3 cw = normalize(ta - ro);\n  vec3 cu = normalize(vec3(-cw.z, 0.0, cw.x));\n  vec3 cv = cross(cu, cw);\n  return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  // iResolution = vec2(800.0, 450.0, 1.778);\n  vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  \n  vec2 mo = iMouse.xy / iResolution.xy;\n  float spd = 0.0;\n  float theta = 7.0 * mo.x + spd * iTime * 0.33;\n  \n  vec3 ro = vec3(7.5 * sin(theta), 2.0, 7.5 * cos(theta)); // camera position\n  vec3 ta = vec3(0.0);\n  mat3 ca = setCamera(ro, ta);\n  const float fl = 2.5; // focal length\n  vec3 rd = ca * normalize(vec3(p, fl));\n  \n  vec3 col = render(ro, rd);\n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}