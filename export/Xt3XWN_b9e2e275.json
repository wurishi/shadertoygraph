{"ver":"0.1","info":{"id":"Xt3XWN","date":"1479648858","viewed":160,"name":"Mandelbrot test 1","username":"n1kk","description":"tetsting fractal drawing with shaders","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// better one https://www.shadertoy.com/view/lsX3W4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // screen rect convertion to local coordinate system \n    vec2 start = vec2(-4.5, -2.5);\n    vec2 size = vec2(5.0, 5.0);\n    // zooming data\n    //vec2 zoom_point = vec2(0.59089, 0.599975);\n    vec2 zoom_point = vec2(0.59089+.2, 0.599975);\n    float zoom = 1.0;\n    bool show_zoom_point = true;\n    float anim_speed = 0.2;\n    float zoom_factor = 15.0;\n    float pizelSize = size.x / iResolution.x;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // iMouse.zw present mouse has been pressed, use pointer data for zoom\n    // otherwize use Time to animate zooming in and out\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) {\n        zoom_point = iMouse.zw / iResolution.xy;\n        zoom_point.x *= iResolution.x / iResolution.y;\n        zoom = pow(2.0, distance(iMouse.xy, iMouse.zw)) / 1.0;\n    } else {\n        zoom = 0.5 - 0.5 * cos(anim_speed * iTime);\n    \tzoom = pow(2.0, zoom_factor * zoom);\n    }\n    \n    if (zoom != 0.0) {\n        //float multitude_zoom = pow(2.0, zoom_factor * zoom);\n        vec2 scaled_size = size / zoom;\n        vec2 scale_shift = (size - scaled_size) * zoom_point;\n\n        size = scaled_size;\n        start += scale_shift;\n    }\n    \n    vec2 p = uv * size + start;\n    vec2 c = p;\n    \n    // draw grid x\n    if ( mod(abs(p.x), floor(abs(p.x))) < pizelSize ) {\n        col.r += 0.1;\n    }\n    // draw grid y\n    if ( mod(abs(p.y), floor(abs(p.y))) < pizelSize ) {\n        col.g += 0.1;\n    }\n     \n    // mandelbrot\n    float res = 0.0;\n    const int nn = 300;\n    //for (int n = 0; n <= nn; n++) {\n    for (float n = 0.0; n < 1.0; n += 0.005) {\n        float aa = p.x * p.x - p.y * p.y;\n        float bb = 2.0 * p.x * p.y;\n        p.x = aa + c.x;\n        p.y = bb + c.y;\n        //res = (1.0 + float(n)) / float(nn);\n      \tres = n; \n        if ((p.x + p.y) > 10000.0) {\n           break;\n        }\n    }\n    // animate coloring\n    /*\n\tcol.r += res * (0.6+0.4*cos(3.0*iTime));\n    col.g += res * (0.6+0.4*(cos(iTime) + sin(2.0*iTime)));\n    col.b += res * (0.6+0.4*sin(iTime));\n    */\n    col += vec3(float(res));\n    \n    // show zooming point\n    if (show_zoom_point && distance(uv, zoom_point) < 1.0 * pizelSize) {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}