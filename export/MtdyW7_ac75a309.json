{"ver":"0.1","info":{"id":"MtdyW7","date":"1532933943","viewed":160,"name":"Assignment5_task2_G3","username":"wln928672785","description":"Assignment5_task2_G3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 8;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 20;\n\nconst float eradius=0.15;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.5, 0.1, 0.8 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\nconst float PI = 3.1415926;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical right plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 7.5;\n    Plane[1].materialID = 4;\n    \n    // Vertical left plane.\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 7.5;\n    Plane[2].materialID = 5;\n    \n    // Vertical right plane.\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = -1.0;\n    Plane[3].D = 7.5;\n    Plane[3].materialID = 6;\n    \n    // Vertical left plane.\n    Plane[4].A = -1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 7.5;\n    Plane[4].materialID = 7;\n\n    // Biggest sphere.\n    Sphere[0].center = vec3( 1.5*sin(iTime),  0.4,  1.5*cos(iTime) );\n    Sphere[0].radius = 0.0;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3(  1.5*sin(iTime)+0.7*cos(iTime), 0.5*abs( sin(2.0 * iTime)) + 0.2, 0.7*sin(iTime)+  1.5*cos(iTime) );\n    Sphere[1].radius = 0.0;\n    Sphere[1].materialID = 2;\n    \n    // Center sphere.\n    Sphere[2].center = vec3( 0, 1.33*abs( sin(2.0*iTime+ PI/2.0))+0.3, 0 );\n    Sphere[2].radius = sin(2.0*iTime+ PI/2.0)> 0.78 ? 0.15+0.35*sin(2.0*iTime+ PI/2.0): 0.35;\n    Sphere[2].materialID = 3;\n    \n    // Circling sphere.\n    Sphere[3].center = vec3(  0,  1.5,  0 );\n    Sphere[3].radius = 0.0;\n    Sphere[3].materialID = 2;\n    \n    // First sphere.\n    Sphere[4].center = vec3(2.0-2.0*sin(2.0*iTime+ PI/2.0), 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  0 );\n    Sphere[4].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[4].materialID = 0;\n    \n    // Second sphere.\n    Sphere[5].center = vec3( (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0),  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[5].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[5].materialID = 0;\n    \n    // Third sphere.\n    Sphere[6].center = vec3(  0,  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  -(2.0-2.0*sin(2.0*iTime+ PI/2.0)) );\n    Sphere[6].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[6].materialID = 0;\n    \n    // Fourth sphere.\n    Sphere[7].center = vec3(  -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0),  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[7].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[7].materialID = 0;\n    \n    // Fifth sphere.\n    Sphere[8].center = vec3(  -(2.0-2.0*sin(2.0*iTime+ PI/2.0)),  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19, 0.0 );\n    Sphere[8].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[8].materialID = 0;\n    \n    // Sixth sphere.\n    Sphere[9].center = vec3( -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0), 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[9].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[9].materialID = 0;\n    \n    // Seventh sphere.\n    Sphere[10].center = vec3(  0, 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.0-2.0*sin(2.0*iTime+ PI/2.0) );\n    Sphere[10].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[10].materialID = 0;\n    \n    // Eigth sphere.\n    Sphere[11].center = vec3(  (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0), 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19, (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[11].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[11].materialID = 0;\n    \n    // First sphere.\n    \n      // First sphere.\n    \n   // First sphere.\n    \n    if(sin(iTime)>0.0)\n    Sphere[12].center = vec3( 1.2*sin(2.0*4.0/3.0*iTime)*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  1.2*cos(2.0*4.0/3.0*iTime)*sin(iTime));\n    else\n        Sphere[12].center = Sphere[2].center;\n    vec3 distan1=Sphere[2].center-Sphere[12].center;\n\n    Sphere[12].radius = eradius;\n    Sphere[12].materialID = 0;\n\n    // Second sphere.\n    \n    if(sin(iTime)>0.0)\n    Sphere[13].center = vec3( 1.6*sin(2.0*4.0/3.0*(iTime-PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  1.6*cos(2.0*4.0/3.0*(iTime-PI/32.0))*sin(iTime));\n    else\n        Sphere[13].center = Sphere[2].center;\n    Sphere[13].radius = eradius;\n    Sphere[13].materialID = 0;\n\n    // Third sphere.\n    if(sin(iTime)>0.0)\n    Sphere[14].center = vec3( 2.0*sin(2.0*4.0/3.0*(iTime-2.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.0*cos(2.0*4.0/3.0*(iTime-2.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[14].center = Sphere[2].center;\n    Sphere[14].radius = eradius;\n    Sphere[14].materialID = 0;\n\n    // Fourth sphere.\n    if(sin(iTime)>0.0)\n     Sphere[15].center = vec3( 2.4*sin(2.0*4.0/3.0*(iTime-3.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.4*cos(2.0*4.0/3.0*(iTime-3.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[15].center = Sphere[2].center;\n    Sphere[15].radius = eradius;\n    Sphere[15].materialID = 0;\n    \n    \n    // Fifth sphere.\n    if(sin(iTime)>0.0)\n    Sphere[16].center = vec3( 2.8*sin(2.0*4.0/3.0*(iTime-4.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.8*cos(2.0*4.0/3.0*(iTime-4.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[16].center = Sphere[2].center;\n    Sphere[16].radius = eradius;\n    Sphere[16].materialID = 0;\n\n    // Third sphere.\n    if(sin(iTime)>0.0)\n    Sphere[17].center = vec3( 3.2*sin(2.0*4.0/3.0*(iTime-5.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  3.2*cos(2.0*4.0/3.0*(iTime-5.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[17].center = Sphere[2].center;\n    Sphere[17].radius = eradius;\n    Sphere[17].materialID = 0;\n\n    // Fourth sphere.\n    if(sin(iTime)>0.0)\n     Sphere[18].center = vec3( 3.6*sin(2.0*4.0/3.0*(iTime-6.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  3.6*cos(2.0*4.0/3.0*(iTime-6.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[18].center = Sphere[2].center;\n    Sphere[18].radius = eradius;\n    Sphere[18].materialID = 0;\n\n    // Eigth sphere.\n    if(sin(iTime)>0.0)\n     Sphere[19].center = vec3( 4.0*sin(2.0*4.0/3.0*(iTime-7.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  4.0*cos(2.0*4.0/3.0*(iTime-7.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[19].center = Sphere[2].center;\n    Sphere[19].radius = eradius;\n    Sphere[19].materialID = 0;\n    // Silver material.\n    Material[0].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.4, 0.6, 0.9 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.8, 0.4, 0.3 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 2.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    // Another plastic material.\n    Material[3].k_d = vec3( 0.8, sin(iTime), cos(iTime) );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n    \n    // Another plastic material.\n    Material[4].k_d = vec3( 0.6, sin(iTime), 0.7+0.3*cos(iTime) );\n    Material[4].k_a = 0.2 * Material[3].k_d;\n    Material[4].k_r = 2.0 * Material[2].k_d;\n    Material[4].k_rg = 0.5 * Material[2].k_r;\n    Material[4].n = 128.0;\n    \n    // Another plastic material.\n    Material[5].k_d = vec3( sin(iTime),0.8,  0.8+0.2*cos(iTime) );\n    Material[5].k_a = 0.2 * Material[3].k_d;\n    Material[5].k_r = 2.0 * Material[2].k_d;\n    Material[5].k_rg = 0.5 * Material[2].k_r;\n    Material[5].n = 128.0;\n    \n    // Another plastic material.\n    Material[6].k_d = vec3(  sin(iTime),0.3+0.7* cos(iTime),0.7 );\n    Material[6].k_a = 0.2 * Material[3].k_d;\n    Material[6].k_r = 2.0 * Material[2].k_d;\n    Material[6].k_rg = 0.5 * Material[2].k_r;\n    Material[6].n = 128.0;\n    \n    // Another plastic material.\n    Material[7].k_d = vec3( 0.8,0.4+ 0.6*sin(iTime), 0.5+0.5*cos(iTime) );\n    Material[7].k_a = 0.2 * Material[3].k_d;\n    Material[7].k_r = 2.0 * Material[2].k_d;\n    Material[7].k_rg = 0.5 * Material[2].k_r;\n    Material[7].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 0.0, 15.0, 0.0 );\n    Light[0].I_a = vec3( sin(iTime)*0.1, sin(iTime)*0.1,sin(iTime)*0.1 );\n    Light[0].I_source = vec3( 0.7, 0.7, 0.7 );\n\n    // Light 1.\n    Light[1].position = vec3( 4.0*sin(iTime), -15.0, 4.0*cos(iTime) );\n    Light[1].I_a = vec3( 0.4, 0.4, 0.4 );\n    Light[1].I_source = vec3( 0.5, 0.5, 0.5 );\n    \n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    ray.o=ray.o-sph.center;\n    float t0,t1,t2;\n    float dRd = dot( ray.d, ray.d );\n    float oRo = dot(ray.o, ray.o);\n    float dRo = dot( ray.d, ray.o );\n    if((dRo*dRo-dRd*(oRo-sph.radius*sph.radius))<0.0)\n        return false;  // Replace this with your code.\n    else\n    {\n        t1=(-dRo+sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n        t2=(-dRo-sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n    }\n    if(t1 <= 0.0&&t2 <= 0.0)\n        return false;\n    else if(t1*t2 <= 0.0 )\n        t0=max(t1,t2);\n    else t0=min(t1,t2);\n\n    if ( t0 <=tmin || t0 >=tmax ) return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d+sph.center;\n\n    hitNormal = normalize((ray.o + t0 * ray.d)/sqrt(oRo+dRd));\n    return true;\n\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    ray.o=ray.o-sph.center;\n    float t0,t1,t2;\n    float dRd = dot( ray.d, ray.d );\n    float oRo = dot(ray.o, ray.o);\n    float dRo = dot( ray.d, ray.o );\n    if((dRo*dRo-dRd*(oRo-sph.radius*sph.radius))<0.0)\n    return false;  // Replace this with your code.\n    else\n    {\n        t1=(-dRo+sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n        t2=(-dRo-sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n    }\n    if(t1 <= 0.0&&t2 <= 0.0)\n        return false;\n    else if(t1*t2 <= 0.0 )\n        t0=max(t1,t2);\n    else t0=min(t1,t2);\n\n    if ( t0 <=tmin || t0 >=tmax ) return false;\n    return true;\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    if (IntersectPlane(Plane[0], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Plane[0].materialID;\n        hasHitSomething=true;\n    }\n\n    if(IntersectPlane(Plane[1], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[1].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectPlane(Plane[2], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[2].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectPlane(Plane[3], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[3].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectPlane(Plane[4], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[4].materialID;\n        hasHitSomething=true;\n    }\n\n    if(IntersectSphere(Sphere[0], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[0].materialID;\n        hasHitSomething=true;\n    }\n\n    if(IntersectSphere(Sphere[1], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[1].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[2], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[2].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[3], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[3].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[4], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[4].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[5], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[5].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[6], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[6].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[7], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[7].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[8], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[8].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[9], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[9].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[10], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[10].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[11], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[11].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[12], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[12].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[14], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[14].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[15], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[15].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[16], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[16].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[13], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[13].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[17], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[17].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[18], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[18].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[19], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[19].materialID;\n        hasHitSomething=true;\n    }\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    Ray_t lightray0;\n    lightray0.o = nearest_hitPos;\n    lightray0.d = normalize(Light[0].position - nearest_hitPos);\n    vec3 lengray0 = Light[0].position - nearest_hitPos;\n    float t0max=length(lengray0);\n\n    Ray_t lightray1;\n    lightray1.o = nearest_hitPos;\n    lightray1.d = normalize(Light[1].position - nearest_hitPos);\n    vec3 lengray1 = nearest_hitPos - Light[1].position;\n    float t1max=length(lengray1);\n\n    bool inShadow = false;\n\n    if(IntersectSphere(Sphere[0],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[1],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[2],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[3],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[4],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[5],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[6],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[7],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[8],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[9],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[10],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[11],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[12],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[13],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[14],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[15],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[16],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[17],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[18],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[19],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[0],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[1],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[2],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[3],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[4],lightray0,DEFAULT_TMIN,t0max))\n          inShadow = true;\n     I_local += PhongLighting(lightray0.d,nearest_hitNormal,-ray.d,inShadow, Material[nearest_hitMatID],Light[0] );\n\n\n    inShadow = false;\n    if(IntersectSphere(Sphere[1],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[0],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[2],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[3],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[4],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[5],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[6],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[7],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[8],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[9],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[10],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[11],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[12],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[13],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[14],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[15],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[16],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[17],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[18],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[19],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[0],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[1],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[2],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[3],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[4],lightray1,DEFAULT_TMIN,t1max))\n    inShadow = true;\n\n    I_local += PhongLighting(lightray1.d,nearest_hitNormal,-ray.d,inShadow, Material[nearest_hitMatID],Light[1]);\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n//=======================================================\n\nvec3 background( in vec3 d, in vec3 l )\n{\n    vec3 col = vec3(0.0);\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    \n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 50.0*d.xy );\n    vec2 vyz = voronoi( 50.0*d.yz );\n    vec2 vzx = voronoi( 50.0*d.zx );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n    col = 1.5*col - 0.2;\n    col += vec3(-0.05,0.1,0.0);\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\n//--------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    //vec3 cam_pos = vec3( 1.5+1.5*abs(sin(iTime/5.0)), 5.0, 1.5+abs(1.5*cos(iTime/5.0)) );\n    vec3 cam_pos = vec3( 4.5*sin(-1.0*iTime), 2.0, 4.5*cos(-1.0*iTime) );\n    vec3 cam_lookat = vec3( 0.0, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\t\n    vec3 col = texture(iChannel0, fragCoord).rgb;// 获取纹理在uv出的像素颜色\n    Material[0].k_d = col;\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n    \n    vec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\n\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n    vec3 col0 = background( rd, lig );\n    Material[7].k_d = col0;\n    Material[6].k_d = col0;\n    Material[5].k_d = col0;\n    Material[4].k_d = col0;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 0.5 );\n}\n","name":"Image","description":"","type":"image"}]}