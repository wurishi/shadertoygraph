{"ver":"0.1","info":{"id":"Nd3SW2","date":"1633976666","viewed":126,"name":"Flowers Field","username":"rudros","description":"Very small but (hopefully) readable ray-caster. 3D Noise taken from one of @iq's shaders","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","mini"],"hasliked":0,"parentid":"NdcXDj","parentname":"Flowers1"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PI 3.1415326\n\n\n#define HIGH_QUALITY_NOISE\n\n// 3D noise\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0, 17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv+ 0.5)/256.0, 0.0).yx;\n#else\n\tvec2 uv  = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod(iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0.0).yx;\n\tvec2 rg2 = textureLod(iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0.0).yx;\n\tvec2 rg3 = textureLod(iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0.0).yx;\n\tvec2 rg4 = textureLod(iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0.0).yx;\n\tvec2 rg  = mix(mix(rg1, rg2, f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\n// Distance of point p to spherical noise surface\nfloat distanceTo(vec3 p) {\n    p = mod(p+.5+round(p.z),2.)-1.; // Repeat the noise spheres\n    return (length(p)-abs(noise(normalize(p)*vec3(12.)))); // Use 12 unit cube for noise\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    float eyeDist = iTime; // Clipping plane keeps moving\n    float i;\n    \n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    for(float minDist=1.; i<100. && minDist>0.1; i++) {\n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n        \n        // Camera motion\n        //p.xy += iTime/10.;\n        p.xy *= rotate2D(sin(iTime+eyeDist*.4)); // Depth affects motion\n        \n        minDist = distanceTo(p);\n        eyeDist += minDist*0.1;\n    }\n    // Hue is based on distance, brightness based on distance \n    fragColor.rgb = hsv(.4-.1*eyeDist, 1., 1.-i/100.);\n//    fragColor.rgb += 1000./(i*i);\n}\n","name":"Image","description":"","type":"image"}]}