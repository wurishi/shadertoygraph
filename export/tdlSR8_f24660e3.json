{"ver":"0.1","info":{"id":"tdlSR8","date":"1551126550","viewed":2088,"name":"Moon voxels","username":"nimitz","description":"rendering a diorama-like voxels scene, you can change the voxel size at the top of the code.\n\nFullscreen recommended to see the individual voxels better","likes":85,"published":1,"flags":32,"usePreview":1,"tags":["voxel","moon","hybrid","diorama","explorers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Moon voxels\n// by nimitz 2019 (twitter: @stormoid)\n// https://www.shadertoy.com/view/tdlSR8\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tShowing off a hybrid sphere-tracing(raymarching)/\n\tvoxel intersection hybrid algorithm with this little diorama.\n\t\n\tA few other technically interesting things about this shader:\n\t\n        -A new method for rendering 3D terrain, using summed triangle\n        wave octaves with rotation and displacement, will post more on this\n        technique soon.\n\t\n        -2D triangle folding for the modelling of the rocket to speed up\n        evaluation, this type of space folding (be it 2D or 3D) can be used \n        with any geometry that has any type of symmetry to accelerate evals.\n\n\t\t-A very simple form of AA, displacing the screen each frame by\n\t\ta fraction of a pixel to get only the pixels on the edge of the coverage\n\t\tlimit and blending over a few frames to smooth the result.\n\n\tAs for the rendering of this scene:\n\n\tMaterials are defined per-voxel and the colors are quantitized to 16 \n\tcolors per channel to replicate the \"pixel art\" look but the lighting \n\tcalculations are done in full color. Also using voxel AO based on fb39ca4's\n\ttechnique, which is barely visible in non-fullscreen mode.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    \n    col = 1.12*pow( col, vec3(0.96,0.95,1.0) ) + vec3(-0.04,-0.04, -0.01); //Correction\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Moon voxels\n// by nimitz 2019 (twitter: @stormoid)\n// https://www.shadertoy.com/view/tdlSR8\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Utility hash and noise functions here\n\nvec2 hash2(uint x)\n{\n    uvec2 p = x * uvec2(3266489917U, 668265263U);\n    p = (p.x ^ p.y) *  uvec2(2654435761U, 2246822519U);\n    return vec2(p)*2.3283064365386962890625e-10;\n}\n\nfloat hash12(vec2 p)\n{\n    p  = 50.*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) )*1.8-0.6;\n}\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(3.0-2.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(0.0,0.0)), hash12(ip + vec2(1.0,0.0)), ramp.x),\n                   mix( hash12(ip + vec2(0.0,1.0)), hash12(ip + vec2(1.0,1.0)), ramp.x), ramp.y);\n    \n    return rz;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Moon voxels\n// by nimitz 2019 (twitter: @stormoid)\n// https://www.shadertoy.com/view/tdlSR8\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n/*\n\tShowing off a hybrid sphere-tracing(raymarching)/\n\tvoxel intersection hybrid algorithm with this little diorama.\n\t\n\tA few other technically interesting things about this shader:\n\t\n        -Using a new method for rendering 3D terrain, using summed triangle\n        wave octaves with rotation and displacement, will post more on this\n        technique soon.\n\t\n        -Using 2D triangle folding for the modelling of the rocket to speed up\n        evaluation, this type of space folding (be it 2D or 3D) can be used \n        with any geometry that has any type of symmetry to accelerate evals.\n\n\t\t-Using a very simple form of AA, displacing the screen each frame by\n\t\ta fraction of a pixel to get only the pixels on the edge of the coverage\n\t\tlimit and blending over a few frames to smooth the result.\n\n\tAs for the rendering of this scene:\n\n\tMaterials are defined per-voxel and the colors are quantitized to 16 \n\tcolors per channel to replicate the \"pixel art\" look but the lighting \n\tcalculations are done in full color. Also using voxel AO based on fb39ca4's\n\ttechnique, which is barely visible in non-fullscreen mode.\n*/\n\n#define ITR 60\n#define FAR 10.\n//#define BOUNDED\n#define ORTHOGRAPHIC\n\n//Voxel size\nconst float scl = 0.014;\nconst float hscl = scl*0.5;\n\n\n//------------------------------------------------------------\n//--------------Base distance functions (from iq)-------------\n//-----------https://www.shadertoy.com/view/Xds3zN------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//------------------------------------------------------------\n//------------------------------------------------------------\n//------------------------------------------------------------\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat slength(in vec3 p){ return max(abs(p.x), max(abs(p.y), abs(p.z))); }\n\n//2d triangle domain folding\nvec2 foldTri(in vec2 p)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(-0.5, -0.8660254);\n  \tp -= 2.0*min(0.0, dot(p, v))*v;\n \treturn p;    \n}\n\nvec2 dUnion(vec2 a, vec2 b)\n{\n\treturn (a.x < b.x)?a:b;\n}\n\nfloat rocket(in vec3 p)\n{\n    p.y -= 0.37;\n    float core = sdCyl(p + vec3(0,-0.3,0), vec2(0.09,1.2));\n    core += mix(sin(p.y*1.1 - .0)*0.3, sin(p.y*4.8 + 6.3)*0.019, step(p.y, 0.));\n    p.xz *= mat2(0.70711, -0.70711, 0.70711, 0.70711);\n    p.xz = foldTri(p.xz);\n    float fins = sdRoundCone(p + vec3(0.,1.1,0.27), 0.05,0.03,0.25) - sin(p.y*20. + 3.)*0.01;\n    p.y += (p.z+0.05)*p.z*4.2;\n    fins = min(fins, sdBox(p + vec3(0.,.72,0.17), vec3(0.003,0.1 - (p.z+0.15)*0.25,0.1))-0.008);\n    return min(core, fins);    \n}\n\nvec2 tank(in vec3 p)\n{\n    p +=  vec3(0.5, -0.22 , .85);\n    p.xz *= mat2(0.940, 0.342, -0.342, 0.940);\n    float front = smoothstep(0.01,0.0, abs(p.x-0.2)-0.04)*sin(p.y*100. + 0.5)*0.03;\n    float core  = sdBox(p + vec3(-0.2,.93,-2.3), vec3(0.08,0.04,0.115 + (p.y+1.)*0.5 + front));\n    core = min(core, sdBox(p + vec3(-0.2,.91,-2.28), vec3(0.06 - (p.y+.9)*0.2, 0.04, 0.1 - (p.y+.9)*0.4)));\n    core = min(core, sdBox(p + vec3(-0.2,.87,-2.28), vec3(0.05 - (p.y+.9)*0.3, 0.02, 0.09 - (p.y+.9)*0.5)));\n    float ports = length(p + vec3(-.205,0.875,-2.3))-0.035;\n    p.x = abs(p.x-0.2)+0.16;\n    ports = min(ports, length(p + vec3(-.19,0.92,-2.4))-0.035);\n    return dUnion(vec2(core, 3.), vec2(ports, 4.));\n}\n\nfloat linstep(in float mn, in float mx, in float x)\n{\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\n}\n\nvec3 tri(vec3 p) { return abs(fract(p)-0.5)-0.222; }\n\nconst mat3 m3 = mat3(0.75425, 0.41613, -0.50788, -0.61539, 0.71772, -0.32585, 0.22892, 0.55832, 0.79742);\n\nfloat terrain(vec3 p)\n{\n    vec3 bp = p;\n    float d = 0.;\n    float frq = 0.245;\n    float z = 4.86;\n    for(int i = 0; i < 7; i++)\n    {\n        p += vec3(.2, 1.43,0.45);\n        d += dot(tri(p*frq), tri(p.yzx*frq + 0.43))*z;     \n        frq *= 1.89;\n        z *= 0.46;\n        p *= m3;\n    }\n    \n    d += 0.05;\n    d *= clamp(dot(bp.xz,bp.xz)*0.65,0.25,1.); //flat near rocket\n    return linstep(.8, 0.15,d)*1.1 + linstep(0.15,-.15, d)*0.09 + linstep(-0.17,-3., d);\n}\n\n\nvec2 map(vec3 p)\n{   \n    float d = terrain(p) + p.y - 0.4;\n    \n    //bounding box\n    #ifdef BOUNDED\n    d = max(d, sdBox(p + vec3(0,-1.25,0), vec3(2.4,2.3,2.4)));\n    #endif\n\n    vec2 rez = dUnion(vec2(d, 1.), vec2(rocket(p),2.));\n    rez = dUnion(rez, tank(p));\n    \n    //crates\n    p.xz = foldTri(p.xz+vec2(0.4,0.45))+0.27;\n    float crates = sdBox(p + vec3(0.,.71,.0), vec3(0.042, 0.04, 0.037));\n    \n    rez = dUnion(rez, vec2(crates, 5.));\n    \n    return rez;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\nfloat dBox(vec3 ro, vec3 invRd, float size) \n{\n    vec3 t = -ro*invRd + abs(invRd)*size;\n\treturn min(min(t.x, t.y), t.z);\n}\n\n//Sphere-tracing (raymarching) / box-tracing hybrid\n//allows to march thousands of voxels deep\nvec2 marchVxl(in vec3 ro, in vec3 rd, float near, float far, out vec3 alig, out vec3 vPos)\n{\n    float lastD = 0.0001;\n    float travel = near;\n    \n    float gridStride = 0.;\n    vec3 ip = vec3(0);\n    vec3 invRd = 1./rd;\n    vec2 bxNfo = vec2(0.);\n    \n    for( int i=0; i<ITR; i++ )\n    {\n        travel += lastD*.8 + gridStride;\n        if(travel > far) break;\n        vec3 pos = ro + rd*travel;\n        float mapD = map(pos).x;\n        \n        if (mapD < (scl*1.2))\n        {\n            travel -= lastD*0.6;\n            pos = ro + rd*travel;\n            ip = (floor(pos/scl) + 0.5)*scl;\n        \tbxNfo = map(ip);\n            if (bxNfo.x < 0.0) break;\n            vec3 q  = fract(pos/scl)*scl - hscl;\n            gridStride = dBox(q, invRd, hscl + 1e-6);\n            mapD = 0.;\n        }\n        else gridStride= 0.;\n        lastD = mapD;\n    }\n    \n    vec3 intc = -(fract((ro + rd*travel)/scl)*scl - hscl)*invRd - abs(invRd)*hscl;\n    alig = step(intc.yzx, intc.xyz)*step(intc.zxy, intc.xyz);\n    vPos = ip;\n    \n\treturn vec2(travel, bxNfo.y);\n}\n\n\n//inspired by fb39ca4's Voxel AO (https://www.shadertoy.com/view/ldl3DS)\n//and by reinder's and shane's modifications of fb39ca4's code\n//written to be clean-ish, self-contained and to support any voxel size\nfloat vxlAO(vec3 vp, vec3 sp, vec3 nor, vec3 alig) \n{\n    sp = fract(sp/scl);\n    vec2 uv = sp.yz*alig.x + sp.zx*alig.y + sp.xy*alig.z;\n    vec3 p = vp + nor*scl;\n    alig *= scl;\n    vec4 side = step(vec4(map(p + alig.zxy).x, map(p + alig.yzx).x, map(p - alig.zxy).x, map(p - alig.yzx).x), vec4(0));\n    vec4 cornr = vec4(map(p + alig.zxy + alig.yzx).x, map(p - alig.zxy + alig.yzx).x,\n                      map(p - alig.zxy - alig.yzx).x, map(p + alig.zxy - alig.yzx).x);\n    vec4 faceOcc = 1.0 - (side + side.yzwx + max(step(cornr, vec4(0)), side*side.yzwx))/3.;\n    return mix(mix(faceOcc.z, faceOcc.w, uv.x), mix(faceOcc.y, faceOcc.x, uv.x), uv.y);\n}\n\nvec3 lgt = normalize( vec3(-.5, 0.19, -0.2) );\nvec3 lcol = vec3(1.,0.86,0.77)*1.3;\n\n//Laplacian-based curvature, a great way to add detail to any scene with sdf data\n//more detail: https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;\n    float t1 = map(p + e.yxx).x, t2 = map(p + e.xxy).x;\n    float t3 = map(p + e.xyx).x, t4 = map(p + e.yyy).x; \n    return .125/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4.*map(p).x);\n}\n\nvec3 shade(in vec3 pos, vec3 nor, in vec3 rd, float ao, float matID)\n{\n    //mtl m;\n    \n    vec3 ip = (floor(pos/scl) + 0.5)*scl;\n    \n    float rn = clamp(valueNoise(ip.xz*4.)-0.5,0.,1.);\n    //vec3 alb = sin(vec3(.2,.25,.4) + pos.y*pos.y*5. + rn*3.)*0.12+0.2;\n    vec3 alb = sin(vec3(.25,.35,.4) + pos.y*pos.y*5. + rn*3.)*0.13+0.2;\n    \n    //landing dust\n    vec2 pl = vec2(atan(pos.z, pos.x), length(pos.xz));\n    float nzpl = valueNoise(pl*vec2(8.5,5));\n    alb *= mix(1.,nzpl*1.2+.1, smoothstep(1.9,-.5,pl.y)*smoothstep(-0.05,.23,pl.y));\n    \n    //overly complex tank tracks\n    vec2 trCoords = pos.xz;\n    trCoords.y += 0.15;\n    trCoords *= rot(-trCoords.y*0.2 + .925);\n    trCoords.x = abs(trCoords.x) -0.05;\n    alb *= (smoothstep(0.0,1.,sin(mix(trCoords.y,pos.z,0.0 - pos.x*0.25)*130.))-.5)*smoothstep(0.05,0.00, abs(trCoords.x))*\n        smoothstep(.8,0.6, abs(trCoords.y-1.2)) + 1.;    \n    \n    alb += (hash33(ip).x*2.0-1.0)*0.06 + 0.04;\n    \n    ip.y -= 0.21;\n    //shade rocket\n    if (matID == 2.)\n    {\n        //polar\n        vec2 ppol = vec2(atan(ip.z,ip.x)*0.95, ip.y*8.3);\n        float f = mod(floor(ppol.x - 0.1) + floor(ppol.y + .8), 2.);\n        f *= step(abs(ip.y+0.16)-.3, 0.);\n        alb = mix(vec3(.6,0.03,0.03), vec3(0.75,0.75,0.7), f);\n    }\n    else if (matID == 3.)\n    {\n        alb = mix(vec3(0.04,0.17,.5)*1.1, vec3(0.07), step(ip.y,-.915));\n    }\n    else if (matID == 5.)\n    {\n        alb = vec3(0.55,0.32,0.1);\n        alb *= smoothstep(-1.5,-0.5,sin(ip.y*400. + 0.5));\n    }\n    \n    alb *= curv(pos, 0.05)*0.07+.7;\n    if (matID == 1.) alb *= smoothstep(-1.,-.1,pos.y) + 1.;\n    \n    const float numcol = 18.;\n    alb = floor(alb*numcol)/numcol;\n    \n    \n\tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n\tvec3 col = vec3(0.);\n    \n    if (nl > 0.)\n    {\n        float shd2 = 0.;\n        vec3 tm1, tm2;\n        if(nl>0.01)\n        {\n            shd2 = marchVxl(pos + nor*0.0001, lgt, 0., 3., tm1, tm2).x;\n            shd2 = step(3., shd2);\n        }\n        nl *= shd2*0.75+0.25;\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        col = lcol*nl*alb + fre*nl*0.05;\n    }\n    col += 0.01*alb;\n    col *= ao;\n    return col;\n}\n\nvec3 bg(in vec3 p, in vec3 ro)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.y*2.1;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.001+i*i*0.0017);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.26;\n    }\n    return c*c;\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 ofst = hash2(uint(iFrame)) - 0.5;\n    ofst*= .25;\n    vec2 r = fragCoord.xy / iResolution.xy;\n\tvec2 q = (fragCoord.xy+ofst) / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.3,-0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\tmo.y = clamp(mo.y*0.8-.45,-.8 ,-0.25 );\n\t\n    //orthographic camera\n    #ifdef ORTHOGRAPHIC\n    vec3 ro = vec3(p*(3.3+sin(iTime*0.1)*0.2) + vec2(0,-.5), 5.);\n    vec3 rd = vec3(p*1e-20,-1.0);\n    #else\n    vec3 ro = vec3(0.,-0.8,5.2);\n    vec3 rd = normalize(vec3(p,-1.6));\n    #endif\n    vec3 rd2 = normalize(vec3(p, -1.));\n    \n    mat3 cam = rot_x(-mo.y)*rot_y(-mo.x + sin(iTime*0.05)*0.4 - 0.5);\n   \tro *= cam;\n\trd *= cam;\n    rd2 *= cam;\n    \n    vec3 invRd = 1./rd;\n    vec3 t = -ro*invRd - abs(invRd)*2.41;\n    #ifdef BOUNDED\n\tfloat near =  max(max(t.x, t.y), t.z);\n    #else\n    float near = 0.;\n    #endif\n    vec3 vPos, alig;\n    vec2 rz = marchVxl(ro, rd, near, FAR, alig, vPos);\n    vec3 nor = -sign(rd)*alig;\n    vec3 col = bg(rd2, ro);\n    \n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro + rd*rz.x;\n        vec3 nor2 = normal(pos);\n        float ao = vxlAO(vPos, pos, nor, alig);\n        nor = mix(nor2, nor, .6);\n        col = shade(pos, nor, rd, ao, rz.y);\n    }\n    \n\tcol = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055; //Correct gamma\n    \n    col = mix(col, textureLod(iChannel0, r, 0.).rgb, 0.65);\n    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"}]}