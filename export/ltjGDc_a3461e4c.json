{"ver":"0.1","info":{"id":"ltjGDc","date":"1433300240","viewed":257,"name":"Study iQ's dir deriv ","username":"tyleeer","description":"Simple trick save operations.\n\nThere is some visible difference, especially when there is more detailed thing.\n\nMathematically equivalent, but why there is difference?","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Usign directional derivatives for lighting is much faster than computing \n// gradients/normals and doing lighting with it (if the number of lights is\n// less than four). Mostly useful for volumetric effects.\n//\n// See \n//\n//  https://iquilezles.org/articles/derivative\n//\n// and also:\n//\n//  https://www.shadertoy.com/view/XslGRr\n//  https://www.shadertoy.com/view/Xd23zh]Xd23zh\n//  https://www.shadertoy.com/view/MsfGzM\n//\n// In the left half of the screen, directional derivatives. On the right, the\n// traditional gradient-based lighting. Move the mouse to compare.\n\nfloat noise(vec3 p) {\n \n    return 0.3*cos(sin(5.0*p.x)+cos(10.0*p.y+cos(iTime))+0.5*sin(4.0*p.z+sin(iTime)))*sin(0.5*iTime); \n}\n\nfloat map( vec3 p )\n{\n\tfloat d1 = p.y - 0.0 + noise(cos(0.8*p)); // ground plane\n    float d2 = length(p-vec3(0.0,0.0,0.0)) - 1.0 + noise(cos(p)); // ball1\n    float d3 = length(p.xz-vec2(-3.0,0.0)) - 0.5 + noise(sin(2.0*p)); // cylinder\n    float d4 = length(p-vec3(1.0,1.0,1.0)) - 1.0 + noise(p); // ball2\n    return min( min(d1,d2), min(d3,d4) ); // Union all of them\n}\n\n// ray casting\nfloat intersect( in vec3 ro, in vec3 rd, const float maxdist )\n{\n    float res = -1.0;\n    float t = 0.1;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + t*rd);\n        res = t;\n        if( h<(0.0001*t) || t>maxdist ) break;\n        t += h;\n    }\n    return res;\n}\n\n// calculate normal\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    // so weird formula.... see the one below for more clear one\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 calcGradient(vec3 pos)\n{\n    // the distance field F(p) = 0 defines the isosurface\n    // according to the definition of gradient DF_p = normal\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 ); // small perturbation\n\tvec3 grad = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy), // [D(x+dx,y,z)-D(x,y,z)]/dx \n\t    map(pos+eps.yxy) - map(pos-eps.yxy), // [D(x,y+dy,z)-D(x,y,z)]/dy\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) ); //[D(x,y,z+dz)-D(x,y,z)]/dz\n    \n    return grad/(2.0*eps.x);\n}\n\nvec3 calcNormal( in vec3 pos )\n{   \n    return normalize(calcGradient(pos));\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float doAB )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    float t = intersect( ro, rd, maxdist );\n    \n    if( t < maxdist )\n    {\n        float eps = 0.001;\n        vec3  pos = ro + t*rd;\n\n        vec3 lig = normalize( vec3(1.0,1.0,1.0) ); // this is a vector point from position to light source\n        float dif = 0.0;\n\n        // directional derivative\n        if( doAB>0.0 )\n        {\n            dif = (map(pos+lig*eps) - map(pos)) / eps;\n            float s = length(calcGradient(pos));\n            dif = dif*(1.0/s);\n        }\n        // gradient based lighting\n\telse\n        {\n            vec3 nor = calcNormal( pos);\n            dif = dot(nor,lig);\n        }\n        \n        dif = clamp( dif, 0.0, 1.0 ); // ignore negative things which means in shadow\n        \n        col = vec3(1.0,0.8,0.3)*dif + vec3(0.1,0.15,0.3); // diffuse light color + ambient, shadow is not completely black but the opposite of light\n        \n        col *= exp( -0.1*t ); // simulate light intensity decay\n    }\n    \n    return pow( col, vec3(0.45) ); // gamma correction, why this formular....\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y; // uv space and preserve aspect ratio\n    \n    // camera configuration\n    vec3  ro = vec3(0.0,1.0,7.0); // ray origin, camera center\n    vec3  ta = vec3(0.0,1.0,0.0); // camera direction, camera aim at\n    vec3  ww = normalize( ta - ro); // z direction\n    vec3  uu = normalize( cross( ww,vec3(0.0,1.0,0.0 ) )); // front X up is right \n    vec3  vv = normalize( cross(uu,ww) ); // right x front = UP\n    vec3  rd = normalize( p.x*uu + p.y*vv + 3.0*ww ); // ray direction take focal len into consideration\n\n    float im = iMouse.x; if( iMouse.z<=0.001 ) im = iResolution.x/2.0; // set mouse to center when there is no clicking\n    float dm = im - fragCoord.x; // for each pixel calculate its signed distance to mouse position\n\n    vec3 col = render( ro, rd, dm ); // render scene\n    \n    col = mix( vec3(0.0), col, smoothstep( 1.0, 2.0, abs(dm) ) ); // draw splitting line\n    \n    fragColor = vec4( col, 1.0 );\n}\n\n","name":"","description":"","type":"image"}]}