{"ver":"0.1","info":{"id":"MfSGWh","date":"1704142462","viewed":46,"name":"Cross Field","username":"luckyballa","description":"Cross field implementation using Monte Carlo PDE\n\nUseful for geometry processing, especially quad remeshing\n\nhttps://geometry-central.net/surface/algorithms/direction_fields","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["wos","crossfiled","directionalfield","prde","motecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 data = texture(iChannel0, uv);\n    \n    vec3 res = vec3(data.xy / data.w, data.z);    \n    float angle = atan(res.y, res.x) / N_SYM;\n    vec2 normal = vec2(cos(angle), sin(angle));\n    float crossDist = step(crossFieldDist(p, normal), 0.05);\n    \n    vec3 col = pal(angle / PI + 0.2, vec3(0.5),vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.67));\n    col += crossDist * 0.777;\n    float d = sdPolygon(p, polygon);\n    // col.xy = normal.xy; col.z = 0.0;\n    col *= max(-sign(sdPolygon(p, polygon)), 0.5);\n    col += smoothstep(0.002, 0.001, abs(d));\n \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 map(vec2 pos) {    \n  vec3 dis_col = sdcPolygon(pos, polygon);\n\n\n  return dis_col;\n}\n\n\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n\nvec2 randomInCircle( void ) {\n    float an = 6.283185*float(rand())/32767.0;\n    return vec2(cos(an),sin(an));\n}\n\nvec2 march( in vec2 p ) {\n    vec3 h = vec3(0.0);\n\tfor(int i=0; i< 32; i++) {\n        h = map(p);\n        if( h.x<0.005) break;\n        p = p + h.x * randomInCircle();\n    }\n    return h.yz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n    srand(ivec2(fragCoord), iFrame);\n\n    vec3 col = vec3(march(p), 0.0);\n    vec4 t = vec4(0.0);\n    \n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    fragColor = vec4(vec2(data.xy) + col.xy, col.z, data.w + 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define CROSS_DENSITY 30.0\n#define N_SYM 4.0\n\nconst int N = 29;\n\nvec2[N] polygon = vec2[](\n    vec2(0, -0.4), \n    vec2(0.35, -0.4), \n    vec2(0.35, 0.0), \n    vec2(0.35, 0.35),\n    vec2(0.2, 0.35), \n    \n    vec2(sin(PI * 0.55) * 0.2, 0.35 + cos(PI * 0.55) * 0.2),\n    vec2(sin(PI * 0.6) * 0.2, 0.35 + cos(PI * 0.6) * 0.2),\n    vec2(sin(PI * 0.65) * 0.2, 0.35 + cos(PI * 0.65) * 0.2),\n    vec2(sin(PI * 0.7) * 0.2, 0.35 + cos(PI * 0.7) * 0.2),\n    vec2(sin(PI * 0.75) * 0.2, 0.35 + cos(PI * 0.75) * 0.2),\n    vec2(sin(PI * 0.8) * 0.2, 0.35 + cos(PI * 0.8) * 0.2),\n    vec2(sin(PI * 0.85) * 0.2, 0.35 + cos(PI * 0.85) * 0.2),\n    vec2(sin(PI * 0.9) * 0.2, 0.35 + cos(PI * 0.9) * 0.2),\n    vec2(sin(PI * 0.95) * 0.2, 0.35 + cos(PI * 0.95) * 0.2),\n\n    vec2(0.0, 0.15),\n    \n    vec2(-sin(PI * 0.95) * 0.2, 0.35 + cos(PI * 0.95) * 0.2),\n    vec2(-sin(PI * 0.9) * 0.2, 0.35 + cos(PI * 0.9) * 0.2),\n    vec2(-sin(PI * 0.85) * 0.2, 0.35 + cos(PI * 0.85) * 0.2),\n    vec2(-sin(PI * 0.8) * 0.2, 0.35 + cos(PI * 0.8) * 0.2),\n    vec2(-sin(PI * 0.75) * 0.2, 0.35 + cos(PI * 0.75) * 0.2),\n    vec2(-sin(PI * 0.7) * 0.2, 0.35 + cos(PI * 0.7) * 0.2),\n    vec2(-sin(PI * 0.65) * 0.2, 0.35 + cos(PI * 0.65) * 0.2),\n    vec2(-sin(PI * 0.6) * 0.2, 0.35 + cos(PI * 0.6) * 0.2),\n    vec2(-sin(PI * 0.55) * 0.2, 0.35 + cos(PI * 0.55) * 0.2),\n\n    vec2(-0.2, 0.35), \n    vec2(-0.35, 0.35), \n    vec2(-0.35, 0.0), \n    vec2(-0.35, -0.4), \n    vec2(0, -0.4)\n   \n    );\n\n\nfloat sdSegment(  vec2 p,  vec2 a,  vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t vec2 r = pa - ba*h;\n    return length( pa - ba*h );\n}\n\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n    \nvec2 ortho(vec2 o) {\n    return vec2(-o.y, o.x);\n} \n\n\nfloat crossFieldDist(vec2 p, vec2 t) {\n    float m = 0.2;\n    vec2 s = ortho(t);\n    vec2 b = normalize(t) * m;\n    vec2 sb = normalize(s) * m;\n    vec2 fp = fract(p * CROSS_DENSITY) - 0.5;\n   \n    float rz = sdSegment(fp, -b , b);\n    rz = min(rz, sdSegment(fp, -sb , sb));\n\n\n\n    vec2 prp = (vec2(-b.y,b.x));\n    \n    return rz;\n}\n\nvec2 encode(vec2 n) {\n    float a = atan(n.y, n.x) * N_SYM;\n\n    return vec2(cos(a), sin(a));\n}\n\nvec2 decode(vec2 n) {\n    float a = atan(n.y, n.x) / N_SYM;\n\n    return vec2(cos(a), sin(a));\n}\n\n\nvec3 sdcPolygon( in vec2 p, in vec2[N] v) {\n    vec2 vip = v[0];\n    vec2 vjp = v[N - 1];\n    float d = dot(p - vip, p - vip);\n    float s = 1.0;\n    vec3 res = vec3(1e20, 0.0, 0.0);\n        for(int i = 0; i < N; i++) {\n            vec2 e = vjp - vip;\n            vec2 w = p - vip;\n            vec2 b = w - e * clamp(dot(w,e) / dot(e,e), 0.0, 1.0 );\n            d = min(dot(b, b), d);\n            bvec3 c = bvec3(p.y >= vip.y ,p.y < vjp.y, e.x * w.y > e.y * w.x);\n            if( all(c) || all(not(c)) ) { s*=-1.0; }\n            \n            vjp = vip;\n            vip = vec2(v[i + 1]);\n            \n            if (d < res.x) {\n                vec2 n = normalize(vec2(e.y, -e.x));\n                vec2 f = encode(n);\n\n                res = vec3(d, f);\n            }\n        }\n\n    res.x = sqrt(d);\n\n    return res;\n}\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}