{"ver":"0.1","info":{"id":"NldGzn","date":"1663271047","viewed":222,"name":"fast atmo scattering 2022","username":"16807","description":"Same as the work here, but with a split screen presentation that's easier to debug: https://www.shadertoy.com/view/3ll3zM","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sky","volumetric","scattering","atmosphere","rayleigh","mie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265358979323846264338327950288419716939937510;\nconst float PHI = 1.6180339887;\nconst float BIG = 1e20;\nconst float SMALL = 1e-20;\n\nstruct maybe_int\n{\n    int value;\n    bool exists;\n};\nstruct maybe_float\n{\n    float value;\n    bool exists;\n};\nstruct maybe_vec2\n{\n    vec2 value;\n    bool exists;\n};\nstruct maybe_vec3\n{\n    vec3 value;\n    bool exists;\n};\n\n/*\nMENSURATION\nthis file contains functions for finding perimeters, areas, \nsurface areas, and volumes of primitive shapes\n*/\nfloat get_surface_area_of_sphere(\n    in float radius\n) {\n    return 4.*PI*radius*radius;\n}\n//#include \"precompiled/academics/math/geometry/point_intersection.glsl\"\n\nmaybe_vec2 get_bounding_distances_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_vec2(\n        vec2(\n          max(min(distances_along_line.value.x, distances_along_line.value.y), 0.0),\n          max(distances_along_line.value.x, distances_along_line.value.y)\n        ),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_nearest_distance_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_float(\n        distances_along_line.value.x < 0.0? distances_along_line.value.y :\n        distances_along_line.value.y < 0.0? distances_along_line.value.x :\n        min(distances_along_line.value.x, distances_along_line.value.y),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_distance_along_line_to_union(\n    in maybe_float shape1,\n    in maybe_float shape2\n) {\n    return maybe_float(\n        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),\n        shape1.exists || shape2.exists\n    );\n}\nmaybe_vec2 get_distances_along_line_to_union(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),\n             !shape1.exists ? shape2.value.y : !shape2.exists ? shape1.value.y : max(shape1.value.y, shape2.value.y )),\n        shape1.exists || shape2.exists\n    );\n}\nmaybe_vec2 get_distances_along_line_to_negation(\n    in maybe_vec2 positive,\n    in maybe_vec2 negative\n) {\n    /*\n    There are 4 values to consider, which are the entrances and exits for positive and negative space.\n    In comments, we denoted these values as x+, y+, x-, and y-,\n     where x variables indicate entrances, and y variables indicate exits.\n    There are 4*3*2*1 = 24 ways these 4 values could be sequenced along a number line,\n     however we can ignore sequences where yp<xp and y+<x-.\n    We can see all possible sequences that fulfill this condition using the following code, in python:\n        [A for A in itertools.permutations(['x+','y+','x-','y-']) \n         if A.index('x+') < A.index('y+') and A.index('x-') < A.index('y-')]\n    Combined with flags for whether positive/negative space exists along the ray, \n    This provides us with the following possibilities along with their output:\n    \n        input               output\n                    exists        exists\n        1  2  3  4  - +     x  y  \n        *  *  *  *  F F     *  *  F\n        *  *  *  *  T F     *  *  F\n        *  *  *  *  F T     x+ y+ T\n        x+ y+ x- y- T T     x+ y+ T\n        x+ x- y+ y- T T     x+ x- T\n        x+ x- y- y+ T T     x+ x- T\n        x- x+ y+ y- T T     *  *  F\n        x- x+ y- y+ T T     y- y+ T\n        x- y- x+ y+ T T     x+ y+ T\n        \n    (NOTE: asterisks above indicate arbitrary values)\n\n    */\n\n    float xp = positive.value.x;\n    float yp = positive.value.y;\n    float xn = negative.value.x;\n    float yn = negative.value.y;\n\n    // as long as intersection with positive exists, \n    // and negative doesn't completely surround it, there will be an intersection\n    if (!positive.exists || (xn < xp && yp < yn && negative.exists)){\n        return maybe_vec2( vec2(xn, xn), false);\n    }\n    else if (!negative.exists || yn < xp){\n        return positive;\n    } \n    else if (xp < xn) {\n        return maybe_vec2( vec2(min(yn, xp), min(xn, yp)), true);\n    }\n    else /*x- x+ y- y+*/{\n        return maybe_vec2( vec2(yn, yp), true);\n    } \n}\nmaybe_vec2 get_distances_along_line_to_obscuration(\n    in maybe_vec2 positive,\n    in maybe_vec2 negative\n) {\n    /*\n    \"obscuration\" is not a standard CSG operation but it is useful within shaders.\n    It is similar to the negation, but fails to return an object if \n    the \"positive\" object is obscured behind the \"negative\" object.\n    The following is its full input/output table:\n    \n        input               output\n                    exists        exists\n        1  2  3  4  - +     x  y  \n        *  *  *  *  F F     *  *  F\n        *  *  *  *  T F     *  *  F\n        *  *  *  *  F T     x+ y+ T\n        x+ y+ x- y- T T     x+ y+ T\n        x+ x- y+ y- T T     x+ x- T\n        x+ x- y- y+ T T     x+ x- T\n        x- x+ y+ y- T T     *  *  F\n        x- x+ y- y+ T T     *  *  F\n        x- y- x+ y+ T T     *  *  F\n        \n    (NOTE: asterisks above indicate arbitrary values)\n\n    */\n\n    float xp = positive.value.x;\n    float yp = positive.value.y;\n    float xn = negative.value.x;\n    float yn = negative.value.y;\n\n    // as long as intersection with positive exists, \n    // and negative doesn't obscure it, there will be an intersection\n    if (!positive.exists || (xn < xp && negative.exists)){\n        return maybe_vec2( vec2(xn, xn), false);\n    }\n    else {\n        return maybe_vec2( vec2(xp, min(xn, yp)), true);\n    } \n}\n\nmaybe_vec2 get_distances_along_line_to_intersection(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.0;\n    float y = shape1.exists && shape2.exists ? min(shape1.value.y, shape2.value.y ) : 0.0;\n    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);\n}\n\n\n/*\nA0 point position\nB0 plane reference\nN  vertex normal\n*/\nfloat get_distance_of_3d_point_to_region_bounded_by_plane(in vec3 A0, in vec3 B0, in vec3 N)\n{\n    return dot(A0-B0, N);\n}\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 plane reference\nN  plane surface normal, normalized\n*/\nmaybe_float get_distance_along_3d_line_to_plane(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N\n){\n    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 sphere origin\nR  sphere radius along each coordinate axis\n*/\nmaybe_vec2 get_distances_along_3d_line_to_sphere(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in float r\n){\n    float t = dot(B0 - A0, A);\n    vec3  At = A0 + A*t - B0;\n    float y2 = r*r - dot(At,At);\n    float dxr = sqrt(max(y2, SMALL));\n    return maybe_vec2(\n        vec2(t - dxr, t + dxr),\n        y2 > 0.\n    );\n}\n\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 cylinder reference\nB  cylinder direction, normalized\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r\n){\n    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    // implementation shamelessly copied from Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 D = A0 - B0;\n    float BA = dot(B, A);\n    float BD = dot(B, D);\n    float a = 1.0 - BA * BA;\n    float b = dot(D, A) - BD * BA;\n    float c = dot(D, D) - BD * BD - r * r;\n    float h = sqrt(max(b * b - a * c, 0.0));\n    return maybe_vec2(\n        vec2((-b + h) / a, (-b - h) / a),\n        h > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);\n    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);\n    float a_in = min(a1.value, a2.value);\n    float a_out = max(a1.value, a2.value);\n    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);\n    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);\n    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);\n    // TODO: do we need this line?\n    float entrance = max(tube.value.y, a_in);\n    float exit = min(tube.value.x, a_out);\n    return maybe_vec2(\n        vec2(entrance, exit),\n        tube.exists && entrance < exit\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 capsule endpoint 1\nB2 capsule endpoing 2\nr  capsule radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_capsule(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);\n    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);\n    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);\n    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);\n    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);\n    return capsule;\n}\n\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nvec3 get_surface_normal_of_point_near_sphere( in vec3 A0, in vec3 B0 )\n{\n    return normalize( A0-B0 );\n}\n\n\n\nconst float KELVIN = 1.;\nconst float KILOGRAM = 1.; // kilograms\nconst float METER = 1.; // meters\nconst float SECOND = 1.; // seconds\nconst float NEWTON = KILOGRAM * METER / (SECOND * SECOND);\nconst float JOULE = NEWTON * METER;\nconst float WATT = JOULE / SECOND;\nconst float EARTH_RADIUS = 6.367e6; // meters\nconst float ASTRONOMICAL_UNIT = 149597870700.;// meters\nconst float GLOBAL_SOLAR_CONSTANT = 1361.; // watts/meter^2\nconst float SOLAR_MASS = 2e30; // kilograms\nconst float SOLAR_RADIUS = 695.7e6; // meters\nconst float SOLAR_LUMINOSITY = 3.828e26; // watts\nconst float SOLAR_TEMPERATURE = 5772.; // kelvin\n\n\nconst float SPEED_OF_LIGHT = 299792458. * METER / SECOND;\nconst float BOLTZMANN_CONSTANT = 1.3806485279e-23 * JOULE / KELVIN;\nconst float STEPHAN_BOLTZMANN_CONSTANT = 5.670373e-8 * WATT / (METER*METER* KELVIN*KELVIN*KELVIN*KELVIN);\nconst float PLANCK_CONSTANT = 6.62607004e-34 * JOULE * SECOND;\n\n// see Lawson 2004, \"The Blackbody Fraction, Infinite Series and Spreadsheets\"\n// we only do a single iteration with n=1, because it doesn't have a noticeable effect on output\nfloat solve_fraction_of_light_emitted_by_black_body_below_wavelength(\n    in float wavelength,\n    in float temperature\n){\n    const float iterations = 2.;\n    const float h = PLANCK_CONSTANT;\n    const float k = BOLTZMANN_CONSTANT;\n    const float c = SPEED_OF_LIGHT;\n    float L = wavelength;\n    float T = temperature;\n    float C2 = h*c/k;\n    float z = C2 / (L*T);\n    float z2 = z*z;\n    float z3 = z2*z;\n    float sum = 0.;\n    float n2=0.;\n    float n3=0.;\n    for (float n=1.; n <= iterations; n++) {\n        n2 = n*n;\n        n3 = n2*n;\n        sum += (z3 + 3.*z2/n + 6.*z/n2 + 6./n3) * exp(-n*z) / n;\n    }\n    return 15.*sum/(PI*PI*PI*PI);\n}\nfloat solve_fraction_of_light_emitted_by_black_body_between_wavelengths(\n    in float lo,\n    in float hi,\n    in float temperature\n){\n    return solve_fraction_of_light_emitted_by_black_body_below_wavelength(hi, temperature) -\n            solve_fraction_of_light_emitted_by_black_body_below_wavelength(lo, temperature);\n}\n// This calculates the radiation (in watts/m^2) that's emitted \n// by a single object using the Stephan-Boltzmann equation\nfloat get_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    float T = temperature;\n    return STEPHAN_BOLTZMANN_CONSTANT * T*T*T*T;\n}\nvec3 solve_rgb_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    return get_intensity_of_light_emitted_by_black_body(temperature)\n         * vec3(\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(600e-9*METER, 700e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(500e-9*METER, 600e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(400e-9*METER, 500e-9*METER, temperature)\n           );\n}\n// Rayleigh phase function factor [-1, 1]\nfloat get_fraction_of_rayleigh_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    return 3. * (1. + cos_scatter_angle*cos_scatter_angle)\n    / //------------------------\n                (16. * PI);\n}\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nfloat get_fraction_of_mie_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    return (1. - g*g)\n    / //---------------------------------------------\n        ((4. + PI) * pow(1. + g*g - 2.*g*cos_scatter_angle, 1.5));\n}\n// Schlick's fast approximation to the Henyey-Greenstein phase function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nfloat approx_fraction_of_mie_scattered_light_scattered_by_angle_fast(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    const float k = 1.55*g - 0.55 * (g*g*g);\n    return (1. - k*k)\n    / //-------------------------------------------\n        (4. * PI * (1. + k*cos_scatter_angle) * (1. + k*cos_scatter_angle));\n}\n/*\n\"get_fraction_of_microfacets_accessible_to_ray\" is Schlick's fast approximation for Smith's function\n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_accessible_to_ray(\n    in float cos_view_angle,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float v = cos_view_angle;\n    // float k = m/2.0; return 2.0*v/(v+sqrt(m*m+(1.0-m*m)*v*v)); // Schlick-GGX\n    float k = m*sqrt(2./PI); return v/(v*(1.0-k)+k); // Schlick-Beckmann\n}\n/*\n\"get_fraction_of_microfacets_with_angle\" \n  This is also known as the Beckmann Surface Normal Distribution Function.\n  This is the probability of finding a microfacet whose surface normal deviates from the average by a certain angle.\n  see Hoffmann 2015 for a gentle introduction to the concept.\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_with_angle(\n    in float cos_angle_of_deviation,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float t = cos_angle_of_deviation;\n    float m2 = m*m;\n    float t2 = t*t;\n    float u = t2*(m2-1.0)+1.0; return m2/(PI*u*u);\n    //return exp((t*t-1.)/max(m*m*t*t, 0.1))/max(PI*m*m*t*t*t*t, 0.1);\n}\n/*\n\"get_fraction_of_light_reflected_from_facet_head_on\" finds the fraction of light that's reflected\n  by a boundary between materials when striking head on.\n  It is also known as the \"characteristic reflectance\" within the fresnel reflectance equation.\n  The refractive indices can be provided as parameters in any order.\n*/\nfloat get_fraction_of_light_reflected_from_facet_head_on(\n    in float refractivate_index1,\n    in float refractivate_index2\n){\n    float n1 = refractivate_index1;\n    float n2 = refractivate_index2;\n    float sqrtF0 = ((n1-n2)/(n1+n2));\n    float F0 = sqrtF0 * sqrtF0;\n    return F0;\n}\n/*\n\"get_rgb_fraction_of_light_reflected_from_facet\" returns Fresnel reflectance for each color channel.\n  Fresnel reflectance is the fraction of light that's immediately reflected upon striking the surface.\n  It is the fraction of light that causes specular reflection.\n  Here, we use Schlick's fast approximation for Fresnel reflectance.\n  see https://en.wikipedia.org/wiki/Schlick%27s_approximation for a summary \n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for implementation details\n*/\nvec3 get_rgb_fraction_of_light_reflected_from_facet(\n    in float cos_incident_angle,\n    in vec3 characteristic_reflectance\n){\n    vec3 F0 = characteristic_reflectance;\n    float _1_u = 1.-cos_incident_angle;\n    return F0 + (1.-F0) * _1_u*_1_u*_1_u*_1_u*_1_u;\n}\n/*\n\"get_fraction_of_light_reflected_from_material\" is a fast approximation to the Cook-Torrance Specular BRDF.\n  It is the fraction of light that reflects from a material to the viewer.\n  see Hoffmann 2015 for a gentle introduction to the concept\n*/\nvec3 get_fraction_of_light_reflected_from_material(\n    in float NL, in float NH, in float NV, in float HV,\n    in float root_mean_slope_squared,\n    in vec3 characteristic_reflectance\n){\n    float m = root_mean_slope_squared;\n    vec3 F0 = characteristic_reflectance;\n    return 1.0\n        * get_fraction_of_microfacets_accessible_to_ray(NL, m)\n        * get_fraction_of_microfacets_with_angle(NH, m)\n        * get_fraction_of_microfacets_accessible_to_ray(NV, m)\n        * get_rgb_fraction_of_light_reflected_from_facet(HV, F0)\n        / max(4.*PI*NV*NL, 0.001);\n}\n/*\n\"GAMMA\" is the constant that's used to map between \nrgb signals sent to a monitor and their actual intensity\n*/\nconst float GAMMA = 2.2;\n/* \nThis function returns a rgb vector that quickly approximates a spectral \"bump\".\nAdapted from GPU Gems and Alan Zucconi\nfrom https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\n*/\nvec3 get_rgb_intensity_of_rgb_signal(\n    in vec3 signal\n){\n    return vec3(\n        pow(signal.x, GAMMA),\n        pow(signal.y, GAMMA),\n        pow(signal.z, GAMMA)\n    );\n}\n/*\nThis function returns a rgb vector that best represents color at a given wavelength\nIt is from Alan Zucconi: https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\nI've adapted the function so that coefficients are expressed in meters.\n*/\nvec3 get_rgb_signal_of_rgb_intensity(\n    in vec3 intensity\n){\n    return vec3(\n        pow(intensity.x, 1./GAMMA),\n        pow(intensity.y, 1./GAMMA),\n        pow(intensity.z, 1./GAMMA)\n    );\n}\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\nmat4 get_translation_matrix(vec3 offset)\n{\n    return mat4(1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                offset,1);\n}\n\nfloat F(\n    in float x2,\n    in float y2,\n    in float r0\n){\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    float y = sqrt(y2);\n    float x = sqrt(x2);\n    float r = sqrt(x2+y2);\n    float Ch = (1. - 1./(2.*(y-x))) * SQRT_HALF_PI * sqrt(y) + 0.6*x;\n    return exp(r0-r) / (x/r + 1.0/Ch);\n}\n\n// \"approx_air_column_density_ratio_through_atmosphere\" \n//   calculates the distance you would need to travel \n//   along the surface to encounter the same number of particles in the column. \n// It does this by finding an integral using integration by substitution, \n//   then tweaking that integral to prevent division by 0. \n// All distances are recorded in scale heights.\n// \"a\" and \"b\" are distances along the ray from closest approach.\n//   The ray is fired in the positive direction.\n//   If there is no intersection with the planet, \n//   a and b are distances from the closest approach to the upper bound.\n// \"z2\" is the closest distance from the ray to the center of the world, squared.\n// \"r0\" is the radius of the world.\nfloat approx_air_column_density_ratio_through_atmosphere(\n    in float a,\n    in float b,\n    in float z2,\n    in float r0\n){\n    // GUIDE TO VARIABLE NAMES:\n    //  \"x*\" distance along the ray from closest approach\n    //  \"z*\" distance from the center of the world at closest approach\n    //  \"r*\" distance (\"radius\") from the center of the world\n    //  \"*0\" variable at reference point\n    //  \"*2\" the square of a variable\n    //  \"ch\" a nudge we give to prevent division by zero, analogous to the Chapman function\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    const float k = 0.6; // \"k\" is an empirically derived constant\n    float x0 = sqrt(max(r0*r0 - z2, SMALL));\n    return max( sign(b)*(F(x0*x0,z2,r0)-F(b*b,z2,r0)) - sign(a)*(F(x0*x0,z2,r0)-F(a*a,z2,r0)), 0.0 );\n}\n\n#ifndef PROD\n#define ASSERT(test, color) if (!(test)) { return color; }\n#else\n#define ASSERT(test, color)\n#endif\n    const float STEP_COUNT = 64.;\n\n// TODO: multiple scattering events\n// TODO: support for light sources from within atmosphere\n/*\n\"daylight\" is defined here as any light ray whose closest approach to a world falls below the surface\n\"twilight\" is defined here as any light ray whose closest approach to a world is above the surface\n*/\nvec3 get_rgb_fraction_of_distant_twilight_scattered_by_atmosphere(\n    vec3 view_origin, vec3 view_direction, float view_start_length, float view_stop_length,\n    vec3 world_position, float world_radius,\n    vec3 light_direction, float atmosphere_scale_height,\n    vec3 beta_ray, vec3 beta_mie, vec3 beta_abs\n){\n    // For an excellent introduction to what we're try to do here, see Alan Zucconi: \n    //   https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-3/\n    // We will be using most of the same terminology and variable names.\n    // GUIDE TO VARIABLE NAMES:\n    //  Uppercase letters indicate vectors.\n    //  Lowercase letters indicate scalars.\n    //  Going for terseness because I tried longhand names and trust me, you can't read them.\n    //  \"*v*\"    property of the view ray, the ray cast from the viewer to the object being viewed\n    //  \"*l*\"    property of the light ray, the ray cast from the object to the light source\n    //  \"y*\"     distance from the center of the world to the plane shared by view and light ray\n    //  \"z*\"     distance from the center of the world to along the plane shared by the view and light ray \n    //  \"r*\"     a distance (\"radius\") from the center of the world\n    //  \"h*\"     the atmospheric scale height, the distance at which air density reduces by a factor of e\n    //  \"*2\"     the square of a variable\n    //  \"*0\"     property at the start of the raymarch\n    //  \"*1\"     property at the end of the raymarch\n    //  \"*i\"     property during an iteration of the raymarch\n    //  \"d*\"     the change in a property across iterations of the raymarch\n    //  \"beta*\"  a scattering coefficient, the number of e-foldings in light intensity per unit distance\n    //  \"gamma*\" a phase factor, the fraction of light that's scattered in a certain direction\n    //  \"sigma*\" a column density ratio, the density of a column of air relative to surface density\n    //  \"F*\"     fraction of source light that reaches the viewer due to scattering for each color channel\n    //  \"*_ray\"  property of rayleigh scattering\n    //  \"*_mie\"  property of mie scattering\n    //  \"*_abs\"  property of absorption\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h = atmosphere_scale_height;\n    float r = world_radius / h;\n    vec3 V0 = (view_origin + view_direction * view_start_length - world_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - world_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float va = dot(V0,V);\n    float vc = dot(V1,V);\n    float vb = max(min(vc,0.0),va);\n    vec3 L = light_direction; // unit vector pointing to light source\n    float VL = dot(V,L);\n    // \"gamma_*\" indicates the fraction of scattered sunlight that scatters to a given angle (indicated by its cosine, A.K.A. \"VL\").\n    // It only accounts for a portion of the sunlight that's lost during the scatter, which is irrespective of wavelength or density\n    float gamma_ray = get_fraction_of_rayleigh_scattered_light_scattered_by_angle(VL);\n    float gamma_mie = get_fraction_of_mie_scattered_light_scattered_by_angle(VL);\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3 beta_sum = h*(beta_ray + beta_mie + beta_abs);\n    vec3 beta_gamma = h*(beta_ray * gamma_ray + beta_mie * gamma_mie);\n    // number of iterations within the raymarch\n    float la = dot(V0,L);\n    float y  = dot(V0,normalize(cross(V,L)));\n    float y2 = y*y;\n    float zv2 = dot(V0,V0) - y2 - va*va;\n    float sigma; // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3 H = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    float R = 3.0*r; // some arbitrarily large number, technically the distance to the light source\n    float vl0 = va-la/VL; // \"vl0\" is the value of vi at which li=0\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    float v0, v1, dv;\n    float zl2, vi2, li;\n    float Fv0;\n    v0 = va;\n    v1 = vb;\n    dv = (v1 - v0) / STEP_COUNT;\n    Fv0 = F(v0*v0,y2+zv2,r);\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        vi2 = dv*dv*i*i + v0*v0 +2.0*dv*i*v0;\n        li = VL*(dv*i + v0-va) + la;\n        zl2 = vi2 + zv2 - li*li;\n        \n        float xla2 = max(r*r-y2-zl2, 0.0);\n        sigma =  F(vi2, y2+zv2,r) - Fv0\n              +  F(xla2,y2+zl2,r) * (1.0-sign(li))\n              + sign(li)*F(li*li, y2+zl2,r);\n\n        H += exp(r-sqrt(vi2+y2+zv2) - beta_sum*sigma) * dv;\n    }\n    v0 = vb;\n    v1 = vc;\n    dv = (v1 - v0) / STEP_COUNT;\n    Fv0 = F(v0*v0,y2+zv2,r);\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        vi2 = dv*dv*i*i + v0*v0 +2.0*dv*i*v0;\n        li = VL*(dv*i + v0-va) + la;\n        zl2 = vi2 + zv2 - li*li;\n        \n        float xla2 = max(r*r-y2-zl2, 0.0);\n        sigma =  Fv0 - F(vi2,y2+zv2,r) \n              +  F(xla2,y2+zl2,r) * (1.0-sign(li))\n              + sign(li)*F(li*li, y2+zl2,r);\n\n        H += exp(r-sqrt(vi2+y2+zv2) - beta_sum*sigma) * dv;\n    }\n    return H * beta_gamma;\n}\n\n\nvec3 get_rgb_fraction_of_distant_daylight_scattered_by_atmosphere(\n    vec3 view_origin, vec3 view_direction, float view_start_length, float view_stop_length,\n    vec3 world_position, float world_radius,\n    vec3 light_direction, float atmosphere_scale_height,\n    vec3 beta_ray, vec3 beta_mie, vec3 beta_abs\n){\n    // For an excellent introduction to what we're try to do here, see Alan Zucconi: \n    //   https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-3/\n    // We will be using most of the same terminology and variable names.\n    // GUIDE TO VARIABLE NAMES:\n    //  Uppercase letters indicate vectors.\n    //  Lowercase letters indicate scalars.\n    //  Going for terseness because I tried longhand names and trust me, you can't read them.\n    //  \"*v*\"    property of the view ray, the ray cast from the viewer to the object being viewed\n    //  \"*l*\"    property of the light ray, the ray cast from the object to the light source\n    //  \"y*\"     distance from the center of the world to the plane shared by view and light ray\n    //  \"z*\"     distance from the center of the world to along the plane shared by the view and light ray \n    //  \"r*\"     a distance (\"radius\") from the center of the world\n    //  \"h*\"     the atmospheric scale height, the distance at which air density reduces by a factor of e\n    //  \"*2\"     the square of a variable\n    //  \"*0\"     property at the start of the raymarch\n    //  \"*1\"     property at the end of the raymarch\n    //  \"*i\"     property during an iteration of the raymarch\n    //  \"d*\"     the change in a property across iterations of the raymarch\n    //  \"beta*\"  a scattering coefficient, the number of e-foldings in light intensity per unit distance\n    //  \"gamma*\" a phase factor, the fraction of light that's scattered in a certain direction\n    //  \"sigma*\" a column density ratio, the density of a column of air relative to surface density\n    //  \"F*\"     fraction of source light that reaches the viewer due to scattering for each color channel\n    //  \"*_ray\"  property of rayleigh scattering\n    //  \"*_mie\"  property of mie scattering\n    //  \"*_abs\"  property of absorption\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h = atmosphere_scale_height;\n    float r = world_radius / h;\n    vec3 V0 = (view_origin + view_direction * view_start_length - world_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - world_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float va = dot(V0,V);\n    float vc = dot(V1,V);\n    float vb = max(min(vc,0.0),va);\n    vec3 L = light_direction; // unit vector pointing to light source\n    float VL = dot(V,L);\n    // \"gamma_*\" indicates the fraction of scattered sunlight that scatters to a given angle (indicated by its cosine, A.K.A. \"VL\").\n    // It only accounts for a portion of the sunlight that's lost during the scatter, which is irrespective of wavelength or density\n    float gamma_ray = get_fraction_of_rayleigh_scattered_light_scattered_by_angle(VL);\n    float gamma_mie = get_fraction_of_mie_scattered_light_scattered_by_angle(VL);\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3 beta_sum = h*(beta_ray + beta_mie + beta_abs);\n    vec3 beta_gamma = h*(beta_ray * gamma_ray + beta_mie * gamma_mie);\n    // number of iterations within the raymarch\n    float la = dot(V0,L);\n    float y  = dot(V0,normalize(cross(V,L)));\n    float y2 = y*y;\n    float zv2 = dot(V0,V0) - y2 - va*va;\n    float sigma; // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3 H = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    float R = 3.0*r; // some arbitrarily large number, technically the distance to the light source\n    float vl0 = va-la/VL; // \"vl0\" is the value of vi at which li=0\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    float v0, v1, dv;\n    float zl2, vi2, li;\n    float Fv0;\n    v0 = va;\n    v1 = vb;\n    dv = (v1 - v0) / STEP_COUNT;\n    Fv0 = F(v0*v0, y2+zv2, r);\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        vi2 = dv*dv*i*i + v0*v0 +2.0*dv*i*v0;\n        li = VL*(dv*i + v0-va) + la;\n        zl2 = vi2 + zv2 - li*li;\n        \n        float xla2 = max(r*r-y2-zl2, 0.0);\n        sigma =  F(vi2, y2+zv2,r) - Fv0 \n              +  F(xla2,y2+zl2,r) * (1.0-sign(li))\n              + sign(li)*F(li*li, y2+zl2,r);\n\n        H += exp(r-sqrt(vi2+y2+zv2) - beta_sum*sigma) * dv;\n    }\n    v0 = vb;\n    v1 = vc;\n    dv = (v1 - v0) / STEP_COUNT;\n    Fv0 = F(v0*v0, y2+zv2, r);\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        vi2 = dv*dv*i*i + v0*v0 +2.0*dv*i*v0;\n        li = VL*(dv*i + v0-va) + la;\n        zl2 = vi2 + zv2 - li*li;\n        \n        float xla2 = max(r*r-y2-zl2, 0.0);\n        sigma =  Fv0 - F(vi2,y2+zv2,r) \n              +  F(xla2,y2+zl2,r) * (1.0-sign(li))\n              + sign(li)*F(li*li, y2+zl2,r);\n\n        H += exp(r-sqrt(vi2+y2+zv2) - beta_sum*sigma) * dv;\n    }\n    return H * beta_gamma;\n}\n\n\nvec3 get_rgb_fraction_of_light_transmitted_through_atmosphere(\n    in vec3 view_origin, in vec3 view_direction, in float view_start_length, in float view_stop_length,\n    in vec3 world_position, in float world_radius, in float atmosphere_scale_height,\n    in vec3 beta_ray, in vec3 beta_mie, in vec3 beta_abs\n){\n    float h = atmosphere_scale_height;\n    float r = world_radius / h;\n    vec3 V0 = (view_origin + view_direction * view_start_length - world_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - world_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float v0 = dot(V0,V);\n    float v1 = dot(V1,V);\n    float zv2 = dot(V0,V0) - v0*v0;\n    vec3 beta_sum = (beta_ray + beta_mie + beta_abs)*h;\n    float sigma = approx_air_column_density_ratio_through_atmosphere(v0,v1,zv2,r);\n    return exp(-sigma * beta_sum);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float SCALE_HEIGHT = 7994.0*METER;\n    \n    // world\n    float earth_radius = 6360e3/SCALE_HEIGHT;      // surface of the world\n    float atmo_radius = earth_radius+100.0;   // \"top\" of the atmosphere\n    vec3 earth_origin = vec3(0,0,0);  // center of the world\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;    \n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,\n                                            0,0.3,0,0,\n                                            0,0,0,-1,\n                                            0,0,-1,1));\n                                            \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace = vec2(\n        0.5*(mod(4.0 * screenspace.x, 2.0) - 1.0), \n        2.0 * screenspace.y - 1.0\n    );\n    \n    mat4  view_matrix_inverse;\n    bool IS_FIRST_PERSON_POV = screenspace.x > 0.5;\n    if(IS_FIRST_PERSON_POV){\n        float altitude = 100.0/SCALE_HEIGHT;\n        vec3 position = normalize(vec3(0.0,0.0, -1.0))*(earth_radius+altitude);\n        vec3 up    = normalize(-position);\n        vec3 right = vec3(1,0,0);\n        vec3 front = normalize(cross(up, right));\n        view_matrix_inverse = \n            get_translation_matrix(-position) *\n            get_rotation_matrix(up, 1.2*PI+3.0*PI*mouse.x) * \n            get_rotation_matrix(right,0.1*PI-PI/4.0*mouse.y) * \n            inverse(mat4(vec4(right,0), vec4(up,0), vec4(front,0), vec4(0,0,0,1)));\n    } else {\n        view_matrix_inverse = \n            get_rotation_matrix(vec3(0,1,0), 6.3*mouse.x) * \n            get_rotation_matrix(vec3(1,0,0), PI/2.0+PI*mouse.y) *\n            get_translation_matrix(vec3(0,0,6.0*earth_radius)) *\n            mat4(1);\n    }\n    \n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz;\n\n    vec3  I =   solve_rgb_intensity_of_light_emitted_by_black_body(SOLAR_TEMPERATURE) \n              * get_surface_area_of_sphere(SOLAR_RADIUS) / get_surface_area_of_sphere(1.*ASTRONOMICAL_UNIT); // intensity of incoming light for each color channel\n    vec3  E = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    \n    // view ray\n    vec3 V0 = view_origin;\n    vec3 V  = view_direction;\n    vec3 Vi = V0;            // point along view ray\n    \n    \n    // light ray\n    //vec3 L  = normalize(vec3(1,0,0)); // static\n    vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.87*PI+0.2*PI*sin(1.0*iTime)) * // rotation of the earth\n               //get_rotation_matrix(vec3(0,0,1), -PI*23.4/180.) * // axial tilt\n               vec4(1,0,0,1)).xyz;\n    // realistic\n    //vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.1*iTime) * vec4(1,0,0,1)).xyz;\n\n    // \"beta_*\" is the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio\n    vec3  beta_ray_air   = vec3(5.20e-6, 1.21e-5, 2.96e-5) * SCALE_HEIGHT;\n    vec3  beta_mie_air   = vec3(1e-6)*SCALE_HEIGHT;\n    vec3  beta_abs_air   = vec3(0);\n\n    \n    \n    maybe_vec2 world = get_distances_along_3d_line_to_sphere(V0, V, earth_origin, atmo_radius);\n    maybe_vec2 ground = get_distances_along_3d_line_to_sphere(V0, V, earth_origin, earth_radius);\n    maybe_vec2 daylight = get_distances_along_3d_line_to_capsule(V0, V, earth_origin, earth_origin+L*100.0, earth_radius);\n    maybe_vec2 shadow = get_distances_along_3d_line_to_capsule(V0, V, earth_origin, earth_origin-L*100.0, earth_radius);\n    \n    maybe_vec2 world_ahead = get_bounding_distances_along_ray(world);\n    maybe_vec2 air_ahead = get_distances_along_line_to_negation(world_ahead, ground);\n    maybe_vec2 shadow_ahead = get_bounding_distances_along_ray(shadow);\n    \n    maybe_vec2 illuminated_air_ahead = get_distances_along_line_to_negation(air_ahead, shadow);\n    maybe_vec2 unilluminated_air_ahead = get_distances_along_line_to_intersection(air_ahead, shadow);\n    \n    maybe_vec2 daylight_air_ahead = get_distances_along_line_to_intersection(illuminated_air_ahead, daylight);\n    maybe_vec2 twilight_air_ahead = get_distances_along_line_to_negation(illuminated_air_ahead, daylight);\n    \n    maybe_float ground_edge_ahead = get_nearest_distance_along_ray(ground);\n    \n    if(!world_ahead.exists) \n    { \n        // nothing to see here folks, move along\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if(ground_edge_ahead.exists){\n        vec3 Vt = V0+V*(ground_edge_ahead.value-0.001);\n        maybe_vec2 world_along_light_ray = get_distances_along_3d_line_to_sphere(Vt, L, earth_origin, atmo_radius);\n        maybe_vec2 ground_along_light_ray = get_distances_along_3d_line_to_sphere(Vt, L, earth_origin, earth_radius);\n        \n        maybe_vec2 world_ahead_along_light_ray = get_bounding_distances_along_ray(world_along_light_ray);\n        maybe_vec2 air_ahead_along_light_ray = get_distances_along_line_to_negation(world_ahead_along_light_ray, ground_along_light_ray);\n        \n        vec3 I_surface = I;\n        if (air_ahead_along_light_ray.exists)\n        {\n            I_surface *= get_rgb_fraction_of_light_transmitted_through_atmosphere(Vt,L, air_ahead_along_light_ray.value.x, air_ahead_along_light_ray.value.y, earth_origin, earth_radius, 1.0, beta_ray_air, beta_mie_air, beta_abs_air);\n        }\n        \n        vec3 N = get_surface_normal_of_point_near_sphere(Vt, earth_origin);\n        vec3 H = normalize(L-V);\n        float NV = max(dot(N,-V), 0.);\n        float NL = max(dot(N, L), 0.);\n        float NH = max(dot(N, H), 0.);\n        float HV = max(dot(H,-V), 0.);\n        float VL = max(dot(L,-V), 0.);\n        vec3 E_surface_ambient = vec3(1e-3); // surface ambient light\n        vec3 F_surface_diffuse = vec3(0.0,0.01,0.1); // diffuse surface color\n        \n        E += E_surface_ambient;\n        if (NL > 0.) //!world_along_light_ray.exists \n        {\n            const vec3 F0  = vec3(0.04); // NOTE: \"0.04\" is a representative value for plastics and other diffuse reflectors\n            const float m = 3.0;\n            vec3 F_reflected = get_fraction_of_light_reflected_from_material(NL,NH,NV, HV, m,F0);\n            vec3 E_surface_reflected = I_surface * NL * F_reflected;\n            vec3 I_surface_refracted = I_surface * NL * (1. - F_reflected);\n            vec3 E_surface_refracted = I_surface_refracted * F_surface_diffuse;\n            E += E_surface_reflected + E_surface_refracted;\n        }\n    }\n    \n/*\n*/\n    \n/*\n    if(air_ahead.exists)\n    {\n        E *= get_rgb_fraction_of_light_transmitted_through_atmosphere(\n            V0,V, air_ahead.value.x,  air_ahead.value.y,  \n            earth_origin, earth_radius, 1.0, \n            beta_ray_air, beta_mie_air, beta_abs_air);\n    }\n*/\n    \n    vec3 E_scatter = vec3(0.0); \n    \n/*\n    if(twilight_air_ahead.exists) {\n        E_scatter += \n           I * get_rgb_fraction_of_distant_twilight_scattered_by_atmosphere(\n                V0, V, twilight_air_ahead.value.x,  twilight_air_ahead.value.y,  \n                earth_origin, earth_radius, L, 1.0, \n                beta_ray_air, beta_mie_air, beta_abs_air\n              );\n    }\n*/\n\n/*\n    if(daylight_air_ahead.exists) {\n        E_scatter += \n           I * get_rgb_fraction_of_distant_daylight_scattered_by_atmosphere(\n                V0, V, daylight_air_ahead.value.x,  daylight_air_ahead.value.y,  \n                earth_origin, earth_radius, L, 1.0, \n                beta_ray_air, beta_mie_air, beta_abs_air\n              ); \n    }\n*/\n    if(illuminated_air_ahead.exists) {\n        E_scatter += \n           I * get_rgb_fraction_of_distant_daylight_scattered_by_atmosphere(\n                V0, V, illuminated_air_ahead.value.x,  illuminated_air_ahead.value.y,  \n                earth_origin, earth_radius, L, 1.0, \n                beta_ray_air, beta_mie_air, beta_abs_air\n              ); \n    }\n/*\n*/\n    \n/*\n    if(unilluminated_air_ahead.exists) {\n        E_scatter *=\n            get_rgb_fraction_of_light_transmitted_through_atmosphere(\n                V0,V, unilluminated_air_ahead.value.x, unilluminated_air_ahead.value.y, \n                earth_origin, earth_radius, 1.0, beta_ray_air, beta_mie_air, beta_abs_air); \n    }\n*/\n    \n    E += E_scatter;\n       \n    /*\n        E.r += 10000. * (shadow_along_view_ray.exists? 1.0:0.0);\n        E.b += 10000. * (air_along_view_ray.exists? 1.0:0.0);\n        E.r += 10000. * (illuminated_air_along_view_ray.exists? 1.0:0.0);\n        E.g += 10000. * (shadow_along_view_ray.exists? 1.0:0.0);\n    */\n    //fragColor = world_along_view_ray.exists? vec4(vec3(1),1) : vec4(vec3(0),1);\n    float exposure_intensity = 15.; // Watts/m^2\n    vec3  ldr_tone_map = 1.0 - exp(-E/exposure_intensity);\n\n    fragColor = vec4(get_rgb_signal_of_rgb_intensity(ldr_tone_map), 1);\n    //if((E.x==0.)){fragColor.x = 1.0;} else {fragColor.x=0.0;}\n\n}","name":"Image","description":"","type":"image"}]}