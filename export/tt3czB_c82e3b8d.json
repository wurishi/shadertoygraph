{"ver":"0.1","info":{"id":"tt3czB","date":"1609443160","viewed":101,"name":"Metallic Metaballs","username":"Tarquin","description":"Raymarching metaballs with Blinn-Phong lighting + hard/soft shadows + AO + reflections + cubemap.\nUse UP an DOWN arrows get closer or farther.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","metaballs","cubemap","reflections","metallic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Arthur Jacquin - 2020\n// https://www.linkedin.com/in/arthur-jacquin-631921153/\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Constants\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n\n//Raymarching parameters\n#define MAX_STEPS 300\n#define MAX_DIST 100.\n#define ACCURACY .001\n#define SPHERE_SMOOTHING 0.5\n\n//Shadows parameters\n#define SHADOW_INTENSITY 1.0\n#define MIN_SHADOW_DISTANCE 0.1\n#define MAX_SHADOW_DISTANCE 50.0\n#define SHADOW_PENUMBRA 75.0\n\n//Ambiant occlusion parameters\n#define AO_INTENSITY 0.25\n#define AO_ITERATIONS 3\n#define AO_STEPSIZE 0.2\n\n//Material parameters\n#define MATERIAL_SHININESS 100.0\n\n//Reflections parameters\n#define REFLECTION_COUNT 2\n#define REFLECTIONS_INTENSITY 0.7\n#define ENV_REFLECTIONS_INTENSITY 0.1\n\n//Buffer\n#define CAMERA_POSITION 1\n\n//Directional light\nstruct DirectionalLight{\n    vec3 dir;\n    vec3 color;\n    float intensity;\n};\n\nstruct Sphere{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\n\nconst int sphereCount = 8;\nSphere spheres[] = Sphere[sphereCount](\n    Sphere(vec3(0., 0., 0.), 10.0, vec3(0.666, 0.662, 0.678)),\n    Sphere(vec3(0., 0., 0.), 6.0, vec3(0.666, 0.662, 0.678)),\n    Sphere(vec3(0., 0., 0.), 5.0, vec3(0.666, 0.662, 0.678)),\n    Sphere(vec3(0., 0., 0.), 4.0, vec3(0.666, 0.662, 0.678)),\n    Sphere(vec3(0., 0., 0.), 4.5, vec3(0.666, 0.662, 0.678)),\n    Sphere(vec3(0., 0., 0.), 4.0, vec3(0.666, 0.662, 0.678)),\n    Sphere(vec3(0., 0., 0.), 3.5, vec3(0.666, 0.662, 0.678)),\n    Sphere(vec3(0., 0., 0.), 3.0, vec3(0.666, 0.662, 0.678))\n);\n\n// Retrieve value from BufferA.\nvec4 getValue(int a)\n{\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return texture(iChannel1, q);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Union smooth\nvec4 opUS(vec4 d1, vec4 d2, float k) \n{\n\tfloat h = clamp(0.5 + 0.5*(d2.w - d1.w) / k, 0.0, 1.0);\n\tvec3 color = mix(d2.rgb, d1.rgb, h);\n\tfloat dist = mix(d2.w, d1.w, h) - k * h * (1.0 - h);\n\n\treturn vec4(color, dist);\n}\n\n//Y rotation\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925 * degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n\n    return vec3(cosY * v.x - sinY * v.z, v.y, sinY * v.x + cosY * v.z);\n}\n\n//Distance\nvec4 Map(vec3 p) \n{\n    //Rotation\n    float s = 0.3;\n    vec3 pos = spheres[0].pos + vec3(1. * sin(iTime * s), 2. * sin(iTime * s), 0.5 * cos(iTime * s));\n    \n    //first sphere\n    vec4 result = vec4(spheres[0].col, sdSphere(p - pos, spheres[0].r));\n\n    for(int i = 1; i < sphereCount; i++)\n    {\n        //Rotation\n        s = min(float(i) * 0.3 * spheres[i].r * 0.1, 1.5);\n        pos = spheres[i].pos + vec3(2. * float(i) * sin(iTime * s), 3. * float(i) * sin(iTime * s), 1.5 * float(i) * cos(iTime * s));\n        //Scale\n        float size = spheres[i].r + 3. * (0.5 + 0.5 * sin(2. * PI * iTime * 0.3 + (p.y - spheres[i].pos.y) / 3.));\n\n        //Distance\n        vec4 newSphere = vec4(spheres[i].col, sdSphere(RotateY(p, 45.0 * float(i)) - pos, spheres[i].r));\n\n        result = opUS(result, newSphere, SPHERE_SMOOTHING * float(i));\n    }\n\n    return result;\n}\n\n//Normal\nvec3 GetNormal(vec3 p)\n{ \n    float d = Map(p).w; // Distance\n    vec2 e = vec2(.01, 0.0); // Epsilon\n    vec3 n = d - vec3(\n    Map(p-e.xyy).w,\n    Map(p-e.yxy).w,\n    Map(p-e.yyx).w);\n \n    return normalize(n);\n}\n\n//Hard shadows\nfloat HardShadows(vec3 ro, vec3 rd)\n{\n    for (float dO = MIN_SHADOW_DISTANCE; dO < MAX_SHADOW_DISTANCE;)\n    {\n        vec3 p = ro + rd * dO;\n        float h = Map(p).w;\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n\n        dO += h;\n    }\n\n    return 1.0;\n}\n\n//Soft shadows\nfloat SoftShadows(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    for(float t = MIN_SHADOW_DISTANCE; t < MAX_SHADOW_DISTANCE;)\n    {\n        float h = Map(ro + rd * t).w;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, SHADOW_PENUMBRA * h / t );\n        t += h;\n    }\n    return res;\n}\n\n//Ambiant occlusion\nfloat AmbiantOcclusion(vec3 p, vec3 n)\n{\n    float ao = 0.0;\n    float d;\n\n    for (int i = 1; i <= AO_ITERATIONS; i++)\n    {\n        d = AO_STEPSIZE * float(i);\n        ao += max(0.0, (d - Map(p + n * d).w) / d);\n    }\n\n    return (1.0 - ao * AO_INTENSITY);\n}\n\n//Calculate all the lighting, shadows and ambiant occlusion\nvec3 Shading(vec3 p, vec3 N, vec3 camPos, vec3 objCol)\n{\n    //Lights\n    DirectionalLight light = DirectionalLight(vec3(1.0, -0.5, 1.0), vec3(1.0, 0.9961, 1.0), 0.9);\n    \n    vec3 lightingCol;\n    \n    //Ambiant\n    vec3 K_a = vec3(0.2, 0.2, 0.2); //Ambiant color\n    vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    lightingCol = ambientLight * K_a;\n    \n    //Blinn Phong\n    vec3 L = normalize(-light.dir);\n    float LdotN = dot(L, N);\n\n    if (LdotN >= 0.0) //Light visible from this point on the surface\n    {       \n        vec3 V = normalize(camPos - p);\n        vec3 R = normalize(reflect(-L, N));\n        float RdotV = dot(R, V);\n        \n        if (RdotV < 0.0) \n        {\n            // Light reflection in opposite direction as viewer, apply only diffuse\n            // component\n            lightingCol += light.color * LdotN * light.intensity;\n        }\n        else\n        {\n            //Specular color\n            lightingCol += light.intensity * (light.color * LdotN + light.color * pow(RdotV, MATERIAL_SHININESS));\n        }\n    }\n\n    //Shadow\n    //float shadows = HardShadows(p, -light.dir);\n    float shadows = SoftShadows(p, -light.dir);\n    \n    float ao = AmbiantOcclusion(p, N);\n\n    return objCol * lightingCol * shadows * ao;\n}\n\n// Forked from: https://www.shadertoy.com/view/MsXGz4\nvec3 Cubemap(in vec2 q, in vec2 mo) {\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\t\n    // camera\n\tfloat an1 = -6.2831 * (mo.x + 0.25);\n\tfloat an2 = clamp( (1.0-mo.y) * 2.0, 0.0, 2.0 );\n    vec3 ro = 2.5 * normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));\n    vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww ));\n    vec3 vv = normalize(cross(ww, uu));\n    return normalize( p.x * uu + p.y * vv + 1.4 * ww );\n}\n\n//Raymarching\nbool RayMarch(vec3 ro, vec3 rd, float maxDist, int maxSteps, inout vec3 p, inout vec4 obj) \n{\n  float dO = 0.; //Distane Origin\n  vec3 col = vec3(0.0, 0.0, 0.0);\n  \n  //Raymarch steps\n  for(int i = 0; i < maxSteps; i++)\n  {\n    //Step along the ray\n    p = ro + rd * dO;\n    \n    vec4 ds = Map(p); //Calculate new distance\n    \n    //Hit or out of range\n    if(dO > maxDist || ds.w < ACCURACY) \n    { \n        col = ds.xyz; //Set color\n        break;\n    }\n    \n    dO += ds.w; //Set new distance\n  }\n\n  obj = vec4(col, dO);\n  return obj.w < MAX_DIST;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UV corrections\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Rotation\n    vec2 m = vec2(0.0, 0.0);\n    m.x += 1.;\n    float nRotate = iTime * 0.05;\n    float h  = PI * (m.x - nRotate);\n    float e  = mix(0.0, 2.5, m.y); // eye\n\n    //Raymarching\n    vec3 camPos = texture(iChannel1, vec2(0)).xyz;\n    vec3 ro = camPos + vec3(sin(h) * cos(e), sin(e), cos(h) * cos(e)); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0)); // Ray Direction\n    \n    vec4 obj; //Color and distance of the object hit\n    vec3 hitPos; //Hit position\n    bool hit = RayMarch(ro, rd, MAX_DIST, MAX_STEPS, hitPos, obj); // Distance\n    \n    //Object hit\n    if(hit)\n    {\n        vec3 N = GetNormal(hitPos);\n        vec3 S = Shading(hitPos, N, ro, obj.xyz);\n        vec4 col = vec4(S, 1.0);\n        vec3 dir = normalize(reflect(rd, N));\n        col += texture(iChannel0, dir) * ENV_REFLECTIONS_INTENSITY;\n        \n        //Reflections\n        for(int i = 1; i < REFLECTION_COUNT + 1; i++)\n        {\n            rd = normalize(reflect(rd, N));\n            ro = hitPos + (rd * 0.01);\n            hit = RayMarch(ro, rd, MAX_DIST / (float(i) * 2.0), MAX_STEPS / i * 2, hitPos, obj);\n\n            if (hit)\n            {\n                N = GetNormal(hitPos);\n                S = Shading(hitPos, N, ro, obj.xyz);\n                col += vec4(S * REFLECTIONS_INTENSITY, 0);\n            }\n            else\n            {\n                break;\n            }\n        }\n        \n        fragColor = col;\n    }\n    else //Background\n    {\n        vec2 q = fragCoord.xy / iResolution.xy;\n        vec3 dir = Cubemap(q, iResolution.xy * 0.5 / iResolution.xy);\n        vec3 col = texture(iChannel0, dir).rgb;\n        col *= 0.25 + 0.75 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15 );\n        fragColor = vec4(col, 1.0);\n    }   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer for keyboard inputs\n\n#define KEY_UP    38\n#define KEY_DOWN  40\n\nbool GetKey(int keyCode) \n{\n    return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x != 0.0;\n}\n\n//Y rotation\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925 * degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n\n    return vec3(cosY * v.x - sinY * v.z, v.y, sinY * v.x + cosY * v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos;\n    \n    if(iFrame == 0)//Init cam pos\n    {\n        camPos = vec3(0., 0., -25.);\n    }\n    else //Move cam\n    {\n        camPos = texture(iChannel0, vec2(0)).xyz;\n        \n        float speed = iTimeDelta * 10.0;\n        camPos += normalize(-camPos) * speed * texelFetch( iChannel1, ivec2(KEY_UP, 0), 0).x;\n        camPos += normalize(camPos) * speed * texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0).x;\n    \n    }\n    \n    fragColor = vec4(camPos, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}