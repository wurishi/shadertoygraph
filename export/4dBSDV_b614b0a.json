{"ver":"0.1","info":{"id":"4dBSDV","date":"1460516495","viewed":576,"name":"The dark side of the moon","username":"bytewave","description":"The dark side of the moon","likes":28,"published":1,"flags":32,"usePreview":0,"tags":["thedarksideofthemoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec4 t = texture(iChannel0,uv);\n\tfragColor = t;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat crosss( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = crosss( g, f );\n    float k1 = crosss( e, f ) + crosss( h, g );\n    float k0 = crosss( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)/(2.0*k2);\n    float v2 = (-k1 + w)/(2.0*k2);\n    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\nfloat Maskline(float pos,float lineNumber)\n{    \n  return step(pos,0.1428571428571429 * lineNumber) - (step(pos,0.1428571428571429 * (lineNumber - 1.)));\n}\n\nvec3 GetRainbowColor(float i)\n{\n    //Step Violet\n    vec3 Violet = \tvec3(0.57,0.0, 1.0) \t*  Maskline(i,7.);\n    vec3 Purple = \tvec3(0.27,0.0, 0.51)\t*  Maskline(i,6.);\n    vec3 blue \t=\tvec3(0.0, \t0.0, 1.0) \t*  Maskline(i,5.);\n \tvec3 Green\t=\tvec3(0.0, \t1.0, 0.0) \t*  Maskline(i,4.);\n \tvec3 Yellow =\tvec3(1.0, \t1.0, 0.0) \t*  Maskline(i,3.);\n\tvec3 Orange =\tvec3(1.0, \t0.5, 0.0) \t*  Maskline(i,2.);\n \tvec3 Red\t=\tvec3(1.0, \t0.0, 0.0) \t*  Maskline(i,1.);\n    return Violet + Purple + blue + Green + Yellow + Orange + Red;\n}\n\nvec3 SmoothRainbowColor(float i)\n{\n    i *= 0.1428571428571429 * 6.;\n    float gradinStep = mod(i,0.1428571428571429) * 7.;    \n    vec3 firstColor = GetRainbowColor(i);\n    vec3 NextColor = GetRainbowColor(i + 0.1428571428571429);    \n    return mix(firstColor,NextColor, gradinStep);\n}\n\nvec2 rot(vec2 uv,float a)\n{\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nfloat SharpTri(vec2 pos, float radius,float angle)\n{    \n    float third = 1.0471975511965977461542144610932;\n    float offsetRotation = radius * 0.5 ;    \n    vec2 uv1 = rot(pos , angle);\n\tfloat v = step(radius , radius - uv1.y - offsetRotation );\n    vec2 uv2 = rot(pos , third * 2. + angle);\n    float v2 = step(radius , radius - uv2.y - offsetRotation );\n    vec2 uv3 = rot(pos , third * 4. + angle);    \n    float v3 = step(radius , radius - uv3.y - offsetRotation );    \n    v = 1. - (v + v2 + v3);\n    return clamp(v,0.,1.);\n}\n\nfloat SmoothTri(vec2 pos, float radius,float angle)\n{    \n    angle += 3.14159;\n    float third = 1.0471975511965977461542144610932;\n    float offsetRotation = radius * 0.5 ;    \n    vec2 uv1 = rot(pos , angle);\n\tfloat v = max(radius - uv1.y - offsetRotation,0.);\n    vec2 uv2 = rot(pos , third * 2. + angle);\n    float v2 = max(radius - uv2.y - offsetRotation,0.);\n    vec2 uv3 = rot(pos , third * 4. + angle);    \n    float v3 = max(radius - uv3.y - offsetRotation,0.);    \n    v = pow((v * v2 * v3),.26) * 18.;\n    return clamp(v,0.,1.);\n}\n\n////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    uv -= vec2(0.5,0.25);    \n    //uv += sin(uv.x * 20. + iTime) * 0.02;\n   // uv += sin(uv.x * 120. + iTime) * 0.005;\n    \n    // Prism\n    float t = SharpTri(uv , 0.152, 0.);\n    float st = SmoothTri(uv , .14, 0.);\n    float sto = SmoothTri(uv , .1519, 0.);\n    vec3 colo =  vec3(0.1,0.15,0.17);\n    vec3 prism = (t - (st * 0.8) ) * colo * 4. + (sto - st);\n    \n    // Beam in\n    float beamMask = max(1. - sign( rot(uv,1.).y ),0.);\n    float beam = clamp ((1. - sign(pow (abs(0.1 - rot(uv + vec2(0.,-0.18),1.35).x ) , .12) - 0.5 )) * beamMask,0.,1.);\n    \n    // Beam in prism\n    float GradBeamInPrism = clamp (1. - (( rot(uv,-0.5).x + 0.05) * 8.),0.,1.);\n    float BeamInPrismMask = ((max(sign(rot(uv + vec2(0.,-0.053),.22).y) ,0.)));\n    BeamInPrismMask -= 1. - sign(rot(uv + vec2(0.,-0.08),1.35).x);\n    BeamInPrismMask *= clamp(t,0.,1.);    \n    float beamInPrism = clamp( BeamInPrismMask ,0.,1.) * GradBeamInPrism;\n    \n    // Rainbow\n    float RainbowMask = clamp(sign(rot(uv + vec2(0.,-0.0918),1.72).x)  ,0.,1.);\n    RainbowMask -= clamp( sign(rot(uv + vec2(0.,-0.058),1.86).x)  , 0.,1.);\n    RainbowMask *= 1. - t;    \n    RainbowMask = clamp(RainbowMask,0.,1.);\n    RainbowMask *= sign(uv.x) * 10.;\n    \n    vec2 p0 = vec2(0.065,0.033);\n    vec2 p1 = vec2(0.83,-0.2);\n    vec2 p2 = vec2(0.9,-0.015);\n    vec2 p3 = vec2(0.031,0.095);\n    \n    vec2 uvRainBow = invBilinear(uv,p0,p1,p2,p3);\n    \n    //fragColor = vec4(uvRainBow,0.,1.);\n    \n    vec3 RainbowColor = SmoothRainbowColor(1. - uvRainBow.y ) * .4;\n    vec3 compo = clamp(prism + beam ,0.,1.) + beamInPrism + ( RainbowColor);    \n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    float f = (sin(iTime * 0.2) * 0.5 + 0.5) * 20.;\n    float a = 0.001 ;\n    \n    if(iTime > 4.)\n    {\n    uv2.x -= sin((uv2.y - (iTime * 0.041)) * f) * a;\n    uv2.y -= sin((uv2.x - (iTime * 0.041)) * f) * a;\n       uv2 -= 0.0021; \n    }\n    \n    vec4 thisImage = texture(iChannel0,uv2 );\n    thisImage.x+= 0.0008;\n    thisImage.z-= 0.0008;\n    \n        \n\tfragColor = vec4(((thisImage.xyz * 0.97 ) ) + compo * 0.1,1.0) ;\n}","name":"Buf A","description":"","type":"buffer"}]}