{"ver":"0.1","info":{"id":"MlsyD4","date":"1504903201","viewed":241,"name":"Quiver plot","username":"rougier","description":"Quiver plot. Better in fullscreen. Move the mouse.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","quiver","arrows","msg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 filled(float distance, float linewidth, float antialias, vec4 fill, vec4 bg)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    else\n        // Outside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            frag_color = bg;\n        else // Line stroke exterior border\n            frag_color = mix(bg, fill, alpha);\n\n    return frag_color;\n}\n\n// Computes the signed distance from a line\nfloat line_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    return dot(rel_p, vec2(dir.y, -dir.x));\n}\n\n// Computes the signed distance from a line segment\nfloat segment_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n    float dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n    return max(dist1, dist2);\n}\n\n// Computes the center with given radius passing through p1 & p2\nvec4 circle_from_2_points(vec2 p1, vec2 p2, float radius)\n{\n    float q = length(p2-p1);\n    vec2 m = (p1+p2)/2.0;\n    vec2 d = vec2( sqrt(radius*radius - (q*q/4.0)) * (p1.y-p2.y)/q,\n                   sqrt(radius*radius - (q*q/4.0)) * (p2.x-p1.x)/q);\n    return  vec4(m+d, m-d);\n}\n\nfloat arrow_curved(vec2 texcoord,\n                   float body, float head,\n                   float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    vec2 p1 = end - head*vec2(+1.0,+height);\n    vec2 p2 = end - head*vec2(+1.0,-height);\n    vec2 p3 = end;\n\n    // Head : 3 circles\n    vec2 c1  = circle_from_2_points(p1, p3, 1.25*body).zw;\n    float d1 = length(texcoord - c1) - 1.25*body;\n    vec2 c2  = circle_from_2_points(p2, p3, 1.25*body).xy;\n    float d2 = length(texcoord - c2) - 1.25*body;\n    vec2 c3  = circle_from_2_points(p1, p2, max(body-head, 1.0*body)).xy;\n    float d3 = length(texcoord - c3) - max(body-head, 1.0*body);\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    // Outside (because of circles)\n    if( texcoord.y > +(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.y < -(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.x < -(body/2.0 + antialias) )\n         return 1000.0;\n    if( texcoord.x > c1.x ) //(body + antialias) )\n         return 1000.0;\n\n    return min( d4, -min(d3,min(d1,d2)));\n}\n\nfloat arrow_triangle(vec2 texcoord,\n                     float body, float head, float height,\n                     float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n\n    // Head : 3 lines\n    float d1 = line_distance(texcoord, end, end - head*vec2(+1.0,-height));\n    float d2 = line_distance(texcoord, end - head*vec2(+1.0,+height), end);\n    float d3 = texcoord.x - end.x + head;\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    float d = min(max(max(d1, d2), -d3), d4);\n    return d;\n}\n\nfloat arrow_triangle_90(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 1.0, linewidth, antialias);\n}\n\nfloat arrow_triangle_60(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 0.5, linewidth, antialias);\n}\n\nfloat arrow_triangle_30(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_triangle(texcoord, body, head, 0.25, linewidth, antialias);\n}\n\nfloat arrow_angle(vec2 texcoord,\n                  float body, float head, float height,\n                  float linewidth, float antialias)\n{\n    float d;\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n\n    // Arrow tip (beyond segment end)\n    if( texcoord.x > body/2.0) {\n        // Head : 2 segments\n        float d1 = line_distance(texcoord, end, end - head*vec2(+1.0,-height));\n        float d2 = line_distance(texcoord, end - head*vec2(+1.0,+height), end);\n        // Body : 1 segment\n        float d3 = end.x - texcoord.x;\n        d = max(max(d1,d2), d3);\n    } else {\n        // Head : 2 segments\n        float d1 = segment_distance(texcoord, end - head*vec2(+1.0,-height), end);\n        float d2 = segment_distance(texcoord, end - head*vec2(+1.0,+height), end);\n        // Body : 1 segment\n        float d3 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n        d = min(min(d1,d2), d3);\n    }\n    return d;\n}\n\nfloat arrow_angle_90(vec2 texcoord,\n                     float body, float head,\n                     float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 1.0, linewidth, antialias);\n}\n\nfloat arrow_angle_60(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 0.5, linewidth, antialias);\n}\n\nfloat arrow_angle_30(vec2 texcoord,\n                        float body, float head,\n                        float linewidth, float antialias)\n{\n    return arrow_angle(texcoord, body, head, 0.25, linewidth, antialias);\n}\n\n\nfloat arrow_stealth(vec2 texcoord,\n                    float body, float head,\n                    float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    // Head : 4 lines\n    float d1 = line_distance(texcoord, end-head*vec2(+1.0,-height),\n                                       end);\n    float d2 = line_distance(texcoord, end-head*vec2(+1.0,-height),\n                                       end-vec2(3.0*head/4.0,0.0));\n    float d3 = line_distance(texcoord, end-head*vec2(+1.0,+height), end);\n    float d4 = line_distance(texcoord, end-head*vec2(+1.0,+0.5),\n                                       end-vec2(3.0*head/4.0,0.0));\n\n    // Body : 1 segment\n    float d5 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    return min(d5, max( max(-d1, d3), - max(-d2,d4)));\n}\n\n// Position jitter (see comments)\n#define srnd(p)  (2.* fract(sin(p*mat2(12.9898, 78.233,1,-47.14))* 43758.5453) -1. )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float M_PI = 3.14159265358979323846;\n    const float SQRT_2 = 1.4142135623730951;\n    const float linewidth = 3.0;\n    const float antialias =  1.0;\n\n    const float rows = 48.0;\n    const float cols = 48.0;\n    float body = min(iResolution.x/cols, iResolution.y/rows) / SQRT_2;\n    vec2 texcoord = gl_FragCoord.xy;\n    vec2 size   = iResolution.xy / vec2(cols,rows);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n\n    // Position jitter (see comments)\n    center += .2*size* srnd(center);\n\n    texcoord -= center;\n\n    // float theta = M_PI/3.0 + 0.1*(center.x / cols + center.y / rows);\n    \n    // vec2 mouse = iMouse.xy;\n    vec2 mouse = iResolution.xy*(.5+.5*vec2(.75*cos(iTime)+.25*sin(0.33*iTime),\n                                             .75*sin(iTime)+.25*cos(1.27*iTime)));\n    \n    float theta = M_PI-atan(center.y-mouse.y,  center.x-mouse.x);\n\n    \n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    texcoord = vec2(cos_theta*texcoord.x - sin_theta*texcoord.y,\n                    sin_theta*texcoord.x + cos_theta*texcoord.y);\n\n    float l = 1.0-length(center-mouse.xy)/max(iResolution.x, iResolution.y);\n    l = 0.25 +.75*l;\n    \n    \n    // float d = arrow_curved(texcoord, body, 0.25*body, linewidth, antialias);\n    float d = arrow_stealth(texcoord, l*body, 0.25*body, linewidth, antialias);\n    // float d = arrow_triangle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    // float d = arrow_triangle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    // float d = arrow_triangle_30(texcoord, body, 0.25*body, linewidth, antialias);\n    // float d = arrow_angle_90(texcoord, body, 0.15*body, linewidth, antialias);\n    // float d = arrow_angle_60(texcoord, body, 0.20*body, linewidth, antialias);\n    // float d = arrow_angle_30(texcoord, body, 0.25*body, linewidth, antialias);\n\n    fragColor = filled(d, linewidth, antialias,\n                          vec4(0,0,0,1),vec4(1,1,1,1));\n}\n\n","name":"Image","description":"","type":"image"}]}