{"ver":"0.1","info":{"id":"lfXyWM","date":"1721197114","viewed":52,"name":"mean curvature blur","username":"aksel","description":"wanted to learn how this worked after finding it in GIMP\n\nvery much inspired/learned from https://www.shadertoy.com/view/ct23RV, credits to them\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["blur","imageprocessing","curvature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Display the image as it's being blurred in buffer A\n    vec4 buffer = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    fragColor = buffer;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Initial image data is in iChannel1\n   Over time the blurred result is stored in\n   buffer A, which is then displayed via the \n   Image tab.\n*/\n\n// Toggle between different approaches\nconst bool DELTA = true;\n\n// Define directions\nconst vec2 up    = vec2(0,1.);\nconst vec2 down  = vec2(0,-1.);\nconst vec2 right = vec2(1.,0);\nconst vec2 left  = vec2(-1.,0);\n\nvec2 nv(vec2 v) {\n    // Normalize with a minimum bound -\n    // without this, code breaks\n    return v * min(1./length(v), 1e20);\n}\n\nfloat intensity(sampler2D source, vec2 p, int i)\n{\n    // Normalize pixel coordinates based on texture size\n    // Explicitly cast from ivec2 (int) to vec2 (float)\n    vec2 size = vec2(textureSize(source, 0));\n    \n    return texture(source, p/size)[i];\n}\n\nfloat intensity(vec2 p, int i)\n{\n    return intensity(iChannel0, p, i);\n}\n\nvec4 col(sampler2D source, vec2 p)\n{\n    vec2 size = vec2(textureSize(source, 0));\n    return texture(source, p/size);\n}\n\nvec4 col(vec2 p)\n{\n    return col(iChannel0, p);\n}\n\nvec2 gradient(vec2 p,int i)\n{   \n    // Compute gradient of a point using central difference formula for\n    // first-order partial derivatives\n    float grad_x = intensity(p + right, i) - intensity(p + left, i);\n    float grad_y = intensity(p + up, i)    - intensity(p + down, i);\n    \n    return vec2(grad_x, grad_y) * 0.5;\n}\n\nfloat grad_mag(vec2 gradient)\n{\n    // Compute magnitude of the gradient\n    return sqrt(gradient.x * gradient.x + gradient.y * gradient.y);\n}\n\nmat2 hessian(vec2 p, int i)\n{\n    mat2x2 hessian;\n    \n    // Compute hessian matrix using central difference formula for\n    // second-order partial derivatives\n    hessian[0][0] = intensity(p + right, i) - (2. * intensity(p, i)) + intensity(p + left, i);\n    hessian[1][1] = intensity(p + up, i)    - (2. * intensity(p, i)) + intensity(p + down, i);\n    hessian[0][1] = (intensity(p + up + right, i) - intensity(p + up + left, i) - intensity(p + down + right, i) + intensity(p + down + left, i)) * 0.25;\n    hessian[1][0] = hessian[0][1];\n    \n    return hessian;\n}\n\nfloat curvature(vec2 p, int i)\n{\n    vec2 gradient = nv(gradient(p, i));\n    mat2 hessian  = hessian(p, i); \n    \n    // The trace of a hessian matrix of f(x,y) is equivalent to the laplacian of f(x,y)\n    // which is a measure of the rate at which the average value of f around a point differs\n    // from the value at the point itself (average curvature)\n    float trace = hessian[0][0] + hessian[1][1]; \n\n    // Compute mean curvature flow using the formula: \n    // https://wikimedia.org/api/rest_v1/media/math/render/svg/1759181feca78f1f31f296d82a155ca6dccd0db9\n    float numerator = (1. + (gradient.x*gradient.x))*hessian[1][1] - 2.*gradient.x*gradient.y*hessian[0][1] + (1.+(gradient.y*gradient.y))*hessian[0][0];\n    \n    // From https://www.shadertoy.com/view/ct23RV\n    // Calculatation so that colors in image move under mean curvature flow\n    // Points on the level set with higher curvature move faster than points\n    // with lower curvature, leading to a smoothing effect over time\n    // Expanded form of calculation is commented out\n    //float s_numerator = hessian[0][0] + hessian[1][1] - (gradient.x*gradient.x*hessian[0][0] + 2.*gradient.x*gradient.y*hessian[0][1] + gradient.y*gradient.y*hessian[1][1]);\n    float s_numerator = trace - dot(hessian*gradient, gradient);\n    \n    if (DELTA) { numerator = s_numerator; }\n    \n    float denomerator = (2. * pow(1. + gradient.x*gradient.x + gradient.y*gradient.y, 3./2.)); // Normalization factor\n    float H = numerator / denomerator;\n    \n    return H;\n}\n\nvoid mean_curvature_blur(out vec4 fragColor, vec2 fragCoord, float blur_amt, int iterations)\n{\n    vec2 p = fragCoord;\n    \n    // Initially grab the color of the previous frame\n    vec4 prev = col(p);\n    \n    // If we're on the first frame, initialize buffer A with color data\n    // from iChannel1\n    if (iFrame < 1) {\n        prev = texture(iChannel1, p/iResolution.xy);\n    }\n    // Stop once we've hit the desired iterations\n    if (iFrame > iterations) {\n        fragColor = prev;\n        return;\n    }\n    \n    // Iteratively blur the image according to the mean curvature\n    prev.r += curvature(p, 0) * blur_amt;\n    prev.g += curvature(p, 1) * blur_amt;\n    prev.b += curvature(p, 2) * blur_amt;\n\n    fragColor = prev;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int iterations = 300; // Determines the amount of iterations to blur\n    float blur_amt = 0.4; // Adjust the blurring rate over time\n    \n    mean_curvature_blur(fragColor, fragCoord, blur_amt, iterations);\n}","name":"Buffer A","description":"","type":"buffer"}]}