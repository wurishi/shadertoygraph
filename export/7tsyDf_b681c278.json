{"ver":"0.1","info":{"id":"7tsyDf","date":"1650568376","viewed":63,"name":"BH Gravitational Lensing","username":"steampunc","description":"This is some code which integrates rays of light through space as defined by the Schwarzschild metric. It does so by computing the changes in the coordinate velocity of light, and, as a result, refracting it. Click and drag to rotate the image!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blackhole","gravitationallensing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants parameterizing the system\nconst float rs = 0.3;\nconst float dt = 0.01;\nconst float dl = 0.01;\n\nconst float camera_dist = 4.0;\nconst float camera_fov = 0.5;\nconst float max_ray_dist = rs * 15.0;\n\nconst float disk_radius = 2.0;\nconst float disk_height = 0.03;\n\nconst vec3 disk_normal = normalize(vec3(0.0, 1.0, -0.05));\n\n// Comment this out to see the accretion disk better\n//#define USE_CUBEMAP; // This line\n#ifdef USE_CUBEMAP\nconst vec4 disk_color = vec4(0.1, 0.01, 0.1, 0.01);\n#else\nconst vec4 disk_color = vec4(0.02, 0.02, 0.02, 0.001);\n#endif\n\n// The basic ray datatype which gets integrated along the curved paths.\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n    vec4 curr_color;\n};\n\n// Computes the coordinate velocity of light at a particular\n// position in the Schwarzschild metric (isotropic coords)\nfloat velocity(vec3 pos) {\n    float lr = length(pos);\n    return sqrt(1.0 - rs / (4.8 * lr)) \n            / pow(1.0 + rs / (4.0 * lr), 2.5);\n}\n\n// Handles ray-accretion disk intersection using a signed \n// distance function, and returns a color. Modifying disk\n// color/opacity based off of other properties (i.e position)\n// could be a good future improvement.\nvec4 insideDisk(Ray r) {\n    float proj_height = dot(r.pos, disk_normal);\n    vec3 proj_r = r.pos - disk_normal * proj_height;\n    float sdf = max(length(proj_r) - disk_radius, \n                max(proj_height - disk_height / 2.0, \n                -proj_height - disk_height/2.0));\n    if (sdf < 0.0) {\n        return disk_color;\n    }\n    return vec4(0.0);\n}\n\n// Computes the direction the ray is refracted depending \n// on its position and direction.\nvec3 curveRay(Ray r) {\n    // Finding the perpendicular direction\n    vec3 r_perp = normalize(r.pos);\n    vec3 out_vec = cross(r.dir, r_perp);\n    vec3 dir_perp = normalize(cross(out_vec, r.dir));\n    \n    // Calculating the velocities at the displaced point\n    float v1 = velocity(r.pos - dir_perp * dl / 2.0);\n    float v2 = velocity(r.pos + dir_perp * dl / 2.0);\n    \n    float theta = atan((v1 - v2) * dt / dl);\n    \n    // Rotating the direction vector by linear combination of \n    // two orthogonal vectors.\n    vec3 dir = r.dir * cos(theta) + dir_perp * sin(theta);\n    return normalize(dir);\n}\n\n// Rotation matrix to handle camera motion.\nmat3 sphericalRotate(vec2 angle) {\n\tvec2 co = cos(angle);\n\tvec2 si = sin(angle);\n\t\n\treturn mat3(\n\t\tco.y, 0.0, -si.y,\n\t\tsi.y * si.x, co.x, co.y * si.x,\n\t\tsi.y * co.x, -si.x, co.y * co.x\n\t);\n}\n\n// Main update function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Some math to figure out the origin of the rays and their directions depending on the pixel.\n    vec3 camera_pos = vec3(0.0, 0.0, -camera_dist);\n    vec3 screen_pos = vec3((fragCoord - iResolution.xy / 2.0) / iResolution.x, -camera_dist + camera_fov);\n    \n    mat3 rot = sphericalRotate((iMouse.xy - iResolution.xy * 0.5).yx * vec2(0.01, -0.01));\n    camera_pos = rot * camera_pos;\n    screen_pos = rot * screen_pos;\n    \n    // Initializing the ray after having rotated the camera.\n    Ray r = Ray(screen_pos, normalize(screen_pos - camera_pos), vec4(0.0));\n    \n    // Looping until the ray has been integrated to a limit, either inside the \n    // Schwarzschild metric or some reasonably far distance away from the black hole.\n    while (length(r.pos) < max_ray_dist && length(r.pos) > rs) {\n        float stp = velocity(r.pos) * dt;\n        r.pos += r.dir * stp;\n        r.dir = curveRay(r);    \n        r.curr_color += insideDisk(r);\n    }\n    \n    // Getting a color from the ray, which was keeping track of what it hit while colliding\n    fragColor = r.curr_color;\n    if (length(r.pos) > rs) {\n        #ifdef USE_CUBEMAP\n        fragColor = texture(iChannel1, r.dir) + r.curr_color;\n        #else\n        // Adding far away dots and lines to visualize Einstein rings more easily when disabling the cubemap.\n        if (dot(r.dir, vec3(0.0, 0.0, 1.0)) > 0.9995) {\n            fragColor = r.curr_color + vec4(1.0, 0.0, 0.0, 0.0);\n        } else if (dot(r.dir, normalize(vec3(-1.0, 1.0, 1.0))) > 0.9995) {\n            fragColor = r.curr_color + vec4(0.0, 1.0, 0.0, 0.0);\n        } else if (abs(dot(r.dir, normalize(vec3(0.0, 0.5, 0.11)))) < 0.01) {\n            fragColor = r.curr_color + vec4(0.0, 0.0, 1.0, 0.0);\n        }\n        \n        #endif\n    }\n\n}","name":"Image","description":"","type":"image"}]}