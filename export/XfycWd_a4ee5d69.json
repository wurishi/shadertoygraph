{"ver":"0.1","info":{"id":"XfycWd","date":"1732530217","viewed":30,"name":"Raymarching Pathtracing Plane v2","username":"Longingly","description":"A demo shader i made for practice","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define a struct to hold surface information\nstruct SurfaceInfo {\n    vec3 color;\n    float reflectivity;\n    float distance;\n};\n\nfloat sdfSphere(vec3 p, float size) {\n    return length(p) - size;\n}\n\nfloat sdfPlane(vec3 p, float planeY) {\n    return p.y - planeY;\n}\n\nfloat sdfCube(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.x * axis.z + axis.y * s,\n        oc * axis.y * axis.x + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.z * axis.y + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nfloat smoothmin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n// Helper function to smoothly combine two SurfaceInfos\nSurfaceInfo smoothMinSurface(SurfaceInfo a, SurfaceInfo b, float k) {\n    float h = clamp(0.5 + 0.5 * (b.distance - a.distance) / k, 0.0, 1.0);\n    SurfaceInfo result;\n    result.distance = mix(b.distance, a.distance, h) - k * h * (1.0 - h);\n    result.color = mix(b.color, a.color, h);\n    result.reflectivity = mix(b.reflectivity, a.reflectivity, h);\n    return result;\n}\n\nSurfaceInfo map(vec3 p, int bouncedTimes) {\n    float k = .7;\n    if (bouncedTimes == 0) {\n        k = .7;\n    }\n\n    // Initialize the result with the plane\n    SurfaceInfo result;\n    float planeY = -1.0;\n    result.distance = sdfPlane(p, planeY);\n    result.color = vec3(0.6, 0.6, 0.6);\n    result.reflectivity = 0.8;\n\n    const int NUM_SPHERES = 3;\n    vec3 spherePositions[NUM_SPHERES];\n    float sphereSizes[NUM_SPHERES];\n    vec3 sphereColors[NUM_SPHERES];\n    float sphereReflectivities[NUM_SPHERES];\n\n    // Define spheres\n    spherePositions[0] = vec3(1.0, 0.0, 0.5);\n    sphereSizes[0] = 0.5;\n    sphereColors[0] = vec3(1.0, 0.0, 0.0);\n    sphereReflectivities[0] = 0.25;\n\n    spherePositions[1] = vec3(-1.0, 0.0, 1.0);\n    sphereSizes[1] = 0.5;\n    sphereColors[1] = vec3(0.0, 1.0, 0.0);\n    sphereReflectivities[1] = 0.25;\n\n    spherePositions[2] = vec3(1.0, 0.0, 1.5);\n    sphereSizes[2] = 0.5;\n    sphereColors[2] = vec3(0.5, 0.5, 0.8);\n    sphereReflectivities[2] = 0.8;\n\n    // Loop through spheres and combine using smoothmin\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        vec3 spherePos = spherePositions[i];\n        spherePos.x += sin(iTime + float(i)); // Animate sphere positions\n        float sdf = sdfSphere(p - spherePos, sphereSizes[i]);\n\n        SurfaceInfo sphereInfo;\n        sphereInfo.distance = sdf;\n        sphereInfo.color = sphereColors[i];\n        sphereInfo.reflectivity = sphereReflectivities[i];\n\n        result = smoothMinSurface(result, sphereInfo, k);\n    }\n\n    // Define cube\n    vec3 cubeSize = vec3(5.0, 1.0, 1.0);\n    vec3 q1 = p + vec3(0.0, -0.5, -4.0);\n    q1 *= rotationMatrix(vec3(1.0, 0.0, 0.0), iTime / 2.0);\n    float cubeDist = sdfCube(q1, cubeSize);\n\n    SurfaceInfo cubeInfo;\n    cubeInfo.distance = cubeDist;\n    cubeInfo.color = vec3(0.0, 0.0, 1.0);\n    cubeInfo.reflectivity = 0.7;\n\n    // Combine cube with result\n    result = smoothMinSurface(result, cubeInfo, 0.);\n\n    return result;\n}\n\n// Function to compute the normal at point p\nvec3 computeNormal(vec3 p) {\n    const float eps = 0.0001;\n    float dx = map(p + vec3(eps, 0.0, 0.0), 0).distance - map(p - vec3(eps, 0.0, 0.0), 0).distance;\n    float dy = map(p + vec3(0.0, eps, 0.0), 0).distance - map(p - vec3(0.0, eps, 0.0), 0).distance;\n    float dz = map(p + vec3(0.0, 0.0, eps), 0).distance - map(p - vec3(0.0, 0.0, eps), 0).distance;\n    return normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 accumulatedColor = vec3(0.0);\n    float attenuation = 1.0;\n\n    int i;\n\n    const int bounceTimes = 16;\n    const int maxMarches = 80;\n\n    // Bounce Loop\n    for (int j = 0; j < bounceTimes; j++) {\n        float t = 0.0;\n\n        // Ray marching\n        for (i = 0; i < maxMarches; i++) {\n            vec3 p = ro + rd * t;\n            SurfaceInfo a = map(p, j);\n\n            float d = a.distance;\n            if (d < 0.001) {\n                vec3 surfaceColor = a.color;\n                float reflectivity = a.reflectivity;\n\n                // Add the surface color to the accumulated color\n                accumulatedColor += attenuation * surfaceColor * (1.0 - reflectivity);\n\n                // Update attenuation\n                attenuation *= reflectivity;\n\n                if (attenuation < 0.01) {\n                    // If attenuation is too small, exit the loop\n                    break;\n                }\n\n                // Compute normal and reflect the ray\n                vec3 normal = computeNormal(p);\n                ro = p + normal * 0.001; // Offset to prevent self-intersection\n                rd = reflect(rd, normal);\n\n                // Proceed to the next bounce\n                break;\n            }\n\n            t += d;\n        }\n\n        if (i >= maxMarches) {\n            // Ray did not hit anything; add background color\n            vec3 backgroundColor = vec3(0.2, 0.2, 0.2);\n            accumulatedColor += attenuation * backgroundColor;\n            break;\n        }\n    }\n\n    fragColor = vec4(accumulatedColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}