{"ver":"0.1","info":{"id":"ftcfRN","date":"1662714902","viewed":43,"name":"DayC's Cornell Box","username":"DayC","description":"尝试渲染一个Cornell Box","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cornellbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MEX_STEP=255;\nconst float EPI=0.005;\nconst float MAX_DIST=1000000.0;\n\nvec3 camera_pos=vec3(278,273,-800);\nvec3 camera_dir=vec3(0,0,1);\nvec3 camera_up=vec3(0,1,0);\nfloat near=0.035;\nvec2 size=vec2(0.044,0.025);\n\n//盒子的白色部分\nfloat BoxWhite(vec3 point)\n{\n\tfloat dist=MAX_DIST;\n\t//地板\n\tdist=min(dist,udQuad(point, vec3(552.8,0,0), vec3(0,0,0), vec3(0,0,559.2), vec3(549.6,0,559.2)));\n\t//天花板\n\tdist=min(dist,udQuad(point, vec3(556.0,548.8,0.0), vec3(556.0,548.8,559.2), vec3(0.0,548.8,559.2), vec3(0.0,548.8,0.0)));\n\t//后面墙\n\tdist=min(dist,udQuad(point, vec3(549.6,0.0,559.2), vec3(0.0,0.0,559.2), vec3(0.0,548.8,559.2), vec3(556.0,548.8,559.2)));\n    //小盒子\n    mat4 smallbox_transform=translate(vec3(185,82.5,169))*rotate(vec3(0,1,0),-0.29);\n    vec4 smallbox_point=inverse(smallbox_transform)*vec4(point,1);\n    dist=min(dist,sdBox(smallbox_point.xyz,vec3(165,165,165)/2.0));\n    //大盒子\n    mat4 tallbox_transform=translate(vec3(368,165,351))*rotate(vec3(0,1,0),-1.27);\n    vec4 tallbox_point=inverse(tallbox_transform)*vec4(point,1);\n    dist=min(dist,sdBox(tallbox_point.xyz,vec3(165,330,165)/2.0));\n\treturn dist;\n}\n\nvec3 EstimateNormal_Wihte(vec3 point)\n{\n\treturn normalize(vec3(BoxWhite(point+vec3(EPI,0,0))-BoxWhite(point-vec3(EPI,0,0)),\n        BoxWhite(point+vec3(0,EPI,0))-BoxWhite(point-vec3(0,EPI,0)),\n        BoxWhite(point+vec3(0,0,EPI))-BoxWhite(point-vec3(0,0,EPI))));\n}\n\n//盒子的红色部分\nfloat BoxRed(vec3 point)\n{\n\tfloat dist=MAX_DIST;\n\t//左面墙\n\tdist=min(dist,udQuad(point, vec3(552.8,0.0,0.0), vec3(549.6,0.0,559.2), vec3(556.0,548.8,559.2), vec3(556.0,548.8,0.0)));\n\treturn dist;\n}\nvec3 EstimateNormal_Red(vec3 point)\n{\n\treturn normalize(vec3(BoxRed(point+vec3(EPI,0,0))-BoxRed(point-vec3(EPI,0,0)),\n        BoxRed(point+vec3(0,EPI,0))-BoxRed(point-vec3(0,EPI,0)),\n        BoxRed(point+vec3(0,0,EPI))-BoxRed(point-vec3(0,0,EPI))));\n}\n\n//盒子的绿色部分\nfloat BoxGreen(vec3 point)\n{\n\tfloat dist=MAX_DIST;\n\t//右面墙\n\tdist=min(dist,udQuad(point, vec3(0.0,0.0,559.2), vec3(0.0,0.0,0.0), vec3(0.0,548.8,0.0), vec3(0.0,548.8,559.2)));\n\treturn dist;\n}\nvec3 EstimateNormal_Green(vec3 point)\n{\n\treturn normalize(vec3(BoxGreen(point+vec3(EPI,0,0))-BoxGreen(point-vec3(EPI,0,0)),\n        BoxGreen(point+vec3(0,EPI,0))-BoxGreen(point-vec3(0,EPI,0)),\n        BoxGreen(point+vec3(0,0,EPI))-BoxGreen(point-vec3(0,0,EPI))));\n}\n\n\n\n//透视摄像机射线\nvec3 CameraRay_Perspective(vec3 eyePos,vec3 upVec,vec3 front,float near,vec2 size,vec2 uv)\n{\n    upVec=normalize(upVec);\n    front=normalize(front);\n    vec3 right=cross(front,upVec);\n    vec3 hitPoint=vec3(size*uv,0);\n    hitPoint=hitPoint.x*right+hitPoint.y*upVec+eyePos+front*near;\n    return normalize(hitPoint-eyePos);\n}\n\nLambertMaterial material_white=LambertMaterial(vec3(1,1,1),vec3(0.5,0.5,0.5),vec3(0.1,0.1,0.1));\nLambertMaterial material_red=LambertMaterial(vec3(1,0,0),vec3(0.5,0.5,0.5),vec3(0.1,0.1,0.1));\nLambertMaterial material_green=LambertMaterial(vec3(0,1,0),vec3(0.5,0.5,0.5),vec3(0.1,0.1,0.1));\nLambertLight scene_light=LambertLight(vec3(278,548.8,278.5),vec3(1,1,1),100000.0);\n\nvec4 HalfLambertShading(vec3 pos,vec3 eyePos,vec3 normal,LambertMaterial mateial,LambertLight light)\n{\n    vec3 light_dir=normalize(light.pos-pos);\n    vec3 view_dir=normalize(eyePos-pos);\n    normal=normalize(normal);\n    float light_dist=length(pos-light.pos);\n    float intensity=light.intensity/(light_dist*light_dist);\n    \n    vec3 diffuse = light.color*mateial.diffuse*intensity*max(.0,dot(normal,light_dir));\n\n    vec3 half_vec=normalize(view_dir+light_dir);\n    vec3 specular=light.color*mateial.specular*intensity*pow(max(.0,dot(half_vec,normal)),1000.0);\n\n    vec3 ambient=light.color*mateial.ambient*intensity;\n\n    return vec4(diffuse+specular+ambient,1.0);\n}\n\n//光线步进\nvec4 RayMarching(vec3 eyePos,vec3 rayDir,float start,float end)\n{\n\tint material_index=-1;\n\n\tfloat depth=start;\n    for(int i=0;i<MEX_STEP;i++)\n    {\n    \tfloat dist;\n        vec3 point=eyePos+rayDir*depth;\n        //计算最小的光线距离以及打到了什么材质上\n        float dist_white=BoxWhite(point);\n        float dist_red=BoxRed(point);\n        float dist_green=BoxGreen(point);\n        if(dist_white<dist_red&&dist_white<dist_green)\n        {\n        \tmaterial_index=0;\n        \tdist=dist_white;\n        }\n        else if(dist_red<dist_green)\n        {\n        \tmaterial_index=1;\n        \tdist=dist_red;\n        }\n        else\n        {\n        \tmaterial_index=2;\n        \tdist=dist_green;\n        }\n        if(dist<EPI)\n        {\n        \tbreak;\n        }\n        depth+=dist;\n        if(depth>=end)\n        {\n        \tmaterial_index=-1;\n        \tbreak;\n        }\n    }\n\n    vec3 shade_pos=camera_pos+rayDir*depth;\n    vec4 fragColor;\n\n    switch(material_index)\n    {\n    \tcase 0:\n    \t\tfragColor=HalfLambertShading(shade_pos,camera_pos,EstimateNormal_Wihte(shade_pos),material_white,scene_light);\n    \t\tbreak;\n    \tcase 1:\n    \t\tfragColor=HalfLambertShading(shade_pos,camera_pos,EstimateNormal_Red(shade_pos),material_red,scene_light);\n    \t\tbreak;\n    \tcase 2:\n    \t\tfragColor=HalfLambertShading(shade_pos,camera_pos,EstimateNormal_Green(shade_pos),material_green,scene_light);\n    \t\tbreak;\n    \tdefault:\n    \t\treturn vec4(0,0,0,1);\n    \t\tbreak;\n    }\n\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    uv-=0.5;\n\n    vec3 ray=CameraRay_Perspective(camera_pos,camera_up,camera_dir,near,size,uv);\n    fragColor=RayMarching(camera_pos,ray,0.1,1000000.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct  LambertMaterial\n{\n    //漫反射系数\n    vec3 diffuse;\n    //高光系数\n    vec3 specular;\n    //环境光系数\n    vec3 ambient;\n};\n\nstruct LambertLight\n{\n    //位置\n    vec3 pos;\n    //颜色\n    vec3 color;\n    //强度\n    float intensity;\n};\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nmat4 translate(vec3 delta)\n{\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(delta.x,delta.y,delta.z,1));\n}\n\nmat4 scale(vec3 delta)\n{\n\treturn mat4(\n\t\tvec4(delta.x,0,0,0),\n\t\tvec4(0,delta.y,0,0),\n\t\tvec4(0,0,delta.z,0),\n\t\tvec4(0,0,0,1));\n}\n\nmat4 rotate(vec3 axis,float theta_rad)\n{\n\taxis=normalize(axis);\n\tfloat cos_theta=cos(theta_rad);\n\tfloat sin_theta=sin(theta_rad);\n\treturn mat4(\n\t\tvec4(axis.x*axis.x*(1.0-cos_theta)+cos_theta       , axis.y*axis.x*(1.0-cos_theta)+axis.z*sin_theta, axis.z*axis.x*(1.0-cos_theta)-axis.y*sin_theta , 0.0),\n\t\tvec4(axis.x*axis.y*(1.0-cos_theta)-axis.z*sin_theta, axis.y*axis.y*(1.0-cos_theta)+cos_theta       , axis.z*axis.y*(1.0-cos_theta)+axis.x*sin_theta, 0.0),\n\t\tvec4(axis.x*axis.z*(1.0-cos_theta)+axis.y*sin_theta, axis.y*axis.z*(1.0-cos_theta)-axis.x*sin_theta, axis.z*axis.z*(1.0-cos_theta)+cos_theta       , 0.0),\n\t\tvec4(0.0                                           , 0.0                                           , 0.0                                           , 1.0));\n}","name":"Common","description":"","type":"common"}]}