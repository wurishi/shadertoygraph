{"ver":"0.1","info":{"id":"7lfBWX","date":"1651588954","viewed":139,"name":"Fork rotating g haleyhalcy 266","username":"HaleyHalcyon","description":"a","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"NtsBWj","parentname":"rotating grid •##{~n{@#~"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.141592653589)\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\nvec3 color(float x){\n    const int colorCount = 8;\n    vec3[] c = vec3[](\n        vec3(0),\n        HEX(0xe020c0),\n        HEX(0xf0e040),\n        HEX(0xc0ff80),\n        vec3(1),\n        HEX(0xa0ffe0),\n        HEX(0x7080F0),\n        HEX(0x8000a0)\n    );\n    x *= float(colorCount);\n    int lo = int(floor(x));\n    \n    return mix(\n        c[lo],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}\n\n// does overexposure filter\nvec3 deepfry(vec3 rgb, float x) {\n    rgb *= x;\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}\n\nvec2 rotate(vec2 uv, float theta) {\n    return vec2(\n        uv.x * cos(theta) - uv.y * sin(theta),\n        uv.y * cos(theta) + uv.x * sin(theta)\n    );\n}\n\nvec2 rotEffect(vec2 uv, float t) {\n    float scale = exp2(-t * 0.5);\n    return rotate(\n        floor(\n            rotate(\n                uv * scale, t * PI / 4.\n            )\n        ) + 0.5,\n        -t * PI / 4.\n    ) / scale;\n}\n\nfloat zigzag(float x) {\n    return 1. - abs(1. - fract(x) * 2.);\n}\n\n// returns two floats for hue, one float for saturation\nvec3 spiral(vec2 uv, float t) {\n    vec2 rt = vec2(log(0.2 + length(uv)), atan(uv.y, uv.x) / PI / 2.);\n    vec2 hueVec = rotate(\n        vec2(1.0, 0.0),\n        PI * 2. * (\n            1.1 * rt.x\n            - 3. * rt.y\n            + 0.0 * sin(2. * t * PI)\n        )\n    );\n    return vec3(hueVec, zigzag(5.8 * uv.x + 11.0 * rt.y + 0.8 * rt.x) * 2.0 - 1.0);\n}\n\n#define LAYERS 4.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 2.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = 16.00;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    uv *= 1. + 0.03 * sin(6.2 * length(uv) + 2. * t * PI * 2.);\n    vec3 abv = vec3(0.);\n    \n    for (float i = 0.; i < LAYERS; i++) {\n        float ti = t + i;\n        vec2 uv0 = rotEffect(uv * scale, ti);\n        abv += spiral(\n            uv0 / scale, t\n        ) * min(min(ti, LAYERS - ti), 1.) / (LAYERS - 1.);\n    }\n    vec3 col = deepfry(\n        color(fract(atan(abv.y, abv.x) * 0.5 / PI)), 1.0 + 2.0 * abv.z / LAYERS\n    );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}