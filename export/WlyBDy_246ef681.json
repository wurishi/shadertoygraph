{"ver":"0.1","info":{"id":"WlyBDy","date":"1675868346","viewed":87,"name":"Simple Raymarching Shader v2","username":"Mcthouacbb","description":"A Simple Raymarcher","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 128\n#define MAX_DIST 64\n#define EPSILON 0.001\n\n#define FOV 150.0\n#define background_color vec3(0.5, 0.5, 0.5)\n\n#define PI 3.14159265\n\n\nstruct sphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n};\n\nstruct box {\n    vec3 pos;\n    vec3 rot;\n    vec3 size;\n};\n\nstruct cylinder {\n    float height;\n    float radius;\n    vec3 rot;\n    vec3 pos;\n};\n\nstruct light {\n    vec3 position;\n    float intensity;\n};\n\nsphere spheres[7] = sphere[7](\n    sphere(vec3(0, 0, 0), 1.3, vec3(1, 0.5, 0.8)),\n    sphere(vec3(1.5, 0, 0), 0.35, vec3(0.5, 1, 1)),\n    sphere(vec3(-1.5, 0, 0), 0.35, vec3(0.5, 1, 1)),\n    sphere(vec3(0, 1.5, 0), 0.35, vec3(0.5, 1, 1)),\n    sphere(vec3(0, -1.5, 0), 0.35, vec3(0.5, 1, 1)),\n    sphere(vec3(0, 0, 1.5), 0.35, vec3(0.5, 1, 1)),\n    sphere(vec3(0, 0, -1.5), 0.35, vec3(0.5, 1, 1))\n);\nbox boxes[1] = box[1](\n    box(vec3(0, 0, 0), vec3(0 ,0, 0), vec3(0.98, 0.98, 0.98))\n);\ncylinder cylinders[3] = cylinder[3](\n    cylinder(3.0, 0.6, vec3(0, 0, 0), vec3(0, 0, 0)),\n    cylinder(3.0, 0.6, vec3(0, 90, 0), vec3(0, 0, 0)),\n    cylinder(3.0, 0.6, vec3(90, 0, 0), vec3(0, 0, 0))\n);\n\nlight lights[6] = light[6](\n    light(vec3(2, 1, -15), 0.1),\n    light(vec3(-2, -1, 15), 0.1),\n    light(vec3(15, -2, -1), 0.03),\n    light(vec3(-15, 2, 1), 0.03),\n    light(vec3(0, 16, 0), 0.03),\n    light(vec3(0, 15, 0), 0.03)\n);\n\nmat3 rotateX(float rotationAngle) {\n    float sinAng = sin(rotationAngle);\n    float cosAng = cos(rotationAngle);\n    return mat3(\n        1,      0,       0,\n        0, cosAng, -sinAng,\n        0, sinAng,  cosAng\n    );\n}\nmat3 rotateY(float rotationAngle) {\n    float sinAng = sin(rotationAngle);\n    float cosAng = cos(rotationAngle);\n    return mat3(\n         cosAng, 0, sinAng,\n              0, 1,      0,\n        -sinAng, 0, cosAng\n    );\n}\nmat3 rotateZ(float rotationAngle) {\n    float sinAng = sin(rotationAngle);\n    float cosAng = cos(rotationAngle);\n    return mat3(\n        cosAng, -sinAng, 0,\n        sinAng,  cosAng, 0,\n             0,       0, 1\n    );\n}\n\n\n\nfloat sphereSDF(sphere sampleSphere, vec3 samplePos) {\n    return length(samplePos - sampleSphere.pos) - sampleSphere.radius;\n}\nfloat boxSDF(box sampleBox, vec3 samplePos) {\n    vec3 p = rotateZ(sampleBox.rot.z * PI / 180.0) * rotateY(sampleBox.rot.y * PI / 180.0) * rotateX(sampleBox.rot.x * PI / 180.0) * (samplePos - sampleBox.pos);\n    vec3 d = abs(p) - sampleBox.size;\n    \n    float insideDist = length(max(d, 0.0));\n    float outsideDist = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    return insideDist + outsideDist;\n}\n\nfloat cylinderSDF(cylinder sampleCylinder, vec3 samplePos) {\n    vec3 p = rotateZ(sampleCylinder.rot.z * PI / 180.0) * rotateY(sampleCylinder.rot.y * PI / 180.0) * rotateX(sampleCylinder.rot.x * PI / 180.0) * (samplePos - sampleCylinder.pos);\n    \n    float inOutRadius = length(p.xy) - sampleCylinder.radius;\n    float inOutHeight = abs(p.z) - sampleCylinder.height / 2.0;\n    \n    float inDist = min(max(inOutRadius, inOutHeight), 0.0);\n    float outDist = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return inDist + outDist;\n}\n\n\nfloat sceneSDF(vec3 samplePos) {\n    samplePos = mod(samplePos + 0.5 * vec3(12.0), vec3(12.0)) - 0.5 * vec3(12.0);\n\n    float sphereDist1 = sphereSDF(spheres[0], samplePos);\n    float boxDist1 = boxSDF(boxes[0], samplePos);\n    \n    float boxSphereDist1 = max(boxDist1, sphereDist1);\n    \n    float sphereDists = float(MAX_DIST);\n    \n    for(int i = 1; i < spheres.length(); i++) {\n        sphereDists = min(sphereDists, sphereSDF(spheres[i], samplePos));\n    }\n    \n    float cylinderDist1 = cylinderSDF(cylinders[0], samplePos);\n    float cylinderDist2 = cylinderSDF(cylinders[1], samplePos);\n    float cylinderDist3 = cylinderSDF(cylinders[2], samplePos);\n    \n    float boxSphereCylinderDist = max(max(max(boxSphereDist1, cylinderDist3 * -1.0), cylinderDist2 * -1.0), cylinderDist1 * -1.0);\n    \n    float test = min(boxSphereCylinderDist, sphereDists);\n    return test;\n}\n\n\nvec3 getNormal(vec3 pos) {\n    return normalize(vec3(\n        sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z)) - sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z)),\n        sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z)) - sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z)),\n        sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON)) - sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON))\n    ));\n}\n\nfloat calculateLighting(vec3 samplePos, vec3 cameraPos, vec3 normal) {\n    float intensity = 0.0;\n    intensity += 0.2;\n    \n    samplePos = mod(samplePos + 0.5 * vec3(12.0), vec3(12.0)) - 0.5 * vec3(12.0);\n    \n    vec3 viewDir = normalize(cameraPos - samplePos);\n    for(int i = 0; i < lights.length(); i++) {\n        vec3 lightDir = lights[i].position - samplePos;\n        \n        vec3 reflectDir = normalize(2.0 * dot(lightDir, normal) * normal - lightDir);\n        float dotRV = dot(reflectDir, viewDir);\n        float dotLN = dot(lightDir, normal);\n        if(dotRV > 0.0 && dotLN > 0.0) {\n            intensity += (dotLN + pow(dotRV, 5.0)) * lights[i].intensity;\n        } else {\n            if(dotLN > 0.0) {\n                intensity += dotLN * lights[i].intensity;\n            }\n        }\n    }\n    \n    return intensity;\n}\n\n\n\nvec4 raymarch(vec3 rayOrigin, vec3 rayDirection, float maxDist) {\n    float sceneDist = sceneSDF(rayOrigin);\n    float currentDist = sceneDist;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        sceneDist = sceneSDF(rayOrigin + currentDist * rayDirection);\n        \n        if(currentDist > float(maxDist)) {\n            break;\n        } else {\n            if(sceneDist < EPSILON) {\n                vec3 currentPos = rayOrigin + currentDist * rayDirection;\n                \n                return vec4(currentPos, currentDist);\n                \n                /*vec3 normal = getNormal(currentPos);\n            \n                vec3 col = (normal + vec3(1.4)) / 2.4;\n                \n                float Intensity = calculateLighting(currentPos, rayOrigin, normal);\n                \n                return col * Intensity;*/\n                \n            } else {\n                currentDist += sceneDist;\n            }\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, -1.0);\n}\n\n\n\nvec3 screenPointToRay(vec2 screenPos, vec3 cameraRot) {\n    vec3 originRay = normalize(vec3(screenPos * tan((FOV / 180.0 * PI) / 2.0), 1));\n    return rotateY(cameraRot.y) * rotateX(cameraRot.x) * rotateZ(cameraRot.z) * originRay;\n}\n\nvec2 getAttribPos(int i) {\n    vec2 xy = vec2(mod(float(i), iChannelResolution[0].x), floor(float(i) / iChannelResolution[0].x));\n    xy += vec2(0.5);\n    xy /= iChannelResolution[0].xy;\n    return xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 screenPos = ((fragCoord - iResolution.xy / 2.0) / iResolution.x);\n    \n    for(int i = 1; i < spheres.length(); i++) {\n        spheres[i].pos = spheres[i].pos * (cos(iTime * 2.0) * 1.1 + 1.5);\n        spheres[i].radius += cos(iTime * 2.0) / 12.0;\n    }\n    for(int i = 0; i < cylinders.length(); i++) {\n        cylinders[i].radius += cos(iTime * 2.0) / 2.75 + 0.15;\n    }\n    \n    vec3 cameraDir = vec3(texture(iChannel0, getAttribPos(1)).xy, 0.0);//vec3(-atan(cos(iTime * 1.5) / 2.0), iTime * 1.5 + PI / 2.0, iTime * 2.5);\n    \n    vec3 rayDirection = screenPointToRay(screenPos, cameraDir);\n    \n    vec3 rayOrigin = texture(iChannel0, getAttribPos(0)).xyz;//vec3(cos(iTime * 1.5) * 12.0, 6.0 * cos(iTime * 1.5), sin(iTime * 1.5) * 12.0);\n\n    vec4 rayData = raymarch(rayOrigin, rayDirection, float(MAX_DIST));\n    \n    if(rayData.w == -1.0) {\n        fragColor = vec4(background_color, 1.0);\n    } else {\n        vec3 normal = getNormal(rayData.xyz);\n        \n        vec3 col = (normal + vec3(1.4)) / 2.4;\n        \n        float Intensity = calculateLighting(rayData.xyz, rayOrigin, normal);\n        \n        fragColor = vec4(col * Intensity, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265\n\nint saveNum(vec2 xy) {\n    xy *= iChannelResolution[0].xy;\n    xy = floor(xy);\n    return int(xy.x + xy.y * iChannelResolution[0].x);\n}\n\nvec2 getAttribPos(int i) {\n    vec2 xy = vec2(mod(float(i), iChannelResolution[0].x), floor(float(i) / iChannelResolution[0].x));\n    xy += vec2(0.5);\n    xy /= iChannelResolution[0].xy;\n    return xy;\n}\n\nfloat moveSpeed = 5.0;\n\nfloat mouseLookSpeed1 = 0.9;\nfloat mouseLookSpeed2 = 1.4;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    int save = saveNum(uv);\n    if(save == 0) {\n        float cameraYaw = texture(iChannel0, getAttribPos(1)).y;\n        vec3 cameraPos = texture(iChannel0, uv).xyz;\n        float xMove = moveSpeed * iTimeDelta * (-texelFetch(iChannel1, ivec2(65, 0), 0).r + texelFetch(iChannel1, ivec2(68, 0), 0).r);\n        float zMove = moveSpeed * iTimeDelta * (texelFetch(iChannel1, ivec2(87, 0), 0).r - texelFetch(iChannel1, ivec2(83, 0), 0).r);\n        float yMove = moveSpeed * iTimeDelta * (texelFetch(iChannel1, ivec2(69, 0), 0).r - texelFetch(iChannel1, ivec2(81, 0), 0).r);\n        cameraPos += vec3(xMove * cos(cameraYaw) - zMove * sin(cameraYaw), yMove, zMove * cos(cameraYaw) + xMove * sin(cameraYaw));\n        fragColor = vec4(cameraPos, 0);\n    } else {\n        if(save == 1) {\n            vec3 cameraLook = texture(iChannel0, uv).xyz;\n            float cameraYawDelta = mouseLookSpeed1 * iTimeDelta * (texelFetch(iChannel1, ivec2(38, 0), 0).r - texelFetch(iChannel1, ivec2(40, 0), 0).r);\n            float cameraPitchDelta = mouseLookSpeed2 * iTimeDelta * (texelFetch(iChannel1, ivec2(37, 0), 0).r - texelFetch(iChannel1, ivec2(39, 0), 0).r);\n            cameraLook += vec3(cameraYawDelta, cameraPitchDelta, 0);\n            fragColor = vec4(clamp(cameraLook.x, -PI / 2.0, PI / 2.0), cameraLook.y, cameraLook.z, 0);\n        } else {\n            discard;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}