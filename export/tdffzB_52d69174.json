{"ver":"0.1","info":{"id":"tdffzB","date":"1588513454","viewed":123,"name":"Failed tiling attempt","username":"Domenicobrz","description":"Tiling some octahedrons for my CG uni class ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","tiling","octahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat sdSphere(vec3 center, float rad, vec3 p) {\n    return length(p - center) - rad;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdOctahedronSquash( vec3 p, float s, float ys) {\n  p = abs(p) * vec3(1.0, ys, 1.0);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat scene(vec3 p, float type) {\n    float modul = 4.0;\n    float hmod  = modul * 0.5;\n    \n    vec3 realp = p;\n    \n    p.y += noise(sin(p.x * 0.01 + iTime * 0.4) * 10.0) * 2.0; \n    p.z += noise(sin(p.z * 0.01 + iTime * 0.4) * 10.0) * 2.0; \n    \n    \n    \n    vec3 octahedron_index = (p + hmod) - mod((p+hmod), modul);\n    octahedron_index.y = 0.0;\n    // vec3 octahedron_index = p - mod(p, modul);\n    // octahedron_index.y = 0.0;\n    \n    \n    float pt = (p.z + hmod) - mod((p.z + hmod), modul);\n    float pq = (p.x + 128.0 + hmod) - mod((p.x + 128.0 + hmod), modul);\n    \n    p.x = mod(p.x + hmod, modul) - hmod;\n    p.y = p.y;\n    p.z = mod(p.z + hmod, modul) - hmod;\n        \n    \n    \n    // float mint = sphere(vec3(0.0, 0.0, 8.0), 5.0, p);\n    // float octahedron_index = \n    float octahedron_height = noise(pt * 0.25 + pq * 0.25 + iTime * 0.2);\n    float octahedron  = sdOctahedronSquash(p, 2.0, octahedron_height * 2.0 + 0.4);\n    \n    \n    \n    \n    \n    \n    p = p + vec3(2.0, 0.0, 2.0);\n    p.x = mod(p.x + hmod, modul) - hmod;\n    p.y = p.y;\n    p.z = mod(p.z + hmod, modul) - hmod;\n    pt = (p.z + hmod) - mod((p.z + hmod), modul);\n    pq = (p.x + 128.0 + hmod) - mod((p.x + 128.0 + hmod), modul);\n    octahedron_height = noise(pt * 0.15 + pq * 0.15);\n    \n    float octahedron2 = sdOctahedronSquash(p, 2.0, octahedron_height * 2.0 + 0.4);\n    \n    \n    \n    \n    \n    \n    \n    \n    vec3 tp = realp;\n    tp.y += noise(iTime * 0.5 + octahedron_index.x * 17.0 + octahedron_index.z * 23.0) * 8.0;\n    float hmod2 = hmod * 1.2;\n    float modul2 = modul * 1.2;\n    tp.x = mod(tp.x + hmod2, modul2) - hmod2;\n    tp.y = tp.y - 8.0;\n    tp.z = mod(tp.z + hmod2, modul2) - hmod2;\n    float octahedron3 = sdOctahedronSquash(tp, 0.2, 0.5);\n    // remove octahedron at the center\n    if(length(realp.xz - vec2(0.0, 0.0)) < 0.5) octahedron3 = 999999.0;\n    \n    \n    \n    \n    \n    \n    float plane      = p.y;\n    \n    float mint = opSmoothUnion(octahedron, octahedron2, sin(realp.x * 2.0 + iTime) * 0.5 + 0.5);\n    if(octahedron2 < mint) mint = octahedron2;\n    if(octahedron3 < mint) mint = octahedron3;\n    if(plane < mint) mint = plane;\n    \n    \n    float sphere = sdSphere(vec3(0.0, 2.0 + (sin(iTime) * 0.5 + 0.5) * 3.0, 0.0), 0.75, realp); \n    if(sphere < mint && type > 0.0) mint = sphere;\n    \n\treturn mint;\n}\n\n\nfloat shadowRay(vec3 ro, vec3 lightPos) {\n    float epsilon = 0.01;\n    float dist = length(lightPos - ro);\n    vec3 rd = normalize(lightPos - ro);\n    \n    \n    vec3 p = ro + rd * 0.15;\n    for(float i = 0.0; i < 50.0; i++) {\n        float t = scene(p, 0.0);\n  \n        if(t < 0.0) {\n            p += rd * t;\n            return 0.0;\n        }\n        if(abs(t) < epsilon) {\n            p += rd * t;\n            break;\n        }\n        \n        p += rd * t;\n    }\n    \n    float hitDist = length(p - ro);\n    if(dist - hitDist < 0.4) return 1.0;\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n  \n    \n    \n    vec2 ndv = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    float fov = 1.5;\n    \n    vec3 target = vec3(0.0);\n    // vec3 ro = vec3(-8.0, 6.0, -6.0);\n    vec3 ro = vec3(sin(iTime * 0.2) * 4.0, 3.0, cos(iTime * 0.2) * 4.0);\n    float rot = 0.5;\n\t// vec3 ro = vec3(sin(rot) * 4.0, 3.0, cos(rot) * 4.0);\n\t\n    ro *= 3.0;\n    \n    \n    vec3 w  = normalize(target - ro);\n    vec3 u  = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v  = normalize(cross(u, w));\n        \n        \n    vec3 rd = normalize(vec3(ndv, 1.0 * fov)); \n    rd = w * rd.z + v * rd.y + u * rd.x;\n                        \n    vec3 col = vec3(0.0);\n    \n    float epsilon = 0.03;\n    vec3 lightPos = vec3(0.0, 2.0 + (sin(iTime) * 0.5 + 0.5) * 3.0, 0.0);\n    float diffuse = 1.0;\n    vec3 n;\n    \n    vec3 p = ro;\n    for(float i = 0.0; i < 50.0; i++) {\n        float t = scene(p, 1.0);\n        \n        if(abs(t) < epsilon) {\n            \n            float px = scene(p + vec3(+epsilon, 0.0, 0.0), 1.0);\n            float py = scene(p + vec3(0.0, +epsilon, 0.0), 1.0);\n            float pz = scene(p + vec3(0.0, 0.0, +epsilon), 1.0);\n            \n            \n            n = normalize(vec3(px - t, py - t, pz - t));\n            // n.z = -n.z;\n            \n            vec3 lightDir = normalize(lightPos - p);\n            \n            float attenuation = 1.0 / (pow(length(lightPos - p), 2.0)); \n            \n            diffuse = max(dot(n, lightDir), 0.0) * attenuation * 10.0;\n          \n            //p = p + rd * t * 0.85;\n            break;\n        } else {\n        \tp = p + rd * t * 0.85;\n        }\n        \n        if(i > 28.0) {\n           diffuse = 0.0;\n        }\n    }\n    \n    \n    // shadow ray\n    float srr = max(shadowRay(p, lightPos), 0.075);\n    col = vec3(diffuse * srr + 0.0025) * vec3(1.0, 0.6, 0.2);\n    col *= texture(iChannel1, p.xz * 0.05 + p.y * 0.01).rgb * 0.75;\n    \n\t\n    if(length(lightPos - p) < 1.2) {\n       col *= vec3(2030.0);\n    }\n    \n    \n    float gamma = 2.2;\n    float exposure = 1.5;\n\tcol *= pow(2.0, exposure);\n    col = max(vec3(0.), col - vec3(0.004));\n\tcol = (col * (6.2 * col + .5)) / (col * (6.2 * col + 1.7) + 0.06);\n\tcol = pow(col, vec3(1. / gamma));\n\t    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}