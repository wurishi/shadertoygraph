{"ver":"0.1","info":{"id":"MtfyDr","date":"1504393348","viewed":117,"name":"Refraction & Shadows","username":"Sheado","description":"Just practicing some refraction...\nMouse to pan around.\n\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Practicing directional light & shadows. \n * Some references I followed:\n *\thttps://learnopengl.com/#!Lighting/Basic-Lighting\n *\thttps://iquilezles.org/articles/distfunctions\n *  https://learnopengl.com/#!Advanced-Lighting/Advanced-Lighting \n *  https://learnopengl.com/#!Advanced-OpenGL/Cubemaps\n */\nconst float EPSILON = 0.005;\nconst int maxSteps = 64;\nconst float PI = 3.1415926;\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat opTwist( vec3 p )\n{\n    return sdTorus(p, vec2(1., .2))+sin(1.*p.x)*sin(3.*p.y)*sin(2.*p.z);\n}\n\n/**\n * the camera\n */ \nmat3 getView(vec3 position, vec3 target)\n{\n    vec3 cameraDirection = normalize(target-position);\t// technically the reverse direction\n    vec3 up = vec3(0, 1, 0);\t\t\t\t\t\t\t// world up\n    vec3 cameraRight = normalize(cross(up, cameraDirection));\t\n    vec3 cameraUp = cross(cameraDirection, cameraRight);\n                                 \n\tmat3 view = mat3(cameraRight, cameraUp, cameraDirection);\n \treturn view;\n}\n\n\n/**\n * https://learnopengl.com/#!Getting-started/Transformations\n */\nmat4 rotate(float theta, vec3 a /*axis*/) {\n    float c = cos(theta);\n    float ic = 1. - c;\n    float s = sin(theta);\n    float is = 1. - s;\n\n    return mat4(\n        vec4(c+a.x*a.x*ic, \t\ta.x*a.y*ic-a.z*s, \ta.x*a.z*ic+a.y*s, \t0),\n        vec4(a.y*a.x*ic+a.z*s, \tc+a.y*a.y*ic, \t\ta.y*a.z*ic-a.x*s, \t0),\n        vec4(a.z*a.x*ic-a.y*s, \ta.z*a.y*ic+a.x*s, \tc+a.z*a.z*ic, \t\t0),\n        vec4(0, \t\t\t\t0, \t\t\t\t\t0,\t\t\t\t\t1)\n    );\n}\n\nfloat drawScene(vec3 p, out int id)\n{\n    vec3 position = p + vec3(-2.,-1.,-3.);\n    vec3 boxPosition = (rotate((iTime),vec3(0.,1.,0.))*vec4(position,1.)).xyz;\n    float dt = udBox( boxPosition,vec3(.5) );\n    id = 0;\n    float d;\n    \n    position = p + vec3(2.5*sin(iTime),-2.5,0.);\n    vec3 ppp = (rotate(PI*.25+.25*sin(iTime),vec3(1.,0.,0.)) * vec4(position,1.)).xyz;\n    d = sdTorus( ppp, vec2(1.,.2) );\n    if( d < dt )\n    {\n        dt = d; \n        id = 1;\n    }\n\n    position = p + vec3(3.*cos(iTime),-1.0,0.);\n    d = \tsdSphere(position,.5);\n    if( d < dt )\n    {\n        dt = d; \n        id = 2;\n    }\n\n    position = p + vec3(2.,-.7,-2.5);\n    d = opTwist( position );\n    if( d < dt )\n    {\n        dt = d; \n        id = 3;\n    }\n\n    // floor\n    position = p + vec3(0.,1,0.);\n    d = udBox( position,vec3(3.,.0,3.5) );\n    if( d < dt )\n    {\n        dt = d; \n        id = 4;\n    }\n    \n\treturn dt;\n}\n\nfloat drawScene(vec3 p)\n{\tint id;\n    return drawScene(p,id);\n}\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        drawScene(vec3(p.x + EPSILON, p.y, p.z)) - drawScene(vec3(p.x - EPSILON, p.y, p.z)),\n        drawScene(vec3(p.x, p.y + EPSILON, p.z)) - drawScene(vec3(p.x, p.y - EPSILON, p.z)),\n        drawScene(vec3(p.x, p.y, p.z  + EPSILON)) - drawScene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getMaterialColor(int id)\n{\n    vec3 color;\n    switch( id )\n    {\n        case 0:\n        color = vec3(1.,0.,0.);\n        break;\n        case 1:\n        color = vec3(1.,1.,0.);\n        break;\n        case 2:\n        color = vec3(1.,.0,1.);\n        break;\n        case 3:\n        color = vec3(0.,0.,1.);\n        break;\n        case 4:\n        color = vec3(0.,1.,0.);\n        break;\n    }\n    return color;\n}\n\nvec3 refraction(vec3 normalizedNormal, vec3 position, vec3 lightPos, vec3 viewPosition, vec3 color, float shadow)\n{\n    float refractionTransmissionIndex = 1.33;\n    float refractionQuotient = 1.0 / refractionTransmissionIndex;\n    \n    vec3 viewDirection = normalize(position-viewPosition);\t// negative view position\n    vec3 transmittedDirection = refract(viewDirection, normalizedNormal, refractionQuotient);\n\n    return texture(iChannel0, transmittedDirection).xyz;\n}\n\nfloat directionalShadow(vec3 cameraTarget, vec3 modelPosition, vec3 p, vec3 dirLightPos)\n{\n    float shadow = 0.;\n    mat3 dirLightView = getView(dirLightPos, cameraTarget);\n    vec3 dirLightRayDirection = dirLightView * modelPosition;\n\n    float dt = 0., d = 0.;\n    // shadow depth\n    float shadowDepth = length((dirLightPos-p));\n    dirLightRayDirection = normalize(-dirLightPos+p);\n    vec3 shadowPos;\n    for( int i = 0; i < maxSteps; ++i )\n    {\n        vec3 p = dirLightPos + dirLightRayDirection*d;\n        int id;\t// id of object that is being drawn\n        dt = drawScene(p,id);\n        if( dt < EPSILON )\n        {\n            float currentShadowDepth = length((dirLightPos-p));\n            // \n            if( currentShadowDepth/shadowDepth < 1.-EPSILON)\n                shadow = 1.;\t\n            break;\n        }\n        d += dt;\n    }\n    return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv *= 2.;\n    uv -= 1.;\n    uv.x *= aspect;\n\n    // camera setup\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if( mouse.x == -1. )\n        mouse.x = 0.; \n    if( mouse.y == -1. )\n        mouse.y = -.5; \n    float mx = clamp(mouse.x*2.*PI,-PI*.5,PI*.5);\n    float my = -clamp(mouse.y*2.*PI, -PI*.25, 0.0);\n    vec3 rayOrigin = vec3(7.*sin(mx), 2.*sin(my), 7.*cos(mx));\n    vec3 cameraTarget = vec3(0.,.0,.0);\n    mat3 view = getView(rayOrigin,cameraTarget);\n    vec3 modelPosition = normalize(vec3(uv,2.));\n    vec3 rayDirection = view * modelPosition;\n    \n    // directional light\n    vec3 dirLightPos = vec3(2.,10.,3.);\n\tmat3 dirLightView = getView(dirLightPos,cameraTarget);\n    vec3 dirLightRayDirection = dirLightView * modelPosition;\n\n    vec3 p;\n    float dt = 0., d = 0.;\n    vec3 color = texture(iChannel0,normalize(rayDirection)).xyz;\n    // shadow depth\n    float shadowDepth = 0.;\n\n    // raymarch\n    dt = 0.;\n    d = 0.;\n    for( int i = 0; i < maxSteps; ++i )\n    {\n        p = rayOrigin + rayDirection*d;\n        int id;\t// id of object that is being drawn\n        dt = drawScene(p,id);\n        if( dt < EPSILON )\n        {\n            color = getMaterialColor(id);\n            float shadow = directionalShadow(cameraTarget, modelPosition, p, dirLightPos);\n            \n            vec3 normal = normalize(estimateNormal(p));\n          \tcolor = refraction(normal, p, dirLightPos, rayOrigin, color, shadow);\n            color *= (1.0-shadow*0.5);\n            \n            break;\n        }\n        d += dt;\n    }\n\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}