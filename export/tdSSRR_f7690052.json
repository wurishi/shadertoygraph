{"ver":"0.1","info":{"id":"tdSSRR","date":"1552645612","viewed":73,"name":"Mashgraph","username":"da_demin","description":"Машграф, задание 1\nВыполнена базовая часть. Дополнительно имеется фрактал Мандельброта, резкие тени, CSG\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mashgraph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Constant parameters\nconst int STEPS = 1000;\nconst float MINDIST = 0.0;\nconst float MAXDIST = 1000.0;\nconst float EPS = 0.0001;\n\n/*\nПримитив кроме формы должен содержать цвет и материал.\nhttp://devernay.free.fr/cours/opengl/materials.html\nИх стоит возвращать при вызове ф-ции\n*/\n//Materials description\n//Parameters: ambient, diffuse, specular, alpha\nvec4[5] Materials=vec4[5](\n    vec4(0.5, 0.7, 0.8, 10.0),            \n    vec4(0.9, 0.7, 0.3, 20.0),\n    vec4(0.6, 0.7, 0.8, 64.0), \n    vec4(0.8, 0.2, 0.6, 1.0),\n    vec4(1.0, 1.0, 1.0, 0.0)//light\n);\n\n    \n//Colours description\nvec3[6] Colours = vec3[6](\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 0.0, 0.0),\n    vec3(1.0, 1.0, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.1, 1.0, 1.0),\n    vec3(1.0, 1.0, 1.0)//light\n);\n    \n//Structure, describes one point\nstruct pointdesc{\n    float dist;\n    int colour;\n    int material;\n};\n\n\n\n//SDF functions\nfloat SDFsphere(vec3 center, float r) {\n    return length(center) - r;\n}\n\nfloat SDFtorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SDFplane( vec3 point, vec4 normal )\n{\n  // n must be normalized\n  return dot(point,normal.xyz) + normal.w;\n}\nfloat SDFroundbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat SDFbox( vec3 p, vec3 b)\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat SDFmandelbulb(vec3 p, vec3 parameters, float detail, int iterations) {\n    vec3 temp = p;\n    float temp_detail = detail;   \n    for (int i=0; i < iterations; i++) {      \n        float r = length(temp);\n        if (r > 1.5){\n          break;\n        }\n        //to polar\n        float b = acos(temp.z/r);\n        float c = atan(temp.y/temp.x);\n        temp_detail = 5.0 * pow(r, parameters.z) * temp_detail + 1.0;\n        //scale, rotate\n        r = pow(r, parameters.z);\n        b = b * parameters.x;\n        c = c * parameters.y;\n        //to cartesian\n        temp = r * vec3(sin(b)*cos(c), sin(b)*sin(c), cos(b)) + p;\n    }\n    float z = length(temp);\n    float r = 0.5*z*log(z) / temp_detail;\n\treturn r;\n}\n\n\n//CSG operations\n\nfloat SDFunion(float dist1, float dist2) {\n    return min(dist1, dist2);\n}\nfloat SDFintersect(float dist1, float dist2) {\n    return max(dist1, dist2);\n}\nfloat SDFsubstract(float dist1, float dist2) {\n    return max(-dist1, dist2);\n}\n\n\n//Scene Description\npointdesc SDFscene(vec3 center) {\n   pointdesc ret;\n   //All SDFs must be repeated in getproperties\n   float SDF1 = SDFsphere(center + vec3(-1.5, 0.0, 4.0), 0.6);\n   float SDF2 = SDFsphere(center + vec3(1.6, 0.0, 0.0), 0.3);\n   float SDF3 = SDFtorus(center + vec3(1.0, 0.7, 0.3), vec2(0.6, 0.2));\n   float SDF4 = SDFplane(center + vec3(0.0, 0.9, 0.0), normalize(vec4(0.0, 1.0 , 0.0, 0.0)));\n   float SDF5_0 = SDFroundbox(center + vec3(-3.5, -0.8, 6.0), vec3(0.7, 0.7 , 0.1), 0.2);\n   float SDF5_1 = SDFsphere(center + vec3(-3.5, -0.8, 6.0 + sin(iTime/2.0)), 0.5);\n   float SDF5 = SDFsubstract(SDF5_1, SDF5_0);\n   float SDF6 = SDFmandelbulb(center + vec3(-0.3, -1.0, 6.0), vec3(8.0, 4.0, 7.0), 1.0, 2);\n   \n   if (SDF6 <= min(min(min(SDF2, SDF3), min(SDF1, SDF4)),SDF5)){\n       ret.dist = SDF6;\n       ret.colour = 3;\n       ret.material = 2;\n   } else if(SDF5 <= min(min(SDF2, SDF3), min(SDF1, SDF4))){\n       ret.dist = SDF5;\n       ret.colour = 4;\n       ret.material = 2;\n   } else if (SDF1 <= min(min(SDF2, SDF3),SDF4)){\n       ret.dist = SDF1;\n       ret.colour = 0;\n       ret.material = 0;\n   } else if (SDF2 <= min(SDF3, SDF4)){\n       ret.dist = SDF2;\n       ret.colour = 1;\n       ret.material = 1;\n   } else if (SDF3 <= SDF4){\n       ret.dist = SDF3;\n       ret.colour = 2;\n       ret.material = 2;\n   } else {\n       ret.dist = SDF4;\n       ret.colour = 3;\n       ret.material = 3;\n   }\n   \n   return ret;\n}\n\n//Distance calculating function\nfloat shortDistToSurf(vec3 eye, vec3 marchingDirection) {\n    float depth = MINDIST;\n    for (int i = 0; i < STEPS; i++) {\n        float dist = SDFscene(eye + depth * marchingDirection).dist;\n        if (dist < EPS) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAXDIST) {\n            return MAXDIST;\n        }\n    }\n    return MAXDIST;\n}\n            \n\n//Direction from eye to point\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    float x = fragCoord.x - size.x / 2.0;\n    float y = fragCoord.y - size.y / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(x ,y , -z));\n}\n\n\n//Phong lightig model will be realised\n//calculating normal to point\nvec3 getnormal(vec3 point){\n    return normalize(vec3(\n        SDFscene(vec3(point.x + EPS,point.y,point.z)).dist-SDFscene(vec3(point.x - EPS,point.y,point.z)).dist,\n        SDFscene(vec3(point.x,point.y + EPS,point.z)).dist-SDFscene(vec3(point.x,point.y - EPS,point.z)).dist,\n        SDFscene(vec3(point.x,point.y,point.z + EPS)).dist-SDFscene(vec3(point.x,point.y,point.z - EPS)).dist\n    ));\n}\n\n//How one light point changes colour\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, vec3 point, vec3 eye,\n                          vec3 LPosition, vec3 LIntensity, pointdesc properties) {\n    vec3 L = normalize(LPosition - point);\n    vec3 N = getnormal(point);\n    vec3 V = normalize(eye - point);\n    vec3 R = normalize(reflect(-L, N));\n      \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    //colour and material description\n    vec3 CLobject = vec3(1.0, 1.0, 1.0);\n    vec4 Material = vec4(1.0, 1.0, 1.0, 128.0);\n    CLobject = Colours[properties.colour];\n    Material = Materials[properties.material];\n   \n    if (/*dotLN < 0.0*/ shortDistToSurf(point + 0.003*N, L) <length(LPosition - point)) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return LIntensity * (k_d * dotLN * Material[1] * CLobject);\n    }\n    \n    return LIntensity * (k_d * Material[1] * CLobject * dotLN + k_s * Material[2] * CLobject * pow(dotRV, Material[3]));\n}\n\n//Phong lighting model\nvec3 PhongLighting(vec3 eye, vec3 point){\n    pointdesc Properties = SDFscene(point);\n    \n    //Ambient\n    vec3 CLambient = vec3(0.9, 0.9, 0.9)*Colours[Properties.colour];\n    float AmbientPower = 0.4;                   //Power of AmbientLight\n    vec3 ambient = CLambient * AmbientPower * Materials[Properties.material][0];\n    vec3 colour = ambient;\n    \n    //Light point 1\n    vec3 CLdiffuse1 = vec3(0.3, 0.3, 0.3);\n    vec3 CLspecular1 = vec3(0.5, 0.5, 0.5);    \n    vec3 lightpos1 = vec3(0.0, 5.0, 0.0);\n    vec3 lightInt1 = vec3(1.0, 1.0, 1.0);\n    colour += phongContribForLight(CLdiffuse1, CLspecular1, point,\n                                   eye, lightpos1, lightInt1, Properties);\n    //Light point 2\n    vec3 CLdiffuse2 = vec3(0.3, 0.3, 0.15);\n    vec3 CLspecular2 = vec3(0.5, 0.5, 0.25);    \n    vec3 lightpos2 = vec3(-1.0, sin(iTime)*3.0, -2.0);\n    vec3 lightInt2 = vec3(1.0, 1.0, 1.0);\n    colour += phongContribForLight(CLdiffuse2, CLspecular2, point, \n                                   eye, lightpos2, lightInt2, Properties);\n    return colour;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 4.0+sin(iTime/4.0)*4.0);\n    float dist = shortDistToSurf(eye, dir);\n    \n    if (dist > MAXDIST - EPS) {\n        fragColor = vec4(0.1, 0.1, 0.1, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * dir;\n    \n    vec3 colour = PhongLighting(eye, p);\n    \n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}