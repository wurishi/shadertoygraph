{"ver":"0.1","info":{"id":"Ds3fWS","date":"1697562162","viewed":62,"name":"2d moving light source","username":"tomcat7479","description":"2d moving light source with shadow","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadow","multisampling","lineequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n  移动的2D光源\n*/\n\n#define pixelW 1.0 / iResolution.x\n#define N 4 // 采样点数量 \n#define backgroundColor vec3(0.2, 0.1, 0.0)\n#define shadowColor vec3(0.0)\n#define dx 0.5 * pixelW\n#define dy 0.5 * pixelW\n\n\nstruct Box {\n    float w;\n    vec2 lu;\n    vec2 ru;\n    vec2 ld;\n    vec2 rd;\n    vec3 color;\n} box;\n\nstruct Light {\n    vec2 pos;\n    vec3 color;\n    float brightness;\n    float minIntensity;\n    float maxIntensity;\n} light;\n\nstruct Line {\n    vec2 start;\n    vec2 end;\n} line;\n\nvec2 fix(in vec2 fragCoord, float zoom) {\n    return zoom * (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat interpolateLight(float min, float max, float x) { \t          \n    if (x < min) {\n        return 1.0;\n    }\n    else if (x > max) {\n        return 0.0;\n    }\n    else {\n\n        //linear interpolation of x between min and max\n        float value= (x - min) / (max - min);\n\n        //hyperbolic function: 100/99 * (9x + 1)^2 - 1/99 （曲线类似于正态分布）\n        return (100./99.) / ((9. * value + 1.) * (9. * value + 1.)) - (1./99.);\n    }\n}\n\nBox createBox(float w, vec2 boxCenter, vec3 boxColor) {\n    float h = w / 2.0;\n    vec2 k = vec2(1.0, -1.0);\n    vec2 lu = boxCenter + h * k.yx;\n    vec2 ru = boxCenter + h * k.xx;\n    vec2 ld = boxCenter + h * k.yy;\n    vec2 rd = boxCenter + h * k.xy;\n    Box box = Box(w, lu, ru, ld, rd, boxColor);\n    return box; \n}\n\nLight createLight(vec2 pos, vec3 color, float brightness, float minI, float maxI) {\n    Light light = Light(pos, color, brightness, minI, maxI);\n    return light;\n}\n\nvec2 intersectPoint(Line line_0, Line line_1) {\n    float slope_0, slope_1, x, y;\n    \n    if (line_0.start.x == line_0.end.x) {     \n        //slope_0 is infinite\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n        \n        x= line_0.start.x;\n        y= slope_1 * x + line_1.start.y;\n        \n    } else if (line_1.start.x == line_1.end.x) {\n        //slope_1 is infinite\n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        \n        x= line_1.start.x;\n        y= slope_0 * (x - line_0.start.x) + line_0.start.y;\n        \n    } else {\n        slope_0= (line_0.start.y - line_0.end.y) / (line_0.start.x - line_0.end.x);\n        slope_1= (line_1.start.y - line_1.end.y) / (line_1.start.x - line_1.end.x);\n\n        if (slope_0 != slope_1) {\n\t\t\t\n            //calculate y-intercept of line_1 based on line_0.start\n            float b= slope_1 * (line_0.start.x - line_1.start.x) + line_1.start.y;\n            \n            x= (b - line_0.start.y) / (slope_0 - slope_1);\n            y= slope_0 * x + line_0.start.y;\n            x= x + line_0.start.x;\n            \n\n        } else {\n            return vec2(-1.0);\n        }\n    }\n    \n    return vec2(x, y);\n}\n\nbool inside(in vec2 uv, Box box) {\n    vec2 minValues = vec2( min(box.ld.x, box.ru.x), min(box.ld.y, box.ru.y) );\n    vec2 maxValues = vec2( max(box.ld.x, box.ru.x), max(box.ld.y, box.ru.y) );\n    \n    if (uv.x < minValues.x) return false;\n    if (uv.x > maxValues.x  ) return false;\n    if (uv.y < minValues.y) return false;\n    if (uv.y > maxValues.y  ) return false;\n    return true;\n}\n\nbool inside(Line line, vec2 point) {\n    vec2 minValues = vec2( min(line.start.x, line.end.x), min(line.start.y, line.end.y) );\n    vec2 maxValues = vec2( max(line.start.x, line.end.x), max(line.start.y, line.end.y) );\n    \n    if (point.x < minValues.x) return false;\n    if (point.x > maxValues.x  ) return false;\n    if (point.y < minValues.y) return false;\n    if (point.y > maxValues.y  ) return false;\n    return true;\n}\n\n// 判断两条线段是否相交 (注意线段和射线直线不一样，有左右边界范围，相交点未必在线段的范围内)\nbool isIntersect(Line lineA, Line lineB, Box box) {\n    vec2 point = intersectPoint(lineA, lineB);\n    return inside(lineA, point) && inside(lineB, point);\n}\n\n/**\n   大致的渲染思路：\n      我们计算当前像素点与光源的射线与盒子之间的位置关系，如果被盒子遮挡主，说明这条\n      射线上的路径就是阴影，否则就是光照\n      总结：射线与方形的位置关系是核心\n*/\nvec3 calculateLighting(vec2 pixel, Light light, Box box) {\n    vec3 color = vec3(0.0);\n    Line ldir = Line(pixel, light.pos); // 当前的光线方向\n    Line boxLeftLine = Line(box.ld, box.lu);\n    Line boxRightLine = Line(box.rd, box.ru);\n    Line boxBottomLine = Line(box.ld, box.rd);\n    Line boxUpLine = Line(box.lu, box.ru);\n    bool isIntersect = isIntersect(ldir, boxLeftLine, box) ||\n                       isIntersect(ldir, boxRightLine, box) ||\n                       isIntersect(ldir, boxBottomLine, box) ||\n                       isIntersect(ldir, boxUpLine, box);                  \n    if (isIntersect) {\n        // shadow\n        return shadowColor;\n    } else {\n        // light, 利用插值获取当前像素位置的光照（这里的光源指的是点光源，其光照强度看成环形扩散）\n        return interpolateLight(light.minIntensity, light.maxIntensity, \n                      pow(distance(pixel, light.pos), 0.6)) * light.color * light.brightness;\n    }                \n    return color;\n}\n\n// 多点采样\nvec3 multiSampling(in vec2 uv, Light light, Box box) {\n    vec3 color = vec3(0.0);\n    vec2 point[4];\n    // 对角线采样\n    point[0] = uv + vec2(-dx, dy);\n    point[1] = uv + vec2(dx, dy);\n    point[2] = uv + vec2(dx, -dy);\n    point[3] = uv + vec2(-dx, -dy);\n    for (int i = 0; i < N; i++) {\n        color += calculateLighting(point[i], light, box); // 计算光照阴影\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord, 1.0);\n    Box box = createBox(0.2, vec2(0.5, 0.5), vec3(0.1, 0.63, 0.86));\n    Light light = Light(fix(iMouse.xy, 1.0), vec3(1.0), 0.71, 0.0, 2.0);\n\n    vec3 color = backgroundColor;\n    \n    color += multiSampling(uv, light, box);\n\n    if (inside(uv, box)) {\n        color = box.color;\n    } \n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}