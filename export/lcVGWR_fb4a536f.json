{"ver":"0.1","info":{"id":"lcVGWR","date":"1713107350","viewed":61,"name":"Iterative alpha de-blending 1D","username":"mrboggieman","description":"Each particle moves from one distribution to another by taking random paths towards the target over small steps, based on https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["particles","diffuse","particle","iadb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this buffer creates distribution functions from samples we can use for random sampling\n\n// needs to be defined as a const outside the struct given the glsl lang limitations\nconst int num_samples = 360;\n\nstruct DistSampler {\n    float sum;\n    float[num_samples] samples;\n};\n\nDistSampler new_sampler() {\n    float[num_samples] samples;\n    \n    for (int i=0; i<num_samples; i++) {\n        samples[i] = 0.0;\n    }\n    \n    return DistSampler(0.0, samples);\n}\n\nvoid normalize_sampler(inout DistSampler sampler) {\n    // divide the sample by the total to get their individual contribution\n    for (int i=0; i<num_samples; i++) {\n        sampler.samples[i] /= sampler.sum;\n    }\n}\n\nvoid add_sample(inout DistSampler sampler, in int index, in float val) {\n    sampler.sum += val;\n    sampler.samples[index] = val;\n}\n\nfloat sample_sampler(in DistSampler sampler, in float num) {\n    // now when a random number is given we can just walk through the samples until we arrive at the random number and return the sample value\n    float acc = 0.0;\n\n    for (int i=0; i<num_samples; i++) {\n        float next = sampler.samples[i];\n        acc += next;\n        \n        if (acc >= num) {\n            // interpolate between the previous and current based on the difference\n            return (float(i) + (num - acc) / next) / float(num_samples);\n        }\n    }\n\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame > 0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // we need to transform our distributions such that a random number 0-1 will produce a weighted point\n    DistSampler sampler = new_sampler();\n\n    // we only have 1d distributions so just store the 'from' in the left column and the 'to' in the right column\n    if (int(fragCoord.x) == 0) {\n        for (int i=0; i<num_samples; i++) {\n            add_sample(sampler, i, from(float(i)/float(num_samples)));\n        }\n    } else if (int(fragCoord.x) == int(iResolution.x) - 1) {\n        for (int i=0; i<num_samples; i++) {\n            add_sample(sampler, i, to(float(i)/float(num_samples)));\n        }\n    } else {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n\n    normalize_sampler(sampler);\n\n    // output the samples\n    float mag = sample_sampler(sampler, uv.y);\n\n    fragColor = vec4(vec3(clamp(mag, 0.0, 1.0)),1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float SQRT_2PI = 2.50662827463;\nconst float TAU = 6.28318530718;\nconst float E = 2.718281828;\nconst float EPSILON = 0.00001;\n\nfloat normal_dist(in float x, in float m, in float s) {\n    return pow(E, -0.5*pow((x-m)/s, 2.0)) / (s*SQRT_2PI);\n}\n\nfloat from(in float t) {\n    float x = 4.0*(t - 0.5);\n    //return (normal_dist(x, -0.5, 0.1) + normal_dist(x, 0.5, 0.1)) / 4.0;\n    return (normal_dist(x, -0.9, 0.3) + normal_dist(x, 0.9, 0.3)) / 2.0;\n    //return (sin(t * TAU * 4.0) + 1.0) / 2.0;\n}\n\nfloat to(in float t) {\n    float x = 4.0*(t - 0.5);\n    //return normal_dist(x, 0.0, 1.0);\n    return (normal_dist(x, -1.0, 0.1) + normal_dist(x, 0.0, 0.1) + normal_dist(x, 1.0, 0.1)) / 4.0;\n}\n\n// RNG\nuint hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rand(inout uint state) {\n    return float(hash(state)) / 4294967296.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// this buffer contains our particle positions\n// TODO: pack 4 particles into each coord\n\nconst int num_attempts = 200;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rng = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n\n    if (iFrame == 0) {\n        float pos = texture(iChannel0, vec2(0.0, rand(rng))).r;\n        fragColor = vec4(pos, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    //if the total frames exceeds the alpha the just display their last positions\n    if (iFrame > int(iResolution.x)) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n\n    // the x coord of our particle is going to match the frame number so only need to store the y\n    float prev_val = texelFetch(iChannel1, ivec2(fragCoord), 0).r;\n    float alpha = float(iFrame) / iResolution.x;\n    float next_alpha = float(iFrame + 1) / iResolution.x;\n    \n    float from_min = clamp(prev_val - ((1.0 - prev_val) / (1.0 - alpha)) * alpha, 0.0, 1.0);\n    float from_max = clamp(prev_val - (-prev_val / (1.0 - alpha)) * alpha, 0.0, 1.0);\n    float to_min = clamp(((prev_val - 1.0)/alpha) + 1.0, 0.0, 1.0);\n    float to_max = clamp(prev_val/alpha, 0.0, 1.0);\n    \n    // de-blending, find a random to/from that would blend into this point\n    for (int i=0; i<num_attempts; i++) {\n        // TODO: improve this by not using rejection sampling\n        float to_pos = texture(iChannel0, vec2(1.0, rand(rng))).r;\n        \n        // confirm the random 'to' sample is in the range possible at this position\n        if (to_pos < to_min || to_pos > to_max) {\n            continue;\n        }\n        \n        // project the 'to' position through the point onto the y coord\n        float from_pos = prev_val - ((to_pos - prev_val)/(1.0 - alpha)) * alpha;\n        \n        if (from_pos < from_min || from_pos > from_max) {\n            continue;\n        }\n        \n        // confirm the projected 'from' value is valid\n        if (from(from_pos) > 0.1) {\n            // blend along this direction to form the next position\n            float pos = mix(from_pos, to_pos, next_alpha);\n            fragColor = vec4(pos, 0.0, 0.0, 1.0);\n            return;\n        }\n    }\n    \n    fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int num_samples = 100; // samples to take from each axis\n\n// all we do here is sample our particles and visualise them (one vertical line per frame)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // this is a progressive buffer so only fill one vertical line per frame\n    if (int(fragCoord.x) > iFrame) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    \n    if (int(fragCoord.x) < iFrame) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    float pixelRadius = 0.5 / iResolution.y;\n    \n    // TODO: find a way of sorting the particles and only reading those close to this pixel\n    float col = 0.01;\n    float mag = 0.0;\n\n    // read as many particle as possible (this is the intense bit)\n    for (int i=0; i<num_samples; i++) {\n        for (int j=0; j<num_samples; j++) {\n            float pos = texelFetch(iChannel0, ivec2(i, j), 0).r;\n            \n            mag += (1.0 - step(pixelRadius, distance(pos, fragCoord.y / iResolution.y))) * col;\n        }\n    }\n\n    fragColor = vec4(vec3(clamp(mag, 0.0, 1.0)),1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}