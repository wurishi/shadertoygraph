{"ver":"0.1","info":{"id":"dtScRc","date":"1692094284","viewed":35,"name":"tutotial","username":"BaiShile","description":"inspired from tutorial made by https://www.youtube.com/watch?v=f4s1h2YETNY","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired from tutorial made by https://www.youtube.com/watch?v=f4s1h2YETNY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalize fragCoord as new var uv;\n    // would be xyz if we were in 3d;\n    // avoid nasty stretch from aspect ratio via / ires.y\n    // make uv centered at 0 0 (now its at .5 .5 ) via *2 - iresxy\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    // plots a blue to pink gradient (as uv.x ranges from 0 to 1 now;\n    //fragColor = vec4(uv.x,0.3,1.0,1.0);\n    // repeat gradient 4 times split horizontally\n    //fragColor = vec4(fract(uv.x*4.0),0.3,1.0,1.0);\n    // or verticaly...\n    //fragColor = vec4(fract(uv.y*4.0 + uv.x),0.3,1.0,1.0);\n    // or in a diagonal way\n    //fragColor = vec4(fract(uv.y*4.0 + uv.x*4.0),0.3,1.0,1.0);\n    // or in a curved way \n    //fragColor = vec4(fract(uv.y*4.0 * uv.x*2.0),0.3,1.0,1.0);\n    // repeat in a 4x4 grid\n    //float newx = fract(uv.y*4.0) + fract(uv.x*4.0);\n    // repeat in a 4x4 grid \\ tilted\n    //float newx = fract(uv.y*4.0+uv.x*2.0) + fract(uv.x*4.0);\n    //fragColor = vec4(newx,0.3,1.0,1.0);\n    \n    \n    // make it a 3-way gradient\n    \n//    fragColor = vec4(uv,0.0,1.0);\n    \n    \n\n     uv.x = abs(uv.x *sin(iTime*0.02));\n     uv.y = uv.y *sin(iTime*0.05);\n\n\n    \n    \n    \n    // length fn calculates vec magnitude from origin (now 0 0)\n    float magxy = length(uv*.4);\n    float magxy2 = length(uv*uv.x*0.1);\n    magxy += sin(uv.x*0.001 + iTime*0.02);\n    //so magxy is still a 2d array but its only used on the red color\n    \n    \n\n    \n    // make circle  *(i.e. crete negative values inside 0.5 radius)\n    //magxy-=0.5;\n    \n    // make 4 circles with repeating increasing radius\n    //magxy = sin(magxy*8.0)/8.;\n    // make sin funciton oscilate over time to make circles move\n    //magxy = sin(magxy*8.0 + iTime);\n    // make them move in opposite direction\n    magxy = sin(magxy*128.0 - iTime*0.02);\n    \n    magxy2 = sin(magxy2*55.0 - iTime*0.02);\n    \n    \n    // make parts inside circle positive\n    magxy = abs(magxy);\n    \n    magxy2 = abs(magxy2);\n    // make circle sharp\n    magxy = step(0.4,magxy);\n    \n    magxy2 = step(0.3,magxy2);\n    \n    // make it smoother\n    magxy = smoothstep(0.0, 0.2,magxy);\n    \n    magxy2 = smoothstep(0.0, 0.2,magxy2);\n    \n    \n    \n    fragColor = vec4(max(magxy, magxy2), magxy2,magxy*magxy2,.0);\n    \n\n}","name":"Image","description":"","type":"image"}]}