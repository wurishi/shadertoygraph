{"ver":"0.1","info":{"id":"DtGfz3","date":"1702765098","viewed":22,"name":"ray marching cellular division","username":"userman","description":"my first implementation of ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blobs","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DISTANCE = 0.1;\nconst float MAX_DISTANCE = 200.0;\nconst float EPSILON = 0.00001;\n\n// xyz as the center point of the sphere, and w as the radius.\n\nfloat[40] spheres = float[40](\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0,\n    0.0, 0.0, -50.0, 6.0\n);\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 point, vec4 sphere) {\n    return distance(point, sphere.xyz) - sphere.w;\n}\n\nfloat sceneSDF(vec3 point) {\n    float closest = MAX_DISTANCE;\n    \n    for (int i=3; i<40; i+=4) {\n        vec4 sphere = vec4(\n            spheres[i-3],\n            spheres[i-2],\n            spheres[i-1],\n            spheres[i]\n        );\n        \n        float dist = sphereSDF(point, sphere);\n        \n        closest = smin(dist, closest, 5.0);\n       \n    }\n    \n    return closest;\n}\n\nfloat shortestDistanceToSurface(vec3 point, vec3 direction) {\n    float distanceTraveled = MIN_DISTANCE;\n    \n    for (int i=0; i<MAX_MARCHING_STEPS; i++) {\n    \n        float sceneSDFResult = sceneSDF(point + direction * distanceTraveled);\n        \n        if (MAX_DISTANCE + EPSILON <= sceneSDFResult) {\n            break;\n        }\n        distanceTraveled += sceneSDFResult;\n        \n        if (sceneSDFResult <= EPSILON) {\n            break;\n        }\n        \n    }\n    \n    return distanceTraveled;\n}\n\nvec3 makeRayDirection(float fieldOfView, vec2 resolution, vec2 fragCoord) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 getSurfaceNormal(vec3 p) {\n\tfloat d = sceneSDF(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        sceneSDF(p-e.xyy),\n        sceneSDF(p-e.yxy),\n        sceneSDF(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    modulatePositionWithTime();\n\n    vec3 rayOrigin = vec3(0.0);\n     \n    vec3 rayDirection = makeRayDirection(100.0, iResolution.xy, fragCoord);\n    \n    float dist = shortestDistanceToSurface(rayOrigin, rayDirection);\n   \n    if (dist < MAX_DISTANCE) {\n        \n        vec3 surfaceNormal = getSurfaceNormal(rayDirection * dist);\n        \n        fragColor = vec4(1.) * clamp(dot(surfaceNormal, -normalize(rayDirection)), 0.0, 1.0) * 0.6;\n              \n    }\n}","name":"Image","description":"","type":"image"}]}