{"ver":"0.1","info":{"id":"ltVyWd","date":"1538246538","viewed":221,"name":"DCT lookup refresh","username":"BigotedSJW","description":"trying to fix syntax errors and refactor https://www.shadertoy.com/view/lllfWn, which used to work fine but will not compile anymore\n\nedit: successfully refactored! but it's slow.\nfurther edit: switch case makes it faster (!?)","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","discreetcosinetransform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//struct DCT { lowp int[64] c;};\n\n//values grabbed using JPEGSnoop http://www.impulseadventure.com/photo/jpeg-snoop.html\n const lowp int[] zeroDCT = int[64](  //tweaked DC, too bright\n  192,   220,  -108,   300,  -320,    16,  -100,  -120,\n  185,    -5,    24,   168,   -10,   -46,   -96,   -22,\n -306,   -45,  -156,  -170,    64,  -184,    84,     0,\n  198,   126,  -108,  -180,  -160,    35,   160,   -50,\n  -63,     0,  -135,  -132,   135,    44,     0,   -62,\n  170,     0,  -330,   -26,    96,  -168,   -45,     0,\n  -80,   -26,    93,    35,   -41,   -48,    48,   120,\n   58,    37,  -152,   -78,     0,   -40,    41,     0);\n    \n const lowp int[] oneDCT = int[64](\n  -256,  324, -396, -396,  -30,  208,  120,  -72,\n  -25,   35,  -60, -224,  -40,   92,  -24,  -22,\n    6,    0,   84,  140,  -16, -115,  -56,    0,\n  102,   42,  -72,  -48,    0,   35,   32,    0,\n -224, -117,   45,  -22,   27,   44,    0,   31,\n  180,   42,  -66,  104,   32,    0,   90,    0,\n -240, -130,    0,  -70,   41,   96,   48,   40,\n   87,    0,  -38,   78,   45,    0,   41,    0);\n\nconst lowp int[] twoDCT = int[64](\n  192,  292, -300,  144,  -30, -256,   20,   24,\n   60,  -30, -120,  -16,   30,  -69,  -48,   44,\n   30,   30,   24,   40,   48,    0,  -56,  -66,\n  228,  224,   45,  -48,  -80, -105,  -64,  -25,\n -224,    9,  -60, -440,  -27,  132,  -82,   93,\n  210,   28, -286, -130,  128,   84,    0,   37,\n -180, -156,    0,   70,    0,  -48,    0,    0,\n  -29,    0,    0, -117, -135,    0,   41,    0);\n\nconst lowp int[] threeDCT = int[64](\n  -60,  180, -384,  186,   30, -288,  -20,   48,\n  135,   20,  -78,   48,   10,  -46,    0,   22,\n   -6,  145,   84, -170,  -48,    0, -112,  -44,\n  216,  147,   -9,   24,  -20, -105,  -64,  -25,\n -161,  -72, -105, -242,   27,  132,    0,   62,\n  120,  112, -242, -390,   32,   84,  -90,   74,\n -100,  -78,   62,  105,    0,    0,   48,  -40,\n  -87, -148, -114,    0,  -45,  -40,    0,    0);\n    \nconst lowp int[] fourDCT = int[64](\n  156,    0, -460,  318,  -60, -144,   60,  -24,\n  155,   90, -168,  -24,    0, -115,  120,  -22,\n -300, -185, -120, -140,  112,  138,    0,  -66,\n  102, -133, -144,   96,  100,  105,  -32,  -50,\n    0,  135,  180,   44,   54,   44,  -82,  -62,\n  -20,  -84,   22,  156,   32,  -84,  -90,  -74,\n -220,    0,   62,    0,  -41, -192,   48,   40,\n  232,    0,  -76,  -78,  -90,  120,  -82,    0);\n\n\nconst lowp int[] fiveDCT = int[64](\n  -96,  312, -244,  228,   30, -240,    0,    0,\n  215,  180,   54,   48,   30,   46,   24,  -22,\n   30,  190,   84, -200,  -16,  115,  -56,  -44,\n  198,    7,  -54,  168,  -40, -105,   64,  -50,\n -161, -288, -105,  110,  -27,    0,  164,    0,\n  250,   56, -264, -130,    0,  -42,    0,   37,\n  160,  104,    0,   70,   41,    0,   48,    0,\n  145,   74, -190, -195,   45,   40,  -41,   40);\n  \nconst lowp int[] sixDCT = int[64](\n  -30,  436, -168,   60,    0, -224,  -60,   48,\n   15,   80,   -6, -144,  -20,   69,   24,   66,\n -252, -170, -156, -290,  -32,  115,   28,   66,\n  192,  -63, -189,  132,   40, -105,   32,   25,\n    0,  -72, -120,   22,  135,   88,   41,   62,\n  180,   98, -220, -182,  160,   84,  -90,   74,\n -100,  -52,  155,  245,   82,   48,   48,  -40,\n  -29,  -37,   38,   78,    0,    0,  -41,  -40);\n  \nconst lowp int[] sevenDCT = int[64](\n -126,  196, -376,  -12,   60,   16,   80,  -48,\n  340,   65,  -18,  368,   20, -253,    0,  -22,\n  120,  105,  138,  140,  -80,  -92,   28,  -22,\n  210,  210,  -63, -264,  -60,  175,   96,  -50,\n    0,   36,  -30,  -66,   54,   44,  -41,    0,\n   60,  -14, -154,  -78,   64,   42,    0,    0,\n  -40,  -78,  -31,    0,  -41,    0,   48,    0,\n    0,  -37,  -38,  -39,  -90,   40,  123,    0);\n\n//I wonder if all x & y symetrical blocks have 0 right down the middle\nconst lowp int[] eightDCT = int[64](\n  252,  380, -248,  234,    0, -368, -100,    0,\n  175,   75,  -42,   64,    0,  -69,  -24,    0,\n -168,  -55,  -48, -210,    0,   92,  -28,   22,\n  150,   63,  -54,   12,    0,  -70,  -32,    0,\n -126,  -36,  -90, -242,    0,   88,  -41,   31,\n  100,   84, -286, -416,    0,   42, -135,   74,\n  -60,  -52,  124,  140,    0,    0,   48,  -40,\n   29,    0,   38,   78,    0,  -40,    0,    0);\n\nconst lowp int[] nineDCT = int[64](\n -126,  232, -368,  126,    0, -256,  -60,  -48,\n  290,  115,  -12,  192,  -20, -184,    0,   22,\n -108,  115,  120, -190,  -16,   69,  -84,   22,\n  -24,  -42, -189, -180,  100,   70,  -64,   50,\n  -63,  -99, -120, -110,  -54,    0,   41,   31,\n  190,  182, -154, -338,  -96,   42,  -45,  -74,\n -100,  -52,    0,   35,  123,   48,  -48,   40,\n  -58,    0,  114,   78,  -45,  -40,   41,    0);\n\nconst lowp int[] zigzag = int[64](\n  0,   1,   8,  16,   9,   2,   3,  10,\n 17,  24,  32,  25,  18,  11,   4,   5,\n 12,  19,  26,  33,  40,  48,  41,  34,\n 27,  20,  13,   6,   7,  14,  21,  28,\n 35,  42,  49,  56,  57,  50,  43,  36,\n 29,  22,  15,  23,  30,  37,  44,  51,\n 58,  59,  52,  45,  38,  31,  39,  46,\n 53,  60,  61,  54,  47,  55,  62,  63);\n\n//would this be by refrence or by value? e.g have I in effect declared 1280 integers instead of 640?\n//edit: looks to be by value\n//const DCT[10] dcts = DCT[10](\n//    DCT(zeroDCT), DCT(oneDCT), DCT(twoDCT), DCT(threeDCT), DCT(fourDCT),\n//    DCT(fiveDCT), DCT(sixDCT), DCT(sevenDCT), DCT(eightDCT), DCT(nineDCT)); \n\nlowp vec4 sampleFixedResBuffer(vec2 uv){\n    vec2 bounds = 16.0/iResolution.xy;\n\treturn texture(iChannel0, fract(uv)*bounds);\n}\n\nlowp float sampleDCT(vec2 uv, ivec2 freq){\n\tvec2 samplepos = fract(uv)*0.5*vec2(freq);\n    return sampleFixedResBuffer(samplepos).r;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 2).\n    // upper left as 0, 0\n    float centerX = -1.21875 * iResolution.x/iResolution.y;\n    vec2 uv = vec2(centerX, 2.0) - fragCoord/iResolution.y * mat2(-3., 0., 0., 3.0);\n\n    lowp int level = int(64.*clamp(abs(3.*fract(iTime*0.5) - 2.),0.0,1.0));\n    lowp int which = int(iTime*0.5 + 1./3.) % 10;\n\n    //this is a whole lot faster than using a nested array via a struct. Strange.\n    lowp int[64] dctmat;\n    switch(which){\n     \tcase 0: dctmat = zeroDCT; break;\n        case 1: dctmat = oneDCT; break;\n        case 2: dctmat = twoDCT; break;\n        case 3: dctmat = threeDCT; break;\n        case 4: dctmat = fourDCT; break;\n        case 5: dctmat = fiveDCT; break;\n        case 6: dctmat = sixDCT; break;\n        case 7: dctmat = sevenDCT; break;\n        case 8: dctmat = eightDCT; break;\n        case 9: dctmat = nineDCT; break;\n    }\n     \n    lowp float val = float(dctmat[0])/1024.;\n    \n    if( max(uv.x, uv.y) < 1. && min (uv.x, uv.y) > 0.){\n        for(lowp int i=1; i<64; i++){\n            if(level < i) break;\n            lowp int elem = zigzag[i]; //not needed; order independent, but it does give it pop\n            ivec2 pos =\tivec2( elem & 7, elem  >> 3); //pretend 64 entry array is an 8x8 array\n            lowp float weight = float(dctmat[elem])/1024.;\t\n            val += weight * sampleDCT(uv, pos);\n        }\n    } else {\n        lowp int elem = zigzag[level];\n    \tivec2 pos =\tivec2( elem & 7, elem  >> 3);\n        lowp float weight = float(dctmat[elem])/1024.;\n        val = abs(weight) * (0.5 + 0.5*sampleDCT(uv, pos));\n    }\t\n    \n   fragColor = vec4( vec3(val\n       \t//mix(vec3(val), //for checking dimensions/direction\n        //    vec3(1.0, 0.0, 0.0),\n        /*    vec3(btmEdge+rightEdge)*/ ), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define twoPi   6.283185307f\n//based on https://en.wikipedia.org/wiki/Discrete_cosine_transform#/media/File:DCT-8x8.png\n// this is cell [2,2] in that matrix, or row 3 column 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord/16.0f;\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy); \n    if (iFrame <= 20){\n     \tvec2 lookup = cos(uv*twoPi);\n        fragColor = vec4(lookup.x*lookup.y, lookup, 1.0f); \n    }\n}\n\n//first person to reproduce Lena.jpg in a pixel shader wins...nothing","name":"Buffer A","description":"","type":"buffer"}]}