{"ver":"0.1","info":{"id":"clVSW3","date":"1686420334","viewed":457,"name":"Single Pass Field Flow","username":"myth0genesis","description":"This is an effort inspired by MartinRGB's recent post on [url=https://www.shadertoy.com/view/DttSRB]vector flow[/url]. I needed an effect like this that could run in a single pass on a mobile device, so here are the fruits of my effort...","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["flow","field","vector","pass","single"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n\n// It turns out that davidar's wind flow map effect https://www.shadertoy.com/view/4sKBz3\n// only needs a single buffer for every stage of the simulation\n// without any additional overhead, provided you're okay with sacrificing\n// the ability to choose any color you want for the particles and tracers.\n// I used a modified version of nimitz's FBM https://www.shadertoy.com/view/3l23Rh for the field,\n// normalized from -1.0 to 1.0 and sans some of the frequency-wise scaling, to drive the particles' velocities,\n// as it can give you a lot of variation with very few iterations, which enabled the ability\n// to sample a larger area without a performance hit.\n// I tried my best to regulate the speed (via frmAdj) in order to prevent pixels from traveling\n// outside of the sample area or from moving too fast if the frame rate is either\n// too low or too high.\n\n// Click to push pixels outward.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2023 myth0genesis\n\n// Feel free to modify the number of iterations in the FBM function.\n// ztot and iztot will compensate for it and normalize the result from -1.0 to 1.0.\nconst int iters = 2;\nconst float ztot = 0.5 * (2.0 - 1.0 / pow(2.0, float(iters) - 1.0));\nconst float iztot = 1.0 / ztot;\n\n// Noise speed and position scale.\nconst float tScale = 0.275;\nconst float scale = 3.5;\n\n// Particle velocity.\nconst float pVel = 0.6;\n\n// Tracer decay rate.\nconst float decay = 0.01;\n\n// Particle spawn rate.\nconst float spawnRate = 0.00005;\n\n// Distance (in pixels) sampled around point.\nconst int smpDst = 2;\n\n// The amount of velocity added by clicking.\nconst float impulse = 15.0;\n\nconst uvec4 shft = uvec4(14U, 15U, 16U, 17U);\nconst float imf = 1.0 / float(0xFFFFFFFFU);\n\nconst mat3 m3 = mat3( 0.3338,  0.56034, -0.71817,\n                     -0.87887, 0.32651, -0.15323,\n                      0.15162, 0.69596,  0.61339) * 1.93;\n\nfloat tm;\nvec2 invRes;\nfloat frmAdj;\n\n// My own 128-bit bijective hash https://www.shadertoy.com/view/mstXD2\nvec4 bjhash128(vec4 p0) {\n    uvec4 p = floatBitsToUint(p0);;\n    p ^= p >> shft;\n    p *= uvec4(0xEAF649A9U, 0x6AF649A9U, 0x050C2D35U, 0xAAF649A9U);\n    p ^= p.yzwx ^ p.zwxy;\n    p ^= p >> shft.yzwx;\n    p *= uvec4(0x21F0AAADU, 0x0D0C2D35U, 0xE8F649A9U, 0xD30332D3U);\n    p ^= p.yzwx ^ p.zwxy;\n    return vec4(p ^ p >> shft.wxyz) * imf;\n}\n\n// nimitz's gyroid-based FBM technique https://www.shadertoy.com/view/3l23Rh\nvec2 gFBM(vec3 p0) {\n    vec3 p1 = p0 + vec3(1385.382, 2769.299, 7631.838);\n    float d0 = 0.0;\n    float d1 = 0.0;\n    p0.z -= tm;\n    p1.z -= tm;\n    \n    // Note: Changing z's initial value without correcting\n    // for it will denormalize the field's return value.\n    float z = 1.0;\n    \n    float prd = 1.0;\n    for(int i = 0; i < iters; i++) {\n        p0 += sin(p0.yzx * prd);\n        p1 += sin(p1.yzx * prd);\n        d0 += abs(dot(cos(p0), sin(p0.zxy)) * z);\n        d1 += abs(dot(cos(p1), sin(p1.zxy)) * z);\n        z *= 0.5;\n        prd *= 1.5;\n        p0 = p0 * m3;\n        p1 = p1 * m3;\n    }\n    return (vec2(d0, d1) - ztot) * iztot;\n}\n\n// Much of the code in sc(), ss(), and mainImage() is derived from davidar's\n// wind flow map https://www.shadertoy.com/view/4sKBz3\nvec2 sc(vec2 pos) {\n    for(int i = -smpDst; i <= smpDst; i++) {\n        for(int j = -smpDst; j <= smpDst; j++) {\n        \n            // These two lines subtract the current fragCoord's position (pos) from the sum\n            // of the previous frame's pixel coordinate and its velocity at the sampled point (res)\n            // which is stored in the .xy component of the buffer to get a velocity vector\n            // relative to the sampled point, then checks whether that vector points to the\n            // center of the current pixel or not.\n            vec2 res = texture(iChannel0, (pos + vec2(i,j)) * invRes).xy;\n            if(all(lessThan(abs(res - pos), vec2(0.5)))) return res;\n        }\n    }\n    return vec2(0.0);\n}\n\nvec3 ss(vec2 pos, vec2 scr) {\n    vec2 uv0 = pos * invRes.x;\n    \n    vec2 uv1 = scale * (scr - 0.5 * iResolution.xy) * invRes.y;\n    \n    float frame = float(iFrame);\n    vec4 hash = bjhash128(vec4(pos, frame, 1.738765));\n    \n    // This adds random particles with a random initial velocity offset.\n    scr = (hash.w <= spawnRate * frmAdj * 800.0 / iResolution.x) ? (pos + hash.xy) : scr;\n    \n    // The velocity field.\n    vec2 v = gFBM(vec3(uv1, -3875.27)) * pVel * frmAdj;\n    \n    // Mouse velocity offset when clicked.\n    if (iMouse.z > 0.0) {\n        vec2 mousePos = iMouse.xy * invRes.x;\n        float md = distance(mousePos, uv0);\n        float vFac = smoothstep(0.2, 0.0, md);\n        v = mix(v, (uv0 - mousePos) * impulse, vFac);\n    }\n    \n    // This just adds the position and velocity of the particle that will move into the current pixel to its new velocity.\n    // Every on-screen particle at this point except for the one occupying the bottom-leftmost pixel\n    // will have a value greater than zero and thus will persist into the next frame,\n    // and likewise the resulting sum of the particle's position and its velocity and the new velocity will\n    // always be greater than 1.0, which, when put into a vector whose .b component is 1.0, makes it white.\n    return (any(greaterThan(scr, vec2(0.0)))) ? vec3(scr + v, 1.0) : vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    frmAdj = min(1.0, 144.0 * iTimeDelta);\n    tm = iTime * tScale;\n    invRes = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    // Tracer state is calculated here. Decay by a small amount every frame\n    // until it reaches zero.\n    float r = texture(iChannel0, uv).z - decay * frmAdj;\n    \n    vec2 scRes = sc(fragCoord);\n    r = (any(greaterThan(scRes, vec2(0.0)))) ? 1.0 : clamp(r, 0.0, 1.0);\n    vec3 ssRes = ss(fragCoord, scRes);\n    \n    // The color of the tracer is added to the current frame's color.\n    fragColor = vec4(ssRes + vec3(0.0, 0.0, r), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}