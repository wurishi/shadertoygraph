{"ver":"0.1","info":{"id":"mddyDj","date":"1695513062","viewed":38,"name":"Moving Shadows ","username":"xXx_T0SHIII_xXx","description":"I was struggling to understand how shadows would get calculated for a specific light source for a more complex scene so I decided to simplify everything to figure it out and then transfer the right knowledge back to the more complex project. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.0\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define FOG_DEPTH 20.\n\n#define ZERO min(iFrame,0)\n\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\nmat2 Rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat PlaneSDF(vec3 p,vec3 rot, float modifier)\n{\n    return dot(p,normalize(rot)) - modifier;\n}\nfloat BoxSDF( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\nvec2 Map(vec3 p)\n{\n    vec2 map = vec2(0.,0.);\n    float scale = 1.;\n    vec2 plane = vec2(PlaneSDF(p,vec3(0,1.,0),0.),0.5);\n    \n    vec3 bPos = vec3(0,1,0);\n    vec3 blength = vec3(.1,1.,1.);\n    vec3 bP = p - bPos;\n    vec2 b = vec2(BoxSDF(bP,blength),1.5);\n    \n    vec3 bPos2 = vec3(0,1,3);\n    vec3 bP2 = p - bPos2;\n    vec2 b2 = vec2(BoxSDF(bP2,blength),1.5);\n    \n    vec3 bPos3 = vec3(0,1,-3);\n    vec3 bP3 = p - bPos3;\n    vec2 b3 = vec2(BoxSDF(bP3,blength),1.5);\n    \n    map = opU(b,b2);\n    map = opU(map,b3);\n    map = opU(plane,map);\n    return map;\n}\nvec3 Transform(vec3 p)\n{\n    return p;\n}\nvec2 Raymarch(vec3 ro, vec3 rd) {\n\tfloat Depth = MIN_DIST;\n    vec2 res = vec2(0.0);\n    float id = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = Transform(ro + rd*Depth);\n        res = Map(p);\n        Depth += res.x;\n        id = res.y;\n        if(Depth>MAX_DIST || abs(res.x)<SURF_DIST) break;\n    }\n    return vec2(Depth,id);\n}\nvec3 GetNormal(vec3 p) {\n\tvec2 d = Map(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d.x - vec3(Map(p-e.xyy).x,Map(p-e.yxy).x,Map(p-e.yyx).x);\n    return normalize(n);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 2.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        vec2 d = Map( pos + h*nor );\n        occ += (h-d.x)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        vec3 offs = vec3(.1,.1,0.1);\n        vec2 h = Map((ro + rd*t + offs));\n        res = min( res, smoothstep(0.0,1.0,k*h.x/t) );\n\t\tt += clamp( h.x, 0.01, 0.25 );\n        if( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\nfloat GetLight(vec3 p, vec3 lightPosition) {\n    vec3 lightPos = lightPosition;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = Raymarch(p+n*SURF_DIST*1000., l);\n    if(d.x < length(lightPos-p))\n    {\n        dif*=softshadow(p,l,0.,-18.);\n    }\n    return dif;\n}\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = p+f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i-p);\n    return d;\n}\n\nvec3 render(vec3 ro,vec3 rd)\n{\n    vec3 col = COLOR_BACKGROUND;\n    vec2 res = Raymarch(ro,rd);\n    float id = res.y;\n    vec3 p = Transform(ro + rd * res.x);\n    \n    vec3 lightPos = vec3(sin(iTime)*3.,2,cos(iTime)*3.);\n    vec3 n = GetNormal(p);\n    \n    float AO = calcAO(p,n);\n    float dif = GetLight(p,lightPos);\n    float fog = res.x/80.;\n    \n    if(id > 3.)\n    {\n        vec3 colXZ = texture(iChannel2, p.xz*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel2, p.yz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel2, p.xy*.5+.5).rgb;\n\n        n = abs(n);\n\n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    } \n    else if(id > 1.)\n    {\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n\n        n = abs(n);\n\n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n\n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    } \n    else if(id > 0.)\n    {\n        vec3 colXZ = texture(iChannel1, p.xz*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel1, p.yz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel1, p.xy*.5+.5).rgb;\n\n        n = abs(n);\n\n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    }\n    col *= dif;\n// Courtesy of Theron for using this to help explain how shading is supposed to work lol\n//col = mix(col*AO*exp(-4.*Shadows),vec3(.3),1.-exp(-fog));\n    col = mix(col*AO,vec3(1.5),1.-exp(fog*.02));\n//Gamma Correction\n    //col = pow( col, vec3(1.0/2.2));\n    col = max(col,vec3(0.));\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Normalized pixel coordinates (Centered)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n//Init camera\n    vec3 ro = vec3(4.,9.,-7.);\n    ro.yz *= Rotate(-m.y*3.14+1.);\n    ro.xz *= Rotate(-m.x*6.2831);\n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n    vec3 rendered = render(ro,rd);\n// Output to screen\n    fragColor = vec4(rendered,1.0);\n}","name":"Image","description":"","type":"image"}]}