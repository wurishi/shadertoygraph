{"ver":"0.1","info":{"id":"X3dGW7","date":"1716567725","viewed":147,"name":"Cone Marching 2D","username":"chickenlegs","description":"A 2D visualization of cone marching. This shader is used in an article I made explaining cone marching in Three.js https://medium.com/@nabilnymansour/cone-marching-in-three-js-6d54eac17ad4","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","conemarching"],"hasliked":0,"parentid":"Nd3cDn","parentname":"Rotating circles illusion"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Settings\n#define STEPS 10\n#define FOV 20.\n#define MAX_DIS 50.\n\n// Helpers\n#define PI 3.1415926538\n\nfloat gt(float v1, float v2)\n{\n    return step(v2,v1);\n}\n\nfloat lt(float v1, float v2)\n{\n    return step(v1, v2);\n}\n\nfloat between(float val, float start, float end)\n{\n    return gt(val,start)*lt(val,end);\n}\n\nfloat eq(float v1, float v2, float e)\n{\n    return between(v1, v2-e, v2+e);\n}\n\nfloat s_gt(float v1, float v2, float e)\n{\n    return smoothstep(v2-e, v2+e, v1);\n}\n\nfloat s_lt(float v1, float v2, float e)\n{\n    return smoothstep(v1-e, v1+e, v2);\n}\n\nfloat s_between(float val, float start, float end, float epsilon)\n{\n    return s_gt(val,start,epsilon)*s_lt(val,end,epsilon);\n}\n\nfloat s_eq(float v1, float v2, float e, float s_e)\n{\n    return s_between(v1, v2-e, v2+e, s_e);\n}\n\nfloat dot2(vec2 v) {\n    return dot(v, v);\n}\n\n// SDFs from https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 ) return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// Render functions for SDFs\nfloat circleRender(vec2 p, float r) {\n    return s_lt(length(p), r, 0.005);\n}\n\nfloat hollowCircleRender(vec2 p, float r, float t) {\n    return s_between(length(p), r-t, r, 0.005);\n}\n\nfloat segmentRender(vec2 p, vec2 a, vec2 b, float w) {\n    return s_lt(sdSegment(p, a, b), w, 0.005);\n}\n\nfloat scene(vec2 xy) {\n    float s1 = sdCircle(xy-vec2(1,1), 0.5);\n    float s2 = sdCircle(xy-vec2(-1,-1), 0.5);\n    float heart = sdHeart(xy-vec2(-1,0.5));\n    float moon = sdMoon(xy-vec2(-1,-1), 0.5, 0.75, 0.6);\n    return min(s1, min(s2, min(heart, moon)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Getting values\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Setting up view port\n    float zoom = 8.;\n    vec2 zoomCenter = vec2(0., 0.);\n    float viewPortCenter = 0.5;\n    float ratio = iResolution.y/iResolution.x;\n    \n    // Establishing screen xy values\n    vec2 xy = (uv - viewPortCenter) * zoom + zoomCenter;\n    xy = vec2(xy.x, xy.y*ratio);\n    \n    // Establishing mouse xy values\n    mouse = (mouse - viewPortCenter) * zoom + zoomCenter;\n    mouse.y *= ratio;\n    \n    \n    // Establishing base xy values\n    vec2 current = vec2(sin(iTime),cos(iTime));\n    //vec2 current = vec2(0.5,-0.5);\n    \n    vec3 col = vec3(0);\n    \n    // Cone center definition\n    vec2 crd = normalize(mouse - current); // cone ray direction \n    vec2 crdPerp = vec2(-crd.y, crd.x); // vector perpendicular to cone ray direction\n    vec2 cro = current; // cone ray origin\n    \n    // current position\n    col.r += circleRender(cro-xy, 0.1);\n    \n    // Render Scene\n    float sceneDis = scene(xy);\n    col += sin(sceneDis*100.)*0.2;\n    col += s_lt(sceneDis, 0., 0.005);\n    \n    col = max(col, vec3(0));\n    \n    // tan fov\n    float tanFov = tan((FOV * PI/180.)/2.);\n    \n    \n    // SDF Inflation visualization from @elenzil\n    float distFromPoint = length(cro - xy);\n    float sceneDisInflated = sceneDis - distFromPoint * tanFov;\n    vec3 inflateCol = vec3(0.4, 0.8, 0.9);\n    col += inflateCol * 0.2 * smoothstep(8.0/iResolution.y, 0.0,    (sceneDisInflated) - 2.0/iResolution.y);\n    col += inflateCol * 1.0 * smoothstep(8.0/iResolution.y, 0.0, abs(sceneDisInflated) - 2.0/iResolution.y);\n    \n    // Cone marching\n    float d = 0.;\n    float cd; // current distance\n    float ccr; // current cone radius\n    vec2 p;\n    for (int i = 0; i < int(STEPS); i++) {\n        p = cro + d * crd;\n        cd = scene(p);\n        ccr = (d * tanFov);\n\n        col.g += circleRender(p-xy, 0.025);\n        col += hollowCircleRender(p-xy, cd, 0.01);\n\n        col.g += segmentRender(xy, p + cd * crdPerp, p - cd * crdPerp, 0.01);\n\n        if (cd < ccr || d > MAX_DIS) break;\n        d += cd;\n    }\n    \n    col.r += segmentRender(xy, cro, p, 0.01);\n\n    if (d < MAX_DIS) col.b += circleRender(p-xy, 0.05);\n\n    \n    // mouse position\n    col.b += circleRender(mouse-xy, 0.1);\n    \n    // Render Cone\n    vec2 coneLeft = p + ccr * crdPerp;\n    vec2 coneRight = p - ccr * crdPerp;\n\n    col.rb += segmentRender(xy, coneLeft, coneRight, 0.01);\n    col.rgb += segmentRender(xy, cro, coneRight, 0.01);\n    col.rgb += segmentRender(xy, cro, coneLeft, 0.01);\n\n    float coneRadiusInf = 10. * tanFov;\n    vec2 coneEndPointInf = cro + 10. * crd;\n    vec2 coneLeftInf = coneEndPointInf + coneRadiusInf * crdPerp;\n    vec2 coneRightInf = coneEndPointInf - coneRadiusInf * crdPerp;\n\n    col.rg += segmentRender(xy, cro, coneRightInf, 0.01);\n    col.rg += segmentRender(xy, cro, coneLeftInf, 0.01);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}