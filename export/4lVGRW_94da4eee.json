{"ver":"0.1","info":{"id":"4lVGRW","date":"1473811409","viewed":526,"name":"Pathtracing vs. Direct","username":"zackpudil","description":"Was bored at work.\nWASD keys and mouse to move.. Switch back to direct render by moving the camera, or by hitting enter.\n\nWant to add color but ran outta time.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","pathtracing","keyboard","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float f = texture(iChannel1, vec2(0)).x;\n    \n    vec3 col =\ttexture(iChannel0, uv).xyz;\n    if(f > 0.0) {\n        col /= f;\n    }\n    \n    col = pow(col, vec3(1.0/2.2));\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The main texture.\n\nconst float PI = 3.14159265359;\n\nfloat frame;\nvec3 key = vec3(0, 2.6, 2.5); // light position.\n\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat de(vec3 p) {\n\tvec4 q = vec4(p, 1); // the walls\n    vec4 s = vec4(p, 1); // the column in the middle.\n\t\n\tq.xz = abs(q.xz) -  vec2(3.0);\n\tif(q.x > q.z) q.xz = q.zx;\n    \n    s.y -= 3.3;\n        \n\tfor(int  i = 0; i < 5; i++) {\n\t\ts.xyz = abs(s.xyz) - vec3(-0.02, 1.97, -0.02);\n\t\ts /= clamp(dot(s.xyz, s.xyz), 0.4, 1.0);\n        s = 2.0*s - vec4(0.5, 1.0, 0.4, 0.0);\n\n        q.xyz = abs(q.xyz) - vec3(0.8, 0.3, -0.02);\n        q /= clamp(dot(q.xyz, q.xyz), 0.4, 1.0);\n        q = 2.0*q - vec4(2.8, 2.0, 0.2, 0.0);\n        \n\t}\n    \n    float d = length(q.yz)/q.w - 0.02;\n    d = min(d, length(s.xz)/s.w - 0.005);\n    \n    d = min(d, p.y + 1.65);\n    d = min(d, -p.y + 3.0);\n    \n    d = min(d, p.x + 5.0);\n    d = min(d, -p.x + 5.0);\n    \n    d = min(d, p.z + 5.0);\n    d = min(d, -p.z + 5.0);\n\t\n\treturn d;\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.001;\n    float eps = frame > 0.0 ? 0.0001 : 0.0001;\n    \n    for(int i = 0; i < 200; i++) {\n        float d = de(ro + rd*t);\n        if(d < eps || t >= mx) break;\n        t += d*0.25;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(\n        de(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx)\n\t));\n    \n    return n;\n}\n\nvec3 cone(float s) {\n    float a = 3.14159*hash(s + 23.34);\n    float b = 6.28138*hash(s + 93.34);\n    \n    return vec3(sin(a)*sin(b), sin(a)*cos(b), cos(a));\n}\n\nvoid geometryAndLighting(vec3 ro, vec3 rd, float t, \n                         inout vec3 pos, inout vec3 nor, \n                         inout vec3 lig, inout float dis) {\n    pos = ro + rd*t;\n    nor = normal(pos);\n    \n    lig = normalize(key - pos);\n\tdis = length(key - pos);\n}\n\nvec3 material(vec3 pos, vec3 nor) {\n    vec3 mat = vec3(1);\n    \n    if(pos.y > -1.64 && pos.y < 2.99\n      && pos.x > -4.99 && pos.x < 4.99\n      && pos.z > -4.99 && pos.z < 4.99)\n        mat *= vec3(1);\n    else if(pos.y < -1.64 || pos.y > 2.99)\n        mat *= 0.2 + 0.8*mod(floor(pos.x) + floor(pos.z), 2.0);\n\telse if(pos.x < -4.99 || pos.x > 4.99)\n        mat *= 0.2 + 0.8*mod(floor(pos.z) + floor(pos.y), 2.0);\n\telse if(pos.z < -4.99 || pos.z > 4.99)\n        mat *= 0.2 + 0.8*mod(floor(pos.x) + floor(pos.y), 2.0);\n    \n    return mat;\n}\n\n//path-march lighting\nvec3 render(vec3 ro, vec3 rd, float sa) {\n    vec3 col = vec3(0);\n    vec3 mat = vec3(1);\n    \n    for(float b = 0.0; b < 4.0; b++) {\n        rd = normalize(rd);\n        \n        float t = trace(ro, rd, 50.0);\n        if(t < 0.0) {\n            if(b == 0.0) col = vec3(0.15, 0.20, 0.28);\n            break;\n        }\n        \n        float se = sa + 23.2*b + 93.3*frame;\n        \n        vec3 pos, nor, lig;\n        float dis;\n        \n        geometryAndLighting(ro, rd, t, pos, nor, lig, dis);\n\n        vec3 icol = vec3(0);        \n        icol += 0.7*clamp(dot(lig, nor), 0.0, 1.0)\n            *step(0.0, -trace(pos + nor*0.001, lig, dis));\n        \n        mat *= material(pos, nor);\n        \n        col += icol*mat;\n\n        ro = pos;\n        if(hash(se + 12.23) < 0.7) {\n        \trd = nor + cone(se);\n        } else {\n            rd = normalize(reflect(rd, nor)) + cone(se + 3.34)*0.04;\n        }\n\n    }\n    \n    return col;\n}\n\n// direct lighting.\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.15, 0.20, 0.28);\n    \n    float t = trace(ro, rd, 50.0);\n    if(t < 0.0) return col;\n    \n\tvec3 pos, nor, lig;\n    float dis;\n        \n    geometryAndLighting(ro, rd, t, pos, nor, lig, dis);\n    \n    float occ = 0.0, s = 0.005;\n    for(int i = 0; i < 15; i++) {\n        float d = de(pos + nor*s);\n        occ += (s - d);\n        s += s/(float(i) + 1.0);\n    }\n    occ = 1.0 - clamp(occ, 0.0, 1.0);\n    \n    col = vec3(0.1)*occ;\n    \n    float dif = 0.7*clamp(dot(lig, nor), 0.0, 1.0);\n    \n    col += dif*step(0.0, -trace(pos + nor*0.001, lig, dis));\n    \n    col *= material(pos, nor);\n    \n    return col;\n}\n\nmat3 cameraMatrix() {\n    vec2 mo = -1.0 + 2.0*(iMouse.xy - abs(iMouse.zw));\n    mo.y = -mo.y;\n    vec2 rad = mo*PI/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\n// basic raymarcher.\nvec3 calcPixelDirect(vec2 fc, vec3 ro) {\n    vec2 p = (-iResolution.xy + 2.0*(fc))/iResolution.y;\n    vec3 rd = normalize(cameraMatrix()*vec3(p, 1.97));\n    \n    return render(ro, rd);\n}\n\n// monte-carlo path marching.\nvec3 caclPixelPathtrace(vec2 fc, vec3 ro) {\n    float sa = hash(dot(fc, vec2(12.232, 39.343)) + 1920.3*frame);\n    vec2 of = -0.5 + vec2(hash(sa + 23.23), hash(sa + 93.34));\n    \n    vec2 uv = fc/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0*(fc + of))/iResolution.y;\n    \n    vec3 rd = normalize(cameraMatrix()*vec3(p, 1.97));\n    vec3 col = vec3(0);\n    if(frame > 0.0) {\n        col = texture(iChannel0, uv).xyz;\n    \tcol += render(ro, rd, sa);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    frame = texture(iChannel1, vec2(0)).x;\n    \n    vec3 col;\n    vec3 ro = vec3(-0.3, -1, 2) +  texture(iChannel2, vec2(0)).xyz;\n    \n    if(frame > 0.0) {\n        col = caclPixelPathtrace(fragCoord, ro);\n    } else {\n        col = calcPixelDirect(fragCoord, ro);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// determines what the frame should be.  frame as it mimics the iFrame uniform but can be altered.\n\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\n\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_SH\t  = 16.5/256.0;\n\nconst float KEY_EN\t  = 13.5/256.0;\n\nconst float PI = 3.14159265359;\n\nfloat hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nfloat hash(mat3 n) {\n    float r = 0.0;\n    for(int i = 0; i < 3; i++)\n\tfor(int j = 0; j < 3; j++) {\n        r += hash(n[i][j]);\n\t}\n    \n    return r;\n}\n\nmat3 cameraMatrix() {\n    vec2 mo = -1.0 + 2.0*(iMouse.xy - abs(iMouse.zw));\n    mo.y = -mo.y;\n    vec2 rad = mo*PI/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nbool isKeyPressed(float k) {\n    return texture(iChannel1, vec2(k, 0)).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 i = texture(iChannel0, vec2(0)).xy;\n    float s = i.x;\n    float c = i.y;\n    \n    float cc = hash(cameraMatrix());\n    \n    if(isKeyPressed(KEY_W) \n       || isKeyPressed(KEY_A)\n       || isKeyPressed(KEY_D) \n       || isKeyPressed(KEY_S)\n       || isKeyPressed(KEY_SP)\n       || isKeyPressed(KEY_SH)\n       || isKeyPressed(KEY_EN)\n       || iMouse.z > 0.0) {\n        s = -1.0;\n    } else {\n        s += 1.0;\n    }\n    \n    fragColor = vec4(s, cc, 0, 0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// camera.\n\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\n\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_SH\t  = 16.5/256.0;\n\nconst float PI = 3.14159265359;\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.0) ).x > 0.0;\n}\n\nmat3 cameraMatrix() {\n    vec2 mo = -1.0 + 2.0*(iMouse.xy - abs(iMouse.zw));\n    mo.y = -mo.y;\n    vec2 rad = mo*PI/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvec3 cameraPosition() {\n    vec3 p =  texture(iChannel0, vec2(0)).xyz;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 cp = cameraPosition();\n    mat3 cm = cameraMatrix();\n    \n    float speed = 0.1;\n    \n    if(isKeyPressed(KEY_W)) cp += cm[2]*speed;\n    if(isKeyPressed(KEY_S)) cp -= cm[2]*speed;\n    if(isKeyPressed(KEY_A)) cp -= cm[0]*speed;\n    if(isKeyPressed(KEY_D)) cp += cm[0]*speed;\n    if(isKeyPressed(KEY_SP)) cp += cm[1]*speed;\n    if(isKeyPressed(KEY_SH)) cp -= cm[1]*speed;\n    \n    \n    fragColor = vec4(cp, 0.0);\n}","name":"Buf C","description":"","type":"buffer"}]}