{"ver":"0.1","info":{"id":"stdyDN","date":"1660409777","viewed":125,"name":"FTPlus' polar Voronoi diagrams","username":"FTPlus","description":"Experimentation with Voronoi diagrams using a polar coordinate system and arc-length as distance formula.\n\nDrag the dots into the compass to see it in action.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","polarcoordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat draw(float d, float width)\n{\n    float f = min(iResolution.x, iResolution.y);\n    return smoothstep((width + 1.5) / f, (width - 1.5) / f, d);\n}\nfloat detect(sampler2D C, ivec2 I, vec4 base, int range)\n{\n    int count = 0;\n    for (int y = -range; y <= range; ++y)\n    for (int x = -range; x <= range; ++x)\n    {\n        ivec2 P = I + ivec2(x, y);\n        if (x == 0 && y == 0) continue;\n        if (P.x < 0 || P.y < 0\n        || P.x >= int(iResolution.x)\n        || P.y >= int(iResolution.y)) continue;\n        if (texelFetch(C, P, 0) != base)\n            ++count;\n    }\n    return float(count) / float((range + 1) * range * 4);\n}\n\nfloat sdfRay(vec2 V, vec2 I)\n{\n    return length(I - V * (dot(I, V) / dot(V, V)));\n}\nfloat sdfGrid(vec2 divs, vec2 I)\n{\n    float d = infty;\n    float l = length(I);\n    for (float r = 0.; r < 1.00001; r += 1. / divs.x)\n        d = min(d, abs(l - r));\n    for (float a = 0.; a < PI; a += PI / divs.y)\n        d = min(d, sdfRay(vec2(sin(a), cos(a)), I));\n    d = max(max(d, 1. / divs.x - l), l - 1.);\n    return d;\n}\nfloat sdfPoints(vec2 I)\n{\n    float d = infty;\n    for (int i = 0; i < MAX_POINTS; ++i)\n    {\n        vec2 P = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        normalizeCoords(P, iResolution.xy);\n        d = min(d, distance(P, I));\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec4 diagram = texelFetch(iChannel1, ivec2(I), 0);\n    float edge = detect(iChannel1, ivec2(I), diagram, 3);\n    \n    normalizeCoords(I, iResolution.xy);\n    vec2 P = polarCoords(I);\n    \n    O = diagram;\n    O = mix(O, WHITE, smoothstep(0., .25, edge));\n    O = mix(O, OFFWHITE, smoothstep(1., 1.01, P.x));\n    O = mix(O, BLACK, 1. - min(1. - P.x / 10., 1.));\n    float grid = draw(sdfGrid(vec2(5, 6), I), 2.);\n    O = mix(O, GRAY, grid * .35);\n    float points = draw(sdfPoints(I), 20.);\n    O = mix(O, BLACK, points);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool conflict(int index)\n// returns true iff a dragged node would collide with other nodes\n{\n    for (int i = 0; i < MAX_POINTS; ++i)\n    {\n        if (i == index)\n            continue;\n        vec2 P = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        if (distance(P.xy, iMouse.xy) < float(NODE_SIZE))\n            return true;\n    }\n    return false;\n}\n\nbool dragging()\n// returns true iff a nodes is currently being dragged\n{\n    for (int i = 0; i < MAX_POINTS; ++i)\n        if (texelFetch(iChannel0, ivec2(i, 0), 0).z > 0.)\n            return true;\n    return false;\n}\n\nconst float szNode = float(NODE_SIZE);\nconst float sp = szNode * 2.;\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    O = texelFetch(iChannel0, ivec2(I), 0);\n    if (iFrame < 10)\n    {\n        int i = int(I.x);\n        float m = float(MAX_POINTS / 2);\n        O.xy = vec2(sp + (I.x > m ? 0. : sp), szNode + mod(I.x, m) * sp);\n    }\n    \n    if (iMouse.z < 0.) // Mouse up\n        O.z = 0.;\n    else if (!dragging() && iMouse.z > 0. && distance(O.xy, iMouse.xy) < szNode / 2.)\n        O.z = 1.;\n    \n    if (O.z > 0. && !conflict(int(I.x)))\n        O.xy = iMouse.xy;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_POINTS 10\n#define NODE_SIZE 20\n\n#define PI 3.1415926535897932384626433832795\n#define PII 6.283185307179586476925286766559\n\n#define BLACK vec4(vec3(0.), 1.)\n#define WHITE vec4(vec3(1.), 1.)\n#define OFFWHITE vec4(1., .97, .95, 1.)\n#define GRAY vec4(vec3(.25), 1.)\n\n// from https://colorbrewer2.org/\nconst ivec3 Set3[10] = ivec3[10](\n    ivec3(141, 211, 199),\n    ivec3(255, 255, 179),\n    ivec3(190, 186, 218),\n    ivec3(251, 128, 114),\n    ivec3(128, 177, 211),\n    ivec3(253, 180, 98),\n    ivec3(179, 222, 105),\n    ivec3(252, 205, 229),\n    ivec3(217, 217, 217),\n    ivec3(188, 128, 189));\nvec4 color(int i)\n{\n    if (i < 0 || i >= 10)\n        return WHITE;\n    return vec4(vec3(Set3[i]) / 255., 1.);\n}\n\nvoid normalizeCoords(inout vec2 I, in vec2 R)\n{\n    R *= .5;\n    I = (I - R) / min(R.x, R.y);\n}\nvec2 polarCoords(vec2 I)\n{\n    return vec2(length(I), atan(I.y, I.x));\n}\n\nconst float infty = 1. / 0.;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_ITER 50\n#define APPROXIMATE 1\n\nfloat distancePolar(vec2 A, vec2 B)\n{\n    return sqrt(A.x * A.x + B.x * B.x - 2. * A.x * B.x * cos(B.y - A.y));\n}\n\n// approximated arc length between two polar coordinates\nfloat approxArcDistance(vec2 A, vec2 B)\n{\n    float a = abs(B.y - A.y);\n    a = min(a, PII - a);\n    float r = B.x - A.x;\n    return length(vec2((A.x + B.x) * .5 * a, r));\n}\n\n// arc length between two polar coordinates\n// numerical, perhaps there is a closed form but I couldn't be bothered to calculate it\nfloat numArcDistance(vec2 A, vec2 B)\n{\n    float a = abs(B.y - A.y);\n    a = min(a, PII - a);\n    float r = B.x - A.x;\n    \n    float d = 0.;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n        float f1 = float(i) / float(MAX_ITER);\n        float f2 = float(i + 1) / float(MAX_ITER);\n        vec2 P1 = vec2(A.x + f1 * r, A.y + f1 * a);\n        vec2 P2 = vec2(A.x + f2 * r, A.y + f2 * a);\n        d += distancePolar(P1, P2);\n    }\n    return d;\n}\n\n#if (APPROXIMATE)\n    #define arcDistance(A, B) approxArcDistance(A, B)\n#else\n    #define arcDistance(A, B) numArcDistance(A, B)\n#endif\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    normalizeCoords(I, iResolution.xy);\n    vec2 Ip = polarCoords(I);\n    \n    int index = -1;\n    float m = infty;\n    for (int i = 0; i < MAX_POINTS; ++i)\n    {\n        vec2 P = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        normalizeCoords(P, iResolution.xy);\n        vec2 Pp = polarCoords(P);\n        \n        // Ignore points not in the compass\n        if (length(P) > 1.) continue; \n        \n        /**/\n        float d = arcDistance(Ip, Pp);\n        /*/\n        float d = distance(I, P);\n        /**/\n        if (d < m)\n        {\n            m = d;\n            index = i;\n        }\n    }\n    \n    O = color(index);\n}","name":"Buffer B","description":"","type":"buffer"}]}