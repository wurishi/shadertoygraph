{"ver":"0.1","info":{"id":"WlscWS","date":"1607131052","viewed":202,"name":"CRTtest","username":"RoyaleNoir","description":"testing a crt effect, phosphor mask isn't the best","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightPos = vec3(.5, -1.5, 4);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float mask = 1.0;\n    \n    //TODO: Aspect\n    vec2 viewUV = (uv - 0.5) * aspectRatio;\n    vec3 viewPos = vec3(0, 0, warpRadius + viewDist);\n    vec3 viewDir = vec3(viewUV.x, -viewUV.y, -viewDist);\n    \n    vec3 norm;\n    vec3 pos;\n    vec2 mappedUV = traceSphere(normalize(viewDir), vec3(0, 0, warpRadius + viewDist), vec3(0.0), warpRadius, norm, pos);\n    mappedUV.x /= 12.0 / 16.0;\n    \n    float wid = 0.0025;\n    float rad = 0.05;\n    \n    mask = smoothstep(0.5, 0.5-wid, abs(mappedUV.x));\n    mask *= smoothstep(0.5, 0.5-wid, abs(mappedUV.y));\n    \n    float circleMask = smoothstep(rad-wid, rad, length(abs(mappedUV) - (0.5-rad)));\n    circleMask *= smoothstep(0.5-rad-wid, 0.5-rad, abs(mappedUV.y));\n    circleMask *= smoothstep(0.5-rad-wid, 0.5-rad, abs(mappedUV.x));\n    \n    mappedUV += 0.5;\n    \n    // Time varying pixel color\n    vec3 emission = pow(texture(iChannel0, mappedUV).rgb, vec3(2.4));\n    emission = phosphor(emission, mappedUV) * mask * (1.0 - circleMask);\n    \n    vec3 albedo = vec3(0.005) * mix(0.1, 1.0, mask * (1.0 - circleMask));\n    \n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 viewDir2 = normalize(pos - viewPos);\n    \n    vec3 refl = reflect(lightDir, norm);\n    \n    albedo *= max(dot(lightDir, norm), 0.0) * 2.;\n    \n    albedo += pow(max(dot(viewDir2, refl), 0.0), 64.);\n\n    // Output to screen\n    fragColor = vec4(pow(emission + albedo, vec3(1.0/2.2)), 1.0);\n    //fragColor.rgb = pos;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TWOPI radians(360.)\nconst float warpRadius = 2.0;\nconst float viewDist = 2.0;\n\nvec2 aspectRatio = vec2(1.33, 1.0);\n\nvec2 traceSphere(vec3 rayDir, vec3 rayOrigin, vec3 center, float radius, out vec3 norm, out vec3 pos)\n{\n    vec3 offset = rayOrigin - center;\n    \n    //Quadratic Parameters\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(offset, rayDir);\n    float c = dot(offset, offset) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    float t;\n    vec2 uv = vec2(1.0);\n    \n    if(discriminant < 0.0)\n    {\n        t = -1.0;\n    }\n    else\n    {\n        t = (-b - sqrt(discriminant)) / (2.0*a);\n        vec3 intersectPos = rayOrigin + t * rayDir;\n        vec3 centerPos = vec3(0, 0, warpRadius); \n        \n        //https://groups.google.com/d/msg/comp.soft-sys.matlab/zNbUui3bjcA/c0HV_bHSx9cJ\n        float cp_len =\n        length(cross(intersectPos, centerPos));\n        float dp = dot(intersectPos, centerPos);\n        float angle_from_image_center = atan(cp_len, dp);\n    \tfloat arc_len = angle_from_image_center * warpRadius;\n        \n        vec2 square_uv_unit = normalize(vec2(intersectPos.x,\n        -intersectPos.y));\n        \n    \tuv = arc_len * square_uv_unit;\n        \n        norm = normalize(intersectPos - center);\n        pos = intersectPos;\n        \n        uv /= aspectRatio;\n    }\n    \n    return uv;\n}\n\nvec3 phosphor(vec3 col, vec2 uv)\n{\n    float xRes = 320.;\n    float yRes = 240.;\n    \n    float ddx = dFdx(uv.x * xRes);\n    float ddy = dFdy(uv.x * xRes);\n    \n    float gL = 2.0 * length(vec2(ddx, ddy));\n    \n    float rAp = smoothstep(10.0 * gL, -10. * gL, cos(TWOPI * uv.x * xRes + radians(120.)));\n    float gAp = smoothstep(10.0 * gL, -10. * gL, cos(TWOPI * uv.x * xRes));\n    float bAp = smoothstep(10.0 * gL, -10. * gL, cos(TWOPI * uv.x * xRes - radians(120.)));\n    \n    float scan = smoothstep(-10.0 * gL, 10.0 * gL, cos(TWOPI * uv.y * yRes));\n    \n    col *= smoothstep(0.1, 0.9, scan) * 2.;\n    \n    float red = mix(0.0, 0.9, col.r);\n    float green = mix(0.0, 0.9, col.g);\n    float blue = mix(0.0, 0.9, col.b);\n    \n\treturn vec3(red, green, blue) * vec3(rAp, gAp, bAp) * 1.5;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}