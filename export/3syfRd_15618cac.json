{"ver":"0.1","info":{"id":"3syfRd","date":"1607692680","viewed":629,"name":"Single-read smooth noise clouds","username":"cnlohr","description":"An update of toocanzs's clouds with custom noise -> https://www.shadertoy.com/view/tsVBz3 based on a noise algorithm I wanted to iterate on.  https://gist.github.com/cnlohr/d6e9fe34c326ce28430ac6bc1e18d4e8","likes":8,"published":1,"flags":33,"usePreview":0,"tags":["cloudsnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013 (liberally licensed single-lookup smooth noise function modified 2020 <>< CNLohr)\n\n// Clouds: License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Noise:  License CC0, MIT/x11, NewBSD.\n\n//Noise function liberally licensed (CC0, MIT/x11, etc...)\n//More details can be found here:  https://github.com/cnlohr/shadertrixx/tree/main/tanoise\n//Originally based on noise function in original shader, but updated by toocanzs, then fixed.\n\n#define qNoiseZOff vec2(53.0,111.0)\nconst mat3 qNoiseM = mat3(\n  -0.071301, 0.494967, -0.757557,\n  0.494967, 0.388720, 0.303345,\n  -0.757557, 0.303345, 0.497523 );\n  \nfloat noise( vec3 x )\n{\n\tvec3 c = x * qNoiseM;\n\tvec3 p = floor(c);\n\tvec3 f = fract(c);\n\n\t// First level smoothing for nice interpolation between levels. This\n\t// gets rid of the sharp artifacts that will come from the bilinear\n\t// interpolation.\n\tf = f * f * ( 3.0 - 2.0 * f );\n\n\t// Compute a u,v coordinateback in\n\tvec2 uv = ( p.xy + p.z*qNoiseZOff ) + f.xy;\n\tvec2 t = textureLod( iChannel0, vec2( (uv+0.5)/iChannelResolution[0].xy ), 0.0 ).rg;\n\treturn mix( t.r, t.g, f.z )*1.0;\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\n#define MARCH(STEPS,MAPLOD)\\\nfor(int i=0; i<STEPS; i++)\\\n{\\\n   vec3 pos = ro + t*rd;\\\n   if( pos.y<-3.0 || pos.y>2.0 || sum.a>0.99 ) break;\\\n   float den = MAPLOD( pos );\\\n   if( den>0.01 )\\\n   {\\\n     float dif = clamp((den - MAPLOD(pos+0.3*sundir))/0.6, 0.0, 1.0 );\\\n     vec3  lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;\\\n     vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\\\n     col.xyz *= lin;\\\n     col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\\\n     col.w *= 0.4;\\\n     \\\n     col.rgb *= col.a;\\\n     sum += col*(1.0-sum.a);\\\n   }\\\n   t += max(0.05,0.02*t);\\\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;\n\n    MARCH(40,map5);\n    MARCH(40,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    // background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    // sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy + vec2(.4);\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = vec4(texture(iChannel0, uv).xy,0.,1.);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir, ivec2(fragCoord-0.5) );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash( vec2 p ) \n{\n    float h = dot(p,vec2(127.1,311.7));    \n    return fract(sin(h)*43758.5453123);\n}\nfloat rawnoise( in vec2 p )\n{\n    return hash( p ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = rawnoise(fragCoord.xy);\n    float g = rawnoise( mod( fragCoord.xy + vec2(53.0,111.0), vec2(iResolution.xy) ));\n    vec3 c = vec3(r,g,0.);\n    fragColor = vec4(c,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}