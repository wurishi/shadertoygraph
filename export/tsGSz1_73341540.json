{"ver":"0.1","info":{"id":"tsGSz1","date":"1573398297","viewed":121,"name":"sprouts","username":"skaplun","description":"Original - https://twitter.com/adamshmamshon/status/1193466171275796481","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 48\n#define MIN_DIST 0.\n#define MAX_DIST 20.\n#define EPSILON 0.0001\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p){\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\nvec3 getCylAtPos(float yFactor, float time, in float modifier){\n\tyFactor += modifier;\n    float s = cos(yFactor * 1.25 + 2.) + .75 + exp(-10. * yFactor);\n    return  vec3(vec2(fbm1x(yFactor, time),\n                 \t  fbm1x(yFactor + 78.233, time)) * (.5 + .2*yFactor),\n                 \t  .5 + .5 * fbm1x(yFactor + 13.317, time * 2.));\n}\n\nfloat cylinder(in vec3 p, in float r) {\n    float a = abs(sin(atan(p.z, p.x) * 10.)) * .01;\n    return length(p.xz) - r - a;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat world(vec3 p){\n    float modifier = hash12(ceil(p.xz-1.));\n    vec3 mp = vec3(fract(p.x)-.5, p.y, fract(p.z)-.5);\n    vec3 cyl = getCylAtPos(p.y, -iTime, modifier) * vec3(.25, .25, .25 + pow(smoothstep(0., -.9, p.y), 4.) * 4.);\n    return opSubtraction(p.y + 1., opSubtraction(-p.y + 1. - noised(vec3(p.xz * .5, iTime)).x * 1.5, cylinder(mp + vec3(cyl.x, 0., cyl.z), cyl.z)));\n}\n\nfloat march(vec3 eye, vec3 marchingDirection) {\n\tconst float precis = .025;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for( int i=0; i<MAX_MARCHING_STEPS; i++ )\n    {\n\t    float h = world( eye + marchingDirection * t );\n        if( h < precis ) return t;\n        t += h * .75;\n    }\n    return -1.;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)) - world(vec3(p.x - EPSILON, p.y, p.z)),\n        world(vec3(p.x, p.y + EPSILON, p.z)) - world(vec3(p.x, p.y - EPSILON, p.z)),\n        world(vec3(p.x, p.y, p.z  + EPSILON)) - world(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec4 render(in vec2 fragCoord){\n\tvec4 color = vec4(0.);\n    float a = radians(30.);\n    vec3 eye = vec3(10. * sin(a), 5., 10. * cos(a));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    float dist = march(eye, worldDir);\n    if (dist >= 0.) {\n        vec3 p = (eye + dist * worldDir);\n    \tvec3 norm = estimateNormal(p);\n        color = vec4(1.) - pow(abs(dot(norm, worldDir)), .25);\n    }\n    \n    return color;\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += render(fragCoord + vec2(x, y) / float(AA));\n        }\n    \n    fragColor /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{vec3 origin, direction;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n    \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}","name":"Common","description":"","type":"common"}]}