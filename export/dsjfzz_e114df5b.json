{"ver":"0.1","info":{"id":"dsjfzz","date":"1689378702","viewed":72,"name":"Planet Orbit","username":"jeffbustercase","description":"My first try on making planets with 3D SDFs.\nLearned a lot, most of it thanks to iq (and his codes on his site).\n\nOn the Shoulders of Giants..","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["space","planet","orbit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MOUSE_ROTATE_PLANET false\n#define SUN_ROTATION false\n#define ROTATE_CAMERA false\n#define MOUSE_ROT false\n#define ACES true\n#define FILMIC false\n#define TONEMAP_TEST false\n#define AA 2\n\n#define t iTime*0.4\n#define res iResolution\n\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float theta) {\n  float s = sin(theta);\n  float c = cos(theta);\n\n  return mat4(\n    vec4(1.0, 0.0, 0.0,0.0),\n    vec4(0.0,   c,   s,0.0),\n    vec4(0.0,  -s,   c,0.0),\n    vec4(0.0,   0,   0,1.0)\n  );\n}\n\nmat4 rotateZ(float theta) {\n  float s = sin(theta);\n  float c = cos(theta);\n\n  return mat4(\n    vec4( c,   s, 0.0,0.0),\n    vec4(-s,   c,   0,0.0),\n    vec4(0.0,  0,   1,0.0),\n    vec4(0.0,  0,   0,1.0)\n  );\n}\n\nmat4 rotMat(vec3 r) {\n\treturn rotateX(r.x)*rotateY(r.y)*rotateZ(r.z);\n}\n\nvec3 rotateByMouse(vec3 entryPoint)\n{\n\tfloat mf = 10.;\n    float mx = -(iMouse.x/iResolution.x*2.-1.)*mf;\n    float my = (iMouse.y/iResolution.y*2.-1.)*mf*.5;\n    vec2 vv = vec2(mx,my);\n    float v = distance(vv,vec2(0));\n    return (vec4(entryPoint,1.0)*rotMat(vec3(0,v,0))).xyz;\n}\n\nvec3 getPos(int id) {\n\tif(id==2) {\n\t\treturn vec3(0);\n\t} else if (id==0) {\n\t\treturn vec3(0.2,0,0);\n\t} else {\n\t\treturn vec3(-.5,0,0);\n\t}\n}\n\nvec3 pos(vec3 p, int id)\n{\n    return p+getPos(id);\n}\n\nmat4 baseMat(vec3 pos) {\n\treturn mat4(\n        vec4(1, 0, 0, pos.x),\n        vec4(0, 1, 0, pos.y),\n        vec4(0, 0, 1, pos.z),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 posMat(int id) {\n\tvec3 pos = getPos(id);\n\treturn baseMat(pos);\n}\n\n// From IQ Articles page\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n    vec4 x = texture( s, p.yz );\n    vec4 y = texture( s, p.zx );\n    vec4 z = texture( s, p.xy );\n    \n    // blend weights\n    vec3 w = pow( abs(n), vec3(k) );\n    // blend and return\n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\n\n\n\n// Free real state?\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n// ..Somehow..\nvec3 tonemapFilmic(const vec3 color) {\n\tvec3 x = max(vec3(0.0), color - 0.004);\n\treturn (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\n\nfloat sdf(vec3 p, int id) {\n\t\n    if(id == 0)\n    {\n        return length(p)-.75;\n    } else \n    {\n        return length(p)-.326;\n    }\n}\n\nvec3 rotVec(int id) {\n\tif(id == 0) {\n\t\treturn vec3(0,0.5*t,0);\n\t} else {\n\t\treturn vec3(0.0,0.2*t,0);\n\t} \n}\n\nvec3 rotate(vec3 rotV, vec3 p) {\n\treturn ((rotMat(rotV)) * vec4(p,1.0)).xyz;\n}\n\nvec3 translate(vec3 p, int id) {\n\tif(id == 0) {\n\t\treturn vec3(0)+p;\n\t} else  {\n\t\treturn vec3(1.5,0,1.5)+p;\n\t} \n}\n\nvec3 rotateToWorld(vec3 p, int id)  {\n\tif(id == 0) {\n\t\treturn p;\n\t} else {\n\t\tif(MOUSE_ROTATE_PLANET)\n\t\t\treturn rotateByMouse(p);\n\t\telse\n\t\t\treturn rotate(vec3(0,0.5*t,0),p);\n\t}\n}\n\nvec3 transform(vec3 p, int id) {\n\tp = rotateToWorld(p, id);//must come before translation\n\tp = translate(p, id);\n\tvec3 rotV = rotVec(id);\n\tvec3 r = rotate(rotV, p);\n\treturn r;\n}\n\nfloat sd(vec3 p, int id)\n{\n\tvec3 r = transform(p,id);\n\treturn sdf(r,id);\n}\n\nvec3 doMaterial(vec3 p, vec3 nor, int id)\n{\n  \n    if(id == 0)\n    {   \n        return boxmap(iChannel0, p, nor, 8.0).xyz;    \n    } else \n    {\n        return boxmap(iChannel1, p, nor, 8.0).xyz;    \n    }\n}\n\nvec3 render(vec2 uv)\n{\n    \n    vec3 col = vec3(0);\n    vec3 lightColor = vec3(.86,.9,.65);\n    \n    vec3 light = vec3(1.6,-0.4,-3.2);\n    if(SUN_ROTATION) {\n\t    light = (vec4(light,1.0)*rotMat(vec3(0.0,2.0*-0.91*t,0.0))).xyz;\n    }\n    \n    vec3 ro = vec3(2.0,-.3,-2.525);\n    \n    if(ROTATE_CAMERA) {\n\t    ro = (vec4(ro,1.0)*rotMat(vec3(0,0.91*t,0))).xyz;\n    }\n    \n    if(MOUSE_ROT && iMouse.z > 0.)\n    {\n        ro = rotateByMouse(ro);\n    }\n    \n    vec3 lookAt = vec3(0);\n    \n    float vel = 1.;\n    float mov = vel*1.;\n    \n    \n    \n    float focal = 300.;\n    vec2 coord = uv * iResolution.xy*.7;\n    vec3 camDir = normalize(lookAt-ro);\n    vec3 center = ro + camDir * focal;\n    \n    vec3 zpos = -camDir;\n    vec3 xpos = cross(vec3(0,1,0),zpos);\n    vec3 ypos = cross(xpos,zpos);\n    \n    vec3 target =\n        center\n        + xpos * coord.x\n        + ypos * coord.y;\n    \n    vec3 rd = normalize(target-ro);\n    \n    const int MAX_REFL = 10;\n    \n    const float EPS = 0.005;\n    float depth = EPS;\n    for(int i=0;i<256;i++)\n    {\n        vec3 p = ro + depth*rd;\n        vec3 bkp = p;\n        float dis0 = sd(p,0);\n        float dis1 = sd(p,1);\n        \n        int id = -1;\n        float dis = EPS;\n        if(dis0<dis1) {\n        \tid = 0;\n        \tdis = dis0;\n        }\n        else {\n\t\t\tdis = dis1;\n\t\t\tid=1;\n        }\n        \n        if(dis < EPS)\n        {\n\n\n            vec2 eps = vec2(1,-1);\n            \n            vec3 nor = normalize( eps.xyy*sd( p + eps.xyy*EPS,id ) + \n                      eps.yyx*sd( p + eps.yyx*EPS,id ) + \n                      eps.yxy*sd( p + eps.yxy*EPS,id ) + \n                      eps.xxx*sd( p + eps.xxx*EPS,id ) );\n\t       \tp = transform(p,id);\n\t       \t\n            vec3 toLight = normalize(light-p);            \n\n            float diff = dot(toLight,nor);\n            \n            float ambient = 0.0035;\n            vec3 color = vec3(1.);\n            \n            color = doMaterial(p,nor,id);\n            vec3 shadowedColor = color*ambient;\n            col *= shadowedColor;\n            if(diff > EPS)\n            {\n                vec3 preCol = color * diff * lightColor;\n                preCol *= 1./distance(light,p);\n                \n                col += preCol;\n            }\n            \n            //apply shadow if so\n            float colforc = 1.;\n            float _depth = EPS;\n            float k = 3.;\n            vec3 orig = bkp+toLight*EPS*7.;\n            for(int j=0;j<65;j++)\n            {\n            \t//break;\n                vec3 _p = orig+_depth*toLight;\n                \n                float _dis0 = sd(_p,0);\n                float _dis1 = sd(_p,1);\n                \n                int _id = -1;\n\t\t\t\tfloat _dis = EPS;\n                if(_dis0<_dis1){\n\t                _id=0;\n\t                _dis = _dis0;\n                }\n                else {\n\t                _id = 1;\n\t                _dis = _dis1;\n                }\n               \n                \n                if(_dis<EPS)\n                {             \t\n                    colforc = ambient;\n                    break;\n                }\n                \n                colforc = max(min(colforc, k*_dis/_depth),ambient);\n                _depth += _dis;\n                \n                if(_dis>20.)\n                {\n                    break;\n                }\n            }\n            \n            col *= colforc;\n            break;\n        }\n        \n        depth += dis;\n        \n        if(dis > 2000.)\n        {\n            col += vec3(0.3,.6,.9) * (1.-length(uv*.6))*0.01;\n          \n            break;\n        }\n    }\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/res.xy*2.-1.;\n\n    vec3 col = vec3(0);\n    \n    const int lim = AA;\n    vec2 st = uv;\n    for(int i=0;i<lim;i++)\n    {\n        float f = float(i);\n        col += render(st);\n        st.x += 0.00075*sin(uv.x*f+f);\n        st.y += 0.00075*cos(uv.y*f+f);\n    }\n    \n    col = col/float(lim);\n    \n    if(ACES) col = acesFilm(col);\n    if(FILMIC) col = tonemapFilmic(col);\n    \n    \n    if(TONEMAP_TEST){\n\t    if(uv.x > 0. && uv.y > 0.) col = acesFilm(col);\n\t    else if(uv.x < 0. && uv.y < 0.) col = tonemapFilmic(col);\n\t    else if(uv.x > 0. && uv.y < 0.) col = tonemapFilmic(acesFilm(col));\n    }\n    \n    col = pow(col,vec3(.4545));\n\n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}