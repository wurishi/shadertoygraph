{"ver":"0.1","info":{"id":"dt2SWh","date":"1676164385","viewed":227,"name":"Preintegrated Subsurface Scatter","username":"H2ongzh","description":" reference: \n1. GPU Pro2 \n2. https://www.shadertoy.com/view/4tXBWr\n3. https://www.shadertoy.com/view/llXBWn\n","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["pbr","pss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------\n// To implement the Preintegrated Subsurface Scattering by following the GPU Pro2 Chapter \n// Please check references and their amazing implements!!\n// Author: HongZhang\n// Date: 2023/02/10\n// ------------------------------\n\n// uncomment it to visualize the LUT\n// #define SHOWLUT \n#define PI 3.14159265359\n#define MAX_ITERATION 360\n\n// Gaussian Function\nfloat Gaussian ( float v , float r ){\n    return 1.0 / sqrt (2.0 * PI * v ) * exp(- (r * r) / 2.0 / v);\n}\n\n// to approximate the skin diffustion profile with six Gaussian functions for each channel\n// cite: GPU Pro2\nvec3 DiffusionProfile(float r){\n    return Gaussian ( 0.0064 * 1.414 , r ) * vec3( 0.233 , 0.455 , 0.649 ) +\n    \t   Gaussian ( 0.0484 * 1.414 , r ) * vec3( 0.100 , 0.336 , 0.344 ) +\n    \t   Gaussian ( 0.1870 * 1.414 , r ) * vec3( 0.118 , 0.198 , 0.000 ) +\n    \t   Gaussian ( 0.5670 * 1.414 , r ) * vec3( 0.113 , 0.007 , 0.007 ) +\n    \t   Gaussian ( 1.9900 * 1.414 , r ) * vec3( 0.358 , 0.004 , 0.000 ) +\n    \t   Gaussian ( 7.4100 * 1.414 , r ) * vec3( 0.078 , 0.000 , 0.000 ) ;\n}\n\n// ----------------------------\n// to compute the Subsurface LUT\n// theta: [-PI, 0], curvature: [0, 1]\n//                       SUM(R(x) * max(0, cos(theta + x))) \n// D(theta, curvature) = ----------------------------------\n//                                 SUM(R(x))\n// Here, R(x) refers to diffusion profile\nvec3 computeSSLUT(float theta, float curvature){\n    vec3 normFactor = vec3(0.);\n    vec3 warppedLight = vec3(0.);\n    \n    float r = 1. / curvature; // radius: [1, inf]\n    \n    float angleInterval = 2. * PI / float(MAX_ITERATION);\n    \n    for(int i = 0; i < MAX_ITERATION; i += 1){\n        float deltaX = float(i) * angleInterval;\n        float dist = abs(2. * r * sin(deltaX * 0.5));\n        \n        vec3 weight = DiffusionProfile(dist);\n        \n        warppedLight += max(0., cos(theta + deltaX)) * weight;\n        normFactor += weight;\n    }\n    \n    return warppedLight / normFactor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col; \n    \n    #ifdef SHOWLUT\n        col = computeSSLUT(PI  - PI * uv.x, uv.y);\n        col = pow( col, vec3(0.4545));// tone map, you can use it or not, it depends\n        fragColor = vec4(col, 1.);\n    #else \n        // here, I simply grab iq's code to draw a sphere\n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n        float an = 2.0 + 0.5*iTime + 6.2831*iMouse.x/iResolution.x;\n\n        vec3 ww = vec3(cos(an),0.0,sin(an));\n        vec3 uu = vec3(-ww.z,0.0,ww.x);\n        vec3 vv = vec3(0.0,1.0,0.0);\n        vec3 ro = -2.5*ww;\n\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n        float b = dot( rd, ro );\n        float c = dot( ro, ro ) - 1.0;\n        float h = b*b - c;\n        if( h>0.0 )\n        {\n            float t = -b - sqrt(h);\n            vec3 pos = ro + t*rd;\n            vec3 nor = normalize(pos); \n            const float r = 0.2;  // curvature\n            col = vec3(1.0,0.9,0.8) * computeSSLUT( acos(dot(nor,vec3(0.57703))), r );\n\n            col = pow( col, vec3(0.4545));// tone map, you can use it or not, it depends\n\n            fragColor = vec4(col, 1.);\n        }\n        else{\n            fragColor = vec4(0.);\n        }\n    #endif\n}","name":"Image","description":"","type":"image"}]}