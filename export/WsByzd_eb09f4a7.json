{"ver":"0.1","info":{"id":"WsByzd","date":"1587135803","viewed":1043,"name":"River Plane Sparkly","username":"spalmer","description":"added a post pass to River Plane [url]https://shadertoy.com/view/wdBczc[/url]","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["refraction","water","bokeh","texturing","flares"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of original 'A river' by Pierco https://shadertoy.com/view/MsSGWK\n\n#define T(p, lod) textureLod(iChannel0, p, lod).rgb\n\nvec3 flare(vec2 uv, vec2 dir, float brite)\n{\n    vec3 c = vec3(0);\n    vec2 gd = dir * .18; //vec2(-.02,.05); //, vec2(-.03,444.03);\n    // FIXME directions should take buffer aspect ratio into account\n    const float stp = .01;\n    for (float f = 0.; f < 1.001; f += stp)\n        c += .1 * pow(max(vec3(0),\n             T(uv + gd * (f * 2. - 1.), 0.)\n             - .9), vec3(8.));\n    return c * brite;\n}\n//#define G(p, grad) textureGrad(iChannel0, p, grad, grad).rgb\n//#undef G\n//    #if 1\n//    #else // textureGrad not working for some reason :( will figure it out later; probably some WebGL issue\n//    c += pow(max(vec3(0),\n//             textureGrad(iChannel0, uv, gd, gd*.5).rgb\n//             - .5), vec3(.5));\n//    #endif\n\n//    #define FLARE(grad,b) (max(vec3(0.), \\\n//    \t.5 * (G(uv + (grad) * 2., (grad)) + G(uv - (grad) * 2., -(grad))) \\\n//            - .7) * 2. * (b))\n    //FLARE(vec2(.1,.3), 1.); // FIXME directions should take buffer aspect ratio into account\n//#undef FLARE\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy; //iChannelResolution[0].xy;\n\tvec3 c = T(uv, 0.); //vec3(0); //\n    c += flare(uv, vec2(0., 1.2), 4.5);\n    c += flare(uv, vec2(.4, .7), 3.3);\n    c += flare(uv, vec2(-.3, .6), 3.4);\n    c = max(c, vec3(0.));\n//\tc = pow(c, vec3(1./2.2)); // to srgb gamma for storage in display buffer\n\tfragColor = vec4(c, 1);\n}\n#undef T\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float waveHeight = .125; // average surface height\n\nfloat spow(float x, float e)\n{\n    return pow(abs(x), e) * sign(x);\n}\n\n// 3 scrolling textures on a plane\nfloat wave(vec3 p)\n{\n//    return p.y - waveHeight + .2*spow(sin(p.x)*sin(p.z), 4.); // test bumps\n\tfloat t = iTime * .33; //0.; // scroll or don't\n    // disliked how original fudged with the texcoords\n    #define T(x,y) texture(iChannel2, (p.xz + vec2(x,y)*t) / 30.).rgb\n\tvec3 c1 = T(2., 2.);\n\tvec3 c2 = T(2.52, 5.);\n\tvec3 c3 = T(3.32, 9.);\n    #undef T\n\tc1 += c2 - c3;\n\tfloat z = (c1.x + c1.y + c1.z) / 12.;\n\treturn p.y + z;\n}\n\n// no ray marching required, just cast directly to plane\nfloat intersectWave(vec3 ro, vec3 rd) \n{\n    return (ro.y - waveHeight) / -rd.y;\n}\n\n// even fwd diff seems fine for normal\nvec3 normWave(vec3 p) \n{\n\tconst vec2 e = vec2(.25,0);\n\treturn normalize(vec3(\n\t\twave(p + e.xyy),\n\t\twave(p + e.yxy),\n\t\twave(p + e.yyx))\n      - wave(p)\n\t);\n}\n\nvec3 lightWave(vec3 ro, vec3 rd, float d)\n{\n    vec3 p = ro + rd * d; // hit point on plane\n    float sh = wave(p) - .5*waveHeight; //.25; // wave height variation\n    p.xz += 2. * sh * rd.xz; // bump offset, parallax mapping - subtle\n    sh = wave(p) - .5*waveHeight; //.25; // reeval height after bump offset\n\tvec3 n = normWave(p) // surface normal\n\t, l1 = normalize(vec3(1)); // main parallel light ('sun')\n\tfloat nv = dot(rd, n)\n\t, spc = pow(max(0., dot(reflect(l1, n), rd)), 30.) // sun specular\n    , eta = 1.003/1.3 // air vs. water\n    , waterdepth = 4.; //+ sh\n    vec3 rfd = refract(rd, n, eta);  // refract view direction\n    float depthest = -waterdepth / rfd.y; // water depth estimate along refracted path\n\tvec3 ref = texture(iChannel0, reflect(rd, n)).rgb // reflection environment cubemap\n    , rfa = texture(iChannel1, (p + rfd*depthest).xz / 6.).rgb; // regular refraction\n    // HACK the original just did everything in srgb gamma\n    // which is not correct, but it's really hard to match\n    // the look without doing basically the same thing.\n\t// gave up on good gamma correction until I can\n    // match the look better somehow.\n     //   ref = pow(ref, vec3(2.2));\n     //   rfa = pow(rfa, vec3(2.2));\n    ref *= .5;\n    rfa *= exp2(-.125 * depthest); // extinct by water depth estimate\n    vec3 c;\n//    c = n * .5 + .5; // DEBUG normal\n//    c = vec3(sh * 1.5 + .5); // DEBUG height\n//    c = vec3(exp2(-.2*d)); // DEBUG depth\n//    c = vec3(spc); // DEBUG spec only\n//    c = ref; // DEBUG just envmap reflection\n//    c = rfa; // DEBUG just refraction\n//    c = spc + rfa; // DEBUG just spec + refraction\n//    c = pow(c, vec3(1./2.2)); // HACK fix gamma - temp - for debugging\n\tc = rfa + ref + spc; // sum all light - in wrong gamma\n    return c;\n}\n\n// e^(-i*angleRadians) I guess\nvec2 cossin(float angleRadians)\n{\n\treturn sin(angleRadians + vec2(1.5708,0));\n}\n\nvoid cameraRay(vec2 p, vec2 r, out vec3 ro, out vec3 rd)\n{\n\tvec2 q = (p + p - r) * .5/r.y; // signed aspect-correct uv\n\tvec3 rc = vec3(0); // look at point, spins around\n    float mx = iMouse.x; // mouse lookaround\n    if (dot(iMouse.xy, vec2(1)) < 1.5) mx = iTime * -1.; // slowly spin if unattended\n\tro = vec3(6. * cossin(4. + .02 * mx), 7).xzy; // camera rotate\n\tvec3 ww = normalize(rc - ro)\n\t, uu = normalize(cross(vec3(0,1,0), ww))\n\t, vv = normalize(cross(ww, uu));\n\trd = normalize(uu * q.x + vv * q.y + ww);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 ro, rd, c = vec3(0);\n    cameraRay(fragCoord, iResolution.xy, ro, rd);\n\tfloat d = intersectWave(ro, rd);\n\tif (d >= 0.) // didn't miss? can't, really, with this camera\n        c = lightWave(ro, rd, d); // draw water\n//\tc = pow(c, vec3(1./2.2)); // to srgb gamma for storage in display buffer\n\tfragColor = vec4(c, 1);\n}\n\n\t\t//vec3 rfa = texture(iChannel1, (p+n).xz / 6.).rgb; // extreme HACK refraction\n     //   rfa *= 1.0; // HACK brighten riverbed rocks\n        //rfa *= 8./d; // HACK fade in distance to emulate missing fresnel and water extinction\n     //   rfa *= mix(1.-pow(max(0., 1.-abs(nv)), 5.), 1., .04); // fakie fresnel\n\t    //c = (c - .5) * 1.5 + .5; // HACK increase contrast\n\n","name":"Buffer A","description":"","type":"buffer"}]}