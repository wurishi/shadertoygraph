{"ver":"0.1","info":{"id":"NtdXDB","date":"1640158049","viewed":179,"name":"E00 - Refraction","username":"roeseth","description":"My very first shader focused on refraction in nested objects. Thought about many scene setups but ended with a rather simple one. Toggle the space key to switch to the preset view.","likes":7,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","template","artofcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References. Big thanks to the authors of these awesome shaders/tutorials.\n// This has been a good exercise helping me reviewing basic concepts of \n// geometry transformation, raymarching and shading model.\n// \n// RayMarching starting point by BigWIngs. https://shadertoy.com/view/WtGXDD\n// Bending Light https://www.youtube.com/watch?v=NCpaaLkmXI8\n// Sphere in a box https://www.shadertoy.com/view/3sycDm\n// Ray Intersector https://iquilezles.org/articles/intersectors\n// Creation by Silexars  https://shadertoy.com/view/XsXXDn\n//\n// Will not include in this excercise but will consider practicing later\n// 1. Photo editing / image processing algorithms, grain\n// 2. DOF and bokeh\n// 3. Black Body Radiation -> Dispersion Function (Sellmeier approximation) -> Wavelength -> RGB\n\n// Overall Graphics\n#define AA 2\n#define DIM_LEVEL 0.4\n#define OBJ_AMP 1.0 \n\n//RayIntersect\n#define SURF_DIST .001\n// The offset to work with interection on both side\n#define OFFSET 15.\n#define FLOAT_MAX 3.402823466e+38\n\n// Bouncing and spectral setup\n#define IOR 2.45\n#define ABB 0.06\n#define MATERIAL_DECAY 0.1\n#define MAX_BOUNCES 10\n#define SPECTRAL_BANDS 3\n\n// Helper\n#define S smoothstep\n#define T iTime\n#define PI 3.14159265358\n#define keyToggle(ascii)  ( texelFetch(iChannel1,ivec2(ascii,2),0).x > 0.)\n\n\nconst vec3 SP_COL[SPECTRAL_BANDS] = vec3[](vec3(1.0, 0.0, 0.0), \n                                           vec3(0.0, 1.0, 0.0),\n                                           vec3(0.0, 0.0, 1.0));\n\n// stores intersection result\nstruct ObjInter\n{\n    bool inter;\n    bool inside;\n    float d;\n    vec3 n;\n};\n\nfloat random(in vec3 p)\n{\n    return fract(sin(dot(p,vec3(.7434,.4234, .793)))*33348.541133);\n}\n\nfloat noise(in vec3 p)\n{\n\tp.z += iTime * .4;\n\t\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.-2.*f);\n\n    vec2 c = vec2(0,1);\n\n    return mix(\n\t\tmix(mix(random(i + c.xxx), random(i + c.yxx),f.x),\n\t\t\tmix(random(i + c.xyx), random(i + c.yyx),f.x),\n\t\t\tf.y),\n\t\tmix(mix(random(i + c.xxy), random(i + c.yxy),f.x),\n\t\t\tmix(random(i + c.xyy), random(i + c.yyy),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 Rot3D(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mz*my*mx;\n}\n\n// Intersector https://iquilezles.org/articles/intersectors\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    // bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return t;\n\n    // some precomputation\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    t = 1e30;        \n\n    // corner\n    {\n    float b = od.x + od.y + od.z;\n    float c = oo.x + oo.y + oo.z - ra2;\n    float h = b*b - c;\n    if( h>0.0 ) t = -b-sqrt(h);\n    }\n    // edge X\n    {\n    float a = dd.y + dd.z;\n    float b = od.y + od.z;\n    float c = oo.y + oo.z - ra2;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        h = (-b-sqrt(h))/a;\n        if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;\n    }\n    }\n    // edge Y\n    {\n    float a = dd.z + dd.x;\n    float b = od.z + od.x;\n    float c = oo.z + oo.x - ra2;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        h = (-b-sqrt(h))/a;\n        if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;\n    }\n    }\n    // edge Z\n    {\n    float a = dd.x + dd.y;\n    float b = od.x + od.y;\n    float c = oo.x + oo.y - ra2;\n    float h = b*b - a*c;\n    if( h>0.0 )\n    {\n        h = (-b-sqrt(h))/a;\n        if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;\n    }\n    }\n\n    if( t>1e19 ) t=-1.0;\n    \n    return t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nObjInter roundedBoxIntersect(in vec3 roB, in vec3 roF, in vec3 rd, vec3 box_c, vec3 size, float r, mat3 m) {\n    ObjInter box;\n    box.inside = false;\n    \n    roB -= box_c;\n    roF -= box_c;\n    \n    roB = m * roB;\n    roF = m * roF;\n    rd = m * rd;\n    \n    vec3 p;\n    float d1 = roundedboxIntersect(roB, rd, size, r);\n    float d2 = roundedboxIntersect(roF, -rd, size, r);\n    \n    if (d1 > OFFSET) {\n        // outside\n        p = roB + rd*d1;\n        box.d = d1 - OFFSET;\n        box.n = roundedboxNormal(p, size, r) * m;\n        box.inter = true;\n    } else if (d2 > 0.0 && d2 < OFFSET) {\n        // inside\n        p = roF - rd*d2;\n        box.d = OFFSET - d2;\n        box.n = -roundedboxNormal(p, size, r) * m;\n        box.inside = true;\n        box.inter = true;\n    } else {\n        box.inter = false;\n    }\n    return box;\n}\n\nObjInter sphereIntersect(in vec3 roB, in vec3 roF, in vec3 rd, vec4 para) {\n    ObjInter sph;\n    sph.inside = false;\n    \n    vec3 p;\n    float d1 = sphIntersect(roB, rd, para);\n    float d2 = sphIntersect(roF, -rd, para);\n    \n    if (d1 > OFFSET) {\n        // outside\n        p = roB + rd*d1;\n        sph.d = d1 - OFFSET;\n        sph.n = sphNormal(p, para);\n        sph.inter = true;\n        \n    } else if (d2 > 0.0 && d2 < OFFSET) {\n        // d1 < d2\n        // inside\n        p = roF - rd*d2;\n        sph.d = OFFSET - d2;\n        sph.n = -sphNormal(p, para);\n        sph.inside = true;\n        sph.inter = true;\n    } else {\n        sph.inter = false;\n    }\n    return sph;\n}\n\nfloat planeIntersect(vec3 ro, vec3 rd, vec3 nor, float dist) {\n  float denom = dot(rd, nor);\n  float t = -(dot(ro, nor) + dist) / denom;\n\n  return t;\n}\n\n// Source: https://iquilezles.org/articles/palettes\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 2.*PI*(c*t+d) );\n}\n\nvec3 paletteBackground(vec3 ro, vec3 rd) {\n    vec3 col = palette(\n        clamp(rd.z * 0.5 + 0.5, -1.0, 1.0),\n        vec3(0.5, 0.5, 0.5),\n        vec3(0.5, 0.5, 0.5),\n        vec3(1.0, 1.0, 1.0),\n        vec3(0.0, 0.1, 0.20));\n  return col;\n}\n\n// Creation by Silexars  https://shadertoy.com/view/XsXXDn\nvec3 litPlane(vec3 ro, vec3 rd) {\n    vec3 col;\n    \n    ro.xz *= Rot(-0.1*T);\n    rd.xz *= Rot(-0.1*T);\n\n    // get the plane the BG is displaying on\n    float d = planeIntersect(ro, rd, normalize(vec3(0, -1, 0)), 20.);\n\n    if (d > 0.0) {\n        vec3 pp = ro + rd * d;\n        \n        /* position */\n        vec2 f = pp.xz;\n        vec2 U;\n        vec2 r = vec2(40, 40);\n        vec2 p = f/r;\n\n        p.x*= r.x/r.y;\n\n        float t = 0.2*T, l = length(p);\n        \n        \n        for( int i=0; i<3; i++ ) {\n            t +=.02;\n            U = f/r + normalize(p) * ( sin(t)+1.) * abs(sin(l*9.-t*2.));\n            col[i] = .01 / length( abs(fract(U)-.5) );\n        }\n        \n        col = col/l;\n    }\n    return col * smoothstep(40., 30., d);\n}\n\nvec3 getBackgroundCol(in vec3 ro, in vec3 rd) {\n    vec3 col;\n\n    // ig's Palette\n    col = paletteBackground(ro, rd);\n    \n    // plane\n    col += litPlane(ro, rd) * 0.5;\n    \n    // revert gamma correction since we'll do final correction\n    return pow(col, vec3(2.2));\n}\n\n// RayMarching is too slow\n// Use intersector instead\n// now the inside para is used to determine where is the start point located\nbool RayMarchIntersect(in vec3 ro, in vec3 rd, in float side, out float d, out vec3 oNor) {\n    // Set up the scene\n    const int max_obj = 11;\n    ObjInter objs[max_obj];\n    \n    // Offset on both direction\n    // Note: only work accurately on simple geometry\n    // For shape like a torus, even sometime a ray has\n    // four intersection, this only give you two of them\n    \n    // move backwards, look forwards\n    vec3 roB = ro - rd*OFFSET;\n    // move forwards, look backwards\n    vec3 roF = ro + rd*OFFSET;\n    \n    // Rounded Box 0\n    float box_r = 0.02;\n    vec3 box_c = vec3(0., 0., 0.);\n    vec3 box_size = vec3(4, 4, 4);\n    mat3 box_m = Rot3D(vec3(0, 0., 0.));\n    ObjInter box = roundedBoxIntersect(roB, roF, rd, box_c, box_size, box_r, box_m);\n    //objs[0] = box;\n    \n\n    // Rounded Box 1\n    float box_r1 = .02;\n    vec3 box_c1 = vec3(0, 0, 0);\n    vec3 box_size1 = vec3(0.9);\n    mat3 box_m1 = Rot3D(vec3(0, 0.1*T, 0.));\n    //mat3 box_m = Rot3D(vec3(atan(1./sqrt(2.)), 0, 1./4.*PI));\n    ObjInter box1 = roundedBoxIntersect(roB, roF, rd, box_c1, box_size1, box_r1, box_m1);\n    objs[1] = box1;\n    \n    // Sphere 1\n    vec3 loc = vec3(0., 1.1, 0.);\n    loc.xy = Rot(0.2*T) * loc.xy;\n    vec4 sph_para = vec4(loc, 1.1);\n    ObjInter sph = sphereIntersect(roB, roF, rd, sph_para);\n    objs[2] = sph;\n    \n    // Sphere 2\n    vec3 loc2 = vec3(0., -1.1, 0.);\n    loc2.xy = Rot(0.2*T) * loc2.xy;\n    vec4 sph_para2 = vec4(loc2, 1.1);\n    ObjInter sph2 = sphereIntersect(roB, roF, rd, sph_para2);;\n    objs[3] = sph2;\n\n    // Sphere shell\n    vec4 sph_para3 = vec4(0.0, 0.0, 0.0, 3.0);\n    ObjInter sph3 = sphereIntersect(roB, roF, rd, sph_para3);;\n    objs[4] = sph3;\n    \n    // a generic intersection handling\n    // find the nearest intersection\n    int inter_count = 0;\n    ObjInter interObjs[max_obj];\n    \n    for (int i = 0; i < max_obj; i++) {\n        if (objs[i].inter) {\n            interObjs[inter_count] = objs[i];\n            inter_count++;\n        }\n    }\n    \n    if (inter_count < 1) {\n        return false;\n    }\n    \n    int min_idx;\n    float min_d = FLOAT_MAX;\n    for (int i = 0; i < inter_count; i++) {\n        if (interObjs[i].d < min_d) {\n            min_idx = i;\n            min_d = interObjs[i].d;\n        }\n    }\n    \n    d = interObjs[min_idx].d;\n    oNor = interObjs[min_idx].n;\n    \n    return true;\n}\n\n\n// p = point\n// l = lookat\n// z = zoom\n// r_para is the vector implicitly determine rotation and\n// handedness of coordinate system.\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, vec3 r_para, float z) {\n    vec3 f = normalize(l-p),\n        // this intermediate vec r is to make sure u is in the correct plane\n        r = normalize(cross(r_para, f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// p: first contact point on surface\n// rd: subsurface rd\nvec3 renderSub(in vec3 p, in vec3 n, in vec3 rd, in float ior) {\n    \n    // the first refraction entering the solid\n    vec3 rdStart = rd;\n    // offset in a little bit to \n    // determin inner ray start point\n    vec3 pStart = p - n*SURF_DIST;\n    \n    // start with inner side\n    float side = -1.;\n    \n    // to avoid multiple declaration\n    float dStart;\n    vec3 rdNext, pNext, nNext;\n    \n    // ray path length\n    float innerLength = 0.;\n    \n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        \n        // subsurface bounce, scale down the step\n        \n        //dStart = RayMarch(pStart, rdStart, side, .5);\n        float dStart;\n        vec3 nNext;\n        bool inter = RayMarchIntersect(pStart, rdStart, side, dStart, nNext);\n        \n        if (side < 0.) {\n            innerLength += dStart;\n        }   \n\n        // if ray leaves solid\n        if (!inter) {\n            break;\n        }\n\n        pNext = pStart + rdStart * dStart;\n        \n        // for simplicity, we consider the ray either\n        // relfect OR refract, not both.\n        rdNext = refract(rdStart, nNext, ior);\n        //\n        // check if rdOut.xyz are all 0\n        // length(rdOut) also does the trick,\n        // but slower than dot(v, v)\n        if (dot(rdNext, rdNext) == 0.) {\n            pStart = pNext + nNext*SURF_DIST;\n            rdStart = reflect(rdStart, nNext);\n        } else {\n            pStart = pNext - nNext*SURF_DIST;\n            rdStart = rdNext;\n            side = -side;\n            ior = 1. / ior;\n        }\n    }\n    \n    // dIn is the distance/length of internal ray\n    float optDist = exp(-innerLength * MATERIAL_DECAY);\n    \n    return getBackgroundCol(pStart, rdStart) * optDist;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the same offset and scale for uv when rendering,\n    // to make the center (0,0), and space [-.5 .5];\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // set camera to enough far so it\n    // looks like isometric\n    // need more work on a real transformation\n    vec3 ro = vec3(0, -10., 0);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 r_para = vec3(0, 0, 1.);\n    float zoom = 1.; \n    \n    // space key will lock scence to preset\n    \n    // Thanks davidar@ for the fix on blank screen when mouse is at (0,0)\n    if (keyToggle(32) || iMouse.xy == vec2(0)) {\n        // reset and lock mouse to center\n        mouse = vec2(0.0);\n    }\n    \n    //ro.xy *= Rot(m.x*PI*1.);\n    //ro.yz *= Rot(m.y*PI*1.);\n    //ro *= Rot3D\n    ro = Rot3D(vec3(-mouse.y*PI, 0.0, -mouse.x*PI)) * ro;\n    \n    vec3 tot = vec3(.0);\n    for (int m = 0; m < AA; m++) {\n        for (int n = 0; n < AA; n++) {\n            // AA sampling offset\n            vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n            vec2 uv = ((fragCoord+o)-.5*iResolution.xy)/iResolution.y;\n\n            vec3 rd = GetRayDir(uv, ro, lookat, r_para, zoom);\n\n            // the cube map is a 2d collection of rd endpoints\n            vec3 col;\n\n            // To save computation time, we only march once \n            // when hitting the object the first time\n            //float d = RayMarch(ro, rd, 1., 1.);\n            float d;\n            vec3 oNor;\n            bool inter = RayMarchIntersect(ro, rd, 1.0, d, oNor);\n\n\n            if (inter) {\n                vec3 p = ro + rd * d;\n                //vec3 n = GetNormal(p);\n                vec3 refl = reflect(rd, oNor);\n\n                // reflection\n                vec3 reflOutside = getBackgroundCol(p, refl);\n\n                vec3 refrCol;\n\n                // rgb chromatic abbreviation\n                for (int i = 0; i < SPECTRAL_BANDS; i++) {\n                    float ior = mix(IOR-ABB, IOR+ABB, float(i)/float(SPECTRAL_BANDS-1));\n                    vec3 rdSub = refract(rd, oNor, 1./ior);\n                    refrCol += renderSub(p, oNor, rdSub, ior) * SP_COL[i];\n                }\n\n                // flipped fresnel, could actually revert\n                // doesn't matter.\n                float fresnel = pow(1.-dot(-rd, oNor), 4.);\n\n                col = mix(refrCol, reflOutside, fresnel);\n                col *= OBJ_AMP;\n                //col = col*dif;\n            } else {\n                // dim background\n                col = getBackgroundCol(ro, rd);\n            }\n            tot += col;\n        }\n    }\n    \n    tot /= float(AA*AA);\n    \n    // gamma correction\n    tot = pow(tot, vec3(.4545));\n    //col = pow(col, vec3(1./2.2))\n    \n    //post processing\n    tot = desaturate(tot, 0.1);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.2);\n    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}