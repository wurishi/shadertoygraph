{"ver":"0.1","info":{"id":"3tSXRh","date":"1565064975","viewed":128,"name":"gb camera shader","username":"maple","description":"it's a shader that makes input look like gb camera yay","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pixel","gameboy","lowres","gbcamera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * ------------------------------------------------------------\n * \"THE BEERWARE LICENSE\" (Revision 42):\n * maple <maple@maple.pet> wrote this code. As long as you retain this \n * notice, you can do whatever you want with this stuff. If we\n * meet someday, and you think this stuff is worth it, you can\n * buy me a beer in return.\n * ------------------------------------------------------------\n */\n\nconst int bayer8[64] = int[](\n\t 0, 32,  8, 40,  2, 34, 10, 42, /* 8x8 Bayer ordered dithering */\n\t48, 16, 56, 24, 50, 18, 58, 26, /* pattern. Each input pixel */\n\t12, 44,  4, 36, 14, 46,  6, 38, /* is scaled to the 0..63 range */\n\t60, 28, 52, 20, 62, 30, 54, 22, /* before looking in this table */\n\t 3, 35, 11, 43,  1, 33,  9, 41, /* to determine the action. */\n\t51, 19, 59, 27, 49, 17, 57, 25,\n\t15, 47,  7, 39, 13, 45,  5, 37,\n\t63, 31, 55, 23, 61, 29, 53, 21\n);\n\n// quantize coords to low resolution\nvec2 pixelize(vec2 uv, vec2 pixelSize) {\n\tvec2 factor = vec2(pixelSize) / iResolution.xy;\n\treturn floor(uv / factor) * factor;\n}\nvec2 pixelize(vec2 uv, float pixelSize) {\n\treturn pixelize(uv, vec2(pixelSize));\n}\n\n// any 4-color GB palette works here as long as it's ordered dark to light\nint paletteSize = 4;\nvec3 palette[] = vec3[4](\n    vec3(0.18, 0, 0.18),\n    vec3(0.37, 0.15, 0.47),\n    vec3(0.97, 0.56, 0.12),\n    vec3(0.97, 0.94, 0.53)\n);\n\nvec3 colorLUT(vec3 color) {\n    vec3 gray = vec3(color.r*0.3 + color.g*0.59 + color.b*0.11);\n    gray = floor(gray * 4.0);\n    return palette[int(gray)];\n}\n\n// adjust brightness, contrast and gamma levels of a color\nvec3 levels(vec3 color, float brightness, float contrast, vec3 gamma) {\n\tvec3 value = (color - 0.5) * contrast + 0.5;\n\tvalue = clamp(value + brightness, 0.0, 1.0);\n\treturn clamp(vec3(pow(abs(value.r), gamma.x),pow(abs(value.g), gamma.y),pow(abs(value.b), gamma.z)), 0.0, 1.0);\n}\nvec3 levels(vec3 color, float brightness, float contrast, float gamma) { \n\treturn levels(color, brightness, contrast, vec3(gamma));\n}\n\n// applies the dithering filter to a color map\nvec3 dither8x8(vec2 coord, vec3 color, vec2 pixelSize) {\n\t// reduces pixel space to the selected pixel size\n\tvec2 pixelCoord = floor((coord * iResolution.xy) / vec2(pixelSize) + 0.5);\n\n    float dither_factor = 0.8;\n    \n\t// applies the bayer matrix filter to the color map\n\tpixelCoord = mod(pixelCoord, 8.0);\n\tint index = int(pixelCoord.x + (pixelCoord.y * 8.0));\n\tvec3 bayerColor = (color + (vec3(bayer8[index]-31)/32.0) * (dither_factor / 8.0));\n\t// limits it to the selected palette\n\tcolor = colorLUT(bayerColor);\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(3.0);    \n    \n    vec2 texcoord = pixelize(uv, pixelSize);\n    vec3 color = texture(iChannel0, texcoord).rgb;\n    \n    color = levels(color, 0.0, 1.0, 0.6);\n    \n    color = dither8x8(texcoord, color, pixelSize);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}