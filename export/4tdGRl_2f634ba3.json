{"ver":"0.1","info":{"id":"4tdGRl","date":"1470894567","viewed":109,"name":"4: Grid Effect","username":"andgokevin","description":"Expanding and strobing grid.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Multiply scalar within trig. functions to compress or expand the wave.\n */\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  vec4 bgColor = vec4(0.4, 0.2, 0.2, 1.0);  // Background color.\n  vec4 color = bgColor;  // Default to background color.\n\n  vec2 uv = fragCoord.xy / iResolution.xy;  // Clamp coordinate system to [0, 1].\n    \n  float gridTick = 0.1;  // How much space between grid lines.\n  float gridWidth = 0.1;  // Thickness of grid lines.\n  vec4 gridColor = vec4(0.8, 0.8, 1.0, 1.0);  // Color of grid lines.\n    \n  // Do trippy stuff using the time.\n  // 1. Make the distance between grid ticks vary.\n  // gridTick = gridTick * min(((sin(iTime) + 1.0) / 2.0), 0.002);\n  // 2. Make the width of the grid ticks vary.\n  gridWidth = gridWidth * ((sin(iTime) + 1.0) / 2.0);\n   \n  // Use modulo which divides coordinate by tick. Then compares to the width.  \n  if (mod(uv.x, gridTick) < gridWidth || mod(uv.y, gridTick) < gridWidth) {\n    color = gridColor * abs(sin(0.25 * iTime));\n  }\n\n\n  fragColor = color;\n}","name":"Image","description":"","type":"image"}]}