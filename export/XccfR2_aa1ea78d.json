{"ver":"0.1","info":{"id":"XccfR2","date":"1733261607","viewed":36,"name":"Cellular 2x2","username":"stegu","description":"Smaller 2x2 search window, useful for smaller jitter amounts and when only the nearest neighbor is wanted. Jitter over 0.5 (+/- 0.25 times the grid spacing) yields some errors even for the closest point.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","cellular"],"hasliked":0,"parentid":"4ctBz8","parentname":"Cellular \"noise\" demo (2D)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float aastep(float a, float x) {\n    float fw = 0.5*fwidth(x-a);\n    return smoothstep(-fw, fw, x-a);\n}\n\n// Make a kind-of random RGB color from a modulo-289 integer ID\nvec3 rgbh(float h) {\n    return vec3(1.0-mod(h,7.0)/8.0, 0.9-mod(h,49.0)/64.0, 1.0-h/288.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/min(iResolution.x, iResolution.y);\n\n    vec2 F;\n    vec2 P1;\n    float ID1;\n    vec3 col;\n    \n    F = cellular2x2(uv*12.0, 0.5, P1, ID1);\n\n    if(uv.x < 0.0) {\n        // The classic \"Voronoi\" pattern, with color to make use of ID1\n        col = mix(rgbh(ID1), vec3(1.0), 1.0-aastep(0.05, F.x));\n    }\n    else {\n        col = vec3(1.0-1.2*F.x*F.x);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Cellular noise (\"Worley noise\") in 2D.\n// Version 2024-12-03, by Stefan Gustavson.\n// Published under the CC-BY-SA 4.0 license:\n// https://creativecommons.org/licenses/by-sa/4.0/\n\n// Cellular noise, returning F1 and F2 in a vec2,\n// the offset from P to the nearest point P1\n// in an \"out\" parameter vec2 P1, and the hashed\n// Voronoi cell ID in an \"out\" parameter float ID1.\n// 2x2 search window for good F1 values with\n// jitter <= 0.5. F2 is pretty useless, even near\n// the Voronoi cell boundary lines.\n// With jitter > 0.5, even F1 is wrong a lot.\n//\n// Explicit loops, compact code that's easy to read.\n// Not *quite* as fast as a vectorized version, but\n// on modern platforms the difference is marginal.\n//\nfloat permute289(float x) {\n  return mod((34.0 * x + 10.0) * x, 289.0);\n}\nvec2 cellular2x2(vec2 P, float jitter, out vec2 P1, out float ID1) {\n    jitter = clamp(jitter,0.0,1.0);\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n\tvec2 Pf = P0-P; // Vector from P to closest unjittered grid point P0\n\tfloat px, pxy, d, d1, d2, ox, oy, dx, dy;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n\tfor(float ix = 0.0; ix <=1.0; ix++) {\n\t\tpx = permute289(Pi.x + ix);\n\t\tfor(float iy = 0.0; iy <= 1.0; iy++) {\n\t\t\tpxy = permute289(px + Pi.y + iy);\n            float psi = pxy*0.07482; // Scale the hash (and jumble it some more)\n            // Generate a displacement vector of maximum length\n            ox = cos(psi); // sin and cos are usually fast these days\n            oy = sin(psi);\n            float sqc = 0.5 / max(abs(ox), abs(oy));\n            ox = ox * sqc; // Square the circle\n\t\t\toy = oy * sqc;\n\t\t\tdx = Pf.x + ix + jitter*ox; // points at grid crossings\n\t\t\tdy = Pf.y + iy + jitter*oy; // instead of at cell centers\n\t\t\td = dx*dx + dy*dy; // Distance from P to Pn, squared\n            // d could replace either d1 or d2, handle both cases\n\t\t\td2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n\t\t\tP1 = (d <= d1 ? vec2(dx,dy) : P1);\n\t\t\tID1 = (d <= d1 ? pxy : ID1);\n\t\t\td1 = (d <= d1 ? d : d1);\n\t\t}\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n","name":"Common","description":"","type":"common"}]}