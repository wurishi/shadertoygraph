{"ver":"0.1","info":{"id":"MXy3zW","date":"1718822026","viewed":98,"name":"Direct lighting - 2D","username":"mrboggieman","description":"Direct lighting (with smooth shadows) by clipping lights and then accumulating contributions. Noise-free :) Re-draw a wall by clicking and dragging the mouse. Just don't cross the lines :D","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","lighting","shadows","penumbra","direct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// trims and split light lines with occlusions lines and sums the remaining light contributions, noise free\n\n// a structure to store precomputed data for the angles and distance (min and max) for a line\n// the angles are polar (0-TAU anti-clockwise from pos-x)\nstruct Segment {\n    float start_angle;\n    float end_angle;\n    float start_dist;\n    float end_dist;\n    Line line;\n};\n\nstruct Light {\n    Line line;\n    vec3 colour;\n};\n\n// Calculate polar angles and split a line into segments from a given point\n// Returns the number of new segments that have been inserted into a provided array\nint line_segments(in vec2 pos, in Line line, out Segment[2] result) {\n    float a_angle = polar_angle(line.a - pos);\n    float b_angle = polar_angle(line.b - pos);\n\n    float from_angle = a_angle;\n    float to_angle = b_angle;\n    vec2 from_pos = line.a;\n    vec2 to_pos = line.b;\n\n    if (b_angle < a_angle) {\n        from_angle = b_angle;\n        from_pos = line.b;\n        to_angle = a_angle;\n        to_pos = line.a;\n    }\n\n    if ((to_angle - from_angle) > PI) {\n        // split lines into two if they cross the positive x axis\n        // this is so we always have line segments with a start and end angle in the range of 0 - TAU\n        float dist_at_zero = ray_line_distance(Ray(pos, 0.0), line);\n        vec2 pos_at_zero = pos + polar_position(dist_at_zero, 0.0);\n\n        result[0] = Segment(\n            0.0,\n            from_angle,\n            dist_at_zero,\n            distance(from_pos, pos),\n            Line(pos_at_zero, from_pos)\n        );\n\n        result[1] = Segment(\n            to_angle,\n            TAU,\n            distance(to_pos, pos),\n            dist_at_zero,\n            Line(to_pos, pos_at_zero)\n        );\n\n        return 2;\n    }\n\n    result[0] = Segment(\n        from_angle,\n        to_angle,\n        distance(from_pos, pos),\n        distance(to_pos, pos),\n        Line(from_pos, to_pos)\n    );\n\n    return 1;\n}\n\n// Given a light segment and an occlusion segment produce new light segments that are not occluded\n// Returns the count of the segments in the output\n// Maths: https://www.desmos.com/calculator/qvh4aatruh\nint trim_segment(in vec2 pos, in Segment light, in Segment wall, out Segment[2] result) {\n    // test the angles first and see if there is overlap\n    // then test the distance and split if the wall is closer than the light\n    if (wall.end_angle > light.end_angle) {\n        if (wall.start_angle > light.end_angle) {\n            // leave intact (no occlusion)\n            result[0] = light;\n            return 1;\n        }\n\n        if (wall.start_angle >= light.start_angle) {\n            // split right\n            float new_min_dist = ray_line_distance(Ray(pos, wall.start_angle), light.line);\n            \n            if (wall.start_dist < new_min_dist) {\n                result[0] = Segment(\n                    light.start_angle,\n                    wall.start_angle,\n                    light.start_dist,\n                    new_min_dist,\n                    Line(light.line.a, pos + polar_position(new_min_dist, wall.start_angle))\n                );\n                return 1;\n            }\n\n            // leave intact (no occlusion)\n            result[0] = light;\n            return 1;\n        }\n        \n        // check if the wall is closer thean the light\n        float check_dist = ray_line_distance(Ray(pos, light.start_angle), wall.line);\n        \n        if (check_dist < light.start_dist) {\n            // remove line (occluded)\n            return 0;\n        }\n\n        // leave intact (no occlusion)\n        result[0] = light;\n        return 1;\n    }\n\n    if (wall.start_angle > light.start_angle) {\n        // split into two\n        float new_min_dist = ray_line_distance(Ray(pos, wall.start_angle), light.line);\n       \n        if (wall.start_dist < new_min_dist) {\n            float new_max_dist = ray_line_distance(Ray(pos, wall.end_angle), light.line);\n\n            result[0] = Segment(\n                light.start_angle,\n                wall.start_angle,\n                light.start_dist,\n                new_min_dist,\n                Line(light.line.a, pos + polar_position(new_min_dist, wall.start_angle))\n            );\n\n            result[1] = Segment(\n                wall.end_angle,\n                light.end_angle,\n                new_max_dist,\n                light.end_dist,\n                Line(pos + polar_position(new_max_dist, wall.end_angle), light.line.b)\n            );\n\n            return 2;\n        }\n\n        // leave intact (no occlusion)\n        result[0] = light;\n        return 1;\n    }\n\n    if (wall.end_angle > light.start_angle) {\n        // split left\n        float new_max_dist = ray_line_distance(Ray(pos, wall.end_angle), light.line);\n\n        if (wall.end_dist < new_max_dist) {\n            result[0] = Segment(\n                wall.end_angle,\n                light.end_angle,\n                new_max_dist,\n                light.end_dist,\n                Line(pos + polar_position(new_max_dist, wall.end_angle), light.line.b)\n            );\n            return 1;\n        }\n    }\n\n    // leave intact (no occlusion)\n    result[0] = light;\n    return 1;\n}\n\n// start\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // scene\n    Light[] lights = Light[](\n        Light(Line(vec2(0.4, 0.8), vec2(0.8, 0.8)), vec3(1.0)),\n        Light(Line(vec2(1.2, 0.9), vec2(1.4, 0.7)), vec3(0.3, 0.0, 0.0))\n    );\n\n    Line[] walls = Line[](\n        Line(vec2(0.4, 0.4), vec2(0.8, 0.4)),\n        Line(vec2(1.2, 0.2), vec2(1.4, 0.3))\n    );\n    \n    // rotate one of the lights around its center point with time\n    vec2 light_center = mix(lights[0].line.a, lights[0].line.b, 0.5);\n    float rotate_angle = iTime;\n    lights[0].line.a = rotate(lights[0].line.a, rotate_angle, light_center);\n    lights[0].line.b = rotate(lights[0].line.b, rotate_angle, light_center);\n\n    // let the wall be drawn with the mouse\n    if (iMouse.z > 0.0) {\n        walls[0].a = abs(iMouse.zw)/iResolution.y;\n        walls[0].b = iMouse.xy/iResolution.y;\n    }\n    \n    // we will be doing computations for each wall against each light so pre-calculate the segments\n    const int max_wall_segments = walls.length() * 2;\n    Segment[max_wall_segments] wall_segments;\n    int num_wall_segments = 0;\n    \n    for (int i=0; i<walls.length(); i++) {\n        Segment[2] new_segments;\n        int num_new_segments = line_segments(uv, walls[i], new_segments);\n        \n        for (int j=0; j<num_new_segments; j++) {\n            wall_segments[num_wall_segments] = new_segments[j];\n            num_wall_segments++;\n        }\n    }\n\n    vec3 mag = vec3(0.0);\n    \n    // go through all of the lights and chop them down until we get only the visible fragments\n    for (int i=0; i<lights.length(); i++) {\n        Light light = lights[i];\n        float line_dist = distance(light.line.a, light.line.b);\n        \n        // this is used to compute the contribute of each light\n        // a pill shape that corresponds to the line at a distance (half circles joined by the two lines)\n        float circumference = (distance_to_line_segment(light.line, uv) * TAU) + line_dist + line_dist;\n\n        Segment[2] light_segments;\n        int num_light_segments = line_segments(uv, light.line, light_segments);\n\n        for (int j=0; j<num_light_segments; j++) {\n            Segment[2 * max_wall_segments] light_fragments;\n            light_fragments[0] = light_segments[j];\n            int num_light_fragments = 1;\n\n            // chop up the light fragments by all of the wall segments over and over\n            for (int k=0; k<num_wall_segments; k++) {\n                // accumulate the new fragments\n                Segment[2 * max_wall_segments] new_light_fragments;\n                int num_new_light_fragments = 0;\n                Segment wall_segment = wall_segments[k];\n\n                for (int l=0; l<num_light_fragments; l++) {\n                    Segment[2] trimmed_light_fragments;\n                    int num_trimmed_light_fragments = trim_segment(uv, light_fragments[l], wall_segment, trimmed_light_fragments);\n                    \n                    // insert the new light fragments into our new list\n                    for (int m=0; m<num_trimmed_light_fragments; m++) {\n                        new_light_fragments[num_new_light_fragments] = trimmed_light_fragments[m];\n                        num_new_light_fragments++;\n                    }\n                }\n\n                // replace the original set so we can break them down against the next wall segment\n                light_fragments = new_light_fragments;\n                num_light_fragments = num_new_light_fragments;\n            }\n\n            for (int n=0; n<num_light_fragments; n++) {\n                Segment light_fragment = light_fragments[n];\n\n                // the contribution can be determined by the surface area of the line vs the total area from all photons emitted from the light at this distance\n                float amount = (distance(light_fragment.line.a, light_fragment.line.b) / line_dist) / circumference;\n\n                //TODO: we can shape the lights by varying the photon distribution from the lights\n                mag += amount * light.colour;\n            }\n        }\n    }\n\n    fragColor = vec4(clamp(mag, 0.0, 1.0),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// utils\nconst float EPSILON = 0.00001;\nconst float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\n\nstruct Line {\n    vec2 a;\n    vec2 b;\n};\n\nstruct Ray {\n    vec2 pos;\n    float angle;\n};\n\nfloat det2(in vec2 a, in vec2 b) {\n    return determinant(mat2(a, b));\n}\n\nvec2 project(in vec2 a, in vec2 b) {\n    return dot(a, b)/dot(b, b) * b;\n}\n\nvec2 closest_point_on_line(in Line line, in vec2 pos) {\n    return line.a + project(pos - line.a, line.b - line.a);\n}\n\nfloat distance_to_line_segment(in Line line, in vec2 pos) {\n    return distance(clamp(closest_point_on_line(line, pos), min(line.a, line.b), max(line.a, line.b)), pos);\n}\n\n// rotate around a point\nvec2 rotate(in vec2 pos, in float angle, in vec2 center) {\n    vec2 relative = pos - center;\n    return center + vec2(\n        relative.x*cos(angle) - relative.y*sin(angle),\n        relative.x*sin(angle) + relative.y*cos(angle)\n    );\n}\n\n// The unsigned angle from the +x axis anti-clockwise for a vector (0 - 2PI)\nfloat polar_angle(in vec2 a) {\n    return PI - atan(a.y, -a.x);\n}\n\nvec2 polar_position(in float radius, in float angle) {\n    return radius * vec2(cos(angle), sin(angle));\n}\n\n// Get the distance to the intersection for a ray and line segment\n// Maths: https://www.desmos.com/calculator/ah5v9w5xqo\nfloat ray_line_distance(in Ray ray, in Line line) {\n    float denom = (line.b.y-line.a.y)*cos(ray.angle) + (line.a.x - line.b.x) * sin(ray.angle);\n    \n    if (abs(denom) < EPSILON) {\n        return distance(ray.pos, line.a);\n    }\n    \n    return det2(line.a-ray.pos, line.b - ray.pos) / denom;\n}\n","name":"Common","description":"","type":"common"}]}