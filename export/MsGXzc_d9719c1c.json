{"ver":"0.1","info":{"id":"MsGXzc","date":"1465783340","viewed":1052,"name":"capture the flag","username":"flockaroo","description":"capture the flag - multiplayer test of <2121 on iceworld> keys: ASDW, HJKU (zoom RF, OL)\non my machine its not multi-playable, because strangely it cant deal with so many keys pressed at once. webgl problem? or my machine? any idea, anyone?\n","likes":16,"published":1,"flags":48,"usePreview":1,"tags":["game","simulation","physics","car","driving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n#define readSampler iChannel1\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n#define frameTime iTimeDelta\n//----- common ------\n\n#define MaxParticleNum 2\n#define NumViews int(min(float(MaxParticleNum),2.0))\n//#define NumViews 2\n#define InRes iChannel0Resolution\n\n#define FlagRadius 3.0\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n    float score;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,p.score,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    p.score  = p2.y;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeCamPosI(vec3 pos, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(0+i*20,0,fragCoord)) fragColor.xyz=pos;\n}\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord) { writeCamPosI(pos, fragColor, fragCoord, 0); }\n\nvec3 readCamPosI(int i)\n{\n    return getPixel(0+i*20,0).xyz;\n}\nvec3 readCamPos() { return readCamPosI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamQuatI(vec4 quat, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(1+i*20,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2+i*20,0,fragCoord)) fragColor.x=quat.w;\n}\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord) { writeCamQuatI(quat, fragColor, fragCoord, 0); }\n\nvec4 readCamQuatI(int i)\n{\n    vec4 q;\n    q   = getPixel(1+i*20,0);\n    q.w = getPixel(2+i*20,0).x;\n    return q;\n}\nvec4 readCamQuat() { return readCamQuatI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamNavI(vec3 nav, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(3+i*20,0,fragCoord)) fragColor.xyz=nav;\n}\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord) { writeCamNavI(nav, fragColor, fragCoord, 0); }\n\nvec3 readCamNavI(int i)\n{\n    return getPixel(3+i*20,0).xyz;\n}\nvec3 readCamNav() { return readCamNavI(0); }\n\n//-------------------------------------------------------------------------------------\nfloat readSteeringAngleI(int i)\n{\n    return getPixel(4+i*20,0).x;\n}\nfloat readSteeringAngle() { return readSteeringAngleI(0); }\n\nvoid writeSteeringAngleI(float st, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.x=st;\n}\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord) { writeSteeringAngleI(st, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nfloat readGasI(int i)\n{\n    return getPixel(4+i*20,0).y;\n}\nfloat readGas() { return readGasI(0); }\n\nvoid writeGasI(float gas, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.y=gas;\n}\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord) { writeGasI(gas, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nvec3 readFlagPos()\n{\n    //return vec3(96,0,80);\n    return getPixel(100,0).xyz;\n}\nvoid writeFlagPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(100,0,fragCoord)) fragColor.xyz=pos;\n}\n\n//-------------------------------------------------------------------------------------\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvec4 mat2quat(mat3 m)\n{\n    float T=m[0].x+m[1].y+m[2].z+1.0;\n    if(T<0.0000001) return vec4(0.0,0.0,0.0,1.0);\n    //assuming positive trace\n    float S = 0.5/sqrt(T);\n    vec4 q;\n    q.w = 0.25/S;\n    q.x = (m[2].y-m[1].z)*S;\n    q.y = (m[0].z-m[2].x)*S;\n    q.z = (m[1].x-m[0].y)*S;\n    return q;\n}\n\nvec4 slerpQuat(vec4 q1, vec4 q2, float t)\n{\n    vec4 q3;\n    float dot = dot(q1, q2);\n\n    /*\tdot = cos(theta)\n     if (dot < 0), q1 and q2 are more than 90 degrees apart,\n     so we can invert one to reduce spinning\t*/\n    if (dot < 0.0)\n    {\n        dot = -dot;\n        q3 = -q2;\n    } else q3 = q2;\n\n    if (dot < 0.95)\n    {\n        float angle = acos(dot);\n        return (q1*sin(angle*(1.0-t)) + q3*sin(angle*t))/sin(angle);\n    } else // if the angle is small, use linear interpolation\n        return mix(q1,q3,t);\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos, int i)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPosI(i);\n    vec4 cq = readCamQuatI(i);\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1.0/(1.0+exp(-x));\n}\n\nfloat dominantMax(float d1, float d2, float sc)\n{\n    return mix(d1,d2,fermi((d2-d1)/sc-2.0));\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    //plane\n    //dist=pos.z;\n    //dist+=clamp(5.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0);\n\n    // make a little crater at flag station\n    vec3 flagPos=readFlagPos();\n    dist = dominantMax(-(length(pos-flagPos)-FlagRadius)+0.7*snoise3DS(pos*0.01),dist,0.6);\n    //dist = min((length(pos-flagPos)-FlagRadius)+0.6*snoise3DS(pos*0.02),dist);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/3.0/Mass)\n#define WheelRadius 0.45\n\n#define ObjBoundRadius 3.5\n\nvec4 getDistanceObjS(vec3 pos, float steeringAngle)\n{\n    //return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    float obj=0.0;\n    float dist = 100000.0;\n    //float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n\nvec3 calcFlagPos(vec3 pos)\n{\n    //pos-=(getRand4(dot(pos,vec3(1.0))).xyz-vec3(0.5))*50.0;\n    vec3 rand3=getRand4(dot(pos.xyz,vec3(1.0))).xyz;\n    vec3 grad=getDistanceWorldSGradient(pos,0.1);\n    vec3 n=normalize(cross(rand3,grad));\n    // move around tangential\n    int allScore=0;\n    for(int i=0;i<MaxParticleNum;i++) allScore+=int(readParticle(i).score);\n\n    for(int i=0;i<200;i++)\n    {\n        if(i>20+allScore*14) break;\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        vec3 n=normalize(cross(grad,cross(n,grad)));\n        pos+=3.0*n;\n        float dist=getDistanceWorldS(pos);\n        grad=getDistanceWorldSGradient(pos,0.1);\n        pos-=0.7*normalize(grad)*dist;\n    }\n    // converge back to surface\n    for(int i=0;i<10;i++)\n    {\n        float dist=getDistanceWorldS(pos);\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        //pos-=0.7*normalize(grad)*dist;\n    }\n    //return vec3(96,0,80);\n    return pos;\n}\n\n\n\n\nint getDigitMask(int d)\n{\n    if(d==0x0) return 0x00EAAAE;\n    if(d==0x1) return 0x004C444;\n    if(d==0x2) return 0x00E2E8E;\n    if(d==0x3) return 0x00E2E2E;\n    if(d==0x4) return 0x00AAE22;\n    if(d==0x5) return 0x00E8E2E;\n    if(d==0x6) return 0x00E8EAE;\n    if(d==0x7) return 0x00E2222;\n    if(d==0x8) return 0x00EAEAE;\n    if(d==0x9) return 0x00EAE2E;\n    if(d==0xa) return 0x004AAEA;\n    if(d==0xb) return 0x00CACAC;\n    if(d==0xc) return 0x0068886;\n    if(d==0xd) return 0x00CAAAC;\n    if(d==0xe) return 0x00E8C8E;\n    if(d==0xf) return 0x00E8C88;\n    return -1;\n}\n\n#if 1\n//ABCDEF641jk73n0p9r5tuvw8y2\n//         xx  x x x xxxx x\n\n#define O_ 0x10\n#define I_ 0x11\n#define Z_ 0x12\n#define M_ 0x13\n#define H_ 0x14\n#define S_ 0x15\n#define G_ 0x16\n#define L_ 0x17\n#define X_ 0x18\n#define Q_ 0x19\n#define A_ 0x1A\n#define B_ 0x1B\n#define C_ 0x1C\n#define D_ 0x1D\n#define E_ 0x1E\n#define F_ 0x1F\n#define J_ 0x21\n#define N_ 0x22\n#define W_ 0x23\n#define K_ 0x24\n#define U_ 0x25\n#define P_ 0x26\n#define V_ 0x27\n#define T_ 0x28\n#define Y_ 0x29\n#define R_ 0x2A\n#define dot_ 0x30\n#define dot2_ 0x31\n#define space_ 0x32\n#define minus_ 0x33\n\nint getLetterMask(int d)\n{\n    if(d==O_) return 0x004AAA4; // O\n    if(d==I_) return 0x00E444E; // I\n    if(d==Z_) return 0x00E248E; // Z\n    if(d==M_) return 0x00AEEAA; // M\n    if(d==H_) return 0x00AAEAA; // H\n    if(d==S_) return 0x00E8E2E; // S\n    if(d==G_) return 0x00E8AAE; // G\n    if(d==L_) return 0x008888E; // L\n    if(d==X_) return 0x00EAEAE; // X\n    if(d==Q_) return 0x004AAA6; // q\n    if(d==A_) return 0x004AAEA; // A\n    if(d==B_) return 0x00CACAC; // B\n    if(d==C_) return 0x0068886; // C\n    if(d==D_) return 0x00CAAAC; // D\n    if(d==E_) return 0x00E8C8E; // E\n    if(d==F_) return 0x00E8C88; // F\n    if(d==J_) return 0x00E222C; // J\n    if(d==N_) return 0x00CAAAA; // N\n    if(d==W_) return 0x00AAEEA; // W\n    if(d==K_) return 0x00AAEAA; // K\n    if(d==U_) return 0x00AAAAE; // U\n    if(d==P_) return 0x00E8AAE; // P\n    if(d==V_) return 0x00AAAA4; // V\n    if(d==T_) return 0x00E4444; // T\n    if(d==Y_) return 0x00AAE44; // Y\n    if(d==R_) return 0x00CAACA; // R\n    if(d==dot_) return 0x0000004; // .\n    if(d==dot2_) return 0x0004004; // :\n    if(d==space_) return 0x0000000; // _\n    if(d==minus_) return 0x0000E00; // _\n    return getDigitMask(d);\n}\n\n\nvoid drawLetter(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getLetterMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nvoid drawText(mat4 str, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    for(int i=0;i<4;i++)\n    {\n        bool breakIt=false;\n        for(int j=0;j<4;j++)\n        {\n            if(int(str[i][j])<0) { breakIt=true; break; }\n            drawLetter(int(str[i][j]),pos+size*vec2(4.0*float(i*4+j),0),size,fragColor,fragCoord);\n        }\n        if(breakIt) break;\n    }\n}\n\n#endif\n\nvoid drawDigit(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getDigitMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nint getDigit(int n, int d)\n{\n    return int(mod(float(n)/pow(10.0,float(d)),10.0));\n}\n\nint getDigitF(float f, int d)\n{\n    if(d<0) return int(mod(f/pow(0.1,float(-d)),10.0));\n    return int(mod(f/pow(10.0,float(d)),10.0));\n}\n\nvoid drawInt(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    for(int i=0;i<100;i++) { if(n2-1>=n) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        if(i==dn) break;\n        drawDigit(getDigit(n,dn-1-i), pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\n\nvoid drawFloat(float f, int dotnum, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    if(f<0.0) { f=-f; drawLetter(minus_, pos, size, fragColor, fragCoord); pos+=vec2(4.0*size,0); }\n    for(int i=0;i<100;i++) { if(float(n2-1)>=f) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        int d;\n        if      (i<dn)  d=getDigitF(f,dn-1-i);\n        else if (i==dn) d=dot_;\n        else if (i>dn)  d=getDigitF(f,dn-1-i+1);\n        if(i==dn+dotnum+1) break;\n        drawLetter(d, pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\n\n#define lightPos vec3(-0.06,0.30,0)\n\n#define godStrength 1.3\n#define godPower 1.5\n#define sampNum 64\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int view = int((fragCoord.y/iResolution.y)*float(NumViews));\n    float aspect=iResolution.y/iResolution.x/float(NumViews);\n    vec2 ires2 = iResolution.xy/vec2(1,float(NumViews));\n    vec2 spos = mod(fragCoord.xy,ires2)/ires2*2.0-vec2(1.0);\n    vec3 right, fwd, up, pos, dir;\n    getEyeCoords(right,fwd,up,pos,dir,aspect,spos,view);\n\n    vec2 ppos = fragCoord.xy/iResolution.xy*2.0-vec2(1.0);\n\n    vec3 lpos = lightPos;\n    lpos = 0.5*vec3(0.3*cos(time*0.3132*3.0),cos(time*0.534*3.0),0);\n    vec4 camQuat=readCamQuat();\n    lpos = transformVecByQuat(vec3(0,0,100)-pos,inverseQuat(camQuat));\n    lpos.xy/=lpos.z;\n    lpos.xy = calcScreenPos(pos, right, fwd, up, pos+vec3(0,0,10000), aspect);\n    lpos.z=dot(vec3(0,0,1),fwd);\n\n    float rnd=0.2*texture(randSampler,normalize(ppos.xy-lpos.xy)*0.07+vec2(time*0.02), -1000.0).x;\n\n    float occ=0.0;\n\n    int i;\n    float sum=0.0;\n    vec4 col = vec4(0);\n    vec2  ldistv = ppos.xy-lpos.xy;\n    float ldist=length(ldistv);\n    float amp = pow(ldist,godPower)*godStrength;\n    amp=clamp(amp,0.0,1.0);\n    vec2 delta = normalize(ppos.xy-lpos.xy);\n    for(int i=0;i<sampNum;i++)\n    {\n        vec2 ppos2;\n        vec2 texc;\n        float weight = 1.0-length((float(i))/float(sampNum));\n        float sampOffs=-sign(lpos.z)*(float(i))/float(sampNum);\n        ppos2 = ppos.xy+amp*sampOffs*delta;\n        texc = ppos2*0.5+vec2(0.5);\n        vec4 c1=clamp(vec4(-0.4+0.1*rnd)+texture(iChannel0,texc),vec4(0),vec4(1))+vec4(0.2);\n        col+=weight*pow(c1,vec4(2.0));\n        sum+=weight;\n    }\n    col/=sum;\n    //col=1.0*mix(texture(iChannel0,fragCoord.xy/iResolution.xy),1.0*col,0.5*clamp(1.0-0.8*(-lpos.z*0.5+0.5),0.0,1.0));\n    float gf=clamp(1.0-4.0*(-lpos.z*0.5+0.5),0.0,1.0);\n    col=texture(iChannel0,fragCoord.xy/iResolution.xy)+col*1.0*gf;\n    fragColor = col*(1.0-0.25*gf);\n\n    for(int i=0;i<MaxParticleNum;i++)\n    {\n        Particle p = readParticle(i);\n        drawInt(int(p.score),\n                vec2(10.0,10.0+iResolution.y/float(MaxParticleNum)*float(i)),\n                iResolution.y/float(MaxParticleNum)*0.03,\n                fragColor,fragCoord);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n//#define SHOW_CRATERS\n\n#define readSampler iChannel0\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n#define frameTime iTimeDelta\n//----- common ------\n\n#define MaxParticleNum 2\n#define NumViews int(min(float(MaxParticleNum),2.0))\n//#define NumViews 2\n#define InRes iChannel0Resolution\n\n#define FlagRadius 3.0\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n    float score;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,p.score,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    p.score  = p2.y;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeCamPosI(vec3 pos, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(0+i*20,0,fragCoord)) fragColor.xyz=pos;\n}\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord) { writeCamPosI(pos, fragColor, fragCoord, 0); }\n\nvec3 readCamPosI(int i)\n{\n    return getPixel(0+i*20,0).xyz;\n}\nvec3 readCamPos() { return readCamPosI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamQuatI(vec4 quat, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(1+i*20,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2+i*20,0,fragCoord)) fragColor.x=quat.w;\n}\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord) { writeCamQuatI(quat, fragColor, fragCoord, 0); }\n\nvec4 readCamQuatI(int i)\n{\n    vec4 q;\n    q   = getPixel(1+i*20,0);\n    q.w = getPixel(2+i*20,0).x;\n    return q;\n}\nvec4 readCamQuat() { return readCamQuatI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamNavI(vec3 nav, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(3+i*20,0,fragCoord)) fragColor.xyz=nav;\n}\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord) { writeCamNavI(nav, fragColor, fragCoord, 0); }\n\nvec3 readCamNavI(int i)\n{\n    return getPixel(3+i*20,0).xyz;\n}\nvec3 readCamNav() { return readCamNavI(0); }\n\n//-------------------------------------------------------------------------------------\nfloat readSteeringAngleI(int i)\n{\n    return getPixel(4+i*20,0).x;\n}\nfloat readSteeringAngle() { return readSteeringAngleI(0); }\n\nvoid writeSteeringAngleI(float st, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.x=st;\n}\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord) { writeSteeringAngleI(st, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nfloat readGasI(int i)\n{\n    return getPixel(4+i*20,0).y;\n}\nfloat readGas() { return readGasI(0); }\n\nvoid writeGasI(float gas, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.y=gas;\n}\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord) { writeGasI(gas, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nvec3 readFlagPos()\n{\n    //return vec3(96,0,80);\n    return getPixel(100,0).xyz;\n}\nvoid writeFlagPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(100,0,fragCoord)) fragColor.xyz=pos;\n}\n\n//-------------------------------------------------------------------------------------\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvec4 mat2quat(mat3 m)\n{\n    float T=m[0].x+m[1].y+m[2].z+1.0;\n    if(T<0.0000001) return vec4(0.0,0.0,0.0,1.0);\n    //assuming positive trace\n    float S = 0.5/sqrt(T);\n    vec4 q;\n    q.w = 0.25/S;\n    q.x = (m[2].y-m[1].z)*S;\n    q.y = (m[0].z-m[2].x)*S;\n    q.z = (m[1].x-m[0].y)*S;\n    return q;\n}\n\nvec4 slerpQuat(vec4 q1, vec4 q2, float t)\n{\n    vec4 q3;\n    float dot = dot(q1, q2);\n\n    /*\tdot = cos(theta)\n     if (dot < 0), q1 and q2 are more than 90 degrees apart,\n     so we can invert one to reduce spinning\t*/\n    if (dot < 0.0)\n    {\n        dot = -dot;\n        q3 = -q2;\n    } else q3 = q2;\n\n    if (dot < 0.95)\n    {\n        float angle = acos(dot);\n        return (q1*sin(angle*(1.0-t)) + q3*sin(angle*t))/sin(angle);\n    } else // if the angle is small, use linear interpolation\n        return mix(q1,q3,t);\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos, int i)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPosI(i);\n    vec4 cq = readCamQuatI(i);\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1.0/(1.0+exp(-x));\n}\n\nfloat dominantMax(float d1, float d2, float sc)\n{\n    return mix(d1,d2,fermi((d2-d1)/sc-2.0));\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    //plane\n    //dist=pos.z;\n    //dist+=clamp(5.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0);\n\n    // make a little crater at flag station\n#ifdef SHOW_CRATERS\n    vec3 flagPos=readFlagPos();\n    dist = dominantMax(-(length(pos-flagPos)-FlagRadius)+0.7*snoise3DS(pos*0.01),dist,0.6);\n#endif\n    //dist = min((length(pos-flagPos)-FlagRadius)+0.6*snoise3DS(pos*0.02),dist);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/3.0/Mass)\n#define WheelRadius 0.45\n\n#define ObjBoundRadius 3.5\n\nvec4 getDistanceObjS(vec3 pos, float steeringAngle)\n{\n    //return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    float obj=0.0;\n    float dist = 100000.0;\n    //float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n\nvec3 calcFlagPos(vec3 pos)\n{\n    //pos-=(getRand4(dot(pos,vec3(1.0))).xyz-vec3(0.5))*50.0;\n    vec3 rand3=getRand4(dot(pos.xyz,vec3(1.0))).xyz;\n    vec3 grad=getDistanceWorldSGradient(pos,0.1);\n    vec3 n=normalize(cross(rand3,grad));\n    // move around tangential\n    int allScore=0;\n    for(int i=0;i<MaxParticleNum;i++) allScore+=int(readParticle(i).score);\n\n    for(int i=0;i<200;i++)\n    {\n        if(i>20+allScore*14) break;\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        vec3 n=normalize(cross(grad,cross(n,grad)));\n        pos+=3.0*n;\n        float dist=getDistanceWorldS(pos);\n        grad=getDistanceWorldSGradient(pos,0.1);\n        pos-=0.7*normalize(grad)*dist;\n    }\n    // converge back to surface\n    for(int i=0;i<10;i++)\n    {\n        float dist=getDistanceWorldS(pos);\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        //pos-=0.7*normalize(grad)*dist;\n    }\n    //return vec3(96,0,80);\n    return pos;\n}\n//----- update ------\n\nvoid initAll( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0.0);\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n    Particle p;\n    if(pidx>=0)\n    {\n        p.pos.xyz = vec3(float(pidx*5)+torusWorldRadius1,0.0,torusWorldRadius2*1.1);\n        p.vel.xyz = vec3(0,0,0);\n        p.quat = vec4(0,0,0,1);\n        p.quat = normalize(vec4(0.46,0.68,0.26,0.5));\n        p.pos.xyz = vec3(101.7,2.41,84.72)+vec3(5,5,0)*float(pidx);\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n    writeCamPos(vec3(0),fragColor,fragCoord);\n    writeCamPosI(vec3(99.5,4.5,54.8),fragColor,fragCoord,0);\n    writeCamPosI(vec3(99.5,4.5,54.8)+vec3(5,5,0),fragColor,fragCoord,1);\n    writeCamQuat(vec4(0,0,0,1),fragColor,fragCoord);\n    writeCamQuatI(normalize(vec4(0.592,0.428,0.471,0.494)),fragColor,fragCoord,0);\n    writeCamQuatI(normalize(vec4(0.592,0.428,0.471,0.494)),fragColor,fragCoord,1);\n    writeSteeringAngleI(0.2,fragColor,fragCoord,0);\n    writeSteeringAngleI(0.2,fragColor,fragCoord,1);\n    writeGasI(0.0,fragColor,fragCoord,0);\n    writeGasI(0.0,fragColor,fragCoord,1);\n    writeCamNavI(vec3(30.0,-0.54,0.3), fragColor, fragCoord,0);\n    writeCamNavI(vec3(30.0,-0.54,0.3), fragColor, fragCoord,1);\n    writeFlagPos(vec3(0,0,0), fragColor, fragCoord);\n}\n\n#define SpringConst 20.1\n#define SpringConstStab 5.1\n#define DT min(frameTime*1.0,0.06)\n\nvoid calcWheelForceAndTorque(inout Particle p, vec3 wheelPos, float wheelRadius, float steeringAngle, float frictionCoeff, float wheelAngSpeed, float springConst, float clutch, inout vec3 force, inout vec3 torque)\n{\n    vec3 wheelPosW = p.pos.xyz+transformVecByQuat(wheelPos.xyz,p.quat);\n    float dist = getDistanceWorldS(wheelPosW);\n    if(dist<wheelRadius)\n    {\n        // forces by wheels\n        vec3 dforce = vec3(0,0,0);\n        vec3 distGrad = getDistanceWorldSGradient(wheelPosW,0.1);\n        vec3 distDir = normalize(distGrad);\n        dforce=distDir*(wheelRadius-dist)*springConst;\n        //p.vel.xyz -= distDir*dot(p.vel.xyz,distDir)*0.1;\n        float fl = length(dforce);\n        //if(fl>5.0) { dforce=dforce/fl*5.0; fl = length(dforce); }\n        force  += dforce;\n        torque += cross(dforce,wheelPosW-p.pos.xyz);\n\n        // wheel-drive-forces\n        vec3 chassisRotVel = transformVecByQuat(cross(-p.angVel.xyz,wheelPos.xyz+vec3(0,0,-WheelRadius)),p.quat);\n        vec3 wheelAxe = transformVecByQuat(vec3(cos(steeringAngle),sin(-steeringAngle),0),p.quat);\n        vec3 f=normalize(cross(distDir,wheelAxe));\n        //vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel+dot(p.vel.xyz+chassisRotVel,distDir)*0.9*distDir;\n        ///*if(length(c)>1.0)*/ c=normalize(c);\n        //dforce = fl*frictionCoeff*c;\n\n        vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel;\n        dforce = vec3(0.0);\n        float ffr = fl*frictionCoeff; if(ffr>5.0) ffr=5.0;\n        // in f dir\n        dforce += ffr*clutch*sign(dot(c,f))*f;\n        // in wheelaxe dir\n        dforce += ffr*sign(dot(c,wheelAxe))*wheelAxe;\n        // in up dir - pure velocity damping in the dampers\n        float du=4.7; /* damping for wheel down (chassis up) */\n        float dd=2.7; /* damping for wheel up (chassis down) */\n        dforce += ((du+dd)*0.5*sign(dot(c,distDir))-0.5*(du-dd))*distDir;\n\n        force += dforce;\n        torque += cross(dforce,wheelPosW+transformVecByQuat(vec3(0,0,-WheelRadius),p.quat)-p.pos.xyz);\n    }\n\n}\n\nvoid calcObjForceAndMom(Particle p, Particle p2, inout vec3 force, inout vec3 torque)\n{\n    vec3 collpos1;\n    vec3 collpos2;\n    vec3 dforce=vec3(0);\n    vec3 d;\n    vec3 dn;\n\n    for(int k=0;k<4;k++)\n    {\n        //collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&1),p.quat);\n        //collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&2)*0.5,p2.quat);\n        collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*mod(float(k),2.0), p.quat);\n        collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k/2)*0.5,    p2.quat);\n\n        d = collpos1 - collpos2;\n        dn = p2.pos.xyz-p.pos.xyz;\n        if( length(d)<2.0 ) dforce=100.1*d/(length(d)+0.1);\n        force+=dforce;\n        torque+=1.0*cross(dforce,0.5*(collpos1+collpos2)-p.pos.xyz);\n    }\n    //TODO: friction force+torque\n    //torque+=0.3*cross(cross(dforce,normalize(dn)),0.5*(collpos1+collpos2)-pos);\n}\n\n#define GRAVITY -4.0\nvec3 getGravityWorld(vec3 pos)\n{\n    return GRAVITY*normalize(getDistanceWorldSGradientSlow(pos, 5.0)+getDistanceWorldSGradientSlow(pos, 10.0));\n}\n\n#define keyTex iChannel1\n#define KEY_CODE(_x_) texture(keyTex,vec2((float(_x_)+0.5)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_LEFT  KEY_CODE(37)\n#define KEY_UP    KEY_CODE(38)\n#define KEY_RIGHT KEY_CODE(39)\n#define KEY_DOWN  KEY_CODE(40)\n#define KEY_0     KEY_CODE(48)\n#define KEY_1     KEY_CODE(49)\n#define KEY_2     KEY_CODE(50)\n#define KEY_3     KEY_CODE(51)\n#define KEY_4     KEY_CODE(52)\n#define KEY_5     KEY_CODE(53)\n#define KEY_6     KEY_CODE(54)\n#define KEY_7     KEY_CODE(55)\n#define KEY_8     KEY_CODE(56)\n#define KEY_9     KEY_CODE(57)\n#define KEY_A     KEY_CODE(65)\n#define KEY_B     KEY_CODE(66)\n#define KEY_C     KEY_CODE(67)\n#define KEY_D     KEY_CODE(68)\n#define KEY_E     KEY_CODE(69)\n#define KEY_F     KEY_CODE(70)\n#define KEY_G     KEY_CODE(71)\n#define KEY_H     KEY_CODE(72)\n#define KEY_I     KEY_CODE(73)\n#define KEY_J     KEY_CODE(74)\n#define KEY_K     KEY_CODE(75)\n#define KEY_L     KEY_CODE(76)\n#define KEY_M     KEY_CODE(77)\n#define KEY_N     KEY_CODE(78)\n#define KEY_O     KEY_CODE(79)\n#define KEY_P     KEY_CODE(80)\n#define KEY_Q     KEY_CODE(81)\n#define KEY_R     KEY_CODE(82)\n#define KEY_S     KEY_CODE(83)\n#define KEY_T     KEY_CODE(84)\n#define KEY_U     KEY_CODE(85)\n#define KEY_V     KEY_CODE(86)\n#define KEY_W     KEY_CODE(87)\n#define KEY_X     KEY_CODE(88)\n#define KEY_Y     KEY_CODE(89)\n#define KEY_Z     KEY_CODE(90)\n\nvec4 fwdRight2Quat(vec3 fwd, vec3 right)\n{\n    float lfwd  =length(fwd);\n    float lright=length(right);\n    if(lfwd  <0.00001) return vec4(0,0,0,1);\n    if(lright<0.00001) return vec4(0,0,0,1);\n    fwd/=lfwd;\n    right/=lright;\n    return normalize(inverseQuat(mat2quat(mat3(right,fwd,cross(right,fwd)))));\n}\n\nvoid calcCameraI( inout vec4 fragColor, in vec2 fragCoord, int i, bool zoomOut, bool zoomIn, bool rotLeft, bool rotRight )\n{\n    vec3 camPos  = readCamPosI(i);\n    vec4 camQuat = readCamQuatI(i);\n    vec3 camDistRzRx = readCamNavI(i);\n    float camDistScalar = camDistRzRx.x;\n    float camRotZ = camDistRzRx.y;\n    float camRotX = camDistRzRx.z;\n\n    float sDist=getDistanceWorldS(camPos);\n    if(sDist<0.2) camDistScalar-=16.0*DT;\n    if(zoomOut) camDistScalar-=10.0*DT;\n    if(zoomIn ) camDistScalar+=10.0*DT;\n    if(camDistScalar<20.5) camDistScalar+=3.0*DT;\n    if(camDistScalar<3.5) camDistScalar=3.5;\n\n    if(rotLeft)  camRotZ-=1.0*DT;\n    if(rotRight) camRotZ+=1.0*DT;\n\n    Particle p = readParticle(i);\n    vec3 camDist = vec3(-sin(camRotZ)*cos(camRotX),-cos(camRotZ)*cos(camRotX),sin(camRotX))*camDistScalar;\n\n    vec3 newCamPos  = p.pos.xyz+transformVecByQuat(camDist,p.quat);\n    camPos  = mix( camPos,  newCamPos,  0.02 );\n\n    vec3 dpos=p.pos.xyz-camPos;\n    dpos=transformVecByQuat(dpos,inverseQuat(p.quat));\n    vec4 newCamQuat = multQuat(p.quat,fwdRight2Quat(dpos,vec3(dpos.yx*vec2(1.0,-1.0),0.0)));\n\n    camQuat = normalize(slerpQuat( camQuat, newCamQuat, 0.3 ));\n\n    camDistRzRx.x=camDistScalar;\n    camDistRzRx.y=camRotZ;\n    camDistRzRx.z=camRotX;\n    writeCamNavI(camDistRzRx, fragColor, fragCoord, i);\n    writeCamQuatI(camQuat, fragColor, fragCoord, i);\n    writeCamPosI(camPos,   fragColor, fragCoord, i);\n}\n\nvoid calcCamera( inout vec4 fragColor, in vec2 fragCoord)\n{\n    calcCameraI(fragColor, fragCoord, 0, KEY_R>0.5, KEY_F>0.5, KEY_E>0.5, KEY_Q>0.5);\n    calcCameraI(fragColor, fragCoord, 1, KEY_O>0.5, KEY_L>0.5, KEY_I>0.5, KEY_Z>0.5 || KEY_Y>0.5);\n}\n\nvoid calcSteeringI( inout vec4 fragColor, in vec2 fragCoord, int i, bool leftkey, bool rightkey, bool upkey, bool downkey)\n{\n    float steeringAngle = readSteeringAngleI(i);\n    float gas = readGasI(i);\n\n    if     (leftkey ) steeringAngle-=0.6*DT;\n    else if(rightkey) steeringAngle+=0.6*DT;\n    else steeringAngle*=pow(0.9,DT/0.03);\n\n    if     (upkey  ) gas+=0.2*DT;\n    else if(downkey) gas-=0.2*DT;\n    else gas*=pow(0.9,DT/0.03);\n\n    gas=clamp(gas,-1.0,1.0);\n    steeringAngle=clamp(steeringAngle,-0.5,0.5);\n\n    writeSteeringAngleI(steeringAngle,   fragColor, fragCoord, i);\n    writeGasI(gas, fragColor, fragCoord, i);\n}\n\nvoid calcSteering( inout vec4 fragColor, in vec2 fragCoord )\n{\n    calcSteeringI(fragColor, fragCoord, 0,\n                  KEY_A>0.5 || KEY_LEFT >0.5,\n                  KEY_D>0.5 || KEY_RIGHT>0.5,\n                  KEY_W>0.5 || KEY_UP  >0.5,\n                  KEY_S>0.5 || KEY_DOWN>0.5);\n    calcSteeringI(fragColor, fragCoord, 1,\n                  KEY_H>0.5,\n                  KEY_K>0.5,\n                  KEY_U>0.5,\n                  KEY_J>0.5);\n}\n\nvoid updateFlag( inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 flagPos=readFlagPos();\n    vec3 posAvg=vec3(0.0);\n    for(int i=0;i<MaxParticleNum;i++)\n    {\n        Particle p = readParticle(i);\n        posAvg+=p.pos.xyz;\n        vec3 dpos = p.pos.xyz-flagPos;\n        if(dot(dpos,dpos)<FlagRadius*FlagRadius)\n        {\n            writeFlagPos(calcFlagPos(p.pos.xyz), fragColor, fragCoord);\n        }\n    }\n    posAvg/=float(MaxParticleNum);\n    if( flagPos.x==0.0 && flagPos.y==0.0 && flagPos.z==0.0 && iFrame>100 )\n    {\n        writeFlagPos(calcFlagPos(posAvg), fragColor, fragCoord);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // copy old content\n    fragColor = getPixel(int(fragCoord.x),int(fragCoord.y));\n\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n\n    if(pidx>=0 && pidx<MaxParticleNum)\n    {\n        vec3 force = vec3(0,0,0);\n        vec3 torque = vec3(0,0,0);\n\n        Particle p = readParticle(pidx);\n\n        // gravity\n        force+=getGravityWorld(p.pos.xyz)*Mass;\n\n        // velocity damping\n        force+=-0.2*p.vel.xyz;\n        torque+=-0.2*transformVecByQuat(p.angVel.xyz,p.quat);\n\n        float steeringAngle = readSteeringAngleI(pidx);\n        float gas = readGasI(pidx);\n        float clutch = clamp(abs(gas),0.0,1.0);\n        float rotSpeed = gas*50.0;\n        if(KEY_X>0.5) { clutch=1.0; gas=0.0; }\n        // wheel forces\n        calcWheelForceAndTorque(p,WheelFL,WheelRadius,steeringAngle,0.8,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelFR,WheelRadius,steeringAngle,0.8,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBL,WheelRadius,     0.0,     0.8,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBR,WheelRadius,     0.0,     0.8,rotSpeed,SpringConst,clutch,force,torque);\n        // stabilizers\n        calcWheelForceAndTorque(p,vec3(0,0,1.6),1.8,     0.0,     0.0,0.0,SpringConstStab,1.0,force,torque);\n\n        vec3 fwd=transformVecByQuat(vec3(0,1,0),p.quat);\n        vec3 up=transformVecByQuat(vec3(0,0,1),p.quat);\n\n        // obj-obj collision forces\n        for(int i=0;i<MaxParticleNum;i++)\n        {\n            if (i!=pidx)\n            {\n                Particle p2 = readParticle(i);\n                calcObjForceAndMom(p,p2,force,torque);\n            }\n        }\n\n        // clamp velocity\n        float velLen = length(p.vel.xyz);\n        if(velLen>120.1) p.vel.xyz*=120.1/velLen;\n        /*float angVelLen = length(p.angVel.xyz);\n        if(angVelLen>3.1) p.angVel.xyz*=3.1/velLen;*/\n\n        // time integration\n        // ...positional\n        vec3 acc = force/Mass;\n        p.vel.xyz += acc*0.5*DT;\n        p.pos.xyz += p.vel.xyz*DT;\n        p.vel.xyz += acc*0.5*DT;\n        // ...angular\n        vec3 angAcc = Iinv*transformVecByQuat(torque,inverseQuat(p.quat));\n        p.angVel.xyz += angAcc*0.5*DT;\n        p.quat = normalize(rotateQuatbyAngle(p.quat,-p.angVel.xyz*DT));\n        p.angVel.xyz += angAcc*0.5*DT;\n\n        vec3 flagPos=readFlagPos();\n        vec3 dpos = p.pos.xyz-flagPos;\n        if(dot(dpos,dpos)<FlagRadius*FlagRadius)\n        {\n            p.score+=0.5;\n        }\n\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n    else\n    {\n        calcCamera(fragColor,fragCoord);\n\n        calcSteering(fragColor,fragCoord);\n\n        updateFlag(fragColor,fragCoord);\n    }\n\n    if(iFrame<10 || KEY_0>0.5) initAll(fragColor,fragCoord);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n//#define SHOW_CRATERS\n\n#define readSampler iChannel0\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n#define frameTime iTimeDelta\n//----- common ------\n\n#define MaxParticleNum 2\n#define NumViews int(min(float(MaxParticleNum),2.0))\n//#define NumViews 2\n#define InRes iChannel0Resolution\n\n#define FlagRadius 3.0\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n    float score;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,p.score,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    p.score  = p2.y;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeCamPosI(vec3 pos, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(0+i*20,0,fragCoord)) fragColor.xyz=pos;\n}\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord) { writeCamPosI(pos, fragColor, fragCoord, 0); }\n\nvec3 readCamPosI(int i)\n{\n    return getPixel(0+i*20,0).xyz;\n}\nvec3 readCamPos() { return readCamPosI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamQuatI(vec4 quat, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(1+i*20,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2+i*20,0,fragCoord)) fragColor.x=quat.w;\n}\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord) { writeCamQuatI(quat, fragColor, fragCoord, 0); }\n\nvec4 readCamQuatI(int i)\n{\n    vec4 q;\n    q   = getPixel(1+i*20,0);\n    q.w = getPixel(2+i*20,0).x;\n    return q;\n}\nvec4 readCamQuat() { return readCamQuatI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamNavI(vec3 nav, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(3+i*20,0,fragCoord)) fragColor.xyz=nav;\n}\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord) { writeCamNavI(nav, fragColor, fragCoord, 0); }\n\nvec3 readCamNavI(int i)\n{\n    return getPixel(3+i*20,0).xyz;\n}\nvec3 readCamNav() { return readCamNavI(0); }\n\n//-------------------------------------------------------------------------------------\nfloat readSteeringAngleI(int i)\n{\n    return getPixel(4+i*20,0).x;\n}\nfloat readSteeringAngle() { return readSteeringAngleI(0); }\n\nvoid writeSteeringAngleI(float st, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.x=st;\n}\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord) { writeSteeringAngleI(st, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nfloat readGasI(int i)\n{\n    return getPixel(4+i*20,0).y;\n}\nfloat readGas() { return readGasI(0); }\n\nvoid writeGasI(float gas, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.y=gas;\n}\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord) { writeGasI(gas, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nvec3 readFlagPos()\n{\n    //return vec3(96,0,80);\n    return getPixel(100,0).xyz;\n}\nvoid writeFlagPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(100,0,fragCoord)) fragColor.xyz=pos;\n}\n\n//-------------------------------------------------------------------------------------\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvec4 mat2quat(mat3 m)\n{\n    float T=m[0].x+m[1].y+m[2].z+1.0;\n    if(T<0.0000001) return vec4(0.0,0.0,0.0,1.0);\n    //assuming positive trace\n    float S = 0.5/sqrt(T);\n    vec4 q;\n    q.w = 0.25/S;\n    q.x = (m[2].y-m[1].z)*S;\n    q.y = (m[0].z-m[2].x)*S;\n    q.z = (m[1].x-m[0].y)*S;\n    return q;\n}\n\nvec4 slerpQuat(vec4 q1, vec4 q2, float t)\n{\n    vec4 q3;\n    float dot = dot(q1, q2);\n\n    /*\tdot = cos(theta)\n     if (dot < 0), q1 and q2 are more than 90 degrees apart,\n     so we can invert one to reduce spinning\t*/\n    if (dot < 0.0)\n    {\n        dot = -dot;\n        q3 = -q2;\n    } else q3 = q2;\n\n    if (dot < 0.95)\n    {\n        float angle = acos(dot);\n        return (q1*sin(angle*(1.0-t)) + q3*sin(angle*t))/sin(angle);\n    } else // if the angle is small, use linear interpolation\n        return mix(q1,q3,t);\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos, int i)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPosI(i);\n    vec4 cq = readCamQuatI(i);\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1.0/(1.0+exp(-x));\n}\n\nfloat dominantMax(float d1, float d2, float sc)\n{\n    return mix(d1,d2,fermi((d2-d1)/sc-2.0));\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    //plane\n    //dist=pos.z;\n    //dist+=clamp(5.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0);\n\n    // make a little crater at flag station\n#ifdef SHOW_CRATERS\n    vec3 flagPos=readFlagPos();\n    dist = dominantMax(-(length(pos-flagPos)-FlagRadius)+0.7*snoise3DS(pos*0.01),dist,0.6);\n#endif\n    //dist = min((length(pos-flagPos)-FlagRadius)+0.6*snoise3DS(pos*0.02),dist);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/3.0/Mass)\n#define WheelRadius 0.45\n\n#define ObjBoundRadius 3.5\n\nvec4 getDistanceObjS(vec3 pos, float steeringAngle)\n{\n    //return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    float obj=0.0;\n    float dist = 100000.0;\n    //float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n\nvec3 calcFlagPos(vec3 pos)\n{\n    //pos-=(getRand4(dot(pos,vec3(1.0))).xyz-vec3(0.5))*50.0;\n    vec3 rand3=getRand4(dot(pos.xyz,vec3(1.0))).xyz;\n    vec3 grad=getDistanceWorldSGradient(pos,0.1);\n    vec3 n=normalize(cross(rand3,grad));\n    // move around tangential\n    int allScore=0;\n    for(int i=0;i<MaxParticleNum;i++) allScore+=int(readParticle(i).score);\n\n    for(int i=0;i<200;i++)\n    {\n        if(i>20+allScore*14) break;\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        vec3 n=normalize(cross(grad,cross(n,grad)));\n        pos+=3.0*n;\n        float dist=getDistanceWorldS(pos);\n        grad=getDistanceWorldSGradient(pos,0.1);\n        pos-=0.7*normalize(grad)*dist;\n    }\n    // converge back to surface\n    for(int i=0;i<10;i++)\n    {\n        float dist=getDistanceWorldS(pos);\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        //pos-=0.7*normalize(grad)*dist;\n    }\n    //return vec3(96,0,80);\n    return pos;\n}\n//----- update ------\n\nvoid initAll( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0.0);\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n    Particle p;\n    if(pidx>=0)\n    {\n        p.pos.xyz = vec3(float(pidx*5)+torusWorldRadius1,0.0,torusWorldRadius2*1.1);\n        p.vel.xyz = vec3(0,0,0);\n        p.quat = vec4(0,0,0,1);\n        p.quat = normalize(vec4(0.46,0.68,0.26,0.5));\n        p.pos.xyz = vec3(101.7,2.41,84.72)+vec3(5,5,0)*float(pidx);\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n    writeCamPos(vec3(0),fragColor,fragCoord);\n    writeCamPosI(vec3(99.5,4.5,54.8),fragColor,fragCoord,0);\n    writeCamPosI(vec3(99.5,4.5,54.8)+vec3(5,5,0),fragColor,fragCoord,1);\n    writeCamQuat(vec4(0,0,0,1),fragColor,fragCoord);\n    writeCamQuatI(normalize(vec4(0.592,0.428,0.471,0.494)),fragColor,fragCoord,0);\n    writeCamQuatI(normalize(vec4(0.592,0.428,0.471,0.494)),fragColor,fragCoord,1);\n    writeSteeringAngleI(0.2,fragColor,fragCoord,0);\n    writeSteeringAngleI(0.2,fragColor,fragCoord,1);\n    writeGasI(0.0,fragColor,fragCoord,0);\n    writeGasI(0.0,fragColor,fragCoord,1);\n    writeCamNavI(vec3(30.0,-0.54,0.3), fragColor, fragCoord,0);\n    writeCamNavI(vec3(30.0,-0.54,0.3), fragColor, fragCoord,1);\n    writeFlagPos(vec3(0,0,0), fragColor, fragCoord);\n}\n\n#define SpringConst 20.1\n#define SpringConstStab 5.1\n#define DT min(frameTime*1.0,0.06)\n\nvoid calcWheelForceAndTorque(inout Particle p, vec3 wheelPos, float wheelRadius, float steeringAngle, float frictionCoeff, float wheelAngSpeed, float springConst, float clutch, inout vec3 force, inout vec3 torque)\n{\n    vec3 wheelPosW = p.pos.xyz+transformVecByQuat(wheelPos.xyz,p.quat);\n    float dist = getDistanceWorldS(wheelPosW);\n    if(dist<wheelRadius)\n    {\n        // forces by wheels\n        vec3 dforce = vec3(0,0,0);\n        vec3 distGrad = getDistanceWorldSGradient(wheelPosW,0.1);\n        vec3 distDir = normalize(distGrad);\n        dforce=distDir*(wheelRadius-dist)*springConst;\n        //p.vel.xyz -= distDir*dot(p.vel.xyz,distDir)*0.1;\n        float fl = length(dforce);\n        //if(fl>5.0) { dforce=dforce/fl*5.0; fl = length(dforce); }\n        force  += dforce;\n        torque += cross(dforce,wheelPosW-p.pos.xyz);\n\n        // wheel-drive-forces\n        vec3 chassisRotVel = transformVecByQuat(cross(-p.angVel.xyz,wheelPos.xyz+vec3(0,0,-WheelRadius)),p.quat);\n        vec3 wheelAxe = transformVecByQuat(vec3(cos(steeringAngle),sin(-steeringAngle),0),p.quat);\n        vec3 f=normalize(cross(distDir,wheelAxe));\n        //vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel+dot(p.vel.xyz+chassisRotVel,distDir)*0.9*distDir;\n        ///*if(length(c)>1.0)*/ c=normalize(c);\n        //dforce = fl*frictionCoeff*c;\n\n        vec3 c=wheelAngSpeed*wheelRadius*f-p.vel.xyz-chassisRotVel;\n        dforce = vec3(0.0);\n        float ffr = fl*frictionCoeff; if(ffr>5.0) ffr=5.0;\n        // in f dir\n        dforce += ffr*clutch*sign(dot(c,f))*f;\n        // in wheelaxe dir\n        dforce += ffr*sign(dot(c,wheelAxe))*wheelAxe;\n        // in up dir - pure velocity damping in the dampers\n        float du=4.7; /* damping for wheel down (chassis up) */\n        float dd=2.7; /* damping for wheel up (chassis down) */\n        dforce += ((du+dd)*0.5*sign(dot(c,distDir))-0.5*(du-dd))*distDir;\n\n        force += dforce;\n        torque += cross(dforce,wheelPosW+transformVecByQuat(vec3(0,0,-WheelRadius),p.quat)-p.pos.xyz);\n    }\n\n}\n\nvoid calcObjForceAndMom(Particle p, Particle p2, inout vec3 force, inout vec3 torque)\n{\n    vec3 collpos1;\n    vec3 collpos2;\n    vec3 dforce=vec3(0);\n    vec3 d;\n    vec3 dn;\n\n    for(int k=0;k<4;k++)\n    {\n        //collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&1),p.quat);\n        //collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k&2)*0.5,p2.quat);\n        collpos1 = p.pos.xyz  + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*mod(float(k),2.0), p.quat);\n        collpos2 = p2.pos.xyz + transformVecByQuat(vec3(0,0.6,0)-vec3(0,1.2,0)*float(k/2)*0.5,    p2.quat);\n\n        d = collpos1 - collpos2;\n        dn = p2.pos.xyz-p.pos.xyz;\n        if( length(d)<2.0 ) dforce=100.1*d/(length(d)+0.1);\n        force+=dforce;\n        torque+=1.0*cross(dforce,0.5*(collpos1+collpos2)-p.pos.xyz);\n    }\n    //TODO: friction force+torque\n    //torque+=0.3*cross(cross(dforce,normalize(dn)),0.5*(collpos1+collpos2)-pos);\n}\n\n#define GRAVITY -4.0\nvec3 getGravityWorld(vec3 pos)\n{\n    return GRAVITY*normalize(getDistanceWorldSGradientSlow(pos, 5.0)+getDistanceWorldSGradientSlow(pos, 10.0));\n}\n\n#define keyTex iChannel1\n#define KEY_CODE(_x_) texture(keyTex,vec2((float(_x_)+0.5)/256.0,(0.5+0.0)/3.0)).x\n#define KEY_LEFT  KEY_CODE(37)\n#define KEY_UP    KEY_CODE(38)\n#define KEY_RIGHT KEY_CODE(39)\n#define KEY_DOWN  KEY_CODE(40)\n#define KEY_0     KEY_CODE(48)\n#define KEY_1     KEY_CODE(49)\n#define KEY_2     KEY_CODE(50)\n#define KEY_3     KEY_CODE(51)\n#define KEY_4     KEY_CODE(52)\n#define KEY_5     KEY_CODE(53)\n#define KEY_6     KEY_CODE(54)\n#define KEY_7     KEY_CODE(55)\n#define KEY_8     KEY_CODE(56)\n#define KEY_9     KEY_CODE(57)\n#define KEY_A     KEY_CODE(65)\n#define KEY_B     KEY_CODE(66)\n#define KEY_C     KEY_CODE(67)\n#define KEY_D     KEY_CODE(68)\n#define KEY_E     KEY_CODE(69)\n#define KEY_F     KEY_CODE(70)\n#define KEY_G     KEY_CODE(71)\n#define KEY_H     KEY_CODE(72)\n#define KEY_I     KEY_CODE(73)\n#define KEY_J     KEY_CODE(74)\n#define KEY_K     KEY_CODE(75)\n#define KEY_L     KEY_CODE(76)\n#define KEY_M     KEY_CODE(77)\n#define KEY_N     KEY_CODE(78)\n#define KEY_O     KEY_CODE(79)\n#define KEY_P     KEY_CODE(80)\n#define KEY_Q     KEY_CODE(81)\n#define KEY_R     KEY_CODE(82)\n#define KEY_S     KEY_CODE(83)\n#define KEY_T     KEY_CODE(84)\n#define KEY_U     KEY_CODE(85)\n#define KEY_V     KEY_CODE(86)\n#define KEY_W     KEY_CODE(87)\n#define KEY_X     KEY_CODE(88)\n#define KEY_Y     KEY_CODE(89)\n#define KEY_Z     KEY_CODE(90)\n\nvec4 fwdRight2Quat(vec3 fwd, vec3 right)\n{\n    float lfwd  =length(fwd);\n    float lright=length(right);\n    if(lfwd  <0.00001) return vec4(0,0,0,1);\n    if(lright<0.00001) return vec4(0,0,0,1);\n    fwd/=lfwd;\n    right/=lright;\n    return normalize(inverseQuat(mat2quat(mat3(right,fwd,cross(right,fwd)))));\n}\n\nvoid calcCameraI( inout vec4 fragColor, in vec2 fragCoord, int i, bool zoomOut, bool zoomIn, bool rotLeft, bool rotRight )\n{\n    vec3 camPos  = readCamPosI(i);\n    vec4 camQuat = readCamQuatI(i);\n    vec3 camDistRzRx = readCamNavI(i);\n    float camDistScalar = camDistRzRx.x;\n    float camRotZ = camDistRzRx.y;\n    float camRotX = camDistRzRx.z;\n\n    float sDist=getDistanceWorldS(camPos);\n    if(sDist<0.2) camDistScalar-=16.0*DT;\n    if(zoomOut) camDistScalar-=10.0*DT;\n    if(zoomIn ) camDistScalar+=10.0*DT;\n    if(camDistScalar<20.5) camDistScalar+=3.0*DT;\n    if(camDistScalar<3.5) camDistScalar=3.5;\n\n    if(rotLeft)  camRotZ-=1.0*DT;\n    if(rotRight) camRotZ+=1.0*DT;\n\n    Particle p = readParticle(i);\n    vec3 camDist = vec3(-sin(camRotZ)*cos(camRotX),-cos(camRotZ)*cos(camRotX),sin(camRotX))*camDistScalar;\n\n    vec3 newCamPos  = p.pos.xyz+transformVecByQuat(camDist,p.quat);\n    camPos  = mix( camPos,  newCamPos,  0.02 );\n\n    vec3 dpos=p.pos.xyz-camPos;\n    dpos=transformVecByQuat(dpos,inverseQuat(p.quat));\n    vec4 newCamQuat = multQuat(p.quat,fwdRight2Quat(dpos,vec3(dpos.yx*vec2(1.0,-1.0),0.0)));\n\n    camQuat = normalize(slerpQuat( camQuat, newCamQuat, 0.3 ));\n\n    camDistRzRx.x=camDistScalar;\n    camDistRzRx.y=camRotZ;\n    camDistRzRx.z=camRotX;\n    writeCamNavI(camDistRzRx, fragColor, fragCoord, i);\n    writeCamQuatI(camQuat, fragColor, fragCoord, i);\n    writeCamPosI(camPos,   fragColor, fragCoord, i);\n}\n\nvoid calcCamera( inout vec4 fragColor, in vec2 fragCoord)\n{\n    calcCameraI(fragColor, fragCoord, 0, KEY_R>0.5, KEY_F>0.5, KEY_E>0.5, KEY_Q>0.5);\n    calcCameraI(fragColor, fragCoord, 1, KEY_O>0.5, KEY_L>0.5, KEY_I>0.5, KEY_Z>0.5 || KEY_Y>0.5);\n}\n\nvoid calcSteeringI( inout vec4 fragColor, in vec2 fragCoord, int i, bool leftkey, bool rightkey, bool upkey, bool downkey)\n{\n    float steeringAngle = readSteeringAngleI(i);\n    float gas = readGasI(i);\n\n    if     (leftkey ) steeringAngle-=0.6*DT;\n    else if(rightkey) steeringAngle+=0.6*DT;\n    else steeringAngle*=pow(0.9,DT/0.03);\n\n    if     (upkey  ) gas+=0.2*DT;\n    else if(downkey) gas-=0.2*DT;\n    else gas*=pow(0.9,DT/0.03);\n\n    gas=clamp(gas,-1.0,1.0);\n    steeringAngle=clamp(steeringAngle,-0.5,0.5);\n\n    writeSteeringAngleI(steeringAngle,   fragColor, fragCoord, i);\n    writeGasI(gas, fragColor, fragCoord, i);\n}\n\nvoid calcSteering( inout vec4 fragColor, in vec2 fragCoord )\n{\n    calcSteeringI(fragColor, fragCoord, 0,\n                  KEY_A>0.5 || KEY_LEFT >0.5,\n                  KEY_D>0.5 || KEY_RIGHT>0.5,\n                  KEY_W>0.5 || KEY_UP  >0.5,\n                  KEY_S>0.5 || KEY_DOWN>0.5);\n    calcSteeringI(fragColor, fragCoord, 1,\n                  KEY_H>0.5,\n                  KEY_K>0.5,\n                  KEY_U>0.5,\n                  KEY_J>0.5);\n}\n\nvoid updateFlag( inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 flagPos=readFlagPos();\n    vec3 posAvg=vec3(0.0);\n    for(int i=0;i<MaxParticleNum;i++)\n    {\n        Particle p = readParticle(i);\n        posAvg+=p.pos.xyz;\n        vec3 dpos = p.pos.xyz-flagPos;\n        if(dot(dpos,dpos)<FlagRadius*FlagRadius)\n        {\n            writeFlagPos(calcFlagPos(p.pos.xyz), fragColor, fragCoord);\n        }\n    }\n    posAvg/=float(MaxParticleNum);\n    if( flagPos.x==0.0 && flagPos.y==0.0 && flagPos.z==0.0 && iFrame>100 )\n    {\n        writeFlagPos(calcFlagPos(posAvg), fragColor, fragCoord);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // copy old content\n    fragColor = getPixel(int(fragCoord.x),int(fragCoord.y));\n\n    int pidx=PIdx(int(fragCoord.x),int(fragCoord.y));\n\n    if(pidx>=0 && pidx<MaxParticleNum)\n    {\n        vec3 force = vec3(0,0,0);\n        vec3 torque = vec3(0,0,0);\n\n        Particle p = readParticle(pidx);\n\n        // gravity\n        force+=getGravityWorld(p.pos.xyz)*Mass;\n\n        // velocity damping\n        force+=-0.2*p.vel.xyz;\n        torque+=-0.2*transformVecByQuat(p.angVel.xyz,p.quat);\n\n        float steeringAngle = readSteeringAngleI(pidx);\n        float gas = readGasI(pidx);\n        float clutch = clamp(abs(gas),0.0,1.0);\n        float rotSpeed = gas*50.0;\n        if(KEY_X>0.5) { clutch=1.0; gas=0.0; }\n        // wheel forces\n        calcWheelForceAndTorque(p,WheelFL,WheelRadius,steeringAngle,0.8,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelFR,WheelRadius,steeringAngle,0.8,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBL,WheelRadius,     0.0,     0.8,rotSpeed,SpringConst,clutch,force,torque);\n        calcWheelForceAndTorque(p,WheelBR,WheelRadius,     0.0,     0.8,rotSpeed,SpringConst,clutch,force,torque);\n        // stabilizers\n        calcWheelForceAndTorque(p,vec3(0,0,1.6),1.8,     0.0,     0.0,0.0,SpringConstStab,1.0,force,torque);\n\n        vec3 fwd=transformVecByQuat(vec3(0,1,0),p.quat);\n        vec3 up=transformVecByQuat(vec3(0,0,1),p.quat);\n\n        // obj-obj collision forces\n        for(int i=0;i<MaxParticleNum;i++)\n        {\n            if (i!=pidx)\n            {\n                Particle p2 = readParticle(i);\n                calcObjForceAndMom(p,p2,force,torque);\n            }\n        }\n\n        // clamp velocity\n        float velLen = length(p.vel.xyz);\n        if(velLen>120.1) p.vel.xyz*=120.1/velLen;\n        /*float angVelLen = length(p.angVel.xyz);\n        if(angVelLen>3.1) p.angVel.xyz*=3.1/velLen;*/\n\n        // time integration\n        // ...positional\n        vec3 acc = force/Mass;\n        p.vel.xyz += acc*0.5*DT;\n        p.pos.xyz += p.vel.xyz*DT;\n        p.vel.xyz += acc*0.5*DT;\n        // ...angular\n        vec3 angAcc = Iinv*transformVecByQuat(torque,inverseQuat(p.quat));\n        p.angVel.xyz += angAcc*0.5*DT;\n        p.quat = normalize(rotateQuatbyAngle(p.quat,-p.angVel.xyz*DT));\n        p.angVel.xyz += angAcc*0.5*DT;\n\n        vec3 flagPos=readFlagPos();\n        vec3 dpos = p.pos.xyz-flagPos;\n        if(dot(dpos,dpos)<FlagRadius*FlagRadius)\n        {\n            p.score+=0.5;\n        }\n\n        writeParticle(pidx,p,fragColor,fragCoord);\n    }\n    else\n    {\n        calcCamera(fragColor,fragCoord);\n\n        calcSteering(fragColor,fragCoord);\n\n        updateFlag(fragColor,fragCoord);\n    }\n\n    if(iFrame<10 || KEY_0>0.5) initAll(fragColor,fragCoord);\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// very much inspired by iq's \"Volcanic\", WAHa_06x36's \"Truchet Tentacles\" and Shanes \"Entangled Vines\"\n\n//#define SHOW_CRATERS\n\n#define readSampler iChannel0\n#define randSampler iChannel2\n#define time iDate.w\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n#define frameTime iTimeDelta\n//----- common ------\n\n#define MaxParticleNum 2\n#define NumViews int(min(float(MaxParticleNum),2.0))\n//#define NumViews 2\n#define InRes iChannel0Resolution\n\n#define FlagRadius 3.0\n\nstruct Particle {\n    vec4 pos;\n    vec4 vel;\n    vec4 angVel;\n    vec4 quat;\n    float score;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\n#define PixPerParticle 5\n#define ParticlesPerLine 16\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/16)+50; } // first line (y=0) reserved for other than particle-data\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-50)*16 + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.vel;\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=p.angVel;\n    if (isPixel(xc+3,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+4,yc,fragCoord)) fragColor.xyzw=vec4(p.quat.w,p.score,0,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.vel    = getPixel(xc+1,yc);\n    p.angVel = getPixel(xc+2,yc);\n    p.quat   = getPixel(xc+3,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+4,yc);\n    p.quat.w = p2.x;\n    p.score  = p2.y;\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\n//-------------------------------------------------------------------------------------\nvoid writeCamPosI(vec3 pos, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(0+i*20,0,fragCoord)) fragColor.xyz=pos;\n}\nvoid writeCamPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord) { writeCamPosI(pos, fragColor, fragCoord, 0); }\n\nvec3 readCamPosI(int i)\n{\n    return getPixel(0+i*20,0).xyz;\n}\nvec3 readCamPos() { return readCamPosI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamQuatI(vec4 quat, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(1+i*20,0,fragCoord)) fragColor.xyzw=quat;\n    if (isPixel(2+i*20,0,fragCoord)) fragColor.x=quat.w;\n}\nvoid writeCamQuat(vec4 quat, inout vec4 fragColor, vec2 fragCoord) { writeCamQuatI(quat, fragColor, fragCoord, 0); }\n\nvec4 readCamQuatI(int i)\n{\n    vec4 q;\n    q   = getPixel(1+i*20,0);\n    q.w = getPixel(2+i*20,0).x;\n    return q;\n}\nvec4 readCamQuat() { return readCamQuatI(0); }\n\n//-------------------------------------------------------------------------------------\nvoid writeCamNavI(vec3 nav, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(3+i*20,0,fragCoord)) fragColor.xyz=nav;\n}\nvoid writeCamNav(vec3 nav, inout vec4 fragColor, vec2 fragCoord) { writeCamNavI(nav, fragColor, fragCoord, 0); }\n\nvec3 readCamNavI(int i)\n{\n    return getPixel(3+i*20,0).xyz;\n}\nvec3 readCamNav() { return readCamNavI(0); }\n\n//-------------------------------------------------------------------------------------\nfloat readSteeringAngleI(int i)\n{\n    return getPixel(4+i*20,0).x;\n}\nfloat readSteeringAngle() { return readSteeringAngleI(0); }\n\nvoid writeSteeringAngleI(float st, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.x=st;\n}\nvoid writeSteeringAngle(float st, inout vec4 fragColor, vec2 fragCoord) { writeSteeringAngleI(st, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nfloat readGasI(int i)\n{\n    return getPixel(4+i*20,0).y;\n}\nfloat readGas() { return readGasI(0); }\n\nvoid writeGasI(float gas, inout vec4 fragColor, vec2 fragCoord, int i)\n{\n    if (isPixel(4+i*20,0,fragCoord)) fragColor.y=gas;\n}\nvoid writeGas(float gas, inout vec4 fragColor, vec2 fragCoord) { writeGasI(gas, fragColor, fragCoord, 0); }\n\n//-------------------------------------------------------------------------------------\nvec3 readFlagPos()\n{\n    //return vec3(96,0,80);\n    return getPixel(100,0).xyz;\n}\nvoid writeFlagPos(vec3 pos, inout vec4 fragColor, vec2 fragCoord)\n{\n    if (isPixel(100,0,fragCoord)) fragColor.xyz=pos;\n}\n\n//-------------------------------------------------------------------------------------\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec4 rotateQuatbyAngle(vec4 quat, vec3 angle)\n{\n    float angleScalar=length(angle);\n    if (angleScalar<0.00001) return quat;\n    return multQuat(quat,vec4(angle*(sin(angleScalar*0.5)/angleScalar),cos(angleScalar*0.5)));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvec4 mat2quat(mat3 m)\n{\n    float T=m[0].x+m[1].y+m[2].z+1.0;\n    if(T<0.0000001) return vec4(0.0,0.0,0.0,1.0);\n    //assuming positive trace\n    float S = 0.5/sqrt(T);\n    vec4 q;\n    q.w = 0.25/S;\n    q.x = (m[2].y-m[1].z)*S;\n    q.y = (m[0].z-m[2].x)*S;\n    q.z = (m[1].x-m[0].y)*S;\n    return q;\n}\n\nvec4 slerpQuat(vec4 q1, vec4 q2, float t)\n{\n    vec4 q3;\n    float dot = dot(q1, q2);\n\n    /*\tdot = cos(theta)\n     if (dot < 0), q1 and q2 are more than 90 degrees apart,\n     so we can invert one to reduce spinning\t*/\n    if (dot < 0.0)\n    {\n        dot = -dot;\n        q3 = -q2;\n    } else q3 = q2;\n\n    if (dot < 0.95)\n    {\n        float angle = acos(dot);\n        return (q1*sin(angle*(1.0-t)) + q3*sin(angle*t))/sin(angle);\n    } else // if the angle is small, use linear interpolation\n        return mix(q1,q3,t);\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos, int i)\n{\n    float speed=0.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(60.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    eye = readCamPosI(i);\n    vec4 cq = readCamQuatI(i);\n    right = transformVecByQuat(vec3(1,0,0),cq);\n    up    = transformVecByQuat(vec3(0,0,1),cq);\n    fwd   = transformVecByQuat(vec3(0,1,0),cq);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n\n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\n#define torusWorldRadius1 90.0\n#define torusWorldRadius2 30.0\n\n\n\n// ---- truchet cell funcs -----\n// derived from WAHa_06x36 - shadertoy (https://www.shadertoy.com/view/ldfGWn)\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius)\n{\n    pos=fract(pos);\n    float r=length(pos.xy);\n    return length(vec2(r-0.5,pos.z-0.5))-radius;\n}\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat sphere(vec3 pos, float r) { return length(pos)-r; }\n\nfloat truchetCell2(vec3 pos, float r)\n{\n    return min(min(\n        min(sphere(fract(pos)-vec3(0,0.5,0.5),r),sphere(fract(pos)-vec3(0.5,0,0.5),r)),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetCell3(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz    ,r),\n        truchetArc(pos.xyz*vec3(-1,-1,1) ,r)),\n        length(fract(pos.xy)-vec2(0.5))-r\n              );\n}\n\n// i tried to put all if's from WAHa_06x36's version into\n// one modulo operation, and left away the swizzling.\n// i think all roatational/mirrored cases are covered this way.\n// yet im not completely sure...\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat truchetDist2(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    float rnd2=truchetRand(gridpos+vec3(3.2,4.432,6.32))*3.0;\n    float rnd3=truchetRand(gridpos-vec3(3.2,4.432,6.32))*3.0;\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    if     (rnd3>2.0) cellpos = cellpos.yzx;\n    else if(rnd3>1.0) cellpos = cellpos.zxy;\n\n    if     (rnd2<1.0)\n        return truchetCell(cellpos*fact,r);\n    else if(rnd2<2.0)\n        return truchetCell2(cellpos*fact,r);\n    else if(rnd2<3.0)\n        return truchetCell3(cellpos.zxy,r);\n\n    return truchetCell(cellpos*fact,r);\n}\n\n#define randSampler iChannel2\n\nvec4 snoise(vec2 texc) { return  2.0*texture(randSampler,texc, -1000.0)-vec4(1.0); }\n\nvec4 snoise3Dv4S(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    // using iq's improved texture filtering (https://www.shadertoy.com/view/XsfGDn)\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = ((p.xy+vec2(17.0,7.0)*p.z) + 0.5 + f.xy)/256.0;\n    vec4 v1 = texture( randSampler, uv, -1000.0);\n    vec4 v2 = texture( randSampler, uv+vec2(17.0,7.0)/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\n// this is a somewhat modified version of iq's noise in \"volcanic\"\nvec4 snoise3Dv4(vec3 texc)\n{\n    vec3 x=texc*256.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    vec2 uv;\n    uv = (p.xy+vec2(17,7)*p.z) + 0.5 + f.xy;\n    vec4 v1 = texture( randSampler, uv/256.0, -1000.0);\n    vec4 v2 = texture( randSampler, (uv+vec2(17,7))/256.0, -1000.0);\n    return mix( v1, v2, f.z )-vec4(0.50);\n}\n\nfloat snoise3D(vec3 texc)\n{\n    return snoise3Dv4(texc).x;\n}\n\nfloat snoise3DS(vec3 texc)\n{\n    return snoise3Dv4S(texc).x;\n}\n\nfloat mScaleNoise(vec3 texc)\n{\n    float d=0.0;\n    d+=snoise3DS(texc);\n    d+=snoise3DS(texc*2.553)*0.5;\n    d+=snoise3DS(texc*5.154)*0.25;\n    //d+=snoise3DS(texc*400.45)*0.009;\n    d+=snoise3DS(texc*400.45*vec3(0.1,0.1,1.0))*0.009;\n    //d+=snoise3DS(texc*900.45*vec3(0.1,1.0,0.1))*0.005;\n    //d+=snoise3DS(texc*900.45*vec3(1.0,0.1,0.1))*0.005;\n    d*=0.5;\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1.0/(1.0+exp(-x));\n}\n\nfloat dominantMax(float d1, float d2, float sc)\n{\n    return mix(d1,d2,fermi((d2-d1)/sc-2.0));\n}\n\nfloat getDistanceWorldS(vec3 pos)\n{\n    vec3 pos0=pos;\n\n    float dist = 100000.0;\n    dist=truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n    float f=sin(0.01*(pos.x+pos.y+pos.z));\n    dist+=clamp(15.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0)*(0.2+0.8*f*f);\n\n    //plane\n    //dist=pos.z;\n    //dist+=clamp(5.5*mScaleNoise(0.035*pos/256.0),-100.0,1000.0);\n\n    // make a little crater at flag station\n#ifdef SHOW_CRATERS\n    vec3 flagPos=readFlagPos();\n    dist = dominantMax(-(length(pos-flagPos)-FlagRadius)+0.7*snoise3DS(pos*0.01),dist,0.6);\n#endif\n    //dist = min((length(pos-flagPos)-FlagRadius)+0.6*snoise3DS(pos*0.02),dist);\n\n    return dist;\n}\n\nvec3 getDistanceWorldSGradientSlow(vec3 pos, float delta)\n{\n    return vec3 (\n                 getDistanceWorldS( pos+delta*vec3(1,0,0) )-getDistanceWorldS( pos-delta*vec3(1,0,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,1,0) )-getDistanceWorldS( pos-delta*vec3(0,1,0) ),\n                 getDistanceWorldS( pos+delta*vec3(0,0,1) )-getDistanceWorldS( pos-delta*vec3(0,0,1) )\n                )/2.0/delta;\n}\n\nvec3 getDistanceWorldSGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistanceWorldS(pos);\n    return vec3(getDistanceWorldS(pos+eps.xyy)-d,\n                getDistanceWorldS(pos+eps.yxy)-d,\n                getDistanceWorldS(pos+eps.yyx)-d)/delta;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n\n#define Mass 2.0\n#define Iinv (mat3( 1.6,0,0, 0,3.0,0, 0,0,1.4 )/3.0/Mass)\n#define WheelRadius 0.45\n\n#define ObjBoundRadius 3.5\n\nvec4 getDistanceObjS(vec3 pos, float steeringAngle)\n{\n    //return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    float obj=0.0;\n    float dist = 100000.0;\n    //float steeringAngle=readSteeringAngle();\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    float dist2 = dist;\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    if(dist!=dist2) obj=1.0;\n    return vec4(dist,obj,0,0);\n}\n\nvec3 calcFlagPos(vec3 pos)\n{\n    //pos-=(getRand4(dot(pos,vec3(1.0))).xyz-vec3(0.5))*50.0;\n    vec3 rand3=getRand4(dot(pos.xyz,vec3(1.0))).xyz;\n    vec3 grad=getDistanceWorldSGradient(pos,0.1);\n    vec3 n=normalize(cross(rand3,grad));\n    // move around tangential\n    int allScore=0;\n    for(int i=0;i<MaxParticleNum;i++) allScore+=int(readParticle(i).score);\n\n    for(int i=0;i<200;i++)\n    {\n        if(i>20+allScore*14) break;\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        vec3 n=normalize(cross(grad,cross(n,grad)));\n        pos+=3.0*n;\n        float dist=getDistanceWorldS(pos);\n        grad=getDistanceWorldSGradient(pos,0.1);\n        pos-=0.7*normalize(grad)*dist;\n    }\n    // converge back to surface\n    for(int i=0;i<10;i++)\n    {\n        float dist=getDistanceWorldS(pos);\n        vec3 grad=getDistanceWorldSGradient(pos,0.5);\n        //pos-=0.7*normalize(grad)*dist;\n    }\n    //return vec3(96,0,80);\n    return pos;\n}\n//----- render ------\n\n#define randSampler iChannel2\n#define keySampler iChannel3\n\nvec4 getDistanceExt(vec3 pos)\n{\n    float dist=1000000.0;\n    float oldDist=1000000.0;\n    float obj=0.0;\n    // world\n    dist=min(dist,getDistanceWorldS(pos));\n\n    // cars\n    for(int i=0;i<MaxParticleNum;i++)\n    {\n        Particle p = readParticle(i);\n        oldDist=dist;\n        float steeringAngle=readSteeringAngleI(i);\n        vec4 ov = getDistanceObjS(transformVecByQuat(pos-p.pos.xyz,inverseQuat(p.quat)),steeringAngle);\n        dist=min(dist,ov.x);\n        if(dist!=oldDist) obj=float(i)+1.0+ov.y*0.1;\n    }\n\n    // flag\n    oldDist=dist;\n    vec3 flagPos=readFlagPos();\n    dist=min(dist,length(pos-flagPos)-FlagRadius);\n    if(dist!=oldDist) obj=float(MaxParticleNum+1);\n\n    return vec4(dist,obj,0,0);\n}\n\nfloat getDistance(vec3 pos)\n{\n    return getDistanceExt(pos).x;\n}\n\nvec3 getDistanceGradientSlow(vec3 pos, float delta)\n{\n    vec3 eps=vec3(delta,0,0);\n    return vec3 (\n                 getDistance( pos+eps.xyy )-getDistance( pos-eps.xyy ),\n                 getDistance( pos+eps.yxy )-getDistance( pos-eps.yxy ),\n                 getDistance( pos+eps.yyx )-getDistance( pos-eps.yyx )\n                );\n}\n\nvec3 getDistanceGradient(vec3 pos, float delta)\n{\n    delta*=2.0;\n    vec3 eps=vec3(delta,0,0);\n    float d=getDistance(pos);\n    return vec3(getDistance(pos+eps.xyy)-d, getDistance(pos+eps.yxy)-d, getDistance(pos+eps.yyx)-d)/delta;\n}\n\n\n// Ambient occlusion approximation.\n// Based upon boxplorer's implementation which is derived from:\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n#define AoIterationsMax 4\nfloat ambientOcclusion(vec3 p, vec3 n, float eps, float aoSpread, float aoIntensity, int aoIterations)\n{\n    float o = 1.0;                  // Start at full output colour intensity\n    eps *= aoSpread;                // Spread diffuses the effect\n    float k = aoIntensity / eps;    // Set intensity factor\n    float d = 2.0 * eps;            // Start ray a little off the surface\n    \n    for (int i = 0; i < AoIterationsMax; ++i) {\n        o -= (d - getDistance(p + n * d)) * k;\n        d += eps;\n        k *= 0.5;                   // AO contribution drops as we move further from the surface\n        if(i > aoIterations) break;\n    }\n    \n    return clamp(o, 0.0, 1.0);\n}\n\n#define RaytraceMaxStepNum 200\n#define glowColor vec3(0.1,0.3,0.4)\n#define ambientColor (vec3(0.35,0.55,0.65)*0.7)\n#define diffuseColor vec3(0.8,0.95,1.0)\n\nfloat gauss(float x) { return exp(-x*x); }\n\nvec4 shadeCar(vec3 pos, float glow, float dist, vec3 dir, float obj)\n{\n    vec4 col=vec4(1.0);\n    vec3 normal=normalize(getDistanceGradient(pos,0.001));\n    float ao = 1.0;\n    ao *= ambientOcclusion(pos, normal, 0.03,\n                           8.0,    //spread,\n                           0.1, //intensity,\n                           4     //iterations\n                          );\n    col *= ao;\n    //col *= vec4(normal.xyz*0.5+vec3(0.5),1);\n    vec3 lightDir = normalize(vec3(-16.0, 100.0, -60.0));\n    float diff = clamp(dot(vec3(0,0,1),normal),0.0,1.0);\n    diff*=1.2;\n    //diff*=diff;\n    vec3 diffuseColorL = vec3(1,1,1);\n    //if(obj>=1.0) diffuseColorL =vec3(0.5); // tire\n\n    vec3  eye=-dir;\n    float spec = dot(-eye+2.0*normal*dot(normal,eye),vec3(0,0,1));\n    float shin1 = 0.6;\n    float shin2 = 0.05;\n    float shTot = 1.0;\n    //if(obj>=1.0) { shin1 = 0.8; shin2 = 0.4; shTot=0.3; }\n    vec3 specv = shTot*(0.9*gauss((spec+0.4)/shin1)*vec3(ambientColor) + 0.7*gauss((spec-0.95)/shin2)*vec3(1));\n\n    col.xyz *= mix(ambientColor*diffuseColorL,diffuseColorL,diff);\n    col.xyz += vec3(specv);\n\n    return col;\n}\n\nvec4 shadeTerrain(vec3 pos, float glow, float dist, vec3 dir)\n{\n    vec4 col=vec4(1);\n    vec3 normal=normalize(getDistanceGradient(pos,0.2123));\n\n    float ao = 1.0;\n\n    ao *= ambientOcclusion(pos, normal, 0.03,\n                           8.0,    //spread,\n                           0.1, //intensity,\n                           4     //iterations\n                          );\n    ao *= ambientOcclusion(pos, normal, 2.5,\n                           8.0,    //spread,\n                           0.07, //intensity,\n                           4     //iterations\n                          );\n\n    //ao*=ao;\n\n    vec3 lightDir = normalize(vec3(-16.0, 100.0, -60.0));\n    float diff = clamp(dot(vec3(0,0,1),normal),0.0,1.0);\n    diff=1.2*pow(diff,1.0);\n    vec3 eye=-dir;\n    vec3 rnormal = normalize(snoise3Dv4(pos*0.1).xyz);\n    float spec1 = dot(-eye+2.0*rnormal*dot(rnormal,eye),vec3(0,0,1));\n    float spec2 = dot(-eye+2.0*normal*dot(normal,eye),vec3(0,0,1));\n    float spec=2.0*gauss((spec1-0.8)/0.01)*diff+0.7*gauss((spec2-0.99)/0.2)*(1.0-dot(eye,normal));\n\n    col.xyz *= mix(diffuseColor, ambientColor, 1.0-diff);\n    col.xyz *= mix(vec3(ao),vec3(1,1,1),vec3(0.1,0.4,0.6));\n    //col.xyz *= 0.9+texture( randSampler, pos.xy*0.003, -1000.0).x*0.1;\n\n    col.xyz += 0.7*spec*vec3(1,1,1);\n    col.xyz += glowColor*glow;\n    return col;\n}\n\nvec4 raytraceDistfield(vec3 pos0, vec3 dir, float maxDist)\n{\n    vec3 colbg = mix(vec3(0.35,0.6,0.65)*0.5,1.2*vec3(0.8,0.95,1.0),dir.z*0.5+0.5);\n    vec4 col = vec4(1,1,1,1);\n\n    vec3 rpos = pos0;\n    vec3 rpos0 = rpos;\n\n    float dist=0.0;\n    float ddist=100.0;\n    int cnt=0;\n    float eps=0.005; // m\n    vec4 dv;\n    float dd=0.8; // security factor against overshooting (due to random distortions, smoothmin, etc)\n    for( int i=0 ; i<RaytraceMaxStepNum ; i++ )\n    {\n        if(ddist<eps) break;\n        dv=getDistanceExt(rpos.xyz+dir*dist);\n        ddist=dv.x;\n        dist+=ddist*dd;\n        cnt++;\n        if(dist>maxDist) break;\n    }\n    float smoothCnt = float(cnt)+max(ddist/eps,0.0);\n    //smoothCnt = float(cnt);\n    //float glow=2.0*(1.0-exp(-smoothCnt/50.0));\n    float glow=smoothCnt/100.0;\n\n    float ddistsurf=ddist;\n    float distsurf=dist;\n\n    if(ddistsurf<=eps) {\n        if(dv.y>=float(MaxParticleNum+1))\n            col=vec4(fract(time),0,0,1)/*shadeFlag(rpos.xyz+dir*distsurf,glow,dist,dir)*/;\n        else if(dv.y>=1.0)\n            col=shadeCar(rpos.xyz+dir*distsurf,glow,dist,dir,fract(dv.y)*10.0);\n        else\n            col=shadeTerrain(rpos.xyz+dir*distsurf,glow,dist,dir);\n    }\n    else\n    {\n        col.w = 0.0;\n        col.xyz=colbg.xyz;\n    }\n\n    if(cnt>=RaytraceMaxStepNum-2) col=vec4(0.8,0.95,1.0,1.0);\n\n    float fog = 1.0-exp(-dist/maxDist*3.0);\n    col.xyz = mix(col.xyz,colbg,fog);\n\n    vec3 flagPos = readFlagPos();\n    float flagAng = acos(dot(dir,normalize(flagPos-pos0)));\n    col.xyz+=vec3(1.0*(1.0-fract(time)),0,0)*gauss((flagAng-fract(time))/0.03);\n    col.xyz+=vec3(0.5*(1.0-fract(time)),0,0)*gauss(flagAng/0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int view = int((fragCoord.y/iResolution.y)*float(NumViews));\n    float aspect=iResolution.y/iResolution.x/float(NumViews);\n    vec2 ires2 = iResolution.xy/vec2(1.0,float(NumViews));\n    vec2 spos = mod(fragCoord.xy,ires2)/ires2*2.0-vec2(1.0);\n    vec3 right, fwd, up, pos, dir;\n    getEyeCoords(right,fwd,up,pos,dir,aspect,spos,view);\n    fragColor = raytraceDistfield(pos,dir,1000.0);\n    Particle p = readParticle(0);\n    //if()\n    //fragColor += texture(keySampler,fragCoord/vec2(256,iResolution.y));\n    //drawFloat(length(p.vel.xyz)*3.6,2,vec2(10,10),2.0,fragColor,fragCoord);\n    //drawFloat(readGas(),2,vec2(10,45),2.0,fragColor,fragCoord);\n    //drawFloat(readSteeringAngle(),2,vec2(10,30),2.0,fragColor,fragCoord);\n}\n","name":"Buf C","description":"","type":"buffer"}]}