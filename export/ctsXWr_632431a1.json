{"ver":"0.1","info":{"id":"ctsXWr","date":"1675108604","viewed":52,"name":"Spheres, lots of them","username":"frettini","description":"Building my first raymarcher with variable names I understand, adding some geometry to it and (trying) to make it pretty :) (but not optimized :x)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres","repetition"],"hasliked":0,"parentid":"mt23RV","parentname":"A simple raymarcher"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RAYMARCHSTEPS 80\n\n#define MATERIAL1 1.\n#define MATERIAL2 2.\n\n#define MAXDIST 30.0\n\n// having some issues with Union in nested for loops...\n//#pragma optionNV (unroll all)\n\nstruct Hit\n{\n    float rayDist;\n    float matID;\n};\n\nmat3 LookAt(vec3 pos, vec3 target)\n{\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(cross(forward,vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, forward));\n        \n    return mat3(vec3(right),\n                vec3(up),\n                vec3(forward));\n    \n}\n\n// HASH ----------------------------------------------------------\n//https://www.shadertoy.com/view/XdGfRR, David Hoskins. May 2018\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// OPERATIONs ----------------------------------------------------\n// from https://iquilezles.org/articles/distfunctions/\n\nHit Union(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist < hit2.rayDist)\n    { \n        return hit1;\n    }\n    else\n    { \n        return hit2; \n    }\n}\n\nvec2 Union(vec2 hit1, vec2 hit2)\n{\n    return (hit1.x < hit2.x) ? hit1 : hit2;\n}\n\nHit Substract(Hit hit1, Hit hit2)\n{\n    if(-hit1.rayDist > hit2.rayDist){ return  Hit( -hit1.rayDist, hit1.matID ); }\n    else{ return hit2; };\n}\n\nHit Intersect(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist > hit2.rayDist){ return  hit1; }\n    else{ return hit2; };\n}\n\nHit SmoothIntersect( Hit hit1, Hit hit2, float k ) \n{\n    Hit result;\n    float h = clamp(0.5-0.5*(hit2.rayDist - hit1.rayDist)/k, 0.0, 1.0);\n    result.rayDist = mix(hit2.rayDist, hit1.rayDist, h) + k*h*(1.0-h);\n    result.matID = hit1.matID; // TODO : this is a simplification for now\n    return result;\n}\n\n// SDFs ----------------------------------------------------------\n// from https://iquilezles.org/articles/distfunctions/\n\nfloat SDSphere(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    return length(pos - spherePos) - sphereRadius;\n}\n\nHit RepeatedSDSphere(vec3 pos)\n{  \n    Hit rayHit = Hit(MAXDIST,-1.);\n    //Hit sphereHit = Hit(MAXDIST, -1.);\n    float matOffset = 0.;\n    \n    vec3 coord = pos;\n    float gridScale = 2.;\n    vec3 gridCoord = floor(coord/gridScale);\n    \n    for(int i =-1; i <= 1; i++)\n    for(int j =-1; j <= 1; j++)\n    for(int k =-1; k <= 1; k++)\n    {\n        vec3 cell = gridCoord + vec3(i,j,k);\n        vec3 offset = hash33(cell);\n        float scale = max(0.2,hash13(cell)*0.6);\n        float speed = hash13(cell*5.);\n        matOffset = pow(hash13(cell),2.);\n        offset.y += cos(speed*iTime)*0.5;\n        \n        float rayDist = SDSphere((cell+offset)*gridScale, coord, scale);\n        Hit sphereHit = Hit(rayDist, MATERIAL2);\n        sphereHit.matID += matOffset;\n                \n        rayHit = Union( rayHit, sphereHit);\n    }\n    \n    return rayHit;\n}\n\n// ---------------------------------------------------------------\n\n// from the position, return the distance and material of the closest object\nHit GetDistance(vec3 pos)\n{\n    float planeHeight = 0.;\n    \n    Hit rayHit = Hit(MAXDIST,-1.);\n    \n    rayHit = Union( RepeatedSDSphere(pos), rayHit);\n    \n    return rayHit;\n}\n\n// using the specified ray, step through the ray and check against the SDF until the distance is small\n// enough to say that we have hit something.\nvoid Raymarch(vec3 rayOrigin, vec3 rayDirection, out Hit resultHit)\n{\n    float tmin = 1.;\n    float tmax = MAXDIST;\n    \n    float t = tmin;\n    for(int i = 0; i < RAYMARCHSTEPS && t < tmax; i++)\n    {\n        vec3 testPos = rayOrigin + rayDirection * t;\n        \n        Hit rayHit = GetDistance(testPos);\n        \n        // if distance is smaller than a given threshold, consider that a Hit\n        if(abs(rayHit.rayDist) < 0.0001*t )\n        {\n            // return the distance along the ray and the material ID of what we Hit\n            resultHit = Hit(t, rayHit.matID);\n            break;\n        }\n        \n        t += rayHit.rayDist;\n    }\n}\n\n// from : https://iquilezles.org/articles/normalsSDF/\n// tetrahedon method to get the normal of a SDF\nvec3 GetNormal(vec3 pos)\n{\n    // trick the compiler to avoid inlining the Map function\n    #define ZERO (min(0, iFrame))\n    \n    float eps = 0.0001;\n    \n    vec3 normal = vec3(0.);\n    \n    for(int i = ZERO; i < 4 ; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        normal += e*GetDistance(pos+e*eps).rayDist;\n    }\n    \n    return normalize(normal);\n}\n\n\n// Once we know what we hit, we can start material calculations\nvec3 GetColour(vec3 rayOrigin, vec3 rayDirection, Hit rayHit)\n{\n    \n    float distCol = (cos(rayHit.rayDist*0.2+iTime*0.5));\n    vec3 paletteCol = vec3(1.,0.,0.) ;\n    paletteCol = 0.5 + 0.5*cos( 1.0+distCol*1.4 + vec3(0.7,0.0, 0.5 * (cos(iTime*10.)*.05+0.5) ));\n\n    vec3 backgroundCol = paletteCol*0.5;\n    vec3 col = backgroundCol;\n    \n    //vec3 col = backgroundCol;\n    if(rayHit.matID > 0.)\n    {\n        vec3 pos = rayOrigin + rayDirection * rayHit.rayDist;\n        \n        // SPHERE Material\n        if(rayHit.matID > 1.99)\n        {\n            vec3 normal = GetNormal(pos);\n            vec3 refl = reflect(rayDirection, normal); // shorten the name to avoid conflict with function \n            \n            // this doesn't work on my machine for some reason, disabling it for now...\n            //float fresnel = pow(1.-max(0.,dot(normal, refl)),4.*fract(rayHit.matID));\n            //col = mix(vec3(1.0), paletteCol , fresnel);\n            col = paletteCol;\n        }\n        \n#if 0\n        float absorptionCoef = 0.08;\n        float transmittance = exp( - absorptionCoef * rayHit.rayDist);\n        col = (1.0 - transmittance) * backgroundCol + transmittance * col;\n#else  \n        // smooth out things in the background ( could use beer lambert law but makes everything a bit darker)\n        float normDist = rayHit.rayDist / MAXDIST;\n        float smoothDist = smoothstep(0.2,1., normDist);\n        col = mix(col, backgroundCol, smoothDist);\n#endif\n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float focalDistance = 2.;\n    vec3 rayOrigin = vec3( cos(0.3)*88.+0.6,sin(iTime*0.1)+10.0, sin(0.3)*3.+sin(iTime*0.03)*30.);\n    vec3 rayTarget = vec3(cos(-iTime*0.01),sin(iTime*0.1)+ 0.5,cos(iTime*0.08)*100.);\n    \n    mat3 lookAt = LookAt(rayOrigin, rayTarget);  \n\n    // Normalized pixel coordinates (from -1.0 to 1.0)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n      \n    // Get the ray direction by building the ray in camera space and transforming it using the lookAt matrix\n    vec3 cameraRayDir =  normalize( vec3(uv, focalDistance) );\n    vec3 rayDirection = normalize((lookAt * cameraRayDir));\n    \n    Hit rayHit = Hit(MAXDIST, -1.0);\n    Raymarch( rayOrigin, rayDirection, rayHit);\n    vec3 col = GetColour(rayOrigin, rayDirection, rayHit);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}