{"ver":"0.1","info":{"id":"stKBzz","date":"1664466515","viewed":74,"name":"SDF Nightmare","username":"Topxic","description":"Just a nightmarish raymarching sdf project for learning","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rotate_x(a) mat3(vec3(1, 0, 0), vec3(0, cos(a), -sin(a)), vec3(0, sin(a), cos(a)))\n#define rotate_y(a) mat3(vec3(cos(a), 0, sin(a)), vec3(0, 1, 0), vec3(-sin(a), 0, cos(a)))\n#define rotate_z(a) mat3(vec3(cos(a), -sin(a), 0), vec3(sin(a), cos(a), 0), vec3(0, 0, 1))\n\nconst float TEX_SCALE = 1.0;\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0000005;\nconst float FOV = 90.0;\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sceneSDF(vec3 p) {\n    float distplacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n    float s1 = sphereSDF(p + vec3(0, 2.0 * (0.5 + sin(iTime)), 0), 0.5) + distplacement;\n    \n    mat3 rot1 = rotate_y(radians(70.0 * iTime));\n    mat3 rot2 = rotate_y(sin(iTime) * radians(80.0 * sin(p.y)));\n    float e1 = sdBox(rot2 * (abs(rot1 * p) - 1.0), vec3(0.32, 6, 0.32));\n    \n    rot1 = rotate_y(-radians(70.0 * iTime));\n    float e2 = sdBox(rot2 * (abs(rot1 * p) - 2.0), vec3(0.32, 6, 0.32));\n    \n    rot1 = rotate_y(radians(70.0 * iTime));\n    float e3 = sdBox(rot2 * (abs(rot1 * p) - 3.0), vec3(0.32, 6, 0.32));\n    return min(min(min(s1, e1), e2), e3);\n}\n\nfloat ray_marching(vec3 eye, vec3 dir) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * dir);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 estimate_normal(vec3 p) {\n    vec2 h = vec2(0, EPSILON);\n    return normalize( \n        vec3(sceneSDF(p+h.xyy) - sceneSDF(p-h.xyy),\n             sceneSDF(p+h.yxy) - sceneSDF(p-h.yxy),\n             sceneSDF(p+h.yyx) - sceneSDF(p-h.yyx)));\n}\n\nvec3 blinn_phong(vec3 pos, vec3 l, vec3 n, vec3 v, float s) {\n    \n    vec3 blending = abs(n);\n    blending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0 \n    float b = (blending.x + blending.y + blending.z);\n    blending /= vec3(b, b, b);\n    \n    // in float scale\n    vec4 xaxis = texture(iChannel0, pos.yz * TEX_SCALE);\n    vec4 yaxis = texture(iChannel0, pos.xz * TEX_SCALE);\n    vec4 zaxis = texture(iChannel0, pos.xy * TEX_SCALE);\n    vec4 tex = xaxis * blending.x + xaxis * blending.y + zaxis * blending.z;\n    \n    \n    vec3 amb = vec3(0.1, 0.6, 0.2);\n    float d = distance(vec2(0), pos.xz);\n    if (d < 2.0) {\n        amb = vec3(0.6, 0.1, 0.1);\n    }\n    if (d < 1.0) {\n        amb = tex.xyz;\n    }\n      \n    vec3 h = normalize(v + l);\n    float n_dot_l = max(dot(n, l), 0.0);\n    float n_dot_h = max(dot(n, h), 0.0);\n    vec3 diff = n_dot_l * vec3(0.5);\n    vec3 spec = pow(n_dot_h, s) * vec3(0.5);\n    return amb + diff + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_eye = vec3(0, 1, 5);\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(FOV) / 2.0);\n    vec3 dir = normalize(vec3(xy, -z));\n    dir = rotate_x(radians(20.0)) * dir;\n    \n    float dist = ray_marching(cam_eye, dir);\n    if (dist >= MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.3, 0.3, 0.4, 1);\n    } else {\n        vec3 p = cam_eye + dist * dir;\n        vec3 n = estimate_normal(p);\n        vec3 light_pos = vec3(0, 3, 2);\n        vec3 l = normalize(light_pos - p);\n        fragColor = vec4(blinn_phong(p, l, n, -dir, 8.0), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}