{"ver":"0.1","info":{"id":"ftd3RM","date":"1635876716","viewed":106,"name":"jneen - pixellated starfield","username":"jneen","description":"pixellated but it's 3d again, but it's different","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (iTime*.5)\n#define v2Resolution iResolution\n#define out_color fragColor\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+cross(ax,p)*sin(ro);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0., max(q.x,max(q.y,q.z)));\n}\n\nmat2 rot(float x) { float s=sin(x),c=cos(x); return mat2(c,s,-s,c); }\n\nfloat roundunion(float d1, float d2, float amt) {\n  float m = min(d1, d2);\n\n  vec2 d = clamp(vec2(d1, d2),-amt,amt);\n  \n  return min(m, amt-length(d-amt)); //max(m,length(vec2(d1,d2))-.5);\n}\n\nfloat roundint(float d1, float d2, float amt) {\n  float m = max(d1, d2);\n  vec2 d= clamp(vec2(d1,d2),-amt,amt);\n  return max(m, -(amt-length(d+amt)));\n}\n\n\nfloat chamfunion(float d1, float d2, float amt) {\n  float m = min(d1, d2);\n  vec2 d = max(vec2(d1,d2),0.);\n  \n  return min(m, (d.x+d.y-amt)/sqrt(2.)); //max(m,length(vec2(d1,d2))-.5);\n}\n\nfloat chamfint(float d1, float d2, float amt) {\n  float m = max(d1, d2);\n  \n  vec2 d = min(vec2(d1,d2),0.);\n  \n  //return m;\n  return max(m, (d.x+d.y+amt)/sqrt(2.));\n}\n\n\n\nfloat smoothsubtract(float d1, float d2, float k) {\n  float h = clamp(.5-.5*(d2+d1)/k, 0., 1.);\n  return mix(d2, -d1, h) + k*h*(1.-h);\n}\n\n#define gmix(A,B,Q) ((A)*pow((B)/(A), Q))\nfloat COL;\n#define tri(x) (abs(fract(x)-.5)*2.)\nfloat scene(vec3 p) {\n  float perz=3.;\n  p.xz *= rot(sin(time)*.4);\n  //p.z = mod(p.z, perz)-.5*perz;\n  //p.xy *= rot(time);\n  p.x -= .3;\n  p.y -=.2;\n  \n  float perxy = 2.8;\n  vec2 newxy = mod(p.xy, perxy)-.5*perxy;\n  vec2 cell = p.xy-newxy;\n  COL = cos(time)*cell.x+sin(time)*cell.y;\n  p.xy = newxy;\n  \n  //p.xz *= rot(3.14/3.);\n  //p.yz *= rot(1.);\n  p = erot(p, normalize(vec3(-1,.2,.8)), time*.5);\n  float cube = box(erot(p, normalize(vec3(.1,.1,0)), time*8.), vec3(1,1,1))-.2;\n  float amt = 2.*(.5+.5*tri(time));\n  \n  float per = .555;\n  vec3 sphc = mod(erot(p, vec3(0,0,1), time), per)-.5*per;\n  float sph = sphere(sphc, .4);\n  \n  float sph2 = sphere(p, 1.);\n  //return max(-sph,cube);\n  float sparkle = chamfint(-sph,cube, .01);\n  return sparkle;\n  \n  return gmix(sph2, sparkle, sin(time)*.5+.5);\n}\n\n#define MISS(x) ((x)>1000.)\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for (int i=0;i<300;i++) {\n    float c=scene(p+dir*d);\n    d+=c;\n    if (c < .00001) return d;\n    if (MISS(d)) return 1001.;\n  }\n  \n  return d;\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p)-mat3(.001);\n  return scene(p) - vec3(scene(K[0]), scene(K[1]), scene(K[2]));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / v2Resolution.xy - .5;\n  vec2 uu = fragCoord.xy / v2Resolution.xy;\n  uv.x *= v2Resolution.x/v2Resolution.y;\n  \n  vec3 cam = vec3(0,0,-20);\n  vec3 dir = normalize(vec3(uv, 1));\n  \n  float dist = ray(cam, dir);\n  \n  vec3 C;\n  if (MISS(dist)) {\n    C = vec3(0);\n  }\n  else {\n    vec3 hue = floor(mod(vec3(1,3,5)+COL-.5, 10.))*.1+.05;\n    vec3 normal = normalize(grad(cam+dir*dist));\n    float diff = length(sin(3.*normal+vec3(1,2,2))*.5+.5)/sqrt(3.);\n    C = vec3(diff*diff)*hue;\n\n  }\n  \n\n  out_color = vec4(sqrt(C), 0.);\n}\n\n\n","name":"Image","description":"","type":"image"}]}