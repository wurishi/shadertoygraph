{"ver":"0.1","info":{"id":"mt2BDG","date":"1694457889","viewed":302,"name":"LatticeRobot GLSL Interop Beta","username":"bcourter","description":"The first prototype of LatticeRobot's GLSL export are in the contents of the \"Common\" tab.  Feedback welcome.  \n\nThis ability is WIP at https://www.latticerobot.com .\n\nTBD:\n* Parameter metadata\n* Function call instead of uniforms/globals?","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["sdf","diamond","gyroid","lattice","tpms","latticerobot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.0\n//\n// Please see the \"Common\" tab for LatticeRobot interop.  \n//\n// This renderer is similar to the one used by LatticeRobot, derived from IQ and related \n// ShaderToys as commented below.  \n//\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// Sliders\n\nfloat cellCount = 1.0;\n\nfloat readFloat(float address) { \n    return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; \n}\n\nvoid updateParams() {\n    float latticeIndexFloat = readFloat(0.) * 4.;\n    latticeIndex = latticeIndexFloat >= 4. ? 3 : int(latticeIndexFloat);\n    size_x = readFloat(1.) * 10.0 + 5.0;\n    size_y = readFloat(2.) * 10.0 + 5.0;\n    size_z = readFloat(3.) * 10.0 + 5.0;\n    bias = readFloat(4.) * 5.0 - 2.5;\n    thickness = readFloat(5.) * 5.0;\n    drop_x = readFloat(6.);\n    drop_y = readFloat(7.);\n    drop_z = readFloat(8.);\n    gyroid = readFloat(9.);\n    cellCount = readFloat(10.) * 3.0 + 1.0;\n}\n\n// ColorImplicit\n\nconst float cHigh = 0.8;\nconst float cMed = 0.7;\nconst float cLow = 0.3;\nconst vec4 colorCool = vec4(cMed, cMed, cHigh, 1.0);\nconst vec4 colorWarm = vec4(cHigh, cMed, cMed, 1.0);\nconst vec4 colorLightGray = vec4(cHigh, cHigh, cHigh, 1.0);\n\nstruct ColorImplicit {\n\tfloat Distance;\n\tvec3 Gradient;\n\tvec4 Color;\n};\n\nColorImplicit CreateColorImplicit(Implicit implicit, vec4 color) {\n    return ColorImplicit(implicit.Distance, implicit.Gradient, color);\n}\n\nColorImplicit Max(ColorImplicit a, ColorImplicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\n\n// IQ rendering https://www.shadertoy.com/view/wlXSD7\nColorImplicit map(vec3 p) {\n    float amp = 0.05;\n    vec3 pOrig = p * vec3(1.0 + amp * cos(iTime), 1.0 + amp * cos(iTime), 1.0 + amp * sin(iTime));  // play with size\n    p = pOrig + center;\n\n    Implicit merged = Divide(scaledLattice(pOrig * cellCount + center), cellCount);\n\n    Implicit bounds = BoxCenter(p, center, 0.1 * vec3(size_x, size_y, size_z));\n\n    float bumpOffset = 0.05;\n    float bump = pow(abs(cos((1.5 * iTime + p.z) * 0.4)), 400.);\n    Implicit offset = Add(merged, -bump * bumpOffset);\n    \n    vec4 baseColor = latticeIndex == 1 ? colorWarm : colorCool;\n    ColorImplicit colorField = CreateColorImplicit(offset, baseColor);\n    if (latticeIndex > 1) {\n        int tmp = latticeIndex;\n        latticeIndex = 0; // override to see what axis we are on\n        colorField.Color = (Divide(scaledLattice(pOrig * cellCount + center), cellCount).Distance > 0.0) ?\n            colorCool : colorWarm;\n            \n           \n        latticeIndex = tmp;\n    }\n    \n    colorField.Color = colorField.Color + vec4(bump * 0.2);\n    ColorImplicit colorBox = CreateColorImplicit(bounds, colorLightGray);\n    return Max(colorField, colorBox);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0)  *0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).Distance + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).Distance + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).Distance + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).Distance );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadowBanding( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).Distance;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + t*rd).Distance;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n// advanced via https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).Distance;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            // float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).Distance;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    updateParams();\n\n    float rad = 1.25;\n    float lightAng = 0.0;\n\tvec3 ro = vec3( rad*cos(lightAng), rad*sin(lightAng), 0.7 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n    mat3 rot = RotateZ(an);\n    mat3 rotInv = RotateZ(-an);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.5;\n    float t = 0.0;\n    ColorImplicit hit;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = (ro + t*rd) * rot;\n        hit = map(pos);\n        if( hit.Distance < 0.0001 || t > tmax ) break;\n        t += hit.Distance * 0.35;  // slow down to not miss sharp features and TPMS with Lipschitz > 1.  (TBD figure out why this value doesn't work at 0.9)\n    }\n\n    if (t > tmax)\n        tot = vec3(1.0);\n\n    vec3 nor;\n\n#if 0    // 1 for simple renderer\n    // shading/lighting\t\n    vec3 col = vec3(0.0);\n    if( t<tmax ) {\n        vec3 pos = (ro + t*rd) * rot;\n        //vec3 nor = calcNormal(pos);  // numerical gradient\n        nor = normalize(hit.Gradient);\n\n       float dif = clamp( dot(nor, vec3(0.8, 0., 0.6) * rot ), 0.0, 1.0 );\n        float amb = 0.5 ;\n        col = vec3(0.6)*amb + vec3(1.)*dif;\n        col = col * hit.Color.rgb;\n    }\n#else\n    // shading/lighting\t\n    vec3 col = vec3(0.0);\n    if( t<tmax )\n    {\n        vec3 pos = (ro + t*rd) * rot;\n        nor = calcNormal(pos);\n        nor = normalize(hit.Gradient);\n        vec3 lig = normalize(vec3(0.6,0.0,0.4)) * rot;\n        vec3 hal = normalize(lig-rd*rot);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        float occ = calcOcclusion( pos, nor );\n        if( dif>0.001 ) dif *= softshadow( pos, lig, 0.0001, 1.0, 0.2 );\n        float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd*rot),0.0,1.0),5.0));\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.0,1.0));\n        col =  hit.Color.rgb * amb*occ;\n        col += hit.Color.rgb * dif * 0.8;\n\n        col *= 0.8;\n\n        col += vec3(1.,1.,1.)*spe*2.0;\n    }\n#endif\n          \n\ttot += col;\n\tfragColor = vec4( tot, 1.0 );\n    \n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = mix(fragColor, ui, ui.a);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.0\n// This code in the 'Common' tab is test output from LatticeRobot's lattice CodeRep generator.  \n// It is intended for other implicits to use to fill shapes with spatially varying lattices.\n//\n// https://www.latticerobot.com\n//\n// LICENSE: This code is provided under an MIT license.  \n// BETA WARNING: This format will evolve through the fall of 2023\n//\n// Documentation:\n// Immediately below, there is a library, followed by the custom code for this parameterized\n// unit cell (line 336).  A complier directive replaces the uniforms with internal parameters\n// for the purpose of this Shadertoy demo.\n//\n// Lattice Variants and Index:\n// The latticeIndex uniform accesses the four variants of the lattice F(p), with the shape \n// defined by the preimage of the non-positive values of that variant:\n//\n//   0: Solid. The Solid lattice:\n//       F(p) - bias\n//\n//   1: Inverse. The inverse of the Solid lattice:\n//       -F(p) + bias\n//\n//   2: Thin. A thin band of the Solid lattice:\n//       abs(F(p) - bias) - thickness / 2\n//\n//   3: Twin. The twin axes produced by the inverse of the Thin lattice:\n//       -abs(F(p) - bias) + thickness / 2\n//\n// Common Lattice Parameters (with default value and units):\n//   * size_x, size_y, and size_z (10 mm): The dimensions of the desired bounding box. \n//   * bias (0 mm): The offset of the baseline lattice surface.  Not precise distance.\n//   * thickness (1 mm): Thin and Twin only.  The thickness of the wall of the thin lattice or\n//        the span of the spacing of the twin lattice.  Not precise distance.\n//\n// Special Lattice Parameters (for only this lattice):\n//   * drop_x, drop_y, and drop_z (1): Lattice-specific parameters that attenuate coefficients.\n//   * gyroid (0): interpolates the Diamond TPMS to Gyroid TPMS.  \n//  \n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// LatticeRobot Library\n\n#define PI 3.14159265358979\n#define SQRT2 1.41421356237\n#define SQRT3 1.73205080757\n\nstruct Implicit {\n\tfloat Distance;\n\tvec3 Gradient;\n};\n\nImplicit CreateImplicit() { return Implicit(0.0, vec3(0.0)); }\nImplicit CreateImplicit(float iValue) { return Implicit(iValue, vec3(0.0)); }\n\nImplicit mix(Implicit a, Implicit b, float t) {\n    return Implicit(\n        mix(a.Distance, b.Distance, t),\n        mix(a.Gradient, b.Gradient, t)\n    );\n}\n\nImplicit Negate(Implicit iImplicit) {\n\treturn Implicit(-iImplicit.Distance, -iImplicit.Gradient);\n}\n\nImplicit Add(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance + b.Distance, a.Gradient + b.Gradient);\n}\n\nImplicit Subtract(Implicit a, Implicit b)  {\n\treturn Implicit(a.Distance - b.Distance, a.Gradient - b.Gradient);\n}\n\nImplicit Add(float iT, Implicit iImplicit) {\n\treturn Implicit(iT + iImplicit.Distance, iImplicit.Gradient);\n}\nImplicit Add(Implicit iImplicit, float iT) { return Add(iT, iImplicit); }\nImplicit Subtract(float iT, Implicit iImplicit) { return Add(iT, Negate(iImplicit)); }\nImplicit Subtract(Implicit iImplicit, float iT) { return Add(-iT, iImplicit); }\n\nImplicit Multiply(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance * b.Distance, a.Distance * b.Gradient + b.Distance * a.Gradient);\n}\nImplicit Multiply(float iT, Implicit iImplicit) { return Implicit(iT * iImplicit.Distance, iT * iImplicit.Gradient); }\nImplicit Multiply(Implicit iImplicit, float iT) { return Multiply(iT, iImplicit); }\n\nImplicit Divide(Implicit a, Implicit b) {\n\treturn Implicit(a.Distance / b.Distance, (b.Distance * a.Gradient - a.Distance * b.Gradient) / (b.Distance * b.Distance));\n}\nImplicit Divide(Implicit a, float b) { return Implicit(a.Distance / b, a.Gradient / b); }\n\nImplicit Min(Implicit a, Implicit b) {\n\tif (a.Distance <= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Min(Implicit a, Implicit b, Implicit c) { return Min(a, Min(b, c)); }\nImplicit Min(Implicit a, Implicit b, Implicit c, Implicit d) { return Min(a, Min(b, Min(c, d))); }\n\nImplicit Max(Implicit a, Implicit b) {\n\tif (a.Distance >= b.Distance)\n\t\treturn a;\n\n\treturn b;\n}\nImplicit Max(Implicit a, Implicit b, Implicit c) { return Max(a, Max(b, c)); }\nImplicit Max(Implicit a, float b) { return Max(a, CreateImplicit(b)); }\nImplicit Max(Implicit a, Implicit b, Implicit c, Implicit d) { return Max(a, Max(b, Max(c, d))); }\n\nImplicit Compare(Implicit iA, Implicit iB) {\n    if (iA.Distance < iB.Distance)\n        return CreateImplicit(-1.0);\n        \n    if (iA.Distance > iB.Distance)\n        return CreateImplicit(1.0);\n\n    return CreateImplicit(0.0);\n}\nImplicit Compare(Implicit iA, float iB) { return Compare(iA, CreateImplicit(iB)); }\n\nImplicit Exp(Implicit iImplicit) {\n\tfloat exp = exp(iImplicit.Distance);\n\treturn Implicit(exp, exp * iImplicit.Gradient);\n}\n\nImplicit Log(Implicit iImplicit) {\n\treturn Implicit(log(iImplicit.Distance), iImplicit.Gradient / iImplicit.Distance);\n}\n\nImplicit Pow(Implicit iMantissa, Implicit iExponent) {\n    float result = pow(iMantissa.Distance, iExponent.Distance);\n\treturn Implicit(result, result * log(iMantissa.Distance) * iMantissa.Gradient);\n}\n\nImplicit Sqrt(Implicit iImplicit) {\n\tfloat sqrt = sqrt(iImplicit.Distance);\n\treturn Implicit(sqrt, iImplicit.Gradient / (2.0 * sqrt));\n}\n\nImplicit Square(Implicit iImplicit) {\n\tfloat square = iImplicit.Distance * iImplicit.Distance ;\n\treturn Implicit(square, 2. *  square * iImplicit.Gradient);\n}\n\nImplicit Abs(Implicit iImplicit) {\n\treturn Implicit(abs(iImplicit.Distance), sign(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Sin(Implicit iImplicit) {\n\treturn Implicit(sin(iImplicit.Distance), cos(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Cos(Implicit iImplicit) {\n\treturn Implicit(cos(iImplicit.Distance), -sin(iImplicit.Distance) * iImplicit.Gradient);\n}\n\nImplicit Tan(Implicit iImplicit) {\n    float sec = 1. / cos(iImplicit.Distance);\n\treturn Implicit(tan(iImplicit.Distance), sec * sec * iImplicit.Gradient);\n}\n\nvec3 Boundary(vec3 iP, Implicit i) {\n    return -i.Distance * i.Gradient;\n}\n\nImplicit Shell(Implicit iImplicit, float thickness, float bias) {\n\tthickness *= 0.5;\n\treturn Subtract(Abs(Add(iImplicit, bias * thickness)), thickness);\n}\n\nImplicit EuclideanNorm(Implicit a, Implicit b) {\n    return Sqrt(Add(Multiply(a, a), Multiply(b, b)));\n}\nImplicit EuclideanNorm(Implicit a, Implicit b, Implicit c) {\n    return Sqrt(Add(Add(Multiply(a, a), Multiply(b, b)), Multiply(c, c)));\n}\n\n// Booleans\n\n// https://mercury.sexy/hg_sdf/\nImplicit UnionEuclidean(Implicit a, Implicit b, float radius) {\n    Implicit ua = Subtract(a, radius);\n    Implicit ub = Subtract(b, radius);\n\n    Implicit ab = Min(ua, ub);\n\n    if (max(ua.Distance, ub.Distance) < 0.) {\n        ab = Negate(EuclideanNorm(ua, ub));\n    }\n\n    return Add(ab, radius);\n}\n\nImplicit IntersectionEuclidean(Implicit a, Implicit b, float radius) {\n    return Negate(UnionEuclidean(Negate(a), Negate(b), radius));\n}\n\nImplicit IntersectionSmoothExp(Implicit a, Implicit b, float radius) {\n    return Negate(UnionEuclidean(Negate(a), Negate(b), radius));\n}\n\n\nImplicit UnionEuclidean(Implicit a, Implicit b, Implicit c, float radius) {\n    Implicit zero = CreateImplicit(0.0);\n    Implicit r = CreateImplicit(radius);\n    Implicit ua = Max(Subtract(r, a), zero);\n    Implicit ub = Max(Subtract(r, b), zero);\n    Implicit uc = Max(Subtract(r, c), zero);\n\n    Implicit abc = Min(a, Min(b, c));\n\n\tImplicit op = Subtract(Max(r, abc), EuclideanNorm(ua, ub, uc));\n\n    if (abc.Distance > 0.0)\n        op.Gradient = abc.Gradient;\n\n    vec3 bary = 0.33 * vec3(ua.Distance, ub.Distance, uc.Distance) / (ua.Distance + ub.Distance + uc.Distance);\n\n    return op;\n}\n\nImplicit UnionChamfer(Implicit iA, Implicit iB, float k) {\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(h, 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n\n    return result;\n}\n\nImplicit UnionRound(Implicit iA, Implicit iB, float k) {\n    Implicit h = Multiply(Max(Subtract(CreateImplicit(k), Abs(Subtract(iA, iB))), CreateImplicit()), 1.0 / k);\n    Implicit h2 = Multiply(Multiply(h, h), 0.5);\n    Implicit result = Subtract(Min(iA, iB), Multiply(h2, k * 0.5));\n    float param = h2.Distance;\n\n    return result;\n}\n\n// Primitives\n\nImplicit Plane(vec3 p, vec3 origin, vec3 normal) {\n    vec3 grad = normalize(normal);\n    float v = dot(p - origin, grad);\n    return Implicit(v, grad);\n}\nImplicit Plane(vec2 p, vec2 origin, vec2 normal) {\n    return Plane(vec3(p, 0.0), vec3(origin, 0.0), vec3(normal, 0.0));\n}\n\n\nImplicit Circle(vec2 p, vec2 center, float iRadius) {\n\tvec2 centered = p - center;\n    float len = length(centered);\n\tfloat length = len - iRadius;\n\treturn Implicit(length, vec3(centered / len, 0.0));\n}\n\nmat2 Rotate2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nmat3 RotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0.0),\n        vec3(s, c, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec3 RotateX(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, -sa * p.y + ca * p.z, ca * p.y + sa * p.z);\n}\nvec3 RotateY(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 RotateZ(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\nImplicit Sphere(vec3 iP, vec3 iCenter, float iRadius) {\n\tvec3 centered = iP - iCenter;\n    float length = length(centered);\n\tfloat dist = length - iRadius;\n\treturn Implicit(dist, centered / length);\n}\n\nImplicit BoxCenter(vec3 iP, vec3 iCenter, vec3 iSize) {\n\tvec3 p = iP - iCenter;\n\tvec3 b = iSize * 0.5;\n\n\tvec3 d = abs(p)-b;\n\tfloat dist = length(max(d, vec3(0.))) + min(max(d.x, max(d.y, d.z)), 0.);\n\n\tvec3 grad = (d.x > d.y) && (d.x > d.z) ? vec3(1., 0., 0.) :\n\t\t(d.y > d.z ? vec3(0., 1., 0.) : vec3(0., 0., 1.));\n\n\tif (d.x > 0. || d.y > 0. || d.z > 0.)\n\t{\n\t\td = max(d, 0.);\n\t\tgrad = d / length(d);\n\t}\n\n\tgrad *= sign(p);\n\n\treturn Implicit(dist, grad);\n}\n\nImplicit Box(vec3 iP, vec3 iA, vec3 iB) {\n\tvec3 center = (iA + iB) * 0.5;\n\tvec3 size = abs(iA - iB);\n\treturn BoxCenter(iP, center, size);\n}\n\nconst vec3 center = vec3(0.5);\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// LatticeRobot Unique Unit Cell\n\n#if 0\nuniform int latticeIndex;\nuniform float size_x;\nuniform float size_y;\nuniform float size_z;\nuniform float bias;\nuniform float thickness;\nuniform float drop_x;\nuniform float drop_y;\nuniform float drop_z;\nuniform float gyroid;\n#else\nint latticeIndex = 2;\nfloat size_x = 10.0;\nfloat size_y = 10.0;\nfloat size_z = 10.0;\nfloat bias = 0.0;\nfloat thickness = 1.0;\nfloat drop_x = 1.0;\nfloat drop_y = 1.0;\nfloat drop_z = 1.0;\nfloat gyroid = 0.0;\n#endif\n\nfloat supremum = SQRT2;\n\nImplicit mix(Implicit a, float b, float t) {\n  float _mix_000 = 1.0 - t;\n  Implicit _mix_001 = Multiply(_mix_000, a);\n  float _mix_002 = t * b;\n  Implicit _mix_003 = Add(_mix_001, _mix_002);\n  return _mix_003;\n}\n\nImplicit solidLattice(vec3 p) {\n  float _tpms_000 = 1.0 - gyroid;\n  Implicit x = Implicit(p.x, vec3(1.0, 0.0, 0.0));\n  float halfsizeX = size_x * 0.5;\n  float frequencyX = PI / halfsizeX;\n  Implicit _sx_000 = Multiply(x, frequencyX);\n  Implicit sx = Sin(_sx_000);\n  Implicit _tpms_001 = Multiply(_tpms_000, sx);\n  Implicit y = Implicit(p.y, vec3(0.0, 1.0, 0.0));\n  float halfsizeY = size_y * 0.5;\n  float frequencyY = PI / halfsizeY;\n  Implicit _sy_000 = Multiply(y, frequencyY);\n  Implicit sy = Sin(_sy_000);\n  Implicit _tpms_002 = Multiply(_tpms_001, sy);\n  Implicit z = Implicit(p.z, vec3(0.0, 0.0, 1.0));\n  float halfsizeZ = size_z * 0.5;\n  float frequencyZ = PI / halfsizeZ;\n  Implicit _sz_000 = Multiply(z, frequencyZ);\n  Implicit sz = Sin(_sz_000);\n  Implicit _tpms_003 = Multiply(_tpms_002, sz);\n  Implicit _tpms_004 = Multiply(drop_x, sx);\n  Implicit _cy_000 = Multiply(y, frequencyY);\n  Implicit cy = Cos(_cy_000);\n  Implicit _tpms_005 = Multiply(_tpms_004, cy);\n  Implicit _cz_000 = Multiply(z, frequencyZ);\n  Implicit cz = Cos(_cz_000);\n  Implicit _tpms_006 = mix(cz, 1.0, gyroid);\n  Implicit _tpms_007 = Multiply(_tpms_005, _tpms_006);\n  Implicit _tpms_008 = Add(_tpms_003, _tpms_007);\n  Implicit _tpms_009 = Multiply(drop_y, sy);\n  Implicit _tpms_010 = Multiply(_tpms_009, cz);\n  Implicit _cx_000 = Multiply(x, frequencyX);\n  Implicit cx = Cos(_cx_000);\n  Implicit _tpms_011 = mix(cx, 1.0, gyroid);\n  Implicit _tpms_012 = Multiply(_tpms_010, _tpms_011);\n  Implicit _tpms_013 = Add(_tpms_008, _tpms_012);\n  Implicit _tpms_014 = Multiply(drop_z, sz);\n  Implicit _tpms_015 = Multiply(_tpms_014, cx);\n  Implicit _tpms_016 = mix(cy, 1.0, gyroid);\n  Implicit _tpms_017 = Multiply(_tpms_015, _tpms_016);\n  Implicit tpms = Add(_tpms_013, _tpms_017);\n  Implicit _lattice_000 = Multiply(tpms, size_x);\n  float infimum = -1.0 * SQRT2;\n  float range = supremum - infimum;\n  float _lattice_001 = 2.0 * range;\n  Implicit _lattice_002 = Divide(_lattice_000, _lattice_001);\n  Implicit lattice = Subtract(_lattice_002, bias);\n  Implicit solid = lattice;\n  return solid;\n}\n\nImplicit inverseLattice(vec3 p) {\n  float _tpms_000 = 1.0 - gyroid;\n  Implicit x = Implicit(p.x, vec3(1.0, 0.0, 0.0));\n  float halfsizeX = size_x * 0.5;\n  float frequencyX = PI / halfsizeX;\n  Implicit _sx_000 = Multiply(x, frequencyX);\n  Implicit sx = Sin(_sx_000);\n  Implicit _tpms_001 = Multiply(_tpms_000, sx);\n  Implicit y = Implicit(p.y, vec3(0.0, 1.0, 0.0));\n  float halfsizeY = size_y * 0.5;\n  float frequencyY = PI / halfsizeY;\n  Implicit _sy_000 = Multiply(y, frequencyY);\n  Implicit sy = Sin(_sy_000);\n  Implicit _tpms_002 = Multiply(_tpms_001, sy);\n  Implicit z = Implicit(p.z, vec3(0.0, 0.0, 1.0));\n  float halfsizeZ = size_z * 0.5;\n  float frequencyZ = PI / halfsizeZ;\n  Implicit _sz_000 = Multiply(z, frequencyZ);\n  Implicit sz = Sin(_sz_000);\n  Implicit _tpms_003 = Multiply(_tpms_002, sz);\n  Implicit _tpms_004 = Multiply(drop_x, sx);\n  Implicit _cy_000 = Multiply(y, frequencyY);\n  Implicit cy = Cos(_cy_000);\n  Implicit _tpms_005 = Multiply(_tpms_004, cy);\n  Implicit _cz_000 = Multiply(z, frequencyZ);\n  Implicit cz = Cos(_cz_000);\n  Implicit _tpms_006 = mix(cz, 1.0, gyroid);\n  Implicit _tpms_007 = Multiply(_tpms_005, _tpms_006);\n  Implicit _tpms_008 = Add(_tpms_003, _tpms_007);\n  Implicit _tpms_009 = Multiply(drop_y, sy);\n  Implicit _tpms_010 = Multiply(_tpms_009, cz);\n  Implicit _cx_000 = Multiply(x, frequencyX);\n  Implicit cx = Cos(_cx_000);\n  Implicit _tpms_011 = mix(cx, 1.0, gyroid);\n  Implicit _tpms_012 = Multiply(_tpms_010, _tpms_011);\n  Implicit _tpms_013 = Add(_tpms_008, _tpms_012);\n  Implicit _tpms_014 = Multiply(drop_z, sz);\n  Implicit _tpms_015 = Multiply(_tpms_014, cx);\n  Implicit _tpms_016 = mix(cy, 1.0, gyroid);\n  Implicit _tpms_017 = Multiply(_tpms_015, _tpms_016);\n  Implicit tpms = Add(_tpms_013, _tpms_017);\n  Implicit _lattice_000 = Multiply(tpms, size_x);\n  float infimum = -1.0 * SQRT2;\n  float range = supremum - infimum;\n  float _lattice_001 = 2.0 * range;\n  Implicit _lattice_002 = Divide(_lattice_000, _lattice_001);\n  Implicit lattice = Subtract(_lattice_002, bias);\n  Implicit inverse = Multiply(-1.0, lattice);\n  return inverse;\n}\n\nImplicit thinLattice(vec3 p) {\n  float _tpms_000 = 1.0 - gyroid;\n  Implicit x = Implicit(p.x, vec3(1.0, 0.0, 0.0));\n  float halfsizeX = size_x * 0.5;\n  float frequencyX = PI / halfsizeX;\n  Implicit _sx_000 = Multiply(x, frequencyX);\n  Implicit sx = Sin(_sx_000);\n  Implicit _tpms_001 = Multiply(_tpms_000, sx);\n  Implicit y = Implicit(p.y, vec3(0.0, 1.0, 0.0));\n  float halfsizeY = size_y * 0.5;\n  float frequencyY = PI / halfsizeY;\n  Implicit _sy_000 = Multiply(y, frequencyY);\n  Implicit sy = Sin(_sy_000);\n  Implicit _tpms_002 = Multiply(_tpms_001, sy);\n  Implicit z = Implicit(p.z, vec3(0.0, 0.0, 1.0));\n  float halfsizeZ = size_z * 0.5;\n  float frequencyZ = PI / halfsizeZ;\n  Implicit _sz_000 = Multiply(z, frequencyZ);\n  Implicit sz = Sin(_sz_000);\n  Implicit _tpms_003 = Multiply(_tpms_002, sz);\n  Implicit _tpms_004 = Multiply(drop_x, sx);\n  Implicit _cy_000 = Multiply(y, frequencyY);\n  Implicit cy = Cos(_cy_000);\n  Implicit _tpms_005 = Multiply(_tpms_004, cy);\n  Implicit _cz_000 = Multiply(z, frequencyZ);\n  Implicit cz = Cos(_cz_000);\n  Implicit _tpms_006 = mix(cz, 1.0, gyroid);\n  Implicit _tpms_007 = Multiply(_tpms_005, _tpms_006);\n  Implicit _tpms_008 = Add(_tpms_003, _tpms_007);\n  Implicit _tpms_009 = Multiply(drop_y, sy);\n  Implicit _tpms_010 = Multiply(_tpms_009, cz);\n  Implicit _cx_000 = Multiply(x, frequencyX);\n  Implicit cx = Cos(_cx_000);\n  Implicit _tpms_011 = mix(cx, 1.0, gyroid);\n  Implicit _tpms_012 = Multiply(_tpms_010, _tpms_011);\n  Implicit _tpms_013 = Add(_tpms_008, _tpms_012);\n  Implicit _tpms_014 = Multiply(drop_z, sz);\n  Implicit _tpms_015 = Multiply(_tpms_014, cx);\n  Implicit _tpms_016 = mix(cy, 1.0, gyroid);\n  Implicit _tpms_017 = Multiply(_tpms_015, _tpms_016);\n  Implicit tpms = Add(_tpms_013, _tpms_017);\n  Implicit _lattice_000 = Multiply(tpms, size_x);\n  float infimum = -1.0 * SQRT2;\n  float range = supremum - infimum;\n  float _lattice_001 = 2.0 * range;\n  Implicit _lattice_002 = Divide(_lattice_000, _lattice_001);\n  Implicit lattice = Subtract(_lattice_002, bias);\n  Implicit _thin_000 = Abs(lattice);\n  float _thin_001 = thickness * 0.5;\n  Implicit thin = Subtract(_thin_000, _thin_001);\n  return thin;\n}\n\nImplicit twinLattice(vec3 p) {\n  Implicit thin = thinLattice(p);\n  Implicit twin = Multiply(-1.0, thin);\n  return twin;\n}\n\nImplicit indexedLattice(vec3 p) {\n  switch (latticeIndex) {\n    case 0: return solidLattice(p);\n    case 1: return inverseLattice(p);\n    case 2: return thinLattice(p);\n    case 3: return twinLattice(p);\n  }\n  return Sphere(p, vec3(0.0), 5.0);\n}\n\nImplicit scaledLattice(vec3 scaledP) {\n  vec3 p = (scaledP - center) * 10.0;\n  Implicit lattice = indexedLattice(p);\n  return Divide(lattice, 10.0);\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// LatticeRobot CodeRep output v0.0\n//\n// Please see the \"Common\" tab for LatticeRobot interop.  \n// This buffer is for the ShaderToy sliders.\n//\n// This slider approach is slow.  Expect a replacement. \n//\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// Sliders from work ceated by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thx to :\n// Smooth HSV - iq : https://www.shadertoy.com/view/MsS3Wc\n// Rounded box - iq : https://www.shadertoy.com/view/4llXD7\n// 96-Bit 8x12 font - Flyguy : https://www.shadertoy.com/view/Mt2GWD\n\n// NON MINIFIED VERSION : https://www.shadertoy.com/view/XsySzG\n\nvec4 bounds = vec4(30,410,160,18);\n\n#define UI_COLOR vec3(0.0,0.0,0.0)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n// Backwards at https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h\n#define RPAREN text.w += char(0x180C, 0x0606, 0x060C, 0x1800);\n#define LPAREN text.w += char(0x060C, 0x1818, 0x180C, 0x0600);\n#define SLASH  text.w += char(0x0306, 0x0C18, 0x3060, 0x4000);\n#define BSLASH text.w += char(0x6030, 0x180C, 0x0603, 0x0100);\n#define PLUS   text.w += char(0x000C, 0x0C3F, 0x0C0C, 0x0000);\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float minval, float maxval, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val * (maxval - minval) + minval, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, float minval, float maxval, inout float ui, vec2 p, vec4 b){  \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, minval, maxval, 1., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n}\n\n//boolean\nvoid drawBoolean(int id, float val, inout float ui, vec2 p, vec4 b){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy, b) <= gap && iMouse.w > 0.0){\n     //   float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x + b.z) - b.x;\n      //  data.r = round(distanceFromLeftEdege / b.z);        \n        //data.a=1.0;\n        data.r = round(1.0 - data.r);\n        setPixel(vec2(id, 1), data);\n        \n        b.w = 35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r > 0.5) {\n        _T R U E\n    }\n    else {\n        _F A L S E\n    }\n    ui = mix(ui, 0., text.w);\n    text = tmp;\n}\n\n//chooser\nvoid drawChooser(int id, float val, inout float ui, vec2 p, vec4 b, int count){  \n    float gap = 11.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val, .4, 0, 1);\n        setPixel(vec2(id, 1), data);\n    }    \n    \n   // b.z = b.x + b.w;\n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdege/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    \n    float increment = 1. / float(count);\n    moveCursor(b.xy + vec2(8., 5.));\n    if (data.r < 1. * increment) {\n        _S O L I D\n    }\n    else if (data.r < 2. * increment){\n        _I N V E R S E\n    }\n    else if (data.r < 3. * increment){\n        _T H I N\n    }\n    else {\n        _T W I N\n    }\n    ui = mix(ui, 0., text.w);\n\n    text = tmp;\n}\n\n#define EASYSLIDER(id,val,minval,maxval) drawSlider(id, val, minval, maxval, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYBOOLEAN(id,val) drawBoolean(id, round(val), ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n#define EASYCHOOSER(id,val,count) drawChooser(id, val, ui, pixel, bounds, count); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = fragCoord.xy;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n    \n    //define sliders    \n    EASYCHOOSER(0, 2.0, 4)  _V A R I A N T   \n    EASYSLIDER(10, 0.0, 1.0, 4.0)  _C O U N T   \n    EASYSLIDER(1, 0.5, 5.0, 15.0)  _S I Z E _ _X    \n    EASYSLIDER(2, 0.5, 5.0, 15.0)  _S I Z E _ _Y    \n    EASYSLIDER(3, 0.5, 5.0, 15.0)  _S I Z E _ _Z          \n    EASYSLIDER(4, 0.5, -2.5, 2.5)  _B I A S  \n    EASYSLIDER(5, 0.5, 0.0, 5.0)  _T H I C K N E S S   \n    EASYSLIDER(6, 1.0, 0.0, 1.0)  _D R O P _ _X    \n    EASYSLIDER(7, 1.0, 0.0, 1.0)  _D R O P _ _Y    \n    EASYSLIDER(8, 1.0, 0.0, 1.0)  _D R O P _ _Z    \n    EASYSLIDER(9, 0.0, 0.0, 1.0)  _G Y R O I D   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n    \n    fragColor=result;    \n}","name":"Buffer A","description":"","type":"buffer"}]}