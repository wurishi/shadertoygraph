{"ver":"0.1","info":{"id":"NtfXRB","date":"1625916223","viewed":131,"name":"Blobby Cavern","username":"Taron","description":"Still not brilliant and way too slow, but good fun for some exploration.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blobby","fractalnoise","volumn"],"hasliked":0,"parentid":"stlXWM","parentname":"camouflage depth"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OCT 3\nfloat hash(vec3 p)\n{\n\tp  = fract(p * .1337);\n    p += dot(p, p.zyx + 37.36);\n    return fract((p.x + p.y) * p.z);\n}\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.,1.,f);\n    \n    vec2 oo = vec2(1.,0.);\n    \n    return mix(mix(mix(hash(i+oo.yyy),hash(i+oo.xyy),u.x),\n                   mix(hash(i+oo.yxy),hash(i+oo.xxy),u.x),u.y),\n               mix(mix(hash(i+oo.yyx),hash(i+oo.xyx),u.x),\n                   mix(hash(i+oo.yxx),hash(i+oo.xxx),u.x),u.y),u.z);\n}\n\nfloat turb(vec3 p, float noiseThreshold, float noiseSoftness, int oct, float dist)\n{\n    float r = 0.0,\n          w = 1.0, \n          s = 1.0,\n          d = 0.0;\n    for (int i=0; i<oct; i++)\n    {\n         r += w * noise(p);\n         d += w;\n         w *= 0.573;\n         p *= 1.677;\n     }\n    r = abs(-1.+2.*r/d);\n    return smoothstep(noiseThreshold,noiseSoftness+noiseThreshold,r)+(.1-dist);\n}\n\nfloat march(vec3 cp, vec3 cd){\n\tfloat dO=1.;\n    vec3 p = cp;\n    vec3 sp = cd;\n    float sf = .05;\n    for(int i=0; i<100; i++) {\n    \tp += sp;\n        float dS = turb(p, .01,.5, OCT, min(.1,dO-1.));\n        sf = (1.*dS)*.1+.01;\n        dO += sf;\n        sp = cd*sf;\n        if(dO>6.|| abs(dS)<0.001){\n            p-=sp;\n            sf = 0.001;\n            sp = cd*sf;\n            int cnt = 0;\n            dS = 1.;\n            while(cnt<10 && dS>0.001){\n                cnt++;\n                dO+=0.001;\n                p+=sp;\n                dS = turb(p, .01,.5, OCT, min(.1,dO-1.));\n            }\n            break;\n        }\n    }\n    \n    return dO;\n}\nvec3 norm(vec3 p, float dist){\n    vec2 oo = vec2(.025,0.);\n    float nx = turb(p+oo.xyy, .0,.5, OCT,dist);\n    float ny = turb(p+oo.yxy, .0,.5, OCT,dist);\n    float nz = turb(p-oo.yyx, .0,.5, OCT,dist);\n    return -normalize(vec3(nx,ny,nz));\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fC )\n{\n    vec2 uv = (fC.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 ms = iMouse.xy/iResolution.xy * 6.28;\n\n    vec3 camera = vec3(0.);\n    vec3 target = vec3(uv*(.5+.5*dot(uv,uv)),.25);\n    target.yz *= Rot(-ms.y+sin(iTime*.25));\n    target.xy *= Rot(-ms.x+cos(iTime*.5));\n     \n    vec3 cdir = normalize(camera-target);\n   \n    vec3 p = camera-vec3(0.,0.,iTime*.25);\n    \n    vec3 col = vec3(0.1,0.6,0.8);\n    \n    float depth = march(p,cdir);\n    if(depth<6.){\n        vec3 s = p+cdir*depth;\n        vec3 l = s-p;\n        float fo = max(0.,1.-.25*dot(l,l));\n        float light = 0.;\n        if(fo>0.){\n            vec3 n = norm(s, 0.1);\n            l = normalize(l);\n            light = (.5+.5*dot(n,l))*fo;\n        }\n        col = mix(vec3(light),col,-.5+depth/4.);\n   }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}