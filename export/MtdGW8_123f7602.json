{"ver":"0.1","info":{"id":"MtdGW8","date":"1469109961","viewed":351,"name":"Gooey, pure WebGL","username":"caesarsol","description":"Click to move the blue balloon","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","gooey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 red = vec3(1, 0, 0);\nvec3 blue = vec3(0, 0, 1);\nvec3 green = vec3(0, 1, 0);\n\nfloat limit(float x) {\n  return clamp(x, 0.0, 1.0);\n}\n\nvec4 buildCircleLinearBlur(vec2 center, float radius, vec3 color, float blurRadius, vec2 xy) {\n  float r = length(xy - center);\n  float alpha = 1.0 - clamp(r / (radius + blurRadius), 0.0, 1.0);\n  return vec4(color, alpha);\n}\n\nvec4 buildCircleHermiteBlur(vec2 center, float radius, vec3 color, float blur, vec2 xy) {\n  float r = length(xy - center);\n  float inner = radius - blur;\n  float outer = radius + blur;\n  float alpha = 1.0 - smoothstep(inner, outer, r);\n  return vec4(color, alpha);\n}\n\nfloat rstep(float a, float v) {\n  return step(v, a);\n}\n\nfloat stepBetween(float a, float b, float v) {\n  return step(a, v) * step(v, b);\n}\nvec2 stepBetween(vec2 a, vec2 b, vec2 v) {\n  return step(a, v) * step(v, b);\n}\n\nfloat smoothstepBetween(float a, float b, float s, float v) {\n  return smoothstep(a, a+s, v) * (1.0 - smoothstep(b-s, b, v));\n}\n  \n\nvec4 buildRect(vec2 a, vec2 b, vec3 color, vec2 xy) {\n  vec2 hv = stepBetween(a.xy, b.xy, xy);\n  float alpha = hv.x * hv.y;\n  return vec4(color.rgb, alpha);\n}\n\nfloat m(vec2 a, vec2 b) { return (a.y - b.y)/(a.x - b.x); }\nfloat q(vec2 a, vec2 b) { return (a.y - a.x * m(a, b)); }\n\nfloat semiplane(vec2 a, vec2 b, vec2 xy) {\n  float m = m(a, b);\n  return step(xy.y, m * xy.x + q(a, b));\n  //float right = step(xy.y, m * xy.x + q(a, b)) * rstep(m, 0.0);\n  //float left = step(xy.y, m * xy.x + q(a, b)) * step(m, 0.0);\n  //return max(right, left);\n}\n\nvec4 buildPoly(vec2 a, vec2 b, vec2 c, vec2 d, vec3 color, vec2 xy) {\n  float ab = semiplane(a, b, xy);\n  float bc = semiplane(b, c, xy);\n  float cd = semiplane(c, d, xy);\n  float da = 1.0 - semiplane(d, a, xy);\n  float alpha = ab * bc * cd * da;\n  return vec4(color.rgb, alpha);\n}\n\nvec2 project(vec2 v, vec2 dir) {\n  vec2 normDir = normalize(dir);\n  return dot(v, normDir) * normDir;\n}\n\nvec2 reject(vec2 v, vec2 dir) {\n  return v - project(v, dir);\n}\n\nfloat projectionLength(vec2 v, vec2 dir) {\n  vec2 normDir = normalize(dir);\n  return dot(v, normDir);\n}\n\nvec4 buildLineBlurColor(vec2 p1, vec2 p2, vec3 color1, vec3 color2, float blur, vec2 xy) {\n  float a = distance(p1, xy);\n  float b = distance(p2, xy);\n  float c = distance(p1, p2);\n    \n  vec2 para = project(xy - p1, p2 - p1);\n  vec2 perp = reject(xy - p1, p2 - p1); \n    \n  float l = projectionLength(xy - p1, p2 - p1);\n  float s = l / c;  // Measures the point at which we are in the segment\n  float q = length(perp);\n\n  float lineEndMask = smoothstepBetween(0.0, c, 15.0, l);\n  float width = 1.0;\n  blur *= mix(20.0, 50.0, s) / 20.0;\n  float lineWidthMask = smoothstep(width + blur/2.0, width - blur/2.0, q);\n\n  vec3 color = mix(color1, color2, s);\n  float alpha = lineEndMask * lineWidthMask;\n  return vec4(color, alpha);\n}\n\nfloat delta(float x, float width) {\n  //return step(-width/2.0, x) - step(width/2.0, x);\n  return clamp(smoothstep(-width, 0.0, x) - smoothstep(0.0, width, x), 0.0, 1.0);\n}\n\nfloat delta(float x) {\n  return delta(x, 1.0);\n}\n\nvec4 blend(vec4 bg, vec4 fg){\n  vec3 bgm = bg.rgb * bg.a;\n  vec3 fgm = fg.rgb * fg.a;\n  float ia = 1.0 - fg.a;\n  float a = (fg.a + bg.a * ia);\n  if (a == 0.0) return vec4(0.0, 0.0, 0.0, a);\n  vec4 rgba;\n  rgba.rgb = (fgm + bgm * ia) / a;\n  rgba.a = a;\n  return rgba;\n}\n\nvec4 alphaContrast(vec4 color, float mult, float sub) {\n  float a = limit(color.a * mult - sub);\n  //a = color.a;\n  return vec4(color.rgb, a);\n}\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 xy = fragCoord.xy;\n  vec2 center = iResolution.xy * 0.5;\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  float r1 = 20.0;\n  float r2 = 50.0;\n  float b = 50.0;\n  vec2 c1 = iMouse.xy;\n  vec2 c2 = center + vec2(200.0, 0.0);\n    \n  if (iMouse.x == 0.0) {\n    float ang = iTime;\n    c1.x = center.x + sin(ang) * 250.0;\n    c1.y = center.y + cos(ang) * 100.0;\n  }\n\n  //vec4 circleOutline = vec4(0.5, 0.5, 0.0, delta(radius - length(xy - center + 40.0)));\n  \n  vec4 bg = vec4(0.5, 0.5, 0.5, 1.0);\n\n  vec4 fg = vec4(0.0, 0.0, 0.0, 0.0);\n  fg = blend(fg, buildLineBlurColor(c1, c2, blue, green, b, xy));\n  fg = blend(fg, buildCircleHermiteBlur(c1, r1, blue, b, xy));\n  fg = blend(fg, buildCircleHermiteBlur(c2, r2, green, b, xy));\n  fg = alphaContrast(fg , 40.0, 16.0);\n\n  fragColor = blend(bg, fg);\n}\n","name":"Image","description":"","type":"image"}]}