{"ver":"0.1","info":{"id":"csyGzw","date":"1678302854","viewed":215,"name":"5 procedural textures","username":"ianertson","description":"* Wooden planks\n* Dirty metal\n* Grass\n* Marble\n* Rock / Stone\n\nUse the mouse to look around :)","likes":14,"published":1,"flags":48,"usePreview":1,"tags":["procedural","3d","texture","materials","textures","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define WALK 0\n\n#define CAMERA_ORIGIN vec3(0, 0, -6)\n#define CAMERA_Y 0.5\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX_1 2\n#define ID_BOX_2 3\n#define ID_BOX_3 4\n#define ID_BOX_4 5\n#define ID_BOX_5 6\n\nfloat rand(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= (s ^ ((~p.x << s) + (~p.y << s)));\n    \n    p ^= (p << 17U);\n    p ^= ((p ^ s) >> 13U);\n    p ^= (p << 5U);\n    p ^= ((s + (s&(p.x^p.y))) >> 3U);\n    \n    uint n = (p.x*s+p.y)+((p.x ^ p.y) << ~p.x ^ s) + ((p.x ^ p.y) << ~p.y ^ s);\n    return float(n*50323U) / float(0xFFFFFFFFU);\n}\n\nvec3 trand(in vec2 p, in float seed, in float lod) {\n    return textureLod(iChannel3, (p + (seed*1.90928382))/256., lod).xyz;\n}\n\nfloat xnoise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(rand(id, seed), rand(id+vec2(1, 0), seed), lv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat xnoise(in vec2 p, in float seed, in float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*xnoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(trand(id, seed, lod), trand(id+vec2(1, 0), seed, lod), lv.x),\n        mix(trand(id + vec2(0, 1), seed, lod), trand(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, in float warp, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n        p += ((n.xy*(0.5+(0.5*n.z)))*2.0-1.0)*warp; \n    }\n    \n    return n / div;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    float dist = FAR;\n    int skip = data.skip;\n    int id = ID_NONE;\n    \n    float ground = groundSDF(p);\n    \n    float numBoxes = 5.0;\n    \n    float box1 = boxSDF(p - vec3(-numBoxes*0.5, 0.5, 0), vec3(0.5));\n    SAMPLE(box1, ID_BOX_1);\n    float box2 = boxSDF(p - vec3(-(numBoxes*0.5)/2., 0.5, 0), vec3(0.5));\n    SAMPLE(box2, ID_BOX_2);\n    \n    float box3 = boxSDF(p - vec3(0., 0.5, 0), vec3(0.5));\n    SAMPLE(box3, ID_BOX_3)\n    \n    float box4 = boxSDF(p - vec3(numBoxes*0.5, 0.5, 0), vec3(0.5));\n    SAMPLE(box4, ID_BOX_4);\n    float box5 = boxSDF(p - vec3((numBoxes*0.5)/2., 0.5, 0), vec3(0.5));\n    SAMPLE(box5, ID_BOX_5)\n    \n    SAMPLE(ground, ID_GROUND);\n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float d = 0.0;\n    const int steps = STEPS / 2;\n    for (int i = ZERO; i < steps; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= far) return 1.0;\n    }\n    return clamp(d/(1.0+d), 0.0, 1.0);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow;\n}\n\nfloat checkerTexture(in vec2 uv, in float s) {\n    vec2 d = max(abs(dFdx(uv)), abs(dFdy(uv))) + s;\n    vec2 t1 = vec2(1.-2.0*abs(fract((uv.x+.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y+.5*d.y)*.5)-0.5));\n    vec2 t2 = vec2(1.-2.0*abs(fract((uv.x-.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y-.5*d.y)*.5)-0.5));\n    return 0.5 - 0.5*((t1.x-t2.x)/d.x)*(t1.y-t2.y)/d.y;\n}\n\n//#define DEBUG_TEXTURE plankTexture\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n\n    float hf1 = xnoise(uv*4., 0.329125, 10.0, 4);\n    vec3 hf2 =  snoise(uv*4., 0.329125, 0.9, 10.0, 4);\n    vec3 lf1 = snoise(uv*0.5,  1.772734, 0.3, 2.9, 6);\n\n    \n    vec3 c1 = rgb(188, 121, 71);\n    vec3 c2 = rgb(170, 146, 118);\n    vec3 c3 = rgb(156, 116, 77);\n    vec3 c4 = rgb(131, 76, 35);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf2.x), c3, hf2.y), c4, hf2.z);\n    col += col1;\n    \n    float tile = 4.0;\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x)*10.*lf1.y, sin((uv.y)*TAU)*2.));\n    \n    vec2 k = fract((uv+0.25)*(tile/2.));\n    k = abs(k*2.0-1.0);\n    float g = max(0.0, 1.0-round(k.y+0.45));\n    \n    float sg = smoothstep(0.33-0.05, 0.4+0.05, max(0.0, 1.0-k.y-0.6));\n    \n    float w = w2;\n    float edge = abs(w*2.0-1.0);\n    edge = max(0.0, 1.0 - smoothstep(0.02, 0.29, edge));\n    \n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    vec3 col2 = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    col = mix(col, mix(col2, c2, lf1.x), w);\n    col = mix(col, col*col, edge*lf1.y);\n    \n    col = mix(col, col*col*col, clamp(sg*(0.5+(hf2.z*0.5))*1.25, 0.0, 1.0));\n    \n    m.spec = clamp((sg-(g*0.5))+max(0.0, (grain.x*lf1.x)-edge), 0.0, 1.0);\n\n    return col;\n}\n\n//#define DEBUG_TEXTURE metalTexture\n\nvec3 metalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoiseWarp(uv, 0.0328125, 0.9, 16.0, 0.25, 6);\n    vec3 hf2 = snoise(uv, 2.3456767, 0.9, 64.0, 2);\n    vec3 hf3 = clamp(abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0))), 0.0, 1.0);\n    vec3 lf1 = snoiseWarp(uv, 5.55939123, 0.9, 8.0, 0.25, 6);\n    vec3 lf2 = snoise(uv, 10.02931925, 0.0, 2.5, 4);\n  \n    vec3 grain = textureLod(iChannel3, uv*0.5, 0.0).xyz;\n    vec3 hf4 = clamp(abs(normalize(cross(reflect((hf3)*2.0-1.0, grain*2.0-1.0), hf1*2.0-1.0))), 0.0, 1.0);\n    \n    vec3 m1 = rgb(134, 145, 151);\n    vec3 m2 = rgb(89, 91, 97);\n    vec3 m3 = rgb(175, 175, 175);\n    vec3 m4 = rgb(203, 203, 203);\n    vec3 m5 = rgb(92, 92, 92);\n    \n    vec3 col1 = mix(mix(mix(m1, m2, hf1.x), m3, hf1.y), m4, hf1.z);\n    \n    col += col1;\n    \n    vec3 d1 = rgb(103, 80, 71);\n    vec3 d2 = rgb(118, 92, 57);\n    vec3 d3 = rgb(71, 55, 40);\n    vec3 d4 = rgb(181, 106, 50);\n    \n    vec3 d5 = rgb(52, 51, 56);\n    vec3 d6 = rgb(69, 64, 56);\n    vec3 d7 = rgb(109, 94, 88);\n    vec3 d8 = rgb(82, 78, 80);\n    \n    vec3 dirtCol1 = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n    vec3 dirtCol2 = mix(mix(mix(d5, d6, hf3.x), d7, hf3.y), d8, hf3.z);\n    \n    vec3 dirtCol = mix(dirtCol1, dirtCol2, smoothstep(0.34, 0.5, lf1.x));\n    \n    float dirtReg = clamp(pow(lf2.x, 3.)*6., 0.0, 1.0);\n    col = mix(col, dirtCol, 0.5);\n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, hf4.z*lf2.y*grain.x*grain.y);\n    \n    m.spec = clamp(lf1.x*max(0.0, 1.0-(dirtReg*hf3.y)), 0.0, 1.0);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE grassTexture\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    uv += 0.;\n    vec3 hf1 = snoise(uv, 0.03982213, 0.0, 140.0, 3);\n    vec3 hf2 = fract(hf1*102.392981523);\n    vec3 lf1 = snoise(uv, 1.29392152, 0.3, 3.0, 4);\n    vec3 hf3 = fract(2.029812*reflect(cross(hf1*2.0-1.0, fract(hf1*11.9238123)*2.0-1.0), lf1*2.0-1.0));\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    vec3 g1 = rgb(62, 76, 20);\n    vec3 g2 = rgb(99, 100, 59);\n    vec3 g3 = rgb(111, 144, 65);\n    vec3 g4 = rgb(89, 85, 61);\n    vec3 g5 = rgb(62, 60, 25);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    grassCol = mix(grassCol, g5, hf2.x*lf1.x);\n    col += grassCol;\n    \n    vec3 d1 = rgb(68, 50, 38);\n    vec3 d2 = rgb(113, 98, 79);\n    vec3 d3 = rgb(102, 78, 56);\n    vec3 d4 = rgb(118, 102, 83);\n    \n    vec3 dirtCol = mix(mix(mix(d1, d2, hf3.x), d3, hf3.y), d4, hf3.z);\n    \n    float dirtReg = lf1.y*lf1.z;\n    \n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, lf1.z*lf1.z*lf1.z);\n    col = mix(col, col*col, grain.x*hf3.y*lf1.z);\n    \n    float tile = 64.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    \n    float seed = 2.20931;\n    float r = mix(\n        mix(rand(id, seed), rand(id + vec2(1, 0), seed), slv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    r += lf1.x-grain.x;\n    float an = radians(mix(0.0, 90.0, r));\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(cos(an), sin(an))*0.5+0.5;\n    vec2 pp = abs(lv*2.0-1.0);\n    vec2 pa = pp - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float l = clamp(1.0-length(pa - ba * h) / 0.2, 0.0, 1.0);\n    \n    col = mix(col, mix(col*col, g2, grain.y*grain.z*grain.z), (l*grain.y)*max(0.0, 1.0-(dirtReg*2.)));\n    \n    m.spec = clamp((dirtReg*hf1.z)*(0.5+(grain.x*0.5)), 0.0, 1.0);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE rockTexture\n\nvec3 rockTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    float h = xnoise(uv, 203.231, 16.0, 4);\n    grain = (grain+h)/2.;\n    vec3 lf1 = snoiseWarp(uv, 0.032123, 0.5, 4.5, 1.5, 4);\n    vec3 lf2 = snoise(uv, 1.1112312, 0.01, 16.0, 4);\n    \n    vec3 c1 = rgb(106, 104, 105);\n    vec3 c2 = rgb(120, 114, 109);\n    vec3 c3 = rgb(133, 113, 92);\n    vec3 c4 = rgb(83, 81, 75);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    col1 = mix(col1, vec3(1.), lf1.x*lf1.x*h*grain.x);\n    col += col1;\n    \n    float edge = abs(lf2.x*2.0-1.0);\n    edge = max(0.0, 1.0-smoothstep(0.02, 0.09, edge));\n    \n    float scratchReg = edge*lf1.y*h*grain.y;\n    col = mix(col, col*col, scratchReg);\n    \n    m.spec = clamp((1.0-scratchReg)*grain.x, 0.0, 1.0);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE marbleTexture\n\nvec3 marbleTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoiseWarp(uv, 2.244234, 1., 24.0, 0.3, 4);\n    vec3 hf2 = snoiseWarp(uv, 8.727231, 0.3, 20.0, 0.03, 6);\n    vec3 hf3 = snoise(uv, 11.83772244, 0.2, 18.0, 4);\n    \n    vec3 hf4 = snoise(uv, 0.00392123, 0.09, 32.0, 6);\n    \n    \n    \n    vec3 w1 = rgb(247, 247, 247);\n    vec3 w2 = rgb(219, 218, 224);\n    vec3 w3 = rgb(211, 207, 207);\n    vec3 w4 = rgb(217, 207, 195);\n    \n    vec3 bg = mix(mix(mix(w1, w2, hf1.x), w3, hf1.y), w4, hf1.z);\n    col += bg;\n    \n    float edges = max(0.0, 1.0-smoothstep(0.02, 0.1, abs(hf2.x*2.0-1.0)));\n    float edges2 = max(0.0, 1.0-smoothstep(0.02, 0.1, abs(hf3.z*2.0-1.0)));\n    \n    vec3 c1 = rgb(196, 169, 127);\n    vec3 c2 = rgb(247, 178, 191);\n    vec3 c3 = rgb(158, 155, 149);\n    vec3 c4 = rgb(80, 77, 72);\n    \n    float edgeReg = edges2*smoothstep(0.39, 0.8, hf4.x);\n    vec3 pCol = mix(mix(mix(c1, c2, hf3.x), c3, hf3.y), c4, hf3.z);\n    col = mix(col, pCol, edgeReg);\n    col = mix(col, col*col, edges*hf4.z*hf4.y*(0.33+hf1.z));\n    \n    m.spec = clamp((1.0-edgeReg)*hf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    float c = checkerTexture(uv*2., 1.5*(data.d/FAR));\n    return vec3(c);\n}\n\nvec3 getAlbedoBox_1(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv*2.;\n    vec3 col = plankTexture(uv, p, data.m);\n    \n    float e = 0.004;\n    Material m2 = NEW_MATERIAL;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(plankTexture(uv + vec2(e, 0), p, m2)),\n        luma(plankTexture(uv + vec2(0, e), p, m2)),\n        0.6\n    )), 0.01, 0.9);\n    \n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBox_2(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = metalTexture(uv, p, data.m);\n    \n    float e = 0.004;\n    Material m2 = NEW_MATERIAL;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(metalTexture(uv + vec2(e, 0), p, m2)),\n        luma(metalTexture(uv + vec2(0, e), p, m2)),\n        0.52\n    )), 0.01, 0.9);\n    \n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBox_3(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = grassTexture(uv, p, data.m);\n    \n    float e = 0.001+(data.d/FAR);\n    Material m2 = NEW_MATERIAL;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(grassTexture(uv + vec2(e, 0), p, m2)),\n        luma(grassTexture(uv + vec2(0, e), p, m2)),\n        0.34\n    )), 0.01, 0.9);\n    \n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBox_4(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = rockTexture(uv, p, data.m);\n    \n    float e = 0.002+(data.d/FAR);\n    Material m2 = NEW_MATERIAL;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(rockTexture(uv + vec2(e, 0), p, m2)),\n        luma(rockTexture(uv + vec2(0, e), p, m2)),\n        0.44+(data.d/FAR)\n    )), 0.01, 0.9);\n    \n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoBox_5(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = marbleTexture(uv, p, data.m);\n    \n    float e = 0.004;//+(data.d/FAR);\n    Material m2 = NEW_MATERIAL;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(marbleTexture(uv + vec2(e, 0), p, m2)),\n        luma(marbleTexture(uv + vec2(0, e), p, m2)),\n        0.7\n    )), 0.1, 0.9);\n    \n    data.n = bump;\n    \n    return col;\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        \n        case ID_BOX_1: return getAlbedoBox_1(data); break;\n        case ID_BOX_2: return getAlbedoBox_2(data); break;\n        case ID_BOX_3: return getAlbedoBox_3(data); break;\n        case ID_BOX_4: return getAlbedoBox_4(data); break;\n        case ID_BOX_5: return getAlbedoBox_5(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    vec2 uv = rd.xz / rd.y;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    vec3 blue = vec3(0.29, 0.59, 0.9);\n    vec3 col = pow(blue*blue, vec3(1.0 + dotup));\n    \n    return col;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.71), 2.0, LIGHT_AMBIENT);\n    \n    if (march(data, ro, rd)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        \n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd, diffuse);\n        }\n    } else {\n        col += getSky(rd);\n    }\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -4.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if WALK\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    \n    ro += walk;\n    ro.y += fly.y;\n    \n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    #else\n    \n    if (length(m.xy) > 0.0001 && m.z > 0.001) {\n        ro.z += 0.33;\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        ro.z += 2.;\n        ro.x -= 2.5;\n        ro.x = mix(-2.5, 2.5, (0.5+(0.5*cos(T*0.5))));\n        \n        ro.z += (0.5+(0.5*sin((T-1.02982731)*0.5)))*0.5;\n    }\n    #endif\n    \n    ro.y += CAMERA_Y;\n    ro.y = max(CAMERA_Y, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    col /= 1.0 + max(col-0.5, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (skip != id_ && var < dist) { id = id_; dist = var; }\n#define AMBIENT 0.05\nfloat luma(in vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data { vec3 p; vec3 n; vec2 uv; float d; int id; int skip; Material m; };\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n        light.type == LIGHT_POINT ? normalize(light.p - p) : normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, distance(light.p, p))); break;\n        case LIGHT_DIR: {\n            vec3 L2 = normalize(light.p - p);\n            return light.c * NdotL * light.s * smoothstep(0.8, 1.0, dot(L2, L));\n        }; break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.xz, round(adot(n, vec3(0, 1, 0)))), p.zy, round(adot(n, vec3(1, 0, 0))));\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"}]}