{"ver":"0.1","info":{"id":"XcyyWy","date":"1732367099","viewed":24,"name":"FS Random Grid Experiments","username":"GabrieleGiuseppini","description":"Experiments for procedurally creating sparkles in a random grid. Probably will be used in Floating Sandbox as enriching animation when NPCs disappear.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["floatingsandbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat2 GetRotationMatrix(float angle)\n{\n    mat2 m;\n    m[0][0] = cos(angle); m[0][1] = -sin(angle);\n    m[1][0] = sin(angle); m[1][1] = cos(angle);\n\n    return m;\n}\n\nfloat CalculateNoise(vec2 xy, float seed)\n{\n    float PHI = 1.61803398874989484820459;\n    return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n}\n\nfloat CalculateGridSize(float iPhase)\n{\n    #define BASE_GRID_SIZE 0.1\n    return BASE_GRID_SIZE / ((iPhase + 4.) * 0.2);\n}\n\nvec2 CalculateGridCenter(vec2 uv, float gridSize)\n{    \n    vec2 gridCenter = floor(uv / gridSize) * gridSize;\n    vec2 offset = vec2(gridSize / 2.);\n    return offset + gridCenter;\n}\n\nfloat CalculateCellToggle(vec2 gridCenter, float iPhase)\n{\n    //float density = 0.85 - max(iPhase - 10., 0.0) * 0.1;\n    float density = 0.85;\n    \n    vec2 nc = vec2(gridCenter * 77. + sin(iPhase));\n    float n = CalculateNoise(nc, 1.);\n    n = step(density, n);\n\n    return n;\n}\n\nfloat CalculateAlpha(vec2 uv, float iPhase, float paramAspectRatio)\n{\n    // Calculate (random) rotation angle for this phase\n    float angle = (sin(iPhase) + 1.0f) * 3.1415;\n    mat2 rotMatrix = GetRotationMatrix(angle);\n    \n    // Rotate uv coords\n    vec2 uv2 = rotMatrix * uv;\n\n    // Calculate grid center for this pixel\n    float gridSize = CalculateGridSize(iPhase);\n    vec2 gridCenter = CalculateGridCenter(uv2, gridSize);\n    \n    // Convert uv in in-cell coords\n    vec2 uvCell = (uv2 - gridCenter) / (gridSize / 2.);\n    \n    // Now rotate in-cell\n    float angleCell = (sin(iPhase + gridCenter.x * 1000.1 + gridCenter.y * 777.7) + 1.0f) * 3.1415;\n    mat2 rotMatrixCell = GetRotationMatrix(angleCell);\n    uvCell = rotMatrixCell * uvCell;\n    \n    // Calculate alpha - circle\n    //float d = length(uvCell);\n    //float alpha = step(d, .5);\n    \n    // Calculate alpha - star\n    float alpha = 1. - sqrt(abs(uvCell.x) + abs(uvCell.y));\n    \n    // Get toggle for this cell\n    float cellToggle = CalculateCellToggle(gridCenter, iPhase);    \n    alpha *= cellToggle;\n    \n    return alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float paramAspectRatio = iResolution.x / iResolution.y;\n    uv.y /= paramAspectRatio;\n    float paramProgress = iTime;\n    \n    ////////////////////////////////////////////////////////////    \n\n    // Calculate integral phase\n    #define PHASE_DURATION .5\n    float iPhase = floor(paramProgress / PHASE_DURATION);\n    float inPhase = paramProgress / PHASE_DURATION - iPhase;\n    \n    // Calculate alpha for both phases\n    //uv = uv * 2. - vec2(1.);\n    float alpha1 = CalculateAlpha(uv, iPhase, paramAspectRatio);\n    float alpha2 = CalculateAlpha(uv, iPhase + 1., paramAspectRatio);\n    \n    float alpha = mix(alpha1, alpha2, inPhase);\n\n    vec3 col = vec3(1.);\n    \n    \n    ////////////////////////////////////////////////////////////\n    \n    vec3 bgColor = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(\n        mix(\n            bgColor,\n            col,\n            alpha),\n        1.0);\n}","name":"Image","description":"","type":"image"}]}