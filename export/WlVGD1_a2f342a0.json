{"ver":"0.1","info":{"id":"WlVGD1","date":"1578863361","viewed":214,"name":"Orbit Camera","username":"spalmer","description":"a simple mouse controlled lookat orbit camera.  No state buffer needed. Still fine-tuning the camera itself.","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["camera","orbit","lookat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// camera and scene trace code in Common.\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n\tvec2 R = iResolution.xy\n\t, M = iMouse.xy\n\t, q = StoQ(   p, R)\n\t, m = StoQ(M.xy, R);\n\tif (length(M.xy) <= 1.0)\n\t    m = vec2(.2 + .02*iTime,-.15); // unattended, mouse in bottom left corner?\n\tvec3 objectPos = vec3(0, objRadius, 0)\n\t, cameraDir = OrbitCamera(m)\n\t, cameraPos = objectPos - orbitScale * objRadius * cameraDir; // LookAt\n  #if 1 && PLANE\n\tcameraPos.y = max(cameraPos.y, 1e-2); // do not go beneath ground\n\tcameraDir = normalize(objectPos - cameraPos); // redo LookAt after clamp\n  #endif\n\tmat3 cam = CameraMatrix(cameraDir, vec3(0, 1, 0));\n\tconst float hfovy = pi/6.;\n\tvec3 vd = normalize(vec3(q, 1./sin(hfovy)));\n\tvec3 ro = cameraPos, rd = normalize(cam * vd); // view ray\n\tc.rgb = RenderScene(ro, rd, iTime);\n\tc.rgb = pow(c.rgb, vec3(1./2.2));\n\t// dither using blue noise from iChannel3 sampler\n\tc.rgb += .5/256. * (texelFetch(iChannel3, ivec2(mod(p, iChannelResolution[3].xy)), 0).rgb * 2. - 1.);\n\tc.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PLANE 1\n\nconst float\n  pi = acos(-1.)  //3.141592\n, objRadius = 2.  // of object resting on ground to examine\n, orbitScale = 3. // of radius of object objRadius\n, minAngle = -.4  // default full turns angle clamp\n, maxAngle =  .4  // need tweaked in forked toys\n;\n\n// to signed aspect correct uv given screen pixel and resolution\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n\n// build 3x3 camera orientation matrix given forward direction vector\nmat3 CameraMatrix(vec3 camFwd, vec3 camUp)\n{\n\tvec3 w = normalize(camFwd)\n\t   , u = abs(dot(camFwd, camUp)) > 1e-7 \n\t       ? normalize(cross(camUp, w)) \n\t       : w.yzx * vec3(1,1,-1)\n\t   , v = normalize(cross(w, u));\n\treturn mat3(u, v, w);\n}\n// then transform by pw = MC * pv;\n\nvec2 cossin(float rads)\n{\n\treturn vec2(cos(rads), sin(rads));\n}\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    vec2 u = cossin(a.x), v = cossin(a.y);\n    return vec3(u.y*v.x, v.y, u.x*v.x) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in turns\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, minAngle, maxAngle);\n    return sph2cart(vec3(angles * pi, 1.)); // to radians then cartesian\n} // returns forward vector camera aims along\n\n// can use the sphere and plane\n// as bounding and clipping shapes.\n#if PLANE\nfloat tracePlaneY(vec3 ro, vec3 rd)\n{\n    return ro.y <= 0. ? 0. : rd.y >= -5e-3 ? -1. : ro.y / -rd.y;\n}\n#endif\n\n// for an object to rotate around.\n// stripped down rootfinder a bit\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{ // f(t) = dot(f, vec3(1.,vec2(1.,t)*t)) == 0\n    float dsc = .25 * f.y * f.y - f.x * f.z;\n    if (dsc < 0.) return -1.; // no intersection\n\tfloat d = sqrt(dsc);\n\tif (f.y * f.z < 0.) d = -d;\n\treturn (d - .5 * f.y) / f.z;\n} // see also The Quadratic Equation\n// doesn't work in general case anymore;\n// only handles inputs traceBall provides,\n// mishandles ro inside ball, negative radii.\n// inlined traceSphere for radius=1\nfloat traceBall(vec3 ro, vec3 rd)\n{\n\treturn Root(vec3(dot(ro, ro) - 1., 2. * dot(ro, rd), 1.));\n}\n\n// scene trace nearest intersection mechanism to be written here\n// first 2 are inout arguments, last 2 unmodified.\n// macro is to future-proof check of bounding volume etc.\n// do..while provides scope for the temporary and requires trailing semicolon\n#define ConsiderObject(dmin, imin, dobj, iobj) \\\ndo { \\\n  float _dtemp = dobj; \\\n  if (0. <= _dtemp && _dtemp < dmin) \\\n  { dmin = _dtemp; imin = iobj; } \\\n} while (false)\n///\n\n\n// anyway there's no lighting whatsoever.\n// Grid textures are antialiased but objects aren't.\n// none of the graphics are really the point.\nvec3 RenderScene(vec3 ro, vec3 rd, float time)\n{\n    vec3 c = vec3(0.); vec3 op = vec3(0.,objRadius,0.);\n    uint i = 0u; // sky is id 0\n    float d = 1e4; // prep trace scene\n    #if PLANE\n    ConsiderObject(d, i, tracePlaneY(ro, rd), 1u);\n    #endif\n    ConsiderObject(d, i, traceBall((ro - op) / objRadius, rd) * objRadius, 2u);\n    vec3 csky = rd * .5 + .5; //const vec3 csky = vec3(.5, .7, .9); //\n    vec3 hp = ro + d * rd; // hit pos\n    switch (i) {\n        case 0u: { // sky\n            c.rgb = csky, d = 1e4;\n        \tbreak;\n        }\n        #if PLANE\n        case 1u: { // plane\n            //vec2 hp = ro.xz + d * rd.xz; // hit pos\n            // I'd rather just stripe the object in this one\n    \t\tfloat stripe = cos(hp.x) * cos(hp.z); //1.; // 2d grid texture\n            stripe *= stripe; stripe = 1. - stripe; stripe *= stripe;\n            stripe = mix(stripe, .3, min(1., .4*length(fwidth(hp.xz)))); // aa\n        //    if (d == 0.) stripe = sin(time*12.); // beneath? flash\n            c.rgb = vec3(.5*stripe, .5, 0.); // colorize\n        \tbreak;\n        }\n        #endif\n        case 2u: { // sphere\n            hp -= op; //vec3 hp = ro + d * rd - op; \n            hp *= 1.*pi;\n            float stripe = cos(hp.x) * cos(hp.y) * cos(hp.z); // 3d grid texture\n            stripe = 1. - abs(stripe); stripe *= stripe; stripe *= stripe; \n            stripe = mix(stripe, .3, min(1., .4*length(fwidth(hp)))); // aa\n        //    if (d == 0.) stripe = sin(time*12.); // beneath? flash\n            c.rgb = vec3(.5, .25*stripe, 0.); // colorize\n            // TODO antialias silhouette edge!  ;)\n\t        break;\n        }\n        default:\n\t        break;\n    }\n    float dfade = exp2(-.02*d);\n    c.rgb = mix(csky, c.rgb, dfade);\n    return c;\n}\n\n\n#if 0 // unused, but here it is, the inverse of StoQ above:\nvec2 QtoS(vec2 q, vec2 r)\n{\n    return .5 * (q * r.y + r);\n}\n#endif\n\n","name":"Common","description":"","type":"common"}]}