{"ver":"0.1","info":{"id":"NlGyW1","date":"1661339267","viewed":102,"name":"DancingPlanets","username":"wchen","description":"DancingPlanets","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER 100\n#define THRES_CLOSE .01\n#define MAX_TRACE 1000.\n#define FAR_PLANE 510.\n#define NEAR_PLANE 490.\n\nin vec2 fragTexCoord;\nin vec4 fragColor;\n\nvec3 move(vec3 pos, vec3 delta)\n{\n    return pos - delta;\n}\n\nvec4 sdExpand(vec4 sd, float val)\n{\n    return vec4(sd.xyz, sd.w - val);\n}\n\nvec4 sdUnion(vec4 sd1, vec4 sd2)\n{\n    float weight = step(sd1.w, sd2.w);\n    float len = min(sd1.w, sd2.w);\n    vec3 nrm = sd1.xyz * weight + sd2.xyz * (1.-weight);\n    return vec4(nrm, len);\n}\n\nvec4 sdIntersect(vec4 sd1, vec4 sd2)\n{\n    float weight = step(sd2.w, sd1.w);\n    float len = max(sd1.w, sd2.w);\n    vec3 nrm = sd1.xyz * weight + sd2.xyz * (1.-weight);\n    return vec4(nrm, len);\n}\n\nvec4 sdSubstract(vec4 sd, vec4 sub)\n{\n    return sdIntersect(sd, -sub);\n}\n\nvec4 sdPoint(vec3 pos)\n{\n    float len = length(pos);\n    return vec4(pos.xyz/len, len);\n}\n\nvec4 sdCave(vec4 sd, vec3 pos, float x, float y, float z)\n{\n    pos = move(pos, 9.*vec3(sin(x), sin(y), sin(z)));\n    sd = sdSubstract(sd, sdExpand(sdPoint(pos), 4.));\n    return sd;\n}\n\nvec4 sdPlanet(vec4 sd, vec3 pos, float x, float y, float z)\n{\n    pos = move(pos, 9.*vec3(sin(x), sin(y), sin(z)));\n    sd = sdUnion(sd, sdExpand(sdPoint(pos), 1.));\n    return sd;\n}\n\nvec4 sdWorld(vec3 pos)\n{\n    vec4 sd = sdPoint(pos);\n    sd = sdExpand(sd, 8.);\n\n    sd = sdCave(sd, pos, iTime, 1.1*iTime, 1.3*iTime);\n    sd = sdCave(sd, pos, 1.1*iTime, 1.3*iTime, 1.7*iTime);\n    sd = sdCave(sd, pos, 1.3*iTime, 1.7*iTime, 1.9*iTime);\n    sd = sdCave(sd, pos, 1.7*iTime, 1.9*iTime, 2.3*iTime);\n    sd = sdCave(sd, pos, 1.9*iTime, 2.3*iTime, 2.7*iTime);\n\n    sd = sdPlanet(sd, pos, iTime, 1.1*iTime, 1.3*iTime);\n    sd = sdPlanet(sd, pos, 1.1*iTime, 1.3*iTime, 1.7*iTime);\n    sd = sdPlanet(sd, pos, 1.3*iTime, 1.7*iTime, 1.9*iTime);\n    sd = sdPlanet(sd, pos, 1.7*iTime, 1.9*iTime, 2.3*iTime);\n    sd = sdPlanet(sd, pos, 1.9*iTime, 2.3*iTime, 2.7*iTime);\n    return sd;\n}\n\nvec4 march(vec3 pos, vec3 dir)\n{\n    float len;\n    for (int i=0; i<MAX_ITER; ++i)\n    {\n        vec4 sd = sdWorld(pos);\n        pos += sd.w * dir;\n        len += sd.w;\n        if (sd.w < THRES_CLOSE)\n        {\n            return vec4(sd.xyz, len);\n        }\n        else if (len > MAX_TRACE)\n        {\n            return vec4(-dir, MAX_TRACE);\n        }\n    }\n    return vec4(-dir, MAX_TRACE);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 view = (gl_FragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 origin = vec3(0., 00., 500.);\n    vec3 camDir = vec3(0., -.0, -1.);\n    vec3 camUp = vec3(0., 1., 0.);\n\n    camDir = normalize(camDir);\n    vec3 camRight = cross(camUp, camDir);\n    camUp = cross(camDir, camRight);\n\n    float fov = 0.05;\n    vec3 viewDir = camDir + fov * (camUp * view.y + camRight * view.x);\n    vec4 ret = march(origin, viewDir);\n\n    float val = 1.0 - (ret.w - NEAR_PLANE) / (FAR_PLANE - NEAR_PLANE);\n    val = max(val, 0.);\n    val *= .5 + .5*dot(ret.xyz, -viewDir);\n    val = .2 + .8 * val;\n    fragColor = vec4(vec3(uv, .5 + .5 *sin(.2 * iTime)) * val, 1.);\n}","name":"Image","description":"","type":"image"}]}