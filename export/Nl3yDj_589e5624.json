{"ver":"0.1","info":{"id":"Nl3yDj","date":"1660516789","viewed":88,"name":"discrete optical camera","username":"pyrite","description":"This is a reference to make an optical physics based camera easily portable into other scenes. \n\"up\" on the camera sensor is based on the y direction in the scene. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dof","camera","aa","ssaa","ca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 asphere(in vec3 ro, in vec3 rd, in vec3 sp, in float sr){ \n    // geometric solution for analytic ray-sphere intersection\n    vec3 e0 = sp - ro; //vector from ray origin to center of sphere\n    float e1 = dot(e0,rd); //distance from origin of ray to closest point on ray to center of sphere\n    float cr2 = dot(e0,e0) - e1*e1; //square of radius of closest point on ray to center of sphere\n    float cr = sqrt(cr2); //radius of closest point on ray to center of sphere\n    if (cr >= sr) return vec3(9999.9,1.0,1.0/(cr-sr)); //miss 9999.9 distance, 1.0 material, inverse distance\n    //returning misses early saves a sqrt()\n    float sr2 = sr*sr; //square of sphere radius\n    float e2 = sqrt(sr2 - cr2); //distance from closest point of ray to center of sphere to edge of sphere.\n    float st = e1-e2; //shortest distance from ray origin to intersection of ray and sphere\n    if (cr2 < sr2) return vec3(st,0.0,1.0/((cr-sr))); //distance to surface, 0.0 material, inverse distance\n}\n\nvec3 amins(in vec3 s1, in vec3 s2){ //returns vec3 with smallest first element, and sum of inverse distance\n    return (s1.x<s2.x)?vec3(s1.x, s1.y, s1.z+s2.z):vec3(s2.x, s2.y, s1.z+s2.z);\n}\n\nvec3 ascene(in vec3 ro, in vec3 rd){\n    vec3 t = \n        amins(asphere(ro,rd,vec3(0.0,0.0,0.0),1.5),\n        amins(asphere(ro,rd,vec3(-2,0.0,0.0),1.0), \n        amins(asphere(ro,rd,vec3(0.0,-2,0.0),1.0),\n        amins(asphere(ro,rd,vec3(1.15,1.15,1.15),1.0),\n        amins(asphere(ro,rd,vec3(0.0,0.0,-2),1.0),\n        asphere(ro,rd,vec3(3.,3.,3.),0.2)\n        ))))); //length along ray to intersection, material, sum of inverse distance\n    vec3 col = vec3(0.0);\n    /*/\n    if (t.y==0.0) { //if surface is hit calculate color based on surface position\n        vec3 loc = t.x*rd+ro; //ray information to location\n        loc = loc*0.5; //arbitrate scene color scale\n        col = clamp(vec3(loc.x,loc.y,loc.z),0.0,1.0);\n    }\n    //*/\n    /*/\n    else{\n    //*/\n    col = clamp(col+vec3(t.z/(5.0+abs(t.z))),0.0,1.0); //add sigmoid of sum of inverse distances\n    /*/\n    }\n    //*/\n    return col;\n}\n\nvec3 acamera( in vec3 cameraPos, in vec3 cameraDir, in vec2 fragCoord){\n    //THIS v\n    const int lensResolution = 5; //THIS <\n    const int superSample = 2; //THIS <\n    float lensDistance = 1.0; //THIS <\n    float lensDiameter = 0.5; //THIS <\n    float focalDis = 24.0; //THIS <\n    float chromaticAberration = 0.2; //THIS <\n    //THIS ^\n    \n    //fragcoord is the center of the pixel\n\tvec2 sensorLoc = \n        vec2(0.5,0.5*(iResolution.y/iResolution.x))//sets x limits from 0->1, y at same scale, center at (0.5,0.?)\n        - fragCoord.xy / iResolution.x; //reverse sensor and center on (0,0)\n        \n    vec3 trueY = vec3(0.0,1.0,0.0); //useful later could be hardcoded later instead\n    vec3 cameraX = normalize(cross(cameraDir,trueY)); //right dir for camera\n    vec3 cameraY = normalize(cross(cameraX,cameraDir)); //up dir for camera\n    \n    vec3 colorTotal = vec3(0.0);//for each pixel reset the accumulated color\n    float colorCount = 0.0; //keep track of how many color samples are in final sum\n        \n    float sscale = 1.0/(iResolution.x); //size of a pixel\n    float sstep = 1.0/float(superSample); //step for Super Sample Anti Aliasing\n    float sstart = sstep/2.0 - 0.5; //location of first SSAA step\n    \n    float lstep = 1.0/(float(lensResolution)); //step for lens\n    float lstart = lstep/2.0 - 0.5; //location of first lens step\n    \n    //Red Channel\n    float rFocalDis = focalDis*(1.0+chromaticAberration); //adjust focal lenth for red channel based on aberration\n    float rFocal = 1.0+lensDistance/rFocalDis; //adjust focal lenth for red channel based on lens position\n    \n    //Green Channel \n    float gFocalDis = focalDis; //adjust focal lenth for green channel based on aberration\n    float gFocal = 1.0+lensDistance/gFocalDis; //adjust focal lenth for green channel based on lens position\n\n    //Blue Channel\n    float bFocalDis = focalDis*(1.0-chromaticAberration); //adjust focal lenth for blue channel based on aberration\n    float bFocal = 1.0+lensDistance/bFocalDis; //adjust focal lenth for blue channel based on lens position\n    \n    \n    for (float sx = sstart; sx < 0.5; sx += sstep){ //SSAA x direction\n    \tfor (float sy = sstart; sy < 0.5; sy += sstep){ //SSAA y direction\n            \n        \tvec2 ss = vec2(sx,sy)*sscale; //sub pixel offset for SSAA\n            vec3 sensorRel = cameraX*(sensorLoc.x+ss.x) + cameraY*(sensorLoc.y+ss.y); //position on sensor relative to center of sensor. Used once\n            vec3 sensorPos = cameraPos - lensDistance*cameraDir + sensorRel; //3d position of ray1 origin on sensor\n            \t\n            for (float lx = lstart; lx <0.5; lx+=lstep){\n        \t\tfor (float ly = lstart; ly <0.5; ly+=lstep){\n                    \n            \t\tvec2 lensCoord = vec2(lx,ly); //fragCoord analog for lens array. lens is square\n        \t\t\tvec2 lensLoc = (lensCoord)*lensDiameter; //location on 2d lens plane\n            \t\t\n                    if (length(lensCoord)<0.5){ //trim lens to circle\n                        \n                \t\tvec3 lensRel = cameraX*(lensLoc.x) + cameraY*(lensLoc.y); //position on lens relative to lens center. Used twice\n            \t\t\tvec3 lensPos = cameraPos + lensRel; // 3d position of ray1 end and ray2 origin on lens\n            \t\t\tvec3 senlenRay = lensPos - sensorPos; //direction of ray from sensor to lens\n                        \n                        //Red channel\n                        vec3 rRay = senlenRay - rFocal*(lensRel); //direction of ray afer being focused by lens\n                        rRay = normalize(rRay); //normalize after focus\n                        \n                        vec3 red = ascene(lensPos,rRay); //scene returns red\n                        \n                        if(chromaticAberration!=0.0){\n                            //Green channel\n                            vec3 gRay = senlenRay - gFocal*(lensRel); //direction of ray afer being focused by lens\n                            gRay = normalize(gRay); //normalize after focus\n\n                            //Blue channel\n                            vec3 bRay = senlenRay - bFocal*(lensRel); //direction of ray afer being focused by lens\n                            bRay = normalize(bRay); //normalize after focus\n                            \n                            vec3 green = ascene(lensPos,gRay); //scene returns green\n                            vec3 blue = ascene(lensPos,bRay); //scene returns blue\n\n                            colorTotal = colorTotal+vec3(red.r, green.g, blue.b); //sum color over all points from lens\n                        }else{\n                            colorTotal = colorTotal+red;\n                        }\n                        \n                        colorCount += 1.0; //total number of colors added.\n                    }\n                }\n            }\n        }\n    }\n    \n    return colorTotal/colorCount; //return average color value after all rays have been summed. \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float tau = 0.2*iTime - 5.0*iMouse.x/iResolution.x; //tau used to determine camera position\n    \n    vec3 cameraPos = 20.0*vec3(1.0*sin(3.0*tau),1.0*sin(2.0*tau),1.0*cos(3.0*tau)); //this is not normalized\n    vec3 cameraDir = normalize(-cameraPos); //normalized ray from cameraPos to 0,0,0\n    \n    \n    fragColor = vec4(acamera(cameraPos,cameraDir,fragCoord),0.0); //return the color of the pixel on the camera sensor. \n}","name":"Image","description":"","type":"image"}]}