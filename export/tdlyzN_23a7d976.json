{"ver":"0.1","info":{"id":"tdlyzN","date":"1584318114","viewed":151,"name":"Fast PBR Ring System","username":"16807","description":"Click to rotate. To view from the surface, set IS_FIRST_PERSON_POV = true. This scene depicts a ringed earth-size planet 1 AU distance from a sunlike star. It assumes the rings are gaussian distributed mie scatterers with a little absorption.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fast","approximation","analytic","integral","pbr","scatterer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct maybe_int\n{\n    int value;\n    bool exists;\n};\nstruct maybe_float\n{\n    float value;\n    bool exists;\n};\nstruct maybe_vec2\n{\n    vec2 value;\n    bool exists;\n};\nstruct maybe_vec3\n{\n    vec3 value;\n    bool exists;\n};\nstruct maybe_vec4\n{\n    vec4 value;\n    bool exists;\n};\nconst float PI = 3.14159265358979323846264338327950288419716939937510;\nconst float PHI = 1.6180339887;\nconst float BIG = 1e20;\nconst float SMALL = 1e-20;\n\n/*\nGENERIC MATH UTILITY FUNCTIONS\nfunctions not associated to any subject in particular\n*/\n// The error function, integral of exp(-x^2)\nfloat erf(float x)\n{\n    return tanh(1.202760580 * x);\n}\n/*\nMENSURATION\nthis file contains functions for finding perimeters, areas, \nsurface areas, and volumes of primitive shapes\n*/\nfloat get_perimeter_of_circle(\n    in float radius\n) {\n    return 2.*PI*radius;\n}\nfloat get_area_of_circle(\n    in float radius\n) {\n    return PI*radius*radius;\n}\nfloat get_perimeter_of_triangle(\n    in vec2 vertex1,\n    in vec2 vertex2,\n    in vec2 vertex3\n) {\n    return length(vertex1-vertex2) + length(vertex2-vertex3) + length(vertex3-vertex1);\n}\nfloat get_area_of_triangle(\n    in vec2 vertex1,\n    in vec2 vertex2,\n    in vec2 vertex3\n) {\n    // half the magnitude of the cross product\n    return 0.5f * abs((vertex1.x*(vertex2.y-vertex3.y) + vertex2.x*(vertex3.y-vertex1.y)+ vertex3.x*(vertex1.y-vertex2.y)));\n}\nfloat get_surface_area_of_sphere(\n    in float radius\n) {\n    return 4.*PI*radius*radius;\n}\nfloat get_volume_of_sphere(\n    in float radius\n) {\n    return 4./3.*PI*radius*radius*radius;\n}\nfloat get_surface_area_of_tetrahedron(\n    in vec3 vertex1,\n    in vec3 vertex2,\n    in vec3 vertex3,\n    in vec3 vertex4\n) {\n    // each face is half the magnitude of the cross product\n    return 0.5f * (\n        length(cross(vertex1-vertex2, vertex1-vertex3)) +\n        length(cross(vertex1-vertex2, vertex1-vertex4)) +\n        length(cross(vertex1-vertex3, vertex1-vertex4)) +\n        length(cross(vertex2-vertex3, vertex2-vertex4))\n    );\n}\nfloat get_volume_of_tetrahedron(\n    in vec3 vertex1,\n    in vec3 vertex2,\n    in vec3 vertex3,\n    in vec3 vertex4\n) {\n    // 1/6 the volume of a parallelipiped, which is the scalar triple product of its edges\n    return dot(cross(vertex1-vertex2, vertex1-vertex3), vertex1-vertex4) / 6.f;\n}\n// 2D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nbool is_2d_point_in_circle(in vec2 A0, in vec2 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n/*\nA0 point position\nB0 ellipsis center\nR  ellipsis radius along each coordinate axis\n*/\nbool is_2d_point_in_ellipsis(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    return length((A0-B0)/R) < 1.0;\n}\n/*\nA0 point position\nB0 rectangle center\nR  rectangle length along each coordinate axis\n*/\nbool is_2d_point_in_axis_aligned_rectangle(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    return all(lessThan(abs((A0-B0)/R), vec2(1)));\n}\n/*\nA0 point position\nB0 line reference\nN  surface normal of region, normalized\n\nNOTE: in this case, N only needs to indicate the direction facing outside, \n it need not be perfectly normal to B\n*/\nbool is_2d_point_in_region_bounded_by_line(in vec2 A0, in vec2 B0, in vec2 N)\n{\n    return dot(A0-B0, N) < 0.;\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\nbool is_2d_point_in_triangle(in vec2 A0, in vec2 B1, in vec2 B2, in vec2 B3)\n{\n    // INTUITION: if A falls within a triangle,\n    //  the angle between A and any side will always be less than the angle\n    //  between that side and the side adjacent to it\n    vec2 B2B1hat = normalize(B2-B1);\n    vec2 B3B2hat = normalize(B3-B2);\n    vec2 B1B3hat = normalize(B1-B3);\n    return dot(normalize(A0-B1), B2B1hat) > dot(-B1B3hat, B2B1hat)\n        && dot(normalize(A0-B2), B3B2hat) > dot(-B2B1hat, B3B2hat)\n        && dot(normalize(A0-B3), B1B3hat) > dot(-B3B2hat, B1B3hat);\n}\n// 3D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nbool is_3d_point_in_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  radius\n*/\nbool is_3d_point_in_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    return length((A0-B0)/R) < 1.0;\n}\n/*\nA0 point position\nB0 rectangle center\nR  rectangle length along each coordinate axis\n*/\nbool is_3d_point_in_axis_aligned_rectangle(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    return all(lessThan(abs((A0-B0)/R), vec3(1)));\n}\n/*\nA0 point position\nB0 plane reference\nN  vertex normal\n*/\nbool is_3d_point_in_region_bounded_by_plane(in vec3 A0, in vec3 B0, in vec3 N)\n{\n    return dot(A0-B0, N) < 0.;\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\nbool is_3d_point_in_tetrahedron(in vec3 A0, in vec3 B1, in vec3 B2, in vec3 B3, in vec3 B4)\n{\n    // INTUITION: for each triangle, make sure A0 lies on the same side as the remaining vertex\n    vec3 B2xB3 = cross(B2-B1, B3-B1);\n    vec3 B3xB1 = cross(B3-B2, B1-B2);\n    vec3 B1xB2 = cross(B1-B3, B2-B3);\n   return sign(dot(A0-B1, B2xB3)) == sign(dot(B4-B1, B2xB3))\n        && sign(dot(A0-B2, B3xB1)) == sign(dot(A0-B2, B3xB1))\n        && sign(dot(A0-B3, B1xB2)) == sign(dot(A0-B3, B1xB2))\n        ;\n}\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nfloat get_distance_of_2d_point_to_circle(in vec2 A0, in vec2 B0, in float r)\n{\n    return length(A0-B0) - r;\n}\n/*\nA0 point position\nB0 box center\nB  box dimentsions\n*/\nfloat get_distance_of_2d_point_to_rectangle(in vec2 A0, in vec2 B0, in vec2 B)\n{\n  vec2 q = abs(B0) - B;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n/*\nA0 point position\nB0 ellipsis center\nR  ellipsis radius along each coordinate axis\n*/\nfloat guess_distance_of_2d_point_to_ellipsis(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    float u = length((A0-B0)/R);\n    float v = length((A0-B0)/(R*R));\n    return u*(u-1.0)/v;\n}\n/*\nA0 point position\nB0 line reference\nN  surface normal of region, normalized\n\nNOTE: in this case, N only needs to indicate the direction facing outside, \n it need not be perfectly normal to B\n*/\nfloat get_distance_of_2d_point_to_region_bounded_by_line(in vec2 A0, in vec2 B0, in vec2 N)\n{\n    return dot(A0-B0, N);\n}\n// 3D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nfloat get_distance_of_3d_point_to_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) - r;\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nfloat guess_distance_of_3d_point_to_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    vec3 V = A0-B0;\n    float u = length(V/R);\n    float v = length(V/(R*R));\n    return u*(u-1.0)/v;\n}\n/*\nA0 point position\nB0 plane reference\nN  vertex normal\n*/\nfloat get_distance_of_3d_point_to_region_bounded_by_plane(in vec3 A0, in vec3 B0, in vec3 N)\n{\n    return dot(A0-B0, N);\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\n/*\nfloat get_distance_of_3d_point_to_tetrahedron(in vec3 A0, in vec3 B1, in vec3 B2, in vec3 B3, in vec3 B4)\n{\n    // INTUITION: for each triangle, make sure A0 lies on the same side as the remaining vertex\n    vec3 B2xB3 = cross(B2-B1, B3-B1);\n    vec3 B3xB1 = cross(B3-B2, B1-B2);\n    vec3 B1xB2 = cross(B1-B3, B2-B3);\n    return sign(dot(A0-B1, B2xB3)) == sign(dot(B4-B1, B2xB3)) \n        && sign(dot(A0-B2, B3xB1)) == sign(dot(A0-B2, B3xB1)) \n        && sign(dot(A0-B3, B1xB2)) == sign(dot(A0-B3, B1xB2)) \n        ;\n}\n*/\n\n//#include \"precompiled/academics/math/geometry/point_intersection.glsl\"\n\nmaybe_vec2 get_bounding_distances_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_vec2(\n        vec2(\n          max(min(distances_along_line.value.x, distances_along_line.value.y), 0.0),\n          max(distances_along_line.value.x, distances_along_line.value.y)\n        ),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_nearest_distance_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_float(\n        distances_along_line.value.x < 0.0? distances_along_line.value.y :\n        distances_along_line.value.y < 0.0? distances_along_line.value.x :\n        min(distances_along_line.value.x, distances_along_line.value.y),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_distance_along_line_to_union(\n    in maybe_float shape1,\n    in maybe_float shape2\n) {\n    return maybe_float(\n        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),\n        shape1.exists || shape2.exists\n    );\n}\nmaybe_vec2 get_distances_along_line_to_union(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),\n             !shape1.exists ? shape2.value.y : !shape2.exists ? shape1.value.y : max(shape1.value.y, shape2.value.y )),\n        shape1.exists || shape2.exists\n    );\n}\n\nmaybe_vec2 get_distances_along_line_to_negation(\n    in maybe_vec2 positive,\n    in maybe_vec2 negative\n) {\n    /*\n    There are 4 values to consider, two for positive space and two for negative space.\n    In comments, we denoted these values as x+, y+, x-, and y-\n    There are 4*3*2*1 = 24 ways these 4 values could be sequenced along a number line.\n    x variables indicate the start of a region, and y indicate the end of a region,\n    therefore we can ignore sequences where yp<xp and yn<xn.\n    We can see all possible sequences that fulfill this condition using the following code, in python:\n        [A for A in itertools.permutations(['x+','y+','x-','y-']) \n         if A.index('x+') < A.index('y+') and A.index('x-') < A.index('y-')]\n    Combined with flags for whether positive/negative space exists along the ray, \n    This provides us with the following possibilities and their output \n    (asterisks indicate arbitrary values):\n        input               output\n                    exists        exists\n        1  2  3  4  - +     x  y  \n        *  *  *  *  F F     *  *  F\n        *  *  *  *  T F     *  *  F\n        *  *  *  *  F T     x+ y+ T\n        x+ y+ x- y- T T     x+ y+ T\n        x+ x- y+ y- T T     x+ x- T\n        x+ x- y- y+ T T     x+ x- T\n        x- x+ y+ y- T T     *  *  F\n        x- x+ y- y+ T T     y- y+ T\n        x- y- x+ y+ T T     x+ y+ T\n\n    */\n\n    float xp = positive.value.x;\n    float yp = positive.value.y;\n    float xn = negative.value.x;\n    float yn = negative.value.y;\n\n    // as long as intersection with positive exists, \n    // and negative doesn't completely surround it, there will be an intersection\n    if (!positive.exists || (xn < xp && yp < yn && negative.exists)){\n        return maybe_vec2( vec2(xn, xn), false);\n    }\n    else if (!negative.exists || yn < xp){\n        return positive;\n    } \n    else if (xp < xn) {\n        return maybe_vec2( vec2(min(yn, xp), min(xn, yp)), true);\n    }\n    else /*x- x+ y- y+*/{\n        return maybe_vec2( vec2(yn, yp), true);\n    } \n}\n\nmaybe_vec2 get_distances_along_line_to_intersection(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.0;\n    float y = shape1.exists && shape2.exists ? min(shape1.value.y, shape2.value.y ) : 0.0;\n    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);\n}\nfloat get_distance_along_2d_line_nearest_to_point(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0\n){\n    return dot(B0 - A0, A);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\nmaybe_float get_distance_along_2d_line_to_line(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    return maybe_float(\n        length(R) / dot(B, normalize(-R)),\n        abs(abs(dot(A, B)) - 1.0) > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\nmaybe_float get_distance_along_2d_line_to_ray(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && xA > 0.0);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line segment endpoint 1\nB1 line segment endpoint 2\n*/\nmaybe_float get_distance_along_2d_line_to_line_segment(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if 0 < distance < |B2-B1|\n    vec2 B = normalize(B2 - B1);\n    vec2 D = B1 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && 0. < xA && xA < length(B2 - B1));\n}\nmaybe_vec2 get_distances_along_2d_line_to_circle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in float r\n){\n    vec2 D = B0 - A0;\n    float xz = dot(D, A);\n    float z2 = dot(D, D) - xz * xz;\n    float y2 = r * r - z2;\n    float dxr = sqrt(max(y2, 1e-10));\n    return maybe_vec2(vec2(xz - dxr, xz + dxr), y2 > 0.);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\n*/\nmaybe_vec2 get_distances_along_2d_line_to_triangle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2,\n    in vec2 B3\n){\n    maybe_float line1 = get_distance_along_2d_line_to_line_segment(A0, A, B1, B2);\n    maybe_float line2 = get_distance_along_2d_line_to_line_segment(A0, A, B2, B3);\n    maybe_float line3 = get_distance_along_2d_line_to_line_segment(A0, A, B3, B1);\n    return maybe_vec2(\n        vec2(min(line1.value, min(line2.value, line3.value)),\n             max(line1.value, max(line2.value, line3.value))),\n        line1.exists || line2.exists || line3.exists\n    );\n}\nfloat get_distance_along_3d_line_nearest_to_point(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0\n){\n    return dot(B0 - A0, A);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_line(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 C = normalize(cross(B, A));\n    // cross\n    vec3 R = D - dot(D, A) * A - dot(D, C) * C;\n    // rejection\n    return maybe_float(\n        length(R) / -dot(B, normalize(R)),\n        abs(abs(dot(A, B)) - 1.0) > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_ray(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && xA > 0.0);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 line segment endpoint 1\nB2 line segment endpoint 2\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_line_segment(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B1\n){\n    vec3 B = normalize(B1 - B0);\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && 0. < xA && xA < length(B1 - B0));\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 plane reference\nN  plane surface normal, normalized\n*/\nmaybe_float get_distance_along_3d_line_to_plane(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N\n){\n    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 circle origin\nN  circle surface normal, normalized\nr  circle radius\n*/\nmaybe_float get_distance_along_3d_line_to_circle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N,\n    in float r\n){\n    // intersection(plane, sphere)\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    return maybe_float(t.value, is_3d_point_in_sphere(A0 + A * t.value, B0, r));\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\nmaybe_float get_distance_along_3d_line_to_triangle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3\n){\n    // intersection(face plane, edge plane, edge plane, edge plane)\n    vec3 B0 = (B1 + B2 + B3) / 3.;\n    vec3 N = normalize(cross(B1 - B2, B2 - B3));\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    vec3 At = A0 + A * t.value;\n    vec3 B2B1hat = normalize(B2 - B1);\n    vec3 B3B2hat = normalize(B3 - B2);\n    vec3 B1B3hat = normalize(B1 - B3);\n    return maybe_float(t.value,\n        dot(normalize(At - B1), B2B1hat) > dot(-B1B3hat, B2B1hat) &&\n        dot(normalize(At - B2), B3B2hat) > dot(-B2B1hat, B3B2hat) &&\n        dot(normalize(At - B3), B1B3hat) > dot(-B3B2hat, B1B3hat)\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 sphere origin\nR  sphere radius along each coordinate axis\n*/\nmaybe_vec2 get_distances_along_3d_line_to_sphere(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in float r\n){\n    float t = dot(B0 - A0, A);\n    vec3  At = A0 + A*t - B0;\n    float y2 = r*r - dot(At,At);\n    float dxr = sqrt(max(y2, SMALL));\n    return maybe_vec2(\n        vec2(t - dxr, t + dxr),\n        y2 > 0.\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nmaybe_float get_distance_along_3d_line_to_ellipsoid(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 R\n){\n    // NOTE: shamelessly copy pasted, all credit goes to Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 Or = (A0 - B0) / R;\n    vec3 Ar = A / R;\n    float ArAr = dot(Ar, Ar);\n    float OrAr = dot(Or, Ar);\n    float OrOr = dot(Or, Or);\n    float h = OrAr * OrAr - ArAr * (OrOr - 1.0);\n    return maybe_float(\n        (-OrAr - sqrt(h)) / ArAr,\n        h >= 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\nmaybe_float get_distance_along_3d_line_to_tetrahedron(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3,\n    in vec3 B4\n){\n    maybe_float hit1 = get_distance_along_3d_line_to_triangle(A0, A, B1, B2, B3);\n    maybe_float hit2 = get_distance_along_3d_line_to_triangle(A0, A, B2, B3, B4);\n    maybe_float hit3 = get_distance_along_3d_line_to_triangle(A0, A, B3, B4, B1);\n    maybe_float hit4 = get_distance_along_3d_line_to_triangle(A0, A, B4, B1, B2);\n    maybe_float hit;\n    hit = get_distance_along_line_to_union(hit1, hit2);\n    hit = get_distance_along_line_to_union(hit, hit3);\n    hit = get_distance_along_line_to_union(hit, hit4);\n    return hit;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cylinder reference\nB  cylinder direction, normalized\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r\n){\n    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    // implementation shamelessly copied from Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 D = A0 - B0;\n    float BA = dot(B, A);\n    float BD = dot(B, D);\n    float a = 1.0 - BA * BA;\n    float b = dot(D, A) - BD * BA;\n    float c = dot(D, D) - BD * BD - r * r;\n    float h = sqrt(max(b * b - a * c, 0.0));\n    return maybe_vec2(\n        vec2((-b + h) / a, (-b - h) / a),\n        h > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);\n    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);\n    float a_in = min(a1.value, a2.value);\n    float a_out = max(a1.value, a2.value);\n    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);\n    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);\n    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);\n    // TODO: do we need this line?\n    float entrance = max(tube.value.y, a_in);\n    float exit = min(tube.value.x, a_out);\n    return maybe_vec2(\n        vec2(entrance, exit),\n        tube.exists && entrance < exit\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 capsule endpoint 1\nB2 capsule endpoing 2\nr  capsule radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_capsule(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);\n    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);\n    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);\n    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);\n    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);\n    return capsule;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 ring endpoint 1\nB2 ring endpoing 2\nro ring outer radius\nri ring inner radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_ring(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float ro,\n    in float ri\n){\n    maybe_vec2 outer = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ro);\n    maybe_vec2 inner = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ri);\n    maybe_vec2 ring = get_distances_along_line_to_negation(outer, inner);\n    return ring;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\ncosb cosine of cone half angle\n*/\nmaybe_float get_distance_along_3d_line_to_infinite_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float cosb\n){\n    vec3 D = A0 - B0;\n    float a = dot(A, B) * dot(A, B) - cosb * cosb;\n    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);\n    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;\n    float det = b * b - 4. * a * c;\n    if (det < 0.)\n    {\n        return maybe_float(0.0, false);\n    }\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t)\n    {\n        t = t2;\n    }\n    else {\n        t = t1;\n    }\n    vec3 cp = A0 + t * A - B0;\n    float h = dot(cp, B);\n    return maybe_float(t, t > 0. && h > 0.);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\nr  cone radius\nh  cone height\n*/\nmaybe_float get_distance_along_3d_line_to_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r,\n    in float h\n){\n    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));\n    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;\n    cone = get_distance_along_line_to_union(end, cone);\n    return cone;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 cone endpoint 1\nB2 cone endpoint 2\nr1 cone endpoint 1 radius\nr2 cone endpoint 2 radius\n*/\nmaybe_float get_distance_along_3d_line_to_capped_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r1,\n    in float r2\n){\n    float dh = length(B2 - B1);\n    float dr = r2 - r1;\n    float rmax = max(r2, r1);\n    float rmin = min(r2, r1);\n    float hmax = rmax * dr / dh;\n    float hmin = rmin * dr / dh;\n    vec3 B = sign(dr) * normalize(B2 - B1);\n    vec3 Bmax = (r2 > r1? B2 : B1);\n    vec3 B0 = Bmax - B * hmax;\n    vec3 Bmin = Bmax - B * hmin;\n    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);\n    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));\n    float c_h = dot(A0 + cone.value * A - B0, B);\n    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;\n    cone = get_distance_along_line_to_union(cone, end1);\n    cone = get_distance_along_line_to_union(cone, end2);\n    return cone;\n}\n\n/*\nA1 vertex 1 position\nA2 vertex 2 position\nA3 vertex 3 position\n*/\nvec3 get_surface_normal_of_triangle( in vec3 A1, in vec3 A2, in vec3 A3 )\n{\n    return normalize( cross(A2-A1, A3-A1) );\n}\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nvec3 get_surface_normal_of_point_near_sphere( in vec3 A0, in vec3 B0 )\n{\n    return normalize( A0-B0 );\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nvec3 guess_surface_normal_of_point_near_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    vec3  V  = A0-B0;\n    return normalize( V/R );\n}\n/*\nA0 point position\nB0 cylinder reference\nB  cylinder direction, normalized\n*/\nvec3 get_surface_normal_of_point_near_infinite_cylinder( in vec3 A0, in vec3 B0, in vec3 B )\n{\n    // INTUITION: equivalent to the normalized vector rejection\n    vec3 D = A0-B0;\n    return normalize( D - B*dot(D, B) );\n}\n/*\nA0 point position\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\n*/\nvec3 get_surface_normal_of_point_near_cylinder( in vec3 A0, in vec3 B1, in vec3 B2 )\n{\n    vec3 D = A0-B1;\n    vec3 B = normalize(B2-B1);\n    float DB = dot(D,B);\n    return 0.f < DB? -B : DB < length(D)? B : normalize( D-B*DB );\n}\n\n\nfloat get_angular_radius_of_sphere_at_distance(\n\tin float sphere_radius, in float sphere_distance\n){\n\tfloat r = sphere_radius;\n\tfloat h = sphere_distance;\n\t// \"a2\": squared distance to the tangent point, found using pythagorean theorem, \n\t// scaled so hypoteneuse = 1\n\tfloat a2 = 1.0-r*r/(h*h);\n\treturn r * sqrt(a2) / (h * a2);\n}\nfloat get_area_of_intersection_between_circle_and_circle(\n\tin float circle1_radius, in float circle2_radius, in float circle_origin_distance\n){\n\t/*\n\tNOTE: see here for an explanation:\n\thttps://www.xarg.org/2016/07/calculate-the-intersection-area-of-two-circles/\n\t*/\n\tfloat d = circle_origin_distance;\n\tfloat R = max(circle1_radius, circle2_radius);\n\tfloat r = min(circle1_radius, circle2_radius);\n\tif (d>=r+R)\n\t{\n\t\treturn 0.0;\n\t}\n\telse if (d+r<=R)\n\t{\n\t\treturn PI*r*r;\n\t}\n\telse \n\t{\n\t\tconst float EPSILON = 0.000;\n\t\tfloat X = (R*R-r*r+d*d)/(2.0*d);\n\t\tfloat y = sqrt(R*R-X*X);\n\t\tfloat x = abs(d-X);//sqrt(r*r-y*y);\n\t\tfloat theta = asin(y/r);\n\t\tfloat Theta = asin(y/R);\n\t\tfloat a = r*r*theta - x*y;\n\t\tfloat A = R*R*Theta - X*y;\n\t\treturn A + d>=X? a:PI*r*r-a;\n\t}\n}\n/*\nAssumes the light source and occlusion are distant enough that they can be \ntreated as circles on a 2d plane\n*/\nfloat get_fraction_of_sphere_not_occluded_by_sphere(\n\tin vec3 light_destination, in vec3 light_origin, in float light_radius, \n\tin vec3 sphere_origin, in float sphere_radius\n){\n    const float EPSILON = 1e-10;\n\t// direction of light origin from destination\n\tvec3  light_direction  = normalize(light_origin-light_destination);\n\tfloat light_distance   = length(light_origin-light_destination);\n\t// direction of sphere origin from destination\n\tvec3  sphere_direction = normalize(sphere_origin-light_destination);\n\tfloat sphere_distance  = length(sphere_origin-light_destination);\n\tfloat cos_angular_separation = dot(light_direction, sphere_direction);\n\t// angular separation between light and sphere origins when viewed from destination\n    if (cos_angular_separation <= 0.0) return 1.0;\n    if (sphere_distance < sphere_radius) return 0.0;\n\tfloat angular_separation = acos(min(cos_angular_separation, 1.0-EPSILON));\n\tfloat angular_light_radius  = get_angular_radius_of_sphere_at_distance(light_radius, light_distance);\n\tfloat angular_sphere_radius = get_angular_radius_of_sphere_at_distance(sphere_radius, sphere_distance);\n\t// distance between light and sphere origins when viewed from destination, \n\t// treating the two as circles on a 2d plane\n\tfloat angular_distance = 2.0 * tan(angular_separation / 2.0);\n    if(angular_separation>1e20) {return 1.;}\n\tfloat area = get_area_of_intersection_between_circle_and_circle(\n\t\tangular_light_radius, angular_sphere_radius, angular_distance\n\t);\n\treturn 1.0 - area / (PI*angular_light_radius*angular_light_radius);\n}\n\n\n\nconst float DEGREE = 3.141592653589793238462643383279502884197169399/180.;\nconst float RADIAN = 1.;\nconst float KELVIN = 1.;\nconst float MICROGRAM = 1e-9; // kilograms\nconst float MILLIGRAM = 1e-6; // kilograms\nconst float GRAM = 1e-3; // kilograms\nconst float KILOGRAM = 1.; // kilograms\nconst float TON = 1000.; // kilograms\nconst float NANOMETER = 1e-9; // meters\nconst float MICROMETER = 1e-6; // meters\nconst float MILLIMETER = 1e-3; // meters\nconst float METER = 1.; // meters\nconst float KILOMETER = 1000.; // meters\nconst float MOLE = 6.02214076e23;\nconst float MILLIMOLE = MOLE / 1e3;\nconst float MICROMOLE = MOLE / 1e6;\nconst float NANOMOLE = MOLE / 1e9;\nconst float FEMTOMOLE = MOLE / 1e12;\nconst float SECOND = 1.; // seconds\nconst float MINUTE = 60.; // seconds\nconst float HOUR = MINUTE*60.; // seconds\nconst float DAY = HOUR*24.; // seconds\nconst float WEEK = DAY*7.; // seconds\nconst float MONTH = DAY*29.53059; // seconds\nconst float YEAR = DAY*365.256363004; // seconds\nconst float MEGAYEAR = YEAR*1e6; // seconds\nconst float NEWTON = KILOGRAM * METER / (SECOND * SECOND);\nconst float JOULE = NEWTON * METER;\nconst float WATT = JOULE / SECOND;\nconst float EARTH_MASS = 5.972e24; // kilograms\nconst float EARTH_RADIUS = 6.367e6; // meters\nconst float STANDARD_GRAVITY = 9.80665; // meters/second^2\nconst float STANDARD_TEMPERATURE = 273.15; // kelvin\nconst float STANDARD_PRESSURE = 101325.; // pascals\nconst float ASTRONOMICAL_UNIT = 149597870700.;// meters\nconst float GLOBAL_SOLAR_CONSTANT = 1361.; // watts/meter^2\nconst float JUPITER_MASS = 1.898e27; // kilograms\nconst float JUPITER_RADIUS = 71e6; // meters\nconst float SOLAR_MASS = 2e30; // kilograms\nconst float SOLAR_RADIUS = 695.7e6; // meters\nconst float SOLAR_LUMINOSITY = 3.828e26; // watts\nconst float SOLAR_TEMPERATURE = 5772.; // kelvin\n\n\n\nconst float SPEED_OF_LIGHT = 299792458. * METER / SECOND;\nconst float BOLTZMANN_CONSTANT = 1.3806485279e-23 * JOULE / KELVIN;\nconst float STEPHAN_BOLTZMANN_CONSTANT = 5.670373e-8 * WATT / (METER*METER* KELVIN*KELVIN*KELVIN*KELVIN);\nconst float PLANCK_CONSTANT = 6.62607004e-34 * JOULE * SECOND;\n// see Lawson 2004, \"The Blackbody Fraction, Infinite Series and Spreadsheets\"\n// we only do a single iteration with n=1, because it doesn't have a noticeable effect on output\nfloat solve_fraction_of_light_emitted_by_black_body_below_wavelength(\n    in float wavelength,\n    in float temperature\n){\n    const float iterations = 2.;\n    const float h = PLANCK_CONSTANT;\n    const float k = BOLTZMANN_CONSTANT;\n    const float c = SPEED_OF_LIGHT;\n    float L = wavelength;\n    float T = temperature;\n    float C2 = h*c/k;\n    float z = C2 / (L*T);\n    float z2 = z*z;\n    float z3 = z2*z;\n    float sum = 0.;\n    float n2=0.;\n    float n3=0.;\n    for (float n=1.; n <= iterations; n++) {\n        n2 = n*n;\n        n3 = n2*n;\n        sum += (z3 + 3.*z2/n + 6.*z/n2 + 6./n3) * exp(-n*z) / n;\n    }\n    return 15.*sum/(PI*PI*PI*PI);\n}\nfloat solve_fraction_of_light_emitted_by_black_body_between_wavelengths(\n    in float lo,\n    in float hi,\n    in float temperature\n){\n    return solve_fraction_of_light_emitted_by_black_body_below_wavelength(hi, temperature) -\n            solve_fraction_of_light_emitted_by_black_body_below_wavelength(lo, temperature);\n}\n// This calculates the radiation (in watts/m^2) that's emitted \n// by a single object using the Stephan-Boltzmann equation\nfloat get_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    float T = temperature;\n    return STEPHAN_BOLTZMANN_CONSTANT * T*T*T*T;\n}\nvec3 solve_rgb_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    return get_intensity_of_light_emitted_by_black_body(temperature)\n         * vec3(\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(600e-9*METER, 700e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(500e-9*METER, 600e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(400e-9*METER, 500e-9*METER, temperature)\n           );\n}\n// Rayleigh phase function factor [-1, 1]\nfloat get_fraction_of_rayleigh_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    return 3. * (1. + cos_scatter_angle*cos_scatter_angle)\n    / //------------------------\n                (16. * PI);\n}\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nfloat get_fraction_of_mie_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    return (1. - g*g)\n    / //---------------------------------------------\n        ((4. + PI) * pow(1. + g*g - 2.*g*cos_scatter_angle, 1.5));\n}\n// Schlick's fast approximation to the Henyey-Greenstein phase function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nfloat approx_fraction_of_mie_scattered_light_scattered_by_angle_fast(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    const float k = 1.55*g - 0.55 * (g*g*g);\n    return (1. - k*k)\n    / //-------------------------------------------\n        (4. * PI * (1. + k*cos_scatter_angle) * (1. + k*cos_scatter_angle));\n}\n/*\n\"get_fraction_of_microfacets_accessible_to_ray\" is Schlick's fast approximation for Smith's function\n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_accessible_to_ray(\n    in float cos_view_angle,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float v = cos_view_angle;\n    // float k = m/2.0; return 2.0*v/(v+sqrt(m*m+(1.0-m*m)*v*v)); // Schlick-GGX\n    float k = m*sqrt(2./PI); return v/(v*(1.0-k)+k); // Schlick-Beckmann\n}\n/*\n\"get_fraction_of_microfacets_with_angle\" \n  This is also known as the Beckmann Surface Normal Distribution Function.\n  This is the probability of finding a microfacet whose surface normal deviates from the average by a certain angle.\n  see Hoffmann 2015 for a gentle introduction to the concept.\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_with_angle(\n    in float cos_angle_of_deviation,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float t = cos_angle_of_deviation;\n    float m2 = m*m;\n    float t2 = t*t;\n    float u = t2*(m2-1.0)+1.0; return m2/(PI*u*u);\n    //return exp((t*t-1.)/max(m*m*t*t, 0.1))/max(PI*m*m*t*t*t*t, 0.1);\n}\n/*\n\"get_fraction_of_light_reflected_from_facet_head_on\" finds the fraction of light that's reflected\n  by a boundary between materials when striking head on.\n  It is also known as the \"characteristic reflectance\" within the fresnel reflectance equation.\n  The refractive indices can be provided as parameters in any order.\n*/\nfloat get_fraction_of_light_reflected_from_facet_head_on(\n    in float refractivate_index1,\n    in float refractivate_index2\n){\n    float n1 = refractivate_index1;\n    float n2 = refractivate_index2;\n    float sqrtF0 = ((n1-n2)/(n1+n2));\n    float F0 = sqrtF0 * sqrtF0;\n    return F0;\n}\n/*\n\"get_rgb_fraction_of_light_reflected_from_facet\" returns Fresnel reflectance for each color channel.\n  Fresnel reflectance is the fraction of light that's immediately reflected upon striking the surface.\n  It is the fraction of light that causes specular reflection.\n  Here, we use Schlick's fast approximation for Fresnel reflectance.\n  see https://en.wikipedia.org/wiki/Schlick%27s_approximation for a summary \n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for implementation details\n*/\nvec3 get_rgb_fraction_of_light_reflected_from_facet(\n    in float cos_incident_angle,\n    in vec3 characteristic_reflectance\n){\n    vec3 F0 = characteristic_reflectance;\n    float _1_u = 1.-cos_incident_angle;\n    return F0 + (1.-F0) * _1_u*_1_u*_1_u*_1_u*_1_u;\n}\n/*\n\"get_fraction_of_light_reflected_from_material\" is a fast approximation to the Cook-Torrance Specular BRDF.\n  It is the fraction of light that reflects from a material to the viewer.\n  see Hoffmann 2015 for a gentle introduction to the concept\n*/\nvec3 get_fraction_of_light_reflected_from_material(\n    in float NL, in float NH, in float NV, in float HV,\n    in float root_mean_slope_squared,\n    in vec3 characteristic_reflectance\n){\n    float m = root_mean_slope_squared;\n    vec3 F0 = characteristic_reflectance;\n    return 1.0\n        * get_fraction_of_microfacets_accessible_to_ray(NL, m)\n        * get_fraction_of_microfacets_with_angle(NH, m)\n        * get_fraction_of_microfacets_accessible_to_ray(NV, m)\n        * get_rgb_fraction_of_light_reflected_from_facet(HV, F0)\n        / max(4.*PI*NV*NL, 0.001);\n}\n/*\n\"GAMMA\" is the constant that's used to map between \nrgb signals sent to a monitor and their actual intensity\n*/\nconst float GAMMA = 2.2;\n/* \nThis function returns a rgb vector that quickly approximates a spectral \"bump\".\nAdapted from GPU Gems and Alan Zucconi\nfrom https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\n*/\nvec3 get_rgb_intensity_of_rgb_signal(\n    in vec3 signal\n){\n    return vec3(\n        pow(signal.x, GAMMA),\n        pow(signal.y, GAMMA),\n        pow(signal.z, GAMMA)\n    );\n}\n/*\nThis function returns a rgb vector that best represents color at a given wavelength\nIt is from Alan Zucconi: https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\nI've adapted the function so that coefficients are expressed in meters.\n*/\nvec3 get_rgb_signal_of_rgb_intensity(\n    in vec3 intensity\n){\n    return vec3(\n        pow(intensity.x, 1./GAMMA),\n        pow(intensity.y, 1./GAMMA),\n        pow(intensity.z, 1./GAMMA)\n    );\n}\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\nmat4 get_translation_matrix(vec3 offset)\n{\n    return mat4(1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                offset,1);\n}\n// \"approx_air_column_density_ratio_through_atmosphere\" \n//   calculates the distance you would need to travel \n//   along the surface to encounter the same number of particles in the column. \n// It does this by finding an integral using integration by substitution, \n//   then tweaking that integral to prevent division by 0. \n// All distances are recorded in scale heights.\n// \"a\" and \"b\" are distances along the ray from closest approach.\n//   The ray is fired in the positive direction.\n//   If there is no intersection with the planet, \n//   a and b are distances from the closest approach to the upper bound.\n// \"z2\" is the closest distance from the ray to the center of the world, squared.\n// \"r0\" is the radius of the world.\nfloat approx_air_column_density_ratio_through_atmosphere(\n    in float a,\n    in float b,\n    in float z2,\n    in float r0\n){\n    // GUIDE TO VARIABLE NAMES:\n    //  \"x*\" distance along the ray from closest approach\n    //  \"z*\" distance from the center of the world at closest approach\n    //  \"r*\" distance (\"radius\") from the center of the world\n    //  \"*0\" variable at reference point\n    //  \"*2\" the square of a variable\n    //  \"ch\" a nudge we give to prevent division by zero, analogous to the Chapman function\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    const float k = 0.6; // \"k\" is an empirically derived constant\n    float x0 = sqrt(max(r0*r0 - z2, SMALL));\n    // if obstructed by the world, approximate answer by using a ludicrously large number\n    if (a < x0 && -x0 < b && z2 < r0*r0) { return BIG; }\n    float abs_a  = abs(a);\n    float abs_b  = abs(b);\n    float z      = sqrt(z2);\n    float sqrt_z = sqrt(z);\n    float ra     = sqrt(a*a+z2);\n    float rb     = sqrt(b*b+z2);\n    float ch0    = (1. - 1./(2.*r0)) * SQRT_HALF_PI * sqrt_z + k*x0;\n    float cha    = (1. - 1./(2.*ra)) * SQRT_HALF_PI * sqrt_z + k*abs_a;\n    float chb    = (1. - 1./(2.*rb)) * SQRT_HALF_PI * sqrt_z + k*abs_b;\n    float s0     = min(exp(r0- z),1.) / (x0/r0 + 1./ch0);\n    float sa     = exp(r0-ra) / max(abs_a/ra + 1./cha, 0.01);\n    float sb     = exp(r0-rb) / max(abs_b/rb + 1./chb, 0.01);\n    return max( sign(b)*(s0-sb) - sign(a)*(s0-sa), 0.0 );\n}\n\nvec3 get_rgb_fraction_of_light_transmitted_through_atmosphere(\n    in vec3 view_origin, in vec3 view_direction, in float view_start_length, in float view_stop_length,\n    in vec3 world_position, in float world_radius, in float atmosphere_scale_height,\n    in vec3 beta_ray, in vec3 beta_mie, in vec3 beta_abs\n){\n    float h = atmosphere_scale_height;\n    float r = world_radius / h;\n    vec3 V0 = (view_origin + view_direction * view_start_length - world_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - world_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float v0 = dot(V0,V);\n    float v1 = dot(V1,V);\n    float zv2 = dot(V0,V0) - v0*v0;\n    vec3 beta_sum = (beta_ray + beta_mie + beta_abs)*h;\n    float sigma = approx_air_column_density_ratio_through_atmosphere(v0,v1,zv2,r);\n    return exp(-sigma * beta_sum);\n}\n\n#ifndef PROD\n#define ASSERT(test, color) if (!(test)) { return color; }\n#else\n#define ASSERT(test, color)\n#endif\n\n// TODO: multiple scattering events\n// TODO: support for light sources from within atmosphere\nvec3 get_rgb_fraction_of_distant_light_scattered_by_atmosphere(\n    vec3 view_origin, vec3 view_direction, float view_start_length, float view_stop_length,\n    vec3 world_position, float world_radius,\n    vec3 light_direction, float atmosphere_scale_height,\n    vec3 beta_ray, vec3 beta_mie, vec3 beta_abs\n){\n    // For an excellent introduction to what we're try to do here, see Alan Zucconi: \n    //   https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-3/\n    // We will be using most of the same terminology and variable names.\n    // GUIDE TO VARIABLE NAMES:\n    //  Uppercase letters indicate vectors.\n    //  Lowercase letters indicate scalars.\n    //  Going for terseness because I tried longhand names and trust me, you can't read them.\n    //  \"*v*\"    property of the view ray, the ray cast from the viewer to the object being viewed\n    //  \"*l*\"    property of the light ray, the ray cast from the object to the light source\n    //  \"y*\"     distance from the center of the world to the plane shared by view and light ray\n    //  \"z*\"     distance from the center of the world to along the plane shared by the view and light ray \n    //  \"r*\"     a distance (\"radius\") from the center of the world\n    //  \"h*\"     the atmospheric scale height, the distance at which air density reduces by a factor of e\n    //  \"*2\"     the square of a variable\n    //  \"*0\"     property at the start of the raymarch\n    //  \"*1\"     property at the end of the raymarch\n    //  \"*i\"     property during an iteration of the raymarch\n    //  \"d*\"     the change in a property across iterations of the raymarch\n    //  \"beta*\"  a scattering coefficient, the number of e-foldings in light intensity per unit distance\n    //  \"gamma*\" a phase factor, the fraction of light that's scattered in a certain direction\n    //  \"sigma*\" a column density ratio, the density of a column of air relative to surface density\n    //  \"F*\"     fraction of source light that reaches the viewer due to scattering for each color channel\n    //  \"*_ray\"  property of rayleigh scattering\n    //  \"*_mie\"  property of mie scattering\n    //  \"*_abs\"  property of absorption\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h = atmosphere_scale_height;\n    float r = world_radius / h;\n    vec3 V0 = (view_origin + view_direction * view_start_length - world_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - world_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float v0 = dot(V0,V);\n    float v1 = dot(V1,V);\n    vec3 L = light_direction; // unit vector pointing to light source\n    float VL = dot(V,L);\n    // \"gamma_*\" indicates the fraction of scattered sunlight that scatters to a given angle (indicated by its cosine, A.K.A. \"VL\").\n    // It only accounts for a portion of the sunlight that's lost during the scatter, which is irrespective of wavelength or density\n    float gamma_ray = get_fraction_of_rayleigh_scattered_light_scattered_by_angle(VL);\n    float gamma_mie = get_fraction_of_mie_scattered_light_scattered_by_angle(VL);\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3 beta_sum = h*(beta_ray + beta_mie + beta_abs);\n    vec3 beta_gamma = h*(beta_ray * gamma_ray + beta_mie * gamma_mie);\n    // number of iterations within the raymarch\n    const float STEP_COUNT = 6.;\n    float dv = (v1 - v0) / STEP_COUNT;\n    float vi = v0;\n    float dl = dv*VL;\n    float li = dot(V0,L);\n    float y  = dot(V0,normalize(cross(V,L)));\n    float y2 = y*y;\n    float zv2 = dot(V0,V0) - y2 - v0*v0;\n    float zl2 = 0.0;\n    float sigma; // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3 F = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        zl2 = vi*vi + zv2 - li*li;\n        sigma = approx_air_column_density_ratio_through_atmosphere(v0, vi, y2+zv2, r )\n              + approx_air_column_density_ratio_through_atmosphere(li, 3.*r, y2+zl2, r );\n        F += exp(r-sqrt(vi*vi+y2+zv2) - beta_sum*sigma) * beta_gamma * dv;\n            // NOTE: the above is equivalent to the incoming fraction multiplied by the outgoing fraction:\n            // incoming fraction: the fraction of light that scatters towards camera\n            //   exp(r-sqrt(vi*vi+y2+zv2)) * beta_gamma * dv\n            // outgoing fraction: the fraction of light that scatters away from camera\n            // * exp(-beta_sum * sigma);\n        vi += dv;\n        li += dl;\n    }\n    return F;\n}\n\n/*\n\"approx_fast_column_density_ratio_through_ring_system\" \n  calculates the distance you would need to travel \n  along the center of a ring system to encounter the same number of particles \n  in the specified column. \nIt does this by assuming a Gaussian density distribution \n when travelling in the direction that's perpendicular to the ring.\nAll distances are recorded in scale heights.\n\"a\" and \"b\" are distances along the ray from closest approach.\n  The ray is fired in the positive direction.\n\"m\"  is the \"slope\", the distance travelled parallel to the ring\n  per unit traveled perpendicular to the ring.\n*/\nfloat approx_fast_column_density_ratio_through_ring_system(\n    in float a,\n    in float b,\n    in float m\n){\n    return m*sqrt(PI)*(erf(b) - erf(a));\n}\nvec3 get_rgb_fraction_of_light_transmitted_through_ring_system(\n    in vec3 view_origin, in vec3 view_direction, in float view_start_length, in float view_stop_length,\n    vec3 ring_origin, vec3 ring_direction, float ring_scale_height, \n    in vec3 beta_ray, in vec3 beta_mie, in vec3 beta_abs\n){\n    float h   = ring_scale_height;\n    vec3  B0  = ring_origin/h;\n    vec3  B   = ring_direction;\n    vec3  D   = (view_direction * (view_stop_length - view_start_length)) / h; \n    vec3  V0  = (view_origin + view_direction * view_start_length - ring_origin) / h; \n    vec3  V1  = (view_origin + view_direction * view_stop_length  - ring_origin) / h;\n    vec3  V   = view_direction;   // unit vector pointing to viewer\n\n    float v02d = dot(V0,B);\n    float v12d = dot(V1,B);\n    float mv  = sqrt(1.-dot(V,B)*dot(V,B));\n    vec3  beta_sum   = h*(beta_ray + beta_mie + beta_abs);\n    float sigma = approx_fast_column_density_ratio_through_ring_system(v02d, v12d,  mv);\n    return exp(-sigma * beta_sum);\n}\n\nvec3 get_rgb_fraction_of_distant_light_scattered_by_ring_system(\n    vec3 view_origin, vec3 view_direction, float view_start_length, float view_stop_length,\n    vec3 ring_origin, vec3 ring_direction, float ring_scale_height,\n    vec3 light_direction, vec3 beta_ray, vec3 beta_mie, vec3 beta_abs\n){\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h   = ring_scale_height;\n    vec3  B0  = ring_origin/h;\n    vec3  B   = ring_direction;\n    vec3  L   = light_direction;  // unit vector pointing to light source\n    vec3  D   = (view_direction * (view_stop_length - view_start_length)) / h; \n    vec3  V0  = (view_origin + view_direction * view_start_length - ring_origin) / h; \n    vec3  V1  = (view_origin + view_direction * view_stop_length  - ring_origin) / h;\n    vec3  V   = view_direction;   // unit vector pointing to viewer\n    float VL  = dot(V,L);\n\n    // \"gamma_*\" indicates the fraction of scattered sunlight that scatters to a given angle (indicated by its cosine, A.K.A. \"VL\").\n    // It only accounts for a portion of the sunlight that's lost during the scatter, which is irrespective of wavelength or density\n    float gamma_ray = get_fraction_of_rayleigh_scattered_light_scattered_by_angle(VL);\n    float gamma_mie = get_fraction_of_mie_scattered_light_scattered_by_angle(VL);\n\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3  beta_sum   = h*(beta_ray + beta_mie + beta_abs);\n    vec3  beta_gamma = h*(beta_ray * gamma_ray + beta_mie * gamma_mie);\n    \n    // number of iterations within the raymarch\n    const float STEP_COUNT = 8.; \n    float dv  = length(V1-V0) / STEP_COUNT;\n    float vi  = 0.;\n    float dl  = dv*VL;\n\n    float v02d = dot(V0,B);\n    float v12d = dot(V1,B);\n    float mv   = sqrt(1.-dot(V,B)*dot(V,B));\n    float ml   = sqrt(1.-dot(L,B)*dot(L,B));  \n    float sigma;       // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3  F = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        vec3  Vi   = V0+V*vi; \n        \n        float vi2d = dot(Vi,B);\n        float li2d = dot(Vi,B*sign(dot(B,L)));\n        \n        ///*\n        sigma =  approx_fast_column_density_ratio_through_ring_system(v02d, vi2d,  mv)\n               + approx_fast_column_density_ratio_through_ring_system(li2d, 1e10, ml);\n        //*/\n        /*\n        sigma =  solve_air_column_density_ratio_through_ring_system(v02d, vi2d,  mv)\n               + solve_air_column_density_ratio_through_ring_system(li2d, 3.*ri, ml);\n        */\n        F +=\n            // incoming fraction: the fraction of light that scatters towards camera\n              exp(-vi2d*vi2d) * beta_gamma * dv\n            // outgoing fraction: the fraction of light that scatters away from camera\n            * exp(-beta_sum * sigma);\n\n        vi += dv;\n        //li += dl;\n    }\n\n    return F;\n}\nvec3 get_rgb_fraction_of_light_transmitted_through_scene(vec3 L0, vec3 L)\n{\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = 6e6; // arbitrary reference units, used to scale down the scene to work within precision limitations\n\n    // world\n    vec3  B0  = vec3(0,0,0)/u;// center of the world\n    float hB  = 8000.0/u;     // scale height of the world\n    float rB0 = 6e6/u;        // surface of the world\n    float rB1 = rB0+10.0*hB;  // \"top\" of the atmosphere\n    \n    // rings\n    vec3  C   = vec3(0,1,0); // direction of the rings\n    float rCi =   8e6 /u;    // inner radius of the rings\n    float rCo = 1.5e7 /u;    // outer radius of the rings\n    float hC  =  10.0 /u;    // scale height of the rings (assuming Gaussian density distribution)\n    float hC1 =  10.0*hC;    // half the total \"width\" of the rings\n\n    vec2 mouse = vec2(iMouse.xy) / vec2(iResolution.xy);\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,\n                                            0,0.3,0,0,\n                                            0,0,0,-50,\n                                            0,0,-1,50));\n    \n    bool IS_FIRST_PERSON_POV = false;\n    mat4  view_matrix_inverse;\n    if(IS_FIRST_PERSON_POV){\n        vec3 position = normalize(vec3(-5,1,0))*rB0*1.001;\n        vec3 up    = normalize(position);\n        vec3 right = vec3(0,1,0);\n        vec3 front = normalize(cross(up, right));\n        view_matrix_inverse = \n            get_translation_matrix(-position) *\n            get_rotation_matrix(up, -3.0*PI*mouse.x) * \n            get_rotation_matrix(right, PI/2.0-PI*mouse.y) * \n            inverse(mat4(vec4(right,0), vec4(up,0), vec4(front,0), vec4(0,0,0,1)));\n    } else {\n        view_matrix_inverse = \n            get_rotation_matrix(vec3(0,1,0), 6.3*mouse.x) * \n            get_rotation_matrix(vec3(1,0,0), PI/2.0+PI*(mouse.y)) *\n            get_translation_matrix(vec3(0,0,6.0*rB0)) *\n            mat4(1);\n    }\n    \n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz;\n\n    vec3  I =   solve_rgb_intensity_of_light_emitted_by_black_body(SOLAR_TEMPERATURE) \n              * get_surface_area_of_sphere(SOLAR_RADIUS) / get_surface_area_of_sphere(ASTRONOMICAL_UNIT); // intensity of incoming light for each color channel\n    vec3  E = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    \n\n    // view ray\n    vec3 V0 = view_origin;\n    vec3 V  = view_direction;\n    vec3 Vi = V0;            // point along view ray\n    \n    // light ray\n    // static\n    //vec3 L  = normalize(vec3(1,0,0)); \n    // daylight hours only\n    vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.1*PI*sin(0.1*iTime)) * vec4(normalize(vec3(3,1,0)),1)).xyz;\n    // realistic\n    //vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.1*iTime) * vec4(1,0,0,1)).xyz;\n\n    // \"beta_*\" is the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio\n    vec3  beta_ray_air   = vec3(5.20e-6, 1.21e-5, 2.96e-5) * u;\n    vec3  beta_mie_air   = vec3(1e-6)*u;\n    vec3  beta_abs_air   = vec3(0)*u;\n    vec3  beta_ray_ring  = vec3(0)*u;\n    vec3  beta_mie_ring  = vec3(1e-2)*u;\n    vec3  beta_abs_ring  = vec3(1,1,2)*1e-2*u;\n\n    maybe_vec2 world_along_view_ray = \n        get_bounding_distances_along_ray(\n            get_distances_along_3d_line_to_sphere(V0, V, B0, rB0)\n        );\n        \n    maybe_float world_ahead_on_view_ray = \n        get_nearest_distance_along_ray(\n            world_along_view_ray\n        );\n        \n    maybe_vec2  air_along_view_ray  = \n        get_bounding_distances_along_ray(\n            get_distances_along_line_to_negation(\n                get_distances_along_3d_line_to_sphere(V0, V, B0, rB1),\n                world_along_view_ray\n            )\n        );\n        \n    maybe_vec2 rings_along_view_ray = \n        get_bounding_distances_along_ray(\n            get_distances_along_line_to_negation(\n                get_distances_along_3d_line_to_cylinder(V0, V, B0-hC1*C, B0+hC1*C, rCo),\n                 get_distances_along_3d_line_to_cylinder(V0, V, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n            )\n        );\n    \n    if(!air_along_view_ray.exists && !world_along_view_ray.exists && !rings_along_view_ray.exists) \n    { \n        // nothing to see here folks, move along\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    \n    if(world_ahead_on_view_ray.exists){\n        vec3 Vt = V0+V*(world_ahead_on_view_ray.value-0.001);\n        maybe_vec2 air_along_light_ray = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_sphere(Vt, L, B0, rB1),\n                    get_distances_along_3d_line_to_sphere(Vt, L, B0, rB0)\n                )\n            );\n        maybe_vec2 rings_along_light_ray = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_cylinder(Vt, L, B0-hC1*C, B0+hC1*C, rCo),\n                    get_distances_along_3d_line_to_cylinder(Vt, L, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n                )\n            );\n        maybe_vec2 world_along_light_ray = \n            get_bounding_distances_along_ray(\n                get_distances_along_3d_line_to_sphere(Vt, L, B0, rB0)\n            );\n        \n        vec3 I_surface = I;\n        if (air_along_light_ray.exists)\n        {\n            I_surface *= get_rgb_fraction_of_light_transmitted_through_atmosphere(Vt,L, air_along_light_ray.value.x, air_along_light_ray.value.y, B0, rB0, hB, beta_ray_air, beta_mie_air, beta_abs_air);\n        }\n        if (rings_along_light_ray.exists)\n        {\n            I_surface *= get_rgb_fraction_of_light_transmitted_through_ring_system(Vt,L, rings_along_light_ray.value.x, rings_along_light_ray.value.y, B0, C, hC, beta_ray_ring, beta_mie_ring, beta_abs_ring);\n        }\n        \n        vec3 N = get_surface_normal_of_point_near_sphere(Vt, B0);\n        vec3 H = normalize(L-V);\n        float NV = max(dot(N,-V), 0.);\n        float NL = max(dot(N, L), 0.);\n        float NH = max(dot(N, H), 0.);\n        float HV = max(dot(H,-V), 0.);\n        float VL = max(dot(L,-V), 0.);\n        vec3 E_surface_ambient = vec3(1,1,1)/255.; // surface ambient light\n        vec3 F_surface_diffuse = vec3(0.4,0.4,0.3); // diffuse surface color\n        \n        E += E_surface_ambient;\n        if (NL > 0.) //!world_along_light_ray.exists \n        {\n            const vec3 F0  = vec3(0.04); // NOTE: \"0.04\" is a representative value for plastics and other diffuse reflectors\n            const float m = 3.0;\n            vec3 F_reflected = get_fraction_of_light_reflected_from_material(NL,NH,NV, HV, m,F0);\n            vec3 E_surface_reflected = I_surface * NL * F_reflected;\n            vec3 I_surface_refracted = I_surface * NL * (1. - F_reflected);\n            vec3 E_surface_refracted = I_surface_refracted * F_surface_diffuse;\n            E += E_surface_reflected + E_surface_refracted;\n        }\n    }\n    if(air_along_view_ray.exists && (air_along_view_ray.value.x < world_ahead_on_view_ray.value || !world_ahead_on_view_ray.exists))\n    {\n        vec3 Vt0 = V0+V*(air_along_view_ray.value.x);\n        vec3 Vt1 = V0+V*(air_along_view_ray.value.y);\n        maybe_vec2 rings_along_light_ray0 = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_cylinder(Vt0, L, B0-hC1*C, B0+hC1*C, rCo),\n                    get_distances_along_3d_line_to_cylinder(Vt0, L, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n                )\n            );\n        maybe_vec2 rings_along_light_ray1 = \n            get_bounding_distances_along_ray(\n                get_distances_along_line_to_negation(\n                    get_distances_along_3d_line_to_cylinder(Vt1, L, B0-hC1*C, B0+hC1*C, rCo),\n                    get_distances_along_3d_line_to_cylinder(Vt1, L, B0-2.*hC1*C, B0+2.*hC1*C, rCi)\n                )\n            );\n        vec3 I_entrance = I;\n        if (rings_along_light_ray0.exists || rings_along_light_ray1.exists)\n        {\n            vec3 F0 = !rings_along_light_ray0.exists? vec3(0.0) : get_rgb_fraction_of_light_transmitted_through_ring_system(Vt0,L, rings_along_light_ray0.value.x, rings_along_light_ray0.value.y, B0, C, hC, beta_ray_ring, beta_mie_ring, beta_abs_ring);\n            vec3 F1 = !rings_along_light_ray1.exists? vec3(0.0) : get_rgb_fraction_of_light_transmitted_through_ring_system(Vt1,L, rings_along_light_ray1.value.x, rings_along_light_ray1.value.y, B0, C, hC, beta_ray_ring, beta_mie_ring, beta_abs_ring);\n            \n            I_entrance *= (F0+F1)/2.;\n        }\n        \n        \n        float v0 = air_along_view_ray.value.x;\n        float v1 = air_along_view_ray.value.y;\n        E *= get_rgb_fraction_of_light_transmitted_through_atmosphere(V0,V, air_along_view_ray.value.x,  air_along_view_ray.value.y,  B0, rB0*0.999, hB, beta_ray_air, beta_mie_air, beta_abs_air);\n        E += I_entrance * get_rgb_fraction_of_distant_light_scattered_by_atmosphere(\n            V0, V, v0, v1, \n            B0, rB0, L, hB, \n            beta_ray_air, beta_mie_air, beta_abs_air\n        );\n        \n    }\n    \n    if(rings_along_view_ray.exists && (rings_along_view_ray.value.x < world_ahead_on_view_ray.value || !world_ahead_on_view_ray.exists))\n    {\n        vec3 Vt = V0+V*(rings_along_view_ray.value.x);\n        float v0 = rings_along_view_ray.value.x;\n        float v1 = rings_along_view_ray.value.y;\n        \n        float F_occluded = get_fraction_of_sphere_not_occluded_by_sphere(\n            Vt, L*ASTRONOMICAL_UNIT/u, SOLAR_RADIUS/u, B0, rB0\n        );\n        E += I * F_occluded *get_rgb_fraction_of_distant_light_scattered_by_ring_system(\n            V0, V, v0, v1, \n            B0, C, hC, \n            L, beta_ray_ring, beta_mie_ring, beta_abs_ring\n        );\n    }\n    \n    //fragColor = world_along_view_ray.exists? vec4(vec3(1),1) : vec4(vec3(0),1);\n    float exposure_intensity = 40.; // Watts/m^2\n    vec3  ldr_tone_map = 1.0 - exp(-E/exposure_intensity);\n\n    fragColor = vec4(get_rgb_signal_of_rgb_intensity(ldr_tone_map), 1);\n    //if((E.x==0.)){fragColor.x = 1.0;} else {fragColor.x=0.0;}\n\n}","name":"Image","description":"","type":"image"}]}