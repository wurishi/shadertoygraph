{"ver":"0.1","info":{"id":"XtSGWV","date":"1432300932","viewed":339,"name":"XOR pattern experiment","username":"104","description":"Exploring the different ways to generate periodic functions: sin(), mod(), and fract(), and having a bit of fun","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","xor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const int iterationCount = 9;\n\n// square method\n// 1 = mod()\n// 2 = sin()\n// 3 = fract()\n#define SQUARE_METHOD 3\n\n// it turns out that the 3 methods here really have no performance difference\n// set iterationCount to 1000 and change the method.\n\n//--------------------------------------------------------\n\nconst float pi = 3.14159;\nconst float pi2 = 2. * 3.14159;\n\n// c64 palette because why not.\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\n\nfloat saturate(float a)\n{\n    return clamp(a,0.,1.);\n}\nvec2 saturate(vec2 a)\n{\n    return clamp(a,0.,1.);\n}\nvec3 saturate(vec3 a)\n{\n    return clamp(a,0.,1.);\n}\n\n\n#if SQUARE_METHOD == 1\nfloat square(float x, float period)\n{\n    // using mod()+sign().\n    // my feeling is that this is the fastest method, but it makes no difference.\n    return sign(mod(x, period)-(period/2.0));\n}\n#endif\n#if SQUARE_METHOD == 2\nfloat square(float x, float period)\n{\n    // using sin() is obvious\n    return sign(sin(x / period * pi2));\n}\n#endif\n#if SQUARE_METHOD == 3\nfloat square(float x, float period)\n{\n    // this is clever, but is not faster.\n    float ret = x / (period);// now fractional part is the mod.\n    ret = fract(ret);// now it's 0-1 in the period.\n    ret -= 0.5;\n    return sign(ret);\n}\n#endif\n\n\n\n\nvec3 getPalette(int i)\n{\n    if(i == 0) return color6;\n    if(i == 1) return color3;\n    if(i == 2) return color5;\n    if(i == 3) return color9;\n    if(i == 4) return color7;\n    return color8;\n}\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.y * 2.0) - 1.0;// -1 to 1\n\n    // warp & rotate for fun\n    float someCycleThing = sin(iTime * 1.2) * 0.5;\n    float angle = (1.3 * sin(((uv.x * someCycleThing) + 2.1) * ((uv.y * someCycleThing) + 2.2) * 0.2)) + sin(iTime * 0.22) * cos(iTime * 0.5);\n    uv = rot2D(angle) * uv;\n\n    // set up some variables for iteration. the main goal is to calculate 'color'\n    // by iteratively mixing colors on it.\n    vec3 color = colorE;\n    float mixAmt = 1.0;// influence of iteration\n    float tileSize = 5.0;\n    for(int i = 0; i < iterationCount; ++ i)\n    {\n       \tfloat z = square(uv.x, tileSize) * square(uv.y, tileSize);\n        z = (z+1.0)/2.0;// make 0-1 range\n      \tcolor = mix(color, getPalette(i), mixAmt * z);\n        tileSize /= 2.;\n        mixAmt /= 1.25;\n\t}\n    fragColor = vec4(color,1.0);\n    \n    // brighten\n\tfragColor.rgb *= 2.1;\n    \n    // add a little vignette\n    float va = distance(fragCoord, iResolution.xy / 2.0) / max(iResolution.x, iResolution.y);\n    va = pow(va, 0.96);\n    va = 1.0 - va;\n\tfragColor.rgb = saturate(fragColor.rgb * va);\n    \n\t//if(length(uv)<.05) fragColor = vec4(1.0);// show a dot at (0,0)\n}\n\n","name":"","description":"","type":"image"}]}