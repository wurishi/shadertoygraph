{"ver":"0.1","info":{"id":"wtSfR3","date":"1599456798","viewed":153,"name":"Outline Post","username":"Stephen_epa","description":"outline post-processing algorithm","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sobel","postprocessing","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// do edge checker\nfloat depthChecker(vec3 s012, vec3 s345, vec3 s678) {\n    return abs(s012.x - s678.z) +\n           abs(s012.z - s678.x) +\n           abs(s345.x - s345.z) +\n           abs(s012.y - s678.y);\n}\n\nfloat normalChecker(vec3 s0, vec3 s1, vec3 s2,\n                    vec3 s3, vec3 s4, vec3 s5,\n                    vec3 s6, vec3 s7, vec3 s8) {\n    return max(0., 1. - dot(s0, s8)) +\n           max(0., 1. - dot(s2, s6)) +\n           max(0., 1. - dot(s3, s5)) +\n           max(0., 1. - dot(s1, s7));\n}\n\n#define DEPTH_SCALE 1.5\nfloat edgeChecker(sampler2D tex, vec2 uv) {\n    vec3 e = vec3(1, 0, -1);\n    vec2 ps = 1./iResolution.xy;\n    vec4 s0 = texture(tex, uv + e.zx * ps);\n    vec4 s1 = texture(tex, uv + e.yx * ps);\n    vec4 s2 = texture(tex, uv + e.xx * ps);\n    vec4 s3 = texture(tex, uv + e.zy * ps);\n    vec4 s4 = texture(tex, uv + e.yy * ps);\n    vec4 s5 = texture(tex, uv + e.xy * ps);\n    vec4 s6 = texture(tex, uv + e.zz * ps);\n    vec4 s7 = texture(tex, uv + e.yz * ps);\n    vec4 s8 = texture(tex, uv + e.xz * ps);\n    return depthChecker(vec3(s0.a, s1.a, s2.a), \n                        vec3(s3.a, s4.a, s5.a),\n                        vec3(s6.a, s7.a, s8.a)) * DEPTH_SCALE +\n           normalChecker(s0.rgb, s1.rgb, s2.rgb,\n                         s3.rgb, s4.rgb, s5.rgb,\n                         s6.rgb, s7.rgb, s8.rgb);\n}\n\n// image based edge detection\n// kernel\n//\t\t [1 0 -1]\t\t  [ 1  2  1]\t\n//\tGx = [2 0 -2]    Gy = [ 0  0  0] \n//\t\t [1 0 -1]\t      [-1 -2 -1]\n//\nvec3 sobel(sampler2D tex, vec2 uv) {\n    vec3 Gx = vec3(0.);\n    vec3 Gy = vec3(0.);\n    vec3 e = vec3(0., 1., -1.);\n    vec2 ps = 1./iResolution.xy;\n    Gx += texture(tex, uv + ps * e.zz).rgb * 1.;\n    Gx += texture(tex, uv + ps * e.zx).rgb * 2.;\n    Gx += texture(tex, uv + ps * e.zy).rgb * 1.;\n\n    Gx += texture(tex, uv + ps * e.yy).rgb * -1.;\n    Gx += texture(tex, uv + ps * e.yx).rgb * -2.;\n    Gx += texture(tex, uv + ps * e.yz).rgb * -1.;\n    \n    Gy += texture(tex, uv + ps * e.zy).rgb * 1.;\n    Gy += texture(tex, uv + ps * e.xy).rgb * 2.;\n    Gy += texture(tex, uv + ps * e.yy).rgb * 1.;\n\n    Gy += texture(tex, uv + ps * e.zz).rgb * -1.;\n    Gy += texture(tex, uv + ps * e.xz).rgb * -2.;\n    Gy += texture(tex, uv + ps * e.yz).rgb * -1.;\n    \n    return sqrt(Gx*Gx + Gy*Gy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    float edge = 0.;\n    float splitx = 0.5;\n    if (iMouse.z > 0.)\n    \tsplitx = muv.x;\n    if (uv.x < splitx) {\n        vec3 sb = sobel(iChannel0, uv);\n    \tedge = step(max(sb.x, max(sb.y, sb.z)), .5);\n    } else {\n        edge = step(edgeChecker(iChannel0, uv), .5);\n    }\n    \n\n    float f = fract(iTime * .3);\n    f = max(f - .5, 0.0);\n    f = f*f*(3.-2.*f);\n    if (uv.x < splitx)\n        col = vec3(edge);\n    else\n    \tcol = mix(vec3(edge), edge * texture(iChannel0, uv).rgb, f);    \n\n    col = mix(col, vec3(0.), step(abs(uv.x - splitx), 0.001));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define stepsize 50\n#define maxdistant 120.0\n\n// -------------------- sdf stuff ------------------\nfloat sdfSp(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdfBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// --------------------------------------------end\n\n// scene description\nfloat map(vec3 p) {\n    vec3 region = vec3(2., 0., 2.);\n    p = mod(p + .5 * region, region) - .5 * region;\n    return sdfBox(p, vec3(.6));\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nvoid lookAt(inout vec3 ro, inout vec3 rd, vec3 tg) {\n    vec3 ot = normalize(tg - ro);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 rr = normalize(cross(ot, up));\n    up = normalize(cross(rr, ot));\n    rd = mat3(rr, up, ot) * rd;\n}\n\nfloat march(vec3 o, vec3 d) {\n    float total = 0.;\n    float ep = 0.0001;\n    vec3 np = o;\n    for (int i = 0; i < stepsize; ++i) { \n        float dt = map(np);\n        if (dt <= ep || total > maxdistant) break;\n        np = np + dt * d;\n        total += dt;\n    }\n    if (total >= maxdistant) return maxdistant;\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n\tvec2 muv = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0., 3.6, 3.);\n    vec3 rd = vec3(uv, 1.2);\n    rd = normalize(rd);\n    \n    lookAt(ro, rd, vec3(.0));\n    float d = march(ro, rd);\n    vec3 p = ro + d * rd;\n    \n    vec3 col = calcNormal(p);\n    fragColor = vec4(col,max(d / maxdistant, 0.0));\n}","name":"Buffer A","description":"","type":"buffer"}]}