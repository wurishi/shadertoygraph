{"ver":"0.1","info":{"id":"cdSGDK","date":"1668101583","viewed":89,"name":"quadric - AO/AA idea","username":"slimsag","description":"Proof of concept for rendering a single quadric surface with quadric bounds. The surface is found as the ray-quadric intersection and then bounds tested against the second quadric. The surface normal is found from the gradient of the first quadric. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["quadric"],"hasliked":0,"parentid":"Dd23Rd","parentname":"Bounded quadric surface"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The surface is at pᵀQp = 0\n// This encodes the equation x² + y² + 2z² = 1\nconst mat4 surfaceQ = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 2.0, 0.0,\n    0.0, 0.0, 0.0, -1.0);\n// The surface is valid at pᵀQp <= 0\n// This encodes the equation 0.25 <= x² + y² - xy\nconst mat4 boundsQ = mat4(\n    -1.0, 0.5, 0.0, 0.0,\n    0.5, -1.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.25);\n\nconst vec3 lightDir1 = normalize(vec3(1.0, 1.0, 1.0));\nconst vec3 lightDir2 = normalize(vec3(-1.0, 1.0, 1.0));\nconst vec3 lightColor1 = vec3(1.0, 1.0, 0.5);\nconst vec3 lightColor2 = vec3(1.0, 0.5, 0.5);\nconst vec3 ambientColor = vec3(0.1, 0.1, 0.25);\nconst vec3 albedoColor = vec3(0.5, 0.5, 0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Shoot a ray out from the camera\n    float aspectXoverY = float(iResolution.x) / float(iResolution.y);\n    vec4 rayOrigin = vec4(0.0, 0.0, 5.0, 1.0);\n    vec4 rayDir = vec4((uv.x - 0.5) * aspectXoverY, uv.y - 0.5, -2.0, 0.0);\n\n    // Rotate over time\n    float cs = cos(iTime);\n    float s = sin(iTime);\n    mat4 R = mat4(\n        cs, 0.0, s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -s, 0.0, cs, 0.0,\n        0.0, 0.0, 0.0, 1.0);\n    rayOrigin = R * rayOrigin;\n    rayDir = R * rayDir;\n\n    // Find ray-quadric intersection, if any\n    float a = dot(rayDir, surfaceQ * rayDir);\n    float b = dot(rayOrigin, surfaceQ * rayDir) + dot(rayDir, surfaceQ * rayOrigin);\n    float c = dot(rayOrigin, surfaceQ * rayOrigin);\n    // Discriminant from quadratic formula\n    // b^2 - 4ac\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        float xa = 1.0-(1.0+(discriminant/15.0));\n        fragColor = vec4(xa,xa,xa,0);\n        return;\n    }\n\n    // Pick the solution that is facing us\n    float t = (b + sqrt(discriminant)) * -0.5 / a;\n\n    // Discard stuff behind us\n    if (t < -0.0) {\n        fragColor = vec4(0,1,0,0);\n        return;\n    }\n\n    // Find the hit point in world space\n    vec4 hitPoint = rayOrigin + rayDir * t;\n    float boundsValue = dot(hitPoint, boundsQ * hitPoint);\n\n    // Discard fragments that are out of bounds\n    if (boundsValue > 0.0001) {\n        float xa = boundsValue*25.0;\n        fragColor = vec4(xa,xa,xa,0);\n        return;\n    }\n\n    // Compute normal from gradient of surface quadric\n    vec3 normal = normalize((surfaceQ * hitPoint).xyz);\n\n    // Use the normal for coloring\n    fragColor = vec4(albedoColor * (\n        lightColor1 * max(0.0, dot(normal, lightDir1)) +\n        lightColor2 * max(0.0, dot(normal, lightDir2)) +\n        ambientColor), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}