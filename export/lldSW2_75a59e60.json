{"ver":"0.1","info":{"id":"lldSW2","date":"1481716893","viewed":248,"name":"TriangleCircles3D_en","username":"gPlatl","description":"Extented version of IQs triangle demo (see header comment)\nwhich additional draws the incircle & outcircle of a triangle & there center points.\n\nBtw. any hints for shorter or faster TriangleXXXCircle calculations are welcome!\n\n","likes":4,"published":1,"flags":16,"usePreview":0,"tags":["3d","triangle","circle","normal","plane","circumcircle","circumscribe","incircle","3point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// TriangleCircles3D_en.glsl       by Gerd Platl\n//   v1.0  2016-12-15  initial version\n//   v1.1  2017-08-28  time correction\n//   v1.2  2021-01-18  optimizing intersect()\n//   v1.3  2021-02-14  TriangleOutCircle V2\n//   v1.4  2022-05-17  TriangleInCircle added (&renamed)\n//         2022-08-17  working status\n//\n// License: (CC BY-NC-SA 3.0) Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// tags: 3d, triangle, plane, normal, circle, incircle, circumcircle, circumscribe, 3point\n//---------------------------------------------------------\n// Created by inigo quilez:\n//   basic 3d scenery     https://www.shadertoy.com/view/4sXXRN\n//   basic 3d primitives  https://www.shadertoy.com/view/4lSGRV\n//   incircle 2d          https://www.shadertoy.com/view/tlKcDz \n//   http://iquilezles.org/www/articles/triangledistance/triangledistance.htm\n// 2d shader variant of inscribed and circumscribed circle of a triangle:\n//   https://www.shadertoy.com/view/NsXfRN\n//---------------------------------------------------------\n\n#define ANIMATE_TRIANGLE true \n\n//=== help functions ===\n\n// vector square: sqr(v) = v^2 = v.v = dot(v,v)\nfloat sqr (in vec3 v) { return dot(v,v); }\n\n// get normalized normal and its length\nvec3 normalVector (in vec3 u, in vec3 v, out float nl)\n{\n  vec3 r = cross(u,v);\n//  r.x = u.y * v.z - u.z * v.y;   // n = u x v\n//  r.y = u.z * v.x - u.x * v.z;\n//  r.z = u.x * v.y - u.y * v.x;\n  nl = sqrt (r.x*r.x + r.y*r.y + r.z*r.z);       // nl = |n|\n  if (nl > 1E-9) r /= nl;          // nn = n / |n|\n  return r;\n}\n\n// rotation around X-axis\nvec3 rotateX(vec3 p, float angle)\n{ float sa = sin(angle);\n  float ca = cos(angle);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n// rotation around Y-axis\nvec3 rotateY(vec3 p, float angle)\n{ float sa = sin(angle);\n  float ca = cos(angle);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n// rotation around Z-axis\nvec3 rotateZ(vec3 p, float angle)\n{ float sa = sin(angle);\n  float ca = cos(angle);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n//=== distance calculations ===\n\n//---------------------------------------------------------\n// return unsigned distance of point P to triangle A,B,C\n// http://iquilezles.org/www/articles/triangledistance/triangledistance.htm\n// https://www.shadertoy.com/view/4sXXRN\n//---------------------------------------------------------\nfloat udTriangle (in vec3 A, in vec3 B, in vec3 C, in vec3 P)\n{\n  vec3 u = B - A; vec3 pa = P - A;\n  vec3 v = C - B; vec3 pb = P - B;\n  vec3 w = A - C; vec3 pc = P - C;\n  vec3 nor = cross(u,w);\n\n  float d = sign(dot(cross(u,nor),pa))\n          + sign(dot(cross(v,nor),pb))\n          + sign(dot(cross(w,nor),pc));\n\n  if (d < 2.0)\n    return sqrt(min( min(\n                 sqr(u*clamp(dot(u,pa) / sqr(u),0.0,1.0)-pa),\n                 sqr(v*clamp(dot(v,pb) / sqr(v),0.0,1.0)-pb)),\n                 sqr(w*clamp(dot(w,pc) / sqr(w),0.0,1.0)-pc)));\n  \n  else return sqrt (dot(nor,pa)*dot(nor,pa) / sqr(nor));\n}\n//---------------------------------------------------------\n// sphere: M = center, radius = sphere radius\n//---------------------------------------------------------\nfloat sdSphere (vec3 M, float radius)\n{\n    return length(M) - radius;\n}\n//---------------------------------------------------------\n// cylinder Z-axis: h.x = radius, h.y = height\n//---------------------------------------------------------\nfloat sdCylinder (vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//---------------------------------------------------------\n// cylinder X-axis: h.x = radius, h.y = height\n//---------------------------------------------------------\nfloat sdCylinderX (vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//---------------------------------------------------------\n// cylinder Y-axis: h.x = radius, h.y = height\n//---------------------------------------------------------\nfloat sdCylinderY (vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//---------------------------------------------------------\n// torus:  t.x = torus radius,  t.y = ring radius\n//---------------------------------------------------------\nfloat sdTorus (vec3 p, vec2 t)\n{\n  return length(vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\n//=== geometric calculations ===\n\nconst float eps = 1E-6;        // very small value\nconst float undefined = 0.0;   \n\nstruct Ray    { vec3 origin;  vec3 direction; };\n\nstruct Plane  { vec3 origin;  vec3 normal; };\n\nstruct Sphere { vec3 center;  float radius; };\n\nstruct Circle   { vec3 M; vec3 normal; float radius; };\n\nstruct Triangle { vec3 A; vec3 B; vec3 C; };\n\n//---------------------------------------------------------\n// triangle area \n//---------------------------------------------------------\nfloat TriangleArea (in vec3 A, in vec3 B, in vec3 C)\n{\n  vec3 u = B - A;         // u = A->B\n  vec3 v = C - A;         // v = A->C\n  vec3 n = cross(u,v);    // n = uXv\n  return 0.5 * length(n); // Ft=|n|/2\n}\n//---------------------------------------------------------\n// triangle center\n//---------------------------------------------------------\nvec3 TriangleCenter (in vec3 A, in vec3 B, in vec3 C)\n{\n  return (A + B + C) / 3.0;\n}\n//---------------------------------------------------------\n// line triangle intersection point\n//---------------------------------------------------------\nvec3 LineTriangleIntersection (in Ray ray,       // Strahl\n                               in Triangle tri)  // Dreieck\n{\n  vec3 u = tri.A - tri.B;\n  vec3 v = tri.C - tri.A;    \n  vec3 w = tri.A - ray.origin;\n  vec3 n = cross(v, u);\n  vec3 q = cross(w, ray.direction);\n\n  float r = dot(ray.direction, n);\n  float k = dot(q,v) / r;  \n  float l = dot(q,u) / r;\n  float m = dot(n,w) / r;\n\n  if (k>0.0 && l>0.0 && (k+l)<1.0) // Schnittpunkt ?\n    return vec3(m, k, l);   // Skalierungsfaktoren \n  return vec3(-1.0);        // kein Schnittpunkt\n}\n//---------------------------------------------------------\n// circumcircle of a triangle,    A,B,C = triangle vertices\n//   M,r = circle center & radius,   nn = normalized normal\n//---------------------------------------------------------\nbool TriangleOutCircleV1 (in vec3 A, in vec3 B, in vec3 C,\n                          out vec3 M, out vec3 nn, out float r)\n{\n  vec3 u = B - A;           // u = A->B\n  vec3 v = C - A;           // v = A->C\n  vec3 n = cross (u,v);     // n = plane normal\n  float d = length(n);      // d = length of n\n  nn = normalize(n);        // |nn| = 1\n/*\n  if (d < eps)              // A,B,C on one line ?\n  {\n    M = A;                  // points A,B,C are \n    r = undefined;          //   on one line \n    return false;          \n  }\n*/  \n  float u2 = sqr (u);       // u2 = u^2\n  float v2 = sqr (v);       // v2 = v^2\n  float uv = dot (u,v);     // uv = u.v\n  d = 0.5 / (u2*v2-uv*uv);  // determinant\n  float k = v2*(u2-uv)*d;   \n  float l = u2*(v2-uv)*d;\n  vec3 w = k*u + l*v;       // w = A->M\n  M = A + w;                // circle center\n  r = length(w);            // r = |w|\n  return true;\n}\n//------------------------------\n// optimized variant \n//------------------------------\nvec3 TriangleOutCircle (in vec3 A, in vec3 B, in vec3 C,\n                        out vec3 nn, out float r)\n{\n  vec3 u = B - A;           // u = A->B\n  vec3 v = C - A;           // v = A->C\n  vec3 w = C - B;           // w = B->C\n  nn = cross(u,v);          // perpendicular vector \n  vec3 n = cross(nn,u);     // normal \n  vec3 m = 0.5 * (u + n * dot(v, w) / dot(n, w));\n  r = length(m);            // r = |m|\n  nn = normalize(n);        // nn= normalized normal\n  return A + m;             // M = circle center\n}\n//---------------------------------------------------------\n// incircle of a triangle\n//---------------------------------------------------------\nvec3 TriangleInCircle (in vec3 A, in vec3 B, in vec3 C,\n                       out vec3 nn, out float r)\n{\n  vec3 u = B - A;           // u = A->B \n  vec3 v = C - B;           // v = B->C\n  vec3 w = A - C;           // w = C->A\n  float i = length(u);      // i = |u|\n  float j = length(v);      // j = |v|\n  float k = length(w);      // k = |w|\n  float d = 1.0 / (i+j+k);  // d = 1 / circumference\n  vec3 n = cross(u,v);      // n = u X v \n  r = length(n)*d;          // r = |n|*d = radius\n  nn = normalize(n);        // nn= normalized normal\n  return A + (u*k-w*i)*d;   // M = circle center\n}\n\n//---------------------------------------------------------\n// get matrix to rotate to plane given by 3 points\n//---------------------------------------------------------\nmat3 rotMatrix (vec3 v1, vec3 v2, vec3 v3)\n{               \n  vec3 u = normalize(v2 - v1);\n  vec3 n = normalize(cross(u, v3-v1));\n  return mat3 (u, n, cross(n,u));\n}\n                \n\n//=== rendering ===========================================\n\nvec2 uv = vec2(0.0);\n\n// triangle vertices\nvec3 v1 = vec3(0.0);     \nvec3 v2 = vec3(0.0);\nvec3 v3 = vec3(0.0);\n\n// circle data\nbool inCircle = true;\nbool outCircle = true;\nvec3 Mi = vec3(0.0, 0.0, 0.0);  \nvec3 Mo = vec3(0.0, 0.0, 0.0);  \nvec3 nn = vec3(0.0, 1.0, 0.0);\nfloat ri = 0.05;    \nfloat rc = 0.05;    \n\n// hit point data\nstruct aHit\n{ vec3   pos;   // position\n  float dist;   // distance to object\n  int  steps;   // steps required\n  vec3 color;   // object color\n};\naHit hit;       // current intersection point\n\n//---------------------------------------------------------\nvoid animateTriangle()\n{\n  hit = aHit(vec3(1,0,0), 99999., 0, vec3(0));\n  float time = (ANIMATE_TRIANGLE) ? 0.2 * iTime : 0.0;\n  v1 = 0.8*cos(time + vec3(0.0,1.0,1.0) + 1.0);\n  v2 = 0.8*cos(time + vec3(0.0,2.0,3.0) + 2.0);\n  v3 = 0.8*cos(time + vec3(0.0,3.0,5.0) + 4.0);\n}\n//---------------------------------------------------------\nvoid hitCheck(float dist, vec3 color)\n{\n  if (dist < hit.dist)\n  {\n    hit.dist = dist;\n    hit.color = color;\n  }\n}\n//---------------------------------------------------------\nconst vec3 plane1Color    = vec3(0.50, 0.60, 0.70);\nconst vec3 plane2Color    = vec3(0.90, 0.60, 0.30);\nconst vec3 triangleColor  = vec3(0.00, 0.40, 0.80);\nconst vec3 normalColor    = vec3(1.00, 0.90, 0.00);\nconst vec3 inCircleColor  = vec3(0.60, 0.30, 0.00);\nconst vec3 outCircleColor = vec3(0.25, 0.80, 0.25);\nconst vec3 xColor         = vec3(1.00, 0.00, 0.00);\nconst vec3 yColor         = vec3(0.00, 1.00, 0.00);\nconst vec3 zColor         = vec3(0.00, 0.00, 1.00);\n//---------------------------------------------------------\nvoid worldAxis (in vec3 p)\n{\n  // world origin\n  float dist = sdSphere(p, 0.02);\n  hitCheck(dist, vec3(2.0));\n\n  dist = sdCylinderX (p, vec2(0.008, 1.0));   // X axis\n  hitCheck(dist, xColor);\n    \n  dist = sdCylinderY (p, vec2(0.008, 1.0));   // Y axis\n  hitCheck(dist, yColor);\n    \n  dist = sdCylinder (p, vec2(0.008, 1.0));   // Z axis\n  hitCheck(dist, zColor);\n}\n//----------------------------------------------------------\n// return 'true', if given key is pressed\n//----------------------------------------------------------\nbool keyPressed (int key)\n{\n  //return 0.5 < texture(iChannel0, vec2(key,0.25) / 256.0).x;\n  return texelFetch(iChannel0, ivec2(key,0), 0).x > 0.0;\n}\n//---------------------------------------------------------\n// get intersection point distance\n//---------------------------------------------------------\nfloat map (in vec3 p)\n{\n  // ground plane\n  float dist = p.y + 1.5;\n  hit = aHit(p, dist, 1, plane1Color);\n    \n  // triangle\n  dist = udTriangle(v1, v2, v3, p) - 0.01;\n  hitCheck(dist, triangleColor);\n    \n  // triangle center \n  float area = TriangleArea(v1,v2,v3);\n  vec3 center = TriangleCenter(v1,v2,v3);\n  dist = sdSphere(p - center, 0.04);\n  hitCheck(dist, triangleColor);\n              \n  // press 'a' to view axis\n  if (keyPressed(65))   // 65 = 'a'\n    worldAxis(p);\n \n  // prepare scenery rotation\n  mat3 rMatrix = rotMatrix(v1,v2,v3);\n  \n  // plane normal\n  vec3 r1 = (p - center) * rMatrix;\n  dist = sdCylinder (r1, vec2(0.01, 0.6));   \n  hitCheck(dist, normalColor);\n\n  // inscribeCircle\n  if (inCircle)\n  {\n    r1 = (p - Mi) * rMatrix;\n    dist = sdTorus(r1, vec2(ri,0.016));    \n    hitCheck(dist, inCircleColor);\n    \n    // draw inscribeCircle center  \n    dist = sdSphere(p - Mi, 0.04);\n    hitCheck(dist, inCircleColor);\n  }\n\n  // circumCircle\n  if (outCircle)\n  {\n    r1 = (p - Mo) * rMatrix;\n    dist = sdTorus(r1, vec2(rc,0.016));    \n    hitCheck(dist, outCircleColor);\n    \n    // draw circumCircle center  \n    dist = sdSphere(p - Mo, 0.04);\n    hitCheck(dist, outCircleColor);\n  }\n\n  return hit.dist;\n}\n//---------------------------------------------------------\n// get minimal object distance\n//---------------------------------------------------------\nfloat intersect (in vec3 ro, in vec3 rd)\n{\n  const float maxDist = 10.0;\n  float hd = 1.0;\n  float t = 0.0;\n  for (int i=0; i<64; i++)\n  {\n    hd = map (ro + rd*t);           // get distance\n    if (hd < 0.001) return t;       // near object ?\n    t += hd;                        // get nearer\n    if (t > maxDist) return -1.0;   // no intersection\n  }\n  return t;\n}\n//---------------------------------------------------------\nconst vec3 epsX = vec3(0.001, 0.0, 0.0);\nconst vec3 epsY = vec3(0.0, 0.001, 0.0);\nconst vec3 epsZ = vec3(0.0, 0.0, 0.001);\n\nvec3 calcNormal (in vec3 pos)\n{\n  float center = map(pos);\n  return normalize(vec3(map(pos+epsX) - center,\n                        map(pos+epsY) - center,\n                        map(pos+epsZ) - center));\n}\n//---------------------------------------------------------\nfloat calcSoftshadow (in vec3 ro, in vec3 rd, float k)\n{\n  float res = 1.0;\n  float t = 0.0;\n  float h = 1.0;\n  for (int i=0; i<20; i++)\n  {\n    h = map(ro + rd*t);\n    res = min (res, k*h/t);\n    t += clamp (h, 0.01, 1.0);\n    if (h < 0.0001) break;\n  } \n  return clamp(res, 0.0, 1.0);\n}\n//---------------------------------------------------------\nfloat calcOcclusion (in vec3 pos, in vec3 nor)\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++)\n  {\n    float hr = 0.02 + 0.025*float(i*i);\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos);\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return 1.0 - clamp (occ, 0.0, 1.0);\n}\n\nconst vec3 lightPos = normalize(vec3(1.0, 0.9, 0.7));\n\n//---------------------------------------------------------\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  // transformation to window center\n  #define R iResolution\n  vec2 uv = (2.0*fragCoord.xy - R.xy) / R.y;    // y: -1.0 .. 1.0\n  vec2 mo = (2.0*iMouse.xy    - R.xy) / R.y;    // y: -1.0 .. 1.0\n\n  // camera\t\n  float rtime = 0.1*iTime;\n  float rAngle = 6.2*mo.x + rtime;\n  vec3 ro = vec3(2.*cos(rAngle), 0.25+mo.y, 2.*sin(rAngle));  // ray origin\n  vec3 ta = vec3(0.0, 0.0, 0.0);        // target\n  vec3 cp = vec3(0.0, 1.0, 0.0);        // up\n  vec3 cw = normalize (ta - ro);        // direction\n  vec3 cu = normalize (cross(cw, cp));  // right\n  vec3 cv = normalize (cross(cu, cw));  // up corrected\n  vec3 rd = normalize (uv.x*cu + uv.y*cv + 2.0*cw);\n\n  animateTriangle();\n\n  // v3 = 0.5*(v2+v1);    // test special case\n  // TriangleInCircle    (v1,v2,v3, Mi,nn,ri);\n  Mo = TriangleOutCircle (v1,v2,v3, nn, rc);\n  Mi = TriangleInCircle  (v1,v2,v3, nn, ri);\n    \n  float t = intersect(ro,rd);   // get distance\n  \n  vec3 col = vec3(0);\n\n  if (t > 0.0)    // intersection found ?\n  {\n    hit.pos = ro + t*rd;             // intersection point \n    col = hit.color*3.0;             // object color\n    vec3 nor = calcNormal(hit.pos);  // object normal\n\n    // get shadow color \n    float sha = calcSoftshadow (hit.pos + nor*0.01, lightPos, 32.0);\n    float lgh = clamp (dot(nor, lightPos), 0.0, 1.0); \n    col *= plane1Color * 0.1 + plane1Color * lgh * sha;\n\n    // get occlusion\n    float occ = calcOcclusion(hit.pos, nor);\n    col += 0.03 + plane2Color * clamp(nor.y, 0.0, 1.0) * occ * 0.01;\n    col *= exp(-0.2*t);\n    col *= 1.0 - smoothstep(5.0, 10.0, t);\n  }\n  col = pow (clamp(col,0.0,1.0), vec3(0.45));\n    \n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}