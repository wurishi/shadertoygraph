{"ver":"0.1","info":{"id":"ttXcRr","date":"1591257291","viewed":55,"name":"Raymarching tutorial(1)","username":"imanishi","description":"Raymarchingで丸を表示するだけ\nhttps://www.youtube.com/watch?v=I2BPU2cWeY8","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\n#define ITERATION 64\n\n// 球の距離関数\nfloat sphere_d(vec3 pos) {\n\treturn length(pos) - 2.0;\n}\n\n//　Rayの定義\nstruct Ray {\n\tvec3 pos;\n    vec3 dir; // Rayの進行方向\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouse = (iMouse.xy - 0.5) * 2.0;\n    mouse.y *= iResolution.y / iResolution.x;\n    \n    // カメラ始点\n    vec3 camera = vec3(0.0, 0.0, -5.0);\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = vec3(0.0, 0.0, 1.0);\n    vec3 cameraSide = cross(cameraUp, cameraDir);\n    \n    // Ray設定\n    Ray ray;\n    ray.pos = camera;\n    ray.dir = normalize(st.x * cameraSide + st.y * cameraUp + cameraDir);\n    \n    // Rayを進める(Rayの衝突判定)\n    float t = 0.0;\n    float diff;\n    for (int i = 0; i < ITERATION; i++) {\n    \tdiff = sphere_d(ray.pos); // 距離関数から現在の距離を求める\n        // 衝突判定\n        if (diff < 0.001) {\n            break;\n        }\n        // 衝突しなかったらほんのちょびっとだけRayを進める\n        t += diff;\n        ray.pos = camera + t * ray.dir;\n    }\n    \n    if (diff < 0.001) {\n        fragColor = vec4(1.0);\n    } else {\n    \tfragColor = vec4(0.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}