{"ver":"0.1","info":{"id":"fdjXRc","date":"1620713575","viewed":171,"name":"porter","username":"hunahpu","description":"porter\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["math","complexanalysis","conformalmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Complex domain coloring\n * Copyright 2019 Ricky Reusser. MIT License.\n *\n * See Common tab for cubehelix license: \n * https://github.com/d3/d3-color\n * Copyright 2010-2016 Mike Bostock\n *\n * Features:\n *\n * - Adaptively selects and blends multiple octaves for polar phase and\n *   magnitude of a complex analytic function.\n *\n * - Antialiased grid lines\n *\n * - Antialiased shading\n * \n * - Partial implementation of automatic differentiation for avoiding\n *   standard derivatives (in the end standard derivatives are so easy and\n *   the anisotropy is not overwhelming, so why overcomplicate things?)\n * \n * - Avoids some (though not all?) preventable overflow/underflow via the\n *   `hypot` function instead of `length`\n *\n * TO DO:\n *\n * - fix gamma/colorspace usage (well, *non-usage*, to be precise)\n *\n * - add switch for rectangular contours\n *\n */\n\n// Available functions: cadd, csub, cmul, cdiv, cinv, csqr, cconj,\n// csqrt, cexp, cpow, clog, csin, ccos, ctan, ccot, ccsc, csec, casin,\n// cacos, catan, csinh, ccosh, ctanh, ccoth, ccsch, csech, casinh,\n// cacosh, catanh\nvec2 f (vec2 z, float t, vec2 mouse) {\n    vec2 a = vec2(sin(t), 0.5 * sin(2.0 * t));\n    vec2 b = vec2(cos(t), 0.5 * sin(2.0 * (t - HALF_PI)));\n    vec2 m = mouse;\n    \n    // Try a different equation:\n    // return csin((cmul(z - a, z - b, z - m)));\n    \n    return cdiv(cmul(z - a, m - b), cmul(z - b, m - a));\n}\n\nconst bool animate = true;\nconst bool grid = true; // (when not animating)\n\n// 1: counters split in six\n// 0: contours split in two\n#if 0\nconst vec2 steps = vec2(6, 6);\nconst int magOctaves = 5;\nconst int phaseOctaves = 5;\n#else\nconst vec2 steps = vec2(2, 2);\nconst int magOctaves = 9;\nconst int phaseOctaves = 9;\n#endif\n\n\n// Other constants\n// Defines the scale of the smallest octave (in some arbitrary units)\nconst vec2 scale = vec2(0.05);\n\n// Grid lines:\nconst float lineWidth = 1.0;\nconst float lineFeather = 1.0;\nconst vec3 gridColor = vec3(0);\n\n// Power of contrast ramp function\nconst float contrastPower = 2.5;\n\nvec2 pixelToXY (vec2 point) {\n  \tvec2 aspect = vec2(1, iResolution.y / iResolution.x);\n    return (point / iResolution.xy - 0.5) * aspect * 5.0;\n}\n\n// Select an animation state\nfloat selector (float time) {\n    const float period = 10.0;\n    float t = fract(time / period);\n    return smoothstep(0.4, 0.5, t) * smoothstep(1.0, 0.9, t);\n}\n\nvec3 colorscale (float phase) {\n    return rainbow(phase / 2.0 - 0.25);\n}\n\nfloat complexContouringGridFunction (float x) {\n  return 8.0 * abs(fract(x - 0.5) - 0.5);\n}\n\nfloat domainColoringContrastFunction (float x, float power) {\n  x = 2.0 * x - 1.0;\n  return 0.5 + 0.5 * pow(abs(x), power) * sign(x);\n}\nvec4 domainColoring (vec4 f_df,\n                     vec2 steps,\n                     vec2 scale,\n                     vec2 gridOpacity,\n                     vec2 shadingOpacity,\n                     float lineWidth,\n                     float lineFeather,\n                     vec3 gridColor,\n                     float phaseColoring,\n                     float contrastPower\n                     //sampler2D colormap\n) {\n    float invlog2base, logspacing, logtier, n, invSteps;\n\n    vec2 res = scale * vec2(1.0, 1.0 / 6.28) * 20.0 * steps;\n\n    // Complex argument, scaled to the range [0, 4]\n    float carg = atan(f_df.y, f_df.x) * HALF_PI_INV * 2.0;\n\n    // Reciprocal of the complex magnitude\n    float cmagRecip = 1.0 / hypot(f_df.xy);\n\n    // Normalize z before using it to compute the magnitudes. Without this we lose half\n    // of the floating point range due to overflow.\n    vec2 znorm = f_df.xy * cmagRecip;\n\n    // Computed as d|f| / dz, evaluated in the +real direction (though any direction works)\n    float cmagGradientMag = hypot(vec2(dot(znorm, f_df.zw), dot(vec2(znorm.y, -znorm.x), f_df.zw)));\n\n    float cargGradientMag = cmagGradientMag * cmagRecip;\n\n    // Shade at logarithmically spaced magnitudes\n    float mappedCmag = -log2(cmagRecip);\n    float mappedCmagGradientMag = cmagGradientMag * cmagRecip;\n\n    // Magnitude steps\n    // This is just a number we use a few times\n    invlog2base = 1.0 / log2(steps.x);\n    \n    // Compute the spacing based on the screen space derivative, and clamp it to a sane\n    // range so it looks a little nicer when it overflows\n    logspacing = log2(mappedCmagGradientMag * res.x) * invlog2base;\n    logspacing = clamp(logspacing, -50.0, 50.0);\n    \n    // The above is a continuous representation of the spacing, but we clamp so that\n    // we have an integer interval\n    logtier = floor(logspacing);\n    \n    // I'm having trouble working back through this line, though I think it's supposed\n    // to use the spacing (which is like a difference) back into a log-value, using the\n    // function value. Sorry this line isn't more clear. I'm suspicious it's actually not\n    // exactly the line I want it to be.\n    n = log2(abs(mappedCmag)) * invlog2base - logtier;\n\n    // Line widths\n    float width1 = max(0.0, lineWidth - lineFeather);\n    float width2 = lineWidth + lineFeather;\n    \n    // Position within a given octave in the [0, 1] sense\n    float position = 1.0 - logspacing + logtier;\n\n    float w, scaleFactor, value, gridValue;\n    float totalWeight = 0.0;\n    float magnitudeGrid = 0.0;\n    float magnitudeShading = 0.0;\n    float octave = pow(steps.x, n) * sign(mappedCmag);\n    scaleFactor = pow(steps.x, logtier) / cargGradientMag * 0.25;\n    invSteps = 1.0 / steps.x;\n    \n    // Loop through octaves for magnitude\n    for(int i = 0; i < magOctaves; i++) {\n        // Select the weight of either side of this octave to fade the \n        // smallest and largest octaves in/out. Also increase the weight\n        // a bit on each successive octave so that larger scales dominate\n        // and it's not excessively noisy.\n        float w0 = i == 0 ? 1e-4 : 1.0 + float(i);\n        float w1 = i == magOctaves - 1 ? 1e-4 : 1.0 + float(i + 1);\n        w = mix(w0, w1, position);\n        \n        totalWeight += w;\n        \n        // Compute a grid value so we can draw lines\n        gridValue = complexContouringGridFunction(octave) * scaleFactor;\n        \n        // Accumulate the above into grid lines\n        magnitudeGrid += w * smoothstep(width1, width2, gridValue);\n        \n        // Compute a looping ramp for magnitude\n        value = fract(-octave);\n        \n        // Add magnitude's contribution to shading. The contrast function applies\n        // some contrast, and the final min() function uses the grid function to blur\n        // the sharp edge where the ramp repeats, effectively antialiasing it.\n        magnitudeShading += w * (0.5 + (domainColoringContrastFunction(value, contrastPower) - 0.5) * min(1.0, gridValue * 1.5));\n        \n        // Increment the octave\n        scaleFactor *= steps.x;\n        octave *= invSteps;\n    }\n    \n    // We add weighted ramp functions in [0, 1]. We divide by the total weight to blend\n    // them, which also ensures the result is in [0, 1] as well.\n    magnitudeGrid /= totalWeight;\n    magnitudeShading /= totalWeight;\n\n    // Perform identically the same computation, except for phase.\n    invlog2base = 1.0 / log2(steps.y);\n    logspacing = log2(cargGradientMag * 2.0 * res.y) * invlog2base;\n    logspacing = clamp(logspacing, -50.0, 50.0);\n    logtier = floor(logspacing);\n    n = log2(abs(carg) + 1.0) * invlog2base - logtier;\n    position = 1.0 - logspacing + logtier;\n\n\n    totalWeight = 0.0;\n    float phaseShading = 0.0;\n    float phaseGrid = 0.0;\n    octave = pow(steps.y, n) * sign(carg);\n    scaleFactor = pow(steps.y, logtier) / (cargGradientMag * 2.0) * 2.0;\n    invSteps = 1.0 / steps.y;\n\n    // See above for a description of all the terms in this computation.\n    for (int i = 0; i < phaseOctaves; i++) {\n        float w0 = i == 0 ? 1e-4 : 1.0 + float(i);\n        float w1 = i == phaseOctaves - 1 ? 1e-4 : 1.0 + float(i + 1);\n        \n        w = mix(w0, w1, position);\n        totalWeight += w;\n        gridValue = complexContouringGridFunction(octave) * scaleFactor;\n        phaseGrid += w * smoothstep(width1, width2, gridValue);\n        value = fract(octave);\n        phaseShading += w * (0.5 + (domainColoringContrastFunction(value, contrastPower) - 0.5) * min(1.0, gridValue * 1.5));\n        scaleFactor *= steps.y;\n        octave *= invSteps;\n    }\n\n    phaseGrid /= totalWeight;\n    phaseShading /= totalWeight;\n\n    // Combine the grids into a single grid value\n    float grid = 1.0;\n    grid = min(grid, 1.0 - (1.0 - magnitudeGrid) * gridOpacity.x);\n    grid = min(grid, 1.0 - (1.0 - phaseGrid) * gridOpacity.y);\n    \n    // Add up the shading so that `shading` is 1.0 when there is none, and darkens as you add shading.\n    float shading = 0.5 + (shadingOpacity.y * (0.5 - phaseShading)) + shadingOpacity.x * (magnitudeShading - 0.5);\n\n    // Compute a color based on the argument, then multiply it by shading\n    vec3 color = colorscale(carg) * (0.5 + 0.5 * shading);\n    \n    // Combine the result into a bit of an ad hoc function, again tailored so that things reduce\n    // to a nice result when you remove shading or coloring.\n    vec3 result = mix(vec3(shading + (1.0 - phaseColoring) * 0.5 * (1.0 - shadingOpacity.x - shadingOpacity.y)), color, phaseColoring);\n\n    // Combine the color and grid\n    result = mix(gridColor, result, grid);\n\n    // --\n    return vec4(result, 1.0);\n}\nvec2 lerp2(vec2 a, vec2 b, float t){\n    return a*(1.0-t)+t*b;\n}\n\nvec2 normal(vec2 xy, vec2 p, float t){\n    return cdiv(xy,lerp2(vec2(1.0,0.0),p,t));\n}\n\nvec2 translate(vec2 xy, vec2 p, float t){\n    return lerp2(xy,xy-p,t);\n}\n\nvec2 invert(vec2 xy, float t){\n    return lerp2(xy,cinv(xy),t);;\n}\n\nfloat circle(vec2 xy, float r){\n    return step(length(xy),r);\n}\n\nvec2 h(vec2 xy, vec2 p){\n    return xy-p;\n}\n\nvec2 h1(vec2 xy, vec2 p){\n    return cdiv(xy,p);\n}\n\nvec2 h2(vec2 xy, vec2 p){\n    return cinv(h(xy,p));\n}\n\n\nvec2 z1 = vec2(0.5,1.0);\nvec2 z2 = vec2(1.0,0.4);\nvec2 z3 = vec2(-1.0,0.0);\nvec2 z4 = vec2(1.2,-0.1);\nfloat r = 0.05;\n\nvec2 g(vec2 xy){\n    return h1(h((cinv(h(xy,z3))),cinv(h(z2,z3))),h((cinv(h(z1,z3))),cinv(h(z2,z3))));\n}\n\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = pixelToXY(fragCoord)*2.0;\n    vec2 mouse = pixelToXY(iMouse.xy);\n    float t = pow(sin(iTime / 5.0),2.0)*3.0;\n    vec2 fz = vec2(0.0);//lerp2(xy,cinv(xy-z1),t);//f1(xy,vec2(0.5,0.5),t);//f(xy, iTime * 0.2, mouse);\n    if(t<0.5)\n        fz = translate(xy,z3,2.0*t);\n    else if(t<1.0)\n        fz = invert(h(xy,z3),2.*t-1.0);\n    else if(t<2.0)\n        //fz = translate(xy,z1,1.0);\n        fz = translate(cinv(h(xy,z3)),cinv(h(z2,z3)),t-1.0);\n    else \n        fz = normal(translate(cinv(h(xy,z3)),cinv(h(z2,z3)),1.0),translate(cinv(h(z1,z3)),cinv(h(z2,z3)),1.0),t-2.0);//normal(translate(xy,z1,1.0),h(z2,z1),1.0-t);\n        //fz = normal(translate(xy,z1,1.0),h(z2,z1),1.0-t);//invert(normal(translate(xy,z1,1.0),z2-z1,1.0),z3,3.0-t);\n    //fz = g(xy);\n    //fz = cinv(xy);\n    // fwidth(fz) works, but it adds ugly anisotropy in the width of lines near zeros/poles.\n    // Insead, we compute the magnitude of the derivatives separately.\n    //\n    // Also *NOTE* that this is a very important place in which we use `hypot` instead of an\n    // algebraically equivalent built-in `length`. Floating point is limited and we lose lots\n    // of our floating point domain if we're not careful about over/underflow.\n    vec4 fdf = vec4(fz, vec2(hypot(dFdx(fz)), hypot(dFdy(fz))));\n\n   \tfloat select = selector(iTime);\n    if(circle(xy-z1,r)==1.0)\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    else if(circle(xy-z2,r)==1.0)\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    else if(circle(xy-z3,r)==1.0)\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    else{\n        vec4 color = domainColoring(\n            fdf,\n            steps,\n            scale,\n            vec2(1.0),  // grid\n            vec2(0.35), // shading\n            lineWidth,\n            lineFeather,\n            gridColor,\n            0.9,\n            contrastPower\n        );\n        //color = max(color, vec4(circle(xy-z3,r)));\n        //color = max(color, vec4(circle(xy-z2,r)));\n        //color = max(color, vec4(circle(xy-cinv(h(z2,z3)),r)));\n        //color = max(color, vec4(circle(xy-z2,r)));\n\n        fragColor = color;\n        }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex math! Beware that these functions are not all great for overflow,\n// even though a GPU is precisely the sort of place where you ought to be \n// *very* concerned about overflow.\n//\n// This also includes a partial implementation of automatic differentiation\n// for complex arithmetic using vec4 as a + bi --> vec4(a, b, da, db). This\n// may be used to successfully avoid standard derivatives, though I just\n// didn't find it worthwhile when standard derivatives are so easy and well\n// supported.\n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n/*\nfloat sinh (float x) {\n  return 0.5 * (exp(x) - exp(-x));\n}\n\nfloat cosh (float x) {\n  return 0.5 * (exp(x) + exp(-x));\n}*/\n\nvec2 sinhcosh (float x) {\n  vec2 ex = exp(vec2(x, -x));\n  return 0.5 * (ex - vec2(ex.y, -ex.x));\n}\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\nvec2 clog(vec2 z) {\n  return vec2(\n    log(hypot(z)),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 catan (vec2 z) {\n  float a = z.x * z.x + (1.0 - z.y) * (1.0 - z.y);\n  vec2 b = clog(vec2(1.0 - z.y * z.y - z.x * z.x, -2.0 * z.x) / a);\n  return 0.5 * vec2(-b.y, b.x);\n} \n\nvec2 catanh (vec2 z) {\n  float oneMinus = 1.0 - z.x;\n  float onePlus = 1.0 + z.x;\n  float d = oneMinus * oneMinus + z.y * z.y;\n\n  vec2 x = vec2(onePlus * oneMinus - z.y * z.y, z.y * 2.0) / d;\n\n  vec2 result = vec2(log(hypot(x)), atan(x.y, x.x)) * 0.5;\n\n  return result;\n} \n\nvec2 cacos (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(a.x - z.y, a.y + z.x));\n  return vec2(HALF_PI - b.y, b.x);\n} \n\nvec2 cacosh (vec2 z) {\n  vec2 a = cacos(z);\n\n  if (a.y <= 0.0) {\n    return vec2(-a.y, a.x);\n  }\n\n  return vec2(a.y, -a.x);\n} \n\nvec2 cacot (vec2 z) {\n  return catan(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cacoth(vec2 z) {\n  return catanh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casin (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(\n    a.x - z.y,\n    a.y + z.x\n  ));\n\n  return vec2(b.y, -b.x);\n} \n\nvec2 casinh (vec2 z) {\n  vec2 res = casin(vec2(z.y, -z.x));\n  return vec2(-res.y, res.x);\n} \n\nvec2 cacsch(vec2 z) {\n  return casinh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casec (vec2 z) {\n  float d = dot(z, z);\n  return cacos(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casech(vec2 z) {\n  return cacosh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cconj (vec2 z) {\n  return vec2(z.x, -z.y);\n} \n\nvec2 ccos (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(cos(z.x), -sin(z.x));\n} \n\nvec2 ccosh (vec2 z) {\n  return sinhcosh(z.x).yx * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 ccot (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.y);\n  return vec2(-sin(z.x), sch.x) / (cos(z.x) - sch.y);\n} \n\nvec2 ccoth(vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, -sin(z.y)) / (sch.y - cos(z.y));\n} \n\nvec2 ccsc (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) - 0.5 * cos(2.0 * z.x);\n\n  return sinhcosh(z.y).yx * vec2(sin(z.x), -cos(z.x)) / d;\n} \n\nvec2 ccsch (vec2 z) {\n  vec2 sch = sinhcosh(z.x);\n  float d = cos(2.0 * z.y) - (exp(2.0 * z.x) + exp(-2.0 * z.x)) * 0.5;\n  return vec2(-cos(z.y), sin(z.y)) * sch / (0.5 * d);\n} \n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmul (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c) {\n  return cmul(cmul(a, b), c);\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmul(cmul(a, b), cmul(c, d));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmul(cmul(a, b, c), cmul(d, e));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmul(cmul(a, b, c), cmul(d, e, f));\n} \n\nvec2 cpolar (vec2 z) {\n  return vec2(\n    atan(z.y, z.x),\n    hypot(z)\n  );\n} \n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\nvec2 csec (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) + 0.5 * cos(2.0 * z.x);\n  return sinhcosh(z.y).yx * vec2(cos(z.x), sin(z.x)) / d;\n} \n\nvec2 csech(vec2 z) {\n  float d = cos(2.0 * z.y) + 0.5 * (exp(2.0 * z.x) + exp(-2.0 * z.x));\n  vec2 sch = sinhcosh(z.x);\n\n  return vec2(cos(z.y), -sin(z.y)) * sch.yx / (0.5 * d);\n} \n\nvec2 csin (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(sin(z.x), cos(z.x));\n} \n\nvec4 csincos (vec2 z) {\n  float c = cos(z.x);\n  float s = sin(z.x);\n  return sinhcosh(z.y).yxyx * vec4(s, c, c, -s);\n} \n\nvec2 csinh (vec2 z) {\n  return sinhcosh(z.x) * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 csqr (vec2 z) {\n  return vec2(\n    z.x * z.x - z.y * z.y,\n    2.0 * z.x * z.y\n  );\n} \n\nvec2 ctan (vec2 z) {\n  vec2 e2iz = cexp(2.0 * vec2(-z.y, z.x));\n\n  return cdiv(\n    e2iz - vec2(1, 0),\n    vec2(-e2iz.y, 1.0 + e2iz.x)\n  );\n} \n\nvec2 ctanh (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, sin(z.y)) / (sch.y + cos(z.y));\n}\n\n\nvec4 cmul (vec4 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec2 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw)\n  );\n}\n\nvec4 cmul (vec4 a, vec2 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec4 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\n\nvec4 csqr (vec4 a) {\n  return vec4(\n    csqr(a.xy),\n    2.0 * cmul(a.xy, a.zw)\n  );\n}\nvec4 cdiv (vec4 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw) - cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec2 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(-cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec4 a, vec2 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw), csqr(b.xy))\n  );\n}\n\nvec4 csub(vec4 a, vec4 b) {\n  return a - b;\n}\n\nvec4 csub(vec2 a, vec4 b) {\n  return vec4(a.xy - b.xy, -b.zw);\n}\n\nvec4 csub(vec4 a, vec2 b) {\n  return vec4(a.xy - b.xy, a.zw);\n}\n\nvec4 cadd(vec4 a, vec4 b) {\n  return a + b;\n}\n\nvec4 cadd(vec2 a, vec4 b) {\n  return vec4(a.xy + b.xy, b.zw);\n}\n\nvec4 cadd(vec4 a, vec2 b) {\n  return vec4(a.xy + b.xy, a.zw);\n}\n\n\nvec4 cinv(vec4 a) {\n  vec2 ainv = cinv(a.xy);\n  return vec4(ainv, cmul(a.zw, -csqr(ainv)));\n}\n\nvec4 cexp(vec4 a) {\n  vec2 expa = cexp(a.xy);\n  return vec4(expa, cmul(expa, a.zw));\n}\n\nvec4 csqrt(vec4 a) {\n  float r = hypot(a.xy);\n  float b = sqrt(2.0 * (r + a.x));\n  float c = sqrt(2.0 * (r - a.x));\n  float re = a.x >= 0.0 ? 0.5 * b : abs(a.y) / c;\n  float im = a.x <= 0.0 ? 0.5 * c : abs(a.y) / b;\n  vec2 s = vec2(re, a.y < 0.0 ? -im : im);\n  return vec4(s, cmul(a.zw, 0.5 * cinv(s)));\n}\n\n/*vec4 cpow(vec4 a, float n) {\n  float theta = atan(a.y, a.x);\n  float r = hypot(a.xy);\n  float tn = theta * n;\n  float rn = pow(r, n);\n  vec2 s = rn * vec2(sin(tn), cos(tn));\n  float rn1 = pow(r, n - 1.0);\n  float tn1 = theta * (n - 1.0);\n  return vec4(s, cmul(a.zw, n * rn1 * vec2(sin(tn1), cos(tn1))));\n}*/\n\nvec4 clog(vec4 z) {\n  return vec4(\n    log(hypot(z.xy)),\n    atan(z.y, z.x),\n    cdiv(z.zw, z.xy)\n  );\n}\n\nvec4 csin(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.xy, cmul(asincos.zw, a.zw));\n}\n\nvec4 ccos(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.zw, cmul(-asincos.xy, a.zw));\n}\n\nvec4 ctan(vec4 a) {\n  return cdiv(csin(a), ccos(a));\n}\n\nvec4 casin(vec4 z) {\n  vec4 s = clog(vec4(-z.y, z.x, -z.w, z.z) + csqrt(csub(vec2(1, 0), csqr(z))));\n  return vec4(s.y, -s.x, s.w, -s.z);\n}\n\nvec4 cacos(vec4 z) {\n  vec4 s = -casin(z);\n  s.x += HALF_PI;\n  return s;\n}\n\nvec4 catan(vec4 z) {\n  vec2 s = clog(cdiv(cadd(vec2(0, 1), z.xy), csub(vec2(0, 1), z.xy)));\n  return vec4(\n     0.5 * vec2(-s.y, s.x),\n     cmul(z.zw, cinv(cadd(vec2(1, 0), csqr(z))))\n  );\n}\n\nvec4 csinh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez - cinv(ez));\n}\n\nvec4 ccosh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez + cinv(ez));\n}\n\nvec4 ctanh(vec4 z) {\n  vec4 ez = cexp(z);\n  vec4 ezinv = cinv(ez);\n  return 0.5 * cdiv(ez - ezinv, ez + ezinv);\n}\n\nvec4 casinh(vec4 z) {\n  return clog(cadd(z, csqrt(cadd(vec2(1, 0), csqr(z)))));\n}\n\nvec4 cacosh(vec4 z) {\n  return clog(z + cmul(csqrt(cadd(z, vec2(1, 0))), csqrt(csub(z, vec2(1, 0)))));\n}\n\nvec4 catanh(vec4 z) {\n  return 0.5 * clog(cdiv(cadd(z, vec2(1,  0)), csub(vec2(1, 0), z)));\n}\n\n// https://github.com/d3/d3-color\n// Copyright 2010-2016 Mike Bostock\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n// \n// * Redistributions of source code must retain the above copyright notice, this\n//   list of conditions and the following disclaimer.\n// \n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// \n// * Neither the name of the author nor the names of contributors may be used to\n//   endorse or promote products derived from this software without specific prior\n//   written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nvec3 cubehelix(vec3 c) {\n  vec2 sc = vec2(sin(c.x), cos(c.x));\n  return c.z * (1.0 + c.y * (1.0 - c.z) * (\n    sc.x * vec3(0.14861, 0.29227, -1.97294) + \n    sc.y * vec3(1.78277, -0.90649, 0.0)\n  ));\n}\n\nvec3 rainbow(float t) {\n  return cubehelix(vec3(\n    TWO_PI * t - 1.74533,\n    (0.25 * cos(TWO_PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n  ));\n}","name":"Common","description":"","type":"common"}]}