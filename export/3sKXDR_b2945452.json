{"ver":"0.1","info":{"id":"3sKXDR","date":"1573819468","viewed":217,"name":"don - Gear SDF 2D","username":"koktszfung","description":"This shader showcase a gear sdf I made. This is also my first shader!\n90% of the code is written by hughsk though lol (https://www.shadertoy.com/view/XsyGRW).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n *\tray marching tools adapted from hughsk's 2D SDF Toy https://www.shadertoy.com/view/XsyGRW\n */\n\n#define TRACE_STEPS 20\n#define TRACE_RAY\n\n// 0 = Distance Field Display\n// 1 = Raymarched Edges\n// 2 = Resulting Solid\n// 3 = Distance Field Polarity\n#define DISPLAY 0\n\n// 0 = Angle controlled By iTime\n// 1 = Angle controlled By iMouse\n#define MOUSE 0\nconst float PI = 3.14159265359;\n\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec2 pmod(vec2 p, float m) {\n\treturn mod(p + m*.5, m) - m*.5;\n}\n\nfloat pmod(float p, float m) {\n\treturn mod(p + m*.5, m) - m*.5;\n}\n\nvec2 rotate(vec2 p, float a){\n \treturn vec2(p.x*cos(a) - p.y*sin(a),\n                p.x*sin(a) + p.y*cos(a));   \n}\n\n\n\nfloat shape_circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat shape_rect(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) +  min(max(d.x, d.y), 0.0);  // out + in\n}\n\nfloat shape_line(vec2 p, vec2 a, vec2 b) {\n  vec2 dir = b - a;\n  return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat shape_segment(vec2 p, vec2 a, vec2 b) {\n  float d = shape_line(p, a, b);\n  float d0 = dot(p - b, b - a);\n  float d1 = dot(p - a, b - a);\n  return d1 < 0.0 ? length(a - p) : d0 > 0.0 ? length(b - p) : d;\n}\n\nfloat shape_gear(vec2 p, float n, float lr, float hr, float oa) {  // point, number, low radius, high radius, teeth's offset angle\n    float pr = length(p);\t\n    float pa = atan(p.y, p.x) + PI*2.;\n    \n    float ma = 2.*PI/n;  // ma: modulus angle\n    pa = mod(pa, ma);  // new pa: remainder angle\n    p = pr * vec2(cos(pa), sin(pa));  // take values in the first modulus angle\n    \n    // circle is a discont' part of the primitive circle shape\n    float gr = (pa > oa && pa < ma-oa)? hr : lr;  // gear's radius at angle pa\n    float circle = shape_circle(p, gr);\n    \n    // segment is a cont' part of the primitive segment shape\n    float segment1 = shape_segment(p, vec2(lr*cos(oa), lr*sin(oa)), vec2(hr*cos(oa), hr*sin(oa)));  // start angle   \n    float segment2 = shape_segment(p, vec2(lr*cos(ma-oa), lr*sin(ma-oa)), vec2(hr*cos(ma-oa), hr*sin(ma-oa)));  // end angle    \n    float segment = min(segment1, segment2);\n    \n    // when p is inside the shape, the value is negative\n    if (pr < gr) {\n        return -min(-circle, segment);\n    } else {\n    \treturn min(circle, segment);\n    }\n}\n\nfloat SAMPLER(vec2 p) {\n    #if MOUSE\n    \tfloat a1 = iMouse.x / iResolution.x * PI*2.;\n    \tfloat a2 = iMouse.x / iResolution.x * -PI*2. + PI*.5;\n    #endif\n    #if !MOUSE\n        float T = 3.;  // period\n        float a1 = smoothstep(0., T*.75, mod(iTime, T)) * PI*2.;  // stop for T*.25s\n        float a2 = smoothstep(0., T*.75, mod(iTime, T)) * -PI*2. + PI*.5;  // stop for T*.25s, +PI/2 phase\n    #endif\n\n    \n    vec2 p1 = rotate(p - vec2(-.6, 0.), a2);  // left\n    vec2 p2 = rotate(p - vec2(.6, 0.), a1);  // right\n    \n    float gear1 = shape_gear(p1, 3., .5, .7, .83);  // left\n    float gear2 = shape_gear(p2, 3., .5, .7, .83);  // right\n\n    return min(gear1, gear2);\n}\n\n\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_polarity(float d, vec2 p) {\n  p += iTime * -0.1 * sign(d) * vec2(0, 1);\n  p = mod(p + 0.06125, 0.125) - 0.06125;\n  float s = sign(d) * 0.5 + 0.5;\n  float base = draw_solid(d);\n  float neg = shape_rect(p, vec2(0.045, 0.0085) * 0.5);\n  float pos = shape_rect(p, vec2(0.0085, 0.045) * 0.5);\n  pos = min(pos, neg);\n  float pol = mix(neg, pos, s);\n\n  float amp = abs(base - draw_solid(pol)) - 0.9 * s;\n\n  return vec3(1.0 - amp);\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd) {\n  vec3 col = vec3(0);\n  vec3 line = vec3(1, 1, 1);\n  vec2 _ro = ro;\n\n  for (int i = 0; i < TRACE_STEPS; i++) {\n    float t = SAMPLER(ro);\n    col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));\n    col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));\n    col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));\n    ro += rd * t;\n    if (t < 0.01) break;\n  }\n\n  #ifdef TRACE_RAY\n    col += 1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.);\n  #endif\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime * 0.5;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  vec2 rd = normalize(-ro);\n\n  d = SAMPLER(uv);\n\n  #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n    #if MOUSE == 0\n    \tcol -= (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    #endif\n  #endif\n  #if DISPLAY == 1\n    col = vec3(0) + 1.0 - vec3(draw_line(d));\n    #if MOUSE == 0\n    \tcol += (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(1, 0.25, 0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    #endif\n    col = 1. - col;\n  #endif\n  #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n  #endif\n  #if DISPLAY == 3\n    col = vec3(draw_polarity(d, uv.xy));\n  #endif\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"}]}