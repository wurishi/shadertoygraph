{"ver":"0.1","info":{"id":"ldVyzR","date":"1520883710","viewed":155,"name":"Marmaladey Rays","username":"audiopixel","description":"Climb the tower","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rays","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Marmaladey Rays'\n// Created by hepp maccoy 2018 hepp@audiopixel.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Building on techniques by @iq, @alteredq, @mrkishi and others\n// Thanks to @cacheflowe & @reinder for advice on ray marching\n\nmat2 r2d(float a) {\n    float sa=sin(a);\n    float ca=cos(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nfloat soc(vec3 p) {\n    vec3 n = normalize(sign(p+1e6));\n    return min(min(dot(p.xy, n.xy), dot(p.yz, n.yz)), dot(p.xz, n.xz));\n}\n\nvec2 amod(vec2 p, float m) {\n    float a=mod(atan(p.x,p.y), m)-m*.5;\n    return vec2(cos(a), sin(a))*length(p);\n}\n\nfloat map(vec3 p) {\n    float t = iTime + 240.;\n    float k = (t * 4.)+ sin(t * .5) * 4.;\n    float r = 14.7072541 + sin(t * .4) * 6.;\n    float d = 1.0; vec3 o = p;\n    float a = mod(o.y+5.0, (20.))-10.; a = abs(o.y);\n    p.zy *= r2d(sign(a)*0.3998);\n    p.xz *= r2d(sign(a)*k * .25 - sin(t) * .4);\n    p.xz = amod(p.xz, 0.785398163375  - sin(t * .35) * .5);\n    p.xz = max(abs(p.xz)-(0.732119777+ sin(t) * .7), (-0.73844485 - sin(t * .3) * 1.2));\n    p.z = mod(p.z, 1.00980358)-0.50490179;\n    p.x = mod(p.x, r)-(r *.5);\n    p.y = mod(p.y+k, 15. + sin(iTime) * .014)-5.;\n    d = min(d, soc(max(abs(p)-0.183095666, 0.096382810)));\n    return (length(p*-0.34201)-1.3970756)*(0.2746 - sin(t * 1.) * .15) - (d * -2.);\n} \n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.5;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord.xy/iResolution.xy)*2.5-1.;\n    st.x *= 1.7;\n    vec3 ro = vec3(st, 12.5022423);\n    vec3 rd = normalize(vec3(st+vec2(0.), -0.41422437));\n    vec3 mp; mp = ro; float md;\n    for (int i=0; i<50; i++) {\n        md = map(mp); if (md <.001) break;\n        mp += (rd*.480739274206)*md*.838429808073;\n    }\n    vec3 c1 = vec3(-0.3 - (length(ro-mp) * .02496077) * -1.19102289690);\n    vec3 c2; vec3 light = vec3(0,0,0); vec3 p = ro + rd * (mp); vec3 normal = calcNormal(p);\n    float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n    dif *= 5. / dot(light - p, light - p);\n    c2 = vec3(pow(dif, .4545)); \n    c2 = vec3(normal.z * .75, 0., normal.y * .25);\n    c2 -= vec3(normal.y * 3., 1., 0.);\n    fragColor = vec4((c1 + max(c1, c2 * -0.5708 + sin(iTime * .34) * .25)), 1.0);\n}","name":"Image","description":"","type":"image"}]}