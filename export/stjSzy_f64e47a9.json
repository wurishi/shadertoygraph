{"ver":"0.1","info":{"id":"stjSzy","date":"1627992150","viewed":163,"name":"Sphere (Max Norm Distance)","username":"TheTurk","description":"Maximum norm distance function for a sphere.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","sphere","circle","distance","linfinity","maximumnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nTo compute the maximum norm distance between a point p and a \nprimitive we need to find the size of the smallest \naxis-aligned cube (compared to the size of the smallest \nsphere under Euclidian norm) centered at p that touches the \nsurface of the primitive. There are usually three cases that \nneed to be handled depending on whether the point that \ntouches the surface of the primitive lies on a corner, edge \nor face of the cube.\n*/\n\nfloat circle(vec2 position, float radius) {\n    position = abs(position);\n    float d = max(position.x - radius, position.y);\n    d = min(d, max(position.x, position.y - radius));\n    float b = dot(vec2(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 2.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 2.0;\n        d = min(d, t);\n    }\n    return d;\n}\n\n// alternative geometric version\nfloat circle2(vec2 position, float radius) {\n    position = abs(position);\n    if (position.x < position.y - radius || position.y < position.x - radius) {\n        return max(position.x, position.y) - radius;\n    }\n    float p = dot(position, vec2(0.5));\n    float q = dot(position, position) * 0.5 - p * p;\n    float h = sqrt(radius * radius * 0.5 - q); \n    return p - h;\n}\n\nfloat sphere(vec3 position, float radius) {\n    position = abs(position);\n\n    // closest point lies on cube face\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    \n    // closest point lies on cube edge\n    {\n        float b = dot(vec2(1.0), position.xy);;\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n\n    // closest point lies on cube corner\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\n// alternative geometric version\nfloat sphere2(vec3 position, float radius) {\n    position = abs(position);\n\n    // closest point lies on cube face\n    if (position.y < position.x - radius && position.z < position.x - radius) {\n        return position.x - radius;\n    }\n    // closest point lies on cube face\n    if (position.x < position.y - radius && position.z < position.y - radius) {\n        return position.y - radius;\n    }\n    // closest point lies on cube face\n    if (position.x < position.z - radius && position.y < position.z - radius) {\n        return position.z - radius;\n    }\n\n    // closest point lies on cube edge\n    if (position.x < position.y && position.x < position.z) {\n        float p = dot(position.yz, vec2(0.5));\n        float q = dot(position.yz, position.yz) * 0.5 - p * p;\n        float h = sqrt(radius * radius * 0.5 - q); \n        float a = p - h;\n        if (position.x < a) {\n           return a;\n        }\n    }\n    // closest point lies on cube edge\n    if (position.y < position.x && position.y < position.z) {\n        float p = dot(position.xz, vec2(0.5));\n        float q = dot(position.xz, position.xz) * 0.5 - p * p;\n        float h = sqrt(radius * radius * 0.5 - q); \n        float a = p - h;\n        if (position.y < a) {\n            return a;\n        }\n    }\n    // closest point lies on cube edge\n    if (position.z < position.x && position.z < position.y) {\n        float p = dot(position.xy, vec2(0.5));\n        float q = dot(position.xy, position.xy) * 0.5 - p * p;\n        float h = sqrt(radius * radius * 0.5 - q); \n        float a = p - h;\n        if (position.z < a) {\n           return a;\n        } \n    }\n\n    // closest point lies on cube corner\n    vec3 rayDirection = vec3(sqrt(1.0 / 3.0));\n    float p = dot(position, rayDirection);\n    float q = dot(position, position) - p * p;\n    float h = sqrt(radius * radius - q); \n    float c = p - h;\n    float a = c * sqrt(1.0 / 3.0);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float z = (fract((iTime * 0.2) + 0.5) * 2.0 - 1.0) * 0.6;\n    \n    float radius = 0.5;\n    // float d = circle(position, 0.5);\n    float d = sphere(vec3(position, z), radius);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0, 0.9, 1.0) + sign(d) * vec3(-0.3, 0.4, 0.3); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d); // ripples\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.001) * iResolution.y)); // outline\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}