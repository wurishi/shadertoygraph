{"ver":"0.1","info":{"id":"XfcyRf","date":"1732675297","viewed":97,"name":"Inverse Kinematics Testing V1","username":"8InfinityTaco8","description":"Some more Inverse Kinematics methods ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ik","inverse","kinematics"],"hasliked":0,"parentid":"lfdyDn","parentname":"Inverse Kinematics Test V0"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Top Left: Analytical IK\n// Top Right: FABRIK IK (my favorite)\n//Bottom Left: CCD IK\n//Bottom Right: Jacobian Inverse IK\n\nconst float PI = 3.14159265359;\nconst int NUM_SEGMENTS = 3;\nconst float SEGMENT_LENGTH = 0.2;\nconst float JOINT_RADIUS = 0.02;\n\nstruct Joint {\n    vec2 pos;\n    float angle;\n};\n\nfloat drawCircle(vec2 uv, vec2 center, float radius) {\n    float d = length(uv - center);\n    return smoothstep(radius + 0.005, radius, d);\n}\n\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2, float thickness) {\n    vec2 dir = p2 - p1;\n    float len = length(dir);\n    dir = dir / len;\n    vec2 perpDir = vec2(-dir.y, dir.x);\n    vec2 toUV = uv - p1;\n    float projLen = dot(toUV, dir);\n    float perpDist = abs(dot(toUV, perpDir));\n    return (projLen >= 0.0 && projLen <= len && perpDist < thickness) ? 1.0 : 0.0;\n}\n\n// Analytical IK (2-segment only)\nJoint[NUM_SEGMENTS] solveAnalyticalIK(vec2 target, vec2 base) {\n    Joint[NUM_SEGMENTS] joints;\n    \n    // Initialize joints\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        joints[i].pos = base;\n        joints[i].angle = 0.0;\n    }\n    \n    vec2 toTarget = target - base;\n    float targetDist = length(toTarget);\n    float maxReach = SEGMENT_LENGTH * 2.0; // Maximum reach for 2 segments\n    \n    // Clamp target to maximum reach\n    if(targetDist > maxReach) {\n        toTarget = (toTarget / targetDist) * maxReach;\n        targetDist = maxReach;\n        target = base + toTarget;\n    }\n    \n    // Minimum distance to prevent numerical issues\n    targetDist = max(targetDist, 0.001);\n    \n    // Calculate angles using cosine law\n    float a = SEGMENT_LENGTH;\n    float b = SEGMENT_LENGTH;\n    float c = targetDist;\n    \n    float angle1 = acos(clamp((a*a + c*c - b*b)/(2.0*a*c), -1.0, 1.0));\n    float angle2 = acos(clamp((a*a + b*b - c*c)/(2.0*a*b), -1.0, 1.0));\n    \n    // Base angle\n    float baseAngle = atan(toTarget.y, toTarget.x);\n    \n    // Set joint positions\n    joints[0].pos = base;\n    joints[0].angle = baseAngle - angle1;\n    \n    joints[1].pos = base + vec2(cos(joints[0].angle), sin(joints[0].angle)) * SEGMENT_LENGTH;\n    joints[1].angle = joints[0].angle + PI - angle2;\n    \n    joints[2].pos = joints[1].pos + vec2(cos(joints[1].angle), sin(joints[1].angle)) * SEGMENT_LENGTH;\n    \n    return joints;\n}\n\n// FABRIK IK (your original implementation)\nJoint[NUM_SEGMENTS] solveFABRIK(vec2 target, vec2 base) {\n    Joint[NUM_SEGMENTS] joints;\n    \n    // Initialize joints\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        joints[i].pos = base + vec2(float(i) * SEGMENT_LENGTH, 0.0);\n        joints[i].angle = 0.0;\n    }\n    \n    for(int iter = 0; iter < 10; iter++) {\n        // Forward reaching\n        joints[NUM_SEGMENTS-1].pos = target;\n        \n        for(int i = NUM_SEGMENTS-2; i >= 0; i--) {\n            vec2 dir = normalize(joints[i].pos - joints[i+1].pos);\n            joints[i].pos = joints[i+1].pos + dir * SEGMENT_LENGTH;\n        }\n        \n        // Backward reaching\n        joints[0].pos = base;\n        \n        for(int i = 1; i < NUM_SEGMENTS; i++) {\n            vec2 dir = normalize(joints[i].pos - joints[i-1].pos);\n            joints[i].pos = joints[i-1].pos + dir * SEGMENT_LENGTH;\n        }\n    }\n    \n    // Calculate angles\n    for(int i = 0; i < NUM_SEGMENTS-1; i++) {\n        vec2 dir = joints[i+1].pos - joints[i].pos;\n        joints[i].angle = atan(dir.y, dir.x);\n    }\n    \n    return joints;\n}\n\n// CCD (Cyclic Coordinate Descent) IK\nJoint[NUM_SEGMENTS] solveCCD(vec2 target, vec2 base) {\n    Joint[NUM_SEGMENTS] joints;\n    \n    // Initialize joints\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        joints[i].pos = base + vec2(float(i) * SEGMENT_LENGTH, 0.0);\n        joints[i].angle = 0.0;\n    }\n    \n    for(int iter = 0; iter < 10; iter++) {\n        for(int i = NUM_SEGMENTS-2; i >= 0; i--) {\n            vec2 toEndEffector = joints[NUM_SEGMENTS-1].pos - joints[i].pos;\n            vec2 toTarget = target - joints[i].pos;\n            \n            float currentAngle = atan(toEndEffector.y, toEndEffector.x);\n            float targetAngle = atan(toTarget.y, toTarget.x);\n            \n            float rotation = targetAngle - currentAngle;\n            \n            // Apply rotation to all children\n            for(int j = i+1; j < NUM_SEGMENTS; j++) {\n                vec2 toChild = joints[j].pos - joints[i].pos;\n                float len = length(toChild);\n                float angle = atan(toChild.y, toChild.x) + rotation;\n                joints[j].pos = joints[i].pos + len * vec2(cos(angle), sin(angle));\n            }\n        }\n    }\n    \n    return joints;\n}\n\n// Jacobian Inverse IK\nJoint[NUM_SEGMENTS] solveJacobianIK(vec2 target, vec2 base) {\n    Joint[NUM_SEGMENTS] joints;\n    \n    // Initialize joints in a straight line\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        joints[i].pos = base + vec2(float(i) * SEGMENT_LENGTH, 0.0);\n        joints[i].angle = 0.0;\n    }\n    \n    float maxReach = SEGMENT_LENGTH * float(NUM_SEGMENTS);\n    float tolerance = 0.01;\n    float alpha = 0.5;\n    \n    // Clamp target to max reach\n    vec2 toTarget = target - base;\n    float targetDist = length(toTarget);\n    if(targetDist > maxReach) {\n        toTarget = normalize(toTarget) * maxReach;\n        target = base + toTarget;\n    }\n    \n    for(int iter = 0; iter < 20; iter++) {\n        vec2 endEffector = joints[NUM_SEGMENTS-1].pos;\n        vec2 error = target - endEffector;\n        \n        if(length(error) < tolerance) break;\n        \n        // Adaptive learning rate\n        float currentError = length(error);\n        alpha = min(0.5, currentError * 2.0);\n        \n        // Prioritize last joints\n        for(int i = NUM_SEGMENTS-2; i >= 0; i--) {\n            vec2 toEnd = endEffector - joints[i].pos;\n            float len = length(toEnd);\n            \n            if(len > 0.001) {\n                // More robust Jacobian column\n                vec2 jacobianCol = vec2(-toEnd.y, toEnd.x) / len;\n                \n                // Error projection with adaptive learning\n                float deltaAngle = clamp(\n                    dot(error, jacobianCol) * alpha, \n                    -0.5, // Limit rotation\n                    0.5\n                );\n                \n                // Rotate and update downstream joints\n                for(int j = i + 1; j < NUM_SEGMENTS; j++) {\n                    vec2 toChild = joints[j].pos - joints[i].pos;\n                    float childLen = length(toChild);\n                    float currentAngle = atan(toChild.y, toChild.x);\n                    float newAngle = currentAngle + deltaAngle;\n                    \n                    joints[j].pos = joints[i].pos + childLen * vec2(cos(newAngle), sin(newAngle));\n                }\n                \n                // Update end effector\n                endEffector = joints[NUM_SEGMENTS-1].pos;\n            }\n        }\n    }\n    \n    // Calculate final angles\n    for(int i = 0; i < NUM_SEGMENTS-1; i++) {\n        vec2 dir = joints[i+1].pos - joints[i].pos;\n        joints[i].angle = atan(dir.y, dir.x);\n    }\n    \n    return joints;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    // Determine which quadrant we're in\n    vec2 quadrantUV = uv;\n    vec2 quadrantMouse = mouse;\n    vec2 base = vec2(0.0);\n    Joint[NUM_SEGMENTS] joints;\n    vec3 quadrantColor;\n    vec2 defaultTarget;\n    \n    // Scale and offset UV and mouse for each quadrant\n    if(uv.x < 0.0) {\n        if(uv.y > 0.0) {\n            // Top Left - Analytical IK\n            quadrantUV = (uv - vec2(-1.0, 1.0)) * 1.0;\n            base = vec2(-0.2, -0.5);  // Moves the armature\n            defaultTarget = base + vec2(SEGMENT_LENGTH * 2.0, 0.0);\n            \n            if(mouse.x < 0.0 && mouse.y > 0.0) {\n                quadrantMouse = (mouse - vec2(-1.0, 1.0)) * 1.0;\n                joints = solveAnalyticalIK(quadrantMouse, base);\n            } else {\n                joints = solveAnalyticalIK(defaultTarget, base);\n            }\n            quadrantColor = vec3(1.0, 0.5, 0.5);\n        } else {\n            // Bottom Left - CCD IK\n            quadrantUV = (uv - vec2(-1.0, -1.0)) * 1.0;\n            base = vec2(-0.2, 0.5);  // Moves the armature\n            defaultTarget = base + vec2(SEGMENT_LENGTH * 2.0, 0.0);\n            \n            if(mouse.x < 0.0 && mouse.y <= 0.0) {\n                quadrantMouse = (mouse - vec2(-1.0, -1.0)) * 1.0;\n                joints = solveCCD(quadrantMouse, base);\n            } else {\n                joints = solveCCD(defaultTarget, base);\n            }\n            quadrantColor = vec3(0.5, 1.0, 0.5);\n        }\n    } else {\n        if(uv.y > 0.0) {\n            // Top Right - FABRIK IK\n            quadrantUV = (uv - vec2(1.0, 1.0)) * 1.0;\n            base = vec2(-0.2, -0.5);  // Moves the armature\n            defaultTarget = base + vec2(SEGMENT_LENGTH * 2.0, 0.0);\n            \n            if(mouse.x >= 0.0 && mouse.y > 0.0) {\n                quadrantMouse = (mouse - vec2(1.0, 1.0)) * 1.0;\n                joints = solveFABRIK(quadrantMouse, base);\n            } else {\n                joints = solveFABRIK(defaultTarget, base);\n            }\n            quadrantColor = vec3(0.5, 0.5, 1.0);\n        } else {\n            // Bottom Right - Jacobian IK\n            quadrantUV = (uv - vec2(1.0, -1.0)) * 1.0;\n            base = vec2(-0.2, 0.5);  // Moves the armature\n            defaultTarget = base + vec2(SEGMENT_LENGTH * 2.0, 0.0);\n            \n            if(mouse.x >= 0.0 && mouse.y <= 0.0) {\n                quadrantMouse = (mouse - vec2(1.0, -1.0)) * 1.0;\n                joints = solveJacobianIK(quadrantMouse, base);\n            } else {\n                joints = solveJacobianIK(defaultTarget, base);\n            }\n            quadrantColor = vec3(1.0, 1.0, 0.5);\n        }\n    }\n    \n    // Draw segments and joints\n    float color = 0.0;\n    \n    // Draw segments\n    for(int i = 0; i < NUM_SEGMENTS-1; i++) {\n        color += drawLine(quadrantUV, joints[i].pos, joints[i+1].pos, 0.005);\n    }\n    \n    // Draw joints\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        color += drawCircle(quadrantUV, joints[i].pos, JOINT_RADIUS);\n    }\n    \n    // Set final color\n    vec3 finalColor = vec3(0.1); // Background color\n    \n    // Add grid lines\n    float gridLine = smoothstep(0.002, 0.0, abs(uv.x)) + smoothstep(0.002, 0.0, abs(uv.y));\n    finalColor = mix(finalColor, vec3(0.2), gridLine);\n    \n    // Add IK visualization\n    if(color > 0.0) {\n        finalColor = quadrantColor;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}