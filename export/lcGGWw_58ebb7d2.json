{"ver":"0.1","info":{"id":"lcGGWw","date":"1712836595","viewed":52,"name":"task22","username":"DmKo","description":"dsakm","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int n=8;\nvec3 color_arr[n] = vec3[n](\n    vec3(0.0, 0.0 , 1.0),\n    vec3(.0, .5, 0.0),\n    vec3(0., 5.0, 0.0),\n    vec3(0.0, 0.5, 0.0),\n    vec3(0.0, .2, .0),\n    vec3(.0, .8, 0.0),\n    vec3(0.52, 0.52, 0.52),\n    vec3(0.0, 1.0 , 1.0)\n);\nvec3 BackColor = vec3(1.0,1.0, 1.);\nint inds[n + 1] = int[n + 1](0, 4, 8, 12, 16, 20, 24, 28, 32);\nconst int m = 39;\nfloat wave(float x, float y, float time) {\n    return sin(x * 5.0 + time) * sin(y * 5.0 + time);\n}\nvec3 points[m], normal;\nvoid initPolygons(out vec3 points[m], in float time)\n{\n    float cosTime = cos(time);\n    float sinTime = sin(time);\n    float sizeFactor = 1.0;\n\n    points[0] = vec3(0.3 * sizeFactor + 0.2 * cosTime - 0.2, 0.1 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n    points[1] = vec3(0.1 * sizeFactor + 0.2 * cosTime - 0.2, 0.0 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[2] = vec3(0.4 * sizeFactor + 0.2 * cosTime - 0.2, 0.0 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[3] = vec3(0.6 * sizeFactor + 0.2 * cosTime - 0.2, 0.1 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n\n    points[4] = vec3(0.4 * sizeFactor + 0.2 * cosTime - 0.2, 0.0 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[5] = vec3(0.6 * sizeFactor + 0.2 * cosTime - 0.2, 0.1 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n    points[6] = vec3(0.7 * sizeFactor + 0.2 * cosTime - 0.2, 0.3 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n    points[7] = vec3(0.5 * sizeFactor + 0.2 * cosTime - 0.2, 0.2 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor);\n\n    points[8] = vec3(0.3 * sizeFactor + 0.2 * cosTime - 0.2, 0.1 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n    points[9] = vec3(0.6 * sizeFactor + 0.2 * cosTime - 0.2, 0.1 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n    points[10] = vec3(0.7 * sizeFactor + 0.2 * cosTime - 0.2, 0.3 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n    points[11] = vec3(0.4 * sizeFactor + 0.2 * cosTime - 0.2, 0.3 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor);\n\n    points[12] = vec3(0.3 * sizeFactor + 0.2 * cosTime - 0.2, 0.1 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor);\n    points[13] = vec3(0.4 * sizeFactor + 0.2 * cosTime - 0.2, 0.3 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor);\n    points[14] = vec3(0.2 * sizeFactor + 0.2 * cosTime - 0.2, 0.2 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor);\n    points[15] = vec3(0.1 * sizeFactor + 0.2 * cosTime - 0.2, 0.0 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor);\n\n    points[16] = vec3(0.1 * sizeFactor + 0.2 * cosTime - 0.2, 0.0 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[17] = vec3(0.4 * sizeFactor + 0.2 * cosTime - 0.2, 0.0 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[18] = vec3(0.5 * sizeFactor + 0.2 * cosTime - 0.2, 0.2 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[19] = vec3(0.2 * sizeFactor + 0.2 * cosTime - 0.2, 0.2 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n\n    points[20] = vec3(0.2 * sizeFactor + 0.2 * cosTime - 0.2, 0.2 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[21] = vec3(0.5 * sizeFactor + 0.2 * cosTime - 0.2, 0.2 * sizeFactor + 0.1 * sinTime, 0.4 * sizeFactor); \n    points[22] = vec3(0.7 * sizeFactor + 0.2 * cosTime - 0.2, 0.3 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n    points[23] = vec3(0.4 * sizeFactor + 0.2 * cosTime - 0.2, 0.3 * sizeFactor + 0.1 * sinTime, 0.0 * sizeFactor); \n\n    points[24] = vec3(0.15 - 0.3 * cos(time), 0.35 + 0.3 * sin(time), -0.45 - 0.9 * sin(time)); \n    points[25] = vec3(-0.15 - 0.3 * cos(time), 0.35 + 0.3 * sin(time), -0.45 - 0.9 * sin(time)); \n    points[26] = vec3(-0.15 - 0.3 * cos(time), 0.05 + 0.3 * sin(time), 0.15 - 0.9 * sin(time)); \n    points[27] = vec3(0.15 - 0.3 * cos(time), 0.05 + 0.3 * sin(time), 0.15 - 0.9 * sin(time)); \n}\n\n\nbool inPolygon( in vec2 vector, in int num)\n{  \n    int size = inds[num + 1] - inds[num], start = inds[num], i;\n    vec2 a;\n    vec2 b;\n    for(i = start; i < size + start - 1; i++)\n    {\n        a = vec2(points[i + 1].x - points[i].x, points[i + 1].y - points[i].y);\n        b = vec2(vector.x - points[i].x, vector.y - points[i].y);\n        if ( a.x * b.y - b.x * a.y  < 0.0) \n            { return false; }\n    }\n   a = vec2(points[start].x - points[i].x, points[start].y - points[i].y);\n   b = vec2(vector.x - points[i].x, vector.y - points[i].y);\n   if ( a.x * b.y - b.x * a.y  < 0.0) \n            { return false; }\n   \n   return true;   \n}\n\nfloat sphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat height(int i, vec3 polygons[m], float x, float y)\n{\n         float z, D, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;\n         x1 = points[inds[i]].x;\n         x2 = points[inds[i] + 1].x;\n         x3 = points[inds[i] + 2].x;\n         y1 = points[inds[i]].y;\n         y2 = points[inds[i] + 1].y;\n         y3 = points[inds[i] + 2].y;\n         z1 = points[inds[i]].z;\n         z2 = points[inds[i] + 1].z;\n         z3 = points[inds[i] + 2].z; \n         normal = cross(vec3(x2-x1, y2-y1, z2-z1), vec3(x3-x1,y3-y1,z3-z1)); \n         D = -normal.x * x1 - normal.y * y1 - normal.z * z1;\n         z = (-normal.x * x - normal.y * y - D)/ normal.z; \n         return z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const vec3 color = vec3(.9, .67, .9);\n    vec2 resolution = iResolution.xy;\n    float time = iTime;\n    vec2 square1 = vec2(0.1 + 0.5 * cos(1.0 * time), 0.9);\n    vec2 square4 = vec2(0.9 + 0.3 * cos(0.3 * time), 0.9);\n    vec2 square4Size = vec2(0.1 * resolution.x, 0.1 * resolution.y); \n    vec2 square4TopLeft = square4 - square4Size * 0.5; \n    vec2 square4BottomRight = square4 + square4Size * 0.5; \n    vec3 squarecolor1 = vec3(0.5 + 0.5 * cos(time), 0.1, 0.5); \n    vec3 squarecolor4 = vec3(0.2, 0.5, 0.5); \n    vec2 uv = fragCoord/iResolution.xy-0.2; \n    initPolygons(points, iTime);\n    vec3 backgroundColor = 0.9 +0.1 + 0.1 * sin(50.*time + fragCoord.xyx * 0.1 + length(fragCoord.yx) * 0.1);\n    vec3 col = backgroundColor;\n    float maxZ = -100.0, x = uv.x, y = uv.y, z = maxZ;\n    float squareSize = 0.08 * resolution.x;\n    \n    if (abs(fragCoord.x - resolution.x * square1.x) < squareSize && abs(fragCoord.y - resolution.y * square1.y) < squareSize) {\n        col = squarecolor1;\n    }\n    if (abs(fragCoord.x - resolution.x * square4.x) < squareSize && abs(fragCoord.y - resolution.y * square4.y) < squareSize) {\n        float waveIntensity = 0.5;\n        float waveValue = wave(fragCoord.x, fragCoord.y, time);\n        col = squarecolor4 + vec3(waveValue) * waveIntensity;\n    }\n    for(int i = 1; i < n; i++){\n     if (inPolygon(uv, i))\n     {\n         z = height(i, points, x, y);\n         if (z >= maxZ)\n         {\n             col = color_arr[i];\n             maxZ = z;\n         }\n      }\n     }\n\n    vec2 Circlecenter = vec2(0.9, 0.1 + 0.1 * sin(0.5 * time));\n    float Circleradius = 0.05;\n    float distToRedCircleTop = length(fragCoord - Circlecenter * resolution);\n    if (distToRedCircleTop < Circleradius * resolution.x) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n\n     fragColor = vec4(col, 1.0); \n}\n","name":"Image","description":"","type":"image"}]}