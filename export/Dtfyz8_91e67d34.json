{"ver":"0.1","info":{"id":"Dtfyz8","date":"1691750563","viewed":13,"name":"Rain Bokeh","username":"HexPrism33","description":"tutorial shader 2","likes":0,"published":1,"flags":64,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Md3GWH","filepath":"https://soundcloud.com/spartan-commander-118/far-cry-5-soundtrack-menu-music-when-the-morning-light-shines-in?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/spartan-commander-118/far-cry-5-soundtrack-menu-music-when-the-morning-light-shines-in?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Implementation of Tutorial by Art of Code\n#define S(a, b, t) smoothstep(a, b, t)\n\nstruct ray\n{\n   vec3 o,d;\n};\n\n\nfloat N(float t)\n{\n   return fract(sin(t*3456.0)*6547.0);\n}\n\n\nvec4 N14(float t)\n{\n   return fract(sin(t*vec4(3456.0,818.0,1865.0,9832.0))*vec4(6547.0,2767.0,3679.0,1564.0));\n}\n\nray getRay(vec2 uv,vec3 camPos, vec3 lookAt, float zoom)\n{\n   ray a;\n   a.o = camPos;\n   vec3 f = normalize(lookAt - camPos);\n   vec3 r = normalize(cross(f,vec3(0.0,1.0,0.0)));\n   vec3 u = cross(r,f);\n   vec3 c = a.o + f * zoom;\n   //intersection point is basically converting uv coords\n   //based on center\n   vec3 i = c + uv.x * r + uv.y * u; \n\n   a.d = normalize(i - a.o);\n   return a;\n}\n\nvec3 closestPoint(ray r, vec3 p)\n{\n   //gives closest point int the ray to p\n   vec3 pDir = p - r.o;\n   vec3 point = r.o + max(0.0,dot(r.d,pDir))*r.d;\n   return point;\n}\n\nfloat distRay(ray r, vec3 p)\n{\n   // returns distance between ray and point\n   return length(p - closestPoint(r,p));\n}\n\nfloat Bokeh(ray r, vec3 p, float size, float blur)\n{ \n   float d = distRay(r, p);\n   //Multiplying by length of vectorp\n   //length of p is larger in further points in camera thus size \n   //gets offseted accordingly\n   size *= length(p);\n   float c = S(size,size*(1.0-blur),d);\n   c *= mix(.7,1.,S(size*0.8,size,d));\n   return c;\n\n}\n\nvec3 streetLights(ray r,float t)\n{\n\n   float side = step(r.d.x,0.0);//Read doc mat3\n   //side = 1 if r.d.x < 0 ==> for left side\n   r.d.x = -abs(r.d.x);//Mirroring the lights\n\n\n   float offset = 100.0;\n   float m = 0.;\n   float s = .1;\n   for(float i = 0.0;i<1.0;i+=s)\n   {\n      float ti = fract(t+i+s*side*.5);\n      //See Documentation ( 1 )\n      vec3 p = vec3(-3.0,2.0,(100.0-ti*offset));\n      //See Documentation ( 2 )\n      m += Bokeh(r,p,0.05,0.1)*ti*ti*ti;\n   }\n   vec3 col = vec3(1.0,.7,.3)*m;\n\n   return col;\n}\n\n\nvec3 headLights(ray r,float t)\n{\n   t*=2.0;\n   float offset = 100.0;\n   float w1 = .25;\n   float w2 = w1*1.2;\n   float m = 0.;\n   float s = 1./30.0;\n   for(float i = 0.0;i<1.0;i+=s)\n   {\n      if(N(i)>0.1)\n         continue;\n      float ti = fract(t+i);\n      //See Documentation ( 1 )\n      float z =100.0-ti*offset;\n      float fade = ti*ti*ti*ti*ti;\n      //See Documentation ( 2 )\n\n      float focus = S(.9,1.,ti);\n      float size = mix(.05,.03,focus);\n      m += Bokeh(r,vec3(1.0 - w1,.15,z),size,0.1)*fade;\n      m += Bokeh(r,vec3(1.0 + w1,.15,z),size,0.1)*fade;\n\n      //headLight is composed of 2 dots and will give shape \n      m += Bokeh(r,vec3(1.0 - w2,.15,z),size,0.1)*fade;\n      m += Bokeh(r,vec3(1.0 + w2,.15,z),size,0.1)*fade;\n\n      float ref = 0.;\n\n      ref += Bokeh(r,vec3(1.0 - w2,-.15,z),size*3.,1.)*fade;\n      ref += Bokeh(r,vec3(1.0 + w2,-.15,z),size*3.,1.)*fade;\n\n      m+= ref*focus;\n   }\n   vec3 col = vec3(.9,.9,1.)*m;\n\n   return col;\n}\n\n\n\nvec3 tailLights(ray r,float t)\n{\n   t*=.25;\n   float offset = 100.0;\n   float w1 = .25;\n   float w2 = w1*1.2;\n   float m = 0.;\n   float s = 1./15.0;\n   for(float i = 0.0;i<1.0;i+=s)\n   {\n      float n = N(i);\n      if(n > 0.5)\n         continue;\n\n      float lane = step(0.25, n);//0 or 1  \n      float ti = fract(t+i);\n      //See Documentation ( 1 )\n      float z =100.0-ti*offset;\n      float fade = ti*ti*ti*ti*ti;\n      //See Documentation ( 2 )\n\n      float focus = S(.9,1.,ti);\n      float size = mix(.05,.03,focus);\n      float laneShift = S(1.0,0.96,ti);\n      float x = -1.5 + lane*laneShift;\n      float blink = step(0.0,sin(501.0*t))*lane*step(.96,ti);\n      m += Bokeh(r,vec3(x - w1,.15,z),size,0.1)*fade;\n      m += Bokeh(r,vec3(x + w1,.15,z),size,0.1)*fade;\n\n      //headLight is composed of 2 dots and will give shape \n      m += Bokeh(r,vec3(x + w2,.15,z),size,0.1)*fade;\n      //Left most light blinks\n      m += Bokeh(r,vec3(x - w2,.15,z),size,0.1)*fade*(1.0 + blink);\n\n      float ref = 0.;\n\n      ref += Bokeh(r,vec3(x + w2,-.15,z),size*3.,1.)*fade;\n      ref += Bokeh(r,vec3(x - w2,-.15,z),size*3.,1.)*fade*(1.0+blink);\n\n      m+= ref*focus;\n   }\n   //see Documentation ( 3 )\n   vec3 col = vec3(.9,.1,.03)*m;\n\n   return col;\n}\n\n\nvec3 EnvLights(ray r,float t)\n{\n\n   float side = step(r.d.x,0.0);//Read doc mat3\n   //side = 1 if r.d.x < 0 ==> for left side\n   r.d.x = -abs(r.d.x);//Mirroring the lights\n\n\n   float offset = 50.0;\n   vec3 c = vec3(0.);\n   float s = .1;\n   vec3 col = vec3(0.0); \n   for(float i = 0.0;i<1.0;i+=s)\n   {\n      float ti = fract(t+i+s*side*.5);\n      vec4 n = N14(i+side*100.0);\n      float fade = ti*ti; \n      float occlusion = sin(ti*6.28*10.0*n.x)*0.5 + 0.5;\n      fade *= occlusion;\n      //See Documentation ( 1 )\n      float x = mix(-2.5,-10.0,n.x);\n      float y = mix(.1,1.5,n.y);\n      vec3 p = vec3(x,y,(50.0-ti*offset));\n      //See Documentation ( 2 )\n      col = n.wzy;\n      c += Bokeh(r,p,0.05,0.3)*fade*col*fade;\n   }\n   // vec3 col =  vec3(1.0,.7,.3)*m;\n\n   return c;\n}\n\nvec2 rain(vec2 uv, float t)\n{\n   t*=40.0;\n   //Magic Function \n   //sin(x+sin(x+sin(x)*0.5)) (Increases first but devreases slowly)\n   vec2 aspect = vec2(3.,1.);//set an aspect for stretchy box\n   vec2 st = uv*aspect;\n   vec2 id = floor(st);//Helps to create an id \n   //fract eliminates whole part but the whole part itself is id\n   st.y += t*.22;\n   //make a sudo random offset for each frame\n   float n = fract(sin(id.x*737.24)*958.45);\n   st.y += n;\n   uv.y += n;\n   //st.x += n/8.0;\n   uv.x += n * 0.5;\n   id = floor(st);\n   st = fract(st)-0.5;//Fract here create multiple screens\n\n\n   //6.28 is multiplied to fix phase problems\n   t +=  fract(sin(id.x * 67.24 + id.y * 1453.7)*958.45)*6.28;\n\n   //decreases fast but Increases slowly\n   float y = -sin(t+sin(t+sin(t)*0.5))*0.42;\n   vec2 p = vec2(-0.3+n*0.5,y);\n   vec2 o1 = (st-p)/aspect;\n   float d = length(o1);\n\n   float drops = 0.0;\n   float m1 = S(0.07,0.0,d);\n\n\n   vec2 o2 = (fract(uv *aspect.x* vec2(1.0,2.0))-0.5)/vec2(1.0,2.0);\n   d = length(o2);\n   float m2 = S(.3*(0.5 - st.y),.0,d) * step(.1,st.y-p.y); \n\n   //if(st.x > 0.46 || st.y > 0.49)\n      //m1 = 1.0;//debug lines\n      \n   // drops += ;\n   // drops += ;\n   //We need distortion so we will output offsets\n   return vec2(m1*o1*30.0 + m2*o2*30.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n   uv -= 0.5;\n   uv.x *= iResolution.x/iResolution.y;\n   \n   vec2 m = iMouse.xy/iResolution.xy;\n\n\n   vec3 camPos = vec3(-0.5, .2, .0);\n   vec3 dir = vec3(-.25-iTime/100.0, .2, 1.0);\n\n   float t = iTime*.03 + m.x;//adding m.x helps scale time using mouse\n   vec2 rainDistort = rain(uv*5.0,t)*0.25;\n   rainDistort += rain(uv*6.5,t)*0.25;\n   \n   uv.x += sin(uv.y*70.0)*.005;\n   uv.y += sin(uv.x*170.0)*0.003;\n   \n   ray r = getRay(uv - rainDistort*0.5,camPos,dir,2.0);\n\n   vec3 col = streetLights(r,t);\n   col += headLights(r,t); \n   col += tailLights(r,t);\n   col += EnvLights(r,t);\n   col += (r.d.y+0.1)*vec3(0.3,0.3,0.75);\n\n   //col = vec3(rainDistort,0.0);\n   fragColor = vec4(col,1.0);\n}\n\n\n/*\nDOCUMENTATION \n\n1) fract funtion\n      fract function (float x) == gives only the fractional part of the value\n      eg : fract(2.5) = .5\n\n2) Multiplying by a  fraction b/w 0 and 1\n      Multiplying once ==> linear decrease\n      Multiplying twice ==> quadratic decrease\n      Multiplying thrice ==> cubic decrease\n\n\n3) step funtion\n   syntax -> step(float edge, float x)\n      returns 0 if(edge > x)\n      return 1 if(edge < x)\n\n      ie: a smoothstep without smoot part...\n\n4)Hiding one color on other vec3(.9,.1,.03) \n      since b value is less than g value \n      when it is scaled the difference becomes very prominent\n      leading to an entirely new color\n      Since r is very big it does not contribute\n      when it is more than one\n*/\n","name":"Image","description":"","type":"image"}]}