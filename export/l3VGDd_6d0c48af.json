{"ver":"0.1","info":{"id":"l3VGDd","date":"1718461098","viewed":70,"name":"Kaleidoscope by Volbla","username":"Volbla","description":"Simulating a kaleidoscope by bouncing rays off long mirrors.\n\nz up.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_REFLECTIONS 20\n\n\nvec3 reflections(vec3 p, vec3 v, vec3[3] N, float d) {\n    int i, j;\n    float t, t0;\n    vec3 n;\n    \n    for (i = 0; i < MAX_REFLECTIONS; i++) {\n        t = -1.;\n        \n        for (j = 0; j < 3; j++) {\n            // (p + v*t)*N = d\n            t0 = (d - dot(p, N[j])) / dot(v, N[j]);\n            \n            if (0. < t0 && (t0 < t || t == -1.)) {\n                t = t0;\n                n = N[j];\n            }\n        }\n        if (0. < t && p.y + v.y*t < 1.) {\n            // If you go the full distance the same\n            // plane can be detected on the next iteration\n            // and the ray gets stuck.\n            p = p + v*t*0.999;\n            v = reflect(v, n);\n        } else {\n            break;\n        }\n    }\n    p = p + v*(1. - p.y)/v.y;\n    if (i == MAX_REFLECTIONS-1)\n        p -= 10.;\n    \n    return p;\n}\n\n\nmat2 rotation(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord*2. - iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 p = vec3(0);\n    vec3 v = normalize(vec3(uv.x, 1., uv.y));\n    // Three plane normals.\n    vec3[3] N = vec3[3](\n        vec3(0.5*sqrt(3.), 0, 0.5),\n        vec3(-0.5*sqrt(3.), 0, 0.5),\n        vec3(0, 0, -1.0)\n    );\n    // Their distance from the origin.\n    float d = mouse.y;\n    d = 0.1;\n    \n    \n    // Rotate the top right mirror.\n    // N[0].xz *= rotation(sin(0.5*iTime) / 12.);\n    \n    p = reflections(p, v, N, d);\n    p = p*0.5 + 0.5;\n    \n\n    if (all(greaterThan(p.xz, vec2(0))) && all(lessThan(p.xz, vec2(1))) ) {\n        // Rotate the texture.\n        p.xz *= rotation(0.07*iTime);\n        \n        fragColor = texture(iChannel0, p.xz);\n    } else\n        fragColor = vec4(vec3(0),1);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}