{"ver":"0.1","info":{"id":"stsXzr","date":"1625083923","viewed":125,"name":"Ann The Bee","username":"Pebaz","description":"First non-hello world SDF painting.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nHello World Shader\n\nWorks on Shadertoy and in the Visual Studio Code extension:\nhttps://github.com/actarian/vscode-glsl-canvas\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n// Cross-Platform SDF Header\n////////////////////////////////////////////////////////////////////////////////\n\n// Uncomment to deploy to Shadertoy\n#define SHADERTOY\n\n// Uncomment to deploy to Win32\n// #version 430 core\n// #define WIN32\n\n// -----------------------------------------------------------------------------\nvoid fragment(vec2 uv, out vec3 color);\n\n#ifdef SHADERTOY\n    #define resolution iResolution\n    #define time iTime\n    #define mouse\n\n    void mainImage(out vec4 out_color, in vec2 frag_coord)\n    {\n        vec2 uv = (2.0 * frag_coord.xy - resolution.xy) / resolution.y;\n        vec3 color = vec3(0);\n        fragment(uv, color);\n        out_color = vec4(color, 1);\n    }\n\n#elif defined(WIN32)\n    out vec4 color;\n\n    uniform vec2 resolution;\n    uniform float time;\n\n    void main()\n    {\n        vec2 uv = (2.0 * gl_FragCoord.xy - resolution.xy) / resolution.y;\n        vec3 final_color = vec3(0);\n        fragment(uv, final_color);\n        color = vec4(final_color, 1);\n    }\n\n#else  // VS Code\n    precision mediump float;\n\n    uniform vec2 u_resolution;\n    uniform float u_time;\n    uniform sampler2D u_texture_0;\n    uniform sampler2D u_texture_1;\n\n    #define resolution u_resolution\n    #define time u_time\n    #define mouse\n\n    void main()\n    {\n        vec2 uv = (2.0 * gl_FragCoord.xy - resolution.xy) / resolution.y;\n        vec3 color = vec3(0);\n        fragment(uv, color);\n        gl_FragColor = vec4(color, 1);\n    }\n#endif\n\nconst int max_steps = 100;\nconst float max_distance = 5.0;\nconst float surface_hit = 0.001;\nconst float epsilon = 0.001;\n\n#define WHITE 1\n#define BLACK 2\n#define LIGHT_BROWN 3\n#define BROWN 4\n#define YELLOW 5\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float length;\n};\n\nstruct Hit\n{\n    vec3 position;\n    float distance;\n    int object_type;\n    vec2 uv;\n    vec3 normal;\n};\n\nfloat sdf_sphere(const in vec3 point, const in vec3 origin, const in float radius)\n{\n    return length(point - origin) - radius;\n}\n\nfloat sdf_box(vec3 point, vec3 origin, vec3 bounds)\n{\n    vec3 dist = abs(point - origin) - bounds;\n    return length(\n        max(dist, 0.0)\n    ) + min(\n        max(dist.x, max(dist.y, dist.z)),\n        0.0\n    );\n}\n\nfloat sdf_line(vec3 point, vec3 point_a, vec3 point_b, float radius)\n{\n    vec3 a = point - point_a;\n    vec3 b = point_b - point_a;\n    float h = clamp(dot(a, b) / dot(b, b), 0.0, 1.0);\n    return length(a - b * h) - radius;\n}\n\nvec3 rotate_x(const in vec3 point, const in float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    vec3 result = vec3(\n        point.x,\n        c * point.y + s * point.z,\n        -s * point.y + c * point.z\n    );\n\n    return result;\n}\n\nvec3 rotate_y(const in vec3 point, const in float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    vec3 result = vec3(\n        c * point.x + s * point.z,\n        point.y,\n        -s * point.x + c * point.z\n    );\n\n    return result;\n}\n\nvec3 rotate_z(const in vec3 point, const in float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    vec3 result = vec3(\n        c * point.x + s * point.y,\n        -s * point.x + c * point.y,\n        point.z\n    );\n\n    return result;\n}\n\nHit get_closer_hit(Hit a, Hit b)\n{\n    if (a.distance <= b.distance)\n        return a;\n    else\n        return b;\n}\n\nmat3 skew(float skew_angle, const in vec3 a, const in vec3 b)\n{\n    skew_angle = tan(skew_angle);\n    float x = a.x * skew_angle;\n    float y = a.y * skew_angle;\n    float z = a.z * skew_angle;\n\n    return mat3(\n        x * b.x + 1.0, x * b.y, x * b.z,\n        y * b.x, y * b.y + 1.0, y * b.z,\n        z * b.x, z * b.y, z * b.z + 1.0\n    );\n}\n\n// float round_merge(float shape1, float shape2, float radius) {\n//     float2 intersectionSpace = float2(shape1 - radius, shape2 - radius);\n//     intersectionSpace = min(intersectionSpace, 0);\n//     return length(intersectionSpace) - radius;\n// }\n\nHit body(vec3 point)\n{\n    Hit result;\n\n    result.position = point;\n\n    vec3 sample_point = point;\n    vec3 a = vec3(0, 1.0, 0);\n    vec3 b = vec3(0, 0, -1.0);\n    float skew_angle = 0.2;\n\n    sample_point = skew(skew_angle, a, b) * sample_point;\n\n    vec3 head_point = vec3(0, 0.05, 0.3);\n    vec3 tail_point = vec3(0, 0, -0.3);\n    float roundness = 1.0;\n    float body = sdf_line(sample_point, head_point, tail_point, roundness);\n\n    result.distance = body;\n    result.object_type = YELLOW;\n\n    // Determine material based on point on body\n    if (distance(sample_point, head_point * 5.5) < 1.0001)\n    {\n        result.object_type = LIGHT_BROWN;\n    }\n\n    else if (distance(sample_point, head_point * 2.5) < 1.005)\n    {\n        result.object_type = BROWN;\n    }\n\n    // else if (distance(sample_point, tail_point) < 1.0005)\n    // {\n    //     result.object_type = WHITE;\n    // }\n\n    else if (distance(point, tail_point * 4.0) < 1.25)\n    {\n        result.object_type = BROWN;\n    }\n\n    // Face\n\n    float eye1 = sdf_sphere(point, vec3(-0.35, 0.1, 1.18), 0.1);\n    float highlight1 = sdf_sphere(point, vec3(-0.36, 0.12, 1.27), 0.01);\n\n    if (eye1 < result.distance)\n    {\n        result.distance = min(result.distance, eye1);\n        result.object_type = BLACK;\n\n        if (highlight1 < result.distance)\n        {\n            result.distance = highlight1;\n            result.object_type = WHITE;\n        }\n    }\n\n    float eye2 = sdf_sphere(point, vec3(0.35, 0.1, 1.18), 0.1);\n    float highlight2 = sdf_sphere(point, vec3(0.36, 0.12, 1.27), 0.01);\n\n    if (eye2 < result.distance)\n    {\n        result.distance = min(result.distance, eye2);\n        result.object_type = BLACK;\n\n        if (highlight2 < result.distance)\n        {\n            result.distance = highlight2;\n            result.object_type = WHITE;\n        }\n    }\n\n    float smile_base = sdf_sphere(point, vec3(0, 0, 1.16), 0.2);\n    float smile_cutout = sdf_sphere(point, vec3(0, -0.15, 1.16), 0.1);\n    float smile = max(-smile_base, smile_cutout);\n    // float smile = min(smile_base, smile_cutout);\n\n    if (smile < result.distance)\n    {\n        result.distance = min(result.distance, smile);\n        result.object_type = BLACK;\n    }\n\n    return result;\n}\n\nHit foot(vec3 point, vec3 point_a, vec3 point_b, float radius)\n{\n    Hit result;\n\n    result.position = point;\n\n    float line = sdf_line(point, point_a, point_b, radius);\n\n    result.distance = line;\n    result.object_type = BLACK;\n\n    return result;\n}\n\nfloat rounded_cylinder(vec3 point, vec3 origin, float ra, float rb, float h)\n{\n    point -= origin;\n    vec2 d = vec2(length(point.xz) - 2.0 * ra + rb, abs(point.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nHit wings(vec3 point)\n{\n    Hit result;\n\n    result.position = point;\n\n    // float sphere = sdf_sphere(point, vec3(0, 2, 0), 1.0);\n\n    // float sphere = length(point - vec3(0, 2, 0)) - 1.0;\n\n    // float wing = rounded_cylinder(rotate_x(point, 1.5), vec3(0, 1, 0), 0.5, 0.1, 0.5);\n\n    vec3 origin = rotate_x(vec3(0.8, 0.8, 0.55) - point, 1.5) + point;\n    float wing = rounded_cylinder(point, origin, 0.17, 0.01, 0.03);\n    float wing_cutout = rounded_cylinder(point, origin + vec3(0, 0.05, 0), 0.1, 0.01, 0.03);\n    wing = max(wing, -wing_cutout);\n\n    vec3 origin2 = rotate_x(vec3(-0.8, 0.8, 0.55) - point, 1.5) + point;\n    float wing2 = rounded_cylinder(point, origin2, 0.17, 0.01, 0.03);\n    float wing_cutout2 = rounded_cylinder(point, origin2 + vec3(0, 0.05, 0), 0.1, 0.01, 0.03);\n    wing2 = max(wing2, -wing_cutout2);\n\n    result.distance = min(wing, wing2);\n    result.object_type = WHITE;\n\n    return result;\n}\n\nHit scene(vec3 point)\n{\n    Hit result = foot(point, vec3(0), vec3(0, 0, -1.35), 0.05);\n\n    Hit foot1 = foot(point, vec3(0, 0, 0.15), vec3(-0.65, -0.65, 0.75), 0.1);\n    Hit foot2 = foot(point, vec3(0, 0, -0.1), vec3(-0.75, -0.75, 0.0), 0.1);\n    Hit foot3 = foot(point, vec3(0, 0, -0.55), vec3(-0.75, -0.75, -0.65), 0.1);\n\n    Hit foot4 = foot(point, vec3(0, 0, 0.15), vec3(0.65, -0.65, 0.75), 0.1);\n    Hit foot5 = foot(point, vec3(0, 0, -0.1), vec3(0.75, -0.75, 0.0), 0.1);\n    Hit foot6 = foot(point, vec3(0, 0, -0.55), vec3(0.75, -0.75, -0.65), 0.1);\n\n    Hit wings = wings(point);\n\n    result = get_closer_hit(result, body(point));\n    result = get_closer_hit(result, foot1);\n    result = get_closer_hit(result, foot2);\n    result = get_closer_hit(result, foot3);\n    result = get_closer_hit(result, foot4);\n    result = get_closer_hit(result, foot5);\n    result = get_closer_hit(result, foot6);\n\n    result = get_closer_hit(result, wings);\n\n    return result;\n}\n\nvec3 get_scene_normal(const in vec3 point)\n{\n    vec3 offset1 = vec3(epsilon, -epsilon, -epsilon);\n    float f1 = scene(point + offset1).distance;\n    vec3 normal = offset1 * f1;\n\n    vec3 offset2 = vec3(-epsilon, -epsilon, epsilon);\n    float f2 = scene(point + offset2).distance;\n    normal += offset2 * f2;\n\n    vec3 offset3 = vec3(-epsilon, epsilon, -epsilon);\n    float f3 = scene(point + offset3).distance;\n    normal += offset3 * f3;\n\n    vec3 offset4 = vec3(epsilon, epsilon, epsilon);\n    float f4 = scene(point + offset4).distance;\n    normal += offset4 * f4;\n\n    return normalize(normal);\n}\n\nHit raymarch(Ray ray)\n{\n    Hit closest;\n\n    for (int step = 0; step < max_steps; step++)\n    {\n        vec3 point = ray.origin + ray.direction * ray.length;\n        closest = scene(point);\n        closest.position = point;\n\n        if (closest.distance < surface_hit)\n            break;\n\n        ray.length += closest.distance;\n\n        if (ray.length >= max_distance)\n            break;\n    }\n\n    closest.distance = ray.length;\n    return closest;\n}\n\nvec3 render(Ray ray)\n{\n    vec3 color = vec3(0);\n\n    Hit hit = raymarch(ray);\n\n    if (hit.distance <= max_distance)\n    {\n        vec3 normal = get_scene_normal(hit.position);\n\n        if (hit.object_type == WHITE)\n        {\n            color = vec3(1.0) - normal.x;\n        }\n\n        else if (hit.object_type == BLACK)\n        {\n            // color = abs(get_scene_normal(hit.position));\n            color = vec3(0.15);\n        }\n\n        else if (hit.object_type == LIGHT_BROWN)\n        {\n            color = vec3(189, 153, 91) / 255.0;\n        }\n\n        else if (hit.object_type == BROWN)\n        {\n            color = vec3(0.27, 0.17, 0.09);\n        }\n\n        else if (hit.object_type == YELLOW)\n        {\n            color = vec3(1, 0.78, 0);\n        }\n\n        vec3 light_color = vec3(0.2, 0.5, 0.7);\n        vec3 light_dir = normalize(rotate_y(vec3(0, -0.25, 1), -1.25));\n        float diff = max(dot(normal, light_dir), 0.0);\n        float sky_energy = 1.7;\n        vec3 sky = diff * light_color * sky_energy;\n        // sky = vec3(0);\n\n        vec3 light_color2 = vec3(0.7, 0.5, 0.2);\n        vec3 light_dir2 = normalize(rotate_y(vec3(0, 0.25, 1), 1.0));\n        float diff2 = max(dot(normal, light_dir2), 0.0);\n        float sun_energy = 1.2;\n        vec3 sun = diff2 * light_color2 * sun_energy;\n        // sun = vec3(0);\n\n        vec3 light_color3 = vec3(1);\n        vec3 light_dir3 = normalize(rotate_y(vec3(0, 1, 4), 2.75));\n        float diff3 = max(dot(normal, light_dir3), 0.0);\n        float wormhole_energy = 0.5;\n        vec3 wormhole = diff3 * light_color3 * wormhole_energy;\n        // wormhole = vec3(0);\n\n        // float diff2 = max(dot(normal, light_dir2), 0.0);\n        // lighting += vec3(diff2) * 0.5 * vec3(0.7, 0.5, 0.2);\n\n        // color = albedo * lighting;\n\n        vec3 ambient = vec3(0.3);\n\n        color = color * (ambient + sun + sky + wormhole);\n    }\n\n    else\n    {\n        color = normalize(normalize(hit.position) + vec3(2));\n    }\n\n    return color;\n}\n\nRay get_camera_ray(\n    const in vec3 vPos,\n    const in vec3 vForwards,\n    const in vec3 vWorldUp,\n    const in vec2 uv\n) {\n    vec2 vUV = uv;\n    vec2 vViewCoord = vUV;// * 2.0 - 1.0;\n\n    // float fRatio = resolution.x / resolution.y;\n    // vViewCoord.y /= fRatio;\n\n    Ray ray;\n\n    ray.origin = vPos;\n\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n\n    ray.direction = normalize(\n        vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards\n    );\n\n    return ray;\n}\n\nRay look_at(\n    const in vec3 vPos,\n    const in vec3 vInterest,\n    const in vec2 uv\n) {\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    return get_camera_ray(vPos, vForwards, vUp, uv);\n}\n\nvoid fragment(vec2 uv, out vec3 color)\n{\n    // vec3 ray_origin = rotate_y(vec3(0, sin(time * 0.25) * 1.5, 2.5), cos(time));\n    vec3 ray_origin = rotate_y(vec3(0, sin(time * 0.2), 2.5), time * 0.4);\n\n    Ray ray = look_at(\n        ray_origin,\n        vec3(0),\n        uv\n    );\n\n    color = render(ray);\n}\n","name":"Image","description":"","type":"image"}]}