{"ver":"0.1","info":{"id":"MctyRn","date":"1730261542","viewed":69,"name":"Persistent State Physics v0","username":"8InfinityTaco8","description":"FINALLY figured out how to do a little bit of physics after playing around all day.\nUSE THE WASD Keys to move and bounce of off the walls.\nThe goal is to eventually make this a particle sim with fluid dynamics and different materials, but we'll see ","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["bounce","physics","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Image\n\n//USE THE WASD KEYS TO BOUNCE OFF OF THE WALLS\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Get the positional state from Buffer A\n    vec4 state = texture(iChannel0, vec2(0.5));\n    \n    // Convert pixel coordinates to UV space (-0.5 to 0.5)\n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    // Centered UV for circle\n    vec2 centeredUV = uv - state.xy;\n\n    // Render the circle using SDF\n    float d = sdCircle(centeredUV, CIRCLE_RADIUS);\n    vec3 col = vec3(step(0.0, -d));\n    \n    // Render the box edges\n    float distToBox = sdBox(uv, BOX_BOUND_MIN, BOX_BOUND_MAX);\n    if (abs(distToBox) < BOX_EDGE_THICKNESS) {\n        col += vec3(1.0, 0.0, 0.0); // Red box edges\n    }\n    \n    // Debug: Draw center point\n    float centerPoint = step(length(uv), 0.005);\n    col = mix(col, vec3(0.0, 1.0, 0.0), centerPoint); // Green center point\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// \"State\" buffer (Buffer A)\nbool isKeyPressed(int keyCode) {\n    return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x > 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 previousState = texture(iChannel0, uv);\n    \n    // Initialize on first frame\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n\n    vec2 position = previousState.xy;\n    vec2 velocity = previousState.zw;\n    \n    \n    /*note deltaTime is used instead of Frame time so the physics are frame independent.\n    If you want frame dependent physics then remove deltatime scaling on everything.\n    \n    Also if you do remoe the deltatime scaling you will have to go in the macros and change \n    the gravity and velocity values because they are no longer accounting for the scaling\n    */\n    \n    // Input-based acceleration\n    if (isKeyPressed(KEY_W)) velocity.y += ACCELERATION * deltaTime + INITIAL_VELOCITY_BOOST;\n    if (isKeyPressed(KEY_S)) velocity.y -= ACCELERATION * deltaTime + INITIAL_VELOCITY_BOOST;\n    if (isKeyPressed(KEY_A)) velocity.x -= ACCELERATION * deltaTime + INITIAL_VELOCITY_BOOST;\n    if (isKeyPressed(KEY_D)) velocity.x += ACCELERATION * deltaTime + INITIAL_VELOCITY_BOOST;\n    \n    // Apply gravity to y-velocity\n    velocity.y += -GRAVITY * deltaTime;\n\n    // Apply friction\n    velocity *= pow(FRICTION, deltaTime); \n\n    // Update position\n    position += velocity * deltaTime;\n    \n    // Boundary constraints considering circle radius and BOX VOUNDAEY\n    //position = clamp(position, BOX_BOUND_MIN + vec2(CIRCLE_RADIUS), BOX_BOUND_MAX - vec2(CIRCLE_RADIUS)); // Boundary con\n    \n      // Boundary constraints with bouncing effect\n    if (position.x < BOX_BOUND_MIN.x + CIRCLE_RADIUS) {\n        position.x = BOX_BOUND_MIN.x + CIRCLE_RADIUS; // Adjust position to stay within bounds\n        velocity.x = -velocity.x; // Reverse x velocity\n    } \n    else if (position.x > BOX_BOUND_MAX.x - CIRCLE_RADIUS) {\n        position.x = BOX_BOUND_MAX.x - CIRCLE_RADIUS; // Adjust position to stay within bounds\n        velocity.x = -velocity.x; // Reverse x velocity\n    }\n    \n    if (position.y < BOX_BOUND_MIN.y + CIRCLE_RADIUS) {\n        position.y = BOX_BOUND_MIN.y + CIRCLE_RADIUS; // Adjust position to stay within bounds\n        velocity.y = -velocity.y; // Reverse y velocity\n    } \n    else if (position.y > BOX_BOUND_MAX.y - CIRCLE_RADIUS) {\n        position.y = BOX_BOUND_MAX.y - CIRCLE_RADIUS; // Adjust position to stay within bounds\n        velocity.y = -velocity.y; // Reverse y velocity\n    }\n\n    // Write position and velocity back to the buffer\n    fragColor = vec4(position, velocity);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Common\n#define ACCELERATION .09\n\n//incread this vlaue to slow down quicker\n//decrease this value to keep velocity longer\n#define FRICTION 0.8\n#define GRAVITY 1.0\n\n// Adjust this value for desired movement speed when presing down the keys\n#define INITIAL_VELOCITY_BOOST 0.05 \n\n\n#define deltaTime iTimeDelta\n#define CIRCLE_RADIUS 0.05\n#define CIRCLE_BOUND_MIN CIRCLE_RADIUS\n#define CIRCLE_BOUND_MAX (1.0 - CIRCLE_RADIUS)\n\n#define BOX_BOUND_MIN vec2(-0.88, -0.49)\n#define BOX_BOUND_MAX vec2(0.88, 0.49)\n#define BOX_EDGE_THICKNESS .005\n\n\n#define KEY_W 87\n#define KEY_S 83\n#define KEY_A 65\n#define KEY_D 68\n\n\n// SDF for a circle\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// SDF for a box\nfloat sdBox(vec2 p, vec2 bMin, vec2 bMax) {\n    vec2 bCenter = (bMax + bMin) * 0.5;\n    vec2 bSize = (bMax - bMin) * 0.5;\n    vec2 d = abs(p - bCenter) - bSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n","name":"Common","description":"","type":"common"}]}