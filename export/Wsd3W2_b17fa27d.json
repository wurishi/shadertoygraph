{"ver":"0.1","info":{"id":"Wsd3W2","date":"1569322871","viewed":121,"name":"Cubic equation raymarch","username":"Blake447","description":"Given three roots to a cubic equation, raymarch it. This program showcases a framework thats been generalized to march some function f(x) given its derivative, second derivative, and a list of special points, including extrema and inflection points","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","de","function","cubic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 intersectionOfTwoLines(vec2 A, float sa, vec2 B, float sb);\nfloat sgn(float x);\nfloat LineHeight(float slope, vec2 point, float x);\nfloat Radians(float deg);\nvec4 float4(float x, float y, float z, float w);\nvec3 float3(float x, float y, float z);\nvec2 float2(float x, float y);\nvec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius);\nfloat sdfOfBound(vec3 Point, vec3 Center, vec2 Keys);\nfloat sdfFunction(vec3 Point, vec3 Center);\nfloat DE(vec3 p, vec3 c);\nfloat dSphere(vec3 pos, vec3 center, float radius);\n\n// So the idea of this shader is to raymarch some function given some information about it.\n// The relevant information consists of 3 functions, along with some bounds.\n// The three functions below define the function we are going to raymarch. df is the first\n// derivative of f, and ddf is the second derivative of f. Along with that, some bounds need to\n// be defined as well, but we'll get to that.\n\n\n// Return the roots of a cubic equation\nvec3 polynomial()\n{\n\t// define the roots of the cubic in here. This is case-wise, and is only used\n    // for cubic equations without repeating roots, as the first two derivatives\n    // and their respective roots can easily be expressed in terms of these roots.\n    // This means users can easily input just the roots and the code will take care\n    // of the rest.\n    float r1 = -4.0;\n    float r2 = 0.0;\n    float r3 = 4.0;\n    return vec3(r1, r2, r3);\n}\n\nfloat f(float x)\n{\n    // given the roots of the cubic, calculate the function of x.\n    // Again, this is specific to this family of cubic equations. For general functions,\n    // this will just be output explicitly\n    vec3 roots = polynomial();    \n    float r1 = -roots.x;\n    float r2 = -roots.y;\n    float r3 = -roots.z;\n    \n \treturn 0.1*(x+r1)*(x+r2)*(x+r3);   \n}\nfloat df(float x)\n{\n    // given the roots of the cubic, calculate the derivative of x.\n    // Another specific case. Will be output explicitly later\n    vec3 roots = polynomial();\n    float r1 = -roots.x;\n    float r2 = -roots.y;\n    float r3 = -roots.z;\n    \n    float A = r1 + r2 + r3;\n    float B = r1*r2 + r2*r3 + r3*r1;\n    \n    \n \treturn 0.1*(3.0*x*x + 2.0*x*A + B);   \n}\nfloat ddf(float x)\n{\n    // given the roots of the cubic, calculate the concavity of x\n    // Specific case\n    vec3 roots = polynomial();\n    float r1 = -roots.x;\n    float r2 = -roots.y;\n    float r3 = -roots.z;\n    \n    float A = r1 + r2 + r3;\n    float B = r1*r2 + r2*r3 + r3*r1;\n    \n \treturn 0.1*(6.0*x + 2.0*A);   \n}\n\n// Fetch some boundary. Basically return two adjacent special points (more on this later).\nvec2 GetBoundary(int i)\n{\n    // using the roots of the polynomial, we will determine extrema and inflection points\n    vec3 roots = polynomial();\n    float r1 = -roots.x;\n    float r2 = -roots.y;\n    float r3 = -roots.z;\n    \n    // specific case\n    float A = r1 + r2 + r3;\n    float B = r1*r2 + r2*r3 + r3*r1;\n    \n    float sp0 = -1000.0;\n    float sp1 = -A/3.0 - sqrt(A*A - 3.0*B)/3.0;\n    float sp2 = -A/3.0;\n    float sp3 = -A/3.0 + sqrt(A*A - 3.0*B)/3.0;\n    float sp4 = 1000.0;\n        \n    \n    if (i == 0)\n    {\n        return vec2(sp0, sp1);\n    }\n    if (i == 1)\n    {\n        return vec2(sp1, sp2);\n    }\n    if (i == 2)\n    {\n        return vec2(sp2, sp3);\n    }\n    if (i == 3)\n    {\n        return vec2(sp3, sp4);\n    }\n\n    return vec2(0.0,0.0);\n}\n\n// An SDF consisting of iterating through several portions of some function, to eventually\n// build it all together.\nfloat sdfFunction(vec3 Point, vec3 Center)\n{\n    const int POINT_COUNT = 5;\n\tfloat d = 100000.0;\n     \n    float x = Point.z - Center.z;\n       \n\tfor (int i = 0; i < POINT_COUNT - 1; i++)\n    {\n     \td = min(d, sdfOfBound(Point, Center, GetBoundary(i)));   \n    }\n    \n    return d;\n}\n\n\n\n\n///////////////////////////////\n///\t\t\t\t\t\t\t///\n///\t\tEnd of User Input\t///\n///\t\t\t\t\t\t\t///\n///////////////////////////////\n\n\n\n\n// Distance estimation for the scene\nfloat DE(vec3 p, vec3 c)\n{\n    float sphere = dSphere(p, c, 8.0);\n    float function = sdfFunction(p,c);\n    float d = max(sphere, function);\n    \n    return d;\n}\n\n\n// Distance estimation of the above function between two bounding points, which must be\n// adjacent points of the following categories: Extrema, Inflecta, vertical asymptotes.\n// \n// This is where the magic happens so to speak. It uses a combination of various tangent\n// lines and chords depending on what side of the function we're on, the concavity and slope\n// within the bounds given, and whether we are inside those bounds in the first place.\nfloat sdfOfBound(vec3 Point, vec3 Center, vec2 Keys)\n{\n\tvec3 pnt = Point - Center;\n    float h = pnt.z;\n    float k = pnt.y;\n    float a = Keys.x;\n    float b = Keys.y;\n\tfloat range = (b-a);\n    float half_range = range * 0.5;\n    float clamped_h = clamp(h, a, b);\n    vec2 A = vec2(h, k);\n    vec2 Bp = vec2(clamped_h, k);\n    vec2 Bf = vec2(clamped_h, f(clamped_h));\n    float concavity = sgn( ddf( a + half_range ) );\n\tfloat derivative = sgn( df(a + half_range) );    \n    bool clamped = (h < a || h > b);\n    if (clamped)\n    {\n     \tbool ctangent_method = (sgn(Bp.y - Bf.y)) != sgn( ddf( a + half_range ) );\n        float ct_slope = df(Bp.x);\n    \tvec2 ct_pnt = Bf;\n    \tvec2 ct_closest = intersectionOfTwoLines(ct_pnt, ct_slope, A, -1.0 / ct_slope);\n        float ct_dist = distance(ct_closest, A);\n        if (ct_closest.x < a || ct_closest.x > b)\n        {\n        \tct_dist = max(max(ct_dist, A.x - b), a - A.x);\n        }       \n        if (ctangent_method)\n        {\n         \treturn ct_dist;   \n        }\n\t\tfloat cch_samp_d = distance(A, Bf)* -sgn(A.x - Bp.x);\n\t    float cch_raw_Q = A.x + cch_samp_d;       \n\t    float cch_clamped_Q = clamp(cch_raw_Q, a, b);   \n        vec2 cch_P = Bf;\n\t    vec2 cch_Q = vec2(cch_clamped_Q, f(cch_clamped_Q));\n        float cch_slope = (cch_P.y - cch_Q.y) / (cch_P.x - cch_Q.x);\n    \tvec2 cch_pnt = cch_P;\n\t    vec2 cch_closest = intersectionOfTwoLines(cch_pnt, cch_slope, A, -1.0 / cch_slope);\n        if ( cch_closest.x < a || cch_closest.x > b)\n        {\n        \tcch_closest = vec2(clamp(cch_closest.x, a, b), f(clamp(cch_closest.x, a, b))); \n        }\n        float cch_dist = distance(cch_closest, A);\n        return cch_dist;      \n    }\n    bool tangent_method = (sgn(A.y - f(A.x)) != concavity);    \n    float t_slope = df(A.x);\n    vec2 t_pnt = vec2(A.x, f(A.x));\n    vec2 t_closest = intersectionOfTwoLines(t_pnt, t_slope, A, -1.0 / t_slope);\n    float t_dist = distance(t_closest, A);\n    float ch_samp_d = abs(f(A.x) - k) * sgn(df(A.x)) * sgn(ddf(a + half_range));   \n    float ch_raw_Q = A.x + ch_samp_d;       \n    float ch_clamped_Q = clamp(ch_raw_Q, a, b);   \n    vec2 ch_P = vec2(A.x, f(A.x));\n    vec2 ch_Q = vec2(ch_clamped_Q, f(ch_clamped_Q));\n    float ch_slope = (ch_P.y - ch_Q.y) / (ch_P.x - ch_Q.x);\n    vec2 ch_pnt = ch_P;\n    vec2 ch_closest = intersectionOfTwoLines(ch_pnt, ch_slope, A, -1.0 / ch_slope);\n    float ch_dist = distance(ch_closest, A);\n    if (tangent_method)\n    {\n     \treturn t_dist;   \n    }    \n    return ch_dist;\n}\n\n// A method for intersecting two lines in R-two.\nvec2 intersectionOfTwoLines(vec2 A, float sa, vec2 B, float sb)\n{\n\tfloat buffer = (sa*A.x - A.y - sb * B.x + B.y) / (sa - sb);\n\tvec2 intersection = float2(buffer, sa*(buffer - A.x) + A.y);\n\treturn intersection;\n}\n\n// evaluate the height of a line at some point x\nfloat LineHeight(float slope, vec2 point, float x)\n{\n \treturn slope*(x - point.x) + point.y;   \n}\n\n// Exact intersection of a sphere. Resolves a quatratic equation. Returns the \n// min distance, max distance, and discriminant to determine if the intersections\n// actually exist.\nvec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius)\n{\n\t// Derivation for formula:\n\t//\t\tLet the ray be represented as a point P plus a scalar multiple t of the direction vector v,\n\t//\t\tThe ray can then be expressed as P + vt\n\t//\n\t//\t\tThe point of intersection I = (x, y, z) must be expressed as this, but must also be some distance r\n\t//\t\tfrom the center of the sphere, thus x*x + y*y + z*z = r*r, or in vector notation, I*I = r*r\n\t//\n\t//\t\tIt therefore follows that (P + vt)*(P + vt) = r*r, or when expanded and rearranged,\n\t//\t\t(v*v)t^2 + (2P*v)t + (P*P - r*r) = 0. For this we will use the quadratic equation for the points of\n\t//\t\tintersection\n\n\t// a, b, and c correspond to the second, first, and zeroth order terms of t, the parameter we are trying to solve for.\n\tfloat a = dot(dir_vector, dir_vector);\n\tfloat b = 2.0 * dot(pos_vector, dir_vector);\n\tfloat c = dot(pos_vector, pos_vector) - sphere_radius * sphere_radius;\n\n\t// to avoid imaginary number, we will find the absolute value of the discriminant.\n\tfloat discriminant = b * b - 4.0 * a*c;\n\tfloat abs_discriminant = abs(discriminant);\n\tfloat min_dist = (-b - sqrt(abs_discriminant)) / (2.0 * a);\n\tfloat max_dist = (-b + sqrt(abs_discriminant)) / (2.0 * a);\n\n    // return the two intersections, along with the discriminant to determine if\n    // the intersections actually exist.\n\treturn float3(min_dist, max_dist, discriminant);\n\n}\n\n// Exact SDF for a sphere\nfloat dSphere(vec3 pos, vec3 center, float radius)\n{\n    vec3 v = pos - center;\n    return length(v) - radius;\n}\n\n// Convert degrees to radians\nfloat Radians(float deg)\n{\n \treturn deg / 360.0 * 2.0 * 3.14159; \n}\n\n\n// return the sign of the value input (favoring positive)\nfloat sgn(float x)\n{\n \tif (x < 0.0)\n    {\n    \treturn -1.0;\n    }\n    return 1.0;\n}\n\n// Write a float4 function for some of the HLSL Code conversion\nvec4 float4(float x, float y, float z, float w)\n{\n \treturn vec4(x,y,z,w);   \n}\n\n// Write a float3 function for the same purpose\nvec3 float3(float x, float y, float z)\n{\n \treturn vec3(x,y,z);   \n}\n\n// and a float2 function as well\nvec2 float2(float x, float y)\n{\n \treturn vec2(x, y);   \n}\n\n// Draw the main image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the iterations for the marcher.\n    const int ITERATIONS = 60;\n    \n    // Define the roation speed. Set to 0 to disable\n    const float ROTATION_SPEED = 0.6;\n    \n    // Define the start angle for the rotation (in degrees)\n    const float START_ANGLE = 0.0;\n    \n    // Define the orbit radius\n    const float ORBIT_RADIUS = 16.0;\n    \n    // Define the epsilon value for closeness to be considered a hit\n    const float EPSILON = 0.001;\n    \n    const bool HIDE_BACKGROUND = false;\n    \n    \n    \n    // Define the center of the julia set\n    vec3 sdf_center = vec3(0.0, 0.0, 0.0);\n \n    // Calculate the starting angles for the orbit\n    float theta = iTime * ROTATION_SPEED;\n    float phi = Radians(START_ANGLE);\n    \n    // Take some mouse input\n    vec4 mouse = iMouse / iResolution.xyxx;\n    \n    // If the mouse is being held down\n    if (mouse.z > 0.0)\n    {\n        // convert the mouse input to angles\n        theta = mouse.x * 2.0 * 3.14159;\n        phi = (mouse.y - 0.5) * 1.0 * 3.14159;\n    }\n    \n    // Define an orbital path based on time\n    vec3 orbit = vec3(cos(theta)*cos(phi), sin(phi), sin(theta)*cos(phi));\n    \n    // Cacluate the normal of the path. Since its a circle, it will just\n    // be back down into the center\n    vec3 normal = -normalize(orbit);\n    \n    // Calculate the tangent of the path\n    // A circle consists of <cost, sint>, which when differentiated yields\n    // <-sint, cost>. since z is already sint, and x is already cost, the equation\n    // is as follows.\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n    \n\t// Calculate the UV coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert the UV coordinates to a range between -1 and 1\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    \n    //// Define the Camera position\n    //vec3 cam_pos = vec3(0,0,-2);\n    \n    //// Define the forward, up, and right vectors (needs rework)\n    //vec3 forward = normalize(vec3(0,0,1));\n    //vec3 up = normalize(vec3(0,1,0));\n    //vec3 right = normalize(vec3(1,0,0));\n    \n    // Define the Camera position\n    vec3 cam_pos = orbit*ORBIT_RADIUS;\n    \n    // Define the forward, up, and right vectors (needs rework)\n    vec3 forward = normal;\n    vec3 up = normalize(cross(normal, tangent));\n    vec3 right = tangent;\n        \n    // Calculate the aspect ratio of the screen\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    // Calculate the ray as a normalized combination of the forward, right, and up vectors.\n    // Note that the purely forward + horizonal combination yield vectors 45 degrees outward\n    // for a 90 degree field of view. This may be updated with a fov option\n    vec3 ray = normalize(forward + range.x*right + range.y*up*aspect);\n    \n    // Initialize the ray marched point p\n    vec3 p = cam_pos;\n\n\n\t// Initialize the distance\n    float dist = 1.0;\n    \n    // Calculate the exact distance from a sphere of radius 2 using a raytracing function\n    vec3 init_distance = intersections_of_sphere(p - sdf_center, ray, 8.0);\n    \n    // If we are outside a bubble around the raymarched fractal\n    if (init_distance.z > 0.0)\n    {\n        // Step onto the sphere so we start off a bit closer.\n    \tp += ray * clamp(init_distance.x, 0.0, init_distance.x);\n    }\n\n    // declare a dummy variable to store the number of iterations into.\n    // I'm doing it this way because on my phone it didnt let me use an\n    // already declared variable as the loop iterator.\n    int j;\n    \n    float min_dist = 1.0;\n\t// Begin the raymarch\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        // Estimate the distance to the julia set\n        dist = DE(p, sdf_center);\n        \n        min_dist = min(dist, min_dist);\n        \n        // Move forward that distance\n        p += ray*dist;\n        \n        // Record the number of iterations we are on\n        j = i;\n        \n        // If we hit the julia set, or get too far away form it\n        if (dist < EPSILON || dot(p - sdf_center, p-sdf_center) > 64.0 + 0.1)\n        {\n            // Break the loop.\n        \tbreak;   \n        }\n        \n    }\n    \n        // determine if we hit the fractal or not\n    float hit = step(dist, EPSILON);\n    \n    \n    // calculate the brightness based on iterations used\n\tfloat di = (1.0 - (float(j) + (dist / EPSILON)*hit) / float(ITERATIONS));\n    float glow = 1.0 - (min_dist / 1.0);\n    \n\t//di = (di * hit) + (glow*(1.0-hit));\n    if (HIDE_BACKGROUND)\n    {\n    \tdi *= hit;\n    }\n\n    \n    \n    \n    // define some phase angle\n    float psi = Radians(70.0);\n    \n    // Time varying pixel color (included in default shadertoy project)\n    //vec3 col = 0.8 + 0.2*cos(iTime*0.5+uv.xyx+vec3(0,2,4) + psi*hit);\n\t\n    // Boring old white instead of the above commented code. Will tweak rendering later\n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    \n    // Output to screen. Modifiy the color with the brightness calculated as di.\n    fragColor = vec4(col*di,1.0);\n}","name":"Image","description":"","type":"image"}]}