{"ver":"0.1","info":{"id":"llfcRH","date":"1503518763","viewed":712,"name":"Reaction Diffusion on a Sphere","username":"rory618","description":"Reaction diffusion data is stored randomly in buf A according to a hash function, the inverse mapping is found per pixel with a random search. Once points in buf A know what voxel maps to its location, it can find its neighbors and use them for diffusion.","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["raymarched","diffusion","greyscale","reaction","hashing","spatial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI asin(1.)*2.\n#define marchSteps 15\n\n\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat map(vec3 rp){\n    vec3 sp = rp/length(rp);\n    vec3 cell = floor(sp*60.);\n    vec2 index = floor(iResolution.xy*hash23(cell));\n    vec3 ABc = vec3(0);\n    vec3 d;\n    for(d.x = -1.; d.x <= 1.; d.x++){\n        for(d.y = -1.; d.y <= 1.; d.y++){\n            for(d.z = -1.; d.z <= 1.; d.z++){\n                if(dot(d,d)==0.) d.z++;\n                vec2 neighborIndex = floor(iResolution.xy*hash23(cell+d));\n                vec4 neighbor = texelFetch(iChannel0, ivec2(neighborIndex),0);\n                vec3 neighborp = vec3(sin(neighbor.x)*cos(neighbor.y),sin(neighbor.y),cos(neighbor.x)*cos(neighbor.y));\n                float s = exp(-100.*length(neighborp-sp));\n                ABc += vec3(neighbor.zw,1)*s;\n            }\n        }\n    }\n    ABc /= max(.01,ABc.z);\n    return min(length(rp)-1.-ABc.x*.10+ABc.y*.01,10.-length(rp));\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(0.01,0.0,0.0);\n\treturn normalize( vec3(\n\t\tmap(pos+eps.xyy) - map(pos-eps.xyy),\n\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 mouse=iMouse.xy/iResolution.xy;\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\n\n    //camera\n    float theta = (mouse.x*2. - 1.)*2.*PI;\n    float phi = (mouse.y - .5)*PI;\n    \n    vec3 cameraPos = 2.*vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \n    vec3 cameraTarget = vec3(0.);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\n    \n    vec3 rp = cameraPos;\n    for(int i = 0;i < 16; i++){\n        \n        rp += map(rp)*rayDir;\n        \n        \n    }\n    \n    float l = .3;\n    \n    vec3 light = vec3(1,2,2)+.1*hash44(hash44(vec4(0,fragCoord,iFrame))).xyz;\n    vec3 normal = calcNormal(rp);\n    float ao = calcAO(rp,normal);\n    \n    vec3 lr = rp + normal * .01;\n    vec3 ld = light-lr;\n    ld /= length(ld);\n    \n    \n    for(int i = 0;i < 16; i++){\n        lr += min(map(lr),length(light-lr))*ld;\n    }\n    \n    \n    if(length(light-lr) < 1.){\n        l += .7*max(0.,dot(normal,ld));\n    }\n    \n    vec2 index = floor(iResolution.xy*hash23(floor(rp*60.)));\n    vec4 data = texelFetch(iChannel0,ivec2(index),0);\n    \n    vec3 p = vec3(sin(data.x)*cos(data.y),sin(data.y),cos(data.x)*cos(data.y));\n    \n\tfragColor = vec4(.5+.5*sin(length(rp)*30.))*l*ao;\n    if(length(rp)>1.1)\n    fragColor *= exp((1.1-length(rp))*8.);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI asin(1.)*2.\n#define voxelResolution 60.\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = texelFetch(iChannel0, ivec2(i),0);\n    for(int j = 0; j < 16; j++){\n        vec2 rnd = hash44(vec4(i,iFrame,j)).xy;\n        float theta = PI*2.*rnd.x;\n        float phi = acos(2.*rnd.y-1.)+PI/2.;\n        vec3 p = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec2 index = floor(iResolution.xy*hash23(floor(p*voxelResolution)));\n        if(index==floor(i)){\n            o=vec4(theta,phi,o.zw);\n        }\n    }\n    if(o!=vec4(0)){\n        float theta = o.x;\n        float phi = o.y;\n        vec3 p = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n        vec3 cell = floor(p*voxelResolution);\n        vec3 d;\n        float A = o.z;\n        float B = o.w;\n        float f = .045;\n        float k = .06;\n        float Ap = A - A*B*B + f*(1.-A);\n        float Bp = B + A*B*B - (k+f)*B;\n        A = mix(Ap,A,.2);\n        B = mix(Bp,B,.2);\n        \n        \n        \n        vec3 diff = vec3(0);\n        \n        for(d.x = -1.; d.x <= 1.; d.x++){\n            for(d.y = -1.; d.y <= 1.; d.y++){\n                for(d.z = -1.; d.z <= 1.; d.z++){\n                    if(dot(d,d)==0.) d.z++;\n                    vec2 neighborIndex = floor(iResolution.xy*hash23(cell+d));\n                    vec4 neighbor = texelFetch(iChannel0, ivec2(neighborIndex),0);\n                    vec3 neighborp = vec3(sin(neighbor.x)*cos(neighbor.y),sin(neighbor.y),cos(neighbor.x)*cos(neighbor.y));\n                    float s = exp(-voxelResolution*3.*length(neighborp-p));\n                    diff += vec3(neighbor.zw,1)*s;\n                }\n            }\n        }\n        \n        o.z = mix(A,diff.x/diff.z,.6);\n        o.w = mix(B,diff.y/diff.z,.3);\n        o.z=min(1.,o.z);\n        o.w=min(1.,o.w);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}