{"ver":"0.1","info":{"id":"4sdXD2","date":"1461647186","viewed":247,"name":"Pedagogical Font in use","username":"akohdr","description":"Sample usage of Pedagogical Font.  Mouse resizes characters in both X and Y","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","text","font"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//    for details refer to dev shader @ https://www.shadertoy.com/view/XsdSWS\n\n// DEBUG flag colours primitives RGB\n//#define DEBUG\n\n#define SCROLL\n#define DISTORT\n\n#define INK ORG\n#define WIDTH 4.\n\nvoid antialias(inout vec4 k, float d, float w, vec4 K) {\n    // Standard filled antialiased lines\n    //    k += K*(w-d);\n\n    // Neon glow\n    //    k += K/d;\n\n    // Partially stenciled lines\n    //  k += K*sin(d-w);\n\n    // Hollow lines\n    k += K*cos(1.5+d-w);\n\n    // Center line plus outline\n    //k += K*tan(.2+d-w);\n\n    // Stripe filled (using screen x/y would give stable fill)\n    //    k += K*max(K*cos(d-w), cos(7.*(d-w)));\n\n    // Temporally striped and outlined\n    //  k += K*max(K*cos(d-w), 1.+2.*cos(7.*(d-w)*(1.1+sin(iTime/2.))));\n\n    // Flashing font (temporal)\n    //    k += K*max(K*cos(d-w), sin(5.*iTime));\n}\n\n// ASCII char ordinals\n#define ASC_Sp 32\n#define ASC_a 97\n#define ASC_b 98\n#define ASC_c 99\n#define ASC_d 100\n#define ASC_e 101\n#define ASC_f 102\n#define ASC_g 103\n#define ASC_h 104\n#define ASC_i 105\n#define ASC_j 106\n#define ASC_k 107\n#define ASC_l 108\n#define ASC_m 109\n#define ASC_n 110\n#define ASC_o 111\n#define ASC_p 112\n#define ASC_q 113\n#define ASC_r 114\n#define ASC_s 115\n#define ASC_t 116\n#define ASC_u 117\n#define ASC_v 118\n#define ASC_w 119\n#define ASC_x 120\n#define ASC_y 121\n#define ASC_z 122\n\n// some colours\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define ORG vec4(1.,.5,.0,1.)\n\nfloat dBezier(vec2 p, vec4 ac, vec2 b);\n\nvoid bezier(inout vec4 k, vec2 p, vec4 ac, vec4 bw, vec4 K) \n{\n    #ifdef DEBUG\n    K = RED;\n    #endif\n    float d = dBezier(p,ac,bw.xy);\n    if(d<bw.z) antialias(k,d,bw.z,K);\n}\n\nvoid circle(inout vec4 k, in vec2 p, vec4 a, vec4 K)\n{\n    #ifdef DEBUG\n    K = GRN;\n    #endif\n    float r = a.z,\n        w = a.w,\n        w2 = w/2.,\n        l = length(p-a.xy),\n        d = (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\n    if(d<w) antialias(k,d,w,K);\n}\n\nvoid line(inout vec4 k, vec2 p, vec4 l, float w, vec4 K)\n{\n    #ifdef DEBUG\n    K = BLU;\n    #endif\n    vec2 a=l.xy, b=l.zw;\n    b -= a;  p -= a;\n    float d = length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n    if(d<w) antialias(k,d,w,K);\n}\n\nvec4 procGlyph(inout vec4 k, inout vec4 c, in vec2 p,\n               vec2 s, float w, vec4 K,\n               mat4 ps, int a)\n{\n    bool skip = false;\n    for(int i=0;i<4;i++) {\n        if(skip) {skip = false; continue;}\n        vec4 u = s.xyxy*ps[i];\n        if(u.x<0.)\n            if(u.z<0.){\n                vec4 v = s.xyxy*ps[i+1]; skip = true;\n                bezier(k, p, c.xyxy+vec4(-u.x,u.y,-u.z,u.w), c+vec4(v.xy,w,0.), K);\n            }\n            else\n                circle(k, p, c+vec4(-u.x,u.yz,w), K);\n        else\n            if(u.x>0.) line(k, p, c.xyxy+u,w, K);\n    }\n    c.x += s.x*float(a);\n\treturn k;\n}\n\n// Rotates control points retaining the sign of x components (micro-op)\nvec4 rotPt(vec4 p, float a) \n{\n    vec2 s = sign(p.xz);\n    vec4 trans = -vec4(5,5,5,5);\n    p += trans; p *=.01;\n    \n    vec3 sc = vec3(cos(a),-sin(a),0);\n\t\t      sc.z = -sc.y;\n    mat2 rot2D = mat2( sc.xyzx);\n\n    p.xy = rot2D*p.xy;\n    if(s.x == s.y) // don't transform circle radii\n\t    p.zw = rot2D*p.zw;\n    \n    p*=100.; p -= trans;\n    p.xz = s*abs(p.xz);\n\n    return p;\n}\n\n// Add pipeline step for select chars\nvec4 chainProcGlyph(inout vec4 k, inout vec4 c, in vec2 p,\n                    vec2 s, float w, vec4 K,\n                    mat4 ps, int a)\n{\n    // Because we can.......\n    // tweak the colour\n    float t = iTime+150.,\n         ct = t*.00001*p.x;\n    ct += ct;\n    K = abs(vec4(sin(2.*ct),cos(5.*ct),sin(3.*ct),1));\n\n\t// off centered rotation breaks apart letter into 2D components\n    float sT = sin(p.x/200.+2.*t), cT = cos(t),\n          r = cT*1.5*(1.+cos(2.1+sT));\n    ps[0] = rotPt(ps[0],r);\n    ps[1] = rotPt(ps[1],r);\n    ps[2] = rotPt(ps[2],r);\n    ps[3] = rotPt(ps[3],r);\n\n    return procGlyph(k,c,p,s,w,K,ps,a);\n}\n\n#define Z4 0,0,0,0\n#define Z8 Z4,Z4\n\n//The 'eidos' of font.....\n#define a_   mat4( -2,8,-13,-8, \t16,15,0,0,   -7,-3,6,0,   \tZ4)\n#define b_   mat4( 1,20,0,-7,   \t-8,0,8,0,   Z8)\n#define c_   mat4( -1,0,-13,5,   \t3,12,0,0, \t -1,0,-14,-3,   -2,-12,0,0)\n#define d_   mat4( -5,0,8,0,  \t\t13,20,13,-7, Z8)\n#define e_   mat4( -6,6,-15,-6,   \t-8,-10,0,0,   -7,7,-1,-2,   25,2,0,0)\n#define f_   mat4( -9,18,-2,-8,  \t1,25,0,0,    9,5,0,4,   \tZ4)\n#define g_   mat4( -7,0,8,0,   \t\t-15,8,-1,-16,17,-28,0,0, \tZ4)\n#define h_   mat4( 1,20,0,-8,   \t-1,4,-14,-8, 13,15,0,0,   \tZ4)\n#define i_   mat4( -3,13,2,0,   \t-2,7,-4,-6,  -1,-16,0,0,   \tZ4)\n#define j_   mat4( -2,13,2,0,   \t-2,7,-1,-15, 5,-22,0,0,   \tZ4)\n#define k_   mat4( 1,18,0,-8,   \t1,-2,13,6,   5,0,13,-8,   \tZ4)\n#define l_   mat4( -1,19,-6,-5,  \t0,-18,0,0,   Z8)\n#define m_   mat4( -1,-9,-8,-3,   \t2,20,0,0,  \t -8,-3,-16,-9,  14,20,0,0)\n#define n_   mat4( 1,7,0,-8,   \t\t-1,4,-14,-8, 15,15,0,0,   \tZ4)\n#define o_   mat4( -7,0,8,0, \t\tZ4, \t\t Z8)\n#define p_   mat4( -9,0,8,0,   \t\t1,7,1,-20, \t Z8)\n#define q_   mat4( -6,0,8,0,   \t\t14,7,14,-20, Z8)\n#define r_   mat4( 1,8,0,-7,   \t\t-2,3,-13,5,  11,12,0,0,   \tZ4)\n#define s_   mat4( -5,0,-8,7,   \t-8,8,0,0,  \t -6,-1,-1,-6,   15,-11,0,0)\n#define t_   mat4( -4,15,-12,-5, \t1,-15,0,0,   1,8,8,8, \t\tZ4)\n#define u_   mat4( -1,8,-13,-4,  \t0,-16,0,0,   14,8,14,-8,    Z4)\n#define v_   mat4( 1,8,6,-8,   \t\t11,8,6,-8,   Z8)\n#define w_   mat4( 1,8,4,-8,   \t\t4,-6,9,4,    9,4,14,-6,   \t14,-8,18,8)\n#define x_   mat4( 1,8,8,-8,   \t\t8,8,0,-8,    Z8)\n#define y_   mat4( -2,8,-12,-4,  \t4,-11,0,0,   -14,8,-1,-18,  14,-28,0,0)\n#define z_   mat4( 1,8,8,8,   \t\t8,8,0,-8,    1,-8,8,-8,   \tZ4)\n\nint msgCharAtPos(const int xc){\n// ***WARNING***: Big ugly if blocks blow up compilers, exhaust memory and crash browsers ?!\n\n    /*  \n\t#define MAP(a,b,c) if(a<b)return c;\n\t// char pos mappings\n    #define A_  MAP(xc,x++,97)\n    #define B_  MAP(xc,x++,98)\n    #define C_  MAP(xc,x++,99)\n\n....\n\n    int x = 1;\n    // This is lighter but STILL big if that taxes/breaks the *doze compiler(s)  ???!!!!!\n    SP_ T_ H_ E_ SP_ Q_ U_ I_ C_ K_ SP_ B_ R_ O_ W_ N_ SP_ F_ O_ X_ SP_ SP_ SP_\n        SP_ J_ U_ M_ P_ S_ SP_ O_ V_ E_ R_ SP_ T_ H_ E_ SP_ L_ A_ Z_ Y_ SP_ SP_ SP_\n        SP_ D_ O_ G_\n*/\n    \n    // We can use lookup table with caveats (see below)\n    \n     int m[50];\n     m[ 0] = ASC_t;\n     m[ 1] = ASC_h;\n     m[ 2] = ASC_e;\n     m[ 3] = ASC_Sp;\n     m[ 4] = ASC_q;\n     m[ 5] = ASC_u;\n     m[ 6] = ASC_i;\n     m[ 7] = ASC_c;\n     m[ 8] = ASC_k;\n     m[ 9] = ASC_Sp;\n     m[10] = ASC_b;\n     m[11] = ASC_r;\n     m[12] = ASC_o;\n     m[13] = ASC_w;\n     m[14] = ASC_n;\n     m[15] = ASC_Sp;\n     m[16] = ASC_f;\n     m[17] = ASC_o;\n     m[18] = ASC_x;\n     m[19] = ASC_Sp;\n     m[20] = ASC_j;\n     m[21] = ASC_u;\n     m[22] = ASC_m;\n     m[23] = ASC_p;\n     m[24] = ASC_s;\n     m[25] = ASC_Sp;\n     m[26] = ASC_o;\n     m[27] = ASC_v;\n     m[28] = ASC_e;\n     m[29] = ASC_r;\n     m[30] = ASC_Sp;\n     m[31] = ASC_t;\n     m[32] = ASC_h;\n     m[33] = ASC_e;\n     m[34] = ASC_Sp;\n     m[35] = ASC_l;\n     m[36] = ASC_a;\n     m[37] = ASC_z;\n     m[38] = ASC_y;\n     m[39] = ASC_Sp;\n     m[40] = ASC_d;\n     m[41] = ASC_o;\n     m[42] = ASC_g;\n        \n    // The loop is required to overcome compiler requirement for 'constant' index\n    //   (I can only guess maybe internal GPU memory access is somekind of block SRAM (?))\n    for (int i=0; i<43; i++){\n        if (i==xc) return m[i];\n    }\n    \n\treturn ASC_Sp;\n}\n\n// dimension lowering mapping of 2D screen pos (pixels) to 1D text pos (chars)\nfloat whereInFixedFontSpace(vec2 p, vec2 FONT_DIMS) {\n\n    p.y = iResolution.y-p.y; //flip read top down left right\n\n    float row = floor(p.y/FONT_DIMS.y),\n          col = floor(p.x/FONT_DIMS.x),\n   colsPerRow = floor(iResolution.x/FONT_DIMS.x);\n\n    return row*colsPerRow + col;\n}\n\nvoid screen(inout vec4 k, in vec2 p )\n{\n    vec2 SCREEN_SIZE = vec2(15,6),\t\t\t\t\t\t// in chars\n           FONT_DIMS = iResolution.xy/SCREEN_SIZE;\t\t// char cell dims\n\n    // cursor position\n    vec4 c = vec4(0);\n\n    // find 1D linear position in character space\n    float xc = whereInFixedFontSpace(p, FONT_DIMS);\n\n    // find the character at position in message\n    highp int xci = int(xc);\n    int ch = msgCharAtPos(xci);\n\n    if(ch==ASC_Sp) return;  //early exit \n\n    // calculate cursor position based on screen pos\n    c.xy = floor(p/FONT_DIMS)*FONT_DIMS;\n\n    // glyph offset within cell\n    c.xy += FONT_DIMS/vec2(4,2);\n\n    // remainder of glyph rendering context\n    float w = WIDTH;\n    vec4 K = INK;\n\n    // mouse sizing\n    vec2 s = iMouse.z>0. ? 4. * iMouse.xy/iResolution.xy : vec2(.002,.0035)*iResolution.xy;\n\n    // call the appropriate rendering function\n    //     uses context (k,c,p,s,w,K)\n\n// ***WARNING***: Big ugly if blocks blow up compilers, exhaust memory and crash browsers ?!\n    \n    // Design descision to use mat4/struct was to facilitate conditional assignment\n    // TODO: red/black tree the glyph lookup process\n    \n\t// 'Wiggly' letters\n    mat4 g =(ch== 97) ? a_ :\n            (ch== 98) ? b_ :\n            (ch==100) ? d_ :\n            (ch==101) ? e_ :\n            (ch==102) ? f_ :\n            (ch==112) ? p_ :\n            mat4(0);\n      \n    if (abs(g[0][0])>0.) \n\t    chainProcGlyph(k,c,p,s,w,K,g,50);\n    else {\n        g = (ch== 99) ? c_ :\n            (ch==103) ? g_ :\n            (ch==104) ? h_ :\n            (ch==105) ? i_ :\n            (ch==106) ? j_ :\n            (ch==107) ? k_ :\n            (ch==108) ? l_ :\n            (ch==109) ? m_ :\n            (ch==110) ? n_ :\n            (ch==111) ? o_ :\n            (ch==113) ? q_ :\n            (ch==114) ? r_ :\n            (ch==115) ? s_ :\n            (ch==116) ? t_ :\n            (ch==117) ? u_ :\n            (ch==118) ? v_ :\n            (ch==119) ? w_ :\n            (ch==120) ? x_ :\n            (ch==121) ? y_ :\n            (ch==122) ? z_ : \n        \tmat4(0);\n        procGlyph(k,c,p,s,w,K,g,50);    \n    }\n}\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    k = vec4(0);  // Just keep forgetting this!!\n\n    vec2 ir = iResolution.xy,\n        ir2 = ir/2.;\n\n    float f = .0005*ir.y*float(iFrame+50);  // tweaked for preview\n\n#ifdef DISTORT\n    // shimmer\n    float w = (ir.y/12.);\n    p.x += w/3.*sin(mod(p.y/w,w));\n#endif\n\n#ifdef SCROLL\n    // scroll up\n//    p.y -= 6.*f;     \t\t// absolute speed pixel/frame\n    p.y -= f*log(ir2.y);\t// seems to balance speed better switching res.\n//    p.y -= 20.*f*log(ir2.y);\t// go nuts....  still solid 60fps on my box\n    p.y = mod(p.y,ir.y);\n#endif\n    \n    screen(k,p);\n\n}\n\n\n\n\n\n\n\n//=============================================================================\n// derived from bezier code @ https://www.shadertoy.com/view/Mlj3zD\n#define PI 3.14159265358979\nint findRoots(vec4 abcd, out vec3 r)\n{\n    float a = abcd[0], \n          b = abcd[1], \n          c = abcd[2], \n          d = abcd[3];\n    vec3 vS = vec3(-1);\n    if (abs(a) > 1e-9){\n        \n        float z = 1./a;\n        abcd *= z;\n        a = abcd[1];\n        b = abcd[2];\n        c = abcd[3];\n        \n        float d3 = 1./3.,\n              aa = a*a,\n             d27 = 1./27.,\n               p = b-aa*d3,\n               q = a*(2.*aa-9.*b)*d27+c,\n             ppp = p*p*p,\n               D = q*q+4.*ppp*d27,\n           delta = -a*d3;\n        \n        if (D > 1e-9){\n            z = sqrt(D);\n            vec2 uv = .5*(vec2(z,-z)-q),\n                  s = sign(uv);\n            uv = abs(uv);\n    \t\tfloat u = s.x*pow(uv.x,d3),\n                  v = s.y*pow(uv.y,d3);\n            r.x = u+v+delta;\n            return 1;\n        }\n        else if (D < -1e-9){\n            float u = sqrt(-p*d3)*2.,\n                  s = -sqrt(-27.0/ppp)*q*.5;\n            if (abs(s) > 0.) {}\n            r = u*cos(vec3(acos(s)*d3) + vec3(0,2,4)*PI*d3)+delta;\n            return 3;\n        }\t\t\n        else {\n            q = sign(q)*pow(abs(q)*.5,d3);\n            r.xy = vec2(-q,q)+delta;\n            r.x *= 2.;\n            return 2;\n        }\n    }\n    else {\n        if (abs(b) <= 1e-9 && abs(c) > 1e-9) {\n            r.x = -d/c;\n            return 1;\n        }\n        else {\n            float D = c*c-4.*b*d,\n                  z = 1./(2.*b);\n            if (D > 1e-9) {\n                D = sqrt(D);\n                r.xy = (vec2(-D,D)-c)*z;\n                return 2;\n            }\n            else if (D > -1e-9) {\n                r.x = -c*z;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c) \n{\n    float mT = 1.-t;\n    vec2 pos = mT*mT*a+2.*t*mT*b+t*t*c;\n    return pos;\n}\n\nfloat dBezier(vec2 p, vec4 ac, vec2 b) \n{\n    vec2 a = ac.xy, \n         c = ac.zw,\n       dap = a-p,\n       dba = b-a,\n       sac = a+c-b*2.;\n    vec3 r;\n    float dist = 999.;\n    int roots = findRoots(vec4(dot(sac,sac), \n                               dot(dba,sac)*3.,\n                               dot(dba,dba)*2.+dot(dap, sac), \n                               dot(dap,dba)),r);\n    float r1 = r.x,\n          r2 = r.y,\n          r3 = r.z;\n    if (roots > 0 && r1 >= 0. && r1 <= 1.)\n        dist = distance(p,bzPos(r1,a,b,c));\n    if (roots > 1 && r2 >= 0. && r2 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[1],a,b,c)));\n    if (roots > 2 && r3 >= 0. && r3 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[2],a,b,c)));\n    return min(dist, min(distance(p, a), distance(p, c)));\n}\n","name":"Image","description":"","type":"image"}]}