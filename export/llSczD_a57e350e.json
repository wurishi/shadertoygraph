{"ver":"0.1","info":{"id":"llSczD","date":"1507643808","viewed":298,"name":"Forever_Cycling","username":"duvengar","description":"Variation on the Truchet Theme. Inspired and derived from [url=https://www.shadertoy.com/view/llfyWX]Simple_animated_Truchet[/url] by @Shane\nMouse control the flow direction.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","flow","polar","chain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Forever_Cycling by julien Vergnaud @duvengar-2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n\n// Derived from Simple_animated_Truchet by @Shane\n// [url]https://www.shadertoy.com/view/llfyWX[/url]\n\n// Mouse control direction\n\n\n#define PI     3.14159265359\n#define TWO_PI (PI*2.)\n\n// vec2 to float hash function taken from @Shane - Based on IQ's original.\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.867)))*43758.5453); }\n\n// Standard 2D rotation formula.\n\nmat2 rot(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// polynomial smooth min\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n//distance field circle\n\nfloat df_circle(vec2 pos, float rad){\n\n    return (length(pos)-rad);  \n}\n\n\n\n//distance field chain ring\n\nfloat df_chain(vec2 pos, float rad, float dir, float off){\n    \n    // Because the truchet cells are flipped out along the Y axis\n    // We need to draw everthing in symetry using direction\n    // and offset values as variables for the position.\n    // The smin from iq method is used to unify two spheres smothly\n    // making the chain block curved.\n    \n    float shp  = length(pos + vec2(0, dir * rad * off)) -rad; \n    \n          shp  = smin(shp, (length(pos - vec2(0, dir * rad * off)) -rad ), .05);;\n          shp  = max (shp,-(length(pos + vec2(0, dir * rad * off)) -rad/2.5)); \n    \t  shp  = max (shp,-(length(pos - vec2(0, dir * rad * off)) -rad/2.5)); \n\n    return   shp;\n}\n\n\n\nvoid mainImage( out vec4 c, in vec2 uv )\n{\n    \n    // I   //  Screen coordinates is formated to go from -1. to 1.\n    \n\tvec2 p = -1.+ 2.* uv / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    \n      \n   \n    // II  //  Moove & Rescale screen space\n    \n    p *= 1. + dot(p, p)*.05;        // fish eye\n    p += vec2(.0, iTime/12.);       // moove along Y axis\n    p *= .5*floor(iResolution.x/300.); // rescale space\n \n    \n \t// III //  Make truchet lines\n           //  store tile id & Divide screen into grid \n    \t   //  & store direction in a checkerboard way.\n\t\n    vec2 id = floor(p);\n    \n           // replacing Shane's float dir = sign(mod(id.x + id.y, 2.) - .5);\n           // The sign() seems to be dispensable\n    \n           \n    \n    float dir = mod(id.x + id.y, 2.)*2.-1.; // values from -5 to .5\n    \n    p = fract(p) - .5 ;  // or // p -= id + .5; \n        \n           //  Truchet tiles orientation randomisation\n    \n\tp.y *= hash21(id) > .5 ? 1. : -1.;\n    \n           //  Applying symetry on diagonal axis to avoid drawing two arcs\n           //  Tricks form @shane\n    \n    p *= sign(p.x + p.y);\n  \n      \n           //  Drawing the two arc's strokes directly with a tickness of t\n           //  The tricks to draw a contour was taken from a @FabriceNeyret2 \n           //  comment in this shader https://www.shadertoy.com/view/MtXyWX\n    \n    p             -= .5; \n    float t        = .12; \n    float t2       = .05;    \n    float line     = abs(length(p ) - .5) - t * .5;\n    float line_str = abs(length(p ) - .5) - t2 * .3;\n    float line_out = max(line, -line -.008);\n    float line_glo = max(line, -line -.8);;\n      \n           //  Adjusting the arcs clarity (I don't know how to call that)\n    \n    line     = 1. - smoothstep(.01,.1, sqrt(line));\n    line_str = 1. - smoothstep(.01,.1, sqrt(line_str));\n  \n    // IV  //  RENDER CHAIN\n    \n            //  Animate flow\n     \n    vec2 pos = p ;\n    \n    if(iMouse.z > 0.){\n    \tfloat m = smoothstep(.0,-1. + 2. * iResolution.x, -1. + 2. * iMouse.x);\n        m*= 20.;\n    \tpos *= rot(m*dir);\n    }else{\n        pos *= rot(iTime*dir);\n    }\n\n            //  Part into cells  & convert into polar coordinates\n     \n    const float num = 8.;                        // partitions number\n    float ang = atan(pos.y, pos.x);              // Pixel angle.               \n    float ctr = floor(ang / TWO_PI * num ) + .5 ; // the cell center.\n\n    pos  = rot(ctr  *(PI*2.) / num) *pos;        // Converting to polar coordinates\n \t \n    pos.x -= .5 -.0055;                                 // p.x = radius, p.y = angle.\n                                                     // Translate coordinates\n    \n            //  render the objects in each slices\n      \n    //float ring  = df_chain(pos, .089, dir, 1.9);\n    \n    //dir*2.;\n    float ring  = df_chain(pos, .09, dir, .9);\n    \n    float ring2 = smoothstep(0.0, .01, df_circle(pos, .165)); \n    \n    float ring3 = smoothstep(0.0, .01, abs(ring));\n          ring  = smoothstep(0.0, .01, ring);\n    \n    \n    float base2 = 1. - smoothstep(.0,.01, \n                       min(line_glo, df_chain(pos, .089, dir, .9))); \n    \n    \n    \n    \n    ///////////////////////////////////////////////////////////////////////////////\n    \n   \n    \n    // V  //   Coloring\n    \n    float tex = .7 * sin(2. * cos(10. * uv.x + uv.y) - hash21(uv));     \n    \t\t \t\n    float c2  = 1. - min(line_str, ring2);              // chain interstice\n     \n    float c1  = min(line_out, ring);                   // create Chain contour\n          c1  = min(1. - c1, ring3); \n          c1  = min(c1, c2);\n    \n    c  = .4*vec4(max(.4*tex, base2 * cos(sin(ang))));   // base texture with radial gradient\n\t\t\t\t\t\t\t\t\t\t\t\t\t    // the cos(sin(angle) is used \n                                                        // todo the lighning\n    \n    c *= vec4(c1 * cos(sin(ang)));                      // draw chain contour \n\n    c /= .7+vec4(1., hash21(uv) * 2., 1., 1.);          // noisy color\n    \n    c += .7 * vec4(base2 * .35, base2 * .3, .1, 1.);   // a bit gold\n    \n   \n    c += mix(vec4(.4, .7, .55, 1.), c, .6);              // a bit more blue\n    \n    c -= vec4( .3 * c1);                                // a bit darker\n    \n    vec2 uu  = 1. - 2. * uv / iResolution.xy;           // vigneting\n    float v  = 1. - smoothstep(.7, 1.9, length(uu)) * 2.;\n    c *= vec4(v);                                       // black\n    c /= .8 * vec4(v * .6, 1., .6, 1.);                 // red   \n\n    c -=.6-c1*.7;                                       //adjust outline contrast\n  \n    c = sqrt(c)*.1+c;;    \n\n\n}","name":"Image","description":"","type":"image"}]}