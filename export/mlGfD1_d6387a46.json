{"ver":"0.1","info":{"id":"mlGfD1","date":"1702027024","viewed":28,"name":"Where does the rotation go?","username":"snail_god","description":"Illustrating what happens with rotation and translation depending on order of operations, including which direction things end up pointing towards. Grab the arrow signed distance function and use it for debugging!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArrow( in vec2 p, in float r, in float off, in bool dot  )\n{\n    float len = r + off;\n    float a = radians(90.);\n    vec2 rot_p = mat2(cos(a), -sin(a),\n                    sin(a),  cos(a)) * (p + vec2(2. * len, 0.));\n    float pointer = sdEquilateralTriangle(rot_p, r);\n    float stick = sdBox(p + vec2(len, 0.), vec2(len, r * 0.4));\n    float arrow = min(pointer, stick);\n    if (dot) {\n        return min(arrow, length(p) - r);\n    }\n    else {\n        return arrow;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 pix = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 center = vec2(0.);\n    \n    float a = radians(50. * iTime);\n    mat2 rotate = mat2(cos(a), -sin(a),\n                    sin(a),  cos(a));\n    vec2 translate = vec2(.6, .0);\n\n    bool circ = true;\n\n    float size = 0.1;\n    float bounce = 0.01 * sin(4. * iTime);\n\n    /////////////////////////////////////////\n    // This is the part to pay attention to!!\n    /////////////////////////////////////////\n    float sd_1 = sdArrow((rotate * pix) + translate, size, bounce, circ);\n    float sd_2 = sdArrow(rotate * (pix + translate), size, bounce, circ);\n    float sd_3 = sdArrow(pix + (rotate * translate), size, bounce, circ);\n    float sd_4 = sdArrow(pix, size, bounce, circ);\n\n    vec3 col = vec3(1.);\n        \n    if (sd_1 < 0.) {\n        col.r -= 0.5;\n    }\n    \n    if (sd_2 < 0.) {\n        col.g -= .5;\n    }\n    \n    if (sd_3 < 0.) {\n        col.r -= .5;\n        col.b -= .5;\n    }\n    \n    if (sd_4 < 0.) {\n        col.r -= .5;\n        col.g -= .5;\n        col.b -= .5;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}