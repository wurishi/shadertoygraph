{"ver":"0.1","info":{"id":"llSfRK","date":"1516455556","viewed":1396,"name":"Cloudy tunnel","username":"noby","description":"Never made an oldskool raytraced tunnel so here's a quick shot at that. It became a cloudy one. Not super pretty, but at least it's \"fast\". Will probably revise this next week a bit. Vignetting is based on https://github.com/keijiro/KinoVignette.","likes":36,"published":1,"flags":0,"usePreview":1,"tags":["tunnel","volume","cloud","volumetric","tube","cylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float W = 4.0;\nconst float T = 0.05;\nfloat filmic_reinhard_curve (float x) {\n    float q = (T + 1.0)*x*x;    \n\treturn q / (q + x + T);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) / w;\n}\n\nmat3 orient(in vec3 v,in vec3 d)\n{\n\tv = normalize(v);\n\tvec3 i = normalize(cross(v, normalize(d)));\n\treturn mat3(i, cross(i, v), v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0+2.0*fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float position = iTime*100.0;\n    \n    // origo and lookat points\n    vec3 o = vec3(sin(iTime*0.478)*8.0,cos(iTime*0.513)*8.0, iTime*100.0);\n\tvec3 t = vec3(sin(iTime*0.509)*200.0,cos(iTime*0.437)*200.0, -1000.0);\n\t// oriented direction vectors (yes I like my up vectors like that shut your up)\n\tvec3 d = normalize(vec3(uv, 2.0)*orient(t, normalize(vec3(0,1,2)) ));\n    \n    vec3 tv = vec3(1);\n    vec3 ac = vec3(0);\n    vec3 i = vec3(0);\n    float aid = 0.0;\n    \n    for(int l = 0; l < 32; l++)\n    {\n        float off = 3.0*(1.0*pow(length(tv),2.0) );\n        aid += off;\n        float r = 32.0 - off;\n    \n        float a = d.x*d.x + d.y*d.y;\n        float b = 2.0*(o.x*d.x + o.y*d.y);\n        float c = o.x*o.x + o.y*o.y - r*r;\n\n        float delta = b*b - 4.0*a*c;\n\n        float t1 = (-b - sqrt(delta))/(2.0*a);\n        float t2 = (-b + sqrt(delta))/(2.0*a);\n        float t = min(t1, t2);\n\n        i = o + t*d;\n\n        //vec2 co = vec2((i.z)*0.2, (atan(i.y, i.x)*32.0/3.1416));\n        //tv = textureLod(iChannel0, co*0.01, 1.0).rgb;\n        vec2 co = vec2((i.z)*0.2,\n                       atan(i.y, i.x)*32.0/3.1416);\n        tv = texture(iChannel0, co*0.007).rgb;  //.grb*vec3(1.12,0.94,1.02);\n        vec2 c2 = vec2((i.z)*0.2,\n                       abs(atan(i.y, i.x)*32.0/3.1416));\n        vec3 te = texture(iChannel0, c2*0.007).rgb;\n        tv = mix(tv, te, smoothstep(0.0,0.7,atan(i.y, i.x))+smoothstep(3.1416-0.7,3.1416,-atan(i.y, i.x)));\n        /*\n        co = vec2(abs(i.z)*0.07,\n                       abs(atan(i.y, i.x)*11.0/3.1416));\n        tv += 0.5*texture(iChannel0, co*0.01).rgb;\n\t\t*/\n        ac += pow(tv, vec3(2.2))/32.0;\n    }\n    \n    ac /= pow(smoothstep(0.0, 1.0, 1.0/pow(distance(o, i)*0.02, 2.0)), 0.5);\n    ac /= pow(aid, 0.5)*0.1;\n    \n    \n    // vignette\n    float rf = sqrt(dot(uv, uv)) * 0.3;\n    float rf2_1 = rf * rf + 1.0;\n    ac *= 1.0 / (rf2_1 * rf2_1);\n    // tonemap\n    ac = filmic_reinhard(ac);\n    ac = smoothstep(-0.12, 1.0, ac);\n    \n\tfragColor.rgb = pow(ac, vec3(0.4545));\n}","name":"Image","description":"","type":"image"}]}