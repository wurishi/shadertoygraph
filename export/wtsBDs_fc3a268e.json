{"ver":"0.1","info":{"id":"wtsBDs","date":"1598276534","viewed":278,"name":"[steb] volumetric clouds","username":"steb","description":"now to convert to unity :(\nhttps://twitter.com/st3bongo\nUseful Resources:\nhttps://www.youtube.com/watch?v=4QOcCGI6xOU\nhttps://advances.realtimerendering.com/s2015/The%20Real-time%20Volumetric%20Cloudscapes%20of%20Horizon%20-%20Zero%20Dawn%20-%20ARTR.pdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raytracing","raymarching","volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 cameraPos = vec3(0);\nconst float camPlaneDst = 5.0;\nconst float cloudDistance = 10.0;\nconst vec3 cloudScale = vec3(3.5, 2.0, .6);\nconst int scatterSamples = 15;\nconst float stepDistance = .05f;\nconst float absorbance = .8;\nconst int sunSamples = 20;\nconst float sunStepDistance = .05f;\nconst float sunAbsorbance =25.0;\nconst vec3 sunColor = vec3(10, 10, 10); \nconst float g = .7;\nconst float forwardAmount = .2;\n//const float scatterAmount = .0;\n\nvec3 ambient(vec3 dir, vec3 sunDir)\n{\n    return vec3(.4 - dir.y *2.2f, 0.6 - dir.y * 2.4f, .9f) + pow(max(0.0,dot(dir, sunDir)), 800.0);\n}\n\nfloat sampleDepth(vec3 pos)\n{\n    vec2 cloudUV = (pos.xy / cloudScale.xy);\n    //\n    float depth = (pow(texture(iChannel0, cloudUV + vec2(iTime / 50.0, 0)).x, 1.0)) * cloudScale.z / max(1.0, pow(length(2.0 * vec3(cloudUV, (pos.z - cloudDistance) / cloudScale.z)), 15.0));\n    return abs(cloudUV.x) < 1.0f && abs(cloudUV.y) < 1.0f && cloudScale.z + cloudDistance > pos.z ? max(0.0, depth * 3.0 - .2) : 0.0f;\n}\n\nfloat hgPhase(float cosAngle)\n{\n    float gSquared = g*g;\n    return (0.079577471545948) * (1.0 - gSquared) / pow(1.0 + gSquared - 2.0 * g * cosAngle, 1.5);\n}\n\n//vec3 scatter(vec3 s)\n//{\n//    return (2.0 * texture(iChannel1, vec2(s.x + s.z + iTime * 50.0, s.y + s.z)).rgb - 1.0) * scatterAmount;\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 sunDir = normalize(vec3(2.0f * iMouse.x / iResolution.x -1.0f, 2.0f * iMouse.y / iResolution.y - 1.0f, sin(iTime / .5)));\n    vec3 sunDir = normalize(vec3(sin(iTime), 0, cos(iTime)));\n    //sunDir = vec3(1,0,0);\n    vec2 screenUV = (fragCoord - vec2(iResolution.x, iResolution.y) / 2.0f) / iResolution.x;\n    vec3 rayDir = vec3(2.0f * screenUV, camPlaneDst) - cameraPos;\n    \n    float rayDst = cloudDistance / camPlaneDst;\n    vec3 hitPos = cameraPos + rayDst * rayDir;\n    \n    rayDir = normalize(rayDir);\n    //vec3 nrm = vec3(0,0, 1);\n    //vec2 add = vec2(0, 1.0f / 512.0f);\n    //nrm.x = texture(iChannel0, cloudUV - add.yx).x - texture(iChannel0, cloudUV + add.yx).x;\n    //nrm.y = texture(iChannel0, cloudUV - add.xy).x - texture(iChannel0, cloudUV + add.xy).x;\n    //nrm = normalize(nrm);\n    fragColor = vec4(ambient(rayDir, -sunDir), 1);\n    \n    float density = sampleDepth(hitPos);\n    \n    if (density > 0.0)\n    {\n    \tvec3 lightEnergy = vec3(0.0);\n        float phase = mix(1.0, hgPhase(dot(rayDir, -sunDir)), forwardAmount);\n        for (int i = 0; i < scatterSamples; i++)\n        {\n            //rayDir += scatter(hitPos);\n            //rayDir = normalize(rayDir);\n            hitPos += rayDir * stepDistance;\n            float s = sampleDepth(hitPos) * stepDistance;\n            density += s;\n            \n            float sunDensity = 0.0;\n            vec3 pos = hitPos;\n            vec3 dir = -sunDir;\n            for (int j = 0; j < sunSamples; j++)\n            {\n                //dir += scatter(dir);\n                //dir = normalize(dir);\n                pos += dir * sunStepDistance;\n                float sunS = sampleDepth(pos) * sunStepDistance;\n                sunDensity += sunS;\n            }\n            \n            float ambientTransmittance = exp(-density * absorbance);\n            // ;\n            lightEnergy += phase * s * (exp(-sunDensity * sunAbsorbance) * ambientTransmittance * sunColor+ ambientTransmittance * ambient(rayDir, -sunDir));\n        }\n        float transmittance = exp(-density * absorbance);\n        //\n        fragColor = fragColor * vec4(transmittance) + vec4(lightEnergy, 1);\n        //fragColor = mix(vec4(lightEnergy, 1), fragColor, transmittance);\n    }\n    \n    //fragColor = vec4(-(rayDir), 1);\n}","name":"Image","description":"","type":"image"}]}