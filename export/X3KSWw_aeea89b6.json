{"ver":"0.1","info":{"id":"X3KSWw","date":"1720028400","viewed":26,"name":"SmoothingMinimumAnimatedDemo","username":"Teomik","description":" its only a demo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.  \n#define SURF_DIST .01\n//dot because of float and integer\n  float f (float t){\n  float e = float(vec3(0,1,6)+1.5*t);\n  if ( e > 7.) {\n  e = float(vec3(11,1,6) - 1.5*t);\n  }\n   if (e <-8.){\n  e = float(vec3(-20,1,6) + 1.5*t);\n  }\n  return e;\n  }\n float sdBox (vec3 p, vec3 s){   //box\n return length(max(abs(p)-s,0.));\n }\nfloat smin( float a, float b, float k )\n{\n    k = 2.0;\n    float x = b-a;\n    return 0.5*( a+b-sqrt(x*x+k*k) );\n}\nfloat GetDist(vec3 p) {\n vec4 s =vec4(f(iTime),1,6,1);\n float sphereDist = length(p-s.xyz)-s.w; //spere distance\n float bd = sdBox(p-vec3(-2.,1,5.),vec3(.7)); //box distance\n float planeDist = p.y;\n \n float ud = smin(bd,sphereDist,.2);\n float d = min(p.y,ud);\n return d;\n }\nfloat RayMarch(vec3 ro,vec3 rd){ //raymarchfuntion\n  float dO =0.;\n  for(int i=0;i<MAX_STEPS;i++){\n  vec3 p = ro +rd*dO;\n  float ds = GetDist(p);\n  dO+=ds;\n  if(dO>MAX_DIST || ds<SURF_DIST) break;\n  }\n  return dO;\n}\nvec3 GetNormal(vec3 p){  //light\n float d = GetDist(p);\n vec2 e = vec2 (.01,0.);\n vec3 n = d - vec3(\n GetDist(p-e.xyy),\n GetDist(p-e.yxy),\n GetDist (p-e.yyx));\n return normalize (n);\n}\n float GetLight (vec3 p){  //light\n vec3 lightPos = vec3 (2,10,1);\n \n vec3 l =normalize(lightPos-p);\n vec3 n = GetNormal(p);\n  float dif = clamp(dot(n,l), 0.,2.);  // n-normal, l-light //clamp - hold the values\n  float d = RayMarch(p+n*SURF_DIST*2.,l);   //shadow\n  if(d<length(lightPos-p)) dif*=.1;   //shadow\n return dif;\n \n }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; //middle\n\n    // Time varying pixel color\n    vec3 col =vec3(0);\n    vec3 ro = vec3 (0,1,0);\n    vec3 rd =normalize(vec3(uv.x,uv.y,1)); //check by deleting the normalize function (NORMALIZE MEANS THAT A LENGTH IS SETTING TO 1); \n    float d = RayMarch(ro,rd);\n    vec3 p =ro + rd*d;\n    float dif = GetLight(p);\n    d/=9.;\n    col = vec3(dif);\n    // Output to screen\n    fragColor = vec4(col, 2.0);\n}\n","name":"Image","description":"","type":"image"}]}