{"ver":"0.1","info":{"id":"3sSBRW","date":"1589544019","viewed":94,"name":"Squashed hexagons (ungolfed)","username":"schnaader","description":"Shader to draw the pattern from\nhttps://codegolf.stackexchange.com/questions/204726/tile-the-plane-with-squashed-hexagons\n\nungolfed version, golfed version here: https://www.shadertoy.com/view/tsBfRW","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tesselation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int n = 10;\n\nconst float zoom = 0.15;                // higher values => zoom into the pattern\n\nconst float W = (0.03 * zoom) / 2.0;\t// half line width\nconst float L = (0.1 * zoom); \t\t\t// length of a hexagon edge\nconst float M = (L / 2.0) * sqrt(2.0);  // axis parallel length of a diagonal\nconst float InsideHexagon = 1.0;\nconst float OnBoundary = 0.0;\n \n// Returns 1.0 if inside the hexagon, 0.0 else\nfloat hexagon(vec2 uv, vec2 center) {\n    \n    // using absolute of the coordinates uses the symmetry of the hexagon\n    // this way, the hexagon can be reduced to two lines\n    vec2 absUv = abs(uv - center);\n    \n    if ((absUv.x >= 0.0) && (absUv.x <= L / 2.0)) { // straight line\n        if ((absUv.y >= M - W / sqrt(2.0)) && (absUv.y <= M + W / sqrt(2.0))) {\n            return OnBoundary;\n        } else {\n            return InsideHexagon;\n        }\n    } else if (absUv.x <= L / 2.0 + M + W) { // diagonal line\n        if ((absUv.y >= M - (absUv.x - L / 2.0) - W) && (absUv.y <= M - (absUv.x - L / 2.0) + W)) {\n            return OnBoundary;\n        } else {\n            return InsideHexagon;\n        }        \n    }\n    \n    return InsideHexagon;\n}\n\nfloat mirroredHexagons(vec2 uv, vec2 center) {\n    float result;\n    \n    result = hexagon(uv, center);     // draws some of the hexagons\n    result *= hexagon(uv.yx, center); // same, but rotated by 90Â°\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    uv.y /= (iResolution.x / iResolution.y);\n \n    // rotated by 45 degree\n    float alpha = radians(-45.0);\n    vec2 uv45 = vec2(uv.x * cos(alpha) - uv.y * sin(alpha), uv.x * sin(alpha) + uv.y * cos(alpha));\n \n    // Time varying pixel color\n    vec3 colInside   = 0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 colBoundary = vec3(0,0,0);\n\n    // Output to screen\n    float currentState = InsideHexagon;\n    \n    float xFirst = L / 2.0 + M;\n    \n    for (int i = 0; i < n; i++) {\n        int maxJ = i / 2 + 1;\n        if (i % 2 == 0) {\n            for (int j = 0; j < maxJ; j++) {\n                // by passing abs(uv) to mirroredHexagons, symmetry is used and multiple hexagons are\n                // drawn at once\n            \tcurrentState *= mirroredHexagons(abs(uv), vec2(xFirst + float(i) * (L + M), float(j) * 2.0 * M));\n                if (i < n - 1) {\n                    currentState *= mirroredHexagons(abs(uv45), vec2(xFirst + float(i) * (L + M) + L, float(j) * 2.0 * M));\n                }\n            }\n        } else {\n            for (int j = 0; j < maxJ; j++) {\n            \tcurrentState *= mirroredHexagons(abs(uv), vec2(xFirst + float(i) * (L + M), float(j) * 2.0 * M + M));\n                if (i < n - 1) {\n            \t\tcurrentState *= mirroredHexagons(abs(uv45), vec2(xFirst + float(i) * (L + M) + L, float(j) * 2.0 * M + M));\n                }\n            }\n        }\n    }\n\n    // multiplying gives black for boundaries while preserving the animated background\n    fragColor = vec4(currentState * colInside, 1.0);\n}","name":"Image","description":"","type":"image"}]}