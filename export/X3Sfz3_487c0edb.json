{"ver":"0.1","info":{"id":"X3Sfz3","date":"1731823180","viewed":531,"name":"20241117_Planefiller","username":"0b5vr","description":"The shadertoy port of \"Planefiller\", my Windows 8kb intro\n\nhttps://www.pouet.net/prod.php?which=101218","likes":39,"published":1,"flags":40,"usePreview":1,"tags":["2d","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n// == text =========================================================================================\nfloat sddomainchar(inout vec2 p, int code, float margin) {\n  const ivec4 spaces[] = ivec4[](ivec4(3,5,8,8),ivec4(8,8,3,4),ivec4(4,8,8,3),ivec4(5,3,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,3,3,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(3,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,4,8),ivec4(4,8,8,2));\n\n  vec2 uv = saturate((p - vec2(4.0, 0.0)) / 16.0 + 0.5);\n  float d = 100.0;\n  if (abs(uv.x - 0.5) < 0.5 && abs(uv.y - 0.5) < 0.5) {\n    uv = (uv + vec2(code % 8, code / 8)) / 8.0;\n    d = texture(iChannel0, uv).x;\n  }\n\n  p.x -= float(spaces[code / 4][code % 4]) + margin;\n\n  return d;\n}\n\n// == main =========================================================================================\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor *= 0.0;\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float time = iTime;\n  vec3 seed = hash3f(vec3(uv, time));\n  time += 0.003 * seed.z;\n  float beats = time / i_B2T;\n  float beatpulse = 0.4 + 0.6 * pow(0.5 - 0.5 * cos(TAU * ease(beats, 7.0)), 0.3) * (\n    1.0 - 0.8 * smoothstep(0.0, 1.0, beats - i_TENKAI_BREAK - 1.0) * smoothstep(0.0, -0.5, beats - i_TENKAI_FULLHOUSE)\n  );\n  float beatpulse2 = exp(-5.0 * fract(beats));\n\n  // -- buffer 0 alpha - texts ---------------------------------------------------------------------\n  // title, \"planefiller\"\n  if (beats < i_TENKAI_HELLO_RGB_DELAY) {\n    float d = 100.0;\n\n    vec2 p = (uv - 0.5) * 160.0 + vec2(56.0, 0.0);\n\n    float i_margin = 3.0;\n    d = min(d, sddomainchar(p, 47, i_margin));\n    d = min(d, sddomainchar(p, 43, i_margin));\n    d = min(d, sddomainchar(p, 32, i_margin));\n    d = min(d, sddomainchar(p, 45, i_margin));\n    d = min(d, sddomainchar(p, 36, i_margin));\n    d = min(d, sddomainchar(p, 37, i_margin));\n    d = min(d, sddomainchar(p, 40, i_margin));\n    d = min(d, sddomainchar(p, 43, i_margin));\n    d = min(d, sddomainchar(p, 43, i_margin));\n    d = min(d, sddomainchar(p, 36, i_margin));\n    d = min(d, sddomainchar(p, 49, i_margin));\n\n    // render\n    fragColor.y = d;\n  }\n\n  // \"warning\"\n  if (i_TENKAI_BREAK <= beats && beats < i_TENKAI_FULLHOUSE - 4.0) {\n    const int codes[] = int[](\n      0,\n      54, 32, 49, 45, 40, 45, 38, // warning\n      63, 12, 63, // -\n      35, 49, 46, 47, 63, // drop\n      40, 45, 34, 46, 44, 40, 45, 38\n    );\n\n    float d = 100.0;\n\n    vec2 p = (uv - 0.5) * 280.0 + vec2(118.0, 0.0);\n\n    for (int i = 0; i ++ < 23;) {\n      float phase = saturate((beats - i_TENKAI_BREAK - 0.5 - 0.05 * float(i)) / 0.25);\n      if (0.0 < phase) {\n        int i_offset = 3 * (int(16.0 * phase) - 16);\n        int code = (codes[i] - i_offset) % 64;\n        d = min(d, sddomainchar(p, code, 4.0));\n      }\n    }\n\n    // render\n    fragColor.y = d;\n  }\n\n  // countdown\n  if (i_TENKAI_FULLHOUSE - 4.0 <= beats && beats < i_TENKAI_FULLHOUSE) {\n    vec2 p = (uv - 0.5) * 280.0 + vec2(4.0, 0.0);\n\n    float d = sddomainchar(p, 18 - int(beats) % 4, 4.0);\n\n    // render\n    fragColor.y = d;\n  }\n\n  // -- buffer 1 alpha - chars ---------------------------------------------------------------------\n  fragColor.x = texture(iChannel0, uv).x;\n  if (fragColor.x == 0.0) {\n    const ivec4 vertices[] = ivec4[](ivec4(0x10111216,0x35361516,0x61016505,0x50561016),ivec4(0x05165665,0x62531304,0x01105061,0x26063036),ivec4(0x42060424,0x42406062,0x00016566,0x41425363),ivec4(0x02011030,0x45443313,0x04051636,0x41423313),ivec4(0x15166050,0x30212536,0x00111506,0x03653236),ivec4(0x31356305,0x00116303,0x10114303,0x00016566),ivec4(0x65615010,0x01051656,0x16016510,0x10303526),ivec4(0x56160550,0x13536465,0x05600002,0x64655616),ivec4(0x62533353,0x01105061,0x63130406,0x66066066),ivec4(0x63540406,0x01105061,0x01051656,0x62615010),ivec4(0x66060353,0x56101165,0x13040516,0x50616253),ivec4(0x13020110,0x56656453,0x05041363,0x61655616),ivec4(0x14011050,0x14101113,0x65001113,0x64046103),ivec4(0x63056101,0x56160501,0x33536465,0x36303132),ivec4(0x63524233,0x05165665,0x00501001,0x63462603),ivec4(0x00620260,0x64655606,0x62530353,0x65005061),ivec4(0x01051656,0x06615010,0x65560600,0x06005061),ivec4(0x06630366,0x66066000,0x00065303,0x05165665),ivec4(0x61501001,0x00064363,0x60666303,0x61661016),ivec4(0x02011050,0x65660006,0x61430343,0x60000660),ivec4(0x32330600,0x00606633,0x10666006,0x56656150),ivec4(0x10010516,0x65560600,0x10035364,0x56656150),ivec4(0x10010516,0x06006142,0x53646556,0x60625303),ivec4(0x05165665,0x62531304,0x01105061,0x30366606),ivec4(0x50100106,0x03066661,0x66634020,0x34330006),ivec4(0x06666033,0x66606105,0x06000165,0x65663305),ivec4(0x66063033,0x60000165,0x30202636,0x60610506),ivec4(0x00101606,0x00543614,0x00000060,0));\n    const ivec4 segments[] = ivec4[](ivec4(0,2,4,6),ivec4(8,10,12,14),ivec4(16,28,30,35),ivec4(40,44,66,68),ivec4(72,76,78,80),ivec4(82,84,86,88),ivec4(90,92,96,105),ivec4(107,111,113,123),ivec4(130,136,140,142),ivec4(144,152,162,167),ivec4(184,195,197,199),ivec4(201,203,206,208),ivec4(210,213,221,223),ivec4(235,241,243,250),ivec4(255,263,265,271),ivec4(273,275,278,280),ivec4(282,284,294,296),ivec4(298,300,302,308),ivec4(310,314,317,320),ivec4(324,327,331,340),ivec4(347,356,358,365),ivec4(368,380,382,384),ivec4(390,396,400,403),ivec4(407,411,414,418),ivec4(424,428,432,436),ivec4(439,441,0,0));\n    const ivec4 chars[] = ivec4[](ivec4(0,2,4,8),ivec4(10,13,14,15),ivec4(16,17,20,22),ivec4(23,24,25,26),ivec4(28,30,31,33),ivec4(35,37,38,39),ivec4(40,41,43,45),ivec4(46,48,49,51),ivec4(52,54,56,57),ivec4(59,62,65,66),ivec4(69,70,71,74),ivec4(75,77,78,79),ivec4(80,82,84,85),ivec4(87,88,89,91),ivec4(93,95,96,97),ivec4(98,99,100,101));\n\n    const ivec4 spaces[] = ivec4[](ivec4(3,5,8,8),ivec4(8,8,3,4),ivec4(4,8,8,3),ivec4(5,3,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,3,3,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(3,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,4,8),ivec4(4,8,8,8));\n\n    int code = int(dot(floor(8.0 * uv), vec2(1, 8)));\n    vec2 p = (fract(8.0 * uv) - 0.5) * 16.0;\n\n    float d = 100.0;\n\n    int seg0 = chars[code / 4][code % 4];\n    code ++;\n    int seg1 = chars[code / 4][code % 4];\n\n    for (int i = seg0; i ++ < seg1;) {\n      int j = i - 1;\n      int vert0 = segments[j / 4][j % 4];\n      j ++;\n      int vert1 = segments[j / 4][j % 4] - 1;\n\n      for (int i = vert0; i ++ < vert1;) {\n        int j = i - 1;\n        int i_iv0 = (vertices[j / 16][j / 4 % 4] >> ((j % 4) * 8));\n        vec2 v0 = vec2((i_iv0 / ivec2(16, 1)) & 15);\n        j ++;\n        int i_iv1 = (vertices[j / 16][j / 4 % 4] >> ((j % 4) * 8));\n        vec2 v1 = vec2((i_iv1 / ivec2(16, 1)) & 15);\n\n        v0 = 1.5 * v0 + vec2(-0.5, 0.5) * (step(2.0, v0) + step(5.0, v0)) - vec2(4.0, 5.0);\n        v1 = 1.5 * v1 + vec2(-0.5, 0.5) * (step(2.0, v1) + step(5.0, v1)) - vec2(4.0, 5.0);\n        d = min(d, sdcapsule2(p - v0, v1 - v0));\n      }\n    }\n\n    fragColor.x = d;\n  }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n// == text =========================================================================================\nfloat sddomainchar(inout vec2 p, int code, float margin) {\n  const ivec4 spaces[] = ivec4[](ivec4(3,5,8,8),ivec4(8,8,3,4),ivec4(4,8,8,3),ivec4(5,3,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,3,3,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(3,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,8,8),ivec4(8,8,4,8),ivec4(4,8,8,2));\n\n  vec2 uv = saturate((p - vec2(4.0, 0.0)) / 16.0 + 0.5);\n  float d = 100.0;\n  if (abs(uv.x - 0.5) < 0.5 && abs(uv.y - 0.5) < 0.5) {\n    uv = (uv + vec2(code % 8, code / 8)) / 8.0;\n    d = texture(iChannel0, uv).x;\n  }\n\n  p.x -= float(spaces[code / 4][code % 4]) + margin;\n\n  return d;\n}\n\n// == primitive isects =============================================================================\nvec4 isectBox(vec3 ro, vec3 rd, vec3 s) {\n  vec3 xo = -ro / rd;\n  vec3 xs = abs(s / rd);\n\n  vec3 dfv = xo - xs;\n  vec3 dbv = xo + xs;\n\n  float df = max(dfv.x, max(dfv.y, dfv.z));\n  float db = min(dbv.x, min(dbv.y, dbv.z));\n  if (df < 0.0) { return vec4(FAR); }\n  if (db < df) { return vec4(FAR); }\n\n  vec3 n = -sign(rd) * step(vec3(df), dfv);\n  return vec4(n, df);\n}\n\nvec4 isectIBox(vec3 ro, vec3 rd, vec3 s) {\n  vec3 xo = -ro / rd;\n  vec3 xs = abs(s / rd);\n\n  vec3 dbv = xo + xs;\n\n  float db = min(dbv.x, min(dbv.y, dbv.z));\n  if (db < 0.0) { return vec4(FAR); }\n\n  vec3 n = -sign(rd) * step(dbv, vec3(db));\n  return vec4(n, db);\n}\n\n// == main =========================================================================================\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor *= 0.0;\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float time = iTime;\n  vec3 seed = hash3f(vec3(uv, time));\n  time += 0.003 * seed.z;\n  float beats = time / i_B2T;\n  float beatpulse = 0.4 + 0.6 * pow(0.5 - 0.5 * cos(TAU * ease(beats, 7.0)), 0.3) * (\n    1.0 - 0.8 * smoothstep(0.0, 1.0, beats - i_TENKAI_BREAK - 1.0) * smoothstep(0.0, -0.5, beats - i_TENKAI_FULLHOUSE)\n  );\n  float beatpulse2 = exp(-5.0 * fract(beats));\n\n  for (int i = ZERO; i ++ < i_SAMPLES;) {\n    vec2 p = (uv - 0.5) + seed.xy / iResolution.y;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 colRem = vec3(0.4, 0.2, 1.0);\n\n    float i_clen = 10.0;\n    mat3 cb = orthBas(colRem);\n    vec3 ro = i_clen * cb[2];\n    vec3 rd = cb * normalize(vec3(p, -10.0));\n\n    vec3 fp = ro + rd * (i_clen - 1.0);\n    ro += cb * vec3(0.01 * tan(2.0 * (seed = hash3f(seed)).xy - 1.0).xy, 0.0);\n    rd = normalize(fp - ro);\n    ro += rd * i_clen * mix(0.5, 0.7, seed.z);\n\n    float i_blur = exp(-0.2 * beats) + 0.04 * smoothstep(i_TENKAI_FADEOUT0, i_TENKAI_FADEOUT1, beats);\n    ro += cb * vec3(i_blur * tan(2.0 * seed.xy - 1.0).xy, 0.0);\n\n    ro.z -= 0.4 * time;\n\n    colRem *= (1.0 - 0.5 * length(p)) / colRem;\n\n    for (int i = ZERO; i ++ < i_REFLECTS;) {\n      vec3 emissive = vec3(0.0);\n      float roughness = 0.3;\n\n      // floor\n      vec4 isect2, isect = vec4(0.0, 1.0, 0.0, -ro.y / rd.y);\n      if (isect.w < 0.0) {\n        isect = vec4(FAR);\n      }\n\n      // floor greebles quadtree shit\n      float grl = max(0.0, -(ro.y - i_GREEBLES_HEIGHT) / rd.y);\n\n      for (int i = ZERO; i ++ < i_GREEBLES_TRAVERSAL;) {\n        // if ray length is already further than isect, break\n        if (isect.w < grl) {\n          break;\n        }\n\n        // if already out of the greebles region, break\n        vec3 gro = ro + rd * grl;\n        if (gro.y * rd.y > 0.0 && abs(gro.y) > i_GREEBLES_HEIGHT) {\n          break;\n        }\n\n        vec3 cell, dice, size = vec3(0.125, i_GREEBLES_HEIGHT, 0.125);\n        for (int i = ZERO; i ++ < 4;) {\n          if (i > 1) {\n            if (dice.y < 0.4) {\n              break;\n            }\n            size.xz /= 1.0 + vec2(step(0.6, dice.y), step(dice.y, 0.7));\n          }\n\n          cell = lofi(gro, 2.0 * size) + size;\n          cell.y = 0.0;\n          dice = hash3f(cell);\n        }\n\n        vec3 i_size = size - vec2(mix(1.0, 1.0 - beatpulse, step(i_TENKAI_FLOOR_BEAT, beats)) * (0.4 + 0.4 * sin(TAU * dice.z + time)) * i_GREEBLES_HEIGHT, i_GREEBLES_GAP).yxy;\n        isect2 = isectBox(ro - cell, rd, i_size);\n        if (isect2.w < isect.w) {\n          isect = isect2;\n          dice = hash3f(dice);\n          emissive *= 0.0;\n          roughness = exp(-1.0 - dice.y);\n          break;\n        }\n\n        // forward to the next cell\n        grl += isectIBox(gro - cell, rd, size).w + 0.01;\n      }\n\n      // plane array\n      float mask = 0.0;\n      float sidez = sign(rd.z);\n      float planez = (floor(ro.z / i_PLANE_INTERVAL) + 0.5 * (1.0 + sidez)) * i_PLANE_INTERVAL;\n\n      for (int i = ZERO; i ++ < i_PLANES_TRAVERSAL;) {\n        isect2 = vec4(0.0, 0.0, -sidez, abs((ro.z - planez) / rd.z));\n\n        // if the plane is already further than existing isect, break\n        if (isect.w < isect2.w) {\n          break;\n        }\n\n        vec3 rp = ro + rd * isect2.w;\n        rp.y -= i_GREEBLES_HEIGHT;\n\n        vec3 id = vec3(planez + vec3(1, 2, 3));\n        vec3 dice = hash3f(id);\n\n        float kind = floor(mod(planez / i_PLANE_INTERVAL, 8.0));\n        if (kind == 4.0) {\n          // rainbow bar\n          if (abs(rp.y - 0.02) < 0.01 * ease(saturate(beats - i_TENKAI_HELLO_RAINBOW_BAR), 5.0)) {\n            mask = 1.0;\n            float i_phase = TAU * dice.z + rp.x;\n            vec3 i_col = mix(\n              1.0 + cos(i_phase + vec3(0, 2, 4)),\n              vec3(smoothstep(2.0, 0.0, abs(rp.x)), 0.1, 1.0),\n              ease(saturate(beats - i_TENKAI_TRANS), 3.0)\n            );\n            emissive += 10.0\n              * exp(-40.0 * rp.y)\n              * mix(1.0, sin(200.0 * rp.x), 0.2)\n              * mix(1.0, sin(60.0 * (rp.x + beats)), 0.2)\n              * mask\n              * i_col\n              * beatpulse;\n          }\n\n          // warning\n          rp.y -= 0.05;\n          float warningheight = 0.025 * ease(saturate(beats - i_TENKAI_BREAK), 5.0) * smoothstep(0.0, -1.0, beats - i_TENKAI_FULLHOUSE);\n          if (abs(rp.y) < warningheight && i_TENKAI_BREAK <= beats && beats < i_TENKAI_FULLHOUSE) {\n            mask = 1.0;\n\n            rp.x = mod(rp.x + 0.1 * time, 1.0) - 0.5;\n            float blind = step(fract(20.0 * (rp.x + rp.y + 0.1 * time)), 0.5) * step(0.3, abs(rp.x)) * step(abs(rp.y), warningheight - 0.008);\n\n            float shape = max(\n              step(texture(iChannel0, saturate(rp.xy / 24.0 / warningheight + 0.5)).y, 1.0),\n              blind\n            );\n\n            emissive += mix(\n              mix(\n                vec3(1.0, 0.04, 0.04),\n                vec3(1.0, 0.5, 0.04),\n                mod(floor(beats), 2.0)\n              ),\n              mix(\n                vec3(1.0),\n                vec3(0.0),\n                mod(floor(beats), 2.0)\n              ),\n              shape\n            );\n\n          }\n        } else if (kind == 0.0) {\n          // large pillar\n          float i_ratio = ease(saturate(beats - i_TENKAI_HELLO_LARGE_PILLAR), 3.0);\n          rp.x = abs(abs(rp.x) - 0.5) / 0.05 / i_ratio;\n          if (rp.x < 1.0) {\n            mask = 1.0;\n            vec3 i_col = exp(-rp.y) * mix(\n              vec3(4.0, 6.0, 8.0),\n              vec3(9.0 * exp(-4.0 * rp.y), 0.5, 8.0),\n              ease(saturate(beats - i_TENKAI_TRANS), 3.0)\n            ) * beatpulse * cos(0.9 * rp.x);\n            emissive += i_col;\n          }\n        } else if (kind == 2.0) {\n          // rave laser\n          rp.y += 0.01;\n          float t = dice.y + floor(beats);\n          float d = min(\n            max(abs(mod((rp.xy * rotate2D(t)).x, 0.04) - 0.02), 0.0),\n            max(abs(mod((rp.xy * rotate2D(-t)).x, 0.04) - 0.02), 0.0)\n          );\n          vec3 i_col = mix(\n            vec3(0.1, 10.0, 2.0),\n            vec3(10.0, 0.1, 0.1),\n            ease(saturate(beats - i_TENKAI_TRANS), 3.0)\n          );\n          emissive += step(i_TENKAI_HELLO_LASER, beats) * smoothstep(2.0, 0.0, abs(rp.x)) * exp(-4.0 * abs(rp.y)) * beatpulse2 * step(d, 0.001) * i_col;\n        } else if (kind == 6.0) {\n          if (i_TENKAI_HELLO_HUGE_STUFF <= beats && beats < i_TENKAI_BREAK || i_TENKAI_FULLHOUSE <= beats && beats < i_TENKAI_OUTRO) {\n            // huge stuff\n            dice = hash3f(dice + floor(beats));\n            rp.x += floor(9.0 * dice.y - 4.0) * 0.25;\n\n            if (dice.x < 0.25) {\n              // pillars\n              mask = step(abs(rp.x), 0.125) * step(abs(fract(64.0 * rp.x) - 0.5), 0.05);\n            } else if (dice.x < 0.5) {\n              // x\n              rp.y -= 0.25;\n              float i_range = max(abs(rp.x) - 0.25, abs(rp.y) - 0.25);\n              mask = max(\n                step(abs(rp.x + rp.y), 0.002),\n                step(abs(rp.x - rp.y), 0.002)\n              ) * step(i_range, 0.0);\n            } else if (dice.x < 0.75) {\n              // dashed box\n              dice.yz = exp(-3.0 * dice.yz);\n              rp.y -= dice.z;\n              float d = max(abs(rp.x) - dice.y, abs(rp.y) - dice.z);\n              float shape = step(abs(d), 0.001) * step(0.5, fract(dot(rp, vec3(32.0)) + time));\n              mask = shape;\n            } else {\n              // huge circle\n              rp.y -= 0.5;\n              mask = step(abs(length(rp.xy) - 0.5), 0.001);\n            }\n\n            emissive += 10.0 * beatpulse2 * mask;\n            mask = 0.0;\n          }\n        } else if (abs(rp.x) < 1.0 && i_TENKAI_HELLO_RGB_DELAY <= beats) {\n          // rgb delay shit\n          float size = 0.25;\n          dice = hash3f(vec3(floor(rp.xy / size), dice.z));\n          size /= 1.0 + step(0.3, dice.z);\n          dice = hash3f(vec3(floor(rp.xy / size), dice.z));\n          size /= 1.0 + step(0.5, dice.z);\n          dice = hash3f(vec3(floor(rp.xy / size), dice.z));\n          vec2 cp = rp.xy / size;\n\n          if (abs(cp.y - 0.5) < 0.5) {\n            cp = (fract(cp.xy) - 0.5) * size / (size - 0.01);\n\n            if (abs(cp.x) < 0.5 && abs(cp.y) < 0.5) {\n              float off = (seed = hash3f(seed)).y;\n              float beatsoff = beats - 0.2 * off + 0.1;\n              vec3 col = 4.0 * 3.0 * (0.5 - 0.5 * cos(TAU * saturate(1.5 * off - vec3(0.0, 0.25, 0.5)))) * (1.0 + sin(400.0 * rp.y + 100.0 * beatsoff));\n              float timegroup = floor(4.0 * dice.x);\n\n              if (beatsoff < i_TENKAI_RGB_DELAY_4FLOOR) {\n                // b2sSwing\n                float st = 4.0 * beatsoff;\n                st = 2.0 * floor(st / 2.0) + step(i_SWING, fract(0.5 * st));\n\n                st = clamp(st, 4.0 * i_TENKAI_HELLO_RGB_DELAY + 10.0, 4.0 * i_TENKAI_RGB_DELAY_4FLOOR - 16.0);\n                st += floor(st / 32.0);\n                st -= 1.0 + 3.0 * timegroup;\n                st = lofi(st, 12.0);\n                st += 1.0 + 3.0 * timegroup;\n                st -= floor(st / 32.0);\n\n                float i_bst = 0.5 * (floor(st / 2.0) + i_SWING * mod(st, 2.0));\n                float t = beatsoff - i_bst;\n\n                col *= vec3(1.0, 0.04, 0.1) * step(0.0, t) * (exp(-4.0 * t) + exp(-40.0 * t));\n              } else if (beatsoff < i_TENKAI_BREAK) {\n                float b = beatsoff;\n\n                b = clamp(b, i_TENKAI_RGB_DELAY_4FLOOR + 3.0, i_TENKAI_FULLHOUSE);\n                b -= timegroup;\n                b = lofi(b, 4.0);\n                b += timegroup;\n\n                float t = beatsoff - b;\n\n                col *= step(0.0, t) * (exp(-2.0 * t) + exp(-20.0 * t)) * (0.5 + 0.5 * cos(PI * 5.0 * saturate(2.0 * (beatsoff - i_TENKAI_BREAK + 0.5))));\n              } else {\n                float thr = sqrt(fract(dice.x * 999.0));\n\n                col *= smoothstep(0.0, 4.0, beatsoff - i_TENKAI_BREAK - 32.0 * thr) * mix(vec3(1.0), vec3(1.0, 0.05, 0.12), ease(saturate(beats - i_TENKAI_TRANS), 3.0));\n              }\n\n              col = max(col, 0.0);\n\n              float phase = (\n                1.0\n                + max(beatsoff - timegroup - i_TENKAI_BREAK, 0.0) / 4.0\n                + max(beatsoff - timegroup - i_TENKAI_FULLHOUSE, 0.0) / 4.0\n              );\n\n              float ephase = ease(phase, 6.0);\n              float ephase0 = min(mod(ephase, 2.0), 1.0);\n              float ephase1 = max(mod(ephase, 2.0) - 1.0, 0.0);\n\n              dice.z *= 24.0;\n\n              if (dice.z < 1.0) {\n                // ,',\n                cp *= rotate2D(3.0 * PI * ephase);\n                float theta = lofi(atan(cp.x, cp.y), TAU / 3.0) + PI / 3.0;\n                cp = (cp * rotate2D(theta) - vec2(0.0, 0.3));\n                float shape = step(length(cp), 0.1);\n                emissive += col * shape;\n              } else if (dice.z < 2.0) {\n                // circle\n                emissive += col * step(0.5 * ephase0 - 0.2, length(cp)) * step(length(cp), 0.5 * ephase0) * step(1.1 * ephase1, fract(atan(cp.y, cp.x) / TAU - ephase1 - 2.0 * TAU * dice.y));\n              } else if (dice.z < 3.0) {\n                // slide\n                cp.x *= sign(dice.y - 0.5);\n                cp *= rotate2D(PI / 4.0);\n                cp.x += 2.0 * sign(cp.y) * (1.0 - ephase0);\n                cp = abs(cp);\n                float shape = step(0.03 + ephase1, cp.y) * step(max(cp.x, cp.y), 0.65) * step(cp.x + cp.y, 1.0 / SQRT2);\n                emissive += col * shape;\n              } else if (dice.z < 4.0) {\n                // dot matrix\n                float shape = step(abs(cp.y), 0.5) * step(abs(cp.x), 0.5);\n                cp *= 4.0;\n                shape *= step(length(fract(cp) - 0.5), 0.4);\n                cp = floor(cp);\n                float i_rand = floor(12.0 * min(fract(phase), 0.5));\n                emissive += col * shape * step(\n                  hash3f(vec3(cp, dice.y + i_rand)).x,\n                  0.3 - 0.3 * cos(PI * ephase)\n                );\n              } else if (dice.z < 5.0) {\n                // target\n                cp = abs(cp);\n                float i_shape = max(\n                  step(abs(max(cp.x, cp.y) - 0.48), 0.02) * step(0.8 - 0.6 * ephase0, min(cp.x, cp.y)),\n                  step(max(cp.x, cp.y), 0.15 * ephase0) * step(abs(min(cp.x, cp.y)), 0.02)\n                ) * step(fract(3.0 * max(ephase1, 0.5)), 0.5);\n                emissive += col * i_shape;\n              } else if (dice.z < 6.0) {\n                // hex\n                cp *= rotate2D(TAU * lofi(dice.y - ephase, 1.0 / 6.0));\n                float cell = floor(atan(cp.x, cp.y) / TAU * 6.0 + 0.5);\n                cp *= rotate2D(cell / 6.0 * TAU);\n                float i_shape = (\n                  step(0.02, dot(abs(cp), vec2(-SQRT3_OVER_TWO, 0.5)))\n                  * step(0.24, cp.y)\n                  * step(cp.y, 0.44)\n                ) * step(mod(cell, 3.0), 1.0 - 1.1 * cos(PI * ephase));\n                emissive += col * i_shape;\n              } else if (dice.z < 7.0) {\n                // 0b5vr (hide in the first half)\n                cp = floor(8.0 * cp + 0.5);\n                float i_lcp = length(cp);\n                float i_rand = floor(16.0 * phase);\n                float i_obsvr = step(i_lcp, 0.5) + step(1.5, i_lcp) * step(i_lcp, 2.5);\n                float i_shape = step(\n                  hash3f(vec3(cp, dice.y + i_rand)).x,\n                  0.5 + 0.5 * cos(PI * ephase)\n                ) * i_obsvr;\n                emissive += col * i_shape;\n              } else if (dice.z < 8.0) {\n                // char\n                float i_rand = floor(30.0 * min(fract(phase), 0.2)) + floor(phase);\n                int i_char = int(64.0 * hash3f(dice + i_rand).x);\n                cp = 12.0 * cp + vec2(4.0, 0.0);\n                float i_d = sddomainchar(cp, i_char, 0.0);\n                emissive += col * step(i_d, 0.5);\n              } else if (dice.z < 12.0) {\n                // arrow\n                cp /= 0.001 + ephase0;\n\n                float blink = floor(min(8.0 * ephase1, 3.0));\n\n                float dout, din = 1.0;\n\n                if (dice.z < 9.0) {\n                  // arrow\n                  vec2 cpt = vec2(\n                    abs(cp.x),\n                    0.8 - fract(cp.y + 0.5 - 2.0 * ephase0)\n                  );\n\n                  din = min(\n                    sdcapsule2(cpt, vec2(0.0, 0.6)),\n                    sdcapsule2(cpt, vec2(0.3, 0.3))\n                  ) - 0.07;\n\n                  cpt = cp;\n                  cpt -= clamp(cpt, -0.4, 0.4);\n                  dout = length(cpt) - 0.05;\n                } else if (dice.z < 10.0) {\n                  // error\n                  dout = length(cp) - 0.45;\n\n                  cp *= rotate2D(PI * ephase0 + PI / 4.0);\n                  cp = abs(cp);\n\n                  din = max(\n                    max(cp.x, cp.y) - 0.25,\n                    min(cp.x, cp.y) - 0.07\n                  );\n                } else if (dice.z < 11.0) {\n                  // warning\n                  cp.x = abs(cp.x);\n                  din = max(\n                    cp.x - 0.07,\n                    min(\n                      abs(cp.y) - 0.15,\n                      abs(cp.y + 0.27) - 0.05\n                    )\n                  ) + step(fract(3.9 * ephase0), 0.5);\n\n                  dout = mix(\n                    min(\n                      sdcapsule2(cp - vec2(0.0, 0.35), vec2(0.4, -0.7)),\n                      sdcapsule2(cp + vec2(0.0, 0.35), vec2(0.4, 0.0))\n                    ),\n                    0.0,\n                    step(dot(cp, vec2(0.7, 0.4)), 0.11) * step(-0.4, cp.y) // cringe\n                  ) - 0.05;\n                } else {\n                  // power\n                  dout = 0.3 * ephase0 * ephase0;\n                  dout = sdcapsule2(cp - vec2(0.0, 0.1), vec2(0.0, dout)) - 0.07;\n                  float i_ring = max(\n                    abs(length(cp) - 0.4) - 0.07,\n                    -dout + 0.07\n                  );\n                  dout = min(dout, i_ring);\n                }\n\n                float i_shape = mix(\n                  mix(\n                    step(max(dout, -din), 0.0),\n                    step(abs(max(dout, -din)), 0.01),\n                    saturate(blink)\n                  ),\n                  mix(\n                    step(din, 0.0),\n                    0.0,\n                    saturate(blink - 2.0)\n                  ),\n                  saturate(blink - 1.0)\n                );\n                emissive += col * i_shape;\n              }\n            }\n          }\n        }\n\n        // if the mask test misses, traverse the next plane\n        if (mask == 0.0) {\n          planez += i_PLANE_INTERVAL * sidez;\n          continue;\n        }\n\n        // hit!\n        isect = isect2;\n        roughness = 0.0;\n        break;\n      }\n\n      // emissive\n      fragColor.xyz += colRem * emissive;\n\n      // if mask is set, break\n      if (mask > 0.0) {\n        break;\n      }\n\n      // the ray missed all of the above, you suck\n      if (isect.w >= FAR) {\n        float i_intro = 0.5 * smoothstep(0.0, 32.0, beats) * (0.01 + smoothstep(32.0, 31.5, beats));\n        fragColor.xyz += colRem * i_intro;\n        break;\n      }\n\n      // now we have a hit\n\n      // set materials\n      ro += isect.w * rd + isect.xyz * 0.001;\n      float sqRoughness = roughness * roughness;\n      float sqSqRoughness = sqRoughness * sqRoughness;\n      float halfSqRoughness = 0.5 * sqRoughness;\n\n      // shading\n      {\n        float NdotV = dot(isect.xyz, -rd);\n        float Fn = mix(0.04, 1.0, pow(1.0 - NdotV, 5.0));\n        float spec = 1.0;\n\n        // sample ggx or lambert\n        seed.y = sqrt((1.0 - seed.y) / (1.0 - (1.0 - sqSqRoughness) * seed.y));\n        vec3 i_H = orthBas(isect.xyz) * vec3(\n          sqrt(1.0 - seed.y * seed.y) * sin(TAU * seed.z + vec2(0.0, TAU / 4.0)),\n          seed.y\n        );\n\n        // specular\n        vec3 wo = reflect(rd, i_H);\n        if (dot(wo, isect.xyz) < 0.0) {\n          break;\n        }\n\n        // vector math\n        float NdotL = dot(isect.xyz, wo);\n        float i_VdotH = dot(-rd, i_H);\n        float i_NdotH = dot(isect.xyz, i_H);\n\n        // fresnel\n        vec3 i_baseColor = vec3(0.3);\n        vec3 i_F0 = i_baseColor;\n        vec3 i_Fh = mix(i_F0, vec3(1.0), pow(1.0 - i_VdotH, 5.0));\n\n        // brdf\n        // colRem *= Fh / Fn * G * VdotH / ( NdotH * NdotV );\n        colRem *= saturate(\n          i_Fh\n            / (NdotV * (1.0 - halfSqRoughness) + halfSqRoughness) // G1V / NdotV\n            * NdotL / (NdotL * (1.0 - halfSqRoughness) + halfSqRoughness) // G1L\n            * i_VdotH / i_NdotH\n        );\n\n        // prepare the rd for the next ray\n        rd = wo;\n      }\n\n      if (dot(colRem, colRem) < 0.01) {\n        break;\n      }\n    }\n\n    // title\n    if (beats < i_TENKAI_HELLO_RGB_DELAY) {\n      float phase = (float(i - 1) + seed.x) / i_SAMPLES_F;\n      float diffuse = phase * phase * phase * phase;\n      p += (exp(-0.08 * beats) * diffuse + 0.5 * exp(-0.4 * beats) * phase) * cyclic(vec3(4.0 * p, 0.2 * time) + 5.0, 0.5, 1.4).xy;\n\n      float d = 100.0;\n\n      d = texture(iChannel0, saturate(0.7 * p + 0.5)).y;\n\n      // render\n      float shape = smoothstep(2.0 * diffuse, 0.0, d - 0.2);\n      vec3 i_col = 3.0 * (0.5 - 0.5 * cos(TAU * saturate(1.5 * phase - vec3(0.0, 0.25, 0.5))));\n      fragColor.xyz += shape * i_col * smoothstep(-1.0, -4.0, beats - i_TENKAI_HELLO_RGB_DELAY);\n    }\n  }\n\n  fragColor.xyz = mix(\n    smoothstep(\n      vec3(-0.0, -0.1, -0.2),\n      vec3(1.0, 1.1, 1.2),\n      sqrt(fragColor.xyz / i_SAMPLES_F)\n    ),\n    max(texture(iChannel1, uv), 0.0).xyz,\n    0.5\n  ) * smoothstep(0.0, 4.0, beats) * smoothstep(i_TENKAI_FADEOUT1, i_TENKAI_FADEOUT0, beats);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n// == constants ====================================================================================\nconst float FAR = 44.0;\n\nconst float PI = acos(-1.0);\nconst float TAU = PI + PI;\nconst float SQRT2 = sqrt(2.0);\nconst float SQRT3 = sqrt(3.0);\nconst float SQRT3_OVER_TWO = SQRT3 / 2.0;\n\nconst float i_B2T = 0.43;\nconst float i_SWING = 0.62;\nconst int i_SAMPLES = 10;\nconst float i_SAMPLES_F = 10.0;\nconst int i_PLANES_TRAVERSAL = 16;\nconst int i_REFLECTS = 3;\n\nconst float i_GREEBLES_GAP = 0.01;\nconst int i_GREEBLES_TRAVERSAL = 8;\nconst float i_GREEBLES_HEIGHT = 0.03;\nconst float i_PLANE_INTERVAL = 0.5;\n\nfloat i_TENKAI_HELLO_RGB_DELAY = 32.0 + 0.5 * i_SWING;\nconst float i_TENKAI_HELLO_HUGE_STUFF = 64.0;\nconst float i_TENKAI_FLOOR_BEAT = 64.0;\nconst float i_TENKAI_HELLO_LARGE_PILLAR = 96.0;\nconst float i_TENKAI_RGB_DELAY_4FLOOR = 96.0;\nconst float i_TENKAI_BREAK = 192.0;\nconst float i_TENKAI_HELLO_RAINBOW_BAR = 224.0;\nconst float i_TENKAI_HELLO_LASER = 224.0;\nconst float i_TENKAI_FULLHOUSE = 224.0;\nconst float i_TENKAI_TRANS = i_TENKAI_FULLHOUSE + 64.0;\nconst float i_TENKAI_OUTRO = i_TENKAI_TRANS + 64.0;\nconst float i_TENKAI_FADEOUT0 = i_TENKAI_OUTRO + 16.0;\nconst float i_TENKAI_FADEOUT1 = i_TENKAI_FADEOUT0 + 16.0;\n\n// == macros =======================================================================================\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define lofi(i, m) (floor((i) / (m)) * (m))\n\n// iq's anti loop unroll measure\n#define ZERO min(iFrame, 0)\n\n// == hash / random ================================================================================\nuvec3 seed;\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash3f(vec3 s) {\n  uvec3 r = floatBitsToUint(s);\n  r = ((r >> 16u) ^ r.yzx) * 1111111111u;\n  r = ((r >> 16u) ^ r.yzx) * 1111111111u;\n  r = ((r >> 16u) ^ r.yzx) * 1111111111u;\n  return vec3(r) / float(-1u);\n}\n\nvec3 uniformSphere(vec2 xi) {\n  float phi = xi.x * TAU;\n  float sinTheta = 1.0 - 2.0 * xi.y;\n  float cosTheta = sqrt(1.0 - sinTheta * sinTheta);\n\n  return vec3(\n    cosTheta * cos(phi),\n    cosTheta * sin(phi),\n    sinTheta\n  );\n}\n\n// == math utils ===================================================================================\nmat2 rotate2D(float t) {\n  return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nmat3 orthBas(vec3 z) {\n  z = normalize(z);\n  vec3 up = abs(z.y) < 0.99 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n  vec3 x = normalize(cross(up, z));\n  return mat3(x, cross(z, x), z);\n}\n\nvec2 cis(float t) {\n  return vec2(cos(t), sin(t));\n}\n\n// == noise ========================================================================================\nvec3 cyclic(vec3 p, float pers, float lacu) {\n  vec4 sum = vec4(0);\n  mat3 rot = orthBas(vec3(2, -3, 1));\n\n  for (int i = 0; i ++ < 5;) {\n    p *= rot;\n    p += sin(p.zxy);\n    sum += vec4(cross(cos(p), sin(p.yzx)), 1);\n    sum /= pers;\n    p *= lacu;\n  }\n\n  return sum.xyz / sum.w;\n}\n\n// == anim utils ===================================================================================\nfloat ease(float t, float k) {\n  float tt = fract(1.0 - t);\n  return floor(t) + float(tt > 0.0) - (k + 1.0) * pow(tt, k) + k * pow(tt, k + 1.0);\n}\n\n// == 2d sdfs ======================================================================================\nfloat sdcapsule2(vec2 p, vec2 tail) {\n  float i_t = saturate(dot(p, tail) / dot(tail, tail));\n  return length(p - i_t * tail);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"// This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// https://creativecommons.org/licenses/by-nc/4.0/\n\n#define lofi(i, m) (floor((i) / (m)) * (m))\n#define p2f(i) (exp2(((i)-69.)/12.)*440.)\n#define tri(p) (1.-4.*abs(fract(p)-0.5))\n\nconst float B2T = 0.43;\nconst float SWING = 0.62;\n\n// == rhythm stuff =================================================================================\nfloat t2sSwing(float t) {\n  float st = 4.0 * t / B2T;\n  return 2.0 * floor(st / 2.0) + step(SWING, fract(0.5 * st));\n}\n\nfloat s2tSwing(float st) {\n  return 0.5 * B2T * (floor(st / 2.0) + SWING * mod(st, 2.0));\n}\n\nvec4 seq16(float t, int seq) {\n  t = mod(t, 4.0 * B2T);\n  int sti = int(t2sSwing(t));\n  int rotated = ((seq >> (15 - sti)) | (seq << (sti + 1))) & 0xffff;\n\n  float i_prevStepBehind = log2(float(rotated & -rotated));\n  float prevStep = float(sti) - i_prevStepBehind;\n  float prevTime = s2tSwing(prevStep);\n  float i_nextStepForward = 16.0 - floor(log2(float(rotated)));\n  float nextStep = float(sti) + i_nextStepForward;\n  float nextTime = s2tSwing(nextStep);\n\n  return vec4(\n    prevStep,\n    t - prevTime,\n    nextStep,\n    nextTime - t\n  );\n}\n\n// == osc stuff ====================================================================================\nvec2 shotgun( float t, float spread ) {\n  vec2 sum = vec2(0.0);\n\n  for (int i = 0; i ++ < 64;) {\n    vec3 dice = hash3f(float(i) + vec3(7, 1, 3));\n    sum += vec2(sin(TAU * t * exp2(spread * dice.x))) * rotate2D(TAU * dice.y);\n  }\n\n  return sum / 64.0;\n}\n\n// == main =========================================================================================\nvec2 mainSound(int frame, float _) {\n  const float i_TENKAI_HELLO_RIM = 32.0;\n  const float i_TENKAI_HELLO_RAVE = 32.0;\n  const float i_TENKAI_HELLO_KICK = i_TENKAI_HELLO_RAVE + 32.0;\n  const float i_TENKAI_HELLO_BASS = i_TENKAI_HELLO_RAVE + 64.0;\n  const float i_TENKAI_HELLO_HIHAT = i_TENKAI_HELLO_BASS;\n  const float i_TENKAI_HELLO_FMPERC = i_TENKAI_HELLO_BASS;\n  const float i_TENKAI_HELLO_HIHAT_16TH = i_TENKAI_HELLO_BASS + 32.0;\n  const float i_TENAKI_HELLO_CLAP = i_TENKAI_HELLO_BASS + 32.0;\n  const float i_TENKAI_HELLO_OH = i_TENAKI_HELLO_CLAP + 32.0;\n  const float i_TENKAI_BREAK = i_TENKAI_HELLO_OH + 32.0;\n  const float i_TENKAI_FULLHOUSE = i_TENKAI_HELLO_OH + 64.0;\n  const float i_TENKAI_TRANS = i_TENKAI_FULLHOUSE + 64.0;\n  const float i_TENKAI_OUTRO = i_TENKAI_TRANS + 64.0;\n  const float i_TENKAI_FADEOUT0 = i_TENKAI_OUTRO + 8.0;\n  const float i_TENKAI_FADEOUT1 = i_TENKAI_OUTRO + 32.0;\n\n  int samplesPerBeat = int(iSampleRate * B2T);\n  vec4 time = vec4(frame % (samplesPerBeat * ivec4(1, 4, 32, 65536))) / iSampleRate;\n  float beats = time.w / B2T;\n  float beatsbar = lofi(beats, 4.0);\n  float beats8bar = lofi(beats, 32.0);\n\n  bool i_condKickHipass = (\n    ((i_TENKAI_HELLO_BASS - 3.0) <= beats && beats < i_TENKAI_HELLO_BASS) ||\n    (i_TENKAI_BREAK <= beats && beats < i_TENKAI_FULLHOUSE - 4.0)\n  );\n\n  int i_patternKick =\n    beatsbar == (i_TENKAI_HELLO_OH - 4.0) ? 0x88a6 :\n    beatsbar == (i_TENKAI_FULLHOUSE - 4.0) ? 0x808f :\n    beatsbar == (i_TENKAI_TRANS - 4.0) ? 0x809e :\n    beatsbar == (i_TENKAI_OUTRO - 4.0) ? 0xa18e :\n    0x8888;\n\n  float i_timeCrash = float(frame - samplesPerBeat * int(\n    i_TENKAI_OUTRO <= beats ? i_TENKAI_OUTRO :\n    i_TENKAI_OUTRO - 4.0 <= beats ? i_TENKAI_OUTRO - 4.0 :\n    i_TENKAI_TRANS <= beats ? i_TENKAI_TRANS :\n    i_TENKAI_TRANS - 4.0 <= beats ? i_TENKAI_TRANS - 4.0 :\n    i_TENKAI_FULLHOUSE <= beats ? i_TENKAI_FULLHOUSE :\n    i_TENKAI_FULLHOUSE - 4.0 <= beats ? i_TENKAI_FULLHOUSE - 4.0 :\n    i_TENKAI_HELLO_OH <= beats ? i_TENKAI_HELLO_OH :\n    i_TENKAI_HELLO_BASS <= beats ? i_TENKAI_HELLO_BASS :\n    i_TENKAI_HELLO_KICK <= beats ? i_TENKAI_HELLO_KICK :\n    -111.0\n  )) / iSampleRate;\n\n  float i_volumeSnare = (\n    beats8bar == i_TENKAI_BREAK ? smoothstep(0.0, 32.0 * B2T, time.z) :\n    beatsbar == (i_TENKAI_FULLHOUSE - 4.0) ? smoothstep(-4.0 * B2T, 4.0 * B2T, time.y) :\n    beatsbar == (i_TENKAI_TRANS - 4.0) ? smoothstep(-4.0 * B2T, 4.0 * B2T, time.y) :\n    beatsbar == (i_TENKAI_OUTRO - 4.0) ? smoothstep(-4.0 * B2T, 4.0 * B2T, time.y) :\n    0.0\n  );\n\n  bool i_rollSnare = (\n    beats8bar == i_TENKAI_BREAK ? 28.0 * B2T < time.z :\n    2.0 * B2T < time.y\n  );\n\n  vec2 dest = vec2(0);\n  float sidechain = 1.0;\n\n  if (i_TENKAI_HELLO_KICK <= beats) { // kick\n    vec4 seq = seq16(time.y, i_patternKick);\n    float t = seq.y;\n    float q = seq.w;\n\n    float env = smoothstep(0.3, 0.2, t);\n\n    if (i_condKickHipass) { // hi-pass like\n      env *= exp2(-60.0 * t);\n    }\n\n    vec2 wave = vec2(0.0);\n    vec2 phase = vec2(40.0 * t);\n    phase -= 9.0 * exp2(-25.0 * t);\n    phase -= 3.0 * exp2(-50.0 * t);\n    phase -= 3.0 * exp2(-500.0 * t);\n    wave += sin(TAU * phase);\n\n    dest += 0.5 * env * tanh(1.3 * wave);\n\n    sidechain = smoothstep(0.0, 0.7 * B2T, time.x) * smoothstep(0.0, 0.01 * B2T, B2T - time.x);\n    sidechain *= 0.5 + 0.5 * smoothstep(0.0, 0.7 * B2T, t) * smoothstep(0.0, 0.01 * B2T, q);\n  }\n\n  if (i_TENKAI_HELLO_HIHAT <= beats && beats < i_TENKAI_OUTRO) { // hihat\n    int i_patternCH =\n      i_TENKAI_HELLO_HIHAT_16TH <= beats ? 0xffff :\n      0xeaaa;\n    vec4 seq = seq16(time.y, i_patternCH);\n    float t = seq.y;\n\n    float vel = fract(seq.x * 0.38);\n    float env = exp2(-exp2(6.0 - 1.0 * vel - float(mod(seq.x, 4.0) == 2.0)) * t);\n    vec2 wave = shotgun(6000.0 * t, 2.0);\n    dest += 0.16 * env * mix(0.2, 1.0, sidechain) * tanh(8.0 * wave);\n  }\n\n  if (i_TENKAI_HELLO_OH <= beats && beats < i_TENKAI_OUTRO) { // open hihat\n    vec4 seq = seq16(time.y, 0x2222);\n    float t = seq.y;\n\n    vec2 sum = vec2(0.0);\n\n    for (int i = 0; i ++ < 8;) {\n      vec3 dice = hash3f(vec3(i));\n      vec3 dice2 = hash3f(dice);\n\n      vec2 wave = vec2(0.0);\n      wave = 4.5 * exp2(-5.0 * t) * sin(wave + exp2(13.30 + 0.1 * dice.x) * t + dice2.xy);\n      wave = 3.2 * exp2(-1.0 * t) * sin(wave + exp2(11.78 + 0.3 * dice.y) * t + dice2.yz);\n      wave = 1.0 * exp2(-5.0 * t) * sin(wave + exp2(14.92 + 0.2 * dice.z) * t + dice2.zx);\n\n      sum += wave;\n    }\n\n    dest += 0.1 * exp2(-14.0 * t) * sidechain * tanh(2.0 * sum);\n  }\n\n  if (i_TENKAI_HELLO_FMPERC <= beats && beats < i_TENKAI_OUTRO) { // fm perc\n    vec4 seq = seq16(time.y, 0xffff);\n    float t = seq.y;\n    float q = seq.w;\n    vec3 dice = hash3f(vec3(seq.x, mod(beatsbar, 32.0), 1.0));\n\n    float freq = exp2(9.0 + 2.0 * dice.x);\n    float env = exp2(-exp2(3.0 + 5.0 * dice.y) * t) * smoothstep(0.0, 0.01, q);\n    float fm = env * exp2(2.0 + 4.0 * dice.z) * sin(freq * exp2(-t));\n    float wave = sin(fm);\n    dest += 0.05 * sidechain * vec2(wave) * rotate2D(seq.x);\n  }\n\n  if (i_TENKAI_HELLO_RIM <= beats && beats < i_TENKAI_OUTRO) { // rim\n    vec4 seq = seq16(time.y, 0x6db7);\n    float t = seq.y;\n\n    float env = step(0.0, t) * exp2(-400.0 * t);\n\n    float wave = tanh(4.0 * (\n      + tri(t * 400.0 - 0.5 * env)\n      + tri(t * 1500.0 - 0.5 * env)\n    ));\n\n    dest += 0.2 * env * vec2(wave) * rotate2D(seq.x);\n  }\n\n  if (i_TENKAI_FULLHOUSE <= beats && beats < i_TENKAI_OUTRO) { // ride\n    vec4 seq = seq16(time.y, 0xaaaa);\n    float t = seq.y;\n    float q = seq.w;\n\n    float env = exp2(-4.0 * t) * smoothstep(0.0, 0.01, q);\n\n    vec2 sum = vec2(0.0);\n\n    for (int i = 0; i ++ < 8;) {\n      vec3 dice = hash3f(vec3(i));\n      vec3 dice2 = hash3f(dice);\n\n      vec2 wave = vec2(0.0);\n      wave = 2.9 * env * sin(wave + exp2(13.10 + 0.4 * dice.x) * t + dice2.xy);\n      wave = 2.8 * env * sin(wave + exp2(14.97 + 0.4 * dice.y) * t + dice2.yz);\n      wave = 1.0 * env * sin(wave + exp2(14.09 + 1.0 * dice.z) * t + dice2.zx);\n\n      sum += wave;\n    }\n\n    dest += 0.05 * env * mix(0.3, 1.0, sidechain) * tanh(sum);\n  }\n\n  if (i_TENAKI_HELLO_CLAP <= beats && beats < i_TENKAI_OUTRO) { // clap\n    vec4 seq = seq16(time.y, 0x0808);\n    float t = seq.y;\n    float q = seq.w;\n\n    float env = mix(\n      exp2(-80.0 * t),\n      exp2(-500.0 * mod(t, 0.012)),\n      exp2(-100.0 * max(0.0, t - 0.02))\n    );\n\n    vec2 wave = cyclic(vec3(4.0 * cis(800.0 * t), 840.0 * t), 0.5, 2.0).xy;\n\n    dest += 0.15 * tanh(20.0 * env * wave);\n  }\n\n  if (i_volumeSnare > 0.0) { // snare909\n    vec4 seq = seq16(time.y, 0xffff);\n    float t = i_rollSnare\n      ? mod(time.y, B2T / 6.0)\n      : seq.y;\n\n    float env = exp(-20.0 * t);\n\n    vec2 wave = (\n      cyclic(vec3(cis(4000.0 * t), 4000.0 * t), 1.0, 2.0).xy\n      + sin(1400.0 * t - 40.0 * exp2(-t * 200.0))\n    );\n\n    dest += 0.2 * i_volumeSnare * mix(0.3, 1.0, sidechain) * tanh(4.0 * env * wave);\n  }\n\n  { // crash\n    float t = i_timeCrash;\n\n    float env = mix(exp2(-t), exp2(-14.0 * t), 0.7);\n    vec2 wave = shotgun(4000.0 * t, 2.5);\n    dest += 0.4 * env * mix(0.1, 1.0, sidechain) * tanh(8.0 * wave);\n  }\n\n  { // chord stuff\n    const int N_CHORD = 8;\n    const int CHORD[N_CHORD] = int[](\n      0, 7, 10, 12, 15, 17, 19, 22\n    );\n\n    float t = mod(time.z, 8.0 * B2T);\n    float st = max(1.0, lofi(mod(t2sSwing(t) - 1.0, 32.0), 3.0) + 1.0);\n    float stt = s2tSwing(st);\n    t = mod(t - stt, 8.0 * B2T);\n    float nst = min(st + 3.0, 33.0);\n    float nstt = s2tSwing(nst);\n    float l = nstt - stt;\n    float q = l - t;\n\n    if (beats < i_TENKAI_HELLO_RAVE) {\n      t = time.z;\n      q = i_TENKAI_HELLO_RAVE * B2T - t;\n    }\n\n    float env = smoothstep(0.0, 0.001, t) * smoothstep(0.0, 0.001, q);\n    float trans = 3.0 * step(beats, i_TENKAI_TRANS) + step(i_TENKAI_HELLO_RAVE, beats) * step(st, 3.0);\n\n    if (i_TENKAI_HELLO_BASS <= beats) { // bass\n      float note = 24.0 + trans + float(CHORD[0]);\n      float freq = p2f(note);\n      float phase = freq * t;\n      float wave = tanh(2.0 * sin(TAU * phase));\n\n      dest += 0.5 * sidechain * env * wave;\n    }\n\n    if (beats < i_TENKAI_HELLO_RAVE) { // longnote\n      env *= smoothstep(1.0, i_TENKAI_HELLO_RAVE, beats);\n    } else { // env\n      env *= mix(\n        smoothstep(0.6 * l, 0.4 * l, t - 0.4 * l * step(i_TENKAI_FULLHOUSE, beats)),\n        exp2(-5.0 * t),\n        0.1\n      );\n    }\n\n    { // choir\n      vec2 sum = vec2(0.0);\n\n      for (int i = 0; i ++ < 64;) {\n        float fi = float(i);\n        vec3 dice = hash3f(float(i) + vec3(8, 4, 2));\n\n        float note = 48.0 + trans + float(CHORD[i % N_CHORD]);\n        float freq = p2f(note) * exp2(0.016 * tan(2.0 * dice.y - 1.0));\n        float phase = lofi(t * freq, 1.0 / 16.0);\n\n        vec3 c = vec3(0.0);\n        vec3 d = vec3(2.0, -3.0, -8.0);\n        float k = 0.1 + 0.4 * smoothstep(0.0, i_TENKAI_HELLO_RAVE, beats);\n        vec2 wave = cyclic(fract(phase) * d, k, 2.0).xy;\n\n        sum += vec2(wave) * rotate2D(fi);\n      }\n\n      dest += 0.05 * mix(0.1, 1.0, sidechain) * env * sum;\n    }\n\n    if (i_TENKAI_FULLHOUSE <= beats) { // arp\n      int iarp = int(16.0 * t / B2T);\n      float note = 48.0 + trans + float(CHORD[iarp % N_CHORD]) + 12.0 * float((iarp % 3) / 2);\n      float freq = p2f(note);\n      float phase = TAU * lofi(t * freq, 1.0 / 16.0);\n\n      vec2 wave = cyclic(vec3(cis(phase), iarp), 0.5, 2.0).xy * rotate2D(time.w);\n\n      dest += 0.2 * sidechain * env * wave;\n    }\n  }\n\n  return clamp(1.3 * tanh(dest), -1.0, 1.0) * smoothstep(i_TENKAI_FADEOUT1, i_TENKAI_FADEOUT0, beats);\n}\n","name":"Sound","description":"","type":"sound"}]}