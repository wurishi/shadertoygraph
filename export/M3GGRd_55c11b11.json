{"ver":"0.1","info":{"id":"M3GGRd","date":"1718060504","viewed":41,"name":"0rb","username":"OscarSaharoy","description":"Trying to learn how light works :) please let me know how to improve it","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["refraction","glass","orb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // ===== setup =====\n\n    vec3 viewPos = normalize( vec3(sin(iTime*.3), cos(iTime*.3), cos(iTime*.4) * 0.2) );\n    float fov = pi * .4;\n    vec3 viewDir = getViewDir( fragCoord, viewPos, iResolution, fov );\n    \n    float pxAngle = fov / iResolution.x;\n    vec3 sphereCentre = vec3(0);\n    float sphereRadius = 0.2;\n    float n = 1.5;\n    \n    // ===== calculate light terms =====\n    \n    // 0 environment\n  \n    vec4 envLight = texture(iChannel0, mat3(1,0,0,0,0,1,0,1,0) * viewDir);\n      \n    vec4 sphereIntersect = intersectSphere( viewPos, viewDir, pxAngle, sphereCentre, sphereRadius, false );\n    vec3 normal = normalize( sphereIntersect.xyz - sphereCentre );\n    \n    // 1 reflection\n    \n    float R0 = pow( ( 1. - n ) / ( 1. + n ), 2. );\n    float schlick = R0 + ( 1. - R0 ) * pow( 1. - dot( -viewDir, normal ), 5. );\n    \n    vec3 reflDir = reflect( viewDir, normal );\n    vec4 reflLight = texture(iChannel0, mat3(1,0,0,0,0,1,0,1,0) * reflDir); // 1\n    \n    vec3 refrDir = refract( viewDir, normal, 1. / n );\n    vec4 innerIntersect = intersectSphere( sphereIntersect.xyz, refrDir, 1e-9, sphereCentre, sphereRadius, true );\n    vec3 innerNormal = -normalize( innerIntersect.xyz );\n    \n    // 2 refraction then refraction\n    \n    float R02 = pow( ( n - 1. ) / ( n + 1. ), 2. );\n    float schlick2 = R02 + ( 1. - R02 ) * pow( 1. - dot( -refrDir, normal ), 5. );\n    \n    vec3 refr2Dir = refract( refrDir, innerNormal, n );\n    vec4 refr2Light = texture(iChannel0, mat3(1,0,0,0,0,1,0,1,0) * refr2Dir) * vec4(.4, .8, .5, 1.); // 2\n    \n    vec3 refl2Dir = reflect( refrDir, innerNormal );\n    vec4 innerIntersect2 = intersectSphere( innerIntersect.xyz, refl2Dir, 1e-9, sphereCentre, sphereRadius, true );\n    vec3 innerNormal2 = -normalize( innerIntersect2.xyz );\n    \n    // 3 refraction then reflection then refraction\n    \n    vec3 refr3Dir = refract( refl2Dir, innerNormal2, n );\n    vec4 refr3Light = texture(iChannel0, mat3(1,0,0,0,0,1,0,1,0) * refr3Dir) * vec4(.3, .7, .4, 1.); // 3\n    \n    // ===== composite & tonemap =====\n    \n    vec4 sphereLight = mix( mix( refr2Light, refr3Light, schlick2 ), reflLight, schlick );\n    fragColor = mix( envLight, sphereLight, sphereIntersect.w );\n    fragColor.xyz = pow( fragColor.xyz, vec3(2) ) * 1.4;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 getViewDir(\n    vec2 fragCoord, vec3 viewPos, vec3 iResolution,\n    float fov\n) {\n\n    vec3 toward = normalize( -viewPos );\n    vec3 up = vec3( 0, 0, 1 );\n    vec3 right = normalize( cross( toward, up ) );\n    vec3 over = cross( right, toward );\n\n    vec2 uv = (fragCoord - iResolution.xy/2.)\n        / iResolution.x;\n        \n    float l = .5 / tan( fov / 2. );\n\n    return normalize(\n        l * toward\n        + uv.x * right\n        + uv.y * over\n    );\n}\n\nvec4 intersectSphere(\n    vec3 rayOrigin, vec3 rayDir, float pxAngle,\n    vec3 sphereCentre, float sphereRadius, bool inner\n) {\n\n    vec3 ro = rayOrigin;\n    vec3 rd = rayDir;\n    vec3 c  = sphereCentre;\n    float R = sphereRadius;\n\n    vec4 result = vec4(0.0);\n\n    vec3 ro2c = c - ro;\n    float distToClosest = dot(rd, ro2c);\n    vec3 closestPoint = ro + rd * distToClosest;\n    float centreToClosest = length(\n        closestPoint - sphereCentre\n    );\n    \n    // ============================ antialias ===================================\n    \n    float pxDist = pxAngle * length(ro - c);\n    result.w = clamp( -(centreToClosest - R) / 1.414 / pxDist, 0., 1. );\n    \n    // ==========================================================================\n\n    if( distToClosest > 0. )\n        result.xyz = closestPoint;\n\n    if( centreToClosest > R )\n        return result;\n\n    float closestToIntersect = sqrt(\n        R*R - centreToClosest*centreToClosest\n    );\n    float distToSphere = !inner ? distToClosest - closestToIntersect : distToClosest + closestToIntersect;\n    float distThroughSphere =\n        closestToIntersect * 2. + min(0., distToSphere);\n\n    if( distThroughSphere < 0. )\n        return result;\n\n    vec3 intersect =\n        rayOrigin + max(0., distToSphere) * rayDir;\n\n    result.xyz = intersect;\n    \n\n    return result;\n}\n","name":"Common","description":"","type":"common"}]}