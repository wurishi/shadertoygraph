{"ver":"0.1","info":{"id":"3tXBWH","date":"1596704680","viewed":162,"name":"metal microsurface pbr","username":"uTaras","description":"Implement microsurface to brdf.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["brdf","pbr","microfacets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = float(3.14159);\nconst float GOLDEN_R = float(1.61803);\nconst float MICRO_FACE_SIZE = float(100.0);\nconst int SPECULAR_SAMPLES_COUNT = 256;\nconst int IRRADIANCE_SAMPLE_COUNT = 64;\nconst int MAX_MIP_COUNT = 16;\n    \nstruct AppState\n{\n    float\tmenuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot  \t= data.xy;  \n   \n    s.objRot    \t= data.zw;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\nfloat Smooth(float x)\n{\n\treturn smoothstep(0., 1., saturate(x));   \n}\n\nfloat Circle(vec2 p, float r)\n{\n    return (length(p / r) - 1.) * r;\n}\n\nvoid Rotate(inout vec2 p, float a) \n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat Capsule(vec2 p, float r, float c) \n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat RoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n} \n\nfloat Sphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat UnionRound(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Displace(float scale, float ampl, vec3 p)\n{\n    p *= ampl;\n\treturn scale * sin(p.x) * sin(p.y) * sin(p.z);\n}\n\nfloat Scene(vec3 p, mat3 localToWorld)\n{  \n    p = p * localToWorld;\n    \n    float ret = Sphere(p, 1.2);\n    //ret = RoundBox(p, vec3(1.0, 1.0, 0.3), 0.1);\n    ret += Displace(0.05, 7.0, p);\n    \n\treturn ret;\n}\n\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for (int i = 0; i < 50; ++i)\n    {\n        if (h < 0.001 || t > maxd) \n        {\n            break;\n        }\n        \n\t    h = Scene(ro + rd * t, localToWorld);\n        t += h;\n    }\n\n    if (t > maxd)\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    Scene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\n\t    Scene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\n\t    Scene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\n\treturn normalize(nor);\n}\n\n\nfloat L(float x, float r)\n{\n\tr = saturate(r);\n\tr = 1.0 - (1. - r) * (1. - r);\n\n\tfloat a = mix( 25.3245,  21.5473, r);\n\tfloat b = mix( 3.32435,  3.82987, r);\n\tfloat c = mix( 0.16801,  0.19823, r);\n\tfloat d = mix(-1.27393, -1.97760, r);\n\tfloat e = mix(-4.85967, -4.32054, r);\n\n\treturn a / (1. + b * pow(x, c)) + d * x + e;\n}\n//------------Place your functions here---------------------------\n\nfloat random (vec2 st) \n{\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) \n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = smoothstep(0.,1.,f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p )\n{\n\tfloat k = 1.0+63.0*pow(1.0,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g );\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\n\nfloat generateMicrosurf(vec3 p, float s)\n{\n    vec2 uv = vec2(atan(p.x, p.z), acos(p.y));\n\n    float noise = noise(uv * s);\n    float voronoi = voronoise(uv * s / 2.0);\n    return saturate(noise * voronoi);\n}\n\nvec2 fibonacci2D(int i, int samplesCount)\n{\n    float random = fract(float(i)+1.0)*GOLDEN_R;\n    return vec2(float(i)+0.5/float(samplesCount), random);\n}\n\n//lighting\n\nvec3 frensel(float vdoth, vec3 specColor)\n{\n    float fc = pow(1.0 - vdoth, 5.0);\n    return (1.0 - fc) * specColor + fc;\n}\n\nfloat normalDistrib(float ndoth, float rough)\n{\n    float a = rough * rough;\n    float a2 = a * a;\n    float ndoth2 = ndoth * ndoth;\n    \n    float num = a2;\n    float denom = (ndoth2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    \n    return num / denom;\n}\n\nfloat geomAnalytic(float ndotv, float rough)\n{\n    float r = rough + 1.0;\n    float k = (r * r) / 8.0;\n    \n    float num = ndotv;\n    float denom = ndotv * (1.0 - k) + k;\n    \n    return num/denom;\n}\n\nfloat geomSmithAnalytic(float ndotv, float ndotl, float rough)\n{\n    float ggx1 = geomAnalytic(ndotv, rough);\n    float ggx2 = geomAnalytic(ndotl, rough);\n    return ggx1 * ggx2;\n}\n\nfloat geomIBL(float ndotv, float rough)\n{\n    float a = rough;\n    float k = (a * a) / 2.0;\n    \n    return ndotv / (ndotv * (1.0 - k) + k);\n}\n\nfloat geomSmithIBL(float ndotv, float ndotl, float rough)\n{\n    float ggx1 = geomIBL(ndotv, rough);\n    float ggx2 = geomIBL(ndotl, rough);\n    return ggx1 * ggx2;\n}\n\nvec3 importanceSample(vec2 Xi, vec3 normal, float rough)\n{\n    float a = rough * rough;\n    \n    float phi = 2.0 * PI * Xi.x;\n    float cos_theta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n    \n    vec3 h;\n    h.x = cos(phi)*sin_theta;\n    h.y = sin(phi)*sin_theta;\n    h.z = cos_theta;\n    \n    vec3 up = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tang = normalize(cross(up, normal));\n    vec3 bitang = cross(normal, tang);\n    \n    vec3 sampleVec = tang * h.x + bitang * h.y + normal * h.z;\n    return normalize(sampleVec);\n}\n\nfloat computeMIP(vec3 Ln, float p, int samplesCount)\n{\n    return max(0.0, (float(MAX_MIP_COUNT) - 1.5) - log2(float(samplesCount) * p *\n                                                sqrt(1.0 - Ln.y * Ln.y)));\n}\n\nvec3 cookTorrance(float vdh, float ndh, float ndl,\n                           float ndv, vec3 ks, float r)\n{\n    return max(frensel(vdh, ks) * geomSmithIBL(ndl, ndv, r) * vdh * ndl / (ndh), 0.001);\n}\n\nvec3 computeSpecAnalytic(vec3 specColor, float ndh, float ndl, float ndv, float rough, float rand)\n{\n    float r2 = 1.0 - rough*rough;\n    rand = rand * r2;\n    float d = normalDistrib(ndh, rough);\n    float g = geomSmithAnalytic(ndl, ndv, rough);\n    return max(specColor * d * g * ndl * rand / PI, 0.001);\n}\n\nvec3 computeSpecIBL(vec3 specColor, vec3 normal, vec3 viewDir, float rough, float rand)\n{\n    vec3 result = vec3(0.0);\n    \n    float roughInv = 1.0 - rough;\n    float distort = rand * 0.09 * roughInv;\n    distort *= 2.0 - 1.0;\n    rand += 1.5;\n    \n    for(int i=0; i<SPECULAR_SAMPLES_COUNT; i++)\n    {\n        vec2 xi = fibonacci2D(i, SPECULAR_SAMPLES_COUNT);\n        vec3 h = importanceSample(xi, normal, rough);\n        vec3 l = -reflect(viewDir, h);\n        \n        float ndotl = saturate(dot(normal, l));\n        float ndotv = saturate(dot(normal, viewDir));\n        float ndoth = saturate(dot(normal, h));\n        float hdotv = saturate(dot(h,viewDir));\n        \n        if(ndotl > 0.001)\n        {\n            float d = normalDistrib(ndoth, rough);\n            float pdf = (d * ndoth / (4.0 * hdotv * rand));\n            \n            float mipLevel = rough < 0.01 ? 0.0 : computeMIP(l, pdf, SPECULAR_SAMPLES_COUNT);\n            \n            l -= distort;\n            vec3 color = textureLod(iChannel1, l, mipLevel).rgb;\n            vec3 cook = cookTorrance(hdotv, ndoth, ndotl, ndotv, specColor, rough);\n            result += color * cook;\n        }\n    }\n    \n    return result / float(SPECULAR_SAMPLES_COUNT);\n}\n\nvec3 computeIrradianceIBL(vec3 normal, float rand)\n{\n    vec3 irradiance = vec3(0.0);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), normal);\n    vec3 up = cross(normal, right);\n    \n\tfloat delta = PI/float(IRRADIANCE_SAMPLE_COUNT);    \n    \n    float counter = 0.0;\n    rand *= 0.24;\n    rand *= 2.0 - 1.0;\n    \n    for(float p=0.0; p < 2.0*PI; p+=delta)\n    {\n        float sin_phi = sin(p + rand);\n        float cos_phi = cos(p + rand);\n        \n        for(float t = 0.0; t < 0.5*PI; t+=delta)\n        {\n            float sin_theta = sin(t + rand);\n            float cos_theta = cos(t + rand);\n            \n            vec3 tspace = vec3(sin_theta * cos_phi, sin_theta * sin_phi, cos_theta);\n            vec3 wspace = tspace.x * right + tspace.y * up + tspace.z * normal;\n            \n            irradiance += textureLod(iChannel1, wspace, 2.0).rgb * \n                cos_theta * sin_theta;\n            counter += 1.0;\n        }\n    }\n    return PI * irradiance * (1.0 / counter);\n}\n\n//---------------------end----------------------------------------\n\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s, vec2 fragCoord)\n{\n    vec3 lightPos \t   = vec3(-0.3, 0.5, 1.);\n    vec3 lightColor    = vec3(1.0);\n    vec3 lightDir      = normalize(vec3(-0.3, 0.5, 1.));\n\tvec3 baseColor     = 0.25 * pow(vec3(1.5, 1.5, 1.5), vec3(2.2));\n\n\n    float roughness    = saturate(s.roughness);\n    \n    p -= vec2(0., 10.);\n    p *= .011;\n    \n    float yaw = 2.7 - s.objRot.x;\n    mat3 rotZ = mat3(\n        vec3(cos(yaw), 0.0, -sin(yaw)),\n\t\tvec3(0.0, 1.0, 0.0),        \n        vec3(sin(yaw), 0.0, cos(yaw))\n       );\n    \n    float phi = -0.1 + s.objRot.y;\n    mat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(phi), sin(phi)),\n        vec3(0.0, -sin(phi), cos(phi))\n       );\n    \n    mat3 localToWorld = rotY * rotZ;  \n    \n    lightDir = localToWorld * lightDir;\n    \n\tvec3 rayOrigin \t= vec3(0.0, .3, -3.5);\n    vec3 rayDir \t= normalize(vec3(p.x, p.y, 2.0));    \n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\n    if (t > 0.0)\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal(pos, localToWorld);\n        vec3 viewDir = -rayDir;\n        vec3 refl = reflect(rayDir, normal);\n        \n        vec3 localNormal = normal*localToWorld;\n        vec3 localViewDir = -rayDir*localToWorld;\n\n        vec3 halfVec = normalize(viewDir + lightDir);\n        float vdoth = saturate(dot(viewDir, halfVec));\n        float ndoth\t= saturate(dot(normal, halfVec));\n        float ndotv = saturate(dot(normal, viewDir));\n        float ndotl = saturate(dot(normal, lightDir));\n        \n        float random = generateMicrosurf(pos*localToWorld*.8, MICRO_FACE_SIZE);\n\n        vec3 irradiance = computeIrradianceIBL(localNormal,random);\n\t\tvec3 diffuse = baseColor * irradiance * (ndotl/PI);\n        \n        vec3 specularIBL = computeSpecIBL(lightColor, localNormal, localViewDir, roughness, random);\n        vec3 specularDir = computeSpecAnalytic(lightColor, ndoth, ndotl, ndotv, roughness, random);\n        vec3 specular = specularIBL + specularDir;\n        \n        color = diffuse+specular;\n        \n        color = pow(color, vec3(1. / 2.2));\n    }\n    else\n    {\n        // shadow\n        float planeT = -(rayOrigin.y + 1.2) / rayDir.y;\n        if (planeT > 0.0)\n        {\n            vec3 p = rayOrigin + planeT * rayDir;\n            \n            float radius = .7;\n            color *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\n        }\t\t\n    }\n}\n\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(-160, 62);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? (t.x < 4. ? 1768452929u : (t.x < 8. ? 1768777835u : (t.x < 12. ? 5653614u : 0u))) : v;\n\tv = t.y == 1. ? (t.x < 4. ? 1918986307u : (t.x < 8. ? 1147496812u : (t.x < 12. ? 1752383839u : (t.x < 16. ? 1835559785u : 5664361u)))) : v;\n\tv = t.y == 0. ? (t.x < 4. ? 1918986307u : (t.x < 8. ? 1147496812u : (t.x < 12. ? 86u : 0u))) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n    if (t.y == 2. - s.menuId)\n    {\n        textColor = vec3(0.74, 0.5, 0.12);\n\t}\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid SliderText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(67, 76);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 14963u)) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    } \n}\n\n\nvoid DrawSlider(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(110, 94.5);\n    \n    p.y += 15.;\n    float c1 = Capsule(p.yx - vec2(0., 20.), 1., 20.);\n    c1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\n\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;    \n    p *= 100.;\n    \n    AppState s;\n    LoadState(s);  \n\n    vec3 color = vec3(0.19,0.2,0.2);\n    \n    DrawScene(color, p, s, fragCoord);\n    \n    SliderText(color, p, s);\n\n    DrawSlider(color, p, s);\n\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// control loop\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ    = 2.;\n\nstruct AppState\n{\n    float   menuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot   = data.xy;\n    s.objRot        = data.zw;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord)\n{\n    if (iFrame <= 0)\n    {\n        s.menuId      = 0.0;\n        s.roughness   = 0.5;\n        s.focus       = 0.0;\n        s.focusObjRot = vec2(0.0);\n        s.objRot      = vec2(0.0);\n    }\n    \n    vec4 ret = vec4(0.);\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.roughness, s.focus, 0.0), ret, fragCoord);\n    StoreValue(vec2(1., 0.), vec4(s.focusObjRot, s.objRot), ret, fragCoord);\n    return ret;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.) \n    {\n        discard;    \n    }\n\n    AppState s;\n    LoadState(s);\n    \n    vec4 q = iMouse / iResolution.xyxy;\n    vec4 m = -1. + 2. * q;\n    m.xz *= iResolution.x / iResolution.y;    \n    m *= 100.;    \n\n    vec4 sliderM = m - vec2(110, 94.5).xyxy;\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\n    {\n        s.focus = FOCUS_SLIDER;\n    } \n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\n    {\n        if (s.focus != FOCUS_OBJ)\n        {\n            s.focusObjRot = s.objRot; \n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n        s.focus = 0.;\n        vec2 mp = (m.xy - vec2(-160, -1));\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\n        if (menuId >= 0. && menuId <= 2.)\n        {\n            s.menuId = menuId;\n        }\n    }\n\n    if (s.focus == FOCUS_SLIDER)\n    {\n        s.roughness = saturate(sliderM.x / 40.);    \n    } \n    if (s.focus == FOCUS_OBJ)\n    {\n        s.objRot = s.focusObjRot + .04 * (m.xy - m.zw);\n    }\n    \n    fragColor = SaveState(s, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}