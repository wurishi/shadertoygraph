{"ver":"0.1","info":{"id":"XcSSWG","date":"1706729142","viewed":95,"name":"Box Muller + Vogel Spiral","username":"chronos","description":"See description!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["normal","box","angle","gaussian","distribution","vogel","golden","ratio","muller"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    /////////////////////////////////////////////////\n    Box Muller + Vogel Golden Spiral by chronos\n    /////////////////////////////////////////////////\n    \n    On the left: Target (standard) normal distribution\n    On the right: Unit area discs scattered using Box muller and vogel spiral pattern, normalized by disc count.\n    \n    See also:\n    \n    \"Voronoi Vogel Golden Spiral\" by chronos - https://www.shadertoy.com/view/lf2SRK\n    \"Gaussian Vogel Golden Spiral\" by chronos - https://www.shadertoy.com/view/XfSXzK\n    \"Vogel's Method\" by chronos - https://www.shadertoy.com/view/4fBXRG\n    \n    \"Bokeh disc\" by Dave_Hoskins - https://www.shadertoy.com/view/4d2Xzw\n    \n*/\n\nconst float PI = 3.14159265;\n\nconst float TWO_PI = 6.283185307; // aka Tau\nconst float PHI = (1. + sqrt(5.))/2.; // Golden ratio\n\nconst float golden_angle = TWO_PI * (1. - 1./PHI);\n\nfloat normal_dist(vec2 x, vec2 mean, float variance)\n{\n    return exp(-.5 * dot(x-mean, x-mean)/variance) / sqrt(pow(variance * 2. * PI, 2.));\n}\n\nfloat normal_dist(vec2 x, vec2 mean, mat2 covariance)\n{\n    return exp(-.5 * dot(x-mean,inverse(covariance)*(x-mean))) / sqrt(determinant(covariance) * pow(2. * PI, 2.));\n}\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = PI;\n\n    vec2 uv = zoom*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    if(length(iMouse.xy) < 10.)\n        mouse = vec2(smoothstep(0.25, 0.75,sin(iTime*1.))-1., cos(iTime));\n    vec3 color = vec3(0);\n\n    vec2 mean = vec2(0, 0);\n    \n    float disc_radius = sqrt(1. / PI); // This gives: area = PI * r^2 = PI / sqrt(PI)^2 = PI / PI = 1.\n    \n    float num_samples = mix(3., 1000.,  smoothstep(-1., 1., mouse.y));\n    float rcp_num_samples = 1./num_samples;\n        \n    float ps = zoom * 2. / iResolution.y;\n    \n    for(float i = .5; i < num_samples; i++) // Samples half-integers between 0 and num_samples\n    {\n        float t = i * rcp_num_samples;\n        float r = sqrt( -2. * log(t) );\n        float th = golden_angle * i;\n        vec2 pos = r * vec2(cos(th), sin(th));\n        float d = length(pos - uv) - disc_radius;\n        float alpha = smoothstep(ps, -ps, d);\n        color += alpha;\n    }\n    color /= num_samples;\n    \n    // Draw target distribution:\n    float g = normal_dist(uv, mean*0., 1.);\n    \n    if(zoom * mouse.x > uv.x)\n        color = vec3(g);\n        \n         \n    // Draw a vertical black seperator line\n    color = mix(color, vec3(1), smoothstep(2. * ps, ps, abs(uv.x - zoom * mouse.x)));    \n        \n        \n    color = sRGBencode(color);\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}