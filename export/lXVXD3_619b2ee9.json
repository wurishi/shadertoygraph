{"ver":"0.1","info":{"id":"lXVXD3","date":"1720594448","viewed":95,"name":"random lighting silk(hw7)","username":"zemi","description":"a little trial","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fractal","random","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//inspired by iq\n\n\nuniform float rotationSpeed;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float r = texelFetch( iChannel0, ivec2(fragCoord), 0 ).y;\n    \n    \n    float lod = pow(r,9.0)*5.0;\n    \n   \n    float angle = iTime * rotationSpeed;\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    vec2 rotatedUV;\n    rotatedUV.x = uv.x * cos(angle) - uv.y * sin(angle);\n    rotatedUV.y = uv.x * sin(angle) + uv.y * cos(angle);\n    \n    rotatedUV = rotatedUV * iResolution.y + 0.5 * iResolution.xy;\n    \n    \n    vec3 col = textureLod( iChannel0, rotatedUV / iResolution.xy, lod ).zyx;\n    \n    \n    col *= 20.0/(1.0 + 1.0 * col);\n    \n    \n    fragColor = vec4(col, 4.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nint   seed = 7;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\nint   hash( int n ) { n=(n>>12)^n; return n*(n*n*15731+114514)+1919810; }\n\n\nmat3x2 fixDet( in mat3x2 m, out float w )\n{\n    mat2x2 r = mat2x2( m[0][0], m[0][1], m[1][0], m[1][1] );\n    w = abs(determinant(r));\n    if( w>0.5 )\n    {\n        float s = 0.4/w;\n        w *= s;\n        m[1][1] = r[0][0]*s;\n        m[1][0] = r[0][1]*s;\n        m[0][1] = r[1][0]*s;\n        m[0][0] = r[1][1]*s;\n    }\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))) );\n\n    \n\tfloat t = 0.2*iTime;\n\n\tmat3x2 am = mat3x2( sin(t*1.71+0.18), sin(t*1.11+5.31), \n                        sin(t*1.31+3.18), sin(t*1.44+4.21),\n                        sin(-t*2.13+0.94), sin(-t*1.19+0.29) );\n                      \n\tmat3x2 bm = mat3x2( cos(-t*2.57+1.66), cos(t*1.08+0.74), \n                        cos(t*1.31+4.51), cos(t*1.23+1.29),\n                        cos(t*1.09+5.25), cos(t*1.27+1.77) );\n                        \n\tmat3x2 cm = mat3x2( cos(t*1.75+0.33), cos(t*1.74+5.12), \n                        cos(t*2.94+1.92), cos(t*2.58+2.36),\n                        cos(t*2.76+2.39), cos(t*2.35+2.04) );\n                        \n\tmat3x2 dm = mat3x2( cos(t*1.42+4.89), cos(t*1.14+1.94),\n                        cos(t*2.73+6.34), cos(-t*1.21+4.84),\n                        cos(-t*1.42+4.71), cos(t*2.81+3.51) );\n\n    \n    \n    float ad, bd, cd, dd;\n    am = fixDet(am, ad);\n    bm = fixDet(bm, bd);\n    cm = fixDet(cm, cd);\n    dm = fixDet(dm, dd);\n\n    \n    float wa = (ad         ) / (ad+bd+cd+dd);\n    float wb = (ad+bd      ) / (ad+bd+cd+dd);\n    float wc = (ad+bd+cd   ) / (ad+bd+cd+dd);\n    float wd = (ad+bd+cd+dd) / (ad+bd+cd+dd);\n\n    \n    float zoom = 0.5+0.5*sin(iTime*0.1);\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tuv *= 3.0*exp2(-zoom);\n\n\n\tvec3  cola = vec3(0.0);\n\tvec3  colb = vec3(0.0);\n    float colw = 0.0;\n\tfloat cad = 0.0;\n\n    vec2 z = vec2( 0.0 );\n\tconst int num = 256;\n\tfor( int i=0; i<num; i++ ) \n    {\n\t\tfloat p = frand();\n\n        // affine transform\n        cad *= 0.25;\n             if( p < wa ) { z = am*vec3(z,1.0); cad += 0.00; }\n        else if( p < wb ) { z = bm*vec3(z,1.0); cad += 0.25; }\n        else if( p < wc ) { z = cm*vec3(z,1.0); cad += 0.50; }\n        else              { z = dm*vec3(z,1.0); cad += 0.75; }\n\n        // non linear transform\n        float an = length(z)*0.25;\n        vec2 c = vec2( cos(an), sin(an) );\n        z = 2.0*mat2(c.x,c.y,-c.y,c.x)*z/dot(z,z);\n\n        // splat into screen\n        if( i>10 )\n\t\t{\n        vec3  co = 0.5 + 0.5*sin(1.5*cad + vec3(0.5,2.0,2.0)+2.0);\n        co.z += co.y*(1.0*sin(cad*3.0+3.0));\n        co = clamp(co,0.0,1.0);\n    \n        float d2 = dot(uv-z,uv-z)*4.0;\n        cola += co*exp2( -8192.0*d2 );\n        colb += co*exp2(  -128.0*d2 );\n        colw += exp2( -256.0*d2 );\n\t\t}\n\t}\n    cola/=float(num);\n    colb/=float(num);\n    colw/=float(num);\n    \n    // color\n    cola = 256.0*sqrt(cola);\n    colb =   2.0*sqrt(colb);\n    colw = 64.0*sqrt(colw);\n    vec3 col = cola + colb;\n    \n    // auto-gain\n    col *= 3.0/(1.0+col);\n    col = clamp(col,0.0,1.0);\n    colw = clamp(colw,0.0,1.0);\n   \n    vec4 old = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n\n\tfragColor = mix( old, vec4(col,colw), 0.1 );\n}\n","name":"Buffer A","description":"","type":"buffer"}]}