{"ver":"0.1","info":{"id":"WtSXzD","date":"1565165030","viewed":1347,"name":"Test anti alias","username":"edapx","description":"I am trying to understand this antialias technique (on the upper part of the screen) used the first time by eiffie in a shader that unfortunately got lost (https://www.shadertoy.com/view/XsSXDt). It is used also here https://www.shadertoy.com/view/MdBSDt ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","antialias"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// AA technique from:\n// https://www.shadertoy.com/view/MdBSDt\n// https://www.shadertoy.com/view/4llGWM\n\n\nconst int MAX_MARCHING_STEPS = 64;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 100.00;\nconst float PI = 3.14159265359;\n\nfloat clampeddot(vec3 a, vec3 b){\n    return max(0.,dot(a, b));\n}\n\nvec3 lightDirection = vec3(1.0, 1.0, 1.0);\n\nvec2 rotate(vec2 pos, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * pos;\n} \n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n    return mod(p,c)-0.5*c;\n}\n\nfloat map(vec3 pos){\n    pos.xy = rotate(pos.xy, sin(iTime) * PI/2. * 0.03);\n    float offset = 0.7;\n    float sph = sphere(pos, 15.);\n    // just a sphere\n    //return sph;\n\n    // domain repetition, more edges, antialias more visible\n    pos = opRep(pos, vec3(offset, offset, offset));\n\n    // test boxes\n    return sdBox(pos, vec3(0.1, 0.1, 0.1));\n\n    // test spheres\n    //return sphere(pos, .2);\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    float ambient = 0.2;\n    return clamp( clampeddot(normal, lightDirection) * ambient + ambient, 0.0, 1.0 );\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return clamp( pow(clampeddot(h, normal), specularityCoef), 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getColor(vec3 eye, vec3 dir,float dist){\n        vec3 collision = (eye += (dist*0.995) * dir );\n        vec3 normal = computeNormal(collision);\n        float diffLight = diffuse(normal);\n        float specLight = specular(normal, dir);\n\n        return (diffLight + specLight ) * vec3(0.2392, 0.8118, 0.9529);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(3.5, 3.0, 15.5);\n    vec3 ta = vec3( -0.5, -0.9, 0.5 );\n    mat3 camera = setCamera( eye, ta, 0.0 );\n    float fov = 0.2;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n\n    // bg\n    vec3 color = vec3(0.6784, 0.4118, 0.1059);\n\n    float depth = NEAR_CLIP;\n    float dist = EPSILON;\n    \n   // ANTIALIAS VARIABLES\n    float pix = 4.0/iResolution.x; // the size of a pixel\n    float od = dist;\n    float w = 1.8; // what is this variable for? It is a threshold, but why 1.8 and why w?\n    float s = 0.0; // what is this variable for?\n    vec4 stack = vec4(-1.0); // here 4 distance values are stored.\n    bool grab = true;\n    // END ANTIALIAS VARIABLES\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        dist = map(eye + depth * dir);\n        // ??\n        if (w > 1.0 && (od + dist < s)) {\n            s -= w*s;\n            w = 1.0;\n        } else {\n            // ??\n            s = dist * w;\n        \tif (dist <= od) grab = true;\n        \telse if (grab && stack.w < 0. && od < pix*(depth-od)) {\n                // stack.w contains now the new distance\n            \tstack.w = depth-od;\n                // the stack variable get updated and the new distance is pushed in\n                stack = stack.wxyz; \n            \tgrab = false;\n        \t}\n        \tif (dist < EPSILON || depth > FAR_CLIP) break;\n        }\n        od = dist;\n        depth += s; \n    }\n\n    if (dist < EPSILON) color = getColor(eye, dir, depth);\n\n    // AA just on the top part of the screen, to see the difference with non AA\n    if (uv.y > 0.) {\n        for (int i = 0; i < 4; ++i) {\n            // if the stored distance is less than 0, abort the loop.\n            if (stack[i] < 0.0) break;\n            // get the color for the collected distance stack[i]\n            // mix it with the color obtained in the previous loop iteration\n            dist = map(eye + stack[i]*dir);\n            color = mix(getColor(eye, dir, stack[i]), color, clamp(dist/(pix*stack[i]), 0.0, 1.0));\n        }\n    }\n    // separation line\n    if (uv.y < 0. && uv.y> -0.01) color = vec3(0.);\n    //vec3 debug = vec3(s);\n    //vec3 debug = vec3(od);\n    //gl_FragColor = vec4(clamp(debug,0.0,1.0) , 1.0);\n    \n    fragColor = vec4(clamp(color,0.0,1.0) , 1.0);\n}","name":"Image","description":"","type":"image"}]}