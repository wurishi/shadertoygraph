{"ver":"0.1","info":{"id":"tttcDN","date":"1659688756","viewed":107,"name":"Voronoi With Gradients","username":"DragonWolf","description":"Voronoi with some gradients","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float t = iTime;\n    float m = N22(uv * iTime).x;\n    \n    vec3 col = vec3(m);\n    \n    uv *= 10.;\n    \n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    float minDist = 10.;\n    float nextDist = 10.;\n    \n    vec2 cid = vec2(0,0);\n    vec2 p0 = vec2(0,0);\n    \n    vec2 nO = N22(id) + 0.5;\n    vec2 pO = id + nO - 0.5;\n    vec3 cidColor = vec3(0.);\n    \n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id + offset) + 0.5;\n            vec2 p = id + offset + n - 0.5;\n            float d = length(p - uv);\n            float dn = length(p - pO); // 0 for same point.\n            \n            if (d < minDist) {\n                minDist = d;\n                nextDist = dn;\n                p0 = p;\n                cid = id + offset;\n                cidColor = vec3(N22(id + offset + 10.0), N22(id + offset + 11.0).x);\n            }\n        }\n    }\n    \n    // Step until we find the boundary between cells.\n    vec2 currentCid = cid;\n    vec2 pos = uv;\n    vec2 dir = normalize(uv - p0);\n    float stepSize = 0.01;\n    int maxCheck = 150;\n    int i = 0;\n    vec2 otherCid = vec2(0.);\n    vec3 otherCidColor = vec3(0.);\n    while (i++ < maxCheck && !(abs(stepSize) <= 0.0001 && currentCid == cid)) {\n        float minDist2 = 10.;\n        vec3 cidColor2 = vec3(0.);\n        vec2 lastCid = currentCid;\n        pos += (dir * stepSize);\n        for (float y = -1.; y <= 1.; y++) {\n            for (float x = -1.; x <= 1.; x++) {\n                vec2 offset = vec2(x, y);\n                vec2 n = N22(id + offset) + 0.5;\n                vec2 p = id + offset + n - 0.5;\n                float d = length(p - pos);\n\n                if (d < minDist2) {\n                    minDist2 = d;\n                    currentCid = id + offset;\n                    cidColor2 = vec3(N22(id + offset + 10.0), N22(id + offset + 11.0).x);\n                }\n            }\n        }\n        \n        // If changed cell, then reverse direction at half speed.\n        if (currentCid != cid) {\n            pos -= (dir * stepSize);\n            stepSize = (stepSize / 2.);\n        }\n        \n        if (currentCid != cid) {\n            otherCid = currentCid;\n            otherCidColor = cidColor2;\n        }\n    }\n    \n    float maxDist = length(pos - p0);\n    float normalizedDist = 1. - (minDist / maxDist);\n    \n    col = vec3(cidColor * (normalizedDist + 0.4f));\n    \n    if (i >= maxCheck) {\n        col = vec3(1., 0., 0.);\n    }\n    \n    fragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}