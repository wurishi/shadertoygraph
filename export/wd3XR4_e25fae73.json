{"ver":"0.1","info":{"id":"wd3XR4","date":"1571611236","viewed":255,"name":"Bouncy bounce!","username":"msiddeek","description":"Bouncing lights and balls around.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","raycasting","baking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BOUNCES 3\n#define SAMPLES 3.\n#define RM_SIZE 4.\n\n#define MAX_DIST 50.\n#define PREC .01\n#define CR 400.\n#define CP 1200.\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, normalize(n.xyz)) - n.w;\n}\nfloat planeX(vec3 p, float d) {\n    return plane(p, vec4(1., 0., 0., d));\n}\nfloat planeY(vec3 p, float d) {\n    return plane(p, vec4(0., 1., 0., d));\n}\nfloat planeZ(vec3 p, float d) {\n    return plane(p, vec4(0., 0., 1., d));\n}\nfloat cyl(vec3 p, vec3 cd, float r) {\n    return length(cross(p, normalize(cd))) - r;\n}\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 b)  {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n          \nfloat tramp(vec2 p, float s) {\n    vec2 ap = abs(p);\n    float a = clamp(-MAX_DIST, 0., abs(max(ap.x, ap.y) * .5) - s);    \n    return -a * .4;\n}\nfloat pCol(vec3 c) {\n    float f = 0.;\n    f = f * CP + floor(c.r * CR);\n    f = f * CP + floor(c.g * CR);\n    f = f * CP + floor(c.b * CR);\n    return f;\n}\n\nvec3 upCol(float f) {\n    vec3 c;\n    f = (f - fract(f)) / CP;\n    c.b = fract(f);\n    f = (f - fract(f)) / CP;\n    c.g = fract(f);\n    f = (f - fract(f)) / CP;\n    c.r = fract(f);\n    return c * CP / CR;\n}\n\nvec4 map(vec3 p) {\n    float d = MAX_DIST;\n    float c = .0;\n    float nor = 0.;\n    float dif = 0.;\n\n    // walls\n    float w =\n            min(\n                min(planeX(p, -RM_SIZE), -planeX(p, RM_SIZE)),\n                min(-planeZ(p, RM_SIZE), planeZ(p, - RM_SIZE))\n            );\n    if (d > w) {\n        d = w;\n        c = pCol(vec3(1.1, .9, .7));\n        dif = .0;\n        nor = .5;\n    }\n\n    // sky\n    float pl1 = plane(p, vec4(-.0, -1., -.0, -3.5));\n    if (d > pl1) {\n        d = pl1;\n        c = pCol(vec3(1.25, 1.25, 1.25));\n        dif = .00;\n        nor = .00;\n    }\n    \n    // ball\n    float phf = fract(iTime / 8.);\n    float ph = cos(phf * 3.14 * 2. * 8.);\n    float j = 3.;\n\n    vec3 sp = p - vec3(0., 1. + ph, 0.);\n    sp.x += (clamp(abs(8. * phf - 3.) - 1.5, 0.1, 0.9) - .5) * j;\n    sp.z += (clamp(abs(8. * phf - 5.) - 1.5, 0.1, 0.9) - .5) * j;\n    float s = sphere(sp, .5);\n    if (s < d) {\n        d = s;\n        c = pCol(vec3(1.));\n        nor = .00;\n        dif = .999;\n    }\n    \n    // mirror\n    float m = box(p - vec3(0., 1.75, RM_SIZE), vec3(3., 1.65, .01));\n    if (d > m) {\n\t\td = m;\n        float fr = smoothstep(1.5, 1.499999, abs(p.y - 1.75)) * smoothstep(2.9, 2.899999, abs(p.x));\n        c = fr * pCol(vec3(1.)) + (1. - fr) * pCol(vec3(.1, .3, .5));\n        nor = .01;\n        dif = .94 + .05 * fr;\n    }\n    \n    \n    // floor\n    float f = p.y - clamp(-1., -.1, ph) * tramp(sp.xz, .8);\n    if (d > f) {\n        d = f;\n        float bt = (mod(floor(p.x - .5), 2.) * mod(floor(p.z - .5), 2.));\n        c = pCol(vec3(.1 + 1.1 * bt, .2 + .9 * bt, .1));\n        dif = 0.;\n        nor = 0.4;\n    }\n    \n    return vec4(d, c, dif, nor);\n}\n\nvec3 normal(vec3 p) {\n    vec2 t = vec2(1., -1.) * PREC * .001;\n    return normalize(\n    \tt.xyy * map(p + t.xyy).x +\n    \tt.yxy * map(p + t.yxy).x +\n    \tt.yyx * map(p + t.yyx).x +\n    \tt.xxx * map(p + t.xxx).x);\n}\nvec4 march(vec3 ro, vec3 rd, float maxD) {\n    vec4 res;\n    float d = 0.;\n    float newD = PREC;\n    while (newD >= PREC && d < maxD) {\n        res = map(ro + rd * d);\n        newD = res.x;\n        d = min(maxD, d + newD);\n    }\n \treturn vec4(d, res.yzw);\n}\n\n\nfloat R11(float i) {\n    return fract(i * 12312.234 + 89.1);\n}\nfloat R31(vec3 p, float s) {\n    return fract(\n        s * (p.x * p.y * p.z + .567) * 100.654 +\n        p.x * 123.458 +\n        p.y * 789.012 +\n        p.z * 345.678);\n}\nvec3 R33(vec3 p, float s) {\n    return vec3(\n        fract(R31(p, s) * 567.890),\n        fract(R31(p, s) * 123.456),\n        fract(R31(p, s) * 789.012));\n}\n\nvec3 bounce(vec3 h, vec3 n, vec3 r, vec2 m, float s) {\n    vec3 ref = r - 2. * dot(r, n) * n;\n    return m.x * ref + m.y * n + (1. - m.x - m.y) * normalize(R33(h, fract((s + 1.) * iTime)) - .5);\n}\n\n\n\nvec3 ray(vec3 ro, vec3 rd) {\n    vec3 ac = vec3(0);\n    vec3 c[BOUNCES + 1];\n\n    for (float s = 0.; s < SAMPLES; s++) {\n        vec3 h = ro;\n        vec3 n = rd;\n        vec3 r = rd;\n        vec4 m = march(h + n * PREC, r, MAX_DIST);\n        c[0] = upCol(m.y);\n        h = h + m.x * r;\n        n = normal(h);\n        r = normalize(bounce(h, n, r, m.zw, R11(s)));\n\n        int b = 1;\n        while (b <= BOUNCES) {\n            m = march(h + n * PREC, r, MAX_DIST);\n            c[b] = upCol(m.y);\n            if (length(c[b]) <= 0.2) {\n                break;\n            }\n\n            h = h + m.x * r;\n            n = normal(h);\n            r = normalize(bounce(h, n, r, m.zw, R11(s)));\n            b++;\n        }\n\n\t   vec3 rc = vec3(0);\n       while (b >= 0) {\n           rc *= c[b];\n           rc += smoothstep(1., 3., c[b]);\n           b--;\n        }\n        ac += rc;\n    }\n\n\n    return ac / SAMPLES;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    col += ray(ro, rd);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float y = 0.1;\n    float a = - .25 * 3.14; //;\n    if (iMouse.x != 0.) {\n        y = (.5 - iMouse.y / iResolution.y) * 3.14 * .75;\n        a += (.5 - iMouse.x / iResolution.x) * 3.14 * .5;\n    }\n    float cp = 1.;\n    vec3 ro = vec3(-RM_SIZE + .3, 2., -RM_SIZE + .3);\n    float phf = fract(iTime / 8.);\n    float ph = cos(phf * 3.14 * 2. * 8.);\n    ro.y += smoothstep(-.8, -1., ph) * (ph + .8) * .5;\n    vec3 rd = normalize(vec3(uv.x, uv.y, cp));\n\n    rd.yz = mat2(cos(y), sin(y), -sin(y), cos(y)) * rd.yz;\n    rd.xz = mat2(cos(a), sin(a), -sin(a), cos(a)) * rd.xz;\n\n    vec3 col = render(ro, rd);\n    col = pow(col * 4., vec3(0.4545));\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}