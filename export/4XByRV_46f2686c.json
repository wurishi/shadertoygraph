{"ver":"0.1","info":{"id":"4XByRV","date":"1727692542","viewed":101,"name":"procedural terrain world","username":"ruochen","description":"learned from Inigo's tutorial https://www.youtube.com/watch?v=BFld4EBO2RE\nhave performance issue, needs to optimize it.\ncredits\ncloud:https://www.shadertoy.com/view/WslGWl\nterrain:https://www.shadertoy.com/view/4ttSWf","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","terrain3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float mint = 6.0;\nfloat maxt = 100.0;\nconst float pi = 3.1415926;\n\n// =====================================================================================\n// COMMON\nfloat random2D( in vec2 st ) \n{\n    return fract( sin(dot( st.xy, vec2(2.9898,78.233 ) ) ) * 43758.5453123);\n}\n\n// =====================================================================================\n// PERLIN NOISE SPECIFIC\n\nfloat perlinAmplitude = 1.55;\nfloat perlinFrecuency = 1.8;\nfloat perlinScale = 1.;\nint perlinOctaves = 11;\n//float max_terrain = 4.7;\n//int perlinOctaves = 5;\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\nvec3 light_dir = normalize(vec3(-0.5, 0.3, 0.5));\n\nfloat noiseInterpolation(in vec2 i_coord)\n{\n\tvec2 grid = i_coord;\n    \n    vec2 randomInput = floor( grid );\n    vec2 weights     = fract( grid );\n    \n    float p0 = random2D( randomInput );\n    float p1 = random2D( randomInput + vec2( 1.0, 0.0  ) );\n    float p2 = random2D( randomInput + vec2( 0.0, 1.0 ) );\n    float p3 = random2D( randomInput + vec2( 1.0, 1.0 ) );\n    \n    weights = smoothstep( vec2( 0.0, 0.0 ), vec2( 1.0, 1.0 ), weights ); \n    \n    return p0 +\n           ( p1 - p0 ) * ( weights.x ) +\n           ( p2 - p0 ) * ( weights.y ) * ( 1.0 - weights.x ) +\n           ( p3 - p1 ) * ( weights.y * weights.x );    \n}\n\nfloat fbm_2d(vec2 uv, float sc, float f, float a, int o)\n{\n    float noiseValue = 0.0;\n    float localAmplitude  = a;\n\n    for( int index = 0; index < o; index++ )\n    {\n        noiseValue += noiseInterpolation( uv * sc ) * localAmplitude;\n        \n        localAmplitude  *= 0.55;        \n        \n        uv = f*m2*uv;\n    }    \n\n\treturn noiseValue;\t\n}\n\n//3d noise generator, source: https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n    vec3 du = 30.0 * w * w * (w * (w - 2.0) + 1.0);\n    #else\n    vec3 u = w * w * (3.0 - 2.0 * w);\n    vec3 du = 6.0 * w * (1.0 - w);\n    #endif\n\n    float n = p.x + 317.0 * p.y + 157.0 * p.z;\n\n    float a = hash1(n + 0.0);\n    float b = hash1(n + 1.0);\n    float c = hash1(n + 317.0);\n    float d = hash1(n + 318.0);\n    float e = hash1(n + 157.0);\n    float f = hash1(n + 158.0);\n    float g = hash1(n + 474.0);\n    float h = hash1(n + 475.0);\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = -a + b + c - d + e - f - g + h;\n\n    return vec4(-1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z),\n    2.0 * du * vec3(k1 + k4 * u.y + k6 * u.z + k7 * u.y * u.z,\n    k2 + k5 * u.z + k4 * u.x + k7 * u.z * u.x,\n    k3 + k6 * u.x + k5 * u.y + k7 * u.x * u.y));\n}\n\nvec4 fbm_3d(vec3 uv)\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n\n    for( int i=0; i<9; i++ )\n    {\n        vec4 n = noised(uv);\n        a += b*n.x;          // accumulate values\n        if( i<4 )\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        uv = f*m3*uv;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm_cloud(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m3 * p * 2.02;\n    f += 0.2500 * noise(p); p = m3 * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nfloat rmCloud(vec3 p, vec3 b)\n{\n    vec3 gra = vec3(0.0, sign(p.y), 0.0);\n\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    vec4 n = fbm_3d(p*0.35+vec3(2.0,100.2,1.0)+0.12*vec3(iTime*0.3, 0.1*iTime,3.*iTime));\n    //d += 400.0* * fbm_3d(p*3.+iTime).x;\n    d += 9.*n.x * (.9 + 0.3*gra.y);\n    return d;\n}\n\n\nfloat getTerrainHeight(vec2 uv, int octaves)\n{\n    uv /= 12.0;\n    int terrain_loop_count = 4;\n    float noise_value = 0.0;\n    float s = perlinScale, f=perlinFrecuency, a=perlinAmplitude;\n    int o=octaves;\n    noise_value += pow(fbm_2d(uv, s, f, a, o), 2.0);\n\n    \n    return noise_value;\n}\n\nbool rayMarchingTerrain(vec3 ro, vec3 rd, float max_dist, out float res_t)\n{\n    // float terrain_height = sin(iTime) + 1.;\n    float dt = 0.01;\n    float last_h = 0.0;\n    vec3 last_p = vec3(0);\n    for(float t = mint; t < max_dist; t+=dt)\n    {\n        vec3 p = ro+t*rd;\n        float terrain_height = getTerrainHeight(p.xz, perlinOctaves);\n        if(p.y < terrain_height)\n        {        \n            res_t = t - dt + dt*(last_h - last_p.y) / (p.y - last_p.y-terrain_height+last_h); \n            return true;\n        }        \n        // closer terrain use higher accuracy\n        dt = 0.0075*t;\n        last_h = terrain_height;        \n        last_p = p;\n    }\n\n    return false;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    // use central differences method for normal\n    float eps = 0.02;\n    int normal_octaves = perlinOctaves - 1;\n    return normalize(\n        vec3(getTerrainHeight(vec2(pos.x-eps, pos.z), normal_octaves)-getTerrainHeight(vec2(pos.x+eps, pos.z), normal_octaves),\n        2.0*eps,\n        getTerrainHeight(vec2(pos.x, pos.z-eps), normal_octaves)-getTerrainHeight(vec2(pos.x, pos.z+eps), normal_octaves)\n        ));\n    vec2 step = vec2(2, 0);\n}\n\n// shadow hit can use shorter range\nfloat shadow_max_dist = 10.0;\nfloat calcShadow(vec3 pos)\n{\n    float shadow_hit;\n    if(rayMarchingTerrain(pos, light_dir, shadow_max_dist, shadow_hit))\n    {\n        // in shadow\n        return 0.0;\n    }\n    else\n    {\n        //not in shadow, but maybe near shadow, get a smooth soft shadow effect\n        float res = 1.0;\n        float dt = 0.02;        \n        for(int i = 0; i < 32; ++i)\n        {            \n            vec3 sample_pos = pos+light_dir*dt;\n            float terrain_height = getTerrainHeight(sample_pos.xz, 5);\n            float h_diff = sample_pos.y - terrain_height;\n            res = min(res, 10.*h_diff/dt);\n            // res = min(res, h_diff*1000.);\n            if(res < 1e-3 || sample_pos.y > 1e3) break;            \n            dt += clamp(h_diff, dt*0.1, 100.0 );            \n        }\n        \n        //return clamp(res, 0.0, 1.0);\n        // return 0.0;\n        return smoothstep(0.0, 1.0, res);\n        // not in shadow\n        return 1.0;\n    }\n}\n\n// cal fog density, different between r,g,b so the fog has a blue hue\nvec3 calcFog(float dist)\n{    \n    return exp(-5e-3*dist*vec3(1,2,4));\n}\n\nfloat getCloudDensity(vec2 uv, int octaves)\n{\n    uv /= 12.0;\n    int terrain_loop_count = 4;\n    float noise_value = 0.0;\n    float s = perlinScale, f=perlinFrecuency, a=perlinAmplitude;\n    int o=octaves;\n    noise_value += pow(fbm_2d(uv, s, f, a, o), 2.0);\n\n    \n    return noise_value;\n}\n\nfloat top_sky_plane = 3000.;\nfloat mid_cloud_bottom = 300.0;\nfloat mid_cloud_top = 400.0;\n\nfloat renderHighClouds(vec3 ro, vec3 rd, out float res_t)\n{\n    float t_bottom = (mid_cloud_bottom - ro.y) / rd.y;\n    float t_top = (mid_cloud_top - ro.y) / rd.y;\n\n    if(t_bottom < 0.0) return 0.0;\n    vec3 hit_bottom, hit_top;\n    hit_bottom.y = mid_cloud_bottom;\n    hit_bottom.xz = t_bottom*rd.xz + ro.xz;\n    hit_top.y = mid_cloud_top;\n    hit_top.xz = ((mid_cloud_top-ro.y)/rd.y)*rd.xz + ro.xz;\n\n    int step_count = 32;\n    float sum = 0.0;\n    vec3 step_size = (hit_top-hit_bottom)/float(step_count);\n    for(int i = 0; i < step_count; ++i)\n    {\n        vec3 pos = hit_bottom + step_size*float(i);\n        float dist = fbm_3d(pos*0.001 + iTime*0.05).x + 0.5;\n        sum+=dist;\n    }\n    sum /= 32.0;\n    sum = smoothstep(-.3, 1.0, sum);\n    return sum;\n}\n\n\nfloat max_cloud_dist = 100.;\nvec4 renderMidClouds(vec3 ro, vec3 rd)\n{    \n    vec4 color = vec4(0);\n    int step_count = 32;\n    vec3 p = ro;\n    vec3 cloud_box_center = vec3(ro.x, 45.0, ro.z);\n    float ds = max_cloud_dist / float(step_count);\n\n    float T = 1.0;  // transmittance\n    float absorption = 100.0;\n\n    for(int i = 0; i < step_count; ++i)\n    {\n        float density = -rmCloud((p - cloud_box_center), vec3(100.0, 35.5, 100.0));\n\n        if(density > 0.0)\n        {\n            //return vec4(1.0);\n            // the sample point is inside of the clouds\n            float tmp = density / float(step_count) / 30.;\n            T *= 1.0 - (tmp*absorption);\n\n            // all light energy get absorbed\n            if(T < 1e-2)\n            {\n                break;\n            }\n\n            // sample the color of this point\n            float opacity = 50.0;\n            float k = opacity * tmp * T;\n            vec4 cloud_color = vec4(1.0);\n            color += cloud_color * k;\n        }\n\n        p+=rd*ds;\n    }\n\n    //vec3 bg = mix(vec3(0.3, 0.1, 0.8), vec3(0.7, 0.7, 1.0), 1.0 - (rd.y + 1.0) * 0.5);\n    //color.rgb += bg;\n    return color;\n}\n\nfloat cloud_view_distance = 50000.0;\n\nvec3 low_sky_blue = vec3(0.5137, 0.7804, 0.9608);\nvec3 high_sky_blue = vec3(0.3216, 0.4706, 0.9725);\n\n\nvec3 getSkyColor(vec3 ro, vec3 rd)\n{\n    \n    // return renderCloud(ro, rd).xyz;\n\n    vec3 hit_sky;\n    hit_sky.y = top_sky_plane;\n        \n    hit_sky.xz = ro.xz + rd.xz * (top_sky_plane - ro.y)/rd.y;    \n    //hit_sky *= -1.;\n    \n    //lower further cloud density, looks better\n    float hit_dist = distance(hit_sky, ro);\n    float cloud_density_percentage = 1.0;\n    if(hit_dist > cloud_view_distance)\n    {\n        cloud_density_percentage *= exp(-(hit_dist - cloud_view_distance)/ cloud_view_distance);\n    }    \n    // only up direction will have cloud\n    if(hit_sky.z < ro.z)\n    {\n        cloud_density_percentage = 0.0;\n    }\n\n\n    float cloud_density = smoothstep(getCloudDensity(hit_sky.xz/150.0, 3), -0.99, 1.9)*cloud_density_percentage * 0.5;\n    float res_t;\n    //cloud_density += smoothstep(0.0, 1.0, renderClouds(ro, rd, res_t) * pow(cloud_density_percentage, 1.0) * 1.2);    \n    // return vec3(cloud_density);\n    // sky color    \n    vec3 sky_color = mix(low_sky_blue, high_sky_blue, clamp(rd.y, 0.0, 1.0));\n    vec3 cloud_color = vec3(1.);\n    return mix(sky_color, cloud_color, cloud_density);\n}\n\nvec3 dirt_color = vec3(0.8549, 0.5255, 0.3098);\nvec3 grass_color = vec3(0.3137, 0.5412, 0.0157);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    uv.x *= iResolution.x/iResolution.y;    \n\n    vec3 ro = vec3(0, 1,-1.0+1.0*(iTime));\n    // uv.y -= 0.5;\n    // camera close to the ground, use a lower octaves noise for smooth movement\n    ro.y = max(ro.y, getTerrainHeight(ro.xz, 3) + 8.0);\n    \n    vec3 rd = normalize(vec3(uv, 2));\n    vec3 color;\n    float res_t = 0.0;\n    // cap the ray march range for performance\n    maxt = min(ro.y * 10., 200.0);\n    \n    if(rd.y < 0.05 && rayMarchingTerrain(ro, rd, maxt, res_t))\n    {\n        vec3 height_pos = ro+res_t*rd;\n\n        // calculate normla\n        vec3 normal = getNormal(height_pos);\n        float grass_ratio = smoothstep(0.9, 0.98, normal.y);\n        \n        float light_intensity = max(0.0, dot(light_dir, normal));\n\n        // calculate soft shadow\n        float shadow_intensity = calcShadow(height_pos+vec3(0.0, .1, 0.0));                        \n        light_intensity *= shadow_intensity;\n        vec3 ground_color = mix(dirt_color, grass_color, grass_ratio);\n        color = ground_color * light_intensity;\n\n        // raymarch trees(todo, not very clear about this part now)\n        //if(grass_ratio > 0.5)        \n        //    color = rayMarchTree(ro, rd, height_pos);\n\n        vec3 fog_amount = calcFog(res_t);\n        color = mix(vec3(0.7),color, fog_amount);\n\n        // add some diffuse light from sky\n        color += (normal.y + 1.0)/2.0*low_sky_blue/10.0;\n        // add some bounce diffuse light from other mountain\n        color += (max(0.0, dot(-light_dir, normal))*ground_color/10.0);\n        // // color = normal.xzy*0.5 + 0.5;\n    }\n    else\n    {        \n        color = getSkyColor(ro, rd);        \n    }\n    \n    vec4 mid_cloud_data = renderMidClouds(ro, rd);\n\n    float cloud_intensity = smoothstep(0.0, .4, mid_cloud_data.x);\n    color = mix(color, vec3(1.0), cloud_intensity);\n    // // color = vec3(cloud_intensity);\n    fragColor = vec4(color, 1);\n    // fragColor = smoothstep(0.0, 0.4, renderMidClouds(ro, rd));\n}","name":"Image","description":"","type":"image"}]}