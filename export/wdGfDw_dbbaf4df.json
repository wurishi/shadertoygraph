{"ver":"0.1","info":{"id":"wdGfDw","date":"1610907309","viewed":69,"name":"30% shadertoy ","username":"lewismills2k","description":"COMPUTER GAMES TECHNOLOGY\nManchester metropolitan university, Advanced computer graphics assignment, 3rd year.\n30% shadertoy.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["assignment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//RIPPLE----------------------------------------------------------------------------------------------------------------\nvec3 RippleNorm( in float x, in float z, in float time )\n{\n    float dx = -2.0*cos(3.0*x + 2.0*z + 3.0*time) + 3.0*cos(-1.0*x + 3.0*z + 4.0*time) - 2.0*cos(2.0*x -2.0*z + 5.0*time)\n        -0.5*cos(-2.0*x -0.5*z + 2.0*time); \n        \n    float dz = 3.0*cos(3.0*x + 2.0*z + 3.0*time) - cos(-1.0*x + 3.0*z + 4.0*time) + 2.0*cos(2.0*x -2.0*z + 5.0*time)\n        -2.0*cos(-2.0*x -0.5*z + 2.0*time);\n    return normalize(vec3(0.01*dx,1,0.01*dz));\n}\nfloat Ripple( in float x, in float z, in float time )\n{\n    return sin(3.0*x + 2.0*z + 3.0*time) + sin(-1.0*x + 3.0*z + 4.0*time) + sin(2.0*x -2.0*z + 5.0*time)\n        +sin(-2.0*x -0.5*z + 2.0*time);  \n}\n\n//RAYCASTING------------------------------------------------------------------------------------------------------------\nbool RayCastPlane( in vec3 rayStart, in vec3 rayDir, in vec3 planePos, in vec3 planeNormal, out vec3 hitPos )\n{\n    float dp = dot(rayDir, planeNormal);\n    if ( dp >= 0.0 )\n        return false;\n    float hitU = dot(planePos-rayStart,planeNormal)/dp;\n    if ( hitU < 0.0 )\n        return false;\n    hitPos = rayStart + rayDir*hitU;\n    return true;\n}\n\nbool SphereIntersect( in vec3 pos, in vec3 dir, in vec3 centre, in float radius,\nin mat3 rotMat, out vec3 hitPos, out vec3 hitNorm, out vec3 hitPosLocal )\n{\n\t// coefficients of the quadratic equation, a=1\n\tfloat b = dot(pos-centre,dir)*2.0;\n\tfloat c = dot(pos-centre,pos-centre)-radius*radius;\n\tif ( b*b < 4.0*c )\n\t\treturn false;\n\tfloat sol1, sol2, sq;\n\tsq = sqrt(b*b-4.0*c);\n\tsol1 = 0.5*(-b - sq);\n\tsol2 = 0.5*(-b + sq);\n\tif ( sol2 < sol1 )\n\t\tsol1 = sol2;\n\thitPos = pos + dir * sol1;\n\thitNorm = normalize(hitPos-centre);\n\thitPosLocal = transpose(rotMat)*(hitPos-centre);\n\treturn true;\n}\n\n//----------------------------------------------------------------------------------------------------------------------\n\nvec4 proctexcolorcube(vec3 pos) // COLOR CUBE STANDARD\n{\n    return vec4(pos+0.5, 1.0);\n}\n\nvec4 plasmacolor(vec3 pos, float x, float y) //creates plasma coloring for the cube, by Viktor Korsun (2011)\n{\n    float mov0 = x+y+cos(sin(iTime)*2.0)*100.0+sin(x/100.0)*1000.0;\n    float mov1 = y / 0.9 +  iTime;\n    float mov2 = x / 0.2;\n    float c1 = abs(sin(mov1+iTime)/2.0+mov2/2.0-mov1-mov2+iTime);\n    float c2 = abs(sin(c1+sin(mov0/1000.0+iTime)+sin(y/40.0+iTime)+sin((x+y)/100.0)*3.0));\n    float c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.0)));\n    \n\treturn vec4(pos+c1*c3, c2*c3*0.9);\n}\n\n\n//ROTATION AND COLORING-------------------------------------------------------------------------------------------------\nmat3 rotMatrix( in vec3 about, in float angle )\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0-c;\n    float x = about.x; \n    float y = about.y;\n    float z = about.z;\n    \n    mat3 rotMat;\n    rotMat[0] = vec3( t*x*x+c, t*x*y - z*s, t*x*z + y*s );\n    rotMat[1] = vec3( t*x*y + z*s, t*y*y + c, t*y*z - x*s);\n    rotMat[2] = vec3( t*x*z - y*s, t*y*z + x*s, t*z*z + c);\n    return rotMat;\n}\nvec4 GetSceneColor( in vec3 r, in vec3 n, in float iTime ) //SCENE COLOUR\n{\n    mat3 sphereRot = rotMatrix(normalize(vec3(0,0,0)), iTime); //rotates the sphere\n    vec3 spherePos = vec3(0,2.0,4);\n    float rad = 2.0;    \n    vec3 hitPos, hitNorm, hitPosLocal;\n       \n    bool hit = SphereIntersect(r, n, spherePos, rad, sphereRot, hitPos, hitNorm, hitPosLocal);\n\tvec4 outColor; //OUTPUT TO THE SCREEN\n  \n    if ( hit ) // WHEN RAYCAST HITS CHANGE THE COLOR/TEXTURE OF THE HIT\n    {\n        float light = 0.3 + 0.7*max(hitNorm.y,0.0);\n        \n\t\tvec4 baseColor = plasmacolor(hitPosLocal, hitPosLocal.x, hitPosLocal.y); // ADD THE PLASMA\n        outColor = baseColor*light + 0.3*texture(iChannel0, reflect(n,hitNorm));  //output color = color of cube + reflectivity * texture(texture location, reflection location)\n    }\n\telse\n\t    outColor = texture(iChannel0, n);\n    \n    return outColor;   \n}\n\nconst vec3 camPos = vec3(0,-0.1,-0.5); //pos of camera \t(x,y,z)\n\n//const float camRad = 5.0;\n//const float camSpeed = 0.3;\n\n//MAIN AREA-------------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= vec2(0.5,0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    //uv.x += cos(-iTime) * 0.2; //ROTATES CAMERA about X dir*speed\n    //camPos = vec3(camRad * sin(camSpeed * iTime), 0.0, camRad * cos(camSpeed * iTime));\n    \n    //vec3 r = camPos; //RAY POS\n    //vec3 n = normalize(vec3(uv,0)-camPos); //RAY DIR      \n    \n    mat3 rotation = rotMatrix(vec3(0,1,0), iTime*0.3);\n    vec3 rotateAboutPoint = vec3(0,0,5);  //rotation, subtract point to rotate about, rotate, then add point back\n   \n    vec3 r = rotateAboutPoint + rotation*(camPos-rotateAboutPoint);    \n    vec3 n = rotation*normalize(vec3(uv,0)-camPos);\n    \n\tvec3 hitPos;\n    bool hit = RayCastPlane(r, n, vec3(0,-1.5,0), vec3(0,1,0),hitPos); //location for ripple\n    \n    if ( hit )\n    {\n\t\tvec3 norm = RippleNorm(hitPos.x, hitPos.z, iTime); \n       \tn = reflect(n,norm); //reflect upon the ripple\n        r = hitPos;\n    }\n   \tfragColor = GetSceneColor(r, n, iTime);\n}\n\n\n","name":"Image","description":"","type":"image"}]}