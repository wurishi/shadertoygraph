{"ver":"0.1","info":{"id":"3lBXRh","date":"1564927713","viewed":214,"name":"Error diffusion: 1D Fixed window","username":"104","description":"Click the mouse to change TV channels. Details in comments.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","dithering","floydsteinberg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// CLICK the window to change channels. See below in tex() for details\n// of the src image\n\n// \"ORIG\" is the original image.\n// \"LTR\" is a dumb 1D error diffusion. Not viable because it\n//       performs on AVERAGE (iResolution.x*.5) samples.\n// \"LIM\" is the same as LTR, except it refuses to consider error further\n//   than windowSize pixels away from current.\n//   demonstrates how leaving behind error creates wide contour lines.\n// \"kern\" is like LTR except it distributes error in a\n//   kernel similar to 2D error diffusion like Floyd-Steinberg. it's an attempt at breaking\n//   up the wide contour lines of LIM. the kernel\n//   is normalized so it has a natural falloff (pixels further away have progressively less effect)\n\nconst float windowSize = 64.; // window size\n\n// attempts to break up \"kern\" by shifting phase each scanline.\n// it mostly just looks horrible and glitchy.\n//#define PHASE_DANCE\n\n\n////////////////////////////////////////////////////\n\nfloat load(int i) {\n    return texelFetch(iChannel1, ivec2(i,0), 0).x;\n}\nfloat tobw(float a) {\n    return step(.6,a);\n}\n// Generic algorithm to desaturate images used in most game engines\nfloat togray(vec3 color)\n{\n\treturn dot(vec3(0.299, 0.587, 0.114), color);\n}\n\n// generate a nice pattern with low & high freqs.\nfloat tex(vec2 p, vec2 R) {\n    float chan = load(0);\n    if (chan == 0.) {\n        // a 2D gradient. shows banding in its full glory.\n        // shows the fundamental problem with a hard limit (LIM) creating ugly thick bands\n        // and how a kernel tries to break it up\n        // also shows limitation of 1D EC because you get contour lines in 1 dimension only,\n        // despite the gradient being equal in both dimensions.\n        float ret = pow(clamp(p.x,0.,1.) * p.y,.5);\n        //p-=.5;\n        //p=-abs(p-.5)+.1;\n        //float sq = sign(p.x+p.y);\n        //ret = max(sq,ret);\n        return ret;\n    }\n    if (chan == 1.) {\n        // another gradient\n        float ret = pow(clamp(p.x,0.,1.) * p.y * (sin(length(p)*9.)*.5+.5),.5);\n        return ret;\n    }\n    if (chan == 2.) {\n        // hard objects on soft gradient.\n        // emphasizes how bad the rolling window calculation is\n        float ret = clamp(p.x,0.,1.) * p.y * .5;\n        p.x *= 2.;\n        vec2 p1 =-abs(p-.5)+.15;\n        float sq1 = sign(p1.x+p1.y);\n        vec2 p2 =-abs(p-.5)+.1;\n        //float sq1 = sign(p1.x+p1.y);\n        sq1 -= sign(p2.x+p2.y);\n        ret = max(sq1,ret);\n        \n        sq1 = -sign(length(p-vec2(1.4,.5))-.3);\n        float sq2 = sign(length(p-vec2(1.4,.5))-.2);\n        ret = max(sq1+sq2,ret);\n        \n        return clamp(ret,0.,1.);\n    }\n    if (chan == 3.) {\n        // a soft circle. here the kernel makes a big difference in breaking up weird patterns\n        // also shows result of left-to-right error accumulation:\n        // smooth on the left, noisy on the right.\n        p -= .5;\n        return 1.-smoothstep(.0,.2,length(p)-.1);\n    }\n    if (chan == 5.) {\n        // a real video. shows how the fixed window is really just too ugly to be taken seriously.\n        return togray(texture(iChannel2, p).rgb);\n    }\n    \n    // an animation with both high freq & low freq content.\n    float t = iTime*.05;\n    p.x *= R.x / R.y;\n    p*=.5;\n\n    p.x += t;\n    p.y += t*.333;\n    \n    float ret = (sin(p.x * 20.) * .5 + .5) + (sin(p.y * 20.) * .5 + .5);\n    ret /= 2.;\n    \n    float span = .5;\n    vec2 c = mod(p, span) - span*.5;\n    ret = max(ret, 1.-step(.0, length(c)-span*.3));\n\n    span *= .7;\n    c = mod(p - vec2(0,t), span) - span*.5;\n    ret = min(ret, step(.0,length(c)-span*.3));\n    return ret;\n}\n\nvoid gray( out vec4 o, in vec2 fragCoord, vec2 R )\n{\n    o = vec4(tex(fragCoord.xy / R.xy, R));\n}\n\nvoid nodither( out vec4 o, in vec2 fragCoord, vec2 R )\n{\n    o = vec4(tobw(tex(fragCoord.xy / R.xy, R)));\n}\n\n// accumulate error from left edge until fragCoord.x\nvoid leftToRight( out vec4 o, in vec2 fragCoord, vec2 R )\n{\n    float error = 0.;\n    float b;\n    for (float i = 0.; i <= fragCoord.x; ++ i) {\n        float a = tex(vec2(i,fragCoord.y) / R.xy, R);\n        a -= error;\n        b = tobw(a);\n        error = (b-a);\n    }\n    o = vec4(b);\n}\n\n// same thing, but with a hard limit of N samples.\n// the problem?\nvoid leftToRight_lim( out vec4 o, in vec2 fragCoord, vec2 R )\n{\n    float error = 0.;\n    float b;\n    float begin = fragCoord.x - windowSize;//max(0.,fragCoord.x - range);\n    for (float i = begin; i <= fragCoord.x; ++ i) {\n        float a = tex(vec2(i,fragCoord.y) / R.xy, R);\n        a -= error;\n        b = tobw(a);\n        error = (b-a);\n    }\n    o = vec4(b);\n}\n\n// if our density is < 1.0, then it means short circuit error accumulation because there's a natural falloff.\n// m = abs maximum total error amount +/-.25 = .25\n// e = epsilon, the error amount we consider insignificant\n// d = density of the kernel\n// n = number of pixels required to accumulate for significant error correction\n// m * (d ^ n) = e\n// if you know D, then N = log(d,e/m)=N\n// if you know N, then D = (e/m)^(1/n) = d\nvoid leftToRight_kern( out vec4 o, in vec2 fragCoord, vec2 R )\n{\n    int kernelSize = 4;\n    // kernel chosen attempting to break up banding without looking like total noise\n    //vec4 k = vec4(4,7,4,1);\n    vec4 k = vec4(4,5,3,1);\n    //vec4 k = vec4(1,0,0,0); // this is equiv to no kernel at all (if density = 1.)\n    float eps = 0.0001;\n    const float m = 0.25;\n    float density = pow(eps/m,1./windowSize);\n    float sum = (k.x+k.y+k.z+k.w);//length(kernelBase)*length(kernelBase);\n    vec4 kernel = k / (sum / density);\n    \n    vec4 error = vec4(0); // keep track of distributed error values.\n    int errorCursor = 0;\n    int phase = int(fragCoord.y *1.) % kernelSize;\n    #ifndef PHASE_DANCE\n    phase = 0;\n    #endif\n    float b;\n    // because we're generating this image, and we don't want the artifacts on the left edge,\n    // allow negative sample coords\n    float begin = fragCoord.x - windowSize;//max(0.,fragCoord.x - range);\n    for (float i = begin; i <= fragCoord.x; ++ i) { // iterate from left to right\n        float a = tex(vec2(i,fragCoord.y) / R.xy, R);\n        a -= error[errorCursor];// apply error correction based on previously accumulated values\n        error[errorCursor] = 0.;\n        b = tobw(a);\n        float totalError = b-a;\n        errorCursor = (errorCursor + 1) % kernelSize;\n        for (int c = 0; c < kernelSize; ++ c) {\n            int x = (errorCursor + c) % kernelSize;\n        \terror[x] += totalError * kernel[(c + phase) % kernelSize];\n        }\n    }\n    o = vec4(b);\n}\n\n\n\n#define C(c) U.x-=.5; O+= char(U,64+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    float halfLineW = 2.;\n    vec2 R = iResolution.xy * .5;\n    vec2 window = mod(fragCoord, iResolution.xy*.5);\n    vec2 uv = window / iResolution.y;\n    uv.x -= .6;\n    uv.y -= .4;\n    vec2 U = uv*12.;\n    vec4 O = vec4(0);\n    if (fragCoord.x <= iResolution.x * .5 - halfLineW) {\n        if (fragCoord.y <= iResolution.y * .5 - halfLineW) {\n            // BOTTOM LEFT\n    \t\tleftToRight_lim(o, window, R);\n    \t\tC(12);C(9);C(13); // LIM\n        } else if (fragCoord.y <= iResolution.y * .5 + halfLineW) {\n        \to = vec4(1,0,0,0);\n        } else {\n            // TOP LEFT\n\t    \tgray(o, window, R);\n    \t\tC(15);C(18);C(9);C(7); // ORIG\n        }\n    }\n    else if (fragCoord.x <= iResolution.x * .5 + halfLineW) {\n        \to = vec4(1,0,0,0);\n    } else {\n        if (fragCoord.y <= iResolution.y * .5 - halfLineW) {\n            // BOTTOM RIGHT\n\t    \tleftToRight_kern(o, window, R);\n    \t\tC(11);C(5);C(18);C(14);// KERN\n        } else if (fragCoord.y <= iResolution.y * .5 + halfLineW) {\n        \to = vec4(1,0,0,0);\n        } else {\n            // TOP RIGHT\n\t    \tleftToRight(o, window, R);\n    \t\tC(12);C(20);C(18);// LTR\n        }\n    }\n    \n    o = mix(o, vec4(.9,0,0,0), O.x);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// this is just used to keep track of which \"tv channel\" you're watching\n\n// 0 = tv channel\n// 1 = previous mouse state\n\nfloat load(int i) {\n    return texelFetch(iChannel0, ivec2(i,0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 C = ivec2(fragCoord);\n    int i = C.x + (int(iChannelResolution[0].x) * C.y);\n    \n    if (i == 0) {\n        float prevClickState = load(1);\n        if (prevClickState != iMouse.z && iMouse.z <= 0.) {\n            // mouse clicked state has changed; change tv channels.\n        \tfloat prev = load(0);\n            fragColor.x = float((int(prev) + 1) % 6);\n            return;\n        }\n    }\n    \n    if (i == 1) { // save mouse state\n        fragColor.x = iMouse.z;\n        return;\n    }\n    fragColor.x = load(i);\n}\n    \n","name":"Buffer A","description":"","type":"buffer"}]}