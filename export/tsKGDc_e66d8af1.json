{"ver":"0.1","info":{"id":"tsKGDc","date":"1571136291","viewed":220,"name":"2d sidescroller","username":"onak","description":"Simulating a 2d sidescroller level through 1d noise\n\nupdate: added some simple ground structure and parallax clouds.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2dnoise","sidescroller"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pixelsize = 4.0;\nfloat scrollSpeed = 0.3;\nfloat roughness = 0.55;\n\nfloat PI = 3.14159265359;\n\n/**\n * compares x to f and returns a value between 1.0 and 0.0\n * depending on the difference as long as its below threshold\n *\n * always returns 1.0 for differences above the threshold\n */\nfloat plot2d(in float x, in float f, in float threshold) {\n    float deviation = abs(x - f);\n    \n    if (deviation < threshold) {\n        return (deviation / threshold);\n    }\n    \n    return 1.0;\n} \n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat noise_fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        c += perlin_noise(coord * size) * p;\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n\n/**\n * two-dimensional fractal Brownian motion\n */\nfloat fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        // apply noise function for the current octave\n        c += p * sin(coord.x * PI * size);\n        \n        // prepare parameters for next octave\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    \n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n// photoshop blend modes: https://www.shadertoy.com/view/XdS3RW\nvec4 blend_lighten(vec4 s, vec4 d) {\n    return max(s, d);\n}\nvec3 blend_lighten(vec3 s, vec3 d) {\n    return max(s, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    float surfaceThickness = 0.04;\n    vec3 skyDark = vec3(0.17, 0.389, 0.71); // RGB 44, 74, 105\n    vec3 skyBright = vec3(0.714, 0.929, 0.984); // RGB 183, 238, 247\n    vec3 terrainBright = vec3(0.855, 0.640, 0.179); // RGB 219, 164, 46\n    vec3 terrainDark = vec3(0.585, 0.437, 0.117); // RGB 150, 112, 30 #96701e\n    vec3 surfaceDark = vec3(0.246, 0.398, 0.183); // RGB 63, 102, 47\n    vec3 surfaceBright = vec3(0.312, 0.648, 0.179); // RGB 80, 166, 46\n    float time = iTime * scrollSpeed;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (pixelsize > 1.0) {\n   \t\tuv = (pixelsize * floor(iResolution.xy * uv / pixelsize)) / iResolution.xy;\n        time = pixelsize * floor(iResolution.x / pixelsize * iTime * scrollSpeed) / iResolution.x;\n    }\n    \n    // generate fractal noise\n    float v = fBM(roughness, 7, 0.5, 2.31, uv + time);\n    \n    // map to range\n    v = 0.5 + 0.35 * v;\n    \n    // colorize\n    if (abs(v - uv.y) < surfaceThickness) {\n        // surface\n\t\tcol = mix(surfaceBright, surfaceDark, plot2d(uv.y, v + surfaceThickness * 0.5, surfaceThickness));\n\n    } else if (v < uv.y) {\n        // sky\n        vec3 sky = mix(skyBright, skyDark, uv.y);\n        float c = 2.5 * noise_fBM(2.0, 5, 0.5, 2.0, uv + vec2(iTime * (0.7 * scrollSpeed), 0.0));\n        vec3 clouds = vec3(c);\n        col = clamp(sky + clouds, sky, vec3(1.0));\n\n    } else {\n        // terrain\n        col = terrainBright;\n        \n        // add some structure\n        float noise = noise_fBM(16.0, 5, 0.5, 2.0, uv + vec2(time, 0.0));\n        noise = 0.5 + noise;\n\n        if (noise > 0.7) {\n            col = terrainDark;\n        }\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}