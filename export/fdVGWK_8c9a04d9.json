{"ver":"0.1","info":{"id":"fdVGWK","date":"1632213011","viewed":336,"name":"iPhone 13 pro wallpaper","username":"johnao","description":"iPhone 11 model with new iphone 13 pro wallpaper.\n\nUncomment #define SOLO_MODE to view single iphone","likes":11,"published":1,"flags":96,"usePreview":0,"tags":["iphone","apple"],"hasliked":0,"parentid":"tldGD7","parentname":"iPhone 11"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4tB3zh","filepath":"https://soundcloud.com/mrsuicidesheep/novo-amor-anchor","previewfilepath":"https://soundcloud.com/mrsuicidesheep/novo-amor-anchor","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"iPhone 11\" by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define MAX_STEPS 300\n#define MIN_DIST .5\n#define MAX_DIST 2400.\n#define SURF_DIST .1\n\n//#define SOLO_MODE\n\n#define BLUE vec3(0.6352941176470588, 0.7529411764705882, 0.8549019607843137)\n#define SILVER vec3(0.9019607843137255, 0.8666666666666667, 0.8823529411764706)\n#define GOLD vec3(0.8784313725490196, 0.8, 0.6941176470588235)\n#define BLACK vec3(0.36470588235294116, 0.3607843137254902, 0.34509803921568627)\n#define RED vec3(0.7607843137254902, 0.10196078431372549, 0.15294117647058825)\n#define WHITE vec3(1.)\n\nvec3 baseCol = BLACK;\n    \nmat2 Rot(float a) {\n    float s = sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\nvec2 sabs(vec2 x,float k) { return vec2(sabs(x.x, k), sabs(x.y,k)); }\nvec3 sabs(vec3 x,float k) { return vec3(sabs(x.x, k), sabs(x.y,k), sabs(x.z,k)); }\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdApple(vec2 p) {    \n    float d;\n    \n    float A = length(p-vec2(-.078,.02))-.52;\n    float B = length(p-vec2(.118,.045))-.552;\n    float sides = max(A, B);\n    \n    float C = length(p-vec2(-.181,.108))-.245;\n    float D = length(p-vec2(.178,.108))-.245;\n    float top = min(C, D);\n    \n    float E = length(p-vec2(-.153,-.29))-.115;\n    float F = length(p-vec2(.176,-.3))-.107;\n    float bottom = min(E, F);\n    \n    d = mix(\n        min(top, bottom),\n        sides,\n        S(.05, -.05, p.y-.188)*S(-.05,.01, p.y+.382)\n    );\n    \n    float G = length(p-vec2(.01, -.608))-.247;\n    d = smin(d, -G, -.03);\n    float H = length(p-vec2(.487, .06))-.222;\n    d = max(d, -H);\n    \n    float I = length(p-vec2(0,.417))-.113;\n    float J = length(p-vec2(0,.17))-.163;\n    d = min(d, max(-I, J));\n    \n    float K = length(p-vec2(.207, .365))-.222;\n    float L = length(p-vec2(-.02, .567))-.222;\n    d = min(d, max(K, L));\n    \n    return d;\n}\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(max(d.x,d.y), d.z),0.0) + length(max(d,0.0));\n}\nfloat sdBox2D( vec2 p, vec2 b ){\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCyl(vec3 p, float h, float r, float b) {\n\tfloat d = length(p.xy)-r+b;\n    return length(max(vec2(d, abs(p.z)-h), 0.))-b;\n}\n\nfloat sdCameras(vec3 p) {\n\t// cameras\n    float r2 = 14.7;\n\tvec2 size = vec2(26.2, 29.2);\n    \n    float d = sdBox2D(p.xy, size-r2)-r2;\n    \n    d = max(d, p.z);\t// cut back\n    \n    vec3 h = vec3(size.x, size.y, r2)-r2;\n    vec3 q = p - clamp( p, -h, h );\t\t\t// IQs elongation\n    float t = length(vec2(length(q.xy)-r2, q.z+1.))-1.; // torus\n    d = max(d, -t);\t// cut bevel\n    d = smin(d, -(p.z+1.), -.5); // cut front\n    \n    d = max(d, -sdCyl(p-vec3(11.6,0,-3.8), 1.5, 5.6, 2.));\t// flash\n    d = max(d, -sdCyl(p-vec3(11.6,14.5,-3.), 1.5, 2.8, 1.));\t// mike\n\n    // lenses\n    vec3 lp = vec3(p.x+11.5, abs(p.y)-14.6, p.z);\n    d = min(d, sdCyl(lp, 1.5, 12., .4)); // ring\n    d = min(d, sdCyl(lp, 1.8, 10., .3)); // lens cap\n    \n    d = max(d, (8.-length(lp*vec3(1,1,4)+vec3(0,0,7)))/4.); // hole\n    d = min(d, (length(lp*vec3(1,1,2))-4.)/2.);\n    \n    return d;\n}\n\nvec4 TransformPos(vec3 p) {\n\tfloat id = 0.;\n    #ifndef SOLO_MODE\n    vec3 s = sign(p);\n    vec3 size = vec3(400, 400, 800);\n    \n    float t = mod(iTime, 200.)*.5;\n    \n    p.z -= t*400.;\n    \n    id = floor(p.z/size.z);\n    p.z = mod(p.z, size.z)-size.z*.5;\n    \n    p.xy *= Rot(t*.3+id);\t\t\t// rotate wheel\n    s = sign(p);\n    float flip = s.x==s.y?1.:-1.;\n    p.xy = abs(p.xy)-size.xy*.5;\t// 4-fold \n    p.x *= flip;\n    \n    p.xy *= Rot(3.1415*.25*flip);\t\t// point to center\n    p.xz *= Rot(t+id);\t\t\t\t// spin on axis\n    \n    #endif\n    return vec4(p,id);\n}\n\nfloat GetDist(vec3 p) {\n    p = TransformPos(p).xyz;\n    \n    vec3 size = vec3(75.7, 150.9, 8.3);\n    float r1 = 24.3;\n    \n\tfloat front = sdBox2D(p.xy, size.xy-r1)-r1;\n    float side = sdBox2D(p.yz, vec2(144, 8.1)-8.)-8.;\n    float top = sdBox2D(p.xz, vec2(71.4, 8.1)-8.)-8.;\n   \n    float d = sdBox(p, size-size.z)-size.z;\n    d = smin(d, front, -4.);\n    \n    // front cam and speaker\n    d = smin(d, 1.-sdBox(p-vec3(0,137.8,size.z), vec3(7.95,0, .0)), -.5);\n    \n    vec3 h = size-r1;\n    vec3 q = p-clamp(p, -h, h);\n    float groove = length(q.xy*1.35)-r1-1.;\n    d += S(.5,-.5,groove)*.4;\n    \n    // buttons\n    side = step(0., p.x);\n    \n    float lb = sdBox2D(p.zy-vec2(0, 65.1), vec2(0,16))-3.;\n    lb = S(.3, -1., lb)-S(-.5, -2., lb)*1.5;\n    \n    float rb = sdBox2D(p.zy-vec2(0, 104.1), vec2(.5,6))-2.;\n    rb = S(.3, -1., rb);\n    d += rb * side;\n    rb = sdBox2D(p.zy-vec2(1, 104.1), vec2(0,6))-2.;\n    rb = S(.3, -1., rb);\n    d -= rb * side;\n    \n    vec2 bp = vec2(p.z, abs(p.y-65.1));\n    \n    rb = sdBox2D(bp-vec2(0, 13), vec2(0,9))-3.;\n    rb = S(.3, -1., rb)-S(-.5, -2., rb)*1.5;\n    \n    d += mix(lb, rb, side);\n    \n    // bottom\n    vec3 pb = vec3(abs(p.x), p.y+size.y, p.z); \n    float bb = sdBox(pb, vec3(8, 4, 0))-2.;\n    bb = min(bb, sdCyl((pb-vec3(15, 0, .6)).zxy, 1., 1.76, .5));\n    \n    pb.x = mod(pb.x-2.35, 4.7)-2.35;\n    float mh = sdCyl(pb.zxy, 4., 1.47, .2);\n    mh = max(mh, abs(abs(p.x)-35.4)-13.2);\n    bb = min(bb, mh);\n    \n    d = smin(d, -bb, -1.);\n    \n    // cameras\n    d = min(d, sdCameras(p-vec3(-39.6, 111.4, -size.z)));\n    \n    return d*.7;\n}\n\nfloat AO( in vec3 p, in vec3 n, in float maxDist, in float falloff ) {\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = fract(sin((float(i))*maxDist));\n        vec3 rd = n*l;\n        \n        ao += (l - max(GetDist( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=MIN_DIST;\n    float dS;\n    float matId=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec3(dO, abs(dS), matId);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(1e-2, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Pixelize(sampler2D sampler, vec2 uv, vec2 resolution) {\n   // resolution *= .1;\n    uv *= resolution;\n    \n    vec2 c = fwidth(uv)*100.;\n    \n    vec2 gv = fract(uv)-.5; \n    vec2 id = floor(uv);\n    \n    float rbPixel = length(gv);\n    float gPixel = length(abs(gv)-.5);\n    \n    float checker = mod(id.x+id.y, 2.);\n    vec3 colorMask = vec3(checker, 0., 1.-checker);\n    \n    float rgbShift = smoothstep(.4, .2, gPixel);\n    colorMask = mix(colorMask, vec3(0,1,0), rgbShift);\n    \n    id += rgbShift*.5*sign(gv);\n    vec3 col = texture(sampler, id/resolution).rgb;\n    \n\tfloat pixelMask = smoothstep(.5, .2, rbPixel) + smoothstep(.3, .2, gPixel);\n    \n    float fade = clamp(dot(c,c)/1e4, 0., 1.);\n    col *= mix(pixelMask*colorMask*2., vec3(1.), fade);\n    //col = vec3(fade);\n    \n    return col;\n}\n\nvoid SetBaseCol(float id) {\n     if(id==0.)\n    \tbaseCol = BLACK;\n    else if(id==1.)\n        baseCol = SILVER;\n    else if(id==2.)\n        baseCol = GOLD;\n    else if(id==3.)\n        baseCol = RED;\n    else\n        baseCol = BLUE;\n}\n\nvec3 Material(vec3 p, vec3 n, vec3 rd) {    \n    float ao = AO(p, n, .5, .5);\n    \n    vec3 s = sign(p);\n    vec4 P = TransformPos(p);\n    \n    p = P.xyz;\n    \n    float id = mod(P.w, 5.);\n    SetBaseCol(id);\n      \n    vec3 col;\n    \n    vec3 r = reflect(rd, n);\n    float f = 1.+dot(n, rd);\n    float fresnel = pow(max(f, 0.), 2.);\n    \n    vec3 blurRef = texture(iChannel0, r).rgb;\n    vec3 sharpRef = texture(iChannel1, r).rgb;\n    \n    float w = .2;\n    \n    float side = step(0., -p.z);\t// which side 0=front 1=back\n    float bandDist = sdBox2D(p.xy, vec2(51.3, 126.6))-18.7;\n    float band = S(-w, w, bandDist);\n    \n    if(side<.5) {\t// screen side\n        float screenDist = sdBox2D(p.xy, vec2(51.3, 126.6)-1.)-15.;\n        screenDist = smin(screenDist, 10.-sdBox2D(p.xy-vec2(0,139.5), vec2(30, 10.5)-10.), -3.);\n        float screen = S(w, -w, screenDist)*(1.-side);\n        \n        vec2 uv = p.xy/vec2(-150*2, 300) +.5;\n        vec3 scrCol = texture(iChannel2, uv).rgb;\n        scrCol = Pixelize(iChannel2, uv, vec2(828,1792));\n        col = scrCol*screen;\n        col += .002*(1.-screen);\n        vec2 lp = p.xy-vec2(-14.6, 137.8);\n        float d = length(lp)-2.6;\n        if(d<0.) {\n            float z = 1.-rd.y;\n            z = 0.;\n            \n            vec3 ref = vec3(.3, .2, .8)*S(.3, -.3, d+1.)*d*d*.5;\n            ref *= ref;\n            ref *= pow(1.-f, 12.)*.25;\n            \n            col = ref;\n        }\n        \n        col += sharpRef*.05;\n        \n    } else {\t\t\t// back side\n        float logo = S(.01, -.01, sdApple(p.xy*.04));\n    \t\n        col = baseCol*baseCol*ao;\n        col += mix(blurRef, sharpRef, logo)*.5;\n        \n        // camera area \n        vec2 cp = p.xy-vec2(-39.6, 111.4);\n        vec2 lp = vec2(cp.x+11.5, abs(cp.y)-14.6);\n        float d = length(lp);\n        \n        if(d<10.) {\n            col = vec3(col.r*0.1);\n            vec3 ref = sharpRef*vec3(.3, .2, .8)*2.;\n            col += ref*ref*sqrt(f)*S(4., 3., d);\n            ref = texture(iChannel1, reflect(rd,vec3(0,0,-1))).rgb;\n            //col *= ao;\n            col += ref*rd.y;   \n        } else if(d<12.) {\n            band = 1.;\n        }\n        \n        // flash\n        vec2 fp = cp-vec2(11.5,0);\n        d = length(fp);\n        if(d<4.5) {\n            float fd = length(fp+rd.xy);\n            float sep = 2.;\n            float w1d = length(fp-vec2(0, sep));\n            float w2d = length(fp+vec2(0, sep));\n            float freq = 15.;\n            float waves = (sin(w1d*freq)+sin(w2d*freq))*S(.0, -.5, fd-4.3); \n            vec3 flashCol = mix(vec3(1., .5, .2), vec3(.8), fd*.3);\n           \tflashCol += S(3., 1., length(fp-vec2(0.,sep)))*.2;\n            flashCol += waves*.05;\n            col = mix(col, flashCol, S(.3, -.0, d-4.2));\n            col *= S(1., -1., d-4.5);\n        }\n        \n        // mike\n        fp = cp-vec2(11.5,14.5);\n        float fd = length(fp);\n        if(fd<2.2) {\n            float m = S(2.2, 2., fd);\n            fp *= 10.;\n            m *= max(0., sin(fp.x+fp.y))+max(0., sin(fp.x-fp.y));\n        \tfloat distFade = min(1., fwidth(length(p))*3.);\n            col = mix(vec3(m), vec3(.5), distFade);\n            //col = vec3(distFade);\n        }\n    }\n    \n    float gaps = S(w, -w, abs(abs(p.y)-120.)-1.4);\n    gaps *= S(71.7, 72.1, abs(p.x));\n    vec3 bandCol = pow(blurRef, vec3(.4))*baseCol;\n    bandCol *= 1.-gaps*.3;\n    \n    float shadow = clamp(74.2-abs(p.x), 0., 1.);\n    shadow *= clamp(4.-abs(p.z), 0., 1.); \n    float s1 = shadow;\n    shadow *= clamp(115.-abs(p.y), 0., 1.);\n    shadow += S(-149., -146., p.y)*s1*S(52., 50., length(p.xy+vec2(0,150)));\n    bandCol -= shadow;\n    \n    col = mix(col, bandCol, band);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    float t = iTime;\n    \n    vec2 p = uv;\n    float zoom = mix(1., 15., (sin(iTime)*.5+.5)*0.);\n    \n    #ifdef SOLO_MODE\n    vec3 ro = vec3(0,0,300);\n    /*if(uv.x>0.) {\n    \tuv.x -= .5;\n    } else {\n    \tuv.x += .3;\n        uv *= .4;\n    }*/\n    #else\n    vec3 ro = vec3(0,0,600);\n    #endif\n    \n    ro.xz *= Rot(-M.x*6.2831-3.1415);\n    //ro.yx *= -Rot(M.y*3.1415);\n    ro.y -= M.y*800.;\n    vec3 lookat = vec3(0, ro.y*.3, 0);\n    //lookat = vec3(-39.6, 111.4, 10);\n    //lookat = vec3(-59.6*0., 136.4, 10);\n    //lookat = vec3(0, -140,0);\n    \n    vec3 rd = R(uv, ro, lookat, zoom);\n\tvec3 bg = WHITE;\n    #ifdef SOLO_MODE\n    float f = .01/dot(uv,uv);\n    //bg *= 0.;\n    #endif\n    \n    vec3 col = bg;\n    \n    vec3 info = RayMarch(ro, rd);\n    \n    if(info.y<SURF_DIST) {\n        vec3 p = ro + rd*info.x;\n        vec3 n = GetNormal(p);\n        col = Material(p, n, rd);\n    }\n    \n    float fade = min(1., info.x/2400.);\n    col = mix(col, bg, fade*fade*fade);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// sampling directions\n#define N_DIRECTION 32\n#define fN_DIRECTION 32.0\n\n// constants\n#define PI 3.1415926535\n#define TAU 6.2831853\n#define INF 2.0\n\n#define COLOR0 vec3(0.0, 0.0, 0.11764705882352941)\n#define COLOR1 vec3(0.615686274509804, 0.9607843137254902, 1.0)\n#define COLOR2 vec3(0.23529411764705882, 0.5843137254901961, 0.9725490196078431)\n#define COLOR3 vec3(0.4666666666666667, 0.6392156862745098, 0.8745098039215686)\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat disSeg(vec2 o,vec2 d, vec2 a, vec2 b){\n    vec2 e=a-b;\n    vec2 f=a-o;\n    if(f.y*e.x<f.x*e.y)return INF;\n    float det=d.x*e.y-d.y*e.x;\n    if(det==0.)return INF;\n    float s=(f.x*e.y-f.y*e.x)/det;\n    float t=(d.x*f.y-d.y*f.x)/det;\n    if(t>=0.&&t<=1.&&s>0.)return s;\n    return INF;\n}\n\nvec4 neon(vec2 o,vec2 d, vec2 a, vec2 b){\n    vec3 col=COLOR0*3.5;\n    float t;\n    if((t=disSeg(o,d,a,b))<INF){\n        col=(COLOR1*exp(-200.*t*t)+COLOR2*1.2*exp(-50.*t*t))*1.;\n    }else if((t=disSeg(o,d,b,a))<INF){\n        col=COLOR3*2.*exp(-100.*t*t);\n    }\n    return vec4(col,t);\n}\n\nvec3 sampling(vec2 o, vec2 d){\n    float t=iTime+3.5;\n    float k=clamp(-3.2*sin(t*1.2)-2.,0.,1.);\n    vec4 c=neon(o,d,vec2(.5-.15*k,.5),vec2(.5+.15*k,.5));\n    float s=c.w;\n    vec3 col=c.xyz;\n    //c=neon(o,d,vec2(.5,.28+.15*max(0.,sin(t*1.2))),vec2(.5,.43+.15*min(0.,sin(t*1.2))));\n    //c=neon(o,d,vec2(.5,.28+.15*(1.-clamp(2.*abs(sin(t*.6+1.57)),0.,1.))),vec2(.5,.28+.15*clamp(2.*abs(sin(t*.6)),0.,1.)));\n    //c=neon(o,d,vec2(.5,.28+.15*clamp((abs(cos(t*.6))-0.83)/0.15,0.,1.)),vec2(.5,.28+.15*(1.-clamp((abs(sin(t*.6))-0.83)/0.15,0.,1.))));\n    c=neon(o,d,vec2(.5,.28),vec2(.5,.28+.15*max(0.,sin(-t*1.2)*.6+0.4)));\n    if(c.w<s){\n        s=c.w;\n        col=c.xyz;\n    }\n    //k=min(1.,0.6*(sin(t*1.2+1.97)+1.));\n    //c=neon(o,d,vec2(.15,.73),vec2(.15+0.3*k,.73-0.16*k));\n    k=clamp(-.6*sin(t*1.2)+.5,0.,1.);\n    c=neon(o,d,vec2(.15,.73),vec2(.15+0.3*k,.73-0.16*k));\n    if(c.w<s){\n        s=c.w;\n        col=c.xyz;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 s=vec3(0.);\n    vec2 uv=(fragCoord+.5*vec2(max(0.,iResolution.y-iResolution.x),max(0.,iResolution.x-iResolution.y)))/max(iResolution.x,iResolution.y);\n    float n=rand(uv+mod(iTime,100.))*3.;\n    for(int i=0;i<N_DIRECTION;++i){\n        s+=sampling(uv,vec2(sin(n+float(i)*TAU/fN_DIRECTION),cos(n+float(i)*TAU/fN_DIRECTION)));\n    }\n    s=s/fN_DIRECTION;\n    fragColor = vec4(pow(s,vec3(2.5)),1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}