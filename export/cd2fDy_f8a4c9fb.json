{"ver":"0.1","info":{"id":"cd2fDy","date":"1690098804","viewed":58,"name":"2023/7/24","username":"olxh","description":"3d shader","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID:  SWS3005_01\n//\n// GROUP NUMBER: 01\n//\n// STUDENT NAME:  LI SHIYANG\n// NUS User ID.:  t0930151\n//\n// STUDENT NAME:  HUANG JUNYUAN\n// NUS User ID.:  t0930142\n//\n// STUDENT NAME:  ZHANG CHENRUI\n// NUS User ID.:  t0930305\n//\n// COMMENTS TO GRADER:  fine \n//\n//============================================================================\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.7, 0.6);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 40.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\nconst int STACK_SIZE = 3;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 1;\nconst int NUM_PLANES = 7;\nconst int NUM_SPHERES = 20;\nconst int NUM_TRIANGLES = 20;\nconst int NUM_MATERIALS = 4+NUM_SPHERES;\n\nconst float DELTA_TIME = 0.01;\nconst float CAMAERA_T = 40.0;\nconst float CAMAERA_DELTA_ANGLE = PI * 2.0 / (CAMAERA_T / DELTA_TIME);\nfloat cameraAng = 0.0;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Triangle_t {\n    vec3 p[3];\n    vec3 N;\n    int materialID;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_t;   // Refracted specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    vec3 k_tg;  // Global refraction coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n    float m;    // The refraction exponent. Ranges from 0.0 to 1.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS+1];\nTriangle_t Triangle[NUM_TRIANGLES];\n\nfloat interplote(float minX,float maxX,float t,float T) {\n    return minX + (maxX-minX)*t/T;\n}\n\nvec3 interplote(vec3 minX,vec3 maxX,float t,float T) {\n    return minX + (maxX-minX)*t/T;\n}\n\nMaterial_t interplote(const in Material_t a, const in Material_t b,float t,float T) {\n    Material_t c;\n    c.k_d = interplote(a.k_d,b.k_d,t,T);\n    c.k_a = interplote(a.k_a,b.k_a,t,T);\n    c.k_r = interplote(a.k_r,b.k_r,t,T);\n    c.k_rg = interplote(a.k_rg,b.k_rg,t,T);\n    c.k_t = interplote(a.k_t,b.k_t,t,T);\n    c.k_tg = interplote(a.k_tg,b.k_tg,t,T);\n    c.n = interplote(a.n,b.n,t,T);\n    c.m = interplote(a.m,b.m,t,T);\n    return c;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene() {\n    const float lightDist = 14.0; \n    // Light 0.\n    cameraAng = floor(iTime / DELTA_TIME) * CAMAERA_DELTA_ANGLE;\n    if(cameraAng > 2.0 * PI)\n        cameraAng -= 2.0 * PI;\n    if(cameraAng < 0.0)\n        cameraAng += 2.0 * PI;\n\n    Light[0].position = vec3(lightDist * sin(cameraAng), 12.0, lightDist * cos(cameraAng));\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(1.0, 1.0, 1.0);\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    float planeDist = 18.0;\n    float planeIntervallAng = PI / 3.0;\n    for(int i = 1; i < 7; i++) {\n        float nowAng = float(i) * planeIntervallAng;\n        Plane[i].A = sin(nowAng);\n        Plane[i].B = 0.0;\n        Plane[i].C = cos(nowAng);\n        vec3 normal = normalize(vec3(Plane[i].A, 0.0, Plane[i].C));\n        vec3 posInPlane = -planeDist * normal;\n        Plane[i].D = -dot(normal, posInPlane);\n        Plane[i].materialID = 0;\n    }\n\n    float T = 21.0;\n    float circleT = 10.5;\n    float minOuterCircleRadius = 0.0;\n    float maxOuterCircleRadius = 4.0;\n    float minHeight = 1.0;\n    float maxHeight = 10.0;\n    float minR = 0.1;\n    float maxR = 1.2;\n    float intervalSec = T / float(NUM_SPHERES);\n    float nowMinHeight = maxHeight;\n    int nowMinHeightMaterialID = 4;\n    float SphereInACircle = 6.0;\n    for(int i = 0; i < NUM_SPHERES; i++) {\n        float t = iTime - intervalSec * float(i);\n        float nowTime = t - floor(t / T) * T;\n        if(nowTime < 0.0)\n            nowTime += T;\n        float nowAng = (t - floor(t / circleT) * circleT) / circleT * 2.0 * PI;\n        if(nowAng < 0.0)\n            nowAng += 2.0 * PI;\n        float SphereRadius = interplote(minR,maxR,nowTime,T);\n        float nowHeight = interplote(minHeight,maxHeight,nowTime,T);\n        float nowOuterCircleRadius = interplote(minOuterCircleRadius,maxOuterCircleRadius,nowTime,T);\n        Sphere[i].center = vec3(nowOuterCircleRadius * cos(nowAng), nowHeight, nowOuterCircleRadius * sin(nowAng));\n        Sphere[i].radius = SphereRadius * 1.08;\n        Sphere[i].materialID = i % (NUM_MATERIALS - 4) + 4;\n        if(nowHeight<nowMinHeight) {\n            nowMinHeight = nowHeight;\n            nowMinHeightMaterialID = Sphere[i].materialID;\n        }\n    }\n\n    float OuterOffset = 6.25;\n    float InnerOffset = 1.0;\n    float TriangleHeight = 4.0;\n    vec3 OuterOffsetArray[5];\n    OuterOffsetArray[0] = vec3(OuterOffset, 0.0, OuterOffset);\n    OuterOffsetArray[1] = vec3(-OuterOffset, 0.0, OuterOffset);\n    OuterOffsetArray[2] = vec3(-OuterOffset, 0.0, -OuterOffset);\n    OuterOffsetArray[3] = vec3(OuterOffset, 0.0, -OuterOffset);\n    OuterOffsetArray[4] = vec3(0.0, 0.0, 0.0);\n    vec3 InnerOffsetArray[4];\n    InnerOffsetArray[0] = vec3(InnerOffset, 0.0, InnerOffset);\n    InnerOffsetArray[1] = vec3(-InnerOffset, 0.0, InnerOffset);\n    InnerOffsetArray[2] = vec3(-InnerOffset, 0.0, -InnerOffset);\n    InnerOffsetArray[3] = vec3(InnerOffset, 0.0, -InnerOffset);\n    for(int i = 0; i < 5; i++) {\n        for(int j = 0; j < 4; j++) {\n            Triangle[i * 4 + j].p[0] = OuterOffsetArray[i] + InnerOffsetArray[j];\n            Triangle[i * 4 + j].p[1] = OuterOffsetArray[i] + InnerOffsetArray[(j + 1) % 4];\n            Triangle[i * 4 + j].p[2] = OuterOffsetArray[i] + vec3( 0.0, TriangleHeight, 0.0 );\n            if(i==4) Triangle[i * 4 + j].p[2].y = minHeight-0.1;\n            Triangle[i * 4 + j].materialID = 4+i*3;\n            if(i==4) Triangle[i * 4 + j].materialID = NUM_MATERIALS;\n            Triangle[i * 4 + j].N = normalize(cross(Triangle[i * 4 + j].p[1] - Triangle[i * 4 + j].p[2], Triangle[i * 4 + j].p[0] - Triangle[i * 4 + j].p[2]));\n        }\n    }\n\n    // Silver material.\n    Material[0].k_d = vec3(0.5, 0.5, 0.5);\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Horizontal Plane Bounce material\n    Material[1].k_d = vec3(0.4, 0.4, 0.4);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = vec3(1.0, 1.0, 1.0);\n    Material[1].n = 64.0;\n\n    // Horizontal Plane Base material\n    Material[2].k_d = vec3(1.0, 1.0, 1.0);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 2.0 * Material[2].k_d;\n    Material[2].n = 64.0;\n\n    // Back wall material.\n    Material[3].k_d = vec3(0.0, 0.8, 0.0);\n    Material[3].k_a = vec3(0.5, 0.5, 0.5);\n    Material[3].k_r = vec3(1.0, 1.0, 1.0);\n    Material[3].n = 128.0;\n    for(int i = 0; i < 4; i++) {\n        Material[i].k_t = Material[i].k_tg = vec3(0.0);\n        Material[i].m = 0.0;\n    }\n\n    const vec2 red = vec2(1.0,0);\n    const vec2 green = vec2(-cos(PI/3.0),sin(PI/3.0));\n    const vec2 blue = vec2(-cos(PI/3.0),-sin(PI/3.0));\n\n    // Ball material\n    for(int i = 4; i < NUM_MATERIALS; i++) {\n        float ang = float(i - 4) / float(NUM_MATERIALS - 4) * 2.0 *PI;\n        vec2 nowColor = vec2(cos(ang),sin(ang));\n        float r = dot(red,nowColor);\n        float g = dot(green,nowColor);\n        float b = dot(blue,nowColor);\n        Material[i].k_d = vec3(max(abs(r),0.5),max(abs(g),0.5),max(abs(b),0.5));\n        Material[i].k_a = 0.2 * Material[i].k_d;\n        if((i & 1) ==0) {\n            Material[i].k_r = 2.0 * Material[i].k_d;\n            Material[i].k_rg = 0.5 * Material[i].k_r;\n            Material[i].k_t = Material[i].k_tg = vec3(0.0);\n            Material[i].m = 0.0;\n            Material[i].n = 64.0;\n        } else {\n            Material[i].k_r = 0.0 * Material[i].k_d;\n            Material[i].k_rg = 0.0 * Material[i].k_r;\n            Material[i].k_t = 0.8 * Material[i].k_d;\n            Material[i].k_tg = 0.9 * Material[i].k_t;\n            Material[i].k_d *= 0.5;\n            Material[i].n = 1.0;\n            Material[i].m = 1.0;\n        }\n    }\n\n    float tt = iTime/intervalSec - floor(iTime/intervalSec);\n    int nextMinHeightMaterialID = 4+(nowMinHeightMaterialID+1)%(NUM_MATERIALS - 4);\n    Material[NUM_MATERIALS] = interplote(Material[nowMinHeightMaterialID],\n    Material[nextMinHeightMaterialID],tt,1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(\n    in Plane_t pln,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(N);\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(\n    in Sphere_t sph,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 scRayo = ray.o - sph.center;\n    float b = 2.0 * dot(ray.d, scRayo);\n    float c = dot(scRayo, scRayo) - sph.radius * sph.radius;\n    float delta = b * b - 4.0 * c;\n    if(delta < 0.0)\n        return false;\n    float t0 = (-b - sqrt(delta)) / 2.0;\n    float t1 = (-b + sqrt(delta)) / 2.0;\n    float t2 = min(t0, t1);\n    if(t2 < 0.0)\n        t2 = max(t0, t1);\n    if(t2 < 0.0 || t2 < tmin || t2 > tmax)\n        return false;\n    hitPos = ray.o + t2 * ray.d;\n    t = t2;\n    hitNormal = normalize(hitPos - sph.center);\n    return true;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    vec3 scRayo = ray.o - sph.center;\n    float b = 2.0 * dot(ray.d, scRayo);\n    float c = dot(scRayo, scRayo) - sph.radius * sph.radius;\n    float delta = b * b - 4.0 * c;\n    if(delta < 0.0)\n        return false;\n    float t0 = (-b - sqrt(delta)) / 2.0;\n    float t1 = (-b + sqrt(delta)) / 2.0;\n    float t2 = min(t0, t1);\n    if(t2 < 0.0)\n        t2 = max(t0, t1);\n    if(t2 < 0.0 || t2 < tmin || t2 > tmax)\n        return false;\n    return true;\n\n}\n\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle( in Triangle_t Trian, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) {\n    if(dot(Trian.N, ray.d) > 0.0) return false;\n    struct GaussianElimination {\n        float a[3], b;\n    }g[3], tmp;\n    g[0].a[0] = Trian.p[0].x - Trian.p[1].x;\n    g[0].a[1] = Trian.p[0].x - Trian.p[2].x;\n    g[0].a[2] = ray.d.x;\n    g[1].a[0] = Trian.p[0].y - Trian.p[1].y;\n    g[1].a[1] = Trian.p[0].y - Trian.p[2].y;\n    g[1].a[2] = ray.d.y;\n    g[2].a[0] = Trian.p[0].z - Trian.p[1].z;\n    g[2].a[1] = Trian.p[0].z - Trian.p[2].z;\n    g[2].a[2] = ray.d.z;\n    g[0].b = Trian.p[0].x - ray.o.x;\n    g[1].b = Trian.p[0].y - ray.o.y;\n    g[2].b = Trian.p[0].z - ray.o.z;\n    float eps = 1e-8;\n    bool HasIntersect = true;\n    for(int k = 0; k < 3; k++) {\n        for(int i = k + 1; i < 3; i++)\n        \tif( abs(g[i].a[k]) > abs(g[k].a[k]) ) {\n                tmp = g[i];\n                g[i] = g[k];\n                g[k] = tmp;\n            }\n        for(int i = 0; i < 3; i++)\n        \tif(abs(g[k].a[i]) > eps) break;\n        \telse if(i == 2 && abs(g[k].b) < eps) {\n        \t\tHasIntersect = false;\n            \tbreak;\n\t\t\t}\n        if(HasIntersect == false) break;\n        float s = g[k].a[k];\n        for(int i = k; i < 3; i++) g[k].a[i] /= s;\n        g[k].b /= s;\n        for(int i = 0; i < 3; i++) {\n            if(i == k)continue;\n            s = g[i].a[k];\n            for(int j = k; j < 3; j++)\n                g[i].a[j] -= (g[k].a[j] * s);\n            g[i].b -= (g[k].b * s);\n        }\n    }\n    if(HasIntersect == false)\n        return false;\n    if(0.0 < g[0].b && g[0].b < 1.0 && 0.0 < g[1].b && g[1].b < 1.0 && g[0].b + g[1].b < 1.0 && g[2].b >= tmin && g[2].b <= tmax)\n        HasIntersect = true;\n    else HasIntersect = false;\n    if(HasIntersect == false)\n        return false;\n    t = g[2].b;\n    hitPos = ray.o + t * ray.d;\n    hitNormal = Trian.N;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle( in Triangle_t Trian, in Ray_t ray, in float tmin, in float tmax ) {\n    if(dot(Trian.N, ray.d) > 0.0) return false;\n    struct GaussianElimination {\n        float a[3], b;\n    }g[3], tmp;\n    g[0].a[0] = Trian.p[0].x - Trian.p[1].x;\n    g[0].a[1] = Trian.p[0].x - Trian.p[2].x;\n    g[0].a[2] = ray.d.x;\n    g[1].a[0] = Trian.p[0].y - Trian.p[1].y;\n    g[1].a[1] = Trian.p[0].y - Trian.p[2].y;\n    g[1].a[2] = ray.d.y;\n    g[2].a[0] = Trian.p[0].z - Trian.p[1].z;\n    g[2].a[1] = Trian.p[0].z - Trian.p[2].z;\n    g[2].a[2] = ray.d.z;\n    g[0].b = Trian.p[0].x - ray.o.x;\n    g[1].b = Trian.p[0].y - ray.o.y;\n    g[2].b = Trian.p[0].z - ray.o.z;\n    float eps = 1e-8;\n    bool HasIntersect = true;\n    for(int k = 0; k < 3; k++) {\n        for(int i = k + 1; i < 3; i++)\n        \tif( abs(g[i].a[k]) > abs(g[k].a[k]) ) {\n                tmp = g[i];\n                g[i] = g[k];\n                g[k] = tmp;\n            }\n        for(int i = 0; i < 3; i++)\n        \tif(abs(g[k].a[i]) > eps) break;\n        \telse if(i == 2 && abs(g[k].b) < eps) {\n        \t\tHasIntersect = false;\n            \tbreak;\n\t\t\t}\n        if(HasIntersect == false) break;\n        float s = g[k].a[k];\n        for(int i = k; i < 3; i++) g[k].a[i] /= s;\n        g[k].b /= s;\n        for(int i = 0; i < 3; i++) {\n            if(i == k)continue;\n            s = g[i].a[k];\n            for(int j = k; j < 3; j++)\n                g[i].a[j] -= (g[k].a[j] * s);\n            g[i].b -= (g[k].b * s);\n        }\n    }\n    if(HasIntersect == false)\n        return false;\n    if(0.0 < g[0].b && g[0].b < 1.0 && 0.0 < g[1].b && g[1].b < 1.0 && g[0].b + g[1].b < 1.0 && g[2].b >= tmin && g[2].b <= tmax)\n        HasIntersect = true;\n    else HasIntersect = false;\n    if(HasIntersect == false)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    in float eta,\n    in vec3 inShadow,\n    in Material_t mat,\n    in Light_t light\n) {\n    if(length(inShadow) < 0.01)\n        return light.I_a * mat.k_a;\n    else {\n        vec3 R = reflect(-L, N);\n        vec3 T = refract(-L, N, eta);\n        float N_dot_L = max(0.0, dot(N, L));\n        float R_dot_V = max(0.0, dot(R, V));\n        float T_dot_V = max(0.0, dot(R, T));\n\n        float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n        float T_dot_V_pow_m = (T_dot_V == 0.0) ? 0.0 : pow(T_dot_V, mat.m);\n\n        return light.I_a * mat.k_a +\n            inShadow * light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n + mat.k_t * T_dot_V_pow_m);\n    }\n\n}\n\nint FetchPlaneMaterial(in int Planeid, in vec3 hitPosition, in vec3 temp_hitNormal, out vec3 nearest_hitNormal) {\n    float StripWidth = 0.2;\n    float MiniSquareSideLen = 2.5;\n    float MiniSquareHalfLen = MiniSquareSideLen / 2.0;\n    if(Planeid > 0) {\n        nearest_hitNormal = temp_hitNormal;\n        return Plane[Planeid].materialID;\n    } else {\n    // normal\n        float PositionX = hitPosition.x - floor(hitPosition.x / MiniSquareSideLen) * MiniSquareSideLen;\n        float PositionZ = hitPosition.z - floor(hitPosition.z / MiniSquareSideLen) * MiniSquareSideLen;\n        float DeltaX = PositionX > MiniSquareHalfLen ? MiniSquareSideLen - PositionX : PositionX;\n        float DeltaZ = PositionZ > MiniSquareHalfLen ? MiniSquareSideLen - PositionZ : PositionZ;\n        if(DeltaX < StripWidth || DeltaZ < StripWidth) {\n            if(DeltaX < DeltaZ) {\n                if(PositionX < MiniSquareHalfLen)\n                    nearest_hitNormal = normalize(vec3(1.0, 1.0, 0.0));\n                else\n                    nearest_hitNormal = normalize(vec3(-1.0, 1.0, 0.0));\n            } else {\n                if(PositionZ < MiniSquareHalfLen)\n                    nearest_hitNormal = normalize(vec3(0.0, 1.0, 1.0));\n                else\n                    nearest_hitNormal = normalize(vec3(0.0, 1.0, -1.0));\n            }\n            return 1;\n        } else {\n            nearest_hitNormal = temp_hitNormal;\n            return 2;\n        }\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(\n    in Ray_t ray,\n    in float eta,\n    out bool hasHit,\n    out vec3 hitPos,\n    out vec3 hitNormal,\n    out vec3 k_rg,\n    out vec3 k_tg\n) {\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for(int i = 0; i < NUM_PLANES; i++) {\n        Plane_t plane = Plane[i];\n        if(plane.materialID == -1)\n            continue;\n        if(IntersectPlane(plane, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)) {\n            if(temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitMatID = FetchPlaneMaterial(i, nearest_hitPos, temp_hitNormal, nearest_hitNormal);\n                hasHitSomething = true;\n            }\n        }\n    }\n    for(int i = 0; i < NUM_SPHERES; i++) {\n        Sphere_t sphere = Sphere[i];\n        if(IntersectSphere(sphere, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)) {\n            if(temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = sphere.materialID;\n                hasHitSomething = true;\n            }\n        }\n    }\n    for(int i = 0; i < NUM_TRIANGLES; i++) {\n        Triangle_t triangle = Triangle[i];\n        if(IntersectTriangle(triangle, ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal)) {\n            if(temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = triangle.materialID;\n                hasHitSomething = true;\n            }\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if(!hasHitSomething)\n        return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3(0.0);  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    if(eta<1.0) nearest_hitPos += 0.05*DEFAULT_TMIN * nearest_hitNormal;\n    else nearest_hitPos -= 0.05*DEFAULT_TMIN * nearest_hitNormal;\n    for(int i = 0; i < NUM_LIGHTS; i++) {\n        Light_t light = Light[i];\n        Ray_t shadowRay = Ray_t(nearest_hitPos, normalize(light.position - nearest_hitPos));\n        vec3 inShadow = vec3(1.0);\n        float tmax = length(light.position - nearest_hitPos);\n\n        for(int j = 0; j < NUM_PLANES; j++) {\n            Plane_t plane = Plane[j];\n            if(IntersectPlane(plane, shadowRay, DEFAULT_TMIN, tmax)) {\n                inShadow *= Material[plane.materialID].k_t*0.5;\n                if(length(inShadow) < 0.01)\n                    break;\n            }\n        }\n        if(length(inShadow) > 0.0) {\n            for(int j = 0; j < NUM_SPHERES; j++) {\n                Sphere_t sphere = Sphere[j];\n                if(IntersectSphere(sphere, shadowRay, DEFAULT_TMIN, tmax)) {\n                    inShadow *= Material[sphere.materialID].k_t*0.5;\n                    if(length(inShadow) < 0.01)\n                        break;\n                }\n            }\n            if(length(inShadow)>0.0) {\n                for(int j = 0; j < NUM_TRIANGLES; j++) {\n                    Triangle_t triangle = Triangle[j];\n                    if(IntersectTriangle(triangle, shadowRay, DEFAULT_TMIN, tmax)) {\n                        inShadow *= Material[triangle.materialID].k_t*0.5;\n                        if(length(inShadow) < 0.01)\n                            break;\n                    }\n                }\n            }\n        }\n        I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, eta, inShadow, Material[nearest_hitMatID], light);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    k_tg = Material[nearest_hitMatID].k_tg;\n\n    return I_local;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    const float camera_dist = 16.0;\n\n    vec3 cam_pos = vec3(camera_dist * sin(cameraAng), 8.0, camera_dist * cos(cameraAng));\n    vec3 cam_lookat = vec3(0.0, 2.0, 0.0);\n    vec3 cam_up_vec = vec3(0.0, 1.0, 0.0);\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n    vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis + pixel_pos_z * cam_z_axis);\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result[STACK_SIZE];\n    Ray_t ray[STACK_SIZE];\n    int state[STACK_SIZE];\n    vec3 hitNormal[STACK_SIZE];\n    vec3 k_rg[STACK_SIZE];\n    vec3 k_tg[STACK_SIZE];\n    vec3 hitPos[STACK_SIZE];\n    float eta[STACK_SIZE];\n    ray[0] = pRay;\n    state[0] = 0;\n    eta[0] = 1.0 / 1.5;\n    int top = 0;\n\n    while(top >= 0) {\n        bool hasHit;\n        if(top == STACK_SIZE - 1) {\n            I_result[top] = CastRay(ray[top], eta[top], hasHit, hitPos[top], hitNormal[top], k_rg[top], k_tg[top]);\n            top--;\n            continue;\n        }\n        int son = top + 1;\n        switch(state[top]) {\n            case 0: {\n                I_result[top] = CastRay(ray[top], eta[top], hasHit, hitPos[top], hitNormal[top], k_rg[top], k_tg[top]);\n                if(!hasHit) {\n                    top--;\n                } else {\n                    state[top]++;\n                    if(length(k_rg[top]) > 0.01) {\n                        ray[son] = Ray_t(hitPos[top], normalize(reflect(ray[top].d, hitNormal[top])));\n                        eta[son] = eta[top];\n                        state[son] = 0;\n                        top = son;\n                    } else {\n                        I_result[son] = vec3(0.0);\n                    }\n                }\n            }\n            break;\n            case 1: {\n                I_result[top] += k_rg[top] * I_result[son];\n                state[top]++;\n                if(length(k_tg[top]) > 0.01) {\n                    ray[son] = Ray_t(hitPos[top], normalize(refract(ray[top].d, hitNormal[top], eta[top])));\n                    eta[son] = 1.0 / eta[top];\n\n                    state[son] = 0;\n                    top = son;\n                } else {\n                    I_result[son] = vec3(0.0);\n                }\n            }\n            break;\n            case 2: {\n                I_result[top] += k_tg[top] * I_result[son];\n                top--;\n            }\n\n        }\n    }\n\n    fragColor = vec4(I_result[0], 1.0);\n}","name":"Image","description":"","type":"image"}]}