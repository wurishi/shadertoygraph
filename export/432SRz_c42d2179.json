{"ver":"0.1","info":{"id":"432SRz","date":"1710208987","viewed":118,"name":"...Like antennas to heaven","username":"BurgerTown","description":"Shader based off of the final level in ultrakills violence layer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ultrakill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float height = 1.3;\nvec3 light = vec3(0.,.5,0.1);\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n//iq functions\n//https://iquilezles.org/articles/\nfloat hash( ivec3 p ){\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\nfloat noise( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat messyNoise(vec3 pos){\n    mat3 m = mat3( 0.00,  0.80,  0.60,-0.80,  0.36, -0.48,-0.60, -0.48,  0.64 );\n    vec3 q = 8.0*pos;\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n//\nvec2 sdBox( vec3 p, vec3 b , float id)\n{\n  vec3 q = abs(p) - b;\n  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),id);\n}\nvec2 sdRoundCone( vec3 p, vec3 a, vec3 b, float r1, float r2, float id )\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot( pa*l2 - ba*y,pa*l2 - ba*y  );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  vec2(sqrt(x2 + z2)        *il2 - r2, id);\n  if( sign(y)*a2*y2<k ) return  vec2(sqrt(x2 + y2)        *il2 - r1,id);\n                        return vec2((sqrt(x2*a2*il2)+y*rr)*il2 - r1,id);\n}\nvec2 opUnion( vec2 d1, vec2 d2 )\n{\n    float id;\n    float d = min(d1.x,d2.x);\n    if(d1.x < d2.x){\n        id = d1.y;\n    }else{\n        id = d2.y;\n    }\n    return vec2(d,id);\n}\n//\nvec2 scene(vec3 p){\n    vec2 sce;\n    vec3 bulidcon = vec3(.5,1.5,.5);\n    vec3 q = (p+vec3(2.,0.,7.));\n    q.xy *= rotate2d(.20);\n    sce = sdBox(q,bulidcon,2.);\n    q = (p+vec3(-2.,0.,9.));\n    q.xy *= rotate2d(.30);\n    sce = opUnion(sce,sdBox(q,bulidcon,2.));\n    q = (p+vec3(-4.,0.1,7.));\n    q.xy *= rotate2d(.40);\n    sce = opUnion(sce,sdBox(q,bulidcon,2.));\n    q = (p+vec3(6.,0.1,7.));\n    q.xy *= rotate2d(.40);\n    sce = opUnion(sce,sdBox(q,bulidcon,2.));\n    q = (p+vec3(8.,0.1,6.));\n    q.xy *= rotate2d(.10);\n    sce = opUnion(sce,sdBox(q,bulidcon,2.));\n    q = (p+vec3(-7.,0.1,6.));\n    q.xy *= rotate2d(.10);\n    sce = opUnion(sce,sdBox(q,bulidcon,2.));\n    //star\n    //theres def a better way to do this\n    int stars = 8;\n    for(int o = 0; o < stars; o++){\n        float iTime2 = iTime + hash(ivec3(o))*10.;\n            float h2 = hash(ivec3(floor(iTime2/15.)+float(o)));\n            q = p+vec3(mix(6.,-12.,h2),-10.,mix(4.,10.,float(o)/float(stars)));\n            float y = (mod(iTime2+0.*10.,15.)/1.);\n            q += vec3(y,y,0.);\n            sce = opUnion(sce,sdRoundCone(q,vec3(0.),vec3(1.,1.,0.),.1,.01,4.+clamp(0.,1.,length(q))));\n    }\n    return sce;\n}\nfloat ground(vec2 p){\n    return noise(vec3(p.x,1.,p.y))/3.;\n}\nvec2 raymarch(vec3 ro,vec3 rd){\n    float id = 0.0;\n    float dist = 0.0;\n    //ground \n    float mint = 2.2;\n    float maxt = 10.;\n    float dt = .02;\n    for(float t = mint; t < maxt; t+= dt){\n        vec3 p = ro+rd*t;\n        if(p.y < ground(p.xz)){\n            dist = t-dt/2.;\n            id = 1.;\n            break;\n        }\n        dist = t;\n    }\n    float dis2 =0.;\n    for(int i = 0; i < 46; i++){\n        vec2 depth = scene(ro+rd*dis2);\n        if(depth.x < .001){\n            if(dist > dis2 || id == 0.){id = depth.y;}\n            break;\n        }\n        dis2 += depth.x;\n    }\n    dist = min(dis2, dist);\n    return vec2(dist,id);\n}\nvec3 shade(vec2 t,vec3 rd,vec3 ro){\n    vec3 col = vec3(0.);\n    vec3 p = ro+rd*t.x;\n    float falloff = clamp(1.-distance(p,light)*.2,0.,1.);\n    if(t.y == 0.){\n        //sky\n        col = mix(vec3(0.702, 0., 0.)*.75,vec3(0.969, 0., 0.)*.75,smoothstep(0.3,.0,rd.y));\n    }else if(t.y == 1.){\n        //earth\n        col = vec3(messyNoise(p/2.))*falloff;\n    }else if(t.y >= 4.){\n        //falling stars\n        col = mix(vec3(1., 0.965, 0.361),vec3(1., 0.671, 0.239),t.y-3.9);\n    }\n        \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 RO = vec3(.0,height,2.0);\n    vec3 ta = vec3( 0.0,height, 0.0 );\n    vec3 ww = normalize( ta - RO );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 RD = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    //\n    vec2 t = raymarch(RO,RD);\n    vec3 col = shade(t,RD,RO);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}