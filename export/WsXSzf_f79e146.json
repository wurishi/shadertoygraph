{"ver":"0.1","info":{"id":"WsXSzf","date":"1551738225","viewed":303,"name":"[twitch] Glowing Gem","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/GlowingGem.glsl","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MARCH_STEPS 100\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 r) {\n  vec3 ap=abs(p)-r;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x,max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*784.523)*7894.5231);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nfloat clock(float t, float d) {\n  float g=t/d;\n  float fg = fract(g);\n  //fg = pow(fg, 4.0);\n  fg = smoothstep(0.0,1.0,fg);\n  fg = smoothstep(0.0,1.0,fg);\n  return (floor(g)+fg)*d;\n}\n\nfloat mat = 0.0;\n\nfloat piece(vec3 fp) {\n  vec3 bp = fp;\n\n  vec4 p = vec4(fp, 1.0);\n  float c = 10000.0;\n  //float t2 = curve(time,1.4);\n  for(int i=0;i<5; ++i) {\n    //float t1 = sin(time*0.1)+sin(i) + 12.5;\n    //float t2 = curve(time + i*0.1,1.4);\n    float t2 = sin(clock(time + float(i)*0.12, 2.0) * 0.3);\n    //float t1 = t2+sin(i) + 12.5;\n    float t1 = t2 + 12.5;\n    p.xz *= rot(t1);\n    p.xyz-=0.2+float(i)*0.2;\n    p *= 0.8;\n    p.zy *= rot(t1*0.7);\n    p.xyz=abs(p.xyz);\n    p.xyz-=0.1+0.1*float(i);\n\n    if(i==3) {\n      c = min(c, cyl(p.xz, 0.12));\n    }\n  }\n\n  p.xyz /= p.w;\n\n  float b = box(p.xyz, vec3(0.5,0.03,5.0)) - 0.05;\n  c = smin(c, sph(bp, 20.0), -12.0);\n  if(b<c)mat=1.0;\n  //return b;\n  return min(b,c);\n}\n\nfloat map(vec3 p) {\n\n  vec3 bp=p;\n\n  for(int i=0; i<3; ++i) {\n\n    p -= vec3(0.5,5.2,1.2)*0.2*float(i);\n    p = abs(p);\n  }\n  mat = 0.0;\n\n  float p1 = piece(p);\n\n  //float p2 = p1-80.0;\n  vec3 bsize = vec3(100.0,40.0,100.0);\n  float p2 = box(bp, bsize);\n  bp.xz*=rot(PI*0.25);\n  p2 = max(p2,box(bp, bsize));\n\n  if(p1>-p2)mat=2.0;\n  \n  return min(p1, -p2);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(vec3(map(p+off.xyy)-map(p-off.xyy), map(p+off.yxy)-map(p-off.yxy), map(p+off.yyx)-map(p-off.yyx)));\n  //return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nvoid cam(inout vec3 p) {\n  float t1 = time * 0.3 + curve(time, 1.7)*3.0;\n  t1 *= 0.5;\n  p.yz *= rot(sin(t1)*0.5);\n  p.zx *= rot(sin(t1*1.2)*1.5 + PI*1.5);\n}\n\nvec3 getcol(vec3 r) {\n\n  float bl = pow(r.x*0.5+0.5,5.0);\n  return mix(vec3(0.5,0.6,0.7),vec3(3.0,1.3,0.2), bl);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s = vec3(0,0,-33);\n  vec3 r = normalize(vec3(-uv, 0.5 + 0.3 * curve(time, 1.3)));\n  vec3 br = r;\n\n  cam(s);\n  cam(r);\n\n  vec3 col = vec3(0);\n\n  vec3 lpos = vec3(0);\n\n  vec3 p = s;\n  int i=0;\n  float prod=1.0;\n  float dd=0.0;\n  vec3 at = vec3(0.0);\n  for(; i<MARCH_STEPS; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      float curmat = mat;\n      vec3 n=norm(p);\n      vec3 l=normalize(lpos-p);\n      float fog = 1.0-float(i)/float(MARCH_STEPS);\n      float dfog = clamp(dd/50.0,0.0,1.0);\n      float fresnel = pow(1.0-abs(dot(n,r)),2.0);\n      vec3 h=normalize(l-r);\n      float back = curmat==2.0?0.0:1.0;\n      float gold = curmat==0.0?1.0:0.0;\n      vec3 bcol  = getcol(r);\n      float aodist = 0.2;\n      float ao = 1.0;//clamp(map(p+n*aodist)/aodist, 0.0, 1.0);\n      vec3 diff = mix(vec3(0.8,0.8,0.8), vec3(2.0,0.2,0.2), gold) * bcol * 2.;\n      col += back * prod * max(0.0,dot(n,l)) * fog * (0.2 + pow(max(0.0,dot(n,h)), 5.0)*0.8) * diff * ao;\n      col += back * prod * clamp(-n.y*0.7+0.3,0.0,1.0) * 0.3 * diff * ao;\n      col += prod * fresnel*0.1 * bcol * ao;\n      prod *= 0.2+fresnel*0.8;\n      //prod *= 0.8+0.2*back;\n      if(prod<0.03) break;\n      r = reflect(r, n);\n      d=0.01;\n    }\n    if(d>100.0) { i=100; break; }\n    p+=r*d;\n    dd+=d;\n    at += prod * exp(-max(1.0,d)*0.7) * getcol(r);\n  }\n\n  col += at*0.02;\n\n  col = 1.0-exp(-col*1.5);\n  col = pow(col, vec3(1.5));\n  \n  col *= pow(clamp(1.5-length(uv),0.0,1.0),3.0);\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}