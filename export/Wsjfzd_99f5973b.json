{"ver":"0.1","info":{"id":"Wsjfzd","date":"1590638700","viewed":114,"name":"Spiky Cube RayMarching","username":"AlancitoBalanza","description":"Spiky Cube RayMarching\nLeft button click to choose color\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","spiky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.);\n\n#define MAX_ITER 300\n#define MAX_DIST 10000.0\n\n#define SET_CLOSER(dst,src) if (src.distance < dst.distance) dst = src\n\n#define X vec3(1, 0, 0)\n#define Y vec3(0, 1, 0)\n#define Z vec3(0, 0, 1)\n\n\nvec3 SPIKE_COLOR; //Controlled on mouse click\n\n//Spike count per side (sweeps over time)\nfloat CYCLES;\n\n\n\n// Smooth HSV to RGB conversion (from https://www.shadertoy.com/view/MsS3Wc)\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nmat3 rotationX(float angle) {\n    vec3 u = vec3(1, 0, 0);\n    vec3 v = vec3(0, cos(angle), -sin(angle));\n    vec3 w = vec3(0, sin(angle), cos(angle));\n    return mat3(u, v, w);\n}\n\nmat3 rotationY(float angle) {\n    vec3 u = vec3(cos(angle), 0, sin(angle));\n    vec3 v = vec3(0, 1, 0);\n    vec3 w = vec3(-sin(angle), 0, cos(angle));\n    return mat3(u, v, w);\n}\n\nmat3 rotationZ(float angle) {\n    vec3 u = vec3(cos(angle), -sin(angle), 0);\n    vec3 v = vec3(sin(angle), cos(angle), 0);\n    vec3 w = vec3(0, 0, 1);\n    return mat3(u, v, w);\n}\n\nmat3 rotationMatrix(vec3 angles) {\n    return rotationZ(angles.z) * rotationY(angles.y) * rotationX(angles.x);\n}\n\n\nstruct DistanceObject {\n    float distance;\n    vec3 color;\n    int objectId;\n};\nstruct HitData {\n    vec3 color;\n    float distance;\n    int iterations;\n    vec3 position;\n    vec3 normal;\n    float incidence;\n};\n\nfloat sdSphere(vec3 pos, float rad) {\n    return length(pos) - rad;\n}\n\nfloat sdPlane(vec3 pos) {\n\treturn pos.y;\n}\n\nvec3 boxNormal(vec3 pos, vec3 b) {\n    float epsilon = 1e-3;\n    \n    vec3 abdD = min(abs(pos) / b, 1.) / 2.;\n    vec3 d = clamp(pos / b, -1., 1.)*.5;\n    \n    vec2 uv;\n    \n    vec3 u, v;\n    bool reverse = false;\n    \n    if (abdD.x > 0.5 - epsilon){\n        uv = d.yz;\n        if (d.x < 0.) {\n            reverse = true;\n        }\n        u = Y;\n        v = Z;\n    }\n    else if (abdD.y > 0.5 - epsilon){\n        uv = d.zx;\n        if (d.y < 0.) {\n            reverse = true;\n        }\n        u = Z;\n        v = X;\n    }\n    else if (abdD.z > 0.5 - epsilon){\n        uv = d.xy;\n        if (d.z < 0.) {\n            reverse = true;\n        }\n        u = X;\n        v = Y;\n    }\n    \n    if (reverse)\n\t\tuv = -uv;\n    \n    //Spike height function\n    vec2 k = abs(cos(uv * PI * CYCLES)) * cos(uv * PI);\n    \n\tfloat c = CYCLES;\n    vec2 x = uv;\n    //Derivative of spike height function\n    vec2 dH = -PI*abs(cos(c*PI*x))*sin(PI*x)-(c*PI*sin(2.*c*PI*x)*cos(PI*x))/(2.*abs(cos(c*PI*x)));\n    dH *= k.yx;\n    vec2 angles = atan(dH);\n    //angles = vec2(0., 0.);\n    \n    vec3 right = rotationMatrix(angles.x*v) * u;\n    vec3 top = rotationMatrix(-angles.y*u) * v;\n    \n    vec3 norm;\n    norm = normalize(cross(right, top));\n    if (reverse)\n    \tnorm = -normalize(cross(right, top));\n    \n    return norm;\n}\n\nDistanceObject sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    vec3 abdD = min(abs(p) / b, 1.) / 2.;\n    vec3 d = clamp(p / b, -1., 1.)*.5;\n    \n    float dist = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    \n    float height;\n    \n    // In range: (-1, 1)\n    vec2 uv;\n    \n    if (abdD.x > 0.499)\n        uv = d.yz;\n    else if (abdD.y > 0.499)\n        uv = d.xz;\n    else if (abdD.z > 0.499)\n        uv = d.xy;\n    \n    //Spike height function\n    vec2 val = abs(cos(uv * PI * CYCLES)) * cos(uv * PI);\n    \n    height = val.x * val.y * 0.3 * length(b);\n    //height = 0.;\n\n    dist -= height;\n    \n    //vec3 col = boxNormal(p, b);\n\t//vec3 col = vec3(val.x * val.y*2., 0, 0);\n    float value = val.x * val.y * 2.;\n\tvec3 col = SPIKE_COLOR * value;\n    //col = vec3(1.);\n    //return DistanceObject(dist, vec3(height*5., 0, 0), 5);\n    //return DistanceObject(dist, norm, 5);\n    return DistanceObject(dist, col, 5);\n}\n\n\nDistanceObject map(vec3 pos, vec3 rayDir) {\n\t\n    DistanceObject nearest = DistanceObject(MAX_DIST, vec3(1, 0, .5), -1);\n    \n    \n    //  WRITE OBJECTS HERE\n    //SET_CLOSER(nearest, DistanceObject(sdSphere(pos - vec3(4, 0, 0), 1.), vec3(1), 3));\n    \n    pos = mod(pos + 2., 4.) - 2.;\n    //pos = pos;\n    \n    //if (length(pos) < 5.) {\n        DistanceObject box = sdBox(pos, vec3(1, 1, 1));\n        SET_CLOSER(nearest, box);\n    //}\n    \n    //SET_CLOSER(nearest, DistanceObject(sdPlane(pos + vec3(0, 10, 0)), vec3(0, 1, 0), 2));\n    \n    \n    return nearest;\n}\n\n\nvec3 calculateNormal(int objectId, vec3 position) {\n    /*\n    switch (objectId) {\n    \tcase 2: //plane\n        \treturn vec3(0, 1, 0);\n        case 3: //sphere\n        \treturn normalize(position - vec3(4, 0, 0));\n        case 5: //cube\n\t*/\n\t\t    position = mod(position + 2., 4.) - 2.;\n        \treturn boxNormal(position, vec3(1, 1, 1));\n    /*\n        default:\n        \treturn vec3(1, 0, 0);\n    }\n*/\n}\n\n\nHitData render(vec3 pos, vec3 rayDir) {\n\tDistanceObject obj;\n    int iter;\n    float dist = 0.;\n    for (int i = 0; i < MAX_ITER; i++) {\n    \tobj = map(pos, rayDir);\n        \n        obj.distance *= 0.3;\n        \n        dist += obj.distance;\n        pos += rayDir * obj.distance;\n        \n        if (obj.distance < .0001) {\n        \titer = i;\n            break;\n        }\n    }\n    \n    if (iter == MAX_ITER) {\n    \tdist = MAX_DIST;\n        obj.color = vec3(0.);\n    }\n    \n    vec3 normal = calculateNormal(obj.objectId, pos);\n    //normal = rotationMatrix(vec3(PI/2.,0,0)) * -rayDir;\n    \n    float incidence = dot(-normal, rayDir) / (length(normal)*length(rayDir));\n    \n    //incidence *= 1000000.0;\n    //incidence = min(incidence, 1.);\n    /*\n    if (obj.objectId == 5)\n        incidence=1.;\n    */\n    HitData res = HitData(obj.color, dist, iter, pos, normal, incidence);\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CYCLES = (sin(iTime) * 0.5 + 0.5) * 7.0 + 1.0;\n    \n\tSPIKE_COLOR = hsv2rgb_smooth(vec3(iMouse.x / iResolution.x, 1., 1.));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 coord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec2 cameraAngle = vec2((sin(iTime)*0.3+0.8)*-PI/2.0*0.5, iTime);\n    //cameraAngle.x = -iMouse.y / 100.0 + (PI / 2.);\n    //cameraAngle.y = iMouse.x / 100.0;\n    mat3 cameraMatrix = rotationMatrix(vec3(cameraAngle, 0));\n    \n    vec3 cameraPosition = cameraMatrix * -vec3(0, 0, 1) * 4.0;\n    \n    \n    vec3 direction = cameraMatrix * vec3(coord.x, coord.y, (sin(iTime*3.)*.5+.5)*2.+1.0);\n    direction = normalize(direction);\n\n    vec3 col;\n    \n    HitData data = render(cameraPosition, direction);\n    \n    col = data.color;\n    //col *= inversesqrt(data.distance);\n    //col *= float(data.iterations) / 10.0;\n    //col *= calculateIncidence(cameraPosition, direction);\n   \tcol *= data.incidence;\n    col = mix(col, vec3(0.1), clamp(sqrt(data.distance / 100.0), 0., 1.));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}