{"ver":"0.1","info":{"id":"sdX3RH","date":"1616695017","viewed":95,"name":"Fork am_produit anthonybat 703","username":"anthonybattel","description":"produit scalaire ex. 2","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ateliermaths"],"hasliked":0,"parentid":"3tVBWt","parentname":"am_produitscalaire_ex2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////\n// Exercice : retourner la distance entre le point m et le segment AB\n/////////////////////////////////////////////////////////////////////\nfloat pointToSegmentDistance(vec3 m, vec3 A, vec3 B) {\n    vec3 AB = B - A;\n    float L = dot (AB, m - A) / length(AB);\n    if(L < 0.) {\n        return length(A - m); \n    } \n    else if (L > length(AB)){\n        return length(B - m); \n    }\n    else { \n        vec3 mprim = A + normalize(AB) * L; \n        return  length(m - mprim);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////\n// Private\n/////////////////////////////////////////////////////////////////////\nfloat map(vec3 m) {\n    \n    float anim = iTime;\n    \n    vec3 A = vec3(cos(anim)*5., 0, 20.0+sin(anim)*5.);\n    vec3 B = A + (vec3(0, 0, 20)- A)*2.;    \n    \n    float radius = 3.0;\n    \n    return pointToSegmentDistance(m, A, B) - radius;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvec4 iridescent(in vec3 ray, in vec3 m, in vec3 normal) {\n\n   \tvec3 pos = m;\n    vec3 ref = reflect(ray, normal);\n    vec3 lig = normalize(vec3(.5,1,-.5));\n    vec3 dome = vec3(0,1,0);\n    vec3 eye = vec3(0,0,-1);\n\n    vec3 perturb = sin(pos * 1.);\n    vec3 color = spectrum( dot(normal + perturb * .05, eye) * 2.);\n\n    float specular = clamp(dot(ref, lig), 0., 1.);\n    specular = pow((sin(specular * 20. - 3.) * .5 + .5) + .1, 32.) * specular;\n    specular *= .1;\n    specular += pow(clamp(dot(ref, lig), 0., 1.) + .3, 8.) * .1;\n\n    float shadow = pow(clamp(dot(normal, dome) * .5 + 1.2, 0., 1.), 3.);\n    color = color * shadow + specular;\n\n    return vec4(color, 1.0);\n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 p, in vec3 normal, in vec3 lightSource) {\n    \n    vec3 light = normalize(p-lightSource);\n    vec3 light2 = normalize(vec3(-1,1,-8));    \n    \n    float distorsion = -0.6;\n    float diffuse = clamp(dot(normal, light2), 0.0, 1.0) * 1.;\n    vec3 outlight = normalize(light2 + normal * distorsion);\n    float scatter = clamp(dot(-ray, outlight), 0.0, 1.0) * 0.5;\n\n    vec4 outter_color = vec4(121, 179, 255, 255)/255.;    \n    vec4 inner_color  = vec4(0, 179, 255, 255)/255.;\n\n    vec3 cp = (p - vec3(0., 0.0, +20.0)) / 20.0;\n    outter_color = vec4(normalize(vec3(cp.x, 1.0-cp.z, cp.x)), 1.0);\n    \n    outter_color = vec4(normalize(vec3(1.0+cp.x, cp.y*10.0, -cp.z*10.)), 1.0);\n    inner_color = outter_color;\n    \n    vec4 solid_color = outter_color * (0.15+diffuse) + inner_color * scatter;        \n    \n    vec3 ref = reflect(light2, normal);\n    float specular = pow(clamp(dot(ref, ray), 0.0, 1.0), 60.0);\n    \n    vec4 irri = iridescent(ray, p, normal);\n\n    return mix(solid_color, irri, 0.75);\n    \n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n\n    const float zFar  = 40.0;\n\n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n    for(int i = 0; i<200; i++) {\n        m = origin + ray * marchingDist;    \n    \tfloat dist = map(m);\n        if(dist < 0.001) {\n            return true;\n        }\n        else {\n            marchingDist += dist * 0.75;\n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n\treturn false;    \n}\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\nvec4 run(in vec2 fragCoord) {\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), 1.);\n    vec3\teye\t\t\t\t= vec3(0.0, 1.25, -0.185);\n    vec3\tray\t\t\t\t= normalize(viewportCoord);\n    vec3\tp;\n    \n    vec3\tlightSource\t\t= vec3(-20.0, 0.0, 40.0);\n    \n    if(rayMarching(eye, ray, p)) {\n        vec3 normal = computeNormal(p);\n        return computeColor(ray, p, normal, lightSource);\n    }\n    else {\n        return vec4(0.5, 0, 1.0, 1.0);  \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = run(fragCoord); \n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}