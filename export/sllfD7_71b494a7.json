{"ver":"0.1","info":{"id":"sllfD7","date":"1651001957","viewed":584,"name":"Rolling Cubes Army","username":"Bleuje","description":"I was checking out if I could make a raymarched rolling cube, but added more stuff by the way.","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n\n#define PI 3.14159\n#define TAU (2.*PI)\n#define duration 0.9\n#define AA true\n\nfloat time;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\nfloat cubeSize; // cube size\nfloat spacing = 3.6;\nfloat delayFactor = 0.28;\n\nvec3 rollPosition(vec3 q,float param,float delay)\n{\n    param -= delay;\n\n    float stp = floor(param);\n    float transition = param-stp;\n    \n    transition = pow(transition,3.0);\n    \n    q -= vec3(0.5*cubeSize,0.,0.);\n    q -= vec3(2.0*cubeSize*(stp-param),0.,0.);\n    q -= vec3(cubeSize,-cubeSize,0.);\n    q.xy *= rot(PI/2.0*transition);\n    q += vec3(cubeSize,-cubeSize,0.);\n    q.xy *= rot(-PI/2.0*stp);\n\n    return q;\n}\n\nstruct MapData\n{\n    float typeId;\n    float dist;\n    vec2 uv;\n    vec2 cubePos;\n};\n\n\nMapData map(vec3 p) {\n    MapData res;\n\n    vec3 q = p;\n\n    float repetitionDistance = spacing*cubeSize;\n    p.xz = mod(p.xz + repetitionDistance*.5, repetitionDistance) - repetitionDistance*.5;\n    \n    // block indices\n    vec2 qi = floor((q.xz+0.5*vec2(repetitionDistance))/repetitionDistance);\n    float delay = delayFactor*length(qi);\n    \n    p = rollPosition(p, time, delay);\n\n    float boxDistance = sdBox(p,vec3(cubeSize));\n    float waveDistance = max(0.015+0.02*length(q),abs(mod(length(0.94*q/cubeSize/spacing)-time/delayFactor+0.53/delayFactor,1.0/delayFactor)-2.0));\n    float groundDistance = q.y+cubeSize;\n    \n    if(groundDistance<boxDistance) // we're closer to the ground\n    {\n        res.typeId = 0.;\n        res.dist = min(groundDistance,waveDistance);\n    }\n    else // we're closer to a cube\n    {\n        vec2 uv;\n        // looking for cube face uv\n        if(abs(p.x)<=cubeSize&&abs(p.y)<=cubeSize)\n            uv = p.xy;\n        else if(abs(p.y)<=cubeSize&&abs(p.z)<=cubeSize)\n            uv = p.yz;\n        else\n            uv = p.xz;\n        \n        res.typeId = 1.;\n        res.dist = min(boxDistance,waveDistance);\n        res.uv = uv;\n        res.cubePos = qi;\n    }\n    \n    return res;\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n    \n    time = mod(iTime/duration,4.0);\n    cubeSize = 0.18+0.1*cos(0.5*iTime);\n\n\tvec3 ro = vec3(3.4+1.1*cos(0.4*iTime), 2., -4.);\n\tvec3 ta = vec3(0., 0., 0.);\n\tvec3 rd;\n\n\trd = camera(ro, uv, ta);\n    \n    float rng = hash12(100.*q + 123.*time);\n\n\tvec3 p;\n\tMapData res;\n\tfloat ri, t = 0.;\n\tfor (float i = 0.; i < 1.; i += 1.0/60.0) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tres = map(p);\n\t\tif (res.dist<.001) break;\n\t\tt += res.dist*(0.9+0.1*rng);\n\t}\n    \n    float delay = 0.9*delayFactor*length(p)/cubeSize/spacing;\n    float waveFactor = pow(abs(sin(PI*(time-delay-0.6))),3.5);\n\n    vec3 col;\n    \n    if(res.typeId < 0.5) // floor case\n    {\n        // color brightness based on number of raymarching iterations, distance and wave\n        col = vec3(pow(ri,3.0)/(t*t)*700.0)*.2*(0.5+2.0*waveFactor);\n        float ll = 0.02;\n        float f = smoothstep(ll,0.65*ll,mod(abs(p.z),spacing*cubeSize));\n        f += smoothstep(ll,0.5*ll,mod(abs(p.x+2.0*cubeSize*time),spacing*cubeSize));\n        col += f*vec3(1.0);\n    }\n    else // cube case\n    {\n        vec2 uuvv = res.uv;\n        if(mod(res.cubePos.x+res.cubePos.y,2.0)<0.5) uuvv *= rot(PI/2.0); // alternating face rotation\n        \n        // cube edges factor\n        float squareDistance = max(abs(uuvv.x),abs(uuvv.y));\n        float f_edges = 0.1+1.4*smoothstep(0.88*cubeSize,0.93*cubeSize,squareDistance);\n        \n        // factor for stripes on cube faces\n        float a = 1.0;\n        float b = 0.75;\n        float v = clamp((mod(3.0*uuvv.x/cubeSize,a)-b)/(a-b),0.,1.);\n        float f_stripes = 1.5*sin(PI*v);\n        \n        // brightness with number of raymarching iterations, distance and previous factors\n        col = vec3(pow(ri,1.7)/(t*t)*100.0)*max(f_edges,f_stripes);\n        \n        // brighter on wave\n        col *= (0.75+1.5*waveFactor);\n    }\n\n\tfragColor = vec4(col, 1.);\n}\n\n// smart AA, from FabriceNeyret2\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if(AA)\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"}]}