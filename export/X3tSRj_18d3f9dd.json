{"ver":"0.1","info":{"id":"X3tSRj","date":"1719275278","viewed":39,"name":"First Perlin Noise Grad","username":"L1x3N","description":"One of my first Perlin Noise GLSL shaders.\nThe multiple colors come from the colors from the blend (in COLORS_VALUES) that are rounded, creating yellow and deep blue with the others.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlin","colorful","scroll","seamless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3[] COLORS_VALUES = vec3[](vec3(1., 0., 0.), vec3(0.5, 1., 0.), vec3(0., 1., 1.), vec3(0.5, 0., 1.), vec3(1., 0., 0.));\nconst float[] COLORS_POS = float[](0., 1.f / 4., 2.f / 4., 3.f / 4., 1.);\n\nconst float SCROLL_SPEED = 1.;\nconst bool GRADIENT_BLEND_MODE = true;\nconst bool ASPECT_RATIO = true;\n\nvec2 randomGradient(vec2 p) {\n\tp = p + 0.1;\n\tfloat x = dot(p, vec2(123.4, 234.5));\n\tfloat Y = dot(p, vec2(432.1, 987.6));\n\tvec2 gradient = sin(vec2(x, Y)) * 26438.799;\n\n\treturn sin(gradient);\n\t// return sin(gradient + iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Setup UVs\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif(ASPECT_RATIO)\n\t\tuv.x *= iResolution.x / iResolution.y;\n        \n\tuv.x += iTime / 4.f * SCROLL_SPEED;\n\tfloat nbUVs = 5.;\n\n\tvec2 gridUv = fract(uv * nbUVs), gridId = floor(uv * nbUVs);\n\t// vec3 myColor = vec3(gridUv, 0);\n\n\t// Coins de la grille\n\tvec2 bg = gridId;\n\tvec2 bd = gridId + vec2(1, 0);\n\tvec2 hg = gridId + vec2(0, 1);\n\tvec2 hd = gridId + vec2(1, 1);\n\n\t// Dégradés de la grille\n\tvec2 gradBg = randomGradient(bg);\n\tvec2 gradBd = randomGradient(bd);\n\tvec2 gradHg = randomGradient(hg);\n\tvec2 gradHd = randomGradient(hd);\n\n\t// Distance du pixel actuel aux coins \n\tvec2 pixDistBg = gridUv;\n\tvec2 pixDistBd = gridUv - vec2(1, 0);\n\tvec2 pixDistHg = gridUv - vec2(0, 1);\n\tvec2 pixDistHd = gridUv - vec2(1, 1);\n\n\t// Produit scalaire du dégradé à la distance du pixel aux coins\n\tfloat scBg = dot(gradBg, pixDistBg);\n\tfloat scBd = dot(gradBd, pixDistBd);\n\tfloat scHg = dot(gradHg, pixDistHg);\n\tfloat scHd = dot(gradHd, pixDistHd);\n\n\t// Smoothstep\n\tgridUv = smoothstep(0., 1., gridUv);\n\n\t// Lerp des 4 produits scalaires\n\tfloat b = mix(scBg, scBd, gridUv.x);\n\tfloat h = mix(scHg, scHd, gridUv.x);\n\tfloat perlin = mix(b, h, gridUv.y);\n\n\tvec3 myColor;\n\n\t// vec3 myColor = vec3(perlin); // Perlin noise\n\t// vec3 myColor = vec3(abs(perlin)); // Billow noise\n\t// vec3 myColor = vec3(pow(1.f - abs(perlin), 2.)); // Ridged noise\n\n\t// perlin = pow(1.f - abs(perlin), 2.) - 0.25; // Ridged noise\n\n\tint colorPosIndex;\n\tfor(colorPosIndex = 0; colorPosIndex < (COLORS_POS.length()); colorPosIndex ++) {\n\t\tif(fract(perlin) < COLORS_POS[colorPosIndex])\n\t\t\tbreak;\n\t}\n\n\tif(GRADIENT_BLEND_MODE) {\n\t\tfloat colorUv = (fract(perlin) - COLORS_POS[colorPosIndex - 1]) / (COLORS_POS[colorPosIndex] - COLORS_POS[colorPosIndex - 1]);\n\t\tmyColor = mix(COLORS_VALUES[colorPosIndex - 1], COLORS_VALUES[colorPosIndex], colorUv);\n\t} else {\n\t\tmyColor = COLORS_VALUES[colorPosIndex];\n\t}\n\n\t// myColor = vec3(perlin);\n\t// myColor = round(myColor);\n    myColor = (myColor-.5) / fwidth(myColor); // FabriceNeyret2's comment\n\n\n\tfragColor = vec4(myColor, 1.);\n}","name":"Image","description":"","type":"image"}]}