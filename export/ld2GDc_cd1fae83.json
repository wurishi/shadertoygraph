{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI 3.14159265359\n#define MAX_ITER 128\n#define MAX_ITER_INTERNAL 0\n#define MAX_ITER_SHADOW 32\n#define MAX_DIST_SHADOW 10.0\n#define MIN_DIST_SHADOW 0.1\n#define MAX_DIST 1000.0\n#define MIN_DIST 0.01\n#define FOV 0.75\n#define SPECULAR 5.0\n#define SAMPLE_RADIUS 0.001\n#define PENUMBRA 2.0\nstruct ray{\n\tvec4 c;\n\tvec3 p;\n\tvec3 d;\n\tvec3 n;\n\tfloat t;\n\tint i;\n};\nstruct light{\n\tvec4 c;\n\tvec3 p;\n};\nlight l=light(\n\tvec4(0.5),\n\tvec3(0.0,-5.0,5.0)\n);\nvec4 a=vec4(0.5);\nfloat s;\nvoid srand(vec2 p){\n\ts=sin(dot(p,vec2(423.62431,321.54323)));\n}\nfloat rand(){\n\ts=fract(s*32322.65432+0.12333);\n\treturn abs(fract(s));\n}\nmat3 rotx(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\nmat3 roty(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\nmat3 rotz(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\nmat3 rot(vec3 z,float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat b=1.0-c;\n\treturn mat3(\n\t\tb*z.x*z.x+c,b*z.x*z.y-z.z*s,b*z.z*z.x+z.y*s,\n\t\tb*z.x*z.y+z.z*s,b*z.y*z.y+c,b*z.y*z.z-z.x*s,\n\t\tb*z.z*z.x-z.y*s,b*z.y*z.z+z.x*s,b*z.z*z.z+c);\n}\nmat2 rot2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(\n\t\tc,-s,\n\t\ts, c);\n}\nfloat expstep(float x,float k,float n){\n\treturn exp(-k*pow(x,n));\n}\nfloat smin(float a,float b,float k){\n\tfloat h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\nfloat sphere(inout ray r){\n    float d = length(r.p - vec3(0.1));\n    r.c = vec4(1.0);\n    r.i=MAX_ITER_INTERNAL+1;\n    return d;\n}\nfloat dome(inout ray r){\n\tfloat d=dot(r.p,vec3(0.0,0.0,1.0))+0.5;\n\td=smin(d,50.0-length(r.p),10.0);\n\tif(d<0.0){\n\t\tfloat l=length(r.p);\n\t\tr.c=vec4(1.0);\n\t\tr.i=MAX_ITER_INTERNAL+1;\n\t}\n\treturn d;\n}\nfloat grid(inout ray r)\n{\n    #define GRID_SIZE 10.0\n    #define GRID_WIDTH 0.1\n    float xmod=mod(r.p.x,GRID_SIZE);\n    float ymod=mod(r.p.y,GRID_SIZE);\n    float zmod=mod(r.p.z,GRID_SIZE);\n    \n    float xd=min(xmod,GRID_SIZE-xmod);\n    float yd=min(ymod,GRID_SIZE-ymod);\n    float zd=min(zmod,GRID_SIZE-zmod);\n    \n    float d=min(xd,min(yd,zd))-GRID_WIDTH;\n    return d;\n}\n\nfloat dist(inout ray r){\n\tfloat d=MAX_DIST;\n\td=min(d,dome(r));\n    //d=min(d,sphere(r));\n\t//d=min(d,grid(r));\n\treturn d;\n}\nvoid normal(inout ray r){\n\tfloat d=dist(r);\n\tvec3 n=vec3(SAMPLE_RADIUS,0.0,0.0);\n\tray r0=r;\n\tray r1=r;\n\tray r2=r;\n\tr0.p+=n.xyy;\n\tr1.p+=n.yxy;\n\tr2.p+=n.yyx;\n\tr.n=normalize(vec3(dist(r0)-d,dist(r1)-d,dist(r2)-d));\n}\nvec4 ambient(ray r){\n\treturn r.c*a;\n}\nvec4 diffuse(ray r){\n\tvec3 v=l.p-r.p;\n\treturn clamp(r.c*l.c*dot(r.n,normalize(v)),0.0,1.0);\n}\nvec4 specular(ray r){\n\tfloat d=length(l.p-r.p);\n\tvec3 v=normalize(l.p-r.p);\n\treturn l.c*max(pow(dot(v,reflect(r.d,r.n)),SPECULAR),0.0);\n}\nvec4 shadow(ray r){\n\tfloat s=1.0;\n\tfloat t=MIN_DIST_SHADOW;\n\tfor(int i=0;i<MAX_ITER_SHADOW;i++){\n\t\tray tmp=r;\n\t\ttmp.p+=r.d*t;\n\t\tfloat h=dist(tmp);\n\t\tif(h<MIN_DIST)return vec4(0.0);\n\t\ts=min(s,PENUMBRA*h/t);\n\t\tt+=h;\n\t\tif(t>MAX_DIST_SHADOW)break;\n\t}\n\treturn vec4(1.0)*s;\n}\nvec4 trace(inout ray r){\n\tr.c=vec4(1.0);\n\tfor(int i=0;i<MAX_ITER;i++){\n\t\tfloat d=dist(r);\n\t\tif(r.i>MAX_ITER_INTERNAL)break;\n\t\tr.p+=r.d*max(d,MIN_DIST);\n\t}\n\tnormal(r);\n\tray tmp=r;\n\ttmp.d=normalize(l.p-r.p);\n\ttmp.p-=2.0*MIN_DIST*r.d;\t\n\treturn ambient(r)+min(max(diffuse(r),specular(r)),shadow(tmp));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=iTime;\n\tfloat r=iResolution.x/iResolution.y;\n\tvec2 m=vec2(\n\t\t(iMouse.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(iMouse.y-iResolution.y/2.0)/iResolution.y);\n\tvec2 s=vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*r,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\t\n\tvec3 l=vec3(0.0,0.0,0.0);\n\tvec3 tmp=vec3(2.0,0.0,0.0);\n\ttmp*=roty((PI*m.y)/4.0-PI/8.0);\n\ttmp*=rotz(2.0*PI*m.x);\n\tvec3 e=l+tmp;\n\tvec3 u=vec3(0.0,0.0,1.0);\n\tvec3 d=normalize(l-e);\n\tvec3 h=normalize(cross(d,u));\n\tvec3 v=normalize(cross(h,d));\n\tfloat f=0.75;\n\td*=rot(v,FOV*s.x);\n\td*=rot(h,FOV*s.y);\n\tray a=ray(vec4(0.0),e,d,vec3(0.0),t,0);\n\tfragColor=trace(a);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2GDc","date":"1394829969","viewed":309,"name":"Blank Framework","username":"Justaway","description":"Blank framework for the raymarching neophyte.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}