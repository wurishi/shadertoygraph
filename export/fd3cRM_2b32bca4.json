{"ver":"0.1","info":{"id":"fd3cRM","date":"1653157134","viewed":155,"name":"Eye shader tutorial","username":"boomji","description":"This shader try's to deconstruct the eye shader by Inigo Quilez and also by learning from The book of shaders.\n\nhttps://www.youtube.com/watch?v=emjuqqyq_qc\nhttps://thebookofshaders.com/10/\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fbm","eye","parallaxmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n// We want to create the illusion of randomness so we get some pseudo random numbers.\n// The fract function gives fractional values in between 0 and 1\n// If you multyply the result by high values we get nubers that can look random\n// https://thebookofshaders.com/10/\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453); \n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\n\n// Fractal Browanian motion. 3 steps \n//1.Add noise octave 2. decrease amplitude of each octave 3 increase frequency\n// 1.The idea is to keep adding octaves of noise (via 'f+= ) ,decreasing amplitude and increasing frequency \nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); // f+= amp * noise(p) adds the first octave of noise\n    p = m*p*2.02;            // Then increase frequency by increasing p . a simpler eg p*=2.02\n    f += 0.25000*noise( p ); // add another octave of noise but reduce the amplitude \n    p = m*p*2.03;            // Increase the frequency again a simpler eg p*=2.02\n    f += 0.12500*noise( p ); // so on and so forth...\n    p = m*p*2.01;\n    f += 0.06250*noise( p ); \n    p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Remap coord going from 0 - 1 to -1 to 1\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q; // 2 * q = uv going from 0 to 2. Then subtracting -1 brings in the range of -1 to 0 to 1\n    p.x *= iResolution.x/iResolution.y; // we want our eye to be round and not oval due to pixel aspect stretching.So multyply by correct aspect \n    \n    float freq  = 1.0; // increase for coarser noise\n    float f  = noise(p * freq);  // simple noise\n    //float f  = fbm(p * freq); // perlin like noise \n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(f,f,f);\n\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}