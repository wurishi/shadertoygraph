{"ver":"0.1","info":{"id":"Nlcyz7","date":"1659448688","viewed":214,"name":"RayMarching Penis","username":"ostapader","description":"This is an art inspired by ArtOfCode Youtube channel. During the creation of this art I was thinking about my friend  from work, Dima.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define MIN_DIST 0.0001\n#define MAX_STEPS 100\n\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    return length(p - c) - r;\n}\n\nfloat sdTorus(vec3 p, vec3 center, vec2 rs) {\n    float verticalDist = p.y - center.y;\n    float horizontalDist = length(center.xz - p.xz) - rs.x;\n    float dist = sqrt(verticalDist*verticalDist + horizontalDist*horizontalDist);\n    return dist - rs.y;\n    \n}\n\nfloat sdBox(vec3 p, vec3 center, vec3 size) {\n    vec3 normP = p - center;\n    return length(max(abs(normP) - size, 0.));\n}\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n//    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    float d = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5)*length(ab);\n    float e = length(max(vec2(d, y), 0.));\n    return e;\n}\n\nfloat getDist(vec3 p) {\n    vec4 sphere1 = vec4(0., 0.3, 4., 0.5);\n    vec4 sphere2 = vec4(0., 0.3, 4., 0.5);\n    sphere1.xz += vec2(sin(iTime), cos(iTime))*0.8;\n    sphere2.xz += -1.*vec2(sin(iTime), cos(iTime))*0.8;\n    \n    float floorDist = p.y;\n    float sphereDist1 = length(sphere1.xyz - p) - sphere1.w;\n    float sphereDist2 = length(sphere2.xyz - p) - sphere2.w;  \n\n\n    vec3 lowCenter = vec3(0., 0., 4.);\n    vec3 topCenter = vec3(0., 2., 4.);\n//    lowCenter.xz += offset;\n//    topCenter.xz += offset;\n    float capsuleDist = sdCapsule(p, lowCenter, topCenter, .5);\n    \n    vec3 torusCenter = vec3(0., 2., 4.);\n    torusCenter.y += sin(iTime);\n//    torusCenter.xz += offset;\n    float torusDist = sdTorus(p, torusCenter, vec2(0.7, .2));\n//    float boxDist = sdBox(p, vec3(-2., 1., 5.), vec3(1.));\n\n\n    \n\n    \n    float resDist = min(floorDist, torusDist);\n    resDist = min(resDist, sphereDist1);\n    resDist = min(resDist, sphereDist2);\n    resDist = min(resDist, capsuleDist);\n//    resDist = min(resDist, boxDist);\n//    resDist = min(resDist, cylinderDist);\n    \n    return resDist;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for (int i=0; i<MAX_STEPS; ++i) {\n        vec3 p = ro + rd*d;\n        float step = getDist(p);\n        d += step;\n        if (d < MIN_DIST || d > MAX_DIST) break;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    \n    vec3 normal = d - vec3(getDist(p - e.xyy),\n                           getDist(p - e.yxy),\n                           getDist(p - e.yyx));\n    return normalize(normal);\n}\n\n\nfloat getLight(vec3 ro, vec3 rd) {\n\n    \n    vec3 lightSource = vec3(0., 3., 2.);\n    lightSource += vec3(sin(iTime), 0., cos(iTime))*2.;\n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 n = getNormal(p);\n    vec3 l = normalize(lightSource - p);\n    \n    float light = clamp(dot(n, l), 0., 1.);\n    float light_dist = rayMarch(p+n*.05, l);\n    if (light_dist < length(lightSource - p)) light *= .3;\n    \n    return light;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    float zoom = 1.;\n    \n    vec3 ro = vec3(0., 1., 0.);\n    \n    vec3 lookAt = vec3(0., 1., 4.);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = normalize(i - ro);\n    \n        \n    float light = getLight(ro, rd);\n    col = vec3(light);\n    \n    fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"}]}