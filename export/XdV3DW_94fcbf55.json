{"ver":"0.1","info":{"id":"XdV3DW","date":"1454523120","viewed":1280,"name":"Emanating Radial Glow","username":"vamoss","description":"Good for glow effects","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["noise","planet","glow","solar","wind"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\n//Addapted from: tholzer\n//https://www.shadertoy.com/view/4tsXRS\n\n//--------------------------------------------------------------------\n// Shader: burn\n// Yuldashev Mahmud Effect took from shaderToy mahmud9935@gmail.com\n// original:  http://glslsandbox.com/e#26733.0\n//--------------------------------------------------------------------\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\tuv *= res;\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+1., res))*s;\n\tvec3 f = fract(uv); \n\tf = f*f*(3.0-2.0*f);\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 burn (vec2 p, float size) \n{\n\tfloat color1 = size*4.-3.*length(2.5*p);\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\tfor(int i = 1; i <= 3; i++)\n\t{\n\t\tfloat power = exp2(float(i));\n\t\tcolor1 += 0.2*(1.5 / power) * snoise(coord + vec3(0.,-time*.05, -time*.01), power*16.);\n\t}\n\tcolor1 *= 0.6;\n\treturn vec3( color1);\n}\n\n//--------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color = vec3(0.3, 0.8, 1.0);\n  float ignoreInner = 0.3;\n  float size = 1.;\n    \n  vec2 R = resolution.xy;\n  vec2 p = (fragCoord.xy - .5 * R) / R.y;\n    \n  if(length(p) < ignoreInner) {\n      fragColor = vec4(0.0);\n      return;\n  }\n  vec3 color2 = burn(p, size);\n  fragColor = vec4( color2*color*0.7, 1.0);\n}\n\n/*\n//Unity3D Version\nShader \"Vamoss/Glow\"\n{\n\tProperties\n\t{\n\t\t_Color(\"Main Color (A=Opacity)\", Color) = (1, 1, 1, 1)\n\t\t_Size(\"Size\", float) = 4\n\t\t_Vel(\"Velocity\", float) = .05\n\t\t_Crop(\"Crop\", float) = 0.3\n\t}\n\tSubShader\n\t{\n\t\tTags { \n\t\t\t\"RenderType\"=\"Transparent\"\n\t\t\t\"Queue\" = \"Transparent+10\"\n\t\t\t\"IgnoreProjector\" = \"True\"\n\t\t\t\"PreviewType\" = \"Plane\"\n\t\t}\n\n\t\tCull Off\n\t\tLighting On\n\t\tZWrite Off\n\t\tZTest On\n\t\tBlend SrcAlpha OneMinusSrcAlpha\n\n\t\tLOD 100\n\n\t\tPass\n\t\t{\n\t\t\tCGPROGRAM\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\t\t\t\n\t\t\t#include \"UnityCG.cginc\"\n\n\t\t\tfixed4 _Color;\n\t\t\tfloat _Size;\n\t\t\tfloat _Vel;\n\t\t\tfloat _Crop;\n\n\t\t\tstruct appdata\n\t\t\t{\n\t\t\t\tfloat4 vertex : POSITION;\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t};\n\n\t\t\tstruct v2f\n\t\t\t{\n\t\t\t\tfloat2 uv : TEXCOORD0;\n\t\t\t\tfloat4 vertex : SV_POSITION;\n\t\t\t};\n\t\t\t\n\t\t\tv2f vert (appdata v)\n\t\t\t{\n\t\t\t\tv2f o;\n\t\t\t\to.vertex = mul(UNITY_MATRIX_MVP, v.vertex);\n\t\t\t\to.uv = v.uv;\n\t\t\t\treturn o;\n\t\t\t}\n\n\n\t\t\t//--------------------------------------------------------------------\n\t\t\t// Shader: SolarWind\n\t\t\t// https://www.shadertoy.com/view/4tsXRS\n\t\t\t//--------------------------------------------------------------------\n\t\t\tfloat snoise(float3 uv, float res)\n\t\t\t{\n\t\t\t\tconst float3 s = float3(1e0, 1e2, 1e3);\n\t\t\t\tuv = uv * res;\n\t\t\t\tfloat3 uv0 = floor(fmod(uv, res))*s;\n\t\t\t\tfloat3 uv1 = floor(fmod(float3(uv.x + 1.0, uv.y + 1.0, uv.z + 1.0), float3(res, res, res)))*s;\n\t\t\t\tfloat3 f = frac(uv);\n\t\t\t\tf = f*f*(3.0 - 2.0*f);\n\t\t\t\tfloat4 v = float4(uv0.x + uv0.y + uv0.z, uv1.x + uv0.y + uv0.z,\n\t\t\t\t\tuv0.x + uv1.y + uv0.z, uv1.x + uv1.y + uv0.z);\n\t\t\t\tfloat4 r = frac(sin(v*1e-1)*1e3);\n\t\t\t\tfloat r0 = lerp(lerp(r.x, r.y, f.x), lerp(r.z, r.w, f.x), f.y);\n\t\t\t\tr = frac(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\t\t\t\tfloat r1 = lerp(lerp(r.x, r.y, f.x), lerp(r.z, r.w, f.x), f.y);\n\t\t\t\treturn lerp(r0, r1, f.z)*2. - 1.;\n\t\t\t}\n\n\t\t\tfloat3 burn(float2 p)\n\t\t\t{\n\t\t\t\tfloat color1 = _Size - 3.*length(2.5*p);\n\t\t\t\tfloat3 coord = float3(atan2(p.y, p.x) / 6.2832 + .5, length(p)*.4, .5);\n\t\t\t\tfor (int i = 1; i <= 3; i++)\n\t\t\t\t{\n\t\t\t\t\tfloat power = pow(2.0, float(i));\n\t\t\t\t\tcolor1 += 0.2*(1.5 / power) * snoise(coord + float3(0., -_Time.y*_Vel, -_Time.y*_Vel/5.0), power*16.);\n\t\t\t\t}\n\t\t\t\tcolor1 = color1 * 0.6;\n\t\t\t\treturn float3(color1, color1, color1);\n\t\t\t}\n\n\t\t\tfixed4 frag(v2f i) : SV_Target\n\t\t\t{\n\t\t\t\tfloat2 p = i.uv.xy - 0.5;\n\t\t\t\tif (length(p) < _Crop) return fixed4(0.0, 0.0, 0.0, 0.0);\n\t\t\t\tfloat3 brn = burn(p);\n\t\t\t\treturn fixed4(brn*_Color*0.7, brn.r*brn.g*brn.b);\n\t\t\t}\n\n\t\t\tENDCG\n\t\t}\n\t}\n}\n*/","name":"Image","description":"","type":"image"}]}