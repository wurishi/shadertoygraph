{"ver":"0.1","info":{"id":"3ltGD7","date":"1588993295","viewed":137,"name":"Lighting blob in 3d","username":"yp3y5akh0v","description":"Lighting blob in 3d","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_STEPS 100\n#define EPS 0.001\n#define t iTime\n\nstruct Light {\n    vec3 p;\n    float r;\n    vec3 c;\n} light;\n\nstruct RM {\n    float sdf;\n    float atm;\n};\n    \nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinder(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat plane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat SceneSdf(vec3 p) {\n    float plane = plane(p, -5.0);\n    float dcBox1 = max(box(p - vec3(0., 1., 0.), vec3(1., 0.1, 1)), -cylinder(p, 0.5));\n    float dcBox2 = max(box(p - vec3(0., 0., 0.), vec3(1., 0.1, 1)), -cylinder(p, 0.5));\n    float d = min(dcBox1, dcBox2);\n    d = min(d, plane);\n    float dLight = length(light.p - p) - light.r;\n    d = min(d, dLight);\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = SceneSdf(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(\n        SceneSdf(p - e.xyy),\n        SceneSdf(p - e.yxy),\n        SceneSdf(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat WeightedLightBlob(Light light, float decay, vec3 pos) {\n    return light.r * decay / pow(length(pos - light.p), 2.);\n}\n\nRM RayMarching(vec3 ro, vec3 rd) {\n    float sdf = 0.;\n    float atm = 0.;\n    float decay = 1.;\n    vec3 pos = ro;\n    for(int i = 0; i < MAX_RAY_STEPS; i++) {        \n        float d = SceneSdf(pos);\n        atm += WeightedLightBlob(light, decay, pos);\n        if (abs(d) < EPS) {\n            break;\n        }\n        sdf += d;\n        pos += d * rd;\n        decay *= 0.98;\n    }\n    return RM(sdf, atm);\n}\n\nvec3 RenderSceneWithLight(Light light, vec3 ro, vec3 rd) {\n    RM rmMap = RayMarching(ro, rd);\n    vec3 p = ro + rmMap.sdf * rd;\n    vec3 n = GetNormal(p); \n    vec3 pToL = light.p - p;\n    vec3 pToLN = normalize(pToL);\n    float diffuse = max(dot(n, pToLN), 0.);\n\n    vec3 col = diffuse * vec3(1.) + rmMap.atm * light.c;\n    \n    RM rmShadow = RayMarching(p + n, pToLN);\n    if (rmShadow.sdf < length(pToL) - light.r) {\n        col *= 0.3;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float dor = 2.5;\n    vec2 cs = vec2(0.5 + 1.5 * cos(0.5 * t), 0.5 + 1.5 * sin(0.5 * t));\n    vec3 ro = vec3(dor * cs.x - 2., 3. * cs.x, dor * cs.y - 2.);\n    vec3 lookAt = vec3(0.);\n    vec3 col = vec3(0.);\n    \n    vec3 oz = normalize(lookAt - ro);\n    vec3 ox = normalize(cross(vec3(0., 1., 0.), oz));\n    vec3 oy = normalize(cross(oz, ox));\n    \n    vec3 rd = uv.x * ox + uv.y * oy + oz;\n    \n    light = Light(vec3(0., cs.x, 0.), .01, vec3(1, 0.871, 0.231));\n    col = RenderSceneWithLight(light, ro, rd);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}