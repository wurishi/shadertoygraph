{"ver":"0.1","info":{"id":"fdf3Wj","date":"1616618915","viewed":155,"name":"firework fun (vlllll)","username":"valalalalala","description":"Finally got around to watching BigWing's tutorial and  wanted to play around with some different distance metrics.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["firework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        ///////////////////////////////////////////////////////////////////\n       //                                                              ////\n      //  \"firework fun\"                                              // //\n     //                                                              //  //\n    //  Finally got around to watching BigWing's tutorial and       //   //\n   //  wanted to play around with some different distance metrics. //    //\n  //  https://www.youtube.com/watch?v=xDxAnguEOn8                 //     //\n //                                                              //     //\n//////////////////////////////////////////////////////////////////     // \n//                                                              //    //\n// CC0 1.0 Universal                                            //   //\n// https://creativecommons.org/publicdomain/zero/1.0/           //  //\n//                                                              // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                            ////\n//                                                              ///\n//////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////\n// tweak 'em if ya got 'em! I do... settings, pervert! yeesh...\n\nconst float FIREWORKS   = 3.;\nconst float PARTICLES   = 22.;\n\nconst float SPEED       = 1.;\nconst float MAX_EFFECT  = .004;\n\nconst float CLOSE_ENUFF = .77;\n\n//////////////////////////////////////////////////////////////////\n// so many fun distance metrics and so much time!\n\nfloat euclid( vec2 p );\nfloat eumomma( vec2 p );\nfloat manhattan( vec2 p );\nfloat langth( vec2 p );\nfloat maxhattan( vec2 p );\nfloat minhattan( vec2 p );\nfloat manmanhathattantan( vec2 p, float dampening );\nfloat atlanta( vec2 p );\nfloat marietta( vec2 p );\nfloat newnan( vec2 p );\nfloat diz1( vec2 p );\nfloat distancish( vec2 a );\n\nfloat dizd( vec2 p, int which ) {\n    // uncomment to always use the same function\n    //which = 8; \n    switch ( which % 11 ) {\n        case  0: return euclid( p );\n        case  1: return eumomma( p );\n        case  2: return langth( p );\n        case  3: return manhattan( p );\n        case  4: return maxhattan( p );\n        case  5: return manmanhathattantan( p, 4.4 );\n        case  6: return atlanta( p );\n        case  7: return marietta( p );\n        case  8: return newnan( p );\n        case  9: return diz1( p );\n        case 10: return distancish( p );\n    }\n}\n\n//////////////////////////////////////////////////////////////////\n// the dao of the tau \n\nconst float TAU = 6.283185307179586;\n\n//////////////////////////////////////////////////////////////////\n// here is a thrilling function to write over and over!\n\nvec2 fromScreen( in vec2 fragCoord );\n\n//////////////////////////////////////////////////////////////////\n// hashtastic, blackle!\n\n#define FBI(v) floatBitsToInt(v*v*3.3)^floatBitsToInt(v)\n\nfloat hash( float v );\nvec2 hash2( float v );\nvec2 rash2( float v );\n\n\n//////////////////////////////////////////////////////////////////\n// finally getting exciting!\n\nvec3 fireworkShow( vec2 uv );\nvec3 shootFirework( vec2 uv, float firework );\n\n//////////////////////////////////////////////////////////////////\n// and now... the main event!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4( fireworkShow( fromScreen( fragCoord ) ), 1. );\n}\n\n//////////////////////////////////////////////////////////////////\n// oh, gee whiz! that's really swell!\n\nvec3 fireworkShow( vec2 uv ) {\n    vec3 accumulator = vec3( .0 );\n    \n    for( float firework = 1. ; firework <= FIREWORKS ; firework++ ) {\n        accumulator += shootFirework( uv, firework );\n    }\n    \n    return accumulator;\n}\n\nvec3 shootFirework( vec2 uv, float firework ) {\n    float accumulator = .0;\n    \n    float t = iTime * firework * SPEED + firework * 4.4;\n\n    float epoch = floor( t );\n    float moment = t - epoch;\n    float imoment = ( 1. - moment );\n\n    vec2 fireworkOffset = hash2( epoch + firework * 3.3 + 4.4 );\n    vec2 fireworkLocation = uv + fireworkOffset * vec2( .8, .4 );\n        \n    vec3 color = sin( vec3( fireworkOffset.xy, fireworkOffset.x + fireworkOffset.y ) ) * .5 + .5;\n        \n    int distanceFunction = int( hash( epoch + firework ) * 11. );\n    \n    for ( float particle = 1. ; particle <= PARTICLES ; particle++ ) {\n        vec2 offset = rash2( epoch + particle + firework ) * .3;\n        vec2 location = fireworkLocation - offset * moment;\n        \n        float d = dizd( location, distanceFunction );\n        d = min( d, CLOSE_ENUFF );\n        accumulator += MAX_EFFECT / d * imoment;\n    }\n    \n    return color * accumulator;\n}\n\n//////////////////////////////////////////////////////////////////\n// here's the moment you've been waiting for:\n\nvec2 fromScreen( in vec2 fragCoord ) {\n    return ( fragCoord - iResolution.xy * .5 ) / iResolution.y;\n}\n\n//////////////////////////////////////////////////////////////////\n// hash implementations\n\nfloat hash( float v ) {\n    int q = FBI( v );\n    return float( q * q ) / 2.1248e9;\n}\n\nvec2 hash2( float v ) {\n    return vec2( hash( v - 1.234 ), hash( v + 33.44 ) );\n}\n\n// such a great trick to get that nice round distribution!\nvec2 hashToRash( vec2 h ) {\n    h *= vec2( TAU, 1. );\n    return vec2( cos( h.x ), sin( h.x ) ) * h.y;\n}\n\nvec2 rash2( float v ) {\n    return hashToRash( hash2( v ) );\n}\n\n//////////////////////////////////////////////////////////////////\n// keep your distance functions handy\n\nfloat euclid( vec2 p ) {\n    return length( p );\n}\n\nfloat eumomma( vec2 p ) {\n    return dot( p, p );\n}\n\nfloat manhattan( vec2 p ) {\n    p = abs( p );\n    return p.x + p.y;\n}\n\nfloat langth( vec2 p ) {\n    return eumomma( p ) / manhattan( p );\n}\n\nfloat maxhattan( vec2 p ) {\n    p = abs(p);\n    return max(p.x,p.y);\n}\n\nfloat minhattan( vec2 p ) {\n    p = abs(p);\n    return min(p.x,p.y);\n}\n\nfloat manmanhathattantan( vec2 p, float dampening ) {\n    float d = manhattan( p );\n    return d * d * dampening;\n}\n\n// lookit! hometown girl makes good (distance functions)! \n\nfloat atlanta( vec2 p ) {\n    return p.x * p.x * p.y * p.y * 1e7;\n}\n\nfloat marietta( vec2 p ) {\n    p = abs(p);\n    return p.x * p.y * 1e4;\n}\n\nfloat newnan( vec2 p ) {\n    return p.x * p.y * 1e2;\n}\n\nfloat diz1( vec2 p ) {\n    float dd = p.x * p.y;\n    float dp = p.x + p.y;\n    return 1. - ( dp * dd * .002 ) / ( 1e-13 + dd * dd );\n}\n\nfloat distancish( vec2 a ) {\n    vec2 d = abs( a );\n    float d1 = min( d.x, d.y );\n    float d2 = max( d.x, d.y );\n    return ( d1 * .3 + d2 * 0.7 ) * 1.41;\n}\n\n// EOF, please don't read this comment... thanks!\n//////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"}]}