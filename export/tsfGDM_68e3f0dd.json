{"ver":"0.1","info":{"id":"tsfGDM","date":"1546476611","viewed":313,"name":"Blood cells","username":"jaszunio15","description":"Having fun with cellular noise\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise","cellular","cells","blood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n//EDIT: Thanks to FabriceNyret2 for this nice rotation tip\n#define ROTATE_VEC2(angle) vec2(cos(angle), sin(angle)) \n\n//Comment to enable previus shader version\n#define ONLY_CIRCULAR_CELLS\n\n\nconst int iterations = 5;\nconst float pi = 3.141592;\nconst float doublePi = 6.283185;\n\nvec2 randomNumber(in vec2 v)\n{\n    //EDIT: Thanks to FabriceNyret2 for optimization tip \n    //return vec2(fract(sin(dot(v, vec2(12.1215, 23.02751))) * 541.9283),\n    //            fract(sin(dot(v, vec2(23.02751, 12.1215))) * 632.6047));\n    return fract(sin(v * mat2(0.7400775, -0.6725215, 0.1241045, 0.9922691)) * vec2(541.9283, 638.1429));\n}\n\nvec2 cellCenter(in vec2 uv)\n{\n \tvec2 rand = randomNumber(uv);\n    \n    //EDIT: Removed code redundancy pointed by FabriceNyret2, thanks again!\n    //return uv + vec2(cos(iTime * rand.x * 0.3), sin(iTime * rand.x * 0.3)) * rand.y * float(iterations - 1);\n\tfloat time = iTime * rand.x * 0.3;\n\treturn uv + ROTATE_VEC2(time) * rand.y * float(iterations - 1);\n}\n\nvec4 cellularNoise(in vec2 uv)\n{\n    //xy - floor uv (root point), zw - cell center\n \tvec4 uvData = vec4(floor(uv), 0.0, 0.0);\n    uvData.zw = cellCenter(uvData.xy);\n    \n    //xy - point coordinates, z - distance from point to uv\n    vec3 firstPointData = vec3(0.0, 0.0, 99999.0);\n    for(int x = -iterations; x <= iterations; x++)\n    {\n        for(int y = -iterations; y <= iterations; y++)\n        {\n            vec4 tempUVData = vec4(uvData.xy + vec2(x, y), 0.0, 0.0);\n            tempUVData.zw = cellCenter(tempUVData.xy);\n            vec2 v = uv - tempUVData.zw;\n     \t\tfloat distToTemp = v.x * v.x + v.y * v.y;\n            \n            //changed () ? : into if statement, thanks to Fabrice again!\n           \tif(firstPointData.z > distToTemp)\n            {\n                firstPointData.z = distToTemp;\n            \tfirstPointData.xy = tempUVData.zw;\n            }\n            else\n            {\n                firstPointData.z = firstPointData.z;\n            \tfirstPointData.xy = firstPointData.xy;\n            }   \n        } \n    }\n    \n    vec3 secondPointData = vec3(0.0, 0.0, 99999.0);\n    for(int x = -iterations; x <= iterations; x++)\n    {\n        for(int y = -iterations; y <= iterations; y++)\n        {\n            vec4 tempUVData = vec4(uvData.xy + vec2(x, y), 0.0, 0.0);\n            tempUVData.zw = cellCenter(tempUVData.xy);\n            vec2 v = uv - tempUVData.zw;\n     \t\tfloat distToTemp = v.x * v.x + v.y * v.y;\n            \n            //changed () ? : into if statement\n            if (secondPointData.z > distToTemp && distToTemp > firstPointData.z)\n            {\n                secondPointData.z = distToTemp;\n                secondPointData.xy = tempUVData.zw;\n            }\n            else\n            {\n                secondPointData.z = secondPointData.z;\n                secondPointData.xy = secondPointData.xy;\n            }\n            \n            \n        } \n    }\n    \n    firstPointData.z = sqrt(firstPointData.z);\n    secondPointData.z = sqrt(secondPointData.z);\n    vec3 centralPoint = (firstPointData + secondPointData) / 2.0;\n    \n    //Added this line to remove all not circular cells\n#ifdef ONLY_CIRCULAR_CELLS\n    centralPoint.z = clamp(centralPoint.z, 0.0, 0.5);\n#endif\n    \n    float effect = pow(sin(fract(centralPoint.z) * doublePi) * 0.5 + 0.5, 4.0);\n    vec3 col = vec3(0.8, 0.0, 0.0) * effect;\n    \n    return vec4(col + vec3(0.1, 0.0, 0.0), 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //EDIT: Removed useless mousePos\n\t//float mousePos = iMouse.y / iResolution.y;\n\n    vec2 uv = fragCoord / min(iResolution.x, iResolution.y);\n    uv -= vec2(0.0, 1.5);\n    float time = iTime * 0.1;\n    mat2 mat = mat2(\tcos(time), \tsin(time),\n    \t\t\t\t\t-sin(time), cos(time));\n    uv = mat * uv;\n\n    fragColor = cellularNoise(uv * 10.0);\n}","name":"Image","description":"","type":"image"}]}