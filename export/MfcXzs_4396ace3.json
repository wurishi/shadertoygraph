{"ver":"0.1","info":{"id":"MfcXzs","date":"1714314263","viewed":67,"name":"Collatz Fractal7 -Fastaro","username":"robfast","description":"whynot","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","recursion","collatzconjecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec2 p) {\n    // A simple hashing function\n    p = 50.0 * fract(p * 0.3183099 + vec2(0.1,0.1));\n    return fract(p.x * p.y);\n}\n\nfloat generateStartingValue(float n, float x) {\n    // Using the provided sequence formula to generate a starting value\n    return ((4.0 + 3.0 * n) * pow(4.0, x) - 1.0) / 3.0;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = sin(iTime/20.0) * 0.05*(fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    float slowTime = iTime * 3.0; // Slow down the time factor by 10\n\n    // Dynamically changing base value, now incorporates random element\n    float base = 2.0 + floor(mod(slowTime, 1.0) * 0.7);\n    float x = base + length(uv) * 16.0; // Starting value based on position\n\n    // Generate a random starting value from the sequence\n    float randomStart = generateStartingValue(hash(uv), x);\n\n    float sequenceValue = randomStart;\n    int steps = 0;\n    const int maxSteps = 86;\n\n    // Simulate the Collatz sequence\n    while (sequenceValue > 1.0 && steps < maxSteps) {\n        if (mod(sequenceValue, 2.0) == 0.0) {\n            sequenceValue *= 0.5;\n        } else {\n            sequenceValue = 3.0 * sequenceValue + 1.0;\n        }\n        steps++;\n    }\n\n    // Visual representation based on the number of steps\n    float radius = float(steps) / float(maxSteps);\n    float angle = atan(uv.y, uv.x);\n\n    // Polar to cartesian coordinates conversion\n    vec2 pos = vec2(radius * cos(angle), radius * sin(angle));\nfloat hueRangeStart = 0.4; // Start of hue range\nfloat hueRangeEnd = 0.95; // End of hue range\nfloat hue = hueRangeStart + mod(3.0*randomStart +1.0 /2.0 + iTime/16.0, hueRangeEnd - hueRangeStart);\n\n    float saturation = 1.6;\n    float value = 3.2;\n\n    vec3 hsv = vec3(hue, saturation, value);\n    vec3 rgb = log(abs((hsv2rgb(hsv)+2.0))); // Convert HSV to RGB\n\n    // Scaling and centering the position\n    vec2 screenPos = 0.5 + 0.5 * pos;\n    if (screenPos.x >= 0.0 && screenPos.x <= 1.0 && screenPos.y >= 0.0 && screenPos.y <= 1.0) {\n        fragColor = vec4(mix(vec3(88.0,0.0,88.0)+88.0/rgb,rgb-0.7,1.0), 0.2);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n}\n","name":"Image","description":"","type":"image"}]}