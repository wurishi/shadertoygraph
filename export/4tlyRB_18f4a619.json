{"ver":"0.1","info":{"id":"4tlyRB","date":"1505456365","viewed":199,"name":"Veins of Primes","username":"cauliflower","description":"Basically the same representation as in the famous Ulam spiral, but here the prime numbers are extended to the negative integers, and surprisingly the veins run straight through them.\n\nUse mouse to zoom/navigate.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","mathematics","primes","scrolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Veins of Primes\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Primality test, created by inigo quilez\n// https://www.shadertoy.com/view/4slGRH\nbool isPrime(int x)\n{\n\tif( x==1 ) return false;\n\tif( x==2 ) return true;\n\tif( x==3 ) return true;\n\tif( x==5 ) return true;\n\tif( x==7 ) return true;\n\tif( (x%2)==0 ) return false;\n\tif( (x%3)==0 ) return false;\n\tif( (x%5)==0 ) return false;\n\n    int xm = 1 + int(sqrt(float(x)));\n    \n\tint y = 7;\n\tfor( int i=0; i<100000; i++ ) // count up to 3000000\n\t{\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm    ) return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t}\n\t\n\treturn true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat zoom = 1.0;\n    float speed = 0.3;\n    float shiftX = 0.0;\n    float shiftY = 0.0;\n    if (iMouse.z > 0.0) {\n        vec2 normMouse = iMouse.xy/iResolution.xy-0.5;\n        vec2 deflection = normMouse*normMouse*normMouse;\n    \tshiftX = (exp(deflection.x*50.0)-exp(-deflection.x*50.0))*5000.0;\n    \tshiftY = (exp(deflection.y*24.0)-exp(-deflection.y*24.0))*200.0;\n        // magnify when mouse vertically centered\n        zoom = floor(mix(iResolution.y/80.0, 1.0, smoothstep(0.0, 0.1, normMouse.y*normMouse.y*4.0)));\n    }        \n\n    float shear = mod(iTime*speed, 2.0);\n    float offsetY = -0.5*shear + shiftY;  // scroll one row up per turn\n    vec2 cy = vec2(0.0);\n    for (int i = 0; i <= 1; i++) {\n        float y = floor((fragCoord.y-0.5+float(i) - floor(iResolution.y*0.5))/zoom + offsetY);\n        float offsetX = y*shear + 0.25*shear*shear + shiftX; \n\t    vec2 cx = vec2(0.0);\n    \tfor (int j = 0; j <= 1; j++) {\n            float x = floor((fragCoord.x-0.5+float(j) - floor(iResolution.x*0.5))/zoom + offsetX);\n            int n = abs(int(y * y + x));  // consider negative primes too\n            cx[j] = isPrime(n) ? 1.0 : 0.0;\n        }\n        // ultra smooth anti-alias for large magnification, horizontally\n        cy[i] = mix((cx[0]+cx[1])*0.5, mix(cx[0], cx[1], fract(offsetX*zoom)), smoothstep(1.5, 3.5, zoom));\n    }\n    // ultra smooth anti-alias for large magnification, vertically\n    float c = mix((cy[0]+cy[1])*0.5, mix(cy[0], cy[1], fract(offsetY*zoom)), smoothstep(0.5, 1.5, zoom));\n\n    fragColor = vec4(0.0, c, c, 1.0);\n}","name":"Image","description":"","type":"image"}]}