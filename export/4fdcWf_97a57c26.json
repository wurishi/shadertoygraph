{"ver":"0.1","info":{"id":"4fdcWf","date":"1731278928","viewed":230,"name":"test cave +spiral water 4","username":"jojobavg","description":"mix of a cave tunnel with a water tunnel\nFork from my test shader https://www.shadertoy.com/view/X3cSD7 and try to apply the advice in the comments","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["water","spiral","cave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using code from\n\n//Morgan McGuire for the noise and random functions\n// https://www.shadertoy.com/view/4dS3Wd\n\n// TDM for the getSkyColor function\n// https://www.shadertoy.com/view/Ms2SD1\n\n#define time iTime\n#define depth 40.0\n#define fogSize 30.0\n#define seuil 4.0\n#define steps 200.0\n#define sand_color_1 vec3(0.4,0.5,0.3)\n#define sand_color_2 vec3(0.65,0.7,0.4)\n#define water_sand_color_1 vec3(0.25,0.4,0.30)\n#define water_sand_color_2 vec3(0.3,0.48,0.44)\n#define water_color_1 vec3(0.3,0.4,0.4)\n#define water_color_2 vec3(0.3,0.465,0.441)\n#define fog_color vec3(0.85,0.85,0.85)\n\nfloat fogCoef=1.0/(depth-fogSize);\n\n\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\n\nfloat noise(in vec3 p_water) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p_water);\n\tvec3 f = fract(p_water);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat sand_normal = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(sand_normal + dot(step, vec3(0,0,0))),\n\trandom(sand_normal + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(sand_normal + dot(step, vec3(0,1,0))),\n\trandom(sand_normal + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(sand_normal + dot(step, vec3(0,0,1))),\n\trandom(sand_normal + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(sand_normal + dot(step, vec3(0,1,1))),\n\trandom(sand_normal + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat water(in vec3 p_water, float scale ) {\n\tvec3 tunnel = vec3(p_water.x+sin(length(p_water*0.2)+time)*2.0,p_water.y+cos(length(p_water*0.2)-time)*2.0,0.0);\n\tfloat coef = length(tunnel)-4.0;\n\n\tfloat c=1.0;\n\tfloat n1=1.0;\n\tfloat d=1.0;\n    vec3 noiseInput;\n    \n    p_water.xy*= rot(time);\n    p_water.z=p_water.z+time;\n\tfor(int i=0; i<8; ++i) {\n        \n        noiseInput = vec3(p_water*c-0.5*c*d);\n\n\t\tn1+=2.0/c*abs(noise(noiseInput*scale));\n\t\tc*=2.0;\n\t\td+=1.5;\n\t}\n\n\treturn n1*coef;\n\n}\nfloat sand(in vec3 p_water,  float scale) {\n\tvec3 tunnel = vec3(p_water.x,p_water.y,0.0);\n\tp_water.z=p_water.z+time;\n\tfloat c1=1.0;\n\tfloat n1=1.0;\n\tfloat d=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=4.0/c1*abs(noise((p_water*c1)*scale*0.5));\n\t\tc1*=2.0;\n\t\td+=1.5;\n\t}\n    float coef = length(tunnel)-1.3*n1;\n\treturn n1*coef;\n\n}\nfloat mapHyper(vec3 p_water){\n\treturn water(p_water,0.3);\n}  \nfloat mapHyper2(vec3 p_water){\n\treturn sand(p_water,0.3);\n}  \n\n\nvec3 tunnel(vec3 p_water){\n\tvec3 off=vec3(0);\n\toff.x += sin(p_water.z*0.2)*1.5;\n\toff.y += sin(p_water.z*0.3)*1.3;\n\treturn off;\n}\n\n\n//vec3 getSkyColor(vec3 e) {\n//\te.y = (e.y);\n//\te.y = max(e.y,0.0);\n//\treturn vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4)*noise(e);\n//}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) *noise(e);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\n\t\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 s=vec3(-1.0,-1.0,-3);\n    float t2=(time*1.5);\n    s.xz *= rot(sin(t2)*0.015);\n    vec3 t=vec3(0,0,0);\n    s -= tunnel(s);\n    t -= tunnel(t);\n    s.x += cos(t2*0.2)*1.0*sin(time*0.01);\n    s.y += sin(t2*0.2)*1.0*sin(time*0.01+10.0);\n    vec3 cz=normalize(t-s);\n    vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy=normalize(cross(cz,cx));\n    vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n    vec3 p_water=s;\n    float c= 0.0;\n    float mH;\n\n    for(int i=0; i<200; ++i) \n    {\n        mH = mapHyper(p_water);\n        c +=mH;  \n        if(c>seuil)break;\n        p_water+=r*(mH-seuil)*0.09;\n    }\n    vec3 p_sand=s;\n    c= 0.0;\n    for(int i=0; i<200; ++i) \n    {\n        mH = mapHyper2(p_sand);\n        c+=mH;\n        float sand_water_dist = length(p_water)-length(p_sand);\n        if(sand_water_dist<0.0)break;\n        if(c>seuil)break;\n        p_sand+=r*(mH-seuil)*0.02;\n        \n    }\n    c= 0.0;\n    vec3 water_surface_normal;\n    vec2 off=vec2(0.005,0.0);\n    water_surface_normal=normalize(mapHyper(p_water)-vec3(mapHyper(p_water-off.xyy), mapHyper(p_water-off.yxy), mapHyper(p_water-off.yyx)));\n    float fresnel;\n    fresnel = clamp(1.0 - dot(water_surface_normal, normalize(s)), 0.0, 1.0);\n    fresnel = min(fresnel * fresnel * fresnel, 0.5);\n    vec3 p_sand_underwater=p_water;\n    vec3 r2 = refract(-p_water,water_surface_normal,1.333);\n    if(fresnel<0.495)\n    {\n        for(int i=0; i<100; ++i) \n        {\n            mH = mapHyper2(p_sand_underwater);\n            c+=mH;    \n            if(c>seuil)break;\n            p_sand_underwater+=r2*(mH-seuil)*0.02;\n        }\n    }\n\tvec3 final_color=vec3(0);\n    vec3 reflection;\n\n    vec3 zVect = vec3(0.0,0.0,1.0);\n    float sand_water_dist = length(p_water)-length(p_sand_underwater);\n    float sand_water_dist_2 = length(p_water)-length(p_sand);\n\n    vec3 light_position = vec3(0.0,-0.0,-150.0);\n    float power = 2.5;\n    vec3 sand_normal=normalize(mapHyper2(p_sand)-vec3(mapHyper2(p_sand-off.xyy), mapHyper2(p_sand-off.yxy), mapHyper2(p_sand-off.yyx)));\n    if( sand_water_dist_2<0.0)\n    {\n        // This part is for the water surface and the sand underwater rendering\n\n        // Calculate the color of the water based on the water surface normal and the light direction\n        vec3 water_color =mix(water_color_1,water_color_2,(abs(1.0+dot(water_surface_normal,s)*pow(dot(zVect,r),5.0))));\n        vec3 light_direction = normalize(light_position);\n        vec3 sand_underwater_normal=normalize(mapHyper2(p_sand_underwater)-vec3(mapHyper2(p_sand_underwater-off.xyy), mapHyper2(p_sand_underwater-off.yxy), mapHyper2(p_sand_underwater-off.yyx)));\n        \n        // Calculate the color of the sand underwater based on the light direction and the sand underwater normal\n        vec3 sand_underwater_color = mix(water_sand_color_1 ,water_sand_color_2 ,vec3(dot(-light_direction,sand_underwater_normal)))*(1.0-clamp(length(light_position-p_water)/200.0,0.0,1.0))*power;\n        \n        // Calculate the final color by blending the water color and the sand underwater color based on the sand-water distance\n        water_color = mix(water_color, sand_underwater_color*clamp(exp((0.5+sand_water_dist*0.2)), 0.0, 1.0), clamp(exp((0.5+sand_water_dist*0.2)), 0.0, 1.0));\n        reflection = getSkyColor(abs(reflect(r,water_surface_normal)));\n        \n        // This line blends the final color with the reflection color based on the fresnel value multiplied by the x component of the reflection color.\n        final_color = mix(water_color,reflection, (fresnel*length(reflection)));\n        // if(sand_water_dist>-0.15){      \n        //     //  This line add a little edging where the sand and the water meet      \n        //    final_color =mix(mix(final_color,final_color+reflection*0.5,reflection.x),final_color,-sand_water_dist*8.0);\n        // }\n    }\n    else\n    {\n        // This part is for the sand rendering\n        vec3 light_direction = normalize(light_position);\n        \n        // Calculate the color of the sand based on the light direction and the sand normal\n        vec3 sand_color =mix(sand_color_1,sand_color_2,vec3(dot(-light_direction,sand_normal)))*(1.0-clamp(length(light_position-p_sand)/200.0,0.0,1.0))*power;\n        \n        fresnel = clamp(1.0 - dot(sand_normal, normalize(s)), 0.0, 1.0);\n        fresnel = min(fresnel * fresnel * fresnel, 0.5);\n        reflection = getSkyColor(abs(reflect(r,sand_normal)));\n        \n        final_color = mix(sand_color,reflection, (fresnel*length(reflection)));  \n    }\n    float fog =  clamp(exp((length(p_water-s)-fogSize)*fogCoef),0.0,1.0);\n    final_color = mix(final_color,fog_color,fog);\n    final_color =pow(clamp(final_color-0.22,0.0,1.0), vec3(1./2.2));\n\tfragColor = vec4(final_color,1.0);\n\n}","name":"Image","description":"","type":"image"}]}