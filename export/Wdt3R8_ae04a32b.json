{"ver":"0.1","info":{"id":"Wdt3R8","date":"1568063505","viewed":389,"name":"What lies in the clouds","username":"Draedrus","description":"A test for procedural clouds\n\nIn Common :\n#define SUNRISE_CAM - default cam\n//#define MOUSE_CAM - free camera, bad edges deformation\nThere is two profiles for performance, but you can play anyway you want with the parameters","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["procedural","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// @author Pierre-Marie Plans\n// clouds, lighting principally from http://www.cse.chalmers.se/~uffe/xjobb/RurikH%C3%B6gfeldt.pdf\n// helped myself with the one from https://www.shadertoy.com/view/4dSBDt Enscape Cube, ThomasSchander\n// in order to see appliance of some formulas and confirm thoughts\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cBlurDir = vec2(0.0, 1.0);\n    vec2 cBlurRadius = vec2(BLUR_SCALE/iResolution.y);\n    float cBlurSigma = BLUR_SIGMA;\n    fragColor = GaussianBlur(BLOOM_I_MAX, cBlurDir, cBlurRadius, cBlurSigma, iChannel0, uv);\n    fragColor.rgb = clamp(tonemapping(fragColor.rgb), 0., 1.);\n    \n    \n    /*if(uv.x<0.5)\n    {\n        fragColor.rgba = vec4(texture(iChannel1, uv).rgba);\n        fragColor.rgb *= fragColor.a;\n    }*/\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// @author Pierre-Marie Plans\n// clouds, lighting principally from http://www.cse.chalmers.se/~uffe/xjobb/RurikH%C3%B6gfeldt.pdf\n// helped myself with the one from https://www.shadertoy.com/view/4dSBDt Enscape Cube, ThomasSchander\n// in order to see appliance of some formulas and confirm thoughts\n\n#define PI 3.1313\n\n//#define SUNDOWN_CAM\n#define SUNRISE_CAM\n//#define MOUSE_CAM\n\n//#define LOW\n#define HIGH\n\n//#define WIP\n\n#ifdef HIGH\n    #define TEMPORAL_AA\n    #define USE_JITTERING\n    #define USE_WORLEY_DENSITY_MODIFIER true\n    #define USE_WORLEY_DENSITY_MODIFIER_INNER true\n\t#define USE_3DNOISE_PERTURBATION true\n    #define USE_WATER_CLOUD_SHADOWING\n\t//#define SAMPLE_SUN\n    #define SHADOW_HIGH\n\t#define CLOUD_SAMPLES 32\n\t#define SKY_REFLECTION_SAMPLES 16\n\t#define WATER_SAMPLES 2\n\n    // Gaussian blurr\n    #define BLOOM_I_MAX 4\n    #define BLUR_SIGMA 1.2 /* 1.2 */\n\t#define BLUR_SCALE 1.1 /* 1. */\n#else\n    #define TEMPORAL_AA\n    #define USE_JITTERING\n    #define USE_WORLEY_DENSITY_MODIFIER false\n    #define USE_WORLEY_DENSITY_MODIFIER_INNER false\n\t#define USE_3DNOISE_PERTURBATION true\n\t#define CLOUD_SAMPLES 16\n\t#define SKY_REFLECTION_SAMPLES 4\n    //#define USE_WATER_CLOUD_SHADOWING\n    //#define SHADOW_HIGH\n\t#define WATER_SAMPLES 1\n\n    // Gaussian blurr\n    #define BLOOM_I_MAX 4\n    #define BLUR_SIGMA 1.2 /* 1.2 */\n\t#define BLUR_SCALE 1.2 /* 1. */\n#endif\n\n#define JITTERING_FACTOR 1e4\n#define WEATHER_SCALE 20.\n#define NOISE_3DPERTURBATION_FACTOR .5\n\n#if defined(SUNDOWN_CAM)\n#define GTIME (iTime*0.1+6.5)\n#elif defined(SUNRISE_CAM)\n#define GTIME (iTime*0.1+4.65)\n#else\n#define GTIME iTime*0.1\n#endif\n\nfloat Remap(float x, float _oMin, float _oMax, float _newMin, float _newMax)\n{\n    return _newMin+((x-_oMin)/(_oMax-_oMin))*(_newMax-_newMin);\n}\n\nfloat Remap01(float x, float _oMin, float _oMax)\n{\n    return ((x-_oMin)/(_oMax-_oMin));\n}\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\n\n/** HASH **/\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat noise(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*noise(uv); uv*=2.001;\n    total += 0.2500*noise(uv); uv*=2.003;\n    total += 0.1250*noise(uv); uv*=2.002;\n    total += 0.0625*noise(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash3D(vec3 x)\n{\n    float h = dot(x, vec3(42.69, 51.42, 34.405));\n\treturn fract(abs(sin(h))*50403.43434);   \n}\n\nfloat smoothHash3D(vec3 x)\n{\n \tvec3 lower\t= floor(x);\n    vec3 frac \t= fract(x);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \t\tmix(\n                    mix(hash3D(lower+vec3(0., 0., 0.)), hash3D(lower+vec3(1., 0., 0.)), f.x),\n                    mix(hash3D(lower+vec3(0., 1., 0.)), hash3D(lower+vec3(1., 1., 0.)), f.x),\n        \t\tf.y),\n        \t\tmix(\n                    mix(hash3D(lower+vec3(0., 0., 1.)), hash3D(lower+vec3(1., 0., 1.)), f.x),\n                    mix(hash3D(lower+vec3(0., 1., 1.)), hash3D(lower+vec3(1., 1., 1.)), f.x),\n        \t\tf.y),\n        \tf.z); \n}\n\nfloat fbm3D(vec3 x)\n{\n    float total = 0.0;\n    total += 0.5000*smoothHash3D(x); x*=2.001;\n    total += 0.2500*smoothHash3D(x); x*=2.003;\n    total += 0.1250*smoothHash3D(x); x*=2.002;\n    total += 0.0625*smoothHash3D(x); x*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/XdyBRc\nfloat WorleySeamless(vec2 tc, int grid, float seed)\n{\n    vec2 p   = tc * float(grid);\n    vec2 ftc = fract(p);\n    vec2 itc = floor(p);\n    float m  = 1.0;\n    \n    for(int i = -1; i < 2; i++)\n    {\n        for(int j = -1; j < 2; j++)\n        {\n            vec2 n = vec2(i,j);\n            vec2 q = itc + n;\n            \n            if(q.x == -1.0)q.x = float(grid-1);\n            else if(q.x == float(grid))q.x = 0.0;\n                \n            if(q.y == -1.0)q.y =float(grid-1);\n            else if(q.y == float(grid))q.y = 0.0;\n\n            float rp \t= hash(q * seed);\n            vec2 diff \t= n + rp - ftc;\n            float dist \t= length(diff);\n            m \t\t\t= min(m,dist);\n        }\n    } \n    \n    return pow(1.0 - m,1.0);\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ )\n    {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\n// Adapted: http://callumhay.blogspot.com/2010/09/gaussian-blur-shader-glsl.html\nvec4 GaussianBlur(int blurKernelSize, vec2 blurDir, vec2 blurRadius, float sigma, sampler2D tex, vec2 texCoord)\n{\n    int blurKernelHalfSize = blurKernelSize / 2;\n\n    // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)\n    vec3 gaussCoeff;\n    gaussCoeff.x = 1.0 / (sqrt(2.0 * PI) * sigma);\n    gaussCoeff.y = exp(-0.5 / (sigma * sigma));\n    gaussCoeff.z = gaussCoeff.y * gaussCoeff.y;\n\n    vec2 blurVec = blurRadius * blurDir;\n    vec4 avgValue = vec4(0.0, 0.0, 0.0, 0.0);\n    float gaussCoeffSum = 0.0;\n\n    avgValue += texture(tex, texCoord) * gaussCoeff.x;\n\n    gaussCoeffSum += gaussCoeff.x;\n    gaussCoeff.xy *= gaussCoeff.yz;\n\n    for (int i = 1; i <= blurKernelHalfSize; i++)\n    {\n        avgValue += texture(tex, texCoord - float(i) * blurVec) * gaussCoeff.x;\n        avgValue += texture(tex, texCoord + float(i) * blurVec) * gaussCoeff.x;\n\n        gaussCoeffSum += 2.0 * gaussCoeff.x;\n        gaussCoeff.xy *= gaussCoeff.yz;\n    }\n\n    return avgValue / gaussCoeffSum;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ruv = -1.+2.*uv;\n    //uv = abs(ruv);\n    \n    float f = 1./WEATHER_SCALE;\n    \n \tfloat rb = 1.-dot(ruv, ruv);\n    rb = 1.-pow(ruv.x*ruv.x, 32.);\n    rb *= 1.-pow(ruv.y*ruv.y, 32.);\n    \n    vec2 wind = fract(vec2(cos(0.1*GTIME), sin(0.1*GTIME))*0.008);\n   \n    float b = 0.;\n    float d = fbm_hash(WEATHER_SCALE*(1.+uv)+wind);\n    //b *= d*d;\n    //b = clamp(4.*b, 0., 1.);\n    float v = 0.;//max(0., 1.-voronoi2D(uv*30.+GTIME));\n    b = WorleySeamless(fract(f*uv+wind), 8*int(WEATHER_SCALE), 5.);\n    //b = Remap01(b, -.2, 1.);//clamp(b-0.2, 0., 1.);\n    v = clamp(WorleySeamless(fract(f*uv+wind*0.002), 15*int(WEATHER_SCALE), 45.), 0., 1.);\n    \n    fragColor.rgba = vec4(\n        4.*((b-.5)+(d-.5)),\n        d,\n       \t/*smoothstep(.2, .6, v)*/Remap01(1.-d, 0.5, 1.),\n    \trb);//3.*clamp(v, 0.2, 0.4));\n    //fragColor.rgb = vec3(wind, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// @author Pierre-Marie Plans\n// clouds, lighting principally from http://www.cse.chalmers.se/~uffe/xjobb/RurikH%C3%B6gfeldt.pdf\n// helped myself with the one from https://www.shadertoy.com/view/4dSBDt Enscape Cube, ThomasSchander\n// in order to see appliance of some formulas and confirm thoughts\n// HDR sky parameters\n\n#define SUNDIST \t\t\t(149597870700.0)\n#define MOONDIST \t\t\t(384467700.0)\n#define EARTHRADIUS\t\t\t(6360e3)\n#define ATMOSPHERERADIUS\t(6420e3)\n#define SUNRADIUS \t  \t\t(695700000.0)\n#define MOONRADIUS \t\t\t(1737400.0)\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n\n#ifdef ORIGINAL_SETUP\n#define CLOUD_START (2.0)\n#define CLOUD_END\t(14.0)\n#else\n#define CLOUD_START (15000.)\n#define CLOUD_END\t(40000.)\n#endif\n\n#define SUNINTENSITY\t\t 20.\n\n#define SUNPOS (EARTHPOS+normalize(vec3(0.0, cos(GTIME), sin(GTIME)))*SUNDIST)\n#define MOONPOS (EARTHPOS+normalize(vec3(-0.6, 0.8, -1.5))*MOONDIST)\n\nvec2 gDebugUV = vec2(0.);\n\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B + 4.0*-C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = B*-.5;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))*.5;\n            tmax = (-B+sqrt(D))*.5;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec4 getSkyLight(vec3 ro, vec3 rd, vec3 Lo, in float Li, in int nSamples, inout vec3 betaM, inout vec3 betaR, inout vec3 sumM, inout vec3 sumR)\n{\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, -normalize(Pa-Lo));\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 1./7994.0; // 7994\n    float hm = 1./350.0; // 1200\n    // Rayleigh\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    float opticalDepthR = 0.0;\n    // Mie\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    float opticalDepthM = 0.0;\n    float cloudScat = 0.0;\n    for (int i = 0; i < nSamples; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h*hr)*segL;\n        float _hm = exp(-h*hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = normalize(Lo-X);//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, lRay, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax*0.125; // tlmax/8.0\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < nSamples>>1; ++j)\n        {\n            vec3 samplePositionLight = X+lRay*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(hLight * -hr) * segLLight;\n            opticalDepthLightM += exp(hLight * -hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = exp(-tau);//vec3(exp(-tau.xyz), exp(-tau.y), exp(-tau.z));\n        \t\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return vec4(\n        Li * (sumR * phaseR * betaR + sumM * phaseM * betaM)\n        , tmax);\n}\n\nfloat heightSignal(float a, float x, float h)\n{\n    return (x-a)*(x-a-h)*(-4./(h*h));\n}\n\nfloat phaseHenyeyGreenstein(float g, float cosTeta)\n{\n    return (1.-g*g)/(4.*PI*pow(1.+g*g-2.*g*cosTeta, 1.5));\n}\n\nfloat GetHeight(vec3 P, float a, float t)\n{\n    float height = Remap01(P.y, EARTHRADIUS+CLOUD_START, EARTHRADIUS+CLOUD_END);//clamp((CLOUD_END-(pos.y-EARTHRADIUS))/(CLOUD_END-CLOUD_START), 0.0, 1.0);\n    return heightSignal(a, height, t);\n}\n\nvec2 GetDensity(vec3 pos, float s, bool bDoWorley)\n{\n    pos.xz += 16000.*GTIME;\n    /*float f = (1./WEATHER_SCALE);\n    vec4 data = texture(iChannel0, 0.00005*f*s*pos.xz).rgba;\n    data.r *= data.a;\n    data.r = texture(iChannel1, .0001*f*pos).r;\n    float df = smoothstep(.7, 1., 0.8);\n    float h = clamp(GetHeight(pos, 0., 1.), 0., 1.);\n\n    float n = Remap01(texture(iChannel1, 0.00004*s*(pos+vec3(0., 0., .02))).r, 0., 1.);\n    // this is a massive computation resource\n    // I avoid it while sampling inner and inter clouds shadowing saving a lot of GPU power\n    // with minor quality loss\n    float v =clamp(bDoWorley?max(0., 1.-voronoi3D(0.007*f*pos)):data.g, 0., 1.);\n    //data.r += 0.4;\n    return vec2(\n        clamp(\n            /*pow(clamp(\n            h * (data.r-0.15)*v\n            #ifdef USE_3DNOISE_PERTURBATION\n            -NOISE_3DPERTURBATION_FACTOR*n\n            #endif\n            // h * max(0., n*(data.g+v)*(data.r-0.15))// * n)// *n)// * v - .1)\n            , 0., 1.), max(1., 8.*max(0.01, 1.-data.r)))\n            , 0., 1.),*/\n     /*       \n            , 0., 1.),\n        h);*/\n    \n    //------ Data\n    float f = (1./WEATHER_SCALE);\n    vec4 data = texture(iChannel0, 0.00005*f*s*pos.xz).rgba;\n    //------ height\n    float h = GetHeight(pos, .3, 1.8);\n    //------ Shape\n    float b = max(0., fbm3D(.00002*pos+GTIME)-.5);//pow((1.-voronoi3D(.00001*pos)), 16.);\n    //------ details\n    float dt = clamp(bDoWorley?max(0., 1.-voronoi3D(0.0002*pos)):1., 0., 1.);\n    float n = Remap01(texture(iChannel1, 0.00008*pos).r, 0., 1.);\n    \n    #ifdef USE_3DNOISE_PERTURBATION\n    dt*=NOISE_3DPERTURBATION_FACTOR*n;\n    #endif\n    //------ composition\n    float d = h * smoothstep(0., dt, 2.*b) /* (data.r * data.a + .0)*/;\n    //d = d*d;\n    d = d*d*(3.-2.*d);\n    //------ result\n    return vec2(clamp(d, 0., 1.), h);\n}\n\nfloat atten(float d, float l)\n{\n    // beer\n    //return exp(-d*l);\n    // TODO TRY BEER-POWDER AGAIN - Horizon Zero Dawn\n    return exp(-d*l)*(/*1.f-*/exp(-d*l*2.));\n}\n\nvec3 getSkyColor(vec2 ssUV, vec3 ro, vec3 rd, vec3 Lpos, float Li, float Ls, vec3 betaM, vec3 betaR, float fNight, int nbSamples, bool bWorley, bool bWorleyInner, inout vec3 outAtmScat)\n{\n    vec3 sumR = vec3(0.);\n    vec3 sumM = vec3(0.);\n    \n    vec4 colorAndCS = getSkyLight(ro, rd, Lpos, Li, nbSamples>>2, betaM, betaR, sumM, sumR);\n\n    outAtmScat = (sumR*betaR+sumR*betaM);\n       \n   \tvec3  color = colorAndCS.rgb;\n    vec3 Pa = ro+rd*colorAndCS.a;\n    \n\tvec3 L = normalize(Pa-Lpos);\n    \n    float mu = dot(rd, -L); // may be negative\n    float dPhase = phaseHenyeyGreenstein(.76, mu);\n    \n    float Disk = 0.;\n    Disk = (mu-mix(0.997, 0.999, fNight))>0.?1.:0.;\n    // astre\n    float mask = Remap01(fbm_hash((rd*72.0).xz), .1, .6);\n    vec3 lcolor = Li*outAtmScat*mix(.15, clamp(.85*mask, 0., 1.), fNight);\n    color += Disk*lcolor;\n    // stars\n    float sN = clamp(Remap01(texture(iChannel1, 8.*rd/*2e-5*Pa*/).r, 0.92, 1.), 0., 1.);\n    color += fNight*vec3(10.*sN);\n    // clouds\n    float totalDensity = 0.0;\n    float totalLightin = 0.;\n    float transmittance = 1.;\n    float lowerLayerDist = 0.0;\n    {\n        float tminclouds = 0.0;\n        float _d = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS+CLOUD_START, tminclouds, lowerLayerDist);\n    }\n    float upperLayerDist = 0.0;\n    {\n        float tminclouds = 0.0;\n        float _d = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS+CLOUD_END, tminclouds, upperLayerDist);\n    }\n    float tmp = max(upperLayerDist, lowerLayerDist);\n    lowerLayerDist = min(upperLayerDist, lowerLayerDist);\n    upperLayerDist = tmp;\n    float stepS = (upperLayerDist-lowerLayerDist)/float(nbSamples);\n    float totalDist = lowerLayerDist;\n    #ifdef USE_JITTERING\n    float dithFactor = noise(JITTERING_FACTOR*ssUV);\n    //float dfs = 4./(max(upperLayerDist, lowerLayerDist));\n    //float dithFactor = pow(JITTERING_FACTOR, mix(1.2, 0.6, clamp(rd.y, 0., 1.)))*textureLod(iChannel1, dfs*(ro+rd*lowerLayerDist), 0.).r;\n    totalDist = (dithFactor-.5)*2.*stepS+totalDist;\n    //return vec3(dithFactor);\n    //stepS -= dithFactor/float(nbSamples);\n    //stepS = max(1., stepS);\n    #endif\n    \n    #ifdef SAMPLE_SUN\n    vec4 sunColor = getSkyLight(ro+rd*lowerLayerDist, -L, Lpos, Li, nbSamples>>2, betaM, betaR, sumM, sumR);\n    #endif\n    if(rd.y>.01)\n    for(int i = 0;i<nbSamples; ++i)\n    {\n        //if(dist>tminclouds) break;\n        vec3 P = ro+rd*totalDist;\n\t\tvec2 dh = GetDensity(P, 1., bWorley);\n        \n        if(dh.x>0.0)\n        {\n            vec3 RaySun = normalize(Lpos-P);\n\n            float ambient = max(0.05, abs(L.y));//.4;//smoothstep(.4,.5, clamp(dh.y, 0., 1.));//.5;//smoothstep(0., 1., dh.y);//clamp(1.-(EARTHRADIUS+CLOUD_END-P.y)/(EARTHRADIUS+CLOUD_END-EARTHRADIUS+CLOUD_START), 0., 1.);\n\n            // shadowing + light\n            float incomingRadiance = 0.;\n            float stepLight = 10.;\n            float distLight = stepLight*.5;\n            //if(RaySun.y>0.)\n            float _tr = transmittance;\n            for(int j = 0; j < 4; ++j)\n            {\n                vec3 Pl = P+RaySun*distLight;\n                vec2 dhTS = GetDensity(Pl, 1., bWorleyInner);\n                \n                // meh, let's see that after\n                float _dPhase = phaseHenyeyGreenstein(.76, dot(RaySun, L));\n                #if 0\n                if(dhTS.x>0.)\n                {\n                    //#define SIMPLE_CLOUD_TOSUN\n                    #ifdef SIMPLE_CLOUD_TOSUN\n                        float inRad = _tr*(Li*_dPhase+ambient);\n                        _tr *= atten(densityTS, stepLight);\n                        incomingRadiance += inRad;\n                    #else\n                        float inRad = (Li*dPhase+ambient)*dhTS.x;\n                        incomingRadiance += _tr*((inRad-inRad*atten(dhTS.x, stepLight))/(1.+dhTS.x));\n                        _tr *= atten(dhTS.x, stepLight);\n                    #endif\n                }\n                else\n                {\n                    incomingRadiance += _tr*(Li*_dPhase+ambient);\n                    _tr *= atten(0., stepLight);\n                }\n                #else\n                \t_tr = min(1., _tr*atten(max(0., dhTS.x), stepLight));\n                #endif\n                if(_tr<=0.05) break;\n                \n                //stepLight = exp(stepLight);\n                stepLight = 2.*stepLight;\n                distLight += stepLight;\n            }\n\n            // lighting\n            float sigmaScattering = 1.;\n            float sigmaExtinction = 1.;\n            float sampleSigmaS = sigmaScattering * dh.x;\n            float sampleSigmaE = sigmaExtinction * dh.x;\n            float Tr = atten(dh.x, stepS); // beers law, use total distance for light or just step ?\n            float radiance = (Li*dPhase*_tr+ambient) * sampleSigmaS;\n            \n            totalLightin += transmittance*((radiance-radiance*Tr)/sampleSigmaE);\n            transmittance *= Tr;\n\n            if(transmittance<=0.05) break;\n        }\n        totalDist += stepS*(dh.x>0.?.2:1.);\n        if(totalDist>upperLayerDist) break;\n        totalDensity += dh.x;\n    }\n    //if(totalDensity>0.) lightShaft = 0.;\n    #ifdef WIP\n    float lightShaft = 0.;\n    lightShaft = 0.;\n    totalDist = upperLayerDist*.05;\n    float totalTrShaft = 1.;\n    totalDensity = 0.;\n    stepS = upperLayerDist/float(nbSamples);\n    if(rd.y>.01)\n    for(int i = 0;i<nbSamples; ++i)\n    {\n        //if(dist>tminclouds) break;\n        vec3 P = ro+rd*totalDist;\n\t\tvec2 dh = GetDensity(P, 1., bWorley);\n        \n        float towardsSun = 0.;\n        float _tr = 1.;\n        //if(dh.x>0.0)\n        {\n            vec3 RaySun = normalize(Lpos-P);\n\n            // shadowing + light\n            float stepLight = 500.; // 5000.\n            float distLight = stepLight*.5;\n            //if(RaySun.y>0.)\n            for(int j = 0; j < 4; ++j)\n            {\n                vec3 Pl = P+RaySun*distLight;\n                vec2 dhTS = GetDensity(Pl, 1., false);\n                \n                /*float trTS = atten(dhTS.x, stepLight);\n                towardsSun += 0.005;\n        \t\t//towardsSun += .002*trTS*((dhTS.x>0.)?dhTS.x:1.);\n                _tr *= trTS;*/\n                if(dhTS.x>0.0)\n                totalTrShaft *= .95;\n                \n                //stepLight = exp(stepLight);\n                stepLight = 6.*stepLight;\n                distLight += stepLight;\n            }\n        }\n        \n        /*float tr = atten(max(0., dh.x), stepS);\n        float radiance = towardsSun;\n        \n        lightShaft += totalTrShaft*(radiance)*_tr;\n        \n        totalTrShaft *= tr;*/\n        if(dh.x>0.0)\n        totalTrShaft *= .95;\n        \n        totalDist += stepS;//*(dh.x>0.?.2:1.);\n        totalDensity += dh.x;\n        if(totalDist>upperLayerDist) break;\n    }\n    lightShaft = totalTrShaft;\n    lightShaft = clamp(lightShaft, 0., 1.);\n    #endif\n    #ifdef SAMPLE_SUN\n    vec3 finalColor = sunColor.rgb*totalLightin;\n    #else\n    vec3 finalColor = outAtmScat*totalLightin;\n    #endif\n    //finalColor = vec3(totalLightin);\n    \n    // square to stop the sun disk, this is actually some kind of hack it should be done only once\n    //finalColor += transmittance * color;\n    #ifdef WIP\n    finalColor += transmittance * color + pow(lightShaft, 1.) * color;\n    //finalColor = vec3(lightShaft);\n    #else\n    finalColor += transmittance * color;\n    #endif\n    //finalColor = vec3(smoothstep(0., 1., transmittance) * color);\n    //finalColor = vec3(outAtmScat*totalLightin);\n    \n    return finalColor;\n}\n\nfloat IntersectPlane(vec3 ro, vec3 rd, vec3 po, vec3 pn) {\n    float Vd = dot(rd, pn);\n    float t = -1.0;\n    float d = -1.0;\n    if(Vd<0.0) {\n        float V0 = -(dot(pn, ro)+length(po-ro));\n        float t = V0/Vd;\n        if(t>=0.0) {\n            d = t;\n        }\n    }\n    return d;\n}\n\nfloat mapW(vec3 P, vec2 w)\n{\n    float d = P.y;\n    float str = .5*(1.+sin(GTIME));\n    // main shape\n    //float m = 2.*(-0.5+fbm_hash(w+0.02*P.xz));\n    //d -= (10.0+4.0*str)*m;\n    //d += 0.01*str*fbm_hash(-w*6.+1.1*P.xz)+1.0*fbm_hash(w*8.+1.1*P.xz);\n    float amp = 16.0; // 32.0\n    float f = 0.005; // 0.01\n    float s = 0.05; // 0.2\n    for(int i = 0;i < WATER_SAMPLES; ++i)\n    {\n        d += (amp+4.0*str) * fbm_hash(-w+f*P.xz);\n        d -= (amp+4.0*str) * fbm_hash(-w-f*P.xz);\n        amp *= 0.05;\n        f *= 1.6;\n        s *= 2.8;\n    }\n    // detail\n    return d;\n}\n\n// Disney ggx ?\nfloat bdistrib(float r, float NdotH)\n{\n    float NdotH2 = NdotH*NdotH;\n    float r2 = r*r;\n    float r1 = 1.0 / max(0.0001, 4.0 * r2 * NdotH2*NdotH2);\n    r2 = (NdotH2 - 1.0) / (r2 * NdotH2);\n    return r1 * exp(r2);\n}\n\n#ifdef USE_WATER_CLOUD_SHADOWING\nfloat getShadowAmount(vec3 ro, vec3 rd)\n{\n    float transmittance = 1.;\n    float lowerLayerDist = 0.0;\n    {\n        float tminclouds = 0.0;\n        float _d = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS+CLOUD_START, tminclouds, lowerLayerDist);\n    }\n    int nbSamples = CLOUD_SAMPLES>>2;\n    #ifdef SHADOW_HIGH\n    float upperLayerDist = 0.0;\n    {\n        float tminclouds = 0.0;\n        float _d = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS+CLOUD_END, tminclouds, upperLayerDist);\n    }\n    \n    float stepS = (upperLayerDist-lowerLayerDist)/float(nbSamples);\n    #else\n    float stepS = 100./float(nbSamples);\n    #endif\n    float totalDist = lowerLayerDist;\n    \n    if(rd.y>0.1)\n    for(int i = 0;i<nbSamples; ++i)\n    {\n        if(totalDist>upperLayerDist) break;\n        vec3 P = ro+rd*totalDist;\n\t\tvec2 dh = GetDensity(P, 1., false);\n        \n        if(dh.x>0.0)\n        {\n            transmittance *= atten(dh.x, stepS);\n\n            if(transmittance<=0.05) break;\n        }\n        stepS += stepS;\n        totalDist += stepS;\n    }\n    return clamp(transmittance, 0.6, 1.);\n}\n#endif\n\nvec3 Render(vec2 uv, vec3 ro, vec3 rd, vec3 Psun, vec3 Pmoon)\n{\n    vec3 betaDayR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    vec3 betaDayM = vec3(21e-6);\n    vec3 betaNightR = vec3(1.5e-8, 1.6e-8, 1.4e-8);\n    vec3 betaNightM = vec3(3e-6);\n    float nSunH = (Psun.y/SUNDIST);\n    \n    float x = Remap01(nSunH, -0.10, 1.);\n    float bSwitch = x>0.?0.:1.;\n    \n    vec3 Lpos = mix(Psun, Pmoon, bSwitch);\n    vec3 betaR = mix(betaDayR, betaNightR, bSwitch);\n    vec3 betaM = mix(betaDayM, betaNightM, bSwitch);\n    float Li = mix(SUNINTENSITY, SUNINTENSITY*smoothstep(0., 1., clamp(-(nSunH), 0., 1.)), bSwitch);\n    float Ls = mix(SUNRADIUS, MOONRADIUS, bSwitch);\n    \n    vec3 color = vec3(0.);\n    vec3 outAtmScat = vec3(0.0);\n    if(rd.y>0.)\n    \tcolor = getSkyColor(uv, ro, rd, Lpos, Li, Ls, betaM, betaR, bSwitch, CLOUD_SAMPLES, USE_WORLEY_DENSITY_MODIFIER, USE_WORLEY_DENSITY_MODIFIER_INNER, outAtmScat);\n    \n    if(rd.y<0.1)\n    {\n        #define WFAR 600.\n        #define MAP(X, w) mapW((X), w)\n        float d = 0.;\n        vec2 W = vec2(1.*GTIME, 0.5*GTIME);\n        vec3 Plocal = ro-vec3(0., EARTHRADIUS-18., 0.);\n        for(int i = 0;i<50; ++i)\n        {\n            vec3 P = Plocal+rd*d;\n            float d2 = MAP(P, W);\n            if(d2<0.01 || d>WFAR) break;\n            d += 0.5*d2;\n        }\n        if(d<WFAR)\n        {\n            vec3 Pl = ro-vec3(0., EARTHRADIUS, 0.)+rd*d;\n            vec3 Pw = ro+rd*d;\n\n            float e = 0.001;\n            float d = 2.;\n            vec3 N;\n            {\n                N.y = MAP(Pl*d, W);\n                N.x = MAP((Pl+vec3(e, 0., 0.))*d, W) - N.y;\n                N.z = abs(MAP((Pl+vec3(0., 0., e))*d, W) - N.y);\n                N.y = e*1.0;\n                N = \n                    normalize(mix(\n                        vec3(0.0, e, 0.0),\n                        N,\n                        1./d*0.7)); //exp(-d*.7) // -d*0.007\n            }\n            vec3 L = normalize(Lpos-Pw);\n\n            {\n                float F = clamp(1.-Fresnel_Schlick(1., 1.345, dot(-rd, N)), 0., 1.);\n                vec3 H = normalize(rd-L);\n                color = mix(vec3(.01, 0.05, 0.06), vec3(0.02, 0.06, .06), clamp((Pl.y+18.)*0.05, 0., 1.));\n\n                rd = reflect(rd, N);\n                vec4 refl = vec4(0.0);\n                if(rd.y<0.16)\n                {\n                    vec3 sumR = vec3(0.);\n                    vec3 sumM = vec3(0.);\n\n                    refl = getSkyLight(Pw, rd, Lpos, Li, SKY_REFLECTION_SAMPLES, betaM, betaR, sumM, sumR);\n                }\n                else\n                {\n                    refl = vec4(getSkyColor(uv, Pw,\n                                            rd, Lpos, Li, Ls, betaM, betaR, bSwitch, CLOUD_SAMPLES>>2, false, false, outAtmScat), 0.);\n                }\n                color = mix(\n                    color,\n                    bdistrib(.9, dot(N, H))*refl.rgb,\n                    F);\n                #ifdef USE_WATER_CLOUD_SHADOWING\n                color *= vec3(getShadowAmount(Pw, normalize(Lpos-Pw)));\n                #endif\n\n                color = max(vec3(0.), color);\n            }\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ires =  1. / iResolution.xy;\n\tvec2 uv = fragCoord.xy * ires;\n    vec2 ruv = uv;\n    ruv.x *= iResolution.x * ires.y;\n    gDebugUV = uv;\n\tvec2 muv = (-1.0+2.0*iMouse.xy * ires)*3.14;\n    vec3 color = vec3(0.0);\n    \n    float T = 0.08*GTIME;\n    vec3 ro = vec3(0.0, 0.1, 0.0)+vec3(0.0, EARTHRADIUS, 0.0);\n    vec3 rd = normalize(vec3(-1.0+2.0*ruv, 1.* iResolution.x*ires.y));\n    mat3 viewMat = setCamera(ro,\n                             #ifdef SUNDOWN_CAM\n                             ro+vec3(-cos(PI*1.012), .5, -sin(PI*1.012)*100.)\n                             #elif defined(SUNRISE_CAM)\n                             ro+vec3(cos(PI*1.012), .5, sin(PI*1.012)*100.)\n                             #elif defined(MOUSE_CAM)\n                             ro+vec3(cos(muv.x), sin(muv.y), sin(muv.x))*100.0\n                             #else\n                             ro+vec3(cos(PI*0.5), 0.0, sin(PI*0.5))*100.0\n                             #endif\n                             ,\n                             vec3(0.0, 1.0, 0.0)\n                            );\n    \n    rd = viewMat*rd;\n    \n    color = Render(uv, ro, rd, SUNPOS, MOONPOS);\n    \n\tfragColor = vec4(color,GTIME);\n    #ifdef TEMPORAL_AA\n    vec4 prev = texture(iChannel2, uv);\n    fragColor.rgb = mix(fragColor.rgb, prev.rgb, 0.1);\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//\n// @author Pierre-Marie Plans\n// clouds, lighting principally from http://www.cse.chalmers.se/~uffe/xjobb/RurikH%C3%B6gfeldt.pdf\n// helped myself with the one from https://www.shadertoy.com/view/4dSBDt Enscape Cube, ThomasSchander\n// in order to see appliance of some formulas and confirm thoughts\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ires = 1./iResolution.xy;\n    vec2 uv = fragCoord*ires.xy;\n    vec2 cBlurDir = vec2(1.0, 0.0);\n    vec2 cBlurRadius = vec2(BLUR_SCALE*ires.y);\n    float cBlurSigma = BLUR_SIGMA;\n    fragColor = GaussianBlur(BLOOM_I_MAX, cBlurDir, cBlurRadius, cBlurSigma, iChannel0, uv);\n}","name":"Buffer C","description":"","type":"buffer"}]}