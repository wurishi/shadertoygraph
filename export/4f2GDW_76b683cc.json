{"ver":"0.1","info":{"id":"4f2GDW","date":"1704326863","viewed":16,"name":"Edge Shader w/ Raymarching","username":"onetap","description":"Its an edge shader bro","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float s){\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)- \n  t.x,p.y);\n  return length(q)-t.y;\n }\n\nfloat sdPlanexz(vec3 p, float y){\n    return p.y - y;\n}\n\nfloat smoothMax(float a, float b, float k){\n    return log(exp(k*a)+exp(k*b))/k;\n}\nfloat smoothMin(float a, float b, float k){\n    return -smoothMax(-a,-b,k);\n}\nfloat map(vec3 p){\n    vec3 spherePos = vec3(0,0,0);\n    vec3 spherePos2 = vec3(3.39*sin(iTime/0.7),0,0);\n    vec3 torusPos = vec3(4.0*sin(iTime*2.0),0,0);\n    float sphere = sdSphere(p - spherePos,1.0);\n    float sphere2 = sdSphere(p - spherePos2,1.0);\n    float torus = sdTorus(p-torusPos,vec2(1,0.2));\n    //float plane = sdPlanexz(p,-1.0);\n    return smoothMin(sphere2,smoothMin(sphere,torus,5.0),5.0);\n}\n\nvec3 calculateNormal(vec3 p){\n    float epsilon = 0.001;\n    vec3 v1 = vec3(\n        map(p + vec3(epsilon,0,0)),\n        map(p + vec3(0,epsilon,0)),\n        map(p + vec3(0,0,epsilon)));\n    vec3 v2 = vec3(\n        map(p - vec3(epsilon,0,0)),\n        map(p - vec3(0,epsilon,0)),\n        map(p - vec3(0,0,epsilon)));\n        \n    return normalize(v1-v2);\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) /iResolution.y;\n\n    vec3 ro = vec3(0,2,-3);\n    vec3 rd = normalize(vec3(uv,1));\n    vec3 col = vec3(0,0,0);\n    vec3 lightPos = vec3(1,1,-3);\n    float t = 0.0;\n    \n    for(int i = 0; i < 80; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d;\n        \n\n        if(d < 0.001){ \n            vec3 color = vec3(1,0,0);\n            vec3 lightRay = normalize(lightPos);\n            vec3 normal = calculateNormal(p);\n            \n            vec3 diffuseCol = max(0.0,dot(lightRay,normal)) * color;\n            col = color;\n            //col = diffuseCol * (1.0-float(i)/40.0) + vec3(1,1,1)*(float(i)/40.0);\n            if(float(i) > 15.0){\n                col = vec3(0,0,0);\n            }\n            break;\n        }\n        if(t > 100.0){\n            //col = vec3(124.0, 128.0, 127.0)/255.0;\n            col = vec3(1,1,1);\n            \n        }\n        if(p.y < -1.0){\n            vec3 floorColor = vec3(58./255.0 , 94./255.0 , 85./255.0 );\n            vec3 fogColor = vec3(124.0, 128.0, 127.0)/255.0;\n            float fogWallDist = 20.0;\n            float multiplier = length(p)/fogWallDist;\n            if(multiplier > 1.0) multiplier = 1.0;\n            //fix banding sometime down the line\n            //col = (1.0-multiplier)*floorColor + multiplier*(fogColor);\n            col = vec3(1,1,1);\n            break;\n        }\n        \n    }\n\n    \n\n    fragColor = vec4(col,1);\n\n}","name":"Image","description":"","type":"image"}]}