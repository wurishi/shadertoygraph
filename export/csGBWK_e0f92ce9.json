{"ver":"0.1","info":{"id":"csGBWK","date":"1698638929","viewed":70,"name":"photoshop like waveletdecompose","username":"thedidi","description":"photoshop like waveletdecompose","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["waveletdecompose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAPR(v) ((v) / iResolution.xy)\n\nconst int stride = 3;\nconst int kSize = stride*stride;\nconst int kRadius = (stride-1)/2;\nconst float kernel[kSize] = float[] (1.,2.,1.,2.,4.,2.,1.,2.,1.);\nconst float norm = 16.;\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d - 1.0;\n}\n\nfloat overlay( float s, float d )\n{\n\treturn (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 overlay( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = overlay(s.x,d.x);\n\tc.y = overlay(s.y,d.y);\n\tc.z = overlay(s.z,d.z);\n\treturn c;\n}\n\nvec4 dilate0(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,0.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*texture(tex, MAPR(xy+vec2(scale*float(i),scale*float(j)))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 dilate1(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,1.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*dilate0(tex, xy+vec2(scale*float(i),scale*float(j))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 dilate2(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,2.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*dilate1(tex, xy+vec2(scale*float(i),scale*float(j))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 dilate3(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,3.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*dilate2(tex, xy+vec2(scale*float(i),scale*float(j))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 tophat_transform(sampler2D tex, vec2 fragCoord) {\n    vec4 blend1 = 0.5+texture(tex, MAPR(fragCoord.xy)) - dilate0(tex, fragCoord);\n    vec4 blend2 = 0.5 + dilate0(tex, fragCoord) - dilate1(tex, fragCoord);\n    vec3 blendResult = linearLight(blend1.xyz,blend2.xyz);\n\treturn vec4(blendResult,1.0);\n    vec4 blend3 = 0.5 + dilate1(tex, fragCoord) - dilate2(tex, fragCoord);\n    blendResult = linearLight(blendResult,blend3.xyz);\n\treturn vec4(blendResult,1.0);\n    vec4 blend4 = 0.5 + dilate2(tex, fragCoord) - dilate3(tex, fragCoord);\n    blendResult = linearLight(blendResult,blend4.xyz);\n\treturn vec4(blendResult,1.0);\n    vec4 blend5 = dilate3(tex, fragCoord);\n    blendResult = overlay(blendResult,blend5.xyz);\n    return vec4(blendResult,1.0);\n}\n\n//iChannel0: texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = tophat_transform(iChannel0, fragCoord);\n}","name":"Image","description":"","type":"image"}]}