{"ver":"0.1","info":{"id":"DsGcRd","date":"1696448468","viewed":61,"name":"Ray Marching with colors","username":"francesco_vmk","description":"this is my first attempt at ray marching.\ni followed this tutorial for the base: https://www.youtube.com/watch?v=TSAIR03FPfY\nand i added the colors and changed some stuff.\n\nits not the most optimized shader but its my first attempt","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"dsKyzc","parentname":"my first ray marching test"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_TRAVEL_DIST = 24.0;\nconst float STEP_NUM = 70.0;\nconst float MIN_SDF_DIST = 0.01;\n\n// Functions\nfloat[5] map(vec3 p);\nfloat rayMarch(vec3 ro, vec3 rd, float maxDistance);\nvec3 render(vec2 uv);\nvec3 getNormal(vec3 p);\nfloat[5] opSmoothUnion(float[5] d1, float[5] d2, float k);\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nvec4 getColor(vec3 p);\n\n\nvec4 randomColor(float seed, float i)\n{\n    // Generate random values for R, G, B, and A components\n    float r = fract(sin(i * seed) * 43758.5453);\n    float g = fract(cos(i * seed) * 54756.8929);\n    float b = fract(tan(i * seed) * 35678.2345);\n    \n    return vec4(r, g, b, 1.0); // Fully opaque color\n}\n\n\n//shapes\nfloat[5] sdfSphere(vec3 p, vec3 center, float radius, vec4 color);\nfloat sdfPlane( vec3 p, vec3 n, float h );\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Calculate aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n\n    // Correct for aspect ratio\n    uv.x *= aspectRatio;\n\n    vec3 color = vec3(0.0);\n\n    color = render(uv);\n    fragColor = vec4(color, 1.0);\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 color = vec3(0.0);\n\n    vec3 ro = vec3(0.0, 0.0, -2.5); // ray origin\n    vec3 rd = vec3(uv, 1.0);       // ray direction\n\n    float dist = rayMarch(ro, rd, MAX_TRAVEL_DIST);\n\n    if (dist < MAX_TRAVEL_DIST)\n    {\n        //color = vec3(1.0);\n        \n        //normals\n        vec3 p = ro + rd * (dist); //get point wher you need to calculate the normals\n        vec4 baseColor = getColor(p); //get color at point\n        vec3 normal = getNormal(p);\n        \n        color = normal;\n        \n        //lighting\n        \n        //ambient\n        vec3 ambient = vec3(1.000,1.000,1.000);\n        \n        //diffuse\n        vec3 lightColor = vec3(1.000,1.000,1.000);\n        vec3 lightSource = vec3(2.5 + sin(iTime), 2.5, -1.5);\n        float diffuseStrength = max(0.0, dot(normalize(lightSource),normal));\n        \n        vec3 diffuse = lightColor * diffuseStrength;\n        \n        //specular\n        lightColor = vec3(1.000,1.000,1.000);\n        \n        vec3 viewSource = normalize(ro);\n        vec3 reflectSource = normalize(reflect(-lightSource,normal));\n        float specularStrength = max(0.0, dot(viewSource, reflectSource));\n        specularStrength = pow(specularStrength, 64.0);\n        vec3 specular = specularStrength * lightColor;\n        \n        vec3 lighting = ambient * 0.4 + diffuse * 0.95 + specular * 0.6;\n        \n        color = vec3(baseColor.r,baseColor.g, baseColor.b) * lighting;\n        \n        //shadows\n        vec3 lightDirection = normalize(lightSource);\n        float distToLightSource = length(lightSource - p);\n        ro = p + normal * 0.1;\n        rd = lightDirection;\n        float dist = rayMarch(ro, rd, distToLightSource);\n        \n        if(dist < distToLightSource){\n            color = color * vec3(0.15);\n        }\n        \n        \n        //gamma correction\n        color = pow(color, vec3(1.0 / 2.2));\n        \n    }else{\n    \n        color = vec3(0.741,0.902,1.000);\n    }\n\n    return color;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float maxDistance)\n{\n    float dist = 0.0;\n\n    for (float i = 0.0; i < STEP_NUM; i++)\n    {\n        vec3 currentPos = ro + rd * dist;\n        float distSdf = map(currentPos)[0];\n\n        if (distSdf < MIN_SDF_DIST)\n        {\n            break;\n        }\n\n        dist = dist + distSdf;\n\n        if (dist > maxDistance)\n        {\n            break;\n        }\n    }\n\n    return dist;\n}\n\nfloat[5] map(vec3 p)\n{\n    float[5] sphere;\n    float[5] m = float[5](1.0,1.0,1.0,1.0,1.0);\n    \n    for(float i = 1.0; i < 25.0; i++){\n         //sphere\n        sphere = sdfSphere(p, vec3(sin(fract(rand(i)) * iTime) * 2.4, sin(rand(rand(i)) * iTime) * 0.9, 0.0), sin(rand(i)) * 0.03, randomColor(rand(i), i));\n        m = opSmoothUnion(m, sphere, 0.6);\n    }\n    \n\n    \n    //plane\n    float h = 1.3;\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    float[5] plane = float[5](sdfPlane(p, normal, h), 1.0, 1.0, 1.0, 1.0);\n    m = opSmoothUnion(m, plane, 0.6);\n    return m;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 d = vec2(0.001,0.0);\n    float gx = map(p + d.xyy)[0] - map(p - d.xyy)[0];\n    float gy = map(p + d.yxy)[0] - map(p - d.yxy)[0];\n    float gz = map(p + d.yyx)[0] - map(p - d.yyx)[0];\n    vec3 normal = vec3(gx,gy,gz);\n    return normalize(normal);\n}\n\nvec4 getColor(vec3 p){\n float[5] res = map(p);\n return vec4(res[1], res[2], res[3], res[4]);\n}\n\nfloat[5] opSmoothUnion(float[5] d1, float[5] d2, float k){\n\n    float h = clamp(0.5 + 0.5 * (d2[0] - d1[0]) / k, 0.0, 1.0);\n    vec4 color = vec4(mix(vec3(d2[1], d2[2], d2[3]), vec3(d1[1], d1[2], d1[3]), h), mix(d2[4],d1[4],h));\n    return float[5](mix(d2[0], d1[0], h) - k * h * (1.0-h), color.r, color.g, color.b, color.a);\n}\n  \n//shapes\nfloat[5] sdfSphere(vec3 p, vec3 center, float radius, vec4 color)\n{\n\n    return float[5](length(p - center) - radius, color.r, color.g, color.b, color.a);\n}\n\nfloat sdfPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}","name":"Image","description":"","type":"image"}]}