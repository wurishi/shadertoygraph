{"ver":"0.1","info":{"id":"sdXXzl","date":"1619114313","viewed":72,"name":"Rotational Velocity","username":"Jeaper","description":"Playing with saving rotation and rotational velocities in a texture.\nClick left or right to increase the velocity in that direction.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["rotate","shapes","rotation","velocity","click","interactable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define velocityFalloff 0.5\n#define velocityClickMultiplier 0.5\n\n// Pi, the ratio of a circle's circumference to its diameter.\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec2 rotateUV(vec2 uv, vec2 resolution, float angle) {\n    uv /= resolution; \n    angle *= M_PI*2.0;\n   \n    uv -= .5;\n    uv.y /= resolution.x / resolution.y;\n    float s = sin(angle), c = cos(angle);\n    uv *= mat2(c, s, -s, c);\n    uv.y *= resolution.x / resolution.y;\n    uv += .5;\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec4 data = texture(iChannel1,vec2(0.5,0.5));\n    // Render the rotated textures.\n    vec2 resolution = iChannelResolution[0].xy;\n    vec2 rotatedUV = rotateUV(fragCoord,resolution,1.0-data.x);\n    vec4 color = texture(iChannel0, rotatedUV);\n    \n    vec2 rotatedUV2 = rotateUV(fragCoord,resolution,1.0-data.z)-0.5;\n    rotatedUV2*= 0.95;\n    rotatedUV2+= 0.5;\n    vec4 color2 = texture(iChannel0, rotatedUV2);\n   \n   \n    fragColor = color * color2;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat sdRectangle (vec2 fragCoord, vec4 transform) {\n    float rect = step( abs(fragCoord.x-transform.x),transform.z);\n    rect *= step(abs(fragCoord.y - transform.y),transform.w);\n    return rect;\n}\n\nfloat sdCircle (vec2 uv, vec2 pos,float rad) {\n    float d = step(length(uv-pos), rad);\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The texture which we later rotate\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 center =  vec2(0.5,0.5);\n    float circ = sdCircle(uv, center,0.3);\n    color.rgb = mix(color.rgb, vec3(1.0,0.0,0.0), circ);\n    \n    float rect = sdRectangle(uv, vec4(center.x,center.y, 0.0569,0.20));\n    color.rgb = mix(color.rgb, vec3(1.0,1.0,1.0), rect);\n    \n   \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define velocityFalloff 0.1\n#define velocityClickMultiplier 0.12\n\n#define liquidThickness 1.7\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\nfloat fMod(float x, float y){\n  return x - y * trunc(x/y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 m = iMouse / iResolution.x;\n\n    float animation = iTimeDelta * 10.0;\n            \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel1, uv);\n    \n    // Holding the mouse button increases velocity\n    float newVelocity = velocityClickMultiplier*(m.x-0.5);\n    newVelocity *= step( 0.00001,m.z);\n    \n    // Store the shapes rotation and velocity in x and y\n    float velocity =((color.y*2.0)-1.0);\n    velocity += newVelocity;\n    velocity *= 1.0-(velocityFalloff * animation);\n    //This step is to decrease float weirdness when getting too low.\n    velocity *= step( 0.00001,abs(velocity));\n    // -1 == 0 | 0 == 0.5 | 1 == 1\n    color.y =  0.5 + (velocity/2.0);\n   \n    color.x = mod(color.x + (velocity * animation * 0.1),1.0);\n    \n    // store the second shapes rotation and velocity in z and w\n    float velocity2 =((color.w*2.0)-1.0);\n    //divide by the thickness of the liquid to get a slower acceleration and deceleration\n    velocity2 += newVelocity / liquidThickness;\n    velocity2 *= 1.0-((velocityFalloff / liquidThickness) * animation);\n     //This step is to decrease float weirdness when getting too low.\n    velocity2 *= step( 0.00001,abs(velocity2));\n    // -1 == 0 | 0 == 0.5 | 1 == 1\n    color.w =  0.5 + (velocity2/2.0);\n    color.z = mod(color.z + (velocity2 * animation * 0.1),1.0);\n    \n    fragColor = color;\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}