{"ver":"0.1","info":{"id":"ll2BDw","date":"1516113228","viewed":407,"name":"Advecting random velocity","username":"Ultraviolet","description":"Inspired by [url=https://www.shadertoy.com/view/XsdXWn]this[/url] entry.\n4-phased advection of a single-channel random texture.\nWeighting derived from the Bernstein polynomial B2,4.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["texture","advection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PERIOD\t1.\n\n\n// This comes from the Bernstein polynomial B2,4.\n// It is not perfect as Sum(w(t+i/4)) for i in [0,3] is not exactly 1.\n// I'm opened for suggestions !\nfloat weight(float t)\n{\n    t = mod(t, 1.);\n    return 7.5*t*t*(1.-t)*(1.-t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 buf = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float t = iTime/PERIOD;\n    float val = weight(t)*buf.x + weight(t+.25)*buf.y + weight(t+.5)*buf.z + weight(t+.75)*buf.w;\n        \n    fragColor = vec4(val);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PERIOD\t1.\n#define EPSILON\t0.05\n\n#define SPEED_EV\t(1.5*iMouse.x/iResolution.x)\n#define SPEED_AM\t(0.5+iMouse.y/iResolution.y)\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0*fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// from https://www.shadertoy.com/view/Xsl3Dl\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n\n\nvec2 speed(vec2 uv)\n{\n    float ratio = iResolution.y/iResolution.x;\n    uv = uv*10.*vec2(1., ratio);\n    return SPEED_AM*vec2(noise(vec3(uv, iTime*SPEED_EV)), noise(vec3(uv + vec2(12.10135, 1354.2435), iTime*SPEED_EV)));\n}\n\n\n#define h 2.\nvec2 RK4(vec2 p){\n    vec2 r = iResolution.xy;\n    vec2 k1 = speed(p/r);\n    \n    //return h*k1;\n    \n    vec2 k2 = speed((p-0.5*h*k1)/r);\n    vec2 k3 = speed((p-0.5*h*k2)/r);\n    vec2 k4 = speed((p-h*k3)/r);\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\n\nfloat noiseTexture(vec2 p, float t)\n{\n    p *= .5;\n    float val = texture(iChannel1,p.xy + t).x;\n    \n    if(texelFetch(iChannel2, ivec2(32,2),0).x>.5)\n    {\n        val *= .5;\n        val += texture(iChannel1,p.xy*2. + t*2.).x *.25;\n        val += texture(iChannel1,p.xy*4. + t*4.).x *.125;\n        val += texture(iChannel1,p.xy*8. + t*8.).x *.0625;\n    }\n    \n    return val;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n\tvec2 r  = iResolution.xy;\n\tvec2 uv = C / r;\n    \n    vec4 buf = texture(iChannel0,(C-RK4(C))/r);\n    \n    float val0, val1, val2, val3;\n    \n    if(iTime < EPSILON)\n    {\n        val0 = noiseTexture(uv, 0.);\n        val1 = val0;\n        val2 = val0;\n        val3 = val0;\n    }\n    else\n    {\n        val0 = buf.x;\n        val1 = buf.y;\n        val2 = buf.z;\n        val3 = buf.w;\n    }\n    \n    float t = iTime/PERIOD;\n    if(mod(t, 1.0) < EPSILON)\n    {\n        val0 = noiseTexture(uv, t);\n    }\n    \n    if(mod(t+.25, 1.0) < EPSILON)\n    {\n        val1 = noiseTexture(uv, t);\n    }\n    \n    if(mod(t+.5, 1.0) < EPSILON)\n    {\n        val2 = noiseTexture(uv, t);\n    }\n    \n    if(mod(t+.75, 1.0) < EPSILON)\n    {\n        val3 = noiseTexture(uv, t);\n    }\n    \n    O = vec4(val0, val1, val2, val3);\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}