{"ver":"0.1","info":{"id":"MlyBRG","date":"1542916610","viewed":532,"name":"4.8^2 Truchet","username":"fizzer","description":"Truchet tiling using the semi-regular tiling made of octagons and squares. This is based on the idea that any regular polygon with an even number of sides can be used as a Truchet tile.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["truchet","tiling","octagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Truchet tiling using the semi-regular tiling made of octagons and squares.\n// This is based on the idea that any regular polygon with an even number of sides can be used\n// as a Truchet tile.\n//\n// Inspired by this JavaScript canvas version here: http://somethingorotherwhatever.com/truchet-polygons/\n//\n// The side connection tables were pre-generated using my own rather brute-force program.\n//\n// 4.6.12 version is here: https://www.shadertoy.com/view/llyBRG\n//\n// Weaved version is here: https://www.shadertoy.com/view/3dVSRm\n//\n\nfloat pi = 3.141592653589;\n\nfloat hash(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n}\n\n/*\n// Returns the origin and radius of a circle intersecting a and b, with tangents\n// at a and b pointing towards vec2(0). This is for drawing the circular arcs.\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r)\n{\n    float th = acos(dot(normalize(a), normalize(b))) / 2.;\n    float adj = length(a);\n    r = tan(th) *adj;\n    o = normalize((a + b) / 2.) * sqrt(r * r + adj * adj);\n}\n*/\n\n// (via comments on https://www.shadertoy.com/view/wdBSRm):\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n// Pixel width for anti-aliasing.\nfloat w;\n\n// Draws a line or arc connecting a and b inside a polygon.\nfloat l(vec2 p, vec2 a, vec2 b)\n{\n    if(dot(normalize(a), normalize(b)) < -.99999)\n    {\n        float d = distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n        return smoothstep(0.03, 0.03 - w * 2., d - .04);\n    }\n\n    vec2 o;\n    float r;\n    solveCircle(a, b, o, r);\n    return smoothstep(0.03, 0.03 - w * 2., abs(distance(p, o) - r) - .04);\n}\n\n\n// Array of unique octagon side connections without overlaps.\nconst int arr8[4 * 8] = int[4 * 8](\n    1, 2 ,  3, 4 ,  5, 6 ,  7, 8, \n    1, 2 ,  3, 4 ,  5, 8 ,  6, 7, \n    1, 2 ,  3, 8 ,  4, 5 ,  6, 7, \n    1, 2 ,  3, 8 ,  4, 7 ,  5, 6\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 8.;\n\n    w = max(length(dFdx(p)), length(dFdy(p)));\n\n    p.x += iTime / 3.;\n\n    float th = 2. * pi / 8.;\n\n    float el = tan(2. * pi / 16.);\n    float hyp = sqrt(1. - el * el);\n    float d = cos(2. * pi / 16.) * hyp;\n\n    vec2 ip = floor(p - .5) * 2.;\n    vec2 fpa = abs(fract(p) - .5);\n    vec2 fp = fract(p - .5) - .5;\n\n    float a = 0.;\n    float b = hash(ip);\n    float c = 0.;\n\n    vec3 col = vec3(1, 1, 0);\n\n    if(fpa.x + fpa.y < (1. - sqrt(2.) / 2.))\n    {\n        // Square.\n        ip = floor(p) * 2. +1.;\n        b = hash(ip);\n        fp = fract(p) - .5;\n        if(b > .5)\n            fp = fp.yx * vec2(1, -1);\n\n        a += l(fp, normalize(vec2(-1, 1)) * .5 * d / 2., normalize(vec2(1, 1)) * .5 * d / 2.);\n        a += l(fp, normalize(vec2(1, -1)) * .5 * d / 2., normalize(vec2(-1, -1)) * .5 * d / 2.);\n        c = max(c, smoothstep((1. - sqrt(2.) / 2.) - w * sqrt(2.) * 2., (1. - sqrt(2.) / 2.), max(abs(fp.x + fp.y), abs(fp.y - fp.x))));\n    }\n    else\n    {\n        // Octagon.\n        float th = floor(mod(b,.25)/.25*8.) * pi * 2. / 8.;\n        fp *= mat2(cos(th), sin(th), -sin(th), cos(th));\n        col = mix(vec3(0, .5, 0), vec3(.25, .25, 1), mod(ip.x / 2. + ip.y / 2., 2.));\n\n        th = pi * 2. / 8.;\n\n        int i = int(floor(b * 3.999));\n\n        for(int j = 0; j < 8; j += 2)\n        {\n            int ia = arr8[i * 8 + j + 0] - 1;\n            int ib = arr8[i * 8 + j + 1] - 1;\n            a += l(fp, vec2(cos(th * float(ia)), sin(th * float(ia))) / 2., vec2(cos(th * float(ib)), sin(th * float(ib))) / 2.);\n        }\n\n        float d = max(abs(fp.x + fp.y) / sqrt(2.), abs(fp.y - fp.x) / sqrt(2.));\n        c = max(c, smoothstep(.5 - w * 2., .5, max(d, max(abs(fp.x), abs(fp.y)))));\n    }\n\n    // Shade.\n    col = mix(col, vec3(1), .3) + .1;    \n    col = mix(col, vec3(0), c);\n\n    float l = 1. - (min(fract(iTime / 4.) * 2., 2. - 2. * fract(iTime / 4.)) - .5) * 16.;\n\n    fragColor.rgb = mix(vec3(.8), col, smoothstep(0., 1., l));\n\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), a);\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}