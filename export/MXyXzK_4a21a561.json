{"ver":"0.1","info":{"id":"MXyXzK","date":"1720178885","viewed":106,"name":"Gigeresque 1","username":"aidanwyber","description":"Effects from height maps and SDFs. Based on the work of H. R. Giger.\nFullscreen recommended. Hold ALT+Left Arrow to take the lift down to hell.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","effect","h","r","artist","giger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 2\n\n#define PI 3.14159\n#define TIME iTime*1.\n#define sat(x) clamp(x, 0., 1.)\n#define screen(a, b) (1. - (1.-a) * (1.-b))\n#define nmc(x) (-cos(x)*0.5+0.5)\n\n#define STEEPNESS 0.8\n\n\nconst vec2 e = vec2(0.001, 0.);\n\nvec2 uv, origPos;\n\nfloat smin( float a, float b, float k ) {\n    // iq, sigmoid\n    k *= 0.301029995;//log(2.0);\n    float x = b-a;\n    return a + x/(1.0-exp2(x/k));\n}\n\nfloat circMap(float x) {\n    return sqrt(1. - x*x);\n}\n\nvec2 sdRidges(vec2 pos) {\n    pos.y *= 20.;\n    float dom = 17.;\n    \n    float y = pos.y + sin(pos.x + TIME * 0.2 + pos.y * 0.45) * 0.5;\n    y = mod(y, dom) - dom/2.;\n    float effect = abs(y) / (dom/2.);\n    \n    float chr = effect;//abs(y) <= 1. ? 0. : 1.; // Y\n    \n   // float topQ = 0.3;\n  \n    float bumps = nmc(effect * PI * 2.) * effect;\n    chr = 1.-effect;\n    \n    y = exp(-(-effect)*(-effect) * 10.);// * effect;\n    y += bumps * 0.9;\n  \n    y = sat(y);\n    return vec2(y, chr);\n}\n\n\n\nvec2 map(vec2 pos) {\n\n    float skewAngle = pos.y + TIME * 0.1 + pos.x;\n    float skewAmp = 0.06;\n    pos.y += sin(skewAngle) * skewAmp;\n    pos.x += sin(skewAngle) * cos(skewAngle) * skewAmp * -0.5;\n\n    float f = 20. * PI;\n    float v = 0.;\n    float totFalloff = 0.;\n    \n    float chroma = 0.;\n    \n    for (int i = 0; i < 3; i++) {\n        float falloff = 1. / (float(i) + 1.);\n        v += (\n                (\n                    cos(pos.x * 2. * f) +\n                    cos(pos.y * 0.6 * f)\n                )/2. * 0.5 + 0.5\n            ) * falloff;\n        totFalloff += falloff;\n        f *= 1.1;\n        \n        chroma += v * falloff;\n    }\n    v /= totFalloff;\n    chroma /= totFalloff;\n    v = sat(v);\n    v = pow(v, 2.) * 0.3;\n    \n    vec2 sc = sdRidges(pos);\n    vec2 sc2 = sdRidges(pos * vec2(1., 4.)) * 0.33;\n    sc = -vec2(\n        smin(-sc.x, -sc2.x, 0.04), // smax\n        smin(-sc.y, -sc2.y, 0.04)  // smax\n        );\n    \n    v = screen(v, sc.x * 0.6);\n    \n    //v = mix(v, 1., sc.x);\n    \n    //chroma = screen(chroma, sc.y);\n    chroma = mix(chroma, sc.y, 0.5);\n    chroma = mix(chroma, pow(abs(uv.x * 2. - 1.) * 0.5, 0.66), 1.); // gradient from center x\n    \n    v = sat(v);\n    return vec2(v, chroma);\n}\n\n\nvec2 gradient(vec2 pos) {\n    return vec2(\n    map(pos + e.xy).x,\n    map(pos + e.yx).x\n    ) - map(pos).x;\n}\n\n\nvec3 normal(vec2 pos) {\n    vec2 grad = gradient(pos) * STEEPNESS;\n    return normalize(cross(\n        vec3(e.x, 0., grad.x),\n        vec3(0., e.x, grad.y)\n    ));\n}\n\n\nvec3 gigerPalette(float lum, float chroma) {\n    const vec3 dark = vec3(0.05, 0.04, 0.07);\n    const vec3 midB = vec3(0.49, 0.51, 0.58);\n    //const vec3 midY = vec3(0.53, 0.49, 0.47);\n    const vec3 midY = vec3(0.373,0.357,0.349);\n    const vec3 light = vec3(0.98, 0.98, 1.00);\n    \n    lum = sat(lum);\n    chroma = sat(chroma);\n    \n    vec3 mid = mix(midB, midY, chroma);\n    vec3 col = lum < 0.5 ? \n        mix(dark, mid, lum * 2.) :\n        mix(mid, light, (lum - 0.5) * 2.);\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 avgCol = vec3(0.);\n    for (int nn = 0; nn < AA; nn++) {\n        for (int mm = 0; mm < AA; mm++) {\n            vec2 aa = vec2(float(nn), float(mm)) / float(AA);\n        \n            uv = (fragCoord + aa) / iResolution.xy;\n            vec2 pos = (fragCoord + aa - iResolution.xy/2.) / iResolution.y * 2.;\n            origPos = pos;\n            pos.y -= TIME * 0.07;\n            pos.x -= TIME * 0.005;\n            vec3 pos3 = vec3(origPos, 0.);\n\n            vec2 mapped = map(pos);\n            float v = mapped.x;\n            float chroma = mapped.y;\n\n            vec3 n = normal(pos);\n\n            float th = TIME * PI * 2. * 0.1;\n            vec2 timeCirc = vec2(cos(th), sin(th));\n\n            vec3 lightDir = normalize(vec3(timeCirc, 1.));\n            float spec = max(dot(lightDir, n), 0.);\n\n            //v = v * spec;\n\n            float vignette = 1. - length(uv - vec2(0.5)) / length(vec2(0.5));\n            spec = mix(spec, mix(spec, 1., 0.1), vignette);\n\n            float highl = pow(v, 1.5) * 1.; // airbrush effect? bloom-ish?\n            float highl2 = pow(spec, 100.);\n\n            v *= spec * 0.5;\n            v += highl + highl2; \n            v *= 0.8;\n\n            v = pow(v, mix(0.25, 1.5, nmc(iTime * 0.25 + pos.x * 0.25)));\n\n            vec3 col = gigerPalette(v, chroma);\n\n            vignette = pow(vignette, 1.);\n            col *= mix(0.2, 1., vignette);\n\n            //col = vec3(chroma);\n\n            //col = vec3(v);\n            //col = vec3(highl);\n            //col = n;\n            avgCol += col;\n        }\n    }\n    avgCol /= float(AA * AA);\n    \n    fragColor = vec4(avgCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}