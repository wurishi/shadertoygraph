{"ver":"0.1","info":{"id":"M3BfDc","date":"1730009717","viewed":40,"name":"mandelbrot 3D 101 ","username":"kukovisuals","description":"mandelbrot 3D simple ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","mandelbrot3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fractal Shader: mandelbrot Rendering with Light Blue Coloring\n\n// Constants for the mandelbrot fractal\nconst int MAX_STEPS = 100;          // Maximum number of ray marching steps\nconst float MAX_DIST = 100.0;       // Maximum distance for ray marching\nconst float MIN_DIST = 0.001;       // Minimum distance to consider a hit\nconst int MAX_ITERATIONS = 8;       // Maximum iterations for fractal calculation\nconst float BAILOUT = 2.0;          // Escape radius\nconst float POWER = 8.0;            // Power of the Mandelbulb fractal\n\n// Distance estimator for the Mandelbulb fractal\nfloat DE_Mandelbulb(vec3 pos) {\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = length(z);\n    float theta, phi, zr;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(z);\n        if (r > BAILOUT) break;\n        \n        // Convert to spherical coordinates\n        theta = acos(z.z / r);\n        phi = atan(z.y, z.x);\n        zr = pow(r, POWER - 1.0);\n        \n        // Calculate the new position\n        dr = pow(r, POWER - 1.0) * POWER * dr + 1.0;\n        float sinTheta = sin(POWER * theta);\n        float cosTheta = cos(POWER * theta);\n        float sinPhi = sin(POWER * phi);\n        float cosPhi = cos(POWER * phi);\n        z = zr * vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n        z += pos;\n    }\n    \n    // Distance estimation formula\n    return 0.5 * log(r) * r / dr;\n}\n\n// Calculate normal for lighting using numerical gradient\nvec3 getNormal(vec3 p) {\n    float eps = 0.0005;\n    vec3 grad;\n    grad.x = DE_Mandelbulb(p + vec3(eps, 0.0, 0.0)) - DE_Mandelbulb(p - vec3(eps, 0.0, 0.0));\n    grad.y = DE_Mandelbulb(p + vec3(0.0, eps, 0.0)) - DE_Mandelbulb(p - vec3(0.0, eps, 0.0));\n    grad.z = DE_Mandelbulb(p + vec3(0.0, 0.0, eps)) - DE_Mandelbulb(p - vec3(0.0, 0.0, eps));\n    return normalize(grad);\n}\n\n// Main ray marching function\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 p) {\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        p = ro + rd * totalDist;\n        float dist = DE_Mandelbulb(p);\n        if (dist < MIN_DIST || totalDist > MAX_DIST) break;\n        totalDist += dist;\n    }\n    return totalDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -4.0); // Camera position\n    vec3 rd = normalize(vec3(uv, 6.5)); // Ray direction\n    \n    // Rotate the scene over time\n    float angle = iTime * 0.05;\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    mat3 rotY = mat3(\n        cosAngle, 0.0, sinAngle,\n        0.0,      1.0,      0.0,\n        -sinAngle, 0.0, cosAngle\n    );\n    ro = rotY * ro;\n    rd = rotY * rd;\n    \n    // Ray marching\n    vec3 p;\n    float totalDist = rayMarch(ro, rd, p);\n    \n    // Shading and coloring\n    vec3 color = vec3(0.0);\n    if (totalDist < MAX_DIST) {\n        // Calculate normal for lighting\n        vec3 normal = getNormal(p);\n        // Light direction\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n        // Diffuse lighting\n        float diff = max(dot(normal, lightDir), 0.0);\n        // Light blue color\n        vec3 baseColor = vec3(0.2, 0.5, 0.9);\n        color = diff * baseColor;\n        // Ambient lighting\n        color += baseColor * 0.2;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}