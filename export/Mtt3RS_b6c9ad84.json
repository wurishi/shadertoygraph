{"ver":"0.1","info":{"id":"Mtt3RS","date":"1483527000","viewed":1207,"name":"sand world","username":"raziel","description":"Messing around with volumetric rendering, trying to understand and implement the info from Frostbite's physically-based volumetric rendering presentation. Building on top of my previous sand shader, making a dust/sand storm.","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["noise","volumetric","scattering","media","sand","participating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- thanks to iq for all the ray-marching sdf info and awesomeness\n\nfloat Rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat ValueNoise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 s = smoothstep(0.0, 1.0, f);\n    float nx0 = mix(Rand(i + vec2(0.0, 0.0)), Rand(i + vec2(1.0, 0.0)), s.x);\n    float nx1 = mix(Rand(i + vec2(0.0, 1.0)), Rand(i + vec2(1.0, 1.0)), s.x);\n    return mix(nx0, nx1, s.y);\n}\n\nfloat Intersect(vec3 p)\n{\n    // --- value noise for sand\n    float totalNoise = 0.0;\n    vec2 planePos = p.xz * 0.35;\n    float ampl = 0.5;\n    float freq = 1.0;\n    for (int i = 0; i < 3; ++i)\n    {\n        totalNoise += ValueNoise(planePos * freq) * ampl;\n        ampl *= 0.5;\n        freq *= 2.5;\n        planePos = planePos * mat2(0.5, -0.866, 0.866, 0.5) * 0.65;\n        planePos += vec2(2.5, 4.8);\n    }\n    \n    float dist = p.y - totalNoise * 2.0;\n    return dist;\n}\n\nvec3 ComputeNormal(vec3 pos)\n{\n    vec3 eps = vec3(0.01, 0.0, 0.0);\n    vec3 pos00 = (pos + eps.xyy);\n    vec3 pos01 = (pos - eps.xyy);\n    vec3 pos10 = (pos + eps.yxy);\n    vec3 pos11 = (pos - eps.yxy);\n    vec3 pos20 = (pos + eps.yyx);\n    vec3 pos21 = (pos - eps.yyx);\n\tvec3 normal = vec3(Intersect(pos00) - Intersect(pos01), \n                       Intersect(pos10) - Intersect(pos11), \n                       Intersect(pos20) - Intersect(pos21));\n\treturn normalize(normal);\n}\n\nfloat GetDensityLOD0(in vec3 p)\n{\n    float freq = 1.0;\n    float ampl = 0.5;\n    float noiseAccum = 0.0;\n    for (int i = 0; i < 4; ++i)\n    {\n        noiseAccum += ValueNoise((p.xz * 0.5 - iTime * 2.0) * freq) * ampl;\n        ampl *= 0.5;\n        freq *= 2.0;\n    }\n    ampl = 0.1;\n    freq = 0.5;\n    for (int i = 0; i < 2; ++i)\n    {\n        noiseAccum += ValueNoise((p.xz * 5.5 - iTime * 2.0) * freq) * ampl;\n        ampl *= 0.5;\n        freq *= 2.0;\n    }\n    ampl = 0.1;\n    freq = 8.5;\n    noiseAccum += ValueNoise((p.xz * 4.5 - iTime * 5.0) * freq) * ampl;\n\n    float fog = clamp(clamp(noiseAccum, 0.0, 1.0) * 1.15 - p.y * 0.45, 0.0, 1.0) * 2.0;\n    return clamp(0.002 + fog * (fog + 1.0), 0.0, 1.0);\n}\n\nfloat GetDensityLOD1(in vec3 p)\n{\n    float freq = 1.0;\n    float ampl = 0.5;\n    float noiseAccum = 0.0;\n    for (int i = 0; i < 2; ++i)\n    {\n        noiseAccum += ValueNoise((p.xz * 0.5 - iTime * 2.0) * freq) * ampl;\n        ampl *= 0.5;\n        freq *= 2.0;\n    }\n    ampl = 0.1;\n    freq = 0.5;\n    noiseAccum += ValueNoise((p.xz * 5.5 - iTime * 2.0) * freq) * ampl;\n\n    float fog = clamp(clamp(noiseAccum, 0.0, 1.0) * 1.15 - p.y * 0.3, 0.0, 1.0) * 2.0;\n    return clamp(0.002 + fog * (fog + 1.0), 0.0, 1.0);\n}\n\nvec3 GetVolumetricShadow(in vec3 p, in vec3 L)\n{\n\tvec3 shadow = vec3(0.36, 0.2, 0.176) * 8.0;\n    const float stopValue = 2.0;\n    for (float i = 0.5; i < stopValue; i += 1.0)\n    {\n        vec3 pos = p + L * (i / stopValue);\n        float density = GetDensityLOD1(pos);\n        shadow *= exp(-density * (i / stopValue));\n    }\n    return shadow;\n}\n\n// --- trying to implement the physically based volumetric rendering stuff from frostbite\n// --- http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\nvoid Integrate(in vec3 p, \n               in vec3 L,\n               in vec3 V,\n               in float density, \n               in float sdfDist, \n               in vec3 lightColor,\n               inout float transmittance, \n               inout vec3 inscatteredLight)\n{\n    transmittance *= exp(-density * sdfDist);\n    float g = 0.2;\n    float phaseHG = (1.0 / (4.0 * 3.14)) * ((1.0 - g * g) / (pow((1.0 + g * g - 2.0 * g * max(dot(L, V), 0.0)), 3.0 / 2.0)));\n    vec3 shadow = GetVolumetricShadow(p, L);\n    vec3 lscat = lightColor * shadow * phaseHG;\n    inscatteredLight += density * transmittance * lscat * sdfDist;\n}\n\nvec2 RayMarchSDFAndVolume(in vec3 ro, in vec3 rd, in vec3 lightDirection, out vec4 scattering)\n{\n    float t = 0.0;\n    float tmax = 120.0;\n    const int numSteps = 150;\n    float sdfDist = 0.0;\n    float stepsTaken = 0.0;\n    float density = 0.0;\n    float transmittance = 1.0;\n    vec3 inscatteredLight = vec3(0.0);\n    vec3 L = lightDirection;\n    vec3 lightColor = vec3(1.0, 0.8, 0.6) * 10.0;\n    \n    // --- two LOD levels\n    for(int i = 0; i < 100; ++i)\n    { \n    \tvec3 p = ro + rd * t;\n        \n        sdfDist = Intersect(p); \n        if (sdfDist < 0.001) { break; }\n        \n        density = min(GetDensityLOD0(p), sdfDist);\n        if (density > 0.99) { break; }\n        \n        Integrate(p, L, -rd, density, sdfDist, lightColor, transmittance, inscatteredLight);\n        t += max(0.05, sdfDist * 0.2); \n        stepsTaken++;\n    }\n    for(int i = 0; i < 100; ++i)\n    { \n    \tvec3 p = ro + rd * t;\n        \n        sdfDist = Intersect(p); \n        if (sdfDist < 0.001) { break; }\n        \n        density = min(GetDensityLOD1(p), sdfDist);\n        if (density > 0.99) { break; }\n        \n        Integrate(p, L, -rd, density, sdfDist, lightColor, transmittance, inscatteredLight);\n        t += max(0.05, sdfDist * 0.2); \n        stepsTaken++;\n    }\n      \n    scattering = vec4(inscatteredLight, transmittance);\n    return vec2(t, stepsTaken / float(numSteps));\n}\n\n// --- some rendering tricks for sand from \n// --- http://advances.realtimerendering.com/s2012/thatgamecompany/SandRenderingInJourney_thatgamecompany.pptx\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    vec3 tint = (1.0 - rd.yyx);\n    tint = sqrt(tint);\n    vec3 skyColor = tint * vec3(0.5, 0.9, 0.98);\n    vec3 lightDirection = normalize(vec3(1.0, 0.5, -1.0));\n    \n    vec4 scattering = vec4(0.0);\n    vec2 res = RayMarchSDFAndVolume(ro, rd, lightDirection, scattering);\n    vec3 color = vec3(0.0);\n    {\n        vec3 pn = ro + res.x * rd;\n        vec3 n1 = ComputeNormal(pn);\n        \n        // --- mess around with normals and noise for sand grainy look\n        vec3 n2 = normalize(textureLod(iChannel0, pn.xz * 3.0, 0.0).rgb);\n        vec3 nn1 = normalize(mix(n1, n2, 0.2));\n        vec3 nn2 = normalize(mix(n1, n2, 0.4));\n        \n        // --- sand wavy normals\n        vec3 wv = vec3(sin(pn.xz * 4.0), 1.0);\n        wv = vec3(pn.x * 4.0 + wv.y);\n        wv = vec3(mod(wv.x, 1.1)) * 0.6 + 0.4;\n        \n        nn1 = normalize(mix(nn1, wv, 0.3));\n        nn1.y *= 0.3;\n        vec3 ndotl = clamp(2.0 * dot(nn1, lightDirection) * (1.0 - res.y), 0.0, 1.0) * vec3(0.55, 0.7, 0.6) + vec3(0.45, 0.3, 0.4);\n        color = ndotl * vec3(0.909, 0.686, 0.415) * 1.2;\n        color += (1.0 - ndotl) * vec3(0.36, 0.2, 0.176);\n        \n        nn2 = normalize(mix(nn2, wv, 0.3));\n        nn2.y *= 0.3;\n        float ndotv = clamp(dot(nn2, -rd), 0.0, 1.0);\n        color += pow(1.0 - ndotv, 5.0) * vec3(1.0, 0.8, 0.6) * clamp(dot(nn2, lightDirection), 0.0, 1.0);\n        color *= pow(tint, vec3(0.7));\n        \n        color = color * scattering.w + scattering.xyz * sqrt(tint);\n    }\n    color = mix(skyColor, color, 1.0 - smoothstep(res.x, 0.0, 100.0));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xi[5];\n    xi[0] = vec2(0.0, 0.0);\n    xi[1] = vec2(0.25, 0.0);\n    xi[2] = vec2(-0.25, 0.0);\n    xi[3] = vec2(0.0, 0.25);\n    xi[4] = vec2(0.0, -0.25);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec3 cp = vec3(0.0, 2.9 + mo.y, 5.0 - iTime);\n    vec3 cu = normalize(vec3(0.0, 0.7, -0.5));\n    vec3 cr = vec3(1.0, 0.0, 0.0);\n    vec3 cf = normalize(cross(cu, cr));\n    float fl = 1.1;\n    \n    vec3 col = vec3(0.0);\n    const int nx = 1;\n    for (int i = 0; i < nx; ++i)\n    {\n        vec2 c_ss = (fragCoord.xy + xi[i]) / iResolution.xy;\n        vec2 c_cs = 2.0 * c_ss - 1.0;\n        c_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 rd = normalize(cf * fl + cr * c_cs.x + cu * c_cs.y);\n        col += Render(cp, rd);\n    }\n    col /= float(nx);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}