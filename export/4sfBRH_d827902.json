{"ver":"0.1","info":{"id":"4sfBRH","date":"1494746997","viewed":83,"name":"MyShader","username":"karanbhagat","description":"Raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: karanbhagat\n//Sphere struct\nstruct Sphere {\n    float radius;\n\tvec3 position;\n};\n\n// Global Object Definitions\nSphere sphere1 = Sphere(0.65, vec3(0.1, 1.0, -1.0));\nSphere sphere2 = Sphere(0.7, vec3(1.4, 1.0, 0.2));\n\n//Limited Plane intersection\nfloat intersectPlaneLimited(vec3 rayOrigin, vec3 rayDirection) {\n    float result = -rayOrigin.y/rayDirection.y;\n    vec3 position = rayOrigin + result*rayDirection;\n    if(position.x > 3.0 || position.x < -5.0) {\n        return -1.0;\n    }\n    return result;\n}\n\nvec3 nPlane() {\n\treturn vec3(0.0, 1.0, 0.0);\n}\n\n//Sphere intersection\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDirection, Sphere sphere) {\n    vec3 objectCollision = rayOrigin - sphere.position;\n    float b = dot(objectCollision, rayDirection);\n   \tfloat c = dot(objectCollision, objectCollision) - sphere.radius*sphere.radius;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    float t = -b - sqrt(h);\n    return t;\n}\n\nvec3 nSphere(vec3 pos, Sphere sphere) {\n\treturn (pos - sphere.position) / sphere.radius;\n}\n\n\n// returns the id of the object hit\n// simultaneously sets the time that an object was hit\nfloat intersect(in vec3 ro, in vec3 rayDir, out float resT) {\n\tresT = 10000.0; // infinity kinda\n    float id = -1.0; // the object hit\n    float tsphere1 = intersectSphere(ro, rayDir, sphere1);\n    float tsphere2 = intersectSphere(ro, rayDir, sphere2);\n    float tplane = intersectPlaneLimited(ro, rayDir);\n    if(tsphere1 > 0.0) {\n    \tid = 2.0; // intersected with sphere1\n        resT = tsphere1; // setting the time value the sphere is at\n    }\n    if(tsphere2 > 0.0 && tsphere2 < resT) {\n    \tid = 3.0;\n        resT = tsphere2;\n    }\n    if(tplane > 0.0 && tplane < resT) {\n    \tid = 1.0;\n        resT = tplane;\n    }\n    \n    return id;\n}\n\nvec3 calColorRec2(vec3 rayOr, vec3 rayDir) {\n    float t;\n    float id = intersect(rayOr, rayDir, t);\n    \n    vec3 pos = rayOr + rayDir*(t);\n    // need this to prevent shelf shading\n    vec3 posShadow = rayOr + rayDir*(t-0.0001);\n    vec3 nor;\n    vec3 reflectEye; // rayDir is the eye to position\n    float time = 0.5*iTime;\n    //vec3 lightPos = vec3(3.0*sin(time), 3.0, 3.0*cos(time));\n    vec3 lightPos = vec3(1.5, 5.0, 6.0);\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 lightCol = vec3(1.0, 0.9, 0.7);\n    float specCoeff, diffCoeff, ambCoeff;\n    float spec, diff, shadow;\n    vec3 amb;\n    \n    // set material of object\n    vec3 material;\n    if(id > 0.5 && id < 1.5) { // hit the plane\n        nor = nPlane();\n        reflectEye = reflect(normalize(rayDir), nor);\n        // material color\n        float tileSize = 2.0;\n        float tile = mod(floor(tileSize*pos.x) + floor(tileSize*pos.z), 2.0);\n        if(tile > 0.0) {\n            material = vec3(0.9, 0.1, 0.1);\n        } else {\n            material = vec3(0.9, 0.9, 0.1);\n        }\n        \n    } else if(id > 1.5 && id < 2.5) { // hit the sphere1\n        nor = nSphere(pos, sphere1);\n        reflectEye = reflect(normalize(rayDir), nor);\n        // material color\n    \tmaterial = vec3(0.8, 0.1, 0.3);\n    } else if(id > 2.5 && id < 3.5) { // hit the sphere2\n        nor = nSphere(pos, sphere2);\n        reflectEye = reflect(normalize(rayDir), nor);\n       \t//vec3 reflectEye = refract(rayDir, -nor, 1.125/1.00029);\n        material = vec3(0.0, 0.0, 0.0);\n    } else { // background\n        // cornflower blue\n    \treturn vec3(0.0, 0.0, 0.0);\n    }\n\n    // calculate lighting\n    vec3 brdf;\n    ambCoeff = 0.1;\n    diffCoeff = .9454545454;\n    specCoeff = .3545454545;\n    // hard shadow method\n    float trashTime; // this isn't going to be used right now\n    shadow = intersect(posShadow, lightDir, trashTime);\n    if(shadow > 0.0) {\n        shadow = 0.1;\n    } else {\n    \tshadow = 1.0;\n    }\n    amb = ambCoeff*vec3(1.0, 1.0, 1.0);\n    diff = shadow*diffCoeff*clamp(dot(nor,lightDir), 0.0, 1.0);\n    spec = shadow*specCoeff*pow(clamp(dot(reflectEye,lightDir), 0.0, 1.0), 30.0);\n    brdf = material*lightCol*(diff+spec);\n    brdf += amb;\n    return brdf;\n}\n\nvec3 calColorRec(vec3 rayOr, vec3 rayDir) {\n    float t;\n    float id = intersect(rayOr, rayDir, t);\n    \n    vec3 pos = rayOr + rayDir*(t);\n    // need this to prevent shelf shading\n    vec3 posShadow = rayOr + rayDir*(t-0.0001);\n    vec3 nor;\n    vec3 reflectEye; // rayDir is the eye to position\n    float time = 0.5*iTime;\n    //vec3 lightPos = vec3(3.0*sin(time), 3.0, 3.0*cos(time));\n    vec3 lightPos = vec3(1.5, 5.0, 6.0);\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 lightCol = vec3(1.0, 0.9, 0.7);\n    float specCoeff, diffCoeff, ambCoeff;\n    float spec, diff, shadow;\n    vec3 amb;\n    \n    // set material of object\n    vec3 material;\n    if(id > 0.5 && id < 1.5) { // hit the plane\n        nor = nPlane();\n        reflectEye = reflect(normalize(rayDir), nor);\n        // material color\n        float tileSize = 2.0;\n        float tile = mod(floor(tileSize*pos.x) + floor(tileSize*pos.z), 2.0);\n        if(tile > 0.0) {\n            material = vec3(0.9, 0.1, 0.1);\n        } else {\n            material = vec3(0.9, 0.9, 0.1);\n        }\n        // float marbleCol = fbm(pos.xz + .5*fbm(pos.xz + .2*fbm(pos.xz)));\n        // material = vec3(marbleCol);\n        \n    } else if(id > 1.5 && id < 2.5) { // hit the sphere1\n        nor = nSphere(pos, sphere1);\n        reflectEye = reflect(normalize(rayDir), nor);\n        // material color\n    \tmaterial = vec3(0.8, 0.1, 0.3);\n    } else if(id > 2.5 && id < 3.5) { // hit the sphere2\n        nor = nSphere(pos, sphere2);\n        //reflectEye = reflect(normalize(rayDir), nor);\n       \tvec3 reflectEye = refract(rayDir, -nor, 1.125/1.00029);\n        vec3 refractColor = calColorRec2(posShadow, reflectEye);\n        // material color\n        material = refractColor;\n        // material color\n        //material = vec3(0.2, 0.1, 0.8);\n    } else { // background\n        // cornflower blue\n    \treturn vec3(0.0, 0.0, 0.0);\n    }\n\n    // calculate lighting\n    vec3 brdf;\n    ambCoeff = 0.1;\n    diffCoeff = .9454545454;\n    specCoeff = .3545454545;\n    // hard shadow method\n    float trashTime; // this isn't going to be used right now\n    shadow = intersect(posShadow, lightDir, trashTime);\n    if(shadow > 0.0) {\n        shadow = 0.1;\n    } else {\n    \tshadow = 1.0;\n    }\n    amb = ambCoeff*vec3(1.0, 1.0, 1.0);\n    diff = shadow*diffCoeff*clamp(dot(nor,lightDir), 0.0, 1.0);\n    spec = shadow*specCoeff*pow(clamp(dot(reflectEye,lightDir), 0.0, 1.0), 30.0);\n    brdf = material*lightCol*(diff+spec);\n    brdf += amb;\n    return brdf;\n}\n\n\nvec3 calColor(vec3 rayOr, vec3 rayDir) {\n    float t;\n    float id = intersect(rayOr, rayDir, t);\n    \n    vec3 pos = rayOr + rayDir*(t);\n    // need this to prevent shelf shading\n    vec3 posShadow = rayOr + rayDir*(t-0.0001);\n    vec3 nor;\n    vec3 reflectEye; // rayDir is the eye to position\n    vec3 refractRay;\n    float time = 0.5*iTime;\n    //vec3 lightPos = vec3(3.0*sin(time), 3.0, 3.0*cos(time));\n    vec3 lightPos = vec3(1.5, 5.0, 6.0);\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 lightCol = vec3(1.0, 0.9, 0.7);\n    float specCoeff, diffCoeff, ambCoeff;\n    float spec, diff, shadow;\n    vec3 amb;\n    \n    // set material of object\n    vec3 material;\n    if(id > 0.5 && id < 1.5) { // hit the plane\n        nor = nPlane();\n        reflectEye = reflect(normalize(rayDir), nor);\n        // material color\n        float tileSize = 2.0;\n        float tile = mod(floor(tileSize*pos.x) + floor(tileSize*pos.z), 2.0);\n        if(tile > 0.0) {\n            material = vec3(0.9, 0.1, 0.1);\n        } else {\n            material = vec3(0.9, 0.9, 0.1);\n        }\n        // float marbleCol = fbm(pos.xz + .5*fbm(pos.xz + .2*fbm(pos.xz)));\n        // material = vec3(marbleCol);\n        \n    } else if(id > 1.5 && id < 2.5) { // hit the sphere1\n        nor = nSphere(pos, sphere1);\n        reflectEye = reflect(normalize(rayDir), nor);\n        // material color\n        vec3 reflectRay = reflect(rayDir, nor);\n        vec3 reflectColor = calColorRec(posShadow, reflectRay);\n        // material color\n        material = mix(vec3(.9), reflectColor, .7);\n    } else if(id > 2.5 && id < 3.5) { // hit the sphere2\n        nor = nSphere(pos, sphere2);\n        //reflectEye = reflect(normalize(rayDir), nor);\t\n        vec3 refractRay = refract(rayDir, nor, 1.125/1.00029);\n        vec3 refractColor = calColorRec(posShadow, refractRay);\n        // material color\n        material = refractColor;\n    } else { // background\n    \treturn vec3(0.0, 0.0, 0.0);\n    }\n\n    // calculate lighting\n    vec3 brdf;\n    ambCoeff = 0.06;\n    diffCoeff = .7454545454;\n    specCoeff = .4545454545;\n    // hard shadow method\n    float trashTime; // this isn't going to be used right now\n    shadow = intersect(posShadow, lightDir, trashTime);\n    if(shadow > 0.0) {\n        shadow = 0.1;\n    } else {\n    \tshadow = 1.0;\n    }\n    amb = ambCoeff*vec3(1.0, 1.0, 1.0);\n    diff = shadow*diffCoeff*clamp(dot(nor,lightDir), 0.0, 1.0);\n    spec = shadow*specCoeff*pow(clamp(dot(reflectEye,lightDir), 0.0, 1.0), 30.0);\n    brdf = material*lightCol*(diff+spec);\n    brdf += amb;\n    return brdf;\n}\n\n\n// CAMERA SETTING\nmat3 mkCamMat(in vec3 rayOrigin, in vec3 lookAtPoint, float roll) {\n    vec3 cw = normalize(lookAtPoint - rayOrigin);\n    vec3 cp = vec3(sin(roll), cos(roll), 0.0); //this is a temp right vec for cross determination\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.5 + 3.0*q;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // camera or eye (where rays start)\n    // Straight ahead view\n    vec3 rayOrigin = vec3(1.0, 1.1, 2.0);\n    vec3 lookAtPoint = vec3(1.0, 1.1, -1.0);\n    // top down view\n    //vec3 rayOrigin = vec3(1.2, 6.4, 0.2);\n    //vec3 lookAtPoint = vec3(1.2, -1.0, 0.3);\n    float focalLen = 1.5; // how far camera is from image plane\n    mat3 camMat = mkCamMat(rayOrigin, lookAtPoint, 0.0);\n\n    // ray direction into image plane\n    vec3 rayDir = camMat * normalize(vec3(p.xy, focalLen));\n    \n    //render the scene with ray marching\n    vec3 col = calColor(rayOrigin, rayDir);\n    col = col*1.5;\n    fragColor = vec4(col, 1.0); \n\t//fragColor = vec4(.9); // that off white\n}","name":"Image","description":"","type":"image"}]}