{"ver":"0.1","info":{"id":"tdtcWs","date":"1602396489","viewed":81,"name":"Canção do Exílio","username":"rmmcal","description":"Canção do Exílio (Gonçalves Dias)\n[url]https://en.wikipedia.org/wiki/Can%C3%A7%C3%A3o_do_ex%C3%ADlio[/url]","likes":3,"published":1,"flags":96,"usePreview":0,"tags":["poema"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n////           .... Canção do Exílio ....                ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)🧙🧞\n// - Started: 2020/10 - Published: 2020/10\n// - url: https://www.shadertoy.com/view/tdtcWs\n// - fork: https://www.shadertoy.com/view/wtlyWl\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  Canção do Exílio (Gonçalves Dias)\n//\n//\tPass: Sabia\n//  \n//      ... @rmmcal 2020/10 \n//\n//  Wiki: \n//  => https://en.wikipedia.org/wiki/Can%C3%A7%C3%A3o_do_ex%C3%ADlio\n// \t=> https://pt.wikipedia.org/wiki/Can%C3%A7%C3%A3o_do_Ex%C3%ADlio\n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4tB3W3","filepath":"https://soundcloud.com/mikyle-busson/brian-crain-rain?in=nitza-md/sets/piano-deep-concentration","previewfilepath":"https://soundcloud.com/mikyle-busson/brian-crain-rain?in=nitza-md/sets/piano-deep-concentration","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////\n////           .... Canção do Exílio ....                ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)🧙🧞\n// - Started: 2020/10 - Published: 2020/10\n// - url: https://www.shadertoy.com/view/tdtcWs\n// - fork: https://www.shadertoy.com/view/wtlyWl\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  Canção do Exílio (Gonçalves Dias)\n//\n//\tPass: Sabia\n//  \n//      ... @rmmcal 2020/10 \n//\n//  Wiki: \n//  => https://en.wikipedia.org/wiki/Can%C3%A7%C3%A3o_do_ex%C3%ADlio\n// \t=> https://pt.wikipedia.org/wiki/Can%C3%A7%C3%A3o_do_Ex%C3%ADlio\n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n\n#ifndef SHADERTOY_COM\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D backbuffer;\nuniform sampler2D keyboard;\n\n#define iTime time\n#define iChannel0 backbuffer\n#define iChannel1 0 \n#define iChannel2 0\n#define iChannel3 keyboard\n#define texelFetch(a,b,c) texture2D(a, (vec2(b)+vec2(.5))/resolution)\n\n#else \n#define resolution iResolution.xy\n#define time iTime\n#endif\n\n#define shiftr(a,b) a / int(pow(2.,float(b)))   \n\nint imax(int a, int b){\n    return a>b?a:b;\n}\nint modi(int a, int n){\n    return a - (n * int(a/n));\n}\nint p2(int x){\n    return int(pow(2.,float(x)));\n}\nint absi(int x){\n    return x < 0? -x : x; \n}\nint clampi(int x, int a, int b){\n    x = (x < a ? a : x);\n    x = (x > b ? b : x);\n    return x; \n}\n\nbool checkin(int x, int y, int w, int h){\n    return x>=0&&x<w && y>=0&&y<h; \n}\n\nconst int CHARS_LEN = 97;\nivec4 CHARS[CHARS_LEN];\n\nconst int TEXT_LEN = 41;\nivec4 TEXT[TEXT_LEN];\n\nvoid setup_text(){\n TEXT[0] = ivec4( 0x2F4B504A, 0X43025647, 0X54544302, 0X56474F02);\n TEXT[1] = ivec4( 0x52434E4F, 0X474B5443, 0X550E0131, 0X50464702);\n TEXT[2] = ivec4( 0x45435056, 0X43025102, 0X3543444B, 0X431D0123);\n TEXT[3] = ivec4( 0x55024358, 0X47550E02, 0X53574702, 0X4353574B);\n TEXT[4] = ivec4( 0x02495154, 0X4C474B43, 0X4F0E0130, 0X43510249);\n TEXT[5] = ivec4( 0x51544C47, 0X4B434F02, 0X45514F51, 0X024E4310);\n TEXT[6] = ivec4( 0x01010130, 0X51555551, 0X02454757, 0X0256474F);\n TEXT[7] = ivec4( 0x024F434B, 0X55024755, 0X5654474E, 0X43550E01);\n TEXT[8] = ivec4( 0x30515555, 0X43550258, 0X43545C47, 0X43550256);\n TEXT[9] = ivec4( 0x474F024F, 0X434B5502, 0X484E5154, 0X47550E01);\n TEXT[10] = ivec4( 0x30515555, 0X51550244, 0X51555357, 0X47550256);\n TEXT[11] = ivec4( 0x474F024F, 0X434B5502, 0X584B4643, 0X0E013051);\n TEXT[12] = ivec4( 0x55554302, 0X584B4643, 0X024F434B, 0X5502434F);\n TEXT[13] = ivec4( 0x51544755, 0X10010101, 0X274F0245, 0X4B554F43);\n TEXT[14] = ivec4( 0x540E0255, 0X515C4B50, 0X4A510E02, 0X43025051);\n TEXT[15] = ivec4( 0x4B56470E, 0X012F434B, 0X55025254, 0X435C4754);\n TEXT[16] = ivec4( 0x02475045, 0X51505654, 0X51024757, 0X024E431D);\n TEXT[17] = ivec4( 0x012F4B50, 0X4A430256, 0X47545443, 0X0256474F);\n TEXT[18] = ivec4( 0x0252434E, 0X4F474B54, 0X43550E01, 0X31504647);\n TEXT[19] = ivec4( 0x02454350, 0X56430251, 0X02354344, 0X4B431001);\n TEXT[20] = ivec4( 0x01012F4B, 0X504A4302, 0X56475454, 0X43025647);\n TEXT[21] = ivec4( 0x4F025254, 0X4B4F5154, 0X47550E01, 0X33574702);\n TEXT[22] = ivec4( 0x56434B55, 0X02504351, 0X02475045, 0X51505654);\n TEXT[23] = ivec4( 0x51024757, 0X0245431D, 0X01274F02, 0X454B554F);\n TEXT[24] = ivec4( 0x4354020F, 0X0255515C, 0X4B504A51, 0X0E024302);\n TEXT[25] = ivec4( 0x50514B56, 0X47020F01, 0X2F434B55, 0X02525443);\n TEXT[26] = ivec4( 0x5C475402, 0X47504551, 0X50565451, 0X02475702);\n TEXT[27] = ivec4( 0x4E431D01, 0X2F4B504A, 0X43025647, 0X54544302);\n TEXT[28] = ivec4( 0x56474F02, 0X52434E4F, 0X474B5443, 0X550E0131);\n TEXT[29] = ivec4( 0x50464702, 0X45435056, 0X43025102, 0X3543444B);\n TEXT[30] = ivec4( 0x43100101, 0X01304351, 0X02524754, 0X4F4B5643);\n TEXT[31] = ivec4( 0x02264757, 0X55025357, 0X47024757, 0X024F5154);\n TEXT[32] = ivec4( 0x54430E01, 0X35474F02, 0X53574702, 0X47570258);\n TEXT[33] = ivec4( 0x514E5647, 0X02524354, 0X43024E43, 0X1D013547);\n TEXT[34] = ivec4( 0x4F025357, 0X47024647, 0X55485457, 0X56470251);\n TEXT[35] = ivec4( 0x55025254, 0X4B4F5154, 0X47550133, 0X57470250);\n TEXT[36] = ivec4( 0x43510247, 0X50455150, 0X56545102, 0X52515402);\n TEXT[37] = ivec4( 0x45431D01, 0X35474F02, 0X5357094B, 0X50464302);\n TEXT[38] = ivec4( 0x43584B55, 0X56470243, 0X55025243, 0X4E4F474B);\n TEXT[39] = ivec4( 0x5443550E, 0X01315046, 0X47024543, 0X50564302);\n TEXT[40] = ivec4( 0x51023543, 0X444B4310, 0X01000000, 0X00000000);\n \n}\n\nvoid setup_font(){\n\n    CHARS[0] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00000000); //  0x1e 30\n    CHARS[1] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00000000); //  0x1f 31\n    CHARS[2] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00000000); //   0x20 32\n    CHARS[3] = ivec4(0x00000000, 0x00001818, 0x00181818, 0x3c3c3c18); // ! 0x21 33\n    CHARS[4] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00444466); // \" 0x22 34\n    CHARS[5] = ivec4(0x00000000, 0x00003636, 0x7f36367f, 0x36360000); // # 0x23 35\n    CHARS[6] = ivec4(0x00000000, 0x08083e6b, 0x6b381c0e, 0x6b6b3e08); // $ 0x24 36\n    CHARS[7] = ivec4(0x00000000, 0x00003049, 0x4b360c18, 0x36694906); // % 0x25 37\n    CHARS[8] = ivec4(0x00000000, 0x00006e33, 0x333b6e0c, 0x1c36361c); // & 0x26 38\n    CHARS[9] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00081018); // ' 0x27 39\n    CHARS[10] = ivec4(0x00000000, 0x00003018, 0x0c0c0c0c, 0x0c0c1830); // ( 0x28 40\n    CHARS[11] = ivec4(0x00000000, 0x00000c18, 0x30303030, 0x3030180c); // ) 0x29 41\n    CHARS[12] = ivec4(0x00000000, 0x00000000, 0x663cff3c, 0x66000000); // * 0x2a 42\n    CHARS[13] = ivec4(0x00000000, 0x00000000, 0x18187e18, 0x18000000); // + 0x2b 43\n    CHARS[14] = ivec4(0x00000000, 0x04080c0c, 0x00000000, 0x00000000); // , 0x2c 44\n    CHARS[15] = ivec4(0x00000000, 0x00000000, 0x00007f00, 0x00000000); // - 0x2d 45\n    CHARS[16] = ivec4(0x00000000, 0x00000c0c, 0x00000000, 0x00000000); // . 0x2e 46\n    CHARS[17] = ivec4(0x00000000, 0x00000001, 0x03060c18, 0x30604000); // / 0x2f 47\n    CHARS[18] = ivec4(0x00000000, 0x00003e63, 0x63676f7b, 0x7363633e); // 0 0x30 48\n    CHARS[19] = ivec4(0x00000000, 0x00007e18, 0x18181818, 0x181e1c18); // 1 0x31 49\n    CHARS[20] = ivec4(0x00000000, 0x00007f63, 0x03060c18, 0x3060633e); // 2 0x32 50\n    CHARS[21] = ivec4(0x00000000, 0x00003e63, 0x6060603c, 0x6060633e); // 3 0x33 51\n    CHARS[22] = ivec4(0x00000000, 0x00007830, 0x307f3333, 0x363c3830); // 4 0x34 52\n    CHARS[23] = ivec4(0x00000000, 0x00003e63, 0x6060603f, 0x0303037f); // 5 0x35 53\n    CHARS[24] = ivec4(0x00000000, 0x00003e63, 0x6363633f, 0x0303633e); // 6 0x36 54\n    CHARS[25] = ivec4(0x00000000, 0x00000c0c, 0x0c0c1830, 0x6060637f); // 7 0x37 55\n    CHARS[26] = ivec4(0x00000000, 0x00003e63, 0x6363633e, 0x6363633e); // 8 0x38 56\n    CHARS[27] = ivec4(0x00000000, 0x00003e63, 0x60607e63, 0x6363633e); // 9 0x39 57\n    CHARS[28] = ivec4(0x00000000, 0x00000018, 0x18000000, 0x18180000); // : 0x3a 58\n    CHARS[29] = ivec4(0x00000000, 0x00081018, 0x18000000, 0x18180000); // ; 0x3b 59\n    CHARS[30] = ivec4(0x00000000, 0x00006030, 0x180c060c, 0x18306000); // < 0x3c 60\n    CHARS[31] = ivec4(0x00000000, 0x00000000, 0x007e0000, 0x7e000000); // = 0x3d 61\n    CHARS[32] = ivec4(0x00000000, 0x0000060c, 0x18306030, 0x180c0600); // > 0x3e 62\n    CHARS[33] = ivec4(0x00000000, 0x00001818, 0x00181830, 0x6063633e); // ? 0x3f 63\n    CHARS[34] = ivec4(0x00000000, 0x00003c02, 0x6db5a5a5, 0xb9423c00); // @ 0x40 64\n    CHARS[35] = ivec4(0x00000000, 0x00006363, 0x63637f63, 0x6363361c); // A 0x41 65\n    CHARS[36] = ivec4(0x00000000, 0x00003f66, 0x6666663e, 0x6666663f); // B 0x42 66\n    CHARS[37] = ivec4(0x00000000, 0x00003e63, 0x63030303, 0x0363633e); // C 0x43 67\n    CHARS[38] = ivec4(0x00000000, 0x00003f66, 0x66666666, 0x6666663f); // D 0x44 68\n    CHARS[39] = ivec4(0x00000000, 0x00007f66, 0x46161e1e, 0x1646667f); // E 0x45 69\n    CHARS[40] = ivec4(0x00000000, 0x00000f06, 0x06161e1e, 0x1646667f); // F 0x46 70\n    CHARS[41] = ivec4(0x00000000, 0x00007e63, 0x63637303, 0x0363633e); // G 0x47 71\n    CHARS[42] = ivec4(0x00000000, 0x00006363, 0x6363637f, 0x63636363); // H 0x48 72\n    CHARS[43] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x1818183c); // I 0x49 73\n    CHARS[44] = ivec4(0x00000000, 0x00001e33, 0x33303030, 0x30303078); // J 0x4a 74\n    CHARS[45] = ivec4(0x00000000, 0x00006766, 0x66361e1e, 0x36666667); // K 0x4b 75\n    CHARS[46] = ivec4(0x00000000, 0x00007f66, 0x46060606, 0x0606060f); // L 0x4c 76\n    CHARS[47] = ivec4(0x00000000, 0x00006363, 0x63636b7f, 0x7f776341); // M 0x4d 77\n    CHARS[48] = ivec4(0x00000000, 0x00006363, 0x63737b7f, 0x6f676361); // N 0x4e 78\n    CHARS[49] = ivec4(0x00000000, 0x00003e63, 0x63636363, 0x6363633e); // O 0x4f 79\n    CHARS[50] = ivec4(0x00000000, 0x00000f06, 0x06063e66, 0x6666663f); // P 0x50 80\n    CHARS[51] = ivec4(0x00000000, 0x00603e7b, 0x6b636363, 0x6363633e); // Q 0x51 81\n    CHARS[52] = ivec4(0x00000000, 0x00006766, 0x66363e66, 0x6666663f); // R 0x52 82\n    CHARS[53] = ivec4(0x00000000, 0x00003e63, 0x6360301c, 0x0663633e); // S 0x53 83\n    CHARS[54] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x185a7e7e); // T 0x54 84\n    CHARS[55] = ivec4(0x00000000, 0x00003e63, 0x63636363, 0x63636363); // U 0x55 85\n    CHARS[56] = ivec4(0x00000000, 0x0000081c, 0x36636363, 0x63636363); // V 0x56 86\n    CHARS[57] = ivec4(0x00000000, 0x00004163, 0x777f6b63, 0x63636363); // W 0x57 87\n    CHARS[58] = ivec4(0x00000000, 0x00006363, 0x363e1c1c, 0x3e366363); // X 0x58 88\n    CHARS[59] = ivec4(0x00000000, 0x00003c18, 0x1818183c, 0x66666666); // Y 0x59 89\n    CHARS[60] = ivec4(0x00000000, 0x00007f63, 0x43060c18, 0x3061637f); // Z 0x5a 90\n    CHARS[61] = ivec4(0x00000000, 0x00003c0c, 0x0c0c0c0c, 0x0c0c0c3c); // [ 0x5b 91\n    CHARS[62] = ivec4(0x00000000, 0x00000040, 0x6030180c, 0x06030100); // \\ 0x5c 92\n    CHARS[63] = ivec4(0x00000000, 0x00003c30, 0x30303030, 0x3030303c); // ] 0x5d 93\n    CHARS[64] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x63361c08); // ^ 0x5e 94\n    CHARS[65] = ivec4(0x00000000, 0x00ff0000, 0x00000000, 0x00000000); // _ 0x5f 95\n    CHARS[66] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00100818); // ` 0x60 96\n    CHARS[67] = ivec4(0x00000000, 0x00006e33, 0x33333e30, 0x1e000000); // a 0x61 97\n    CHARS[68] = ivec4(0x00000000, 0x00003e66, 0x66666666, 0x3e060607); // b 0x62 98\n    CHARS[69] = ivec4(0x00000000, 0x00003e63, 0x03030363, 0x3e000000); // c 0x63 99\n    CHARS[70] = ivec4(0x00000000, 0x00006e33, 0x33333333, 0x3e303038); // d 0x64 100\n    CHARS[71] = ivec4(0x00000000, 0x00003e63, 0x037f6363, 0x3e000000); // e 0x65 101\n    CHARS[72] = ivec4(0x00000000, 0x00001e0c, 0x0c0c0c0c, 0x3e0c6c38); // f 0x66 102\n    CHARS[73] = ivec4(0x0000001e, 0x33303e33, 0x33333333, 0x6e000000); // g 0x67 103\n    CHARS[74] = ivec4(0x00000000, 0x00006766, 0x6666666e, 0x36060607); // h 0x68 104\n    CHARS[75] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x1c001818); // i 0x69 105\n    CHARS[76] = ivec4(0x0000001e, 0x33333030, 0x30303030, 0x38003030); // j 0x6a 106\n    CHARS[77] = ivec4(0x00000000, 0x00006766, 0x361e1e36, 0x66060607); // k 0x6b 107\n    CHARS[78] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x1818181c); // l 0x6c 108\n    CHARS[79] = ivec4(0x00000000, 0x0000636b, 0x6b6b6b7f, 0x37000000); // m 0x6d 109\n    CHARS[80] = ivec4(0x00000000, 0x00006666, 0x66666666, 0x3b000000); // n 0x6e 110\n    CHARS[81] = ivec4(0x00000000, 0x00003e63, 0x63636363, 0x3e000000); // o 0x6f 111\n    CHARS[82] = ivec4(0x0000000f, 0x06063e66, 0x66666666, 0x3b000000); // p 0x70 112\n    CHARS[83] = ivec4(0x00000078, 0x30303e33, 0x33333333, 0x3e000000); // q 0x71 113\n    CHARS[84] = ivec4(0x00000000, 0x00000f06, 0x0606066e, 0x7b000000); // r 0x72 114\n    CHARS[85] = ivec4(0x00000000, 0x00003e63, 0x301c0663, 0x3e000000); // s 0x73 115\n    CHARS[86] = ivec4(0x00000000, 0x0000182c, 0x0c0c0c0c, 0x3f0c0c08); // t 0x74 116\n    CHARS[87] = ivec4(0x00000000, 0x00006e33, 0x33333333, 0x33000000); // u 0x75 117\n    CHARS[88] = ivec4(0x00000000, 0x0000081c, 0x36636363, 0x63000000); // v 0x76 118\n    CHARS[89] = ivec4(0x00000000, 0x0000367f, 0x6b6b6b6b, 0x63000000); // w 0x77 119\n    CHARS[90] = ivec4(0x00000000, 0x00006363, 0x361c3663, 0x63000000); // x 0x78 120\n    CHARS[91] = ivec4(0x0000001f, 0x30607e63, 0x63636363, 0x63000000); // y 0x79 121\n    CHARS[92] = ivec4(0x00000000, 0x00007f43, 0x060c1831, 0x7f000000); // z 0x7a 122\n    CHARS[93] = ivec4(0x00000000, 0x00007018, 0x1818180e, 0x18181870); // { 0x7b 123\n    CHARS[94] = ivec4(0x00000000, 0x00001818, 0x18180000, 0x18181818); // | 0x7c 124\n    CHARS[95] = ivec4(0x00000000, 0x00000e18, 0x18181870, 0x1818180e); // } 0x7d 125\n    CHARS[96] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00003b6e); // ~ 0x7e 126\n}\n\n#define START_CH 30\n\n\nfloat ch(ivec2 p, int ch) {\n    float c = 0.;\n    if (checkin(p.x,p.y,8,32)) {\n        for (int i = 0; i < CHARS_LEN; i += 1) {\n            if (i == ch)\n                for (int yi = 0; yi < 24; yi += 1) {\n                    if (-p.y+12 == yi){\n                        c += float(modi((CHARS[i][3 - yi / 4] /p2 (modi(yi , 4) * 8) /p2( modi(absi(p.x),8))),2))/1.;\n                    }\n                }\n        }\n    }\n    return c;\n}\n \n#define setCursor(cursor) locScreen = loc(cursor.xy)\n#define getCharCursor() ivec4(texelFetch(iChannel0, locScreen,0)*255.)\n#define writeChOnCursor() if (ip == locScreen) fragColor = vec4(tch)/255.\n\nconst int total = 7;\nconst int len = total;\nvec4 m[len];\n\n#define MSG     ivec4(0 ,   136, 0, 2) \n \n\n#define getInt(a)  a.y * 256 + a.x;  \n#define loadInt(a) a = ivec4(a.y * 256 + a.x, 0, 0, 0)\n#define saveInt(a) a = ivec4(modi(a.x,256),a.x/256, 0, 0)  \n\n#define ROWS 80\n#define LINES 18\n\n#define loc(sp) ivec2(modi(sp.x+sp.y*ROWS+1, ROWS),1 + imax(0, (sp.x+sp.y*ROWS) / ROWS))\n#define print(t) print_mem_start.x = getInt(t.xz); print_mem_end.x = getInt(t.yw); print_mem_stack.x = print_mem_prog.x\n#define delaySec(a) print_mem_time.x = int(iTime+a)\n#define MAX_PRINT_SPEED 100\n#define PRINT_SPEED 0\n#define SPEED 1\n\n\nint getTextChAt(int at){\n    ivec4 vt = ivec4(0);  \n    int s1 = 0;\n    int s2 = 0;\n\n    for (int i = 0; i < TEXT_LEN; i++)   {\n        if (( at / 16) == i) {\n            vt = (TEXT[i]);\n            break;\n        }\n    }\n\n    int b = modi(at/4,4);\n    for (int i = 0; i < 4; i++) {\n        if ( i == b) {\n            s1 = vt[i]; \n            break;\n        } \n    }\n    return modi(shiftr(s1, 24-modi(at, 4)*8),256);\n\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ir = ivec2(resolution); \n    ivec2 ip = ivec2(fragCoord.xy);\n    vec2 fp = vec2(ip);\n    vec2 fr = vec2(ir);\n    vec2 uv = fp/fr;\n    int row = ir.x/8;\n\n    // load memory //\n    for (int i = 0 ; i < len; i++) \n        m[i] = texelFetch(iChannel0, ivec2(i,0),0)*255.;\n\n    ivec2 spg = ivec2(ip.x/8-1,ir.y/16-ip.y/16-1);// screen point\n    ivec2 locScreen = loc(spg);\n    ivec4 cursor = ivec4(m[0]);\n    ivec4 print_mem_start = ivec4(m[1]);\n    ivec4 print_mem_end   = ivec4(m[2]);\n    ivec4 print_mem_stack = ivec4(m[3]);\n    ivec4 print_mem_int   = ivec4(m[4]);\n    ivec4 print_mem_time  = ivec4(m[5]);\n    ivec4 print_mem_prog  = ivec4(m[6]);    \n\n\n    loadInt(print_mem_start);\n    loadInt(print_mem_end);\n    loadInt(print_mem_stack);\n    loadInt(print_mem_int);\n    loadInt(print_mem_time);\n    loadInt(print_mem_prog);\n\n    ivec4 tch = getCharCursor(); \n    ivec4 sch = getCharCursor(); \n    if (locScreen.y==0)\n        tch *= 0;\n\n    if (iTime < 1.)\n        discard;\n    \n    if (ip.y<LINES+2)\n    {\n        setup_text();\n\n        fragColor = texelFetch(iChannel0, ip, 0); // mem last state\n\n        ivec2 sp = cursor.xy;\n        setCursor(cursor.xy);\n        tch = getCharCursor(); \n\n        if (print_mem_time.x <= int(iTime*50.))\n        {\n            if (cursor.y > LINES){\n                // scroll lines\n                cursor.y -= 1;\n                int t = (ip.x+ip.y*80) / (ir.x);\n                fragColor = texelFetch(iChannel0, ip+ivec2(0,1), 0);\n            } \n            else if ((print_mem_start.x) < (print_mem_end.x) ) {\n\n                for (int i = 0; i < MAX_PRINT_SPEED; i++) { \n                    \n                    if (i > cursor.z + PRINT_SPEED) // cursor.z => max char for frame \n                        break;\n                    \n                    if ( (print_mem_start.x) < (print_mem_end.x) ) {\n                        \n                        // print text\n                        tch.x = getTextChAt(print_mem_start.x);\n                        setCursor(cursor.xy);\n                        cursor.x += 1; \n                        print_mem_start.x += 1;\n\n                        if (tch.x == 1) {\n                            // \\n\n                            cursor.x = 0;\n                            cursor.y += 1;  \n                             print_mem_time.x+=70*SPEED;\n                        }\n                        if (tch.x == 2) {\n                            // space\n                             print_mem_time.x+=20*SPEED;\n                        }\n                        if (tch.x == 0)\n                        {\n                            // end string\n                            print_mem_start.x = print_mem_end.x;                \n                            print_mem_prog.x = print_mem_stack.x;\n                            cursor.y += 1;\n                            cursor.x = print_mem_stack.x > 0 ? cursor.x : 0;\n                            break;\n                        }\n\n                        if (cursor.y > LINES)\n                            break;\n\n                        writeChOnCursor();\n                        print_mem_time.x+=int(cos( abs(float(cursor.x*cursor.x+cursor.y)*153.75329) )*5.+10.)*SPEED;\n                    }\n                }\n            }\n            else {\n                if (cursor == ivec4(0.0)){\n                    print(MSG); // start \n                }\n            }\n        }\n\n        saveInt(print_mem_start);\n        saveInt(print_mem_end);\n        saveInt(print_mem_stack);\n        saveInt(print_mem_int);\n        saveInt(print_mem_time);\n        saveInt(print_mem_prog);\n\n        m[0] = vec4 ( cursor );\n        m[1] = vec4 ( print_mem_start );\n        m[2] = vec4 ( print_mem_end );\n        m[3] = vec4 ( print_mem_stack );\n        m[4] = vec4 ( print_mem_int );\n        m[5] = vec4 ( print_mem_time );\n        m[6] = vec4 ( print_mem_prog );\n\n        for (int i = 0 ; i < len; i++) {\n            if (ip == ivec2(i,0)){\n                fragColor =\tm[i]/255.; \n            }\n        }\n\n       \twriteChOnCursor();\n\n        fragColor.a = 1.; \n        return;\n    }\n\n    setup_font();\n\n    float c = 0.;\n    if (modi(int(time*4.),2)==0)\n        c += ch(ip-cursor.xy*ivec2(8,-16)-ivec2(8,ir.y-20),95-START_CH);\n\n    if (tch.x!=0 && spg.y>=0 && spg.x<80 && spg.y<=LINES){\n        ivec2 it = ip;         \n        c += ch(ivec2(modi(it.x,8),modi(it.y+int(0.),16)),tch.x);       \n    }\n     \n\tfloat t = iTime*.4;\n    vec3 cc = abs(vec3( cos(uv.x*11.+t), cos(uv.y+0.)+.5, cos(uv.x+t*.5) ));\n    fragColor = vec4(  vec3(c*cc*.7) , 1.0 );\n\n}\n\n#ifndef SHADERTOY_COM\n/**/\nvoid main( void ) {\n    vec4 color;\n    mainImage(color, gl_FragCoord.xy );\n    gl_FragColor = color;\n\n}\n#endif\n/**/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SHADERTOY_COM","name":"Common","description":"","type":"common"}]}