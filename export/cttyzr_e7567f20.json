{"ver":"0.1","info":{"id":"cttyzr","date":"1698936115","viewed":75,"name":"Ray tracing AO and Spheric Light","username":"Furquijos","description":"Original Intersection/traverse code from \"Introduction to Ray Tracing\" (SIGGRAPH) led by Rajesh Sharma. Taking C++ logic from \"RaytracingInOneWeekend\" into GLSL to diffuse, occluding ambient light by hit-points scattering new rays,adding spherical Light\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","diffuse","siggraph","raytracinginoneweekend","introductiontoraytracing"],"hasliked":0,"parentid":"csVfWy","parentname":"Ray Tracing Ambient Occlusion"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 10000000.0\n\n/*\nOriginal Intersection/traverse code from course \"Introduction to Ray Tracing\" (SIGGRAPH) led by Rajesh Sharma. \nI bring the C++ logic from \"RaytracingInOneWeekend\" into GLSL to diffuse it.\nOccluding the ambient light by making hitpoints scatter new rays pseudo-randomly above the hit normal surfac using a Lambertian scattering distribution\nForking from my  previous ray tracing iteration https://www.shadertoy.com/view/csVfWy adding Spherical Light/Emissive Surface feature\n*/\n\n// =========================>  samples per pixel,change it as you want (the bigger the smoother and slower)\nconst int numSamples=60;\n// =========================>  Max Bounces per Ray\nconst int maxBounces=3;\n\n//////////////////////////////////////////////////////////////////////\n//Noise code from https://www.shadertoy.com/view/Nsf3Ws\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(1)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return (2.0 * float(seed)/4294967295.0) -1.0;\n}\n/////////////////////////////////////////////////////////////////////\n\n\n\n\nvec3 randomvec()\n{\n     return vec3(random(),random(),random());\n}\n\n\n////////getting random vectors above the surface adapted from RaytracingInOneWeekend\n/// Possible optimization creating an array of precaulculated unit vectors with an homogenious distribution on the sphere and randomly returning one instead of using brute force\nvec3 random_in_unit_sphere() {\n    while (true) {\n        vec3 p = randomvec();\n        if (length(p) < 1.0)\n            return p;\n    }\n}\n\nvec3 random_unit_vector() {\n    return normalize(random_in_unit_sphere());\n}\n\nvec3 random_on_hemisphere(vec3 normal) {\n    vec3 on_unit_sphere = random_unit_vector();\n    if (dot(on_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal\n        return on_unit_sphere;\n    else\n        return -on_unit_sphere;\n}\n/////\n\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n    int isLight;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\nconst int NUM_SPHERE = 4;\nSphere spheres[NUM_SPHERE];\n//Light  lights[1];\n\n// Intersection code for Ray-Sphere (from https://www.shadertoy.com/view/NllGDs)    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE; i++) {\n       Sphere sphere = spheres[i];\n       \n       float t = raySphereIntersect(ray, sphere);\n         \n       if (t < minT && t >= 0.001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n  \n\nvoid makeScene(int f) {\n    spheres[0] = Sphere(1.0 , vec3(0.0, 0, -7), vec3(1, 1, 0),0);\n    spheres[1] = Sphere(30.0, vec3(0.0,-31, -7), vec3(1, 1, 0),0);\n    spheres[2] = Sphere(0.5, vec3(sin(iTime)*1.3,-0.52, -7.0 + cos(iTime)*1.3), vec3(1, 1, 0),0);\n    spheres[3] = Sphere(0.5, 1.5*vec3(sin(iTime*2.0)*1.0,0.5, -5.0 + cos(iTime*2.0)*1.2), vec3(2.8, 2.8, 2.8),1);\n\n   \n}\n\n\n\n vec3 ray_color(Ray r, int depth){\n \n vec3 finalColor = vec3(1.0, 1.0, 1.0);\n       \n       //This logic is a mixture from  \"Introduction to Ray Tracing\" and  \"RaytracingInOneWeekend\"\n       //I couldn't use recursivity so I did a while loop instead with breaks in the base cases\n       while(true)\n       {\n\n            // If we've exceeded the ray bounce limit, no more light is gathered.\n           \n            if (depth <= 0)\n            {\n                //finalColor *= 0.0;\n                break;\n            }\n\n\n           // traverse the scene (all spheres) and find the \n           // closest intersected object and intersection point\n           Intersection intersection = intersectAllObjects(r);\n\n           int iSphere = intersection.obj;\n           float minT = intersection.t;\n\n           Sphere sphere;\n\n           if (iSphere > -1) { \n               // to get around iSphere not being constant\n               for (int i=0; i<NUM_SPHERE; i++) {\n                   if (i==iSphere) {\n                       sphere = spheres[i];\n                       break;\n                   }\n               }\n               \n               //is it a Light?\n               if(spheres[iSphere].isLight == 1)\n                   return finalColor * spheres[iSphere].color;\n               \n               \n\n\n               // hit coordinates\n               vec3 hit = r.origin + minT*r.direction;\n               // normal at the point of ray-sphere intersection\n               vec3 hitPointNormal = normalize(hit-sphere.center);\n               vec3 xnorm = hitPointNormal;\n               r.origin = hit;\n               //Lambertian distribution\n                r.direction = xnorm + random_unit_vector();\n               \n               //Homogeneous distribution of rays on a hemisphere commented below\n               //r.direction = random_on_hemisphere(xnorm);                      \n               finalColor *= 0.5;\n              \n            } \n            else{\n             break;\n            \n            }\n             depth--;\n        }\n\n        vec3 unit_direction = normalize(r.direction);\n        float a = 0.5*(unit_direction.y + 1.0);\n        finalColor *= (1.0-a)*vec3(1.0, 1.0, 1.0) + a*vec3(0.5, 0.7, 1.0);\n        return finalColor;\n                \n }\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n\n   initRandomGenerator(fragCoord);\n\n   makeScene(iFrame);\n\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n \n       for (int i=0; i<1*numSamples; i++) {\n           float x = fragCoord.x + random() - 0.5;\n           float y = fragCoord.y + random() - 0.5;\n\n\n           // map (0.5, w-0.5) to (-1, 1)\n           // and (0.5, h-0.5) to (-1, 1)\n           x = (x/width)*2.0 - 1.0;\n           y = (y/height)*2.0 - 1.0;\n\n           // account for the non-square window\n           float aspectRatio = width/height;\n           y = y/aspectRatio;\n\n           // ray Origin for is at (0, 0, 0)\n           vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n           // normalized ray direction\n           vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n\n           Ray ray = Ray(rayOrigin, rayDirection);\n           vec3 col = vec3(1.0, 1.0, 1.0);\n\n\n           samp += ray_color(ray, maxBounces);\n\n       }\n   \n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n  \n  \n\n}","name":"Image","description":"","type":"image"}]}