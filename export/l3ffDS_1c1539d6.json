{"ver":"0.1","info":{"id":"l3ffDS","date":"1728839477","viewed":25,"name":"colladascope","username":"garrisonhh","description":"messing around with point projection and color ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","projection","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float zNear = 0.01;\nconst float zFar = 10.0;\n\n// returns (x, y, depth), where depth is scaled to range [0.0, 1.0]\nvec3 project(mat4 mvp, vec3 v) {\n    vec4 proj = mvp * vec4(v, 1.0);\n    vec3 homo = proj.xyz / proj.w;\n\n    float depth = (proj.z - zNear) / (zFar - zNear);\n    return vec3(homo.xy, depth);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coord = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    coord.x *= iResolution.x / iResolution.y;\n\n    // compute projection\n    mat4 matModel =\n        matRotateZ(iTime * 0.1) *\n        matRotateY(iTime) *\n        matScale(vec3(0.3));\n    mat4 matView =\n        matTranslate(vec3(0.0, 0.0, -5.0)) *\n        matRotateX(0.25 * PI);\n    mat4 matProjection = matPerspective(zNear, zFar);\n    mat4 mvp = matProjection * matView * matModel;\n\n    // compute point sdfs\n    const float sphereRadius = 0.3;\n    float spirals = cos(iTime / 32.0) * 8.0;\n    const int pointCount = 48;\n    const float pointSize = 0.3;\n    float pointOffset = fract(iTime);\n    float mixV = 0.025;\n\n    float magnitude = 0.0;\n    for (int i = 0; i < pointCount; ++i) {\n        float pF = (float(i) + pointOffset) / float(pointCount);\n        float angleV = pF * PI;\n        float angleH = pF * spirals * TAU;\n        float radius = sphereRadius * sin(pF * PI);\n        vec3 point = radius * vec3(sin(angleV), cos(angleV), 0.0);\n        point.y *= 2.0;\n        point = vec3(matRotateY(angleH) * vec4(point, 1.0));\n    \n        vec3 proj = project(mvp, point);\n\n        float dist = distance(proj.xy, coord);\n        float scaledPointSize = pointSize * (1.0 - proj.z);\n        float value = (scaledPointSize - dist) / pointSize;\n        value = clamp(value, 0.0, mixV) / mixV;\n\n        magnitude += value;\n    };\n\n    // convert to color\n    float mF = magnitude / float(pointCount);\n    float lightness = pow(mF, 1.0 / 8.0);\n    float hue = mF * 12.0 * TAU + (0.6 * TAU);\n    vec3 labColor = vec3(lightness, cos(hue) * 0.5, sin(hue) * 0.5);\n    \n    fragColor = vec4(srgb_from_oklab(labColor), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define TAU (2.0 * PI)\n\nmat4 matPerspective(float near, float far) {\n    float d = near - far;\n    float c1 = (far + near) / d;\n    float c2 = (2.0 * far * near) / d;\n    \n    return mat4(\n         1.0,  0.0,  0.0,  0.0,\n         0.0,  1.0,  0.0,  0.0,\n         0.0,  0.0,   c1,   c2,\n         0.0,  0.0, -1.0,  0.0\n    );\n}\n\nmat4 matScale(vec3 v) {\n    return mat4(\n        v.x, 0.0, 0.0, 0.0,\n        0.0, v.y, 0.0, 0.0,\n        0.0, 0.0, v.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matTranslate(vec3 v) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        v.x, v.y, v.z, 1.0\n    );\n}\n\nmat4 matRotateX(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matRotateY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(\n          c, 0.0,   s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n         -s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matRotateZ(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n\n// taken from https://www.shadertoy.com/view/WtccD7\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n\n    return mix(xlo, xhi, step(vec3(0.04045), x));\n}\n\nconst mat3 fwdA = mat3(\n    1.0, 1.0, 1.0,\n    0.3963377774, -0.1055613458, -0.0894841775,\n    0.2158037573, -0.0638541728, -1.2914855480\n);\nconst mat3 fwdB = mat3(\n    4.0767245293, -1.2681437731, -0.0041119885,\n    -3.3072168827, 2.6093323231, -0.7034763098,\n    0.2307590544, -0.3411344290,  1.7068625689\n);\nconst mat3 invB = mat3(\n    0.4121656120, 0.2118591070, 0.0883097947,\n    0.5362752080, 0.6807189584, 0.2818474174,\n    0.0514575653, 0.1074065790, 0.6302613616\n);\nconst mat3 invA = mat3(\n    0.2104542553, 1.9779984951, 0.0259040371,\n    0.7936177850, -2.4285922050, 0.7827717662,\n    -0.0040720468, 0.4505937099, -0.8086757660\n);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n    vec3 lms = invB * c;\n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n    vec3 lms = fwdA * c;\n    return fwdB * (lms * lms * lms);\n}\n\nvec3 oklab_from_srgb(vec3 c) {\n    return oklab_from_linear_srgb(linear_srgb_from_srgb(c));\n}\n\nvec3 srgb_from_oklab(vec3 c) {\n    return srgb_from_linear_srgb(linear_srgb_from_oklab(c));\n}\n\nvec3 mix_srgb(vec3 a, vec3 b, float x) {\n    vec3 a_lab = oklab_from_srgb(a);\n    vec3 b_lab = oklab_from_srgb(b);\n    vec3 mixed = mix(a_lab, b_lab, x);\n    return srgb_from_oklab(mixed);\n}","name":"Common","description":"","type":"common"}]}