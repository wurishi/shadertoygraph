{"ver":"0.1","info":{"id":"McKyW3","date":"1732488294","viewed":28,"name":"eyeball2","username":"Wotan","description":"WIP eyeball","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["buffera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Main Image Shader - Applies VHS Glitch Effect to Buffer A (Corrected)\n// Place this code in the Main Image Shader\n\n// Function to generate noise\nfloat noise(vec2 p) {\n    return fract(sin(dot(p ,vec2(127.1,311.7))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Do not flip uv.y here\n\n    // --- VHS Glitch Effect ---\n\n    // Time variables\n    float time = iTime;\n\n    // Horizontal distortion (simulating tape tracking issues)\n    float yDistort = sin(uv.y * 150.0 + time * 5.0) * 0.005;\n    vec2 distortedUV = uv;\n    distortedUV.x += yDistort;\n\n    // Color channel shift\n    float shift = sin(time * 2.0) * 0.04;\n\n    // Sample from Buffer A with glitches\n    vec3 color;\n    color.r = texture(iChannel0, distortedUV + vec2(shift, 0.0)).r;\n    color.g = texture(iChannel0, distortedUV).g;\n    color.b = texture(iChannel0, distortedUV - vec2(shift, 0.0)).b;\n\n    // Scan lines\n    float scanline = sin(uv.y * iResolution.y * 1.5) * 0.05;\n    //color -= scanline * 0.0;\n\n    // Noise\n    float n = noise(uv * iResolution.xy + time * 10.0) * 0.1;\n    //color += 0.0;//n;\n\n    // Clamp color\n    color = clamp(color, 0.0, 1.0);\n\n    // Output color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A - Eye Shader with Moving Iris and Pupil (No uv.y flip)\n// Place this code in Buffer A\n\nfloat Xor(float a, float b){\n    return a*(1.-b)+b*(1.-a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Eye center position (stationary at center of screen)\n    vec2 eyeCenter = vec2(0.5, 0.5);\n\n    // Normalized mouse coordinates (from 0 to 1)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // If the mouse is outside the window (e.g., not moved yet), default to looking straight ahead\n    if (iMouse.xy == vec2(0.0)) {\n        mouse = eyeCenter;\n    }\n\n    // Vector from eye center to mouse position\n    vec2 toMouse = mouse - eyeCenter;\n\n    // Limit the pupil movement to within the iris\n    float maxOffset = 0.05; // Maximum offset for pupil and iris movement\n    vec2 toMouseNorm = normalize(toMouse + 1e-6); // Avoid division by zero\n    float offsetMagnitude = min(length(toMouse), maxOffset);\n    vec2 pupilOffset = toMouseNorm * offsetMagnitude;\n\n    // Compute vector from adjusted iris center to current fragment\n    vec2 delta = uv - (eyeCenter + pupilOffset);\n\n    // Distance from the adjusted center of the iris/pupil\n    float dist = length(delta);\n\n    // Angle for swirling effect\n    float angle = atan(delta.y, delta.x) + sin(dist * 10.0 - iTime * 5.0) * 0.5;\n\n    // Coordinates after applying swirl\n    vec2 swirlPos = vec2(cos(angle), sin(angle)) * dist;\n\n    // Recompute distance after swirl\n    float swirlDist = length(swirlPos);\n\n    // Compute vector from eye center to current fragment for sclera\n    vec2 deltaSclera = uv - eyeCenter;\n    float distSclera = length(deltaSclera);\n\n    // Define radii for different parts of the eye\n    float pupilRadius = 0.05;\n    float irisRadius = 0.15;\n    float scleraRadius = 0.3;\n\n    // Initialize color\n    vec3 color = vec3(0.0);\n\n    if (distSclera < scleraRadius) {\n        // Inside the eye\n\n        if (swirlDist < pupilRadius) {\n            // Pupil color (black)\n            color = vec3(0.0, 0.0, 0.0);\n        } else if (swirlDist < irisRadius) {\n            // Incorporate the pattern into the iris\n\n            // Scale and translate coordinates for the pattern\n            vec2 patternUV = (uv - (eyeCenter + pupilOffset)) * iResolution.y * 8.0;\n            float t = iTime;\n            float m = 0.0;\n\n            // Nested loops to create the pattern\n            for(float y = -1.0; y <= 1.0; y++) {\n                for(float x = -1.0; x <= 1.0; x++) {\n                    vec2 offs = vec2(x, y);\n                    float d = length(patternUV + offs);\n                    float dist = length(patternUV - offs) * 2.0;\n                    float r = mix(0.2, 2.0, sin(dist - t) * 0.5 + 0.5);\n                    m = Xor(m, smoothstep(r, r * 0.8, d * abs(sin(t * 0.5))));\n                }\n            }\n\n            // Adjust color based on pattern\n            color = mix(vec3(0.0, 0.0, 0.5), vec3(0.2, 0.4, 0.8), m);\n\n        } else {\n            // Sclera color (white)\n            color = vec3(1.0, 1.0, 1.0);\n        }\n\n    } else {\n        // Background color (dark)\n        color = vec3(0.0, 0.0, 0.0);\n    }\n\n    // Output color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}