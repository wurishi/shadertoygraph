{"ver":"0.1","info":{"id":"ctfGDX","date":"1672501840","viewed":119,"name":"Cube of triangles","username":"MrHAX00","description":"I'd say this is fairly ok, next will be blending normals etc. and implementing textures!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["triangle"],"hasliked":0,"parentid":"ctl3Dj","parentname":"TriangleRenderer"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Line(uv, P1, P2) ((uv.x - P1.x) * (P1.y - P2.y) / (P1.x - P2.x) + P1.y)\n\nfloat Triangle(vec2 uv, vec2 P1, vec2 P2, vec2 P3)\n{\n    vec2 Center = (P1 + P2 + P3) / 3.;\n    \n    float Sign1 = sign(Center.y - Line(Center, P1, P2));\n    float Line1 = sign((uv.y - Line(uv, P1, P2)) * Sign1) * .5 + .5;\n    \n    float Sign2 = sign(Center.y - Line(Center, P2, P3));\n    float Line2 = sign((uv.y - Line(uv, P2, P3)) * Sign2) * .5 + .5;\n    \n    float Sign3 = sign(Center.y - Line(Center, P3, P1));\n    float Line3 = sign((uv.y - Line(uv, P3, P1)) * Sign3) * .5 + .5;\n    \n    return Line1 * Line2 * Line3;\n}\n\n#define pi 3.14159\n//from https://www.shadertoy.com/view/Nl33W8\nmat3 AxisAngle(vec3 Axis, float Angle) {\n    float Sin = cos(Angle + pi * .5);\n    float Cos = cos(Angle);\n    return mat3(\n        Axis * Axis.x * (1. - Cos) + vec3(Cos, Axis.z * Sin, -Axis.y * Sin),\n        Axis * Axis.y * (1. - Cos) + vec3(-Axis.z * Sin, Cos, Axis.x * Sin),\n        Axis * Axis.z * (1. - Cos) + vec3(Axis.y * Sin, -Axis.x * Sin, Cos)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 CamPos = vec3(0., 0., 4.);\n    mat3 CamRot = AxisAngle(vec3(0., 1., 0.), iTime) * AxisAngle(vec3(1., 0., 0.), sin(iTime));\n\n    float Sum = 0.;\n    for (int i = 0; i < FaceCount; i++) {\n        mat3 Face = -Faces[i];\n        \n        vec3 P1 = Face[0] * CamRot - CamPos;\n        vec3 P2 = Face[1] * CamRot - CamPos;\n        vec3 P3 = Face[2] * CamRot - CamPos;\n        \n        vec3 Normal = normalize(cross(P1 - P2, P1 - P3));\n        \n        P1 /= P1.z;\n        P2 /= P2.z;\n        P3 /= P3.z;\n        \n        float Dot = dot(Normal, normalize((P1 + P2 + P3) / 3.));\n        if (Dot > 0.) {\n            Sum = mix(Sum, Dot, Triangle(uv, P1.xy, P2.xy, P3.xy));\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(Sum), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FaceCount 12\nconst mat3 Faces[FaceCount] = mat3[FaceCount](\n    //Face1\n    mat3(\n        -1., 1., 1.,\n        1., -1., 1.,\n        -1., -1., 1.\n    ),\n    mat3(\n        1., -1., 1.,\n        -1., 1., 1.,\n        1., 1., 1.\n    ),\n    \n    //Face2\n    mat3(\n        -1., 1., 1.,\n        -1., -1., 1.,\n        -1., 1., -1.\n    ),\n    mat3(\n        -1., 1., -1.,\n        -1., -1., 1.,\n        -1., -1., -1.\n    ),\n    \n    //Face3\n    mat3(\n        1., -1., -1.,\n        -1., 1., -1.,\n        -1., -1., -1.\n    ),\n    mat3(\n        -1., 1., -1.,\n        1., -1., -1.,\n        1., 1., -1.\n    ),\n    \n    //Face4\n    mat3(\n        1., -1., 1.,\n        1., 1., 1.,\n        1., 1., -1.\n    ),\n    mat3(\n        1., -1., 1.,\n        1., 1., -1.,\n        1., -1., -1.\n    ),\n    \n    //Face5\n    mat3(\n        1., 1., -1.,\n        1., 1., 1.,\n        -1., 1., -1.\n    ),\n    mat3(\n        1., 1., 1.,\n        -1., 1., 1.,\n        -1., 1., -1.\n    ),\n    \n    //Face6\n    mat3(\n        1., -1., 1.,\n        1., -1., -1.,\n        -1., -1., -1.\n    ),\n    mat3(\n        -1., -1., 1.,\n        1., -1., 1.,\n        -1., -1., -1.\n    )\n);","name":"Common","description":"","type":"common"}]}