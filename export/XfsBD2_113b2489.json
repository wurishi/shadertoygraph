{"ver":"0.1","info":{"id":"XfsBD2","date":"1724386792","viewed":2,"name":"METABALL TEST","username":"lambwww","description":"METABALL","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 4.\n\nstruct MetaBall{\n\tfloat r;\n    vec2 pos;\n    vec3 col;\n};\nstruct MetaBox{\n    vec2 pos;\n    float halfHeight;\n    float halfWidth;\n    vec3 col;\n};\n// 计算圆的势能值\nvec4 BallSDF(MetaBall ball, vec2 uv){\n    float dst = ball.r / length(uv - ball.pos);\n    dst = pow(dst, 2.);\n    return vec4(ball.col * dst, dst);\n}\n//计算矩形的势能\nvec4 BoxSDF(MetaBox box, vec2 uv) {\n    /*vec2 d = uv - box.pos;\n    float dist = max(abs(d.x) - box.halfWidth, abs(d.y) - box.halfHeight);\n    if(dist > .0) { // 矩形外面\n        \n    }else { //矩形里面\n    \n    }\n    return vec4(box.col * dist, dist);*/\n    if(box.pos.x == uv.x)\n    {\n        float dist = box.halfHeight / length(box.pos - uv);\n        dist = pow(dist, 2.);\n        return vec4(box.col * dist, dist);\n    }\n    else if(box.pos.y == uv.y)\n    {\n        float dist = box.halfWidth/ length(box.pos - uv);\n        dist = pow(dist, 2.);\n        return vec4(box.col * dist, dist);\n    }\n    float left = box.pos.x - box.halfWidth;\n    float right = box.pos.x + box.halfWidth;\n    float top = box.pos.y + box.halfHeight;\n    float bottom = box.pos.y - box.halfHeight;\n    /*if(abs(box.pos.y-uv.y)*box.halfWidth == abs(box.pos.x-uv.x)*box.halfHeight)\n    {\n        float dist = (pow(box.halfWidth, 2.)+pow(box.halfHeight, 2.))/ pow(length(box.pos - uv),2.);\n        return vec4(texture(iChannel0, uv).rgb, dist);\n    }*/\n    vec2 dir = box.pos - uv;\n    float tx1 = (left - uv.x) / dir.x;\n    float tx2 = (right - uv.x) / dir.x;\n    float ty1 = (box.pos.y - box.halfHeight - uv.y) / dir.y;\n    float ty2 = (box.pos.y + box.halfHeight - uv.y) / dir.y;\n    float tx=10000000.,ty=10000000.; // 最后取得是tx和ty中最小的数，这里把tx和ty设置成极大数是因为如果射线起点在矩形内部，射线在反方向取值时t这个时候是负数，可能会取成远的那个值\n    // 从两个t中选出真的和矩形相交的那一个\n    float testX = uv.y + tx1 * dir.y;\n    float temp = step(testX, top) * step(bottom, testX);\n    tx = step(1.,temp) * tx1 // if(temp==1.) tx=tx1 \n        + step(temp,0.) * tx; // else 也就是： if(temp==0.) tx=tx;\n    /*if(testX <= top && bottom <= testX){\n        tx = tx1;\n    }\n    else{ //mark，这个else好像没效果？\n        testX = uv.y + tx2 * dir.y;\n        if(testX <= top && bottom <= testX)\n            tx = tx2;\n    }*/\n    float testY = uv.x + ty1 * dir.x;\n    if(testY <= right && left <= testY){\n        ty = ty1;\n    }\n    else{\n        testY = uv.x + ty2 * dir.x;\n        if(testY <= right && left <= testY)\n            ty = ty2;\n    }\n    float t = min(tx, ty);\n    vec2 point = uv + t * dir;\n    float dist = length(point - box.pos) / length(box.pos - uv);\n    dist = pow(dist, 2.);\n    return vec4(box.col * dist, dist);\n}\nvec3 renderMetaBall(vec2 uv){\n\tMetaBall  mbr, mbg, mbb;\n    mbr.pos = vec2(-0.8, sin(iTime*1.5 + 0.5));\n    //mbr.pos = vec2((iTime * 2.6), 1.4 * iTime);\n    mbr.r = 0.3; mbr.col = vec3(1., 0., 0.);\n    mbg.pos = vec2(0.0, sin(iTime*0.6 + 0.9)); \n    //mbg.pos = vec2((-2.4 * iTime ), .0);\n    mbg.r = 0.9; mbg.col = vec3(0., 1., 0.);\n    mbb.pos = vec2(0.5, -0.5+sin(iTime*0.9 + 1.1)); \n    //mbb.pos = vec2(2.5 * iTime, -0.3 * iTime);\n    mbb.r = 0.8; mbb.col = vec3(0., 0., 1.);\n\tMetaBox mtb;\n    mtb.pos = vec2(.0, -.8);\n    mtb.halfHeight = .3; \n    mtb.halfWidth = .4; \n    mtb.col = vec3(1.0);//texture(iChannel0, uv).rgb;\n    \n    vec4 ballr = BallSDF(mbr, uv);\n    vec4 ballg = BallSDF(mbg, uv);\n    vec4 ballb = BallSDF(mbb, uv);\n    vec4 box = BoxSDF(mtb, uv);\n    // 通过势能大小进行着色，势能越大（也就是r越大），代表离物体越近，所以颜色更足\n    float r = ballr.a + ballg.a + ballb.a + box.a;\n    // 下面这段注释掉的是一个抗锯齿操作，模糊了物体的边界颜色。但是看起来像散光，所以选择了多次采样的抗锯齿\n    vec3 color = r < 5.5 \n    ? vec3(0.)\n    : (r < 6.6\n        ? (smoothstep(0.1, 0., 6.0 - r) * (ballr.rgb + ballg.rgb + ballb.rgb + box.rgb)/4. + vec3(0.))\n        : (ballr.rgb + ballg.rgb + ballb.rgb + box.rgb)/4. );\n    /*vec3 color = r < 5. \n    ? vec3(1.)\n    : (ballr.rgb + ballg.rgb + ballb.rgb)/4.;*/\n    //if(box.a > 3.0) color=mtb.col;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    col = renderMetaBall(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}