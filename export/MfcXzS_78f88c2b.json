{"ver":"0.1","info":{"id":"MfcXzS","date":"1714059673","viewed":165,"name":"Droplet Splash","username":"gunthern","description":"Trying to recreate the effect of a drop of liquid landing on a surface with raymarched SDFs.\n\nThis is an updated version of a shader I wrote a long time ago before I knew as much about raymarching. Thanks @oneshade for good advice on animation timing.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fluid","slomo","splash","slowmo","droplet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141593\n#define MAX_STEPS 100\n#define  MAX_DIST 50.0\n#define SURFACE_DIST 0.01\n\n// Enable Raymarched REFRACT and REFLECT below - performance warning\n//#define REFRACT\n//#define REFLECT\n#define NUM_BOUNCES 2\n#define BGMULT vec3(0.9, 0.92, 1.0)\n\n// Surface constructor\nstruct Surface {\n\n    float dist;\n    vec3 col;\n    vec3 refl;\n    vec3 refr;\n    \n};\n\n// Rotate2D from the Art of Code\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Smooth min\nSurface smin(Surface a, Surface b, float k) {\n    \n    float h = clamp(0.5 + 0.5*(b.dist - a.dist)/k, 0.0, 1.0);\n\n    float d = mix(b.dist, a.dist, h) - k*h*(1.0-h);\n    \n    return Surface(\n        d,\n        mix(b.col, a.col, h),\n        mix(b.refl, a.refl, h),\n        mix(b.refr, a.refr, h)\n    );\n    \n}\n\n// SDFs from iquilez\nSurface sdRoundCone(vec3 p, vec2 r, float h, vec3 col, vec3 refl, vec3 refr)\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r.x-r.y)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  float l = 0.0;\n  if( k<0.0 ) l = length(q) - r.x;\n  else if( k>a*h ) l = length(q-vec2(0.0,h)) - r.y;\n  else l = dot(q, vec2(a,b) ) - r.x;\n  return Surface(\n      l,\n      col,\n      refl,\n      refr\n  );\n}\n\nSurface sdSphere(vec3 p, vec3 s, float r, vec3 col, vec3 refl, vec3 refr) {\n    float d = length(p-s.xyz)-r;\n    return Surface(\n        d,\n        col,\n        refl,\n        refr\n    );\n}\n\nSurface sdTorus(vec3 p, vec2 r, vec3 col, vec3 refl, vec3 refr) {\n    float x = length(p.xz) - r.x;\n    float d = length(vec2(x, p.y)) - r.y;\n    return Surface(\n        d,\n        col,\n        refl,\n        refr\n    );\n}\n\nfloat opDisplace(in Surface primitive, in vec3 p, in float s, in float m)\n{\n    float d1 = primitive.dist;\n    float d2 = sin(p.x*s)*sin(p.y*s)*sin(p.z*s) * m;\n    return d1+d2;\n}\n\n// Scene\nSurface GetDistColor(vec3 p){\n\n    // Water material values\n    vec3 waterCol = vec3(0.0, 0.0, 0.03);\n    vec3 waterDropRefl= vec3(0.5, 0.6, 0.65);\n    vec3 waterDropRefr= vec3(0.7, 0.8, 0.85);\n    vec3 waterSurfaceRefl = vec3(0.7, 0.85, 0.9);\n    vec3 waterSurfaceRefr = vec3(0.5, 0.55, 0.6);\n    \n    // Surface\n    float waterSurfaceDistort = \n        ((sin(p.x*0.5) * sin(iTime) * 0.2\n        + cos(p.z*0.5) * cos(iTime) * 0.2)\n        * (1.0 - smoothstep(0.0, 5.0, (5.0 - distance(p, vec3(0.0))))))\n        * clamp(iTime*0.1 - 1.0, 0.0, 1.0);\n        \n    float waterSurfaceRipple =\n        sin(distance(p, vec3(0.0)) * 3.0 - (iTime-PI/2.0+0.2)*2.0) * 0.1\n        * pow(\n            smoothstep(0.0, clamp(iTime-PI, 0.0, 4.0) * 2.5,\n            (clamp(iTime-PI+0.1, 0.0, 4.0) * 2.5 - distance(p, vec3(0.0)))), 3.0\n        );\n        \n    Surface waterSurface = \n        sdSphere(\n            vec3(p.x, p.y + waterSurfaceRipple - waterSurfaceDistort, p.z),\n            vec3(0.0, -250.0, 0.0),\n            250.0,\n            waterCol,\n            waterSurfaceRefl,\n            waterSurfaceRefr\n        );\n    \n    // Main drop\n    Surface mainDrop = \n        sdSphere(\n            p, \n            vec3(0.0, -6.0*(clamp(tan(iTime), -10.0, 10.0)), 0.0),\n            0.25,\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n        \n    // Initial splash\n    float splashTorusMod = mod(-(iTime-0.03)/PI*2.0, 2.0) - 1.0;\n        \n    float splashTorusWave =\n        splashTorusMod * ((1.0 - pow(splashTorusMod, 30.0)) + 1.0); // Smooth sawtooth\n    \n    float splashTorusRad =\n        (1.0 - pow((mod(-(iTime-PI-0.03)/PI*2.0, 2.0)), 2.0) + PI) * 0.4; // Exp sawtooth\n        \n    float splashTorusY =\n        splashTorusMod * max(1.0 - pow(splashTorusMod, 6.0), 0.0) - 0.4; // Smooth sawtooth\n        \n    Surface splashTorus =\n        sdTorus(\n            (p - vec3(0.0, splashTorusY, 0.0)) * vec3(1.0, 0.3, 1.0),\n            vec2(splashTorusRad, 0.05 * max(splashTorusWave, 0.1)),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n       \n    splashTorus.dist = opDisplace(splashTorus, p, 20.0, 0.005*max(splashTorusWave, 0.0));\n    \n    // Subtractive sphere for splash and rebound cavity\n    Surface splashSubtractSphere =\n        sdSphere(\n            p * vec3(1.0, 1.5, 1.0),\n            vec3(0.0, 1.0 + sin(iTime), 0.0),\n            -min(sin(iTime), 0.0),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n        \n    splashSubtractSphere.dist = -opDisplace(splashSubtractSphere, p, 10.0, 0.02);\n    \n    // Rebound cone\n    float reboundConeWave =\n        (1.0 - sin(iTime-PI/2.0+0.1))*2.0 - 4.0;\n    \n    Surface reboundCone = \n        sdRoundCone(\n            p - vec3(0.0, reboundConeWave, 0.0),\n            vec2(min(0.25/max(p.y+1.0, 0.1)-(sin(iTime-1.0) + 0.66)*0.4, 1.0), 0.25/max(p.y+2.0, 1.0)-max((sin(iTime+0.3)*0.2)*0.7, 0.0)),\n            2.0,\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n        \n    // Rebound drops\n    Surface reboundDrop0 = \n        sdSphere(\n            p,\n            vec3(0.0, 2.22*sin(iTime-4.7), 0.0),\n            0.15 * sin(iTime-PI/4.0-4.7),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n        \n    Surface reboundDrop1 = \n        sdSphere(\n            p, \n            vec3(0.0, 2.22*sin(iTime-4.7) - 0.7, 0.0), \n            0.15 * sin(iTime-PI/4.0-4.9),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n        \n    Surface reboundDrop2 = \n        sdSphere(\n            p, \n            vec3(0.0, 2.22*sin(iTime-4.7) - 1.5, 0.0), \n            0.2 * sin(iTime-PI/4.0-4.7),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n    \n    // Rebound ripples\n    Surface torus0Dist = \n        sdTorus(\n            p - vec3(0.0, -0.5*cos(iTime-PI-0.85)-0.75, 0.0),\n            vec2(2.0*sin(iTime-0.85), 0.5*sin(iTime-0.85)),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n        \n    Surface torus1Dist = \n        sdTorus(\n            p - vec3(0.0, -0.5*cos(iTime-PI-1.2)-0.75, 0.0),\n            vec2(2.0*sin(iTime-1.2), 0.5*sin(iTime-1.2)),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n        \n    Surface torus2Dist = \n        sdTorus(\n            p - vec3(0.0, -0.5*cos(iTime-PI-1.7)-0.75, 0.0),\n            vec2(2.0*sin(iTime-1.7), 0.5*sin(iTime-1.7)),\n            waterCol,\n            waterDropRefl,\n            waterDropRefr\n        );\n    \n    // Splash cycle\n    bool activeSplashCycle = \n        sin(iTime-0.03) < 0.0 && sin(iTime-2.73) > 0.1;\n    \n    // Main drop cycle\n    bool activeDropCycle = sign(sin(iTime-PI-0.2)) < 0.0;\n    \n    // Smooth min (union of surfaces)\n    Surface scene = waterSurface;\n    if (activeSplashCycle) {\n       scene = smin(waterSurface, splashTorus, 0.2*clamp(splashTorusWave, 0.0, 1.0));\n    }\n    \n    // Subtractive sphere for initial splash\n    scene = smin(scene, splashSubtractSphere, -0.2);\n    \n    // Rebound cone, drops\n    if (iTime > 2.5) {\n        scene = smin(scene, reboundCone, 0.2);\n        scene = smin(scene, reboundDrop0, 0.35);\n        scene = smin(scene, reboundDrop1, 0.2);\n        scene = smin(scene, reboundDrop2, 0.1);\n    }\n    \n    if (iTime > 4.5) {\n        scene = smin(scene, torus0Dist, 0.5);\n        scene = smin(scene, torus1Dist, 0.5);\n        scene = smin(scene, torus2Dist, 0.5);\n    }\n    \n    \n    if (activeDropCycle) {\n        scene = smin(scene, mainDrop, 0.01);\n    }\n    \n    return scene;\n}\n\nSurface RayMarch(vec3 ro, vec3 rd, float side){\n    float dO = 0.0;\n    Surface distColor;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        distColor = GetDistColor(p);\n        float dS = distColor.dist * side;\n        dO += dS;\n        if (dO>MAX_DIST) break;\n    }\n    \n    return Surface(\n        dO,\n        distColor.col,\n        distColor.refl,\n        distColor.refr\n    );\n}\n\nvec3 GetNormal(vec3 p) {\n    Surface d = GetDistColor(p);\n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = d.dist - vec3(\n        GetDistColor(p-e.xyy).dist,\n        GetDistColor(p-e.yxy).dist,\n        GetDistColor(p-e.yyx).dist);\n        \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Render(\n        inout vec3 ro,\n        inout vec3 rd,\n        inout vec3 bounce,\n        bool last\n    ) {\n    \n    vec3 col = vec3(0.0);\n    vec3 emissive = vec3(0.0);\n    bounce = vec3(0.0);\n    \n    Surface distColor = RayMarch(ro, rd, 1.0);\n    float d = distColor.dist;\n    \n    float ior = 1.333;\n    \n    if (d < MAX_DIST) {\n    \n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        // Refraction\n        vec3 refr = vec3(0.0);\n        vec3 rdIn = refract(rd, n, 1.0/ior);\n#if defined REFRACT\n        vec3 pEnter = p - n*SURFACE_DIST*3.0;\n        float dIn = RayMarch(pEnter, rdIn, -1.0).dist;\n\n        vec3 pExit = pEnter + rdIn * dIn;\n        vec3 nExit = -GetNormal(pExit);\n        vec3 rdOut = refract(rdIn, nExit, ior);\n        if(dot(rdOut, rdOut)<SURFACE_DIST) {\n            rdOut = reflect(rdIn, nExit);\n        }\n\n        vec3 refrTex = texture(iChannel0, rdOut).rgb * BGMULT;\n        if (dIn > MAX_DIST) {\n            refrTex = texture(iChannel0, rdIn).rgb * BGMULT;\n        }\n        \n#else\n        vec3 refrTex = texture(iChannel0, rdIn).rgb * BGMULT;\n#endif\n        refr = refrTex * distColor.refr;\n            \n        // Reflection\n        ro = p + n*SURFACE_DIST*3.0;\n        \n        float fresnel = pow(1.0 + dot(rd, n), 2.4);\n#if defined REFLECT\n        bounce = clamp(vec3(fresnel*distColor.refl), 0.0, 1.0);\n        \n        rd = r;\n        \n        // Assemble\n        col = distColor.col + refr;\n        \n        if (last) {\n            vec3 reflTex = texture(iChannel0, r).rgb * fresnel * BGMULT;\n            col += reflTex * distColor.refl;\n        }\n#else \n        col = distColor.col + refr;\n        vec3 reflTex = texture(iChannel0, r).rgb * fresnel * BGMULT;\n        col += reflTex * distColor.refl;\n#endif\n        \n    }\n    else {\n        col = texture(iChannel0, rd).rgb * BGMULT;\n    }\n    \n    return col;\n}\n\n// Mouse rotation from the Art of Code https://www.shadertoy.com/view/sdsXWr\nmat2 mouseRot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n    // Ray origin and mouse rotation\n    vec2 m = iMouse.xy/iResolution.xy - 0.5;\n    vec3 ro = vec3(0.0, 2.0, -6.0);\n    ro.yz *= mouseRot(m.y);\n    ro.xz *= mouseRot(-m.x*PI*2.0 + PI);\n    ro.y = max(ro.y, 1.0);\n        \n    // Ray direction\n    vec3 rd = GetRayDir(uv, ro, vec3(0.0, 1.0, 0.0), 1.0);\n    \n    // Render\n    vec3 refl = vec3(0.0);\n    vec3 filt = vec3(1.0);\n    vec3 col = Render(ro, rd, refl, false);\n    \n    // Reflection\n#if defined REFLECT\n    for (int i=0; i<NUM_BOUNCES; i++) {\n        filt *= refl;\n        vec3 bounce = filt * Render(ro, rd, refl, i==NUM_BOUNCES-1);\n        col += bounce, 0.0, 1.0;\n    }\n#endif\n    \n    // Gamma\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}