{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec2 clip_coord(vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\treturn 2.0*aspect*fragCoord.xy/iResolution.xy - aspect;\n}\n\nvec3 eye_ray(vec3 eye, vec3 look_at, vec3 eye_up, float fov, vec2 fragCoord){\n\t// Do as a matrix?\n\tvec3 forward = normalize(look_at - eye);\n\tvec3 right = cross(forward, normalize(eye_up));\n\tvec3 up = cross(right, forward);\n\t\n\tvec2 clip = clip_coord(fragCoord);\n\treturn normalize(forward + (clip.x*fov)*right + clip.y*up);\n}\n\nfloat d_sphere(vec3 v, vec3 p, float r){\n\treturn length(v - p) - r;\n}\n\nfloat d_cylinder(vec3 v, vec3 p, vec3 n, float r, float l){\n\tfloat dvn = dot(v - p, n);\n\treturn max(\n\t\tlength(v - n*dvn) - r,\n\t\tabs(dvn) - l*0.5\n\t);\n}\n\nfloat d_box(vec3 v, vec3 p, vec3 b){\n\tvec3 d = abs(v - p) - b*0.5;\n\treturn max(max(d.x, d.y), d.z);\n}\n\nfloat d_union(float d1, float d2){ return min(d1, d2); }\nfloat d_subtract(float d1, float d2){ return max(d1, -d2); }\nfloat d_intersect(float d1, float d2){ return max(d1, d2); }\n\nfloat dist(vec3 v){\n\tfloat s = 1.3;\n\tfloat r = mix(1.6, 1.8, 0.5*sin(2.0*iTime) + 0.5);\n\t\n\tfloat d = 1e10;\n\td = d_union(d, -d_box(v, vec3(0), vec3(10.0)));\n\td = d_union(d, d_box(v, vec3(0), vec3(2.0*s)));\n\td = d_subtract(d, d_sphere(v, vec3(0), r));\n\td = d_union(d, d_sphere(v, vec3(0), r*0.75));\n\td = d_union(d, d_cylinder(v, vec3(0), vec3(1,0,0), 0.2, 10.0));\n\td = d_union(d, d_cylinder(v, vec3(0), vec3(0,1,0), 0.2, 10.0));\n\td = d_union(d, d_cylinder(v, vec3(0), vec3(0,0,1), 0.2, 10.0));\n\treturn d;\n}\n\nconst float g_eps = 1e-3;\n\nvec3 grad(vec3 p){\n\treturn normalize(vec3(\n\t\tdist(p + vec3(g_eps,0,0)) - dist(p - vec3(g_eps,0,0)),\n\t\tdist(p + vec3(0,g_eps,0)) - dist(p - vec3(0,g_eps,0)),\n\t\tdist(p + vec3(0,0,g_eps)) - dist(p - vec3(0,0,g_eps))\n\t));\n}\n\nconst int iterations = 64;\nconst float threshold = 1e-3;\nconst float min_step = 1e-4;\nconst float step_fraction = 0.75;\n\nstruct Hit {\n\tvec3 p, n;\n\tfloat d;\n};\n\nHit raymarch(vec3 eye, vec3 ray){\n\tfloat dsum = 0.0;\n\tfor(int i=0; i<iterations; i++){\n\t\tvec3 p = eye + dsum*ray;\n\t\tfloat dmin = dist(p);\n\t\tif(dmin < threshold){\n\t\t\treturn Hit(p, grad(p), dsum);\n\t\t} else {\n\t\t\tdsum += max(min_step, dmin*step_fraction);\n\t\t}\n\t}\n\t\n\tvec3 p = eye + dsum*ray;\n\treturn Hit(p, vec3(0), dsum);\n}\n\nconst float ao_samples = 4.0;\nconst float ao_spacing = 0.3;\nconst float ao_strength = 4.0;\n\nfloat ao(Hit hit){\n\tfloat sum = 0.0;\n\tfor(float i=1.0; i<=ao_samples; i++){\n\t\tfloat d = i*ao_spacing;\n\t\tsum += (d - dist(hit.p + hit.n*d))/pow(2.0, i);\n\t}\n\t\n\treturn 1.0 - ao_strength*sum;\n}\n\nconst int shadow_iterations = 256;\n\nfloat shadowmarch(vec3 point, vec3 light){\n\tvec3 delta = light - point;\n\tfloat dmax = length(delta);\n\tvec3 ray = delta/dmax;\n\t\n\tfloat shadow = 1.0;\n\tfloat dsum = 0.1;\n\tfor(int i=0; i<shadow_iterations; i++){\n\t\tvec3 p = point + ray*dsum;\n\t\tfloat d = dist(p);\n\t\tif(d < 1e-6) return 0.0;\n\t\t\n\t\tdsum += max(min_step, d*step_fraction);\n\t\tshadow = min(shadow, 128.0*d/dsum);\n\t\tif(dsum > dmax) return shadow;\n\t}\n\t\n\treturn shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime/3.0;\n\tvec3 eye = -4.0*normalize(vec3(-cos(t), cos(0.5*t), -sin(t)));\n\tvec3 look_at = vec3(0);\n\tvec3 up = vec3(0,sin(t),cos(t));\n\t\n\tvec3 ray = eye_ray(eye, look_at, up, 1.0, fragCoord);\n\tHit hit = raymarch(eye, ray);\n\tvec3 albedo = abs(hit.n);\n\tfloat occlusion = ao(hit);\n\tvec3 color = albedo;\n\t\n\tvec3 light_pos = -eye.yzx;\n\tvec3 light_dir = normalize(light_pos - hit.p);\n\tfloat diff = clamp(dot(light_dir, hit.n), 0.0, 1.0);\n\t\n\tfloat spec = pow(clamp(dot(reflect(ray, hit.n), light_dir), 0.0, 1.0), 50.0);\n\tfloat light = 0.5*diff + 1.0*spec;\n\tfloat shadow = shadowmarch(hit.p, light_pos);\n\tcolor *= occlusion*(light*shadow + 0.1);\n\t\n\tvec3 fog_color = abs(ray);\n\tcolor = mix(color, fog_color, hit.d/12.0);\n\t\n\t// TODO add a curve to filter out the > 1.0 crustees\n\tcolor += 0.5*albedo*pow(1.0 + dot(hit.n, ray), 4.0);\n\t\n\tfragColor = vec4(color, 0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdfGDB","date":"1378285240","viewed":838,"name":"Lighting Thingy","username":"slembcke","description":"Ambient occlusion and shadows on a distance field. Kinda neat I guess. The shadowing could use some work.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shadows","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""}}