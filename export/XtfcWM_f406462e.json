{"ver":"0.1","info":{"id":"XtfcWM","date":"1504949974","viewed":377,"name":"3D ray intersection math","username":"Daedelus","description":"3D ray intersection math","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3drayintersectionmath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// intersection code\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat rayPlaneIsect(Ray ray, vec3 origin, vec3 normal)\n{\n    return dot(origin - ray.origin, normal) / dot(ray.direction, normal);\n}\n\nvec2 raySphereIsect(Ray ray, vec3 origin, float radius)\n{\n    float t = rayPlaneIsect(ray, origin, ray.direction);\n    vec3 p = ray.origin - origin + ray.direction * t;\n    float dt = sqrt(radius * radius - dot(p, p));\n    return vec2(-dt, dt) + t;\n}\n\nfloat rayInsideBoxIsect(Ray ray, vec3 origin, vec3 extents)\n{\n\tvec3 local = origin - ray.origin;\n    vec3 distances = abs(local / ray.direction);\n    vec3 offsets = extents / ray.direction;\n    distances = distances + max(offsets, -offsets);\n    return min(distances.x, min(distances.y, distances.z));\n}\nvec2 rayBoxIntersect(Ray ray, vec3 origin, vec3 extents)\n{\n    vec3 tbot = (origin - extents - ray.origin) / ray.direction;\n    vec3 ttop = (origin + extents - ray.origin) / ray.direction;\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    if(t1 < max(t0, 0.0))\n        return vec2(1.0/0.0); // return inf\n    return vec2(t0, t1);\n}\n\n// render utilities\n#define D(w,l, cl) fragColor.rgb = mix( fragColor.rgb, cl, smoothstep(10./iResolution.y,0.,length(l)-w) )\n\n#define _circle(fragColor, uv, cl, pt, r) D(r, pt-uv, cl)\n\n#define circle(cl,pt,r) _circle(fragColor,uv,cl,pt,r)\n\n#define _circleEdge(fragColor, uv, cl, pt, r, w) D(w,length(uv-pt)-r, cl)\n\n#define circleEdge(cl,pt,r,w) _circleEdge(fragColor,uv,cl,pt,r,w)\n\n#define _direction(fragColor, uv, cl, o, d, w) D(w, d*dot(uv-o,d)+o-uv, cl)\n\n#define direction(cl,o,d,w) _direction(fragColor,uv,cl,o,d,w)\n\n#define _line(fragColor, uv, cl, o, d, l, w)  D(w, d*clamp(dot(uv-(o),d),0.0,l)+o-(uv), cl)\n\n#define line(cl,o,d,l,w) _line(fragColor,uv,cl,o,d,l,w)\n\n// combined functions\nvoid plane(inout vec4 fragColor, vec2 uv, Ray ray, vec3 origin, vec3 normal)\n{\n    normal = normalize(normal);\n    \n    // render plane & normal\n    direction(vec3(1, 1, 0), origin.xy, vec2(normal.y,-normal.x), 0.01);\n    line(vec3(0, 1, 1), origin.xy, normal.xy, 1.0, 0.01);\n    \n    // intersect & render result\n    float t = rayPlaneIsect(ray, origin, normal);\n    circle(vec3(1, 0, 0),ray.origin.xy+ray.direction.xy*t, 0.1);\n}\nvoid sphere(inout vec4 fragColor, vec2 uv, Ray ray, vec3 origin, float radius)\n{\n    // render sphere & some of its normals\n    circleEdge(vec3(1, 1, 0), origin.xy, radius, 0.01);\n    const int N = 16;\n    for(int i = 0; i < N; ++i)\n    {\n        float a = float(i+i)/float(N) * 3.14159265359;\n        vec2 n = vec2(cos(a), sin(a));\n        line(vec3(0, 1, 1),origin.xy+radius*n,n, 1.0, 0.01);\n    }\n    \n    // debug draw the intersection steps\n    direction(vec3(0.5),origin.xy,vec2(ray.direction.y,-ray.direction.x), 0.01);\n    line(vec3(0.5),origin.xy,ray.direction.xy, 1.0, 0.02);\n    \n    // intersect & render result\n    vec2 t = raySphereIsect(ray,origin,radius);\n    circle(vec3(1, 0, 0),ray.origin.xy+ray.direction.xy*t.x,0.1);\n    circle(vec3(1, 0, 0),ray.origin.xy+ray.direction.xy*t.y,0.1);\n}\nvoid box(inout vec4 fragColor, vec2 uv, Ray ray, vec3 origin, vec3 extents)\n{\n    // render sides\n    line(vec3(1, 1, 0), origin.xy - extents.xy, vec2(1.0, 0.0), 2.0 * extents.x, 0.01);\n    line(vec3(1, 1, 0), origin.xy - extents.xy, vec2(0.0, 1.0), 2.0 * extents.y, 0.01);\n    line(vec3(1, 1, 0), origin.xy + extents.xy, vec2(-1.0, 0.0), 2.0 * extents.x, 0.01);\n    line(vec3(1, 1, 0), origin.xy + extents.xy, vec2(0.0, -1.0), 2.0 * extents.y, 0.01);\n    \n    // intersect & render result\n    vec2 t = rayBoxIntersect(ray, origin, extents);\n    circle(vec3(1, 0, 0),ray.origin.xy+ray.direction.xy*t.x, 0.1);\n    circle(vec3(1, 0, 0),ray.origin.xy+ray.direction.xy*t.y, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // setup\n    const float scale = 5.0;\n    \n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= scale;\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    mouse *= scale;\n    \n    vec3 rayOrigin = vec3(-2, 1, 0);\n    vec3 rayDirection = normalize(vec3(mouse, 0) - rayOrigin);\n    Ray ray = Ray(rayOrigin, rayDirection);\n    \n\tfragColor = vec4(0);\n    \n    // draw ray\n    circle(vec3(1.0), rayOrigin.xy, 0.2);\n    direction(vec3(1.0), rayOrigin.xy, rayDirection.xy, 0.01);\n \t\n    // intersect planes\n    plane(fragColor, uv, ray, vec3(5, 0, 0), vec3(-1, -0.5, 0));\n    plane(fragColor, uv, ray, vec3(-5, 0, 0), vec3(-1, 0.25, 0));\n    \n    // intersect spheres\n    sphere(fragColor, uv, ray, vec3(1, 3, 0), 1.0);\n    sphere(fragColor, uv, ray, vec3(2, -3, 0), 2.0);\n    sphere(fragColor, uv, ray, vec3(1, 1, 0), 5.0);\n    \n    // intersect box\n    box(fragColor, uv, ray, vec3(2.5, 0.0, 0.0), vec3(1.5));\n    box(fragColor, uv, ray, vec3(-2.5, 0.0, 0.0), vec3(1.5));\n}\n","name":"Image","description":"","type":"image"}]}