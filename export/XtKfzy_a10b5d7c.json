{"ver":"0.1","info":{"id":"XtKfzy","date":"1542987909","viewed":137,"name":"Kaleidoscope-ish","username":"Stinger21","description":"Not elegant, mostly arrived at through playing with shapes.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["triangle","triangles","kaleidoscope","trippy","tile","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// HLSL Compatability because I'm lazy. (sorry)\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define frac fract\n#define lerp mix\n#define saturate(X) clamp(X, 0.0, 1.0)\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n#define rcp(x) 1.0f / x \n#define atan2 atan\n\n\t\nfloat2 RotateUVsByVector(float2 RotationCenter, float2 UV, float2 Direction)\n{\n    // Offset to (0, 0)\n    float2 OffsetUV = UV - RotationCenter;\n\n    // 2D matrix multiplication kinda\n    float NewU = dot(OffsetUV, float2(Direction.y, -Direction.x));\n    float NewV = dot(OffsetUV, float2(Direction.x, Direction.y));\n\n    // Offset back\n    return float2(NewU, NewV) + RotationCenter;\n}\n\nfloat2 AngleToVector(float Angle)\n{\n    return float2(sin(Angle), cos(Angle));\n}\n\n// Rotator\nfloat2 RotateUVs(float2 RotationCenter, float2 UV, float Angle)\n{\n    Angle *= 6.28318548;\n\n    return RotateUVsByVector(RotationCenter, UV, AngleToVector(Angle));\n}\n\nfloat2 MirrorAlongAxis(float2 UV, float2 Axis)\n{\n    UV -= 0.5;\n    UV = UV - (dot(UV, Axis) * Axis * 2.0);\n    UV += 0.5;\n    return UV;\n}\n\nvoid mainImage( out float4 fragColor, in float2 fragCoord )\n{\n    float3 result = float3(0,0,0);\n    \n    vec2 UV = fragCoord/iResolution.xy;\n    \n    float col = 0.;\n    \n    float2 ImageScale = float2(1.0, 1.2);\n    \n    float Scale = 5.;\n    \n    float2 ScaledUV = UV * Scale / ImageScale;\n    \n    float TriangleDirection = ceil(frac(ScaledUV).y - frac(ScaledUV.x + ScaledUV.y * 0.5));\n    \n    \n    float Rows = ((1.0 - floor(frac((ScaledUV.y * 0.5)) * 2.))*0.5);\n    float RowIndex = floor(ScaledUV.y);\n        \n    \n    float TriangleIndex1 = (floor((ScaledUV.x - Rows*3.)) + 0.5) * 2.;\n    float TriangleIndex2 = floor((ScaledUV.x - Rows*3.) + 0.5) * 2.;\n                                \t   \n    \n    float IndexX = lerp(TriangleIndex2, TriangleIndex1, TriangleDirection);\n    float IndexY = RowIndex;\n    \n    float2 UpDownOffset = float2(0, ((TriangleDirection - 0.5) * -0.32));\n    \n    \n    float2 UV1 = float2(ScaledUV.x + Rows + 0.5, ScaledUV.y);\n    float2 UV2 = float2(ScaledUV.x + Rows, ScaledUV.y);\n    \n    float2 BlendedUV = frac(lerp(UV1, UV2, TriangleDirection)) + UpDownOffset;\n    \n    if(TriangleDirection > 0.5)\n    {\n    \tBlendedUV = MirrorAlongAxis(BlendedUV, AngleToVector(-2.094333));\n    }\n    \n\tfloat wat = mod(floor(IndexX / 2.0), 3.0);\n        \n    BlendedUV = RotateUVs(float2(0.5, 0.5), BlendedUV, (iTime * 0.1) + (wat * 3.3333));\n    \n    \n    float3 color = texture(iChannel0, saturate(((BlendedUV-0.5)*1.0)+0.5)).rgb;\n    \n    \n    // Output to screen\n    fragColor = float4(IndexX/20.,IndexX/20.,IndexX/20., 0.);\n    fragColor = float4(BlendedUV, 0., 0.);\n    fragColor = float4(color, 0.);\n}","name":"Image","description":"","type":"image"}]}