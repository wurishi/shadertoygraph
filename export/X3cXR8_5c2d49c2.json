{"ver":"0.1","info":{"id":"X3cXR8","date":"1719756161","viewed":53,"name":"let's create a color slider","username":"mkundera","description":"some shaders tutorial for the AKL training camp. Try clicking on the slider!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n\n\n// a function we'll use in part 3. reference: https://iquilezles.org/articles/palettes/\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n    {\n        return a + b*cos( 2.0*PI*(c*t+d) );\n    }\n    \n\n// a function we'll use in part 5. reference: https://www.shadertoy.com/view/Nlc3zf\nfloat box(vec2 position, vec2 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - cornerRadius;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n\n// 1. let's make the color vary based on the screen x position\n    \n    vec3 col = vec3(cos(2.0*PI*uv.x), 0.4, sin(2.0*PI*uv.x));\n\n\n    \n// 2. let's make the color move in time\n    \n    float moving_speed = 0.0;\n    float moving_horiz = uv.x + moving_speed*iTime; // the coefficient in front of the time variable adjusts the speed at which the color travels\n    \n    col = vec3(cos(2.0*PI*moving_horiz), 0.6, sin(2.0*PI*moving_horiz)); // we'll need to update our col vector for it to move in time\n\n\n    \n// 3. as you can see, the color palette isn't very apealing. Let's take a look at what IQ did.\n// https://www.shadertoy.com/view/ll2GD3 (a detailed explanation is available here: https://iquilezles.org/articles/palettes/)\n    \n       // take the time to test things out. Play around with the vectors.\n    col = pal( moving_horiz, vec3(0.7,0.2,0.5),vec3(0.7,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.1,0.67) );\n\n            \n            \n// 4. let's restrain our slider to a specific part of the image. \n// let's restrain it to a band in the middle of the screen\n        \n    float rectangle_mask = smoothstep(0.39,0.41, uv.y) * smoothstep(0.61, 0.59, uv.y); //what happens when you only output one smoothstep?\n    \n    //col *= rectangle_mask; // apply the mask to the color palette\n    \n\n\n// 5. let's make the slider a bit better looking. We'll use a rounded box sdf (signed distance function) for this. \n// here's a reference: https://www.shadertoy.com/view/Nlc3zf\n        \n    vec2 normalized_uv = (2.0*fragCoord - iResolution.xy)/iResolution.y; // needed, in order to use the signed distance function\n    \n    normalized_uv.y += 0.5; // this will only work if we comment out the col argument at line 55\n        \n    float rounded_box_sdf = box(normalized_uv, vec2(1.3, 0.1), 0.03);\n    \n    float rounded_box_mask = smoothstep(0.02, 0.0, rounded_box_sdf);\n    \n    col *=rounded_box_mask;\n    \n   \n   \n// 6. let's create a slider and a output screen above the slider. \n\n    //float slider = 1.0 - step(0.02,abs(normalized_uv.x));\n    \n    //col = max(vec3(slider*rounded_box_mask), col);\n    \n    //float screen = smoothstep(0.21, 0.2, abs(uv.y - 0.7))*smoothstep(0.21, 0.2, abs(uv.x - 0.5));\n    \n    //col += vec3(screen)*pal(0.5 + 0.15*iTime, vec3(0.7,0.2,0.5),vec3(0.7,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.1,0.67) );\n    \n    \n// 7. Finally, we want to be able to add interactivity to our slider. We can simply rewrite number 6 by integrating the iMouse uniform.\n// as well as commenting out \n\n    vec2 normalized_mouse = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    \n    float slider = 1.0 - step(0.02,abs(normalized_mouse.x - normalized_uv.x));\n    \n    float screen = smoothstep(0.21, 0.2, abs(uv.y - 0.7))*smoothstep(0.21, 0.2, abs(uv.x - 0.5));\n    \n    if (abs(normalized_mouse.x) < 1.26){ \n    \n        col = max(vec3(slider*rounded_box_mask), col);\n        \n        col += vec3(screen)*pal(iMouse.x/iResolution.x + moving_speed*iTime, vec3(0.7,0.2,0.5),vec3(0.7,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.1,0.67) );\n        }\n        \n    else {\n        \n        col += vec3(screen);\n        }\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}