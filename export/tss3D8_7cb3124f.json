{"ver":"0.1","info":{"id":"tss3D8","date":"1546101910","viewed":143,"name":"Alien World","username":"slimyfrog","description":"Weirdo planet with photo-reactive rocks and hacky water","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["terrain","displacement","lighting","water","texturemix","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE   70.0\n#define MIN_DISTANCE    0.0001\n#define WATER_HEIGHT -1.3\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat asteroidDf(vec3 p, out vec3 color1, out vec3 color2)\n{\n    float anim = -iTime*3.0;\n    vec2 uv = vec2( p.x, anim +p.z);\n    vec3 displace = vec3(texture(iChannel0,  uv * .1));\n    vec3 displace2 = vec3(texture(iChannel0, uv * 0.1));\n    vec3 displace3 = vec3(texture(iChannel0, uv* 0.01 ).x);\n    \n    \n    color1 = vec3(0,0,1) * texture(iChannel1, 0.5 + uv * 0.1).xyz * 2.0 - 0.3;\n    color2 = texture(iChannel2, 0.5 + uv * 0.1 ).xyz;\n    displace = displace * 0.3 + displace2 * 0.2 + displace3 * 2.0;\n    \n    float w = p.y * p.y;\n    if (p.y  < WATER_HEIGHT){\n        color2 = mix(color2, vec3(0.3,0.7,0.0), 0.5);\n        displace += p.y*0.2;\n    }\n    float dist =  p.y;    \n    dist += length(displace);\n    return dist;\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p, out vec3 color1, out vec3 color2)\n{\n    float dist = asteroidDf(p, color1, color2);\n    return dist;\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.01;\n    \n    vec3 normal;\n    vec3 f,u;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z), f,u) - sceneDf(vec3(p.x - e, p.y, p.z), f,u);\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z), f,u) - sceneDf(vec3(p.x, p.y - e, p.z), f,u);\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e), f,u) - sceneDf(vec3(p.x, p.y, p.z - e), f,u);\n    \n    return normalize(normal);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor1, vec3 baseColor2, vec3 eyePos, vec3 surfacePoint)\n{\n    vec3 normal = calcNormal(surfacePoint);\n    vec3 toLight = normalize(eyePos + vec3(0, -1.0, -9.0) - surfacePoint);\n    float pointDot = max(dot(toLight, normal), 0.0);\n    float colMix = max(pointDot * 2.0 - 1.0, 0.0);\n    vec3 color = baseColor2 + baseColor1 * colMix;\n    return pointDot * color * 2.0;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir)\n{\n    vec3 color = vec3(0);\n    vec3 currentPoint = eyePos;\n    while(length(currentPoint) < MAX_DISTANCE)\n    {\n        vec3 sceneCol1, sceneCol2;\n        float dist = sceneDf(currentPoint, sceneCol1, sceneCol2);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(sceneCol1, sceneCol2, eyePos, currentPoint);\n            float absz = -currentPoint.z;\n            color *= 1.0-vec3(max(absz - 40.0, 0.0)/10.0);\n            break;\n        }\n        currentPoint += (dist * dir);\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera\t\n\tvec3 eye = vec3(0.0, 3.0, 9.0 );\n    vec3 lookat = vec3( sin(iTime * 0.3) * 3.0, 0.0, 0.0 );\n    \n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 3.5*forward );\n       \n    vec3 color = marchRay(eye, dir);\n    \n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}