{"ver":"0.1","info":{"id":"4ccBDX","date":"1733524207","viewed":60,"name":"Inercia shader royale jam shader","username":"Exca","description":"Shader made during Inercia shader jam.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["jam","inercia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// shared values\nvec2 ouv = vec2(0.0);\nfloat time = 0.0;\nvec3 color1 = vec3(1.0, 0.0, 0.0);\nvec3 color2 = vec3(0.0, 1.0, 0.0);\nvec3 color3 = vec3(0.0, 0.0, 1.0);\nvec3 light1 = vec3(1.0, 0.6, 0.0);\nvec3 light2 = vec3(0.5, 0.5, 0.9);\nvec3 light3 = vec3(0.2, 0.9, 0.4);\nvec3 glow = vec3(0.0);\nfloat fft = 0.0;\nfloat ffts = 0.0;\nfloat ffts2 = 0.0;\nfloat ffti = 0.0;\nfloat beat = 0.0;\nfloat beatstep = 0.0;\nfloat bar = 0.0;\nfloat barstep = 0.0;\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  return rotx*roty*rotz * p;\n}\nvec3 getcam(vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target-cam);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  return normalize(forward*fov + uv.x * right + uv.y*up);\n}\nfloat sphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\nfloat frame( vec3 p, vec3 b, float e )\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat ground(vec3 p, float h)\n{\n  return p.y-h;\n}\n\nvec3 uunion( vec3 a, vec3 b)\n{\n  return a.x < b.x ? a :b;\n}\n\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod(p + q*0.5, q)-q*0.5;\n}\n\n\nvec3 map(vec3 p, float isShadow)\n{\n  vec3 ps1 = rotate(p-vec3(0.0, 1.7,0.0), ffti, ffti*0.63, ffti*1.3);\n  ps1 = repeat(ps1, vec3(8.0, 8.0, 8.0));\n  float s1 = frame(ps1,vec3(0.5)*(1.0+smoothstep(0.2, 0.5, ffts)), 0.25-0.2*smoothstep(0.1,0.9,ffts)-0.1*smoothstep(0.1,0.9,ffts2));\n  if(mod(bar, 8.0) < 4.0) s1 = torus(ps1, vec2(1.0,0.2 + 0.3*smoothstep(0.1,0.6,ffts)));\n  vec3 S1 = vec3( s1, 1.0, 0.0);\n  \n  \n  float g1 = ground(p, 0.0);\n  vec3 G1 = vec3( g1, 1.0, 1.0);\n  \n  float l1 = sphere(p - light1, 0.05);\n  float l2 = sphere(p - light2, 0.05);\n  float l3 = sphere(p - light3, 0.05);\n  \n  vec3 L = vec3(99.0,99.0, 99.0);\n  if(isShadow < 0.5)\n  {\n    vec3 L1 = vec3( l1, 12.0, 0.0);\n    vec3 L2 = vec3( l2, 12.0, 0.5);\n    vec3 L3 = vec3( l3, 12.0, 1.0);\n    L = uunion(L1,L2);\n    L = uunion(L, L3);\n    glow += smoothstep(0.2, 0.0, L1.x) * color1;\n    glow += smoothstep(0.2, 0.0, L2.x) * color2;\n    glow += smoothstep(0.2, 0.0, L3.x) * color3;\n  }\n    \n  return uunion(L, uunion(G1,S1));\n}\n\nvec3 normal( vec3 p)\n{\n  vec3 c = map(p, 0.0);\n  vec2 e = vec2(0.001, 0.0);\n  return normalize( vec3( \n    map(p+e.xyy, 0.0).x,\n    map(p+e.yxy, 0.0).x,\n    map(p+e.yyx, 0.0).x\n  )-c.x);\n}\n\nfloat diffuse( vec3 p, vec3 n, vec3 l)\n{\n  return max(0.0, dot(n,normalize(l-p)));\n}\n\nvec3 march(vec3 cam, vec3 rd, out vec3 p, out float travel, float isShadow)\n{\n  float minimum = 99.0;\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd*travel;\n    vec3 r = map(p, isShadow);\n    minimum = min(r.x, minimum);\n    \n    travel += r.x;\n    if(r.x < 0.001){\n      \n      return r;\n    }\n    if(travel > 100.0){\n      travel = 100.0;\n      return vec3(minimum, 0.0, 0.0);\n    }\n    \n  }\n  return vec3( minimum, 0.0, 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime;\n\tvec2 uv = fragCoord/iResolution.xy;\n\n  ouv = uv;\n  \n  ffti = time; // just forward instead of real ffti\n  ffts = texture(iChannel1, vec2(0.15,0.5)).r*1.0;\n  ffts2 = texture(iChannel1, vec2(0.05, 0.5)).r*1.1;\n  fft = ffts;\n  \n  beat = floor(time * 130.0 / 60.0);\n  beatstep = fract( time * 130.0 / 60.0*1.0);\n  bar = floor(beat/4.0);\n  barstep = fract(beat/4.0);\n  \n  \n  vec3 inercia = texture(iChannel2, vec2(uv.x, 1.0-uv.y)).rgb;\n  \n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 c = vec3(0.0);\n  \n  vec3 cam = vec3( sin( time*0.2 ) * 4.0, 4.0, cos( time*0.21 ) * 3.0);\n  vec3 target = vec3( 0.0, 1.6, 0.0);\n  float fov = 1.36;\n  \n  light1 = vec3(cos(time)*1., 2.0+sin(time*1.1), sin(time)*1.0);\n  light2 = vec3(cos(time*0.5)*3., 1.5+sin(time*0.6), sin(time*0.89)*3.0);\n  light3 = vec3(cos(time*0.8)*3., 1.5+sin(time*0.3), sin(time*0.23)*3.0);\n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  vec3 marchp = cam;\n  float marcht = 0.0;\n  vec3 res = march( cam, rd, marchp, marcht, 0.0);\n  \n  if(res.y < 0.5)\n  {\n    // bg\n  }\n  else if(res.y < 1.5)\n  {\n    // obj\n    vec3 n = normal(marchp);\n    \n    float mat = 1.0;\n    if(res.z > 0.5)\n    {\n      float idx = mod( floor(marchp.x/0.5)+0.5, 2.0);\n      float idy = mod( floor(marchp.z/0.5)-0.5, 2.0);\n      mat = max(1.0,2.0-idx * idy);\n    }\n    \n    // shadows\n    vec3 l1marchp = marchp;\n    float l1marcht = marcht;\n    vec3 l1march = march( marchp + n*0.1, normalize(light1-marchp+n*0.1), l1marchp, l1marcht, 1.0);\n    \n    vec3 l2marchp = marchp;\n    float l2marcht = marcht;\n    vec3 l2march = march( marchp + n*0.1, normalize(light2-marchp+n*0.1), l2marchp, l2marcht, 1.0);\n    \n    vec3 l3marchp = marchp;\n    float l3marcht = marcht;\n    vec3 l3march = march( marchp + n*0.1, normalize(light3-marchp+n*0.1), l3marchp, l3marcht, 1.0);\n    \n    \n    float shadow1 = smoothstep( 0.05, 0.15, l1march.x);\n    float shadow2 = smoothstep( 0.05, 0.15, l2march.x);\n    float shadow3 = smoothstep( 0.05, 0.15, l3march.x);\n    \n    c = mat* color1*diffuse( marchp, n, light1)/1.0 * shadow1;\n    c +=mat* color2*diffuse( marchp, n, light2)/1.0 * shadow2;\n    c +=mat* color3*diffuse( marchp, n, light3)/1.0 * shadow3;\n    \n    \n  }\n  else \n  {\n    c = vec3(1.0);\n    if(res.z < 0.33) c = color1;\n    else if(res.z < 0.66) c = color2;\n    else if(res.z < 1.33) c = color3;\n    \n  }\n  \n\tvec2 m;\n\tm.x = atan(uv.x / uv.y) / 3.14;\n\tm.y = 1. / length(uv) * .2;\n\tfloat d = m.y;\n\n\t\n  c+= glow;\n\t\n  ouv -= 0.5;\n  ouv *= 1.05-ffts*0.5;\n  ouv += 0.5;\n  vec3 prev = texture( iChannel0, ouv).rgb*2.0;\n  prev *=0.5;\n  c = mix( \n    c, \n    c +prev*0.5, smoothstep(0.005, 0.1, ffts));\n  \n  float gray = dot(c.rgb, vec3(0.299, 0.587, 0.114));\n  c = mix(c,vec3(gray),0.75);\n  \n  fragColor = vec4(c,1.0)+ 1.0*vec4(inercia*(0.75),1.0);\n \n\n}","name":"Buffer A","description":"","type":"buffer"}]}