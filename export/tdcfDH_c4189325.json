{"ver":"0.1","info":{"id":"tdcfDH","date":"1604992720","viewed":89,"name":"Nodevember Day10","username":"antoinefortin","description":"Antoine Nodevember","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["nodevember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\n/* SDF */\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat sdPlane(vec3 pos)\n{\n\treturn pos.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opu(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n\nfloat h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel1, p * 0.055).x ;    \n    float b = (sin(p.x * 2.))  ;\n    \n    b*=  ba * sin( cos( 2.)) * abs(sin(1.) + 1.25);\n    b *= b - abs(sin(iTime));\n    return -b - 1.2;\n}\n\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sapin(vec3 pos)\n{\n\t\n    vec3 q = pos;\n    float d = 0.0;\n\tfloat pine = sdCone(q, vec2(.25, .25), .5);\n    \n    \n\n        \n    return pine;\n   \n}\n\nfloat cloud(vec3 pos)\n{\n\tfloat d = 0.0;\n    vec3 q = pos;\n    \n\t// Define the radius of cloud modulation...\n   \tq.y -= 1.75;\n    \n    q.z = mod(q.z+ 1., 2.) -1.;\n    \n\tq.x = mod(q.x+ 1.5, 3.) -1.5;\n   \n    vec3 cr = vec3(.25, .15, .15);\n\n    cr.x += .01 + abs(sin((q.x * 50. + iTime * 5.))) * 0.05;\n \n    \n    cr.y += abs(cos((q.y + iTime))) * 0.009;\n    \n    d = sdEllipsoid(q, cr);\n    \n    return d;\n}\nfloat trees(vec3 pos)\n{\n\tvec3 q = pos;\n    q.y -= .2;\n    q.z -= .2;\n    q.x += 1.2;\n    float modEn= 1.0;\n\tq.xz = mod(q.xz+ 1., 2.) -1.;\n    q.yz = rotate(q.yz, 1.65);\n    float d = sdHexPrism(q, vec2(.015, .215));\n    \n    return d;\n}\n\n\nfloat feuilles(vec3 pos)\n{\n    float originLeaves = .2;\n\tpos.y -= originLeaves;\n    vec3 q = pos;\n    q.y -= .2;\n    q.z -= .2;\n    q.x += 1.2;\n\tq.xz = mod(q.xz+ 1., 2.) -1.;\n    q.yz = rotate(q.yz, 1.65 +(sin(iTime) * .5));\n\n    float d = sdHexPrism(q, vec2(.15, .0215));\n    \n    q = pos; // snap back to origin\n\tq.y -= .25;\n    q.z -= .2;\n    q.x += 1.2;\n\tq.xz = mod(q.xz+ 1., 2.) -1.;\n\tq.yz = rotate(q.yz, 1.+sin(iTime));\n    float d1 = sdHexPrism(q, vec2(.12, .0245));\n    \n        \n    q = pos; // snap back to origin\n\tq.y -= .30;\n    q.z -= .2;\n    q.x += 1.2;\n    q.xz = mod(q.xz+ 1., 2.) -1.;\n\tq.xy = rotate(q.xy, 1.65 + cos(iTime));\n    float d2 = sdHexPrism(q, vec2(.10, .0245));\n    \n            \n    q = pos; // snap back to origin\n\tq.y -= .40;\n    q.z -= .2;\n    q.x += 1.2;\n\tq.yz = rotate(q.yz, 1.65);\n    q.xz = mod(q.xz+ 1., 2.) -1.;\n    float d3 = sdHexPrism(q, vec2(.075, .025));\n    \n    \n\tq = pos; // snap back to origin\n\tq.y -= .35;\n    q.z -= .2;\n    q.x += 1.2;\n    q.xz = mod(q.xz+ 1., 2.) -1.;\n\tq.xz = rotate(q.xz,  cos(iTime * 1.5));\n    float d4 = sdHexPrism(q, vec2(.085, .02));\n    \n\n    \n    return min(d,min(d1,min(d2,min(d3,d4))));\n}\n\n\nvec2 map(vec3 pos)\n{\n    \n    \n\tfloat sphere = sdSphere(pos + vec3(0.0, -.15, 0.0), .15);\n    \n    \n    \n    float theFloor = sdPlane(pos + vec3(0.0, -1.2, 0.0)) - (h(pos.xz));\n    \n\tfloat waterPlane = sdPlane(pos+ vec3(0.0, .08, 0.0));\n    \n\t\n    float trunk = trees(pos);\n    float feuille = feuilles(pos);\n    \n    float sapin = sapin(pos);\n    float cloudRepeat = cloud(pos);\n\tvec2 res =     vec2(sphere,       1.0 /*Object ID*/);\n    res = opu(res, vec2(theFloor,     2.0 /*Object ID*/));\n    res = opu(res, vec2(trunk,     3.0 /*Object ID*/));\n    res = opu(res, vec2(feuille,     4.0 /*Object ID*/));\n    \n    res = opu(res, vec2(cloudRepeat,    5./*Object ID*/));\n    \n    res = opu(res, vec2(waterPlane,    6./*Object ID*/));\n    \n    \n    \n \n     \n    \n    \n    return res;\n}\n\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n\n    float t = 0.0;\n    float id = -20.;\n\tfloat farClippingPlane = 7.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        \n    \tvec3 pos = ro + t * rd;\n        float h = map(pos).x;\n        id = map(pos).y;\n        \n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        if(t > farClippingPlane) break;\n        \n    }\n    \n    if(t > farClippingPlane) t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x\n    \t\t\t\t));\n}\n\nvoid resetToZero(inout vec3 r)\n{\n\tr = vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\tvec3 ro = vec3(0., .45 ,-1.5 + iTime);\n\tvec3 rd = normalize(vec3(uv.x, uv.y - .2,1.)); \n\n\tvec3 col = vec3(.22);\n\t\n\t\n\tfloat hitDistance = castRay(ro, rd).x;\n    float objectId = castRay(ro, rd).y;\n    \n    vec3 unfinishedSky;\n    \n    // No hit color\n    if(hitDistance < 0.01)\n    {\n        \n        /* Sky properties*/\n        vec3 skyColor = vec3(.4, 0.75, 1.0);\n        float skyMovement = .5;\n\t\tcol = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n        \n        \n        \n    }\n    \n    \n    if(hitDistance > 0.)\n    {\n       \tvec3 debugColor = vec3(1.);\n        vec3 pos = ro + hitDistance * rd;\n        vec3 normalWS = calcNormal(pos);\n\n        /* Global Lighting section */\n        \n        // Sky\n        vec3 skyColor = vec3(.4, 0.75, 1.0);\n\t\tfloat skyMovement = .5;\n        vec3 skyColFactor = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n\t\t\n        // Basic lighting\n        vec3 sunPos = normalize(vec3(.5, .4, -.52));\n \t\tfloat fSunDiffuse = clamp(dot(normalWS, sunPos), 0., 1.);\n        float sunShadow = smoothstep(castRay(pos + normalWS * 0.001, sunPos).x, 0., 1.);\n\t\tfloat skyDif = dot(normalWS,vec3(0.,1.0,0.));\n        vec3 basicColor = vec3(.5, 0.75, 0.8) * (fSunDiffuse + (skyDif * .5)) * sunShadow;\n        col = basicColor * (skyColFactor * .75);\n\n        \n        \n        //col = skyColFactor;\n        /*End of Global Lighting section */\n        \n        \n        bool materialSystem = true;\n        \n        if(materialSystem)\n        {\n            float blendingFactor = .5;\n\t\t\t// Sphere\n        \tif(objectId == 1.0) \n        \t{\n        \t\tvec3 sphereMat = vec3(.2, .5, .6);\n                col = col;\n        \t}\n        \n        \t// Floor\n        \tif(objectId == 2.0)\n       \t\t{\n                /* Floor settings*/\n               \tfloat gridXF = 25.0f;\n\t\t\t\tfloat gridYF = 25.0f;\n                float changeFactor = iTime * .5;\n        \t\tvec3 floorColor = vec3(.25, .45, .3);\n\t\t\t\t// displace the floor\n                pos.x += sin(iTime * .2);\n                pos.z += cos(iTime * .2);\n                float f = .5 + abs(sin( sin(changeFactor) * (sin(pos.x * gridXF) * cos(pos.z * gridYF))));\n               \tvec3 pattern = vec3(f / 5.);\n                col = pattern * col + vec3(0., .22, 0.);\n                \n                {\n                 //resetToZero(col);\n                }\n        \t}\n            // trunk\n            if(objectId == 3.0)\n            {\n                vec3 trunk = vec3(255) / vec3(210,105,30);\n            \tcol = vec3(.8, .5, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            // leaves\n            if(objectId == 4.)\n            {\n\t\t\t\t\n            \tcol = vec3(.4, .95, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            /*Sapin*/\n            \n            if(objectId == 5.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                float shadingAmoutOnClouds = dot(normalWS, sunPos);\n                vec3 bloop = texture(iChannel0, uv * 2.).xxx;\n            \tcol = vec3(shadingAmoutOnClouds) * bloop * 5.;\n            }\n            \n          // water\n\t\t\tif(objectId == 6.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                \n\t\t\t\tvec3 waterC = vec3(dot(normalWS,sunPos + pos * .5));\n\t\t\t\tfloat hitDistance = castRay(ro, rd).x;\n    \t\t\tfloat objectId = castRay(ro, rd).y;\n                \n                \n                vec3 wcF =  (sin(uv.y * 120.) * uv.y * sin(uv.x * 120.)) * waterC * vec3(cos(hitDistance * pos.x), sin(objectId * 120.), cos(sin(waterC * hitDistance)));\n\t\t\t\tcol = waterC.xxx * (abs(wcF.xxx) + .5)  * vec3(.1, .15, .75);\n                col += vec3(0., 0., .4);\n                \n            }\n            \n            \n            \n            \n        }\n\n        \n        col = col;\n       \n        /*\n       \tvec3 sundir = normalize(vec3(0.2, 0.4, 0.2));\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir).x,0., 1.);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n\t\tcastRay(ro, rd).x */    \n\t}\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}