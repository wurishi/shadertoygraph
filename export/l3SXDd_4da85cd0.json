{"ver":"0.1","info":{"id":"l3SXDd","date":"1711310869","viewed":171,"name":"The Moon Through a Telescope","username":"otkazano","description":"\"The Moon Through a Telescope\" is my less-than-skillful attempt at recreating a visually naturalistic demonstration of the Moon as seen from Earth through optical instruments.\nUse the mouse to change the terminator position and focal length (zoom)\n","likes":21,"published":1,"flags":96,"usePreview":1,"tags":["music","blur","texture","moon","night","bump","gamma","correction","hdr","ambient","abberation","relaxation","jitter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsGGRz","filepath":"https://soundcloud.com/sergej-pavlov-58281009/aud-20240325-wa0004-mp3/s-r698GzKCEh2?ref=clipboard&p=a&c=1&si=28516b07dcec4ccc914c86993294a47f&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/sergej-pavlov-58281009/aud-20240325-wa0004-mp3/s-r698GzKCEh2?ref=clipboard&p=a&c=1&si=28516b07dcec4ccc914c86993294a47f&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //c = texture(iChannel0, uv).xyz;\n    \n    //Abberation\n    //int s = SAMPLES;\n    float s = float(SAMPLES);\n    vec3 txt;\n    for(float i=1.0; i<=s; i++){\n        txt = vec3(\n            texture(iChannel0, (uv-0.5)*mix(ABB0.r,ABB1.r,i/s)+0.5).r,\n            texture(iChannel0, (uv-0.5)*mix(ABB0.g,ABB1.g,i/s)+0.5).g,\n            texture(iChannel0, (uv-0.5)*mix(ABB0.b,ABB1.b,i/s)+0.5).b\n        );\n        c += txt;\n    }\n    c /= s;\n    \n    \n    // Correction\n    c = 1.0-exp(-c*HDR);\n    c = pow(c,GAMMA);\n    \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592654\n\n//interface params\n#define axisWeight 0.3/iResolution.x\n\n\n\n\n//uv screen params\n#define du 0.5\n#define dv 0.5\n#define iR vec2(1.0/iResolution.x, 1.0/iResolution.y)\n\n\n\nstruct camera {\n    vec3 position;\n    float zoom;\n    float angleA;\n    float angleB;\n};\n\nstruct directLight {\n    vec3 color;\n    vec3 direction;\n    float power;\n};\n\ncamera cam;\n\n\n//------MATRIX-------------------------------------------------\nmat2 rotMatx2( float a )\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n//------S C R E E N    S P A C E-------------------------------\nvec2 translateCoo( vec2 uv ){\n    vec2 rv = uv/iResolution.xy;\n    rv -= 0.5; \n    rv.y *= iResolution.y/iResolution.x;\n    return rv;\n}\nvec3 uvToSpace( in vec2 uv )\n{\n    vec2 z = vec2(cam.zoom,uv.y);\n    z *= rotMatx2(cam.angleB*miceFactor.y);\n    vec2 xz = vec2(uv.x,z.x);\n    xz *= rotMatx2(cam.angleA*miceFactor.x);\n    return normalize(vec3(xz.x,z.y,xz.y));\n}\n\n//------TRANSFORM----------------------------------------------\nvec3 rotate( in vec3 p, float a, float b )\n{\n    vec3 rp = p;\n    \n    rp.xy *= rotMatx2(b);\n    rp.yz *= rotMatx2(a);\n    return rp;\n}\n//------RANDOM-------------------------------------------------\n\nfloat hash11( float p, float seed ){\n    return fract(sin(p*8573.46673+seed)*12547.4654-seed);\n}\nfloat hash12(vec2 p){\n    float h = dot(sin(p*473.4577987),vec2(241.544324,622.2845231));\n    h = fract(sin(h*843.4743)*547.4654);\n    return h;\n}\nfloat hash13( vec3 p, float seed ){\n    float h = dot(sin(p*73.4577987),vec3(82.544324-seed,622.2845231+seed,4646.1234+seed))+seed;\n    h = fract(sin(h*873.4743+seed)*547.4654-seed);\n    return h;\n}\nvec3 randVec3( vec3 p, float seed ){\n    return vec3(hash13(p, seed+154.4164), hash13(p, seed-4654.454), hash13(p, seed*14.453))-0.5;\n}\n\n//------KEYBOARD-----------------------------------------------\nbool keyDown( int ascii ){\n    return (texture(iChannel3,vec2((0.5+float(ascii))/256.,0.25)).x > 0.);\n}\nbool keyPressed( int ascii ){\n\treturn (texture(iChannel3,vec2((0.5+float(ascii))/256.,0.75)).x > 0.);\n}\n//------MAPS---------------------------------------------------\n\nfloat volume( vec3 p, float seed ){\n\n    vec3 i, f;\n    i = floor(p);\n    //f = p-i;\n    f = fract(p);\n    return\n        mix(\n            mix(\n                mix(hash13(i+vec3(0.0,0.0,0.0), seed), hash13(i+vec3(1.0,0.0,0.0), seed), f.x),\n                mix(hash13(i+vec3(0.0,1.0,0.0), seed), hash13(i+vec3(1.0,1.0,0.0), seed),f.x),\n                f.y\n            ),\n            mix(\n                mix(hash13(i+vec3(0.0,0.0,1.0), seed), hash13(i+vec3(1.0,0.0,1.0), seed), f.x),\n                mix(hash13(i+vec3(0.0,1.0,1.0), seed), hash13(i+vec3(1.0,1.0,1.0), seed),f.x),\n                f.y\n            ),\n            f.z\n        );\n}\nfloat sphere(vec3 p, float seed, float entropyPos, float entropyR, float rad, float sm, float bl){\n\n    vec3 uvLoc = fract(p)-0.5, offset, bias;\n    float c = 0.0, r = 0.0, l = 0.0;\n    for(float dz=-1.0; dz<=1.0; dz++){\n        for(float dy=-1.0; dy<=1.0; dy++){\n            for(float dx=-1.0; dx<=1.0; dx++){\n                offset = vec3(\n                    hash13(floor(p)+vec3(dx,dy,dz), seed*2.0+0.15),\n                    hash13(floor(p)+vec3(dx,dy,dz), seed+5.0+0.17),\n                    hash13(floor(p)+vec3(dx,dy,dz), seed+7.0+0.13)\n                )-0.5;\n                r = (hash13(floor(p)+vec3(dx,dy,dz), seed+13.17)-0.5)*entropyR + rad;\n                l = length(vec3(dx,dy,dz)+offset*entropyPos-uvLoc);\n                c = max(c,smoothstep(r+sm, r-sm, l));\n            }\n        }\n    }\n    return c;\n}\n//------MICE---------------------------------------------------\nvec2 getMice()\n{\n    if(iMouse.xy==vec2(0.0)) return vec2(-0.90,0.0);\n    return vec2(iMouse.x/iResolution.x-.5,iMouse.y/iResolution.y-.5);\n}\n//------CURVES-------------------------------------------------\nfloat mix0(float a, float b, float k){ // linear\n    return mix(a, b, k);\n}\n\nfloat mix1(float a, float b, float k){ // cubic\n    float f = k*k*(3.0-2.0*k);\n    return mix(a, b, f);\n}\nfloat mix2(float a, float b, float k){ // sine\n    float f = 0.5-cos(k*PI)*0.5;\n    return mix(a, b, f);\n}\nfloat mix3(float a, float b, float k){ // parabolic\n    float f;\n    if(k==0.5){\n        f = 0.5;\n    }else{\n        if(k<0.5){\n            f = k*k*2.0;\n        }else{\n            k--;\n            f = 1.0-2.0*k*k;\n        }\n    }\n    return mix(a, b, f);\n}\n//------TEXTURES-----------------------------------------------\nfloat craterCanva( float t, float h, float s )\n{\n    float a=s, b=5.0, k0, k1, k2;//s â€” 0...10\n    k0 = max((t-1.0)*a+1.0,0.0);\n    k1 = exp(-(b*(k0-0.5))*(b*(k0-0.5)))*h;\n    k2 = min(k0,0.5);\n    return (k2*k1 + k2*k2)*4.0-1.0;\n}\nfloat moon( vec3 p, bool bump )\n{\n    float b=0.0, s=0.0, k=0.0, K, A=1.0, a=1.0, f=0.1, w, g, cn;\n    if(!bump){\n        for(float i=0.0; i<7.0; i++){\n            s += sphere(p*f, 3.798*(i+9.15), 0.8, 0.2, 0.3, 0.4, 0.3)*a;\n            A+=a;\n            a*=0.555;\n            f*=1.9;\n        }\n        s /= A;\n        s = 1.0-smoothstep(0.0, 0.3, s)*0.3;\n        \n        A=0.0, a=1.0, f=1.0, k=0.0;\n        for(float i=0.0; i<7.0; i++){\n            w = 1.0-sphere(p*f, 2.548*(i+4.137), 0.99, 0.9, 0.03, 0.1, 0.13);\n            g += 1.0-w;\n            w = craterCanva(w, pow(volume(p*30.0, 45.045),1.5)*0.5, volume(p*40.0, 78.045)*0.5+0.9);\n            k += w*a;\n            A+=a;\n            a*=0.85;\n            f*=1.33;\n        }\n        g = 1.0-smoothstep(0.0, 0.3, g)*0.02;\n        return s*g;\n    }else{\n        A=0.0, a=1.0, f=1.0, k=0.0;\n        for(float i=0.0; i<7.0; i++){\n            w = 1.0-sphere(p*f, 2.548*(i+4.137), 0.99, 0.9, 0.03, 0.1, 0.13);\n            g += 1.0-w;\n            w = craterCanva(w, pow(volume(p*30.0, 45.045),1.5)*0.5, volume(p*40.0, 78.045)*0.5+0.9);\n            k += w*a;\n            A+=a;\n            a*=0.85;\n            f*=1.33;\n        }\n        g = 1.0-smoothstep(0.0, 0.3, g)*0.02;\n        k /= A;\n        k *= 0.075;\n        A=0.0, a=0.15, f=5.0, b=0.0;\n        for(float i=0.0; i<5.0; i++){\n            b += mix3(0.0, 1.0, volume(p*f, 3.12*(i+2.0)))*a;\n            A+=a;\n            a*=0.65;\n            f*=1.95;\n        }\n        b /= A;\n        b = pow(b*0.95+0.05,0.1)*0.27;\n        return -k+b;\n    }\n}\n\n/*\nvec4 moon( vec3 p )\n{\n    float b=0.0, s=0.0, k=0.0, K, A=1.0, a=1.0, f=0.1, w, g, cn;\n    \n    for(float i=0.0; i<7.0; i++){\n        s += sphere(p*f, 3.798*(i+9.15), 0.8, 0.2, 0.3, 0.4, 0.3)*a;\n        A+=a;\n        a*=0.555;\n        f*=1.9;\n    }\n    s /= A;\n    s = 1.0-smoothstep(0.0, 0.3, s)*0.3;\n    \n    A=0.0, a=1.0, f=1.0, k=0.0;\n    for(float i=0.0; i<7.0; i++){\n        w = 1.0-sphere(p*f, 2.548*(i+4.137), 0.99, 0.9, 0.03, 0.1, 0.13);\n        g += 1.0-w;\n        w = craterCanva(w, pow(volume(p*30.0, 45.045),1.5)*0.5, volume(p*40.0, 78.045)*0.5+0.9);\n        k += w*a;\n        A+=a;\n        a*=0.85;\n        f*=1.33;\n    }\n    g = 1.0-smoothstep(0.0, 0.3, g)*0.02;\n    k /= A;\n    k *= 0.075;\n    A=0.0, a=0.15, f=5.0, b=0.0;\n    for(float i=0.0; i<5.0; i++){\n        b += mix3(0.0, 1.0, volume(p*f, 3.12*(i+2.0)))*a;\n        A+=a;\n        a*=0.65;\n        f*=1.95;\n    }\n    b /= A;\n    b = pow(b*0.95+0.05,0.1)*0.27;\n    return vec4(s*g,s*g,s*g,-k+b);\n}\n*/\n/*\nvec4 moonOld( vec3 p )\n{\n    float b=0.0, s=0.0, k=0.0, K, A=1.0, a=1.0, f=0.1;\n    \n    for(float i=0.0; i<7.0; i++){\n        s += sphere(p*f, 3.798*(i+9.15), 0.8, 0.2, 0.3, 0.4, 0.3)*a;\n        A+=a;\n        a*=0.555;\n        f*=1.9;\n    }\n    s /= A;\n    s = 1.0-smoothstep(0.0, 0.3, s)*0.3;\n    \n    A=0.0, a=2.0, f=1.0;\n    for(float i=0.0; i<7.0; i++){\n        k += sphere(p*f, 2.548*(i+4.137), 0.99, 0.9, 0.03, 0.05, 0.13)*a;\n        A+=a;\n        a*=0.85;\n        f*=1.33;\n    }\n    k /= A;\n    \n    A=0.0, a=0.15, f=5.0, b=0.0;\n    for(float i=0.0; i<5.0; i++){\n        b += mix3(0.0, 1.0, volume(p*f, 3.12*(i+2.0)))*a;\n        A+=a;\n        a*=0.65;\n        f*=1.95;\n    }\n    b /= A;\n    b = pow(b*0.95+0.05,0.2)*0.15;\n    k = 1.0-smoothstep(0.0, 0.3, k)*0.03;\n    return vec4(s*k,s*k,s*k,1.0-k+b);\n}\n*/\n//------SCENE--------------------------------------------------\nvec4 scene( in vec3 p, in float dist, in int option )\n{\n    float a = 1.0;\n    float d = MarchInfinity, D = MarchInfinity, cut = MarchInfinity, M = MarchThreshold*2.0;\n    d = length(p)-10.0;\n    if(option == 1){\n        d+=moon(p, true)*0.03*cz;\n    }\n    return vec4(d,0.0,0.0,0.0);\n}\n\n//------PROCEDURAL---------------------------------------------\nvec3 normal( vec3 p ){\n    float e = MarchNormalPrecision;\n    int side;\n    float track, depth;\n    float P = scene(p, 0.0, 1).x;\n    return normalize(\n        vec3(\n            scene(p+vec3(e,0.0,0.0), 0.0, 1).x-P,\n            scene(p+vec3(0.0,e,0.0), 0.0, 1).x-P,\n            scene(p+vec3(0.0,0.0,e), 0.0, 1).x-P\n        )\n    );\n    \n}\nvec3 marching( in vec3 pos, in vec3 dir, out float d, out bool r, out float steps )\n{\n    float track, depth;\n    float mt = MarchThreshold;\n    float dd = 0.0;\n    r = true;\n    vec3 p=pos;\n    d = scene(p, dd, 0).x;\n    steps = 0.0;\n\n    for(int i=1; i<=MarchSteps; i++){\n        if(d <= mt){\n            r = true;\n            return p;\n        }\n        d = scene(p, dd, 0).x;\n        p += dir*d;\n        dd += d;\n        steps++;\n        if(dd>=MarchMaxDistance){\n            r = false;\n            return p;\n        }\n    }\n    return p;\n}\nfloat shadow( in vec3 pos, in vec3 normal, in vec3 dir) //Shadow and surface lightness\n{\n    if(dot(dir, normal)>0.0) return 0.0;\n    float mt = MarchThreshold;\n    vec3 p=pos+normal*mt*3.0;\n    float d, dd=0.0;\n    d = scene(p, 0.0, -1).x;\n    for(int i=1; i<=MarchSteps; i++){\n        if(abs(d) <= mt){\n            return 0.0;\n        }\n        d = scene(p, dd, -1).x;\n        dd += d;\n        p += -dir*d;\n        if(dd>=MarchMaxDistance){\n            return 1.0;\n        }\n    }\n    return 1.0;\n}\nfloat lightness ( in vec3 normal, in vec3 dir, float coverage )\n{\n    vec3 n = normal;\n    return max(0.0,-dot(dir, n) * (1.0-0.5*coverage) + 0.5*coverage);\n}\n\n\nvec3 getFarColor( vec3 lookAtvector )\n{   \n    float p;\n    vec3 rv;\n    vec3 upCol;\n    vec3 dnCol;\n    \n    upCol = vec3(0.1,0.1,0.1)*3.0;\n    dnCol = vec3(0.1,0.1,0.1);\n    \n    rv += upCol*pow(max(dot(vec3(0.0,1.0,0.0),lookAtvector),0.0),2.0);\n    rv += dnCol*pow(max(dot(vec3(0.0,-1.0,0.0),lookAtvector),0.0),2.0);\n    rv += (hash13(lookAtvector, 0.465465756)-0.5)*0.01;\n    \n    rv += 0.3;\n    \n    return max(rv,0.0);\n}\nvec3 getStarField( vec3 lookAtvector )\n{   \n    float t = sphere(lookAtvector*50.0, 324.6343, 0.99, 0.3, 0.02, 0.5, 0.5);\n    t = smoothstep(0.67, 0.73, t);\n    return vec3(pow(t,3.4));\n}\n\nvec3 frameSubProcessing( vec2 uv ){\n    \n\n    vec2 mice = getMice();\n    \n    if(iMouse.z>0.0){\n        mice = getMice();\n    }\n    \n    //Eyler angles\n    //cam.angleA = -mice.x;\n    //cam.angleB = -mice.y;\n\n    \n    cz = CameraZoom+max(mice.y,0.0)*7.0;\n    cam.zoom = cz;\n    uv += pow((texture(iChannel0,vec2(iTime*0.5,iTime*0.1))-0.5).xy,vec2(3.0))*cam.zoom*0.008;\n\n    \n    //cam.position.z = iTime*0.0;\n    cam.position = -uvToSpace( vec2(0.0) )*50.0;\n    vec3 v = uvToSpace(uv);\n    vec3 tx1 = texture(iChannel0,vec2(uv.x,uv.y-iTime*0.05*cam.zoom)/cam.zoom*3.786).xyz;\n    vec3 tx2 = texture(iChannel0,vec2(uv.x+0.47,uv.y-iTime*0.08*cam.zoom)/cam.zoom*1.48).xyz;\n\n    \n    v = normalize(\n        v\n        +vec3(tx1-0.5)*0.0005\n        +vec3(tx2-0.5)*0.0007\n    );\n    \n    directLight l;\n    l.color = vec3(1.0,0.9,0.8);\n    l.direction = normalize(vec3(sin(-mice.x*6.0+3.0),-0.3,cos(mice.x*6.0+3.0)));\n    l.power = SunPower;\n\n    bool reached;\n    float dist, steps, depth;\n\n    vec3 n;\n    vec3 c = vec3(1.0);\n    vec3 txtMet,  txtBump, txtCol;\n    \n    vec3 p = marching(cam.position, v, dist, reached, steps);\n    if(reached){\n        n = normal(p);\n        float t = moon(p, false);\n        c = vec3(t);\n        c *= max(dot(l.direction, n),0.0);\n        c *= l.color * l.power;\n        //c *= shadow(p, n, -l.direction);\n    }else{\n        c = getStarField(vec3(v.xz*rotMatx2(-iTime*0.0015),v.y))*31.0;\n    }\n    float moonPower = SunPower*(-l.direction.z+1.0);\n    c += vec3(0.05,0.09,0.2)*0.17*moonPower;\n    return c;\n}\n\nvec3 frameProcessing( vec2 uv, int subs ){\n    float ss = float(subs);    \n    vec3 c = vec3(0.0);\n    float delta = 1.0/(ss+1.0), pixSize = 1.0/iResolution.x;\n    delta *= pixSize;\n    float dx, dy;\n    dy = 0.0;\n    for(float y=0.0; y<ss; y++){\n        dy += delta;\n        dx = 0.0;\n        for(float x=0.0; x<ss; x++){\n            dx += delta;\n            c += frameSubProcessing(uv+vec2(dx,dy));\n        }\n    }\n    return c/float(ss*ss);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = translateCoo(fragCoord);\n    vec3 c = frameProcessing( uv, subSamplesS );\n    fragColor = vec4(c,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//quality params\n#define subSamplesS 1\n#define SAMPLES 64\n\n//march tracing params\n#define MarchMaxDistance 1e3\n#define MarchSteps 256\n#define MarchThreshold 5e-3\n#define MarchInfinity 1e7\n#define MarchNormalPrecision MarchThreshold*0.5\n\n//camera params\n#define CameraZoom 0.75\n\n//mice params\n#define miceFactor vec2(-9.0, 3.5)\n\n//abberation\n#define ABB0 vec3(0.999,0.998,0.996)\n#define ABB1 vec3(0.995,0.990,0.980)\n\n//correction\n#define GAMMA vec3(2.2)\n#define HDR 0.35\n\n//light\n#define SunPower 13.0\n\nfloat cz = CameraZoom;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define RADIUS 0.4\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 6.283185307179586476925286766559\n\nfloat hash12(vec2 uv){\n    uv = fract(uv);\n    float a = fract(dot(uv,vec2(321.175675,464.456765)));\n    return fract(dot(vec2(a*45.4554, a*387.178),vec2(a*7865.4554, a*738.178)));\n}\n\nfloat gaussian(float x, float a, float b, float c){\n    return a*exp(-(x-b)*(x-b)/(2.0*c*c));\n}\n\nvec2 fibboXY(float i, float n){\n    float fi = 0.5+sqrt(5.0)*0.5;\n    return vec2(fract(i/fi), i/n);\n}\nvec2 fibboAR(float i, float n){\n    vec2 fsq = fibboXY(i, n);\n    return vec2(fsq.x*PI2, sqrt(fsq.y));\n}\nfloat fallOf(float r, float R){\n    return pow(r/R,0.0);\n}\n\n\nvec2 translateCoo( vec2 uv ){\n    vec2 rv = uv/iResolution.xy;\n    rv -= 0.5; \n    rv.y *= iResolution.y/iResolution.x;\n    return rv;\n}\nvec2 getMice()\n{\n    if(iMouse.xy==vec2(0.0)) return vec2(-0.90,0.1);\n    return vec2(iMouse.x/iResolution.x-.5,iMouse.y/iResolution.y-.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c;\n    vec2 uv = fragCoord/iResolution.xy;\n    cz = CameraZoom+max(getMice().y,0.0)*7.0;\n    \n    float f, R, fal=0.0;\n    R = RADIUS*pow(texture(iChannel1,vec2(iTime*0.05,iTime*0.005)).x,7.0)*0.02*cz;\n    vec2 offs;\n    \n    //Blur\n    int s = SAMPLES;\n    for(int i=1; i<=s; i++){\n         vec2 f = fibboAR(float(i), float(s));\n         offs = vec2(f.y*sin(f.x)*R,f.y*cos(f.x)*R); //sample offset\n         c += texture(iChannel0, (uv+offs)).rgb*fallOf(f.y, 1.0);\n         fal += fallOf(f.y, 1.0);\n    }\n    c /= fal;\n    \n    /*\n    //Denoise\n    float e = 1.0/iResolution.x;\n    float t=0.0, th = 1.5;\n    for(float y=-e; y<=e*1.5; y+=e){\n        for(float x=-e; x<=e*1.5; x+=e){\n            t = max(t,length(texture(iChannel0, uv).rgb-texture(iChannel0, uv+vec2(x,y)).rgb));\n        }\n    }\n    \n    if(t>=th){\n        c *= 0.0;\n        for(float y=-1.0; y<=1.0; y++){\n            for(float x=-1.0; x<=1.0; x++){\n                //c+= texture(iChannel0, uv+vec2(x,y)*e).rgb*(abs(y)+abs(x)+1.0);\n                c+= texture(iChannel0, uv+vec2(x,y)*e).rgb;\n            }\n        }\n        c *= 0.1111;\n    }\n    */\n    c = mix(c,c/(cz+0.25),0.65);\n\n    fragColor = vec4(c,1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}