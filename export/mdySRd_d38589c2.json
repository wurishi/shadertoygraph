{"ver":"0.1","info":{"id":"mdySRd","date":"1681731223","viewed":54,"name":"Ray Marching and Distortion","username":"yonng","description":"Practice and Learng with Ray Marching with Distortion. \n\nThanks very much for the great tutorials: https://michaelwalczyk.com/blog-ray-marching.html and https://iquilezles.org/articles/distfunctions/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learnraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n\n\n//psudo-noise\nvec2 hash22(vec2 p)\n{\n    float n = sin(dot(p, vec2(41, 289)));\n    \n    return sin(fract(vec2(262144, 32768)*n)*6.28 + iTime);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    p -= ip;\n    vec4 v = vec4(dot(hash22(ip), p),\n        dot(hash22(ip + vec2(1,0)), p-vec2(1,0)),\n        dot(hash22(ip + vec2(0,1)), p-vec2(0,1)),\n        dot(hash22(ip + vec2(1,1)), p-vec2(1,1))\n    );\n    \n    p = p*p*p*(p*(p*6.-15.)+10.);\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n}\n\n\nfloat sdfSphere(vec3 p, vec4 center)\n{\n      return length(p - center.xyz) - center.w;   //w is the radius   \n}\n\n// torus on the xz plane\nfloat sdfTorus(vec3 p, vec3 center, vec2 r)   //r is for the two radiuses\n{\n     p -=center;  //remap the center from the (0,0,0)\n     float x = length(p.xz) - r.x;\n     return length(vec2(x, p.y)) - r.y;    //r.y is \n    \t\n}\n\n\n//build sdf Scenes with comparison of distances\nfloat sdfScene(vec3 p)  // simple way calculate the distance using ray marching\n{\n     vec4 s = vec4(0,3,6,1);   //the last 1 is for radius, the first three are the coordinates of the circle\n     float sphereSdf = sdfSphere(p,s);\n     float torusSdf = sdfTorus(p,vec3(0,0.5,7), vec2(1.58,.2));\n     \n     //float var = sin(5.0*iTime) * sin(3.0*iTime)*cos(4.0*iTime)*0.15;\n     //Combine into a complete scene\n     float d = min(sphereSdf, torusSdf);\n     return d;\n    \n}\n\n\n#define MAX_STEPS 100    \n#define MAX_DIST 100.   \n#define SURF_DIST .01\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat d0=0.;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n       \n       vec3 p = ro + rd*d0;\n       //add time-dependent displacement\n       float var = clamp(noise(p.xy*sin(iTime)),0.0, 5.0)*0.3*cos(iTime+p.x);\n       float ds = sdfScene(p)+var;   \n       d0+=ds;\n       // to long or to small -> break\n       if(d0>MAX_DIST) {d0=0.;break;}\n       if(ds<SURF_DIST) break;\n        \n    }\n    \n    return d0;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;    //45 degree light dir\n    return normalize(e.xyy*sdfScene(pos + e.xyy*ep)\n                     +e.yyx*sdfScene(pos + e.yyx*ep)\n                     +e.yxy*sdfScene(pos + e.yxy*ep)\n                     +e.xxx*sdfScene(pos + e.xxx*ep));\n                     \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0.0, 0.0, 0.0, 1.);\n    \n    //Add Anti-Aliasing Support\n    // Normalized pixel coordinates [-0.5 0.5]\n    // and make it squared\n    for(int m=0; m<AA;m++)\n    for(int n=0; n<AA; n++)\n    {\n        vec2 offset = vec2(float(m), float(n))/float(AA) - 0.5;\n        vec2 uv = (fragCoord+offset - 0.5*iResolution.xy)/iResolution.y;\n\n        vec3 camera_position = vec3(1.0, 3.0, -5.0);\n        vec3 ro = camera_position;\n        vec3 rd = normalize(vec3(uv, 1.0));\n\n        //perform the rendering\n        vec4 col = vec4(0., 0., 0., 1.); \n        float d = RayMarch(ro, rd);  //add time-independent displacement\n        if(d>0.) \n        {\n            col.rgb = vec3(1.);\n            vec3 pos = ro + d*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp(dot(nor, vec3(0.5773)), 0.0, 1.0);\n            col.rgb = vec3(0.025, 0.05, 0.08) + dif*vec3(1.0, 0.9, 0.8);\n            \n        }\n        col = sqrt(clamp(col, 0.0, 1.0));\n        tot.rgb +=col.rgb;\n    }\n    \n    tot.rgb /= float(AA*AA);\n    // Output to screen\n    fragColor = tot; //vec4(uv,0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}