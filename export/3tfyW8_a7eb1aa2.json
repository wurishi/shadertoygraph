{"ver":"0.1","info":{"id":"3tfyW8","date":"1591896564","viewed":96,"name":"GiVD - Transform Shader","username":"RedReservoir","description":"Shader for testing TG with SDFs.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["givd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAYMARCHING_ITERATIONS 100\n#define EPSILON 0.00001\n#define MIN_DIST 0.00001\n#define MAX_DIST 100.0\n\nstruct material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n        \nstruct light {\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmaterial mat_red = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.2, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_green = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_blue = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_orange = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.5, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_turquoise = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.5), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_purple = material(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\n\nlight[] scene_lights = light[] (\n    light(vec3(0.0, 0.0, 0.0), vec3(0.05, 0.05, 0.05), vec3(0.4, 0.4, 0.4), vec3(0.0, 0.0, 0.0)),\n    light(vec3(10.0, 10.0, 10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(-10.0, -10.0, -10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0))\n);\nint l_num = 3;\n\nvec3 background_color = vec3(0.7, 0.7, 0.9);\n\n//---------------------------------------------------------------------------------\n\nfloat mixInverse(float x, float y, float a) {\n\treturn (a - x) / (y - x);    \n}\n\nfloat unitMap(float x) {\n    return (2.0 / (1.0 + exp(-x))) - 1.0;\n}\n\nfloat unitMapInverse(float x) {\n\treturn -log((2.0 / (x + 1.0)) - 1.0);    \n}\n\nfloat unitPow(float x, float p) {\n\treturn unitMap(pow(unitMapInverse(x), p));   \n}\n\nmat4 identityMatrix() {\n\tmat4 id;\n    id[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    id[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    id[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    id[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    return id;\n}\n\nmat4 rotationMatrix(float ax, float ay, float az) {\n\tmat4 rot_x;\n    rot_x[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    rot_x[1] = vec4(0.0, cos(ax), -sin(ax), 0.0);\n    rot_x[2] = vec4(0.0, sin(ax), cos(ax), 0.0);\n    rot_x[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_x = transpose(rot_x);\n\n    mat4 rot_y;\n    rot_y[0] = vec4(cos(ay), 0.0, sin(ay), 0.0);\n    rot_y[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    rot_y[2] = vec4(-sin(ay), 0.0, cos(ay), 0.0);\n    rot_y[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_y = transpose(rot_y);\n\n    mat4 rot_z;\n    rot_z[0] = vec4(cos(az), -sin(az), 0.0, 0.0);\n    rot_z[1] = vec4(sin(az), cos(az), 0.0, 0.0);\n    rot_z[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    rot_z[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_z = transpose(rot_z);\n    \n    return rot_z * rot_y * rot_x;\n}\n\nmat4 scaleMatrix(float sx, float sy, float sz) {\n    mat4 sc;\n    sc[0] = vec4(sx, 0.0, 0.0, 0.0);\n    sc[1] = vec4(0.0, sy, 0.0, 0.0);\n    sc[2] = vec4(0.0, 0.0, sz, 0.0);\n    sc[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    sc = transpose(sc);\n    return sc;\n}\n\nmat4 translationMatrix(float tx, float ty, float tz) {\n    mat4 tr;\n    tr[0] = vec4(1.0, 0.0, 0.0, tx);\n    tr[1] = vec4(0.0, 1.0, 0.0, ty);\n    tr[2] = vec4(0.0, 0.0, 1.0, tz);\n    tr[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    tr = transpose(tr);\n    return tr;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 c, float h, float r) {\n    float inOutRadius = length(p.xy - c.xy) - r;\n    float inOutHeight = abs(p.z - c.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat hexPrismSDF(vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid unionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 < d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid intersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 > d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid differenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(-d1 > d2) {\n        d = -d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid smoothUnionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) - k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothIntersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothDifferenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, -d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid sceneSDF(vec3 pos, out float dist, out material obj_mat) {\n        \n    float speed_1 = 0.7;\n    mat4 geom_transform_1 =\n        scaleMatrix(2.0 + sin(iTime), 1.5 + cos(iTime) / 2.0, 1.0) *\n        rotationMatrix(iTime, 8.0 * iTime * speed_1 / 7.0, 6.0 * iTime * speed_1 / 7.0) * \n        translationMatrix(-5.0, 0.0, 0.0) *\n        rotationMatrix(0.0, 12.0 * iTime * speed_1 / 7.0, 0.0);\n    \n    float speed_2 = 0.65;\n    mat4 geom_transform_2 =\n        scaleMatrix(1.5 + sin(iTime) / 2.0, 2.0 + cos(iTime), 1.0) *\n        rotationMatrix(iTime, 9.0 * iTime * speed_2 / 7.0, 5.0 * iTime * speed_2 / 7.0) * \n        translationMatrix(-4.0, 0.0, 0.0) *\n        rotationMatrix(0.0, -9.0 * iTime * speed_2 / 8.0, 0.0);\n    \n    vec3 new_pos_1 = (inverse(geom_transform_1) * vec4(pos, 1.0)).xyz;\n    vec3 new_pos_2 = (inverse(geom_transform_2) * vec4(pos, 1.0)).xyz;\n\n        \n    float dist_1 = torusSDF(new_pos_1, vec2(2.0, 0.5));\n    float dist_2 = torusSDF(new_pos_2, vec2(2.0, 0.5));\n    \n    smoothUnionSDF(dist_1, dist_2, mat_orange, mat_purple, dist, obj_mat, 1.0, 1.0);\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 blinnPhong(vec3 pos, vec3 V, vec3 N, material mat, light lt) {\n    //Calculate L and H vectors\n    vec3 L = normalize(vec3(lt.position - pos));\n    vec3 H = normalize(L + V);\n\n    //Ambient\n    vec3 ambient = lt.ambient * mat.ambient;\n\n    //Diffuse\n    vec3 diffuse = lt.diffuse * mat.diffuse * max(dot(L, N), 0.0f);\n\n    //Specular\n    vec3 specular = lt.specular * mat.specular * pow(max(dot(H, N), 0.0f), mat.shininess);\n    \n    //Final color calculation\n    //vec3 color = diffuse + ambient + specular;\n    vec3 color = diffuse + ambient;\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 estimateNormal(vec3 pos) {\n    material placeholder;\n    float nxr, nxl, nyr, nyl, nzr, nzl;\n    sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z), nxr, placeholder);\n    sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z), nxl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z), nyr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z), nyl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON), nzr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON), nzl, placeholder);\n   \n    return normalize(vec3(nxr - nxl, nyr - nyl, nzr - nzl));\n}\n\nvoid castRay(vec3 ray_origin, vec3 ray_direction, float dmin, float dmax, out float scene_dist, out material obj_mat) {    \n    scene_dist = dmin;\n    float step_dist;\n    for(int it = 0; it < MAX_RAYMARCHING_ITERATIONS; it++) {\n        vec3 ray_pos = ray_origin + (ray_direction * scene_dist);\n        sceneSDF(ray_pos, step_dist, obj_mat);\n        scene_dist += step_dist;\n        if(step_dist < EPSILON || scene_dist > dmax) { return; }\n    }\n   \n    scene_dist = dmax + 1.0;\n}\n\nvec3 calculateScreenRayDirection(vec2 fragCoord, vec2 size, float fov) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calculateCameraMatrix(vec3 lookfrom, vec3 lookat, vec3 vup) {\n    vec3 cz = normalize(lookat - lookfrom);\n    vec3 cx = normalize(cross(cz, vup));\n    vec3 cy = cross(cx, cz);\n    return mat3(cx, cy, -cz);\n}\n\n\n//---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Precalculate variables\n    vec2 mouse_UV = iMouse.xy / iResolution.xy;\n    \n    //Camera calculations\n    vec3 cam_lookat = vec3(0, 0, 0);\n    vec3 cam_lookfrom = cam_lookat + vec3(0.0,\n                                          12.0,\n                                          40.0\n                                         );\n    vec3 cam_vup = vec3(0, 1, 0);\n    mat3 cam_matrix = calculateCameraMatrix(cam_lookfrom, cam_lookat, cam_vup);\n    \n    //Apply raymarching\n    float scene_dist;\n    material obj_mat;\n    \n    vec3 ray_origin = cam_lookfrom;\n    vec3 ray_direction = cam_matrix * calculateScreenRayDirection(fragCoord, iResolution.xy, 45.0);\n    castRay(ray_origin, ray_direction, MIN_DIST, MAX_DIST, scene_dist, obj_mat);\n    \n    vec3 pos = ray_origin + (ray_direction * scene_dist);\n    vec3 norm = estimateNormal(pos);\n\n    vec3 col = vec3(0);\n    if(scene_dist < MAX_DIST) {\n        for(int l_index = 0; l_index < l_num; l_index++) {\n        \tcol += blinnPhong(pos, vec3(cam_lookfrom - pos), norm, obj_mat, scene_lights[l_index]);\n        }\n    } else {\n        col = background_color;\n    }\n    \n    //Gamma normalization\n    //col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}