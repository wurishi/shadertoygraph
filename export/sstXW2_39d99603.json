{"ver":"0.1","info":{"id":"sstXW2","date":"1634007585","viewed":171,"name":"One Hundred and One Pigs","username":"shyuriken","description":"One Hundred and One Pigs \nsdf modeling and fold animation","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// AntiAliasing only\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 292 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat luminance(vec3 col) { return dot(col, vec3(.2126729, .7151522, .072175)); }\n\nvec3 FXAA(sampler2D tex, vec2 uv) {\n\tconst vec3 e = vec3(-1, 1, 0);\n\tvec2 offuv = uv;\n\tvec3 colnw = texture(tex, uv + e.xy / iResolution.xy).rgb,\n\t     coln = texture(tex, uv + e.zy / iResolution.xy).rgb,\n\t     colne = texture(tex, uv + e.yy / iResolution.xy).rgb,\n\t     colw = texture(tex, uv + e.xz / iResolution.xy).rgb,\n\t     colm = texture(tex, uv + e.zz / iResolution.xy).rgb,\n\t     cole = texture(tex, uv + e.yz / iResolution.xy).rgb,\n\t     colsw = texture(tex, uv + e.xx / iResolution.xy).rgb,\n\t     cols = texture(tex, uv + e.zx / iResolution.xy).rgb,\n\t     colse = texture(tex, uv + e.yx / iResolution.xy).rgb;\n\tfloat ish,\n\t      lnw = luminance(colnw),\n\t      ln = luminance(coln),\n\t      lne = luminance(colne),\n\t      lw = luminance(colw),\n\t      lm = luminance(colm),\n\t      le = luminance(cole),\n\t      lsw = luminance(colsw),\n\t      ls = luminance(cols),\n\t      lse = luminance(colse),\n\t      maxl = max(ln, max(ls, max(lw, max(le, lm)))),\n\t      diff = maxl - min(ln, min(ls, min(lw, min(le, lm))));\n\tif (diff < max(.0833, .166 * maxl)) return colm;\n\tfloat filterfactor = 0.;\n\tfilterfactor += 2. * (ln + lw + ls + le) + lnw + lne + lsw + lse;\n\tfilterfactor /= 12.;\n\tfilterfactor = clamp(abs(filterfactor - lm) / diff, 0., 1.);\n\tfloat blend = smoothstep(0., 1., filterfactor);\n\tblend *= blend;\n\tish = step(2. * (le + lw - 2. * lm) + (lne + lnw - 2. * ln) + (lse + lsw - 2. * ls), 2. * (ln + ls - 2. * lm) + (lne + lse - 2. * le) + (lnw + lsw - 2. * lw));\n\tfloat psoff = ish >= 1. ? 1. / iResolution.y : 1. / iResolution.x;\n\tif (abs(ish >= 1. ? ln : le - lm) < abs(ish >= 1. ? ls : lw - lm)) psoff = -psoff;\n\tif (ish >= 1.) offuv.y += psoff * blend;\n\telse offuv.x += psoff * blend;\n\n\treturn vec3(textureLod(tex, offuv, 0.).rgb);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) { fragColor = vec4(FXAA(iChannel0, fragCoord / iResolution.xy), 1); }","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Processed by 'GLSL Shader Shrinker' (Shrunk by 2,474 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat pBox(vec3 b, vec3 p) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat pTriPrism(float h, float r, vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h, max(q.x * .866025 + p.y * .5, -p.y) - r * .5);\n}\n\nfloat pCylinder(float r, float h, vec3 p) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat pEllipsoid(vec3 r, vec3 p) {\n\tfloat k0 = length(p / r);\n\treturn k0 * (k0 - 1.) / length(p / (r * r));\n}\n\nvec3 mTranslation(vec3 inv_translation, vec3 p) { return p + inv_translation; }\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nvec3 mMirror(vec3 normal, float dist, vec3 p) { return p - 2. * max(0., dot(normal, p) - dist) * normal; }\n\nfloat sabs(float p) { return sqrt(p * p + 1e-2); }\n\nvec3 mFold(vec3 sw, vec3 t, vec3 p) {\n\tfloat h, a,\n\t      n = sw.x,\n\t      r = sw.y;\n\tbool s = sw.z > 0.;\n\th = floor(log2(n));\n\ta = 6.2832 * exp2(h) / n;\n\tfor (int i = 0; i < int(h) + 2; i++) {\n\t\tvec2 v = normalize(vec2(-cos(a), sin(a)));\n\t\tfloat g = dot(p.xz, v);\n\t\tp.xz -= (g - ((r > 0.) ? sabs(g) : abs(g))) * v;\n\t\ta *= .5;\n\t}\n\n\tp.xz -= clamp(p.xz, s ? -t.xz : t.xz, t.xz);\n\treturn p;\n}\n\nfloat oUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat oThicken(float thickness, float d) { return d - thickness; }\n\nfloat oSmoothUnion(float k, float d1, float d2) {\n\tfloat h = clamp(.5 + .5 * (d1 - d2) / k, 0., 1.);\n\treturn mix(d1, d2, h) - k * h * (1. - h);\n}\n\nfloat oSmoothSubtraction(float k, float d1, float d2) {\n\tfloat h = clamp(.5 - .5 * (d1 + d2) / k, 0., 1.);\n\treturn mix(d1, -d2, h) + k * h * (1. - h);\n}\n\nfloat sdf(vec3 p0) {\n\tp0.z += 50.;\n\tfloat d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19, d20;\n\t{\n\t\tvec3 p1 = mFold(vec3(101.*abs(sin(iTime*0.05)), 1, 0), vec3(0, 0, 46), p0);\n\t\t{\n\t\t\tvec3 p2 = mRotation(mat3(1, 0, 0, 0, -0, 1, 0, -1, -0), p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.677496, 1.03517, .845881), p3);\n\t\t\t\t\t{ d1 = pEllipsoid(vec3(.317834, .389427, 1.28), mRotation(mat3(.997936, .036243, .053017, -.053274, .928209, .368227, -.035865, -.370291, .928223), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.810368, -1.41275, .78488), p3);\n\t\t\t\t\t{ d2 = pEllipsoid(vec3(.317834, .389427, 1.28), mRotation(mat3(.997936, .063492, .009651, -.053274, .902341, -.427719, -.035865, .426322, .90386), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.609872, 1.65283, 1.81004), p3);\n\t\t\t\t\t{ d3 = pEllipsoid(vec3(.317834, .389427, .224704), mRotation(mat3(.997936, .050853, .039223, -.053274, .996567, .063372, -.035865, -.06533, .997219), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.779156, -1.52652, 1.82232), p3);\n\t\t\t\t\t{ d4 = pEllipsoid(vec3(.317834, .419824, .224704), mRotation(mat3(.997936, .050853, .039223, -.053274, .996567, .063372, -.035865, -.06533, .997219), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.75592, -1.07116, 1.79248), p3);\n\t\t\t\t\t{ d5 = pTriPrism(.224704, .317834, mRotation(mat3(.997936, .050853, .039223, -.053274, .996567, .063372, -.035865, -.06533, .997219), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.585204, 2.15659, 1.74812), p3);\n\t\t\t\t\t{ d6 = pTriPrism(.224704, .317834, mRotation(mat3(.997936, .050853, .039223, -.053274, .996567, .063372, -.035865, -.06533, .997219), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mRotation(mat3(1, 0, 0, 0, -0, 1, 0, -1, -0), p1);\n\t\t\t{ d7 = pEllipsoid(vec3(1.28, 1.99566, 1.28), mTranslation(vec3(-0, -0, -.24), p2)); }\n\t\t\t{ d8 = pEllipsoid(vec3(1.25807, 1.27383, 1.18272), mTranslation(vec3(-0, 2.19676, -.697841), p2)); }\n\t\t\t{ d9 = pEllipsoid(vec3(.523608, .4, .4), mTranslation(vec3(-0, 3.53394, -.66776), p2)); }\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.56286, 2.50059, -1.98436), p3);\n\t\t\t\t\t{ d10 = pEllipsoid(vec3(.22, .19332, .333723), mRotation(mat3(.951097, .035688, .306824, -.032899, .999357, -.014261, -.307135, .00347, .95166), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t{ d11 = pBox(vec3(.523608, .4, .4), mTranslation(vec3(-0, 4.10564, -.697841), p2)); }\n\t\t\t{ d12 = pEllipsoid(vec3(.13, .22, .15), mTranslation(vec3(.2, 3.66, -.7), p2)); }\n\t\t\t{ d13 = pEllipsoid(vec3(.126052, .22, .136304), mTranslation(vec3(-.240216, 3.65702, -.7078), p2)); }\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-.55706, 2.66301, -1.9838), p3);\n\t\t\t\t\t{ d14 = pEllipsoid(vec3(.22, .19332, .333723), mRotation(mat3(.951097, .035688, .306824, -.032899, .999357, -.014261, -.307135, .00347, .95166), p4)); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{ d15 = pEllipsoid(vec3(.22), mTranslation(vec3(-.453488, 3.19157, -1.29908), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mMirror(vec3(-1, 0, 0), 0., p2);\n\t\t\t\t{ d16 = pEllipsoid(vec3(.13458, .063269, .127974), mTranslation(vec3(-.422868, 3.0823, -1.2628), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(.014604, -2.10898, -.9746), p2);\n\t\t\t\t{ d17 = pCylinder(.13, -.01, mRotation(mat3(.087156, .996195, -0, 0, -0, -1, -.996195, .087156, -0), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(.003386, -2.51274, -.979361), p2);\n\t\t\t\t{ d18 = pEllipsoid(vec3(.111785, .317131, .112422), mRotation(mat3(.058344, -.063921, .996248, .662402, .749091, .00927, -.746873, .659376, .086046), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(-.023682, -2.06754, -.710119), p2);\n\t\t\t\t{ d19 = pEllipsoid(vec3(.111785, .317131, .112422), mRotation(mat3(.072743, -.008632, .997313, .495892, .867911, -.028657, -.865332, .496644, .067415), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(.014604, -2.10898, -.9746), p2);\n\t\t\t\t{ d20 = pCylinder(.16, .21, mRotation(mat3(.087156, .996195, -0, 0, -0, -1, -.996195, .087156, -0), p3)); }\n\t\t\t}\n\t\t}\n\t}\n\treturn oSmoothUnion(.3, d7, oUnion(oSmoothUnion(.1, oSmoothSubtraction(.05, d10, d14), oSmoothUnion(.1, oSmoothSubtraction(.05, d8, d15), oSmoothSubtraction(.05, oSmoothSubtraction(.05, d9, d11), oUnion(d13, d12)))), oUnion(d16, oUnion(oSmoothUnion(.1, d18, oSmoothUnion(.1, d19, oSmoothSubtraction(.05, oThicken(.17, d17), d20))), oUnion(oSmoothUnion(.1, d1, oSmoothSubtraction(.05, d3, d6)), oSmoothUnion(.1, d2, oSmoothSubtraction(.05, d4, d5)))))));\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (h < .001) break;\n\t\tt += h;\n\t\tif (t > 1e3) break;\n\t}\n\n\tif (t > 1e3) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(5. * cos(iTime * .1), 8.2 * sin(iTime * .1) * cos(iTime * .1), 14. * sin(iTime * .1)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tfloat t = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(1);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.18) * vec3(7, 4.5, 3) * sun_dif * sun_sha;\n\t\tcol += vec3(.18) * vec3(.5, .8, .9) * sky_dif * occ;\n\t\tcol += vec3(.18) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}