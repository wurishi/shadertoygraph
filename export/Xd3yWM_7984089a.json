{"ver":"0.1","info":{"id":"Xd3yWM","date":"1519055473","viewed":131,"name":"Astroid with Ellipses","username":"Ultraviolet","description":"Same curve than [url]https://www.shadertoy.com/view/XsccDH[/url], different technique.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["ellipse","accumulation","astroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Rainbow Nephroid - Circle\" by Ultraviolet. https://shadertoy.com/view/4dccDH\n// 2018-02-19 15:09:23\n\n// Fork of \"Caustic Nephroid\" by Ultraviolet. https://shadertoy.com/view/XddcDr\n// 2018-02-14 08:14:12\n\n\nfloat drawAlpha(Ray r, vec2 p, float width)\n{\n    float d = dist(r, p);\n    return mix(1.,0.,clamp(d*iResolution.y/2. - width, -1., 1.)*.5+.5);\n}\n\nvoid draw(Ray r, vec2 p, float width, vec3 fgCol, inout vec3 bgCol)\n{\n    bgCol = mix(bgCol, fgCol, drawAlpha(r, p, width));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buf = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec3 c = buf.rgb;\n    \n    c = sqrt(c);\n    \n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define lineWidth \t(0.)\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int N = int(iResolution.y);\n    //int N = 20;\n    float dy = 1. / (float(N)-1.);\n    float k = float(iFrame) *dy;\n    \n    //float r = .38;\n    //Circle c = Circle(vec2(0.15,0.), r);\n    Circle c = Circle(vec2(0.), 1.);\n    \n    //Circle c0 = Circle(getPt(c, k), c.rad*2.*sin(k*PI));\n    \n    \n    vec2 p = (fragCoord -iResolution.xy*.5)/iResolution.y*2.;\n    vec3 col = vec3(0.);\n    float d;\n    \n    //d = dist(c,p/vec2(k, 1.-k));\n    d = dist(Ellipse(vec2(0), vec2(k, 1.-k)*.5),p);\n    //vec3 cc = hsv2rgb_smooth(vec3(k*.5,1.,1.));\n    vec3 cc = hsv2rgb_smooth(vec3(k,1.,1.));\n    \n    if(min(k, 1.-k)< 0.001)\n        cc *= 2.;\n        \n    \n    col = mix(col, cc, mix(1.,0.,clamp(d*iResolution.y/4. - lineWidth, -1., 1.)*.5+.5));\n        \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(k<=1.)\n    \tfragColor += vec4(col*.05, 1.);\n    //fragColor = (fragColor*float(iFrame) + vec4(col, 1.))/float(iFrame+1);\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    //fragColor = vec4(dist(Ellipse(vec2(0), m),p));\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI\t3.1415926535\n\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n    \nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n    \nstruct Ellipse\n{\n    vec2 ctr;\n    vec2 rad;\n};\n    \nvec2 getPt(Ellipse e, float t)\n{\n    return e.ctr + vec2(cos(t*2.*PI), sin(t*2.*PI))*e.rad;\n}\n\nbool intersect(Circle c, Ray r, out vec2 t)\n{\n    float A = dot(r.dir, r.dir);\n    float B = dot(r.dir, -c.ctr+r.org);\n    float C = dot(c.ctr, c.ctr) +dot(r.org, r.org) -2.*dot(c.ctr, r.org) - c.rad*c.rad;\n    \n    float delta = B*B-A*C;\n    \n    if(delta < 0.0)\n    \treturn false;\n\n    t = (vec2(-B) + vec2(sqrt(delta))*vec2(-1.,1.))/A;\n    return true;\n}\n\nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n}\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\nfloat dist(Circle c, vec2 p)\n{\n    return abs(length(c.ctr-p)-c.rad);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n    \n}\n\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\nfloat dist(Ellipse e, vec2 p)\n{\n    if(e.rad.x < 0.001)\n        return dist(Segment(e.ctr + vec2(0., e.rad.y), e.ctr - vec2(0., e.rad.y)), p);\n    if(e.rad.y < 0.001)\n        return dist(Segment(e.ctr + vec2(e.rad.x, 0.), e.ctr - vec2(e.rad.x, 0.)), p);\n    \n    return abs(sdEllipse(p-e.ctr, e.rad));\n}\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}