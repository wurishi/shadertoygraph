{"ver":"0.1","info":{"id":"fsK3zd","date":"1638124358","viewed":701,"name":"A Simple Path Tracer","username":"GCScholar","description":"A simple, common path tracer, but the first one for me ^_^\nClick and move to reset rendering","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["raytracer","pathtarcer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// An usual path tracer, but first one for me ^_^\n//\n// Great resources for path and tracing in general\n//\n// Super useful and easy ---> https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n// https://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n// https://www.realtimerendering.com/raytracinggems/rtg2/index.html\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n\n    // Increase exposure\n    color *= 2.5;\n    \n    // Convert unbounded HDR color range to SDR color range: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    color = ACESFilm(color);\n    \n    // Gamma correction\n    fragColor = vec4(pow(color.xyz, vec3(0.4545)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////// SDF \n\nfloat pSphere(float r, vec3 p)\n{\n\treturn length(p) - r;\n}\n\nfloat pBox(vec3 b, vec3 p)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat pOctahedron(float s, vec3 p)\n{\n\tp = abs(p);\n\tfloat m = p.x+p.y+p.z-s;\n\tvec3 q;\n\t\tif( 3.0*p.x < m ) q = p.xyz;\n\telse if( 3.0*p.y < m ) q = p.yzx;\n\telse if( 3.0*p.z < m ) q = p.zxy;\n\telse return m*0.57735027;\n\t\t\n\tfloat k = clamp(0.5*(q.z-q.y+s),0.0,s); \n\treturn length(vec3(q.x,q.y-s+k,q.z-k));\n\n\t// bound\n\t// p = abs(p);\n\t// return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat pFrame(vec3 size, float thickness, vec3 p)\n{\n\tp = abs(p) - size;\n\tvec3 q = abs(p + thickness) - thickness;\n\tfloat a = length(max(vec3(p.x,q.y,q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0);\n\tfloat b = length(max(vec3(q.x,p.y,q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0);\n\tfloat c = length(max(vec3(q.x,q.y,p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0);\n\treturn min(min(a, b), c);\n}\n\nvec2 oUnion(vec2 d1, vec2 d2)\n{\n    if(d1.x < d2.x) return d1;\n    return d2;\n}\n\nfloat oSubtraction(float d1, float d2)\n{\n\treturn max(d1, -d2);\n}\n\nvec3 mTranslation(vec3 translation, vec3 p)\n{\n\treturn p - translation;\n}\n\n\n////// sRGB <--> linear conversions\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n////// Tone mapping\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FOCAL_LENGTH 1.2\n#define MAX_MARCHING_DISTANCE 30.\n#define RAYS_SHOOTED_FOR_FRAME 4\n#define MAX_BOUNCES 8\n\n#define PI acos(-1.)\n#define TWO_PI 2.*PI\n\nuint pcg_hash(inout uint seed)\n{\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    seed = (word >> 22u) ^ word;\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(pcg_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * TWO_PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n\n/// SDF \n\n\nvec2 scene(vec3 p0)\n{\n    vec3 TrIn_1 = vec3(0,4.05,0);\n    vec3 BoSi_2 = vec3(2,0.1,2);\n    vec3 TrIn_3 = vec3(0,-4,0);\n    vec3 BoSi_4 = vec3(6.1,0.1,4);\n    vec3 TrIn_5 = vec3(0,4.1,0);\n    vec3 BoSi_6 = vec3(6.1,0.1,4);\n    vec3 TrIn_7 = vec3(0,0,-4);\n    vec3 BoSi_8 = vec3(6,4,0.1);\n    vec3 TrIn_9 = vec3(-6,0,0);\n    vec3 BoSi_10 = vec3(0.1,4,4);\n    vec3 TrIn_11 = vec3(6,0,0);\n    vec3 BoSi_12 = vec3(0.1,4,4);\n    vec3 TrIn_13 = vec3(3,-3,0);\n    vec3 BoSi_14 = vec3(1,2,1);\n\tvec3 TrIn_15 = vec3(-1,-3,2);\n    vec3 BoSi_16 = vec3(1,1,1);\n    vec3 TrIn_17 = vec3(-1,-1.3,2);\n    float SpRa_18 = 0.7;\n    vec3 TrIn_19 = vec3(5.9,3,0);\n    vec3 BoSi_20 = vec3(0.1,0.1,4);\n    vec3 TrIn_21 = vec3(-5.9,3,0);\n    vec3 BoSi_22 = vec3(0.1,0.1,4);\n    vec3 TrIn_23 = vec3(0,-3,-3.95);\n    vec3 BoSi_24 = vec3(6,0.1,0.1);\n    vec3 TrIn_24 = vec3(-5.95,-3,0);\n    vec3 TrIn_25 = vec3(5.95,-3,0);\n    vec3 TrIn_26 = vec3(0,3,-3.95);\n    vec3 TrIn_27 = vec3(3,-1.,0);\n    vec3 BoSi_28 = vec3(0.1,0.5,0.1);\n    \n    vec3 p1;\n    vec2 d;\n    vec2 d1;\n    \n    // Light (emissive box)\n\t//vec3 p1 = mTranslation(TrIn_1, p0);\n\t//d = vec2(pBox(BoSi_2, p1), 1); \n    \n    // Floor\n    p1 = mTranslation(TrIn_3, p0);\n    d = vec2(pBox(BoSi_4, p1), 2); \n    //d = oUnion(d,d1);\n    \n    // Ceil\n\tp1 = mTranslation(TrIn_5, p0);\n\td1 = vec2(pBox(BoSi_6, p1), 2);\n    d = oUnion(d,d1);\n    \n    // Back wall\n\tp1 = mTranslation(TrIn_7, p0);\n\td1 = vec2(pBox(BoSi_8, p1), 2);\n    d = oUnion(d,d1);\n    \n    // Left wall\n\tp1 = mTranslation(TrIn_9, p0);\n\td1 = vec2(pBox(BoSi_10, p1), 2);\n    d = oUnion(d,d1);\n    \n    // Right wall\n\tp1 = mTranslation(TrIn_11, p0);\n\td1 = vec2(pBox(BoSi_12, p1), 2);\n    d = oUnion(d,d1);\n\t\n    // Right box\n    p1 = mTranslation(TrIn_13, p0);\n\td1 = vec2(pBox(BoSi_14, p1), 2);\n\td = oUnion(d,d1);\n    \n    // Left box\n\tp1 = mTranslation(TrIn_15, p0);\n\td1 = vec2(pBox(BoSi_16, p1), 2);\n    d = oUnion(d,d1);\n    \n    // Sphere\n    p1 = mTranslation(TrIn_17, p0);\n\td1 = vec2(pSphere(SpRa_18, p1), 3);\n    d = oUnion(d,d1);\n    \n    // Luminescent box\n    p1 = mTranslation(TrIn_27, p0);\n\td1 = vec2(pBox(BoSi_28, p1), 4);\n    d = oUnion(d,d1);\n     \n    // Central low light\n    p1 = mTranslation(TrIn_26, p0);\n\td1 = vec2(pBox(BoSi_24, p1), 5);\n    d = oUnion(d,d1);\n    \n    // Right light\n    p1 = mTranslation(TrIn_19, p0);\n\td1 = vec2(pBox(BoSi_20, p1), 5);\n    d = oUnion(d,d1);\n    \n    // Left light\n    p1 = mTranslation(TrIn_21, p0);\n\td1 = vec2(pBox(BoSi_22, p1), 5);\n    d = oUnion(d,d1);\n    \n    // Central low light\n    p1 = mTranslation(TrIn_23, p0);\n\td1 = vec2(pBox(BoSi_24, p1), 1);\n    d = oUnion(d,d1);\n    \n    // Right low light\n    p1 = mTranslation(TrIn_24, p0);\n\td1 = vec2(pBox(BoSi_20, p1), 1);\n    d = oUnion(d,d1);\n    \n    // Left low light\n    p1 = mTranslation(TrIn_25, p0);\n\td1 = vec2(pBox(BoSi_22, p1), 1);\n    d = oUnion(d,d1);\n    \n    \n\treturn d;\n}\n\n///////\n\nvec3 normal(vec3 P)\n{\n\tvec2 eps = vec2(0.,0.0001);\n    return normalize(vec3(\n        scene(P+eps.yxx).x - scene(P-eps.yxx).x, \n\t\tscene(P+eps.xyx).x - scene(P-eps.xyx).x, \n        scene(P+eps.xxy).x - scene(P-eps.xxy).x));\n}\n\n\nstruct Material \n{\n   vec3 albedo;\n   vec3 emissive;\n};\n    \nMaterial material(int id) \n{\n    Material mat;\n    \n    if(id==1) // Emissive white material 1\n    {   \n        mat.albedo = vec3(0);\n        mat.emissive = vec3(10);\n    }\n    else if(id==2) // White\n    {   \n        mat.albedo = vec3(0.15, 0.15, 0.15);\n        mat.emissive = vec3(0);\n    }\n    else if(id==3) // Ball\n    {   \n        mat.albedo = vec3(0.1, 0.7, 0.3);\n        mat.emissive = vec3(0);\n    }\n    else if(id==4) // Emisive purple\n    {   \n        mat.albedo = vec3(0);\n        mat.emissive = vec3(0.,0.2,0.2) * 100.;\n    }\n    else if(id==5) // Emissive Blue\n    {   \n        mat.albedo = vec3(0);\n        mat.emissive = vec3(0.2,0.,0.2) * 30.;\n    }\n    \n\n    return mat;\n}\n\nstruct Hit \n{\n    float dist;\n    vec3 point;\n    vec3 normal;\n    int objId;\n};\n\nHit castRay(vec3 ro, vec3 dir) \n{\n    Hit hit; \n    hit.objId = -1;\n    \n    float t=0.0;\n    int i=0;\n    while(t < MAX_MARCHING_DISTANCE) \n    {\n        i++;\n        vec3 P = ro+t*dir;\n        vec2 d = scene(P);\n        if(d.x < 0.0001)\n        {\n            // Hit something\n            hit.dist = t;\n            hit.point = P;\n            hit.normal = normal(P);\n            hit.objId = int(d.y);\n            return hit;\n        }\n        t+=d.x;    \n    }\n    return hit; // No hit\n}\n\nvec3 GetColorForRay(in vec3 rayStart, in vec3 rayDir, uint rngState)\n{\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n     \n    for (int i=0; i<=MAX_BOUNCES; ++i)\n    {   \n        Hit hit = castRay(rayStart, rayDir);\n         \n        if(hit.objId == -1)\n        {\n            // Ray miss, sample environment cube map\n            ret += SRGBToLinear(texture(iChannel1, rayDir).rgb) * throughput;\n            break;\n        }\n        \n        Material mat = material(hit.objId);\n\n        // Compute bouncing ray\n        rayStart = (rayStart + rayDir * hit.dist) + hit.normal * 0.001;\n        rayDir = normalize(hit.normal + RandomUnitVector(rngState));        \n        \n        ret += mat.emissive * throughput;\n        throughput *= mat.albedo;      \n        \n        \n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        float p = max(throughput.r, max(throughput.g, throughput.b));\n        if (RandomFloat01(rngState) > p) break;\n\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        throughput *= 1.0f / p;\n    }\n  \n    // return pixel color\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Compute different random state for each pixel\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // Antialiasing using jitter\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    \n    // Centered normalized coordinates\n    vec2 U = (2.*(fragCoord+jitter)-iResolution.xy)/(iResolution.x);\t\n    \n    // Camera\n    vec2 pos;\n    if(iMouse.x <= 0.) pos = iResolution.xy/2.+iResolution.xy/10.;\n    else pos = iMouse.xy;\n    \n    vec2 camAngle = (pos.xy/iResolution.xy)*PI/2.-PI/4.;\n    vec3 P_eye = vec3(10.0*sin(camAngle.x), 10.0*sin(camAngle.y), 10.0*cos(camAngle.x));\n    vec3 P_target = vec3(0.,0.,0.);\n    \n    // Camera reference frame\n    vec3 ww = normalize(P_eye - P_target);\n    vec3 vv = normalize(cross(vec3(0.,1.,0.), ww));\n    vec3 uu = normalize(cross(ww, vv));\n    \n    // Ray through this pixel\n    vec3 ray = normalize(U.x*vv + U.y*uu - FOCAL_LENGTH*ww);\n    \n    // Shoot the ray\n    vec3 color;\n    for(int i=0; i<RAYS_SHOOTED_FOR_FRAME; i++)\n    {\n        rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(i+1) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n        color += GetColorForRay(P_eye, ray, rngState);\n    }\n    color /= vec3(RAYS_SHOOTED_FOR_FRAME);\n    \n    // Average the frames\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || iMouse.z > 0.) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend); \n    \n    fragColor = vec4(color, blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}