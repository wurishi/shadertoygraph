{"ver":"0.1","info":{"id":"Nldczs","date":"1660515429","viewed":189,"name":"Sea Cucumber on Beach","username":"harry7557558","description":"I tried to find a way to grow \"spines\" on an arbitrary solid body. I created a sea cucumber on a beach to showcase my method.","likes":20,"published":1,"flags":0,"usePreview":1,"tags":["voronoi","beach","spine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I tried to find a way to grow \"spines\" on an arbitrary solid body\n// after seeing this:\n// https://www.thisiscolossal.com/2022/08/julie-bergeron-ceramic-sculptures/\n\n// Given the SDF of a body and the SDF of a spine,\n// how do create an SDF that has the spines growing on the body?\n\n// I found a (not so perfect) solution and implemented it\n// in the closestGrid() and the mapCucumber() functions.\n\n// I created a sea cucumber on a beach to showcase my method.\n\n\n#define ZERO min(iTime,0.)\n#define PI 3.1415927\n\n// Smoothed union\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\nvec4 smin(vec4 a, vec4 b, float k) {\n    float h = clamp(.5 + .5 * (b.x - a.x) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// SDF of the body of the sea cucumber\nfloat mapBody(vec3 p) {\n    //return length(p)-3.2;\n    //return length(vec2(length(p.xz)-3., p.y))-1.;\n    p += vec3(-0.45, .5*sin(.5*p.x)*sin(1.2*iTime-.3)+1., .2);\n    p.z *= 1.1;\n    float d1 = length(p-vec3(3,-0.5,0))-1.4;\n    float d2 = length(p-vec3(2,1.5,0))-1.3;\n    float d3 = length(p-vec3(0,2.8,0))-1.0;\n    float d4 = length(p-vec3(-2,1.8,0.2))-1.2;\n    float d5 = length(p-vec3(-2.8,0.3,0.5))-1.1;\n    float d6 = length(p-vec3(-4.5,-0.9,1))-0.6;\n    float d = smin(smin(smin(d1,d2,1.),smin(d4,d5,1.),1.),min(d3,d6),2.);\n    return d + .1*sin(.5*p.x)*cos(iTime);\n}\nvec3 mapBodyGrad(vec3 p, float h) {\n\tfloat a = mapBody(p+vec3(h,h,h));\n\tfloat b = mapBody(p+vec3(h,-h,-h));\n\tfloat c = mapBody(p+vec3(-h,h,-h));\n\tfloat d = mapBody(p+vec3(-h,-h,h));\n\treturn (.25/h)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n// Cucumber with fake spines, for fast shadow/AO calculations\nfloat mapFakeCucumber(vec3 p) {\n    return mapBody(p)-0.2 + \\\n      0.5*sin(3.*p.x)*sin(3.*p.y)*sin(3.*p.z);\n}\n\n// SDF of the spine\nfloat mapSpine(vec3 p) {\n    float tooth = 2.*dot(p.xy,p.xy)*sin(5.*atan(p.y,p.x));  // barnacle?\n    float spine = 3.*sqrt(dot(p.xy,p.xy)+1e-3)-0.5;  // like that of a sea cucumber\n    p.z += mix(spine, tooth, pow(.5-.5*cos(3.*iTime+2.*p.x),2.));\n    return length(p)-0.5;\n}\n\n// Find the point that the spine grows on.\n// Find the closest point within integer grid cells, with continuity.\nvec3 hash33(vec3 p3) {\n    // https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec3 closestGrid(vec3 p, vec3 n, out float wt) {\n    vec3 pc = round(p);\n    vec4 se = vec4(0); // used to perform smoothed minimum\n    vec3 wdg = vec3(0); // ∂[se.x]/∂p\n    for (float i=ZERO-1.; i<=1.; i++)\n      for (float j=ZERO-1.; j<=1.; j++)\n        for (float k=ZERO-1.; k<=1.; k++)  // iterate through neighbor grids\n    {\n        vec3 gc = pc+vec3(i,j,k);\n        gc += .3*(hash33(gc)-.5);  // make it not that regular\n        float d = dot(gc-p,gc-p);  // choose the point with minimum this but smoothed\n        vec3 p = gc-dot(gc-p, n)*n;  // project on plane\n        const float ks = 10.; // smoothing coefficient\n        se += exp(-ks*d)*vec4(1,p); // smoothed minimum\n        wdg += exp(-ks*d)*ks*(gc-p);  // ∂d/∂p\n    }\n    wt = smoothstep(0.,1.,2.*pow(dot(wdg,wdg), .6)); // lerp coefficient to supress \"ridges\"\n    return se.yzw/se.x;  // exponential smoothed minimum\n}\n\n// Model the sea cucumber\nvec4 mapCucumber(vec3 p) {\n    // sample value\n    float bv = mapBody(p);\n    vec3 bg = mapBodyGrad(p, .2);\n    if (bv > 1.) return vec4(bv);\n\n    // spine coordinate axes\n    vec3 w = normalize(bg);\n    vec3 u = vec3(1,0,0); u=normalize(u-dot(u,w)*w);\n    vec3 v = cross(w, u);\n\n    // fun part\n    vec3 q0 = p - bv*bg/dot(bg,bg); // closest point on the cucumber\n    float wt;\n    q0 = closestGrid(q0, w, wt);  // origin, where the spine grows on\n    vec3 q = p-q0;\n    q = vec3(dot(q,u),dot(q,v),dot(q,w));  // a point in spine coordinates\n\n    // sample spines\n    float tv = mapSpine(q);\n    tv = mix(bv, tv, wt);  // no spine between spines\n    vec4 d = smin(vec4(bv,.2,.1,.2),vec4(tv,.8,.6,.4), .5);  // combine body and spines\n    d.x += .007*sin(20.*p.x)*sin(20.*p.y)*sin(20.*p.z);\n    return d;\n}\nvec3 mapCucumberGrad(vec3 p) {\n    // https://iquilezles.org/articles/normalsSDF/\n    const float h = .001;\n    vec3 n = vec3(0);\n    for(int i=int(ZERO); i<4; i++) {\n        vec3 e = 2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.;\n        n += e*mapCucumber(p+e*h).x;\n    }\n    return n*(.25/h);\n}\n\n\n// Model the beach, returns height\nfloat mapBeach(vec2 p) {\n    vec2 q = .1*p;\n    float tot=-1.;\n    for (float i=0.; i<3.; i++) {\n        q = mat2(1.5,-1.,1.,1.5)*q-vec2(i);\n        tot += -.4*pow(.4,i)*cos(q.x)*cos(q.y);\n    }\n    tot += .005*texture(iChannel0, .06*p).x;\n    tot += .004*texture(iChannel0, .12*p).x;\n    float cum = mapBody(vec3(p,-1.))-.2;\n    tot += 0.2*tanh(cum);\n    tot += .1*sin(4.*p.x)*sin(4.*p.y)*exp(-8.*cum*cum);\n    return tot;\n}\n\n// https://www.shadertoy.com/view/Nt2yW3\nfloat intersectBeach(vec3 ro, vec3 rd, float tf) {\n    float t = 0.1;\n    float v0 = 0., v, dt;\n    for (int i = int(ZERO); i < 64; i++) {  // raymarching\n        if (t>tf) return -1.;\n        vec3 p = ro+rd*t;\n        v = p.z-mapBeach(p.xy);\n        v = mix(v, max(v-1.,0.), .5);  // smaller step when closer\n        if (v*v0 < 0.0) break;\n        dt = i==int(ZERO)?v:dt*v/abs(v-v0); // divide by line derivative\n        dt = sign(dt)*clamp(abs(dt), 0.05, 2.5);\n        t += dt, v0 = v;\n    }\n    t -= dt * clamp(v/(v-v0), 0., 1.); // linear interpolation\n    return t;\n}\n\n\n// Bounding box intersection\n// calculates near and far intersections, returns true if intersects\nbool cucumberBound(vec3 ro, vec3 rd, out float t0, inout float t1) {\n    vec3 inv_rd = 1./rd;\n    vec3 n = inv_rd*ro, k = abs(inv_rd)*vec3(6,4,2.5);\n    vec3 s1 = -n - k, s2 = -n + k;\n    t0 = max( max( s1.x, s1.y ), s1.z );\n    t1 = min(t1, min( min( s2.x, s2.y ), s2.z ) );\n    return !(t0>t1 || t1<0.);\n}\n\n// Intersecting the sea cucumber\nfloat intersectCucumber(vec3 ro, vec3 rd, float tf) {\n    // check bounding box\n    float t0, t1=tf;\n    if (!cucumberBound(ro, rd, t0, t1)) return -1.;\n    // raymarching\n    float t = t0, v0;\n    for (int i=int(ZERO); i<64; i++) {\n        float v = mapCucumber(ro+rd*t).x;\n        v = mix(v, max(v-1.,0.), .5);  // smaller step when closer\n        if (v<0.) {\n            t -= max(v0,0.05) * v / (v - v0);\n            break;\n        }\n        if (t>t1) return -1.;\n        t += max(v,.05);\n        v0 = v;\n    }\n    return t;\n}\n\n// Test if a ray is occluded by the sea cucumber\nbool occludeCucumber(vec3 ro, vec3 rd) {\n    float t0, t1=10.;\n    if (!cucumberBound(ro, rd, t0, t1)) return false;\n    float t = t0;\n    for (int i=int(ZERO); i<16; i++) {\n        if (t>t1) return false;\n        float v = mapFakeCucumber(ro+rd*t);\n        if (v<0.) return true;\n        t += max(v, 0.5);\n    }\n    return false;\n}\n\n// Ambiant occlusion\nfloat calcAO(vec3 p, vec3 n) {\n    float tot = 0.0;\n    for (float t=.05; t<1.; t+=.2) {\n        vec3 q = p+n*t;\n        float v = min(mapFakeCucumber(q), q.z+1.);\n        tot += .2*v*exp(-.5*t);\n    }\n    return .3+.7*exp(4.*smin(tot,0.,.2));\n}\n\n// Sky color\nconst vec3 sundir = normalize(vec3(-1, 1, 1));\nvec3 getSky(vec3 rd) {\n    rd.z = max(rd.z,0.);\n    vec3 base = mix(vec3(0.5,0.6,0.7), vec3(0.2,0.5,0.8), pow(rd.z,.5));\n    vec3 sun = 1.*vec3(1,0.85,0.65)*pow(max(dot(sundir,rd),0.), 8.);\n    return base + sun;\n}\n\n// Shading\nvec3 render(vec3 ro, vec3 rd) {\n    float tb = intersectBeach(ro, rd, 100.);\n    float tc = intersectCucumber(ro, rd, tb<0.?100.:tb);\n    \n    vec3 col, albedo, p, n, refl;\n    \n    // shade beach\n    if (tc < 0.) {\n        if (tb<0.) return getSky(rd);\n        p = ro+rd*tb;\n        vec2 g = vec2(\n            mapBeach(p.xy+vec2(.01,0))-mapBeach(p.xy-vec2(.01,0)),\n            mapBeach(p.xy+vec2(0,.01))-mapBeach(p.xy-vec2(0,.01)) )/.02;\n        n = normalize(vec3(-g, 1.));\n        refl = reflect(rd, n);\n        albedo = mix(vec3(0.8,0.7,0.6),vec3(0.9,0.8,0.6),smoothstep(-1.5,-0.5,p.z));\n        albedo *= vec3(0.8,0.7,0.7);\n        vec3 amb = albedo * 0.4;\n        vec3 dif = albedo * max(n.z,0.) * 0.5*vec3(0.5,0.6,0.7);\n        vec3 spc = albedo * 0.1*pow(max(dot(refl,sundir),0.),1.5);\n        vec3 rfl = getSky(refl) * (occludeCucumber(p,refl) ? 0. : 0.2);\n        col = amb+dif+spc+rfl;\n        col = mix(col, getSky(rd), smoothstep(.65,.2,exp(-.01*tb)));\n    }\n\n    // shade sea cucumber\n    else {\n        p = ro+rd*tc;\n        albedo = mapCucumber(p).yzw;\n        n = normalize(mapCucumberGrad(p));\n        refl = reflect(rd, n);\n        vec3 amb = albedo * 0.2;\n        vec3 dif = albedo * max(n.z,0.) * 0.4*vec3(0.5,0.6,0.7);\n        vec3 spc = albedo * 0.1*pow(max(dot(refl,sundir),0.),1.5);\n        vec3 rfl = getSky(refl)*0.1;\n        col = amb+dif+spc+rfl;\n    }\n\n    // AO + haze + adjustment\n    col *= pow(calcAO(p, n), tc<0.?1.5:0.5);\n    col += .2*vec3(1,0.5,0.5)*pow(max(dot(rd,sundir),0.),5.);\n    col = max(1.2*col-0.1, vec3(.01));\n    return col;\n}\n\n// Camera setup + Gamma\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float rx = iMouse.x>0.?.5*PI*(iMouse.y/iResolution.y):0.3;\n    float rz = iMouse.x>0.?-iMouse.x/iResolution.x*4.*PI:-1.2;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u=vec3(-sin(rz),cos(rz),0);\n    vec3 v=cross(w,u);\n\n    vec3 ro = vec3(0) + 25.*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution));\n\n    vec3 col = render(ro, normalize(rd));\n    fragColor = vec4(pow(col, vec3(.4545)), 1);\n}\n","name":"Image","description":"","type":"image"}]}