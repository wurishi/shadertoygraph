{"ver":"0.1","info":{"id":"Xtt3Df","date":"1472130360","viewed":178,"name":"Raymarching Demo","username":"Crow","description":"references: https://www.shadertoy.com/view/Xds3zN\n               https://zhuanlan.zhihu.com/p/20091064","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n\nfloat SdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat SdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat SdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nfloat SdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 OpU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat OpS( float d1, float d2 )\n{\n    return max(-d2, d1);\n}\n\nvec2 Map( vec3 pos )\n{\n    vec2 res = vec2(SdPlane(pos), 1.0);    \n    res = OpU( res, vec2(SdCylinder(pos - vec3(0, 0.1, 0), vec2(0.65, 0.06)), 2.0));\n    res = OpU( res, vec2(SdSphere(pos - vec3(0, 1.15, 0), 0.75), 2.0));\n    \n    res = OpU( res, vec2(OpS(SdBox(pos - vec3(0, 0.06, 0), vec3(0.8, 0.06, 0.8)),   \n                            SdCylinder(pos - vec3(0, 0.1, 0), vec2(0.66, 0.065))), 3.0));\n    \n    res = OpU( res, vec2(OpS(SdSphere(pos - vec3(0, 1.15, 0), 1.0), \n                             OpU(vec2(SdSphere(pos - vec3(0, 1.15, 0), 0.77), 3.0), \n                                 vec2(SdSphere(pos - vec3(0.7, 1.6, 0.7), 0.7), 3.0)).x), 3.0));\n\n    return res;\n}\n\nvec2 CastRay( vec3 camPos, vec3 rayDir )\n{\n    float nearClip = 0.1;\n    float farClip = 10.0;\n    \n    float dis = nearClip;\n    float mat = -1.0;\n    for(int i = 0; i < 50; i++)\n    {\n\t    vec2 res = Map(camPos + rayDir * dis);\n        if(res.x < 0.001) \n            break;\n        \n        dis += res.x;\n        mat = res.y;\n        if(dis >= farClip)\n        {\n            dis = farClip;\n            mat = -1.0;\n            break;\n        }\n    }\n    \n    return vec2(dis, mat);\n}\n\n//---material--------------------------------------------------\nstruct Mat\n{\n    vec3 basCol;\n    float rou;    \n    float spe;\n};\n\nMat CreateMat( vec3 basCol, float rou, float spe)\n{\n    Mat mat;\n    mat.basCol = basCol;\n    mat.rou = rou;\n    mat.spe = spe;\n    return mat;\n}\n\nMat GetMat( vec3 pos, float matNumber )\n{\n    if(matNumber < 1.5)\n    {\n        return CreateMat(vec3(1.0, 1.0, 1.0), 0.9, 0.1);\n    }\n    else if(matNumber < 2.5)\n    {\n        return CreateMat(vec3(0.1, 0.1, 0.1), 1.0, 0.01);\n    }\n    else if(matNumber < 3.5)\n    {\n        float n = step(0.3, mod(pos.x, 0.6));\n        return CreateMat(n * vec3(0.2) + vec3(0.0, 0.3, 0.7), (1.0 - n) * 0.8 + 0.1, n * 0.5 + 0.2);\n    }\n}\n\n//---render-------------------------------------------------\nvec3 GetNormal( vec3 pos )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(Map(pos + eps.xyy).x - Map(pos - eps.xyy).x,\n                    Map(pos + eps.yxy).x - Map(pos - eps.yxy).x,\n                    Map(pos + eps.yyx).x - Map(pos - eps.yyx).x );\n\treturn normalize(nor); \n}\n\nfloat GetAO( vec3 pos, vec3 nor, float bas, float step)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float hr = bas + step * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = Map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);    \n}\n\nfloat GetShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 20; i++)\n    {\n\t\tfloat h = Map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > maxt) \n            break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat DisneyDiffuse( float lh, float nl, float nv, float roughness )\n{\n    float oneMinusCosL = 1.0 - nl;\n    float oneMinusCosV = 1.0 - nv;\n    \n    float F_D90 = 0.5 + 2.0 * lh * lh * roughness;\n\n    return (1.0 + (F_D90 - 1.0) * pow(oneMinusCosL, 5.0)) *\n\t\t(1.0 + (F_D90 - 1.0) * pow(oneMinusCosV, 5.0)) / PI;\n}\n\nfloat FresnelSchlick( float inCosine, float normalReflectance )\n{\n    float oneMinusCos = 1.0 - inCosine;\n\tfloat fresnel = normalReflectance + (1.0 - normalReflectance) * pow(oneMinusCos, 5.0);\n\treturn fresnel;\n}\n\nfloat GGX_D( float nh, float roughness )\n{\n\tfloat root = roughness / (nh * nh * (roughness * roughness - 1.0) + 1.0);\n\treturn root * root / PI;\n}\n\nfloat SmithG1( float nDotV, float k )\n{\n    return nDotV / (nDotV * (1.0 - k) + k); \n}\n\nfloat Smith_G( float nl, float nv, float roughness )\n{\n    float k = roughness / 2.0;\n    return SmithG1(nl, k) * SmithG1(nv, k);\n} \n\nvec3 Render( vec3 camPos, vec3 rayDir )\n{    \n    vec3 lightDir = normalize(vec3(-1.3, -1.0, -0.7));\n    vec3 lightCol = vec3(1.0, 1.0, 1.0);     \n    vec3 amb = vec3(0.2, 0.2, 0.2);\n    \n    vec3 col;    \n    vec3 pos = camPos;\n        \n    vec2 res = CastRay(pos, rayDir);\n    float dis = res.x;\n    float m = res.y;     \n    if(m > 0.0)\n    {\n        pos += rayDir * dis;\n        Mat mat = GetMat(pos, m);\n\n        vec3 nor = GetNormal(pos);\n        float occ = GetAO(pos, nor, 0.01, 0.07);\n        float shadow = GetShadow(pos, -lightDir, 0.01, 10.0);\n        \n        vec3 viewDir = -rayDir;\n        lightDir = -lightDir;\n        \n        float nl = max(dot(nor, lightDir), 0.0);\n        float nv = max(dot(nor, viewDir), 0.0);\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float nh = max(dot(nor, halfDir), 0.0);\n        float lh = max(dot(lightDir, halfDir), 0.0);\n        vec3 refDir = normalize(reflect(rayDir, nor));\n        \n        float diffuse = DisneyDiffuse(lh, nl, nv, mat.rou);\n            \n        float roughness = mat.rou * mat.rou;\n        float D = GGX_D(nh, roughness);\n        float G = Smith_G(nl, nv, roughness);\n        float F = FresnelSchlick(lh, mat.spe);\n        float specular = max((D * G * F) / (4.0 * nl * nv), 0.0);\n        \n        float ref = 1.0 - 0.28 * roughness * mat.rou;\n        vec3 refCol = mix(texture(iChannel0, refDir).rgb,\n                         texture(iChannel1, refDir).rgb,\n                         mat.rou);\n        float refF = FresnelSchlick(nv, mat.spe);\n        \n        col = ((mat.basCol * diffuse + specular) * lightCol * nl * shadow\n               + refCol * refF * ref\n               + mat.basCol * amb) * occ;\n    }\n    else\n    {\n        col = texture(iChannel0, rayDir).rgb;\n    }\n    \n    return col;\n}\n//--------------------------------------------------------\n\nmat3 SetCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 camPos = vec3(3.0 * cos(7.0 * mouse.x), 1.0 + 2.0 * mouse.y, 3.0 * sin(7.0 * mouse.x));\n    vec3 camLookAt = vec3(0.0, 1.0, 0.0);\n    \n    mat3 camMatrix = SetCamera(camPos, camLookAt, 0.0);\n    vec3 rayDir = normalize(camMatrix * vec3(p.xy, 1.5));\n    \n    vec3 col = Render(camPos, rayDir);\n\tcol = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}