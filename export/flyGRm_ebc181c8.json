{"ver":"0.1","info":{"id":"flyGRm","date":"1721460696","viewed":79,"name":"Fly around path trace","username":"jvb","description":"mouse look around\nW,A,S,D move camera\nSHIFT move faster\n","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["collision","detection","cubemap","bake"],"hasliked":0,"parentid":"7stGzX","parentname":"Bake PT cubemap"},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// mouse look around\n// W,A,S,D move camera\n// SHIFT move faster\n\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n\tvec3 color = vec3(0.0);  \n\tvec3 tex = vec3(0);\n    \n    vec3 pos = ro; \n    float dist = 0.0; \n    vec2 d = vec2(0); \n    for (int i = 0; i < 64; i++) {\n        d = scene(pos); \n        if (abs(d.x) < 0.0001) break; \n        pos += rd*d.x;\n    }\n    color = texture(iChannel2,pos.xyz).xyz; \n\treturn color; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy )-1.0;\n\n    vec3 color =  vec3(0);\n    vec3 campos = texelFetch(iChannel0,ivec2(0,0), 0).xyz;\n    vec3 ro, rd; \n    // persp\n\tp.x *= iResolution.x/iResolution.y; \n\tro = campos;\n\trd = normalize(vec3(p.x,p.y,-1.0)); \n    \n\tvec2 tmouse = vec2(iMouse.x*0.001,iMouse.y*0.001);\t\n    rd = rotatex(rd, -5.0+iMouse.y*0.02);\n    rd = rotatey(rd, -5.0+iMouse.x*0.02);\n    color = rm(ro,rd,iTime); \n\t#define GAMMA 1\n\t#if GAMMA\n\tcolor = pow(color,vec3(1.0/1.5));\n\t#endif\n    // Output to screen\n    fragColor = vec4(color, 1.0); \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\nfloat random(vec3 scale, float seed) { \n\treturn fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed); \n} \n\nvec3 cosineWeightedDirection(float seed, vec3 normal) {\n#if 0\n\tfloat a = 2.0*random(vec3(12.9898, 78.233, 151.7182), seed)-1.0; \n\tfloat b = 2.0*random(vec3(63.7264, 10.873, 623.6736), seed)-1.0; \n\tfloat c = sqrt(1.0-a*a);\n\tvec3 r = vec3(c*cos(b),a,c*sin(b)); \n\treturn dot(r,normal) > 0.0 ? r : -r; \n#else\n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat r = sqrt(u); \n\tfloat angle = 6.283185307179586 * v; \n\tvec3 sdir, tdir; \n\tif (abs(normal.x)<.5) { \n\t\tsdir = cross(normal, vec3(1,0,0)); \n\t} else { \n\t\tsdir = cross(normal, vec3(0,1,0)); \n\t} \n\ttdir = cross(normal, sdir); \n\treturn r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal; \n#endif\n} \n\nvec3 uniformlyRandomDirection(float seed) { \n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat z = 1.0 - 2.0 * u; float r = sqrt(1.0 - z * z); \n\tfloat angle = 6.283185307179586 * v; \n\treturn vec3(r * cos(angle), r * sin(angle), z); \n} \n\nvec3 uniformlyRandomVector(float seed) { \n\treturn uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed)); \n} \n\n\n\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n\tvec3 colorMask = vec3(1.0); \n\tvec3 color = vec3(0.0);  \n\tvec3 surfaceColor = vec3(0);\n\tvec3 tex = vec3(0);\n#define BOUNCES 3\n\tfor (int bounce = 0; bounce < BOUNCES; bounce++) {\n\t\tvec3 pos = ro; \n\t\tfloat dist = 0.0; \n\t\tvec2 d = vec2(0); \n\t\t\n\t\tif (bounce == 0) {\n            for (int i = 0; i < 64; i++) {\n                d = scene(pos); \n                if (abs(d.x) < 0.0001) break; \n                pos += rd*d.x;\n            }\n\t\t}\n\t\telse {\n            for (int i = 0; i < 64; i++) {\n                d = scene(pos); \n                if (abs(d.x) < 0.0001) break; \n                pos += rd*d.x;\n            }\t\t\t\n\t\t}\n        dist = length(pos-ro); \n\t\tif (dist < 10000.0 && abs(d.x) < 100.0) {\n\t\t\tfloat o = d.y;\n\t\t\tvec3 n = get_normal(pos); \n\t\t\tfloat shade = 1.0; //ambientOcclusion(pos+0.001*n, 1.0*n)*1.0;\n\n\t\t\t#define MULTISAMPLE_TEX 0\n\t\t\tif (true) {\n\t\t\t#if MULTISAMPLE_TEX\n\t\t\ttex = vec3(0);\n\t\t\t\tfor (int i = 0; i < 16; i++) {\n\t\t\t\t\tfloat AA = 0.01; \n\t\t\t\t\ttex += get_tex(pos + AA*uniformlyRandomVector(float(time)+float(i))); \n\t\t\t\t}\n\t\t\t\ttex /= 16.0;\n\t\t\t#else\n\t\t\t\ttex = get_tex(pos); \n\t\t\t#endif\n\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\tif (d.y == 1.0) {\n\t\t\t\t// Light, luminance\n\t\t\t\tsurfaceColor =vec3(1,1,1)*100.0; \n\t\t\t}\n\t\t\telse if (d.y == 2.0) {\n\t\t\t\tsurfaceColor = vec3(1,0,0); \n\t\t\t}\n\t\t\telse if (d.y == 3.0) {\n                vec3 tex3 = vec3(0);\n                tex3 = texture(iChannel1, pos.yz*0.1).xyz*n.x; \n                tex3 += texture(iChannel1, pos.xz*0.1).xyz*n.y; \n                tex3 += texture(iChannel1, pos.xy*0.1).xyz*n.z; \n \t\t\t\tsurfaceColor = (tex)*vec3(1,1,1); \n\t\t\t\tcolorMask *= surfaceColor;\n                n += tex3; \n\t\t\t}\n\t\t\telse if (d.y == 4.0) {\n\t\t\t\tvec3 lightpos = vec3(10,0,-4); \n\t\t\t\tvec3 l = normalize(lightpos - pos);\n\t\t\t\tfloat diff = clamp(dot(n,l), 0.0,1.0);\n\t\t\t\tsurfaceColor = mix(vec3(1,1,1)*1.0,vec3(1,1,1)*1.1,diff);\n\t\t\t}\n\t\t\tif (bounce == 0) {\n\t\t\t\tcolorMask *= surfaceColor;\n\t\t\t\tcolor += 0.5*(shade*surfaceColor); //*colorMask; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolorMask *= surfaceColor;\n\t\t\t\tcolor += 0.5*(shade*surfaceColor)*clamp(dist*0.25,0.0,32.0); //*colorMask; \n\t\t\t}\n\t\t\tfloat refl = 0.0;\n\t\t            float rr = random(vec3(36.7539, 50.3658, 306.2759), time+float(bounce));\n\t\t            refl = clamp(refl*rr, 0.0, 1.0);\n\t\t\tro = pos+n*0.001; \n\t\t\tvec3 rd2 = reflect(rd, n); \n\t\t\trd = normalize(cosineWeightedDirection(time+float(bounce), n));\t\t\t\t\t\n\t\t\trd = normalize(mix(rd, rd2, refl));\n\t\t\t\n\t\t}\t\n\t}\n\treturn clamp(color, 0.0, 1.0); \n}\n\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 color = vec3(0); \n    \n    \n    if (iFrame < 100) {\n\n        #define SSAMPLES 1\n        for (int i = 0; i < SSAMPLES; i++) {\n            color += rm(ro, rd, iTime+float(i)); \n        }\n        color /= float(SSAMPLES);\n\n        // Output to cubemap\n        color = mix(color, texture(iChannel0, rd).xyz, 0.99); \n    }\n    else {\n        color = texture(iChannel0, rd).xyz; \n    \n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n\nvec3 rotatey(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.z*sin(ang),p.y,p.x*sin(ang)+p.z*cos(ang));  }\nvec3 rotatex(in vec3 p, float ang) { return vec3(p.x,p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang));  }\nvec3 rotatez(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang),p.z);  }\n\nvec2 sph(in vec3 p, float r, float o) { return vec2(length(p)-r, o); }\nvec2 rbox(in vec3 p, in vec3 b, float r, float o) { return vec2(length(max(abs(p)-b,0.0))-r, o); }\nvec2 sdbox( vec3 p, vec3 b, float o ) { vec3 d = abs(p) - b; return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o); }\nvec2 plane(in vec3 p, in vec3 n, float d, float o) { return vec2(dot(p,n)-d, o); }\n\nvec2 min2(in vec2 o1, in vec2 o2) { if (o1.x < o2.x) return o1; else return o2; }\nvec2 max2(in vec2 o1, in vec2 o2) { if (o1.x > o2.x) return o1; else return o2; }\nfloat lightgap = 1.0;\nvec2 scene(in vec3 p)\t\n{\n\tvec2 d = vec2(1000.0, 0);     \n   \td = min2(d, vec2(-1,1)*sdbox(p-vec3(0,0,0), vec3(6,2,8),3.0));\t\n\td = max2(d, vec2(-1,1)*sdbox(p-vec3(0,-2,0), vec3(5,1,7),3.0));\t\n\td = max2(d, vec2(-1,1)*sdbox(p-vec3(0,-2,0), vec3(4,2,2),3.0));\t\n\n    return d; \n}\n\nvec3 get_tex(in vec3 p)\n{\n\tvec3 col = vec3(0.0);\n    if (p.x < -5.999 && abs(p.z+p.y+4.0) < 2.0) col += vec3(25);\n    if (p.x < -5.999 && abs(p.z-p.y-4.0) < 2.0) col += vec3(25);\t\n\treturn col*0.5;\n}\nvec3 get_normal(in vec3 p)\n{\n\tvec3 eps = vec3(0.001, 0, 0); \n\tfloat nx = scene(p + eps.xyy).x - scene(p - eps.xyy).x; \n\tfloat ny = scene(p + eps.yxy).x - scene(p - eps.yxy).x; \n\tfloat nz = scene(p + eps.yyx).x - scene(p - eps.yyx).x; \n\treturn normalize(vec3(nx,ny,nz)); \n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    vec3 campos = texelFetch(iChannel0,ivec2(0,0), 0).xyz;\n   // fly controls\n    const int KEY_W = 87;\n    const int KEY_A = 68;\n    const int KEY_S = 83;\n    const int KEY_D = 65;\n    const int KEY_Q = 81;\n    const int KEY_E = 69;\n    const int KEY_SHIFT = 0x10;\n    vec3 vel = vec3(0);\n    if (texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x > 0.0) { vel += vec3(0,0,-1); }\n    if (texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x > 0.0) { vel += vec3(1,0,0); }\n    if (texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x > 0.0) { vel += vec3(0,0,1); }\n    if (texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x > 0.0) { vel += vec3(-1,0,0); }\n    if (texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x > 0.0) { vel += vec3(0,+1,0); }\n    if (texelFetch(iChannel1, ivec2(KEY_E, 0), 0).x > 0.0) { vel += vec3(0,-1,0); }\n    vel = rotatex(vel, -5.0+iMouse.y*0.02);\n    vel = rotatey(vel, -5.0+iMouse.x*0.02);\n    vec3 prevpos = campos;\n    if (texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).x > 0.0) {\n        vel *= 2.0;\n    }\n    campos +=vel*iTimeDelta*2.5;\n#define COLLISION_DETECTION 1\n#if COLLISION_DETECTION\n    if (scene(campos).x < 0.1) {\n        campos = prevpos+get_normal(campos)*0.001;\n    }\n#endif\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n        color = campos;\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}