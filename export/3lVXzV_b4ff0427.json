{"ver":"0.1","info":{"id":"3lVXzV","date":"1586618946","viewed":52,"name":"Raycast testing 314","username":"josepp14","description":"For raycast testing\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VEC3_MAX vec3(1e20,1e20,1e20)\n#define VEC3_NULL vec3(0.,0.,0.) // Also works as black\n\n\n\n\nstruct CAMERA\n{\n    vec3 pos;\n    vec3 lookat;\n\tfloat focal_length;\n    \n    vec3 Forward; // Same as Lookat but specifically normalized\n    vec3 Right;\n    vec3 Up;\n};  \n\nvec3 Plane = vec3(0.0, -1.0,0.0);\nvec3 SphereCenter = vec3(1.0, 0.0, 0.0);\nfloat SphereRadius = 0.5;\n\nvoid SetupCamFromFocalLength(out CAMERA cam, in float focal_length, vec3 expected_pos)\n{\n    // at focal Length 1., at distance sqrt(3), object of size .2 is .6\n    \n    float ratio = 1. / 50.;\n    cam.focal_length = focal_length*ratio;\n    \n    cam.pos = expected_pos*(focal_length/10.);\n    \n    // Camera is set to (0,0,0)\n    cam.lookat = VEC3_NULL;\n}\n\nvec3 ex2(in vec2 fragCoord)\n{    \n   \tCAMERA cam;\n    \n    // Color variable for use instead of ruining directly fragColor\n\tvec3 color = vec3(0.0,0.0,0.0);\n    \n    // 1 - Setup Camera    \n    SetupCamFromFocalLength(cam, 50., vec3(1.,2.,1.));\n    \n    // 1.2 - Camera Animation\n    // Camera rotates around center at the expected distance calculated with the previous fucntion\n    cam.pos *= vec3(sin(iTime/10.),.1,cos(iTime/10.));\n    cam.pos *= vec3(1., abs(sin(iTime/5.)), 1.);\n    //cam.pos *= vec3(0., 1., 0.);\n    \n    \n    // Imagine F to be parallel to z and x vector = Perpendicular to Y\n    // We generate Right vector with this, then the real Up Vector\n    // cross product between 2 vectors returns a perpendicular one always\n    cam.Forward = normalize(cam.lookat - cam.pos);\n    cam.Right \t= cross(vec3(0.,1.,0.), cam.Forward);\n    cam.Up\t\t= cross(cam.Forward, cam.Right);    \n    \n    // 2 - Calculate Center of the screen\n    vec3 center = cam.pos + cam.Forward * cam.focal_length;\n    \n    // We calculate initial World Coordinate from screen\n    vec3 world_coord = vec3((fragCoord - (iResolution.xy / 2.)) / iResolution.y, 0.);\n\t\n    // Transform it according to the Camera\n    vec3 coord = center + world_coord.x*cam.Right + world_coord.y * cam.Up;\n\n    // 3 - Start raying\n    vec3 raycastDir = normalize(coord - cam.pos);\n        \n    \n    //Plane Grey\n    float t = -cam.pos.y+Plane.y/raycastDir.y;\n    \n    Plane.x = cam.pos.x+t*raycastDir.x;\n    Plane.z = cam.pos.z+t*raycastDir.z;\n    \n    vec3 blue = vec3(0.0,0.5,0.5);\n    vec3 white = vec3(1.0,1.0,1.0);\n    \n    \n    if (t > 0.0)\n    {\n        color = vec3(0.9,0.9,0.9);\n    }\n    else\n    {\n        color = mix(white,blue,coord.y);\n    }\n    \n    //Sphere                \n    // d = Ray Direction\n    \n       \n    // Calculate OC\n    vec3 OC = SphereCenter-cam.pos;\n    \n    //Get t_OCD with OC(L) projected in direction (D)   \n    float t_OCD = dot(raycastDir,OC);\n    if (t_OCD < 0.) return color;\n    \n    //Pythagorean theorem h^2 = co^2 + cc^2 -> co^2 = h^2 - cc^2 -> co = sqrt(h^2-cc^2) -> distance_oc_ocd = sqrt(OC^2-t_OCD^2)     \n    float distance_OC_OCD = dot(OC,OC) - t_OCD*t_OCD;\n    \n    float t_OC_OCD_R = sqrt(pow(SphereRadius,2.) - pow(distance_OC_OCD,2.0));\n    if (t_OC_OCD_R > SphereRadius) return color;\n    \n    vec3 intersection1 = (t_OCD - t_OC_OCD_R)*raycastDir + cam.pos;\n    vec3 intersection2 = (t_OCD + t_OC_OCD_R)*raycastDir + cam.pos;\n    \n    if(length(intersection1 - cam.pos) < length(intersection2 - cam.pos) && (t_OCD - t_OC_OCD_R) > 0.)\n    {\n        \n        return color = vec3(1.0,0.0,0.0);\n    }\n    \n    if(length(intersection2 - cam.pos) < length(intersection1 - cam.pos) && (t_OCD + t_OC_OCD_R) > 0.)\n    {\n        return color = vec3(0.0,1.0,0.0);\n    }    \n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 color = ex2(fragCoord);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}