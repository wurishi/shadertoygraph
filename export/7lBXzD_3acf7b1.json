{"ver":"0.1","info":{"id":"7lBXzD","date":"1627189039","viewed":72,"name":"CellularNoise","username":"hyperang","description":"Cellular Noise, Worley Noise","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float scale = 5.;\nfloat speed = 0.5;\n\n// hash function\nvec2 hash(vec2 p)\n{\n\tp = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= scale;\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    float m_dist = 1.;\n    \n    for(int i=-1;i<=1;i++)\n    {\n        for(int j=-1;j<=1;j++)\n        {\n            // neighbor grid's place\n            vec2 neighbor = vec2(float(i),float(j));\n            \n            // random point position (in one of the current pixel's 9 grids)\n            vec2 point = hash(i_uv+neighbor);\n            \n            // animate point\n            point = 0.5+0.5*sin(speed*(iTime+6.2831*point));\n            \n            // distance (current pixel is in the center grid)\n            float dist = length(neighbor+point-f_uv);\n            \n            m_dist = min(m_dist,dist);\n        }\n    }\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col *= m_dist;\n    \n    // draw grids\n    //if(f_uv.x < 0.002*scale || f_uv.y < 0.002*scale)\n        //col = vec3(0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}