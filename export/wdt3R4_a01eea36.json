{"ver":"0.1","info":{"id":"wdt3R4","date":"1592133116","viewed":267,"name":"SftM Wallpaper Fork","username":"slerpy","description":"That one scene from Shoot for the Moon, but with proper depth of field.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["intro","4k","demoscene","dof","fork","wallpaper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Shoot For The Moon\" by slerpy\n// https://shadertoy.com/view/Md3Bzf\n// 2019-09-08 21:01:20\n\nvec3 aberrationColor(float f)\n{\n    f = f * 3.0 - 1.5;\n    return clamp(vec3(-f,1.0-abs(f),f),0.,1.);\n}\n\nvec4 chromab(vec2 u)\n{\n    u -= .5;\n    float f = 1.;\n    vec4 acc = vec4(0), wb = vec4(0);\n    for(int i=0; i<50; i++)\n    {\n        u *= .9998;\n        vec4 smp = texture(iChannel0, u+.5);\n        vec4 ca = vec4(aberrationColor(float(i)/50.), 1);\n        \n        acc += ca * smp;\n        wb += ca;\n    }\n    \n    return acc / wb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    vec2 u = fragCoord / iResolution.xy.xy;\n    if(2.39 * abs(u.y-0.5) > 1.)return;\n    \n    vec4 acc = chromab(u);\n    for(float i=4.; i<8.; i++)\n        acc += textureLod(iChannel0, u, i) / (i * i);\n    \n    fragColor = acc / acc.w;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU 6.28318530718\n#define PI 3.14159265359\n\nvec3 R;\n\nvec3 g, s;\nint scene;\n\nmat3 rx(float a){ float s=sin(a), c=cos(a); return mat3(1,0,0,0,c,s,0,-s,c); }\nmat3 ry(float a){ float s=sin(a), c=cos(a); return mat3(c,0,s,0,1,0,-s,0,c); }\nmat3 rz(float a){ float s=sin(a), c=cos(a); return mat3(c,s,0,-s,c,0,0,0,1); }\n\nfloat box(vec3 p){return max(max(p.x,p.y),p.z);}\nfloat box(vec2 p){return max(p.x,p.y);}\n\n#define sround(X) (floor(X) + smoothstep(.4, .6, fract(X)))\n\nvoid amod(inout vec2 p, float m)\n{\n    float a=mod(atan(p.x, p.y), m)-m/2.;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p); p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p*=p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat apollonian(vec3 p, float s)\n{\n\tfloat scale = .5;\n\tfor( int i=0; i<5;i++ )\n\t{\n\t\tp = -1.0+2.0*fract(0.5*p+0.5);\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = s/r2;\n\t\tp *= k, scale *= k;\n\t}\n\treturn abs(p.y)/scale;\n}\n\nvoid light(vec3 col, float d)\n{\n    g += col * pow(d + 1., -2.);\n}\n\nfloat map(vec3 p)\n{\n    float d = 1e+31; g -= g;\n    \n    // scene distance function\n    \n    vec3 q = (p + 7. * vec3(1, 0, 3)) * ry(.25*PI);\n    q.y += sround(noise(q.xzx));\n    d = apollonian(.1*q-1., 1.3);\n    //d += .00083 * sin(4.*R.z);\n    light(vec3(1.), (10.-abs(p.y)) * 16.);\n    g += .03 * noise(q.xzx);\n    \n    // ship distance function\n    \n    const float s = .5;\n    \n\tq = p; amod(q.yz, TAU/6.);\n    float ship = abs(q.x) + s*abs(q.y) - s; // main shape\n    ship = max(.5*ship, -p.z-radians(30.)*abs(p.y)); // back\n    \n    float win = ship + .03;\n    ship = min(win, max(ship, min(p.z-p.y-.1, p.y-.2))); // window\n    light(-g, 10.*win);\n    \n    float thr = box(abs(p)-vec3(.4-s*abs(p.y), .4, .45)) + .05*noise(20.*p.xyx);\n    ship = min(ship, max(p.z, .7*thr) ); // thruster\n    \n    d = min(d, ship);\n    \n    float beam = max(p.z+.5, length(p.xy)-.25); // beam\n    \n    light(vec3(0,1,2), 8.*beam);\n    d = min(d, beam);\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(0, 0.001);\n\treturn normalize(vec3(map(p+e.yxx), map(p+e.xyx), map(p+e.xxy)) - map(p));\n}\n\nfloat tracer(vec3 ro, vec3 rd, int iter)\n{\n    s -= s;\n    float t = .01, m;\n    for(int i=0; i < iter; i++)\n    {\n        t += m = map(ro + rd * t), s += g * m;\n        if(m < 1e-3)break;\n    }\n    s = g + 0.1 * s;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = vec3(iResolution.xy, iTime);\n    \n    vec4 last = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n#if 1\n    int seg = int(4.*fragCoord.x / R.x);\n    if(seg != iFrame % 4)\n    {\n        fragColor = last;\n        return;\n    }\n#endif\n    \n    //fragCoord = (fragCoord - vec2(0, .9*R.y) - .5*R.xy)/3. + .5*R.xy;\n    //fragCoord = fragCoord / 4. + (.5-.5/4.)*R.xy;\n    \n    // camera setup\n    \n    vec4 rv = vec4(fragCoord, iFrame, 1) - last;\n    for(int i=0; i<8; i++)rv = fract(1e4*sin(rv) + rv.wxyz);\n    \n    vec2 aa = rv.xy - .5;\n    \n    vec3 rd = normalize(vec3(fragCoord.xy + aa - .5*R.xy, R.y));\n    vec3 ro = vec3(0, 0, -32);\n    \n    rv = fract(1e4*sin(rv) + rv.wxyz);\n    vec2 dof = rv.xy - rv.zw;\n    \n    rd.xy += dof / length(ro);\n    ro.xy -= dof;\n    \n    mat3 rm = ry(PI/2.) * rz(-.05);\n    ro *= rm, rd *= rm;\n    \n    \n    // first trace\n    \n    float tr = tracer(ro, rd, 250);\n\tvec3 sp = ro + rd * tr;\n\tvec3 sn = normal(sp);\n    vec3 emit = s;\n    \n    // debug\n    \n    #if(0)\n    fragColor = last;\n    vec3 col = 0.5 + 0.5 * normalize(sn);\n    if(!any(isnan(col)))fragColor += vec4(col, 1);\n    return;\n    #endif\n    \n    // reflection\n    \n    vec3 rd2 = reflect(rd, sn), ro2 = sp;\n    float tr2 = tracer(ro2, rd2, 50);\n    emit += g;\n    \n    // color\n    \n    fragColor = clamp(vec4(emit, 1), vec4(0), vec4(1)) + last;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}