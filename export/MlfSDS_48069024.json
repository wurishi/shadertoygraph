{"ver":"0.1","info":{"id":"MlfSDS","date":"1439415459","viewed":888,"name":"star1","username":"aldroid","description":"figuring out how to draw a starry rainbow","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dir(vec2 a, vec2 b, vec2 c)\n{\n\treturn (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\n}\n\n\nbool insideTri(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tbool b1 = dir(p, a, b) < 0.0;\n\tbool b2 = dir(p, b, c) < 0.0;\n\tbool b3 = dir(p, c, a) < 0.0;\n  \treturn ((b1 == b2) && (b2 == b3));\n}\n\nvoid applyColor(vec3 paint, inout vec3 col, vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tif (insideTri(p, a, b, c)) col = mix(col, paint, 0.4);\n}\n\nvoid rotate(inout vec2 point, float r) {\n    point = vec2(point.x*sin(r) +point.y*cos(r), point.x*cos(r)- point.y*sin(r));\n}\n\n\nfloat PI = 3.14159265358979323846264;\n\nvoid drawTri(vec2 offset1, vec2 offset2, float size, float rotation, vec3 triColour, inout vec3 col, vec2 pos) {\n    float oneThirdPhase = PI*2.0/3.0;\n    float twoThirdPhase = PI*4.0/3.0;\n    vec2 triTop = vec2(0, 1) * size + offset1;\n    vec2 triBL = vec2(sin(oneThirdPhase),cos(oneThirdPhase)) * size + offset1;\n    vec2 triBR = vec2(sin(twoThirdPhase),cos(twoThirdPhase)) * size + offset1;\n    rotate(triTop, rotation);\n    rotate(triBL, rotation);\n    rotate(triBR, rotation);\n    applyColor(triColour, col, pos, triTop + offset2, triBL+offset2, triBR+ offset2);\n}\n\n\nvoid drawStar(vec2 offset, float size, float rotation, vec3 triColour, inout vec3 col, vec2 pos) {\n    vec2 topTriOff = offset;\n    vec2 bottomTriOff = offset;\n    float topTriRot = PI + rotation;\n    float bottomTriRot = rotation;\n    drawTri(vec2(0), topTriOff, size, topTriRot, triColour, col, pos);\n    drawTri(vec2(0), bottomTriOff, size, bottomTriRot, triColour, col, pos);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid drawCircle(vec2 offset, float rad2, vec3 circColour, inout vec3 col, vec2 pos) {\n    if (length(offset-pos)<rad2) {\n        col = mix(col, circColour, 0.52);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor.rgb = vec3(0.75,0.8,1.0);\n    vec3 starColourHSV = vec3(0,1,1);\n    float starheight = 0.0;\n    for (int i=0; i<100; ++i) {\n        starheight = rand(vec2(float(i),5.0));\n        starColourHSV.x = 0.9-starheight;\n\t    drawStar(vec2(0.1+mod((float(i)+iTime)/12.0,0.8), 0.1+starheight/8.0+sin(uv.x*PI)/4.0), 0.03, iTime+rand(vec2(float(i),3)), hsv2rgb(starColourHSV),fragColor.rgb, fragCoord.xy/iResolution.x);\n    }\n    \n    for (int i = 0; i < 10; ++i) {\n        vec2 cloudOffset = vec2(0.1+rand(vec2(float(i),8))/12.0, 0.2+rand(vec2(float(i), 9))/12.0);\n        drawCircle(cloudOffset,0.05, vec3(1.0), fragColor.rgb, fragCoord.xy/iResolution.x);\n    }\n    for (int i = 0; i < 10; ++i) {\n        vec2 cloudOffset = vec2(0.85+rand(vec2(float(i),8))/12.0, 0.19+rand(vec2(float(i), 9))/12.0);\n        drawCircle(cloudOffset,0.05, vec3(1.0), fragColor.rgb, fragCoord.xy/iResolution.x);\n    }\n}","name":"","description":"","type":"image"}]}