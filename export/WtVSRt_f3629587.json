{"ver":"0.1","info":{"id":"WtVSRt","date":"1583371658","viewed":140,"name":"Iris Cell Marching Without Accel","username":"HenriPK","description":"Without use of octree acceleration, it's not that good, really :/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nVOXEL RENDERING SHADER FOR IRIS (on shadertoy)\n\nThings here are slow, unoptimized i know.\nOn IRIS, the actual c++ code isn't much like that.\n\nThis is more like an experiment area.\n\nCode marked with (DEPRECATED) is entirely removed.\nCode marked with (OVERRIDE) is changed on IRIS to match our actual goals.\n\n*/\n\n\n/*Those are given an use in IRIS itself.*/\nuniform float time;\nuniform vec2 resolution;\n\n//layout(origin_upper_left) in vec4 gl_FragCoord;\n\n/* Default is pointing X+ in rectangular coordinates.\n\nIncreasing X rotates the screen clockwise,\n  Y rotates the screen upwards,\n    Z rotates the screen to the right.\n\nIt's unactive, for now.\n*/\nvec3 camera_rotation = vec3(0.0, radians(30.), 0.0);\n\n#define RGB(x, y, z) (vec4(x, y, z, 255.) / 255.)\n\nhighp float;\nhighp vec3;\n\n/* How many colours there are. */\nint ccount = 8;\n\n/* The size of the model in voxels. 2^LOD */\nvec3 model_size = vec3(20.);\n\n/* The top-northwest of the model. */\nvec3 a = vec3(0.2, -.05, -.05);\n\n/* The size of the model */\nvec3 b = vec3(.1, .1, .1);\n\n/* FUNCTION DECLARATIONS */\nvec3 raymarch (vec2 uv, vec3 camera_scale);\nfloat ssdf (vec3 p);\nvec3 vecFloor (vec3 inv);\nvec3 ssnormal (vec3 p);\nvec3 rotate3d(vec3 vector, vec3 rotations);\nvec3 currentColor(vec3 ray);\nvec4 getColor(uint cv);\nvoid setVoxel(vec3 ray, uint vox);\n\nvec2 mouseuv;\nvec2 fc;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n   fc = fragCoord;\n   mouseuv = iMouse.xy / iResolution.xy - .5;\n   \n   //Color  is raymarched :D \n   vec3 col = raymarch(uv - .5, vec3(1.6, 0.9, 1.0));\n    \n  fragColor = vec4(floor(col*8.)/8., 1.0);\n}\n\n/* Step using cell marching. */ \n\nvoid stepCM (inout vec3 p, in vec3 direction, in float model_size){\n    \n    //First determine the cell this point is in.\n    //A pair of vectors (minp and maxp)\n    \n    float inv_ms = 1./model_size;\n    \n    vec3 minp = floor(p * model_size) * inv_ms;\n    vec3 maxp = minp + inv_ms;\n    \n    vec3 dist = vec3(\tdirection.x > 0. ? maxp.x - p.x : minp.x - p.x,\n                     \tdirection.y > 0. ? maxp.y - p.y : minp.y - p.y,\n                     \tdirection.z > 0. ? maxp.z - p.z : minp.z - p.z\n                     );\n    \n    if (abs(direction.z / direction.x) > abs(dist.z / dist.x))\n        p += dist.z * vec3(direction.x / direction.z, direction.y / direction.z, 1.);\n    else if (abs(direction.y / direction.x) > abs(dist.y / dist.x))\n        p += dist.y * vec3(direction.x / direction.y, 1., direction.z / direction.y);\n    else\n        p += dist.x * vec3(1., direction.y / direction.x, direction.z / direction.x);\n            \n    p += 0.001 * direction;\n}\n\n//#define RAYTRACING\n\n/*\n\n\tDefine and undefine RAYTRACING to see how the model should look.\n\tIf Raytracing is not defined, the used algorithm will be stepCM.\n*/\n\nconst highp float MIN_PHOTON_SETP = 0.001;\n\n#ifdef RAYTRACING\nconst int MAX_RM_STEPS = 1000;\n#else\nconst int MAX_RM_STEPS = 400;\n#endif\n\nvec3 raymarch (vec2 uv, vec3 camera_scale)\n{\n  /* The ray we'll raymarch :D */\n  vec3 ray = normalize(vec3(1.0, camera_scale.xy * uv));\n  float dist; vec3 cray; vec3 tcray;\n\n  for(int steps = 0; steps < MAX_RM_STEPS; steps++)\n  {\n    \n        #ifdef RAYTRACING\n            dist += MIN_PHOTON_SETP; cray = dist * ray;\n        #else\n            stepCM(cray, ray, float(model_size) * 4000.); //cray += MIN_PHOTON_SETP * ray;\n        #endif\n\n\n      \tbool outside = tcray.x < a.x || tcray.y < a.y || tcray.z < a.z || tcray.x > a.x+b.x || tcray.y > a.y+b.y || tcray.z > a.z+b.z;\n      \n    \tif (outside) continue;\n      \n        /* (OVERRIDE) The current method to check if a voxel is full or not. Palette based, not alpha based.*/\n         \n      \tvec3 cv = currentColor(tcray);\n      \tif(cv == vec3(67)) continue;\n              vec4 col = vec4(cv, 1.0);\n              return mix(col.rgb, vec3(1.0), 1.0 - col.a);\n  }\n\n  return vec3(1.0);\n}\n\n/* Get the current color of a color cube and completely ignores the model. */\nvec3 currentColor(vec3 ray)\n{    \n    vec3 r = ( ray - a ) / b;\n    \n    vec3 re = floor(r * model_size);\n    \n    if (distance(re, vec3(9.5)) < 13.) return vec3(67);\n    if ((mod(re.x, 2.)==1.)!=(mod(re.y, 2.)==1.)!=(mod(re.z, 2.)==1.)) return vec3(67);\n    //if ((mod(re.x, 2.)==1.)||(mod(re.y, 2.)==1.)||(mod(re.z, 2.)==1.)) return vec3(67);\n    \n    return  1. - re / model_size;\n}\n\n/* (DEPRECATED) Given an axis and an angle, generate a matrix that rotates a vector on those. */\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/* (DEPRECATED) Rotates a vector on three axis. */\nvec3 rotate3d(vec3 vector, vec3 rotations) {\n\n  mat4 rx = rotationMatrix(vec3(1.0, 0.0, 0.0), rotations.x);\n  mat4 ry = rotationMatrix(vec3(0.0, 1.0, 0.0), rotations.y);\n  mat4 rz = rotationMatrix(vec3(0.0, 0.0, 1.0), rotations.z);\n\n  vec4 r = (rz * ry * rx * vec4(vector, 1.0));\n    \n  return r.xyz / r.w ;\n}\n","name":"Image","description":"","type":"image"}]}