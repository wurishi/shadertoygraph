{"ver":"0.1","info":{"id":"7ltBz7","date":"1662933998","viewed":86,"name":"Evolving Cubes","username":"2222pizza","description":"checkered floor, tv static, moving camera, and 3 cubes moving in different directions. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","cubes","static","moving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//rotation matrix around the x axis\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n//rotation matrix around the y axis\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n//rotation matrix around the z axis\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n//identity matrix\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\n\nfloat circle(vec2 st, float radius){\n    vec2 pos = vec2(0.5)-st;\n    radius *= 0.75;\n    return 1.-smoothstep(radius-(radius*0.05),radius+(radius*0.05),dot(pos,pos)*3.14);\n}\n\nfloat circlePattern(vec2 st, float radius) {\n    return  circle(st+vec2(0.,-.5), radius)+\n            circle(st+vec2(0.,.5), radius)+\n            circle(st+vec2(-.5,0.), radius)+\n            circle(st+vec2(.5,0.), radius);\n}\n\n\n\n\nstruct Surface {\n    float sd; //signed distance value\n    vec3 col; //color\n};\n\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform) {\n    p = (p - offset) * transform;\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n    float d = p.y + 1.;\n    return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface sdScene(vec3 p) {\n    vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    Surface co = sdFloor(p, floorColor);\n    co = minWithColor(co, sdBox(\n        p,\n        vec3(1),\n        vec3(0, 0.5, -4),\n        vec3(0, 1, 1),\n        //rotateX(iTime)*rotateY(iTime)*rotateZ(iTime) //combine rotation matrices\n        rotateX(iTime)\n    ));\n    co = minWithColor(co, sdBox(\n        p,\n        vec3(1),\n        vec3(0, 0.5, -4),\n        vec3(0, 1, 1),\n        //rotateX(iTime)*rotateY(iTime)*rotateZ(iTime) //combine rotation matrices\n        //identity()\n        rotateY(iTime)\n    ));\n    co = minWithColor(co, sdBox(\n        p,\n        vec3(1),\n        vec3(0, 0.5, -4),\n        vec3(0, 1, 1),\n        //rotateX(iTime)*rotateY(iTime)*rotateZ(iTime) //combine rotation matrices\n        //identity()\n        rotateZ(iTime)\n    ));\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co; //closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) \n            break;\n    }\n\n    co.sd = depth;\n\n    return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; //epsilon\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).sd +\n        e.yyx * sdScene(p + e.yyx).sd +\n        e.yxy * sdScene(p + e.yxy).sd +\n        e.xxx * sdScene(p + e.xxx).sd);\n}\n\n\n\n\n\n\n\n\n\nfloat maxStrength = 0.5;\nfloat minStrength = 0.125;\n\nfloat speed = 10.00;\n\nfloat random(vec2 noise) {\n    return fract(sin(dot(noise.xy,vec2(10.998,98.233)))*12433.14159265359);\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 backgroundColor = vec3(0, 1, 1);\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(cos(iTime), sin(iTime) + 0.1, 3); //ray origin that represents camera position\n    vec3 rd = normalize(vec3(uv, -1)); //ray direction\n\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5; //<-0.5,0.5>\n    rd *= rotateY(mouse.x) * rotateX(mouse.y); //apply yaw and pitch\n\n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); //closest object\n\n    if (co.sd > MAX_DIST) {\n        col = backgroundColor; //ray didn't hit anything\n    } \n    else {\n        vec3 p = ro + rd * co.sd; //point on cube or floor we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(2, 2, 7);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.); //diffuse reflection\n\n        col = dif * co.col + backgroundColor * .2; //add a bit of background color to the diffuse color\n    }\n    \n    vec2 uv2 = fract(fragCoord.xy/iResolution.xy*fract(sin(iTime*speed)));\n    maxStrength = clamp(sin(iTime/2.0),minStrength,maxStrength);\n    vec3 col2;\n    col2 = vec3(random(uv2.xy))*maxStrength;\n    \n    \n    \n  \n    //output to screen\n    fragColor = vec4(col - col2, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}