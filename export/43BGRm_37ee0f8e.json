{"ver":"0.1","info":{"id":"43BGRm","date":"1711578157","viewed":50,"name":"Celestial Clock","username":"Chromaney","description":"Combination of experimenting with lighting and fractal-like structures.\nWith some clockwork-like movement.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","lighting","bloom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader \"Celestial Clock\" by Chromaney.\n// Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Combination of experimenting with lighting and fractal-like structures.\n// With some clockwork-like movement.\n// Use pressed LMB to rotate around.\n\n// --------------------------------\n\n// Vertical selective blur buffer + output.\n// Blur is somewhat resolution-dependent.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 normCoord = fragCoord / iResolution.xy;\n    vec2 coordScale = max(iResolution.x, iResolution.y) / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    float rMax = 0.03;\n    float nSamples = 15.0;\n    float sampleStep = 2.0 * rMax / (nSamples - 1.0);\n    float weightSum = 0.0;\n    \n    for (float dy = -rMax; dy <= rMax + 0.1 * sampleStep; dy += sampleStep){\n        float curDy = dy * coordScale.y;\n        vec2 curCoord = normCoord + vec2(0.0, curDy);\n        vec4 srcCol = textureLod(iChannel1, curCoord, 1.0);\n        float curWeight = weightFcn(abs(dy / rMax));\n        col += srcCol.xyz * srcCol.w * curWeight;\n        weightSum += curWeight;\n    }\n    \n    col = texture(iChannel0, normCoord).xyz + col * 10.0 / weightSum;\n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926536\n\n#define N_LIGHTS 7.0\n\nmat2 rotMtx(float ang){\n    float cosAng = cos(ang);\n    float sinAng = sin(ang);\n    return mat2(cosAng, -sinAng, sinAng, cosAng); // applied from right\n}\n\nfloat incStep(float t){\n    float fixedPart = 2.0 * M_PI * floor(t / (2.0 * M_PI));\n    float scaledVal = 2.0 * ((t + sin(t) - fixedPart) / (2.0 * M_PI) - 0.5);\n    float svSign = sign(scaledVal);\n    scaledVal *= (scaledVal * scaledVal); // 3\n    scaledVal *= scaledVal; // 6\n    float val = (svSign * scaledVal + 0.5) * M_PI + fixedPart;\n    return val;\n}\n\nfloat smoothMin(float a, float b, float k){\n    k *= 4.0;\n    float h = max(k - abs(a - b), 0.0) / k;\n    return (min(a, b) - h * h * k * (1.0 / 4.0));\n}\n\nfloat smoothMax(float a, float b, float k){\n    return (a + b - smoothMin(a, b, k));\n}\n\nvec3 colFromHue(float h){\n    return clamp(abs(fract(h - vec3(0.0, 1.0, 2.0) / 3.0) - 1.0 / 2.0) * 6.0 - 1.0, 0.0, 1.0);\n}\n\nfloat gyroid(vec3 pos, vec2 period){\n    return dot(sin(pos * period.x), cos(pos.zxy * period.y));\n}\n\nfloat weightFcn(float t){\n    return (1.0 - t * t * (-2.0 * t + 3.0));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Main image buffer.\n\n#define RM_MAX_ITER 100\n#define RM_MAX_DIST 30.0\n#define RM_PROX_DIST 0.003\n#define RM_SURF_EPS 0.7\n\n#define NORM_COORD_STEP 0.001\n#define NORM_COORD_STEP_VEC vec3(NORM_COORD_STEP, 0.0, 0.0)\n\nfloat sphereSDF(vec3 pos, float r){\n    // centered on vec3(0.0)\n    return (length(pos) - r);\n}\n\nfloat sphereShellSDF(vec3 pos, vec2 r){\n    // centered on vec3(0.0)\n    return (abs(length(pos) - r.x) - r.y);\n}\n\nfloat patternSDF(vec3 pos, vec2 shellSize, float scale){\n    vec3 coordShift = vec3(0.5 * scale);\n    vec3 modifPos = mod(pos - coordShift, scale) - coordShift;\n    return sphereShellSDF(modifPos, shellSize * scale);\n}\n\nfloat objSDF(vec3 pos, vec2 shellSize, vec2 secShellSize, vec2 patternScale, int n){\n    float dist = sphereShellSDF(pos, shellSize);\n    float curScale = patternScale.x;\n    for(int i = 0; i < n; i ++){\n        float patternDist = patternSDF(pos, secShellSize, curScale);\n        dist = smoothMax(dist, -patternDist, 0.007);\n        curScale /= patternScale.y;\n    }\n    return dist;\n}\n\nvec3 lightPosFromId(float id){\n    if (abs(id - (N_LIGHTS - 1.0)) < 0.1){\n        return vec3(0.0);\n    }\n    \n    float nSub = round(N_LIGHTS / 3.0);\n    float axis = mod(id, 3.0);\n    float subId = floor(id / 3.0);\n    float baseR = 6.5;\n    \n    vec3 axisMatch = vec3(\n        float(abs(axis - 0.0) < 0.001), \n        float(abs(axis - 1.0) < 0.001), \n        float(abs(axis - 2.0) < 0.001)\n    );\n    vec3 pos = baseR * axisMatch.yzx;\n    \n    mat2 curRotMtx = rotMtx(subId / nSub * 2.0 * M_PI + iTime * 0.25);\n    \n    if (axisMatch.x > 0.5){\n        pos.yz *= curRotMtx;\n    }\n    if (axisMatch.y > 0.5){\n        pos.zx *= curRotMtx;\n    }\n    if (axisMatch.z > 0.5){\n        pos.xy *= curRotMtx;\n    }\n    \n    pos.yz *= rotMtx(iTime * 0.12);\n    pos.zx *= rotMtx(iTime * 0.14);\n    pos.xy *= rotMtx(iTime * 0.15);\n    \n    return pos;\n}\n\nvec3 lightColorFromId(float id){ // synced\n    float baseHue = 0.67 + 0.1 * cos(incStep(iTime * 0.67 + 4.0 * M_PI / 3.0) / 4.3);\n    float curHue;\n    if (abs(id - (N_LIGHTS - 1.0)) < 0.1){\n        curHue = baseHue + 0.33;\n    } else {\n        curHue = baseHue + 0.1 * (2.0 * id / (N_LIGHTS - 2.0) - 1.0);\n    }\n    return (0.2 + 0.8 * colFromHue(fract(curHue)));\n}\n\nfloat lightSizeFromId(float id){\n    if (abs(id - (N_LIGHTS - 1.0)) < 0.1){\n        return 1.6;\n    }\n    \n    return 1.0;\n}\n\nfloat lightIntFromId(float id){\n    return 20.0;\n}\n\nvec4 lightGeomFromId(float id){\n    return vec4(lightPosFromId(id), lightSizeFromId(id));\n}\n\nvec4 lightColIntFromId(float id){\n    return vec4(lightColorFromId(id) * lightIntFromId(id), 1.0);\n}\n\nfloat lightDissipFcn(vec3 src, vec3 dst){\n    // should be const / r^2, but const is too mathy to calculate and r^2 is too dark\n    return 1.0 / (1.0 + length(dst - src));\n}\n\nvec3 inftyColor(vec3 dir){\n    float colorCoeff1 = 0.5 + 0.5 * gyroid(dir, vec2(10.0, 10.0)) / 3.0; // 0 to 1\n    float colorCoeff2 = 0.5 + 0.5 * gyroid(dir, vec2(8.0, 8.0)) / 3.0; // 0 to 1\n    vec3 col = vec3(0.1, 0.1, 0.1) * (0.5 + 0.5 * colorCoeff1) + \n        vec3(0.0, 0.05, 0.1) * (0.5 + 0.5 * colorCoeff2);\n    return col;\n}\n\nmat3 objRotMtx(){ // synced\n    float t = iTime * 0.67;\n    float angX = incStep(t) / 13.0;\n    float angY = incStep(t + 2.0 * M_PI / 3.0) / 12.0;\n    float angZ = incStep(t + 4.0 * M_PI / 3.0) / 11.0;\n    float sx = sin(angX), cx = cos(angX);\n    float sy = sin(angY), cy = cos(angY);\n    float sz = sin(angZ), cz = cos(angZ);\n    vec3 comp1 = vec3(cy * cz, sx * sy * cz - cx * sz, cx * sy * cz + sx * sz);\n    vec3 comp2 = vec3(cy * sz, sx * sy * sz + cx * cz, cx * sy * sz - sx * cz);\n    vec3 comp3 = vec3(-sy, sx * cy, cx * cy);\n    \n    return mat3(comp1, comp2, comp3);\n}\n\nvec2 objParams(){ // synced\n    return vec2(\n        0.075 + 0.025 * cos(incStep(iTime * 0.67 + 2.0 * M_PI / 3.0) / 1.3), \n        2.0 + 0.1 * cos(incStep(iTime * 0.67) / 1.6)\n    );\n}\n\nfloat objDistField(vec3 pos, vec2 objPar){\n    return objSDF(pos, vec2(3.8, 0.2), vec2(0.6 - objPar.x, objPar.x), vec2(1.0, objPar.y), 2);\n}\n\nvec3 sceneNorm(vec3 pos, mat3 objRot, vec2 objPar){\n    // since normal is now only for object, rotation can be separated from SDF calculations\n    pos *= objRot;\n    float sdfShX = objDistField(pos + NORM_COORD_STEP_VEC.xzy, objPar);\n    float sdfShY = objDistField(pos + NORM_COORD_STEP_VEC.yxz, objPar);\n    float sdfShZ = objDistField(pos + NORM_COORD_STEP_VEC.zyx, objPar);\n    vec3 norm = normalize(vec3(sdfShX, sdfShY, sdfShZ) - objDistField(pos, objPar));\n    return (norm * transpose(objRot));\n}\n\nvec4 rayMarch(vec3 origin, vec3 dir, out float objType, mat3 objRot, vec2 objPar){\n    float dist = 0.0;\n    objType = 1.5;\n    \n    for (int iter = 0; iter < RM_MAX_ITER; iter ++){\n        vec3 pos = origin + dir * dist;\n        float curStep = objDistField(pos * objRot, objPar);\n        dist += curStep;\n        if (abs(curStep) < RM_PROX_DIST){\n            break;\n        }\n        if (dist > RM_MAX_DIST){\n            objType = -0.5;\n            break;\n        }\n    }\n    \n    vec3 pos = origin + dir * dist;\n    return vec4(pos, dist);\n}\n\nvec4 lightMarch(vec3 pos, vec4 lightGeom, vec4 lightCol, vec3 curSceneNorm, mat3 objRot, vec2 objPar){\n    //returns vec4: xyz - resulting light intensity, w - diffuse light component\n    \n    vec3 lightPos = lightGeom.xyz;\n    float lightSize = lightGeom.w;\n    \n    float normStep = RM_PROX_DIST * (1.0 + RM_SURF_EPS);\n    vec3 origin = pos + curSceneNorm * normStep;\n    \n    vec3 lightDir = normalize(lightPos - origin);\n    float lightDist = length(lightPos - origin);\n    \n    float dist = RM_PROX_DIST * (1.0 + RM_SURF_EPS);\n    float minAngMiss = 1.0;\n    float angLightSize = lightSize / lightDist;\n    \n    float lightCoeff = 1.0;\n    \n    for (int iter = 0; iter < RM_MAX_ITER; iter ++){\n        vec3 pos = origin + lightDir * dist;\n        float curStep = objDistField(pos * objRot, objPar);\n        \n        \n        minAngMiss = min(max(curStep / dist / angLightSize, 0.0), minAngMiss);\n        dist += curStep;\n        \n        if (dist >= lightDist){ // replaces RM_MAX_DIST check\n            break;\n        }\n        if (abs(curStep) < RM_PROX_DIST){\n            break;\n        }\n    }\n    \n    if (dist < lightDist){\n        lightCoeff = 0.0;\n    } else {\n        lightCoeff *= minAngMiss;\n    }\n    \n    lightCoeff *= lightDissipFcn(origin, lightPos);\n    \n    float dotNormLight = dot(curSceneNorm, lightDir);\n    float diffLightVal = max(\n        dotNormLight + (1.0 - dotNormLight * dotNormLight) * lightSize / lightDist, \n        0.0);\n    // ^ corrected for non-point light sources\n    \n    return vec4(lightCoeff * lightCol.xyz, diffLightVal);\n}\n\nvec4 sceneColor(vec4 rmRes, float objType, vec3 camPos, vec3 rayDir, mat3 objRot, vec2 objPar){\n    // returns vec4: xyz - color, w - bloom strength\n    vec4 col = vec4(0.0);\n    vec3 pos = rmRes.xyz;\n    \n    float closestLightId = -1.0;\n    float minDist = rmRes.w;\n    vec4 closestLightColor = vec4(0.0);\n    for (float id = 0.0; id < N_LIGHTS - 0.5; id += 1.0){\n        vec4 lightGeom = lightGeomFromId(id);\n        vec4 lightColor = lightColIntFromId(id);\n        vec3 lightPos = lightGeom.xyz;\n        float lightSize = lightGeom.w;\n        \n        float coeff2 = dot(rayDir, rayDir);\n        float coeff1 = 2.0 * dot(rayDir, camPos - lightPos);\n        float coeff0 = dot(camPos - lightPos, camPos - lightPos) - lightSize * lightSize;\n        float det = coeff1 * coeff1 - 4.0 * coeff2 * coeff0;\n        if (det >= 0.0){\n            float curDist = (-coeff1 - sqrt(det)) / (2.0 * coeff2);\n            if (curDist < minDist){\n                minDist = curDist;\n                closestLightId = id;\n                closestLightColor = lightColor;\n            }\n        }\n    }\n    \n    if (closestLightId > -0.5){ // light source\n        col.xyzw = closestLightColor * lightDissipFcn(camPos + rayDir * minDist, camPos);\n    } else {\n        if (objType < 0.0){ // infinity\n            col.xyz = inftyColor(rayDir);\n        } else { // any not (infinity / not reached / light source) -> just object\n            vec3 curSceneNorm = sceneNorm(pos, objRot, objPar);\n            \n            vec2 texEffParams = 5.0 * vec2(\n                1.0 + 0.1 * cos(iTime / 5.2 + 2.0), \n                1.0 + 0.1 * cos(iTime / 6.0)\n            );\n\n            float texEffect = 0.5 + 0.5 * gyroid(pos * objRot, texEffParams) / 3.0;\n            texEffect = 1.0 + 1.0 - 2.0 * abs(smoothstep(0.4, 0.6, texEffect) - 0.5);\n\n            for (float id = 0.0; id < N_LIGHTS - 0.5; id += 1.0){\n                vec4 lightMarchRes = lightMarch(pos, \n                    lightGeomFromId(id), lightColIntFromId(id), curSceneNorm, objRot, objPar);\n                col.xyz += lightMarchRes.xyz * lightMarchRes.w;\n            }\n            col.xyz *= texEffect;\n            col.xyz += 0.75 * (vec3(0.1, 0.1, 0.1) + vec3(0.0, 0.05, 0.1));\n            // ^ add average ininity color\n            col.xyz *= vec3(1.0); // surface color\n            col *= lightDissipFcn(pos, camPos);\n        }\n        // col.w is 0.0 from init\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 mousePos = iMouse.xy;\n    if (iMouse.z == 0.0){\n        mousePos = vec2(0.3, 0.3) * iResolution.xy;\n    }\n    mat2 rotXZ = rotMtx((mousePos.x / iResolution.x * 2.0 - 1.0) * M_PI);\n    mat2 rotYZ = rotMtx((mousePos.y / iResolution.y * 1.0 - 0.5) * M_PI);\n    \n    vec3 camPos = vec3(0.0, 0.0, -10.0);\n    camPos.yz *= rotYZ;\n    camPos.xz *= rotXZ;\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    rayDir.yz *= rotYZ;\n    rayDir.xz *= rotXZ;\n    \n    mat3 objRot = objRotMtx();\n    vec2 objPar = objParams();\n    \n    float objType;\n    vec4 rmRes = rayMarch(camPos, rayDir, objType, objRot, objPar);\n    vec4 col = sceneColor(rmRes, objType, camPos, rayDir, objRot, objPar);\n    \n    fragColor = col;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Horizontal selective blur buffer.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 normCoord = fragCoord / iResolution.xy;\n    vec2 coordScale = max(iResolution.x, iResolution.y) / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    float rMax = 0.03;\n    float nSamples = 15.0;\n    float sampleStep = 2.0 * rMax / (nSamples - 1.0);\n    float weightSum = 0.0;\n    \n    for (float dx = -rMax; dx <= rMax + 0.1 * sampleStep; dx += sampleStep){\n        float curDx = dx * coordScale.x;\n        vec2 curCoord = normCoord + vec2(curDx, 0.0);\n        vec4 srcCol = textureLod(iChannel0, curCoord, 1.0);\n        float curWeight = weightFcn(abs(dx / rMax));\n        col += srcCol.xyz * srcCol.w * curWeight;\n        weightSum += curWeight;\n    }\n    \n    col *= (1.0 / weightSum);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}