{"ver":"0.1","info":{"id":"4fyXDz","date":"1715020795","viewed":76,"name":"Denoising via nearest neighbour","username":"mrboggieman","description":"Removing random parts of a texture and then filling in the gaps using the nearest neighbour.\nControls: \n - Key '1' = toggle show all noise\n - Mouse drag x = increase noise\n - Mouse drag y = move noise visualiser line","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["denoising","nearest","neighbour"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RADIUS_LIMIT = 100; // the absolute limit of x/y radius to traverse\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 size = ivec2(iResolution.xy);\n    ivec2 p = ivec2(fragCoord);\n    vec2 pf = vec2(p);\n    \n    // draw the division line\n    bool draw_noise = texelFetch(iChannel1, ivec2(49, 2), 0).r > 0.0;\n    int division_line = int(iResolution.y / 2.0);\n    \n    if (iMouse.y > 10.0) {\n        division_line = int(iMouse.y);\n    }\n    \n    if (!draw_noise && abs(p.y - division_line) < 2) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    // if we already have a colour for the current pixel then just print it out\n    vec4 col = texelFetch(iChannel0, p, 0);\n    \n    if (col.a == 1.0) {\n        fragColor = col;\n        return;\n    }\n    \n    if (draw_noise || p.y < division_line) {\n        fragColor = vec4(vec3(0.0, 1.0, 0.0), 1.0);\n        return;\n    }\n    \n    // just find the closest point by traversing neighbours\n    float min_dist = float(max(max(p.x, p.y), max(size.x - p.x, size.y - p.y)));\n\n    vec3 result;\n\n    for (int r=1; r<=min(RADIUS_LIMIT, int(min_dist)); r++) {\n        int x = p.x - r;\n        int y = p.y - r;\n        int x2 = p.x + r;\n        int y2 = p.y + r;\n        \n        int from_x = max(0, x);\n        int to_x = min(size.x-1, x2);\n\n        int from_y = max(0, y+1);\n        int to_y = min(size.y-1, y2-1);\n\n        //bottom line\n        if (y >= 0) {\n            for (int new_x = from_x; new_x <= to_x; new_x++) {\n                vec2 point_pos = vec2(new_x, y);\n                vec4 point_colour = texelFetch(iChannel0, ivec2(point_pos), 0);\n\n                if (point_colour.a > 0.0) {\n                    float dist = distance(pf, point_pos);\n\n                    if (dist < min_dist) {\n                        min_dist = dist;\n                        result = point_colour.rgb;\n                    }\n                }\n            }\n        }\n\n        //left line\n        if (x >= 0) {\n            for (int new_y = from_y; new_y <= to_y; new_y++) {\n                vec2 point_pos = vec2(x, new_y);\n                vec4 point_colour = texelFetch(iChannel0, ivec2(point_pos), 0);\n\n                if (point_colour.a > 0.0) {\n                    float dist = distance(pf, point_pos);\n\n                    if (dist < min_dist) {\n                        min_dist = dist;\n                        result = point_colour.rgb;\n                    }\n                }\n            }\n        }\n        \n        //top line\n        if (y2 < size.y) {\n            for (int new_x = from_x; new_x <= to_x; new_x++) {\n                vec2 point_pos = vec2(new_x, y2);\n                vec4 point_colour = texelFetch(iChannel0, ivec2(point_pos), 0);\n\n                if (point_colour.a > 0.0) {\n                    float dist = distance(pf, point_pos);\n\n                    if (dist < min_dist) {\n                        min_dist = dist;\n                        result = point_colour.rgb;\n                    }\n                }\n            }\n        }\n\n        //right line\n        if (x2 < size.x) {\n            for (int new_y = from_y; new_y <= to_y; new_y++) {\n                vec2 point_pos = vec2(x2, new_y);\n                vec4 point_colour = texelFetch(iChannel0, ivec2(point_pos), 0);\n\n                if (point_colour.a > 0.0) {\n                    float dist = distance(pf, point_pos);\n\n                    if (dist < min_dist) {\n                        min_dist = dist;\n                        result = point_colour.rgb;\n                    }\n                }\n            }\n        }\n    }\n    \n    fragColor = vec4(result, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer takes a texture and erases some of the pixels\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float erase_coverage = (cos(iTime + pi) / 2.0) + 0.5;\n    \n    // control the amount to erase with the mouse x axis\n    if (iMouse.x >= 10.0) {\n        erase_coverage = iMouse.x / iResolution.x;\n    }\n\n    uint rng = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277)) | uint(1);    \n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n    \n    // randomly remove some pixels from the image, use the alpha channel to indicate this\n    if (rand(rng) < erase_coverage) {\n        col = vec4(0.0);\n    }\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926;\n\n// RNG\nuint hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rand(inout uint state) {\n    return float(hash(state)) / 4294967296.0;\n}","name":"Common","description":"","type":"common"}]}