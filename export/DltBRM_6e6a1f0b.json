{"ver":"0.1","info":{"id":"DltBRM","date":"1701938477","viewed":186,"name":"Android Runtime","username":"shau","description":"Attempt at trying to simulate mocap motion with simple trig.","likes":36,"published":1,"flags":32,"usePreview":1,"tags":["3d","animation","human"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n    Trying to create a passable android/humanoid with as little geometry \n    as possible and is reasonably performant.\n    For the motion I used this as a basis but it's still a bit stiff and uniform \n    https://www.shadertoy.com/view/mtd3zM\n    \n    Some human animation shadertoys that I like\n    \n    Human Document by Reinder\n    https://www.shadertoy.com/view/XtcyW4\n    \n    The Olypian by Klems\n    hadertoy.com/view/XltyRf\n    \n    The Walking Raymarcher by XorXor\n    https://www.shadertoy.com/view/Mt3XWH\n    \n    On the Salt Lake by Iapafoto\n    https://www.shadertoy.com/view/fsXcR8\n*/\n\n\n#define ZERO (min(iFrame,0))\n#define EPS 0.005\n#define FAR 140.0\n//jeyko\n#define AObruh(p,n,a) smoothstep(0.,1.,map(p + n*a).x/a)\n\n//Shane IQ?\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7,157,113);\n    vec4 h = vec4(0.0,s.yz,s.y + s.z) + dot(ip,s);\n    rp = rp*rp*(3.0 - 2.0*rp); \n    h = mix(fract(sin(h)*43758.5),fract(sin(h + s.x)*43758.5),rp.x);\n    h.xy = mix(h.xz,h.yw,rp.y);\n    return mix(h.x,h.y,rp.z); \n}\n\n//IQ\n//https://iquilezles.org/articles/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat plaIntersect( vec3 ro, vec3 rd, vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ),\n          c = dot( oc, oc ) - sph.w*sph.w,\n          h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat bone(vec3 p, \n           vec3 a, \n           vec3 b, \n           float r1, \n           float r2, \n           float r3, \n           float ma, \n           float s)\n{\n    float la = length(a-p)/length(a-b),\n          lt = min(sdSphere(p - a,r1),sdSphere(p - b,r2)),\n          x = (1.0 - la)*s+S(0.0,0.4,la)*S(1.0,0.4,la)*ma;\n    return smin(lt,sdCapsule(p,a,b,r3 + x),0.3);\n}\n\nfloat torso(vec3 p, \n            vec3 base, \n            vec3 lHip,\n            vec3 rHip,\n            vec3 top,\n            vec3 lShoulder,\n            vec3 rShoulder)\n{\n    //bottom of torso\n    vec3 q = p - base;\n    q.xy *= rot((base.x - top.x)/(top.y - base.y));\n    q.xz *= rot((lHip.x - rHip.x)/(rHip.z - lHip.z));\n    q.yz *= rot((lHip.y - rHip.y)/(rHip.z - lHip.z));\n    float hips = min(sdEllipsoid(q,vec3(1.4,1.6,rHip.z)),\n                  max(-q.y,sdEllipsoid(q,vec3(1.4,3.0,rHip.z))));\n    //shoulders and chest\n    q = p - top;\n    float tt2 = S(-1.8,-0.9,q.y)*S(1.4,-0.8,q.y)*0.6*max(0.0,sign(q.x)) - //chest\n                S(0.4,0.0,abs(q.z))*S(-0.6,-2.2,q.y)*0.3*max(0.0,sign(q.x)) - //groove front\n                S(0.6,0.0,abs(q.z))*S(1.4,-1.2,q.y)*0.6*max(0.0,sign(-q.x)); //groove back\n    \n    q.xy *= rot((base.x - top.x)/(top.y - base.y));\n    q.xz *= rot((lShoulder.x - rShoulder.x)/(rShoulder.z - lShoulder.z));\n    q.yz *= rot((lShoulder.y - rShoulder.y)/(rShoulder.z - lShoulder.z));\n    float shoulders = min(sdEllipsoid(q,vec3(1.2+tt2,1.5,rShoulder.z)),\n                          max(q.y,sdEllipsoid(q,vec3(1.2+tt2,5.0,rShoulder.z))));\n    q.z = abs(q.z);\n    shoulders = smin(shoulders,sdSphere(q-vec3(0.0,0.0,2.4),1.0),0.3);\n    return smin(hips,shoulders,0.8);\n}\n\nfloat leg(vec3 p, \n          vec4 hip, \n          vec4 knee, \n          vec4 ankle, \n          vec4 joint, \n          vec4 toe, \n          float side)\n{\n    //thigh and bum\n    float t = smin(bone(p,\n                       hip.xyz,\n                       knee.xyz,\n                       1.0,\n                       0.8,\n                       0.7,\n                       hip.w,\n                       0.2),\n            sdEllipsoid(p-hip.xyz-vec3(-0.4,0.0,0.5*side),vec3(1.5,1.8,1.5)),\n            0.5);\n    //shin - move ankle bone up a bit\n    t = min(t,bone(p,\n                   knee.xyz,\n                   ankle.xyz + normalize(knee.xyz - ankle.xyz) * 0.7,\n                   0.8,\n                   0.5,\n                   0.45,\n                   knee.w,\n                   0.1));\n    //foot - new shoes. waddle waddle\n    vec3 q = p - joint.xyz;\n    float a = tan((joint.x - ankle.x)/length(ankle-joint));\n    q.xy *= rot(a);\n    float foot = max(-q.y,sdEllipsoid(q,vec3(0.4,1.6,0.9)));\n    q.xy *= rot(tan((toe.x - joint.x)/length(joint-toe))-a);\n    foot = min(foot,max(q.y,sdEllipsoid(q,vec3(0.4,1.0,0.9)))); //toes\n    foot = min(foot,sdEllipsoid(q,vec3(0.4,0.4,0.9))); //joint\n    foot = smin(foot,\n                sdCapsule(p,\n                          joint.xyz,\n                          ankle.xyz + normalize(ankle.xyz - joint.xyz)*0.6,\n                          0.4),\n                0.2);\n    \n    return smin(t,foot,0.3);\n}\n\nfloat arm(vec3 p, \n          vec4 shoulder, \n          vec4 elbow, \n          vec4 wrist, \n          vec4 knuckle, \n          vec4 finger, \n          float side)\n{\n    float t = min(bone(p,shoulder.xyz,elbow.xyz,0.7,0.6,0.5,shoulder.w,0.1),\n                  bone(p,elbow.xyz,wrist.xyz,0.6,0.4,0.4,elbow.w,0.05));\n    \n    //hand\n    vec3 q = p - knuckle.xyz;\n    float a = (finger.y - wrist.y)/length(finger.xy - wrist.xy);\n    q.xy *= rot(tan(a));\n    q.xz *= rot(-0.4*side);    \n    float hnd = min(sdEllipsoid(q,vec3(0.3,0.7,0.3)), \n                    max(q.x,sdEllipsoid(q,vec3(1.6,0.7,0.3))));\n    q.xz *= rot(0.6*side);\n    hnd = min(hnd,max(-q.x,sdEllipsoid(q,vec3(1.6,0.7,0.3))));\n    return smin(t,hnd,0.4);\n}\n\nvec2 near(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec3 map(vec3 p)\n{\n    vec4 bSpine =    texture(iChannel0,B_SPINE/R),\n         rHip =      texture(iChannel0,R_HIP/R),\n         lHip =      texture(iChannel0,L_HIP/R),\n         rKnee =     texture(iChannel0,R_KNEE/R),\n         rAnkle =    texture(iChannel0,R_ANKLE/R),\n         rFoot =     texture(iChannel0,R_FOOT/R),\n         rToe =      texture(iChannel0,R_TOE/R),\n         lKnee =     texture(iChannel0,L_KNEE/R),\n         lAnkle =    texture(iChannel0,L_ANKLE/R),\n         lFoot =     texture(iChannel0,L_FOOT/R),\n         lToe =      texture(iChannel0,L_TOE/R),\n         tSpine =    texture(iChannel0,T_SPINE/R),\n         rShoulder = texture(iChannel0,R_SHOULDER/R),\n         lShoulder = texture(iChannel0,L_SHOULDER/R),\n         rElbow =    texture(iChannel0,R_ELBOW/R),\n         rWrist =    texture(iChannel0,R_WRIST/R),\n         rKnuckle =  texture(iChannel0,R_KNUCKLE/R),\n         rFinger =   texture(iChannel0,R_FINGER/R),\n         lElbow =    texture(iChannel0,L_ELBOW/R),\n         lWrist =    texture(iChannel0,L_WRIST/R),\n         lKnuckle =  texture(iChannel0,L_KNUCKLE/R),\n         lFinger =   texture(iChannel0,L_FINGER/R),\n         head =      texture(iChannel0,HEAD/R);\n\n    float t = torso(p,\n                    bSpine.xyz,\n                    rHip.xyz,\n                    lHip.xyz,\n                    tSpine.xyz,\n                    rShoulder.xyz,\n                    lShoulder.xyz),    \n          legs = min(leg(p,rHip,rKnee,rAnkle,rFoot,rToe,RIGHT),\n                     leg(p,lHip,lKnee,lAnkle,lFoot,lToe,LEFT)),\n          arms = min(arm(p,rShoulder,rElbow,rWrist,rKnuckle,rFinger,RIGHT),\n                     arm(p,lShoulder,lElbow,lWrist,lKnuckle,lFinger,LEFT));\n\n    t = smin(t,legs,0.3);\n    t = smin(t,arms,0.2);\n\n    //head\n    vec3 q = p - head.xyz;\n    q.xy *= rot(-0.1);\n    float fa = S(-0.7,-0.3,q.y)*0.4,\n          fb = S(-1.0,-2.3,q.y)*0.4,\n          f = sdEllipsoid(q - vec3(1.4,-0.6,0.0),vec3(0.9+fa,1.9,1.3-fb));\n    q.xy *= rot(-0.2);\n    f = smin(f,sdEllipsoid(q - vec3(0.4,0.4,0.0),vec3(2.0,1.4,1.7)),0.4);     \n    //nose\n    f = smin(f, sdCapsule(q,vec3(2.5,-0.8,0.0),vec3(1.9,1.0,0.0),0.2),0.15);\n    //neck\n    f = smin(f, sdCapsule(p,tSpine.xyz,head.xyz,0.8),0.4);\n    t = smin(t,f,0.5);\n    //eyes and ears\n    q.z = abs(q.z);\n    float eyes = sdEllipsoid(q - vec3(1.7,-0.2,0.5),vec3(0.7,0.5,0.6)); \n    eyes = min(eyes,sdEllipsoid(q - vec3(0.0,0.4,1.5),vec3(0.6,0.4,0.4)));\n    return vec3(near(vec2(t,1.0),vec2(eyes,2.0)),eyes);\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\nfloat surfCol(vec3 p)\n{\n    vec3 rHip =      texture(iChannel0,R_HIP/R).xyz,\n         lHip =      texture(iChannel0,L_HIP/R).xyz,\n         rKnee =     texture(iChannel0,R_KNEE/R).xyz,\n         rAnkle =    texture(iChannel0,R_ANKLE/R).xyz,\n         lKnee =     texture(iChannel0,L_KNEE/R).xyz,\n         lAnkle =    texture(iChannel0,L_ANKLE/R).xyz,\n         rShoulder = texture(iChannel0,R_SHOULDER/R).xyz,\n         lShoulder = texture(iChannel0,L_SHOULDER/R).xyz,\n         rElbow =    texture(iChannel0,R_ELBOW/R).xyz,\n         rWrist =    texture(iChannel0,R_WRIST/R).xyz,\n         lElbow =    texture(iChannel0,L_ELBOW/R).xyz,\n         lWrist =    texture(iChannel0,L_WRIST/R).xyz,\n         head =      texture(iChannel0,HEAD/R).xyz,\n         la = lAnkle + normalize(lKnee - lAnkle) * 0.7,\n         ra = rAnkle + normalize(rKnee - rAnkle) * 0.7;\n    \n    float t = min(length(p-lHip) - 1.6,length(p-rHip) - 1.6);\n    t = min(t,length(p-lKnee) - 1.0);\n    t = min(t,length(p-la) - 0.7);\n    t = min(t,length(p-ra) - 0.7);\n    t = min(t,length(p-rKnee) - 1.0);\n    t = min(t,length(p-lShoulder) - 1.2);\n    t = min(t,length(p-rShoulder) - 1.1);\n    t = min(t,length(p-lElbow) - 0.8);\n    t = min(t,length(p-rElbow) - 0.8);\n    t = min(t,length(p-lWrist) - 0.6);\n    t = min(t,length(p-rWrist) - 0.6);\n    t = min(t,length(p.xy-head.xy) - 1.4);\n    t = min(t,abs(p.z) - 0.2);\n    \n    return t;\n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0,\n          w = 1.0,\n          s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w*noise(s*x);\n    }\n    return r;\n}\n\n//Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) \n{\n    float CT = iTime/8.0,\n          nz = fbm(vec3((rd.xz/(rd.y + 0.4))*1.4 + vec2(CT*2.0,0.0),CT))*1.5;\n    return clamp(pow(vec3(nz),vec3(6.0))*rd.y,0.0,1.0);\n}\n\nvec3 bump(vec3 p, vec3 n) {\n    vec4 d = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p,0.0);\n        s[i] += EPS;\n        d[i] = S(0.08,0.0,surfCol(s.xyz));\n    }\n    return normalize(n - d.xyz*0.4);\n}\n\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec4 ro = texture(iChannel0,CAM/R),\n         la = texture(iChannel0,LA/R),\n         rFoot = texture(iChannel0,R_FOOT/R),\n         lFoot = texture(iChannel0,L_FOOT/R);\n         \n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    vec3 rd = camera(la.xyz,ro.xyz,0.0) * normalize(vec3(uv,ro.w)), \n         bg = rotHue(vec3(1.0,0.0,0.0),iTime*0.1)*2.0,\n         col = bg*clouds(rd)*3.0,\n         lp = vec3(7.0,25.0,-17.0);\n    \n    float ft = plaIntersect(ro.xyz,rd,vec4(0,1,0,6.0)), //floor\n          st = sphIntersect(ro.xyz,rd,vec4(0.0,4.0,0.0,12.0)), //bounding sphere\n          t = 0.0, maxt = FAR, sid = 0.0, gc = 0.0;\n\n    if (ft>0.0)\n    {\n        //floor\n        maxt = ft;\n        vec3 p = ro.xyz + rd*ft,\n             q = vec3(p.x+mod(iTime*32.0,32.0),p.yz),\n             fl = floor(q*0.5) - 0.5,\n             fr = fract(q*0.5) - 0.5;\n        \n        col = vec3(0.01);\n        \n        //glow\n        float lft = length(lFoot.xz - floor(p.xz*0.5) - vec2(0.5)),\n              rft = length(rFoot.xz - floor(p.xz*0.5) - vec2(0.5)),\n              ct = length(fr.xz);\n        col += 3.0*(2.0*bg*S(0.5,0.1,ct)+mix(bg,vec3(1.0),0.8)*S(0.3,0.0,ct)) *\n                S(2.6,0.0,lft)*S(-5.0,-6.0,lFoot.y);\n        col += 3.0*(2.0*bg*S(0.5,0.1,ct)+mix(bg,vec3(1.0),0.8)*S(0.3,0.0,ct)) *\n                S(2.6,0.0,rft)*S(-5.0,-6.0,rFoot.y);\n        \n        col += clouds(reflect(rd,vec3(0.0,1.0,0.0)))*bg*0.5;\n        //mask\n        col *= S(-0.4,-0.35,fr.x)*S(0.4,0.35,fr.x) *\n               S(-0.4,-0.35,fr.z)*S(0.4,0.35,fr.z);\n        \n        float fog = length(p);\n        col /= (1.0 + fog*fog*0.01);\n    }\n    \n    if (st>0.0)\n    {\n        t = st;\n        for (int i=ZERO; i<100; i++)\n        {\n            vec3 p = ro.xyz + rd*t;\n            vec3 ns = map(p);\n            if (ns.x<EPS) \n            {\n                sid = ns.y;\n                break;\n            }\n            t += ns.x*0.8;\n            gc += 0.016/(1.0 + ns.z*ns.z*32.0);\n            if (t>maxt) {\n                t = -1.;\n                break;\n            }\n        }\n    }\n    \n    if (t>0.0) { \n       vec3 p = ro.xyz + rd*t,\n            n = bump(p,normal(p)),\n            ld = normalize(lp-p);\n       float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),16.0),\n             fres = pow(clamp(dot(n,rd) + 1.0,0.0,1.0),4.0),\n             ao = AObruh(p,n,0.4)*AObruh(p,n,0.1),\n             jc = surfCol(p);\n       \n       if (sid==1.0)\n       {\n           if (jc<0.0)\n           {\n               //joints\n               col = vec3(0.006)*max(0.0,dot(ld,n)) + max(0.0,n.y)*bg*0.08;\n               col *= ao;\n           }\n           else\n           {\n               //body\n               col = vec3(0.01)*max(0.001,dot(ld,n)); \n               col += bg*clouds(reflect(rd,n))*4.0*max(0.2,dot(ld,n));\n               col *= ao;\n               col += vec3(1.0)*spec;\n               col += vec3(1.0)*clouds(reflect(rd,n))*4.0*fres;\n           }\n\n       }\n       if (sid==2.0)\n       {\n           //eyes and ears\n           col = bg;\n       }\n    }\n\n    col += gc*bg;    \n    col = pow(col,vec3(0.4545));\n    \n    C = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define PI 3.141592\n#define S(a, b, v) smoothstep(a, b, v)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n#define CAM vec2(30.5,0.5)\n#define LA vec2(31.5,0.5)\n\n#define RIGHT 1.0\n#define LEFT -1.0\n\n#define R_HIP      vec2(0.5, 0.5)\n#define R_KNEE     vec2(1.5, 0.5)\n#define R_ANKLE    vec2(2.5, 0.5)\n#define R_FOOT     vec2(3.5, 0.5)\n#define R_TOE      vec2(4.5, 0.5)\n#define L_HIP      vec2(5.5, 0.5)\n#define L_KNEE     vec2(6.5, 0.5)\n#define L_ANKLE    vec2(7.5, 0.5)\n#define L_FOOT     vec2(8.5, 0.5)\n#define L_TOE      vec2(9.5, 0.5)\n#define R_SHOULDER vec2(10.5, 0.5)\n#define R_ELBOW    vec2(11.5, 0.5)\n#define R_WRIST    vec2(12.5, 0.5)\n#define R_KNUCKLE  vec2(13.5, 0.5)\n#define R_FINGER   vec2(14.5, 0.5)\n#define L_SHOULDER vec2(15.5, 0.5)\n#define L_ELBOW    vec2(16.5, 0.5)\n#define L_WRIST    vec2(17.5, 0.5)\n#define L_KNUCKLE  vec2(18.5, 0.5)\n#define L_FINGER   vec2(19.5, 0.5)\n#define B_SPINE    vec2(20.5, 0.5)\n#define T_SPINE    vec2(21.5, 0.5)\n#define HEAD       vec2(22.5, 0.5)\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime*4.0\n\nvec3 moveJoint(vec3 joint, float r)\n{\n    joint.xy *= rot(r);\n    return joint;\n}\n\nstruct Arm\n{\n    vec4 shoulder;\n    vec4 elbow;\n    vec4 wrist;\n    vec4 knuckle;\n    vec4 finger;\n};\n\nArm moveArm(vec3 back, float t, float side)\n{\n    Arm arm = Arm(vec4(0.0),\n                  vec4(0.0),\n                  vec4(0.0),\n                  vec4(0.0),\n                  vec4(0.0));\n                  \n    vec3 elbow = vec3(0.0,-3.0,-1.4*side),\n         wrist = vec3(3.0,0.0,S(0.0,-1.0,sin(t))*side*1.8),\n         knuckle = vec3(1.4,0.0,-0.4*side),\n         finger = vec3(1.0,0.0,0.3*side);\n              \n    elbow.xy *= rot(0.4 + sin(t)*0.6);\n    wrist.xy *= rot(0.8+sin(t)*1.0);\n    knuckle.xy *= rot(0.6+sin(t)*1.2);\n    finger.xy *= rot(0.6+sin(t)*1.2);\n    \n    arm.shoulder.xyz = back+vec3(sin(t-PI)*0.3,sin(t)*0.3,-2.4*side);\n    arm.elbow.xyz = arm.shoulder.xyz + elbow;\n    arm.wrist.xyz = arm.elbow.xyz + wrist;\n    arm.knuckle.xyz = arm.wrist.xyz + knuckle;\n    arm.finger.xyz = arm.knuckle.xyz + finger;\n    \n    //muscle contraction\n    float x = sin(t);\n    arm.shoulder.w = 0.4 + S(-0.4,0.6,-x)*0.1;;\n    arm.elbow.w = 0.3 + S(-0.3,0.8,-x)*0.06;\n    \n    return arm;\n}\n\nstruct Leg\n{\n    vec4 hip;\n    vec4 knee;\n    vec4 ankle;\n    vec4 foot;\n    vec4 toe;\n};\n\nLeg moveLeg(vec3 origin, float t, float side)\n{\n    Leg leg = Leg(vec4(0.0),\n                  vec4(0.0),\n                  vec4(0.0),\n                  vec4(0.0),\n                  vec4(0.0));\n    \n    vec3 knee = vec3(0.0,-4.7,0.0),\n         ankle = vec3(0.0,-4.5,0.0),\n         foot = vec3(1.9,0.0,0.0),\n         toe = vec3(0.9,0.0,0.0);\n\n    float x = sin(t),\n          xp5 = abs(sin((t+0.6)*0.5)),\n          yy = mod((t+0.6),PI*2.0);\n\n    leg.hip.xyz = origin + vec3(sin(t)*0.2,cos(t)*0.2,-1.5*side);\n    leg.knee.xyz = leg.hip.xyz + moveJoint(knee,x*0.5);\n    //leg.ankle = leg.knee + moveJoint(ankle,x+xp5*0.7+xp5*yy*0.25);\n    leg.ankle.xyz = leg.knee.xyz + moveJoint(ankle,x*0.5+xp5*yy*0.5);\n    \n    foot.xy *= rot( mix(0.2+xp5,1.2+xp5,S(0.3,0.6,xp5)));\n    toe.xy *= rot( mix(0.2+xp5,1.2+xp5,S(0.1,0.4,xp5)));\n    toe = mix(vec3(0.7,0.0,0.0),toe,S(0.2,1.0,xp5)); \n    leg.foot.xyz = leg.ankle.xyz + foot;\n    leg.toe.xyz = leg.foot.xyz + toe;\n    \n    //muscle contraction\n    leg.hip.w = 0.5 + S(-0.4,0.6,-x)*0.2;\n    leg.knee.w = 0.5 + S(-0.3,0.8,-x)*0.1;    \n    \n    return leg;\n}\n\nvoid mainImage(out vec4 C, vec2 U) \n{\n    float at = T, at2 = mod(at*0.1,PI*6.0);\n    C = vec4(0.0);\n    \n    vec4 cam  = vec4(60.0*cos(at2),3.0,-20.0*sign(sin(at2)),1.4),\n         la = vec4(0.0,6.0,0.0,0.0);\n    if ((at2>PI*0.5&&at2<PI*2.5) || (at2>PI*3.5&&at2<PI*5.5))\n    {\n        cam  = vec4(0.0,cam.y,-20.0,1.4);\n        cam.xz *= rot(at2-PI*0.5);\n        \n    }\n    cam.y += (1.0+cos(T*0.131))*12.0*S(40.0,0.0,abs(cam.x));\n    cam.z *= S(45.0,10.0,abs(cam.x));\n    \n    vec3 origin = vec3(0.0,4.0+abs(sin(at))*0.8,0.0),    \n         back = origin + vec3(0.0,6.0,0.0),\n         head = vec3(0.0,3.5,0.0);\n\n    back.xy *= rot(0.02+cos(at*2.0)*0.03);\n    head.xy *= rot(0.36+cos(at*2.0)*0.04);\n    head += back;\n    \n    Leg rightLeg = moveLeg(origin,at,RIGHT);\n    Leg leftLeg = moveLeg(origin,at-PI,LEFT);\n\n    Arm rightArm = moveArm(back,at-PI,RIGHT);\n    Arm leftArm = moveArm(back,at,LEFT);\n\n    if (U==CAM)\n    {\n        C = cam;\n    }\n    if (U==LA)\n    {\n        C = la;\n    }\n\n    if (U==B_SPINE)\n    {\n        C = vec4(origin,0.0);  \n    }\n    if (U==R_HIP)\n    {\n        C = rightLeg.hip;    \n    }\n    if (U==R_KNEE)\n    {\n        C = rightLeg.knee; \n    }\n    if (U==R_ANKLE)\n    {\n        C = rightLeg.ankle;    \n    }\n    if (U==R_FOOT)\n    {\n        C = rightLeg.foot;    \n    }\n    if (U==R_TOE)\n    {\n        C = rightLeg.toe;    \n    }\n    if (U==L_HIP)\n    {\n        C = leftLeg.hip;    \n    }    \n    if (U==L_KNEE)\n    {\n        C = leftLeg.knee; \n    }\n    if (U==L_ANKLE)\n    {\n        C = leftLeg.ankle;    \n    }\n    if (U==L_FOOT)\n    {\n        C = leftLeg.foot;    \n    }\n    if (U==L_TOE)\n    {\n        C = leftLeg.toe;    \n    }\n    if (U==T_SPINE)\n    {\n        C = vec4(back,0.0);    \n    }\n    if (U==R_SHOULDER)\n    {\n        C = rightArm.shoulder;    \n    }\n    if (U==R_ELBOW)\n    {\n        C = rightArm.elbow;\n    }\n    if (U==R_WRIST)\n    {\n        C = rightArm.wrist;\n    }\n    if (U==R_KNUCKLE)\n    {\n        C = rightArm.knuckle;\n    }\n    if (U==R_FINGER)\n    {\n        C = rightArm.finger;\n    }\n    if (U==L_SHOULDER)\n    {\n        C = leftArm.shoulder;    \n    }\n    if (U==L_ELBOW)\n    {\n        C = leftArm.elbow;\n    }\n    if (U==L_WRIST)\n    {\n        C = leftArm.wrist;\n    }\n    if (U==L_KNUCKLE)\n    {\n        C = leftArm.knuckle;\n    }\n    if (U==L_FINGER)\n    {\n        C = leftArm.finger;\n    }\n    if (U==HEAD)\n    {\n        C = vec4(head,0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}