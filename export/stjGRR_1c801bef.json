{"ver":"0.1","info":{"id":"stjGRR","date":"1623252788","viewed":241,"name":"Fast High-Quality White Noise","username":"TheTurk","description":"Using MurmurHash hash function to generate White Noise. Should be about as fast as the fract() / sin() one-liner that is frequently used but is more robust and produces a much better distribution of random numbers.  ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","fast","random","hash","whitenoise","murmur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector. The vector is hashed by simply treating as a \n// sequence of bytes. MurmurHash is the natural choice for this task because it works \n// on 4 byte sequences which happens to be also the length of the uint data type.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint seed = 0x578437adU; // can be set to something else if you want a different set of random values\n    uint hashValue = hash(uvec2(uint(fragCoord.x), uint(fragCoord.y)), seed); \n    float value = float(hashValue) / float(0xffffffffU); // convert to float in range [0, 1]\n    fragColor = vec4(vec3(value), 1.0);\n}","name":"Image","description":"","type":"image"}]}