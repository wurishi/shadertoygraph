{"ver":"0.1","info":{"id":"DdjfDh","date":"1689675610","viewed":137,"name":"J/M Set","username":"Elyades","description":"Quick draft of the sets. Trying to get more precision","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["mandelbrotset"],"hasliked":0,"parentid":"mdjczt","parentname":"Mandelbrot set Draft"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\nvec2 cosh2(vec2 uv)\n{\n    float expo = exp(uv.x); float co = cos(uv.y); float si = sin(uv.y);\n    return ( (expo*vec2(co,si) + exp(-uv.x)*vec2(co,-si))*0.5 );\n}\n\nvec2 sinh2(vec2 uv)\n{\n    float expo = exp(uv.x); float co = cos(uv.y); float si = sin(uv.y);\n    return ( (expo*vec2(co,si) - exp(-uv.x)*vec2(co,-si))*0.5 );\n}\n\nvec2 tanh2(vec2 uv)\n{\n    vec2 expo = exp2d(2.0*uv);\n    return( vec2(expo - 1.0)/(expo + 1.0) );\n}\n\nvec2 rotate(vec2 uv,float angle)\n{\n    float co = cos(angle);float si = sin(angle);\n    uv *= mat2(co,-si,si,co);\n    return(uv);\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec2 zpowlnz(vec2 uv)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    float LOG = log(modulus);\n    float value = 2.0*angle*LOG;\n    vec2 result = vec2(cos(value),sin(value))*exp(-angle*angle + pow(LOG,2.0));\n    return(result);\n}\n\nvec2 conj(vec2 uv)\n{\n    return vec2(uv.x,-uv.y);\n}\n\nvec2 iteration(vec2 uv, vec2 c)\n{    \n    //this function is f(z) = z^ln(z) + c\n    //vec2 result = power(uv,2.0 + min(max(iTime-1.0,0.0)/5.0,2.0)) + c;\n    vec2 result = vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y , 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y) + c;\n    //vec2 result = power(uv,3.0) + c;\n    //vec2 result = vec2(uv.x*uv.x - uv.y*uv.y, 2.0*uv.x*uv.y) + c;\n    //vec2 result = power(uv,2.0) + c;\n    return result;\n}\n\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.33,0.67);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,2.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Scale\n    float scale = 1.9;\n    uv += -0.5;\n    uv *= scale;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    \n\n    //Choosing the Zoom\n    float zoomAmount = pow(10.0,-iTime/10.0);\n    //vec2 zoomPoint = vec2(0.359993,1.099972);\n    vec2 zoomPoint = vec2(0.0,0.3);\n    vec2 mousePoint = (iMouse.xy - iResolution.xy/2.0)*8.0/ iResolution.xy;\n    \n\n    //uv = uv*zoomAmount;\n    //uv = rotate(uv,mod(max(iTime-7.0,0.0)/40.0,1.0)*TWOPI); //comment this to stop the rotation\n    uv += zoomPoint;\n    \n    //uv += mousePoint*zoomAmount*max(iTime-4.0,0.0);\n    //uv += vec2(-0.61021,-0.0001);\n    //uv += zoomPoint*zoomAmount;\n    \n    //Determining the interior of the set\n    \n    \n    \n    //Change this line to go from Mandelbrot to Julia\n    //vec2 c =  5.0*(iMouse.xy - iResolution.xy/2.0)/iResolution.xy;\n    vec2 c = uv;\n    \n    float tol = pow(10.0,-8.0);\n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 10000;\n    \n    vec2 dummyuv = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = dummyuv;\n        dummyuv = iteration(dummyuv,c);\n        currentModulus = length(dummyuv);\n        DistanceToPrevious = length(dummyuv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > 200.0)\n        {\n            break;\n        } \n    }\n\n    //Coloring the interior of the set\n    \n    if (currentModulus < 200.0)\n    {\n        \n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //Coloring the exterior of the set\n    \n    else\n    {\n        \n        /*if(iterationAmount <= 2)\n        {\n            float intensity = 1.0 - float(iterationAmount/10);\n            fragColor = vec4(intensity*0.7,intensity*0.0,intensity*1.0,1.0);\n        }*/\n        \n        //else\n        {\n            iterationAmount *= 5;\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette2(indexFast);\n            \n            int periodMedium = 20;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette2(indexMedium);\n            \n            int periodSlow = 50;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette2(indexSlow);\n           \n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n     }\n        \n        \n    }\n\n    \n}","name":"Image","description":"","type":"image"}]}