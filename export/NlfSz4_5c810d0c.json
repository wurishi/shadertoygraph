{"ver":"0.1","info":{"id":"NlfSz4","date":"1625209768","viewed":95,"name":"Basic Ray Tracing(2)","username":"chenxiaoleizi","description":"Based on https://www.gabrielgambetta.com/computer-graphics-from-scratch/02-basic-raytracing.html","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.gabrielgambetta.com/computer-graphics-from-scratch/02-basic-raytracing.html\nstruct sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\nsphere s1 = sphere( vec3(0.0, -1.0, 3.0), 1.0, vec3(1.0, 0.0, 0.0) );\nsphere s2 = sphere( vec3(2.0, 0.0, 4.0), 1.0, vec3(0.0, 0.0, 1.0) );\nsphere s3 = sphere( vec3(-2.0, 0.0, 4.0), 1.0, vec3(0.0, 1.0, 0.0) );\n\nstruct light {\n    float type;\n    float intensity;\n    vec3 position;\n    vec3 direction;\n};\nlight l1 = light( 1.0, 0.2, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0) );\nlight l2 = light( 2.0, 0.6, vec3(2.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0) );\nlight l3 = light( 3.0, 0.2, vec3(0.0, 0.0, 0.0), vec3(1.0, 4.0, 4.0) );\n\n\nconst vec3 bg = vec3(1.0, 1.0, 1.0);\nconst vec3 o = vec3(0.0, 0.0, 0.0);\nconst float cw = 800.0, ch = 450.0;\nconst float vw = 1.0, vh = 0.5625;\nconst float planeD = 1.0;\n\nvec3 canvas2viewport(float x, float y, float d){\n    return vec3(x * vw / cw, y * vh / ch, d);\n}\nvec2 insectRaySphere(vec3 o, vec3 d, sphere s){\n    float radius = s.radius;\n    vec3 co = o - s.center;\n    \n    float a = dot(d, d);\n    float b = 2.0 * dot(co, d);\n    float c = dot(co, co) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return vec2(100000000.0, 100000000.0);\n    }\n    \n    float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b - sqrt(discriminant)) / (2.0 * a);\n    \n    return vec2(t1, t2);\n}\n\nfloat computeLighting(vec3 p, vec3 n){\n    light lArr[3];\n    lArr[0] = l1;\n    lArr[1] = l2;\n    lArr[2] = l3;\n    \n    float itensity = 0.0;\n    vec3 direction;\n    \n    for (int i = 0; i < 3; i++) {\n        light l = lArr[i];\n        \n        if (l.type == 1.0) {\n            itensity += l.intensity;\n        } else {\n            direction = (l.type == 2.0)? (l.position - p) : l.direction;\n            \n            float nDotL = dot(n, direction);\n            if (nDotL > 0.0) {\n                itensity += l.intensity * nDotL / (length(n) * length(direction));\n            }\n        }\n    }\n    \n    return itensity;\n}\n\nvec3 traceRay(vec3 o, vec3 d, float tMin, float tMax) {\n    float closestT = 100000000.0;\n    sphere closestSphere;\n    bool get = false;\n    \n    sphere sArr[3];\n    sArr[0] = s1;\n    sArr[1] = s2;\n    sArr[2] = s3;\n    for (int i = 0; i < 3; i++) {\n        sphere s = sArr[i];\n       vec2 tRes = insectRaySphere(o, d, s);\n       float t1 = tRes.x;\n       float t2 = tRes.y;\n\n       if (t1 > tMin && t1 < tMax && t1 < closestT) {\n           closestT = t1;\n           get = true;\n           closestSphere = sphere(s.center, s.radius, s.color);\n       }\n       if (t2 > tMin && t2 < tMax && t2 <closestT) {\n           closestT = t2;\n           get = true;\n           closestSphere = sphere(s.center, s.radius, s.color);\n       } \n    }\n\n    if (!get) {\n        return bg;\n    }\n    \n    vec3 p = o + closestT * d;\n    vec3 n = normalize(p - closestSphere.center);\n    float intensity = computeLighting(p, n);\n    \n    return closestSphere.color * intensity;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    float x = fragCoord.x - cw / 2.0;\n    float y = fragCoord.y - ch / 2.0;\n    vec3 d = canvas2viewport(x, y, planeD);\n    \n    vec3 col = traceRay(o, d, 1.0, 100000000.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}