{"ver":"0.1","info":{"id":"cs3GWf","date":"1681105867","viewed":146,"name":"Easter Egg !","username":"celifan","description":"An egg with lines on it.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["egg","easter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define TAU (2.0 * PI)\n\n#define SPLIT_THICK_LINES 1\n\n// Egg 2d sdf\nfloat sdEgg2( in vec2 p)\n{\n    p.x = abs(p.x);\n    return   ((p.y <= 0.)           ? length(p)   - 1.0 :\n              ((p.y-1.0) > p.x)     ? length(p-vec2( 0.0,1.0)) - (2.-sqrt(2.)) : \n                                        length(p-vec2(-1.0,0.0)) - 2.);  \n}\n\n// Egg 2d param [-1,1]\nfloat egg_u(in vec2 p )\n{\n    float s0 = (p.y >0.0 && p.x >0.0 && ((p.y-1.0) <= p.x)) ? (atan(p.y, p.x+1.0)*2.0):0.0;\n    const float s0t = PI/2.0;\n    //\n    float s1t = sqrt(2.0)*PI/8.0; \n    float s1 = (p.y >0.0 && ((p.y-1.0) > p.x) && ((p.y-1.0) >-p.x)) ?s0t+ atan(p.y-1.0, p.x)*sqrt(2.0)/2.0 - s1t\n                                                                    :0.0;\n    //                                                               \n    s1t*=2.0;\n    float s2 = (p.y >0.0 && p.x <0.0 && (p.y-1.0) <-p.x) ?s1t+s0t+ atan(p.y, p.x-1.0)*2.0 - 3.0*PI/2.0:0.0;\n    float s2t = s0t*2.0 +s1t; \n    //\n    return  p.y <=0.0 ? atan(p.y, p.x)/PI: (s0+ s1 +s2)/s2t;\n}\n\n// Circle 2d param [-1,1]\nfloat circ_v(in vec2 p)\n{\n    float vp = atan( p.y,p.x);\n   \n    return vp /(PI);\n}\n\n// Egg 3d sdf\nfloat sdEgg3(vec3 pos)\n{\n    vec2 pxy= vec2(length(pos.xz), pos.y);\n    return sdEgg2(pxy);\n}\n\n// Egg normal\nvec3 Negg3( in vec3 pos )\n{\n    const float ep = 0.01;\n    vec2 e = vec2(1.0,-1.0);\n    return normalize( e.xyy*sdEgg3( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*sdEgg3( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*sdEgg3( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*sdEgg3( pos + e.xxx*ep ) );\n}\n\n\nfloat sdThickCircle(in vec2 p, float r , float r_in)\n{\n   \n     float d0 =length(p)-r;\n     float d1 = length(p)-r_in;\n     return max(d0,-d1);\n}\n\n\n\nfloat sdThickCircleHalf(in vec2 p, float r,float r_in)\n{\n    float d0 =p.y>0.0 ?length(p)-r : length(abs(p)-vec2(r,0.0));\n    float d1 =p.y>0.0 ?length(p)-r_in : length(abs(p)-vec2(r,0.0));\n    return max(d0,-d1);\n}\n\n\n#define R .2\n#define R38 (R/38.0)\n#define R76 (R38/2.0)\n#define M (2.0*R/18.0)\n#define C_OFF R/2.0\n\nfloat traceArc(vec2 uv, int o, int n)\n{\n    float rLoc = R-R/12.0;\n    float mLoc = 2.0*rLoc/18.0;\n    float r = mLoc*float(n)/2.0;\n    vec2 c = vec2(-rLoc+mLoc*float(o)+r,0.0);\n    return sdThickCircleHalf(vec2(uv.x,uv.y)+c, r+R76, r-R76);\n}\n\n\nfloat c_dir(in vec2 p, float r, float r_in,vec2 dir)\n{\n    float d0 = (p.x*dir.y) - (p.y*dir.x) >0.0 ? min(length(p-dir*r), length(p+dir*r)) :length(p)-r;\n    float d1 = (p.x*dir.y) - (p.y*dir.x) >0.0 ? min(length(p-dir*r_in), length(p+dir*r_in)) :length(p)-r_in;\n    return max(d0,-d1);\n}\n\nfloat c_dir1(in vec2 p, float r, float r_in,vec2 dir, float off)\n{\n    \n    float d0 = p.y<-off &&(p.x*dir.y) - (p.y*dir.x) >0.0 ? min(length(p-dir*r), length(p+dir*r)) :length(p)-r;\n    float d1 = p.y<-off &&(p.x*dir.y) - (p.y*dir.x) >0.0 ? min(length(p-dir*r_in), length(p+dir*r_in)) :length(p)-r_in;\n    return max(d0,-d1);\n}\n\nfloat sd_l(vec2 p, vec2 d, float l, float w)\n{\n    float h= clamp(dot(p,d),0.0,l);\n    return length(d*h-p)-w  ; \n}\n\nfloat leaf(in vec2 p)\n{\n    float _r=R-R/4.0;\n    p.x = abs(p.x);\n    \n    float sq32 = sqrt(3.0)/2.0;\n    \n    // vertical line \n    float dvert = sd_l( p+vec2(0.0,_r), vec2(0.0,1.0),_r*3.0/2.0,R76);\n    \n    // main dir \n    vec2 dr_dir_n = vec2(.5,-sq32);\n    vec2 dr_dir =  _r*sq32*dr_dir_n;\n    // main dir ortho\n    vec2 dr_ortho_dir_n = vec2(sq32,.5);\n    vec2 dr_ortho_dir = _r* dr_ortho_dir_n;\n    \n    //\n    float dr0 =  sd_l( p+vec2(0.0,-_r/2.0), dr_ortho_dir_n,_r*.5,R76);\n    float dr = sd_l( p+vec2(0.0,_r), dr_ortho_dir_n,_r,R76);\n    float dr1 = sd_l( p+vec2(0.0,0.0), dr_ortho_dir_n,_r-_r/4.0,R76);\n    float dr2 = sd_l( p+vec2(0.0,_r/2.0), dr_ortho_dir_n,_r,R76);\n   \n    //\n    vec2 p0= (dr_ortho_dir*3.0/4.0+dr_dir*1.0/4.0);\n    vec2 p1= (dr_ortho_dir*3.0/4.0-dr_dir*1.0/4.0);\n    vec2 p2= (dr_ortho_dir*3.0/4.0+dr_dir*1.0/4.0) - vec2(0.0,_r/2.0);\n    vec2 p3= vec2(0.0,_r*3.0/4.0);\n    \n    float rc = _r*sq32* .25;\n    float rc1 = _r*.25;\n    float p0_d = c_dir(p-p0,rc+R76, rc-R76,dr_dir_n);\n    float p1_d = c_dir(p-p1, rc+R76, rc-R76,dr_dir_n);\n    float p2_d = c_dir(p-p2, rc+R76, rc-R76,dr_dir_n);\n    float p3_d = c_dir1(p-p3,  rc1+R76, rc1-R76,vec2(1.0,0.0),_r*.125);\n    \n    float dist = min(dvert,min(dr0,min(dr2,min(dr1,min(p3_d,min(p2_d,(min(p1_d, min(p0_d,dr)))))))));\n    return dist;\n}\n\nfloat trefoil(in vec2 p)\n{\n    float r_ = R/2.0 - R/10.0;\n    p.y*=2.0;\n    p.x*=.7;\n    p.y+= r_-r_/8.0;\n    \n    float sq32 = sqrt(3.0)/2.0;\n    // main dir \n    vec2 ds_n = vec2(sq32,-.5);\n   \n    // folds\n    // y dir\n    //p.y *= smoothstep(0.0,r_,p.y);\n    p.x = abs(p.x);\n    // ds_n dir \n    p= (p.x*ds_n.y)-(p.y*ds_n.x) >0.0 ? p+ 2.0*(dot(ds_n,p)*ds_n-p): p;\n   \n    float border = .5*r_*(sq32-1.0);\n    float c0= length(p)-r_;\n    float c1 = length(p)-(r_+border);\n    float c = max(c0,-c1);\n    \n    float tr0= (length(p-r_*vec2(sqrt(3.0)/4.0,1.0/4.0))-.5*r_);\n    float tr1 = (length(p-r_*vec2(sqrt(3.0)/4.0,1.0/4.0))-(.5*r_+border));\n    \n    \n    \n    float tr = min(c, max(tr0,-tr1));\n   \n    \n   return tr;\n}\n\nfloat waves(in vec2 uv)\n{\n    vec2 uv_f = uv*vec2(1.0,-1.0);\n    float sp0 =1.0000;\n\n    sp0 =min(sp0, traceArc(uv,3, 1));\n    sp0 = min(sp0, traceArc(uv_f,3, 1));\n\n    sp0 = min(sp0, traceArc(uv,0, 4)); \n    sp0 = min(sp0, traceArc(uv,2, 2)); \n    sp0 = min(sp0, traceArc(uv_f,2, 4)); \n    sp0 = min(sp0, traceArc(uv_f,0, 12)); \n    sp0 = min(sp0, traceArc(uv_f,2, 10)); \n\n    sp0 = min(sp0, traceArc(uv,6, 12)); \n    sp0 = min(sp0, traceArc(uv,6, 10)); \n    sp0 = min(sp0, traceArc(uv,6, 4)); \n\n    sp0 = min(sp0, traceArc(uv,8, 2)); \n    sp0 = min(sp0, traceArc(uv_f,8, 2)); \n    sp0 = min(sp0, traceArc(uv_f,8, 4)); \n\n    sp0 = min(sp0, traceArc(uv,12, 4)); \n    sp0 = min(sp0, traceArc(uv_f,14, 2)); \n    sp0 = min(sp0, traceArc(uv_f,14, 1)); \n    sp0 = min(sp0, traceArc(uv,14, 1));\n    sp0 = min(sp0, traceArc(uv_f,14, 4));\n    \n    return sp0;\n}\n\nfloat mapParam(in vec3 pos)\n{\n    pos.y+=.3;\n    // \n    float v = egg_u(vec2(length(pos.xz),pos.y));\n    float u = circ_v(pos.xz);\n\n\n\n    //float vi = floor(v*4.0);\n    float r =.2;\n    float r_in = r-r/12.0;\n    float r2 = r*2.0;\n    //\n    float u4 = fract((u)*3.0);\n    float u4_90 = fract((u+1.0/6.0)*3.0);\n\n    float u_= u4*r2-r;\n    float u_90= u4_90*r2-r;\n    //\n    float cCenter = sdThickCircle(vec2(u_,v-.1), r, r_in) ;\n    float cTop = sdThickCircle(vec2(.5*(u_90), (v-.4)), r/2.0, r/2.0-r/12.0) ;\n    float cBottom = sdThickCircle(vec2(u_90, (v+.3)), r, r-r/6.0);\n\n\n    float lb = abs(v+.1)-r/24.0;\n    float lt = abs(v-.3)-r/36.0;\n\n    //leaf\n    vec2 uv = vec2(u_90, (v+.3));\n    float leaf = leaf(uv);\n\n    //trefoil\n    uv = vec2(u_90, (v-.4));\n    float trefoil = trefoil(uv);\n\n    //waves \n    uv = vec2(u_,v-C_OFF);\n    float waves = waves(uv);\n\n    //\n    return min(trefoil,min(leaf,min(waves,min(cCenter,min(cTop,min(cBottom, min(lb, lt)))))));\n\n}\n\n// from Shane https://www.shadertoy.com/view/tdtyDs\n//\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.001;\n    vec2 e = vec2(1.0,-1.0);\n    return normalize( e.xyy*sdEgg3( pos + e.xyy*ep )+ \n\t\t\t\t\t  e.yyx*sdEgg3( pos + e.yyx*ep )+ \n\t\t\t\t\t  e.yxy*sdEgg3( pos + e.yxy*ep )+ \n\t\t\t\t\t  e.xxx*sdEgg3( pos + e.xxx*ep ));\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m =  (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    //\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int mm=0; mm<AA; mm++ )\n    for( int nn=0; nn<AA; nn++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(mm),float(nn)) / float(AA) - 0.5;\n        vec2 p2 = (2.0 * (fragCoord.xy+o)/iResolution.xy -1.0 ); \n        #else    \n        vec2 p2 = (2.0 * fragCoord.xy/iResolution.xy -1.0 );\n        #endif\n         \n        p2.y+=.25;\n        p2.x*=(iResolution.x/iResolution.y);\n        // camera\n        vec3 up = vec3(0.0,1.0,0.0);\n        vec3 ro = vec3(3.0*sin(7.0*(m.x+(iTime/10.0))), 3.0*cos(4.0*(m.x+(iTime/10.0))),3.0*cos(7.0*(m.x +(iTime/10.0))));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        vec3 ro_ta = normalize(ta -ro); \n        vec3 ri = normalize(cross(ro_ta,up));\n        vec3 rj = normalize(cross(ri,ro_ta));\n        vec3 rd = normalize(p2.x*ri +p2.y*rj+ ro_ta*2.0);   \n\n        float t = 0.0;\n        for( int i=0; i<256;++i)\n        {\n            vec3 p = ro + t*rd;\n            float h = sdEgg3(p);\n\n            if( abs(h)<0.001 || t>10.0 ) break;\n            t += h;\n        }\n\n        vec3 col = vec3(0.0);\n        if( t<10.0  )\n        {\n            //\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect(rd, nor);\n            vec3 specColor = vec3(.7,.8,1.0);\n           \n            vec3 tx = tex3D(iChannel1, pos, nor);\n            tx = smoothstep(.0, .5, tx);\n            \n            vec3  lig = normalize(vec3(1.0,2.0,-2.0));\n            vec3  lig1 = normalize(vec3(1.0,2.0,2.0));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float dif1 = clamp(dot(nor,lig1),0.0,1.0);\n            \n            \n            float dp =mapParam(pos);\n            float sf = 0.001;\n            float dps = smoothstep(0.0,sf,dp);\n            float dps1 = smoothstep( -sf*1.1,-sf,dp);\n            col = mix(vec3(1.0,.7,.3),vec3(1.0,.96,.85),dps1);\n            #if defined(SPLIT_THICK_LINES)\n            col = mix(col,vec3(.27,0.05,0.047),abs(pow(.5*(sin(dp*1000.0)+1.0),6.0)));\n            #endif\n            col = mix(col, vec3(.27,0.05,0.047),dps);\n            // fresnel\n            float exponent = 8.; \n            float fresnel = .5*pow(clamp(1. - dot(nor, -rd), 0., 1.), exponent);\n            col += fresnel *vec3(1, 1, 1) ;\n           \n            // spec term \n            float pp = clamp(dot(ref, lig), 0.0, 1.0);\n            float spec = .5* pow(pp, 128.0*.3 );\n            float pp1 = clamp(dot(ref, lig1), 0.0, 1.0);\n            float spec1 = .3* pow(pp1, 128.0*.8 );\n            col = col + dif*1.7*vec3(.27,0.05,0.047) +   specColor* spec;\n            col +=  dif1*1.7*vec3(.27,0.05,0.047) +  specColor * spec1;\n            \n            // small amount of texture.\n            float av = length(tx);\n            col *= tx*.3 + .7;\n            \n            tot += col;\n        }\n        else \n            tot+=col;\n\n         #if AA>1\n        }\n    tot /= float(AA*AA);\n    #endif\n    \n\tfragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}