{"ver":"0.1","info":{"id":"tsScDy","date":"1588872879","viewed":94,"name":"Penumbra Shadows - cis461","username":"sharond106","description":"Penumbra shadows","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["penumbra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOVY = 0.25 * 3.141569;\nconst int RAY_STEPS = 256;\n#define BACK_WALL_SDF sdfPlane(pos, BACK_WALL_INVERSE_T)\n#define BACK_WALL_ID 1\n#define BACK_WALL_INVERSE_T inverseTransform(vec3(0., 5., 15.), vec3(0.), vec3(40., 40., 1.))\n#define FLOOR_SDF sdfPlane(pos, FLOOR_INVERSE_T)\n#define FLOOR_ID 2\n#define FLOOR_INVERSE_T inverseTransform(vec3(0., -4.95, 0.), vec3(90., 0., 0.), vec3(60., 50., 1.))\n#define SPHERE_SDF sdfSphere(pos, vec3(0, 1, 3), 1.)\n#define SPHERE_ID 5\n#define SPHERE_INVERSE_T inverseTransform(vec3(0, 1, 3), vec3(90, 0., 0), vec3(1.))\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 inverseTransform(vec3 translate, vec3 rotate, vec3 scale) {\n    mat4 s;\n    // matrices indexed to columns!\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n\ts[3] = vec4(0., 0., 0., 1.);                                     \n                                    \n    rotate.x = radians(rotate.x);\n    rotate.y = radians(rotate.y);\n    rotate.z = radians(rotate.z);\n      \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(translate.x, translate.y, translate.z, 1.); \n    \n    return inverse(t * r * s);      \n}\n    \nfloat sdfPlane(vec3 p, mat4 inverseT) {\n    p = vec3(inverseT * vec4(p, 1.));\n    float dot = dot(p, vec3(0., 0., 1.));\n    if (abs(dot) < 0.0001) {\n        // n must be normalized\n        if (p.x >= -.5 && p.x <= 0.5 && p.y >= -0.5 && p.y <= 0.5) {\n            return 0.;  \n        }\n        return 324234.;\n    }\n    float dist = 0.f;\n    if (abs(p.x) > 0.5) {\n        dist += ((p.x - 0.5) * (p.x - 0.5));\n    }\n    if (abs(p.y) > 0.5) {\n        dist += ((p.y - 0.5) * (p.y - 0.5));\n    }\n    dist += abs(p.z) * abs(p.z);\n    return sqrt(dist);\n} \n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objectHit) {\n\tt = FLOOR_SDF;\n    objectHit = FLOOR_ID;\n    float t2;\n    \n\tif ((t2 = BACK_WALL_SDF) < t) {\n        t = t2;\n        objectHit = BACK_WALL_ID;\n    }\n    if ((t2 = SPHERE_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE_ID;\n    }\n}\n\n// called by computeNormal\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objectHit) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float min;\n        sceneMap3D(pos, min, objectHit);\n        if (min < 0.01) {\n            return;\n        }\n        t += min;\n    }\n    t = -1.;\n    objectHit = -1;\n}\n\nvec3 computeNormal(vec3 p) {\n    vec3 epsilon = vec3(0., .001, 0.);\n    return normalize(vec3(sceneMap3D(p + epsilon.yxx) - sceneMap3D(p - epsilon.yxx),\n                          sceneMap3D(p + epsilon.xyx) - sceneMap3D(p - epsilon.xyx),\n                     \t  sceneMap3D(p + epsilon.xxy) - sceneMap3D(p - epsilon.xxy)));\n}\n\n\nvec3 computeMaterial(int objectHit, vec3 p, vec3 n, vec3 lightPos, vec3 view) {\n    vec3 lightDir = normalize(lightPos - p);\n    float lambert = dot(n, lightDir);\n    vec3 color;\n    switch (objectHit) {\n        case SPHERE_ID:\n        color = vec3(.5, 1, 1);                \n        break;\n        case FLOOR_ID:\n        color = vec3(1);\n        break;\n        case BACK_WALL_ID:\n        color = vec3(1);        \n        break;\n    }\n    return color * lambert;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float k, int max_steps) {\n    float res = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < max_steps; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nIntersection sdf3D(vec3 eye, vec3 dir) {\n    float t;\n    int objectHit;\n    march(eye, dir, t, objectHit);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect);\n   \n    vec3 lightPos = vec3(4, 10, -2);\n    \n    vec3 color = computeMaterial(objectHit, isect, nor, lightPos, normalize(eye - isect)) \n        \t\t\t* softShadow(normalize(lightPos - isect), isect, 12.0, int(lightPos - isect) + 10);\n    \n    if (objectHit == -1) {\n        color = vec3(0, 0, 0);\n    }\n    \n    return Intersection(t, color, isect, objectHit);\n}\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1, 1);\n    \n    vec3 eye = vec3(0, 3, -11);\n    vec3 ref = vec3(0, 0, 2);\n    vec3 rayDir = rayCast(eye, ref, uv); \n    \n    Intersection isect = sdf3D(eye, rayDir);\n\n    fragColor = vec4(isect.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}