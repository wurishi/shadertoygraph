{"ver":"0.1","info":{"id":"slK3Dt","date":"1638550598","viewed":164,"name":"Flat plane ride","username":"bunyk","description":"Learning GLSL","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["plane","lowpoly"],"hasliked":0,"parentid":"NtKGDc","parentname":"Indra's net 3d"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst vec3 CAM_START_POS = vec3(0, 0, -3.0);\nconst vec3 CAM_DIR = vec3(0, 0, 1.0);\nconst float focal_length = 1.0;\n\nconst vec3 red = vec3(1.0, 0.0, 0.0);\nconst vec3 green = vec3(0.0, 1.0, 0.0);\nconst vec3 black = vec3(0.0);\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Direction;\n};\n\nRay getCamRay(in vec3 origin, in vec2 uv, in float aspect_ratio) {\n    float viewport_height = 2.0;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 horizontal = vec3(viewport_width, 0, 0);\n    vec3 vertical = vec3(0, viewport_height, 0);\n    vec3 lower_left_corner = origin - horizontal/2.0 - vertical/2.0 + vec3(0, 0, focal_length);\n\n    return Ray(origin, normalize(lower_left_corner + uv.x * horizontal + uv.y*vertical - origin));\n}\n\n\nfloat hit_sphere(in vec3 center, in float radius, in Ray r) {\n    vec3 oc = r.Origin - center;\n    float a = dot(r.Direction, r.Direction);\n    float b = 2.0 * dot(oc, r.Direction);\n    float c = dot(oc, oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nfloat hit_hplane(in float h, in Ray r) {\n    if (r.Direction.y == 0.0) {\n        return -1.0;\n    }\n    return (h - r.Origin.y) / r.Direction.y;\n}\n\nvec3 at(in Ray r, float t) {\n    return r.Origin + r.Direction * t;\n}\n\n\nvec3 rayColor(in Ray r) {\n    float t = hit_sphere(vec3(0,0, -1), 0.5, r);\n    if (t > 0.0) {\n        vec3 N = normalize(at(r, t) - vec3(0,0,-1));\n        return vec3(dot(N, vec3(0.0, 1.0, 0.0)));\n    } \n    t = hit_hplane(-0.5, r);\n    if (t > 0.0) {\n        vec3 hp = at(r, t);\n        float x = mod(hp.x, 1.0);\n        float y = mod(hp.z, 1.0);\n        if((x < 0.05) || (y < 0.05)) {\n            return green;\n        }\n        return black;\n    }\n    vec3 unit_direction = normalize(r.Direction);\n    t = 0.5*(unit_direction.y + 1.0);\n    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n\n}\n\nconst float SUBPIXELS = 10.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 camPos = CAM_START_POS + iTime * CAM_DIR;\n    \n    vec3 col;\n    \n    for(float i = 0.0; i < SUBPIXELS; i++) {\n        for(float j = 0.0; j < SUBPIXELS; j++) {\n            vec2 subpixel_uv = vec2(i, j) / iResolution.xy / SUBPIXELS;\n            Ray ray = getCamRay(camPos, uv + subpixel_uv, iResolution.x / iResolution.y);\n            col += rayColor(ray);\n        }\n    }\n    col /= SUBPIXELS*SUBPIXELS;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}