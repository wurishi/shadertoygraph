{"ver":"0.1","info":{"id":"ll2GRt","date":"1431523178","viewed":4507,"name":"Oil stain","username":"noby","description":"A little 2D effect I wrote earlier this year based on iq's noise derivatives. A standalone GLSL version only works on nVidia for some reason, I'm probably abusing the derivatives too badly, or maybe the noise has some sort of a quirk I haven't noticed...","likes":97,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","fbm","perlin","blackandwhite","fluid","monochrome","liquid","noisederivative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//#define INVERT\nmat2 rot2d(float angle){return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));}\nfloat r(float a, float b){return fract(sin(dot(vec2(a,b),vec2(12.9898,78.233)))*43758.5453);}\nfloat h(float a){return fract(sin(dot(a,dot(12.9898,78.233)))*43758.5453);}\n\nfloat noise(vec3 x){\n    vec3 p  = floor(x);\n    vec3 f  = fract(x);\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( h(n+0.0), h(n+1.0),f.x),\n                   mix( h(n+57.0), h(n+58.0),f.x),f.y),\n               mix(mix( h(n+113.0), h(n+114.0),f.x),\n                   mix( h(n+170.0), h(n+171.0),f.x),f.y),f.z);\n}\n\n// https://iquilezles.org/articles/morenoise\n// http://www.pouet.net/topic.php?post=401468\nvec3 dnoise2f(vec2 p){\n    float i = floor(p.x), j = floor(p.y);\n    float u = p.x-i, v = p.y-j;\n    float du = 30.*u*u*(u*(u-2.)+1.);\n    float dv = 30.*v*v*(v*(v-2.)+1.);\n    u=u*u*u*(u*(u*6.-15.)+10.);\n    v=v*v*v*(v*(v*6.-15.)+10.);\n    float a = r(i,     j    );\n    float b = r(i+1.0, j    );\n    float c = r(i,     j+1.0);\n    float d = r(i+1.0, j+1.0);\n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = a-b-c+d;\n    return vec3(k0 + k1*u + k2*v + k3*u*v,\n                du*(k1 + k3*v),\n                dv*(k2 + k3*u));\n}\n\nfloat fbm(vec2 uv){               \n    vec2 p = uv;\n\tfloat f, dx, dz, w = 0.5;\n    f = dx = dz = 0.0;\n    for(int i = 0; i < 28; ++i){        \n        vec3 n = dnoise2f(uv);\n        dx += n.y;\n        dz += n.z;\n        f += w * n.x / (1.0 + dx*dx + dz*dz);\n        w *= 0.86;\n        uv *= vec2(1.16);\n        uv *= rot2d(1.25*noise(vec3(p*0.1, 0.12*iTime))+\n                    0.75*noise(vec3(p*0.1, 0.20*iTime)));\n    }\n    return f;\n}\n\nfloat fbmLow(vec2 uv){\n    float f, dx, dz, w = 0.5;\n    f = dx = dz = 0.0;\n    for(int i = 0; i < 4; ++i){        \n        vec3 n = dnoise2f(uv);\n        dx += n.y;\n        dz += n.z;\n        f += w * n.x / (1.0 + dx*dx + dz*dz);\n        w *= 0.75;\n        uv *= vec2(1.5);\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = 1.0-2.0*(fragCoord.xy / iResolution.xy);\n    uv.y /= iResolution.x/iResolution.y;\n    float t = iTime*0.6;\n    \n    vec2 rv = uv/(length(uv*2.5)*(uv*30.0));\n    uv *= rot2d(0.3*t);\n    float val = 0.5*fbm(uv*2.0*fbmLow(length(uv)+rv-t));\n    uv *= rot2d(-0.6*t);\n    \n    #ifdef INVERT\n    \tfragColor = 1.0-1.2*vec4( vec3(0.5*fbm(uv*val*8.0)+0.02*r(uv.x,uv.y)), 1.0 );\n    #else\n    \tfragColor = 1.6*vec4( vec3(0.5*fbm(uv*val*8.0)+0.02*r(uv.x,uv.y)), 1.0 );\n    #endif\n    \n    fragColor.rgb *= 3.8;\n    fragColor.rgb = fragColor.rgb/(1.0+fragColor.rgb);\n    fragColor.rgb = smoothstep(0.18, 0.88, fragColor.rgb);\n    //fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}","name":"Image","description":"","type":"image"}]}