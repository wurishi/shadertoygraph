{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Learning how to do nice looking raymarching\n// Heavily borrowed from Inigo Quilez and Shane\n\n#define PI 3.1415926\n\n#define sEPS 0.005 // Minimum surface distance threshold.\n#define FAR 60. // Maximum ray distance threshold.\n#define AA 2 // Anti-Aliasing\n#define SPEED 5.\n#define VOLUMETRIC_STEP_SIZE 0.08\n#define MAX_STEPS 128.\n\n#define ATTENUATION\n#define SHADOWS\n#define AMBIENT_OCCLUSION\n#define PHONG_SHADING\n#define ENABLE_OPAQUE\n#define ENABLE_VOLUMETRIC\n//#define NORMALS_DEBUG\n\nstruct PhongParameters {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float specularExponent;\n};\n\nstruct Material {\n    vec3 color;\n    int textureID;\n    PhongParameters phongParameters;\n};\n\nstruct MapReturn {\n    float sdf;\n    Material material;\n};\n\nstruct VolumetricReturn {\n\tfloat density;\n\tvec3 color;\n};\n\nMaterial brass, white, flesh, brick, missing;\n\n// Produces rotation matrix given theta\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\nfloat noise(vec3 x ) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n\n  vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n  vec2 tex = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\n  return mix( tex.x, tex.y, f.z ) * 2.0 - 1.0;\n}\n\nfloat fbm(vec3 p) {\n  vec3 q = p + iTime * 0.5 * vec3(1.0, -0.2, -1.0);\n  float g = noise(q);\n\n  float f = 0.0;\n  float scale = 0.5;\n  float factor = 2.02;\n\n  for (int i = 0; i < 6; i++) {\n      f += scale * noise(q);\n      q *= factor;\n      factor += 0.21;\n      scale *= 0.5;\n  }\n\n  return f;\n}\n\nvec3 sphereInversion(vec3 p, vec3 c, float r) {\n\tvec3 d = p - c;\n\tfloat d2 = dot(d, d);\n\treturn c + (r * r / d2) * d;\n}\n\nvoid setMaterials() {\n    PhongParameters brassParameters = PhongParameters(vec3(0.329412, 0.223529, 0.027451), vec3(0.780392, 0.568627, 0.113725), vec3(0.992157, 0.941176, 0.807843), 27.8974);\n    PhongParameters whiteParameters = PhongParameters(vec3(0.1), vec3(1.), vec3(0.), 1.);\n    \n    brass = Material(vec3(.7098, .651, .2588), -1, brassParameters);\n    flesh = Material(vec3(153./255.,45./255.,27./255.), -1, whiteParameters);\n    white = Material(vec3(1., 1., 1.), -1, whiteParameters);\n    brick = Material(vec3(1., 1., 1.), 2, whiteParameters);\n    missing = Material(vec3(0., 0., 0.), -1, whiteParameters);\n}\n\nMapReturn planeSDF(vec3 samplePoint, vec3 normal, float height, Material material) {\n    MapReturn mp;\n    mp.sdf = abs(dot(samplePoint, normal) - height);\n    mp.material = material;\n    return mp;\n}\n\nMapReturn boxSDF(vec3 samplePoint, vec3 bounds, Material material) {\n    MapReturn mp;\n    vec3 q = abs(samplePoint) - bounds;\n    mp.sdf = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    mp.material = material;\n    return mp;\n}\n\nMapReturn sphereSDF(vec3 samplePoint, float size, Material material) {\n\tMapReturn mp;\n\tmp.sdf = length(samplePoint) - size;\n\tmp.material = material;\n\treturn mp;\n}\n\nMapReturn opUnion(MapReturn a, MapReturn b) {\n    if (a.sdf > b.sdf) return b;\n    else return a;\n}\n\nMapReturn opSmoothUnion(MapReturn a, MapReturn b, float k) {\n    MapReturn mp;\n    float h = clamp( 0.5 + 0.5*(b.sdf-a.sdf)/k, 0.0, 1.0 );\n    mp.sdf = mix( b.sdf, a.sdf, h ) - k*h*(1.0-h);\n    // TODO - Material mixing?\n    mp.material = a.material;\n    return mp;\n}\n\nMapReturn map(vec3 position) {\n\tposition.yz *= rot(.07*position.x);\n    position.z += sin(position.x)*.1;\n    position.y += sin(position.x+1.)*.04;\n    \n    //position.z += sin(position.x*3.)*.1;\n    \n    float scale = sin(position.x/4.+6.)/3. + 1.;\n    scale = 1.;\n    \n    MapReturn floorD = planeSDF(position, vec3(0., 1., 0.), -1.*scale, brick);\n    MapReturn ceilingD = planeSDF(position, vec3(0., 1., 0.), 1.*scale, brick);\n    MapReturn floorsD = opUnion(floorD, ceilingD);\n    MapReturn leftWallD = planeSDF(position, vec3(0., 0., 1.), -1.*scale, brick);\n    MapReturn rightWallD = planeSDF(position, vec3(0., 0., 1.), 1.*scale, brick);\n    MapReturn wallsD = opUnion(leftWallD, rightWallD);\n    \n    position.x -= iTime*SPEED+2.;\n    \n    MapReturn sphereD = sphereSDF(position, .3, brass);\n    \n    return opUnion(opUnion(floorsD, wallsD), sphereD);\n    //return opUnion(floorsD, wallsD);\n}\n\nMapReturn alsoOldMap(vec3 position) {\n\tfloat scaling = 1.;\n\t\n\tfor (int i = 0; i < 8; i++) {\n\t\tposition = 2. * fract(.5 * position + .5) - 1.;\n\t\t\n\t\tfloat r2 = dot(position, position);\n\t\tfloat scalingFactor = (1.1 + 0.5 * smoothstep(-0.3, 0.3, cos(0.1 * iTime))) / r2;\n\t\tposition *= scalingFactor;\n\t\tscaling *= scalingFactor;\n\t}\n\t\n\tMapReturn mp;\n\tmp.sdf = .25 * abs(position.y) / scaling;\n\tmp.material = white;\n\treturn mp;\n}\n\nMapReturn infiniteGrid(vec3 position, float s, Material material) {\n\tMapReturn mp;\n\t\n\tposition = position - round(position);\n\t\n\tvec2 q = abs(position.xy) - s;\n\tfloat beam1 = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n\t\n\tq = abs(position.xz) - s;\n\tfloat beam2 = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n\t\n\tq = abs(position.zy) - s;\n\tfloat beam3 = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n\t\n    mp.sdf = min(beam1, min(beam2, beam3));\n    mp.material = material;\n    return mp;\n}\n\nMapReturn rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float surfaceDistance, distanceTravelled = 0.;\n    Material material = missing;\n    \n    for (float i = 0.; i < MAX_STEPS; i++) {\n        MapReturn sdfResult = map(rayOrigin + rayDirection * distanceTravelled);\n        surfaceDistance = sdfResult.sdf;\n        \n        \n        if (surfaceDistance < sEPS) {\n            material = sdfResult.material;\n            break;\n        }\n        \n        if (distanceTravelled > FAR) break;\n        \n        distanceTravelled += surfaceDistance*0.75;\n    }\n    \n    MapReturn mp;\n    mp.sdf = distanceTravelled;\n    mp.material = material;\n    return mp;\n}\n\nVolumetricReturn volumetricSphereSDF(vec3 position, float radius, vec3 color) {\n\tVolumetricReturn vr;\n\tvr.color = color;\n\t\n\tvr.density = -(length(position) - radius);\n\t\n\treturn vr;\n}\n\nVolumetricReturn volumetricBoxSDF(vec3 position, vec3 bounds, vec3 color) {\n\tVolumetricReturn vr;\n\tvr.color = color;\n\t\n    vec3 q = abs(position) - bounds;\n    vr.density = -length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    \n    return vr;\n}\n\nVolumetricReturn volumetricMap(vec3 position) {\n\tposition.x -= iTime*SPEED+10.;\n\t\n\tVolumetricReturn sphereD = volumetricSphereSDF(position, 5., vec3(1.));\n\tfloat f = fbm(position+iTime)*.5;\n\tsphereD.density += f;\n\treturn sphereD;\n}\n\nvec4 volumetricRayMarch(vec3 rayOrigin, vec3 rayDirection, float opaqueDepth) {\n\tvec3 currentPosition = rayOrigin;\n\t\n\tvec4 res = vec4(0.);\n\t\n\tfor (float i = 0.; i < MAX_STEPS; i++) {\n\t\tfloat currentDepth = length(currentPosition - rayOrigin);\n\t\t\n\t\tif (currentDepth >= opaqueDepth) break;\n\t\t\n\t\tVolumetricReturn volume = volumetricMap(currentPosition);\n\t\t\n\t\tif (volume.density > 0.) {\n\t\t\tvec3 sunDirection = normalize(vec3(iTime*SPEED+1., 0., 0.) - currentPosition);\n\t\t\tfloat diffuse = clamp(volumetricMap(currentPosition).density-volumetricMap(currentPosition + 0.3 * sunDirection).density/ 0.3, 0., 1.); \n\t\t\t\n\t\t\tvec3 lin = vec3(0.60,0.60,0.75) * 1.1 + 0.8 * vec3(1.0,0.6,0.3) * diffuse;\n\t\t\t\n\t\t\tvec4 color = vec4(mix(vec3(1.), vec3(0.), volume.density), volume.density);\n\t\t\t\n\t\t\tcolor.rgb *= lin;\n\t\t\tcolor.rgb *= color.a;\n\t\t\tres += color * (1. - res.a);\n\t\t}\n\t\t\n\t\tcurrentPosition += rayDirection * VOLUMETRIC_STEP_SIZE;\n\t\t\n\t\tif (currentDepth >= FAR) break;\n\t}\n\t\n\treturn res;\n}\n\nvec3 getNormal(in vec3 p) {\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z)).sdf-map(vec3(p.x-eps,p.y,p.z)).sdf,\n\t\tmap(vec3(p.x,p.y+eps,p.z)).sdf-map(vec3(p.x,p.y-eps,p.z)).sdf,\n\t\tmap(vec3(p.x,p.y,p.z+eps)).sdf-map(vec3(p.x,p.y,p.z-eps)).sdf\n\t));\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    //n = abs(n)/1.732051;\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nfloat softShadow(vec3 rayOrigin, vec3 rayDirection, float minDist, float maxDist, float w) {\n    float shade = 1.;\n    const int maxIterations = 32;\n    \n    float dist = minDist;\n    float stepDist = maxDist/float(maxIterations);\n    \n    for (int i = 0; i < maxIterations; i++) {\n        float h = map(rayOrigin + rayDirection*dist).sdf;\n        shade = min(shade, w*h/dist);\n        \n        dist += clamp(h, 0.0005, stepDist*2.);\n        \n        if (h < 0.001 || dist > maxDist) break;\n    }\n    \n    return min(max(shade, 0.) + 0.4, 1.);\n}\n\nfloat calculateAmbientOcclusion(vec3 rayOrigin, vec3 surfaceNormal) {\n    const float AO_SAMPLES = 5.;\n    float r = 0.;\n    float w = 0.5;\n    float dist;\n    \n    for (float i = 1.; i < AO_SAMPLES+1.1; i++) {\n        dist = i/AO_SAMPLES;\n        r += w*(dist - map(rayOrigin + surfaceNormal * dist).sdf);\n        w *= 0.5;\n    }\n    \n    return 1. - clamp(r, 0., 1.);\n}\n\n/* Implementation not working\nfloat brdf(vec3 position, vec3 rayDirection, vec3 lightDirection) {\n    vec3 halfway = (lightDirection + rayDirection)/length(lightDirection + rayDirection);\n    vec3 normal = getNormal(position);\n    \n    float dotvh = dot(rayDirection, halfway);\n    float dotnh = dot(normal, halfway);\n    float dotnl = dot(normal, lightDirection);\n    float dotnv = dot(normal, rayDirection);\n    \n    float g_v = 2. * dotnh * dotnv / dotvh;\n    float g_l = 2. * dotnh * dotnl / dotvh;\n    float g = g_v * g_l;\n\n    float fresnel = 0.7 + 0.3 * pow(1.-dotvh, 5.);\n    \n    float rough2 = pow(0.7, 2.);\n    float d = rough2 / (PI * pow(pow(dotnh, 2.) * (rough2 - 1.) + 1., 2.));\n    \n    float final = fresnel * g * d / (4. * dotnl * dotnv);\n    \n    return final;\n}*/\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n    vec3 lightPosition = rayOrigin;\n    \n    // Scene color is initialized to black\n    vec3 sceneColor = (vec3(.529,.808,.922)+rayDirection.y)*0.2;\n    \n    MapReturn raymarchResult = rayMarch(rayOrigin, rayDirection);\n    \n    #ifdef ENABLE_OPAQUE\n    vec4 volumetricContribution = volumetricRayMarch(rayOrigin, rayDirection, raymarchResult.sdf);\n    #else\n    vec4 volumetricContribution = volumetricRayMarch(rayOrigin, rayDirection, FAR);\n    #endif\n    \n    float surfaceDistance = raymarchResult.sdf;\n    Material objectMaterial = raymarchResult.material;\n    \n    #ifdef ENABLE_OPAQUE\n    if (surfaceDistance < FAR) {\n        \n        vec3 surfacePoint = rayOrigin + rayDirection * surfaceDistance;\n        \n        vec3 surfaceNormal = getNormal(surfacePoint);\n        \n        // TODO - bump map here updates surfaceNormal\n        \n        #ifdef NORMALS_DEBUG\n        vec3 objectColor = surfaceNormal;\n        #else\n        vec3 objectColor;\n        if (objectMaterial.textureID == -1) {\n        \tobjectColor = objectMaterial.color;\n        } else {\n        \tobjectColor = tex3D(iChannel2, surfacePoint, surfaceNormal);\n        }\n        \n        #endif\n        \n        vec3 lightDirection = lightPosition-surfacePoint;\n        float lightDistance = max(length(lightDirection), .001); // Distance from light to surface point\n        lightDirection /= lightDistance; // Normalize\n       \n        #ifdef ATTENUATION\n        float attenuation = min(1.0 / (lightDistance*0.3 + lightDistance*lightDistance*0.05), 1.);\n        #else\n        float attenuation = 1.;\n        #endif\n        \n        // Phong Lighting Approach\n        // TODO - Investigate BRDF\n        PhongParameters phong = objectMaterial.phongParameters;\n        \n        float phongDiffuse = max(0.0, dot(surfaceNormal, lightDirection));\n        float phongSpecular = max(0.0, dot(reflect(-lightDirection, surfaceNormal), -rayDirection));\n        phongSpecular = pow(phongSpecular, phong.specularExponent);\n        \n        // IQ Soft Shadows\n        #ifdef SHADOWS\n        float shadow = softShadow(surfacePoint, lightDirection, sEPS*2., lightDistance, 32.);\n        #else\n        float shadow = 1.;\n        #endif\n        \n        // Ambient occlusion\n        #ifdef AMBIENT_OCCLUSION\n        float ambientOcclusion = calculateAmbientOcclusion(surfacePoint, surfaceNormal);\n        #else\n        float ambientOcclusion = 1.;\n        #endif\n    \n        #ifdef PHONG_SHADING\n        sceneColor = objectColor*(phongDiffuse*phong.diffuse + phong.ambient) \n                   + phongSpecular*phong.specular*0.75;\n        #else\n        sceneColor = objectColor;\n        #endif\n                   \n        sceneColor *= attenuation*shadow*ambientOcclusion;\n        \n        //sceneColor += (1.-attenuation)*vec3(.3, 0., 0.);\n    }\n    #endif\n    \n    #ifdef ENABLE_VOLUMETRIC\n    vec3 finalColor = mix(sceneColor, volumetricContribution.rgb, volumetricContribution.a);\n    #else\n    vec3 finalColor = sceneColor; \n    #endif\n    \n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setMaterials();\n\n    // Screen coords [-1, 1]\n    vec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.y;\n    \n    vec3 total = vec3(0);\n    \n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            vec2 updatedFragCoord = (fragCoord + vec2(float(i)/float(AA),float(j)/float(AA)));\n            vec2 uv = (updatedFragCoord - iResolution.xy*0.5) / iResolution.y;\n    \n            vec3 rayOrigin = vec3(iTime*SPEED - 2., 0., 0.);\n            \n            vec3 lookAt = rayOrigin + vec3(1., 0., 0.);\n\n            float FOV = 1.25;\n            vec3 forward = normalize(lookAt - rayOrigin);\n            vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n            vec3 up = cross(forward, right);\n\n            vec3 rayDirection = normalize(uv.x*right + uv.y*up + forward/FOV);\n            \n            \n            total += render(rayOrigin, rayDirection);\n        }\n    }\n    \n    total /= float(AA*AA);\n    \n    fragColor = vec4(clamp(total, 0., 1.), 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cKfDG","date":"1734397634","viewed":48,"name":"RayMarch w/ Materials","username":"emilyel","description":"ray","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}