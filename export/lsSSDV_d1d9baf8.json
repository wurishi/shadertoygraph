{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n#define MaxSteps 40\n#define MinimumDistance 0.00005\n#define normalDistance     0.001\n\n#define Iterations 7\n#define Scale  3.0\n#define FieldOfView 3.0\n#define NonLinearPerspective 1.0\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.32184\n#define Diffuse 0.8\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0,0.7,0.358824)\n#define LightDir2 vec3(1.0,-1.0,1.0)\n#define LightColor2 vec3(0.5,0.633333,0.2)\n#define Offset vec3(0.92858,0.92858,0.32858)\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular\nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\nfloat DE(in vec3 z)\n{\n\tz  = abs(1.0-mod(z,2.0));\n\tfloat time = 0.3*iTime;\n\tfloat d = 1.0;\n\tfor (int n = 0; n < Iterations; n++) \n    {\n\t\tz.xy = rotate(z.xy,2.0*cos( time/8.0));\n\t\tz.yz = rotate(z.yz,2.0*sin( time/200.0));\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\treturn d-normalDistance;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(0.7, 0.8, 1.0);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash3(p+0.0), hash3(p+1.0),f);\n}\n\n\nmat4 rotationMat( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t     0.0,                      0.0,                      0.0,        1.0 );\n}\n\n\nvec4 rayMarch(in vec3 from, in vec3 dir) \n{\n\tfloat totalDistance = 0.0;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i<MaxSteps; i++) \n    {\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos);\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n    if (distance>0.1) return exp(2.0*distance)*vec4(1.0, 0.5, 0.0, 1.0);  \n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    // animation\t\n\tfloat time = iTime;\n\ttime += 15.0*smoothstep(  15.0, 25.0, iTime );\n\ttime += 20.0*smoothstep(  65.0, 80.0, iTime );\n\ttime += 35.0*smoothstep( 105.0, 135.0, iTime );\n\ttime += 20.0*smoothstep( 165.0, 180.0, iTime );\n\ttime += 40.0*smoothstep( 220.0, 290.0, iTime );\n\ttime +=  5.0*smoothstep( 320.0, 330.0, iTime );\n\tfloat time1 = (time-10.0)*1.5 - 167.0;\n\tfloat time2 = time;\n    const float s = 1.1;\n\tmat4 mm;\n    mm = rotationMat( vec3(0.4,0.1,3.4) + \n                      0.15*sin(0.1*vec3(0.40,0.30,0.61)*time1) + \n                      0.15*sin(0.1*vec3(0.11,0.53,0.48)*time1));\n    mm[0].xyz *= s;\t\n    mm[1].xyz *= s;\n    mm[2].xyz *= s;\t\n\tmm[3].xyz = vec3( 0.15, 0.05, -0.07 ) + 0.05*sin(vec3(0.0,1.0,2.0) + 0.2*vec3(0.31,0.24,0.42)*time1);\n\t\n    // camera\n\tfloat an = 1.0 + 0.1*time2 - 6.2*m.x;\n\tfloat cr = 0.15*sin(0.2*time2);\n    float cr2 = 0.6*smoothstep(10.0,20.0,time2);\n    vec3 dro = cr2 * vec3(sin(an),0.25,cos(an));\n    vec3 ro = 0.05*iTime*vec3(0.0,0.0,1.0) + 0.01*dro; \n    \n    vec3 ta = vec3( 0.0, 0.0 + 0.13*cos(0.3*time2), 0.0 );\n\tta += 0.05*noise(  0.0 + 1.0*time );\n\tro += 0.05*noise( 11.3 + 1.0*time );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n\tfragColor = rayMarch(ro, rd);\n}\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsSSDV","date":"1415980900","viewed":442,"name":"Menger's dream","username":"jamiep","description":"Playing with Menger.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","menger"],"hasliked":0,"parentid":"","parentname":""}}