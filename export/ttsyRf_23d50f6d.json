{"ver":"0.1","info":{"id":"ttsyRf","date":"1639745385","viewed":162,"name":"Neural SDF toy","username":"lirfu","description":"You are looking at a small neural network (MLP) that models a SDF.  The bounding sphere back-wall shows the distance from surface passed through sine function.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","neuralnetwork"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Move mouse to rotate around.\n\n#define HIT_EPS 1E-3\n#define HIT_MAX 1E1\n#define GRAD_EPS 1E-3\n#define PI 3.141592653589\n\nvec3 X = vec3(1.,0.,0.);\nvec3 Y = vec3(0.,1.,0.);\nvec3 Z = vec3(0.,0.,1.);\n\nvec3 cam_loc;\nvec3 cam_dir;\n//vec3 cam = vec3(0., 0., -5.);\n//vec3 light = vec3(0., 3., 0.);\n\nstruct Ray\n{\n    float t;\n    vec3 r0;\n    vec3 rd;\n};\n\nstruct Hit\n{\n    vec3 p;\n    vec3 n;\n    float d;\n};\n\nvec3 ray_to_point(in Ray r) {\n    return r.r0 + r.t * r.rd;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - 1.;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2(-b-h, -b+h);\n}    \n\nfloat relu(float x)\n{\n    return max(0., x);\n}\n\nvec3 relu(vec3 x)\n{\n    return max(vec3(0.), x);\n}\n\n\n// This is the neural network.\nfloat nn(vec3 x)\n{        \n    mat3 w1 = mat3(\n        sin(iTime*1.), 0.0, 0.0, \n        0.0, sin(iTime*.5), 0.0, \n        0.0, 0.0, sin(iTime*.25)\n    );\n    \n    for (int i = 0; i < 1; i++)\n    {\n        x = relu(w1 * x);\n    }\n    vec3 wo = vec3(1., 1., 1.);\n    return dot(wo,x);\n\n    //vec3 q = abs(x) - vec3(.5);\n  \t//return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);  // Box.\n    //return length(x) - .5;  // Sphere.\n}\n\nvec3 normal(vec3 x)  // Simplex gradient.\n{\n    const vec2 k = vec2(GRAD_EPS,0);\n    return vec3(\n    \tnn(x + k.xyy) - nn(x - k.xyy),\n        nn(x + k.yxy) - nn(x - k.yxy),\n        nn(x + k.yyx) - nn(x - k.yyx)\n    ) / GRAD_EPS / 2.;\n}\n\nvec3 normal_tetra(vec3 x)\n{\n    const vec2 k = vec2(GRAD_EPS,-GRAD_EPS);\n    return normalize( \n        k.xyy * nn( x + k.xyy ) + \n        k.yyx * nn( x + k.yyx ) + \n        k.yxy * nn( x + k.yxy ) + \n        k.xxx * nn( x + k.xxx ) \n    );\n}\n\nfloat sdf(vec3 x, inout Hit h)\n{    \n    h.p = x;\n    h.n = normal(h.p);  // QUEST: Is variable chaining good for shaders (leaving result in cache).\n    \n    return nn(x);\n}\n\nHit trace(inout Ray r)\n{\n    Hit h;\n    \n    // Bounding sphere, return if outside.\n    vec2 bounds = sphIntersect(r.r0, r.rd);\n    if (bounds[0] < 0.)\n    {\n     \tr.t = HIT_MAX;\n        return h;\n    }  \n    r.t = bounds[0] + HIT_EPS;\n    \n    h.d = HIT_EPS + 1.;\n    for (int i = 0; i < 80 && r.t < bounds[1] && h.d > HIT_EPS; i++)\n    {\n        h.d = sdf(r.r0 + r.t * r.rd, h);\n        \n        // March through normalized space.\n        float ln = length(h.n);\n        if (ln > HIT_EPS)\n            h.d /= ln;\n            \n        r.t += max(0., h.d);\n    }\n    \n    if (r.t >= bounds[1])  // Exited bounds.\n    {\n        r.t = HIT_MAX;\n    }\n    \n    if (h.d <= 0.)  // Calculate normal over bounds if we're under the surface.\n    {\n        h.n = normalize(h.p);\n    } else {  // Otherwise calculate the actual normal.\n        h.n = normalize(h.n);\n    }\n    return h;\n}\n\nvec3 shade(inout Ray r)\n{\n    Hit h = trace(r);\n\n    // Background.\n    if (r.t >= HIT_MAX) return texture(iChannel0, r.rd).rgb;\n\n    //return vec3(.2,1.,0.) * ( relu(dot(h.n, normalize(cam_loc - h.p))) + 0.2 );  // Phong flashlight\n    //return (h.p + 1.) * .5;  // Position.\n    //return (h.n + 1.) * .5;  // Normals\n    return vec3(dot(h.n, -cam_dir));  // View angle\n    //return vec3(1. - 0.1 * r.t);  // Depth\n}\n\nRay perspective(in vec3 loc, in vec3 dir, vec3 up, in vec2 uv, float fov)\n{\n    vec3 x = cross(dir, up);\n    vec3 sensor = uv[0] * x + uv[1] * up + dir / tan(fov / 2.);\n    return Ray(0., loc, normalize(sensor));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uv_n = (uv * 2. - 1.) * vec2(1., iResolution.y / iResolution.x);\n\n    // Mouse rotation.\n    float phi = PI * ((-0.55+0.5*sin(iTime ))*0. + iMouse.x / iResolution.x * 2. - 1.);\n    float theta = PI * (-iMouse.y / iResolution.y);\n    \n    float sp = sin(phi), cp = cos(phi);\n    float st = sin(theta), ct = cos(theta);\n    \n    cam_loc = 5. * vec3(sp*st, ct, cp*st);\n    cam_dir = normalize(-cam_loc);  // Look at origin.\n    vec3 tang = vec3(sp*ct, -st, cp*ct);  // View up vector follows shpere.\n    \n    Ray r = perspective(cam_loc, cam_dir, tang, uv_n, PI / 4.);\n    vec3 col = shade(r);\n    \n    // Visualize distance on back of BV.\n    float b = sphIntersect(r.r0, r.rd).y;\n    vec3 pt = r.r0 + r.rd * b;\n    float d = nn(pt) / length(normal(pt));\n    vec3 dist = mix(vec3(0.), vec3(.9), pow(sin(10.*d), 2.));\n    \n    if (r.t >= HIT_MAX && b >= 0.) {\n        col = dist;\n    }\n    \n    // Gamma.\n    //col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}