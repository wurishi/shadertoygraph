{"ver":"0.1","info":{"id":"NljBW3","date":"1652845255","viewed":346,"name":"\"Walk on Sphere\" interpolator","username":"dpiponi","description":"Using idea at MonteCarloGeometryProcessing\n\nInterpolating colour at each point in image from boundary() function that gives the colour at the boundary.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["math","montecarlo","pde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See https://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/\n\n// Random numbers using code at\n// https://stackoverflow.com/a/17479300\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n// Distance to boundary of screen, working from the inside\nfloat sdf(in vec2 uv)\n{\n    return min(min(uv.x, uv.y), min(1. - uv.x, 1. - uv.y));\n}\n\n// Compute colour at boundary...\nvec3 boundary(in vec2 xy)\n{\n    return xy.x > 0.5 ? vec3(0.5 * xy.y, 0.5 + 0.5 * cos(15.0 * xy.y), 0.0)\n                      : vec3(1.0 - xy.y, 0.5 + 0.5 * sin(22.0 * xy.y), 1.0);\n}\n\n// ...and interpolate to rest of image.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 total = vec3(0.0, 0.0, 0.0);\n\n    // number_of_walks is essentially the number of samples\n    // per pixel so noise is proportional\n    // to 1/sqrt(this).\n    const int number_of_walks = 200;\n    \n    const int steps_per_walk = 5; // Seems low but looks fine\n    \n    // Average n random walks\n    for (int walk = 0; walk < number_of_walks; ++walk)\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        \n        // Take m steps...\n        for (int step = 0; step < steps_per_walk; ++step)\n        {\n            // ...each of which has a random direction but whose\n            // length is the radius of the largest circle you can\n            // place at the current point just touching the\n            // boundary. That's more efficient of taking lots\n            // of tiny steps and it's obvious that taking a random\n            // walk from the centre of a circle hits the boundary\n            // at uniformly distributed points.\n            float r = sdf(uv);\n            float theta = 2. * 3.14159265 * random(uv + vec2(step, walk));\n            uv.x += r * cos(theta);\n            uv.y += r * sin(theta);\n        }\n     \n        total += boundary(uv);\n    }\n    \n    total = total / float(number_of_walks);\n\n    // Output to screen\n    fragColor = vec4(total, 1.0);\n}","name":"Image","description":"","type":"image"}]}