{"ver":"0.1","info":{"id":"wdyGRW","date":"1570175016","viewed":250,"name":"Reaction diffusion testing","username":"tantalum","description":"testing reaction diffusion mechanics, and learning to use buffers","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["testing","hypnotic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n//\tThis shader is for testing with reaction/diffusion and multiple buffers\n//\tCode is a mess, will condense and comment at some point.\n*/\n\n#define res iResolution.xy\nvec4 blur3x3(){\n \t\n    /*\n\t\t[0.0625, 0.125 ,0.0625]\n\t\t[0.125 ,  0.5  , 0.125]\n\t\t[0.0625, 0.125 ,0.0625]\n\t*/\n    float offset = 1.0;\n\n    // get pixels from surrounding grid\n    vec4 C = texture(iChannel0, vec2(gl_FragCoord.x/res.x, gl_FragCoord.y/res.y))*0.25;\n    vec4 N = texture(iChannel0, vec2(gl_FragCoord.x/res.x, gl_FragCoord.y/res.y - offset/res.y))*0.125;\n    vec4 S = texture(iChannel0, vec2(gl_FragCoord.x/res.x, gl_FragCoord.y/res.y + offset/res.y))*0.125;\n    vec4 E = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y))*0.125;\n    vec4 W = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y))*0.125;\n\n    vec4 NE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y + offset/res.y))*0.0625;\n    vec4 NW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y + offset/res.y))*0.0625;\n    vec4 SE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y - offset/res.y))*0.0625;\n    vec4 SW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y - offset/res.y))*0.0625;\n    \n   \tvec4 o = C+N+S+E+W+NE+NW+SE+SW;\n    \n    return o;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor = vec4(blur3x3());    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 mod289(vec3 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\nreturn mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v) {\nconst vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n   0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n  -0.577350269189626,  // -1.0 + 2.0 * C.x\n   0.024390243902439); // 1.0 / 41.0\n// First corner\nvec2 i  = floor(v + dot(v, C.yy) );\nvec2 x0 = v -   i + dot(i, C.xx);\n\n\n// Other corners\nvec2 i1;\n //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n //i1.y = 1.0 - i1.x;\ni1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n // x0 = x0 - 0.0 + 0.0 * C.xx ;\n // x1 = x0 - i1 + 1.0 * C.xx ;\n // x2 = x0 - 1.0 + 2.0 * C.xx ;\nvec4 x12 = x0.xyxy + C.xxzz;\nx12.xy -= i1;\n\n// Permutations\ni = mod289(i); // Avoid truncation effects in permutation\nvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n+ i.x + vec3(0.0, i1.x, 1.0 ));\n\nvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\nm = m*m ;\nm = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\nvec3 x = 2.0 * fract(p * C.www) - 1.0;\nvec3 h = abs(x) - 0.5;\nvec3 ox = floor(x + 0.5);\nvec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\nm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\nvec3 g;\ng.x  = a0.x  * x0.x  + h.x  * x0.y;\ng.yz = a0.yz * x12.xz + h.yz * x12.yw;\nreturn 130.0 * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    float flow = 1.0;\n    float seedScale = 0.1;\n    float seedThreshold = 0.9;\n    \n    float dA = 1.0;\n    float dB = 0.5;\n    float feed = 0.0367;\n    float k = 0.061;\n    \n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord.xy / res.xy;\n    vec2 brush = iMouse.xy;\n    // load current values for a and b\n    vec4 currentColor = texture(iChannel0, uv);\n    float a = currentColor.r;\n    float b = currentColor.g;\n    \n    \n    float dist = distance(brush.xy, gl_FragCoord.xy);\n    float radius = 256.0*(0.5*sin(iTime*0.23)+0.5);\n\tif(dist < radius) {\n\t\tfloat ratio = 1.0 - dist/256.0;\n\t\t//b += 0.5 * ratio * 1.0;\n        k += 0.25* ratio;\n\t}\n    \n    //Vary kill and feed spatially\n    k += 0.0025*sin(uv.y*3.0+iTime*0.3587);\n    feed += 0.0025*cos(uv.x*3.0+iTime*0.4963);\n    \n\n    if (iFrame < 30) {\n        a = 0.0;\n        b = snoise(vec2((gl_FragCoord.x) * seedScale, (gl_FragCoord.y) * seedScale));\n        if (b < seedThreshold) b = 0.0;\n    }\n\n    float offset = 1.0;\n    float scroll = 0.0;\n\n    // get pixels from surrounding grid\n    vec4 N = texture(iChannel0, vec2(gl_FragCoord.x/res.x - scroll, gl_FragCoord.y/res.y - offset/res.y));\n    vec4 S = texture(iChannel0, vec2(gl_FragCoord.x/res.x - scroll, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 E = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x - scroll, gl_FragCoord.y/res.y));\n    vec4 W = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x - scroll, gl_FragCoord.y/res.y));\n\n    vec4 NE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x - scroll, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 NW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x - scroll, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 SE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x - scroll, gl_FragCoord.y/res.y - offset/res.y));\n    vec4 SW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x - scroll, gl_FragCoord.y/res.y - offset/res.y));\n\n    // diffusion values\n    float diff1 = 0.2*flow;\n    float diff2 = 0.05*flow;\n\n    // calculate laplace of A\n    float lapA = 0.0;\n    lapA += a * -1.0;\n    lapA += N.r * diff1;\n    lapA += S.r * diff1;\n    lapA += E.r * diff1;\n    lapA += W.r * diff1;\n    lapA += NE.r * diff2;\n    lapA += NW.r * diff2;\n    lapA += SE.r * diff2;\n    lapA += SW.r * diff2;\n\n\n    // calculate laplace of B\n    float lapB = 0.0;\n    lapB += b * -1.0;\n    lapB += N.g * diff1;\n    lapB += S.g * diff1;\n    lapB += E.g * diff1;\n    lapB += W.g * diff1;\n    lapB += NE.g * diff2;\n    lapB += NW.g * diff2;\n    lapB += SE.g * diff2;\n    lapB += SW.g * diff2;\n\n\n    // calculate diffusion reaction\n    a += ((dA * lapA) - (a*b*b) + (feed * (1.0-a))) * 1.0;\n    b += ((dB * lapB) + (a*b*b) - ((k + feed) * b)) * 1.0;\n\n\n    a = clamp(a, 0.0, 1.0);\n    b = clamp(b, 0.0, 1.0);\n\n\n    vec4 newColor = vec4(a, b, 0.0, 1.0);\n    fragColor = newColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    float flow = 1.0;\n    float seedScale = 0.01;\n    float seedThreshold = 0.1;\n    \n    float dA = 1.0;\n    float dB = 0.5;\n    float feed = 0.0367;\n    float k = 0.061;\n\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord.xy / res.xy;\n    vec2 brush = iMouse.xy;\n    // load current values for a and b\n    vec4 currentColor = texture(iChannel0, uv);\n    float a = currentColor.r;\n    float b = currentColor.g;\n    \n    \n    /*\n    float dist = distance(brush.xy, gl_FragCoord.xy);\n\tif(dist < 30.0) {\n\t\tfloat ratio = 1.0 - dist/30.0;\n\t\tb += 0.5 * ratio * 1.0;\n\t}\n    */\n    \n    //Vary kill and feed spatially\n    k += 0.0025*sin(uv.y*3.0+iTime*0.3587);\n    feed += 0.0025*cos(uv.x*3.0+iTime*0.4963);\n\n    float offset = 1.0;\n\n    // get pixels from surrounding grid\n    vec4 N = texture(iChannel0, vec2(gl_FragCoord.x/res.x, gl_FragCoord.y/res.y - offset/res.y));\n    vec4 S = texture(iChannel0, vec2(gl_FragCoord.x/res.x, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 E = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y));\n    vec4 W = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y));\n\n    vec4 NE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 NW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 SE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y - offset/res.y));\n    vec4 SW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y - offset/res.y));\n\n    // diffusion values\n    float diff1 = 0.2*flow;\n    float diff2 = 0.05*flow;\n\n    // calculate laplace of A\n    float lapA = 0.0;\n    lapA += a * -1.0;\n    lapA += N.r * diff1;\n    lapA += S.r * diff1;\n    lapA += E.r * diff1;\n    lapA += W.r * diff1;\n    lapA += NE.r * diff2;\n    lapA += NW.r * diff2;\n    lapA += SE.r * diff2;\n    lapA += SW.r * diff2;\n\n\n    // calculate laplace of B\n    float lapB = 0.0;\n    lapB += b * -1.0;\n    lapB += N.g * diff1;\n    lapB += S.g * diff1;\n    lapB += E.g * diff1;\n    lapB += W.g * diff1;\n    lapB += NE.g * diff2;\n    lapB += NW.g * diff2;\n    lapB += SE.g * diff2;\n    lapB += SW.g * diff2;\n\n\n    // calculate diffusion reaction\n    a += ((dA * lapA) - (a*b*b) + (feed * (1.0-a))) * 1.0;\n    b += ((dB * lapB) + (a*b*b) - ((k + feed) * b)) * 1.0;\n\n\n    a = clamp(a, 0.0, 1.0);\n    b = clamp(b, 0.0, 1.0);\n\n\n    vec4 newColor = vec4(a, b, 0.0, 1.0);\n    fragColor = newColor;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    float flow = 1.0;\n    float seedScale = 0.01;\n    float seedThreshold = 0.1;\n    \n    float dA = 1.0;\n    float dB = 0.5;\n    float feed = 0.0367;\n    float k = 0.061;\n    \n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord.xy / res.xy;\n    vec2 brush = iMouse.xy;\n    // load current values for a and b\n    vec4 currentColor = texture(iChannel0, uv);\n    float a = currentColor.r;\n    float b = currentColor.g;\n    \n    /*\n    float dist = distance(brush.xy, gl_FragCoord.xy);\n\tif(dist < 30.0) {\n\t\tfloat ratio = 1.0 - dist/30.0;\n\t\tb += 0.5 * ratio * 1.0;\n\t}\n\t*/\n    \n    //Vary kill and feed spatially\n    k += 0.0025*sin(uv.y*3.0+iTime*0.3587);\n    feed += 0.0025*cos(uv.x*3.0+iTime*0.4963);\n\n    float offset = 1.0;\n\n    // get pixels from surrounding grid\n    vec4 N = texture(iChannel0, vec2(gl_FragCoord.x/res.x, gl_FragCoord.y/res.y - offset/res.y));\n    vec4 S = texture(iChannel0, vec2(gl_FragCoord.x/res.x, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 E = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y));\n    vec4 W = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y));\n\n    vec4 NE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 NW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y + offset/res.y));\n    vec4 SE = texture(iChannel0, vec2(gl_FragCoord.x/res.x + offset/res.x, gl_FragCoord.y/res.y - offset/res.y));\n    vec4 SW = texture(iChannel0, vec2(gl_FragCoord.x/res.x - offset/res.x, gl_FragCoord.y/res.y - offset/res.y));\n\n    // diffusion values\n    float diff1 = 0.2*flow;\n    float diff2 = 0.05*flow;\n\n    // calculate laplace of A\n    float lapA = 0.0;\n    lapA += a * -1.0;\n    lapA += N.r * diff1;\n    lapA += S.r * diff1;\n    lapA += E.r * diff1;\n    lapA += W.r * diff1;\n    lapA += NE.r * diff2;\n    lapA += NW.r * diff2;\n    lapA += SE.r * diff2;\n    lapA += SW.r * diff2;\n\n\n    // calculate laplace of B\n    float lapB = 0.0;\n    lapB += b * -1.0;\n    lapB += N.g * diff1;\n    lapB += S.g * diff1;\n    lapB += E.g * diff1;\n    lapB += W.g * diff1;\n    lapB += NE.g * diff2;\n    lapB += NW.g * diff2;\n    lapB += SE.g * diff2;\n    lapB += SW.g * diff2;\n\n\n    // calculate diffusion reaction\n    a += ((dA * lapA) - (a*b*b) + (feed * (1.0-a))) * 1.0;\n    b += ((dB * lapB) + (a*b*b) - ((k + feed) * b)) * 1.0;\n\n\n    a = clamp(a, 0.0, 1.0);\n    b = clamp(b, 0.0, 1.0);\n\n\n    vec4 newColor = vec4(a, b, 0.0, 1.0);\n    fragColor = newColor;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n#define pi 3.14159265359\n#define offset 1.0\n#define pixelToTexelRatio (iResolution.xy/iChannelResolution[0].xy)\n#define aspect iResolution.x/iResolution.y\n\n\nvec2 stdNormalMap(in vec2 uv) \n{\n    float height = texture(iChannel0, uv).r;\n    return -vec2(dFdx(height), dFdy(height)) * pixelToTexelRatio;\n}\n\nvec2 createNormalMap(in vec2 uv)\n{\n\tvec2 a = 1.0/iChannelResolution[0].xy;\n    \n    float g = texture(iChannel0,uv).r;\n    float h = texture(iChannel0,uv + a * vec2(offset,0)).r;\n    float i = texture(iChannel0,uv + a * vec2(0,offset)).r;\n    \n    return (g - vec2(h,i));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 oxy = vec2(-0.0015,0.0015);\n    oxy.y *= aspect;\n    vec2 uv2 = uv-oxy;\n\n    vec2 normal = createNormalMap(uv);\n    normal *= -1.0;\n    normal += 0.5;\n    vec3 color = vec3(normal,1.0);\n    \n    //Grab A and B\n    float a =  texture(iChannel0, uv).r;\n    float b =  texture(iChannel0, uv).g;\n    \n    float a2 = texture(iChannel0, uv2).r;\n    float b2 = texture(iChannel0, uv2).g;\n    \n    vec3 color2 = vec3(a/2.0,b/1.2,b+a*2.0)*0.5;\n    vec3 color3 = vec3(0.0);\n    if(a2 <= 0.5){\n        \n    \tcolor3 = vec3(a2/2.0,b2/1.2,b2+a2*2.0);\n    }\n\n    vec3 lightDir = vec3(0.39,1.0,0.0);\n    lightDir = normalize(lightDir);\n    //color = normalize(color);\n    vec3 light = vec3(pow(clamp(dot(lightDir,color),0.0,1.0),3.0));\n    fragColor = vec4(clamp(color2+color3+light,0.0,1.0),1.0);    \n    \n}","name":"Buffer D","description":"","type":"buffer"}]}