{"ver":"0.1","info":{"id":"mdVyRz","date":"1696702094","viewed":34,"name":"my mandelbulb","username":"helenhsn","description":"Mandelbulb with polynomial degree varying in time.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DIST 250.0\n#define SURF_DIST .001\n\n\nvec3 z_n(vec3 z, float n, float r) {\n    /*\n    Computes the z to the power of n in spherical space\n    */\n    float th = acos(z.y/r);\n    float phi = asin(z.z/length(z.xz));\n     \n    float n_th = n*th;\n    float n_phi = n*phi;\n    float sin_nth = sin(n_th);\n    return pow(r, n) * vec3(sin_nth*sin(n_phi), cos(n_th), sin_nth*cos(n_phi));\n}\n\n\n// Hubbard-Douady potential SDF\nfloat distToMandelbulb(vec3 p) \n{\n    float n = clamp((1.0-cos(iTime*0.3))*10.0, 1.5, 10.0);\n    float n_minus_1 = n-1.0;\n    float size_bulb = 4.0;\n    vec3 z = p;\n    float lz_2 = dot(z,z); // length squared of vector z = modul\n    float r = sqrt(lz_2);\n    float dz = 1.0; // derivative\n\n    for (int i = 0; i<7; i++) \n    {\n        \n        dz = n * dz * pow(r, n_minus_1) + 1.0; //dz_k+1 = n * dz_k * length(z)**(n-1) + 1\n        z = p + z_n(z, n, r);\n        lz_2 = dot(z, z);\n        r = sqrt(lz_2);\n        if (r > size_bulb) break;\n    }\n    return 0.5*r*log(r)/dz;\n}\n\nfloat testSDFs(vec3 p) \n{\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    float r = 1.0;\n    \n    return min(length(p-c)-r, p.y+10.0); \n}\n\nfloat map(vec3 p) \n{\n    return min(distToMandelbulb(p), p.y+6.0);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, inout int nb_steps)\n{\n    float d = 0.0;\n    \n    for (int i = 0; i<MAX_STEPS; i++) \n    {\n        nb_steps = i+1;\n        vec3 p = ro + rd*d;\n        float dist = map(p);\n        d += dist;\n        if (d > MAX_DIST || dist < SURF_DIST) break;\n    }\n    return d;\n}\n\nvec3 initCamera(vec2 uv, vec3 eye, vec3 look_at, float zoom)\n{\n    vec3 fwd = normalize(look_at - eye);\n    vec3 rgt = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));\n    vec3 local_up = cross(rgt, fwd);\n    return zoom*fwd + uv.x*rgt + uv.y * local_up;\n    //return local_up;\n}\n\n\n\nvec3 getNormal(vec3 p) \n{\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 n = vec3(\n    map(p+eps.xyy) - map(p-eps.xyy), \n    map(p+eps.yxy) - map(p-eps.yxy),\n    map(p+eps.yyx) - map(p-eps.yyx));\n    return normalize(n);\n}\n\nvec3 getColor(vec3 eye, vec3 p, float sdf, int nb_steps) \n{\n    vec3 l = normalize(vec3(0.0,100.0, 0.0) - p);\n    vec3 n = getNormal(p);\n    float intensity = clamp(dot(n, l), 0.0, 1.0);\n    \n    \n    vec3 color = vec3(0.7, 0.1, 0.1)*float(nb_steps)*0.1;\n    \n    \n    int temp;\n    float dist = rayMarch(p+n*SURF_DIST*2.0, l, temp);\n    if (dist < length(l - p)) \n        intensity *=0.8;\n    \n    return intensity * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    \n    vec3 look_at = vec3(0.0, 0.0, -1.0); //look at\n    vec3 ro = 3. * length(look_at) * vec3(cos(0.8), 1.0, cos(0.8));\n    float zoom = 1.0;\n    vec3 rd = initCamera(uv, ro, look_at, zoom);\n    \n    int nb_steps = 0;\n    float sdf = rayMarch(ro, rd, nb_steps);\n    vec3 intersection = ro + sdf * rd;\n    \n    \n    vec3 color = getColor(ro, intersection, sdf, nb_steps);\n\n    fragColor = vec4(pow(color, vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}