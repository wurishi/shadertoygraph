{"ver":"0.1","info":{"id":"mtfXRl","date":"1723435607","viewed":30,"name":"dispersion/aberration faking","username":"impliedchaos","description":"little experiment with faking chromatic aberration.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = atan(1.0)*4.0;\nconst float TAU = 2.0 * PI;\n\n// Rotate & scale affine transformation matrix.\nmat3 rotsc(float a, float k){float c=cos(a)*k;float s=sin(a)*k;return(mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0));}\n\n// Sinusoidal plasma.\nfloat plas(vec2 uv) {\n    float h = cos(uv.y*PI+sin(mod(iTime,TAU))*4.0+4.0)*sin(uv.x*PI-cos(mod(iTime/3.125,TAU))*2.4+2.4)+sin(uv.y*PI+cos(mod(iTime/0.75,TAU))*3.3+3.3)*cos(uv.x*PI-cos(mod(iTime,TAU))*2.1+2.1);\n    uv = (vec3(uv,1.0)*rotsc(mod(iTime*0.2,TAU),0.6)).xy;\n    h += cos(uv.y*PI+2.2*sin(mod(iTime,TAU))*3.0)*sin(uv.x*PI*2.42-cos(mod(iTime,TAU))*2.2);\n    return(h*0.125+0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    // Get pixel above and bottom-left and bottom-right of coords to create a plane.\n    vec2 a = ((fragCoord.xy + vec2(0.0,1.0)) - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 b = ((fragCoord.xy + vec2(-1.0,-1.0)) - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 c = ((fragCoord.xy + vec2(1.0,-1.0)) - 0.5 * iResolution.xy)/iResolution.y;\n    // Use plasma function to get heights of a, b, and c.\n    float ah = plas(a);\n    float bh = plas(b);\n    float ch = plas(c);\n    // get lines AB and AC.\n    vec3 ab = vec3(a,ah)-vec3(b,bh);\n    vec3 ac = vec3(a,ah)-vec3(c,ch);\n    // Cross product of AB and AC to get surface normal of plane ABC.\n    vec3 p = normalize(cross(ab,ac));\n    p = faceforward(p,vec3(0,0,1),p);\n    // Scale the surface normal by the height to get the texture offset.\n    float h = plas(uv);\n    vec3 vp = normalize(vec3(0.0,0.0,10.0)-vec3(uv,h));\n    // Use seperate refraction values for each of R G and B.\n    vec3 ur = refract(vp,p,1.313);\n    vec3 ug = refract(vp,p,1.333);\n    vec3 ub = refract(vp,p,1.353);\n    vec2 offsetr = ur.xy*(h/ur.z);\n    vec2 offsetg = ug.xy*(h/ug.z);\n    vec2 offsetb = ub.xy*(h/ub.z);\n    fragColor.r = texture(iChannel0,uv+offsetr+vec2(0.5)).r;\n    fragColor.g = texture(iChannel0,uv+offsetg+vec2(0.5)).g;\n    fragColor.b = texture(iChannel0,uv+offsetb+vec2(0.5)).b;\n}","name":"Image","description":"","type":"image"}]}