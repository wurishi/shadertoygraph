{"ver":"0.1","info":{"id":"DtyBWm","date":"1702129920","viewed":49,"name":"Ray Marched Earth and Moon","username":"Chroma_Crash","description":"Planets in 3D this time.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","primitive"],"hasliked":0,"parentid":"DlyBDw","parentname":"Ray Marched Primitives"},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define STEPS 128\n#define MAX_MARCH 60.0\n#define HIT_DISTANCE 0.001\n\n#define LIGHT_DIRECTION normalize(vec3(0.8, 1, 1))\n#define LIGHT_COLOR vec3(1, 1, 0.8)\n#define AMBIENT 0.1\n\n#define DISTANCE 24.0\n\n#define PIXEL_SIZE 1.0\n\nstruct Planet {\n    vec3 position;\n    float size;\n    vec3 rotation;\n    vec3[5] palette;\n    float[4] levels;\n    float weight;\n    float offset;\n    float minimum;\n    float spin;\n};\n\nconst vec3[5]  EARTH_COLORS =  vec3[] (vec3(72, 74, 119), vec3(77, 101, 180), vec3(35, 144, 99), vec3(30, 188, 115),\n                                        vec3(255, 255, 255));\nconst float[4] EARTH_LEVELS = float[] (0.41, 0.45, 0.53, 0.63);\n\nconst vec3[5]  MOON_COLORS =  vec3[] (vec3(69, 41, 63), vec3(107, 62, 117), vec3(127, 112, 128), vec3(155, 171, 178),\n                                       vec3(255, 255, 255));\nconst float[4] MOON_LEVELS = float[] (0.2, 0.35, 0.4, 0.8);\n\n#define EARTH Planet(vec3(0, 2, 0), 2.0, vec3(PI/8.0, 0.0, 0.0), EARTH_COLORS, EARTH_LEVELS, 0.4, 0.0, 0.45, 0.0)\n#define MOON  Planet(vec3(8, 4, 0), 1.1, vec3(PI/8.0, 0.0, PI/2.0),  MOON_COLORS,  MOON_LEVELS, 0.3, 0.3, 0.0, 1.5)\n\n#define TOTAL_PLANETS 2\nPlanet[TOTAL_PLANETS] PLANETS = Planet[](EARTH, MOON);\n\nvec3[4] PALETTE = vec3[](vec3(0.6, 0.8, 0.7), vec3(0.9, 0.2, 0.2), vec3(0.2, 0.2, 0.9),\n                         vec3(0.2, 0.9, 0.2));\n                         \n                         \nmat3 rotate_x(float theta) {\n    return mat3(1,           0,          0,\n                0,  cos(theta), sin(theta),\n                0, -sin(theta), cos(theta));;\n}\n\nmat3 rotate_y(float theta) {\n    return mat3(cos(theta), 0, -sin(theta),\n                         0, 1,           0,\n                sin(theta), 0,  cos(theta));\n}\n\nmat3 rotate_z(float theta) {\n    return mat3(cos(theta), -sin(theta), 0,\n                sin(theta),  cos(theta), 0,\n                         0,           0, 1);;\n}\n\nfloat samplePerlin(vec3 uv) {\n    float[4] zoom    = float[] (0.1, 0.2, 0.6, 1.0);\n    float[4] weights = float[] (0.4, 0.4, 0.1, 0.1);\n    \n    float value = 0.0;\n    \n    for (int i = 0; i < 4; i++) {\n        value += texture(iChannel0, uv * zoom[i]).x * weights[i];\n    }\n    \n    return value;\n}\n\nfloat samplePerlin(vec2 uv) {\n    float[4] zoom    = float[] (0.1, 0.2, 0.6, 1.0);\n    float[4] weights = float[] (0.4, 0.3, 0.2, 0.1);\n    \n    float value = 0.0;\n    \n    for (int i = 0; i < 4; i++) {\n        value += texture(iChannel1, uv * zoom[i]).x * weights[i];\n    }\n    \n    return value;\n}\n\nvec2 sphereUV(vec3 p) {\n    vec3 n = normalize(p);\n    float longitude = 0.5 - atan(n.z, n.x) / (2.0 * PI);\n    float latitude = 0.5 + asin(n.y) / PI;\n\n    vec2 uv = vec2(longitude, latitude);\n    return uv;\n}\n\nfloat planetNoise(vec3 p, Planet planet) {\n    mat3 x = rotate_x(planet.rotation.x);\n    mat3 y = rotate_y(planet.rotation.y - iTime * planet.spin);\n    mat3 z = rotate_z(planet.rotation.z);\n    p = z * y * x * p;\n    vec3 n = normalize(p);\n    return samplePerlin(n + vec3(0, planet.offset, 0));\n}\n\nfloat sdPlanet(vec3 p, Planet planet) {\n    vec3 n = normalize(p);\n    float extra = max(planet.minimum, planetNoise(p, planet));\n \n    return length(p - n * extra * planet.weight) - planet.size;\n}\n\nvec2 select(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 world(vec3 p) {\n    vec2 res = vec2(sdPlanet(p - PLANETS[0].position, PLANETS[0]), 0);\n    \n    for (int i = 1; i < TOTAL_PLANETS; i++) {\n        float sphere = sdPlanet(p - PLANETS[i].position, PLANETS[i]);\n        res = select(res, vec2(sphere, i));\n    }\n\n    return res;\n}\n\nvec3 get_normal(in vec3 p) {\n    const vec3 s = vec3(0.01, 0.0, 0.0);\n\n    float g_x = world(p + s.xyy).x - world(p - s.xyy).x;\n    float g_y = world(p + s.yxy).x - world(p - s.yxy).x;\n    float g_z = world(p + s.yyx).x - world(p - s.yyx).x;\n\n    vec3 normal = vec3(g_x, g_y, g_z);\n\n    return normalize(normal);\n}\n\nfloat specular(vec3 cam, vec3 pos, vec3 normal) {\n    vec3 viewDir = normalize(cam - pos);\n    vec3 reflectDir = reflect(-LIGHT_DIRECTION, normal);\n    \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 6.0);\n    return 0.75 * spec;\n}\n\nfloat diffuse(vec3 normal) {\n    float diffuse = (dot(LIGHT_DIRECTION, normal) + 1.0) / 2.0;\n    return diffuse;\n}\n\nvec4 raymarch(in vec3 ro, in vec3 rd) {\n    float traveled = 0.01;\n    \n    vec3 p = ro;\n\n    for (int i = 0; i < STEPS; i++) {\n        p = ro + traveled * rd;\n        \n        vec2 world = world(p);\n    \n        float max_travel = world.x;\n        \n        if (max_travel < HIT_DISTANCE) {\n            return vec4(p, world.y);\n        }\n        \n        if (traveled > MAX_MARCH) {\n            break;\n        }\n        \n        traveled += max_travel;\n    }\n    return vec4(p, -1);\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float traveled = 0.3;\n    \n    float res = 1.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec2 world = world(ro + traveled * rd);\n        \n        float max_travel = world.x;\n        \n        if (max_travel < HIT_DISTANCE) {\n            return 0.0;\n        }\n        if (traveled > MAX_MARCH) {\n            break;\n        }\n        \n        res = min(res, 2.0 * max_travel / traveled);\n        \n        traveled += max_travel;\n    }\n    \n    return res;\n}\n\nvec4 render(vec2 uv, float time) {\n    uv *= 0.8;\n\n    time = time / 2.0;\n    vec3 ro = vec3(cos(time) * DISTANCE, DISTANCE * 5.0 / 12.0, sin(time) * DISTANCE);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float d = PI/8.0;\n    \n    mat3 rx = rotate_x(d);\n                  \n    d = -time - PI / 2.0;\n    \n    mat3 ry = rotate_y(d);\n                   \n    rd = ry * rx * rd;\n    \n    vec4 march = raymarch(ro, rd);\n    \n    vec3 pos = march.xyz;\n    vec3 normal = get_normal(pos);\n    \n    if (march.w < -0.1) {\n        vec2 u = sphereUV(rd);\n        float stars = samplePerlin(u * 120.0);\n        float mult = (stars > 0.7) ? (stars - 0.7) : 0.0;\n        return vec4((mult + 0.05) * vec3(0.9 + mult, 0.9 + mult, 1.0), 1.0);\n    }\n    \n    Planet planet = PLANETS[int(march.w)];\n    float height = planetNoise(pos - planet.position, planet);\n    \n    vec3 col;\n    int i;\n    for (i = 0; i < 4; i++) {\n        if (height <= planet.levels[i]) {\n            break;\n        }\n    }\n    col = planet.palette[i] / 255.0;\n    \n    float lighting = diffuse(normal);\n    \n    if (i < 2) {\n        lighting += specular(ro, pos, normal);\n    }\n    \n    float shadow_cast = pow(shadow(pos, LIGHT_DIRECTION), 0.25);\n    \n    float gamma_corrected = pow(shadow_cast * lighting, 2.2);\n    \n    vec3 complete = max(AMBIENT, gamma_corrected) * LIGHT_COLOR * col;\n    \n    return vec4(complete, 1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \n    vec4 col = render(uv, iTime / 2.0);\n\n    fragColor = col;\n}\n\n\n","name":"Image","description":"","type":"image"}]}