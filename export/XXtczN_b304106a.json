{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//Infinity spheres render by Brilcon\n\n// (RU) Рендеринг бесконечных шаров от Brilcon\n\n//--------Functions  \\Функции\n\nvec3 getNormalMap(vec3 pos)\n{\n  return texture(iChannel1,pos.xy).rgr-0.5;\n}\n\nvec4 distSphere(vec3 p,vec3 c,float r)\n{\n  // xyz - normal \\нормаль\n  // w - distance \\расстояние\n  float Cell=10.0;\n  c=(floor((p)/Cell)+0.5)*Cell;\n  vec3 sphereToViewDir=normalize(p-c);\n  return vec4(sphereToViewDir,distance(p,c)-r);\n}\n\n  \n//-------Main   \\Основная функция вывода\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  vec2 uv = ( (fragCoord.xy / iResolution.xy)-0.5)* vec2(iResolution.x/iResolution.y, 1.0)+0.5;\n\n  vec3 camRot=vec3(-1.6,-3.14,0.0)+7.0*vec3(iMouse.y/iResolution.y,iMouse.x/iResolution.x,1.0);\n   vec3 camPos=vec3(iTime*3.0,0.,1.0) +  0.0*vec3(iMouse.x/iResolution.x,0.0,iMouse.y/iResolution.y);\n\n  vec3 col=vec3(0.0);\n\n  vec3 delta=vec3(uv.xy,1)-vec3(0.5,1.05,0.0);\n  float xs=sin(camRot.x); float xc=cos(camRot.x);\n  float ys=sin(camRot.y); float yc=cos(camRot.y);\n  float zs=sin(camRot.z); float zc=cos(camRot.z);\n  delta*=mat3(\n    1.0,0,0,\n    0,xc,-xs,\n    0,xs,xc);\n  delta*=mat3(\n    yc,0,ys,\n    0,1.0,0,\n    -ys,0,yc);\n    delta=normalize(delta);\n    \n    vec3 pos=camPos;\n\n  \n    // Ray marching ----------                      \\Реймарчинг\n    float dist; //distance to nearest surface point \\ расстояние до ближайшей точки поверхности\n    vec3 n;     //surface normal                    \\ нормаль поверхности\n    for(int i=0;i<200;i++)\n    {\n      vec4 rayCheck=distSphere(pos,vec3(0),2.0);\n      float distCheck=rayCheck.w;\n      dist=distCheck;\n      n=-rayCheck.xyz;\n      pos+=delta*dist;\n      if(dist<0.001*distance(pos,camPos)){break;}\n    }\n  \n  \n\n  n+=getNormalMap(n)-0.5;\n  vec3 surfToView=pos-camPos;\n  \n  vec3 reflectDir=-reflect(surfToView, n );\n \n  col=vec3(1.0,1.0,0.5)*texture(iChannel0,reflectDir).rgb;\n  col*=2.5/(1.0+distance(pos,camPos)*0.05);\n  col+=vec3(0.05,0.07,0.1)*(1.0-1.0/(1.0+distance(pos,camPos)*0.05));\n\n  if(dist>0.001*distance(pos,camPos)){col=vec3(0.05,0.07,0.1);}\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// Music code by Brilcon\n\n// (RU) Процедурная музыка от Brilcon\nfloat chords[16] = float[16](261.0, 395.0, 296.0,222.0,261.0, 395.0, 296.0,222.0,332.0,249.0,373.0,279.0,209.0,313.0,235.0,352.0);\n\n\n\nfloat FM(float t,float freq,float modFreq,float m)\n{\nreturn sin(6.2831*freq*t +m*sin(6.2831*modFreq*t));\n}\n\n// Sawtooth function for random number generator\nfloat saw(float x)\n{\nreturn 2.0*mod(x,3.1415)/3.1415-1.0;\n}\n\nfloat noise(float t)\n{\nt=floor(t*20000.0)/20000.0;\nt=t*43434242.43234;\nfloat n=t;\nn=saw(7.1231*n+3.1232*saw(11.12314*n+5.564*saw(13.03242*n+7.564*saw(17.03242*t))));\nn=saw(7.1231*n+3.1232*saw(11.12314*n+5.564*saw(13.03242*n+7.564*saw(17.03242*t))));\nn=saw(17.1231*n+3.1232*saw(11.12314*n+5.564*saw(13.03242*n+7.564*saw(17.03242*t))));\nn=saw(63.1231*n+3.1232*saw(11.12314*n+5.564*saw(13.03242*n+7.564*saw(17.03242*t))));\n\nreturn n;\n}\n\nfloat distort(float signal,float coof)\n{\n  float effect;\n  if(signal<0.0){effect=-pow(-signal,1.0/(coof+1.0));}\n  else{effect=pow(signal,1.0/(coof+1.0));}\n  \n  return effect;\n}\n\nfloat kick(float t)\n{\nt=mod(t,0.5);\nfloat freq=300.0-pow(t*90000.0,0.2)*30.0;\nreturn sin(6.2831*freq*t)*exp(-10.0*t);\n}\n\nfloat clap(float t)\n{\nt=mod(t,1.0);\nfloat multiply=sin(299.0*t)*1.0+0.5;\nreturn noise(t)*exp(-19.0*t)*multiply;\n}\n\nfloat bass(float t,float freq)\n{\n\nt=mod(t,0.25);\nfloat sawtooth=mod(t,1.0/(freq))*6.2831*freq-0.5;\nreturn sawtooth*exp(-9.0*t);\n}\n\n \nfloat organ(float t,float freq)\n{\n    t=mod(t,0.5);\n    \n   return FM(t,freq,freq*4.0,1.0-t)*exp(-9.0*t);\n}\n\n\n\nvec2 PROCESS(float time)\n{\nfloat cycle_time=mod(time,32.0);\n\nfloat perc_vol=0.0; if(cycle_time>8.0 && cycle_time<24.0){perc_vol=0.5;}\nfloat bass_vol=0.0; if(cycle_time>16.0){bass_vol=0.13;}\n\n    float PERCUSSION=distort( kick(time)+clap(time+0.5),0.7) ;\n    \n    float chordProg=mod(float(time+0.0),16.0);\n    float ff=chords[int(chordProg)];\n    \n    vec2 ORGAN=organ(time+0.25,ff/2.0)*vec2(1.0,0.7)+ organ(time+0.25,ff)*vec2(0.95,0.8)+organ(time+0.25,ff*(1.0+1.0/2.0))*vec2(0.8,0.95)+organ(time+0.25,ff*(1.0+1.0/4.0))*vec2(0.7,1.0) ;\n    float BASS= bass(time,ff/4.0);\n    \n    vec2 sound=perc_vol*vec2(PERCUSSION);\n    sound+=0.2*ORGAN;\n    sound+=bass_vol*BASS;\n    return sound;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    \n    vec2 sound;\n    float delay=0.05;\n    //----Reverb\n    for(float r=0.0;r<1.0;r+=0.01)\n    {\n   sound+=0.02*PROCESS(time-delay)*  1.0/(1.0+39.0*r*r*r)*vec2( noise(r+123.0)+1.0 ,noise(r+433.0)+1.0) ;\n   delay+=(noise(r)+2.0)/105.0;\n    }\n    //-----\n sound+=PROCESS(time)*0.8;\n \n    return vec2( sound );\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XXtczN","date":"1734876140","viewed":138,"name":"Infinity spheres +Music","username":"Brilcon","description":"My first ever shader:)\n  This shader uses ray-marching algorithm for rendering a huge number of spheres\n\n+A little procedural music with reverb effect","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["raymarching","music"],"hasliked":0,"parentid":"","parentname":""}}