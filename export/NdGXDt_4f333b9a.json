{"ver":"0.1","info":{"id":"NdGXDt","date":"1635462873","viewed":125,"name":"concentric extrusion","username":"do","description":"extrusion","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["extrusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//concentric extrusion\n//2021\n//do\n\nconst int steps = 250;\nfloat eps = 0.001;\nfloat dmin = 0.;\nfloat dmax = 750.;\nconst int aa = 2;\n\nconst int octaves = 5;\nfloat hurst = 0.5;\n\nconst int seed = 123457;\n\nfloat h11(float p) {\n    uvec2 n = uint(int(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat h21(vec2 p) {\n    uvec2 n = uvec2(ivec2(p)) * uvec2(uint(int(seed)),2531151992.0);\n    uint h = (n.x ^ n.y) * uint(int(seed));\n    return float(h) * (1./float(0xffffffffU));\n}\n\nfloat n2(vec2 x) { \n\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);  \n    float n = p.x + p.y * 57.;  \n\n    return mix(mix(h11(n+0.),h11(n+1.),f.x),\n               mix(h11(n+57.),h11(n+58.),f.x),f.y);  \n}\n\nfloat f2(vec2 x) {\n\n    float s = 0.;\n    float h = exp2(-hurst);     \n    float f = 1.;\n    float a = 0.5;\n\n    for(int i = 1; i < octaves; i++) {\n \n        s += a * n2(f * x);\n        f *= 2.;\n        a *= h;\n    }    \n\n    return s;\n}\n\nmat2 rot(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n \nmat3 camOrthographic(vec3 ro,vec3 ta,float r) {\n     \n     vec3 w = normalize(ta - ro); \n     vec3 p = vec3(sin(r),cos(r),0.);           \n     vec3 u = normalize(cross(w,p)); \n     vec3 v = normalize(cross(u,w));\n\n     return mat3(u,v,w); \n} \n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat extr(vec3 p,float d,float h) {\n    vec2 w = vec2(d,abs(p.z) - h);\n    return min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\nfloat sdif(float d1,float d2,float k) {\n    float h = clamp(.5-.5*(d2+d1)/k,0.,1.);\n    return mix(d2,-d1,h) +k*h +(1.-h);\n}\n\nvec2 scene(vec3 p) {\n\n    vec2 res = vec2(1.,0.);\n\n    float d = 0.;\n\n    d = extr(p,sin(length(p.xy)*3.),1.5);\n    res = opu(res,vec2(sdif(d,p.z,.5)*.5,2.));  \n    return res;\n\n}\n\nvec2 rayScene(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = dmin;\n    float e = dmax;  \n\n    for(int i = 0; i < steps; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(abs(dist.x) < eps || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 95; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,125. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < eps || t > 5.) { break; }\n\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * eps;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\nvec3 renderScene(vec3 ro,vec3 rd) {\n \nvec2 d = rayScene(ro, rd);\n\nvec3 col = vec3(1.);\n\nif(d.y >= 0.) {\n\nvec3 p = ro + rd * d.x;\nvec3 n = calcNormal(p);\nvec3 l = normalize(vec3(10.));\n\nvec3 h = normalize(l - rd);\nvec3 r = reflect(rd,n);\n\ncol += vec3(f2(p.xz+f2(p.yx*3.)*5.));\n\nfloat amb = clamp(0.5 + 0.5 * n.y,0.,1.);\n\nfloat dif = clamp(dot(n,l),0.0,1.0);\n\nfloat fre = pow(clamp(1. + dot(n,rd),0.0,1.0),2.0);\nfloat ref = smoothstep(-.2,.2,r.y);\n\nvec3 linear = vec3(0.);\n \ndif *= shadow(p,l);\nref *= shadow(p,r);\n\nlinear += dif * vec3(.5);\nlinear += amb * vec3(0.01,0.05,0.05);\n\ncol = col * linear;\ncol = mix(col,vec3(1.),1.-exp(-0.00001 *d.x*d.x*d.x)); \n\n}\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n \nvec3 color = vec3(0.);\nvec3 ro = vec3(10.,10.,15.);\nvec3 ta = vec3(0.0);\n\nro.xy *= rot(iTime*.1);\n\nfor(int k = 0; k < aa; ++k) {\n    for(int l = 0; l < aa; ++l) {\n\n    vec2 o = vec2(float(l),float(k)) / float(aa) - .5;\n\n    vec2 uv = (2. * (fragCoord.xy + o) -\n    iResolution.xy) / iResolution.y; \n\n    mat3 cm = camOrthographic(ro,ta,0.);\n    vec3 rd = cm * normalize(vec3(uv.xy,2.));\n\n    vec3 col = renderScene(ro,rd);    \n\n    col = pow(col,vec3(.4545));\n    color += col;\n    }\n}\n\ncolor /= float(aa*aa);\nfragColor = vec4(color,1.0);\n\n}","name":"Image","description":"","type":"image"}]}