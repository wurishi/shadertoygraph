{"ver":"0.1","info":{"id":"lscyzr","date":"1517764127","viewed":721,"name":"Old School Flame Effect","username":"yvtjp","description":"Based on the algorithm I implemented using Microsoft Visual C++ 6.0 when I was 7â€“12. Pretty amazing to see that it's now possible to run it in real-time without heavy optimizations.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["flame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final composition -- based on https://www.shadertoy.com/view/lt3SWj\n\nconst float BloomUndersample = 20.;\n\nvec3 acesToneMapping(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel1, uv);\n    \n    vec2 offs = vec2(50. / BloomUndersample) / iResolution.xy;\n    \n    vec2 uv0 = uv / BloomUndersample;\n    for (float x = -0.5; x <= 0.5; x += 0.2) {\n        for (float y = -0.5; y <= 0.5; y += 0.2) {\n\t\t\tfragColor += texture(iChannel0, uv0 + vec2(x, y) * offs)\n                 * (max(0.7 - length(vec2(x, y)), 0.) * .0002);\n        }\n    }\n    \n    // vignette\n    vec2 vigPos = ((uv.xy - 0.5) * iResolution.xy) / max(iResolution.x, iResolution.y);\n    float vig = 1. - dot(vigPos, vigPos);\n    fragColor.xyz *= vig * vig;\n    \n    // And tone mapping\n    fragColor.xyz = acesToneMapping(fragColor.xyz);\n    fragColor.xyz = sqrt(fragColor.xyz); // gamma correction\n\n    // Color adjustment\n    fragColor.xyz = mix(vec3(dot(fragColor.xyz, vec3(1.0)) / 3.0), fragColor.xyz, 1.2);\n    \n    fragColor.w = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Main code of the flame effect\n\nvec4 fractalNoise(vec2 coord) {\n    vec4 value = vec4(0.0);\n    float scale = 0.5;\n    for (int i = 0; i < 5; i += 1) {\n     \tvalue += texture(iChannel0, coord) * scale;\n        coord *= 2.0;\n        scale *= 0.6;\n    }\n    return value;\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // The following part is the original algorithm:\n    vec2 uv_scaled = uv * vec2(0.04, 0.02);\n    \n    float val = fractalNoise(uv_scaled - vec2(0.0, 1.0) * iTime * 0.008).x;\n    val += fractalNoise(uv_scaled - vec2(0.0, 1.0) * iTime * 0.004).y;\n    \n    // Shape the flame\n    val *= 1.4 - uv.y;\n    val *= 1.0 - pow(abs(uv.x - 0.5), 1.0) * 1.0;\n    \n    // Non-linear mapping -- This is the crucial part to \n    // give it a flame-like appearance.\n    val = pow(max(val - 0.5, 0.0), 5.0) * 3.0;\n    val += smoothstep(0.0, 0.2, val);\n    \n    // The bottom part\n    val += pow(1.0 - max(0.0, uv.y - 0.1), 16.0) * 0.05;\n    \n    // Apply tint -- This part deviates from the original algorithm, which\n    // used a gradient mapping (black -> red -> yellow -> white). \n    // I modernized it a bit by replacing the gradient mapping with a linear mapping\n    // + ACES tone mapping as post process.\n    vec3 col = vec3(1.0, 0.3, 0.1) * val;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    if (uv.y < 0.1) {\n       \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Undersampling for bloom effect -- based on https://www.shadertoy.com/view/lt3SWj\n\nconst float BloomUndersample = 20.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= BloomUndersample;\n    if (uv.x > 1. || uv.y > 1.) {\n     \tfragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 offs = vec2(20.) / iResolution.xy;\n    \n    fragColor = vec4(0.);\n    for (float x = -0.5; x <= 0.5; x += 0.1) {\n        for (float y = -0.5; y <= 0.5; y += 0.1) {\n\t\t\tfragColor.xyz += texture(iChannel0, uv +\n                  vec2(x, y) * offs).xyz;\n        }\n    }\t\n    \n    fragColor.w = 1.;\n}","name":"Buf B","description":"","type":"buffer"}]}