{"ver":"0.1","info":{"id":"WdV3R1","date":"1569730446","viewed":151,"name":"Roots of Unity","username":"CodyEthanJordan","description":"Visualizing Newton's method for finding 0s for the complex roots of 1. Work in progress.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float intPow(float a, int n)\n{\n    float o = a;\n    for(int i=0; i <= n-1; ++i)\n    {\n        o*= a;\n    }\n    return o;\n}\n\nvec2 c_from_polar(float r, float theta) {\n  return vec2(r * cos(theta), r * sin(theta));\n}\n\nvec2 c_to_polar(vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\nvec2 c_pow(vec2 c, float e) {\n  vec2 p = c_to_polar(c);\n  return c_from_polar(pow(p.x, e), p.y*e);\n}\n\nvec2 c_div(vec2 self, vec2 other) {\n    float norm = length(other);\n    return vec2(self.x * other.x + self.y * other.y,\n                self.y * other.x - self.x * other.y)/(norm * norm);\n}\n\nvec2 f(vec2 z, float n)\n{\n    return c_pow(z, n) - 1.0;\n}\n\nvec2 f_prime(vec2 z, float n)\n{\n    return n*c_pow(z, n-1.0);\n}\n\nfloat g(float x, float y, float n)\n{\n    return x*x*x - n*x*y*y - 1.0;\n    //return intPow(x, n - n*x*y*y-1.0;\n    //return pow(x,n) - n*x*pow(y, n-1.0) - 1.0;\n}\n\nfloat h(float x, float y, float n)\n{\n    return n*x*x*y-y*y*y;\n    return n*pow(x,n-1.0)*y - pow(y,n);\n}\n\nfloat gx(float x, float y, float n)\n{\n    return n*x*x - n*y*y;\n    return n*pow(x,n-1.0) - n*pow(y, n-1.0);\n}\n\nfloat gy(float x, float y, float n)\n{\n    return -n * (n-1.0) * x * y;\n}\n\nfloat hx(float x, float y, float n)\n{\n    return n * (n-1.0) * x * y;\n}\n\nfloat hy(float x, float y, float n)\n{\n    return n*x*x - n*y*y;\n    return n*pow(x,n-1.0) - n*pow(y, n-1.0);\n}\n\nvec2 newtonIteration(vec2 point)\n{\n    float n = 3.0;\n    float x = point.x;\n    float y = point.y;\n    float nextX = x - (g(x,y,n)*hy(x,y,n) - h(x,y,n)*gy(x,y,n)) / \n        (gx(x,y,n)*hy(x,y,n) - gy(x,y,n)*hx(x,y,n));\n    float nextY = y - (h(x,y,n)*gx(x,y,n) - g(x,y,n)*hx(x,y,n)) / \n        (gx(x,y,n)*hy(x,y,n) - gy(x,y,n)*hx(x,y,n));\n    return vec2(nextX, nextY);\n}\n\nvec2 iter(vec2 point)\n{\n    float n = 3.8 + 2.0*sin(iTime/5.0);\n    //n = 1.81;\n    return point - c_div(f(point, n), f_prime(point, n));\n}\n\nvec3 complexNewton(vec2 initial, float epsilon, int maxIterations)\n{\n    int i = 0;\n \tvec2 current = initial;\n \tvec2 prev = vec2(1000.0,1000.0);\n    while (length(current-prev) > epsilon)\n    {\n        if(i >= maxIterations)\n        {\n            return vec3(current, float(i));\n        }\n        prev = current;\n        current = iter(current);\n        //return current;\n        i++;\n        \n    }\n    return vec3(current, float(i));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0;\n    vec2 uv = scale*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //uv += sin(iTime);\n    //uv.x += -0.8;\n    \n    int maxIterations = 50;\n    vec3 zeroFound = complexNewton(uv, 1.1+sin(iTime), maxIterations);\n    //zeroFound = normalize(zeroFound);\n    //zeroFound += 1.0;\n    vec3 col = vec3(abs(zeroFound.x + zeroFound.y), \n                    abs(zeroFound.x - zeroFound.y)\n                    , zeroFound.y / float(maxIterations));\n    //vec3 col = vec3(zeroFound.x + zeroFound.y, zeroFound.x - zeroFound.y, 0.0);\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}