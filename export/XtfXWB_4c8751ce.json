{"ver":"0.1","info":{"id":"XtfXWB","date":"1439243570","viewed":609,"name":"[SIG15] Bullet Time Matrix","username":"pellicus","description":"\"Matrix Magic Moment\" Bullet Time.\nuncomment #define MIRRORS only on Mac.\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["time","modeling","mirror","matrix","bullet","sig15"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// only on mac ... \n//#define MIRRORS 1\n\n/*\n\tmy contribution to SIG15 contest.\n\twith my tools I modeled the whole scene (helycopter, details around,\n\tmore buildings around and more details on Neo..)\n\tbut..hey...webgl explodes :D. So I spent a lot of time cutting stuff.. \n\tWe need to find out techniques to reduce instruction number in GLSL...\n*/\nconst vec4 bullet_toff = vec4(0.000000,0.200000,0.600000,0.800000);\n\nconst vec4 params = vec4(0.300000,0.000000,0.000000,0.000000);\n\nconst vec4 sky_color = vec4(0.913725,1.000000,0.909804,0.039216);\n\nconst vec3 main_light = vec3(0.504000,0.565500,0.630000);\n\n//const vec4 OPTIONS_PARAMS = vec4(0.000000,0.000000,0.000000,0.000000);\n\nconst vec3 camera_offset = vec3(0.000000,-0.130000,-0.500000);\n\nconst vec4 camera_focus = vec4(-1.312500,1.000000,-0.872500,0.812500);\n\n\n\n#define MAX_ITERATIONS 50\n#define MAX_PRECISION 0.005\n#define SHD_ITERATIONS 16\n#define AO_ITERATIONS 5\n#define AO_STEP 0.12*0.25\n#define CAMERA_NEAR 0.03\n#define CAMERA_FAR 150.0\n#define Math_PI 3.1415926\nint PRIM;\nvec3 P; vec3 N; vec3 UV; vec3 PUV;\nint MATID;\nint CURMATID;\nvec3 RO;\nvec3 RD;\nvec3 ooRD;\nfloat Z;\nfloat Z_cull;\nfloat AO=1.0;\n\n\n#define oU(d1,d2) min(d1,d2)\n\n#define oS(d1,d2) max(-d2,d1)\n#define oSi(d1,d2) max(-d1,d2)\n//#define oB(d1,d2,k) smin(d1,d2,k)\n#define oI(d1,d2) max(d1,d2)\n\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//iq's  polynomial smooth min https://iquilezles.org\nfloat oB( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// A list of usefull distance function to simple primitives, and an example on how to\n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\n\n\n#define PRIM_AABB 1\n#define PRIM_TRIS 2\n#define PRIM_CYL  3\n#define PRIM_CONE 4\n#define PRIM_OBB  5\n#define PRIM_DF 500\n\n#define M(n) CURMATID = n;\n\n\nint dMATID=-1;\n// i => intersection in a pure ray tracing model.\n\n//#define iB(p,x)      rt_AABB(p,x,CURMATID)\n#define iS(p,r)      \n//rt_AABB(p,vec3(r,r,r),CURMATID)\n//#define iC(p,rh)      rt_CYL(p,rh,CURMATID)\n#define iT(a,b,c,n1,n2,n3) rt_T(a,b,c,n1,n2,n3,CURMATID)\n\n// d => distance function in a pur ray marching model.\n#define dM(n) dMATID=z<prevZ?CURMATID:dMATID; CURMATID = n; prevZ=z;\n#define dM_s(n,pr) dMATID=CURMATID=n; float z=pr; float prevZ=z;\n#define dM_e() dMATID=z<prevZ?CURMATID:dMATID; return z;\n\n//#define dOP(X) z=min( X ,z);\n#define dT(a,b,c)\n\n#define PRIM_SLOT_ID    1000\n\n#define PRIM_RM_NORMAL(map)    {vec3 eps = vec3( 0.001, 0.0, 0.0 );N =normalize( vec3( map(P+eps.xyy) - map(P-eps.xyy),map(P+eps.yxy) - map(P-eps.yxy),map(P+eps.yyx) - map(P-eps.yyx) ));}\n\n#define PRIM_RM_AO(map,nits)    { float occ=0.0,sca=1.0;for(int i=0;i<nits;i++){float hr = 0.01 + AO_STEP*float(i);vec3 aopos =  N * hr + P;float dd = map( aopos );occ += -(dd-hr)*sca;sca *= 0.95;} AO= clamp( 1.0 - 3.0*occ, 0.0, 1.0 );  }\n\n\n#define RAYMARCH_OBJ(N,ID,I) float tmin = max(Z_cull,CAMERA_NEAR),tmax = Z,precis = MAX_PRECISION,t = tmin; dMATID =-1; vec3 ro = RO, rd=RD;for( int i=0; i<I; i++ ){    float z=N(ro+rd*t);if(z<precis || t>tmax)break;t+=z;} if(t<Z){MATID=dMATID;Z=t;PRIM=ID;}\n\n\n\nfloat dFloor( vec3 p )\n{\n    return p.y;\n}\nfloat dFloor( vec4 p )\n{\n    return p.y;\n}\n\nfloat dS( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat dS( vec4 p, float s )\n{\n    return length(p.xyz)-s;\n}\n\nfloat dB( vec3 p, vec3 b )\n{\n //return length(max(abs(p)-b,0.0));\n   vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat dB( vec4 p, vec3 b )\n{\n    //return length(max(abs(p)-b,0.0));\n    vec3 d = abs(p.xyz) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n//unisgned\n\n\nfloat dC( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dC( vec4 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dCa( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\n\n\nfloat dRB( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\nfloat dRB( vec4 p, vec3 b, float r )\n{\n    return length(max(abs(p.xyz)-b,0.0))-r;\n}\n\n\n/*\nfloat dCn( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}*/\n// RAYTRACING PRIMITIVES\n\n\n//===========================================\n// ============  AABB Primitive =============\n//===========================================\nvec3 AABB_pos;\nvec3 AABB_ext;\nvoid iB( in vec3 pos, in vec3 ext )\n{ //  ext*=0.25;\n    //  pos*=0.25;pos+=vec3(0,3.0,0);\n    vec3 roo =  RO -pos;\n    vec3 n = ooRD*roo;\n    vec3 k = abs(ooRD)*ext;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return ;\n    if( tN < Z){\n        Z = tN;\n        AABB_pos=pos;\n        AABB_ext=ext;\n        PRIM=PRIM_AABB;\n        MATID=CURMATID;\n    }\n    //    return tN;\n}\n\nbool inB( in vec3 pos, in vec3 ext )\n{\n    //return true;\n    vec3 roo = RO - pos;\n    vec3 n = ooRD*roo;\n    vec3 k = abs(ooRD)*ext;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    Z_cull = tN;\n    return ( tN > tF || tF < 0.0 || tN>Z)?false:true;\n    \n}\n\nvoid mat_AABB(in vec3 p)\n{\n    vec3 a= (p-AABB_pos) / AABB_ext;\n    vec3 aa=abs(a);\n    N = sign(a)*step(0.999,aa); //*2.0-1.0;\n    vec3 n=abs(N);\n    UV=aa;PUV=P;\n    if(n.x>0.0){PUV=vec3(P.y,P.z,0.0);UV=vec3(aa.y,aa.z,0.0);return;}\n    if(n.y>0.0){PUV=vec3(P.x,P.z,0.0);UV=vec3(aa.x,aa.z,0.0);return;}\n    \n}\n\n//===========================================\n//===========================================\n\n\n\nvoid iC( in vec3 pos, in vec2 r_xh )\n{\n    vec3  d = RO - pos;\n    float a = dot( RD.xz, RD.xz );\n    float b = dot( RD.xz, d.xz );\n    float c = dot( d.xz, d.xz ) - r_xh.x*r_xh.x;\n    float t;\n    \n    t = b*b - a*c;\n    if( t>0.0 )\n    {\n        t = -(b+sqrt( t ))/a;\n        vec3 h = RO +RD*t;\n        \n        if(t>0.0 && abs(h.y-pos.y)<r_xh.y && t<Z)\n        {   vec2 n=normalize(h.xz-pos.xz);\n            N = vec3(n.x,0.0,n.y);\n        Z = t;\n        MATID = CURMATID;\n        PRIM = PRIM_CYL;\n        }\n        \n    }\n    \n//    return t-.001;\n    \n}\n\n\n\n\n\n#define MAT_FLOOR  2\n#define MAT_DEFAULT 1\n#define MAT_GRNLITE 3\n#define MAT_FLOOR_TILES 4\n#define MAT_WALL 5\n#define MAT_BRONZE 6\n#define MAT_STEPS 7\n#define MAT_PIPES 8\n#define MAT_FLOOR_A 9\n#define MAT_FLOOR_B 10\n#define MAT_PELLE 11\n#define MAT_VEST 12\n#define MAT_SKIN 13\n#define M_W 14\n#define M_MIR 15\n#define MAT_HELY MAT_VEST\n#define MAT_FX_BULLET MAT_FLOOR_A\nfloat hash( const float n ) {\nreturn fract(sin(n*14.1234512)*51231.545341231);\n}\nfloat hash( const vec2 x ) {\nfloat n = dot( x, vec2(14.1432,1131.15532) );\nreturn fract(sin(n)*51231.545341231);\n}\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\n#define COL(r,g,b) vec3(r/255.,g/255.,b/255.)\nfloat sat( const float a ) { return clamp(a,0.,1.); }\nfloat onCircleAA( const vec2 c, const vec2 centre, const float radius, const float aa ) {\nreturn sat( aa*(radius - distance(c,centre)) );\n}\nfloat onLineX( const vec2 c, const float x ) {\nreturn step(x,c.x)*step(c.x,x);\n}\nfloat onLineY( const vec2 c, const float y ) {\nreturn step(y,c.y)*step(c.y,y);\n}\nfloat onBand( const float c, const float mi, const float ma ) {\nreturn step(mi,c)*step(c,ma);\n}\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\nreturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\n}\nvec3 addKnobAA( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\nvec2 lv = normalize( centre-c );\nreturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircleAA(c, centre, radius, 4. ) );\n}\nfloat onBandAA( const float c, const float mi, const float ma ) {\nreturn sat( (ma-c+1.) )*sat( (c-mi+1.) );\n}\nfloat onRectAA( const vec2 c, const vec2 lt, const vec2 rb ) {\nreturn onBandAA( c.x, lt.x, rb.x )*onBandAA( c.y, lt.y, rb.y );\n}\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\nfloat xl = sat( (c.x-lt.x)/size);\nfloat xr = sat( (rb.x-c.x)/size);\nfloat yt = sat( (c.y-lt.y)/size);\nfloat yb = sat( (rb.y-c.y)/size);\nreturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRectAA( c, lt, rb ) );\n}\nvoid getMaterialColor( const int material, in vec3 UV, out vec4 result ) {\nvec3 col=result.xyz;\nvec2 uv = floor( UV.xy*50.0 );\nfloat huv = hash(uv), huvx = hash(uv.x);\nif (material == MAT_DEFAULT)\n{\nfloat f = mod( floor(UV.x*10.1+0.5) + floor(UV.y*10.0+0.5), 2.0);\ncol = mix(vec3(1,.5,.5),vec3(0,1,1),f);\ncol *=mix(vec3(1,1,1),vec3(0.1,.1,.1),Z/CAMERA_FAR);\n}else\nif( material ==  MAT_FLOOR )\n{\nfloat f = mod( floor(PUV.z+.5) + floor(PUV.x+0.5), 2.0);\ncol = mix(vec3(1,1,0),vec3(0,1,0),f);\ncol *=mix(vec3(1,1,1),vec3(0.1,.1,.1),Z/CAMERA_FAR);\n}else\nif(material==MAT_PELLE)\n{ col = vec3(0.3,0.3,0.3);  }\nelse if(material==    MAT_VEST)\n{ col = vec3(0.052 ,0.051,0.051);  }\nelse if(material==    MAT_SKIN)\n{  col = vec3(0.7 ,0.4,0.4);  }\nelse if(material==    M_W)\n{  col = vec3(0.9 ,0.9,0.9); }\nelse\nif( material == MAT_GRNLITE ) {         uv = mod(uv, vec2(64.)); vec2 centre = mod(uv,vec2(32.,16.));\ncol = mix( COL(90.,98.,69.),COL(152.,149.,125.),(0.75*huv+0.25*mod(uv.x,2.)) );\ncol = mix( col, mix(vec3(243./255.),vec3(169./255.), distance(centre,vec2(16.,8.))/6.5), onCircleAA(centre, vec2(16.,8.), 6.25, 0.75) );\n}\nelse /* if( material == MAT_FLOOR_TILES ) {         uv = mod(uv, vec2(64.)); vec2 uv8 = mod(uv, vec2(64.,7.7));\nfloat h = huv*huvx;\ncol = mix( COL(136.,114.,95.), COL(143.,122.,92.), sat(4.*h) );\ncol = mix( col, COL(175.,126.,89.), sat( 2.*(hash(floor(uv*0.125))+huv-1.35) ) );\ncol = mix( col, COL(21.,103.,83.), sat( onLineX(uv,0.)+onLineY(uv,63.)) );\ncol = mix( col, COL(21.,103.,83.), onLineX(uv,31.)*huv );\nuv8.x = abs(16.-uv8.x);\nfloat d = min( max( uv8.x-8.,abs(uv8.y-4.) ), abs(distance(uv8,vec2(11.,4.))) )+huv;\nvec3 fgcol = mix( col, col*sat(((16.-uv8.y)/12.)), step(d,3.) );\ncol = mix( mix( fgcol, COL(114.,94.,78.), sat(d*(3.5-d)/4.)*step(2.,d) ), col, onRect(uv, vec2(32.,23),vec2(63.,39.) ) );\n} \nelse*/ if( material == MAT_WALL ) {          vec2 uv = floor( UV.xz*50.0 );\nuv = mod(uv, vec2(128.,128)); vec2 uv64 = mod(uv, vec2(64.,65.) ); vec2 uv24 = mod(uv64, vec2(64.,24.) );\nfloat h = huv*huvx;\ncol = mix( vec3(114./255.), vec3(98./255.), sat(2.*h) );\ncol = mix( col, mix( COL(111.,114.,87.), COL(90.,98.,69.), sat(2.*h) ), sat( 100.*(hash(uv+vec2(523.,53.))*hash(150.-uv.x)-0.15)) );\ncol = addKnobAA( mod( uv24, vec2(3.,32.) ), vec2(0.,4.5), 1.1, 0.4, col );\ncol = mix( col, COL(137.,141.,115.), 0.7*sat( onLineX(uv64,1.)+onLineY(uv,1.)+onLineY(uv24,0.)+onLineY(uv24,19.)+onLineY(uv64,59.) ) );\ncol = mix( col, COL(73.,81.,55.), sat( onLineX(uv64,0.)+onLineX(uv64,62.) ) );\ncol = mix( col, mix(COL(73.,81.,55.),vec3(38./255.),uv24.y-22.), onBand(uv24.y,22.,23.) );\ncol = mix( col, mix(COL(73.,81.,55.),vec3(38./255.),uv64.y-63.), onBand(uv64.y,63.,64.) );\ncol = mix( col, vec3(38./255.), sat( onLineY(uv,0.)+onLineX(uv64,63.) ) );\ncol = mix( col, COL(137.,141.,115.), onRect(uv,vec2(3.),vec2(60.,12.)) );\ncol = mix( col, mix( vec3(1.), COL(255.,253.,110.), sat( abs(uv.x-32.)/20.)-0.25*mod(uv.x,2.)), onRect(uv,vec2(4.),vec2(59.,11.)) );\n}\nelse if( material == MAT_BRONZE ) {         uv = mod(uv, vec2(64.,128)); float s = sin(31.15926*uv.x/64.);\ncol = mix( vec3(75./255.), vec3(64./255.), huv );\ncol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+1.2)*(1.-(uv.y+44.)/64.))) * onBand(uv.y, 0., 30. ) );\ncol = mix( col, COL(123.,105.,85.), sat( 2.*(0.5*huvx+huv+(s+1.7)*(1.-(uv.y+44.)/64.)-0.5) ) * onBand(uv.y, 0., 30. ) );\ncol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+0.7)*(1.-(uv.y+14.)/64.))) * onBand(uv.y, 30., 98. ) );\ncol = mix( col, COL(123.,105.,85.), sat( 2.*(1.1*huvx+(s+1.7)*(1.-(uv.y+14.)/64.)-0.5) ) * onBand(uv.y, 30., 98. ) );\ncol = mix( col, COL(7.,59.,20.), sat( huv*uv.y/96.-0.5) );\ncol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+1.2)*(1.-(uv.y-40.)/64.))) * onBand(uv.y, 98., 128. ) );\ncol = mix( col, COL(123.,105.,85.), sat( 2.*(huvx+(s+1.7)*(1.-(uv.y-40.)/64.)-0.5) ) * onBand(uv.y, 98., 128. ) );\ncol = mix( col, mix(COL(110.,89.,70.),COL(130.,112.,92.),sat((uv.y-3.)/18.)), onRectAA(mod(uv,vec2(16.,128.)),vec2(6.5,1.5),vec2(12.5,21.5)) );\ncol = addBevel( mod(uv,vec2(16.,128.)),vec2(5.5,-2.5),vec2(12.5,21.5), 2.3, 1., 0.1, 0.7, col );\ncol = mix( col, addBevel( abs(mod(uv+vec2(0.,-85.),vec2(64.))-vec2(32.,0.)), vec2(15.5,0.5), vec2(34.5,52.5), 1.2, 1., 0.5, -0.7, col ), onBand(uv.y, 30.,97.));\ncol = mix( col, 0.7*col, sat( onLineY(uv,127.)+onLineX(uv,0.)+onBand(uv.y, 97.,98.)+onBand(uv.y, 29.,30.)) );\ncol = mix( col, 1.2*col, sat( onBand(uv.y, 98.,99.)+onBand(uv.y, 0.,1.)+onLineX(uv, 63.)) );\ncol = mix( col, 0.75*col*uv.x, onBand(uv.x, 0., 1.)*onBand(uv.y, 30.,97.) );\ncol *= 1.0-0.1*huv;\n}\nelse /*if( material == MAT_STEPS ) {         uv = mod(uv, vec2(64.,16.));\ncol = mix( COL(182.,133.,93.), COL(132.,98.,66.), sat(huv-0.5) );\ncol = mix( col, COL(129.,111.,79.), sat(1.-(uv.y-4.)/8.) );\ncol = mix( col, COL(102.,82.,50.), sat((huv+1.)*onRectAA(mod(uv,vec2(32.,16.)), vec2(1.5,9.7), vec2(29.5,13.5))) );\ncol = mix( col, COL(102.,82.,50.), 0.6*sat((huv+1.)*onRectAA(mod(uv,vec2(8.,16.)), vec2(2.5,3.5), vec2(5.5,6.2))) );\ncol = mix( col, COL(143.,122.,92.), onLineY(uv,0.) );\ncol = mix( col, COL(106.,86.,61.), onLineY(uv,2.) );\ncol *= 1.-0.2*onLineY(uv,3.);\n}\nelse*/ if( material == MAT_PIPES ) {         uv = mod(uv, vec2(128.,64.)); float huv2 = hash( uv*5312. );\ncol = mix( mix(COL(184.,165.,144.),COL(136.,102.,67.),uv.x/128.),\nmix(COL(142.,122.,104.),COL(93.,77.,50.),uv.x/128.), sat(huv+huvx) );\ncol *= 1.+0.5*sat(hash(uv.y)-0.7);\ncol *= 1.-0.2*sat(hash(uv.y-1.)-0.7);\ncol = mix( col, COL(102.,82.,50.), sat(0.2*huv2+3.*(huvx-0.7)) );\ncol = mix( col, COL(165.,122.,85.), (0.75+0.5*huv2)*sat( onBandAA(uv.x,122.5,123.5)+onBandAA(uv.x,117.5,118.5)+onBandAA(uv.x,108.5,109.5) ) );\ncol = mix( col, mix(  (1.-sat(0.2*abs(2.8-mod(uv.x,6.))))*mix(COL(175.,126.,89.),COL(143.,107.,71.),0.4*distance( mod(uv,vec2(6.)), vec2 (1.5))), COL(77.,68.,40.), onBandAA(mod(uv.x+1.,6.),0.,1.5)),\n(0.75+0.5*huv2)*sat( onBandAA(uv.x,6.5,11.5)+onBandAA(uv.x,54.5,59.5)+onBandAA(uv.x,66.5,70.5)+onBandAA(uv.x,72.5,78.5) ) );\ncol = mix( col, mix( COL(82.,90.,64.), 1.2*COL(118.,125.,99.), huv*(sat(abs(uv.x-14.)-huv)+sat(abs(uv.x-62.)-huv)) ), onBandAA(uv.x,12.8,13.8) + onBandAA(uv.x,60.8,61.8));\ncol = mix( col, vec3(0.), 0.3*(onBandAA(uv.y,18.8,21.8)*onBandAA(uv.x,40.8,52.8) + onBandAA(uv.x,0.1,3.7) + onBandAA(uv.x,41.3,44.2) + onBandAA(uv.x,48.9,51.8)+0.6*onBandAA(uv.x,80.1,81.6)));\ncol = mix( col, mix( 1.2*COL(205.,186.,167.), COL(143.,122.,92.), 0.3*(sat(abs(uv.x-2.)+huv)+sat(abs(uv.x-43.)+huv)+sat(abs(uv.x-51.)+huv)) ), onBandAA(uv.x,0.8,2.8) + onBandAA(uv.x,42.1,43.3) + onBandAA(uv.x,49.8,51.2)+0.6*onBandAA(uv.x,80.8,81.5));\ncol = mix( col, mix( 1.2*COL(205.,186.,167.), COL(154.,133.,105.), (sat(abs(uv.y-20.5)+huv)) ), onBandAA(uv.y,19.3,21.2)*onBandAA(uv.x,40.8,52.1));\nfloat d = min( min( min( min( min( min( distance(uv,vec2(6.,39.)), 0.8*distance(uv,vec2(23.,45.)) ), 1.2*distance(uv,vec2(39.,30.)) )\n, 1.5*distance(uv,vec2(48.,42.)) ), distance(uv,vec2(90.,32.)) ), 0.8*distance(uv,vec2(98.,50.)) ), 1.15*distance(uv,vec2(120.,44.)) );;\nd *= (1.-0.8*(sat(hash(uv.x+uv.y)-0.6)+sat(huvx-0.6)));\ncol = mix( col,COL(93.,77.,50.), sat((7.-d)/8.) );\ncol = mix( col, vec3(0.), pow(sat((5.-d)/6.),1.5) );\n}\nelse if( material == MAT_FLOOR_A ) {         uv = mod(uv, vec2(64.));\ncol = mix( COL(147.,126.,108.), COL(175.,152.,134.), sat( 1.5*(huv+hash(uv.x-uv.y)-0.95-uv.y/128.)) );\ncol = mix( col, COL(175.,152.,134.), sat( 1.5*(huv+hash(uv.x-uv.y*1.1+5.)-1.8+uv.y/64.)) );\ncol = mix( col, COL(130.,133.,108.), sat( 10.*(huv+hash(uv.x*1.1-uv.y+3.)-1.25)) );\ncol = mix( col, mix( COL(118.,125.,99.), COL(130.,133.,108.), 1.-huv), sat(5.*(huv-1.5+uv.y/64.)) );\ncol = mix( col, COL(129.,111.,91.), sat( onLineX(uv,0.)+onLineY(uv,63.) ) );\ncol *= sat(0.92+huv);\n}\nelse /* if( material == MAT_FLOOR_B ) {         uv = mod(uv, vec2(64.));\nfloat h = hash(3.*uv.x+uv.y);\ncol = mix( COL(136.,114.,95.), COL(143.,122.,104.), sat(4.*h*huv) );\ncol = mix( col, COL(129.,111.,91.), sat(h-0.5) );\ncol *= 1.+0.05*sat( 0.3+mod(uv.x,2.)*cos(uv.y*0.2)*huv );\ncol = mix( col, COL(175.,126.,89.), sat( 2.*(hash(floor(uv*0.125))+huv-1.5) ) );\nvec3 ncol = mix( col, COL(114.,94.,78.), sat(\n(0.4*huv+0.4)*onRectAA( mod(uv+vec2(0.,33.),vec2(64.)), vec2(6.5,0.5), vec2(36.5,58.5) )\n-onRectAA( mod(uv+vec2(0.,33.),vec2(64.)), vec2(9.5,3.5), vec2(33.5,55.5) ) ));\nncol = mix( ncol, COL(114.,94.,78.), sat( (0.6*huv+0.3)*onRectAA( mod(uv+vec2(0.,5.),vec2(64.)), vec2(33.5,0.5), vec2(59.5,60.5) ) ));\nncol = mix( ncol, col, sat(               0.8*onRectAA( mod(uv+vec2(0.,5.),vec2(64.)), vec2(35.5,2.5), vec2(57.5,58.5) ) ));\nncol = mix( ncol, COL(121.,103.,81.), sat( (0.8*huv+0.9)*onRectAA( mod(uv+vec2(0.,53.),vec2(64.)), vec2(18.5,0.5), vec2(41.5,22.5) ) ));\nncol = mix( ncol, col, sat(               onRectAA( mod(uv+vec2(0.,53.),vec2(64.)), vec2(19.5,1.5), vec2(40.5,21.5) ) ));\nncol = mix( ncol, COL(114.,94.,78. ), sat( (0.8*huv+0.6)*onRectAA( mod(uv+vec2(8.,46.),vec2(64.)), vec2(0.5,0.5), vec2(20.5,36.5) ) ));\ncol  = mix( ncol, col, sat(               onRectAA( mod(uv+vec2(8.,46.),vec2(64.)), vec2(1.5,1.5), vec2(19.5,35.5) ) ));\n} else */ {\ncol = vec3(0.5);\n}\nresult.xyz = col.xyz;\n}\n\n                                                                                       \n                                                                                  \n\nfloat dBullet( vec3 p, vec2 h ,float t)\n{   if(t<1.0)\np.y-=(h.y*t-h.y);\nelse {\np.y-= h.y*(t-1.0);\nt=1.0;\n}\nfloat w = h.x*mix(.25 , max(t*.8,.5), (1.0+cos(50.0*p.y))*.5);\nvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(w,h.y*t);\nreturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat map( in vec3 p )\n{\nfloat t =  iTime*params.x;\nvec4 bt = mod(vec4(t)+bullet_toff,2.0)*3.0/2.0;\n#define FX_Bullets_ID (PRIM_SLOT_ID+3)\nvec4 q=vec4(p,1.0);\ndM_s(MAT_FX_BULLET, dBullet((mat4( 1.000,0.023,0.004,0.000,-0.002,-0.086,0.996,0.000,0.023,-0.996,-0.086,0.000,1.175,-1.224,-1.443,1.000)*q).xyz , vec2(0.035,7.310),bt.x));\nz= oU(dBullet((mat4( 0.996,0.093,0.000,0.000,0.000,-0.000,1.000,0.000,0.093,-0.996,0.000,0.000,0.656,-1.295,-1.956,1.000)*q).xyz , vec2(0.035,7.310),bt.y) , z) ;\nz= oU(dBullet((mat4( 1.000,-0.006,-0.000,0.000,0.000,-0.068,0.998,0.000,-0.006,-0.998,-0.068,0.000,1.150,-1.538,-1.645,1.000)*q).xyz , vec2(0.035,7.310),bt.z) , z) ;\ndM_e();\nreturn z;\n}\n\n#define Scn_MainRoofTop_ID (PRIM_SLOT_ID+0)\nfloat Scn_MainRoofTop(vec3 p)\n{\nvec4 q=vec4(p,1.);\ndM_s(MAT_FLOOR_A, dB((mat4( 1.,.0,.0,.0,.0,.0,1.,.0,.0,-1.,.0,.0,5.285,8.402,-0.841,1.)*q),vec3(0.19,0.49,0.319)));\nz= min(dB((mat4( 0.874,.0,0.485,.0,-0.485,.0,0.874,.0,.0,-1.,.0,.0,4.598,8.411,1.747,1.)*q),vec3(0.46,0.47,0.269)),z) ;\ndM(MAT_WALL);\nz= min(dB((mat4( 1.,.0,.0,.0,.0,1.,.0,.0,.0,.0,1.,.0,-3.82,-1.67,9.341,1.)*q),vec3(1.57,1.18,1.062)),z) ;\ndM(MAT_VEST);\nz= min(dB((mat4( 1.,.0,.0,.0,.0,1.,.0,.0,.0,.0,1.,.0,-1.846,-1.67,9.128,1.)*q),vec3(0.68,1.82,1.062)),z) ;\ndM(MAT_FLOOR_A);\nz= min(dB(p-vec3(-3.16,-7.33,-0.25),vec3(10.85,7.83,10.264)),z) ;\nz= min(dB(p-vec3(-9.39,-4.35,5.49),vec3(4.,5.71,6.998)),z) ;\ndM_e();\n}\n#define Bkg_RSide_ID (PRIM_SLOT_ID+1)\nfloat Bkg_RSide(vec3 p)\n{\nvec4 q=vec4(p,1.);\ndM_s(MAT_WALL, dB(p-vec3(50.49,-1.15,-54.52),vec3(8.98,40.29,16.548)));\nz= min(dB(p-vec3(-10.18,-1.9,-68.11),vec3(34.53,10.2,11.734)),z) ;\ndM_e();\n}\n#define Bkg_FSide_ID (PRIM_SLOT_ID+2)\nfloat Bkg_FSide(vec3 p)\n{\nvec4 q=vec4(p,1.);\ndM_s(M_MIR, dB(p-vec3(-2.8,2.49,35.34),vec3(11.3,39.05,10.185)));\ndM(MAT_BRONZE);\nz= min(dB(p-vec3(-3.4,2.49,24.32),vec3(0.81,39.05,0.915)),z) ;\ndM_e();\n}\n#define Scn_AGENT_ID (PRIM_SLOT_ID+3)\nfloat Scn_AGENT(vec3 p)\n{\nvec4 q=vec4(p,1.);\ndM_s(MAT_BRONZE, dCa(p,vec3(-1.28,2.08,8.504),vec3(-1.37,0.49,8.457),0.08));\nz= oB(dCa(p,vec3(-1.26,2.01,8.582),vec3(-1.06,0.57,8.671),0.07),z,0.02) ;\ndM(MAT_VEST);\nz= oB(dCa(p,vec3(-1.1,0.53,8.7),vec3(-0.97,0.52,8.609),0.04),z,0.02) ;\nz= oB(dCa(p,vec3(-1.35,0.53,8.426),vec3(-1.37,0.51,8.27),0.04),z,0.02) ;\ndM(MAT_BRONZE);\nz= oB(dCa(p,vec3(-1.42,2.02,8.515),vec3(-1.29,1.98,7.748),0.06),z,0.02) ;\ndM(MAT_VEST);\nz= oB(dCa(p,vec3(-1.26,2.06,7.75),vec3(-1.25,2.08,7.551),0.03),z,0.02) ;\ndM(M_W);\nz= oB(dCa(p,vec3(-1.17,2.08,8.581),vec3(-1.3,1.45,8.57),0.09),z,0.02) ;\ndM(MAT_SKIN);\nz= oB(dCa(p,vec3(-1.26,2.11,8.528),vec3(-1.27,2.29,8.491),0.07),z,0.02) ;\nz= oB(dS(p-vec3(-1.27,2.26,8.507),0.1),z,0.02) ;\ndM_e();\n}\n#define snc_NEO_ID (PRIM_SLOT_ID+4)\nfloat snc_NEO(vec3 p)\n{\nvec4 q=vec4(p,1.);\ndM_s(MAT_VEST, dCa(p,vec3(-0.64,1.14,-1.773),vec3(-0.29,1.2,-1.715),0.06));\nz= oB(dC((mat4( 0.38,-0.401,-0.834,.0,0.403,-0.739,0.539,.0,-0.833,-0.541,-0.119,.0,-1.815,-0.014,-1.086,1.)*q),vec2(0.045,0.16)),z,0.015) ;\nz= oB(dC((mat4( -0.867,-0.152,-0.474,.0,-0.388,-0.39,0.835,.0,-0.312,0.908,0.279,.0,-1.219,2.369,-0.714,1.)*q),vec2(0.05,0.15)),z,0.015) ;\nz= oB(dCa(p,vec3(-1.07,0.99,-2.215),vec3(-0.95,1.01,-1.877),0.06),z,0.015) ;\nz= oB(dCa(p,vec3(-0.89,1.04,-1.838),vec3(-0.7,1.1,-1.792),0.1),z,0.015) ;\nz= oB(dCa(p,vec3(-1.03,0.58,-0.994),vec3(-1.07,0.51,-0.86),0.04),z,0.015) ;\nz= oB(dCa(p,vec3(-0.66,0.57,-1.192),vec3(-0.62,0.49,-1.061),0.04),z,0.015) ;\nz= oB(dCa(p,vec3(-0.93,0.99,-0.867),vec3(-0.86,1.02,-1.321),0.07),z,0.015) ;\nz= oB(dCa(p,vec3(-0.93,0.99,-0.826),vec3(-1.03,0.57,-0.981),0.05),z,0.015) ;\nz= oB(dCa(p,vec3(-0.59,0.89,-0.864),vec3(-0.65,0.57,-1.185),0.05),z,0.015) ;\nz= oB(dCa(p,vec3(-0.6,0.9,-0.901),vec3(-0.71,1.01,-1.333),0.07),z,0.015) ;\ndM(MAT_SKIN);\nz= oB(dS(p-vec3(-0.79,1.1,-2.058),0.09),z,0.015) ;\nz= oB(dS(p-vec3(-0.85,1.14,-1.95),0.03),z,0.015) ;\nz= oB(dS(p-vec3(-0.82,1.13,-1.989),0.05),z,0.015) ;\nz= oB(dCa(p,vec3(-0.79,1.1,-2.054),vec3(-0.79,1.09,-1.874),0.05),z,0.015) ;\nz= oB(dS(p-vec3(-1.,1.11,-2.469),0.04),z,0.015) ;\ndM(MAT_VEST);\nz= min(dB((mat4( 0.97,-0.239,0.04,.0,0.242,0.962,-0.125,.0,-0.008,0.131,0.991,.0,0.518,-0.994,1.712,1.)*q),vec3(0.13,0.06,0.246)),z) ;\ndM(MAT_SKIN);\nz= oB(dS(p-vec3(-0.16,1.42,-1.567),0.04),z,0.025) ;\ndM_e();\n}\n#define DO_EVALUATE_RMPRIMS 1\nvoid EvaluateRMPrims()\n{\nif(PRIM==Scn_MainRoofTop_ID){\nPRIM_RM_NORMAL(Scn_MainRoofTop)\n}\nelse\nif(PRIM==Bkg_RSide_ID){\nPRIM_RM_NORMAL(Bkg_RSide)\n}\nelse\nif(PRIM==Bkg_FSide_ID){\nPRIM_RM_NORMAL(Bkg_FSide)\n}\nelse\nif(PRIM==Scn_AGENT_ID){\nPRIM_RM_NORMAL(Scn_AGENT)\n}\nelse\nif(PRIM==snc_NEO_ID){\nPRIM_RM_NORMAL(snc_NEO)\n}\n}\n\nvoid trace()\n{\n\n//if(inB(vec3(7.38,0.05,-17.16),vec3(52.09,41.49,62.684)))\n{\nif(inB(vec3(-3.16,-5.84,0.987),vec3(10.85,9.33,11.501)))\n{\nRAYMARCH_OBJ(Scn_MainRoofTop,Scn_MainRoofTop_ID,40);\n}\nif(inB(vec3(7.38,-1.15,-58.908),vec3(52.09,40.29,20.936)) && Z>Z_cull)\n{\nRAYMARCH_OBJ(Bkg_RSide,Bkg_RSide_ID,MAX_ITERATIONS);\n}\nif(inB(vec3(-2.8,2.49,34.465),vec3(11.3,39.05,11.06)) && Z>Z_cull)\n{\nRAYMARCH_OBJ(Bkg_FSide,Bkg_FSide_ID,50);\n}\nif(inB(vec3(-1.21,1.42,8.159),vec3(0.27,0.95,0.611))&& Z>Z_cull)\n{\nRAYMARCH_OBJ(Scn_AGENT,Scn_AGENT_ID,MAX_ITERATIONS);\n}\nif(inB(vec3(-0.62,0.96,-1.647),vec3(0.52,0.51,0.877))&& Z>Z_cull)\n{\nRAYMARCH_OBJ(snc_NEO,snc_NEO_ID,35);\n}\n}\n\n}\nfloat castRay( in vec3 ro, in vec3 rd ,bool shadowing)\n{\nRO=ro;\nRD=normalize(rd);\nooRD=1.0/rd;\nPRIM=-1;\nZ=CAMERA_FAR;\nN = vec3(0,1,0);\nUV = vec3(-1.0);\nMATID = -1;\ntrace();\nif(!shadowing)\n{\ndMATID =-1;\nfloat tmin = CAMERA_NEAR;\nfloat tmax = Z;\nfloat precis = 0.001;\nfloat t = tmin;\nfloat m = -1.0;\nfor( int i=0; i<MAX_ITERATIONS; i++ )\n{\nfloat z = map( ro+rd*t );\nif( z<precis || t>tmax ) break;\nt += z;\n}\nif(t<Z)\n{\nZ=t;\nMATID=dMATID;\nPRIM=PRIM_DF;\n}\n}\nreturn Z;\n}\nvec3 calcNormal( in vec3 pos )\n{\nvec3 eps = vec3( 0.001, 0.0, 0.0 );\nvec3 nor = vec3(\nmap(pos+eps.xyy) - map(pos-eps.xyy),\nmap(pos+eps.yxy) - map(pos-eps.yxy),\nmap(pos+eps.yyx) - map(pos-eps.yyx) );\nreturn normalize(nor);\n}                                                          \n                                                                                         \n\nvec4 render( in vec3 ro, in vec3 rd )\n{\nvec4 PIXEL = vec4(0.913725,1.000000,0.909804,1.0);     AO=1.0;\nfloat z=castRay(ro,rd,false);\nint mat = MATID;\nP = RO + z*RD;\nUV = P.xzy;\nPUV = P;\nif( PRIM == PRIM_DF)\n{\nN=calcNormal(P);\n}\nif( PRIM==PRIM_AABB)\n{   mat_AABB(P);\n}\nvec3 filterz = vec3(1.,1.,1.);\nif(MATID == M_MIR)\n{\n//EvaluateRMPrims();\n    N= vec3(0.0,0.,-1.);\n    #ifdef MIRRORS\nvec3 R = reflect( rd, vec3(0.0,0.,-1.) );\nz=castRay(P,R,true);\nfilter = vec3(0.329412,0.337255,0.282353);\nvec2 uv=mod(P.xy*vec2(1.0,0.5),2.0);\nfilter *=(uv.x<1.90 )?1.0:0.5;\nfilter *=(uv.y<1.90 )?1.0:0.5;\nmat = MATID;\nP = RO + z*RD;\nUV = P.xzy;\nPUV = P;\n    #endif\n\n}\n#ifdef DO_EVALUATE_RMPRIMS\n    else\nif(PRIM>=PRIM_SLOT_ID)\nEvaluateRMPrims();\n#endif\nvec3 R = reflect( rd, N );\nif(mat>0)\ngetMaterialColor(mat,UV,PIXEL);\nvec3 litdir = normalize(main_light);\nfloat amb = clamp( 0.5+0.5*N.y, 0.0, 1.0 );\nfloat dif = clamp( dot( N, litdir ), 0.0, 1.0 );\nfloat spe = pow(clamp( dot( R, litdir ), 0.0, 1.0 ),16.0)*.5;\nfloat shdatt = castRay(P,litdir,true)>=CAMERA_FAR?1.0:0.0;\nvec3 lit = vec3(dif)*PIXEL.xyz*filterz;\nlit *= AO*max(shdatt,0.5);\nlit += 0.20*amb*vec3(0.30,0.20,0.20);\nlit += spe*shdatt;\nPIXEL.xyz = lit;\nPIXEL = mix( PIXEL, sky_color, sky_color.w*z/CAMERA_FAR  );\nreturn PIXEL;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\nreturn mat3( cu, cv, cw );\n}                                                                       \n                                                                                                \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 q = fragCoord.xy/iResolution.xy;\nvec2 p = -1.0+2.0*q;\np.x *= -iResolution.x/iResolution.y;\nvec2 mo = iMouse.xy/iResolution.xy;\n#ifdef ROVER_ENGINE\nvec3 ro = r_camera_source_fov.xyz;\nvec3 ta = r_camera_target_roll.xyz;\nif(OPTIONS_PARAMS.x>0.0)\n{\n#else\nvec3 ro;\nvec3 ta;\n#endif\nfloat time =  iTime+24.0;\nro = vec3( -0.5+camera_focus.w*3.2*cos(0.2*time + 6.0*mo.x), 1.0 + mix(0.0,1.00,clamp(mo.y,0.0,1.0)), 0.5 + camera_focus.w*3.2*sin(0.2*time + 6.0*mo.x) ) + camera_offset;\nta = camera_focus.xyz;\n#ifdef ROVER_ENGINE\n}\nmat3 ca = setCamera( ro, ta, r_camera_target_roll.w );\nvec3 rd = ca * normalize( vec3(p,r_camera_source_fov.w) );\n#else\nmat3 ca = setCamera( ro, ta, 0.0 );\nvec3 rd = ca * normalize( vec3(p,1.63) );\n#endif\nvec4 col = render( ro, rd );\ncol.rgb = pow( col.rgb, vec3(0.4545) );\nfragColor=vec4(col.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}