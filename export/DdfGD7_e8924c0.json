{"ver":"0.1","info":{"id":"DdfGD7","date":"1666207544","viewed":193,"name":"Blobs __","username":"Envy24","description":"Extruded version: https://www.shadertoy.com/view/mss3WM","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["blobs","sminmunion"],"hasliked":0,"parentid":"DdX3W7","parentname":"Operators for SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )\n#define UNIT                      ( 2.0 / R.y )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\n\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 ndc_offset)\n{\n    /**\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]\n    \n    return SC - ndc_offset;          // apply \"static\" offset in ndc space\n}\n#define STD_MAP(SC) ( map_to_centered_ndc(SC, 1., vec2(0)) )\n\n// Source: https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat union_sdf(float dl, float dr) { return smin(dl, dr, 0.15); }\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = STD_MAP(SC);\n    vec3 color = HASH3(10., 1., -2.);\n       \n    float scene_dist = 99., T = 0.5*iTime;\n    \n    for (float i = 0.; i < 300.; i += 1.)\n    {\n        vec2 r = HASH2(i, i+1.),                 // random vector xy [-1;1][-1;1]\n             dir = r * T*fract(i/100.),          // random direction times velocity\n             C = mod(r + dir, vec2(4))-vec2(2);  // wrapped disk coordinates.\n             \n        float tresholded_r =\n            abs(r.y) > 0.1 ?\n                0.1*abs(r.x) :\n                abs(r.x)*abs(r.x),\n\n              radius = 64.*tresholded_r*UNIT,\n              dist = diskSDF_L2(NDC, C, radius);\n        \n        scene_dist = union_sdf( scene_dist, dist ); \n    }\n    //color = mix( color, HASH3(6., 35., -7.), SMAA(abs(scene_dist)) );\n    color = mix( color, HASH3(6., 35., -7.), SMAA(scene_dist) );\n    \n    O = vec4(color, 1); \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH2(x, y) ( hash2to2(uint(x), uint(y)) )\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 hash3to3(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH3(x, y, z) ( abs(hash3to3(uint(x), uint(y), uint(z))) )","name":"Common","description":"","type":"common"}]}