{"ver":"0.1","info":{"id":"tsSczW","date":"1586183163","viewed":682,"name":"simple raymarch sphere","username":"Ridgen","description":"My first try to make raymarch shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.1\n\nvec4 sphere = vec4(0.,1.,6.,1.);\nvec3 lightpos = vec3(1.,7.,6.);\n\nfloat getdist(vec3 raypos)\n{\n\tfloat planedist = raypos.y;\n    float spheredist = length(raypos-sphere.xyz)-sphere.w;\n    return min(planedist,spheredist);\n}\nvec3 getnormal(vec3 p)\n{\n \treturn normalize(sphere.xyz-p);   \n}\nfloat getlight(vec3 p)\n{\n    vec3 lightdir = normalize(lightpos-p);\n    vec3 normal = getnormal(p);\n    float diff = dot(normal,lightdir);\n    return diff;\n}\nfloat raymarch(vec3 camera, vec3 dir)\n{\n\tfloat dist = 0.; \n    for(int i=0; i<MAX_STEPS; i++){\n   \t\tvec3 pos = camera+dir*dist;\n        float stepdist = getdist(pos);\n        dist+=stepdist;\n        if(dist>MAX_DIST || dist<MIN_DIST) break;\n    }\n    return dist;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(0.);\n\t\n    vec3 camera = vec3(0.,1.,1.);\n    vec3 ray = vec3(uv.x, uv.y, camera.z);\n    float d = raymarch(camera, normalize(ray));\n    vec3 p = camera + ray*d;\n    //col+=vec3(1.-1./MAX_DIST*d);\n    float diff = getlight(p);\n    col+=vec3(1.-diff);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}