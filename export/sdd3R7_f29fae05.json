{"ver":"0.1","info":{"id":"sdd3R7","date":"1629457318","viewed":244,"name":"Pattern process #3","username":"louis_C","description":"Interactive visualization as part of this project : https://www.cosamentale.fr/frages-flux-of-generative-researches/ ","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat cu( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    return sqrt( res );\n}\nfloat li( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat fra (vec2 uv,float tf){\nfloat fr = 10.;\n    //if(length(uv.x-0.4)<1. && length(uv.y)<0.2){\n     fr = cu(uv,vec2(-0.576,-0.155),vec2(-0.575,0.02),vec2(-0.295,0.01));\n     fr = min(fr,cu(uv,vec2(-0.576,0.01),vec2(-0.576,0.175),vec2(-0.35,0.175)));\n     fr = min(fr,cu(uv,vec2(0.055,0.01),vec2(0.05,0.175),vec2(-0.17,0.175)));\n     fr = min(fr,li(uv,vec2(-0.35,0.175),vec2(-0.17,0.175)));\n     fr = min(fr,cu(uv,vec2(-0.29,-0.155),vec2(-0.29,0.01),vec2(-0.165,0.01)));\n     fr = min(fr,cu(uv,vec2(0.04,-0.155),vec2(0.04,0.01),vec2(-0.089,0.01)));\n     fr = min(fr,cu(uv,vec2(0.1,-0.155),vec2(0.035,-0.05),vec2(0.15,0.05)));\n     fr = min(fr,li(uv,vec2(0.15,0.051),vec2(0.269,0.151)));\n     fr = min(fr,li(uv,vec2(0.1,-0.155),vec2(0.354,0.06)));\n     fr = min(fr,cu(uv,vec2(0.185,0.175),vec2(0.32,0.17),vec2(0.375,0.01)));\n     fr = min(fr,li(uv,vec2(0.375,0.01),vec2(0.43,-0.155)));\n     fr = min(fr,cu(uv,vec2(0.72,0.175),vec2(0.435,0.193),vec2(0.435,0.01)));\n     fr = min(fr,cu(uv,vec2(0.6,-0.16),vec2(0.45,-0.15),vec2(0.435,0.01)));\n     fr = min(fr,cu(uv,vec2(0.6,-0.16),vec2(0.77,-0.16),vec2(0.79,0.01)));\n     fr = min(fr,cu(uv,vec2(1.09,0.175),vec2(0.8,0.193),vec2(0.805,0.01)));\n     fr = min(fr,cu(uv,vec2(1.375,0.175),vec2(1.09,0.193),vec2(1.09,0.01)));\n     fr = min(fr,cu(uv,vec2(0.99,-0.16),vec2(0.80,-0.15),vec2(0.805,0.01)));\n     fr = min(fr,cu(uv,vec2(1.2,-0.16),vec2(1.36,-0.15),vec2(1.378,0.01)));\n     fr = min(fr,li(uv,vec2(-0.576,0.01),vec2(0.05,0.01)));\n     fr = min(fr,li(uv,vec2(0.6,0.01),vec2(1.378,0.01)));\n     fr = min(fr,li(uv,vec2(1.2,-0.16),vec2(0.99,-0.16)));\n    // }\n    // else{fr=0.;}\n     float r1 =  smoothstep(0.012+tf,0.00,fr);\n      float r2 =  pow(smoothstep(0.007,0.03,fr),0.1+tf*4.);\n     return max(r1,r2);\n     }\nconst float threshold[16] = float[16](\n    1./16., 9./16., 3./16., 11./16., \n    13./16., 5./16., 15./16., 7./16., \n    4./16., 12./16., 2./16., 10./16.,\n    16./16., 8./16., 14./16., 6./16.);\n\nfloat dit2(int x, int y, float v)\n{\n    return step(threshold[4*y+x],v);\n}\nstruct scene{float dist;int em;float re;float col;};\nfloat rd(float se) {return (fract(sin( (se += 1.0)) * 43758.5453));}\nvec3 rdv(float se){\n    float theta = rd(se) * (6.283);\n    float z = rd(se) * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z); \n    vec3 v = vec3(a * cos(theta), a * sin(theta), z);\n    return v * sqrt(rd(se));}\nmat2 rot(float r){float c = cos(r);float s = sin(r);return mat2(c, s, -s, c);}\nfloat box(vec3 p, vec3 s){vec3 d = abs(p) - s;\nreturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);}\nfloat bl(vec2 p, vec2 s){vec2 d = abs(p) - s;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);}\nscene opOR(in scene a, in scene b){\n    if (a.dist < b.dist){return a;}\n    return b;}\n    \nfloat pat(vec3 p){\nfloat tt = clamp(map(iMouse.y/iResolution.y,0.65,0.15,0.,2.45),0.,2.45);\nvec3  pd = p;\nvec3 p2 = p;vec3 p3 = p;vec3 p4 = p;vec3 p5 = p;\nvec3 re2 = vec3(4.);\np2 = mod(p2+re2*vec3(0.5,0.5,0.),re2)-re2*0.5;\np3 = mod(p3+re2*vec3(0.5,0.,0.5),re2)-re2*0.5;\np4 = mod(p4+re2*vec3(0.,0.5,0.5),re2)-re2*0.5;\np5 = mod(p5+re2*vec3(0.),re2)-re2*0.5;\nfloat d5 = min(min(min(box(p2,vec3(1.)),box(p3,vec3(1.))),box(p4,vec3(1.))),box(p5,vec3(1.)));\nfloat d5i = max(-100.,-d5);\n\nvec3 pl = abs(p);\nif(pl.x>pl.z)pl.x=pl.z;\nif(pl.x>pl.y)pl.x=pl.y;\n\nvec3 pl2 =abs(p);\n\nif(pl2.x>pl2.y)pl2.x=pl2.y;\nif(pl2.x<pl2.z)pl2.x=pl2.z;\n\nvec3 pl3 =abs(p);\n\nif(pl3.x<pl3.y)pl3.x=pl3.y;\nfloat tl = 0.25;\nfloat d6 = clamp(length(fract(pl.x*1.5)-0.5)-0.2,-10.,tl);\nfloat d7 = clamp(length(fract(pl2.x*1.5)-0.5)-0.2,-10.,tl);\nfloat d8 = clamp(length(fract(pl3.x*1.5)-0.5)-0.2,-10.,tl);\nfloat d7b = max(d7,d8);\n\n      pd = abs(pd);\n      pd -=vec3(9.5);\n      if(pd.x>pd.y)pd.xy=pd.yx;\n      pd.x -= 2.;\n      if(pd.x>pd.z)pd.xz=pd.zx;\n      if(pd.z>pd.y)pd.zy=pd.yz;\n      pd = 1.5-abs(pd-1.);\n\n  //float d9 = box(p,vec3(4.5));\n  vec3 p9 = (p+0.5)/5.;\nfloat d9 =length( floor(p9)+smoothstep(0.5,0.7,fract(p9)))-(0.5+tt);\n//float d9 = length(p)-tt*10.;\nfloat di = max(d6,d5);\nfloat di2 = max(d7b,d5i);\nfloat di3 = min(di,di2);\n\nfloat dt = max(di3,d9);\nreturn dt;\n  }\nscene map(vec3 p){\nvec3 p1 = p;\n\n\nfloat f1 = pat(p1);\nfloat tb = 100.;\n//float f3 = box(p1,vec3(tb));\nfloat f3 = length(p1.xz)-tb;\nfloat f4 = min(max(-100.,-f3),p.y+20.);\nfloat b1 = dot(p,vec3(0.,-1.,0.))+20.;    \n\n    scene art = scene( f1,0,1.5, 1.);\n    float vm =1.5;\n\n    scene m1 = scene( b1,1,vm, 1.);\n    scene m2 = scene( f4,0,vm, 1.);\n   \n    scene a1 = opOR(m1,m2);\n   \n    scene r0 = opOR(art,a1);\n\n\n    return r0;\n}\nvec3 norm(vec3 p){vec2 e=vec2(0,0.01);return normalize(map(p).dist \n        -vec3(map(p-e.yxx).dist,map(p-e.xyx).dist,map(p - e.xxy).dist));}\n\nscene raymarch(in vec3 ro, in vec3 rd){\n    float t = 0.0;\n    scene sceneOutput = scene(50.,  0, 1.2, 0.03);\n    for (int i = 0; i < 300; ++i){\n        scene sce = map(ro + rd * t);\n        if (sce.dist < 0.01){\n            sceneOutput = scene(t, sce.em,sce.re,sce.col);\n            break;}\n        t += sce.dist;\n       // if (t > 40.){break;}\n    }\n    return sceneOutput;}\nfloat bz;\nfloat raytrace(in vec2 uv,float se){\nfloat tt = clamp(map(iMouse.y/iResolution.y,0.65,0.15,0.,2.45),0.,2.45);\nuv*= 2.;\nuv -= vec2(1.9,-0.4);\n    vec3 ro = vec3(uv,-10.-tt*10.);\n    vec3 rd = normalize(vec3(uv, 1.8));\n\n    ro.xz *= rot(iTime);\n    rd.xz *= rot(iTime);\n    float color  = 0.;\n   float mco = 0.;\n    float atten = 1.0;\n    float bounces = 1.;\n    float z1  =bl(uv,vec2(1.));\n    for (int i = 0; i <3; ++i)\n    {\n     if(z1>0.){break;}\n        scene sce = raymarch(ro, rd);\n        if (sce.em == 0)\n        {\n            vec3 p = ro + rd * sce.dist;\n            vec3 n = norm(p); \n            rd = n + rdv(se) * sce.re;\n            ro = p + rd * 0.1;\n            mco += (sce.col) * atten; \n            bounces += 1.0;\n            atten *= 0.5;\n        }\n        else\n        { color = mix(sce.col, mco * sce.col, max(0.0, float(i)));\n         break;}\n\n    } \n    color/=bounces;\n     bz = z1;\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat tt = 1.;\nfloat ft = (1080./iResolution.y)*0.01;\n   vec2 uc = fragCoord/iResolution.xy;\n    float tmp = 0.;\n    \n     float se = (iResolution.y*uc.x + uc.y);\n    se += iTime;\n    vec2 uv = (uc * 2.0 - 1.0) ;\n    uv.x *= iResolution.x/iResolution.y;\n    float color =raytrace(uv,se);\n   float prevColor = texture(iChannel0,uc).a;\n     float result2 = max(color,prevColor*0.0001);\n     float r2 = step(0.00001,result2);\n     float t2 = mix(mix(r2,0.,step(0.,bz)),1.,step(0.005,bz));\n     vec2 us  =uv+vec2(0.45,0.2);\n     float t1 = step(0.,pat(vec3(us*(10.+tt*10.),sin(iTime*0.5)*(2.6+tt*4.5))));\n     float bs = bl(us,vec2(0.5));\n     t1 *= max(step(bs,0.),step(0.0025,bs));\n     float fr = fra(uv*2.5-vec2(2.2,1.7),ft);\n    float bm = clamp((se-0.5)*2.,-0.6,0.8);\n    float f8 = step(0.,bl(uv+vec2(1.45,0.2),vec2(0.001,0.5)))*step(0.0,bl(uv+vec2(1.45,-0.3),vec2(0.01,0.001)))*step(0.0,bl(uv+vec2(1.45,0.7),vec2(0.01,0.001)));\n    float f9 = mix(1.-f8,f8,smoothstep(0.015,0.018,distance(uv,vec2(-1.45,clamp((0.5-(1.-iMouse.y/iResolution.y))*2.,-0.7,0.3)))));\n     fragColor = vec4(fr*t2*t1*vec3(0.905882,0.,0.22745)*f9,result2);\n}","name":"Buffer A","description":"","type":"buffer"}]}