{"ver":"0.1","info":{"id":"MltBRN","date":"1538890634","viewed":934,"name":"HeightMap plane","username":"edo_m18","description":"HeightMap plane test.\n\nIs this right approach to HeightMap distance field..?","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["hiehgtmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.01\n\nvec3 cameraPos = vec3(0.0, 2.0, 1.5);\nvec4 plane = vec4(0.0, 1.0, 0.0, 2.0);\nvec3 lightDir = vec3(1.0, 1.0, 1.0);\nvec3 skyCol = vec3(0, 0.745, 0.9);\n\nconst float heightFactor = 3.0; // height factor. will multiply to texture texel.\n\nfloat distPlane(in vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) * n.w;\n}\n\nfloat distFunc(in vec3 p)\n{\n    float d = distPlane(p, plane);\n    vec4 tex = texture(iChannel0, mod(p.xz * 0.2, 1.0));\n    tex *= heightFactor;\n\treturn d - tex.x;\n}\n\nvec3 getNormal(in vec3 p)\n{\n    const float e = EPS;\n    const vec3 dx = vec3(e, 0, 0);\n    const vec3 dy = vec3(0, e, 0);\n    const vec3 dz = vec3(0, 0, e);\n    \n    float d = distFunc(p);\n    \n    return normalize(vec3(\n    \td - distFunc(p - dx),\n    \td - distFunc(p - dy),\n    \td - distFunc(p - dz)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 p = (fragCoord.xy * 2.0 - R.xy) / min(R.x, R.y);\n    \n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec3 origin = cameraPos;\n    float t = iTime * 0.01;\n    const float cd = 3.0;\n    const float sp = 2.0;\n    float x = cos(t * sp) * cd;\n    float z = sin(t * sp) * cd;\n    \n    vec3 target = vec3(0, 2.5, 0);\n    \n    vec3 cPos = origin + vec3(x, 0, z);\n    //vec3 cDir = normalize(vec3(m.x, -m.y, -1.0));\n    vec3 cDir = normalize(cPos - target);\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0)));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    \n    float targetDepth = 1.3;\n    \n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    const int maxSteps = 128;\n    \n    float d = 0.0;\n    float depth = 0.0;\n    vec3 pos;\n    \n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < maxSteps; i++)\n    {\n        pos = cPos + ray * depth;\n        d = distFunc(pos) * 0.1;\n        \n        if (d <= EPS)\n        {\n            break;\n        }\n        \n        depth += d;\n    }\n    \n    if (d <= EPS)\n    {\n        vec3 n = getNormal(pos);\n        float diff = dot(n, normalize(lightDir));\n        float fog = 1.0 - exp(-depth * 0.12);\n        col = mix(vec3(diff), skyCol, fog);\n    }\n    else\n    {\n        col = skyCol;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}