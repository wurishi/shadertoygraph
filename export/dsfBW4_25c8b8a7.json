{"ver":"0.1","info":{"id":"dsfBW4","date":"1688730235","viewed":75,"name":"Diffuse light as function","username":"Envy24","description":"See Image tab.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["light","graph","diffuse","point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Graphs for two different methods for calculating diffuse point light (linear, nonlinear).\n    X axis represents angle between hit point to light direction (green) and hit point normal (purple).\n    Color of graph represent resulting color.\n    Hold LMB to switch methods.\n    Mouse.y changes intensity.\n*/\n\n#define SCENE_SCALE               ( 3. )\n#define ORIGIN                    ( vec2(3,0) )\n#define UNIT                      ( (SCENE_SCALE*5.0) / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat cells(vec2 NDC)\n{\n    NDC = min(fract(NDC), fract(1. - NDC));\n    return\n        min(vertical_line(NDC, 0.), horizontal_line(NDC, 0.)) +\n        max(vertical_line(NDC, 0.), horizontal_line(NDC, 0.));\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n#define INTENSITY (iMouse.xy == vec2(0) ? 1. : (iMouse.y / iResolution.y) * 2.)\n#define rotZ(a) (mat2(cos(a), sin(a), -sin(a), cos(a)) )\nfloat nonlinear(float x)\n{\n    float intensity = INTENSITY;\n    vec2 light = vec2(4, -1.5);\n    vec2 hp = vec2(2, -1.5);\n    vec2 hp_to_l = normalize(light - hp),\n         normal = rotZ(x)*hp_to_l;\n    return clamp(intensity * dot(normal, hp_to_l), 0.0, 1.0);\n    //return dot(normal, hp_to_l);\n}\nfloat linear(float x)\n{\n    const float inv_half_pi = 0.6366197723675813;\n    float intensity = INTENSITY;\n\n    vec2 light = vec2(4, -1.5);\n    vec2 hp = vec2(2, -1.5);\n    vec2 hp_to_l = normalize(light - hp);\n    vec2 normal = rotZ(x)*hp_to_l;;\n    float theta = acos(dot(normal, hp_to_l)) * inv_half_pi;\n\n    //return theta > 1. ? 0. : intensity * (1. - theta); // bad definition.\n    return clamp(intensity * (1. - theta), 0., 1.);\n    //return intensity * (1. - theta);\n}\nfloat explicit(float x) \n{ \n    return \n        iMouse.z > 0. ?\n            nonlinear(x) :\n            linear(x); \n}\nfloat dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return (explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n         \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC)*0.5; color -= y_axis(NDC)*0.5;\n         color -= vertical_line(NDC, 2.*3.141592)*0.5;\n         color -= cells(NDC)*0.2;\n         \n    /* Hit_point */\n    vec2 hp = vec2(4, -1.5);\n    vec3 hp_col = vec3(1,0,0);\n    color = mix(color, hp_col, SMAA(diskSDF_L2(NDC, hp, 0.05)));\n    /* */\n         \n    /* Point light */\n    vec2 light = vec2(2, -1.5);\n    vec3 light_col = vec3(1,0,0);\n    color = mix(color, light_col, SMAA(diskSDF_L2(NDC, light, 0.05)));\n    /* */\n    \n    /* Graph. */\n    float x = NDC.x,          \n          fx = explicit(x),\n          dfdx = dydx(x);        \n    color = mix(color, vec3(1,0,0)*fx, draw_explicit_func(NDC, fx, dfdx));\n    /* */\n    \n    /* Direction from hp to light, normal and hit point. */\n    x = fract(iTime*0.1) * (2. * 3.141592);\n    fx = explicit(x);\n    vec2 hp_to_l = normalize(light - hp),\n         normal = rotZ(x)*hp_to_l;\n    color = mix(color, vec3(0,1,0), 0.5*SMAA(arrowSDF_L2(NDC, hp, hp+hp_to_l, 0.0)));\n    color = mix(color, vec3(1,0,1), SMAA(arrowSDF_L2(NDC, hp, hp+normal, 0.0)));\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, vec2(x, fx), 0.05)));\n    color = mix(color, hp_col*fx, SMAA(diskSDF_L2(NDC, hp, 0.05)));\n    /**/\n    \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n// Points exactly at point E.\nfloat arrowSDF_L2(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.275, //      U--\n         U = C + up  * 0.10,  // B----C----E\n         D = C - up  * 0.10;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.275 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}","name":"Common","description":"","type":"common"}]}