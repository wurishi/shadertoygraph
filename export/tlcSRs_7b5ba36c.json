{"ver":"0.1","info":{"id":"tlcSRs","date":"1581524075","viewed":78,"name":"My first 3D demo","username":"pspupsp","description":"It' s just my first demo:)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Sphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord.st / iResolution.st;\n\t     uv = uv * 2.0 - 1.0;\n\n\tfloat aspectRatio = iResolution.s / iResolution.t;\n\tuv.x *= aspectRatio;\n\t\n\tvec2 screenCentre = vec2(0.0);\n\tfloat camToScreenDistance = 1.0;\n\t\n\tvec2 centreToUV = uv - screenCentre;\n\tvec3 camToUV = vec3(centreToUV, camToScreenDistance);\n\tvec3 camToCentre = vec3(0.0, 0.0, camToScreenDistance);\n\t\n\tvec3 normCamToUV = normalize(camToUV);\n\tvec3 normCamToCentre = normalize(camToCentre);\n\t\n\n\t//vec3 sphereCentre = vec3(sin(iTime) * 2.0 - 1.0, cos(iTime) * 2.0 - 1.0, 3.0 + (sin(iTime * 10.0) * 2.0 - 1.0) * 0.5);\n    vec3 sphereCentre = vec3(sin(iTime * 5.0), cos(iTime * 5.0), 1.0 + (cos(iTime * 10.0) + 1.0) * 2.0);\n\tfloat sphereRadius = 1.0;\n\n\n\n\n\tvec3 posInScreen = vec3(uv, 0.0);\n\tvec3 pos = vec3(uv, -camToScreenDistance);\n\n\tfloat avaliable = 0.0;\n\tfloat depthMap = 1.0;\n\n\tconst int samp = 64;\n\tfloat stepLength = 0.1;\n\tfor(int i = 0; i <= samp; i++)\n\t{\n\t\tpos += normCamToUV * stepLength;\n\t\tfloat map = Sphere(sphereCentre - pos, sphereRadius);\n\n\t\tif(map < 0.02)\n\t\t{\n\t\t\tavaliable = 1.0;\n\t\t\tdepthMap += length(pos - posInScreen) / (float(samp) * stepLength) - 1.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdepthMap = clamp(depthMap, 0.0, 1.0);\n\n\tfragColor = vec4(vec3(depthMap), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}