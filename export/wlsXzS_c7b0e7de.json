{"ver":"0.1","info":{"id":"wlsXzS","date":"1603924458","viewed":402,"name":"vogel_disk_sampling","username":"myrkott","description":"Rotating Vogel disk with per-frame radius jittering. This sampling pattern can be used in combination with temporal anti-aliasing for, e.g., SSAO, shadow map filtering, DoF, etc. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rotating Vogel disk with per-frame radius jittering. This sampling pattern\n// provides good spatial coverage with only a few sampling points and can be\n// used in combination with temporal anti-aliasing for, e.g., SSAO, shadow map\n// filtering, DoF, etc. The plot shows the distribution of NUM_SAMPLES over\n// NUM_FRAMES.\n//\n// References:\n// - Spreading points on a disc and on a sphere, http://blog.marmakoide.org/?p=1\n// - M. Gjoel and M. Svendsen, The rendering of INSIDE, GDC 2016, p. 43\n//   https://www.gdcvault.com/play/1023002/Low-Complexity-High-Fidelity-INSIDE.\n//\n// Author: Johan Nysj√∂\n\n#define NUM_SAMPLES 6\n#define NUM_FRAMES 60\n#define PI 3.14159265398\n\nvec3 srgb2lin(vec3 color)\n{\n\treturn color * color;    \n}\n\nvec3 lin2srgb(vec3 color)\n{\n \treturn sqrt(color);   \n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed * 12.9899) * 43758.5453); \n}\n\nvec2 vogel_disk(int i, int num_samples, float r_offset, float phi_offset)\n{\n\tfloat r = sqrt((float(i) + r_offset) / float(num_samples));\n    float golden_angle = 2.399963229728;\n    float phi = float(i) * golden_angle + 2.0 * PI * phi_offset;\n    float x = r * cos(phi);\n    float y = r * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat aastep(float edge, float x)\n{\n    float aawidth = 0.7 * fwidth(x);\n\treturn smoothstep(edge - aawidth, edge + aawidth, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 p = (2.0 * uv - 1.0) * vec2(aspect, 1.0);\n\n    vec3 background_color = srgb2lin(vec3(0.8, 0.8, 0.8));\n    vec3 glyph_color = srgb2lin(vec3(0.7, 0.1, 0.1));\n    float glyph_size = 0.03;\n\n    // NOTE: the seed should be fetched from, e.g., a tiled blue noise texture\n    // when the vogel disk is used as a filter kernel for postprocessing effects\n    vec2 seed = vec2(0.0, 0.0);\n\n    vec3 output_color = background_color;\n    for (int i = 0; i < NUM_FRAMES; ++i) {\n        float r_offset = hash(seed.x + float((iFrame + i) % 1000));\n        float phi_offset = fract(seed.y + sqrt(3.0) * float((iFrame + i) % 1000));\n        float glyph_alpha = float(i + 1) / float(NUM_FRAMES);\n        for (int j = 0; j < NUM_SAMPLES; ++j) {\n            vec2 q = vogel_disk(j, NUM_SAMPLES, r_offset, phi_offset);\n            float dist = length(p - q);\n            float alpha = glyph_alpha * (1.0 - aastep(glyph_size, dist));\n            output_color = alpha * glyph_color + (1.0 - alpha) * output_color;\n        }\n    }\n\toutput_color = lin2srgb(output_color);\n    \n    fragColor = vec4(output_color, 1.0);\n}","name":"Image","description":"","type":"image"}]}