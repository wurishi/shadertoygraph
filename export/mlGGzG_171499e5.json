{"ver":"0.1","info":{"id":"mlGGzG","date":"1684212413","viewed":235,"name":"Physically Accurate Starfield","username":"shake_n_jake","description":"Physically accurate starfield.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["worley","stars","blackbody","physically","accurate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Easy adaptive sampling */\n/* source: https://www.shadertoy.com/view/3ljfRG */\n\n#define N 5      // pixel oversampling NxN ( only where necessary )\n#define eps 1e-2 // similarity threshold, is case of continuous mask\n\n#define T(U,l)          textureLod(iChannel0, (U)/R, float(l-1) )\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage(out vec4 O, vec2 u) \n{\n    float an = 12.0 + 0.01*iTime + 10.0*iMouse.x/iResolution.x;\n\n    O -= O;\n    float n = float(N),\n          S = 1. / R.y;\n\n    vec2 U = S* ( 2.*u - R );\n\n    // for bench: always oversample\n    for (int k=0; k<N*N; k++) {    // --- oversampling\n        vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n        O += f( U + D*2.*S, an );\n    }\n    O /= n*n;\n    \n    float exposure = mix(25., 25000., 0.5+0.5*sin(iTime));\n\n    O = 1.0 - exp(-O * exposure);\n    O = pow(O, vec4(1.0 / 2.2));\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n//#define ZOOM\n\n#define R              iResolution.xy\n\n#define M_PI           3.1415926535897932\n#define M_1_4PI        0.0795774715459476 // 1/(4pi)\n\n#define LIGHT_YEAR     9.4607e+15         // One light year in meters.\n#define STELLAR_RADIUS 6.957e+8           // Radius of the sun in meters.\n#define SIGMA          5.670367e-8        // Stefan-Boltzmann constant.\n\n#define RATIO          3.066257e-22       // (STELLAR_RADIUS^2 * SIGMA) / LIGHT_YEAR^2\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\n/* Hash by David_Hoskins */\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n/* Source: https://www.shadertoy.com/view/3dVXDc */\nvec4 worley(vec3 uv)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    vec4 v = vec4(10000, 0.0, 0.0, 0.0);\n\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n              vec3 offset = vec3(x, y, z);\n              vec3 h = hash33((id + offset));\n              vec3 d = p - (h + offset);\n\n              float s = smoothstep(-1.0, 1.0, (v.x-length(d))/0.3);\n              v.yzw = mix(v.yzw, h, s);\n              v.x = min(v.x, length(d));\n            }\n        }\n    }\n    return v;\n}\n\n/* source: http://www.physics.sfasu.edu/astro/color/blackbody.html */\nvec3 star_color(float temp) {\n  float pt = pow(temp,-1.5)*1e5,\n        lt = log(temp);\n  return clamp(vec3(\n      561. * pt + 148.,\n      temp > 6500. ? 352. * pt + 184. : 100.04 * lt - 623.6,\n      194.18 * lt - 1448.6)/255., 0., 1.);\n}\n\nvec3 draw_stars(Ray ray)\n{\n  vec3 L = vec3(0.0);\n  \n  for (float i = 1.0; i < 2.0; i++) {\n\n      vec4 n = worley(ray.dir*250.*i);\n\n      float t = mix(2000.0, 10000.0, n.y); // Absolute Temperature (K)\n      float d = mix(1.0, 100.0, n.z);      // Light Years (m)\n      float r = mix(100.0, 1800.0, n.w);   // Stellar Radius (m)\n      \n      // radiant_flux = 4pi * sigma * t^4 * r^2 (W)\n      // radiant_intensity = radiant_flux / (4pi * d^2) (W * sr^-1)\n\n      float I = (t*t*t*t) * (r*r) * RATIO / (d*d);\n      L += vec3(exp(-n.x*mix(25., 45., n.y))) * star_color(t) * I;\n      \n  }\n  return L;\n}\n\nvec4 f(vec2 p, float an) \n{\n#ifdef ZOOM\n    float fov = mix(5.0, 50.0, 0.5+0.5*cos(an*10.));\n    vec3 ro = vec3( 3.0, 0., -3.0 );\n#else\n    float fov = 5.0;\n    vec3 ro = vec3( 3.0*cos(an), 0., 3.0*sin(an) );\n#endif\n    vec3 ta = vec3( 1.0, 1.0, 1.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\n    Ray ray;\n    ray.pos = vec3(0.0);\n    ray.dir = rd;\n\n    vec3 L_stars = draw_stars(ray);\n    vec3 L_atmo = mix(vec3(.31,.32,.75)*0.0001, vec3(0.0), .7+0.46*rd.y);\n\n    return vec4(L_stars+L_atmo,1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// --- evaluate the function everywhere at pixel resolution\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = ( 2.*u - R ) / R.y;\n    float an = 12.0 + 0.01*iTime + 10.0*iMouse.x/iResolution.x;\n    O = f(U, an);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}