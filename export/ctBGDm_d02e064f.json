{"ver":"0.1","info":{"id":"ctBGDm","date":"1673688271","viewed":146,"name":"Black hole 2D","username":"Amirk","description":"I modified the forked FabriceNeyret2's shader . An alternative ray-bending borrowed from http://rantonels.github.io/starless/ \nAccounted for time dilation and that rays move slower radially than \"tangentially\". \nReset ray origin with mouse.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["simulation","blackhole","physics","optics","gravity","relativity","geodesic"],"hasliked":0,"parentid":"wdt3zM","parentname":"light trajectory - 2D black hole"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMost of the shader code was done by FabriceNeyret2 https://www.shadertoy.com/view/wdt3zM\nI just modified some physics stuff and added commentary.\n*/\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O =  sqrt(T(U)) ;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//speed of light and gravitational constant G is assumed 1\n\n#define Size .165  \n//Schwarzschild radius:\n#define r_s Size*2.\n#define r_photon 3./2.*r_s\n#define isco 3.*r_s\n//A relevant component of the metric:\n#define g_tt(r) abs(1.-r_s/r)\n\n#define PI 3.14159265359\nconst float rayDensity=3.;\n\nfloat blueshift(float r1, float r2){\n    //gravitational shift of frequences as light travels from radius r1 to r2\n    float freq1Overfreq2=sqrt((1.-r_s/r2)/(1.-r_s/r1));\n    return freq1Overfreq2;\n}\n\nvoid mainImage( out vec4 O, vec2 u ) // --- simulates trajectories\n{\n    //O holds information about the dynamical variables:\n    //ray position: O.xy \n    //ray velocity: O.zw\n    //u.y is used to index the rays\n    \n    O = T(u); //We always draw on top of the previous frame\n    \n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n         \n    vec2 m;\n    //mouse click will reset the origin of the rays\n    if(iMouse.xy==vec2(0))\n         m = vec2(r_s+.1,0);\n    else{\n        m = (2.*iMouse.xy-R)/R.y;\n\n    } \n    float rOrigin=length(m.xy);\n    \n    \n    \n    //pixel (2,2) keeps track of the window size\n    //If the size changes or mouse is clicked we reset the process\n    if ( T(2).xy != R ||sign(iMouse.w)>0. ) {\n        //reset the everything:\n        O -= O;\n        \n        //Storing rays: enumerate rays with y values \n        //new states: u.xy=(0.5, y), which corresponds to pixels (0,y)\n        //old states: u.xy=(1.5, y), which corresponds to pixels (1,y)\n        if (u.x<2.){\n            \n            float VelAngle=U.y*PI;  //U.y*PI goes from -PI to PI\n            float PosAngle=atan(m.y,m.x);\n            float c = cos(VelAngle-PosAngle);\n            float s = sin(VelAngle-PosAngle);\n            \n            //The THE SPEED OF RAY DEPENDS ON DIRECTION AS WELL AS DISTANCE r.\n            //\"relative speed of light\". It is how it would \"look\" for a distant observer.\n            //Calculated from the metric components g_tt,g_rr,g_phiphi.\n            float raySpeed= g_tt(rOrigin)/sqrt(c*c+g_tt(rOrigin)*s*s);\n            \n            //we initalize the ray at speed of light in Schwarzschild soordinates:\n            O = vec4(m,raySpeed*cos(VelAngle),raySpeed*sin(VelAngle));     \n        }\n        else if (u==vec2(2.5)) O.xy = R; // for testing window size change\n        else O +=.15*S( length(U) - isco ) -.1*S( length(U) - r_photon )-S( length(U) - r_s ); // draw isco, photon sphere, and BH\n        return;\n    }\n    \n    \n    \n    if (u==vec2(2.5)) return; //this just holds the window size\n    \n    //PHYSICS: calculation of the next stage\n    if (u.x==.5) {\n        float r = length(O.xy);                   // distance to BH\n        if(r<.05){ //we hit singularity:\n            O.xy =  vec2(0);\n        }\n        else{\n            //specific angular momentum (constant of motion really)\n            float angularMom=abs(O.x*O.w-O.y*O.z);\n            /*\n            stepSize: Time slows down closer to the BH --> smaller stepSize\n            (We also scale time by the starting point rOrigin)\n            This is not physically exact, but it gives the right impression, and it adapts the stepsize\n            */\n            float dt  = .01*min(g_tt(r)/g_tt(rOrigin), 1./length(O.zw)); //.01/length(O.zw);   \n            dt=min(dt, abs(r-r_s)-.001);\n            \n            //FOR RAYS THAT ARE INSIDE HORIZON AND POINTING AWAY FROM IT:\n            if(r<r_s && dot(O.zw,O.xy)>0.){ \n                /*\n                If we left dt>0 (try it), \n                then inside event horizon these geodesics would go terminate at the horizon.\n                But, as is well known, inside EH the time and r-axes switch roles, so\n                outward going geodesics should be travelled \"backwards in time\",\n                in Schwarzschild coordinate time that is.\n                */\n\n                //We could reverse the time:\n                    //dt*=-1.;\n                //But the colors get blended so I just terminate these rays:    \n                dt*=0.;\n            }\n            \n            /*\n            The geodesic equation can be modelled with a fictious central \"force\" via Binet equation.\n            The orbits should be physically correct but the timescales are not exact.\n            (see: http://rantonels.github.io/starless/ )           \n            */\n            float Force =1.5*Size*angularMom*angularMom /(r*r*r*r*r);             \n            //update ray velocity BH\n            O.zw =  O.zw - dt * Force* O.xy/r ;\n            //update ray position\n            O.xy += dt * O.zw;\n        }\n                        \n    }\n    else if (u.x==1.5)                       // save prev ray position for drawing\n        O = T(vec2(0,u.y));\n    else {                                   // draw rays (new segment)\n        float dist = 1e5, rayIdx,  distFromRay;\n        \n        //finds out if U is close to any of the rays\n        for (float i=0.; i < R.y; i += rayDensity ) {\n            distFromRay = line( U, T(vec2(1,i)).xy, T(vec2(0,i)).xy);\n            if ( distFromRay < dist ){\n                dist = distFromRay;\n                rayIdx= i; //choose coloring according to this ray\n            }\n        }\n        float r=length(T(vec2(0,rayIdx)).xy);\n        float shift;\n        if(r>r_s)\n             shift=blueshift(length(m.xy),r);\n        else  \n            shift=1.;\n            \n        shift*=shift;\n        O += S( sqrt(dist) -0./R.y )* vec4(.5*shift,.5/(1.+abs(1.-shift)),.5/shift,1.);\n    }   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n\n// utils from https://www.shadertoy.com/view/llySRh\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),                  // proj coord on line\n          c = clamp(h, 0., 1.);\n    p -= b * h; return h==c ? dot(p,p): 1e5;          // distÂ² to segment\n}\n\n#define S(v) smoothstep( 3./R.y, 0., v)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n","name":"Common","description":"","type":"common"}]}