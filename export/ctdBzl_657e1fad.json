{"ver":"0.1","info":{"id":"ctdBzl","date":"1701476840","viewed":37,"name":"Inercia jam shading","username":"Exca","description":"Shader made during 2023 Inercia shader jam. Not exactly the same but about there.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["inercia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    vec3 c = texture(iChannel3, ouv).rgb;\n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float ffti = 0.0;\nfloat ffts = 0.0;\nfloat fft = 0.0;\nfloat glow = 0.0;\nfloat beat = 0.0;\nfloat beatstep = 0.0;\nfloat bar = 0.0;\nfloat barstep = 0.0;\n\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  return rotx*roty*rotz * p;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rot2d( float a, vec2 p)\n{\n  return mat2( cos(a), -sin(a), sin(a), cos(a)) * p;\n}\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod(p + q*0.5, q)-q*0.5;\n}\n\nvec3 textureMap( vec3 surfacepos, vec3 normal)\n{\n  mat3 trimap = mat3(\n    texture(iChannel0, surfacepos.yz).rgb,\n    texture(iChannel0, surfacepos.xz).rgb,\n    texture(iChannel0, surfacepos.xy).rgb\n  );\n  return trimap * normal;\n}\nvec3 textureMap2( vec3 surfacepos, vec3 normal)\n{\n  mat3 trimap = mat3(\n    texture(iChannel1, surfacepos.yz).rgb,\n    texture(iChannel1, surfacepos.xz).rgb,\n    texture(iChannel1, surfacepos.xy).rgb\n  );\n  return trimap * normal;\n}\n\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize( cross(vec3(0,1,0), forward));\n  vec3 up = normalize( cross(forward, right));\n  return normalize( forward * fov + uv.x * right + uv.y * up);\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat box( vec3 pos, vec3 size)\n{\n  vec3 q = abs(pos)-size;\n  return length(max(q,0.0)+min(max(q.x, max(q.y, q.z)), 0.0));\n}\n\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nvec3 Union( vec3 a, vec3 b)\n{\n  if(a.x < b.x) return a;\n  return b;\n}\n\nvec3 map( vec3 p)\n{\n  vec2 id = floor( (p.xz+vec2(2.0))*0.25);\n  vec3 hexP = repeat(p+vec3(iTime*id.x,0.0,0.0), vec3(2.0, 0.0, 2.0))+\n      vec3(0.0, -1.0+1.0*sin(id.x+id.y + ffti*1.0), 0.0);\n  hexP = rotate(hexP, ffti + id.x -id.y,-ffti + id.x -id.y, 0.0);\n  \n  float s1 = sphere( \n    repeat(p, vec3(2.0, 0.0, 2.0))+\n      vec3(0.0, -1.0+0.5*sin(id.x+id.y + ffti*1.0), 0.0), \n    0.5 + sin(ffts+id.x-id.y)*0.15);\n  \n  float oct1 = octahedron( hexP, 0.85+ffts);\n  \n  float hex1 = hexPrism( \n    hexP, \n    vec2(0.5 + sin(ffts+id.x-id.y)*0.1));\n  \n  s1 = mix( oct1, hex1, ffts);\n  \n  float b1 = box(p, vec3(95.0, 0.1, 95.0));\n  vec3 S1 = vec3(s1, 1.0, 0.0);\n  vec3 B1 = vec3(b1, 1.4, 0.0);\n  glow += 1.0- smoothstep( 0.0, 0.4, s1);\n  float bm = mod(bar*0.5, 11.0);\n  if( mod(bm, 2.0) < 1.0) return B1;\n  return Union(S1, B1);\n}\n\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float travel)\n{\n  float minim = 99.0;\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd*travel;\n    vec3 r = map(p);\n    travel+=r.x;\n    minim = min(r.x, minim);\n      \n    if(r.x < 0.001)\n    {\n      return r;\n    }\n    if(travel > 90.0)\n    {\n      travel = 90.0;\n      return vec3(minim, 0.0, 0.0);\n    }\n  }\n  return vec3(minim, 0.0, 0.0);\n}\n\nvec3 normal( vec3 p )\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.01, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x);\n}\n\nfloat diffuse( vec3 p, vec3 l, vec3 n)\n{\n  return max(0.0, dot(n,normalize(l-p)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 ouv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n      ffti = iTime;// texture(texFFTIntegrated,0.2).r;\n      ffts = texture(iChannel2, vec2(0.15,0.5)).r*0.5+sin(iTime)*0.5;\n  \n  \n  \n      vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  beat = floor(iTime * 130.0 / 60.0);\n  beatstep = fract( iTime * 130.0 / 60.0*1.0);\n  bar = floor(beat/4.0);\n  barstep = fract(beat/4.0);\n  \n\tvec3 c = vec3(0.0);\n  \n  \n  \n  vec3 target = vec3(0,1,1.0);\n  vec3 cam = target - vec3(cos(iTime*0.3),sin(iTime*0.3)-4.0,2.0);\n  float fov = 0.8;\n  \n  float bm = mod(bar,4.0);\n  if(bm < 1.0){\n    target = vec3(0.01);\n    cam = target - vec3(cos(iTime*0.06)-3.0,sin(iTime*0.3)*0.5-3.0,2.0);\n    fov = mix( 0.2, 1.0, barstep);\n  \n  }\n  else if(bm < 2.0){\n    target = vec3(0.01);\n    cam = target - vec3(cos(iTime*0.56)-3.0,sin(iTime*0.13)-9.0,-8);\n    fov = mix( 1.2, 3.0, barstep);\n  \n  }\n  else if(bm < 3.0){\n    target = vec3(0.0, 0.0, sin(iTime*0.4)*3.0);\n    cam = target - vec3(cos(iTime*0.56)-3.0,sin(iTime*0.03)-5.0,-3);\n    fov = mix( 1.2, 0.05, barstep);\n  \n  }\n  else if(bm < 4.0){\n    fov = mix( 0.5, 1.0, barstep);\n  \n  }\n  \n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  vec3 light1 = target + vec3( 0.0, 2.0, sin(iTime));\n  \n  vec3 marchP = cam;\n  float marchT = 0.0;\n  vec3 res = march( cam, rd, marchP, marchT);\n  float shadow = 1.0;\n  // Materials\n  if(res.y < 0.5)\n  {\n    // Sky\n    \n  }\n  else if(res.y < 1.5)\n  {\n    // obj 1\n    vec3 n = normal(marchP);\n    vec3 mapUv = marchP;\n    \n    if(res.y < 1.25){\n      c = vec3(1.0) * textureMap(mapUv, n) * diffuse( marchP, light1, n);\n      c = mix( vec3(1.0, 0.6,0.2), c, length(c));\n      c = palette( length(c), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));\n    }\n    else {\n      mapUv.xz = rot2d( ffti*0.7 + length(mapUv.xz)*0.05, mapUv.xz);\n      c= vec3(1.0) * textureMap2(mapUv*(0.1*smoothstep(0.0, 1.0,beatstep)+0.05), n) * diffuse( marchP, light1, n);\n      c = palette( length(c), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));\n    }\n    // Shadows\n    vec3 shadowP = marchP;\n    float shadowT = 0.0;\n    vec3 shadowMarch = march( marchP+n*0.1, normalize( light1 - marchP), shadowP, shadowT)*0.95;\n    c *= 0.15+ smoothstep(0.0, 0.15,shadowMarch.x);\n    shadow = 0.05+ smoothstep(0.0, 0.15,shadowMarch.x);\n    // Reflection\n    vec3 ref = reflect( rd, n);\n    vec3 refP = marchP;\n    float refT = 0.0;\n    vec3 refR = march( marchP+n*0.1, ref, refP, refT);\n    if(refR.y < 0.5) {\n      // sky\n      \n    }\n    else if(refR.y < 1.5)\n    {\n      // Ground\n      n = normal(refP);\n      mapUv = refP;\n      mapUv.xz = rot2d( ffti*0.7 + length(mapUv.xz)*0.25, mapUv.xz);\n      vec3 rc =  vec3(0.0);//vec3(1.0) * textureMap(mapUv, n) * diffuse( refP, light1, n);\n      \n      if(refR.y < 1.25){ \n        rc = vec3(1.0) * textureMap(mapUv, n) * diffuse( refP, light1, n);\n        rc = palette( length(rc), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));\n      }\n      else rc = vec3(1.0) * textureMap2(mapUv, n) * diffuse( refP, light1, n);\n      // Shadows\n      shadowP = refP;\n      shadowT = 0.0;\n      shadowMarch = march( refP+n*0.1, normalize( light1 - refP), shadowP, shadowT)*0.95;\n      rc *= 0.0+ smoothstep(0.0, 0.15,shadowMarch.x);\n      \n      c = mix(c, rc, 0.05);\n    }\n  }\n  \n  c = mix( c, vec3(0.4, 0.2, 0.1), smoothstep(2.0, 20.0, marchT));\n  c += glow*0.08*palette( length(c), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20))*shadow;\n  //c += inercia(uv * vec2(1.0, 1.0+ ffts) + iTime*vec2(0.2,0.0));\n  \n  if(bm < 1.0) c.rgb = c.grb;\n  else if(bm < 2.0) c.rgb = c.brg;\n  else if(bm < 3.0) c.rgb = c.rbg;\n  else if(bm < 4.0) c.rgb = c.gbr;\n  \n  ouv -= 0.5;\n  ouv *= 0.99;\n  ouv += 0.5;\n  vec3 prev = texture(iChannel3, ouv).rgb;\n  c = mix( c, c+prev*0.75, ffts);\n  \n\tfragColor = vec4(c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}