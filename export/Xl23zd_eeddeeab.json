{"ver":"0.1","info":{"id":"Xl23zd","date":"1431623315","viewed":2097,"name":"Silo","username":"dila","description":"Inspired by Hamneggs' Parking Garage: https://www.shadertoy.com/view/Xt2GRG","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["camera","reflections","flythrough"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat map(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    vec3 l = fract(p/2.0)*2.0 * 2.0 - 1.0;\n    vec3 m = fract((p+vec3(0.0,0.0,1.0))/2.0)*2.0 * 2.0 - 1.0;\n    vec3 u = fract(p+vec3(0.0,0.0,0.5)) * 2.0 - 1.0;\n    float ts = 0.5;\n\tfloat d = max(ts-length(q.xy), ts*1.8-length(l.xz));\n    d = max(d, ts-length(u.yz));\n    d = min(d, p.y-0.35);\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 _texture(vec3 p)\n{\n    vec3 ta = texture(iChannel0, vec2(p.y,p.z)).xyz;\n    vec3 tb = texture(iChannel0, vec2(p.x,p.z)).xyz;\n    vec3 tc = texture(iChannel0, vec2(p.x,p.y)).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvec3 quad(vec3 a, vec3 b, vec3 c, float t)\n{\n \tvec3 u = mix(a, b, t);\n    vec3 v = mix(b, c, t);\n    return mix(u, v, t);\n}\n\nvec3 position(float b, float o)\n{\n    float idx = floor(mod(b, 5.0));\n    float t = fract(b) + o;\n    if (idx == 2.0) {\n        return mix(vec3(0.3, 0.8, 0.6),\n                   vec3(0.4, 1.3, 0.5), t);\n    } else if (idx == 1.0) {\n        return quad(vec3(0.1, 0.5, 0.5),\n                    vec3(0.5, 0.5, 0.5),\n                    vec3(0.5, 0.6, 1.0), t);\n\t} else if (idx == 0.0) {\n        return quad(vec3(0.5, 0.5, -0.5),\n                    vec3(0.5, 0.5, 0.5),\n                    vec3(0.5, 1.5, 0.6), t);\n    } else if(idx == 3.0) {\n        return quad(vec3(0.5, 0.5, 0.5),\n                    vec3(0.1, 0.5, 0.5),\n                    vec3(0.5, 0.5, 1.0), t);\n    } else {\n        return mix(vec3(0.5, 0.5, 0.0),\n                   vec3(-0.5, 0.5, 0.0),\n                   t);\n    }\n}\n\nmat3 orientation(float time)\n{\n    mat3 m;\n    vec3 a = position(time, 0.0);\n    vec3 b = position(time, 0.01);\n    m[2] = normalize(b - a);\n    m[1] = vec3(0.0, 1.0, 0.0);\n    m[0] = normalize(cross(m[2], m[1]));\n    m[2] = normalize(cross(m[1], m[0]));\n    return m;\n}\n\nvec3 shade(vec3 p, vec3 r)\n{\n    vec3 o = p;\n    vec4 fc = vec4(0.0);\n    vec4 sc = vec4(0.0);\n    vec3 sn = vec3(0.0);\n    for (int i = 0; i < 2; ++i) {\n        float t = trace(p + sn * 0.01, r);\n        p = p + r * t;\n        sn = normal(p);\n        vec3 q = fract(p/2.0+vec3(0.0,0.0,0.5))*2.0*2.0 - 1.0;\n        vec3 s = fract(p/2.0)*2.0 * 2.0 - 1.0;\n        vec3 v = fract(p+0.5) * 2.0 - 1.0;\n        vec4 lc = vec4(0.0);\n        \n        float prod = max(dot(r,-sn), 0.0);\n        float fd = map(p);\n        float fog = 1.0 / (1.0 + t * t * 0.1 + fd * 10.0);\n        float pfog = prod * fog;\n        \n        if (abs(length(s.xz)-0.7) < 0.03) {\n            lc = pfog * vec4(1.0, 1.0, 0.0, 0.0);\n        } else if (sn.y > 0.999) {\n            lc = pfog * vec4(1.0, 1.0, 1.0, 0.25);\n        } else if (abs(v.x) < 0.05) {\n            lc = pfog * vec4(1.0, 1.0, 0.0, 0.0);\n        } else if (abs(q.z) < 0.05) {\n            lc = pfog * vec4(1.0, 1.0, 0.0, 0.0);\n        } else if (abs(p.y-1.0) < 0.02) {\n            lc = pfog * vec4(1.0, 1.0, 0.0, 0.0);\n        } else {\n        \tlc = pfog * vec4(0.5-0.5*sin(1.0*(_texture(p*yrot(pi*0.25)).x*2.0-1.0)));\n            lc.w = 0.0;\n        }\n        r = reflect(r, -sn);\n        fc = sc;\n        sc = lc;\n    }\n\treturn mix(fc.xyz, sc.xyz, vec3(fc.a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n   \tvec3 r = normalize(vec3(uv, 0.7 - dot(uv,uv) * 0.2));\n    \n    float ts = iTime * 0.125;\n    r *= orientation(ts);\n    vec3 o = position(ts, 0.0);\n\n    vec3 fc = shade(o, r);\n    \n    float fade = sin(fract(ts)*pi);\n    fade = 1.0 - pow(1.0 - fade, 8.0);\n    fc = mix(fc, vec3(0.0, 0.0, 0.0), 1.0-fade);\n    \n\tfragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}