{"ver":"0.1","info":{"id":"dsjSWw","date":"1670411332","viewed":60,"name":"Sinusoidal Disco","username":"demensdeum","description":"\"Cool\" shader written by ChatGPT","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blending","weird","huetorgb","rgbtohsl","chatgpt","hsltorgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 RGBToHSL(vec3 rgb)\n{\n    // Normalize the RGB values\n    vec3 normRGB = rgb / 255.0;\n\n    // Calculate the minimum and maximum RGB values\n    float minRGB = min(min(normRGB.r, normRGB.g), normRGB.b);\n    float maxRGB = max(max(normRGB.r, normRGB.g), normRGB.b);\n\n    // Initialize the HSL values with the luminance\n    vec3 hsl = vec3((maxRGB + minRGB) / 2.0);\n\n    // If the min and max RGB values are equal, the color is a shade of gray\n    if (minRGB == maxRGB)\n    {\n        // In this case, the hue and saturation are zero\n        hsl.x = 0.0;\n        hsl.y = 0.0;\n    }\n    else\n    {\n        // Calculate the hue and saturation\n        float delta = maxRGB - minRGB;\n        hsl.y = (hsl.z < 0.5) ? (delta / (maxRGB + minRGB)) : (delta / (2.0 - maxRGB - minRGB));\n\n        if (normRGB.r == maxRGB)\n        {\n            hsl.x = (normRGB.g - normRGB.b) / delta;\n        }\n        else if (normRGB.g == maxRGB)\n        {\n            hsl.x = 2.0 + (normRGB.b - normRGB.r) / delta;\n        }\n        else\n        {\n            hsl.x = 4.0 + (normRGB.r - normRGB.g) / delta;\n        }\n\n        // Scale the hue to the range [0,1]\n        hsl.x /= 6.0;\n        if (hsl.x < 0.0)\n        {\n            hsl.x += 1.0;\n        }\n    }\n\n    return hsl;\n}\n\nfloat HueToRGB(float v1, float v2, float vH)\n{\n    if (vH < 0.0)\n    {\n        vH += 1.0;\n    }\n    if (vH > 1.0)\n    {\n        vH -= 1.0;\n    }\n    if ((6.0 * vH) < 1.0)\n    {\n        return (v1 + (v2 - v1) * 6.0 * vH);\n    }\n    if ((2.0 * vH) < 1.0)\n    {\n        return v2;\n    }\n    if ((3.0 * vH) < 2.0)\n    {\n        return (v1 + (v2 - v1) * ((2.0/3.0) - vH) * 6.0);\n    }\n    return v1;\n}\n\nvec3 HSLToRGB(vec3 hsl)\n{\n    // Initialize the RGB values with the luminance\n    vec3 rgb = vec3(hsl.z);\n\n    // If the saturation is zero, the color is a shade of gray\n    if (hsl.y == 0.0)\n    {\n        // In this case, the RGB values are the same as the luminance\n        rgb = vec3(hsl.z);\n    }\n    else\n    {\n        // Calculate the intermediate values\n        float v2 = (hsl.z < 0.5) ? (hsl.z * (1.0 + hsl.y)) : ((hsl.z + hsl.y) - (hsl.z * hsl.y));\n        float v1 = 2.0 * hsl.z - v2;\n\n        // Calculate the RGB values\n        rgb.r = HueToRGB(v1, v2, hsl.x + (1.0/3.0));\n        rgb.g = HueToRGB(v1, v2, hsl.x);\n        rgb.b = HueToRGB(v1, v2, hsl.x - (1.0/3.0));\n    }\n\n    return rgb;\n}\n\n\nvec3 hue(vec3 color, float hueShift)\n{\n    // Convert the color to HSL color space\n    vec3 hsl = RGBToHSL(color);\n\n    // Shift the hue value\n    hsl.x += hueShift;\n\n    // Clamp the hue value to the range [0,1]\n    hsl.x = clamp(hsl.x, 0.0, 1.0);\n\n    // Convert the shifted color back to RGB color space\n    vec3 shiftedColor = HSLToRGB(hsl);\n\n    // Scale the shifted color back to the [0,255] range and return it\n    return shiftedColor * 255.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the UV coordinates of the current pixel\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Perturb the UV coordinates to create a wavy effect\n    uv.x += 0.05 * sin(uv.y * 10.0 + iTime);\n    uv.y += 0.05 * sin(uv.x * 10.0 + iTime);\n\n    // Use the perturbed UV coordinates to sample the iChannel0 texture\n    vec4 texColor = texture(iChannel0, uv);\n\n    // Shift the hue of the texture color\n    texColor.rgb = hue(texColor.rgb, 0.5*sin(iTime));\n\n    // Mix the shifted color with the original color using a mask texture\n    vec4 mask = texture(iChannel1, uv);\n    fragColor = vec4(mix(texColor.rgb, mask.rgb, mask.a), 1.0);\n}","name":"Image","description":"","type":"image"}]}