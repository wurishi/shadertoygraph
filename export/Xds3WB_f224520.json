{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//learning about distance fields, raymarching & matrices\n//referencing https://www.shadertoy.com/view/Xds3zN by IQ\n//feel free to offer suggestions/improvements\n//ndxbxrme\n\nint hitObject = 1;\nfloat objectId = 0.;\nfloat dist = 0.;\nint steps = 0;\n\n//http://en.wikipedia.org/wiki/Matrix_rotation\nvec3 rotateX(vec3 p, float t)\n{\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\tmat3 m = mat3(\n\t\t1.0, 0.0, 0.0, \n\t\t0.0, c, -s, \n\t\t0.0, s, c\n\t\t);\n\treturn p * m;\n}\n\nvec3 rotateY(vec3 p, float t)\n{\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\tmat3 m = mat3(\n\t\tc, 0.0, s, \n\t\t0.0, 1, 0.0, \n\t\t-s, 0.0, c\n\t\t);\n\treturn p * m;\n}\n\nvec3 rotateZ(vec3 p, float t)\n{\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\tmat3 m = mat3(\n\t\tc, -s, 0.0, \n\t\ts, c, 0.0, \n\t\t0.0, 0.0, 1.0\n\t\t);\n\treturn p * m;\n}\n\nfloat sdWorm(vec3 p, float s)\n{\n\t\n\tp = rotateX(p, iTime);\n\tp = rotateY(p, iTime);\n\tp = rotateZ(p, iTime);\n\tp.x +=  smoothstep( 0.0,0.8, sin(25.0*p.y) ) * .2;\n\tp.x += sin(p.y + iTime *  2.);\n\tp.y *= sin(iTime*.23)*.25;\n\treturn length(p)-s;\t\n}\n\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 pos)\n{\n\t//rendering the worm alone causes inconsitencies\n\t//i've fixed this for now by adding a plane behind it\n\t//but i don't like having to do that :(\n\treturn opU(vec2(sdWorm(pos, 0.6), 1.0), vec2(pos.z + 11., 2.0));\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0.0, 0.0 ); //smaller values cause edge detection to fail :(\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid castRay(vec3 ro, vec3 rd, float maxd)\n{\n\tint result = 0;\n\tfloat precis = 0.00001;\n\tfloat h = precis * 2.;\n\tfloat t = 0.;\n\tfloat oid = 0.;\n\tfor(int i=0; i<60; i++)\n\t{\n\t\tt += h;\n\t\tif( abs(h)<precis||t>maxd) {\n\t\t\t\tsteps = i-1;\n\t\t\t\tcontinue;\t\n\t\t}\n\t\t\n\t\tvec2 res = map(ro + rd * t);\n\t\th = res.x;\n\t\toid = res.y;\n\t}\n\tif( t<maxd) {\n\t\tobjectId = oid;\n\t}\n\telse hitObject = 0;\n\tdist = t;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 col = vec3(0.0);\n\tcastRay(ro, rd, 20.0);\n\tif(hitObject > 0)\n\t{\n\t\tvec3 pos = ro + dist * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tcol = vec3(0.2, 0.1, 0.0);\n\t\t//edge detection, i'm surprised this works as well as it does :)\n\t\tfloat k = dot(rd,nor);\n\t\tif(k>-0.5) col += vec3(smoothstep(-0.5, -0.0, k));\t\n\t\t\n\t}\n\telse {\n\t\t//glow, neither of my attempts worked very well :(\n\t\tcol += vec3(inversesqrt(dist/20.) * vec3(0.6,0.8,1.0) * sin(iTime * 0.2)) * float(steps)/60.;\n\t\t//col += smoothstep(0., 1., float(steps)/60.);\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.+2.*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(0.0, 0.0, -10.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x*cu + p.y*cv + 2.5 * cw);\n\t\n\tvec3 col = vec3(0.0);\n\tcol = render(ro, rd) * .5;\n\tcol += render(ro, rd + vec3(0.0001,0.0001,0.0)) * .5; //2x antialiasing ;)\n\tfragColor = vec4( col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xds3WB","date":"1378565400","viewed":252,"name":"Fatworm blows a sparky","username":"ndxbxrme","description":"Just an experiment.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields","edgedetection","matrix","rotation"],"hasliked":0,"parentid":"","parentname":""}}