{"ver":"0.1","info":{"id":"tstBD2","date":"1606251229","viewed":90,"name":"Path Tracing Testing 32","username":"Pjbomb2","description":"WASD and mouse for camera controls\nIncrease bounce count define in common for more ray bounces\nNeed advice for how to improve the image quality/realism of this renderer, but most importantly how to optimize it please!","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["spheretracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//How can I optimize this?  \n//Did I do the refraction physically correctly?(is it physically correct?)\n//also what would be a good method to debug the rays in this?\n//finally, what/where would be a better place to ask questions like this?\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec3 col = vec3(0.0);\n    \n        col = texture( iChannel3, uv ).xyz;\n            // convert unbounded HDR color range to SDR color range\n    col = ACESFilm(col);\n\n    // convert from linear to sRGB for display\n    col = LinearToSRGB(col);\n    \n\n\n\n\n\n    \n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BOUNCECOUNT 3\n#define grate\n\n\n\n\n//Color correction from Demofox\nvec3 LessThan(vec3 f, float value)\n{\n    //Reccomended change by Dave_Hoskins\n    return vec3(lessThan(f, vec3(value)));\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n//Texture applyer by IQ\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x+m.y+m.z);\n}\n\n//SDF functions\n\nfloat opIntersection( float d1, float d2 ) { \nreturn (d1 > d2) ? d1:d2;\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return (-d1 > d2) ? -d1:d2;\n}\n\nvec2 find_nearest(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1:d2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdBox(q,vec3(0.5, 0.5, 0.5));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdCapsule(q, vec3(0, 0, -4), vec3(0,0,12), 0.75);\n}\n\nfloat opRepLimHoriz( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdCapsule(q, vec3(-7, 0, 0), vec3(7,0,0), 0.75);\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n\t\n\t\n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDistanceWine( vec3 vPos )\n{\n    vec3 vLocalPos = vPos;\n    vLocalPos.y -= 2.0;\n    \n    vec2 vPos2 = vec2(length(vLocalPos.xz), vLocalPos.y);\n    \n    vec2 vSphOrigin = vec2(0);\n    vec2 vSphPos = vPos2 - vSphOrigin;   \n    \n    float fBowlDistance = length( vSphPos ) -  0.6 + 0.01;\n    \n    vec3 vWaterNormal = vec3(0,1,0);\n    \n    vWaterNormal.x = sin(5.0) * 0.01;\n    vWaterNormal.z = cos( 5.0) * 0.01;\n    \n    vWaterNormal = normalize( vWaterNormal );\n    float fWaterLevel = dot(vLocalPos, vWaterNormal) - 0.1;\n        \n    return max( fBowlDistance, fWaterLevel );\n}\n\nfloat GetDistanceWineGlass( vec3 vPos )\n{\n    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);\n    \n    vec2 vSphOrigin = vec2(0,2.0);\n    vec2 vSphPos = vPos2 - vSphOrigin;\n    \n    vec2 vClosest = vSphPos;\n    \n    if ( vClosest.y > 0.3 ) vClosest.y = 0.3;\n    vClosest = normalize(vClosest) * 0.6;\n    \n    float fBowlDistance = distance( vClosest, vSphPos ) - 0.015;\n    \n    vec2 vStemClosest = vPos2;\n    vStemClosest.x = 0.0;    \n    vStemClosest.y = clamp(vStemClosest.y, 0.0, 1.35);\n    \n    float fStemRadius = vStemClosest.y - 0.5;\n    fStemRadius = fStemRadius * fStemRadius * 0.02 + 0.03;\n    \n    float fStemDistance = distance( vPos2, vStemClosest ) - fStemRadius;\n    \n    \n    vec2 norm = normalize( vec2( 0.4, 1.0 ) );\n    vec2 vBaseClosest = vPos2;\n    float fBaseDistance = dot( vPos2 - vec2(0.0, 0.1), norm ) - 0.2;\n    fBaseDistance = max( fBaseDistance, vPos2.x - 0.5 ); \n\n    float fDistance = SmoothMin(fBowlDistance, fStemDistance, 0.2);\n    fDistance = SmoothMin(fDistance, fBaseDistance, 0.2);\n    \n    fDistance = max( fDistance, vSphPos.y - 0.5 );\n        \n    return fDistance;\n}\nmat2 rotation(float angle) {\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, s, -s, c);\n}\n\n\nvec2 tablemap(in vec3 p, in vec3 s) {\n    vec2 d = vec2(1000, 0);\n    vec3 q = p;\n    q.xz = abs(q.xz);\n    d = find_nearest(d, vec2(sdCapsule(q, vec3(0.75, -0.75, 0.75)*s, vec3(0.75, 0.75, 0.75)*s, 0.2), 5.0));\n    \n    d = find_nearest(d, vec2(sdBox(p - vec3(0, 0.75, 0) * s, vec3(1, 0.2, 1)*s), 4.0));\n    \n    d = find_nearest(d, vec2(opIntersection(sdBox(p - vec3(0,2, 0), vec3(0.75, 1.2, 0.75)), GetDistanceWineGlass(p - vec3(0, 0.8, 0))), 11.0));\n    \n    d = find_nearest(d, vec2(GetDistanceWine(p - vec3(0, 0.78, 0)), 13.0));\n    return d;\n}\n\n\nvec2 bulbmap(in vec3 p) {\n     vec2 d = vec2(1000, 0);\n    //d = find_nearest(d, vec2(sdCappedCone(p, vec3(0, 0, 0), vec3(0,1,0), 0.4, 0.2), 5.0));\nd = find_nearest(d, vec2(sdCappedCone(p, vec3(0, 1.75, 0), vec3(0,2.75,0), 0.2, 0.4), 5.0));\n\n    d = find_nearest(d, vec2(sdSphere(p - vec3(0, 1.4, 0), 0.2), 14.0));//6\n    \n    \n    return d;\n}\n\nvec2 gratemap(in vec3 p) {\n   vec2 d = vec2(1000, 0);\n\n    // first set of capsules\n    vec3 q = p;\n    q.xy *= rotation(45.);\n    q.y = mod(q.y + 0.18, 0.36) - 0.18; // repeat on Y axis every 0.36 units\n    d = find_nearest(d, vec2(sdCapsule(q, vec3(-2, 0, 0), vec3(2, 0, 0), 0.075), 10.0));\n    \n    // second set of capsules\n    q = p;\n    q.xy *= rotation(-45.); // perpendicular to the first set\n    q.y = mod(q.y + 0.18, 0.36) - 0.18; // repeat on Y axis every 0.36 units\n    d = find_nearest(d, vec2(sdCapsule(q, vec3(-2, 0, 0), vec3(2, 0, 0), 0.075), 10.0));\n\n    d = vec2(opIntersection(sdBox(p, vec3(1.9, 1.9, 1.5)), d.x), 10.0);\n\n    return d;\n}\n\n\n\n\n\n\n\n\n\n\nfloat fresnel(in vec3 I, in vec3 N, float eps) \n{ \n    float cosi = clamp( dot(I, N), -1.0, 1.0); \n    \n    float etai = 1.0;\n    float etat = eps; \n    float tmp;\n    if (cosi > 0.0) { tmp = etai; etai = etat; etat = etai; /*swap(etai, etat);*/ } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        return 1.0;\n    } \n    else { \n        float cost = sqrt(max(0.0, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return  (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\n\n//materials\nvec3 GetMatProps(in float matID, out float refl, out float refr, out float emmis, out float IOR) {//return material properties when what material is being hit is requested\n    \n    if(matID == 0.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.7, 0.1, 0.1);\n    }\n    if(matID == 1.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.1, 0.7, 0.1);\n    }\n    if(matID == 2.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.1, 0.1, 0.7);\n    }\n    if(matID == 3.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.52, 0.34, 0.14);\n    }\n    if(matID == 4.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.8, 0.5, 0.44);\n    }\n    if(matID == 5.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.35, 0.2, 0.09);\n    }\n        if(matID == 6.0) {\n     \trefl = 0.3;\n        refr = 0.0;\n        emmis = 30.0;\n        IOR = 1.0;\n        return vec3(0.3, 0.3, 0.6);\n    }\n            if(matID == 7.0) {\n     \trefl = 0.3;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.4, 0.4, 0.4);\n    }\n            if(matID == 8.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 75.0;\n        IOR = 1.0;\n        return vec3(0.89, 0.49, 0.1);\n    }\n    \n        if(matID == 9.0) {\n     \trefl = 0.4;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.52, 0.34, 0.14);\n    }\n\tif(matID == 10.0) {\n     \trefl = 0.7;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.1, 0.1, 0.2);\n    }\n    \tif(matID == 11.0) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        IOR = 1.5;\n        return vec3(0.1, 0.1, 0.9);\n    }\n    \n                if(matID == 12.0) {\n     \trefl = 0.8;\n        refr = 0.0;\n        emmis = 0.0;\n        IOR = 1.0;\n        return vec3(0.2, 0.2, 0.2);\n    }\n                    if(matID == 13.0) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        IOR = 1.333;\n        return vec3(1.2, 0.1, 1.2);\n    }\n                if(matID == 14.0) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 250.0;\n        IOR = 1.0;\n        return vec3(0.89, 0.49, 0.1);\n    }\nreturn vec3(1.0, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy * 10.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n\n    \n    position += (0.1 * target - position);\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (iMouse.zw - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Camera and Keyboard input by glk7, from https://www.shadertoy.com/view/4lVXRm\n\n\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 VMOUSE = ivec2(1, 1);\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nfloat ofst;\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector2(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 RandomUnitVector(inout uint state, in vec3 nor)\n{\n    float u = RandomFloat01(state);\n    float v = RandomFloat01(state) * c_twopi;\n   \n        // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n        float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n\n\nvec2 fireplacemap(in vec3 p) {\n     vec2 d = vec2(1000, 0);\n    d = find_nearest(d, vec2(sdBox(p - vec3(ofst), vec3(2, 0.5, 1.5)), 7.0));\n    d = find_nearest(d, vec2(sdBox(p - (vec3(0, 3.5, 0.25) + ofst) , vec3(2, 0.5, 1.25)), 7.0));\n    d = find_nearest(d, vec2(sdBox(p - (vec3(0, 6, 0) + ofst), vec3(1, 2, 1)), 7.0));\n    d = find_nearest(d, vec2(sdBox(p - (vec3(1.75, 1, 0.25) + ofst), vec3(0.25, 2, 1.25)), 7.0));\n    d = find_nearest(d, vec2(sdBox(p - (vec3(-1.75, 1, 0.25) + ofst), vec3(0.25, 2, 1.25)), 7.0));\n    d = find_nearest(d, vec2(sdBox(p - (vec3(0, 1, 1.25) + ofst), vec3(1.5, 2, 0.25)), 7.0));\n    \n    d = find_nearest(d, vec2(sdBox(p - vec3(0, 1, 0), vec3(1.25, 1, 0.25)), 8.0));\n    \n    \n    \n    return d;\n}\n\n\n\n\nvec2 map(in vec3 p, in float inside) {//Main map function, maps main objects\n    \n vec2 ret = vec2(1000, 0);\n//materials 0-20, opaques\n//materials 21-?, others(special properties such as reflectivity, emmisivity, and refractivity)\n    //ret = find_nearest(ret, vec2(sdBox(p - vec3(6, 0, 7), vec3(0.5, 2, 2)), 3.0));\n    ofst = smoothstep(-4.0, 4.0, texcube( iChannel3, p*0.1, vec3(1.0) ).z * 2.0 - 1.0) - 0.5;\n    //right wall\n    if(sdBox(p - vec3(6,0,7), vec3(0.35, 2.25, 2.25)) < ret.x) {\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(6, -1.75, 7), vec3(0.25, 0.25, 2)), 5.0));\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(6, 1.75, 7), vec3(0.25, 0.25, 2)), 5.0));\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(6, 0, 7), vec3(0.25, 0.25, 2)), 5.0));\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(6, 0, 8.75), vec3(0.25, 2, 0.25)), 5.0));\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(6, 0, 5.25), vec3(0.25, 2, 0.25)), 5.0));\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(6, 0, 7), vec3(0.25, 2, 0.25)), 5.0));\n    }\n    ret = find_nearest(ret, vec2(opSubtraction(sdBox(p - vec3(6, 0, 7), vec3(1.5, 2, 2)), opRepLim(p - vec3(6.0 + ofst, 0, 3), 1.25, vec3(0.0, 3.0, 0.0))), 3.0));\n    \n    //outside light\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(7, 0, 7), vec3(0.5, 2, 2)), 6));\n    \n    //left wall\n  \n     ret = find_nearest(ret, vec2(opRepLim(p - vec3(-6.0 + ofst, 0, 3), 1.25, vec3(0.0, 3.0, 0.0)), 3.0));\n  \n    //back wall\n    ret = find_nearest(ret, vec2(opSubtraction(sdBox(p - vec3(0, -2, 14), vec3(2, 2, 2)), opRepLimHoriz(p - vec3(0, 0, 14.0 + ofst), 1.25, vec3(0.0, 3.0, 0.0))), 3.0));\n    \n    \n    //front wall\n    ret = find_nearest(ret, vec2(opRepLimHoriz(p - vec3(0, 0, -2.0 + ofst), 1.25, vec3(0.0, 3.0, 0.0)), 3.0));\n    \n    \n    \n    //floor\n    ret = find_nearest(ret, vec2(sdBox(vec3(p.x, abs(p.y), p.z) - vec3(0, abs(-4.0 + ofst), 7), vec3(6, 0.25, 8)), 9.0));\n    \n    \n    //ceiling\n    //ret = find_nearest(ret, vec2(sdBox(p - vec3(0, 4.0 + ofst, 7), vec3(6, 0.25, 8)), 3.0));\n    \n    \n    \n    //table\n   if(sdBox(p - vec3(-2, -1.75, 7), vec3(1.25, 2.25, 1.25)) < ret.x) {\n    ret = find_nearest(ret, tablemap(p - vec3(-2,-3,7), vec3(1.0)));\n    }\n    \n    \n    \n    //ret = find_nearest(ret, vec2(opSubtraction(sdBox(p - vec3(6, 0, 7), vec3(0.7, 2, 2)), sdBox(p - vec3(6, 0, 8), vec3(0.5, 4, 6))), 3.0));\n    \n    ret = find_nearest(ret, vec2(sdCylinder(p - vec3(4,0,10), vec3(0, 0, 0.25)), 12.0));\n    ret = find_nearest(ret, vec2(sdBox(p - vec3(1, -3.25, 9), vec3(0.5,0.5,0.5)), 3.0));\n    \n    ret = find_nearest(ret, bulbmap(p - vec3(-1.5,1,13)));\n    \n    if(sdBox(p - vec3(0, 0, 14), vec3(2.5, 4, 2)) < ret.x) {\n    ret = find_nearest(ret, fireplacemap(p - vec3(0,-3.5,14)));\n    #ifdef grate\n        if(sdBox(p - vec3(0, -1.75, 13.25), vec3(2, 1.9, 0.5)) < ret.x) {\n    ret = find_nearest(ret, gratemap(p - vec3(0,-1.75,13.25)));\n    }\n    #endif\n    }\n\n    \n    //if(ret.x < 0.001) return ret;//transparent materials go below\n    \n\n    \n\n    \n    return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n    \n}\n\n\n\nvec3 calcNormal( in vec3 pos )//normals calculation\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy, 0.0).x - map( pos-eps.xyy, 0.0).x,\n      map( pos+eps.yxy, 0.0).x - map( pos-eps.yxy, 0.0).x,\n      map( pos+eps.yyx, 0.0).x - map( pos-eps.yyx, 0.0).x ) );\n}\n\n\n\nfloat intersect(in vec3 ro, in vec3 rd, in float inside) {//normal sphere tracing function\n    float res = -1.0;\n    float tmax = 25.0;\n    float t = 0.001;\n    for(int i = 0; i < 128; i++) {\n        float h = map(ro+rd*t, inside).x;\n        if((h<0.0001) || (t>tmax)) break;\n        t += h;\n    }\n    if(t<tmax) res = t;\n    \n    return res;\n    \n}\n\n\n\n\nvec3 calcFinalColor(vec3 ro, vec3 rd, inout uint rngState) {//main function\n    vec3 accumulatedColor = vec3(0.0);\n        vec3 colorMask = vec3(1.0);\n            float fdis = 0.0;\n\n        float emmis = 0.0;\n        float refl = 0.0;\n        float refr = 0.0;\n        float IOR = 1.0003;\n        float inside = 0.0;\n        float rand = RandomFloat01(rngState);\n    \n    for(int bounce = 0; bounce < BOUNCECOUNT; bounce++) {\n        float preIOR = IOR;\n        float t = intersect(ro, rd, 0.0);\n        vec3 iColor = vec3(0.0);\n               if( t < 0.0 )\n        {\n            \n            //fdis=16.0; \n            iColor +=  (2.0 * texture(iChannel0, rd).rgb) + 2.0 * accumulatedColor;//apply colors and emmisivity\n            colorMask *= texture(iChannel0, rd).rgb;\n            accumulatedColor += colorMask * iColor;\n            \n            break;\n        }\n\n        if(bounce == 0) fdis = t;\n        vec3 pos = ro + rd*t;\n        vec3 surfaceColor = GetMatProps(map(pos, 0.0).y, refl, refr, emmis, IOR);\n        vec3 norm = calcNormal(pos);\n        if(surfaceColor == vec3(0.52, 0.34, 0.14)) {\n        surfaceColor *= texcube( iChannel3, pos*0.5, norm ).xyz*1.2;\n        }\n        if(refr == 1.0) {//if material is refractive\n            float eps = IOR;\n            if(t < 0.001) {//theory: if ray is already inside an object, use first calculation, else use second calculation\n                norm = -norm;\n                inside = 1.0;//inside variable used for transparent objects, so I can define all objects in a single map() function\n            \n            }else {\n               eps = preIOR/eps;\n                inside = 0.0;\n            }\n            \n        rd = (fresnel(rd, norm, preIOR/eps) > rand) ? reflect(rd, norm) : refract(rd, norm, eps);//Fresnel function located in common\n\n            \n            \n        t = intersect(pos, rd, 1.0);\n        pos += rd*t;\n            \n            colorMask *= exp(-(surfaceColor*0.8) * t * t); //coloring based on distance ray travels through transparent object\n        \n        }else { //else if material not refractive\n                  colorMask *= surfaceColor;\n\n            //mix between reflective and diffuse ray directions\n            rd = mix( reflect(rd, norm), RandomUnitVector(rngState, norm), 1.0-refl);\n\n            \n            \n\n              }\n        ro = pos;\n        iColor +=  (emmis * surfaceColor) + 2.0 * accumulatedColor * dot(norm, rd);//apply colors and emmisivity\n        accumulatedColor += colorMask * iColor;\n       // accumulatedColor += norm;\n\n    }\n    \n\n    \n    float ff = exp(-0.001*fdis*fdis);\n    accumulatedColor *= ff; \n    accumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n\n\n    \n    return accumulatedColor;\n}\n\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) //Camera function to make flying camera\n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3(((fragCoord) - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    \n        vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    vec3 col = vec3(0.0);\n         Camera(fragCoord + jitter, ro, rd);\n         col = calcFinalColor( ro, rd, rngState);\n\n    \n    \n    \n        \n            vec4 lastFrameColor = texture( iChannel2, fragCoord/iResolution.xy );\n            float blend = (lastFrameColor.a == 0.0f || iMouse.z > 1.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n\n    \n    fragColor = vec4(col,blend);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Temporal sampling\n\nfloat grayscale(vec3 image) {\n    return dot(image, vec3(0.3, 0.59, 0.11));\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  lowp vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n  lowp vec3 imageacc = max( texture(iChannel1,uv).rgb , vec3(0.0));\n  lowp vec3 image = max( texture(iChannel0,uv).rgb , vec3(0.0));  \n\n    //declare stuff\n    const int mSize = 9;\n    const int kSize = (mSize-1)/2 ;\n    float kernel[mSize];\n    vec3 imageblurred = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 1.5;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            imageblurred += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }   \n    \n    imageblurred = imageblurred / (Z*Z);  \n    \n    image = min(image, imageblurred); // reduce fireflies    \n\n    if (iMouse.z < 0.5) \n    {\n        // attempt to reduce ghosting\n        lowp float weight = grayscale( pow( clamp( abs(imageacc - image) * 0.3 , 0., 1.), vec3(0.5)));\n        imageacc = mix(imageacc, image, clamp(weight + 0.1, 0., 1.));\n    } else { \n\n        imageacc = image;\n    }\n    \n    fragColor = vec4(imageacc,1.0);\n\n\t\n}","name":"Buffer C","description":"","type":"buffer"}]}