{"ver":"0.1","info":{"id":"XlXyz8","date":"1503283058","viewed":226,"name":"Super Simple Raymarcher","username":"Assossa","description":"Super simple raymarcher\n\nCamera ray code from https://www.shadertoy.com/view/XlBXWR","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","simple","raymarch","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxRender = 10.0; // Max distance to ray march\nconst float epsilon = 0.001; // Margin of error\nconst vec3 light = vec3(1.0, 1.0, -1.0); // Light position\n\n// Find distance between sphere and ray\nfloat sphereDistance(vec3 p, vec3 center, float radius) {\n    return distance(p, center) - radius;\n}\n\n// Find normal of sphere from hit location\nvec3 sphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\n// Get the hit location for a sphere and ray\nvec3 sphereHit(vec3 o, vec3 d, vec3 center, float radius) {\n    // Keep track of the distance we have traveled\n    float dist = 0.0;\n    \n    // Kill the marching if we go too far\n    while(dist <= maxRender) {\n        // Get distance to sphere\n        float tempDist = sphereDistance(o, center, radius);\n        \n        // Add it to our distance counter and update the ray origin\n        dist += tempDist;\n        o += d * tempDist;\n        \n        // If we hit a sphere, then return the hit\n        if(tempDist <= epsilon) return o;\n    }\n    \n    // We didn't hit anything\n    return vec3(maxRender);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Create ray for current pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 0.0, -3.0);\n    \n    // Find a hit\n    vec3 hit = sphereHit(origin, ray, vec3(0.0), 1.0);\n    \n    // If no hit, then use the sky color\n    if(hit == vec3(maxRender)) {\n        fragColor = vec4(0.3, 0.5, 0.7, 1.0);\n        return;\n    }\n    \n    // Find the normal of the sphere and the diffuse lighting from the normal\n    vec3 nml = sphereNormal(hit, vec3(0.0));\n    float diffuse = max(dot(nml, (light - hit)) + 0.75, 0.0) * 0.95;\n    \n    fragColor = vec4(vec3(diffuse), 1.0);\n}","name":"Image","description":"","type":"image"}]}