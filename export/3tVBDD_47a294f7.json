{"ver":"0.1","info":{"id":"3tVBDD","date":"1614382165","viewed":387,"name":"Fluid Vorticity Confinement","username":"niels747","description":"I successfully got any asymmetries out of it. Unfortunately it is a bit unstable and sometimes randomly glitches into chaos :(\nDoes not work on fullscreen!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","convection"],"hasliked":0,"parentid":"WtyfWW","parentname":"Fluid simple jets"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 fluid = texture(iChannel0,uv);\n    float curl = texture(iChannel1,uv)[0];\n    \n    vec2 normMouse = iMouse.xy / iResolution.xy;\n    \n    // temperature view\n    //fragColor = vec4(hsv2rgb(vec3(-fluid.w*0.31+0.3,1.0,1.0)),1.0); // hue\n    fragColor = vec4(1.0 + fluid.w, 1.0 - abs(fluid.w),1.0 - fluid.w, 1.0); // red and blue\n    \n    // presure view\n    //fragColor = vec4(1.0 + fluid.z*2., 1.0 - abs(fluid.z*2.),1.0 - fluid.z*2., 1.0); // red and blue\n    \n    // velocity view\n    //fragColor = vec4(1.0 + fluid.x*2., 1.0 - abs(fluid.x*2.),1.0 - fluid.x*2., 1.0); // horizontal\n    //fragColor = vec4(1.0 + fluid.y*2., 1.0 - abs(fluid.y*2.),1.0 - fluid.y*2., 1.0); // vertical\n    \n    // curl\n   // fragColor = vec4(1.0 + curl*4., 1.0 - abs(curl*4.),1.0 - curl*4., 1.0); \n    \n    #ifdef HIGH_VEL_INDICATOR\n    // Draw high velocity indicator\n    #define lowTresh 0.70\n    #define medTresh 0.85\n    #define highTresh 0.99\n    \n    if(abs(fluid.x) > highTresh || abs(fluid.y) > highTresh)\n       fragColor = vec4(1,0.5,0,1);\n       \n    else if(abs(fluid.x) > medTresh || abs(fluid.y) > medTresh)\n       fragColor = vec4(1,1,0,1);\n    \n    else if(abs(fluid.x) > lowTresh || abs(fluid.y) > lowTresh)\n       fragColor = vec4(0,1,0,1);     \n       \n    #endif\n\n\n #ifdef ISOBARS\n   // draw isobars for negative pressure\n   for(float p = -0.9; p < -0.03; p+=0.05){\n   if(abs(fluid.z - p) < 0.005){\n   fragColor = vec4(0,0,0,1);\n   break;\n }\n }\n \n #endif\n\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n\nx = horizontal velocity\ny = vertical velocity\nz = pressure\nw = temperature\n*/\n\n\n\nfloat powI(float x,int p) // p > 0\n{\nfloat result = x;\nfor(int i = 1; i<p; i++){\nresult *= x;\n}\nreturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iRes = ivec2(iResolution);\n    vec2 center = fragCoord / iResolution.xy;\n    vec2 XmY0  = (fragCoord + vec2(-1,0)) / iResolution.xy;\n    vec2 X0Ym  = (fragCoord + vec2(0,-1)) / iResolution.xy;\n    vec2 XpY0  = (fragCoord + vec2(1,0)) / iResolution.xy;\n    vec2 X0Yp  = (fragCoord + vec2(0,1)) / iResolution.xy;\n    \n    vec2 XmYp  = (fragCoord + vec2(-1,1)) / iResolution.xy;\n    vec2 XpYm  = (fragCoord + vec2(1,-1)) / iResolution.xy;\n    vec2 Xm2Y0  = (fragCoord + vec2(-2,0)) / iResolution.xy;\n    vec2 XmYm  = (fragCoord + vec2(-1,-1)) / iResolution.xy;\n    vec2 X0Ym2  = (fragCoord + vec2(0,-2)) / iResolution.xy;\n\n    \n    //vec2 norm = vec2(center.x / (iResolution.y/iResolution.x), center.y);\n    \n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    \n    vec4 t = texture(iChannel0, center);\n    \n    // velocity changes proportional to pressure gradient across point\n    t.x += t.z - texture(iChannel0,XpY0).z; \n    t.y += t.z - texture(iChannel0,X0Yp).z; \n    \n    \n       // apply vorticity\n    float curl =     texture(iChannel1, center)[0];\n    float curlXmY0 = texture(iChannel1, XmY0)[0];\n    float curlX0Ym = texture(iChannel1, X0Ym)[0];\n    float curlXpY0 = texture(iChannel1, XpY0)[0]; \n    float curlX0Yp = texture(iChannel1, X0Yp)[0];\n    \n    float curlXmYp = texture(iChannel1, XmYp)[0]; \n    float curlXpYm = texture(iChannel1, XpYm)[0];\n    float curlXm2Y0 = texture(iChannel1, Xm2Y0)[0]; \n    float curlXmYm = texture(iChannel1, XmYm)[0];\n    float curlX0Ym2 = texture(iChannel1, X0Ym2)[0]; \n    \n    // because of the the staggered grid arangement, the vorticity force needs to be calulated in multiple different \n    // positions and then averaged to get a symetrical force and prevent phantom forces\n    // the colors refer to a diagram I used to determine wich positions to use\n\n    // green\n    vec2 force = vec2(abs(curlX0Ym) - abs(curlX0Yp), abs(curlXpY0) - abs(curlXmY0));\n    float magnitude = length(force);\n\n    if(magnitude != 0.0){ // prevent divide by 0\n      force /= magnitude; // normalize vector\n      force *= curl;\n    }\n    //blue\n    vec2 forceL = vec2(abs(curlXmYm) - abs(curlXmYp), abs(curl) - abs(curlXm2Y0));\n    magnitude = length(forceL);\n\n    if(magnitude != 0.0){ // prevent divide by 0\n      forceL /= magnitude; // normalize vector\n      forceL *= curlXmY0;\n    }\n    \n    // red\n    vec2 forceD = vec2(abs(curlX0Ym2) - abs(curl), abs(curlXpYm) - abs(curlXmYm));\n    magnitude = length(forceD);\n\n    if(magnitude != 0.0){ // prevent divide by 0\n      forceD /= magnitude; // normalize vector\n      forceD *= curlX0Ym;\n    }\n   \n    if(abs(t.x) > 0.05 && abs(t.y) > 0.05)\n    \n    #ifdef CORRECTED_VORTICITY\n    t.xy += vec2((force.x+forceD.x)/2.,(force.y+forceL.y)/2.) * vortMult; // final corected vorticity confinement force\n    #else\n    t.xy += force * vortMult; // simple vorticity confinement force\n    #endif\n    // 1.5 9\n    t.x -= clamp(powI(t.x * 1.8 ,5)*0.00051, -0.1,0.1); // drag to prevent too high velocities\n    t.y -= clamp(powI(t.y * 1.8 ,5)*0.00051, -0.1,0.1); // simulation is only stable and accurate if x and y velocies < 1.0 (fragments/iteration)\n   \n   //t.x *= 0.999;\n   //t.y *= 0.999;\n   \n\n    // mouse adds heat\n    if(length(iMouse.xy - fragCoord) < 30.1 && iMouse.z > 0.5){\n        t.w += 0.1;\n    }\n    \n    \n    if(iTime> 3.0){\n    if(length(uv - vec2(-0.25,0.09)) < 0.02){\n     t.xy += vec2(0.010,0.000); // (0.010,-0.002);\n     t.w = -1.0;\n   }else if(length(uv - vec2(0.25,-0.09)) < 0.02){\n    t.xy += vec2(-0.010,0.000); //(-0.010,0.002);\n    t.w = 1.0; \n   }\n  }\n  /*\n  if(length(uv - vec2(-0.1,-0.13)) < 0.05 || uv.x < -0.49  || uv.y < -0.27){ // walls\n     t.xy = vec2(0); // just set velocity to 0\n     t.w = 0.;\n   }  \n   */\n   \n   // Sucktion hole\n   float suckVal = 0.020 * smoothstep(0.0, 10.0, iTime);\n    if(length(uv - vec2(0.0, 0.0)) < 0.015){\n    \n        t.w += suckVal;\n        t.z -= suckVal;\n    }\n  if(length(uv - vec2(0.4, 0.1)) < 0.015){\n        t.w -= suckVal;\n        t.z += suckVal;\n    }\n  \n  \n    t.w = clamp(t.w,-1.0,1.0); // constrain temperature\n    \n    fragColor = vec4(t.x ,t.y, t.z, t.w);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nx = horizontal velocity\ny = vertical velocity\nz = pressure\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iRes = ivec2(iResolution);\n    vec2 center = fragCoord / iResolution.xy;\n    vec2 left  = (fragCoord + vec2(-1,0)) / iResolution.xy;\n    vec2 down  = (fragCoord + vec2(0,-1)) / iResolution.xy;\n      \n   vec4 t = texture(iChannel0,center);\n   \n   // pressure changes proportional to the net inflow - outflow of the cell\n   t.z += (texture(iChannel0,left).x - t.x + texture(iChannel0,down).y - t.y) *0.499; // multiplier has to be < 0.5\n\n   fragColor = vec4(t.x, t.y, t.z, t.w);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 bilerp(sampler2D tex, vec2 uv)\n{\n    vec2 texSize = iChannelResolution[0].xy;\n\tvec2 pos = uv * texSize - 0.5;\n    vec2 f = fract(pos);\n    \n    vec2 pos_top_left = floor(pos);\n    \n    // we are sample center, so it's the same as point sample\n    vec4 tl = texture(tex, (pos_top_left + vec2(0.5, 0.5)) / texSize, -100.0);\n    vec4 tr = texture(tex, (pos_top_left + vec2(1.5, 0.5)) / texSize, -100.0);\n    vec4 bl = texture(tex, (pos_top_left + vec2(0.5, 1.5)) / texSize, -100.0);\n    vec4 br = texture(tex, (pos_top_left + vec2(1.5, 1.5)) / texSize, -100.0);\n    \n    vec4 ret = mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n    \n    return ret;\n}\n\n\n// Advection\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = fragCoord / iResolution.xy;\n    vec2 XmY0  = (fragCoord + vec2(-1,0)) / iResolution.xy;\n    vec2 X0Ym  = (fragCoord + vec2(0,-1)) / iResolution.xy;\n    vec2 XpY0  = (fragCoord + vec2(1,0)) / iResolution.xy;\n    vec2 X0Yp  = (fragCoord + vec2(0,1)) / iResolution.xy;\n    \n    vec2 XmYp  = (fragCoord + vec2(-1,1)) / iResolution.xy;\n    vec2 XpYm  = (fragCoord + vec2(1,-1)) / iResolution.xy;\n  \n    vec4 cellX0Y0 = texture(iChannel0, center);\n    vec4 cellXmY0 = texture(iChannel0, XmY0);\n    vec4 cellX0Ym = texture(iChannel0, X0Ym);\n    vec4 cellXpY0 = texture(iChannel0, XpY0); \n    vec4 cellX0Yp = texture(iChannel0, X0Yp);\n\n    vec4 cellXmYp = texture(iChannel0, XmYp); \n    vec4 cellXpYm = texture(iChannel0, XpYm);\n    \n    #ifdef CORRECTED_ADVECTION\n\n    vec2 velAtP = vec2((cellXmY0.x + cellX0Y0.x)/2.0, (cellX0Ym.y + cellX0Y0.y)/2.);\n    vec2 velAtVx = vec2(cellX0Y0.x, (cellX0Ym.y + cellXpY0.y + cellX0Y0.y + cellXpYm.y)/4.);\n    vec2 velAtVy = vec2((cellXmY0.x + cellX0Yp.x + cellXmYp.x + cellX0Y0.x)/4., cellX0Y0.y);\n\n    fragColor.zw = bilerp(iChannel0, center - velAtP / iResolution.xy).zw; // pressure and temperature \n    fragColor.x = bilerp(iChannel0, center - velAtVx / iResolution.xy).x; // Vx\n    fragColor.y = bilerp(iChannel0, center - velAtVy / iResolution.xy).y; // Vy\n    \n    #else  \n    \n    fragColor = bilerp(iChannel0, center - cellX0Y0.xy / iResolution.xy); // simple advection\n    \n   #endif\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = fragCoord / iResolution.xy;\n    vec2 right  = (fragCoord + vec2(1,0)) / iResolution.xy;\n    vec2 up     = (fragCoord + vec2(0,1)) / iResolution.xy;\n    \n    vec4 cell = texture(iChannel0, center);\n    \n    float curl = texture(iChannel0,up).x - cell.x - texture(iChannel0,right).y + cell.y;\n    \n    fragColor = vec4(curl, 0.0, 0.0, 0.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\nUntil now I have always been using simple advection and vorticity confinement calculations wich did not \nacount for the staggered grid arangement. This did work pretty well, but it caused some phantom forces wich\nbroke the conservation of momentum.\n\nHere is some info on the staggered grid model: http://nielsdaemen.nl/Projects/webgl/Model/\n*/\n\n#define CORRECTED_ADVECTION\n#define CORRECTED_VORTICITY\n\n#define vortMult 0.15 // unstable above 0.20\n\n#define HIGH_VEL_INDICATOR // color if velocity close to max\n\n#define ISOBARS // draw isobars\n","name":"Common","description":"","type":"common"}]}