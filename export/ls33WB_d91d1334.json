{"ver":"0.1","info":{"id":"ls33WB","date":"1451984503","viewed":1062,"name":"Mode 7 WASD Walkaround","username":"Hamneggs","description":"The standard mode 7 plane deformation, with positional state stored in a multipass buffer.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["deformation","plane","keyboard","state","mode7","multipass","wasd","walkaround"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/**\n\tI just wanted to get mildly aquainted with the multipass update.\n\t\n\tUpdate 1.01: Fixed AD movement. Sorry guys.\n\tUpdate 1.10: Data is now stored in two texels of buffer A. That's a lot\n\t\t\t\t more efficient use of storage, eh?\n\tUpdate 1.50: OH MAN OH MAN CAMERA IS NOW CLICK AND DRAG!\n\tUpdate 1.53: Look up and down kinda now.\n\tUpdate 1.61: Added bumpmapping and lighting.\n\tUpdate 1.70: Got true single texel data storage working. Data now occupies\n\t\t\t\t continuous region in the buffer.\n\tUpdate 1.72: Made buffer \"IO\" functions better.\n*/\n\n// What buffer the data is stored in.\n#define DATA_BUFFER iChannel0\n// The texture for the plane.\n#define TEXTURE iChannel1\n// The location of the position \"register\" in the data buffer.\nconst vec2 txPOS = vec2(1,0);\n// The location of the mouse position \"register\".\nconst vec2 txMOUSE = vec2(2,0);\n// The size of the buffer. Used for reading.\n#define BUFF_RES iChannelResolution[0].xy\n\n// Want to see what the data looks like? Look at (0,0),(3,0) in\n// the bottom left. Note, you won't be able to see negative position vals.\n// Also, there's a lot of zoom in this mode.\n//#define VIEWDATA\n\n/*\n\tReads a texel out of a buffer. Note, that that position is \n\tNOT normalized.\n*/\nvec4 readTexel(in sampler2D buffer, in vec2 pos )\n{\n    return texture(buffer, (pos+.5)/BUFF_RES);\n}\n\n/*\n\tSilly way to get a general brightness for a texel.\n*/\nfloat lum(in sampler2D t, in vec2 uv)\n{\n    return length(texture(t,uv));\n}\n\n/*\n\tRough surface normal given the texture texturing the surface.\n*/\nvec3 texNorm( in vec2 uv, in sampler2D t )\n{\n    //uv = gl_FragCoord.xy/iResolution.xy;\n    vec2 diff = vec2(0.0,0.001);\n    float diffY = lum(t,uv+diff.xy)-lum(t,uv-diff.xy);\n    float diffX = lum(t,uv+diff.yx)-lum(t,uv-diff.yx);\n    return normalize(vec3(10.0*diffX,1.0,10.0*diffY));\n}\n\n/*\n\tGouraud lighting, with bumpmapping!\n*/\nvec4 light(in vec4 tex, in vec3 s, in vec3 p, in vec3 d, in vec2 uv, in float fan)\n{\n    // Since we have two planes, we can just go ahead and estimate the norm.\n    vec3 n = vec3(0.0,-s.y,0.0);\n    n.xz = -texNorm(uv,TEXTURE).xz;\n    n = normalize(n);\n    //return texNorm(uv,TEXTURE).rgbb;\n    vec3 ld = -normalize(s-p);\n    return 1.5*tex*dot(n,ld)*smoothstep(1.0-fan-.1,1.0-fan,clamp(dot(-ld,d),0.0,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef VIEWDATA\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy/10.0);\n    return;\n    #endif\n    \n    // Get some good UV coordinates.\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Load the mouse position.\n    vec2 mouse = readTexel(DATA_BUFFER,txMOUSE).xy;\n    \n    // Get a rotation coefficient from the current mouse position.\n    float mx = 6.28*(mouse.x/iResolution.x);\n    float my = (mouse.y/iResolution.y);\n    \n    // Create rotation matrices.\n    float cmx = cos(iTime), smx = sin(iTime);\n    mat2 rotX = mat2(cmx,smx,-smx,cmx); // Column major.\n    float cmy = cos(my), smy = sin(my);\n    mat2 rotY = mat2(cmy,smy,-smy,cmy);\n    \n    // Go ahead and look up and down.\n    uv.y += my;\n    \n    // Plane deformation.\n    vec2 texUV = vec2(uv.x/abs(uv.y), (1.0/abs(uv.y)));\n    \n    // Rotate the deformed plane according to mouse position.\n    texUV *= rotX;\n    \n    // Get the current position from the render buffer.\n    vec2 pos = readTexel(DATA_BUFFER,txPOS).xy;\n    \n    // Translate the position.\n    texUV += pos;\n    \n    // Sample the texture with the deformed UV coordinates.\n    fragColor = texture(TEXTURE,texUV, -1.5);\n    \n    // Do lighting.\n    vec3 surface = vec3(texUV.x, sign(uv.y), texUV.y);\n    vec3 camPos = vec3(pos.x, 0.0, pos.y);\n    vec3 camDir = vec3(0.0,0.0,1.0);\n    camDir.xz *= rotX;\n    camDir.zy *= rotY;\n    fragColor = light(fragColor, surface, camPos, camDir, texUV, .2);\n    \n    \n    // Simple distance fog.\n    float dist = length(pos.xy-texUV.xy)/80.0;\n    fragColor = mix(fragColor, vec4(0.0), dist);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n\tThis buffer stores input and positional state.\n*/\n\n// Key codes.\nconst float KEY_W = 87.0/256.0;\nconst float KEY_A = 65.0/256.0;\nconst float KEY_S = 83.0/256.0;\nconst float KEY_D = 68.0/256.0;\n\n\n// Key data position.\nconst vec2 txKEYS = vec2(0,0);\n// Position data position.\nconst vec2 txPOS = vec2(1,0);\n// Mouse position data position\nconst vec2 txMOUSE = vec2(2,0);\nconst vec2 txMOUSEDX = vec2(3,0);\n\n// Current buffer size for loading data.\n#define BUFF_RES iChannelResolution[0].xy\n\n// Other constants.\n#define KEYS_BUFFER iChannel0\n#define KEYBOARD iChannel1\n#define KEY_DOWN_POS 0.0\n#define MOVE_SPEED .125\n\n// Reads a texel. We don't really need component-wise read functions.\nvec4 readTexel(in sampler2D buffer, in vec2 pos )\n{\n    return texture(buffer, (pos+.5)/BUFF_RES);\n}\n\n// Writes a single component of a pixel in a buffer.\nvoid write1( inout float buffer, in float val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes two components of a pixel in a buffer.\nvoid write2( inout vec2 buffer, in vec2 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes three of the components.\nvoid write3( inout vec3 buffer, in vec3 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// Writes all components of a texel (at once).\nvoid write4( inout vec4 buffer, in vec4 val, in vec2 pos, in vec2 fragCoord)\n{\n    vec2 offset = abs(pos-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n// The keypress handler.\nvoid handleKeys( inout vec4 buffer, in vec2 fragCoord )\n{\n    // Load keypress data from the buffer.\n    vec4 priorKeys = readTexel(KEYS_BUFFER, txKEYS);\n    \n    // If a key is down, update the position accordingly.\n    vec4 keys;\n    keys.r = texture(KEYBOARD,vec2(KEY_W, KEY_DOWN_POS)).r;\n    keys.g = texture(KEYBOARD,vec2(KEY_S, KEY_DOWN_POS)).r;\n    keys.b = texture(KEYBOARD,vec2(KEY_A, KEY_DOWN_POS)).r;\n    keys.a = texture(KEYBOARD,vec2(KEY_D, KEY_DOWN_POS)).r;\n    \n    // Store the keys value. That mix eases between full up and\n    // full down states, so that the velocity of the camera\n    // isn't as jarring.\n    write4(buffer,mix(priorKeys,keys,.25),txKEYS,fragCoord);\n}\n\n// The position update handler.\nvoid handlePosition(inout vec4 buffer, in vec2 fragCoord )\n{\n    // Get the prior position value.\n    vec2 priorPos = readTexel(KEYS_BUFFER, txPOS).xy;\n    vec2 mouse = readTexel(KEYS_BUFFER, txMOUSE).xy;\n    \n    // Get some good UV coordinates.\n    vec2 uv = fragCoord / iChannelResolution[0].xy - 0.5;\n\tuv.x *= BUFF_RES.x/BUFF_RES.y; //fix aspect ratio\n    \n    // Get the x mouse coordinate, multiplied by the parametric interval.\n    float mx = 6.28*(mouse.x/BUFF_RES.x);\n    \n    // Get the same rotation that is applied to the deformed plane\n    // in the final image shader.\n    float cmx = cos(mx), smx = sin(mx);\n    vec2 dir = vec2(0.0,1.0)*mat2(cmx,smx,-smx,cmx); // Column major.\n    \n    // Get the strafing direction.\n    vec2 str = dir*mat2(0.0,1.0,-1.0,0.0);\n    \n    // Get the key press value from the key press buffer.\n    vec4 keys = readTexel(KEYS_BUFFER, txKEYS);\n    \n    // If a key is down, update the position accordingly.\n    priorPos += keys.r * dir *  MOVE_SPEED;\n    priorPos += keys.g * dir * -MOVE_SPEED;\n    priorPos += keys.b * str * -MOVE_SPEED;\n    priorPos += keys.a * str *  MOVE_SPEED;\n    \n    // Store our new position value.\n    write2(buffer.rg,priorPos,txPOS,fragCoord);\n}\n\n// Do you want click and drag mouse? Yes. The \"current\" mouse\n// Position is stored in the data buffer, and the value is updated\n// per frame, by the amount the mouse has moved that frame.\n// This is done by comparing how far the mouse has moved from\n// where it was clicked frame on frame, with the difference from\n// the prior frame also stored in the buffer.\nvoid handleMouse( inout vec4 buffer, in vec2 fragCoord )\n{\n    // Load prior mouse position.\n    vec2 pMouse = readTexel(KEYS_BUFFER,txMOUSE).xy;\n    // Load last frame's difference between where the mouse is,\n    // and where the mouse was most recently clicked.\n    vec2 pMouseDX = readTexel(KEYS_BUFFER,txMOUSEDX).xy;\n    \n    // Get the current mouse position.\n    vec4 curMouse = iMouse;\n    \n    vec2 cMouseDX;\n    if(curMouse.z > 0.0 && curMouse.w > 0.0) // LMB down.\n    {\n        // current difference between click and cur.\n        cMouseDX = curMouse.xy-curMouse.zw;\n        pMouse += (cMouseDX-pMouseDX)*.5;\n        \n        // We don't want to look up or down too far, so...\n        pMouse.y = clamp(pMouse.y,-iResolution.y,iResolution.y);\n    }\n    // And store it.\n    write2(buffer.xy,pMouse,txMOUSE,fragCoord);\n    write2(buffer.xy,cMouseDX,txMOUSEDX,fragCoord);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Load the buffer at this fragment's position.\n    vec4 buff = texture(KEYS_BUFFER,fragCoord/BUFF_RES);\n    \n    // Call the key handler.\n    handleKeys(buff,fragCoord);\n    // Call the position update handler.\n    handlePosition(buff,fragCoord);\n    // Call the mouse handler.\n    handleMouse(buff,fragCoord);\n    \n    // Write out this fragment position's result.\n    fragColor = buff;\n}","name":"Buffer A","description":"","type":"buffer"}]}