{"ver":"0.1","info":{"id":"dlSXDc","date":"1676690221","viewed":237,"name":"2D low discrepancy sequence R2","username":"clauswilke","description":"2d low discrepancy sequence R2, as described at: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["2d","noise","lowdiscrepancy","r2curve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D Low Discrepancy Sequence\n// Claus O. Wilke, Feb. 2023\n// Licensed CC0, https://creativecommons.org/share-your-work/public-domain/cc0/\n\n// This shader implements the R2 curve described here:\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n\n// Plastic constant, https://en.wikipedia.org/wiki/Plastic_number\nconst float phi2 = pow((9. + sqrt(69.)) / 18., 1./3.) + pow((9. - sqrt(69.)) / 18., 1./3.); \n\n// Calculate R2 for index i\nvec2 getR2(float i) {\n    // We're using 1 - 1/phi instead of 1/phi for higher precision,\n    // as explained here: https://www.shadertoy.com/view/mts3zN\n    const float C1 = 1. - 1. / phi2;\n    const float C2 = 1. - 1. / (phi2 * phi2);\n\n    return vec2(fract(i * C1), fract(i * C2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    // number of dots to show\n    float N = mod(100.*iTime + 500., 1000.);\n    \n    vec3 col = vec3(0);\n    for (float i = 0.; i<N; i++) {\n        vec2 uv0 = 2. * getR2(i) - 1.;\n        float d = length(uv0 - uv);\n        if (d < 0.01) {\n            col +=  smoothstep(0.009, 0.008, d) * vec3(.6, .8, 1.);        \n        }\n    }\n       \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}