{"ver":"0.1","info":{"id":"4ltXW4","date":"1479607566","viewed":219,"name":"imperfect voxels","username":"SudoNhim","description":"Combining voxels and distance functions to make rough shaped voxels.\n\n1st pass: voxel march a fixed number of steps storing the first four voxels hit\n2nd pass: distance march each of the hit voxels to intersect","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// utility functions\nvec3 rot_axis_angle(vec3 v, vec3 axis, float angle);\nfloat snoise(const in vec3 x);\nfloat hash(float x);\n\n// current ray\nvec3 ro;\nvec3 rd;\n\n// voxel marcher\n#define MAX_VOXEL_HITS 4\n#define VOXEL_MARCH_STEPS 36\nivec3 hitVoxels[MAX_VOXEL_HITS];\nint hitIndex = 0;\nvoid voxelMarch();\n\n// terrain type of hit voxel\nint terrainType;\n\n// map\n#define NONE 0\n#define WATER 1\n#define STONE 2\nint getTerrain(ivec3 mapPos) {\n  float l = length(vec3(mapPos));\n  float rand = ( \n    0.367 * hash(float(mapPos.x) + 127.71) + \n    0.367 * hash(float(mapPos.y) + 432.22) + \n    0.367 * hash(float(mapPos.z) + 322.11)\n    );\n  if (l*rand > 4.0) return STONE;\n  \n  if (mapPos.y < 0) return WATER;\n  \n  return NONE;\n}\n\n\nfloat dfVoxel(vec3 p, vec3 globalP) {\n  if (terrainType == WATER) {\n    float surfDist = p.y - 0.5;\n    return surfDist;\n  } \n  else if (terrainType == STONE) {\n    float radius = 0.01;\n    vec3 sides = vec3(0.475, 0.475, 0.475);\n    float cubeDist = length(max(abs(p)-(sides-radius), 0.0))-radius;\n    float distortion = -0.03 + 0.03*snoise(p*3.0+floor(globalP));\n    float detail = min(0.0, 0.004*snoise(p*15.0+floor(-globalP)));\n    return cubeDist + distortion + detail;\n  }\n  return 0.0;\n}\n\nvec3 nrmVoxel(vec3 p, vec3 globalP) {\n  vec2 dd = vec2(0.001,0.0);\n  float base = dfVoxel(p, globalP);\n  return normalize(vec3(\n    dfVoxel(p+dd.xyy, globalP) - base,\n    dfVoxel(p+dd.yxy, globalP) - base,\n    dfVoxel(p+dd.yyx, globalP) - base\n    ));\n}\n\nvec3 hitPos;\nvec3 hitVoxelCenter;\nvec3 hitNormal;\n#define SDMARCH_STEPS 8\nvoid resolveHitVoxels() { \n  for (int i=0; i<MAX_VOXEL_HITS; i++) {\n    if (i == hitIndex) break;\n    \n    terrainType = getTerrain(hitVoxels[i]);\n    hitVoxelCenter = vec3(hitVoxels[i]) + 0.5;\n    \n    // intersect with voxel cube\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float d = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    hitPos = ro + rd * d;\n    \n    // attempt better intersect with distance marching\n    float diff;\n    vec3 p =hitPos;\n    for (int j=0; j<SDMARCH_STEPS; j++) {\n      diff = dfVoxel(p - hitVoxelCenter, hitVoxelCenter);\n      d += diff;\n      p = ro + rd * d;\n    }\n    if (diff < 0.03) { // good enough distance marched intersection\n      hitPos = p;\n      break;\n    }\n  }\n  \n  hitNormal = nrmVoxel(hitPos - hitVoxelCenter, hitVoxelCenter);\n}\n\nvec3 GetColor()\n{\n  vec3 color = vec3(0.0);\n  if (terrainType == WATER)\n    color = vec3(0.1, 0.1, 0.2) + 0.1*snoise(hitVoxelCenter);\n  if (terrainType == STONE)\n    color = vec3(0.1) + vec3(0.5, 0.3, 0.1) * abs(snoise(hitVoxelCenter));\n  vec3 ldir = normalize(hitPos);\n  float diffuse = dot(-ldir, hitNormal);\n  float ambient = 1.0 - length(hitPos) / 16.0;\n  color *= diffuse + ambient;\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  ro = vec3(0.0, 2.0, 0.0);\n  rd = vec3(((uv-0.5)*vec2(iResolution.x/iResolution.y, 1.0)), 1.0);\n  rd = rot_axis_angle(rd, vec3(1.0, 0.0, 0.0), sin(iTime/9.0)/4.0+0.3+(-iMouse.y/iResolution.y)*3.0);\n  rd = rot_axis_angle(rd, vec3(0.0, 1.0, 0.0), sin(iTime/7.0)/2.0+(iMouse.x/iResolution.x-0.5)*5.0);\n  \n  voxelMarch();\n  resolveHitVoxels();\n  \n  vec3 color = vec3(0.0);\n  if (hitIndex > 0)\n    color = GetColor();\n    \n  fragColor = vec4(color, 1.0);\n}\n\n\n//###################################################################\n// Voxel marcher\n\nvoid voxelMarch() {\n  ivec3 mapPos = ivec3(floor(ro));\n  vec3 deltaDist = abs(vec3(length(rd)) / rd);\n  ivec3 rayStep = ivec3(sign(rd));\n  vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n  bvec3 mask;\n\t\n  for (int i = 0; i < VOXEL_MARCH_STEPS; i++) {\n    if (getTerrain(mapPos) != NONE) {\n      if (hitIndex == 0) // no non-const indexing? :<\n          hitVoxels[0] = mapPos;\n      else if (hitIndex == 1)\n          hitVoxels[1] = mapPos;\n      else if (hitIndex == 2)\n          hitVoxels[2] = mapPos;\n      else if (hitIndex == 3)\n          hitVoxels[3] = mapPos;\n      hitIndex++;\n      if (hitIndex == MAX_VOXEL_HITS) return;\n    }\n\n    // Branchless DDA not working in webgl? :L\n    //mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n    //sideDist += vec3(mask) * deltaDist;\n    //mapPos += ivec3(mask) * rayStep;\n      \n    if (sideDist.x < sideDist.y) {\n        if (sideDist.x < sideDist.z) {\n            sideDist.x += deltaDist.x;\n              mapPos.x += rayStep.x;\n            mask = bvec3(true, false, false);\n        }\n        else {\n            sideDist.z += deltaDist.z;\n            mapPos.z += rayStep.z;\n            mask = bvec3(false, false, true);\n        }\n    }\n    else {\n        if (sideDist.y < sideDist.z) {\n            sideDist.y += deltaDist.y;\n            mapPos.y += rayStep.y;\n            mask = bvec3(false, true, false);\n        }\n        else {\n            sideDist.z += deltaDist.z;\n            mapPos.z += rayStep.z;\n            mask = bvec3(false, false, true);\n          }\n      }\n  }\n}\n\n\n//###################################################################\n// Utils\n\nvec3 rot_axis_angle(vec3 v, vec3 axis, float angle) {\n  return v*cos(angle) +\n         cross(axis, v)*sin(angle) +\n         axis*dot(axis, v)*(1.0-cos(angle));\n}\n\nfloat hash(float x) {\n  return fract(423.623*sin(773.67*x + 1.93));\n}\n\n// Description : Array and textureless GLSL 3D simplex noise function\n// http://www.gamedev.net/topic/502913-fast-computed-noise/\n\nvec4 randomizer4(const vec4 x)\n{\n    vec4 z = mod(x, vec4(5612.0));\n    z = mod(z, vec4(3.1415927 * 2.0));\n    return(fract(cos(z) * vec4(56812.5453)));\n}\n\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\n\nfloat snoise(const in vec3 xx)\n{\n    vec3 x = mod(xx + 32768.0, 65536.0);\n    vec3 ix = floor(x);\n    vec3 fx = fract(x);\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n\n    vec4 N1 = nn + A3;\n    vec4 N2 = nn + A4;\n    vec4 R1 = randomizer4(N1);\n    vec4 R2 = randomizer4(N2);\n    vec4 R = mix(R1, R2, wx.x);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n\n    return 1.0 - 2.0 * re;\n}\n","name":"Image","description":"","type":"image"}]}