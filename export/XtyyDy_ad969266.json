{"ver":"0.1","info":{"id":"XtyyDy","date":"1537439793","viewed":753,"name":"ray tracing in one weekend","username":"mastersun","description":"ray tracing in one weekend","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI \t\t\t3.141592653589793\n#define DIFFUSE 1\n#define METAL 2\n#define GLASS 3\nprecision highp float;\n\nstruct Material {\n    int materialType;\n    vec3 albedo;\n    float fuzz;\n    float ref_idx;\n};\n\nstruct hitRec {\n    vec3 p;\n    float t;\n    vec3 normal;\n    Material material;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    Material material;\n};\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec2 randState;\n\nfloat hash( const float n ) \n{\n    return fract(sin(n)*43758.54554213);\n}\n\n\nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);;\n\n        return randState.x;\n}\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\n\n// random direction in unit sphere (for lambert brdf)\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nbool intersect(Ray ray, Sphere s, float t_min, float t_max, out hitRec rec) {\n\n    vec3 origin = ray.origin;\n    vec3 direction = ray.direction;\n    vec3 center = s.center;\n    vec3 oc = origin - center;\n    float a = dot(direction, direction);\n    float b = dot(direction, oc);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float discriminant = b * b - a * c;\n\n    bool isHit = false;\n    // 没有解返回-1\n    if (discriminant > 0.0) {\n\n        float temp = (-b - sqrt(discriminant)) / a;\n        if (temp > t_min && temp < t_max) {\n            isHit = true;\n            rec.t = temp;\n            rec.p = ray.origin + temp * ray.direction;\n            rec.normal = normalize(rec.p - s.center);\n            rec.material = s.material;\n            return isHit;\n        }\n\n        temp = (-b + sqrt(discriminant)) / a;\n        if (temp > t_min && temp < t_max) {\n            isHit = true;          \n            rec.t = temp;\n            rec.p = ray.origin + temp * ray.direction;\n            rec.normal = normalize(rec.p - s.center);\n            rec.material = s.material;\n            return isHit;\n        }\n    }      \n\n    return isHit;\n}\n\n\nSphere[] spheres = Sphere[13](\n    Sphere(vec3(-1.7767739124623123, 0.2, -1.2816898536829258), 0.2, Material(METAL, vec3(0.8583803237598104, 0.20326924410262914, 0.6395126962804198), 0.0, 1.0)),\n    Sphere(vec3(-1.7305723691670227, 0.2, 0.3951602921593084), 0.2, Material(METAL, vec3(0.31312642687469494, 0.7515889461590635, 0.28340848312832545), 0.0, 1.0)),\n    Sphere(vec3(-0.27591460582523974, 0.2, -1.8354952437012457), 0.2, Material(METAL, vec3(0.6198719656801521, 0.556026705514626, 0.648322615823812), 0.0, 1.0)),\n    Sphere(vec3(-0.9494116695035437, 0.2, 1.1626594958242502), 0.2, Material(DIFFUSE, vec3(0.5537532126201208, 0.5414521567205806, 0.7067976503378637), 0.0, 1.0)),\n    Sphere(vec3(0.34406388813179173, 0.2, -1.3459160365634482), 0.2, Material(METAL, vec3(0.6672582591732812, 0.5969480095581641, 0.06122936189796979), 0.0, 1.0)),\n    Sphere(vec3(0.8645388174599531, 0.2, -0.6721135055961149), 0.2, Material(DIFFUSE, vec3(0.8325486386586358, 0.6111814610006208, 0.062379505844914585), 0.0, 1.0)),\n    Sphere(vec3(0.26709016789165435, 0.2, 0.8643855722533954), 0.2, Material(METAL, vec3(0.9525838044784114, 0.055228586680290626, 0.9361120234051548), 0.0, 1.0)),\n    Sphere(vec3(1.248775787035965, 0.2, -1.2530472200991882), 0.2, Material(METAL, vec3(0.5406328826474636, 0.7101046078344466, 0.2631417124753519), 0.0, 1.0)),\n    Sphere(vec3(1.0832295826801093, 0.2, -0.8585841079725383), 0.2, Material(METAL, vec3(0.18963476844985272, 0.15177197074252846, 0.4885690417252797), 0.0, 1.0)),\n    Sphere(vec3(1.2052948984262064, 0.2, 0.7685004648640211), 0.2, Material(METAL, vec3(0.2841868868425741, 0.8423035464421846, 0.6406487327665245), 0.0, 1.0)),\n    Sphere(vec3(-4.0, 1.0, 0.8), 1.0, Material(DIFFUSE, vec3(0.4, 0.2, 0.1), 0.0, 1.0)),\n    Sphere(vec3(0.0, 1.0, 0.0), 1.0, Material(METAL, vec3(1.0, 1.0, 1.0), 0.0, 1.0)),\n    Sphere(vec3(0.0, -1000.0, 0.0), 1000.0, Material(DIFFUSE, vec3(0.5, 0.5, 0.5), 0.0, 1.0))\n);  \n\nbool intersectWorld(Ray ray, float t_min, float t_max, out hitRec rec) {\n    bool isHit = false;\n\n    for (int i = 0; i < spheres.length(); i++) {\n        bool isCurrHit = false;\n        hitRec currRec;\n        isCurrHit = intersect(ray, spheres[i], t_min, t_max, currRec);\n        if (isCurrHit) {\n            isHit = true;\n            t_max = currRec.t;\n            rec = currRec;\n        }\n    }\n\n    return isHit;\n}\n\n\nbool scatter(inout Ray ray, hitRec rec) {\n    int materialType = rec.material.materialType;\n    if (materialType == METAL) {\n        vec3 reflected = reflect(ray.direction, rec.normal);\n        float fuzz = rec.material.fuzz > 1.0 ? 1.0 : rec.material.fuzz < 0.0 ? 0.0 : rec.material.fuzz;\n        if (fuzz > 0.0) {\n            ray = Ray(rec.p, normalize(reflected) + fuzz * random_in_unit_sphere());\n        } else {\n            ray = Ray(rec.p, reflected);\n        }\n        return (dot(ray.direction, rec.normal) > 0.0);\n    } else if (materialType == GLASS) {\n\n        vec3 outward_normal;\n        vec3 reflected = reflect(ray.direction, rec.normal);\n        float ni_over_nt;\n        float reflected_prob;\n        float cosine;\n        float ref_idx = rec.material.ref_idx;\n\n        if (dot(ray.direction, rec.normal) > 0.0) {\n            outward_normal = - rec.normal;\n            ni_over_nt = rec.material.ref_idx;\n            cosine = ref_idx * dot(normalize(ray.direction), rec.normal);\n        } else {\n            outward_normal = rec.normal;\n            ni_over_nt = 1.0 / rec.material.ref_idx;\n            cosine = -ref_idx * dot(normalize(ray.direction), rec.normal);\n        }\n\n        vec3 refracted = refract(normalize(ray.direction), outward_normal, ni_over_nt);\n\n        if (refracted.x != 0.0 && refracted.y != 0.0 && refracted.z != 0.0) {\n            reflected_prob = schlick(cosine, ref_idx);\n            // ray = Ray(rec.p, refracted);\n        } else {\n            reflected_prob  = 1.0;\n            // ray = Ray(rec.p, reflected);\n        }\n\n        if (rand2D() < reflected_prob) {\n            ray = Ray(rec.p, reflected);          \n        } else {\n            ray = Ray(rec.p, refracted);\n        }\n\n        return true;\n\n    } else {\n        ray = Ray(rec.p, rec.normal + random_in_unit_sphere());\n        return true;\n    }\n}\n\n#define MAX_DEPTH 50\n\nvec3 paint(Ray ray, float t_min, float t_max) {\n    hitRec rec;\n\n    int hitCounts = 0;\n    bool isHit = intersectWorld(ray, t_min, t_max, rec);\n    vec3 scale = vec3(1.0, 1.0, 1.0);\n\n    while(isHit && hitCounts < MAX_DEPTH) {\n        hitCounts++;\n        bool isScatter = scatter(ray, rec);\n\n        if (!isScatter) return vec3(0.0, 0.0, 0.0);\n\n        scale *= rec.material.albedo;\n        isHit = intersectWorld(ray, t_min, t_max, rec);   \n    }\n\n    float t = (normalize(ray.direction).y + 1.0) * 0.5;\n    vec3 color = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);\n\n    return scale * color;\n}\n\nstruct Camera {\n    vec3 center;\n    vec3 lower_left;\n    vec3 hori;\n    vec3 vert;\n};\n\n    Camera getCamera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect) {\n        vec3 u, v, w;\n        Camera camera;\n        float theta = vfov * PI / 180.0;\n        float half_height = tan(theta / 2.0);\n        float half_width = aspect * half_height;\n        camera.center = lookfrom;\n        w = normalize(lookfrom - lookat);\n        u = normalize(cross(vup, w));\n        v = cross(w, u);\n        camera.lower_left = camera.center - half_width * u - half_height * v - w;\n        camera.hori = 2.0 * half_width * u;\n        camera.vert = 2.0 * half_height * v;\n        return camera;\n    }\n\nRay getRay(Camera camera, float u, float v) {\n    return Ray(camera.center, camera.lower_left + u * camera.hori + v * camera.vert - camera.center);\n}\n\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord )\n{\n    if (ivec2(frag_coord) == ivec2(0)) {\n        frag_color = iResolution.xyxy;\n        return;\n    }\n    float ratio = iResolution.x / iResolution.y;\n    // float speed = 10.0;\n    // float angle = speed * iTime * PI / 180.0;\n\n    Camera camera = getCamera(vec3(1.22, 1.8, 4.0), vec3(-2.0, 1.0, -3.0), vec3(0.0, 1.0, 0.0), 90.0, ratio);\n    // Camera camera = getCamera(vec3(7.75*cos(angle) - 2.0, 1.8, 7.75*sin(angle) - 3.0), vec3(-2.0, 1.0, -3.0), vec3(0.0, 1.0, 0.0), 90.0, ratio);\n    \n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    randState = frag_coord.xy / iResolution.xy;\n    \n    float u = float(frag_coord.x + rand2D()) / float(iResolution.x);\n    float v = float(frag_coord.y + rand2D()) / float(iResolution.y);\n\n    Ray ray = getRay(camera, u, v);\n\n    color = paint(ray, 0.01, 1000.0);\n\n    if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \n        frag_color = vec4(color,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\n    } else {        \n        frag_color = vec4(color,1);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}]}