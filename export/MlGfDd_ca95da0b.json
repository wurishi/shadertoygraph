{"ver":"0.1","info":{"id":"MlGfDd","date":"1544508090","viewed":201,"name":"Light My Fire","username":"daumkuchen","description":"fire effect using distance function & noise.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["effect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\nconst float angle = 60.;\nconst float fov = angle * .5 / PI / 180.;\nconst vec3 lightDir = normalize(vec3(-.5, .5, .5));\nconst vec3 ambient = vec3(-.5, .5, .5);\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,\n                        0.309016994374947451);\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n  i = mod(i, 289.0);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat random (in vec2 _uv){\n  return fract(sin(dot(_uv.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n  vec3 a = floor(p);\n  vec3 d = p - a;\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n  vec4 k1 = perm(b.xyxy);\n  vec4 k2 = perm(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\n  vec4 k3 = perm(c);\n  vec4 k4 = perm(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n#define NUM_OCTAVES 5\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\nfloat sdSphere(vec3 p, float s){\n  return length(p) - s;\n}\n\nvec2 distanceFunc(vec3 p){\n  float t = iTime * .2;\n  float n = fbm(normalize(p) + t) * 6.;\n        n = snoise(vec4(vec3(n) * .2, .1));\n  vec3 r = rotate(p, radians(iTime * 20.), vec3(1.));\n  float s = sdSphere(r, 1. + n * .5);\n\n  return vec2(s);\n}\n\nvec3 getNormal(vec3 p){\n  vec3 d = vec3(.2, 0., 0.);\n  return normalize(vec3(\n    distanceFunc(p + d.xyy).x - distanceFunc(p - d.xyy).x,\n    distanceFunc(p + d.yxy).x - distanceFunc(p - d.yxy).x,\n    distanceFunc(p + d.yyx).x - distanceFunc(p - d.yyx).x\n  ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n  vec3 lightDir = normalize(vec3(sin(iTime * 20.), cos(iTime * 20.), 1.));\n\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n  // vec2 tUv = fragCoord.xy / iResolution;\n\n  vec3 ray = normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov)));\n\n  vec2 d = vec2(0.);\n  vec2 rLen = vec2(0.);\n\n  vec3 cPos = vec3(.0, .0, 1.);\n  vec3 rPos = cPos;\n\n  for(int i = 0; i < 12; i++){\n    d = distanceFunc(rPos);\n    rLen += d;\n    rPos = cPos + ray * vec3(rLen, 1.);\n  }\n\n  vec3 normal = getNormal(rPos);\n\n  float diffuse = max(dot(lightDir, normal), 0.);\n  float specular = max(dot(normal, lightDir), 0.);\n        specular = pow(specular, 2.);\n  vec3 ambientColor = min(ambient + diffuse, 1.);\n\n  float dot = dot(vec3(.0), normal);\n  float value = cos(dot * PI * 16.);\n\n  float r1 = random(vec2(iTime));\n  vec3 fCol = vec3(.7);\n  vec3 nCol1 = vec3(normal.z * 1., normal.z * 10., normal.z * (4. - sin(iTime * .5)));\n  vec3 nCol2 = vec3(normal.z * 2., normal.z * 1., normal.z * (2. - sin(iTime * .5))) * (cos(iTime * .7) + 1.);\n  vec3 col = nCol1 * nCol2 * fCol;\n\n  col *= smoothstep(.01, .1, value);\n  col = abs(col - .01) * 6.;\n  col = col + (random(normal.yz) * .1);\n\n  vec3 dest = (.8 - col + vec3(specular * .4)) * 1.5;\n\n  fragColor = vec4(dest, 1.);\n\n}\n","name":"Image","description":"","type":"image"}]}