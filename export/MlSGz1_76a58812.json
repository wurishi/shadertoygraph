{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n\n// ------------------------------------------------------- SH, yes 'orangebook' -----------------------------------------------------------------------------\n\nstruct SHC\n{\n    vec3 L00, L1m1, L10, L11, L2m2, L2m1, L20, L21, L22;\n};\n\nSHC beach = SHC(\n                vec3( 0.6841148,  0.6929004,  0.7069543),\n                vec3( 0.3173355,  0.3694407,  0.4406839),\n                vec3(-0.1747193, -0.1737154, -0.1657420),\n                vec3(-0.4496467, -0.4155184, -0.3416573),\n                vec3(-0.1690202, -0.1703022, -0.1525870),\n                vec3(-0.0837808, -0.0940454, -0.1027518),\n                vec3(-0.0319670, -0.0214051, -0.0147691),\n                vec3( 0.1641816,  0.1377558,  0.1010403),\n                vec3( 0.3697189,  0.3097930,  0.2029923)\n                );\n\nvec3 sh_light(vec3 normal, SHC l)\n{\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n    \n    const float C1 = 0.429043;\n    const float C2 = 0.511664;\n    const float C3 = 0.743125;\n    const float C4 = 0.886227;\n    const float C5 = 0.247708;\n    \n    return (\n            C1 * l.L22 * (x * x - y * y) +\n            C3 * l.L20 * z * z +\n            C4 * l.L00 -\n            C5 * l.L20 +\n            2.0 * C1 * l.L2m2 * x * y +\n            2.0 * C1 * l.L21  * x * z +\n            2.0 * C1 * l.L2m1 * y * z +\n            2.0 * C2 * l.L11  * x +\n            2.0 * C2 * l.L1m1 * y +\n            2.0 * C2 * l.L10  * z\n            );\n}\n// noise (iq)\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 hash3( vec3 p )\n{\n    vec3 q = vec3( dot(p,vec3(127.1,311.7, 567.324)), \n\t\t\t\t   dot(p,vec3(269.5,183.3, 341.693)), \n\t\t\t\t   dot(p,vec3(419.2,371.9, 127.143)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\n// ------------------------------------------------------- atmosphere -----------------------------------------------------------------------------\n// Credit: Written by GLtracy\n// found on shadertoy\n\n// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst float MAX = 10000.0;\n\n// scatter const\nconst float K_R = 0.166;\nconst float K_M = 0.0025;\nconst float E = 14.3; \t\t\t\t\t\t// light intensity\nconst vec3  C_R = vec3( 0.3, 0.7, 1.0 ); \t// 1 / wavelength ^ 4\nconst float G_M = -0.85;\t\t\t\t\t// Mie g\n\nconst float R = 1.016 * 6300.0;\nconst float R_INNER = 2.0 * 0.49840050697085 * 6300.0;\n\nconst float SCALE_H = 4.0 / ( R - R_INNER );\nconst float SCALE_L = 1.0 / ( R - R_INNER );\n\nconst int NUM_OUT_SCATTER = 10;\nconst float FNUM_OUT_SCATTER = 10.0;\n\nconst int NUM_IN_SCATTER = 10;\nconst float FNUM_IN_SCATTER = 10.0;\n\n// angle : pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\n// Reyleigh\n// g : 0\n// F = 3/4 * ( 1 + c^2 )\nfloat phase_reyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat density( vec3 p ){\n\treturn exp( -( length( p ) - R_INNER ) * SCALE_H );\n}\n\nfloat optic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * SCALE_L;\n\t\n\treturn sum;\n}\n\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\tfor ( int i = 0; i < NUM_IN_SCATTER; i++ ) {\n\t\tvec2 f = ray_vs_sphere( v, l, R );\n\t\tvec3 u = v + l * f.y;\n\t\t\n\t\tfloat n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );\n\t\t\n\t\tsum += density( v ) * exp( -n * ( K_R * C_R + K_M ) );\n\n\t\tv += step;\n\t}\n\tsum *= len * SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E;\n}\n\n// ---------------------------------------------------------Shading Functions----------------------------------------------------------------------\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\nfloat distribution(vec3 n, vec3 h, float roughness)\n{\n    float m_Sq= roughness * roughness;\n    float NdotH_Sq= max(dot(n, h), 0.0);\n    NdotH_Sq= NdotH_Sq * NdotH_Sq;\n    return exp( (NdotH_Sq - 1.0)/(m_Sq*NdotH_Sq) )/ (3.14159265 * m_Sq * NdotH_Sq * NdotH_Sq);\n}\n\nfloat geometry(vec3 n, vec3 h, vec3 v, vec3 l, float roughness)\n{\n    float NdotL_clamped= max(dot(n, l), 0.0);\n    float NdotV_clamped= max(dot(n, v), 0.0);\n    float k= roughness * sqrt(2.0/3.14159265);\n    float one_minus_k= 1.0 -k;\n    return ( NdotL_clamped / (NdotL_clamped * one_minus_k + k) ) * ( NdotV_clamped / (NdotV_clamped * one_minus_k + k) );\n}\n\nfloat fresnel(float f0, vec3 n, vec3 l)\n{\n    return f0 + (1.0-f0) * pow(1.0- dot(n, l), 5.0);\n}\n\nfloat diffuseEnergyRatio(float f0, vec3 n, vec3 l)\n{\n    return 1.0 - fresnel(f0, n, l);\n}\n\n// -----------------------------------------------------Distance Function / Tools ---------------------------------------------------------------------\n\nfloat rmf(vec3 p, float frequency, float lacunarity)\n{\n    p *= frequency;\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float h = 1.0;\n    float f = 1.0;\n\n    for (int curOctave=0; curOctave < 6; curOctave++) \n    {\n        signal = noise(p);\n        signal = pow(1.0 - abs(signal), 2.0) * weight;\n        weight = clamp(0.0, 1.0, signal * 16.0);\n        value += (signal * pow(f, -1.0));\n        f *= lacunarity;\n        p *= lacunarity;\n    }\n    \n    return (value * 1.25) - 1.0;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h, float k)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025*k+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y);\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Kali's code for this fractal (modified)\nfloat cc, ss;\n\nvec4 formula (vec4 p) \n{\n\t//p.y-=t*.25;\n    p.y=abs(3.-mod(p.y, 6.));\n    for (int i=0; i<6; i++) {\n\t\tp.xyz = abs(p.xyz)-vec3(.0,1.,.0);\n\t\tp=p*1.6/clamp(dot(p.xyz,p.xyz),.2,1.)-vec4(0.4,1.5,0.4,0.);\n\t\tp.xz*=mat2(cc,ss,-ss,cc);\n\t}\n\treturn p;\n}\n\nvec2 de(vec3 pos) \n{\n\tfloat aa=smoothstep(0.,1.,clamp(cos(-pos.y*.4)*1.5,0.,1.))*3.14159;\n    cc=cos(aa);\n    ss=sin(aa);\n\tvec3 tpos=pos;\n\tvec4 p=vec4(tpos,1.);\n\tfloat y=max(0.,.3-abs(pos.y-3.3))/.3;\n    p=formula(p);\n    float fr=max(abs(p.z/p.w)-.01,length(p.zx)/p.w-.002);\n    float d=fr;\n    \n    return vec2(d, pow(dot(p.xy, p.zw)*0.004, 2.666));\n}\n\nfloat sdf(vec3 p, out float m)\n{\n    const vec3 c = vec3(6.0);\n    vec3 w = mod(p, c)-0.5*c;\n    vec3 hashid=hash3(floor(p/12.0));\n    w = rotationMatrix(hashid, iTime*0.05)*w;\n    \n    p = rotationMatrix(vec3(0.0, 1.0, 0.0), 0.1*iTime) * p;\n\tfloat sd = sdCappedCylinder(p, vec2(2.0, 0.16));\n    sd = max(sd, -sdCappedCylinder(p, vec2(1.86, 0.2)));\n    sd = max(sd, -sdCappedCylinder(p-vec3(0.0, 0.0, 0.0), vec2(1.96, 0.12)));\n    sd = min(sd, sdBox(p, vec3(0.16, 0.16, 1.86)));\n    sd = min(sd, sdBox(p, vec3(1.86, 0.16, 0.16)));\n    vec2 fr = de(p*0.25-vec3(0.0, 7.97, 0.0));\n    float fractal = fr.x;\n    m = min(1.0, fr.y);\n    fractal = max(fractal, sdCappedCylinder(p, vec2(2.0, 2.0)));\n    fractal = min(fractal, length(p)-0.5);\n    sd = min(sd, fractal);\n    sd = min(sd, length(p-vec3(0.0, 2.3, 0.0))-0.55);\n    sd = min(sd, sdBox(p-vec3(0.0, -2.7, 0.0), vec3(0.65)));\n    \n    float astroids = (length(w)-0.5*hash(dot(hashid, hashid))); \n    if (astroids < sd)\n    {\n        sd = astroids-rmf(w, 32.0, 0.5)*0.01;\n        m = 2.0;\n    }\n    return sd;\n}\n\n\nvec3 grad(vec3 p, float eps)\n{\n    float m;\n    vec3 f = vec3(sdf(p, m));\n    vec3 g = vec3(sdf(p+vec3(eps, 0.0, 0.0), m),\n                  sdf(p+vec3(0.0, eps, 0.0), m),\n                  sdf(p+vec3(0.0, 0.0, eps), m));\n    return (g-f) / eps;\n}\n\n// ---------------------------------------------------------------------------------------------------------------------------------------\n\nfloat ambientOcclusion(const vec3 p, vec3 N)\n{\n    const float k = 4.0;\n    float amboDelta = 0.04;\n    float ambo = 0.0;\n    float t = 1.0;\n    float m;\n    for (int i=1; i<=4; i++)\n    {\n        ambo += t * (float(i)*amboDelta - sdf(p+N*amboDelta*float(i), m));\n        t *= 0.5;\n    }\n    return 1.0 - min(1.0, k*ambo);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) \n{\n\tfloat sh = 1.0;\n\tfloat t = mint;\n\tfloat h = 0.0;\n    float m;\n\tfor (int i = 0; i < 32; i++) \n\t{\n\t\tif (t > maxt)\n\t\t\tbreak;\n\t\th = sdf(ro+rd*t, m);\n\t\tsh = min(sh, k*h/t);\n\t\tt += h;\n\t}\n\treturn max(0.1, sh);\n}\n\nvec3 setupRayDirection(vec2 v, float camFov)\n{\n    float fov_y_scale = tan(camFov/2.0);\n    vec3 raydir = vec3(v.x*fov_y_scale, v.y*fov_y_scale, -1.0);\n    return normalize(raydir);\n}\n\nconst float starLimit = 0.975;\nconst vec3 starColor = vec3(1.0, 0.9, 0.8);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // coordinate system with origin in the center and y-axis goes up\n    // y-range is [-1.0, 1.0] and x-range is based on aspect ratio.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0 * gl_FragCoord.xy) / iResolution.y;\n    vec2 m = 2.0*(iMouse.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    //p.x += sin(time*10.0)*0.01*sin(uv.y*resolution.y*2.0);\n    //p.y += sin(time*100.0)*0.01*sin(uv.x*resolution.y*2.0);\n    \n    //vec3 lightPos = vec3(sin(time), 0.0, 0.3);\n    vec3 lightDir = normalize(vec3(-0.4496467, 0.4155184, 0.3416573));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 rayOrigin = vec3(-1.95, 0.0, 0.0);\n    mat3 rm = rotationMatrix(vec3(0.0, 1.2, 1.0), 1.9);\n    rm *= rotationMatrix(vec3(1.0, 0.0, 0.0), -sin(iTime)*0.1);\n    if (iTime > 15.0)\n    {\n        rayOrigin = vec3(-3.0, 4.0-iTime*0.05, 1.0);\n    \trm = rotationMatrix(normalize(vec3(0.0, 1.0, 1.0)), 2.0);\n    }\n    vec3 rayDir = rm * setupRayDirection(p, radians(100.0));\n    \n    vec3 rayPos = rayOrigin;\n    float sd;\n    float travel = 0.0;\n    \n    vec3 sp = vec3(0.0);\n    bool hit = false;\n    float coneR;\n    float mat =0.0;\n    for (int i=0; i<256; i++)\n    {\n        coneR = travel * tan(0.25*radians(100.0)/iResolution.y);\n        sd = sdf(rayPos, mat);\n        \n        if (abs(sd) < coneR)\n        {\n            hit = true;\n            break;\n        }\n        \n        rayPos += rayDir * sd *0.8;\n        travel += sd *0.8;\n        if (travel > 16.0)\n        {\n            break;\n        }\n    }\n\n    if (hit == true)\n    {\n        //gl_FragColor = vec4(travel*0.1);return;\n        vec3 N = normalize(grad(rayPos, coneR));\n        vec3 P = rayPos;\n        \n        float ambo = ambientOcclusion(P, N);\n        // shadow is messed up\n        float shadow = softShadow(P, lightDir, 0.1, 16.0, 128.0);\n        \n        // constants for now \n\t    float refractiveIndex = clamp(15.0*abs(mat), 0.0, 15.0);\n\t    float u_roughness = clamp(mat*0.25, 0.0, 1.0);\n\t    vec3 u_diffuseColor = mix(vec3(0.25, 0.3, 0.3)*2.0, vec3(0.6, 0.6, 0.8), clamp(mat, 0.0, 1.0));\n        if (mat >= 2.0)\n        {\n            u_diffuseColor = vec3(1.0);\n            u_roughness = 0.1;\n            refractiveIndex = 3.0;\n        }\n        float u_fresnel0 = pow((1.0 - refractiveIndex)/(1.0 + refractiveIndex), 2.0);\n\t    \n        // surface params\n        vec3 halfVec=  normalize(lightDir - rayDir);\n            \n        float NdotL = dot(N, lightDir);\n        float NdotV = dot(N, -rayDir);\n        float NdotL_clamped= max(NdotL, 0.0);\n        float NdotV_clamped= max(NdotV, 0.0);\n        float brdf_spec= fresnel(u_fresnel0, halfVec, lightDir) \n            * geometry(N, halfVec, -rayDir, lightDir, u_roughness) \n            * distribution(N, halfVec, u_roughness) / (4.0 * NdotL_clamped * NdotV_clamped);\n        vec3 color_spec= NdotL_clamped * brdf_spec * lightColor;\n        vec3 color_diff= NdotL_clamped * diffuseEnergyRatio(u_fresnel0, N, lightDir) * u_diffuseColor * lightColor;\n        vec3 color = max(vec3(0.0), color_spec)+color_diff+clamp(-N.z+0.25, 0.0, 1.0)*vec3(0.8, 0.8, 1.0)*u_diffuseColor; // + sh_light(rotationMatrix(vec3(0.0, 1.0, 0.0), 1.9)*N, beach)*0.15;\n        fragColor = vec4(ambo*shadow*color, 1.0);\n        //gl_FragColor.r += mod((atan(rayPos.x, rayPos.z)+3.14) / 6.28, 0.0625) * 16.0;\n    }\n    else\n    {\n        vec3 ro = rayOrigin + vec3(0.0, 0.0, 6450.0);\n        vec2 e = ray_vs_sphere( ro, rayDir, R );\n\t    if ( e.x > e.y || e.x < 0.0 ) {\n\t\t    float n = noise(vec3(uv * 1000.0, 0.0));\n            if (n > starLimit) {\n        \t\tfragColor = vec4(starColor * smoothstep(starLimit, 1.0, n), 1.0);\n            }\n            else {\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n\t\n            return;\n\t    }\n\t\n\t    vec2 f = ray_vs_sphere( ro, rayDir, R_INNER );\n        //e.y = f.x;\n\t    e.y = min( e.y, f.x );\n        \n\t    vec3 I = in_scatter( ro, rayDir, e, lightDir );\n        \n        fragColor = vec4(I, 1.0);\n    }\n    \n    float distanceFromCenter = length( uv - vec2(0.5, 0.5) );\n    float vignetteAmount;\n    vignetteAmount = 1.0 - distanceFromCenter;\n    vignetteAmount = smoothstep(0.1, 1.0, vignetteAmount);    \n    vec3 color = fragColor.xyz;\n    color = pow(color, vec3(0.8));\n    color += 0.05*sin(uv.y*iResolution.y*2.0);\n    color += 0.009 * sin(iTime*16.0);\n    color *=  vignetteAmount*1.0;\n    \n\tfragColor.xyz = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlSGz1","date":"1426824801","viewed":287,"name":"[NV15]Flossing Space","username":"florian","description":"A ton of code thrown into glsl sandbox and then into shadertoy last minute. Needs flossing and tuning.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["space","nv15"],"hasliked":0,"parentid":"","parentname":""}}