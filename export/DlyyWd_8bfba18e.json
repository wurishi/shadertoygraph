{"ver":"0.1","info":{"id":"DlyyWd","date":"1700776584","viewed":53,"name":"[WIP] Micro Planet","username":"codeforger","description":"pixel shaded planet","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pixel","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec4 planet = vec4(1024/2,576/2,300, 1);\nconst vec3 sunVector = vec3(1, 1, -1);\n//const vec3 sunVector = vec3(1, 0, 0);\nconst int MARCH_MAX = 100;\nconst float DST_MAX = 600.;\nconst float DST_THRESHOLD = .1;\n\nvec3[] colors = vec3[] (\n\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.5, 0.5, 0.5 ),\n        vec3( .0, 0., 1. ),\n        vec3( 0.5, 1.0, 0.5 ),\n        vec3( 0.5, 0.5, 1.0 ),\n        vec3( 0.5, 1.0, 1.0 ),\n        vec3( 1.0, 0.5, 1.0 ),\n        vec3( 1.0, 1.0, 0.5 )\n);\n\nvec3 distToScene(vec3 point){\n    vec3 retPlanet = vec3(0, 0, 0);\n    vec3 vecToPlanet = planet.xyz - point;\n    float ang = atan(vecToPlanet.x / vecToPlanet.z) + iTime/3.;\n    float noise = (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * 2.))/10.;\n    float planetRawDst = distance(point, planet.xyz + noise * vecToPlanet) - 200.;\n    retPlanet.x = planetRawDst; // + (Pseudo3dNoise(vec3((point.x)/60. + iTime, point.y/60.,0))*20.);\n    retPlanet.y = planet.a;\n    retPlanet.z = (distance(point, planet.xyz) - 200.) / 40.;\n    vec3 retSea = vec3(0, 0, 0);\n    retSea.x = distance(point, planet.xyz) - 200. ;\n    retSea.y = 2.;\n    retSea.z = 0.;\n    return retPlanet.x < retSea.x ? retPlanet: retSea;\n}\n\nvec4 march(vec2 uv) {\n    float dst = 0.;\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec3 objInfo = distToScene(vec3(uv, dst));\n        dst += objInfo.x;\n        if(dst > DST_MAX) {\n            return vec4(DST_MAX,0, 0, i);\n        }\n        \n        if(objInfo.x < DST_THRESHOLD){\n            return vec4(dst, objInfo.yz, i);\n        }\n        \n    }\n    \n    return vec4(DST_MAX, 0, 0, 100);\n}\n\nfloat marchToSun(vec3 uv) {\n    vec3 uv2 = vec3(uv.xy, uv.z - DST_THRESHOLD*4.);\n    float dst = 0.;\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec3 objInfo = distToScene(vec3(uv2 + (sunVector * dst)));\n        dst += objInfo.x;\n        if(dst > DST_MAX) {\n            return 1.-float(i)/float(MARCH_MAX);\n        }\n        \n        if(objInfo.x < DST_THRESHOLD){\n            return 0.;\n        }\n        \n    }\n    \n    return 1.;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - vec2(ivec2(fragCoord)%8);\n    //vec2 uv = fragCoord;\n\n\n    vec4 hitInfo = march(uv);\n    float dst = (1.-(hitInfo.x/DST_MAX));\n    float itrs = clamp(float(hitInfo.a)/float(MARCH_MAX), 0., .5);\n    float sunLightRaw = marchToSun(vec3(uv, hitInfo.x));\n    float sunLightPlanet = (hitInfo.x == DST_MAX ? 0. : sunLightRaw);\n    float sunLight = sunLightRaw;\n    float sunLightAtmos =  (((sunLightRaw) *marchToSun(vec3(uv, planet.z - sunVector.z*length(planet.xy-uv)))) / 4. * 3. + .25);\n    // Output to screen\n    fragColor = vec4(clamp(\n    colors[int(hitInfo.y)]*dst * sunLight + hitInfo.z * sunLight + (vec3(.7, .7, 1) * itrs * sunLightAtmos),\n    vec3(0,0,0),\n    vec3(1,1,1)\n    ) ,1.0);\n    //fragColor = vec4(vec3(.7, .7, 1) * itrs * sunLightAtmos,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    //float rand = texture(iChannel0, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}","name":"Common","description":"","type":"common"}]}