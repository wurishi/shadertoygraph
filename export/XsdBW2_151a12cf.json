{"ver":"0.1","info":{"id":"XsdBW2","date":"1526861156","viewed":213,"name":"Koch Snowflake 3D","username":"BenDrews","description":"An attempt to raymarch a 3D extension of the Koch snowflake fractal.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kochsnowflake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Ben Drews\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// 3D extenstion of Koch snowflake to tetrahedra.\n//\n// Raymarching skeleton taken from iq's shader \"Apollonian\"\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nfloat longTime = 20.0;\nvec3 far = vec3(10.0);\nfloat maxIters = 5.0;\nint iters = 0;\nfloat height = 1.0;\n\nvec3 orb;\nvec3 orb2;\nvec3 lastPt(vec3 p1, vec3 p2, vec3 p3, float scale) {\n    float l = length(p2 - p1);\n    vec3 n = normalize(cross(p2-p1,p3-p1));\n    return (0.6666666667 * ((p1 + p2)/2.0f - p3)) + p3 + (n*l*0.81649658092*scale);\n}\n\nfloat rayTriangle(vec3 P, vec3 w, inout vec3 n, vec3 v1, vec3 v2, vec3 v3){\n    //Edge vectors\n    vec3 e1 = v2-v1;\n    vec3 e2 = v3-v1;\n    \n    n = normalize(cross(e1, e2));\n    \n    vec3 q = cross(w, e2);\n    float a = dot(e1, q);\n    \n    vec3 s = (P - v1) / a;\n    vec3 r = cross(s, e1);\n    \n    float b0 = dot(s, q);\n    float b1 = dot(r, w);\n    float b2 = 1.0 - b0 - b1;\n    if ((b0 >= 0.0) && (b1 >= 0.0) && (b2 >= 0.0)) return dot(e2, r);\n    return longTime;\n    \n}\n\nfloat rayTetra(vec3 P, vec3 w, inout vec3 n, vec3 v1, vec3 v2, vec3 v3, vec3 v4){\n\tfloat t = rayTriangle(P, w, n, v1, v2, v3);\n    vec3 n1;\n    float t1 = rayTriangle(P, w, n1, v1, v3, v4);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v2, v4, v3);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v1, v4, v2);\n    if(t1 < t) { t = t1; n = n1; }\n    return t;\n}\n\nvoid chooseTetra(vec3 P, vec3 w, inout vec3 p1, inout vec3 p2, inout vec3 p3, inout vec3 p4, vec3 p5, vec3 p6, vec3 p7, vec3 p8, inout float t, inout vec3 n, vec3 col, inout float next) {\n\tvec3 n1;\n    float t2 = rayTetra(P, w, n1, p5, p6, p7, p8);\n    if( t2 < t) {\n        t = t2;\n        n = n1;\n        p1 = p5;\n        p2 = p6;\n        p3 = p7;\n        p4 = p8;\n        orb = col;\n    }\n    if( t2 < next && t2 > 0.0) {\n    \tnext = t2;\n    }\n}\n\nvec3 o1 = vec3(0.0, 0.0, 0.0);\nvec3 o2 = vec3(1.0, 0.0, 0.0);\nvec3 o3 = vec3(0.5, 0.86602540378, 0.0);\nvec3 o4 = vec3(0.5, 0.28867513459, 0.81649658092);\n\n    \nfloat map( vec3 P, vec3 w, float s, inout vec3 n, inout int level)\n{\n    orb = vec3(0.0);\n    orb2 = vec3(0.0);\n    vec3 p1 = far;\n    vec3 p2 = far;\n    vec3 p3 = far;\n    vec3 p4 = far;\n    \n    float t = longTime;\n    float next = t;\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o1, 2.0*o2, 2.0*o3, 2.0*lastPt(o3, o2, o1, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,1.0), next);\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o2, 2.0*o4, 2.0*o3, 2.0*lastPt(o3, o4, o2, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o3, 2.0*o4, 2.0*o1, 2.0*lastPt(o1, o4, o3, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);\n    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o2, 2.0*o1, 2.0*o4, 2.0*lastPt(o2, o4, o1, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,0.0,1.0), next);\n\torb2 += orb;    \n                \n    vec3 v1 = p1;\n    vec3 v2 = p2;\n    vec3 v3 = p3;\n    vec3 v4 = (p1 + p2)/2.0;\n    vec3 v5 = (p2 + p3)/2.0;\n    vec3 v6 = (p1 + p3)/2.0;\n    vec3 v7 = lastPt(v4, v6, v5, 1.0);\n  \t\n    if(t > 0.0) {\n    \tlevel = -1;\n        return t;\n    }\n    for(int i=0; i <iters; i++) {\n        t = next;\n        chooseTetra(P, w, p1, p2, p3, p4, v4, v6, v1, lastPt(v1, v6, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v5, v3, v6, lastPt(v6, v3, v5, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,1.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v2, v5, v4, lastPt(v4, v5, v2, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v4, v7, v6, lastPt(v6, v7, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v5, v6, v7, lastPt(v7, v6, v5, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);\n        chooseTetra(P, w, p1, p2, p3, p4, v4, v5, v7, lastPt(v7, v5, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,0.0), next);\n        orb2 += orb;\n        v1 = p1;\n        v2 = p2;\n        v3 = p3;\n        v4 = (p1 + p2)/2.0;\n        v5 = (p2 + p3)/2.0;\n        v6 = (p1 + p3)/2.0;\n        v7 = lastPt(v4, v6, v5, 1.0);\n        if(t > 0.0) {\n        \tlevel = i;    \n            return t;\n        }\n    }\n    t = next - 0.01;\n    \n    //For anim\n    v7 = lastPt(v4, v6, v5, height);\n    orb2 -= orb;\n    orb2 += orb*height;\n    vec3 n1;\n    float t1 = rayTriangle(P, w, n1, v1, v6, v4);\n    if(t1 < t) {t = t1; n = n1;}\n    t1 = rayTriangle(P, w, n1, v6, v3, v5);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v5, v2, v4);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v4, v6, v7);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v7, v6, v5);\n    if(t1 < t) { t = t1; n = n1; }\n    t1 = rayTriangle(P, w, n1, v7, v5, v4);\n    if(t1 < t) { t = t1; n = n1; }\n    level = iters;\n\treturn t;\n}\n\n\n//Ray marching\nfloat trace( in vec3 ro, in vec3 rd, float s, inout vec3 n)\n{\n    int count = max(8, 2*iters);\n\tfloat maxd = longTime;\n    float t = 0.01;\n    int level = 0;\n    for( int i=0; i<count; i++)\n    {\n\t    float precis = 0.001 * t;\n\t    float h = map( ro+rd*t, rd, s, n, level);\n        if((h < precis && level == iters) || t>maxd ) break;\n        t += max(h, 0.01);\n    }\n\n    if( t>maxd) t=-1.0;\n    return t;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float t = trace( ro, rd, anim, n);\n    if( t>0.0 )\n    {\n        vec3 tra = orb2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = n;\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(1.0,1.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.0,0.0), clamp(tra.x,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,1.0,0.0), clamp(tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(0.0,0.0,1.0), clamp(tra.z,0.0,1.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = maxIters * (1.0 + cos(0.2*iTime));\n    iters = int(anim);\n    height = fract(anim);\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        // camera\n        vec2 mo = iMouse.xy/iResolution.xy;\n\t\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA); \n\tfragColor = vec4( tot, 1.0 );\t\n\n}","name":"Image","description":"","type":"image"}]}