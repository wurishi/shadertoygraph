{"ver":"0.1","info":{"id":"4fdyRr","date":"1730169587","viewed":31,"name":"Perlin Noise ~ buzaszendvics","username":"buzaszendvics","description":"Perlin noise.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","geometry","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec3 inp) {\n    vec3 i = floor(inp);\n    vec3 f = fract(inp);\n\n    f = f * f * (3.0 - 2.0 * f); // Smootherstep interpolation\n\n    float n = dot(i, vec3(1.0, 57.0, 113.0)); // New, smoother hash basis\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat perlin_part(vec3 inp)\n{\n    vec3 fl = floor(inp);\n    vec3 fr = fract(inp);\n    \n    fr = smoothstep(0.0, 1.0, fr);\n    \n    float L = fl.x;\n    float R = fl.x + 1.0;\n    float T = fl.y;\n    float B = fl.y + 1.0;\n    float T0 = fl.z;\n    float T1 = fl.z + 1.0;\n    \n    float LT0 = noise(vec3(L, T, T0));\n    float LT1 = noise(vec3(L, T, T1));\n    float LB0 = noise(vec3(L, B, T0));\n    float LB1 = noise(vec3(L, B, T1));\n    float RT0 = noise(vec3(R, T, T0));\n    float RT1 = noise(vec3(R, T, T1));\n    float RB0 = noise(vec3(R, B, T0));\n    float RB1 = noise(vec3(R, B, T1));\n    \n    float LT = LT0*(1.0-fr.z) + LT1*fr.z;\n    float LB = LB0*(1.0-fr.z) + LB1*fr.z;\n    float RT = RT0*(1.0-fr.z) + RT1*fr.z;\n    float RB = RB0*(1.0-fr.z) + RB1*fr.z;\n    \n    float l = LT*(1.0-fr.y) + LB*fr.y;\n    float r = RT*(1.0-fr.y) + RB*fr.y;\n    \n    float final = l*(1.0-fr.x) + r*fr.x;\n    \n    return final;\n}\n\nvec3 colors0[10] = vec3[10](\n    vec3(0.1, 0.4, 0.7), // Deep blue\n    vec3(0.2, 0.5, 0.8), // Soft sky blue\n    vec3(0.15, 0.45, 0.65), // Muted ocean blue\n    vec3(0.1, 0.45, 0.6), // Teal blue\n    vec3(0.08, 0.35, 0.55), // Dark cyan\n    vec3(0.12, 0.48, 0.7), // Sea blue\n    vec3(0.1, 0.4, 0.5), // Slate teal\n    vec3(0.18, 0.42, 0.7), // Cornflower blue\n    vec3(0.1, 0.35, 0.65), // Stormy blue\n    vec3(0.12, 0.4, 0.6)); // Aqua marine\n    \nvec3 colors1[3] = vec3[3](\n    vec3(0.48, 0.09, 0.15), // Deep Ruby\n    vec3(0.69, 0.19, 0.66), // Amethyst Purple\n    vec3(0.85, 0.50, 0.54));  // Olive Green\n    \nvec3 colors2[3] = vec3[3](\n    vec3(1.0, 0.78, 0.86),  // Light Pink\n    vec3(1.0, 0.56, 0.71),  // Hot Pink\n    vec3(1.0, 0.88, 0.0));    // Sunset Yellow\n    \nvec3 colors3[3] = vec3[3](\n    vec3(0.18, 0.1, 0.32),  // Dark Cosmic Blue\n    vec3(0.52, 0.33, 0.75), // Purple Nebula\n    vec3(0.9, 0.8, 0.18));   // Pastel Aqua);    // Sunset Yellow\n\nfloat perlin(vec3 inp)\n{\n    int layers = 15;\n    float mult = 0.85;\n\n    \n    inp += 3.0;\n\n    float f = 0.0;\n    float m = 1.0;\n    float s = 0.0;\n    for (int i = 0; i < layers; i++)\n    {\n        f += perlin_part(inp/m) * m;\n        s += m;\n        m *= mult;\n    }\n    f /= s;\n    return 0.5+0.5*sin(f*6.28318530718);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 layers[4];\n    \n    layers[0] = colors0[int(iTime+round(sin(uv.x*200.0)*0.5+sin(uv.y*200.0)*0.5))%10];\n    layers[1] = colors1[int(iTime*5.0+round(uv.x*90.0))%3];\n    layers[2] = colors2[int(round(fract(dot(uv*20.0, vec2(-0.5, 0.5)))))+int(round(fract(dot(uv*20.0, vec2(0.5, 0.5)))))];\n    layers[3] = colors3[int(fract(uv.y*20.0)*3.0)];\n    \n    float v = perlin(vec3(uv*0.5, iTime*0.2));\n    float u = perlin(vec3(1.0+uv*0.7, iTime*0.05));\n    \n    int U = int(floor(v*2.4));\n    int V = int(floor(u*2.4));\n    \n    vec3 color = vec3(layers[V+U]);\n    //color = vec3(layers[2]);\n    \n    fragColor = vec4(color, 1.0);\n\n    // Output to screen5\n}","name":"Image","description":"","type":"image"}]}