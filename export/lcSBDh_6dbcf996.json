{"ver":"0.1","info":{"id":"lcSBDh","date":"1724865033","viewed":73,"name":"anamorphic rendering","username":"rossning92","description":"Anamorphic compression with custom parameters, including: 1) focal point input, 2) focal region size, 3) minimal sampling rate.","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["anamorphic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nfloat decompress(float x, float rate, float fovea, float focal) {\n  // The polynomial coefficients should be calculated on the CPU side. I am\n  // writing it down here mostly for demo purposes.\n  highp mat3 mat;\n  mat[0][1] = 2.0 * rate / (-fovea * rate + fovea + rate + 1.0);\n  mat[0][2] = (rate - 1.0) /\n              ((focal - 0.5 * fovea) * (fovea * rate - fovea - rate - 1.0));\n  mat[1][0] = -((focal - 0.5 * fovea) * (rate - 1.0) /\n                (fovea * rate - fovea - rate - 1.0));\n  mat[1][1] = 2.0 / (2.0 * fovea - (fovea - 1.0) * (rate + 1.0));\n  mat[2][0] =\n      ((rate - 1.0) *\n       (focal * fovea + focal + 0.5 * fovea * fovea - 0.5 * fovea) /\n       ((focal + 0.5 * fovea - 1.0) * (fovea * rate - fovea - rate - 1.0)));\n  mat[2][1] =\n      (-2.0 * (focal * rate + 0.5 * fovea * rate - 1.0) /\n       ((focal + 0.5 * fovea - 1.0) * (fovea * rate - fovea - rate - 1.0)));\n  mat[2][2] = (rate - 1.0) / ((focal + 0.5 * fovea - 1.0) *\n                              (fovea * rate - fovea - rate - 1.0));\n\n  if (x < focal - 0.5 * fovea) {\n    return mat[0][2] * x * x + mat[0][1] * x;\n  } else if (x < focal + 0.5 * fovea) {\n    return mat[1][1] * x + mat[1][0];\n  } else {\n    return mat[2][2] * x * x + mat[2][1] * x + mat[2][0];\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float focalX = 0.5;\n    float focalY = 0.5;\n    float rate = 2.0;\n\n    focalX = 0.5 + sin(iTime) * 0.2;\n    focalY = 0.5 + cos(iTime) * 0.2;\n\n    uv.x = decompress(uv.x, rate, 0.5, focalX);\n    uv.y = decompress(uv.y, rate, 0.5, focalY);\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"}]}