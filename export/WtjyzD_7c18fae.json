{"ver":"0.1","info":{"id":"WtjyzD","date":"1593868165","viewed":89,"name":"Hex Banner","username":"RedReservoir","description":"Just an hexagon pattern generator","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","bannero"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAYMARCHING_ITERATIONS 100\n#define EPSILON 0.00001\n#define MIN_DIST 0.00001\n#define MAX_DIST 100.0\n\nstruct material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n        \nstruct light {\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmaterial mat_black = material(vec3(0, 0, 0), vec3(0, 0, 0), vec3(0, 0, 0), 100.0);\nmaterial mat_red = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.2, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_green = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_blue = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_orange = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.5, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_turquoise = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.5), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_purple = material(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial[] materials = material[] (\n    material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.2, 0.2), vec3(1.0, 1.0, 1.0), 100.0),\n    material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.2), vec3(1.0, 1.0, 1.0), 100.0),\n    material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0),\n    material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.5, 0.2), vec3(1.0, 1.0, 1.0), 100.0),\n    material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.5), vec3(1.0, 1.0, 1.0), 100.0),\n    material(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0)\n);\nint m_num = 6;\n\nlight[] scene_lights = light[] (\n    light(vec3(6.0, -3.0, 5.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0))\n);\nint l_num = 1;\n\nvec3 background_color = vec3(0.7, 0.7, 0.9);\n\nfloat ap = 0.5;\nint x_size = 13;\nint y_size = 13;\nint x_shift = 0;\nint y_shift = 0;\n\n//---------------------------------------------------------------------------------\n\nfloat mixInverse(float x, float y, float a) {\n\treturn (a - x) / (y - x);    \n}\n\nfloat unitMap(float x) {\n    return (2.0 / (1.0 + exp(-x))) - 1.0;\n}\n\nfloat unitMapInverse(float x) {\n\treturn -log((2.0 / (x + 1.0)) - 1.0);    \n}\n\nfloat unitPow(float x, float p) {\n\treturn unitMap(pow(unitMapInverse(x), p));   \n}\n\nmat4 identityMatrix() {\n\tmat4 id;\n    id[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    id[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    id[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    id[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    return id;\n}\n\nmat4 rotationMatrix(float ax, float ay, float az) {\n\tmat4 rot_x;\n    rot_x[0] = vec4(1.0, 0.0, 0.0, 0.0);\n    rot_x[1] = vec4(0.0, cos(ax), -sin(ax), 0.0);\n    rot_x[2] = vec4(0.0, sin(ax), cos(ax), 0.0);\n    rot_x[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_x = transpose(rot_x);\n\n    mat4 rot_y;\n    rot_y[0] = vec4(cos(ay), 0.0, sin(ay), 0.0);\n    rot_y[1] = vec4(0.0, 1.0, 0.0, 0.0);\n    rot_y[2] = vec4(-sin(ay), 0.0, cos(ay), 0.0);\n    rot_y[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_y = transpose(rot_y);\n\n    mat4 rot_z;\n    rot_z[0] = vec4(cos(az), -sin(az), 0.0, 0.0);\n    rot_z[1] = vec4(sin(az), cos(az), 0.0, 0.0);\n    rot_z[2] = vec4(0.0, 0.0, 1.0, 0.0);\n    rot_z[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    rot_z = transpose(rot_z);\n    \n    return rot_z * rot_y * rot_x;\n}\n\nmat4 scaleMatrix(float sx, float sy, float sz) {\n    mat4 sc;\n    sc[0] = vec4(sx, 0.0, 0.0, 0.0);\n    sc[1] = vec4(0.0, sy, 0.0, 0.0);\n    sc[2] = vec4(0.0, 0.0, sz, 0.0);\n    sc[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    sc = transpose(sc);\n    return sc;\n}\n\nmat4 translationMatrix(float tx, float ty, float tz) {\n    mat4 tr;\n    tr[0] = vec4(1.0, 0.0, 0.0, tx);\n    tr[1] = vec4(0.0, 1.0, 0.0, ty);\n    tr[2] = vec4(0.0, 0.0, 1.0, tz);\n    tr[3] = vec4(0.0, 0.0, 0.0, 1.0);\n    tr = transpose(tr);\n    return tr;\n}\n\n//Random numbers from https://www.shadertoy.com/view/tsf3Dn\nint xorshift(in int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\n//Random numbers from https://www.shadertoy.com/view/tsf3Dn\nint nextInt(int seed) {\n    seed = xorshift(seed);\n    return seed;\n}\n\n//Random numbers from https://www.shadertoy.com/view/tsf3Dn\nfloat nextFloat(int seed) {\n    seed = xorshift(seed);\n    // FIXME: This should have been a seed mapped from MIN..MAX to 0..1 instead\n    return abs(fract(float(seed) / 3141.592653));\n}\n\n//Random numbers from https://www.shadertoy.com/view/tsf3Dn\nfloat nextFloat(int seed, in float max) {\n    return nextFloat(seed) * max;\n}\n\n//---------------------------------------------------------------------------------\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 c, float h, float r) {\n    float inOutRadius = length(p.xy - c.xy) - r;\n    float inOutHeight = abs(p.z - c.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat hexPrismSDF(vec3 p, vec3 cen, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p - cen);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid unionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 < d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid intersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 > d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid differenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(-d1 > d2) {\n        d = -d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid smoothUnionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) - k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothIntersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothDifferenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, -d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid sceneSDF(vec3 pos, out float dist, out material obj_mat) {\n    \n    vec3 v1 = vec3(sqrt(3.0) * ap, ap, 0);\n\tvec3 v2 = vec3(0, 2.0 * ap, 0);\n    \n    dist = 99999999.0;\n    obj_mat = mat_black;    \n    for(int i = -x_size + x_shift; i <= x_size + x_shift; i++) {\n        for(int j = -y_size + y_shift; j <= y_size + y_shift; j++) {\n            float h_dist = hexPrismSDF(pos, (float(i) * v1) + (float(j) * v2), vec2(ap, 0.1));\n            float rand_float = nextFloat(int(round(137.0 * float(i) + float(j) * float(x_size))));\n            rand_float = unitPow(rand_float, 1.5);\n            material h_mat = material(vec3(0.5, 0.5, 0.5), mix(vec3(0.8, 0.5, 0.2), vec3(0.5, 0.2, 0.8), vec3(rand_float)), vec3(1.0, 1.0, 1.0), 100.0); \n            smoothUnionSDF(dist, h_dist, obj_mat, h_mat, dist, obj_mat, ap * 0.05, 7.0);\n        }\n    }\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 blinnPhong(vec3 pos, vec3 V, vec3 N, material mat, light lt) {\n    //Calculate L and H vectors\n    vec3 L = normalize(vec3(lt.position - pos));\n    vec3 H = normalize(L + V);\n\n    //Ambient\n    vec3 ambient = lt.ambient * mat.ambient;\n\n    //Diffuse\n    vec3 diffuse = lt.diffuse * mat.diffuse * max(dot(L, N), 0.0f);\n\n    //Specular\n    vec3 specular = lt.specular * mat.specular * pow(max(dot(H, N), 0.0f), mat.shininess);\n    \n    //Final color calculation\n    //vec3 color = diffuse + ambient + specular;\n    vec3 color = diffuse + ambient;\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 estimateNormal(vec3 pos) {\n    material placeholder;\n    float nxr, nxl, nyr, nyl, nzr, nzl;\n    sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z), nxr, placeholder);\n    sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z), nxl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z), nyr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z), nyl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON), nzr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON), nzl, placeholder);\n   \n    return normalize(vec3(nxr - nxl, nyr - nyl, nzr - nzl));\n}\n\nvoid castRay(vec3 ray_origin, vec3 ray_direction, float dmin, float dmax, out float scene_dist, out material obj_mat) {    \n    scene_dist = dmin;\n    float step_dist;\n    for(int it = 0; it < MAX_RAYMARCHING_ITERATIONS; it++) {\n        vec3 ray_pos = ray_origin + (ray_direction * scene_dist);\n        sceneSDF(ray_pos, step_dist, obj_mat);\n        scene_dist += step_dist;\n        if(step_dist < EPSILON || scene_dist > dmax) { return; }\n    }\n   \n    scene_dist = dmax + 1.0;\n}\n\nvec3 calculateScreenRayDirection(vec2 fragCoord, vec2 size, float fov) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calculateCameraMatrix(vec3 lookfrom, vec3 lookat, vec3 vup) {\n    vec3 cz = normalize(lookat - lookfrom);\n    vec3 cx = normalize(cross(cz, vup));\n    vec3 cy = cross(cx, cz);\n    return mat3(cx, cy, -cz);\n}\n\n\n//---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Precalculate variables\n    vec2 mouse_UV = iMouse.xy / iResolution.xy;\n    \n    //Camera calculations\n    vec3 v1 = vec3(sqrt(3.0) * ap, ap, 0);\n\tvec3 v2 = vec3(0, 2.0 * ap, 0);\n    \n    vec3 cam_lookat = vec3(0.0, 0, 0) + (float(x_shift) * v1) + (float(y_shift) * v2);\n    vec3 cam_lookfrom = cam_lookat + vec3(0.0,\n                                          0.0,\n                                          30.0\n                                         );\n    vec3 cam_vup = normalize(vec3(1, 10, 0));\n    mat3 cam_matrix = calculateCameraMatrix(cam_lookfrom, cam_lookat, cam_vup);\n    \n    //Apply raymarching\n    float scene_dist;\n    material obj_mat;\n    \n    vec3 ray_origin = cam_lookfrom;\n    vec3 ray_direction = cam_matrix * calculateScreenRayDirection(fragCoord, iResolution.xy, 45.0);\n    castRay(ray_origin, ray_direction, MIN_DIST, MAX_DIST, scene_dist, obj_mat);\n    \n    vec3 pos = ray_origin + (ray_direction * scene_dist);\n    vec3 norm = estimateNormal(pos);\n\n    vec3 col = vec3(0);\n    if(scene_dist < MAX_DIST) {\n        for(int l_index = 0; l_index < l_num; l_index++) {\n        \tcol += blinnPhong(pos, vec3(cam_lookfrom - pos), norm, obj_mat, scene_lights[l_index]);\n        }\n    } else {\n        col = background_color;\n    }\n    \n    //Gamma normalization\n    //col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}