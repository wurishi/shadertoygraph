{"ver":"0.1","info":{"id":"NtcSRl","date":"1639557214","viewed":54,"name":"Terrain Shader","username":"creator4","description":"Terrain Shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["df","terrains"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nRaymarched Terrain Fragment Shader made by Creator4\nHeavily inspired by Iq's work (Thank you!!!)\nhis website is at https://iquilezles.org/www/index.htm and I would\nNOT have gotten this working if it wasn't for his tutorials\n*/\n\n\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.0\n#define GAMMA 2.2\n\nmat3 cameraMatrix(vec3 lookFrom, vec3 lookAt, float roll) {\n    \n    vec3 w = normalize(lookAt - lookFrom);\n    vec3 u = normalize(cross(w, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n\n\n}\n\nfloat unionOp(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(0.4242, 438);\n\treturn fract(sin(p)*2434.1351);\n}\n\nfloat getClosestObj(vec3 p) { //sdf map for all objects in the scene\n    vec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    //float planeDist = heightMap(p.xz);\n    \n    //float d = min(sphereDist, planeDist);\n    return p.y;\n    \n}\n\nfloat noise( in vec2 p ) { //simplex noise function taken from https://www.shadertoy.com/view/Msf3WH\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(500.0) );\n    \n}\n\n\n\nfloat heightMap(vec2 grid) { //FBM mountain\n\n    grid *= 0.05;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    float f = 0.;\n    int numOctaves = 5;\n    float octVal = 0.5000;\n    for(int i = 0; i < numOctaves; i++) {\n        f += octVal*noise(grid);\n        grid = m*grid;\n        octVal = octVal * 0.5;\n    }\n    \n    f = 0.5 + 0.5*f;\n    f *= smoothstep(0.0, 0.005, abs(grid.x-0.6));\n\n    return max(f, 0.0);\n    \n    //return sin(grid.x)*sin(grid.y);\n    \n}\n\n\nbool rayMarch(vec3 rayOrigin, vec3 rayDir, inout float dist) {\n    float increment = 0.01;\n    float lh = 0.;\n    float ly = 0.;\n    for (float d = MIN_DIST; d < MAX_DIST; d += increment) {\n        vec3 pos = rayOrigin + rayDir*d;\n        float height = heightMap(pos.xz);\n        if(pos.y < height) {\n            dist = d - increment + increment * (lh - ly)/(pos.y-ly-height+lh);\n            return true;\n        }\n        increment = 0.01*d;\n        lh = height;\n        ly = pos.y;\n    \n    }\n    return false;\n}\n\nvec3 computeNormal(vec3 p) {\n    float e = 0.0001; //epsilon, tiny increment\n    float xNew = heightMap(vec2(p.x - e,p.z)) - heightMap(vec2(p.x + e, p.z));\n    float yNew = 2.*e;\n    float zNew = heightMap(vec2(p.x, p.z - e)) - heightMap(vec2(p.x, p.z + e));\n    return normalize(vec3(xNew, yNew, zNew));\n}\n\nfloat computeSoftShadows(vec3 pos, vec3 lightPos) {\n    float k = 1.;\n    float res = 1.;\n    float ph = 1e20;\n    for(float t = MIN_DIST; t < MAX_DIST;) {\n        vec3 lightVector = pos + lightPos*t;\n        float h = heightMap(lightVector.xz);\n        if(h < 0.001) return 0.0;\n        float y = h*h/(2.*ph);\n        float dist = sqrt(h*h-y*y);\n        res = min(res, k*dist/max(0.,t-y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 computeLighting(vec3 pos, vec3 normal) {\n    vec3 sun = vec3(500., 100., 40.);\n    //vec3 lightVal = normalize(lightPos - pos);\n    \n    vec3 lightVal = normalize(sun);\n    float l = clamp(dot(normal, lightVal), 0., 1.);\n    //float l = computeSoftShadows(pos, lightVal);\n    \n    vec3 lightColor = vec3(l, l, l);\n    vec3 ambient = vec3(0.7, 0.9, 1.0)/2.;\n    lightColor = clamp(lightColor + ambient, 0., 1.);\n    \n    \n    \n    return lightColor * GAMMA;\n}\n\n\n\nvec3 computeTerrainColor(vec3 rayOrigin, vec3 rayDir, float dist) { \n    vec3 c = vec3(0);\n    vec3 fog = vec3(dist/75.);\n    //c = vec3(0., 0.5, 1.);\n    vec3 pos = rayOrigin + rayDir*dist;\n    vec3 normal = computeNormal(pos);\n    \n    vec3 lightIntensity = computeLighting(pos, normal);\n    \n    vec3 grass = vec3(0.1, 1.0, 0.1);\n    vec3 dirt = vec3(0.44, 0.31, 0.22);\n    vec3 snow = vec3(1);\n    vec3 water = vec3(0.2, 0.5, 1.0);\n    vec3 waterBorder = vec3(0.0, 0.8, 1.0);\n    \n    vec3 surfaceCol = grass;\n    //surfaceCol = texture(iChannel0, 0.5*pos.xz).xyz*0.5*vec3(1);\n    //surfaceCol = vec3(incX, incY, incZ);\n    surfaceCol = mix(surfaceCol, dirt, min(pos.y/1.5-0.3 + 0.7, 1.));\n    if(pos.y >= -0.002 && pos.y <= 0.01) surfaceCol = water;\n    //if(pos.y >= 0.001 && pos.y <= 0.012) surfaceCol = waterBorder;\n    surfaceCol = mix(surfaceCol, snow, clamp(pos.y*2.-2.5, 0., 1.));\n    //}\n    \n    \n    \n    c = surfaceCol * lightIntensity;\n    \n    \n    c = mix(c, fog, 0.5);\n    return c;\n\n}\n\nvec3 computeSkyColor(vec2 fragCoord) {\n   vec2 gradient = fragCoord.xy / iResolution.xy;\n   vec3 skyCol = vec3(-gradient.y+1.3, -gradient.y+1.5, 1.); \n\n\n\n   return skyCol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy -0.5*iResolution.xy) / (iResolution.y);\n    //uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    //vec3 col = vec3(abs(uv.x), abs(uv.y), 0);\n    \n    vec3 col = vec3(0);\n    \n    vec3 rayOrigin = vec3(0, 2.50, -iTime);\n    vec3 lookAt = vec3(0,2.4,-iTime - 1.);\n    vec3 rayDir = normalize(cameraMatrix(rayOrigin, lookAt, sin(iTime/3.)/10.) * vec3(uv.xy, 1.));\n    //rayDir = normalize(vec3(uv.xy, 1));\n    float d = 0.;\n    if(rayMarch(rayOrigin, rayDir, d)) {\n        col = computeTerrainColor(rayOrigin, rayDir, d);\n    } else {\n        col = computeSkyColor(fragCoord);\n    }\n\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}