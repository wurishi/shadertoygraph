{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Ray marching constants\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n#define MANDELBULB_ITERATIONS 8\n#define MANDELBULB_POWER 8.0\n\n// Distance field functions\nfloat mandelbulbSDF(vec3 pos) {\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    float power = MANDELBULB_POWER * (1.0 + 0.2 * sin(iTime * 0.5));\n    \n    for (int i = 0; i < MANDELBULB_ITERATIONS; i++) {\n        r = length(z);\n        if (r > 2.0) break;\n        \n        // Convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi = atan(z.y,z.x);\n        dr = pow(r, power-1.0)*power*dr + 1.0;\n        \n        // Scale and rotate\n        float zr = pow(r,power);\n        theta = theta*power;\n        phi = phi*power;\n        \n        // Convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z += pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = mandelbulbSDF(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n// Calculate normal\nvec3 getNormal(vec3 p) {\n    float d = mandelbulbSDF(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        mandelbulbSDF(p-e.xyy),\n        mandelbulbSDF(p-e.yxy),\n        mandelbulbSDF(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Camera setup\n    vec3 ro = vec3(3.0*sin(iTime*0.5), 2.0*cos(iTime*0.3), 3.0*cos(iTime*0.4)); // Camera position\n    vec3 ta = vec3(0.0); // Look at point\n    \n    // Camera matrix\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    // Ray marching\n    float d = rayMarch(ro,rd);\n    vec3 p = ro + rd * d;\n    vec3 n = getNormal(p);\n    \n    // Lighting\n    vec3 col = vec3(0.0);\n    \n    if(d < MAX_DIST) {\n        // Basic lighting\n        vec3 lightPos = vec3(2.0*sin(iTime), 4.0, 2.0*cos(iTime));\n        vec3 l = normalize(lightPos-p);\n        vec3 h = normalize(l - rd);    \n        \n        // Colors based on normal and position\n        vec3 baseColor = 0.5 + 0.5*cos(iTime + p.xyx + vec3(0,2,4));\n        \n        // Diffuse\n        float diff = max(dot(n,l), 0.0);\n        // Specular\n        float spec = pow(max(dot(n,h), 0.0), 32.0);\n        // Fresnel\n        float fres = pow(1.0 + dot(n,rd), 2.0);\n        \n        // Combine lighting\n        col = baseColor * diff + spec * vec3(1) + fres * vec3(0.2,0.5,1.0);\n        \n        // Add ambient occlusion\n        float ao = 1.0;\n        for(int i=0; i<5; i++) {\n            float dist = float(i) * 0.1;\n            ao -= (dist - mandelbulbSDF(p + n * dist)) * 0.2;\n        }\n        col *= ao;\n    }\n    \n    // Fog\n    col = mix(col, vec3(0.1,0.2,0.3), 1.0-exp(-0.02*d));\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MfyBDd","date":"1734574528","viewed":65,"name":"Sigma Shader","username":"sozalp","description":"super cool","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["epic","cool","awesome","sick","fortnite"],"hasliked":0,"parentid":"","parentname":""}}