{"ver":"0.1","info":{"id":"4t3Bz7","date":"1538964905","viewed":235,"name":"deep-sea-life","username":"teraspora","description":"A bunch of sine waves dancing under the sea.   Click in th right half  for more symmetry. Watch for 2 minutes at least!    Full-screen! :)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["slow","flowing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653588\n//#define f fragCoord.xy\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\n// =======================================\n\n\n\nfloat scale = 0.4;\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    float asp = iResolution.x/iResolution.y;\n    // Normalized pixel coordinates (y from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y - vec2(0.5 * asp, 0.5)) / scale;\n\tuv = rotate(uv, PI * 0.5);\n    \n    uv.y = abs(uv.y);\n    if (nmouse().x >= 0.5) uv.x = abs(uv.x);\n    float c = mod(t, 128.) - 104.;\n    if (c > 0.) uv = rotate(uv, c * PI / 12.);\n    float a = 5.;\n    float b = 8.;\n    uv.x += 0.1 * cos(a * uv.y + b * uv.x);\n    col = crimson;\n    \n\n    \n    float d = 1.0;\n    col *= step(uv.y, f(uv.x)) - step(uv.y + d, f(uv.x));\n    if (col != black && mod(length(uv), 0.1) > 0.05) {\n        col = invert(col);\n        col.g *= nsin(t / 6.);\n    }\n    col.r *= nsin(iTime * 0.015625);    \n        \n    if (col == black) {\n        col = 0.2 * nsin(iTime * 0.03125) * sin(iTime * 0.425 + length(uv) + vec3(0.,2.,4.));\n    \t}\n    \n    // Border code:    \n    // ============    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tcol = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}