{"ver":"0.1","info":{"id":"sdBcWm","date":"1715108809","viewed":62,"name":"Diffraction - Attempt 4","username":"swr06","description":"bee","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["rays"],"hasliked":0,"parentid":"fsjcWD","parentname":"Diffraction Spikes - Attempt 3"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat3 ACESInputMat = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nmat3 ACESOutputMat = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108, 1.10813, -0.07276,\n    -0.07367, -0.00605, 1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec4 ACESFitted(vec4 Color, float Exposure)\n{\n    Color.rgb *= Exposure;\n    Color.rgb = ACESInputMat * Color.rgb;\n    Color.rgb = RRTAndODTFit(Color.rgb);\n    Color.rgb = ACESOutputMat * Color.rgb;\n    return Color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // these can be changed :\n    const int Blades = 6;\n    int Steps = 32;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texturesize = vec2(textureSize(iChannel0,0)); \n    vec2 TexelSize = 1.0 / texturesize; \n    vec4 finalColor = vec4(0.); \n    finalColor.xyz = texture(iChannel0, uv).xyz;\n\n    float Rotation = radians(40.) + radians(iTime * 10.0f);\n    float AngleStep = radians(360.0f / float(Blades));\n    float CurrentAngle = AngleStep + Rotation;\n    float AspectCorrect = iResolution.x/iResolution.y;\n    float TotalWeight = 0.0001f;\n    vec3 Total = vec3(0.0f);\n    \n    float Dither = bayer32(fragCoord.xy);;\n    Dither = mix(Dither, 1.0f, 0.8f);\n    \n    vec2 Directions[Blades];\n    \n    // Generate directions (this can be precomputed) \n    \n    for (int b = 0 ; b < Blades ; b++) {\n        Directions[b] = vec2(sin(CurrentAngle), cos(CurrentAngle));\n        CurrentAngle += AngleStep;\n    }\n    \n    \n    float Hash = bayer16(fragCoord.xy);\n    Hash = mix(Hash, 1.0f, 0.7f);\n    \n    for(int x = -Steps; x < Steps; x++) \n    {\n        if(x == 0)\n            x = 1; \n           \n        \n        float StepSize = 32.;//mix(4., 16., clamp(NormalizedStepCount, 0.0f, 1.0f)); //16.0f;\n        \n        float CurrentStep = float(x) * StepSize * Hash;\n\n        float Distance = abs(float(x) * Hash * (float(x) / 2.75f)) / 10.0f; \n\n        for(int Offset = 0; Offset < Blades; Offset++) \n        {\n            Total += texture(iChannel0, \n                          uv + (Directions[Offset] * vec2(CurrentStep)) * TexelSize).xyz * (1.0f / Distance); \n        }\n        \n\n    }\n    \n    finalColor.xyz += Total * 0.07f;\n    finalColor.w = 1.0f;\n\tfragColor = ACESFitted(finalColor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Sajid's code form modules:\n//None of the code bleow belongs to me\n\n//Ray-Sphere function borrowed from https://www.shadertoy.com/view/ldS3DW\nfloat sphereIntersect(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n vec3 rc = ray-center;\n float c = dot(rc, rc) - (radius*radius);\n float b = dot(dir, rc);\n float d = b*b - c;\n float t = -b - sqrt(abs(d));\n float st = step(0.0, min(t,d));\n return mix(-1.0, t, st);\n}\n\n\n//-------------\n//All units are in mm\nvec3 SphereCenter = vec3(0.0,0.0,10.0);\n\n\nvec3 CameraCenter = vec3(0.0,0.0, -3.0);\nfloat imagePlaneDist = 1.0;\n\nvec3 lightPos = vec3(10.0, 5.0, -1.0);\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n // Normalized pixel coordinates (from 0 to 1)\n vec2 uv = fragCoord/iResolution.xy;\n \n //Center from -1 to 1\n uv = (uv * 2.0) - 1.0;\n \n //fix aspect ratio\n uv.x *= iResolution.x / iResolution.y;\n \n //Ray starts at camera center\n vec3 rayOrigin = CameraCenter;\n \n\n float SphereRadius = mix(4.5f, 6.0f, sin(iTime));\n\n //Ray moves towards current pixel on image plane\n vec3 imagePlanePixel = vec3(uv.x,uv.y,CameraCenter.z + imagePlaneDist);\n \n //Calculate ray\n vec3 rayDirection = normalize(imagePlanePixel - rayOrigin);\n \n \n\n//Intersect ray with sphere\n float t = sphereIntersect(rayOrigin, rayDirection, SphereCenter, SphereRadius);\n \n //hitpoint\n vec3 hitPoint = rayOrigin + rayDirection * t;\n\nt = clamp(t, 0.0, 1.0);\n\n//Sphere normal is a vector pointing outward from center, to intersection point\nvec3 normal = normalize(hitPoint - SphereCenter);\n//vec3 normal = normalize(SphereCenter - hitPoint);\n\n//The percentage this point is looking towards the light (lamberts law)\nfloat lightLambert = max(dot(normal, normalize(lightPos - hitPoint)) , 0.0); \n\n\n// Output to screen\nvec3 sphereColor =   vec3(30.0, 12.0, 2.0) * 0.05;\n\nfragColor = vec4(sphereColor * t, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float Kernels[19] = float[](\n\n0.00001,\t\n\n    0.000078\t,\n    0.000489\t,\n    0.002403\t,\n    0.009245\t,\n    0.027835\t,\n    0.065591\t,\n    0.120978\t,\n    0.174667\t,\n    0.197413\t,\n    0.174667\t,\n    0.120978\t,\n    0.065591\t,\n    0.027835\t,\n    0.009245\t,\n    0.002403\t,\n    0.000489\t,\n    0.000078\t,\n    0.00001\n\n   );\n\nvec4 Gaussian(sampler2D t,vec2 tc) {\nvec2 t_size = 1.0/vec2(textureSize(t,0)); \nvec4 Final = vec4(0.); \n    for(int x=-4;x<4;x++) {\n    \tFinal += texture(t,vec2(tc.x,tc.y+t_size.y*float(x*3))) * Kernels[x+9]; \n    }\nreturn Final; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = Gaussian(iChannel0,uv); \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float Kernels[19] = float[](\n\n0.00001,\t\n\n    0.000078\t,\n    0.000489\t,\n    0.002403\t,\n    0.009245\t,\n    0.027835\t,\n    0.065591\t,\n    0.120978\t,\n    0.174667\t,\n    0.197413\t,\n    0.174667\t,\n    0.120978\t,\n    0.065591\t,\n    0.027835\t,\n    0.009245\t,\n    0.002403\t,\n    0.000489\t,\n    0.000078\t,\n    0.00001\n   );\n\n\nvec4 Gaussian(sampler2D t,vec2 tc) {\nvec2 t_size = 1.0/vec2(textureSize(t,0)); \nvec4 Final = vec4(0.); \n    for(int x=-4;x<4;x++) {\n    \tFinal += texture(t,vec2(tc.x+t_size.x*float(x*3),tc.y)) * Kernels[x+9]; \n    }\nreturn Final; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = Gaussian(iChannel0,uv); \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float bayer2(vec2 a){\n    a = floor(a);\n    return fract(dot(a, vec2(0.5, a.y * 0.75)));\n}\n#define bayer4(a)   (bayer2(  0.5 * (a)) * 0.25 + bayer2(a))\n#define bayer8(a)   (bayer4(  0.5 * (a)) * 0.25 + bayer2(a))\n#define bayer16(a)  (bayer8(  0.5 * (a)) * 0.25 + bayer2(a))\n#define bayer32(a)  (bayer16( 0.5 * (a)) * 0.25 + bayer2(a))\n#define bayer64(a)  (bayer32( 0.5 * (a)) * 0.25 + bayer2(a))\n#define bayer128(a) (bayer64( 0.5 * (a)) * 0.25 + bayer2(a))\n#define bayer256(a) (bayer128(0.5 * (a)) * 0.25 + bayer2(a))","name":"Common","description":"","type":"common"}]}