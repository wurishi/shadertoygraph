{"ver":"0.1","info":{"id":"dsG3Wd","date":"1679206282","viewed":130,"name":"Protogen Face V3","username":"coburn","description":"Version 3 of protogen face. Needed to be GLSL ES v1.0 compatible and much faster due to target platform (Raspberry Pi 1 B+). Smiles and blinks now","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["video","animation","furry","protogen"],"hasliked":0,"parentid":"dtsGz2","parentname":"Protogen Face v2"},"renderpass":[{"inputs":[],"outputs":[],"code":"// Trying to emulate: https://www.youtube.com/watch?v=lpbvKUYoOUQ\n// Inspired by: https://www.shadertoy.com/view/lt2SDK\n\n#define MAIN_BLOOM_ITERATIONS 3\n#define MAIN_BLOOM_SIZE 0.005\n\n#define PHOSPHOR_COL vec4(0.35, 0.55, 1.0, 0.0)\n#define PI 3.141592\n\nprecision highp float;\n\nfloat rand(float s){\n    return fract(sin(s * 12.9898 ) * 43758.5453);\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float r) {\n\tp -= a;\n\tb -= a;\n\tfloat d = length(p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n\treturn d - r;\n}\nfloat sdCircle(vec2 p, vec2 center, float radius) {\n    return length(center - p) - radius; // inside is negative\n}\n\n// sdf for protogen face combining lines and circles\nfloat sdProtogen(vec2 uv, vec2 res) {\n    vec2 uv2 = uv;\n    // aspect correction\n    uv2.y = uv.y * (res.y / res.x);\n\n    float smileTween = sin(iTime)+sin(3.0*iTime)/3.0+sin(5.0*iTime)/5.0+sin(7.0*iTime)/7.0+sin(9.0*iTime)/9.0;//clamp(4.0*(sin(2.0*iTime) + 1.0) / 2.0, 0.0, 1.0);\n    float blinkTween = mod(iTime, 10.0) > 9.9\n        ? -abs(sin(4.0*2.0*PI*iTime + PI/2.0))+1.0\n        : 0.0;\n\n    float eyeInside = sdCircle(uv2, vec2(0.16, 0.39), 0.14);\n    float eyeLid = sdCircle(uv2, vec2(0.06, 0.17), 0.3);\n    float eyeIdle = max(-eyeLid, eyeInside); //combine via subtracting lid from inside\n    \n    float eyeSmileInside = sdCircle(uv2, vec2(0.16, 0.39), 0.14);\n    float eyeSmileLid = sdCircle(uv2, vec2(0.08, 0.19), 0.3);\n    float eyeSmile = max(-eyeSmileLid, eyeSmileInside); //combine via subtracting lid from inside\n    \n    float eyeBlinkInside = sdCircle(uv2, vec2(0.16, 0.39), 0.01);\n    float eyeBlinkLid = sdCircle(uv2, vec2(0.08, 0.19), 0.3);\n    float eyeBlink = max(-eyeBlinkLid, eyeBlinkInside); //combine via subtracting lid from inside\n    \n    float eye = mix(mix(eyeSmile, eyeIdle, smileTween), eyeBlink, blinkTween);\n    \n    float mouth0 = sdLine(uv2,  vec2(0.15,0.23),  vec2(0.22,0.19),  0.03);\n    float mouth1 = sdLine(uv2,  vec2(0.22,0.19),  vec2(0.50,0.15),  0.03);\n    float mouth2 = sdLine(uv2,  vec2(0.50,0.15),  vec2(0.55,0.13),  0.03);\n    float mouth3 = sdLine(uv2,  vec2(0.55,0.13),  vec2(0.62,0.07),  0.03);\n    float mouth4 = sdLine(uv2,  vec2(0.62,0.07),  vec2(0.68,0.12),  0.03);\n    float mouth5 = sdLine(uv2,  vec2(0.68,0.12),  vec2(0.76,0.14),  0.03);\n    float mouth6 = sdLine(uv2,  vec2(0.76,0.14),  vec2(0.81,0.13),  0.03);\n    float mouth7 = sdLine(uv2,  vec2(0.81,0.13),  vec2(0.87,0.11),  0.03);\n    float mouth8 = sdLine(uv2,  vec2(0.87,0.11),  vec2(0.92,0.07),  0.03);\n    float mouth9 = sdLine(uv2,  vec2(0.92,0.07),  vec2(0.97,0.11), 0.03);\n    float mouth10 = sdLine(uv2, vec2(0.97,0.11), vec2(1.01,0.12),  0.03);\n    float mouthIdle = min(min(min(min(min(min(min(min(min(min(mouth0, mouth1), mouth2),\n    mouth3), mouth4), mouth5), mouth6), mouth7), mouth8), mouth9), mouth10);\n    \n    float smile0 = sdLine(uv2,  vec2(0.15,0.27),  vec2(0.22,0.22),  0.03);\n    float smile1 = sdLine(uv2,  vec2(0.22,0.22),  vec2(0.50,0.16),  0.03);\n    float smile2 = sdLine(uv2,  vec2(0.50,0.16),  vec2(0.55,0.14),  0.03);\n    float smile3 = sdLine(uv2,  vec2(0.55,0.14),  vec2(0.62,0.09),  0.03);\n    float smile4 = sdLine(uv2,  vec2(0.62,0.09),  vec2(0.68,0.13),  0.03);\n    float smile5 = sdLine(uv2,  vec2(0.68,0.13),  vec2(0.76,0.145),  0.03);\n    float smile6 = sdLine(uv2,  vec2(0.76,0.145),  vec2(0.81,0.135),  0.03);\n    float smile7 = sdLine(uv2,  vec2(0.81,0.135),  vec2(0.87,0.11),  0.03);\n    float smile8 = sdLine(uv2,  vec2(0.87,0.11),  vec2(0.92,0.09),  0.03);\n    float smile9 = sdLine(uv2,  vec2(0.92,0.09),  vec2(0.97,0.11), 0.03);\n    float smile10 = sdLine(uv2, vec2(0.97,0.11), vec2(1.01,0.12),  0.03);\n    float smile = min(min(min(min(min(min(min(min(min(min(smile0, smile1), smile2),\n    smile3), smile4), smile5), smile6), smile7), smile8), smile9), smile10);\n    \n    float mouth = mix(smile, mouthIdle, smileTween);\n    \n    float noseInside = sdCircle(uv2, vec2(0.89, 0.37), 0.05);\n    float noseOut = sdCircle(uv2, vec2(0.86, 0.32), 0.07);\n    float nose = max(-noseOut, noseInside);\n\n    return min(min(nose, mouth), eye) - 0.005; // slightly grow the entire shape\n}\n\nvec4 ledFilter(float t, vec2 uv, vec2 res) {\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Create an LED matrix-like grid of circles\n    // Pixelated grid of cells\n    vec2 count = vec2(128.0 / 2.0, 75.0 / 2.0);\n    vec2 uvPixel = ceil(uv * count) / count; // Global rounded UV of each cell\n    vec2 uvInsidePixel = mod(uv * count, 1.0); // [0,1] UV in each cell\n        \n    // Variable circle radius based on sampled pixel brightness\n    // add shimmer to make it feel \"animated\" without the expense of\n    // anything _actually_ animated (due to GPU restrictions)\n    float offset = uvPixel.y + uvPixel.x * count.x;\n    float noise = rand(offset);\n    float shimmerPhase = noise * 6.28;\n    float shimmerTheta = t * 6.28 * noise * 40.0;\n    float shimmer = sin(shimmerTheta + shimmerPhase) * noise;\n    \n    float d = sdProtogen(uvPixel, res);\n    float d2 = min(d, d - shimmer * 0.002); // add noise to edges\n    float lum = clamp(d2 * -100.0, 0.0, 1.0); // change d to a smooth gradient along edge [0,1]\n    \n    float radius = mix(0.0, 0.37, lum);\n    float dPixel = sdCircle(uvInsidePixel, vec2(0.5, 0.5), radius);\n    //float v = float(dPixel < 0.0);\n    \n    vec4 pxColor = PHOSPHOR_COL * lum; // circle brightness adjust by lum\n    // Fake bloom the effect instead of an actual postprocess bloom\n    // due to multiple calls to ledFilter too slow + register allocation failure\n    float bloomFalloff = mix(0.0, 1.0, clamp(dPixel * 4.0 * -1.0 + 0.5, 0.0, 1.0));\n    c += bloomFalloff * 2.0 * pxColor;\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    float t = mod(iTime, 1000.0);\n    \n    c = ledFilter(t, uv, iResolution.xy);\n    //float v = float(sdProtogen(uv, iResolution.xy) < 0.0);\n    //c = vec4(v, v , v, v);\n    \n    fragColor = c;\n}","name":"Image","description":"","type":"image"}]}