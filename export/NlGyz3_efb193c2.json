{"ver":"0.1","info":{"id":"NlGyz3","date":"1661874837","viewed":290,"name":"roundEven","username":"FabriceNeyret2","description":"do you see something else than plain white ?\nIf yes, please tell your GPU and OS ! \n\nSee code header for problem description.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["test","glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Indeed, the page https://registry.khronos.org/OpenGL-Refpages/gl4/html/roundEven.xhtml\n// is confusing, or even wrong.\n// A way clearer definition is there: https://blogs.sas.com/content/iml/2019/11/11/round-to-even.html\n// In short: roundEven = round  BUT for integer+0.5 . Then, parity decide. Purpose: avoid statistical bias.\n\n// still, at least on OpenGL+nVIDIA roundEven doesn't seem to work. [EDIT]: wrong: it's round that always do roundEven !\n// But it is indeed let implementation choice: https://registry.khronos.org/OpenGL-Refpages/gl4/html/round.xhtml\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (U.y > iResolution.y/2.) U = floor(U);   // then, roundEven(U) == round(U) is expected.\n                                                // but not in the other case ( bottom window ).\n    O = vec4( roundEven(U) == round(U) );\n // O = vec4( round(U) == floor(U+.5) );        // indeed, the anomaly is round, not roundEven\n\n}","name":"Image","description":"","type":"image"}]}