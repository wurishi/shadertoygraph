{"ver":"0.1","info":{"id":"XtGyWc","date":"1537934414","viewed":161,"name":"Warp distortion","username":"cacheflowe","description":"Warping correction attempt for projections... Probably not very good.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wrap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n\nfloat map(float value, float low1, float high1, float low2, float high2) {\n   return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat sineIn(float t) {\n  return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n\nfloat sineOut(float t) {\n  return sin(t * HALF_PI);\n}\n\nfloat quadraticIn(float t) {\n  return t * t;\n}\n\nfloat quadraticOut(float t) {\n  return -t * (t - 2.0);\n}\n\nfloat gain(float x, float k) {\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvOrig = fragCoord/iResolution.xy;\n    \n    float controlX = 0.5 + 0.2 * sin(iTime);//iMouse.x;\n    \n    float distToControl = distance(controlX, uv.x);\n    distToControl *= 2.25;\n    distToControl = clamp(distToControl, 0., 1.);\n    distToControl = 1. - distToControl;\n    \n    \n    // calculate easing curve\n    // try sineInOut\n    float gainCurve = 1.2;\n    float curveLeft = gain( map(uv.x, 0.,controlX, 0., 1.), gainCurve );\n    float curveRight = gain( map(uv.x, controlX, 1., 0., 1.), gainCurve );\n\tfloat curveAmp = (uv.x < controlX) ? curveLeft : curveRight + 1.;\n    \n    // uv.x = mix(uv.x, curveAmp, 0.5);\n    uv.x = mix(uv.x, curveAmp / 2., 0.15);\n    \n    // display warped texture\n    fragColor = texture(iChannel0, uv);\n    \n    //////////////////////////////////////////\n    // debug\n    // black line\n    if(uv.y < 0.455) {\n    \tfragColor = vec4(0., 0., 0., 1.);\n    }\n    // original texture\n    if(uv.y < 0.45) {\n    \tfragColor = texture(iChannel0, uvOrig);\n    }\n    // black line\n    if(uv.y < 0.155) {\n    \tfragColor = vec4(0., 0., 0., 1.);\n    }\n    // show curve gradient\n    if(uv.y < 0.15) {\n      curveAmp = (uvOrig.x < controlX) ? curveLeft : 1.- curveRight;\n      fragColor = vec4(vec3(curveAmp), 1.);\n    }\n    // distance to controlX\n    if(uv.y < 0.1) {\n      fragColor = vec4(distToControl, distToControl, distToControl, 1.);\n    }\n    // controlX center\n    if(uv.y < 0.05) {\n      float direction = sign(controlX - uvOrig.x);\n      fragColor = vec4(vec3(direction), 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}