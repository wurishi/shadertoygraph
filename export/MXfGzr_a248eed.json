{"ver":"0.1","info":{"id":"MXfGzr","date":"1707064517","viewed":138,"name":"Circle Tangents via Inversion","username":"chronos","description":"Diagram demonstrating an easy way to find the tangent lines to a sphere through a point.\nIt works by simply finding the circle inversion Q' of the query point Q, and then applying pythagoras in the orthogonal direction.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["2d","sphere","intersection","circle","disc","tangent","diagram"],"hasliked":0,"parentid":"mlcfRr","parentname":"Ray Sphere Intersection Diagram"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Circle Tangents via Inversion by chronos\n\n    Diagram demonstrating an easy way to find the tangent lines to a sphere through a point.\n    It works by simply finding the circle inversion Q' of the query point Q, and then applying pythagoras in the orthogonal direction.\n    \n    The same method can be used to find the tangent cone, and corresponding intersection circle, in 3D.\n    \n    I just happened to stumble upon this method while working out a more complicated method for this using arguments based on\n    orthogonality, distances and solving quadratic equations.\n\n    This is of course well known, but not to me! So it may be new to many others :)\n    After discovering this, I of course went to wikipedia (https://en.wikipedia.org/wiki/Tangent_lines_to_circles)\n    to find out that it mentions circle inversions and inversive geometry a lot, apparently this method generalizes!\n    \n    -------------------------------------\n    Method:\n    -------------------------------------\n    \n    For a query point Q\n    Find the intersection points P of the tangent lines to a circle through Q\n    \n    1. Compute the circle inversion Q' of Q wrt the circle of radius R\n    \n    Q' = Q * ( R^2 / ||Q||^2 )                  ( ||Q||^2   is the same as :  dot(Q,Q)  )\n    \n    2. Find the squared \"cosine\", i.e distance of Q' from the center:\n    \n    c^2 = ||Q'||^2\n    \n    3. Use Pythagoras to find the squard \"sine\", i.e 'height' of the points on the circle which intersec the line through Q' \n    \n    s^2 = R*R - c^2\n    \n    4. Find the orthogonal (normal N) direction by normalizing and rotating Q by 90 degrees:\n    \n    N = (-Q.y, Q.x) / ||Q||                    (||Q|| is the same as:    length(Q)\n    \n    4. find the intersection points P:\n    \n    P = Q' + sqrt(s^2) * N\n    and\n    P = Q' - sqrt(s^2) * N\n    \n    -------------------------------------\n\n*/\n\nfloat char(vec2 uv, vec2 position, float size, int ascii_code)\n{\n    uv = (uv-position) / (size*percent);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., min(min(uv.x, 1.-uv.x), min(uv.y, 1.-uv.y)));\n    return texelFetch(iChannel0, ij, 0).r * mask;\n}\n\nfloat char_shadow(vec2 uv, vec2 position, float size, int ascii_code, float shadow_offset, float shadow_blur)\n{\n    uv = (uv-(position+vec2(shadow_offset,-shadow_offset))) / (size*percent);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., min(min(uv.x, 1.-uv.x), min(uv.y, 1.-uv.y)));\n    float d = texelFetch(iChannel0, ij, 0).a;\n    float f = smoothstep(0.5+shadow_blur,0.5-shadow_blur, d); \n    return f * mask;\n}\n\nfloat linesegdist(vec2 a, vec2 b, vec2 p)\n{\n    b -= a; p -= a;\n    return length(p - clamp(dot(p,b)/dot(b,b), 0., 1.) * b); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv_text = uv;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    mat2 rot = mat2(1);\n\n    if(length(iMouse.xy) < 10.)\n        mouse = vec2(cos(iTime) * 0.44, sin(iTime) * .4) + vec2(1., 0.);\n \n    vec3 bg_color = vec3(0.2, 0.30, 0.5);\n    vec3 color = bg_color;\n\n    // Used for aliasing / smoothing\n    float pix_size = 2./iResolution.y;\n    float rpix_size = 1./pix_size;\n    \n    float r = 0.75;     // circle radius\n    \n    vec2 circle_inverse_q = mouse * r*r / dot(mouse, mouse);     // This is the circle inversion!\n    \n    // Swap if Q is inside circle\n    if(length(circle_inverse_q) > length(mouse))\n    {\n        vec2 tmp = circle_inverse_q;\n        circle_inverse_q = mouse;\n        mouse = tmp;\n    }\n    \n    float h = length(circle_inverse_q);  // height ( 's' in the description )\n    \n    // we know y, which is equal to the height h, so we only need to find the two x values\n    // Use Pythagoras\n    // ('x' is 's' in the description)\n    \n    float x = sqrt(r*r - h*h); // intersection points are plus/minus x\n    \n    vec2 p0 = circle_inverse_q + x * normalize(vec2(-1,1)*mouse.yx);\n    vec2 p1 = circle_inverse_q - x * normalize(vec2(-1,1)*mouse.yx);\n    \n    // This is the solution the rest is just drawing the diagram.\n    \n    \n    \n    \n    \n    // ------------------------------------------------------------------------------------\n    // ------------------------------------------------------------------------------------\n    \n    \n    float d, a; // distance & alpha\n        \n    // Draw circle\n    d = length(uv)-r;\n    a = smoothstep(2., 1., abs(d)*rpix_size);\n    a *= .9;\n    color = mix(color, vec3(1,1,1), a);\n    \n    // Draw offset distance from center\n    d = linesegdist(vec2(0), circle_inverse_q, uv);\n    a  = smoothstep(pix_size, 0., abs(d));\n    color = mix(color, vec3(0, 1, 0), a);\n            \n    // Draw circle center\n    d = length(uv);\n    a = smoothstep(point_radius+pix_size, point_radius, d);\n    color = mix(color, vec3(1), a);\n    \n    // Draw first tangent line\n    d = linesegdist(p0, mouse, uv);\n    a = smoothstep(1.5, 0.75, abs(d)*rpix_size);\n    a *= .5;\n    color = mix(color, vec3(1), a);\n    \n    // Draw second tangent line\n    d = linesegdist(p1, mouse, uv);\n    a = smoothstep(1.5, 0.75, abs(d)*rpix_size);\n    a *= .5;\n    color = mix(color, vec3(1), a);\n    \n    // Draw segment from Q inv to Q\n    d = linesegdist(circle_inverse_q, mouse, uv);\n    a = smoothstep(1.5, 0.75, abs(d)*rpix_size);\n    a *= .125;\n    color = mix(color, vec3(1), a);\n    \n    // Draw segment from center P0\n    d = linesegdist(vec2(0), p0, uv);\n    a = smoothstep(1.5, 0.75, abs(d)*rpix_size);\n    a *= .125;\n    color = mix(color, vec3(1), a);\n    \n    // Draw segment from center P1\n    d = linesegdist(vec2(0), p1, uv);\n    a = smoothstep(1.5, 0.75, abs(d)*rpix_size);\n    a *= .125;\n    color = mix(color, vec3(1), a);\n    \n    // Draw intersection points\n        // Draw colored ray segment in interior\n        d = linesegdist(p0, p1, uv);\n        a = smoothstep(pix_size, 0., d); // vertical slab with thickness 2x centered on origin\n        color = mix(color, vec3(0,1,0), a);\n\n        // Draw first intersection\n        d = distance(uv, p0);\n        a = smoothstep(point_radius+pix_size, point_radius, d);\n        color = mix(color, vec3(1), a);\n        \n        // Draw second intersection\n        d = distance(uv, p1);\n        a = smoothstep(point_radius+pix_size, point_radius, d);\n        color = mix(color, vec3(1), a);\n    ///////////\n\n    // Draw query point (mouse)\n    d = distance(uv, mouse);\n    a = smoothstep(point_radius+pix_size, point_radius, d);\n    color = mix(color, vec3(1), a);\n    \n    // Draw circle inversion of query point    \n    d = distance(uv, circle_inverse_q);\n    a = smoothstep(point_radius+pix_size, point_radius, d);\n    color = mix(color, vec3(1), a);\n\n    // Draw diagram annotations\n    \n    const float shadow_alpha = 40.*percent;\n    \n    float charP0 = char(uv_text, p0, 10., ascii_P);\n    float charP0_shadow = shadow_alpha*char_shadow(uv_text, p0, 10., ascii_P, .3*percent, 5.*percent);\n    \n    float charP1 = char(uv_text, p1, 10., ascii_P);\n    float charP1_shadow = shadow_alpha*char_shadow(uv_text,p1, 10., ascii_P, .3*percent, 5.*percent);\n    \n    float charQ0 = char(uv_text, mouse, 10., ascii_Q);\n    float charQ0_shadow = shadow_alpha*char_shadow(uv_text,mouse, 10., ascii_Q, .3*percent, 5.*percent);\n    \n    float charQ1 = char(uv_text, circle_inverse_q, 10., ascii_Q);\n    float charQ1_shadow = shadow_alpha*char_shadow(uv_text,circle_inverse_q, 10., ascii_Q, .3*percent, 5.*percent);\n    \n    float charQ1_apo = char(uv_text - vec2(3.*percent, 0), circle_inverse_q, 10., ascii_apostrophe);\n    float charQ1_apo_shadow = shadow_alpha*char_shadow(uv_text-vec2(3.*percent, 0),circle_inverse_q, 10., ascii_apostrophe, .3*percent, 5.*percent);\n    \n    color = mix(color, vec3(0), charP0_shadow);\n    color = mix(color, vec3(1), charP0);\n    \n    color = mix(color, vec3(0), charP1_shadow);\n    color = mix(color, vec3(1), charP1);\n    \n    color = mix(color, vec3(0), charQ0_shadow);\n    color = mix(color, vec3(1), charQ0);\n    \n    color = mix(color, vec3(0), charQ1_shadow);\n    color = mix(color, vec3(1), charQ1);\n    \n    color = mix(color, vec3(0), charQ1_apo_shadow);\n    color = mix(color, vec3(1), charQ1_apo);\n    \n    color = sRGBencode(color);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nconst float percent = .01;\nconst float line_width = 1. * percent;\nconst float point_radius = 2. * percent;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nivec2 ascii_to_index(int ascii_code)\n{\n    const int row_len = 16;\n    const int glyph_size = 64;\n    int y = ascii_code / 16;\n    int x = ascii_code - y * 16;\n    return ivec2(x,y+1);\n}\n\nivec2 index_to_offset(ivec2 index)\n{\n    return ivec2(index.x * 64, 1024 - index.y * 64);\n}\n\nivec2 ascii_to_offset(int ascii_code)\n{\n    return index_to_offset(ascii_to_index(ascii_code));\n}\n\n/*\nfloat character(vec2 uv, vec2 position, float size, int ascii_code, int text_index)\n{\n    //float pixel_size = 1. / iResolution.y;\n    const float percent = .01;\n    uv = (uv-position) / (size*percent) - vec2(text_index, 0)*.5;//(size * pixel_size);\n    ivec2 ij = ivec2(uv * 64.) + ascii_to_offset(ascii_code);\n    float mask = step(0., uv.x) * step(0., 1.-uv.x) * step(0., uv.y) * step(0., 1.-uv.y);\n    return texelFetch(iChannel0, ij, 0).r * mask;\n}\n*/\n\n\n/*\n    \n    \"ASCII\" CODE TABLES FOR character() FUNCTION\n\n*/\n#define ascii_arrow_left 16\n#define ascii_arrow_up 17\n#define ascii_arrow_right 18\n#define ascii_arrow_down 19\n\n#define ascii_arrow_left_right 20\n#define ascii_arrow_up_down 21\n#define ascii_arrow_up_left 22\n#define ascii_arrow_up_right 23\n#define ascii_arrow_down_right 24\n#define ascii_arrow_down_left 25\n#define ascii_arrow_counter_clockwise 26\n#define ascii_arrow_clockwise 27\n#define ascii_arrow_STAR 28\n#define ascii_arrow_smiley 29\n\n#define ascii_space 32\t\n#define ascii_exclam 33\t\n#define ascii_quotation 34\t\n#define ascii_hash 35\t\n#define ascii_dollar 36\t\n#define ascii_percent 37\t\n#define ascii_ampersand 38\t\n#define ascii_apostrophe 39\t\n#define ascii_lparen 40\t\n#define ascii_rparen 41\t\n#define ascii_star 42\t\n#define ascii_plus 43\t\n#define ascii_comma 44\t\n#define ascii_minus 45\t\n#define ascii_period 46\t\n#define ascii_slash 47\t\n#define ascii_0 48\t\n#define ascii_1 49\t\n#define ascii_2 50\t\n#define ascii_3 51\t\n#define ascii_4 52\t\n#define ascii_5 53\t\n#define ascii_6 54\t\n#define ascii_7 55\t\n#define ascii_8 56\t\n#define ascii_9 57\t\n#define ascii_colon 58\t\n#define ascii_semicolon 59\t\n#define ascii_lt 60\t\n#define ascii_equals 61\t\n#define ascii_gt 62\t\n#define ascii_questionmark 63\t\n#define ascii_at 64\t\n#define ascii_A 65\t\n#define ascii_B 66\t\n#define ascii_C 67\t\n#define ascii_D 68\t\n#define ascii_E 69\t\n#define ascii_F 70\t\n#define ascii_G 71\t\n#define ascii_H 72\t\n#define ascii_I 73\t\n#define ascii_J 74\t\n#define ascii_K 75\t\n#define ascii_L 76\t\n#define ascii_M 77\t\n#define ascii_N 78\t\n#define ascii_O 79\t\n#define ascii_P 80\t\n#define ascii_Q 81\t\n#define ascii_R 82\t\n#define ascii_S 83\t\n#define ascii_T 84\t\n#define ascii_U 85\t\n#define ascii_V 86\t\n#define ascii_W 87\t\n#define ascii_X 88\t\n#define ascii_Y 89\t\n#define ascii_Z 90\t\n#define ascii_lbracket 91\t\n#define ascii_backslash 92\t\n#define ascii_rbracket 93\t\n#define ascii_hat 94\t\n#define ascii_underscore 95\t\n#define ascii_accent 96\t\n#define ascii_a 97\t\n#define ascii_b 98\t\n#define ascii_c 99\t\n#define ascii_d 100\t\n#define ascii_e 101\t\n#define ascii_f 102\t\n#define ascii_g 103\t\n#define ascii_h 104\t\n#define ascii_i 105\t\n#define ascii_j 106\t\n#define ascii_k 107\t\n#define ascii_l 108\t\n#define ascii_m 109\t\n#define ascii_n 110\t\n#define ascii_o 111\t\n#define ascii_p 112\t\n#define ascii_q 113\t\n#define ascii_r 114\t\n#define ascii_s 115\t\n#define ascii_t 116\t\n#define ascii_u 117\t\n#define ascii_v 118\t\n#define ascii_w 119\t\n#define ascii_x 120\t\n#define ascii_y 121\t\n#define ascii_z 122\t\n#define ascii_lbrace 123\t\n#define ascii_pipe 124\t\n#define ascii_rbrace 125\t\n#define ascii_tilde 126\t\n\t\n#define ascii_blank2 127\n\n#define ascii_alpha   128\n#define ascii_beta    129\n#define ascii_gamma   130\n#define ascii_delta   131\n#define ascii_epsilon 132\n#define ascii_zeta    ascii_z\n#define ascii_eta     ascii_n\n#define ascii_theta   133\n#define ascii_iota    ascii_i\n#define ascii_kappa   ascii_k\n#define ascii_lambda  134\n#define ascii_mu      135\n#define ascii_nu      ascii_v\n#define ascii_xi      136\n#define ascii_omicron ascii_o\n#define ascii_pi      137\n#define ascii_rho     138\n#define ascii_sigma   139\n#define ascii_tau     140\n#define ascii_upsilon ascii_u\n#define ascii_phi     141\n#define ascii_chi     ascii_x\n#define ascii_psi     142\n#define ascii_omega   143\n\n#define ascii_ALPHA   ascii_A\n#define ascii_BETA    ascii_B\n#define ascii_GAMMA   144\n#define ascii_DELTA   145\n#define ascii_EPSILON ascii_E\n#define ascii_ZETA    ascii_Z\n#define ascii_ETA     ascii_H\n#define ascii_THETA   146\n#define ascii_IOTA    ascii_I\n#define ascii_KAPPA   ascii_K\n#define ascii_LAMBDA  147\n#define ascii_MU      ascii_M\n#define ascii_NU      ascii_N\n#define ascii_XI      ascii_X\n#define ascii_OMICRON ascii_O\n#define ascii_PI      148\n#define ascii_RHO     ascii_P\n#define ascii_SIGMA   149\n#define ascii_TAU     ascii_T\n#define ascii_UPSILON ascii_Y\n#define ascii_PHI     150\n#define ascii_CHI     ascii_X\n#define ascii_PSI     151\n#define ascii_OMEGA   152\n","name":"Common","description":"","type":"common"}]}