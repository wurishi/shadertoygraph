{"ver":"0.1","info":{"id":"DdcfW8","date":"1697161329","viewed":59,"name":"Artificial-Lice (a-lice)","username":"DwayneBrah","description":"This is a \"Don't Google the Answer!\", personal challenge at creating an a-life simulation.\nIt's just a boilerplate for now, and even though this has the potential to be super-efficient, your getting a quick-bodge version of it from me here.\nSee common tab","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fast","slime","automata","evolution","cellular","efficient","quick","mold","alife","artificiallife","lice","insects","boilderplate","evolve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec4 col_a = texture(iChannel0, uv);\n    vec4 col_b = texture(iChannel1, uv);\n    vec4 col_c = texture(iChannel2, uv);\n    \n    \n    //float zoom_factor = (0.50 + 1.0+sin(iTime/10.00));\n    float zoom_factor = (0.40);\n    \n    vec2 uv_mouse = uv;\n    uv_mouse.x += iMouse.x/iResolution.x;\n    uv_mouse.y += iMouse.y/iResolution.y;\n    \n    vec4 col_a_zoomed = texture(iChannel0, uv_mouse * zoom_factor);\n    vec4 col_b_zoomed = texture(iChannel1, uv_mouse * zoom_factor);\n    vec4 col_c_zoomed = texture(iChannel2, uv_mouse * zoom_factor);\n    \n    \n   // float split = 0.5 + (sin(iTime*0.50)*0.5);\n    \n    \n    // Output to screen\n    float split = 0.8;\n    if (uv.x < split) {\n        \n        fragColor = col_c*0.75;\n        fragColor += col_a.r*0.125; \n        \n    } else {\n    \n        if (uv.y < 0.25) {\n            \n            fragColor = col_c_zoomed;\n            \n        };\n        if (uv.y >= 0.25 && uv.y < 0.50) {\n            \n            fragColor = col_b_zoomed;\n            \n        };\n        if (uv.y >= 0.50 && uv.y < 0.75) {\n            \n            fragColor = col_a_zoomed;\n            \n        };\n        if (uv.y >= 0.75) {\n            \n            fragColor = col_c_zoomed*0.75;\n            fragColor += col_a_zoomed.r;\n            \n        };\n        \n    }\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float pix_y = 1.0 / iResolution.y;    \n    float pix_x = 1.0 / iResolution.x;   \n    \n    initRandomGenerator(fragCoord);\n    vec4 col_a = texture(iChannel0, uv);\n    vec4 col_b = texture(iChannel1, uv);\n    \n    vec4 col_out = col_a;\n    \n    float r = random();\n    \n    if (iFrame < spawn_frames+wait_frames && iFrame >= wait_frames) {\n        \n        \n        if (mod(r, 0.123) < 0.001) {\n            \n            col_out.r = 1.0;\n            col_out.g = mod(random(), 1.0);\n            col_out.a = mod(random(), 1.0);\n            \n        };\n\n    } else {\n    \n        // EXPERIMENTAL DIRECTION OFFSET TO SEE\n        // IF I CAN GET VIRTUAL OMNIDIRECTION \n        //float omni_offset = mod(random(), 0.50)-0.25; \n        //col_a.g += omni_offset;\n    \n        bool direction_cycle = int( mod(float(iFrame), 4.00) ) == col_to_index(col_a.g);\n\n        vec2 offset = vec2(pix_x, pix_y) * col_to_vector(col_a.g);\n        \n        vec4 col_a_offset = texture(iChannel0, uv+offset);\n        vec4 col_b_offset = texture(iChannel1, uv+offset);\n        /*if (col_a_offset.r <= 0.0) {\n            col_a_offset = col_b_offset;\n        }*/\n        if (col_a.b >= 1.0) {\n            \n            col_a.r = 0.0;\n            col_a.g = 0.0;\n            col_a.b = 0.0;\n            col_a.a = 0.0;\n            \n        };\n        \n        if (col_a.r <= 0.0) {\n        \n            col_out = col_b;\n            col_a = col_out;\n            \n        } else {\n            \n            \n            \n            // IF this is a cell - coded in red for now.\n            if (col_a.r >= 0.0) {\n            \n                \n                // IF the space(s) in cyrrent directin is free!\n                if (col_a_offset.r <= 0.0 && col_b_offset.r <= 0.0) {\n\n                    if (col_a.g < 1.0) {\n                        \n                        if ( direction_cycle && col_a.a > mod(float(iFrame), 10.00) * 0.05 ) {\n                            \n                            col_out.b = 1.0;\n                            \n                        } else {\n                            \n                            col_out.b = 0.0;\n                            \n                        };\n                        \n                        \n                    } else {\n                        \n                        //col_out.g = mod(col_a.g + 0.25, 1.0);\n                        \n                    };\n\n                } else {\n                \n                    col_out.g = mod(col_a.g + 0.05, 1.0);\n                    \n                };\n                \n                \n            };\n            \n            \n        };\n        \n        \n        \n\n        \n        \n    };\n    \n    \n\n    fragColor = col_out;\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float pix_y = 1.0 / iResolution.y;    \n    float pix_x = 1.0 / iResolution.x;   \n\n    \n    \n    vec4 col_a = texture(iChannel0, uv);\n    vec4 col_b = texture(iChannel1, uv);\n\n    fragColor = col_a;\n    \n    vec4 col_out = vec4(0.0, 0.0, 0.0, 0.0);\n    col_a.b = 0.0;\n\n    \n    // IF THIS IS A BLANK PIXEL\n    if (iFrame >= spawn_frames) {\n        \n        int direction_cycle = int( mod(float(iFrame), 4.00) );\n        \n        if (col_a.r <= 0.0) {\n            \n            \n            \n            \n            vec2 offset_top = vec2(pix_x * 0.0, pix_y * 1.0);\n            vec2 offset_right = vec2(pix_x * 1.0, pix_y * 0.0);\n            vec2 offset_bottom = vec2(pix_x * 0.0, pix_y * -1.0);\n            vec2 offset_left = vec2(pix_x * -1.0, pix_y * 0.0);\n\n            vec4 col_top = texture(iChannel0, uv+offset_top);\n            vec4 col_right = texture(iChannel0, uv+offset_right);\n            vec4 col_bottom = texture(iChannel0, uv+offset_bottom);\n            vec4 col_left = texture(iChannel0, uv+offset_left);\n               \n            \n            \n            \n            // RANDOMISE THESE?\n            vec4 selected_col = vec4(0.5, 0.5, 0.5, -0.5);\n            if (direction_cycle == 0 && col_bottom.r > 0.0 && col_bottom.g < 0.25) {\n\n                selected_col = col_bottom;\n\n            };\n            \n            if (direction_cycle == 1 && col_left.r > 0.0 && col_left.g >= 0.25 && col_left.g < 0.50) {\n\n                selected_col = col_left;\n\n            };\n            \n            \n            if (direction_cycle == 2 && col_top.r > 0.0 && col_top.g >= 0.50 && col_top.g < 0.75) {\n\n                selected_col = col_top;\n\n            };\n            if (direction_cycle == 3 && col_right.r > 0.0 && col_right.g >= 0.75) {\n\n                selected_col = col_right;\n\n            };\n            if (selected_col.b >= 1.0) {\n            \n                col_out = selected_col;\n                col_out.b = 0.0;\n            \n            };\n\n            \n\n\n        };\n    \n    };\n    \n    \n    \n\n    fragColor = col_out;\n\n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// This is a \"Don't Google the Answer!\", personal challenge\n// at creating an a-life simulation.\n// Change the below for MUCH more crits on the screen!!!\n\nint spawn_frames = 1;\nint wait_frames = 10;\n\n// It's just a boilerplate for now, and even though this has\n// the potential to be super-efficient, your getting a\n// quick-bodge version of it from me here, in-between my fiddlings.\n// \n// The zoomed-in debug panels on the right are; (click to pan)\n//  - Final render\n//  - Main buffer A. (where they spawn)\n//  - Movement buffer\n//  - Final render\n// \n// It's efficiency is mostly due to left/right/up/down being processed\n// iteratively. \n// \n// There are no features that facilitate any kind of 'evolution' - yet.\n// \n// Speed and color/species is kept in the ALPHA channel. There's lots\n// of room to add other attributes in there. I am inspired by this old \n// DOS game; (game/sim?)\n// \n// https://dosgames.com/game/evolve-lite/\n// \n// ^ It's behavioral genetics system is very simple and ingenious.\n// \n// Trails are left for the other critters to \"sniff out\", critters\n// following each other is possible here.\n// \n// I will also add propper omnidirection, maybe by\n// dithering/interpolating the direction. Hmmm...\n// \n\n\n\n\n\n\n\nfloat top = 0.0;\nfloat right = 0.25;\nfloat bottom = 0.50;\nfloat left = 0.75;\n\n\n\n\n// direction encoding\nint col_to_index( float d )\n{\n    \n    d = mod(d, 1.0);\n    int v = -1;\n    \n    if (d < 0.25) {\n    \n        v = 0;\n        \n    } else {\n    \n        if (d < 0.5) {\n            \n            v = 1;\n            \n        } else {\n            \n            if (d < 0.75) {\n                \n                 v = 2;\n                \n            } else {\n                \n                 v = 3;\n                \n            };\n            \n        };\n\n    };\n    \n    return(v);\n    \n}\n// direction encoding\nvec2 col_to_vector( float d )\n{\n    \n    d = mod(d, 1.0);\n    vec2 v = vec2(0.0, 0.0);\n    \n    if (d < 0.25) {\n    \n        v = vec2(0.0, 1.0);\n        \n    } else {\n    \n        if (d < 0.5) {\n            \n            v = vec2(1.0, 0.0);\n            \n        } else {\n            \n            if (d < 0.75) {\n                \n                 v = vec2(0.0, -1.0);\n                \n            } else {\n                \n                 v = vec2(-1.0, 0.0);\n                \n            };\n            \n        };\n\n    };\n    \n    return(v);\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float pix_y = 1.0 / iResolution.y;    \n    float pix_x = 1.0 / iResolution.x;\n    \n    vec2 cycled_vector = col_to_vector(mod(float(iFrame), 4.00) / 4.00);\n    cycled_vector = cycled_vector * vec2(pix_x, pix_y);\n    \n    \n    vec4 col_a = texture(iChannel0, uv);\n    vec4 col_b = texture(iChannel1, uv);\n    vec4 col_c = texture(iChannel2, uv);\n    vec4 col_c_vector = texture(iChannel2, uv+cycled_vector);\n\n    vec4 fader = vec4(0.96, 0.96, 0.96, 1.0);\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 out_color = vec4(0.0, 0.0, 0.0, 1.0);\n    //out_color.r = col_a.r;\n    \n    //out_color.r = clamp(col_c.r*0.98, 0.0, 1.0);\n    out_color = col_c;\n    out_color *= fader;\n    out_color = mix(out_color, col_c_vector, fader*0.13);\n    \n    //out_color += white*col_a.r * 0.8;\n    \n    if (col_a.r >= 1.0) {\n        out_color = white;\n        if (col_a.a < 0.33) {\n            out_color = vec4(1.0, 0.0, 0.0, 1.0);\n        };\n        if (col_a.a >= 0.33 && col_a.a < 0.66) {\n            out_color = vec4(0.2, 1.0, 0.0, 1.0);\n        };\n        if (col_a.a >= 0.66) {\n            out_color = vec4(0.3, 0.5, 1.0, 1.0);\n        };\n    };\n     \n    \n    \n    fragColor = out_color;\n    \n    \n    \n}","name":"Buffer C","description":"","type":"buffer"}]}