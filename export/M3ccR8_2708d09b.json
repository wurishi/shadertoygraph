{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.1415926\n#define EDGE_WIDTH 0.15\n#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 50\n#define SHADOW_STEP 1.0\n#define SHADOW_SMOOTHNESS 256.0\n#define SHADOW_DARKNESS 0.75\n#define SURF_DIST 0.001\n\n// Distance functions from iquilezles.org\nvoid fUnion(inout float d1, float d2) {d1 = min(d1,d2);}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\nfloat pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}\nfloat pCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ); \n    return length( pa - ba*h ) - r;}\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\nfloat sdCappedCylinder(vec3 p, vec3 c, vec2 h) \n{\n    // h.x 是圆柱体的半径，h.y 是圆柱体的高度的一半\n    p -= c;\n    vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r ){ return length(p-c) - r; }\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction(float d1, float d2) { return max(-d2, d1); }\nfloat opIntersection(float d1, float d2) { return max(d1, d2); }\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\n\n//cos变形\nvec3 deform(vec3 p, float frequency, float amplitude) {\n    float r = length(p.xy); \n    float theta = atan(p.y, p.x);\n\n    float deformation = amplitude * cos(theta * frequency);\n\n    p.z += deformation;\n\n    return p;\n}\n\nvec2 distf(vec3 p){\n    vec2 res = vec2(0.,1.);\n\tfloat d = 100000.0;\n\tvec3 sp = vec3(abs(p.x),p.y,p.z);\n\n    //耳朵\n    d = opSmoothUnion(\n            sdEllipsoid(sp,vec3(6.3,0,11),vec3(1.5,1.5,1.5)),\n            sdEllipsoid(sp,vec3(5,0,10),vec3(3.5,1.5,3.5)),\n            0.8);\n    //头\n    float head = sdEllipsoid(p,vec3(0,0,7),vec3(6,5.6,6));\n    d = opSmoothUnion(head,d,0.5);\n    //身\n    d = opSmoothUnion(sdEllipsoid(p,vec3(0,0,-5),vec3(6,5.6,6)), d, 0.5);\n\n    //脚\n    d = opSmoothUnion(pCapsule(sp,vec3(2.6,0,-5),vec3(4.3,0,-13),3.2), d, 0.8);\n\n    //手臂\n    fUnion(d, pCapsule(sp, vec3(3,0.6,-0.5), vec3(11,0.6,0.), 2.25));\n    \n\n    //围巾圈\n    float scarf2 = pTorus2(\n                       deform(p*vec3(.88,1.2,1.), 2.0, -.69) + vec3(0,0,-1.6), \n                       vec2(4.2,0.8));\n    fUnion(d, scarf2);\n    if (scarf2 < d+SURF_DIST) res.y = 2.;\n    \n    \n    \n    //围巾\n    vec3 rxp= rotX(p+vec3(0.,-5.,-4.5),.5);\n    float scarf0 = pTorus2(vec3(0,10,-1) + rxp, vec2(3,0.8));\n    float scarf1 = opSmoothUnion(\n                        scarf0,\n                        sdCappedCylinder(rxp,vec3(0,-10,1),vec2(2.3,.8)),\n                        0.1);\n\n    float scarfIn = opIntersection(scarf1,scarf2);\n    float scarfSphere = sdSphere(p,vec3(0,0.,2.),3.8);\n    float scarfCut = opSubtraction(scarf1, scarfSphere);\n    float scarfSmooth = opUnion(scarfIn,scarfCut);\n    \n    d = opSmoothUnion(d, scarfSmooth,0.1);\n    if (scarfSmooth < d+SURF_DIST) res.y = 3.;\n    if (scarf0 < d+SURF_DIST) res.y = 2.;\n    \n    //线\n    float green = opIntersection(scarfSmooth,\n                      opUnion(pRoundBox(p+vec3(0.,4.3,-1.), vec3(1.2,.06,.5), .1),\n                          opUnion(pRoundBox(rotZ(p,-1.3)+vec3(-5.,1.3,-1.), vec3(.8,.06,.5), .1),\n                              pRoundBox(rotZ(p,.6)+vec3(3.5,4.1,-1.), vec3(.5,.02,.5), .1))));\n    \n\n    float red = opIntersection(scarfSmooth,\n                    opUnion(sdSphere(p,vec3(.3,-6.3,.75),.55),\n                        sdSphere(p,vec3(-1.2,-5.8,1.),.55)));\n    \n    float brown = opIntersection(head, \n                      opUnion(pRoundBox(rotY(sp,-0.12)-vec3(3.8,-5.3,6.1), vec3(.1,.8,1.), .1), \n                          opUnion(pRoundBox(p+vec3(0.,4.3,-5.), vec3(1.52,1.06,.1), .1), \n                              pRoundBox(p+vec3(0.,4.3,-4.3), vec3(.1,.8,.8), .1))));\n    \n    fUnion(d, green);\n    fUnion(d, red);\n    fUnion(d,brown);\n    \n    if (green < d+SURF_DIST) res.y = 1.2;\n    if (red < d+SURF_DIST) res.y = 1.3;\n    if (brown < d+SURF_DIST) res.y = 1.1;\n    \n    \n    //\n    res.x = d;\n\treturn res;\n}\n\n\nvec3 normal(vec3 p){\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z)).x - distf(vec3(p.x+eps,p.y,p.z)).x),\n                   (distf(vec3(p.x,p.y-eps,p.z)).x - distf(vec3(p.x,p.y+eps,p.z)).x),\n                   (distf(vec3(p.x,p.y,p.z-eps)).x - distf(vec3(p.x,p.y,p.z+eps)).x)\n\t\t\t\t );\n    return normalize(n);\n}\n\nvec4 raymarch(vec3 from, vec3 increment){\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfloat lastDistEval = 1e10;\n\tfloat edge = 0.0;\n\tfloat mat = 0.0;\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n        vec2 Fdistf = distf(pos);\n\t\tfloat distEval = Fdistf.x;\n        mat = Fdistf.y;\n\t\t\n\t\tif (lastDistEval < EDGE_WIDTH && distEval > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t}\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval;\n\t\tif (distEval < lastDistEval) lastDistEval = distEval;\n\t}\n\t\n\t//float mat = 1.0;\n\tif (dist >= maxDist) mat = 0.0;\n\t\n\t//return vec4(dist, mat, edge, 0);\n    return vec4(dist, mat, edge, 0);\n}\n\nfloat shadow(vec3 from, vec3 increment){\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n        float h = distf(from + increment * t).x;\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, SHADOW_SMOOTHNESS * h / t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\nfloat rand(float x){\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat triangle(float x){\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\nfloat time;\n\n\nfloat seem( vec2 U ) {\nU *= vec2(1.8,1.);\n    U = 2.* mod(U*.8,vec2(1,1.4)) - vec2(1,1.9);           \n    float l = length(U);\n    l = U.y/l > -.7 ?  l                                   \n                    :  length( U - vec2 (sign(U.x),-1) );  \n    \n    return smoothstep(.1,.0, abs(l-.7) -.1) * ( .5+.4*abs(U.y+.5) );    \n}\n\nfloat cGrid(in vec2 p){\n\tvec2 grid = fract(p * 25.); \n\treturn max(seem(grid), seem(grid+vec2(0,.73))) ;\n}\n\nfloat gridTexture(vec2 uv, float scale, float intensity) {\n    return cGrid(uv);\n}\n\n\nvec4 triplanarGridMapping(vec3 pos, vec3 normal, float scale, float intensity) {\n    vec2 uvX = pos.yz / 20.0; \n    vec2 uvY = pos.xz / 20.0;\n    vec2 uvZ = pos.xy / 20.0;\n\n    float texX = gridTexture(uvX, scale, intensity);\n    float texY = gridTexture(uvY, scale, intensity);\n    float texZ = gridTexture(uvZ, scale, intensity);\n\n    float blendX = abs(normal.x);\n    float blendY = abs(normal.y);\n    float blendZ = abs(normal.z);\n\n\n    if (blendX > blendY){\n        if (blendX > blendZ){\n            blendY = 0.;blendZ = 0.;\n        } else {\n            blendX = 0.;blendY = 0.;\n        }\n    } else {\n        if (blendY > blendZ){\n            blendX = 0.;blendZ = 0.;\n        } else {\n            blendX = 0.;blendY = 0.;\n        }\n    }\n\n    float finalTex = texX * blendX + texY * blendY + texZ * blendZ;\n    \n\n    return vec4(vec3(finalTex), 1.0);\n}\n\n\nvec4 getPixel(vec2 p, vec3 from, vec3 increment, vec3 light) {\n    vec4 c = raymarch(from, increment);\n    \n    vec3 hitPos = from + increment * c.x;\n    \n    vec3 normalDir = normalize(normal(hitPos));\n    \n    float diffuse = max(0.0, dot(normalDir, -light));\n    \n    if (c.y == 0.0)\n        diffuse = min(pow(length(p), 4.0) * 0.125, 1.0);\n\n    vec4 mCol = mix(vec4(1, 0.9, 0.8, 1), vec4(1, 0.9, 0.8, 1) * 0.5, diffuse);\n\n    vec4 gridColor = triplanarGridMapping(hitPos, normalDir, 10.0, 0.1);\n\n    vec4 finalColor ;\n    if (c.y == .0)\n        finalColor = mCol;\n    else if (c.y == 1.1)\n        finalColor = vec4(0.78, 0.62, 0.45, 0.7);\n    else if (c.y == 1.2)\n        finalColor = vec4(0.49, 0.88, 0.80, 0.7);\n    else if (c.y == 1.3)\n        finalColor = vec4(1.0, 0.4, 0.4, 0.7);\n    else if (c.y == 2.)\n        finalColor= mix( vec4(0.95, 0.90, 0.82, 1.0), vec4(1., 1., 1., .70),gridColor.r);\n    else if (c.y == 3.)\n        finalColor= mix( vec4(0.75, 0.85, 0.95, 1.0), vec4(0.8, 0.9, 1.0, .70),gridColor.r);\n    else \n        finalColor= mix(vec4(0.9, 0.75, 0.4, .81), vec4(1.0, 0.99, 0.0, 1.0), gridColor.r);\n\n    //边缘混合\n    return mix(finalColor, vec4(1, 0.9, 0.8, 1) * 0.5, c.z);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\ttime = floor(iTime * 16.0) / 16.0;\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= -iResolution.x/iResolution.y;\n   \n\t\n    p += vec2(triangle(p.y * rand(time) * 3.0) * rand(time * 1.9) * 0.012,\n\t\t\ttriangle(p.x * rand(time * 3.4) * 3.0) * rand(time * 2.1) * 0.012);\n            \n\tp += vec2(rand(p.x * 3.1 + p.y * 8.7) * 0.01,\n\t\t\t  rand(p.x * 1.1 + p.y * 6.7) * 0.01);\n\n\t\n\t// mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif (iMouse.x == 0.0 && iMouse.y == 0.0) {\n\t\tm = vec2(time * 0.06 + 1.67, 0.78);\t\n\t}\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-0.75);\n\tm.y += 0.75;\n\n\t// camera position\n\tfloat dist = 50.0;\n\tvec3 ta = vec3(0,0,0);\n\tvec3 ro = vec3(cos(m.x) * cos(m.y) * dist, sin(m.x) * cos(m.y) * dist, sin(m.y) * dist);\n\tvec3 light = vec3(cos(m.x - 2.27) * 50.0, sin(m.x - 2.27) * 50.0, -20.0);\n\t\n\t// camera direction\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t// calculate color\n\tvec4 col = getPixel(p, ro, rd, normalize(light));\n    col = pow(col, vec4(1.0 / 2.2));\n    col = col * 1.8 - 0.8;\n\tfragColor = col;\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"M3ccR8","date":"1734706769","viewed":83,"name":"littleBear","username":"littleBear","description":"toy","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""}}