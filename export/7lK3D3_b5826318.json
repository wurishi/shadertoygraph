{"ver":"0.1","info":{"id":"7lK3D3","date":"1638548646","viewed":178,"name":"Bezier Rope","username":"miczac","description":"This is a proof of concept demonstration of a rope function. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["animation","texturing","rope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DATA iChannel0\n#define TEXT1 iChannel1\n#define TEXT2 iChannel2\nfloat section;\nfloat map(vec3 p)\n{\n    // id is row index where position data is stored\n    int id = 1;\n    float cap = Rope(p, id, DATA, ROPE_POINTS, section);\n    //save global variables p_tranform and h\n    return cap;\n}\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float min_dist = 0.01;\n    float max_dist = 10.;\n    float d = min_dist;\n    for(int i = 0; i < 80; i++)\n    {\n        vec3 p = ro + rd*d;\n        float cap = map(p);\n        if(d > max_dist || abs(cap) < min_dist) break;\n        d += cap;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if 1 to check how the data is stored\n    #if 0 \n    fragColor = texelFetch(DATA,ivec2(fragCoord*0.05),0);\n    #else\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y*2.;\n    vec3 lookat = vec3(0 ,1.,0);\n    //vec3 ro = vec3(cos(iTime*0.5),0.5,sin(iTime*0.5));\n    vec3 ro = vec3(0,0.5,3.);\n    mat3 cam = camera(ro, lookat, 0.);\n    vec3 rd = cam * normalize(vec3(uv, 1));\n    float hit = intersect(ro,rd);\n    vec3 col = vec3(0);\n    if(hit < 10.)\n    {\n        vec3 p = ro + rd * hit;\n        vec2 ruv = rope_uv[int(section)];\n        #if 1\n        vec3 text = texture(TEXT1,ruv).xxx;\n        #else\n        vec3 text = texture(TEXT2,ruv).xyz;\n        #endif\n        col = text;\n    }\n    fragColor = vec4(col,1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* This is an improved version of my earlier rope function using splines\nin this I use bezier as was suggested on FB by Tom Sirgedas (thanks!)\nIt's less efficient since it implements a loop in the sdf but more accurate and allows for correct \nuv mapping*/\n\n\n\n#define RHO 1.732050808\n\n#define ROPE_POINTS 12\n#define ROPE_LENGTH 2.8\n#define ROPE_THICK 0.1\nconst int NUM_BEZ = ROPE_POINTS / 2;\nconst float fNUM_BEZ = float(NUM_BEZ);\nconst float H_SECTION = 1./fNUM_BEZ;\n\n//rope uv is an array since it stores rope's segments\nvec2[NUM_BEZ] rope_uv;\n\n\n#define PI 3.14159265358\n\nvec3 slide(vec3 cur, vec3 tar, float sli)\n{\n    vec3 res = mix(cur, tar, sli);\n    return    res;\n}\n\nmat3 camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n//https://www.shadertoy.com/view/MlKcDD signed distance to a quadratic bezier\n//I added 2 inouts to get the t interpolation value between points\n// and a vec3 point to get the position of the point in the bezier, both values\n// are used to extract fixed uv for texturing\nfloat sdBezier( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, inout float tt, inout vec3 point  )\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n        point =(c + b*t)*t;\n        tt = t;\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*RHO;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));     \n    }\n    return sqrt( res );\n}\n\n\nfloat Rope(vec3 p, int id, in sampler2D text, int num_points, inout float section)\n{\n    float dist = 100.;\n    for(int i = 0; i < NUM_BEZ; i++)\n    {\n        int cell = i*2;\n        vec3 A = texelFetch(text, ivec2(cell, id ), 0).xyz;\n        vec3 B = texelFetch(text, ivec2(cell+1, id ), 0).xyz;\n        vec3 C = texelFetch(text, ivec2(cell+2, id ), 0).xyz;\n        float v = 0.;\n        float u = 0.;\n        vec3 point = vec3(0);\n        float bez = sdBezier(p,A,B,C, v, point);\n        vec3 diff = p - point - A;\n        u = fract(atan(diff.z,diff.x)/2.)/PI+0.5;\n        v = v/fNUM_BEZ+H_SECTION*float(i);\n        rope_uv[i] = vec2(u,v);\n        if(bez < dist ) section = float(i);\n        dist = min(dist,bez);\n    }\n    \n    return dist - ROPE_THICK;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FEEDBACK iChannel0\n\nvec3 rope_anim()\n{\n    return vec3(cos(iTime*10.)*0.5,0,sin(iTime*0.3))*1.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoo = ivec2(fragCoord);\n    if(any(greaterThan(iCoo, ivec2(ROPE_POINTS,1)))) discard;\n    //save position data in two rows: one for simple non-streteched\n    //values, one with position data plus some added stretch value\n    //given by the ROPE_LENGTH and added to each pixel depending on\n    // its x position: first pixel will be the rope head,\n    //last pixel is rope tail.\n\n    //generate and store position raw data \n    //without any stretch (rope of length 0)\n    if(iCoo.y == 0)\n    {\n        //first pixel in row is current position\n        if(iCoo.x == 0) fragColor.xyz = rope_anim();\n        //save previous positions in following pixels\n        else\n        {\n            vec3 tar = texelFetch(FEEDBACK, iCoo - ivec2(1,0),0).xyz;\n            vec3 cur = texelFetch(FEEDBACK, iCoo ,0).xyz;\n            fragColor.xyz = slide(cur,tar,0.5);\n        }\n    }\n    //retrieve stored data and add a stretch value equal to the \n    //rope length * texel.x/ROPE_POINTS. I need to separate these steps otherwise the rope\n    //will keep accumulating stretch values \n    else \n    {\n        vec3 target = texelFetch(FEEDBACK, iCoo - ivec2(0,1),0).xyz;\n        vec3 stretch = vec3(0,float(iCoo.x)/float(ROPE_POINTS)*ROPE_LENGTH, 0);\n        target += stretch;\n        vec3 current = texelFetch(FEEDBACK, iCoo,0).xyz;\n        vec3 res = slide(current, target, 0.2);\n        fragColor.xyz = res;\n    }\n\n\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}