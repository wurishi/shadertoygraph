{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct sphere_t\n{\n\tvec3 pos;\n\tfloat rayon;\n};\n\t\nstruct plan_t\n{\n\tvec3 normale; // la normale au plan\n\tfloat d; //offset de l'Ã©quation\n};\n\t\nstruct surface_t\n{\n\tvec3 pos;\n\tvec3 normale;\n\tvec2 uv;\n\tint id;\n};\n\t\nstruct ray_t\n{\n\tvec3 pos;\n\tvec3 direction;\n};\n\nstruct material_t\n{\n\tvec3  couleur;\n\tfloat rugosite;\n};\n\nstruct mapping_t\n{\n\tvec3 rotation;\n};\n\t\nstruct light_t{\n\tvec3 direction;\n\tfloat contribution;\n};\n\t\nconst int NONE   = 0;\nconst int PLANE  = 1;\nconst int SPHERE = 2;\n\nconst float PI   = 3.14; //Valeur de PI\nfloat max_distance = 1e5; //distance par rapport Ã  la sphÃ¨re\n\nfloat intersectSphere( const in ray_t ray, const in sphere_t sphere, out surface_t surface)\n{\t\n\tmat4 espaceMonde =  mat4(\n\t\t1.0, 0.0, 0.0, -sphere.pos.x,\n\t\t0.0, 1.0, 0.0, -sphere.pos.y,\n\t\t0.0, 0.0, 1.0, -sphere.pos.z,\n\t\t0.0, 0.0, 0.0, 0.0\n\t);\n\t\n\tvec3 pos = vec3( vec4(ray.pos,1.0)*espaceMonde);\n\t\t\n\tfloat t,t1,t2;\n\tfloat a = pow(ray.direction.x, 2.0) + pow(ray.direction.y, 2.0) + pow(ray.direction.z, 2.0);\n\tfloat b = 2.0 *( (ray.direction.x*pos.x) + (ray.direction.y*pos.y) + (ray.direction.z*pos.z) );\n\tfloat c = pow(pos.x,2.0) + pow(pos.y,2.0)+pow(pos.z,2.0) - pow(sphere.rayon,2.0);\n\t\n\tfloat delta = pow(b,2.0) - (4.0*a*c);\n\tt1 = ( -b + sqrt(delta)) / (2.0*a);\n\tt2 = ( -b - sqrt(delta)) / (2.0*a);\n\t\n\tif (delta < 0.0) return max_distance; //Pas d'intersection\n\t\n\tif(t1 < t2){\n\t\tsurface.pos = ray.pos + (ray.direction * t1);\n\t}\n\telse{\n\t\tsurface.pos = ray.pos + (ray.direction * t2);\n\t}\n\n\tvec3 positionLocale = surface.pos - sphere.pos;\n\t\n\tfloat rho = sphere.rayon;\n\tfloat theta = atan(positionLocale.x, positionLocale.z )/(PI/2.0); //compris entre -1 et 1\n\tfloat phi = acos( positionLocale.y / rho )/PI; //compris entre 0 et 1\n\t\n\tsurface.id = SPHERE;\n\tsurface.uv = vec2((theta+1.0)*0.5,phi);\n\t//surface.uv = vec2(abs(theta),phi);\n\tsurface.normale = normalize((surface.pos - sphere.pos)/sphere.rayon);\n\t\n\treturn min(t1,t2);\n}\n\nfloat intersectPlan(const in plan_t plan, const in ray_t ray, const in mapping_t mapping, out surface_t surface)\n{\t\n\tvec3 cosinus = cos(mapping.rotation), sinus = sin(mapping.rotation);\n\tmat3 rotationX = mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cosinus.x,-sinus.z,\n\t\t0.0, sinus.x, cosinus.x\n\t);\n\tmat3 rotationY = mat3(\n\t\tcosinus.y, 0.0,  sinus.y,\n\t\t0.0, 1.0,  0.0,\n\t   -sinus.y, 0.0,  cosinus.y\n\t);\n\tmat3 rotationZ = mat3(\n\t\tcosinus.z,-sinus.z,  0.0,\n\t\tsinus.z, cosinus.z,  0.0,\n\t    0.0, 0.0,  1.0\n\t);\n\t\n\tmat3 rotation = rotationX * rotationY * rotationZ;\n\tvec3 planNormale = normalize( plan.normale ) * rotation;\n\t\n\tvec3 /* normal_by_origin */ no = planNormale * ray.pos;\n\tvec3 /* normal_by_direction */ nd = planNormale * ray.direction;\n\tfloat distance_from_origin = ( - no.x - no.y - no.z - plan.d) / ( nd.x + nd.y + nd.z );\n\t\n\tsurface.pos = ray.pos + ray.direction * distance_from_origin;\n\t\n\tvec3 localPosition = surface.pos * rotation;\n\tsurface.uv = vec2( localPosition.x,-localPosition.z );\n\t\n\tsurface.normale   = plan.normale;\n\t\n\tsurface.id = PLANE;\n\treturn distance_from_origin < 0.0 ? max_distance : distance_from_origin;\n}\n\nfloat intersect(const in ray_t ray, out surface_t surface, out material_t material, const in int avoid)\n{\n\tconst sphere_t sphere = sphere_t(vec3(0.0,1.0,0.0),1.0);\n\tconst plan_t plan = plan_t(vec3(0.0, 0.1, 0.01),0.1);\n\t\n\tconst mapping_t mappingSphere = mapping_t( vec3( 0.0, 0.0, 0.0 ) );\n\tconst mapping_t mappingPlan  = mapping_t( vec3( PI / 12.0, 0.0, 0.0 ) );\n\t\n\tsurface_t surfaceSphere, surfacePlan;\n\tfloat distance_from_origin_Plan = intersectPlan(plan, ray, mappingPlan,surfacePlan);\n\tfloat distance_from_origin_Sphere = intersectSphere(ray, sphere,surfaceSphere);\n\t\n\tif ((distance_from_origin_Plan < max_distance) && (distance_from_origin_Plan<distance_from_origin_Sphere)){\n\t\t//On se trouve sur le plan\n\t\t\n\t\tsurface = surfacePlan;\n\t\t//surface.uv *= 3.0;\n\t\tmaterial.couleur = texture(iChannel3, surface.uv).rgb;\n\t\tmaterial.rugosite = 0.8;\n\t}\n\telse if(distance_from_origin_Sphere < max_distance){\n\t\t//On se trouve sur la sphere\n\t\t\n\t\tsurface = surfaceSphere;\n\t\t//surface.uv * 2.0;\n\t\tmaterial.couleur = texture(iChannel2, surface.uv).rgb;\n\t\tmaterial.rugosite = 1.0;\n\t\t\n\t}\n\telse {\n\t\tsurface.id = NONE;\n\t\tsurface.pos = vec3( 0.0 );\n\t\tsurface.uv = vec2( 0.0 );\n\t\tsurface.normale = vec3( 0.0 );\n\t\t\n\t\tmaterial.couleur = vec3 (1.0, 0.4, 0.3);\n\t\tmaterial.rugosite = 0.0;\n\t}\n\treturn min(distance_from_origin_Sphere,distance_from_origin_Plan);\n}\n\nvoid light_information0(const in surface_t surface, out light_t light){\n\tvec3  positionPoint = vec3( 5.0 * cos( iTime ), 2.0, 5.0 * sin( iTime ) );\n\tconst float contributionPointModifiee = 1.0;\n\t\n\tlight.direction = normalize( positionPoint - surface.pos );\n\tlight.contribution = length( light.direction ) * contributionPointModifiee;\n}\n\nvoid light_information1( const in surface_t surface, out light_t light )\n{\n\tconst vec3  positionPoint = vec3( 0.0, 1.0, 0.0 );\n\tconst float contributionPointModifiee = 1.0;\n\t\n\tlight.direction    = normalize( positionPoint - surface.pos );\n\tlight.contribution = length( light.direction ) * contributionPointModifiee;\n}\n\nvec3 illumination(const in ray_t ray, const in surface_t surface, const material_t material, const in light_t light )\n{\n\tfloat power = mix( 5000.0, 75.0, material.rugosite );\n\t//vec3 vectorHalf = normalize( -ray.direction + light.direction );\n\tvec3 vectorHalf = normalize(reflect( ray.direction,-surface.normale));\n\t\n\t\n\tfloat diffuse  = max( 0.0, dot( surface.normale, light.direction ) );\n\t//float specular = max( 0.0, pow( dot( surface.normale, vectorHalf ), power ) );\n\tfloat specular = pow( max(0.0, dot(light.direction, vectorHalf)),power );\n\t\n\t\n\tvec3 contributionDiffuse  = vec3( diffuse * light.contribution * material.couleur );\n\tvec3 contributionSpecular = vec3( specular * light.contribution );\n\t\n\tvec3 contribution = contributionDiffuse + contributionSpecular;\n\treturn contribution;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coordinate = fragCoord.xy / iResolution.xy;\n\tvec2 coordinate_entered = 2.0 * coordinate - 1.0;\n\t\n\tfloat coeffCorrection = (iResolution.x/iResolution.y);\n\t\n\tray_t camera_ray;\n\tsurface_t surface;\n\tmaterial_t material;\n\t\n\tcamera_ray.pos = vec3(0.0, 0.6, 2.0);\n\tcamera_ray.direction = vec3((coordinate_entered.x * coeffCorrection) , coordinate_entered.y, -1.0);\n\tfloat distance_from_origin = intersect(camera_ray, surface, material, NONE);\n\n\t\tif ((distance_from_origin < max_distance)&&( surface.id != NONE)){\n\t\t\tlight_t light;\n\t\t\tvec3 illuminationLight = vec3(0.0);\n\t\t\t\n\t\t\tlight_information0( surface, light );\n\t\t\tvec3 illumination_light0 = illumination( camera_ray, surface, material, light );\n\t\t\t\n\t\t\tlight_information1( surface, light );\n\t\t\tvec3 illumination_light1 = illumination( camera_ray, surface, material, light ); \n\t\t\t\n\t\t\tilluminationLight += illumination_light0;\n\t\t\tilluminationLight += illumination_light1;\n\t\t\t\n\t\t\t//const vec3 _color = vec3(0.3, 0.6, 0.6);\n\t\t\tfragColor = vec4( vec3( illuminationLight ), 1.0 );\n\t\t}\n\t\telse{\n\t\t\tconst vec3 background_color = vec3(0.03, 0.05, 0.98);\n\t\t\tfragColor = vec4 (background_color, 1.0);\n\t\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSGRd","date":"1392046682","viewed":225,"name":"Texture Sphere_Plane","username":"MugiwaraLuffy","description":"Texture on sphere\nTexture on plane","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["texture","light","sphere","plane","rotation"],"hasliked":0,"parentid":"","parentname":""}}