{"ver":"0.1","info":{"id":"X3SSDh","date":"1711201245","viewed":56,"name":"psych.noise.2D","username":"alesteba","description":"grunge stoner garage surf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noisestonergaragesurf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// random\n\n\nfloat rand2dTo1d(vec2 value, vec2 dotDir){\n\n    vec2 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\n\nfloat rand2dTo1d(vec2 value){\n\n    vec2 dotDir = vec2(12.9898, 78.233);\n    \n    return rand2dTo1d(value,dotDir);\n}\n\nvec2 rand2dTo2d(vec2 value){\n\n    return vec2(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135))\n    );\n}\n\nfloat interpolate_In(float interpolator){\n\n\t\t\treturn interpolator * interpolator;\n}\n\nfloat interpolate_Out(float interpolator){\n    return 1.0 - interpolate_In(1.0 - interpolator);\n}\n\nfloat interpolate_InOut(float interpolator){\n\n    float in_value = interpolate_In(interpolator);\n    float out_value = interpolate_Out(interpolator);\n    \n    return mix(in_value, out_value, interpolator);\n}\n\n\nfloat perlinNoise(vec2 value){\n\n    vec2 ll_Direction = rand2dTo2d(vec2(floor(value.x), floor(value.y))) * 2.0 - 1.0;\n    vec2 lr_Direction = rand2dTo2d(vec2(ceil(value.x), floor(value.y))) * 2.0 - 1.0;\n    vec2 ul_Direction = rand2dTo2d(vec2(floor(value.x), ceil(value.y))) * 2.0 - 1.0;\n    vec2 ur_Direction = rand2dTo2d(vec2(ceil(value.x), ceil(value.y))) * 2.0 - 1.0;\n    \n    vec2 fraction = vec2( fract(value.x), fract(value.y) );\n\n    float ll_FunctionValue = dot(ll_Direction, fraction - vec2(0, 0));\n    float lr_FunctionValue = dot(lr_Direction, fraction - vec2(1, 0));\n    float ul_FunctionValue = dot(ul_Direction, fraction - vec2(0, 1));\n    float ur_FunctionValue = dot(ur_Direction, fraction - vec2(1, 1));\n\n    float interpolatorX = interpolate_InOut(fraction.x);\n    float interpolatorY = interpolate_InOut(fraction.y);\n\n    float lowerCells = mix(ll_FunctionValue, lr_FunctionValue, interpolatorX);   \n    float upperCells = mix(ul_FunctionValue, ur_FunctionValue, interpolatorX);\n\n    float noise = mix(lowerCells, upperCells, interpolatorY);\n    \n    return noise;\n}\n\n\nfloat surf (vec2 worldPos) {\n        \n    vec2 cellSize = vec2(0.25, 0.25);\n    \n    vec2 value = worldPos / cellSize;\n    \n    float noise = perlinNoise(value) + 0.5*(iTime*0.1)+0.5;\n\n    return noise;\n}\n\n\nint binarySearch(float[3] nums,float searchnum ){\n\n    int low = 0;\n    int high = 3 - 1;\n    int mid = (low + high) / 2;\n    \n    while(low < high){\n        if(nums[mid] < searchnum){\n            if(nums[mid + 1] > searchnum){\n                return mid;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        else{\n            high = mid - 1;\n        }\n        mid = (low + high) / 2;\n    }\n    \n    return mid;\n}\n\nfloat lerp (float x0, float x1, float y0, float y1, float x)\n{\n    float d = x1 - x0;\n    \n    if (d == 0.0)\n        return (y0 + y1) / 2.0;\n        \n    return y0 + ( (x - x0) * (y1 - y0) ) / d;\n}\n\nvec3 vec3_lerp(float x0, float x1, vec3 a, vec3 b, float x)\n{\n\n    return vec3(\n        lerp(x0, x1, a.x, b.x, x),\n        lerp(x0, x1, a.y, b.y, x),\n        lerp(x0, x1, a.z, b.z, x)\n    );\n}\n\n\nvec3 piecewise_lerp (float[3] Xs, vec3[3] Ys, float x)\n{\n    int index = int(binarySearch(Xs, x));\n\n    return vec3_lerp\n    (\n        Xs[index ], Xs[index+1],\n        Ys[index ], Ys[index+1],\n        x\n    );\n}\n\nvec3 rgb_normal(float r, float g, float b)\n{\n    return vec3(r/255.0, g/255.0, b/255.0);\n}\n\nvec4 color_interpolator( float interpolant_x)\n{\n    float interpolant = interpolant_x;\n    \n    float mid = 0.25*sin(iTime)+0.5;\n    \n    float x[3]=float[](0.0,mid,1.0); \n    vec3 COLOR_MASKS[3];\n    COLOR_MASKS[0] = rgb_normal(1.0, 166.0, 185.0);\n    COLOR_MASKS[1] = rgb_normal( 7.0, 7.0, 7.0);\n    COLOR_MASKS[2] = rgb_normal( 196.0, 85.0, 118.0 );\n    \n    vec3 combination = piecewise_lerp(x,COLOR_MASKS,interpolant);\n    \n    return vec4(combination, 1.0);\n            \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float v1 = surf(uv);\n    \n    float m = mix(6.0, 9.0, abs(sin(iTime*0.001)));\n    \n    v1 = fract(v1 * m);\n    \n    fragColor = color_interpolator(v1);\n}","name":"Image","description":"","type":"image"}]}