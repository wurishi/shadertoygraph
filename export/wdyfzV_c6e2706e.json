{"ver":"0.1","info":{"id":"wdyfzV","date":"1607519371","viewed":97,"name":"Raymarching Light + Texture","username":"Kiltun","description":"Simple Light and Texture system for raymarching ( + controller )","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","texture","light","sampler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n        \n    vec4 out_color = texture(iChannel0, uv);\n\tfragColor = out_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n\nconst int slotCameraPosition = 0;\nconst int slotCameraRotation = 1;\n\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraRotation(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraRotation).xyz;\n}\n\n\n//// ROTATION\n\nconst float pi = acos(-1.); //3.141592;\n\n// e^(i*rads) Euler's formula complex spinor\nvec2 cossin(float r)\n{\n    return sin(r + vec2(.5*pi, 0));\n}\n\n\nmat2 mrot(vec2 s)\n{\n    return mat2(s.x, -s.y, s.y, s.x);\n} // then can q.xz = mrot(cossin(a)) * q.xz;\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_W = 87;\nconst int KEY_Z = 90;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_Q = 81;\nconst int KEY_D = 68;\nconst int KEY_SHIFT = 16;\nconst int KEY_SPACE = 32;\nconst int KEY_C = 67;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ip = ivec2(fragCoord);\n    vec3 o = cameraPosition(iChannel1);\n    float deltaTime = iTimeDelta;\n    \n    float zMov = texelFetch( iChannel0, ivec2(KEY_Z,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_S,0), 0 ).x;\n    float yMov = texelFetch( iChannel0, ivec2(KEY_SPACE,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_C,0), 0 ).x;\n    float xMov = texelFetch( iChannel0, ivec2(KEY_D,0), 0 ).x - texelFetch( iChannel0, ivec2(KEY_Q,0), 0 ).x;\n    float boost = texelFetch( iChannel0, ivec2(KEY_SHIFT,0), 0 ).x * 4.;\n    \n    deltaTime *= 1. + (boost);\n    o += (vec3(xMov * deltaTime,yMov * deltaTime, zMov * deltaTime));\n    \n    vec3 newPos = o;       \n    fragColor.xyz = newPos;\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define ITERATIONS 64\n\nfloat mapFunction(vec3 p)\n{\n    p = fract(p) * 2. -1.;\n    return length(p) - 0.25;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = fract(p) * 2. -1.;\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  p =fract(p) * 2.0 -1.0;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 calcNormals(vec3 pos, vec2 s)\n{\n\tconst vec2 eps = vec2(0.001, 0.0);\n    \n    vec3 nor = vec3(\n    sdTorus(pos + eps.xyy, s) - sdTorus(pos -  eps.xyy, s),\n    sdTorus(pos + eps.yxy, s) - sdTorus(pos -  eps.yxy, s),\n    sdTorus(pos + eps.yyx, s) - sdTorus(pos -  eps.yyx, s));\n    \n    return normalize(nor);\n}\n\nvec3 triplanar(vec3 pos, vec3 normal, sampler2D textureSample)\n{\n\tnormal = abs(normal);\n    \n    vec3 xy = texture(textureSample, pos.xy).xyz; \n    vec3 xz = texture(textureSample, pos.xz).xyz; \n    vec3 zy = texture(textureSample, pos.zy).xyz; \n    \n    return normal.z * xy + normal.y * xz + normal.x * zy;\n}\n\n\nvec3 trace(vec3 o, vec3 r,out float distanceD )\n{\n\tvec3 c;\n    distanceD = 0.;\n    for(int i = 0; i < ITERATIONS; i++)\n    {\n    \tvec3 p = o + r * distanceD;\n        //float d = mapFunction(p);\n        vec2 s = vec2((sin(iTime) * 0.5 ) + 1.0, 0.2);\n        \n        float d = sdTorus(p, s);\n        \n        if(d < 0.001)\n        {\n        \tc = calcNormals(p, s);\n            \n            vec3 lightDir = vec3(cos(iTime),sin(iTime),sin(iTime));\n            lightDir = normalize(lightDir);\n            \n            float dotLight = dot(lightDir, c );\n            dotLight = clamp(dotLight, 0.0, 1.0);\n            \n            \n            vec3 tex = triplanar(p, c, iChannel0);\n            \n            \n            \n            \n            vec3 diffuse_color = vec3(0.8,0.8, 0.8);\n            vec3 ambient_color = vec3(0.2,0.2,0.2);\n            \n            diffuse_color *= tex;\n            \n            vec3 output_color = (diffuse_color * dotLight) + ambient_color;\n            \n            output_color = vec3(\n            min(output_color.x, 1.0),\n            min(output_color.y, 1.0),\n            min(output_color.z, 1.0));\n            \n           \n            \n        \treturn output_color;\n        }\n        \n        \n        distanceD += d * 0.5;\n    }\n    //return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_jcvd = uv;\n    uv = uv * 2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 1.0));\n    /*r.zx *= mrot(cossin(iTime));\n    r.zy *= mrot(cossin(iTime));*/\n    \n    float time_var = iTime * 0.1;\n       \n    vec3 o = cameraPosition(iChannel1);\n    o += vec3(0.5, 0, time_var);\n        \n    float distanceDD;\n    vec3 t = trace(o,r,distanceDD);\n\n    vec3 fogColor = texture(iChannel2,uv_jcvd).rgb;\n\tt = mix(t, 0.8 * fogColor, 1.0 - exp2(-0.11 * distanceDD * distanceDD));\n\n    fragColor = vec4(t,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}