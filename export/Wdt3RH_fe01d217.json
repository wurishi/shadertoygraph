{"ver":"0.1","info":{"id":"Wdt3RH","date":"1567785928","viewed":194,"name":"1D Mobius Transform","username":"skye_adaire","description":"This is a geometric Mobius transformation of the real line. Horizontal motions are translation, vertical motions are scaling, and rotations are inversion. The white region is infinitely large. http://www-users.math.umn.edu/~arnold//papers/moebius.pdf","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sphere","mobius","plane","complex","stereographic","transform","real","lifted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define tau32 6.2831853072\n#define eps32 1e-10\n\nfloat alpha(float x, float a, float b)\n{\n   return (x - a) / (b - a);\n}\n\n#define uclamp(x) clamp(x, 0.0, 1.0)\n#define ualpha(x, a, b) uclamp(alpha(x, a, b))\n\nfloat argument(vec2 h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nvec2 versor(float angle)\n{\n    return vec2(cos(angle), sin(angle));\n}\n\n//the hyperplane centered at the origin with normal 0,1\nbool intersectHyperplane(vec2 rayPosition, vec2 rayDirection, out float t)\n{\n    t = -rayPosition[1] / rayDirection[1];\n\n    return t > 0.0 && !isinf(t);\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\n//the hypersphere centered at the origin with radius 1\nbool intersectHypersphere(vec2 rayPosition, vec2 rayDirection, out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayPosition);\n    float c = dot(rayPosition, rayPosition) - 1.0;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//http://blog.hvidtfeldts.net/index.php/2012/03/lifted-domain-coloring/\nvec3 liftedDomainColor(float x)\n{\n    x = abs(x);\n    \n    float magnitude = (1.0-1.0/pow(2.0,x));\n    float logradius = log(x);\n    float fractlog = fract(logradius);\n    \n    //infinity will be white\n    float infinityFade = min(1.0, x / (tau32));\n    \n    //log growth ring shade\n    float growth = (fractlog)*0.2 + 0.8;\n    \n    float hue = x / (tau32);\n    float saturation = 1.0 - infinityFade;\n    float value = growth;\n    \n    return hsv2rgb(vec3(hue, saturation, value));\n}\n\nmat2 rotation2(float a)\n{\n \tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 getSphereColor(vec2 positionOnSphere)\n{\n    //in local sphere space, project onto the real line\n    vec2 rp = positionOnSphere;\n    vec2 rd = normalize(rp - vec2(0, 1));\n    \n    float t;\n    intersectHyperplane(rp, rd, t);//must hit\n    \n    float x = (rp + t * rd).x;\n    return liftedDomainColor(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 ss = clip * vec2(2.5) + vec2(0.0, 1.0);    \n    \n    //transform sphere local to global\n    float angle = iTime * 0.4;\n    mat2 rotation = rotation2(angle);\n    vec2 translation = vec2(0, 1.0 + cos(iTime*0.5));\n    vec2 pole = translation + vec2(0.0, 1.0);\n    \n    //transform sphere global to local\n    mat2 rotationInv = rotation2(-angle);\n    vec2 translationInv = -translation;\n    vec2 poleInv = vec2(0.0, 1.0);\n    \n    //transform position and take distances\n    vec2 pt = rotationInv * (translationInv + ss);\n    float dsphere = abs(length(pt) - 1.0);\n    float dreals = abs(ss.y);\n    float width = 0.07;\n    \n    vec2 spherePosition;\n    \n    if(dsphere < width)//we are on the sphere\n    {\n        //polar correction for line thickness\n        spherePosition = versor(argument(pt));\n    }\n    else if(dreals < width)//we are on the real line\n    {\n        //stereographic projection to the sphere\n        float x = ss.x;\n        vec2 rp = vec2(x, 0);\n        vec2 rd = normalize(rp - pole) * (length(pt) < 1.0 ? 1.0 : -1.0);\n        \n        //transform to local sphere\n        vec2 rpt = rotationInv * (translationInv + rp);\n        vec2 rdt = rotationInv * rd;\n        \n        //intersect the local sphere\n        float t;\n        intersectHypersphere(rpt, rdt, t);//must hit\n        spherePosition = rpt + t * rdt;\n    }\n    \n    //color and smooth\n    float wmodel = 1.0 - smoothstep(0.1*width, width, min(dsphere, dreals));\n    vec3 cmodel = wmodel * getSphereColor(spherePosition);\n\n    //grid\n    vec2 fs = abs(fract(ss) * 2.0 - 1.0);\n    float g = 0.2 * smoothstep(0.96, 1.0, max(fs.x, fs.y)) + 0.1;\n    g -= wmodel;//lines over grid\n    g = max(g, 0.0);\n    \n    fragColor = vec4(vec3(g) + cmodel,1.0);\n}","name":"Image","description":"","type":"image"}]}