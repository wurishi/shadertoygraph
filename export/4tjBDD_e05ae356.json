{"ver":"0.1","info":{"id":"4tjBDD","date":"1515844085","viewed":189,"name":"Adaptive Distance Estimation","username":"dust","description":"See comment.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","julia","raymarched","fractals","quaternion","distanceestimator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modified Julia DE starts from line 51\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\n// Assumes unit quaternion (rotation only)\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\n// Rigorous quaternion product, works for any length\n// (DE-friendly)\n// Taken from MacSlow's shader here: \n// https://www.shadertoy.com/view/lttSzX\n// Thanks :)\nvec4 QtnProduct2(vec4 qtnA, vec4 qtnB)\n{\n    float x = qtnA.x * qtnB.x - dot (qtnA.yzw, qtnB.yzw);\n    vec3 yzw = (qtnA.x * qtnB.yzw) + \n               (qtnB.x * qtnA.yzw) + cross(qtnA.yzw, qtnB.yzw);\n    return vec4(x, yzw);\n}\n\nstruct JParams\n{\n\tint iter;\n    vec4 z;\n    vec4 dz;\n};\n\n#define W_FRAME 0.0\n#define BAILOUT 16.0\nJParams Julia(vec3 coord,\n           \t  int maxIter)\n{\n    vec4 z = vec4(coord, W_FRAME);\n    vec4 dz = vec4(1, 0, 0, 0);\n    vec4 c = vec4(-0.5,-0.5, -0.5, W_FRAME);\n    int i = 0;\n    while (i < maxIter &&\n           length(z) < BAILOUT)\n    {\n        dz = (2.0 + length(coord) / 10.0) * QtnProduct2(z, dz);\n        z = QtnProduct2(z, z) + c;\n        i += 1;\n    }\n    return JParams(i, z, dz);\n}\n\nfloat MakinBuddhi(vec3 coord, \n                  float r, \n                  int maxIter)\n{\n    float eps = 0.0001;\n    return length((vec3(length(Julia(coord + vec3(1, 0, 0) * eps, maxIter).z), \n                 \t    length(Julia(coord + vec3(0, 1, 0) * eps, maxIter).z), \n                 \t    length(Julia(coord + vec3(0, 0, 1) * eps, maxIter).z)) - r) / eps);\n}\n\n#define ITERATIONS 8\nfloat JuliaDE(vec3 coord)\n{\n    // [0.5 * log(r) * r/dr]\n    // |f^2[n-1](c) + d, f[0] = c|\n    JParams julia = Julia(coord, \n                          ITERATIONS);\n    float r = length(julia.z);\n    float dr = length(julia.dz);\n    return (0.5 * log(r) * r / dr);\n}\n\nfloat map(vec3 coord)\n{\n    return JuliaDE(coord);\n}\n\nvec3 grad(vec3 samplePoint, float eps)\n{\n\tfloat normXA = map(vec3(samplePoint.x + eps, samplePoint.y, samplePoint.z));\n    float normXB = map(vec3(samplePoint.x - eps, samplePoint.y, samplePoint.z));\n\n    float normYA = map(vec3(samplePoint.x, samplePoint.y + eps, samplePoint.z));\n    float normYB = map(vec3(samplePoint.x, samplePoint.y - eps, samplePoint.z));\n\n    float normZA = map(vec3(samplePoint.x, samplePoint.y, samplePoint.z + eps));\n    float normZB = map(vec3(samplePoint.x, samplePoint.y, samplePoint.z - eps));\n\n    vec3 norm = vec3(normXA - normXB,\n                     normYA - normYB,\n                     normZA - normZB);\n    float len = length(norm);\n    return vec3(norm / len);    \n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\n#define EYE_DIST 7.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float eps = 0.0001;\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    vec3 sphPos = vec3(0.0, 0.0, 4.0);\n    vec4 rgba = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 dRGBA = vec4(0.02, 0.06, 0.04, 0.0) / EYE_DIST;\n    for (int i = 0; i < 255; i += 1)\n    {\n        vec3 eyePos = vec3(0.0, 0.0, EYE_DIST * -1.0);\n    \tvec3 rayVec = QtnRotate(eyePos + (rayDir * currRayDist), vec4(vec3(0.0, 1.0, 0.0) * sin(iTime / 20.0), cos(iTime / 20.0)));\n        float qtnDist = map(rayVec);\n        rgba += dRGBA;\n        if (qtnDist < eps)\n        {   \n            vec3 baseLightPos = vec3(0.0, 1.0, -1.0);\n            vec3 lightPos = QtnRotate(baseLightPos,\n                                      vec4(vec3(0.0, 1.0, 0.0) * sin(iTime / 20.0), cos(iTime / 20.0)));\n            float nDL = dot(grad(rayVec, eps).xyz, \n                            normalize(lightPos));\n            \n            fragColor = rgba * nDL;\n            fragColor.w = 1.0;\n            return;\n        }\n        \n        currRayDist += qtnDist;\n    }\n\n    fragColor = rgba;\n}","name":"Image","description":"","type":"image"}]}