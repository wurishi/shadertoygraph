{"ver":"0.1","info":{"id":"ddSXRD","date":"1669968078","viewed":160,"name":"ChatGPT Grass Scene","username":"scry","description":"\"Write a GLSL function for a 2D scene of a field of grass\"\nhttps://twitter.com/Scrygl/status/1598587842493435904","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Write a GLSL function for a 2D scene of a field of grass\nvec4 grass_try1(vec2 uv) {\n  // Calculate a simple sin wave for the grass blades\n  float bladeHeight = sin(uv.x * 10.0) * 0.1 + 0.9;\n  \n  // Use the bladeHeight to calculate the color of the grass\n  vec3 grassColor = vec3(0.3, 0.6, 0.2) * bladeHeight;\n  \n  // Return the color of the grass\n  return vec4(grassColor, 1.0);\n}\n\n//Can you add a bright blue sky and sun to the scene?\nvec4 grass_2(vec2 uv) {\n  // Calculate a simple sin wave for the grass blades\n  float bladeHeight = sin(uv.x * 10.0) * 0.1 + 0.9;\n  \n  // Use the bladeHeight to calculate the color of the grass\n  vec3 grassColor = vec3(0.3, 0.6, 0.2) * bladeHeight;\n  \n  // Calculate the position of the sun in the sky\n  float sunX = 0.7;\n  float sunY = 0.2;\n  float sunRadius = 0.1;\n  \n  // Calculate the distance from the sun to the current fragment\n  float distanceToSun = distance(uv, vec2(sunX, sunY));\n  \n  // Calculate the color of the sky\n  vec3 skyColor;\n  if (distanceToSun < sunRadius) {\n    // If the fragment is inside the sun, use a bright yellow color\n    skyColor = vec3(1.0, 1.0, 0.7);\n  } else {\n    // Otherwise, use a bright blue color\n    skyColor = vec3(0.5, 0.7, 1.0);\n  }\n  \n  // Blend the sky and grass colors based on the y coordinate of the fragment\n  vec3 finalColor = mix(skyColor, grassColor, smoothstep(0.3, 0.7, uv.y));\n  \n  // Return the final color\n  return vec4(finalColor, 1.0);\n}\n\n//Cool, however the scene seems to be upside down. Also can the sun have orange rays coming off it?\nvec4 grass_3(vec2 uv) {\n  // Calculate a simple sin wave for the grass blades\n  float bladeHeight = sin(uv.x * 10.0) * 0.1 + 0.9;\n  \n  // Use the bladeHeight to calculate the color of the grass\n  vec3 grassColor = vec3(0.3, 0.6, 0.2) * bladeHeight;\n  \n  // Calculate the position of the sun in the sky\n  float sunX = 0.7;\n  float sunY = 0.2;\n  float sunRadius = 0.1;\n  \n  // Calculate the distance from the sun to the current fragment\n  float distanceToSun = distance(uv, vec2(sunX, sunY));\n  \n  // Calculate the color of the sky\n  vec3 skyColor;\n  if (distanceToSun < sunRadius) {\n    // If the fragment is inside the sun, use a bright yellow color\n    skyColor = vec3(1.0, 1.0, 0.7);\n  } else {\n    // Otherwise, use a bright blue color\n    skyColor = vec3(0.5, 0.7, 1.0);\n  }\n  \n  // Blend the sky and grass colors based on the y coordinate of the fragment\n  vec3 finalColor = mix(skyColor, grassColor, smoothstep(0.3, 0.7, uv.y));\n  \n  // Add orange rays to the sun\n  if (distanceToSun < sunRadius) {\n    // Calculate the angle of the fragment relative to the center of the sun\n    float angle = atan(uv.y - sunY, uv.x - sunX);\n    \n    // Calculate the length of the ray\n    float rayLength = 0.5 * distanceToSun / sunRadius;\n    \n    // Draw the ray\n    finalColor = mix(finalColor, vec3(1.0, 0.5, 0.2), smoothstep(-0.5, 0.5, rayLength * cos(angle * 6.0)));\n  }\n  \n  // Return the final color\n  return vec4(finalColor, 1.0);\n}\n\n//That looks pretty good, but the rays are inside the sun, can they instead be 12 triangles repeating around the sun?\nvec4 grass(vec2 uv) {\n  // Calculate a simple sin wave for the grass blades\n  float bladeHeight = sin(uv.x * 10.0) * 0.1 + 0.9;\n  \n  // Use the bladeHeight to calculate the color of the grass\n  vec3 grassColor = vec3(0.3, 0.6, 0.2) * bladeHeight;\n  \n  // Calculate the position of the sun in the sky\n  float sunX = 0.7;\n  float sunY = 0.2;\n  float sunRadius = 0.1;\n  \n  // Calculate the distance from the sun to the current fragment\n  float distanceToSun = distance(uv, vec2(sunX, sunY));\n  \n  // Calculate the color of the sky\n  vec3 skyColor;\n  if (distanceToSun < sunRadius) {\n    // If the fragment is inside the sun, use a bright yellow color\n    skyColor = vec3(1.0, 1.0, 0.7);\n  } else {\n    // Otherwise, use a bright blue color\n    skyColor = vec3(0.5, 0.7, 1.0);\n  }\n  \n  // Blend the sky and grass colors based on the y coordinate of the fragment\n  vec3 finalColor = mix(skyColor, grassColor, smoothstep(0.3, 0.7, uv.y));\n  \n  // Add orange rays to the sun\n  if (distanceToSun < sunRadius) {\n    // Loop through each triangle\n    for (int i = 0; i < 12; i++) {\n      // Calculate the angle of the fragment relative to the center of the sun\n      float angle = atan(uv.y - sunY, uv.x - sunX);\n      \n      // Calculate the length of the ray for the current triangle\n      float rayLength = 0.5 * distanceToSun / sunRadius;\n      \n      // Draw the ray for the current triangle\n      finalColor = mix(finalColor, vec3(1.0, 0.5, 0.2), smoothstep(-0.5, 0.5, rayLength * cos(angle * 6.0 - float(i) * 30.0)));\n      //finalColor = mix(finalColor, vec3(1.0, 0.5, 0.2), smoothstep(-0.5, 0.5, rayLength * cos(angle * 6.0 - i * 30.0)));\n    }\n  }\n  \n  // Return the final color\n  return vec4(finalColor, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Calculate the UV coordinates\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 flippedUV = vec2(uv.x, 1.-uv.y);\n  vec4 color = grass(flippedUV);\n  // Call the grass function to get the color of the grass\n  //vec4 color = grass(uv);\n  \n  // Set the output color to the color of the grass\n  fragColor = color;\n}","name":"Image","description":"","type":"image"}]}