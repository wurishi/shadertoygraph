{"ver":"0.1","info":{"id":"dljcRw","date":"1691602545","viewed":68,"name":"Dipole Field","username":"chronos","description":"Started out by trying to give a reasonable alpha value to points outside the line through a pair of points, ended up with a connection to something that looks like the field lines of magnetic dipoles and winding numbers.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["lines","number","field","dipole","winding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reduces to solving or alpha in linear interpolation if points are colinear\n// C = (1.-alpha) * A + alpha * B\nfloat get_alpha(vec2 A, vec2 B, vec2 C)\n{\n    return length(C-A) / (length(C-A) + length(B-C));\n}\n\nvec2 get_alpha_gradient_C(vec2 A, vec2 B, vec2 C)\n{\n    // Quotient rule, computing the gradient of ||C-A|| wrt C as (C-A) / ||C-A||\n    // And using linearity of the derivative\n    // N = numerator\n    // D = denominator\n    // d = derivative\n    // _C = \"function of C\" or \"by C\"\n    vec2 AC = C - A;\n    vec2 CB = B - C;\n    float N_C = length(AC);\n    float D_C = N_C + length(CB);\n    vec2 dN_C = AC / N_C;\n    vec2 dD_C = dN_C - CB / length(CB);\n    \n    vec2 df_C = (dN_C * D_C - N_C * dD_C) / (D_C * D_C); // quotient rule\n    \n    return df_C;\n}\n\nvec2 get_alpha_gradient_C_numerical(vec2 A, vec2 B, vec2 C)\n{\n    float eps = 0.001;\n    vec2 dx = vec2(1., 0.) * eps;\n    vec2 dy = vec2(0., 1.) * eps;\n    return vec2(\n        get_alpha(A, B, C + dx) - get_alpha(A, B, C - dx),\n        get_alpha(A, B, C + dy) - get_alpha(A, B, C - dy)\n    ) / (2.*eps);\n}\n\nconst float PI = 3.14159265359;\nfloat winding_number_segment(vec2 O, vec2 A, vec2 B)\n{\n    vec2 a = normalize(A-O);\n    vec2 b = normalize(B-O);\n    float d = dot(a,b);\n    float angle = acos(d);\n    angle = min(angle, 2.*PI - angle);\n    return sign(determinant(mat2(a,b))) * angle / (2. * PI);\n}\n\nfloat get_field_lines(vec2 A, vec2 B, vec2 C)\n{\n    return winding_number_segment(C,  A,  B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    vec2 A, B, C;\n    \n    A = vec2( cos(iTime*.75), sin(iTime*.75));\n    B = vec2(  1.15, -.55);\n    C = uv;\n    \n    float alpha = get_alpha( A,  B,  C);\n    \n    float potential = smoothstep(0.9, 0.95, max(sin(128.*alpha), 0.));\n    \n    float field_lines = get_field_lines(A, B, C);\n    \n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float beta = get_alpha(A, B, mouse);\n    float gamma = get_field_lines(A, B, mouse);\n    \n    color = mix(color, vec3(1), smoothstep(0.002, 0.001, abs(alpha - beta)));\n    color = mix(color, vec3(1), smoothstep(0.002, 0.001, abs(field_lines - gamma)));\n\n    vec2 alpha_grad = get_alpha_gradient_C(A,B, C);\n    \n    vec2 grad_uv = normalize(alpha_grad)*.5+.5;\n    \n    vec3 grad_color = length(alpha_grad)*vec3((grad_uv), 1. - grad_uv.x - grad_uv.y);\n    \n    color += grad_color * 1.;\n    color += potential * 0.25;\n    \n    color += smoothstep(0.91, 0.985, max(sin(256.*field_lines), 0.)) * 0.25;\n\n    fragColor = vec4(pow(color,vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}