{"ver":"0.1","info":{"id":"3ljyW3","date":"1595631672","viewed":313,"name":"Procedural Roads","username":"kastorp","description":"procedurally generated roads on  heightmap\nclick mouse to add a single  road \n \"A\" to add multiple random roadsa\n \"S\" to see territories \n \"Z\" for zoom mode","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["voronoi","road","distance","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nPROCEDURAL ROADS BY KASTORP \n\nPROOF OF CONCEPT:\ngiven a map with some POIs (points of interest, maybe towns), \n try to connect each POI to the closest one, \n where distance function is weighted by slope\n\nALGORTHM:\n1) initialize map  height\n2) divide map into squared areas, and for each one set the position of the POI \n3) from each POI, explore the neightbour and for each explored cell set \n    the distance  and the incoming direction, where distance is determined \n    by slope \n4) in case of a cell explored by two POIs, set also secondary distance\n    and incoming direction\n5) when a POI is explored by secondary POI, set the POI as linked\n    and follow the secondary path back \n6) if a secondary path encounters the primary path, follow it (only the first time)\n\nadditional road are the added from random spots, repeating step 5-6\n\nACTIONS:\n\tmouse click: add a linked point and build paths from it\n\tA: add random roads\n\tD: color by distance  \n    S: color by closest POI (like Voronoi tesselation)\n\tZ: toggle zoom mode\n\tW: show direction indicators (in zoom mode only)\n\tR: add random rivers\n*/\nMain {\n       \n    Directions\n        \n    vec2 P= U / ZOOM;\n    vec2 M = (iMouse.xy)/ZOOM;\n    if(M.x<1.)  M= R / ZOOM /2.;\n    \n    \n    bool zoomMode= !keyToggle(CH_Z);\n    if( zoomMode)     P=  (U -R/2.) /ZOOM/ZOOM2  +M; \n        \n    \n    bool odd_square = mod(floor(P.x/AREA_SIZE)+floor(P.y/AREA_SIZE)+.5,2.)>1.;\n    \n    if(min(P.x,P.y)<0. || max(P.x/RZ.x,P.y/RZ.y)>1.) {Q=vec4(0.); return;}\n    \n    vec4 data=A(P );\n    cell c = decodeCell(data);\n    \n    \n    \n    bool z =keyToggle(CH_W) && zoomMode &&!c.isTree;\n    if(c.isPOI) Q=vec4(1. *mod(iTime,1.),vec3(0.) );\n    //  circle abs(   length(floor(P) -P +.5)-.4 )<.1\n    // \n    else if(z && c.distance1 < MAX_PATH && length(floor(P) -P +.5 )<.15) Q=vec4(.5,.5,0.,1.);\n    else if(z && c.distance1 < MAX_PATH && length(floor(P) -P +.5 + d[c.direction1]*.35)<.15) Q=vec4(.5,.5,0.,1.);\n    else if(z && c.distance2 < MAX_PATH && length(floor(P) -P +.5 + d[c.direction2]*.35)<.15) Q=vec4(.5,0.,0.,1.);\n    \n    else if( zoomMode && abs(floor(P.y) -P.y +.5 + d[0].y*.4)<.1 && (c.blockedSides & 1 )!=0 ) Q=vec4(.2);\n    else if( zoomMode && abs(floor(P.x) -P.x +.5 + d[1].x*.4)<.1 && (c.blockedSides & 2 )!=0 ) Q=vec4(.2);\n    else if( zoomMode && abs(floor(P.x) -P.x +.5 + d[2].x*.4)<.1 && (c.blockedSides & 4 )!=0 ) Q=vec4(.2);\n    else if( zoomMode && abs(floor(P.y) -P.y +.5 + d[3].y*.4)<.1 && (c.blockedSides & 8 )!=0 ) Q=vec4(.2);\n       \n    else if(c.idPOI1==c.idPOI2 && c.distance1 < MAX_PATH && c.distance2 < MAX_PATH) Q=vec4(1.);\n    else if(c.isRiver) Q=vec4(.1,.8,1.,0.);\n    else if (keyDown(CH_S) && c.distance1<MAX_PATH) Q= vec4( hash(float(c.idPOI1)),hash(float(c.idPOI1+3)),0.,1.  );\n\n    //else if(c.isBlocked && c.isLinked2) Q=vec4(1.,0.,1.,0.);\n    else if(c.isLinked1 || c.isLinked2 ) Q=vec4(.8,.4,.2,0.);\n    else if(c.isBorder) Q=vec4(0.,0.,0.,0.);\n    else if(c.isFarm) Q=vec4(.8,.8,0.,0.);\n    else if(c.isTree) Q=vec4(0.,.2,0.,0.);\n\n    else if(c.isWater) Q= vec4(.1,.3, odd_square? .95:.85,0.);\n    else if (keyToggle(CH_D)) Q=vec4(mod(float(c.distance1),100.)/100.,mod(float(c.distance1),10.)/10.,mod(float(c.distance1),2.)/2.,0.);\n    else if (keyDown(CH_C)) Q=vec4(0,.6,1.-float(c.wDist)/float(MAX_PATH),0);\n    else if(c.distance1<MAX_PATH) Q= vec4(\n        step(float(MAX_PATH),float(c.distance1))/2. +step(float(MAX_PATH),float(c.distance2))/2.,\n        .7 -.7* float(c.height - WATER_LEVEL)/ (MOUNTAIN_LEVEL-float(WATER_LEVEL)),\n        .2* float(c.height - WATER_LEVEL)/ (MOUNTAIN_LEVEL-float(WATER_LEVEL)),0.);\n    else Q= vec4( float(c.height)/100.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//SETTINGS\n#define ZOOM  1.\n#define ZOOM2 6.\n#define AREA_SIZE 160.\n#define MAX_PATH 500\n#define WATER_LEVEL 30\n#define TREE_DENSITY .16\n#define MOUNTAIN_LEVEL 120.\n\n\n\n//RESOLUTION\n#define R iResolution.xy\n#define RZ (R/ZOOM)\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n//BUFFER INPUT\n#define A(U) texture(iChannel0,(U)/R)\n//#define A(U) texelFetch(iChannel0, ivec2(mod(U,R)), 0)\n\n#define Neighborhood vec4 n[9] = vec4[] \\\n\t\t(A(U+vec2(-1,1)),  A(U+vec2(0,1)),  A(U+vec2(1,1)),  \\\n         A(U+vec2(-1,0)),  A(U+vec2(0, 0)), A(U+vec2(1,0)), \\\n         A(U+vec2(-1,-1)), A(U+vec2(0,-1)), A(U+vec2(1,-1)));\n#define TS vec2(textureSize(iChannel0,0))\n \n#define Directions vec2 d[4] = vec2[] \\\n\t\t(vec2(0,1), vec2(-1,0),vec2(1,0) ,vec2(0,-1));            \n            \n//KEYBOARD\n#define CH_R 82 // add rivers\n#define CH_S 83 // show territories\n#define CH_D 68 // voronoi map  \n#define CH_A 65 // add roads\n#define CH_C 67 // show water flow map\n#define CH_Z 90 // toggle zoom\n#define CH_W 87 // show directions\n#define keyDown(k) (texelFetch(iChannel1, ivec2(k,0), 0).r>.5)\n#define keyToggle(k) (texelFetch(iChannel1, ivec2(k,2), 0).r>.5)\n            \nfloat hash(in float x) { return fract(sin(x*.0007)*29835.24389); }\nfloat hash(in vec2 x) { return hash(dot(x,vec2(23.17,17.23))); }\n\n\nvec2 hash22( vec2 p ) \n{\n    float t = hash(p);\n\treturn vec2( t,hash(t));\n}\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\nfloat fbm(vec2 uv) {\n\tfloat v = 0.6;\n    const int steps = 7;\n    for(int i = 0; i < steps; i++){\n        float factor = pow(2.,float(i + 1)) / 2.;\n    \tv += snoise(uv * factor) / factor;\n    }\n    return v / ((pow(.5,float(steps))- 1.) / -.5);\n}\n\n\nint  mapTerrain( vec2 p) {\n\n    vec2 uv =  p  / 300.;\n  \tfloat n = .1  +max(fbm(uv * 1.2 ) - .2, 0.); \n    n =  n * n * (3. - 2. * n);  \n    //n*= (.3 + snoise(p/120.)); //islands\n    //n= mix(n, .4,snoise(p/120.)); //plains\n    return int(clamp( n*MOUNTAIN_LEVEL,1.,MOUNTAIN_LEVEL));\n\n}\n\n\n//PACKING/UNPACKING         \n//from https://www.shadertoy.com/view/wsBfzW\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\n//lazy version:\n//#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(2.,s)\n//strict version (use in case of strange behaviours):\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\n\n            \n//MODEL\nstruct cell {\n\t//int id;\n    int height; //7 bit\n    bool isWater; //1 bit\n    bool isPOI; //calculated\n    bool isLinked2;\n    bool isLinked1;\n    bool isBlocked;\n    bool isBorder;\n    bool isTree;\n    bool isFarm;\n    int distance1; //8 bit\n    int direction1; //2 bit   0=UP,1=LEFT,2=RIGHT,3=DOWN\n    int idPOI1;   // 4 bit \n    int distance2; //8 bit\n    int direction2; //2 bit   0=UP,1=LEFT,2=RIGHT,3=DOWN\n    int idPOI2;   // 4 bit \n    int wDist ; //9 bit\n    int wDir; //2bit\n    bool isRiver; \n    int blockedSides; //4 bits\n};\n \ncell newCell(int h, bool isPOI, int idPOI){\n    cell o;\n    o.height=h; \n    o.isWater=(h<WATER_LEVEL); \n    o.isPOI=isPOI; //calculated\n    o.isLinked2=false;\n    o.isLinked1=false;\n    o.isBlocked=false;\n    o.isBorder=false;\n    o.isTree=false;\n    o.isFarm=false;\n    o.distance1= isPOI? 0: MAX_PATH; \n    o.direction1=0;\n    o.idPOI1=idPOI;\n    o.distance2=  MAX_PATH; \n    o.direction2=0;\n    o.idPOI2=0; \n    o.wDist=MAX_PATH;\n    o.wDir=0;\n    o.isRiver=false;\n    o.blockedSides=0;\n    return o;\n}\n\n// each cell is decoded/encoded with a texel of 4x16 bit \ncell decodeCell(vec4 t) {\n\tcell o;\n    o.height      = int(gb(t.r,0., 7.));\n    o.isWater     =(o.height< WATER_LEVEL); \n\to.isPOI       = gb(t.r,7., 1.)>.5 ;\n    o.isLinked2    = gb(t.r,8., 1.)>.5 ;\n    o.isLinked1    = gb(t.r,9., 1.)>.5 ;\n    o.isBorder    = gb(t.r,10., 1.)>.5 ;\n    o.isBlocked    = gb(t.r,11., 1.)>.5 ;\n    o.isTree      = gb(t.r,12., 1.)>.5 ;\n    o.isFarm      = gb(t.r,13., 1.)>.5 ;\n    o.distance1   = int(gb(t.g,0., 9.));\n    o.direction1  = int(gb(t.g,9., 2.));\n    o.idPOI1        = int(gb(t.g,11., 4.));  \n    o.distance2   = int(gb(t.b,0., 9.));\n    o.direction2  = int(gb(t.b,9., 2.));\n    o.idPOI2        = int(gb(t.b,11., 4.));  \n    o.wDist     = int(gb(t.a,0., 9.));\n    o.wDir    = int(gb(t.a,9., 2.));\n    o.isRiver    = gb(t.a,11., 1.)>.5 ;\n    o.blockedSides =int(gb(t.a,12., 4.));\n    return o;\n}\n\nvec4 encodeCell(cell o) {\n\tvec4 t=vec4(0.);\n    sb(t.r,0.,7.,float(o.height));\n    sb(t.r,7.,1., o.isPOI?1.:0.);\n    sb(t.r,8.,1., o.isLinked2?1.:0.);\n    sb(t.r,9.,1., o.isLinked1?1.:0.);\n    sb(t.r,10.,1., o.isBorder?1.:0.);\n    sb(t.r,11.,1., o.isBlocked?1.:0.);\n    sb(t.r,12.,1., o.isTree?1.:0.);\n    sb(t.r,13.,1., o.isFarm?1.:0.);\n    sb(t.g,0.,9.,float(o.distance1));\n    sb(t.g,9.,2.,float(o.direction1));\n    sb(t.g,11.,4.,float(o.idPOI1));\n    sb(t.b,0.,9.,float(o.distance2));\n    sb(t.b,9.,2.,float(o.direction2));\n    sb(t.b,11.,4.,float(o.idPOI2));\n    sb(t.a,0.,9.,float(o.wDist));\n    sb(t.a,9.,2.,float(o.wDir));\n    sb(t.a,11.,1., o.isRiver?1.:0.);\n    sb(t.a,12.,4., float(o.blockedSides));\n    return t;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat noise(in vec2 p) {\n\tvec2 e=vec2(1.,0.), F = floor(p), f = fract(p), k = (3. - 2.*f) * f * f;\n\treturn mix(mix(hash(F),      hash(F+e.xy), k.x),\n\t\t\t   mix(hash(F+e.yx), hash(F+e.xx), k.x), k.y);\n}\n\n\nMain {\n    Q =vec4(0.);\n    \n    Neighborhood;\n    // 0 1 2\n    // 3 4 5\n    // 6 7 8    \n    Q = n[4]; //propagate state if nothing happens\n    \n\t\t\n    //reset:\n    if (iFrame==0 || TS.x != A(vec2(0.)).z){\n\n        int height=  mapTerrain(U);\n        bool water = height<WATER_LEVEL;\n        vec2 POI_Coord0 = floor(U/AREA_SIZE)*AREA_SIZE ;\n\t\tvec2 POI_Coord = POI_Coord0 + floor(hash22(POI_Coord0 +float(iFrame))*AREA_SIZE) +.5;\n        \n     \n        bool isPOI =length(POI_Coord-U)<2. && ! water ; //&& hash(U)<.5 ;\n        \n        int idPOI = (int(U.x/AREA_SIZE)%4)*4  +int(U.y/AREA_SIZE)%4;\n        \n        //Q =vec4(height,POI? 0.:MAX_PATH+1.,0.,0.);    \n        \n        cell c = newCell(height,isPOI,idPOI);\n        \n        \n        if(water) c.wDist=0;\n        else if(height<70 && hash(U)>1. -TREE_DENSITY) c.isTree=true;\n        //packing\n        Q= encodeCell(c);\n\n        \n    } else{\n        \n        //unpacking\n        cell c = decodeCell(Q);\n        \n        bool isNLinked1=false;\n        bool isNLinked2=false;\n        \n        int blockedSides=0;\n        \n\n        \n        for(int i=1; i<8; i+=2){\n           \n\t\t\t\n            cell nc= decodeCell(n[i]);\n        \n            if(nc.isLinked1) isNLinked1=true;\n        \tif(nc.isLinked2) isNLinked2=true;\n            if(nc.isBlocked && (c.isLinked1|| c.isLinked2)) c.isBlocked=true;\n            \n            int slope =abs(nc.height-c.height);\n            if(\tnc.isWater //&& i==3\n                || (nc.height-c.height)>1\n            ) blockedSides +=  1<<(i-1)/2; // int(exp2((float(i)-1.)/2.)); \n           \n            //EXPLORATION from POI1:\n            if( //c.distance1 >=MAX_PATH\n               nc.distance1 + slope  < c.distance1 \n               && !c.isWater  \n               && slope<=1 \n               && !nc.isWater \n               && !nc.isTree\n              ) {\n                c.distance1=nc.distance1 +1+ slope;\n                c.direction1=(i-1)/2; \n                c.idPOI1=nc.idPOI1;\n            }  \n            //EXPLORATION from POI1 neightbour to POI2 current:\n            if(//c.distance1 <= nc.distance1\n                c.distance2>=MAX_PATH\n               && c.distance2>=nc.distance1 \n               && !c.isWater\n               && !nc.isTree\n               && slope<=1 \n               && !nc.isWater\n               && nc.idPOI1!= c.idPOI1\n              ) {\n                c.distance2=nc.distance1 +1+ slope;\n                c.direction2=(i-1)/2; \n                c.idPOI2=nc.idPOI1;\n            }\n           //EXPLORATION from POI2:\n            if(//c.distance2 >=MAX_PATH\n                nc.distance2 +slope < c.distance2    \n               && !c.isWater\n               && !nc.isTree\n               && slope<=1 \n               && !nc.isWater              \n              ) {\n                c.distance2=nc.distance2 +1+ slope;\n                c.direction2=(i-1)/2; \n                c.idPOI2=nc.idPOI2;\n            } \n           \n                    \n           //follow path 2\n           if(nc.isLinked2       \n               && i + (nc.direction2*2+1)==8 //opposite direction           \n              && !c.isWater \n              && ! nc.isBlocked\n             ) {\n                c.isLinked2=true;\n            } \n           \n            //switch from path 2 to path 1 is path 2 was not blocked\n            if(nc.isLinked2  \n               &&  ! c.isLinked1\n               && ! c.isWater\n               && ( i + (nc.direction1*2+1)==8   ||  i + (nc.direction2*2+1)==8  )\n               && (nc.idPOI2==c.idPOI1 || nc.idPOI1==c.idPOI2 )\n               && ! nc.isBlocked\n              ) {\n                c.isLinked1=true; //c.isBlocked=true;\n            } \n            \n            //follow path 1\n            if(nc.isLinked1 \n               && ! c.isLinked1 \n               && i + (nc.direction1*2+1)==8   \n               && !c.isWater\n               && ! nc.isBlocked\n              ) {\n                c.isLinked1=true;\n            }\t\n            \n            \n            //WATER DISTANCE:\n            int wSlope= clamp(c.height-nc.height,-1,2);\n            if(nc.wDist+2-wSlope< c.wDist\n               && wSlope>=0 \n               && nc.wDist<MAX_PATH\n               && !c.isTree\n              ) {\n            \tc.wDist=nc.wDist +2-wSlope;\n                c.wDir=(i-1)/2;\n            }\n            //RIVER:\n            if(nc.isRiver \n               && nc.wDist<MAX_PATH\n               && c.wDist<MAX_PATH\n               && i + (nc.wDir*2+1)==8 \n               && c.wDist>0\n              ){\n                c.isRiver =true;\n                c.wDist-=3;\n            }\n\n            //ADD HOUSE:\n            if((nc.isLinked1 )\n               && !c.isLinked1 \n               && nc.distance1>10 && nc.distance1<=20\n               && c.wDist<30 \n               && !c.isRiver && ! c.isWater && slope==0\n              ){\n                c.isPOI =true;  c.isTree=false; c.distance1=0; c.isBlocked=true;\n            }  \n            //FARM:\n            if(((nc.isLinked1 || nc.distance1 <=10) || nc.isFarm)\n               && c.wDist<30 \n               && !c.isRiver && ! c.isWater && !c.isPOI && slope==0\n              ){\n                c.isFarm =true; c.isTree=false;         \n            }\n\n\n        }\n        if(!c.isWater) c.blockedSides=blockedSides;\n\n        c.isBorder=false;\n        for(int i=0; i<9; i++){\n             cell nc= decodeCell(n[i]);\n            //BORDER:\n            if( i!=4 && c.distance1<MAX_PATH \n               && nc.distance1<MAX_PATH\n               && c.idPOI1!=nc.idPOI1 //&&c.idPOI1!=0\n               && !nc.isWater\n              )\n            {\n                c.isBorder=true;\n            }\n        } \n        \n    \t//Block path biforcation\n    \t//if(isNLinked2 && isNLinked1) c.isBlocked=true;\n    \n    \n        //detect LINKED POI \n        if(c.isPOI && c.distance2<MAX_PATH && c.idPOI1!= c.idPOI2 &&!c.isBlocked) c.isLinked2=true;\n           \n        //ORDER incoming POIs by distance\n        if(c.distance2<c.distance1){\n        \tint tdistance=c.distance1;\n            int tdirection= c.direction1;\n            int tPOI=  c.idPOI1;\n            c.distance1=c.distance2;\n            c.direction1=c.direction1;\n            c.idPOI1=c.idPOI2;\n            c.distance2=tdistance;\n            c.direction2=tdirection;\n            c.idPOI2=tPOI;        \n        }\n        //CLEAR DISTANCE 2 IF SAME AS 1\n        if(c.idPOI1==c.idPOI2 && c.distance1 <  c.distance2 ){\n        \tc.distance2 = MAX_PATH;\n        }\n        \n\t\t\n        //MOUSE click\n        if(keyToggle(CH_Z) && length(U- floor(iMouse.xy/ZOOM +.5))<1.) \n        { if(c.distance1<MAX_PATH) c.isLinked1=true; \n          if(c.distance2<MAX_PATH) c.isLinked2=true;\n        }\n        \n        //ADD random roads\n        if (keyDown(CH_A) ){//|| (iFrame>190 && iFrame<200)){\n            vec2 POI_Coord0 = floor(U/AREA_SIZE)*AREA_SIZE ;\n\t\t\tvec2 POI_Coord = POI_Coord0 + floor(hash22(POI_Coord0 +iTime)*AREA_SIZE) +.5;\n            if(length(U- POI_Coord)<1.) \n            { if(c.distance1<MAX_PATH) c.isLinked1=true; \n              if(c.distance2<MAX_PATH) c.isLinked2=true;\n            }\n        }\n        //ADD random rives            \n        if (keyDown(CH_R) || (iFrame>150 && iFrame<200)){\n            vec2 POI_Coord0 = floor(U/AREA_SIZE)*AREA_SIZE ;\n\t\t\tvec2 POI_Coord = POI_Coord0 + floor(hash22(POI_Coord0 +iTime*2.)*AREA_SIZE) +.5;\n            if(!c.isTree && length(U- POI_Coord)<1.\n               && (c.wDist>40 || c.height > int(MOUNTAIN_LEVEL*.8))\n               &&c.wDist<MAX_PATH && !c.isWater              \n              ) c.isRiver=true; \n              \n            \n        }\n        //packing\n        Q= encodeCell(c);\n\t\t\n    }\n    \n    \n    // save CURRENT TEXTURE SIZE\n    if(max(U.x,U.y)<1.) Q.zw= TS.xy;\n}","name":"Buffer A","description":"","type":"buffer"}]}