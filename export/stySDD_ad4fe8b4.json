{"ver":"0.1","info":{"id":"stySDD","date":"1640696405","viewed":315,"name":"Infinity isometric zoom","username":"bitless","description":"I like infinity zooms.\nAnd I like isometric.\nAnd I want something at least a little bit like a Christmas tree.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["2d","isometry","infinityzoom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: Infinity isometric zoom\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define h21(p) ( fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453) ) //hash21\n#define hue(v) ( .6 + .26 * cos(6.3*(v) + vec4(0,23,21,0) ) ) //hue\n\n#define L 4.  //cycle duration\n\n//  Minimal Hexagonal Grid - Shane\n//  https://www.shadertoy.com/view/Xljczw\nvec4 getHex(vec2 p) //hex grid coords \n{\n    vec2 s = vec2(1, 1.7320508);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nvec3 HexToSqr (vec2 st) //hexagonal cell coords to square face coords \n{ \n    vec3 r;\n    if (st.y > -abs(st.x)*.57777)\n        if (st.x > 0.) \n            r = vec3((vec2(st.x,(st.y+st.x/1.73)*.86)*2.),2); //right face\n        else\n            r = vec3(-(vec2(st.x,-(st.y-st.x/1.73)*.86)*2.),3); //left face\n    else \n        r = vec3 (-(vec2(st.x+st.y*1.73,-st.x+st.y*1.73)),0); //top face\n    return r;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 g)\n{\n\n    vec2 r = iResolution.xy\n        ,u = (g+g-r)/-r.y\n        ,t;\n    \n    float   T = mod(iTime,L) //cycle timer\n        ,   F = sin(T/L*3.14) //cycle fade 0 to 1 to 0\n        ,   m\n        ,   n = floor(iTime/L)            //num of cycle\n        ,   f = T/L                       \n        ,   k = 0.\n        ,   sm = 3./iResolution.y + F*.1; //smoothness factor + bloor during a transition \n    \n    bool p = true;  //previous layer visibility\n\n    u -= u * (length(u)*.08); //camera distortion\n    u /= exp(f*log(5.))*2.;   //camera zoom\n    u.y += -.7225;              //camera shift to centre of pyramid\n    O -= O;\n\n    vec3 s;\n\n    for (float i=0.; i <5. ; i++)  //draw 5 layers of cubes\n    {\n        t = fract(s.xy*5.)-.5;\n        m = smoothstep (3.,1.,i-f);\n        sm += i*.01;\n        O = mix (O, vec4(0),smoothstep(.45-sm,.5+sm,max(abs(t.x),abs(t.y)))*m);  //draw grid lines on previous layer\n        \n        vec4 h = getHex(u);  //hexagonal grid of curent layer\n        s = HexToSqr(h.xy);  //cube sides coordinates\n        \n        m = (p && abs(h.z)-(h.w) <= 1. && h.w < 1.) ? //cube visibility mask\n            smoothstep (4.,3.,i-f)  //hide smalless cubes\n            :0.;\n\n        O = mix (O,\n                hue(h21(h.zw+i+n+k) //color of cube \n                + h21(floor(s.xy*5.)+s.z)*.1) // + color variation on sides of cube\n                    *(1.2 + smoothstep(.7,.2,length(s.xy-.5))*.3   //light gradient on sides\n                        - smoothstep(.8,1.,s.y+s.x)*.4 //\"ambient occlusion\"\n                        - (s.z*.2)  //sides lighting variation\n                        - (i-f)*.2) //make small cubes darkest\n                        ,m);\n\n        u.y += .57804; //shift for next layer\n        h = getHex(u); \n        p = p && abs(h.z)-(h.w) <= 1. && h.w <= 1.;  //check visibility for next layer\n        u = h.xy*5.;\n        k = h21(h.zw); //color variation factor of the layers\n    }\n    \n}","name":"Image","description":"","type":"image"}]}