{"ver":"0.1","info":{"id":"ttKBD1","date":"1614286013","viewed":157,"name":"Line Tunnel","username":"Patate1er","description":"A tunnel with random lines","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","tunnel","deform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\n#define TAU 6.288531\n\nconst float f_noise = 0.1;//speed\nconst float l = 0.15;//rectangle length\nconst float l_rand = 0.25;//rectangle supplementar random length \nconst float width = 0.02;//rectangle width\nconst float smoothing = 0.005;//rectangle smooth\n\nfloat random(float seed){\n\treturn fract(sin(1.0*seed)*1000000.0);\n}\n\nfloat Square(vec2 _pos, vec2 _size, vec2 _uv,float _smooth){\n\t// bottom-left\n    vec2 bl = smoothstep(_pos-_size/2.0,_pos-_size/2.0+_smooth,_uv);\n    //top-right\n    vec2 tr = smoothstep(_pos+_size/2.0,_pos+_size/2.0-_smooth,_uv);\n    float pct = bl.x * bl.y * tr.x * tr.y;\n    return pct;\n}\n\nvec2 linePos(float _current,float _threshold, vec2 _size){\n\treturn vec2(\n        _size.x/2.0+random(_threshold*2.0)*(1.0-_size.x/2.0),\n        -(_size.y+f_noise)+(1.0+2.0*(_size.y+f_noise))*(iTime-_current)/(_threshold-_current));\n}\n\nfloat Lines(vec2 uv)\n{    \n    int nb = int(texelFetch( iChannel0, ivec2(0,0), 0 ).x);\n\n    //variable pour enregistrer les lignes dans la boucle\n    float lines;\n    \n    vec4 chan;\n    //à boucler pour chaque parties de l'image\n    for(int i=1;i<=nb;++i){\n    \tchan = texelFetch( iChannel0, ivec2(int(mod(float(i), iResolution.x)),int(floor(float(i)/iResolution.x))), 0 );\n    \t\n        float l_current = l+random(chan.g*15.0)*l_rand;\n    \tvec2 pos = linePos(chan.r,chan.g,vec2(width,l_current));\n    \tlines += Square(pos,vec2(width,l_current),uv,smoothing);\n    }\n    // Output to screen\n    return min(lines,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.2;\n    float deformation = 1.1;\n    \n    // Normalize coords from 0->1 with 0.5, 0.5 at center.\n    vec2 position = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 positionAnim;\n    if(iMouse.z<=0.0){\n        positionAnim = vec2(sin(iTime *0.5)*0.4+cos(iTime*0.7)*0.2,sin(iTime *1.2)*0.2+cos(iTime*0.45)*0.4);\n    }\n    else{\n    \tpositionAnim = 2.0 * (0.5 - iMouse.xy/iResolution.xy);\n    }\n    position += positionAnim;\n    position.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    position+=deformation * ( positionAnim  ) * pow(length( position ),2.0);\n\n    \n    // Cartesian coords to polar coords.\n    float a = atan( position.y, position.x );\n    //normalized angle\n\ta = a/TAU+.5;\n    float r = length( position );\n    \n    vec2 uv = vec2( .1 / r ,  a );\n    \n    float texSample = Lines( vec2(uv.y, 1.-uv.x) );\n    \n    // Use r to create a distance fog.\n    fragColor = vec4( vec3( r * texSample ), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(float seed){\n\treturn fract(sin(1.*seed)*1000000.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //constantes\n    const int n = 80;\n    \n    int i = int(floor(fragCoord.y) * iResolution.x + fragCoord.x);//!\\ FragCoord donne le milieu d'un pixel pas son index\n    \n    if(i == 0){\n        fragColor.r = float(n);\n    }\n    else if(i <= n){\n        vec4 c = texelFetch( iChannel0, ivec2(fragCoord.x,fragCoord.y), 0 );\n        //valeurs qui permettent de detecter le moment ou \n        //il faut supprimer l'objet et en créer un nouveau\n        float t = c.g;\n\n        //Si t > g, r prends la valeur de g et r est incrémenté aléatoirement\n        if(iTime > t){\n            float t2 = t+hash(iTime+float(i))*3.+2.;\n            c.xy = vec2(t,t2);\n            if(t==0.){\n                c.xy-=hash(iTime+1.+float(i))*t2;\n            }\n        }\n        fragColor = c;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}