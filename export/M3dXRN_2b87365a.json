{"ver":"0.1","info":{"id":"M3dXRN","date":"1718785807","viewed":89,"name":"Simple Magic circle","username":"uk0141","description":"2D to 3D practice","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","sdf","circle","magic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\n#define ID_NONE -1.\n#define BLUE 1.\n#define ORANGE 1.1\nfloat random(vec2 st){\n    return fract(sin(dot(st, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nfloat noise(vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    vec2 u = f;\n    \n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\nfloat opExtrusion( in vec3 p, in float sdf, in float h ){\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nmat2 rot(float t){\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat sdSphere(vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat c1(vec2 p){\n    float d = 10.;\n    float r = .75*(1.+.1*sin(iTime*1.6));\n    \n    p = rot(iTime/5.)*p;\n    d = min(d, max(sdSphere(p, (r+.05)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/5.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*10., 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c2(vec2 p){\n    float d = 10.;\n    float r = .69*(.95+.15*sin(iTime*1.6));\n    \n    p = rot(-iTime/3.)*p;\n    d = min(d, max(sdSphere(p, (r+.01)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/5.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - 10.*vec2(r, 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c3(vec2 p){\n    float d = 10.;\n    float r = .9*(1.+.05*sin(iTime*1.6));\n    \n    p = rot(-iTime/5.)*p;\n    d = min(d, max(sdSphere(p, (r+.005)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/3.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - 10.*vec2(r, 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c4(vec2 p){\n    float d = 10.;\n    float r = .4*(1.+.1*sin(iTime*1.6));\n    \n    p = rot(iTime/5.)*p;\n    d = min(d, max(sdSphere(p, (r+.05)*10.), -sdSphere(p, r*10.)));   \n    float angle = 2.*PI/3.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*10., 0.), 10.*vec2(.06, .08)));\n    \n    return d;\n}\n\nfloat c5(vec2 p){\n    float d = 10.;\n    float r = .95*(1.+.05*sin(iTime*1.6));\n    float n = 10.;\n    \n    float no = noise(p*7.)/5.;\n    p = rot(iTime+no)*p;\n    d = min(d, max(sdSphere(p, (r+.001)*n+no), -sdSphere(p, r*n+no)));   \n    float angle = 2.*PI/11.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*n, 0.), n*vec2(.2, .35+.3*sin(iTime*1.5))));\n    \n    return d;\n}\nfloat c6(vec2 p){\n    float d = 10.;\n    float r = .5*(1.+.1*sin(iTime*1.6));\n    float n = 10.;\n    \n    float no = noise(p*7.)/5.;\n    p = rot(-iTime+no)*p;\n    d = min(d, max(sdSphere(p, (r+.001)*n+no), -sdSphere(p, r*n+no)));   \n    float angle = 2.*PI/5.;\n    float sector = round(atan(p.y, p.x)/angle);\n    float an = angle*sector;\n    vec2 pos = rot(an)*p;\n    d = max(d, -sdBox(pos - vec2(r*n, 0.), n*vec2(.2, .35+.3*sin(iTime*1.5))));\n    \n    return d;\n}\nvec2 intersect(vec3 pos){\n    vec2 p = pos.xy;\n    float d = 10.;\n    float id = ID_NONE;\n    \n    d = min(d, c1(p));\n    \n    d = min(d, c2(p));\n    \n    d = min(d, c3(p));\n    \n    d = min(d, c4(p));\n    if(d != 10.)id = BLUE;\n    \n    if(c5(p) < d){\n        d = c5(p);\n        id = ORANGE;\n    }\n     if(c6(p) < d){\n        d = c6(p);\n        id = ORANGE;\n    }\n    \n    return vec2(id, opExtrusion(pos, d, .03));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n   vec3 col = vec3(.1, .2, .8)*mix(1., .8, smoothstep(0., 1., length(p)));\n   \n   vec3 ro = vec3(0., 4., 13.);\n   vec3 rd = vec3(p, -1.5);\n   rd.zy = rot(radians(-10.))*rd.zy;\n   rd = normalize(rd);\n   \n   #define TMIN .001\n   #define TMAX 200.\n   #define EPS .001\n   #define ITR 256.\n   \n   vec3 ray;\n   float t = TMIN;\n   for(float i = 0.;i < ITR;i++){\n       ray = ro + rd*t;\n       vec3 rayR = ray;\n       rayR.zy = rot(radians(90.))*ray.zy;\n       vec2 obj = intersect(rayR);\n       if(obj.y <2000.*EPS){\n           if(obj.x == BLUE)col += .05*vec3(.005, .01, .03)*i;\n           if(obj.x == ORANGE)col += .03*vec3(.05, .03, .005)*i;\n       }\n       \n       if(obj.y > TMAX)break;\n       t += .7*obj.y;\n   }\n\n    //col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}