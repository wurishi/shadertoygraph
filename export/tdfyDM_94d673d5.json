{"ver":"0.1","info":{"id":"tdfyDM","date":"1584970616","viewed":107,"name":"Texel Lines Bricks","username":"spalmer","description":"Trying out Oskar Stålberg's clever \"every other texel is a line\" technique from twitter:\nhttps://twitter.com/OskSta/status/1241096929490149376\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["texturing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// replicating Oskar Stålberg's clever \"every other texel is a line\" technique from twitter:\n// https://twitter.com/OskSta/status/1241096929490149376\n\n// I didn't see the other implementations of this technique\n// stressing the antialiasing and scaling or showing perspective\n// at all, or using an appropriate texture, so... here ya go!\n\n// this one is just monochromatic, though, for these simple uniformly-colored bricks\n// a real one would support all texture channels, not just x or a greyscale bitmap.\n\n    \nconst float scale = 4.\n    , spin = .01;\n\nconst int z = 4 //DataBricks.length(); //int(iChannelResolution[0].x) //\n    , m = z - 1;\n\n// abstract the texturing, so I can switch between hw and sw implementation,\n// and prevent the main uv manipulation function from including all the messiness involved\nfloat BrickTexture(ivec2 i, vec2 f)\n{\n    vec2 p = vec2(i+z) + f; // recombine, avoid origin/wrap edge for now, assumes texture big enough to tile more than once\n    p += .5; // half-texel offset is required\n    //vec2 q = p / float(z); // unscale\n   #if 1 // hw bilinear filtered texture sampling\n    float r = texture(iChannel0, p/iChannelResolution[0].xy).x;\n    // was trying to get the mipmap hardware to help out, but\n    // my manipulations just cause it to break at the seams when mips enabled\n    // now when doing this for real, you'd probably use\n    // texture(iChannelN, p/iChannelResolution[N].xy).x from above\n   #else // simple software bilinear texture directly from the array\n    // perf might be ok since texture is so tiny, but be warned, this won't scale!\n    mat2 c;\n    c[0][0] = DataBricks[i.y][i.x];\n    c[0][1] = DataBricks[i.y][h.x];\n    c[1][0] = DataBricks[h.y][i.x];\n    c[1][1] = DataBricks[h.y][h.x];\n    float r = mix(mix(c[0][0], c[0][1], f.x)\n             , mix(c[1][0], c[1][1], f.x), f.y); // software bilinear filter\n   #endif\n    return r;\n}\n\nfloat TextureBricks(vec2 q, float bias)\n{\n    vec2 p = q * float(z)\n\t, l = floor(p);\n    bias = clamp(bias, -.9999, .9999);\n    ivec2 i = ivec2(l)\n    , h = i + 1;\n    vec2 f = p - l\n    , j = vec2(i & 1)\n    , k = vec2(.5) //(j - .5) * bias //\n    , grx = dFdx(q) // measure screen space variance of q\n    , gry = dFdy(q) // along horiz and vert ss directions\n    , fw = abs(grx) + abs(gry)\n    ;\n    // bias f coordinate to make the magic happen\n    f = (j - .5) * bias + f; // * 8.*fw\n    // change width of linear transition to about 1 pixel\n    f = k + (f - .5) / (8.*fw + .001);\n    f = clamp(f, 0., 1.);\n    i &= m; h &= m; // software repeat tile uv\n    float r = BrickTexture(i, f);\n    // isotropic antialias back to some factor of bias and j\n    // when fw is really large (texture minified)\n    // since I can't seem to get mip hw to help out anyway\n    // TODO anisotropy\n    return mix(bias * .5 + .5, r, exp2(-16. * dot(fw,fw)));\n}\n\n    //p -= float(z) * (1.-step(vec2(z)-.5, p));\n\nconst float pi = 3.1415927;\n\n   \nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 R = iResolution.xy, q = (p + p - R) / R.y;\n    // must get a real texture coordinate with some perspective distortion\n    // to verify the technique works how it's supposed to,\n    // so probably need some raycast shape and some planar mapping or some other unwrap\n    // I have a cube unwrap!  But this at least does something:\n    vec2 rot = sin(vec2(.5*pi,0) + iTime * spin); \n    q = mat2(rot.x, -rot.y, rot.y, rot.x) * q; // rotate? ensure aa works\n    //q *= (dot(q,q)*dot(q,q) + 1.) * scale;\n\t//q *= (pow(.5*dot(q,q), 1.) + .125); // * scale;\n\tq.y *= q.x * q.x + scale;\n    q.x *= (abs(q.x)+1.) * scale;\n    const vec3 cgrout = vec3(.5)\n    , cbrick = vec3(.2,.05,.05);\n\t// master control of apparent thickness of line width vs. interior regions (animated)\n    float bias = pow(sin(iTime)*.5+.5, .5) * 1.9998 - 1.; //sin(iTime) * .999; //\n    if (iMouse.z >= 0. && dot(iMouse.xy, vec2(1)) > 2.)\n        bias = iMouse.x * 2. / R.x - 1.; // can also use mouse to directly affect thickness bias\n    vec3 col = mix(cgrout, cbrick, TextureBricks(q, bias));\n    o = vec4(pow(col, vec3(1.0/2.2)), 1); // to sRGB gamma\n}\n\n\n    // hopefully get the blend transition to always be 1 pixel thick also!  contrary goal, it seems.\n    // If I'm not mistaken, the original effect was to make the texture\n    // appear to have odd lines appear at a certain proportional thickness,\n    // regardless of perspective it's viewed from.\n    // So I think I already got it, basically!\n\n\t// could probably use smoothstep somehow, but linear is good and cheap\n\n\t//col = vec3((1.*dFdx(q) + 1.*dFdy(q)) * 16. + .5,0); // was debugging ss partial derivatives\n\n    // but since that lacks any mipmapping hardware, should fade out\n    // when really stretched?  so far no dice\n    // = mix(vec2(.5 + .5*bias), f, clamp(2.*fw, 0., 1.));\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 o, vec2 p)\n{\n    if (iFrame > 2) discard; // think makes thumbnail flicker?\n    float g = DataBricks[int(p.y)&3][int(p.x)&3];\n    // leave linear gamma, I guess\n    o = vec4(vec3(g), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// my \"texture\".  Could put something in BufferA and use iChannel0 but would need to do my own repeat tiling anyway because it's too large!\n\nconst vec4[4] DataBricks = vec4[4] (\n    vec4(1,0,1,1),\n    vec4(0,0,0,0),\n    vec4(1,1,1,0),\n    vec4(0,0,0,0)\n);\n\n","name":"Common","description":"","type":"common"}]}