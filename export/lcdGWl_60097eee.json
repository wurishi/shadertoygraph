{"ver":"0.1","info":{"id":"lcdGWl","date":"1713202718","viewed":39,"name":"PauOlmosDelievery","username":"Olmos","description":"Three spheres","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spheres","shaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raytracing exercise 9\nvec3 Spheres[3];\nfloat SphereRadius = 0.5;\nfloat GroundY = -0.5;\n\n//Colors\nvec3 Blue = vec3(0.6, 0.67, 0.9);\nvec3 Grey = vec3(0.7, 0.7, 0.7);\nvec3 fresnel = vec3(0.);\n\n//lights \nvec3 light = vec3(1.,1.,1.);\nfloat TAU = 6.2832;\n\n//Camera\nvec3 cameraOrigin;\n\n//Hit struct\nstruct Hit\n{\n    vec3 normals;\n    vec3 point;\n    int objectId;\n};\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n//Return true if a hit was detected with any sphere\nbool HitsSphere(in vec3 origin, in vec3 direction, inout Hit _hit, int ballId, inout float zDist )\n{\n    bool ret = false;\n\n    //Ball Vars\n    vec3 C = Spheres[ballId];\n    vec3 Oc = C - origin;\n    float r = SphereRadius;\n    \n    //Ball Formula\n    float proj = dot(Oc, normalize(direction));\n    vec3 K = origin + normalize(direction) * proj;\n    float L1 = length(C-K);\n    float L2 = sqrt(r*r - L1 * L1);\n    float tSphere = proj - L2;\n    vec3 P = origin + normalize(direction) * tSphere;\n    vec3 normals = normalize(P - C);\n    \n    float HitDepth = length(Oc + normals);\n    \n    //Print Ball\n    if(L1 < r  &&  tSphere >= 0. && (zDist >= HitDepth || zDist < 0.0))\n    {\n        _hit.normals = normals;\n        _hit.point = P;\n        _hit.objectId = ballId;\n\n        zDist = HitDepth;\n        ret = true;\n    }\n    \n    return ret;\n}\n\nbool HitsPlane(in vec3 origin, in vec3 direction, inout float tPlane, inout Hit _hit)\n{\n    bool ret = false;\n    \n    //Plane formula\n    float Py = GroundY;\n    \n    tPlane = (Py - origin.y)/(direction.y);\n    _hit.point = origin + (direction * tPlane);\n    \n    if(tPlane > 0.01)\n    {\n        _hit.objectId = -1;\n        _hit.normals = vec3(0., 1.0, 0.);\n        ret = true;\n    }\n    \n    return ret;\n}\n\nbool HitsAnySphere(vec3 origin, vec3 direction, inout Hit _hit, inout float zDepth, in int ignoreId)\n{\n    bool ret = false;\n    for(int i = 0; i < Spheres.length(); i++)\n    {\n        if(ignoreId != i && HitsSphere(origin, direction, _hit, i, zDepth))\n        {\n            ret = true;\n        }\n    }\n    return ret;\n}\n\nbool HitsAnything(in vec3 origin, in vec3 direction, inout Hit hit, in int ignoreId)\n{\n    bool ret = false;\n    float tempDepth = -1.0f;\n    float tPlane = -1.0;\n   \n    if(HitsPlane(origin, direction, tPlane, hit))\n    {\n        ret = true;\n    }\n    \n    if(HitsAnySphere(origin, direction, hit, tempDepth, ignoreId))\n    {\n        ret = true;\n    }\n       \n    return ret;\n}\n\nvec3 Fresnel(in vec3 direction, in vec3 normal)\n{\n   vec3 F0 = vec3(0.04f);\n   float cosTheta = dot(normal, -direction);\n   return F0 + (1.0-F0)*pow(1.0 - cosTheta, 5.0);\n}\n\nbool CastShadowRay(vec3 origin, vec3 direction, float maxDistance) {\n    Hit hit;\n    float zDepth = -1.0f;\n    \n    // Check for intersection with any object except the current sphere\n    if (HitsAnything(origin, direction, hit, -1)) {\n        // If the intersection is within the range of the light, return true (in shadow)\n        return length(hit.point - origin) < maxDistance;\n    }\n    \n    // If no intersection, return false (not in shadow)\n    return false;\n}\n\n\nvec3 DirectPassColor(vec3 rayDirection)\n{\n    vec3 finalColor = vec3(0.0);\n  \n    float tPlane = 0.0;\n    Hit planeHit;\n    float lightDistance = length(light - cameraOrigin); // Distance from camera to light source\n    float tileSize = 2.0f;\n    \n    \n    if(HitsPlane(cameraOrigin, rayDirection, tPlane, planeHit))\n    {\n        int ix = int(floor(planeHit.point.x / tileSize)); // Assuming each square is 0.5 units wide\n        int iz = int(floor(planeHit.point.z / tileSize)); // Assuming each square is 0.5 units long\n        bool isWhite = (ix + iz) % 2 == 0; // Check if the sum of x and z indices is even\n        \n        // Set color based on chessboard pattern\n        finalColor = isWhite ? vec3(0.9) : vec3(0.1);\n        \n        float distance = length(planeHit.point - cameraOrigin);\n        float minFogDistance = 15.0; // Minimum distance for fog to start rendering\n    \n        if (distance > minFogDistance) {\n        \n            // Apply distance fog\n            float fogDensity = 0.06; // Adjust fog density to control intensity\n            float minFogDistance = 5.0; // Minimum distance for fog to start rendering\n            float fogFactor = 1.0 - exp(-pow((distance - minFogDistance) * fogDensity, 1.0));\n            vec3 fogColor = vec3(1.0,1.0, 1.0); // Adjust fog color if needed\n            finalColor = mix(finalColor, fogColor, fogFactor);\n            \n        }\n        \n    }\n    else\n    {\n        // Calculate cloudiness based on vertical position of the ray\n        float cloudiness = noise(planeHit.point.xz * 0.4) * 0.4 + 0.0; // Adjust the factor to control cloud density\n        \n        // Mix between sky blue and white based on cloudiness\n        finalColor = mix(vec3(0.6, 0.67, 0.9), vec3(1.0), cloudiness);\n    }\n   \n   \n    //Plane shadows\n    Hit hit;\n    float zDepth = -1.0f;\n    if(HitsAnySphere(planeHit.point, light, hit, zDepth, -1))\n    {\n           finalColor = vec3(0.0f);\n    }\n    \n    //Sphere color\n    for (int i = 0; i < Spheres.length(); ++i)\n    {\n        Hit hit;\n        float currentZDepth = -1.0; // Initialize currentZDepth for each sphere\n        if (HitsSphere(cameraOrigin, rayDirection, hit, i, currentZDepth))\n        {\n        \n            // Sample texture based on UV coordinates\n            vec2 uv = hit.point.xz / SphereRadius; // Assuming UV coordinates are mapped uniformly\n            vec3 sphereColor = texture(iChannel0, uv).rgb; // Sample texture from iChannel0 (texture unit 0)\n\n            // Check if the intersection is closer than the previous one\n            if (currentZDepth < zDepth || zDepth < 2.0f)\n            {\n                zDepth = currentZDepth;\n                finalColor = sphereColor;\n            }\n        }\n    }\n        // Sphere shadows\n        for (int i = 0; i < Spheres.length(); ++i)\n        {\n            Hit sphereHit;\n            float currentZDepth = -1.0; // Initialize currentZDepth for each sphere\n            if (HitsSphere(cameraOrigin, rayDirection, sphereHit, i, currentZDepth))\n            {\n                // Calculate shadow ray direction towards the light source\n                vec3 shadowRayDirection = normalize(light - sphereHit.point);\n                \n                // Cast shadow ray from the intersection point on the sphere towards the light\n                if (CastShadowRay(sphereHit.point, shadowRayDirection, lightDistance))\n                {\n                    finalColor *= 0.75;\n                }\n            }\n        }\n    return finalColor;\n}\n\nvec3 ReflectionPassColor(vec3 rayDirection, inout vec3 aaFresnel, int maxDepth)\n{\n    // Normalize the ray direction\n    rayDirection = normalize(rayDirection);\n    \n    // Initialize the reflection color\n    vec3 reflectionColor = vec3(0.);\n    \n    // Initialize the hit structure\n    Hit hit;\n    \n    // Initialize the stack for iterative reflection calculation\n    int depth = 0;\n    int stack[10];\n    vec3 directionStack[10];\n    stack[0] = 0;\n    directionStack[0] = rayDirection;\n    \n    // Iteratively calculate reflection color\n    while (depth >= 0) {\n        // Check if the stack is empty\n        if (depth >= 10) {\n            // If the stack is full, break to avoid infinite loop\n            break;\n        }\n        \n        // Pop the top of the stack\n        int currentDepth = stack[depth];\n        vec3 currentDirection = directionStack[depth];\n        depth--;\n        \n        // Check the recursion depth to avoid excessive reflections\n        if (currentDepth < maxDepth) {\n            // Check if the ray hits anything in the scene\n            if (HitsAnything(cameraOrigin, currentDirection, hit, -1))\n            {\n                // Calculate the reflection direction\n                vec3 reflectionDirection = reflect(currentDirection, hit.normals);\n                \n                // Cast a ray in the reflection direction\n                Hit reflectionHit;\n                if (HitsAnything(hit.point, reflectionDirection, reflectionHit, -1))\n                {\n                    // Calculate the Fresnel effect\n                    aaFresnel = Fresnel(currentDirection, hit.normals);\n                    \n                    // Calculate the reflected color based on the hit point\n                    reflectionColor = vec3(dot(reflectionHit.normals, light)) * Blue;\n                    \n                    // Push the reflection direction to the stack\n                    depth++;\n                    stack[depth] = currentDepth + 1;\n                    directionStack[depth] = reflectionDirection;\n                }\n            }\n        }\n    }\n  \n    return reflectionColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ball Positions + Shading\n    Spheres[0] = vec3(-0.6f, 0., -1.1f);\n    Spheres[1] = vec3(0.0f, 0., -1.9f);\n    Spheres[2] = vec3(0.4f, 0., -0.8f);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;  \n    \n    // Camera Matrix\n    vec3 nearCoord = vec3(2.0 * (fragCoord / iResolution.xy) - 1.0, 0.0);\n    nearCoord.x *= iResolution.x/iResolution.y;\n    \n    float xAxisIncrement = 1.0 - iMouse.y / iResolution.y;\n    float yAxisIncrement = TAU * iMouse.x / iResolution.x;\n    \n    cameraOrigin = 3.0 * vec3(cos(xAxisIncrement) * cos(yAxisIncrement),\n                               sin(xAxisIncrement),\n                               cos(xAxisIncrement) * sin(yAxisIncrement));\n                                   \n    vec3 tgt = vec3(0.0, 1.0, 0.0);\n    vec3 zz = normalize(cameraOrigin - tgt);\n    vec3 xx = normalize(cross(vec3(0.0, 1.0, 0.0), zz));\n    vec3 yy = cross(zz, xx);\n    \n    // Plane Vars\n    vec3 rayDirection = normalize(xx * nearCoord.x + yy * nearCoord.y - zz * (iResolution.x / iResolution.y));\n    light = normalize(light);\n    \n    float dx = dFdx(rayDirection.x);\n    float dy = dFdy(rayDirection.y);\n    \n    vec4 finalAAColor = vec4(0.0);\n    for(int x = -1; x < 2; ++x)\n    {\n        for(int y = -1; y < 2; ++y)\n        {\n            vec3 aaPixelColor;\n            vec3 aaDirection = normalize(vec3(rayDirection.x + dx * float(x),\n                                              rayDirection.y + dy * float(y),\n                                              rayDirection.z));\n            \n            \n            aaPixelColor = DirectPassColor(aaDirection);\n            \n            // Calculate reflection color\n            vec3 reflectionFresnel;\n            vec3 reflectionColor = ReflectionPassColor(aaDirection, reflectionFresnel, 100);\n            \n            // Mix direct pass color and reflection color using Fresnel effect\n            aaPixelColor = mix(aaPixelColor, reflectionColor, reflectionFresnel);\n            \n            finalAAColor += vec4(aaPixelColor, 1.0);\n        }\n    }\n    \n    finalAAColor /= 9.0;\n\n    // Output to screen\n    fragColor = finalAAColor;\n}\n","name":"Image","description":"","type":"image"}]}