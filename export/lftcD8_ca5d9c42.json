{"ver":"0.1","info":{"id":"lftcD8","date":"1730598330","viewed":58,"name":"does this have a name?","username":"bpt","description":"just curious.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["question","nameof"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sphere intersection function\nfloat sphereIntersect(vec3 ro, vec3 rd, vec3 center, float radius) {\n    vec3 oc = ro - center;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    \n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Check if point is within volume bounds\nbool inVolume(vec3 p) {\n    return all(greaterThanEqual(p, vec3(-1.0))) && all(lessThanEqual(p, vec3(1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Camera setup\n\tfloat t = iTime * 0.5;\n    vec3 ro = vec3(2.5 * sin(t), 2.0, 2.5 * cos(t)); // Rotating camera\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Camera vectors\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    \n    // Ray direction\n    vec3 rd = normalize(uv.x * u + uv.y * v + 2.0 * w);\n    \n    // Sphere centers at cube corners\n    \n    float radius = 2.0; // Sphere radius\n    float minDist = 1e10;\n    vec3 hitPoint;\n    int hitSphere = -1;\n    \n    vec3 centers[8];\n\t\n        centers[0] = vec3(-1.0, -1.0, -1.0);\n        centers[1] = vec3( 1.0, -1.0, -1.0);\n        centers[2] = vec3(-1.0,  1.0, -1.0);\n        centers[3] = vec3( 1.0,  1.0, -1.0);\n        centers[4] = vec3(-1.0, -1.0,  1.0);\n        centers[5] = vec3( 1.0, -1.0,  1.0);\n        centers[6] = vec3(-1.0,  1.0,  1.0);\n        centers[7] = vec3( 1.0,  1.0,  1.0);\n    // Find closest sphere intersection\n    for (int i = 0; i < 8; i++) {\n        float dist = sphereIntersect(ro, rd, centers[i], radius);\n        if (dist > 0.0 && dist < minDist) {\n            vec3 p = ro + rd * dist;\n            if (inVolume(p)) {\n                minDist = dist;\n                hitPoint = p;\n                hitSphere = i;\n            }\n        }\n    }\n    \n    // Color the pixel\n    if (hitSphere >= 0) {\n        // Normalize hit point coordinates to [0,1] range\n        vec3 normalizedPos = (hitPoint + vec3(1.0)) * 0.5;\n        fragColor = vec4(normalizedPos, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}