{"ver":"0.1","info":{"id":"Xt2XDz","date":"1444151012","viewed":387,"name":"Casette Explosion","username":"rohtie","description":"Made this to generate a background for a poster I am making for a field recording festival in Norway.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","distortion","model","casette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Change to 1 if you are on windows to see a more interesting version\n#define WINDOWS 0\n\n// Enable if you want to see the casette from more angles\n#define ROTATE 0\n\n// Enable if you have a good graphics card\n#define MULTISAMPLING 0\n\n// Disable if you want to see a still frame\n#define ANIMATE 1\n#define FRAME 0.52\n\n\nfloat Sphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat Box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat RoundBox( vec3 p, vec3 b, float r ) {\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\n\nfloat Intersect ( float d1, float d2 ) {\n    return max(-d2,d1);\n}\n\nfloat Union ( float d1, float d2 ) {\n    return min(d1, d2);\n}\n\nvec3 Repeat ( vec3 p, vec3 c ) {\n    return mod(p,c)-0.5*c;\n}\n\nvec3 rotate (vec3 point) {\n    float a = iTime * 0.5;\n    \n\treturn point * mat3(1.0, 0.0, 0.0,\n                        0.0, -sin(a), cos(a),\n                       \t0.0, cos(a), sin(a));\n}\n\n\nfloat map (vec3 point) {\n    #if ROTATE\n    point = rotate(point);\n    #endif\n    \n    #if WINDOWS \n    point = Repeat(-point, -point);\n    #endif\n    \n    float casette = (\n        Union(\n            Intersect(\n                RoundBox(point, vec3(0.9, 0.5, 0.01), 0.075),\n                Union(\n                    Sphere(point + vec3(0.5, 0.1, 0.0), 0.17),\n                    Sphere(point + vec3(-0.5, 0.1, 0.0), 0.17)\n                )\n            ),\n            Box(point - vec3(0.0, 0.42, 0.0), vec3(0.8, 0.12, 0.1)) - point.y * 0.07\n        )\n    );\n    \n    #if ANIMATE\n    float frame = sin(iTime);\n    #else\n    float frame = FRAME;\n    #endif\n    \n    return mix(\n        casette, \n        Box(point, texture(iChannel0, point.xx * point.yy * point.zz).rgb), \n        -clamp(frame, 0.0, 1.0)\n    );\n}\n\nfloat intersect (vec3 rayOrigin, vec3 rayDirection) {\n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n\n    float distance = 0.0;\n    float currentDistance = 1.0;\n\n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        currentDistance = map(rayOrigin + rayDirection * distance);\n\n        distance += currentDistance;\n    }\n\n    if (distance > maxDistance) {\n        return -1.0;\n    }\n\n    return distance;\n}\n\nvec3 getNormal(vec3 point) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(point + extraPolate.xyy),\n        map(point + extraPolate.yxy),\n        map(point + extraPolate.yyx)\n    ) - map(point));\n}\n\nvec3 light = normalize(vec3(0.0, 2.0, 3.0));\n\nvec3 render(vec2 point) {\n    #if WINDOWS \n    vec3 cameraPosition = vec3(0.0, 0.0, 2.0);\n    #else\n    vec3 cameraPosition = vec3(0.0, 0.0, 1.0);\n    #endif\n    \n    vec3 rayDirection = normalize(vec3(point, -1.0));\n\n    float distance = intersect(cameraPosition, rayDirection);\n\n    vec3 col = vec3(0.0);\n\n    if (distance > 0.0) {\n        vec3 point = cameraPosition + rayDirection * distance;\n        vec3 normal = getNormal(point);\n\n        col += vec3(0.05, 0.01, 0.35);\n        col += vec3(0.7, 1.0, 0.95) * max(dot(normal, light), 0.0);\n\n        vec3 halfVector = normalize(light + normal);\n        col += vec3(1.0) * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n    } \n    else {\n        return vec3(0.0, 0.05, 0.1);\n    }\n    \n    return col;\n}\n\nvoid mainImage (out vec4 color, in vec2 point) {\n    point /= iResolution.xy;\n    point = 2.0 * point - 1.0;\n    point.x *= iResolution.x / iResolution.y;\n\t\n    #if MULTISAMPLING\n    vec3 e = vec3(0.001, 0.0, -0.001);\n    color.rgb = (\n        render(point) +\n        render(point - e.xy) + \n        render(point + e.xy) + \n        render(point + e.yx) + \n        render(point - e.yx) +\n        render(point - e.x) +\n        render(point + e.x) +\n        render(point + e.xz) +\n        render(point + e.zx)\n    ) / 9.0;\n    #else\n    color.rgb = render(point);\n    #endif\n}\n","name":"","description":"","type":"image"}]}