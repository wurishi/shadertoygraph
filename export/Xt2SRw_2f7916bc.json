{"ver":"0.1","info":{"id":"Xt2SRw","date":"1442484509","viewed":226,"name":"Types of Light","username":"jackdavenport","description":"Different types of lights in a 3D raytracer. Order (from left to right): 1) Ambient 2) Directional 3) Omnidirectional (Point) 4) Spotlight. Use mouse to visualise one light type only.\n\nThe spotlight doesn't work totally right, that could be improved.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"struct Ray {\n \n    vec3 origin;\n    vec3 direction;\n    \n};\n    \nstruct RaycastHit {\n        \n    vec3 point;\n    vec3 normal;\n    float det;\n    int type;\n        \n};\n    \nstruct Light {\n\n    vec3 pos;\n    vec3 dir;\n    float beamAngle;\n    float falloffAngle;\n    int type;\n    \n};\n    \nconst vec3 camPos = vec3(0., 0., 3.);\n\nLight directional = Light(vec3(0., 0., 0.), vec3(.3, .3, .4), 0., 0., 0);\nLight omnidirectional = Light(vec3(1.4, 2., 3.), vec3(0.), 0., 0., 1);\nLight spotlight = Light(vec3(2., 1., 3.), vec3(-3., .9, 4.), radians(5.), radians(7.), 2);    \n\nRaycastHit intersectSphere(vec3 position, float radius, const Ray ray) {\n    \n\tfloat a = dot(ray.direction, ray.direction);\n    float b = 2. * dot(ray.direction, ray.origin - position);\n    float c = dot(ray.origin - position, ray.origin - position) -(radius * radius);\n    float det = (b * b) - 4. * a * c;\n\n\tfloat lambda = (-b -sqrt(det)) / (2. * a);\n\tvec3 p = ray.origin + lambda * ray.direction;\n\tvec3 n = p - position;\n    \n    RaycastHit hit;\n    hit.point = p;\n    hit.normal = normalize(n);\n    hit.det = det;\n    hit.type = (det >= 0. && lambda >= 0.) ? 0 : -1;\n    //hit.type = det >= 0. ? 0 : -1;\n    \n    return hit;\n        \n}\n\nRaycastHit intersectPlane(vec3 position, vec3 normal, const Ray ray) {\n \n    //float num = position.y - dot(normal, ray.origin);\n\tfloat num = -dot(normal,ray.origin-position);\n    float denom = dot(normal, ray.direction);\n\tfloat t = num / denom;\n\t\t\t\n\tvec3 p = ray.origin + ray.direction * t;\t\t\n    \n    RaycastHit hit;\n    hit.point = p;\n    hit.normal = normal;\n    hit.det = t;\n    hit.type = t > 0. ? 1 : -1;\n    \n    return hit;\n    \n}\n\nfloat dist(vec3 a, vec3 b) {\n \n    float x = a.x - b.x;\n    float y = a.y - b.y;\n    float z = a.z - b.z;\n    \n    return sqrt(x*x + y*y + z*z);\n    \n}\n    \nRaycastHit minHit(RaycastHit a, RaycastHit b, vec3 ori) {\n \n    if(dist(b.point, ori) < dist(a.point, ori)) {\n     \n        return b;\n        \n    } else if(b.type != -1 && a.type == -1) {\n     \n        return b;\n        \n    }\n    \n    return a;\n    \n}\n\nRaycastHit intersect(Ray ray) {\n \n    RaycastHit sph = intersectSphere(vec3(0., 0., 0.), .6, ray);\n    RaycastHit pln = intersectPlane(vec3(0., -3., 0.), vec3(0., 1., 0.), ray);\n    \n    sph = minHit(sph, intersectSphere(vec3(1.4, 0., 0.), .6, ray), ray.origin);\n    sph = minHit(sph, intersectSphere(vec3(-1.4, 0., 0.), .6, ray), ray.origin);\n    \n    \n    return minHit(pln, sph, camPos);\n    \n}\n\nfloat lighting(RaycastHit hit, Ray ray) {\n \n    float final = .2;\n    Light theLight = Light(vec3(0.), vec3(0.), 0., 0., -1);\n    \n    vec2 scrn = gl_FragCoord.xy / iResolution.xy;\n    if(iMouse.z > 0.) scrn = iMouse.xy / iResolution.xy;\n    \n    if(scrn.x < .25) {\n\n        return final;\n        \n    } else if(scrn.x < .5) {\n        \n        theLight = directional;\n        \n    } else if(scrn.x < .75) {\n     \n        theLight = omnidirectional;\n        theLight.dir = theLight.pos - hit.point;\n        \n    } else if(scrn.x <= 1.) {\n     \n        theLight = spotlight;\n        \n    }\n    \n    const float bias = .001;\n    vec3 l = theLight.dir;\n    \n    Ray shadowRay = Ray(hit.point + (l * bias), l);\n    RaycastHit shadow = intersect(shadowRay);\n    \n    float diff = 0.;\n    \n    if(shadow.type < 0) {\n     \n        diff = max(dot(normalize(l), hit.normal), 0.);\n        \n   \t}\n    \n    if(theLight.type == 2) {\n        \n     \tvec3 surf = normalize(hit.point - theLight.pos);\n        float angle = acos(dot(surf, l));\n        \n        if(angle > theLight.beamAngle + theLight.falloffAngle) {\n         \n           diff = 0.;\n            \n        }\n        \n        if(angle > theLight.beamAngle) {\n         \n            diff *= 1. - ((angle / theLight.beamAngle) / theLight.falloffAngle);\n            \n        }\n        \n    }\n    \n    final += diff;\n    return max(min(final, 1.), 0.);\n    \n}\n\nvec4 shade(Ray ray) {\n \n    RaycastHit scene = intersect(ray);\n    vec3 refl = vec3(0.);\n    \n    if(scene.type == 0) {\n     \n        refl = reflect(normalize(ray.direction), scene.normal);\n        \n    } else if(scene.type == 1) {\n     \n        vec3 col = vec3(1., 0., 0.) * lighting(scene, ray);\n        return vec4(col, 1.);\n        \n    }\n    \n    if(refl.x != 0. && refl.y != 0. && refl.z != 0.) {\n     \n        vec3 col = vec3(1., 1., 0.) * lighting(scene, ray);\n        const float rf = .6;\n        \n\t\tRay rr = Ray(scene.point + (refl * .001), refl);\n        RaycastHit r = intersect(rr);\n        \n        if(r.type == 0) {\n         \n            col = mix(col, vec3(1., 1., 0.) * lighting(r, rr), rf);\n            \n        } else if(r.type == 1) {\n         \n            col = mix(col, vec3(1., 0., 0.) * lighting(scene, rr), rf);\n            \n        } else {\n         \n            col = mix(col, texture(iChannel0, rr.direction).xyz, rf);\n            \n        }\n        \n        return vec4(col, 1.);\n        \n    }\n    \n    return texture(iChannel0, ray.direction);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n    vec3 camDir = vec3(uv.x, uv.y, -1.);\n    \n\tfragColor = shade(Ray(camPos, camDir));\n}","name":"","description":"","type":"image"}]}