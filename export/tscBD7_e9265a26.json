{"ver":"0.1","info":{"id":"tscBD7","date":"1605279933","viewed":130,"name":"Grow Circle Mini Game","username":"rito15","description":"mini game","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circle","play","grow","smax"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CIRCLE 0\n#define HEART 1\n#define DROP 2\n#define RECT 3\n\n/**************************************************************************************************\n * Options\n **************************************************************************************************/\n\n#define CIRCLE_COUNT 20\n#define SHAPE_MODE   CIRCLE\n\nbool APPLY_SHADOW = false;\n\n/**************************************************************************************************\n * Main\n **************************************************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 해상도를 800x450에서 450x450으로 맞추고 화면 중앙 정렬하기\n    float ratioWH = iResolution.x / iResolution.y;\n    float ratioHW = iResolution.y / iResolution.x;\n    float2 adjMul = float2(ratioWH, 1.);\n    float2 adjSub = float2((1.-ratioHW) * 0.5 * ratioWH, 0.);\n    float2 uv = (fragCoord/iResolution.xy) * adjMul - adjSub;\n    \n    float3 shp = float3(0.); // 최종 모양\n    float3 col = float3(1.); // 최종 컬러\n    // => 최종 결과 = shp * col\n    \n    // uv Remap : 0. ~ 1. => -1. ~ 1.\n    float2 uv2 = uv *2. - 1.;\n    \n    \n    // == - ========================================================\n    \n    float2 mousePos = ((iMouse.xy / iResolution.xy) * adjMul - adjSub) * 2. - 1.;\n    \n    float2 uvHero;\n    uvHero = uv2 - mousePos;\n    uvHero = UvPulse(uvHero, 0.05, iTime * 10.0);\n    uvHero = UvWave(uvHero, 0.5, 0.5, 0.1, iTime * 5.0);\n    //uvHero = UvRotate(uvHero, iTime*0.2);\n    //uvHero = UvVibrate(uvHero, 10., 10., 0.1, iTime * 5.0);\n    //uvHero = UvScatter(uvHero, float2(35.0));\n    \n    float rHero = 0.2;\n    \n    // Arrays\n    float[CIRCLE_COUNT]  arrS; // Seed\n    float[CIRCLE_COUNT]  arrR; // Radius\n    float2[CIRCLE_COUNT] arrP; // Position\n    float[CIRCLE_COUNT]  arrD; // Distance Between Circle and Mouse\n    float[CIRCLE_COUNT]  arrT; // Touched?  (닿았는지 여부)\n    float[CIRCLE_COUNT]  arrC; // Contact Rate (접촉률)\n    \n    float[CIRCLE_COUNT]  arrCircle; // Circles\n    float3[CIRCLE_COUNT] arrColor;  // Colors\n    float[CIRCLE_COUNT]  arrShadow;\n    \n    float totalContact = 0.; // 접촉률 총합\n    \n    for(int i = 0; i < CIRCLE_COUNT; i++)\n    {\n        // Init Arrays\n        arrS[i] = float(i) * 123. + 0.456 * iDate.z;\n        arrR[i] = GetRandomRadius(arrS[i]);\n        arrP[i] = GetRandomPos(arrS[i], iTime);   \n        arrD[i] = length(arrP[i] - mousePos) - (rHero) * 0.4;\n        arrT[i] = step(arrD[i], arrR[i]);\n        arrC[i] = arrT[i] * (arrR[i] - arrD[i]);\n        \n        // Generate Circles\n        arrCircle[i] = Circle(uv2, arrP[i], arrR[i] - arrC[i], 0.1);\n        \n        // Generate Shadows\n        arrShadow[i] = smoothstep(1.0, 0.0, length(uv2 - arrP[i]) + (1. - arrR[i]) ) * 1.2;\n        \n        totalContact += arrC[i];\n    }\n    \n    \n    // Grow Hero Circle\n    rHero = rHero + totalContact * 0.5;\n    float debug = DebugValue(uv2, float2(-1.75, -0.95), 0.02, rHero, 2);\n    \n    // Generate Hero Circle\n    float cHero = \n        \n    #if (SHAPE_MODE == CIRCLE)\n    \n    Circle(uvHero, float2(0.), rHero, 0.1);\n    \n    #elif (SHAPE_MODE == HEART)\n    \n    lerp(Circle(uvHero, float2(0.), rHero, 0.1),\n         Heart(uvHero, float2(0.), float2(rHero), 0.5),\n         (rHero - 0.2) * 2.5\n        );\n    \n    #elif (SHAPE_MODE == DROP)\n    \n    lerp(Circle(uvHero, float2(0.), rHero, 0.1),\n         Drop(uvHero, float2(0.), float2(rHero*2.0, rHero*4.0), 0.3),\n         saturate((rHero - 0.2) * 10.)\n        );\n    \n    #elif (SHAPE_MODE == RECT)\n    \n    lerp(Circle(uvHero, float2(0.), rHero, 0.1),\n         Rect(uvHero, float2(0.), float2(rHero*2.0), 0.2),\n         (rHero - 0.2) * 2.5\n        );\n    \n    #endif\n    \n    // Shadow\n    float shdHero = smoothstep(1.0, 0.87, length(uv2 - mousePos) + (1. - rHero) );\n    \n    // Set Color of Hero\n    float3 colHero = cHero * float3(\n        R11(sin(iTime*1.), 0.5, 0.9),\n        R11(sin(iTime*2.), 0.2, 0.9),\n        R11(sin(iTime*3.), 0.2, 0.9));\n    \n    if(APPLY_SHADOW)\n    \tcolHero *= shdHero;\n        \n    // Set Colors of Circles\n    for(int i = 0; i < CIRCLE_COUNT; i++)\n    {\n        arrColor[i] = arrCircle[i] * float3(\n        R11(cos(sin(arrS[i]) * 22.), 0.2, 1.0),\n        R11(cos(sin(arrS[i]) * 33.), 0.2, 1.0),\n        R11(cos(sin(arrS[i]) * 44.), 0.2, 1.0));\n        \n        if(APPLY_SHADOW)\n        \tarrColor[i] += arrShadow[i];\n    }\n    \n    // Unite Circles\n    float circles;\n    if(CIRCLE_COUNT > 0)\n    \tcircles = smax(cHero,   arrCircle[0], 1.0);\n    \n    for(int i = 1; i < CIRCLE_COUNT; i++)\n    {\n        circles = smax(circles, arrCircle[i], 1.0);\n    }\n    \n    // Smoothness\n    float changeSmooth = sin(iTime) * 0.099;\n    shp += smoothstep(0.9 + changeSmooth, 1.0, circles );\n    \n    // Apply Colors\n    float3 mCol = colHero;\n    \n    if(CIRCLE_COUNT > 0)\n    \tmCol = max(colHero, arrColor[0]);\n    \n    for(int i = 1; i < CIRCLE_COUNT; i++)\n    {\n        mCol = max(mCol, arrColor[i]);\n    }\n    \n    col *= mCol;\n    \n    // =========================================================================\n    fragColor = vec4(shp * col + debug,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**************************************************************************************************\n * DEFINITIONS : Unity Compatibility\n **************************************************************************************************/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat3\n\n#define frac(x)     fract(x)\n#define saturate(x) clamp(x, 0., 1.)\n\n#define atan2(x,y)    atan(y,x)\n#define tex2D(s,t)    texture(s,t)\n#define mul(mat,vec)  vec*mat;\n\n#define lerp(a,b,t) mix(a,b,t)\n\n/**************************************************************************************************\n * DEFINITIONS\n **************************************************************************************************/\n#define S(a, b, t) smoothstep(a, b, t)\n\n// (0 ~ 1) => (a, b)\n#define R01(t, a, b) (b - a) * t + a\n\n// (-1 ~ 1) => (a, b)\n#define R11(t, a, b) (b - a) * (1. - t) * 0.5 + a\n\n/**************************************************************************************************\n * Digit Debug\n **************************************************************************************************/\n// 직사각형 : 좌하단, 우상단 정점 좌표\nfloat DebugRect(float2 uv, float2 p1, float2 p2, float smoothness)\n{\n    float2 center = (p1 + p2) * 0.5;\n    float  width  = (p2.x - p1.x) * 0.5;\n    float  height = (p2.y - p1.y) * 0.5;\n    \n    float rect = smoothstep(width,   width - smoothness, abs(uv.x - center.x)); // 세로\n         rect *= smoothstep(height, height - smoothness, abs(uv.y - center.y)); // 가로\n    \n    return rect;\n}\n\n// 기본 : 한 칸 채우기\nfloat DigitSquare(float2 uv, float2 center, float unit)\n{\n    unit *= 0.5;\n    float rect = 1.- step(unit + 0.0001, abs(uv.x - center.x));\n         rect *= 1.- step(unit + 0.0001, abs(uv.y - center.y));\n    return rect;\n}\n\n// 점\nfloat DigitDot(float2 uv, float2 pivot, float unit)\n{\n    return DigitSquare(uv, pivot + unit * 0.5, unit);\n}\n\n// 마이너스\nfloat DigitMinus(float2 uv, float2 pivot, float unit)\n{\n    float2 pivotPoint = pivot + unit * 0.5;\n    float m = DigitSquare(uv, pivotPoint + unit * float2(0.0, 2.0), unit) +\n              DigitSquare(uv, pivotPoint + unit * float2(1.0, 2.0), unit) +\n              DigitSquare(uv, pivotPoint + unit * float2(2.0, 2.0), unit);\n    return saturate(m);\n}\n\n// 숫자 표현 - pivot : 좌측 하단 기준점, unit : 단위 길이, digit : 정수 1개\nfloat Digit(float2 uv, float2 pivot, float unit, int digit)\n{\n    float2 pivotPoint = pivot + unit * 0.5;\n    \n    // Full Rect\n    float dgRect = DebugRect(uv, pivot, pivot + unit * float2(3.0, 5.0), 0.0001);\n    \n    // Dots\n    float dg00 = DigitSquare(uv, pivotPoint, unit);\n    float dg01 = DigitSquare(uv, pivotPoint + unit * float2(0.0, 1.0), unit);\n    float dg02 = DigitSquare(uv, pivotPoint + unit * float2(0.0, 2.0), unit);\n    float dg03 = DigitSquare(uv, pivotPoint + unit * float2(0.0, 3.0), unit);\n    float dg04 = DigitSquare(uv, pivotPoint + unit * float2(0.0, 4.0), unit);\n    float dg10 = DigitSquare(uv, pivotPoint + unit * float2(1.0, 0.0), unit);\n    float dg11 = DigitSquare(uv, pivotPoint + unit * float2(1.0, 1.0), unit);\n    float dg12 = DigitSquare(uv, pivotPoint + unit * float2(1.0, 2.0), unit);\n    float dg13 = DigitSquare(uv, pivotPoint + unit * float2(1.0, 3.0), unit);\n    float dg14 = DigitSquare(uv, pivotPoint + unit * float2(1.0, 4.0), unit);\n    float dg20 = DigitSquare(uv, pivotPoint + unit * float2(2.0, 0.0), unit);\n    float dg21 = DigitSquare(uv, pivotPoint + unit * float2(2.0, 1.0), unit);\n    float dg22 = DigitSquare(uv, pivotPoint + unit * float2(2.0, 2.0), unit);\n    float dg23 = DigitSquare(uv, pivotPoint + unit * float2(2.0, 3.0), unit);\n    float dg24 = DigitSquare(uv, pivotPoint + unit * float2(2.0, 4.0), unit);\n    \n    // Digit 0 ~ 9\n    float digit0 = dgRect - dg11 - dg12 - dg13;\n    float digit1 = dg10 + dg11 + dg12 + dg13 + dg14; //dg20 + dg21 + dg22 + dg23 + dg24;\n    float digit2 = dgRect - dg03 - dg11 - dg13 - dg21;\n    float digit3 = dgRect - dg01 - dg03 - dg11 - dg13;\n    float digit4 = dgRect - dg00 - dg01- dg10 - dg11 - dg13 - dg14;\n    \n    float digit5 = dgRect - dg01 - dg11 - dg13 - dg23;\n    float digit6 = dgRect - dg11 - dg13 - dg23;\n    float digit7 = dgRect - dg00 - dg01 - dg10 - dg11- dg12 - dg13;\n    float digit8 = dgRect - dg11 - dg13;\n    float digit9 = dgRect - dg01 - dg11 - dg13;\n    \n    switch(digit)\n    {\n        case 0: return saturate(digit0);\n        case 1: return saturate(digit1);\n        case 2: return saturate(digit2);\n        case 3: return saturate(digit3);\n        case 4: return saturate(digit4);\n        case 5: return saturate(digit5);\n        case 6: return saturate(digit6);\n        case 7: return saturate(digit7);\n        case 8: return saturate(digit8);\n        case 9: return saturate(digit9);\n    }\n    return 0.;\n}\n\n// 대상 숫자 리턴 - unit : 한 칸 단위, value : 대상 값, cipher : 소수부 출력 자릿수\nfloat DebugValue(float2 uv, float2 pos, float unit, float value, int cipher)\n{\n    uv -= pos;\n    \n    float digits = 0.; // 결괏값\n    float2 cursor = float2(0., 0.);// 현재 커서 위치\n    float2 space  = float2(unit * 4., 0.); // 공백\n    \n    // 음수처리\n    if(value < 0.)\n    {\n     \tdigits += DigitMinus(uv, cursor, unit);\n        cursor += space;\n        value = -value;\n    }\n    \n    int   valueN = int(value); \t// 정수부\n    float valueF = frac(value); // 소수부\n    \n    bool printOn = false;\n    \n    // 정수부가 0일 경우\n    if(valueN == 0)\n    {\n     \tdigits += Digit(uv, cursor, unit, 0);\n        cursor += space;\n    }\n    else\n    {\n        // 정수부 출력\n        for(int div = 1000000000; div > 0; div /= 10)\n        {\n            int d = valueN / div;\n\n            if(d > 0 || printOn)\n            {\n                printOn = true;\n                digits += Digit(uv, cursor, unit, d);\n                cursor += space;\n\n                valueN -= (d * div);\n            }\n        }\n    }\n    \n    // 소숫점\n    if(cipher > 0)\n    {\n        digits += DigitDot(uv, cursor, unit);\n        cursor += space * 0.5;\n    }\n    \n    // 소수부 출력\n    for(int i = 1; i <= cipher; i++)\n    {\n        int d = int(valueF / 0.1);\n        digits += Digit(uv, cursor, unit, d);\n        cursor += space;\n        valueF = frac(valueF * 10.);\n    }\n    \n    return digits;\n}\n\n// override : 소숫점 4자리 표현\nfloat DebugValue(float2 uv, float2 pos, float unit, float value)\n{\n \treturn DebugValue(uv, pos, unit, value, 4);   \n}\n\n/**************************************************************************************************\n * Basic Shapes\n **************************************************************************************************/\n// 원 : 중심좌표, 반지름\nfloat Circle(float2 uv, float2 center, float radius, float smoothness)\n{\n    return smoothstep(radius, radius - smoothness, length(uv - center));\n}\n\nfloat Heart(float2 uv, float2 center, float2 size, float smoothness)\n{\n    float2  uvHeart   = (uv - center) / (size * float2(1.15, 0.97));\n    float2  heartBase = float2(uvHeart.x, uvHeart.y - sqrt(abs(uvHeart.x)) * 0.7 + 0.18);\n    float heart = smoothstep(0.87, 0.87 - smoothness, length(heartBase));\n    return heart;\n}\n// 직사각형 : 중심점, 사이즈(너비, 높이)\nfloat Rect(float2 uv, float2 center, float2 size, float smoothness)\n{\n    size *= 0.5;\n    \n    float rect = smoothstep(size.x, size.x - smoothness, abs(uv.x - center.x)); // 세로\n         rect *= smoothstep(size.y, size.y - smoothness, abs(uv.y - center.y)); // 가로\n    \n    return rect;\n}\nfloat Drop(float2 uv, float2 center, float2 size, float smoothness)\n{\n    float2 uvDrop = (uv - center - float2(0., 0.2)) / (size * float2(1., 0.5));\n    uvDrop = -uvDrop;\n    \n    float k = max(min(-0.45 * (uvDrop.y - 0.5), 1.), 0.); // k = max(min(-y, 1), 0) 변형\n    float s = k * k * (2.5 - 2. * k);                     // s = k^2(3 - 2k) 변형\n    float dropBase = abs(uvDrop.x) + s;\n    float drop = smoothstep(0.5, 0.5 - smoothness, dropBase);\n    \n    // 상하 가로로 자르기\n    float dropClip = smoothstep(1.0, 0.5, abs(uvDrop.y + 0.2));\n    drop *= dropClip;\n    \n    // 물방울 하단부 원\n    float dropCircle = smoothstep(0.5, 0.5 - smoothness, length(uvDrop - float2(0., 0.5)));\n    dropCircle *= 1. - dropClip;\n    drop += dropCircle;\n    \n    drop = smoothstep(0., 1., drop);\n    \n    return drop;\n}\n/**************************************************************************************************\n * Calc Functions \n **************************************************************************************************/\n// Smooth Max\nfloat smax(float a, float b, float k)\n{\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n\n// Smooth Min\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn lerp(b, a, h) - k * h * (1.0 - h);\n}\n\n// 회전 : 기본 시계방향\nfloat2 Rotate(float2 org, float deg)\n{\n    float2x2 rotMat = float2x2(cos(deg), -sin(deg),\n                               sin(deg),  cos(deg));\n    return mul(rotMat, org);\n}\n\n/**************************************************************************************************\n * UV Functions \n **************************************************************************************************/\n// 타일링\nfloat2 UvTile(float2 uv, float2 size, float2 offset)\n{\n    return frac(uv * size) - offset;\n}\n\n// 회전\nfloat2 UvRotate(float2 uv, float rot)\n{\n    return Rotate(uv, rot);\n}\n\n// 스케일 박동\nfloat2 UvPulse(float2 uv, float range, float t)\n{\n    return uv * (1. + sin(t)* range);\n}\n\n// 꿀렁꿀렁 - a : x꿀렁, b : y꿀렁, c : 꿀렁 범위 / t : 시간\nfloat2 UvWave(float2 uv, float a, float b, float c, float t)\n{\n    float x = abs(uv.x) * a;\n    float y = abs(uv.y) * b;\n    float k;\n    \n    k = sin(x * y + t); // 기본\n    //k *= cos(x *b + cos(t)*0.5) * 0.5 + 0.5; \n    \n    float kkc = abs(k * k * c);\n    float w1 = 1. + kkc * a;\n    float w2 = 1. + kkc * b;\n    return float2(uv.x * w1, uv.y / w2);\n}\n\n// 진동\nfloat2 UvVibrate(float2 uv, float a, float b, float c, float t)\n{\n    float x = abs(uv.x) * a;\n    float y = abs(uv.y) * b;\n    float w = 1. + abs(sin(t*x * y + t) * sin(t*x * y + t) * c);\n    \n    return float2(uv.x * w, uv.y * w);\n}\n\n// 흩뿌리기\nfloat2 UvScatter(float2 uv, float2 scale)\n{\n    float x = uv.x;\n    float y = uv.y;\n    float2 s = 2. - float2(cos(x * scale) * cos(y * scale));\n    return uv * s;\n}\n\n/**************************************************************************************************\n * Functions \n **************************************************************************************************/\n\nfloat Random11(float seed, float min, float max)\n{\n    float t = frac(sin(seed * 13.421 + 23.512) * 17593.39482);\n    return lerp(min, max, t);\n}\n\nfloat GetT(float seed, float t)\n{\n    float r1 = Random11(seed, 0.1, 1.0);\n    float r2 = Random11(seed, 0.5, 1.0);\n    float r3 = Random11(seed, 0.1, 0.4);\n    \n    float k = sin( t * r1 * r2 * r3 * 1.0);\n    return k;\n}\n\nfloat2 GetRandomPos(float seed, float t)\n{\n    float seed2 = seed * 123.45;\n    return float2(GetT(seed, t), GetT(seed2, t));\n}\n\nfloat GetRandomRadius(float seed)\n{\n    return Random11(seed*0.123, 0.1, 0.3);\n}","name":"Common","description":"","type":"common"}]}