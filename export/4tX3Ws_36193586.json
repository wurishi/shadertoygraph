{"ver":"0.1","info":{"id":"4tX3Ws","date":"1434748664","viewed":2003,"name":"Satellite's eye","username":"nimitz","description":"Mouse up/down to change water level.\nMouse left/right to change influence of derivatives (left = less influence)","likes":72,"published":1,"flags":0,"usePreview":1,"tags":["terrain","map","relief"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Satellite's eye by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4tX3Ws\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\nVery few shaders on shadertoy use iq's great anylitic noise derivative technique \n(https://iquilezles.org/articles/morenoise)\n\nThe main goal was to get terrain that looks good enough at the \"continental\" scale\n*/\n\n#define time iTime\n\n#define CLOUDS\n\nvec2 mo = vec2(0);\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat noise( in vec2 x ){return textureLod(iChannel0, x*.01,0.0).x;}\n\n//for clouds\nfloat fbm( in vec2 p )\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n\tfor (float i= 1.;i<5.;i++ )\n\t{\n        rz+= (sin(noise(p)*5.)*.5+0.5)/z;\n\t\tz = z*2.3;\n        p*= m2;\n\t\tp = p*2.3;\n\t}\n\treturn rz;\n}\n\n\n//https://iquilezles.org/articles/morenoise\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    //vec2 u = f*f*f*(f*(f*6. - 15.) + 10.); //Quintic smoothsing\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain(in vec2 p)\n{\n    float a = 0.0;\n    float z = 1.;\n    vec2 bp = p;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz*mo.x;\n        a += z * n.x/(dot(d,d)+1.);\n        \n\t\tz *= .49;\n        p = m2*p*2.17;\n    }\n    \n    a += mo.y*0.5-0.15;\n    \n    a *= exp(a*1.5-2.5);\n    a = smoothstep(-0.5,.3,a)*.15 + (smoothstep(.3,.5,a)*.5) + smoothstep(.65,3.,a)*5. - smoothstep(.9,-.35,a)*.25;\n    return a;\n}\n\n\nvec3 normal(in vec2 p, in float h, in float w)\n{\n    vec2 e = vec2(w,0.);\n    return normalize( vec3( terrain(p+e.xy) - terrain(p-e.xy), h, terrain( p+e.yx)-terrain(p-e.yx) ) );\n}\n\nvec3 tex(in vec2 p)\n{\n    vec3 col = vec3(1);\n    \n    float rz = terrain(p);\n    vec2 dd = vec2(.707);\n    \n    //coastal smoothing\n    float coast = smoothstep(0.,.2, rz)-smoothstep(0.2,.65, rz);\n    \n    float dif = clamp(dot( normal(p, 0.019+coast*0.05, 0.008-coast*0.004),(vec3(dd.x,0.1,dd.y)) )*0.5+0.5,0.0,1.);\n    float dif2 = clamp(dot( normal(p, .9, .25),(vec3(dd.x,.7,dd.y)) )*0.5+0.5,0.0,1.);\n    \n    float fbm1 = fbm(p*0.75);\n    float nz = texture(iChannel0,p*iResolution.xy*0.0015).r*0.4+0.5;\n    \n    float wtr = smoothstep(-1.,.1, rz)-smoothstep(-.05,.2, rz);\n    col -= wtr*vec3(1.,0.85,.7)*1.1 + smoothstep(0.3,.7,fbm1)*0.1*wtr;\n    \n    \n    float grass = smoothstep(0.2,.6, rz)-smoothstep(0.6,.7, rz);\n    col -= (smoothstep(-1.,0.,rz)*(nz*0.5+0.5))*grass;\n    col += col*grass*vec3(0.25,0.5,0.05)*1.5;\n    \n    col -= coast*(nz*.4)*vec3(.7,.75,1.1);\n    \n    float mount = smoothstep(0.52,.7, rz);\n    col -= col*mount*vec3(.5,.75,1.)*(fbm(p*3.)-0.1)*0.45;\n    \n    col *= dif*dif2;\n    \n    #ifdef CLOUDS\n    p.y -= time*0.016;\n    const float scl = .55;\n    float clo2 = fbm(p*scl);\n    vec2 e = vec2(0.07+fbm(p*2.)*0.6,0.);\n    vec3 cldn = normalize( vec3( fbm((p+e.xy)*scl) - clo2, .3, fbm( (p+e.yx)*scl) - clo2 ) );\n    float cldif = max(dot(cldn,(vec3(dd.x,0.4,dd.y))),0.);\n    clo2 = smoothstep(.0,1.,cldif * ((cldif-clo2)*1.+0.));\n    col = mix(col, vec3(1.), clo2);\n    #endif\n    \n    col = clamp(col,0.,1.);\n    col = pow(col,vec3(.75));\n    \n    return col;\n}\n\nfloat sphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    \n    if(h <0.0) return -1.;\n    else return -b + sqrt(h);\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y*1.3;\n\tmo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.0,-0.05):mo;\n    mo.x = mo.x*0.75+0.5;\n    mo.y += mo.x*0.5;\n    \n    vec3 ro = vec3(0,0.,.66);\n    vec3 rd = normalize(vec3(p,-7.));\n    rd = rotx(rd,0.58);\n    float t = sphere(ro,rd);\n    \n    vec3 col = vec3(0);\n    if (t > 0.)\n    {\n        vec3 pos = ro + rd*t;\n        pos.xy /= pos.z;\n        pos.y -= time*0.025;\n        col = tex(pos.xy*5.);\n        \n    }\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}