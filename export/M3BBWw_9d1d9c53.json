{"ver":"0.1","info":{"id":"M3BBWw","date":"1729518569","viewed":138,"name":"A walker","username":"tanczmy","description":"Goes and goes","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["simple","animation","squares"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float customCurve(float t) {\n    // Example: Sinusoidal curve (ease-in, ease-out)\n    return 0.5 - 0.5 * cos(3.14159 * t);\n\n    // You can also try other curves like:\n    // return t * t * (3.0 - 2.0 * t);  // Quadratic ease-in-out\n    // return pow(t, 3.0);              // Cubic ease-in\n    // return pow(t, 0.5);              // Square root (ease out)\n}\n\nfloat easeOutQuint(float t) {\n    return 1.0 - pow(1.0 - t, 5.0);\n}\n\nfloat easeInOutCubic(float t) {\n    return t < 0.5 \n        ? 4.0 * t * t * t \n        : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;\n}\n\nvec3 generateColor(float seed) {\n    // Use sine waves to create smooth transitions in each RGB channel\n    float r = 0.5 + 0.5 * sin(seed + 0.0); // Red channel\n    float g = 0.5 + 0.5 * sin(seed + 2.0); // Green channel (phase-shifted)\n    float b = 0.5 + 0.5 * sin(seed + 4.0); // Blue channel (phase-shifted)\n\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float TIME_MULTI = 2.0;\n    \n    float CELL_DURATION_VARIABILITY = clamp((2.0 * sin(iTime) + 1.0) / 150.0, 0.45, 0.6);\n    \n    float CELL_DURATION = 3.5 + CELL_DURATION_VARIABILITY;\n    \n    float TIME = iTime * TIME_MULTI;\n\n    // Normalize pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Grid dimensions\n    \n    float longerDimension = max(iResolution.x, iResolution.y);\n    float shorterDimension = min(iResolution.x, iResolution.y);\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float gridSizeY = 5.0;\n    \n    float gridSize = floor(gridSizeY * aspectRatio);\n    \n    vec2 cellSize = vec2(1.0 / gridSize, 1.0 / gridSizeY);\n    \n    // Get the current cell index\n    vec2 cellIndex = floor(uv / cellSize);\n    \n    // Calculate the local UV coordinates within the cell\n    vec2 cellUV = fract(uv / cellSize);\n    \n    // Calculate the index of the cell we want to light up\n    float totalCells = gridSizeY * gridSize;\n    \n    float cellNumber = mod(floor(TIME / CELL_DURATION), totalCells);\n\n    float uniqueCellId = 0.0;\n\n    float row = floor(cellNumber / gridSize);\n    float column = mod(cellNumber, gridSize);\n    \n    // Check if the current cell is the active one\n    float brightness = 0.0;\n    \n    // Use the main square for background\n    float backgroundColorCellId = floor(TIME / CELL_DURATION);\n    \n    if(cellIndex.x == column && cellIndex.y == row) {\n        float localTime = mod(TIME, CELL_DURATION);\n        \n        // Smoothly fade from white to black\n        float t = clamp(localTime / CELL_DURATION, 0.0, 1.0);\n        // Use the custom curve function to transition brightness\n        brightness = easeOutQuint(t);\n                \n        uniqueCellId = floor(TIME / CELL_DURATION);\n    }\n    \n    // Second cell\n\n    float previousCellNumber = cellNumber - 1.0;\n\n    if(cellNumber == 0.0) {\n        previousCellNumber = totalCells - 1.0;\n    }\n\n    float previousRow = floor(previousCellNumber / gridSize);\n    float previousColumn = mod(previousCellNumber, gridSize);\n    \n    if(cellIndex.x == previousColumn && cellIndex.y == previousRow) {\n        float previouslocalTime = mod(TIME, CELL_DURATION);\n        \n        // Smoothly fade from white to black\n        float t = clamp(previouslocalTime / CELL_DURATION, 0.0, 1.0);\n        // Use the custom curve function to transition brightness\n        brightness = easeInOutCubic(t);\n        brightness = 1.0 - brightness;\n        \n        // Some nice animation\n        brightness *= abs(cos((1.0 - cos(cellUV.x + cellUV.y + iTime)) * previouslocalTime));\n\n        uniqueCellId = floor(TIME / CELL_DURATION) - 1.0;\n    }\n    \n    vec3 backgroundColor = generateColor(iTime) * clamp(sin(uv.y + iTime), 0.8, 1.0);\n    float backgroundColorStrength = 0.3;\n\n    vec3 uniqueColor = generateColor(uniqueCellId);\n\n    vec3 cellColor = brightness * uniqueColor;\n\n    vec3 finalColor = cellColor + (backgroundColor * backgroundColorStrength);\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}