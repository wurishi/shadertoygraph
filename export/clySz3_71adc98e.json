{"ver":"0.1","info":{"id":"clySz3","date":"1697750572","viewed":54,"name":"[ConcoursJFIG2023]IcingCake","username":"bowari","description":"This shader is my submission for the JFIG 2023 Shadertoy contest.\nThis shader is an great improvement on the path-tracer I posted last year for this same contest : https://www.shadertoy.com/view/sltfz4","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["concoursjfig2023"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec3 col = fragColor.xyz/fragColor.w;\n    \n    // post processing flame\n    vec3 posCam = texelFetch(iChannel0, ivec2(3%int(iResolution.x),3/int(iResolution.y)), 0).xyz;\n    \n    vec3 w = normalize(LOOKAT - posCam);\n\tvec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n\tvec3 v = normalize(cross(w, u));\n    \n    float vpSize = 2.*tan(0.5*FOVY)*FOCAL_DISTANCE;    \n    vec3 fragPos = (uv.x-0.5f)*u*vpSize*(iResolution.x/iResolution.y) + (uv.y-0.5f)*v*vpSize + posCam;\n    vec3 rayDir = normalize(fragPos-(posCam-w*FOCAL_DISTANCE));\n    \n    float t;\n    vec4 flame = vec4(0.);\n    \n    vec3 flame3_Origin = vec3(-15.1,0.,172.);\n    if(intersectPlane(rayDir,fragPos,flame3_Origin,normalize(posCam-flame3_Origin),0.,FAR,t)){\n        vec3 point = rayDir*t+fragPos;\n        vec3 tmp = flame3_Origin-point;\n        if(dot(tmp,tmp)<16.) {\n            vec2 uvFlame = 1.-(vec2(dot(u,tmp),dot(v,tmp))+4.)/8.;\n            flame += texture(iChannel2,uvFlame);\n        }\n    }\n    \n    vec3 flame0_Origin = vec3(15.1,0.,172.);\n    if(intersectPlane(rayDir,fragPos,flame0_Origin,normalize(posCam-flame0_Origin),0.,FAR,t)){\n        vec3 point = rayDir*t+fragPos;\n        vec3 tmp = flame0_Origin-point;\n        if(dot(tmp,tmp)<16.) {\n            vec2 uvFlame = 1.-(vec2(dot(u,tmp),dot(v,tmp))+4.)/8.;\n            flame += texture(iChannel2,uvFlame);\n        }\n    }\n    \n    // tone map (aces)\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    col = clamp((col * (a * col + b)) / (col * (c * col + d ) + e), 0., 1.);\n    \n    // gamma correction\n    col = pow(col,vec3(1./GAMMA));\n    \n    fragColor = vec4(mix(col,flame.xyz,flame.a),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// --- constants ---\n#define INV_PI    0.318309\n#define PI        3.141592\n#define PI_TWO    1.570796\n#define PI_THREE  1.047197\n#define PI_SIX    0.523598\n#define TWO_PI    6.283185\n\n// --- camera ---\n#define POS_CAM         vec3(0.,110.,150.)\n#define LOOKAT          vec3(0.,0.,130.)\n#define FOCAL_DISTANCE  2.5\n#define FOVY            PI_THREE\n#define DOF             0.0015\n#define GAMMA           2.2\n\n// --- others ---\n#define AA                1\n#define NB_OBJ            8.\n#define NB_BOUNCE         5\n#define MAX_STEP          100\n#define FAR               500.\n#define EPS_NORMAL        0.01\n#define EPS               0.001\n#define EPS_OH            0.0015\n\n#define Z min(iFrame,0)\n#define pow2(a) (a)*(a)\n#define pow5(a) (a)*(a)*(a)*(a)*(a)\n\nuint seed;\nbool[int(NB_OBJ)] shrinkScene;\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- RANDOM -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nuint pcg(){\n    uint state = seed*747796405U+2891336453U;\n    uint tmp  = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    return (seed = (tmp >> 22U) ^ tmp);\n}\n\nfloat rand(){return float(pcg())/float(0xffffffffU);}\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- MATERIAL -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nstruct Material{\n    vec3  albedo;           // [0, 1]\n    vec3  emissive;         // [0, +inf[\n    float metalness;        // [0, 1]\n    float roughness;        // [0, 1]\n    float transmitness;     // [0, 1]\n    vec3  absorptionColor;  // [0, 1]\n    float absorptionDensity;// [0, +inf[\n    float ior;              // [0, +inf[\n};\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- BSDF -------------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// fresnel for normal incidence cosTi = cosTo = 1\nfloat fresnel(in float ni, in float no){\n    return pow2((ni-no)/(ni+no));\n}\n\nfloat schlick(in float f0, in float f90, in float cosT){\n    return f0 + (f90-f0) * pow5(1.-cosT);\n} \n\nvec3 schlick(in vec3 f0, in vec3 f90, in float cosT){ \n\treturn f0 + (f90-f0) * pow5(1.-cosT);\n}\n\n// rough BSDF Heitz 2014 : https://inria.hal.science/hal-00996995/en\nvec3 weightedBTDF(in vec3 V, in vec3 L, in vec3 N, in vec3 H, in Material m){\n    float cosNV = max(1e-5,abs(dot(N, V))); // max 1e-5f avoid artefacts\n    float cosNL = dot(N, L);\n    float cosHN = dot(H, N);\n    float cosHL = dot(H, L);\n    float cosHV = abs(dot(H, V));\n            \n    float r = m.roughness * m.roughness;\n    float r2 = r * r;\n    \n    // ------------ TRANSMIT ------------\n    float num = 2.*cosNL;\n    float tmpV = sqrt(r2+(1.-r2)*cosNV*cosNV);\n    float tmpL = sqrt(r2+(1.-r2)*cosNL*cosNL);\n    float denom = (cosNL+tmpL) * (1.+0.5*(tmpL/cosNL-1.)+0.5*(tmpV/cosNV-1.));\n    \n    return (denom<=0.) ? vec3(0.) : m.albedo*num/denom ;\n}\n\nvec3 weightedBRDF(in vec3 V, in vec3 L, in vec3 N, in vec3 H, in Material m){    \n    float cosNV = max(1e-5,dot(N, V)); // max 1e-5f avoid artefacts\n    float cosNL = dot(N, L);\n    float cosHN = dot(H, N);\n    float cosHL = dot(H, L); \n    float cosHV = dot(H, V);\n            \n    float r = m.roughness * m.roughness;\n    float r2 = r * r;\n            \n    // ------------ CONDUCTOR ------------ : ggx+smith height correlated cosNL embedded\n    vec3 F = schlick(m.albedo, vec3(1.), cosHL);\n    float num = cosNV+sqrt((cosNV-cosNV*r2)*cosNV+r2);\n    float denom = cosNV*sqrt((cosNL-cosNL*r2)*cosNL+r2) + cosNL*sqrt((cosNV-cosNV*r2)*cosNV+r2);\n    vec3 conductor = (denom<=0.) ? vec3(0.) : cosNL*F*num/denom;\n\n    // ------------ DIELECTRIC ------------ : frostbite\n    float f90 = m.roughness*(2.*cosHL*cosHL+0.5);\n    vec3 dielectric = m.albedo * schlick(1.,f90,cosNL)*schlick(1.,f90,cosNV)*(1.-m.roughness*0.51/1.51);\n\n    return mix(dielectric, conductor, m.metalness);\n}\n\n// sampling GGX VNDF Dupuy 2023 : https://arxiv.org/pdf/2306.05044.pdf\nvec3 sampleGGXVNDF(in vec3 V, in vec3 N, float rx, float ry) {\n    // https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n    float s = (N.z>=0.) ? 1. : -1.;\n\tfloat a = -1./(s+N.z);\n\tfloat b = N.x*N.y*a;\n\tvec3 T = vec3(1.+s*N.x*N.x*a, s*b, -s*N.x);\n\tvec3 B = vec3(b,s+N.y*N.y*a, -N.y);    \n\n    V = vec3(dot(V,T), dot(V,B), dot(V,N));\n    vec3 Vh = normalize(V*vec3(rx,ry,1.));\n\n    float phi = TWO_PI*rand();\n    float z = (1.-rand())*(1.+Vh.z)-Vh.z;\n    float sinTheta = sqrt(clamp(1.-z*z,0.,1.));\n    vec3 Nh = normalize(vec3(sinTheta*cos(phi),sinTheta*sin(phi),z)+Vh);\n    vec3 Ne = normalize(Nh*vec3(rx,ry,1.));\n\n    return Ne.x*T + Ne.y*B + Ne.z*N;\n}\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- OPERATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// ****** mix ******\nfloat op_union( in float p_sdf1, in float p_sdf2 ) {\n\treturn (p_sdf1<p_sdf2) ? p_sdf1 : p_sdf2;\n}\n\nfloat op_Sunion( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 + 0.5*(p_sdf2-p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf2, p_sdf1, tmp ) - p_factor*tmp*(1.-tmp); \n}\n\nfloat op_intersection( in float p_sdf1, in float p_sdf2 ) {\n    return (p_sdf1>p_sdf2) ? p_sdf1 : p_sdf2;\n}\n\nfloat op_Sintersection( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 - 0.5*(p_sdf2-p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf2, p_sdf1, tmp ) + p_factor*tmp*(1.-tmp);  \n}\n\nfloat op_substraction( in float p_sdf1, in float p_sdf2 ) {\n    return (p_sdf1>-p_sdf2) ? p_sdf1 : -p_sdf2;\n}\n\nfloat op_Ssubstraction( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 - 0.5*(p_sdf2+p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf1, -p_sdf2, tmp ) + p_factor*tmp*(1.-tmp);  \n}\n\n// ****** transformations ******\nvec3 op_translatePoint( in vec3 p_point, in vec3 p_translation ) {\n    return p_point - p_translation;\n}\n\nvec3 op_rotatePoint( in vec3 p_point, in vec3 p_angle) {\n    vec3 c = vec3(cos(p_angle.x),cos(p_angle.y),cos(p_angle.z));\n    vec3 s = vec3(sin(p_angle.x),sin(p_angle.y),sin(p_angle.z));\n    \n    mat3 rotateX = mat3(1., 0., 0., 0., c.x, -s.x, 0., s.x, c.x);\n    mat3 rotateY = mat3(c.y, 0., s.y, 0., 1., 0., -s.y, 0., c.y);\n    mat3 rotateZ = mat3(c.z, -s.z, 0., s.z, c.z, 0., 0., 0., 1.);\n    \n    return p_point*rotateZ*rotateY*rotateX;\n}\n\n// ****** other ******\nfloat op_round( in float p_sdf, in float p_radius ){\n    return p_sdf - p_radius;\n}\n\nfloat op_onion( in float p_sdf, in float p_h ){\n    return abs(p_sdf)-p_h;\n}\n\n// ------------------------------------------------------------------------------------------\n// ------------------------------------------ SDF -------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nfloat sdf_sphere( in vec3 p_point, in float p_radius ){\n    return length(p_point)-p_radius;\n}\n\nfloat sdf_plane( in vec3 p_point, in vec3 p_normal, in float p_h ){\n    return dot(p_point,p_normal)+p_h;\n}\n\nfloat sdf_cylinder( in vec3 p_point, in float p_h, in float p_radius ){\n    vec2 tmp = vec2(length(p_point.xy)-p_radius,abs(p_point.z)-p_h);\n    return min(max(tmp.x,tmp.y),0.) + length(max(tmp,0.));\n}\n\nfloat sdf_box( in vec3 p_point, in vec3 p_bound ){\n    vec3 q = abs(p_point) - p_bound;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdf_torus( in vec3 p_point, in float p_radius, float p_thickness ){\n    return length(vec2(length(p_point.xz)-(p_radius-p_thickness*0.5), p_point.y)) - p_thickness*0.5;\n}\n\n// https://www.shadertoy.com/view/3tBcDR\nfloat sdf_ellipsoid( in vec3 p_point, in vec3 p_radius ){\n    float k = length(p_point/p_radius);\n    return (k<1.) ? (k-1.)*min(p_radius.x,min(p_radius.y,p_radius.z)) : k*(k-1.)/max(1e-3,length(p_point/(p_radius*p_radius)));\n}\n\n// ------------------------------------------------------------------------------------------\n// ------------------------------- RAY-PLANE INTERSECTION -----------------------------------\n// ------------------------------------------------------------------------------------------\n\nbool intersectPlane(in vec3 p_rayD, in vec3 p_rayO, in vec3 p_planeO, in vec3 p_planeN, in float p_tmin, in float p_tmax, inout float p_t) {\n    float d = dot(p_rayD, p_planeN);\n\tif (abs(d) > 0.f) {\n        float t = dot(p_planeO-p_rayO, p_planeN) / d;\n\t\tif(t>p_tmin && t<p_tmax) { p_t=t; return true; }\n\t}\n\treturn false;\n}\n\n// ------------------------------------------------------------------------------------------\n// -------------------------------------- ACCELERATOR ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\nbool intersectAABB( in vec3 p_d, in vec3 p_o, in vec3 p_min, in vec3 p_max, in float p_tMin, in float p_tMax ){ \n    vec3 tmin = (p_min - p_o) / p_d; // care divide by 0 !\n\tvec3 tmax = (p_max - p_o) / p_d; // care divide by 0 !\n\n\tvec3 a = min(tmin, tmax);\n\tvec3 b = max(tmin, tmax);\n\n\tfloat tnear = max(max(a.x, a.y), a.z);\n\tfloat tfar = min(min(b.x, b.y), b.z);\n\n\treturn tnear<=tfar && tfar>=p_tMin && tnear<=p_tMax;\n}\n\nvoid updateShrinkScene(in vec3 p_rayD, in vec3 p_rayO, in float p_tMin, in float p_tMax){    \n    shrinkScene[0] = intersectAABB(p_rayD,p_rayO,vec3(-150.,-230.,93.5),vec3(150.,70.,96.5),p_tMin,p_tMax);\n    shrinkScene[1] = intersectAABB(p_rayD,p_rayO,vec3(-55.,-55.,97.),vec3(55.,55.,100.),p_tMin,p_tMax);\n    shrinkScene[2] = intersectAABB(p_rayD,p_rayO,vec3(-45.,-45.,94.),vec3(45.,45.,130.),p_tMin,p_tMax);\n    shrinkScene[3] = intersectAABB(p_rayD,p_rayO,vec3(-46.,-46.,110.),vec3(46.,46.,132.),p_tMin,p_tMax);\n    shrinkScene[4] = intersectAABB(p_rayD,p_rayO,vec3(-30.,-5.,130.5),vec3(30.,5.,167.),p_tMin,p_tMax);\n    shrinkScene[5] = intersectAABB(p_rayD,p_rayO,vec3(-15.5,-1.5,165.5),vec3(15.5,1.5,168.5),p_tMin,p_tMax);\n    shrinkScene[6] = intersectAABB(p_rayD,p_rayO,vec3(69.7,-30.3,96.8),vec3(90.3,-9.7,165.2),p_tMin,p_tMax);\n    shrinkScene[7] = intersectAABB(p_rayD,p_rayO,vec3(70.,-30.,125.),vec3(90.,-10.,150.),p_tMin,p_tMax);\n}\n\n// ------------------------------------------------------------------------------------------\n// -------------------------------------- EVALUATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// Evaluate the sdf witch correspond to p_num\nfloat evaluate( in vec3 p_point, in float p_num ){\n    switch(int(p_num)){\n        case 0:\n            return sdf_cylinder(op_translatePoint(p_point,vec3(0.,-80.,95.)),1.5,150.);\n        \n        case 1:\n            float plateBase = sdf_sphere(op_translatePoint(p_point,vec3(0.,0.,115)),55.);\n            float platePlane1 = sdf_plane(p_point,vec3(0.,0.,1.),-97.);\n            float platePlane2 = sdf_plane(p_point,vec3(0.,0.,-1.),100.);\n            return op_substraction(op_onion(op_substraction(plateBase,platePlane1),1.),platePlane2);\n            \n        case 2:\n            return op_round(sdf_cylinder(op_translatePoint(p_point,vec3(0., 0., 112.)), 10., 37.), 8.);\n       \n        case 3:\n            float icingBase = op_round(sdf_cylinder(op_translatePoint(p_point,vec3(0.,0.,121.)),3.,38.),8.); \n            float icingHole1 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,0.,110.)),vec3(PI/2.,0.,0.)),105.,10.);\n            float icingHole2 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,0.,113.)),vec3(PI/2.,0.,-0.5)),105.,12.5);\n            float icingHole3 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,0.,90.)),vec3(PI/2.,0.,0.5)),105.,30.);\n            float icingHole4 = sdf_cylinder(op_rotatePoint(op_translatePoint(p_point,vec3(0.,0.,100.)),vec3(PI/2.,0.,-0.8)),105.,20.);\n            return op_Ssubstraction(op_Ssubstraction(op_Ssubstraction(op_Ssubstraction(icingBase,icingHole1,1.),icingHole2,1.),icingHole3,1.),icingHole4,1.);\n            \n        case 4:\n            float number3 = op_Sunion(\n                                op_round(sdf_box(op_translatePoint(p_point,vec3(-15.,0.,133.)),vec3(0.5,0.5,2.)),0.5),\n                                op_Ssubstraction(\n                                    op_Sunion(\n                                        sdf_torus(op_translatePoint(p_point,vec3(-15.,0.,143.)),10.,5.),\n                                        sdf_torus(op_translatePoint(p_point,vec3(-15.,0.,157.)),10.,5.),\n                                        0.5),\n                                    sdf_sphere(op_translatePoint(p_point,vec3(-25.,0.,150.)),10.),\n                                    0.5),\n                                1.);\n        \n            vec3 number0P = op_translatePoint(p_point,vec3(15.,0.,150.));\n            vec3 number0Q = number0P - clamp(number0P, -vec3(1.,1.,7.), vec3(1.,1.,7.));\n            float number0 = op_Sunion(\n                                op_round(sdf_box(op_translatePoint(p_point,vec3(15.,0.,133.)),vec3(0.5,0.5,2.)),0.5),\n                                sdf_torus(number0Q,10.,5.),\n                                0.5);\n            \n            return op_union(number3,number0);\n        \n        case 5:\n            float wickOn3 = sdf_cylinder(op_translatePoint(p_point,vec3(-15.,0.,167.)),1.5,0.5);\n            float wickOn0 = sdf_cylinder(op_translatePoint(p_point,vec3(15.,0.,167.)),1.5,0.5);\n            return op_union(wickOn3,wickOn0); \n            \n        case 6:\n            float glassTop = op_substraction(\n                                 op_onion(sdf_ellipsoid(op_translatePoint(p_point,vec3(80.,-20.,150.)),vec3(10.,10.,25.)),0.1),\n                                 sdf_plane(p_point,vec3(0.,0.,-1.),165.));\n            float glassMid = sdf_cylinder(op_translatePoint(p_point,vec3(80.,-20.,111.5)),13.5,1.);\n            float glassBot = sdf_cylinder(op_translatePoint(p_point,vec3(80.,-20.,97.5)),0.3,8.);\n            return op_Sunion(glassTop,op_Sunion(glassMid,glassBot,0.1),0.2);\n            \n        case 7:\n            return op_substraction(sdf_ellipsoid(op_translatePoint(p_point,vec3(80.,-20.,150.)),vec3(10.,10.,25.)),\n                                   sdf_plane(p_point,vec3(0.,0.,-1.),150.));\n                                   \n        default : return 1e10;\n    }\n}\n\n// Evaluate all the scene and return the distance and the id of the nearest primitive\nvec2 evaluateAll(in vec3 p_point){\n    vec2 res = vec2(1e10,-1.);\n\n    for(float i=0.; i<NB_OBJ ;i++){\n        float tmp = evaluate(p_point,i);\n        if(tmp<res.x) res = vec2(tmp,i); \n    }\n    \n    return res;\n}\n\n// Evaluate shrink scene and return the distance and the id of the nearest primitive\nvec2 evaluateScene(in vec3 p_point){\n    vec2 res = vec2(1e10,-1.);\n\n    for(float i=0.; i<NB_OBJ ;i++)\n        if(shrinkScene[int(i)]){\n            float tmp = evaluate(p_point,i);\n            if(tmp<res.x) res = vec2(tmp,i); \n        }\n    \n    return res;\n}\n\n// Evaluate shrink scene and return the distance of the nearest primitive\nfloat evaluateAny(in vec3 p_point){\n    float res = 1e10;\n    \n    for(float i=0.; i<NB_OBJ ;i++)\n        if(shrinkScene[int(i)])\n            res = min(res,evaluate(p_point,i));\n    \n    return res;\n}\n\n// Evaluate one object and find normal by computing gradient at 'p_point'\nvec3 findNormal( in vec3 p_point, in float p_hitId ){\n\treturn normalize(vec3(evaluate( p_point + vec3( EPS_NORMAL, 0., 0. ), p_hitId ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., EPS_NORMAL, 0. ), p_hitId ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., 0., EPS_NORMAL ), p_hitId ))\n\t\t\t\t\t -evaluate( p_point, p_hitId ));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer store the camera data\n// inspired by : https://www.shadertoy.com/view/wsVSDd\n\nmat3 rotationMatrix(in vec3 p_rot){\n    vec3 c = vec3(cos(p_rot.x),cos(p_rot.y),cos(p_rot.z));\n    vec3 s = vec3(sin(p_rot.x),sin(p_rot.y),sin(p_rot.z));\n    \n    mat3 rx = mat3(1., 0., 0., 0., c.x, -s.x, 0., s.x, c.x);\n    mat3 ry = mat3(c.y, 0., s.y, 0., 1., 0., -s.y, 0., c.y);\n    mat3 rz = mat3(c.z, -s.z, 0., s.z, c.z, 0., 0., 0., 1.);\n    \n    return rz*ry*rx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, iFragCoord, 0);\n    int index = iFragCoord.x+iFragCoord.y*int(iResolution.x);\n    \n    if(iFrame==0){\n        vec3 w = normalize(LOOKAT - POS_CAM);\n        vec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n        vec3 v = normalize(cross(w, u));\n    \n        if(index==0) fragColor = vec4(u,0.);       // u\n        if(index==1) fragColor = vec4(v,0.);       // v\n        if(index==2) fragColor = vec4(w,0.);       // w\n        \n        if(index==3) fragColor = vec4(POS_CAM,0.); // camPos\n        if(index==4) fragColor = vec4(LOOKAT,0.);  // lookAt\n        if(index==5) fragColor = vec4(FOCAL_DISTANCE,FOVY,DOF,1.); // camData : focalDistance,fovy,dof,isMoving\n        \n        if(index==6) fragColor = vec4(iMouse);                 // mouse data\n        if(index==7) fragColor = vec4(iResolution.xy,0.,0.);   // resolution\n    }else{\n        vec4 mouseData = texelFetch(iChannel0, ivec2(6%int(iResolution.x),6/int(iResolution.y)), 0);\n        vec2 oldResolution = texelFetch(iChannel0, ivec2(7%int(iResolution.x),7/int(iResolution.y)), 0).xy;\n        \n        float isMoving = 0.;\n        \n        if(iResolution.x != oldResolution.x || iResolution.y != oldResolution.y) isMoving = 1.;\n        \n        if(iMouse.z>=0. && mouseData.z>=0. && (iMouse.x != mouseData.x || iMouse.y != mouseData.y)){\n            vec3 cameraPosition = texelFetch(iChannel0, ivec2(3%int(iResolution.x),3/int(iResolution.y)), 0).xyz * \n                                  rotationMatrix(vec3(0.,0.,(mouseData.x-iMouse.x)*(iResolution.x/iResolution.y) * 0.005));\n            \n            vec3 w = normalize(texelFetch(iChannel0, ivec2(4%int(iResolution.x),4/int(iResolution.y)), 0).xyz - cameraPosition);\n            vec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n            vec3 v = normalize(cross(w, u));\n            \n            if(index==0) fragColor = vec4(u,0.);\n            if(index==1) fragColor = vec4(v,0.);\n            if(index==2) fragColor = vec4(w,0.);\n            \n            if(index==3) fragColor = vec4(cameraPosition,0.);\n            \n            isMoving = 1.;\n        }\n        \n        if(index==5) fragColor = vec4(fragColor.xyz,isMoving); \n        if(index==6) fragColor = vec4(iMouse);\n        if(index==7) fragColor = vec4(iResolution.xy,0.,0.);    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer render the scene by path tracing\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- MATERIAL -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nMaterial getMaterial( in vec3 p_point, in float p_num ){\n    switch(int(p_num)){\n        case 0 : // table\n            return Material(0.5*texture(iChannel2, 0.01*p_point.xy).xyz,vec3(0.),0.5,0.5,0.,vec3(1.),0.,1.5);\n    \n        case 1: // plate\n            return Material(vec3(0.8),vec3(0.),0.5,0.1,0.,vec3(1.),0.,1.5);\n\n        case 2: // cake \n            return Material(vec3(0.65,0.4,0.15),vec3(0.),0.,1.,0.,vec3(1.),0.,1.5);\n\n        case 3: // cake icing\n            return Material(vec3(1.),vec3(0.),0.,1.,0.,vec3(1.),0.,1.5);\n\n        case 4: // candle\n            return Material(vec3(0.67,0.28,0.06),vec3(0.),0.5,0.1,0.,vec3(1.),0.,1.5);\n\n        case 5: // wick\n            return Material(vec3(0.1),vec3(0.),0.,0.6,0.,vec3(1.),0.,1.5); \n\n        case 6: // glass\n            return Material(vec3(1.),vec3(0.),0.,0.01,1.,vec3(0.99),0.,1.5);\n        \n        case 7: // champagne\n            return Material(vec3(1.),vec3(0.),0.,0.2,1.,vec3(1.,0.8,0.2),0.1,1.345);\n\n        default: return Material(vec3(1.),vec3(0.),0.,1.,0.,vec3(1.),0.,1.5);\n    }  \n}\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- SKY DOME -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\n//cheap skydome from : https://www.shadertoy.com/view/tsXSRs\nvec3 skydome(vec3 p_rayD){\n    vec2 uv = vec2(atan(p_rayD.x,p_rayD.y),acos(-p_rayD.z));\n\n    const vec3 ground   = pow(vec3(0.416, 0.396, 0.382), vec3(GAMMA));\n    const vec3 horizon  = pow(vec3(0.915, 0.97, 0.99),   vec3(GAMMA));\n    const vec3 sky_low  = pow(vec3(0.827, 0.94, 0.96),   vec3(GAMMA));\n    const vec3 sky_mid  = pow(vec3(0.541, 0.637, 0.78),  vec3(GAMMA));\n    const vec3 sky_high = pow(vec3(0.403, 0.5, 0.655),   vec3(GAMMA));\n    const vec3 sky_top  = pow(vec3(0.271, 0.345, 0.482), vec3(GAMMA));\n    \n    vec3 h = vec3(0); \n    h = mix(ground, horizon, smoothstep(PI*0.5-0.02, PI*0.51, uv.y));\n    h = mix(h, sky_low,  smoothstep(PI*0.5-0.02, PI*0.53, uv.y));\n    h = mix(h, sky_mid,  smoothstep(PI*0.5, PI*0.6, uv.y));\n    h = mix(h, sky_high, smoothstep(PI*0.52, PI*0.8, uv.y));\n    h = mix(h, sky_top,  smoothstep(PI*0.54, PI, uv.y));\n    \n    return 0.25+mix(h+sky_low*0.01, h, smoothstep(PI*0.2, PI*0.6, uv.y));\n}\n\n// ------------------------------------------------------------------------------------------\n// ---------------------------------------- RENDER ------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nvec3 trace( in vec3 p_rayD, in vec3 p_rayO){\n    vec3 totalColor = vec3(0.);\n    vec3 rayColor   = vec3(1.);\n    \n    updateShrinkScene(p_rayD,p_rayO,0.,FAR);\n    vec2 hit = evaluateScene(p_rayO);\n    bool isInside = hit.x<0.;\n    float numInside = hit.y;\n    float t = abs(hit.x);\n    \n    float no;\n    float ni = (isInside) ? getMaterial(p_rayO,hit.y).ior : 1.;\n\n    for(int i=Z; i<NB_BOUNCE ;i++){\n        for(int nbStep=Z; nbStep<MAX_STEP ;nbStep++){\n            vec3 point = t*p_rayD + p_rayO;\n            hit = (isInside ? vec2(evaluate(point,numInside),numInside) : evaluateScene(point));\n            \n            if(abs(hit.x)<EPS){            \n                Material m = getMaterial(point,hit.y);\n                totalColor += m.emissive*rayColor;\n                if(isInside) rayColor *= exp(-(1.-m.absorptionColor)*(t+abs(hit.x))*m.absorptionDensity);\n                \n                vec3 V = -p_rayD;\n                vec3 N = findNormal(point, hit.y)*((isInside) ? -1. : 1.);\n                if(dot(N,V)<0.) return totalColor; // avoid artefacts          \n                vec3 H = sampleGGXVNDF(V,N,m.roughness,m.roughness);\n                \n                vec3 pointOffsetRefract = point-N*(EPS_OH+abs(hit.x));\n                vec3 pointOffsetReflect = point+N*(EPS_OH-abs(hit.x));\n\n                vec2 hitNo = evaluateAll(pointOffsetRefract); \n                bool isInsideNo = hitNo.x<0.;\n                no = (isInsideNo) ? getMaterial(pointOffsetRefract,hitNo.y).ior : 1.;\n\n                if (rand() <= 1.-m.transmitness*(1.-m.metalness)*(1.-schlick(fresnel(ni,no),1.,dot(N,V))) || length(refract(-V,H,ni/no))==0.) {\n                    t = 0.;\n                    p_rayO = pointOffsetReflect;\n                    p_rayD = normalize(reflect(-V,H));\n                    \n                    if(dot(p_rayD,N)<0.) return totalColor; // avoid artefacts\n                    \n                    rayColor *= weightedBRDF(V,p_rayD,N,H,m);\n                } else {\n                    t = abs(hitNo.x);\n                    p_rayO = pointOffsetRefract;\n                    p_rayD = normalize(refract(-V,H,ni/no));\n                    \n                    if (dot(p_rayD,-N)<0.) return totalColor; // avoid artefacts\n                    rayColor *= weightedBTDF(V,p_rayD,-N,-H,m);\n                    \n                    isInside = isInsideNo;\n                    if(isInside) numInside = hitNo.y;\n                    ni = no;\n                }\n                updateShrinkScene(p_rayD,p_rayO,0.,FAR);\n                break;\n            }\n\n            t += abs(hit.x);\n            if(t>FAR) return totalColor+rayColor*(skydome(p_rayD));\n            if(nbStep == MAX_STEP) return totalColor;\n        }\n    }\n    \n    return totalColor;\n}\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- MAIN -------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    // --- setup --- \n    seed = uint(iFrame*(int(iResolution.x*iResolution.y)))+uint(fragCoord.x+fragCoord.y*iResolution.x);\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 posCam = texelFetch(iChannel0, ivec2(3%int(iResolution.x),3/int(iResolution.y)), 0).xyz;\n\n    // --- camera ---    \n    vec3 w = normalize(LOOKAT - posCam);\n\tvec3 u = normalize(cross(w, vec3(0.,0.,-1.)));\n\tvec3 v = normalize(cross(w, u));\n    \n    // dof from : https://www.shadertoy.com/view/XlcfRs\n    float theta = TWO_PI*rand();\n    float phi = acos(1.-rand()*(1.-cos(DOF)));\n    w = u*sin(phi)*cos(theta) + v*sin(phi)*sin(theta) + w*cos(phi);\n    \n    float vpSize = 2.*tan(0.5*FOVY)*FOCAL_DISTANCE;\n    vec3 vpV = v * vpSize;\n    vec3 vpU = u * vpSize * (iResolution.x/iResolution.y);\n    \n    // --- trace ---    \n    fragColor = (texelFetch(iChannel0, ivec2(5%int(iResolution.x),5/int(iResolution.y)), 0).w==1.) ? vec4(0.) : texelFetch(iChannel1, ivec2(fragCoord), 0);\n    for(int a=0; a<AA ;a++)\n        for(int b=0; b<AA ;b++){\n            float sx = uv.x + (float(a)+rand())/(iResolution.x*float(AA));\n            float sy = uv.y + (float(b)+rand())/(iResolution.y*float(AA));\n            vec3 fragPos = (sx-0.5f)*vpU + (sy-0.5f)*vpV + posCam;\n            vec3 rayDir = normalize(fragPos-(posCam-w*FOCAL_DISTANCE));\n            fragColor += vec4(trace(rayDir, fragPos),1.);\n        }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// This buffer render the texture of flame \n// Source code : https://www.shadertoy.com/view/Xd3GD4\n\nvec2 hash22( vec2 p ){\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn 2.*fract(sin(p)*43758.5453123)-1.;\n}\n\nfloat noise( in vec2 p ){\n\tvec2 i = floor( p + (p.x+p.y)*0.36602540 );\n\tvec2 a = p - i + (i.x+i.y)*0.21132486;\n\tvec2 o = (a.x>a.y) ? vec2(1.,0.) : vec2(0.,1.);\n\tvec2 b = a - o + 0.21132486;\n\tvec2 c = a - 0.57735027;\n\tvec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.);\n\tvec3 n = h*h*h*h*vec3( dot(a,hash22(i+0.)), dot(b,hash22(i+o)), dot(c,hash22(i+1.)));\n\treturn dot( n, vec3(70.) );\n}\n\nfloat fbm(vec2 uv){\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5*noise( uv ); uv = m*uv;\n\tf += 0.25*noise( uv ); uv = m*uv;\n\tf += 0.125*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv;\n\tfloat strength = floor(q.x+1.);\n\tfloat T3 = max(2.,strength)*iTime;\n    q.x -= 0.5;\n\tq.y -= 0.1; \n\tfloat n = fbm(strength*q - vec2(0.,T3));\n\tfloat c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+0.25 ) ),1.2 );\n\tfloat c1 = clamp(n * c * (1.5-pow(2.25*uv.y,4.)),0.,1.);\n\tvec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n\tcol= mix(col, pow(vec3(1.-clamp(c1, -1., 0.)) * pow(fbm(strength*q*1.25 - vec2(0,T3)),2.),vec3(2.)), 0.75-(col.x+col.y+col.z)/3.);\n\tfloat a = c * (1.-uv.y*uv.y*uv.y);\n    fragColor = vec4(col,(0.001>a) ? 0. : a);\n}","name":"Buffer C","description":"","type":"buffer"}]}