{"ver":"0.1","info":{"id":"Nt3fWX","date":"1663730910","viewed":59,"name":"physically based rendering :)","username":"purplejragon","description":"physically based rendering","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shading","lights","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float map(vec3 p)\n{\n    vec3 b = vec3(1.0, 0.1, 0.8);\n    vec3 q = abs(p - vec3(-0.7, -0.65, 0)) - b;\n    float t = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    \n    vec3 a = vec3(1.1, 2.0, 0);\n    b = vec3(-2, -2, 0);\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    t = min(t, length( pa - ba*h ) - 0.4);\n    \n    return t;\n}\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.001;\n    for (int i = 0; i < 800; i++)\n    {\n        float dist = map(ro + rd * t);\n        t += dist;\n        if (dist < 0.001) return t;\n        if (t > 100.0) return -1.0;;\n    }\n    return -1.0;\n}\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float t = 0.001;\n    float res = 1.0;\n    for (int i = 0; i < 1000; i++) {\n        float dist = map(ro + rd * t);\n        if (dist < 0.001) return 0.0;\n        if (t > 100.0) return res;\n        res = min( res, k*dist/t );\n        t += dist;\n    }\n    return res;\n}\nvec3 calcNormal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    LightSource lss[2];\n    lss[0] = LightSource(2, vec3(-1, 1, -0.5), vec3(5, 5, 5));    \n    lss[1] = LightSource(2, vec3(1, -1, 2), vec3(0.5, 0.5, 0.7));\n\n    vec3 ro = vec3(-2, 0, 0.75);\n    mat3 lookAt = lookAt(ro, vec3(-1, 0, 0), 0.0); \n    vec3 rd = normalize(\n        vec3((fragCoord - 0.5 * iResolution.xy) / iResolution.y, -0.5) * lookAt);\n    \n    vec3 col = vec3(0);\n    float t = raymarch(ro, rd);\n    \n    vec3 albedo = vec3(137, 207, 240) / 255.0;\n    float roughness = 0.4;    \n    float metallic = 0.8;\n        \n    if (t > 0.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        float rustThreshold = 0.6;\n        float rust = fbm(p.xy*p.zx, 6);\n        rust *= 0.5;\n        albedo = mix(albedo, vec3(183, 65, 14) / 255.0, rust);\n        roughness = mix(roughness, 0.9, rust);\n        vec3 v = -rd;\n        //vec2 uv = 0.5 + vec2(atan(n.z, n.x) / (2.0 * PI), asin(p.y) / PI);\n        for (int i = 0; i < lss.length(); i++) {\n            vec3 l = lss[i].type == LS_DIRECTIONAL ? \n                normalize(lss[i].position) : normalize(lss[i].position - p);    \n            vec3 h = normalize(v + l);\n            float d = ggx(roughness * roughness, n, h);\n            float g = schlickGGX(n, v, roughness) * schlickGGX(n, l, roughness);\n            vec3 f = fresnel(mix(vec3(0.04), albedo, metallic), n, v);\n            \n            vec3 kD = (1.0 - f) * (1.0 - metallic);\n            \n            vec3 lambertian = albedo / PI;\n            vec3 cookTorrance = (d * g * f) / (4.0 * cdot(n, l) * cdot(n, v) + 0.0001); \n            vec3 radiance = lss[i].color;\n            radiance *= 1.0 / pow(distance(p, lss[i].position), 2.0);\n            radiance *= shadow(p + n * 0.001, l, 32.0);\n            col += (kD * lambertian + cookTorrance) * cdot(n, l) * radiance;\n        }\n        col += vec3(0.01) * albedo;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n#define LS_POINT 1\n#define LS_DIRECTIONAL 2\n#define E 2.71828\nfloat rand(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 st)\n{\n    vec2 i = floor(st);\n    vec2 f = smoothstep(0.0, 1.0, fract(st));\n    \n    float bl = rand(i);\n    float br = rand(i + vec2(1, 0));\n    float b = mix(bl, br, f.x);\n    \n    float tl = rand(i + vec2(0, 1));\n    float tr = rand(i + vec2(1, 1));\n    float t = mix(tl, tr, f.x);\n    \n    return mix(b, t, f.y);\n}\nfloat fbm(vec2 st, int octaves)\n{\n    float n = 0.0;\n    float amp = 1.0;\n    float freq = 4.0;\n    float total;\n    for (int i = 0; i < octaves; i++)\n    {\n        n += noise(st*freq)*amp;\n        total += amp;\n        amp /= 2.0;\n        freq *= 2.0;\n    }\n    return n / total;\n    return noise(st*4.0);\n}\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    return mat3(-uu, vv, -ww);\n}\nfloat cdot(vec3 a, vec3 b) {\n    return max(0.0, dot(a, b));\n}\nstruct LightSource {\n    int type;\n    vec3 position;\n    vec3 color;\n};\n\n\n\n\n\n\n\n\nfloat ggx(float a, vec3 n, vec3 h) {\n    float a2 = a * a;\n    float nh2 = pow(cdot(n, h), 2.0);\n    return a2 / (PI * pow(nh2*(a2-1.0)+1.0,2.0));\n}\nfloat schlickGGX(vec3 n, vec3 v, float roughness) {\n    float k = pow(roughness + 1.0, 2.0) / 8.0;\n    float nv = cdot(n, v);\n    return nv / (nv * (1.0 - k) + k);\n}\nvec3 fresnel(vec3 R0, vec3 n, vec3 v) {\n    return R0 + (1.0 - R0) * pow(1.0 - cdot(n, v), 5.0);\n}","name":"Common","description":"","type":"common"}]}