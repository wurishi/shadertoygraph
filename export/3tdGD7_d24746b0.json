{"ver":"0.1","info":{"id":"3tdGD7","date":"1576564210","viewed":271,"name":"MSAA 12162019","username":"bad_dreams_","description":"üèÅ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["msaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float checkerboard(vec2 uv) {\n    vec2 adjusted = floor(uv);\n \tbool inside = mod(adjusted.y, 2.0) == 1.0\n\t\t? mod(adjusted.x, 2.0) == 0.0\n        : mod(adjusted.x, 2.0) == 1.0;\n    return inside ? 1.0 : 0.0;\n}\n\nstruct HitResult { bool hit; vec3 point; };\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Plane { vec3 origin; vec3 normal; };\n\nmat4 rotateY(float angle) {\n \tfloat x = cos(angle);\n    float y = sin(angle);\n    return mat4(\n\t\ty, 0,-x, 0,\n        0, 1, 0, 0,\n        x, 0, y, 0,\n        0, 0, 0, 1\n     );\n}\n\nHitResult rayPlaneIntersect(Ray ray, Plane plane) {\n \tfloat horizonDot = dot(ray.direction, plane.normal);\n    if (horizonDot < 0.00001) {\n\t\tvec3 difference = plane.origin - ray.origin;\n        float time = dot(difference, plane.normal) / horizonDot;\n        \n        bool hit = time > 0.0;\n        vec3 point = hit\n            ? ray.origin + ray.direction * time\n            : vec3(0.0);\n        \n        return HitResult(hit, point);\n    }\n    \n    return HitResult(false, vec3(0.0));\n}\n\nvec3 scene(vec2 uv) {\n    const vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 origin = vec3(0.0, 2.0 + cos(iTime), 0.0);\n    mat4 rotation = rotateY(iTime * 0.2);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 0.9));\n    rayDirection = (rotation * vec4(rayDirection, 0.0)).xyz;\n    \n    Ray ray = Ray(origin, rayDirection);\n    Plane plane = Plane(vec3(0.0), up);  \n    \n    \n    HitResult result = rayPlaneIntersect(ray, plane);\n\n    float value = checkerboard(uv * 10.0);\n    vec3 color = result.hit\n        ? vec3(checkerboard(result.point.xz))\n        : vec3(rayDirection.x, rayDirection.y, rayDirection.z);\n\n   \treturn color;\n}\n\nconst float PI = 3.14159;\n\nvec2 coordToUv(vec2 coord) {\n \treturn (coord - iResolution.xy * 0.5) / iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 singleSample = scene(uv);\n    \n    float a = (3.0 / 8.0);\n    float b = (1.0 / 8.0);\n    vec3 acc = vec3(0.0);\n    acc += scene(coordToUv(fragCoord + vec2(-a, b)));\n    acc += scene(coordToUv(fragCoord + vec2(-b, -a)));\n    acc += scene(coordToUv(fragCoord + vec2(a, -b)));\n    acc += scene(coordToUv(fragCoord + vec2(b, a)));\n    acc /= 4.0;\n\n    vec3 color = fragCoord.x / iResolution.x > 0.5\n        ? acc\n        : singleSample;\n    \n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color *= step(0.001, abs(fragCoord.x / iResolution.x - 0.5));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}