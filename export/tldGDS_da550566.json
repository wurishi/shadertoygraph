{"ver":"0.1","info":{"id":"tldGDS","date":"1577499559","viewed":456,"name":"temporal resolve experimental","username":"Carandiru","description":"- original shader: https://www.shadertoy.com/view/wtsXD7\n  by fabrice neyret (some parts used for a scene)\n- Original text shader taken from https://www.shadertoy.com/view/MstBzN by Rafbeam\n\n// 4 distinct samples are rendered per frame\n// one of those ...","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["bluenoise","resolve","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original shader: https://www.shadertoy.com/view/wtsXD7\n// by fabrice neyret (some parts used for a scene)\n\n// Original text shader taken from https://www.shadertoy.com/view/MstBzN by Rafbeam\n\n// shader by Carandiru\n// http://bit.ly/supersinfulsilicon\n\n// **** so whats happening here ?\n// 4 distinct samples are rendered per frame\n// one of those four samples is selected based on\n// the index of the current frame multiplied by a channel of bluenoise\n// where that channel of blue noise is the same for every sample \n// (deterministic across distinct samples at the same pixel location)\n\n// if the sample is not selected, that sample remains the same as the previous frame\n// (like there was no clear on that samples image buffer)\n\n// there is a one pixel offset that is different but constant for\n// each sample. this could be experimented more with a changing, but deterministic offset\n// to theoretically increase the samples / frame \n// (blue noise rocks)\n\n// then the samples are resolved by the blue noise that is shared for this pixel\n// different ways of resolving could be done here, but typically the\n// ground truth of a temporal resolve is the average of n samples with no\n// further complication\n// however the ground truth may look the nicest, it fails under fast or severe\n// motion - especially the camera moving around.\n\n// so it spins to some acceptable factor of speed and acceptable \"ghosting\"\n// that is desired\n\n// no clears here on buffers A,B,C,D\n\n// the Common tab has some configurable parametera like SPEED, INTERVAL\n\n// Cheers! comments and ideas are welcome!\n\n\nvoid mainImage( out vec4 sO, vec2 sU )\n{\n    ivec2 iU = ivec2(sU);\n    \n\tvec4 color = vec4(0);\n    vec4 fetch;\n    \n    fetch += texelFetch(iChannel0, iU, 0);\n    \n    fetch += texelFetch(iChannel1, iU, 0);\n    \n    fetch += texelFetch(iChannel2, iU, 0);\n    \n    fetch += texelFetch(iChannel3, iU, 0);\n         \n    color.rgb = fetch.rgb * (1.0f / fetch.a);\n    \n    sO = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// globals //\n#define INTERVAL int(iFrame)\n#define GOOD_COLOR vec3(0.5,0.05,1)\n#define SPEED (16.0f * sin(tT * 0.25f))\n\nvec3 scene( in vec2 U, in vec2 R, in float tT, in int usample )\n{\n   vec2 P = ( 2.*U - R ) / R.y;\n    \n    // --- stochastic cone-trace the scene ( = 1 sphere ) \n    \n    P += 0.666*cos(SPEED * tT+vec2(0,33));              // camera motion\n    \n    vec3 D = vec3( P, 1),                \n         C = vec3(0,0,-1), \n         L = normalize(vec3(-1,1,-2)), N,H;\n    \n    D = normalize(D);\n    \n    float r = .5, \n          b = dot(D,C), \n          c = dot(D,D) - r*r, \n          d = b*b - c;\n    \n    vec3 O = vec3(0);\n    \n    if (d>0.) { \n        \n        d = -b - sqrt(d); C += d*D;             // ray-sphere intersection\n        N = normalize(C);                       // local normal\n        H = normalize(L+vec3(0,0,-1));\n        \n        vec3 color = vec3(0);\n        \n        color.r = float(3 == usample);\n        color.g = float(2 == usample);\n        color.b = float(1 == usample);\n        color = mix(color, GOOD_COLOR, 0.5f + float(0 == usample));\n        \n        O = dot(N,L) * color           // diffuse shading\n            + pow(max(0.,dot(N,H)),99.) ;   // specular shading\n    }\n    \n    return O;\n}\n\n\n\n// Original text shader taken from https://www.shadertoy.com/view/MstBzN by Rafbeam\nconst int CHARS[41] = int[](\n    0x00000000, \n    0x00E8FE31, \n    0x01E8FA3E, \n    0x00F8420F, \n    0x01E8C63E, \n    0x01F87A1F, \n    0x01F87A10, \n    0x00F84E2F, \n    0x0118FE31, \n    0x01F2109F, \n    0x01F0862F, \n    0x01197251, \n    0x0108421F, \n    0x01BAD6B1, \n    0x011CD671, \n    0x00E8C62E, \n    0x01E8FA10, \n    0x00E8D66E, \n    0x01E8FA31, \n    0x00F8383E, \n    0x01F21084, \n    0x0118C62E, \n    0x0118C544, \n    0x0118C6AA, \n    0x01151151, \n    0x0118A884, \n    0x01F9113F, \n    0x00ECD66E, \n    0x0046509F, \n    0x00E8991F, \n    0x00E89A2E, \n    0x00232BE2, \n    0x01F8383E, \n    0x00F87E3E, \n    0x01F11108, \n    0x00E8BA2E, \n    0x00F8FC3E, \n    0x00000004, \n    0x00000088, \n    0x00421004, \n    0x00E11004\n);\n\nvec3 character(vec3 color, vec3 background, int character, vec2 position, float size, vec2 uv)\n{\n    if((uv.x > position.x && uv.x < position.x + size) && (uv.y > position.y && uv.y < position.y + size))\n    {\n        ivec2 pixel = ivec2(ceil((uv.x-position.x)/size*5.0)-1.0, ceil((1.0-(uv.y-position.y)/size)*5.0)-1.0);\n        int bit_index = pixel.y*5 + pixel.x;\n        int bit = (CHARS[character] >> (24 - bit_index))&1;\n        if(bit > 0)\n            return color;\n    }\n    return background;\n}\n\n#define EOL 0\n#define _ 0,\n#define A 1,\n#define B 2,\n#define C 3,\n#define D 4,\n#define E 5,\n#define F 6,\n#define G 7,\n#define H 8,\n#define I 9,\n#define J 10,\n#define K 11,\n#define L 12,\n#define M 13,\n#define N 14,\n#define O 15,\n#define P 16,\n#define Q 17,\n#define R 18,\n#define S 19,\n#define T 20,\n#define U 21,\n#define V 22,\n#define W 23,\n#define X 24,\n#define Y 25,\n#define Z 26,\n\n#define DOT 37,\n#define COMMA 38,\n#define BANG 39,\n#define QUESTION 40,\n\n#define EOL1 0\n#define EOL2 EOL1,EOL1\n#define EOL3 EOL2,EOL1\n#define EOL4 EOL3,EOL1\n#define EOL5 EOL4,EOL1\n#define EOL6 EOL5,EOL1\n#define EOL7 EOL6,EOL1\n#define EOL8 EOL7,EOL1\n#define EOL9 EOL8,EOL1\n#define EOL10 EOL9,EOL1\n#define EOL11 EOL10,EOL1\n#define EOL12 EOL11,EOL1\n#define EOL13 EOL12,EOL1\n#define EOL14 EOL13,EOL1\n#define EOL15 EOL14,EOL1\n#define EOL16 EOL15,EOL1\n#define EOL17 EOL16,EOL1\n#define EOL18 EOL17,EOL1\n#define EOL19 EOL18,EOL1\n#define EOL20 EOL19,EOL1\n#define EOL21 EOL20,EOL1\n#define EOL22 EOL21,EOL1\n#define EOL23 EOL22,EOL1\n#define EOL24 EOL23,EOL1\n#define EOL25 EOL24,EOL1\n#define EOL26 EOL25,EOL1\n#define EOL27 EOL26,EOL1\n#define EOL28 EOL27,EOL1\n#define EOL29 EOL28,EOL1\n#define EOL30 EOL29,EOL1\n\n#define LEN0 EOL30\n#define LEN1 EOL29\n#define LEN2 EOL28\n#define LEN3 EOL27\n#define LEN4 EOL26\n#define LEN5 EOL25\n#define LEN6 EOL24\n#define LEN7 EOL23\n#define LEN8 EOL22\n#define LEN9 EOL21\n#define LEN10 EOL20\n#define LEN11 EOL19\n#define LEN12 EOL18\n#define LEN13 EOL17\n#define LEN14 EOL16\n#define LEN15 EOL15\n#define LEN16 EOL14\n#define LEN17 EOL13\n#define LEN18 EOL12\n#define LEN19 EOL11\n#define LEN20 EOL10\n#define LEN21 EOL9\n#define LEN22 EOL8\n#define LEN23 EOL7\n#define LEN24 EOL6\n#define LEN25 EOL5\n#define LEN26 EOL4\n#define LEN27 EOL3\n#define LEN28 EOL2\n#define LEN29 EOL1\n#define LEN30 EOL0\n\nvec2 text_uv = vec2(0.0);\nvec2 text_position = vec2(0.0);\nvec3 text_color = vec3(1);\nvec3 text = vec3(0);\n\nconst float TEXT_SIZE = 0.03;\nconst float TEXT_SIZE2 = 0.03 + 0.04/5.0;\n\nvoid draw_text(int LINE[30]) {\n \tfor(int i = 0; i < 30; i++)\n        text = character(text_color, text, LINE[i], vec2(0,1) + text_position*vec2(1,-1) + vec2(TEXT_SIZE2 * float(i), 0.), TEXT_SIZE, text_uv);\n}\n\n#define TEXT(x,y) draw_text(int[](x y));\n\n\nvec3 draw_sample_text(in int sample_text[30], in vec2 uv, in vec2 sR, in float tT, in float alpha)\n{\n    vec3 text_out = vec3(0);\n    \n    {\n        float text_speed = sin(tT * 0.125f);\n        float x_tran = smoothstep( 0.0f, 0.9f, text_speed * 0.5f + 0.5f );\n        x_tran = x_tran * 2.0f - 1.0f;\n        x_tran *= 0.5f;\n        x_tran += text_speed;\n\n        text_uv = uv;\n        text_uv.x *= sR.x / sR.y;\n        text_position = vec2(0.69f + x_tran * 0.333f, 0.8725f);\n\n        text_color = GOOD_COLOR*GOOD_COLOR / length(GOOD_COLOR);\n        \n        draw_text(sample_text);\n\n        text_out += text;\n    }\n    \n    {\n        float text_speed = sin(tT * alpha * 0.125f);\n        float x_tran = smoothstep( 0.0f, 0.9f, text_speed * 0.5f + 0.5f );\n        x_tran = x_tran * 2.0f - 1.0f;\n        x_tran *= 0.5f;\n        x_tran += text_speed;\n\n        text_uv = uv;\n        text_uv.x *= sR.x / sR.y;\n        text_position = vec2(0.69f + x_tran * 0.333f, 0.87f);\n\n        text_color = GOOD_COLOR;\n        \n        draw_text(sample_text);\n\n        text_out += text * (1.0f - text_out);\n        text_out += text_out * (text - (1.0f - text_out));\n    }\n    \n    return text_out;\n\n}\n\n#define SAMPLE_TEXT(x,y) draw_sample_text(int[](x y), uv, iResolution.xy, iTime, alpha);\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int this_sample = 0;\n\nvoid mainImage( out vec4 sO, in vec2 sU )\n{\n    sO = vec4(0);\n    \n    vec2 uv = sU / iResolution.xy;\n    \n    float alpha = texture(iChannel0, uv).r;\n    int select_sample = int(\n        \t\t\t\t\t(float(INTERVAL & 3) + 1.0f)\n        \t\t\t\t\t* (alpha + 0.5f)\n        \t\t\t\t\t\n        \t\t\t\t\t);\n    sO.a = alpha;\n    \n    if ( this_sample == select_sample ) {\n\t\tsO.rgb = scene(sU + vec2(0,0), iResolution.xy, iTime, this_sample);\n    \n    \tsO.rgb += SAMPLE_TEXT(S A M P L E _ DOT _ A, LEN10);\n    }\n    else {\n    \tsO = texture(iChannel1, uv);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int this_sample = 1;\n\nvoid mainImage( out vec4 sO, in vec2 sU )\n{\n    sO = vec4(0);\n    \n    vec2 uv = sU / iResolution.xy;\n    \n    float alpha = texture(iChannel0, uv).r;\n    int select_sample = int(\n        \t\t\t\t\t(float(INTERVAL & 3) + 1.0f)\n        \t\t\t\t\t* (alpha + 0.5f)\n        \t\t\t\t\t\n        \t\t\t\t\t);\n    sO.a = alpha;\n    \n    if ( this_sample == select_sample ) {\n\t\tsO.rgb = scene(sU + vec2(0,1), iResolution.xy, iTime, this_sample);\n    \n    \tsO.rgb += SAMPLE_TEXT(S A M P L E _ DOT _ _ B, LEN11);\n    }\n    else {\n    \tsO = texture(iChannel1, uv);\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int this_sample = 2;\n\nvoid mainImage( out vec4 sO, in vec2 sU )\n{\n    sO = vec4(0);\n    \n    vec2 uv = sU / iResolution.xy;\n    \n    float alpha = texture(iChannel0, uv).r;\n    int select_sample = int(\n        \t\t\t\t\t(float(INTERVAL & 3) + 1.0f)\n        \t\t\t\t\t* (alpha + 0.5f)\n        \t\t\t\t\t\n        \t\t\t\t\t);\n    sO.a = alpha;\n    \n    if ( this_sample == select_sample ) {\n\t\tsO.rgb = scene(sU + vec2(1,0), iResolution.xy, iTime, this_sample);\n    \n    \tsO.rgb += SAMPLE_TEXT(S A M P L E _ DOT _ _ _ C, LEN12);\n   \n    }\n    else {\n    \tsO = texture(iChannel1, uv);\n    }\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const int this_sample = 3;\n\nvoid mainImage( out vec4 sO, in vec2 sU )\n{\n    sO = vec4(0);\n    \n    vec2 uv = sU / iResolution.xy;\n    \n    float alpha = texture(iChannel0, uv).r;\n    int select_sample = int(\n        \t\t\t\t\t(float(INTERVAL & 3) + 1.0f)\n        \t\t\t\t\t* (alpha + 0.5f)\n        \t\t\t\t\t\n        \t\t\t\t\t);\n    sO.a = alpha;\n    \n    if ( this_sample == select_sample ) {\n\t\tsO.rgb = scene(sU + vec2(1,1), iResolution.xy, iTime, this_sample);\n    \n    \tsO.rgb += SAMPLE_TEXT(S A M P L E _ DOT _ _ _ _ D, LEN13);\n    \n    }\n    else {\n    \tsO = texture(iChannel1, uv);\n    }\n}","name":"Buf D","description":"","type":"buffer"}]}