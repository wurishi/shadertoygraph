{"ver":"0.1","info":{"id":"X3syRS","date":"1726420982","viewed":57,"name":"Graphics HW","username":"mishaglik","description":"Lone road with blinking lights ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3  (0, 0, 10);\nconst float period   = 22.;\nconst vec3  light    = vec3  ( 5.3,  -1.6 + 6.0 + 0.32, 0.5 * period - 0. * period);\nconst int   maxSteps = 1000;\nconst float eps      = 1e-4;\n\nfloat unionD(float d1)\n{\n    return d1;\n}\n\n\nfloat unionD(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat unionD(float d1, float d2, float d3)\n{\n    return min(d1, min(d2, d3));\n}\n\nfloat unionD(float d1, float d2, float d3, float d4)\n{\n    return min(min(d1, d2), min(d3, d4));\n}\n\nvec4 unionD(vec4 d1)\n{\n    return d1;\n}\n\nvec4 unionD(vec4 d1, vec4 d2)\n{\n    return (d1.w < d2.w) ? d1 : d2;\n}\n\nvec4 unionD(vec4 d1, vec4 d2, vec4 d3)\n{\n    return unionD(d1, unionD(d2, d3));\n}\n\nvec4 unionD(vec4 d1, vec4 d2, vec4 d3, vec4 d4)\n{\n    return unionD(unionD(d1, d2), unionD(d3, d4));\n}\n\nfloat intersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat subtract(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nvec4 intersect(vec4 d1, vec4 d2)\n{\n    return (d1.w < d2.w) ? d2 : d1;\n}\n\nvec4 subtract(vec4 d1, vec4 d2)\n{\n    d1.w = -d1.w;\n    return (d1.w < d2.w) ? d2 : d1;\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0,  0),\n        vec3(0, c, -s),\n        vec3(0, s,  c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,  0, s),\n        vec3(0,  1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dPlane ( in vec3 p, vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat dSphere ( in vec3 p, in vec3 c, in float r )\n{\n        return length ( p - c ) - r;\n}\n\n\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat dCylinder ( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pt    = pos;\n    vec3  ba   = b  - a;\n    vec3  pa   = pt - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x    = length(pa*baba-ba*paba) - r*baba;\n    float y   = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat dCylinderl8 ( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3 pt    = pos;\n    vec3  ba   = b  - a;\n    vec3  pa   = pt - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x    = length8(pa*baba-ba*paba) - r*baba;\n    float y   = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat dConeCapped ( in vec3 pos, in vec3 st, in float h, in float r1, in float r2 )\n{\n    vec3 pt = pos - st;\n    vec2 q  = vec2 ( length ( pt.xz ), pt.y );\n    vec2 k1 = vec2 ( r2, h );\n    vec2 k2 = vec2 ( r2 - r1, 2.0*h );\n    vec2 ca = vec2 ( q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n\n    return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n        vec2    q = vec2 ( length8 ( p.xz ) - t.x, p.y );\n\n        return length8 ( q ) - t.y;\n}\n\nfloat dBox ( in vec3 pos, in vec3 size )\n{\n    vec3 pt = pos - size;\n\n    return length ( max ( pt, 0.0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), 0.0 );\n}\n\nfloat dBox(in vec3 pos, in vec3 p1, in vec3 p2)\n{\n    return subtract(dBox(pos, p1), dBox(pos, p2));\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n        float res = exp ( -k*a ) + exp ( -k*b );\n        return -log ( res ) / k;\n}\n\n\nfloat smoothUnion ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat dRazmetka(in vec3 p, in vec3 pos, in vec3 size)\n{\n    p = p - pos;\n    p.z = mod(p.z, size.z * 2.);\n    p = p / size;\n    \n    return length8(p) - 1.;\n    \n}\n\nfloat dTrueBox(in vec3 p, in vec3 pos, in vec3 size)\n{\n    p = p - pos;\n    p = p / size;\n    p = abs(p);\n    return max(p.x, max(p.y, p.z)) - 1.;\n}\n\nvec4 lamp(in vec3 p, in vec3 pos)\n{\n    vec3 height = vec3(0.0, 6.0, 0.0);\n    float topR = 0.1;\n    \n    return vec4(1., 1., 1., unionD( \n            smoothUnion(\n                dCylinder(p, pos, pos + 0.3 * height, topR),\n                dCylinder(p, pos, pos +       height, topR),\n                0.3),\n            unionD(\n                unionD(\n                    dCylinderl8(p, pos + height + vec3(  0.0,  0.0,  topR), pos + height + vec3(         0.0, 0.5,  topR + 0.3), 0.01),\n                    dCylinderl8(p, pos + height + vec3(  0.0,  0.0, -topR), pos + height + vec3(         0.0, 0.5, -topR - 0.3), 0.01),\n                    dCylinderl8(p, pos + height + vec3(  topR, 0.0,   0.0), pos + height + vec3(  topR + 0.3, 0.5,         0.0), 0.01),\n                    dCylinderl8(p, pos + height + vec3( -topR, 0.0,   0.0), pos + height + vec3( -topR - 0.3, 0.5,         0.0), 0.01)\n                ),\n                subtract(\n                    dConeCapped(p, pos + height + vec3(0, 0.699, 0), 0.2, topR + 0.28, 0.02),\n                    dConeCapped(p, pos + height + vec3(0, 0.700, 0), 0.2, topR + 0.30, 0.10)\n                )\n            )\n        ));\n}\n\n\nvec4 road(in vec3 p)\n{\n    return unionD(\n        vec4(0.1, 0.1, 0.1, dPlane (p, vec4 (0, 1, 0, 1.8))),\n        vec4(0.8, 0.8, 0., dRazmetka(p, vec3(2.5, -1.8, 1), vec3(0.2, 0.1, 2))),\n        vec4(0.3, 0.3, 0.3, unionD(\n            subtract(dBox (p, vec3(-100, 0.1, 50.1)), dBox(p, vec3(0,   -1.6, 50))),\n            subtract(dBox (p, vec3(   5, 0.1, 50.1)), dBox(p, vec3(100, -1.6, 50)))\n            ))\n        );\n    \n}\n\nvec4 housing(in vec3 p)\n{\n    vec3 pr = p; \n    pr.z = mod(pr.z, 3.1); \n    pr.y -= 1.;\n    if (pr.y > 0.) {\n        pr.y = mod(pr.y, 4.1);\n    }\n    return subtract(\n        vec4(0.0, 0.0, 0.0, dTrueBox(pr, vec3(-1., 1, 0.7), vec3(0.1, 1.4, 0.7))),\n        vec4(0.4, 0.2, 0.0, dBox(p, vec3(-1, 30, 50)))\n        );\n}\n\nvec4 sdf ( in vec3 p, in mat3 m)\n{\n   vec3 q = m * p;\n   //q = p;\n   vec3 qr = q;\n   qr.z = mod(qr.z, period);\n   return unionD(\n        road(q), \n        lamp(qr, vec3(5.3, -1.6, 0.5 * period)),\n        housing(q)\n    );\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, out vec4 surf)\n{\n        vec3    p         = from;\n        float   totalDist = 0.0;\n        float  prec = 0.99;\n        hit = false;\n        \n        for ( int steps = 0; steps < maxSteps; steps++ )\n        {\n                surf = sdf ( p, m);\n                float dist = prec * surf.w;\n        \n                if ( dist < eps )\n                {\n                        hit = true;\n                        break;\n                }\n    \n                totalDist += dist;\n\n                if ( totalDist > 140.0 )\n                        break;\n\n                p += dist * dir;\n        }\n\n        return p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    vec4 sf;\n    float dx1 = sdf(z + vec3(e, 0, 0), m).w;\n    float dx2 = sdf(z - vec3(e, 0, 0), m).w;\n    float dy1 = sdf(z + vec3(0, e, 0), m).w;\n    float dy2 = sdf(z - vec3(0, e, 0), m).w;\n    float dz1 = sdf(z + vec3(0, 0, e), m).w;\n    float dz2 = sdf(z - vec3(0, 0, e), m).w;\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nfloat ambientOcclusion ( in vec3 pos, in vec3 normal, in mat3 m)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    vec4 sf;\n    for ( int i = 0; i < 5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = sdf ( pos + h*normal, m).w;\n\n        occ += (h-d)*sca;\n        sca *= 0.95;\n\n        if ( occ > 0.35 ) \n            break;\n    }\n\n    return clamp ( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*normal.y);\n}\n\nvec4 getLight(vec3 p, vec3 src, mat3 m, vec3 n)\n{\n    bool hit;\n    vec3  l  = normalize( src - p );\n    vec4 sf;\n    vec3 s = trace(src, -l, hit, m, sf);\n    vec4 shade = vec4(1., 1., 1., 1.);\n    \n    if(length(s - p) > 0.4)\n    {\n        shade = 0.33 * sf;\n    }\n    \n    \n    vec3  eyer = eye;\n    eyer.z = mod(eyer.z, period) - 7.;\n    vec3  v  = normalize        ( eyer - p );\n    //vec3  n  = generateNormal   ( p, 0.0001, m );\n    float nl = max ( 0.0, dot ( n, l ) );\n    vec3  h  = normalize ( l + v );\n    float hn = max ( 0.0, dot ( h, n ) );\n    float sp = pow ( hn, 150.0 );\n\n    return shade * (0.7*ambientOcclusion(p, n, m)*vec4 ( nl ) + 0.5 * sp * vec4 ( 1, 1, 1, 1 ));\n    \n}\n\nint hash( int x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec3 meye =  eye;\n    m = mat3(vec3(1,0,0), vec3(0,1,0), vec3(0,0,1));\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n    vec3 dir   = normalize ( vec3 ( uv, 0 ) - meye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec4 surf  = vec4 ( 1, 1, 1, 1 );\n    vec3 p     = trace ( meye, dir, hit, m, surf);\n\n\n        if ( hit )\n        {       \n                vec3 pr = p;\n                pr.z = mod(pr.z, period);\n                \n                \n                \n                color = surf * getLight(pr, light, m, generateNormal( p, 0.0001, m )) ;//+ getLight(pr, light + vec3(0, 0, 15), m);\n                float id =  -floor(p.z / period);\n                if (hash(int(iTime)) % 100 == int(id)) {\n                    color = color * pow(min(1., abs(sin(30. * iTime) + cos(2. * iTime))), 100.);\n                }\n                \n        \n        if (dot(color, vec4(1,1,1,0)) < 0.1) {\n            color =  0.1 * ambientOcclusion(p, generateNormal( p, 0.0001, m ), m) * surf;\n        }\n        } \n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}