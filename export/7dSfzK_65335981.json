{"ver":"0.1","info":{"id":"7dSfzK","date":"1646627254","viewed":324,"name":"Doom Melt Transition","username":"Andrew900460","description":"Based on the doom melt transition. I made this for self-learning purposes. I understand I'm probably not the first to try and remake this.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["doom","transition","melt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// Doom Melt Transition (as close to the original as possible)\n/// If you want to tweak the effect, pay attention to the \"melt_pattern\" function.\n/// That is the function that determines height values for the effect.\n/// There is also an alternative function I made for a more smooth height map\n/// But it won't look like the original doom one any more. The code for it is commented out.\n\n/// Clicking on different places on the creen will change the \"seed\" based on iMouse.x\n\n\n// based off of the \"rndtable\" that doom uses for random number generation\n// this table I had to generate in a seperate program, but this is essentially\n// the heightmap that doom would use for the melt transition.\nint melt_table[256] = int[](\n    -8, -8, -8, -9, -9, -8, -7, -8, -7, -6, -5, -5, -6, -5,\n    -6, -6, -5, -4, -3, -3, -4, -4, -3, -2, -1, 0, -1, 0, 0,\n    0, -1, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, -1,\n    0, 0, -1, -1, 0, 0, -1, -2, -1, -2, -3, -4, -4, -5, -6,\n    -5, -5, -6, -7, -7, -6, -6, -5, -5, -6, -6, -5, -5, -5,\n    -6, -7, -6, -6, -6, -5, -4, -4, -5, -4, -5, -5, -6, -5,\n    -4, -3, -3, -2, -2, -1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0,\n    -1, -2, -2, -3, -2, -1, -2, -1, -2, -2, -2, -1, 0, 0, 0,\n    0, -1, -1, -2, -1, -2, -1, -2, -1, 0, 0, 0, 0, 0, 0, 0,\n    0, -1, -1, -2, -3, -4, -4, -4, -3, -3, -3, -3, -3, -4,\n    -4, -3, -4, -5, -5, -6, -6, -5, -6, -6, -7, -6, -5, -5,\n    -4, -5, -4, -4, -5, -6, -7, -8, -9, -8, -9, -10, -9, -9,\n    -9, -10, -9, -8, -8, -9, -9, -8, -8, -9, -8, -8, -8, -7,\n    -6, -5, -6, -7, -8, -8, -9, -8, -8, -9, -8, -7, -8, -7,\n    -7, -7, -8, -8, -8, -8, -7, -8, -8, -9, -10, -9, -9, -8,\n    -7, -6, -6, -7, -7, -6, -6, -6, -7, -7, -8, -8, -8, -9,\n    -9, -8, -9, -10\n);\n\nfloat getMeltTableValue(float x) {\n    float screenWidth = 320.0; // original doom resolution width was 320\n    int index = int(floor(x * screenWidth)) & 0xff;\n    int melt_height = melt_table[index];\n    \n    // some final processing to convert the int height value\n    // into a float value in the range [0,1]\n    // the biggest value in the table would be 10, so I chose 10.\n    float result_height = float(melt_height+10) / 10.0;\n    \n    return result_height;\n}\n\nfloat rand(float x) {\n    return fract(cos(x*96753.57931)*98635.1967);\n}\n\nfloat smooth_rand(float x) {\n    //int i = int(floor(fract(x) * 256.0));\n    //float(rndtable[i]) / 256.0;\n    return sin(x) + sin(1.6*x)*0.5 + sin(4.3*x)*0.25 + sin(7.7*x)*0.125;\n}\n\nfloat crush(float x, float crush) {\n    return floor(x*crush)/crush;\n}\n\nfloat melt_pattern(float x) {\n    float height;\n    \n    // using custom special made heights\n    ///height = smooth_rand(16.0*crush(x,320.0) + iMouse.x);\n    ///height = crush(height,8.0);\n    \n    // using the more \"true to original\" doom rnd height values\n    height = getMeltTableValue(x + iMouse.x) * 2.0;\n    \n    return height;\n}\n\nfloat inNormal(float x) {\n    if(x >= 0.0 && x <= 1.0){\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = iTime;\n    \n    float animationTime = clamp(t*1.0-1.0,-1.0,2.0);\n    \n    vec2 uv2 = uv;\n    \n    float acceleration = smoothstep(0.5,1.0,iTime*1.0) * 0.5 + 1.0;\n    \n    float push = melt_pattern(uv.x)*0.2 + animationTime * acceleration;\n    // clamp(iTime*0.5,0.0,2.0);\n    \n    push = clamp(push,0.0,1.0);\n    \n    uv2.y += push;\n    \n    vec4 topColor = texture(iChannel0,uv2);\n    \n    vec4 bottomColor = texture(iChannel1,uv) * 0.25;\n    \n    vec4 mask = vec4(inNormal(uv2.y));\n    \n    // Output to screen\n    fragColor = vec4(mask.rgb*topColor.rgb + bottomColor.rgb*(1.0-mask.rgb),1.0);\n}","name":"Image","description":"","type":"image"}]}