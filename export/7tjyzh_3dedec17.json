{"ver":"0.1","info":{"id":"7tjyzh","date":"1649192612","viewed":260,"name":"Chaos & Order","username":"kastorp","description":"all life long","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["3d","points"],"hasliked":0,"parentid":"slfcWl","parentname":"points & regions v2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// chaos & order by kastorp\n//---------------------------\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    vec2  p = (U/R.y -R/R.y*.5),mp = (iMouse.xy/R.y -R/R.y*.5),\n        c = (p*R.y/R.xy +.5)*float(M) ;    \n    int j = int(c.x) +int(c.y)*M, //current region id\n        jj= int(step(.5,fract(c.x))+2.*step(.5,fract(c.y)));\n    \n    O=vec4(0,0,0,10);\n    \n    for(int i=0,k=0;k<N && i<500;i++){ // scan points in current region (max 500)\n        \n        //get point at pointer\n        vec4 c=texelFetch(iChannel0,ivec2(max(0,k-1)%NX,max(0,k-1)/NX ),0);\n        \n        //draw the point\n        float r= TL*DIST/(DIST+c.w);\n        float d =length(p-c.xy), \n            //sh= (1.5- length(p-c.xy-vec2(0,r*.5))/r)*1.5 -.5;sh=.5+sh*sh;\n            sh= (1.+dot((p-c.xy) +vec2(0,r),vec2(0,1))/d)*.3; \n        if(c.w<O.w && d<r) O=vec4((0.5 + 0.5*cos(c.z*6.+vec3(0,2,4)))*sh,c.w);\n        \n        //get pointer to next point in region\n        k =int(texelFetch(iChannel1,ivec2(k%NX,k/NX +j*NY),0)[jj]);\n       \n    }\n    \n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//random points \n//// Hash without Sine (c)2014 David Hoskins\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    if(int(U.y)>(NY*M*M) || int(U.x)>NX) return ;\n    int i= (int(U.y)%NY)*NX + int(U.x); \n        \n    vec3 p = mix(vec3(i/(L*L),(i%(L*L))/L,i%L)/float(L)-.5+1./float(L) , (hash32(U)-.5),.5+.5*cos(iTime/2.));    \n  \n   float a = iTime/4.;//iMouse.x/iResolution.x*3.;\n   p.xy*=mat2(cos(a),sin(a),-sin(a),cos(a));\n   p.xz*=mat2(cos(a),sin(a),-sin(a),cos(a));\n   O.xy=p.xy *.7 *DIST / (DIST+p.z);\n   O.z=float(i)/float(N);\n   O.w= p.z;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define N 2000   //number of points (<=10000)\n#define H 10  //number of scanned points in buffer B \n#define TL .015 //sphere size \n#define DIST .7\n#define Init vec2 R =iResolution.xy;\\\n    int NX =int(iResolution.x);\\\n    int NY= (N/NX+1);\\\n    int M= min(16,int(sqrt(iResolution.y/float(NY))));\\\n    int L= int(pow(float(N),1./3.));\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//points in each region\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    O= vec4(H);\n    if(int(U.y)>(NY*M*M) || int(U.x)>NX) return ;\n       \n    int j=int(U.y)/NY, //current region\n        i= (int(U.y)%NY)*NX + int(U.x); //current point\n\n    bvec4 f=bvec4(false);\n    for( int k = i; k<min(N,i+H);k++){ //iterate on max H points in region\n        \n        \n        vec4 p= texelFetch(iChannel0,ivec2(k%NX,k/NX),0); //point position\n        float r= TL*DIST/(DIST+p.w);\n        float sz=1./float(M);\n        vec2 s =(vec2((j%M),j/M)+.25);\n        vec2 s1=s+.25; s1=s1*sz-.5 ; s1*=R.xy/R.y ; //region center\n        if(max(abs(p.x-s1.x)-.5*sz*R.x/R.y,abs(p.y-s1.y)-.5*sz)>r) continue; //outside region\n          \n        for(int jj=0;jj<4;jj++){\n          if(f[jj])continue; //already found next point for subregion\n               \n          vec2 ss=s +vec2((jj==1|| jj==3) ?.5:0.,(jj==2|| jj==3) ?.5:0.); ss=ss*sz-.5 ; ss*=R.xy/R.y ; //subregion center\n      \n            if(max(abs(p.x-ss.x)-.25*sz*R.x/R.y,abs(p.y-ss.y)-.25*sz)<r)\n            {\n                //this point is inside subergion\n                O[jj]= float(k-i); \n                f[jj]=true;\n            }\n       } \n       if(all(f)) return; \n    }\n    \n       \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//pointer joiner (from relative to absolute)\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    Init\n    \n    if(int(U.y)>(NY*M*M) || int(U.x)>NX) return ;        \n     \n    int j=int(U.y)/NY, //current region\n        i= (int(U.y)%NY)*NX + int(U.x); //current point\n    \n    O=  texelFetch(iChannel1,ivec2(U),0);\n    for(int jj=0;jj<4;jj++){\n        if(i>0 &&   int(texelFetch(iChannel1,ivec2((i-1)%NX,(i-1)/NX +j*NY),0)[jj]) !=0) {\n            O[jj]=float(N+1);\n            continue;\n        }\n        \n         //TODO: order by ascending distance\n        for(int ii=0,k=int(O[jj])+i;k<N && ii<N/H+5;ii++){ // scan next points in current region \n\n            int sk=int(texelFetch(iChannel1,ivec2(k%NX,k/NX +j*NY),0)[jj]);\n            if(sk==0) { //the point is in\n                O[jj]=float(k+1); //update pointer\n                break;\n            }\n            else k+=int(sk); //skip till first point in region\n        }\n\n   }  \n\n}","name":"Buffer C","description":"","type":"buffer"}]}