{"ver":"0.1","info":{"id":"st3cR8","date":"1659253114","viewed":122,"name":"faraway shader","username":"Hriz","description":"faraway","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["glyph3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 256;\nconst float MAX_RAY_LENGTH = 50.;\n\nfloat glyph (vec2 uv)\n{\n    vec2 fl = floor(uv + 0.5);\n    float match = 0.;\n    \n    if (fl.x > -3.5 && fl.x < -2.5 && fl.y > -0.5 && fl.y < 0.5) {\n        fl = vec2(6.0, 11.0);\n        match = 1.;\n    } else if (fl.x > -2.5 && fl.x < -1.5 && fl.y > -0.5 && fl.y < 0.5) {\n        fl = vec2(1.0, 11.0);\n        match = 1.;\n    } else if (fl.x > -1.5 && fl.x < -0.5 && fl.y > -0.5 && fl.y < 0.5) {\n        fl = vec2(2.0, 10.0); \n        match = 1.;\n    } else if (fl.x > -0.5 && fl.x < 0.5 && fl.y > -0.5 && fl.y < 0.5) {\n        fl = vec2(1.0, 11.0);\n        match = 1.;\n    } else if (fl.x > 0.5 && fl.x < 1.5 && fl.y > -0.5 && fl.y < 0.5) {\n        fl = vec2(7.0, 10.0); \n        match = 1.;\n    } else if (fl.x > 1.5 && fl.x < 2.5 && fl.y > -0.5 && fl.y < 0.5) {\n        fl = vec2(1.0, 11.0); \n        match = 1.;\n    } else if (fl.x > 2.5 && fl.x < 3.5 && fl.y > -0.5 && fl.y < 0.5) {\n        fl = vec2(9.0, 10.0); \n        match = 1.;\n    }\n    \n    uv = fl + fract(uv + 0.5) - 0.5;\n    float tex = (texture(iChannel0, (uv + 0.5) * 1.0 / 16.0).a - .5) / 8.;\n    return mix(0.3, tex, match);\n}\n\nfloat extrudeGlyph (float d, float w, float y)\n{\n    return length(vec2(max(d, 0.), y - clamp(y, -w, w)))\n        + min(max(d, abs(y)-w), 0.);\n}\n\nfloat dist (vec3 p)\n{\n    return extrudeGlyph(glyph(p.xy), .1, p.z);\n}\n\nvec3 normal (vec3 p)\n{\n    float e = 0.005;\n    return normalize(vec3(\n        dist(p + vec3(e, 0., 0.)) - dist(p - vec3(e, 0., 0.)),\n        dist(p + vec3(0., e, 0.)) - dist(p - vec3(0., e, 0.)),\n        dist(p + vec3(0., 0., e)) - dist(p - vec3(0., 0., e))\n    ));\n}\n\nfloat rayMarch (vec3 ro, vec3 rs)\n{\n    float rayLength = 0.;\n    \n    for (int i = 0; i <= MAX_STEPS; i++)\n    {\n        vec3 r = ro + rs * rayLength;\n        float d = dist(r);\n        \n        if (d <= 0.001 || rayLength > MAX_RAY_LENGTH) break;\n        \n        rayLength += d;\n    }\n    \n    return rayLength;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) \n{\n\tvec3 cd = normalize(lookAtPoint - cameraPos); \n\tvec3 cr = normalize(cross(vec3(0., 1., 0.), cd)); \n\tvec3 cu = normalize(cross(cd, cr)); \n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 bg(in vec3 uv) \n{\n    vec3 p = vec3(1., .52, .5) + .1 * normalize(vec3(uv));\n    \n    float pa, a;\n    \n    for (int i = 0; i < 26; i++) { \n        p = abs(p) / dot(p, p) - 0.5; \n        a += abs(length(p) - pa);  \n        pa = length(p);\n    }\n    \n    a *= a * a; \n    return vec3(0.0002 * a * .01) * vec3(1., 0.9, 1.5); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float cameraRadius = 6.;\n    \n    vec3 lp = vec3(0., 0., 0.); \n    vec3 ro = vec3(0., 0., cameraRadius); \n    ro.x = cameraRadius * cos(iTime / 3.) + lp.x; \n    ro.z = cameraRadius * sin(iTime / 3.) + lp.z; \n\n    vec3 rs = camera(ro, lp) * normalize(vec3(uv.xy, -1.)); \n    \n    float rayLength = rayMarch (ro, rs);\n\n    vec3 col = bg(rs);\n    \n    if (rayLength <= MAX_RAY_LENGTH) {\n        vec3 p = ro + rs * rayLength;\n        vec3 lightPosition = vec3(2, 2, 5);\n        vec3 lightDirection = normalize(lightPosition - p);\n        vec3 normal = normal(p);\n        float lightDot = clamp(dot(normal, lightDirection), 0., 1.);\n        \n        col = col * reflect(rs, normal).xyz + vec3(lightDot) * 0.2 + col;\n        col = mix(col * reflect(rs, normal).xyz, vec3(lightDot) * .1 + .2, .5) + col * .7;\n    }\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}