{"ver":"0.1","info":{"id":"cljGDR","date":"1673135710","viewed":285,"name":"Fancy Space Filling Curves","username":"MartyMcFly","description":"Just some fun visualizing the order in which space filling curves fill space\n\nH-Curve: https://www.shadertoy.com/view/mlS3Rm\nHilbert lifted from: https://www.shadertoy.com/view/XtGBDW","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["hilbert","morton","hcurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//For details regarding the H-curve, see https://www.shadertoy.com/view/mlS3Rm\n#define LEVELS 12\n\nuint H_curve(uvec2 pos, uint logN)\n{\n        pos &= (1u << logN) - 1u;//since it's cycling, I have to make it tileable somehow\n        uint x = pos.x & 3u;\n        uint y = pos.y & 3u;\n        pos >>= 1u;\n        \n        uint i = (x&2u)<<2u|((y^x)&2u)<<1u|(y^(~x<<1u))&2u|(x^y)&1u; //initial D, I mean H  \n        \n        //uint idx = x * 4u + y;        \n        //uint H = 0xBB44B14Eu;        \n        //i = ((H>>(idx&0xEu)+16u)<<2u)|(H>>((idx&1u)*2u));\n      \n        for(uint s = 2u; s < logN; s++)\n        {\n            uint n = 1u << s;\n            uint n2 = n * n;\n\n            //first, shift indices in the base blocks so 0 is at bottom right (when wrapped around)\n            \n            i += (3u * n2) >> 3u; //i %= n*n; //done later again so skip it                       \n            \n            pos >>= 1u;\n            x = pos.x & 1u;\n            y = pos.y & 1u;           \n            \n            uint permute = x ^ y + (y << 1u);                    \n            uint shift   = x ^ y + (x << 1u); \n            \n            //offset indices within each quadrant so start and exit connect\n            i = (i + permute * (n2 >> 2u)) & (n2 - 1u);    \n            //offset indices by block count, i.e. 0123 0123 becomes 0123 4567\n            i += shift * n2;  \n        }\n        return i;\n}\n\n// from https://www.shadertoy.com/view/XtGBDW\nuint HilbertIndex( uvec2 Position, uint N )\n{   \n    uint WIDTH = 1u << N;\n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return Index;\n}\n\nuint part1by1 (uint x) \n{\n    x = (x & 0x0000FFFFu);\n    x = ((x ^ (x << 8u)) & 0x00FF00FFu);\n    x = ((x ^ (x << 4u)) & 0x0F0F0F0Fu);\n    x = ((x ^ (x << 2u)) & 0x33333333u);\n    x = ((x ^ (x << 1u)) & 0x55555555u);\n    return x;\n}\n    \nuint pack_morton2x16(uvec2 v) \n{\n\treturn part1by1(v.x) | (part1by1(v.y) << 1);\n}\n\n\n//thanks IQ\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb=clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z*mix(vec3(1.0),rgb,c.y);\n}\n\nvec3 gradient(float t) \n{\n    float h = 0.6666 * (1.0 - t*t);\n    float s = 0.75;\n    float v = 1.0 - 0.9*(1.0 - t) * (1.0 - t);\n\treturn hsv2rgb(vec3(h,s,v));    \n}\n\nuint inverse_gray32(uint n) {\n    n = n ^ (n >> 1);\n    n = n ^ (n >> 2);\n    n = n ^ (n >> 4);\n    n = n ^ (n >> 8);\n    n = n ^ (n >> 16);\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    uint logN = uint(LEVELS + 2);    \n    uint N = 1u << logN;  \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;    \n    \n    float r = max(0.0, 1.0 - dot(uv, uv) * 0.3);   \n    fragColor = vec4(r);   \n     \n     \n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.3;\n    \n    float fade = max(abs(uv.x), abs(uv.y)) - 1.0;\n    \n    fragColor *= fade / (0.005 + fade);\n     \n    if(abs(uv.x) < 1.0 && abs(uv.y) < 1.0)\n    {\n        uv = uv * 0.5 + 0.5;\n        uvec2 pos = uvec2(uv * float(N));\n        \n        uint mode = uint(iTime*0.125) % 3u;\n        \n        uint i = 0u;\n        \n        switch(mode)\n        {\n            case 0u: i = pack_morton2x16(pos); break;\n            case 1u: i = HilbertIndex(pos, logN); break;\n            case 2u: i = H_curve(pos, logN); break; \n        }\n        \n\n        \n        float t = float(i) / float(N * N);\n        t = fract(t - iTime * 0.125);\n        fragColor = vec4(gradient(t), 1.0); \n        \n    }  \n  \n}","name":"Image","description":"","type":"image"}]}