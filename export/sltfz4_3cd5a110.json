{"ver":"0.1","info":{"id":"sltfz4","date":"1664635812","viewed":258,"name":"[ConcoursJFIG2022]Vin&CannelÃ©s","username":"bowari","description":"You can turn around the scene using mouse and waiting the algorithm converge.\nYou can change some parameters in file \"common\" lines 13-31.","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["concoursjfig2022"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ********************  MAIN  *******************\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = fragColor.xyz/fragColor.w;\n    \n    // tone map (aces)\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    col = clamp((col * (a * col + b)) / (col * (c * col + d ) + e), 0., 1.);\n    //cheap gamma correction\n    col = sqrt(col);\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ------------------------------------------------------------------------------------------\n// ------------------------------------ GLOBAL VARIABLE -------------------------------------\n// ------------------------------------------------------------------------------------------\n\n#define INV_PI    0.3183098861837906715377675267450\n#define PI        3.1415926535897932384626433832795\n#define PI_TWO    1.5707963267948966192313216916398\n#define PI_THREE  1.0471975511965977461542144610932\n#define PI_SIX    0.5235987755982988730771072305466\n#define TWO_PI    6.2831853071795864769252867665590\n\n// --- camera ---\n#define CAM_SENSIBILITY 0.005\n#define POS_CAM         vec3(0.,30.,70)\n#define LOOKAT          vec3(0.)\n#define FOCAL_DISTANCE  2.5\n#define FOVY            PI_THREE\n\n// --- others ---\nuint seed;\n#define NB_OBJ            7.\n#define RAY_PER_FRAME     1\n#define NB_BOUNCE         20\n#define MAX_STEP          1000\n#define EPS               0.001\n#define EPS_OH            0.0015\n#define EPS_NORMAL        0.01\n#define ENV_MAP_POWER     4.\n#define SUN_POWER         20.\n#define SUN_COLOR         vec3(1.)\n#define SUN_NORMAL_JITTER 0.05\n\n#define Z min(iFrame,0)\n\n// ------------------------------------------------------------------------------------------\n// ----------------------------------------- RANDOM -----------------------------------------\n// ------------------------------------------------------------------------------------------\n// https://www.shadertoy.com/view/Ns2XDt\n// https://www.pcg-random.org/download.html\nuint pcg(){\n    uint state = seed*747796405U+2891336453U;\n    uint tmp  = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    return (seed = (tmp >> 22U) ^ tmp);\n}\n\nfloat rand(){return float(pcg())/float(0xffffffffU);}\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- MATERIAL -----------------------------------------\n// ------------------------------------------------------------------------------------------\n\nstruct Material{\n    vec3 colorSurface;     // color absorb by the surface of object\n    float r;               // roughness\n    vec3 colorAbsorb;      // color absorb by the interior of object\n    float absorptivity;    // molar attenuation coefficient * molar concentration\n    float ior;             // ior==0 no refraction  ;  x>0 refraction \n};\n\nMaterial materials[int(NB_OBJ)] = Material[](\n    Material(vec3(0.5)            ,0.2  ,vec3(1.)                ,0.   ,0.   ),   // table        \n    Material(vec3(0.99)           ,0.01 ,vec3(0.5,0.7,0.4)       ,0.09 ,1.5  ),   // bouteille    \n    Material(vec3(0.98)           ,1e-3 ,vec3(1.)                ,0.09 ,1.5  ),   // verre        \n    Material(vec3(0.99)           ,1e-3 ,vec3(0.85, 0.015, 0.08) ,0.06 ,1.345),   // vin\n    Material(vec3(0.95)           ,0.3  ,vec3(1.)                ,0.   ,0.   ),   // plat         \n    Material(vec3(0.08,0.05,0.03) ,0.8  ,vec3(1.)                ,0.   ,0.   ),   // canele       \n    Material(vec3(0.8,0.4,0.2)    ,0.8  ,vec3(1.)                ,0.   ,0.   )    // floor\n);\n\n// https://schuttejoe.github.io/post/ggximportancesamplingpart1/\nvec3 GGX_MIS(in vec3 wi, in vec3 wo, in vec3 wm, in vec3 normal, in Material m){         \n    float n_wo = dot(normal,wo);\n    float n_wi = dot(normal,wi);\n    float n_wm = dot(normal,wm);\n    float wi_wm = dot(wi, wm);\n    float r2 = m.r*m.r;\n\n    // ------------ F => Schlick aprox of fresnel\n    float tmpF = 1. - wi_wm;    // dot(wi,wm) same as dot(wo,wm)\n    vec3 F0 = m.colorSurface;\n    vec3 F = F0 + (1. - F0) * tmpF*tmpF*tmpF*tmpF*tmpF;\n\n    // ------------ G\n    float tmpG = 1.-r2;\n    float G = 2.*n_wi*n_wo/\n              (n_wi * sqrt(r2+tmpG*n_wo*n_wo) +\n               n_wo * sqrt(r2+tmpG*n_wi*n_wi));\n       \n    return F*G*abs(wi_wm /(n_wi*n_wm));\n}\n\nvec3 GGX(in vec3 wi, in vec3 wo, in vec3 normal, in Material m){    \n    vec3 h = normalize(wi+wo);\n    float n_wo = dot(normal,wo);\n    float n_wi = dot(normal,wi);\n    float n_h = dot(normal,h);\n    float r2 = m.r*m.r;\n    \n    // ------------ F => Schlick aprox of fresnel\n    float tmpF = 1. - dot(wi, h);     // dot(wi,h) same as dot(wo,h)\n    vec3 F0 = m.colorSurface;\n    vec3 F = F0 + (1. - F0) * tmpF*tmpF*tmpF*tmpF*tmpF;\n\n    // ------------ G\n    float tmpG = 1.-r2;\n    float G = 2.*n_wi*n_wo/\n              (n_wi * sqrt(r2+tmpG*n_wo*n_wo) +\n               n_wo * sqrt(r2+tmpG*n_wi*n_wi));\n               \n    // ------------ D\n    float tmpD = (n_h*n_h)*(r2-1.)+1.;\n    float D = r2/(PI*tmpD*tmpD);\n    \n    return F*G*D/abs(4.*n_wi); // => F*G*D/(4.*abs(4n_wi)*abs(n_wo))  * abs(n_wo) \n}\n\nfloat fresnel(in float ni, in float no, in float cTi, in float cTo){\n    float tmp = (no*cTi + ni*cTo);\n    float Rs = (abs(tmp)<EPS) ? 0. : (no*cTi - ni*cTo)/tmp;\n    \n    tmp = (ni*cTi + no*cTo);\n    float Rp = (abs(tmp)<EPS) ? 0. : (ni*cTi - no*cTo)/tmp;\n\n    return (Rs*Rs + Rp*Rp)*0.5;\n}\n\n// ------------------------------------------------------------------------------------------\n// --------------------------------------- OPERATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\n\n// ****** union ******\nfloat op_union( in float p_sdf1, in float p_sdf2 ) {\n\treturn (p_sdf1<p_sdf2) ? p_sdf1 : p_sdf2; // faster than min(d1,d2)\n}\n\nfloat op_Sunion( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 + 0.5*(p_sdf2-p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf2, p_sdf1, tmp ) - p_factor*tmp*(1.-tmp); \n}\n\n// ****** intersection ******\nfloat op_intersection( in float p_sdf1, in float p_sdf2 ) {\n    return (p_sdf1>p_sdf2) ? p_sdf1 : p_sdf2; // faster than max(d1,d2)\n}\n\nfloat op_Sintersection( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 - 0.5*(p_sdf2-p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf2, p_sdf1, tmp ) + p_factor*tmp*(1.-tmp);  \n}\n\n// ****** substraction ******\nfloat op_substraction( in float p_sdf1, in float p_sdf2 ) { // intersection of sdf1 and -sdf2\n    return max(p_sdf1,-p_sdf2);\n}\n\nfloat op_Ssubstraction( in float p_sdf1, in float p_sdf2, float p_factor ) {\n    float tmp = clamp( 0.5 - 0.5*(p_sdf2+p_sdf1)/p_factor, 0., 1. );\n    return mix( p_sdf1, -p_sdf2, tmp ) + p_factor*tmp*(1.-tmp);  \n}\n\n// ****** other ******\nfloat op_round( in float p_sdf, in float p_radius ){\n    return p_sdf - p_radius;\n}\n\nfloat op_onion( in float p_sdf, in float p_h ){\n    return abs(p_sdf)-p_h;\n}\n\n// ------------------------------------------------------------------------------------------\n// ------------------------------------------ SDF -------------------------------------------\n// ------------------------------------------------------------------------------------------\n\nfloat sdf_sphere( in vec3 p_point, in float p_radius ){\n  return length(p_point)-p_radius;\n}\n\nfloat sdf_plane( in vec3 p_point, in vec3 p_normal, in float p_h ){\n    return dot(p_point,p_normal)+p_h;\n}\n\nfloat sdf_cylinder( in vec3 p_point, in float p_h, in float p_radius ){\n  vec2 tmp = vec2(length(p_point.xz)-p_radius,abs(p_point.y)-p_h);\n  return min(max(tmp.x,tmp.y),0.) + length(max(tmp,0.));\n}\n\nfloat sdf_capsule( in vec3 p_point, in float p_h, in float p_radius ){\n  p_point.y -= clamp( p_point.y, 0., p_h );\n  return length(p_point) - p_radius;\n}\n\n// https://www.shadertoy.com/view/3tBcDR\nfloat sdf_ellipsoid_glass( in vec3 p_point, in vec3 p_radius ){\n  float k = length(p_point/p_radius);\n  return (k<1.) ? (k-1.)*min(p_radius.x,min(p_radius.y,p_radius.z)) : k*(k-1.)/max(1e-3,length(p_point/(p_radius*p_radius)));\n}\n\nfloat sdf_ellipsoid_plate( in vec3 p_point, in vec3 p_radius ){\n  float k = length(p_point/p_radius);\n  return k*(k-1.)/max(1e-3,length(p_point/(p_radius*p_radius)));\n}\n\nfloat sdf_box( in vec3 p_point, in vec3 p_bound ){\n  vec3 q = abs(p_point) - p_bound;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// ------------------------------------------------------------------------------------------\n// -------------------------------------- EVALUATIONS ---------------------------------------\n// ------------------------------------------------------------------------------------------\nbool intersectAABB( in vec3 p_d, in vec3 p_o, in vec3[2] p_MinMax, in float p_tMax ){ \n    // MARGIN\n    p_MinMax[0] -= vec3(EPS);\n    p_MinMax[1] += vec3(EPS);\n    \n    ivec3 s\t= ivec3( p_d.x<0., p_d.y<0., p_d.z<0. );\n\n\t// *** X axis ***\n\tfloat tmpMin, refMin = ((p_MinMax[s.x]).x - p_o.x) * p_d.x;\n\tfloat tmpMax, refMax = ((p_MinMax[1-s.x]).x - p_o.x) * p_d.x;\n\n\t// *** Y axis ***\n    if( (tmpMin=((p_MinMax[s.y]).y - p_o.y)*p_d.y)>refMax || refMin>(tmpMax=((p_MinMax[1-s.y]).y - p_o.y)*p_d.y) ) return false;\n    refMin = max( tmpMin, refMin );\n    refMax = min( tmpMax, refMax );\n\n\t// *** Z axis ***\n    if( (tmpMin=((p_MinMax[s.z]).z - p_o.z)*p_d.z)>refMax || refMin>(tmpMax=((p_MinMax[1-s.z]).z - p_o.z)*p_d.z) ) return false;\n    refMin = max( tmpMin, refMin );\n    refMax = min( tmpMax, refMax );\n\n\treturn (refMin<=p_tMax) && (refMax>=0.);\n}\n\nbool[int(NB_OBJ)] shrinkScene(in vec3 p_rayD, in vec3 p_rayO ,in float p_tMax){\n    vec3 invRayD = 1./p_rayD;\n    bool[int(NB_OBJ)] newScene;\n    \n    newScene[0] = intersectAABB(invRayD,p_rayO,vec3[2](vec3( -50.,       -75.,  -50.),vec3( 50.,          0.,  50.)),p_tMax); // table\n    newScene[1] = intersectAABB(invRayD,p_rayO,vec3[2](vec3( 15.5,     EPS_OH,   0.5),vec3(24.5, 29.5+EPS_OH,  9.5)),p_tMax); // bouteille\n    newScene[2] = intersectAABB(invRayD,p_rayO,vec3[2](vec3( -7.1,     EPS_OH,  13.9),vec3( 1.1, 20.4+EPS_OH, 22.1)),p_tMax); // verre \n    newScene[3] = intersectAABB(invRayD,p_rayO,vec3[2](vec3( 15.7, 0.2+EPS_OH,   0.7),vec3(24.3,  17.+EPS_OH,  9.3)),p_tMax); // vin\n    newScene[4] = intersectAABB(invRayD,p_rayO,vec3[2](vec3(-10.2,     EPS_OH,  24.8),vec3(10.2,  4.4+EPS_OH, 45.2)),p_tMax); // plat\n    newScene[5] = intersectAABB(invRayD,p_rayO,vec3[2](vec3(-7.35, 0.2+EPS_OH, 32.65),vec3(7.35, 5.3+EPS_OH, 37.35)),p_tMax); // canele\n    newScene[6] = dot(vec3(0.,1.,0.),p_rayD)<0.; // approximate but faster                                               // floor\n\n    return newScene;\n}\n\n// Evaluate the sdf witch correspond to p_num\nfloat evaluate( in vec3 p_point, in float p_num ){\n    int num = int(p_num);\n    switch(int(p_num)){\n    case 0:\n        return op_union(\n                          sdf_cylinder(p_point+vec3(0.,0.75,0.),0.75,50.),\n                          op_union(\n                            sdf_cylinder(p_point+vec3(0.,37.5,0.),36.5,5.),\n                            sdf_cylinder(p_point+vec3(0.,74.25,0.),0.75,20.))\n                        );\n    \n    case 1:\n        p_point -= vec3(20.,8.5+EPS_OH,5.);\n        return op_substraction(\n                         op_union(\n                           op_substraction(\n                             op_Sunion(\n                               op_union(\n                                 sdf_cylinder(p_point,8.5,4.5),    \n                                 sdf_sphere(p_point-vec3(0.,8.5,0.),4.5)),\n                               op_union(\n                                 sdf_cylinder(p_point-vec3(0.,16.8,0.),4.2,1.5),\n                                 op_round(sdf_cylinder(p_point-vec3(0.,20.2,0.),0.3,1.5),0.1))\n                                 ,0.3),\n                             op_Sunion(\n                               op_union(\n                                 sdf_cylinder(p_point-vec3(0.,0.1,0.),8.45,4.3),\n                                 sdf_sphere(p_point-vec3(0.,8.5,0.),4.3)),\n                               sdf_cylinder(p_point-vec3(0.,17.,0.),5.,1.3)\n                               ,0.3)),\n                           sdf_sphere(p_point+vec3(0.,9.5,0.),4.)),  \n                         op_union(\n                           sdf_sphere(p_point+vec3(0.,9.5,0.),3.8), \n                           sdf_plane(p_point,vec3(0.,1.,0.),8.5))\n                       );\n        \n        case 2:\n            p_point -= vec3(-3.,5.4+EPS_OH,18.);\n            return op_Sunion(\n                         op_substraction(\n                           op_onion( sdf_ellipsoid_glass(p_point-vec3(0.,11.,0.),vec3(4.,6.,4.)),0.1 ),\n                           sdf_plane(p_point,vec3(0.,-1.,0.),15.)),\n                         op_Sunion(\n                           sdf_cylinder(p_point,5.,0.4),\n                           sdf_cylinder(p_point+vec3(0.,5.2,0.),0.2,3.5)\n                           ,0.4)\n                         ,0.2\n                       );\n        \n        case 3:\n            p_point -= vec3(20.,8.45+EPS_OH,5.);\n            return op_substraction(\n                     sdf_cylinder(p_point-vec3(0.,0.1,0.),8.45,4.3),\n                     sdf_sphere(p_point+vec3(0.,9.5,0.),4.)\n                   );\n        \n        case 4:\n            p_point -= vec3(0.,2.2+EPS_OH,35.);\n            return op_Ssubstraction(\n                     op_onion(\n                           op_intersection(\n                             sdf_box(p_point,vec3(15.,2.,10.)),\n                             op_intersection(\n                               sdf_ellipsoid_plate(p_point,vec3(15.,4.,10.)),\n                               sdf_ellipsoid_plate(p_point,vec3(10.,4.,15.))))\n                           ,0.2),\n                         sdf_plane(p_point,vec3(0.,-1.,0.),0.)\n                         ,0.2\n                       );\n       \n        case 5:\n            p_point -= vec3(0.,2.75+EPS_OH,35.);\n            p_point.x = p_point.x-5.*clamp(round(p_point.x/5.),-1.,1.); // repetition\n            p_point = abs(p_point); // symetrie en xyz \n            return op_union(\n                     op_substraction(\n                       op_round(sdf_cylinder(p_point, 2.1, 1.1),0.2),\n                       sdf_sphere(p_point-vec3(0.,2.5,0.),1.5)),\n                     op_Sunion(\n                       op_Sunion(\n                         sdf_capsule(p_point-vec3(0.,0.,1.5),1.7,0.8),\n                         sdf_capsule(p_point-1.5*vec3(sin(PI_SIX),0.,cos(PI_SIX)),1.7,0.8)\n                         ,0.1),\n                       op_Sunion(\n                         sdf_capsule(p_point-1.5*vec3(sin(PI_THREE),0.,cos(PI_THREE)),1.7,0.8),\n                         sdf_capsule(p_point-vec3(1.5,0.,0.),1.7,0.8)\n                         ,0.1)\n                       ,0.1)\n                   );\n        \n        case 6:\n            return sdf_plane(p_point,vec3(0.,1.,0.),75.);\n        \n        default : return 1e10;\n    }\n}\n\n// Evaluate the global sdf of the scene and return distance and num nearest primitive\nvec2 evaluateScene(in vec3 p_point, in bool[int(NB_OBJ)] p_shrinkScene){\n    float tmp, num=-1., res = 1e10;\n\n    for(float i=0.; i<NB_OBJ ;i++)\n        if(p_shrinkScene[int(i)]){\n            tmp = evaluate(p_point,i);\n            if(tmp<res){ num = i; res = tmp; } \n        }\n    \n    return vec2(res,num);\n}\n\nvec2 evaluateScene(in vec3 p_point){\n    float tmp, num=-1., res = 1e10;\n\n    for(float i=0.; i<NB_OBJ ;i++){\n        tmp = evaluate(p_point,i);\n        if(tmp<res){ num = i; res = tmp; } \n    }\n    \n    return vec2(res,num);\n}\n\n\n// Evaluate the global sdf of the scene and return distance\nfloat evaluateAny(in vec3 p_point, in bool[int(NB_OBJ)] p_shrinkScene){\n    float res = 1e10;\n    for(float i=0.; i<NB_OBJ ;i++)\n        if(p_shrinkScene[int(i)])\n            res = op_union(res,evaluate(p_point,i));\n    return res;\n}\n\n// Evaluate scene and find normal by computing gradient at 'p_point'\nvec3 findNormal( in vec3 p_point, in vec2 p_hit ){\n\treturn normalize(vec3(evaluate( p_point + vec3( EPS_NORMAL, 0., 0. ), p_hit.y ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., EPS_NORMAL, 0. ), p_hit.y ),\n\t\t\t\t\t\t  evaluate( p_point + vec3( 0., 0., EPS_NORMAL ), p_hit.y ))\n\t\t\t\t\t -p_hit.x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/wsVSDd \nmat3 rotationMatrix(in vec3 p_rot){\n    float c = cos(p_rot.x), s = sin(p_rot.x);\n    mat3 rx = mat3(1, 0, 0,\n                   0, c,-s,\n                   0, s, c);\n                   \n    c = cos(p_rot.y), s = sin(p_rot.y);\n    mat3 ry = mat3(c, 0,-s, \n                   0, 1, 0,\n                   s, 0, c);\n                   \n    c = cos(p_rot.z), s = sin(p_rot.z);\n    mat3 rz = mat3(c,-s, 0,\n                   s, c, 0,\n                   0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){        \n    ivec2 fc = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, fc, 0);\n    int index = fc.x+fc.y*int(iResolution.x);\n    \n    if(iFrame==0){\n        if(index == 0) fragColor = vec4(POS_CAM,0.);\n        if(index == 1) fragColor = vec4(iMouse);\n        if(index == 2) fragColor = vec4(1.);\n        if(index == 3) fragColor = vec4(iResolution,0.);\n        \n    }else{\n        vec4 prevMouseState = texelFetch(iChannel0, ivec2(1,0), 0);\n        vec3 camPosition = texelFetch(iChannel0, ivec2(0), 0).xyz;\n        float isScreenChange = 0.;\n\n        vec3 camRotation = vec3(0.,0.,0.);\n        if(iMouse.z >= 0. && prevMouseState.z >= 0. && iMouse != prevMouseState){\n            camRotation.yz = (prevMouseState.xy-iMouse.xy)*(iResolution.x/iResolution.y) * CAM_SENSIBILITY;\n            isScreenChange = 1.;\n        }else if(iResolution != texelFetch(iChannel0, ivec2(3,0), 0).xyz){\n            isScreenChange = 1.;\n        }\n        \n        if(index == 0) fragColor = vec4(camPosition*rotationMatrix(camRotation),0.);\n        if(index == 1) fragColor = vec4(iMouse);\n        if(index == 2) fragColor = vec4(isScreenChange); \n        if(index == 3) fragColor = vec4(iResolution,0.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool isDirectLigthing( in vec3 p_d, in vec3 p_rayO, in float p_tMax){\n    float dist, t=0.;\n    \n    bool[int(NB_OBJ)] scene = shrinkScene(p_d,p_rayO,p_tMax);\n\n    for(int nbStep=MAX_STEP+Z; nbStep>0 ;nbStep--){\n        dist = evaluateAny(t*p_d+p_rayO,scene);\n        if(dist<EPS) return false;\n        t += dist; \n        if(t>p_tMax) break;\n    }\n    \n    return true;\n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/global-illumination-path-tracing/global-illumination-path-tracing-practical-implementation\nvec3 computeWM(in vec3 p_normal, in Material p_m){\n    float tmp = rand();\n    float theta = acos(sqrt((1.-tmp)/max(1e-3,(tmp*(p_m.r*p_m.r-1.)+1.))));\n    float phi = TWO_PI * rand();\n    float sinT = sin(theta);\n    vec3 wm = vec3(sinT*cos(phi), cos(theta) , sinT*sin(phi)); // tangent space\n    \n    vec3 tangent = normalize( (abs(p_normal.x)>abs(p_normal.y)) ? vec3(p_normal.z,0.,-p_normal.x) : vec3(0.,-p_normal.z,p_normal.y)); \n    vec3 bitangent = cross(p_normal,tangent); \n    \n    return wm*transpose(mat3(tangent,p_normal,bitangent));\n}\n\nvec3 trace( in vec3 p_rayD, in vec3 p_rayO, in float p_tMax){\n    int nbStep; \n    float ni, no, t, dist ,inside, num_inside;\n    vec3 normal, point, totalColor=vec3(0.), rayColor=vec3(1.), d=p_rayD, o=p_rayO;\n    bool[int(NB_OBJ)] scene = shrinkScene(d,o,p_tMax);\n    vec2 hit = evaluateScene(o,scene);   // hit = vec2(distance, num OBJ nearest)\n    \n    if(hit.x<0.){ni=materials[int(hit.y)].ior; inside=-1.; num_inside=hit.y;}\n    else ni = inside = 1.;\n    t = hit.x*inside;\n\n    for(int i=NB_BOUNCE+Z; i>0 ;i--){\n        for(nbStep=MAX_STEP+Z; nbStep>0 ;nbStep--){\n            point = t*d + o;\n            hit = (inside==1. ? evaluateScene(point,scene) : vec2(evaluate(point,num_inside),num_inside));\n        \n            if((dist = hit.x*inside)<EPS){\n                Material m = materials[int(hit.y)];\n                normal = findNormal(o = point, hit)*inside; // face the ray dir in all case\n                vec3 offsetRefract = o-normal*(EPS_OH+dist);\n                vec3 offsetReflect = o+normal*(EPS_OH-dist);\n                        \n                vec2 hitNo = evaluateScene(offsetRefract);\n                no = (hitNo.x<0. ? materials[int(hitNo.y)].ior : 1.);\n                \n                vec3 wi = -d;\n                vec3 wm = normalize(computeWM(normal,m));\n                vec3 wo = normalize(reflect(d,wm));\n                vec3 refractRay = refract(d, wm, ni/no); // no can't be 0.\n                float lenRefRay = length(refractRay);\n                \n                float cTi = dot(wm, wi);\n                if(cTi<=0. || dot(wo,normal)<=0.) return totalColor;\n                         \n                if( m.ior==0. || ((ni>no) && asin(no/ni)<acos(cTi)) || lenRefRay<EPS || dot(normal,refractRay)>=0. || rand()<fresnel(ni,no,cTi,dot(-wm, refractRay/lenRefRay))){\n                    o = offsetReflect;\n                    d = wo;\n                    t = 0.;\n                    \n                    // sun direct lighting\n                    vec3 wl = vec3(0.5,0.5,-0.15);\n                    wl += (vec3(rand(),rand(),rand())-0.5)*SUN_NORMAL_JITTER;\n                    wl = normalize(wl);\n                    if(inside==1. && isDirectLigthing(wl,o,p_tMax))\n                        totalColor += SUN_POWER*SUN_COLOR*rayColor*GGX(wi,wl,normal,m);\n                        \n                    rayColor *= GGX_MIS(wi,wo,wm,normal,m);\n                     \n                }else{\n                    o = offsetRefract;\n                    d = refractRay/lenRefRay;\n                    \n                    if(inside==-1.) rayColor *= materials[int(num_inside)].colorAbsorb/pow(10.,(t+dist)*materials[int(num_inside)].absorptivity);\n\n                    if(hitNo.x<0.){\n                        inside = -1.; \n                        num_inside=hitNo.y;\n                    }else inside=1.;\n\n                    t = hitNo.x*inside;\n                    ni = no;\n                }\n                \n                if(length(rayColor)<1e-2) return totalColor;\n                \n                scene = shrinkScene(d,o,p_tMax);\n                break;\n            }\n\n            t += dist;\n            if(t>p_tMax){\n                vec3 tex = texture(iChannel2, d).xyz;\n                return totalColor+rayColor*ENV_MAP_POWER*tex*tex;;\n            }\n        }\n        if(nbStep==0) break; \n    }\n\n    return totalColor; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    seed = uint(iFrame+1)*uint(fragCoord.x+fragCoord.y*iResolution.x);\n    vec2 uv = fragCoord/iResolution.xy;    // Normalized pixel coordinates (from 0 to 1)\n\n    // --- camera ---\n    vec3 posCam = texelFetch(iChannel1, ivec2(0), 0).xyz;\n    \n    vec3 w = normalize( posCam-LOOKAT );\n    vec3 u = normalize( cross( vec3(0.,-1.,0.) ,w ) );\n    vec3 v = normalize( cross( w ,u ) );\n\n    float size = 2. * tan(0.5*FOVY) * FOCAL_DISTANCE;\n    \n    vec3 viewportV = v * size;\n    vec3 viewportU = u * size * (iResolution.x/iResolution.y); // *aspectRatio\n    vec3 viewportTopLeftCorner = posCam - w*FOCAL_DISTANCE + 0.5*(viewportV - viewportU);\n    \n    vec3 rayD = normalize( viewportTopLeftCorner + viewportU * (uv.x+(rand()-0.5)/iResolution.x) - viewportV * (uv.y+(rand()-0.5)/iResolution.y) - posCam );\n    \n    // --- trace ---\n    fragColor = (texelFetch(iChannel1, ivec2(2,0), 0).x == 1.) ? vec4(0.) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    for(int i=0; i<RAY_PER_FRAME ;i++){\n        fragColor.xyz += trace(rayD, posCam, 1000./dot(rayD,-w));\n        fragColor.w++;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}