{"ver":"0.1","info":{"id":"lltBRf","date":"1540530247","viewed":195,"name":"Environment Shader - Pillars","username":"tiff","description":"Environment Shader Project- endless coliseum, the white color gives it an exquisite, antique, grand, classy vibe. I purposefully did not add another color or rounded sides to make it look more sophisticated, traditional and structural.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["environmentshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n// ============================\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\n//=======================\n\nShape Hallway(vec3 c){\n  Shape shape;\n  vec4 color = vec4(1., 1., 1., 1.);\n  \n  c.z = repeat(c.z, 2.);\n    \n  c.x = abs(c.x)-0.5; //Mirror\n    \n  vec3 boxSize = vec3(.5, 1., .5);\n  vec3 boxOffset = vec3(1., -1.2, 0.);\n  float b1 = fBox(c+ boxOffset, vec3(3.0, .2, .2)); //c- vec3(x, y, z) how much to move the object\n  float b2 = fBox(c- boxOffset, vec3(3.0, .2, .2)); //c- vec3(x, y, z) how much to move the object\n  float b3 = fBox(c- vec3(.8, 0., 0.), vec3(.07, 1., .05)); //left box on column\n  float b4 = fBox(c- vec3(1., 0., -0.17), vec3(.07, 1., .05)); //front box on column\n  float b5 = fBox(c- vec3(1., 0., 0.17), vec3(.07, 1., .05)); //back box on column\n  float b6 = fBox(c- vec3(-.8, 0., 0.), vec3(.07, 1., .05)); //right box on column\n  float b7 = fBox(c- vec3(.0, -1.5, 0.), vec3(.5, .2, 2.));//small box on bottom\n    \n  float col1 = fCylinder(c- vec3(1., 0., 0.), .2, .9);\n  float col2 = fCylinder(c- vec3(1.9, 0., 0.), .2, .9);\n     \n  shape.dist = fOpUnionStairs(col1, b1, .3, 3.);  \n  shape.dist = fOpUnionStairs(shape.dist, b2, .3, 3.);\n  shape.dist = fOpUnionStairs(shape.dist, col2, .3, 3.);\n  shape.dist = fOpUnionStairs(shape.dist, b3, .3, 1.);\n  shape.dist = fOpUnionStairs(shape.dist, b4, .3, 1.);\n  shape.dist = fOpUnionStairs(shape.dist, b5, .3, 1.);\n  shape.dist = fOpUnionStairs(shape.dist, b6, .3, 1.);  \n  shape.dist = fOpUnionStairs(shape.dist, b7, .3, 3.); \n    \n  shape.color = color;\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape hall = Hallway(c);\n  return hall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}