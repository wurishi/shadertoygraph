{"ver":"0.1","info":{"id":"csyXWh","date":"1681084090","viewed":100,"name":"dust particle perturbation","username":"kfalicov","description":"Click+drag to disrupt the particles. Uses mouse behavior from the Chimera's Breath: https://www.shadertoy.com/view/4tGfDW\n\nThe effect is a 'fake' wind that doesn't have any persistent effects on the vortex field.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["curl","smoke","gyroid"],"hasliked":0,"parentid":"csySDR","parentname":"Curl noise dust particles"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    \n    // frame\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    // rendering the dots\n    float minDist = 2.;\n    for (int i = 0; i < 32; i++) {\n        vec2 p = texelFetch(iChannel0, idxToPos(i, int(iResolution.y)), 0).xy;\n        vec2 xydist = abs(uv-p);\n        minDist = min(minDist, max(xydist.x*ar,xydist.y));\n    }\n    if(minDist<dustSize/iResolution.x){\n      fragColor=vec4(1.);\n    }else{\n      fragColor=vec4(0.);\n      //uncomment this to see the noise field\n      //fragColor=texture(iChannel1, uv)*0.5 + 0.5;\n    }\n    \n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\nMaintains the array of particles and computes their new position based on the flow field\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    int n = posToIdx(ivec2(fragCoord), int(iResolution.y));\n    \n    \n    // position of dot\n    vec2 p = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n    \n    //flow field\n    vec2 velocity = texture(iChannel1, p).xy;\n    \n    fragColor = vec4(p+velocity*0.01,0.0,1.0);\n    \n    // ...out of bounds\n    bool b = p.x > iResolution.x/iResolution.y || p.x < 0.0 || p.y > 1.0 || p.y < 0.0;\n\n    // ...randomly\n#ifdef RESET_PROB\n    bool h = hash11(float(n)+float(iFrame)/127.0) < RESET_PROB;\n#else\n    bool h = false;\n#endif\n    \n    //bool o = texture(iChannel2, p).x < 0.5;\n    if ( b || h || iFrame == 0) {\n        // reset position \n        fragColor = vec4(hash22(uv+fract(iTime))*vec2(iResolution.x/iResolution.y, 1.0), 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Simplified from https://www.shadertoy.com/view/cl23Wt\n// basic turbulence because I don't need the rest of the swirling smoke display\n\n#define R iResolution.xy\n\nfloat gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }\nfloat noise (vec3 p)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < octaves; ++i, a/=2.)\n    {\n        p.z += iTime*.1;//+result*.5;\n        result += abs(gyroid(p/a))*a;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = (2.*fragCoord-R.xy)/R.y;\n    \n    //1 pixel LOD\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec3 color=texture(iChannel0, uv).rgb;\n    \n    // curl\n    vec2 e = vec2(.01,0);\n    vec3 pos = vec3(p, length(p));\n    float x = (noise(pos+e.yxy)-noise(pos-e.yxy))/(2.*e.x);\n    float y = (noise(pos+e.xyy)-noise(pos-e.xyy))/(2.*e.x);\n    vec2 curl = vec2(x,-y);\n    \n    //take mouse velocity and adjust the field.\n    vec4 lastMouse = texelFetch(iChannel1, ivec2(0,0), 0);\n    if (iMouse.z > 1. && lastMouse.z > 1.)\n    {\n        vec2 vv = clamp(vec2(iMouse.xy*w - lastMouse.xy*w)*10., -6., 6.);\n        color.xy += .001/(mag2(uv - iMouse.xy*w)+0.001)*vv;\n    }\n  \n    color = mix(color, vec3(curl*str, 0.), delta);\n    \n  \n    fragColor = vec4(color,1.0);\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// if defined, particles have the given probability to teleport to a random position each frame (the closer to 0 the longer the paths)\n#define RESET_PROB 0.001\n\n//the strength of the turbulence, how much it affects the particles\n#define str 0.08\n\n//how quickly the turbulence is modified (0 means never, 1. means always)\n//higher values increase particle jitter\n#define delta 0.01\n\n//the depth of the perlin noise\n#define octaves 4.\n\n//the size of each particle in px. Particles are squares\n#define dustSize 4.\n\n// indexing of the position buffer (Buffer A)\nivec2 idxToPos(int i, int width) {return ivec2(i / width, i % width);}\nint posToIdx(ivec2 i, int width) {return i.x * width + i.y;}\n\nfloat mag2(vec2 p){return dot(p,p);}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 co) {\n    return fract(sin(vec2(dot(co,vec2(167.1,311.7)),dot(co,vec2(269.5,183.3))))*737.5453);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Mouse position storage\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //to get the last mouse pos anywhere\n    //vec4 lastMouse = texelFetch([iChannel corresponding to Buf C], ivec2(0,0), 0);\n    \n    if(iMouse.z<=1.){\n       fragColor=vec4(0.);\n    }else{\n       fragColor=vec4(iMouse.xyz,1.);\n    }\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}