{"ver":"0.1","info":{"id":"X3cSz7","date":"1718761686","viewed":87,"name":"VISUALIZE IT!","username":"multiphonic","description":"This is a very configurable, glitchy, old school music visualizer. It has lots of options that behave unpredictably which is good for happy accidents. I made it with ChatGPT, this is not my field of expertise. I made this to make music more entertaining.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sound","audio","psychedelic","visualizer","bars","eq"],"hasliked":0,"parentid":"43cXR7","parentname":"VISUALIZE IT"},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BARS_COUNT 32\n#define BAR_HEIGHT 1.73\n#define BAR_ASPECT_RATIO 1.3 // Aspect ratio for the bars\n#define BAR_SPACING_PERCENTAGE 0.8\n#define BAR_COLOR vec3(1.0, 1.51, 0.6)\n#define BACKGROUND_COLOR vec3(0.03, 0.23, 0.9)\n#define MIRROR_FLAG 1\n#define ORIENTATION_FLAG 1\n#define CENTER_OVERLAP 0.003\n#define COLOR_POLARITY_FLAG 0\n#define GRADIENT_FLAG 1\n#define GRADIENT_POLARITY_FLAG 1\n#define GRADIENT_OFFSET 0.23\n#define GRADIENT_MULTIPLIER 1.2\n#define GRADIENT_CONTRAST 0.05\n#define MIRROR_Y_BOTTOM_FLAG 1\n#define MIRROR_Y_TOP_FLAG 0\n#define LOUDNESS_EXPONENT 2.23\n#define TRAIL_COUNT 3\n#define TRAIL_SCALE 0.998\n#define TRAIL_DECAY 0.003\n#define BASS_WARP 1.5\n#define AUDIO_ELASTICITY 0.8\n#define FLIP_VERTICAL 0\n#define BKGD_ELASTICITY 2.225\n#define RMS_TIME_WINDOW 10.1 // Time window for RMS calculation in milliseconds\n\n// Zoom control\n#define ZOOM_BASE 0.223\n#define ZOOM_RANGE 5.034\n#define ZOOM_POLARITY 0 // 1 for zoom in with amplitude, -1 for zoom out with amplitude\n#define ZOOM_WRAP_FLAG 1 // Set to 1 to enable wrapping of the zoomed area\n#define ZOOM_MIRROR_FLAG 0 // Set to 1 to enable mirroring of the zoomed area\n#define CUTOFF_FREQ 50.0 // Low-pass filter cutoff frequency in Hz\n\nfloat previousAmplitude = 0.0;\n\n// Precompute constants\nconst float totalBars = float(BARS_COUNT) * (MIRROR_FLAG == 1 ? 2.0 : 1.0);\nconst float barWidth = 1.0 / (totalBars + (totalBars - 1.0) * BAR_SPACING_PERCENTAGE);\nconst float barSpacing = barWidth * BAR_SPACING_PERCENTAGE;\n\n// Function to get the frequency for a given band index\nfloat getFrequency(int index) {\n    float normIndex = float(index) / float(BARS_COUNT);\n    float warpedIndex = pow(normIndex, mix(1.0, 0.5, BASS_WARP));\n    if (ORIENTATION_FLAG == 1) {\n        warpedIndex = 1.0 - warpedIndex;\n    }\n    return warpedIndex;\n}\n\n// Function to get the band value from the texture\nfloat getBand(int index) {\n    float freq = getFrequency(index);\n    return texture(iChannel0, vec2(freq, 0.0)).r;\n}\n\n// Function to calculate RMS for a given time window in milliseconds\nfloat calculateRMS(float timeWindowMs) {\n    float rms = 0.0;\n    float sum = 0.0;\n    float sampleRate = 44100.0; // Assuming audio sample rate of 44100 Hz\n    int sampleCount = int(timeWindowMs * sampleRate / 1000.0);\n    int sampleStep = max(1, sampleCount / 128); // Reduce the number of samples to 64\n\n    // Sum the squares of the audio texture samples\n    for (int i = 0; i < sampleCount; i += sampleStep) {\n        float sampleIndex = float(i) / sampleRate;\n        float amplitude = texture(iChannel0, vec2(0.5, sampleIndex)).r;\n        sum += amplitude * amplitude;\n    }\n\n    // Calculate the mean of the squares\n    float meanSquare = sum / float(sampleCount / sampleStep);\n\n    // Calculate the RMS value as the square root of the mean square\n    rms = sqrt(meanSquare);\n\n    return rms;\n}\n\n// Function to get gradient color based on height and gradient parameters\nvec4 getGradientColor(float t) {\n    if (GRADIENT_FLAG == 1) {\n        t = clamp(GRADIENT_OFFSET + t * GRADIENT_MULTIPLIER, 0.0, 1.0);\n        t = pow(t, mix(1.0, 3.0, GRADIENT_CONTRAST));\n        vec3 color = mix(BACKGROUND_COLOR, BAR_COLOR, t);\n        return vec4(GRADIENT_POLARITY_FLAG == 1 ? vec3(1.0) - color : color, 1.0);\n    }\n    return vec4(BAR_COLOR, 1.0);\n}\n\n// Function to apply trail effect with perspective scaling and luminosity decay\nvec4 applyTrailEffect(vec4 color, float trailIndex) {\n    float scale = pow(TRAIL_SCALE, trailIndex);\n    float decayFactor = mix(1.0, 0.0, TRAIL_DECAY) + (1.0 - TRAIL_DECAY) * (1.0 - trailIndex / float(TRAIL_COUNT));\n    color.rgb *= decayFactor * scale;\n    color.a *= decayFactor;\n    return color;\n}\n\n// Function to draw bars\nvoid drawBars(inout vec4 color, vec2 uv, float barWidth, float barSpacing, float scaleX, float rmsAmplitude) {\n    for (int i = 0; i < BARS_COUNT; i++) {\n        float bandValue = pow(getBand(i) * BAR_HEIGHT, LOUDNESS_EXPONENT) * rmsAmplitude;\n\n        for (int t = 0; t < TRAIL_COUNT; t++) {\n            float trailScale = pow(TRAIL_SCALE, float(t));\n            float scaledBandValue = bandValue * trailScale;\n            float barX = (barWidth + barSpacing) * float(i) * trailScale * scaleX + 0.5 * (1.0 - trailScale * scaleX);\n\n            // Draw bars on the left side\n            if (uv.x > barX && uv.x < barX + barWidth * trailScale * scaleX) {\n                float barTop = 0.5 + (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                float barBottom = 0.5 - (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                if (uv.y > barBottom && uv.y < barTop) {\n                    float gradientFactor = (uv.y - barBottom) / (barTop - barBottom);\n                    vec4 barColor = applyTrailEffect(getGradientColor(gradientFactor), float(t));\n                    color = mix(color, barColor, barColor.a); // Blend using alpha\n                }\n            }\n\n            // Draw mirrored bars on the right side\n            if (MIRROR_FLAG == 1) {\n                float overlap = CENTER_OVERLAP;\n                barX = 1.0 - (barWidth + barSpacing) * float(i + 1) * trailScale * scaleX - 0.5 * (1.0 - trailScale * scaleX) + overlap;\n                if (uv.x > barX && uv.x < barX + barWidth * trailScale * scaleX) {\n                    float barTop = 0.5 + (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                    float barBottom = 0.5 - (scaledBandValue / 2.0 * AUDIO_ELASTICITY) * BAR_ASPECT_RATIO;\n                    if (uv.y > barBottom && uv.y < barTop) {\n                        float gradientFactor = (uv.y - barBottom) / (barTop - barBottom);\n                        vec4 barColor = applyTrailEffect(getGradientColor(gradientFactor), float(t));\n                        color = mix(color, barColor, barColor.a); // Blend using alpha\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Low-pass filter function\nfloat applyLowPassFilter(float amplitude, float cutoffFreq) {\n    float rc = 1.0 / (2.0 * 3.141592 * cutoffFreq);\n    float dt = 1.0 / 60.0; // Assuming 60 FPS for the time step\n    float alpha = dt / (rc + dt);\n\n    // Apply the low-pass filter to smooth the amplitude\n    float filteredAmplitude = previousAmplitude + alpha * (amplitude - previousAmplitude);\n    previousAmplitude = filteredAmplitude;\n    return filteredAmplitude;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Flip the screen vertically for phone displays\n    if (FLIP_VERTICAL == 1) {\n        uv = vec2(uv.y, 1.0 - uv.x);\n    }\n\n    // Calculate RMS amplitude for a time window\n    float rmsAmplitude = calculateRMS(RMS_TIME_WINDOW);\n\n    // Apply low-pass filter to the RMS amplitude for zoom factor calculation\n    float filteredAmplitude = applyLowPassFilter(rmsAmplitude, CUTOFF_FREQ);\n\n    // Calculate zoom factor based on filtered amplitude\n    float zoomFactor = ZOOM_BASE + ZOOM_RANGE * pow(filteredAmplitude, BKGD_ELASTICITY);\n    zoomFactor = (ZOOM_POLARITY == 1) ? 1.0 / zoomFactor : zoomFactor;\n\n    // Apply zoom to UV coordinates for background\n    vec2 zoomedUv = (uv - 0.5) / zoomFactor + 0.5;\n\n    // Apply wrapping or mirroring to the zoomed UV coordinates\n    if (ZOOM_WRAP_FLAG == 1) {\n        zoomedUv = fract(zoomedUv);\n    } else if (ZOOM_MIRROR_FLAG == 1) {\n        zoomedUv = abs(fract(zoomedUv * 0.5) * 2.0 - 1.0);\n    }\n\n    // Pull the background from Buffer A\n    vec3 backgroundColor = texture(iChannel1, zoomedUv).rgb;\n\n    // Initial color based on background from Buffer A\n    vec4 finalColor = vec4(backgroundColor, 1.0);\n\n    // Draw bars\n    vec4 barColor = vec4(0.0, 0.0, 0.0, 0.0);\n    drawBars(barColor, uv, barWidth, barSpacing, 1.0, rmsAmplitude);\n\n    // Buffer the bar calculations\n    vec4 bufferedColor = barColor;\n\n    // Apply post-process mirroring effect to the buffered color\n    if (MIRROR_Y_BOTTOM_FLAG == 1) {\n        vec2 mirroredUv = uv;\n        mirroredUv.y = 1.0 - uv.y;\n        vec4 mirrorColor = vec4(0.0, 0.0, 0.0, 0.0);\n        drawBars(mirrorColor, mirroredUv, barWidth, barSpacing, 1.0, rmsAmplitude);\n        bufferedColor.rgb = mix(bufferedColor.rgb, mirrorColor.rgb, step(0.5, uv.y));\n    }\n\n    if (MIRROR_Y_TOP_FLAG == 1) {\n        vec2 mirroredUv = uv;\n        mirroredUv.y = 1.0 - uv.y;\n        vec4 mirrorColor = vec4(0.0, 0.0, 0.0, 0.0);\n        drawBars(mirrorColor, mirroredUv, barWidth, barSpacing, 1.0, rmsAmplitude);\n        bufferedColor.rgb = mix(bufferedColor.rgb, mirrorColor.rgb, step(uv.y, 0.5));\n    }\n\n    // Combine final background and buffered bar colors\n    finalColor.rgb = mix(finalColor.rgb, bufferedColor.rgb, bufferedColor.a);\n\n    if (COLOR_POLARITY_FLAG == 1) {\n        finalColor.rgb = vec3(1.0) - finalColor.rgb;\n    }\n\n    fragColor = finalColor;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Helper function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Helper function for lens warp effect\nvec2 lensWarp(vec2 uv, float convexity) {\n    vec2 centeredUv = uv - 0.5;\n    float r = length(centeredUv);\n    float theta = atan(centeredUv.y, centeredUv.x);\n    r = pow(r, convexity); // Apply convexity\n    vec2 warpedUv = vec2(r * cos(theta), r * sin(theta)) + 0.5;\n    return warpedUv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Define constants for checkerboard effect\n    #define CHECKER_SIZE 5.0\n    #define ASPECT_RATIO 1.0 // Aspect ratio for the checkerboard\n    #define BASE_BPM 120.0 // Base beats per minute for the color cycling LFO\n    #define BPM_MULTIPLIER .05 // Multiplier for BPM\n    #define GRADIENT_INTENSITY 0.4 // Intensity of the interior gradients\n    #define CONVEXITY -1.23 // Convexity control, -1 is concave, 1 is convex\n    #define HUE_CENTER 0.5 // Central hue value (0.0 to 1.0)\n    #define HUE_RANGE 1.5 // Bipolar hue range (0.0 to 0.5)\n    #define SATURATION 2.0 // Saturation for the colors\n    #define VALUE 0.5 // Value (brightness) for the colors\n\n    // Time in seconds\n    float time = iTime;\n\n    // Calculate the LFO based on BPM and multiplier\n    float bpm = BASE_BPM * BPM_MULTIPLIER;\n    float lfo = 0.5 * (1.0 + sin(2.0 * 3.141592 * (bpm / 60.0) * time));\n\n    // Calculate the current hue\n    float hue1 = mod(HUE_CENTER + HUE_RANGE * (lfo - 0.5), 1.0);\n    float hue2 = mod(HUE_CENTER + 0.5 + HUE_RANGE * (lfo - 0.5), 1.0); // Ensuring hue2 is always 180 degrees from hue1\n\n    // Convert HSV to RGB\n    vec3 color1 = hsv2rgb(vec3(hue1, SATURATION, VALUE));\n    vec3 color2 = hsv2rgb(vec3(hue2, SATURATION, VALUE));\n\n    // Adjust UV coordinates for aspect ratio\n    uv.x *= ASPECT_RATIO;\n\n    // Apply lens warp effect\n    uv = lensWarp(uv, CONVEXITY);\n\n    // Create checkerboard pattern\n    vec2 checkUv = uv * CHECKER_SIZE;\n    float checkPattern = mod(floor(checkUv.x) + floor(checkUv.y), 2.0);\n\n    // Calculate interior gradient\n    vec2 fractUv = fract(checkUv);\n    float gradient = abs(fractUv.x - 0.5) + abs(fractUv.y - 0.5);\n\n    gradient = clamp(gradient * 2.0, 0.0, 1.0);\n\n    // Mix the colors with the gradient\n    vec3 checkerColor = mix(color1, color2, checkPattern);\n    checkerColor = mix(checkerColor, vec3(1.0), gradient * GRADIENT_INTENSITY);\n\n    // Enhance shading effect with additional warping\n    vec3 shading = vec3(1.0) - checkerColor;\n    checkerColor = mix(checkerColor, shading, gradient * GRADIENT_INTENSITY * 0.5);\n\n    fragColor = vec4(checkerColor, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}