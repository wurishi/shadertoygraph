{"ver":"0.1","info":{"id":"WsGGWt","date":"1574364912","viewed":482,"name":"WATER DANCE","username":"Ayoub","description":"A shader implementation of the Lattice-Boltzmann method for fluid sim.\nThe 9 densities for each fragment/cell are packed in the RGB channels.\nFor lighting, normals are estimated from cell densities.\n\nTWITTER: https://twitter.com/AyoubKhammasi\n","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["light","sphere","fluid","latticeboltzmann"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T(i) texture(iChannel0, i)\n#define rotSpeed 0.2\n#define blue vec3(50.0, 129.0, 168.0)/255.0\n#define yellow  vec3(179.0, 101.0, 0.0)/255.0\n\nconst float thickness = 0.5;\n\n//estimating the  normal by calculating the neghibor cells density difference from the current cell\nvec3 getNormal(vec2 uv)\n{\n\tvec2 o = vec2(1.0) / iResolution.xy;\n    float d = T(uv).w;// this cell calculated density\n    vec2 n2d = vec2(0.0);\n    for(int i = 0; i < 9; i++)\n        n2d += e[i] * (T(uv + (e[i]/iResolution.xy)).w - d);\n    \n    return normalize(vec3(n2d, d*thickness));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized UVs\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    //Final output colot\n    vec4 col;\n\n    //possible final color\n    vec3 pCol = blue; //Light Blue\n\n    //COLORING THE FLUID\n    //Normals from densities\n    vec3  n=getNormal(uv);\n    //getting ambient light from cube map\n    pCol*= texture(iChannel1, n).xyz;\n\t\n    \n    //COLORING THE SPHERE\n    vec2 c = iMouse.xy /iResolution.y;\n    vec2 pos = fragCoord/iResolution.y;\n\n    float rad = sRad + 0.01;\n    if(distance(pos, c) <= rad)\n    {\n        //Normals from sphere\n        n = getSphereNormal(c,rad, pos);\n        pCol = vec3(133.0, 149.0, 158.0)/255.0;\n        //pCol = vec3(163.0, 146.0, 36.0)/255.0;\n        \n        //sphere dirt and reflection\n        float offset = iTime*rotSpeed*2.0*PI;\n        vec3 s = texture(iChannel1,n + vec3(sin(offset),cos(offset),0.0)).xyz;\n        vec3 ref = texture(iChannel2, abs(n + vec3(c,0.0)).yxz).xyz;\n        pCol*=pow(s.x,.7)*ref;\n    }\n    \n    //SPECULAR LIGHTING\n    vec3 light = normalize(vec3(2,1.0,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,20.0)*2.5;\n\tcol = vec4(pCol,1.0)*vec4(diff)+vec4(spec);\n    \n    //fragColor=vec4(n,1);//testing normals\n\n    fragColor = col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//cells are initialized with this value\nconst float initDen = 10000.0;\nconst float ifv = 0.4; //inflow condition velocity: the x component of the imposed velocity U\n\n\n//const vec2[9] e = vec2[](vec2(-1.0,-1.0), vec2(-1.0,0.0),vec2(-1.0,1.0),vec2(0.0,-1.0),vec2(0.0,0.0),vec2(0.0,1.0),vec2(1.0,-1.0),vec2(1.0,0.0),vec2(1.0,1.0));\n\n\nvec3 bc = vec3 (0.0,.0,1.);\n\nint invInd(int i) { return (8-i);}\n\n//Get the boundaries (non fluid cells)\nbool isBoundary(vec2 pos)\n{\n    pos /= iResolution.y;\n    bool res = false;\n    vec2 c = iMouse.xy /iResolution.y;//vec2(1.1, 0.5);\n    c = vec2(c.x, c.y);\n    float r = sRad;\n    \n    //Circle \n    if(distance(pos, c) <= r)\n        return true;\n    //top and bottom\n    if((pos.y <= 0.001) || (pos.y >= .999))\n        return true;\n}\n\n//fills the densities array with densities from neighbor cells\n//estimates each cell's color : NOT USED IN FINAL OUTPUT\nvoid getValues(in vec2 pos, out float[9] d, out float rho, out vec2 u, out vec3 col)\n{\n    vec2 dx = vec2(1.0) / iResolution.xy;\n\tfloat p;\n    vec4 frag;\n    col = vec3(0.0);\n    rho = 0.0;\n    u = vec2(0.0);\n    \n    \n    //color estimation variables\n    //float mxDen = 0.0; //maximum density to specify which color to take\n    //float colNorm = 0.0; //color normalizer\n    \n    \n    //inflow condition variables\n    float[3] rhos; //density of each row\n\n    vec2 t = pos * iResolution.xy;\n    for(int i = 0; i < 9; i++)\n    {\n        vec2 np = pos + dx*e[i]; //normalized position of neighbor cell, with origin in the left bottom corner\n        vec2 pp = np * iResolution.xy; //position of the neghbor cell in pixels, used for boundary detection\n        int id = invInd(i);\n        frag = texture(iChannel0, np);\n\n\t\tp = frag[id/3];\n      \td[i] = unpack(p)[id%3]; //old density\n        \n        //OUTFLOW CONDITION\n        if(pos.x >= iResolution.x && i >= 6)\n        {\n            d[i] = d[id]; //copy the values from the previous row\n        }\n        \n        //INFLOW CONDITION\n        rhos[i/3] += d[i];\n        \n        // summing the velocity u by adding the density mutplied by the direction it came from\n        u += d[i] * e[id];\n        \n        //estimating the cell color\n        /*if(!isBoundary(pp))\n        {\n            col  += d[i] * unpack(frag.w);\n            colNorm += d[i];\n        }*/\n           \n    }\n    \n    //INFLOW CONDITION UNCOMMENT FOR USING INFLOW\n    if(pos.x <= 0.001)// first vertical line of cells doesn't have access to left densities 0,1 and 2, so we estimate them by imposing an inflow velocity\n        rho = (rhos[1] + 2.0*rhos[2]) / (1.0 - ifv); \n    else\n\t    rho = rhos[0] + rhos[1] + rhos[2];\n    \n    \n    u /= rho; //normalizing the velocity\n    \n\t//col /=colNorm; //Normlizing the col\n}\n\n//Set all the values in a vec4\nvoid setValues(in float[9] d,in float rho,in vec3 col, out vec4 p)\n{\n    p.x = pack(vec3(d[0],d[1],d[2])); //left row of densities\n    p.y = pack(vec3(d[3],d[4],d[5])); // middle row\n    p.z = pack(vec3(d[6],d[7],d[8])); // right row\n    //p.w = pack(col);//For testing\n    p.w = rho;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalized UVs\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    //populations are initialized or not\n    bool init = (iFrame != 0);\n\t\n    //Final output, xyz contains the 9 number densities packed and w contains the RGB conponents of the color/the density RHO\n    vec4 o = vec4(0.0);\n    \n    if(!init) //INITIALIZATION\n    {\n\n        if(!isBoundary(fragCoord))\n        {\n            //Initializing the center of each cell with initDen\n\t\t\to.y = pack(vec3(.0,initDen,.0));\n        }\n    }\n    else\n    {\n        \tfloat[9] den; //neighbor densities\n\n        \tfloat rho; //microscopic density\n        \tvec2 u; //microscopiv velocity (non thermal)\n        \tvec3 col;\n        \tgetValues(uv, den, rho, u, col);\n\t\t\t\n        \tif(!isBoundary(fragCoord))\n            {\n            \tfloat usqr = (3.0 / 2.0)  * (u.x*u.x + u.y*u.y);\n\t        \tfloat eu;\n    \t    \tfloat[9] eq; //equilibrium density\n        \t\tfor(int i = 0; i < 9; i++)\n        \t\t{\n            \t\teu = 3.0*dot(e[i],u);\n            \t\teq[i] = rho*w[i]*(1.0 + eu + 0.5*eu*eu - usqr);\n            \n            \t\t//streaming\n            \t\tden[i] =den[i] + (eq[i] - den[i]);\n \t\t        }\n           \t}\n            else\n            {\n                //If this is a boundary, no need to calulate anything, just store the desnities from neighbor fluid cells\n                col = bc;\n                rho = 0.0;\n            }\n       \t\n        //pack densities and rho (col for testing) in the final fragment output\n         setValues(den, rho,col, o);\n     \n    }\n    fragColor = o;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//COMMON DEFINES\n#define sRad 0.1\n\n\n//THIS ARRAY OF DIRECTIONS FOR NON SPECULAR BOUNDARY CONDITIONS\nconst vec2[9] e = vec2[](vec2(-1.0,-1.0), vec2(-1.0,0.0),vec2(-1.0,1.0),vec2(0.0,-1.0),vec2(0.0,0.0),vec2(0.0,1.0),vec2(1.0,-1.0),vec2(1.0,0.0),vec2(1.0,1.0));\n\n//THE PROBABILITY FOR EACH DIRECTION\nconst float[9] w = float[](1.0/36.0, 1.0/9.0 , 1.0/36.0 , 1.0/9.0 , 4.0/9.0, 1.0/9.0 , 1.0/36.0, 1.0/9.0 , 1.0/36.0);\n\nconst float c_precision = 512.0;\nconst float c_precisionp1 = c_precision + 1.0;\nconst float PI = 3.141592653589793238462643383279;\n\nfloat pack(vec3 color)\n{\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn floor(color.r * c_precision + 0.5)\n\t\t+ floor(color.b * c_precision + 0.5) * c_precisionp1\n\t\t+ floor(color.g * c_precision + 0.5) * c_precisionp1 * c_precisionp1;\n}\n\nvec3 unpack(float value) {\n\tvec3 color;\n\tcolor.r = mod(value, c_precisionp1) / c_precision;\n\tcolor.b = mod(floor(value / c_precisionp1), c_precisionp1) / c_precision;\n\tcolor.g = floor(value / (c_precisionp1 * c_precisionp1)) / c_precision;\n\treturn color;\n}\n\nvec3 getSphereNormal(vec2 c,float r, vec2 p)\n{\n    //distance from sphere center to point p on plane\n    float d = distance(c,p);\n    \n    //the z component of the point p projected from the plane on the sphere\n    float z = sqrt(r*r - d*d);\n    \n    return normalize(vec3(p,z) - vec3(c,0.0));\n}\n\nvoid inverseDensities(float[9] den, out float[9] id)\n{\n\tfor(int i = 0; i < 9; i++)\n        id[i] = den[8-i];\n}\n\n","name":"Common","description":"","type":"common"}]}