{"ver":"0.1","info":{"id":"ctXGWB","date":"1672291172","viewed":130,"name":"Regolith","username":"Dusty","description":"making sure marcher doesnt overstep and such\nand toying with a roving camera strategy","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["marching","proceduralterrain","camerastyle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXT 192.0\n#define MAXITER 768\n#define SMOOTHING 96.0\n\nvec3 Ray(vec3 pos, vec3 lookat, vec3 up)\n{\n  vec3 forward \t= normalize(lookat - pos);\n  vec3 rightward = normalize(cross(up, forward));\n  vec3 upward \t= cross(rightward, forward);\n  vec2 uv       = (-2.0 * gl_FragCoord.xy + iResolution.xy) / max(iResolution.x, iResolution.y);\n  vec3 dir      = uv.x * rightward + uv.y * upward + 1.4*forward;\n  return normalize(dir); \n}\n\nfloat heightfield(vec2 p)\n{\n  float r = noise(0u, 0.0625 * p);\n  float r2 = noise(1u, 0.0625 * p);\n  r *=r;\n  r2 *= r2;\n  r2 *= r2*r2;\n  r = smin(r, r2, SMOOTHING);\n  return 10.0 * r;\n}\n\nfloat field(vec3 p)\n{\n  float r = heightfield(p.xz);\n  r -= 0.04 * heightfield(p.xz * 12.0); // extra detail, what may cause marcher to overstep too much\n  float f = p.y - r;\n  return f;\n}\n\nfloat fieldcast(vec3 o, vec3 d, float t, float maxt)\n{\n  int iter = 0;\n  while(t < maxt && iter < MAXITER)\n  {\n    vec3 p = o + t * d;\n    float de = field(p);\n    // making the threshold alarmingly large prevents some overstep acne\n    // scaling to t however makes it not so alarming\n    if(abs(de) < t * 0.001) return t; \n    t += de; // can take steps backwards when it oversteps\n    iter += 1;\n  }\n  return t;\n}\n\nconst vec3 PNN = vec3(+1.0,-1.0,-1.0);\nconst vec3 NNP = vec3(-1.0,-1.0,+1.0);\nconst vec3 NPN = vec3(-1.0,+1.0,-1.0);\nconst vec3 PPP = vec3(+1.0,+1.0,+1.0);\n\nvec3 fieldgradient(vec3 p, float h)\n{\n  return normalize( field(p + h*PNN)*PNN \n                  + field(p + h*NNP)*NNP \n                  + field(p + h*NPN)*NPN \n                  + field(p + h*PPP)*PPP );\n}\n\nvec3 path(float t)\n{\n  vec2 p = vec2(64.0 * cos(0.050*t), 64.0 * cos(0.071*t));\n  return vec3(p.x, \n              0.8 + 0.5*cos(0.11*t) + heightfield(p), \n              p.y);\n}\n\nvec3 spath(float t, float k)\n{\n  return 0.0625 * path(t-2.0*k)\n       + 0.2500 * path(t-1.0*k)\n       + 0.3750 * path(t)\n       + 0.2500 * path(t+1.0*k)\n       + 0.0625 * path(t+2.0*k);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 pos    = spath(iTime, 0.25);\n  vec3 lookat = spath(iTime+0.5, 0.25);\n  vec3 up     = normalize(spath(iTime+4.0, 0.25) + vec3(0,5,0) - pos);\n  vec3 dir = Ray(pos, lookat, up);\n  float t = clamp(fieldcast(pos, dir, 0.0, MAXT), 0.0, MAXT);\n  vec3 p = pos + t * dir;\n  vec3 n = fieldgradient(p, 0.001);\n  float v = clamp(dot(n, -dir), 0.0, 1.0);\n  vec3 ldir = normalize(vec3(0,64,0) - p);\n  //float l = clamp(dot(n, ldir), 0.1, 1.0);  // \"real\" lighting eq with ambient term\n  float l = 0.5 + 0.5 * dot(n, ldir);         // faux global illum replacing ambient term\n  \n  vec3 fog = vec3(0.5,0.5,0.6);\n  float tex = pow(fnoise(17u, 32.0, p), 0.5);\n  vec3 clr = mix(vec3(0.25,0.25,0), vec3(1,1,1),tex) * pow(v, 0.25) * l;\n  vec3 c = mix(clr, fog, t / MAXT);\n  fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float logsumexp(float a, float b)\n{\n  return log2( exp2(a) + exp2(b) );\n}\nfloat smax(float a, float b, float k) \n{ \n  return (1.0 / k) * logsumexp(k*a, k*b); \n} \nfloat smin(float a, float b, float k) \n{ \n  return -smax(-a, -b, k); \n} \n\n\nuint hash(uint x)             { return (0x33d326e5u*x) ^ ((0x33d326e5u*x) >> 16); }\n\nuint rnd(uint seed, uvec2 v)  { return hash(seed + hash(seed + hash(v.x + hash(v.y)))); }\nuint rnd(uint seed, uvec3 v)  { return hash(seed + hash(seed + hash(v.x + hash(v.y + hash(v.z))))); }\n\nfloat rnd(uint seed, vec2 v)  { return pow(0.5, 24.0) * float(rnd(seed, floatBitsToUint(v))>>8); }\nfloat rnd(uint seed, vec3 v)  { return pow(0.5, 24.0) * float(rnd(seed, floatBitsToUint(v))>>8); }\n\nfloat noise(uint seed, vec2 p)\n{ \n  vec2 fp = fract(p);\n  fp *= fp * (3.0 - 2.0 * fp); // smoothstep  \n  float n00 = rnd(seed, floor(p) + vec2(0,0));\n  float n01 = rnd(seed, floor(p) + vec2(0,1));\n  float n10 = rnd(seed, floor(p) + vec2(1,0));\n  float n11 = rnd(seed, floor(p) + vec2(1,1));\n  float n0 = mix(n00, n01, fp.y);\n  float n1 = mix(n10, n11, fp.y);\n  return mix(n0, n1, fp.x);\n} \nfloat noise(uint seed, vec3 p)\n{ \n  vec3 fp = fract(p);\n  fp *= fp * (3.0 - 2.0 * fp); // smoothstep\n  float n000 = rnd(seed, floor(p) + vec3(0,0,0));\n  float n001 = rnd(seed, floor(p) + vec3(0,0,1));\n  float n010 = rnd(seed, floor(p) + vec3(0,1,0));\n  float n011 = rnd(seed, floor(p) + vec3(0,1,1));\n  float n100 = rnd(seed, floor(p) + vec3(1,0,0));\n  float n101 = rnd(seed, floor(p) + vec3(1,0,1));\n  float n110 = rnd(seed, floor(p) + vec3(1,1,0));\n  float n111 = rnd(seed, floor(p) + vec3(1,1,1));\n  float n00 = mix(n000, n001, fp.z);\n  float n01 = mix(n010, n011, fp.z);\n  float n10 = mix(n100, n101, fp.z);\n  float n11 = mix(n110, n111, fp.z);\n  float n0 = mix(n00, n01, fp.y);\n  float n1 = mix(n10, n11, fp.y);\n  return mix(n0, n1, fp.x);\n} \nfloat fnoise(uint seed, float f, vec3 p)\n{\n  p = 4.0 * f * p;\n  float x;\n  x = (1.0 / 16.0) * noise(seed, p);\n  p *= 0.5;\n  x += (4.0 / 16.0) * noise(seed, p);\n  p *= 0.5;\n  x += (6.0 / 16.0) * noise(seed, p);\n  p *= 0.5;\n  x += (4.0 / 16.0) * noise(seed, p);\n  p *= 0.5;\n  x += (1.0 / 16.0) * noise(seed, p);\n  return x;\n}\n\n","name":"Common","description":"","type":"common"}]}