{"ver":"0.1","info":{"id":"Wsf3D7","date":"1546644505","viewed":655,"name":"Cheeseburger","username":"Xor","description":"This is a cheeseburger SDF I made in three days for a fun little challenge.\nThe code isn't very organized because of time restraints. Sorry!","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["cheese","table","tomato","plate","cheeseburger","burger","hamburger","buns","lettuce","beef"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\"Cheeseburger\" by Xor (@XorDev)\n\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t\n\tThis is a cheeseburger SDF I made in three days for a fun little challenge.\n\tThe code isn't very organized because of time restraints. Sorry!\n*/\n\n//Anti-Aliasing level. Use 2, 3 or 4 if you have a better PC.\n#define AA 1.\n//Light direction vector.\n#define DIR normalize(vec3(-2,4,3))\n\n\n//Inspired by iq's smooth minimum function: https://iquilezles.org/articles/smin\nfloat Smooth(float A, float B, float N)\n{\n \treturn log(exp(A*N)+exp(B*N))/N;   \n}\n//Generic 3D hash function.\nvec3 Hash(vec3 P)\n{\n \treturn fract(sin(P*mat3(45.32,32.42,-41.55,65.35,-43.42,51.55,45.32,29.82,-41.45)*vec3(142.83,253.36,188.64)));\n}\n//Smooth 3D Worley noise.\nfloat Worley(vec3 P)\n{\n    float D = 1.;\n    for(int X = -1;X<=1;X++)\n    for(int Y = -1;Y<=1;Y++)\n    for(int Z = -1;Z<=1;Z++)\n    {\n    \tvec3 F = floor(P+vec3(X,Y,Z));\n        vec3 V = P-F-Hash(F);\n        D = Smooth(D,dot(V,V),-6.);\n    }\n    return D;\n}\n//Heavily modified Worley noise for the Sesame seeds.\nfloat Seed(vec3 P)\n{\n    float D = 1.;\n    for(int X = -1;X<=1;X++)\n    for(int Y = -1;Y<=1;Y++)\n    {\n    \tvec3 F = floor(vec3(P.xy,0)+vec3(X,Y,0));\n        vec3 H = Hash(F)*vec3(1,1,63);\n        vec3 V = mat3(cos(H.z),sin(H.z),0,sin(H.z),-cos(H.z),0,0,0,1)*(P-F-H*.9)*vec3(1.7,1,0);\n        D = min(D,dot(V,V));\n    }\n    return smoothstep(.1*clamp(P.z-3.5,0.,1.),-.01,D);\n}\n//Cheese SDF.\nfloat Cheese(vec3 P)\n{\n    P.z += .19+.1*Smooth(dot(P.xy,P.xy)-3.,0.,10.);\n \treturn (length(max(abs(P)-vec3(1.7,1.7,.01),0.))-.03)*.9;\n}\n//Burger, Plate and table SDF.\nfloat Model(vec3 P)\n{\n    float D = length(P)-2.5;\n    float M = Smooth(length(P.xy)-3.,pow(P.z-Smooth(D,0.,20.)*.7+1.1,2.)-.01,10.);\n    M = min(M,Smooth(P.z+1.2,-abs(mod(P.y+7.,8.)-4.),12.));\n    if (D<.1)\n    {\n    \tvec3 B = vec3(P.xy,max(P.z-.35,0.)*1.6);\n    \tfloat Bun = Smooth(length(B+.05*sin(B.yzx*2.))*.6-1.2,.5-abs(P.z+.1)-.02*B.x*B.x,50.);\n        M = min(M,Smooth(Bun,-1.-P.z,20.));\n    \tM = min(M,Smooth(length(P.xy+.1*sin(B.yx*2.))-2.1,pow(P.z+.03*P.x*P.x,2.)-.04,12.));\n    \tvec3 L = P-vec3(0,0,.26)+vec3(0,0,clamp(length(P.xy)-2.,.0,.2))*\n        \tcos(P.x*5.+sin(P.x*2.+P.y*4.))*sin(P.y*3.+P.x*3.+cos(P.y-P.x*4.));\n    \tM = min(M,Smooth(length(L)-2.3,abs(L.z)-.05,12.)*.8);\n    \tM = min(M,max(length(P)-1.9,abs(P.z+.45-.03*P.y*P.y)-.1));\n    \tM = min(M,Cheese(P));\n        \n        return M;\n    }\n  \t\n\treturn min(D,M);\n}\n//Bump mapped distance function.\nfloat Bump(vec3 P)\n{    \n    float S = .02*Seed(P*5.);\n    float B = .005*max(1.-1.5*abs(P.z),0.)*Worley(P*18.);\n        B += .0004*Worley(P*40.)*step(-.99,P.z-max(length(P.xy)-2.,0.));\n \treturn Model(P)+B*step(.01,Cheese(P))-S;\n}\n//Typical Normal function.\nvec3 Normal(vec3 P)\n{\n\tvec3 N = vec3(-1,1,0)*.001;\n    return normalize(Bump(P+N.xyy)*N.xyy+Bump(P+N.yxy)*N.yxy+Bump(P+N.yyx)*N.yyx+Bump(P+N.xxx)*N.xxx);\n}\n//Burger, plate and table texturing with lighting.\nvec3 Tex(vec3 P,vec3 R)\n{\n    vec3 L = P-vec3(0,0,.26)+vec3(0,0,clamp(length(P.xy)-2.,.0,.2))*\n        cos(P.x*5.+sin(P.x*2.+P.y*4.))*sin(P.y*3.+P.x*3.+cos(P.y-P.x*4.));\n    float T = max(length(P)-1.9,abs(P.z+.45-.03*P.y*P.y)-.1);\n    \n    vec3 N = Normal(P);\n    float W = Worley(P*11.)*(.05+.95*smoothstep(.7,.4,abs(P.z+.04)))*(abs(N.z)*.7+.3);\n    \n    \n \tfloat M = abs(P.z+.03*P.x*P.x)-.3;\n    float D = .2+.8*max(dot(N,DIR),.0)/(1.-min(dot(DIR,P),0.)*exp(4.-2.3*length(cross(DIR,P))));\n    float S = max(dot(reflect(R,N),DIR),0.);\n    \n    vec3 B = vec3(1,.6,.3)*(1.8-smoothstep(.0,1.2,pow(abs(P.z+.1),2.)))\n        +.5*S*S-2.*W+vec3(.5+S*S*S)*Seed(P*5.);\n    vec3 C = mix(B,vec3(.4,.25,.2)-.4*W+.9*S*S*S,step(M,.01));\n    C = mix(C,vec3(.5,.8,.2)-.4*W+.5*S*S,step(abs(L.z),.06));\n    C = mix(C,vec3(1,.6,.1)+S*S,step(Cheese(P),.01));\n    C = mix(C,vec3(1,.2,.1)+S*S,step(T,.01));\n    C = mix(C,vec3(.9)+S*S*S*S,step(P.z-max(length(P.xy)-2.,0.),-.99));\n    C = mix(C,(texture(iChannel0,P.xy/4.).rgb*vec3(.6,.7,.8)+.2),step(P.z,-1.18));\n    \n    return D*C;\n}\n\n//Output the results.\nvoid mainImage( out vec4 Color, in vec2 Coord )\n{\n    vec2 A = vec2(iTime*.2,.2*cos(iTime*.1)+1.8);\n    vec3 X = vec3(cos(A.x)*sin(A.y),sin(A.x)*sin(A.y),cos(A.y)),\n         Y = normalize(cross(X,vec3(0,0,-1))),\n    \t Z = normalize(cross(X,Y));\n    \n    mat3 M = mat3(X,Y,Z);\n    \n    vec3 C = vec3(0);\n    \n    for(float J = 0.;J<AA;J++)\n    for(float K = 0.;K<AA;K++)\n    {\n        vec4 P = vec4(M*vec3(-10,0,2.*cos(A.y)+.4),0);\n        vec3 R = M*vec3(1,(vec2(J,K)/AA+Coord-.5*iResolution.xy)/iResolution.x);\n\n        for(int I = 0;I<200;I++)\n        {\n            float S = Model(P.xyz);\n            P += vec4(R,1)*S;\n            if ((P.w>30.) || (S<.001)) break;\n        }\n\n    \tC += mix(Tex(P.xyz,R),vec3(.9)+.1*dot(DIR,R),clamp(P.w/20.-.5,0.,1.));\n    }\n    Color = vec4(C/AA/AA,1);\n}","name":"Image","description":"","type":"image"}]}