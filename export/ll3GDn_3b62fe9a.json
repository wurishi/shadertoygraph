{"ver":"0.1","info":{"id":"ll3GDn","date":"1468670094","viewed":143,"name":"spheres and softshadow","username":"pyBlob","description":"rendering spheres using raymarching ... with some annoying artifacts :(","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spheres","softshadow","repeating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mapSphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat mapPlane(vec3 p, vec3 normal, float offset)\n{\n    return dot(p, normal) - offset;\n}\n\nvoid mapUnion(inout vec2 a, vec2 b)\n{\n    if (b.x < a.x) a = b;\n}\n\nvec2 map(vec3 p, out vec4 matInfo)\n{\n    vec2 ret = vec2(1e10);\n    \n    float size = 6.0;\n    vec3 offset = floor(vec3(p.x, 0.0, p.z)/size + 0.5)*size;\n    p = p - offset;\n    \n    float angle = dot(offset, vec3(17.16, 0, 2.45));\n    vec3 vx = vec3(cos(angle), 0.0, sin(angle));\n    vec3 vy = vec3(0.0, 1.0, 0.0);\n    vec3 vz = cross(vx, vy);\n    \n    p = mat3(vx, vy, vz) * p;\n    p += 2.0 * (mod(offset * vec3(68.3, 0.0, 150.2), 1.0) - vec3(0.5, 0.0, 0.5));\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0), 1.0),\n            1.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0, 1.0, 1.0), 0.5),\n            2.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0, 1.0, -1.0), 0.5),\n            2.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapSphere(p, vec3(0.0, -1.0, 0.0), 0.5),\n            2.0\n        )\n    );\n    \n    mapUnion(\n        ret,\n        vec2(\n            mapPlane(p, vec3(0.0, 1.0, 0.0), -1.8 + 0.3 * sin(iTime * 0.5)),\n            3.0\n        )\n    );\n    \n    return ret;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773 * 1e-4;\n    return normalize(\n        e.xyy*map( pos + e.xyy, kk ).x +\n        e.yyx*map( pos + e.yyx, kk ).x +\n        e.yxy*map( pos + e.yxy, kk ).x +\n        e.xxx*map( pos + e.xxx, kk ).x\n    );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat getShadow(vec3 ro, vec3 rd)\n{\n    vec2 dist;\n    vec4 matInfo;\n    \n    float shadow = 1.0;\n    float travel = 0.0;\n    \n    for (int i=0 ; i<50 ; i++)\n    {\n        dist = map(ro, matInfo);\n        vec3 normal = getNormal(ro);\n        float d = 0.3 * (1.0 + dot(normal, rd));\n        \n        dist.x += 0.1 * travel + 0.1;\n        travel += max(0.01, dist.x);\n        ro += rd * max(0.01, dist.x);\n        \n        shadow *= 1.0 - 1.0 / (pow(dist.x, 2.0) + 4.0);\n    }\n    \n    return shadow;\n}\n\nvec3 render(vec3 ro, vec3 rd, out float fog)\n{\n    vec2 dist;\n    vec4 matInfo;\n    \n    for (int i=0 ; i<512 ; i++)\n    {\n        dist = map(ro, matInfo);\n        dist.x *= 0.5;\n        ro += rd * dist.x;\n        \n        float density = 0.001;\n        density *= smoothstep(50.0, 20.0, ro.y);\n        fog += density * dist.x;\n    }\n    \n    if (dist.x < 1e-1)\n    {\n        vec3 normal = getNormal(ro);\n        vec3 light = normalize(vec3(-1.0, 1.0, 0.0));\n        \n        float shadow = getShadow(ro + light*0.1, light);\n        \n        if (dist.y == 1.0)\n        {\n            return\n                0.1 * (1.0 + dot(rd, normal)) +\n                shadow * vec3(1.0, 0.7, 0.1);// * max(0.0, dot(light, normal));\n        }\n        else if (dist.y == 2.0)\n        {\n            return\n                0.1 * (1.0 + dot(rd, normal)) +\n                shadow * vec3(0.7, 1.0, 0.1) +//; * max(0.0, dot(light, normal));\n            \tshadow * vec3(1.0) * pow(max(0.0, dot(light, reflect(rd, normal))), 10.0);\n        }\n        else if (dist.y == 3.0)\n        {\n            return\n                0.05 * (1.0 + dot(rd, normal)) +\n                shadow * vec3(0.2, 1.0, 0.05);// * max(0.0, dot(light, normal));\n        }\n    }\n    \n    return vec3(0.4, 0.5, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n    float height = 0.0;\n    height += iMouse.y / iResolution.y;\n    height *= 100.0;\n    height -= 4.5;\n    \n    float angle = iTime * 0.1;\n    vec3  ta = vec3(-0.1,3.0 + height*0.99,0.0);\n    vec3  ro = vec3(-0.1,3.2 + height,0.0) - 4.0*vec3(cos(angle), 0.0, sin(angle));\n    mat3  ca = setCamera( ro, ta, 0.0 );\n    vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n   \tfloat fog = -0.05;\n    vec3 col = render( ro, rd, fog );\n    \n\tfragColor = vec4(sqrt(mix(col, vec3(1.0), fog)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}