{"ver":"0.1","info":{"id":"WdfyRN","date":"1584221662","viewed":262,"name":"Torus knots table","username":"arifr123","description":"A table of the (p,q) Torus Knots.\nBased on my shader [url]https://www.shadertoy.com/view/wtcSW2[/url].\nUse mouse the change camera position.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gradientdescent","torusknot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433\n\n#define sq(x) dot(x, x)\n\nvec2 sic(float t)\n{\n    return vec2(cos(t), sin(t));\n}\n\nstruct TorusKnotParameters\n{\n    float kp;\n    float kq;\n    float r1;\n    float r2;\n    float r3;\n};\n\nvec3 torusKnot(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    return vec3((sicRZ.x + tkp.r1)*sicXY, sicRZ.y);\n}\nvec3 torusKnotDerivative(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    vec2 dSicXY = tkp.kp * vec2(-1, 1) * sicXY.yx;\n    vec2 dSicRZ = tkp.kq * vec2(-1, 1) * sicRZ.yx;\n    \n    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + tkp.r1), dSicRZ.y);\n}\n\nfloat torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return sq(torusKnot(t, tkp) - p);\n}\nfloat torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));\n}\n\nfloat minimizeDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    float lerningRate = 0.01/max(tkp.kq,tkp.kp);\n\tconst int maxIterations = 30;\n    \n    for(int i = 0; i < maxIterations; i++)\n    {\n        float dt = torusKnotSqDistanceDerivative(t, p, tkp);\n        \n        if(abs(dt) < 0.001)\n            break;\n        \n        t -= lerningRate*dt;\n    }\n    \n    return t;\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nfloat torusKnotLineSqDistance(float t, Ray ray, TorusKnotParameters tkp)\n{\n    //|d| = 1\n    \n    //a^2 = c^2 - b^2\n    //a^2 = c^2 - (b/c * c)^2\n    //a^2 = c^2 - (cos() * c)^2\n    \n    return torusKnotSqDistance(t, ray.ro, tkp) - sq(dot(torusKnot(t, tkp) - ray.ro, ray.rd));\n}\nfloat torusKnotLineSqDistanceDerivative(float t, Ray ray, TorusKnotParameters tkp)\n{\n    //return torusKnotSqDistanceDerivative(t, ray.ro, tkp) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);\n    //  ⇓\n\t//return 2.*dot(torusKnot(t, tkp) - ray.ro, torusKnotDerivative(t, tkp)) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);\n\t//  ⇓\n    \n    vec3 tk = torusKnot(t, tkp);\n    vec3 tkd = torusKnotDerivative(t, tkp);\n        \n    //return 2.*dot(tk - ro, tkd) - 2.*dot(tk - ro, rd)*dot(tkd, rd);\n    //  ⇓\n    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd)*dot(tkd, rd));\n    //  ⇓\n    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd*dot(tkd, rd)));\n    //  ⇓\n    return 2.*(dot(tk - ray.ro, tkd - ray.rd*dot(tkd, ray.rd)));\n}\n\nvec3 firstTorusKnotLineSqDistanceMinimumInside(Ray ray, TorusKnotParameters tkp)\n{\n    int sections = 3*int(max(tkp.kq,tkp.kp));\n    float sectionLength = 2.*PI/float(sections);\n    \n    float lerningRate = 0.008/(max(tkp.kq,tkp.kp)-0.75);\n    const int maxIterations = 100;//50\n    \n    float minDist;\n    float bestT;\n    bool found = false;\n    \n    for(int j = 0; j < sections; j++)\n    {\n        float t = sectionLength * float(j);\n        bool failed = false;\n        \n        for(int i = 0; i < maxIterations; i++)\n        {\n            float dt = torusKnotLineSqDistanceDerivative(t, ray, tkp);\n            \n            if(abs(dt) < 0.1)break;\n            \n            t -= lerningRate*dt;\n            \n            \n            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))\n            {\n                failed = true;\n                break;\n            }\n        }\n        if(failed)continue;\n        \n        float lineSqDist = torusKnotLineSqDistance(t, ray, tkp);\n        \n        if(lineSqDist <= sq(tkp.r3))\n        {\n            float distAlongD = dot(torusKnot(t, tkp) - ray.ro, ray.rd);\n\n            if(!found || distAlongD < minDist)\n            {\n                minDist = distAlongD;\n                bestT = t;\n            }\n            \n            found = true;\n        }\n    }\n    \n    return vec3(bestT, minDist, found ? 1. : 0.);\n}\n\nfloat dot01(vec3 a, vec3 b)// [-1, 1] => [0 ,1]\n{\n    return (dot(a, b) + 1.)/2.;\n}\n\nRay intersect(Ray ray, TorusKnotParameters tkp)\n{\n    const int maxIterations = 50;\n    \n    vec3 res = firstTorusKnotLineSqDistanceMinimumInside(ray, tkp);\n    \n    if(res[2] < 0.5)\n    {\n        return Ray(vec3(0), vec3(0));\n    }\n    \n    float t = res[0];\n    vec3 p = ray.ro + res[1] * ray.rd;\n\n    for(int i = 0; i < maxIterations; i++)\n    {\n        t = minimizeDistance(t, p, tkp);\n        float d = sqrt(torusKnotSqDistance(t, p, tkp)) - tkp.r3;\n        p += d * ray.rd;\n\n        if(abs(d) < 0.01)break;\n    }\n\n    vec3 normal = normalize(torusKnot(t, tkp) - p);\n    \n    return Ray(p, normal);\n}\n\nint gcd(ivec2 v)\n{\n    while(v.x != v.y)\n    {\n        if(v.x > v.y)\n            v.x -= v.y;\n        else\n            v.y -= v.x;\n    }\n    \n    return v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 5.*fragCoord/iResolution.xy;\n    ivec2 kpkq = ivec2(uv) + 1;\n    uv = mod(uv, 1.);\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    //vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n\n    vec2 angles = /*false &&*/ iMouse.z > 0.5 ? PI*(2.*iMouse.xy/iResolution.xy - 1.) : PI*vec2(0.7, 0.25)*(sic(0.5*iTime) + vec2(0, 1));\n    vec2 sic0 = sic(angles[0]);\n    vec2 sic1 = sic(angles[1]);\n    \n    vec3 f = vec3(sic1.x * sic0, -sic1.y);\n    vec3 u = vec3(sic1.y * sic0, sic1.x);\n    vec3 r = -cross(u, f);\n    \n    vec3 ro = -8.*f;\n    \n    float zoom = 1.;\n    \n    ////////////////////////////////////The torus knot parameters//////////////////////////////////////////\n    float kp = 3., kq = 5., r1 = 2., r2 = 1., r3 = 0.4;// + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n    // p and q are flipped. The parameters: 'lerningRate', 'maxIterations' and 'sections' also may need to be changed.\n    \n    /*\n    ivec2 kpkq = ivec2(10.*iMouse.xy/iResolution.xy) + 1;\n    kpkq /= gcd(kpkq);\n\t*/\n    \n    kp = float(kpkq.x);\n    kq = float(kpkq.y);\n    \n    TorusKnotParameters tkp = TorusKnotParameters(kp, kq, r1, r2, r3);\n    \n    vec3 rd = normalize(zoom * f + uv.x*r + uv.y*u);\n    \n    \n    Ray lr = intersect(Ray(ro, rd), tkp);\n    \n    vec3 col;\n    \n    if(sq(lr.rd) < 0.5)\n    {\n        col = vec3(0);\n    }\n    else\n    {\n        //reflections\n        for(int i = 0; i < 0; i++)\n        {\n            Ray nr = intersect(lr, tkp);\n            if(sq(nr.rd) < 0.5)\n                break;\n\n            nr.ro -= 0.01*nr.rd;\n            lr = nr;\n        }\n        \n        float offset = 2.*iTime;\n\n        vec2 sicRZ = sic(0.);//PI/2./4.);//22.5°\n\n        vec3 redLight = vec3(sicRZ.x * sic(offset), sicRZ.y);\n        vec3 blueLight = vec3(sicRZ.x * sic(2.*PI/3. + offset), sicRZ.y);\n        vec3 greenLight = vec3(sicRZ.x * sic(2.*2.*PI/3. + offset), sicRZ.y);\n\n        col = vec3(dot01(lr.rd, -redLight), dot01(lr.rd, -blueLight), dot01(lr.rd, -greenLight));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}