{"ver":"0.1","info":{"id":"mdXXRN","date":"1668563734","viewed":168,"name":"[phreax] higher intelligence","username":"phreax","description":"Based on my previous experiment:\n\nhttps://shadertoy.com/view/dssSRn\n\nGreat write up here: https://www.osar.fr/notes/logspherical/","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","neon","logpolar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n#define PALETTE 0\n\n#define LINE_WIDTH 0.0001\n#define MESH_DENSITY 90.\n#define LAYER_DISTANCE 6.5\n\n\nfloat tt, g_mat;\nfloat g_gl = 0.;\nvec3 ro;\n\n// from \"Palettes\" by iq. https://shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getPal(int id, float t) {\n\n    id = id % 7;\n\n    vec3          col = pal( t, vec3(.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,-0.33,0.33) );\n    if( id == 1 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( id == 2 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( id == 3 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( id == 4 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( id == 5 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( id == 6 ) col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    return vec3(col);\n}\n\nmat2 rot2(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\nfloat box(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\nvec3 transform(vec3 p) {\n\n    float a = PI*.5 + iTime;\n    p.xz *= rot2(a);\n    p.xy *= rot2(a);\n    \n    return p;\n}\n\n\nvec3 repeat(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nvec3 kalei(vec3 p) {\n\n    p.x = abs(p.x) - 2.5;\n    \n    \n    vec3 q = p;\n\n    q.y -= .5;\n    q.y += .4*sin(tt);\n    p.y += .3*sin(p.z*3.+.5*tt);\n    float at = length(q) - .01;\n    for(float i=0.; i < 6.; i++) {     \n        p.x = abs(p.x) - 1.5;\n  \n        p.xz *= rot2(1.-exp(-p.z*.14*i)+.2*tt+.1*at);\n        p.xy *= rot2(sin(2.*i)+.2*tt);\n       // p.xz -= .4*sin(tt);\n     \n        p.y += 1.-exp(-p.z*.1*i);\n    }\n    p.x = abs(p.x) + 2.5;\n    \n        \n    return p;\n}\n\n\n// from iq\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat map(vec3 p) {\n\n\n    vec3 bp = p;\n    \n    \n    p.yz *= rot2(-PI*.25);\n    \n    p = kalei(p);\n    \n    // map to log-spherical\n    float r = length(p);\n    p = vec3(log(r),\n             acos(p.z / r),\n             atan(p.y, p.x));\n   \n\n    // some heuristic computation to compensate the log scaling\n    float shrink = 1./abs(p.y-PI) + 1./abs(p.y) - 1./PI;\n    \n    float scale = floor(MESH_DENSITY)/PI; \n    p *= scale;\n    \n    p.x -= tt;\n    p.y -= .7;\n    \n    vec3 id = repeat(p, vec3(LAYER_DISTANCE, .5, .5));\n\n    p.yz *= rot2(.25*PI);\n    p.x *= shrink;\n     \n   // p.x = abs(p.x) - .5;\n  \n    g_mat = bp.y*.6+id.x+abs(bp.x*.2);\n    \n    float w = LINE_WIDTH;\n    float d = length(p.xz) - w;\n    d = min(d, length(p.xy) - w);\n \n    d *= r/(scale*shrink);\n\n   // float sp = length((bp+vec3(0, -0.4, 0))*vec3(1.1, 0.8, 1)) -1.9;\n   \n    float sp = length(bp*vec3(mix(3.9, 0.5, smoothstep(1.5, 1.1, pow(bp.y, 1.))) +\n                              mix(2.0, 0.5, smoothstep(.0, 1.3, pow(bp.y, 10.))), .8, 1) + \n                         vec3(0, -0.4, 0)) -1.9;\n                         \n    sp = opSmoothUnion(sp, length(bp*vec3(1, 1, .8)- vec3(0, 2.4, 0)) - .6, .1);\n   \n    d = opSmoothIntersection(d, sp-.4, .5);\n    \n\n    float ball = length(bp - vec3(0, 1.1, 0.))- .1;\n    g_gl += .0005/(.0001+pow(abs(ball), 4.));\n    \n    return d*.5;\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   // uv *= rot2(PI*.5);\n    vec3 rd = normalize(vec3(uv, .7)),\n         lp = vec3(0.,2., -15);\n         \n    ro = vec3(0, 0.5, -4.);\n         \n    vec3 p = ro;\n    vec3 col = vec3(0);\n    \n    float t, d = 0.1;\n    \n    tt = .3*iTime;\n    \n    float mat = 0.,\n          gl  = 0.;\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    vec3 al = vec3(0);\n    vec3 bg = vec3(0.035,0.094,0.125);\n    \n    for(float i=.0; i<80.; i++) {\n    \n        d = map(p);\n        mat = g_mat;\n        gl = g_gl;\n        \n        if(t > 5.) break;\n        \n        t += max(.01, abs(d));\n        p += rd*d;\n        \n        // shading\n        if(d < 0.006) {\n          \n            al = getPal(PALETTE, mat*.4);\n            col +=  al/exp(t*.8);\n\n        } \n     \n    } \n    \n    if(dot(col, col) < 0.001) {\n        col += bg*mix(.2, 1.1, (1.5-pow(dot(uv, uv), .5)));\n    }\n    \n    // col += 0.01*gl;\n    col *= mix(.1, 1., (1.5-pow(dot(uv, uv), .2))); // vignette\n    col += vec3(0.459,0.725,0.192)*mix(1., .0, smoothstep(0., .4, pow(length(uv+vec2(0, -.1)), .2)-.25)); // vignette\n    col = pow(col, vec3(.6)); // gamma\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0 - t * 0.3);\n}","name":"Image","description":"","type":"image"}]}