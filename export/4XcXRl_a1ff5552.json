{"ver":"0.1","info":{"id":"4XcXRl","date":"1719387017","viewed":43,"name":"Morphing shape and bump mapping","username":"MonadoMaster0","description":"Another successful experiment to learn about texturing, this time bump mapping and morphing at the same time.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["bumpmapping","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RO vec3(0,1,-4)\n#define fog_d 20.0\n#define MAT_GR 0\n#define MAT_BALL 1\n#define MAT_BOX 2\n\n#define REFLECTIVITY 1.2\n#define FOG_LEVEL 1.0\n#define SAMP iChannel0\n\nconst int MAX_ITERATIONS = 80;\nconst float MIN_D = 0.001;\nconst float MAX_D = 50.0;\nconst float BUMP_DEPTH = 0.02;\n\nfloat morphShape(vec3 p, vec3 bs, float sps) {\n    float sp = sdSphere(p, sps);\n    float box = sdBox(p, bs);\n    \n    float mixval = clamp(sin(iTime*0.3)+0.5,0.0,1.0);\n    \n    return mix(sp, box, mixval);\n}\n\nvec3 morphNorm(vec3 p, vec3 bs, float sps) {\n    vec2 e = vec2(0.001,0);\n    float v = morphShape(p, bs, sps);\n    \n    return normalize(v-vec3(morphShape(p+e.xyy, bs, sps),\n                            morphShape(p+e.yxy, bs, sps),\n                            morphShape(p+e.yyx, bs, sps)));\n}\n\nvec2 map(vec3 p) {\n    \n    float val;\n    int id;\n    \n    vec3 p1 = rotBy(p,iTime*0.3,1);\n    vec3 spn;\n    float sp = morphShape(p1, vec3(0.4), 0.4);\n    //bump mapping\n    spn = morphNorm(p1, vec3(0.4), 0.4);\n    //bumo mapping\n    spn = spn;\n    float bump = texture(SAMP,p1.yz+0.5).x*spn.x+\n                 texture(SAMP,p1.xz+0.5).x*spn.y+\n                 texture(SAMP,p1.xy+0.5).x*spn.z;\n    sp += bump*BUMP_DEPTH;\n    \n    val = sp;\n    if(val==sp) id = MAT_BALL;\n    \n    return vec2(val, id);\n}\n\nvec3 getNorm(vec3 p, inout float edge) {\n    vec2 e = vec2(0.001,0);\n    \n    float d = map(p).x*2.0;\n    float x1=map(p+e.xyy).x,x2=map(p-e.xyy).x,\n          y1=map(p+e.yxy).x,y2=map(p-e.yxy).x,\n          z1=map(p+e.yyx).x,z2=map(p-e.yyx).x;\n    \n    edge = abs(x1 + x2 - d) + abs(y1 + y2 - d) + abs(z1 + z2 - d);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    return normalize(vec3(x1-x2,y1-y2,z1-z2));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    \n    float t=0.0;\n    vec2 d;\n    int i;\n    for (i=0;i<MAX_ITERATIONS;i++) {\n        \n        vec3 p = ro+rd*t;\n        d = map(p);\n        t+=d.x;\n        \n        if(d.x<MIN_D || t>MAX_D) break;\n        }\n    return vec3(t,d.y,float(i));\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd) {\n    vec3 col = vec3(0);\n    vec3 ty = march(ro, rd);\n    float t = ty.x;\n    int mat = int(ty.y);\n    \n    vec3 lo = vec3(-1,5,-10);\n    \n    vec3 p = ro+rd*t;\n    vec3 col1;\n    if(t<MAX_D) {\n        float edge;\n        vec3 n = getNorm(p, edge);\n        vec3 ld = normalize(p-lo);\n        \n        //phong\n        //diffuse\n        float dif = dot(-ld,n);\n        //specular\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,dot(-ld,r)),32.0);\n        //ambient\n        float ambient = 0.01;\n        col += dif + ambient + spec;\n        vec3 p1 = rotBy(p,iTime*0.3,1);\n        n=abs(n);\n        if(mat==MAT_BALL) col*= texture(SAMP,p1.yz+0.5).xyz*n.x+\n                                texture(SAMP,p1.xz+0.5).xyz*n.y+\n                                texture(SAMP,p1.xy+0.5).xyz*n.z;\n        \n                \n    } else col = vec3(0.6,0.9,1)*0.8;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*RES)/RES.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = RO;\n    vec3 la = vec3(0);\n    vec3 rd = getCam(uv, ro, la, 4.0);\n    \n    vec3 lo = vec3(0,0,1);\n    \n    col = render(ro,rd);\n    \n    col = pow(col,vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define RES iResolution.xy\n#define max_n int(80);\n#define min_d 0.001;\n#define max_d 50.;\n\nvec2 map(vec3 p);\n\nmat2 rot(float t) {\n    float c=cos(t),s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec3 rotBy(vec3 p, float angle, int axis) {\n    if(axis==0) {\n        p.yz *= rot(angle);}\n    if(axis==1) {\n        p.xz *= rot(angle);}\n    if(axis==2) {\n        p.xy *= rot(angle);}\n    \n    return p;\n}\n\nfloat _smin(float a,float b,float k) {\n    float d = a-b;\n    return a+b - sqrt(d*d+k*k);\n}\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nfloat _smax(float a,float b,float k) {\n    float d = a-b;\n    return a+b + sqrt(d*d+k*k);\n}\n\nfloat smax( float a, float b, float k )\n{\n    k *= -1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\nvec3 getCam(vec2 uv, vec3 ro, vec3 la, float z) {\n    vec3 f = normalize(la-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 u = cross(f,r);\n    \n    return normalize(r*uv.x + u*uv.y + f*z);\n}\n\nfloat sdPlane(vec3 p, float h) {\n    return dot(vec3(0,1,0),p) + h;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    //vec2 e = vec2(0.001,0);\n    float v = length(p)-s;\n    //n = normalize(v-vec3(length(p+e.xyy)-s,length(p+e.yxy)-s,length(p+e.yyx)-s));\n    \n    return v;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 getTexture(vec3 p, vec3 n, sampler2D ch) {\n    return texture(ch, p.yz)*n.x+\n           texture(ch, p.xz)*n.y+\n           texture(ch, p.xy)*n.z;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash21(vec2 p) {\n    vec3 v = fract(p.xyx*vec3(67.431, 32.237, 90.012));\n    v += dot(v,v+33.33);\n    return fract((v.x+v.y)*v.z);\n}\n\nfloat valNoi(vec2 p) {\n    vec2 i = floor(p);\n    vec2 g = fract(p);\n    g= g*g*(3.0-2.0*g);\n    \n    return mix(\n        mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),g.x),\n        mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),g.x),\n        g.y\n    );\n}\n\nfloat fbm(vec2 p, int oct) {\n    float amp=0.5, f=10.0, v=.0;\n    //int oct = 10;\n    \n    for (int i=0;i<oct;i++) {\n        v+= amp*valNoi(p*f+float(i));\n        p*=rot(1.0);\n        f*=2.0;\n        amp*=0.5;\n    }\n    return v;\n    \n}\n\nfloat metal(vec2 uv) {\n    uv.x+= fbm(uv,7)+3.0;\n    return fbm(uv, 10);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    uv.x+= fbm(uv,7)+3.0;\n    float val = fbm(uv, 10);\n    \n    col+= vec3(metal(uv),metal(uv*rot(1.0)+0.1),metal(uv*rot(2.0)+0.2));\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}