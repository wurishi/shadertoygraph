{"ver":"0.1","info":{"id":"cdcXz2","date":"1680545368","viewed":147,"name":"My Simple Pathtracer","username":"gueni","description":"simple path tracing","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n#if 1    \n    float gamma = 2.2;\n    color = pow(color, vec3(1.0 / gamma));\n#endif    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUM_SPHERES 12\n#define NUM_BOUNCES 8\n#define NUM_SAMPLES 8\n\n\nconst float PI = 3.14159265359; \nconst float TWO_PI = 2.0 * PI;\nconst float INFINITY = 1.0 / 0.0;\n\nconst float DIFFUSE = 0.;\nconst float REFLECT = 1.;\nconst uint REFRACT = 2U;\n\nuint rng; // random number generator state\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere  {\n    float radius;\n    vec3 center;\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n};\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat random_float_01()\n{\n    return float(wang_hash(rng)) / float(0xFFFFFFFFU);\n}\n \nvec3 random_unit_vector()\n{\n    float z = random_float_01() * 2.0 - 1.0;\n    float a = random_float_01() * TWO_PI;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 random_in_hemisphere(vec3 n)\n{\n    vec3 v = random_unit_vector();\n    return (dot(v,n) > 0.0) ? v : -v;\n}    \n\nvec3 visualize_normal(in vec3 normal)\n{\n  return (vec3(1.0) + normal * vec3(1, -1, -1)) * 0.5;\n}\n\nbool ray_sphere_intersect_v1(in Ray r, in Sphere s, out float t)\n{\n  vec3 m = r.origin - s.center;\n  float b = dot(m, r.direction);\n  float c = dot(m, m) - s.radius * s.radius;\n\n  if (c > 0.0 && b > 0.0)\n    return false;\n\n  float discr = b * b - c;\n\n  if (discr < 0.0f)\n    return false;\n\n  t = -b - sqrt(discr);\n\n  if (t < 0.0)\n  {  \n    t = 0.0;\n  }\n  \n  return true;\n}\n\nvec3 render(in Ray ray, in Sphere[NUM_SPHERES] spheres)\n{\n    vec3 color      = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    \n    for (int b = 0; b < NUM_BOUNCES; b++) {\n    \n        int i = -1;\n        float t = INFINITY, c = INFINITY;\n\n        for (int s = 0; s < NUM_SPHERES; s++) {\n            if (ray_sphere_intersect_v1(ray, spheres[s], t) && (0.0 < t && t < c)){        \n                i = s, c = t;\n            }\n        }\n        \n        if (i != -1) {\n            vec3 point  = ray.origin + ray.direction * c;\n            vec3 normal = normalize(point - spheres[i].center);\n\n#if 0\n            color = visualize_normal(normal);\n#else    \n            float nudge = 0.01;\n            ray.origin    = point + normal * nudge;\n            \n            float cos_theta = 1.0;\n            \n            vec3 reflected = reflect(ray.direction, normal);\n            vec3 diffuse = random_in_hemisphere(normal);\n            \n            ray.direction = mix(diffuse, reflected, pow(spheres[i].roughness, 2.));\n            \n#if 0                            \n            if (spheres[i].type == REFLECT){\n                ray.direction = reflect(ray.direction, normal);\n            } else {\n                //cos_theta = -dot(normal, ray.direction) * 2.;\n                ray.direction = normalize(normal + random_unit_vector());\n                ray.direction = random_in_hemisphere(normal);\n            }\n#endif     \n            \n            color      += (spheres[i].emissive * throughput);\n            throughput *= (spheres[i].albedo);  \n#endif\n        } else {\n            break; \n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    rng = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) \n        * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n        \n    \n    vec2 jitter = vec2(random_float_01(), random_float_01());\n    jitter *= 0.001;\n    \n    uv += jitter;\n\n    \n    vec3 red   = vec3(0.7,0.1,0.1);\n    vec3 grey  = vec3(0.7f, 0.7f, 0.7f);\n    vec3 green = vec3(0.1,0.7,0.1);\n    vec3 black = vec3(0,0,0);\n    vec3 white = vec3(1,1,1);\n    vec3 light = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n    vec3 s0    = vec3(0.75f, 0.9f, 0.9f);\n    vec3 s1    = vec3(0.9f, 0.75f, 0.9f);\n    vec3 s2    = vec3(0.9f, 0.9f, 0.75f);\n    vec3 light2 = s2 * 10.0;\n    vec3 light3 = grey * 2.;\n\n    float r = 5000.0;\n    float rh = 2.;\n    float rs = 0.7;\n    float h = r + rh;\n    float w = r + 2.8;\n    Sphere spheres[NUM_SPHERES];\n    \n    int i = 0;\n    \n    // light\n    spheres[i++] = Sphere(0.8, vec3(+0.0, 2.4, 5), s2,  light2, DIFFUSE);\n    \n    // spheres\n    spheres[i++] = Sphere(rs, vec3(-1.5, -rh + rs, 5), s0,  black, 0.5);\n    spheres[i++] = Sphere(0.5, vec3(+0.0, -1.5, 4.3), s2,  black, .3);\n    spheres[i++] = Sphere(rs, vec3(+1.5, -rh + rs, 5), s1,  black, 1.); \n    spheres[i++] = Sphere(0.6, vec3(-.5, 0, 5), s1,  black, .7); \n    spheres[i++] = Sphere(0.4, vec3(1.3, .5, 5), s1,  black, 0.); \n    \n    // walls\n    spheres[i++] = Sphere(r, vec3(0,0,h+4.0), grey,  black, DIFFUSE); // back\n    spheres[i++] = Sphere(r, vec3(0,-h,0),    grey,  black, DIFFUSE); // bottom\n    spheres[i++] = Sphere(r, vec3(0,+h,0),    grey,  black, DIFFUSE); // top\n    spheres[i++] = Sphere(r, vec3(-w,0,0),    red,   black, DIFFUSE); // left\n    spheres[i++] = Sphere(r, vec3(+w,0,0),    green, black, DIFFUSE); // right\n    \n    Ray ray = Ray(vec3(0.0), normalize(vec3(uv.x, uv.y, 1.0)));  \n\n    vec3 color;\n    \n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        color += render(ray, spheres);\n    }\n    \n    color /= float(NUM_SAMPLES);\n    \n    vec3 last_frame_color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color = mix(last_frame_color, color, 1.0 / float(iFrame + 1));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}