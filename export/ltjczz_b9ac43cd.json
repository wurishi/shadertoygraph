{"ver":"0.1","info":{"id":"ltjczz","date":"1609544829","viewed":361,"name":"no fork zone 3 branch","username":"ollj","description":"fork of https://www.shadertoy.com/view/ltfyR2\n2017-10-06","likes":17,"published":1,"flags":48,"usePreview":1,"tags":["3d","raymarch","raycast","cloud","sky","shadows","raytrace","plane","lightning","airplane","bomb","miliatry","airforce","missile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.shadertoy.com/view/ltfyR2\n//no fly zone 3\n//image\n//buffB keynose, buffC\n\n\n//main buffer flow is B A C image\n\n// POST EFFECTS BUFFER\n\n//////////////////////////////////////////////////////////////////////////////////////\n///////////////////// CREATED BY KIM BERKEBY, SEP 2017 ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////// Feel free to mail me at mr.kimb@hotmail.com /////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)/iResolution.xy, 0.0).r)\n  #define CAMZOOM  13.9\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define read(memPos) (  textureLod(iChannel0, (memPos+0.5)/iResolution.xy, 0.0).a)\n  #define readRGB(memPos) (  textureLod(iChannel0, (memPos+0.5)/iResolution.xy, 0.0).rgb)\n  #define STARTHEIGHT 10.\n#define PI acos(-1.)\nmat3 cameraMatrix;\n\nvec3 sunPos;\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );  \n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n    return vec2(PI*dot( pos, cameraMatrix[0].xyz ),PI* dot( pos,  cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha)\n{\n    \n    float visibility = clamp( dot(sunPos, rayDir), 0.0, 1.0 );  \n    vec2 sunScreenPos = GetScreenPos(sunPos);\n    \n    // check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n    float sunTest = readAlpha( sunScreenPos/2.0 +0.5);\n    \n    vec2 uvT = screenSpace-sunScreenPos;\n    float sunIntensity = (1.0/(pow(length(uvT)*4.0+1.0,1.30)))*visibility;\n\n    vec3 flareColor;\n    vec2 offSet;;\n    vec3 color;\n    // only draw if now covered by any object\n    if(sunTest<0.50)\n    {\n    // create flare rings\n    for(float i =1.; i<8.; i++)\n    {\n       color.rg = vec2(0.75+(0.25*sin(i*i)));\n       color.b = 0.75+(0.25*cos(i*i));\n       offSet = mix (uvT, uvT+sunScreenPos, 0.67*i);\n       flareColor += sunIntensity *4.25 * color * pow(max(1.0-(length(offSet)/(1.0+(i*0.2)))*4.60, 0.0),3.0);    \n    }\n    }\n\t// flare star shape\n\tvec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*5.+atan(uvT.x,uvT.y)*10.)*4.0)*.2+3.5*sunIntensity);\n\t// sun glow\n\tsunSpot+=vec3(visibility,visibility*0.76,visibility*0.20)*pow(visibility,6.0)*0.35;\n\n    return flareColor+(sunSpot*(1.0-alpha));\n}\n\n\nvoid pR(inout vec2 p, float a) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  // read values from buffer\n  float turn = mix(0.4, read(vec2(1.0, 10.0)), step(1.0, float(iFrame)));\n  float roll = mix(3.14, read(vec2(1.0, 1.0)), step(1.0, float(iFrame)));\n  float speed = read(vec2(10.0, 1.0));\n  float pitch = read(vec2(15.0, 1.0));\n  sunPos = readRGB(vec2(50.0, 50.0));\n\n  // setup camera and ray direction\n  vec2 camrot = vec2(1.9, 0.25);\n  camrot.x+=mo.x*16.; \n  camrot.y+=mo.y*16.; \n    \n    \n   vec3 rayOrigin = vec3(CAMZOOM*cos(camrot.x), 3.+CAMZOOM*sin(camrot.y), -3.+CAMZOOM*sin(camrot.x) );\n  pR(rayOrigin.xz, -turn);\n cameraMatrix  = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n    \n\n  vec4 color = texture(iChannel2, uv);\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin,screenSpace, color.a);\n\n\n     // fragColor = vec4(mix(colorOld.rgb, color.rgb, mix(1.0, MAXBLUR, smoothstep(0.3, 1., speed))), fragColor.a);\n  fragColor =  vec4(pow(color.rgb, vec3(1.0/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/ltfyR2\n//no fly zone 3\n//image\n//(noise) keyboard, buffb, bark\n\n// TERRAIN BUFFER\n\n//////////////////////////////////////////////////////////////////////////////////////\n///////////////////// CREATED BY KIM BERKEBY, SEP 2017 ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////// Feel free to mail me at mr.kimb@hotmail.com /////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n\n  // SET TO 1.0 TO DISABLE BLUR\n  #define MAXBLUR 0.35    \n  // remove shadow and quality tree define if FPS is too low\n  #define SHADOWS\n  #define QUALITY_TREE\n\n  #define CAMZOOM  13.9\n  #define keyClick(ascii)   ( texelFetch(iChannel1, ivec2(ascii, 0), 0).x > 0.)\n  #define read(memPos) (  textureLod(iChannel2, (memPos+0.5)/iResolution.xy, 0.0).a)\n  #define readRGB(memPos) (textureLod(iChannel2, (memPos+0.5)/iResolution.xy, 0.0).rgb)\n  #define MAX_HEIGHT 80. \n  #define MIN_HEIGHT -12. \n  #define STARTHEIGHT 10.\n  #define WATER_LOD 1.\n  #define TERRAINLEVEL 28.\n  #define CLOUDLEVEL -32.0\n\nvec3 sunPos;\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nvec3 planePos;\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n};\n\nstruct Missile\n{ \n  vec3 pos;\n  vec3 startPos;\n  float life;\n  float roll;\n  float pitch;\n};\n\nMissile missile01;    \n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec3 p) \n{\n  float f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\n\nfloat noise2D( in vec2 pos, float lod)\n{\n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel0, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)/256.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\nvec3 calcWaterNormal( vec2 pos, float res )\n{   \n  return normalize(vec3(noise2D((pos + vec2(-0.001, 0))* res, WATER_LOD)-noise2D((pos + vec2(+0.001, 0))* res, WATER_LOD), noise2D((pos + vec2(0, -0.001))*res, WATER_LOD)-noise2D((pos + vec2(0, +0.001))* res, WATER_LOD), .005)) * 0.5 + 0.5;\n}\n\nfloat GetCloudHeight(vec3 p)\n{    \n  vec2 p2 = (p.xz+planePos.xz)*0.04;\n\n  float i  = 0.3+noise2D(p2)*1.4; \n  p2*=2.02;\n  i += noise2D( p2 )*0.6; \n  p2*=2.03;\n  i += noise2D( p2 )*0.25; \n  p2*=2.51;\n  i += noise2D(p2 )*0.12;\n  p2*=3.12;\n  i += noise2D( p2)*0.04;\n  return clamp(i, -2.0, 8.)*3.50;\n}\n\n\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz+planePos.xz)*0.0005;\n\n  float mainHeight = -1.3+abs(fbm((p+vec3(planePos.x,0.,planePos.z))*0.01))*16.; \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n\n  return   terrainHeight;\n}\n\n\nfloat MapTerrain( vec3 p)\n{\n  float terrainHeight = GetTerrainHeight(p);   \n  terrainHeight= mix(terrainHeight+(textureLod(iChannel3, (p.xz+planePos.xz)*0.02, 1.6).x*0.4), terrainHeight, smoothstep(0.4, 1.3, terrainHeight));\n\n  float tree = mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, textureLod(iChannel3, (p.xz+planePos.xz)*0.02, 1.0).x)), smoothstep(1.5, 3.5, terrainHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return   p.y+TERRAINLEVEL - (terrainHeight+tree);\n}\n\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<16; i++ )\n  {\n    h = MapTerrain(origin+direction*t);\n    res = min( res, 3.5*h/t );\n    t += clamp( h, 0.02, 0.8);\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapTerrain(pos+eps.xyy) - MapTerrain(pos-eps.xyy), 0.5*2.0*eps.x, MapTerrain(pos+eps.yyx) - MapTerrain(pos-eps.yyx) ) );\n}\n\nfloat MapCloud( vec3 p)\n{\n  return CLOUDLEVEL + p.y - GetCloudHeight(p);\n}\n\nfloat MapCloudBelow( vec3 p)\n{\n  return CLOUDLEVEL + p.y - -GetCloudHeight(p);\n}\n\nfloat GetTreeHeight( vec3 p, float terrainHeight)\n{\n  float tree = mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, textureLod(iChannel3, (p.xz+planePos.xz)*0.02, 1.0).x)), smoothstep(1.5, 3.5, terrainHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return  tree;\n}\n\nfloat MapTree( vec3 p)\n{  \n  float terrainHeight = GetTerrainHeight(p);\n  float treeHeight =GetTreeHeight(p, terrainHeight);\n\n  // get terrain height at position and tree height onto that\n  return  p.y + TERRAINLEVEL - terrainHeight-treeHeight;\n}\n\nvec4 MarchTrees( vec3 origin, vec3 direction, int steps)\n{\n  vec4 treeCol =vec4(0.5, 0.5, 0.5, 0.0);\n  float intensity=0.0, t = .0, dist = 0.0;\n  vec3 rayPos, nn;\n  float precis=.0, dif =0.0, densAdd =.0;\n  float treeHeight = 0.0, terrainHeight =0.0;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    terrainHeight = GetTerrainHeight(rayPos);\n    treeHeight = GetTreeHeight(rayPos, terrainHeight);\n    dist = rayPos.y + TERRAINLEVEL - (terrainHeight + treeHeight);  \n    precis = 0.001;\n\n    if (treeHeight>0.1 && dist<precis)\n    {\n      nn= calcNormal(rayPos);  \n      dif = clamp( dot( nn, sunPos ), 0.0, 1.0 );\n      densAdd = ((precis-dist)*treeHeight+(0.001*t));\n\n      treeCol.rgb+=0.03*(0.1*t);\n      treeCol.a+=(1.-treeCol.a)*densAdd;\n    } \n    if (treeCol.a > 0.99) \n    {\n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return clamp(treeCol, 0., 1.);\n}\n\nvec4 MarchClouds( vec3 origin, vec3 direction, int steps)\n{\n  vec4 cloudCol =vec4(0.7, 0.7, 0.7, 0.0);\n  float height = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    height = GetCloudHeight(rayPos);\n    dist = CLOUDLEVEL + rayPos.y - height;      \n    precis = 0.01*t;\n    if (dist<precis)\n    {     \n      cloudCol.rgb+=MapCloud(rayPos+0.25*sunPos)*0.02;\n\n      float densAdd = mix(0., (precis-dist)*0.15, smoothstep(-1., 1.7, height));\n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    t += dist*0.33;\n  }\n  return clamp(cloudCol, 0., 1.);\n}\n\n\nvec4 MarchCloudsBelow( vec3 origin, vec3 direction, int steps)\n{\n  vec4 cloudCol =vec4(0.9, 0.9, 0.9, 0.0);\n  float height = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    height = GetCloudHeight(rayPos)*0.43;\n    dist = abs(CLOUDLEVEL + rayPos.y + height);      \n\n    precis = 0.007*t;\n    if (height>0.01 && dist<precis)\n    {     \n      cloudCol.rgb+=MapCloudBelow(rayPos+0.26*sunPos)*0.0005;\n\n      float densAdd = mix(0., (precis-dist)*0.04, smoothstep(0., 2., height));\n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    t += dist*0.35;\n  }\n  return clamp(cloudCol, 0., 1.);\n}\n\n\nRayHit MarchTerrain( vec3 origin, vec3 direction, int steps)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 350.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrain( rayPos);\n    precis = 0.001*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\n// set sky color tone. 2 gradient passes using MIX.\nvec3 GetSkyColor(vec3 rayDir)\n{ \n    /*\n    rayDir.y+=0.1;\n    vec3  skyColor = vec3(0.2, 0.2, 0.3);\n    skyColor = mix(vec3(0.16, 0.47, 0.75),skyColor,smoothstep(0.0, 0.8, rayDir.y));\n   skyColor = mix(vec3(0.8,.8,0.84),skyColor,smoothstep(0., 0.35, rayDir.y));\n   skyColor = mix(vec3(1.),skyColor,smoothstep(-0.06, 0.14, rayDir.y));  \n   skyColor = mix(vec3(0.87,.92,1.),skyColor,smoothstep(-0.16, 0.0, rayDir.y));  \n    return skyColor;\n*/\n         return mix(mix(vec3(0.04, 0.1, 0.2), vec3(0.16, 0.36, 0.55)*1.2, smoothstep(1.0, .30, rayDir.y)), vec3(0.99), smoothstep(0.3, -0.13, rayDir.y)); \n\n }\n\n// scene lightning\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  #ifdef SHADOWS\n    vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.99); \n  dif *= SoftShadow(shadowPos, sunPos);\n  #endif\n\n    vec3 lightTot = vec3(0.0);\n  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);\n  lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n  lightTot += 0.45*amb*vec3(0.6,0.6, .80);\n\n  return lightTot;\n}\n\nvoid pR(inout vec2 p, float a) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n // vec4 colorOld =  texture(iChannel2, uv);\n\n  // read values from buffer\n\n  float turn = mix(0.4, read(vec2(1.0, 10.0)), step(1.0, float(iFrame)));\n  float roll = mix(3.14, read(vec2(1.0, 1.0)), step(1.0, float(iFrame)));\n  float speed = read(vec2(10.0, 1.0));\n  float pitch = read(vec2(15.0, 1.0));\n  sunPos = mix(normalize(vec3(2.3, 1.7, -1.)), readRGB(vec2(50.0, 50.0)), step(1.0, float(iFrame)));\n  planePos = mix(vec3(-400,STARTHEIGHT,-100), readRGB(vec2(55, 50.0)), step(1.0, float(iFrame)));\n   \n  roll=mod(roll, 6.28);\n\n  float turnAmount = mix(0., 1.57, smoothstep(0., 1.57, 1.57-distance(1.57, roll-3.14)));\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n\n  turn+=turnAmount*0.0175;\n  planePos.xz += vec2(cos(turn+1.5707963)*0.5,  sin(turn+1.5707963)*0.5)*(0.7+speed);\n    planePos.y = clamp(planePos.y+(pitch*0.25), MIN_HEIGHT, MAX_HEIGHT);\n    \n\n  // setup camera and ray direction\n  vec2 camrot = vec2(1.9, 0.25);\n  camrot.x+=mo.x*16.; \n  camrot.y+=mo.y*16.; \n \n  vec3 rayOrigin = vec3(CAMZOOM*cos(camrot.x), 3.+planePos.y+CAMZOOM*sin(camrot.y), -3.+CAMZOOM*sin(camrot.x) );\n  pR(rayOrigin.xz, -turn);\n  mat3 ca = setCamera( rayOrigin, vec3(0., planePos.y, -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n\n  // create sky color fade\n  vec3 skyColor = GetSkyColor(rayDir);\n  vec3 color = skyColor;\n     float alpha=0.;\n\n    if(rayDir.y<0.)\n      {\n  RayHit marchResult = MarchTerrain(rayOrigin, rayDir, 250);\n\n     \n  if (marchResult.hit)\n  { \n      alpha=1.0;\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n\n    float specLevel=0.7;\n    color=vec3(0.3, 0.2, .0);\n\n    // create terrain texture\n    vec3 colorRocks= mix(texture(iChannel3, (marchResult.hitPos.xz+planePos.xz)*.007).rgb, vec3(0.6), 0.5);\n    color =colorRocks;\n\n    // grass\n    color.rgb = mix(color.rgb, ((color+noise2D((marchResult.hitPos.xz+planePos.xz)*12., 1.0))+vec3(0.5, 0.5, .0))*0.3, smoothstep(-TERRAINLEVEL+0.2, -TERRAINLEVEL+2.0, marchResult.hitPos.y)); \n\n      if(marchResult.hitPos.y<=-TERRAINLEVEL+0.25)\n      {\n    // add ripples to water\n    vec3 waterNormal = (calcWaterNormal(marchResult.hitPos.xz+planePos.xz + vec2(-iTime*0.4, -iTime*0.2), 2.66));\n    waterNormal = (normalize(mix(waterNormal,(calcWaterNormal(marchResult.hitPos.xz+planePos.xz + vec2(iTime*0.4, iTime*0.2), 5.61)),0.5))+vec3(0.,1.0,0.))*0.4;    \n       marchResult.normal = mix(waterNormal, marchResult.normal, smoothstep(-TERRAINLEVEL-0.1, -TERRAINLEVEL+0.25, marchResult.hitPos.y));\n\n    //vec3 waterNormal = ((calcWaterNormal(marchResult.hitPos.xz+planePos.xz + vec2(-iTime*0.4, -iTime*0.2), 2.66))*(calcWaterNormal(marchResult.hitPos.xz+planePos.xz + vec2(iTime*0.4, iTime*0.2), 5.61)));      \n   // marchResult.normal = mix((vec3(0.0, 1.0, 0.0)+waterNormal)*0.4, marchResult.normal, smoothstep(-TERRAINLEVEL+0.2, -TERRAINLEVEL+0.5, marchResult.hitPos.y));\n\n          \n    // water color\n color.rgb  = mix(skyColor, color.rgb, smoothstep(-TERRAINLEVEL-0.7, -TERRAINLEVEL+0.3, marchResult.hitPos.y));\n    color.rgb  = mix(skyColor*0.65, color.rgb, smoothstep(-TERRAINLEVEL-1.39, -TERRAINLEVEL+0.4, marchResult.hitPos.y));\n     specLevel = 22.0;\n      }\n      \n    // get lightning based on material\n    vec3 light = GetSceneLight(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n\n    // apply lightning\n    color = color*light;\n\n    #ifdef QUALITY_TREE\n      // add trees\n      vec4 treeColor = MarchTrees(rayOrigin, rayDir, 32);      \n    color =clamp( mix( color, treeColor.rgb*((noise2D((marchResult.hitPos.xz+planePos.xz)*36., 2.0)+vec3(0.5, 0.5, .0))*0.5), treeColor.a ), 0.1, 1.); \n    #endif\n\n\n      color = mix(color, vec3(0.3, 0.5, 0.7), mix(0.1, 0.45, smoothstep(MIN_HEIGHT, MAX_HEIGHT, planePos.y)));  \n\n    // add fog\n    color = mix(color, skyColor, smoothstep(150., 1250., (marchResult.depth*marchResult.depth)*0.01));\n  }\n      }\n  // add volumetric clouds \n  vec4 cloudColor;\n  if (rayOrigin.y>=-CLOUDLEVEL)\n  {   \n      if(rayDir.y<0.)\n      {\n    cloudColor= MarchClouds(rayOrigin, rayDir, 70);\n      }\n  }\n    else\n  {\n      if(rayDir.y>0.)\n      {\n    cloudColor=MarchCloudsBelow(rayOrigin, rayDir, 70);\n      }\n  }\n\n  // mix clouds color with scene color\n  color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);\n\n    alpha+=cloudColor.a;\n  pitch*=0.97;\n\n \n // fragColor = vec4(mix(colorOld.rgb, color.rgb, mix(1.0, MAXBLUR, smoothstep(0.3, 1., speed))), fragColor.a);\n    fragColor = vec4(color.rgb, min(1.0,alpha));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/ltfyR2\n//no fly zone 3\n//image\n//(buffa) keyboard, buffb\n\n// DATA BUFFER\n\n//////////////////////////////////////////////////////////////////////////////////////\n///////////////////// CREATED BY KIM BERKEBY, SEP 2017 ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////// Feel free to mail me at mr.kimb@hotmail.com /////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n\n  // SET TO 1.0 TO DISABLE BLUR\n  #define MAXBLUR 0.35    \n  // remove shadow and quality tree define if FPS is too low\n  #define SHADOWS\n  #define QUALITY_TREE\n\n  #define CAMZOOM  13.9\n  #define keyClick(ascii)   ( texelFetch(iChannel1, ivec2(ascii, 0), 0).x > 0.)\n  #define read(memPos) (  textureLod(iChannel2, (memPos+0.5)/iResolution.xy, 0.0).a)\n  #define readRGB(memPos) (  textureLod(iChannel2, (memPos+0.5)/iResolution.xy, 0.0).rgb)\n  #define MAX_HEIGHT 80. \n  #define MIN_HEIGHT -12. \n  #define STARTHEIGHT 10.\n  #define WATER_LOD 1.\n  #define TERRAINLEVEL 28.\n  #define CLOUDLEVEL -32.0\n\nvec3 sunPos;\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nvec3 planePos;\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n};\n\nstruct Missile\n{ \n  vec3 pos;\n  vec3 startPos;\n  float life;\n  float roll;\n  float pitch;\n};\n\nMissile missile01;    \n\n\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\nvoid pR(inout vec2 p, float a) {\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n // vec4 colorOld =  texture(iChannel2, uv);\n\n  // read values from buffer\n  float turn = mix(0.4, read(vec2(1.0, 10.0)), step(1.0, float(iFrame)));\n  float roll = mix(3.14, read(vec2(1.0, 1.0)), step(1.0, float(iFrame)));\n  float speed = read(vec2(10.0, 1.0));\n  float pitch = read(vec2(15.0, 1.0));\n  sunPos = mix(normalize(vec3(2.3, 1.7, -1.)), readRGB(vec2(50.0, 50.0)), step(1.0, float(iFrame)));\n  planePos = mix(vec3(-400,STARTHEIGHT,-100), readRGB(vec2(55, 50.0)), step(1.0, float(iFrame)));\n    \n    \n  roll=mod(roll, 6.28);\n  float turnAmount = mix(0., 1.57, smoothstep(0., 1.57, 1.57-distance(1.57, roll-3.14)));\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n\n  turn+=turnAmount*0.0175;\n  planePos.xz += vec2(cos(turn+1.5707963)*0.5,  sin(turn+1.5707963)*0.5)*(0.7+speed);\n  planePos.y = clamp(planePos.y+(pitch*0.25), MIN_HEIGHT, MAX_HEIGHT);\n    \n\n  // setup camera and ray direction\n  vec2 camrot = vec2(1.9, 0.25);\n  camrot.x+=mo.x*16.; \n  camrot.y+=mo.y*16.; \n \n  vec3 rayOrigin = vec3(CAMZOOM*cos(camrot.x), 3.+planePos.y+CAMZOOM*sin(camrot.y), -3.+CAMZOOM*sin(camrot.x) );\n  pR(rayOrigin.xz, -turn);\n  mat3 ca = setCamera( rayOrigin, vec3(0., planePos.y, -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\nvec3 color= vec3(0.);\n  pitch*=0.97;\n\n  // check key inputs. S and F controls roll. E and D controls speed.\n  roll-=0.03*float(keyClick(83)); //s-key\n  roll+=0.03*float(keyClick(70)); //f-key\n  speed=clamp(speed+(0.02*float(keyClick(82))), -0.3, 1.); //r-key\n  speed=clamp(speed-(0.02*float(keyClick(87))), -0.3, 1.); //w-key\n  pitch=clamp(pitch-(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, MIN_HEIGHT))))*float(keyClick(69))), -0.5, 0.5); //e-key\n  pitch=clamp(pitch+(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, MAX_HEIGHT))))*float(keyClick(68))), -0.5, 0.5); //d-key\n\n\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n\n  fragColor.a=0.;\n  // save roll,speed and scroll values to buffer A \n  fragColor.a = mix(turn, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 10.0)))); \n  fragColor.a = mix(speed, fragColor.a, step(1., distance(fragCoord.xy, vec2(10.0, 1.0)))); \n  fragColor.a = mix(roll, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 1.0)))); \n  fragColor.a = mix(pitch, fragColor.a, step(1., distance(fragCoord.xy, vec2(15.0, 1.0)))); \n  color.rgb = mix(sunPos, color.rgb, step(1., distance(fragCoord.xy, vec2(50.0, 50.0))));\n  color.rgb = mix(planePos, color.rgb, step(1., distance(fragCoord.xy, vec2(55.0, 50.0))));\n\n/*\n  // missile \n  // load save variables for missile\n  missile01.life = read(vec2(100.0, 100.0));\n  missile01.roll = read(vec2(108.0, 100.0));\n  missile01.pitch = read(vec2(110.0, 100.0));\n\n  // if missile is \"dead\" check if a new missile is being lanched by pressing the key\n  if ( missile01.life<=0.)\n  {\n\n    if (keyClick(77))\n    {\n      missile01.life=3.0; //m-key\n      missile01.roll = roll;\n      missile01.pitch =pitch;\n    }\n  }\n\n  // update active missile and save variables\n  if ( missile01.life>0.)\n  {\n    missile01.life-= iTimeDelta;\n\n    fragColor.a = mix(missile01.life, fragColor.a, step(1., distance(fragCoord.xy, vec2(100.0, 100.0))));\n    fragColor.a = mix(missile01.roll, fragColor.a, step(1., distance(fragCoord.xy, vec2(108.0, 100.0))));\n    fragColor.a = mix(missile01.pitch, fragColor.a, step(1., distance(fragCoord.xy, vec2(110.0, 100.0))));\n  }\n  */ \n  fragColor = vec4(color.rgb,fragColor.a);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/ltfyR2\n//no fly zone 3\n//image\n//buffa noise, buffb\n\n// BUFFER JetBombInterceptor\n\n#define doJetBombInterceptor\n\n#ifdef doJetBombInterceptor\n\n//////////////////////////////////////////////////////////////////////////////////////\n///////////////////// CREATED BY KIM BERKEBY, SEP 2017 ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////// Feel free to mail me at mr.kimb@hotmail.com /////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n\n#define PI acos(-1.)\n  #define read(memPos) (  textureLod(iChannel2, (memPos+0.5)/iResolution.xy, 0.0).a)\n  #define readRGB(memPos) (  textureLod(iChannel2, (memPos+0.5)/iResolution.xy, 0.0).rgb)\n  #define RAYSTEPS 300\n  #define CAMZOOM  13.9\n  #define STARTHEIGHT 10.\n\n  float pitch = 0.;\nfloat roll=0.;\nfloat speed = 0.5;\nvec3 checkPos;\nvec3 sunPos;\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nfloat winDist=10000.0;\nfloat engineDist=10000.0;\nfloat eFlameDist=10000.0;\nfloat blackDist=10000.0;\nfloat bombDist=10000.0;\nfloat bombDist2=10000.0;\nfloat missileDist=10000.0;\nfloat frontWingDist=10000.0;\nfloat rearWingDist=10000.0;\nfloat topWingDist=10000.0;\n\nfloat sgn(float x) {   \n  return (x<0.)?-1.:1.;\n}\n\nstruct Missile\n{ \n  vec3 pos;\n  vec3 startPos;\n  float life;\n  float roll;\n  float pitch;\n};\n\nMissile missile01;   \n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n\n  float winDist;\n  float engineDist;\n  float eFlameDist;\n  float blackDist;\n  float bombDist;\n  float bombDist2;\n  float missileDist;\n  float frontWingDist;\n  float rearWingDist;\n  float topWingDist;\n};\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float a = textureLod( iChannel1, x.xy/256.0 + (p.z+0.0)*120.7123, 0.2 ).x;\n    float b = textureLod( iChannel1, x.xy/256.0 + (p.z+1.0)*120.7123, 0.2 ).x;\n\treturn mix( a, b, f.z );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p/r.xyz ) - 1.0) * r.y;\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.z - h;\n  float q = p.z - h;\n  float si = 0.5*(r1-r2)/h;\n  float d2 = max( sqrt( dot(p.xy, p.xy)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a, angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nmat2 r2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n//above rotates, below mirrors on half rotated axis\n#define r3(r) mat2(sin(vec4(-1,0,0,1)*acos(0.)+r))\n\n//fast 2d rotation, its fine.\nvoid pR(inout vec2 p, float a){\n p*=r2(a);\n //p=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n\nfloat fOpUnionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r - a, r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\n// Copyright © 2015 Inigo Quilez\nvec3 cubemap( sampler2D sam, in vec3 d )\n{\n  vec3 n = abs(d);\n\n  #if 0\n    // sort components (small to big)    \n    float mi = min(min(n.x, n.y), n.z);\n  float ma = max(max(n.x, n.y), n.z);\n  vec3 o = vec3( mi, n.x+n.y+n.z-mi-ma, ma );\n  return texture( sam, .1*o.xy/o.z ).xyz;\n  #else\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n      (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n      d.xy/d.z;\n  return texture( sam, uv ).xyz;\n\n  #endif\n}\n\nvec3 TranslatePos(vec3 p, float _pitch, float _roll)\n{\n\n  pR(p.xy, _roll-3.14);\n  p.z+=5.;\n  pR(p.zy, _pitch);\n  p.z-=5.;\n  return p;\n}\n\n\nfloat MapEsmPod(vec3 p)\n{\n  float dist = fCylinder( p, 0.15, 1.0);   \n  checkPos =  p- vec3(0, 0, -1.0);\n  pModInterval1(checkPos.z, 2.0, .0, 1.0);\n  return min(dist, sdEllipsoid(checkPos, vec3(0.15, 0.15, .5)));\n}\n\nfloat MapMissile(vec3 p)\n{\n\n  if ( fCylinder( p, 0.70, 1.7)<21.0)\n  {\n    missileDist = min(missileDist, fCylinder( p, 0.12, 1.2));   \n    missileDist =min(missileDist, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    missileDist=min(missileDist, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    missileDist=min(missileDist, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    missileDist = max(missileDist, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    missileDist = max(missileDist, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n  }\n  return missileDist;\n}\n\nfloat MapFrontWing(vec3 p)\n{\n  missileDist=10000.0;\n\n  checkPos = p;\n  pR(checkPos.xy, -0.02);\n  float wing =sdBox( checkPos- vec3(4.50, 0.25, -4.6), vec3(3.75, 0.04, 2.6)); \n\n  if (wing<5.) //Bounding Box test\n  {\n    // cutouts\n    checkPos = p-vec3(3.0, 0.3, -.30);\n    pR(checkPos.xz, -0.5);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p - vec3(8.0, 0.3, -8.80);\n    pR(checkPos.xz, -0.05);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(10.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p- vec3(9.5, 0.3, -8.50);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(2.0, 1.4, 6.75)), 0.6);\n\n    // join wing and engine\n    wing=min(wing, sdCapsule(p- vec3(2.20, 0.3, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.8), 0.04));\n    wing=min(wing, sdCapsule(p- vec3(3., 0.23, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.5), 0.04));    \n\n    checkPos = p;\n    pR(checkPos.xz, -0.03);\n    wing=min(wing, sdConeSection(checkPos- vec3(0.70, -0.1, -4.52), 5.0, 0.25, 0.9));   \n\n    checkPos = p;\n    pR(checkPos.yz, 0.75);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(3.0, -.5, 1.50), vec3(3.75, 3.4, 2.0)), 0.12); \n    pR(checkPos.yz, -1.95);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(2.0, .70, 2.20), vec3(3.75, 3.4, 2.0)), 0.12); \n\n    checkPos = p- vec3(0.47, 0.0, -4.3);\n    pR(checkPos.yz, 1.57);\n    wing=min(wing, sdTorus(checkPos-vec3(0.0, -3., .0), vec2(.3, 0.05)));   \n\n    // flaps\n    wing =fOpIntersectionRound(wing, -sdBox( p- vec3(3.265, 0.1, -6.4), vec3(0.90, 1.4, .5)), 0.03);\n    wing =fOpIntersectionRound(wing, -max(sdBox( p- vec3(5.065, 0.1, -8.4), vec3(0.90, 1.4, 2.5)), -sdBox( p- vec3(5.065, 0., -8.4), vec3(0.89, 1.4, 2.49))), 0.03);\n\n    checkPos = p- vec3(3.265, 0.13, -6.20);\n    pR(checkPos.yz, -0.2);\n    wing =min(wing, sdBox( checkPos, vec3(0.89, 0.005, 0.3)));\n\n    // missile holder\n    float holder = sdBox( p- vec3(3.8, -0.26, -4.70), vec3(0.04, 0.4, 0.8));\n\n    checkPos = p;\n    pR(checkPos.yz, 0.85);\n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -1.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -5.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder =fOpUnionRound(holder, sdBox( p- vec3(3.8, -0.23, -4.70), vec3(1.0, 0.03, 0.5)), 0.1); \n\n    // bomb\n    bombDist = fCylinder( p- vec3(3.8, -0.8, -4.50), 0.35, 1.);   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -3.50), vec3(0.35, 0.35, 1.0)));   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -5.50), vec3(0.35, 0.35, 1.0)));   \n\n    // missiles\n    checkPos = p-vec3(2.9, -0.45, -4.50);\n    pModInterval1(checkPos.x, 1.8, .0, mix(1.0, 0., step(1., missile01.life)));\n    holder = min(holder, MapMissile(checkPos));\n\n\n    // ESM Pod\n    holder = min(holder, MapEsmPod(p-vec3(7.2, 0.06, -5.68)));\n\n    // wheelholder\n    wing=min(wing, sdBox( p- vec3(0.5, -0.25, -4.30), vec3(0.8, 0.4, .50)));\n\n    wing=min(bombDist, min(wing, holder));\n  }\n\n\n  return wing;\n}\n\nfloat MapRearWing(vec3 p)\n{\n  float wing2 =sdBox( p- vec3(2.50, 0.1, -8.9), vec3(1.5, 0.017, 1.3)); \n  if (wing2<0.15) //Bounding Box test\n  {\n    // cutouts\n    checkPos = p-vec3(3.0, 0.0, -5.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.2); \n\n    checkPos = p-vec3(0.0, 0.0, -4.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(3.3, 1.4, 1.70)), 0.2);\n\n    checkPos = p-vec3(3.0, 0.0, -11.70);\n    pR(checkPos.xz, -0.05);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1); \n\n    checkPos = p-vec3(4.30, 0.0, -11.80);\n    pR(checkPos.xz, 1.15);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n  }\n  return wing2;\n} \n\nfloat MapTopWing(vec3 p)\n{    \n  checkPos = p- vec3(1.15, 1.04, -8.5);\n  pR(checkPos.xy, -0.15);  \n  float topWing = sdBox( checkPos, vec3(0.014, 0.8, 1.2));\n  if (topWing<.3) //Bounding Box test\n  {\n    topWing = min(topWing, sdBox( checkPos-vec3(0, 0.55, 0), vec3(0.04, 0.1, 1.25)));\n\n    // cutouts\n    checkPos = p- vec3(1.15, 2., -7.2);\n    pR(checkPos.yz, 1.02);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.41, 0.6)), 0.05);\n\n    topWing=min(topWing, sdCapsule(p- vec3(1.26, 1.8, -8.84), vec3(0, 0, -.50), vec3(0, 0, 0.2), 0.06)); \n    checkPos = p- vec3(1.15, 1., -11.25);  \n    pR(checkPos.yz, -0.15);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n    checkPos = p- vec3(.26, 0.38, -6.26); \n    pR(checkPos.yz, 2.10);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(3.0, 1.8, 0.6)), 0.05);     \n\n    checkPos = p- vec3(1.15, 1.04, -9.15);\n    pR(checkPos.xy, -0.15);  \n    topWing = min(topWing, sdEllipsoid( checkPos-vec3(0, 0.25, 0), vec3(0.04, 0.04, 0.15)));\n    topWing = min(topWing, sdEllipsoid( checkPos-vec3(0, 0.10, 0), vec3(0.04, 0.04, 0.15)));\n  }\n  return topWing;\n}\n\nfloat Map( vec3 p)\n{\n  float  d=100000.0;\n  vec3 pOriginal = p;\n  // rotate position \n  p=TranslatePos(p, pitch, roll);\n\n  if (min(d, sdBox( p- vec3(0., -0., -3.), vec3(7.5, 2., 7.6)))<20.0) //Bounding Box test\n  { \n    // mirror position at x=0.0. Both sides of the plane are equal.\n    pMirror(p.x, 0.0);\n\n    float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));\n    body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);\n    body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   \n\n    // window\n    winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));\n    winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);\n    winDist = max(winDist, -body);\n    body = min(body, winDist);\n    body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., 1.0), vec3(3.0, 1., .01)), 0.03));\n    body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., .0), vec3(3.0, 1., .01)), 0.03));\n\n    // front\n    checkPos = p-vec3(0, 0, 2.5);\n    pR(checkPos.yz, 1.57);\n    body=fOpIntersectionRound(body, -sdTorus(checkPos, vec2(.46, 0.05)), 0.015);\n    body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 0.80, 0), vec2(.6, 0.05)), 0.015);\n    body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 2.30, 0), vec2(.62, 0.06)), 0.015);\n\n    // wings    \n    frontWingDist = MapFrontWing(p);\n    d=min(d, frontWingDist);\n    rearWingDist = MapRearWing(p);\n    d=min(d, rearWingDist);\n    topWingDist = MapTopWing(p);\n    d=min(d, topWingDist);\n\n    // bottom\n    checkPos = p-vec3(0., -0.6, -5.0);\n    pR(checkPos.yz, 0.07);  \n    d=fOpUnionRound(d, sdBox(checkPos, vec3(0.5, 0.2, 3.1)), 0.40);\n\n    float holder = sdBox( p- vec3(0., -1.1, -4.30), vec3(0.08, 0.4, 0.8));  \n    checkPos = p;\n    pR(checkPos.yz, 0.85);\n    holder=max(holder, -sdBox( checkPos- vec3(0., -5.64, -2.8), vec3(1.75, 1.4, 1.0))); \n    d=fOpUnionRound(d, holder, 0.25);\n\n    // large bomb\n    bombDist2 = fCylinder( p- vec3(0., -1.6, -4.0), 0.45, 1.);   \n    bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -3.20), vec3(0.45, 0.45, 2.)));   \n    bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -4.80), vec3(0.45, 0.45, 2.)));   \n\n    d=min(d, bombDist2);\n\n    d=min(d, sdEllipsoid(p- vec3(1.05, 0.13, -8.4), vec3(0.11, 0.18, 1.0)));    \n\n    checkPos = p- vec3(0, 0.2, -5.0);\n    d=fOpUnionRound(d, fOpIntersectionRound(sdBox( checkPos, vec3(1.2, 0.14, 3.7)), -sdBox( checkPos, vec3(1., 1.14, 4.7)), 0.2), 0.25);\n\n    d=fOpUnionRound(d, sdEllipsoid( p- vec3(0, 0., -4.), vec3(1.21, 0.5, 2.50)), 0.75);\n\n    // engine cutout\n    blackDist = max(d, fCylinder(p- vec3(.8, -0.15, 0.), 0.5, 2.4)); \n    d=max(d, -fCylinder(p- vec3(.8, -0.15, 0.), 0.5, 2.4)); \n\n    // engine\n    d =max(d, -sdBox(p-vec3(0., 0, -9.5), vec3(1.5, 0.4, 0.7)));\n\n    engineDist=fCylinder(p- vec3(0.40, -0.1, -8.7), .42, 0.2);\n    checkPos = p- vec3(0.4, -0.1, -8.3);\n    pR(checkPos.yz, 1.57);\n    engineDist=min(engineDist, sdTorus(checkPos, vec2(.25, 0.25)));\n    engineDist=min(engineDist, sdConeSection(p- vec3(0.40, -0.1, -9.2), 0.3, .22, .36));\n\n    checkPos = p-vec3(0., 0., -9.24);  \n    checkPos.xy-=vec2(0.4, -0.1);\n    checkPos.xy = pModPolar(checkPos.xy, 22.0);\n\n    float engineCone = fOpPipe(engineDist, sdBox( checkPos, vec3(.6, 0.001, 0.26)), 0.015);\n    engineDist=min(engineDist, engineCone);\n    engineDist=fOpIntersectionRound(engineDist, -fCylinder(p- vec3(0.4, -0.1, -9.52), 0.22, 1.0), 0.02);  \n\n    d=min(d, engineDist);\n\n    d=min(d, winDist);\n    d=min(d, body);\n    eFlameDist = sdEllipsoid( p- vec3(0.4, -0.1, -9.35-(speed*0.07)+cos(iTime*90.0)*0.03), vec3(.17, 0.17, .20));\n\n    d=min(d, sdBox( p- vec3(1.1, 0., -6.90), vec3(.33, .12, .17))); \n\n    checkPos = p-vec3(0.65, 0.55, -1.4);\n    pR(checkPos.yz, -0.35);\n    d=min(d, sdBox(checkPos, vec3(0.2, 0.1, 0.45)));\n  }\n  /*\n    // check if missile is launched\n   if(missile01.life>0.0)\n   {     \n   // create translation based on launch pitch and roll\n   p= TranslatePos(pOriginal, missile01.pitch, missile01.roll);\n   // mirror position to create two missiles at once  \n   pMirror(p.x, 0.0);\n   \n   vec3 distanceTraveled = (3.-missile01.life)*vec3(0.,0,-30.0);\n   checkPos = p-vec3(4.7, -0.45, -4.50)+distanceTraveled;\n   d = min(d, MapMissile(checkPos));\n   // map missile flame\n   eFlameDist = min(eFlameDist,sdEllipsoid(checkPos+ vec3(0.,0.,2.+cos(iTime*90.0)*0.23), vec3(.14, 0.14, 1.20)));\n   d = min(d, eFlameDist);\n   \n   // map missile smoke trail\n   \n   checkPos =  p-vec3(4.7, -0.45, -2.50)+distanceTraveled;\n   float s = pModInterval1(checkPos.z, -0.7, .0, 35.0);\n   \n   d=min(d,sdEllipsoid(checkPos, vec3(.3, 0.3, .15)*max(0.,((s*0.02)))));\n   }\n   */\n  return min(d, eFlameDist);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\n\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<32; i++ )\n  {\n    h = Map(origin+direction*t);\n    res = min( res, 8.5*h/t );\n    t += clamp( h, 0.03, 0.1);\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nRayHit March(in vec3 origin, in vec3 direction)\n{\n  RayHit result;\n  float maxDist = 150.0;\n  float t = 0.0, glassDist = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<RAYSTEPS; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n\n    if (abs(dist)<0.003 || t>maxDist )\n    {                \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.winDist = winDist;\n      result.engineDist = engineDist;\n      result.eFlameDist = eFlameDist;\n      result.blackDist = blackDist;\n      result.bombDist = bombDist;\n      result.bombDist2 = bombDist2;\n      result.missileDist = missileDist;\n      result.frontWingDist = frontWingDist;\n      result.rearWingDist = rearWingDist;\n      result.topWingDist = topWingDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\n// Advanced lightning pass. 2X SoftShadows + AO pass.\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                   \n  vec3 reflectDir = reflect( rayDir, normal );\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.99);   \n  dif *= SoftShadow(shadowPos, sunPos);\n  skylight *=SoftShadow(shadowPos, reflectDir);\n\n  vec3 lightTot = vec3(0.0);\n\n  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);\n  lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));\n}\n\n\nvec4 GetMaterial(vec3 rayDir, inout RayHit rayHit)\n{\n  vec3 hitPos =TranslatePos(rayHit.hitPos, pitch, roll);\n  vec3 reflectDir = reflect( rayDir, rayHit.normal );\n  vec3  refMap = cubemap(iChannel0, reflectDir*0.7);\n\n  vec3 col = vec3(0.65);\n  float specLevel=1.3;\n\n  // create camo\n  vec3 noiseShade = vec3(noise((hitPos+vec3(2.0, 1.0, 0.))*.8));\n  vec3 baseTexture = mix(col, mix(noiseShade*0.35, noiseShade*1.1, smoothstep(0.5, 0.52, noise(hitPos*1.26))), 0.5);\n  baseTexture = mix(baseTexture, (baseTexture+noiseShade)*0.55, smoothstep(0.5, 0.52, noise((hitPos+vec3(-6.))*1.26)));\n\n  col=baseTexture;\n\n  // create base color mixes\n  vec3 lightColor = mix(vec3(0.73), noiseShade, 0.35);\n  vec3 darkColor = mix(vec3(0.15), noiseShade, 0.45);\n  vec3 missilBaseCol =  mix(vec3(0.7), noiseShade, 0.45);\n  vec3 missilBaseCol2 =  mix(vec3(0.5), noiseShade, 0.45);\n  vec3 missilCol = mix(vec3(0.25), noiseShade, 0.25);\n  vec3 missilCol2 = mix(vec3(0.15), noiseShade, 0.15);\n\n  // front\n  col = mix(col, lightColor, smoothstep(3.0, 3.02, hitPos.z));  \n  col = mix(col, darkColor*0.4, smoothstep(3.08, 3.1, hitPos.z));\n\n  // front wing stripes\n  col=mix(darkColor, col, smoothstep(1.4, 1.42, distance(-6.90, hitPos.z)));\n  col=mix(lightColor, col, smoothstep(1.3, 1.32, distance(-6.90, hitPos.z)));\n  col=mix(darkColor, col, smoothstep(.84, 0.86, distance(-6.7, hitPos.z)));\n  col=mix(lightColor, col, smoothstep(.22, 0.235, distance(-6.94, hitPos.z)));\n\n  // front wing vertical stripes   \n  float xMod = mod(hitPos.x-0.5, 11.0);\n  col=mix(darkColor, col, smoothstep(0.5, 0.52, distance(5., xMod)));\n  col=mix(lightColor, col, smoothstep(0.4, 0.42, distance(5., xMod)));\n\n  col=mix(mix(lightColor, col, step(-0.01, hitPos.y)), col, step(.01, rayHit.frontWingDist));\n\n  // create star (front wings)         \n  vec2 center = vec2(5., -5.1)-vec2(xMod, hitPos.z);\n  float dist = length(center);\n  col=mix(lightColor, col, smoothstep(0.8, 0.82, dist));\n  col=mix(darkColor, col, smoothstep(0.7, 0.72, dist));\n  col=mix(lightColor, col, smoothstep(0.7, 0.72, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n  col=mix(darkColor, col, smoothstep(0.6, 0.62, (dist*1.50)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n\n  // rear wing stripes\n  col=mix(darkColor, col, smoothstep(.55, 0.57, distance(-9.6, hitPos.z)));\n  col=mix(lightColor, col, smoothstep(.5, 0.52, distance(-9.6, hitPos.z)));\n  col=mix(darkColor, col, smoothstep(.4, 0.42, distance(-9.6, hitPos.z)));\n\n  // esm pods\n  col = mix(col, lightColor*0.75, smoothstep(7.02, 7.04, abs(hitPos.x)));\n\n  // top wing stripes\n  col=mix(mix(darkColor, baseTexture, smoothstep(0.55, 0.57, distance(0.85, hitPos.y))), col, smoothstep(0., .05, rayHit.topWingDist));\n  col=mix(mix(lightColor, col, smoothstep(.32, 0.34, distance(0.95, hitPos.y))), col, smoothstep(0., .05, rayHit.topWingDist));\n\n  // create star (top wings)    \n  center = vec2(-8.73, 0.95)-vec2(hitPos.z, hitPos.y);\n  dist = length(center); \n  col=mix(darkColor, col, smoothstep(0.24, 0.26, dist));\n  col=mix(lightColor, col, smoothstep(0.24, 0.26, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.13)));\n\n  // windows\n  col=mix(0.35*refMap, col, step(.01, rayHit.winDist));\n  specLevel=mix(3.5, specLevel, step(.01, rayHit.winDist));\n\n  // engines exhaust\n  col=mix(vec3(0.3)*noiseShade, col, step(.05, rayHit.engineDist));\n  specLevel=mix(0.8, specLevel, step(.05, rayHit.engineDist));\n\n  // engine flame\n  col=mix(col, vec3(1.2, .55, 0.30), smoothstep(.1+(0.02*speed), 0., rayHit.eFlameDist));\n  col=mix(col*0.23, col, step(.02, rayHit.blackDist));\n\n  // small missiles\n  col=mix(mix(missilBaseCol, missilCol2, smoothstep(-3.35, -3.37, hitPos.z)), col, step(.1, rayHit.missileDist));\n  col=mix(mix(col, missilCol, smoothstep(-3.2, -3.22, hitPos.z)), col, step(.1, rayHit.missileDist));\n  col=mix(mix(missilCol2, col, smoothstep(.32, 0.34, distance(-4.75, hitPos.z))), col, step(.1, rayHit.missileDist));\n  col=mix(mix(missilBaseCol, col, smoothstep(.25, 0.27, distance(-4.75, hitPos.z))), col, step(.1, rayHit.missileDist));\n\n  // small bombs   \n  col=mix(mix(missilCol, missilBaseCol, smoothstep(1.18, 1.2, distance(-4.5, hitPos.z))), col, step(.01, rayHit.bombDist));      \n  col=mix(mix(col, missilCol2, smoothstep(1.3, 1.32, distance(-4.5, hitPos.z))), col, step(.01, rayHit.bombDist));  \n\n  // large bomb  \n  col=mix(mix(missilBaseCol2, missilCol, smoothstep(1.48, 1.5, distance(-4.1, hitPos.z))), col, step(.01, rayHit.bombDist2));      \n  col=mix(mix(col, missilBaseCol, smoothstep(1.6, 1.62, distance(-4.1, hitPos.z))), col, step(.01, rayHit.bombDist2));      \n  col=mix(mix(missilBaseCol, col, smoothstep(0.45, 0.47, distance(-4.1, hitPos.z))), col, step(.01, rayHit.bombDist2));      \n\n\n  // reflection at angle\n  col=mix(col, (col+refMap)*0.3, 0.4*pow( clamp(1.0+dot(rayHit.normal, rayDir), 0.0, 1.0), 2.0 ));\n  return vec4(col, specLevel);\n}\n\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    \n#ifdef doJetBombInterceptor\n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  // read missile data\n  missile01.life = read(vec2(100.0, 100.0));\n  missile01.roll = read(vec2(108.0, 100.0));\n  missile01.pitch = read(vec2(110.0, 100.0));\n  //missile01.turn = read(vec2(112.0, 100.0));\n\n  // read roll and speed values from buffer\n  float turn = mix(0.4, read(vec2(1.0, 10.0)), step(1.0, float(iFrame)));\n  roll = mix(3.14, read(vec2(1.0, 1.0)), step(1.0, float(iFrame)));\n  speed = read(vec2(10.0, 1.0));\n  pitch = read(vec2(15.0, 1.0));\n  sunPos = readRGB(vec2(50.0, 50.0));\n      pR(sunPos.xz, -turn);\n  // setup camera and ray direction\n\n  vec2 camrot = vec2(1.9, 0.25);\n\n  camrot.x+=mo.x*16.; \n  camrot.y+=mo.y*16.; \n\n  vec3 rayOrigin = vec3(CAMZOOM*cos(camrot.x), 3.+CAMZOOM*sin(camrot.y), -3.+CAMZOOM*sin(camrot.x) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  // load background from buffer A\n  vec4 color =  texture(iChannel0, uv);\n\n  RayHit marchResult = March(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n    // create texture map and set specular levels\n    vec4 col = GetMaterial(rayDir, marchResult);\n    // get lightning based on material\n    vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin);   \n\n    // apply lightning\n    color.rgb = col.rgb*light;\n    color.rgb = mix(color.rgb, vec3(0.3, 0.5, 0.7), 0.1);\n      color.a=1.0;\n  }\n\n  fragColor = color;\n    #endif\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}