{"ver":"0.1","info":{"id":"3syGRy","date":"1570401660","viewed":207,"name":"Fractal Box ","username":"darkeclipz","description":"A fractal box.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarcher from https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// Thanks iq!\n\n#define AA 1.\n#define R iResolution.xy\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    \n    float fixedRadius2 = 1.3;\n    float minRadius2 = 0.1;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\nvec2 getOffset(float time) \n{\n    float frames = 5.;\n    time = mod(time, frames);\n\n    float it = floor(time),\n          ft = fract(time);\n    \n    vec2 p1 = vec2(-3.2, -2.4);\n    vec2 p2 = vec2(-3.4, -4.1); \n    vec2 p3 = vec2(-2.2, -3.3); \n    vec2 p4 = vec2(-3.8, -3.7); \n    vec2 pl = vec2(0.85, -2.3);\n \n    vec2 pos = p1;\n \n    if(it < 0.5)       pos = mix(pl, p1, smoothstep(0.0, 1.0, ft));\n    else if(it < 1.5)  pos = mix(p1, p2, smoothstep(0.0, 1.0, ft));\n    else if(it < 2.5)  pos = mix(p2, p3, smoothstep(0.0, 1.0, ft));\n    else if(it < 3.5)  pos = mix(p3, p4, smoothstep(0.0, 1.0, ft));\n    else if(it < 4.5)  pos = mix(p4, pl, smoothstep(0.0, 1.0, ft));\n\n    return pos;\n}\n\nvec2 DE(vec3 z, float time)\n{\n    float Iterations = 14.;\n    float Scale = 2.6;\n    vec2 of = getOffset(time);\n\n    vec3 offset = vec3(of.x, 0., of.y);\n\tfloat dr = 1.0;\n    float trap = 99.;\n\tfor (float n = 0.; n < Iterations; n++) {\n        \n        z = mengerFold(z);\n        z.xz = -z.zx;\n        z.yx = -z.xy;\n        z = boxFold(z, vec3(1));       \n        sphereFold(z, dr);\n        z=z*Scale + offset;\n        \n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(abs(z)));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 map( in vec3 pos, float time ) \n{\n    vec2 d1 = DE(pos, time);\n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.00;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.01 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec2 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        vec2 h = map( pos, time );\n        m = h.y;\n        if( h.x<0.00095 )\n            break;\n        t += h.x;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec2(t,m);\n}\n\nvec3 camPos(float time) \n{\n    float frames = 5.;\n    time = mod(time, frames);\n\n    float it = floor(time),\n          ft = fract(time);\n    \n    vec3 p1 = vec3(-0.25, 0, 0.05);\n    vec3 p2 = vec3(0.2, 0, 0.2); \n    vec3 p3 = vec3(-.4, -0.3, 0.15); \n    vec3 p4 = vec3(-.1, 0.2, 0.25); \n    vec3 pl = vec3(-0.42, -0.05, 0.17);\n \n    vec3 pos = pl;\n\n    if(it < 0.5)       pos = mix(pl, p1, smoothstep(0.0, 1.0, ft));\n    else if(it < 1.5)  pos = mix(p1, p2, smoothstep(0.0, 1.0, ft));\n    else if(it < 2.5)  pos = mix(p2, p3, smoothstep(0.0, 1.0, ft));\n    else if(it < 3.5)  pos = mix(p3, p4, smoothstep(0.0, 1.0, ft));\n    else if(it < 4.5)  pos = mix(p4, pl, smoothstep(0.0, 1.0, ft));\n\n    return pos * 2.0;\n} \n\nmat3 camRotation(float time)\n{\n    float frames = 2.;\n    float it = floor(time),\n          ft = fract(time);\n \n    float angleY = 3.*cos(time);\n    float angleZ = sin(time);\n\n    mat3 ry = rotateY(angleY);\n    mat3 rz = rotateZ(angleZ);\n    return ry * rz;  \n}\n \nvoid mainImage( out vec4 O, in vec2 U )\n{\n\n    float time = iTime;\n    time /= 22.;\n\n    vec3 col = vec3(0);\n    vec3 res = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*((U + vec2(aax, aay) + vec2(0.5)) / AA)-R)/R.y;\n        \n        mat3 rot = camRotation(time);\n        vec3 ta = vec3(0,0,3) * rot;\n        vec3 ro = camPos(time);\n        \n        vec3 ww = normalize( ta-ro );\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n        vec3 vv = normalize( cross(uu,ww) );\n\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n \n        vec3 col = vec3(0.0);\n\n        vec2 tm = castRay(ro, rd, time); \n\n        if( tm.x < 20. )\n        {\n            float t = tm.x;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n\n            vec3 mate = vec3(0.18); \n            mate = cos(vec3(0,1,1.5) + tm.y*1.2 - time*11.) *.5 + .5;\n\n            vec3 sun_dir = normalize( vec3(-1, -1, 0) );\n            float sun_dif = clamp( dot(nor,sun_dir),0.0,1.0); \n            float sun_sha = 0.75*castShadow( pos+nor*0.001, sun_dir, time );\n            float bou_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n\n            col  = mate*vec3(5.0,4.5,4.0)*sun_dif*sun_sha;\n            col += mate*vec3(0.5,0.6,0.6)*bou_dif;\n        }\n\n        res += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow( res/(AA*AA), vec3(0.4545) );\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}