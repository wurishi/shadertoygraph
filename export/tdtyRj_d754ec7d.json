{"ver":"0.1","info":{"id":"tdtyRj","date":"1601396906","viewed":534,"name":"Subsurface Scattering - AT","username":"athibaul","description":"An approximation of subsurface scattering based on a \"single scattering\" model, implemented in a raymarcher.","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sss","approximation","scattering","subsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Subsurface scattering approximation for use in a raymarcher\n\n// Based on Fong et al. - Production Volume Rendering\n// https://drive.google.com/file/d/1eFr_4IKzt796Ns4Iv3OjR3ni0Y7QigP5/view\n// I extracted a way to compute a single-scattering approximation in a raymarcher.\n// More explanations in function shadeSSS() below.\n\n\nfloat map(vec3 p)\n{\n    float d = p.z+0.5;\n    vec3 p0 = round(p);\n    // Row of cubes\n    vec3 offset = vec3(clamp(p0.x,-3.,3.),0,0);\n    //float rounded = (p0.x + 3.)*0.05;\n    float rounded = 0.15;\n    vec3 q = abs(p - offset)-0.4 + rounded;\n    d = min(d, length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z))) - rounded);\n    \n    q = p - offset + vec3(0,1,0);\n    d = min(d, length(q) -0.05-rounded);\n    \n    q = abs(p - vec3(0.,1.,0.5)) - vec3(1.,0.0,1.0);\n    //d = min(d, length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z))) - 0.3);\n    return d;\n}\n\n\nvec2 coo;\nvec4 bluenoise()\n{\n    return texture(iChannel0, coo);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd)\n{\n    // Find intersection with the scene\n    float d, t=0.;\n    for(int i=0; i<256; i++)\n    {\n        d = map(ro+t*rd);\n        if(d < 0.001 || t > 100.) break;\n        t += d*0.8;\n    }\n    return ro+t*rd;\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = 0.001*vec2(1,-1);\n    return normalize(e.xxx*map(p+e.xxx)\n                     +e.xyy*map(p+e.xyy)\n                     +e.yxy*map(p+e.yxy)\n                     +e.yyx*map(p+e.yyx));\n}\n\nvec3 sun, sunCol;\n\nvec3 shadeSSS(vec3 ro, vec3 rd, vec3 scatteringDist, vec3 normal)\n{\n    // Do a subsurface raymarch to approximate a single scattering model.\n    // Needs the negative distances to be correct.\n    // Scattering distance can be different for each channel,\n    // but for now I haven't considered absorption.\n    \n    // The goal is to integrate the total transmittance\n    // between the observer and the light source.\n    \n    // At each marched point, the transmittance between the observer and\n    // the current point is T0 = exp(-t/scatteringDist).\n    // The transmittance between the current point and the\n    // sun is exp(-t1/scatteringDist), where t1 is the distance to\n    // exit the volume in the direction of the sun.\n    \n    // Rather than marching again, t1 is approximated by computing\n    // the value of the SDF at a second point in the direction of the sun,\n    // and assuming that the evolution of the SDF along the ray is\n    // approximately linear.\n    \n    vec3 sigma_s = 1./scatteringDist;\n    float clength = 1./length(sigma_s); // Characteristic length\n    float dt = 0.01*clength;\n    vec3 sum = vec3(0.);\n    vec3 norm = vec3(0.001);\n    float mult = 1.1;\n    float bn = bluenoise().y;\n    float t = dt;\n    for(; t<5.; t *= mult)\n    {\n        dt = (mult-1.)*t;\n        if(t > 20.*clength) break;\n        \n        // Two evaluations of the map, to compute approximate distance to the surface\n        \n        #if 0\n        // Evaluate at current point, and farther in the direction of the sun.\n        // Creates strong shadows where there should be transmittance.\n        float d0 = map(ro+t*rd);\n        if(d0 > 0.) break;\n        //float l1 = max(abs(d0), 0.001);\n        float l1 = clength;\n        //float l1 = min(clength, d0+0.001);\n        float ds = map(ro+t*rd+l1*sun);\n        // Approximate distance to surface\n        // (the 0.01 is to avoid edge artifacts)\n        float t1 = -d0*l1/(ds-d0);\n\t\t\n        #elif 1\n        // Evaluate at two points oriented toward the sun\n        float c = clength;\n        float d1 = map(ro+t*rd+c*sun);\n        float d2 = map(ro+t*rd+2.*c*sun);\n        \n        float t1 = c * (1. - d1/(d2-d1));\n        //return vec3(t1) * 10.;\n        //if(t1 > 0.) break;\n        \n        #else\n        /*\n        // Evaluate at 3 points and find root of quadratic polynomial\n        float l = clength;\n        float d0 = map(ro+t*rd);\n        float d1 = map(ro+t*rd+l*sun);\n        float d2 = map(ro+t*rd+2.*l*sun);\n        float a = 0.5;\n        */\n        #endif\n        \n        if(t1 < 0.) continue; // Don't use terms that don't make sense\n        vec3 T0 = exp(-t*sigma_s); // Transmittance to current point\n        vec3 T = exp(-(t+t1)/scatteringDist); // Total transmittance\n        sum += T * dt * sigma_s;\n        norm += T0 * dt * sigma_s;\n    }\n    //return 1.-norm;\n    // If the ray exits the volume, we should add term\n    //   T(d) * L(d,omega)\n    // i.e. compute again what is seen on the other side.\n    // Instead, light it as if the front face was diffuse.\n    sum += (1.-norm) * clamp(dot(normal, sun),0.,1.);\n    return sunCol * sum;\n}\n\nfloat softShadow(vec3 p, vec3 sun, float softness, float w0)\n{\n    float shadow = 1.0;\n    float d, t=0.0;\n    for(int i=0; i<50; i++)\n    {\n        d = map(p+t*sun);\n        float w = t*softness + w0;\n        shadow = min(shadow, smoothstep(-w,w,d+w0));\n        if(i < 3)\n        {\n            t += (d+w)*bluenoise().x;\n        }\n        else\n        {\n        \tt += d+w;\n        }\n        if(shadow < 0.001 || length(p) > 10.) break;\n    }\n    return shadow;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    coo = fragCoord/iResolution.xy;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(2.*cos(.1*iTime),-5.,1.5);\n    vec3 target = vec3(0.,-.5,0);\n    vec3 camFwd = normalize(target - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.5*(uv.x*camRight+uv.y*camUp));\n\n    //float th = 0.2*iTime;\n    float th = 3.1415*0.3 * (1.3 + sin(0.3*iTime));\n    sun = normalize(vec3(cos(th),-0.5*cos(th),sin(th)));\n    //sunCol = vec3(1.)*(vec3(1.,0.5,0.)*sqrt(sun.z) + vec3(0.,0.5,1.)*sun.z);\n    sunCol = vec3(1.,.95,.9);\n    if(sun.z < 0.)\n    {\n        sun = -sun;\n        sunCol = 2.0*vec3(0.2,0.3,0.4)*sqrt(sun.z);\n    }\n    \n    \n    vec3 p = raymarch(ro, rd);\n    vec3 n = calcNormal(p);\n    //vec3 col = 0.5 + 0.5*p;\n    vec3 col = vec3(0);\n\tfloat sssRadius = 0.1 + 0.2*smoothstep(-4.,4.,p.x);\n    float shadowW0 = sssRadius*0.1;\n    float shadow = softShadow(p, sun, 0.5, shadowW0);\n    if(p.z > -0.39 && length(p) < 10.)\n    {\n        // Skin-like material\n        // Red travels farther than green and blue.\n        col = shadeSSS(p-0.001*n, rd, sssRadius*vec3(1.,0.5,0.2), n);\n    }\n    else if(p.z < 0.)\n    {\n        col = 0.5 * sunCol * pow(clamp(sun.z, 0., 1.),0.3);\n    }\n    else\n    {\n        col = vec3(0.);\n    }\n    \n    col *= vec3(shadow) * smoothstep(10.,5.,length(p)+vec3(0.,0.5,1.));\n    //col = vec3(shadow);\n    \n    col = pow(col, vec3(0.45));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}