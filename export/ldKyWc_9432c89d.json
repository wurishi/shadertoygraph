{"ver":"0.1","info":{"id":"ldKyWc","date":"1523602305","viewed":403,"name":"Terrain Traveler","username":"MonterMan","description":"a terrain raymarcher with some stuff","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//NOTE(chen): here are the defines u can tweak\n\n//change the below define if you don't want to see cool glitch\n#define SHOW_GLITCH 1\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(73211.171, 841.13))) * 32131.18128);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 ipos = floor(uv);\n    vec2 fpos = fract(uv);\n    \n    float a = hash12(ipos);\n    float b = hash12(ipos + vec2(1, 0));\n    float c = hash12(ipos + vec2(0, 1));\n    float d = hash12(ipos + vec2(1, 1));\n    \n    vec2 t = smoothstep(0.0, 1.0, fpos);\n    \n    return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n}\n\nmat2 rot2(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nfloat fbm(vec2 uv)\n{\n    float acc = 0.0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for (int i = 0; i < 9; ++i)\n    {\n        acc += amp * noise(freq * uv);\n        uv = uv * rot2(0.3);\n        freq *= 2.0;\n        amp *= 0.5;\n    }\n    return acc;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float t_max, out bool hit)\n{\n    hit = false;\n    float t = 0.1;\n    \n    for (int i = 0; i < 256; ++i)\n    {\n        vec3 p = ro + t*rd;\n        float h = p.y - fbm(p.xz);\n        if (h < 0.004*t || t > t_max)\n        {\n#if !SHOW_GLITCH\n            if (t <= t_max)\n            {\n#endif\n            \thit = true;\n#if !SHOW_GLITCH  \n            }\n#endif\n            break;\n        }\n\n        \n        t += 0.25 * h;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float offset = -1.0;\n    vec3 ro = vec3(offset, 0.0, 0.0);\n    vec3 at = vec3(offset, -0.5, 4.0);\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = normalize(cross(cam_z, cam_x));\n    vec3 rd = cam_x * uv.x + cam_y * uv.y + 2.0 * cam_z;\n    \n    ro += vec3(0.0, 0.8, mod(1.0*iTime, 1000.0));\n    vec3 l = normalize(vec3(0.5, -0.5, 0.5));\n    \n    bool hit;\n    float t_max = 27.5;\n    float t = intersect(ro, rd, t_max, hit);\n    \n    vec3 p = ro + t*rd;\n    \n    //NOTE(chen): a hack, note dpdx and dpdz are not actual partial derivatives, just some offseted vector\n    vec3 px = vec3(p.x + 0.0001, 0.0, p.z);\n    vec3 pz = vec3(p.x, 0.0, p.z + 0.0001);\n    vec3 dpdx = vec3(px.x, fbm(px.xz), px.z);\n    vec3 dpdz = vec3(pz.x, fbm(pz.xz), pz.z);\n    \n    vec3 normal = normalize(cross(dpdz, dpdx));\n    \n    vec3 background = vec3(0.8, 0.8, 0.5);\n    vec3 col = background;\n    if (hit)\n    {\n        float occ = max(0., 2.0*p.y);\n        float dl = 0.25 * pow(dot(normal, -l) + 1.0, 2.0);\n        float lighting = 0.9 * dl + 0.3;\n        vec3 mat = vec3(0.8, 0.3, 0.0);\n        \n        col = mix(occ * lighting * mat, background, pow(t / t_max, 1.5));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}