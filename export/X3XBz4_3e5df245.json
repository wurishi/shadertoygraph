{"ver":"0.1","info":{"id":"X3XBz4","date":"1728058086","viewed":16,"name":"Shiny Sphere by LeSpeti","username":"LeSpeti","description":"Rendering a sphere with lighting.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadow","lighting","light","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Distance function for a sphere with a center position and radius\nfloat sdfSphere(vec3 p, vec3 center, float r) {\n    return length(p - center) - r;\n}\n\n// Scene function: returns distance to the nearest object in the scene\nfloat sceneSDF(vec3 p) {\n    return sdfSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n}\n\n// Ray-marching function\nfloat rayMarch(vec3 ro, vec3 rd, float maxDist, int maxSteps) {\n    float dist = 0.0;\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 pos = ro + rd * dist;\n        float d = sceneSDF(pos);\n        if (d < 0.001) { // Hit the object\n            return dist;\n        }\n        if (dist > maxDist) { // Exceeded maximum distance\n            break;\n        }\n        dist += d; // Advance the ray by the distance function\n    }\n    return maxDist;\n}\n\n// Normal calculation from SDF for shading\nvec3 calcNormal(vec3 p) {\n    float d = 0.001; // Small delta for numerical derivative\n    vec3 n;\n    n.x = sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p - vec3(d, 0.0, 0.0));\n    n.y = sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p - vec3(0.0, d, 0.0));\n    n.z = sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p - vec3(0.0, 0.0, d));\n    return normalize(n);\n}\n\n// Phong shading\nvec3 phongShading(vec3 normal, vec3 lightDir, vec3 viewDir) {\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float ambient = 0.1;\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    return lightColor * (ambient + diff + spec);\n}\n\n// Camera setup and ray marching\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Camera position and rotation setup\n    vec3 camPos = vec3(0.0, 0.0, -3.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    \n    // Build a simple look-at matrix\n    vec3 forward = normalize(camTarget - camPos);\n    vec3 right = normalize(cross(forward, camUp));\n    vec3 up = cross(right, forward);\n    \n    mat3 camRot = mat3(right, up, -forward);\n\n    // Ray direction from camera\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = camPos;\n    vec3 rd = normalize(camRot * vec3(uv, -1.0));\n    \n    // Ray march the scene\n    float maxDist = 100.0;\n    int maxSteps = 100;\n    float dist = rayMarch(ro, rd, maxDist, maxSteps);\n\n    // If we hit something, calculate shading\n    if (dist < maxDist) {\n        vec3 hitPos = ro + rd * dist;\n        vec3 normal = calcNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));  // Direction of the light\n        vec3 viewDir = normalize(-rd);  // View direction is opposite to ray direction\n        vec3 color = phongShading(normal, lightDir, viewDir);\n        fragColor = vec4(color, 1.0);\n    } else {\n        // Background color\n        fragColor = vec4(0.1, 0.1, 0.3, 1.0);\n    }\n    \n    fragColor /= 1.1 + sin(iTime) * 0.1;\n}\n","name":"Image","description":"","type":"image"}]}