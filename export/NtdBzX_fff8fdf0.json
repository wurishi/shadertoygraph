{"ver":"0.1","info":{"id":"NtdBzX","date":"1663503507","viewed":244,"name":"WeatherDayNight-220918","username":"diasgc","description":"clouds rain lighting within day cycle (non-physical model)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["weather"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based in Weather. By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.14,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .7, .55);\nfloat gTime, cloudy;\nvec3 flash;\n\n#define DAY_SPEED 0.05\n#define CLOUD_LOWER 2200.0\n#define CLOUD_UPPER 4200.0\n// Mind to set this carefully\n#define CLOUD_ITER 16\n#define WEATHER_SPEED 0.26\n#define RAIN_INTENSITY 1.32\n#define RAIN_SMOOTH 0.12\n#define RAIN_BRIGHT 0.38\n\n\nfloat Hash( float p ){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat Hash(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat Noise( in vec2 x ){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nfloat Noise(in vec3 p){\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.0-2.0*f);\n\n    return mix(\n\t\tmix(mix(Hash(i + vec3(0.,0.,0.)), Hash(i + vec3(1.,0.,0.)),f.x),\n\t\t\tmix(Hash(i + vec3(0.,1.,0.)), Hash(i + vec3(1.,1.,0.)),f.x),\n\t\t\tf.y),\n\t\tmix(mix(Hash(i + vec3(0.,0.,1.)), Hash(i + vec3(1.,0.,1.)),f.x),\n\t\t\tmix(Hash(i + vec3(0.,1.,1.)), Hash(i + vec3(1.,1.,1.)),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 2.345;\n\nfloat FBM( vec3 p ){\n\tp*= .0003;\n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\nfloat FBMSH( vec3 p ){\n\tp*= .1;\n        \n    float f;\n\t\n\tf = 0.5000 * Noise(p); p = m*p; //p.y -= gTime*.2;\n\tf += 0.2500 * Noise(p); p = m*p; //p.y += gTime*.06;\n\tf += 0.1250 * Noise(p); p = m*p;\n\tf += 0.0625   * Noise(p); p = m*p;\n\tf += 0.03125  * Noise(p); p = m*p;\n\tf += 0.015625 * Noise(p);\n    return f;\n}\n\n\nfloat MapSH(vec3 p){\n\t\n\tfloat h = -(FBM(p) - cloudy - 0.6);\n    h *= smoothstep(CLOUD_UPPER + 100., CLOUD_UPPER, p.y);\n\treturn h;\n}\n\nfloat Map(vec3 p){\n\treturn -(FBM(p)-cloudy-.6);\n}\n\nfloat GetLighting(vec3 p, vec3 s){\n    float l = MapSH( p )- MapSH( p + s * 200.);\n    return clamp(-l * 2., 0.05, 1.0);\n}\n\n\nconst vec3 skyTop = vec3(.0, .05, .4);\nconst vec3 skyHorizon = vec3(.3, .6, .8);\n\nvec3 GetSky(in vec3 pos,in vec3 rd, out vec2 outPos, in float cloudy){\n\t\n    float sunAmount = max( dot( rd, sunLight), 0.0 );\n    float light = cos(iTime * DAY_SPEED);\n    float sunset = exp(-light * light * 72.);\n    light += 0.12;\n    \n    light = max(0.5 + atan(26. * light)/3.1415, 0.02);\n    \n    vec3 skytop = light * skyTop; \n    vec3 skyhorizon = mix(skyHorizon, vec3(1.0, 0.8 - sunset * 0.25, 0.1 * sunset), sunset);\n    skyhorizon = light * pow(skyhorizon, vec3(0.2 * light));\n\tvec3 sunc = (sunColour - sunset * vec3(0.,.8,.9));\n    \n    // Sky\n    vec3  sky = mix(skytop, skyhorizon, 1.0 - rd.y);\n\t\n    // Sun\n    sky = sky + sunc * min(pow(sunAmount, 1500.0) * 5.0, 1.0);\n\tsky = sky + sunc * min(pow(sunAmount, 10.0) * .6, 1.0);\n\t\n\t// Find the start and end of the cloud layer...\n\tfloat beg = ((CLOUD_LOWER - pos.y) / rd.y);\n\tfloat end = ((CLOUD_UPPER - pos.y) / rd.y);\n\t\n\t// Start position...\n\tvec3 p = vec3(pos.x + rd.x * beg, 0.0, pos.z + rd.z * beg);\n\toutPos = p.xz * vec2( 1e-3, 1e-4);\n    beg +=  Hash(p) * 150.0;\n\n\t// Trace clouds through that layer...\n\tfloat d = 0.0;\n\tvec3 add = rd * ((end-beg) / 55.0);\n\tvec2 shade;\n\tvec2 shadeSum = vec2(0.0, 0.0);\n\tshade.x = 1.0;\n\t// def.val 55\n\tfor (int i = 0; i < CLOUD_ITER || shadeSum.y >= 1.0 ; i++){\n\n\t\tfloat h = Map(p);\n\t\tshade.y = max(h, 0.0); \n        shade.x = GetLighting(p, sunLight);\n\t\tshadeSum += shade * (1.0 - shadeSum.y);\n\t\tp += add;\n\t}\n\tvec3 dcloud = clamp(1.4* (light + sunset) * sunColour, 0.3, 1.0);\n\tvec3 clouds = clamp(light, 0.2, 0.8) * mix(dcloud * pow(shadeSum.x, .3) + 0.2, sunColour, (1.0 - shadeSum.y) * .4);\n    clouds += flash * (shadeSum.y + shadeSum.x + .2) * .2;\n\tsky = mix(sky, min(clouds, 1.0), shadeSum.y);\n\t\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvec3 CameraPath( float t ){\n    //return vec3(.0, 0.0, 8800.0 * cos(.145*t+.3));\n    //return vec3(4000.0 * sin(.16*137.)+12290.0, 0., 4e5 * cos(.145*t+.3));\n    return vec3(4000., 0., 9e5 * cos(.145*t+.3));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n    float m = (iMouse.x/iResolution.x) * 30.0;\n\t\n    gTime = iTime*.5 + 75.5;\n    float t= 137. * 0.5 + 75.5;\n\tcloudy = cos(gTime * .15 + .4) * WEATHER_SPEED;\n    float lightning = 0.0;\n    \n    if (cloudy >= .2){\n        float f = mod(gTime + 1.5, 2.5);\n        if (f < .8){\n            f = smoothstep(.8, .0, f) * 1.5;\n        \tlightning = mod( -gTime * (1.5 - Hash(gTime* 0.3) * 0.002), 1.0) * f;\n        }\n    }\n    \n    flash = clamp(vec3(1., 1.0, 1.2) * lightning, 0.0, 1.0);\n       \n\t\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tvec3 cameraPos = CameraPath(2.0);\n\tvec3 camTar\t   = CameraPath(.0);\n    float cSpeed = iTime * 250. * clamp(cloudy, 0.7, 1.0);\n\tcamTar.y = cameraPos.y = 1000.0;\n    cameraPos.z += cSpeed;\n    camTar.z += cSpeed;\n\tcamTar.y += 370.0;\n\t\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(0., 1., 0.);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x * cu + uv.y * cv + 1.3 * cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\tvec3 col;\n\tvec2 pos;\n\tcol = GetSky(cameraPos, dir, pos, cloudy);\n    col *= 1. - cloudy;\n\tfloat l = exp( -length(pos) * 2e-4);\n\tcol = mix(vec3(0.6 - cloudy * 1.2 ) + flash * 0.3, col, max(l, 0.2));\n\t\n\t\n\t\n    // Rain\n    vec2 st =  (uv - 1.57) * vec2( 0.5 + (xy.y + 0.1) * 0.31, .02) + vec2(gTime*.5+xy.y*.2, gTime*.2);\n\tfloat f = Noise( st * 200.5 ) * Noise( st * 120.5 ) * RAIN_INTENSITY;\n\tfloat rain = clamp(cloudy - .15, 0.0, 1.0);\n\tf = clamp(pow(abs(f), 15.0) * 5.0 * (rain * rain * 125.0), 0.0, (xy.y + .05) * RAIN_SMOOTH);\n\tcol = mix(col, vec3( RAIN_BRIGHT ) + flash, f);\n\tcol = clamp(col, 0.0,1.0);\n\n\t//col = pow(col, vec3(.85,.96, 1.0));\n    col = pow(col, vec3(.7));\n\t\n\tfragColor=vec4(col, 1.0);\n}\n\n//--------------------------------------------------------------------------\n","name":"Image","description":"","type":"image"}]}