{"ver":"0.1","info":{"id":"7t2yWh","date":"1649642250","viewed":56,"name":"Floating Balls Via Ray Marching","username":"BeepBoop","description":"Floating Balls Via Ray Marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURF_DISTANCE 0.01\n\nvec4 spheres[3] = vec4[3](\n    vec4(-1,1,4,0.5), vec4(0,1,4,0.75), vec4(1,1,4,0.5)\n);\n\nvec3 colors[3] = vec3[3](\n    vec3(0,0.25,0.25), vec3(0.25,0.25,0), vec3(0.3,0.3,0.6)\n);\n\nvec3 hitColor = vec3(0,0,0);\n\nfloat GetDistance(vec3 pos)\n{\n    //vec4 sphere = vec4(0,1,6,1);\n    //float sphere_distance = length(pos-sphere.xyz)-sphere.w;\n    float ground_distance = pos.y;\n    \n    int color_hit = 0;\n    float current_min_distance = MAX_DISTANCE;\n    for(int i = 0; i < spheres.length(); i++){\n        vec4 sphere = spheres[i] + vec4(0,sin(iTime)/5.0,0,0);\n        float sphere_distance = length(pos-sphere.xyz)-sphere.w;\n        if(sphere_distance<current_min_distance){\n            color_hit = i;\n        }\n        current_min_distance = min(current_min_distance, sphere_distance);\n    }\n    \n    if(current_min_distance < ground_distance){\n        hitColor = colors[color_hit];\n    }else{\n        hitColor = vec3(0.5,0,0);\n    }\n    \n    //return min(ground_distance,sphere_distance);\n    return min(ground_distance,current_min_distance);\n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_direction)\n{\n    float distance_from_origin = 0.0;\n  \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ray_origin + ray_direction*distance_from_origin;\n        float distance_to_scene = GetDistance(p);\n        distance_from_origin += distance_to_scene;\n        \n        if(distance_from_origin>MAX_DISTANCE || distance_to_scene<SURF_DISTANCE){\n            break;\n        }\n    }\n    \n    return distance_from_origin;\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    float distance = GetDistance(pos);\n    vec2 e = vec2(0.01,0);\n    vec3 n = distance - vec3(\n        GetDistance(pos-e.xyy),\n        GetDistance(pos-e.yxy),\n        GetDistance(pos-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat GetLight(vec3 pos)\n{\n    vec3 light_pos = vec3(0,5,6);\n    light_pos.xz += vec2(sin(iTime)*4.0,cos(iTime)*4.0);\n    \n    vec3 to_light = normalize(light_pos-pos);\n    vec3 surface_normal = GetNormal(pos);\n    \n    return dot(to_light, surface_normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 camera_origin = vec3(0,1,0);\n    vec3 camera_direction = normalize(vec3(uv.x,uv.y,1));\n\n    \n    float distance = RayMarch(camera_origin, camera_direction);\n    vec3 hit_position = camera_origin + camera_direction*distance;\n    float light_level = GetLight(hit_position);\n    col = hitColor*light_level;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}