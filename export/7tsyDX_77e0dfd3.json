{"ver":"0.1","info":{"id":"7tsyDX","date":"1648833419","viewed":322,"name":"sRGB vs rec.709","username":"AwareStubMan","description":"A simple test to show the difference between sRGB and rec.709. The rec.709 is more vibrant because of the change in the OETF curve which was designed for monitors that are viewed in a dark environment, which is the opposite of sRGB. is that right??","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["color","space","srgb","rec709"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I'm still a noob at color spaces, so eh\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 a = normalize(vec3(0.25, 0.5, 0.8));\n    vec3 b = normalize(vec3(0.8, 0.0, 0.25));\n    vec3 c = normalize(vec3(0.0, 0.8, 0.0));\n    vec3 d = normalize(vec3(0.5, 0.5, 1.0));\n    \n    float steps = float(1 << 5);\n    \n    vec3 col = vec3(0.0);\n    if (uv.x <= sin(iTime)*0.5+0.5)\n    {\n        vec3 x0 = mix(a, b, uv.x);\n        vec3 x1 = mix(c, d, uv.x);\n\n        col = mix(x0, x1, uv.y);\n\n        col = linear_2_sRGB(col);\n    }\n    else\n    {\n        vec3 x0 = mix(a, b, uv.x);\n        vec3 x1 = mix(c, d, uv.x);\n\n        col = mix(x0, x1, uv.y);\n\n        col = linear_2_rec709(col);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://en.wikipedia.org/wiki/Rec._709\n// The equation used to get beta from the simultaneous equations is (0.55x + 0.1)^(20/11) - x = 0\n//which then I use 2 newton's iteration starting from 0.018 to make it more precise.\n//the derivative of the equation is (0.55x + 0.1)^(9/11) - 1.0\nconst float rec709_beta_x1 = 0.018 - (pow(0.55*0.018 + 0.1, 20.0/11.0) - 0.018) / (pow(0.55*0.018 + 0.1, 9.0/11.0) - 1.0);\nconst float rec709_beta_x2 = rec709_beta_x1 - (pow(0.55*rec709_beta_x1 + 0.1, 20.0/11.0) - rec709_beta_x1) / (pow(0.55*rec709_beta_x1 + 0.1, 9.0/11.0) - 1.0);\nvec3 linear_2_rec709(vec3 v)\n{\n    const float alpha = 1.0 + 5.5*rec709_beta_x2;\n    bvec3 t = greaterThan(v, vec3(rec709_beta_x2));\n    return mix(4.5*v, alpha*pow(v, vec3(0.45)) - (alpha-1.0), vec3(t));\n}\nvec3 rec709_2_linear(vec3 v)\n{\n    const float alpha = 1.0 + 5.5*rec709_beta_x2;\n    bvec3 t = greaterThan(v, vec3(rec709_beta_x2));\n    return mix(v * (1.0/4.5), pow((v + (alpha-1.0)) * (1.0/alpha), vec3(1.0/0.45)), vec3(t));\n}\n\n// https://gamedev.stackexchange.com/questions/92015/optimized-linear-to-srgb-glsl\nvec3 linear_2_sRGB(vec3 v)\n{\n    bvec3 cutoff = lessThan(v, vec3(0.0031308));\n    vec3 higher = vec3(1.055)*pow(v, vec3(1.0/2.4)) - vec3(0.055);\n    vec3 lower = v * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\nvec3 sRGB_2_linear(vec3 v)\n{\n    bvec3 cutoff = lessThan(v, vec3(0.04045));\n    vec3 higher = pow((v + vec3(0.055))/vec3(1.055), vec3(2.4));\n    vec3 lower = v/vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}","name":"Common","description":"","type":"common"}]}