{"ver":"0.1","info":{"id":"DlKBDh","date":"1702037971","viewed":255,"name":"Tiny Hideout","username":"_pwd_","description":"Stylized Diorama.","likes":33,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","water","animation","stylized","diorama"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsd3RX","filepath":"https://soundcloud.com/northcape/first-day-in-a-new-town","previewfilepath":"https://soundcloud.com/northcape/first-day-in-a-new-town","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//\n//\n// Tiny Hideout  \n//\n// Short before upcoming xmas I decided to start a little diorama-series as practise and finger exercise. \n// The reference I used for the cabin is pretty naive -> (https://dasprinzip.com/tinker/cabin.png), but\n// fits well for my purpose, of working it all out in here.\n//\n// More to come the next weeks...\n//\n//\n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT.\n//\n//\n//\n//\n//\n//\n//\n// Related examples\n//\n// Athibaul´s distress flares:\n// https://www.shadertoy.com/view/3dGyRc\n//\n// gaz´s night circuit\n// https://www.shadertoy.com/view/tdyBR1\n//\n// // Gallo´s green field:\n// https://www.shadertoy.com/view/7dSGW1\n//\n// IQ´s article for sure\n// https://iquilezles.org/articles/distfunctions/\n//  \n//\n//\n\n\n\nvec3 flareCol = vec3(0.15, 1.0, 0.4);\n\nfloat noise(float x)\n{\n    return 2.*textureLod(iChannel0, vec2(x+0.5,0)/256., 0.).r-1.;\n}\n\nfloat fbm1D(float x)\n{\n    return noise(x)*0.5 + noise(2.*x)*0.25 + noise(4.*x)*0.125;\n}\n\nfloat intensityAtTime(float t)\n{\n    return fbm1D(t*3.)*0.5 + 0.5;\n}\n\nfloat ligIntensity(float t)\n{\n    return exp(6.*(intensityAtTime(t)-0.5));\n}\n\n\nvec3 flareColor(vec2 p, float time, float dmin)\n{\n    // Hexagonal shape\n    vec2 q = abs(p);\n    vec2 n = vec2(-sqrt(3.)/2., 0.5);\n    q = dot(q,n) > 0. ? reflect(q,n) : q;\n    float d = dot(q,n*vec2(-1,1));\n    float intensity = ligIntensity(time) / (1.+abs(p.y));\n    return flareCol * pow(d+dmin, -2.) * 0.005 * intensity;\n}\n\nvec3 bokeh(vec2 p, float t, float smoo)\n{\n    float bok = smoothstep(0.5+smoo,0.5-smoo,length(p))\n        * (0.5+smoothstep(0.0,0.5, length(p)));\n    return bok * 0.01 * flareCol * ligIntensity(t);\n}\n\nvec3 bokeh2(vec2 p, float t, float smoo)\n{\n    float bok = smoothstep(0.5+smoo,0.5-smoo,length(p));\n    return bok * 0.01 * flareCol * ligIntensity(t);\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv)\n{\n    return textureLod(iChannel1, uv * exp2(-lod) + offset, 0.0).rgb;\n}\n\nvec3 getBloom(vec2 uv)\n{\n    vec3 blur = vec3(0.0);\n    vec2 lOffsetFix = vec2(0.00025, 0.0005);\n    blur = pow(bloomTile(2., vec2(0.0, 0.0) + lOffsetFix, uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3, 0.0) + lOffsetFix, uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0, 0.3) + lOffsetFix, uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1, 0.3) + lOffsetFix, uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2, 0.3) + lOffsetFix, uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * BLOOM_RANGE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n    vec2 p = (fragCoord*1.5-iResolution.xy)/iResolution.y;\n    p.y -= 0.35;\n    p.x -= 0.45;\n    float camTime = iTime;\n    float time = iTime;\n    vec2 q = p + vec2(fbm1D(camTime+50.), fbm1D(camTime+20.))*0.1 - vec2(0.7,0.1);\n    \n    vec4 col = texture(iChannel0, uv);\n    //col.rgb += pow(getBloom(uv), vec3(2.2));\n    col.rgb += getBloom(uv);\n    col.rgb = aces_tonemap(col.rgb);\n\n\n    col.rgb += flareColor(1.2*p-q, time, 0.1) * 0.15;\n    col.rgb += bokeh(2.*p-q + 0.34, time, 0.05) * 0.5;\n    col.rgb += bokeh2(3.*(4.*p-q + 0.44), time, 0.2) * 0.5;\n    col.rgb += bokeh2(3.*(p-2.*q), time, 0.2) * 0.5;\n    col.rgb += bokeh2(5.*(3.*p-2.*q + 0.54), time, 0.1) * 0.3;\n    col.rgb += bokeh2(5.*(q+p), time, 0.2) * 0.5;\n    col.rgb += flareColor(5.*(p+0.53*q), time, 0.2)*0.5;\n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//////////////////////////////////////////////////////////////////////////////////////\n// defines & constants\n//////////////////////////////////////////////////////////////////////////////////////\n\n#define ANIMATE_WATER 1\n\n//Bloom\n#define BLOOM_SIZE (0.5)\n#define BLOOM_THRESHOLD (1.01)\n#define BLOOM_RANGE (0.3)\n#define BLOOM_FRAME_BLEND (0.2)\n\n//utility defines\n#define ZERO   (min(1,0))\n#define X_AXIS vec3(1,0,0)\n#define Y_AXIS vec3(0,1,0)\n#define Z_AXIS vec3(0,0,1)\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// Materials\n#define MAT_WOOD  101\n#define MAT_LEAFS 102\n#define MAT_UNDERWATER 301\n#define MAT_PLANT 701\n#define MAT_STONE 801\n\n#define MAT_GROUNDPLATE 203\n#define MAT_GROUNDPLATE_TOP 204\n#define MAT_BASEPLATE 205\n#define MAT_WALLS 206\n#define MAT_ROOF 207\n#define MAT_ENTRANCE 208\n#define MAT_WINDOW 209\n#define MAT_DUST 210\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// utility functions\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat3 rotation(vec3 axis, float angle)\n{\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return inverse(mat3(oc * axis.x * axis.x + c, \n                        oc * axis.x * axis.y - axis.z * s,  \n                        oc * axis.z * axis.x + axis.y * s, \n                        oc * axis.x * axis.y + axis.z * s,  \n                        oc * axis.y * axis.y + c,           \n                        oc * axis.y * axis.z - axis.x * s,  \n                        oc * axis.z * axis.x - axis.y * s,  \n                        oc * axis.y * axis.z + axis.x * s,  \n                        oc * axis.z * axis.z + c));\n}\n\nvec3 rotateX(vec3 pos, float alpha) {\n    mat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans * vec4(pos, 1.0));\n}\n\n\nvec3 rotateY(vec3 pos, float alpha) {\n    mat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans2 * vec4(pos, 1.0));\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdf blend & domain repetition (\n//////////////////////////////////////////////////////////////////////////////////////\n\n//HG\nfloat fOpUnionRound(float a, float b, float r) \n{\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2.0 - vec2(1.0);\n\treturn c;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r)\n{\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r)\n{\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n//IQ\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//IQ\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// min/max polynomial\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nfloat smoothDiff(float d2, float d1, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0 );\n    return mix(d2, -d1, h ) + k * h * (1.0 - h);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// basic sdf shapes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundBaseBox( vec3 p, vec3 b, float r )\n{\n    float b1 = sdRoundBox(p,b,r);\n    float b2 = sdRoundBox(p + vec3(-0.08,0.0,0.3),vec3(0.07, 0.005, 0.05),r);\n    \n    return min(b1,b2);\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdf shape combinations\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat gTime = 0.0;\n\n// Draws chimney´s edges\nfloat chimneyEdges(vec3 p) \n{\n    \n    float b = sdRoundBox(p + vec3(0.25, -0.44, -0.1), vec3(0.049, 0.005, 0.049), 0.008);\n    float c = sdRoundBox( p + vec3(0.25, -0.46, -0.1), vec3(0.011, 0.017, 0.011), 0.011);\n    float d = smoothDiff(b, c, .02);\n\n    return d;\n}\n\n// Draws rooftop\nfloat roofTop(vec3 p, vec3 r)\n{\n\tvec3 b = r;\n\tp.x = abs(p.x);\n  \tp.y += p.x*.4;\n\treturn length(max(abs(p)-b,0.0))-.03;\n}\n\n// Draws house´s walls and fit walls with rooftop \nfloat wallsAndRoof(vec3 p, vec3 dim, float r)\n{\n    float v = 0.0;\n    float c = 0.0;\n\n    c = roofTop(p + vec3(0.0, -0.23, 0.0), vec3(0.366, .03, 0.366));\n    v = sdRoundBox(p, dim, r);\n\n    return max(v,-c);\n}\n\nfloat treeTrunk(vec3 pos)\n{\n    float r = 1e10;\n\n    r = sdCone(pos, vec3(0.73,0.0,0.35), vec3(0.73,0.23,0.35), 0.02, 0.02 );\n    r += sin(30.*pos.x)*sin(50.*pos.y)*sin(30.*pos.z) * 0.01;\n\n    r = min(r, sdCone(pos, vec3(-0.25,0.0,0.61), vec3(-0.25,0.18,0.61), 0.017, 0.018 ));\n    r += sin(30.*pos.x)*sin(30.*pos.y)*sin(30.*pos.z) * 0.01;  \n    \n    return r;\n}\n\n\nvec3 cellpos;\nvec3 signvec;\nvec3 subpos;\nfloat fsign;\n\nfloat cf(vec3 pos) {\n\t\n\tcellpos=pos-floor(pos);\n\t\n\tsignvec=2.0*step(0.5,cellpos)-1.0;\n\tfsign=signvec.x*signvec.y*signvec.z;\n\t\n\tsubpos=abs(abs(cellpos-0.5)-0.25);\n\t\n\treturn fsign*(max(max(subpos.x,subpos.y),subpos.z)-0.25);\n\t\n}\n\n\nfloat treeLeafs(vec3 pos)\n{\n    float r = 1e10;\n\n    vec3 leafsDomainL = pos - vec3(0.53, 0.42, 0.);\n    vec3 leafsDomainR = pos - vec3(-0.53, 0.42, 0.);\n\n    r = min(r, sdRoundBox(leafsDomainL - vec3(0.20, -0.19, 0.35), vec3(0.07, 0.08, 0.07), 0.029));\n    r = min(r, sdRoundBox(leafsDomainL - vec3(0.28, -0.10, 0.35), vec3(0.02, 0.025, 0.02), 0.029));\n    r = min(r, sdRoundBox(leafsDomainL - vec3(0.23, -0.08, 0.40), vec3(0.024, 0.024, 0.024), 0.029));\n    r = min(r, sdRoundBox(leafsDomainL - vec3(0.13, -0.16, 0.29), vec3(0.02, 0.02, 0.02), 0.029));\n    \n    r = min(r, sdRoundBox(leafsDomainR - vec3(0.29, -0.24, 0.61), vec3(0.048, 0.058, 0.048), 0.029));\n    r = min(r, sdRoundBox(leafsDomainR - vec3(0.24, -0.23, 0.65), vec3(0.02, 0.02, 0.02), 0.029));\n        \n    return r + 0.02;\n}\n\n\n\nfloat g1=0.,g2=0.,g3=0.;\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\nvoid rot(inout vec2 p,float t){\n    p=p*cos(t)+vec2(-p.y,p.x)*sin(t);\n}\n\n// rewrote 20/12/01\nvoid sFold45(inout vec2 p)\n{\n\tvec2 v=normalize(vec2(1,-1));\n\tfloat g=dot(p,v);\n\tp-=(g-sqrt(g*g+5e-5))*v;\n}\n\nfloat stella(vec3 p, float s)\n{\n    p=sqrt(p*p+0.00005); // https://iquilezles.org/articles/functions\n    sFold45(p.xz);\n\tsFold45(p.yz);\n    return dot(p,normalize(vec3(1,1,-1)))-s;\n}\n\n\n#define seed 2576.\n#define hash(p)fract(sin(p*12345.5))\nfloat stellas(vec3 p)\n{\n    p.y-= gTime;\n    float c=5.;\n    vec3 e=floor(p/c);\n    e = sin(11.0*(2.5*e+3.0*e.yzx+1.345)); \n    p-=e*.5;\n    p=mod(p,c)-c*.5;\n    rot(p,hash(e+66.887)-.5,gTime*1.5);\n    return min(.7,stella(p,.06));\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float n)\n{\n    return fract(sin(n * 12.9898) * 43758.5453);\n}\n\nvec2 rand2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// main sdf\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(in vec3 pos)\n{\n    vec2 res = vec2( 1.0, 0.0 );\n    #define opMin(_v, _m)    res = (_v < res.x) ? vec2(_v, _m) : res\n    \n    float bottomGround = sdRoundBox(pos + vec3(0.0, 0.13, 0.0), vec3(0.6, 0.05, 0.6), 0.05);\n    float topGround = sdRoundBox(pos + vec3(0.0, 0.0, 0.0), vec3(0.6, 0.005, 0.6), 0.05);\n    float basePlate = sdRoundBaseBox(pos + vec3(0.1, -0.034, -0.15), vec3(0.28, 0.005, 0.28), 0.03);\n    float walls = wallsAndRoof(pos + vec3(0.1, -0.20, -0.15), vec3(0.25, 0.15, 0.25), 0.025);\n    float roof = roofTop(pos + vec3(0.1, -0.40, -0.15), vec3(0.286, .005, 0.266));\n    float entrance = sdRoundBox(pos + vec3(0.02, -0.15, 0.125), vec3(0.044, 0.08, 0.0035), 0.015);\n    float window = sdRoundBox(pos + vec3(0.20, -0.20, 0.1145), vec3(0.033, 0.033, 0.0035), 0.015);\n    float chimney = sdRoundBox(pos + vec3(0.25, -0.39, -0.1), vec3(0.03, 0.035, 0.03), 0.015);\n    float chimneyEdge = chimneyEdges(pos);\n\n    float waterCavity = sdEllipsoid(pos - vec3(-0.425, 0.01, -0.49), vec3(0.1, 0.2, 0.2));\n          waterCavity -= sin(20.*pos.x)*sin(30.*pos.y)*sin(20.*pos.z) * 0.012;\n          \n    bottomGround = fOpDifferenceRound(bottomGround, waterCavity, 0.07);\n    topGround = fOpDifferenceRound(topGround, waterCavity, 0.07);\n\n    opMin(bottomGround, MAT_GROUNDPLATE);\n    opMin(topGround, MAT_GROUNDPLATE_TOP);\n    opMin(basePlate, MAT_BASEPLATE);\n    opMin(walls, MAT_WALLS);\n    opMin(roof, MAT_ROOF);\n    opMin(entrance, MAT_ENTRANCE);\n    opMin(window, MAT_WINDOW);\n    opMin(chimney, MAT_WALLS);\n    opMin(chimneyEdge, MAT_ROOF);\n    \n    float rock = sdEllipsoid(pos - vec3(-0.05, 0.051, -0.32), vec3(0.08, 0.028, 0.06));\n    rock = min(rock, sdEllipsoid(pos - vec3(0.06, 0.048, -0.39), vec3(0.04, 0.021, 0.04)));\n    rock = min(rock, sdEllipsoid(pos - vec3(-0.04, 0.049, -0.45), vec3(0.06, 0.023, 0.055)));\n    rock = min(rock, sdEllipsoid(pos - vec3(-0.14, 0.049, -0.41), vec3(0.04, 0.023, 0.065)));\n    rock = min(rock, sdEllipsoid(pos - vec3( 0.028, 0.050, -0.54), vec3(0.043, 0.025, 0.059)));\n    rock = min(rock, sdEllipsoid(pos - vec3(-0.074, 0.049, -0.585), vec3(0.065, 0.030, 0.045)));\n    rock += sin(15.*pos.x)*sin(10.*pos.y + 15.5)*sin(28.*pos.z) * 0.02;\n    opMin(rock, MAT_STONE);\n    \n    vec3 treePos = pos - vec3( -0.3, 0.028, -0.3);\n    float treeTrunkDist = treeTrunk( treePos );\n    opMin(treeTrunkDist, MAT_WOOD);\n    float leafsDist = treeLeafs( treePos );\n    opMin(leafsDist, MAT_LEAFS);\n\n    float underWater = max(res.x , waterCavity - 0.03 );\n    res = (underWater < (res.x + 0.0001)) ? vec2(underWater, MAT_UNDERWATER) : res;\n    \n    float stellas = stellas(pos);\n    opMin(stellas, MAT_WINDOW);\n    \n    float d, d1;\n    d = 10000.0;\n    vec3 tempPos = pos + vec3(0.18, -0.39, -0.15);\n    \n    for(int i = 0; i < 20; i++)\n\t{\n        vec3 pos1;\n        float ltime = gTime*0.09 + float(i)*20.134;\n\n        float r = rand(float(i)*2.33);\n        float y = 0.08+mod(ltime*(r + 0.5), 1.0);\n\n        float r1 = rand(float(i)*12.33);\n        r1 *= 0.01;\n\n\n        pos1 = vec3(0.010*mod(float(i), 4.0) - 0.08, y, 0.010*floor(float(i)/5.0) - 0.08);\n        d1 = sdRoundBox(tempPos - pos1, vec3(0.005 + r1, 0.005 + r1, 0.005 + r1), 0.005);\n        if (d1 < d)\n        {\n            d = d1;\n\n        }       \n    }\n         \n    opMin(d, MAT_DUST);\n    return res;\n}\n\n\nfloat mapWaterVolume(vec3 pos)\n{   \n    vec3 rPosX = rotateX(pos, -1.5707);\n\n    float baseBox = sdBox( pos - vec3( -0.42, -0.09, -0.155), vec3(0.1,0.10,0.498) );\n    float wv = baseBox;\n    //animate water\n#if defined(ANIMATE_WATER) && ANIMATE_WATER\n    vec3 offset = vec3(-gTime * 0.04 - 0.02, 0.0, gTime * 0.06 + 0.1);\n#else\n    vec3  offset = vec3(0.1);\n#endif\n    wv += (1.0 - clamp((pos.y / -0.15), 0.0, 1.0)) // affect mostly on top of the water surface\n        *( 1.0\n         * sin(-22.*(pos.x+offset.x))\n         * sin(23.*(pos.z + offset.z))\n         + sin(20.*(pos.z + offset.z + 12.5)) * 0.3\n         + cos(15.*(pos.z + 2.1 +offset.x)) * 0.2\n         + cos(-21.*(pos.x+offset.z)) *0.5\n         )* 0.011;\n    wv -= 0.004;\n    wv = max(wv, sdBox( pos - vec3( -0.42, -0.09, -0.155), vec3(0.1,0.13,0.498) ));\n    wv -= 0.004;\n    \n    float baseBox2 = sdBox( rPosX - vec3( -0.415, 0.63, -0.45), vec3(0.09,0.02,0.42) );\n    float wv2 = baseBox2;\n    //animate water\n#if defined(ANIMATE_WATER) && ANIMATE_WATER\n    vec3 offset2 = vec3(-gTime * 0.04 - 0.02, 0.0, gTime * 0.06 + 0.1);\n#else\n    vec3  offset2 = vec3(0.1);\n#endif\n    wv2 += (1.0 - clamp((rPosX.y / -0.15), 0.0, 1.0)) // affect mostly on top of the water surface\n        *( 1.0\n         * sin(-22.*(rPosX.x+offset2.x))\n         * sin(23.*(rPosX.z + offset2.z))\n         + sin(20.*(rPosX.z + offset2.z + 12.5)) * 0.3\n         + cos(15.*(rPosX.z + 12.1 +offset2.x)) * 0.2\n         + cos(-21.*(rPosX.x+offset2.z)) *0.5\n         )* 0.011;\n    wv2 -= 0.004;\n    wv2 = max(wv2, sdBox( rPosX - vec3( -0.415, 0.63, -0.45), vec3(0.09,0.02,0.42) ));\n    wv2 -= 0.004;\n    \n    return min(wv,wv2);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching softshadows (https://iquilezles.org/articles/rmshadows)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    // bounding volume\n    //float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = tmin;\n    for( int i=ZERO; i<22; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/normalsSDF\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 calcNormalWater( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapWaterVolume(pos+0.0005*e);\n    }\n    return normalize(n); \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.00;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 calcSkyColor(vec3 aDirection)\n{\n    float t = smoothstep(0.1, 0.6, 0.7f*(aDirection.y + 1.0f));\n    return mix(vec3(1.0f, 1.0f, 0.2f), vec3(0.1f, 0.1f, 1.0f), t);\n}\n\nvec4 calcColor(int matId, vec3 pos, vec3 normal, float diffuse, float fresnel)\n{\n    vec4 FinalColor = vec4(0.1, 0.1, 0.1, 1) * diffuse;\n    if(matId == MAT_WOOD)\n    {\n        vec3 WoodBrown = vec3(0.287, 0.11882, 0.04) * 1.5;\n        vec3 WoodBrownShadow = vec3(0.1847, 0.0482, 0.016) * 1.2;\n        FinalColor.rgb = mix(WoodBrownShadow, WoodBrown, diffuse);\n        FinalColor.rgb += WoodBrown * fresnel * 2.0;\n    }\n    else if(matId == MAT_LEAFS)\n    {\n        vec3 Leafs = vec3(0.0882, 0.447, 0.04);\n        vec3 LeafsShadow = vec3(0.00582, 0.247, 0.02);\n        FinalColor.rgb = mix(LeafsShadow, Leafs, diffuse) * 0.7;\n        FinalColor.rgb += Leafs * fresnel * 2.5;\n    }\n    else if(matId == MAT_STONE)\n    {\n        vec3 Stone = vec3(0.4, 0.4, 0.4);\n        vec3 StoneShadow = vec3(0.2, 0.2, 0.3);\n        FinalColor.rgb = mix(StoneShadow, Stone, diffuse);\n        FinalColor.rgb += Stone * fresnel * 0.5;\n    }\n    else if(matId == MAT_GROUNDPLATE)\n    {\n        vec3 g = vec3(0.929,0.733,0.063);\n        vec3 g1 = vec3(0.90, 0.733,0.063);\n        FinalColor.rgb = mix(g1, g, diffuse);\n        FinalColor.rgb += vec3(0.929,0.411,0.033) * fresnel * 0.8;\n    }\n    else if(matId == MAT_GROUNDPLATE_TOP)\n    {\n        FinalColor.rgb = mix( vec3(0.9, 0.8, 0.04), vec3(1.0, 0.9, 0.04), diffuse);\n        FinalColor.rgb += vec3(0.95,0.85,0.033) * fresnel * 1.1;\n    }  \n    else if(matId == MAT_BASEPLATE)\n    {\n        FinalColor.rgb = mix( vec3(0.418,0.598,0.608), vec3(0.758,0.708,0.608), diffuse);\n        FinalColor.rgb +=  vec3(0.418,0.598,0.608) * fresnel * 0.9;\n    }  \n    else if(matId == MAT_WALLS)\n    {\n        FinalColor.rgb = mix( vec3(0.818,0.098,0.628), vec3(0.858,0.908,0.758), diffuse);\n        FinalColor.rgb +=  vec3(0.818,0.898,0.808) * fresnel * 0.9;\n    }  \n    else if(matId == MAT_ROOF)\n    {\n        FinalColor.rgb = mix( vec3(2.996,0.0,0.296), vec3(3.996,0.0,0.286), diffuse * 0.5);\n        FinalColor.rgb +=  vec3(2.996,0.0,0.296) * fresnel * 0.5;\n    }  \n    else if(matId == MAT_ENTRANCE)\n    {\n        FinalColor.rgb = mix( vec3(0.459,0.263,0.157), vec3(0.459,0.463,0.057),  diffuse * 0.3);\n        FinalColor.rgb +=  vec3(0.459,0.263,0.157) * fresnel * 2.5;\n    }  \n    else if(matId == MAT_WINDOW)\n    {\n        FinalColor.rgb = mix( vec3(0.818,0.198,0.108), vec3(0.758,0.708,0.608), diffuse);\n        FinalColor.rgb +=  vec3(0.459,0.263,0.157) * fresnel * 2.5;\n    }    \n    else if(matId == MAT_DUST)\n    {\n        FinalColor.rgb = mix( vec3(0.980, 0.980, 0.980), vec3(1.980,1.980,1.980), diffuse);\n        FinalColor.rgb +=  vec3(1.880,1.880,1.880) * fresnel * 0.5;\n    }    \n    else if(matId == MAT_UNDERWATER)\n    {\n        vec3 Sand = vec3(0.447, 0.447, 0.04);\n        vec3 SandShadow = vec3(0.347, 0.247, 0.02);\n        FinalColor.rgb = mix(SandShadow, Sand, diffuse);\n    }\n    \n    return FinalColor;\n}\n\nvec3 castRay(vec3 ro, vec3 rd)\n{\n    vec3 res = vec3(0.0, 1e10, 0.0);\n    float tmin = 1.0;\n    float tmax = 20.0;\n    float t = tmin;\n    for( int i=0; i<120 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec3(t, h.x, h.y); \n            return res;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec4 applyWaterVolume(vec3 ro, vec3 rd, float depth, vec4 color)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    float t = tmin;\n    float hit = 0.0;\n    float h = 0.0;\n    float distInsideWater = 0.0;\n    for( int i=0; i<70 && t<tmax; i++ )\n    {\n        h = mapWaterVolume( ro+rd*t );\n        if( abs(h)<(0.0001*t) )\n        { \n            distInsideWater += h;\n            hit = 1.0;\n            break;\n        }\n        else if(hit > 0.0)\n        {\n            break;\n        }\n        t += h;\n        if(depth > 0.0 && ((t + 0.0011) > depth))\n        {\n            break;\n        }\n    }\n    \n    depth = (depth > 0.0) ? depth : t*2.5;\n    \n    vec4 WaterBlue = vec4(0.1, 0.4, 1.0, color.a);\n    \n    vec3 pos = ro + rd * t;\n    vec3 lightDir = normalize( vec3(-0.5, 1.1, 0.9) );\n    float shadow = calcSoftshadow( pos, lightDir, 0.02, 2.5 );\n    vec3 normal = calcNormalWater(pos);\n    float NdL = clamp( dot( normal, lightDir ), 0.0, 1.0 );\n    vec3  hal = normalize( lightDir-rd );\n    float spe = pow( clamp( dot( normal, hal ), 0.0, 1.0),40.0)\n                    //*mix(0.5, 1.0, NdL* shadow)  //shadow\n                    //*(0.04 + 2.5*pow( clamp(1.0+dot(hal, rd),0.0,1.0), 1.0 ));\n                    ;\n    spe = smoothstep(0.5, 0.9, spe);\n    //light affecting water\n    WaterBlue = mix(WaterBlue * 0.5, WaterBlue, NdL * shadow);\n    \n    //all inside water is bluiedish\n    color = mix(color, WaterBlue * 0.8 + color * WaterBlue * 0.5, hit * 0.3);\n    \n    //distance to closest point\n    float nearest = clamp(map(pos).x, 0.0, 1.0);\n    color = mix(color, WaterBlue, clamp(pow(nearest * hit, 1.3) * 5.0, 0.0, 1.0));\n    \n    //distance to center of the diorama hack\n    color = mix(color, WaterBlue , clamp(pow(length(pos) * hit, 2.0) * 1.2, 0.0, 1.0));\n    //color = mix(color, WaterBlue * 0.5, ((t / depth)) * hit * 0.7);\n    //return vec4(mix(color.rgb, normal * 0.5 + 0.5, hit), 1.0);\n\n#define WATER_OPACITY_INIT 0.3\n#define WATER_OPACITY_COEFF 2.5\n\n    float fresnel = pow( clamp(1.0+dot(normal,rd),0.0,1.0), 2.4 );\n    color.rgb += hit*2.00*spe*vec3(1.);\n    color += mix(vec4(0.0), fresnel*color*3.0, hit * mix(0.2, 1.0, shadow));\n    return color;\n}\n\nvec4 render( vec2 uv, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec4 finalColor = vec4(calcSkyColor(rd), 0.0);\n    vec3 res = castRay(ro,rd);\n    \n    if(res.y < 0.002)\n    {\n        vec3 lightDir = normalize( vec3(-0.5, 1.1, -0.6) );\n        vec3 pos = ro + rd * res.x;\n        vec3 normal = calcNormal(pos);\n        \n        float ao = calcAO(pos, normal);\n        float shadow = calcSoftshadow( pos, lightDir, 0.02, 2.5 );\n        float NdL = clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        float fresnel = pow( clamp(1.0+dot(normal,rd),0.0,1.0), 2.4 );\n        \n        float diffuse  = shadow * NdL * 12.0;\n\n        vec4 color = calcColor(int(res.z), pos, normal, diffuse, fresnel) * mix(0.22, 1.0, ao);\n        finalColor = vec4(color.rgb, res.x);\n        finalColor.rgb = finalColor.rgb * 0.4 + 0.6 * finalColor.rgb * calcSkyColor(normal);\n    }\n    \n    finalColor = applyWaterVolume(ro, rd, res.x, finalColor);\n    return finalColor;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//////////////////////////////////////////////////////////////////////////////////////\n// main raymarching\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = float(iTime);\n    vec2 mo = iMouse.xy/iResolution.xy;\n    //mo.y += 0.2;\n\tfloat time = 23.5 + iTime*1.5;\n    //float time = 23.5;\n    \n    // camera\t\n    vec3 ro = vec3( 4.6*cos(0.1*time + 12.0*mo.x),  1.2 + 3.0*mo.y, 4.6*sin(0.1*time + 12.0*mo.x) );\n    vec3 ta = vec3( 0.0, 0.14, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,6.0) );\n\n     // ray differentials (NOT USED YET)\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,2.0) );\n    vec3 rdy = ca * normalize( vec3(py,2.0) );\n\n    // render\n    vec4 col = render( p, ro, rd, rdx, rdy );\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//////////////////////////////////////////////////////////////////////////////////////\n// pyramid bloom (https://www.shadertoy.com/view/lsBfRc)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord, vec2 aPixelSize)\n{\n    offset += aPixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * aPixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -3; i < 3; i++) \n    {\n        for (int j = -3; j < 3; j++) \n        {\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125, 6.0); //* 0.125, 6.0\n            vec3 lTextureColor = textureLod(iChannel1, vec2(i,j) * scale + lodFactor * aPixelSize + coord, lod).rgb;\n            lTextureColor = (any(greaterThan(lTextureColor, vec3(BLOOM_THRESHOLD)))) ? lTextureColor * BLOOM_SIZE : vec3(0.0);\n            lTextureColor = pow(lTextureColor, vec3(2.2)) * wg;\n            bloom = lTextureColor + bloom;\n\n            totalWeight += wg;\n            \n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 lInputColor0 = texture(iChannel0, uv);\n\n    vec3 lBlur  = makeBloom(2., vec2(0.0, 0.0), uv, pixelSize);\n         lBlur += makeBloom(3., vec2(0.3, 0.0), uv, pixelSize);\n         lBlur += makeBloom(4., vec2(0.0, 0.3), uv, pixelSize);\n         lBlur += makeBloom(5., vec2(0.1, 0.3), uv, pixelSize);\n         lBlur += makeBloom(6., vec2(0.2, 0.3), uv, pixelSize);\n\n        vec4 lOutputColor = vec4(clamp(pow(lBlur, vec3(1.0 / 2.2)), vec3(0), vec3(100)), 1.0);\n        fragColor = mix(lInputColor0, lOutputColor, BLOOM_FRAME_BLEND); \n}","name":"Buffer B","description":"","type":"buffer"}]}