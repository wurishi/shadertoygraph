{"ver":"0.1","info":{"id":"Mcc3W7","date":"1711753410","viewed":83,"name":"i dont know why, but...","username":"Bestenfalls","description":"lets try some glsl\n\niMouse X = position in iTime applied to x\niMouse Y = tansition\niMouse Z = zoom\niMouse X = rotation ( normalised to 360 max )","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sins","cosins"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 paletteSecond( float t ) {\n    vec3 a = vec3(0.25,0.25,0.25); // Adjust these color values as desired\n    vec3 b = vec3(0.75,0.75,0.75); // Adjust these color values as desired\n    vec3 c = vec3(0.50,0.50,0.50); // Adjust these color values as desired\n\n    return a + b*sin( 6.28318*(c*t) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Modifiers based on iMouse inputs for the first shader\n    float modifierX1 = iMouse.x / iResolution.x * 0.1;\n    float modifierY1 = iMouse.y / iResolution.y * 0.1;\n    float modifierZ1 = iMouse.z / iResolution.x * 8.0;\n    float modifierW1 = (iMouse.w / iResolution.y) * 2.0 * 3.14159; \n\n    // Inverted modifiers for the second shader\n    float modifierX2 = ((iResolution.x - iMouse.x) / iResolution.x) * 0.1;\n    float modifierY2 = ((iResolution.y - iMouse.y) / iResolution.y) * 0.1;\n    float modifierZ2 = ((iResolution.x - iMouse.z) / iResolution.x) * 4.0;\n    float modifierW2 = (((iResolution.y - iMouse.w) / iResolution.y) * 2.0 * 3.14159);\n    \n    // Convert to radians for full rotation\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Apply rotation to UV coordinates for the first shader\n    float rotatedX1 = uv.x * cos(modifierW1) - uv.y * sin(modifierW1);\n    float rotatedY1 = uv.x * sin(modifierW1) + uv.y * cos(modifierW1);\n    \n    // Apply rotation to UV coordinates for the second shader\n    float rotatedX2 = uv.x * cos(modifierW2) - uv.y * sin(modifierW2);\n    float rotatedY2 = uv.x * sin(modifierW2) + uv.y * cos(modifierW2);\n    \n    // Create patterns for the first shader\n    float patternX1 = sin(rotatedX1 * modifierZ1 + iTime * modifierX1);\n    float patternY1 = cos(rotatedY1 * modifierZ1 + iTime * modifierX1);\n    float patternZ1 = sin(uv.y + iTime * modifierX1);\n    float patternW1 = cos(uv.x + iTime * modifierX1);\n    \n    // Create patterns for the second shader\n    float patternX2 = sin(rotatedX2 * modifierZ2 + iTime * modifierX2);\n    float patternY2 = cos(rotatedY2 * modifierZ2 + iTime * modifierX2);\n    float patternZ2 = sin(uv.y + iTime * modifierX2);\n    float patternW2 = cos(uv.x + iTime * modifierX2);\n    \n    // Combine the patterns for the first shader\n    float combinedPattern1 = (patternX1 + patternY1 + patternZ1 + patternW1) / 4.0;\n    \n    // Combine the patterns for the second shader\n    float combinedPattern2 = (patternX2 + patternY2 + patternZ2 + patternW2) / 4.0;\n    \n    // Use the combined patterns to modulate color for each shader\n    vec3 col1 = palette(combinedPattern1); // Color for the first shader\n    vec3 col2 = paletteSecond(combinedPattern2); // Color for the second shader using the second palette\n    \n    // Transition fader using iMouse.y\n    float transition = iMouse.y / iResolution.y;\n    \n    // Interpolate between the colors of the two shaders based on the transition\n    vec3 finalColor = mix(col1, col2, transition);\n    \n    // Output final color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}