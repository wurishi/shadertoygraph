{"ver":"0.1","info":{"id":"3lsXz7","date":"1562472917","viewed":306,"name":"Wavy sand","username":"ParaBellum","description":"Testing noise to adding more texture to surfaces.\nMove light with mouse + left click.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","wave","light","sand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 brown = vec3(.6, .4992, .3625);\n\n// 2D Random\nfloat r1d(float x) {\n    return fract(sin(dot(vec2(x, x),\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat n1D(float x)\n{\n    float i = floor(x);  // integer\n    float f = fract(x);  // fraction\n    float y = r1d(i); //rand() is described in the previous chapter\n    y = mix(r1d(i), r1d(i + 1.0), f);\n    y = mix(r1d(i), r1d(i + 1.0), smoothstep(0.,1.,f));\n    return y;\n}\n\n// 2D Random\nfloat r2d (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = r2d(i);\n    float b = r2d(i + vec2(1.0, 0.0));\n    float c = r2d(i + vec2(0.0, 1.0));\n    float d = r2d(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define PI 3.141592\n\nfloat waves(vec2 p)\n{\n    float t = iTime;\n    for (int i = 0; i < 10; i++) p.y += n1D(p.x*float(i)/2.+t*.05)*.05;\n    p *= 3.;\n    vec2 i_p = floor(p);\n    if (mod(i_p.y, 2.) != 0.) p.y += n1D(abs(p.y+p.x+.5))*.5;\n    else p.y += n1D(abs(p.y+p.x+.5))*.5;\n    p = fract(p)*2.-1.;\n    return smoothstep(.0, 1., abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 frag = fragCoord.xy;\n    vec2 uv = frag/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 ms = iMouse.xy / iResolution.xy * 2. - 1.;\n    ms.x *= iResolution.x / iResolution.y;\n    \n    vec2 e = vec2(1., .0);\n    \n    vec2 x_uv = (frag+e.xy)/iResolution.xy * 2. - 1.;\n    x_uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 y_uv = (frag+e.yx)/iResolution.xy * 2. - 1.;\n    y_uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 pos = vec2(uv*5.);\n    vec2 x_pos = vec2(x_uv*5.);\n    vec2 y_pos = vec2(y_uv*5.);\n\n    // Use the noise function\n    float n = noise(pos);\n    n += noise(pos*4.)*.25;\n    n += noise(pos*8.)*.125;\n    n += noise(pos*16.)*.0625;\n    n *= .15;\n    \n    float x_n = noise(x_pos);\n    x_n += noise(x_pos*4.)*.25;\n    x_n += noise(x_pos*8.)*.125;\n    x_n += noise(x_pos*16.)*.0625;\n    x_n *= .15;\n    \n    float y_n = noise(y_pos);\n    y_n += noise(y_pos*4.)*.25;\n    y_n += noise(y_pos*8.)*.125;\n    y_n += noise(y_pos*16.)*.0625;\n    y_n *= .15;\n    \n    float w = waves(uv);\n    float dx = waves(x_uv);\n    float dy = waves(y_uv);\n    \n    float r = r2d(uv);\n    float x_r = r2d(x_uv);\n    float y_r = r2d(y_uv);\n    \n    vec3 fragPos = vec3(uv, w+n);\n    vec3 x_fragPos = vec3(x_uv, dx+x_n);\n    vec3 y_fragPos = vec3(y_uv, dy+y_n);\n    \n    vec3 fragPosR = vec3(uv, r);\n    vec3 x_fragPosR = vec3(x_uv, x_r);\n    vec3 y_fragPosR = vec3(y_uv, y_r);\n    \n    vec3 a = x_fragPos - fragPos;\n    vec3 b = y_fragPos - fragPos;\n    vec3 nor = normalize(cross(a, b));\n    \n    vec3 aR = x_fragPosR - fragPosR;\n    vec3 bR = y_fragPosR - fragPosR;\n    vec3 norR = normalize(cross(aR, bR));\n    \n    vec3 lightPos = vec3(ms, 4.);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 eye = vec3(0., 0., 6.);\n    vec3 eyeDir = normalize(eye - fragPos);\n    vec3 halfWayDir = normalize(lightDir + eyeDir);\n    \n    float amb = w;\n    float dif = max(dot(nor+norR, lightDir), 0.);\n    float spe = pow(max(dot(halfWayDir,nor+norR), 0.),6.)*r;\n    float light = amb + dif + spe;\n    \n    w = clamp(w, .7, 1.);\n    vec3 col = vec3(0.);\n    col += brown*(light+w)*.5; \n\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)),1.0);\n}","name":"Image","description":"","type":"image"}]}