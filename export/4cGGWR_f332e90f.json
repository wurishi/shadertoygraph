{"ver":"0.1","info":{"id":"4cGGWR","date":"1712585780","viewed":47,"name":"penzai blog0x9 some curve","username":"letbonsaibe","description":"sdf  shape with curve\n\nhttps://github.com/OhBonsai/art/wiki/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WHITE vec3(1.0, 1.0, 1.0)\n#define OCOLOR vec3(0.9,0.6,0.3) \n#define ICOLOR vec3(0.65,0.85,1.0)\n#define PI    3.141592653\n#define PI2   6.283185306 \n\n\nfloat vector_angle(vec2 iAxis, vec2 v) {\n    float theta = acos(dot(iAxis, v) / length(iAxis) / length(v));\n    float crossV = iAxis.x * v.y - iAxis.y * v.x;\n    if (crossV < 0.0) {\n      return PI * 2.0 - theta;\n    } else {\n      return theta;\n    }\n}\n\n\n\nvec2 symmetrical_point(vec2 P, vec2 V) {\n    vec2 V_normalized = normalize(V);\n    vec2 H = dot(P, V_normalized) * V_normalized;\n    vec2 PH_vector = H - P;\n    vec2 PP = P + 2.0 * PH_vector;\n    return PP;\n}\n\n\nvec2 cartesianToPolar(vec2 cartesianCoords) {\n    float r = length(cartesianCoords); // Radial distance\n    float theta = atan(cartesianCoords.y, cartesianCoords.x); // Angle in radians\n\n    return vec2(r, theta);\n}\n\n\nvec2 polarToCartesian(vec2 polarCoords) {\n    float x = polarCoords.x * cos(polarCoords.y); // r * cos(theta)\n    float y = polarCoords.x * sin(polarCoords.y); // r * sin(theta)\n\n    return vec2(x, y);\n}\n\nfloat cross2(vec2 a, vec2 b) {return a.x * b.y - b.x * a.y;}\n\n\n\nvoid wave(float dist, inout vec3 color) {\n    color *= .8  + 0.2 * sin(dist * 50.0 - iTime * 5.0);\n}\n\nvoid border(float dist, inout vec3 color) {\n    color *= 1.0 - exp(-40.0 * abs(dist));\n}\n\nvoid grid_border(vec2 p, float r, inout vec3 color) {\n     p = abs(p);\n     color = mix(color, WHITE, sign(r - min(1.0 - p.x, 1.0 - p.y)));\n}\n\n\nfloat sdf_uneven_capsule(vec2 p, float r1, float r2, float h) {\n    p.x = abs(p.x);\n    \n    float sin_theta = (r1-r2) / h;\n    float normalize_y = sin_theta * 1.0;\n    float normalize_x = sqrt(1.0 - (normalize_y * normalize_y));\n    float cos_theta = normalize_x;\n    vec2 v2 = vec2(-normalize_y, normalize_x);\n    vec2 v  = vec2(normalize_x, normalize_y);\n    \n    float k = dot(p, vec2(v2));\n    \n    // area1\n    if( k < 0.0 ) return length(p) - r1;\n    \n    \n    // area3\n    if( k > cos_theta*h ) return length(p-vec2(0.0,h)) - r2;\n    \n    // area2\n    return dot(p, v ) - r1;\n}\n\nfloat sdf_mossegg(vec2 P, float r, float d ) \n{\n    P.x = abs(P.x);\n    \n    vec2 B = vec2(-d, 0.);\n    float hh = r-d;\n    vec2 D = vec2(0, hh);\n    \n    \n    if (P.y < 0.) {\n        return length(P) - hh;\n    } else {\n    \n        float t = cross2(P-B, D-B);\n        if (t < 0.0) {\n            float tt = sqrt(hh *hh + d * d);\n            float rr =r - tt;\n            return distance(P, D)  - rr ;\n        } else {\n            return distance(P, B) - d - hh;\n        } \n    \n    }\n    \n}\n\n\nfloat sdf_moon(vec2 P, float r1, float r2, float d ) \n{\n    P.y = abs(P.y);\n    float a = (r1*r1 - r2*r2 + d*d)/(2.0*d);\n    float b = sqrt(max(r1*r1-a*a,0.0));\n\n    vec2 PointC = vec2(a, b);\n    vec2 PointB = vec2(d, 0.);\n    vec2 PointD = vec2(0., 0.);\n    vec2 VectorCB = PointB - PointC;\n    vec2 VectorDC = PointC - PointD;\n    vec2 VectorCP = P - PointC;\n    vec2 VectorDP = P - PointD;\n\n    float t1 = cross2(VectorCB, VectorCP);\n    float t2 = cross2(VectorDC, VectorDP);\n\n    if (t1  > 0.0 && t2 < 0.0) {\n       return distance(P,  PointC);\n    }\n    \n    return max(\n        r2 - distance(P, PointB),\n        length(P) - r1\n    );\n   \n}\n\n\nfloat sd_heart( in vec2 P, float r )\n{\n    P.x = abs(P.x);\n    vec2 PointB = vec2(0., r);\n    vec2 PointA = vec2(r, 0.0);\n    vec2 PointC = vec2(0.5*r, 0.5*r);\n    vec2 PointD = vec2(0.25 * r, 0.75 *r );\n    vec2 VectorBA = PointA - PointB;\n    vec2 VectorBP = P - PointB;\n\n    float t = cross2(VectorBA, VectorBP);\n   if (t > 0.0) {\n       return distance(P, PointD) -  0.25 * r * sqrt(2.);\n    }\n\n    float hh = clamp(dot(P, PointC) / dot(PointC, PointC), 0., 1.);\n    return min(\n      distance(P, PointB),\n      length(P-hh*PointC)\n    ) * sign(P.x-P.y);\n\n}\n\n\n\nfloat sd_vesica(vec2 P, float r, float d)\n{\n    P = abs(P);\n    vec2 PB = vec2(-d, 0.0);\n    float h = sqrt(r*r - d*d);\n    vec2 PG = vec2(0.0, h);\n    \n    return min(\n        distance(P, PB) - r,\n        distance(P, PG)\n    );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float perCol = 2.0;\n    float perRow = floor(perCol * iResolution.x / iResolution.y) ;\n    vec2 uv2 = fragCoord/iResolution.y;\n    uv2 *= perCol;\n    vec2 uv = mod(uv2, 1.);\n    // convert screen to [-1, 1] coordinate\n    uv = uv * 2.0 - 1.0;\n    \n    int idx = 0;\n    int curIdx = int(floor(uv2.x) + floor(uv2.y)*perRow) ;\n    float dist;\n    \n    if (curIdx == idx++) {\n         dist = sdf_uneven_capsule(uv, 0.4, 0.2, 0.6);\n    } else if (curIdx == idx++) {\n         float theta = PI / 4.0;\n         mat2 rotation = mat2(\n           cos(theta), sin(theta),\n           -sin(theta), cos(theta)\n         );\n         vec2 uv3 = rotation * uv;\n         dist = sdf_uneven_capsule(uv3, 0.4, 0.2, 0.6);\n\n    } else if (curIdx == idx++) {\n         dist = sdf_mossegg(uv, 0.8, 0.4);\n    }  else if (curIdx == idx++) {\n         dist = sd_vesica(uv, 0.4, 0.2);\n    }else if (curIdx == idx++) {\n        dist = sdf_moon(uv, 0.3, 0.28, 0.2);\n    } else  {\n        dist = sd_heart(uv, 0.5);\n    }\n   \n   \n    vec3 finalColor = dist > 0.0 ? OCOLOR: ICOLOR; \n    border(dist, finalColor);\n    wave(dist, finalColor);\n    grid_border(uv,0.05,finalColor);\n   \n    fragColor = vec4(finalColor, 0.); \n}","name":"Image","description":"","type":"image"}]}