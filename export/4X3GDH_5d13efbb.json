{"ver":"0.1","info":{"id":"4X3GDH","date":"1716392056","viewed":55,"name":"kissing schottky group","username":"sambrunacini","description":"kissing schottky group","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nbased on https://archive.bridgesmathart.org/2016/bridges2016-367.pdf\n*/\n\n\nvec2 complexConj(vec2 z) {\n  return vec2(z.x, -z.y);\n}\n\nfloat normSq(vec2 z) {\n  return z.x * z.x + z.y * z.y;\n}\n\nvec2 complexInv(vec2 z) {\n  return complexConj(z) / normSq(z);\n}\n\nvec2 invert(vec2 z, vec2 c, float r) {\n    return r * r * complexInv(complexConj(z) - complexConj(c)) + c;\n}\n\nfloat dsq(vec2 z1, vec2 z2) {\n    return normSq(z1 - z2);\n}\n\nconst int NUM_CIRCLES = 4;\n\nconst float[NUM_CIRCLES] R = float[](\n    1.0,\n    1.0,\n    0.25,\n    1000.0\n);\n\nconst float[NUM_CIRCLES] CX = float[](\n    -1.0,\n    1.0,\n    0.0,\n    0.0\n);\n\nconst float[NUM_CIRCLES] CY = float[] (\n    -1.0,\n    -1.0,\n    -0.25,\n    1000.0\n);\n\nconst int MAX_INVERSIONS = 30;\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    vec2 xy = 8.0 * vec2(uv.x - .5, aspect * (-.5 + uv.y));\n    \n    vec3 col = vec3(0,0,0);\n    int inversions = 0;\n    for (int i=0; i<MAX_INVERSIONS; i++) {\n        bool exterior = true;\n        for (int j=0; j<NUM_CIRCLES; j++) {\n            vec2 circCenter = vec2(CX[j], CY[j]);\n            if (dsq(circCenter, xy) <= R[j] * R[j]) {\n                xy = invert(xy, circCenter, R[j]);\n                inversions++;\n                exterior = false;\n                //col = vec3(1,0,0);\n                break;\n            }\n        }\n        if (exterior) {\n            break;\n        }\n    }\n    if (inversions > 0) {\n        col = hsv2rgb(vec3( .2 + .7*pow(1./float(MAX_INVERSIONS) * float(inversions), 0.25),0.7,1.0));\n    } else {\n        col = vec3(0,0,0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}