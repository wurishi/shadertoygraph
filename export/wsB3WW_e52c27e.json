{"ver":"0.1","info":{"id":"wsB3WW","date":"1548847794","viewed":71,"name":"Deneb42T4","username":"deneb42","description":"t","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["t"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int sceneSize = 20;\nconst float cubeSize = 0.02;\nconst float INF = 1000000.0;\nconst int maxColIdx = 3;\n\nstruct Surf {\n    vec3 diffCol;\n    bool isReflective;\n    vec3 refMulCol;\n    bool isTransparent;\n    vec3 transMulCol;\n    float refract;\n};\n    \nSurf sRefl(vec3 col, float mul) {\n    return Surf(col, true, vec3(mul), false, vec3(0), 0.0);\n}\nSurf sMatt(vec3 col) {\n    return Surf(col, false, vec3(0), false, vec3(0), 0.0);\n}\nSurf sMetal(vec3 col, float mul) {\n    return Surf(col, true, mul*col, false, vec3(0), 0.0);\n}\n\nSurf surfs[maxColIdx];\n\nvoid setSurfs() {\n\tsurfs[0] = sRefl(vec3(0.3, 0.3, 0.8), 0.3);\n\tsurfs[1] = sMatt(vec3(0.8, 0.3, 0.3));\n\tsurfs[2] = sMetal(vec3(0.3, 0.8, 0.3), 0.9);\n    \n}\n\nconst int maxLights = 3;\n\nstruct ColN {\n    int cc;\n    vec3 n;\n    float t;\n};\n    \nstruct LightInfo {\n    vec3 pos;\n    vec3 col;\n};\n\nLightInfo lights[maxLights];\n\nint lightsCount = 2;\n\nvoid fillLights() {\n    lights[0] = LightInfo(vec3(100.0*sin(iTime/1.0), 100.0*cos(iTime/1.0), 100), vec3(17000));\n    lights[2] = LightInfo(vec3(20, 10, 200), vec3(9000));\n}\n\nLightInfo getLight(int i, vec3 p) {\n    \n    if (i == 0) return LightInfo(normalize(vec3(0, 0, 1)), vec3(1, 1, 1)*0.5);\n    if (i == 1) return LightInfo(normalize(vec3(-1, -4, 0)), vec3(1, 1, 0)*0.5);\n    if (i == 2) return LightInfo(normalize(vec3(1, 1, 10)), vec3(1, 1, 1)*0.5);\n    return LightInfo(vec3(1, 0, 0), vec3(0));\n}\n\nint getCubeColIdx(vec3 p) {\n    vec3 xyz = floor(p);\n    if (any(lessThan(vec3(sceneSize), abs(xyz)))) return 0;\n    float ssf = float(sceneSize);\n    if (length(xyz) < ssf - 3.) return 3;\n    int ix = int(xyz.x);\n    int iy = int(xyz.y);\n    int iz = int(xyz.z);\n    if (ix < -sceneSize) return 0;\n    //if (iz == -1 && (((ix ^ iy) & 1) == 1)) return 3;\n    if (iz == 0 && (ix)*(iy) == 0 || ix == 0 && iy == 0) return 1;\n    if (iz == 0 && int(round(length(vec2(ix, iy)))) == sceneSize - 1) return 2;\n    return 0;\n}\n\n// return t0, t1, dt\nvec3 getTdt(float d, float p, float maxt) {\n    float dt = 1./d;\n    if (dt > 0.) {\n\t    float minI = max(float(-sceneSize - 1), ceil(p));\n    \tfloat maxI = min(float(sceneSize + 1), ceil((maxt*d + p)));\n    \t//float maxI = float(sceneSize + 1);\n        return vec3((minI - p)*dt, (maxI - p)*dt, dt);\n    } else {\n\t    float minI = max(float(-sceneSize - 1), floor((maxt*d + p)));\n    \tfloat maxI = min(float(sceneSize + 1), ceil(p));\n    \t//float maxI = float(sceneSize + 1);\n        return vec3((maxI - p)*dt, (minI - p)*dt, -dt);\n    }\n}\n\nColN getSideColN(float d, float p, float maxt, vec3 dv, vec3 pv, vec3 nv) {\n    if (abs(d) > 0.0001) {\n        vec3 n = nv*(d < 0.0 ? 1. : -1.);\n        vec3 n2 = n/2.;\n        vec3 tdt = getTdt(d, p, maxt);\n        float dt = tdt.b;\n        vec3 dp = dv*dt;\n        float t0 = tdt.r;\n        if (t0 < 0.) { t0 += dt; }\n        vec3 pp = dv*t0 + pv - n2;\n        for (float t = t0; t < tdt.g; t += dt) {\n            //if (t < 0.) continue;\n            int col = getCubeColIdx(pp);\n            if (col > 0) {\n\t            //float tt = (round(d*t + p) - p)/d;\n                return ColN(col, n, t);\n            }\n            pp += dp;\n        }\n    }\n    return ColN(0, vec3(0), maxt);\n}\n\nColN getCubeColN(vec3 d, vec3 p) {\n    vec3 pp = p/cubeSize;\n    vec3 dd = d/cubeSize;\n    float tt = INF;\n    int cc = 0;\n    vec3 n = vec3(0);\n\n    ColN xColN = getSideColN(dd.x, pp.x, INF, dd, pp, vec3(1, 0, 0));\n    ColN yColN = getSideColN(dd.y, pp.y, xColN.t, dd, pp, vec3(0, 1, 0));\n    ColN zColN = getSideColN(dd.z, pp.z, yColN.t, dd, pp, vec3(0, 0, 1));\n    ColN res = ColN(0, vec3(0), INF);\n    if (xColN.t > 0. && xColN.t < res.t) res = xColN;\n    if (yColN.t > 0. && yColN.t < res.t) res = yColN;\n    if (zColN.t > 0. && zColN.t < res.t) res = zColN;\n    return res;\n}\n\nstruct SubCall {\n    bool use;\n    vec3 d;\n    vec3 p;\n    vec3 mulCol;\n};\n    \nconst int maxSubs = 2;\n\nstruct ColRes {\n\tvec3 addCol;\n    SubCall sub1;\n    SubCall sub2;\n};\n\nconst SubCall noCall = SubCall(false, vec3(0), vec3(0), vec3(0));\n\nColRes getCol(vec3 d, vec3 p) {\n\tColN cubes = getCubeColN(d, p);\n    if (cubes.cc > 0) {\n        Surf surf = surfs[cubes.cc - 1];\n        vec3 resCol = vec3(0);\n    \tvec3 np = p + (cubes.t - 0.0001)*d;\n        for (int i = 0; i < lightsCount; i++) {\n            LightInfo li = lights[i];\n            vec3 liDir = li.pos - np;\n            ColN cc = getCubeColN(liDir, np);\n            if (cc.cc == 0) {\n            \tfloat liDist = length(liDir);\n            \tfloat diff = clamp(dot(cubes.n, liDir/liDist)/liDist/liDist, 0.0, 1.0);\n            \tresCol += surf.diffCol*li.col*diff;\n            }\n        }\n        SubCall sub1 = noCall;\n        if (surf.isReflective) {\n\t        vec3 nd = d - 2.0*dot(d, cubes.n)*cubes.n;\n        \tsub1 = SubCall(true, nd, np, surf.refMulCol);\n        }\n        return ColRes(resCol, sub1, noCall);\n    }\n\n    if (abs(d.z) > 0.01) {\n        float z0 = -1.0;\n\n        float t0 = (z0-p.z)/d.z;\n\n        if (t0 > 0.0) {\n            vec3 pt = p + d*t0;\n            vec2 txy = pt.xy*0.2;\n            vec4 tc = texture(iChannel0, txy);\n            vec3 col = vec3(0);\n            for (int i = 0; i < lightsCount; i++) {\n                LightInfo li = lights[i]; //getLight(i, pt);\n                ColN cc = getCubeColN(li.pos - pt, pt);\n                if (cc.cc == 0) {\n                    vec3 liDir = li.pos - pt;\n                    float liDist = length(liDir);\n                    col += li.col/liDist/liDist*tc.xyz*0.5;\n                }\n            }\n            return ColRes(col, noCall, noCall);\n        }\n    }\n    vec4 back = texture(iChannel1, d.yzx);\n    return ColRes(back.xyz, noCall, noCall);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float m = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - iResolution.xy/2.0)*2.0/m;\n    setSurfs();\n    fillLights();\n\n    vec3 camPos = vec3(cos(iTime*0.1), sin(iTime*0.1), 0.1 + sin(iTime*0.4));\n    vec3 camUp0 = vec3(0, 0, 1);\n    vec3 camDir = normalize(-camPos);\n    vec3 camRight = normalize(cross(camDir, camUp0));\n    vec3 camUp = cross(camDir, camRight);\n    \n    vec3 dir = camDir*1.9 + camRight*uv.x - camUp*uv.y;\n    \n    \n    vec3 mulCol = vec3(1);\n    vec3 d = dir;\n    vec3 p = camPos;\n    vec3 resCol = vec3(0);\n    for (int i = 0; i < 3; i++) {\n\t    ColRes res = getCol(d, p);\n        resCol += res.addCol*mulCol;\n        if (!res.sub1.use) break;\n        mulCol = mulCol*res.sub1.mulCol;\n        d = res.sub1.d;\n        p = res.sub1.p;\n    }\n    // Output to screen\n    fragColor = vec4(resCol, 1);\n}","name":"Image","description":"","type":"image"}]}