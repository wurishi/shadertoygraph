{"ver":"0.1","info":{"id":"ssB3zG","date":"1617562276","viewed":43,"name":"Light source 2","username":"donorman","description":"Small test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tracing","rasterbar"],"hasliked":0,"parentid":"NdsGD7","parentname":"Light source works"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float EPSILON=1e-3;\n\nstruct Circle {\n    vec2 Center;\n    float R;\n    vec3 Color;\n};\n\nstruct Light {\n    vec2 Origin;\n    vec3 Color;\n};\n\nstruct Ray {\n    vec2 Origin;\n    vec2 Dir;\n};\n\nvec2 Eye;\nCircle circles[3];\nLight light;\n\nvoid init_scene() {\n    Eye = vec2(-3000,180);\n    circles[0] = Circle(vec2(40,180), 70.0, vec3(1.0, 0.2, 0.5));\n    circles[1] = Circle(vec2(50,350), 30.0, vec3(0.2, 1.0, 0.5));\n    circles[2] = Circle(vec2(50,200), 40.0, vec3(0.2, 0.5, 1.0));\n    \n    light = Light(vec2(-400.0,iResolution.y*.5),vec3(1.0,1.0,1.0));\n}\n\n\nbool intersection(in Ray R, in Circle C, out float t) {\n    vec2 CO = R.Origin - C.Center;\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.0*dot(R.Dir, CO);\n    float c = dot(CO, CO) - C.R*C.R;\n    float delta = b*b - 4.0*a*c;\n    if(delta < 0.0) {\n        return false;\n    }\n    t =  (-b-sqrt(delta)) / (2.0*a) ;\n    return true;\n}\n\nvec3 trace(Ray R, int ctr) {\n    float t;\n    float minT = 100000.0;\n    int c = -1;\n    for(int i=0; i<circles.length(); i++) {\n        if(intersection(R, circles[i], t) && t < minT) {\n            minT = t;\n            c = i;\n        }\n    }\n    if(minT == 10000.0) {\n        //no object hit by ray\n        return vec3(0.0,0.0,0.0);\n    }\n    vec2 P = R.Origin + minT*R.Dir;\n    vec2 N = normalize(P - circles[c].Center);\n    vec2 E = R.Origin - P;\n    //calc angle for diffuse lightning\n    float diff = max(0.0, dot(E,N) / length(E)); //length of N = 1.\n    //calc angle for specular lightning\n    \n    vec2 L = light.Origin - P;\n    \n    \n    //test shadow ray\n    bool inShade = false;\n    Ray Rs = Ray(P, normalize(L));\n    for(int i=0; i<circles.length(); i++) {\n        if(intersection(Rs, circles[i], t) && t > EPSILON) {\n            inShade = true;\n            //break;\n        }\n    }\n    \n    float spec = 0.0;\n    if(inShade == false) \n    {\n        spec = max(0.0, dot(E,L) / (length(E)*length(L)) );\n    }\n    \n    \n    \n    \n    float specDist = 200.0/length(L); //can be optimized length(L) calc 3 times\n    \n    //add up the colors\n    vec3 color = 1.0*diff*circles[c].Color + 0.7*specDist*pow(spec,1080.0)*light.Color;\n    //add distance factor\n    color = color*3000.0/minT;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_scene();\n    \n    float scrHeight = iResolution.y;\n    \n    circles[0].Center.y = scrHeight*0.5 + scrHeight*0.25*cos(1.0*iTime);\n    circles[0].Center.x = 2000.0 + 2000.0*sin(2.0*iTime);\n\n    circles[1].Center.y = scrHeight*0.5 + scrHeight*0.25*sin(1.0*iTime);\n    circles[1].Center.x = 500.0 + 400.0*cos(1.0*iTime);\n    \n    circles[2].Center.y = scrHeight*0.5 + scrHeight*0.25*cos(.8*iTime);\n    circles[2].Center.x = 2000.0 + 2000.0*sin(.8*iTime);\n    \n    //light.Origin.y = 200.0 + 200.0*sin(0.1*iTime);\n\n   \n    Ray R = Ray(Eye, normalize(vec2(0, fragCoord.y) - Eye));\n    \n    vec3 color = trace(R,0);\n    fragColor = vec4(color,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}