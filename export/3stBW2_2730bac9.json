{"ver":"0.1","info":{"id":"3stBW2","date":"1606023771","viewed":97,"name":"truchasbulb","username":"dcxstephen","description":"it's a mandelbulb... for now","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marching parameters\nconst int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 40.0;\nconst float EPSILON = 0.001; // closest you get to the surface\nconst bool USE_ORBIT = true;\n\n/*\nTODO Test values for BAILOUT\nTODO Get shadows and better colors\nTODO Movement of camera\nTODO Camera zoom\nTODO Colors and  shadows (orbit coloring)\nTODO cync it to music, music with a beat, and the mandelbulb shrinks / grows with beat (or just the view)\nTODO other shapes\n*/\n\nconst float BAILOUT = 16.0; // Distance at which mandelbulb will diverge\nconst int MAX_ITER = 50;//100; // for generating the mandelbulb\nconst float BULB_DEGREE = 8.0; // this is the typical one used\nconst float PI = 3.1415926535;\n\nstruct paletteConfig {\n\tvec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n};\n\n// cosine based palette, 4 vec3 params\n// https://iquilezles.org/articles/palettes\nvec3 palette(float t, paletteConfig p) {\n    return p.a + p.b*cos(6.28318*(p.c*t+p.d) );\n}\n\n// Constructive Solid Geometry (CSG) operations\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// SDF (sign distance function) for a sphere centered at the origin\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n// estimates distance to mandelbulb\nvec2 mandelbulbDF(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\n    // Used to color fractal\n    // Tracks the minimum distance from orbitCenter (arbitrary point)\n    float minOrbitDist = 256.0;\n    int orbit = 0;\n\n\tfor (int i = 0; i < MAX_ITER ; i++) {\n\t\tr = length(z);\n        orbit = i;\n\n        // r is diverging\n\t\tif (r>BAILOUT) break;\n\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\n\n        // Next term in Mandelbrot iteration \n\t\tdr = pow(r, BULB_DEGREE-1.0)*BULB_DEGREE*dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, BULB_DEGREE);\n\t\ttheta = theta*BULB_DEGREE;\n\t\tphi = phi*BULB_DEGREE;\n\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n    // x: distance\n    // y: orbit (used for color)\n    return vec2(0.5*log(r)*r/dr, orbit);\n}\n\n// distance function (0 inside +ive outside)\n//float sphereSDF(vec3 p,)\n\n// Absolute of the return value is distance to surface\n// Sign indicates if point is inside (-) or outside (+) surface\nvec2 sceneSDF(vec3 p) {\n    //float sA = sphereSDF((p)-vec3(-3,0,0) / 1.2, 1.0) * 1.2;\n    //float sB = sphereSDF((p)-vec3(3,0,0) / 1.2, 1.0) * 1.2;\n    //return unionSDF(sA, sB);\n    return mandelbulbDF(p);\n}\n\n// Return shortest distance from the eye to the scene surface along ray\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection,\n                                float initialDepth, float maxDepth) {\n    float depth = initialDepth;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // dist is distance from surface\n        // Negative dist indicates surface intersection\n        vec2 dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist.x < EPSILON) {\n            return vec2(depth, dist.y);\n        }\n        depth += dist.x;\n        if (depth >= maxDepth) {\n            return vec2(maxDepth, 0);\n        }\n    }\n    return vec2(maxDepth, 0);\n}\n\n\n// Return normalized direction to march in from the\n// eye point for a single pixel\nvec3 getRayDirection(float fov, vec2 resolution, vec2 fragCoord) {\n    // Move origin from bottom left to center of screen\n    vec2 xy = fragCoord - resolution / 2.0;\n\n    // Get the z-distance from pixel given resolution\n    // and vertical FoV (field of view)\n    // Diagram shows that:\n    // tan(radians(fov)/2) == (resolution.y * 0.5) / z\n    // Diagram: https://stackoverflow.com/a/10018680\n    // Isolating for z gives\n    float z = (resolution.y * 0.5) / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// eye: looking from\n// center: looking at\nmat4 getLookAtMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye); // f is the direction you are looking\n    vec3 s = normalize(cross(f, up)); // s is to the right, if up is (kindof) the direction that's up\n    vec3 u = cross(s, f); // u is the 'real' up\n\n    return mat4(vec4(s, 0),\n                vec4(u, 0),\n                vec4(-f, 0),\n                vec4(0, 0, 0, 1)); // 'fourth componant is just used for perspective divide'\n}\n\nvec3 getNormal(vec3 p) {\n    // compute the gradient\n    float eps = EPSILON*0.1;\n    vec3 px = p + vec3(eps,0,0);\n    vec3 py = p + vec3(0,eps,0);\n    vec3 pz = p + vec3(0,0,eps);\n    float f = sceneSDF(p).x;\n    float fx = sceneSDF(px).x;\n    float fy = sceneSDF(py).x;\n    float fz = sceneSDF(pz).x;\n    vec3 normal = normalize(vec3((fx - f)/eps , (fy - f)/eps , (fz - f)/eps));\n    return normal;\n}\n\nvec3 sphericalToCartesian(vec3 rthetaphi){\n    float r=rthetaphi[0];\n    float theta=rthetaphi[1];\n    float phi=rthetaphi[2];\n    return vec3(r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta));\n}\n\nvec3 addLighting(vec3 p, vec3 color) {\n    vec3 lightSource = vec3(0,0,5); //\n    vec3 lightDir = normalize(lightSource-p);\n    vec3 normal = getNormal(p);\n    float dotp = max(0.1,abs(dot(lightDir, normal)));// the abs value makes two lights at z axis\n    vec3 newColor = color * dotp;\n\n    return newColor;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 resolution = iResolution.xy;\n\n    // Define position of observer\n    // spherical coordinates\n\n    //float r = max(1.6, 4.0-iTime*0.1);\n    //float theta = 0.02*PI*iTime; // from 0 to PI\n    //float phi = 0.0; // from 0 to 2 PI\n    \n    float r = 1.8;\n    float theta = iMouse.xy[0]*(3.14/400.0);\n    float phi = iMouse.xy[1]*(3.14/225.0);\n    \n    vec3 eye = sphericalToCartesian(vec3(r,theta,phi));\n\n    // Shoot a ray from the eye through each pixel\n    // Get the direction of that ray\n    vec3 viewDir = getRayDirection(45.0, resolution, gl_FragCoord.xy);\n\n    // Transform from view to world space\n    // TODO Review this\n    mat4 viewToWorld = getLookAtMatrix(eye, vec3(0), vec3(0, 1, 0));\n    vec3 worldDir    = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n    // Return shortest distance from the eye to the scene surface along ray\n    vec2 dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    // Didn't hit anything\n    if (dist.x > MAX_DIST) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    // Point of intersection of view ray with surface\n    vec3 p = eye + dist.x * worldDir;\n\n    // Procedural color palette parameters\n    paletteConfig pc;\n    pc.a = vec3(0.5, 0.5, 0.5);\n    pc.b = vec3(0.5, 0.5, 0.5);\n    pc.c = vec3(2.0, 1.0, 0.0);\n    pc.d = vec3(0.50, 0.20, 0.25);\n\n    vec3 outColor = palette(dist.y*0.1, pc);\n    if (dist.x < 16.0) {\n        outColor = addLighting(p, outColor);\n    }\n\n    if (dist.x >= BAILOUT) {\n        outColor = vec3(0.0);\n    }\n    //outColor = vec3(dist.y*0.1);\n\n    fragColor = vec4(outColor, 1);\n}\n","name":"Image","description":"","type":"image"}]}