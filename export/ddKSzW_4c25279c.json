{"ver":"0.1","info":{"id":"ddKSzW","date":"1680804773","viewed":87,"name":"\"cool tech polygons\" by Bing AI","username":"mrhyde","description":"\"cool tech polygons\" by Bing AI, and i have no idea about how to write a shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bingai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A shader that draws some cool tech polygons on WebGL 2.0 with functions outside of the void mainImage, rotation, lighting, animation and wave post effect\n\n// A function that returns the distance to a polygon with n sides\nfloat polygon(vec2 p, float n, float r)\n{\n    float a = atan(p.x,p.y);\n    float b = 6.28318/n;\n    return length(p)-r*cos(floor(0.5+a/b)*b-a);\n}\n\n// A function that returns the distance to a grid of polygons\nfloat grid(vec2 p, float n, float r, float s)\n{\n    vec2 q = mod(p,s)-0.5*s;\n    return polygon(q,n,r);\n}\n\n// A function that returns the color of a pixel based on the distance to a grid of polygons and a lighting effect\nvec3 gridColor(vec2 p, float n, float r, float s, vec3 col)\n{\n    // Distance to the grid\n    float d = grid(p,n,r,s);\n\n    // Normal vector\n    vec2 norm = normalize(vec2(d - grid(p + vec2(0.01, 0), n, r, s), d - grid(p + vec2(0, 0.01), n, r, s))); // changed n to norm\n\n    // Light direction\n    vec2 l = normalize(vec2(0.5, 0.5));\n\n    // Diffuse lighting\n    float diff = max(dot(norm, l), 0.0); // changed n to norm\n\n    // Specular lighting\n    vec2 v = normalize(-p); // view direction\n    vec2 h = normalize(l + v); // halfway vector\n    float spec = pow(max(dot(norm, h), 0.0), 32.0); // changed n to norm\n\n    // Ambient lighting\n    float amb = 0.1;\n\n    // Final color\n    return (amb + diff) * col + spec * vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Rotation angle\n    float angle = iTime*0.1;\n\n    // Rotation matrix\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // Animation factor\n    float t = sin(iTime*0.20)*0.5+0.5;\n\n    // Wave effect\n    uv += sin(uv.yx*10.0+iTime)*0.05;\n\n    // Output to screen\n    fragColor = vec4(gridColor(rot*uv*20.0,mix(3.0,9.0,t),mix(0.1,0.9,t),1.0,col),1.0); // applied rotation matrix to uv and added lighting effect and animation effect and wave effect\n}","name":"Image","description":"","type":"image"}]}