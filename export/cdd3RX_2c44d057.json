{"ver":"0.1","info":{"id":"cdd3RX","date":"1681416398","viewed":106,"name":"Warped perlin noise animated","username":"Sergio_2357","description":"Generative warped perlin noise experiment","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["generative"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuint hash(uint s) {\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat Fade(float t) {\n\treturn smoothstep(0.0, 1.0, t);\n}\n\nfloat Lerp(float t, float a, float b) {\n    return a + t*(b-a);\n}\n\nfloat lerp(float a, float b, float f) {\n    return (1.0-f)*a + f*b;\n}\n\nconst float ROTATION_SPEED = 1.7;\nvec2 getGradient(vec2 p) {\n    float deg = random(p)*8. + iTime*ROTATION_SPEED*(random(p)*.5+.5);\n    vec2 grd = vec2(cos(deg), sin(deg));\n    return grd;\n}\n\nfloat perlinNoise(vec2 ps) {\n    vec2 pi = floor(ps);\n    vec2 pf = fract(ps);\n    \n    vec2 u = pf * pf * (3.0 - 2.0 * pf);\n    //vec2 u = pf;\n    \n    vec2 llp = pi;\n    vec2 llv = getGradient(llp);\n    vec2 hlp = pi + vec2(0.0, 1.0);\n    vec2 hlv = getGradient(hlp);\n    vec2 lrp = pi + vec2(1.0, 0.0);\n    vec2 lrv = getGradient(lrp);\n    vec2 hrp = pi + vec2(1.0, 1.0);\n    vec2 hrv = getGradient(hrp);\n    \n    float ll = dot(llv, (ps-llp));\n    float lr = dot(lrv, (ps-lrp));\n    float hl = dot(hlv, (ps-hlp));\n    float hr = dot(hrv, (ps-hrp));\n    \n    float l = lerp(ll, lr, u.x);\n    float h = lerp(hl, hr, u.x);\n    \n    float v = lerp(l, h, u.y);\n    \n    \n    v = v*0.5+0.5;\n    return v;\n}\n\nfloat fractalPerlinNoise(vec2 p) {\n    int steps = 3;\n    float val = perlinNoise(p);\n    float sig = 0.4;\n    float sigmlt = 0.4;\n    float scale = 2.0;\n    float scalemlt = 2.0;\n    for (int i = 0; i < steps; i++) {\n        val = val*(1.0-sig)+sig*perlinNoise(p*scale);\n        sig *= sigmlt;\n        scale *= scalemlt;\n    }\n    return val;\n}\n\nfloat warpedPerlinNoise(vec2 p) {\n    float deg = fractalPerlinNoise(p+vec2(-iTime/1.0));\n    float cs = cos(deg);\n    float sn = sin(deg);\n    mat2 rot = mat2(cs, -sn, sn, cs);\n    int steps = 2;\n    float mlt = 4.0;\n    vec2 add = vec2(0.0, 0.0);\n    vec2 inc = vec2(5.2, 6.2);\n    vec2 mv = vec2(0, 0);\n    for (int i = 0; i < steps; i++) {\n        vec2 tmp = mv;\n        mv.x = fractalPerlinNoise(p + rot*mv*mlt + add);\n        add += inc;\n        mv.y = fractalPerlinNoise(p + rot*mv*mlt + add);\n        add += inc;\n    }\n    return mv.x;\n}\n\nvec4 colFromGreyscale(float f) {\n    vec4 col0 = vec4(0.7, 0.0, 0.0, 1.0);\n    vec4 col1 = vec4(1.3, 1.0, 0.0, 1.0);\n    vec4 res = col0*f+(1.0-f)*col1;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= 20.0;\n    uv.y *= 10.0;\n    uv += vec2(35.0, 35.0);\n    \n    // Time varying pixel color\n    float col = warpedPerlinNoise(uv+vec2(iTime*0.0));\n\n    // Output to screen\n    fragColor = colFromGreyscale(col);\n}","name":"Image","description":"","type":"image"}]}