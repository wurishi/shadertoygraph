{"ver":"0.1","info":{"id":"DlsGzS","date":"1671947750","viewed":67,"name":"tut8","username":"jfwf","description":"study test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tut8"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS=255;\nconst float MIN_DIST=0.0;\nconst float MAX_DIST=100.0;\nconst float PRECISION=0.001;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nstruct Surface \n{\n    float sd;//signed distance\n    vec3 color;\n};\n\nSurface sdCube(vec3 p,vec3 b,vec3 offset,vec3 col,mat3 transform)\n{\n    p= (p-offset)*transform - vec3(3.0,0.,0.);\n    vec3 q = abs(p)-b;\n    float d=length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) ;\n    return Surface(d,col);\n}\n\n\nSurface sdFloor(vec3 p,vec3 col)\n{\n    Surface sur;\n    sur.sd = p.y - (-1.0) ;\n    sur.color=col;\n    return sur;\n}\n\nSurface minWithColor(Surface s1,Surface s2)\n{\n    if(s1.sd>s2.sd) \n    {\n        return s2;\n    }\n    return s1;\n}\n\nSurface sdScene(vec3 p)\n{\n    vec3 floorColor=vec3( 0.7*mod(floor(p.x)+floor(p.z),2.0) ) ;\n    Surface result = sdFloor( p, floorColor ) ;\n    \n    Surface cube=sdCube(p,vec3(1.0),vec3(0,0.5,-4),vec3(1.0,0.0,0.0), rotateY(iTime) ) ;\n    \n    result = minWithColor(result,cube);\n    \n    return result;\n}\n\nSurface rayMarching(vec3 ro,vec3 rd,float start,float end)\n{\n    float depth = start ;\n    Surface outsur ;\n    for(int i = 0 ; i<MAX_STEPS;++i )\n    {\n        vec3 p = ro + rd*depth;\n        outsur = sdScene(p) ;\n        depth += outsur.sd ;\n        if(depth>end||outsur.sd<PRECISION) break;\n        \n    }\n    outsur.sd = depth ;\n    return outsur;\n}\n\nvec3 calcNormal( vec3 p )\n{\n    vec2 e=vec2(1.0,-1.0)*0.0005 ;\n    return normalize( \n        e.xyy*sdScene(p+e.xyy).sd +\n        e.yyx*sdScene(p+e.yyx).sd +\n        e.yxy*sdScene(p+e.yxy).sd +\n        e.xxx*sdScene(p+e.xxx).sd) ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy ;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y ;\n    \n    vec3 bgcolor=vec3(0.835,1.0,1.0);\n    vec3 col=vec3(0.0);\n    vec3 ro=vec3(0.0,0.0,3.0);\n    vec3 rd=normalize( vec3(uv,-1) ) ;\n    \n    rd*=rotateX(0.3);\n    \n    Surface sur=rayMarching( ro, rd, MIN_DIST, MAX_DIST ) ;\n    if( sur.sd > MAX_DIST )\n    {\n        col=bgcolor;\n    }else{\n        vec3 p = ro + rd * sur.sd ;\n        vec3 norm = calcNormal(p);\n        vec3 lightPos = vec3(2.0,2.0,7.0) ;\n        vec3 lightDir = normalize( lightPos - p ) ;\n        float dif=clamp( dot(lightDir,norm), 0.3,1.0);\n        col=dif*sur.color+bgcolor*0.2 ;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}