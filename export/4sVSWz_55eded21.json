{"ver":"0.1","info":{"id":"4sVSWz","date":"1463908055","viewed":1184,"name":"perspective transformation","username":"PeterVivo","description":"correct glsl affine texture mapping\n.. under develop\ndrag closest corner\n","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["interactive","inverse","interpolation","bilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CHESS_SCALE 3.0\n#define RND_OPACITY false\n#define USE_CHANNEL0 true\n#define isSETUP iFrame == 0\n#define rnd hash3( iTime )\n\n#define L(a,b)  fragColor.g+= 2e-1 / length( clamp( dot( fragCoord-a,v=b-a)/dot(v,v), 0.,1.) *v - fragCoord+a )\n\n// implement PhotoShop perspective transformation like interaction .. under develop\n\n// fork :: https://www.shadertoy.com/view/lsBSDm\n\n\t// Created by inigo quilez - iq/2014\n\t// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t// https://iquilezles.org/articles/ibilinear\n\n// uniform samplerXX iChannel0\n// codepen version :: http://codepen.io/Omrega/pen/ONYpRb?editors=0010\n\n#define ASPECT iResolution.x / iResolution.y; \n\n// default position\n\n#define startA vec2(  1.2 ,  0.9 )\n#define startB vec2(  1.1 , -0.8 )\n#define startC vec2( -1.1 , -0.7 )\n#define startD vec2( -0.3 ,  0.8 )\n\n\nvec2 a = startB;    \nvec2 b = startC;    \nvec2 c = startD;\nvec2 d = startA;\n\n\nfloat ccross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\n\n//vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\nvec2 invBilinear( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = ccross( g, f );\n    float k1 = ccross( e, f ) + ccross( h, g );\n    float k0 = ccross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)/(2.0*k2);\n    float v2 = (-k1 + w)/(2.0*k2);\n    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// random\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n// fork :: https://www.shadertoy.com/view/4ljSW1.comments --  chessboard texture \nfloat chessboard(vec2 uv)\n{\n    uv = floor(uv*2.0); \n    return mod(uv.x+uv.y, 2.0);\n}\n\n// fork :: https://www.shadertoy.com/view/4tXGWN\nfloat IGN(vec2 p)\n{\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract( magic.z * fract(dot(p,magic.xy)) );\n}\n\nvec2 center( vec2 v )\n{\n    v = ( v - 0.5 ) * 2.0;\n    v.x *= ASPECT; \n    return v;    \n}    \n\nbool closest( vec2 a , vec2 b , vec2 c , vec2 d , vec2 mou  )\n{\n   return distance(a,mou)<distance(b,mou) && distance(a,mou)<distance(c,mou) && distance(a,mou)<distance(d,mou);\n}    \n\nvec3 rcolor;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    // background\n    vec3 col = vec3( 0.7 );\n    \n    vec2 mou = iMouse.xy / iResolution.xy; \n    mou = center( mou );  \n        \n    // http://wiki.lwjgl.org/wiki/GLSL_Tutorial:_Syntax\n    // http://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html\n    \n    if( closest( a,b,c,d,mou ) ){ a = mou; }\n    if( closest( b,a,c,d,mou ) ){ b = mou; }\n    if( closest( c,b,a,d,mou ) ){ c = mou; }\n    if( closest( d,b,c,a,mou ) ){ d = mou; }\n\n    // area of the quad\n    vec2 uv = invBilinear( p, a, b, c, d );\n    \n    \n    //if( uv.x>-0.5 )\n\tif( uv.x>-0.5 /* random pixel opacity */ && ( !RND_OPACITY || hash3( p.x + p.y * ( iMouse.x + 0.3 ) ).x > .7 ) )\t\n    {\n        col = ( USE_CHANNEL0 ) ? texture( iChannel0 , uv ).xyz : vec3( chessboard( uv * CHESS_SCALE ));\n    }\n    \n    // vec3 rcolor = vec3( 0.8 );\n \n    /*\t\n    // RAM - isin't work at moment     \n    int RAM = int( iResolution.x * fragCoord.y + fragCoord.x );\n\n    // RAM test \n    // if( RAM < 55000 ){ col -= rnd / 5.0 ; }\n    \n    \n    if( RAM < 5000 )\n    {        \n\t\tif( iFrame < 1 )\n        {    \n            fragColor.rgb = rnd;\n            col = fragColor.rgb; \n        }            \n\n        // rcolor = fragColor.rgb;        \n        \n    }\n\t*/\n    \n    fragColor = vec4( col  , 1.0 );\n    \n    /*\n    vec2 v;\n    vec2 R = iResolution.xy / 4.;\n    \n    L( (a*R) , (b*R) );\n    L( (b*R) , (c*R) );\n    L( (c*R) , (d*R) );\n    L( (d*R) , (a*R) );    \n\t*/\n    \n}\n\n// remember click position:  https://www.shadertoy.com/view/Mss3zH\n\n","name":"Image","description":"","type":"image"}]}