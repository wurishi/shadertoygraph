{"ver":"0.1","info":{"id":"4Xf3z2","date":"1728380365","viewed":14,"name":"Fork Raymarching 01","username":"DynameshDude","description":"Learning raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"XXfGD7","parentname":"RaymarchingTuto"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Sphere funtion\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n//BoxFunction\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//SmoothFunction\nfloat smin (float a, float b, float k)\n{\n    float h = max(k-abs(a-b), .5)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\n//RotationFunction\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\n//Cosine based palette function, 4 vec3 params\nvec3 palette(float t)\n\n{\n    vec3 a = vec3(.5, .5, .5);\n    vec3 b = vec3(.8, .5, .5);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(.8, .6, .5);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat map(vec3 Point)\n{\n    vec3 SpherePos = vec3(0., 0 , sin(iTime)* 1.);\n    float Sphere = sdSphere(Point - SpherePos, .8);\n    \n    \n    vec3 q = Point;\n    //Whatever axis you omit, it will rotate by that axis\n    q.xy *= rot2D(iTime);\n    \n    //Foward movement\n    Point.z += iTime * .4;\n    \n    //Space repetition\n    q = fract(Point) - .5;\n    \n    \n    //Multiplying the point by a value distorts the shape. Divide the output to reduce artifacts\n    //float Box = sdBox(Point* 1., vec3(.75))/ 4.;\n                            //Scaling cube size\n    float Box = sdBox(q, vec3(.05));\n    \n    //Adding the ground for blending //Positive value determine how much we push the ground down\n    float Ground = Point.z + 1.;\n    \n    return smin(Ground, smin(Sphere, Box, 5.5), 1.);\n \n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =(fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 Mouse =(iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    \n    //Intialization\n    // Ray origin\n    vec3 RayOrigin = vec3(0, 0, -4);\n    \n    // Ray direction    //This will allow us to control the perspective\n    vec3 RayDirection = normalize(vec3(uv * .9, 1));\n    // Pixel colour\n    vec3 Colour = vec3(0);\n    \n    // Total distance travelled\n    float TotalDistance = 0.;\n    \n    \n    //Vertical camera rotation\n    //RayOrigin.yz *= rot2D(-Mouse.x);\n    //RayDirection.yz *= rot2D(-Mouse.x);\n                                            //Order of operations is VERY important in Raymarching\n    //Horizontal camera rotation\n    RayOrigin.xz *= rot2D(-Mouse.x);\n    RayDirection.xz *= rot2D(-Mouse.x);\n    \n    \n    \n    \n    int i;\n    for (int i = 0; i < 85; i++)\n    {\n        // Raymarching\n        vec3 Point = RayOrigin + RayDirection * TotalDistance;\n        \n        //Wiggle the ray\n        Point.y += sin(TotalDistance)* .1;\n\n        // Current distance\n        float Distance = map(Point);\n\n        TotalDistance += Distance;\n        \n        // Breaks so the GPU doesn't calculator more than it needs to\n        if (Distance < .001) break;\n        if (TotalDistance > 100.) break;\n    }\n    \n   //Colour = palette(TotalDistance *.1);\n   Colour = palette(TotalDistance* .04 + float(i)* .005);\n    \n    \n        \n    \n    // Output to screen\n    fragColor = vec4(Colour, 1);\n}","name":"Image","description":"","type":"image"}]}