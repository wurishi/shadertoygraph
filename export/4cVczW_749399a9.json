{"ver":"0.1","info":{"id":"4cVczW","date":"1731638482","viewed":16,"name":"intro7_raymarching","username":"deformanic","description":"intro7_cam","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","camera","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst int MAX_MARCHING_STEPS = 55;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float PRECISION = 0.01;\nconst float EPSILON = 0.005;\nconst float PI = 3.14;\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nstruct Surface {\n    float sd; // sdVal\n    vec3 col; // color\n};\n\n\nSurface minSurface(Surface objA, Surface objB) {\n  if (objB.sd < objA.sd) return objB;\n  return objA;\n}\n\n\n//obkects\nSurface sdBox( vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform)\n{\n  p = (p - offset) * transform; \n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\n\nSurface sdSphere(vec3 p, float radius , vec3 offset , vec3 col, mat3 transform ) {\n    p = (p - offset) * transform; \n    float d = length(p) - radius; \n    return Surface(d, col);\n}\n\n\nSurface sdTorus(vec3 p, float radius , float tickness , vec3 offset , vec3 col, mat3 transform ) {\n    p = (p - offset) * transform; \n    vec2 q = vec2(length(p.xz)-radius,p.y);\n    float d = length(q)-tickness;\n    return Surface(d, col);\n}\n\n\n\n\n\n\n// Function to define the scene\nSurface sdScene(vec3 p) {\n    vec3 boxA_Size = vec3(.5, 2, .5);\n    vec3 boxA_Position = vec3(-2, 0.5, 0);\n    vec3 boxA_Color = vec3(0, 0, 1); // Blue color\n    mat3 boxA_Rotation = rotateY(iTime*-2.0); \n\n    vec3 boxB_Size = vec3(.5);\n    vec3 boxB_Position = vec3(2, 0.5, 0);\n    vec3 boxB_Color = vec3(1, 0, 1); \n    mat3 boxB_Rotation = rotateX(iTime*-2.0); \n\n    vec3 sphereA_Position = vec3(0, ((sin(iTime)*.5)+.5), 0);\n    float sphereA_Radius = .5;\n    vec3 sphereA_Color = vec3(.5, .5, 0.0); \n    mat3 sphereA_Rotation = rotateX(.0); \n\n    vec3 torus_A_Position = vec3(0, 0.5, 0);\n    float torus_A_radius =1.2;\n    float torus_A_tickness =.25;\n    vec3 torus_A_Color = vec3(0, 1, 0); \n    mat3 torus_A_Rotation = rotateX(iTime); \n\n\n    vec3 floorColor = vec3(1. + 0.7 * mod(floor(p.x) + floor(p.z), 2.0));\n    Surface co = sdFloor(p, floorColor);\n    co = minSurface(co, sdBox(p, boxA_Size, boxA_Position, boxA_Color, boxA_Rotation));\n    co = minSurface(co, sdBox(p, boxB_Size, boxB_Position, boxB_Color, boxB_Rotation));\n    co = minSurface(co, sdSphere( p, sphereA_Radius , sphereA_Position , sphereA_Color, sphereA_Rotation ));\n    co = minSurface(co, sdTorus( p, torus_A_radius, torus_A_tickness , torus_A_Position , torus_A_Color, torus_A_Rotation ));\n    return co;\n}\n\n\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n\n  co.sd = depth;\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).sd +\n      e.yyx * sdScene(p + e.yyx).sd +\n      e.yxy * sdScene(p + e.yxy).sd +\n      e.xxx * sdScene(p + e.xxx).sd);\n}\n\n\n\n\n\n\nmat3 cameraLookat(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n    return mat3(-cr, cu, -cd);\n}\n\n\nvec3 cameraLookatPosition(float cameraHeight, float cameraRadius, vec3 lookAtPos){\n    // Calculate the updated camera position based on time\n    vec3 cameraPosition;\n    cameraPosition.x = cameraRadius * cos(iTime * 0.5) + lookAtPos.x; // Convert to polar coordinates\n    cameraPosition.z = cameraRadius * sin(iTime * 0.5) + lookAtPos.z;\n    cameraPosition.y = cameraHeight;\n    return vec3(cameraPosition);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1, 1);\n    vec3 col = vec3(0);\n\n    vec3 lookAtPos = vec3(0, 0.5, 0); // Look-at point (camera target)\n    vec3 ro  = cameraLookatPosition(.5, 5., lookAtPos);\n    mat3 cam = cameraLookat(ro, lookAtPos);// Get the camera matrix\n    vec3 rd = cam * normalize(vec3(uv, -1)); // Calculate the ray direction\n\n\n    // Perform ray marching\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // Closest object\n\n    if (co.sd > MAX_DIST) {\n        col = backgroundColor; // Ray didn't hit anything\n    } else {\n        vec3 p = ro + rd * co.sd; // Point on the object we discovered from ray marching\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(2, .5, 7);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0.02, 1.0); // Diffuse reflection\n        col = dif * co.col + backgroundColor * 0.2; // Add a bit of background color to the diffuse color\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}