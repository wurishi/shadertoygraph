{"ver":"0.1","info":{"id":"DlcyDS","date":"1699622205","viewed":119,"name":"[RXO] Voxel DDA","username":"Raxmo","description":"A showcase of the unreasonable efficacy of rendering discrete cubic voxel spaces with embarassingly parallel digital differential analysis driven per-pixel ray-casting.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"dtccRn","parentname":"Ray Base"},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RenderDist =128;\n\nconst uint TOP = 0u;\nconst uint RIGHT = 1u;\nconst uint LEFT = 2u;\nconst uint FRONT = 3u;\nconst uint BACK = 4u;\nconst uint BOTTOM = 5u;\nconst uint NULL = 6u;\n\nbool SampleVoxel(ivec3 cell)\n{\n    float height = 6.0 * sin(float(cell.x) / 18.0) * cos(float(cell.y) / 18.0);\n    return float(cell.z) < height + 6.0;\n}\n\nfloat minval(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat maxval(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat VoxelDist(vec3 ro, vec3 rd, out ivec3 ocell, out uint face)\n{\n    float t = 0.0;\n    //---------------------------------------//\n    \n    ivec3 cell = ivec3(floor(ro));\n    vec3 dts = abs(1.0 / rd);\n    ivec3 stepdir = ivec3(sign(rd));\n    vec3 nts = vec3\n    (\n        dts.x * (1.0 - fract(float(stepdir.x) * fract(ro.x))),\n        dts.y * (1.0 - fract(float(stepdir.y) * fract(ro.y))),\n        dts.z * (1.0 - fract(float(stepdir.z) * fract(ro.z)))\n    );\n    float nt = minval(nts);\n    uint zface = stepdir.z < 0 ? TOP : BOTTOM;\n    uint xface = stepdir.x < 0 ? RIGHT : LEFT;\n    uint yface = stepdir.y < 0 ? FRONT : BACK;\n    \n    //--------------- loop ------------------//\n    bool isSky = true;\n    for(int i = 0; i < 16 * RenderDist; i++)\n    {\n        if(SampleVoxel(cell)) \n        {\n            isSky = false;\n            break;\n        }\n        \n        t = nt;\n        if(nts.x == minval(nts))\n        {\n            nts.x += dts.x;\n            cell.x += stepdir.x;\n            face = xface;\n        }\n        else if(nts.y == minval(nts))\n        {\n            nts.y += dts.y;\n            cell.y += stepdir.y;\n            face = yface;\n        }\n        else\n        {\n            nts.z += dts.z;\n            cell.z += stepdir.z;\n            face = zface;\n        }\n        \n        nt = minval(nts);\n    }\n    \n    //---------------------------------------//\n    face = isSky ? NULL : face;\n    ocell = cell;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -->> initializing \"static\" values <<-- //\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n\n    mat3x3 camdir = mat3x3\n    (\n    vec3(1.0, 0.0, 0.0), // Right\n    vec3(0.0, 1.0, 0.0), // Forward\n    vec3(0.0, 0.0, 1.0)  // Up\n    );\n    \n    float fov = 90.0 * (atan(0.0, -1.0) / 180.0);\n\n    vec3 col = vec3(0.0);\n    \n    vec3 rd = camdir * vec3(uv, 1.0).xzy;\n    vec3 ro = vec3(0.0);\n    \n    //------------------------------------------//\n    // -->> Camera set-up <<-- //\n    \n    ro = vec3(0.5, 0.5 + iTime * 2.0, -cos(iTime/20.0) * 10.0 + 16.5);\n    // Forward vector\n    camdir[1] = normalize(vec3(sin(sin(iTime / 10.0) * 3.0), cos(sin(iTime/10.0) * 3.0), -0.45));\n    // Right vector\n    camdir[0] = normalize(vec3(camdir[1].y, -camdir[1].x, 0.0));\n    // Up vector\n    camdir[2] = cross(camdir[0], camdir[1]);\n    rd = camdir * vec3(uv, 1.0).xzy;\n    \n    //------------------------------------------//\n    // -->> do the do <<-- //\n    ivec3 cell = ivec3(0.0);\n    uint face = NULL;\n    float t = VoxelDist(ro, rd, cell, face);\n    vec3 P = ro + rd * t;\n    \n    //------------------------------------------//\n    \n    vec3 cuv = P - vec3(cell);\n    \n    col = cuv;\n    \n    vec3 sunpos = normalize(vec3(2.0, 1.0, 3.0));\n    \n    switch(face)\n    {\n        case NULL:\n            col = vec3(0.2, 0.4, 1.0);\n            break;\n        case TOP:\n            col = texture(iChannel1, cuv.xy).rgb;\n            break;\n        case RIGHT:\n            col = texture(iChannel0, cuv.yz).rgb * 0.8;\n            break;\n        case LEFT:\n            col = texture(iChannel0, cuv.yz).rgb * 0.2;\n            break;\n        case BACK:\n            col = texture(iChannel0, cuv.xz).rgb * 0.6;\n            break;\n        case FRONT:\n            col = texture(iChannel0, cuv.xz).rgb * 0.4;\n            break;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}