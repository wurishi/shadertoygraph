{"ver":"0.1","info":{"id":"3tdGR8","date":"1575594279","viewed":258,"name":"Some Waves","username":"JohnShadow","description":"Some Waves","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","ocean","rotational","somewaves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265359\n#define frand(p) fract(sin(p)*43758.5453123)\n#define rand(p) (256.*fract( sin( dot( floor(p) , vec2(1.1,31.7)) ) *43758.5453123 ))\n\nstruct Ray\n{\n    vec3 o, d;\n};\nstruct WaveInfo\n{\n\tfloat rotationLimit, angleLimiter, waveScalar, waveHeight, wavePeak, timeScalar;\n};\n\n\nWaveInfo info = WaveInfo(10.0, 0.2, 30.0, 4.0, 0.3, 4.0);\n\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\n\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat Y = Yxy.r;\n\tfloat x = Yxy.g;\n\tfloat y = Yxy.b;\n\n\tfloat X = x * ( Y / y );\n\tfloat Z = ( 1.0 - x - y ) * ( Y / y );\n\n\treturn vec3(X,Y,Z);\n}\n\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\tmat3 M = mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n\n\treturn XYZ * M;\n}\n\n\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\n\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\n\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( pi - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\n\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\n\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\n\treturn YxyToRGB( Yp );\n}\nvec3 skyGenerate(float t, vec3 rd)\n{\n   vec3 sunDir = normalize( vec3( sin(t * 0.125) * cos(t * 0.25), cos(t * 0.25), sin(t * 0.25) * sin(t * 0.125) ) );\n\treturn (calculateSkyLuminanceRGB( sunDir, rd, 2.5))/25.0;\n}\n\n\n//------perlin noise-------\n\nfloat smooth_(vec2 p){\n    float corners = (rand(vec2(p.x-1.0,p.y-1.0))+rand(vec2(p.x+1.0,p.y-1.0))+rand(vec2(p.x-1.0,p.y+1.0))+rand(vec2(p.x+1.0,p.y+1.0)))/16.0;\n    float sides = (rand(vec2(p.x+1.0,p.y))+rand(vec2(p.x-1.0,p.y))+rand(vec2(p.x,p.y+1.0))+rand(vec2(p.x,p.y-1.0)))/8.0;\n    float center = rand(vec2(p.x,p.y))/4.0;\n    return corners + sides + center;                                                           \n}\nfloat lin_inter(float x, float y, float s)\n{\n    return x + s * (y-x);\n}\n\nfloat smooth_inter(float x, float y, float s)\n{\n    return lin_inter(x, y, s * s * (3.0-2.0*s));\n}\nfloat noiseSample(vec2 uv)\n{\n    float ix = floor(uv.x), iy = floor(uv.y);\n    float x_frac = fract(uv.x);\n    float y_frac = fract(uv.y);\n    float s = smooth_(vec2(ix,iy))/256.0;\n    float t = smooth_(vec2(ix+1.0,iy))/256.0;\n    float u = smooth_(vec2(ix,iy+1.0))/256.0;\n    float v = smooth_(vec2(ix+1.0,iy+1.0))/256.0;\n    float low = smooth_inter(s, t, x_frac);\n    float high = smooth_inter(u, v, x_frac);\n    return smooth_inter(low, high, y_frac);\n}\nfloat lerp(float a, float b, float t)\n{\n    return a*t + b*(1.-t);\n}\n\nfloat perlin2d(vec2 uv, float freq, int depth)\n{\n    uv *= freq;\n    float amp = 2.0;\n    float fin = 0.0;\n    float div = 0.0;\n\n    int i;\n    for(i=0; i<depth; i++)\n    {\n        div += amp;\n        fin += noiseSample(uv) * amp;\n        amp /= 2.0;\n        uv.x *= 2.0;\n        uv.y *= 2.0;\n    }\n\n    return fin/div;\n}\n   \n//------wave------\n\nvec2 Rotate2d(vec2 position, float theta)\n{\n    float dx = position.x * cos(theta) - position.y * sin(theta);\n    float dy = position.x * sin(theta) + position.y * cos(theta);\n\treturn vec2(dx, dy);\n}\n//info goes (rotation noise scale, rotation noise wave angle, wave scalar, time scalar)\nfloat wave(vec2 uv, WaveInfo info, int n)\n{\n    float sum = 0.0;\n    vec2 q = vec2(0.0);\n    float m = 0.0;\n    float noise = sin(info.rotationLimit);\n    float nf = float(n);\n    vec2 timeAngle = vec2(iTime * info.angleLimiter, iTime * (1.0-info.angleLimiter));\n    uv += timeAngle * info.timeScalar;\n    for(int i = 0; i < n; ++i)\n    {\n\t\t++m;\n        noise = sin(noise * 4700002.123456789);\n        vec2 edit = uv;\n        edit += timeAngle * 3.0 * (info.timeScalar/m); //move sub waves\n        vec2 rotated = Rotate2d(edit, pi * info.rotationLimit * ((noise * info.angleLimiter) / m)); //random rotation\n\t\t\n        rotated *= m/info.waveScalar;\n        \n        float trig = mix(sin(rotated.y), cos(2.0*rotated.x), info.angleLimiter);\n        noise = sin(noise * 4700002.123456789);\n\t\tfloat value = mix(-abs(trig) + 1.0, trig, noise * info.wavePeak);\n        \n        sum += value * value;\n    }\n    sum /= m;\n    return sum * (info.waveHeight);\n}\nfloat waveFoam(vec3 p, WaveInfo info)\n{\n    vec2 timeAngle = 4.0*vec2(iTime * info.angleLimiter, iTime * (1.0-info.angleLimiter));\n    float ylimit = max(10.0*((1.0 - 1.0/(p.y + 1.0))-0.7), 0.0);\n    return ylimit * perlin2d(p.xz + timeAngle, 10.0, 10);\n}\n\n//------march------\n\nfloat map(vec3 p)\n{\n    p = p - vec3(0, 1.0, 0);\n    float ocean = wave(p.xz, info, 20);\n    return dot(p, vec3(0, 1.0, 0)) - ocean;\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.0001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat march(Ray ray)\n{\n    float cd = 0.0, fd = 0.0;\n    for(int i = 0; i < 500; ++i)\n    {\n        cd = map(ray.o + ray.d * fd);\n        fd += cd;\n        if(fd > 500.0)\n            return 0.0;\n        if(cd < 0.0001)\n            return fd;\n    }\n    return 0.0;\n}\n\nfloat getao (vec3 pos, vec3 normal)\n{\n\treturn clamp(map(pos+normal*0.2)/0.2, 0.0, 1.0);\n}\nfloat scatter(float l, Ray ray)\n{\n    float total = 0.0;\n    ray.o = ray.o + ray.d * (l + 0.1);\n    for(int i = 0; i < 50; ++i)\n    {\n        float dist = map(ray.o + ray.d * total);\n        total += dist;\n        if(dist >= -0.01)\n            return total;\n    }\n}\n\n//------ray gen------\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n//------main------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sinTime = vec2(sin(iTime), cos(iTime));\n    \n\tvec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(10.0, 7.0, 10.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 7.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    Ray ray = Ray(eye, worldDir);\n    \n    vec3 sun = normalize(vec3(sinTime, 0.0));\n    \n    float l = march(ray);\n    vec3 n = vec3(0);\n    vec3 c = vec3(0);\n    \n    if(l != 0.0)\n    {\n        vec3 p = eye + worldDir * (l - 0.005);\n    \tn = normal(p);\n        float ao = getao(p, n);\n        float sss = scatter(l, ray);\n        vec3 col = vec3(0.3, 0.6, 0.8) * exp(sss*3.0);\n        float ndot = max(dot(n,sun), 0.0);\n        vec3 refl = normalize(reflect(ray.d, n));\n        vec3 samplesky = skyGenerate(iTime, refl);\n        float foam = waveFoam(p, info);\n        c = foam + ao * col * samplesky;\n    }\n    else\n        c = skyGenerate(iTime, ray.d);\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}