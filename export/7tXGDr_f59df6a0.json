{"ver":"0.1","info":{"id":"7tXGDr","date":"1621962003","viewed":172,"name":"glsl-tri-rast","username":"kusma","description":"A GLSL triangle rasterizer.\n\nHandles view-plane intersecting triangles without geometric clipping.\n\nVisualizes hierarchical rasterization details.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rasterizer","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int SUBPIXEL_BITS = 4;\nconst bool BACKFACE_CULL = true;\n\nivec3 round_to_subpixel(vec3 v)\n{\n    return ivec3(floor(v * float(1 << SUBPIXEL_BITS) + 0.5));\n}\n\nstruct primitive {\n    vec2 bmin, bmax; // bounding box\n    \n    ivec3 e[3]; // edge functions\n\n    // z, w, and barycentric interpolants\n    vec3 fz, fw, fi, fj;\n};\n\nvoid calc_bbox_trivial(vec4 verts[3], out vec2 bmin, out vec2 bmax)\n{\n    bmin = iResolution.xy;\n    bmax = vec2(0);\n    for (int i = 0; i < 3; ++i) {\n        // assert(verts[i].w > 0);\n        bmin = min(bmin, verts[i].xy);\n        bmax = max(bmax, verts[i].xy);\n    }\n}\n\nvoid calc_bbox(vec4 verts[3], out vec2 bmin, out vec2 bmax)\n{\n    bmin = iResolution.xy;\n    bmax = vec2(0);\n    bvec2 xpos = bvec2(false), xneg = bvec2(false);\n    for (int i = 0; i < 3; ++i) {\n        if (verts[i].w > 0.0) {\n            bmin = min(bmin, verts[i].xy);\n            bmax = max(bmax, verts[i].xy);\n        } else {\n            int j = (i + 1) % 3;\n\t\t\tif (verts[j].w > 0.0) {\n                bvec2 s = greaterThan(verts[j].xy, verts[i].xy);\n                xpos = bvec2(xpos.x || s.x, xpos.y || s.y);\n                xneg = bvec2(xneg.x || !s.x, xneg.y || !s.y);\n\t\t\t}\n\n            int k = (i + 2) % 3;\n\t\t\tif (verts[k].w > 0.0) {\n                bvec2 s = greaterThan(verts[k].xy, verts[i].xy);\n                xpos = bvec2(xpos.x || s.x, xpos.y || s.y);\n                xneg = bvec2(xneg.x || !s.x, xneg.y || !s.y);\n\t\t\t}\n        }\n    }\n    for (int i = 0; i < 2; ++i) {\n        if (xpos[i])\n            bmax[i] = iResolution[i];\n        if (xneg[i])\n            bmin[i] = 0.0;\n    }\n}\n\nmat3 calc_adjoint(vec4 verts[3], vec3 tmp)\n{\n    mat3 adj;\n    for (int i = 0; i < 3; ++i) {\n        int j = (i + 1) % 3;\n        int k = (i + 2) % 3;\n        adj[i].x = verts[j].y - verts[k].y;\n        adj[i].y = verts[k].x - verts[j].x;\n        adj[i].z = tmp[i];\n    }\n    return adj;\n}\n\nivec3 adjust_fill_rule(ivec3 e)\n{\n    if (e.x < 0)\n        e.z++; // top-rule\n    else if (e.x == 0) {\n        if (e.y < 0)\n            e.z++; // left-rule\n    }\n    return e;\n}\n\nvoid setup_interpolants(vec4 verts[3], mat3 adj, float det, inout primitive result)\n{\n    result.fw = adj[0] * verts[0].w;\n    result.fi = adj[1] * verts[1].w;\n    result.fj = adj[2] * verts[2].w;\n    result.fw += result.fi + result.fj;\n    result.fz = (adj[0] * verts[0].z +\n                 adj[1] * verts[1].z +\n                 adj[2] * verts[2].z) / det;\n}\n\nvec3 reduce_edge_range(vec3 ef)\n{\n    // reduce edge-function range to avoid 32-bit overflow later.\n    // we're still adding subpixel bits later, so this isn't as low as\n    // it sounds.\n\n    float mag = max(abs(ef.x), max(abs(ef.y), abs(ef.z)));\n    const float limit_log2 = 23.0;\n    if (mag >= exp2(limit_log2))\n        ef *= exp2(-floor(log2(mag)) + limit_log2);\n    return ef;\n}\n\nbool setup_tri_trivial(vec4 verts[3], out primitive result)\n{\n    // calculate enough of the adjoint to calculate the determinant\n    vec3 tmp = cross(vec3(verts[0].x, verts[1].x, verts[2].x),\n                     vec3(verts[0].y, verts[1].y, verts[2].y));\n\n    // backface culling\n\tfloat det = tmp.x + tmp.y + tmp.z;\n    if (BACKFACE_CULL && det <= 0.0)\n        return false;\n    calc_bbox_trivial(verts, result.bmin, result.bmax);\n\n    mat3 adj = calc_adjoint(verts, tmp);\n\n    // edge-functions (snapped to subpixels)\n    for (int i = 0; i < 3; ++i) {\n        vec3 ef = reduce_edge_range(adj[i]);\n        ivec3 e = round_to_subpixel(ef);\n        result.e[i] = adjust_fill_rule(e);\n    }\n\n    setup_interpolants(verts, adj, det, result);\n    return true;\n}\n\nbool setup_tri(vec4 verts[3], out primitive result)\n{\n    if (verts[0].w > 0.0 && verts[1].w > 0.0 && verts[2].w > 0.0)\n        return setup_tri_trivial(verts, result);\n\n    // calculate enough of the adjoint to calculate the determinant\n    vec3 tmp = cross(vec3(verts[0].x, verts[1].x, verts[2].x),\n                     vec3(verts[0].y, verts[1].y, verts[2].y));\n\n    // backface culling\n\tfloat det = tmp.x + tmp.y + tmp.z;\n    if (BACKFACE_CULL && det * verts[0].w * verts[1].w * verts[2].w <= 0.0)\n        return false;\n\n    calc_bbox(verts, result.bmin, result.bmax);\n\n    mat3 adj = calc_adjoint(verts, tmp);\n\n    bool inv_edge[3];\n    inv_edge[0] = verts[1].w * verts[2].w <= 0.0;\n    inv_edge[1] = verts[2].w * verts[0].w <= 0.0;\n    inv_edge[2] = verts[0].w * verts[1].w <= 0.0;\n\n    // edge-functions (snapped to subpixels)\n    for (int i = 0; i < 3; ++i) {\n        vec3 ef = reduce_edge_range(adj[i]);\n        ivec3 e = round_to_subpixel(ef);\n        if (inv_edge[i])\n            e = -e;\n        result.e[i] = adjust_fill_rule(e);\n    }\n\n    setup_interpolants(verts, adj, det, result);\n    return true;\n}\n\nint eval_edge(ivec3 e, ivec2 pos)\n{\n    return e.x * pos.x + e.y * pos.y + e.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    vec4 verts[3] = vec4[3](\n        vec4(-0.75, -0.75, 0.0, 1.0) * 1.0,\n        vec4( 0.75, -0.75, 0.0, 1.0) * 0.75,\n        vec4( 0.00,  0.75, 1.0, 1.0) * 0.25\n    );\n\n    for (int i = 0; i < 3; ++i)\n        verts[i].xy += vec2(sin(iTime * 0.25 + float(i)), cos(iTime * 0.25 - float(i))) * 0.3;\n#else\n    vec4 verts[3] = vec4[3](\n        vec4(-0.75, -0.75, 0.0, 1.0),\n        vec4( 0.75, -0.75, 0.0, 1.0),\n        vec4( 0.00,  0.75, 1.0, 1.0)\n    );\n\n    verts[2].w = 0.5 + 1.75 * sin(iTime);\n    // verts[2].w = 0.0025 * sin(iTime);\n#endif\n\n\n    vec4 attrs[3] = vec4[3](\n        vec4(-1.0, -1.0, 0.0, 0.0),\n        vec4( 1.0, -1.0, 0.0, 0.0),\n        vec4( 0.0,  1.0, 0.0, 0.0)\n    );\n\n    // *** per vertex\n\n    // viewport map\n    for (int i = 0; i < 3; ++i) {\n        float w_rcp = 1.0 / verts[i].w;\n        // clamp 1 / w to avoid problems at infinity\n        const float w_rcp_range = exp2(20.0);\n        w_rcp = clamp(w_rcp, -w_rcp_range, w_rcp_range);\n\n        vec3 tmp = verts[i].xyz * w_rcp;\n        verts[i].xy = iResolution.xy * 0.5 + tmp.xy * iResolution.xy * 0.5;\n        verts[i].z = tmp.z;\n        verts[i].w = w_rcp;\n    }\n\n    // *** per primitive\n\n    primitive prim;\n    if (!setup_tri(verts, prim)) {\n        fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n        return;\n    }\n\n\n    /* this really belongs elsewhere, but it's cleaner to color here */\n    if (any(lessThan(fragCoord.xy, floor(prim.bmin.xy))) ||\n        any(greaterThan(fragCoord.xy, ceil(prim.bmax.xy)))) {\n        fragColor = vec4(0.0, 0.5, 0.5, 1.0);\n        return;\n    }\n\n    // *** per tile\n\n    fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n\n    /* just proof-of-concept: conservative\n     * block-rasterizing, for hierarchial\n     * rasterization (and could be repurposed\n     * for normal conservative rasterization)\n     */\n    ivec3 de, ne;\n    for (int i = 0; i < 3; ++i) {\n        de[i] = max(prim.e[i].x, 0) + max(prim.e[i].y, 0);\n        ne[i] = prim.e[i].x + prim.e[i].y - de[i];\n    }\n\n    fragColor = vec4(1.0);\n    for (int i = 6; i > 0; i--) {\n        ivec2 hpos = ivec2(fragCoord.xy) & ~((1 << i) - 1);\n        ivec3 d;\n        for (int j = 0; j < 3; ++j)\n            d[j] = eval_edge(prim.e[j], hpos);\n\n        bool fully_outside = any(lessThan(d + (de << i), ivec3(0)));\n        if (fully_outside) {\n            fragColor[i % 3] *= 0.875 / float(1 + i / 3);\n            return;\n        }\n\n        bool fully_inside = all(greaterThan(d + (ne << i), ivec3(0)));\n        if (fully_inside) {\n            fragColor[i % 3] *= 0.875 / float(1 + i / 3);\n            break;\n        }\n    }\n\n    // *** per pixel\n\n    ivec2 pos = ivec2(fragCoord.xy);\n\tint d0 = eval_edge(prim.e[0], pos);\n\tint d1 = eval_edge(prim.e[1], pos);\n\tint d2 = eval_edge(prim.e[2], pos);\n\n    if (min(min(d0, d1), d2) > 0) {\n        float z = dot(prim.fz, vec3(pos, 1));\n        if (z < 0.0 || z > 1.0) {\n            fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n            return;\n        }\n\n        float i = dot(prim.fi, vec3(pos, 1));\n        float j = dot(prim.fj, vec3(pos, 1));\n        float w = 1.0 / dot(prim.fw, vec3(pos, 1));\n\n        i *= w;\n        j *= w;\n        float k = 1.0 - i - j;\n\n        // interpolate a single vec4 varying\n        vec4 var = attrs[0] * k + attrs[1] * i + attrs[2] * j;\n\n        vec4 tmp = vec4(textureLod(iChannel0, var.xy, 0.0).xyz, 1.0);\n        tmp.xyz = mix(tmp.xyz, vec3(0.5), 1.0 / (1.0 + z));\n        fragColor *= tmp;\n\n    }\n}\n","name":"Image","description":"","type":"image"}]}