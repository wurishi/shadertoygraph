{"ver":"0.1","info":{"id":"Ml2XWy","date":"1446318492","viewed":420,"name":"inverse trochoid approximation 2","username":"jt","description":"Approximation of inverse-trochoid function with implicit-surface ray-tracer.\nSee here for FabriceNeyret2's original inverse trochoid function: [url]https://www.shadertoy.com/view/MtSSDG[/url]\n","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","implicitsurface","parametriccurve","trochoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Approximation of inverse-trochoid function with implicit-surface ray-tracer by Jakob Thomsen\n// Original inverse trochoid function by FabriceNeyret2\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define pi 3.1415926\n\nfloat localtime;\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat trochoid2d(vec2 v, float t) // Approximation to FabriceNeyret2's inverse trochoid function (source: https://www.shadertoy.com/view/MtSSDG)\n{\n    float A = 0.5 + 0.4 * sin(0.1 * iTime * 2.0 * pi);\n    return -A + 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(v.x - t), A + 1.0), 1.0 / (A + 1.0));\n}\n\nfloat fn(vec3 v)\n{\n    v *= 10.0;\n    return v.z + clamp(trochoid2d(v.xy, localtime), -1.0, 1.0);\n}\n\nvec3 nrm(vec3 v)\n{\n    v *= 10.0;\n    float d = 0.01;\n    vec2 grad;\n    grad.x = trochoid2d(v.xy + vec2(d, 0.0), localtime) - trochoid2d(v.xy + vec2(-d, 0.0), localtime);\n    grad.y = trochoid2d(v.xy + vec2(0.0, d), localtime) - trochoid2d(v.xy + vec2(0.0, -d), localtime);\n    return normalize(vec3(-grad, d));\n}\n\nfloat comb(float v)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), 10.0);\n}\n\nvec3 texGrid(vec3 v)\n{\n    v.x = fract(v.x * 8.0);\n    v.y = fract(v.y * 8.0);\n    float q = 0.0;\n    q = max(q, comb(v.x));\n    q = max(q, comb(v.y));\n    return vec3(q);\n}\n\nvec3 texHeight(vec3 v)\n{\n    v = 0.5 + 0.5 * clamp(v, -1.0, 1.0);\n    return vec3(0.0, v.z, 1.0 - v.z);\n}\n\nvec3 texLight(vec3 v)\n{\n    return vec3(abs(nrm(v).z));\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime * 0.0;\n    //float phi = 2.0 * iMouse.x / iResolution.x - 1.0;\n    vec3 v = vec3(uv, depth);\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    v.x = iso.x * cos(phi) + iso.y * sin(phi);\n    v.y = iso.x * -sin(phi) + iso.y * cos(phi);\n    v.z = iso.z;\n\n    return v;\n}\n\nvec3 bisection(vec3 a, vec3 b) // slow root-finder, but simple & stable\n{\n    float fa = fn(a);\n    float fb = fn(b);\n    const int n = 16;\n    for(int i = 0; i < n; i++)\n    {\n        vec3 c = (a + b) / 2.0;\n        float fc = fn(c);\n        if(sign(fc) == sign(fa))\n        {\n            a = c;\n            fa = fc;\n        }\n        else\n        {\n            b = c;\n            fb = fc;\n        }\n    }\n    \n    return (a + b) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localtime = iTime;\n\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv /= 2.0;\n\n    vec3 a = camera(uv.xy, 1.0);\n    vec3 b = camera(uv.xy,-1.0);\n    vec3 v = bisection(a, b);\n    vec3 color = (abs(v.x) > 1.0 || abs(v.y) > 1.0 || abs(v.z) > 1.0) ? vec3(0.0, 0.0, 0.0) : texLight(v) * texHeight(v) + 0.1 * texGrid(v);\n\n    //fragColor = vec4(color * vec3(m), 1.0);\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}