{"ver":"0.1","info":{"id":"7tcfDB","date":"1690915556","viewed":85,"name":"Iterative Cubic Bezier Curve","username":"Reynolds","description":"Approximate a cubic Bezier curve by looking at line normal at t=0.5 then subdividing. Works suprisingly well.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","spline","segment"],"hasliked":0,"parentid":"stcfDB","parentname":"Iterative Quadratic Bezier"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxIterations 10\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nbool sSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 x = p-a;\n    vec2 e = b-a;\n    return dot(x, vec2(e.y, -e.x)) > 0.0;\n}\n\nvec2 bez2(vec2 A, vec2 B, vec2 C, float t)\n{\n    return mix(mix(A, B, t), \n               mix(B, C, t), t);\n     \n}\n\nvec2 bez3(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(bez2(A, B, C, t),\n               bez2(B, C, D, t), t); \n}\n\nvec2 tangent3(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return bez2(B-A, C-B, D-C, t);    \n}\n\nfloat node(vec2 uv, vec2 pos, float size, float inner) \n{\n   float d0 = length(uv - pos) - size,\n         d1 = length(uv - pos) - inner;\n   return max(d0, -d1);\n}\n\n/* take the normal and position of the curve at t = 0.5 and construct a line\n * determine from this line on which halve of the curve were on. Subdivide the \n * curve to the respectice side and repeat. Only a single curve and tangent\n * evaluation are needed per iteration. Using different numbers of iterations you\n * can create different LODs of the same curve.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.35, 0.0);\n\n    int numIterations = max(int(iTime/2.0) % maxIterations, 1);\n    \n    vec2 A = vec2(0.05, 0.5) + vec2(0.1*sin(iTime/0.7), 0.1*cos(iTime/0.7));\n    vec2 B = vec2(0.2, 0.5 + 0.75*sin(iTime)) +  vec2(0.25*cos(iTime/0.5), 0.0);\n    vec2 C = vec2(0.7, 0.5 + 0.75*cos(iTime/2.0)) + vec2(0.25*sin(iTime/0.7), 0.0);\n    vec2 D = vec2(0.95, 0.5) + vec2(0.1*cos(iTime/0.5), 0.1*sin(iTime/0.5));\n    \n    vec2 p0 = A;\n    vec2 p1 = B;\n    vec2 p2 = C;\n    vec2 p3 = D;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    vec3 ts = vec3(0.0, 0.5, 1.0);\n    vec2 e1 = p1 - p0;\n    vec2 e2 = p3 - p2;\n    float f = 0.25;\n    float u = 0.5;\n    for(int i = 0; i < numIterations; ++i) {\n        e1 = p1 - p0;\n        e2 = p3 - p2;\n\n        col = vec3(0.0);\n        vec2 mp = bez3(p0, p1, p2, p3, 0.5);\n        vec2 t = tangent3(p0, p1, p2, p3, 0.5);   \n\n        vec2 c = 0.5*(p1 + p2);\n\n        //which side of line (mp, t) are we?\n        if(dot(t, mp - uv) < 0.0) {\n            //right\n            col = vec3(1.0, 0.0, 0.0);\n\n            vec2 p2_n = 0.5*(p2 + p3);\n\n            p0 = mp;\n            p1 = 0.5*(c + p2_n);\n            p2 = p2_n;\n            p3 = p3;\n\n            u += f;\n        } else {\n            //left\n            col = vec3(0.0, 0.0, 1.0);\n\n            vec2 p1_n = 0.5*(p0 + p1);\n\n            p0 = p0;\n            p1 = p1_n;\n            p2 = 0.5*(c + p1_n);\n            p3 = mp;\n            \n            u -= f;\n        }\n\n        f *= 0.5;\n    }\n\n    //which side of segment\n    if(sSegment(uv, p0, p3) ) {\n        col = vec3(0.0);\n    } else {\n        col = vec3(1.0);\n    }\n    \n    //distance to segment\n    float d = udSegment(uv, p0, p3);\n    float lineThickness = 0.005;\n\n    col = mix(col, vec3(u, 0, (1.0 - u )), smoothstep(2./iResolution.y, 0., d - lineThickness));\n    \n    vec3 cp = vec3(1.0) - col;\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, A, 0.015, 0.01)));\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, B, 0.015, 0.01)));\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, C, 0.015, 0.01)));\n    col = mix(col, cp, smoothstep(2./iResolution.y, 0., node(uv, D, 0.015, 0.01)));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}