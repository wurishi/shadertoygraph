{"ver":"0.1","info":{"id":"ltyfDd","date":"1544811254","viewed":247,"name":"Procedural City","username":"Gr","description":"Procedural Generated City developed as a part of a final project in a graphics course.\nProcedural texture generation is also a feature.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 0\n#define PLANE 1\n#define NO_INTERSECT 2\n#define BOX 3\n#define HEX 4\n#define SW 5\n\n#define STORY 0.125\n#define BUILD_R 0.32\n#define MID_SEC 0.1\n\n//Section Heights\n#define MAX_S1 4.0\n#define MAX_S2 2.0\n#define MAX_S3 2.0\n    \n//DownTownSPECS\n#define D_RAD 10.0\n\n\n//Road Mapping\n#define SIDEWALK_H 0.01\n#define SIDEWALK_W 0.01\n\n#define YELLOW_MIN 0.48\n#define YELLOW_MAX 0.49\n\n#define DASH_MIN 0.36\n#define DASH_MAX 0.39\n#define DASH_LEN 0.03\n\n#define CROSS_MIN 0.25\n#define CROSS_MAX 0.35\n#define CROSS_LEN 0.08\n\n\n#define M_PI 3.14159265358979323846264338327950288\n//Noise Funcs\n//2D func adapted from terrain\nfloat rand_2_1(vec2 v) {\n    return fract(sin(v.x * 127.1 + v.y * 311.7) * 43758.5453123);\n}\nfloat rand_1_1(float f) {\n    return fract(sin(f * 435.23) * 5489.9847);\n}\nstruct PrimitiveDist {\n    float dist;\n    int primitive; // Can be SPHERE, PLANE, or NO_INTERSECT\n};\n    \n// If you want, you can play around with the textures in iChannels 0 and 1\n// The textures should show no distortion\nvec3 texCube(sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 x = texture(sam, p.yz);\n    vec4 y = texture(sam, p.xz);\n    vec4 z = texture(sam, p.xy);\n    x *= abs(n.x);\n    y *= abs(n.y);\n    z *= abs(n.z);\n    vec3 projections = vec3(x + y + z);\n\n   return projections;\n}\n\n//From TheBookOfShaders Rotation article\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n//http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotate3d(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\n//From https://iquilezles.org/articles/distfunctions\nfloat sdHexPrism(vec3 pos, vec2 h)\n{\n    vec3 p = vec3(pos.x, pos.y - h.y, pos.z);\n    p = rotate3d(vec3(1.0, 0.0, 0.0), M_PI/2.0) * p;\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 pos, vec3 b)\n{\n  vec3 p = pos;\n  p = vec3(pos.x, pos.y - b.y, pos.z);\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n//Compare pd by distance\nPrimitiveDist compPD(PrimitiveDist d1, PrimitiveDist d2)\n{\n    if(d1.dist<d2.dist){\n        return d1;\n    } else {\n        return d2;\n    }\n}\n\nPrimitiveDist section(vec3 p, float rad, int stories, vec2 id){\n    float side = rad*0.75;\n    float randForShape = rand_1_1(rand_2_1(id));\n    if(randForShape < 0.6){\n        float box = sdBox(p, vec3(side, float(stories) * STORY, side));\n\t\tPrimitiveDist boxPD = PrimitiveDist(box, BOX);\n        \n        float randForTower = rand_1_1(rand_1_1(id.x) + rand_1_1(id.y));\n        if(randForTower > 0.7){\n            float randTower = rand_1_1(randForTower);\n            vec3 offsetPos;\n            if(randTower < 0.25){\n                offsetPos = p + vec3(side * 0.5, 0.0, 0.0);\n            } else if((randTower > 0.25) && (randTower < 0.5)) {\n                offsetPos = p + vec3(-side * 0.5, 0.0, 0.0);\n            } else if((randTower > 0.5) && (randTower < 0.75)) {\n                offsetPos = rotate3d(vec3(0.0, 1.0, 0.0), M_PI/2.0) * (p + vec3(0.0, 0.0, side * 0.5));\n            } else {\n                offsetPos = rotate3d(vec3(0.0, 1.0, 0.0), M_PI/2.0) * (p + vec3(0.0, 0.0, -side * 0.5));\n            }\n            float tower = sdHexPrism(offsetPos, vec2(side, float(stories) * STORY));\n            PrimitiveDist towerPD = PrimitiveDist(tower, HEX);\n            return compPD(boxPD, towerPD);\n        } else {\n            return boxPD;\n        }\n    } else {\n        float hex = sdHexPrism(p, vec2(side, float(stories) * STORY));\n\t\tPrimitiveDist hexPD = PrimitiveDist(hex, HEX);\n        \n        float randForTower = rand_1_1(rand_1_1(id.x) + rand_1_1(id.y));\n        if(randForTower > 0.5){\n            float randTower = 0.9 * rand_1_1(randForTower); // Scale to make probabilities nicer\n            vec3 offsetPos;\n            mat3 rot = rotate3d(vec3(0.0, 1.0, 0.0), M_PI/3.0);\n            vec3 dir1 = vec3(cos(M_PI/6.0),0.0, sin(M_PI/6.0));\n            vec3 dir2 = vec3(cos(M_PI*5.0/6.0),0.0, sin(M_PI*5.0/6.0));\n            float mag = side * sqrt(3.0)/2.0;\n            if(randTower > 0.5){\n                offsetPos = rot * (p + mag * dir1);\n            } else if((randTower > 0.15) && (randTower < 0.3)) {\n                offsetPos = rot * (p + mag * -dir1);\n            } else if((randTower > 0.3) && (randTower < 0.45)) {\n                offsetPos = rot * (p + mag * dir2);\n            } else if((randTower > 0.45) && (randTower < 0.6)){\n                offsetPos = rot * (p + mag * -dir2);\n            } else if((randTower > 0.6) && (randTower < 0.75)){\n                offsetPos = p + mag * vec3(0.0, 0.0, 1.0);\n            } else {\n                offsetPos = p - mag * vec3(0.0, 0.0, 1.0);\n            }\n    \t\tfloat tower = sdBox(offsetPos, vec3(side * 0.5, float(stories) * STORY, side * 0.5));\n            PrimitiveDist towerPD = PrimitiveDist(tower, BOX);\n            return compPD(hexPD, towerPD);\n        } else {\n            return hexPD;\n        }\n    }\n}\n\nPrimitiveDist building(vec3 p){\n    vec2 block = floor(p.xz);\n    vec3 blockPos = vec3(fract(p.x) - 0.5, p.y, fract(p.z)- 0.5);\n    float randSections = rand_2_1(block);\n    float sf1 = 2.0 + floor(rand_1_1(randSections) * MAX_S1 * D_RAD/length(block));\n    if(length(block) == 0.0){\n        sf1 = 8.0;\n        //Inifinte edge case due to division by 0\n    }\n    if(sf1 > 15.0){\n    \tsf1 = 15.0;\n    }\n    PrimitiveDist s1 = section(blockPos, BUILD_R, int(sf1), block);\n    PrimitiveDist outSh = s1;\n    if(randSections > 0.5) {\n        //2nd section\n        float sf2 = 1.0 + floor(rand_1_1(sf1) * MAX_S2 * D_RAD/length(block)/1.5);\n        if(sf2 > 15.0){\n    \t\tsf2 = 15.0;\n    \t}\n        PrimitiveDist s2 = section(blockPos + vec3(0.0, -2.0 * sf1 * STORY, 0.0), 0.5 * BUILD_R, int(sf2), 2.0 * block);\n        outSh = compPD(outSh, s2);\n        //Third section\n        if(randSections > 0.75){\n            float sf3 = 1.0 + floor(rand_1_1(sf2) * MAX_S3 * D_RAD/length(block)/1.5);\n            PrimitiveDist s3 = section(blockPos + vec3(0.0, -2.0 * (sf1 + sf2 )* STORY, 0.0), 0.25 * BUILD_R, int(sf3), 3.0 * block);\n            outSh = compPD(outSh, s3);\n        }\n    }\n    float sideWalk = sdBox(blockPos, vec3(BUILD_R, SIDEWALK_H, BUILD_R));\n    PrimitiveDist sw = PrimitiveDist(sideWalk, SW);\n    return compPD(outSh, sw);\n}\n\n\nPrimitiveDist map(vec3 p) {\n\tPrimitiveDist building = building(p);\n    float plane = sdFloor(p);\n    PrimitiveDist outSh = building;\n    outSh = compPD(outSh, PrimitiveDist(plane, 1));\n    return outSh;\n}\n// TODO [Task 4] Calculate surface normals\nconst float epsilon = 0.001;\nvec2 e = vec2(epsilon, 0.0); // For swizzling\nvec3 calcNormal(vec3 p) {\n    float xCom = map(p + e.xyy).dist - map(p - e.xyy).dist;\n    float yCom = map(p + e.yxy).dist - map(p - e.yxy).dist;\n    float zCom = map(p + e.yyx).dist - map(p - e.yyx).dist;\n\n    return normalize(vec3(xCom, yCom, zCom));\n//    return normalize(vec3(0.5));\n\n}\nfloat shadow(vec3 ro, vec3 rd, float k) {\n    float marchDist = 0.001;\n    float boundingVolume = 25.0;\n    float darkness = 1.0;\n    float threshold = 0.001;\n\n    for(int i = 0; i < 30; i++) {\n        if(marchDist > boundingVolume) continue;\n        float h = map(ro + rd * marchDist).dist;\n        // TODO [Task 7] Modify the loop to implement soft shadows\n        darkness = min(darkness, k*h/marchDist);\n        marchDist += h * 0.7;\n    }\n    return darkness;\n}\nPrimitiveDist raymarch(vec3 ro, vec3 rd) {\n\n    // Fill in parameters\n    float marchDist = 0.001;\n    float boundingDist = 500.0;\n    float threshold = 0.001;\n\n    // Fill in the iteration count\n    for (int i = 0; i < 4000; i++) {\n        // Fill in loop body\n        vec3 currPos = ro + rd*(marchDist);\n        PrimitiveDist dist2Geo = map(currPos);\n\n        if(dist2Geo.dist < threshold){\n            return PrimitiveDist(marchDist, dist2Geo.primitive);\n        }if(marchDist > boundingDist){\n            return PrimitiveDist(-1.0, NO_INTERSECT);\n\n        }\n        marchDist += dist2Geo.dist*0.1f;\n    }\n\n    return PrimitiveDist(-1.0, NO_INTERSECT);\n}\n\nvec3 roadColor(vec3 blockPos){\n    vec3 material = vec3(0.0);\n    if(abs(blockPos.x) > CROSS_MIN && abs(blockPos).z > CROSS_MIN) {\n        //Intersections\n        if(abs(blockPos.x) > CROSS_MIN && abs(blockPos.x) < CROSS_MAX){\n            //Crosswalk\n            material = vec3(0.8, 0.8, 0.8);\n            float linePos = fract((blockPos.z + 0.5)/CROSS_LEN);\n            if(linePos < 0.5 && \n               !(abs(blockPos.z) > CROSS_MIN && abs(blockPos.z) < CROSS_MAX)){\n                material = vec3(0.8, 0.8, 0.8);\n            } else {\n                material = vec3(0.2, 0.2, 0.2);\n            }                                                            \n        } else if(abs(blockPos.z) > CROSS_MIN && abs(blockPos.z) < CROSS_MAX){\n            //Crosswalk\n            material = vec3(0.8, 0.8, 0.8);\n            float linePos = fract((blockPos.x + 0.5)/CROSS_LEN);\n            if(linePos < 0.5 &&\n              !(abs(blockPos.x) > CROSS_MIN && abs(blockPos.x) < CROSS_MAX)){\n                material = vec3(0.8, 0.8, 0.8);\n            } else {\n                material = vec3(0.2, 0.2, 0.2);\n            } \n        }else {\n            material = vec3(0.2, 0.2, 0.2);\n        }\n    }else if(abs(blockPos.x) > DASH_MIN && abs(blockPos.x) < DASH_MAX){\n        //White Dashes\n        float linePos = fract((blockPos.z + 0.5)/DASH_LEN);\n        if(linePos < 0.5){\n            material = vec3(0.8, 0.8, 0.8);\n        } else {\n            material = vec3(0.2, 0.2, 0.2);\n        } \n    } else if(abs(blockPos.z) > DASH_MIN && abs(blockPos.z) < DASH_MAX){\n        //White Dashes\n        float linePos = fract((blockPos.x + 0.5)/DASH_LEN);\n        if(linePos < 0.5){\n            material = vec3(0.8, 0.8, 0.8);\n        } else {\n            material = vec3(0.2, 0.2, 0.2);\n        }\n    } else if((abs(blockPos.z) > YELLOW_MIN && abs(blockPos.z) < YELLOW_MAX)||\n              (abs(blockPos.x) > YELLOW_MIN  && abs(blockPos.x)< YELLOW_MAX)){\n        //Yellow Line(s)\n        material = vec3(0.8, 0.6, 0.2);\n    } else {\n        material = vec3(0.2, 0.2, 0.2);\n    }\n    return material;\n}\nvec3 texCol(vec2 uv, vec2 id){\n    float r1 = rand_2_1(id);\n    float g1 = rand_1_1(r1);\n    float b1 = rand_1_1(g1);\n    \n    float r2 = rand_1_1(b1);\n    float g2 = rand_1_1(r2);\n    float b2 = rand_1_1(g2);\n    \n    vec3 colFrom = vec3(0.4, 0.4, 0.4);\n    vec3 colTo = vec3(1.0, 0.6, 0.5);\n    vec3 col1 = colFrom + colTo*vec3(r1, g1, b1);\n    vec3 col2 = colFrom + colTo*vec3(r2, g2, b2);\n    if(uv.y < 0.333){\n        return col1;\n    } else if (uv.y < 0.999 && uv.y > 0.666){\n        return col1;\n    } else if(uv.x > 0.333 && uv.x < 0.666){\n        return vec3(0.2, 0.2, 0.2);\n    } else {\n        return col2;\n    }\n}\n//We assume a STORYxSTORY texMap\nvec3 buildTex(vec3 pos, vec2 id, vec3 nor){\n    vec2 uv;\n    vec3 dir1 = vec3(cos(M_PI/6.0),0.0, sin(M_PI/6.0));\n    vec3 dir2 = vec3(cos(M_PI*5.0/6.0),0.0, sin(M_PI*5.0/6.0)); \n    \n    if(nor == vec3(0.0, 1.0, 0.0)){\n        return vec3(0.1, 0.4, 0.8);\n    }\n    //CubeGriding\n    \n    else if (abs(nor) == vec3(1.0, 0.0, 0.0)){\n        float yFr = fract(pos.y/STORY);\n        float zFr = fract(pos.z/STORY);\n        uv = vec2(zFr, yFr);\n    }else if (abs(nor) == vec3(0.0, 0.0, 1.0)){\n        float yFr = fract(pos.y/STORY);\n        float xFr = fract(pos.x/STORY);\n        uv = vec2(xFr, yFr);\n    }\n    //ExtraChecks for Hex\n    else if (length(nor - dir1) < 0.001 || length(-nor - dir1) < 0.001){\n        vec2 posRot = rotate2d(-M_PI/3.0) * vec2(pos.x, pos.z);\n        float yFr = fract(pos.y/STORY);\n        float xFr = fract(posRot.x/STORY);\n        float zFr = fract(posRot.y/STORY);\n        uv = vec2(xFr, yFr);\n    } else if (length(nor - dir2) < 0.001 || length(-nor - dir2) < 0.001){\n        vec2 posRot = rotate2d(M_PI/3.0) * vec2(pos.x, pos.z);\n        float yFr = fract(pos.y/STORY);\n        float xFr = fract(posRot.x/STORY);\n        float zFr = fract(posRot.y/STORY);\n        uv = vec2(xFr, yFr);\n    }\n    return texCol(uv, id);\n}\nvec3 skyCol(vec3 ro, vec3 rd, float t, int which) {\n    vec3 col = vec3(0.2, 0.5, 0.65);\n    vec3 pos = ro + rd * t;\n    if(pos.y < 1.0){\n        col *= dot(normalize(rd), normalize(vec3(rd.x, 3.0, rd.z)));\n    }\n    return col;\n}\nvec3 render(vec3 ro, vec3 rd, float t, int which) {\n\n    // Col is the final color of the current pixel.\n    vec3 col = vec3(0.);\n    vec3 pos = ro + rd * t;\n    // Light vector\n    vec3 lig = normalize(vec3(1.0,0.6,0.5));\n\n    // Normal vector\n    vec3 nor = calcNormal(pos);\n\n    // Ambient\n    float ambient = 0.1;\n    // Diffuse\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n    // Specular\n    float shineness = 32.0;\n    float specular = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n\n    float darkness = shadow(pos, lig, 18.0);\n    // Applying the phong lighting model to the pixel.\n    col += vec3(((ambient + diffuse + specular) * darkness));\n\n    // TODO [Task 5] Assign different intersected objects with different materials\n    // Make things pretty!\n    \n    vec2 block = floor(pos.xz);\n    vec3 blockPos = vec3(fract(pos.x) - 0.5, pos.y, fract(pos.z)- 0.5);\n    \n    vec3 material = vec3(0.0);\n    if (which == PLANE) {\n        material = roadColor(blockPos);\n    } else if (which == SW){\n        material = vec3(0.8, 0.8, 0.6);\n    } else if (which == HEX || which == BOX) {\n        material = buildTex(blockPos, block, nor);\n    } else {\n        material = vec3(0.3, 0.3, 0.8);\n    }\n    // Blend the material color with the original color.\n    col = mix(col, material, 0.4);\n    return col;\n}\nfloat smoothRand(vec2 cellPos, vec2 cellId){\n    float vecNoiseVal = rand_2_1(cellId);\n\n    float topVal = rand_2_1(cellId);\n    float botVal = rand_2_1(cellId + vec2(1.0, 0.0));\n    float mixedH = mix(topVal, botVal, cellPos.x);\n\n    float lVal = rand_2_1(cellId + vec2(0.0, 1.0));\n    float rVal = rand_2_1(cellId + vec2(1.0, 1.0));\n    float mixedW = mix(lVal, rVal, cellPos.x);\n\n    float mixedFull = mix(mixedH, mixedW, cellPos.y);\n    return mixedFull;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 rayOrigin = vec3(sin(iTime * 0.3) * 6.0, 6., -3.0 + 6.0 *  cos(iTime * 0.3));\n\n    float focalLength = 2.0;\n\n    // The target we are looking at\n    vec3 target = vec3(0.0);\n    // Look vector\n    vec3 look = normalize(rayOrigin - target);\n    // Up vector\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Set up camera matrix\n    vec3 cameraForward = -look;\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n\n    // TODO [Task 1] Construct the ray direction vector\n    vec2 uv = vec2(0.0);\n    vec3 rayDirection = vec3(0.0);\n    float u = gl_FragCoord.x/iResolution.x;\n    float v = gl_FragCoord.y/iResolution.y;\n    u= 2.0f*u - 1.0f;\n    v= 2.0f*v - 1.0f;\n    u= u*(iResolution.x/iResolution.y);\n    uv = vec2(u, v);\n\n    rayDirection = vec3(uv, focalLength);\n\n    cameraRight *= rayDirection.x;\n    cameraUp *= rayDirection.y;\n    cameraForward *= rayDirection.z;\n    rayDirection = normalize(cameraRight + cameraUp + cameraForward);\n\n    PrimitiveDist rayMarchResult = raymarch(rayOrigin, rayDirection);\n    vec3 col = vec3(0.0);\n    if (rayMarchResult.primitive != NO_INTERSECT) {\n        col = render(rayOrigin, rayDirection, rayMarchResult.dist, rayMarchResult.primitive);\n    } else {\n        vec2 cellPos = fract(fragCoord/iResolution.xy * 10.);\n        vec2 cellId = floor(fragCoord/iResolution.xy * 10.);\n        \n        float mixedFull = smoothRand(cellPos, cellId);\n        col = mixedFull * vec3(1.0, 1.0, 1.0) + vec3(0.2, 0.45, 0.650);\n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}