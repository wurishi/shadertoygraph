{"ver":"0.1","info":{"id":"XtdBWn","date":"1539273951","viewed":966,"name":"Conway's game of light","username":"saidwho12","description":"This was just a test of trying to merge conway's game of life with my pathtracer. I chose this way to do it but I know there's alternatives... Enjoy! :-)","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["test","conway","pt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(sqrt(color.rgb), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T(x, y) texelFetch(iChannel0, ivec2(fragCoord) + ivec2(x, y), 0).r\n#define saturate(x) clamp(x,0.0,1.0)\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst int brushSize = 15;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 iColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 oColor = iColor;\n    \n    if(iFrame == 0) {\n        vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n        float h = hash12(fragCoord) * (1.0 - pow(saturate(length(p)), 3.0));\n        if(h > 0.5) {\n            oColor = vec4(1, 0, 0, 0);\n        } else {\n            oColor = vec4(0);\n        }\n    } else if(iMouse.z > 0.0 && int(distance(iMouse.xy, fragCoord)) < brushSize) {\n    \toColor.r = 1.0;\n\t} else {\n    \tint n = int(T(-1, 0)  + T(1, 0)  + T(0, -1) + T(0, 1)\n            \t  + T(-1, -1) + T(1, -1) + T(-1, 1) + T(1, 1));\n        \n        if(int(iColor.r) == 1 && (n > 3 || n < 2)) {\n            oColor.r = 0.0;\n        } else if(int(iColor.r) == 0) {\n            if(n == 3) {\n            \toColor.r = 1.0;\n            }\n        }\n    }\n    \n    fragColor = vec4(oColor.rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float HASHSCALE1;\nvec3 HASHSCALE3;\nvec4 HASHSCALE4;\n\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 fade(in vec2 p) {\n\treturn 6.0*pow(p,vec2(5.0)) - 15.0*pow(p,vec2(4.0)) + 10.0*pow(p,vec2(3.0));\n}\n\nfloat perlin(in vec2 p) {\n\tvec2 a = floor(p), b = ceil(p);\n    vec2 s = fade(p-a);\n    \n    float a1 = hash12(a)  * radians(360.0);\n    vec2 v1 = vec2(cos(a1), sin(a1));\n    \n    vec2 p2 = vec2(b.x, a.y);\n    float a2 = hash12(p2) * radians(360.0);\n    vec2 v2 = vec2(cos(a2), sin(a2));\n    \n    vec2 p3 = vec2(a.x, b.y);\n    float a3 = hash12(p3) * radians(360.0);\n    vec2 v3 = vec2(cos(a3), sin(a3));\n    \n    float a4 = hash12(b) * radians(360.0);\n    vec2 v4 = vec2(cos(a4), sin(a4));\n    \n    vec2 d1 = normalize(v1-p);\n    vec2 d2 = normalize(v2-p);\n    vec2 d3 = normalize(v3-p);\n    vec2 d4 = normalize(v4-p);\n    \n    float g1 = dot(d1, v1);\n    float g2 = dot(d2, v2);\n    float g3 = dot(d3, v3);\n    float g4 = dot(d4, v4);\n    \n    return mix(mix(g1, g2, s.x), mix(g3, g4, s.x), s.y);\n}\n\nconst int N = 4;\n\nfloat fbm(in vec2 p) {\n    float f = 0.0;\n    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);\n    \n    float q = 0.5;\n    for(int i = 0; i < N; i++) {\n        f += q*perlin(p);\n        p = m*p;\n        q *= 0.5;\n    }\n    \n    f = f * 0.5 + 0.5;\n    return f;\n}\n\nconst float RAY_T_MAX = 1e32;\nconst float EPSILON = 1e-3;\n\nconst int MAT_COMMON = 0;\nconst int MAT_REFRACTIVE = 1;\nconst int MAT_EMISSIVE = 2;\nconst int MAT_CHECKER = 3;\nconst int MAT_MOTIF = 4;\nconst int MAT_CAT = 5;\nconst int MAT_TEST = 6;\n\n//#define ENABLE_CAT_ANIMATION\n\nconst float CAT_ANIMATION_TIME = 0.5; // Seconds for the 6 frames\n\nconst int OBJ_TYPE_SPHERE = 0;\nconst int OBJ_TYPE_PLANE = 1;\n\nconst int RAY_BOUNCE_COUNT = 6;\nconst int MONTE_CARLO_FRAMES_MAX = 1;\n\nconst int SAMPLE_COUNT = 16;\n\nconst float PI = 3.14159;\nconst float PI_2 = 2.0 * PI;\nconst float SQRT_8 = 2.82842712475;\n\nconst float goldIor = 0.470;\nconst float acrylicIor = 1.490;\nconst float glassIor = 1.5;\nconst float airIor = 1.0;\nconst float diamondIor = 2.418;\nconst float iceIor = 1.309;\n\nconst vec3 diamondAlbedo = vec3(0.0);\nconst vec3 charcoalAlbedo = vec3(0.04);\nconst vec3 wornAsphaltAlbedo = vec3(0.12);\n\nconst vec3 silverSpecular = vec3(0.971519, 0.959915, 0.915324);\nconst vec3 titaniumSpecular = vec3(0.541931, 0.496791, 0.449419);\nconst vec3 goldSpecular = vec3(1.0, 0.765557, 0.336057);\nconst vec3 waterSpecular = vec3(0.020373188);\nconst vec3 diamondSpecular = vec3(0.171968833);\n\nconst vec3 dialectricSpecular = vec3(0.04);\n\n#define ENABLE_SKY_LIGHT\n\nstruct Material {\n\tvec3 albedo;\n    vec3 specular;\n    float roughness;\n    float ior;\n    int type;\n};\n    \nstruct Sphere {\n\tvec3 center;\n    float radius;\n    Material mat;\n};\n\nstruct Plane {\n    vec3 normal;\n\tfloat height;\n    Material mat;\n};\n\nconst int OBJ_COUNT_SPHERE = 12;\nSphere spheres[OBJ_COUNT_SPHERE] = Sphere[OBJ_COUNT_SPHERE](\n    Sphere(vec3(-0.3, 0.15, 0.3), 0.15, Material(vec3(1.7, 0.6, 0.6), dialectricSpecular, 0.5, glassIor, MAT_REFRACTIVE)),\n    Sphere(vec3(0, 0.25, -0.1), 0.25, Material(vec3(0.625, 0.9, 0.7), vec3(0.1), 0.1, acrylicIor, MAT_COMMON)),\n    Sphere(vec3(0.3, 0.2, 0.3), 0.2, Material(vec3(0.9, 0.5, 0.5), vec3(0.4), 0.6, acrylicIor, MAT_COMMON)),\n    Sphere(vec3(0, 0.7, 0.1), 0.07, Material(vec3(50), vec3(0), 0.0, 0.1, MAT_EMISSIVE)),\n\tSphere(vec3(0, 0.3, 0.7), 0.05, Material(vec3(55), vec3(0), 0.0, 0.1, MAT_EMISSIVE)),\n    Sphere(vec3(-0.6, 0.6, 0.0), 0.05, Material(vec3(75), vec3(0), 0.0, 0.1, MAT_EMISSIVE)),\n    Sphere(vec3(-0.45, 0.2, -0.25), 0.2, Material(vec3(0), goldSpecular, 0.1, goldIor, MAT_COMMON)),\n\tSphere(vec3(0.45, 0.175, -0.4), 0.175, Material(vec3(0), silverSpecular, 0.4, 0.3, MAT_COMMON)),\n\tSphere(vec3(0.8, 0.25, 0), 0.07, Material(vec3(55), vec3(0), 0.0, 0.1, MAT_EMISSIVE)),\n    Sphere(vec3(-0.5, 0.4, 0.4), 0.05, Material(2.0*vec3(125, 110, 100), vec3(0), 0.0, 0.1, MAT_EMISSIVE)),\n    Sphere(vec3(0.0, 0.15, -0.5), 0.15, Material(vec3(1), vec3(0), 0.02, glassIor, MAT_REFRACTIVE)),\n    Sphere(vec3(0.0, 0.4, -0.7), 0.05, Material(vec3(80, 95, 100), vec3(0), 0.02, 0.0, MAT_EMISSIVE))\n);\n\nfloat Intersect_Sphere( in vec3 ro, in vec3 rd, in Sphere sph ) {\n    vec3 v = ro-sph.center.xyz;\n    float b = 2.0*dot(rd,v), c = dot(v,v) - sph.radius*sph.radius,\n    delta = b*b - 4.*c;\n    if(delta < 0.) return -1.0;\n    else if(delta == 0.0 && -b >= 0.0) return -b*0.5;\n    else if(delta > 0.0) {\n        float h = sqrt(delta);\n        float t0 = -b+h, t1 = -b-h;\n        float tmin = min(t0,t1), tmax = max(t0,t1);\n        return (tmin > 0.0 ? tmin : tmax > 0.0 ? tmax : -1.0)*0.5;\n    }\n}\n\nvec3 Normal_Sphere( in vec3 p, in Sphere sph ) {\n\treturn (p - sph.center) / sph.radius;\n}\n\nconst int OBJ_COUNT_PLANE = 1;\nPlane planes[OBJ_COUNT_PLANE] = Plane[OBJ_COUNT_PLANE](\n    #ifdef ENABLE_CAT_ANIMATION\n    Plane(vec3(0,1,0), 0.0, Material(vec3(1.0), dialectricSpecular, 0.95, 0.1, MAT_CAT))\n    #else\n    Plane(vec3(0,1,0), 0.0, Material(vec3(1.0), dialectricSpecular, 0.99, 0.1, MAT_MOTIF))\n\t#endif\n);\n\nfloat Intersect_Plane( in vec3 ro, in vec3 rd, in Plane p ) {\n    return dot(p.normal*p.height-ro, p.normal)/dot(rd,p.normal);\n}\n\nfloat udBox( in vec2 p, in vec2 b ) {\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r ) {\n\treturn length(p) - r;\n}\n\nmat2 rotate( in float a ) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nstruct Hit_Info {\n\tfloat t;\n    vec3 p;\n    vec3 normal;\n    int index;\n    int type;\n    Material mat;\n};\n\nbool hit( in vec3 ro, in vec3 rd, inout Hit_Info info ) {\n    info.index = -1;\n    info.t = RAY_T_MAX;\n    \n    for(int i = 0; i < OBJ_COUNT_SPHERE; ++i) {\n    \tfloat t = Intersect_Sphere(ro, rd, spheres[i]);\n        if(t < 0.0) continue;\n        info.t = min(info.t, t);\n        if(info.t == t) {\n        \tinfo.index = i;\n        \tinfo.type = OBJ_TYPE_SPHERE;\n        }\n    }\n    \n    for(int i = 0; i < OBJ_COUNT_PLANE; ++i) {\n    \tfloat t = Intersect_Plane(ro, rd, planes[i]);\n        if(t < 0.0) continue;\n        info.t = min(info.t, t);\n        if(info.t == t) {\n        \tinfo.index = i;\n        \tinfo.type = OBJ_TYPE_PLANE;\n        }\n    }\n    \n    if(info.index >= 0) {\n        info.p = ro + rd * info.t;\n        if(info.type == OBJ_TYPE_SPHERE) {\n        \tinfo.normal = Normal_Sphere(info.p, spheres[info.index]);\n        \tinfo.mat = spheres[info.index].mat;\n            \n        } else if(info.type == OBJ_TYPE_PLANE) {\n        \tinfo.normal = planes[info.index].normal;\n            info.mat = planes[info.index].mat;\n        }\n        \n        if(info.mat.type == MAT_CHECKER) {\n            vec2 p = info.p.xz * 5.0;\n            float a = float(int(p.x)%2 == int(p.y)%2);\n        \tinfo.mat.albedo = vec3(0.05 + 0.2*a);\n            //info.mat.specular = info.mat.albedo;\n            //info.mat.roughness = 0.8 + 0.35 * a;\n        }\n    \t\n        if(info.mat.type == MAT_CAT) {\n            float w = 40.0/256.0;\n\t        float ofx = floor( mod( (iTime * 6.0) / CAT_ANIMATION_TIME, 6.0 ) );\n\n            vec2 uv = fract(info.p.xz);\n            uv = vec2(uv.x * w + ofx * w, uv.y);\n        \tinfo.mat.albedo = texture(iChannel2, uv).rgb;\n            //info.mat.albedo = vec3(uv,0);\n        }\n        \n        const vec3 yellow = vec3(1, 1, 0);\n        const float magic = 0.70710678118;\n        \n        if(info.mat.type == MAT_MOTIF) {\n        \tvec2 uv = fract(info.p.xz * 2.0);\n            vec2 p = uv * 2.0 - 1.0;\n            float t = min(sdBox(p, vec2(magic)), sdBox(rotate(radians(45.0)) * p, vec2(magic)));\n           \tfloat l = clamp(cos(32.0 * radians(360.0) * abs(t)),0.0,1.0) * exp(-12.0 * abs(t));\n            info.mat.specular = t < 0.0 ? dialectricSpecular : goldSpecular;\n            \n            info.mat.albedo = max(vec3(t < 0.0 ? 3.0 : 1.0)\n                                  //- clamp(exp(-3.0 * abs(t * 32.0)), EPSILON, 1.0)\n                                  - l\n                                  , 0.0);\n            info.mat.roughness = t < 0.0 ? 1.0 : 0.4;\n        }\n        \n        if(info.mat.type == MAT_TEST) {\n            vec2 uv = fract(info.p.xz);\n        \tvec2 p = uv * 2.0 - 1.0;\n            float t = SQRT_8;\n            t = min(t, max(sdCircle(p, 0.5), -sdCircle(p-vec2(0.3,0), 0.5)));\n            t = min(t, max(sdCircle(p-vec2(0.5), 0.3), -sdCircle(p-vec2(0.3), 0.3)));\n            info.mat.albedo += 1.0-clamp(t * 100.0, 0.0, 1.0);\n        }\n        \n        return true;\n    }\n    \n    return false;\n}\n\nvec3 phong(in Material mat, in vec3 N, in vec3 L, in vec3 V) {\n\tvec3 R = reflect(-L, N);\n    vec3 diffuse = mat.albedo * max(dot(N,L),0.0);\n    vec3 specular = mat.specular * pow(max(dot(R,V),0.0),mat.roughness);\n    return diffuse + specular;\n}\n\nfloat oren(in vec3 N, in vec3 L, in vec3 V, in float roughness) {\n\tfloat r2 = roughness*roughness;\n\tfloat A = 1.0 - 0.5*(r2/(r2+0.33));\n    float B = 0.45*(r2/(r2+0.09));\n    float dotNL = dot(N, L);\n    float dotNV = dot(N, V);\n    float ga = dot(V - N*dotNV , N - N*dotNL);\n\treturn max(dotNL,0.0) * (A + B * max(0.0,ga) * sqrt((1.0 - dotNV*dotNV) * (1.0 - dotNL*dotNL)) / max(dotNL, dotNV));\n}\n\nfloat chiGGX(in float v) {\n\treturn v > 0.0 ? 1.0 : 0.0;\n}\n\nfloat D_GGX(in vec3 n, in vec3 h, in float alpha) {\n\tfloat alpha2 = alpha * alpha;\n    float NoH = dot(n,h);\n    float NoH2 = NoH * NoH;\n    float den = NoH2 * (alpha2 + (1.0 - NoH2)/NoH2);\n    return (chiGGX(NoH2) * alpha2) / (PI * den * den);\n}\n\nfloat G_GGX(in vec3 n, in vec3 h, in vec3 v, in float alpha) {\n    float VoH2 = max(dot(v,h),0.0);\n    float chi = chiGGX( VoH2 / max(dot(v,n),0.0) );\n    VoH2 = VoH2 * VoH2;\n    float tan2 = ( 1.0 - VoH2 ) / VoH2;\n    return (chi * 2.0) / ( 1.0 + sqrt( 1.0 + alpha * alpha * tan2 ) );\n}\n\nvec3 Fresnel_Schlick(in float cosT, in vec3 F0) {\n  return F0 + (1.0-F0) * pow( 1.0 - cosT, 5.0);\n}\n\nvec3 ggx(in vec3 N, in vec3 L, in vec3 V, in float roughness, in vec3 F0) {\n    roughness = max(roughness, 0.01);\n    vec3 R = reflect(L, N);\n    float NoV = max(dot(N,V),0.0);\n    vec3 H = normalize(L+V);\n    float NoH = max(dot(N,H),0.0);\n    float D = D_GGX(N, H, roughness);\n    float G = G_GGX(N, H, V, roughness) * G_GGX(N, H, L, roughness);\n    float cosT = max(dot(N,L),0.0);\n    float sinT = sqrt( 1.0 - cosT * cosT);\n    vec3 F = Fresnel_Schlick(max(dot(V,H),0.0), F0);\n    \n    //return D * F * G;\n    float denom = clamp( 4.0 * (NoV * NoH + 0.05) ,0.0,1.0);\n\treturn vec3(D * G) / denom;\n}\n\nvec2 uv = vec2(0);\nfloat seed = 0.0;\n\nfloat Rand() {\n    seed++;\n\treturn hash13(vec3(uv, hash11(seed*1e-7) ));\n}\n\nvec3 RandDirectionSize(vec3 normal, float size)\n{\n\tfloat theta = Rand() * PI_2;\n    float cosT = Rand();\n    float sinT = sqrt(1.0 - cosT * cosT);\n\tvec3 tangent = normalize(cross(normal.yzx, normal));\n    vec3 binormal = cross(normal, tangent);\n\treturn normalize((tangent * cos(theta) + binormal * sin(theta)) * sinT * size + normal * cosT);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd ) {\n\tvec3 color = vec3(0.0);\n    vec3 falloff = vec3(1.0);\n    \n    vec3 lightPos = vec3(1, 2, 3);\n    float ior = airIor;\n    \n    for(int i = 0; i < RAY_BOUNCE_COUNT; i++) {\n        Hit_Info info;\n        if(hit(ro, rd, info)) {\n            \n            vec3 V = -rd;\n            \n            if(info.mat.albedo == vec3(0) || Rand() < 0.5) {\n                vec3 R = reflect(rd, info.normal);\n                rd = RandDirectionSize(R, info.mat.roughness);\n                if(info.mat.roughness == 0.0) {\n                \trd = R;\n                }\n                ro = info.p + rd * EPSILON;\n                falloff *= info.mat.roughness *\n                    info.mat.specular *\n                    max(ggx(info.normal, rd, V, info.mat.roughness, vec3(0.0)),0.0);\n                \n            } else {\n            \tif(info.mat.type == MAT_EMISSIVE) {\n                    color = info.mat.albedo * falloff;\n                    break;\n                    \n                } else {\n                    if(info.mat.type == MAT_REFRACTIVE) {\n                        if(ior == info.mat.ior) {\n                            //rd = RandDirectionSize(-info.normal, 1.0);\n                            //R = refract(rd, -info.normal, info.mat.ior / ior);\n                            //ior = info.mat.ior;\n                        \trd = refract(V, -info.normal, airIor/ior);\n                            ior = airIor;\n                        } else {\n                            //rd = RandDirectionSize(info.normal, 1.0);\n                            //R = refract(rd, info.normal, ior / info.mat.ior);\n                            //ior = airIor;\n                        \trd = refract(V, info.normal, ior/info.mat.ior);\n                            ior = info.mat.ior;\n                        \n                        }\n                        \n                        //float dotRV = max(dot(R,V),0.0);\n                    \tro = info.p + rd * EPSILON;\n                    \tfalloff *= info.mat.albedo;\n                        \n                    } else {\n                        rd = RandDirectionSize(info.normal, 1.0);\n                    \tro = info.p + rd * EPSILON;\n                        //falloff *= phong(info.mat, info.normal, rd, V);\n                        //falloff *= max(dot(info.normal,rd),0.0) / PI;\n                        falloff *= (info.mat.albedo * max(oren(info.normal, rd, V, info.mat.roughness),0.0));\n                        //falloff *= info.mat.albedo;\n                    }\n                }\n            }\n        }\n#ifdef ENABLE_SKY_LIGHT\n        else {\n            color = texture(iChannel1, rd).rgb * falloff;\n            break;\n        }\n#endif        \n        //fragColor.rgb = vec3(fract(info.t));\n        //return;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uv = fragCoord/iResolution.xy;\n    seed = iTime;\n    \n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.xy;\n    float fovy = radians(75.0);\n    float halfHeight = atan(fovy * 0.5);\n    float halfWidth =  (iResolution.x/iResolution.y) * halfHeight;\n    \n    vec2 m = (2.0 * iMouse.xy - iResolution.xy)/iResolution.y;\n    float alpha = m.x * radians(180.0);\n    \n    vec3 lookAt = vec3(0);\n    //vec3 ro = 1.5*vec3(sin(alpha), 0, cos(alpha)) + vec3(0,m.y,0);\n    vec3 ro = vec3(-0.5, 1, 1);\n    \n    vec3 forward = normalize(lookAt - ro);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec2 pixelSize = 0.5/iResolution.xy;\n    \n    HASHSCALE1 = 443.8975;\n    HASHSCALE3 = vec3(443.897, 441.423, 437.195);\n    HASHSCALE4 = vec4(443.897, 441.423, 437.195, 444.129);\n    \n    vec3 color = vec3(0);\n    for(int i = 0; i < SAMPLE_COUNT; ++i) {\n        vec3 rd = normalize(forward + (p.x * halfWidth * right + pixelSize.x * (Rand() * 2.0 - 1.0))\n                                    + (p.y * halfHeight * up  + pixelSize.y * (Rand() * 2.0 - 1.0)));\n    \tcolor += shade(ro, rd);\n    }\n    color /= float(SAMPLE_COUNT);\n    fragColor = vec4(0);\n    vec4 inColor = texture(iChannel0, uv);\n    \n    float f1 = texelFetch(iChannel2, ivec2(fragCoord),0).r;\n    if(iFrame == 0) inColor.w = -1.0;\n    fragColor.w = f1 == 1.0 && inColor.w == -1.0 ? float(iFrame) : inColor.w; \n\n    HASHSCALE1 = .1031;\n    HASHSCALE3 = vec3(.1031, .1030, .0973);\n    HASHSCALE4 = vec4(.1031, .1030, .0973, .1099);\n\n    //inColor.w = float(iFrame);\n    float f0 = 5.0/float(iFrame - int(inColor.w) + 1);\n    \n    uv.y *= iResolution.y / iResolution.x;\n    \n    fragColor.rgb = mix(inColor.rgb, mix(vec3(0)/*vec3(fbm(uv*20.0)) * .025*/, color, f1), f0);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}