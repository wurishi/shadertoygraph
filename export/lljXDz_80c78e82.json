{"ver":"0.1","info":{"id":"lljXDz","date":"1443027506","viewed":271,"name":"Mandelbrot Exponent Sweep","username":"roombarampage","description":"sweeping the exponent in the fractal calculation from 0 to 10","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","exponent","sweep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n  programmer: jonathan potter\n  github: https://github.com/jonathan-potter\n  repo: https://github.com/jonathan-potter/shadertoy-fractal\n*/\n\nconst int MAX_ITERATIONS = 256;\nconst float pi = 3.1415926;\n\nstruct complex { \n  float real;\n  float imaginary;\n};\n    \ncomplex complexExp(complex z, float exponent) {\n  float magnitude = sqrt(z.real * z.real + z.imaginary * z.imaginary);\n    \n  float theta;\n  if (z.real == 0.0) {\n    theta = pi / 2.0 * sign(z.imaginary);\n  } else {\n    theta = atan(z.imaginary, z.real);\n  }\n\n  float newMagnitude = pow(magnitude, exponent);\n  float newTheta = theta * exponent;\n\n  complex newZ;\n  newZ.real      = newMagnitude * cos(newTheta);\n  newZ.imaginary = newMagnitude * sin(newTheta);\n\n  return newZ;\n}\n\nint fractal(complex c, complex z) {\n  for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++) {\n\n    // z <- z^2 + c\n    complex z2 = complexExp(z, 5.0 * (1.6 + cos((iTime + pi) / 6.0)));\n\n    z.real = z2.real + c.real;\n    z.imaginary = z2.imaginary + c.imaginary;\n\n    if (z.real * z.real + z.imaginary * z.imaginary > 4.0) {\n      return iteration;\n    }\n  }\n\n  return 0;\n}\n\nint mandelbrot(vec2 coordinate) {\n  complex c = complex(coordinate.x, coordinate.y);\n  complex z = complex(0.0, 0.0);\n\n  return fractal(c, z);\n}\n\nint julia(vec2 coordinate, vec2 offset) {\n  complex c = complex(offset.x, offset.y);\n  complex z = complex(coordinate.x, coordinate.y);\n\n  return fractal(c, z);\n}\n\nvec2 fragCoordToXY(vec2 fragCoord) {\n  vec2 relativePosition = fragCoord.xy / iResolution.xy;\n  float aspectRatio = iResolution.x / iResolution.y;\n\n  vec2 cartesianPosition = (relativePosition - 0.5) * 4.0;\n  cartesianPosition.x *= aspectRatio;\n\n  return cartesianPosition;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 coordinate    = fragCoordToXY(fragCoord);\n\n  int mandelbrotValue = mandelbrot(coordinate);\n    \n  float mandelbrotColor = 5.0 * float(mandelbrotValue) / float(MAX_ITERATIONS);\n\n  fragColor = vec4(mandelbrotColor, mandelbrotColor, mandelbrotColor, 1.0);\n}\n","name":"","description":"","type":"image"}]}