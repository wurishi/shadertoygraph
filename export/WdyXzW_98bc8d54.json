{"ver":"0.1","info":{"id":"WdyXzW","date":"1573497316","viewed":66,"name":"Old school TV","username":"GrooveDZX","description":"Geometric Modeling practical work","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spheremarchingcsg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ID3D - TP : Blobs\n// Teacher : Eric Galin\n// Student : Zahidi Ali\n#define PI 3.14\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T = 0.5;\n\nconst float rA = 10.0; // Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB = 40.0;\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R)\n{\n  float u = clamp(x / R, 0.0, 1.0);\n  float v = (1.0 - u * u);\n  return v * v * v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n  return e * falloff(length(p - c), R);\n}\n\n// Segment skeleton\n// p : point\n// a : First extremity of the skeleton\n// b : Second extremity of the skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n  float len;\n  vec3 u = normalize(b - a);\n  vec3 ap = p - a;\n  vec3 bp = p - b;\n  if (dot(ap, u) < 0.) // We are on the left of the segment\n    len = length(p - a);\n  else if (dot(bp, u) > 0.) //We are on the right of the segment\n    len = length(b - p);\n  else\n    len = sqrt((length(ap) * length(ap)) - (dot(ap, u) * dot(ap, u))); // On calcule la distance au segment\n  return e * falloff(len, R);\n}\n\n// Disk skeleton\n// p : point\n// c : center of skeleton\n// n : normal of the skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat disk(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.0;\n  // First get the distance to c on the disk plane\n  vec3 pc = p - c;\n  float pcDn = abs(dot(pc, n));\n  float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n  if (projected2C <= R)\n    len = pcDn;\n  else\n  {\n    len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n  }\n  return e * falloff(len, R);\n}\n\n// Circle skeleton\n// p : point\n// c : center of skeleton\n// n : normal of the skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat circle(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.0;\n  // First get the distance to c on the disk plane\n  vec3 pc = p - c;\n  float pcDn = abs(dot(pc, n));\n  float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n  if (projected2C <= R / 2.)\n  {\n    len = R - projected2C;\n  }\n  else\n  {\n    len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n  }\n  return e * falloff(len, R);\n}\n\n// Cylinder skeleton\n// p : point\n// c : center of skeleton\n// n : orientation of the skeleton\n// e : energy associated to skeleton\n// H : height of the skeleton\n// R : radius\nfloat cylinder(vec3 p, vec3 c, vec3 n, float e, float H, float R)\n{\n  float len = 0.;\n    \n  vec3 pc = p - c;\n  float vDist = abs(dot(pc, n));\n  float hDist = sqrt(pow(length(pc), 2.0) - pow(vDist, 2.0));\n\n  // \tOrientate the normal to where p is from c\n  //If we are on the extremities\n  if (vDist > H)\n  {\n    if (dot(pc, n) < 0.0)\n      n = -n;\n    //Compute center of the concerned disk\n    vec3 cc = c + (n * H);\n\n    vec3 pcc = p - cc;\n    float pccDn = abs(dot(pcc, n));\n    float projected2CC = sqrt(pow(length(pcc), 2.0) - pow(pccDn, 2.0));\n    if (projected2CC <= R)\n      len = pccDn;\n    else\n    {\n      len = sqrt(pow(pccDn, 2.0) + pow(projected2CC - R, 2.0));\n    }\n  }\n  else\n  {\n    //\tget the coplanar disk center to the point\n    vec3 cc = c + n * dot(p - c, n);\n    len = length(p - cc) - R;\n  }\n  return e * falloff(len, R);\n}\n\n// Sphere skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat sphere(vec3 p, vec3 c, float e, float R)\n{\n  float len = length(p - c) - R;\n  return e * falloff(len, R);\n}\n\n// Hemisphere skeleton\n// p : point\n// c : center of skeleton\n// n : normal\n// e : energy associated to skeleton\n// R : radius\nfloat hemisphere(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.;\n  if (dot(p - c, n) > 0.) // On top\n  {\n    len = length(p - c) - R;\n  }\n  else\n  {\n    vec3 pc = p - c;\n    float pcDn = abs(dot(pc, n));\n    float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n    if (projected2C <= R)\n      len = pcDn;\n    else\n    {\n      len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n    }\n  }\n  return e * falloff(len, R);\n}\n\n// Bubble skeleton\n// p : point\n// c : center of skeleton\n// n : Elongation axis\n// e : energy associated to skeleton\n// R : radius\nfloat bubble(vec3 p, vec3 c, vec3 n, float e, float R)\n{\n  float len = 0.0;\n  len = length(p - c) - R + min(R, pow(dot(p - c, n), 2.));\n  return e * falloff(len, R);\n}\n\n// Cone skeleton\n// p : point\n// c : center of skeleton\n// n : normal of the skeleton\n// e : energy associated to skeleton\n// H : Height\n// R : radius\nfloat cone(vec3 p, vec3 c, vec3 n, float e, float H, float R)\n{\n  float len = 10.;\n  vec3 pc = p - c;\n  //\tGet the tip\n  vec3 tip = c - n * H;\n  //\tGet the bottom extremity\n  //\tGet the projected Vector on the plane\n  vec3 planeProj = normalize(pc - n * dot(pc, n));\n  //\tCompute the extremity\n  vec3 extremity = c + planeProj * R;\n  //Get the vector going along the edge of the cone\n  vec3 edge = normalize(extremity - tip);\n  //Get the closest point on the cone\n  vec3 q = tip + (edge * dot(p - tip, edge));\n  if (dot(q - extremity, -n) < 0.)\n  {\n    float pcDn = abs(dot(pc, n));\n    float projected2C = sqrt(pow(length(pc), 2.0) - pow(pcDn, 2.0));\n    if (projected2C <= R)\n      len = pcDn;\n    else\n    {\n      len = sqrt(pow(pcDn, 2.0) + pow(projected2C - R, 2.0));\n    }\n  }\n  else if (dot(q - extremity, -n) < H) // If q is in the middle of the cone\n  {\n    //Get the vector going along the edge of the cone and forming a right angle\n    //triangle with p\n    vec3 edge90 = tip + (edge * dot(p - tip, edge)) - tip;\n    len = sqrt(pow(length(p - tip), 2.) - pow(length(edge90), 2.));\n  }\n  else // We are on the top of the cone\n  {\n    len = length(p - tip);\n  }\n\n  return e * falloff(len, R);\n}\n\n// Box skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// W : width of the skeleton\n// H : height of the skeleton\n// D : depth of the skeleton\nfloat box(vec3 p, vec3 c, float e, float R, float W, float H, float D)\n{\n  float len = 0.;\n  vec3 lenVec = vec3(0.0, 0.0, 0.0);\n  \n  //Component wise length computation\n  lenVec.x = max(abs(c.x - p.x) - W / 2.0,0.);\n  lenVec.y = max(abs(c.y - p.y) - H / 2.0,0.);\n  lenVec.z = max(abs(c.z - p.z) - D / 2.0,0.);\n    \n  len =  length(lenVec);\n    \n  return e * falloff(len, R);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nfloat Blend(float a, float b)\n{\n  return a + b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a, float b)\n{\n  return max(a, b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a, float b)\n{\n  return min(a, b);\n}\n\n// Substraction\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Minus(float a, float b, float T)\n{\n  return min(a, 2. * T - b);\n}\n\n// Animation interpolation\nfloat interpolation(float duration, float transitionDuration, float transition1, float transition2)\n{\n  float t = mod(iTime, duration);\n  if (t < transition1 || t > transition2 + transitionDuration)\n    return 1.;\n  else if (t > transition1 + transitionDuration && t < transition2)\n    return 0.;\n  else if (t < transition2)\n    return cos((t - transition1) / transitionDuration * (PI / 2.));\n  else\n    return sin((t - transition2) / transitionDuration * (PI / 2.));\n}\n\n// Potential field of the object\n// p : point\nvec2 Object(vec3 p)\n{\n  p.z = -p.z;\n  float v;\n  /* \n  // PRIMITIVES\n  float seg = segment(p, vec3(0.0, 0.0, 0.0), vec3(5.0, 0.0, 0.0), 1.0, 1.0);\n  float dis = disk(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 2.0);\n  float cir = circle(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 5.0);\n  float cyl = cylinder(p, vec3(0.0, 0.0, 0.0), rotateZ(vec3(0.0, 0.0, 1.0), 10. * cos(iTime)), 1., 5.0, 1.0);\n  float sph = sphere(p, vec3(1., 1., 1.), 1.0, 1.0);\n  float bub = bubble(p, vec3(0., 0., 0.), vec3(1.0, 0., 0.), 1.0, 1.0);\n  float con = cone(p, vec3(0., 0., 0.), vec3(-1.0, 0., 0.), 5.0, 3.0, 1.0);\n  float bx = box(p, vec3(0.0, 0.0, 0.0), 1., 1., 1., 3., 2.);\n  */\n  float t = 1. - interpolation(30., 5., 5., 20.); // Animation factor\n  vec3 tvPos = vec3(0.0, 0.0, 0.0);\n  vec3 tvNormal = vec3(0.0, 0.0, -1.0); // Points to the front of the tv\n  vec3 tvUp = vec3(0.0, 1.0, .0);\n  vec3 hOffset = t * 4. * tvNormal;\n  vec3 vOffset = t * 2. * tvUp;\n  vec3 headPos = tvPos + tvUp * 2.5;\n  vec3 screenPos = (tvPos + tvNormal * 0.75) + hOffset;\n    \n  float tvWidth = 7.;\n  float tvHeight = 5.;\n  float tvDepth = 2.;\n  float antennaWidth = .75;\n  float tvBody = box(p, tvPos, 1., 1., tvWidth, tvHeight, tvDepth);\n  float tvHead = hemisphere(p, headPos, tvUp, 1., antennaWidth);\n  float screen = box(p, screenPos, 1., 1., tvWidth - 2., tvHeight - 2., tvDepth - 1.);\n  float buttonLeft = cylinder(p, tvPos - vec3(tvWidth / 2. - 0.5, tvHeight / 2. - .25, tvDepth / 2.) + hOffset,\n                              tvNormal, 1.0, 0.5, .25);\n  float buttonRight = cylinder(p, tvPos - vec3(-tvWidth / 2. + 0.5, tvHeight / 2. - .25, tvDepth / 2.) + hOffset,\n                               tvNormal, 1.0, 0.5, .25);\n  float tvBack = cone(p, tvPos - tvDepth / 2. * tvNormal - hOffset, tvNormal, 1., 3., 1.5);\n\n  //DETAILS\n\n  tvHead = Union(tvHead, segment(p, headPos + t * 2. * (tvNormal * 1.5 + tvUp * 3. - 2. * cross(tvNormal, tvUp)),\n                                 headPos + tvNormal * 1.5 + tvUp * 3. - 2. * cross(tvNormal, tvUp) +\n                                     t * 2. * (tvNormal * 1.5 + tvUp * 3. - 2. * cross(tvNormal, tvUp)),\n                                 1.0,\n                                 .25));\n  tvHead = Union(tvHead, segment(p, headPos + t * 2. * (tvNormal * 1.5 + tvUp * 3. + 2. * cross(tvNormal, tvUp)),\n                                 headPos + tvNormal * 1.5 + tvUp * 3. + 2. * cross(tvNormal, tvUp) +\n                                     +t * 2. * (tvNormal * 1.5 + tvUp * 3. + 2. * cross(tvNormal, tvUp)),\n                                 1.0,\n                                 .25));\n  tvBody = Minus(tvBody,\n                 box(p, tvPos + tvNormal, 1., 1., tvWidth - 2., tvHeight - 2., tvDepth - 1.), T);\n\n  tvBody = Minus(tvBody,\n                 cylinder(p, tvPos - vec3(tvWidth / 2. - 0.5, tvHeight / 2. - .25, tvDepth / 2.),\n                          tvNormal, 1.0, 0.5, .25),\n                 T);\n  tvBody = Minus(tvBody,\n                 cylinder(p, tvPos - vec3(-tvWidth / 2. + 0.5, tvHeight / 2. - .25, tvDepth / 2.),\n                          tvNormal, 1.0, 0.5, .25),\n                 T);\n\n  tvBody = Minus(tvBody,\n                 segment(p, tvPos - vec3(tvWidth / 2. - 2., tvHeight / 2. - .25, tvDepth / 2. + .5),\n                         tvPos - vec3(-tvWidth / 2. + 2., tvHeight / 2. - .25, tvDepth / 2. + .5),\n                         1., .5),\n                 T);\n\n  tvBody = Minus(tvBody,\n                 cone(p, tvPos - tvDepth / 2. * tvNormal, tvNormal, 1., 3., 1.5),\n                 T);\n\n  v = Union(tvBody, tvHead);\n  v = Union(v, screen);\n  v = Union(v, buttonLeft);\n  v = Union(v, buttonRight);\n  v = Union(v, tvBack);\n  if (screen > 0.5)\n    return vec2(v - T, dot(p - tvPos, cross(tvNormal, tvUp)) / 4.);\n  else\n    return vec2(v - T, -999.);\n}\n\n// Calculate object normal\n// p : point\nvec4 ObjectNormal(in vec3 p)\n{\n  float eps = 0.0001;\n  vec3 n;\n  vec2 v = Object(p);\n  n.x = Object(vec3(p.x + eps, p.y, p.z)).x - v.x;\n  n.y = Object(vec3(p.x, p.y + eps, p.z)).x - v.x;\n  n.z = Object(vec3(p.x, p.y, p.z + eps)).x - v.x;\n  return vec4(normalize(n), v.y);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h, out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for (int i = 0; i < Steps; i++)\n  {\n    s = i;\n    vec3 p = o + t * u;\n    float v = Object(p).x;\n    // Hit object\n    if (v > 0.0)\n    {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += Epsilon;\n    // Escape marched far away\n    if (t > rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h, out int s)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for (int i = 0; i < Steps; i++)\n  {\n    s = i;\n    vec3 p = o + t * u;\n    float v = Object(p).x;\n    // Hit object\n    if (v > 0.0)\n    {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += max(Epsilon, abs(v) / 4.0);\n    // Escape marched far away\n    if (t > rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  return mix(vec3(0.4, 0.3, 0.75), vec3(0.75, 0.85, 1.0), d.y * 0.5 + 0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25 * Background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5 * (1.0 + dot(n, l));\n\n  c += diff * lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t = float(n) / (float(Steps - 1));\n  return vec3(t, 0.25 + 0.75 * t, 0.5 - 0.5 * t);\n}\n\nvec3 screenColor(float x, float t)\n{\n  // t at 1 means\n  float freq = 10.;\n  float speed = 3.;\n  vec3 col = t * vec3(cos(x * freq + iTime * speed),\n                      cos(x * freq + freq / 2. + iTime * speed),\n                      cos(x * freq + freq + iTime * speed)) +\n             (1. - t) * vec3(0.);\n  // Output to screen\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp * pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  vec2 mouse = iMouse.xy / iResolution.xy;\n\n  /*ro = rotateY(ro, -mouse.x * 5.0);\n  rd = rotateY(rd, -mouse.x * 5.0);\n  ro = rotateZ(ro, -mouse.y * 5.0);\n  rd = rotateZ(rd, -mouse.y * 5.0);*/\n\n  float a = iTime * 0.25;\n  ro = rotateY(ro, a);\n  rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit, s);\n  vec3 pos = ro + t * rd;\n  // Shade background\n  vec3 rgb = Background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec4 nScreen = ObjectNormal(pos);\n    vec3 n = nScreen.xyz;\n    float t = interpolation(30., .25, 5., 24.75);\n    if (nScreen.w == -999.)\n      // Shade object with light\n      rgb = Shade(pos, n);\n    else\n      rgb = screenColor(nScreen.w, t);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}