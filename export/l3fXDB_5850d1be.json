{"ver":"0.1","info":{"id":"l3fXDB","date":"1709907967","viewed":64,"name":"Fast sRGB<->Linear approximation","username":"Gaktan","description":"Top: accurate transform\nBottom: fast approximation\nLeft: Linear to sRGB\nRight: sRGB to Linear\n\nGreen line: safe area\nColor line at the bottom: visualization of the error\n\nSpace to display inverse transform\nCtrl to show only safe area","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["fast","color","linear","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Significantly faster than using a pow\n// Because in one case we use 3 quarter rate instructions, and in the other we use none (instead of 6 with a pow)\n// Of course this is in no way accurate, but can be a good alternative to pow if performance is an issue,\n// and the input are within the safe range\n// These values were found by fitting the LinearTosRgbAccurate and sRgbToLinearAccurate curves to\n// sqrt(x)+y, and (x-y)^2 respectively\n// It is possible that better formulas exist that don't require a pow, but it would certainly increase the number of instructions,\n// which is not desirable in this case\n\n// https://www.desmos.com/calculator/yxu74ajn9e\n\n#define float3 vec3\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// Uncomment to check the accuracy of pow(x, 2.2)\n#define FAST\n\n#ifdef FAST\n    #define LINEAR_TO_SRGB(x) LinearTosRgbFast(x)\n    #define SRGB_TO_LINEAR(x) sRgbToLinearFast(x)\n#else\n    #define LINEAR_TO_SRGB(x) LinearToRgb(x)\n    #define SRGB_TO_LINEAR(x) RgbToLinear(x)\n#endif\n\n\n\n// Range [0.018, 0.85] absolute max error: 0.014\n// Outside this range  absolute max error: 0.042\nfloat3 LinearTosRgbFast( in float3 inColor )\n{\n    // 7 instructions total, 3 quarter rate instructions\n    // Note: saturate here instead of inColor so that it's free. Saturate of NaN is always 0\n    return saturate( sqrt( inColor) + 0.0230462 );\n    //return sqrt( saturate(inColor * 0.9432799447708291) ) + 0.04222389178231906;\n}\n// Range [0.0, 0.87] absolute max error: 0.014\n// Outside this range  absolute max error: 0.046\nfloat3 sRgbToLinearFast( in float3 inColor )\n{\n    // 6 instructions total, 0 quarter rate instructions\n    // Note: no need to saturate, because the result is squared.\n    inColor = inColor - 0.0236101;\n    return inColor * inColor;\n}\n\nfloat3 LinearTosRgbAccurate(in float3 inColor)\n{\n    // 23 instructions total, 6 quarter rate instructions\n    float3 sRGBLo = inColor * 12.92f;\n    float3 sRGBHi = ( pow( abs( inColor ), vec3(1.0f/2.4f) ) * 1.055f ) - 0.055f;\n    //float3 sRGB = ( inColor <= 0.0031308 ) ? sRGBLo : sRGBHi;\n    float3 sRGB   = mix(sRGBHi, sRGBLo, lessThan( inColor, vec3(0.0031308) ));\n    \n    return sRGB;\t\t\t\n}\n\nfloat3 sRgbToLinearAccurate(in float3 inColor)\n{\n    // 26 instructions total, 6 quarter rate instructions\n    float3 linearRGBLo = inColor / 12.92f;\n    float3 linearRGBHi = pow( ( abs( inColor + 0.055f ) ) / 1.055f, vec3(2.4f) );\n    //float3 linearRGB = ( inColor <= 0.04045f ) ? linearRGBLo : linearRGBHi;\n    float3 linearRGB   = mix(linearRGBHi, linearRGBLo, lessThan( inColor, vec3(0.04045f) ));\n    \n    return linearRGB;\n}\n\nfloat3 LinearToRgb(in float3 inColor)\n{\n    // 9 instructions total, 6 quarter rate instructions\n    return pow( abs(inColor), vec3(1.0f/2.2f));\n}\n\nfloat3 RgbToLinear(in float3 inColor)\n{\n    // 9 instructions total, 6 quarter rate instructions\n    return pow(abs(inColor), vec3(2.2f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= 0.5;\n\n\n    vec3 linear = vec3(fract(uv.x*2.0));\n    vec3 srgb   = LinearTosRgbAccurate(linear);\n    \n    // Linear to sRGB (left side)\n    if (uv.x < 0.5)\n    {\n        if (uv.y < 0.5 && uv.y > 0.1)\n        {\n            srgb = LINEAR_TO_SRGB(linear);\n        }\n        else if (uv.y <= 0.1)\n        {\n            vec3 diff = abs(srgb - LINEAR_TO_SRGB(linear));\n            srgb = magma(abs(diff.x)*10.0);\n        }\n        fragColor = vec4(srgb,1.0);\n    }\n    // sRGB to Linear (right side)\n    else\n    {\n        if (uv.y < 0.5 && uv.y > 0.1)\n        {\n            linear = SRGB_TO_LINEAR(srgb);\n        }\n        else if (uv.y <= 0.1)\n        {\n            vec3 diff = abs(linear - SRGB_TO_LINEAR(srgb));\n            linear = magma(abs(diff.x*10.0));\n        }\n        \n        fragColor = vec4(linear,1.0);\n    }\n    \n    float space_pressed =  texelFetch( iChannel0, ivec2(32, 0), 0).x;\n    if (space_pressed > 0.0 && uv.y > 0.1)\n    {\n        if (uv.x < 0.5)\n        {\n            fragColor.rgb = sRgbToLinearAccurate(fragColor.rgb);\n        }\n        else\n        {\n            fragColor.rgb = LinearTosRgbAccurate(fragColor.rgb);\n        }\n    }\n    \n    // Compute range where the error is the lowest\n    bool safe_range = true;\n    if (uv.x < 0.5)\n    {\n        float t = uv.x * 2.0;\n        safe_range = t > 0.016 && t < 0.85;\n    }\n    else\n    {\n        float t = uv.x * 2.0 - 1.0;\n        safe_range = t >= 0.0 && t < 0.87;\n    }\n    \n    if (safe_range && uv.y >= 0.095 && uv.y <= 0.105)\n    {\n        fragColor.rgb = vec3(0.0, 1.0, 0.0);\n    }\n    \n    // Hide unsafe range\n    float ctrl_pressed = texelFetch( iChannel0, ivec2(17, 0), 0).x;\n    if (ctrl_pressed > 0.0)\n    {\n        if (!safe_range)\n        {\n            fragColor.rgb = vec3(0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// matplotlib colormaps + turbo \n// From mattz\n// https://www.shadertoy.com/view/3lBXR3\n\nvec3 magma(float t)\n{\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}","name":"Common","description":"","type":"common"}]}