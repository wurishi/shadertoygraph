{"ver":"0.1","info":{"id":"4XGGD3","date":"1718290877","viewed":28,"name":"GoombasVoronoi ","username":"Goomba00","description":"Animated voronoi diagram","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define SIZE 8\n#define GLOBALSPEED .2\n\nvec2 points[SIZE];\nvec3 colors[SIZE] = vec3[SIZE](vec3(1.000,0.678,0.678), vec3(1.000,0.804,0.702), vec3(0.992,0.961,0.749), vec3(0.780,1.000,0.678), vec3(0.600,1.000,0.847), vec3(0.659,0.851,1.000), vec3(0.682,0.659,1.000), vec3(0.839,0.678,1.000));\n\nbool CircleMask(vec2 uv, vec2 circle, float radius) {\n    float dist = pow((uv.x - circle.x), 2.0) + pow((uv.y - circle.y), 2.0);\n    if(dist < pow(radius, 2.0)){\n        return true;\n    }\n    return false;\n}\n\nint indexMinDistance(vec2 uv, vec2[SIZE] points){\n\n    int index = 0;\n    float minDist = 5000000.0;\n\n    for(int i = 0; i < points.length(); i++){\n        if(minDist > abs(pow((uv.x - points[i].x),2.0)) + abs(pow((uv.y - points[i].y),2.0))){\n            index = i;\n            minDist = abs(pow((uv.x - points[i].x),2.0)) + abs(pow((uv.y - points[i].y),2.0));\n        }\n    }\n    return index;\n}\n\nvec2 animateCircle(vec2 center, float diameter, float speed, float tOffset){\n    float x = ((sin((iTime + tOffset) * speed * GLOBALSPEED)) * .5 * diameter) + center.x;\n    float y = ((cos((iTime + tOffset) * speed * GLOBALSPEED + PI)) * .5 * diameter) + center.x;\n    return vec2(x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    points[0] = animateCircle(vec2(.26,.39), .80, .25, 0.5);\n    points[1] = animateCircle(vec2(.51,.5), 1.0, 1.25, 0.4);\n    points[2] = animateCircle(vec2(.5,.5), .5, 1.0, 0.2);\n    points[3] = animateCircle(vec2(.41,.61), .75, 1.3, 1.7);\n    points[4] = animateCircle(vec2(.69,.6), .550, .25, 5.);\n    points[5] = animateCircle(vec2(.31,.5), .25, .75, 6.9);\n    points[6] = animateCircle(vec2(.5,.6), .9, 1.1, 49.9);\n    points[7] = animateCircle(vec2(.71,.65), .445, .6, -.8);\n\n    // Time varying pixel color\n    vec3 col = colors[indexMinDistance(uv, points)];\n    \n    for(int i = 0; i < 8; i++){\n        if CircleMask(uv, points[i], 4.0) {\n            col = vec3(1.0);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}