{"ver":"0.1","info":{"id":"3sBSRR","date":"1552602241","viewed":130,"name":"Raymarching - learning","username":"flyingrub","description":"started with: https://www.shadertoy.com/view/ldtGD4\ngot inspired by: https://www.shadertoy.com/view/Xds3zN, https://github.com/HackerPoet/PySpace/blob/master/pyspace/frag.glsl","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.00001\n#define MAX_MARCH 200\n#define SHADOW_SHARPNESS 8.\n#define ANTIALIASING 2. \n#define time mod(iTime*2.,3.)\n\nvec3 repeat(vec3 p, vec3 spacing) {\n\treturn mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdf(vec3 p) {\n    vec3 amount = vec3(.5);\n    vec3 point = repeat(p,amount);\n    return sdSphere(point,.1);\n}\n\nbool raymarch(inout vec3 point, vec3 ray) {\n\tfor( int i = 0; i < MAX_MARCH; i++) {\n\t\tfloat current_distance = sdf( point);\n\n        if( current_distance < MIN_DIST ) {\n            return true;\n        }\n        point += ray * current_distance;\n\t}\n    return false;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = MIN_DIST;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*h ) + \n                      k.yyx*sdf( p + k.yyx*h ) + \n                      k.yxy*sdf( p + k.yxy*h ) + \n                      k.xxx*sdf( p + k.xxx*h ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t < maxt; )\n    {\n        float h = sdf(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 render(vec3 origin, vec3 direction) {\n    vec3 lightpos = origin + vec3(0.,0.,-1.);\n    vec3 hit_pos = origin;\n\n\tbool hit = raymarch(hit_pos, direction);\n    if (!hit) return vec3(0.);\n\n    vec3 normal = calcNormal(hit_pos);\n\n    vec3 lightvect = normalize(lightpos-hit_pos);\n    vec3 color = vec3(max(dot(lightvect, normal), 0.));\n    \n    \n    float shade = softshadow(hit_pos, lightvect, 10., 20., SHADOW_SHARPNESS);\n    shade = max(shade, 0.5);\n    color = pow( color*shade, vec3(0.4545) );\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 total = vec3(0.);\n    for( float m=0.; m<ANTIALIASING; m++ )\n    for( float n=0.; n<ANTIALIASING; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(m,n) / float(ANTIALIASING) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec3 dir = normalize( vec3(p.xy,2.0) );\n        total+= render(vec3(0.,0.,time*.5), dir);\n    }\n    total /= ANTIALIASING*ANTIALIASING;\n    \n\n    fragColor = vec4(col * total,1.);\n}","name":"Image","description":"","type":"image"}]}