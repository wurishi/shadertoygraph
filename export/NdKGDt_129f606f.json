{"ver":"0.1","info":{"id":"NdKGDt","date":"1632420156","viewed":79,"name":"Random fractals","username":"incription","description":"Random operations (+ = * / ^ log) applied randomly. Can you find the mandelbrot?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define scale 7.\n#define n_operations 3\n\nvec2 applyRandOperation(vec2 z, vec2 c, vec2 seed) {\n    float r = rand(seed);\n    float n = floor(r * 12.);\n    \n        if(n == 0.) z += z;\n        if(n == 1.) z = cmul(z, vec2(2., 0.));\n        if(n == 2.) z = cpow(z, vec2(2., 0.));\n        if(n == 3.) z = cdiv(z, vec2(2., 0.));\n        if(n == 4.) z -= z;\n        if(n == 5.) z = clnb(z, vec2(2., 0.));\n        \n        if(n == 6.) z += c;\n        if(n == 7.) z = cmul(z, c);\n        if(n == 8.) z = cpow(z, c);\n        if(n == 9.) z = cdiv(z, c);\n        if(n ==10.) z -= c;\n        if(n ==11.) z = clnb(z, c);\n    \n    return z;\n}\n\nfloat fractal(vec2 region, vec2 c) {\n    vec2 z = c;\n    float i;\n    region /= 10.43;\n    for(i = 0.; i < 50.; i++) {\n        \n        for(int j=0;j<n_operations;j++)\n        {\n            z = applyRandOperation(z, c, region * float(j));\n        }\n        \n        if(length(z) > 4.) break;\n    }\n    \n    return i / 50.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = uv + 5. * (iMouse.xy - iResolution.xy / 2.) / iResolution.xy;\n    vec2 region = floor(p * scale);\n    \n    vec2 ruv = (fract(p * scale) - .5) * vec2(iResolution.x/iResolution.y, 1);\n    ruv *= 3.;\n    \n    float result = fractal(region, ruv);\n    \n    vec3 col = smoothRainbow(result * 2.);\n    \n    fragColor = vec4(col, 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nfrom\nhttps://stackoverflow.com/questions/56725883/how-to-express-tetration-function-for-complex-numbers\n*/\n\nvec3 rainbow(float level)\n{\n\t/*\n\t\tTarget colors\n\t\t=============\n\t\t\n\t\tL  x   color\n\t\t0  0.0 vec4(1.0, 0.0, 0.0, 1.0);\n\t\t1  0.2 vec4(1.0, 0.5, 0.0, 1.0);\n\t\t2  0.4 vec4(1.0, 1.0, 0.0, 1.0);\n\t\t3  0.6 vec4(0.0, 0.5, 0.0, 1.0);\n\t\t4  0.8 vec4(0.0, 0.0, 1.0, 1.0);\n\t\t5  1.0 vec4(0.5, 0.0, 0.5, 1.0);\n\t*/\n\t\n\tfloat r = float(level <= 2.0) + float(level > 4.0) * 0.5;\n\tfloat g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);\n\tfloat b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);\n\treturn vec3(r, g, b);\n}\n\nvec3 smoothRainbow (float x)\n{\n    float level1 = floor(x*6.0);\n    float level2 = min(6.0, floor(x*6.0) + 1.0);\n    \n    vec3 a = rainbow(level1);\n    vec3 b = rainbow(level2);\n    \n    return mix(a, b, fract(x*6.0));\n}\n\nvec2 cmul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 cdiv(in vec2 a, in vec2 b) {\n    float dis = b.x * b.x + b.y * b.y;\n    return vec2((a.x * b.x + a.y * b.y) / dis, (a.y * b.x - a.x * b.y) / dis); \n}\n\n// complex exponent e^a\nvec2 cexp(in vec2 a) {\n    float ea = exp(a.x);\n    float vl = a.y;\n    return ea * vec2( cos(vl), sin(vl) );\n}\n\n// complex natural logarithm ln(a)\nvec2 cln(in vec2 a) {\n    float ql = length(a);\n    return vec2( log(ql), atan(a.y, a.x));\n}\n\n// complex log with base ln_b(a)\nvec2 clnb(in vec2 a, in vec2 b) {\n    return cdiv( cln(a), cln(b) );\n}\n\n// complex power function a^b\nvec2 cpow(in vec2 a, in vec2 b) {\n    return cexp(cmul(cln(a), b));   \n}\n\nvec2 ctet(in vec2 a, in int b) {\n    vec2 c = vec2(1.0,0.0);\n    for (;b>0;b--) c=cpow(a,c);\n    return c;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}","name":"Common","description":"","type":"common"}]}