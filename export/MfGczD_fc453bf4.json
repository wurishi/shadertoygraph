{"ver":"0.1","info":{"id":"MfGczD","date":"1731556511","viewed":77,"name":"Fork raymarchin lukajk1 745","username":"lukajk1","description":"practice","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"4ccyWs","parentname":"raymarching practice2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 1000. \n#define SURF_DIST_MARGIN .01\n\nfloat getDistFromSceneObjs(vec3 pos) {\n    vec4 sphere = vec4(0, 0., 0., 1);\n\n    float interval = 8.;\n\n    vec3 repeatedPos = mod(pos + interval * .5, interval) - interval * .5;\n\n    float distFromSphereOrigin = length(repeatedPos - sphere.xyz) - sphere.w;\n\n    return distFromSphereOrigin;\n}\n\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float distOffset = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 currentPos = rayOrigin + rayDir * distOffset;\n        float distToSurface = getDistFromSceneObjs(currentPos);\n        distOffset += distToSurface;\n        \n        if (distOffset > MAX_DIST || distToSurface < SURF_DIST_MARGIN) break;\n    }\n    \n    return distOffset;\n    }\n\nfloat mapAndClamp(float value) {\n    return clamp(mix(4., 5.5, value), 5.0, 5.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 rayOrigin = vec3(3.5, 0., 4. * iTime);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1)); \n    /* z is depth, x width, y height naturally. So these vectors are angled based on the current\n    screencoords */\n    \n    float distToSurf = rayMarch(rayOrigin, rayDir);\n    vec3 hitPoint = rayOrigin + rayDir * distToSurf;\n    \n    float distFromCam = length(hitPoint - rayOrigin);\n    \n    float scaledDistFromCam = smoothstep(0., 1., distFromCam / 300.);\n    \n    vec3 col = vec3(scaledDistFromCam);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}