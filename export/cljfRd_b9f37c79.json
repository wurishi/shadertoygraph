{"ver":"0.1","info":{"id":"cljfRd","date":"1694395295","viewed":83,"name":"3D Graph Visualizer","username":"twixuss","description":"You can change the graph in function \"f\" at line 7.\nIf you have low fps, check out the comment at line 29.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","visualizer","graph","function","geometry"],"hasliked":0,"parentid":"WtGXDD","parentname":"RayMarching starting point"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching template by BigWIngs https://www.shadertoy.com/view/WtGXDD\n\n// Click and drag to control the camera\n\n// This is the function to graph. The range of p is [-1;1]\n// Zeros of this function will be drawn as a surface.\nfloat f(vec3 p)\n{\n    // Vortex\n    return p.y - (0.1*S(0.0,0.3,length(p.xz))*sin(length(p.xz) * 10. + atan(p.x, p.z) - T * 10.));\n    \n    // Saddle\n    //return p.y - (p.z*p.z - p.x*p.x);\n    \n    // Spiral\n    //return p.y - (atan(p.z, p.x) / PI);\n    \n    // Waves\n    //float r = 0.0;\n    //for (float i = 0.0; i < 5.0; ++i) {\n    //    r += sin(pow(1.5, i)*iTime + pow(2.0, i) * dot(p.xz, vec2(cos(i*12.34), sin(i*56.78))));\n    //}\n    //return p.y - r*0.06;\n}\n\n// Graph thickness\n#define THICKNESS 0.01\n\n// If you are having too low fps, try lowering MAX_STEPS. There will be\n// more artifacts though. Also you can disable axis arrows.\n#define MAX_STEPS 500\n#define ENABLE_AXIS_ARROWS 1\n\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define NORMAL_EPSILON 0.01\n#define DF_EPSILON 0.01\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 df(vec3 p) {\n    vec2 e = vec2(DF_EPSILON, 0);\n    vec3 n = f(p) - \n        vec3(f(p-e.xyy), \n             f(p-e.yxy),\n             f(p-e.yyx));\n    \n    return n/e.x;\n}\n\nstruct Result {\n    float d;\n    float f;\n};\n\nResult GetDist(vec3 p) {\n    float d;\n    float f = f(p);\n    d = abs(f)-length(abs(df(p)))*float(THICKNESS);\n    d = max(d, sdBox(p, vec3(1)));\n#if ENABLE_AXIS_ARROWS\n    d = min(d, length(p.xz+1.1)-0.02);\n    d = min(d, length(p.xy+1.1)-0.02);\n    d = min(d, length(p.yz+1.1)-0.02);\n    d = max(d, max(-1.12-p.x, -1.12+p.x));\n    d = max(d, max(-1.12-p.y, -1.12+p.y));\n    d = max(d, max(-1.12-p.z, -1.12+p.z));\n    d = min(d, max(length(p.yz+1.1)*4.0+p.x-1.2, 1.0-p.x));\n    d = min(d, max(length(p.xz+1.1)*4.0+p.y-1.2, 1.0-p.y));\n    d = min(d, max(length(p.xy+1.1)*4.0+p.z-1.2, 1.0-p.z));\n#endif\n    return Result(d, f);\n}\n\nResult RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float f;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        Result dS = GetDist(p);\n        f = dS.f;\n        dO += dS.d*0.1;\n        if(dO>MAX_DIST || abs(dS.d)<SURF_DIST) break;\n    }\n    \n    return Result(dO, f);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPSILON, 0);\n    vec3 n = GetDist(p).d - \n        vec3(GetDist(p-e.xyy).d, GetDist(p-e.yxy).d,GetDist(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nfloat maxc(vec3 p) { return max(p.x,max(p.y,p.z)); }\nfloat minc(vec3 p) { return min(p.x,min(p.y,p.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m;\n    if (length(iMouse.xy) < 8.0) {\n        m.x = 2.0;\n        m.y = 0.5;\n    } else {\n        m = iMouse.xy/iResolution.y;\n        m.y = -m.y*PI+PI/2.;\n        m.x = -m.x*PI;\n    }\n\n    vec3 ro = vec3(0, 0, -4);\n    ro.yz *= Rot(m.y);\n    ro.xz *= Rot(m.x);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n   \n    Result r = RayMarch(ro, rd);\n    vec3 V = -rd;\n\n    struct Light {\n        vec3 dir;\n        vec3 color;\n    };\n    \n    Light lights[2] = Light[](\n        Light(normalize(+vec3(1,2,3)), vec3(1.0)),\n        Light(normalize(-vec3(1,2,3)), vec3(0.5))\n    );\n    \n    vec3 ambient = vec3(0.1);\n    vec3 col;\n    \n    if(r.d<MAX_DIST) {\n        vec3 p = ro + rd * r.d;\n        vec3 n = GetNormal(p);\n        vec3 albedo = mix(vec3(1.0,0.6,0.2),vec3(0.2,0.2,1.0),step(r.f,0.0));\n        if (minc(p)<-1.01) {\n            albedo = vec3(0);\n            if(p.x > 1.15+p.y+p.z) albedo.x += 1.0;\n            if(p.y > 1.15+p.x+p.z) albedo.y += 1.0;\n            if(p.z > 1.15+p.x+p.y) albedo.z += 1.0;\n        }\n        col = albedo*ambient/PI;\n        for (int i = 0; i < lights.length(); ++i) {\n            Light light = lights[i];\n            vec3 L = light.dir;\n            vec3 H = normalize(L+V);\n\n            vec3 dif = albedo*SAT(dot(n, L)) * light.color;\n            vec3 spec = step(0.0,dot(n,L))* pow(SAT(dot(n, H)), 100.) * light.color * 2.0;\n            col += vec3(dif + spec);\n        }\n    } else {\n        col = ambient * mix(1.0, 0.5, S(0.8, 0.9, maxc(sin(V*TAU*5.0))));\n    }\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define SAT(x) clamp(x,0.0,1.0)\n#define T iTime\n","name":"Common","description":"","type":"common"}]}