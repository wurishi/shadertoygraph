{"ver":"0.1","info":{"id":"3scfRf","date":"1605629660","viewed":264,"name":"Bezier Curve Editor","username":"dahart","description":"Just a quick sketch of using draggable points","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["bezier","curve","editor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// bezier\nconst mat4x4 bez = transpose(mat4x4(\n    vec4( 1.,  0.,  0., 0.),\n    vec4(-3.,  3.,  0., 0.),\n    vec4( 3., -6.,  3., 0.),\n    vec4(-1.,  3., -3., 1.)\n));\n\nvec2 cubic(mat4x4 m, mat2x4 pts, float u) {\n    float uu = u*u;\n    return transpose(m * pts) * vec4(1.0, u, uu, uu*u);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    float dx = fwidth(length(uv)) * .75;\n\n    vec4 mStateCurr = iMouse / iResolution.y;\n    bool mouseDownCurr = mStateCurr.z > 0.;\n\n    // display the draggable points\n    vec2 p[UI_MAX_POINTS];\n    for (int i = 0; i < UI_MAX_POINTS; i++) {\n        p[i] = texture(iChannel0, (vec2(float(i), 1.)+.5) / iResolution.xy).xy;       \n\t\tfloat w = 0.002;\n    \tfloat d = abs(sdCircle(uv.xy, p[i].xy, UI_POINT_SIZE));\n        float u = float(i) / float(UI_MAX_POINTS);\n    \tif (d < w+dx+dx) fragColor += vec4(u,1.-u,0,1) * smoothstep(w+dx, w-dx, d);\n    }\n    \n    // display the polyline\n    for (int i = 0; i < UI_MAX_POINTS-1; i++) {\n        float w = 0.002;\n        float d = sdSegment(uv.xy, p[i], p[i+1]);\n        if (d < w+dx+dx) fragColor += vec4(.4,.4,.4,1) * smoothstep(w+dx, w-dx, d);\n    }\n    \n    // display the cubic bezier\n    int nsamp = 20;\n    int nseg = UI_MAX_POINTS - 3;\n    float du = 1. / float(nsamp);\n    float w = 0.005;\n    for (int seg = 0; seg < nseg; seg+=3) { // attach segments every 3rd point\n        vec2 p0 = p[seg];\n        for (int samp = 1; samp <= nsamp; samp++) {\n            float u = float(samp) * du;\n            mat4x2 pts = mat4x2(p[seg+0], p[seg+1], p[seg+2], p[seg+3]);\n            vec2 p1 = cubic(bez, transpose(pts), u);\n            float d = sdSegment(uv.xy, p0, p1);\n            // draw the curve with a transparent line. overlap shows where the samples are\n            if (d < w+dx+dx) fragColor += vec4(u, 1.-u, 0., 1.) * smoothstep(w+dx, w-dx, d);\n            p0 = p1;\n        }\n    }\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// click & drag points\n//\n// State is stored in Buf A:\n// (0,0): previous frame mouse state\n// (1,0): is something selected? x==0:no 1:yes  y==id of current selection\n// (x,1): position of point x\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 icoord = ivec2(fragCoord);\n\n    if (iFrame == 0) {\n        if      (icoord.y == 0) fragColor = vec4(0.);\n        else if (icoord.y == 1) fragColor = vec4(hash42(fragCoord + 7.).xy, 0., 0.);\n        return;\n    }\n    \n    if (fragCoord.y > 2. || fragCoord.x > float(UI_MAX_POINTS+1)) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    // copy previous frame state\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n\n    \n    // query previous frame mouse state\n    vec4 mStatePrev = texelFetch(iChannel0, ivec2(0), 0);\n    vec4 mStateCurr = iMouse / iResolution.y; // xyxy\n    \n    bool mouseDownPrev = mStatePrev.z > 0.;\n    bool mouseDownCurr = mStateCurr.z > 0.;\n    \n    bool mouseClicked = mouseDownCurr && !mouseDownPrev;\n    bool mouseReleased = !mouseDownCurr && mouseDownPrev;\n    \n    ivec2 selectedId = ivec2(texelFetch(iChannel0, ivec2(1,0), 0).xy);\n    \n    if (mouseClicked && selectedId.x == 0) {\n        // which point did we click?\n        int imin = -1;\n        float dmin = 2.;\n\n        for (int i = 0; i < UI_MAX_POINTS; i++) {\n            float d = distance(mStateCurr.xy, texelFetch(iChannel0, ivec2(i, 1), 0).xy);\n            if (d < UI_POINT_SIZE && d < dmin) { dmin = d; imin = i; }\n        }\n        if (imin >= 0) selectedId = ivec2(1, imin);\n        else           selectedId = ivec2(0);\n    }\n    else if (mouseReleased) {\n        selectedId = ivec2(0);\n    }\n\n\n\n    // store new mouse state\n    if (icoord == ivec2(0, 0)) fragColor = mStateCurr;\n    \n    // store id of any clicked point\n    else if (icoord == ivec2(1, 0)) {\n        fragColor = vec4(vec2(selectedId)/1., 0,0);\n    }    \n\n    // store position of selected point\n    else if (icoord == ivec2(selectedId.y, 1)) {\n        if (mouseDownCurr && (selectedId.x != 0)) {\n            fragColor = vec4(mStateCurr.xy, 0,0);\n        }\n    }\n        \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\nconst int   UI_MAX_POINTS = 4;\n\nconst float UI_POINT_SIZE = .025; // relative to window size\n\n\n//----------------------------------------------------------------------------------------\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return distance(p,c) - r;\n}\n\n\n//----------------------------------------------------------------------------------------\n// Dave Hoskins Hash Without Sine https://www.shadertoy.com/view/4djSRW\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n","name":"Common","description":"","type":"common"}]}