{"ver":"0.1","info":{"id":"NtccWs","date":"1660761993","viewed":105,"name":"Uniform non-colliding foliage","username":"GribUser","description":"Made to model filiage placement logic. Random and uniform, deterministic, infinite, collision-free. Noise function copy-pasted as-is. Not really meant to be a shader, just a visualisation of the algorithm.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["dots","uniform","foliage","trianglegrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 DotColor, vec2 inCoords) {\n\tvec2 ScaledCOords = inCoords / iResolution.x * VoxelsOnScreen;\n\n\tvec2 RelCoords = inCoords / iResolution.xy;\n\tvec2 VoxelSizeOnTexture = vec2(1.0 / VoxelsOnScreen * iResolution.y / iResolution.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 1.0 / VoxelsOnScreen);\n\n\tfloat HasYong = 0.0;\n\tfloat HasMature = 0.0;\n\tfloat HasAging = 0.0;\n\tfloat StageProgress = fract(iTime/FOliageLifetime);\n\n\tfor (float x = -TreeSize; x < TreeSize; x += 1.0) {\n\t\tfor (float y = -TreeSize; y < TreeSize; y += 1.0) {\n\t\t\tvec2 Shift = vec2(x, y);\n\t\t\tfloat L = length(Shift);\n\t\t\tif (L > TreeSize) { continue; }\n\t\t\tvec2 ARelCoords = RelCoords + VoxelSizeOnTexture * vec2(x, y);\n\t\t\tfloat TreeMode = texture(iChannel0, ARelCoords).r;\n\t\t\tif (TreeMode >= 0.8) {\n\t\t\t\tfloat F = L > TreeCenterSize ? 0.3 : 0.6;\n\t\t\t\tif (F > HasAging) { HasAging = F; }\n\t\t\t} else if (TreeMode >= 0.4) {\n\t\t\t\tfloat F = L > TreeCenterSize ? 0.3 : 0.6;\n\t\t\t\tif (F > HasMature) { HasMature = F; }\n\t\t\t} else if (TreeMode > 0.0) {\n\t\t\t\tfloat GrowingTreeSize = TreeSize * StageProgress * 0.8 + 0.2;\n\t\t\t\tif (L <= GrowingTreeSize) {\n\t\t\t\t\tfloat F = L > GrowingTreeSize/2.0 ? 0.4 : 0.8;\n\t\t\t\t\tif (F > HasYong) { HasYong = F; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tDotColor = vec4(HasYong, HasMature, HasAging, 1.0);\n//\treturn;\n\tDotColor = texture(iChannel0, RelCoords);\n\n\tif (DotColor.r != 0.0) {\n        DotColor = vec4(0.1, 1.0, 0.1, 1.0);\n    } else {\n\t\tif (HasAging > 0.0 && (StageProgress < 0.5 || HasMature == 0.0)) {\n\t\t\tDotColor.r = HasAging * smoothstep(0.0, 1.0, StageProgress);\n\t\t\tDotColor.g = HasAging - DotColor.r / 2.0;\n\t\t} else if (HasMature > 0.0) {\n\t\t\tDotColor.g = HasMature;\n\t\t} else if (HasYong > 0.0) {\n\t\t\tDotColor.g = HasYong;\n\t\t\tDotColor.r = HasYong / 3.0;\n\t\t}\n\t}\n//\tfloat Noise = noise_sum(floor((ScaledCOords + iTime * 3.0)) / 100.0, 0.0) * 0.5 + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Technical\nfloat NoiseYshift = 5834.32;\n\nvec2 ShiftAt(in vec2 Coord) {\n\tfloat noiseX = noise_sum(Coord * 10.0, 0.0) * 0.5 + 0.5;\n\tfloat noiseY = noise_sum((Coord) * 10.0 + NoiseYshift, 0.0) * 0.5 + 0.5;\n\treturn vec2(noiseX, noiseY);\n}\n\n#define sqrt3 1.7320508\n\nvec2 HexCoords(vec2 inCoords) {\n\treturn inCoords * mat2(1, -1. / sqrt3, 0, 2. / sqrt3);\n}\n\nbool DCells(vec2 ScaledCOords) {\n\tvec2 VoxelTLCoords = ScaledCOords + ShiftAt(ScaledCOords * noise1Scale) * noise1Power;\n\n\tfloat CellY00 = VoxelTLCoords.y / (Dencity * sqrt3 / 2.0);\n\tfloat FloorecCellY00 = floor(CellY00);\n\tfloat CellX00 = VoxelTLCoords.x / Dencity * 2.0;\n\tfloat FloorecCellX00 = floor(CellX00);\n\tbool ModY = mod(FloorecCellY00, 2.0) == 0.0;\n\tbool ModX = mod(FloorecCellX00, 2.0) == 0.0;\n\n\tvec2 VoxelBRCoords = ScaledCOords + 1.0;\n\tVoxelBRCoords += ShiftAt(VoxelBRCoords * noise1Scale) * noise1Power;\n\tfloat CellY11 = VoxelBRCoords.y / (Dencity * sqrt3 / 2.0);\n\tfloat FloorecCellY11 = floor(CellY11);\n\tfloat CellX11 = VoxelBRCoords.x / Dencity * 2.0;\n\tfloat FloorecCellX11 = floor(CellX11);\n\n\tbool BothGo = FloorecCellX00 != FloorecCellX11\n\t\t&& FloorecCellY00 != FloorecCellY11;\n//\treturn BothGo;\n\treturn (ModY != ModX) && BothGo;\n}\n\n// Main func\nvoid mainImage(out vec4 DotColor, vec2 inCoords) {\n\n\tvec2 ScaledCOords = (inCoords) / iResolution.x * VoxelsOnScreen + iTime * 3.0;\n\n\tfloat TreeState = 0.0; // no tree\n\n\tfloat NoisePhase = floor(iTime / FOliageLifetime);\n\tbool PrevGrow = noise_sum(floor(ScaledCOords) / 10.0, NoisePhase) > GrowIntencity * 2.0 - 1.0;\n\tif (PrevGrow) {\n\t\tTreeState = 0.5; // mature tree\n\t} else {\n\t\tNoisePhase += 1.0;\n\t\tbool NowGrow = noise_sum(floor(ScaledCOords) / 10.0, NoisePhase) > GrowIntencity * 2.0 - 1.0;\n\t\tif (NowGrow) {\n\t\t\tTreeState = 0.1; // start growing\n\t\t} else {\n\t\t\t// Not in this turn and not in previous, but what about -2?\n\t\t\tNoisePhase -= 2.0;\n\t\t\tbool WasAgesAgo = noise_sum(floor(ScaledCOords) / 10.0, NoisePhase) > GrowIntencity * 2.0 - 1.0;\n\t\t\tif (WasAgesAgo) {\n\t\t\t\tTreeState = 0.9; // fading out tree\n\t\t\t}\n\t\t}\n\t}\n\tNoisePhase = 0.0;\n\n\tbool CanPlantThisPhase = TreeState != 0.0;\n\n\n\tvec2 ScaledCOordsF = floor(ScaledCOords);\n\n\tbool BysyHere = DCells(ScaledCOordsF + vec2(1.0, -1.0))\n\t\t|| DCells(ScaledCOordsF + vec2(0.0, -1.0))\n\t\t|| DCells(ScaledCOordsF + vec2(-1.0, -1.0))\n\t\t|| DCells(ScaledCOordsF + vec2(1.0, 0.0));\n\tif (BysyHere || !DCells(ScaledCOordsF)) { TreeState = 0.0; }\n\tbool Dot = !BysyHere && DCells(ScaledCOordsF);\n\n\n\tif (CanPlantThisPhase) {\n\t\tDotColor = vec4(TreeState, TreeState, TreeState, TreeState);\n\t} else {\n\t\tDotColor = vec4(0.0, Dot?0.3:0.0, Dot ? 0.1 : 0.0, 1.0);\n\t}\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Visual setup\nconst float VoxelsOnScreen = 200.0;\nconst float Dencity = 5.5;\n\nconst float noise1Power = 30.0;\nconst float noise1Scale = 0.004;\nconst float GrowIntencity = 0.54; // 0..1\nconst float FOliageLifetime = 5.0; //sec\nconst float TreeSize = 7.0;\nconst float TreeCenterSize = TreeSize/2.0;\n\n// Perlin noise (copy-paste from https://www.shadertoy.com/view/Md3SzB)\nvec2 hash22(vec2 p, float NoisePhase) {\n\tp = p * mat2(127.1, 311.7, 269.5, 183.3);\n\tp = -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n\treturn sin(p * 6.283 + NoisePhase);\n}\n\nfloat perlin_noise(vec2 p, float NoisePhase) {\n\tvec2 pi = floor(p);\n\tvec2 pf = p - pi;\n\n\tvec2 w = pf * pf * (3. - 2. * pf);\n\n\tfloat f00 = dot(hash22(pi + vec2(.0, .0), NoisePhase), pf - vec2(.0, .0));\n\tfloat f01 = dot(hash22(pi + vec2(.0, 1.), NoisePhase), pf - vec2(.0, 1.));\n\tfloat f10 = dot(hash22(pi + vec2(1.0, 0.), NoisePhase), pf - vec2(1.0, 0.));\n\tfloat f11 = dot(hash22(pi + vec2(1.0, 1.), NoisePhase), pf - vec2(1.0, 1.));\n\n\tfloat xm1 = mix(f00, f10, w.x);\n\tfloat xm2 = mix(f01, f11, w.x);\n\n\tfloat ym = mix(xm1, xm2, w.y);\n\treturn ym;\n\n}\n\nfloat noise_sum(vec2 p, float NoisePhase) {\n\tp *= 4.;\n\tfloat a = 1., r = 0., s = 0.;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tr += a * perlin_noise(p, NoisePhase); s += a; p *= 2.; a *= .5;\n\t}\n\n\treturn r / s;///(.1*3.);\n}\n","name":"Common","description":"","type":"common"}]}