{"ver":"0.1","info":{"id":"mdVcRR","date":"1695737342","viewed":32,"name":"Moons night","username":"transpalex","description":"c'est des lunes. dans la nuit :]","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dot2( in vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cro(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cro(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cro(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\nvec3 palette(float d){\n\treturn mix(vec3(0.9,0.7,0.01),vec3(1.,0.,1.),d);\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n    {\n        return length(p-vec2(a,b));\n    }\n\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    float a = 0.3;\n    float b = 0.2;\n    float di = 0.15;\n    vec3 finalColor = vec3(0.0);\n    \n    vec3 col = vec3(0.0);\n    \n    float screenWidth = iResolution.x / iResolution.y;\n    float xOffset1 = 0.2 * sin(2.0 * iTime);\n    float yOffset1 = 0.1 * sin(1.5 * iTime);\n\tvec2 v0 = vec2(-screenWidth,-1.0);\n    vec2 v1 = vec2(-0.7+xOffset1,-0.1+yOffset1);\n    vec2 v2 = vec2(0.3+xOffset1*0.1,-1.0);\n    \n    float db1 = sdBezier( uv0, v0,v1,v2 );\n    db1 = step(-db1,0.1);\n    \n    \n    float xOffset2 = 0.15 * sin(1.0 * iTime);\n    float yOffset2 = 0.08 * sin(1.2 * iTime);\n    v0 = vec2(0.0+xOffset2,-1.0);\n    v1 = vec2(0.9+xOffset2,0.3+yOffset2);\n    v2 = vec2(screenWidth,-1.0);\n    \n    \n    float db2 = sdBezier( uv0, v0,v1,v2 );\n    db2 = step(-db2,0.1);\n    \n    float translation = 0.2*iTime;\n    \n    if (uv.y>0.0){\n    col = palette(0.5*length(uv0))*0.5;\n    uv = fract(0.9*uv - vec2(translation, 0.0)) - 0.5;\n        float d = sdMoon(uv, di, a, b);\n\n        d = abs(d);\n        d = 0.02/d;\n\n        col *= d;\n    }\n    vec3 backgroundColor = palette(0.5*length(uv0));\n    \n    float starDensity = 0.01;\n    \n    \n    if (db1+db2 < 0.1){\n        vec3 stars_direction = normalize(vec3(uv0 * 3.5, 1.0));\n        float stars = pow(clamp(noise(stars_direction * 200.0), 0.0, 1.0), 8.0) * 200.0;\n        \n        // Add scintillation effect by modulating star brightness with a sine function\n        float scintillation = 0.5 + 0.5 * sin(10.0 * iTime + stars * 100.0);\n        stars *= scintillation; // Modulate star brightness with scintillation\n        \n        if (stars > starDensity) {\n            col += vec3(stars); // White star-like noise\n        }\n        backgroundColor = vec3(0.0,0.0,0.0);\n    }\n    finalColor = col + backgroundColor;\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}