{"ver":"0.1","info":{"id":"cl2SWR","date":"1675923698","viewed":79,"name":"Funny lines","username":"ianertson","description":"Just some moving lines","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lines","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n\nfloat line(vec2 p, vec2 a, vec2 b, float thick) {\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(ba, pa) / dot(ba, ba), 0.0, 1.0);\n    return max(0.0, 1.0 - smoothstep(0.1, 0.2, pow(length(pa - h*ba), thick)));\n}\n\n\nvec2 point(vec2 id) {\n\n    vec2 a = vec2(noise(id+10.0, id.x+3.2091-id.y), noise(id+10.0, id.y+9.2315-id.x))*2.0-1.0;\n    \n    vec2 m = iMouse.xy/R.xy;\n    a += vec2(cos(T*a.x), sin(T*a.y))*length(a);\n    \n    a *= rot(dot(a, m)*TAU);\n    return a;\n}\n\n\nvec4 getLine(vec2 uv, float tile) {\n     vec3 col = vec3(0.0);\n    vec2 id = floor(uv*tile);\n    vec2 lv = smoothstep(0.0, 1.0, fract(uv*tile));\n\n    float rx = step(0.01, lv.x);\n    float ry = step(0.01, lv.y);\n    float value = max(0.0, 1.0-min(rx, ry));\n    \n    \n    float s = tile * tile;\n    vec2 ap = point(id)/s;\n    vec2 bp = point(id+vec2(1.0, 0.0))/s;\n    vec2 cp = point(id+vec2(0.0, 1.0))/s;\n    vec2 dp = point(id+vec2(1.0, 1.0))/s;\n\n\n    float a = dot(ap, uv);\n    float b = dot(bp, uv);\n    float c = dot(cp, uv);\n    float d = dot(dp, uv);\n\n    vec2 ab = mix(ap, bp, lv.x);\n    vec2 cd = mix(cp, dp, lv.x);\n    vec2 j = mix(ab, cd, lv.y);\n    \n    return vec4(uv*tile, j*tile);\n}\n\nvec3 pattern(vec2 uv, float tile) {\n    vec3 col = vec3(0.0);\n    vec2 lv = smoothstep(0.0, 1.0, fract(uv*tile));\n    float seed = 10.28124;\n    float ra = hash2(floor(uv*tile), seed);\n    float rb = hash2(floor(uv*tile) + vec2(1, 0), seed);\n    float rc = hash2(floor(uv*tile) + vec2(0, 1), seed);\n    float rd = hash2(floor(uv*tile) + vec2(1, 1), seed);\n    float rab = mix(ra, rb, lv.x);\n    float rcd = mix(rc, rd, lv.x);\n    float rand = mix(rab, rcd, lv.y);\n\n    vec2 id = floor(uv*tile);\n    \n\n    float rx = step(0.01, lv.x);\n    float ry = step(0.01, lv.y);\n    float value = max(0.0, 1.0-min(rx, ry));\n    \n    float K = 1.0 / (tile);\n    vec4 a = getLine(uv, tile);\n    vec4 b = getLine(uv + (vec2(1.0, 0.0) * K), tile);\n    vec4 c = getLine(uv + (vec2(0.0, 1.0) * K), tile);\n    vec4 d = getLine(uv + (vec2(1.0, 1.0) * K), tile);\n    \n    vec4 L = a;\n    \n    value = line(uv, L.xy, L.zw, 0.3);\n\n\n    col += value;\n    \n    vec4 g = mix(d, mix(a, b, lv.x), lv.y);\n    \n    float re = max(0.0, dot(L.zw, b.zw))*tile*tile;\n    float gr = max(0.0, dot(L.zw, c.zw))*tile*tile;\n    float bl = max(0.0, dot(L.zw, d.zw))*tile*tile;\n    \n    vec2 mi = min(L.zw, min(b.zw, d.zw));\n    vec2 ma = max(L.zw, max(b.zw, d.zw));\n    vec2 area = max(vec2(0.0), ma - mi);\n    \n\n   col += smax(re, smax(gr, bl, 0.5), 0.5)*0.4;\n   col *= abs(vec3(cos(rand*TAU+value+re), sin(rand*TAU+value+gr), tan(rand*TAU+value+bl)));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = pattern(uv, 16.);\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 1.6));\n\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat hash1(float x) {\n    uint y = floatBitsToUint(x + 12.);\n    uint y2 = (y >> 9u);\n    y2 ^= y2 << 13;\n    y2 ^= y2 >> 17;\n    y2 ^= y2 << 5;\n    uint n = 912229U * ((y) ^ ((y2 ^ (y<<2))>>3U));\n    return float(n) / float(0xffffffffU);\n}\n\nfloat hash2(vec2 x, float seed) {\n    seed = hash1(seed+0.91256);\n    uint hx = uint(hash1(x.x+35.1)*3921.52 + seed);\n    uint hy = uint(hash1(x.y+91.1)*3921.44 + seed);\n    uvec2 y = uvec2(floatBitsToUint(x.x+12.92815 + seed), floatBitsToUint(x.y+12.12245 + seed));\n    uint a = 912229U * (((y.x << (hx >> (hy ^ (y.x+y.y)))) ^ (y.y >> 2u)) ^ (hx ^ hy));\n    return float(a) / float(0xffffffffU);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    float ab = mix(hash2(id, seed), hash2(id+vec2(1.0, 0.0), seed), lv.x);\n    float cd = mix(hash2(id+vec2(0.0, 1.0), seed), hash2(id+vec2(1.0, 1.0), seed), lv.x);\n    return mix(ab, cd, lv.y);\n}\n\nvec3 noisev3(vec2 p, float seed) {\n    return vec3(\n        noise(p, 13.29185+seed),\n        noise(p, 16.93811+seed),\n        noise(p, 32.42436+seed)\n    );\n}\n\nvec3 hashv3(vec2 p, float seed) {\n    return vec3(\n        hash2(p, 13.29185+seed),\n        hash2(p + vec2(0.98281, -9.2001), 16.93811+(seed/3.)),\n        hash2(p + vec2(-0.212, 1.121), 32.42436+(seed-1.9291))\n    );\n}\n\n#define NOISE_BODY(c)\\\n    float n = 0.0;\\\n    float amp = 1.0;\\\n    float div = 0.0;\\\n    for (int i = 0; i < c; i++) {\\\n        div += amp;\\\n        n += amp * noise(p*freq, seed);\\\n        freq *= 2.;\\\n        amp /= 2.0;\\\n    }\\\n    return n / div;\n\n//float noise8(vec2 p, float freq) { NOISE_BODY(8); }\nfloat noise16(vec2 p, float freq, float seed) { NOISE_BODY(16); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}","name":"Common","description":"","type":"common"}]}