{"ver":"0.1","info":{"id":"lt3czs","date":"1533667243","viewed":317,"name":" [SH18] Adonis Bob","username":"TLC123","description":"Hambone mit node xyz scaling: variation of conecapsule","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["3d","human","sh18","conecapsule","hambone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.28318530718\n//Procedural animation. What a horrable mess i made.  \n// 2018 shadertoy competition entry.\n\n\n struct mdt { vec3 pos; vec3 scale; }; \nvec3 walkbob(float t){  return vec3(0.,0.,sin ( smoothstep(0.,1. , mod(t,1.0))*TAU));} \nvec3 swing(float t){  return vec3(0.,sin (smoothstep(0.,1. , mod(t,1.0))*TAU),0.);} \nvec3 sway(float t){  return vec3(    sin ( smoothstep(0.,1. ,mod(t,1.0))*TAU),0.,0.);} \n \nconst mdt[] v1= mdt[] ( \n    mdt(vec3(0, -2, 33),vec3(8,8,12)),mdt(vec3(0,-3, 50),vec3(14,14,15)),\n    mdt(vec3(0,-2, 85),vec3(14,10, 14)),mdt(vec3(0, 0,100),vec3(5,5,5)), \n    mdt(vec3(0,-15,117),vec3(12,10,14)),mdt(vec3(0, 5,140),vec3(17,17,17)));\nconst mdt[] v2= mdt[]  ( \n    mdt(vec3( 5, 0,96),vec3(5,6,4)),mdt(vec3(20,  2,95),vec3(7,7,6)),\n    mdt(vec3(40,  0,60),vec3(4,5,4)),mdt(vec3(35,-21,30),vec3(2,3,2)),\n    mdt(vec3(35,-25,10),vec3(8,4,8)),mdt(vec3(35,-20,-5),vec3(3,4,3)));\nconst mdt[] v3= mdt[]  ( \n    mdt(vec3(  -5, 0,96),vec3(5,6,4)),mdt(vec3(-20,  2,95),vec3(7,7,6)),\n    mdt(vec3(-40,  0,60),vec3(4,5,4)),mdt(vec3(-35,-21,30),vec3(2,3,2)),\n    mdt(vec3(-35,-25,10),vec3(8,4,8)),mdt(vec3(-35,-20,-5),vec3(3,4,3)));\n\n\n\nfloat  synmin(float a,float  b,float  r  ) {\n    // drop-in function for smin  \n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*10.1*e*(exp(1.0-(e*0.6 ))))/max(a,b)*0.5)\n \n            ;}\n// rotm sphere  credit to Inigo Quilez\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;}\nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\nfloat conecapsule (vec3 p, vec3 p1 ,vec3 p2 ,vec3 r1,vec3 r2 ) {\n// eats vec4 (x,y,z,r) X 2\n    p1=vec3(p1.x,p1.y,max(-85.,p1.z));\n    p2=vec3(p2.x,p2.y,max(-85.,p2.z));\nvec3 a=mix(p1,p2,0.05);\nvec3 b=mix(p1,p2,0.85);;\nvec3 n1=pow(abs(normalize(p-a)),vec3(1.36));\nvec3 n2=pow(abs(normalize(p-b)),vec3(1.36)); \nfloat\t\td1= length  ( vec3(r1.x*n1.x, r1.y*n1.y,r1.z*n1.z));\nfloat\t\td2= length (vec3(r2.x*n2.x, r2.y*n2.y,r2.z*n2.z)); \nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\nvec4 map(vec4 r0)\n{  vec3 p=r0.xyz ;\n \nfloat myTime= iTime*2.1 ;\n \n \n  mdt[] v4= mdt[]  ( \n    mdt(vec3( 1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)), \n      mdt(vec3(13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.+0.5)*3.,vec3(10,10,11)),\n    mdt(vec3(20,-15,-20)+walkbob(myTime/2.+0.5)*8.+swing(myTime/2.+0.0)*20.+sway(myTime/4. )*2.,vec3(7,7,7)), \n      mdt(vec3(15,  1,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(5,6,4)),\n    mdt(vec3(22, -10,-81)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(8,7,5)),\n      mdt(vec3(25,-20,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*8.,vec3(4,6,4)));\n  mdt[] v5= mdt[]  ( \n    mdt(vec3(  -1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)),\n      mdt(vec3(-13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.)*3.,vec3(10,10,11)),\n    mdt(vec3(-20,-15,-20)+walkbob(myTime/2.)*8.+swing(myTime/2.+0.5)*20.+sway(myTime/4. +0.5)*2.,vec3(7,7,7)),\n      mdt(vec3(-15,  1,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(5,6,4)),\n    mdt(vec3(-22, -10,-81)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(8,7,5)),\n      mdt(vec3(-25,-20,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*8.,vec3(4,6,4))); \n\n \n \n \n \n // make a few points\nfloat d1=1000000000.;\nfloat d2=d1;\nfloat d3=d1;\nfloat d4=d1;\nfloat d5=d1;\n \n for( int i=0; i<5; i++ ){\n  d1= synmin(d1,conecapsule( p -walkbob(myTime)*6.+swing(myTime/2.+0.5)*2.\n                            +vec3(0,-4,0)+sway(myTime/4.+0.5)*2.\n                            ,  v1[i].pos , v1[i+1].pos ,v1[i].scale,v1[i+1].scale ),2.);\n  d2= synmin(d2,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime+0.25)*2.,  v2[i].pos , v2[i+1].pos ,v2[i].scale,v2[i+1].scale ),1.);\n  d3= synmin(d3,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime-0.25)*2.,  v3[i].pos , v3[i+1].pos ,v3[i].scale,v3[i+1].scale ),1.);\n  d4= synmin(d4,conecapsule( p,  v4[i].pos , v4[i+1].pos ,v4[i].scale,v4[i+1].scale ),1.);\n  d5= synmin(d5,conecapsule( p,  v5[i].pos , v5[i+1].pos ,v5[i].scale,v5[i+1].scale ),1.);\n }\n float d=synmin(d1,min(  min(d3,d2), smin(d4,d5,1.0)),3.0);\n float z=p.z+93.;\n  \n float c1= mod( \n        mod (floor(p.x/30.),2.)+\n        mod (floor(p.y/30.),2.)+\n        mod (floor(p.z/30.),2.) ,2.);\n vec3 c2= vec3(0.9,  0.9, 0.8);\n vec3 c= d<z?c2:vec3(c1);\n return vec4(min(d,z) ,c)\n               ;\n\n }\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 700.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.42);\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( ro +vec3(0,10,10) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        vec3 lin = vec3(0.0);\n       lin += 1.30*dif*vec3(1.00,0.80,0.55);\n         lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        // lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n        // lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.6);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 mo = (iMouse.xy/iResolution.xy);\n\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n      vec2 mouse = iMouse.xy / iResolution.xy;\n    //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\n     //   vec3 ro =  vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n\n    vec3 eye = vec3(sin(iTime/1.2+6.*mo.x)*290., cos(iTime/1.43+6.*mo.x)*290., cos(iTime/3.+6.*mo.y)*126. +100.);\n    vec3 centre = vec3(0.0, 0.0, cos(iTime/2.1)*50. +50.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 10.0);\n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}