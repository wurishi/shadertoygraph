{"ver":"0.1","info":{"id":"Nstcz2","date":"1653762839","viewed":177,"name":"my first raymacher from scratch","username":"SONENEIS","description":"i was two days programing. enjoy :)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","demo","first"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265\n#define tau pi * 2.0\n\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define START_STEPS 0\n#define STEP_NUMS 1000\n#define PRECISION 1e-3\n#define EPSILON 5e-4\n\nstruct Sky{\n\tvec3 col;\n\tvec3 mist;\n};\nSky sky = Sky(\n  vec3(0.2,0.6,1.0),\n  vec3(0.9,0.9,1.0)\n);\n\n//materials\nstruct Phong{\n\t//ambient\n\tfloat k_a;\n\tvec3 i_a;\n\t//diffuse\n\tfloat k_d;\n\tvec3 i_d;\n\t//specular\n\tfloat k_s;\n\tvec3 i_s;\n\tfloat alpha;\n};\nstruct Material{\n\tPhong phong;\n\tvec3 col;\n};\nMaterial rubber(vec3 col){\n  //ambient\n  float i_a = 0.6;\n  vec3 k_a = vec3(0.0,0.0,0.0);\n  //diffuse\n  float i_d = 1.0;\n  vec3 k_d = vec3(1.0);\n  //specular\n  float i_s = 0.6;\n  vec3 k_s = vec3(1.0,1.0,1.0);\n  float alpha = 10.0;\n\n  Phong phong = Phong(i_a,k_a, i_d,k_d, i_s,k_s,alpha);\n\n  return Material(phong,col);\n}\n\n//transform\nmat3 unTransform(){\n\treturn mat3(\n\t\tvec3(0,0,0),\n\t\tvec3(0,0,0),\n\t\tvec3(0,0,0)\n\t);\n}\nmat3 rotateX(float angle){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat3(\n\t\tvec3(1,0,0),\n\t\tvec3(0,c,-s),\n\t\tvec3(0,s,c)\n\t);\n}\nmat3 rotateY(float angle){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat3(\n\t\tvec3(c,0,s),\n\t\tvec3(0,1,0),\n\t\tvec3(-s,0,c)\n\t);\n}\nmat3 rotateZ(float angle){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat3(\n\t\tvec3(c,-s,0),\n\t\tvec3(s,c,0),\n\t\tvec3(0,0,1)\n\t);\n}\n\n//sdfs\nstruct object{\n\tfloat sdf;\n  Material mate;\n};\nobject sdfSphere(vec3 uv3d,vec3 pos,float rad,mat3 transform,vec3 pivot,Material mate){\n\tfloat circ = length((uv3d - pos) * transform - pivot) - rad;\n\treturn object(circ,mate);\n}\nobject sdfCube(vec3 uv3d,vec3 pos,float size,mat3 transform,vec3 pivot,Material mate){\n\tvec3 q = abs((uv3d - pos) * transform - pivot) - size;\n\tfloat cube = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\treturn object(cube,mate);\n}\nobject sdfPlane(float uv3d,float pos,Material mate){\n\tfloat pln = uv3d - (-pos);\n\treturn object(pln,mate);\n}\n\n//operations\nobject opUnion(object obj1,object obj2){\n  if(obj1.sdf < obj2.sdf)\n    return obj1;\n  else\n    return obj2;\n}\nobject opSmoothUnion(object obj1,object obj2, float k){\n\tfloat h = clamp(0.5 + 0.5*(obj2.sdf-obj1.sdf)/k,0.0,1.0);\n\tfloat sdf = mix(obj2.sdf,obj1.sdf,h) - k*h*(1.0-h);\n  object res = object(sdf,obj1.mate);\n  res.mate.col = mix(obj2.mate.col,obj1.mate.col,h);\n  return res;\n}\nobject opIntersection(object obj1,object obj2){\n  if(obj1.sdf > obj2.sdf)\n    return obj1;\n  else\n    return obj2;\n}\nobject opSmoothIntersection(object obj1,object obj2, float k){\n\tfloat h = clamp(0.5 - 0.5*(obj2.sdf-obj1.sdf)/k,0.0,1.0);\n\tfloat sdf = mix(obj2.sdf,obj1.sdf,h) + k*h*(1.0-h);\n  object res = object(sdf,obj1.mate);\n  res.mate.col = mix(obj2.mate.col,obj1.mate.col,h);\n  return res;\n}\nobject opSubtraction(object obj1,object obj2){\n  obj1.sdf = -obj1.sdf;\n  if(obj1.sdf > obj2.sdf)\n    return obj1;\n  else\n    return obj2;\n}\nobject opSubtraction2(object obj1,object obj2){\n\tobj2.sdf = -obj2.sdf;\n  if(obj1.sdf > obj2.sdf)\n    return obj1;\n  else\n    return obj2;\n}\nobject opSmoothSubtraction(object obj1,object obj2, float k){\n\tfloat h = clamp(0.5 - 0.5*(obj2.sdf+obj1.sdf)/k,0.0,1.0);\n\tfloat sdf = mix(obj2.sdf,-obj1.sdf,h) + k*h*(1.0-h);\n  object res = object(sdf,obj1.mate);\n  res.mate.col = mix(obj2.mate.col,obj1.mate.col,h);\n  return res;\n}\nobject opSmoothSubtraction2(object obj1,object obj2, float k){\n\tfloat h = clamp(0.5 - 0.5*(obj2.sdf+obj1.sdf)/k,0.0,1.0);\n\tfloat sdf = mix(obj1.sdf,-obj2.sdf,h) + k*h*(1.0-h);\n  object res = object(sdf,obj1.mate);\n  res.mate.col = mix(obj2.mate.col,obj1.mate.col,1.0-h);\n  return res;\n}\n\nobject sdfScene(vec3 uv3d){\n\tobject d;\n\n  vec3 rim_col = vec3(0.1,0.4,0.9);\n\n  object obj; {\n    object cube = sdfCube(uv3d,\n  \t  vec3(0.0,0.5,0.0),0.4,\n  \t  rotateX(iTime)*rotateY(iTime)*rotateZ(iTime),vec3(0.0,0.0,0.0),\n  \t  rubber(\n  \t\t  vec3(0.1,0.05,1.0)\n  \t  )\n    );\n    cube.sdf -= 0.1;\n    cube.sdf += sin(uv3d.x*40.0)*cos(uv3d.y*40.0)*sin(uv3d.z*40.0) * 0.005;\n    \n    object sphere = sdfSphere(uv3d,\n  \t  vec3(0.0,0.5,0.0),0.525,\n  \t  rotateX(iTime)*rotateY(iTime)*rotateZ(iTime),vec3(0.0,0.0,0.0),\n  \t  rubber(\n  \t\t  vec3(1.0,0.0,0.0)\n  \t  )\n    );\n    sphere.sdf += sin(uv3d.x*1.0)*sin(uv3d.y*1.0)*uv3d.z * 0.5;\n    sphere.sdf += sin(uv3d.x*30.0)*sin(uv3d.y*30.0)*uv3d.z * 0.005;\n    \n    obj = opSmoothSubtraction2(cube,sphere,0.1);\n    //obj = cube;\n    //obj = sphere;\n  }\n\n  object plane = sdfPlane(uv3d.y,0.1,\n  \trubber(vec3(\n  \t  //0.1+0.25*mod(floor(uv3d.x*5.0)+floor(uv3d.y*5.0)+floor(uv3d.z*5.0),2.0)\n      texture(iChannel0,uv3d.xz*2.0).rgb\n    ))\n  );\n  plane.sdf += sin(uv3d.x*40.0)*cos(uv3d.z*40.0) * 0.005;\n  plane.sdf += sin(uv3d.x*5.0)*cos(uv3d.z*5.0) * 0.05;\n  plane.sdf += sin(uv3d.x*3.0)*cos(-uv3d.z*7.0) * 0.01;\n  plane.sdf += sin(uv3d.x*9.0)*cos(-uv3d.z*2.0) * 0.03;\n  plane.sdf += sin(uv3d.x*1.0)*cos(uv3d.z*1.0) * 0.5;\n  plane.sdf += sin(uv3d.x*0.1)*cos(uv3d.z*0.1) * 1.0;\n  plane.sdf += sin(uv3d.x*50.0)*cos(uv3d.z*50.0) * 0.001;\n  plane.sdf += sin(uv3d.x*75.0)*cos(uv3d.z*75.0) * 0.001;\n  plane.sdf += sin(uv3d.x*100.0)*cos(uv3d.z*100.0) * 0.0005;\n  plane.sdf += sin(uv3d.x*125.0)*cos(uv3d.z*125.0) * 0.0001;\n  plane.sdf += sin(uv3d.x*150.0)*cos(uv3d.z*150.0) * 0.00007;\n  \n  object water = sdfPlane(uv3d.y,0.25,\n  \trubber(vec3(\n      //0.01,0.05,1.0\n      0.0,0.0,0.3\n    ))\n  );\n  water.sdf += sin(cos(iTime)*10.0+uv3d.x*sin(iTime)*5.0+2.5)*cos(sin(iTime)*10.0+uv3d.z*cos(iTime)*5.0+2.5) * 0.05;\n  \n  object floor = opSmoothUnion(plane,water,0.3);\n  \n  d = opSmoothUnion(floor,obj,0.5);\n\n\treturn d;\n}\n\nvec3 getNormal(vec3 uv3d){\n\tvec2 e = vec2(1.0,-1.0) * EPSILON;\n\treturn normalize(vec3(\n\t\te.xyy * sdfScene(uv3d + e.xyy).sdf +\n\t\te.yyx * sdfScene(uv3d + e.yyx).sdf +\n\t\te.yxy * sdfScene(uv3d + e.yxy).sdf +\n\t\te.xxx * sdfScene(uv3d + e.xxx).sdf\n\t));\n}\n\nobject raymarch(vec3 ro,vec3 rd){\n\tfloat depth = MIN_DIST;\n\tobject h;\n\tfor(int i=START_STEPS;i<STEP_NUMS;i++){\n\t\tvec3 uv3d = ro + depth*rd;\n\t\th = sdfScene(uv3d);\n\n\t\tif(h.sdf < PRECISION || depth > MAX_DIST) break;\n\n\t\tdepth += h.sdf;\n\t}\n\treturn object(depth,h.mate);\n}\n\nfloat softShadow(vec3 ro,vec3 rd,float start,float end){\n  float res = 1.0;\n  float t = start;\n  float k = 10.0;\n  for(int i=0;i<16;i++){\n  \tfloat h = sdfScene(ro + t*rd).sdf;\n  \tres = min(res,k*h/t);\n  \tt += clamp(h,0.02,0.1);\n  \tif(h < PRECISION || t > end) break;\n  }\n  return clamp(res,0.0,1.0);\n}\n\nstruct Light{\n\tvec3 dir;\n\tvec3 col;\n\tfloat itensity;\n\tfloat shadow;\n\tvec3 add;\n};\nLight light(vec3 uv3d,vec3 ro,vec3 rd,object depth,vec3 amb_col,float iten,vec3 pos,vec3 col){\n  vec3 normal = getNormal(uv3d);\n  vec3 dir = normalize(pos - uv3d) * 0.9;\n\n  //float shadow = clamp(raymarch(uv3d+normal*PRECISION,dir).sdf*0.1,0.0,1.0);//softShadow(uv3d,dir,0.01,100.0);\n  float shadow = clamp(softShadow(uv3d,dir,0.02,2.5),0.1,1.0);\n\n  vec3 phong; {\n    //ambient\n    float k_a = depth.mate.phong.k_a;\n    vec3 i_a = depth.mate.phong.i_a + amb_col + 0.1*depth.mate.col;\n    vec3 ambient = k_a * i_a;\n    //diffuse\n    float k_d = depth.mate.phong.k_d;\n    float dotLN = clamp(dot(dir,normal),0.0,1.0);\n    vec3 i_d = depth.mate.phong.i_d * depth.mate.col;\n    vec3 diffuse = col*(k_d * dotLN * i_d) * shadow;\n    //specular\n    float k_s = depth.mate.phong.k_s;\n    float dotRV = clamp(dot(reflect(dir,normal),rd),0.0,1.0);\n    vec3 i_s = col*depth.mate.phong.i_s;\n    float alpha = depth.mate.phong.alpha;\n    vec3 specular = k_s * pow(dotRV,alpha) * i_s;\n\n    phong = ambient + diffuse + specular;\n  }\n  return Light(dir,col,iten,shadow,phong*iten);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  uv *= 2.0;\n\n  float fov = -1.0;\n  vec3 ro = vec3(0.0,0.5,3.0);\n  vec3 rd = normalize(vec3(uv,fov));\n  \n  rd *= rotateZ(sin(iTime));\n  ro.z += cos(iTime);\n  \n  object depth = raymarch(ro,rd); {\n  \tvec3 uv3d = ro + depth.sdf*rd;\n  \tvec3 normal = getNormal(uv3d);\n\n  \tvec3 amb_col = 0.15 * sky.col*sky.mist;\n  \tvec3 amb = amb_col*clamp(0.5 + 0.5*dot(normal,vec3(0.0,1.0,0.0)),0.0,1.0);\n\n    Light sun = light(uv3d,ro,rd,depth,amb_col,\n      1.0,\n    \tvec3(1.0,1.0,1.0),\n    \tvec3(1.0,1.0,0.8)\n    );\n\n    vec3 lights = sun.add;\n\n    if(depth.sdf > MAX_DIST){\n      col = sky.col - 0.7*rd.y;\n      col = mix(col,sky.mist,exp(-10.0*rd.y));\n    }else{\n      vec3 rim; {\n      \tfloat fresnel = pow(clamp(1.0-dot(normal,-rd),0.0,1.0),5.0);\n      \tvec3 rim_col = 0.75*sky.col;\n      \trim = rim_col*fresnel;\n      }\n\n      //render\n      col = lights + rim;\n\n      //gamma correction\n    \tcol = pow(col,vec3(1.0/2.2));\n      //mist\n      col = clamp(mix(col,sky.mist,1.0-exp(-1e-4*pow(depth.sdf,3.0))),0.1,1.5);\n    }\n\n    col ;\n  }\n\n  fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}