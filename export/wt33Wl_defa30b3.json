{"ver":"0.1","info":{"id":"wt33Wl","date":"1577913743","viewed":296,"name":"Cosmic jellyfish","username":"maz","description":"Volumetric rendering of a sphere with a perturbed surface","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","implicitsurface","volumetricrendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP 0.01\n\nfloat noise2(vec2 p)\n{\n   return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat interpolateNoise2d(vec2 p)\n{\n   vec2 intp = floor(p);\n   vec2 fractp = fract(p);\n\n   float v1 = noise2(intp + vec2(0.,0.));\n   float v2 = noise2(intp + vec2(1.,0.)); \n   float v3 = noise2(intp + vec2(0.,1.));\n   float v4 = noise2(intp + vec2(1.,1.));\n\n   float i1 = mix(v1 , v2 , fractp.x);\n   float i2 = mix(v3 , v4 , fractp.x);\n   return mix(i1 , i2 , fractp.y);\n}\n\nfloat getValue(vec2 p, float frequency)\n{\n   float total = 0.0;\n   total += interpolateNoise2d(p * frequency);\n   total += interpolateNoise2d(p * frequency * 2.);\n   return total/2.;\n}\n\nvec3 displace(in vec3 pos)\n{\n   float t = abs(sin(0.5*iTime)); \n   float f = (1.0-t)*4.0 + t*4.8;\n   float offset = getValue(pos.xy, f);\n   offset = offset * 1.5 - 0.5; \n   vec3 normal = normalize(pos);\n   vec3 tmp = pos + offset * normal; \n   return tmp;\n}\n\nfloat density(in vec3 local)\n{\n   vec3 dir = normalize(local);\n   vec3 r = displace(dir);\n   float rr = dot(r,r);\n   float pp = dot(local,local);\n   if (rr >= pp) // inside puff\n   {\n      return 0.5;\n   }\n\n   // Return r - |x|^2/r^2 inside sphere; 0 otherwise\n   float tmp = sqrt(rr) - pp/rr;  \n   return tmp > 0.000001? tmp : 0.0;\n}\n\nvec4 puffcolor(in vec3 local)\n{\n   vec4 inner = vec4(0.8, 0.0, 0.0, 1.0);  \n   vec4 outer = vec4(1.0, 1.0, 0.0, 1.0);  \n   float tmp = max(0.0, min(1.0, 1.0 - abs(length(local))));  \n   return inner*tmp + (1.0-tmp)*outer;\n}\n\nvec4 background(in vec2 fragCoord)\n{\n   vec4 bcolor1 = vec4(0.5, 0.0, 0.5, 1.0);\n   vec4 bcolor2 = vec4(0.1, 0.0, 0.1, 1.0);\n   float t = fragCoord.y/iResolution.y;\n   return (1.0-t)*bcolor1 + t*bcolor2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 pos = (4.*fragCoord.xy - 2.*iResolution.xy)/iResolution.y;\n   vec3 vo = vec3(0.0, 0.0, 2.0);\n   vec3 vd = normalize(vec3(pos.xy,0.0) - vo);\n   vec3 center = vec3(0.,0.1*sin(iTime)-0.2, 0.);\n\n   float transmitivity = 1.0;\n   float kappa = 0.2;\n   vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n   vec4 diffuse = vec4(1.,1.,1.,1.);\n   for (float t = 1.0; t < 4.0; t += STEP)\n   {\n      vec3 pt = vo + t*vd;\n      vec3 local = pt - center;\n    \n      // Get color and transmitivity\n      float density = density(local);\n      float transmitivityDelta = exp(-kappa*STEP*density);\n      transmitivity *= transmitivityDelta;\n\n      vec4 pcolor = puffcolor(local);\n      color = color + ((1.0 - transmitivityDelta)/kappa)*transmitivity*pcolor; \n   } \n\n   fragColor = color + transmitivity*background(fragCoord);\n}\n\n","name":"Image","description":"","type":"image"}]}