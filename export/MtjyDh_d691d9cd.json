{"ver":"0.1","info":{"id":"MtjyDh","date":"1508568975","viewed":162,"name":"Hello Ray Marching","username":"2YY","description":"looks like moon","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void shading() {}\n\n\n\n\n/**\n  * シーンの距離関数。\n  * 今回はシーンを、3次元の座標系の原点に球が配置されているだけ、と定義する。\n  * @param {vec3} p カメラの座標\n  * @param {float} r 球の半径\n  * @return {float} 座標　p からシーンの物体(今回の場合、単一の球)への最短距離\n  */\nfloat scene(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0; // 今回は計算上、ビューポートの座標系を、画面の上下左右中心を(0, 0)として、x = -1〜1、　ｙ　= -1 〜 1 にする必要がある。ビューポート(=カメラ画面領域の中心)の中心を原点として、そこから各ドットへの方向(=レイの方向)を特定しなければならないので。\n    uv.y *= iResolution.y / iResolution.x; // 座標系に画面サイズを使っているので、そのままだと、座標系が長方形に引き伸ばされてしまう。ので、長方形の座標系を正方形の座標系に変換しておきます。\n    vec3 cameraPos = vec3(0.0, 0.0, 1.0); // 今回のシーンでは球を原点に置くので、カメラは原点からちょっとズレたところに置いておく。\n    vec3 rayPos = vec3(uv.xy + cameraPos.xy, cameraPos.z);\n    vec3 rayDirection = normalize(rayPos) * -1.0; // レイ(カメラ)の方向は原点に向ける(球を原点に配置するので)\n    float rayLength = 0.0;\n    vec3 rayPoint = rayPos; // レイマーチング中にレイの先端の位置を記録するための作業変数\n    bool isCollisioned = false; // レイが球にヒットすると立つフラグ\n\n    // レイマーチング\n    for(int i=0; i<1; i++) {\n        rayLength += scene(rayPoint, 0.5);\n        if(rayLength < 0.61 + ((sin(iTime)*0.5+0.5)*0.1)) {\n            isCollisioned = true;\n            break;\n        }\n        rayPoint = cameraPos + rayDirection * rayLength;\n    }\n\n    // 描画\n    fragColor = vec4(isCollisioned);\n}","name":"Image","description":"","type":"image"}]}