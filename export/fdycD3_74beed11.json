{"ver":"0.1","info":{"id":"fdycD3","date":"1655689897","viewed":191,"name":"Four Mud Balls","username":"meowyih","description":"This shader shows how to do the simple volumetric lighting using ray marching. For any beginner who has problem to understand my code, you might want to check my other two simple shaders first - \"Colorful Smoke Tunnel\" and \"Dark Cloud and Dark River\".","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lighting","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader shows how to do the simple volumetric lighting using ray marching\n// The code will be explained in my post in the bbs ptt.cc #1Yh_oR3V (GameDesign)\n//\n// For any beginner who has problem to understand my code, you might want\n// to check my other two shaders below first:\n// 1. https://www.shadertoy.com/view/7syyWG <= simplest ray marching\n// 2. https://www.shadertoy.com/view/sdVcDG <= add some object in ray maching world\n\n////////////////////////////////////////////////////////////////////////////////////////\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\n////////////////////////////////////////////////////////////////////////////////////////\n\n// rotation matrix for fbm octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n              \n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// iq's fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\treturn f/0.875;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// end of iq's 3d noise functions from the elevated shader\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst vec3 LIGHT_POS = vec3( -2.1, -2.6, 1.2 );\n\nvoid ball_1( vec3 pos, out float distance, out float density )\n{\n    vec3 center = vec3( 0.5, 0., 1.2 );\n    float radius = 0.5;\n    distance = length(pos-center) - radius + fbm(pos*14.-iTime*0.2) * 0.14;\n    density = (1. - step(0., distance))*(1.-length(pos-center)/radius);\n}\n\nvoid ball_2( vec3 pos, out float distance, out float density )\n{\n    vec3 center = vec3( -0.3, -0.1, 1.2 );\n    float radius = 0.5;\n    distance = length(pos-center) - radius + fbm(pos*10.5-iTime*0.2) * 0.13;\n    density = (1. - step(0., distance))*(1.-length(pos-center)/radius);\n}\n\n\nvoid ball_3( vec3 pos, out float distance, out float density )\n{\n    vec3 center = vec3( 0.2, 0.3, 1.1 );\n    float radius = 0.5;\n    distance = length(pos-center) - radius + fbm(pos*13.+iTime*0.2) * 0.12;\n    density = (1. - step(0., distance))*(1.-length(pos-center)/radius);\n}\n\nvoid ball_4( vec3 pos, out float distance, out float density )\n{\n    vec3 center = vec3( 0.2, -0.3, 1.1 );\n    float radius = 0.5;\n    distance = length(pos-center) - radius + fbm(pos*13.+iTime*0.2) * 0.12;\n    density = (1. - step(0., distance))*(1.-length(pos-center)/radius);\n}\n\nvoid world( vec3 pos, out float distance, out float density )\n{\n    float den1, den2, den3, den4;\n    float dis1, dis2, dis3, dis4;\n    \n    ball_1( pos, dis1, den1 );\n    ball_2( pos, dis2, den2 );\n    ball_3( pos, dis3, den3 );\n    ball_4( pos, dis4, den4 );\n    \n    // the shortest length to one of the balls\n    distance = min( min( min( dis1, dis2 ), dis3 ), dis4 );\n    \n    // calculate the sum of density\n    density = den1;\n    density += (1. - density)*den2;\n    density += (1. - density)*den3;\n    density += (1. - density)*den4;\n    \n    // if the object is solid, we can use:\n    // density = max( max( max( den1, den2 ), den3 ), den4 );\n}\n\nfloat lightmarch( vec3 ro, vec3 light_pos )\n{\n    float density_sum = 0.;\n    vec3 rd = normalize(light_pos - ro);\n    vec3 pos = ro + rd * 0.01; // move a little bit.\n    \n    for ( int i = 0; i < 5; i ++ )\n    {        \n        float distance, density;\n\n        world( pos, distance, density );\n        \n        density_sum += (1. - density_sum)*density;\n        \n        distance = max(distance, 0.1 );\n        pos += rd * distance;\n    }\n    \n    return density_sum;\n}\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 color_sum = vec4(0.);\n    float density_sum = 0.0;\n    vec3 pos = ro;\n    \n    for ( int i = 0; i < 20; i ++ )\n    {\n        if ( density_sum > 0.95 )\n            break;\n        \n        float distance;\n        float density;\n        vec4 color;\n        \n        float t; // light transmission weight\n        \n        world(pos, distance, density );\n        \n        density_sum += (1. - density_sum)*density;\n        \n        // calculate base color based on density\n        color.rgb = vec3(1.0);\n        color.a = density;\n        \n        // calculate transmission light ratio\n        t = lightmarch( pos, LIGHT_POS );\n        \n        // why (1.0-t)? Because the lower t means the more light can reach the pos\n        vec3 light_color = vec3(1.0,0.6,0.3);\n        vec3 ambient_color = vec3(0.91,0.98,1.05);\n        color.rgb = color.rgb * (light_color*(1.0-t) + ambient_color);\n        \n        // accumate final color, very similar to what we do for the density_sum\n        color.a *= 0.4; \n        color.rgb *= color.a; \n        color_sum += color * (1.0 - color_sum.a); \n        \n        // move to next step\n        distance = max(distance, 0.001 );\n        pos = pos + rd*distance;\n    }\n    \n    density_sum = pow( density_sum, 2.2 );\n    \n    return color_sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (0,0) is at the center of screen, and y-axis range is from [1, -1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // we stand in position 0,0,0\n    vec3 ro = vec3(0.,0.,0.);\n\n    // we got ray direction from uv\n    vec3 rd = normalize(vec3(uv,1.) );  \n    \n    // get final color from ray marching\n    vec4 color = raymarch( ro, rd );\n\n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"}]}