{"ver":"0.1","info":{"id":"Md3BWX","date":"1527319588","viewed":419,"name":"Pilot waves 2","username":"rory618","description":"using stochastic routing to simulate many particles interacting with some kind of wave field. The result is a dynamical system made of both particles and a field, reminiscent of pilot wave theory.","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["wave","particles","stochastic","routing","pilot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Pilot waves\" by rory618. https://shadertoy.com/view/XstfRj\n// 2018-05-22 04:05:54\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    o = vec4(0);\n    o += texture(iChannel0,uv).x;\n    o += texture(iChannel1,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < 20; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = floor(r.x * particles)+.5;\n        vec2 t = getParticle(id,R,iChannel0).xy;//Uniformly sample one of the particles\n\n        float dp = length(i-t*R.xy);\n        //compute the length to see if it is closer than the current champion\n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.x = id;//Output the nearest points ID\n        }\n    }\n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < 20; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        //Sample using a shrinking normal distribution\n        float id = texture(iChannel1,(i+randn(r.zw)*27.)/R.xy)[j==0?1:0];\n        vec2 t = getParticle(id,R,iChannel0).xy;\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.y = id;\n        }\n    }\n    \n    d=1e9;\n    for(int j = 0; j < 20; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*9.)/R.xy)[j==0?2:1];\n        vec2 t = getParticle(id,R,iChannel0).xy;\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.z = id;\n        }\n    }\n    d=1e9;\n    \n    for(int j = 0; j < 20; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*3.)/R.xy)[j==0?3:2];\n        vec2 t = getParticle(id,R,iChannel0).xy;\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.w = id;\n        }\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec2 uv = i/R.xy;\n    vec4 s = hash44(vec4(floor(i),0,1));\n    vec4 r = hash44(vec4(floor(i),F,0));\n    o = texture(iChannel0,uv);\n    vec2 v = unpackSnorm2x16(floatBitsToUint(o.z));\n    vec2 w = unpackSnorm2x16(floatBitsToUint(o.w));\n    if(iFrame<3){\n        o.xy = r.xy;\n        v = (r.zw-.5)/20.;\n        w = vec2(r.zw);\n    }\n    vec2 g = -vec2(\n        texture(iChannel1,o.xy+vec2(1,1)/R.xy).x+\n        texture(iChannel1,o.xy+vec2(1,0)/R.xy).x*2.+\n        texture(iChannel1,o.xy+vec2(1,-1)/R.xy).x+\n        -texture(iChannel1,o.xy+vec2(-1,1)/R.xy).x+\n        -texture(iChannel1,o.xy+vec2(-1,0)/R.xy).x*2.+\n        -texture(iChannel1,o.xy+vec2(-1,-1)/R.xy).x\n        \n        ,\n        texture(iChannel1,o.xy+vec2(1 ,1)/R.xy).x+\n        texture(iChannel1,o.xy+vec2(0 ,1)/R.xy).x*2.+\n        texture(iChannel1,o.xy+vec2(-1,1)/R.xy).x+\n        -texture(iChannel1,o.xy+vec2(1 ,-1)/R.xy).x+\n        -texture(iChannel1,o.xy+vec2(0 ,-1)/R.xy).x*2.+\n        -texture(iChannel1,o.xy+vec2(-1,-1)/R.xy).x\n    \n    \n    );\n    float D = texture(iChannel1,o.xy).x-w.x;\n    w.y += D/4.;\n    w.x+=w.y;\n  // v /= 1.001;\n    v-=w.x*g/(D+1.);\n    //o.xy = fract(o).xy;\n    o.xy += v/R.xy;\n    v = v;//+.1*texture(iChannel1,o.xy).xy*sign(s.x-.25);\n    //o.zw += .01*vec2(sin(o.y*10.),cos(o.x*10.))/1e3;\n    if(iMouse.w > 1.){\n        vec2 d = (iMouse.xy-o.xy*R.xy);\n        v += 17.*d/(pow(length(d),2.));\n        v *= 1.-exp(-.4*length(d));\n    }\n    o.z = uintBitsToFloat(packSnorm2x16(v));\n    o.w = uintBitsToFloat(packSnorm2x16(w));\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    o = vec4(.1);\n    \n    for(int j = 0; j < 10; j++){//Rendering pass is just the last layer pass\n        \n        vec4 r = hash44(vec4(F,i,j));\n        r.zw = randn(r.zw);\n        float id = texture(iChannel1,(i+r.zw)/R.xy).w;\n\n                \n            \n        if(id >= 0.){\n            vec2 t = getParticle(id,R,iChannel0).xy;\n\t\t\t//draw particles by signed distance function\n            //It is very convinient that everything is still done by distance function\n            //so far. In fact \n            //#define length(x) abs(20.-length(x)) \n            //in common will convert this shader to drawing circles instead.\n            //this time just use all 10 iterations for the output\n        \tfloat d = length(i-t*R.xy);\n            //d = clamp(1.-d,0.,1.);\n            //o += vec4(1)*d;\n            o.x=float(d<1.);\n            o.zw = getParticle(id,R,iChannel0).zw;\n        }\n    }\n    o.x = clamp(o.x,0.,1.);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const float KEY_R  = 82.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n    vec2 l = texture(iChannel0, (fragCoord-vec2(2.5,0))/iResolution.xy).xy;\n    vec2 r = texture(iChannel0, (fragCoord+vec2(2.5,0))/iResolution.xy).xy;\n    vec2 u = texture(iChannel0, (fragCoord-vec2(0,2.5))/iResolution.xy).xy;\n    vec2 d = texture(iChannel0, (fragCoord+vec2(0,2.5))/iResolution.xy).xy;\n    \n    vec2 t = texture(iChannel0, fragCoord/iResolution.xy).xy;\n        \n    t = mix(t,(l+r+u+d)/4.,.3);\n        \n\tfloat DL = l.x-t.x;\n\tfloat DR = r.x-t.x;\n\tfloat DU = u.x-t.x;\n\tfloat DD = d.x-t.x;\n    \n    vec4 p = texture(iChannel2,fragCoord/iResolution.xy);\n    vec2 w = unpackSnorm2x16(floatBitsToUint(p.w));\n    float Dw = w.x - t.x;\n    p.x*=4.;\n    t.y += (DL+DR+DU+DD+Dw*p.x)/(p.x+4.);\n    t.x += t.y;\n    t.y *= .98;\n    \n    float f = iMouse.y/40.;\n    if(iResolution.y < 285.){\n        f = 100.;\n    }\n    f=0.;\n    //vec2 v = texture(iChannel2,fragCoord/iResolution.xy).zw;\n    //t = mix(t, w.x, texture(iChannel2,fragCoord/iResolution.xy).x );\n    \n    if(fragCoord.x<1. || fragCoord.y<1. || fragCoord.x>iResolution.x-1. || fragCoord.y>iResolution.y-1.){\n        t*=0.;\n    }\n    \n    if ( keyIsDown(KEY_R)) {\n        t *= 0.;\n    }\n    \n    \n    fragColor = vec4(t.x,t.y,0,1);\n}","name":"Buf D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n\nfloat particles = 1e5;\n\n    \nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//Convert uniform random to normal\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(r.x));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\nvec4 getParticle(float index,vec3 R, sampler2D ch){\n    \n    return texture(ch,(.5+vec2(mod(index,R.x),floor(index/R.x)))/R.xy).xyzw;\n    \n}","name":"Common","description":"","type":"common"}]}