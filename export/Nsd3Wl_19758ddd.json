{"ver":"0.1","info":{"id":"Nsd3Wl","date":"1630873797","viewed":885,"name":"Mysterious Roman Dodecahedron","username":"sylvain69780","description":"While visiting the Lugdunum Museum at Lyon (France) I was [url=https://sylvain69780.github.io/assets/images/roman_dodecahedron.jpg]shocked by a very strange artifact ! [/url]\nYou can play with it. Try to create your own Roman dodecahedron ! ","likes":52,"published":1,"flags":64,"usePreview":0,"tags":["icosahedron","dodecahedron","rounding","platonic","antiquities"],"hasliked":0,"parentid":"WtGXDD","parentname":"RayMarching starting point"},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llSSRz","filepath":"https://soundcloud.com/magicmusicensemble/mysterious-celtic-harp?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/magicmusicensemble/mysterious-celtic-harp?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n \n    Mysterious Roman dodecahedron\n    -----------------------------\n    \n    While visiting the Lugdunum Museum at Lyon (France) I was shocked by a very strange artifact ! \n    \n    A Roman dodecahedron or Gallo-Roman dodecahedron is a small hollow object \n    made of copper alloy which has been cast into a regular dodecahedral shape: \n    twelve flat pentagonal faces, each face having a circular hole of varying \n    diameter in the middle, the holes connecting to the hollow center. \n    Roman dodecahedra date from the 2nd to 4th centuries AD.    \n\n    Some people suggested it is a simple tool to make gloves because they are found \n    only on the north of Europe, I prefer to think it's a kind of magic object. \n    We will probably never know !\n    \n    It's amazing what people were able to do even before Shadertoy was created.\n\n    Related references:\n    \n    Roman dodecahedron - Wikipedia\n    https://en.wikipedia.org/wiki/Roman_dodecahedron\n\n    Wythoff explorer - mattz ♥ \n    https://www.shadertoy.com/view/Md3yRB\n\n    icosahedronal symmetry & Icosahedron Weave - DjinnKahn\n    https://www.shadertoy.com/view/Mly3R3\n    https://www.shadertoy.com/view/Xty3Dy\n\n    Polyhedron again - knighty\n    https://www.shadertoy.com/view/XlX3zB\n\n    Polyhedrons, many many polyhedrons... - Fractalforums\n    https://www.fractalforums.com/fragmentarium/solids-many-many-solids/30/\n        \n    Wythoff Mathematical Details - Greg Egan\n    http://www.gregegan.net/APPLETS/26/WythoffNotes.html\n        \n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n\n    IQ Distance functions\n    https://iquilezles.org/articles/distfunctions\n\n    Wythoff Polyhedra with Exact SDF - mla\n    https://www.shadertoy.com/view/WlccR8\n\n    The so-called \"folding\" technique consists in using a succession of reflections \n    to end up with a reduced domain of coordinates \n       \n    The **spherical** triangle used to fold the coordinates is (P, Q, R) with **fractions of PI** PI/2, PI/3 , PI/5 for angles. \n    Even if the drawing below is FLAT, it represents a triangle on a SPHERE.\n    \n      Q=3 *--__\n          |    ^^--__\n      R=2 *----------* P = 5\n    \n    The sum of these angles is more than PI (180°), this is because we are tiling a sphere here.\n    \n    The shape generated by the distance field using the z direction \n    is a Rhombic Triacontahedron made of 30 rhombic faces formed by 4 coplanar triangles.\n\n    Icosahedron and Dodecahedrons : you get it by rotation of the plan of this triangle around the X or Y axis.\n    R is the middle of an edge of the Ico or Dode\n    Q is the vertex of a Dode, middle of the face of an Ico\n    P is the vertex of an Ico, middle of the face of a Dode\n    \n*/\n\n// folding function - here only 3 fold loops \n// https://www.shadertoy.com/view/ltlGWM\n// https://en.wikipedia.org/wiki/Polyhedral_group\nvec3 opIcosahedralSymmetry( vec3 p )\n{    \n    // const float c = cos(PI/5.), s=sqrt(0.75-c*c);\n    // cos(PI/5.) = 0.80901699437\n    // const vec3 n = vec3(-0.5, -c, s);\n    const vec3 n = vec3(-0.5, -0.809, 0.309); \n    p = abs(p);\n    for (int i=0;i<3;i++) {\n        float side = dot(p, n);\n        if ( side > 0.0 ) break;\n        p -= 2.*min(0., side)*n;\n        if (i!=2) p.xy = abs(p.xy);\n    }\n    return p;\n}    \n\n// some rounded Ico & Dode\n\nfloat Ico(vec3 p) {\n    vec3 q = vec3(p.x - X_TO_ICO_VERTEX,-p.y,p.z-1.0); // position origin at the vertex\n    q.zy *= Rot(ICODIHEDRAL*.5); \n    // min added for interior distance\n    return length(max(q, 0.))+min(q.z, 0.);  // z can be used for interior distance\n}\n\nfloat Dode(vec3 p) {\n    vec3 q = vec3(-p.x,p.y - Y_TO_DODE_VERTEX,p.z-1.0); // position origin at the vertex\n    q.zx *= Rot(DODEDIHEDRAL*.5); \n    return length(max(q, 0.))+min(q.z, 0.); \n}\n\n// I played with these functions\n\nfloat GetDistDodecahedron(vec3 p) {\n    vec3 q = p - ICOMIDEDGE;      // move\n    q.xz *= Rot(DODEDIHEDRAL*.5); // rotate\n    // rounded edge\n    vec3 vtx = vec3(-q.x,q.y - Y_TO_DODE_VERTEX,q.z);\n    // onioning and rounding\n    float dDode = abs(length(max(vtx, 0.))+min(vtx.z, 0.)-.025)-.05; \n    // Holes are centered on the dodecaheron's faces center\n    vec2 pCenter = vec2(q.x - X_TO_DODE_CENTER,q.y);\n    float dHole = length( pCenter ) - .3;    \n    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico\n    float dSmallHole = abs(abs(length( q.xy-mix(vec2(0.0,Y_TO_DODE_VERTEX),vec2(X_TO_DODE_CENTER,0.0),.3) ) - .07)-.030)-.015;\n    // Spheres on the vertices (dodecahedron's vectrices are icosahedron face's centers)\n    float dCorners = length(p - ICOMIDFACE * 1.24)-.12;    \n    // blobby cross picked from IQ's magic box\n    float dBlobbyCross = sdBlobbyCross(vec2(q.x-X_TO_DODE_CENTER*.2,q.y)*13.0,0.80)/13.0-.03;\n    // combine\n    float dist = dDode;\n    float dCarvings = min(dHole,min(dSmallHole,dBlobbyCross));\n    dist = smax(dist,-(dHole+.1),.04);\n    dist += 0.008*smoothstep(0.01,-0.01,dCarvings);\n    dist = smin(dist,dCorners,.07);\n    return dist;\n}\n\nfloat GetDistIcosahedron(vec3 p) {\n    vec3 q = p - ICOMIDEDGE;     // move\n    q.yz *= Rot(ICODIHEDRAL*.5); // rotates the coordinates to have XY plan aligned with a ICO face's plan\n    // rounded edge\n    vec3 vtx = vec3(q.x - X_TO_ICO_VERTEX,-q.y,q.z);\n    float dIco = length(max(vtx, 0.))+min(vtx.z, 0.)-.10;\n    // Circles are centered on the icosahedron's faces\n    float dBigHole = abs(abs(abs(length(q.xy - vec2(0.0,Y_TO_ICO_CENTER))-.17)-.08)-.04)-.02;\n    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico\n    float dSmallHole = abs(abs(length( q.xy - mix(vec2(0.0,Y_TO_ICO_CENTER),vec2(X_TO_ICO_VERTEX,0.0),.60) ) - .07)-.025)-.010;\n    // little chains of spheres on the edges\n    float dBalls = length(q-vec3(round(q.x*20.0)/20.0,0.0,0.1))-.03;\n    // Corners of the Ico\n    q = p - ICOVERTEX * 1.3;      // move\n    q.xz *= Rot(DODEDIHEDRAL*.5); // rotate\n    float dCorners = length(q)-.04*(1.0+.5*sin(q.z*50.0));    \n    // combine\n    float dist = dIco;\n    float dCarvings = min(dBigHole,dSmallHole);\n    dist += 0.008*smoothstep(0.01,-0.01,dCarvings);\n    dist = smin(dist,dCorners-.13,.1);\n    dist = min(dist,dBalls);\n    return dist;\n}\n\n// Not sure it is but looks like\nfloat GetDistSmallStellatedDodecahedron(vec3 p) {\n    vec3 q = p;\n    q -= ICOMIDEDGE;\n    float an = DODEDIHEDRAL*.5; // angle of a face with the rhombic face\n    q.zx *= Rot(an);\n    vec2 vtx = q.xy;\n    float h = cos(DODEDIHEDRAL*.5)*X_TO_ICO_VERTEX; \n    h /= cos(an+DODEDIHEDRAL*.5); // Need to calculate again the intersection point with the folding plan\n    vtx.x -= h;\n    vec2 edge = normalize(vec2(h,-Y_TO_DODE_VERTEX));\n    mat2 r = mat2(edge.x,edge.y,-edge.y,edge.x);\n    vtx.xy *= r; // align xy coordinates to the edge\n    float dStella = length(max(vec3(vtx,q.z), 0.)) + min(max(vtx.x,max(vtx.y,q.z)),0.);  // z can be used for interior distance\n    float lines = clamp(q.x-h*.55,0.0,0.48);\n    dStella -= 0.01*smoothstep(-0.3,0.9,sin(lines*3.14*20.));\n    float dHorseShoe = sdHorseshoe(q.yx-vec2(0.0,0.4),vec2(sin(0.45),cos(0.45)),.14,vec2(.04));\n    dStella -= .1; // rounding\n    dStella = smax(dStella,-dHorseShoe,.02);\n    // get a smooth non-convex dihedral angle is a challenge\n    // here I build a base using 2 intersecting planes and smoothed angle\n    float dBase = smax(p.z-1.13,dot(p,ICOMIDFACE)-1.19,0.005);\n    return smin(dStella,dBase,.01 );\n}\n\n// Not sure it is but looks like\nfloat GreatDodecahedron(vec3 p) {\n    vec3 q = p;\n    q -= ICOMIDEDGE;\n    float an = -ICODIHEDRAL;\n    q.zy *= Rot(an);\n    vec3 vtx = vec3(q.x - X_TO_ICO_VERTEX,-q.y,q.z);\n    float dDode = length(max(vtx, 0.0)) + min(vtx.z, 0.0);\n    float dist = dDode -.05 + 0.008*smoothstep(0.01,-0.01,sdRoundedX(q.xy-vec2(0,0.15),.1,.02));\n    return dist;\n}\n\n// Not sure it is but looks like\nfloat GreatStellatedDodecahedron(vec3 p) {\n    vec3 q = p;\n    q -= ICOMIDEDGE; \n    float an = PI*.5-DODEDIHEDRAL*.5; // angle of a face with the rhombic face\n    q.zy *= Rot(an);\n    // tip of the polyhedron, point of intersection with folding plan\n    // TODO : Will make it more understandable using a 2D plan in desmos\n    // https://www.desmos.com/calculator/abjapu0oqi\n    float h = cos(ICODIHEDRAL*.5)*Y_TO_DODE_VERTEX/cos(an+ICODIHEDRAL*.5); \n    vec2 vtx = vec2(-q.x,q.y-h); // changing coordinates \n    vec2 edge = normalize(vec2(X_TO_ICO_VERTEX,h));\n    vtx.xy *= orient(edge); // align x coordinate to the edge vector\n    float dStella = length(max(vec3(vtx,q.z), 0.)) + min(q.z,0.);  // z can be used for interior distance\n    float lines = clamp(q.y-h*.45,0.0,0.48);\n    dStella -= 0.01*smoothstep(-0.3,0.9,sin(lines*3.14*20.));\n    // get a smooth non-convex dihedral angle is a challenge\n    // here I build a base using smoothed intersecting planes\n    float dBase = smax(p.z-1.25,dot(p,ICOVERTEX)-1.35,0.04);\n    float dist = smin(dStella- .1,dBase,0.02);\n    return dist;\n}\n\n// An experiment using some torus crossing at the intersect of the folding plans\nfloat TorusFlower(vec3 q) {\n    float r2 = .025;\n    float d = 1e10;\n    \n    {\n        float an = PI/3.;   // here you can change the width of the Vesicas\n        float r = 1.0;\n        vec3 n = vec3(1.,0.,0.);\n        n.zx *= Rot(an);   // XZ symetry plane, rotated of an angle around the Y axis\n        float dO = dot(ICOMIDFACE,n),         // calculate the distance between the plan and point ICOMIDFACE on the sphere\n        rCircle = sqrt(1.-dO*dO);             // radius of the circle at intersection of plan and sphere\n        d = distTorus(q-dO*n*r,rCircle*r,r2,n);   // draws the torus based this calculation\n    }\n    {\n        float an = (PI/5.+PI/2.)/2.;   // I found impossible to have a value to make it tangent to both triangle edges\n        float r = 0.95;\n        vec3 n = erot(P35,normalize(ICOVERTEX-ICOMIDFACE),an); // P35 symetry plan, rotated of an angle around the hypotenuse axis\n        float dO = dot(ICOMIDFACE,n),\n        rCircle = sqrt(1.-dO*dO);\n        d = min(d,distTorus(q-dO*n*r,rCircle*r,r2,n));\n    }\n    {\n        float an = PI/5.;  \n        float r = 1.05;\n        vec3 n = vec3(0.,1.,0.);\n        n.zy *= Rot(an);  \n        float dO = dot(ICOVERTEX,n),         \n        rCircle = sqrt(1.-dO*dO);            \n        d = min(d,distTorus(q-dO*n*r,rCircle*r,r2,n));   \n    }\n    return d;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\n// https://www.highlandwoodworking.com/sphereturning.html\n// Work in progress\nfloat ChineseBall(vec3 p) {\n    vec3 q = p;\n    float dDode = length(p)-1.0;\n    dDode = abs(dDode-.025)-.05; // onioning and rounding\n    // Holes are centered on the dodecaheron's faces center\n    q.xz *= Rot(DODEDIHEDRAL*.5); // rotates the coordinates to have XY plan aligned with a DODE face plan\n    vec2 pCenter = vec2(q.x - X_TO_DODE_CENTER,q.y);\n    pCenter = q.xy;\n    float dHole = length( pCenter ) - .55;    \n    // shaking mixing the distances\n    float dist = dDode;\n    dist = smax(dist,-(dHole+.1),.04);\n    return dist;\n}\n\n// IQ & filbs111\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    vec3 o = min(r, 0.0);\n    o = max(r*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n}\n// flockaroo - https://www.shadertoy.com/view/dlcGRH\nfloat GetDistFoldedOctahedron(vec3 p) {\n    float dist = sdOctahedron(p,1.5)-.04;\n    return dist;\n}\n\n\n\nconst float nShapes = 8.;\nfloat shapeID = 0.0;\nfloat GetDist(vec3 p) {\n    vec3 q = opIcosahedralSymmetry(p);\n//     Change shape ID here\n// shapeID=6.5;\n    float d = 1e10;\n    if ( shapeID < 0.5 )\n        d = GetDistDodecahedron(q);\n    else if ( shapeID < 1.5 )\n        d = GetDistIcosahedron(q);\n    else if ( shapeID < 2.5 )\n        { d = GetDistSmallStellatedDodecahedron(q/0.8)*0.8; }\n    else if ( shapeID < 3.5 )\n        { d = GreatDodecahedron(q/1.2)*1.2; }\n    else if ( shapeID < 4.5 )\n        { d = GreatStellatedDodecahedron(q*1.7)/1.7; }\n    else if ( shapeID < 5.5 )\n        { d = TorusFlower(q/1.22)*1.22; } \n    else if ( shapeID < 6.5 )\n        { d = ChineseBall(q); }\n    else if ( shapeID < 7.5 )\n        { d = GetDistFoldedOctahedron(q); }\n     float d2=min(q.x,min(q.y,dot(q,P35)))-.01;\n     d2 = max(d2,q.z-1.);\n   //  d = min(d,d2); // show folded space\n\n    return d;\n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.33*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 orange = vec3(1.00,.25,0.01);\n    vec3 sun   = vec3(1.64,1.27,0.99);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 0, -2.8);\n    shapeID = floor(fract(T/nShapes)*nShapes);\n    if( iMouse.z>0.001 )\n    {\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {   \n        ro.zx *= Rot(T*4.0);\n        ro.xy *= Rot(T*2.);\n    }\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.0);\n    vec3 bg = orange*cos(length(uv));\n    vec3 col = bg;\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 nor = texBump(iChannel0,p*.5,GetNormal(p),.005);\n        float occ = max(.1,calcOcclusion(p,nor));\n        vec3  lig1 = normalize( vec3( 0.10, 1.50, 0.40) );\n        vec3  lig2 = normalize( vec3(-1.50,-1.00, -1.00) );\n        vec3  lig3 = normalize( vec3( 1.50,-1.00, -1.00) );\n        // IQ's Blinn-Phong specular formula\n        float lig1_spe = pow(clamp(dot(nor,normalize( lig1-rd )),0.0,1.0),8.0) * max(0.0,dot(nor,lig1));\n        float lig2_spe = pow(clamp(dot(nor,normalize( lig2-rd )),0.0,1.0),8.0) * max(0.0,dot(nor,lig2));\n        float lig3_spe = pow(clamp(dot(nor,normalize( lig3-rd )),0.0,1.0),8.0) * max(0.0,dot(nor,lig3));\n        float sha1 = calcSoftshadow( p+0.01*nor, lig1, 0.01, 2.1 );\n        col = vec3(0);\n        col += 0.6 * lig1_spe * sun * sha1;\n        col += 0.2 * lig2_spe * orange * occ;\n        col += 0.2 * lig3_spe * orange * occ;        \n    } \n    \n    // https://graphtoy.com/?f1(x,t)=floor(fract(x/10)*10)&v1=true&f2(x,t)=pow(.5+.5*cos(x*6.28),32)&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=1.645933014354067,2.5645933014354068,12\n    col = mix(col,bg,pow(.5+.5*cos((2.*PI*fract(T))),32.));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n// Normal of a plan having a dihedral angle of PI/3 with the YZ plan and PI/5 with the XZ plane\nconst float CP = cos(3.1415/5.), SP=sqrt(0.75-CP*CP);\nconst vec3  P35 = vec3(-0.5, -CP, SP);\n\n// Dihedral angles of the Dode. and Ico.\n// This probably can be obtained using linera algebra calculations\n// https://en.wikipedia.org/wiki/Table_of_polyhedron_dihedral_angles\n\nconst float ICODIHEDRAL  = acos(sqrt(5.)/3.);  \nconst float DODEDIHEDRAL = acos(sqrt(5.)/5.);\n\n// below are the directions from the origin limiting the coordniate's domain after folding space\n// trivial, this is the Z axis\nconst vec3 ICOMIDEDGE = vec3(0,0,1); \n// direction in the XZ plan, the ICO vertex on this line\n// I think this is also the normal of a DODE face\nconst vec3 ICOVERTEX  = normalize(vec3(SP,0.0,0.5)); \n// direction in the YZ plan, you will find the DODE vertex on this line\n// I think this is also the normal of an ICO face\nconst vec3 ICOMIDFACE = normalize(vec3(0.0,SP,CP));  \n/*\n\n    This represents the up view of a Rhombic face at z = 1 \n    This can help to draw some figures on the faces\n\n                Y_TO_DODE_VERTEX\n                Y_TO_ICO_CENTER (after ICODIHEDRAL rotation on X axis)\n                \n                         ** \n                      ********\n                   ***   **    ***\n                ***      **       ***\n             ***         **          ***\n          ***            **             ***\n       ***               **                ***\n    ***                  ** (0,0)             ***\n ***************************************************  X_TO_ICO_VERTEX\n    ***                  **                   ***    X_TO_DODE_CENTER (after DODEDIHEDRAL rotation on Y axis)\n       ***               **                ***\n          ***            **             ***\n             ***         **          ***\n                ***      **       ***\n                   ***   **    ***\n                      ********\n                         ** \n\n*/\n\nconst float X_TO_ICO_VERTEX  = length(cross(ICOMIDEDGE,ICOVERTEX))/dot(ICOMIDEDGE,ICOVERTEX);\nconst float Y_TO_DODE_VERTEX = length(cross(ICOMIDEDGE,ICOMIDFACE))/dot(ICOMIDEDGE,ICOMIDFACE);\nconst float X_TO_DODE_CENTER = X_TO_ICO_VERTEX*cos(DODEDIHEDRAL*.5);\nconst float Y_TO_ICO_CENTER  = Y_TO_DODE_VERTEX*cos(ICODIHEDRAL*.5);\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// https://www.shadertoy.com/view/XsXfz2\n// distancefield of torus around arbitrary axis z\n// similar to https://iquilezles.org/articles/distfunctions\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z)\n{\n    float pz = dot(pos,normalize(z));\n    return length(vec2(length(pos-z*pz)-r1,pz))-r2;\n}\n\n\n// Blackle Mori\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nmat2 orient(vec2 a)\n{\n    return mat2(a.x,a.y,-a.y,a.x);\n}\n\n\n// Shane awesome work below\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define T (iTime*.05)\n\nconst float PI = 3.14159265359;\nconst float PHI = (1.+sqrt(5.))/2.;\n\n\n","name":"Common","description":"","type":"common"}]}