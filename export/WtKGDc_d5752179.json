{"ver":"0.1","info":{"id":"WtKGDc","date":"1580082058","viewed":91,"name":"Two-Helix","username":"timF","description":"Raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 30.0\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.0\n#define PI 3.14159265359\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat map(vec3 p){\n    \n    float plane = p.y+2.0; //the floor\n\n    //sphere 2 cuts out sphere 1\n    float the = iTime*.2;\n    float tha = iTime*.5;\n    \n    \n    \n    mat4 rMatrix1 = rotationMatrix(iTime,vec3(0,1,0));\n    mat4 rMatrix2 = rotationMatrix(iTime+3.14,vec3(0,1,0));\n\n    vec4 cyl1P = vec4(0,0,0,0);\n    vec4 cyl2P = vec4(0,0,0,0);\n\n    cyl1P.x += sin(p.y*.5)*2.0;\n    cyl1P.z += cos(p.y*.5)*2.0;\n\n    cyl1P = rMatrix1 * cyl1P;\n    cyl1P.xz += p.xz;\n\n    cyl2P.x += sin(p.y*.5) * 2.0;\n    cyl2P.z += cos(p.y* .5) * 2.0;\n\n    cyl2P = rMatrix2 * cyl2P;\n    cyl2P.xz += p.xz;\n\n    float cyl1 = sdCylinder(cyl1P.xyz + vec3(0.0,0.0,-2.0),vec2(1.0,10.));\n    float cyl2 = sdCylinder(cyl2P.xyz + vec3(0,0,-2),vec2(1,10));\n\n    float finalShape = min(cyl1, cyl2);\n    return finalShape;\n\n}\n\n\nvec3 getNormal(vec3 p){\n\t//sampling around the point\n\tvec2 e = vec2(0.01, 0.0); //eplison - small offset\n\tfloat d = map(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tmap(p-e.xyy),\n\t\t\t\t\tmap(p-e.yxy),\n\t\t\t\t\tmap(p-e.yyx));\n\treturn normalize(n);\n}\n\nfloat diffuseLighting(vec3 p) {\n    vec3 lightPosition = vec3(3,9,-3);\n    vec3 light = normalize(lightPosition - p); // normalize the vector\n    vec3 normal = getNormal(p);\n\n    float diffuse = clamp( dot(normal, light), 0., 1.); // percentage of similarity\n    return diffuse;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv.st * 2.0 - 1.0 ; // 0 is the center\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 1.0, -2.0); // change this to change the camera\n    vec3 rayDirection = normalize(vec3(uv, 1.));\n\n    float diffuse;\n    float distanceOrigin = 0.0; // initial distance from cam is 0\n\n    vec3 normal;\n    // you must define a max limit for marching...\n    // good upper limit is 128\n    for ( int i = 0; i < 128; i++ ) {\n\n        // start with camera origin + the incremented value, * ray Direction\n        vec3 position = rayOrigin + distanceOrigin * rayDirection;\n        //formula to create a sphere\n        float map = map(position); // just for naming\n        distanceOrigin += map; // check again after hitting the radius of the sphere\n\n        //set the near and far clipping plane\n        if (distanceOrigin < MIN_DISTANCE || distanceOrigin > MAX_DISTANCE) break;\n        diffuse = diffuseLighting(position);\n\n    }\n\n    distanceOrigin /= 2.; // couldn't see the map, so divide by 2\n\n    vec3 shape = vec3(1,1,1) * diffuse;\n    \n\n    vec4 color = vec4(shape,1);\n\n    // Output to screen\n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"}]}