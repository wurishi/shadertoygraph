{"ver":"0.1","info":{"id":"MltcR4","date":"1531856343","viewed":230,"name":"T Logo","username":"terkel","description":"My logo created using SDF. Click and drag to move eyes.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","logo","t","terkel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat circleSDF(vec2 st) {\n    return length(st-.5)*2.;\n}\n\nfloat rectSDF(vec2 st, vec2 s) {\n    st = st*2.-1.;\n    return max(abs(st.x/s.x),\n               abs(st.y/s.y));\n}\n\nvec2 skew(vec2 st, vec2 a) {\n    st = mat2(1., a.x,\n              a.y, 1.)*st;\n    return st;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st+.5;\n}\n\nvec2 scale(vec2 st, vec2 s) {\n    return (st-.5)*s+.5;\n}\n\nfloat aastep(float threshold, float value) {\n    #ifdef GL_OES_standard_derivatives\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n    #else\n    return step(threshold, value);\n    #endif\n}\n\nfloat fill(float x, float size) {\n    return 1.-aastep(size, x);\n}\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x+w*.5) - aastep(size, x-w*.5);\n    return clamp(d, 0., 1.);\n}\n\nfloat skewLine(vec2 st, float w, float dir) {\n    float mask = rectSDF(st, vec2(w, 1.0));\n    st.y = 1.0-st.y;\n    st = skew(st, vec2(0.0, dir));\n    float rect = rectSDF(st, vec2(w, 1.0));\n    return fill(mask, 1.0) * fill(rect, 1.0);\n}\n\nfloat TBase(vec2 st) {\n    float base;\n    float offset = 1.0-smoothstep(0.0, 0.1, abs(sin(iTime*1.5+1000.) - 0.95));\n\n    vec2 tUV = vec2(st.x, st.y-(offset*0.5));\n    float noseV = rectSDF(tUV, vec2(1.0, 7.0+offset));\n    base += fill(noseV, 1.0);\n    \n    tUV = vec2(st.x-3., st.y-3.-offset);\n    float noseH = rectSDF(tUV, vec2(5.0, 1.0));\n    base += fill(noseH, 1.0);\n    \n    tUV = rotate(st, radians(90.));\n\ttUV.x -= 5.+offset;\n    tUV.y += 5.99;\n    float noseT = skewLine(tUV, 5., 1.);\n    base += noseT;\n    \n    tUV = vec2(st.x+2., st.y+3.99);\n    float noseB = skewLine(tUV, 5., -1.);\n    base += noseB;\n    \n    tUV = vec2(st.x+7.5, st.y-3.-offset);\n    float left = skewLine(tUV, 6., -1.);\n    base += left;\n    \n    return base;\n}\n\nfloat TMouth(vec2 st) {\n    vec2 mUV = vec2(st.x+7.5, st.y+7.5);\n    float ring = stroke(circleSDF(mUV-4.5), 9., 2.0);\n    float mask = fill(rectSDF(mUV, vec2(7.5)), 1.0);\n    return ring * mask;\n}\n\nfloat TEye(vec2 st, float scale) {\n    float blink = smoothstep(1.0, .98, sin(iTime*2.0));\n\tfloat eyelid = fill(rectSDF(st, vec2(1.0, blink)), scale);\n    return fill(circleSDF(st), scale) * eyelid;\n}\n\nfloat TEyes(vec2 st) {\n    vec2 m = 0.5-(iMouse.xy/iResolution.xy);\n    st.x += m.x * 2.;\n    st.y += m.y * 0.5;\n    vec2 right = vec2(st.x-3., st.y-2.3);\n    vec2 left = vec2(st.x+7., st.y-2.3);\n    return TEye(right, 1.55) + TEye(left, 1.55);\n}\n\nconst vec2 SCALE = vec2(24.);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv = scale(uv, SCALE);\n    uv.x -= 0.42*SCALE.x;\n    uv.y -= 0.025*SCALE.y;\n    \n    float T;\n    T += TBase(uv);\n    T += TEyes(uv);\n    T += TMouth(uv);\n    \n    vec3 bg = 0.8 + 0.1*cos(iTime+(fragCoord/iResolution.xy).xyx+vec3(0,2,3));\n    \n    vec3 color = mix(bg, vec3(0.0, 0.0, 1.0), T);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}