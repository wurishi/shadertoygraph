{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//1. Go fullscreen\n//2. Take drugs now\n\n//iq noise fn\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n//x3\nvec3 noise3( in vec3 x)\n{\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\n\t\t\t\tnoise(x) );\n}\n\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\nfloat bias(float x, float b) {\n\treturn  x/((1./b-2.)*(1.-x)+1.);\n}\n\nfloat gain(float x, float g) {\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\n}\n\n\nmat3 rotation(float angle, vec3 axis)\n{\n    float s = sin(-angle);\n    float c = cos(-angle);\n    float oc = 1.0 - c;\n\tvec3 sa = axis * s;\n\tvec3 oca = axis * oc;\n    return mat3(\t\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\n}\n\nvec3 fbm(vec3 x, float H, float L, int oc)\n{\n\tvec3 v = vec3(0);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tfloat w = pow(f,-H);\n\t\tv += noise3(x)*w;\n\t\tx *= L;\n\t\tf *= L;\n\t}\n\treturn v;\n}\n\nvec3 smf(vec3 x, float H, float L, int oc, float off)\n{\n\tvec3 v = vec3(1);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tv *= off + f*(noise3(x)*2.-1.);\n\t\tf *= H;\n\t\tx *= L;\n\t}\n\treturn v;\t\n}\n\nvec2 Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return vec2(-1.,-1.);\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5/a;\n\tvec2 i = vec2(-b-d,-b+d)*oo2a;\n//\treturn vec2( min(i.x,i.y), max(i.x,i.y) );\n\treturn i;\n}\n\nvec2 RayEllipsoid(vec3 P, vec3 V, vec3 A)\n{\n\tA*=A;\n\tvec3 VP = V*P;\n\tP *= P;\n\tV *= V;\n\t\n\tvec3 S=A.yzx*A.zxy;\n\t\t\n\tfloat a = dot(V,S);\n\tfloat b = 2. * dot(VP,S);\n\tfloat c = dot(P,S) - A.x*A.y*A.z;\n\t\t\t\t\n\treturn Q(a,b,c);\n}\n\n//x^2   y^2   z^2   \n//--- + --- + --- = 1\n//a^2   b^2   c^2   \n\n//grad \n// 2x\n// --- \n// a^2\n\nvec3 NormalEllipsoid(vec3 P, vec3 A)\n{\n\treturn -normalize(P/(A*A));\n}\n\n#define pi 3.1415927\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvoid MakeViewRay(in vec2 fragCoord, out vec3 eye, out vec3 ray)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n//\tq.x = mod(q.x*3.,1.);\t//tile it for split views!\n//\tq.y = mod(q.y*2.,1.);\t//tile it for split views!\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.,0.,0.);\n\tfloat t = 24.4 + iTime*0.01; //iTime; //sin(iTime*.5)*.5;\n\teye = vec3(-2.5,0,2.5);\n\teye = RotY(eye,t*-0.5*pi);\t\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\nvec3 Colorize(vec3 p)\n{\n\tfloat time = iTime * 1.276;\n\t\n\tfloat slow = time*0.02;\n\t\n\tvec3 axis = 4. * fbm(p+vec3(0.,slow,0.), 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\n\t\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\n\tp += colorVec;\n\t\n//\tfloat mag = 4e5;\t//published, rather garish?\n\tfloat mag = 0.75e5; //still clips a bit\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\n\tcolorVec += colorMod;\n\t\n\tcolorVec = rotation(3.*length(axis)+slow*0.,normalize(axis))*colorVec;\n\t\n\tcolorVec *= 0.075;\n\t\t\t\n\tcolorVec = colorVec / (1. + length(colorVec));\t//tone it all down a bit\n\t\n\treturn colorVec;\n}\n\nfloat shlick(vec3 N, vec3 V)\n{\n\tfloat f = dot(-V,N);\n\tf = 1.0-f;\t\n\tfloat ff = f;\n\tf *= f;\t\t//2\n//\tf *= f;\t\t//4\n//\tf *= ff;\t//5\n\tfloat r0 = 0.025;\n\tf = r0 + (1.0-r0)*f;\n\treturn f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 mainViewP, mainViewD;\n\tMakeViewRay(fragCoord,mainViewP, mainViewD);\n\t\n\tvec3 bg = texture(iChannel0,mainViewD).xyz;\n\tbg = pow(bg,vec3(2.2));\n\t\t\n\tvec3 c = bg;\n\t\t\n//\tfloat s = sin(iTime)*0.025 + 1.;\n//\ts * t * u = 1;\n//  tu = 1/s\n//  t=u=sqrt(1/s);\n//\tfloat tu = sqrt(1./s);\n//\tA *= vec3(tu,s,tu);\n\t\n\tfor (int inst=0; inst<5; inst++) { \n\tvec3 viewP = mainViewP;\n\tvec3 viewD = mainViewD;\n\t\t\n\tvec3 A = vec3(.3,.4,.5)*2. * (1.-float(inst)*0.3);\n\t\t\n\t\t\n\tvec2 uv = fragCoord.xy /iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ax=noise3(vec3(uv*2.5,iTime*0.25+A.x));\n\tviewD=rotation(length(ax)*(0.05),normalize(ax))*viewD;\t\t//wibble the view ray to change bubble shape\n\t\n//\tviewP += (noise3(vec3(iTime*A.y,A.x,A.z))*2.-1.)*vec3(1.,0.6,1.1);\t\t//float around\n\t\t\n\tviewP += smf(vec3(iTime*A.y*.5,A.x,A.z), 0.51, 2.13, 2, 0.2)*vec3(1.,0.6,1.1);\t\t//float around\n\t\t\t\n\tviewP.yz -= (mod(iTime*0.05 + float(inst)*.37,1.)*2.-1.)*2.5;\t\t//float up\n\t\n\tvec2 tt = RayEllipsoid(viewP, viewD, A);\n\t\n\tif (tt.y > tt.x)\n\t{\n\t\ttt = tt.yx; //oops was blending over so go back to front.\n\t\t\n\t\tfor (int i=0; i<2; i++)\n\t\t{\n\t\t\tvec3 hit_p = tt[i]*viewD + viewP;\n\t\t\t\n\t\t\tvec3 n = NormalEllipsoid(hit_p, A);\n\t\t\t\t\n\t\t\tfloat facing = dot(n,-viewD) > 0. ? .25 : .025; //max(,0.);\n\t\t\t\n\t\t\tfloat e = 1.- abs(dot(n,viewD));\n\t\t\t\n\t\t\thit_p.y += iTime*0.1; \n\t\t\tvec3 soap_col = Colorize(RotY(n*0.5,A.x+iTime*0.2)-hit_p*0.1);\n\t\t\t\n\t\t\tvec3 soap = soap_col * (e + .5*length(soap_col));\n\t\t\t\n\t\t\t\n\t\t\tvec3 r = reflect(-viewD,n);\t\t\t//reflection\n\t\t\tr = texture(iChannel0,r).xyz;\n\t\t\tr = pow(r,vec3(2.2));\n\t\t\tfloat f = shlick(n, viewD);\t\t\t//fresnel\n\t\t\tsoap += f*r*facing;\n\t\t\t\n\t\t\tsoap *= 1.-pow(e,10.);\t//antialias\n\t\t\t//soap *= 1.-f;\n\t\t\t\n//\t\t\tc += soap;\n\t\t\tc = mix(c,soap,0.5*(length(soap)+0.5))+soap*.5;\n\t\t}\n\t}\n//\tc += tt.y - tt.x; \t\n\t\n\t}\n\t\n\tc = pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dB3zc","date":"1391469409","viewed":1938,"name":"Soap Bubbles","username":"Antonalog","description":"soapy bubbles","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["bubbles","soap"],"hasliked":0,"parentid":"","parentname":""}}