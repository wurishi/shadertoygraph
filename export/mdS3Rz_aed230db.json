{"ver":"0.1","info":{"id":"mdS3Rz","date":"1667102308","viewed":74,"name":"Flow streamlines","username":"Envy24","description":"Recreation of this shader: https://www.shadertoy.com/view/csXGz7","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["flow","streamlines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 8. / R.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., abs(d)) )\n#define SCENE_SCALE               ( 2. )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    return ((2. * (SC - MOUSE_OFFSET) - R.xy) / R.y) * scale - origin;\n}\n\nvec2 field(vec2 P)\n{\n    //return vec2(1, 1);\n    //return vec2(P.y, -P.x);\n    //return vec2(P.y*P.y, -P.x);\n    return rotateAroundZ(vec2(P.y, -P.x), iTime);\n    //return rotateAroundZ(vec2(P.y*P.y, -P.x), iTime);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0));\n    \n    float min_dist = 99., T = 10.*iTime;\n    vec3 color = vec3(0);\n    \n    for (float s = 0.; s < 40.; s += 1.)\n    {\n        vec2 B = H(s+T, s+T*2.0)*3., E;\n        \n        for (float i = 0.; i < 20. && abs(E.x) < AR*SCENE_SCALE && abs(E.y) < SCENE_SCALE; i+=1.)\n        {\n            E = B + field(B)*0.38;\n            \n            min_dist = min( min_dist, segmentSQSDF_L2(NDC, B, E, 0.) );\n            \n            B = E;\n        }\n        \n        float seed = s + 10.;\n        color = mix( color, HASH3(seed, seed+1., seed+2.), SMAA((sqrt(min_dist))) );\n        min_dist = 99.;\n    }\n        \n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat segmentSQSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B, P = BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    return dot(P, P) - R*R;\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define H(x, y) ( hash2to2(uint(x), uint(y)) )\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 hash3to3(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH3(x, y, z) ( abs(hash3to3(uint(x), uint(y), uint(z))) )","name":"Common","description":"","type":"common"}]}