{"ver":"0.1","info":{"id":"WtsyzS","date":"1592355761","viewed":555,"name":"Basic Water Ripples","username":"Xeke1404","description":"Just a first simple test to create a cheap water-like effect.\nuse your mouse to generate water/ripples.\nbackground noise + some highlighting is added.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2d","distortion","water","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//image has input B, stoneTexture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // lets calculate normals for distortion\n    float nFactor = 10.;\n    vec2 step = 2. / iResolution.xy;\n    vec2 xd = vec2( 1., 0.);\n    vec2 yd = vec2( 0., 1.);\n\tfloat nx = texture( iChannel0, uv + step * xd ).r - texture( iChannel0, uv - step * xd ).r;\n    float ny = texture( iChannel0, uv + step * yd ).r - texture( iChannel0, uv - step * yd ).r;\n    vec3 normal = normalize(vec3(nx * nFactor, 1., ny * nFactor));\n    \n    // blur the image a bit\n    vec3 n = texture( iChannel1, uv + normal.xz + step * vec2( 0., 1.) ).rgb;\n    vec3 s = texture( iChannel1, uv + normal.xz + step * vec2( 0., -1.) ).rgb;\n    vec3 e = texture( iChannel1, uv + normal.xz + step * vec2( 1., 0.) ).rgb;\n    vec3 w = texture( iChannel1, uv + normal.xz + step * vec2( -1., 0.) ).rgb;\n    vec3 finalColor = (n + s + e + w) / 4.;\n    \n    // add some pseudo specular lighting\n    float fovFakeFactor = 5.;\n    vec3 inverseLightDir = normalize(vec3(2., 1., 1.4));\n    vec3 inverseViewDir = normalize(vec3(0., 1., 0.) + vec3(uv.x, 0., uv.y) * fovFakeFactor);\n    vec3 lightColor = vec3(1.);\n    vec3 halfwayDir = normalize(inverseLightDir + inverseViewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 4.);\n\tvec3 specular = lightColor * spec;\n\tfinalColor += specular * 2.;\n    \n    // add a little brightness based on height of water\n    float waterHeight = texture( iChannel0, uv).r;\n    float brightness = clamp(waterHeight*10., 0., 0.1);\n    finalColor += vec3(brightness);\n    \n    fragColor = vec4(finalColor, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// A has input B\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centered = (uv - vec2(0.5)) * 2.;\t// center to (-1 1)\n    vec4 col = texture(iChannel0, uv);\n    vec4 finalColor = col;\n    \n    \n    // initial behavior, just to get smth started.\n    float timing = mod(iTime, 60.0) / 60.0;\n    if (timing >= 0.995 && timing <= 1.0) {\n    \n\n        float angle = atan(centered.y, centered.x);\n        float mask = (1. - step(length(9. * centered), 0.6)) * step(length(9. * centered), 1.5);\n\n        float defaultHeight = 0.0;\n\t\tfloat ringHeight = 0.03;\n        \n        \n        vec3 water = clamp(mix(vec3(defaultHeight, 0., 0.), vec3(ringHeight, 0., 0.), mask), vec3(0.), vec3(1.));\n        finalColor = vec4(water, col.a);\n        \n\n    } else {\n        \n        // else just pass the buffer on to B.\n        finalColor = col;\n        \n    }\n    \n    \n    fragColor = finalColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// B has input A, noise(64x64, repeat)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    vec2 step = 1. / iResolution.xy;\n    \n    vec4 n = texture( iChannel0, uv + step * vec2( 0., 1.) );\n    vec4 s = texture( iChannel0, uv + step * vec2( 0., -1.) );\n    vec4 e = texture( iChannel0, uv + step * vec2( 1., 0.) );\n    vec4 w = texture( iChannel0, uv + step * vec2( -1., 0.) );\n\n    // water logic\n    // https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n\tfloat viscosityConstant = 0.997;\n    float damping = 0.997;\n    float newHeight = ( ( n.r + s.r + e.r + w.r ) * 0.5 - col.g ) * viscosityConstant;\n\tnewHeight *= damping;\n    \n    //add mouse effect\n    float mouseDist = length(iMouse.xy / iResolution.xy - uv);\n    if (mouseDist < length(step*7.) && iMouse.z > 0.) {\n    \tnewHeight += 0.006 + 0.002 * sin(iTime) + 0.001 * sin(fragCoord.x*0.3 + fragCoord.y*0.05);\n    }\n    newHeight = clamp(newHeight, 0., 1.);\n    \n    \n    // add noise\n    float noiseUvScale = 0.2;\n    float noise1 = texture( iChannel1, uv * noiseUvScale + vec2(0.02, 0.02)*iTime).r;\n    float noise2 = texture( iChannel1, uv * noiseUvScale*0.4 - vec2(0.011, 0.05) * iTime).r;\n    float noise3 = texture( iChannel1, uv * noiseUvScale*1.3 + vec2(0.035, -0.04) * iTime).r;\n    float noiseCombo = (noise1 + noise2 + noise3) / 6.;\n    newHeight += noiseCombo * 0.0002;\n    \n    // simulate buffer swapping with channels r,g\n    vec3 finalColor = vec3(0.);\n    finalColor.g = col.r;\n    finalColor.r = newHeight;\n    fragColor = vec4(finalColor, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}