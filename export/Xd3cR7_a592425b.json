{"ver":"0.1","info":{"id":"Xd3cR7","date":"1518132290","viewed":601,"name":"magic morphing cube","username":"laserdog","description":"a transforming cube. inspired by Shane's Cave Entrance shader (https://www.shadertoy.com/view/ltjXzd) - the bump-mapping and triplanar rendering functions in this shader are slightly modified versions of the ones in the cave entrance shader.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","triplanar","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.14159\n#define TAU 6.28318\n\nconst float MAX_DISTANCE = 100.;\nconst float EPSILON = .0001;\nconst int NUM_MARCHES = 255;\nconst float BOX_EXTENTS = 3.;\nconst float RADIUS = .5;\nconst float RADIUS_COMPONENT = .35355; // sqrt(RADIUS^2 / 2)\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nmat3 rotateY(float rads)\n{\n    return mat3(\n        vec3(cos(rads), 0., sin(rads)),\n        vec3(0., 1., 0.),\n        vec3(-sin(rads), 0., cos(rads))\n    );\n}\n\nfloat sceneSDF(vec3 p, mat3 modelMatrix)\n{\n    p *= modelMatrix;\n    return udRoundBox(p, vec3(BOX_EXTENTS), RADIUS);\n}\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n, mat3 mat)\n{\n   \tn *= mat;;\n    \n    n = max((abs(n) - 0.2)*7., 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 bump( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor, mat3 mat){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor, mat)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor, mat)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor, mat)));\n    grad = (grad - getGrey(tex3D(tex,  p , nor, mat))) / eps; \n\n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 phong(vec3 normal, vec3 light, vec3 view)\n{\n    const vec3 ambientColor = vec3(1., 1., 1.);\n    const vec3 diffuseColor = vec3(1., 1., 1.);\n    const vec3 specularColor = vec3(1., 1., 1.);\n    const float shininess = 16.;\n    const float ambientStrength = .25;\n    \n    vec3 diffuse = max(dot(normal, light), 0.) * diffuseColor;\n    // light is negated because the first argument to reflect is the incident vector\n    vec3 specular = pow(max(dot(reflect(-light, normal), view), 0.), shininess) * specularColor;\n    vec3 ambient = ambientStrength * ambientColor;\n    \n    return diffuse + specular + ambient;\n}\n\nvec3 gradient(vec3 pos, mat3 mat)\n{\n    const vec3 dx = vec3(EPSILON, 0., 0.);\n    const vec3 dy = vec3(0., EPSILON, 0.);\n    const vec3 dz = vec3(0., 0., EPSILON);\n    \n    return normalize(vec3(\n    \tsceneSDF(pos + dx, mat) - sceneSDF(pos - dx, mat),\n        sceneSDF(pos + dy, mat) - sceneSDF(pos - dy, mat),\n        sceneSDF(pos + dz, mat) - sceneSDF(pos - dz, mat)\n    ));\n}\n\nfloat distanceToShape(vec3 pos, vec3 dir, mat3 modelMatrix)\n{\n    float tot = 0.;\n    for(int i = 0; i < NUM_MARCHES; i++) {\n        float dist = sceneSDF(pos, modelMatrix);\n        if (dist < EPSILON || tot > MAX_DISTANCE) {\n        \treturn tot;\n        }\n        \n        tot += dist;\n        pos += dir * dist;\n    }\n    return MAX_DISTANCE;\n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, 0.),\n        vec4(u, 0.),\n        vec4(-f, 0.),\n        vec4(0., 0., 0., 1.));\n}\n\n// 0 = same side, 1 = opposite side, 2 = x-adjacent, 3 = y-adjacent\nfloat getSide(vec3 p, mat3 modelMatrix)\n{\n    p = transpose(modelMatrix) * p;\n    \n    if (p.z > BOX_EXTENTS + RADIUS_COMPONENT) \n    {\n    \treturn 0.;\n    }\n    else if (p.z < -BOX_EXTENTS - RADIUS_COMPONENT)\n    {\n    \treturn 1.;\n    }\n    else if (abs(p.x) > BOX_EXTENTS + RADIUS_COMPONENT)\n    {\n    \treturn 2.;\n    }\n    \n    return 3.;\n}\n\nvec3 getColor(vec3 pos, vec3 eye, float texScale, mat3 mat)\n{\n    const float speed = 1.;\n    const float repeat = 2.5;\n    const float thickness = .015;\n    const float thicknessModifier = 8.;\n    const float gridTileWidth = .5;\n    const float bumpAmount = .01;\n    const vec3 lightPos = vec3(-3., 5., 5.);\n    \n    float t = mod(iTime, repeat) * speed;\n    float side = getSide(pos, mat);\n    vec3 originalPos = pos;\n    pos = transpose(mat) * pos;\n    vec2 uv;\n    \n    if (side == 0.) uv = pos.xy;\n    else if (side == 2.) uv = vec2(2. * BOX_EXTENTS - pos.z, pos.y);\n    else if (side == 3.) uv = vec2(pos.x, (2. * BOX_EXTENTS - pos.z));\n    else if (abs(pos.x) > abs(pos.y)) uv = vec2(3. * BOX_EXTENTS + BOX_EXTENTS - abs(pos.x), pos.y);\n    else uv = vec2(pos.x, 3. * BOX_EXTENTS + BOX_EXTENTS - abs(pos.y));\n    \n\tvec2 node = round(uv / vec2(gridTileWidth)) * gridTileWidth;\n    float nodeOffset = 1. - t - (1. - distance(node, vec2(0.)) / thicknessModifier);\n    float uvOffset = 1. - t - (1. - distance(uv, vec2(0.)) / thicknessModifier);\n\n    vec2 dist = abs(uv - node) - vec2(nodeOffset);\n    float num = min(abs(dist.x), abs(dist.y));\n    \n    float lerpAmount = clamp(uvOffset / (gridTileWidth / 2.), 0., 1.);\n    \n    bool swap = floor(mod(iTime / repeat, 2.)) == 0.;\n    \n    vec3 norm = swap ? \n        \t\t\tmix(bump(iChannel1, pos * texScale, gradient(originalPos, mat), bumpAmount, mat),\n                    \tbump(iChannel0, pos * texScale, gradient(originalPos, mat), bumpAmount, mat),\n                    \tlerpAmount) : \n    \t\t\t\tmix(bump(iChannel0, pos * texScale, gradient(originalPos, mat), bumpAmount, mat),\n                    \tbump(iChannel1, pos * texScale, gradient(originalPos, mat), bumpAmount, mat),\n                    \tlerpAmount);\n    \n    \n    vec3 light = phong(norm, normalize(lightPos - pos), normalize(eye - pos));\n    vec3 col = swap ? \n        \t\t\tmix(tex3D(iChannel1, pos * texScale, norm, mat),\n                   \t\ttex3D(iChannel0, pos * texScale, norm, mat),\n                   \t\tlerpAmount) * light :\n    \t\t\t\tmix(tex3D(iChannel0, pos * texScale, norm, mat),\n                   \t\ttex3D(iChannel1, pos * texScale, norm, mat),\n                   \t\tlerpAmount) * light;\n    \n    col.r += mix(0., step(num, thickness), max(0., sign(dist.y + dist.x)));\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float texScale = 1./6.;\n    const mat3 identity = mat3(1., 0., 0., 0., 1., 0., 0., 0., 1.);\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 eye = vec3(-6., 5., 6.5);\n    vec3 ray = normalize(vec3(uv, -1.));\n    \n    mat3 modelMatrix = rotateY(iTime / 2.);\n    \n    mat4 viewMat = lookAt(eye, vec3(0.), vec3(0., 1., 0.));\n    ray = (viewMat * vec4(ray, 1.)).xyz;\n    \n    float dist = distanceToShape(eye, ray, modelMatrix);\n    vec3 pos = eye + ray * dist;\n    \n    fragColor = vec4(0.);\n    \n    if (dist < MAX_DISTANCE) {\n        fragColor.rgb = getColor(pos, eye, texScale, modelMatrix);\n    }\n}","name":"Image","description":"","type":"image"}]}