{"ver":"0.1","info":{"id":"DdB3zR","date":"1672130559","viewed":109,"name":"Menger sponge (Silice impl ref)","username":"sylefeb","description":"Reference shader version of the Menger sponge hardware rendering pipeline written in Silice, see links in comments.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractalsilice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// This is a reference implementation of a dda algorithm\n// for rendering a Menger sponge in hardware, on FPGA.\n//\n// Link to hardware version:\n//   https://github.com/sylefeb/Silice/blob/draft/projects/vga_demo/vga_msponge.si\n//\n// More info in this thread:\n//   https://twitter.com/sylefeb/status/1588215408531742721\n//\n// I used this version to test the core algorithm that I was \n// implementing in hardware.\n//\n// It is *not* optimized for GPU but instead replicates the fixed\n// point hardware implementation. The pipeline is turned into a loop.\n//\n// Since the hardware version is racing the beam this fits well in\n// a shader, and provides interactive feedback during debug.\n//\n// The hardware version (on FPGA) runs at 1080p 60Hz constant \n// framerate.\n//\n// Fork of \"Menger1\" by sylefeb. 2022-10-29 17:01:58\n//\n// MIT license - (c) Sylvain Lefebvre 2022\n\n// Fixed point cosine (table in hardware)\nint icos(int v)\n{\n  return int(1024.0*cos(3.14159*2.0*float(v)/512.0));\n}\n\n// Fixed point sine (table in hardware)\nint isin(int v)\n{\n  return int(1024.0*sin(3.14159*2.0*float(v)/512.0));\n}\n\n// Fixed point division (table in hardware)\nint inv(int v)\n{\n  return abs(v) < 3 ? 32767 : ((1<<16) / abs(v));\n}\n\n// Renderer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // pixel coordinates\n  uint y=0u;          uint x=(0u);\n  vec2 uv = fragCoord/iResolution.xy;\n  x = uint(iResolution.x*uv.x);\n  y = uint(iResolution.y*uv.y);\n  // Menger sponge geometry (one tile at one resolution)\n  const int tile[64] = int[64](\n         1,1,1,1,\n         1,0,0,1,\n         1,0,0,1,\n         1,1,1,1,\n\n         1,0,0,1,\n         0,0,0,0,\n         0,0,0,0,\n         1,0,0,1,\n\n         1,0,0,1,\n         0,0,0,0,\n         0,0,0,0,\n         1,0,0,1,\n\n         1,1,1,1,\n         1,0,0,1,\n         1,0,0,1,\n         1,1,1,1\n  );\n\n  // number of marching steps (dda)\n#define N_steps 192\n  // a bunch of vars for the marching status per ray\n  uint wait=(0u);\n  int  view_x=(0);    int view_y=(0);   int  view_z=(0);\n  int  rot_x=(0);     int rot_y=(0);\n  int  world_x=(0);   int world_y=(0);\n  uint  inside=(0u);\n  uint  clr=(0u);     uint  dist=(0u);\n  uint  clr_r=(0u);   uint  clr_g=(0u); uint  clr_b=(0u);\n  int  cs0=(0);       int  ss0=(0);\n  int  cs1=(0);       int  ss1=(0);\n  int  r_x=(0);       int  r_y=(0);     int  r_z=(0);\n  int  r_x_delta=(0); int  r_z_delta=(0);\n\n  view_x    = (int(x) - int(iResolution.x/2.0));\n  view_y    = (int(y) - int(iResolution.y/2.0));\n  view_z    = 384;\n\n  inside    = 0u;\n  dist      = 255u;\n  clr       = 0u;\n\n  int frame = int(iTime*100.0);\n  \n  // sinse/cosines for ray and view\n  cs0     = icos(frame>>1);\n  ss0     = isin(frame>>1);\n  cs1     = icos((frame+(frame<<1))>>3);\n  ss1     = isin((frame+(frame<<3))>>4);\n  // view rotation\n  rot_x   = (view_x * cs1);\n  rot_y   = (view_x * ss1);\n  view_x  = rot_x - (view_y * ss1);\n  view_y  = rot_y + (view_y * cs1);\n  view_x = view_x >> 10;\n  view_y = view_y >> 10;\n  // a 'voxel' is 1<<12\n  int vxsz = 1<<12;\n  // 1<<11 is half a small 'voxel' (a cube in the smallest 4x4x4 struct)\n  // level 0 is 1<<14 (4x4x4)\n  // level 1 is 1<<16 (4x4x4)\n  // level 2 is 1<<18 (4x4x4)\n  world_x = 0;\n  world_y = 0;\n  // compute the ray direction (through rotations)\n  int xcs = view_x * cs0;\n  int xss = view_x * ss0;\n  int zcs = view_z * cs0;\n  int zss = view_z * ss0;\n  r_x_delta = (xcs - zss);\n  r_z_delta = (xss + zcs);\n  // ray dir is (r_x_delta, view_y, r_z_delta)\n  int rd_x  = r_x_delta>>10;\n  int rd_y  = view_y;\n  int rd_z  = r_z_delta>>10;    \n  // initialize voxel traversal\n  // -> position\n  int p_x   = (68<<11);\n  int p_y   = (12<<11);\n  int p_z   = (frame<<9);\n  // -> start voxel\n  int v_x   = p_x >> 12;\n  int v_y   = p_y >> 12;\n  int v_z   = p_z >> 12;\n  // -> steps\n  int s_x   = rd_x < 0 ? -1 : 1;\n  int s_y   = rd_y < 0 ? -1 : 1;\n  int s_z   = rd_z < 0 ? -1 : 1;\n  // -> inv dot products\n  int inv_x = inv(rd_x);\n  int inv_y = inv(rd_y);\n  int inv_z = inv(rd_z);\n  // -> tmax\n  int brd_x = (p_x - (v_x<<12)); // distance to border\n  int brd_y = (p_y - (v_y<<12)); // distance to border    \n  int brd_z = (p_z - (v_z<<12)); // distance to border    \n  int tm_x  = ((rd_x < 0 ? (brd_x) : (vxsz - brd_x)) * inv_x)>>4; // reaches 28 bits\n  int tm_y  = ((rd_y < 0 ? (brd_y) : (vxsz - brd_y)) * inv_y)>>4; // reaches 28 bits\n  int tm_z  = ((rd_z < 0 ? (brd_z) : (vxsz - brd_z)) * inv_z)>>4; // reaches 28 bits\n  // -> delta\n  int dt_x  = ((vxsz * inv_x)>>4);\n  int dt_y  = ((vxsz * inv_y)>>4);\n  int dt_z  = ((vxsz * inv_z)>>4);\n  \n  r_x = 0; r_y = 0; r_z = 0;\n\n  // --- marching loop ---\n  // In hardware this entire loop (as well as several init steps before)  \n  // are implemented as a long pipeline. Each iteration below is one step\n  // of the ray marching pipeline.\n  int step;\n  for (step=0 ; step<N_steps ; ++step) \n  {\n    int w_x = v_x; int w_y = v_y; int w_z = v_z;\n\n    int  tex     = ((v_x)&63) ^ ((v_y)&63) ^ ((v_z)&63);\n    int  vnum0   = (((w_z>>0)&3)<<4) | (((w_y>>0)&3)<<2) | (((w_x>>0)&3)<<0);\n    int  vnum1   = (((w_z>>2)&3)<<4) | (((w_y>>2)&3)<<2) | (((w_x>>2)&3)<<0);\n    int  vnum2   = (((w_z>>4)&3)<<4) | (((w_y>>4)&3)<<2) | (((w_x>>4)&3)<<0);\n    if ((tile[vnum0] & tile[vnum1] & tile[vnum2]) != 0) {\n      if (inside == 0u) {\n        clr    = uint(tex);\n        dist   = uint(step);\n        inside = 1u;\n        break; // only for CPU/GPU versions, in hardware we\n        //        continue through the entire ray (makes no\n        //        difference since the pipeline already\n        //        outputs one pixel per clock cycle at 1080p)\n      }\n    }\n    bool x_sel = tm_x <= tm_y && tm_x <= tm_z;\n    bool y_sel = tm_y <  tm_x && tm_y <= tm_z;\n    bool z_sel = tm_z <  tm_x && tm_z <  tm_y;\n    if (x_sel) {\n      // tm_x smallest\n      v_x  = v_x  + s_x;\n      tm_x = tm_x + dt_x;\n    } \n    if (y_sel) {\n      // tm_y smallest\n      v_y  = v_y  + s_y;\n      tm_y = tm_y + dt_y;\n    }\n    if (z_sel) {\n      // tm_z smallest\n      v_z  = v_z  + s_z;\n      tm_z = tm_z + dt_z;\n    }\n    \n  }\n\n  // a simple fog effect\n  {\n    uint fog   = dist;\n    uint light = (256u - dist);\n    uint shade = light * clr;\n    clr_r = (shade >> 7) + fog;\n    clr_g = (shade >> 7) + fog;\n    clr_b = (shade >> 8) + fog;\n  }\n    \n  // per-pixel color\n  fragColor = vec4(vec3(clr_r,clr_g,clr_b)/256.0,1.0);\n}\n","name":"Image","description":"","type":"image"}]}