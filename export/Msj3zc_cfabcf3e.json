{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t\n{\n\tvec3 pos;\n\tfloat rayon;\n};\n\t\nstruct ray_t\n{\n\tvec3 pos;\n\tvec3 direction;\n};\n\t\nstruct plan_t\n{\n\tvec3 normale; // la normale au plan\n\tfloat d; //offset de l'Ã©quation\n};\n\nstruct light_t\n{\n\tvec3 direction;\t\n\tfloat contribution;\n};\n\t\nfloat max_distance = 1e5; //distance par rapport Ã  la sphÃ¨re\n\nfloat intersectSphere( const in ray_t ray, const in sphere_t sphere)\n{\t\n\tfloat t,t1,t2;\n\tvec3 position = (ray.pos - sphere.pos);\n\tfloat a = pow(ray.direction.x, 2.0) + pow(ray.direction.y, 2.0) + pow(ray.direction.z, 2.0);\n\tfloat b = 2.0 *( (ray.direction.x*position.x) + (ray.direction.y*position.y) + (ray.direction.z*position.z) );\n\tfloat c = pow(position.x,2.0) + pow(position.x,2.0)+pow(position.z,2.0) - pow(sphere.rayon,2.0);\n\t\n\tfloat delta = pow(b,2.0) - (4.0*a*c);\n\t\n\tif(delta > 0.0){\n\t\tt1 = (-b + sqrt(delta)) / (2.0 * a);\n\t\tt2 = (-b - sqrt(delta)) / (2.0 * a);\n\t\t\n\t\tif(t1 < t2){\n\t\t\tt = t1;\n\t\t}\n\t\telse{\n\t\t\tt =t2;\t\n\t\t}\n\t}\n\telse{\n\t\tt = max_distance;\t\n\t}\n\treturn t ;\n}\n\nfloat intersectPlan(const in ray_t ray, const in plan_t plan)\n{\t\n\tfloat t;\n\n\tfloat num = -plan.d - (plan.normale.x*ray.pos.x) - (plan.normale.y*ray.pos.y) - (plan.normale.z*ray.pos.z);\n\tfloat denom = (plan.normale.x*ray.direction.x)+(plan.normale.y*ray.direction.y)+(plan.normale.z*ray.direction.z);\n\tt =  num / denom ;\n\t\n\tif (t > 0.0){\n\t\treturn t;\n\t}\n\telse{\n\t \treturn max_distance;\t\n\t}\n}\n\nvec4 intersect(const in ray_t ray)\n{\n\tsphere_t sphere;\n\tsphere.pos = vec3(0.0,0.0,0.0);\n\tsphere.rayon = 1.0;\n\t\n\tplan_t plan;\n\tplan.normale = vec3(0.2, 0.8, 0.14);\n\tplan.d = 0.1;\n\t\n\tfloat distance_from_origin_Plan = intersectPlan(ray, plan);\n\tfloat distance_from_origin_Sphere = intersectSphere(ray, sphere);\n\tfloat minGlobal = min(distance_from_origin_Plan,distance_from_origin_Sphere);\n\t\n\tif (minGlobal == max_distance){\n\t\treturn vec4(plan.normale, minGlobal);\n\t}else if (minGlobal == distance_from_origin_Sphere){\n\t\tvec3 surfacePos = ray.pos+ minGlobal*ray.direction - sphere.pos;\n\t\tsurfacePos = surfacePos - sphere.pos;\n\t\treturn vec4(surfacePos, minGlobal);\n\t}else if(minGlobal == distance_from_origin_Plan){\n\t\treturn vec4(plan.normale, minGlobal);\n\t}else{\n\t\treturn vec4(plan.normale, minGlobal);\t\n\t}\n}\n\nvoid light_information0(out light_t light)\n{\n\tlight.direction = vec3(0.0, 1.0, 0.0);\n\tlight.contribution = 1.0; \n}\n\nvoid light_information1(out light_t light)\n{\n\tlight.direction = vec3(cos(iTime*50.0), 1.0, 0.0);\n\tlight.contribution = 1.0; \n}\n\nfloat illumination(ray_t ray, const in vec3 surface, const in light_t light)\n{\n\tfloat diffuse = max(0.0, dot(surface,light.direction));\n\tvec3 reflected = reflect(ray.direction,surface);\n\tfloat specular = dot(normalize(reflected),surface);\n\t\n\treturn diffuse*light.contribution + pow(specular,0.90);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coordinate = fragCoord.xy / iResolution.xy;\n\tvec2 coordinate_entered = 2.0 * coordinate - 1.0;\n\t\n\tfloat coeffCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinateCorrige = vec2(coeffCorrection,1.0) *coordinate_entered;\n\t\n\tray_t camera_ray;\n\tcamera_ray.pos = vec3(0.0, 0.0, abs(3.0*sin(iTime)*1.0));\n\tcamera_ray.direction = normalize(vec3(coordinateCorrige, -1.5));\n\t\n\tvec4 distance_from_origin = intersect(camera_ray);\n\n\t\tif (distance_from_origin.w < max_distance){\n\t\t\tlight_t light;\n\t\t\tlight_information0(light);\n\t\t\tfloat illu = illumination(camera_ray,distance_from_origin.xyz, light);\n\t\t\t\n\t\t\tfragColor = vec4 (illu,illu,illu,1.0);\n\t\t}\n\t\telse{\n\t\t\tconst vec3 background_color = vec3(0.2, 0.3, 0.3); //couleur de l'arriÃ¨re plan.\n\t\t\tfragColor = vec4 (background_color, 1.0);\n\t\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msj3zc","date":"1392023069","viewed":138,"name":"Light Scene","username":"MugiwaraLuffy","description":"Light","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lightraytracing"],"hasliked":0,"parentid":"","parentname":""}}