{"ver":"0.1","info":{"id":"XlBGWR","date":"1427846721","viewed":225,"name":"Reflect","username":"blackyle","description":"My first raymarching shader. Some simple geometry, lots of reflections, and a cubemap. Press and hold the \"m\" key to highlight the areas where the maximum number of reflections is reached.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflection","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PRECISION 0.0001\n#define MAX_ITER 64\n#define MAX_DISTANCE 20.0\n#define EPSILON 0.0001\n#define MAX_REFLECTIONS 8\n#define REFLECTIVITY 0.8\n\nbool showMaxReflections = false;\n\nbool readKey(int key, bool toggle) {\n    return texture(iChannel1, vec2((float(key)+0.5)/256.0, toggle ? 0.75 : 0.25)).x > 0.5;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdUnion(float d1, float d2, float d3, float d4) {\n    return min(min(min(d1, d2), d3), d4);\n}\n\nfloat sdDifference(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat map(in vec3 p) {\n    float box = sdBox(p, vec3(0.8, 0.8, 0.8));\n\tfloat rsphere = sdSphere(p, 1.0);\n    float rbox1 = sdBox(p, vec3(2.0, 0.1, 2.0));\n    float rbox2 = sdBox(p.yzx, vec3(2.0, 0.1, 2.0));\n    float rbox3 = sdBox(p.zxy, vec3(2.0, 0.1, 2.0));\n    return sdDifference(box, sdUnion(rsphere, rbox1, rbox2, rbox3));\n}\n\nvec3 normal(in vec3 p) {\n    vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    return normalize(vec3(\n        \tmap(p + eps.xyy) - map(p - eps.xyy),\n        \tmap(p + eps.yxy) - map(p - eps.yxy),\n        \tmap(p + eps.yyx) - map(p - eps.yyx)\n        ));\n}\n\nfloat march(in vec3 rayOrigin, in vec3 rayDirection) {\n    float dist = 0.1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        float t = map(rayOrigin + rayDirection * dist);\n        dist += t;\n        if (abs(t) < PRECISION || dist > MAX_DISTANCE) {\n            break;\n        }\n    }\n\treturn dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \tvec2 coord = fragCoord.xy / iResolution.xy - 0.5;\n\tcoord.x *= iResolution.x / iResolution.y;\n    \n    vec3 camera = vec3(5.0*sin(iTime/3.0), 2.0*cos(iTime/2.0), 5.0*cos(iTime/3.0));\n    vec3 lookat = vec3(0);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    vec3 rayOrigin = camera;\n    vec3 rayDirection = normalize(coord.x*right + coord.y*up + 2.0*forward);\n\n    int reflections = 0;\n    for (int refl = 0; refl < MAX_REFLECTIONS; refl++) {\n\t    float dist = march(rayOrigin, rayDirection);\n\t    if (dist > MAX_DISTANCE) {\n            break;\n        }\n\t    vec3 hitPoint = rayOrigin+dist*rayDirection;\n\t    vec3 reflected = reflect(rayDirection, normal(hitPoint));\n        \n        rayOrigin = hitPoint;\n        rayDirection = reflected;\n        reflections++;\n    }\n\n    showMaxReflections = readKey(77, false);\n    if (showMaxReflections && reflections == MAX_REFLECTIONS) {\n        fragColor = vec4(0, 1, 0, 1);\n        return;\n    }\n    \n    fragColor = mix(vec4(1, 0, 0, 1), texture(iChannel0, rayDirection), pow(REFLECTIVITY, float(reflections)));\n}","name":"","description":"","type":"image"}]}