{"ver":"0.1","info":{"id":"4f3cRS","date":"1731109777","viewed":51,"name":"SDF Playtime!","username":"8InfinityTaco8","description":"I'm just learning and Messing around with some more of the stuff I've been learning recently. I might add more scenes/modes with other effects in the future to this little project.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf","transition","education"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants for visualization modes\nconst int MODE_SQUARE_SDF = 0;\nconst int MODE_ANIMATED_SQUARE = 1;\nconst int MODE_SOLID_RINGS = 2;\nconst int MODE_ROTATING_CUBE = 3;\nconst int MODE_MINIMAL_CUBE = 4;\n\n// Utility functions\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// Scene distance functions\nfloat getSceneDistance(vec3 p, int mode) {\n    if (mode == MODE_ROTATING_CUBE) {\n        p.xz *= rot2D(iTime * 0.5);\n        p.xy *= rot2D(sin(iTime * 0.3) * 0.5);\n        return sdBox(p, vec3(0.5));\n    } else if (mode == MODE_MINIMAL_CUBE) {\n        p.xz *= rot2D(iTime * 0.5);\n        p.xy *= rot2D(cos(iTime * 0.3) * 0.5);\n        return sdBox(p, vec3(0.5));\n    }\n    return 100.0;\n}\n\n// Ray marching function\nstruct RayMarchResult {\n    float dist;\n    vec3 position;\n    bool hit;\n};\n\nRayMarchResult rayMarch(vec3 ro, vec3 rd, int mode) {\n    float t = 0.0;\n    float minDist = 100.0;\n    vec3 p;\n    bool hit = false;\n    \n    for(int i = 0; i < 100; i++) {\n        p = ro + rd * t;\n        float d = getSceneDistance(p, mode);\n        minDist = min(minDist, d);\n        \n        if(d < 0.001) {\n            hit = true;\n            break;\n        }\n        if(t > 10.0) break;\n        t += d;\n    }\n    \n    return RayMarchResult(minDist, p, hit);\n}\n\n// Normal calculation\nvec3 calcNormal(vec3 p, int mode) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        getSceneDistance(p + e.xyy, mode) - getSceneDistance(p - e.xyy, mode),\n        getSceneDistance(p + e.yxy, mode) - getSceneDistance(p - e.yxy, mode),\n        getSceneDistance(p + e.yyx, mode) - getSceneDistance(p - e.yyx, mode)\n    ));\n}\n\n// Ring pattern \nfloat generateRings(float dist, float speed, float frequency, float threshold) {\n    float animatedDist = dist - iTime * speed;\n    float rings = mod(animatedDist * frequency, 1.0);\n    return step(threshold, rings);\n}\n\n// Square SDF\nfloat calculateSquareSDF(vec2 uv) {\n    vec2 d = abs(uv) - vec2(0.5);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Visualization functions\nvec3 squareSDF(vec2 uv) {\n    float sdf = calculateSquareSDF(uv);\n    float rings = generateRings(sdf, 0.0, 10.0, 0.5);\n    \n    vec3 col = vec3(sdf * 0.5 + 0.5);\n    col = mix(col, vec3(1.0), rings * 0.3);\n    col = mix(col, sdf > 0.0 ? vec3(1.0,0.5,0.2) : vec3(0.2,0.5,1.0), 0.2);\n    \n    if (abs(sdf) < 0.01) col = vec3(0.0);\n    return col;\n}\n\nvec3 animatedSquareSDF(vec2 uv) {\n    float sdf = calculateSquareSDF(uv);\n    float animatedSdf = sdf - iTime * 0.5;\n    float rings = mod(animatedSdf * 10.0, 1.0);\n    rings = smoothstep(0.0, 0.1, rings) * smoothstep(1.0, 0.9, rings);\n    \n    vec3 col = vec3(sdf * 0.5 + 0.5);\n    float ringFade = exp(-sdf * 1.0);\n    col = mix(col, vec3(1.0), rings * 0.3 * ringFade);\n    col = mix(col, sdf > 0.0 ? vec3(1.0,0.5,0.2) : vec3(0.2,0.5,1.0), 0.2);\n    \n    if (abs(sdf) < 0.01) col = vec3(0.0);\n    return col;\n}\n\nvec3 solidRings(vec2 uv) {\n    uv = uv * 2.0;\n    float sdf = calculateSquareSDF(uv);\n    float animatedSdf = sdf - iTime * 0.5;\n    float rings = generateRings(animatedSdf, 0.0, 10.0, 0.5);\n    \n    vec3 col = vec3(0.1);\n    col = mix(col, vec3(1.0), rings);\n    \n    if (abs(sdf) < 0.01) col = vec3(0.0);\n    return col;\n}\n\nvec3 rotatingCubeRings(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    RayMarchResult result = rayMarch(ro, rd, MODE_ROTATING_CUBE);\n    vec3 col = vec3(0.1);\n    \n    if (result.hit) {\n        vec3 n = calcNormal(result.position, MODE_ROTATING_CUBE);\n        float dist = length(result.position.xy);\n        float rings = generateRings(dist, 0.5, 5.0, 0.5);\n        \n        col = mix(\n            vec3(0.5 + 0.5 * dot(n, normalize(vec3(1,1,-1)))),\n            vec3(1.0),\n            rings * 0.8\n        );\n    }\n    \n    return col;\n}\n\nvec3 minimalCubeRings(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    RayMarchResult result = rayMarch(ro, rd, MODE_MINIMAL_CUBE);\n    vec3 col = vec3(0.1);\n    \n    float rings = generateRings(result.dist, 0.5, 4.0, 0.5);\n    col = mix(col, vec3(1.0), rings);\n    \n    if(result.dist < 0.01) {\n        col = vec3(0.0);\n    }\n    \n    return col;\n}\n\nvec3 getCurrentVisualization(int mode, vec2 square_uv, vec2 normal_uv) {\n    if (mode == MODE_SQUARE_SDF) return squareSDF(square_uv);\n    if (mode == MODE_ANIMATED_SQUARE) return animatedSquareSDF(square_uv);\n    if (mode == MODE_SOLID_RINGS) return solidRings(normal_uv);\n    if (mode == MODE_ROTATING_CUBE) return rotatingCubeRings(normal_uv);\n    return minimalCubeRings(normal_uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 squareUV = fragCoord/iResolution.xy;\n    squareUV = (squareUV * 2.0 - 1.0) * 2.0;\n    squareUV.x *= iResolution.x/iResolution.y;\n\n\n\n      \n    float transitionTime = 5.0;\n    float totalModes = 5.0;\n    float time = iTime;\n    \n    float cycleTime = mod(time, transitionTime * totalModes);\n    int currentMode = int(floor(cycleTime / transitionTime));\n    int nextMode = int(mod(float(currentMode + 1), totalModes));\n    \n    float transitionProgress = mod(cycleTime, transitionTime);\n    float wipePosition = transitionProgress * (iResolution.x / transitionTime);\n\n\n\n    // Old wipe transition logic that did not work correctly\n\n    /*\n    float fadeWidth = 2.0;\n    float wipeMask = smoothstep(0.0, fadeWidth, fragCoord.x - wipePosition);\n    \n    vec3 col1 = getCurrentVisualization(currentMode, squareUV, uv);\n    vec3 col2 = getCurrentVisualization(nextMode, squareUV, uv);\n    \n    float lineWidth = 2.0;\n    float lineIntensity = step(abs(fragCoord.x - wipePosition), lineWidth);\n    vec3 lineColor = vec3(0.0);\n    \n    vec3 finalColor = mix(col1, col2, wipeMask);\n    finalColor = mix(finalColor, lineColor, lineIntensity);\n    \n    fragColor = vec4(finalColor, 1.0);\n    */\n    \n\n\n\n\n    // New wipe transition logic that works as I originally expected\n    \n    // This is where we need to change the logic\n    // Instead of using wipeMask to mix between current and next\n    // We'll use the position of the wipe line to determine which mode to show\n    \n    float sceneSelect = step(fragCoord.x, wipePosition);\n    vec3 finalColor = getCurrentVisualization(\n        sceneSelect < 0.5 ? currentMode : nextMode, \n        squareUV, \n        uv\n    );\n    \n    // Add the line\n    float lineWidth = 2.0;\n    float lineIntensity = step(abs(fragCoord.x - wipePosition), lineWidth);\n    vec3 lineColor = vec3(0.0);\n    \n    finalColor = mix(finalColor, lineColor, lineIntensity);\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}