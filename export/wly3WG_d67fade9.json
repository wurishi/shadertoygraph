{"ver":"0.1","info":{"id":"wly3WG","date":"1579723999","viewed":376,"name":"Fitting Arc using Bézier","username":"harry7557558","description":"Least square fitting an unit arc using cubic bezier curve. \nEllipse fitting can be done by simply applying a linear transform. ","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["bezier","circle","approximation","arc","fitting","leastsquare","2021"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tFitting an unit arc using cubic bezier curve\n\tEllipse fitting can be done by simply applying a linear transform.\n\n\tBasic Idea:\n\n\tLet the start point be A(0,1) and the endpoint be B(cosθ,sinθ), the two other \n\tcontrol points be C(1,x) and D=B+x*(sinθ,-cosθ). Let the equation of the bezier \n\tcurve be P(t)=(1-t)³·A+3t(1-t)²·B+3t²(1-t)·C+t³·D and the error be \n\tE(x)=Integral[(P²-1)²,t,0,1]. This integral is be a quartic polynomial \n\tabout x. Let its derivative equal to zero and solve for x, thus determine \n\tcontrol point B and C.\n\n\tSince the calculation is very machanical and error-prone, I used WolframAlpha \n\tto do expanding, integration and differentiation.\n\n\tAs one can see, when θ<2rad, it's not easy to notice the difference between the \n\tcircle and the fitted curve.\n\n\t2020-03-05:\n\tAdd numerical approximation solutions generated by polynomial regression.\n\t(Simpson's integration in [0,2], 2×100000 samples, Gaussian elimination, double-precision)\n*/\n\n\n#define PI 3.1415926\n#define _13 0.333333333\n#define cbrt(x) ((x)>0.?pow(x,_13):-pow(-(x),_13))\n\n#define Clamp(x) clamp(x,0.,1.)\n\nstruct Bezier3{\n    vec2 A, B, C, D;\n};\n\n\n// ========================= Fitting Code =========================\n\n\nvoid fitArc(float a, out Bezier3 R) {\n    float S = sin(a), C = cos(a), x;\n#if 1\n    // derivative of error: error'=ax³+bx²+cx+d\n\tfloat s2 = S * S, c2 = C * C, sc2 = s2 + c2, sc22 = sc2 * sc2;\n\ta = 1. / (756.*(sc22 + 1.) + 810.*s2 - 1890.*(sc2 + 1.)*C + 2430.*c2);\n\tfloat c = (2520.*sc22 + 2736.*s2 + (-507.*sc2 - 6600.*C + 7215.)*C - 2628.) * a,\n\t\tb = (3996.*(sc2 + 1.) - 6750.*C)*S * a, d = (3439.*sc2 + 4276.*C - 7715.)*S * a;\n    // solve the cubic equation to determine the minima\n\tfloat p = (c - b * b * _13) * _13, q = -0.5 * ((b*b / 13.5 - c * _13) * b + d);\n\ta = q * q + p * p * p;\n\tx = a > 0.0 ? cbrt(q + sqrt(a)) + cbrt(q - sqrt(a)) - b * _13\n\t\t: 2.0 * pow(q*q - a, 0.5*_13) * cos(atan(sqrt(-a), q) * _13) - b * _13;\n    // 450+ time unit\n#else\n    // numerical approximation\n    // 12 time unit, ERR = 2.75e-04, RMSE = 8.02e-05, notable error\n    x = ((0.008561080643*a-0.002518989170)*a+0.334292025655)*a;\n    // 23 time unit, ERR = 2.51e-06, RMSE = 6.29e-07, few error\n    x = ((((0.000223623140*a-0.000237833794)*a+0.007216725971)*a-0.000130686154)*a+0.333353941704)*a;\n    // 28 time unit, ERR = 2.71e-07, RMSE = 6.11e-08, no visible error\n    x = (((((0.000027936409*a+0.000060660755)*a+0.000117720501)*a+0.006861171676)*a+0.000027337977)*a+0.333330238084)*a;\n#endif\n    // apply the solution of the equation to the control points\n    R.A=vec2(1,0), R.B=vec2(1,x), R.C=vec2(C+x*S,S-x*C), R.D=vec2(C,S);\n}\n\nfloat sdBezier3(in Bezier3 R, in vec2 p) {\n\tvec2 A = R.D-R.A+3.*(R.B-R.C), B = 3.*(R.C-2.*R.B+R.A), C = 3.*(R.B-R.A);\n\tvec2 a=vec2(1,0), b, pa=p-a, ba, q;\n\tfloat d = dot(pa,pa);\n\tfor (float dt=.02, t = dt; t < 1.; t += dt) {\n\t\tb = ((A*t + B)*t + C)*t + R.A;\n\t\tpa=p-a, ba=b-a, q=pa-ba*Clamp(dot(pa,ba)/dot(ba,ba));\n\t\td = min(d, dot(q,q));\n\t\ta = b;\n\t}\n\treturn sqrt(d);\n}\n\nvoid mainImage(out vec4 col, in vec2 P) {\n    vec2 res = iResolution.xy;\n    vec2 p = 6.0*(P-.5*res)/length(res);\n    float h = .2*length(res); \t// hardness of anti-aliasing\n\n    float ang = atan(p.y,p.x), a;\n    if (iMouse.z>0.){\n        vec2 d = iMouse.xy-.5*iResolution.xy;\n        a = atan(d.y,d.x);\n    }\n    else a = sin(iTime), a=PI*a*a;\n    if (ang<0.) ang+=2.*PI; if (a<0.) a+=2.*PI;\n\n    // axis\n    vec2 axis = Clamp(h*(abs(p)-.02));\n    vec3 bkg = mix(vec3(0,0,1),vec3(1),min(axis.x,axis.y));\n\n    // circle\n    float circ = Clamp(h*(abs(length(p)-1.)-.02));\n    vec3 c = mix(ang<a?vec3(1,0,0):vec3(.7),bkg,circ);\n\n    // bezier curve\n    Bezier3 R;\n    fitArc(a, R);\n    float d = sdBezier3(R,p);\n    c = mix(vec3(0),c,Clamp(h*(d-.01)));\n\n    // vertexes\n    d = min(length(p-R.B),length(p-R.C))-.04;\n    c = mix(vec3(0),mix(vec3(1),c,Clamp(h*d)),Clamp(h*(abs(d)-.002)));\n    d = min(length(p-R.A),length(p-R.D))-.05;\n    c = mix(vec3(0),mix(vec3(1),c,Clamp(h*d)),Clamp(h*(abs(d)-.005)));\n\n    col = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}]}