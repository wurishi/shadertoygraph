{"ver":"0.1","info":{"id":"cdtyDn","date":"1694946308","viewed":135,"name":"Radiance Cascades visualization","username":"sam_izdat","description":"Rough template to visualize parameters for radiance cascades (a GI technique developed by Alexander Sannikov)","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// KEYS:\n// E    - PLAY, \n// Q    - STOP/C0\n// 0-3  - SELECT CASCADE\n// W    - SHOW ALL CASCADES\n\n//---------------------------------------------------\nconst int C0_PROBE_DIRECTIONS = 6;       // ray directions at cascade 0\nconst ivec2 C0_PROBE_RES = ivec2(16, 8); // probe resolution at cascade 0\nconst bool VARY_PROBE_RES = true;        // halve probe resolution on each cascade?\nconst int N_CASCADES = 4;                // total number of cascades\nconst int RAY_SCALE = 2;                 // 2 - double, 4 - quadruple, etc every cascade\nconst bool SHOW_PROBE_CENTER = true;\nconst bool SHOW_PROBE_GRID = true;\n// ---------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    int viewCascade = int(fetchData(iChannel0, VIEW_CASCADE_ADDR).r);\n    vec2 uv = fragCoord/iResolution.xy;\n    // Animation\n    int cascadeAnimFrame = int(mod(iTime, float(N_CASCADES+1))); \n    bool showFinal = viewCascade == -2 && cascadeAnimFrame == N_CASCADES;\n    ivec2 probeRes = VARY_PROBE_RES && viewCascade == -2 && !showFinal\n        ? C0_PROBE_RES / int(pow(2., float(cascadeAnimFrame)))\n        : (showFinal || viewCascade == -1 \n            ? ivec2(1, 1) \n            : VARY_PROBE_RES \n                ? C0_PROBE_RES / int(pow(2., float(max(viewCascade,0))))\n                : C0_PROBE_RES);\n\n    // Other decorative crap\n    float lineFreq = 3.; // every this many pixels from probe center...\n    float lineSize = 1.; // ...color in this many pixels\n    float rayThickness = 0.1;  \n    vec3 rayColor = vec3(.15,.01,.31);\n    float rayIntensity = 200. / float(probeRes.x * probeRes.y);  \n    vec3 mouseColorCascade = vec3(1., 0.2, 0.2);\n    vec3 mouseColorRay = vec3(0.2, 0.2, 1.);\n    float mouseLightIntensity = 10.;\n    vec4 gridColor = vec4(0.25, 0., 0.25, 1.);\n    vec4 dotColor = vec4(1., 1., 1., 1.);\n    vec2 pixelSize = vec2(1. / iResolution.x, 1. / iResolution.y);\n    fragColor = showFinal \n        ? mix(vec4(0., 0., 0.35, 1.), vec4(0.35, 0., 0., 1.), uv.y)\n        : mix(vec4(0.05, 0.03, 0.01, 1.), vec4(0.0, 0.0, 0.2, 1.), uv.y);    \n    \n    // Actual visualization\n    vec2 cascadeSpan[N_CASCADES];\n    float t1 = sqrt(iResolution.x * iResolution.x) * 4.0f / (float(1 << 2 * N_CASCADES) - 1.0f);\n    for (int i = 0; i < N_CASCADES; i++){ \n        float tmin = (i == 0) ? 0. : t1 * float(1 << 2 * (i - 1));\n        float tmax = t1 * float(1 << 2 * i);\n        cascadeSpan[i] = vec2(tmin, tmax);\n    }\n    float dst;\n    vec2 origin, v, dir;\n    int nTheta, curTheta, curCascade;\n    bool inRay = false;\n    for (int pbx = 0; pbx < probeRes.x; pbx++){   \n        for (int pby = 0; pby < probeRes.y; pby++){\n            nTheta = C0_PROBE_DIRECTIONS;\n            vec2 probeSize = vec2(1. / float(probeRes.x), 1. / float(probeRes.y));\n            origin = vec2(probeSize.x / 2. + probeSize.x * float(pbx), probeSize.y / 2. + probeSize.y * float(pby));  \n            origin *= iResolution.xy;\n            v = vec2(origin.xy - uv.xy*iResolution.xy);\n            dst = length(v);\n            dir = normalize(v);\n            for (int i = 0; i < N_CASCADES; i++) { // which cascade are we in?\n                if (dst > cascadeSpan[i].x && dst < cascadeSpan[i].y) { curCascade = i; break; }\n            }\n            nTheta *= int(pow(float(RAY_SCALE), float(curCascade)));\n            for (int i = 0; i < nTheta; i++){ // which sector?\n                float theta = USE_FAST_ATAN ? sloppy_atan2(v.y, v.x) : atan(v.y, v.x);\n                if (curCascade > 0) theta += pi/float(nTheta);\n                float thetaFrac = mod(theta/two_pi * float(nTheta), float(nTheta-1));\n                if (int(round(thetaFrac)) == i) {\n                    if (abs(thetaFrac - float(i)) < rayThickness) inRay = true;\n                    curTheta = i; break;\n                }\n            }\n            if (((viewCascade == -2 && cascadeAnimFrame == curCascade) || showFinal) ||\n                (viewCascade == curCascade || viewCascade == -1)){\n                if (inRay && mod(dst, lineFreq) < lineSize) fragColor.rgb += rayColor.rgb*rayIntensity/(dst*dst/iResolution.x);\n                \n                vec2 mousePos = origin.xy - iMouse.xy;\n                float mouseTheta = USE_FAST_ATAN ? sloppy_atan2(mousePos.y, mousePos.x) : atan(mousePos.y, mousePos.x);\n                float mouseThetaFrac = mod(mouseTheta/two_pi * float(nTheta), float(nTheta-1));                    \n                if (iMouse.z > 0.\n                    && length(mousePos) < cascadeSpan[curCascade].y\n                    && length(mousePos) > cascadeSpan[curCascade].x) {\n                    fragColor.rgb += mouseColorCascade * mouseLightIntensity / float(nTheta);\n                    if (abs(mouseThetaFrac - float(curTheta)) < 0.5) {\n                        fragColor.rgb += mouseColorRay * mouseLightIntensity / float(nTheta);\n                    }\n                }      \n            }\n            if (SHOW_PROBE_CENTER && dst < 1.) fragColor = dotColor;\n            if (SHOW_PROBE_GRID && mod(uv.x, 1. / float(probeRes.x)) < pixelSize.x) fragColor = gridColor;\n            if (SHOW_PROBE_GRID && mod(uv.y, 1. / float(probeRes.y)) < pixelSize.y) fragColor = gridColor;\n            inRay = false; curCascade = 0; curTheta = 0;\n        }    \n    }\n    fragColor = clamp(fragColor, 0., 1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GETKEY(INDEX) (texelFetch(iChannel1,ivec2(INDEX,0),0).x>0.5)\n\n#define KEY_0\t\t48\n#define KEY_1\t    49\n#define KEY_2\t    50\n#define KEY_3\t    51\n#define KEY_Q\t    81\n#define KEY_W \t    87\n#define KEY_E \t    69\n\nconst ivec2 VIEW_CASCADE_ADDR = ivec2(0, 0);\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n// from https://www.shadertoy.com/view/tdGBDG\n\n// ----------------------------\n#define pi 3.14159265358\n#define two_pi 6.28318530718\n#define pi_over_4 0.78539816339\n#define three_pi_over_4 2.35619449019\n\nconst bool USE_FAST_ATAN = false;\n\n// https://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization/\nfloat sloppy_atan2(float y, float x)\n{\n   float abs_y = abs(y)+1e-10;     // kludge to prevent 0/0 condition\n   float r = x >= 0. ? (x - abs_y) / (x + abs_y) : (x + abs_y) / (abs_y - x);\n   float angle =  x >= 0. ? pi_over_4 - pi_over_4 * r : three_pi_over_4 - pi_over_4 * r;\n   if (y < 0.) return(-angle);     // negate if in quad III or IV\n   else return angle;\n}\n\n\nfloat fast_sqrt(float x_in)\n{\n\tint x = floatBitsToInt(x_in);\n\tx = 0x1FBD1DF5 + (x >> 1);\n\treturn intBitsToFloat (x);\n}\n\nfloat distanceSquared2D(vec2 a, vec2 b) { a -= b; return dot(a, a); }\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (storeData(fragCoord, VIEW_CASCADE_ADDR)) {\n        fragColor = vec4(-2.0, 0.0, 0.0, 0.0);\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, VIEW_CASCADE_ADDR)) {\n            fragColor = fetchData(iChannel0, VIEW_CASCADE_ADDR);\n\n            if(GETKEY(KEY_Q)) fragColor.r = 0.;\n            if(GETKEY(KEY_0)) fragColor.r = 0.;\n            if(GETKEY(KEY_1)) fragColor.r = 1.;\n            if(GETKEY(KEY_2)) fragColor.r = 2.;\n            if(GETKEY(KEY_3)) fragColor.r = 3.;\n            if(GETKEY(KEY_W)) fragColor.r  = -1.;\n            if(GETKEY(KEY_E)) fragColor.r  = -2.;\n            fragColor = clamp(fragColor, -2., 3.); \n\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}