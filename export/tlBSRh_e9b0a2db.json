{"ver":"0.1","info":{"id":"tlBSRh","date":"1564989792","viewed":150,"name":"mandelbrother","username":"foran","description":"mandelbrother","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrother"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// Simple Mandelbulb - by @SyntopiaDK\n// (The camera code and lightning was taken from an example by @mrdoob)\n\nfloat PI=3.14159265;\n#define Power 8.0\n#define Bailout 4.0\n\nvoid powN1(inout vec3 z, float r, inout float dr) {\n\t// extract polar coordinates\n\tfloat theta = acos(z.z/r);\n\tfloat phi = atan(z.y,z.x);\n\tfloat power = Power*cos(iTime*0.001+length(iMouse)*0.009);\n\tdr =  pow( r, power-1.0)*power*dr + 1.0 + pow((1.-cos(iTime*.3)*cos(iTime*.2)), -2.5);\n\t\n\t// scale and rotate the point\n\tfloat zr = pow( r,power);\n\ttheta = theta*power;\n\tphi = phi*power;\n\t\n\t// convert back to cartesian coordinates\n\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n}\n\n\n// Compute the distance from `pos` to the Mandelbox.\nfloat DE(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=1.0;\n\tr=length(z);\n\tfor(int i=0; (i < 5); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tif (r>Bailout) break;\n\t}\n\t\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 DEColor(vec3 pos) {\n\tvec3 z=pos;\n\tfloat r;\n\tfloat dr=1.0;\n\tr=length(z);\n\tfloat minR = 1000.0;\n\tfor(int i=0; (i < 2); i++) {\n\t\tpowN1(z,r,dr);\n\t\tz+=pos;\n\t\tr=length(z);\n\t\tminR = min(r,minR);\n\t\tif (r>Bailout) break;\n\t}\n\tfloat i = minR*minR*minR*minR*0.70;\n\treturn vec3(clamp(i,0.0,1.0));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n//void main(void)\n{\n  vec2 vPos=-1.0+2.0*fragCoord.xy/iResolution.xy;\n\n  //Camera animation\n  vec3 vuv=vec3(0,1,0);//Change camere up vector here\n  vec3 vrp=vec3(0,0,0); //Change camere view here\n  float mx=iMouse.x*PI*0.009;\n  float my=iMouse.y*PI*0.009;\n  vec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*2.0; //Trackball style camera pos\n  \n\n  //Camera setup\n  vec3 vpn=normalize(vrp-prp);\n  vec3 u=normalize(cross(vuv,vpn));\n  vec3 v=cross(vpn,u);\n  vec3 vcv=(prp+vpn);\n  vec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  vec3 scp=normalize(scrCoord-prp);\n\n  //Raymarching\n  const vec3 e=vec3(0.001,0,0);\n  const float maxd=5.0; //Max depth\n  float s=0.0;\n  vec3 c,p,n;\n\n  float f=0.010;\n  for(int i=0;i<512;i++){\n    f+=s;\n    p=prp+scp*f;\n    s=DE(p);\n     if (abs(s)<.000525||f>maxd) break;\n   \n  }\n  \n  if (f<maxd){\n    n=normalize(\n      vec3(s-DE(p-e.xyy),\n           s-DE(p-e.yxy),\n           s-DE(p-e.yyx)));\n    c = DEColor(p);\n    c.yz = mix(c.yz, n.yz, 0.3);\n    float b=dot(n,normalize(prp-p));  \n    fragColor = mix(vec4((b*c+pow(b,16.0))*(1.0-f*.01),1.0), vec4(c,1.0),0.58);\n  }\n  else fragColor=vec4(.9,.9,.9,1); //background color\n}","name":"Image","description":"","type":"image"}]}