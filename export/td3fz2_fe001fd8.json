{"ver":"0.1","info":{"id":"td3fz2","date":"1605542126","viewed":59,"name":"TP1 - Modelisation","username":"ARGH","description":"TP1, Terrain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing\n// Eric Galin\n\nconst float view = 5000.0;  // View distance\nconst float Epsilon = 0.05; // Marching epsilon\n\n// Iterations\nconst int Steps = 256;      // Maximum number of steps when sphere-tracing\nconst float K = 7.0;\t    // Lipschitz constant\n\n// Rendering\nconst float fog = 5000.0;   // Fog attenuation distance\n\nfloat ridgeNoise( in vec2 x )\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=415.0;   // Initial amplitude\n    \n\tfloat a = -300.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    for( int i=0; i<10; i++ )\n    {\n        float n = 1.0 - 2.0 * pow(abs(Noise(p) - 0.5), 1.0); //ridge noise ?\n        //float n = 1.0 - pow(abs(Noise(p) - 0.5), 1.0); //ridge noise ?\n        //float n = Noise(p);\n        a += b*n;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn a;\n}\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain( in vec2 x )\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=415.0;   // Initial amplitude\n    \n\tfloat a = -1000.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    for( int i=0; i<10; i++ )\n    {\n        //float n = 1.0 - 2.0 * pow(abs(Noise(p) - 0.5), 1.0); //ridge noise ?\n        float n = 1.0 - pow(abs(Noise(p) - 0.5), 1.2); //ridge noise ?\n        //float n = Noise(p);\n        a += b*n;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn a;\n}\n\nfloat elevationDiskRidge(vec2 p, vec3 c) {\n    return c.z + ridgeNoise(p) - ridgeNoise(c.xy);\n}\n\nfloat elevationDiskPerlin(vec2 p, vec3 c) {\n    return c.z + Terrain(p) - Terrain(c.xy);\n}\n\nfloat elevationLinePerlin(vec2 p, vec2 a, vec2 b, float deep) {\n    float d = distanceLine(p, a, b);\n    return deep + Noise(log(d));\n}\n\n// Implicit surface defining the terrain\n// p : Point\nfloat Implicit(in vec3 p)\n{\n\tfloat h = Terrain(p.xy);\n    float a = 1.0;\n    \n    vec3 cTemp = vec3(1200.0, 0.0, 600.);\n    float alphaTemp = influenceDisk(p.xy, cTemp.xy, 1000.);\n\tfloat elevTemp = elevationDiskRidge(p.xy, cTemp);\n    h = elevationBlending(h, elevTemp, a, alphaTemp);\n    a = influenceBlending(a, alphaTemp);\n    \n    cTemp = vec3(600.0, -1600.0, 600.);\n   \talphaTemp = influenceCircle(p.xy, cTemp.xy, 700.0, 800.0);\n    elevTemp = elevationDiskRidge(p.xy, cTemp);\n    h = elevationBlending(h, elevTemp, a, alphaTemp);\n    a = influenceBlending(a, alphaTemp);\n    \n    \n    cTemp = vec3(30.0, 0.0, 400.);\n   \talphaTemp = influenceCircle(p.xy, cTemp.xy, 500.0, 400.0);\n    elevTemp = elevationDiskRidge(p.xy, cTemp);\n    h = elevationBlending(h, elevTemp, a, alphaTemp);\n    a = influenceBlending(a, alphaTemp);\n    \n    vec2 x = vec2(30., 0.0);\n    vec2 y = vec2(-800.0, 800.0);\n    alphaTemp = influenceLine(p.xy, x, y, 400.0);\n    elevTemp = elevationLinePerlin(p.xy, x, y, -320.);\n    h = elevationBlending(h, elevTemp, a, alphaTemp);\n    a = influenceBlending(a, alphaTemp);\n\n    cTemp = vec3(-800.0, 1000.0, -400.);\n    alphaTemp = influenceCircle(p.xy, cTemp.xy, 300., 1000.);\n\televTemp = elevationDiskPerlin(p.xy, cTemp);\n    h = elevationBlending(h, elevTemp, a, alphaTemp);\n    a = influenceBlending(a, alphaTemp);\n    \n    x = vec2(1400., 800.0);\n    y = vec2(1400., 1400.0);\n    cTemp = vec3(800.0, 1150.0, 400.);\n    alphaTemp = influenceLine(p.xy, x, y, 1400.0);\n    elevTemp = elevationDiskRidge(p.xy, cTemp);\n    h = elevationBlending(h, elevTemp, a, alphaTemp);\n    a = influenceBlending(a, alphaTemp);\n    \n    h *= a;\n    return p.z - h;\n}\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool Intersect(in vec3 ro, in vec3 rd, out float t,out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<Steps; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = Implicit(p);\n        // 1 cm precision at 1 meter range, reduce precision as we get farther from eye\n        if( abs(h)< Epsilon*sqrt(1.0+t) ) { return true; }\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/K);\n\t}\n\n\treturn false;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 Normal(in vec3 p )\n{\n  float eps = 0.01;\n  vec3 n;\n  float v = Implicit(p);\n  n.x = Implicit( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = Implicit( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = Implicit( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    const vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n\tvec3 col;\n    float t;\n    int it;\n    bool b=Intersect( ro, rd, t , it);\n    if( b==false)\n    {\n        // sky\t\t\n        col = vec3(0.35,0.65,0.95) - rd.z*rd.z*2.5;\n    }\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 p = ro + t*rd;\n        vec3 n = Normal( p );\n\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n\n        col=0.5*vec3(0.471,0.361,0.110);\n        \n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col += dif*vec3(0.5);\n\n\t\t// Fog\n        float fo = 1.0-exp(-pow(t/fog,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, 0.5*col+0.51*vec3(0.35,0.65,0.95), fo );\n\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \treturn vec4(ShadeSteps(it),1.0);\n    }\n    else\n    {\n    // Gamma with square root\n       return vec4( sqrt(col), t );\n    }\n\n}\n\nmat3 moveCamera(float time, out vec3 ro)\n{\n\t// Origin\n    ro =  vec3(2000.0*cos(iMouse.x*0.01),2000.0*sin(iMouse.x*0.01),1000.0) ;\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,500.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float time = iTime*0.25 + 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = moveCamera( time, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\nfloat influence(float d, float r) {\n    if (d < r)\n    \treturn pow(1.0 - pow(d, 2.0) / pow(r, 2.0), 3.0);\n    else\n        return 0.0;\n}\n\nfloat distanceLine(vec2 p, vec2 a, vec2 b) {\n    float distance = 0.;\n    vec2 u = normalize(b - a);\n    float ah = dot(p - a, u);\n    if (ah < 0.) {\n    \tdistance = length(p - a);\t    \n    } else if (ah > length(b - a)) {\n        distance = length(p - b);\n    } else {\n   \t\tdistance = sqrt(pow(length(p - a), 2.) - pow(ah, 2.));\n    }\n    \n    return distance;\n}\n\nfloat influenceLine(vec2 p, vec2 a, vec2 b, float r) {\n    float d = distanceLine(p, a, b);\n    return influence(d, r);\n}\n\nfloat distanceCircle(vec2 p, vec2 c, float r) {\n    return abs(length(p - c) - r);\n}\n\nfloat influenceCircle(vec2 p, vec2 c, float R, float r) {\n    float d = distanceCircle(p, c, R);\n    return influence(d, r);\n}\n\nfloat distanceCappedTorus(in vec2 p, in vec2 c, float r, in float ra, in float rb)\n{\n  \tvec2 x = vec2(c.x + r * cos(ra), c.y + r * sin(ra));\n    vec2 y = vec2(c.x + r * cos(rb), c.y + r * sin(rb));\n    \n    float temp = min(length(p - x), length(p - y));\n    return min(temp, distanceCircle(p, c, r));\n    \n}\n\nfloat influenceCappedTorus(vec2 p, vec2 c, float R, float ra, float rb, float r) {\n    float d = distanceCappedTorus(p, c, R, ra, rb);\n    return influence(d, r);\n}\n\nfloat influenceDisk(vec2 p, vec2 c, float r) {\n    float d = length(p - c);\n    return influence(d, r);\n}\n\nfloat elevationBlending(float h1, float h2, float alpha1, float alpha2) {\n    return (alpha1 * h1 + alpha2 * h2) / (alpha1 + alpha2);\n}\n\nfloat influenceBlending(float alpha1, float alpha2) {\n    return alpha1 + alpha2;\n}\n\nfloat elevationReplacing(float h1, float h2, float alpha1, float alpha2) {\n    return (1. - alpha1) * h1 + alpha1 * h2;\n}\n\nfloat influenceReplacing(float alpha1) {\n    return alpha1;\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in float p)\n{\n    float i = floor(p);\n    float f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(Hash(i+vec2(0,0)), Hash(i+vec2(1,0)), f);\n}\n","name":"Common","description":"","type":"common"}]}