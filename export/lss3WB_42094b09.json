{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n\n\n\nfloat nSkyR = 0.05;\nfloat nSkyG = 0.05;\nfloat nSkyB = 0.39;\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hash( float n ) //Borrowed from voltage\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat fBmWRand( vec2 p )//Borroowed from Mark Sleith\n{\n    \tfloat f = 0.0;\n    \tf += 0.50000*rand( p ); p = p*2.02;\n    \tf += 0.25000*rand( p ); p = p*2.03;\n    \tf += 0.12500*rand( p ); p = p*2.01;\n    \tf += 0.06250*rand( p ); p = p*2.04;\n    \tf += 0.03125*rand( p );\n    \treturn f/0.984375;\n}\n\nfloat noise( in vec2 x )//Borroowed from Mark Sleith\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n    \tf = f*f*(3.0-2.0*f);\n    \tfloat n = p.x + p.y*57.0;\n    \tfloat res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    \treturn res;\n}\n\nfloat fbm( vec2 p ) //Borroowed from Mark Sleith\n{\n    \tfloat f = 0.0;\n    \tf += 0.50000*noise( p ); p = p*2.02;\n    \tf += 0.25000*noise( p ); p = p*2.03;\n    \tf += 0.12500*noise( p ); p = p*2.01;\n    \tf += 0.06250*noise( p ); p = p*2.04;\n    \tf += 0.03125*noise( p );\n    \treturn f/0.984375;\n}\n\nvec3 bgGradient()\n{\n\t//Getting the height of the current pixel\n\tfloat height = gl_FragCoord.y / iResolution.y;\n\t\n\t//Calculating the brightness of the pixel\n\tfloat brightness = 1.0 - 0.4 * height;\n\t\n\t//Combining everything into a background\n\tvec3 grad = vec3(nSkyR, nSkyG, nSkyB) * brightness;\n\treturn grad;\n}\n\nbool star()\n{\n\t/*//Getting a position to run random calculations with\n\tfloat pos = (fragCoord.x / iResolution.x) * (fragCoord.y / iResolution.y) + 0.5;\n\t\n\tif(hash(pos) < 0.001)\n\t{\n\t\treturn true;\n\t}\n\treturn false*/;\n\t\t\n\tif(fBmWRand(gl_FragCoord.xy / iResolution.xy) < 0.1)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec4 clouds( vec2 point )\n{\n    float overcast = iMouse.y / iResolution.y;\n\tvec4 result = vec4(0., 0., 0., 0.);\n\t\n\t//Checking if the cloud is above\n\tfloat fbmResult = fbm(point * 5.);\n\tif(fbmResult > overcast)\n\t{\n\t\tresult = vec4(fbmResult, fbmResult, fbmResult, 0.95);\n\t}\n\telse if(fbmResult > overcast - 0.07) //Outlining the clouds\n\t{\n\t\tfloat dist = overcast - fbmResult;\n\t\tfloat colorFac = 1.0 - dist / 0.07;\n\t\t\n\t\tresult = vec4(fbmResult, fbmResult, fbmResult, colorFac);\n\t}\n\t\n\t//Finer details\n\tfloat fbmDetail = fbm(point * 20.);\n\tvec4 details = vec4( 0.7 + fbmDetail, 0.7 + fbmDetail, 0.7 + fbmDetail, 1.0);\n\t\n\t//result = mix(result, details, result.a);\n\tresult = result * details;\n\n\treturn result;\n}\n\nvec2 sunPos = vec2(0.15, 0.1);\n\nfloat sunWidth = 0.03;\nfloat sunGlow = 0.015;\n\nfloat sunR = 1.;\nfloat sunG = 1.;\nfloat sunB = 0.8;\n\nvec4 sun()\n{\n\tvec4 result = vec4(0., 0., 0., 0.);\n\tfloat xPos = gl_FragCoord.x / iResolution.x;\n\tfloat yPos = gl_FragCoord.y / iResolution.x;\n\t\n\tfloat xDist = xPos - sunPos.x;\n\tfloat yDist = yPos - sunPos.y;\n\t\n\tfloat dist = sqrt(pow(xDist, 2.) + pow(yDist, 2.));\n\n\t\n\tif(dist < sunWidth)\n\t{\n\t\tresult = vec4(sunR, sunG, sunB, 1.);\n\t}\n\telse if(dist < sunWidth + sunGlow)\n\t{\n\t\tfloat distFact = (dist - sunWidth) / sunGlow;\n\t\t\n\t\tresult = vec4(sunR, sunG, sunB , 1. - distFact);\n\t}\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float overcast = iMouse.y / iResolution.y;\n    float posX = iMouse.x / iResolution.x;\n    \n\t//Creting the final color variable and adding the gradient\n\tvec4 finalColor = vec4(bgGradient(), 1.0);\n\t\n\t//vec4 sunColor = sun();\n\t//finalColor = mix(finalColor, sunColor, sunColor.a);\n\t//If there is a star\n\tif(star() == true)\n\t{\n\t\tfinalColor = vec4(1., 1., 1., 1.);\t//Make the pixel verry bright\n\t}\n\t\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\t//clouds( (15.0 * float(i)) + fragCoord.xy / iResolution.xy + posX * float(i + 1));\n\t\t/*vec4 cloud = clouds( vec2((15. * float(i)) + fragCoord.x / iResolution.x + posX * float(i + 1)),\n\t\t\t\t\t\t\t(15. * float(i)) + fragCoord.y / iResoulution.y);*/\n\t\t\n\t\tvec4 cloud = clouds( vec2( (15. * float(i)) + fragCoord.x / iResolution.x + posX * float(i + 1),\n\t\t\t(15. * float(i)) + fragCoord.y / iResolution.y));\n\t\t\n\t\t//finalColor = finalColor + vec4(cloud, 1.);\n\t\tfinalColor = mix(finalColor, cloud, cloud.a);\n\t}\n\t\n\tfragColor = finalColor;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lss3WB","date":"1378927937","viewed":177,"name":"Night","username":"TheZoq2","description":"A night sky","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["clouds","sky","stars","rain"],"hasliked":0,"parentid":"","parentname":""}}