{"ver":"0.1","info":{"id":"Md2BDd","date":"1502923399","viewed":261,"name":"Deeper Mandelbrot zoom","username":"rory618","description":"Is 256 too many bits? Mouse up and to right -> lower quality, increase speed. Max iter is set on line 127, set it to 2000 at you want to reach the end.\nThe zoom goes all the way to 10^50 times.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["mandelbrot","zoom","deep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    vec2 M = (iMouse.x==0.)?vec2(iResolution.xy*.75):iMouse.xy;\n    vec2 r = iResolution.xy;///(1.-M.y/iResolution.y);\n    for(ivec2 k = ivec2(0);k.x<=4;k.x++){\n        for(k.y = 0;k.y<=4;k.y++){\n            k.x%=6;\n            float s = exp(-length(vec2(k-2)));\n            fragColor += vec4(texture(iChannel0, (fragCoord+vec2(k-2))/r).xyz*s, s );\n        }\n    }\n    fragColor /= fragColor.w;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord/r*iResolution.xy),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 sampl(ivec2[16] z,ivec2[16] c, int iter){\n    vec4 fragColor = vec4(0);\n    float a = 0.;\n    int i = 32768;\n        float aa = 0.;\n    float e;\n        int j;\n        for(j = 0; j < iter; j++){\n\n\n            ivec2[] z2 = ivec2[](ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0));\n            ivec2 sum = ivec2(0);\n\n            //for each digit position, there will be a few digits that will produce a product that lies in that range.\n            //since we are squaring z, we don't have to do some of the partial products twice\n\n            /*\n              1 2 3 4 5 6 7 8\n            1 a . . . . . . . \n            2 b c . . . . .\n            3 c d e . . .\n            4 d e f g .\n            5 e f g h\n            6 f g h\n            7 g h\n            8 h\n\n            */\n            \n            for(int h = 15; h >= 0; h--){\n                ivec2 carry = ivec2(0);\n                \n                //loop along the diagonal and sum the partial products\n                ivec2 ts = sum;\n                for(int t = 0; t < (h+1)/2; t++){\n                    ivec2 a = z[t];\n                    ivec2 b = z[h-t];\n                    sum += ivec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n\n                    //compute overflow and carry\n                    carry += sum/i;\n                    sum %= i;\n                }\n                \n                carry *= 2;\n                sum = 2*sum-ts;\n                \n                \n                sum += ((h+1)%2)*ivec2(z[h/2].x*z[h/2].x-z[h/2].y*z[h/2].y,z[h/2].x*z[h/2].y*2);\n                \n                \n                carry += sum/i;\n                sum %= i;\n                \n                \n                z2[h] = sum+c[h];\n                sum = carry;\n            }\n            \n            \n            \n            ivec2 carry = ivec2(0);\n            for(int h = 15; h >= 0; h--){\n                z2[h]+=carry;\n                carry = z2[h]/i;\n                z[h]=z2[h]%i;\n            }\n            //bailout\n            vec2 z_ = vec2(z[0])+vec2(z[1])/float(i)+vec2(z[2])/float(i)/float(i);\n            if(length( z_ )>24.){\n                e = length(z_);\n                break;\n            }\n            aa = a;\n            a += (sqrt(float(i+15)/120.)*(1.+sin(log(float(i+1)/220.)*abs(atan(z_.y,z_.x)))));\n        }\n\n  \n        //coloring\n        if(j+1<iter){\n            float mu = 10.+log(log(24.))/log(2.) - log(log(e))/log(2.);\n            fragColor.xyz = .5+.5*cos(2.*sqrt(mu+float(j))*vec3(1.2,1.3,1.4));\n        }\n    return fragColor.xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 M = (iMouse.x==0.)?vec2(iResolution.xy*.75):iMouse.xy;\n    vec2 r = iResolution.xy*(1.-M.y/iResolution.y);\n    \n    // Loop\n    int time = iFrame%65555;\n    \n    // Max value of each digit\n    int i = 32768;\n    \n    //zoom in and out\n    float dec = 1.2+float(time)*.001;\n    \n    float zoom = pow(float(i),.001);\n    vec3 rand = hash33(vec3(iFrame,fragCoord));\n    \n    //Don't let those old pixels go to waste! Bonus antialiasing here too.\n    //fragColor = texelFetch(iChannel0, ivec2(((fragCoord+1.1*(rand.yz-.5)-r/2.)/zoom+r/2.)),0);\n    fragColor = texture(iChannel0, ((fragCoord+0.25*(rand.yz-.5)-iResolution.xy/2.)/zoom+iResolution.xy/2.)/iResolution.xy   ) ;\n    \n    \n    \n    if(rand.x<1.-1./(M.x*(.025*length(fragCoord-iResolution.xy/2.)))){\n        return;\n    }\n    \n    float e;\n    //use more iterations when zoomed in more\n    \n    int iter = min(2000,1900*iFrame/3000+100);\n    \n    if(abs(fragCoord.x-iResolution.x/2.)> r.x/2. ||  abs(fragCoord.y-iResolution.y/2.) > r.y/2. ) return;\n    \n    //if(fragCoord.x < r.x && fragCoord.y < r.y){\n        \n\n\n        vec2 uv = 50.*(fragCoord.xy + .5*(rand.yz-.5) - iResolution.xy*.5)/r.y/pow(float(i),fract(dec));\n\n\n        //initialize z\n        ivec2[] z = ivec2[](ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0));\n\n    \n        // 1.25031129104665225557065956654387258152587683745372550334460265 +\n        // 0.03129787147157260261455261372143470867119649776197981985020027825j\n\n    \n    \n        //initialize center\n        ivec2[] c = ivec2[](\n            ivec2(-2,0),\n            ivec2(24565,1025),\n            ivec2(26201,18633),\n            ivec2(25682,19700),\n            ivec2(21793,8204),\n            ivec2(10229,29796),\n            ivec2(1816,24779),\n            ivec2(4545,17780),\n            ivec2(22202,27783),\n            ivec2(30401,2374),\n            ivec2(22824,23216),\n            ivec2(5569,25379),\n            ivec2(32603,21391),\n            ivec2(8817,4731),\n            ivec2(9636,29056),\n            ivec2(0,0));\n        //shift c based on uv, converting uv into base 8196 digits\n        c[0+int(dec)] += ivec2(floor(float(i)*uv));\n        c[1+int(dec)] += ivec2(floor(float(i)*fract(float(i)*uv)));\n        c[2+int(dec)] += ivec2(floor(float(i)*fract(float(i)*fract(float(i)*uv))));\n\n    fragColor.xyz = fragColor.xyz*.5+.5*sampl(z,c,iter);\n    //}\n}","name":"Buf A","description":"","type":"buffer"}]}