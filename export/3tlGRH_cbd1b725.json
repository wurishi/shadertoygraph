{"ver":"0.1","info":{"id":"3tlGRH","date":"1555636125","viewed":103,"name":"Differential Julia - Following","username":"rory618","description":"Change the parameter c of a julia set while zoomed in with the camera following the features of the fractal as it morphs. Pretty glitch still, doesn't work on interior points so connected julia sets don't do as well.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","fractal","ad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R (iResolution.xy)\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    float scale = .01;\n    vec2 s = (iMouse.xy-R.xy/2.)/R.y*2.;\n\tvec2 c = (i-R.xy/2.)/R.y*scale;\n    c += texture(iChannel0, vec2(0)).xy;\n    float col=0.;\n    \n    vec2 z = vec2(c);\n    for(int i = 0; i < 128; i++){\n         z = mat2(z,-z.y,z.x)*z + s;\n        if(length(z) > 2.){\n            col = float(i);\n            break;\n        }\n    }\n    \n\to =  vec4(sin(.25*log(1.+col)*vec3(3,4,5)),1.0);\n    \n\n    \n\n}\n\n/*\n                                                     \n                    Explination:                                               \n                                                                                                \n       Firstly, let z = F(s,c,N) be the                                                  \n     result z_N of iterating z_n+1 = z_n ^ 2 + c                                               \n     times, with z_0 = s. Iterative formulas                                               \n     for dz/ds and dz/dc can be derived easily.                                               \n                                                                                                \n         Starting with z_0:                                               \n                                                                                                                                               \n     dz_0/ds = d/ds (s) = 1\n     dz_0/dc = d/dc (s) = 0                                               \n                                                 \n          The general case z_n+1, using chain rule \n          to depend on previous iteration:\n  \n     dz_n+1/ds = d/ds (z_n+1) = d/ds (z_n ^ 2 + c) = 2*z_n*dz_n/ds\n     dz_n+1/dc = d/dc (z_n+1) = d/dc (z_n ^ 2 + c) = 2*z_n*dz_n/dc + 1\n  \n  \n       Now the effect of the starting location and \n     seed parameter on the resulting z value can \n     be computed along with z itself.\n  \n       Introduce the known quantity dc/dt, the variation \n     of the seed parameter over time. Additionally, the \n     values dz/dt and ds/dt are important and will be \n     found. ds/dt is a variation in the starting value of\n     z which is a scaled pixel coordinate, so a non zero\n     ds/dt represents a sliding translation. If the sliding \n     translating exactly matches the way the shape of the\n     fractal evolves as c changes over time, then the \n     translation is following the local structure of the \n     fractal, and the value z does not change, thus dz/dt = 0\n  \n          Expanding dz/dt in terms of its partial derivatives gives:\n  \n     dz/dt = dz/dc dc/dt + dz/ds ds/dt = 0\n  \n          All but one quantity here is unknown, so the local\n          translation ds/dt is found by rearranging:\n  \n     -(dz/dc dc/dt)/(dz/ds) = ds/dt\n\n\n          Summary/general approach\n        Solve for all partial derivatives of a fractals orbit endpoint wrt\n      the parameters and the pixel coordinate (this starting parameter only\n      in the case of a julia set). Then solve for ds/dt in terms of the known\n      quantities using the expansion of dz/dt.\n\n\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define R (iResolution.xy)\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    if(iFrame<3){\n    \to = vec4(0,1.01,0,0);\n    } else {\n        vec4 oMouse = texture(iChannel3, vec2(0));\n        o = texture(iChannel1, i/R.xy);\n            \n        float scale = 2.;\n        vec2 c = (iMouse.xy-R.xy/2.)/R.y*scale;\n        vec2 s = o.xy;\n\n        vec2 dcdt = (iMouse.xy-oMouse.xy )/R.y*scale;\n\n        float col=0.;\n\t\tbool convergent = false;\n        vec2 z = vec2(s);\n        vec2 dzdc = vec2(0);\n        vec2 dzds = vec2(1,0);\n        for(int i = 0; i < 32; i++){\n\n            dzdc = vec2(1,0) + 2.*cprod(z,dzdc);\n            dzds = 2.*cprod(z,dzds);\n            z = csqr(z) + c;\n            if(length(z) > 2.){\n                convergent = true;\n                break;\n            }\n        }\n\n        vec2 dsdt = -cdivide(cprod(dzdc,dcdt),dzds);\n        if(iMouse.z>0. && oMouse.z>0.){\n            \n            \n            \n            \n            if(length(dsdt) < 1. && convergent){\n        \t\to.xy += dsdt;\n            }\n    \t} else {\n            o = texture(iChannel1, i/R.xy);\n        }\n        vec2 toEdge = -cdivide(z,dzds)/40.;\n        o.xy += (convergent)?toEdge:vec2(0);\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 cprod(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 csqr(vec2 a){\n    return cprod(a,a);\n}\nvec2 conj(vec2 z) {\n    return vec2(1,-1)*z;\n}\nfloat cabs(vec2 z) {\n    return sqrt(cprod(z,conj(z)).x);\n}\nfloat cabs2(vec2 z) {\n    return cprod(z,conj(z)).x;\n}\nvec2 cinv(vec2 z){\n    return conj(z)/cabs2(z);\n}\nvec2 cdivide(vec2 a, vec2 b){\n    return cprod(a,cinv(b));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n#define R (iResolution.xy)\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = iMouse;\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}