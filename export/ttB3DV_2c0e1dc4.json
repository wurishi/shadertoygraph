{"ver":"0.1","info":{"id":"ttB3DV","date":"1561139611","viewed":829,"name":"Springs of Arbitrary Profile","username":"blackle","description":"How to make a spring whose profile is any arbitrary (symmetric) signed distance function.\n\nclick to look around","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["helix","spring","coil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//How to make a spring whose profile is any arbitrary signed distance function.\n//This is not particularly exact, but the code can be quite small when you sizecode it\n//also it requires that the profile be symmetric along the x and y axes.\n\n//// PROFILES ////\nfloat profileSphere(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat profileLine(vec2 p, vec2 dim) {\n    return distance(p, vec2(clamp(p.x, -dim.x/2.0, dim.x/2.0), 0.0))-dim.y;\n}\n\n//the rest of these are from https://iquilezles.org/articles/distfunctions2d\nfloat profileSquare(vec2 p, vec2 dim) {\n    vec2 d = abs(p)-dim;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat profileRhombus(vec2 p, vec2 dim) {\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,dim)+ndot(dim,dim))/dot(dim,dim),-1.0,1.0);\n    float d = length( q - 0.5*dim*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*dim.y + q.y*dim.x - dim.x*dim.y );\n}\n\nfloat profileCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat profileHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n//// SPRING DISTANCE FUNCTION ////\nvec3 closestPointOnCylinder(vec3 p, vec2 dim) {\n    return vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n}\n\nfloat profileForIndex(vec2 p, int profile) {\n    float dist;\n    if (profile == 0) {\n        dist = profileSphere(p, 0.12);\n    } else if (profile == 1) {\n        dist = profileLine(p, vec2(0.4, 0.04));\n    } else if (profile == 2) {\n        dist = profileSquare(p, vec2(0.05,0.1))-0.02;\n    } else if (profile == 3) {\n        dist = profileRhombus(p, vec2(0.1,0.07))-0.03;\n    } else if (profile == 4) {\n        dist = profileCross(p, vec2(0.15,0.05), 0.0)-0.03;\n    } else {\n        dist = profileHexagon(p, 0.1)-0.03;\n    }\n    return dist;\n}\n\nfloat spring(vec3 p, int profile) {\n    float radius = 0.5;\n    float height = 3.0 + sin(iTime);\n    float coils = 5.0/(height/3.141);\n\n    vec3 pc = closestPointOnCylinder(p, vec2(radius, height));\n\n    float distToCyl = distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    \n    //the multiplication factor is here to reduce the chance of the ray jumping through the back spring\n    return profileForIndex(springCoords, profile) * ( max(radius/2.0-abs(length(p.xy)-radius), 0.0)*0.3 + 0.7);\n}\n\n//// ARRAY OF SPRINGS ////\nfloat scene(vec3 p) {\n    p -= vec3(0.0,4.0,0.0);\n    float dist = 10000.0;\n    for (int i = 0; i < 6; i++) {\n        dist = min(dist, spring(p, i));\n        dist = min(dist, profileSphere(vec2(p.x, 0.1+profileForIndex((p.yz+vec2(0.0,2.8))*0.4, i)), 0.1));\n        p += vec3(0.0,1.5,0.0);\n    }\n        \n    return dist;\n}\n\nvec3 sceneGrad(vec3 p) {\n    vec2 epsi = vec2(0.001,0.0);\n    float d1 = scene(p);\n    return normalize(vec3(\n        scene(p+epsi.xyy) - d1,\n        scene(p+epsi.yxy) - d1,\n        scene(p+epsi.yyx) - d1\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    vec2 mouse = iMouse.xy/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 origin = vec3(16.0,0.0,0.0);\n    vec3 dir = -normalize(origin + vec3(0.0,uv)*3.0);\n\torigin+=vec3(0.0,0.0,-0.4);\n    \n    mat3 rot_x = mat3( cos(mouse.x), sin(mouse.x), 0.0,\n                      -sin(mouse.x), cos(mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(mouse.y), 0.0, sin(mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(mouse.y), 0.0, cos(mouse.y));\n    \n    if (iMouse.z > 0.0) {\n\t    origin*=rot_y*rot_x;\n    \tdir*=rot_y*rot_x;\n    }\n    \n    vec3 point = origin;\n    bool interesected = false;\n    for (int i = 0; i < 80; i++) {\n        float dist = scene(point);\n        if (dist > 20.0) break;\n        if (abs(dist) < 0.001) {\n            interesected = true;\n            break;\n        }\n        point += dir * dist;\n    }\n\n    float col = 0.0;\n    if (interesected) {\n        vec3 grad = sceneGrad(point);\n        col = abs(dot(dir,grad));\n    }\n\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}