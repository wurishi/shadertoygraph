{"ver":"0.1","info":{"id":"MdKGDt","date":"1482601355","viewed":199,"name":"Frosty land","username":"public_int_i","description":"Frosty lands, mouse + w to move and look around.\nYou have 2 seconds to go fullscreen before rendering starts.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["ray","march","trace","frosty","path","monte","carlo","land"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n//Image - Renders BufA\n\n//mouse + w to move and look around.\n\n\n#define devrender 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if devrender == 0\n\tfragColor = pow(texture(iChannel0, fragCoord/iResolution.xy)/max(1.,float(iFrame-int(texture(iChannel0,.5/iResolution.xy).w*1e4))), vec4(1./2.2));\n    #else\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(1./2.2));\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n/*\n\n\nmouse + w to move and look around.\n\n\n\nBuf A - montecarlo path tracing\n\n\nHopefully this is the final iteration of my montecarlo path tracing shaders, \nit now handles transparent materials like smoke/clouds correctly. Proper marching inside transparent\nmaterials is done by applying transparencyFilter to the objects distance.\n\n*/\n\n\n\n//constants/settings\n#define pi 3.1415926\n\n#define iterations 184\n#define range 512.\n#define epsilon 2e-2\n#define valid_background_distance epsilon\n\n//#define ambient_refractive_index 1.\n#define ambient_refractive_index 1.000293\n\n#define minDelta .1\n#define maxDelta .8\n#define skipDelta .5\n\n#define devrender 0\n\n\n\nconst vec3 sunDirection = normalize(vec3(2.,-1.,-1.)),\n    \t   sunColor = vec3(.84,.74,.98)*4.,\n    \t   skyColor = vec3(40., 70., 130.)/2055.;\nconst float sunSize = .002;\n\n\n\nstruct Material {\n    vec3 diffuse,specular;\n    float roughness,metallic,emissive,opacity,refractiveIndex;\n};\n\n\n//2d rotation, p = point  a = angle\nvec2 rot(vec2 p, float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n//random ray using p as a seed\nvec3 randomRay(in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand;\n}\n\n//random hash based on iframe and seed s\nfloat ifrm;\n#define rndifrm(s) fract(fract(ifrm*.044877+s)*256.494+ifrm*.02934)\n\n\n\n//shape distance functions and smin thanks to iq https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat ssub(float a, float b, float k) {\n    float sd = smin(a,-b,k);\n    return max(-sd,b);\n}\n\n//scene functions and variables\n#define nObjects 3\n\n//randomizes distance to simulate transparency. d = distance, o = opacity and p = 3d seed\n#define transparencyFilter(d,o,p) mix(d, skipDelta, clamp(ceil(-(d-epsilon*1.1)),0.,1.)*floor(hash3(p+rndifrm(p*512.)*1024.)+(1.-o)))\n\nstruct SceneContext {\n    float distances[nObjects];\n    float closestDistance;\n    int closestId;\n};\n\n\n//distance function, returns the distance to the closest object from a point\nvoid scene(vec3 p, out SceneContext sc) {\n    #define pd(d,i) sc.distances[i] = d; if (sc.distances[i] < sc.closestDistance) {sc.closestId = i;sc.closestDistance = sc.distances[i];}\n    #define id(d) sc.closestDistance = sc.distances[0] = d; sc.closestId = 0;\n    \n    //ground/water\n    float gd = -p.y+3.;\n\n    \n    //ice chunks\n    float icd = 1e8;\n    for (int i = 0; i < 1; i++) {\n    \tvec3 lp = vec3(mod(abs(p.xz+float(i)*30.),120.)-60., p.y).xzy;\n        float id = floor(abs(p.x+float(i)*60.)/120.)+floor(abs(p.z+float(i)*30.)/120.)*96.-float(i)*1280.;\n        \n        lp.y += 20.-((cos(id*.028)*cos(id*1.877394))*.5+.5)*50.;\n        lp.xz = rot(lp.xz, id*.024+id*2.193);\n        if (cos(id+.294) < -.3) lp.xz = abs(lp.xz)-.1;\n        lp.zy = rot(lp.zy, id*.124+id*1.9667);\n        if (cos(id*1.837+1.934) < .2) lp.zy = abs(lp.zy)-.1;\n        icd = min(icd,\n                  sdTriPrism(lp, vec2(20.+hash(id*1.194+id*.024)*80.,2.+hash(id*.03392+id*.9779+19.7933)*40.)));\n    }\n    \n    //bumps\n    for (int i = 2; i < 3; i++) {\n        float sz = pow(float(i),5.)*.08;\n        vec2 sp = p.xz+cos(p.zx/(sz*.692)+cos(p.xz/(sz*7.394))*5.)*sz;\n        float dsp= length(cos(sp/sz))*sz*.2*length(cos(p.zx/(sz*3.394)));\n    \tgd += dsp;\n        icd += dsp;\n    }\n    \n    \n    id(gd);\n    pd(icd, 1);\n                   \n    \n    //igloo\n    float id = length(p)-20.;\n    vec3 cc = vec3(vec2(atan(p.x,p.z), p.y/20.)/pi*10., id);\n    float cci = floor(cc.x)+floor(cc.y);\n    vec2 rcc = abs(fract(cc.xy)-.5)-.45;\n    id = min( max(abs(cc.z+hash(cci*1.2947)*.5)*.9-.4, max(rcc.x,rcc.y)),\n             1e8);\n    \n    \n    cc.xy += .5;\n    float cci2 = floor(cc.x)+floor(cc.y);\n    vec2 rcc2 = abs(fract(cc.xy)-.5)-.45;\n    id = min( max(abs(cc.z+hash(cci2*1.2947)*.5)*.9-.4, max(rcc2.x,rcc2.y)),\n             id)-.05;\n    \n    float entranceA = length(p.xy-vec2(0.,2.))-6.,\n     \t  entranceB = abs(p.z-22.)-4.;\n    id = max( -max(entranceA+1., entranceB-1.),\n        \tmin(max(entranceA,entranceB),\n             id));\n    pd(id, 2);\n    \n    //pd(length(p)-5., 2);\n    \n    //pd(max(-(gd-epsilon*5.), sdBox(abs(p)-vec3(25.,0.,25.), vec3(3.,10.,3.))), 2);\n}\n\n//material from closest object\nvoid material(in vec3 p, in SceneContext sc, out Material mat) {\n    \n    if (sc.closestId == 1) {\n        //rock ice material\n   \t\tmat = Material(vec3(.84,.86,.99), vec3(.84,.86,.98), .02, 1., 0., .6, 1.31);\n        return;\n    }\n    \n    if (sc.closestId == 2) {\n        //igloo material\n   \t\tmat = Material(vec3(.84,.86,.99)*.1, vec3(.84,.86,.98), .2, 1., 0., .8, 1.01);\n        return;\n    }\n    \n    //ground/water material\n    mat = Material(vec3(.84,.86,.94), vec3(.94,.95,.99), mix(.08,.9,clamp((texture(iChannel2,p.xz/128.).x-.2)*3.,0.,1.)), .84, 0., 1., 1.);\n}\n\n\n\nfloat voronoi(in vec2 uv) {\n    vec2 lp = abs(uv)*10.;\n    vec2 sp = fract(lp)-.5;\n    lp = floor(lp);\n    \n    float d = 1.;\n    \n    for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            \n            vec2 mp = vec2(float(x),float(y));\n            vec2 p = lp+mp;\n            \n            d = min(d,length(sp+(cos(p.x)+cos(p.y))*.3-mp));\n            \n        }\n    }\n    \n    return d;\n}\n//static backgrund\nvec3 background(vec3 d) {\n    return pow(cos(texture(iChannel1, d).xyz*9.)*.5+.5, vec3(4.0,2.2,1.7))*.6;\n}\n\nfloat df(vec3 p) {\n    SceneContext sc;\n    scene(p,sc);\n    return sc.closestDistance;\n}\n    \n    \n//normal from distance function at point p\nvec3 normal(vec3 p) {\n    const vec2 NE = vec2(epsilon, 0.);\n    return normalize(vec3( df(p+NE.xyy)-df(p-NE.xyy),\n                           df(p+NE.yxy)-df(p-NE.yxy),\n                           df(p+NE.yyx)-df(p-NE.yyx) ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ffc = floor(fragCoord);\n    if (iFrame < 120) {\n        //initialize buffer, wait 120 frames so people have time to go fullscreen\n        if (ffc.x+ffc.y == 0.) {\n            //camera data pixel 1, camera position and last change frame id\n            fragColor = vec4(-40., -4., 10., 120./1e4);\n        } else if (ffc.x == 1. && ffc.y == 0.) {\n            //camera data pixel 2, camera rotation\n            fragColor = vec4(4.7, pi+.8, 0., 0.);\n        } else {\n            fragColor = vec4(0.);\n        }\n        return;\n    }\n    vec4 cd1 = texture(iChannel0, .5/iResolution.xy);\n    vec2 cd2 = texture(iChannel0, vec2(1.5,.5)/iResolution.xy).xy;\n    if (ffc.x+ffc.y == 0.) {\n        //camera movement\n        float mov = texture(iChannel3, vec2(38.5, 25.5)/255.).x;\n        vec3 crd = vec3(0.,0.,1.);\n        crd.yz = rot(crd.yz, cd2.x);//camera pitch\n        crd.xz = rot(crd.xz, cd2.y);//camera yaw\n        cd1.xyz += mov*crd*iTimeDelta*10.;\n        if (iMouse.w > 0. || mov > 0.) {\n            cd1.w = float(iFrame+1)/1e4;\n        }\n        fragColor = cd1;\n        return;\n    } else if (ffc.x == 1. && ffc.y == 0.) {\n        //camera rotation\n        if (iMouse.w > 0.) {\n            cd2 += (iMouse.yx/iResolution.yx-.5)/vec2(-20.,10.);\n        }\n        fragColor = vec4(cd2,0.,0.);\n        return;\n    }\n    ifrm = float(iFrame);\n    \n    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.x;\n    uv += (vec2(hash3(vec3(uv*194.245,float(iFrame)/4096.)),\n               hash3(vec3(uv.yx*114.727,float(iFrame)/4096.)))-.5)/iResolution.xy;\n    \n    vec3 rp = cd1.xyz,//camera/ray location\n    \t rd = normalize(vec3(uv*2.,1.));//ray direction\n\t\n    rd.yz = rot(rd.yz, cd2.x);//camera pitch\n    rd.xz = rot(rd.xz, cd2.y);//camera yaw\n    \n    \n    vec3 c = vec3(1.), l = vec3(0.);//ray color and light accumulation\n    \n    \n    #if devrender == 0\n    \n    float s = 0.,//total distance travelled by ray \n          ls = 0.,\n    \t  lastD = 1e8;\n        \n    //path tracing\n    for (int i = 0; i < iterations; i++) {\n        SceneContext sc;\n        scene(rp, sc);\n        float dt = abs(sc.closestDistance),\n            depsilon = epsilon+pow(s/range,2.)*10.;//closestDistance*(minDelta+hash3(rp+rndifrm(rp)*1024.)*(maxDelta-minDelta));\n\n        if (lastD < depsilon || sc.closestDistance < depsilon) {\n            Material mat;\n        \tmaterial(rp,sc,mat);\n            \n            vec3 norm = normal(rp),\n            \t rndRay = randomHemiRay(norm, rp+rndifrm(rp*756.)*1024.);\n\n            if (lastD > depsilon) {\n                if (hash3(rp+rndifrm(rp*756.)*756.) < max(mat.opacity,mat.metallic*.5)) {\n                \trp -= rd*1.*(depsilon*2.-max(0.,sc.closestDistance));//backup so ray isn't intersecting object\n\n                    //emissive\n                    l += c*mat.diffuse*mat.emissive;\n                    if (hash3(rp+rndifrm(rp*512.)*1024.) < mat.opacity*.5*(1.-mat.metallic)) {\n                        //diffuse\n                        c *= mat.diffuse;\n                        rd = rndRay;//random ray in hemisphere of normal for diffuse\n                    } else {\n                        //specular\n                        c *= mat.specular;\n                        rd = reflect(rd,\n                                     mix(norm, rndRay, mat.roughness));//bounce ray and randomize based on roughness\n\n                    }\n                } else {\n                    //refraction\n                    dt *= 2.;\n                    rd = refract( rd, mix(norm,rndRay,mat.roughness), ambient_refractive_index/mat.refractiveIndex);\n                }               \n                ls = 0.;\n        \t} else {\n                if (lastD < depsilon && sc.closestDistance > depsilon) {\n                    //refraction\n                    rd = refract( rd, mix(-norm,rndRay,mat.roughness), mat.refractiveIndex/ambient_refractive_index);\n                    ls = 0.;\n                } else {\n                    dt = max(epsilon, dt*(minDelta+hash3(rp+rndifrm(rp*384.345)*643.942)*(maxDelta-minDelta)));\n                    \n                    c *= pow(mat.specular, vec3(dt));\n                    \n                    //step through transparent object\n                    if (hash3(rp+rndifrm(rp*592.5239)*892.6212) < pow(mat.opacity,1./dt)) {\n                        l += c*mat.diffuse*mat.emissive;//emissive\n                        c *= mat.diffuse;\n                        rd = rndRay;//random ray in hemisphere of normal for diffuse\n                    \tls = 0.;\n                    }\n                }\n            }\n        }\n        \n        rp += rd*+(.8+hash3(rp)*.2)*dt;\n        s += dt;\n    \tif (s > range) break;\n        ls += dt;\n        lastD = sc.closestDistance;\n    }\n    \n    SceneContext sc;\n    scene(rp, sc);\n    if (sc.closestDistance > valid_background_distance) {//if ray is far enough away from any objects add light from background\n        l += c*background(rd);\n    }\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy)*float(iFrame != int(cd1.w*1e4))+\n        vec4(l,1.);//add path result to buffer\n\n    #else\n    //simple debug rendering\n    float s = 0.;\n    for (int i = 0; i < iterations; i++) {\n        SceneContext sc;\n        scene(rp, sc);\n        if (sc.closestDistance < epsilon || s > range) break;\n        \n        rp += rd*sc.closestDistance;\n        s += sc.closestDistance;\n    }\n    SceneContext sc;\n    scene(rp, sc);\n    if (sc.closestDistance < epsilon) {\n       Material mat;\n       material(sc, mat);\n       l = mat.diffuse*(.3+max(0.,(df(rp)-df(rp-sunDirection*epsilon))/epsilon));\n    } else {\n       l = background(rd); \n    }\n    fragColor = vec4(l,1.);\n    #endif\n}","name":"Buf A","description":"","type":"buffer"}]}