{"ver":"0.1","info":{"id":"DldSzH","date":"1685126254","viewed":113,"name":"Medley of Outlines","username":"medley","description":"A demonstration of a basic outline post-processing effect.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","postprocessing","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Render scene\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scaling\n    float scale = 0.2;\n    vec2 scaledCoord = floor(fragCoord * scale);\n    vec2 scaledResolution = iResolution.xy * scale;\n    \n    // Screen coordinate space\n    vec2 screen = scaledCoord / scaledResolution.xy;\n    \n    // Better coordinate space\n    vec2 p = (2.0 * scaledCoord - scaledResolution.xy) / scaledResolution.y;\n    \n    // Clipping planes\n    vec2 clips = clippingPlanes();\n    float near = clips.x;\n    float far = clips.y;\n    \n    // Set up camera and cast the ray\n    vec3 cam = cameraPos(iTime);\n    vec3 dir = cameraDir(p);\n    vec2 res = castRay(cam, dir, near, far);\n    \n    Material mat = mats[int(res.y)];\n    \n    // Initial color albedo\n    vec3 col = mat.ambient;\n    \n    if ( res.y == 0.0 )\n    {\n        // Only use albedo for sky\n        col = mat.albedo;\n        \n        // Sky shading\n        col += vec3(1.0) * smoothstep(0.75,1.5,1.0-p.y);\n    }\n    else\n    {\n        // Ambient color\n        col = mat.ambient;\n        \n        // Lit color\n        \n        vec3 ld = normalize(vec3(1.0,1.0,-1.0)); // Stationary light\n        /* Turning light\n        vec3 ld = normalize(vec3(cos(iTime/7.0*2.0*PI-PI/2.0),  // Light dir\n                                 1.0,\n                                 sin(iTime/7.0*2.0*PI-PI/2.0)));\n        */\n        vec3 lc = vec3(0.8,0.7,0.5); // Light color\n        col += mat.albedo * lc * clamp(dot(calcNormal(cam+dir*res.x),ld),0.0,1.0);\n        \n        // Bounce lighting\n        float bc = 0.15; // Bounce coefficient\n        col += mat.albedo * lc * (bc * clamp(dot(calcNormal(cam+dir*res.x),-ld),0.0,1.0));\n        \n        // Sky lighting\n        vec3 scol = mats[0].albedo;\n        float scoef = 0.1;\n        col += scol * scoef\n                    * clamp(dot(calcNormal(cam+dir*res.x),vec3(0.0,1.0,0.0)),0.0,1.0);\n    }\n    \n    // Gamma correction\n    col = vec3(pow(col.x,1.0/2.2),pow(col.y,1.0/2.2),pow(col.z,1.0/2.2));\n    \n    vec3 outline = texture(iChannel0,screen).rgb;\n    \n    // Final color\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4(col-outline,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Normal buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinate space\n    vec2 screen = fragCoord / iResolution.xy;\n    \n    // Better coordinate space\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Clipping planes\n    vec2 clips = clippingPlanes();\n    float near = clips.x;\n    float far = clips.y;\n    \n    // Set up camera and cast the ray\n    vec3 cam = cameraPos(iTime);\n    vec3 dir = cameraDir(p);\n    vec2 res = castRay(cam, dir, near, far);\n\n    vec3 col = calcNormal(cam+dir*res.x) * 0.5 + 0.5;\n    \n    // Final color\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Here are some controls over the raymarcher.\n#define HIT_THRESH 0.005\n#define RAYMARCH_ITER 256\n\n#define PI 3.14159265358979\n\n// Represents the material of an in-engine object.\nstruct Material\n{\n    vec3 albedo;\n    vec3 ambient;\n};\n\n// List of materials\nMaterial mats[3] = Material[3](\n    Material(vec3(0.2,0.7,0.9),vec3(0.1,0.2,0.3)),\n    Material(vec3(0.9,0.9,0.9),vec3(0.2,0.2,0.2)),\n    Material(vec3(0.9,0.7,0.3),vec3(0.3,0.1,0.0))\n);\n\n/**\n * The signed distance field of a sphere.\n * Source: Inigo Quilez\n *\n * @param p The point to evaluate the SDF at\n * @param s The radius of the sphere\n * @return The signed distance to the sphere\n */\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n/**\n * The signed distance field of a box.\n * Source: Inigo Quilez\n *\n * @param p The point to evaluate the SDF at\n * @param b The dimensions of the box\n * @return The signed distance to the box\n */\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n/**\n * The signed distance field of a rounded box.\n * Source: Inigo Quilez\n *\n * @param p The point to evaluate the SDF at\n * @param b The dimensions of the box\n * @param r The rounding radius\n * @return The signed distance to the rounded box\n */\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n/**\n * The signed distance field of a cone.\n * Source: Inigo Quilez\n *\n * @param p The point to evaluate the SDF at\n * @param c A vec2 whose x is sin(a) and y is cos(a),\n *          where a is the angle of the cone\n * @param h The height of the cone\n * @return The signed distance to the cone\n */\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n/**\n * The signed distance field of a torus.\n * Source: Inigo Quilez\n *\n * @param p The point to evaluate the SDF at\n * @param t A vec2 containing the inner and outer radii\n * @return The signed distance to the torus\n */\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n/**\n * Find the closer object\n *\n * @param o1 The first object to compare\n * @param o2 The second object to compare\n * @return A two-component vector containing the distance\n *         to and material of the closer object\n */\nvec2 minObj( vec2 o1, vec2 o2 )\n{\n    float d = min(o1.x,o2.x);\n    float m = o1.y * float(o1.x<o2.x) +\n              o2.y * float(o2.x<o1.x);\n    return vec2(d,m);\n}\n\n/**\n * Get the signed distance to the scene at a given point,\n * as well as the material of the closest object.\n * \n * @param pos The point to evaluate the distance at\n * @return A two-component vector containing scene\n *         distance and material index\n */\nvec2 map( vec3 pos )\n{\n    float sphere = sdSphere(pos - vec3(-1.0,2.0,0.0),0.5);\n    float box = sdBox(pos - vec3(1.0,2.0,0.0),vec3(0.5,0.25,0.1));\n    float cone = sdCone(pos - vec3(2.5,2.5,0.0),\n                        vec2(sin(PI/16.0),cos(PI/16.0)),1.0);\n    float torus = sdTorus(pos - vec3(4.0,2.0,0.0),vec2(0.5,0.1));\n    \n    // Min obj\n    vec2 mino = minObj(vec2(sphere,2.0),vec2(box,2.0));\n    mino = minObj(mino,vec2(cone,2.0));\n    mino = minObj(mino,vec2(torus,2.0));\n    \n    return minObj(mino,vec2(pos.y,1.0));\n}\n\n/**\n * Get the normal of the scene at the given point.\n * Source: Inigo Quilez\n *\n * @param p The point at which to evaluate the normal\n * @return The normal of the scene as a vec3\n */\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x));\n}\n\n/**\n * Get the position at which a given ray intersects the scene,\n * as well as the proper material.\n *\n * @param ro   The ray origin\n * @param rd   The ray direction\n * @param tmin The near clipping plane, or minimum distance the ray must travel\n * @param tmax The far clipping plane, or maximum distance the ray can travel\n * @return A two-component vector containing the traveled\n *         distance and the material of the object hit\n */\nvec2 castRay( vec3 ro, vec3 rd, float tmin, float tmax )\n{\n    float t = tmin; // Start at the near plane\n    float m = 0.0;\n    \n    // March the ray along its direction\n    for (int i = 0; i < RAYMARCH_ITER; i++)\n    {\n        // Evaluate the distance to the scene\n        vec2 d = map(ro+rd*t);\n        \n        // Advance t according to the distance\n        t += d.x;\n        \n        // Unadvance and stop evaluating if we're below the hit threshold\n        t -= d.x * float(d.x < HIT_THRESH);\n        i += RAYMARCH_ITER * int(d.x < HIT_THRESH);\n        m = d.y * float(d.x < HIT_THRESH);\n        \n        // Stop evaluating if the t value exceeds the maximum\n        i += RAYMARCH_ITER * int(t > tmax);\n    }\n    \n    return vec2(t,m);\n}\n\n// Some functions to make the camera common between buffers\n// VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\n\n/**\n * Retrieve the current camera position.\n * \n * @return The current camera position as a vec3\n */\nvec3 cameraPos( float time )\n{\n    return vec3(fract(time/7.0)*6.0-2.0,2.0,-1.5);\n}\n\n/**\n * Retrieve the current camera direction.\n *\n * @param coords The screen coordinate system to use\n * @return The camera's direction\n */\nvec3 cameraDir( vec2 coords )\n{\n    return normalize(vec3(coords,1.0));\n}\n\n/**\n * Retrieve the near and far clipping planes.\n *\n * @return A vec2 where x is the near plane and y is the far plane\n */\nvec2 clippingPlanes()\n{\n    float near = 0.5;\n    float far = 100.0;\n    \n    return vec2(near,far);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Edge detection convolution filter\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinate space\n    vec2 screen = fragCoord / iResolution.xy;\n    \n    // Better coordinate space\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Convolution variables\n    mat3 edgeConv  = mat3(0.0,-1.0, 0.0,\n                         -1.0, 4.0,-1.0,\n                          0.0,-1.0, 0.0);\n    vec2 stepSize = 1.0/iResolution.xy;\n    \n    vec3 edges; // Store the result\n    \n    // Convolve matrix\n    for (int col = 0; col < 3; col++)\n    {\n        for (int row = 0; row < 3; row++)\n        {\n            vec2 offset = vec2(-1+row,-1+col);\n            edges += texture(iChannel0,screen+offset*stepSize).xyz *\n                        edgeConv[col][row];\n        }\n    }\n    \n    // Constrain outline to get rid of banding\n    float outline = step(0.1,length(edges));\n    \n    fragColor = vec4(vec3(outline),1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Blur the edges so they're wider\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinate space\n    vec2 screen = fragCoord / iResolution.xy;\n    \n    // Better coordinate space\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Same as buf B but with blurring\n    mat3 blurConv  = mat3(1.0,2.0,1.0,2.0,4.0,2.0,1.0,2.0,1.0); \n    vec2 stepSize = 1.0/iResolution.xy;\n    \n    vec3 blur;\n    \n    for (int col = 0; col < 3; col++)\n    {\n        for (int row = 0; row < 3; row++)\n        {\n            vec2 offset = vec2(-1+row,-1+col);\n            blur += texture(iChannel0,screen+offset*stepSize).xyz *\n                        blurConv[col][row];\n        }\n    }\n    \n    float outline = length(blur);\n    \n    fragColor = vec4(vec3(outline),1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}