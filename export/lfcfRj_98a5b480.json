{"ver":"0.1","info":{"id":"lfcfRj","date":"1733261545","viewed":32,"name":"Cellular 4x4","username":"stegu","description":"Larger 4x4 search window, useful for large jitter amounts and when both F1 and F2 need to be correct everywhere. Quite a bit faster than a 5x5 window, which is the straightforward extension to the standard 3x3.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","cellular"],"hasliked":0,"parentid":"XccfR2","parentname":"Cellular 2x2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Anti-aliased step function\nfloat aastep(float a, float x) {\n    float fw = 0.7*fwidth(x-a);\n    return smoothstep(-fw, fw, x-a);\n}\n\n// Make a kind-of random RGB color from a modulo-289 integer ID\nvec3 rgbh(float h) {\n    return vec3(1.0-mod(h,7.0)/8.0, 0.9-mod(h,49.0)/64.0, 1.0-h/288.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/min(iResolution.x, iResolution.y);\n\n    vec2 F;\n    vec2 P1, P2;\n    float ID1, ID2;\n    vec3 col;\n    \n    F = cellular4x4(uv*12.0, 0.7, P1, P2, ID1, ID2);\n\n    if(uv.x < 0.0) {\n        // AA of cell edges: mix in 2nd neighbor's color near the edge\n        float aamask = (1.0-aastep(0.0, F.y-F.x));\n        col = mix(rgbh(ID1), rgbh(ID2), aamask);\n        col = mix(vec3(1.0), col, aastep(0.05,F.x)); // White dots\n    }\n    else {\n        // The classic \"crystals\" pattern, with some color\n        col = sqrt(F.y-F.x) * rgbh(ID1);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Cellular noise (\"Worley noise\") in 2D.\n// Version 2024-12-03, by Stefan Gustavson.\n// Published under the CC-BY-SA 4.0 license:\n// https://creativecommons.org/licenses/by-sa/4.0/\n\n// Cellular noise, returning F1 and F2 in a vec2,\n// the offset from P to the nearest points P1, P2\n// in \"out\" parameters vec2 P1, P2, and the hashed\n// Voronoi cell IDs in \"out\" parameters float ID1, ID2.\n// 4x4 search window yields correct F1 and F2 values\n// even with large jitters.\n//\n// Explicit loops, compact code that's easy to read.\n// Not *quite* as fast as a vectorized version, but\n// on modern platforms the difference is marginal.\n//\nfloat permute289(float x) {\n  return mod((34.0 * x + 10.0) * x, 289.0);\n}\nvec2 cellular4x4(vec2 P, float jitter,\n        out vec2 P1, out vec2 P2, out float ID1, out float ID2) {\n    jitter = clamp(jitter,0.0,1.0);\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n\tvec2 Pf = P0-P; // Vector from P to closest unjittered grid point P0\n\tfloat px, pxy, d, d1, d2, ox, oy, dx, dy;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n\tfor(float ix = -1.0; ix <=2.0; ix++) {\n\t\tpx = permute289(Pi.x + ix);\n\t\tfor(float iy = -1.0; iy <= 2.0; iy++) {\n\t\t\tpxy = permute289(px + Pi.y + iy);\n            float psi = pxy*0.07482; // Scale the hash (and jumble it some more)\n            // Generate a displacement vector of maximum length\n            ox = cos(psi); // sin and cos are usually fast these days\n            oy = sin(psi);\n            float sqc = 0.5 / max(abs(ox), abs(oy));\n            ox = ox * sqc; // Square the circle\n\t\t\toy = oy * sqc;\n\t\t\tdx = Pf.x + ix + jitter*ox; // points at grid crossings\n\t\t\tdy = Pf.y + iy + jitter*oy; // instead of at cell centers\n\t\t\td = dx*dx + dy*dy; // Distance from P to Pn, squared\n            // d could replace either d1 or d2, handle both cases\n            P2 = (d <= d1 ? P1 : (d<= d2 ? vec2(dx, dy) : P2));\n            ID2 = (d <= d1 ? ID1 : (d<= d2 ? pxy : ID2));\n            d2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n            P1 = (d <= d1 ? vec2(dx,dy) : P1);\n            ID1 = (d <= d1 ? pxy : ID1);\n            d1 = (d <= d1 ? d : d1);\n\t\t}\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n","name":"Common","description":"","type":"common"}]}