{"ver":"0.1","info":{"id":"Dd3fDl","date":"1697741217","viewed":72,"name":"Splitting a sphere many times","username":"skinner","description":"Based on https://www.shadertoy.com/view/ll33Wn\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","celshading","edgedetection"],"hasliked":0,"parentid":"cd3fDl","parentname":"Fork Toon Shade skinner 900"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n#define MAX_STEPS 500\n#define MIN_DIST 0.0\n#define MAX_DIST 25.0\n\n#define AMBIENT 0.05\n#define EDGE_THICKNESS 0.005\n#define SHADES 50.0\n\n#define SLICE_THICKNESS 0.08\n#define PLANE_COUNT 5\n\nfloat TorusSDF(vec3 samplePoint, vec2 dimensions)\n{\n\treturn length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;\n}\n\nfloat PlaneSDF( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return abs(dot(p,n) + h) - SLICE_THICKNESS;\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec3 randomPointOnUnitSphere(vec2 st) {\n    float theta = 2.0 * 3.14159265359 * random(st); \n    float phi = acos(2.0 * random(st + vec2(10.0, 10.0)) - 1.0); \n\n    float sinPhi = sin(phi);\n    vec3 point;\n    point.x = sinPhi * cos(theta);\n    point.y = sinPhi * sin(theta);\n    point.z = cos(phi);\n\n    return point;\n}\n\nvec3 rotateAroundAxis(vec3 v, vec3 n, float a) {\n\treturn v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));\n}\n\nfloat SceneSDF(vec3 samplePoint)\n{\n    float d = 100000.0;\n    for (int i=0; i<PLANE_COUNT; i++)\n    {\n        vec2 st = vec2(float(i), 45.0 - 3.0 * float(i));\n        vec3 axis = randomPointOnUnitSphere(st);\n        vec3 samplePoint2 = rotateAroundAxis(samplePoint, axis, float(i) + iTime / 10.0);\n        // float current_d = TorusSDF(samplePoint2, vec2(1.3, 0.05));\n        float current_d = PlaneSDF(samplePoint2, vec3(1.0, 0.0, 0.0), 0.0);\n        d = min(d, current_d);\n    }\n    // d = min(d, length(samplePoint) - 1.3);\n    float sphere = length(samplePoint) - 1.3;\n    d = max(sphere, -d);\n    // return max(d, 1.3 - length(samplePoint));\n    return d;\n}\n\nfloat March(vec3 origin, vec3 direction, float start, float stop, inout float edgeLength)\n{\n    float depth = start;\n    \n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = SceneSDF(origin + (depth * direction)); // Grab min step\n        edgeLength = min(dist, edgeLength);\n        \n        if (dist < EPSILON) // Hit\n            return depth;\n        \n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist; // Step\n        \n        if (depth >= stop) // Reached max\n            break;\n    }\n    \n    return stop;\n}\n\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\nmat4 LookAt(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - camera);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    \n    return mat4(vec4(s, 0.0),\n        \t\tvec4(u, 0.0),\n        \t\tvec4(-f, 0.0),\n        \t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\nvec3 ComputeLighting(vec3 point, vec3 lightDir, vec3 lightColor)\n{    \n    float rnd = 0.;\n    for (int i=0; i<PLANE_COUNT; i++){\n        vec2 st = vec2(float(i), 45.0 - 3.0 * float(i));\n        vec3 axis = randomPointOnUnitSphere(st);\n        vec3 samplePoint2 = rotateAroundAxis(point, axis, float(i) + iTime / 10.0);\n        float current_d = samplePoint2.x;\n\n        rnd += current_d<0.? float(1<<(i*2)) : float(1<<(i*2 + 1));\n    }     \n    rnd *= .777;\n    vec3 sCol = .5 + .45*cos(6.2831589*rnd/1. + vec3(0, 1, 2)*1.5);\n  \n\n    vec3 color = vec3(AMBIENT);\n    float intensity = dot(EstimateNormal(point), normalize(lightDir));\n    intensity = ceil(intensity * SHADES) / SHADES;\n    intensity = max(intensity, AMBIENT);\n    color = lightColor * intensity/2. + (intensity*.5 + .5)*sCol;;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    // vec3 origin = vec3(sin(iTime) * 9.0, (sin(iTime * 2.0) * 4.0) + 6.0, cos(iTime) * 9.0);\n    vec3 origin = vec3(5.0, 5.0, 5.0);\n    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;\n    \n    float edgeLength = MAX_DIST;\n    float dist = March(origin, viewDir, MIN_DIST, MAX_DIST, edgeLength);\n    \n    if (dist > MAX_DIST - EPSILON) // No hit\n    {\n        fragColor = vec4(0.9);\n        return;\n    }\n    \n    if (dist < EPSILON) // Edge hit\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPoint = origin + (dist * viewDir);\n    // vec3 lightDir = vec3(sin(iTime * 2.0) * 6.0, 4.0, sin(iTime * 1.25) * 5.0);\n    vec3 lightDir = vec3(-2.0, 4.0, 5.0);\n    vec3 color = vec3(1.0, 0.5, 0.3);\n    \n    color = ComputeLighting(hitPoint, lightDir, color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}