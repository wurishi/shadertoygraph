{"ver":"0.1","info":{"id":"lddXRs","date":"1461101968","viewed":464,"name":"Window","username":"dila","description":"Portal thing. Don't get sucked in!","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float t)\n{\n \treturn mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdBoxXY( vec3 p, vec3 b )\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat mapr = 1.0;\nfloat mapt = 0.0;\nvec3 mapp = vec3(0.0);\n\nfloat map(vec3 p)\n{        \n    //p.x -= 2.0;\n    //p.x = (fract(p.x * 0.25) - 0.5) * 4.0;\n    //p.z = abs(p.z - 1.0);\n    \n    float d = 1000.0;\n    \n    float room = mod(floor(mapr), 4.0);\n    \n    vec2 scl = vec2(0.9, 0.5);\n    \n    if (room == 0.0) {\n        scl.xy = scl.yx;\n    }\n    \n    if (room == 1.0 || room == 3.0) {\n        scl.xy = vec2(0.5);\n    }\n    \n\tfloat k = -sdBox(p, vec3(4.0, 1.0, 4.0));\n    \n    float c = sdBox(p, vec3(scl.x, scl.y, 0.05));\n    \n    float e = sdBox(p, vec3(scl.x+0.1, scl.y+0.1, 0.05));\n    \n    mapt = 3.0;\n\tmapp = p;\n    \n    if (room == 0.0)\n    {\n        if (k < d) {\n            d = k;\n            mapt = 1.0;\n        }\n    }\n    \n    if (room == 2.0)\n    {\n        vec3 spq = fract(p * 0.5 - 0.5) * 2.0 - 1.0;\n        float spin = 1.3 - length(spq);\n\t\tfloat spd = spin;\n        \n        if (spd < d) {\n            d = spd;\n            mapt = 1.0;\n        }\n    }\n    \n    if (c < d) {\n        d = c;\n        mapt = 0.0;\n\t\tmapp = vec3(p.xy, 0.0);\n    }\n\n    if (e < d) {\n        d = e;\n        mapt = 1.0;\n    }\n\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.8;\n    }\n    return t;\n}\n\nvec3 sky(vec3 r, float gt)\n{\n    vec3 t = vec3(0.0);\n    for (int i = 0; i < 4; ++i) {\n        float fi = float(i) / 3.0;\n        float ft = fract(gt - fi);\n        float bt = ft * (1.0 - ft) * 4.0;\n        float sc = 1.0 / (1.0 + ft);\n        vec2 uv = r.xy * sc * rot(iTime);\n        vec3 tex = texture(iChannel0, uv).xyz;\n        tex *= tex;\n        t += tex * bt;\n    }\n    return t;\n}\n\nvec3 _texture(vec3 p)\n{\n\tvec3 ta = texture(iChannel1, p.yz).xyz;\n    vec3 tb = texture(iChannel1, p.xz).xyz;\n    vec3 tc = texture(iChannel1, p.xy).xyz;\n    return (ta*ta + tb*tb + tc*tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float gt = iTime * 0.15;\n    \n    vec3 br = normalize(vec3(uv, 1.0));\n    vec3 r = br;\n    vec3 bo = vec3(0.0, 0.0, -2.0);\n    vec3 o = bo + abs(bo) * fract(gt);\n    \n    mapr = mod(floor(gt), 4.0);\n\tfloat dir = sign(mod(floor(gt), 3.0) - 1.5);\n    \n    float near = fract(gt);\n    mat2 mr = rot((1.0 - near) * near * 1.57);\n\n    r.xy *= mr;\n    o.xy *= mr;\n    r.xz *= mr;\n    o.xz *= mr;\n    \n    vec3 fc = vec3(0.0);\n    vec3 ao = o;\n    \n    for (int i = 0; i < 8; ++i) {\n        \n        float fi = float(i);\n        \n        float t = trace(o, r);\n\n        vec3 w = o + r * t;\n        \n        vec3 n = normal(w);\n\n        float fd = map(w);\n\n        vec2 puv = mapp.xy;\n\n        float fog = 1.0 / (1.0 + t * t * 0.01);\n        \n        vec3 tc = vec3(fog);\n        \n        float first = max(sign(1.0-fi),0.0);\n        \n        vec3 ref = _texture(w * 0.1);\n        \n        ref *= 1.0 - abs(dot(r, n));\n        //tc = mix(ref, ref * (1.0 - near), first);\n        \n        if (t > 100.0) {\n            float pn = near;\n            float st = mix(fract(gt)*4.0, fract(gt), near*first);\n            fc = sky(br, st);\n        } else {\n        \tfc = ref * fog;\n        }\n            \n        if (mapt != 0.0) {\n            break;\n        }\n        \n        //fc = mix(fc, vec3(1.0, 0.0, 1.0), near);\n\n        //fc = mix(fc, fc * vec3(1.0, 0.0, 1.0), 1.0-near);\n        \n        //fc = vec3(1.0);\n        \n        vec3 nr = normalize(vec3(puv, 1.0));\n        \n        float pwn = pow(near, 1.0);\n        r = normalize(mix(nr, br, pwn*first));\n \n        vec3 mo = bo;\n        ao += mo;\n        o = mix(bo, ao, pow(near,1.0)*first);\n        \n        if (fi < 1.0) {\n            mat2 mr = rot((1.0 - near) * 4.0 * near * -3.14);\n            //r.xy *= mr;\n            //o.xy *= mr;\n            r.xz *= mr;\n            o.xz *= mr;\n        }\n\n        mapr += 1.0;\n    }\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}