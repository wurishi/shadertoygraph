{"ver":"0.1","info":{"id":"MdGGDR","date":"1454300672","viewed":180,"name":"Shadertoy 101","username":"abs","description":"Learning Shadertoy. switch the scene to a hastily made chess set by setting line 1 SCENE to 2\n(warning may crash webgl!)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ball","reflections","chess","refractions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE 1\n\n// ground plane is at Y=0\n// sphere is resting on top of ground plane.\n\nconst float SPHERE_RADIUS = 0.2;\nconst int STEPS = 50;\nconst float TMIN = 0.0;\nconst float TMAX = 11.0;\nconst float PI = 3.1415926;\nconst float THRESHOLD = 0.0001;\n\nconst vec3 SPHERE_POS = vec3(0, SPHERE_RADIUS, 0);\nconst vec3 POINT_LIGHT = vec3(0.5, 1.0, 1.5); // world space location of point light\nconst vec3 SPHERE_DIFFUSE_RED = vec3(1,0,0); // diffuse color of the sphere\nconst vec3 SPHERE_DIFFUSE_BLUE = vec3(0,0,1); // diffuse color of the sphere\nconst vec3 WORLD_COLOR = vec3(0.8, 0.9, 1.0);\nconst vec3 LIGHT_COLOR = vec3(1.0, 1.0, 0.1);\n\nconst vec3 GROUND_COLOR_1 = vec3(0.05);\nconst vec3 GROUND_COLOR_2 = vec3(0.9, 0.9, 0.9);\n\nvec3 rotateX(vec3 p, float angle){\n\tvec3 q = p;\n    q.y = cos(angle) * p.y - sin(angle) * p.z;\n    q.z = sin(angle) * p.y + cos(angle) * p.z;\n    return q;\n}\n\nvec3 rotateY(vec3 p, float angle){\n\tvec3 q = p;\n    q.x = cos(angle) * p.x + sin(angle) * p.z;\n    q.z = -sin(angle) * p.x + cos(angle) * p.z;\n    return q;\n}\n\nvec3 rotateZ(vec3 p, float angle){\n\tvec3 q = p;\n    q.x = cos(angle) * p.x - sin(angle) * p.y;\n    q.y = sin(angle) * p.x + cos(angle) * p.y;\n    return q;\n}\n\nfloat plane(vec3 p){\n\treturn p.y;\n}\n\nfloat sphere(vec3 p, float r){\n\treturn length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h){\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 propose(vec2 val, vec2 pVal){\n    return (pVal.x < val.x) ? pVal : val;\n}\n\nfloat displacement(float primitive, float disp){\n    return primitive + disp;\n}\n\n//polynomic smooth min between two float values\nfloat blend(float p1, float p2, float k){\n    float h = clamp( 0.5+0.5*(p2-p1)/k, 0.0, 1.0 );\n    return mix(p2, p1, h ) - k*h*(1.0-h);\n}\n\nfloat sub(float p1, float p2){\n    return max(-p1, p2);\n}\n\nvec2 sceneBalls(in vec3 pos, bool refr){\n    vec2 res = vec2(TMAX, -1.0);\n \tfloat x = 0.05 * (sin(iTime + 50.0 * pos.x)  * cos(iTime + 20.0 * pos.y) * sin(iTime + 30.0 * pos.z));\n    float y = 0.04 * (cos(15.0 * sin(iTime) * pos.x) * sin(20.0 * sin(iTime) * pos.y) * sin(15.0 * sin(iTime) * pos.z));\n    float other = sphere(pos - SPHERE_POS + vec3(0.0, sin(iTime) / 2.0, cos(iTime) / 2.0), 0.1);\n    float other1 = sphere(pos - SPHERE_POS + vec3(cos(iTime) / 2.0, sin(iTime) / 2.0, 0.0), 0.1);\n    float other2 = sphere(pos - SPHERE_POS + vec3(cos(iTime) / 2.0, 0.0,  sin(iTime) / 2.0), 0.1);\n\n    res = propose(res, vec2(blend(blend(blend(sphere(pos - SPHERE_POS, SPHERE_RADIUS), other, 0.1), other1, 0.1), other2, 0.1), 3.0));\n    if(!refr){\n    \tres = propose(res, vec2(displacement(sphere(pos - vec3(2.0*SPHERE_RADIUS + 0.5, 0, 0) - SPHERE_POS, SPHERE_RADIUS), x), 1.0));\n    \tres = propose(res, vec2(displacement(sphere(pos + vec3(2.0*SPHERE_RADIUS + 0.5, 0, 0) - SPHERE_POS, SPHERE_RADIUS), y), 1.0));\n    }\n    res = propose(res, vec2(plane(pos - vec3(0, -0.5, 0)), 2.0));\n    return res;\n}\n\nfloat pawn(in vec3 pos){\n    float pawnHead = sphere(pos + vec3(0, -0.225, 0), 0.17);\n    float pawnNeck = cylinder(pos + vec3(0, 0.03, 0), 0.15, 0.01);\n    float pawnBody = cylinder(pos + vec3(0, 0.09, 0), 0.12, 0.3);\n    float pawnBase = cylinder(pos + vec3(0, 0.45, 0), 0.2, 0.05);\n    \n\treturn blend(blend(blend(pawnHead, pawnBody, 0.02), pawnNeck, 0.07), pawnBase, 0.2);\n}\n\nfloat rook(in vec3 pos){\n\tfloat rookBase = cylinder(pos + vec3(0, .43, 0), 0.25, 0.07);\n    float rookBody = cylinder(pos + vec3(0, -0.05, 0), 0.17, 0.45);\n\tfloat rookHead = cylinder(pos + vec3(0, -0.5, 0), 0.225, 0.05);\n    float rookHead2 = cylinder(pos + vec3(0, -0.5, 0), 0.205, 0.075);\n    float head = sub(rookHead2, rookHead);\n    return blend(blend(rookBody, rookBase, 0.22), head, 0.07);\n}\n\nfloat horse(in vec3 pos){\n    float horseBase = cylinder(pos + vec3(0, .43, 0), 0.25, 0.07);\n    float horseBody = cylinder(rotateX(pos + vec3(0, -0.05, 0), PI / 20.0), 0.17, 0.45);\n\tfloat horseHead = cylinder(rotateX(pos + vec3(0.0, -0.5, -0.2), PI / 2.0), 0.115, 0.175);\n    float horseEar = cylinder(rotateX(pos + vec3(0.0, -0.5, 0.12), PI / 25.0), 0.035, 0.235);\n    return blend(blend(blend(horseBody, horseBase, 0.22), horseHead, 0.25), horseEar, 0.2);\n}\n\nfloat bishop(in vec3 pos){\n\tfloat bishopBase = cylinder(pos + vec3(0, .43, 0), 0.25, 0.07);\n    float bishopBody = cylinder(pos + vec3(0, -0.05, 0), 0.12, 0.45);\n    float bishopNeck = cylinder(pos + vec3(0, -0.225, 0), 0.15, 0.01);\n\tfloat bishopHead = sphere(pos + vec3(0, -0.5, 0), 0.167);\n    float bishopHead2 = sphere(pos + vec3(0, -0.70, 0), 0.03);\n    float head = blend(bishopHead2, bishopHead, 0.01);\n    return blend(blend(blend(bishopBody, bishopBase, 0.3), bishopNeck, 0.07), head, 0.1);\n}\n\nfloat queen(in vec3 pos){\n\tfloat queenBase = cylinder(pos + vec3(0, .43, 0), 0.25, 0.07);\n    float queenBody = cylinder(pos + vec3(0, -0.05, 0), 0.12, 0.5);\n    float queenNeck = cylinder(pos + vec3(0, -0.425, 0), 0.15, 0.01);\n    float queenFace = cylinder(pos + vec3(0, -0.7, 0), 0.18, 0.05);\n    float ring = cylinder(pos + vec3(0, -0.7, 0), 0.175, 0.075);\n    queenFace = sub(ring, queenFace);\n    float queenFace2 = cylinder(pos + vec3(0, -0.6, 0), 0.14, 0.05);\n    queenFace = blend(queenFace, queenFace2, 0.17);\n\tfloat queenHead = sphere(pos + vec3(0, -0.65, 0), 0.17);\n    float queenHead2 = sphere(pos + vec3(0, -.85, 0), 0.03);\n    float head = min(queenHead2, min(queenFace, queenHead));\n    return blend(blend(blend(queenBody, queenBase, 0.3), queenNeck, 0.07), head, 0.1);\n}\n\nfloat king(in vec3 pos){\n\tfloat kingBase = cylinder(pos + vec3(0, .40, 0), 0.3, 0.08);\n    float kingBody = cylinder(pos + vec3(0, -0.25, 0), 0.15, 0.55);\n    float kingNeck = cylinder(pos + vec3(0, -0.5, 0), 0.2, 0.01);\n    float kingFace = cylinder(pos + vec3(0, -0.8, 0), 0.2, 0.1);\n    float kingFace2 = cylinder(pos + vec3(0, -0.75, 0), 0.1, 0.05);\n    float hair = cylinder(pos + vec3(0, -0.9, 0), 0.05, 0.02);\n    kingFace = blend(hair, blend(kingFace, kingFace2, 0.2), 0.1);\n    float cross1 = cylinder(pos + vec3(0, -1.01, 0), 0.01, 0.07);\n    float cross2 = cylinder(rotateX(pos + vec3(0, -1.01, 0), PI/ 2.0), 0.01, 0.07);\n\tfloat cross = min(cross1, cross2);\n    kingFace = blend(kingFace, cross, 0.001);\n    return blend(blend(blend(kingBody, kingBase, 0.3), kingNeck, 0.1), kingFace, 0.001);\n}\n\nvec2 chess(in vec3 pos, bool refr, float mat){\n    vec2 res = vec2(TMAX, -1);\n    res = propose(res, vec2(rook(pos + vec3(-0.5, 0, -3.5)), mat));\n    res = propose(res, vec2(horse(pos + vec3(-0.5, 0, -2.5)), mat));\n    res = propose(res, vec2(bishop(pos + vec3(-0.5, 0, -1.5)), mat));\n\n    res = propose(res, vec2(queen(pos + vec3(-0.5, 0, -0.5)), mat));\n    res = propose(res, vec2(king(pos + vec3(-0.5, 0, 0.5)), mat));    \n    \n    res = propose(res, vec2(bishop(pos + vec3(-0.5, 0, 1.5)), mat));\n    res = propose(res, vec2(horse(pos + vec3(-0.5, 0, 2.5)), mat));\n    res = propose(res, vec2(rook(pos + vec3(-0.5, 0, 3.5)), mat));\n    if(!refr){\n        for(int i = 0; i < 8; i++){\n            res = propose(res, vec2(pawn(pos + vec3(0.5, 0, -3.5 + float(i))), mat));\t    \n        }\n    }\n    return res;\n}\n\nvec2 map(in vec3 pos, bool refr){\n    vec2 res = vec2(TMAX, -1);\n    #if SCENE == 1\n    \treturn sceneBalls(pos, refr);\n    #elif SCENE == 2\n    \tres = propose(chess(pos + vec3(-3, 0, 0), refr, 4.0),\n                       chess(rotateY(pos, PI) + vec3(-3, 0, 0) , refr, 5.0));\n        res = propose(res, vec2(plane(pos + vec3(0, 0.5, 0)), 2.0));\n    #endif\n    return res;\n     \n}\n\nvec2 raycast(in vec3 ro, in vec3 rd, bool refr){\n    float t = TMIN;\n    float mat = -1.0;\n    for(int i = 0; i < STEPS; i++){\n    \tvec2 res = map(ro + rd * t, refr);\n        t += res.x;\n        mat = res.y;\n        if(t > TMAX || res.x < THRESHOLD) break;\n    }\n    if(t > TMAX){\n    \tmat = -1.0;\t\n    }\n    return vec2(t, mat);\n}\n\nfloat shadows(in vec3 ro, in vec3 rd){\n    float t = 0.1;\n    float res = 1.0;\n    for( int i = 0; i < 32; i++ )\n    {\n\t\tfloat h = map(ro + rd * t, false).x;\n        res = min(res, 16.0 * h / t);\n        t += clamp(h, 0.01, 0.10);\n        if(t > 2.5 || h < THRESHOLD) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos){\n    vec3 eps = vec3(0.01, 0, 0);\n    // calc normal via gradient calculation using map to get points very close to pos on the surface\n    vec3 nor;\n    nor.x = map(pos+eps.xyy, false).x - map(pos-eps.xyy, false).x;\n    nor.y = map(pos+eps.yxy, false).x - map(pos-eps.yxy, false).x;\n    nor.z = map(pos+eps.yyx, false).x - map(pos-eps.yyx, false).x;\n    return normalize(nor);\n}\n\nfloat pointLightDiffuse(vec3 nor, vec3 pos, vec3 lightPos, vec3 f){\n    vec3 toLight = normalize(lightPos - pos);\n    float dist = length(lightPos - pos);\n    float atten = min(1.0, 1.0/(dot(f, vec3(1.0, dist, dist * dist))));\n    return clamp(dot(nor, toLight), 0.0, 1.0) * atten;\n}\n\nfloat pointLightSpec(vec3 nor, vec3 pos, vec3 lightPos, vec3 f, vec3 rd, float shiny){\n    vec3 toLight = normalize(lightPos - pos);\n    float dist = length(lightPos - pos);\n    float atten = min(1.0, 1.0/(dot(f, vec3(1.0, dist, dist * dist))));\n    return clamp(pow(clamp(dot(reflect(rd, nor), toLight), 0.0, 1.0), shiny), 0.0, 1.0) * atten;\n}\n\nfloat dirLightDiffuse(vec3 nor, vec3 lightDir){\n    return clamp(dot(nor, lightDir), 0.2, 1.0);\n}\n\nfloat dirLightSpec(vec3 nor, vec3 lightDir, vec3 rd, float shiny){\n\treturn clamp(pow(clamp(dot(reflect(rd, nor), lightDir), 0.0, 1.0), shiny), 0.0, 1.0);    \n}\n\nvec3 getColor(vec3 pos, vec3 nor, vec3 rd, float mat){\n    vec3 lightPos = vec3(POINT_LIGHT.x * cos(0.5 * iTime), POINT_LIGHT.y, POINT_LIGHT.z * sin(0.5 * iTime));\n    vec3 toLight = normalize(lightPos - pos);\n\tvec3 toDirLight = normalize(vec3(10, 10, 10));\n    \n    vec3 col = vec3(0);\n    vec3 diffuseCol = vec3(0);\n    if(mat == 1.0){\n        vec2 uv = vec2(atan(nor.x, nor.z), acos(nor.y));\n    \tvec3 tex = (texture(iChannel0, uv).xyz);\n        diffuseCol = tex;\n    }\n    else if(mat == 2.0){\n        float floor = mod(floor(pos.x) + floor(pos.z), 2.0);\n\t\tdiffuseCol = mix(GROUND_COLOR_1, GROUND_COLOR_2, floor);\n    }\n    else if(mat ==3.0){\n        diffuseCol = SPHERE_DIFFUSE_RED;\n        vec2 uv = vec2(atan(nor.x, nor.z), acos(nor.y));\n        nor += texture(iChannel2, uv).xyz;\n        nor = normalize(nor);\n    }\n    else if(mat == 4.0){\n        vec2 uv = vec2(atan(nor.x, nor.z), acos(nor.y));\n        vec3 tex = (texture(iChannel3, uv).xyz);\n        diffuseCol = 1.0 * tex + 0.0 * vec3(1, 1, 1);\n        nor += tex;\n        nor = normalize(nor);\n    }\n    else if(mat == 5.0){\n    \tvec2 uv = vec2(atan(nor.x, nor.z), acos(nor.y));\n        vec3 tex = (texture(iChannel0, uv).xyz);\n        diffuseCol = 1.0 * tex + 0.0 * vec3(1, 1, 1);\n        nor += tex;\n        nor = normalize(nor);\n    }\n    else{\n        diffuseCol = texture(iChannel1, rd).xyz;\n        return diffuseCol;\n    }\n    vec3 atten = vec3(1, 0.25, 0.05);\n    #if SCENE == 2\n    \tatten = vec3(1, 0, 0);\n    #endif\n    float pld = pointLightDiffuse(nor, pos, lightPos, atten) * shadows(pos, normalize(lightPos - pos));\n    float pls = pointLightSpec(nor, pos, lightPos, atten, rd, 20.0);\n\n    float dld = dirLightDiffuse(nor, toDirLight) * 0.3 * shadows(pos, toDirLight);\n    float dls = dirLightSpec(nor, toDirLight, rd, 20.0);\n    \n    col += vec3(0.07,0.07,0.07);\n    col += pld*diffuseCol;\n    col += pld*pls;\n    col += dld*diffuseCol;\n    col += dld*dls;\n\treturn col;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n\tvec2 res = raycast(ro, rd, false);\n    vec3 pos = ro + rd * res.x;\n    vec3 nor = normal(pos);\n    vec3 col = vec3(0);\n    col = getColor(pos, nor, rd, res.y);\n    \n    #if SCENE == 1\n        if(res.y != 1.0){\n            for(int i = 0; i < 1; i++){\n                rd = reflect(rd, nor);\n                res = raycast(pos + rd * 0.001, rd, false);\n                pos = ro + rd * res.x;\n                nor = normal(pos);\n                col += getColor(pos, nor, rd, res.y) * pow(0.33, float(i + 1)); \n            }\n        }\n        else{\n            rd = refract(rd, nor, 0.9);\n            res = raycast(pos + rd * 0.001, rd, true);\n            pos = ro + rd * res.x;\n            nor = normal(pos);\n            col += getColor(pos, nor, rd, res.y) * 0.33;\n        }\n    #endif\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float yaw = mouse.x * 2.0 * PI;\n    float pitch = 0.7 + mouse.y * PI / 4.0;\n    vec3 zoom = vec3(1.8, 1.5, 1.8);\n    #if SCENE == 2\n\t    zoom = vec3(7.0, 2.5, 7.0);\n    #endif\n   \tvec3 eye = vec3(zoom.x * cos(yaw - iTime * 0.1) * sin(pitch), zoom.y * cos(pitch), zoom.z * sin(yaw - iTime * 0.1) * sin(pitch)); // world space camera location\n    vec3 look = SPHERE_POS;\n\tvec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n\tfloat d = 1.3; // distance between eye and focal plane\n    \n    vec3 w = normalize( look - eye);\n\tvec3 u = normalize( cross(w,up) );\n\tvec3 v = normalize( cross(u,w) );\n\n    vec3 col = vec3(0.0);\n    float numSamples = 4.0;\n    bool stop = false;\n    for(float i = 0.0; i < 1.0; i+=0.5){\n        for(float j = 0.0; j < 1.0; j+=0.5){\n            vec2 uv = (fragCoord.xy + vec2(i, j))/iResolution.xy;\n            vec2 p = -1.0+2.0*uv; // pixel space of the focal plane\n            p.x *= iResolution.x/iResolution.y;\n            vec3 rd = normalize( p.x*u + p.y*v + d*w );\n            col += render( eye, rd );\n            #if SCENE == 2\n                numSamples = 1.0;\n                stop = true;\n                break;\n            #endif\n        }\n        if(stop) break;\n    }\n    col /= numSamples;\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.7));\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}