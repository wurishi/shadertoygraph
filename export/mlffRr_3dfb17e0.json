{"ver":"0.1","info":{"id":"mlffRr","date":"1692844943","viewed":22,"name":"Bolinha Pinga","username":"Petkovicc","description":"Bolinha que pinga no seno e cosseno","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// o componente mainImage é a função principal do shader, ela é a responsavel por renderizar o que queremos visualizar na tela.\n// out vec4 fragColor é uma variavel de saida que comporta RGBA, podemos fazer o armazenamento da cor final do pixel através dela\n// in vec2 fragCoord é uma variavel de entrada que determina o X e Y dos meus pixeis\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Definir a resolução da tela\n    vec2 resolution = iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //Iresolution é uma variavel pronta do shadertoy, ela permite armazenar a resolução da tela em pixels para manipulação\n    // A normalização se faz necessária para que a textura não se distorça na tela na qual está sendo renderizada\n    \n    // Dividir a tela em 4 partes na vertical para background\n    vec2 uv = fragCoord.xy / resolution.xy;\n    \n    \n    // Definir cores para cada parte\n    vec3 colorBottom = vec3(0.0, 0.0, 0.2) + 0.1 * cos(iTime + uv.xyx + vec3(0, 0, 0));  // Azul Escuro\n    vec3 colorMiddleBottom = vec3(0.0, 0.0, 0.5) + 0.2 * cos(iTime + uv.xyx + vec3(0, 0, 0));  // Azul Escuro\n    vec3 colorMiddleTop = vec3(0.0, 0.0, 0.9) + 0.3 * cos(iTime + uv.xyx + vec3(0, 0, 0));  // Azul Escuro\n    vec3 colorTop = vec3(1.0, 1.0, 0.0);       // Amarelo\n    \n   // Adicionar ondulações no eixo Y usando a função seno (sin)\n   // Calcular os deslocamentos para cada quadrante\n    float yOffsetBottom = 0.8 * sin(uv.x * 04.0 + iTime*3.0); // quebra o quadrante debaixo para simular plataforma\n    float yOffsetMiddleBottom = 0.1 * sin(uv.x *2.0 + iTime*3.0);\n    float yOffsetMiddleTop = 0.0 * sin(uv.x * 1.0 + iTime*3.0);\n    float yOffsetTop = 0.05 * cos(uv.x * 15.0+ iTime*3.0);\n    \n    // Verificar se o fragmento está no quadrante inferior esquerdo\n    bool isBottomLeft = uv.x < 0.5 && uv.y < 0.7;\n\n    // Definir a cor da bolinha \n    vec3 ballColor = vec3(1.0, 0.0, 0.0);\n    \n    // Adicionar uma bolinha no quadrante inferior esquerdo\n    if (isBottomLeft) {\n    \n    // Calcular a posição da bolinha com base na função seno\n    vec2 ballPosition = vec2(0.14 + 0.1 * sin(iTime * 0.0), 0.39 -0.1 * cos(iTime * 3.0));\n\n      // Calcular a distância do fragmento ao centro da bolinha\n       float ballDistance = length(uv - ballPosition);\n\n        // Definir o raio da bolinha\n        float ballRadius = 0.05;\n    \n    // Verificar se o fragmento está dentro do raio da bolinha\n    if (isBottomLeft && ballDistance < ballRadius) {\n        // Definir a cor do fragmento como a cor da bolinha\n        fragColor = vec4(ballColor, 1.0);\n        return;\n    }\n\n    }\n    \n    \n    if (uv.y < 0.25) {\n        uv.y += yOffsetBottom;\n    } else if (uv.y >= 0.25 && uv.y < 0.5) {\n        uv.y += yOffsetMiddleBottom;\n    } else if (uv.y >= 0.5 && uv.y < 0.6) {\n        uv.y += yOffsetMiddleTop;\n    } else {\n        uv.y += yOffsetTop;\n    }\n    \n        // Definir a cor final com base na posição vertical\n    vec3 finalColor;\n    if (uv.y < 0.25) {\n        finalColor = colorBottom;\n    } else if (uv.y >= 0.25 && uv.y < 0.5) {\n        finalColor = colorMiddleBottom;\n    } else if (uv.y >= 0.5 && uv.y < 0.75) {\n        finalColor = colorMiddleTop;\n    } else {\n        finalColor = colorTop;\n    }\n\n    // Definir a cor final do pixel\n    fragColor = vec4(finalColor, 1.0);\n    \n\n}\n\n    //vec3 colorBottom = vec3(0.0, 0.0, 0.5) + 0.09 * cos(iTime + uv.xyx + vec3(0, 0, 0));  // Azul Escuro\n    //vec3 colorMiddleBottom = vec3(0.0, 0.0, 0.5) + 0.12 * cos(iTime + uv.xyx + vec3(0, 0, 0));  // Azul Escuro\n","name":"Image","description":"","type":"image"}]}