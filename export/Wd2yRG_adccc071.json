{"ver":"0.1","info":{"id":"Wd2yRG","date":"1586861902","viewed":368,"name":"[strobe] checkertrip","username":"HaleyHalcyon","description":"#","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\nconst float PI_2 = PI / 2.;\n\nfloat fold(float x) {\n    return abs(mod(x, 2.0) - 1.0);\n}\n\nfloat smoothThres(float x, float strength) {\n    return smoothstep(0.5 - strength, 0.5 + strength, x);\n}\n\nfloat smoothFold(float x, float strength) {\n    return smoothThres(fold(x), strength);\n}\n\nfloat lineTest(vec2 pos, float angle) {\n    return\n        dot(\n            pos\n          , vec2(cos(angle),sin(angle))\n        );\n}\n\nfloat grid(vec2 uv, float size, float angle, float smoothing) {\n    float stripe1 = lineTest(uv * size, angle);\n    float stripe2 = lineTest(uv * size, angle + PI_2);\n    \n    return smoothThres(fold(1.0 * stripe1 + 0.) + fold(1.0 * stripe2 + 1.) - 0.5, smoothing);\n}\n\nfloat grid2(vec2 uv, float size, float angle, float smoothing){\n    float distZag = (0.4 * size * log(uv.x*uv.x+uv.y*uv.y));\n    float angleZag = (12. * (atan(uv.y, uv.x) / PI + angle));\n    return smoothThres(min(fold(1.0 * distZag) , fold(1.0 * angleZag)), smoothing)\n           + \n          smoothThres(min(1.0 - fold(1.0 * distZag) , 1.0 - fold(1.0 * angleZag)), smoothing)\n        ;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    // Normalized pixel coordinates\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= iResolution.xy / scale / 2.;\n    uv *= 2.;\n    float dist = log(uv.x*uv.x+uv.y*uv.y);\n    float angle = atan(uv.y, uv.x) / PI;\n    \n    float sB = 3.;      // size base\n    float sO = 0.;\t\t// size offset\n    float sF = 5.0;     // size frequency\n    float sA = 1.5;\t\t// size amplitude\n    float sSO = 0.02;   // size strobe offset\n    float sSF = 1.4;  // size strobe frequency\n    float sSM = 0.5;\t// size strobe smoothness\n    float sSA = 1.0;\t// size strobe amplitude\n    \n    float aB = -0.3;\t// angle base\n    float aO = 0.2;\t\t// angle offset\n    float aF = 1.5;\t// angle frequency\n    float aA = 1.2;\t\t// angle amplitude\n    float aSO = 0.0;\t// angle strobe offset\n    float aSF = 0.84;\t// angle strobe frequency\n    float aSA = 0.8;\t// angle strobe amplitude\n    \n    float gSize = sB * (1.0 + fract((sO + t) * sF) * sA + smoothFold((sSO + t) * sSF, sSM) * sSA);\n    float gAngle = aB + PI * aA * (aO * fract(t * aF)) - floor((aSO + t) * aSF) * aSA;\n\n    // Time varying pixel color\n    float ring = smoothFold(dist * 2.0 + t * 6.0 + smoothFold(t * 3.0, 0.5), 0.5);\n    float spiral = smoothFold(dist * 0.80 + angle * 1. + t * 3. + PI, 0.2);\n    \n    float grid2use = smoothThres(fract(t*1.5) + 0.25, 0.01);\n    float v = grid2use * grid(uv, gSize, gAngle, 0.05) + (1. - grid2use) * grid2(uv, gSize, gAngle, 0.05);\n    \n    vec3 colA0 = vec3(1.0, 0.3, 0.8);\n    vec3 colA1 = vec3(0.6, 0.2, 0.0);\n    vec3 colB0 = vec3(0.0, 0.8, 1.0);\n    vec3 colB1 = vec3(0.0, 0.1, 0.7);\n    \n    vec3 colRing = vec3(0.2);  \n    \n    \n    vec3 col = (spiral * (v * colA0 + (1. - v) * colA1) +\n        (1. - spiral) * (v * colB0 + (1. - v) * colB1) +\n        colRing * (2.0 * ring - 1.0))\n        * (.3 + smoothFold(t * 30., 0.1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}