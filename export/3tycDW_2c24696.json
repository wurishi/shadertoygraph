{"ver":"0.1","info":{"id":"3tycDW","date":"1611157869","viewed":329,"name":"Octopi","username":"miczac","description":"My first shader in Shadertoy! Each tentacle is a single sdf with spline interpolation.\nThe trail is generated in Buff B.\nI rendered this in 360 with spatial sound and uploaded in on YT: https://youtu.be/te4WrShe0VE","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["water","animation","tentacles","octopus"],"hasliked":0,"parentid":"wd3BzS","parentname":"fish tank_4SB"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Octo\n{\n    int id;\n    float dist;\n    vec3 color;\n    vec3 surf;\n    vec3 norm;\n    vec3 head_pos;\n};\n    \n\nfloat octo_motion(int id, float center_dist)\n{\n    float ampli = Amplitudes[id]*100.;\n    float tenta_attach = smoothstep(0.4, 0.,center_dist)*0.2;\n    float tenta_end = smoothstep(-0.2, 0.2,center_dist)*0.4+smoothstep(0., 0.2,center_dist)*0.4;\n   \n    return (sin(center_dist*TWOPI-ampli*0.25)*0.5+0.5)*center_dist+tenta_attach-tenta_end;\n}\n\nvec3 octo_light(Octo octo, vec3 rd, vec3 tcol)\n{\n    vec3 surf = octo.surf, head_pos = octo.head_pos, normal = octo.norm, color = octo.color;\n\n    vec3 rp = surf - head_pos;\n    vec3 col = vec3(0);\n    \n    vec3  r  = reflect(rd, -normal);\n   \n    float fr = clamp(1. - dot(normal, -rd), 0., 1.);\n\n    float ambient = clamp(0.5 + 0.5 * normal.y, 0.0, 1.0);\n    float diffuse = clamp(dot(normalize(vec3(0,1,0)), normal), 0.0, 1.0);\n    vec3 half_way = normalize(-rd + normalize(vec3(0,1,0)));\n    float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 0.5);\n        \n\n    col = ambient * color ;\n    col += diffuse *tcol ;\n    col += diffuse * specular * color;\n    \n    // transparency and light mix\n    col = mix(tcol, col, 0.5);\n\n\n    return col;\n}\n\n\nvec4  sdOctopusMotion(vec3 p, int id)\n{\n\tfloat center_dist = 0.;\n    vec3 point = vec3(0);\n\tvec3 motion_dir = rope(p,id,POSITION_TRAIL, center_dist, point);\n    float len = 0.6;\n\n    float angle  = octo_motion(id, center_dist );\n    vec3 octo_head = texelFetch(POSITION_TRAIL,ivec2(0,id),0).xyz; \n    vec2 octopus = sdOctopus(p-octo_head,  normalize(motion_dir), angle, 8.,len, TENTACLE_THICK, id);\n    vec4 res = vec4(octopus.x, float(id), octopus.y, center_dist);\n    return res;\n}\n\n               \n\nvec3 normal_octopus(vec3 p, int id, vec3 pos)\n{\n const vec2 eps = vec2(1e-1, 0);\n    const vec2 eps2 = vec2(1e-3, 0);\n    float  smooth_head = smoothstep( 0.,0.5,length(p-pos));\n    return normalize(vec3(sdOctopusMotion(p + eps.xyy,id).x + bump(p + eps2.xyy, iChannel3, pos)*smooth_head - sdOctopusMotion(p - eps.xyy,id).x - bump(p - eps2.xyy, iChannel3, pos)*smooth_head,\n                          sdOctopusMotion(p + eps.yxy,id).x + bump(p + eps2.yxy, iChannel3, pos)*smooth_head - sdOctopusMotion(p - eps.yxy,id).x - bump(p - eps2.yxy, iChannel3, pos)*smooth_head,\n                          sdOctopusMotion(p + eps.yyx,id).x + bump(p + eps2.yyx, iChannel3, pos)*smooth_head - sdOctopusMotion(p - eps.yyx,id).x - bump(p - eps2.yyx, iChannel3, pos)*smooth_head));\n}\n\nbool probe_and_update(vec3 ro, vec3 rd)\n{\n    //returns true if no spheret is hit, also updates spherets pos\n    bool no_hit = true;\n    float radius = SPHERET_RADIUS;\n    for(int id = 0; id < NUMBER_OF_OBJECTS; id++)\n    {\n        //cell after position trail\n        //reports normalized tail position, not affected by speed\n        vec3 spheret = texelFetch(POSITION_TRAIL, ivec2(0, id), 0).xyz;\n        //set spheret pos in array for others to use\n        Spherets[id] = spheret;\n        Amplitudes[id] = texelFetch(iChannel0, ivec2(0,id),0).w;\n        float hit = sphIntersect( ro, rd, vec4(spheret, radius) );\n    \tif( hit>0.0 && hit < 100.  ) //OPTIMIZE do I need to add hit < MAX_DIST?\n        {\n            Spheret_no_hit[id] = false;\n            no_hit = false;\n        }\n    }\n    return no_hit;\n}\n\nvec2 map_octopus(vec3 p)\n{\n    vec2 res = vec2(1000., -1.);\n    for(int id = 0; id < NUMBER_OF_OBJECTS; id++)\n    {\n        if(Spheret_no_hit[id]) continue;\n        vec2 octopus = sdOctopusMotion(p,id).xy;\n        res  = opU(res,octopus);\n    }\n    return res;\n}\n   \nOcto intersect_octopus(in vec3 ro, in vec3 rd)\n{\n    Octo octo;\n    octo.id = -1;\n    float dist = SURF_DIST;\n    for(int i = 0; i < 64; i++)\n    {\n        vec3 p = ro+rd*dist;\n        vec2 hit = map_octopus(p);\n        octo.id = int(hit.y+0.5);\n        octo.color = octo_colors[octo.id];\n        octo.surf = p;\n        octo.dist = dist;\n        octo.head_pos = texelFetch(POSITION_TRAIL,ivec2(0,octo.id),0).xyz;\n        if(abs(dist) < SURF_DIST || dist > MAX_DIST)\n        {\t\n            octo.id = -1;\n            break;\n        }\n        dist += hit.x;\n    }\n    return octo; \n}\n\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    bool no_hit = probe_and_update(ro,rd); \n    vec2 rd_uv = vec2((atan(rd.z, rd.x) / (2. * PI)) + 0.5, acos(-rd.y) / PI);\n    vec3 col;\n\n    if(no_hit) return texture(iChannel2,rd_uv).xyz;\n    Octo octo = intersect_octopus(ro, rd);\n\n    octo.norm = normal_octopus(octo.surf, octo.id, octo.head_pos);\n    if(octo.id>-1)\n    {\n        vec3 bg = texture(iChannel2,rd_uv).xyz;\n        vec2 rd_text = reflect(rd_uv, octo.norm.xy);\n        vec3 tcol = texture(iChannel2,rd_text).xyz;//TWEAK color and text\n        col = octo_light(octo, rd, tcol); \n        \n        //col *= text;\n    }else\n    {\n        col =texture(iChannel2,rd_uv).xyz;\n    }\n    \n    \n    return col;\n}\n\nmat3 camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 f = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);//camera rot\n\tvec3 r = normalize( cross(f,cp) );\n\tvec3 u =          ( cross(r,f) );\n    return mat3( r, u, f );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2  uv = ((fragCoord-0.5*iResolution.xy)/iResolution.y)*2.;\n    uv = uv + 0.021*water_noise(vec3(uv,1), iTime).xy;\n    vec3  ro =  vec3(cos(iTime*0.1),0.,sin(iTime*0.1));\n    ro.xz *= 3.4;\n\n    vec3  lookat = vec3(0);\n    mat3 cam = camera(ro, lookat,0.); \n    vec3  rd = cam * normalize(vec3(uv,1.));\n\tvec3 result = render(ro,rd);  \n\tfragColor = vec4(result,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ROPE_POINTS 30\nconst float fROPE_POINTS = float(ROPE_POINTS);\n#define NUMBER_OF_OBJECTS 5\nconst float fNUMBER_OF_OBJECTS = float(NUMBER_OF_OBJECTS);\n#define TWOPI 6.283185\n#define PI 3.14159265359\n\n//how many envelopes per octopus (pseudo-randomness)\n#define POLIPHONY 3\n\n#define POSITION_TRAIL iChannel1\n#define WATER_NOISE_SCALE 1.\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n#define SPHERET_RADIUS 1.\n#define TENTACLE_THICK 0.04\n\n\nvec3 octo_colors[NUMBER_OF_OBJECTS] = vec3[NUMBER_OF_OBJECTS](vec3(0.498,0.667,0.722), \n                                                              vec3(0.451,0.431,0.667), \n                                                              vec3(0.718,0.557,0.722),\n                                                              vec3(0.412,0.518,0.690),\n                                                              vec3(0.565,0.714,0.686));\n\nvec3  Spherets[NUMBER_OF_OBJECTS] = vec3[NUMBER_OF_OBJECTS](vec3(0),vec3(0),vec3(0),vec3(0),vec3(0));\nbool  Spheret_no_hit[NUMBER_OF_OBJECTS] = bool[NUMBER_OF_OBJECTS](true, true, true, true, true);\n//amplitude values mapping : vec3(current_max_amplitude, slide_max_amplitude, fade_outs, accum fade_outy)\nfloat  Amplitudes[NUMBER_OF_OBJECTS] = float[NUMBER_OF_OBJECTS](0.,0.,0.,0.,0.);  \n\nvec3 Envelope_freq[NUMBER_OF_OBJECTS] = vec3[NUMBER_OF_OBJECTS](vec3(0.01,0.05,0.03),\n                                                                vec3(0.02,0.032,0.125),\n                                                                vec3(0.0565,0.07874,0.0454),\n                                                                vec3(0.0201657,0.0157484,0.1875),\n                                                                vec3(0.03245,0.025458,0.0454541));\n\n\n\n\n/*\n=================================================================================\nUTILITIES & NOISE\n=================================================================================\n*/\n\n//water noise by Fabrice Neyret:https://www.shadertoy.com/view/MdlGDM\n\n//water noise\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n              \nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash1(n+  0.0), hash1(n+  1.0),f.x),\n                        mix( hash1(n+ 57.0), hash1(n+ 58.0),f.x),f.y),\n                    mix(mix( hash1(n+113.0), hash1(n+114.0),f.x),\n                        mix( hash1(n+170.0), hash1(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n    return f;\n}\n\n\nvec3  water_noise(vec3 p, float time)\n{\n    p = 4.*p+time*(.1,.7,1.2);\n\tfloat x = fbm(p);\n\treturn .5+.5*sin(x*vec3(30.,20.,10.));\n}\n\n\n//spline interpolation function to connect points across tentacle \n//from : http://sol.gfxile.net/interpolation/\nvec3 catmullrom(float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n\treturn 0.5 * (\n\t\t\t\t(2. * p1) +\n\t\t\t\t(-p0 + p2) * t +\n\t\t\t\t(2. * p0 - 5. * p1 + 4. * p2 - p3) * t * t +\n\t\t\t\t(-p0 + 3. * p1 - 3. * p2 + p3) * t * t * t\n\t\t\t\t);\n}\n\nmat3 rotAxis(vec3 axis, float a) \n{\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n//IQ union function, smin, smax\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat smin( float a, float b, float k ) \n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// mod for integers\nint modI(int a, int b)\n{\n\treturn int(mod(float(a), float(b)) + 0.5);\n}\n\n//slide for buffer values\nfloat slide(float cur, float tar, float slu, float sld)\n{\n    //slide up or slide down\n    float del = (tar>cur) ?  slu : sld;\n \tcur += (tar - cur) * del;\n    return    cur;\n}\n\n\n\n/*\n========================================================================================\nDISTANCE FUNCTIONS\n========================================================================================\n*/\n\n//this is probably the most relevant function in this shader: it allows for smooth interpolation\n//between points in a sdf (e.g. capsule), it gets its points from a row of pixels stored and \n//continuisly updating in buffer B. For this  to work the object needs to be moving, if slightly, at all times\nvec3 rope(vec3 p, int id, in sampler2D text,  out float center_dist, inout vec3 point)\n{\n    vec3  rope_head   = texelFetch(text, ivec2(0, id ), 0).xyz;\n    vec3  rope_tail   = texelFetch(text, ivec2(ROPE_POINTS-1, id ), 0).xyz;\n    float speed       = 1.+(length(rope_head - rope_tail))*.3;//TWEAK\n\n    //since the distance from the beginning of the rope changes based on object speed\n    //attentuate this undesired effect\n    center_dist = clamp(length(p-rope_head),0.,1.)/speed;\n\n    //pick previous position based on how distant p is from the current position\n    int   point_coo    = int(floor(center_dist*(fROPE_POINTS-3.)));\n    float interp_index = fract(center_dist*(fROPE_POINTS-3.));\n    vec3  rope_point_0 = texelFetch(text, ivec2(point_coo+0, id ), 0).xyz;\n    vec3  rope_point_1 = texelFetch(text, ivec2(point_coo+1, id ), 0).xyz;\n    vec3  rope_point_2 = texelFetch(text, ivec2(point_coo+2, id ), 0).xyz;\n    vec3  rope_point_3 = texelFetch(text, ivec2(point_coo+3, id ), 0).xyz;\n    vec3  point_ahead  = catmullrom(interp_index, rope_point_0, rope_point_1, rope_point_2, rope_point_3);\n    vec3  point_behind = catmullrom(interp_index-0.051, rope_point_0, rope_point_1, rope_point_2, rope_point_3);\n\tpoint = rope_point_3;//output middle point on rope\n    vec3  motion_dir    = point_behind -point_ahead  ;\t\n\n    \n    return motion_dir;\n}\n\n//IQ \nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n//octopus\n\nfloat sdOctoHead(vec3 p, vec3 motion_dir, float thick)\n{\n    vec3 position_front = vec3(0);\n    vec3 position_back = -motion_dir*0.3;\n    float capsule = sdCapsule(p, position_back,position_front, thick+0.11);\n    float inner = length(p - -motion_dir*0.6) - (thick+0.45);\n    float head = max(capsule,-inner);\n    return head;\n    \n}\n\n\nvec2 sdOctopus(vec3 p, vec3 motion_dir, float angle,  float rays, float len, float thick, int note_id)\n{\n\tfloat p_angle = 6.283185/rays;\n\tvec3  q = p;\n\tfloat dist = 300.;\n\tfloat id = -1.;\n\tvec2 res = vec2(dist, id);\n\t//tentacles\n\tfor(int tentacle_id = 0 ; tentacle_id < int(rays+0.5); tentacle_id++)\n\t{\n\t\tvec3  position_front =  vec3(0);\n\t\t\n\t\tvec3  displaced_pos = normalize(motion_dir+vec3(2.));\n\t\tvec3  position_back = normalize(cross( -motion_dir, displaced_pos));\n\t\tposition_back += -motion_dir * length(p);\n        //displace each tentacle around the center in the direction of the motion \n\t\tposition_back = normalize(position_back)*rotAxis(motion_dir, p_angle*float(tentacle_id));\n\t\t\n        //this produces fluctuating tentacle motion \n\t\tposition_back = mix( -motion_dir,position_back,angle );\n\t\tfloat capsule = sdCapsule(q, position_back,position_front, thick);\n\t\tfloat tenta = smax(capsule, length(p)-1., 32./200.);\n\t\tfloat len_from_ctr = clamp(length(p), 0., 0.8);\n\t\tvec2 current = vec2(tenta, float(tentacle_id)); \n\t\tres = opU(current,res);\n\t}\n    //head\n    {\n  \t\tfloat head = sdOctoHead(q,motion_dir, thick);\n        float connect = smin(head, res.x, 32./200.);\n        vec2 current = vec2(connect,float(id));\n        res = opU(res,current);\n\n    }\n\treturn res;\n\t\n}\n\n\n\n\n\n//https://www.shadertoy.com/view/3tXXRn\nfloat bump(vec3 p, sampler3D text, vec3 pos)\n{\n    p -= pos;\n    float f = 0.;\n    // FBM\n    for(int i = 0; i < 3; ++i)\n    \tf += textureLod(text, p * exp2(float(i)), 0.).r / exp2(float(i) + 1.);\n    return f * (1. - smoothstep(1.3, 1.5, length(p))) * 1.5;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sawtooth(ivec2 coo)\n{\n   float  freq = Envelope_freq[coo.y][coo.x];\n   \n   return 1.-fract(freq*iTime);   \n}\n\nfloat max_envelope(int note_id)\n{\n    return\tmax(texelFetch(iChannel0, ivec2(0,note_id), 0).y,\n    \t\tmax(texelFetch(iChannel0, ivec2(1,note_id), 0).y,\n                texelFetch(iChannel0, ivec2(2,note_id), 0).y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n\t=====================================================================\n\tenvelope generator\n\t=====================================================================\n\toutput: one row for each octopus, three cells per object (POLIPHONY value)\n\tTo generate a pseudo-random motion each octopus has 3 envelopes associted to it\n    each envelope fades at a constant rate even though they have different frequencies\n    \n    \t*/\n\n    ivec2 iCoo = ivec2(fragCoord);\n    if(iCoo.x >= POLIPHONY || iCoo.y >=  NUMBER_OF_OBJECTS) discard; \n    //generate sawtooth at different rates based on freq array\n    float new_sawtooth_val = sawtooth(iCoo);\n    float previous_sawtooth_val = texelFetch(iChannel0,iCoo,0).x;\n    bool is_new       = new_sawtooth_val > previous_sawtooth_val;\n    //constant rate decay for each sawtooth envelope\n    float previous_ramp = texelFetch(iChannel0, iCoo, 0).y;\n    float decay_rate = 0.01;\n    //if not a new trigger then slide to 0\n    float new_ramp = is_new ? 1. : slide(previous_ramp,0.,1.,decay_rate);\n    //on cell(0,y) save current max envelope and accumulated max_envelope value\n    if(iCoo.x == 0) \n    {\n        float current_max_env = max_envelope(iCoo.y); \n        fragColor.z =  current_max_env;\n        fragColor.w = texelFetch(iChannel0, iCoo,0).w + current_max_env*0.01+iTimeDelta*0.1;\n    }\n    fragColor.xy = vec2(new_sawtooth_val,new_ramp);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 set_path(int id, float accum_val)\n{\n\n    float fid = float(id);\n    vec3 circle = vec3(cos(accum_val*TWOPI),\n                      fid/fNUMBER_OF_OBJECTS-0.5,sin( accum_val*TWOPI)) ;\n    return circle*vec3(2,4,1);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoo = ivec2(fragCoord);\n    /*\n\teach row is of lenght ROPE_POINTS \n\tchannels :  xyz is object postion trail's xyz\n    */\n\tif(iCoo.x >= ROPE_POINTS || iCoo.y >=  NUMBER_OF_OBJECTS) discard; \n \n    if(iCoo.y<NUMBER_OF_OBJECTS)\n    {\n        if(iCoo.x == 0) \n        {\n             //retrieve accumuluted value on cell (0, y) for uninterrupted motion\n            float accum_val = texelFetch(iChannel0, ivec2(0, iCoo.y), 0).w;\n            fragColor = vec4(set_path(iCoo.y, accum_val*0.5), 0);\n        }\n        //only set cell (0,y) else read the prvious cell\n        else \n        {\n            fragColor.xyz = texelFetch(iChannel1, iCoo - ivec2(1,0), 0).xyz;\n        }\n        \n    }\n\n}\n","name":"Buffer B","description":"","type":"buffer"}]}