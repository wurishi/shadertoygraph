{"ver":"0.1","info":{"id":"MsVSWK","date":"1466729191","viewed":802,"name":"Ictalurus Forest","username":"Nimajamin","description":"Ictalurus Forest\n\n(click &amp; drag mouse to move around the nebula)\n\nhttps://soundcloud.com/ngc4244/ictalurus \n","likes":13,"published":1,"flags":64,"usePreview":0,"tags":["procedural","sound","time","music","space","volumetric","nebula","soundcloud","ictalurus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsf3Wf","filepath":"https://soundcloud.com/ngc4244/ictalurus","previewfilepath":"https://soundcloud.com/ngc4244/ictalurus","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -------------------------------------------------------------\n//\n// \"Ictalurus Forest\" by Nimajamin 24 June 2016\n//\n// -------------------------------------------------------------\n//\n// 3 Pass re-implementation of Star Nest by Pablo RomÃ¡n Andrioli\n//\n// Originally implemented by Shadertoy member: Kali \n//\n// - https://www.shadertoy.com/view/XlfGRj\n//\n// This content is under the MIT License.\n//\n// -------------------------------------------------------------\n//\n// Noise fix implemented by: huwb \n//\n// - https://www.shadertoy.com/view/XllGzN\n//\n// -------------------------------------------------------------\n//\n// Audio visualisation sampling code by: chronos\n//\n// - https://www.shadertoy.com/view/lsdGR8\n//\n// -------------------------------------------------------------\n//\n// Soundtrack - \"Ictalurus Forest\" Nimajamin 2016 [ ngc4244 ]\n//\n// -------------------------------------------------------------\n\n\n// 1st Pass - Nebula..\n\n#define iterations1 27\n#define formuparam1 0.45\n\n#define volsteps1 20\n#define stepsize1 0.1\n\n#define zoom1   0.800\n#define tile1   0.850\n#define speed1  0.0003330 \n\n#define brightness1 0.0015\n#define darkmatter1 0.9300\n#define distfading1 0.730\n#define saturation1 0.850\n\n#define kContrast1 1.0\n#define kBrightness1 -0.2\n#define kSaturation1 0.70\n\n// 2nd Pass - Large Stars..\n\n#define iterations2 7\n#define formuparam2 0.33\n\n#define volsteps2 20\n#define stepsize2 0.1\n\n#define zoom2   0.400\n#define tile2   0.850\n#define speed2  0.010 \n\n#define brightness2 0.0015\n#define darkmatter2 0.300\n#define distfading2 0.730\n#define saturation2 0.850\n\n#define kContrast2 1.0\n#define kBrightness2 0.0\n#define kSaturation2 0.0\n\n// 3rd Pass - Black Holes..\n\n#define iterations3 7\n#define formuparam3 0.83\n\n#define volsteps3 20\n#define stepsize3 0.1\n\n#define zoom3   0.800\n#define tile3   0.850\n#define speed3  0.010 \n\n#define brightness3 0.0015\n#define darkmatter3 0.300\n#define distfading3 0.730\n#define saturation3 0.850\n\n#define kContrast3 1.0\n#define kBrightness3 0.0\n#define kSaturation3 0.0\n\n// RGB Eye response..\n\nconst vec3 deSatConst = vec3( 0.299, 0.587, 0.114 );\n\n// Audio sampling helper..\n\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\n\n// Returns 3 B-spline functions of degree 2..\n\nvec3 B2_spline(vec3 x) \n{ \n    vec3 t = 3.0 * x;\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\n\treturn 0.5 * (\n    \tb0 * pow(t, vec3(2.0)) +\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + \n    \tb2 * pow(3.0-t,vec3(2.0))\n    );\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\n\t// Get coords and direction..\n    //\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat time = iTime * speed1 + 0.25;\n\n    vec2 centered = 2.0 * uv - 1.0;\n    centered.x *= iResolution.x / iResolution.y;\n\n    float dist2 = dot(centered, centered);\n    float clamped_dist = smoothstep(0.0, 1.0, dist2);\n    float arclength    = abs(atan(centered.y, centered.x) / radians(360.0))+0.01;\n    \n    //\n    // Audio visualisation..\n    //\n\t// - Modified version of the Soundcloud example by: chronos\n\t// - https://www.shadertoy.com/view/lsdGR8\n    //\n    float t = iTime / 100.0;\n    float polychrome = (1.0 + sin(t*10.0))/2.0; // 0 -> uniform color, 1 -> full spectrum\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\n    vec3 spline = B2_spline(spline_args);\n    \n    float f = abs(centered.y);\n    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f*spline;\n    vec3 flame_color = pow(base_color, vec3(3.0));\n    vec3 disc_color  = 0.20 * base_color;\n    vec3 wave_color  = 0.10 * base_color;\n    vec3 flash_color = 0.05 * base_color;\n    \n    vec2 fft = uv.xy;\n    fft -= 0.5;\n    fft *= 1.75;\n    fft.x *= iResolution.x / iResolution.y;\n    float sample1 = audio_freq(iChannel0, abs(2.0 * sqrt(dot(fft,fft)) - 1.0) + 0.01);\n\n    float sample2 = audio_ampl(iChannel0, clamped_dist);\n    float sample3 = audio_ampl(iChannel0, arclength);\n    \n    float disp_dist = smoothstep(-0.2, -0.1, sample3-dist2);\n    disp_dist *= (1.0 - disp_dist);\n\t\n    vec3 color = vec3(0.0);\n    \n    // Spline debug..\n//  vec3 s = smoothstep(-0.01, 0.01, spline-uv.y); color += (1.0-s) * s;\n    \n    float v = abs(uv.y - 0.5);\n    vec3 flame = flame_color * smoothstep(v, v*8.0, sample1);\n    color += flame;\n    color += disc_color  * smoothstep(0.5, 1.0, sample2) * (1.0 - clamped_dist);\n    color += flash_color * smoothstep(0.5, 1.0, sample3) * clamped_dist;\n    color += wave_color  * disp_dist;\n    color = pow(color, vec3(0.4545));\n\tvec3 sonicColor = color;\n\n    //\n    // Fix aspect for volumetric passes..\n    //\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3 dir = vec3( uv * zoom1, 1.0 );\n\n    //\n\t// Mouse rotation..\n    //\n\tfloat a1 = 0.15 + iMouse.x / iResolution.x * 2.0;\n\tfloat a2 = 0.8 + iMouse.y / iResolution.y * 2.0;\n\tmat2 rot1 = mat2( cos(a1), sin(a1), -sin(a1), cos(a1));\n\tmat2 rot2 = mat2( cos(a2), sin(a2), -sin(a2), cos(a2));\n\tdir.xz *= rot1;\n\tdir.xy *= rot2;\n\tvec3 from = vec3( 1.0, 0.5, 0.5 );\n    \n    //\n    // ! !! !!! - Time Warp the camera position using the audio freuency data..! :))\n    //\n    time += sample1 * 0.001;\n    \n\tfrom += vec3( time * -200.0, time * 8.0, time * 0.0) * 0.1;\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\n    //\n\t// Volumetric rendering 2nd pass - Larger Stars..\n\t//\n\tfloat s2 = 0.1;\n\tfloat fade2 = 1.0;\n\tvec3 v2 = vec3(0.0);\n\tfor ( int r = 0; r < volsteps2; r++ ) \n    {\n\t\tvec3 p = from + s2 * dir * 0.5;\n\t\tp = abs( vec3( tile2 ) - mod( p, vec3( tile2 * 2.0 ) ) ); // tiling fold\n\t\tfloat pa = 0.0;\n\t\tfloat a = 0.0;\n\n\t\tfor (int i=0; i<iterations2; i++) \n        { \n\t\t\tp=abs(p)/dot(p,p)-formuparam2; \t// the magic formula\n\t\t\ta+=abs(length(p)-pa); \t\t\t// absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n        float dm = max(0.0,darkmatter2-a*a*0.001); \t// dark matter\n\t\ta*= a * a; \t\t\t\t\t\t\t\t\t// add contrast\n\t\tif (r>6) fade2 *= 1.0 - dm; \t\t\t\t// dark matter, don't render near\n        v2 += fade2;\n\t\tv2 += vec3( s2, s2*s2, s2*s2*s2*s2 ) * a * brightness2 * fade2; // colouring based on distance\n        fade2 *= distfading2; \t\t\t\t\t\t// distance fading\n        s2 += stepsize2;\n\t}\n\t\n    v2 = mix(vec3(length(v2)),v2,saturation2) * 0.01; // colour adjust\n    \n    float deSat2 = dot( v2.xyz, deSatConst );   \n   \tvec3 saturateRGB2 = mix( vec3( deSat2, deSat2, deSat2 ), v2.xyz, kSaturation2 );\n    vec3 brightnessRGB2 = clamp( saturateRGB2 + kBrightness2, 0.0, 1.0 );\n    vec3 contrastRGB2 = clamp( pow( brightnessRGB2 * 2.0, vec3( kContrast2, kContrast2, kContrast2 ) ) * 0.5, 0.0, 1.0 );\n\n    //\n\t// Volumetric rendering 3rd pass (first) - Black Holes..\n\t//\n\tfloat s3 = 0.1;\n\tfloat fade3 = 1.0;\n\tvec3 v3 = vec3(0.0);\n\tfor ( int r = 0; r < volsteps3; r++ ) \n    {\n\t\tvec3 p = from + s3 * dir * 0.5;\n\t\tp = abs( vec3( tile3 ) - mod( p, vec3( tile3 * 2.0 ) ) ); // tiling fold\n\t\tfloat pa = 0.0;\n\t\tfloat a = 0.0;\n\n\t\tfor (int i=0; i<iterations3; i++) \n        {\n\t\t\tp=abs(p)/dot(p,p)-formuparam3; \t// the magic formula\n\t\t\ta+=abs(length(p)-pa); \t\t\t// absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n        float dm = max(0.0,darkmatter3-a*a*0.001); \t// dark matter\n\t\ta*= a * a; \t\t\t\t\t\t\t\t\t// add contrast\n\t\tif (r>6) fade3 *= 1.0 - dm; \t\t\t\t// dark matter, don't render near\n        v3 += fade3;\n\t\tv3 += vec3( s3, s3*s3, s3*s3*s3*s3 ) * a * brightness3 * fade3; // colouring based on distance\n        fade3 *= distfading3; \t\t\t\t\t\t// distance fading\n        s3 += stepsize3;\n\t}\n\t\n    // ! !! !!! - Time Warp the camera position using the audio freuency data..! :))\n    //\n    time += sample1 * 0.0005;\n    time += pow( length(v3) * 0.005, 0.001 );\n\n    from = vec3( 1.0, 0.5, 0.5 );\n    from += vec3( time * -200.0, time * 8.0, time * 0.0) * 0.1;\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\n    //\n\t// Volumetric rendering 1st pass - Deep In The Galactic Nebula..\n\t//\n\tfloat s1 = 0.1;\n\tfloat fade1 = 1.0;\n\tvec3 v1 = vec3(0.0);\n\tfor ( int r = 0; r < volsteps1; r++ ) \n    {\n\t\tvec3 p = from + s1 * dir * 0.5;\n\t\tp = abs( vec3( tile1 ) - mod( p, vec3( tile1 * 2.0 ) ) ); // tiling fold\n\t\tfloat pa = 0.0;\n\t\tfloat a = 0.0;\n\n\t\tfor (int i=0; i<iterations1; i++) \n        { \n            p=abs(p)/dot(p,p)-formuparam1; \t// the magic formula\n            float D = abs(length(p)-pa); \t// absolute sum of average change\n            a += i > 10 ? min( 12., D) : D;\t// INTEGER NOISE LIMTER (large num = more noise)\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n        float dm = max(0.,darkmatter1-a*a*0.001); \t// dark matter\n\t\ta*= a * a; \t\t\t\t\t\t\t\t\t// add contrast\n\t\tif (r>6) fade1 *= 1.0 - dm; \t\t\t\t// dark matter, don't render near\n        v1 += fade1;\n\t\tv1 += vec3( s1, s1*s1, s1*s1*s1*s1 ) * a * brightness1 * fade1; // colouring based on distance\n        fade1 *= distfading1; \t\t\t\t\t\t// distance fading\n        s1 += stepsize1;\n\t}\n\t\n    v1 = mix(vec3(length(v1)),v1,saturation1) * 0.01; // colour adjust\n    \n    float deSat1 = dot( v1.xyz, deSatConst );   \n   \tvec3 saturateRGB1 = mix( vec3( deSat1, deSat1, deSat1 ), v1.xyz, kSaturation1 );\n    vec3 brightnessRGB1 = clamp( saturateRGB1 + kBrightness1, 0.0, 1.0 );\n    vec3 contrastRGB1 = clamp( pow( brightnessRGB1 * 2.0, vec3( kContrast1, kContrast1, kContrast1 ) ) * 0.5, 0.0, 1.0 );\n\n\t//vec3 v3 = vec3(0.0);\n    \n    //\n    // Brightness, Contrst & Saturation..\n    //\n    float deSat3 = dot( v3.xyz, deSatConst );   \n   \tvec3 saturateRGB3 = mix( vec3( deSat3, deSat3, deSat3 ), v3.xyz, kSaturation3 );\n    vec3 brightnessRGB3 = clamp( saturateRGB3 + kBrightness3, 0.0, 1.0 );\n    vec3 contrastRGB3 = clamp( pow( brightnessRGB3 * 2.0, vec3( kContrast3, kContrast3, kContrast3 ) ) * 0.5, 0.0, 1.0 );\n\n    //\n    // Final combine..\n    //\n\tfragColor  = vec4((  saturateRGB1 * 0.333\n                       + saturateRGB1 * 0.666 \n                       * saturateRGB2 * 1.900 \n                       - pow( length(v3) * 0.005, 3.0 ) * 0.000222\n                     ) * (0.5 + (1.2 * sonicColor.xyz)) + sonicColor.xyz * 0.444, 1.0);\t\n}\n","name":"Image","description":"","type":"image"}]}