{"ver":"0.1","info":{"id":"ltKczt","date":"1537389606","viewed":1014,"name":"What Even Is Domain Repetition","username":"Dghelneshi","description":"When you have no idea how repeating SDF space works and try to figure something out on your own instead of looking it up. This is just two spheres garnished with generous amounts of WTF.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nfloat intersect(float a, float b) {\n    return max(a,b);\n}\n\n#define MIN_DIST 1.1 // used for both ray marching threshold and gradient!\n#define MAX_DIST 100.\n#define MAX_STEP 100\n\nfloat wtf1(float f) { // works best for MIN_DIST < 0.2\n    return mod(10000.0, f);\n}\nfloat wtf2(float f) { // works best for MIN_DIST ~ 1.0\n    return mod(6.0, f);\n}\nfloat wtf3(float f) { // works best for MIN_DIST > 0.1\n    return mod(f, 1000000.0);\n}\nfloat wtf4(float f) { // works best for MIN_DIST < 0.2\n    return mod(f, abs(sin(iTime)*2.5) + 1.0);\n}\nfloat wtf5(float f) { // works best for MIN_DIST > 0.5\n    return fract(f) * wtf3(f);\n}\n\nfloat SDF(vec3 p) {\n    float s1 = sphere(p, vec3(sin(iTime), cos(iTime), 5.), 2.);\n    float s2 = sphere(p, vec3(cos(iTime)*2., sin(iTime)*2., cos(iTime) + 8.), 4.);\n\n    return wtf2(intersect(s1,s2)); // try replacing with wtf1-5 and adjust MIN_DIST\n}\n\nvec3 grad(vec3 p) {\n  return normalize(vec3(SDF(p + vec3(MIN_DIST,0,0)) - SDF(p - vec3(MIN_DIST,0,0)),\n                        SDF(p + vec3(0,MIN_DIST,0)) - SDF(p - vec3(0,MIN_DIST,0)),\n                        SDF(p + vec3(0,0,MIN_DIST)) - SDF(p - vec3(0,0,MIN_DIST))));\n}\n\nvec3 shade(vec3 p, vec3 light) {\n  vec3 n = grad(p);\n  vec3 l = normalize(light - p);\n  return max(vec3(0), l * n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 light = vec3(1,1,0);\n\n    vec3 cam = vec3(0.0, 0.0, -5.0);\n    vec3 dir = vec3(uv, 1.0);\n    vec3 p = cam;\n    vec3 c = vec3(0);\n\n    for (int i = 0; i < MAX_STEP; i++) {\n        \n        float d = SDF(p);\n        \n        if (d < MIN_DIST) {\n            c = shade(p, light);\n            break;\n        }\n        else if (d > MAX_DIST)\n            break;\n        p += d * dir;\n    }\n\n    fragColor = vec4(c,0);\n}","name":"Image","description":"","type":"image"}]}