{"ver":"0.1","info":{"id":"MX3SDB","date":"1719576949","viewed":55,"name":"Probando Cositas","username":"DGMKPixy","description":"Tengo este shader como caja de juguetes en el que voy a ir probando a hacer cosas para aprender a programar shader como un auténtico pantera.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void INIT(in vec2 fragCoord)\n{\n    DATA.fragCoord = fragCoord;\n    // Normalized pixel coordinates (from 0 to 1)\n    DATA.uv = fragCoord/iResolution.xy;\n    DATA.uv -= .5;\n    DATA.uv.x *= (iResolution.x / iResolution.y);\n    \n    //data.uv = (((fragCoord/iResolution.xy) - .5) * (iResolution.x / iResolution.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT(fragCoord);\n    T = iTime;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.);//0.5 + 0.5*cos(iTime+data.uv.xyx+vec3(0,2,4));\n    \n    vec3 smiley = Smiley(vec2(0), 1.);\n    col = smiley;\n    \n    \n    float x = DATA.uv.x;\n    float y = DATA.uv.y + (.2*cos(x*5.));\n    \n    float A = 0.1;\n    float F = 6.;\n    float V = 4.;\n    float m = A*sin(x*F+(T*V));\n    y = DATA.uv.y - m;\n    DATA.uv = vec2(x,y);\n    \n    vec2 size = vec2(0.6, 0.1);\n    //x = size.x;\n    //y = size.y;\n    //size = vec2(x, y) / 2.;\n    \n    float blur = remap(vec2(-size.x, -size.y),vec2(0.,0.5),x);//.01+(x+0.5);\n    blur=pow(blur*1.5, 2.);\n    float rect = Rectangle(vec2(0.), vec2(0.5+x,0.6), 1.);\n    rect = Rectangle(vec2(0.), \n        vec4(-size.x,-size.y, size.x, size.y), blur);\n    col = vec3(rect);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define RED vec3(1,0,0)\n#define YELLOW vec3(1,1,0)\n#define BLACK vec3(0.001)\n\nstruct Transform\n{\n    vec3 Position;\n    vec3 Rotation;\n    vec3 Scale;\n};\n\nstruct INIT_DATA\n{\n    vec2 fragCoord;\n    vec2 uv;\n};\n\nINIT_DATA DATA;\nfloat T; \n\n// Si t es a, devuelve 0. SI es b, 1.\nfloat lerp(in float a, in float b, in float t)\n{\n    return (t-a)/(b-a);\n}\n\nfloat remap(in vec2 ab, in vec2 cd, in float t)\n{\n    return lerp(ab.x, ab.y, t) * (cd.y-cd.x) + cd.x;\n}\n\nfloat Rectangle(in vec2 pos, in vec4 sides, in float blur)\n{\n    float r = 0.;\n    blur += 0.000001; // Esto sirve para que no sea 0 y smoothstep se haga bien.\n    blur /= 2.;\n    \n    DATA.uv += pos.xy;\n    float rect_x_E = sides.x;\n    float rect_y_S = sides.y;\n    float rect_x_W = sides.z;\n    float rect_y_N = sides.a;\n    r = smoothstep(rect_x_E-blur,rect_x_E+blur,DATA.uv.x);\n    r *= smoothstep(rect_y_S-blur,rect_y_S+blur,DATA.uv.y);\n    r *= smoothstep(rect_x_W+blur, rect_x_W-blur,DATA.uv.x);\n    r *= smoothstep(rect_y_N+blur,rect_y_N-blur,DATA.uv.y);\n    DATA.uv -= pos.xy;\n\n    return r;\n}\n\nfloat Rectangle(in vec2 pos, in vec2 size, in float blur)\n{\n    float r = 0.;\n    blur += 0.000001; // Esto sirve para que no sea 0 y smoothstep se haga bien.\n    \n    size /= 2.;\n    \n    DATA.uv += pos.xy;\n    float rect_x_E = - size.x;\n    float rect_y_S = - size.y;\n    float rect_x_W = + size.x;\n    float rect_y_N = + size.y;\n    r = smoothstep(rect_x_E,rect_x_E+blur,DATA.uv.x);\n    r *= smoothstep(rect_y_S,rect_y_S+blur,DATA.uv.y);\n    r *= smoothstep(rect_x_W+blur, rect_x_W,DATA.uv.x);\n    r *= smoothstep(rect_y_N+blur,rect_y_N,DATA.uv.y);\n    DATA.uv -= pos.xy;\n\n    return r;\n}\n\nfloat Circle(in Transform T, in float radius, in float blur)\n{\n    DATA.uv += T.Position.xy;\n    float d = length(DATA.uv);\n    DATA.uv -= T.Position.xy;\n    \n    float c = smoothstep(radius, radius-blur, d);\n    return c;\n}\n\nvec3 Smiley(vec2 pos, float size)\n{\n    vec3 col = vec3(0.);\n    \n    DATA.uv /= size;\n    \n    Transform t_circle, t_circle2, t_circle3, t_circle4, t_circle5, t_circle6, t_circle7;\n    t_circle.Position = vec3(pos,0.);\n    t_circle2.Position = vec3(pos.x + 0.15, pos.y - 0.1, 0);\n    t_circle3.Position = vec3(pos.x + -0.15, pos.y -0.1, 0);\n    t_circle4.Position = vec3(pos.x + 0.15, pos.y -0.09, 0);\n    t_circle5.Position = vec3(pos.x -0.15, pos.y -0.09, 0);\n    t_circle6.Position = vec3(pos.x + 0., pos.y -.0, 0);\n    t_circle7.Position = vec3(pos.x + 0., pos.y -.4, 0);\n    \n    float radius = 0.35;\n    col = Circle(t_circle, radius, 0.01) * YELLOW;\n    \n// OJOS\n    col += vec3(Circle(t_circle2, radius/3.5, 0.01));\n    col += vec3(Circle(t_circle3, radius/3.5, 0.01));\n    // Ahora clampeamos el color. ¿Por qué? Porque resulta que col en este punto tiene\n    // valores mayores a 1. Si intentamos mezclar colores luego, no podremos hacerlo de\n    // forma correcta\n    col = clamp(col, 0.0, 1.0);\n    \n// PUPILAS\n    // El problema es que el blanco satura el color, por eso no se muestra.\n    // Debería mirar el valor que tiene y, si el resultado del circulo es != 0, cambiarlo.\n    float f4 = Circle(t_circle4, radius/7., 0.015);\n    float f5 = Circle(t_circle5, radius/7., 0.015);\n    col = mix(col, vec3(f4) * BLACK, f4);\n    col = mix(col, vec3(f5) * BLACK, f5);\n    \n    col = clamp(col, 0.0, 1.0);\n    \n// BOCA\n    float mouthMask = Circle(t_circle6, radius/1.6, 0.01);\n    mouthMask -= Circle(t_circle7, radius/.7, 0.01);\n    mouthMask = clamp(mouthMask, 0.0, 1.0);\n\n    //col = vec3(mouthMask);\n    col = mix(col, vec3(mouthMask) * RED, mouthMask);\n    \n    \n    DATA.uv *= size;\n    return col;\n}","name":"Common","description":"","type":"common"}]}