{"ver":"0.1","info":{"id":"fsXcWS","date":"1643011964","viewed":116,"name":"RayMarching-Test","username":"TuanTuan","description":"球,圆角方块","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//射线方向\nvec3 raydirection(vec2 fragCoord,float fov)\n{\n    float depth=iResolution.y/tan(radians(fov*0.5));\n    return normalize(vec3(fragCoord-iResolution.xy*0.5,-depth));\n}\nfloat sphereSDF(vec3 p,vec3 c,float r)\n{\n    return length(p-c)-r;\n}\nfloat planeSDF(vec3 p,float h)\n{\n    return p.y-h;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat sceneSDF(vec3 p)\n{\n    float spheredist=sphereSDF(p, vec3(0.0,0.0,-4), 1.0);\n    float spheredist1=sphereSDF(p, vec3(1.0,0.0,-4), 1.5*sin(iTime));\n    float temp=max(spheredist,-spheredist1);\n    float RoundBoxdist=sdRoundBox(p-vec3(2.0,-0.6,-4),vec3(0.5+0.5*sin(iTime*2.0),0.25,0.25+0.25*sin(iTime*2.0)),0.1);\n    float planedist=planeSDF(p,-1.0);\n    temp=min(min(temp,planedist),RoundBoxdist);\n    float spheredist2=sphereSDF(p,vec3(4.0*sin(iTime),0.0,-4),0.5);\n    return opSmoothUnion(temp,spheredist2,0.5);\n}\n//阴影\nfloat calshadow(in vec3 ro,in vec3 rd,float mint,float maxt)\n{\n    float res=1.0;\n    float t=mint;\n    for(int i=0;i<24;i++)\n    {\n        float h=sceneSDF(ro+rd*t);\n        if(h<0.001)\n        {\n            return 0.0;\n        }\n        res=min(res,h/t);\n        t+=clamp(h,0.02,0.2);\n    }\n    return clamp( res,0.0,1.0);\n}\nfloat raymarch(vec3 ro,vec3 rd)\n{\n    float depth=0.0;\n    for(int i=0;i<256;i++)\n    {\n        vec3 p=ro+rd*depth;\n        float dist=sceneSDF(p);\n        if(dist<=0.01)\n        {\n            return depth;\n        }\n        depth+=dist;\n        if(depth>=1000.0) return 1000.0;\n    }\n    return 1000.0;\n}\n//法线\nvec3 calnormal(vec3 p,vec3 camerapos)\n{\n    vec2 e=vec2(1.,-1.)*0.0005;\n    return normalize(\n        e.xyy*sceneSDF(p+e.xyy)+\n        e.yyx*sceneSDF(p+e.yyx)+\n        e.yxy*sceneSDF(p+e.yxy)+\n        e.xxx*sceneSDF(p+e.xxx)\n    );\n}\n//光照\nvec3 callight(vec3 p,vec3 camerapos)\n{\n    //lightdata\n    vec3 lightpos=vec3(15.0,15.0,15.0);\n    vec3 lightcolor=vec3(1.0,1.0,1.0);\n    vec3 lightdir=normalize(lightpos-p);\n    vec3 viewdir=normalize(camerapos-p);\n    vec3 normal=calnormal(p,camerapos);\n    vec3 halfdir=normalize(viewdir+lightdir);\n    //ambient\n    float ambientstrength=0.1;\n    vec3 ambientcolor=lightcolor;\n    vec3 ambient=ambientstrength*ambientcolor;\n    //diffuse\n    float diffstrength=max(dot(normal,lightdir),0.0);\n    vec3 diffcolor=lightcolor;\n    vec3 diffuse=diffstrength*diffcolor;\n    //specular\n    float specstrength=pow(max(dot(halfdir,normal),0.0),32.0);\n    vec3 speccolor=lightcolor;\n    vec3 specular=specstrength*speccolor;\n    //shadow\n    float shadow=1.0;\n    shadow=calshadow(p,lightdir,1.0,256.0);\n\n    return (ambient+diffuse+specular)*shadow;\n}\nvec3 render(vec3 ro,vec3 rd)\n{\n    vec3 bgcol=vec3(0.76,0.75,0.86);;\n    float dist=raymarch(ro,rd);\n    if(dist>=1000.0)\n    {\n        return bgcol;\n    }\n    vec3 p=ro+rd*dist;\n    vec3 col=callight(p,ro);\n    return col;\n}\n//从eye看向target的变换矩阵\nmat4 viewMatrix(vec3 eye,vec3 target,vec3 up)\n{\n    vec3 f=normalize(target-eye);\n    vec3 r=normalize(cross(f,up));\n    vec3 u=normalize(cross(r,f));\n    return mat4(\n        vec4(r,0.),\n        vec4(u,0.),\n        vec4(-f,0.),\n        vec4(0.,0.,0.,1.)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //相机看向的目标点\n    vec3 ta=vec3(1.0,0.0,-4.0);\n    //相机位置\n    vec3 ro=ta+vec3(5.0*sin(iTime),1.0,5.0*cos(iTime));\n    //相机看向目标点的变换矩阵\n    mat4 ca = viewMatrix( ro, ta,vec3(0.0,1.0,0.0));\n    //相机看向目标点的方向\n    vec3 rd=normalize(ca*vec4(raydirection(fragCoord,90.0),1.0)).xyz;\n    vec3 col=render(ro,rd);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}