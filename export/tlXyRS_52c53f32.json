{"ver":"0.1","info":{"id":"tlXyRS","date":"1592403988","viewed":88,"name":"BRDF Boze","username":"kaiware007","description":"Reference BRDF code\nhttps://www.shadertoy.com/view/XlKSDR","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG1 6.0\n#define MAT_BG2 7.0\n#define MAT_CS 8.0\n\n#define AA 1\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0 / sc);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05, 0.02 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    //return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n    return sdRoundBox(p + vec3(0.03, -0.14,-0.1) * sc, vec3(0.0175,0.0025,0.1) * sc, 0.001);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    //eye.x = opUnion(d9, d10);\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(0.);\n    p = rotate(p, M_PI, vec3(0,1,0));\n    //p = rotate(p, iTime, vec3(0,1,0));\n    //p = rotate(p, iTime, vec3(1,0,0));\n    result = sdBoze(p, 1.0, 1.0);\n    //result = sdBoze(p, (sin(iTime) * 0.5 + 0.5) * 1.5);\n    \n    // background\n    vec2 bg1 = vec2(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), MAT_BG1);\n    \n    vec3 q = opRep(p, vec3(0.5));\n    q = TwistY(q, 2.*M_PI2);\n    q = rotate(q, iTime*M_PI, vec3(0,1,0));\n    q += vec3(0.01,0,0.01);\n    float w = 0.025;\n    vec2 bg2 = vec2(sdRoundBox(q, vec3(w,0.5,w), 0.01), MAT_BG2);\n    \n    result = opU(result, opSU(bg1, bg2, 0.2));\n    //result = opU(bg1, result);\n    //result = opSU(bg1, result, sin(iTime)*0.01+0.01);\n    //result = opU(bg2, result);\n    //result = opSU(bg2, result, sin(iTime)*0.1+0.1);\n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).x - map(position - epsilon.xyy).x,\n          map(position + epsilon.yxy).x - map(position - epsilon.yxy).x,\n          map(position + epsilon.yyx).x - map(position - epsilon.yyx).x);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).x;\n        if (h < 0.0001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = 0.0;\n\n    float t = 0.02;\n    \n    vec3 pos;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = origin + direction * t;\n        vec2 hit = map(pos);\n\n        float d = hit.x * 0.5;\n        t += d;\n        material = hit.y;\n\n        if (d <= 0.00001 ) {\n        \tbreak;\n        }\n\n        \n    }\n    if (t >= MAX_DIST) {\n        t = MAX_DIST;\n        material = 0.0;        \n    }\n    return vec2(t, material);\n}\n\nvec3 materialColor(vec3 pos, vec2 mat, out float roughness, out float metalness)\n{\n    vec3 col = vec3(0);\n    \n    //float t = saturate(sin(iTime * 2.5)*0.25+0.25);\n    float m = 0.1;\n    //float r = mix(0.00001, 1., sin(iTime * 5.)*0.5+0.5);\n    float r = 0.1;\n\tif(mat.y == MAT_BLACK) {\n        col = vec3(0.1);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_FACE) {\n        col = vec3(1.0, 0.8, 0.45);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BROW) {\n        col = vec3(1.0, 0, 0.1);\n        roughness = r;\n        metalness = m*0.1;\n    } else if(mat.y == MAT_CHEEP) {\n        col = vec3(1.0, 0.3, 0.5);\n        roughness = r;\n        metalness = m;\n    } else if(mat.y == MAT_BG1) {\n        vec3 index = floor(pos * 10.+ 0.5);\n\n        float f = noise(index + iTime * 2.8);\n        col = mix(vec3(1), vec3(0), f);\n        //col = vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.001;\n        metalness = 0.8;\n    } else if(mat.y == MAT_BG2) {\n        vec3 index = floor(pos * 50.+ 0.5);\n\t\tfloat f = noise(index + iTime * vec3(2.8,-0.8,0.79));\n        col = sinebow(f);\n        //col = vec3(1.0,0,0) + vec3(-1,0,1) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n        roughness = 0.001;\n        metalness = 0.8;\n    }\n    return col;\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightDir, vec3 lightColor, vec3 baseColor, float roughness, float metallic) {\n    vec3 color = vec3(0);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    vec3 r = normalize(reflect(rayDir, normal));\n\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    \n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n \t\n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec2 indirectHit = traceRay(pos, r);\n    vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n    \n    if (indirectHit.y > 0.0) {\n        vec3 indirectPosition = pos + indirectHit.x * r;        \n\t\tfloat reflength = length(indirectPosition - pos);\n        \n        float roughness, metalness;\n        indirectSpecular = materialColor(indirectPosition, indirectHit, roughness, metalness);\n\n        vec3 sky = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        // fog\n        indirectSpecular = mix(indirectSpecular, 0.8 * sky, 1.0 - saturate(exp2(-0.1 * reflength * reflength)));\n    }\n\t\n    // indirect contribution\n    vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n    vec3 specularColor = f0 * dfg.x + dfg.y;\n    vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\t\n    color += ibl * indirectIntensity;\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.65, 0.85, 1.0);\n    //vec3 sky = vec3(0);\n    vec3 sky = vec3(0.65, 0.85, 1.0) + ray.y * 0.72;\n    //vec3 sky = vec3(1);\n    if (depth >= MAX_DIST) {\n        col = sky;\n    } else {\n        if(mat.y > 0.0)\n        {\n            vec3 nor = norm(p);            \n            float roughness, metalness;\n            col = materialColor(p, mat, roughness, metalness);\n\n            vec3 result = vec3(0.);\n            //result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n            result = calcAmb(p, ray, nor, normalize(vec3(0.6, 0.8, -0.7)), vec3(0.98, 0.92, 0.89) * 3.0, col, roughness, metalness);\n            col = result;\n        }\n    }\n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n    // Exponential distance fog\n    col = mix(col, 0.8 * sky, 1.0 - saturate(exp2(-0.1 * depth * depth)));\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray)\n{\n    vec3 pos;\n    vec2 mat = traceRay(p, ray);\n    \n    p = p + mat.x * ray;\n    return materialize(p, ray, mat.x, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float t = iTime * M_PI * 0.2;\n        float y = sin(t * 2.5) * 0.25;\n        float r = 1. + sin(t * 0.5)*0.5;\n        float theta = t + RAD90 + RAD90*0.25;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        vec3 ro = vec3(cos(theta) * r, 0.24 + y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0.05, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = render(ro, ray);\n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}