{"ver":"0.1","info":{"id":"4tVyWy","date":"1537835300","viewed":95,"name":"CSC550Assign2","username":"alexander_hart21","description":"Homework\nThere are five different shapes: Pyramid, Torus, Cylinder, Sphere, and 3 Planes\nThe floor plane isn't rendering for some reason and the cylinder is only partly rendering. Not quite sure why.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://github.com/yuichiroharai/glsl-y-rotate/blob/master/rotateY.glsl\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateZ(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, s, 0.0,\n        -s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t\t\n\t);\n}\n\nfloat kEpsilon = 1e-8;\n\nbool triangleTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.001 )\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n\n\n\nbool planeTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n    if(t < 0.001)\n        return false;\n    \n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\nbool planeTraceUV(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\n\n//send a ray toward a sphere?\n//return true if it intersects sphere\n//also set the intersecting 3D Point\n//and reflected Ray direction\nbool sphereTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 spherePos, in float sphereRadius,\n\tout vec3 intersectPos, out vec3 intersectDir) {\n\n\t//create a vector from ray Starting Point to Sphere Center\n\tvec3 L = spherePos - rayPos;\n\n\t//project that ray onto my ray direction and get its length\n\tfloat tc = dot(L, rayDirection);\n\n\tif (tc < 0.0)\n\t\treturn false;\n\n\t//float d = sqrt(pow(length(L), 2.0) - pow(tc,2.0));\n\tfloat d = sqrt(dot(L, L) - pow(tc, 2.0));\n\tif (d > sphereRadius)\n\t\treturn false;\n\n\tfloat t1c = sqrt(pow(sphereRadius, 2.0) - pow(d, 2.0));\n\n\t//distance from ray Start to hitting the sphere\n\tfloat t1 = tc - t1c;\n\n\t//results in 3D point where ray hits the sphere\n\tintersectPos = rayPos + rayDirection * t1;\n\n\tvec3 normal = normalize(intersectPos - spherePos);\n\n\tintersectDir = reflect(rayDirection, normal);\n\n\treturn true;\n\n}\n\nconst vec3 DNUT_VERTS[36] = vec3[36](\nvec3( -1.4923572141 ,  1.12418024543 ,  -2.03110440704e-16 ), \nvec3( -2.54859437526 ,  1.12418042424 ,  -2.03110480408e-16 ), \nvec3( -3.07671310485 ,  0.209452297751 ,  -3.49479548955e-23 ), \nvec3( -2.54859467329 ,  -0.705276024314 ,  2.03110453939e-16 ), \nvec3( -1.49235751213 ,  -0.705276083918 ,  2.03110467173e-16 ), \nvec3( -0.964238901745 ,  0.209452140359 ,  0.0 ), \nvec3( -1.3673571545 ,  1.34068654778 ,  0.433012723923 ), \nvec3( -2.67359437526 ,  1.3406867862 ,  0.433012723923 ), \nvec3( -3.32671310485 ,  0.209452335004 ,  0.433012723923 ), \nvec3( -2.67359473289 ,  -0.921782386275 ,  0.433012723923 ), \nvec3( -1.36735751213 ,  -0.921782386275 ,  0.433012723923 ), \nvec3( -0.714238901745 ,  0.209452140359 ,  0.433012723923 ), \nvec3( -1.11735697569 ,  1.77369927171 ,  0.43301269412 ), \nvec3( -2.92359431566 ,  1.77369962933 ,  0.43301269412 ), \nvec3( -3.82671322406 ,  0.20945240951 ,  0.43301269412 ), \nvec3( -2.9235948521 ,  -1.3547951102 ,  0.43301269412 ), \nvec3( -1.11735745252 ,  -1.35479522941 ,  0.43301269412 ), \nvec3( -0.214238782536 ,  0.209452140359 ,  0.43301269412 ), \nvec3( -0.992356916081 ,  1.99020563367 ,  -7.45058063646e-08 ), \nvec3( -3.04859425605 ,  1.9902059913 ,  -7.45058063646e-08 ), \nvec3( -4.07671322406 ,  0.209452446763 ,  -7.45058059692e-08 ), \nvec3( -3.0485948521 ,  -1.57130147216 ,  -7.45058055738e-08 ), \nvec3( -0.992357512127 ,  -1.57130159137 ,  -7.45058055738e-08 ), \nvec3( 0.0357612174644 ,  0.209452140359 ,  -7.45058059692e-08 ), \nvec3( -1.11735709489 ,  1.7736991525 ,  -0.433012753725 ), \nvec3( -2.92359419645 ,  1.77369939092 ,  -0.433012753725 ), \nvec3( -3.82671298565 ,  0.20945240951 ,  -0.433012753725 ), \nvec3( -2.92359473289 ,  -1.35479499099 ,  -0.433012753725 ), \nvec3( -1.11735757173 ,  -1.3547951102 ,  -0.433012753725 ), \nvec3( -0.214239020954 ,  0.209452140359 ,  -0.433012753725 ), \nvec3( -1.3673572141 ,  1.34068642857 ,  -0.433012664318 ), \nvec3( -2.67359431566 ,  1.34068666699 ,  -0.433012664318 ), \nvec3( -3.32671298565 ,  0.209452335004 ,  -0.433012664318 ), \nvec3( -2.67359467329 ,  -0.921782267066 ,  -0.433012664318 ), \nvec3( -1.36735757173 ,  -0.921782386275 ,  -0.433012664318 ), \nvec3( -0.714239020954 ,  0.209452140359 ,  -0.433012664318 ) \n);\nconst ivec3 DNUT_INDEX[72] = ivec3[72](\nivec3( 1 ,  0 ,  7 ), \nivec3( 7 ,  0 ,  6 ), \nivec3( 2 ,  1 ,  8 ), \nivec3( 8 ,  1 ,  7 ), \nivec3( 3 ,  2 ,  9 ), \nivec3( 9 ,  2 ,  8 ), \nivec3( 4 ,  3 ,  10 ), \nivec3( 10 ,  3 ,  9 ), \nivec3( 5 ,  4 ,  11 ), \nivec3( 11 ,  4 ,  10 ), \nivec3( 0 ,  5 ,  6 ), \nivec3( 6 ,  5 ,  11 ), \nivec3( 7 ,  6 ,  13 ), \nivec3( 13 ,  6 ,  12 ), \nivec3( 8 ,  7 ,  14 ), \nivec3( 14 ,  7 ,  13 ), \nivec3( 9 ,  8 ,  15 ), \nivec3( 15 ,  8 ,  14 ), \nivec3( 10 ,  9 ,  16 ), \nivec3( 16 ,  9 ,  15 ), \nivec3( 11 ,  10 ,  17 ), \nivec3( 17 ,  10 ,  16 ), \nivec3( 6 ,  11 ,  12 ), \nivec3( 12 ,  11 ,  17 ), \nivec3( 13 ,  12 ,  19 ), \nivec3( 19 ,  12 ,  18 ), \nivec3( 14 ,  13 ,  20 ), \nivec3( 20 ,  13 ,  19 ), \nivec3( 15 ,  14 ,  21 ), \nivec3( 21 ,  14 ,  20 ), \nivec3( 16 ,  15 ,  22 ), \nivec3( 22 ,  15 ,  21 ), \nivec3( 17 ,  16 ,  23 ), \nivec3( 23 ,  16 ,  22 ), \nivec3( 12 ,  17 ,  18 ), \nivec3( 18 ,  17 ,  23 ), \nivec3( 19 ,  18 ,  25 ), \nivec3( 25 ,  18 ,  24 ), \nivec3( 20 ,  19 ,  26 ), \nivec3( 26 ,  19 ,  25 ), \nivec3( 21 ,  20 ,  27 ), \nivec3( 27 ,  20 ,  26 ), \nivec3( 22 ,  21 ,  28 ), \nivec3( 28 ,  21 ,  27 ), \nivec3( 23 ,  22 ,  29 ), \nivec3( 29 ,  22 ,  28 ), \nivec3( 18 ,  23 ,  24 ), \nivec3( 24 ,  23 ,  29 ), \nivec3( 25 ,  24 ,  31 ), \nivec3( 31 ,  24 ,  30 ), \nivec3( 26 ,  25 ,  32 ), \nivec3( 32 ,  25 ,  31 ), \nivec3( 27 ,  26 ,  33 ), \nivec3( 33 ,  26 ,  32 ), \nivec3( 28 ,  27 ,  34 ), \nivec3( 34 ,  27 ,  33 ), \nivec3( 29 ,  28 ,  35 ), \nivec3( 35 ,  28 ,  34 ), \nivec3( 24 ,  29 ,  30 ), \nivec3( 30 ,  29 ,  35 ), \nivec3( 31 ,  30 ,  1 ), \nivec3( 1 ,  30 ,  0 ), \nivec3( 32 ,  31 ,  2 ), \nivec3( 2 ,  31 ,  1 ), \nivec3( 33 ,  32 ,  3 ), \nivec3( 3 ,  32 ,  2 ), \nivec3( 34 ,  33 ,  4 ), \nivec3( 4 ,  33 ,  3 ), \nivec3( 35 ,  34 ,  5 ), \nivec3( 5 ,  34 ,  4 ), \nivec3( 30 ,  35 ,  0 ), \nivec3( 0 ,  35 ,  5 ) \n);\n\nconst vec3 PYR_VERTS[5] = vec3[5](\nvec3( 2.00000009273 ,  -1.28065652381 ,  -1.70710676908 ), \nvec3( 1.29289323092 ,  -1.28065652381 ,  -1.00000006182 ), \nvec3( 1.99999996909 ,  -1.28065652381 ,  -0.292893230915 ), \nvec3( 2.70710676908 ,  -1.28065652381 ,  -1.0 ), \nvec3( 2.0 ,  1.28065652381 ,  -1.0 ) \n);\nconst ivec3 PYR_INDEX[6] = ivec3[6](\nivec3( 0 ,  3 ,  2 ), \nivec3( 0 ,  1 ,  4 ), \nivec3( 1 ,  2 ,  4 ), \nivec3( 2 ,  3 ,  4 ), \nivec3( 3 ,  0 ,  4 ), \nivec3( 3 ,  0 ,  4 ) \n);\n\n\nconst vec3 CYL_VERTS[12] = vec3[12](\nvec3( 4.9925345821 ,  0.159145151524 ,  2.16451209738 ), \nvec3( 3.87450045773 ,  0.159145151524 ,  2.5277833338 ), \nvec3( 3.87450039812 ,  0.159145151524 ,  3.70335394098 ), \nvec3( 4.99253443309 ,  0.159145151524 ,  4.06662523701 ), \nvec3( 5.68351746031 ,  0.159145151524 ,  3.115568697 ), \nvec3( 4.9925345821 ,  2.15914515152 ,  2.16451209738 ), \nvec3( 3.87450045773 ,  2.15914515152 ,  2.5277833338 ), \nvec3( 3.87450039812 ,  2.15914515152 ,  3.70335394098 ), \nvec3( 4.99253443309 ,  2.15914515152 ,  4.06662523701 ), \nvec3( 5.68351746031 ,  2.15914515152 ,  3.115568697 ), \nvec3( 4.68351746031 ,  0.159145151524 ,  3.115568697 ), \nvec3( 4.68351746031 ,  2.15914515152 ,  3.115568697 ) \n);\nconst ivec3 CYL_INDEX[20] = ivec3[20](\nivec3( 0 ,  1 ,  6 ), \nivec3( 1 ,  2 ,  7 ), \nivec3( 2 ,  3 ,  8 ), \nivec3( 3 ,  4 ,  9 ), \nivec3( 4 ,  0 ,  5 ), \nivec3( 1 ,  0 ,  10 ), \nivec3( 2 ,  1 ,  10 ), \nivec3( 3 ,  2 ,  10 ), \nivec3( 4 ,  3 ,  10 ), \nivec3( 0 ,  4 ,  10 ), \nivec3( 5 ,  6 ,  11 ), \nivec3( 6 ,  7 ,  11 ), \nivec3( 7 ,  8 ,  11 ), \nivec3( 8 ,  9 ,  11 ), \nivec3( 9 ,  5 ,  11 ), \nivec3( 9 ,  5 ,  11 ), \nivec3( 9 ,  5 ,  11 ), \nivec3( 9 ,  5 ,  11 ), \nivec3( 9 ,  5 ,  11 ), \nivec3( 9 ,  5 ,  11 ) \n);\n\nconst vec3 PLANE_POS[3] = vec3[3](vec3(0.0, -0.25, 0.0),\n                                  vec3(6.0, 0.0, 0.0),\n                                  vec3(0.0, 4.0, 0.0)\n\t);\n\nconst vec3 PLANE_NORM[3] = vec3[3](vec3(0.0, 1.0, 0.0),\n                                  vec3(-1.0, 0.0, 0.0),\n                                  vec3(0.0, -1.0, 0.0)\n                                   );\n\nconst vec3 SPHERE_POS[1] = vec3[1](vec3(-1.0, 2.5, -1.0)\n\n\t);\n\nconst vec3 SPHERE_COLOR[1] = vec3[1](vec3(1.0, 0.5, 0.0)\n\t);\n\nconst float SPHERE_RADIUS[1] = float[1](0.8);\n\nconst vec3 LIGHT_POS[3] = vec3[3](vec3(1.0, 10.0, 0.0),\n\tvec3(-5.0, 2.5, 5.0),\n\tvec3(2.5, 2.5, 10.0)\n\n\t);\n\nconst vec3 LIGHT_COLOR[3] = vec3[3](vec3(0.0, 0.0, 1.0),\n\tvec3(1.0, 1.0, 1.0),\n\tvec3(1.0, 0.0, 0.0)\n\t);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord / iResolution.y;\n\tuv -= 0.5; //center the uvs\n\n\n\tvec3 cubePos = vec3(0.5, 0.55, -1.0);//*rotateZ(iTime / 2.0);\n\n\n\tvec3 lightPos = vec3(0, 10, 0);\n\tvec3 lightPos2 = vec3(5, 0, 5);\n\n\t//vec3 rayPos = vec3(uv.x, uv.y + 2.0, 7.0);\n    vec3 rayPos = vec3(0.0,1.5,30.0);//*rotateY(iTime / 2.0);\n\t\n\tvec3 rayDir = normalize(vec3(uv.x, uv.y , -3.0));//*rotateY(iTime / 2.0));\n\n\tvec3 planeNormal = vec3(0.0, 1.0, 0.0);\n\n\n\tvec3 newPos;\n\tvec3 newDir;\n\tvec3 currColor;\n\n\tvec3 col = vec3(0.0);\n\n\t//loop for ray bounces\n\tfor (int r = 0; r < 6; r++) {\n\n\t\t//col = vec3(0.0);\n\n\t\tfloat minDist = 999999999.0;\n\t\tvec3 tempNewPos;\n\t\tvec3 tempNewDir;\n\n\t\t//foreach sphere in our scene check if ray hits it\n\t\tfor (int s = 0; s < 1; s++) {\n\n\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\tif (sphereTrace(rayPos, rayDir,\n\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = SPHERE_COLOR[s];\n\n\t\t\t\t}\n\n\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t}\n\n\t\t}\n\n        \n        \n        for (int f = 0; f < 72; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  DNUT_VERTS[DNUT_INDEX[f].x],\n                              DNUT_VERTS[DNUT_INDEX[f].y],\n                              DNUT_VERTS[DNUT_INDEX[f].z],\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = texture(iChannel2, newPos.xz/10.0).rrr;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        for (int f = 0; f < 20; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CYL_VERTS[CYL_INDEX[f].x],\n                              CYL_VERTS[CYL_INDEX[f].y],\n                              CYL_VERTS[CYL_INDEX[f].z],\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = vec3(1.0, 0.0, 0.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n                for (int f = 0; f < 6; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  PYR_VERTS[PYR_INDEX[f].x],\n                              PYR_VERTS[PYR_INDEX[f].y],\n                              PYR_VERTS[PYR_INDEX[f].z],\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = texture(iChannel0, newPos.xz/10.0).rgb;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        for(int p = 1; p < 3; p++){\n\t\t\tif (planeTrace(rayPos, rayDir,\n\t\t\t\tPLANE_POS[p], PLANE_NORM[p],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\t\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = texture(iChannel1, newPos.xz/10.0).rgb;//vec3(1.0);\n\t\n\t\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t}\n        }\n\n\n\n\n\t\tif (minDist < 50.0) { //make sure this ray doesn't hit anything\n\n\t\t\trayPos = newPos;\n\t\t\trayDir = newDir;\n\n\n\t\t//\t col = newDir;\n        //    col = vec3(minDist/50.0);\n\n\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t//now let's check if this ray can see the light sources\n\n\t\t\t\tvec3 lightDir = normalize(LIGHT_POS[l] - rayPos);\n\t\t\t\tfloat lightDist = 9999999.9f;\n\n\n\t\t\t\tfor (int s = 0; s < 1; s++) {\n\n\t\t\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\t\t\tif (sphereTrace(rayPos, lightDir,\n\t\t\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int f = 0; f < 72; f++) {\n\t\t\t\t\tif (triangleTrace(rayPos, lightDir,\n\t\t\t\t\t\t\t\tDNUT_VERTS[DNUT_INDEX[f].x],\n                              DNUT_VERTS[DNUT_INDEX[f].y],\n                              DNUT_VERTS[DNUT_INDEX[f].z],\n                                      tempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                \n                for (int f = 0; f < 6; f++) {\n\t\t\t\t\tif (triangleTrace(rayPos, lightDir,\n\t\t\t\t\t\t\t\tPYR_VERTS[PYR_INDEX[f].x],\n                              PYR_VERTS[PYR_INDEX[f].y],\n                              PYR_VERTS[PYR_INDEX[f].z],\n                                      tempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                for(int p = 0; p < 3; p++){\n\t\t\t\t\tif (planeTrace(rayPos, lightDir,\n\t\t\t\t\t\tPLANE_POS[p], PLANE_NORM[p],\n\t\t\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\t\n\t\t\t\t\t\tif (dist < lightDist) {\n\n\t\t\t\t\t\t\tlightDist = dist;\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t\t\t}\n                }\n\n\n\t\t\t\tif (lightDist > distance(rayPos, LIGHT_POS[l])) {\n\t\t\t\t\tcol += (currColor*0.15 //ambient\n\t\t\t\t\t\t+ clamp(dot(rayDir, lightDir), 0.0, 1.0)*currColor //diffuse\n\t\t\t\t\t\t+ pow(clamp(dot(rayDir, lightDir), 0.0, 1.0), 50.8) * LIGHT_COLOR[l]\n\n\t\t\t\t\t\t) * (1.0/(float(r) + 1.0))\n\t\t\t\t\t\t* 50.0 / pow(distance(rayPos, LIGHT_POS[l]), 2.0);\n\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t}\n\t// Output to screen\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}