{"ver":"0.1","info":{"id":"ftySDR","date":"1640442754","viewed":420,"name":"Sunrise/sunset seascape","username":"vegardno","description":"Based on:\nhttps://www.shadertoy.com/view/7ttXDl\nhttps://www.shadertoy.com/view/wtV3W1","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["asdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gamma = 2.2;\n\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml\nmat3 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat3(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c\n    );\n}\n\n// https://www.gamedev.net/forums/topic/497459-distance-from-point-to-plane-along-a-vector/\nvoid intersect_ray_plane(vec3 origin, vec3 direction, vec3 plane_normal, float plane_offset, out float near)\n{\n    float t = -(dot(plane_normal, origin) + plane_offset) / dot(plane_normal, direction);\n    near = t * length(direction);\n}\n\nvec3 skybox(vec3 dir, vec3 sun_pos)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 p_sunset_dark[4] = vec3[4](\n        vec3(0.3720705374951474, 0.3037080684557225, 0.26548632969565816),\n        vec3(0.446163834012046, 0.39405890487346595, 0.425676737673072),\n        vec3(0.16514907579431481, 0.40461292460006665, 0.8799446225003938),\n        vec3(-7.057075230154481e-17, -0.08647963850488945, -0.269042973306185)\n    );\n\n    vec3 p_sunset_bright[4] = vec3[4](\n        vec3( 0.38976745480184677, 0.31560358280318124,  0.27932656874),\n        vec3( 1.2874522895367628,  1.0100154283349794,   0.862325457544),\n        vec3( 0.12605043174959588, 0.23134451619328716,  0.526179948359),\n        vec3(-0.0929868539256387, -0.07334463258550537, -0.192877259333)\n    );\n\n    vec3 p_day[4] = vec3[4](\n        vec3(0.051010496458305694, 0.09758747153634058, 0.14233364823001612),\n        vec3(0.7216045769411271, 0.8130766810405122, 0.9907063181559062),\n        vec3(0.23738746590578705, 0.6037047603190588, 1.279274525377467),\n        vec3(-4.834172446370963e-16, 0.1354589259524697, -1.4694301190050114e-15)\n    );\n\n    /* Sky */\n    {\n        float brightness_a = acos(dot(dir, sun_pos));\n        // old values: 80/0\n        float brightness_d = 1.5 * smoothstep(radians(70.), radians(-40.), brightness_a) - .5;\n    \n        vec3 p_sunset[4] = vec3[4](\n            mix(p_sunset_dark[0], p_sunset_bright[0], brightness_d),\n            mix(p_sunset_dark[1], p_sunset_bright[1], brightness_d),\n            mix(p_sunset_dark[2], p_sunset_bright[2], brightness_d),\n            mix(p_sunset_dark[3], p_sunset_bright[3], brightness_d)\n        );\n\n        float sun_a = acos(dot(sun_pos, vec3(0., 1., 0.)));\n        // old values: 100/80\n        float sun_d = smoothstep(radians(95.), radians(70.), sun_a);\n\n        vec3 a = mix(p_sunset[0], p_day[0], sun_d);\n        vec3 b = mix(p_sunset[1], p_day[1], sun_d);\n        vec3 c = mix(p_sunset[2], p_day[2], sun_d);\n        vec3 d = mix(p_sunset[3], p_day[3], sun_d);\n\n        float sky_a = acos(dot(dir, vec3(0., 1., 0.)));\n        // old values: 90/60\n        float sky_d = smoothstep(radians(90.), radians(50.), sky_a) + .04;\n\n        // sin(1/x) suggested by Phillip Trudeau\n        col += .9 * ((b - d) * sin(1. / (vec3(sky_d) / c + 2. / radians(180.) - a)) + d);\n    }\n\n    /* Sun */\n    float sun_a = acos(dot(sun_pos, dir));\n    // old values: (1., .95, .95);\n    vec3 sun_col = .01 * vec3(1., .7, .0) / sun_a;\n    col = max(col + .5 * sun_col, sun_col);\n\n    /* Stars */\n    {\n        vec2 star_uv = vec2(atan(dir.z / dir.x), dir.y) / radians(360.);\n        \n        vec2 uv_maj = floor(100. * star_uv) / 100.;\n        vec2 uv_min = fract(100. * star_uv);\n        \n        vec4 star_data = texture(iChannel1, uv_maj);\n        vec2 star_pos = .5 + (star_data.xy - .5);\n\n        float d = length(uv_min - star_pos) - .03 * star_data.z;\n        vec3 star_col = vec3(star_data.w) * smoothstep(1., -1., d * 20.);\n\n        col = max(col, star_col);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 7:30 AM +/- ~1.6 hours\n    float time_of_day = 7.5 + 1.6 * sin(radians(13.) * iTime);\n    //time_of_day = 7.5 + iTime;\n    //time_of_day = 24.;\n\n    vec3 sun_pos;\n    {\n        float t = (time_of_day + 4.) * radians(360. / 24.);\n        sun_pos = normalize(vec3(0., -sin(t), cos(t)));\n    }\n\n    vec3 eye = vec3(10. * cos(radians(30.) * iTime), 1.5 + sin(radians(30.) * iTime), 0.);\n\n    mat3 mvp = mat3(1.);\n\n    // look up\n    mvp *= rotate(radians(5.) * cos(radians(30.) * iTime), vec3(1., 0., 0.));\n\n    // look sideways\n    mvp *= rotate(radians(20.) * sin(radians(30.) * iTime), vec3(0., 0., 1.));\n\n    vec3 dir = mvp * rayDirection(80., iResolution.xy, fragCoord);\n    // this ought to be normalized already but isn't, for some reason I don't understand\n    // (maybe some kind of float inaccuracy in rotate()?)\n    dir = normalize(dir);\n\n    vec3 hi_rgb = vec3(1.);\n    vec3 lo_rgb = vec3(1.);\n    \n    vec3 normal = vec3(0, 1, 0);\n\n    float near;\n    intersect_ray_plane(eye, dir, normal, 0., near);\n    if (near > 0.) {\n    \tvec3 hit_pos = eye + dir * near;\n\n        // modulate normal based on texture\n        for (int i = 0; i < 4; ++i) {\n            float wave_a = rand(vec2(float(i), 0.)) * radians(360.);\n            mat2 wave_dir = mat2(sin(wave_a), cos(wave_a), -cos(wave_a), sin(wave_a));\n            normal += .03 * (texture(iChannel1, .005 * wave_dir * hit_pos.xz + .02 * vec2(iTime, 0.)).rgb - .5);\n        }\n        \n\t\tnormal = normalize(normal);\n\n        // reflect\n\t\tdir = reflect(dir, normal);\n\n        // slightly tint the darker tones\n        lo_rgb = vec3(.95, .95, 1.);\n    }\n\n    vec3 col = pow(skybox(dir, sun_pos), vec3(gamma));\n    \n#if 1\n    vec3 lo_col;\n    vec3 hi_col;\n    {\n    \t// split color into two components based on luminosity\n    \t// modulate each one separately to preserve highlights\n    \tfloat t = smoothstep(.5, 1., dot(vec3(.21, .72, 0.07), col));\n    \tlo_col = (1. - t) * clamp(col, 0., 1.);\n    \thi_col = t * col;\n    }\n\n    col = lo_rgb * lo_col + hi_rgb * hi_col;\n#endif\n\n    fragColor = vec4(pow(col, vec3(1. / gamma)), 1.);\n}","name":"Image","description":"","type":"image"}]}