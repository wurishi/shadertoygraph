{"ver":"0.1","info":{"id":"NdcBRX","date":"1656858399","viewed":114,"name":"Cheese Caves","username":"alezen","description":"CONTROLS\nmove noise - UP, DOWN, LEFT, RIGHT\norbit - MOUSE\nmove - LEFT, RIGHT, UP, DOWN","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","noise","cheese","caves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float resFactor = 4.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv/resFactor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPS .01\n#define PI 3.14159\n\n\n//RAYMARCH\n\nmat3 lookAt(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(cameraPos - lookAtPoint); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n\nfloat gridLength(vec3 p) {\n    return max(max(abs(p.x), abs(p.y)), abs(p.z));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a,-b, k);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//sd fields\n\nfloat sdSphere( vec3 p, float r )\n{\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n//noise\n\nfloat hash1(float p)\n{\n \tp = fract(p * 2924.45764);\n    p += p*(p + 540.23);\n    return fract(p);\n}\n\nfloat hash1(vec2 p)\n{\n \tp = fract(p * vec2(325.23454, 874.45764));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nfloat hash1(vec3 p)\n{\n    return hash1(vec2(hash1(p.xy), p.z));\n}\n\nfloat noise(float p)\n{\n    float ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec2(1,0));\n    float o = p-ip;\n    o = smoothstep(0.,1.,o);\n    return a*(1. - o) + b*o;\n}\n\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec2(1,0));\n    float c = hash1(ip+vec2(0,1));\n    float d = hash1(ip+vec2(1,1));\n    vec2 o = p-vec2(ip);\n    o = smoothstep(0.,1.,o);\n    return (a*(1. - o.x) + b*o.x)*(1. - o.y) + (c*(1. - o.x) + d*o.x)*o.y;\n}\n\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p);\n    float a = hash1(ip);\n    float b = hash1(ip+vec3(1,0,0));\n    float c = hash1(ip+vec3(0,1,0));\n    float d = hash1(ip+vec3(1,1,0));\n    \n    float a1 = hash1(ip + vec3(0,0,1));\n    float b1 = hash1(ip + vec3(1,0,1));\n    float c1 = hash1(ip + vec3(0,1,1));\n    float d1 = hash1(ip + vec3(1,1,1));\n    vec3 o = p-vec3(ip);\n    //o = 1.-cos(o*PI);\n    //o*=.5;\n    o = smoothstep(0.,1.,o);\n    return\n    ((a*(1. - o.x) + b*o.x)*(1. - o.y) + (c*(1. - o.x) + d*o.x)*o.y)*(1. - o.z) +\n    ((a1*(1. - o.x) + b1*o.x)*(1. - o.y) + (c1*(1. - o.x) + d1*o.x)*o.y)*o.z;\n}\n\n//util\nivec2 splitToVec2(int i, int radix) {\n    ivec2 v;\n    v.x = i%radix;\n    v.y = i/radix;\n    return v;\n}\n\nivec3 splitToVec3(int i, int radix) {\n    ivec3 v;\n    v.x = i%radix;\n    v.y = i/radix;\n    v.z = v.y/radix;\n    v.y %= radix;\n    return v;\n}\n\n\n//IO\n#define CAM_POS_LOCATION ivec2(1,1)\n\nbool isLocated(vec2 fragCoord, ivec2 location) {\n    return length(fragCoord-vec2(location)) < 1.;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 getMouseRot() {\n     return vec2(-3.,1.)*PI*(iMouse.xy/iResolution.y - .5);\n}\n\nfloat getKey(int code)\n{\n    return texelFetch(iChannel0, ivec2(code,0),0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = getMouseRot();\n    vec2 res = iChannelResolution[1].xy;\n    vec2 uv = fragCoord/res;\n    vec4 color = texture(iChannel1,uv);\n    vec4 move = vec4(getKey(KEY_RIGHT) - getKey(KEY_LEFT),0.,getKey(KEY_UP)-getKey(KEY_DOWN),0.);\n    move.yz *= Rot(m.y);\n    move.xz *= Rot(m.x);\n    fragColor = color + move;\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_DIST 200.\n#define MAX_STEPS 128\n#define SURF_DIST .05\n\n#define LINE_WIDTH .4\n#define POINT_WIDTH .0\n#define POINT_JOIN_DIST .99\n\nconst float resFactor = 4.;\n\n\nvec2 getMouseRot() {\n     return vec2(-3.,1.)*PI*(iMouse.xy/iResolution.y - .5);\n}\n\nvec3 LIGHT_DIR = normalize(vec3(-3,-7,-7));\n\nvec3 genPoint(vec3 p) {\n\n    p = vec3(hash1(floor(p)) + 100.);\n    p.x = hash1(p.x);\n    p.y = hash1(p.x);\n    p.z = hash1(p.y);\n    \n    const float w = POINT_WIDTH + SURF_DIST;\n    \n    p *= 1.-w*2.;\n    p += w;\n    return p;\n}\n\n\nfloat sdCaves(vec3 p) {\n    float d = MAX_DIST;\n\n    const int scan_cells = 3;\n    const ivec3 offset = ivec3(-1);\n    const int sqr_scan_cells = scan_cells*scan_cells*scan_cells;\n        \n    for(int i=0;i<sqr_scan_cells-2;i++){\n        vec3 cell1 = vec3(splitToVec3(i, scan_cells) + offset) + p;\n        for(int j=i+1;j<sqr_scan_cells;j++){\n            vec3 cell2 = vec3(splitToVec3(j, scan_cells) + offset) + p;\n            cell1 = floor(cell1) + genPoint(cell1);\n            cell2 = floor(cell2) + genPoint(cell2);\n            if(gridLength(cell1-cell2) < POINT_JOIN_DIST)\n                d = smin(d, sdCapsule(p, cell1, cell2, LINE_WIDTH), .1);\n        }\n    }\n    return d;\n}\n\nfloat sdSpheres(vec3 p) {\n    return length(fract(p) - genPoint(p)) - POINT_WIDTH;\n}\n\n\nfloat scene(in vec3 p,out vec3 col)\n{\n\n    vec3 move = texture(iChannel0,vec2(0)).xyz;\n    float d = MAX_DIST;\n    float box = sdBox(p, vec3(20.));\n    const float k = .5;\n    if(box > k*2.)\n        d = box;\n    else\n        d = smax(box, -sdCaves(p*0.1 + move*0.1), k);//sdCaves(p*0.01);\n    col = vec3(.95,.8,.3);\n    return d;\n}\n\nvec3 raymarch(inout vec3 ro,vec3 rd,out float D)\n{\n    D=0.;\n    float d;\n    vec3 p=ro;\n    vec3 col;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        d=scene(p,col);\n        D+=d;\n        p+=rd*d;\n        if(D>MAX_DIST||d<SURF_DIST)\n            break;\n    }\n    ro = p;\n    return col;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 col;\n    \n    const float e = .01;\n    vec3 n = vec3(\n        scene(p+vec3(e,0,0), col) - scene(p-vec3(e,0,0),col),\n        scene(p+vec3(0,e,0), col) - scene(p-vec3(0,e,0),col),\n        scene(p+vec3(0,0,e), col) - scene(p-vec3(0,0,e),col)\n        );\n    return normalize(n);\n}\n\nfloat getLight(in vec3 p)\n{\n    vec3 n = getNormal(p);\n    float dif = dot(-LIGHT_DIR,n);\n    dif = clamp(dif,0.,1.);\n    dif *= .9;\n    dif += .1;\n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    fragCoord *= resFactor;\n    if(fragCoord.x > res.x || fragCoord.y > res.y){\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    vec2 m = getMouseRot();\n    vec2 uv = (fragCoord-.5*res)/res.y;\n    uv*=2.;\n    float D;\n    float orbitRadius = 50.;\n    vec3 origin = vec3(0.);\n    vec3 orbitVec = vec3(0.,0.,orbitRadius);\n    vec3 rd = normalize(vec3(uv,1));//R(uv, ro, vec3(0,1,0), 1.);\n    orbitVec.yz *= Rot(m.y);\n    orbitVec.xz *= Rot(m.x);\n    \n    vec3 ro = origin + orbitVec;\n    rd = lookAt(ro, origin) * rd;\n    \n    vec3 p = ro;\n    \n    \n    vec3 col = raymarch(p,rd,D);\n    if(D>=MAX_DIST)\n        col = vec3(.2,.4,1);\n    else\n    \tcol *= vec3(getLight(p));\n    col=pow(col,vec3(.6));\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}