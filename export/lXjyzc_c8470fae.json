{"ver":"0.1","info":{"id":"lXjyzc","date":"1727538207","viewed":60,"name":"Code 33c Mossy Rocks","username":"rattlehead","description":"A Basic ray marcher with simple diffuse lighting, texture mapping, and displacement mapping.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mouse","displacementmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code33c_mossy_rocks.txt\n// Re-implementing ray-marching\n// Displacement mapping\n//\n// Setup:\n// iChannel0: Textures -> (Page 2 -> Organic 4 | Page 2 -> Organic 3 | Page 1 -> Abstract 3),\n//            Filter: mipmap, Wrap: repeat\n// iChannel1: Textures -> Page 2 -> Pebbles, Filter: linear, Wrap: repeat\n// iChannel2: Textures -> Page 1 -> RGBA Gray Noise Medium, Filter: linear, Wrap: repeat\n//\n\n#define MAX_ITERATIONS 20000\n#define MAX_DISTANCE 10.\n#define MAX_SURFACE_DISTANCE 0.001\n#define PI  3.1415926536\n#define TAU 6.2831853072\n\nfloat sdBox(vec3 p, vec3 s, float roundness)\n{\n    vec3 d = roundness + abs(p) - abs(s);\n    return length(max(d, 0.)) + min(0., max(d.x, max(d.y, d.z))) - roundness;\n}\n\n// transformation matrix for rotation about the z-axis (xy-plane)\nmat3 rotateZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        c,-s, 0,\n        s, c, 0,\n        0, 0, 1\n    );\n}\n\n// transformation matrix for rotation about the y-axis (zx-plane)\nmat3 rotateY(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        c, 0, s,\n        0, 1, 0,\n       -s, 0, c\n    );\n}\n\n// transformation matrix for rotation about the x-axis (yz-plane)\nmat3 rotateX(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\n\nfloat sdRock(vec3 p, float relief)\n{\n    // base shape\n    vec3 size = vec3(1);\n    float d = sdBox(p, size, 0.001);\n\n    // sides\n    vec2 uv = vec2(atan(p.x, p.z) * 6. / TAU, p.y / 2.) + .5;\n    float displacement = texture(iChannel1, uv).r;\n    displacement *= smoothstep(1., .9, abs(p.y));\n    d -= relief * displacement;\n\n    uv = p.xz;\n\n    // top / bottom\n    displacement = texture(iChannel1, .5 * uv).r;\n    displacement *= smoothstep(.6, 1., abs(p.y));\n    d -= relief * displacement;\n\n    // top: grass\n    displacement = smoothstep(0., 1., texture(iChannel2, 1. * uv).r);\n    displacement *= smoothstep(.8, 1.6, p.y);\n    d -= .02 * displacement;\n\n    // drastically reduce step size, because of aggressive displacement\n    return .15 * d;\n}\n\nvec2 getSignedDistance(vec3 p, mat3 rot)\n{\n    float obj = 1.;\n    float d = sdRock(rot * (p + vec3(1.5,0,0)), .3);\n    float d2 = sdRock(rot * (p - vec3(1.5,0,0)), -.3);\n    if (d2 < d) {\n        d = d2;\n        obj = -1.;\n    }\n    return vec2(d, obj);\n}\n\nvec3 getNormal(vec3 p, mat3 rot)\n{\n    mat3 ignore = mat3(0);\n    vec2 e = vec2(.001,.0);\n    return normalize(getSignedDistance(p, rot).x - vec3(\n        getSignedDistance(p - e.xyy, rot).x,\n        getSignedDistance(p - e.yxy, rot).x,\n        getSignedDistance(p - e.yyx, rot).x\n    ));\n}\n\nvec3 getCamDir(vec2 uv, vec3 pos, vec3 trg, vec3 up, float zoom)\n{\n    vec3 forward = normalize(trg - pos);\n    vec3 right = cross(normalize(up), forward);\n    up = cross(forward, right);\n    return normalize(zoom * forward + uv.x * right + uv.y * up);\n}\n\nvec3 renderScene(vec2 uv)\n{\n    // start upright (=iMouse.xy == (0,0), but if mouse is moved, be upright at (.5w,.5h))\n    vec2 mouse = abs(sign(iMouse.xy)) * (2. * iMouse.xy - iResolution.xy) / iResolution.xy;\n    mat3 rot = rotateY(.25 * iTime) * rotateY(-mouse.x * PI) * rotateX(mouse.y * PI);\n\n    vec3 colScene = vec3(0);\n\n    float zoom = 1.5 + 1.5 * smoothstep(-.15, .15, -cos(iTime * .6));\n    vec3 ro = rotateY(3.6) * vec3(0,2,5);\n    vec3 rd = getCamDir(uv, ro, vec3(0), vec3(0,1,0), zoom);\n\n    float totalDistance = 0.;\n    // (x,y) = (distance, objectId)\n    vec2 stepDistance = vec2(10);\n    vec3 p = ro;\n    for (int iteration = 0; iteration < MAX_ITERATIONS && MAX_SURFACE_DISTANCE < stepDistance.x && totalDistance < MAX_DISTANCE; iteration++)\n    {\n        stepDistance = getSignedDistance(ro + rd * totalDistance, rot);\n        totalDistance += stepDistance.x;\n    }\n    if (totalDistance < MAX_DISTANCE)\n    {\n        mat3 ident = mat3(1,0,0,0,1,0,0,0,1);\n        vec3 p = ro + rd * totalDistance;\n        vec3 n = getNormal(p, rot);\n\n        float dif = dot(n, normalize(vec3(2,3,4))) * .5 + .6;\n        n = rot * n;\n        n = pow(n, vec3(2));\n        n /= n.x + n.y + n.z;\n        p += stepDistance.y * vec3(1.5, .0, .0);\n        p = rot * p;\n        vec3 colX = texture(iChannel0, p.yz).rgb;\n        vec3 colY = texture(iChannel0, p.zx).rgb;\n        vec3 colZ = texture(iChannel0, p.xy).rgb;\n\n        colScene = n.x * colX + n.y * colY + n.z * colZ;\n\n        colScene *= pow(dif, 2.);\n        colScene += .07;\n\n        // Greening on top\n        colScene.rb *= .7 + .3 * smoothstep(.8, .7, p.y + .1 * sin(120. * p.x) + .1 * sin(12. + 107. * p.z));\n        colScene = mix(colScene, smoothstep(0., 1., smoothstep(0., 1., colScene)), 0.6);\n    }\n\n    // add haze\n    vec3 haze = vec3(.15, .16, .20);\n    colScene = mix(colScene, haze, pow(min(1., totalDistance / MAX_DISTANCE), 2.));\n    return colScene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int AA = 1;\n    vec3 col = vec3(0);\n\n    for (int i = 0; i < AA; i++)\n    {\n        for (int j = 0; j < AA; j++)\n        {\n            // Normalized pixel coordinates (from -1 to 1)\n            vec2 uv = (2. * (fragCoord + vec2(i,j) / float(AA)) - iResolution.xy) / iResolution.x;\n            col += renderScene(uv);\n        }\n    }\n    col /= float(AA * AA);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}