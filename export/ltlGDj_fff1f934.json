{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"precision highp float;\n\nconst int ITERS = 80;\nconst float THRESHOLD = 0.0005;\nconst float MAX_T = 25.0;\n\nconst vec3 LIGHT_POS    = vec3(0.0, -4.0, 1.5);\nconst vec3 DIRECTIONAL_LIGHT = vec3(-0.683763, -2.73505, 1.02565);\n\nconst vec2 CIExy4874K = vec2(0.3840, 0.3516);\nconst vec2 D5000_ILLUMINANT = vec2(0.3457, 0.3586);\nconst vec2 D6500_ILLUMINANT = vec2(0.3127, 0.3297);\nconst vec2 LIGHT_CIExy = CIExy4874K;\n\n// BEGIN: https://raw.githubusercontent.com/ashima/webgl-noise/master/src/classicnoise2D.glsl\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// END: https://raw.githubusercontent.com/ashima/webgl-noise/master/src/classicnoise2D.glsl\n\n// A prettier version of cnoise, that is made by layering calls to cnoise.\nfloat cnoise2(in vec2 uv)\n{\n    return (\n          cnoise(uv * 0.5  + vec2(0.5))  * 0.5\n        + cnoise(uv * 2.0  + vec2(2.1))  * 0.25\n        + cnoise(uv * 4.0  + vec2(4.1))  * 0.125\n        + cnoise(uv * 8.0  + vec2(0.8))  * 0.0625\n    + 1.0) * 0.5 ;\n}\n\nfloat cloudnoise(in vec2 uv)\n{\n    float n = cnoise2(uv);\n    if ((n > 0.2 && n < 0.35) || (n > 0.4 && n < 0.46) || (n > 0.6 && n < 0.95))\n    {\n        return n;\n    }\n    return 0.0;\n}\n\n// Converts a CIE xy chromacity to sRGB.\nvec3 CIExyY_RGB(in vec2 cr)\n{\n    float Y = 1.0;\n    vec3 CIE = vec3(\n        Y * (cr.x / cr.y),\n        Y,\n        Y * ((1.0 - cr.x - cr.y) / cr.y));\n    \n    mat3 CIE_rgb = mat3(\n         3.2406, -1.5372, -0.4986,\n        -0.9689,  1.8758,  0.0415,\n         0.0557, -0.2040,  1.0570);\n    return pow(CIE*CIE_rgb, vec3(0.454));\n}\n\nfloat streakynoise(float x)\n{\n    float r = 1.0 / abs(0.1 + cos(x) - sin(x));\n    \t  r+= 1.0 / abs(0.1 + cos(x / 8.0) - sin(8.0 * x));\n    \t  r+= 1.0 / abs(0.1 + cos(x / 27.0) - sin(27.0 * x));\n    \t  r+= 1.0 / abs(0.1 + cos(x / 64.0) - sin(64.0 * x));\n    return clamp(r, 0.0, 35.0) / 35.0;\n}\n\nfloat rand(float x)\n{    \n    return fract(1.0 / sin(x * x *  x * 17.2375e4));\n}\n\nfloat rand(vec2 uv)\n{\n    float v = texture(iChannel1, uv).r;\n    return rand(v);\n}\n\nfloat sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat scene_dist(in vec3 p)\n{\n    float d =  sphere(p - vec3(0.5, 0.3, 2.0), 0.1);\n    d = min(sphere(p - vec3(\n        0.17 * cos(0.5 * iTime) + 0.5, \n        0.30 + 0.03 * (cos(.5 * iTime) + sin(0.5 * iTime)), \n        0.17 * sin(0.5 * iTime) + 2.0), 0.04)\n      , d);\n    return d;\n}\n\nvec3 normal(in vec3 p)\n{\n    // Took this pretty much straight from Ignacio's code, it computes the differentials in\n    // three axes. That's our distance field gradient and our \"normal\".\n\tvec3 stepsize = vec3(0.01, 0.0, 0.0);\n    vec3 N = vec3(\n        scene_dist(p + stepsize.xyz) - scene_dist(p - stepsize.xyz),\n        scene_dist(p + stepsize.yxz) - scene_dist(p - stepsize.yxz),\n        scene_dist(p + stepsize.yzx) - scene_dist(p - stepsize.yzx));\n    return normalize(N);\n}\n\nfloat raycast(in vec3 ro, in vec3 rd)\n{\n\tfloat t = 1.0;\n    for (int i = 0; i < ITERS; ++i)\n    {\n        float d = scene_dist(ro + rd * t);\n        if (d < THRESHOLD || d > MAX_T)\n        {\n            break;\n        }\n        t += d;\n    }\n    \n    return t;    \n}\n\n// Also from Ignacio! My own one broke, so I couldn't bother.\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = scene_dist(ro + rd*t);\n        res = min(res, 2.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t>tmax ) \n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xx;\n    \n    vec3 light_colour = CIExyY_RGB(LIGHT_CIExy) * 0.4;\n    vec3 color        = CIExyY_RGB(D5000_ILLUMINANT);\n    vec3 halo_colour  = vec3(0.25, 0.3, 0.6);\n    vec3 ambient      = color * 0.01;   \n    \n    vec3 ro = vec3(uv, 0.0);\n    vec3 rd = vec3(0.0, 0.0, 1.0);\n    \n    float d = raycast(ro, rd);\n    float atmo = pow(1.0 - softshadow(ro, rd, 0.1, 3.5), 6.0);\n    \n    vec3 finalColour = vec3(0.0);\n    if (d > MAX_T)\n    {\n        float stars = texture(iChannel0, uv, 5.8).r;\n        float stars2 = texture(iChannel1, uv + vec2(iTime * 0.03) , 5.5).r;\n        finalColour = \n              vec3(0.0, 0.2, 0.4) * stars \n            + vec3(0.2) * pow(stars2, 2.0);\n\n    }\n   \telse\n    {\n        vec3 surfpos = ro + rd * d;\n        vec3 L =  normalize(-DIRECTIONAL_LIGHT) * softshadow(ro, normalize(-DIRECTIONAL_LIGHT), 0.1, 10.0);\n        vec3 N = normal(surfpos);\n        float fresnel = pow(max(1.0 - dot(N, -rd), 0.0), 1.5);\n    \n        float shade = softshadow(surfpos, L, 0.08, 1.0);\n        \n        float streaks = (streakynoise(sin(N.y - 3.14) + cos(0.17 * N.x) * sin(0.17 * N.z)) + 0.7);\n        mat3 crotY = mat3(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0);\n        vec3 cN = crotY * N;\n        float clouds = cloudnoise(vec2(atan(cN.y / cN.x), acos(cN.z)) * 4.0 + vec2(iTime * 0.4));\n              clouds += cloudnoise(vec2(atan(cN.y / cN.x), acos(cN.z)) * 2.0 - vec2(iTime * 0.1));\n                \n        float lambert = max(dot(N, L), 0.0) * shade *1.5;\n        atmo *= 0.4;\n        \n\t\tfinalColour += \n              ambient\n            + lambert * vec3(0.3) * (fresnel + 0.4) *  clouds * (0.5 - streaks)\n            + mix(\n               \tstreaks * color * lambert * light_colour * 0.8, \n                halo_colour * 2.0, \n                fresnel * clamp(lambert, 0.42, 1.0));\n    }\n    \n    finalColour += vec3(0.0, 0.25, 0.4) * atmo;\n    fragColor = vec4(finalColour + vec3(0.56, 0.4, 0.4) * uv.x * uv.y * 3.0, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltlGDj","date":"1425505868","viewed":731,"name":"Planet and moon","username":"skurmedel","description":"A bit of a work in progress.\n\nA moon and a planet rendered using raycasting and distance fields.\n\nI don't really like the looks of the clouds, and the moon is just a clone of the planet, which needs fixing.\n\nPerformance in FF seems pretty poor too.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","space","distance","function"],"hasliked":0,"parentid":"","parentname":""}}