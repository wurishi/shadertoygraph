{"ver":"0.1","info":{"id":"XXXBWN","date":"1728369222","viewed":38,"name":"Simple VHS","username":"skymen","description":"Simplified this shader:\nhttps://www.shadertoy.com/view/XlsczN\n\nTo only use 2 textures and a single pass","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["distortion","glitch","analog","vhs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//YIQ/RGB shit\nvec3 rgb2yiq(vec3 c) {\n  return vec3(\n    (0.2989 * c.x + 0.5959 * c.y + 0.2115 * c.z),\n    (0.5870 * c.x - 0.2744 * c.y - 0.5229 * c.z),\n    (0.1140 * c.x - 0.3216 * c.y + 0.3114 * c.z)\n  );\n}\n\nvec3 yiq2rgb(vec3 c) {\n  return vec3(\n    (1.0 * c.x + 1.0 * c.y + 1.0 * c.z),\n    (0.956 * c.x - 0.2720 * c.y - 1.1060 * c.z),\n    (0.6210 * c.x - 0.6474 * c.y + 1.7046 * c.z)\n  );\n}\n\n// Simple hash function to create noise\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n// Function to return medium grey noise\nfloat greyNoise(vec2 uv) {\n    // Scale UV coordinates to control noise frequency\n    float scale = 10.0;  // adjust this value to control noise size\n    uv *= scale;\n    \n    // Generate noise value in the range [0, 1]\n    float noise = hash(floor(uv));\n    \n    // Shift noise to be centered around medium grey (0.5)\n    return 0.4 + noise * 0.2; // results in noise values in [0.4, 0.6] range\n}\n\nvec2 Circle(float Start, float Points, float Point)\n{\n  float Rad = (3.141592 * 2.0 * (1.0 / Points)) * (Point + Start);\n  //return vec2(sin(Rad), cos(Rad));\n  return vec2(-(.3 + Rad), cos(Rad));\n}\n\nvec3 Blur(vec2 uv, float f, float d) {\n  //  d=abs(d);\n  float t = (sin(iTime * 5.0 + uv.y * 5.0)) / 10.0;\n  float b = 1.0;\n  //t=sin(iTime*5.0+f)/10.0;\n  t = 0.0;\n  vec2 PixelOffset = vec2(d + .0005 * t, 0);\n\n  float Start = 2.0 / 14.0;\n  vec2 Scale = 0.66 * 4.0 * 2.0 * PixelOffset.xy;\n\n  vec3 N0 = texture(iChannel0, uv + Circle(Start, 14.0, 0.0) * Scale).rgb;\n  vec3 N1 = texture(iChannel0, uv + Circle(Start, 14.0, 1.0) * Scale).rgb;\n  vec3 N2 = texture(iChannel0, uv + Circle(Start, 14.0, 2.0) * Scale).rgb;\n  vec3 N3 = texture(iChannel0, uv + Circle(Start, 14.0, 3.0) * Scale).rgb;\n  vec3 N4 = texture(iChannel0, uv + Circle(Start, 14.0, 4.0) * Scale).rgb;\n  vec3 N5 = texture(iChannel0, uv + Circle(Start, 14.0, 5.0) * Scale).rgb;\n  vec3 N6 = texture(iChannel0, uv + Circle(Start, 14.0, 6.0) * Scale).rgb;\n  vec3 N7 = texture(iChannel0, uv + Circle(Start, 14.0, 7.0) * Scale).rgb;\n  vec3 N8 = texture(iChannel0, uv + Circle(Start, 14.0, 8.0) * Scale).rgb;\n  vec3 N9 = texture(iChannel0, uv + Circle(Start, 14.0, 9.0) * Scale).rgb;\n  vec3 N10 = texture(iChannel0, uv + Circle(Start, 14.0, 10.0) * Scale).rgb;\n  vec3 N11 = texture(iChannel0, uv + Circle(Start, 14.0, 11.0) * Scale).rgb;\n  vec3 N12 = texture(iChannel0, uv + Circle(Start, 14.0, 12.0) * Scale).rgb;\n  vec3 N13 = texture(iChannel0, uv + Circle(Start, 14.0, 13.0) * Scale).rgb;\n  vec3 N14 = texture(iChannel0, uv).rgb;\n\n  vec4 clr = texture(iChannel0, uv);\n  float W = 1.0 / 15.0;\n\n  clr.rgb =\n    (N0 * W) +\n    (N1 * W) +\n    (N2 * W) +\n    (N3 * W) +\n    (N4 * W) +\n    (N5 * W) +\n    (N6 * W) +\n    (N7 * W) +\n    (N8 * W) +\n    (N9 * W) +\n    (N10 * W) +\n    (N11 * W) +\n    (N12 * W) +\n    (N13 * W) +\n    (N14 * W);\n\n  return vec3(clr.xyz) * b;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  // float d = (iResolution.x/500.0)/2.0-.1*iMouse.x/50.0;\n  float d = .1 * iMouse.x / 50.0;\n  // d=.1-round(mod(iTime/3.0,1.0))*.1;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float s = (texture(iChannel1, fragCoord).r); // - texture(iChannel1,vec2(0.01+uv.y/1000.0,1.0)).r)*2.0;\n\n  float e = min(.30, pow(max(0.0, cos(uv.y * 4.0 + .3) - .75) * (s + 0.5) * 1.0, 3.0)) * 25.0;\n  s -= pow(texture(iChannel1, vec2(0.01 + (uv.y * 32.0) / 32.0, 1.0)).r, 1.0);\n  uv.x += e * abs(s * 3.0);\n  float r = greyNoise(vec2(mod(iTime * 10.0, mod(iTime * 10.0, 256.0) * (1.0 / 256.0)), 0.0)) * (2.0 * s);\n  uv.x += abs(r * pow(min(.003, (uv.y - .15)) * 6.0, 2.0));\n\n  d = .051 + abs(sin(s / 4.0));\n  float c = max(0.0001, .002 * d);\n  vec2 uvo = uv;\n  // uv.x+=.1*d;\n  fragColor.xyz = Blur(uv, 0.0, c + c * (uv.x));\n  float y = rgb2yiq(fragColor.xyz).r;\n\n  uv.x += .01 * d;\n  c *= 6.0;\n  fragColor.xyz = Blur(uv, .333, c);\n  // texture(iChannel0, uv);\n  float i = rgb2yiq(fragColor.xyz).g;\n\n  uv.x += .005 * d;\n\n  c *= 2.50;\n  fragColor.xyz = Blur(uv, .666, c);\n  float q = rgb2yiq(fragColor.xyz).b;\n\n  fragColor.xyz = yiq2rgb(vec3(y, i, q)) - pow(s + e * 2.0, 3.0);\n  fragColor.xyz *= smoothstep(1.0, .999, uv.x - .1);\n\n  // fragColor.xyz-=min(0.10,pow(uv.x,3.0))*d;\n}\n","name":"Image","description":"","type":"image"}]}