{"ver":"0.1","info":{"id":"wdfyD8","date":"1584656677","viewed":845,"name":"Geometric Light Source v 2.","username":"julianlumia","description":":octopusballoon:\nfurther experimentation w reflections","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 30\n#define MAX_DIST 20.\n#define SURF_DIST .001\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\n\nvec2 GetDist(vec3 p) {\n vec2 d;\n vec3 p2 = p;\n float gap = 1.;\n p2 = mod(p + gap,2.0 * gap) - gap;\n vec2 box = vec2(sdBox(p2-vec3(0,0.,.0), vec3(0.2,0.73,.3)),3);\n vec2 box2 = vec2(sdBox(p2-vec3(0,0.,.0), vec3(0.8,.1,1.)),3);\n vec2 box3 = vec2(sdBox(p2-vec3(0,0.,0), vec3(1.,.2,.3)),1);\n float prev = 1.;\n vec3 p1 = vec3( p- vec3(1.,1.0,sin(iTime-3.)+iTime)); \n float the = iTime *1.3;\n p1.x = abs(p1.x)-.9;\n p1.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *0.1;\n p1.zx *= mat2(cos(the), -sin(the), sin(the), cos(the));\n p2 = vec3( p- vec3(1.,1.,0.3+iTime)); \n the = iTime *-.5;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox =vec2( sdOctahedron( p1,.2),3);\n float size = .35;\n vec2 dbox2 = vec2(sdBox( p2,vec3(size)),3);\n vec2 dbox20 = vec2(sdOctahedron( p2,(size)),3);\n\n    p2 = vec3( p- vec3(1.,1.,0.5+iTime)); \n the = iTime *-0.2;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.4;\n p2.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2 = abs(p2)-1.5;\n vec2 dbox4 = vec2(sdSphere( p2-vec3(0.,-0.,-.0),(.02)),1);\n vec3 p3 = vec3( p- vec3(1.,1.,1.+iTime-2.)); \n the = iTime *-.5;\n p3.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p3.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox5 = vec2(sdBox( p3,vec3(.2)),1);\n g1 +=1./(.1+pow(abs(dbox2.x),2.));\n g2 +=1./(0.1+pow(abs(dbox.x),5.));\n g3 +=1./(0.1+pow(abs(dbox4.x),6.));\n g4 +=1./(1.+pow(abs(dbox5.x),5.));\n dbox5.x=   min(dbox5.x,dbox4.x);\n dbox2.x = mix (dbox2.x,dbox20.x,sin(iTime)*0.5+.7);\n dbox = condmin(dbox,dbox2);\n dbox = condmin(dbox,dbox5);\n box = condmin(box3,box);\n box = condmin(box2,box);\n dbox = condmin(dbox,box);\n d = dbox;\n return d ;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=0.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 20; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>100.) break;\n  t += d * 1.;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n// vec3 eye = 1.0*vec3(1.,1.,iTime+abs((sin(iTime*.8)))+1.1);\n vec3 eye = 1.0*vec3(sin(iTime)*0.2+1.,cos(iTime*0.3)*0.1+1.,iTime+1.4);\n vec3 hoek = vec3(1,1.,1);  \n float   the = sin(iTime*1.)-2.5;\n// hoek.yz *= mat2(cos(the), -sin(the), sin(the), cos(the))*100.;\n//   hoek.yz *= mat2(cos(the), -sin(the), sin(the), cos(the))*200.;\nmat3 camera = setCamera( eye, hoek,sin(iTime*0.2));\n float fov = .5;\n vec3 dir = camera * normalize(vec3(uv, fov));\n float lensResolution = 4.;\n float focalLenght =1.;\n float lensAperture = .15;\n float inc = 1./lensResolution;\n float start = inc/2.-1.;\n vec3 focalPoint = eye + (dir * focalLenght);\n for (float stepX = start; stepX < 0.5; stepX+=inc){\n for (float stepY = start; stepY < .5; stepY+=inc){\n vec2 shiftedOrigin = vec2(stepX, stepY) * lensAperture;\n  if (length(shiftedOrigin)<(lensAperture/2.7125)){\n  vec3 shiftedRayOrigin = eye;\n  shiftedRayOrigin.x += shiftedOrigin.x;\n  shiftedRayOrigin.y += shiftedOrigin.y;\n  vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n  vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\n  float t =d.x *1.;   \n   if(t>.01){\n    vec3 baseColor = vec3(0.,0.,0.);\n    shiftedRayOrigin += shiftedRay * t;\n    vec3 sn = GetNormal(shiftedRayOrigin);\n    shiftedRay = reflect(shiftedRay, sn);\n    if(d.y==3.) traceRef(shiftedRayOrigin +  shiftedRay*.1, shiftedRay);\n    }\n   }\n  }\n }\n vec3 d;\n d *= marchCount * vec3(1., 1.,1.) * 1.;\n d +=g1*vec3(0.0006)*vec3(sin(iTime-2.),0.3,cos(iTime-2.)-.5);    \n d +=g2*vec3(0.00045)*vec3(cos(iTime),1,1);    \n d +=g3*vec3(0.002)*vec3(abs(sin(iTime-2.)),.5,1.)*abs(cos(iTime*0.5));    \n d +=g4*vec3(0.01)*vec3(abs(sin(iTime)),0,0);    \n vec3 sky = vec3(1., 1., 1.);\n d = mix(sky, d, 1.0/(d.x*d.x/1./1.*.1+1.005)); \n //d*= 1.;\n fragColor = vec4(d,1.0);\n}","name":"Image","description":"","type":"image"}]}