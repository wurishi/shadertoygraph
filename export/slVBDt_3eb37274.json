{"ver":"0.1","info":{"id":"slVBDt","date":"1669885925","viewed":139,"name":"Hexagon Triangles Loading ","username":"Rutilius","description":"A hexagonal loading loop animation made up with triangles","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["2d","triangle","animation","hexagon","loop","loading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define the speed of the loading animation\n// ----------------------------------------\n#define SPEED 0.6\n// Define the size of the loading animation\n// ----------------------------------------\n#define SIZE 1.\n\n// Define the percetage of the animation to end opening the triangle\n// This should be in the range (0., 1.) and must be before the TRIANGLE_CLOSE_START\n// ----------------------------------------\n#define TRIANGLE_OPEN_END 0.3\n\n// Define the percentage of the animation to start closing the triangle\n// This should be in the range (0., 1.) and must be after the TRIANGLE_OPEN_END\n// ----------------------------------------\n#define TRIANGLE_CLOSE_START 0.7\n\n// Define how much time should pass before open next triangle\n// A lower number will show more triangles \n// A bigger number will show less triangles\n// ----------------------------------------\n#define OVERLAP_TIME 0.3\n\n// Define the final color of the animation\n// ----------------------------------------\n#define TONE vec3(0.7137, 0.1333, 0.1333)\n\n\n// Uncomment the following line to make the loading follow the mouse position when pressed\n// ----------------------------------------\n// #define FOLLOW_MOUSE\n\n// Needed constants do not touch this ones\n// ----------------------------------------\n#define HEXAGON_TRIANGLE 6\n#define PI    3.141592653589793\n#define DEG2RAD    0.0174532925\n// Useful macros\n// ----------------------------------------\n#define deg2rad(degree) (degree * DEG2RAD)\n#define clamp01(f) clamp(f, 0., 1.)\n#define inv(f) (1. - f)\n#define lerp(a, b, t) mix(a, b, t)\n\n// Utils functions\n// ----------------------------------------\nmat2 rotate2d(float theta) { return mat2(cos(theta) , sin(theta), -sin(theta), cos(theta)); }\nfloat map(float value, float low1, float high1, float low2, float high2) { return low2 + (value - low1) * (high2 - low2) / (high1 - low1); }\n\n// Normalize the coordinate respecting the aspect ratio of the viewport\n// ----------------------------------------\nvec2 normCoord(vec2 coord) {\n    vec2 nc = (coord * 2. /iResolution.xy) - 1.;\n    nc.x *= iResolution.x/iResolution.y;\n    return nc;\n}\n\n// Draw a triangle at position p and with the vertex at p0, p1, p2\n// ----------------------------------------\nfloat triangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    // Compute vectors        \n    vec2 v0 = p2 - p0;\n    vec2 v1 = p1 - p0;\n    vec2 v2 = p  - p0;\n\n    // Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    // Compute barycentric coordinates\n    float invDenom = 1. / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // Check if point is in triangle\n    return float((u >= 0.) && (v >= 0.) && (u + v < 1.)) * (u + v);\n}\n\n\n// Draw an animation of open and close of single equilateral triangle\n// The animation is opening from bottom to up and closing from right bottom to left top\n// Will be drow at position 'p' starting from on the left bottom vertex \n// With dimension 'size'\n// And with time of animation 't' should be in range [0., 1.]\n// ----------------------------------------\nfloat animation_equilateral_triangle(vec2 p, float size, float t) {\n    p /= size;\n    \n    // Unitary Equilateral Triangle Coords\n    const vec2 A = vec2(1., 0.);    \n    const vec2 B = vec2(0., 0.);\n    const vec2 C = vec2(0.5, 0.866);\n    \n    vec2 rA = A;\n    vec2 rC = C;\n    \n    float mask = 1.;\n    \n    // Manage animation\n    const float endOpenTime = TRIANGLE_OPEN_END;\n    const float startCloseTime = TRIANGLE_CLOSE_START;\n    if(t < endOpenTime) {\n        float dt = map(t, 0., endOpenTime, 0., 1.);\n        \n        rC = vec2(C.x, lerp(0., C.y, dt));\n        mask = lerp(0., 1., dt);\n        \n    } else if(t > startCloseTime) {\n        float dt = map(t, startCloseTime, 1., 0., 1.);\n        vec2 BA = A - B;\n        vec2 BC = C - B;\n        vec2 BCpA = B + dot(BA, BC) / dot(BC, BC) * BC;\n        \n        rA = vec2(lerp(A.x, BCpA.x, dt), lerp(A.y, BCpA.y, dt));\n        mask = lerp(1., 0., dt);\n    }\n\n    return inv(step(triangle(p, rA, B, rC), 0.)) * mask;\n}\n\n\n// Draw a triangle with open close animation inside an hexagon\n// Will draw at position 'p' the center of the hexagon\n// With dimension 'size'\n// Will choose the triangle with the index 'i' this value will be evaluate as (i % 6)\n// And with time of animation 't' will be clamped into range [0., 1.]\n// ----------------------------------------\nfloat animate_triangle_hexagon(vec2 p, float size, int i, float t) {\n    float deg = (-360. * (float(i) / float(HEXAGON_TRIANGLE)));\n    vec2 newPos = rotate2d(deg2rad(deg)) * p;\n\n    t = clamp01(t); \n    return animation_equilateral_triangle(newPos, SIZE, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = normCoord(fragCoord.xy);\n    float time = (fract(iTime*SPEED));\n    \n    #ifdef FOLLOW_MOUSE\n    vec2 mousePos = normCoord(iMouse.xy);\n    vec2 pos = uv - mousePos;\n    #else\n    vec2 pos = uv;\n    #endif\n    \n    const int count = HEXAGON_TRIANGLE;\n    const float fcount = float(count);\n    const float overlap = OVERLAP_TIME;\n    \n    float r = 0.;\n    \n    // Draw the six triangle with modulate time\n    for (int i = 0; i < count; i++) {\n        float timeSlot = float(i) * overlap;\n        float elements = fcount * overlap;\n\n        // Visualization of this formula at https://www.desmos.com/calculator/me4pvhjug0\n        float repetition = mod(time * elements - timeSlot, elements);\n        r += animate_triangle_hexagon(pos, SIZE, i, repetition);\n    }\n    \n    // Output to screen\n    fragColor = vec4(TONE * r, 1.);\n}\n\n\n","name":"Image","description":"","type":"image"}]}