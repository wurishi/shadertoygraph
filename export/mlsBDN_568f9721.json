{"ver":"0.1","info":{"id":"mlsBDN","date":"1692978840","viewed":62,"name":"bad wfcÕè","username":"01000001","description":"First wfc experiment. Algorithm could be improved, but I lost interest and moved on. Good enough for a first attempt.","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["collapse","wfc","emergence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Add chromatic aberration!\n\n// Add a pipe merge (three ends)\n\nfloat t = .25;\nvoid mainImage( out vec4 O, in vec2 U ){\n    vec2 r = iResolution.xy;\n    \n    U -= iMouse.x < 1. && iMouse.y < 1.?vec2(0):iMouse.xy - r;\n    if (U.y < 0.) U.y += (r.y/res)*r.y;\n    \n    \n    vec2 uv = U/r;\n    O = texture(iChannel0, U/r * res/iResolution.y);\n    \n    vec2 localUV = ((U)/r.y - O.xy)*res + .5;\n    \n    \n    O.xy = localUV;\n    \n    if (O.z <= 3.){\n    \n        for(float i = 0.; i < O.z; i++){\n            localUV *= mat2x2(0, 1, -1, 0);\n            localUV += vec2(0, 1);\n        }\n        \n        O.w = smoothstep(0., 1./r.y, (t-abs(.5-length(localUV))*2.));\n        \n        // Curved pipes\n        \n    } else if (O.z <= 5.){\n    \n        for(float i = 0.; i < O.z; i++){\n            localUV *= mat2x2(0, 1, -1, 0);\n            localUV += vec2(0, 1);\n        }\n\n        O.w = smoothstep(0., 1./r.y, t-abs(localUV.y-.5)*2.);\n        \n        // Straight pipes\n    }\n\n    \n    //if (iFrame%120 < 30)\n    O = min(texture(iChannel0, U/r * res/iResolution.y), O);\n    // Ostrich algorithm! Anything that doesn't converge\n    // pretend it doesn't exist until it does :D\n    \n    //O = texture(iChannel0, U/r * res/iResolution.y);\n\n\n    O = O.wwww;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    if (iFrame < 20){\n        O = vec4(0);\n        O.xy = U/res;\n        float rs = round((res-1.)*.5)*2. + 1.;// Must be odd to pick spawn\n        if (length((2.*U-rs)/rs) < .01){\n            O.w = 1.;\n        }\n    } else {\n    \n        O = texture(iChannel0, U/r);\n        O.xy = U/res;\n\n        \n        float a = 0.;\n        a += texture(iChannel0, (U + vec2(0 , 1))/r).w;\n        a += texture(iChannel0, (U + vec2(0 ,-1))/r).w;\n        a += texture(iChannel0, (U + vec2(1 , 0))/r).w;\n        a += texture(iChannel0, (U + vec2(-1, 0))/r).w;\n        if (a == 0.) return; // Do nothing if no definite neighbours\n\n        float n = round(hash(uvec3(int(U.x), int(U.y), iFrame)).x * types);\n        float rand = hash(uvec3(int(U.x), iFrame, int(U.y))).x;\n        if (O.w == 0. || (a < 4. && rand < 1./speed)){\n            O.z = n;\n            O.w = 0.;\n        } else if (O.w > .0){\n            return;\n        }\n        \n        float up   = texture(iChannel0, (U + vec2(0 , 1))/r).z;\n        float down = texture(iChannel0, (U + vec2(0 ,-1))/r).z;\n        float right= texture(iChannel0, (U + vec2(1 , 0))/r).z;\n        float left = texture(iChannel0, (U + vec2(-1, 0))/r).z;\n        \n        bool u = false;\n        bool d = false;\n        bool g = false;\n        bool l = false;\n\n\n        // Is there a connector there?\n        u = u || up == 0.    || up == 1.    || up == 5.    ;\n        d = d || down == 2.  || down == 3.  || down == 5.  ;\n        g = g || right == 0. || right == 3. || right == 4. ;\n        l = l || left == 1.  || left == 2.  || left == 4.  ;\n\n\n        /*\n        if (U.y == .5) d = true;\n        if (U.y == res + .5) u = true;\n        if (U.x == .5) l = true;\n        if (U.x > (res * r.x/r.y) - .5) g = true;\n        \n        //*/// make the borders all connectors\n\n        int matches = 0;\n        matches += int(false\n            || (O.z == 0. && d)\n            || (O.z == 1. && d)\n            || (O.z == 2. && u)\n            || (O.z == 3. && u)\n            || (O.z == 4. && g)\n            || (O.z == 5. && u)\n        );\n        \n        matches += int(false\n            || (O.z == 0. && l)\n            || (O.z == 1. && g)\n            || (O.z == 2. && g)\n            || (O.z == 3. && l)\n            || (O.z == 4. && l)\n            || (O.z == 5. && d)\n        );\n        \n        if (matches > 1){\n            O.w = 1.;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define res (cos(iTime*.3)*10. + 21.)\n#define types 5.\n#define speed 11.\n#define pi 3.14159\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n","name":"Common","description":"","type":"common"}]}