{"ver":"0.1","info":{"id":"Mdd3Dn","date":"1449099621","viewed":449,"name":"C64 Rasterbars animated","username":"104","description":"Demoscene effect simulation. Looped gradient functions with \"plateau\" for a really bad blurring effect (should actually be post). Raster sync glitch simulation. Click to see C64 background color.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["c64","raster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// c64 palette\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\n\n\n// not sure the best curve to use for mixing. linear looks nice to me though; better\n// than smoothstep and smootherstep.\n// smoothstep is of course the fastest though.\nfloat gradientStep(float edge0, float edge1, float x)\n{\n    return smoothstep(edge0, edge1, x);\n}\n\n\n\n// edge colors will naturally get slightly more intensity because they don't blend with\n// anything on the left/right.\nvec3 gradient3(float t, vec3 c1, vec3 c2, vec3 c3)\n{\n    const float colCount = 3.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.0 * (bandSize/2.);\n    t -= bandSize*.5;\n\treturn\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, t-bandSize*0.)))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, bandSize*2.-t)))\n        ;\n}\n\n// loops properly around edges\nvec3 gradientLoop(float t, vec3 c1, vec3 c2, vec3 c3)\n{\n    const float colCount = 3.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.8 * (bandSize/2.);\n    t = fract(t);\n    t -= bandSize*.5;// center bands\n\treturn\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*-1.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*0.))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        ;\n}\n\nvec3 gradientLoop(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5)\n{\n    const float colCount = 5.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.8 * (bandSize/2.);\n    t = fract(t);\n    t -= bandSize*.5;// center bands\n\treturn\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*-1.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*0.))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*4.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*5.))))\n        ;\n}\n\nvec3 gradientLoop(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6)\n{\n    const float colCount = 6.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.8 * (bandSize/2.);\n    t = fract(t);\n    t -= bandSize*.5;// center bands\n\treturn\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*-1.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*0.))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*4.))))\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*5.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*6.))))\n        ;\n}\n\nvec3 gradientLoop(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6, vec3 c7, vec3 c8)\n{\n    const float colCount = 8.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.8 * (bandSize/2.);\n    t = fract(t);\n    t -= bandSize*.5;// center bands\n\treturn\n        + (c8 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*-1.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*0.))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*4.))))\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*5.))))\n        + (c7 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*6.))))\n        + (c8 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*7.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*8.))))\n        ;\n}\n\nvec3 gradient16(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6, vec3 c7, vec3 c8, vec3 c9, vec3 c10, vec3 c11, vec3 c12, vec3 c13, vec3 c14, vec3 c15, vec3 c16)\n{\n    const float colCount = 16.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.3 * (bandSize/2.);\n    t -= bandSize*.5;\n\treturn\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*0.))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*4.))))\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*5.))))\n        + (c7 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*6.))))\n        + (c8 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*7.))))\n        + (c9 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*8.))))\n        + (c10 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*9.))))\n        + (c11 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*10.))))\n        + (c12 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*11.))))\n        + (c13 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*12.))))\n        + (c14 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*13.))))\n        + (c15 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*14.))))\n        + (c16 * (1.-gradientStep(plateauSize,bandSize-plateauSize, bandSize*15.-t)))\n        ;\n}\n\n// loops properly around edges\nvec3 gradientLoop(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6, vec3 c7, vec3 c8, vec3 c9, vec3 c10, vec3 c11, vec3 c12, vec3 c13, vec3 c14, vec3 c15, vec3 c16)\n{\n    const float colCount = 16.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.4 * (bandSize/2.);\n    t = fract(t);\n    t -= bandSize*.5;\n\treturn\n        + (c16 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*-1.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*0.))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*4.))))\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*5.))))\n        + (c7 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*6.))))\n        + (c8 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*7.))))\n        + (c9 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*8.))))\n        + (c10 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*9.))))\n        + (c11 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*10.))))\n        + (c12 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*11.))))\n        + (c13 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*12.))))\n        + (c14 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*13.))))\n        + (c15 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*14.))))\n        + (c16 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*15.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*16.))))\n        ;\n}\n\n\n// loops properly around edges\nvec3 gradientLoop(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 c5, vec3 c6, vec3 c7, vec3 c8, vec3 c9, vec3 c10, vec3 c11, vec3 c12, vec3 c13, vec3 c14)\n{\n    const float colCount = 14.;\n    const float bandSize = 1./colCount;\n    const float plateauSize = 0.4 * (bandSize/2.);\n    t = fract(t);\n    t -= bandSize*.5;\n\treturn\n        + (c14 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*-1.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*0.))))\n        + (c2 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*1.))))\n        + (c3 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*2.))))\n        + (c4 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*3.))))\n        + (c5 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*4.))))\n        + (c6 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*5.))))\n        + (c7 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*6.))))\n        + (c8 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*7.))))\n        + (c9 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*8.))))\n        + (c10 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*9.))))\n        + (c11 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*10.))))\n        + (c12 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*11.))))\n        + (c13 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*12.))))\n        + (c14 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*13.))))\n        + (c1 * (1.-gradientStep(plateauSize,bandSize-plateauSize, abs(t-bandSize*14.))))\n        ;\n}\n\n// specialized gradient functions\nvec3 gradient3(float t)\n{\n    return gradient3(t, color2, color3, color4);\n}\nvec3 gradientLoop3(float t)\n{\n    return gradientLoop(t, color2, color3, color4);\n}\nvec3 gradient16(float t)\n{\n    return gradient16(t, color0, color1, color2, color3, color4, color5, color6, color7, color8, color9, colorA, colorB, colorC, colorD, colorE, colorF);\n}\nvec3 gradientLoop16(float t)\n{\n    return gradientLoop(t, color0, color1, color2, color3, color4, color5, color6, color7, color8, color9, colorA, colorB, colorC, colorD, colorE, colorF);\n}\n\n\n\n\n\nvec3 gradientLoopBlue(float t)\n{\n    return gradientLoop(t, color0, color6, colorE, color3, color1);\n}\n\nvec3 gradientLoopBlue2(float t)\n{\n    return gradientLoop(t, color0, color6, colorE, color3, color1, color3, colorE, color6);\n}\n\nvec3 gradientLoopGreen2(float t)\n{\n    return gradientLoop(t, color0, color5, colorD, color1, colorD, color5);\n}\n\nvec3 gradientBlueGreen(float t)\n{\n    return gradientLoop(t,\n                        color0, color5, colorD, color1, colorD, color5,// green\n                        color0, color6, colorE, color3, color1, color3, colorE, color6// blue\n                       );\n}\n\nfloat quantize(float x, float p)\n{\n    return floor(x/p)*p;\n}\nvec2 quantize(vec2 x, float p)\n{\n    return floor(x/p)*p;\n}\n\nvoid mainImage( out vec4 o, in vec2 i)\n{\n    vec2 fragCoord = i;\n    vec2 uv = i/iResolution.xy;\n        \n    // simulate scan line timing problem\n    float pixelSize = 1.;\n    vec2 res = iResolution.xy / pixelSize;\n    i = floor(i/pixelSize);\n\n    float linearPixel = i.x + i.y*res.x;\n    float simulatedScanWidth = res.x * 1.02;\n    i.y = floor(linearPixel / simulatedScanWidth);\n\n    vec2 uvScaled = quantize(i, pixelSize)/res;\n\n    float gradOffset = uvScaled.y + iDate.w*.1;\n    \n    float program = mod(iDate.w, 4.);\n    if(program < 1.)\n\t    o = gradientLoopGreen2(gradOffset*24.).xyzz;\n    else if(program < 2.)\n\t    o = gradientLoopBlue2(gradOffset*24.).xyzz;\n    else if(program < 3.)\n\t    o = gradientBlueGreen(gradOffset*12.).xyzz;\n    else\n    {\n\t    o = gradientLoop16(gradOffset*3.).xyzz;\n    }\n    \n    // C-64 background color.\n    if(iMouse.z > 0.)\n    {\n    \tif(uvScaled.y < .8 && uvScaled.y > 0.1 && uvScaled.x > 0.1 && uvScaled.x < 0.9)\n        \to.rgb = colorE;\n    }\n    \n    // post-processing\n    \n    // scan line noise. why not use bayer matrix again, because we know it should result in consistent luminance. Well I don't know if this actually makes any sense but well...\n    //o.rgb = vec3(.5);\n    float uvy = fragCoord.y/pixelSize;\n    uvy += iDate.w*.1 * res.y;\n    uvy /= 8.;\n    float filter_ = texture(iChannel0, vec2(uvy/8., uvy)).r-.5;\n    o.rgb += filter_*.08;\n\n    vec2 uvn = uv-.5;\n\n    o.rgb *= 1.4;\n    o.rgb = clamp(o.rgb,0.,1.);\n    o.rgb *= 1.-length(uvn*1.4);\n    o.rgb = clamp(o.rgb,0.,1.);\n}\n\n\n","name":"Image","description":"","type":"image"}]}