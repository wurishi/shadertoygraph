{"ver":"0.1","info":{"id":"43fcWB","date":"1726692678","viewed":32,"name":"what have i done (5d rendering)","username":"shaderamogus","description":"copied my 4d implementation and made it 5d\nplease tell me if theres an easier way for a vec5 or a vecn (i want 6d to be easy)\nthe rot matrix is more user friendly than the 4d renderer\ni am still new to shadertoy so some advice is good\npls report bugs too","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["5d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct vec5{float x, y, z, w, u;};\nstruct mat5{vec5 v1, v2, v3, v4, v5;};\nvec5 vsub5(vec5 v, vec5 w);\nvec5 vadd5(vec5 v, vec5 w);\nvec5 normalize5(vec5 v);\nvec5 cross5(vec5 v1, vec5 v2, vec5 v3, vec5 v4);\nvec5 matmult5(vec5 v, mat5 m);\nfloat dot5(vec5 v, vec5 w);\n\nvoid calcmat3(vec3 from, vec3 up, vec3 to, out vec3 a, out vec3 b, out vec3 c);\nvoid calcmat4(vec4 from, vec4 up, vec4 over, vec4 to, out vec4 a, out vec4 b, out vec4 c, out vec4 d);\nvoid calcmat5(vec5 from, vec5 up, vec5 over, vec5 around, vec5 to, out vec5 a, out vec5 b, out vec5 c, out vec5 d, out vec5 e);\nfloat ldist(vec2 p, vec2 p1, vec2 p2);\nvec4 cross4(vec4 u, vec4 v, vec4 w);\nfloat dot4(vec4 v, vec4 w);\n\nconst float pi = 3.141592;\n\nfloat fov = 90. *(pi / 180.);\n\nvec5 points[38];\nvec4 axiscols[5];\n\nvec2 lines[] = vec2[](vec2(1,2),vec2(1,3),vec2(1,5),vec2(4,2),vec2(4,3),vec2(4,8),vec2(6,2),vec2(6,5),vec2(6,8),vec2(7,3),vec2(7,5),vec2(7,8),vec2(9,10),vec2(9,11),vec2(9,13),vec2(12,10),vec2(12,11),vec2(12,16),vec2(14,10),vec2(14,13),vec2(14,16),vec2(15,11),vec2(15,13),vec2(15,16),vec2(1,9),vec2(2,10),vec2(3,11),vec2(4,12),vec2(5,13),vec2(6,14),vec2(7,15),vec2(8,16),vec2(17,18),vec2(17,19),vec2(17,21),vec2(20,18),vec2(20,19),vec2(20,24),vec2(22,18),vec2(22,21),vec2(22,24),vec2(23,19),vec2(23,21),vec2(23,24),vec2(25,26),vec2(25,27),vec2(25,29),vec2(28,26),vec2(28,27),vec2(28,32),vec2(30,26),vec2(30,29),vec2(30,32),vec2(31,27),vec2(31,29),vec2(31,32),vec2(17,25),vec2(18,26),vec2(19,27),vec2(20,28),vec2(21,29),vec2(22,30),vec2(23,31),vec2(24,32),vec2(1,17),vec2(2,18),vec2(3,19),vec2(4,20),vec2(5,21),vec2(6,22),vec2(7,23),vec2(8,24),vec2(9,25),vec2(10,26),vec2(11,27),vec2(12,28),vec2(13,29),vec2(14,30),vec2(15,31),vec2(16,32),vec2(0,33),vec2(0,34),vec2(0,35),vec2(0,36),vec2(0,37));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int pcount = 33;\n    const int lcount = 80;\n    const int axiscount = 5;\n\n    axiscols[0] = vec4(1,0,0,0);\n    axiscols[1] = vec4(0,1,0,0);\n    axiscols[2] = vec4(0,0,1,0);\n    axiscols[3] = vec4(1,1,0,0);\n    axiscols[4] = vec4(1,0,1,0);\n\n    points[0] = vec5(0.,0.,0.,0.,0.);\n    for (int i = 1; i < pcount; i++)\n    {\n        float x1 = (float((i-1)%2)*2.)-1.;\n        float x2 = (float(int((i-1)/2)%2)*2.)-1.;\n        float x3 = (float(int((i-1)/4)%2)*2.)-1.;\n        float x4 = (float(int((i-1)/8)%2)*2.)-1.;\n        float x5 = (float(int((i-1)/16)%2)*2.)-1.;\n        \n        points[i] = vec5(x1, x2, x3, x4, x5);\n    }\n    points[33] = vec5(5.,0.,0.,0.,0.);\n    points[34] = vec5(0.,5.,0.,0.,0.);\n    points[35] = vec5(0.,0.,5.,0.,0.);\n    points[36] = vec5(0.,0.,0.,5.,0.);\n    points[37] = vec5(0.,0.,0.,0.,5.);\n\n    vec2 center = iResolution.xy/2.;\n    fragColor = vec4(0.);\n    float projc = 1./tan(fov/2.);\n    float aratio = iResolution.x / iResolution.y;\n    float lthicc = 1.;\n    \n    float theta = -iTime * 2. * pi * 0.1;\n    float phi = iTime * 2. * pi * 0.1;\n    mat5 rotmat = mat5(vec5(cos(phi), 0., -sin(phi), 0., 0.),\n                       vec5(0., 1.,  0., 0., 0.),\n                       vec5(sin(phi), 0., cos(phi), 0., 0.),\n                       vec5(0., 0., 0., cos(theta), sin(theta)),\n                       vec5(0., 0., 0., -sin(theta), cos(theta)));\n    \n    vec5 from5 = vec5(0.,0.,0.,0.,0.);\n    vec5 to5 = vec5(0.,0.,0.,0.,2.);\n    vec5 up5 = vec5(0.,1.,0.,0.,0.);\n    vec5 over5 = vec5(0.,0.,1.,0.,0.);\n    vec5 around5 = vec5(0.,0.,0.,1.,0.);\n    \n    vec5 a5, b5, c5, d5, e5;\n    calcmat5(from5, up5, over5, around5, to5, a5, b5, c5, d5, e5);\n    \n    for (int i = 0; i < pcount + axiscount; i++)\n    {\n        vec5 v = matmult5(points[i], rotmat);\n        v = vsub5(vadd5(v, to5), from5);\n        vec5 prime = matmult5(v, mat5(a5, b5, c5, d5, e5));\n        float cons5 = projc / dot5(v, e5);\n        vec4 p;\n        p.x = cons5 * dot5(v, a5);\n        p.y = cons5 * dot5(v, b5);\n        p.z = cons5 * dot5(v, c5);\n        p.w = cons5 * dot5(v, d5);\n        points[i].x = p.x;\n        points[i].y = p.y;\n        points[i].z = p.z;\n        points[i].w = p.w;\n    }\n    \n    vec4 from4 = vec4(0);\n    vec4 to4 = vec4(0, 0, 0, 2);\n    vec4 up4 = vec4(0, 1, 0, 0);\n    vec4 over4 = vec4(0, 0, 1, 0);\n    \n    vec4 a4, b4, c4, d4;\n    calcmat4(from4, up4, over4, to4, a4, b4, c4, d4);\n    \n    for (int i = 0; i < pcount + axiscount; i++)\n    {\n        vec4 v;\n        v.x = points[i].x;\n        v.y = points[i].y;\n        v.z = points[i].z;\n        v.w = points[i].w;\n        \n        v = v + to4 - from4;\n        vec4 prime = v * mat4(a4, b4, c4, d4);\n        float cons4 = projc / dot(v, d4);\n        vec3 p;\n        p.x = cons4 * dot4(v, a4);\n        p.y = cons4 * dot4(v, b4);\n        p.z = cons4 * dot4(v, c4);\n        points[i].x = p.x;\n        points[i].y = p.y;\n        points[i].z = p.z;\n    }\n\n    vec3 from = from4.xyz;\n    vec3 to = vec3(-7, -3, 10);\n    vec3 up = vec3(0, 1, 0);\n    \n    vec3 a, b, c;\n    calcmat3(from, up, to, a, b, c);\n    \n    for (int i = 0; i < pcount; i++)\n    {\n        vec3 x = vec3(points[i].x, points[i].y, points[i].z);\n        vec3 v = x + to - from;\n        vec3 prime = v * mat3(a, b, c);\n        vec2 t = vec2(prime.x/prime.z * projc, prime.y/prime.z * projc);\n        float cons = projc / dot(v, c);\n        vec2 s;\n        s.x = center.x + (iResolution.x * cons * dot(v, a));\n        s.y = center.y + (iResolution.y * cons * dot(v, b) * aratio);\n        points[i].x = s.x;\n        points[i].y = s.y;\n        if (distance(fragCoord, s) <= 2.)\n        {\n            fragColor = vec4(1, 0, 0, 1);\n            if (i == 0)\n            {\n                fragColor = vec4(1, 0.7, 0.5, 1);\n            }\n        }\n    }\n    \n    for (int i = 0; i < axiscount; i++)\n    {\n        vec3 x = vec3(points[i + pcount].x,points[i + pcount].y,points[i + pcount].z);\n        vec3 v = x + to - from;\n        vec3 prime = v * mat3(a, b, c);\n        vec2 t = vec2(prime.x/prime.z * projc, prime.y/prime.z * projc);\n        float cons = projc / dot(v, c);\n        vec2 s;\n        s.x = center.x + (iResolution.x * cons * dot(v, a));\n        s.y = center.y + (iResolution.y * cons * dot(v, b) * aratio);\n        points[i + pcount].x = s.x; \n        points[i + pcount].y = s.y; \n        if (distance(fragCoord, s) <= 4.)\n        {\n            fragColor = axiscols[i];\n        }\n    }\n    \n    \n    \n    for (int i = 0; i < lcount; i++)\n    {\n        vec2 p1 = vec2(points[int(lines[i].x)].x,points[int(lines[i].x)].y);\n        vec2 p2 = vec2(points[int(lines[i].y)].x,points[int(lines[i].y)].y);\n        float pd = distance(p1, p2);\n        float p1d = distance(p1, fragCoord);\n        float p2d = distance(p2, fragCoord);\n        float ld = ldist(fragCoord, p1, p2);\n        if (fragColor == vec4(0.) && ld < lthicc && p1d < pd + lthicc && p2d < pd + lthicc)\n        {\n            fragColor = vec4(1);\n        }\n    }\n    \n    for (int i = 0; i < axiscount; i++)\n    {\n        vec2 p1 = vec2(points[int(lines[i + lcount].x)].x,points[int(lines[i + lcount].x)].y);\n        vec2 p2 = vec2(points[int(lines[i + lcount].y)].x,points[int(lines[i + lcount].y)].y);\n        float pd = distance(p1, p2);\n        float p1d = distance(p1, fragCoord);\n        float p2d = distance(p2, fragCoord);\n        float ld = ldist(fragCoord, p1, p2);\n        if (ld < lthicc)\n        {\n            fragColor += axiscols[i] * 0.2;\n        }\n    }\n}\n\nvoid calcmat3(vec3 from, vec3 up, vec3 to, out vec3 a, out vec3 b, out vec3 c)\n{\n    c = normalize(to-from);\n    a = normalize(cross(up, c));\n    b = cross(c, a);\n}\n\nvoid calcmat4(vec4 from, vec4 up, vec4 over, vec4 to, out vec4 a, out vec4 b, out vec4 c, out vec4 d)\n{\n    d = normalize(to-from);\n    a = normalize(cross4(up, over, d));\n    b = normalize(cross4(over, d, a));\n    c = cross4(d, a, b);\n}\n\nvoid calcmat5(vec5 from, vec5 up, vec5 over, vec5 around, vec5 to, out vec5 a, out vec5 b, out vec5 c, out vec5 d, out vec5 e)\n{\n    e = normalize5(vsub5(to, from));\n    a = normalize5(cross5(up, over, around, e));\n    b = normalize5(cross5(over, around, e, a));\n    c = normalize5(cross5(around, e, a, b));\n    d = cross5(e, a, b, c);\n}\n\nfloat ldist(vec2 p, vec2 p1, vec2 p2)\n{\n    float a = p1.y - p2.y;\n    float b = p2.x - p1.x;\n    float c = (p1.x - p2.x)*p1.y + (p2.y - p1.y)*p1.x;\n    \n    return abs(a*p.x + b*p.y + c)/sqrt(a*a + b*b);\n}\n\nvec4 cross4(vec4 u, vec4 v, vec4 w)\n{\n    vec4 o;\n    o.x = determinant(mat3(u.y, v.y, w.y, u.z, v.z, w.z, u.w, v.w, w.w));\n    o.y = -determinant(mat3(u.x, v.x, w.x, u.z, v.z, w.z, u.w, v.w, w.w));\n    o.z = determinant(mat3(u.x, v.x, w.x, u.y, v.y, w.y, u.w, v.w, w.w));\n    o.w = -determinant(mat3(u.x, v.x, w.x, u.y, v.y, w.y, u.z, v.z, w.z));\n    return o;\n}\n\nvec5 normalize5(vec5 v)\n{\n    float l = sqrt(v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w + v.u*v.u);\n    return vec5(v.x/l,v.y/l,v.z/l,v.w/l,v.u/l);\n}\n\nvec5 vadd5(vec5 v, vec5 w)\n{\n    return vec5(v.x+w.x, v.y+w.y, v.z+w.z, v.w+w.w, v.u+w.u);\n}\n\nvec5 vsub5(vec5 v, vec5 w)\n{\n    return vec5(v.x-w.x, v.y-w.y, v.z-w.z, v.w-w.w, v.u-w.u);\n}\n\nvec5 cross5(vec5 v1, vec5 v2, vec5 v3, vec5 v4)\n{\n    vec5 o;\n    o.x = determinant(mat4(v1.y,v2.y,v3.y,v4.y, v1.z,v2.z,v3.z,v4.z, v1.w,v2.w,v3.w,v4.w, v1.u,v2.u,v3.u,v4.u));\n    o.y = determinant(mat4(v1.x,v2.x,v3.x,v4.x, v1.z,v2.z,v3.z,v4.z, v1.w,v2.w,v3.w,v4.w, v1.u,v2.u,v3.u,v4.u));\n    o.z = determinant(mat4(v1.x,v2.x,v3.x,v4.x, v1.y,v2.y,v3.y,v4.y, v1.w,v2.w,v3.w,v4.w, v1.u,v2.u,v3.u,v4.u));\n    o.w = determinant(mat4(v1.x,v2.x,v3.x,v4.x, v1.y,v2.y,v3.y,v4.y, v1.z,v2.z,v3.z,v4.z, v1.u,v2.u,v3.u,v4.u));\n    o.u = determinant(mat4(v1.x,v2.x,v3.x,v4.x, v1.y,v2.y,v3.y,v4.y, v1.z,v2.z,v3.z,v4.z, v1.w,v2.w,v3.w,v4.w));\n    return o;\n}\n\nfloat dot5(vec5 v, vec5 w)\n{\n    return v.x*w.x + v.y*w.y + v.z*w.z + v.w*w.w + v.u*w.u;\n}\n\nvec5 matmult5(vec5 v, mat5 m)\n{\n    vec5 o;\n    o.x = v.x*m.v1.x + v.y*m.v2.x + v.z*m.v3.x + v.w*m.v4.x + v.u*m.v5.x;\n    o.y = v.x*m.v1.y + v.y*m.v2.y + v.z*m.v3.y + v.w*m.v4.y + v.u*m.v5.y;\n    o.z = v.x*m.v1.z + v.y*m.v2.z + v.z*m.v3.z + v.w*m.v4.z + v.u*m.v5.z;\n    o.w = v.x*m.v1.w + v.y*m.v2.w + v.z*m.v3.w + v.w*m.v4.w + v.u*m.v5.w;\n    o.u = v.x*m.v1.u + v.y*m.v2.u + v.z*m.v3.u + v.w*m.v4.u + v.u*m.v5.u;\n    return o;\n}\n\nfloat dot4(vec4 v, vec4 w)\n{\n    return v.x*w.x + v.y*w.y + v.z*w.z + v.w*w.w;\n}","name":"Image","description":"","type":"image"}]}