{"ver":"0.1","info":{"id":"DddcWl","date":"1699647975","viewed":23,"name":"TP1 Imagerie","username":"yqnis","description":"Tp1 version finale\nCHAMBAS Corentin\nAUMASSON Yanis","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp1","informatique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 LIGHT_POSITION = vec3(8, 8 , 10);\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Cylinder{\n    vec3 a;// Center\n    vec3 b;// Radius\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Ellipsoid{\n    vec3 c;// Center\n    vec3 r;// Radius\n    int i;// Texture Id\n};\n\nstruct Capsule{\n    vec3 a; // Center of the bottom sphere\n    vec3 b; // Center of the top sphere\n    float r; // Radius of the spheres and cylinder\n    int i; // Texture Id\n};\n\nstruct Box{\n    vec3 min; // Minimum corner\n    vec3 max; // Maximum corner\n    int i; // Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d; // Diffuse\n    float reflectivity;\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n//Texture Uniforme \nMaterial TextureUniforme(vec3 p)\n{\n    return Material (vec3(0.0, 0.0, 1.), 0.0);\n}\n\n//Texture Mirroir\nMaterial TextureMirroir(vec3 p) {\n    return Material(vec3(0.0, 0.0, 1.), 1.0);\n}\n\n//Texture Damier\nMaterial TextureDamier(vec3 p, int i, float tailleDamier) {\n    float f = Checkers(p.xy / tailleDamier);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if (f > 0.5) {\n        col = vec3(1.0, 1.0, 1.0); // Blanc\n    }\n    return Material(col, 0.0);\n}\n\n//Texture concentrique\nMaterial TextureConcentrique(vec3 p, int i) {\n    float d = length(p - vec3(1.,1.,1.2)); // Distance au centre\n    float rayon = 1.5; // à ajuster\n\n    vec3 col; \n\n        if (d < rayon) {\n            col = mix(vec3(0.,1.,0.), vec3(.5,0.,.5), d / rayon);\n        } else {\n            col = vec3(.5,0.,.5);\n        }\n\n    return Material(col, 0.0);\n}\n\n//Texture radiale\nMaterial TextureRadiale(vec3 p, int i) {\n    float d = length(p.xx); // Distance à l'axe xy\n    float rayon = 0.5; // à ajuster\n\n    vec3 col;\n\n    if (d < rayon) {\n        col = mix(vec3(1., 0.0, 0.0), vec3(0.0, 1.0, 0.), d / rayon );\n    } else {\n        col = vec3(0.0, 1.0, 0.);\n    }\n    return Material(col, 0.0);\n}\n\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute texture at point\n// p : Point\n// i : Texture Id\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return TextureUniforme(p);\n    }\n    else if (i==2) {\n        return TextureDamier(p, i, 0.5);\n    }\n    else if (i==3) {\n        return TextureConcentrique(p, i);\n    }\n    else if (i==4) {\n        return TextureRadiale(p, i);\n    }\n    else if (i==5) {\n        return TextureMirroir(p);\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col, 0.0);\n    }\n    return Material(vec3(0), 0.0);\n}\n\n// Translation\nRay TranslationRay(Ray ray, vec3 translation) {\n    ray.o = ray.o + translation;\n    return ray;\n}\n\n// Rotation\nRay RotationRay(Ray ray, float angle, vec3 axis, vec3 center) {\n    // Convertir l'angle de degrés en radians\n    angle = radians(angle);\n    \n    // Normaliser l'axe pour être sûr\n    axis = normalize(axis);\n\n    // Construire la matrice de rotation\n    mat3 rotationMatrix = mat3(\n        cos(angle) + axis.x * axis.x * (1.0 - cos(angle)), \n        axis.x * axis.y * (1.0 - cos(angle)) - axis.z * sin(angle), \n        axis.x * axis.z * (1.0 - cos(angle)) + axis.y * sin(angle),\n\n        axis.y * axis.x * (1.0 - cos(angle)) + axis.z * sin(angle), \n        cos(angle) + axis.y * axis.y * (1.0 - cos(angle)), \n        axis.y * axis.z * (1.0 - cos(angle)) - axis.x * sin(angle),\n\n        axis.z * axis.x * (1.0 - cos(angle)) - axis.y * sin(angle), \n        axis.z * axis.y * (1.0 - cos(angle)) + axis.x * sin(angle), \n        cos(angle) + axis.z * axis.z * (1.0 - cos(angle))\n    );\n\n    // Applique la rotation autour d'un centre\n    vec3 translatedOrigin = ray.o - center; // Translate vers le centre\n    translatedOrigin = rotationMatrix * translatedOrigin; // Appliquer la rotation\n    ray.o = translatedOrigin + center; // Translate en arrière\n\n    // Applique la rotation à la direction\n    ray.d = normalize(rotationMatrix * ray.d);\n\n    return ray;\n}\n\nRay HomethetieRay(Ray ray, vec3 scale, vec3 center) {\n    // Translate vers le centre\n    vec3 translatedOrigin = ray.o - center; \n    translatedOrigin = vec3(translatedOrigin.x * scale.x, translatedOrigin.y * scale.y, translatedOrigin.z * scale.z);\n    ray.o = translatedOrigin + center; // Translate en arrière\n\n    // Applique la rotation à la direction\n    ray.d = normalize(vec3(ray.d.x * scale.x, ray.d.y * scale.y, ray.d.z * scale.z));\n\n    return ray;\n}\n\n\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectCylinder(Ray ray,Cylinder cyl,out Hit x)\n{\n    vec3 oc=ray.o-cyl.a;\n    vec3 dir = ray.d;\n    vec3 ba = cyl.b - cyl.a;\n    float r = cyl.r;\n    \n    float a = dot( dir, dir ) - dot( dir, ba ) * dot( dir, ba );\n    float b = 2.0 * ( dot( dir, oc ) - dot( dir, ba ) * dot( oc, ba ) );\n    float c = dot( oc, oc ) - dot( oc, ba ) * dot( oc, ba ) - r * r;\n    \n    float d = b*b - 4.0 * a * c;\n    \n    if(d>0.)\n    {\n        float t=(-b-sqrt(d))/(2.0*a);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            vec3 normal = normalize(vec3(p.x - cyl.a.x, p.y - cyl.a.y, 0.0));\n            x=Hit(t, normal, cyl.i);\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n\nbool IntersectEllipsoid(Ray ray,Ellipsoid ellip,out Hit x)\n{\n    vec3 oc=ray.o-ellip.c;\n    oc = oc / ellip.r;\n    vec3 dir = ray.d / ellip.r;\n    \n    float a = dot( dir, dir );\n    float b = dot( oc, dir );\n    float c = dot( oc, oc );\n\n    float d = b*b - a*(c-1.0);\n\n    if(d>0.)\n    {\n        float t=(-b-sqrt(d))/a;\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize((p-ellip.c)/(ellip.r*ellip.r)),ellip.i);\n            \n            return true;\n        }\n    }\n    \n    return false; \n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    vec3 invRayDir = 1.0 / ray.d; \n    vec3 distMinCorners  = (box.min - ray.o) * invRayDir; \n    vec3 distMaxCorners  = (box.max - ray.o) * invRayDir;\n\n    vec3 minD = min(distMinCorners, distMaxCorners); \n    vec3 maxD = max(distMinCorners, distMaxCorners);\n\n    float minMaxD = max(max(minD.x, minD.y), minD.z);\n    float maxMinD = min(min(maxD.x, maxD.y), maxD.z);\n\n    if (maxMinD < minMaxD) return false;\n\n    if (maxMinD < 0.0) return false;\n\n    float t = minMaxD; \n    vec3 p = ray.o + t * ray.d; \n\n    vec3 normal;\n    if (minD.x > minD.y && minD.x > minD.z) {\n        normal = vec3(1., 0., 0.);\n    } else if (minD.y > minD.x && minD.y > minD.z) {\n        normal = vec3(0., 1., 0.);\n    } else {\n        normal = vec3(0., 0., 1.);\n    }\n\n    x = Hit(t, normal, box.i); \n    return true; \n}\n\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    vec3 ba = cap.b - cap.a;\n    vec3 oa = ray.o - cap.a;\n\n    float baba = dot(ba, ba);\n    float bard = dot(ba, ray.d);\n    float baoa = dot(ba, oa);\n    float rdoa = dot(ray.d, oa);\n    float oaoa = dot(oa, oa);\n\n    float a = baba - bard * bard;\n    float b = baba * rdoa - baoa * bard;\n    float c = baba * oaoa - baoa * baoa - cap.r * cap.r * baba;\n\n    float h = b * b - a * c;\n    if (h < 0.0) {\n        return false;\n    }\n\n    float t = (-b - sqrt(h)) / a;\n    float y = baoa + t * bard;\n\n    // Cylindre central\n    if (y > 0.0 && y < baba) {\n        vec3 pointOnCylinder = ray.o + ray.d * t;\n        vec3 normal = normalize(pointOnCylinder - (cap.a + ba * y / baba));\n        x = Hit(t, normal, cap.i);\n        return true;\n    }\n\n    // Capsules\n    vec3 oc;\n    if (y <= 0.0) {\n        oc = oa;\n    } else {\n        oc = ray.o - cap.b;\n    }\n\n    b = dot(ray.d, oc);\n    c = dot(oc, oc) - cap.r * cap.r;\n    h = b * b - c;\n    if (h < 0.0) {\n        return false;\n    }\n\n    t = -b - sqrt(h);\n    if (t <= 0.0) {\n        return false;\n    }\n\n    vec3 pointOnSphere = ray.o + ray.d * t;\n    vec3 normal;\n    if (y <= 0.0) {\n        normal = normalize(pointOnSphere - cap.a);\n    } else {\n        normal = normalize(pointOnSphere - cap.b);\n    }\n    \n    x = Hit(t, normal, cap.i);\n    return true;\n}\n\n\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(0.,0.,1.),1.,1);\n    const Sphere sph2=Sphere(vec3(2.,0.,2.),1.,2);\n    const Sphere sph3=Sphere(vec3(0.,2.,1.),1.,3);\n\n    const Sphere sph4=Sphere(vec3(3.,3.,1.),1.,5);\n\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n\n    const Cylinder cyl = Cylinder(vec3(0., 0., 0.), vec3(0., 0., 1.), 0.3, 4);\n\n    const Ellipsoid ell = Ellipsoid(vec3(0., 4., 4.), vec3(0.5, 1.5, 0.5), 4);\n\n\n    const Box box = Box(vec3(2., 2., 1.), vec3(-1., -1., -1.), 3);\n\n\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph3,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph4,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinder(ray,cyl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoid(ray,ell,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectBox(ray,box,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n\n    float ao = 0.;\n    float occlusion = 0.;\n    float radius = 1.; // Définit la portée des tests d'occlusion\n    \n    for (int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // Direction dans la demi-sphère\n        Ray aoRay;\n        aoRay.o = p + n * 0.01; // offset pour éviter l'auto intersection\n        aoRay.d = d;\n        \n        Hit aoHit;\n        if (Intersect(aoRay, aoHit)) {\n            if (aoHit.t < radius) {\n                occlusion += 1. - (aoHit.t / radius);\n            }\n        }\n    }\n    \n    // Calcule le facteur d'occlusion en divisant par le nombre de rayons testés\n    ao = 1.0 - occlusion / float(N);\n    return ao;\n}\n\n// Apply color model\nvec3 Color(Material m, vec3 n, vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 light_pos = LIGHT_POSITION; // Position de la lumière, à ajuster selon votre scène\n    vec3 light_intensity = vec3(1.0, 1.0, 1.0); // Intensité de la lumière\n    vec3 ambient_color = vec3(0.0, 0.0, 0.0); // Couleur ambiante\n    float shininess = 20.0; // Facteur de brillance\n    vec3 specular_color = vec3(1.0, 1.0, 1.0); // Couleur spéculaire\n\n    // Normalisation des directions\n    vec3 light_dir = normalize(light_pos - p);\n    vec3 view_dir = normalize(ro - p);\n\n    // Réflexion parfaite\n    vec3 reflect_dir = reflect(-light_dir, n);\n\n    // Composantes de l'éclairage\n    float diff = smoothstep(0., 1., dot(n, light_dir));\n    float spec = pow(max(dot(view_dir, reflect_dir), 0.), shininess);\n\n    // Couleur résultante avec éclairage de Phong\n    vec3 col = ambient_color + m.d * diff * light_intensity + specular_color * spec * light_intensity;\n\n    // Ajout de l'occlusion ambiante\n    col *= AmbientOcclusion(p, n, 100);\n\n\n    return col;\n}\n\n\n\n\n// Updated Shade function with shadows\n// Updated Shade function with reflections and without recursion\nvec3 Shade(Ray ray) {\n\n    vec3 color = vec3(0.0); \n\n    for(int bounce = 0; bounce <= 1; bounce++) {\n        Hit x;\n        if (Intersect(ray, x)) {\n            vec3 p = Point(ray, x.t); //  point d'intersection\n            Material mat = Texture(p, x.i); // matériel au point d'intersection\n\n            vec3 lightPos = LIGHT_POSITION; \n            vec3 toLight = normalize(lightPos - p); \n            float lightDistance = length(lightPos - p);\n\n            // Rayon pour tester les ombres\n            Ray shadowRay;\n            shadowRay.o = p + x.n * 0.001; // Offset pour éviter l'auto-intersection\n            shadowRay.d = toLight;\n\n\n\n            // Verifie si il y a une intersection entre le point d'intersection et la lumière\n            Hit shadowHit;\n            bool shadow = Intersect(shadowRay, shadowHit) && shadowHit.t < lightDistance;\n\n            if (shadow) {\n                color = vec3(0.0);\n            } else {\n                color = Color(mat, x.n, p, ray.o, ray.d);\n            }\n\n            // Reflection\n            if(mat.reflectivity > 0.0 && bounce == 0) { \n                ray.o = p + x.n * 0.001;\n                ray.d = reflect(ray.d, x.n);\n            } else {\n                break; \n            }\n        } else {\n            color = vec3(0.0); // Noir si pas d'intersection\n            break; \n        }\n    }\n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}