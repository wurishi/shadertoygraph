{"ver":"0.1","info":{"id":"XXySRd","date":"1720334823","viewed":113,"name":"Pink Diamond Generator","username":"Capo","description":"I used fractal and symmetry to generate pink diamonds that gradually split and aggregate in a blue crystal shell","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","color","symmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//reference：https://www.shadertoy.com/view/ftlyRS\nvec2 uv;\nvec3 cp, cn, cr, ro, rd, ss, oc, cc, gl, vb;\nvec4 fc;\nfloat tt, cd, sd, io, oa, td;\nint es=0, ec;\n\nfloat bx(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec3 lattice(vec3 p, int iter, float an, float factor) {\n    for (int i = 0; i < iter; i++) {\n        float iFactor = smoothstep(0.0, 1.0, factor - float(i) / float(iter));\n        p.xy *= rot(an * DTR * iFactor);\n        p.yz = abs(p.yz) - 1.0 * iFactor;\n        p.xz *= rot(-an * DTR * iFactor);\n        p = abs(p); \n    }\n    return p;\n}\n\nfloat diamond(vec3 p) {\n    vec3 q = abs(p);\n    return max(q.x + q.y + q.z - 1.0, 0.0);\n}\n\nfloat mp(vec3 p) {\n    if (iMouse.z > 0.0) {\n        p.yz *= rot(2.0 * (iMouse.y / iResolution.y - 0.5));\n        p.zx *= rot(-7.0 * (iMouse.x / iResolution.x - 0.5));\n    }\n    vec3 pp = p;\n\n    p.xz *= rot(tt * 0.1);\n    p.xy *= rot(tt * 0.1);\n\n    int iter = 9;\n    float factor = smoothstep(0.0, 1.0, min(iTime * 0.018, 1.0)); // 控制晶体生成速度\n    p = lattice(p, iter, 45. + cos(tt * 0.1) * 5., factor);\n\n    float sd1 = diamond(p) - 1.0;\n    sd = smin(sd1, bx(p, vec3(1)), 0.8);\n\n    p.xy = abs(p.xy);\n    p.yz = abs(p.yz);\n    p.zx = abs(p.zx);\n\n    gl += exp(-sd * 0.001) * normalize(p * p) * 0.003;\n    sd = abs(sd) - 0.001;\n\n    if (sd < 0.001) {\n        oc = vec3(0.35, 0.25, 0.45) + length(pow(abs(rd + vec3(0, 0.5, 0)), vec3(3))) * 0.3 + gl;\n        io = 1.2;\n        oa = 0.0;\n        ss = vec3(0);\n        vb = vec3(0., 10, 2.8);\n        ec = 2;\n    }\n    return sd;\n}\n\nvoid tr() {\n    vb.x = 0.;\n    cd = 0.;\n    for (float i = 0.; i < 256.; i++) {\n        mp(ro + rd * cd);\n        cd += sd;\n        td += sd;\n        if (sd < 0.0001 || cd > 128.) break;\n    }\n}\n\nvoid nm() {\n    mat3 k = mat3(cp, cp, cp) - mat3(.001);\n    cn = normalize(mp(cp) - vec3(mp(k[0]), mp(k[1]), mp(k[2])));\n}\n\nvoid px() {\n    cc = vec3(0.35, 0.25, 0.45) + length(pow(abs(rd + vec3(0, 0.5, 0)), vec3(3))) * 0.3 + gl;\n    vec3 l = vec3(0.9, 0.7, 0.5);\n    if (cd > 128.) { oa = 1.; return; }\n    float df = clamp(length(cn * l), 0., 1.);\n    vec3 fr = pow(1. - df, 3.) * mix(cc, vec3(0.4), 0.5);\n    float sp = (1. - length(cross(cr, cn * l))) * 0.2;\n    float ao = min(mp(cp + cn * 0.3) - 0.3, 0.3) * 0.4;\n    cc = mix((oc * (df + fr + ss) + fr + sp + ao + gl), oc, vb.x);\n}\n\nfloat starNoise(vec2 uv) {\n    uv *= 1e3;\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 starryBackground(vec2 uv, float time) {\n    vec3 color1 = vec3(0.0, 0.0, 0.1);\n    vec3 color2 = vec3(0.1, 0.1, 0.3);\n    vec3 bgColor = mix(color1, color2, uv.y + 0.5);\n\n    float stars = step(0.9995, starNoise(uv + time * 0.05));\n    bgColor += vec3(1.0) * stars;\n\n    return bgColor;\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col) {\n    tt = mod(time + 25., 260.);\n    uv = vec2(frag.x / res.x, frag.y / res.y);\n    uv -= 0.5; uv /= vec2(res.y / res.x, 1);\n    float an = (sin(tt * 0.3) * 0.5 + 0.5);\n    an = 1. - pow(1. - pow(an, 5.), 10.);\n    ro = vec3(0, 0, -5. - an * 15.);\n    rd = normalize(vec3(uv, 1));\n\n    vec3 bgColor = starryBackground(uv, time); // 星光背景色\n\n    for (int i = 0; i < 25; i++) {\n        tr();\n        cp = ro + rd * cd;\n        nm();\n        ro = cp - cn * 0.01;\n        cr = refract(rd, cn, i % 2 == 0 ? 1. / io : io);\n        if (length(cr) == 0. && es <= 0) { cr = reflect(rd, cn); es = ec; }\n        if (max(es, 0) % 3 == 0 && cd < 128.) rd = cr; es--;\n        if (vb.x > 0. && i % 2 == 1) oa = pow(clamp(cd / vb.y, 0., 1.), vb.z);\n        px();\n        fc = fc + vec4(cc * oa, oa) * (1. - fc.a);\n        if ((fc.a >= 1. || cd > 128.)) break;\n    }\n    col = mix(vec4(bgColor, 1.0), fc / fc.a, fc.a); // 混合背景色和晶体颜色\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    render(fragCoord.xy, iResolution.xy, iTime, fragColor);\n}\n","name":"Image","description":"","type":"image"}]}