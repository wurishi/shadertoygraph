{"ver":"0.1","info":{"id":"lc3BDB","date":"1733442478","viewed":55,"name":"hat polykite","username":"Boogaloo","description":"Quick and dirty implementation of the hat polykite, though I'm not exactly sure how to make this into a proper tiling without manually placing each tile.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["einstein","aperiodic","monotile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sl=40.;\nfloat pi=3.14159;\nfloat s3=1.732;\n\nvec2 bigRec(vec2 I){return vec2(floor(I.x/(sl*3.)),floor(I.y/(sl*s3)));}\n\nvec2 smallRec(vec2 I){\nvec2 a=vec2(0.);\nif(mod(I.x,sl*3.)>1.5*sl){a.x=1.;}\nif(mod(I.y,sl*s3)>.5*sl*s3){a.y=1.;}\nreturn a;\n}\n\nfloat subDiv(vec2 I){\nif(smallRec(I).x!=smallRec(I).y){I.x=-I.x;}\nvec2 rel=vec2(mod(I.x,sl*1.5),mod(I.y,.5*sl*s3));\nif(rel.x*tan(pi/6.)<rel.y){\nif(rel.x*tan(pi/3.)<rel.y){return 0.;}\nif(rel.x*tan(-pi/3.)+sl*s3>rel.y){return 1.;}\nreturn 2.;\n}\nif(rel.x*tan(-pi/3.)+sl*s3>rel.y){return 3.;}\nif(rel.x*tan(pi/3.)-sl*s3>rel.y){return 4.;}\nreturn 5.;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O=vec4(0.);\n    I*=800./iResolution.x;\n    vec2 big=bigRec(I);\n    vec2 small=smallRec(I);\n    float sub=subDiv(I);\n   \n   \n    if(big==vec2(3.)){\n    if(small==vec2(0.,0.)){O.x=1.;}\n    if(small==vec2(0.,1.)&&sub==3.){O.x=1.;}\n    }\n    if(big==vec2(3.,2.)){\n    if(small==vec2(0.,1.)&&sub!=3.){O.x=1.;}\n    if(small==vec2(1.)&&sub<2.){O.x=1.;}\n    }\n    if(big==vec2(2.)){\n    if(small==vec2(1.)&&sub>3.){O.x=1.;}\n    }\n    \n    O.z=mod(iTime,sub+1.)/6.;    \n}","name":"Image","description":"","type":"image"}]}