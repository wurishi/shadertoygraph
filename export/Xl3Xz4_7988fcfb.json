{"ver":"0.1","info":{"id":"Xl3Xz4","date":"1478296313","viewed":467,"name":"Rolling shutter pathtracing","username":"stduhpf","description":"Simulating a camera with pathtracing(inspired by iq's work, i don't remember the link of the article)\nAnimated version of the wind turbine model [url=https://www.shadertoy.com/view/4lcSz4]here[/url]","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["motionblur","dof","pathtracing","montecarlo","turbine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv)/float(iFrame+1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define camera_distance 6.\n#define viewdist 60.\n\n#define prec .001\n#define raymaxit 1000\n\n#define use_ao\n//#define show_ao\n#define time t/24. //frame/framerate\n\n #define ra mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1) \n\n\nfloat t=1.;  //current frame number(if yo want to make an animation)\n\nstruct material\n{\n    vec3 c; //color\n    float sp; //specularity\n    float sr; //roughness\n    float f; //just a constant for the pseudo fresnel effect\n};\nfloat seed;\n    \nfloat hash( float n )\n{\n    seed+=max(1.,abs(n));\n    return (fract(seed+sin(seed)*43758.5453));\n}\n\n\n\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n\tseed+=iTime;\n    // compute basis from normal\n    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n    // (link provided by nimitz)\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return  sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nvec2 un(vec2 a, vec2 b)\n{\n    float t =  min(a,b).x;\n    float m = b.y;\n    if(a.x==t)\n        m=a.y;\n    return vec2(t,m);\n}\nfloat pale(vec3 p)\n{\nreturn udRoundBox( p, vec3(.05,.8,.01), .001 );   \n}\nfloat pales(vec3 p,float a)\n{\n    p-=vec3(0,2.2,-.25);\n    float d=pale(p*ra);\n    a+=2.095;\n    d= min(d, pale(p*ra));\n    a+=2.095;\n    return min(d, pale(p*ra));\n}\n\nfloat windTurbine(vec3 p)\n{\n    float d =  sdCapsule(p, vec3(0,-2,0), vec3(0,2.5,0), .1);\n    d=min(d,sdCapsule(p,vec3(0,2.2,.1),vec3(0,2.2,-.1),.2));\n    d=min(d,sdCapsule(p,vec3(0,2.2,.1),vec3(0,2.2,-.3),.1));\n    d=min(d,pales(p,201.*time));\n    return d;\n}\nfloat windFarm(vec3 p)\n{\n    float d=windTurbine(p);\n    float a=1.2;\n    p.xzy*=ra;\n    d=min(d,windTurbine(p+vec3(-6,-.2,-8)));\n    p.xzy*=ra;\n    d=min(d,windTurbine(p+vec3(-14,-.5,18)));\n    return d;\n}\n\nfloat ground(vec3 p)\n{\n    float a =.5;\n    p.xzy*=ra;\n    p.yz*=2.;\n    return p.y+clamp(abs(p.z*.126)-2.,0.,2.)*(sin(.5+p.z*.1)+sin(p.x*.15))+.05*texture(iChannel0,.5*p.xz).r;\n}\n\nvec2 map(vec3 p)\n{\n return un(vec2(ground(p),2),vec2(windFarm(p),1)) ;    \n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(prec,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 intersect(vec3 ro,vec3 rd)\n{\n    float f=0.;\n    bool hit = true;\n\n    for(int i = 0; i <raymaxit; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<prec)\n                return vec2(f,h.y);\n               \tif(f > viewdist)\n           break;\n            f+=.8*h.x;\n    }\n    return vec2(0);\n}\n\nfloat shad(vec3 rd,vec3 ro)\n{\n    float t=0.001;\n    for(int i=0;i<raymaxit;i++)\n    {\n        vec3 pos = ro+t*rd;\n        vec2 h= map(pos);\n        if(h.x<prec)\n                return 0.;\n        t+=.8*h.x;\n        if(t>10.)\n        break;\n        }\n\n    return 1.;\n}\n\nvec3 getskyColor(vec3 rd, vec3 ld)\n{\n    vec3 col = mix(vec3(.1,.5,1.),vec3(1.,.9,.5),min(.1/distance(rd,ld),1.));\n   col = mix(col, vec3(1),.2);\n    return col;\n}\nmaterial mat(float m, vec3 p)\n{\n    float a =.8;\n    p.xzy*=ra;\n    m= floor(m);\n    if(m==1.)\n    return material(vec3(1),.8,0.02,0.5);\n    if (m==2.)\n    return material(abs(p.x-cos(.7*p.z)*cos(p.z)-7.)>1.?vec3(.2,.8,.1):vec3(.8,.8,.2),.5,.2,1.);\n    return material(vec3(0),0.,0.,0.);\n    }\n\n    \nvec3 pathtrace(vec3 ro, vec3 rd)\n{\nvec3 acccolor=vec3(0);\nvec3 fcolor=vec3(1);\nvec3 ld = normalize(vec3(-.5,.5,-1));//sun light\nfor(int i=0;i<2;i++)\n{\n    vec2 h = intersect(ro,rd);\n    vec3 color =  getskyColor(rd,ld);\n    vec3 lc = vec3(1);\n    if(h.y>0.)\n    {\n        vec3 P=ro+h.x*rd;\n        vec3 N=normal(P);\n        ld=normalize(ld+(vec3(hash(10.+rd.x),hash(11.+rd.y),hash(12.+rd.z))-.5)*.05);//takes care of the apparent size of the sun  for the soft shadows\n        float l =dot(ld,N); \n        l*=shad(ld,P+prec*N); \n        lc=l*vec3(1.,.9,.5);\n        vec3 ld2=cosineDirection(hash(dot(ld,rd+P)),vec3(0,1,0)); //atmospheric light source\n        l =dot(ld2,N); \n        l*=shad(ld2,P+prec*N); \n        lc=mix(lc,l*vec3(.1,.5,.8),.3634);\n        material m=mat(h.y,P);\n        color = m.c;\n        ro=P+prec*N;\n        float fr=clamp((1.-abs(dot(N,rd)*m.f)),0.,1.);//arbitrary non accurate fresnel effect\n        if(hash(dot(P,N))>m.sp*fr)\n        {\n            rd=cosineDirection(dot(P-N,N+P),N);//diffusion\n        }else{\n            float rough =m.sr;\n            rd=reflect(rd,normalize(N+(vec3(hash(1.),hash(2.),hash(3.))-.5)*rough));//metallic reflections\n        }\n    }\n    else\n    {    \n        fcolor*=color/float(i+1);\n    }\n        fcolor*=color;\n        acccolor+=fcolor*lc;\n}\nreturn acccolor;\n}\n\nvoid mainImage( out vec4 fcol, in vec2 fragCoord )\n{\t\n    seed = iDate.w;\n     fcol=texture(iChannel1,fragCoord.xy / iResolution.xy);\n\n    fragCoord.xy+=vec2(hash(iDate.w+fragCoord.x),hash(fragCoord.y-iDate.w));\n\n\n    vec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n\n    float shutterAperture = .03; //exposition time(in frames) for the motion blur ( set to zero to disable the blur)(max:1)\n    float shutterroll = 1.; //time(in frames) used for the rolling shutter to scan the scene (max: 1)\n    float fov = 2.5; \n    float focusDistance =6.; \n    float blurAmount = 0.025;\n    //motion blur+rolling shutter effect(changes the time variable of the scene)\nt-=shutterAperture * hash(dot(54.+uv, vec2(12.9898, 4.1414)))+uv.y*shutterroll;\n\n       vec2 mse=vec2(-.2,-.2);\nmat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n\n    vec3 ro = vec3(0,2,-camera_distance)*rdroty*rdrotx;\n    vec3 uu=vec3(1,0,0)*rdroty*rdrotx,vv=vec3(0,1,0)*rdroty*rdrotx,ww=vec3(0,0,1)*rdroty*rdrotx;\nvec3 er = normalize( vec3(uv, fov ) );\nvec3 rd = er.x*uu + er.y*vv + er.z*ww;\n\n    //depth of field\n        vec3 go = blurAmount*vec3( -1.0 + 2.0*vec2(hash(uv.y+2.),hash(uv.x+1.)), 0.0 );\n        vec3 gd = normalize( er*focusDistance - go );\n        ro += go.x*uu + go.y*vv;\n        rd += gd.x*uu + gd.y*vv;\n     rd=normalize(rd);\n\n    vec3 col = pathtrace(ro,rd);\n    fcol+=vec4(col,0);\n    if(iFrame==0)fcol=vec4(col,0);\n}","name":"Buf A","description":"","type":"buffer"}]}