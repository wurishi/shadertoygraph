{"ver":"0.1","info":{"id":"3tVXRy","date":"1583043899","viewed":284,"name":"Standard Galactic Alphabet","username":"ChrisFeline","description":"Standard Galactic Alphabet, the lenguaje/alphabet commonly used in Minecraft enhancement table and some secrets in the Commander Keen series. Hello world!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["text","bitmap","font","sprite","bit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CHAR_SIZE vec2(6, 7)\n#define CHAR_SPACING vec2(6, 9)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define DOWN_SCALE 5.0\n\n/*\nBased on: https://www.shadertoy.com/view/llSGRm\nfor educational purposes.\n*/\n\n// Generated from Minecraft using Node.js by ChrisFeline\nvec2 sg_spc = vec2(0.0,0.0);\nvec2 sg_end = vec2(0.0,45.0);\nvec2 sg_a = vec2(402562.0,66608.0);\nvec2 sg_b = vec2(266305.0,16574.0);\nvec2 sg_c = vec2(1048836.0,197648.0);\nvec2 sg_d = vec2(2032001.0,24576.0);\nvec2 sg_e = vec2(1130756.0,133182.0);\nvec2 sg_f = vec2(2031952.0,0.0);\nvec2 sg_g = vec2(266311.0,33288.0);\nvec2 sg_h = vec2(2032113.0,33288.0);\nvec2 sg_i = vec2(1065216.0,133152.0);\nvec2 sg_j = vec2(1064964.0,2080.0);\nvec2 sg_k = vec2(266309.0,557576.0);\nvec2 sg_l = vec2(1069316.0,133664.0);\nvec2 sg_m = vec2(1115152.0,532670.0);\nvec2 sg_n = vec2(1198113.0,33824.0);\nvec2 sg_o = vec2(1968161.0,33824.0);\nvec2 sg_p = vec2(1315141.0,165928.0);\nvec2 sg_q = vec2(262640.0,532670.0);\nvec2 sg_r = vec2(1179648.0,36.0);\nvec2 sg_s = vec2(1065222.0,66576.0);\nvec2 sg_t = vec2(2032656.0,532482.0);\nvec2 sg_u = vec2(160.0,253952.0);\nvec2 sg_v = vec2(266305.0,254014.0);\nvec2 sg_w = vec2(64.0,2176.0);\nvec2 sg_x = vec2(1116193.0,66592.0);\nvec2 sg_y = vec2(1331525.0,166440.0);\nvec2 sg_z = vec2(272660.0,665762.0);\n\n\nvec2 res;\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,22.0); //Fixes small artefacts on my nexus 7\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec2 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec2 ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nfloat Text(vec2 uv)\n{\n    float col = 0.0;\n    \n    print_pos = vec2(res.x/2.0 - STRWIDTH(17.0)/2.0,res.y/2.0 - STRHEIGHT(1.0)/2.0);\n    print_pos = floor(print_pos);\n       \n    col += char(sg_h,uv);\n    col += char(sg_e,uv);\n    col += char(sg_l,uv);\n    col += char(sg_l,uv);\n    col += char(sg_o,uv);\n    \n    col += char(sg_spc,uv);\n    \n    col += char(sg_s,uv);\n    col += char(sg_h,uv);\n    col += char(sg_a,uv);\n    col += char(sg_d,uv);\n    col += char(sg_e,uv);\n    col += char(sg_r,uv);\n    col += char(sg_t,uv);\n    col += char(sg_o,uv);\n    col += char(sg_y,uv);\n    \n    col += char(sg_end,uv);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / DOWN_SCALE;\n    vec2 uv = fragCoord.xy / DOWN_SCALE;\n\tvec2 duv = floor(fragCoord.xy / DOWN_SCALE);\n    \n\tfloat pixel = Text(duv);\n    vec3 col = vec3(pixel);\n\n\tfragColor = vec4(vec3(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}