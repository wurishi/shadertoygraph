{"ver":"0.1","info":{"id":"lsfcD8","date":"1487946823","viewed":245,"name":"Upper Half Plane","username":"soma_arc","description":"Hyperbolic Tessellation on the upper half plane.\nMapping function for the upper half plane to the Poincare disk :  f(z) = (z - i)/(z + i)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","tiling","tessellation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 tp1 = vec2(0.26607724, 0);\nvec2 tp2 = vec2(0, 0.14062592);\nvec2 cPos = vec2(2.01219217, 3.62584500);\nfloat r = 4.02438434;\nconst float PI = 3.14159265359;\n\nvoid calcCircle(float theta, float phi){\n\tfloat tanTheta = tan(PI/2. - theta);\n    float tanPhi = tan(phi);\n    float tanTheta2 = tanTheta * tanTheta;\n    float tanPhi2 = tanPhi * tanPhi;\n    \n    tp1 = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)) - \n               tanTheta * sqrt((1. + tanPhi2)/(-tanPhi2 + tanTheta2))/tanTheta, 0.);\n    tp2 = vec2(0., -tanPhi * sqrt(-(1. + tanTheta2)/(tanPhi2 - tanTheta2))+\n              tanTheta * sqrt(-(1. + tanPhi2)/(tanPhi2 - tanTheta2)));\n    \n    \n    cPos = vec2(sqrt((1. + tanTheta2)/(-tanPhi2 + tanTheta2)),\n                 sqrt((1. + tanPhi2)*tanTheta2/(-tanPhi2 + tanTheta2))\n               );\n    r = sqrt((1. + tanPhi2)*(1. + tanTheta2) /(-tanPhi2 + tanTheta2));\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 20;\nfloat colCount = 0.;\nint IIS(vec2 pos){\n    if(length(pos) > 1.) return 0;\n\n    bool fund = true;\n    int invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if (pos.x < 0.){\n            pos *= vec2(-1, 1);\n            invCount++;\n\t       \tfund = false;\n        }\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(distance(pos, cPos) < r ){\n        \tpos = circleInverse(pos, cPos, r);\n            invCount++;\n            colCount++;\n            fund = false;\n        }\n        if(fund)\n        \treturn invCount;\n    }\n\n\treturn invCount;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 compQuot(const vec2 a, const vec2 b){\n\tfloat denom = dot(b, b);\n    return vec2((a.x * b.x + a.y * b.y) / denom,\n                (a.y * b.x - a.x * b.y) / denom);\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\n\n\nfloat quartEasingInOut(float t) {\n\tt *= 2.;\n\tif (t < 1.) return .5*t*t*t*t*t;\n\tt -= 2.;\n\treturn .5*(t*t*t*t*t + 2.);\n}\n\t\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nconst float sampleNum = 30.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    vec3 sum = vec3(0);\n    calcCircle(PI/4., PI/8.);\n\tfloat t = mod(iTime, 4.);    \n    float zoomingTime = 2.;\n    float stay = 0.;\n    const float maxZoomOut = 5.;\n    for(float i = 0. ; i < sampleNum ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        position.y += 0.3;\n\n        //position = position * 2.;\n        \n        if(t < zoomingTime + stay)\n        \tposition *= mix(maxZoomOut, 0.01,\n                            quartEasingInOut(scene(t, 0., zoomingTime)));\n        else\n            position *= mix(0.01, maxZoomOut,\n                            quartEasingInOut(scene(t, zoomingTime + stay, zoomingTime)));\n\n        //position += vec2(cos(iTime), 0.3 * sin(iTime));\n\t\t\n        if(position.y < 0.) continue;\n        \n        // upper half plane -> Poincare disk\n        vec2 poincare = compQuot(position - vec2(0, 1), position + vec2(0, 1));\n      \t\n        int d = IIS(poincare);\n\n       \tif(d == 0){\n           \tsum += vec3(0.,0.,0.);\n       \t}else{\n           \tif(mod(float(d), 2.) == 0.){\n               \tsum += hsv2rgb(vec3(0.5 + position.y * 0.05, 1., 1.));\n        \t}else{\n            \tsum += hsv2rgb(vec3(1., 1., 1.));\n        \t}\n        }\n    }\n    fragColor = vec4(sum/sampleNum, 1.);\n}","name":"Image","description":"","type":"image"}]}