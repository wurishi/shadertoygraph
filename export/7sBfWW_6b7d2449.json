{"ver":"0.1","info":{"id":"7sBfWW","date":"1646778777","viewed":217,"name":"RGBW decomposition","username":"stduhpf","description":"Simple luma-aware alogithm to create \"saturated\" RGBW signal from unbound RGB colors. \nThe W color has to be inside RGB gamut. \nThe algorithm is trying to maximise the W component while keeping the chromaticity the same as the input if possible.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["color","rgbw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// RGBW decomposition\n// Maximises the amount of W and reproduce the wanted color exactly if possible\n// If the input color is outside the maximum RGB range, it ensures the relative luminance\n// of the output is the same as the input by \"desaturating\"\n// This solution could be usefull for driving things like RGBW LED strips or some display panels\n\n// the Image tab is for displaying the result, the actual decomposition is going on in Buffer A\n\n// white \"primary\" color modifiable in common tab\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w_brightness =.5*(1.-cos(iTime));\n\n    vec3 W = w_brightness*W0;//varying the white max brightness over time\n    float lW = dot(W,lum);\n    \n    vec3 Wl = W*lum;\n    \n    \n    //gain (should match bufferA's)\n    float a = (1.+lW/dot(vec3(1.),lum));\n    //vec3 a = W+1.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 t = clamp(texture(iChannel0,uv),0.,1.);\n    fragColor =vec4((t.rgb+t.w*W)/a,1.0);\n    \n    if(cos(iTime*.5)<0.){\n        float parts = 4.;//use 6. instead of 4. if you want to see the last two\n        float part = mod(floor(uv.x*parts)+floor(iTime*.25/acos(-1.)),parts);\n        //color only\n        if(part==1.)fragColor.rgb=t.rgb/a;\n\n        //white only\n        if(part==2.)fragColor.rgb =t.w*W/a;\n\n        vec4 orig = texture(iChannel1,uv);orig*=orig;\n\n        //exaggerated chromaticity difference(should be mostly gray, especially for dimm or desaturated colors)\n        if(part==3.)fragColor = .5-.5*(fragColor-orig)*10.;\n\n        //luminance\n        if(part==4.)fragColor=vec4(dot(fragColor.rgb,lum));\n\n        //exaggerated luminance difference (should always be uniformly gray, except for precision issues)\n        if(part==5.)fragColor = vec4(.5)-.5*(dot(fragColor.rgb,lum)-dot(orig.rgb,lum))*10.;\n\n    }\n    \n    fragColor = sqrt(fragColor);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 t = texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    t*=t;\n    t*=2.;\n    \n    //t*=0.;\n    //t.rg+=2.*fragCoord.x/iResolution.x;\n    \n    float w = min(min(t.r,min(t.g,t.b)),1.);\n    \n    vec3 c = t-w;\n    \n    float o = max(c.r,max(c.g,c.b))-1.;//overshoot\n    if(o>0.)\n        w=o;\n        c=t-w;\n        \n    fragColor = vec4(c,w);\n}*/\n/*\nconst vec3 lum = vec3(0.2126,0.7152,0.0722);\n\nvec3 g(vec3 x){\n    return x*step(x,vec3(1))+step(vec3(1),x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 t = texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    t*=t;\n    t*=2.;\n    \n    //t*=0.;\n    //t.rg+=2.*fragCoord.x/iResolution.x;\n    \n    float w = min(min(t.r,min(t.g,t.b)),1.);\n    \n    vec3 c = t-w;\n       \n    w+=dot(step(vec3(1),c)*(c-1.),lum);\n    c=g(c);\n        \n    fragColor = vec4(c,w);\n}*/\n\nfloat max4(vec4 a){\n    return max(max(a.x,a.y),max(a.z,a.w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 W = .5*(1.-cos(iTime))*W0; //varying the white max brightness over time\n\n    float lW = dot(W,lum);\n        \n    float a = (1.+lW/dot(vec3(1.),lum)); //maps a*vec3(1.) to vec4(1.)\n    \n    //vec3 a = W+1.; //all possible output colors can be mapped if input is between 0 and this value, without luminance loss\n    \n    vec3 t = texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    t*=t; // rough gamma correction, this needs linear colors to work properly\n\n    t*=a; // increasing brightness of the image so the brighest parts get as bright as all RGBW together \n      \n    \n    //t*=0.;\n    //t.rg+=a*fragCoord.x/iResolution.x;\n    \n    \n    //optionnal white balance to bring rec.709's D65 to whatever W is\n    //t=t*W/max(W.r,max(W.g,W.b));\n    \n    vec3 tn = t/W; //colors mapped to a similar colorspace, but with W as whitepoint (kinda like a color temperature change)\n    \n    \n    float w= min(min(tn.r,min(tn.g,tn.b)),1.); //baseline amount of W\n    \n    vec3 c = t-w*W; //remaining colors after removing the baseline\n    \n    //the following only changes anything if some component of c is gerater than 1.\n    //this means that the input color has at least one component above 1+w*W\n    \n    //this is the part that \"desaturates\" colors that still overshoot the RGB space after removing baseline,towards W\n    //the luminance of the output will match the input as long as the original input is within the [vec3(0),1+W] range \n    w+=dot(max(c,1.)-1.,lum)/lW; //anything above 1. is converted to white while preserving luminance\n    c=min(c,1.); //this is redundant with the final clamp but it explicitely removes the extra colors that got converted to white\n    \n    //refinement step\n    //if w still gets above 1., but some RGB channels are stil not fully saturated\n    //we convert the remaining luminance to fill up the remaining RGB\n    float w2=max(w,1.)-1.;\n    w=min(w,1.);\n    c+=(1.-c)*min(w2*lW/dot(lum,1.-c),1.);\n        \n    //fragColor = fragCoord.x<iResolution.x*.5?vec4(t/a,0.):vec4(c,w);\n    fragColor = clamp((vec4(c,w)),0.,1.);\n    //if(max4(fragColor-vec4(c,w))>1e-6)fragColor*=0.;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// white primary: (could be any vec3 with only strictly positive values, idealy it would match some blackbody radiation)\nconst vec3 W0 = vec3(.54,.67,1.)*10.25;\n//(it's roughly a 12800K blackbody here)\n\n// rec.709 primaries relative luminance (or luma)\nconst vec3 lum = vec3(0.2126,0.7152,0.0722);\n","name":"Common","description":"","type":"common"}]}