{"ver":"0.1","info":{"id":"XsKSRm","date":"1463673169","viewed":889,"name":"rings on water from rain","username":"Emil","description":"rings on water. useful as a displacement/height map or similair\n\nUse mouse to zoom","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 randVec(float inVal){\n    \n    return vec2(fract(sin(dot(vec2(inVal*1.1,2352.75053) ,vec2(12.9898,78.233))) * 43758.5453)-0.5,\n                fract(sin(dot(vec2(715.23515, inVal) ,vec2(27.2311,31.651))) * 65161.6513)-0.5);\n                \n}\n\nfloat randFloat(vec2 inVal){\n    return fract(sin(dot(vec2(inVal.x, inVal.y) ,vec2(89.4516,35.516))) * 13554.3651);\n                \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Controls:\n    float zoom = 0.6+0.46*sin(iTime*0.6);\n    zoom = 0.9+pow(((iMouse.x+iMouse.y)/iResolution.x)*1.,3.0);\n    float sharpness = 4.5*zoom; // maybe plug in ddx and ddy here to mimic mip-mapping (avoid artifacts at long distances)\n    //sharpness = 6.5; // uncomment this line to see when it's not \"blurring\" when zoomed out, crispy!\n    float expansionSpeed = 4.0;\n    float rainSpeed = 0.6;\n    float numRings = 3.0;\n    const float numIterations = 4.;\n    float strength = 0.3;\n    \n    // other numbers:\n    const float pi = 3.141592;\n    float newTime = iTime*rainSpeed;\n    \n    vec2 uv;\n    vec2 uvStep;\n    fragColor = vec4(0.);\n    for(float iterations = 0.; iterations < numIterations; iterations++){\n        for(float xpos = -1.;xpos<=1.;xpos++){\n            for(float ypos = -1.;ypos<=1.;ypos++){\n                uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n                uv /= zoom;\n                uv += iterations*vec2(3.21,2.561);\n                uv += vec2(xpos*0.3333,ypos*0.3333);\n                uvStep = (ceil((uv*1.0-vec2(.5,.5)))/1.);\n                uvStep += vec2(xpos,ypos)*100.;\n                uv = vec2(fract(uv.x+0.5)-.5,fract(uv.y+0.5)-.5);\n\n                // Variables:\n                float timeRand = randFloat(uvStep);\n                float timeLoop = fract(newTime+timeRand);\n                float timeIter = floor(newTime+timeRand);\n\n\n                /// Creating ringMap:\n                float ringMap = sharpness*9.*distance(uv, randVec(timeIter+uvStep.x+uvStep.y)*0.5);\n                //float ringMap = sharpness*9.*distance(uv, randVec(0.)*0.);\n                float clampMinimum = -(1.+((numRings-1.)*2.0));\n                ringMap = clamp((ringMap-expansionSpeed*sharpness*(timeLoop))+1., clampMinimum, 1.);\n\n                // Rings and result\n                float rings = (cos((ringMap+newTime)*pi)+1.0)/2.;\n                rings *= pow(1.-timeLoop,2.);\n                float bigRing = sin((ringMap-clampMinimum)/(1.-clampMinimum)*pi);\n                float result = rings * bigRing;\n                fragColor += vec4(result)*strength;\n            }\n        }\n    }\n    \n    // Debuging:\n    /*\n    float uvCorners = (abs(uv.x*2.)>0.45&&abs(uv.x*2.)<0.55)&&(abs(uv.y*2.)>0.45&&abs(uv.y*2.)<0.55)?1.0:0.0;\n    fragColor += 0.5*vec4(uvCorners); // border overlay\n    fragColor += 0.4*vec4(fract(uvStep.x*0.1)+fract(uvStep.y*0.1));\n    //*/\n}","name":"Image","description":"","type":"image"}]}