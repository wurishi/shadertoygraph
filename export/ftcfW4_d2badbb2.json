{"ver":"0.1","info":{"id":"ftcfW4","date":"1663527668","viewed":103,"name":"Lab 2 ThomasPickles","username":"ThomasPickles","description":"Student version of path tracing lab","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing","lab"],"hasliked":0,"parentid":"7tdGDs","parentname":"Lab 2 student version"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Lab #2: path-tracing in shadertoy\n *\n *\n * This shader implements a path tracer that treats diffuse materials only.\n *\n * 1. The first task is to add a sphere in the scene.\n *\n *    You will need to complete the function \"intersect_sphere\" to achieve this.\n *    To do this you can use the formula for line/sphere intersection (eg https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection)\n *    This requires you to compute the distance \"d\" to the intersection along the ray from the ray origin.\n *\n *    If you return this distance correctly you will get a black sphere: to get diffuse shading,\n *    you also need to compute the (normalized) normal.\n *\n *\n *    You can use ray from the center to the intersection point which defines this normal. Use ray_at\n *    to find the intersection point. Pay attention to all the special cases.\n *\n *    Once you have finished this routine, you should have a diffuse sphere in the middle of the scene.\n *    Question: Explain what happened when you correctly assigned the normal.\n *       Answer: Assigning the normal correctly implements\n *        Lambert's cosine law, which is the ideal diffuse reflectance,\n *        and represents the power/intensity of the light hitting the surface.\n *        Intuitively, light hitting in the direction along the surface\n *        normal is bright, whereas shallow, raking light only illuminates\n *        a surface gently.\n *\n *\n * 2. We will now add a glossy BRDF, and in particular the Ward BRDF. We will be using the\n *    notes from Bruce Walter for this:\n *\n *    http://www.graphics.cornell.edu/pubs/2005/Wal05.html\n *\n *    Start by carefully reading section 1 and 2 to understand the method.\n *\n *    Change the material property of the sphere to be MAT_GLOSSY (after the intersection)\n *    and write the function WardBRDF, using Eq.(4) of the pdf document above. All vectors are given in\n *    local coordinate space. Currently, the BRDF is sampled using the uniform distribution,\n *    same as the diffuse case.\n *\n *\n *    Questions:\n *        What do you observe for pixels of the glossy sphere ?\n \nThe surface of the sphere now show distinct reflections of the walls and the floor.\n\n *        What do you observe for the scene in general ?\n\nThe scene contains lots of bright pixels, known as fireflies.  This is a result of\nrays being cast from the pixel to the light source directly\n\n*\n *    Save the image (right button, save image as) and provide this with your lab code.\n *\n *\n * 3. We will now add importance sampling. To do this, you need to modify WardPDF so that\n *    it uses Eq.(9) of the pdf above.\n *    First you need to modify getOutDir to find the outgoing direction.\n *    To do this, you need to use Eq. (6), (7) and (8) from the pdf document to get the\n *    half-vector of the outgoing direction. You need to understand the geometry\n *    explained in Fig. 2 to achieve this correctly.\n *\n *    You will need to understand how the half vector is parameterized, and how to convert\n *    into spherical coordinates (see Eq. (1) and (5)) so you can find theta and phi.\n *\n *    You will need to use the following helper functions:\n *       - get_random that gives a random number between 0 and 1\n *       - WorldToLocal and LocalToWorld that transform vectors between the world\n *         coordinate system and the local coordinate system of the BRDF( see Fig. 1\n *         of the pdf document  and the slides in class.)\n *    You will  need to use Eq(5) to convert from angles to vectors.\n *    Dont forget to ouput the values of theta_h and phi_h\n *\n *    Be careful about the orientation of the vectors.\n *\n *    Once you have this, you need to modify the function WardPDF to compute the correct\n *    value, using Eq. (9) of the pdf. You can use g_alpha which is a global variable\n *    holding the alpha value of the sphere.\n *\n *    Questions:\n *        What do you observe for pixels of the glossy sphere before and after each step,\n *         ie changing getOutDir ?\n *        Answer:....\n *        What do you observe for the scene in general ?\n *        Answer:....\n *    Save the image (right button, save image as) and provide this with your lab coe.\n *\n *    Numerical precision:\n *    Make the image full screen:\n *    Question: What do you observe at the borders of the sphere ?\n *    Answer:...\n *\n *    This problem is due to the fact that Eq.(8) sometimes generates directions in the opposite\n *    direction of the normal. To reduce these problems, identify and ignore these cases (add a parameter to\n *    return an error from getOutDir, and break the loop).\n *\n *    Question: What do you observe ?\n *    Answer:...\n *\n *  4. Experiment with various parameters:\n *\n *     - Change the roughness (alpha parameter) of the sphere and save the images (change between 0.08 and 0.25).\n *\n *     Question: What do you observe ?\n *     Answer: ....\n *\n *    - The version so far sets g_alpha = alpha_x == alpha_y which is the isotropic version of the Ward BRDF\n *      Modify the code to take separate values and show the effect of changing the values on the final image.\n *      Verify all equations to make sure you use the correct values everywhere.\n *\n *     Question: What do you observe ?\n *     Answer: ....\n *\n *     Save several images with different values of alpha_x and alpha_y\n *\n *\n *     - Change the number of samples and save the images\n *     Question: What do you observe ?\n *     Answer: ....\n *\n *     - Change the number of bounces and save the images\n *     Question: What do you observe ?\n *     Answer: ....\n *\n *\n *\n *  5. Output and save several images that you will use for denoising with a neural network. Run the network on the\n *     noisy images with different numbers of samples, and save the pairs \"noisy/denoised\".\n *\n *  Extensions for Projects:\n *         * Implement simple version of bi-directional path tracing\n *              Reference: http://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/M2MRI/2006/veach-combine.pdf\n *        (Also PBRT book http://pbrt.org )\n *\n *         * Implement simple version of practical path guiding\n *              References: https://tom94.net/data/publications/hart20practical/hart20practical.pdf\n *         * Bonus: Evaluate pre-trained denoisers (required access to a linux machine with a GPU)\n *              References: E.g., https://groups.csail.mit.edu/graphics/rendernet/\n *\n */\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n#define INFINITY 9999999.0\n#define PI 3.141592653589\n#define NUM_SAMPLES 8\n#define NUM_BOUNCES 2\n\n#define MAT_UNDEF   0\n#define MAT_DIFFUSE 1\n#define MAT_GLOSSY  2\n#define MAT_EMISSION 3\n\n#define EPSILON 0.00001\n\nfloat g_light_size;\nfloat g_light_area;\nvec3 g_light_position;\nvec3 g_light_normal;\nint g_seed;\nvec4 g_light_albedo;\nint g_flat_idx;\nfloat g_rho_s = 0.7, g_rho_d = 0.2, g_alpha = 0.1;\n\nvec3 sphere2_center = vec3(0.5, -0.4,  -0.1);\n\n// Sampling routines\n\nvec2\nsample_disk(vec2 uv)\n{\n\tfloat theta = 2.0 * 3.141592653589 * uv.x;\n\tfloat r = sqrt(uv.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3\nsample_cos_hemisphere(vec2 uv)\n{\n\tvec2 disk = sample_disk(uv);\n\treturn vec3(disk.x, sqrt(max(0.0, 1.0 - dot(disk, disk))), disk.y);\n}\n\nvec3\nsample_light(vec2 rng)\n{\n\treturn g_light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * g_light_size;\n}\n\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\n// Routines for random number generation\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\n// return a random 2D vector\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(g_flat_idx, g_seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\n\n// Basic Ray data structures\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\n// Axis Aligned Bounding Box\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\n// intersection\nstruct its {\n    float t; // distance to intersection\n    int material; // = MAT_GLOSSY; // MAT_GLOSSY or MAT_DIFFUSE\n    vec4 albedo;\n    vec3 position;\n    vec3 normal;\n};\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\n\n// intersection routines\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\n\n\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\t\tp /= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_light(Ray ray)\n{\n\tfloat t = intersect_plane(ray, g_light_position, g_light_normal);\n\n\tvec3 p = ray_at(ray, t);\n\tif(all(lessThan(abs(g_light_position - p).xz, vec2(g_light_size * 0.5)))) {\n\t\treturn t;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_sphere(in Ray ray, inout float t_max, inout vec3 normal, in vec3 c /* center*/ , in float r /* radius */)\n{\n    float t_min = 1000.0;\n    float delta = pow(dot(ray.dir, ray.origin - c),2.) - (dot(ray.origin - c, ray.origin - c) - pow(r,2.));\n    if (delta < 0.0) return INFINITY;\n\n    float t = -dot(ray.dir, ray.origin - c) - pow(delta,0.5);\n    vec3 intersection = ray_at(ray, t);\n    normal = intersection - c;\n    return t > 0.0 ? t : INFINITY;\n}\n\n\n\n\n// Intersect the scene by visiting each object\n\nits\nintersect(Ray ray)\n{\n\tfloat t_min = INFINITY;\n    its ret_its;\n\n    ret_its.t = 0.0;\n    ret_its.material = MAT_UNDEF;\n    ret_its.albedo = vec4(0.0);\n\n\t{\n\t\tfloat t = intersect_light(ray);\n\t\tif(t < t_min) {\n\t\t\t//albedo = vec3(100);\n\t\t\tret_its.albedo = g_light_albedo;\n\t\t\t//albedo = vec3(dot(ray.dir, g_light_normal) < 0.0 ? 1.0 : 0.0);\n\t\t\tret_its.normal = g_light_normal;\n\t\t\tt_min  = t;\n\t\t\tret_its.position = ray_at(ray, t);\n            ret_its.material = MAT_EMISSION;\n\t\t}\n\t}\n\n    // small box\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\tray_tmp.origin -= vec3(0.5, -0.75, 0.35);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.25, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tret_its.position = ray_at(ray, t);\n\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tret_its.normal = normal_tmp;\n            ret_its.material = MAT_DIFFUSE;\n\t\t}\n\t}\n\n    // sphere\n    {\n        vec3 c = vec3(0, 0, 0);\n        float r = 0.4;\n        vec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n        float t_max;\n\n\t\tfloat t = intersect_sphere(ray_tmp, t_max, normal_tmp, c, r);\n        if(t < t_min) {\n                t_min = t;\n                ret_its.position = ray_at(ray, t);\n                ret_its.albedo = vec4(.9, .9, .9, 0);\n                ret_its.normal = normal_tmp;\n                ret_its.material = MAT_GLOSSY;\n        }\n    }\n\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tret_its.albedo = vec4(0.9, 0.1, 0.1, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tret_its.albedo = vec4(0.1, 0.9, 0.1, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n\n\t\t\t\tt_min = t;\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tret_its.normal = n;\n\t\t\t\tret_its.position = p_tmp;\n\t\t\t\tret_its.albedo = vec4(0.7, 0.7, 0.7, 0);\n                ret_its.material = MAT_DIFFUSE;\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tret_its.normal = normalize(ret_its.normal);\n\n    ret_its.t = t_min;\n\n\treturn ret_its;\n}\n\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\n\tits t_shadow = intersect(r);\n\n\treturn t_shadow.t > distance(p1, p2) - 2.0 * eps;\n}\n\n// BRDF routines\n\n// all vectors wcs\n\nvec3 WorldToLocal( vec3 v, vec3 ss, vec3 ts, vec3 ns)  {\n\n    return vec3(dot(v, ss), dot(v, ts), dot(v, ns));\n}\n\nvec3 LocalToWorld( vec3 v, vec3 ss, vec3 ts, vec3 ns)\n{\n    return vec3(ss.x * v.x + ts.x * v.y + ns.x * v.z,\n                    ss.y * v.x + ts.y * v.y + ns.y * v.z,\n                    ss.z * v.x + ts.z * v.y + ns.z * v.z);\n}\n\n// define tangent space; all vectors in *world frame*\nvoid\ndefineTangents(vec3 outdir, vec3 normal, inout vec3 s, inout vec3 t)\n{\n      s = cross(outdir, normal);\n      s = normalize(s);\n      t = cross(s, normal);\n      t = normalize(t);\n}\n\n// indir is in World Coordinates\nvec3\ngetOutDir(its inters, vec3 s, vec3 t, vec3 indir, inout float theta, inout float phi, inout bool is_opp)\n{\n    vec2 rand_2d = get_random();\n    float u = abs(rand_2d[0]);\n    float v = abs(rand_2d[1]);\n    \n    indir = - indir; // paper defines this as away from surface\n    \n    // Convert world coords to local coords\n    vec3 local_indir = WorldToLocal(indir, s, t, inters.normal);\n   \n    // isotropic material, alpha_x = alpha_y = g_alpha\n    // simplifies equations significantly\n    \n    // eqn 7 becomes\n    phi = 2. * PI * v; \n    \n    // eqn 6 simplifies too\n    theta = atan(g_alpha*pow(-log(u),0.5));\n    \n    // eqn 5 in paper\n    vec3 h = vec3(sin(theta)*cos(phi), sin(theta)*sin(phi),  cos(theta));\n    \n    vec3 wcs_odir;\n    if(inters.material == MAT_GLOSSY) {\n        // importance sampling\n        vec3 local_odir = 2.0 * dot(local_indir, h) * h - local_indir;\n        // convert back to world coords\n        wcs_odir = LocalToWorld(local_odir, s, t, inters.normal);\n    } else {\n        // uniform sampling on hemisphere\n        mat3 onb = construct_ONB_frisvad(inters.normal);\n        wcs_odir = normalize(onb * sample_cos_hemisphere(get_random())); \n    }\n    \n    if(dot(wcs_odir,indir) < 0.)\n        is_opp = true;\n    \n    return wcs_odir;\n\n}\n\nfloat\ncdot(vec3 v1, vec3 v2)\n{\n    return max (0., dot(v1, v2));\n}\n\n\n// all vectors in local frame !\n// Eqn 4 in Wal05 paper\nfloat\nWardBRDF(vec3 i, vec3 o, float alpha, float rho)\n{\n   float res = 0.;\n   vec3 n = vec3(0,0,1);\n   vec3 x = vec3(1,0,0);\n   vec3 y = vec3(0,1,0);\n   vec3 h = normalize(i + o);\n\n   float prefactor = rho / (4.0* PI* pow(alpha,2.)*pow(dot(i,n)*dot(o,n),0.5));\n   float exponent = (pow(dot(h,x)/alpha,2.) + pow(dot(h,y)/alpha,2.)) / (pow(dot(h,n),2.));\n   res = prefactor * exp(-exponent);\n   return res ;\n}\n\n\n\nfloat\nWardPDF(vec3 o, vec3 i, float thh, float phih)\n{\n     \n\n    // h = i + o => h.i = i^2 + i.o\n    float prefactor = 4.*PI*pow(g_alpha,2.)*dot(i+o,i)*pow(cos(thh),3.);\n    \n    // using isotropic alpha_x = alpha_y, so exponent simplifies to \n    // have no dependence on phih\n    float exponent = pow(tan(thh)/g_alpha,2.);\n    \n    float rval = (1./prefactor)*exp(-exponent);\n    \n    //return 1. / PI;\n    return  (rval);\n\n}\n\n\n\nvec3\nevalBRDF(its inter, inout float brdf_pdf, vec3 wcs_indir, vec3 wcs_outdir, vec3 s, vec3 t, float th, float ph)\n{\n    if( inter.material == MAT_DIFFUSE ) {\n        vec3 brdf = inter.albedo.rgb / PI;\n        brdf_pdf = 1.0 / PI;\n        return brdf;\n    }\n    else if( inter.material == MAT_GLOSSY ) {\n        vec3 local_idir =  normalize( WorldToLocal(wcs_indir, s, t, inter.normal  ));\n        vec3 local_odir =  normalize( WorldToLocal(wcs_outdir, s, t, inter.normal  ));\n\n        vec3 brdf = g_rho_d * 1./PI * inter.albedo.rgb + g_rho_s * WardBRDF( local_idir, local_odir, g_alpha, g_rho_s);\n        brdf_pdf = g_rho_s * WardPDF(-local_odir, local_idir, th, ph);\n\n        return brdf;\n    }\n}\n\n// path tracing with MIS\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n\tits inters = intersect(ray);\n\n    position = inters.position;\n    normal = inters.normal;\n    albedo = inters.albedo;\n    float t = inters.t;\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(albedo.a > 0.0) { /* hit light source */\n\t\treturn albedo.rgb * albedo.a;\n\t}\n\n    Ray currRay = ray;\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\n\n\t\t{ /* NEE */\n\t\t\tvec3 pos_ls = sample_light(get_random());\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee /= sqrt(rr_nee);\n\t\t\tfloat G = max(0.0, dot(normal, l_nee)) * max(0.0, -dot(l_nee, g_light_normal)) / rr_nee;\n            vec3 sv, tv;\n            float theta =0.0, phi=0.0;\n\n            defineTangents(currRay.dir, inters.normal, sv, tv);\n\n\t\t\tif(G > 0.0) {\n\t\t\t\tfloat light_pdf = 1.0 / (g_light_area * G);\n\t\t\t\tfloat brdf_pdf;\n\n\t\t\t\tfloat w = light_pdf / (light_pdf + brdf_pdf);\n\n                vec3 h_wcs = normalize(l_nee+currRay.dir);\n                vec3 h_local = WorldToLocal(h_wcs, sv, tv, inters.normal);\n\n                float theta = acos(h_local.z);\n                float phi = h_local.y/(sin(theta));\n\n\t\t\t\tvec3 brdf = evalBRDF(inters, brdf_pdf, l_nee, -currRay.dir, sv, tv, theta, phi);\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tvec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n\t\t\t\t\tcontrib += tp * (Le * w * brdf) / light_pdf;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n    { /* brdf */\n            vec3 sv, tv;\n\n            defineTangents(-currRay.dir, inters.normal, sv, tv);\n            float theta, phi;\n            bool is_opposite;\n\n\t\t\tvec3 dir = getOutDir(inters, sv, tv, currRay.dir, theta, phi, is_opposite);\n\n            if(is_opposite)\n                break;\n\n\t\t\tRay ray_next = Ray(position, dir);\n\t\t\tray_next.origin += ray_next.dir * 1e-5;\n\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tvec4 albedo_next;\n\t\t\tits inters_next = intersect(ray_next);\n            position_next = inters_next.position, normal_next = inters_next.normal, albedo_next = inters_next.albedo;\n            t = inters_next.t;\n\n\n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            float brdf_pdf;\n\n            vec3 brdf = evalBRDF(inters, brdf_pdf, -dir, currRay.dir, sv, tv, theta, phi);\n\n\t\t\tif(albedo_next.a > 0.0) { /* hit light_source */\n\t\t\t\tfloat G = max(0.0, dot(ray_next.dir, normal)) * max(0.0, -dot(ray_next.dir, normal_next)) / (t * t);\n\t\t\t\tif(G <= 0.0) /* hit back side of light source */\n\t\t\t\t\tbreak;\n\n\t\t\t\tfloat light_pdf = 1.0 / (g_light_area * G);\n\n\t\t\t\tfloat w = brdf_pdf / (light_pdf + brdf_pdf);\n\n\t\t\t\tvec3 Le = g_light_albedo.rgb * g_light_albedo.a;\n\t\t\t\tcontrib += tp * (Le * w * brdf) / brdf_pdf;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttp *= brdf / brdf_pdf;\n\n            currRay = ray_next;\n\n            inters = inters_next;\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\talbedo = albedo_next;\n\t\t}\n\n\t}\n\n\n\treturn contrib;\n}\n\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    g_light_size = 0.6;\n\tg_light_area = g_light_size * g_light_size;\n\n\t// Uncomment to make light move (comment following line)\n    g_light_position = vec3(0.5 * sin(iTime), 0.90, 0.5 * cos(iTime));\n\n\tg_light_normal = vec3(0, -1, 0);\n\tg_seed = 0;\n\tg_light_albedo = vec4(1, 1, 1, 2.0 / (g_light_size * g_light_size));\n\tg_flat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n    vec4 m = iMouse / iResolution.x;\n\n\tif( m.z>0.0 ) { // button is down\n        sphere2_center = sphere2_center +  vec3(-0.1, 0., 0.3);\n        // move light down\n        g_light_position += vec3(0, -0.4, 0);\n    }\n\n    // Make image square\n\tvec2 p = fragCoord.xy  / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\tvec3 cam_center = vec3(0, 0, 3.125);\n\n\tvec3 s = vec3(0);\n\n    // trace NUM_SAMPLES per pixel\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\n        // get random 2-D vector\n\t\tvec2 r = get_random();\n\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -1));\n\t\tray.dir = ray_dir;\n\n        // do path tracing and MIS\n\t\tvec3 c = pt_mis(ray);\n\n        // accumulate color in variable s\n\t\ts += c;\n\t}\n\n    // gamma correct\n\tfragColor = vec4(pow(s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}