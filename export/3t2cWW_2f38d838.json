{"ver":"0.1","info":{"id":"3t2cWW","date":"1594623334","viewed":178,"name":"Doughnut GodRay","username":"Johnblu","description":"光线步进渲染的甜甜圈，并且具有阴影和上帝光.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fov 60.0\n#define beginCamPosition vec3(0.0, 0.0, -14.0)\n \n#define doughnutOffset 1.5\n#define doughnutRadius 0.6\n#define surfaceThreshold 1e-1\n \n#define planeHeight -4.0\n#define farClip 1e+4\n \n#define mainColor vec4(1.0,0.9,0.3,1.0)\n \nfloat plane_dist_estimator(in vec3 camPos, in vec3 viewDir)\n{\n    if(viewDir.y < 0.0 && camPos.y > planeHeight)\n    {\n        return abs(camPos.y - planeHeight) / abs(viewDir.y);\n    }\n    else if(viewDir.y > 0.0 && camPos.y < planeHeight)\n    {\n        return abs(camPos.y - planeHeight) / abs(viewDir.y);\n    }\n    return farClip;\n}\n \nfloat doughnut_dist_estimator(in vec3 surface_pos, in mat3 obj2WorldRot, in mat3 world2ObjRot)\n{\n    vec3 objPos = world2ObjRot * surface_pos;\n    objPos = vec3(objPos.x,0,objPos.z);\n    vec3 worldPos = obj2WorldRot * objPos;\n    \n    //一个平躺的甜甜圈\n    vec3 refPoint = normalize(worldPos) * doughnutOffset;\n    float len = length(surface_pos - refPoint);\n    return len - doughnutRadius;\n}\n \nvec3 surface_normal(in vec3 surface_pos, in mat3 obj2WorldRot, in mat3 world2ObjRot)\n{\n    vec3 objPos = world2ObjRot * surface_pos;\n    objPos = vec3(objPos.x,0,objPos.z);\n    vec3 worldPos = obj2WorldRot * objPos;\n    \n    //一个平躺的甜甜圈\n    vec3 refPoint = normalize(worldPos) * doughnutOffset;\n    return normalize(surface_pos - refPoint);\n}\n \nfloat surface_shadow(in vec3 surface_pos, in vec3 lightDir, in mat3 obj2WorldRot, in mat3 world2ObjRot)\n{\n    float dis = 0.1;\t//计算阴影必须有一个初始的距离\n    for(int i = 0; i < 32; ++i)\n    {\n        float delta = doughnut_dist_estimator(surface_pos + dis * -lightDir,obj2WorldRot,world2ObjRot);\n        dis += delta;\n        if (delta < surfaceThreshold)\n            return 0.0;\n    }\n    \n    return 1.0;\n}\n \nvec4 intersects(in vec3 camPos, in vec3 viewDir, in vec3 lightDir, in mat3 obj2WorldRot, in mat3 world2ObjRot,\n               out float resultDis)\n{\n    //射线查甜甜圈位置\n    float dis = 0.0;\n    for (int i = 0; i < 255; ++i)\n    {\n        float delta = doughnut_dist_estimator(camPos + dis * viewDir, obj2WorldRot, world2ObjRot);\n        dis += delta;\n        if (delta < surfaceThreshold)\n        {\n            resultDis = dis;\n            \n            //查询到甜甜圈\n            vec3 surface_pos = camPos+ viewDir * dis;\n        \tvec3 normalDir = surface_normal(surface_pos, obj2WorldRot, world2ObjRot);\n        \n        \tfloat dotv = dot(normalDir, -lightDir) * 0.5 + 0.5;\n        \tdotv = mix(0.1,1.0,dotv);\n        \treturn mainColor * dotv * 1.0;\n        }\n    }\n    \n    //射线查地面位置\n    dis = plane_dist_estimator(camPos, viewDir);\n    if(dis < farClip)\n    {\n        resultDis = dis;\n        \n        vec3 surface_pos = camPos+ viewDir * dis;\n        vec3 normalDir = vec3(0,1,0);\n        \n        float dotv = dot(normalDir, -lightDir) * 0.5 + 0.5;\n        dotv = mix(0.2,1.0,dotv);\n        \n        float interplate = mod(floor(surface_pos.x * 0.5) + floor(surface_pos.z * 0.5),2.0);\n        vec4 col = mix(vec4(0.5, 0.5, 0.5, 1),vec4(1, 1, 1, 1),interplate) * dotv;\n        float shadow = surface_shadow(surface_pos, lightDir, obj2WorldRot, world2ObjRot);\n        col = mix(mainColor * 0.5 * col,col,shadow);\n        \n        return mix(col, vec4(0.4,0.7,0.9,1), smoothstep(5.0,50.0,dis));\n    }\n    \n    //天空盒颜色\n    resultDis = farClip;\n    return vec4(0.4,0.7,0.9,1);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //甜甜圈的变换矩阵\n    float rotSpeed = iTime * 0.6;\n \n    vec3 tmpX0 = vec3(1,0,0);\n    vec3 tmpX1 = vec3(0,cos(rotSpeed),-sin(rotSpeed));\n    vec3 tmpX2 = vec3(0,sin(rotSpeed),cos(rotSpeed));\n    mat3 rotX = mat3(tmpX0,tmpX1,tmpX2);\n    \n    rotSpeed *= 2.0;\n    \n    vec3 tmpY0 = vec3(cos(rotSpeed),0,sin(rotSpeed));\n    vec3 tmpY1 = vec3(0,1,0);\n    vec3 tmpY2 = vec3(-sin(rotSpeed),0,cos(rotSpeed));\n    mat3 rotY = mat3(tmpY0,tmpY1,tmpY2);\n    \n    rotSpeed *= 2.0;\n    \n    vec3 tmpZ0 = vec3(cos(rotSpeed),-sin(rotSpeed),0);\n    vec3 tmpZ1 = vec3(sin(rotSpeed),cos(rotSpeed),0);\n    vec3 tmpZ2 = vec3(0,0,1);\n    mat3 rotZ = mat3(tmpZ0,tmpZ1,tmpZ2);\n    \n    mat3 obj2WorldRot = rotZ * rotX * rotY;\n    mat3 world2ObjRot = inverse(obj2WorldRot);\n    //甜甜圈的变换矩阵结束\n    \n    //摄像机旋转,拖动屏幕可以旋转摄像机\n    float radian = mix(-3.1415926,3.1415926,-iMouse.x / iResolution.x);\n    vec3 tmpCamY0 = vec3(cos(radian),0,sin(radian));\n    vec3 tmpCamY1 = vec3(0,1,0);\n    vec3 tmpCamY2 = vec3(-sin(radian),0,cos(radian));\n    mat3 rotCamY = mat3(tmpCamY0,tmpCamY1,tmpCamY2);\n    //摄像机旋转结束\n    \n    //------------------------------------------------------------------\n    \n    vec2 uv = (vec2(fragCoord.x - iResolution.x / 2.0, fragCoord.y - iResolution.y / 2.0) / max(iResolution.x, iResolution.y)) * 2.0;\n    float tanValue = tan(radians(fov * 0.5));\n    float cameraDis = (iResolution.y / iResolution.x) / tanValue;\n    vec3 viewDir = normalize(vec3(uv, cameraDis));\t//这里通过fov确定每个像素的观察方向\n    viewDir = rotCamY * viewDir;\n    \n    float lightRotSpeed = iTime * 0.5;\n    vec3 lightDir = normalize(vec3(sin(-lightRotSpeed), -1, sin(lightRotSpeed * 2.0)));\n    \n    float resultDis;\n    vec3 camPosition = rotCamY * beginCamPosition;\n    fragColor = intersects(camPosition, viewDir, lightDir, obj2WorldRot, world2ObjRot, resultDis);\n    \n    //上帝光体积渲染\n    float sinV0 = sqrt(1.0 - pow(dot(normalize(vec3(0,0,0) - camPosition),lightDir),2.0));\n    float beginVertical = length((vec3(0,0,0) - camPosition)) * sinV0 - (doughnutOffset + doughnutRadius);\n    float endVertical = length((vec3(0,0,0) - camPosition)) * sinV0 + (doughnutOffset + doughnutRadius);\n\t\n    float sinV1 = sqrt(1.0 - pow(dot(lightDir,viewDir),2.0));\n    //这里算的是光线步进的开始距离与结束距离\n    float beginDis = beginVertical / sinV1;\n    float endDis = endVertical / sinV1;\n    \n    float totalRay = 0.0;\n    for (float i = beginDis; i < endDis; i += 0.2)\n    {\n        float totalDis = i;\n        if(totalDis > resultDis)\n        {\n            break;\n        }\n\t\tvec3 pos = camPosition + viewDir * totalDis;\n        float shadow = surface_shadow(pos, lightDir, obj2WorldRot, world2ObjRot);\n        totalRay += 1.0 - shadow;\n    }\n    \n    fragColor = mix(fragColor,mainColor,totalRay * 0.04);\n    \n    return;\n}","name":"Image","description":"","type":"image"}]}