{"ver":"0.1","info":{"id":"dstfW4","date":"1697187856","viewed":39,"name":"High rise","username":"ChthonicF4","description":"having fun , there is a being clibing up to my window","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","building"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec4 map(in vec3 p) {\n\n    float d = 1000.;\n    vec3 col = vec3(1.);\n    \n    vec3 pp = p ; //map for the person\n    \n    // person\n    float dp = 1000.;\n        //body\n    dp = min(dp ,sdVerticalCapsule(p-vec3(.13,.0,.0),.06,.01));\n        //front legs\n    dp = min(dp,sdCapsule(p-vec3(.13,.0,.015),vec3(.0,.0,.0),vec3(-.03,.0-.02*sin(iTime*20.),.0),.01));\n    dp = min(dp,sdCapsule(p-vec3(.13,.0,-.015),vec3(.0,.0,.0),vec3(-.03,.0+.02*sin(iTime*20.),.0),.01));\n        //back legs\n    dp = min(dp,sdCapsule(p-vec3(.13,.06,.015),vec3(.0,.0,.0),vec3(-.03,.0+.02*sin(iTime*20.),.0),.01));\n    dp = min(dp,sdCapsule(p-vec3(.13,.06,-.015),vec3(.0,.0,.0),vec3(-.03,.0-.02*sin(iTime*20.),.0),.01));\n\n    p.y += iTime*.5 ;\n    \n    vec3 po = p ; \n    \n    \n    p.z = mod(p.z,.4);\n    \n    p.y = mod(p.y,.2);\n    \n    p -= vec3(.0,.1,.2); \n    \n    // main section\n    d = min(d,sdBox(p,vec3(.1,.101,.201)));\n    \n    // windows \n    \n    d = max(d,-sdBox(p-vec3(.1,0.,0.),vec3(.0201,.04,.1))) ;\n    float db = sdBox(p-vec3(.06,0.,0.),vec3(.02,.04,.1)) ; // window colour\n    \n    // railings\n    \n    d = min(d,sdBox(p-vec3(.1-.002,0.,0.),vec3(.002,.002,.1)));\n    \n    d = min(d,sdBox(p-vec3(.1-.002,0.-.02,0.-.05),vec3(.002,.02,.002)));\n    \n    d = min(d,sdBox(p-vec3(.1-.002,0.-.02,0.),vec3(.002,.02,.002)));\n    \n    d = min(d,sdBox(p-vec3(.1-.002,0.-.02,0.+.05),vec3(.002,.02,.002)));\n    \n    \n    if (d < dp) col += texture(iChannel0,vec2(po.z*.2,po.y*.2)).rgb*.3;\n    else col = vec3(.2);\n    \n    d = min(d,dp); \n    \n    if (db < d) {\n    col = vec3(.1,.2,.3)+texture(iChannel1,vec2(po.z*2.,po.y)).rgb*.2 ;\n    }\n    \n    // glow\n    \n    col += max(pow(1./((db+0.01)*2.),0.8),0.)*vec3(.1);\n    \n    return vec4(col,d);\n\n}\n\n\nconst float MaxDist = 7.;\n\nvec3 RayMarch( in vec3 pos , in vec3 direction) {\n    \n    // ray march settings\n    float t = map(pos).w ;\n    float h = 0. ; \n    float an = 0.5*(iTime-10.0);\n    for (int i=0;i<256;++i) {\n        // get new position\n        pos = pos + t*direction ;\n        // get closest distance \n        h = map(pos).w ; \n        // check if hit somthing or have gone too far\n        if (h < 0.0001 || t > MaxDist) break;\n        // set safe move distance to h\n        t = h ;        \n    }\n    // return the position at the end of the ray marching\n    return pos ;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ).w + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ).w + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ).w + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ).w );\n}\n\nvec3 Shading (in vec3 pos) {\n\n    if (length(pos) > MaxDist) return vec3(.0); \n\n    vec4 cold = map(pos);\n    \n    vec3 normal = calcNormal(pos) ; \n    \n    float dif = clamp( dot(normal,vec3(0.57703)), 0.0, 1.0 ) ; \n    float amb = 0.5 + 0.5*dot(normal,vec3(0.0,1.0,0.0)) ;\n    \n    // fog\n    \n    float intensity = (length(pos)/MaxDist) ; \n    \n    cold.xyz *= (1.-intensity);\n    \n    // combine\n        \n    cold.xyz *= vec3(0.1,0.2,0.3)*amb + vec3(0.8,0.7,0.5)*dif ;\n    \n    return sqrt(cold.xyz) ; \n} \n\n// drawing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert to point \n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y ; \n    \n     // camera movement\t\n     //ro => ray origin \n     //rd => ray direction \n     //an => angle (used for camera movement)\n     //ta => target point \n    float an = .2*(iTime-10.0);\n\tvec3 ro = vec3( .4 - .2*sin(an), 0.3*sin(an*.2), - .2*cos(an));\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // ray direction \n    vec3 rd = normalize( uv.x*uu + uv.y*vv + 1.5*ww );\n    \n    vec3 point = RayMarch(ro,rd) ;\n    \n    vec3 col = Shading(point) ;\n    \n    // vinyet \n    \n    col *= 1. - length(fragCoord/iResolution.xy -.5)*.3;\n    \n    fragColor = vec4(col,1.) ;    \n}","name":"Image","description":"","type":"image"}]}