{"ver":"0.1","info":{"id":"Dtyfzw","date":"1701907127","viewed":16,"name":"snowglobe - GIG Final project","username":"jkom","description":"Merry Christmas!!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["snowglobe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SAFEMARCH = 0.7;\nconst int NUM_PARTICLES = 70; \nconst float PARTICLE_RADIUS = 0.02; \nconst float START_HEIGHT = 0.75; \nconst float END_HEIGHT = -0.27; \nconst vec3 TRANSPARENT_SPHERE_POS = vec3(0.0, -0.1, 0.0); \nconst float TRANSPARENT_SPHERE_RADIUS = 0.5; \n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat dot2(vec2 v) {\n    return dot(v, v);\n}\n\nfloat dot2(vec3 v) {\n    return dot(v, v);\n}\n\n\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sdDecorations(vec3 p) {\n    float d = 1e10;\n    for (int i = 0; i < 24; ++i) { \n        float fi = float(i % 8); \n        float ring = floor(float(i) / 8.0); \n        float angle = fi * 0.75; \n        float height = -0.22 + ring * 0.16; \n        float radius = 0.1 - ring * 0.026; \n        vec3 spherePos = vec3(sin(angle) * radius, height, cos(angle) * (radius + 0.2));\n        d = opUnion(d, sdSphere(p - spherePos, 0.016)); \n    }\n    return d;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSnowglobe(vec3 p) {\n    float dBase = sdBox(p - vec3(0.0, -0.55, 0.0), vec3(0.3, 0.25, 0.3));\n\n    float torusRadiusA = 0.65; \n    float torusRadiusB = 0.01; \n\n    p.yz = p.zy;\n\n    float dTorus = sdTorus(p - vec3(0.0, 0.24, 0.2), vec2(torusRadiusA, torusRadiusB));\n\n    \n    return opUnion(dBase, dTorus);\n}\n\n\n\n\n\nfloat sdCone(vec3 p, float h, float r) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -q.y - h;\n    float d2 = max(dot(q, vec2(r / h, -1.0)), -q.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdTree(vec3 p) {\n    float d1 = sdCappedCone(p - vec3(0.0, 0.15, 0.0), 0.1, 0.07, 0.0); \n    float d2 = sdCappedCone(p - vec3(0.0, 0.03, 0.0), 0.15, 0.1, 0.0); \n    float d3 = sdCappedCone(p - vec3(.0, -0.15, 0.0), 0.2, 0.15, 0.0);  \n\n    return min(min(d1, d2), d3); \n}\n\n\n\nfloat sdStar(vec3 p, float scale) {\n    vec3 starPos = vec3(0.0, 0.45 * scale, 0.0); \n    return sdSphere(p - starPos, 0.05 * scale); \n}\n\n\n\nfloat sdFallingParticles(vec3 p, float time) {\n    float d = 1e10;\n    float fallDistance = START_HEIGHT - END_HEIGHT;\n    for (int i = 0; i < NUM_PARTICLES; ++i) {\n        float fi = float(i);\n        vec3 initialPos = vec3(sin(fi) * 0.4, START_HEIGHT, cos(fi) * 0.4); \n        float speed = 0.5 + mod(fi, 5.0) * 0.1; \n        float yPosition = initialPos.y - mod(time * speed + fi * 0.1, fallDistance);\n\n        vec3 particlePos = vec3(initialPos.x, yPosition, initialPos.z);\n        d = opUnion(d, sdSphere(p - particlePos, PARTICLE_RADIUS));\n    }\n    return d;\n}\nfloat map(vec3 p, float time) {\n    float dBase = sdSnowglobe(p);\n    float dParticles = sdFallingParticles(p, time);\n    float dTree = sdTree(p);\n    float dDecorations = sdDecorations(p); \n\n    float dObjects = opUnion(dTree, dDecorations); \n    return opUnion(opUnion(dBase, dParticles), dObjects); \n}\n\n\n\n\nvec3 calcNormal(vec3 p, float time) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        map(p + h.xyy, time) - map(p - h.xyy, time),\n        map(p + h.yxy, time) - map(p - h.yxy, time),\n        map(p + h.yyx, time) - map(p - h.yyx, time)\n    ));\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float tmin, float tmax, float time) {\n    for (float t = tmin; t < tmax;) {\n        vec3 rt = ro + t * rd;\n        float d = map(rt, time);\n        if (d < 0.0001) return t;\n        t += SAFEMARCH * d;\n        if (t >= tmax) return tmax;\n    }\n    return tmax;\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 mouse, float time) {\n    vec3 col = vec3(0.0);\n    float t = raymarch(ro, rd, 0.0, 10.0, time);\n    if (t < 10.0) {\n        vec3 p = ro + t * rd;\n        vec3 n = calcNormal(p, time);\n\n        vec3 lightPos = vec3(4.0 * mouse.x - 2.0, 4.0 * mouse.y - 2.0, 2.0);\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(n, lightDir), 0.0);\n\n        float dTree = sdTree(p);\n        float dDecorations = sdDecorations(p);\n        float dSnowglobe = sdSnowglobe(p);\n\n        if (dSnowglobe < 0.01) {\n            vec3 silverColor = vec3(0.6, 0.8, 1.0); \n            col = diff * silverColor;\n        } else if (dTree < 0.01) {\n            vec3 forestGreen = vec3(0.13, 0.55, 0.13); //  green \n            col = diff * forestGreen;\n        } else if (dDecorations < 0.01) {\n            vec3 redColor = vec3(1.0, 0.0, 0.0); // Red \n            col = diff * redColor;\n        } else {\n            col = diff * vec3(1.0, 1.0, 1.0); \n        }\n    }\n    return col;\n}\n\nvec3 background(vec3 D) {\n    vec3 col = texture(iChannel0, D).xyz;\n    \n    col.r -= 0.1;\n    col += 0.1;\n    col *= sqrt(col);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.4, 2.0); \n    vec3 target = vec3(0.0, 0.0, 0.0); \n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward); \n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n\n    vec3 col = render(ro, rd, mouse, iTime);\n\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}