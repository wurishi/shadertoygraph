{"ver":"0.1","info":{"id":"WdVBWR","date":"1606915409","viewed":182,"name":"DeSmoothStep","username":"lisichka","description":"Trying to draw line sweep\nUPD : found some \"solution\" by drawing line 3 times with offset by 1.0; Maybe someone have better approach? Do I need to use modulo?\nUPD 1: ahhh that is actually very simple, I've over engeneered this thing lol ))))","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["help","polar","step"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n\n\nfloat deStep(float x, float m, float w) {\n\t// here w is half width\n    x = fract((x - m + 0.5));\n    float low = 0.5 - w;\n    float high = 0.5 + w;\n    return step(low, x) * step(x, high);\n}\n\n\nfloat deSmoothStep(float x, float m, float w, float s) {\n\t// here w is half width\n    x = fract(x - m + 0.5);\n    float low = 0.5 - w;\n    float high = 0.5 + w;\n    return smoothstep(low-s, low, x) * smoothstep(high+s, high, x);\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n\treturn min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy - .5;\n  \tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n\tfloat col = 0.0;\n\n    float r = length(uv);\n    float a = map(atan(uv.y, uv.x), -PI, PI, 0.0, 1.0);  // angle mapped to 0.0 - 1.0  \n    float m = cos(iTime) / 10.0;\n    float halfwidth = 0.05;\n    \n    col += deSmoothStep(a, m, halfwidth, 0.01);\n    //col += deStep(a, m, halfwidth);\n     \n    fragColor = vec4(col * deStep(a, m, 0.001), col, col, 1.0);\n}","name":"Image","description":"","type":"image"}]}