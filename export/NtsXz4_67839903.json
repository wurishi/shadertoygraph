{"ver":"0.1","info":{"id":"NtsXz4","date":"1625260920","viewed":412,"name":"Perspective camera from Blender","username":"Envy24","description":"Recreated perspective camera from Blender.\nOnly lens and camera tabs used.\n\nSome usefull links:\nhttps://www.shadertoy.com/view/4dfBRf","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","camera","perspective","recreation","blender"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                        Orthographic camera: https://www.shadertoy.com/view/flXXWn\n     Perspective camera with depth of field: https://www.shadertoy.com/view/NlsXRf\n*/\n\n#define TAU 6.2831853071795862 // 2*PI\n#define TO_RAD 0.017453292519943295\n#define TO_DEG 57.295779513082323\n#define R iResolution\n\n// Camera positions for viewing scene from different sides.\n#define FRONT  vec3(0.0, 0.0, 1.0)\n#define BACK   vec3(0.0, 0.0, -1.0)\n#define LEFT   vec3(-1.0, 0.0, 0.0)\n#define RIGHT  vec3(1.0, 0.0, 0.0)\n#define TOP    vec3(0.0001, 1.0, 0.0)\n#define BOTTOM vec3(0.0001, -1.0, 0.0)\n\n/*\n    Initial blender camera settings (for match scenes):\n        Lens tab:\n          Type = Perspective.\n          Lens Unit = Field Of View.\n    \n        Camera tab:\n            Sensor Fit = Auto; \n            Size = 1.\n    \n        Coordinates fields:\n            x = 0, y = 0, z = 1 m.\n            \n        Rotation fields (mode XYZ Euler):\n            x = 0, y = 0, z = 0.\n       \n       \n    Scene:\n        UV-Spheres radius = 0.2.\n        UV-Spheres coordinates:\n            (0.0, 0.0, 0.0),\n            (0.5, 0.5, -0.5),\n            (-0.5, 0.5, -0.5),\n            (0.5, -0.5, -0.5),\n            (-0.5, -0.5, -0.5),\n            (0.5, 0.5, 0.5),\n            (-0.5, 0.5, 0.5),\n            (0.5, -0.5, 0.5),\n            (-0.5, -0.5, 0.5).  \n*/\n\n/*\n    Lens Unit = Millimeters.\n*/\nvec4 sceneFL(vec2 uv)\n{\n    float my = iMouse.z > 0.0 ? (iMouse.y / R.y) * 100.0 : 50.0;\n    float mx = iMouse.z > 0.0 ? (iMouse.x / R.x) * 4.0 : 2.0;\n\n    my = my < 50.0 ?\n        my / 50.0 :               // remap [0.0, 50.0] to [0.0; 1.0]\n        1.0 + (my - 50.0) * 0.1;  // remap [50.0; 100.0] to [1.0; 1.0 + (my - 50.0) * 0.1]\n\n\n    /* Axis-aligned perspective camera (Blender) using Focal Length *\n    float zFocalLength = 36.0; // mm.\n    float size = 50.0;         // Sensor Fit: Mode = Auto.\n    \n    float aspectRatio = R.x / R.y;\n\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    float zCamera = 3.0; // m.\n\n    vec3 ray = vec3(0.0, 0.0, zCamera);\n    vec3 rayDir = vec3(\n        (uv.x * vpWidth - vpWidth * 0.5),\n        (uv.y * vpHeight - vpHeight * 0.5),\n        -zFocalLength);\n    rayDir = normalize(rayDir);\n    /* Axis-aligned perspective camera */\n\n\n\n\n    float o = 4.0;\n    float mmy = iMouse.z > 0.0 ? o * 0.5 - (iMouse.y / R.y) * o : 0.0;\n    float mmx = iMouse.z > 0.0 ? o * 0.5 - (iMouse.x / R.x) * o : 0.0;\n\n\n    /* Perspective camera with lookat (Blender). */\n    vec3 lookAt = vec3(mmx, mmy, 0.0);\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up\n        \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = iResolution.x / iResolution.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    // Before uv=[0;1][0;1]\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    // After uv=[-vpWidth*0.5; vpWidth*0.5][-vpHeight*0.5; vpHeight*0.5]\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n    \n    \n  \n    /* Scene stuff */\n  \n    float d = 0.5;\n    vec3 c[9];\n    c[0] = vec3(0.0, 0.0, 0.0); // central\n    \n    c[1] = vec3(d, d, -d);\n    c[2] = vec3(-d, d, -d);\n    c[3] = vec3(d, -d, -d);\n    c[4] = vec3(-d, -d, -d);\n    \n    c[5] = vec3(d, d, d);   \n    c[6] = vec3(-d, d, d);   \n    c[7] = vec3(d, -d, d);   \n    c[8] = vec3(-d, -d, d);\n       \n    float radius = 0.2;\n    \n    float t = 99999.0;\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n\n    for (int s = 0; s < 8; ++s)\n    {\n        for (int i = 0; i < 9; ++i)\n        {\n            /* Rotate scene */\n            c[i] = rotateAroundY(c[i], iTime * 40.0 * TO_RAD);\n            c[i] = rotateAroundX(c[i], iTime * 30.0 * TO_RAD);\n            /* Rotate scene */\n        \n            float tmp = shootRayInSphere(ray, rayDir, c[i], radius);       \n\n            if (tmp > 0.0 && tmp < t) // hit\n            {\n                t = min(t, tmp);\n                normal = (ray + rayDir * t) - c[i];\n            }\n        }\n    }\n\n    if (t > 10.0) { return vec4(normalize(1.0 - rayDir), 1.0); } // Background color.\n\n    float exposureTime = 1.0;\n\n    return vec4(vec3((1.0 + normalize(normal)) * 0.5) * exposureTime, 1.0);\n}\n\n/*\n    Lens Unit = Field Of View.\n    Works only with sensor size == 1 mm\n*/\nvec4 sceneFOV(vec2 uv)\n{\n    float my = iMouse.z > 0.0 ? 1.0 + (iMouse.y / R.y) * 15.0 : 7.0;\n    float mx = iMouse.z > 0.0 ? (iMouse.x / R.x) * 179.99 : 120.0;\n\n\n\n\n\n    /* Axis-aligned perspective camera (Blender) using FOV *\n    float size = 36.0;              // Sensor Fit: Mode = Auto.\n    float fovx = 39.6 * TO_RAD;\n    float aspectRatio = R.x / R.y;\n    float focalLength = (size * 0.5) / tan(fovx * 0.5);\n           \n    float vpWidth = size;\n    float vpHeight = size / aspectRatio;\n           \n    float zCamera = my; // m.\n\n    vec3 ray = vec3(0.0, 0.0, zCamera);\n    vec3 rayDir = vec3(\n        (uv.x * vpWidth - vpWidth * 0.5),\n        (uv.y * vpHeight - vpHeight * 0.5),\n        -focalLength);\n    rayDir = normalize(rayDir);\n    /* Axis-aligned perspective camera (Blender) using FOV */\n    \n    \n  \n  \n    float o = 4.0;\n    float mmy = iMouse.z > 0.0 ? o * 0.5 - (iMouse.y / R.y) * o : 0.0;\n    float mmx = iMouse.z > 0.0 ? o * 0.5 - (iMouse.x / R.x) * o : 0.0;\n  \n  \n  \n  \n    /* Perspective camera (Blender) using FOV */\n    vec3 lookAt = vec3(mmx, mmy, 0.0);\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n    \n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up    \n    \n    float size = 36.0;\n    float fovx = 39.6 * TO_RAD;\n    float aspectRatio = R.x / R.y;\n    float focalLength = (size * 0.5) / tan(fovx * 0.5);\n   \n    float vpWidth = size;\n    float vpHeight = size / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n           \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + focalLength * f);\n    /* Perspective camera (Blender) using FOV */\n    \n\n\n    /* Scene stuff */\n  \n    float d = 0.5;\n    vec3 c[9];\n    c[0] = vec3(0.0, 0.0, 0.0); // central\n    \n    c[1] = vec3(d, d, -d);\n    c[2] = vec3(-d, d, -d);\n    c[3] = vec3(d, -d, -d);\n    c[4] = vec3(-d, -d, -d);\n    \n    c[5] = vec3(d, d, d);   \n    c[6] = vec3(-d, d, d);   \n    c[7] = vec3(d, -d, d);   \n    c[8] = vec3(-d, -d, d);\n       \n    float radius = 0.2;\n    \n    float t = 99999.0;\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n\n    for (int s = 0; s < 8; ++s)\n    {\n        for (int i = 0; i < 9; ++i)\n        {\n            /* Rotate scene */\n            c[i] = rotateAroundY(c[i], iTime * 40.0 * TO_RAD);\n            c[i] = rotateAroundX(c[i], iTime * 30.0 * TO_RAD);\n            /* Rotate scene */\n\n            float tmp = shootRayInSphere(ray, rayDir, c[i], radius);       \n\n            if (tmp > 0.0 && tmp < t) // hit\n            {\n                t = min(t, tmp);\n\n                normal = (ray + rayDir * t) - c[i];\n            }\n        }\n    }\n    \n    if (t > 10.0) { return vec4(normalize(1.0 - rayDir), 1.0); } // Background color.\n    \n    float exposureTime = 1.0;\n\n    return vec4(vec3((1.0 + normalize(normal)) * 0.5) * exposureTime, 1.0);// * (7.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n \n    // Output to screen\n    //fragColor = sceneFL(uv);\n    fragColor = sceneFOV(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T_NEAR 0.0001\n\nfloat shootRayInSphere(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float t = (-b - e) / (2.0 * a);\n\n    if (t >= T_NEAR)\n    {\n       return t;\n    }\n\n    t = (-b + e) / (2.0 * a);\n\n    if (t >= T_NEAR)\n    {\n       return t;\n    }\n    \n    return -1.0;\n}\n\nvec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}\n\n/* \n    Returns random vec2 sample from unit disk.\n*/\nvec2 sampleUnitDisk2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * enthropy2 + x;\n    uint value1 = x * enthropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += enthropy1; value0 *= 445593459u; value0 ^= enthropy0;\n    value1 += enthropy1; value1 *= 445593459u; value1 ^= enthropy0;\n    \n    // (2.0f * PI) / 4294967295.0f = 1.46291812e-09\n    // 1.0f / 4294967295.0f = 2.32830644e-10 \n\n    float angle = float(value0 * value0 * value0) * 1.46291812e-09 - 3.14159274f;\n    float scale = float(value1 * value1 * value1) * 2.32830644e-10 ;\n\n    // Redistribute values by law: f(x)=1-x^2.\n    scale = 1.0 - scale * scale;\n\n    return \n        vec2(\n            cos(angle) * scale,\n            sin(angle) * scale);\n}\n\n/*\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f)); // right\n    vec3 u = normalize(cross(f, r));                   // up   \n*/","name":"Common","description":"","type":"common"}]}