{"ver":"0.1","info":{"id":"ltjXz1","date":"1441759278","viewed":597,"name":"Hexagonal Worley Noise","username":"bh","description":"This shader implements 2D Worley noise using a hexagonal lattice. By using hexagons, it's possible to reduce the number of lattice samples from 9 to 7, albeit at the cost of some added geometric complexity.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// 2d hex worley\n// Copyright 2015 Brendan Hickey\n// Released under the Apache License 2.0\n\nfloat rand(vec2 co){\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt= dot(co.xy ,vec2(a,b));\n  highp float sn= mod(dt,3.14);\n  return fract(sin(sn) * c);\n}\n\nmat3 rotate(float theta) {\n  float c_t = cos(theta);\n  float s_t = sin(theta);\n  return mat3(\n      c_t, -s_t, 0.0,\n      s_t, c_t, 0.0,\n      0.0, 0.0, 1.0);  \n}\n\nmat3 translate(vec2 o) {\n  return mat3(\n      1.0, 0.0, 0.0,\n      0.0, 1.0, 0.0,\n      o.x, o.y, 1.0);\n}\n\nmat3 scale(vec2 s) {\n  return mat3(\n      s.x, 0.0, 0.0,\n      0.0, s.y, 0.0,\n      0.0, 0.0, 1.0);   \n}\n\nfloat section(vec2 p) {\n  vec2 offset = vec2(0.5, 0.25);\n  return float(int(rand(p) * 3.0));\n}\n\n\nvec3 random_point_rhombus(vec2 co) {    \n  float x = rand(co);\n  vec3 square_pt = vec3(x, rand(co + vec2(0.71828182, 0.42614977)), 1.0);\n  mat3 R1 = rotate(3.14159265359 / 4.0);\n  mat3 R2 = rotate(2.09439510239 * section(co));\n  float root12 = 1.0 / sqrt(2.0);\n  float root24 = sqrt(2.0) / 4.0;\n  mat3 T = translate(vec2(-root12, root12));\n  mat3 S = scale(vec2(root12, root24));\n  return R2 * S * T * R1 * square_pt;\n}\n\n// This function does *not* provide an unbiased sample\n// within a hexagon. However, you can use it to bias\n// your samples toward the lattice points.\nvec2 random_point_circle(vec2 co) {\n  float s = rand(co);\n  float t = rand(co + vec2(0.71828182, 0.42614977));    \n  float a = min(s, t);\n  float b = max(s, t);\n  float R = 0.5;\n  float pi = 3.14159265359; \n  return vec2(b*R*cos(2.0 * pi *a/b), b*R*sin(2.0*pi*a/b));\n}\n\nvec2 pixel2hex(vec2 p) {\n  float temp = floor(p.x + sqrt(3.0) * p.y + 1.0);\n  float q = floor((floor(2.0 * p.x + 1.0) + temp) / 3.0);\n  float r = floor((temp + floor(-p.x + sqrt(3.0) * p.y + 1.0))/3.0);\n  return vec2(q, r);\n}\n\nvec2 hex2origin(vec2 h) {\n  float x = (h.x - h.y / 2.0);\n  float y = sqrt(3.0) / 2.0 * h.y;\n  return vec2(x, y);\n}\n\nvec2 hex_pt(vec2 hex) {\n  vec2 hex_center = hex2origin(vec2(floor(hex.x), floor(hex.y)));\n  return hex_center + random_point_rhombus(hex).xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float size = 10.0;\n  vec2 offset = vec2(0.3, 0.3) * iTime;\n  vec2 uv = fragCoord.xy / iResolution.xy \n    * vec2(sqrt(3.0), 1.0) * size + offset;\n  vec2 hex = pixel2hex(uv);\n  vec2 p00 = hex_pt(hex);\n  float L00 = length(uv - p00);\n  vec2 p01 = hex_pt(hex + vec2(0.0, 1.0));\n  vec2 p02 = hex_pt(hex + vec2(0.0, -1.0));\n  vec2 p10 = hex_pt(hex + vec2(1.0, 0.0));\n  vec2 p20 = hex_pt(hex + vec2(-1.0, 0.0));\n  vec2 p11 = hex_pt(hex + vec2(1.0, 1.0));\n  vec2 p12 = hex_pt(hex + vec2(1.0, -1.0)); // !?\n  vec2 p22 = hex_pt(hex + vec2(-1.0, -1.0));\n\n  float L0 = min(length(uv - p01), length(uv - p02));\n  float L1 = min(length(uv - p10), length(uv - p20));\n  float L2 = min(length(uv - p11), length(uv - p12));\n  float L3 = min(L00, length(uv - p22));\n  \n  float d = min(min(L0, L1), min(L2, L3));\n  fragColor = vec4(d, d, d, 1.0);\n}","name":"","description":"","type":"image"}]}