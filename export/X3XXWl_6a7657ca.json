{"ver":"0.1","info":{"id":"X3XXWl","date":"1710120880","viewed":34,"name":"Colorful SDF","username":"sepia_sempervirens","description":"A first foray into raymarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n//     camera\n//       |\n//       v\n//\n//       o\n//      /|\\      <|\n//     / | \\      |-- FOV\n//    /  |  \\     |\n//   /   |   \\   <|\n//  -----------  <--- viewport\n// /     |     \\\n//\n\n\nconst float BOB_FREQ = 0.7;\nconst float ORBIT_FREQ = 0.9;\nconst float DEFORM_FREQ = 0.8;\nconst float FOV = 1.1;\nconst vec3 VERTICAL = vec3(0,0,1);\nconst float stepSize = 0.025;\nconst int numSteps = 70;\nconst float blackPoint = 110.;\n\nconst float TAU = 6.2831855;\nvec2 angle( float turns ) {\n    float theta = TAU * turns;\n    return vec2(cos(theta), sin(theta));\n}\n\n// Variation on the prototypical signed distance field. The function returns an rgb\n// color and a distance, packed in that order as a vec4.\nvec4 sdf( vec3 pos ) {\n    float dist1 = distance(pos, vec3(0.4*angle(0./3.),0));\n    float dist2 = distance(pos, vec3(0.4*angle(1./3.),0));\n    float dist3 = distance(pos, vec3(0.4*angle(2./3.),0));\n    float dist = dist1 * dist2 * dist3 - .07 + 0.007 * sin(iTime * DEFORM_FREQ);\n    \n    vec3 color1 = vec3(0,1,1);\n    vec3 color2 = vec3(1,0,1);\n    vec3 color3 = vec3(1,1,0);\n    float weight1 = 1./dist1;\n    float weight2 = 1./dist2;\n    float weight3 = 1./dist3;\n    vec3 color = (weight1*color1 + weight2*color2 + weight3*color3)\n               / (weight1 + weight2 + weight3);\n    \n    return vec4(color, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPos = vec3(\n        cos(iTime * ORBIT_FREQ),\n        sin(iTime * ORBIT_FREQ),\n        sin(iTime * BOB_FREQ)\n    );\n    vec3 viewportNormal = normalize(-cameraPos) * FOV;\n    vec3 viewportHorizontal = normalize(cross(viewportNormal, VERTICAL));\n    vec3 viewportVertical = normalize(cross(viewportNormal, viewportHorizontal));\n\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 pixelLocation = uv.y * viewportVertical + uv.x * viewportHorizontal + viewportNormal;\n    vec3 stepVec = normalize(pixelLocation) * stepSize;\n    \n    vec3 currPos = cameraPos;\n    for (int i = 0; i < numSteps; i++) {\n        currPos += stepVec;\n        vec4 currSdf = sdf(currPos);\n        if (currSdf.a < 0.) {\n            fragColor.rgb = currSdf.rgb * (1. - float(i) / blackPoint);\n            fragColor.a = 1.;\n            return;\n        }\n    }\n    fragColor = vec4(0);\n}","name":"Image","description":"","type":"image"}]}