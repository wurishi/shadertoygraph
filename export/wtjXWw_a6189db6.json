{"ver":"0.1","info":{"id":"wtjXWw","date":"1566147411","viewed":219,"name":"Bloody Labyrinth","username":"96logda","description":"I did something wrong with the shadows and got a bug looking like blood on the floor.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","cubes","menger","reflections","blood","mengersponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-08-18 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n#define true\t\t\t\t1\n#define false\t\t\t\t0\n\n#define PI 3.14\n\n#define saturate(x) \t\tclamp(x, 0.0, 1.0)\n\n#define MENGER_ITERATIONS\t2\n#define SOFT_SHADOW_STEPS \t16\n\n#define INTERSECT_STEPS\t\t350\n#define INTERSECT_MIN_DIST\t0.0001\n#define INTERSECT_MAX_DIST\t100.0\n\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n     return length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdPlane(vec3 p, float height)\n{\n     return p.y - height;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n     return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 map(in vec3 p)\n{\n    p.xz = mod(p.xz + 1.0, 2.0) - 1.0;\n    p.y  = mod(p.y + 1.0, 2.0) - 1.0;\n    \n    float d = sdRoundBox(p, vec3(0.5), 1.0);\n    vec4 res = vec4(d, 1.0, 0.0, 0.0);\n\t\n    //....................................................................\n    // Based on https://iquilezles.org/articles/menger\n    //....................................................................\n    float s = 8.0;\n    for(int i = 0; i < MENGER_ITERATIONS; ++i)\n    {\t \n        vec3 a = mod(p * s, 2.0) - 1.0;\n        s *= 8.0;\n        vec3 r = abs(1.0 - 5.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / s;\n\n        if(c > d)\n        {\n            d = c;\n            res = vec4(d, min(res.y, 0.2 * da * db * dc), 0.0, 1.0);\n        }\n    }\n    //....................................................................\n    \n    vec4 ground = vec4(sdPlane(p, -0.05), -0.5, 0.0, 1.0);\n    res = opU(ground, res);\n    \n    return res;\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for (int i = 0; i < INTERSECT_STEPS; ++i)\n    {\n\t\tif(h.x < INTERSECT_MIN_DIST || t > INTERSECT_MAX_DIST) \n\t\t{\n\t    \tbreak;\n\t\t}\n\t\n        h = map(ro + rd * t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\n    if (t > INTERSECT_MAX_DIST) \n    {\n\t\tres = vec4(-1.0);\n    }\n    \n    return res;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);\n        if(res < 0.001)\n\t\t{\n            break;\n\t\t}\n        t += clamp(h, 0.0, 0.2);\n    }\n    return saturate(res);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.5);\n    vec4 res = intersect(ro,rd);\n    if(res.x > 0.0)\n    {   \n        const vec3 light1 = vec3(0.5, 0.5, -0.5);\n        vec3 pos = ro + res.x * rd;\n        vec3 baseColor = vec3(0.0);\n        if (res.y == -0.5)\n\t\t{           \n            baseColor = vec3(0.0, 1.0, 1.0);\n\t\t}\n        else if (res.y > 0.0)\n        {\n            baseColor = mix(vec3(0.0, 0.4, 0.6), vec3(0.0, 0.0, 0.0), res.y);\n        }\n        \n        vec3 ambient = vec3(0.2) * baseColor;\n        \n        vec3 normal = calcNormal(pos);\n        vec3 reflection = reflect(rd, normal);\n\n        float occ = res.y;\n        float shadow1 = softshadow(pos + 0.001 * normal, light1);\n\n        vec3 diffuse = baseColor * shadow1 * occ;\n\n        color = diffuse + ambient;\t\t\n        color += 0.8 * smoothstep(0.0, 0.1, reflection.y) * softshadow(pos + 0.1 * normal, reflection);\n    }\n\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 p = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouseXY = iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = vec3(8.75, 1.0, -2.0);\n    vec3 ww = normalize(vec3(0.0, mouseXY.y * 5.0 * PI, 0.0) - ro);\n    ww.xz = rotate2D(ww.xz, -mouseXY.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    ro.x -= iTime * 0.05; //Camera movement\n\n    vec3 color = render(ro + vec3(0.0, -1.0, 0.0), rd);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}