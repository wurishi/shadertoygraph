{"ver":"0.1","info":{"id":"7dtGDr","date":"1629618417","viewed":80,"name":"Solar System Gravity Jump Drive","username":"sdfgeoff","description":"Simulates the gravitational forces in the solar system. Used to prototype some jump drive game mechanics.\n\nTODO: velocity indicator?\nTODO: change screen \"snap\"","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["sun","planet","stars","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is a very strange experiment. It explores the idea of a scientifically\naccurate jump drive. Not accurate in the tmers of \"you can build one\" but rather\nif the jump drive obeys physical constraints such as:\n - Preserves velocity\n - Is limited to a certain amount of absolute energy change (ie you can only jump\n   to a location if your gravitational potential energy matches within the jumpdrives\n   energy consumption.\n   \nIn this gamelet, the jump drive has a max energy output of 10Mj (defined in Common)\nand this is the solar system. The player ship starts in orbit around Jupiter (you'll\nhave to zoom out to see it).\n\nNavigate the map with arrow keys + pageup/pagedown to zoom\nWarp the ship by clicking. Due to the mentioned energy constraints it will only jump\ninto grey areas. THe ship has no other engines - only the jump drive.\n\nYou can tweak the TIME_MULTIPLIER if you need to. It's already way faster than real-time\n\nThings Learned:\n - By jumping near a gravity well you can trade off gravitational potential energy\n   for kinetic potential energy, but your total spacecraft energy will not change.\n   This means that you can jump anywhere if you time your jumps well, but you can't\n   necessarily enter orbit around any planet. \n - XKCD's Gravity wells poster https://xkcd.com/681/ is a handy jump-guide as\n   a jump is a horizontal traverse.\n\n\nWhy did I implement this in shadertoy? It allowed me to evaluate and visualize the \ngravitational potential energy across the entire solar system trivially.\n \n*/\n#define BUFFER_STATE iChannel0\n\nconst float ANTIALIAS_PIXELS = 1.0;\nconst float ORBIT_LINE_THICKNESS_PIXELS = 0.5;\nconst vec4 ORBIT_COLOR = vec4(0.0, 1.0, 0.0, 0.3);\nconst float PLANET_INDICATOR_SIZE_PIXELS = 10.0;\nconst vec4 PLANET_COLOR = vec4(1.0, 0.0, 0.0, 0.3);\nconst float SHIP_INDICATOR_SIZE_PIXELS = 10.0;\nconst vec4 SHIP_COLOR = vec4(0.0, 0.0, 1.0, 0.3);\n\nconst vec4 CAN_JUMP_COLOR = vec4(0.5, 0.5, 0.5, 0.5);\n\nvec3 neon(float val, vec3 color) {\n\tfloat r = clamp(val, 0.0, 1.0);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r16 = r4 * r4;\n    vec3 c = color;\n    vec3 c2 = pow(color, vec3(4.0)); // A darker, more saturated version of color\n    \n\tvec3 outp = vec3(0.0);\n\toutp += c2 * r2; // Darker color falloff\n\toutp += c * r4; // Specified Color main part\n\toutp += vec3(1.0) * r16; // White core\n\treturn outp;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    /*\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    \n    uv *= camera_position.z;\n    uv.xy += camera_position.xy;\n    \n    uv *= M_PER_AU;\n    */\n    vec4 camera_position = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n    vec2 uv = screen_pos_to_meters(fragCoord, camera_position, iResolution);\n    \n    \n    vec4 time_data = read_data(BUFFER_STATE, ADDR_TIME);\n    \n    \n    vec3 grav_data = calc_gravity_data(uv, time_data.x);\n    \n    \n    vec2 grav_force_vector = grav_data.xy;\n    float grav_potential_energy = grav_data.z;\n    \n    \n    float is_orbit = 0.0;\n    float is_planet = 0.0;\n    \n    float m_per_pixel = iResolution.y / (camera_position.z * M_PER_AU);\n\n    for (int i=0;i<NUM_PLANETS; i++){\n        vec4 planet_data = all_planet_data[i];\n        vec2 planet_pos = planet_angular_position_to_cartesian(planet_data, time_data.x);\n     \n        vec2 dist_from_planet = planet_pos - uv;\n\n        // Draw orbits\n        vec2 dist_from_sun = uv;\n        float orbit_ring_meters = abs(planet_data.y * M_PER_AU - length(dist_from_sun));\n        float orbit_ring_pixels = orbit_ring_meters * m_per_pixel;\n        orbit_ring_pixels = 1.0 - smoothstep(ORBIT_LINE_THICKNESS_PIXELS, ORBIT_LINE_THICKNESS_PIXELS+ANTIALIAS_PIXELS, orbit_ring_pixels);\n        is_orbit += orbit_ring_pixels; \n        \n        // Draw Planets\n        float dist_from_planet_pixels = length(dist_from_planet) * m_per_pixel;\n        dist_from_planet_pixels = 1.0 - smoothstep(PLANET_INDICATOR_SIZE_PIXELS, PLANET_INDICATOR_SIZE_PIXELS+ANTIALIAS_PIXELS, dist_from_planet_pixels);\n        is_planet += dist_from_planet_pixels;\n    }\n    \n    vec4 ship_data = read_data(BUFFER_STATE, ADDR_SHIP);\n    vec2 ship_pos = ship_data.xy;\n    float dist_to_ship_meters = length(ship_pos - uv);\n    float dist_to_ship_pixels = dist_to_ship_meters * m_per_pixel;\n    dist_to_ship_pixels = 1.0 - smoothstep(SHIP_INDICATOR_SIZE_PIXELS, SHIP_INDICATOR_SIZE_PIXELS+ANTIALIAS_PIXELS, dist_to_ship_pixels);\n    float is_ship = dist_to_ship_pixels;\n    \n    \n    \n    vec3 ship_gravity_data = calc_gravity_data(ship_pos, time_data.x);\n    \n    //float can_jump = 0.0;\n    //if (abs(ship_gravity_data.z - grav_data.z) < JUMP_DRIVE_MAX_ENERGY) {\n    //    can_jump = 1.0;\n    //}\n    float can_jump = clamp(1.0 - abs(ship_gravity_data.z - grav_data.z) / JUMP_DRIVE_MAX_ENERGY, 0.0, 1.0);\n    can_jump = smoothstep(0.0, 0.2, can_jump);\n    \n\n    // Output to screen\n    vec3 col = vec3(0.0);\n    //col += vec3(grav_potential_energy / 1.0);\n    //col += planet_plot;\n    \n    col += neon(pow(length(grav_force_vector), 0.2), vec3(0.8, 0.6, 0.3));\n    //col.rg += clamp(grav_force_vector / 0.1, 0.0, 1.0);\n    \n    col = clamp(col, 0.0, 1.0);\n    col = mix(col, CAN_JUMP_COLOR.rgb, can_jump * CAN_JUMP_COLOR.a);\n    col = mix(col, ORBIT_COLOR.rgb, clamp(is_orbit, 0.0, 1.0) * ORBIT_COLOR.a);\n    col = mix(col, PLANET_COLOR.rgb, clamp(is_planet, 0.0, 1.0) * PLANET_COLOR.a);\n    col = mix(col, SHIP_COLOR.rgb, clamp(is_ship, 0.0, 1.0) * SHIP_COLOR.a);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float TIME_MULTIPLIER = 10000.0;//float(88 * 60 * 24 * 60);//10000000.0;//10000000.0;\n\n\nconst float PI = 3.14159;\nconst float MASS_SUN = 1.9855e30;\n\nconst float G = 6.67408e-11;\nconst float M_PER_AU = 1.495978707e11;\n\nconst float ROTATION_PERIOD_DAYS_TO_RADS = 7.3682e-6 * 10.0;\n\n\nconst int NUM_PLANETS = 9;\n\nconst float JUMP_DRIVE_MAX_ENERGY = 10.0e6; // Max energy (joules) to supply or dissapate during a jump.\n\n\n/*\nx = Mass (kg), \ny = Orbital Radius (m), \nz = Angular Position(initial) (radians)\nw = Angular Velocity (radians per second)\n*/\nconst vec4 all_planet_data[NUM_PLANETS] = vec4[](\n    vec4(MASS_SUN, 0.0, 0.0, 0.0), \n    vec4(3.302e23, 0.38709893, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 87.969 ),\n    vec4(4.8690e24, 0.72333199, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 224.701),\n    vec4(5.972e24, 1.00000011, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 365.256363),\n    vec4(6.4191e23, 1.52366231, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 686.971),\n    vec4(1.8987e27, 5.20336301, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 4332.59),\n    vec4(5.6851e26, 9.53707032, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 10759.22),\n    vec4(8.6849e25, 19.19126393, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 30688.5),\n    vec4(1.0244e26, 30.06896348, 0.0, -ROTATION_PERIOD_DAYS_TO_RADS / 60182.0)\n);\n\n\n\n// Keyboard Controls\nconst int KEY_LEFT = 37;\nconst int KEY_UP   = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_ZOOM_IN = 0x22; // pagedown\nconst int KEY_ZOOM_OUT = 0x21; // pageup\nconst int KEY_SHOOT = 32;\nconst int KEY_ESC = 27;\n\n\n// Stores the position of the camera as AU\n// y = x\n// y = y\n// z = zoom (AU per screen)\nconst ivec2 ADDR_CAMERA_POSITION = ivec2(0,0);\n\n/*\nX = current universe time (seconds since 949AD)\n*/\nconst ivec2 ADDR_TIME = ivec2(0,1);\n\n/*\nx = x_pos (meters)\ny = y_pos (meters)\nz = x_vel (meters/second)\nw = y_vel (meters/second)\n*/\nconst ivec2 ADDR_SHIP = ivec2(0,2);\n\n\n\n// Fetch a single pixel from the state buffer buffer\nvec4 read_data(sampler2D buffer, ivec2 address){\n    return texelFetch(buffer, address, 0);\n}\n\n\n\n\n//------------------------- SIMULATION STUFF -------------------------------\n\n\n// Returns the position of a planet in AU's from the sun as cartesian coordinates\nvec2 planet_angular_position_to_cartesian(vec4 planet_data, float time) {\n    float radius_meters = planet_data.y * M_PER_AU;\n    if (radius_meters == 0.0) {\n        return vec2(0.0);\n    }\n\n    float angle = mod(\n        planet_data.z + (time * planet_data.w),\n        2.0*PI\n    );\n    \n    return vec2(sin(angle), cos(angle)) * (radius_meters);\n}\n\n\n\n\n// Returns information about the gravity field at a given position\n// X -> acceleration on x axis\n// Y -> acceleration on y axis\n// Z -> Gravitational potential energy\nvec3 calc_gravity_data(\n    vec2 position, // Meters \n    float time\n) {\n    vec2 grav_acceleration_vector = vec2(0.0);\n    float grav_potential_energy = 0.0;\n    \n    vec3 planet_plot = vec3(0.0);\n\n    for (int i=0;i<NUM_PLANETS; i++){\n        vec4 planet_data = all_planet_data[i];\n        vec2 planet_pos = planet_angular_position_to_cartesian(planet_data, time);\n     \n        vec2 dist_from_planet = planet_pos - position;\n        \n        \n        float r2 = dot(dist_from_planet, dist_from_planet);\n        float r = sqrt(r2);\n        \n        grav_potential_energy += G * planet_data.x / r;\n\n        float acceleration_magnitude = G * planet_data.x / r2;\n        \n        grav_acceleration_vector += acceleration_magnitude * normalize(dist_from_planet);\n    }\n    \n    return vec3(grav_acceleration_vector, grav_potential_energy);\n\n}\n\n\n// -------------------------- Interaction Stuff --------------------\nvec2 screen_pos_to_meters(vec2 frag_coord, vec4 camera_data, vec3 resolution_data) {\n    vec2 uv = frag_coord/resolution_data.xy;\n    uv = (uv - 0.5);\n    uv.x *= resolution_data.x / resolution_data.y;\n\n    uv *= camera_data.z;\n    uv.xy += camera_data.xy;\n    \n    uv *= M_PER_AU;\n    return uv;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BUFFER_STATE iChannel0\n#define BUFFER_KEYBOARD iChannel1\n\n\n#define DT (TIME_MULTIPLIER*iTimeDelta)//*get_key(KEY_SHOOT)\n\n\n// Return the state of a key\nfloat get_key(int key_code) {\n    return texelFetch(BUFFER_KEYBOARD, ivec2(key_code,0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 addr = ivec2(fragCoord);\n    \n    if (addr == ADDR_CAMERA_POSITION) {\n        vec4 prev_position = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n        if (iFrame == 0) {\n            prev_position = vec4(0.0, 0.0, 2.0, 0.0);\n        }\n        \n        float zoom_delta = get_key(KEY_ZOOM_IN) - get_key(KEY_ZOOM_OUT);\n        \n        fragColor = prev_position + vec4(\n            get_key(KEY_RIGHT) - get_key(KEY_LEFT),\n            get_key(KEY_UP) - get_key(KEY_DOWN),\n            zoom_delta,\n            0.0\n        ) * iTimeDelta * prev_position.z;\n        \n        vec4 time_data = read_data(BUFFER_STATE, ADDR_TIME);\n        \n        // Snap to Jupiter\n        //fragColor.rg = planet_angular_position_to_cartesian(all_planet_data[5], time_data.x)/ M_PER_AU;\n        \n        // Snap to player ship\n        //fragColor.rg = read_data(BUFFER_STATE, ADDR_SHIP).xy / M_PER_AU;\n        \n        // Lock zoom level\n        //fragColor.b = 0.1;\n        \n        return;\n    }\n    \n    if (addr == ADDR_TIME) {\n        vec4 prev_time = read_data(BUFFER_STATE, ADDR_TIME);\n        if (iFrame == 0) {\n            prev_time = vec4(0.0);//vec4(100000000.0, 0.0, 0.0, 0.0);\n        }\n        fragColor = prev_time + DT;\n        return;\n    }\n    if (addr == ADDR_SHIP) {\n        vec4 prev_ship_data = read_data(BUFFER_STATE, ADDR_SHIP);\n        vec4 time_data = read_data(BUFFER_STATE, ADDR_TIME);\n        if (iFrame == 0) {\n            prev_ship_data = vec4(\n                \n                vec2(0.0, 778412010000.0 + 1000000000.0), //vec2(0.0, 58000000000.0),\n                vec2(0.0)//vec2(13069.7, 0.0)//vec2(49020.0, 0.0)\n            );\n        }\n        \n        vec2 position = prev_ship_data.xy;\n        vec2 velocity = prev_ship_data.zw;\n        \n        vec3 gravity_data = calc_gravity_data(position, time_data.x);\n        vec2 acceleration = gravity_data.xy;\n        \n        velocity += acceleration * DT;\n        position += velocity * DT;\n        \n        if (sign(iMouse.w) > 0.0) {\n            vec4 camera_data = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n            vec2 target_position = screen_pos_to_meters(iMouse.zw, camera_data, iResolution);\n            \n            vec3 target_gravity_data = calc_gravity_data(target_position, time_data.x);\n            if (abs(gravity_data.z - target_gravity_data.z) < JUMP_DRIVE_MAX_ENERGY) {\n                position = target_position;\n            }\n            \n        }\n        \n        fragColor = vec4(position, velocity);\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}