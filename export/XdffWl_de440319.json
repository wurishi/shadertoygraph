{"ver":"0.1","info":{"id":"XdffWl","date":"1498667081","viewed":922,"name":"1D DCT Basis Image","username":"MichaelPohoreski","description":"INSTRUCTIONS: Click on column to zoom; drag mouse up/down middle to turn grid lines on/off.\n\nNOTE: Technically the 1D DCT, u = 0, has a frequency of 0, but it is shown here as 8 since a straight line is visually boring.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fft","visualization","1d","discrete","dct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nVisualization of 1D Discrete Cosine Transform (DCT) basis image\nhttps://www.shadertoy.com/view/XdffWl\n\nCopyleft 2017\nMichaelangel007\nhttps://github.com/Michaelangel007/shadertoy_1d_dct_visualization\n\nDISCLAIMER:\n\n    You are free to use this code as you wish.\n\n    However, if you are going to copy/paste snippets of this code\n    on StackOverflow, StackExchange, Reddit, etc.\n    Please provide a link back to the original source\n    so that people can find updates and bugfixes.\n    Thanks!\n\n\nAlso see:\n\nDCT ZOOM\n* https://www.shadertoy.com/view/XdlfWX\n\nDCT vs CCT\n* https://www.shadertoy.com/view/4ssBWX\n\nDCT vs CCT Zoom\nhttps://www.shadertoy.com/view/XdlfDf\n\n\nReferences:\n\n* http://download.nvidia.com/developer/presentations/2005/GDC/OpenGL_Day/OpenGL_Image_Processing_Tricks.pdf\n\n* https://www.google.com/search?q=dct+basis+images&tbm=isch\n\n*/\n\n#define PI 3.14159265359\n\nfloat fft(vec2 uv)\n{\n    return cos( uv.y * PI * (2.0*uv.x + 1.0) / 16.0 );\n}\n\nfloat plot(vec2 st, float x, float w)\n{\n    return  smoothstep( x-w, x  , st.y) - \n            smoothstep( x  , x+w, st.y);\n}\n\nfloat plot1(vec2 st, float y)\n{\n    return plot( st, y, 0.01 );\n}\n\nfloat plot2(vec2 st, float y)\n{\n    return plot( st, y, 0.02 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 st )\n{\n    // st - scaled:     x = 0 .. 799, y = 0 .. 449\n    // uv - normalized: x = 0 ..   1, y = 0 ..   1\n    // pq - transformed\n\t// ij - quantized\n \n    vec2 cs = vec2( 64.0, 16.0 ); // cell scale\n    vec2 uv = st / iResolution.xy;\n\n/*\n    Map 8x8 -> 64x8\n\nFrom DCT basis image\n    uv\n    07 17 27 37 47 57 67 77\n    06 16 26 36 46 56 66 76\n    05 15 25 35 45 55 65 75\n    04 14 24 34 44 54 64 74\n^   03 13 23 33 43 53 63 73\n|   02 12 22 32 42 52 62 72\n|   01 11 21 31 41 51 61 71\ny=0 00 10 20 30 40 50 60 70\n    x=0 --->\n\nTo\n    00 10 20 30 40 50 60 70 | ... | 07 17 27 37 47 57 67 77\n    00 10 20 30 40 50 60 70 | ... | 07 17 27 37 47 57 67 77\n    00 10 20 30 40 50 60 70 | ... | 07 17 27 37 47 57 67 77\n    00 10 20 30 40 50 60 70 | ... | 07 17 27 37 47 57 67 77\n    00 10 20 30 40 50 60 70 | ... | 07 17 27 37 47 57 67 77\n    00 10 20 30 40 50 60 70 | ... | 07 17 27 37 47 57 67 77\n    00 10 20 30 40 50 60 70 | ... | 07 17 27 37 47 57 67 77\n\n     0  1  2  3  4  5  6  7 ... 56 57 58 59 60 61 62 63\n    cx\n*/\n    vec2 ij = floor( uv * 8.0 ); // quantized 8x8 grid\n    vec2 pq = vec2(\n    \tmod((uv.x * cs.x), 8.0 ),\n    \tij.x\n    );\n\n    bool  bZoom   = (iMouse.z > 0.5);\n    bool  bGrid   = (iMouse.y < 0.5*iResolution.y);\n    bool  bLoRes  = iResolution.x < 900.0;\n    bool  bFirst  = (ij.x < 1.0); // in first column?\n    float iClickX = floor( 8.0 * iMouse.x / iResolution.x );\n    \n    vec3  color   = vec3( 0.0 );\n    vec3  cDotOdd = vec3( 0.2, 1.0, 0.5 ); // Discrete   cos wave (green)\n    vec3  cDotEvn = vec3( 1.0, 1.0, 0.0 ); //            cos wave (yellow)\n    vec3  cWave   = vec3( 0.0, 0.5, 1.0 ); // Continuous cos wave (blue )\n    vec3  cGrid   = vec3( 0.2, 0.6, 0.5 ); // vec3(0.254, 0.6578, 0.554)\n    vec3  cEdge   = vec3( 1.0, 0.0, 0.0 ); // red\n    vec3  cBack   = vec3( 0.1, 0.2, 0.3 ); // dark blue\n    vec3  cGrey   = vec3( 0.2, 0.2, 0.2 );\n\n    float EdgeW = 0.5; // 1.0 / iResolution.x; // 1 px edge between columns\n    if( (uv.x > 0.1) && mod( st.x, iResolution.x / 8.0 ) <= 0.5 )\n    {\n        if( !bZoom || bGrid )\n        {            \n        \tfragColor = vec4(cEdge,1.0);\n        \treturn;\n        }\n    }\n\n    float c = (1.0 + fft(        pq )) * 0.5; // Continuous\n    float d = (1.0 + fft( floor( pq))) * 0.5; // Discrete\n    \n    if( bZoom )\n    {\n        if( ij.x != iClickX ) // Dim columns not selected\n        {\n            c *= 0.25;\n            d *= 0.25;\n        }\n    }\n    \n    if( uv.y >= 0.75 ) // Top = Continuous\n    {\n \t\t   float y = c;\n           color = vec3( y ); // TODO: Gamma correct\n    }\n    else\n    if( uv.y >= 0.50 ) // Middle = Discrete\n    {\n          float y  = d;\n          color = vec3( y ); // TODO: Gamma correct\n    }\n    else // Bottom = Continuous (blue) and Discrete (green/yellow)\n    {\n        // Discrete Wave\n        float even2    = mod(   ij.x, 2.0 );\n        float even8    = mod(   pq.x, 2.0 );\n        float even64   = mod(2.*pq.x, 2.0 );\n              color = bLoRes\n                  ? cBack * ( even2 + 0.2*even64 ) + 0.5*cBack*(1.0 - even2)\n                  : cBack * ( even2 + 0.5*even8 )\n        \t\t  ;  \n\n        if( bZoom )\n        {\n\t\t\tvec2 dz = vec2( ij.x, iClickX ); // 8.0 * uv; ij.x\n            d = 0.5 + 0.5*fft( floor( dz ) );\n            color = vec3( d );\n        }        \n        \n        float y1      = plot2( uv,d*0.5 );\n        vec3 cDot     = (even2 < 1.0) ? cDotEvn : cDotOdd;\n    \t      color   = mix( color, cDot, y1 );\n\n        \n        // Continuous Wave\n        float freq    = bFirst ? 64.0 : 4.0*ij.x; // Technically u=0 freq=0.0 but 64 for better visualization\n        float offset  = ij.x * PI;\n\n        if( bZoom )\n        {\n            freq   = 0.5 * iClickX;\n            offset = 0.0;\n            if( iClickX == 0.0 )\n                freq = 8.0; // Technically zero, but 8 for better visualization\n        }\n        \n        float y2      = 0.5 + 0.5*cos( freq*uv.x * 2.0 * PI + offset );\n        float x2      = plot( uv, y2*0.5, freq * 1.0/iResolution.x * (bZoom ? 4.0 : 2.0) );\n              color   = mix( color, cWave, x2 );\n\n        // Grid\n        if( bGrid )\n        { \n            /* */ vec2  gCells = bLoRes\n                ? vec2(  8.0,  8.0 ) // number of grid height cells is doubled as we only show 1/2\n                : vec2( 64.0, 20.0 )\n                ;\n\n            vec2 isGrid = mod( st, iResolution.xy / gCells );\n            if( (isGrid.x < 1.0) || (isGrid.y < 1.0 ) )\n                color = cGrid; // NOT += as grid always on top\n        }\n\t}\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}