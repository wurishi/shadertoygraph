{"ver":"0.1","info":{"id":"cdSyRc","date":"1695688812","viewed":78,"name":"The Teddimension","username":"Sizertz","description":"Expanding my Teddy shader with different materials and Phong specular highlights and symmetry shenanigans.\nClick to turn around by hand.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","bear"],"hasliked":0,"parentid":"cdSXDW","parentname":"Teddy Bear"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// utils\nfloat lerp(in float a, in float b, in float t) {\n    return a * (1.0 -t) + b * t;\n}\n\nvec3 lerp(in vec3 a, in vec3 b, in float t) {\n    return a * (1.0 -t) + b * t;\n}\n\n// material\nstruct Material {vec3 diffuse; float sheen; float specular; float specE;};\nMaterial lerp(in Material a, in Material b, in float t) {\n    return Material(lerp(a.diffuse, b.diffuse, t), \n    lerp(a.sheen, b.sheen, t),\n    lerp(a.specular, b.specular, t),\n    lerp(a.specE, b.specE, t)\n    );\n}\n\n// polynomial smooth min\nfloat smoothmin(in  float a, in float b, in float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smoothmax(in  float a,in  float b,in  float k )\n{\n    return -smoothmin(-a,-b,k);\n}\n\nfloat smoothmin2(in  float a, in  float b, in  float r) {\n    return - log(exp(-r*a) + exp(-r*b)) / r;\n}\n\n\nfloat smoothmax2(in  float a, in  float b, in  float r) {\n    return log(exp(r*a) + exp(r*b)) / r;\n}\n\nfloat sdfSphere(in  vec3 pos,  in float radius) {\n    return length(pos) - radius;\n}\n\n\nfloat sdfPrimXLine(in vec3 pos) {\n    if(pos.x > 1.)\n        return length(pos - vec3(0.,0.,1.));\n    if(pos.x < 0.)\n        return length(pos);\n    return length(pos.yz); \n}\n\nfloat length2(vec3 v) {\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\nfloat sdfPrimLine(in vec3 pos, in vec3 a, in vec3 b) {\n    vec3 u = b-a;\n    vec3 x = pos-a;\n    if(dot(x, u) < 0.)\n        return length(x);\n    x = pos-b;\n    if(dot(x, u) > 0.)\n        return length(x);\n    vec3 proj = cross(u, cross(u, x));\n    return abs(dot(x,normalize(proj))); \n}\n\nfloat sdfPrimCircle(in vec3 pos, in vec3 o, in float r, in vec3 n) {\n    pos -= o;\n    vec3 u = -cross(n, cross(n,pos));\n    u = normalize(u);\n    return length(pos-r*u);\n}\n\nfloat sdfPrimCone(in vec3 pos, in float slope, in vec3 axis, in vec3 origin) {\n    pos -= origin;\n    axis = normalize(axis);\n    if(dot(axis,pos) < 0.) axis = -axis;\n    // normal to the plane that contains the axis and pos\n    vec3 n = cross(pos,axis);\n    n = normalize(n);\n    \n    vec3 u = cross(axis, n);\n    if(dot(pos,u) < 0.) u = -u;\n    // tangent to the cone in that plane\n    vec3 t = axis + slope * u;\n    // normal to the cone in that plane\n    vec3 proj = cross(t, n);\n    return dot(pos, normalize(proj));\n}\n\nfloat sdfPrimPlane(in vec3 pos, in vec3 n) {\n    return dot(pos, normalize(n));\n}\n\nvec3 bendCoords(in vec3 pos, in vec3 origin, in vec3 t, in vec3 n, in float amount) {\n    vec3 p = pos-origin;\n    n = normalize(n);\n    t = normalize(t);\n    mat3 mat = mat3(t,n,cross(t,n));\n    mat3 inv = inverse(mat);\n    p = inv * p;\n    float c = cos(amount*p.x);\n    float s = sin(amount*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return  mat * vec3(m*p.xy,p.z) + origin;\n}\n\nfloat sdfOutsideEar(in vec3 pos) {\n    float radius = 0.07;\n    vec3 center = vec3(0.12,1.14,-0);\n    return sdfSphere(pos - center, radius);\n}\n\nfloat sdfInsideEar(in vec3 pos) {\n    float radius = 0.07;\n    vec3 center = vec3(0.12,1.14,-0);\n    return sdfSphere(pos - center + vec3(0.,0.02,radius), radius*0.5);\n}\n\nfloat sdfEars(in vec3 pos) {\n    float insideEar = sdfInsideEar(pos);\n    float outsideEar = sdfOutsideEar(pos);\n    return smoothmax(outsideEar, -insideEar, .1);\n}\n\nfloat sdfHead(in vec3 pos) {\n    // sphere\n    vec3 headPos = vec3(0.0,1.02,0.0);\n    vec3 conePos = vec3(0.,1.5,0);\n    float cone = sdfPrimCone(pos, .4, headPos-conePos, conePos);\n    pos -= headPos;\n    float isoSmooth= .4;\n    float size = .2;\n    float scale = 1. + isoSmooth/size;\n    pos *= vec3(scale);\n\n    float sd = sdfSphere(pos , size);\n    \n    \n    // cutoff front and back\n    sd = smoothmax(sd, pos.z - size * .5, size * 2.5);\n    sd = smoothmax(sd, -pos.z - size * .5, size * 2.5);\n    sd = smoothmax(sd, -pos.y + size * .1, size * 5.5);\n    \n    sd = (sd - isoSmooth) / scale;\n    \n    sd = smoothmax(sd, cone, .1);\n    \n    return sd;\n}\n\nfloat sdfFulcrum(in vec3 pos) {\n    vec3 snoutCenter = vec3(0.0,1.05,-0.08);\n    float snoutSize = .1;\n    float fulcrum = sdfPrimCircle(pos, snoutCenter + vec3(.0,.00,+.11), snoutSize + .1, vec3(1.,0.,0.) - 0.001);\n    fulcrum = sdfPrimLine(pos,vec3(0.,.99,-.16),vec3(0.,1.1,-.22)) -0.001;\n    fulcrum = smoothmin(fulcrum, sdfPrimLine(pos,vec3(0.,.99,-.165),vec3(0.2,.88,-.02)) -0.001, 0.01);\n    fulcrum = smoothmin(fulcrum, sdfPrimLine(pos,vec3(0.,.99,-.165),vec3(-0.2,.88,-.02)) -0.001, 0.01);\n    return fulcrum;\n}\n\nfloat sdfSnout(in vec3 pos) {\n    vec3 snoutCenter = vec3(0.0,1.05,-0.08);\n    float snoutSize = .1;\n    float snout = sdfSphere(pos-snoutCenter, snoutSize);\n    snout = smoothmax(snout, pos.y-(snoutCenter.y+snoutSize * .1), snoutSize);\n    float fulcrum = sdfFulcrum(pos);\n    snout = smoothmax(snout, -fulcrum, 0.03); \n    return snout;\n}\n\nfloat sdfNose(in vec3 pos) {\n    float nose = sdfSphere(pos-vec3(0.0,1.04,-0.16), .02);    \n    float nostril = sdfSphere(pos-vec3(0.015,1.03,-0.168), .01);\n    nose = smoothmax(nose, -nostril, 0.01);\n    return smoothmax(nose, pos.y-1.055, 0.01);\n}\n\nfloat sdfEyes(in vec3 pos) {\n    return sdfSphere(pos-vec3(0.06,1.07,-0.115), .015);\n}\n\nfloat sdfBelly(in vec3 pos) {\n    float body= sdfSphere(pos-vec3(0.,0.7,0.02), .22);\n    return smoothmin(body, sdfSphere(pos-vec3(0.,0.85,0.03), .12), 0.2);\n}\n\nfloat sdfArm(in vec3 pos) {\n    float arm = sdfPrimCircle(pos, vec3(0.1,0.8,-0.05), .14, vec3(0.,1.,-.7)) - .065;\n    arm = smoothmax(arm, -sdfPrimPlane(pos, vec3(1.5,1.2,.1)) + .62, .12);\n    return arm;\n}\n\nfloat sdfLeg(in vec3 pos) {\n    vec3 footPos = vec3(0.2,0.6,-0.28);\n    vec3 legOri = vec3(0.1,0.6,0.);\n    float leg=sdfPrimLine(pos, legOri, footPos) - .08;\n    float foot = sdfSphere(pos-(footPos+vec3(0.,0.02,0.)), 0.11);\n    foot = smoothmax(foot,sdfPrimPlane(pos, footPos-legOri) - 0.37, 0.06);\n    \n    //foot = smoothmax(foot,-sdfPrimCircle(mirrorXPos,footPos+vec3(.01,.025,-.018),0.1,footPos-legOri) + 0.002, 0.01);\n    \n    foot= smoothmax(foot, sdfPrimPlane(pos, vec3(1.1,0.,0.2)) - .27, 0.12);\n    foot= smoothmax(foot, sdfPrimPlane(pos, -vec3(1.1,0.,0.2)) + .03, 0.12);\n    \n    leg = smoothmax(leg,sdfPrimPlane(pos, footPos-legOri) - 0.32, 0.035);\n    leg = smoothmin(leg,foot,.01);\n    return leg;\n}\n\nfloat sdfPaw(in vec3 pos) {\n    vec3 footPos = vec3(0.2,0.6,-0.28);\n    vec3 legOri = vec3(0.1,0.6,0.);\n    float paw = sdfSphere(vec3(1.,0.98,1.) * (pos-(footPos+vec3(0.,0.04,0.))), 0.08);\n    return paw;\n}\n\nfloat sdfPawPrint(in vec3 pos) {\n    vec3 footPos = vec3(0.2,0.6,-0.28);\n    vec3 legOri = vec3(0.1,0.6,0.);\n    float pawPrint = sdfSphere(vec3(1.,1.5,1.) * (pos-(footPos+vec3(0.005,0.,-0.02))), 0.04);\n    float dots = sdfSphere(vec3(1.,0.9,1.) * (pos-(footPos+vec3(0.015,0.08,-0.04))), 0.016);\n    pawPrint = min(pawPrint, dots);\n    dots = sdfSphere(vec3(1.,0.9,1.) * (pos-(footPos+vec3(0.053,0.055,-0.02))), 0.015);\n    pawPrint = min(pawPrint, dots);\n    dots = sdfSphere(vec3(1.,0.9,1.) * (pos-(footPos+vec3(-0.03,0.06,-0.05))), 0.015);\n    pawPrint = min(pawPrint, dots);\n    return pawPrint;\n}\n\nfloat sdfGround(vec3 pos){\n    return pos.y - 0.54;\n}\n\nmat2x2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec3 sceneSymmetries(in vec3 pos) {\n    vec3 symPos = pos.xyz;\n    float tile = 1.7;\n    symPos = mod(symPos + tile, 2. * tile) - tile;\n    \n    vec3 n = pos - symPos;\n    mat2x2 rot = rot2(fract(6.5*sin(n.x) + 7.3 * sin(n.y) + 1.219 * sin(n.z)) * 4.);\n    symPos.xz = rot * symPos.xz;\n    \n    symPos.x = abs(symPos.x); \n    \n    \n    return symPos;\n}\n\n\n\nvec4 sceneSDF(in vec3 pos) {\n    vec3 symPos = sceneSymmetries(pos);\n    \n    // head\n    float sd = sdfHead(symPos);\n    \n    // ears\n    float ears = sdfEars(symPos);\n    sd = smoothmin(sd, ears, 0.02);\n    \n    \n    //snout\n    \n    float snout = sdfSnout(symPos);\n    sd = smoothmin(sd, snout, 0.008);\n    \n    \n    //nose\n    float nose = sdfNose(symPos);\n    \n    \n    sd = smoothmin(sd, nose, 0.005);\n    \n    \n    // eyes\n    float eyes = sdfEyes(symPos);\n    sd = smoothmax(sd, -eyes - .0145, .05);\n    sd = smoothmin(sd, eyes, .002);\n    \n    \n    // body\n    float belly = sdfBelly(symPos);\n    sd = smoothmin(sd, belly, 0.02);\n    \n    // arm\n    float arm = sdfArm(symPos);\n    sd = min(sd, arm);\n    \n    // leg\n    float leg = sdfLeg(symPos);       \n    sd = smoothmin(sd, leg, 0.01);\n    sd = smoothmax(sd, -pos.y + .5, 0.2);\n    \n    // ground\n    float ground = sdfGround(pos);\n    sd = min(sd,ground);\n    \n    return vec4(sd, pos);\n}\n\nvec4 rayMarch(in vec3 rayOrigin, in vec3 rayDir) {\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 100000.0;\n    \n    for(int i=0; i<1024 && t<tmax; i++) {\n        vec4 h = sceneSDF(rayOrigin + t*rayDir);\n        if( h.x < 0.001 ) { res = vec4(t, h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 camToScene(in vec3 dir, in vec3 camDir, in vec3 camUp) {\n    vec3 cZ = normalize(camDir);\n    vec3 cX = normalize(cross(camUp, cZ));\n    vec3 cY = cross(cZ,cX);\n    mat3 camToSceneMat = mat3(cX,cY,cZ);\n    return camToSceneMat * dir;\n}\n\nvec4 rayMarch(in vec2 pixel, in vec3 camPos, in vec3 camDir, in vec3 camUp, in float fov) {\n    // vec3 dir = vec3( tan(fov) / iResolution.x * pixel, 1.0); // pixel direction in camera space \n    vec3 dir = vec3( tan(fov * 3.14159 / 180.0) * (pixel - vec2(iResolution.xy / 2.0)), iResolution.x); // pixel direction in camera space \n    dir = camToScene(dir, camDir, camUp);\n    return rayMarch(camPos, normalize(dir));\n}\n\nvec3 camPos(in float time) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float angle = (time + 0.) * 0.05 + mouse.x * 10.;\n    float radius = 3.;\n    float height = 0.7;\n    return vec3(radius*sin(angle), height, -radius*cos(angle));\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 n = vec3(0.0);\n    for (int i = 0; i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e* sceneSDF(pos+0.0005*e).x;\n    }\n    return normalize(n);    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.02 * float(i);\n        float d = sceneSDF( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftShadow( in vec3 origin, in vec3 dir, in float tmin, in float tmax )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = sceneSDF( origin + dir*t ).x;\n        float s = clamp(32.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 100.9 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nconst Material MAT_BG           = Material(vec3(0.65,0.95,0.90), 0.0, 0.0, 1.0);\nconst Material MAT_FELT         = Material(vec3(0.70,0.50,0.30), 1.0, 0.0, 1.0);\nconst Material MAT_FELT_LIGHT   = Material(vec3(0.95,0.80,0.60), 1.0, 0.05, 1.0);\nconst Material MAT_FELT_DARK    = Material(vec3(0.55,0.35,0.20), 1.0, 0.1, 1.);\nconst Material MAT_FLOOR_DARK   = Material(vec3(0.55,0.75,0.65), 0.0, 0.0, 1.0);\nconst Material MAT_FLOOR_BRIGHT = Material(vec3(0.60,0.80,0.70), 0.0, 0.0, 1.0);\nconst Material MAT_EYES         = Material(vec3(0.10,0.10,0.10), 0.5, 1.0, 8.);\nconst Material MAT_NOSE         = Material(vec3(0.55,0.35,0.20), 1.0, 0.4, 4.0);\n\nMaterial getMaterial(in vec3 pos) {\n    if(pos.y < 0.545) {\n        if (int(floor(pos.x) + floor(pos.z)) % 2 == 0 ) \n            return MAT_FLOOR_DARK;\n        else return MAT_FLOOR_BRIGHT;\n    }\n    vec3 symPos = sceneSymmetries(pos);\n    \n    Material mat = MAT_FELT;\n    float eyes = smoothstep(0.001, 0.0025, sdfEyes(symPos));\n    mat = lerp(MAT_EYES, mat, eyes);\n    \n    float snout = smoothstep(-.01, 0.01, sdfSnout(symPos));\n    mat = lerp(MAT_FELT_LIGHT, mat, snout);\n        \n    float fulcrum = smoothstep(0.005, 0.01, max(sdfFulcrum(symPos), sdfSnout(symPos)));\n    mat = lerp(MAT_FELT_DARK, mat, fulcrum);\n   \n    float nose = smoothstep(0.002, 0.003, sdfNose(symPos));\n    mat = lerp(MAT_NOSE, mat, nose);\n    \n    float insideEar = 1. - smoothstep(.005, 0.025, sdfInsideEar(symPos));\n    insideEar *= smoothstep(.002, 0.015, sdfHead(symPos));\n    mat = lerp(MAT_FELT_LIGHT, mat, 1.-insideEar);\n    \n    float paw = smoothstep(.001, 0.005, sdfPaw(symPos));\n    mat = lerp(MAT_FELT_LIGHT, mat, paw);\n    \n    float pawPrint = smoothstep(.001, 0.008, sdfPawPrint(symPos));\n    mat = lerp(MAT_FELT_DARK, mat, pawPrint);\n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 camPos = camPos(iTime);\n    vec3 camDir = vec3(0,.85,0) - camPos;\n    vec3 camUp = vec3(0,1,0);\n    float fov = 30.0;\n\n\n    // background\n    Material material = MAT_BG;\n\n    \n    // ray march scene\n    vec4 rayMarch = rayMarch(fragCoord, camPos, camDir, camUp, fov);\n    \n    vec3 col = material.diffuse;\n    if(rayMarch.x > 0.0) {\n        float zDepth = rayMarch.x;\n        float depthMask = pow(max(0.0, zDepth-5.0)*0.005,0.4);\n        depthMask = clamp(1.0-depthMask, 0., 1.);\n        vec3 normal = calcNormal(rayMarch.yzw);\n        float ao = calcAO(rayMarch.yzw, normal);\n        \n        //vec3 mat = rayMarch.z > .01 ? vec3(.7,.5,.3) : vec3(0.5+0.01*float((int(floor(rayMarch.y) + floor(rayMarch.w)) % 2) == 0));\n        material = getMaterial(rayMarch.yzw);\n        vec3 mat = material.diffuse;\n        \n        // ambiant\n        vec3 ambient = vec3(0.50,0.50,1.00);\n        col = ambient * .5 * mat;\n        \n        //  directional light\n        vec3 directionalLight = normalize(vec3(1.,-2.,2.));\n        float directionalDiffuse = clamp(dot(-directionalLight,normal), 0., 1.);\n        float directionalShadow = calcSoftShadow(rayMarch.yzw, -1.*directionalLight, 0.0001, 3.5);\n        col += mat * 1.0 * directionalDiffuse * directionalShadow; \n        \n        // add Fresnel sheen to Teddy\n        if(rayMarch.z > .01) {\n            float sheen = 0.2 - .2 * clamp(dot(normal, normalize(camPos-rayMarch.yzw)), 0., 1.);\n            col += sheen * material.sheen;\n            col = clamp(col, 0., 1.);\n        }\n        \n        // Phong specular\n        float spec = dot(reflect(-directionalLight,normal), normalize(rayMarch.yzw - camPos));\n        col = lerp(col, vec3(1.) * pow(clamp(spec,0.,1.), material.specE), material.specular);\n        \n        // AO\n        col = lerp(col*col*ao, col, pow(ao, 1.));\n        \n        // atmospheric fog\n        col = lerp(MAT_BG.diffuse, col, depthMask);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}