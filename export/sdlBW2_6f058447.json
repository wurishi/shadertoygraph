{"ver":"0.1","info":{"id":"sdlBW2","date":"1645440787","viewed":203,"name":"Kaleidoscope Simulation","username":"VL","description":"..","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime*0.3)\n\nconst float MaxDist = 100.f;\nconst float SurfaceDist = 0.0001f;\nconst float PI = 3.141592653f;\nconst float PI2 = 6.2831853f;\n\nfloat2 hash(float2 p)\n{\n    float3 p3 = frac(float3(p.xyx) * float3(132.1031, 114.1030, 144.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return frac((p3.xx + p3.yz) * p3.zy)*2.-1.;\n}\n\nfloat3 hash(float3 p3)\n{\n    p3 = frac(p3 * float3(152.1031, 162.1030, 177.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return frac((p3.xxy + p3.yxx) * p3.zyx)*2.-1.;\n}\n\nfloat sdf3dInfPlane(float3 _point, float3 plane, float3 planeNormal)\n{\n    return dot((_point - plane), planeNormal);\n}\n\nfloat kaleidoscopeTunnel(float3 ray)\n{\n    float dist = sdf3dInfPlane(ray, float3(0.f, 0.f, 0.f), float3(0.f, 1.f, 0.f));\n    dist = min(dist, sdf3dInfPlane(ray, float3(4.f, 4.f, 0.f), float3(-sin(PI2 / 3.f), cos(PI2 / 3.f), 0.f)));\n    dist = min(dist, sdf3dInfPlane(ray, float3(-4.f, 4.f, 0.f), float3(cos(-PI / 6.f), sin(-PI / 6.f), 0.f)));\n    \n    return dist;\n}\n\nfloat2 minX(float2 a, float2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat2 GetDist(float3 ray)\n{\n    float2 minDist = float2(kaleidoscopeTunnel(ray), 0.f);\n    minDist = minX(minDist, float2(sdf3dInfPlane(ray, float3(0.f, 0.f, CurrentTime + 10.f), float3(0.f, 0.f, -1.f)), 1.f));\n    \n    return minDist;\n}\n\nfloat2 RayMarching(float3 origin, float3 dir)\n{\n    float hitDist = 0.f;\n    float mat = 0.f;\n    for (int i = 0; i < 100; ++i)\n    {\n        float3 ray = origin + hitDist * dir;\n        float2 curr = GetDist(ray);\n        if (hitDist > MaxDist || curr.x < SurfaceDist)\n            break;\n        hitDist += curr.x;\n        mat = curr.y;\n    }\n    \n    return float2(hitDist,mat);\n}\n\nfloat3 GetNormal(float3 ray)\n{\n    float2 k = float2(1.f, -1.f);\n      \n    return normalize(k.xyy * GetDist(ray + k.xyy * SurfaceDist).x +\n                     k.yyx * GetDist(ray + k.yyx * SurfaceDist).x +\n                     k.yxy * GetDist(ray + k.yxy * SurfaceDist).x +\n                     k.xxx * GetDist(ray + k.xxx * SurfaceDist).x);\n}\n\nfloat2 kaleidoReflect(inout float3 rayPoint, float3 normal, float3 rayDir)\n{\n    float3 rfl = reflect(rayDir, normal);\n    float2 curr = RayMarching(rayPoint + rfl * 0.1f, rfl);\n    rayPoint = rayPoint + rfl * curr.x;\n    normal = GetNormal(rayPoint);\n    \n    int reflectCnt = 1;\n    for (; reflectCnt < min(14,int(iTime*3.0)) && curr.y == 0.f; ++reflectCnt)\n    {\n        rfl = reflect(rfl, normal);\n        curr = RayMarching(rayPoint + rfl * 0.1f, rfl);\n        rayPoint = rayPoint + rfl * curr.x;\n        normal = GetNormal(rayPoint);\n    }\n    \n    rayDir = rfl;\n    return curr;\n}\n\nfloat simplexNoise(float3 p)\n{\n    float k1 = 0.333333f;\n    float k2 = 0.166667f;\n    \n    int3 idx = floor(p + (p.x + p.y + p.z) * k1);\n    float3 a = p - (float3(idx) - float(idx.x + idx.y + idx.z) * k2);\n    \n    int3 tb1Arr[8] = vec3[8]\n    ( int3(0, 0, 1), int3(0, 1, 0), int3( 0), int3(0, 1, 0), int3(0, 0, 1), int3( 0), int3(1, 0, 0), int3(1, 0, 0) );\n    int3 tb2Arr[8] = vec3[8]\n    ( int3(0, 1, 1), int3(0, 1, 1), int3( 0), int3(1, 1, 0), int3(1, 0, 1), int3( 0), int3(1, 0, 1), int3(1, 1, 0) );\n    \n    uint tbIdx = (uint(a.x > a.y) << 2) | (uint(a.x > a.z) << 1) | uint(a.y > a.z);\n    \n    int3 tb1 = tb1Arr[tbIdx], tb2 = tb2Arr[tbIdx];\n    \n    float3 b = a - tb1 + k2;\n    float3 c = a - tb2 + k2 * 2.f;\n    float3 d = a - 1.f + k2 * 3.f;\n    \n    float4 kernel = max(0.5f - float4(dot(a, a), dot(b, b), dot(c, c), dot(d, d)), 0.f);\n    kernel *= kernel;\n    kernel *= kernel;\n    float4 noise = kernel * float4(dot(a, hash(idx)*2.-1.), \n                                   dot(b, hash(idx + tb1)*2.-1.), \n                                   dot(c, hash(idx + tb2)*2.-1.), \n                                   dot(d, hash(idx + 1.f)*2.-1.));\n    \n    return dot(vec4(60.f), noise);\n}\n\nfloat3 kaleidoColor(float3 p)\n{\n    p.y -= 4.f;\n    float2 v = lerp(hash(floor(p.zz)), hash(floor(p.zz + vec2(1))), frac(p.z));\n    \n    p.xy *= v * 4.f;\n    p.x *= sin(p.x);\n    p.y *= cos(p.y);\n    float s, c;\n    //sincos(p.z, s, c);\n    s = sin(p.z);\n    c = cos(p.z);\n    float2x2 rot = float2x2(s, c, -s, c);\n    \n    //[unroll]\n    for (int i = 0; i < 3; ++i)\n    {\n        p.yz = p.xy* rot;\n        p[i] = simplexNoise(p * v.xyx)*0.3;\n        p *= length(p.xy);\n    }\n    \n    return abs(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = 2.f*(fragCoord.xy/iResolution.xy)-1.f;\n   uv.x *= iResolution.x/iResolution.y;\n\n\n    float3 rayOrigin = float3(0.f, 8.f, CurrentTime - 20.f);\n    float3 rayDir = normalize(float3(uv, 1.f));\n    \n    float2 march = RayMarching(rayOrigin, rayDir);\n    float3 rayPoint = rayOrigin + rayDir * march.x;\n    float3 normal = GetNormal(rayPoint);\n    \n    if(march.y == 0.f)\n        march = kaleidoReflect(rayPoint, normal, rayDir);\n    \n    fragColor = float4(vec3(0.f), 1.f);\n    if(march.y == 1.f)\n    fragColor.rgb = kaleidoColor(rayPoint);\n}","name":"Image","description":"","type":"image"}]}