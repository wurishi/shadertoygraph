{"ver":"0.1","info":{"id":"4tKfRw","date":"1543584690","viewed":336,"name":"Approx. Cubic Spline Distance","username":"nr4","description":"Approximate cubic bezier spline distance for rendering SVGs.\nTechnique is interval approximation. Also tried power series approximation (glitches). I expect that the discontinuities in the more far away regions can be removed with polynomial division.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","approximation","spline","distance","cubic","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Approx. Cubic Spline Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Update 1: Optimizations\n\n// Switch between cubic and quadratic splines here.\n//#define QUADRATIC\n#define CUBIC\n\nconst vec2 k = vec2(1.,0.);\nconst float pi = acos(-1.);\n\nvec2 B2(float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    float m1 = 1.-t;\n    return m1*m1*P0 + 2.*m1*t*P1 + t*t*P2;\n}\n\nvec2 B2Prime(float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    return 2.*((1.-t)*(P1-P0)+t*(P2-P1));\n}\n\nfloat D2(vec2 x, float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    return length(x-B2(t, P0, P1, P2));\n}\n\nfloat D2Prime(vec2 x, float  t, vec2 P0, vec2 P1, vec2 P2)\n{\n    return dot(x-B2(t,P0,P1,P2), B2Prime(t, P0,P1,P2));\n}\n\nvec2 B3(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return m1*m1*m1*P0 + 3.*m1*t*(m1*P1+t*P2) + t*t*t*P3;\n}\n\nvec2 B3Prime(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return 3.*(m1*m1*(P1-P0)+2.*m1*t*(P2-P1)+t*t*(P3-P2));\n}\n\nfloat D3(vec2 x, float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    return length(x-B3(t, P0, P1, P2, P3));\n}\n\nfloat D3Prime(vec2 x, float  t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    return dot(x-B3(t,P0,P1,P2,P3), B3Prime(t,P0,P1,P2,P3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.*(fragCoord/iResolution.yy-.5);\n    \n    // Control points.\n    vec2 p_0 = vec2(-.25,-.25)+.15*vec2(sin(iTime), cos(3.*iTime)), \n        p_1 = vec2(.25,-.25)+.5*vec2(sin(iTime), .5-sin(iTime)),\n        p_2 = vec2(.25,.25)+.15*vec2(cos(iTime), sin(iTime)),\n    \tp_3 = vec2(.65,.35)+.15*vec2(sin(iTime), cos(iTime));\n\n    float tmin = 0., tmax = 1., tnew, \n#ifdef QUADRATIC\n        dmin = D2Prime(uv,tmin,p_0,p_1,p_2), \n        dmax = D2Prime(uv,tmax,p_0,p_1,p_2),\n#else\n        dmin = D3Prime(uv,tmin,p_0,p_1,p_2,p_3),\n        dmax = D3Prime(uv,tmax,p_0,p_1,p_2,p_3),\n#endif\n        dnew;\n    \n    // Solve for polynomial roots with interval approximation.\n    for(int i=0; i<10; ++i)\n    {\n        // Compute t and distance for the new test parameter tnew\n        tnew = mix(tmin, tmax, .5);\n#ifdef QUADRATIC\n        dnew = D2Prime(uv,tnew,p_0,p_1,p_2);\n#else\n        dnew = D3Prime(uv,tnew,p_0,p_1,p_2,p_3);\n#endif\n        \n        if(dnew>0.)\n        {\n            tmin = tnew;\n            dmin = dnew;\n        }\n        else \n        {\n            tmax = tnew;\n            dmax = dnew;\n        }\n    }\n        \n    // Cap at the ends of the spline\n    tmin = clamp(tmin, 0., 1.);\n    \n    // Compute distance\n#ifdef QUADRATIC\n    dmin = D2(uv, tmin, p_0, p_1, p_2);\n#else\n    dmin = D3(uv, tmin, p_0, p_1, p_2, p_3);\n#endif\n    \n    vec3 col = k.yyy;\n    \n    // Draw distance isolines\n    col += (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*mod(dmin,0.1)*10.+vec3(1.,0.,0.)*step(dmin,.05);\n    // Draw control points\n    col += k.yxx*step(length(uv-p_0), .05)+k.xyx*step(length(uv-p_1), .05)+k.yxx*step(length(uv-p_2), .05);\n    \n#ifdef CUBIC\n    col += k.yxy*step(length(uv-p_3), .05);\n#endif\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}