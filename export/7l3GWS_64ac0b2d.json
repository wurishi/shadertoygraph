{"ver":"0.1","info":{"id":"7l3GWS","date":"1636611050","viewed":267,"name":"mat3 vs vec4 quarternion","username":"akohdr","description":"unit wireframe cube rendered with mat3 euler angle transform (red) and quarternion transforms (green)\nif math is correct cubes should overlay precisely and combine to yellow","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["wireframe","rotation","plotter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define iR iResolution\n\n#define USE_MATRIX\n#define USE_QUARTERNION\n//#define INDIVIDUALQ\n\n// choose quarternion multiplication impl.\n//#define mulQ(a,b) mulQ_c(a,b)\n//#define mulQ(a,b) mulQ_mat4(a,b)\n//#define mulQ(a,b) mulQ_mat4s(a,b)\n//#define mulQ(a,b) mulQ_mat4m(a,b)\n//#define mulQ(a,b) mulQ_mat4m2(a,b)\n#define mulQ(a,b) mulQ_mat4m3(a,b)\n//#define mulQ(a,b) mulQ_mat4v(a,b)\n//#define mulQ(a,b) mulQ_xd(a,b)\n\n// choose rotation matrix impl.\n//#define rotMT eulerAngleT\n//#define rotMT eulerAngleTs\n//#define rotMT eulerAngleTc\n#define rotMT eulerAngleTv\n\nfloat line3d(vec2 c, vec3 a, vec3 b)\n{    \n    vec3 camPos = vec3(0,0,-8);\n    a -= camPos;  b -= camPos;\n    \n    // perspective projection\n    a.xy /= a.z;  b.xy /= b.z;  c -= a.xy;\n    \n    vec2 d = b.xy - a.xy; \n    return smoothstep(.015,-.015,length (c - clamp (dot(c, d) / dot(d,d), .0, 1.)*d));\n}\n\nmat3 eulerAngleT(vec3 a)\n{\n    vec3 s = sin(a), c = cos(a);\n    return mat3( c.z, s.z,   0,\n                -s.z, c.z,   0,\n                   0,   0,   1 ) *\n                   \n           mat3( c.y,   0,-s.y,\n                   0,   1,   0,\n                 s.y,   0, c.y ) *\n                 \n           mat3(   1,   0,   0,\n                   0, c.x, s.x,\n                   0,-s.x, c.x );\n}\n\nmat3 eulerAngleTs(vec3 a)\n{\n    const mat3 s3 = mat3( 1, 1,-1,\n                         -1, 1, 1,\n                          1,-1, 1);\n    \n    vec3 s = sin(a), c = cos(a);\n    vec2 x = vec2(c.x,s.x), z = vec2(c.z,s.z);\n    \n    return (mat3(   z,   0,\n                    z.yx,0,\n                    0,   0,   1 )/s3) *\n                   \n           (mat3( c.y,   0, s.y,\n                    0,   1,   0,\n                  s.y,   0, c.y )/s3) *\n                 \n           (mat3(   1,   0,   0,\n                    0,   x,\n                    0,   x.yx   )/s3);\n}\n\nmat3 eulerAngleTc(vec3 a)\n{\n    vec3 s = sin(a), \n         c = cos(a);\n    return mat3(\n        c.y*c.z,                c.y*s.z,              -s.y,\n        c.z*s.x*s.y - c.x*s.z,  c.x*c.z + s.x*s.y*s.z, c.y*s.x,\n        c.x*c.z*s.y + s.x*s.z, -c.z*s.x + c.x*s.y*s.z, c.x*c.y\n        );\n}\n\nmat3 eulerAngleTv(vec3 a)\n{\n\n// ooops wrong orientation\n//        c.y*c.z, c.z*s.x*s.y + c.x*s.z, s.x*s.z - c.x*c.z*s.y, \n//       -c.y*s.z, c.x*c.z - s.x*s.y*s.z, c.z*s.x + c.x*s.y*s.z, \n//        s.y, -c.y*s.x, c.x*c.y\n// and again  (is correct but transposed, column major indexing vs Mathematica)\n//        c.y*c.z, c.z*s.x*s.y - c.x*s.z, c.x*c.z*s.y + s.x*s.z, \n//        c.y*s.z, c.x*c.z + s.x*s.y*s.z, -c.z*s.x + c.x*s.y*s.z, \n//       -s.y, c.y*s.x, c.x*c.y\n// and again\n//        c.y *c.z, s.x*s.y - c.x*c.y*s.z, c.x*s.y + c.y*s.x*s.z,\n//        s.z, c.x*c.z, -c.z*s.x,\n//        -c.z*s.y, c.y*s.x + c.x*s.y*s.z, c.x*c.y - s.x*s.y*s.z\n// and again but we can cheat and reverse angle\n//        c.y*c.z, -c.y*s.z, s.y, \n//        c.z*s.x*s.y + c.x*s.z,c.x*c.z - s.x*s.y*s.z, -c.y*s.x, \n//       -c.x*c.z*s.y + s.x*s.z, c.z*s.x + c.x*s.y*s.z, c.x*c.y\n\n// finally matches\n//        c.y*c.z,                c.y*s.z,              -s.y,\n//        c.z*s.x*s.y - c.x*s.z,  c.x*c.z + s.x*s.y*s.z, c.y*s.x,\n//        c.x*c.z*s.y + s.x*s.z, -c.z*s.x + c.x*s.y*s.z, c.x*c.y\n\n\n    // optimized for vector ops.\n    vec3 s = sin(a),  c = cos(a);\n         \n    vec2 t = s.y*vec2(c.x,s.x);\n    vec4 u = s.z*vec4(c.x,t.y,s.x,t.x),  // this could be matrix op.\n         v = c.y*vec4(c.z,s.z,s.x,c.x),\n         w = c.z*vec4(t.y,c.x,t.x,s.x);\n\n#define CHAINED_M\n#ifdef CHAINED_M\n    return mat3( v.x, v.y,   0,\n                 w.x, w.y, v.z,\n                 w.z, u.w, v.w) - mat3( 0,     0, s.y,\n                                        u.x,   0,   0,\n                                        0,   w.w,   0) + mat3(   0,   0,   0,\n                                                                 0, u.y,   0,\n                                                               u.z,   0,   0);\n                                                               \n#else                                                               \n    // safer layout, ensures left right precedence\n    // (local mat3 assignment seems to take slight fps hit)\n    mat3 m = mat3( v.x, v.y,   0,\n                   w.x, w.y, v.z,\n                   w.z, u.w, v.w);\n                  \n        m -= mat3(   0,   0, s.y,\n                   u.x,   0,   0,\n                     0, w.w,   0);\n                    \n        m += mat3(   0,   0,   0,\n                     0, u.y,   0,\n                   u.z,   0,   0);\n        \n        return m;\n        \n#endif\n}\n\n// raw C impl of mulQ\nvec4 mulQ_c(vec4 a,vec4 b)\n{\n    return vec4( a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x,\n                -a.x * b.z + a.y * b.w + a.z * b.x + a.w * b.y,\n                 a.x * b.y - a.y * b.x + a.z * b.w + a.w * b.z,\n                -a.x * b.x - a.y * b.y - a.z * b.z + a.w * b.w);\n}\n\n// mat4 impl of mulQ\nvec4 mulQ_mat4(vec4 a,vec4 b)\n{\n// per Fab,\n    return a * mat4( b.w , b.z ,-b.y , b.x,\n                    -b.z , b.w , b.x , b.y,\n                     b.y ,-b.x , b.w , b.z,\n                    -b.x ,-b.y ,-b.z , b.w);\n}\n\nvec4 mulQ_mat4m(vec4 a,vec4 b)\n{\n    return mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b ) / mat4( 1,-1, 1,-1,\n                             1, 1,-1,-1,\n                            -1, 1, 1,-1,\n                             1, 1, 1, 1) * a;\n}\n\nvec4 mulQ_mat4m2(vec4 a,vec4 b)\n{\n    return matrixCompMult(\n           mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b ), \n           mat4( 1,-1, 1,-1,\n                 1, 1,-1,-1,\n                -1, 1, 1,-1,\n                 1, 1, 1, 1)) * a;\n}\n\nvec4 mulQ_mat4m3(vec4 a,vec4 b)\n{\n    return a * matrixCompMult(\n           mat4( 1, 1,-1, 1,\n                -1, 1, 1, 1,\n                 1,-1, 1, 1,\n                -1,-1,-1, 1),\n           mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b));\n}\n\nvec4 mulQ_mat4v(vec4 a,vec4 b)\n{\n    return a * mat4( b.wzyx * vec4( 1, 1,-1, 1),\n                     b.zwxy * vec4(-1, 1, 1, 1),\n                     b.yxwz * vec4( 1,-1, 1, 1),\n                     b      * vec4(-1,-1,-1, 1));\n}\n\nvec4 mulQ_mat4s(vec4 a,vec4 b)\n{\n    const mat4 s = mat4( 1,-1, 1,-1,\n                         1, 1,-1,-1,\n                        -1, 1, 1,-1,\n                         1, 1, 1, 1);\n\n    return mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b ) /s * a;\n}\n\n//    const mat4 s = mat4( 1, 1,-1, 1,\n//                        -1, 1, 1, 1,\n//                         1,-1, 1, 1,\n//                        -1,-1,-1, 1);\n//    return a*(mat4( b.wzyx,\n//                    b.zwxy,\n//                    b.yxwz,\n//                    b.xyzw)/s);\n                        \n//    mat4 m = mat4(b.wzyx,b.zwxy,b.yxwz,b);\n//         s = mat4( 1, 1,-1, 1,\n//                  -1, 1, 1, 1,\n//                   1,-1, 1, 1,\n//                  -1,-1,-1, 1);\n//    return a * mat4( m[0]*s[0], m[1]*s[1],m[2]*s[2],m[3]*s[3]);\n\n//    vec4 s = vec4(-1, 1, 1, 1), s3 = vec4(-1,-1,-1, 1);\n//    return a * mat4((b.ywzx * s).yzxw, \n//                     b.zwxy * s,\n//                    (b.xywz * s).yxzw,\n//                     b * s3);\n\n//    vec4 nb = -b;\n//    return a * mat4(vec4(nb.y,b.wzx).yzxw,\n//                         nb.z,b.wxy,\n//                    vec4(nb.x,b.ywz).yxzw,\n//                         nb.xyz,b.w);\n                     \n//    return a * mat4( b.wz,      -b.y , b.x,    \n//                    -b.z , b.wxy,\n//                     b.y ,-b.x , b.wz,\n//                    -b.xyz,            b.w);                    \n\n//    return mat4( b, b.zw, -b.xyy, \n//                    b.xw, -b.z,\n//                    b.w, -b.z, b.y, -b.x\n//                )*a.wyzx;\n                    \n//    return mat4( b.w, -b.z,  b.y , -b.x,\n//                 b.zw, -b.xyy,\n//                 b.xw,  -b.z,\n//                 b )*a;                    \n\n\n// mulQ implemented with cross() and dot()\nvec4 mulQ_xd(vec4 a, vec4 b)\n{\n    vec3 u = a.xyz, v = b.xyz;\n\n// per Fab, factor out (a.w * b)\n//\treturn vec4(v * a.w + u * b.w + cross(u,v), a.w * b.w - dot(u,v));\n    return a.w * b + vec4( u * b.w + cross(u,v) ,  - dot(u,v) );\n}\n\nvoid quarternionT(inout vec4 qT, inout vec4 iqT, vec3 a)\n{\n\n    vec3 b = a/2.,  // quarternion rotation splits into two halfs\n         s = sin(b), c = cos(b), is = sin(-b), ic = cos(-b);\n    \n#ifdef INDIVIDUALQ\n            \n    vec4  qTX = vec4( s.x,0,0, c.x);\n    vec4 iqTX = vec4(is.x,0,0,ic.x);\n         \n    vec4  qTY = vec4(0, s.y, 0, c.y);\n    vec4 iqTY = vec4(0,is.y, 0,ic.y);\n         \n    vec4  qTZ = vec4(0, 0, s.z, c.z);\n    vec4 iqTZ = vec4(0, 0,is.z,ic.z);\n\n    // combine individual quarternion rotation transforms \n    //   (pay attention to order mulQ non-commutative)\n     qT = mulQ(mulQ( qTZ, qTY), qTX);\n    iqT = mulQ(mulQ(iqTX,iqTY),iqTZ);\n    \n#else \n    // build transform incrementally\n     qT = vec4(0, 0, s.z, c.z);\n    iqT = vec4(0, 0,is.z,ic.z);\n    \n     qT = mulQ(qT, vec4(0, s.y, 0, c.y));\n    iqT = mulQ(    vec4(0,is.y, 0, ic.y),iqT);\n    \n     qT = mulQ(qT, vec4( s.x, 0, 0, c.x));\n    iqT = mulQ(    vec4(is.x, 0, 0, ic.x),iqT);\n\n#endif\n}\n\nfloat linesSum(vec2 c, vec3[8] v) \n{\n    return (line3d( c, v[0], v[1] )+\n            line3d( c, v[2], v[3] )+\n            line3d( c, v[4], v[5] )+\n            line3d( c, v[6], v[7] )+\n            line3d( c, v[0], v[2] )+\n            line3d( c, v[1], v[3] )+\n            line3d( c, v[4], v[6] )+\n            line3d( c, v[5], v[7] )+\n            line3d( c, v[0], v[4] )+\n            line3d( c, v[1], v[5] )+\n            line3d( c, v[2], v[6] )+\n            line3d( c, v[3], v[7] ));\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    float t = iTime*3.;\n    vec2 c = p-iR.xy/2.; c /= iR.y;\n\n// Generate transforms ---------------------------------------------\n\n    vec3 a = vec3(.7+t/6.,.7-t/6.,t);  // euler angles\n    \n#ifdef USE_QUARTERNION\n    vec4 qT, iqT;\n    quarternionT(qT, iqT, a);\n#endif\n\n#ifdef USE_MATRIX\n    mat3 mT = rotMT(a);\n#endif\n\n\n// Apply transforms to vertices ---------------------------------------------\n\n    vec3 u, v[8], w[8];\n    for ( int i=0; i < 8; i++ ) \n    {\n        // unit cube\n//      u = vec3(i>>2,(i>>1)&1,i&1)*2.-1.;       // supported only GLSL ES 3.00 and above \n\n#define BIT(b,n) (step(0.5, mod(float(b) / pow(2.,n), 1.0)))\n        u = vec3(BIT(i,3.), BIT(i,2.), BIT(i,1.))*2.-1.;\n        \n        vec3 o = vec3(max(0.,3.*cos(t/8.)),0,0); // temporal cube offset\n        \n#ifdef USE_QUARTERNION\n        v[i] = mulQ(mulQ(qT,vec4(u,0)),iqT).xyz + o;\n#endif\n        \n#ifdef USE_MATRIX\n        w[i] = mT * u - o;\n#endif\n    }  //for\n    \n    \n// Render using transformed vertices ----------------------------------------\n// (if math is correct red & green cubes should overlay turning yellow)\n    k = vec4(0);\n    \n#ifdef USE_QUARTERNION\n    k.g = linesSum(c, v);\n#endif\n\n#ifdef USE_MATRIX\n    k.r = linesSum(c, w);\n#endif\n\n    k.b = p.y/iR.y/2.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* SPIR-V from https://alexaltea.github.io/glslang.js\n\n\nvec4 mulQ_mat4(vec4 a,vec4 b)\n{\n// per Fab,\n    return a * mat4( b.w , b.z ,-b.y , b.x,\n                    -b.z , b.w , b.x , b.y,\n                     b.y ,-b.x , b.w , b.z,\n                    -b.x ,-b.y ,-b.z , b.w);\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 69\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"mulQ_mat4(vf4;vf4;\"\n               OpName %10 \"a\"\n               OpName %11 \"b\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 4\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeFunction %7 %8 %8\n         %15 = OpTypeInt 32 0\n         %16 = OpConstant %15 3\n         %17 = OpTypePointer Function %6\n         %20 = OpConstant %15 2\n         %23 = OpConstant %15 1\n         %27 = OpConstant %15 0\n         %59 = OpTypeMatrix %7 4\n         %60 = OpConstant %6 1\n         %61 = OpConstant %6 0\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %7 None %9\n         %10 = OpFunctionParameter %8\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %14 = OpLoad %7 %10\n         %18 = OpAccessChain %17 %11 %16\n         %19 = OpLoad %6 %18\n         %21 = OpAccessChain %17 %11 %20\n         %22 = OpLoad %6 %21\n         %24 = OpAccessChain %17 %11 %23\n         %25 = OpLoad %6 %24\n         %26 = OpFNegate %6 %25\n         %28 = OpAccessChain %17 %11 %27\n         %29 = OpLoad %6 %28\n         %30 = OpAccessChain %17 %11 %20\n         %31 = OpLoad %6 %30\n         %32 = OpFNegate %6 %31\n         %33 = OpAccessChain %17 %11 %16\n         %34 = OpLoad %6 %33\n         %35 = OpAccessChain %17 %11 %27\n         %36 = OpLoad %6 %35\n         %37 = OpAccessChain %17 %11 %23\n         %38 = OpLoad %6 %37\n         %39 = OpAccessChain %17 %11 %23\n         %40 = OpLoad %6 %39\n         %41 = OpAccessChain %17 %11 %27\n         %42 = OpLoad %6 %41\n         %43 = OpFNegate %6 %42\n         %44 = OpAccessChain %17 %11 %16\n         %45 = OpLoad %6 %44\n         %46 = OpAccessChain %17 %11 %20\n         %47 = OpLoad %6 %46\n         %48 = OpAccessChain %17 %11 %27\n         %49 = OpLoad %6 %48\n         %50 = OpFNegate %6 %49\n         %51 = OpAccessChain %17 %11 %23\n         %52 = OpLoad %6 %51\n         %53 = OpFNegate %6 %52\n         %54 = OpAccessChain %17 %11 %20\n         %55 = OpLoad %6 %54\n         %56 = OpFNegate %6 %55\n         %57 = OpAccessChain %17 %11 %16\n         %58 = OpLoad %6 %57\n         %62 = OpCompositeConstruct %7 %19 %22 %26 %29\n         %63 = OpCompositeConstruct %7 %32 %34 %36 %38\n         %64 = OpCompositeConstruct %7 %40 %43 %45 %47\n         %65 = OpCompositeConstruct %7 %50 %53 %56 %58\n         %66 = OpCompositeConstruct %59 %62 %63 %64 %65\n         %67 = OpVectorTimesMatrix %7 %14 %66\n               OpReturnValue %67\n               OpFunctionEnd\n\n======================================================================================================\n\n\nvec4 mulQ_mat4m(vec4 a,vec4 b)\n{\n    return mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b ) / mat4( 1,-1, 1,-1,\n                             1, 1,-1,-1,\n                            -1, 1, 1,-1,\n                             1, 1, 1, 1) * a;\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 67\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"mulQ_mat4m(vf4;vf4;\"\n               OpName %10 \"a\"\n               OpName %11 \"b\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 4\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeFunction %7 %8 %8\n         %21 = OpTypeMatrix %7 4\n         %22 = OpConstant %6 1\n         %23 = OpConstant %6 0\n         %45 = OpConstant %6 -1\n         %46 = OpConstantComposite %7 %22 %45 %22 %45\n         %47 = OpConstantComposite %7 %22 %22 %45 %45\n         %48 = OpConstantComposite %7 %45 %22 %22 %45\n         %49 = OpConstantComposite %7 %22 %22 %22 %22\n         %50 = OpConstantComposite %21 %46 %47 %48 %49\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %7 None %9\n         %10 = OpFunctionParameter %8\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %14 = OpLoad %7 %11\n         %15 = OpVectorShuffle %7 %14 %14 3 2 1 0\n         %16 = OpLoad %7 %11\n         %17 = OpVectorShuffle %7 %16 %16 2 3 0 1\n         %18 = OpLoad %7 %11\n         %19 = OpVectorShuffle %7 %18 %18 1 0 3 2\n         %20 = OpLoad %7 %11\n         %24 = OpCompositeExtract %6 %15 0\n         %25 = OpCompositeExtract %6 %15 1\n         %26 = OpCompositeExtract %6 %15 2\n         %27 = OpCompositeExtract %6 %15 3\n         %28 = OpCompositeExtract %6 %17 0\n         %29 = OpCompositeExtract %6 %17 1\n         %30 = OpCompositeExtract %6 %17 2\n         %31 = OpCompositeExtract %6 %17 3\n         %32 = OpCompositeExtract %6 %19 0\n         %33 = OpCompositeExtract %6 %19 1\n         %34 = OpCompositeExtract %6 %19 2\n         %35 = OpCompositeExtract %6 %19 3\n         %36 = OpCompositeExtract %6 %20 0\n         %37 = OpCompositeExtract %6 %20 1\n         %38 = OpCompositeExtract %6 %20 2\n         %39 = OpCompositeExtract %6 %20 3\n         %40 = OpCompositeConstruct %7 %24 %25 %26 %27\n         %41 = OpCompositeConstruct %7 %28 %29 %30 %31\n         %42 = OpCompositeConstruct %7 %32 %33 %34 %35\n         %43 = OpCompositeConstruct %7 %36 %37 %38 %39\n         %44 = OpCompositeConstruct %21 %40 %41 %42 %43\n         %51 = OpCompositeExtract %7 %44 0\n         %52 = OpCompositeExtract %7 %50 0\n         %53 = OpFDiv %7 %51 %52\n         %54 = OpCompositeExtract %7 %44 1\n         %55 = OpCompositeExtract %7 %50 1\n         %56 = OpFDiv %7 %54 %55\n         %57 = OpCompositeExtract %7 %44 2\n         %58 = OpCompositeExtract %7 %50 2\n         %59 = OpFDiv %7 %57 %58\n         %60 = OpCompositeExtract %7 %44 3\n         %61 = OpCompositeExtract %7 %50 3\n         %62 = OpFDiv %7 %60 %61\n         %63 = OpCompositeConstruct %21 %53 %56 %59 %62\n         %64 = OpLoad %7 %10\n         %65 = OpMatrixTimesVector %7 %63 %64\n               OpReturnValue %65\n               OpFunctionEnd\n\n======================================================================================================\n\n\nvec4 mulQ_mat4s(vec4 a,vec4 b)\n{\n    const mat4 s = mat4( 1,-1, 1,-1,\n                         1, 1,-1,-1,\n                        -1, 1, 1,-1,\n                         1, 1, 1, 1);\n\n    return mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b ) /s * a;\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 67\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"mulQ_mat4s(vf4;vf4;\"\n               OpName %10 \"a\"\n               OpName %11 \"b\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 4\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeFunction %7 %8 %8\n         %21 = OpTypeMatrix %7 4\n         %22 = OpConstant %6 1\n         %23 = OpConstant %6 0\n         %45 = OpConstant %6 -1\n         %46 = OpConstantComposite %7 %22 %45 %22 %45\n         %47 = OpConstantComposite %7 %22 %22 %45 %45\n         %48 = OpConstantComposite %7 %45 %22 %22 %45\n         %49 = OpConstantComposite %7 %22 %22 %22 %22\n         %50 = OpConstantComposite %21 %46 %47 %48 %49\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %7 None %9\n         %10 = OpFunctionParameter %8\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %14 = OpLoad %7 %11\n         %15 = OpVectorShuffle %7 %14 %14 3 2 1 0\n         %16 = OpLoad %7 %11\n         %17 = OpVectorShuffle %7 %16 %16 2 3 0 1\n         %18 = OpLoad %7 %11\n         %19 = OpVectorShuffle %7 %18 %18 1 0 3 2\n         %20 = OpLoad %7 %11\n         %24 = OpCompositeExtract %6 %15 0\n         %25 = OpCompositeExtract %6 %15 1\n         %26 = OpCompositeExtract %6 %15 2\n         %27 = OpCompositeExtract %6 %15 3\n         %28 = OpCompositeExtract %6 %17 0\n         %29 = OpCompositeExtract %6 %17 1\n         %30 = OpCompositeExtract %6 %17 2\n         %31 = OpCompositeExtract %6 %17 3\n         %32 = OpCompositeExtract %6 %19 0\n         %33 = OpCompositeExtract %6 %19 1\n         %34 = OpCompositeExtract %6 %19 2\n         %35 = OpCompositeExtract %6 %19 3\n         %36 = OpCompositeExtract %6 %20 0\n         %37 = OpCompositeExtract %6 %20 1\n         %38 = OpCompositeExtract %6 %20 2\n         %39 = OpCompositeExtract %6 %20 3\n         %40 = OpCompositeConstruct %7 %24 %25 %26 %27\n         %41 = OpCompositeConstruct %7 %28 %29 %30 %31\n         %42 = OpCompositeConstruct %7 %32 %33 %34 %35\n         %43 = OpCompositeConstruct %7 %36 %37 %38 %39\n         %44 = OpCompositeConstruct %21 %40 %41 %42 %43\n         %51 = OpCompositeExtract %7 %44 0\n         %52 = OpCompositeExtract %7 %50 0\n         %53 = OpFDiv %7 %51 %52\n         %54 = OpCompositeExtract %7 %44 1\n         %55 = OpCompositeExtract %7 %50 1\n         %56 = OpFDiv %7 %54 %55\n         %57 = OpCompositeExtract %7 %44 2\n         %58 = OpCompositeExtract %7 %50 2\n         %59 = OpFDiv %7 %57 %58\n         %60 = OpCompositeExtract %7 %44 3\n         %61 = OpCompositeExtract %7 %50 3\n         %62 = OpFDiv %7 %60 %61\n         %63 = OpCompositeConstruct %21 %53 %56 %59 %62\n         %64 = OpLoad %7 %10\n         %65 = OpMatrixTimesVector %7 %63 %64\n               OpReturnValue %65\n               OpFunctionEnd\n\n======================================================================================================\n\n\nvec4 mulQ_mat4m2(vec4 a,vec4 b)\n{\n    return matrixCompMult(\n           mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b ), \n           mat4( 1,-1, 1,-1,\n                 1, 1,-1,-1,\n                -1, 1, 1,-1,\n                 1, 1, 1, 1)) * a;\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 67\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"mulQ_mat4m2(vf4;vf4;\"\n               OpName %10 \"a\"\n               OpName %11 \"b\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 4\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeFunction %7 %8 %8\n         %21 = OpTypeMatrix %7 4\n         %22 = OpConstant %6 1\n         %23 = OpConstant %6 0\n         %45 = OpConstant %6 -1\n         %46 = OpConstantComposite %7 %22 %45 %22 %45\n         %47 = OpConstantComposite %7 %22 %22 %45 %45\n         %48 = OpConstantComposite %7 %45 %22 %22 %45\n         %49 = OpConstantComposite %7 %22 %22 %22 %22\n         %50 = OpConstantComposite %21 %46 %47 %48 %49\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %7 None %9\n         %10 = OpFunctionParameter %8\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %14 = OpLoad %7 %11\n         %15 = OpVectorShuffle %7 %14 %14 3 2 1 0\n         %16 = OpLoad %7 %11\n         %17 = OpVectorShuffle %7 %16 %16 2 3 0 1\n         %18 = OpLoad %7 %11\n         %19 = OpVectorShuffle %7 %18 %18 1 0 3 2\n         %20 = OpLoad %7 %11\n         %24 = OpCompositeExtract %6 %15 0\n         %25 = OpCompositeExtract %6 %15 1\n         %26 = OpCompositeExtract %6 %15 2\n         %27 = OpCompositeExtract %6 %15 3\n         %28 = OpCompositeExtract %6 %17 0\n         %29 = OpCompositeExtract %6 %17 1\n         %30 = OpCompositeExtract %6 %17 2\n         %31 = OpCompositeExtract %6 %17 3\n         %32 = OpCompositeExtract %6 %19 0\n         %33 = OpCompositeExtract %6 %19 1\n         %34 = OpCompositeExtract %6 %19 2\n         %35 = OpCompositeExtract %6 %19 3\n         %36 = OpCompositeExtract %6 %20 0\n         %37 = OpCompositeExtract %6 %20 1\n         %38 = OpCompositeExtract %6 %20 2\n         %39 = OpCompositeExtract %6 %20 3\n         %40 = OpCompositeConstruct %7 %24 %25 %26 %27\n         %41 = OpCompositeConstruct %7 %28 %29 %30 %31\n         %42 = OpCompositeConstruct %7 %32 %33 %34 %35\n         %43 = OpCompositeConstruct %7 %36 %37 %38 %39\n         %44 = OpCompositeConstruct %21 %40 %41 %42 %43\n         %51 = OpCompositeExtract %7 %44 0\n         %52 = OpCompositeExtract %7 %50 0\n         %53 = OpFMul %7 %51 %52\n         %54 = OpCompositeExtract %7 %44 1\n         %55 = OpCompositeExtract %7 %50 1\n         %56 = OpFMul %7 %54 %55\n         %57 = OpCompositeExtract %7 %44 2\n         %58 = OpCompositeExtract %7 %50 2\n         %59 = OpFMul %7 %57 %58\n         %60 = OpCompositeExtract %7 %44 3\n         %61 = OpCompositeExtract %7 %50 3\n         %62 = OpFMul %7 %60 %61\n         %63 = OpCompositeConstruct %21 %53 %56 %59 %62\n         %64 = OpLoad %7 %10\n         %65 = OpMatrixTimesVector %7 %63 %64\n               OpReturnValue %65\n               OpFunctionEnd\n\n======================================================================================================\n\n\nvec4 mulQ_mat4m3(vec4 a,vec4 b)\n{\n    return a * matrixCompMult(\n           mat4( 1, 1,-1, 1,\n                -1, 1, 1, 1,\n                 1,-1, 1, 1,\n                -1,-1,-1, 1),\n           mat4( b.wzyx,\n                 b.zwxy,\n                 b.yxwz,\n                 b));\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 67\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"mulQ_mat4m3(vf4;vf4;\"\n               OpName %10 \"a\"\n               OpName %11 \"b\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 4\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeFunction %7 %8 %8\n         %15 = OpTypeMatrix %7 4\n         %16 = OpConstant %6 1\n         %17 = OpConstant %6 -1\n         %18 = OpConstantComposite %7 %16 %16 %17 %16\n         %19 = OpConstantComposite %7 %17 %16 %16 %16\n         %20 = OpConstantComposite %7 %16 %17 %16 %16\n         %21 = OpConstantComposite %7 %17 %17 %17 %16\n         %22 = OpConstantComposite %15 %18 %19 %20 %21\n         %30 = OpConstant %6 0\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %7 None %9\n         %10 = OpFunctionParameter %8\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %14 = OpLoad %7 %10\n         %23 = OpLoad %7 %11\n         %24 = OpVectorShuffle %7 %23 %23 3 2 1 0\n         %25 = OpLoad %7 %11\n         %26 = OpVectorShuffle %7 %25 %25 2 3 0 1\n         %27 = OpLoad %7 %11\n         %28 = OpVectorShuffle %7 %27 %27 1 0 3 2\n         %29 = OpLoad %7 %11\n         %31 = OpCompositeExtract %6 %24 0\n         %32 = OpCompositeExtract %6 %24 1\n         %33 = OpCompositeExtract %6 %24 2\n         %34 = OpCompositeExtract %6 %24 3\n         %35 = OpCompositeExtract %6 %26 0\n         %36 = OpCompositeExtract %6 %26 1\n         %37 = OpCompositeExtract %6 %26 2\n         %38 = OpCompositeExtract %6 %26 3\n         %39 = OpCompositeExtract %6 %28 0\n         %40 = OpCompositeExtract %6 %28 1\n         %41 = OpCompositeExtract %6 %28 2\n         %42 = OpCompositeExtract %6 %28 3\n         %43 = OpCompositeExtract %6 %29 0\n         %44 = OpCompositeExtract %6 %29 1\n         %45 = OpCompositeExtract %6 %29 2\n         %46 = OpCompositeExtract %6 %29 3\n         %47 = OpCompositeConstruct %7 %31 %32 %33 %34\n         %48 = OpCompositeConstruct %7 %35 %36 %37 %38\n         %49 = OpCompositeConstruct %7 %39 %40 %41 %42\n         %50 = OpCompositeConstruct %7 %43 %44 %45 %46\n         %51 = OpCompositeConstruct %15 %47 %48 %49 %50\n         %52 = OpCompositeExtract %7 %22 0\n         %53 = OpCompositeExtract %7 %51 0\n         %54 = OpFMul %7 %52 %53\n         %55 = OpCompositeExtract %7 %22 1\n         %56 = OpCompositeExtract %7 %51 1\n         %57 = OpFMul %7 %55 %56\n         %58 = OpCompositeExtract %7 %22 2\n         %59 = OpCompositeExtract %7 %51 2\n         %60 = OpFMul %7 %58 %59\n         %61 = OpCompositeExtract %7 %22 3\n         %62 = OpCompositeExtract %7 %51 3\n         %63 = OpFMul %7 %61 %62\n         %64 = OpCompositeConstruct %15 %54 %57 %60 %63\n         %65 = OpVectorTimesMatrix %7 %14 %64\n               OpReturnValue %65\n               OpFunctionEnd\n\n======================================================================================================\nvec4 mulQ_mat4v(vec4 a,vec4 b)\n{\n    return a * mat4( b.wzyx * vec4( 1, 1,-1, 1),\n                     b.zwxy * vec4(-1, 1, 1, 1),\n                     b.yxwz * vec4( 1,-1, 1, 1),\n                     b      * vec4(-1,-1,-1, 1));\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 57\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"mulQ_mat4v(vf4;vf4;\"\n               OpName %10 \"a\"\n               OpName %11 \"b\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 4\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeFunction %7 %8 %8\n         %17 = OpConstant %6 1\n         %18 = OpConstant %6 -1\n         %19 = OpConstantComposite %7 %17 %17 %18 %17\n         %23 = OpConstantComposite %7 %18 %17 %17 %17\n         %27 = OpConstantComposite %7 %17 %18 %17 %17\n         %30 = OpConstantComposite %7 %18 %18 %18 %17\n         %32 = OpTypeMatrix %7 4\n         %33 = OpConstant %6 0\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %7 None %9\n         %10 = OpFunctionParameter %8\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %14 = OpLoad %7 %10\n         %15 = OpLoad %7 %11\n         %16 = OpVectorShuffle %7 %15 %15 3 2 1 0\n         %20 = OpFMul %7 %16 %19\n         %21 = OpLoad %7 %11\n         %22 = OpVectorShuffle %7 %21 %21 2 3 0 1\n         %24 = OpFMul %7 %22 %23\n         %25 = OpLoad %7 %11\n         %26 = OpVectorShuffle %7 %25 %25 1 0 3 2\n         %28 = OpFMul %7 %26 %27\n         %29 = OpLoad %7 %11\n         %31 = OpFMul %7 %29 %30\n         %34 = OpCompositeExtract %6 %20 0\n         %35 = OpCompositeExtract %6 %20 1\n         %36 = OpCompositeExtract %6 %20 2\n         %37 = OpCompositeExtract %6 %20 3\n         %38 = OpCompositeExtract %6 %24 0\n         %39 = OpCompositeExtract %6 %24 1\n         %40 = OpCompositeExtract %6 %24 2\n         %41 = OpCompositeExtract %6 %24 3\n         %42 = OpCompositeExtract %6 %28 0\n         %43 = OpCompositeExtract %6 %28 1\n         %44 = OpCompositeExtract %6 %28 2\n         %45 = OpCompositeExtract %6 %28 3\n         %46 = OpCompositeExtract %6 %31 0\n         %47 = OpCompositeExtract %6 %31 1\n         %48 = OpCompositeExtract %6 %31 2\n         %49 = OpCompositeExtract %6 %31 3\n         %50 = OpCompositeConstruct %7 %34 %35 %36 %37\n         %51 = OpCompositeConstruct %7 %38 %39 %40 %41\n         %52 = OpCompositeConstruct %7 %42 %43 %44 %45\n         %53 = OpCompositeConstruct %7 %46 %47 %48 %49\n         %54 = OpCompositeConstruct %32 %50 %51 %52 %53\n         %55 = OpVectorTimesMatrix %7 %14 %54\n               OpReturnValue %55\n               OpFunctionEnd\n               \n=============================================================================================\n\n\nvec4 mulQ_xd(vec4 a, vec4 b)\n{\n    vec3 u = a.xyz, v = b.xyz;\n    return a.w * b + vec4( u * b.w + cross(u,v) ,  - dot(u,v) );\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 47\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"mulQ_xd(vf4;vf4;\"\n               OpName %10 \"a\"\n               OpName %11 \"b\"\n               OpName %16 \"u\"\n               OpName %19 \"v\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 4\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeFunction %7 %8 %8\n         %14 = OpTypeVector %6 3\n         %15 = OpTypePointer Function %14\n         %22 = OpTypeInt 32 0\n         %23 = OpConstant %22 3\n         %24 = OpTypePointer Function %6\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %7 None %9\n         %10 = OpFunctionParameter %8\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %16 = OpVariable %15 Function\n         %19 = OpVariable %15 Function\n         %17 = OpLoad %7 %10\n         %18 = OpVectorShuffle %14 %17 %17 0 1 2\n               OpStore %16 %18\n         %20 = OpLoad %7 %11\n         %21 = OpVectorShuffle %14 %20 %20 0 1 2\n               OpStore %19 %21\n         %25 = OpAccessChain %24 %10 %23\n         %26 = OpLoad %6 %25\n         %27 = OpLoad %7 %11\n         %28 = OpVectorTimesScalar %7 %27 %26\n         %29 = OpLoad %14 %16\n         %30 = OpAccessChain %24 %11 %23\n         %31 = OpLoad %6 %30\n         %32 = OpVectorTimesScalar %14 %29 %31\n         %33 = OpLoad %14 %16\n         %34 = OpLoad %14 %19\n         %35 = OpExtInst %14 %1 Cross %33 %34\n         %36 = OpFAdd %14 %32 %35\n         %37 = OpLoad %14 %16\n         %38 = OpLoad %14 %19\n         %39 = OpDot %6 %37 %38\n         %40 = OpFNegate %6 %39\n         %41 = OpCompositeExtract %6 %36 0\n         %42 = OpCompositeExtract %6 %36 1\n         %43 = OpCompositeExtract %6 %36 2\n         %44 = OpCompositeConstruct %7 %41 %42 %43 %40\n         %45 = OpFAdd %7 %28 %44\n               OpReturnValue %45\n               OpFunctionEnd\n\n=============================================================================================\n\nmat3 eulerAngleT(vec3 a)\n{\n    vec3 s = sin(a), c = cos(a);\n    return mat3( c.z, s.z,   0,\n                -s.z, c.z,   0,\n                   0,   0,   1 ) *\n                   \n           mat3( c.y,   0,-s.y,\n                   0,   1,   0,\n                 s.y,   0, c.y ) *\n                 \n           mat3(   1,   0,   0,\n                   0, c.x, s.x,\n                   0,-s.x, c.x );\n}\n\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos Glslang Reference Front End; 1\n; Bound: 69\n; Schema: 0\n               OpCapability Shader\n          %1 = OpExtInstImport \"GLSL.std.450\"\n               OpMemoryModel Logical GLSL450\n               OpEntryPoint Fragment %4 \"main\"\n               OpExecutionMode %4 OriginLowerLeft\n               OpSource GLSL 110\n               OpName %4 \"main\"\n               OpName %12 \"eulerAngleT(vf3;\"\n               OpName %11 \"a\"\n               OpName %14 \"s\"\n               OpName %17 \"c\"\n          %2 = OpTypeVoid\n          %3 = OpTypeFunction %2\n          %6 = OpTypeFloat 32\n          %7 = OpTypeVector %6 3\n          %8 = OpTypePointer Function %7\n          %9 = OpTypeMatrix %7 3\n         %10 = OpTypeFunction %9 %8\n         %20 = OpTypeInt 32 0\n         %21 = OpConstant %20 2\n         %22 = OpTypePointer Function %6\n         %27 = OpConstant %6 0\n         %33 = OpConstant %6 1\n         %38 = OpConstant %20 1\n         %53 = OpConstant %20 0\n          %4 = OpFunction %2 None %3\n          %5 = OpLabel\n               OpFunctionEnd\n         %12 = OpFunction %9 None %10\n         %11 = OpFunctionParameter %8\n         %13 = OpLabel\n         %14 = OpVariable %8 Function\n         %17 = OpVariable %8 Function\n         %15 = OpLoad %7 %11\n         %16 = OpExtInst %7 %1 Sin %15\n               OpStore %14 %16\n         %18 = OpLoad %7 %11\n         %19 = OpExtInst %7 %1 Cos %18\n               OpStore %17 %19\n         %23 = OpAccessChain %22 %17 %21\n         %24 = OpLoad %6 %23\n         %25 = OpAccessChain %22 %14 %21\n         %26 = OpLoad %6 %25\n         %28 = OpAccessChain %22 %14 %21\n         %29 = OpLoad %6 %28\n         %30 = OpFNegate %6 %29\n         %31 = OpAccessChain %22 %17 %21\n         %32 = OpLoad %6 %31\n         %34 = OpCompositeConstruct %7 %24 %26 %27\n         %35 = OpCompositeConstruct %7 %30 %32 %27\n         %36 = OpCompositeConstruct %7 %27 %27 %33\n         %37 = OpCompositeConstruct %9 %34 %35 %36\n         %39 = OpAccessChain %22 %17 %38\n         %40 = OpLoad %6 %39\n         %41 = OpAccessChain %22 %14 %38\n         %42 = OpLoad %6 %41\n         %43 = OpFNegate %6 %42\n         %44 = OpAccessChain %22 %14 %38\n         %45 = OpLoad %6 %44\n         %46 = OpAccessChain %22 %17 %38\n         %47 = OpLoad %6 %46\n         %48 = OpCompositeConstruct %7 %40 %27 %43\n         %49 = OpCompositeConstruct %7 %27 %33 %27\n         %50 = OpCompositeConstruct %7 %45 %27 %47\n         %51 = OpCompositeConstruct %9 %48 %49 %50\n         %52 = OpMatrixTimesMatrix %9 %37 %51\n         %54 = OpAccessChain %22 %17 %53\n         %55 = OpLoad %6 %54\n         %56 = OpAccessChain %22 %14 %53\n         %57 = OpLoad %6 %56\n         %58 = OpAccessChain %22 %14 %53\n         %59 = OpLoad %6 %58\n         %60 = OpFNegate %6 %59\n         %61 = OpAccessChain %22 %17 %53\n         %62 = OpLoad %6 %61\n         %63 = OpCompositeConstruct %7 %33 %27 %27\n         %64 = OpCompositeConstruct %7 %27 %55 %57\n         %65 = OpCompositeConstruct %7 %27 %60 %62\n         %66 = OpCompositeConstruct %9 %63 %64 %65\n         %67 = OpMatrixTimesMatrix %9 %52 %66\n               OpReturnValue %67\n               OpFunctionEnd\n\n*/","name":"Common","description":"","type":"common"}]}