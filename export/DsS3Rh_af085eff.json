{"ver":"0.1","info":{"id":"DsS3Rh","date":"1667217165","viewed":86,"name":"Haru86_Sierpiński triangle_Ray","username":"Haru86_","description":"Haru86_Sierpiński triangle_Ray","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 330\n// ShaderToy --> OpenGL/GLSL Convert Preprocessor /////////////////////////////\n#define DRAW_ON_SHADERTOY\n\n#ifdef DRAW_ON_SHADERTOY\n#define _resolution iResolution\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n#define _time iTime\n#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\nconst int _RenderingTarget = 1;\nconst float _LeaveStartTime = 1.0;\nconst float _Alpha = 1.0;\n#else\nuniform float _time;\nuniform vec2 _resolution;\nuniform float _RenderingTarget;\nuniform vec3 _WorldCameraPos;\nuniform vec3 _WorldCameraCenter;\n\nuniform float _LeaveStartTime;\nuniform float _Alpha;\n\nin vec2 uv;\n#endif\n\n// Shared Preprocessor ////////////////////////////////////////////////////////\n#define pi 3.14159265\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin 0.001\n#define tmax 30.0\n#define ldir normalize(vec3(1.0,1.0,-1.0))\n\n// Gloabal Valiable\nvec3 g_ro;\nint CameraIndex;\nfloat ln; // LoopNum\n\n// Useful Function ////////////////////////////////////////////////////////////\n\nstruct mapr // MapResult\n{\n   float d; // Distance\n   bool  hit;\n   int   m; // MaterialType\n            // 0: Debug\n   vec3 vPos;\n   vec3 mask;\n   float i;\n   float t;\n   float acc;\n   vec3 vCol;\n   float flash;\n};\n\nvoid compm(inout mapr mr,float d,int mt,bool IsMin) // CompareMap\n{\n    if(IsMin)\n    {\n        if(d<mr.d) mr = mapr(d,false,mt,vec3(0.0),vec3(0.0),0.0,0.0,0.0,vec3(0.0),0.0);\n        if(mr.d<dmin) mr.hit=true; \n    }\n    else\n    {\n        mr.d = max(mr.d, -d);\n        /*if(d>mr.d) mr = mapr(d,false,mt,vec3(0.0),vec3(0.0),0.0,0.0,0.0,vec3(0.0),0.0);\n        if(mr.d<dmin) mr.hit=true; */\n    }\n}\n\nvec3 trs(vec3 p,vec3 s,vec3 r,vec3 t)\n{\n    p+=t; \n    p.yz*=rot(s.x);p.xz*=rot(s.y);p.xy*=rot(s.z);\n    p*=s;\n    \n    return p;\n}\n\n// Noise Function /////////////////////////////////////////////////////////////\nvec2 pmod(vec2 p,float n){\n  float np = 2.*pi/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p.xy)*vec2(cos(r),sin(r));\n}\n// Distance Function\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\n// https://www.shadertoy.com/view/3ltBD8\nvec4 tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<12;i++){\n        if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n        if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n        if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;       \n        z *= scale;\n        z.xyz += offset*(1.0-scale);\n    }\n    return vec4(col,(cube(z.xyz,vec3(1.5)))/z.w);\n}\n\nfloat Cube(vec3 p,float s)\n{\n    p=abs(p);\n    return length(max(p-vec3(s),0.0));\n}\n\nfloat Triangle(vec3 p,vec3 offset,float scale)\n{\n    vec4 z=vec4(p.xyz,1.0);\n    int count=10;\n    \n    for(int i=0;i<count;i++)\n    {\n        if(z.x+z.y<0.0)z.xy=-z.yx;\n        if(z.x+z.z<0.0)z.xz=-z.zx;\n        if(z.y+z.z<0.0)z.yz=-z.yz;\n        z*=scale;\n        z.xyz-=offset*(scale-1.0);\n    }\n    return Cube(z.xyz,1.0)/z.w;\n    //return (length(z.xyz)-1.5)/z.w;\n}\n\n// Ray Function ///////////////////////////////////////////////////////////////\nmapr map(vec3 p)\n{\n    mapr mr;\n    mr.d=1000.0;\n    mr.hit=false;\n    mr.m=-1;\n    \n    {\n        vec3 lp = p;\n        \n        lp.xz=pmod(lp.xz,32.0);\n        lp.x-=2.1;\n        \n        lp=abs(lp)-0.5;\n        \n        lp.yz*=rot(0.5);\n        lp.xy*=rot(0.15);\n        lp.xz*=rot(0.5);\n        \n        lp.yz*=rot(pi/2.0);\n        \n        lp=abs(lp)-0.25;\n        lp.z=abs(lp.z)-0.5;\n        lp.x=abs(lp.x)-0.75;\n        lp.y=abs(lp.y)-0.75;\n        \n        lp.x=abs(lp.x)-0.65;\n        \n        lp.x = dot(lp,lp);\n        \n        float k = 1.4;\n        lp=mod(lp,k)-k*0.5;\n        \n        compm(mr,Triangle(lp,vec3(1.24),1.8), 0, true);\n       \n        {compm(mr,abs(p.y)-0.5,0,false);}\n        \n        vec4 sd = tetcol(lp,vec3(1),1.8,vec3(0.));\n        float d= sd.w;\n        vec3 col = 1.-0.1*sd.xyz-0.3;\n        col *= exp(-2.5*d)*2.;\n        mr.vCol += col;\n    }\n    \n    {\n        \n        vec3 lp = trs(p, vec3(1.5), vec3(0.0) , vec3(0.0));\n        compm(mr,Triangle(lp,vec3(1.24),1.8), 1, true);\n        \n        vec4 sd = tetcol(lp,vec3(1),1.8,vec3(0.));\n        float d= sd.w;\n        vec3 col = 1.-0.1*sd.xyz-0.3;\n        col *= exp(-2.5*d)*2.;\n        mr.vCol += col;\n    } \n    \n    return mr;\n}\n\nvec3 gn(vec3 p)\n{\n    vec2 e=vec2(0.001,0.0);\n    return normalize(vec3(\n        map(p+e.xyy).d-map(p-e.xyy).d,\n        map(p+e.yxy).d-map(p-e.yxy).d,\n        map(p+e.yyx).d-map(p-e.yyx).d\n    ));\n}\n\n// RayCast\nmapr Raycast(vec3 ro, vec3 rd)\n{\n    mapr mr;float i=0.0,t=0.0,acc=0.0,flash=0.0;mr.vCol=vec3(0.0);mr.flash=0.0;\n    for(;++i<64.0;){\n        mr=map(ro+rd*( t+=mr.d*0.75 ));if(mr.d<dmin||t>tmax)break;acc+=exp(-3.0*mr.d);\n        if(mod(distance(vec3(0.0),ro+rd*t)-_time*10.0,10.0)<1.0){flash+=exp(-3.0*mr.d);}\n    }\n    \n    mr.i=i; mr.t=t;mr.acc=acc;mr.flash=flash;\n \n    return mr;\n}\n \nfloat calcAo(in vec3 p,in vec3 n)\n{\n    float k=1.0, occ=0.0;\n    for(int i=0; i<5; i++)\n    {\n        float len = 0.15 + float(i) * 0.15;\n        float d = map(n*len + p).d;\n        occ += (len - d) * k;\n        k*=0.5;\n    }\n    \n    return clamp(1.0-occ, 0.0, 1.0);\n}\n\n// Main ///////////////////////////////////////////////////////////////////////\nvoid main()\n{\nif(_RenderingTarget==2) // ZTest\n{\n    gl_FragColor = vec4(vec3(0.0),1.0);\n}\nelse\n{\n#ifdef DRAW_ON_SHADERTOY\n    vec2 st=(gl_FragCoord.xy*2.-_resolution.xy)/min(_resolution.x,_resolution.y);\n#else\n    vec2 st=uv*2.0-1.0;\n    st.x*=(_resolution.x/_resolution.y);\n#endif \n    vec3 ro=vec3(cos(_time)*3.0,0.0,sin(_time)*3.0),ta=vec3(0.0,0.0,0.0);\n    vec3 col = vec3(0.0),cdir=normalize(ta-ro),cside=normalize(cross(vec3(0.0,1.0,0.0),cdir)),\n    cup=normalize(cross(cdir,cside)),rd=normalize(st.x*cside+st.y*cup+1.0*cdir);ln = 64.0;\n    mapr mr = Raycast(ro,rd);\n    //if(mr.hit)\n    {\n        if(mr.m == 0) // Debug\n        {\n            //col = vec3(1.0)*20.0/mr.i;\n\n            vec3 p = ro + rd * mr.t;\n            vec3 n = gn(p);\n            float ao = calcAo(p, n);\n            float diff = max(0.0, dot(ldir,n));\n            col = vec3(0.615, 0.8, 0.88) *10.0/mr.i * mr.acc*0.1 + mr.vCol * mr.acc*0.01;\n            col += vec3(1.0)*mr.flash * 0.015;\n            \n        }\n        else if(mr.m == 1)\n        {\n            //col = vec3(0.615, 0.8, 0.88)*20.0/mr.i;\n            \n            vec3 p = ro + rd * mr.t;\n            vec3 n = gn(p);\n            float ao = calcAo(p, n);\n            float diff = max(0.0, dot(ldir,n));\n            col = vec3(0.615, 0.8, 0.88) *10.0/mr.i + mr.vCol * mr.acc*0.05;\n            col += vec3(1.0)*mr.flash * 0.015;\n        }\n    }\n    \n     //vec3 fog = mix(vec3(0.96), vec3(0.24), -rd.y*0.5 + 0.5);\n     //col = mix(col, fog*sqrt(fog)*1.2, smoothstep(0.0, 0.95, mr.t/60.0));\n    \n    gl_FragColor = vec4(col,_Alpha);\n}\n\n}","name":"Image","description":"","type":"image"}]}