{"ver":"0.1","info":{"id":"msKfDy","date":"1706853713","viewed":125,"name":"Black hole WIP","username":"PaulRV","description":"Sky texture is not available. If you want you can add yours in iChannel0 in the \"Buffer A\". This just uses path tracing and uses an almost weightless particle as photons (approximation). Bloom code isn't mine.\nUpdate: made code look nicer.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["space","pathtracing","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0)));\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0)));\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0)));\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0)));\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0)));\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    \n    color += GetBloom(uv) * 0.1;\n    \n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n\n    //fragColor = vec4(ColorFetch(uv),1);\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.1415;\nconst vec3 v0 = vec3(0);\nconst vec3 v1 = vec3(1);\nconst float fov = 75.0;\nconst float invscreenDist = 1.0/(cos(PI*fov/360.0)/sin(PI*fov/360.0));\nconst float gConst = 1.0;\nconst float mass = 1.5;\nconst float schradius = 2.0*gConst*mass;\nconst HitInfo noInfo = HitInfo(-1.0, v0);\nconst mat3x2 hashmat = mat3x2(vec2(127.1,311.7), vec2(269.5,183.3), vec2(419.2,371.9));\nconst vec2[] aaOffsets = vec2[4](vec2(-.25,-.25), vec2(-.25,.25), vec2(.25,-.25), vec2(.25,.25));\nconst vec3 camPos = vec3(0,0,10);\n\nconst float threshold = min(schradius,0.25*dot(camPos,camPos));\n\nvec3 hash3( vec2 p ) {\n\treturn fract(sin(p * hashmat)*43758.5453);\n}\n\nfloat voronoise( in vec2 p){\n\t//vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 fl = p - f;\n    \n\tvec2 a = vec2(0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3(fl +g );;\n\t\tvec2  d = g -f + o.xy;\n\t\tfloat w = 1.0-smoothstep(0.0,1.414,dot(d,d));\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\n\nvec2 viewVectorToUV(vec3 dir){ \n    //front is -z direction, y is up, x is right\n    //wr \n    return vec2(.5*atan(dir.x, -1.0*dir.z)/PI, .5+atan(dir.y,length(dir.xz))/PI);\n}\n\nvec3 polToView(vec2 pol){ \n    //front is -z direction, y is up, x is right\n    vec2 p = pol * vec2(-PI,PI);\n    return normalize(vec3(sin(p.x)*cos(p.y), sin(p.y), -cos(p.x)*cos(p.y)));\n}\n\nvec3 skyBox(vec3 dir){\n    return texture(iChannel0, vec2(mod(.75,1.0),0)+viewVectorToUV(dir)).xyz;\n}\n\nRay scaleRayAround(in Ray ray, in vec3 scale, in vec3 center){\n    return Ray((ray.origin - center) * scale + center, normalize(ray.dir * scale));\n}\n\nRay RayWorldToUnit(in Ray ray, in vec3 scale, in vec3 pos){\n    return Ray((ray.origin - pos) / scale, normalize(ray.dir/ scale));\n}\n\nvec3 sphereNormAtPoint(Object s, vec3 point){\n    return normalize(point - s.tf.pos);\n}\n\nHitInfo raySphereIntersect(in Ray r, vec3 camDir, in Object obj){\n    if (dot(camDir, obj.tf.pos-r.origin)<= 0.0){\n        return noInfo;\n    }\n    Ray newr = RayWorldToUnit(r, obj.tf.scale, obj.tf.pos);\n    float b = dot(newr.dir, newr.origin);\n    float delta = b*b - dot(newr.origin, newr.origin)+1.0;\n    if (delta < 0.0){\n        return noInfo;\n    }\n    vec3 hitpoint = -(b + sqrt(delta))*newr.dir + newr.origin;\n    hitpoint = hitpoint*obj.tf.scale + obj.tf.pos;\n    float dist = distance(hitpoint, r.origin);\n    return HitInfo(dist, hitpoint);\n}\n\nHitInfo rayPlaneIntersect(in Ray r, vec3 camDir, in Object obj){\n    float denom = dot(-obj.tf.normal, r.dir);\n    if (abs(denom) > 0.000001) {\n        vec3 p0l0 = obj.tf.pos - r.origin;\n        float t = dot(p0l0, -obj.tf.normal) / denom;\n        if (t>0.0){\n            return HitInfo(t, r.origin + t*r.dir);\n        }\n    }\n    return noInfo;\n}\n\nHitInfo rayDiskIntersect(in Ray r, vec3 camDir, in Object obj){\n    HitInfo planeInfo = rayPlaneIntersect(r, camDir, obj);\n    if (planeInfo.dist > 0.0){\n        //for disks, tf.x = scaling as if a circle, tf.y = size of the inside\n        //circle, scaled like the outside boundary, as a percentage of the total disk\n        //0 = full disk, 0.99 very thin disk\n        float sqdist = dot(planeInfo.hitpoint - obj.tf.pos,planeInfo.hitpoint - obj.tf.pos);\n        if (sqdist < obj.tf.scale.x*obj.tf.scale.x){\n            if (sqdist > obj.tf.scale.y*obj.tf.scale.y){\n                return planeInfo;\n            }\n        }\n    }\n    return noInfo;\n}\n\nvec3 colorRay(Ray ray, HitInfo info, Object[2] objects){\n    vec4 thing = vec4(info.hitpoint - objects[0].tf.pos,0);\n    thing.w = dot(thing.xyz,thing.xyz);\n    if (info.dist > 0.0){\n        return (v1/*ec3(1.6,.95,.6)*/ * (0.4+1.2*voronoise(vec2(70.0*cos(PI*viewVectorToUV(-thing.xyz).x)-iTime, thing.w)) )\n               )*vec3(min(5.0,4.0/pow((thing.w-objects[1].tf.scale.y*objects[1].tf.scale.y),.5)));//Brightness\n    }\n    return v0;\n}\n\nvec3 marching(Ray inRay, vec3 camPos, vec3 camDir, Object[2] objects, int iterations){\n    Ray movingRay = inRay;\n    float dt = 0.02;\n    vec3 distToSphere;\n    vec3 dirToSphere;\n    float sqdist = 1.0;\n    float forceNorm = 0.0;\n    int i = 0;\n    HitInfo info;\n    //return v1;\n    //while (i < int(float(iterations) * (0.3+0.3*sqdist))){\n    for (i; i < int(float(iterations) * (0.3+0.3*sqdist)); i++){\n        distToSphere = objects[0].tf.pos-movingRay.origin;\n        dirToSphere = normalize(distToSphere);\n        sqdist = dot(distToSphere, distToSphere);\n        if (i>=int(float(iterations) * (0.3+0.3*sqdist))+1){\n            //return movingRay.dir;\n            //return skyBox(inRay.dir);\n            return pow(skyBox(movingRay.dir),vec3(.5));\n        }\n        \n        \n        dt = 0.01*sqdist;\n        forceNorm = 0.01*gConst*mass;\n        movingRay.dir = normalize(movingRay.dir + forceNorm*dirToSphere);\n        movingRay.origin += movingRay.dir*dt;\n        \n        if (sqdist <= threshold){\n            return v0;\n        }\n        \n        info = rayDiskIntersect(movingRay, camDir, objects[1]);\n        if (info.dist <= 1.2*dt && info.dist > 0.0){\n            //return movingRay.dir;\n            return colorRay(movingRay,info, objects);\n        }\n        //i++;\n    }\n    //if (sqdist >= 0.0){\n    //    return colorRay(movingRay,info, objects);\n    //}\n    return v0;\n}\n\n//const vec3 camDir = normalize(vec3(2,0,-1));\n//const vec3 camDir = normalize(vec3(0,0,-1));\n\nconst vec4 screen = vec4(-16.0/9.0, -1.0, 16.0/9.0, 1.0);\nconst Object[] objects = Object[]( Object(Transform(v0, 0.5*v1, 0.01*v1), 1),\n                             Object(Transform(v0, vec3(7,schradius*.5,0), normalize(vec3(0.05,1,0.05))),2));\nRay ray;\nvec2 uv;\nvec3 cam_right;\nvec3 cam_up;\n//const vec3 cam_right = normalize(cross(camDir, vec3(0,1,0)))*invscreenDist;\n//const vec3 cam_up = normalize(cross(cam_right, camDir))*invscreenDist;\nvec3 dire;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 inviResolution = 1.0/iResolution.xy;\n    vec3 camDir = polToView(vec2(-1,.5)+vec2(2.0,-1.0)*iMouse.xy*inviResolution.xy);\n    cam_right = normalize(cross(camDir, vec3(0,1,0)))*invscreenDist;\n    cam_up = normalize(cross(cam_right, camDir))*invscreenDist;\n    //camPos = vec3(0,0.05,15.0/(1.0+0.5*iTime));\n    vec3 color;\n    for (int i = 0; i < 1; i++){ //set max i to 4 for anti-aliasing, and multiply \"color\" by .25 on line 196\n        uv = (fragCoord+aaOffsets[i])*inviResolution.xy;\n        dire = normalize(camDir\n               + (cam_right * mix(screen.x, screen.z,uv.x))//(uv.x * (screen.z - screen.x) + screen.x))\n               + (cam_up * mix(screen.y, screen.w,uv.y)));//(uv.y * (screen.w - screen.y) + screen.y)));\n\n        ray = Ray(camPos, dire);\n        color += marching(ray, camPos, camDir, objects, 200);\n    }\n    // Output to screen\n    fragColor = vec4(pow(color*1.0,vec3(1.5)),1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Transform{\n    vec3 pos;\n    vec3 scale;\n    vec3 normal;\n};\n\nstruct Object{\n    Transform tf;\n    int type;\n};\n\nstruct HitInfo{\n    float dist;\n    vec3 hitpoint;\n};","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float weights[5];\nfloat offsets[5];\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 3.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 3.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}