{"ver":"0.1","info":{"id":"ldyBWy","date":"1530216257","viewed":166,"name":"Ray marching practice 2","username":"lnae","description":"more weird tests","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define STEPS 64.\n#define EPS 0.0001\n#define EPSN 0.005\n\nmat2 rot(float angle){\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat distCube(vec3 pos, float radius){\n\treturn length(max(abs(pos) - radius, 0.)) - 0.05 * ((0.5 * sin(iTime + 5. * pos.y) + 0.5));\n}\n\nfloat distSphere(vec3 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat distScene(vec3 pos){\n    //slightly tilt the scene\n    pos.yz = rot(0.4) * pos.yz;\n    \n    //rotate\n    pos.xz = rot(iTime + sin(iTime) + 0.75) * pos.xz;\n    \n    vec3 posCube = pos;\n    //twist\n    posCube.xz = rot(iTime + sin(iTime + 5. * posCube.y) + 0.75) * posCube.xz;\n    \n    //repeat around y axis\n    float angle = atan(posCube.z, posCube.x);\n    float r = length(posCube.xz);    \n   \tfloat div = PI / 8.;\n    angle = abs(mod(angle, div) - 0.5 * div);\n    posCube.x = r * cos(angle);\n    posCube.z = r * sin(angle);\n    \n    posCube.xz = rot(PI / 4.) * posCube.xz;    \n    \n    //twisted rounded cube\n    float dist = distCube(posCube, 0.15);\n    \n    //repeat without twisting for the spheres\n    angle = atan(pos.z, pos.x);\n    float q = floor(angle / div);\n    angle = abs(mod(angle, div) - 0.5 * div);\n    pos.x = r * cos(angle);\n    pos.z = r * sin(angle);\n    \n    //aggressive spheres\n    float tr = abs(0.25 * sin(2.5 * sin(0.5 * iTime + 0.5)));\n    dist = min(dist, distSphere((pos - vec3(1. * tr + 0.2, 0.15 * sin(3. * sin(iTime + 1.)) + 0.05, 0.)), 0.02 * (mod(q, 2.) + 0.5)));    \n    dist = min(dist, distSphere((pos - vec3(2. * tr + 0.2, 0.15 * sin(3. * sin(iTime + 0.8)) + 0.05, 0.)), 0.025 * (mod(q + 1., 2.) + 0.5)));\n    dist = min(dist, distSphere((pos - vec3(3. * tr + 0.2, 0.15 * sin(3. * sin(iTime + 0.5)) + 0.05, 0.)), 0.03 * (mod(q, 2.) + 0.5)));\n    dist = min(dist, distSphere((pos - vec3(4. * tr + 0.25, 0.15 * sin(3. * sin(iTime + 0.2)) + 0.05, 0.)), 0.035 * (mod(q + 1., 2.) + 0.5)));\n\n\treturn dist;\n}\n\nvec3 getNormal(vec3 pos){\n\treturn normalize(vec3(distScene(pos + vec3(EPSN, 0., 0.) - distScene(pos - vec3(EPSN, 0., 0.))),\n                         distScene(pos + vec3(0., EPSN, 0.) - distScene(pos - vec3(0., EPSN, 0.))),\n                         distScene(pos + vec3(0., 0., EPSN) - distScene(pos - vec3(0., 0., EPSN)))));\n}\n\nvec3 render(vec2 uv){\n\tvec3 eye = vec3(0., 0., 3.);\n    vec3 ray = normalize(vec3(uv, 0.) - eye);\n    vec3 col = vec3(0.2);\n   \n    //raymarch\n    vec3 pos = eye;\n    float s, dist;\n    bool hit = false;\n    for(s = 0.; s < STEPS; s++){\n    \tdist = distScene(pos);\n        if(abs(dist) < EPS){\n        \tbreak;\n        }\n        pos += dist * ray;\n    }\n    \n    //color\n    if(s < STEPS) col = 0.5 * getNormal(pos) + 0.5;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}