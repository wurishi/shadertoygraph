{"ver":"0.1","info":{"id":"ftyXRm","date":"1640335246","viewed":288,"name":"Raymarching with Outlines","username":"PGRacer","description":"My first Shadertoy!\n\nStandard raymarching with cartoony outline effect.  There may be better ways to do it, but this is what I came up with off the top of my head.\n\nForgive any coding oddities.  This is a lazy port from another language.  ;)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cartoon","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.0\n#define SURF_DIST 0.000001\n#define OUTLINE_WIDTH 4.0\n#define COLOR_SEPARATION 4.0\n#define LIGHT_POWER 2.5\n\n#define TIME_FACTOR 0.25\n\nfloat time;\nfloat outlineWidth;\n\n// Generate rotation matrix\nmat3x3 GetRotationMatrix(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n\t\tt * x * x + c, t * x * y - s * z, t * x * z + s * y,\n\t\tt * x * y + s * z, t * y * y + c, t * y * z - s * x,\n\t\tt * x * z - s * y, t * y * z + s * x, t * z * z + c\n\t);\n}\n\n// Test sphere\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n\tp = GetRotationMatrix(time * 1.23, normalize(vec3(0.0, 1.0, 0.0))) * p;\n\n\treturn length(p - pos) - r;\n}\n\n// Test Torus\nfloat sdTorus(vec3 p, vec3 pos, float w, float r)\n{\n\tpos.y = pos.y + sin(iTime * 0.76) * 0.25;\n\n\tp = GetRotationMatrix(time * 2.24, normalize(vec3(0.0, 0.0, 1.0))) * (p - pos) + pos;\n\tp = GetRotationMatrix(time * 1.73, normalize(vec3(1.0, 0.0, 0.0))) * (p - pos) + pos;\n\n\treturn length(vec2(length((p - pos).xz) - w, (p - pos).y)) - r;\n}\n\n// Test Capsule\nfloat sdCapsule(vec3 p, vec3 pos, float len, float rad)\n{\n\tp = GetRotationMatrix(time * 0.5, normalize(vec3(-1.0, 1.0, 0.0))) * (p - pos) + pos;\n\tp = GetRotationMatrix(time * 0.63, normalize(vec3(0.0, 1.0, 0.0))) * (p);\n\n\tvec3 a = pos + vec3(len * 0.5, 0.0, 0.0);\n\tvec3 b = pos + vec3(-len * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - rad;\n}\n\n// Test Cylinder\nfloat sdCylinder(vec3 p, vec3 pos, float l, float r)\n{\n\tpos.x = pos.x + sin(time * 1.34) * 0.4;\n\tp = GetRotationMatrix(time * 0.65, normalize(vec3(.32, .77, -0.484))) * (p - pos) + pos;\n\n\tvec3 a = pos + vec3(l * 0.5, 0.0, 0.0);\n\tvec3 b = pos + vec3(-l * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0));\n\tfloat i = min(max(x, y), 0.0);\n\n\treturn e + i;\n}\n\n// Test Box\nfloat sdBox(vec3 p, vec3 pos, vec3 dimensions)\n{\n\tp = GetRotationMatrix(time * 1.64, normalize(vec3(-.32, .17, -0.87))) * (p - pos) + pos;\n\n    dimensions.x += (sin(time * 1.56) + 1.0) / 4.3;\n    dimensions.y += (sin(time * 0.86) + 1.0) / 3.3;\n    dimensions.z += (sin(time * 1.12) + 1.0) / 5.2;\n\n\treturn length(max(abs(p - pos) - (0.5 * dimensions), 0.0));\n}\n\nfloat GetDist(vec3 p)\n{\n\tfloat distSphere = sdSphere(p, vec3(0.35, 0.0, 0.0), 0.2);\n\tfloat distTorus = sdTorus(p, vec3(0.0, 0.0, 0.0), 0.25, 0.1);\n\tfloat distCapsule = sdCapsule(p, vec3(-0.25, 0.0, 0.12), 0.75, 0.1);\n\tfloat distCylinder = sdCylinder(p, vec3(0.0, 0.0, 0.3), 1.2, 0.15);\n\tfloat distBox = sdBox(p, vec3(0.0, 0.0, 0.33), vec3(0.2, 0.2, 0.2));\n    \n\tfloat minimum = distSphere;\n    minimum = min(minimum, distTorus);\n    minimum = min(minimum, distCapsule);\n    minimum = min(minimum, distCylinder);\n    minimum = min(minimum, distBox);\n    \n    return minimum;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 e = vec2(1e-2, 0);\n\tint objID;\n\tvec3 n = GetDist(p) - vec3(\n\t\tGetDist(p - e.xyy),\n\t\tGetDist(p - e.yxy),\n\t\tGetDist(p - e.yyx)\n\t\t);\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Global time alteration for convenience\n    time = iTime * TIME_FACTOR;\n    \n    // Keep outline width same in full screen\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    // Camera Stuff\n    vec3 camPos = vec3(0.0, 0.0, -1.50);\n    vec3 camDir = normalize(vec3(uv.x, uv.y, 1.0));\n\n    // Do raymarching\n    float dO = 0.0;\n\tvec3 p = vec3(0.0);\n\tbool outline = false;\n\tbool hit = false;\n    float prevDist = 1000.0;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tp = camPos + camDir * dO;\n\t\tfloat d = GetDist(p);\n\t\tdO += d;\n\n\t\tif (!outline && d < outlineWidth * (1.0 + log2(dO)) + SURF_DIST)\n\t\t{\n\t\t\toutline = true;\n\t\t}\n\n\t\tif (dO > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d <= SURF_DIST)\n\t\t{\n            hit = true;\n\t\t\tbreak;\n\t\t}\n        \n        // If at any point we've gotten within the thickness of our outline and \n        // then we get further away from a hit we break out and draw the outline\n        if (outline && prevDist < d)\n        {\n            break;\n        }\n        \n        prevDist = d;\n\t}\n\n    dO /= MAX_DIST;\n    \n    vec3 col;\n    \n    if (hit)\n    {\n        vec3 normal = GetNormal(p);\n        vec3 absNormal = abs(normal);\n        col = vec3(\n            pow(absNormal.x, COLOR_SEPARATION),\n            pow(absNormal.y, COLOR_SEPARATION),\n            pow(absNormal.z, COLOR_SEPARATION)\n        );\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, -0.5));\n        float scalar = dot(lightDir, normal);\n        scalar = clamp(scalar, 0.0, 1.0);\n        scalar *= LIGHT_POWER;\n        scalar = (scalar + 1.0) / 2.0;\n        col *= scalar;\n        //col = vec3(scalar);\n        \n    }\n    else if (outline)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {\n        vec3 dir = GetRotationMatrix(iTime * 0.1, vec3(0.0, 1.0, 0.0)) * camDir; \n        col = texture(iChannel0, dir).rgb;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}