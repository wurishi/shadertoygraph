{"ver":"0.1","info":{"id":"Ml2yDG","date":"1510249064","viewed":1396,"name":"PBR: Disney BRDF 2012","username":"ref2401","description":"Anisotropic Disney BRDF 2012, single directional light source.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["brdf","anisotropic","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References:\n//\t\tPhysically-Based Shading at Disney 2012;\n// \t\tUnderstanding the Masking-Shadowing Function in Microfacet-Based BRDFs;\n//\t\n// Single directional light source;\n// No ambient lighting;\n// No anti-aliasing (solved only sphere jagged edges);\n// One can change light's position in func called 'init_light_view_directions_ts'.\n// One can change material's params in func called 'generate_material'.\n//\n// Prefixis:\n// \t\tis \t- image space;\n// \t\tndc - normalized device coordinates space;\n// \t\tts\t- tangent space;\n\n\nconst float\tc_1_over_pi = 1.0 / 3.1415926535;\n\nstruct material {\n    vec3 \tbase_color;\n    vec3 \treflect_color;\n   \tvec2 \tlinear_roughness; \t// [0.07, 1], ggx is zero when roughness is zero.\n    float \tmetallic_mask;\t\t\n};\n    \n\nvec3 calc_diffuse_term(float dot_nl, float dot_nv, float dot_lh, vec3 base_color, float rough_s)\n{\n    float fd_90_minus_1 = 2.0 * dot_lh * dot_lh * rough_s - 0.5;\n    \n    return base_color * c_1_over_pi \n        * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nl, 5.0))\n        * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nv, 5.0));\n}\n\n// anisotropic GGX / Trowbridge-Reitz\n//\nfloat calc_distribution_ggx(float dot_nh, float dot_ht, float dot_hb, vec2 linear_roughness)\n{\n    float rought_x \t= linear_roughness.x * linear_roughness.x;\n    float rought_y \t= linear_roughness.y * linear_roughness.y;\n    float rough_x_s = rought_x * rought_x;\n\tfloat rough_y_s = rought_y * rought_y;\n    \n\tfloat d = (dot_nh * dot_nh\n        + dot_ht * dot_ht * (1.0 / rough_x_s)\n    \t+ dot_hb * dot_hb * (1.0 / rough_y_s));\n\t\n    return c_1_over_pi * (1.0 / (rought_x * rought_y * d * d));\n}\n\nvec3 calc_fresnel_schlick(vec3 f0, float dot_vn)\n{\n\treturn f0 + (1.0 - f0) * pow(1.0 - dot_vn, 5.0);\n}\n\nfloat calc_smith_lambda(float a2, float cos_angle)\n{\n    if (cos_angle < 0.01) return 0.0;\n    \n    float sin_angle = sqrt(1.0 - cos_angle * cos_angle);\n\tfloat tan_angle = sin_angle * (1.0 * cos_angle);\n\n\treturn sqrt(1.0 + a2 * tan_angle * tan_angle) * 0.5 - 0.5;\n}\n\nfloat calc_masking_shadow_factor(float dot_nl, float dot_nv, float rought_s)\n{\n    // smith correlated\n\tfloat a2 \t\t= rought_s * 0.5;\n\tfloat lambda_l \t= calc_smith_lambda(a2, dot_nl);\n\tfloat lambda_v \t= calc_smith_lambda(a2, dot_nv);\n\treturn 1.0f / (1.0 + lambda_l + lambda_v);\n}\n\nvec3 calc_specular_term(vec3 fresnel, float dot_nl, float dot_nv, float dot_nh, float dot_lh, \n                        float dot_ht, float dot_hb, vec2 linear_roughness, float rough_s)\n{\n    float v_1_over_denom = 1.0 / (4.0 * dot_nl * dot_nv);\n\n\treturn fresnel\n        * calc_distribution_ggx(dot_nh, dot_ht, dot_hb, linear_roughness)\n        * calc_masking_shadow_factor(dot_nl, dot_nv, rough_s)\n        * v_1_over_denom;\n}\n\n// Performs tone mapping and gamma corretion.\n//\nvec3 convert_hdr_to_srgb(vec3 hdr)\n{\n    const float gamma = 1.0 / 2.2;\n    \n    vec3 ldr = hdr * (1.0 / (hdr + 1.0));\t// hell of a tone mapping\n    return vec3(pow(ldr.x, gamma), \n                pow(ldr.y, gamma), \n                pow(ldr.z, gamma));\t\t\t// for some reason I could not write pow(ldr, gamma)\n}\n\nmaterial generate_material(int time_base)\n{\n    //material m = material(/* base_color */\t\tvec3(0.5),\n    //                      /* reflect_color */\t\tvec3(1.0),\n    //                      /* linear_roughness */\tvec2(0.15, 0.15),\n    //                      /* metallic_mask */\t\t0.8);\n\n    vec3 fct_bc\t\t= cos(vec3(time_base) * vec3(0.002, 0.0013, 0.0015));\n    vec4 fct_pack\t= sin(vec4(time_base) * vec4(0.005, 0.012, 0.0188, 0.0057));\n\n    material m;\n    m.base_color \t\t\t= mix(vec3(0.1), vec3(1.0), fct_bc * fct_bc);\n    m.reflect_color \t\t= mix(vec3(0.4), vec3(1.0), pow(fct_pack.x, 4.0));\n    m.linear_roughness.x \t= mix(0.11, 1.0, pow(fct_pack.y, 6.0));\n    m.linear_roughness.y \t= mix(0.11, 1.0, pow(fct_pack.z, 6.0));\n   \tm.metallic_mask \t\t= mix(0.0, 0.8, pow(fct_pack.w, 4.0));\n    \n    return m;\n}\n\n// Sets directions to the light and to the view in the tangent space \n// using the given position of a fragment.\n//\nvoid init_light_view_directions_ts(vec3 pos_ndc, int time_base, out vec3 to_light_ts, out vec3 to_view_ts)\n{\n    float x = cos(float(time_base) * 0.02);\n    float y = sin(float(time_base) * 0.01);\n    vec3 direction_to_light_ndc = normalize(vec3(x, y, 1.0));\n    \n    // compose matrix ndc -> ts.\n    vec3 t = normalize(dFdx(pos_ndc));\n    vec3 b = normalize(dFdy(pos_ndc));\n    vec3 n = normalize(cross(t, b));\n    mat3 ndc_to_ts_matrix = transpose(mat3(t, b, n));\n    \n    to_light_ts = ndc_to_ts_matrix * direction_to_light_ndc;\n    to_view_ts \t= ndc_to_ts_matrix * normalize(vec3(0, 0, 1) - pos_ndc);\n}\n    \nvoid mainImage( out vec4 frag_color, in vec2 fragCoord)\n{\n\tconst float c_radius_ndc = 0.2;\n    \n    // discard a fragment if it does not belong to the spehre.\n    // xy_is is relative to the center of the render target.\n    vec2 xy_is \t\t= gl_FragCoord.xy * (1.0 / iResolution.xy) + vec2(-0.5);\n    vec2 xy_ndc \t= xy_is * vec2(1, iResolution.y * (1.0 / iResolution.x));\n    float dist_ndc \t= length(xy_ndc);\n\n    if (dist_ndc > c_radius_ndc) discard;\n    \n    // reconstruct fragment's position on a sphere in the ndc space.\n    float z_ndc \t\t= sqrt(c_radius_ndc * c_radius_ndc + dot(xy_ndc, -xy_ndc));\n    vec3 position_ndc \t= vec3(xy_ndc.xy, z_ndc);\n    \n    // light equation's directions\n    vec3 l_ts;\n    vec3 v_ts;\n    init_light_view_directions_ts(position_ndc, iFrame, l_ts, v_ts);\n    \n    vec3 h_ts \t\t= normalize(l_ts + v_ts);\n    float dot_nl \t= clamp(l_ts.z, 0.0, 1.0);\n    float dot_nv \t= clamp(v_ts.z, 0.0, 1.0);\n    float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n    float dot_lh \t= clamp(dot(l_ts, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n    float dot_ht\t= h_ts.x;\n    float dot_hb\t= h_ts.y;\n   \n    // material params\n    material m \t\t\t= generate_material(iFrame);\n    float rough_s\t\t= dot_ht * dot_ht * m.linear_roughness.x * m.linear_roughness.x\n        \t\t\t\t+ dot_hb * dot_hb * m.linear_roughness.y * m.linear_roughness.y; // uniform roughness squared\n    vec3 reflect_color \t= 0.16 * m.reflect_color * m.reflect_color;\n    vec3 f0\t\t\t\t= mix(reflect_color, m.base_color, m.metallic_mask);\n    vec3 fresnel\t\t= calc_fresnel_schlick(f0, dot_nv);\n    \n    // lighting\n    vec3 diffuse_factor\t\t= (1.0 - fresnel) * (1.0 - m.metallic_mask);\n    vec3 diffuse_term \t\t= diffuse_factor * calc_diffuse_term(dot_nl, dot_nv, dot_lh, m.base_color, rough_s);\n   \tvec3 specular_term \t\t= calc_specular_term(fresnel, dot_nl, dot_nv, dot_nh, dot_lh, \n                                             dot_ht, dot_hb, m.linear_roughness, rough_s);    \n   \n    vec3 hdr\t= (diffuse_term + specular_term) * dot_nl;\n    vec3 srgb \t= convert_hdr_to_srgb(hdr);\n    \n    // interpolate between black color and srgb value to get rid of those nasty jagged edges.\n    const float c_radius_falloff_start_ndc = c_radius_ndc - 0.007;\n    float mix_factor\t= (c_radius_falloff_start_ndc - dist_ndc) / (c_radius_ndc - dist_ndc);\n    vec3 final_color\t= mix(vec3(0.0), srgb, mix_factor);\n    \n\tfrag_color = vec4(final_color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}