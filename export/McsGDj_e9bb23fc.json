{"ver":"0.1","info":{"id":"McsGDj","date":"1703564924","viewed":60,"name":"SHADERTOY WORK","username":"MATBBB","description":"program","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TYPE_qiu 5.\n#define TYPE_qigan 6.\n#define TYPE_hongqi 7.\n#define TYPE_xingxing 8.\n#define TYPE_rocket 9.\n#define TYPE_fire 10.\n\n#define EPSILON 0.0001\n#define MAX_DIST 200.\n#define MAX_ITER 200\n\n#define ANIMATION_SPEED 1.5\n#define MOVEMENT_SPEED 1.0\n#define MOVEMENT_DIRECTION vec2(0.7, 1.0)\n\n#define PARTICLE_SIZE 0.005\n\n#define PARTICLE_SCALE (vec2(1.2, 1.9))\n#define PARTICLE_SCALE_VAR (vec2(0.25, 0.2))\n\n#define PARTICLE_BLOOM_SCALE (vec2(0.5, 0.8))\n#define PARTICLE_BLOOM_SCALE_VAR (vec2(0.3, 0.1))\n\n#define SPARK_COLOR vec3(1.0, 0.8, 0.8) * 1.5\n#define BLOOM_COLOR vec3(1.0, 0.8, 0.8) * 0.8\n#define SMOKE_COLOR vec3(1.0, 0.8, 0.8) * 0.8\n\n#define SIZE_MOD 1.05\n#define ALPHA_MOD 0.9\n#define LAYERS_COUNT 15\n\nvec2 fixUV(vec2 uv)\n{\n    return (2. * uv - iResolution.xy) / iResolution.x;\n}\n\nfloat random_1d(float p)\n{\n    return abs(fract(982164.87415 * sin(p * 167.547 + 9184.517)));\n}\n\nfloat random(vec2 pos)\n{\n    vec2 p2 = fract(pos * 10.1321513) * 95.1876653;\n    return fract((p2.x + p2.y) * p2.x * p2.y);\n}\n\nvec3 noise(vec2 pos)\n{\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6. * u * (1. - u);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = a - b - c + d;\n\n    return vec3(k0 + k1 * u.x + k2 * u.y + k3 * u.x * u.y,\n                du * (vec2(k1, k2) + k3 * u.yx));\n}\n\nmat2 rotate2D = mat2(0.6, -0.8, 0.8, 0.6);\n// mat2 rotate2D=mat2(0.69465837,-0.71934,0.71934,0.69465837);\n\nfloat ground(vec2 x)\n{\n    vec2 p = 0.003 * x;\n    float a = 0.;\n    float b = 1.;\n    vec2 d = vec2(0);\n\n    for (int i = 0; i < 8; i++)\n    {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n        p = rotate2D * p * 2.;\n        b *= 0.5;\n    }\n\n    return 120. * a;\n}\n\nfloat groundH(vec2 x)\n{\n    vec2 p = 0.003 * x;\n    float a = 0.;\n    float b = 1.;\n    vec2 d = vec2(0);\n\n    for (int i = 0; i < 12; i++)\n    {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n        p = rotate2D * p * 2.;\n        b *= 0.5;\n    }\n\n    return 120. * a;\n}\n\nfloat groundL(vec2 x)\n{\n    vec2 p = 0.003 * x;\n    float a = 0.;\n    float b = 1.;\n    vec2 d = vec2(0);\n\n    for (int i = 0; i < 3; i++)\n    {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n        p = rotate2D * p * 2.;\n        b *= 0.5;\n    }\n\n    return 120. * a;\n}\n\n// 并集\nvec2 OpU(in vec2 sdf1, in vec2 sdf2)\n{\n    if (sdf1.x < sdf2.x)\n        return sdf1;\n    else\n        return sdf2;\n}\n\n/*-------------------- sdf ----------------------------*/\n// 山体sdf\nfloat sdfMountain(vec3 p)\n{\n    return (p.y - ground(p.xz));\n}\n\n// 球sdf\nfloat sdfSphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// 星星 star\nfloat sdfSphere1(in vec3 p, float r)\n{\n    float timeFactor = abs(fract(iTime) - 0.5);\n    float zFactor = (abs(fract(p.z * 0.3) - 0.5) * 4. * timeFactor);\n    float powFactor = pow((-322.3 - p.z) / 4., 1.0);\n\n    p.x += 0.012 * powFactor * sin(zFactor) + 0.2;\n    p.y += 0.008 * powFactor * sin(zFactor);\n\n    return length(p) - r;\n}\n\n// 圆柱sdf\nfloat sdfCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// 旗面sdf\nfloat sdBox(vec3 p, vec3 b)\n{\n    float timeFactor = abs(fract(iTime) - 0.5);\n    float zFactor = (abs(fract(p.z * 0.3) - 0.5) * 4. * timeFactor);\n    float powFactor = pow((-322.3 - p.z) / 4., 1.0);\n\n    p.x += 0.012 * powFactor * sin(zFactor);\n    p.y += 0.008 * powFactor * sin(zFactor);\n\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// 国旗sdf\nvec2 flag(vec3 p)\n{\n    vec2 d = vec2(sdfCappedCylinder(p + vec3(-48, -95, -322), 8.0, 0.3), TYPE_qigan); // 旗杆\n\n    d = OpU(d, vec2(sdfSphere(p + vec3(-48, -103, -322), 0.5), TYPE_qiu)); // 旗杆顶球\n\n    d = OpU(d, vec2(sdBox(p + vec3(-48, -100.5, -326.3), vec3(0.15, 2.5, 4.0)), TYPE_hongqi)); // 红旗\n\n    vec3 starBasePos = p + vec3(-47.5, -101.7, -324);\n    float starSizes[5] = float[](0.35, 0.15, 0.15, 0.15, 0.15);\n    vec3 starOffsets[5] = vec3[](vec3(0, 0, 0), vec3(0, -0.5, -0.9), vec3(0, 0, -1.3), vec3(0, 0.5, -1.3), vec3(0, 1.0, -0.9));\n\n    for (int i = 0; i < 5; i++)\n    { // 星星\n        d = OpU(d, vec2(sdfSphere1(starBasePos + starOffsets[i], starSizes[i]), TYPE_xingxing));\n    }\n\n    return d;\n}\n\n// 火箭圆柱sdf\nfloat sdfCappedCylinder_rocket(vec3 p, float h, float r)\n{\n    p.y -= 2. * pow(iTime + 1., 1.2);\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// 火箭圆锥sdf\nfloat sdCappedCone(vec3 p, float h, float r1, float r2)\n{\n    p.y -= 2. * pow(iTime + 1., 1.2);\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\n// 旗面sdf\nfloat sdBox_rocket(vec3 p, vec3 b)\n{\n    p.y -= 2. * pow(iTime + 1., 1.2);\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec2 rocket(vec3 p, vec3 offset)\n{\n    vec3 pOffset = p + offset;\n    vec2 d = vec2(sdfCappedCylinder_rocket(pOffset, 40., 7.), TYPE_rocket); // 主舰体\n\n    vec3 redFlagOffset = vec3(10., -5., 0.);\n    vec3 mainConeOffset = vec3(0., -45., 0.);\n    vec3 sideBody1Offset = vec3(-7, 30., -7.);\n    vec3 sideCone1Offset = vec3(-7, 5., -7.);\n    vec3 sideBody2Offset = vec3(7, 30., 7.);\n    vec3 sideCone2Offset = vec3(7, 5., 7.);\n    vec3 flame1Offset = vec3(0., 55., 0.);\n    vec3 flame2Offset = vec3(-7., 59., -7.);\n    vec3 flame3Offset = vec3(7., 59., 7.);\n\n    d = OpU(d, vec2(sdBox_rocket(pOffset + redFlagOffset, vec3(0.15, 2.5, 4.)), TYPE_hongqi));   // 红旗\n    d = OpU(d, vec2(sdCappedCone(pOffset + mainConeOffset, 10., 7., 0.01), TYPE_rocket));        // 主箭头\n    d = OpU(d, vec2(sdfCappedCylinder_rocket(pOffset + sideBody1Offset, 20., 7.), TYPE_rocket)); // 副舰体1\n    d = OpU(d, vec2(sdCappedCone(pOffset + sideCone1Offset, 10., 4., 0.01), TYPE_rocket));       // 副箭头1\n    d = OpU(d, vec2(sdfCappedCylinder_rocket(pOffset + sideBody2Offset, 20., 7.), TYPE_rocket)); // 副舰体2\n    d = OpU(d, vec2(sdCappedCone(pOffset + sideCone2Offset, 10., 4., 0.01), TYPE_rocket));       // 副箭头2\n    d = OpU(d, vec2(sdfCappedCylinder_rocket(pOffset + flame1Offset, 16., 5.), TYPE_fire));      // 火焰1\n    d = OpU(d, vec2(sdfCappedCylinder_rocket(pOffset + flame2Offset, 6., 3.5), TYPE_fire));      // 火焰2\n    d = OpU(d, vec2(sdfCappedCylinder_rocket(pOffset + flame3Offset, 6., 3.5), TYPE_fire));      // 火焰3\n\n    return d;\n}\n\nvec2 map(in vec3 p)\n{\n    // x负越大 后  y负越大 上   z负越大 右\n    vec2 d = flag(p);                                               // 国旗\n    d = OpU(d, rocket(p, vec3(-400., -15. - ground(p.xz), -190.))); // 火箭\n    d = OpU(d, vec2(sdfMountain(p), 2.));                           // 2代表山\n    return d;\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    float fac = 0.5;\n    for (int i = 0; i < 4; i++)\n    {\n        f += fac * noise(p).x;\n        p = rotate2D * p * 2.0;\n        fac *= 0.5;\n    }\n    return f;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float t = tmin;\n    float mytype = 3.0;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + t * rd;\n        float d = map(p).x;\n        float retype = map(p).y;\n        if (abs(d) < EPSILON * t || t > tmax)\n        {\n            mytype = retype;\n            break;\n        }\n        t += 0.3 * d;\n    }\n    return vec2(t, mytype);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd)\n{ // 软阴影： ro阴影计算点， rd光源方向 ，dis距离\n    // float minStep = clamp(0.01 * dis, 0.5, 50.0); //最小步长\n    float res = 1.0;\n    float t = 0.001;\n    for (int i = 0; i < 80; i++)\n    {\n        vec3 p = ro + t * rd;\n        // float h = p.y - ground(p.xz);\n        float h = map(p).x;\n        res = min(res, 8.0 * h / t);\n        // t += max(minStep, h);\n        t += h;\n        if (res < 0.001 || p.y > 200.0)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNorm_obj(vec3 p, float t)\n{\n    float h = 0.0027 * t;\n    vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(p + k.xyy * h).x +\n                     k.yyx * map(p + k.yyx * h).x +\n                     k.yxy * map(p + k.yxy * h).x +\n                     k.xxx * map(p + k.xxx * h).x);\n}\n\nvec3 calcNorm(vec3 p, float t)\n{\n    vec2 epsilon = vec2(0.0027 * t, 0);\n    return normalize(vec3(groundH(p.xz - epsilon.xy) - groundH(p.xz + epsilon.xy),\n                          2.0 * epsilon.x,\n                          ground(p.xz - epsilon.yx) - ground(p.xz + epsilon.yx)));\n}\n\nmat3 setCamera(vec3 ro, vec3 target, float cr)\n{\n    vec3 z = normalize(target - ro);\n    vec3 up = normalize(vec3(sin(cr), cos(cr), 0));\n    vec3 x = cross(z, up);\n    vec3 y = cross(x, z);\n    return mat3(x, y, z);\n}\n\nvec3 linear_lighting_common(vec3 p, vec3 light, vec3 norm, vec3 difColor, vec3 ambColor, vec3 bacColor)\n{\n    vec3 lin = vec3(0.0);\n    float dif = clamp(dot(light, norm), 0.0, 1.0);\n    float sh = softShadow(p + 0.01 * light, light);\n    float amb = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n    float bac = clamp(0.2 + 0.8 * dot(vec3(-light.x, 0.0, light.z), norm), 0.0, 1.0);\n    lin += dif * difColor * vec3(sh, sh * sh * 0.5 + 0.5 * sh, sh * sh * 0.8 + 0.2 * sh);\n    lin += amb * ambColor;\n    lin += bac * bacColor;\n    return lin;\n}\n\nvec3 linear_lighting_moon(vec3 p, vec3 moonlight, vec3 norm)\n{\n    return linear_lighting_common(p, moonlight, norm,\n                                  vec3(1.1, 1.2, 1.02) * 1.34,\n                                  vec3(54. / 255., 81. / 255., 135. / 255.) * 1.3,\n                                  vec3(87. / 255., 104. / 255., 124. / 255.));\n}\n\nvec3 linear_lighting_sun(vec3 p, vec3 sunlight, vec3 norm)\n{\n    return linear_lighting_common(p, sunlight, norm,\n                                  vec3(8.0, 5.0, 3.0) * 1.8,\n                                  vec3(0.4, 0.6, 1.0) * 1.2,\n                                  vec3(0.4, 0.5, 0.6));\n}\n\nvec3 calculate_lighting(vec3 p, vec3 rd, vec3 norm, vec3 base_col, vec3 sunlight, vec3 moonlight, float lightscale, float moonscale, float t)\n{\n    vec3 lin = linear_lighting_sun(p, sunlight, norm);\n    vec3 lin_moon = linear_lighting_moon(p, moonlight, norm);\n    vec3 col = base_col * (lin * min(1., (lightscale + 0.2)) + lin_moon * min(1., (moonscale + 0.2)));\n    col = mix(col, 0.65 * vec3(0.5, 0.75, 1.0) * min(1., (lightscale + 0.2)), 1. - exp(-pow(0.003 * t, 1.5)));\n    return col;\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 col = vec3(0);\n    /////////////////////////////////////////   camera  ///////////////////////////////////////////////////////////\n    //修改此处选择是否让摄像机移动\n    float an =  iTime * 0.035;\n    //float an = 0.06;\n    float r = 310.;\n    vec2 pos2d = vec2(r * sin(an) - 10., r * cos(an));\n    float h = groundL(pos2d) + 25.; // 保持在高于山体25的方向上摄像\n    vec3 ro = vec3(pos2d.x, h, pos2d.y);\n    vec3 target = vec3(r * sin(an + 0.01), h, r * cos(an + 0.01));\n    mat3 cam = setCamera(ro, target, 0.);\n\n    float fl = 1.;\n    vec3 rd = normalize(cam * vec3(uv, fl));\n\n    float tmin = 0.001;\n    float tmax = 1000.;\n    float maxh = 300.;\n\n    float tp = (maxh - ro.y) / rd.y;\n    if (tp > 0.)\n    {\n        if (maxh > ro.y)\n            tmax = min(tmax, tp);\n        else\n            tmin = max(tmin, tp);\n    }\n    vec2 t = rayMarch(ro, rd, tmin, tmax);\n\n    // vec3 fire = normalize(vec3(2., -1., -2.) + vec3(0., 2. * pow(iTime + 1., 1.2), 0.)); //火焰位置 p.y -=  2. * pow(iTime + 1., 1.2);\n    // float firedot =  clamp(dot(rd, fire), 0., 1.);\n\n    vec3 sunlight = normalize(vec3(30., 30. * cos(0.3 * iTime), 30. * sin(0.3 * iTime))); // 太阳位置\n    float lightscale = (sunlight.y + 0.5774) / 1.1548;\n    float sundot = clamp(dot(rd, sunlight), 0., 1.); // 太阳系数，与太阳越近越亮\n\n    vec3 moonlight = normalize(vec3(30., -30. * cos(0.3 * iTime), -30. * sin(0.3 * iTime))); // 月亮位置\n    float moonscale = (moonlight.y + 0.5774) / 1.1548;\n    float moondot = clamp(dot(rd, moonlight), 0., 1.); // 月亮系数，与月亮越近越亮\n\n    // 夜空星星\n    vec3 starlight[20];\n    float stardot[20];\n    float itime[20];\n    starlight[0] = normalize(vec3(0.8, 0.4, -0.2));\n    stardot[0] = clamp(dot(rd, starlight[0]), 0., 2.);\n    starlight[1] = normalize(vec3(3., 1.1, -1.));\n    stardot[1] = clamp(dot(rd, starlight[1]), 0., 2.);\n    starlight[2] = normalize(vec3(7., 1., -6.));\n    stardot[2] = clamp(dot(rd, starlight[2]), 0., 2.);\n    starlight[3] = normalize(vec3(5., 1.5, 5.));\n    stardot[3] = clamp(dot(rd, starlight[3]), 0., 2.);\n    starlight[4] = normalize(vec3(5., 1.2, 3.));\n    stardot[4] = clamp(dot(rd, starlight[4]), 0., 2.);\n    itime[0] = iTime * 0.1;\n    itime[1] = iTime * 1.2;\n    itime[2] = iTime * 0.5;\n    itime[3] = iTime * 2.1;\n    itime[4] = iTime * 1.8;\n    // for(int i=5; i<10; i++){\n    //     float randx = random_1d(starlight[i-5].x);\n    //     float randy = random_1d(starlight[i-5].y);\n    //     float randz = random_1d(starlight[i-5].z);\n    //     starlight[i] = normalize(vec3(fract(sin(randx)) * 19489.21, fract(cos(randy)) * 7718.16, fract(sin(randz)) * 476164.54479));\n    //     stardot[i] = clamp(dot(rd, starlight[i]), 0., 2.);\n    //}\n\n    if (t.x > tmax)\n    {\n        // sky\n        col = vec3(0.3 * min(1., (lightscale + 0.3)), 0.5 * min(1., (lightscale + 0.1)), 0.85 * min(1., (lightscale + 0.05))) - rd.y * rd.y * 0.5; // 蓝，越往上更蓝 往下变浅\n        col = mix(col, 0.85 * vec3(0.7, 0.75, 0.85) * min(1., (lightscale + 0.1)), pow(1.0 - max(rd.y, 0.0), 4.0));                                // 下半部分偏向白色\n        // col *= min(1., (lightscale + 0.2));\n\n        // sun\n        col *= (1. - pow(sundot, 64.0));\n        col += 0.4 * vec3(0.9, 0.9, 0.7 * min(1., (lightscale + 0.1))) * pow(sundot, 64.0) * min(1., (lightscale + 0.1)); // 光晕\n        col += 0.4 * vec3(1., 0.8, 0.7 * min(1., (lightscale + 0.1))) * pow(sundot, 64.0) * min(1., (lightscale + 0.1));  // 太阳高光\n        col += 0.4 * vec3(1., 0.7, 0.5 * min(1., (lightscale + 0.1))) * pow(sundot, 512.0) * min(1., (lightscale + 0.1));\n        col += 0.5 * vec3(1, 0.7, 0.5 * min(1., (lightscale + 0.1))) * pow(sundot, 1024.0) * min(1., (lightscale + 0.1));\n        float duskscale = -8.163265306122 * pow(lightscale - 0.6, 2.) + 1.;\n        if (lightscale >= 0.25 && lightscale <= 0.95)\n        {\n            col += 0.75 * vec3(1.0, 0.7, 0.3) * pow(sundot, 8.) * duskscale;\n            col += 0.75 * vec3(1.0, 0.7, 0.3) * pow(sundot, 8.) * duskscale;\n        }\n\n        // moon\n        if (lightscale < 0.6)\n        {\n            col *= (1. - pow(moondot, 1024.0));\n            col += 1. * vec3(0.9, 0.8, 0.5) * pow(clamp(moondot + 0.006, 0., 1.), 1024.0);\n        }\n\n        // stars\n        if (lightscale < 0.3)\n        {\n            // 归一化\n            float starscale = pow(((0.3 - lightscale) / 0.3), 2.) + 0.01;\n            // col += 2. * vec3(255./255., 255./255., 245./255.) * pow(stardot, 4096.0) * starscale + vec3(0.9, 0.9, 0.9) * 0.005;\n            for (int i = 0; i < 5; i++)\n            {\n                col += abs(sin(2. * itime[i])) * 1.1 * vec3(245. / 255., 250. / 255., 245. / 255.) * pow(clamp(stardot[i] - 0.00001, 0., 1.), 60000.0) * starscale + vec3(.8, .8, .8) * 0.0015;\n                //+ vec3(.9, .9, .9) * 0.003 保证星星消失时不至于全黑 加多了在出现和最终消失时会闪烁 加少了消失时有明显黑斑\n            }\n        }\n\n        // clouds\n        vec2 skyPos = ro.xz + rd.xz * (120. - ro.y) / rd.y + iTime * 5.;\n        col = mix(col, vec3(1.0, 0.95, 1.0) * min(1., (lightscale + 0.2)), 0.75 * smoothstep(0.4, 0.8, fbm(0.01 * skyPos)));\n    }\n    else\n    {\n        vec3 p = ro + t.x * rd;\n        vec3 n = calcNorm_obj(p, t.x);\n\n        if (t.y == TYPE_qigan)\n        {\n            // 旗杆\n            col = calculate_lighting(p, rd, n, vec3(128. / 255., 128. / 255., 128. / 255.), sunlight, moonlight, lightscale, moonscale, t.x);\n        }\n        else if (t.y == TYPE_qiu)\n        {\n            // 杆顶\n            col = calculate_lighting(p, rd, n, vec3(0.67, 0.719, 0.8104), sunlight, moonlight, lightscale, moonscale, t.x);\n        }\n        else if (t.y == TYPE_hongqi)\n        {\n            // 红旗\n            col = calculate_lighting(p, rd, n, vec3(1., 0., 0.), sunlight, moonlight, lightscale, moonscale, t.x);\n        }\n        else if (t.y == TYPE_xingxing)\n        {\n            // 星星\n            col = calculate_lighting(p, rd, n, vec3(1., 1., 0.), sunlight, moonlight, lightscale, moonscale, t.x);\n        }\n        else if (t.y == TYPE_rocket)\n        {\n            // 火箭\n            col = calculate_lighting(p, rd, n, vec3(0.7, 0.6, 0.65), sunlight, moonlight, lightscale, moonscale, t.x);\n        }\n        else if (t.y == TYPE_fire)\n        {\n            vec3 p = ro + t.x * rd;\n            float firedot = clamp(dot(rd, p), 0., 1.);\n            col += 0.4 * vec3(0.8, 0.7, 0.1) * pow(firedot, 32.0); // 光晕\n            col += 0.4 * vec3(1., 0.2, 0.1) * pow(firedot, 64.0);  // 光晕\n            col += 0.4 * vec3(1., 0.2, 0.1) * pow(firedot, 512.0); // 光晕\n            col += 0.75 * vec3(1.0, 0.7, 0.3) * pow(firedot, 8.0);\n            col += 0.75 * vec3(1.0, 0.7, 0.3) * pow(firedot, 8.0);\n            // col += 1. * vec3(1.0, 0.7, 0.3) * pow(firedot, 32.0);\n        }\n        else\n        {\n            vec3 p = ro + t.x * rd;\n            vec3 n = calcNorm(p, t.x);                                                                 // 计算法向量\n            vec3 difColor = mix(vec3(0.08, 0.05, 0.03), vec3(0.10, 0.09, 0.08), noise(p.xz * 0.02).x); // 随机深浅色变换\n            float r = noise(p.xz * 0.1).x;                                                             // 随机数\n\n            // 岩石\n            col = (r * 0.25 + 0.75) * 0.9 * difColor;                                                // 基础岩石颜色，0.75-1之间的随机深浅变换\n            col = mix(col, vec3(0.065, 0.06, 0.03) * (0.5 + 0.5 * r), smoothstep(0.7, 0.9, n.y));    // 岩石顶部平缓地方着色\n            col = mix(col, vec3(0.04, 0.045, 0.015) * (0.25 + 0.75 * r), smoothstep(0.95, 1., n.y)); // 草地\n            // col = mix(col, vec3(2.85/255., 1.02/255., 1.78/255.) * (0.5 + 0.5 * (r+1.)), smoothstep(0.3,0.5, n.y)); //花\n            col *= 0.1 + 1.8 * sqrt(fbm(p.xz * 0.04) * fbm(p.xz * 0.005)); // 深浅变化\n\n            // Snow\n            float h = smoothstep(35.0, 80.0, p.y + 35.0 * fbm(0.01 * p.xz));\n            float e = smoothstep(1.0 - 0.5 * h, 1.0 - 0.1 * h, n.y);\n            float o = 0.3 + 0.7 * smoothstep(0.0, 0.1, n.y + h * h);\n            float s = h * e * o;\n            col = mix(col, 0.29 * vec3(0.62, 0.65, 0.7), smoothstep(0.1, 0.9, s));\n\n            // Linear Lighting\n            vec3 lin = vec3(0.);\n            float dif = clamp(dot(sunlight, n), 0., 1.);           // 漫反射\n            float sh = softShadow(p + 0.01 * sunlight, sunlight);  // 软阴影\n            lin = linear_lighting_sun(p, sunlight, n);             // 太阳光照计算\n            vec3 lin_moon = linear_lighting_moon(p, moonlight, n); // 月亮光照\n            col *= lin * min(1., (lightscale + 0.2)) + lin_moon * min(1., (moonscale + 0.2));\n\n            // half-angle\n            vec3 hal = normalize(sunlight - rd);\n\n            col += (0.7 + 0.3 * s) * (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0)) *\n                   vec3(7.0, 5.0, 3.0) * sh * dif *\n                   pow(clamp(dot(n, hal), 0.0, 1.0), 16.0) * min(1., (lightscale + 0.2)); // 镜面光\n\n            col = mix(col, 0.65 * vec3(0.5, 0.75, 1.0) * min(1., lightscale - 0.1) + 0.5 * vec3(60. / 255., 70. / 255., 80. / 255.) * min(0.85, moonscale),\n                      1. - exp(-pow(0.003 * t.x, 1.5))); // 山体雾气\n        }\n    }\n\n    return col;\n}\n\nfloat hash1_2(in vec2 x)\n{\n    return fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);\n}\n\nvec2 hash2_2(in vec2 x)\n{\n    return fract(sin(x * mat2x2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\n\n// Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    // vec2 f = fract(uv);\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n\n    vec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0, 1);\n    vec2 uv10 = uv00 + vec2(1, 0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n\n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n\n    return v;\n}\n\n// Simple interpolated noise\nfloat noise1_2(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    // vec2 f = smoothstep(0.0, 1.0, fract(uv));\n\n    vec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0, 1);\n    vec2 uv10 = uv00 + vec2(1, 0);\n    vec2 uv11 = uv00 + 1.0;\n\n    float v00 = hash1_2(uv00);\n    float v01 = hash1_2(uv01);\n    float v10 = hash1_2(uv10);\n    float v11 = hash1_2(uv11);\n\n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    float v = mix(v0, v1, f.x);\n\n    return v;\n}\n\nfloat layeredNoise1_2(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float animation)\n{\n    float noise = 0.0;\n    float alpha = 1.0;\n    float size = 1.0;\n    vec2 offset;\n    for (int i = 0; i < layers; i++)\n    {\n        offset += hash2_2(vec2(alpha, size)) * 10.0;\n\n        // Adding noise with movement\n        noise += noise1_2(uv * size + iTime * animation * 8.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED + offset) * alpha;\n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n\n    noise *= (1.0 - alphaMod) / (1.0 - pow(alphaMod, float(layers)));\n    return noise;\n}\n\n// Rotates point around 0,0\nvec2 rotate(in vec2 point, in float deg)\n{\n    float s = sin(deg);\n    float c = cos(deg);\n    return mat2x2(s, c, -c, s) * point;\n}\n\n// Cell center from point on the grid\nvec2 voronoiPointFromRoot(in vec2 root, in float deg)\n{\n    vec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2x2(s, c, -c, s) * point * 0.66;\n    point += root + 0.5;\n    return point;\n}\n\n// Voronoi cell point rotation degrees\nfloat degFromRootUV(in vec2 uv)\n{\n    return iTime * ANIMATION_SPEED * (hash1_2(uv) - 0.5) * 2.0;\n}\n\nvec2 randomAround2_2(in vec2 point, in vec2 range, in vec2 uv)\n{\n    return point + (hash2_2(uv) - 0.5) * range;\n}\n\nvec3 fireParticles(in vec2 uv, in vec2 originalUV)\n{\n    vec3 particles = vec3(0.0);\n    vec2 rootUV = floor(uv);\n    float deg = degFromRootUV(rootUV);\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\n    float dist = 2.0;\n    float distBloom = 0.0;\n\n    // UV manipulation for the faster particle movement\n    vec2 tempUV = uv + (noise2_2(uv * 2.0) - 0.5) * 0.1;\n    tempUV += -(noise2_2(uv * 3.0 + iTime) - 0.5) * 0.07;\n\n    // Sparks sdf\n    dist = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_SCALE, PARTICLE_SCALE_VAR, rootUV));\n\n    // Bloom sdf\n    distBloom = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_BLOOM_SCALE, PARTICLE_BLOOM_SCALE_VAR, rootUV));\n\n    // Add sparks\n    particles += (1.0 - smoothstep(PARTICLE_SIZE * 0.6, PARTICLE_SIZE * 3.0, dist)) * SPARK_COLOR;\n\n    // Add bloom\n    particles += pow((1.0 - smoothstep(0.0, PARTICLE_SIZE * 6.0, distBloom)) * 1.0, 3.0) * BLOOM_COLOR;\n\n    // Upper disappear curve randomization\n    float border = (hash1_2(rootUV) - 0.5) * 2.0;\n    float disappear = 1.0 - smoothstep(border, border + 0.5, originalUV.y);\n\n    // Lower appear curve randomization\n    border = (hash1_2(rootUV + 0.214) - 1.8) * 0.7;\n    float appear = smoothstep(border, border + 0.4, originalUV.y);\n\n    return particles * disappear * appear;\n}\n\n// Layering particles to imitate 3D view\nvec3 layeredParticles(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float smoke)\n{\n    vec3 particles = vec3(0);\n    float size = 1.0;\n    float alpha = 1.0;\n    vec2 offset = vec2(0.0);\n    vec2 noiseOffset;\n    vec2 bokehUV;\n\n    for (int i = 0; i < layers; i++)\n    {\n        // Particle noise movement\n        noiseOffset = (noise2_2(uv * size * 2.0 + 0.5) - 0.5) * 0.15;\n\n        // UV with applied movement\n        bokehUV = (uv * size + iTime * MOVEMENT_DIRECTION * MOVEMENT_SPEED) + offset + noiseOffset;\n\n        // Adding particles\t\t\t\t\t\t\t\tif there is more smoke, remove smaller particles\n        particles += fireParticles(bokehUV, uv) * alpha * (1.0 - smoothstep(0.0, 1.0, smoke) * (float(i) / float(layers)));\n\n        // Moving uv origin to avoid generating the same particles\n        offset += hash2_2(vec2(alpha, alpha)) * 10.0;\n\n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n\n    return particles;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fixUV(fragCoord);\n    // 大部分渲染都在render函数中进行\n    vec3 col = render(uv);\n\n    // 下面实现的是屏幕雪花特效，搬运和修改自(https://www.shadertoy.com/view/wl2Gzc)的火焰特效，可注释掉，几乎不会影响观感\n    uv = (1.2 * fragCoord - 0.6 * iResolution.xy) / iResolution.x;\n\n    float vignette = 1.0 - smoothstep(0.4, 1.4, length(uv + vec2(0.0, 0.3)));\n\n    uv *= 1.8;\n\n    float smokeIntensity = layeredNoise1_2(uv * 10.0 + iTime * 4.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.7, 0.7, 6, 0.2);\n    smokeIntensity *= pow(1.0 - smoothstep(-1.0, 1.6, uv.y), 2.0);\n    vec3 smoke = smokeIntensity * SMOKE_COLOR * 0.8 * vignette;\n\n    //Cutting holes in smoke\n    smoke *= pow(layeredNoise1_2(uv * 4.0 + iTime * 0.5 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.8, 0.5, 3, 0.2), 2.0) * 1.5;\n\n    vec3 particles = layeredParticles(uv, SIZE_MOD, ALPHA_MOD, LAYERS_COUNT, smokeIntensity);\n\n    vec3 color = particles + smoke + SMOKE_COLOR * 0.02;\n    color *= vignette;\n\n    color = smoothstep(-0.08, 1.0, color);\n\n    col += color;\n    // 雪花特效到此实现完毕\n\n    fragColor = vec4(1. - exp(-col * 2.), 1.);\n}","name":"Image","description":"","type":"image"}]}