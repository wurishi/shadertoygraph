{"ver":"0.1","info":{"id":"Xccyz8","date":"1730209532","viewed":172,"name":"particles in sci-fi box","username":"nayk","description":"originals from fractal 62 by gaz","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["fractal","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define  resolution iResolution.xy\n#define  time iTime*50.\n\n\n\n// shadertoy emulation\n\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define PI 3.141592652\nfloat circle(vec2 uv, vec2 c, float r){\n    return smoothstep(r, r+2./iResolution.x, length(uv-c));\n}\n\nfloat unsmoothstep(float mn, float mx, float x) {\n    x-=mn;\n    x/=mx-mn;\n    return x + (x - (x * x * (3.0 - 2.0 * x)));\n}\n\n\n\n#define pi 3.14159265359\n#define pi2 6.28318530718\n#define size 2e-4\n\n\nconst float dotsnbt = 90.0; // Number of dots for the tree\nconst float dotsnbs = 20.0; // Number of dots for the star (per circle)\n\n\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define sabs(p) sqrt(p * p + 1e-2)\n\nvec2 sfold(vec2 p) {\n\tvec2 v = normalize(vec2(1, -1));\n\tfloat g = dot(p, v);\n\treturn p - (g - sabs(g)) * v;\n}\n\nfloat map3(vec3 p, vec3 b, float e) {\n\tp.xy *= rot(time * 10.5);\n\tp.xz *= rot(time * 10.5);\n\tp.yz *= rot(time * 10.5);\n\tp = abs(p)-b;\n\tvec3 q = abs(p+e)-e;\n\treturn min(min(\n\t\tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n\t\tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n\t\tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\nhsv.yz = clamp (hsv.yz, 0.0, 1.0);\nreturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    \nfloat mx = max(resolution.x, resolution.y);\nvec2 scrs = resolution/mx;\n\n  vec2 uv = C/iResolution.xy;\n \n  uv.x+=1.50;\n   uv.y-=0.25;\nuv*=0.25;\nvec4 o= O;\nvec2 p=C.xy/min(resolution.x,resolution.y)*8.;\np*=rot(iTime*10.);\nvec4 fr=O;\nvec2 uv3 = (gl_FragCoord.xy - 0.5 * resolution) / resolution.y;\nuv3*=rot(iTime*10.);\n\tvec3 rd3 = normalize(vec3(uv3, 1));\n\tfloat screenZ = 4.0;\n\tvec3 p3 = vec3(0, 0, -screenZ);\n\tfor (int i = 1; i < 50; i++) {\n\t\tfloat d3 = map3(p3,vec3(1.),0.1);\n\t\tp3 += rd3 * d3;\n\t\tif (d3 < 0.001) {\n\t\t\t fr= vec4(vec3(screenZ / float(i)), 1);\n\t\t}\n\t}\nfloat a=length(p);\n\ta += 6.*time*smoothstep(0.2,0.20001,length(p-vec2(7.0,4.0))*.06+0.08*sin(time)+0.06);;\np+=0.08*tan(a)*cos(a);\n\t \no=vec4(0.20,0.3,0.0,0)*mod(floor(p.x)+floor(p.y),2.1)*(2.+sin(a+3.0))+0.1;\no.a = 1.0;\n\nvec2 pos  = vec2(0.0); // Position of the dots\nvec3 col = vec3(0.0); // Color of the dots\nfloat intensitys = 1.0/4000.0; // Light intensity for the star\n    float intensityt = 1.0/10.0; // Light intensity for the tree\nfloat scale = 0.5; // Size of the star\n  \n   \n    /*** Star ***/\nfor(float i = 0.0 ; i<dotsnbs ; i++){\n\npos = vec2(cos(time*0.2)/20.0*cos(2.0*pi*i/dotsnbs),\n  0.15*sin(2.0*pi*i*5./dotsnbs))*scale;\n        pos+= vec2(scrs.x/2.0,scrs.y*0.11);\ncol += hsv2rgb(vec3(i/dotsnbs, distance(uv,pos)*(1.0/intensitys), intensitys/distance(uv,pos)));\n\npos = vec2(0.12*cos(2.0*pi*i/dotsnbs+time*0.2),\n  0.08*sin(2.0*pi*i/dotsnbs))*scale;\npos+= vec2(scrs.x/2.0,scrs.y*0.11);\n       \ncol += hsv2rgb(vec3(1.0-i/dotsnbs, distance(uv,pos)*(1.0/intensitys), intensitys/distance(uv, pos)));\n\npos = vec2(0.12*cos(2.0*pi*i/dotsnbs+time*0.2),\n  -0.08*sin(2.0*pi*i/dotsnbs))*scale;\npos+= vec2(scrs.x/2.0,scrs.y*0.11);\n    \ncol += hsv2rgb(vec3(i/dotsnbs, distance(uv,pos)*(1.0/intensitys), intensitys/distance(uv,pos)));\n}\n   \n    float tim = -iTime*2.1;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv5 = (C/iResolution.xy - .5);\n    uv5.x*=iResolution.x/iResolution.y;\nuv5*=rot(iTime*10.);\n\n    float angl = atan(uv5.y, uv5.x);\n\n    float adir=-angl+PI*.5;\n    // -angl+PI*.5\n\n    vec3 col2 = vec3(1.);\n    const float iCount=12.;\n    for(float i=0.; i<iCount; i++){\n        float dir = floor(adir/(PI/3.)+.5)*(PI/3.);\n        \n        if(mod(i+.1, 2.)<.5){\n            // todo\n            dir = floor((adir-PI/6.)/(PI/3.)+.5)*(PI/3.) + PI/6.;\n        }\n        float timMod1 = mod(-tim+i*(1./iCount), 1.);\n        timMod1 = unsmoothstep(0.,.8,pow(smoothstep(0.,1.,timMod1),.8));\n        float circ = circle(\n            uv5, \n            vec2(sin(dir)*timMod1, cos(dir)*timMod1), \n            cos(timMod1*6.-PI*.65)*.1\n        );\n\n        col2 *= circ;\n    }\n\n    col2*=circle(uv, vec2(0.), sin(iTime)*.04+.038);\n\n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*1./e/8e3\n    )\n    {\n        n1=g*d+ col2*col;\n        n1.xy*=rot(iTime*1.);\n        n1.zy*=rot(iTime*1.);\n        n1.zx*=rot(iTime*1.);\n     n1.z+=iTime*10.;\n        \n        a=30.;\n        n1=mod(n1-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n            n1=.3-abs(n1);\n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.7+sin(iTime*.001)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 )*col2;\n         }\n         g+=e=length(n1.yzzz)/s;\n    }\n    O*=vec4(col*5.5,1.);\n     O+=vec4(col*2.5,1.);\n}\n","name":"Image","description":"","type":"image"}]}