{"ver":"0.1","info":{"id":"MfXXzX","date":"1709216827","viewed":115,"name":"Magic Torus #2","username":"PhiVape","description":"Texture applied along the inside of a torus together with custom normal map.\nLight position controllable with mouse.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","texture","normalmap","art"],"hasliked":0,"parentid":"McXSWN","parentname":"Magic Torus"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MS 100\n#define MD 100.\n#define SD .01\n#define t iTime\n#define PI 3.14159\n#define mn (PI*(2.*(iMouse.xy/iResolution.xy)-1.))\n\n\nfloat dist(vec3 p) { \n    float d = -sdTorus(p-vec3(0., 0., 0.), vec2(1.,0.8));   \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;    \n    for(int i=0; i<MS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = dist(p);\n        dO += dS;\n        if(dO>MD || dS<SD) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = dist(p);\n    vec2 e = vec2(.01, 0);    \n    vec3 n = d - vec3(\n        dist(p-e.xyy),\n        dist(p-e.yxy),\n        dist(p-e.yyx));   \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p, vec3 cam, vec3 col, vec3 texN) {\n    vec3 lightPos = vec3(0, 0, -1.7);\n    if( iMouse.z > 0.0 ) lightPos = vec3(sin(mn.x), 0, -cos(mn.x)) * 1.7;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    vec3 v = normalize(cam - p);\n    vec3 h = normalize(v + l);\n    \n    float spec = pow(max(dot(h, texN), 0.), 200.) * 1.;\n    vec3 dif = clamp(dot(texN, l), 0., 1.) * col;\n    float d = RayMarch(p+n*SD*2., l);\n    if(d<length(lightPos-p)){\n        dif *= .6;\n        spec *= 0.;\n    }\n    vec3 light = dif + vec3(spec);\n    return pow(light, vec3(0.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 0, -1.7);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);   \n    vec3 p = ro + rd * d;   \n    vec3 N = GetNormal(p);\n    \n    //spherical UV-mapping adapted to torus\n    vec2 c = normalize(vec2(p.x, p.z));   \n    vec2 UV = vec2((atan(p.x, -p.z)/(2.*PI)) + 0.5, 1.+atan(length(p.xz-c), p.y)/-PI); \n    if(sign(dot(N.xz,p.xz)) < 0.) UV.y = -UV.y + 1.; //if surface facing inward, flip up-down\n    \n    //normal mapping\n    vec3 texN = texture(iChannel1, UV).rgb;\n    vec3 T  = normalize(vec3(-p.z, 0., p.x));\n    vec3 B = cross(N, T);\n    texN = mat3(T, B, N) * (texN * 2. - 1.);\n    texN = normalize(texN);\n    \n    vec3 col = texture(iChannel0, UV).rgb;\n    fragColor = vec4(GetLight(p, ro, col, texN), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    float t = iTime;\n \n    uv *= 12.;\n    uv += vec2(t, -t);\n    \n    float d = floor(mod(uv.x -uv.y, 2.));\n    if(d == 0.) uv.xy = uv.yx;\n    \n    vec3 col = vec3(0.85);\n    if(floor(fract(uv.x)*3.) == 1.) col = vec3(0.1, 0.35 ,0.1);\n    if(floor(fract(uv.x)*3.) == 2.) col = vec3(0.48, 0.25, 0);\n    //if(abs(fract(uv.x * 3.)) < 0.06) col *= 0.;    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat osc(float min, float max, float t){\n    float r = sin(t);\n    float amp = max-min;\n    r = (r+1.)*amp*0.5 + min;\n    return r;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//normal map\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    float t = iTime;\n   \n    uv *= 12.;\n    uv += vec2(t, -t);\n    \n    float d = floor(mod(uv.x - uv.y, 2.));\n    if(d == 0.) uv.xy = uv.yx;\n    \n    float k = fract(uv.x * 3.) - 0.5;\n    vec3 norm = vec3(0., 0., 1.);\n    float width = .4;\n    if( abs(k) > width / 2. ) norm.x = 0.5 * sign(k); \n    if(d == 0.) norm.xy = norm.yx;\n    norm = normalize(norm);\n    \n    norm = norm * 0.5 + 0.5;\n    fragColor = vec4(norm,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}