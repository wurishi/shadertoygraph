{"ver":"0.1","info":{"id":"MsycWR","date":"1521577947","viewed":168,"name":"Bacteria","username":"Pr0fed","description":"Continue to learn more about procedural textures and patterns.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["proceduraltextures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-- 2D Worley noise. -------------------------------------------------------\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n//--------------------------------------------------------------------------\n\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// 3D Gradient noise by Iq.\nfloat noise3D( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n// Colors.\nvec3 GreenCyan = vec3(0.000, 0.964, 0.825);\nvec3 AquaBlue = vec3(0.000, 0.478, 0.900);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 12.;\n\n    float w = 0.85 - \n        \t  (noise3D(vec3(uv.x + iTime * 0.35, uv.y, 0.45 * iTime)) + \n         \t  (worley2D(uv * 3.)));\n    \n    vec3 col = vec3(w);\n    \n    col = mix(GreenCyan,\n              AquaBlue,\n              clamp((col * col) * 2.75, 0.0, 1.0));\n\n    // Output to screen\n    fragColor = vec4((col * col), 1.0);\n}","name":"Image","description":"","type":"image"}]}