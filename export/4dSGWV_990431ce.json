{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//At last! We have achieved the computer graphics of 1989:\n//http://www.cs.jhu.edu/~subodh/458/p253-perlin.pdf\n\n//select a fuzz!\n//#define FUZZ_TYPE 0\t\t//uniform density, not fuzzy. wuzzy?\n//#define FUZZ_TYPE 1\t\t//high freq fuzz\n//#define FUZZ_TYPE 2\t\t//lumpy fuzz\n//#define FUZZ_TYPE 3\t\t//just the falloff\n#define FUZZ_TYPE 4\t\t\t//furry fur\n\n//#define TEXTURED_LIGHT\n\n//#define POINT_LIGHT\t\n\n#define SHADOW_STEPS\t4\t\n\n//moar steps for main view = too much quality for windoze\n#define SHQ\n//#define MEDQ\n//#define YUCKQ\n\n//get rid of a few math ops for more linear noises\n#define CHEAPER_NOISES\n\n//this ray torus code is much nicer/higher quality but for some reason ANGLE does not like it!?!\n//#define IQ_RAY_TORUS\n\n#define MAIN_LOD_BIAS \t\t\t-10.\n#define MAIN_SHADOW_LOD_BIAS\t3.\n#define GROUND_SHADOW_LOD_BIAS\t3.\n\n#define SELF_SHADOW\n\n#define MAIN_TRACE\n#define SHADOW_TRACE\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord);\nvec4 Sort(vec4 n);\nvec4 RayTorus(vec3 ro, vec3 rd, float R, float r);\nfloat noise( in vec3 x, float lod_bias );\nvec2 noise2( in vec3 x, float lod_bias );\nfloat sdTorus( vec3 p, vec2 t );\nvec3 nTorus( in vec3 pos, vec2 tor );\n\n#define pi 3.1415927\n\n\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvec3 RotZ(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.y*s,\n\t\t\t\t-p.x*s+p.y*c,\n\t\t\t\tp.z);\n}\n\nvec4 quat_rotation( float half_angr, vec3 unitVec )\n{\n    float s, c;\n    s = sin( half_angr );\n    c = cos( half_angr );\n    return vec4( unitVec*s, c );\n}\n\nvec3 quat_times_vec(vec4 q, vec3 v)\n{\n\t//http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n\tvec3 t = 2. * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\t\nfloat r=.75;\nfloat R =1.2;//(1.+sin(iTime*0.7)*r*.5);\n\n\n#define RATE\t7.\t\t\t\n\nfloat density(vec3 p, float sdf, float lod_bias)\n{\n\tfloat falloff =\tmax(-sdf/r,0.);\n\n\tfloat\td = 0.1;\n#if FUZZ_TYPE == 1\n\t//high freq fuzz\n\td = noise( p*RATE*8.123, lod_bias);\n//\td=sqrt(d);\n\td*=d;\n#endif\t\n#if FUZZ_TYPE == 2\n\t//lumpy fuzz\n\td = noise( p*RATE, lod_bias);\n\td *= noise( p*(RATE*1.17), lod_bias )-0.3;// * 0.5;\n\td *= noise( p*(RATE*4.03), lod_bias )-0.2;// * 0.25;\t\t\t\t\n\td *= noise( p*(RATE*8.11), lod_bias )-0.1;// * 0.125;\nd *= 20.;\nd = max(d,0.);\n#endif\t\n#if FUZZ_TYPE == 4\n\tp += (noise2( p*1.3, lod_bias ).yxy*2.-1.)*0.25; //ought to be a vector wibble but keep it cheap!\n//\tp -= 0.9*sdf * nTorus(p,vec2(R,r));\t\t//shoot to surface\n\tp -= 0.9*sdTorus(p,vec2(R,r)) * nTorus(p,vec2(R,r));\t//maybe slightly more correct to redo sdf post warping?\n\td = noise( p*RATE*6.123, lod_bias);\t//high freq hairs\n\td*=d;\n\td = d < .2 ? 0. : d;\t\t\t\t//clip out low alpha gunk to make hairs distinct\n\t\n#endif\n#if FUZZ_TYPE > 0\n\td *= falloff;\n#endif\t\n\treturn d * .25;\n}\n\n#ifdef POINT_LIGHT\nfloat lightT = iTime;\nvec3 lightPos = vec3(0,sin(lightT),cos(lightT))*(R) + vec3(0,R,0);\n\nvec3 TexturedLight(vec3 p)\n{\n\tvec3 d = lightPos-p;\n\tfloat falloff = 1.0 / (0.1*dot(d,d)+1.);\n#ifdef TEXTURED_LIGHT\t\n\td = RotZ( d, iTime*1.7654321 );\n\tvec3 c = texture(iChannel3,d).xyz;\n\treturn c*falloff ;\n#else\t\n\treturn vec3(falloff);\n#endif\n}\n#else\nvec3 offAxis = normalize(vec3(-.25,1,1));\nvec3 lightDir = normalize(vec3(1,2,1)); //RotY( offAxis, iTime );\n\nvec3 TexturedLight(vec3 p)\n{\n#ifdef TEXTURED_LIGHT\t\n\tmat3 m = mat3(  \n\t\tvec3(0.970142,-0.000000,0.242536),\n\t\tvec3(0.168880,0.717741,-0.675521),\n\t\tvec3(-0.174078,0.696311,0.696311));\n\tp = RotY(p,-iTime);\n\tp = m * p;\n\t\n\tvec3 L = texture(iChannel2,p.xz*.1-vec2(0.25,0.5),3.).xyz;\n\tL+=sin(iTime)*0.4+0.5;\n\tL+=0.25;\n\tL*=L;\n\tL*=L;\n\treturn L;\n#else\n\treturn vec3(1);\n#endif\t\n}\n#endif //not POINT_LIGHT\n\nvec3 Trans(float thick)\n{\n\tvec3 beer = vec3(0.793,3.955,0.453);;\n\tvec3 transmittance = exp(-beer*thick);\n\treturn transmittance;\n}\n\nvec3 difColor = vec3(0.875,0.974,0.000);\nvec3 transColor = vec3(0.205,0.000,0.405);\n\n\nfloat shmarch(vec3 p, vec3 L, float start, float end, float lod_bias)\n{\n\tfloat d = 0.;\n\t\n\tfloat dt = (end-start)*(1./float(SHADOW_STEPS));\n\t\n\tp += L * (start + 0.5* dt);\n\t\n\tfor (int i=0; i<SHADOW_STEPS; i++)\n\t{\n\t\tfloat sdf = sdTorus( p, vec2(R, r) );\n\t\n\t\td += density(p,sdf,lod_bias) * dt;\n\t\tp += L * dt;\n\t}\n\t\t\t\t\t\t\t\n\treturn d*100.;\t\t\t\t\t\t\n}\n\nfloat shamarch(vec3 P, vec3 L, vec4 interval, float lod_bias)\n{\n\tfloat d = 0.;\n\t\n\tfloat start = interval.x;\n\tfloat end\t= interval.y;\n\tfloat dt = (end-start)*(1./float(SHADOW_STEPS));\n\t\n\tvec3 p = P + L * (start + 0.5* dt);\n\t\n\tfor (int i=0; i<(SHADOW_STEPS*2); i++)\n\t{\n\t\tif (i==SHADOW_STEPS)\n\t\t{\n\t\t\tstart = interval.z;\n\t\t\tend\t= interval.w;\n\t\t\tdt = (end-start)*(1./float(SHADOW_STEPS));\n\t\n\t\t\tp = P + L * (start + 0.5* dt);\n\t\n\t\t}\n\t\t\n\t\tif (start<1e5)\n\t\t{\n\t\t\tfloat sdf = sdTorus( p, vec2(R, r) );\n\t\t\n\t\t\td += density(p,sdf,lod_bias) * dt;\n\t\t\tp += L * dt;\n\t\t}\n\t}\n\t\t\t\t\t\t\t\n\treturn d*100.;\t\t\t\t\t\t\n}\n\n\nvec4 BlendUnder(vec4 accum,vec4 col)\n{\n\tcol = clamp(col,vec4(0),vec4(1));\t\n\tcol.rgb *= col.a;\n\taccum += col*(1.0 - accum.a);\t\n\treturn accum;\n}\n\nvec4 march(vec4 accum, vec3 viewP, vec3 viewD, vec4 roots)\n{\n\t//exponential stepping\n#ifdef SHQ\n\t#define STEPS\t128\t\n\tfloat slices = 512.;\n#endif\t\n#ifdef MEDQ\n\t#define STEPS\t64\t\n\tfloat slices = 256.;\n#endif\t\n#ifdef YUCKQ\t\n\t#define STEPS\t32\t\n\tfloat slices = 128.;\n#endif\n\t\n\tfloat Far = 10.;\n\t\n\tfloat tt = roots.x;\n\tfloat end = roots.y;\n\tfloat sliceStart = log2(tt)*(slices/log2(Far));\n\tfloat sliceEnd = log2(end)*(slices/log2(Far));\n\t\t\t\n\tfloat last_tt = tt;\n\t\n\tif (tt< 1e5)\n\tfor (int i=0; i<STEPS; i++)\n\t{\t\t\t\t\t\t\t\n\t\tsliceStart += 1.;\n\t\tfloat sliceI = sliceStart;// + float(i);\t//advance an exponential step\n\t\ttt = exp2(sliceI*(log2(Far)/slices));\t//back to linear\n\n\t\tvec3 p = viewP+tt*viewD;\n\t\t\t\t\t\t\n\t\tfloat sdf = sdTorus( p, vec2(R, r) );\n\n\t\tfloat dens = density(p, sdf, MAIN_LOD_BIAS);\n\t\t\n\t\tdens *= (tt-last_tt)*100.;\t//density ought to be proportional to integral over step length?\n\t\tlast_tt = tt;\n\n#ifdef POINT_LIGHT\t\t\n\t\tvec3 lightDir = lightPos-p;\n\t\tfloat light_dist = length(lightDir);\n\t\tlightDir = normalize(lightDir);\n#endif\n\t\t\n\t\t//amount of stuff light had to go through to get here\n\t\tvec4 shadow_roots = RayTorus(p, lightDir, R, r);\n#ifdef SELF_SHADOW\t\t\n\n//\t\tfloat thick = shamarch(p, lightDir, vec4(0.,shadow_roots.xyz), MAIN_SHADOW_LOD_BIAS);\n\t\t\t\n#ifdef POINT_LIGHT\t\t\n\t\tshadow_roots[0]=min(shadow_roots[0],light_dist);\n#endif\n\t\t//well this must be an exit cos we started inside\n\t\tfloat thick = shmarch(p, lightDir, 0., shadow_roots[0], MAIN_SHADOW_LOD_BIAS);\n\n\t\tif (shadow_roots[1]<1e5)\t//and there might be another segment\n\t\t{\n#ifdef POINT_LIGHT\t\t\n\t\t\tshadow_roots.yz=min(shadow_roots.yz,vec2(light_dist));\n#endif\t\t\t\n\t\t\tthick += shmarch(p, lightDir, shadow_roots[1], shadow_roots[2], MAIN_SHADOW_LOD_BIAS);\n\t\t}\n#else\n\t\tfloat thick = 0.2;//shadow_roots.x+shadow_roots.z-shadow_roots.y;\n#endif\n\t\t\n\t#if 1\t\n\t\t//surface-like reflection term falling off towards interior of torus\n\t\tvec3 n = nTorus( p, vec2(R, r) );\n\t\tfloat dif = max(dot(n,lightDir),0.);\n\t\tfloat reflective = 1.-(abs(sdf)/r);\n\t\treflective*=reflective;\n\t\treflective*=reflective;\n\t\tdif *= reflective;\n\t#endif\t\n\t\t\t\t\n\t\tvec3 transmittance = Trans(thick);\n\t\t\t\n\t\tfloat shadow = max(1.-thick,0.);\t\t\n\t//\tvec3 c = vec3(transColor+dif*difColor) * shadow;\n\t//\tvec3 c = vec3(transColor) * shadow;\n\t\t\n\t\tvec3 c = vec3(transColor+dif*difColor) * transmittance;\n\n\t#if 0\t\n\t\tfloat fy = -(R+r);\t\t\t\t//the floor\n\t\tfloat h = p.y - fy;\t\t\t\t//distance to floor\n\t\th = max(1. - (h/(1.*(R+r))),0.);\t\t//fall off\n\t\tc += vec3(max(-n.y*.05,0.0))*h;\t//downwards normals get some floor bounce\n\t#endif\n\t\t\n\t//\tvec3 c = vec3(transColor) * transmittance;\n\t\t\n\t\tc *= TexturedLight(p);\n\t\t\n\t\taccum = BlendUnder(accum,vec4(c,dens));\n\n\t\tif (accum.a > 0.99) break;\n\t\t\n\t\t//if (sliceI > sliceEnd) break; //out of exponential steps\t\n\t\tif (sliceI > sliceEnd)\n\t\t{\n\t\t\t//go to next interval\n\t\t\ttt = roots.y;\n\t\t\tend = roots.w;\n\t\t\tsliceStart = log2(tt)*(slices/log2(Far));\n\t\t\tsliceEnd = log2(end)*(slices/log2(Far));\t\n\t\t\tlast_tt = tt;\n\t\t\n\t\t\tif (tt> 1e5) break;\n\t\n\t\t}\n\t}\t\n\t\n\treturn accum;\n}\n\nfloat Q(float a, float b, float c)\n{\n\tfloat d = b*b-4.0*a*c;\n\tif (d < 0.0) return -1.0;\n\td=sqrt(d);\t\n\tfloat oo2a = 0.5/a;\n\treturn (-b-d)*oo2a; //min((-b-d)*oo2a,(-b+d)*oo2a);\n}\n\nfloat RaySphere(vec3 P, vec3 V, vec3 A, float r)\n{\n\treturn Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-r*r-(2.0*(dot(A,P))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD, fragCoord);\n\n\t//ground plane\n\tfloat floor_height = -(R+r);\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\tvec3 c = texture(iChannel0,p.xz*0.1).xyz;\n\tc = pow(c,vec3(2.2));\n\n#ifdef SHADOW_TRACE\n\n#ifdef POINT_LIGHT\t\n\tvec3 lightDir = lightPos-p;\n\tfloat lightDist = length(lightDir);\n\tlightDir = normalize(lightDir);\n#endif\t\n\t//darken by shadow ray through torus\n\tvec4 shadow_roots = RayTorus(p, lightDir, R, r);\n\tfloat thick=0.;\n\t\n\tfor (int i=0; i<4; i+=2)\n\t{\n\t\tif (shadow_roots[i]<1e5)\n\t\t{\n\t\t\tvec2 sh = vec2(shadow_roots[i],shadow_roots[i+1]);\n#ifdef POINT_LIGHT\t\t\t\n\t\t\tsh = min(sh,vec2(lightDist));\n#endif\t\t\t\t\n\t\t\tthick += shmarch(p, lightDir, sh.x, sh.y, GROUND_SHADOW_LOD_BIAS);\n\t\t}\n\t}\n\n\tc *= max(lightDir.y,0.);\n\t\n\tc *= clamp(Trans(thick)+.2,0.,1.)*TexturedLight(p);\n\t\n\tfloat sdf = sdTorus( p, vec2(R, r) );\n\tc *= min(abs(sdf)+.1,1.);\t\t\t\t\t//block light/blob shadow\n\tc += transColor * max(1.-abs(sdf),0.)*.2;\t//bounce from floor\n#endif\t\n\n#ifdef MAIN_TRACE\t\t\n\t//ray marching segments of torus intersections\n\tvec4 roots = RayTorus(viewP, viewD, R, r);\n\n\tvec4 accum = vec4(0);\n\t\n#ifdef POINT_LIGHT\n\tfloat lightT = RaySphere(viewP, viewD, lightPos, 0.1);\n\tif (lightT >0.)\n\t{\n\t\tif (lightT < roots[0])\n\t\t{ \n\t\t\taccum = vec4( TexturedLight(viewP + lightT * viewD), 1.0); \n\t\t}\n\t}\t\n#endif\n\n\t\t\n//\taccum = march(accum,viewP, viewD, roots[0],roots[1]);\n//\taccum = march(accum,viewP, viewD, roots[2],roots[3]);\n\taccum = march(accum,viewP, viewD, roots);\n\t\n\t//comp over background \n\tc = BlendUnder(accum,vec4(c,1.)).xyz;\n//\tc = mix(c,accum.xyz,accum.w);\n#endif\n\t\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}\n\nvoid MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.);\n\teye = vec3(2.5,3.,-2.5) * 1.5; \t\n\teye = RotY(eye,iTime*.4);\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\t//jitter to de-band\n\teye += ray * texture(iChannel1,p).x;\n}\n\nvec4 Sort( vec4 a)\n{\n\tvec4 m = vec4(min(a.xz,a.yw), max(a.xz,a.yw) );\n\tvec4 r = vec4(min(m.xz,m.yw), max(m.xz,m.yw) ); \n\ta = vec4( r.x, min(r.y,r.z),  max(r.y,r.z), r.w );\n\treturn a;\n}\n\n#define SMALL_ENOUGH 1e-4\n\n\n#ifdef IQ_RAY_TORUS\n//thanks iq!\n//https://www.shadertoy.com/view/4sBGDy\n//slight modifications to return ALL intersections\nvec4 RayTorus( in vec3 ro, in vec3 rd, float torus_R, float torus_r )\n{\n\tfloat Ra2 = torus_R*torus_R;\n\tfloat ra2 = torus_r*torus_r;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)*0.5;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    //----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp /= 3.0;\n\tr /= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R/(sQ*Q)) *(1.0/3.0) );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n\t\tz = sign(R)*abs( sQ + Q/sQ );\n\n\t}\n\t\n\tz = p - z;\n\t\n    //----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<SMALL_ENOUGH ) //this tolerance appears to be deeply annoying to tune. :(\n\t{\n\t\tif( d2<0.0 ) return vec4(1e20);\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return vec4(1e20);\n\t\td1 = sqrt( d1*0.5 );\n\t\td2 = q/d1;\n\t}\n\t\n    //----------------------------------\n\t\n\tvec4 result = vec4(1e20);\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t\n\t\tresult[0]=t1;\n\t\tresult[1]=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\tresult[2]=t1;\n\t\tresult[3]=t2;\n\t}\n\t\n\tfor (int i=0; i<4; i++) if (result[i]<0.) result[i]=1e20;\n\tresult = Sort(result);\n\treturn result;\n}\n\n#else //not IQ_RAY_TORUS buggy solver from POV Ray but keeps ANGLE happy?!!\n\n\n//https://github.com/POV-Ray/povray/blob/3.7-stable/source/backend/math/polysolv.cpp#L808\n\n#define DBL float \n\nfloat solve_cubic(float a1, float a2, float a3)\n{\n\tDBL Q, R, Q3, R2, sQ, d, an, theta;\n\tDBL A2;\n\t\n\tA2 = a1 * a1;\n\n\tQ = (A2 - 3.0 * a2) * (1./ 9.0);\n\n\t/* Modified to save some multiplications and to avoid a floating point\n\t   exception that occured with DJGPP and full optimization. [DB 8/94] */\n\n\tR = (a1 * (A2 - 4.5 * a2) + 13.5 * a3) * (1./ 27.0);\n\n\tQ3 = Q * Q * Q;\n\n\tR2 = R * R;\n\n\td = Q3 - R2;\n\n\tan = a1 * (1./3.);\n\n\tif (d >= 0.0)\n\t{\n\t\t/* Three real roots. */ //but only use the first!\n\n\t\td = R * inversesqrt(Q3);\n\n\t\ttheta = acos(d) * (1. / 3.0);\n\n\t\tsQ = -2.0 * sqrt(Q);\n\n\t\treturn sQ * cos(theta) - an;\n\t}\n\n\tsQ = pow(sqrt(R2 - Q3) + abs(R), 1.0 / 3.0);\n\n\tDBL t = sQ + Q / sQ;\n\t\n\tt = R < 0. ? t : -t;\n\treturn t - an;\n}\n\nvoid quartic_descartes(float c1, float c2, float c3, float c4, inout vec4 results)\n{\n\tDBL c12, z, p, q, q1, q2, r, d1, d2;\n\t\n\t/* Compute the cubic resolvant */\n\n\tc12 = c1 * c1;\n\tp =  -6. * c12 + 4.*c2;\n\tq =  c12 * c1 - c1 * c2 + c3;\n\tq *= 8.;\n\tr = -3. * c12 * c12 + c12 *4.*c2 - c1 * 8.*c3 + 4.*c4;\n\t\t\t\t\n\tfloat cubic_a1 = -0.5 * p;\n\tfloat cubic_a2 = -r;\n\tfloat cubic_a3 = 0.5 * r * p - 0.125 * q * q;\n\n\tz = solve_cubic(cubic_a1, cubic_a2, cubic_a3);\n\n\td1 = 2.0 * z - p;\n\n\tif (d1 < 0.0)\n\t{\n\t\tif (d1 > -SMALL_ENOUGH)\n\t\t{\n\t\t\td1 = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (d1 < SMALL_ENOUGH)\n\t{\n\t\td2 = z * z - r;\n\n\t\tif (d2 < 0.0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\td1 = sqrt(d1);\n\t\td2 = 0.5 * q * (1./ d1);\n\t}\n\n\t/* Set up useful values for the quadratic factors */\n\n\tq1 = d1 * d1;\n\tq2 = -c1;\n\n\t/* Solve the first quadratic */\n\n\tp = q1 - 4.0 * (z - d2);\n\n\tif (p > 0.)\n\t{\n\t\tp = sqrt(p);\n\t\tresults[0] = -0.5 * (d1 + p) + q2;\n\t\tresults[1] = -0.5 * (d1 - p) + q2;\n\t}\n\n\t/* Solve the second quadratic */\n\n\tp = q1 - 4.0 * (z + d2);\n\n\tif (p > 0.)\n\t{\n\t\tp = sqrt(p);\n\t\tresults[2] = 0.5 * (d1 + p) + q2;\n\t\tresults[3] = 0.5 * (d1 - p) + q2;\n\t}\n}\n\n//watch out, unstable on \"small\" R, r, certain planes and slight breezes!! :(\n//http://research.microsoft.com/en-us/um/people/awf/graphics/ray-torus.html\nvec4 RayTorus(vec3 A, vec3 B, float R, float r)\n{\n\t//B assumed normalized\n\t\n\tfloat aa = dot(A,A);\n\tfloat ab = dot(A,B);\n\t\t\n\t// Set up quartic in t:\n\t//\n\t//  4     3     2\n\t// t + A t + B t + C t + D = 0\n\t//\n\t\n\tfloat R2 = R*R;\n\tfloat K = aa - r*r - R2;\n\tK *= 0.5;\n\tfloat qA = ab;\n\tfloat qB = ab*ab + K + R2*B.z*B.z;\n\tfloat qC = K*ab + R2*A.z*B.z;\n\tfloat qD = K*K +  R2*(A.z*A.z - r*r);\n\n    // 4t^3 + 3At^2 + 2Bt + C\n\t//12t^2 + 6At   + 2B\n\t\n\tvec4 roots = vec4(1e10);\n\tquartic_descartes(qA,qB,qC,qD, roots);\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tif (roots[i] < 0.) \n\t\t\troots[i] = 1e10;\t\n\t}\n\t\n\troots = Sort(roots);\n\t\t\n\treturn roots;\n}\n\n#endif\n\n//iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nfloat noise( in vec3 x, float lod_bias )\n{\t\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n#ifndef CHEAPER_NOISES\t\n\tf = f*f*(3.0-2.0*f);\t//not terribly noticeable for higher freq noises anyway\n#endif\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n#ifdef CHEAPER_NOISES\t\n\tvec2 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yx;\n#else\t\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, lod_bias ).yx;\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 noise2( in vec3 x, float lod_bias )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n#ifndef CHEAPER_NOISES\t\n\tf = f*f*(3.0-2.0*f);\n#endif\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n#ifdef CHEAPER_NOISES\t\n\tvec4 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yxwz;\n#else\n\tvec4 rg = texture( iChannel1, (uv+ 0.5)/256.0, lod_bias ).yxwz;\n#endif\t\n\treturn mix( rg.xz, rg.yw, f.z );\n}\n\n/*\n$num = hex $ARGV[0];\nprint \"vec3(\";\nfor ($i=0; $i<3; $i++)\n{\n\t$c = ($num >> ((2-$i)*8))&255;\n\t$f = $c / 255.0;\n\t$f = $f ** 2.2;\n\t$f = -log($f)/$thickness;\n\tprintf( \"%.3f\", $f);  \n\tif ($i < 2)\n\t{\n\tprint \",\";\n\t}\n}\nprint \");\";\n*/\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSGWV","date":"1393417946","viewed":1387,"name":"Furry Torus","username":"Antonalog","description":"At last! We have achieved the computer graphics of 1989: http://www.cs.jhu.edu/~subodh/458/p253-perlin.pdf\nMaybe realtime in 2019?  A bunch of quality sacrifices to make web GL happy. Play with the defines if you have a good rig. :)","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","torus","shadow","fur","beer","donut"],"hasliked":0,"parentid":"","parentname":""}}