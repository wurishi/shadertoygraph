{"ver":"0.1","info":{"id":"4323zG","date":"1708713502","viewed":70,"name":"Highly configurable tonemap","username":"lowellcamp","description":"Many techniques for mapping an HDR color onto a display involve hue shifts. However, most of them offer only control over the amount of shift towards the notorious 6.\nThis tonemap gives explicit control over both the direction and amount of hue shift.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tonemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y = ceil(24.0 * uv.y) / 24.0;\n    uv.x = round(48.0 * uv.x) / 48.0;\n    \n    float hue = 1.0 - uv.y;\n    float x_b = 2.0 * uv.x - 1.0;\n    // +- 10 stops, centered on half brightness\n    float brightness = exp2(10.0 * x_b - 1.0);\n    \n    \n    // Hue to RGB, fully saturated\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n    vec3 color = brightness * saturate(abs(fract(hue+K.xyz)*6.-K.w)-K.x);\n    \n    color = tonemap(color);\n    \n    if ((int(fragCoord.x + fragCoord.y) + iFrame) % 16 <= 8 && max(max(color.r, color.g), color.b) > 1.0) {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TWO_PI 6.28318530718\n\nconst float HDR_MAX = exp2(8.0);\nconst float CONTRAST = 1.0;\nconst float SHOULDER = 0.9;\n\nconst float SHOULDER_SATURATION = 1.5;\n\nconst float MID_IN = 0.25;\nconst float MID_OUT = 0.2;\n\nconst vec3 HUE_SHIFT = vec3(0.2, 0.0, -0.2);\n\n// Prevent instability from shoulder manipulations\nconst float shoulder_min = 1.0 + log(MID_OUT) /\n    (CONTRAST * (log(HDR_MAX) - log(MID_IN)));\nconst float shoulder = mix(shoulder_min, 1.0, SHOULDER);\n\n// Anchor the white point\nconst float bc_denom = (pow(HDR_MAX, CONTRAST * shoulder) - pow(MID_IN, CONTRAST * shoulder)) * MID_OUT;\nconst float b = (-pow(MID_IN, CONTRAST) + pow(HDR_MAX, CONTRAST) * MID_OUT) / bc_denom;\nconst float c = (pow(HDR_MAX, CONTRAST * shoulder) * pow(MID_IN, CONTRAST) - pow(HDR_MAX, CONTRAST) * pow(MID_IN, CONTRAST * shoulder) * MID_OUT) / bc_denom;\n\n// ref: Lottes https://gpuopen.com/wp-content/uploads/2016/03/GdcVdrLottes.pdf\nfloat _tonemap(float x) {\n    x = pow(x, float(CONTRAST));\n    return x / (pow(x, float(shoulder)) * b + c);\n}\n\n// ref: https://gist.github.com/ForeverZer0/f4f3ce84fe8a58d3ab8d16feb73b3509\nvec3 hueShift(vec3 col, float hue) {\n    const vec3 k = vec3(0.57735);\n    float cosAngle = cos(hue);\n    return vec3(col * cosAngle + cross(k, col) * sin(hue) + k * dot(k, col) * (1.0 - cosAngle));\n}\n\nfloat smax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k; \n    return max(a, b) + 0.25 * h * h * k;\n}\n\nvec3 tonemap(vec3 color) {\n    float lum = length(color) / length(vec3(1.0));\n    float mapped_lum = min(_tonemap(lum), 1.0);\n    color *= mapped_lum / lum;\n    \n    float desat = smoothstep(0.0, 1.0, pow(mapped_lum, SHOULDER_SATURATION));\n    \n    float shift = dot(color, HUE_SHIFT) * desat;\n    \n    color = hueShift(color, shift * TWO_PI / 6.0);\n    color /= smax(1.0, max(max(color.r, color.g), color.b), 0.25);\n    color = mix(color, vec3(mapped_lum), desat * desat);\n    \n    return color;\n}","name":"Common","description":"","type":"common"}]}