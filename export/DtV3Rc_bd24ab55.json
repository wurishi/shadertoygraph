{"ver":"0.1","info":{"id":"DtV3Rc","date":"1684364851","viewed":64,"name":"Ray Tracing in a Saturday","username":"lpsoares","description":"This is a partial adaptation of Peter Shirley, Ray Tracing in One Weekend for GLSL in Shadertoy.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raytracinginoneweekend"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Tipos de Materias implementados\n#define lambertian 0\n#define metal 1\n\n// Definições de material dos objetos\nstruct Material {\n  vec3 albedo; // na prática a cor do objeto\n  int type; // tipo (lambertiam ou metal)\n};\n\n// Raio lançado diretamente ou refletido\nstruct Ray {\n  vec3 origin, direction;\n};\n\n// Estrutura para controle de colisões de raios\nstruct hit_record {\n  float t;\n  vec3 p, normal;\n  Material mat;\n};\n\n// Definições para esferas\nstruct Sphere {\n  vec3 center;\n  float radius;\n  Material mat;\n};\n\n// Rotinas para números aleatórios\nvec3 frand;\nvec3 rand = vec3(0.5, 0.5, 0.5);\nvec2 rand2(){ \n  vec2 rand = vec2(\n    mod(rand.y*(195.1*frand.z+371.2*frand.x+508.3*frand.y), 1.0),\n    mod(rand.x*(573.9*frand.z+736.4*frand.y+914.5*frand.x), 1.0)\n  );\n  return fract(rand).xy-0.5;\n}\n\nvec3 random_in_unit_sphere(){ \n  rand = vec3(\n    mod(rand.z*((7.1*frand.z)+(5.1*frand.x)+(9.7*frand.y))*3.83,2.0),\n    mod(rand.x*((1.1*frand.z)+(6.7*frand.x)+(4.9*frand.y))*1.57,2.0),\n    mod(rand.y*((3.1*frand.z)+(4.3*frand.x)+(5.2*frand.y))*2.34,2.0)\n  );\n  return (rand-vec3(1.0));\n}\n\nvec3 random_unit_vector() {\n    return (normalize(random_in_unit_sphere()));\n}\n\nvec3 random_in_hemisphere(vec3 normal) {\n    vec3 in_unit_sphere = random_in_unit_sphere();\n    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal\n        return in_unit_sphere;\n    else\n        return -in_unit_sphere;\n}\n\n\n// Verifica se um vetor ter todas suas coordenadas muito pequenas\nbool near_zero(vec3 e) {\n  float s = 1e-8;\n  return (abs(e[0]) < s) && (abs(e[1]) < s) && (abs(e[2]) < s);\n}\n\n\n// Retornando o ponto em um t de raio\nvec3 point_at_parameter(Ray r, float t) {\n  return(r.origin + t*r.direction);\n}\n\n// Verificando o lado da face correto\nvec3 set_face_normal(Ray r, vec3 outward_normal) {\n    bool front_face = dot(r.direction, outward_normal) < 0.0;\n    return front_face ? outward_normal :-outward_normal;\n}\n\n\n// Cria o raio para o pixel da tela\nRay get_ray(vec2 uv) {\n  float aspect = iResolution.x/iResolution.y;\n  vec3 lower_left_corner = vec3(-1.0*aspect,-1.0, -1.0);\n  vec3 horizontal = vec3(2.0*aspect, 0.0, 0.0);\n  vec3 vertical = vec3(0.0,2.0, 0.0);\n  \n  Ray r = Ray(vec3(0,0,0), lower_left_corner+uv.x*horizontal+uv.y*vertical); \n  return r;\n}\n\n// Verifica e atualiza dados no caso da intersecção de um raio\nbool hit_sphere(Sphere s, Ray r, float t_min, float t_max, out hit_record rec){\n  vec3 oc = r.origin - s.center;\n  float a = dot(r.direction,r.direction);\n  float half_b = dot(oc, r.direction);\n  float c = dot(oc,oc) - s.radius*s.radius;\n  float discriminat = half_b*half_b - a*c;\n  if (discriminat < 0.0) return(false);\n  float sqrtd = sqrt(discriminat);\n  \n  float root = (-half_b - sqrtd) / a;\n  if (root < t_min || t_max < root) {\n    root = (-half_b + sqrtd) / a;\n    if (root < t_min || t_max < root)\n      return false;\n  }\n      \n  rec.t = root;\n  rec.p = point_at_parameter(r,rec.t);\n  \n  vec3 outward_normal = (rec.p - s.center) / s.radius;\n  rec.normal = normalize(set_face_normal(r, outward_normal));\n  rec.mat = s.mat;\n    \n  return(true);\n}\n\n// Cálculo para os raios refletidos de alguma forma\nbool scatter(Material mat, Ray r_in, hit_record rec, out vec3 attenuation, out Ray scattered) {\n  \n  vec3 scatter_direction = rec.normal + random_unit_vector();\n  \n  if (near_zero(scatter_direction))\n    scatter_direction = rec.normal;\n\n  if(mat.type == 0) {\n    scattered = Ray(rec.p, scatter_direction);\n    attenuation = mat.albedo;\n    return true;\n  }\n\n  if(mat.type == 1) {\n    vec3 reflected = reflect(normalize(r_in.direction), rec.normal);\n    scattered = Ray(rec.p, reflected);\n    attenuation = mat.albedo;\n    return(dot(scattered.direction, rec.normal) > 0.0);\n  }\n  \n  return false;\n  \n}\n\n\n\n// ---------------------------------------------------------------------- //\n// Definição da cena\nSphere world[] = Sphere[4](\n  Sphere(vec3( 0.0, -100.5, -1.0), 100.0, Material(vec3(0.8, 0.8, 0.0),0)),\n  Sphere(vec3( 0.0, 0.0, -1.0), 0.5, Material(vec3(0.7, 0.3, 0.3),0)),\n  Sphere(vec3(-1.0, 0.0, -1.0), 0.5, Material(vec3(0.8, 0.8, 0.8),1)),\n  Sphere(vec3( 1.0, 0.0, -1.0), 0.5, Material(vec3(0.8, 0.6, 0.2),1))\n);\n// ---------------------------------------------------------------------- //\n\n\n// Trata lista de todos os objetos da cena\nbool hitable_list(Ray r, float t_min, float t_max, inout hit_record rec) {\n  hit_record temp_rec;\n  bool hit_anything = false;\n  float closest_so_far = t_max;\n  for(int i=0; i<world.length(); i++) {\n    if(hit_sphere(world[i], r, t_min, closest_so_far, temp_rec)) {\n      hit_anything = true;\n      closest_so_far = temp_rec.t;\n      rec = temp_rec;\n    }\n  }\n  return hit_anything;\n}\n\n\n// Rotina que calcula a cor final do pixel\nconst int max_depth = 10;\nvec3 color(Ray r){\n  hit_record rec;\n  vec3 col = vec3(1.0);\n  Ray raio = r;\n  for(int i=0; i < max_depth; i++){\n    if(hitable_list(raio, 0.0001, 100.0, rec)) {\n    \n      Ray scattered;\n      vec3 attenuation = vec3(0.0);\n      \n      if (scatter(rec.mat, r, rec, attenuation, scattered))\n        raio = scattered;\n      else break;\n      \n      col *= attenuation;      \n\n    } else {\n      vec3 unit_direction = normalize(r.direction);\n      float t = 0.5 * (unit_direction.y + 1.0);\n      col *= mix(vec3(1.0), vec3(0.5,0.7,1.0), t);\n      return col;\n    }\n  }\n  return col;\n}\n\n\nconst float samples_per_pixel = 10.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 col = vec3(0.0);\n  for(float s=2.0; s<=samples_per_pixel; ++s) {\n      frand = vec3(fragCoord.xy,s);\n      vec2 delta;\n      delta = rand2() / iResolution.xy;\n      Ray r = get_ray(uv+delta);\n      col += color(r);\n  }\n  col /= samples_per_pixel;\n  float gamma = 2.0;\n  col = pow(col, vec3(1.0/gamma));\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}