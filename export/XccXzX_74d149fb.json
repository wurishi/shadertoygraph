{"ver":"0.1","info":{"id":"XccXzX","date":"1714388744","viewed":116,"name":"Ray to cell boundary","username":"sylvain69780","description":"Simple illistration of some code for grid traversal.\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["voxelgridtraversal"],"hasliked":0,"parentid":"DsyBWR","parentname":"A Square within a Square"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Illustration of simple grid traversal.\n    \n    References (Voxels)\n        Xor     https://www.shadertoy.com/view/XctXzj\n        fb39ca4 https://www.shadertoy.com/view/4dX3zl\n        IQ      https://www.shadertoy.com/view/4dfGzs\n        Shane   https://www.shadertoy.com/view/MdVSDh â¤\n        ...\n\n*/\n\nmat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c,s,-s,c);}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat blend(float sf, float d) { return smoothstep(sf,-sf,d); }\n\nfloat sdArrow(vec2 p, float s)\n{\n    p.y = abs(p.y);\n    float d = length(vec2(p.x-clamp(p.x,0.,s),p.y));\n    d = min(d,sdSegment(p, vec2(s,0), vec2(s-.05,0.05)));\n    return d;\n}\nmat2 align(vec2 rd)\n{\n    return mat2(rd.x,-rd.y,rd.y,rd.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m1=(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 m2=(2.0*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n    vec2 b = sign(iMouse.zw);\n    float time = iTime;\n    \n\tvec2 ro = .25*cos(vec2(time,time*1.23));   \n    vec2 rd = vec2(cos(time),sin(time));\n    \n    if ( iMouse.x > 0.0 ) \n    {\n        ro = clamp(m2,-.5,.5);\n        vec2 rd2 = m1 - ro;\n        if ( length(rd2) > 0. )\n            rd = normalize(rd2);\n    }\n    float sf = 1.5/iResolution.y; // smoothing factor   \n    const float border = 0.005;\n    vec3 col = vec3(.2,.3,.9);\n    vec2 grid = abs(fract(uv)-.5);\n    col += blend(sf,min(grid.x,grid.y)-border);\n    col += blend(sf,abs(length(uv-ro)-.025)-border);\n    col += blend(sf,sdArrow(align(rd)*(uv-ro),.2)-border);\n    // ray to cell boundary\n    vec2 faces = sign(rd)*.5;\n    // distances to cell faces\n    vec2 d = (faces-ro)/rd;\n    float t = min(d.x,d.y);\n    vec2 np = ro + t*rd;\n    col += blend(sf,abs(length(uv-np)-.025)-border);\n    col += blend(sf,sdSegment(uv,ro,np)-border)*.2;\n    // normal and next cell\n    vec2 cell = vec2(0);\n    col += blend(sf,abs(length(uv-cell)-.025)-border);    \n    vec2 n = -sign(rd) * step(d.xy, d.yx);\n    col += blend(sf,abs(length(uv+n)-.025)-border);    \n    // light\n    col *= cos(length(uv)*.8);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}