{"ver":"0.1","info":{"id":"MlGGWG","date":"1476481685","viewed":179,"name":"Silver Mandelbox","username":"stduhpf","description":"I'm just trying to display the mandelbox , not optimised at all.\nIt's called silver mandelbox, because Golden Mandelbox was already taken, but this one have the golden ratio as scale constant.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","mandelbox","slooow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    O= texture(iChannel0,I/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Progressive_aa\n#define aa .95\n\n//#define animate //you should disable aa (exept if you have a really good framerate)\n\n//#define Flat_Projection  //casts parallel rays (looks good when zooming inside the fracal(mostly with abs(scaling)>2.))\n\n\n//fractal constants(you can change them\n#define fr_it 20\n#define ballminrad .5\n#define ballmaxrad 1.\n#define scaling -1.618033989 //original is 2.(change the camera distance to 30. in that case)\n\n//raytracer settings\n#define prec .0001\n#define raymaxit 1000\n#define time iTime*.1\n//#define shadows //divide framerate by ~10\n\n//camera settings\n#ifdef animate\n#define camera_distance 40.*exp(-.5*time)\n#else\n#define camera_distance 8.\n#endif\n#define pseudo_fov .75\n#define viewdist 80.\n\n\nvec3 boxfold(vec3 c){\n    return clamp(c,-1.,1.)*2.-c;\n}  \nfloat ballfold(vec3 c)\n{\n    float r=ballminrad,f=ballmaxrad;\n    float m=length(c);\n    return m<=r?1./(r*r):(m<f?f/m:1.);\n}\nvec2 map(vec3 b)\n{\n\tfloat dr =abs(scaling);\t\n    vec3 u = b;\n    for(int i =0;i<fr_it;i++)\n    {\n        b= boxfold(b);\n        float bf = ballfold(b);\n        b=scaling*b*bf+u;\n        dr = bf*dr*abs(scaling)+1.;\n      }\n return vec2(length(b)/dr,1) ;    \n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(prec,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 intersect(vec3 ro, vec3 rd,float n)\n{\n    float f=0.;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<prec)\n                return vec2(f,h.x);\n               \tif(f > n)\n           break;\n            f+=h.x;\n    }\n    return vec2(0);\n}\n#ifdef shadows\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float f=0.01;\n    float e = 1.;\n    for(int i = 0; i <raymaxit; i++)\n    {\n        float d = map(ro+f*rd).x;\n        \n            if(d<prec)\n            {\n                e=0.;\n             break;\n            }\n            f+=d;\n        e=min(e,8.*d/f);\n    }\n    return clamp(e,0.,1.);\n}\n\n#endif\n\nfloat ao(vec3 p, vec3 n,float s)\n{\n    const float ao_it =5.;\n    float d=0.;\n    float sm =0.;\n    for(float i=1.;i<ao_it;i++)\n    {\n        d+=s;\n        float h = map(p+d*n).x;\n        sm+=(d-h)/pow(2.,i);\n    }\n    return 1.-sm*4.;\n\n}\n\nfloat hash( float n )\n{\n    return (fract(sin(n)*43758.5453)-.5);\n}\n\nvoid mainImage( out vec4 fcol, in vec2 fragCoord )\n{\t\n    vec4 back = texture(iChannel0,fragCoord/iResolution.xy);\n    #ifdef Progressive_aa\n    fragCoord.xy+=vec2(hash(iDate.w+fragCoord.x),hash(fragCoord.y-iDate.w));\n    #endif\n    vec2 uv = fragCoord.xy / iResolution.x- vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.;\n    if(iMouse.xy==vec2(0))\n        mse*=0.;\nmat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n#ifdef Flat_Projection\n    vec3 ro = vec3(uv,-1.)*rdroty*rdrotx*camera_distance;\n    vec3 rd = normalize(vec3(0,0,pseudo_fov))*rdroty*rdrotx;\n    #else   \n    vec3 ro = vec3(0,0,-1.)*rdroty*rdrotx*camera_distance;\n    vec3 rd = normalize(vec3(uv,pseudo_fov))*rdroty*rdrotx;\n    #endif\n    float m =0.;\n    vec2 i = intersect(ro,rd,viewdist);\n    vec3 ld = normalize(vec3(1,1,-1));\n    \n    m+=.02/distance(rd,ld);\n    if(i.x>0.)\n    {\n    vec3 pos = ro+i.x*rd;\n    vec3 nor = normal(pos); \n    float amb =ao(pos,nor,.05);//cheap fake ambiant occlusion\n        m=amb;\n        #ifdef shadows\n       float sh =shadow(pos,ld); //softshadows\n        #else\n        float sh = 1.;\n        #endif\n        m*=max(.1,dot(nor,ld)*sh); //aplly lighting\n        rd = reflect(rd,nor);\n    m+=clamp(.02/distance(rd,ld)*sh,0.,1.); //specular highlighting\n        \n    }\n   \n    vec4 col = vec4(m);\n    \n    #ifdef Progressive_aa\n    col= mix(col,back,aa);\n    #endif\n    \n    fcol = col;\n}","name":"Buf A","description":"","type":"buffer"}]}