{"ver":"0.1","info":{"id":"Wsf3Dl","date":"1551618117","viewed":1083,"name":"Volumetric ray marching","username":"Keyaki","description":"This is a volumetric ray marching experiment.\n\nBased on this article: https://shaderbits.com/blog/creating-volumetric-ray-marcher/\nNoise functions are from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n","likes":13,"published":1,"flags":32,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n// Simplex 4D Noise\n// by Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip)\n{\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n    return p;\n}\n\nfloat snoise(vec4 v)\n{\n    const vec2 C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n    // First corner\n    vec4 i  = floor(v + dot(v, C.yyyy) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C\n    vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n    vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n    vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n    vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n    // Permutations\n    i = mod(i, 289.0);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n                + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n                + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n                + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    // Gradients\n    // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nconst float Epsilon      = 0.001f;\nconst int   Steps        = 192;\nconst float InvSteps     = 1.0f / float( Steps );\nconst int   ShadowSteps  = 512;\nconst float VolumeRadius = 1.0f;\n\nfloat distanceFunction( in vec3 pos )\n{\n    return length( pos ) - VolumeRadius;\n}\n\nfloat getVolumeTexture( in vec4 pos )\n{\n    float t = pos.w;\n    vec4 pos1 = vec4( pos.xyz * 1.1, t * 0.2 );\n    vec4 pos2 = vec4( pos.xyz * 3.7, t * 0.7 );\n    vec4 pos3 = vec4( pos.xyz * 7.1, t * 1.5 );\n\n    float c1 = 16.0;\n    float c2 = 3.0;\n    float c3 = 0.5;\n\n    return smoothstep(\n        0.0,\n        1.0,\n        snoise( pos1 ) * c1 + snoise( pos2 ) * c2 + snoise( pos3 ) * c3 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float CameraDepth = 1.0f;\n    const vec3  CameraPos   = vec3( 0, 0, 2.0f );\n    const vec3  CameraDir   = vec3( 0, 0, -1 );\n    const vec3  CameraUp    = vec3( 0, 1, 0 );\n    const vec3  CameraSide  = vec3( 1, 0, 0 ); // normalize( cross( cameraDir, cameraUp ) );\n\n    const vec3 LightDir  = normalize( vec3( -1, 1, -1 ) );\n    const vec3 LightStep = LightDir * 0.01;\n\n    const float VolumeDensity  = 0.033f;\n    const vec3  ShadowDensity  = vec3( 0.9 );\n    const vec3  AmbientDensity = vec3( 0.26, 0.28, 0.3 );\n    const vec3  SkyColor       = vec3( 1.0 );\n\n    vec2  uv         = fragCoord / iResolution.xy;\n    vec2  pos        = ( fragCoord.xy * 2.0f - iResolution.xy ) / min( iResolution.x, iResolution.y );\n    vec3  ray        = normalize( CameraSide * pos.x + CameraUp * pos.y + CameraDir * CameraDepth );\n    float stepLength = ( length( CameraPos ) + VolumeRadius ) * InvSteps;\n    vec3  stepRay    = ray * stepLength;\n\n    vec3  currentPos      = CameraPos;\n    float currentDensity  = 0.0f;\n    vec3  lightEnergy     = vec3( 0 );\n    float transmittance   = 1.0;  // transmittance of volume\n    const float Threshold = 0.01;\n    float shadowThreshold = -log( Threshold ) / max( ShadowDensity.r, max( ShadowDensity.g, ShadowDensity.b ) );\n\n    float time = float( iFrame ) * 0.1;\n    for( int i = 0; i < Steps; i++ )\n    {\n        currentPos += stepRay;\n        float currentDistance = distanceFunction( currentPos );\n        if( currentDistance < Epsilon )\n        {\n            float volume = getVolumeTexture( vec4( currentPos, time ) );\n            if( volume > Epsilon )\n            {\n                float shadowDistance  = 0.0;\n                vec3  currentPos2 = currentPos;\n                for( int j = 0; j < ShadowSteps; j++ )\n                {\n                    float currentDistanceToLight = distanceFunction( currentPos2 );\n                    if( currentDistanceToLight >= Epsilon ){ break; }\n#if 0\n                    // Caluculate shadowDistance pricisely. But very heavy.\n\n                    float volume2 = getVolumeTexture( vec4( currentPos2, time ) );\n                    if( volume2 > Epsilon )\n                    {\n                        shadowDistance += stepLength * volume2;\n                    }\n#else\n                    shadowDistance += stepLength;\n#endif\n                    if( shadowDistance > shadowThreshold ){ break; }\n                    currentPos2 += LightStep;\n                }\n\n                float currentDensity = clamp( volume * VolumeDensity, 0.0, 1.0 );\n                vec3 shadowTerm = exp( -shadowDistance * ShadowDensity );\n                vec3 absorbedLightEnergy = shadowTerm * currentDensity;\n\n                lightEnergy += absorbedLightEnergy * transmittance;\n                transmittance *= 1.0 - currentDensity;\n                if( transmittance < Threshold ){ break; }\n                transmittance = clamp( transmittance, 0.0, 1.0 );\n\n                // Sky ambient\n                {\n                    float ambientDistance = 0.0f;\n                    vec3 tempPos = vec3( 0 );\n                    float tempVolumeValue = 0.0f;\n\n                    float baseRatio = 0.01f;\n                    tempPos = currentPos - ray * baseRatio;\n                    tempVolumeValue = getVolumeTexture( vec4( tempPos, time ) );\n                    ambientDistance += tempVolumeValue;\n\n                    tempPos = currentPos - ray * baseRatio * 2.0f;\n                    tempVolumeValue = getVolumeTexture( vec4( tempPos, time ) );\n                    ambientDistance += tempVolumeValue;\n\n                    tempPos = currentPos - ray * baseRatio * 3.0f;\n                    tempVolumeValue = getVolumeTexture( vec4( tempPos, time ) );\n                    ambientDistance += tempVolumeValue;\n\n                    lightEnergy += exp( -ambientDistance * AmbientDensity ) * currentDensity * SkyColor * transmittance;\n                }\n            }\n        }\n    }\n\n    const vec3  lightColor     = vec3( 0.98, 0.95, 0.87 );\n    const vec3  skyColorTop    = vec3( 0.92, 0.94, 0.95 );\n    const vec3  skyColorBottom = vec3( 0.45, 0.68, 0.88 );\n    vec3 backgroundColor = mix( skyColorBottom, skyColorTop, uv.y );\n    vec3 foregroundColor = lightEnergy * lightColor;\n    vec3 color = mix( foregroundColor, backgroundColor, transmittance );\n    fragColor = vec4( color, 1 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec4 P){\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / 7.0;\n  vec4 gy00 = floor(gx00) / 7.0;\n  vec4 gz00 = floor(gy00) / 6.0;\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 / 7.0;\n  vec4 gy01 = floor(gx01) / 7.0;\n  vec4 gz01 = floor(gy01) / 6.0;\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 / 7.0;\n  vec4 gy10 = floor(gx10) / 7.0;\n  vec4 gz10 = floor(gy10) / 6.0;\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 / 7.0;\n  vec4 gy11 = floor(gx11) / 7.0;\n  vec4 gz11 = floor(gy11) / 6.0;\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = fract( uv.x * 4.0 );\n    float y = fract( uv.y * 4.0 );\n    float z = floor( uv.y * 4.0 ) * 4.0 + floor( uv.x * 4.0 );\n\n    float value = 0.0;\n    {\n        vec3 pos = vec3( x, y, z * 0.2 );\n        float t = iTime * 0.5;\n    \tvec4 pos0 = vec4( pos * 2.50, t );\n    \tvec4 pos1 = vec4( pos * 3.20, t );\n    \tvec4 pos2 = vec4( pos * 8.00, t );\n    \tvec4 pos3 = vec4( pos * 32.0, t );\n        float n0 = cnoise( pos0 ) * 0.70 * 1.0;\n        float n1 = cnoise( pos1 ) * 0.20 * 1.0;\n        float n2 = cnoise( pos2 ) * 0.08 * 1.0;\n        float n3 = cnoise( pos3 ) * 0.02 * 1.0;\n        float v = ( n0 + n1 + n2 + n3 ) * 1.3;\n        value = clamp( v, 0.0, 1.0 );\n    }\n        \n    fragColor = vec4( value );\n}","name":"Buffer A","description":"","type":"buffer"}]}