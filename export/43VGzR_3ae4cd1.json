{"ver":"0.1","info":{"id":"43VGzR","date":"1717204909","viewed":72,"name":"bae #017 ~ Checkmate","username":"BretHudson","description":"A 3D truchet tile flipping animation with a checkerboard pattern overlayed.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI 3.141592\n\nfloat scrollFactor = .8;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(vec2 p)\n{\n    p = fract(p * vec2(123.345, 734.6897));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.) / k;\n    return min(a, b) - h * h * h * k * (1. / 6.);\n}\n\nvec3 drawTile(vec2 uv, float fudge)\n{\n    vec2 id = floor(uv);// for a loop: mod(floor(uv) + 15., 30.) - 15.;\n    id.y -= 3.;\n    vec2 gv = fract(uv) - .5;\n    gv.y *= sign(hash(id) - .5);\n    \n    float width = .375 + fudge;\n    float thick = width * .5;\n    \n    vec2 cUv = gv - .5 * sign(gv.x + gv.y + .001);\n    float angle = atan(cUv.y, cUv.x);\n    float d = length(cUv);\n    \n    float mask = abs(d - .5) - (thick * .8);\n    mask = smoothstep(0.01, 0., mask);\n    \n    vec2 tUv = vec2(\n        mod((angle + PI) / 1.57079, 1.),\n        (d - (.5 - thick)) / width\n    );\n    tUv.x = abs(mod(id.x + id.y, 2.) - tUv.x);\n    \n    /* No longer needed, but keeping for any future copy/paste\n    bool a = mod(id.x + id.y, 2.) < 1.;\n    bool b = sign(hash(id) - .5) < 0.;\n    bool xx = a ^^ b;\n    if (xx)\n    {\n        tUv.y = 1. - tUv.y;\n    }\n    */\n    \n    return vec3(tUv, mask);\n}\n\nfloat easeInOutCubic(float x)\n{\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat ease(float t)\n{\n    return easeInOutCubic(t);\n}\n\nvec3 rotateTile(vec3 p, vec2 id)\n{\n    float n = hash(id);\n    \n    float dur = 70.;\n    float spd = .25;\n    n = fract(n * 714.56) * dur;\n    \n    float xAxis = round(fract(n * 87.78));\n    float zAxis = 1. - xAxis;\n    \n    vec3 axis = xAxis * vec3(1, 0, 0) + zAxis * vec3(0, 0, 1);\n    \n    float amount = mod(n + iTime * 2., dur);\n    \n    float halfDur = dur * .5;\n    float whichFlip = floor(amount / halfDur);\n    \n    amount = ease(clamp(mod(amount, halfDur) * spd, 0., 1.)) + whichFlip;\n    return rot3D(p, axis, amount * PI);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 id = floor(p.xz);\n    \n    p.x = fract(p.x) - .5;\n    p.z = fract(p.z) - .5;\n    \n    p = rotateTile(p, id);\n    \n    float n = hash(id);\n    \n    n = fract(n * 47.13);\n    \n    float s = sin(iTime + n * PI * 2.);\n    s = smoothstep(0.5, 1., s) * .2;\n    \n    float r = .0;\n    float w = .5 - r;\n    \n    float box = sdBox(p, vec3(w, .065 - r, w)) - r;\n    float sqr = sdBox(p.xz, vec2(w));\n    \n    return vec2(box, sqr);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.; // total distance travelled\n    for (int i = 0; i < 80 * 4; ++i)\n    {\n        vec3 p = ro + rd * t;\n\n        float d = map(p).x * .1;\n\n        t += d;\n        \n        if (abs(d) < .001 || t > 100.) break;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n    float d = map(p).x;\n    vec2 e = vec2(.00001, .0);\n    vec3 n = d - vec3(\n        map(p - e.xyy).x,\n        map(p - e.yxy).x,\n        map(p - e.yyx).x\n    );\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p)\n{\n    float a = 4.5;\n    \n    vec3 lightPos = vec3(\n        0.,\n        20.,\n        0.\n    ); // Light Position\n    lightPos.x -= iTime * scrollFactor;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = normal(p);\n   \n    float dif = dot(n, l);\n    dif = clamp(dif, 0., 1.);\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.x;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.x;\n    \n    uv *= rot(.24);\n    vec3 Y = vec3(0., 1., 0.);\n    \n    float cameraY = 1.;\n    vec3 ro = vec3(0., cameraY, 0.); // ray origin\n    \n    vec3 lookat = vec3(0, 0, 1.);\n    \n    ro.x -= iTime * scrollFactor;\n    lookat.x -= iTime * scrollFactor;\n    \n    vec3 F = vec3(0, -1, 0);\n    vec3 R = vec3(1, 0, 0);\n    vec3 U = vec3(0, 0, 1);\n    \n    float zoom = 4.;\n    R *= zoom;\n    U *= zoom;\n    ro += uv.x * R + uv.y * U;\n    vec3 rd = F;\n    \n    vec3 col = vec3(0);\n    \n    float t = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * t;\n    float dif = getLight(p);\n    \n    vec2 id = floor(p.xz);\n    float n = hash(id * 75.6);\n    \n    float x = floor(p.x);\n    float zz = floor(p.z);\n    p.xz = fract(p.xz) - .5;\n    p = rotateTile(p, id);\n    p.xz += .5;\n    p.x += x;\n    p.z += zz;\n    \n    float pixelSize = 2. / (iResolution.x / zoom);\n    pixelSize *= 50.;\n    \n    vec3 mask = drawTile(p.xz, .0);\n    vec3 mask2 = drawTile(p.xz, .06);\n    \n    vec3 bg = vec3(.4, .3, .4);\n    \n    float z = mask.z;\n    \n    vec3 cA = vec3(.98, .95, 1.);\n    vec3 cB = vec3(.5, .3, .9);\n    \n    mask.x += iTime * .2;\n    \n    float xOffset = .00125;\n    float yOffset = xOffset * 2.;\n    float samples = 5.;\n    for (int i = -2; i <= int(2); ++i)\n    {\n        for (int j = -2; j <= int(2); ++j)\n        {\n            float o = round((pow((mask.y + float(j) * yOffset) - .5, 2.) + .5) * 6.);\n            float w = mod(floor(fract(mask.x + float(i) * xOffset) * 4.) + o, 2.);\n\n            vec3 c = mix(cB, cA, w);\n            col += mix(bg, c, z);\n        }\n    }\n    col /= (samples * samples);\n    \n    col *= dif;\n    \n    col = mix(col, cB * .7 * vec3(dif), mask2.z - mask.z);\n    \n    {\n        vec2 p = fragCoord/iResolution.xy;\n        col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.2 );\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}