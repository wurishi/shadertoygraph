{"ver":"0.1","info":{"id":"Mc3BWS","date":"1733500499","viewed":133,"name":"Inchworm Animation","username":"fizzer","description":"A worm-like object travelling in an inchworm-like way. The length of the body is kept approximately constant as would happen in nature (more-or-less).","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["sdf","worm","circular","arcs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inchworm\n//\n// The worm body is made of four congruent circular arcs. Consider one of the arcs.\n// Let C be the length of the arc, let W be the length of the arc projected onto the floor plane,\n// let R be the radius of the arc, let θ ϵ (0, π) be the aperture, and let T = W / C ϵ (0, 1). Then we have\n//\n//    θ R = C,   W = C T\n//\n//        R sin θ = W\n//  C / θ (sin θ) = W\n//  C / θ (sin θ) = C T\n//    (sin θ) / θ = T\n//\n// C, W, and T are known. R and θ are unknown. Here the equation above is solved for θ numerically\n// using Newton-Raphson iteration. Note that the left-hand side of this equation happens to be the sinc function.\n//\n// It's interesting but probably not too surprising that the solution depends only on the ratio of the\n// projection onto the floor.\n//\n\nconst float pi = 3.14159265358979323;\n\n// From iq, but altered slightly.\nfloat sdArc( in vec2 p, in vec2 sc, in float ra )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 4.;\n\n    float worm_radius = .25;\n\n    // Animation parameters\n    float tmin = .5, tmax = .99;\n    float t = iTime;\n    float phase = mod(floor(t * 2.), 2.);\n\n    vec3 rd = normalize(vec3(0, 0, 1));\n    \n    // Camera rotation\n    vec2 an = (iMouse.xy - vec2(iResolution.x / 2., 0.)) / iResolution.xy *\n                    vec2(pi * 2., .95) + vec2(0, pi * 1.05);\n                    \n    rd.yz *= mat2(cos(an.y), sin(an.y), -sin(an.y), cos(an.y));\n    rd.xz *= mat2(cos(an.x), sin(an.x), -sin(an.x), cos(an.x));\n \n    // Ray coordinate system\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(rd, up));\n    up = cross(right, rd);\n    \n    vec3 ro = mat3(right, up, rd) * vec3(uv, -32.);\n\n    // Scrolling\n    ro.x += fract(t + .5) * (tmax - tmin) * 4.;\n    \n    ro.y += .5;\n\n    // Constants for worm shape\n    float C = 1.0;\n    float tween = smoothstep(0., 1., min(fract(t), 1. - fract(t)) * 2.);\n    float T = mix(tmin, tmax, tween);\n    float W = C * T;\n    \n    // Use Newton-Raphson root-finding to solve for θ.\n    // I made some re-arrangements on the f(θ)/f'(θ) term here.\n    float th = 1. / 4.;\n    for(int i = 0; i < 32; ++i)\n    {\n        float c = cos(th), s = sin(th);\n        th = th - (th * (s - T * th) / (th * (c - th) - s));\n    }\n\n    float R = C / th;\n\n    // Floor intersection\n    float ft = -ro.y / rd.y;\n\n    // Make an adjustment so that the worm sits properly on the floor\n    ro.y -= worm_radius;\n\n    // Constants for SDF\n    vec2 sc = vec2(sin(th), cos(th));\n    vec2 sc2 = vec2(sin(th / 2.), cos(th / 2.));\n    mat2 m = mat2(sc2.yx * vec2(-1, 1), sc2);\n    vec2 p = vec2(sin(th), 1. - cos(th)) * R;\n\n    // SDF raymarching loop\n    vec3 rp;\n    float d, rt = 20.;\n    float min_d = 1e4;\n    for(int i = 0; i < 256; ++i)\n    {\n        rp = ro + rd * min(ft, rt);\n    \n        if(phase > .5)\n            rp.x = C * 2. - rp.x;\n\n        // Mirror symmetry\n        if(rp.x > W * 2.)\n            rp.x = W * 4. - rp.x;\n\n        // Circular arcs forming worm body in 2D\n        d = sdArc(m * (vec2(0, R) + rp.xy * vec2(1, -1)), sc2, R);\n        d = min(d, sdArc(m * (vec2(0, R) + ((rp.xy - p) * mat2(sc.yx, sc * vec2(-1, 1)))), sc2, R));\n        \n        // Circular profile\n        d = length(vec2(rp.z, d)) - worm_radius;\n        \n        min_d = min(min_d, d);\n        \n        if(d < 1e-3 || rt > ft)\n            break;\n        \n        rt += d;\n    }\n\n    vec3 col;\n\n    if(d < 1e-3)\n    {\n        // Worm body\n        col = mix(vec3(1, .5, .9), vec3(.9, .9, .8), uv.y);\n    }\n    else if(min_d < .05)\n    {\n        // Outline\n        col = vec3(.05);\n    }\n    else if(ft > 0.)\n    {\n        // Checkerboard texture\n        vec2 fu = (ro.xz + rd.xz * ft) / (tmax - tmin) / 2.;\n        col = vec3(mix(.2, .4, mod(floor(fu.x) + floor(fu.y), 2.)));\n        // Shadow from worm\n        col *= mix(0.4, 1., smoothstep(0., .7, d));\n    }\n    \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0);\n}","name":"Image","description":"","type":"image"}]}