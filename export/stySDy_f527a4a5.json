{"ver":"0.1","info":{"id":"stySDy","date":"1643598107","viewed":87,"name":"tiled perlin","username":"HaleyHalcyon","description":"Sequential physical scale of Perlin noise follows every other term of the Fibonacci series to approximate the Golden Ratio using integers. The 'blend' variable sets the weights of sequential terms.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"fdG3zK","parentname":"perlin weirdness ɐxәɟɐɹɐje"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\n// Any function that generates pseudorandom output for X and Y coordinates will work.\n// Ken Perlin used a rainbow table consisting of a permutation of 256 integers.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// fade function defined by Ken Perlin.\n// \"Smootherstep\" equal to 6x^5-15x^4+10x^3,\n// using optimized form given on Wikipedia\n// (minus the clamping, which has been done in perlin()).\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x * 15u + hash(y + 170u))) / 65536. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n\n// Perlin noise generator\n// uv: Input coordinates.\n// offset: The offset of the angle of the corner vectors. [0.0, 1.0)\n// loop: Loops the corner vectors, so that the noise can seamlessly loop.\n// Defined as vec2 for ease of coding, but only works for integer values.\n// If you don't need to make it loop, set it to 0 or a negative value.\nfloat perlin(vec2 uv, float offset, vec2 loop) {\n  // Precompute the integer and fractional components\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n  vec2 j = i + 1.;\n  // Calculate looping\n  if (loop.x > 0.) {\n    i.x = mod(i.x,      loop.x);\n    j.x = mod(i.x + 1., loop.x);\n  }\n  if (loop.y > 0.) {\n    i.y = mod(i.y,      loop.y);\n    j.y = mod(i.y + 1., loop.y);\n  }\n  // Apply the Perlin noise smooth function to the fractional component.\n  vec2 u = fade(f);\n  // Not necessary, but to be safe, I discarded the integer component of the angle offset.\n  //offset = fract(offset);\n  // Do the blending thingy in one nested mix() call.\n  return\n  mix(\n    mix(\n      dot( cvec(i,              offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(vec2(j.x, i.y), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(vec2(i.x, j.y), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(j,              offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n\nfloat noise(vec2 uv, float time) {\n  // Subsequent layers of Perlin noise will be multiplied by this factor.\n  // e.g. if blend is 0.5, Layer 0 will be 1x, Layer 1 will be 0.5x, Layer 2 will be 0.25x...\n  const float blend = 0.45;\n  \n  // Generate finer and finer layers of Perlin noise.\n  // The number of cells will follow every other term of the Fibonacci sequence\n  // i.e. 1 1 2 3 5 8 13 21 34 55 89 144 233...\n  const float[4] coeff = float[](13., 34., 89., 233.);\n  float currentBlend = 1.;\n  float z = 0.;\n  float tSign = 1.;\n  \n  for (int i = 0; i < 4; i++) {\n      z += perlin(\n          uv * coeff[i] +\n          vec2(\n              tan(287.3 * currentBlend + 821.8),\n              tan(601.7 * currentBlend + 554.6)\n          ),\n          tSign * time + tan(394.5 * currentBlend + 936.1),\n          vec2(coeff[i])\n      );\n      currentBlend *= blend;\n      tSign *= -1.;\n  }\n  \n  return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Found 0.32 to be the most visually appealing time value.\n  // Comment the other line out to see it evolve in a looping way.\n  float time = fract(iTime / 4.);\n  // float time = 0.32;\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord.xy / iResolution.xy);\n\n  \n  // Convert the 1D value to a grayscale image\n  vec3 col = vec3(noise(uv, time), noise(uv + 0.3, time + 0.7), 0) * 0.35 + 0.5;\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}","name":"Image","description":"","type":"image"}]}