{"ver":"0.1","info":{"id":"tddSz4","date":"1571605631","viewed":8041,"name":"GPU Ray Tracing","username":"willp","description":"A ShaderToy example of implementing Peter Shirley's ray tracing book on the GPU.","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // hold mouse button + move to move around scene\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = 3.14159265358979;\n\nstruct Ray {\n    vec3 o;     // origin\n    vec3 d;     // direction - always set with normalized vector\n    float t;    // time\n};\n\nRay createRay(vec3 o, vec3 d, float t)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n    r.t = t;\n    return r;\n}\n\nRay createRay(vec3 o, vec3 d)\n{\n    return createRay(o, d, 0.0);\n}\n\nvec3 pointOnRay(Ray r, float t)\n{\n    return r.o + r.d * t;\n}\n\nfloat gSeed = 0.0;\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y>>3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));\n    return float(n) / float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1,seed += 0.1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed)\n{\n    uint n = baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nfloat rand(vec2 v)\n{\n    return fract(sin(dot(v.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 toLinear(vec3 c)\n{\n    return pow(c, vec3(2.2));\n}\n\nvec3 toGamma(vec3 c)\n{\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec2 randomInUnitDisk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.0, 6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi), cos(phi));\n}\n\nvec3 randomInUnitSphere(inout float seed)\n{\n    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1.0, 0.0, 0.0);\n    float phi = h.y;\n    float r = pow(h.z, 1.0/3.0);\n\treturn r * vec3(sqrt(1.0 - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);\n}\n\nstruct Camera\n{\n    vec3 origin;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lensRadius;\n    float time0, time1;\n};\n\nCamera createCamera(\n    vec3 lookFrom,\n    vec3 lookAt,\n    vec3 worldUp,\n    float fovy,\n    float aspect,\n    float aperture,\n    float focusDist,\n    float time0,\n    float time1)\n{\n    float theta = fovy * pi / 180.0;\n    float halfHeight = tan(theta * 0.5);\n    float halfWidth = aspect * halfHeight;\n\n    Camera cam;\n    cam.lensRadius = aperture * 0.5;\n    cam.origin = lookFrom;\n    cam.w = normalize(lookFrom - lookAt);\n    cam.u = normalize(cross(worldUp, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    \n    cam.lowerLeftCorner = cam.origin - halfWidth * focusDist * cam.u - halfHeight * focusDist * cam.v - cam.w * focusDist;\n    cam.horizontal = 2.0 * halfWidth * focusDist * cam.u;\n    cam.vertical = 2.0 * halfHeight * focusDist * cam.v;\n    cam.time0 = time0;\n    cam.time1 = time1;\n    return cam;\n}\n\nRay getRay(Camera cam, vec2 uv)\n{\n    vec2 rd = cam.lensRadius * randomInUnitDisk(gSeed);\n    vec3 offset = cam.u * rd.x + cam.v * rd.y;\n    float time = cam.time0 + hash1(gSeed) * (cam.time1 - cam.time0);\n    return createRay(\n        cam.origin + offset,\n        normalize(cam.lowerLeftCorner + uv.x * cam.horizontal + uv.y * cam.vertical - cam.origin - offset),\n        time);\n}\n\n// MT_ material type\n#define MT_DIFFUSE 0\n#define MT_METAL 1\n#define MT_DIALECTRIC 2\n\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float roughness; // controls roughness for metals\n    float refIdx; // index of refraction for dialectric\n};\n\nMaterial createDiffuseMaterial(vec3 albedo)\n{\n    Material m;\n    m.type = MT_DIFFUSE;\n    m.albedo = albedo;\n    return m;\n}\n\nMaterial createMetalMaterial(vec3 albedo, float roughness)\n{\n    Material m;\n    m.type = MT_METAL;\n    m.albedo = albedo;\n    m.roughness = roughness;\n    return m;\n}\n\nMaterial createDialectricMaterial(vec3 albedo, float refIdx)\n{\n    Material m;\n    m.type = MT_DIALECTRIC;\n    m.albedo = albedo;\n    m.refIdx = refIdx;\n    return m;\n}\n\nstruct HitRecord\n{\n    vec3 pos;\n    vec3 normal;\n    float t;            // ray parameter\n    Material material;\n};\n\nbool customRefract(vec3 v, vec3 n, float niOverNt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float discriminant = 1.0 - niOverNt * niOverNt * (1.0 - dt * dt);\n    if(discriminant > 0.0)\n    {\n        refracted = niOverNt * (uv - n * dt) - n * sqrt(discriminant);\n        return true;\n    }\n    return false;\n}\n\nfloat schlick(float cosine, float refIdx)\n{\n    float r0 = (1.0 - refIdx) / (1.0 + refIdx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\nbool scatter(Ray rIn, HitRecord rec, out vec3 atten, out Ray rScattered)\n{\n    if(rec.material.type == MT_DIFFUSE)\n    {\n        vec3 target = rec.pos + rec.normal + randomInUnitSphere(gSeed);\n        rScattered = createRay(rec.pos, normalize(target - rec.pos), rIn.t);\n        atten = rec.material.albedo;\n        return true;\n    }\n    if(rec.material.type == MT_METAL)\n    {\n        vec3 refl = reflect(rIn.d, rec.normal);\n        rScattered = createRay(rec.pos, normalize(refl + rec.material.roughness * randomInUnitSphere(gSeed)), rIn.t);\n        atten = rec.material.albedo;\n        return true;\n    }\n    if(rec.material.type == MT_DIALECTRIC)\n    {\n        atten = vec3(1.0);\n        vec3 outwardNormal;\n        float niOverNt;\n        float cosine;\n\n        if(dot(rIn.d, rec.normal) > 0.0)\n        {\n            outwardNormal = -rec.normal;\n            niOverNt = rec.material.refIdx;\n            cosine = rec.material.refIdx * dot(rIn.d, rec.normal) / length(rIn.d); // last divide not required (already normalized)\n        }\n        else\n        {\n            outwardNormal = rec.normal;\n            niOverNt = 1.0 / rec.material.refIdx;\n            cosine = -dot(rIn.d, rec.normal) / length(rIn.d); // same as above\n        }\n\n        vec3 refracted;\n        float reflectProb;\n        if(customRefract(rIn.d, outwardNormal, niOverNt, refracted))\n        {\n            reflectProb = schlick(cosine, rec.material.refIdx);\n        }\n        else\n        {\n            reflectProb = 1.0;\n        }\n\n        if(hash1(gSeed) < reflectProb)\n        {\n            vec3 reflected = reflect(rIn.d, rec.normal);\n            rScattered = createRay(rec.pos, normalize(reflected), rIn.t);\n        }\n        else\n        {\n            rScattered = createRay(rec.pos, normalize(refracted), rIn.t);\n        }\n\n        return true;\n    }\n    return false;\n}\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nSphere createSphere(vec3 center, float radius)\n{\n    Sphere s;\n    s.center = center;\n    s.radius = radius;\n    return s;\n}\n\nstruct MovingSphere\n{\n    vec3 center0, center1;\n    float radius;\n    float time0, time1;\n};\n\nMovingSphere createMovingSphere(vec3 center0, vec3 center1, float radius, float time0, float time1)\n{\n    MovingSphere s;\n    s.center0 = center0;\n    s.center1 = center1;\n    s.radius = radius;\n    s.time0 = time0;\n    s.time1 = time1;\n    return s;\n}\n\nvec3 center(MovingSphere mvsphere, float time)\n{\n    return mvsphere.center0 + ((time - mvsphere.time0) / (mvsphere.time1 - mvsphere.time0)) * (mvsphere.center1 - mvsphere.center0);\n}\n\n\n/*\n * The function naming convention changes with these functions to show that they implement a sort of interface for\n * the book's notion of \"hittable\". E.g. hit_<type>.\n */\n\nbool hit_sphere(Sphere s, Ray r, float tmin, float tmax, inout HitRecord rec)\n{\n    vec3 oc = r.o - s.center;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float discriminant = b * b - a * c;\n    if(discriminant > 0.0)\n    {\n        float sqrtDiscriminant = sqrt(discriminant);\n        float temp = (-b - sqrtDiscriminant) / a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.pos = pointOnRay(r, rec.t);\n            rec.normal = (rec.pos - s.center) / s.radius;\n            return true;\n        }\n        temp = (-b + sqrtDiscriminant) / a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.pos = pointOnRay(r, rec.t);\n            rec.normal = (rec.pos - s.center) / s.radius;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_movingSphere(MovingSphere s, Ray r, float tmin, float tmax, inout HitRecord rec)\n{\n    vec3 sphereCenter = center(s, r.t);\n    vec3 oc = r.o - sphereCenter;\n    float a = dot(r.d, r.d);\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float discriminant = b * b - a * c;\n    if(discriminant > 0.0)\n    {\n        float sqrtDiscriminant = sqrt(discriminant);\n        float temp = (-b - sqrtDiscriminant) / a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.pos = pointOnRay(r, rec.t);\n            rec.normal = (rec.pos - sphereCenter) / s.radius;\n            return true;\n        }\n        temp = (-b + sqrtDiscriminant) / a;\n        if(temp < tmax && temp > tmin)\n        {\n            rec.t = temp;\n            rec.pos = pointOnRay(r, rec.t);\n            rec.normal = (rec.pos - sphereCenter) / s.radius;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_world(Ray r, float tmin, float tmax, inout HitRecord rec)\n{\n    bool hit = false;\n    rec.t = tmax;\n\n    if(hit_sphere(\n        createSphere(vec3(0.0, -1000.0, -1.0), 1000.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createDiffuseMaterial(vec3(0.5));\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(-4.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createDiffuseMaterial(vec3(0.4, 0.2, 0.1));\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(4.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material = createMetalMaterial(vec3(0.7, 0.6, 0.5), 0.0);\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(0.0, 1.0, 0.0), 1.0),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material.type = MT_DIALECTRIC;\n        rec.material = createDialectricMaterial(vec3(0.8, 0.8, 0.8), 1.5);\n    }\n\n    if(hit_sphere(\n        createSphere(vec3(0.0, 1.0, 0.0), -0.95),\n        r,\n        tmin,\n        rec.t,\n        rec))\n    {\n        hit = true;\n        rec.material.type = MT_DIALECTRIC;\n        rec.material = createDialectricMaterial(vec3(0.8, 0.8, 0.8), 1.5);\n    }\n\n    int numxy = 5;\n    for(int x = -numxy; x < numxy; ++x)\n    {\n        for(int y = -numxy; y < numxy; ++y)\n        {\n            float fx = float(x);\n            float fy = float(y);\n            float seed = fx + fy / 1000.0;\n            vec3 rand1 = hash3(seed);\n            vec3 center = vec3(fx + 0.9 * rand1.x, 0.2, fy + 0.9 * rand1.y);\n            float chooseMaterial = rand1.z;\n            if(distance(center, vec3(4.0, 0.2, 0.0)) > 0.9)\n            {\n                if(chooseMaterial < 0.4)\n                {\n                    vec3 center1 = center + vec3(0.0, hash1(gSeed) * 0.5, 0.0);\n                    // diffuse\n                    if(hit_movingSphere(\n                        createMovingSphere(center, center1, 0.2, 0.0, 1.0),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material = createDiffuseMaterial(hash3(seed) * hash3(seed));\n                    }\n                }\n                else if(chooseMaterial < 0.6)\n                {\n                    // diffuse\n                    if(hit_sphere(\n                        createSphere(center, 0.2),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material = createDiffuseMaterial(hash3(seed) * hash3(seed));\n                    }\n                }\n                else if(chooseMaterial < 0.9)\n                {\n                    // metal\n                    if(hit_sphere(\n                        createSphere(center, 0.2),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material.type = MT_METAL;\n                        rec.material = createMetalMaterial((hash3(seed) + 1.0) * 0.5, hash1(seed));\n                    }\n                }\n                else\n                {\n                    // glass (dialectric)\n                    if(hit_sphere(\n                        createSphere(center, 0.2),\n                        r,\n                        tmin,\n                        rec.t,\n                        rec))\n                    {\n                        hit = true;\n                        rec.material.type = MT_DIALECTRIC;\n                        rec.material = createDialectricMaterial(vec3(0.0), 1.5);\n                    }\n                }\n            }\n        }\n    }\n\n    return hit;\n}\n\n#define MAX_BOUNCES 20\n\nvec3 color(Ray r)\n{\n    HitRecord rec;\n    vec3 col = vec3(1.0);\n    for(int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        if(hit_world(r, 0.001, 10000.0, rec))\n        {\n            Ray scatterRay;\n            vec3 atten;\n            if(scatter(r, rec, atten, scatterRay))\n            {\n                col *= atten;\n                r = scatterRay;\n            }\n            else\n            {\n                return vec3(0.0);\n            }\n        }\n        else\n        {\n            float t = 0.5 * (r.d.y + 1.0);\n            col *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);\n            return col;\n        }\n    }\n    return col;\n}\n\n#define MAX_SAMPLES 5000.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    gSeed = float(baseHash(floatBitsToUint(gl_FragCoord.xy))) / float(0xffffffffU) + iTime;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x = mouse.x * 2.0 - 1.0;\n\n    vec3 camPos = vec3(mouse.x * 10.0, mouse.y * 5.0, 8.0);\n    vec3 camTarget = vec3(0.0, 0.0, -1.0);\n    float fovy = 60.0;\n    float aperture = 0.05;\n    float distToFocus = length(camTarget - camPos);\n    float time0 = 0.0;\n    float time1 = 1.0;\n    Camera cam = createCamera(\n        camPos,\n        camTarget,\n        vec3(0.0, 1.0, 0.0),    // world up vector\n        fovy,\n        iResolution.x / iResolution.y,\n        aperture,\n        distToFocus,\n        time0,\n        time1);\n\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 prev = texture(iChannel0, uv);\n    vec3 prevLinear = toLinear(prev.xyz);\n    prevLinear *= prev.w;\n\n    uv = (gl_FragCoord.xy + hash2(gSeed)) / iResolution.xy;\n    vec3 col = color(getRay(cam, uv));\n\n    vec4 mousedata = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(mousedata.x - mousedata.z != 0.0 || mousedata.y - mousedata.w != 0.0)\n    {\n        col = toGamma(col);\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    if(prev.w > MAX_SAMPLES)\n    {\n        fragColor = prev;\n        return;\n    }\n\n    col = (col + prevLinear);\n    float w = prev.w + 1.0;\n    col /= w;\n    col = toGamma(col);\n    fragColor = vec4(col, w);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(iMouse.xy, prev.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}