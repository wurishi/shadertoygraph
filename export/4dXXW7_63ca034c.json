{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// My first attempt at understanding raymarching. \n// Completely inefficient but by jove it works!\n\n\nconst int RAY_STEPS = 35;\nconst float cubeSize = 4.0;\nconst float speed = 30.0;\n\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// uv coord\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// camera stuff\n\tvec3 camPos = vec3(15.0, 8.0,15.0);\n\tvec3 camNorm = vec3(0.653, 0.383, 0.653);\n\t//animated spin camera\n\tfloat rads = iTime * speed * 0.01745;\n\tmat3 spin = mat3(vec3(cos(rads), 0.0, -sin(rads)), vec3(0.0, 1.0, 0.0), vec3(sin(rads), 0.0, cos(rads)));\n\tcamPos = spin * camPos;\n\tcamNorm = spin * camNorm;\n\t// camera attributes\n\tfloat camNear = .5;\n\tfloat camFar = 55.0;\n\tfloat camHFOV = 65.0;\n\tfloat camVFOV = 35.0;\n\t// camera matrix\n\tvec3 camXAxis = cross(vec3(0.0, 1.0, 0.0), camNorm);\n\tcamXAxis =  normalize(camXAxis);\n\tvec3 camYAxis = cross(camNorm, camXAxis);\n\tmat3 camRotMat = mat3(camXAxis, camYAxis, camNorm);\n\t\n\t//ray vector\n\tvec3 raySt = vec3(0.0, 0.0, -camNear);\n\tfloat nearW = tan(camHFOV * .5 * .01745) * abs(camNear);\n\traySt.x = (nearW * uv.s * 2.0) - nearW;\n\tfloat nearH = tan(camVFOV * .5 * .01745) * abs(camNear);\n\traySt.y = (nearH * uv.t * 2.0) - nearH;\n\t// run the ray through the cameras rotation matrix, and add it's position\n\traySt = (camRotMat * raySt) + camPos;\n\tvec3 rayDir = normalize(raySt - camPos);\n\tvec3 rayInc = rayDir * ((abs(camFar) - abs(camNear)) / float(RAY_STEPS));\n\t\n\t// march\n\tvec3 result = vec3(1.0, 0.0, 1.0);\n\tvec3 curPos = raySt;\n    float cur_step_size = 0.1;\n\tfor (int i = 0; i < RAY_STEPS; ++i) {\n\t\tif (i == RAY_STEPS - 1) {\n\t\t\tresult = mix(vec3(0.15, 0.15, 0.15), vec3(0.6, 0.05, 0.8), uv.t);\t\n        }\n\t\t\n        vec3 wave = vec3(curPos.x + sin(curPos.y * 4.0) * 0.25, curPos.y, curPos.z); \n        float dist = sdBox( wave, vec3(2.0, 4.0, 2.0) );\n        float dist2 = sdCone(wave, vec2(1.0, 0.2));\n        dist = min(dist, dist2);\n\t\tif (abs(dist) < 0.2) {\n\t\t\t//return curPos;\n\t\t\tresult = vec3(0.0,  float(i) / float(RAY_STEPS) * 1.5, 1.0);\n\t\t\tbreak;\n\t\t}\n        cur_step_size = dist;\n\t\tcurPos += rayDir * cur_step_size;\n\t}\n\t\n\n\tfragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dXXW7","date":"1401869898","viewed":271,"name":"Raymarch Hello World","username":"villain749","description":"My first attempt at understanding raymarching. Completely inefficient and very rough but by jove it works!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","helloworld"],"hasliked":0,"parentid":"","parentname":""}}