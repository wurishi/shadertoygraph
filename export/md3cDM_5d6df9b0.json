{"ver":"0.1","info":{"id":"md3cDM","date":"1695126076","viewed":130,"name":"Sin/Cos approximation","username":"Envy24","description":"Source: \"Math Toolkit For Real-Time Development\", Jack W. Crenshaw","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sin","approximation","cos","taylor"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y) ) functions. */\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 1.5 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC = fract(NDC); NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, L2_norm = sqrt(1.0 + dfdx * dfdx);\n    return SMAA(abs(sdf) / L2_norm);\n    //return SMAA(abs(sdf) / L2_norm - 0.05); // thick\n                           \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\nvec2 sincos(float x)\n{\n    const float sin_30 =      0.5;\n    const float cos_30 =      0.8660254037844386;\n    const float pi_over_six = 0.5235987755982988; // pi / 6\n    const float inv =         1.9098593171027440; // 1 / pi_over_six\n    const float tau =         6.2831853071795862; // 2 * pi\n    const float inv_tau =     0.1591549430918953; // 1 / tau\n    \n    // Increases accuracy for negative angles (see this shader: https://www.shadertoy.com/view/NtVBWG)\n    x = fract(x*inv_tau)*tau;\n    \n    int n = int(x * inv + 0.5); \n    x -= float(n) * pi_over_six;\n    \n    //n = n < 0 ? (n + 12) % 12 : n % 12;\n    //n %= 12; if (n < 0) n += 12;\n\n    float z = x*x, s = 0., c = 0.,\n          s1 = ((z/20.0-1.0)*z/6.0+1.0)*x,\n          c1 = ((z/30.0+1.0)*z/12.0-1.0)*z/2.0+1.0;        \n    \n    switch(n)\n    {\n    case 0:\n    case 12: s =  s1;                        c =  c1;                        break;\n    case 1:  s =  cos_30 * s1 + sin_30 * c1; c = -sin_30 * s1 + cos_30 * c1; break;\n    case 2:  s =  sin_30 * s1 + cos_30 * c1; c = -cos_30 * s1 + sin_30 * c1; break;\n    case 3:  s =  c1;                        c = -s1;                        break;\n    case 4:  s = -sin_30 * s1 + cos_30 * c1; c = -cos_30 * s1 - sin_30 * c1; break;\n    case 5:  s = -cos_30 * s1 + sin_30 * c1; c = -sin_30 * s1 - cos_30 * c1; break;\n    case 6:  s = -s1;                        c = -c1;                        break;\n    case 7:  s = -cos_30 * s1 - sin_30 * c1; c =  sin_30 * s1 - cos_30 * c1; break;\n    case 8:  s = -sin_30 * s1 - cos_30 * c1; c =  cos_30 * s1 - sin_30 * c1; break;\n    case 9:  s = -c1;                        c =  s1;                        break;\n    case 10: s =  sin_30 * s1 - cos_30 * c1; c =  cos_30 * s1 + sin_30 * c1; break;\n    case 11: s =  cos_30 * s1 - sin_30 * c1; c =  sin_30 * s1 + cos_30 * c1; break;\n    }\n    \n    return vec2(s, c);\n}\n// Another implementation.\nfloat sine(float x)\n{        \n    const float tau =     6.2831853071795862;\n    const float inv_tau = 0.1591549430918953;\n    \n    float X = fract(x*inv_tau);\n       \n    switch (int(X * 4.))\n    {                                              // Quadrants:\n    case 0: X = X                    * tau; break; // first\n    case 1: X = (.25 - (X - .25))    * tau; break; // second\n    case 2: X = (-(X - .5))          * tau; break; // third\n    case 3: X = (-(.25 - (X - .75))) * tau; break; // fourth\n    }\n\n    float xx = X*X;\n    const float a0 =  1.,\n                a1 = -0.166666665811,\n                a2 =  0.008333320401,\n                a3 = -0.000198407018014,\n                a4 =  0.0000027522394147,\n                a5 = -0.00000002384080041;\n\n    return (((((a5 * xx + a4) * xx + a3) * xx + a2) * xx + a1) * xx + a0) * X;\n}\nfloat cosine(float x) { return sine(x + 1.5707963267948966); }\n\n// Explicit function definition.\nint func_idx = 0;\n#define M ( 3. )\nfloat explicit(float x) \n{ \n    vec2 sc = sincos(M * x);\n    if (func_idx == 0)\n        return sc.x;\n        //return sine(M * x);\n        //return sin(M * x);\n    else\n        return sc.y;\n        //return cosine(M * x);\n        //return cos(M * x);\n}\nfloat explicit_dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return ( explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n    /* Analytic derivative. *\n    return -M*sin(M*x);\n    /**/\n}\n     \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0.9), SMAA(cellsSDF(NDC*10.)-0.025) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    /* Explicit function y=f(x) */\n    func_idx = 0;\n         color = mix(color, vec3(1,0,0), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n    func_idx = 1;\n         color = mix(color, vec3(0,0,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}