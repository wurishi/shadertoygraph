{"ver":"0.1","info":{"id":"3dsGDH","date":"1546051779","viewed":80,"name":"Raymarching nux w/ dithering","username":"cafe","description":"Noox","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["nux"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\n\nconst int max_step = 50;\n\nconst float delta = 0.0001;\n\nconst float NORMAL_DELTA = 0.1;\n\nconst vec3 normalX = vec3(NORMAL_DELTA, 0, 0);\nconst vec3 normalY = vec3(0, NORMAL_DELTA, 0);\nconst vec3 normalZ = vec3(0, 0, NORMAL_DELTA);\n\nint last_raymarch_count = 0;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat grid(vec2 uv, float t){\n   float modulo = 0.008;\n   uv.x += cos(uv.y*10.+iTime)*0.001;\n   uv.y += sin(uv.x*7.648651+iTime)*0.001;\n   const float ss_delta = .1;\n   float strikes = abs(mod(uv.x*2.+uv.y,modulo)*2./modulo-1.);\n   //float strikes = rand(uv);\n   //float strikes = 1.-length(mod(uv*vec2(1.78,1.),modulo)-vec2(modulo*.5))/(modulo)*sqrt(2.);\n   //return smoothstep(0.49,0.51,strikes);\n   return 1.-smoothstep(t-ss_delta,t+ss_delta,strikes);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 heatmap(float t){\n     return pal(t,vec3(0.5),vec3(0.5), vec3(0.67), vec3(0.33,0.,0.67));\n}\n\n/* radius 1.0 sphere, centered on origin 0,0,0 */\nfloat distanceToSphere(vec3 p)\n{\n    vec3 s_pos = vec3(0., 0., -10.);\n    float radius = 1.;\n\treturn distance(s_pos, p) - radius;\n}\n\n/* radius 1.0 sphere, centered on 2, 0, -2 */\nfloat distanceToSphere2(vec3 p)\n{\n    vec3 s_pos = vec3(3., 0., -10.);\n    float radius = 1.;\n\treturn distance(s_pos, p) - radius;\n}\n\nfloat plan(vec3 p)\n{\n    vec3 plan_pos = vec3(0.,0.,-20.);\n    return abs(p.z - plan_pos.z);\n}\n\nfloat genericDistance(vec3 p)\n{\n\tfloat min_val = min(distanceToSphere(p), distanceToSphere2(p));\n    \n    min_val = min(min_val, plan(p));\n    \n    return min_val;\n}\n\nvec3 getIntersectionPointWithSphere(vec3 p, vec3 dir)\n{\n \tfloat dist = 0.0;\n    int i;\n    for(i=0; i<max_step; ++i)\n    {\n    \tfloat res = genericDistance(p + dir * dist);\n        if(res < delta)\n        {\n            last_raymarch_count = i;\n            return p + dir * dist;\n        }\n        dist += res;\n    }   \n    return vec3(0,0,0);\n}\n\nbool isOccluded(vec3 p, vec3 source)\n{\n    vec3 distToSphere = getIntersectionPointWithSphere(p, source);\n    \n    if(distToSphere != vec3(0,0,0))\n    {\n        return true;\n    }\n    return false;\n}\n\nvec3 computeNormal(vec3 p)\n{\n    float dist = genericDistance(p);\n    return normalize(vec3(\n        genericDistance(p + normalX) - dist,\n        genericDistance(p + normalY) - dist,\n        genericDistance(p + normalZ) - dist\n        )\n    );\n}\n\nfloat vectorAngle(vec3 vector1, vec3 vector2)\n{\n    vec3 norm_v1 = normalize(vector1);\n    vec3 norm_v2 = normalize(vector2);\n    return dot(norm_v1, norm_v2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fovy = fovx * iResolution.y/iResolution.x;\n\tfloat ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const vec3 cameraPosition = vec3(1.5, 0.0, 0.0);\n\tconst vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\n\tconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);    \n\n\t// generate the ray for this pixel\n\tvec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n\tvec3 nright = normalize(cross(cameraUp, cameraDirection));\n\tvec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n\tvec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 lightSourcePos = vec3(sin(iTime/10.)*20., cos(iTime/2.)*2., cos(iTime/10.) * 20.);\n    //vec3 lightSourcePos = vec3(1.5, 10., -10.);\n    \n    vec3 col = vec3(0,0,0);\n    \n    fragColor = vec4(col,1.0);\n    \n    vec3 sphere_intersect = getIntersectionPointWithSphere(cameraPosition, rayDirection);\n    if(sphere_intersect != vec3(0,0,0))\n    {\n        vec3 normal = computeNormal(sphere_intersect);\n        vec3 fromPointToLight = normalize(lightSourcePos - (sphere_intersect - rayDirection * 0.02));\n        if(isOccluded(sphere_intersect - rayDirection * 0.02, fromPointToLight))\n        {\n        \tcol = vec3(0,0,0);   \n            //col = heatmap(float(last_raymarch_count)/float(max_step));\n        }else{\n            col = vec3(0.3, 0.5, 0.5);\n            //vec3 np = cross(normal, fromPointToLight);\n            float vecAngle = vectorAngle(normal, fromPointToLight);\n            //col *= max(0., vecAngle);\n            col *= grid(uv,max(0.,vecAngle));\n            //col = normal * 0.5 + 0.5;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}