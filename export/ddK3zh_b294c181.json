{"ver":"0.1","info":{"id":"ddK3zh","date":"1680784205","viewed":36,"name":"test 3D","username":"gallerev","description":"test 3D","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["virus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define false 0\n#define true 1\n#define pas 0.\n#define peu 2.\n#define moyen 5.\n#define beaucoup 10.\n\n //objets\n#define AFF_BOX true\n#define AFF_VIRUS true\n\n // screen resolution\n#define R iResolution.xy\n#define background 0.7\n\n //params\n#define color_instability pas\n#define deformation_stable beaucoup;\n#define nb_deformation moyen;\n        //shyniness\n#define mat_sphere beaucoup\n#define mat_cube beaucoup*beaucoup\n#define mat_sol beaucoup*beaucoup\n\n // minimum distance to objects\n#define DIST_MIN 1.\n\n // maximum distance to objects\n#define DIST_MAX 50.0\n\n // max number of steps for the ray-marching\n#define RAY_MARCH_STEPS 80\n\n // consider hit if we reach this distance\n#define RAY_MARCH_PRECI 0.01\n\n // for ray direction computation\n#define PI 3.14159265359\n\n // ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n    float shiny;\n};\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 rotate(in vec2 p, float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n    return vec2(ca*p.x-sa*p.y, sa*p.x+ca*p.y);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nSurface scene(in vec3 p) {\n\n    vec3 p_rot = p;\n    p_rot.xy = rotate(p_rot.xy,iTime);\n    p_rot.yz = rotate(p_rot.yz,cos(iTime));\n\n    vec3 t = (p_rot+iTime/5.)*nb_deformation;\n    vec3 blue_sh = (p+60./5.)*6.;\n    float d = (sin(t.x)*sin(t.y)*sin(t.z))/deformation_stable;\n    float dc = d * 6.;\n    \n    //box\n    float box = sdBoxFrame(p,vec3(2.),0.2);\n    Surface s_box = Surface(box,vec3(0.4,0.4,0.4),mat_cube);\n    \n    //ground\n    float sol = sdPlane(p+5.,vec3(0.,0.5,0.),0.5);\n    Surface s_sol = Surface(sol,vec3(0.,0.5,0.),mat_sol);\n    \n    //sphere\n    float sphere = sdSphere(p,1.)+d;\n    Surface s_sphere = Surface(sphere,vec3(-dc+1.,dc+1.,cos(blue_sh*blue_sh)*color_instability),mat_sphere);\n    //Surface(sphere,vec3(-dc+1.,dc+1.,cos(blue_sh*blue_sh)*color_instability),mat_sphere);\n    \n    \n    //disp params\n    #if AFF_BOX == true && AFF_VIRUS == true\n    if (sphere < box){\n       return s_sphere;\n    }else if (box < sol){\n        return s_box;\n    }\n    return s_sol;\n    \n    #else\n        #if AFF_BOX == true\n        if (box < sol){\n            return s_box;\n        }\n        #endif        \n        #if AFF_VIRUS == true\n        if (box < sol){\n            return s_sphere;\n        }\n        #endif\n    #endif\n   return s_sol;\n   //return Surface(1.,vec3(0.4,0.4,0.4));\n}\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c,s.shiny);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0),0.);\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nvec3 shade(in Surface s,in Ray r) {\n    vec3 n = normalAt(s,r);\n    //vec3 l = normalize(vec3(1.,1.,-1.)); //light pos\n    vec3 l = normalize(vec3((cos(iTime/5.)+1.),1.,-(sin(iTime)+1.))); //light pos\n\n    \n        //reflets\n    vec3 v = -r.d;\n    vec3 e = reflect(-l,n);\n    \n    vec3 kd = s.c;\n    vec3 ks = vec3(1.);\n    vec3 ka = vec3(0.);\n    \n    float diff = max(dot(n,l),0.);\n    float spec = pow(max((dot(e,v)),0.),s.shiny);\n    \n    return ka + kd*diff + ks*spec;\n    \n        //no reflets\n    //float d = dot(n,l);\n    //return d*s.c;\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = (iMouse.xy/R.y);\n    \n    // camera position   \n    float DP = 10.;\n    float d = DP/2.+5.;\n    vec3 ro = vec3(d*cos(6.0*m.x),sin(iMouse.y*0.01)*7.,d*sin(6.0*m.x) );\n\n    //vec3 ro = vec3(0.,0.,-7.);\n\n    // target point\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + zf*cw);\n\n    return Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n\n    Ray r = camRay(uv);\n    Surface s = march(r);\n    vec3 c = vec3(background);\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}