{"ver":"0.1","info":{"id":"ds2yRm","date":"1687543169","viewed":523,"name":"Pairtial","username":"PairtialShaders","description":"Shader based on https://www.shadertoy.com/view/NlsXDH \"Exit the Matrix\" .","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["learning","ai","machine","neural","networks","artificial","pairtial","intelligence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float det = 0.001, t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 path(float t)\n{\n    vec3 p = vec3(vec2(sin(t * 0.1), cos(t * 0.05)) * 10.0, t);\n    p.x += smoothstep(0.0, 0.5, abs(0.5 - fract(t * 0.02))) * 10.0;\n    return p;\n}\n\nfloat fractal(vec2 p)\n{\n    p = abs(5.0 - mod(p * 0.2, 10.0)) - 5.0;\n    float ot = 1000.0;\n    for (int i = 0; i < 7; i++)\n    {\n        p = abs(p) / clamp(p.x * p.y, 0.25, 2.0) - 1.0;\n        if (i > 0) ot = min(ot, abs(p.x) + 0.7 * fract(abs(p.y) * 0.05 + t * 0.05 + float(i) * 0.3));\n    }\n    ot = exp(-10.0 * ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c = abs(p) - l;\n    return length(max(vec3(0.0), c)) + min(0.0, max(c.x, max(c.y, c.z)));\n}\n\nfloat de(vec3 p)\n{\n    boxhit = 0.0;\n    vec3 p2 = p - adv;\n    p2.xz *= rot(t * 0.2);\n    p2.xy *= rot(t * 0.1);\n    p2.yz *= rot(t * 0.15);\n    float b = box(p2, vec3(1.0));\n    p.xy -= path(p.z).xy;\n    float s = sign(p.y);\n    p.y = -abs(p.y) - 3.0;\n    p.z = mod(p.z, 20.0) - 10.0;\n    for (int i = 0; i < 5; i++)\n    {\n        p = abs(p) - 1.0;\n        p.xz *= rot(radians(s * -45.0));\n        p.yz *= rot(radians(90.0));\n    }\n    float f = -box(p, vec3(5.0, 5.0, 10.0));\n    float d = min(f, b);\n    if (d == b) boxp = p2, boxhit = 1.0;\n    return d * 0.7;\n}\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 p, n, g = vec3(0.0);\n    float d, td = 0.0;\n    for (int i = 0; i < 80; i++)\n    {\n        p = from + td * dir;\n        d = de(p) * (1.0 - hash(gl_FragCoord.xy + t) * 0.3);\n        if (d < det && boxhit < 0.5) break;\n        td += max(det, abs(d));\n        float f = fractal(p.xy) + fractal(p.xz) + fractal(p.yz);\n        float b = fractal(boxp.xy) + fractal(boxp.xz) + fractal(boxp.yz);\n        vec3 colf = vec3(f);\n        vec3 colb = vec3(b + 0.1, b * b + 0.05, 0.0);\n        g += colf / (3.0 + d * d * 2.0) * exp(-0.0015 * td * td) * step(5.0, td) / 2.0 * (1.0 - boxhit);\n        g += colb / (10.0 + d * d * 20.0) * boxhit * 0.5;\n    }\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up)\n{\n    dir = normalize(dir);\n    vec3 rt = normalize(cross(dir, normalize(up)));\n    return mat3(rt, cross(rt, dir), dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    t = iTime * 7.0;\n    vec3 from = path(t);\n    adv = path(t + 6.0 + sin(t * 0.1) * 3.0);\n    vec3 dir = normalize(vec3(uv, 0.7));\n    dir = lookat(adv - from, vec3(0.0, 1.0, 0.0)) * dir;\n    vec3 col = march(from, dir);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}