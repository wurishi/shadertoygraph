{"ver":"0.1","info":{"id":"4fByD1","date":"1723089556","viewed":91,"name":"Titaniumballz","username":"Cotterzz","description":"This is a GLSL renderer for a game I'm developing in C, Raylib and JS\n\nThere are still a few more features to add before it's ready to plug into the game.\nRight now I need to spend some time tidying up the code and optimising.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["game","lighting","spheres","shadows","ball","25d","orthographic","titaniumballz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\n#define numballs 10\n#define black vec3(0.0,0.0,0.0)\n#define white vec3(1.0,1.0,1.0)\n#define grey vec3(0.5,0.5,0.5)\n#define blue vec3(0.0,0.0,1.0)\n#define red vec3(1.0,0.0,0.0)\n#define lime vec3(0.0,1.0,0.0)\n#define green vec3(0.0,0.7,0.0)\n#define cyan vec3(0.0,1.0,1.0)\n#define purple vec3(1.0,0.0,1.0)\n#define yelow vec3(1.0,1.0,0.0)\n#define orange vec3(1.0,0.6,0.0)\n\nvec4 Balls[numballs];\n\nbool outputMode = false; vec3 outputColour; // Easy way to throw a value at the output for debugging\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} // Call outputValue with a float and that value will override the pixel output\nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;} // or directly with a vec3\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.y<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    float pixel = 1.0/iResolution.y;\n    float cradius = 0.34;\n    float radius = 0.055;\n    vec3 gcol = vec3(0.5,0.6,0.7);\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5);\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5);\n    vec2 centre = vec2(0.0,0.0);\n    float segment = 1.256637; // ( 3.1415926 * 2.0 ) / 5.0;\n    float rightAng = 1.5708; // ( 3.1415926 * 2.0 ) / 4.0;\n    vec3 Tcolf;\n    vec3 Tcolb;\n    bool flatTop;\n    float tradius = radius/3.0;\n    float theight = sqrt((radius*radius)-(tradius*tradius));\n    float speed = iTime;\n    float dist = 20.0;\n    float angle;\n    vec3 bcol,col;\n    int currentBall = 10;\n    for(int i=0;i<numballs;i++){\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>4){\n            angle += speed;\n            rcentre = centreR;} else {\n                angle -= speed;\n            }\n        Balls[i]= vec4( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0, angle );\n\n        float bdist = distance(uv, Balls[i].xy);\n        if(bdist<radius){\n            dist=bdist;\n            if(bdist<(radius-pixel)){currentBall = i;}\n            centre = vec2(Balls[i].x, Balls[i].y);\n            vec3 TAbcol = vec3(0.9,1.0,0.9);\n            vec3 TAfcol = vec3(0.1,0.7,0.1);\n            vec3 TBbcol = vec3(0.1,0.0,0.0);\n            vec3 TBfcol = vec3(1.0,0.0,0.0);\n            \n            if(i<5){Tcolf=TAfcol;Tcolb=TAbcol;}else{Tcolf=TBfcol;Tcolb=TBbcol;}\n            float f;\n            float ringRadius=0.8;\n            float ringWidth = 0.1;\n            if(i>4){flatTop=true;ringRadius=0.45;}else{flatTop=false;ringRadius=0.8;}\n            if(bdist>radius*(ringRadius+ringWidth)){\n                f = smoothstep(radius*(ringRadius+ringWidth), (radius*(ringRadius+ringWidth))+pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else if (bdist<radius*ringRadius){\n                f = smoothstep(radius*ringRadius, (radius*ringRadius)-pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else {\n                bcol = Tcolf;\n            }\n        } else if(bdist<dist){ dist=bdist;}\n    }\n\n    float rotation;\n    if(currentBall>4){\n        rotation = Balls[currentBall].w + rightAng;\n    } else {rotation = Balls[currentBall].w - rightAng;}\n    // Spoiler flap\n    float SpFoffset = radius*3.0;// set distance from centre to front\n    float SpBoffset = radius/1.8;// set distance from centre to back\n    float SpFheight = radius*-1.5;// set front and back heights\n    float SpBheight = radius*1.2;\n    float SpWidth = radius/1.6;// set width, length, height of triangle\n    float SpLength = SpFoffset+SpBoffset;\n    float SpHeight = SpBheight-SpFheight;\n    vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation), 0.0, centre.y + SpFoffset * sin(rotation));// get front point F\n    vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.z -= (SpWidth * cos(rotation));// get front points L and R\n    vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.z += (SpWidth * cos(rotation));\n    vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), 0.0, centre.y - SpBoffset * sin(rotation));// get back point B\n    vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.z -= (SpWidth * cos(rotation));// get back points L and R\n    vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.z += (SpWidth * cos(rotation));\n    float SpBD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpBl.x, 0.0, SpBl.z), vec3(SpBr.x, 0.0, SpBr.z) );// get distance from back\n    float SpFD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpFl.x, 0.0, SpFl.z), vec3(SpFr.x, 0.0, SpFr.z) );// get distance from front\n    float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point\n    float inTri = sdTriangle(uv, SpFc.xz, SpBr.xz, SpBl.xz);// is point in triangle\n    //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is\n    \n    float lineDist = linePointLength( vec3(uv.x, 0.0, uv.y) , vec3(SpBc.x, 0.0, SpBc.z)  , vec3(SpFc.x, 0.0, SpFc.z)  );\n    if(currentBall<5){\n        float gfline = 2.7;\n        float gflinew = 0.011;\n        if(lineDist>radius/gfline&&lineDist<(radius/gfline)+gflinew&&dist<radius*0.9)\n            {\n            if(lineDist<(radius/gfline)+(gflinew/5.0)){\n                float p = smoothstep(radius/gfline, radius/gfline + (gflinew/5.0), lineDist);\n                bcol = mix(Tcolb,Tcolf,  p);} else {\n                    float p = smoothstep((radius/gfline)+gflinew, (radius/gfline)+gflinew - (gflinew/5.0), lineDist);\n                    bcol = mix(bcol,Tcolf,  p);\n                }\n            } else if (lineDist<(radius/gfline)+gflinew ){bcol = Tcolb;}\n    }\n    \n    float power = 32.0;\n    float power2 = 32.0;\n    float height = sqrt((radius*radius)-(dist*dist));\n    vec2 distv = uv - centre;\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n  \n    if(flatTop){\n        if(height>theight){\n            height=theight;\n            normal = vec3(0.0, 1.0, 0.0);\n            power = power2;\n        }\n        float p = smoothstep(theight-0.01, theight, height);\n        normal = mix(normal,vec3(0.0, 1.0, 0.0),  p);\n        height = mix(height,theight,  p);\n    }\n    if(SpH>height&&currentBall<10){// is spoiler higher than dome\n        float face = 0.7;  \n        if(inTri<0.0){\n        power = power2;\n        float s = smoothstep(0.0, -0.002, inTri);\n        bcol=mix(Tcolb, Tcolf, s);\n        if(inTri<-0.005){\n            s = smoothstep(-0.01, -0.008, inTri);\n            bcol=mix(Tcolb, Tcolf, s);\n        }\n            s = smoothstep(0.0, pixel*6.0, SpH-height);\n            height=mix(height, SpH, s);\n            normal=mix(normal,vec3( face * cos(rotation), 0.9 , face * sin(rotation)), s);\n        } \n        if (inTri<radius/10.0&&inTri>0.0) {\n            power = power2;\n            bcol=Tcolb;\n            float s = smoothstep(0.0, radius/6.0, inTri);\n            height=mix(SpH,height,  s);\n            normal=mix(vec3( face * cos(rotation), 0.9 , face * sin(rotation)),normal, s);\n        }\n    }\n    \n    normal = normal/length(normal);\n\n    vec3 position = vec3(uv.x, height, uv.y);\n        \n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n\n    vec3 lcolA = vec3(0.0,0.4,0.0);\n    vec3 lcolB = vec3(0.5,0.0,0.0);\n    vec3 lcolC = vec3(0.4,0.4,0.5);\n\n    vec3 lcolAmbient = (lcolA+lcolB+lcolC+lcolC+lcolC)/(7.0);\n        \n    gcol *= lcolAmbient;\n\n    vec3 lightA = vec3(0.0-0.3, 0.1, 0.5);\n    vec3 lightB = vec3(ar+0.3, 0.1, 0.5);\n    vec3 lightC = vec3(0.5*ar,0.2, 0.5);\n        \n    float f;\n    \n    vec3 goalRT = vec3(ar-0.1, 0.2, 0.65);\n    vec3 goalRB = vec3(ar-0.1, 0.2, 0.35);\n\n    float lightBTG = (goalRT.z-lightB.z)/(lightB.x-goalRT.x);\n    float lightBTGdist = ( (lightB.x - uv.x) * lightBTG) -  (uv.y-lightB.z);\n    float lightBBG = (goalRB.z-lightB.z)/(lightB.x-goalRB.x);\n    float lightBBGdist =    (uv.y-lightB.z)-( (lightB.x - uv.x) * lightBBG);\n    float lightBdist = lightBBGdist*lightBTGdist;\n    \n    vec3 goalLT = vec3(0.1, 0.2, 0.65);\n    vec3 goalLB = vec3(0.1, 0.2, 0.35);\n\n    float lightATG = (goalLT.z-lightA.z)/(lightA.x-goalLT.x);\n    float lightATGdist = ( (lightA.x - uv.x) * lightATG) -  (uv.y-lightA.z);\n    float lightABG = (goalLB.z-lightA.z)/(lightA.x-goalLB.x);\n    float lightABGdist =    (uv.y-lightA.z)-( (lightA.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n\n    vec3 tolightA = lightA - position;\n    vec3 tolightB = lightB - position;\n    vec3 tolightC = lightC - position;\n\n    float distlA = length(tolightA);\n    float distlB = length(tolightB);\n    float distlC = length(tolightC);\n\n    tolightA = tolightA/distlA;\n    tolightB = tolightB/distlB;\n    tolightC = tolightC/distlC;\n    \n    float lamntA = max(0.0, dot(tolightA, normal));\n    float lamntB = max(0.0, dot(tolightB, normal));\n    float lamntC = max(0.0, dot(tolightC, normal));\n\n    float specamntA = pow(max(0.0, dot(tolightA, reflection)), power);\n    float specamntB = pow(max(0.0, dot(tolightB, reflection)), power);\n    float specamntC = pow(max(0.0, dot(tolightC, reflection)), power);\n    if( dist > radius ){ height = 0.0;}\n    \n    vec3 tlightA = (lcolA*specamntA)+(lcolA*lamntA);\n    vec3 tlightB = (lcolB*specamntB)+(lcolB*lamntB);\n    vec3 tlightC = (lcolC*specamntC)+(lcolC*lamntC);\n    \n    tlightA*=2.0;\n    tlightB*=2.0;\n    tlightC*=3.0;\n    \n    int Btotal;\n    int Atotal;\n    int Ctotal;\n    float Bmost=0.0;\n    float Amost=0.0;\n    float Cmost=0.0;\n        \n    bool Bcast = false;\n    float BcastDepth;\n    bool Acast = false;\n    float AcastDepth;\n    for(int i=0;i<numballs;i++){\n        if(i!=currentBall){\n            vec3 ballcast = Balls[i].xzy;\n            float beamA = linePointLength(ballcast, lightA, vec3(uv.x, height, uv.y));\n            float beamB = linePointLength(ballcast, lightB, vec3(uv.x, height, uv.y));\n            float beamC = linePointLength(ballcast, lightC, vec3(uv.x, height, uv.y)); \n\n            float cradius = radius*1.04;\n               \n            if (beamC>(cradius)){Ctotal+=1;} else if ((cradius-beamC) > Cmost) {Cmost = cradius-beamC;}\n\n            if (beamA>(radius)){ Atotal+=1;} else {\n                if ((radius-beamA) > Amost) {Amost = radius-beamA;}\n                if (height>0.0  && (uv.x>Balls[i].x) ){ Acast = true; AcastDepth=radius-beamA;}\n            }\n\n            if (beamB>(radius)){\n                Btotal+=1;\n            } else {\n                if ((radius-beamB) > Bmost) {Bmost = radius-beamB;}\n                if(height>0.0  && (uv.x<Balls[i].x) ){Bcast = true;BcastDepth=radius-beamB;}\n            }\n\n            }\n        }\n        float lcolAinc = lightA.y/(lightA.x-uv.x);\n        f = smoothstep(0.0, uv.x/40.0, lightAdist);\n        vec3 gacol = mix(gcol,gcol+(lcolA*-lcolAinc*1.2),  f);\n        tlightA = mix(vec3(0.0,0.0,0.0),tlightA,  f);\n        if(Atotal==10){\n            \n            gcol = gacol;\n        }  else {\n            Amost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Amost);\n            gcol = mix(gcol,gacol,  f);\n            if(Acast){\n                f = smoothstep(0.0, 0.01, AcastDepth);\n                tlightA = mix(tlightA,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n        float lcolBinc = lightB.y/(lightB.x-uv.x);\n        f = smoothstep(0.0, (ar-uv.x)/40.0, lightBdist);\n        vec3 gbcol = mix(gcol,gcol+(lcolB*lcolBinc*1.2),  f);\n        tlightB = mix(vec3(0.0,0.0,0.0),tlightB,  f);\n        if(Btotal==10){\n            \n            gcol = gbcol;\n        }  else {\n            Bmost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Bmost);\n            gcol = mix(gcol,gbcol,  f);\n            if(Bcast){\n                f = smoothstep(0.0, 0.01, BcastDepth);\n                tlightB = mix(tlightB,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n    vec3 VA = vec3(lightC.x-uv.x, lightC.y, lightC.z-uv.y);\n    vec3 VB = vec3(0.0, 1.0, 0.0);\n    VA = VA/length(VA);\n    float lcolCinc = dot(VB,VA );\n    if(Ctotal==10 ||  dist < (radius-pixel)){    \n        gcol = gcol+(lcolC*lcolCinc*1.2);\n    }  else if(dist > (radius-pixel)) {\n        Cmost *=80.0;\n        f = smoothstep(0.4 + (dist-radius)*5.0, 0.0, Cmost);\n        gcol = mix(gcol, gcol+(lcolC*lcolCinc*1.2), f);\n    }\n\n    // Multiplying and then adding light like this is not correct\n    bcol*=(1.0+tlightA+tlightB+tlightC+lcolAmbient)/4.0;\n    bcol+=(tlightA+tlightB+tlightC+lcolAmbient)/4.0;  \n    f = smoothstep(radius-pixel, radius, dist);\n    col = mix(bcol, gcol, f);\n    if( dist > radius ) { col = gcol; }\n\n    if(outputMode){col = outputColour;}\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}