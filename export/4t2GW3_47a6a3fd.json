{"ver":"0.1","info":{"id":"4t2GW3","date":"1433622932","viewed":3404,"name":"Arabesque #2","username":"mplanck","description":"Second draft of a series that began with [url]https://www.shadertoy.com/view/4lBGWW[/url]. ","likes":54,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","arabesque"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define REALLY_SMALL_NUMBER 0.0001\n#define BIG_NUMBER 1000000.\n#define PI 3.14159\n#define TWO_PI 6.28318\n\nfloat g_time = 0.;\n    \n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ray_origin,\n                     vec3 ray_direction,\n                     vec3 plane_origin,                     \n                     vec3 plane_normal)\n{\n    float ray_direction_dot_normal = dot(ray_direction, plane_normal);\n\n    float denominator = ray_direction_dot_normal;\n    \n    float intersected = 0.;\n    float t = BIG_NUMBER;\n    if (abs(denominator) > REALLY_SMALL_NUMBER) {\n        t = -dot(plane_normal, (ray_origin - plane_origin)) / denominator;    \n        if (t > REALLY_SMALL_NUMBER) {\n            intersected = 1.;\n        }\n    }\n    return vec2(intersected, t);\n\n}\n\nfloat grayscale(vec3 c)\n{\n    return dot(c, vec3(.21, .72, .07));\n}\n\nvoid mirror_test(vec3 o, vec3 r, vec3 po, vec3 pn,\n                 inout vec3 rn,\n                 inout float t)\n{\n    \n    vec2 hr = intersect_plane(o, r, po, pn);\n    if (hr.x > .5 && t > hr.y)\n    {\n        rn = pn;\n        t = hr.y;\n    }\n}\n\nfloat dist_to_line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 l = normalize(b-a);\n    return length((a-p) - dot((a - p), l) * l);    \n}\n\nvec3 shade_end(vec3 hp, float reflect_depth)\n{\n\n    float sr = .02 * mod(reflect_depth - 160. * g_time, 50.);\n\n    float sm = texture(iChannel0, vec2(.0, .5)).r;\n    \n    //vec3 c = mix(vec3(1.2, .8, .1), vec3(1., .0, .0), sr);\n    //vec3 c = mix(vec3(.8), vec3(0.05), sr);\n    vec3 c = mix(vec3(1.2, .8, .1), vec3(1., -.1, .0), sr);\n    \n    c += .5 * pow((1. - sr), 4.);\n    float sp = BIG_NUMBER;\n    \n    vec2 p1 = vec2(0., sin(10. * g_time));\n    vec2 p2 = vec2(-.866, -.5 * sin(5. * g_time));\n    vec2 p3 = vec2(.866, -.5 * sin(10. * g_time + 3.14));\n    \n    sp = min(dist_to_line(hp.xz, p1, p2), sp);\n    sp = min(dist_to_line(hp.xz, p2, p3), sp);\n    sp = min(dist_to_line(hp.xz, p3, p1), sp);    \n\n    c = (.4 + .6 * smoothstep(0., .6, sp)) * (.5 + .5 * smoothstep(0., .08, sp)) * c;\n\n    float sb = BIG_NUMBER;\n    vec2 b1 = vec2(0., 1.732);\n    vec2 b2 = vec2(-1.6, -1.);\n    vec2 b3 = vec2(1.732, -1.);\n    \n    sb = min(dist_to_line(hp.xz, b1, b2), sb);\n    sb = min(dist_to_line(hp.xz, b2, b3), sb);\n    sb = min(dist_to_line(hp.xz, b3, b1), sb);    \n\n    \n    c = (.8 + .2 * smoothstep(0., .5, sb)) * (.2 + .8 * smoothstep(0., .08, sb)) * c;\n    \n    return c;\n}\n\nvec3 trace_arabesque(vec3 rd, \n                     vec3 ro)\n{\n \n    vec3 r = rd;\n    vec3 o = ro;  \n    vec3 c = vec3(0.);\n    for (float i = 0.; i < 35.; i += 1.)\n    {\n        float t = BIG_NUMBER;\n        vec3 hn = vec3(0.);\n\n        // Test intersection with the mirrors of the arabesque\n        mirror_test(o, r, vec3(.5, 0., .866),  vec3(.866, 0., .5),  hn, t);\n        mirror_test(o, r, vec3(0., 0., -1.),   vec3(0., 0., 1.),    hn, t);\n        mirror_test(o, r, vec3(-.5, 0., .866), vec3(-.866, 0., .5), hn, t);        \n\n        // Now test the shaded plane at the bottom of the arabesque\n        vec2 pt = intersect_plane(o, r, vec3(0., -10., 0.), vec3(0., 1., 0.));\n        if (pt.x > .5 && t > pt.y)\n        {\n            t = pt.y;\n            vec3 hp = o + r * t;\n            c += shade_end(hp, i);\n            break;\n        }\n\n        // If loop isn't broken, reflect the mirrors of the arabesque \n        // and repeat\n        o = o + r * t;\n        r = reflect(r, hn);\n\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    g_time = .1 * iTime;\n    \n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.y *= invar;\n    \n    vec3 iz = vec3(0., -1., 0.);\n    vec3 ix = vec3(cos(1. * g_time), 0., sin(1. * g_time));\n    vec3 iy = normalize(cross(ix, iz));\n    \n    vec3 o = vec3(0., 5. * sin(2. * g_time + PI * iMouse.x/iResolution.x) + 8., 0.);\n    vec3 r = normalize(ix * uv.x + iy * uv.y + .3 * iz);\n        \n    vec3 c = trace_arabesque(r, o);\n    \n    // gamma correct\n    c = pow(c, vec3(.45));\n    \n    fragColor = vec4(c, 1.);\n}","name":"","description":"","type":"image"}]}