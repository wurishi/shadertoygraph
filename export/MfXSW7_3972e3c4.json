{"ver":"0.1","info":{"id":"MfXSW7","date":"1705332788","viewed":49,"name":"Raymarching1.0","username":"CasHendrix","description":"testing...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdOctahedron(vec3 p, float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 palette(float t){\n    vec3 a = vec3(1.308, 0.500, 0.500);\n    vec3 b = vec3(-1.502, 0.500, 0.500);\n    vec3 c = vec3(-1.642, 1.000, 0.698);\n    vec3 d = vec3(-1.672, -0.552, 0.667);\n    \n    return a+b*cos(6.28318*(c*t+d));\n}\n\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// new map ++++++++++++++++++++++++++++++++++++++++++++++++++++\nfloat map(vec3 p){\n    p.z += iTime * .4; // Forward movement\n    \n    p = fract(p) - .5; // space repetition\n\n    float box = sdOctahedron(p, .15); // cube\n\n    return box;\n}\n\n// original map +++++++++++++++++++++++++++++++++++++++++++++++\n// float map(vec3 p){\n//     vec3 spherePos = vec3(sin(iTime)*3., 0, 0);\n//     float sphere = sdSphere(p - spherePos, 1.);\n\n//     vec3 q = p; // input copy\n\n//     q.y -= iTime * .4; // Upward movement\n\n//     q = fract(p) - .5; // space repetition\n\n//     //q.xy *= rot2D(iTime);\n\n//     float box = sdBox(p, vec3(.75)); // cube\n\n//     float ground = p.y + .75; //ground\n\n//     return smin(ground, smin(sphere, box, 2.), 1);\n// }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    // initialization\n    vec3 ro = vec3(0, 0, -3); // ray origin\n    vec3 rd = normalize(vec3(uv, 1));    // ray direction\n    vec3 col = vec3(0);\n\n    float t = 0.; // total distance travelled\n    \n    // Vertical camera rotation\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);   \n    \n    // Horizontal camera rotation\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n\n    // Raymarching\n    int i;\n    for(int i = 0; i < 80; i++){\n        vec3 p = ro + rd *t; // position along the ray\n\n        float d = map(p); //current distance in the scene\n        \n        t += d; //march\n\n        col = vec3(i) / 80.;\n\n        if(d < .001 || t > 100.) break; // early stop\n\n    }\n\n    // Coloring\n    col = palette(t*.04 + float(i)*.005);\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}