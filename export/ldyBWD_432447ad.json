{"ver":"0.1","info":{"id":"ldyBWD","date":"1528840282","viewed":2887,"name":"Boxy Pikachu","username":"fizzer","description":"A fanart recreation of the new boxy Pikachu design from the Nintendo game Pokémon Quest.\nIt turns out Pokémon are easy to make with SDFs when they are made of boxes!","likes":63,"published":1,"flags":0,"usePreview":0,"tags":["nintendo","pikachu","boxy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 4 // Anti-aliasing sampling box size factor. Total number of samples will be AA ^ 2\n\n#define PI 3.141592653589\n\nfloat time;\n\n// 2D rotation matrix\nmat2 rotmat(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n// Rounded box distance with internal distance, 2D version.\nfloat box(vec3 p,vec3 s)\n{\n    p=abs(p)-s;\n    float d=max(p.x,max(p.y,p.z));\n    return max(d,length(max(p,vec3(0))));\n}\n\n// Rounded box distance with internal distance, 3D version.\nfloat box(vec2 p,vec2 s)\n{\n    p=abs(p)-s;\n    float d=max(p.x,p.y);\n    return max(d,length(max(p,vec2(0))));\n}\n\n// The main body SDF, sans mouth.\nfloat body(vec3 p)\n{\n    float d=1e4;\n    p.y+=.05;\n\n    // Tail, made of some rotated boxes.\n    float taild;\n    vec3 tp=p;\n    tp.xy*=rotmat(0.2);\n    taild=box(tp-vec3(1,0.4,1.2),vec3(.5,.3,.1))-.1;\n    taild=min(taild,box(tp-vec3(1.2,1.3,1.2),vec3(.3,.7,.1))-.1);\n    taild=min(taild,box(tp-vec3(1.9,1.5,1.2),vec3(.9,.5,.1))-.1);\n\n    d=min(d,taild);\n\n    // Rest of the body is symmetrical.\n    p.x=abs(p.x);\n\n    // Torso / head.\n    d=min(d,box(p,vec3(.93,.7,.95))-.2);\n    \n    // Ears\n    d=min(d,box(p-vec3(.6,1,-.6+p.y/8.),vec3(.2,1.1,.05))-.1);\n\n    // Feet\n    p-=vec3(-.1,.05,.1);\n    d=min(d,box(vec3(p.xy,abs(p.z-.1))-vec3(.7,-1,.7),vec3(.23,.4,.15))-.06);\n    p-=vec3(.7,-1.4,-.0);\n    p.z=abs(p.z);\n    d=min(d,box(p-vec3(0,0,0.7),vec3(.23,.05,.2))-.06);\n    \n    return d;\n}\n\n// The complete body.\nfloat bodyWithMouth(vec3 p)\n{\n    float d=body(p);\n    \n    p.x=abs(p.x);\n    \n    // Main mouth shape.\n    d=max(d,-(box(p-vec3(0,-.4,-2),vec3(.34,.14,1.2))-.012));\n    \n    // The upper triangular part, which is just a rotated box.\n    p.y+=.21;\n    p.z+=2.;\n    p.xy*=rotmat(-1.);\n    d=max(d,-(box(p,vec3(.1,.05,1.2))-.012));\n    \n    return d;\n}\n\n// Scene SDF.\nfloat f(vec3 p)\n{\n    return bodyWithMouth(p);\n}\n\n// Linstep, for cheaper smoothening of texture edges.\nfloat linstep(float a,float b,float x)\n{\n    return clamp((x-a)/(b-a),0.,1.);\n}\n\n// Face texture.\nvec3 face(vec2 p)\n{\n    p.y*=1.1;\n    vec3 c=vec3(1,1,.2);\n    \n    // Mirrored through X axis.\n    p.x=abs(p.x);\n    \n    // Eyes\n    c=mix(c,vec3(0),linstep(.02,.01,box(p-vec2(.45,.3),vec2(.15,.17))));\n    c=mix(c,vec3(1),linstep(.02,.01,box(p-vec2(.4,.39),vec2(.04,.04))));\n    \n    // Nose\n    c=mix(c,vec3(0),linstep(.02,.01,box(p-vec2(0,-.02),vec2(.07,.03))));\n    \n    // Cheeks\n    c=mix(c,vec3(1,.15,.04),linstep(.02,.01,box(p-vec2(0.7,-.25),vec2(.18,.2))));\n    \n    return c;\n}\n\n// Maps [0, 1] x [0, 1] to unit disc.\nvec2 disc(vec2 uv)\n{\n   float a = uv.x * PI * 2.;\n   float r = sqrt(uv.y);\n   return vec2(cos(a), sin(a)) * r;\n}\n\n// Maps [0, 1] x [0, 1] to disc with linear distribution.\nvec2 tent(vec2 uv)\n{\n\treturn disc(vec2(uv.x, 1. - sqrt(1. - uv.y)));\n}\n\nvec3 sampleScene(vec2 coord)\n{\n    vec2 t = coord / iResolution.xy * 2. - 1.;\n\tt.x *= iResolution.x / iResolution.y;\n    \n    // Set up primary ray.\n    float an=7.;\n    vec3 ro=vec3(.3,0.6,15.);\n    vec3 rd=normalize(vec3(t.xy,-5.));\n\n    // Intersect with ground plane.\n    float groundt=(-1.55-ro.y)/rd.y;\n\n\t// Compositional orientation.\n    rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n    ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n    // Animating orientation.\n    mat2 rx=rotmat(cos(time*7.)*.1);\n    mat2 rz=rotmat(cos(time*3.)*.1);\n\n    ro.y-=abs(sin(time*7.+PI))/8.+.05;\n    ro.yz*=rx;\n    rd.yz*=rx;\n\n    ro.xy*=rz;\n    rd.xy*=rz;\n\n    // Reject negative ground plane intersection distance.\n    if(groundt<0.)\n        groundt=1e4;\n\n    float dt=5.,d=0.;\n    \n    // Trace through SDF.\n    for(int i=0;i<140;++i)\n    {\n        d=f(ro+rd*dt);\n        if(abs(d)<1e-3||dt>20.||dt>groundt)\n            break;\n        dt+=d;\n    }\n\n    // Backdrop colour.\n    vec3 c=vec3(.5,15,.3)*.9;\n    \n    if(groundt<dt)\n    {\n        // Ground is nearer. Just apply some basic shadow shape.\n        vec3 rp=ro+rd*groundt;\n        c*=mix(.7,1.,linstep(0.,.1,box(rp.xz,vec2(1.))-.5));\n    }\n    else if(dt<20.)\n    {   \n        // SDF is nearer.\n        float d2=f(ro+rd*dt+normalize(vec3(-2,2,-1))*1e-2);\n        float l=.5+.5*(d2-d)/1e-2;\n\n        // Get the intersection point.\n        vec3 rp=ro+rd*dt;\n\n        // Determine a colour based on where the ray hit is.\n        \n        c=vec3(1,1,.2);\n\n        if(bodyWithMouth(rp)>body(rp))\n            // Main body.\n            c=vec3(1.3,.5,1)/2.*mix(.5,1.,smoothstep(.3,.6,l));\n        else if(rp.z<-1.)\n            // Face texture.\n            c=face(rp.xy);\n        else if(rp.y>1.2&&rp.z<0.)\n            // Tips of ears.\n            c=mix(c,vec3(0),linstep(0.,.01,rp.y-1.7));\n\n        // Stripes on back.\n        rp.xz=abs(rp.xz-vec2(0,.3))-vec2(0,.3);\n        rp.y-=.8;\n        float stripesd=box(rp,vec3(6,.5,.15))-.02;\n        c=mix(c,vec3(1,.5,.1)/4.,linstep(.01,0.,stripesd));\n\n\t\t// Apply some directional light.\n        c*=mix(vec3(1,1,.8)*.9,vec3(1),smoothstep(.3,.31,l));\n    }\n    \n    return c;\n}\n\n\n// Hash function from IQ.\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n\tfragColor.a = 1.;\n\n    fragColor.rgb = vec3(0);\n    \n    // Toroidal shift for anti-aliasing samples.\n    float hashindex=fragCoord.x+fragCoord.y*957.;\n    vec2 uvshift=vec2(hash(hashindex*2.),hash(hashindex*2.+1.));\n    \n    // Anti-aliasing loop.\n    for(int y=0;y<AA;++y)\n        for(int x=0;x<AA;++x)\n        {\n            // Get a filter kernel samplepoint. Here a tent filter is used.\n            vec2 uv=fract(vec2(float(x)+.5,float(y)+.5)/float(AA)+uvshift);\n            vec2 offset = tent(uv);\n            \n            // Sample the scene.\n\t\t    fragColor.rgb += clamp(sampleScene(fragCoord + offset), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n    \n    // Gamma correction.\n    fragColor.rgb=pow(fragColor.rgb,vec3(1./2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}