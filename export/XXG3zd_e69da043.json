{"ver":"0.1","info":{"id":"XXG3zd","date":"1718149971","viewed":29,"name":"Ice Exoplanet","username":"PederW","description":"Just a little experiment with raymarching and noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = 3.1415926;\nfloat expLine(float x, int e) {\n    return floor(x) + pow(mod(x,1.),float(e));\n}\nvec3 palette(float t) {\n    return (.5+.5*cos(6.28318*(t+vec3(.3,.416,.557))))*.7;\n}\nmat2 rot2d (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nvec2 rand2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(st)*43758.5453123);\n}\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( rand2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( rand2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( rand2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( rand2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nvec3 Voronoi(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    float mdist = 10.;\n    vec2 mpoint;\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = rand2(iuv + neighbor);\n            point = 0.5 + 0.5*sin(6.2831*point);\n            vec2 diff = neighbor + point - fuv;\n            float dist = length(diff);\n\n            if( dist <= mdist) {\n                mdist = dist;\n                mpoint = point;\n            }\n        }\n    }\n    return vec3(mpoint,mdist);\n}\nfloat map (vec3 p, vec3 mpos){\n    vec2 q = vec2(p.x+iTime,p.z);\n    return p.y+noise(vec2(p.x,p.z)/10.+vec2(iTime/10.,0.))*2.5+(noise(vec2(q.x+23.+iTime/10.,q.y+15.))/10.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y; //normalized screen uv from -1 to 1\n    vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y; //mouse uv\n    m = vec2(.2,.7);\n    \n    //init\n    vec3 ro = vec3(0.,0.,-5.); //ray orgin\n    vec3 rd = normalize(vec3(uv,1.)); //ray direction\n    \n    ro.yz *= rot2d(-m.y*pi/2.+pi/2.);\n    rd.yz *= rot2d(-m.y*pi/2.+pi/2.);\n    ro.xz *= rot2d(-m.x*pi/2.*iResolution.x/iResolution.y);\n    rd.xz *= rot2d(-m.x*pi/2.*iResolution.x/iResolution.y);\n    \n    float td = 0.; //total distance travelled\n    vec3 col = vec3(uv,0.);\n    \n    //raymarching\n    int i;\n    vec3 p;\n    for (i = 0; i < 50; i++){\n        p = ro+rd*td; //position along the ray\n        \n        float d = map(p,vec3(m,0.)); //distance to object\n        td+=d;\n        if (abs(d)<.001) break; //stop if close or far enough\n        if (td>100.) {\n        td=100.;\n        break;\n        }\n    }\n    col=palette((float(i)*.005+clamp(p.y,-1.,5.)*.1)/2.+0.3)/1.2+.2;\n    col+=Voronoi(vec2(p.x+iTime,p.z)).z/(3.*(p.y+2.))/5.;\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}