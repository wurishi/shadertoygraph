{"ver":"0.1","info":{"id":"sdsyW2","date":"1642752893","viewed":354,"name":"Infinity isometric zoom v.2","username":"bitless","description":"More complicated version of this my quick sketch: https://www.shadertoy.com/view/stySDD","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["2d","zoom","infinity","isometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: Infinity isometric zoom v.2\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define D 5.  //cycle duration\n#define  CLR vec4(.0,.005,.05,1)   //back color\n#define rot(a)   mat2(cos(a + vec4(0,11,33,0)))                             //rotate 2d\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )                   //iq's palette\n#define K 1.7320508 //sqr(3)\n#define B(x, a, b) ( x >= a && x <= b) //boolean: check x between a and b  \n\n\nfloat h21(vec2 p)  //hash21\n{\n    return fract(sin(dot(p.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\nfloat noise( in vec2 f ) //gradient noise\n{\n    vec2 i = floor( f );\n    f -= i;\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( h21( i + vec2(0,0) ), \n                     h21( i + vec2(1,0) ), u.x),\n                mix( h21( i + vec2(0,1) ), \n                     h21( i + vec2(1,1) ), u.x), u.y);\n}\n\n\n//  Minimal Hexagonal Grid - Shane\n//  https://www.shadertoy.com/view/Xljczw\nvec4 getHex(vec2 p) //hex grid coords \n{\n    vec2 s = vec2(1, K);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nvec3 HexToSqr (vec2 st, inout vec3 n) //hexagonal cell coords to square face coords + face normal \n{ \n    vec3 r;\n    if (st.y > -abs(st.x)*1./K)\n        if (st.x > 0.) \n            {r = vec3((vec2(st.x,(st.y+st.x/K)*K/2.)*2.),2); n = vec3(1,0,0);} //right face\n        else\n            {r = vec3(-(vec2(st.x,-(st.y-st.x/K)*K/2.)*2.),3); n = vec3(0,1,0);} //left face\n    else \n        {r = vec3 (-(vec2(st.x+st.y*K,-st.x+st.y*K)),1); n = vec3(0,0,1);} //top face\n    return r;\n}\n\nvec3 L; //light vector\nfloat N, I, F, R, CN, CH; //cycle number, layer number, transition phase, random factor, num of cells, num of cubes  \n\nvec4 Pal (float t) //return color from palette\n{\n    return vec4(p(t,vec3(.5),vec3(.5),vec3(1.),vec3(.0,.2,.4)),1);\n}\n\nvec4 Face(vec4 C, vec2 uv, vec3 nr, float h, float g) //draw face of cube\n{\n    float m =  dot (nr,L); //face lighting\n    vec2 id = uv*((g==0.)?5.:(floor(h*3.)+3.)) //cell id\n        ,l = fract(id); //local cell coord\n    id -= l;\n    l -= .5;\n    nr.z += h21(id+R+h+g) + noise(l*100.)*.2; //cell normal deviation + gradient noise\n    nr.xy += l*.25*rot(F*12.56+nr.z*2.); //rotate cell normal for \"glass effect\"\n    return mix (C*dot(nr,L)*m, vec4(0), smoothstep (-.5,.5,max(l.x,l.y))*.6); //mix face color + face lighting + cell lighting + inner edge \n}\n\nvoid Voxel (vec2 uv, vec2 lc, vec2 sh, inout vec4 C, bool m) //cubes on floor\n{\n    uv += sh*vec2(-1,1./K/2.) ;\n    vec2 id = floor(vec2((uv.x+uv.y*K),(uv.x-uv.y*K))); //isometric grid cell's id\n\n    float   h = h21(id+R) //random factor for cube \n            ,sz = 1. + fract(h*10.)*.75 //voxel size variation\n            ,sm = 3./iResolution.y; //smoothing factor\n      \n    vec3 nr  //face normal\n        ,vx = HexToSqr(lc-vec2(sh.x,(sh.y-1./sz)/K/2.),nr);  //voxel face coords, face id and face normal\n  \n    nr.xy = nr.yx;\n    vx.xy *= sz;\n    \n    vec4 V = Pal(fract(h*5.)); //color of a cube\n\n    V = mix (Face(V, vx.xy, nr, h, vx.z), CLR, smoothstep(1.,4.,I-F)); //decrease color variation of small cubes for noise reducing \n    \n    C = mix (C, vec4(V.rgb,1) , smoothstep(1.+sm,1.-sm,max(vx.x,vx.y))\n                * float(m                                           //cell mask\n                        && B(id.x, 0., CN-1.) && B(id.y, -CN, -1.)     //cube on floor of celll\n                        && (id.x - id.y) > CN-CH\n                        && (fract(h*100.) > .4))                    //cube visibility random factor\n    ); \n}\n \n\nvoid mainImage( out vec4 O, in vec2 g)\n{\n\n    vec2 r = iResolution.xy\n        ,u = (g+g-r)/-r.y/2.\n        ,lc;\n    \n    L = normalize(vec3(abs(sin(iTime*.5))*.8+.5,abs(cos(iTime*.5))*.8+.5,sin(iTime*1.3)*1.+2.)); //light vector direction\n\n    float  T = mod(iTime,D);\n    \n    N = floor(iTime/D);            //cycle number\n    F = T/D;                       //cycle duration 0..1\n    \n    R = h21(vec2(0,1)+N-1.);        //random factor for current layer\n    float   Rn = h21(vec2(0,1)+N),    //random factor for second layer\n            CNn = floor(Rn*5.)+4.,  //num of cells for second layer 4..8\n            CHn = floor(fract(Rn*10.)*(CNn-3.)),  //num of cubes for next layer 0..4\n            f = smoothstep(0.,1.,F), //cycle duration 0..1 (for smoother transition)\n            a = 1.,  //alpha mask of curent layer \n            an,  //alpha mask of previuos layer\n            n;\n            \n    CN = floor(R*5.)+4.;//num of cells for first layer 4..8\n    CH = floor(fract(R*10.)*(CN-3.));//num of cubes for first layer 0..4\n    f =  f*(log2(f+1.));\n\n    u /= exp (log(CNn)*F); //zoom during transition \n    u.y -= ((CN-CH-4.) + (CNn-CHn-4.)*f/(1.+(CNn-1.)*f))/K;  //move camera to next cell during transition\n    \n    O -= O;\n\n    vec3 s,nr;\n    vec4 C = vec4(0), h, CL;\n\n    vec2[4] sh = vec2[4] (vec2(0,0),vec2(.5,1),vec2(-.5,1),vec2(0,2)); //coordinate offsets for voxel neighbors \n    \n    for (I=0.; I < 6. && (a>0.); I++)  //draw 5 layers of cubes\n    {\n        O = mix(O, Face(O, s.xy, nr, R, 0.),an); //draw previous layer cell sides   \n        \n        h = getHex(u+vec2(0,(CN-CH-2.)/K));  //hexagonal grid of curent layer\n        \n        s = HexToSqr(h.xy, nr);  //cell sides coordinates\n        an = a * float( B (h.w, abs(h.z), (CN-CH)/2.-1.)); //cell mask\n        \n        CL = mix (Pal(h21(h.zw+R)), CLR, smoothstep(1.,3.5,I-F));  //cell sides color + decrease color variation of small cubes for noise reducing \n        O = mix (O, CL, an);\n    \n        lc = floor(vec2((u.x+u.y*K),(u.x-u.y*K))); //cell id\n        f = mod(lc.x+lc.y+1.,2.);  //even and odd cells\n        lc = fract(vec2((1.-f)*.5-u.x,u.y*K-f*.5)) - .5;  //local cell corrdinates\n        lc.y /= K;\n        \n        for (int j = 0 ; j<4 ; j++) Voxel (u, lc, sh[j], C, (a>0.) && h.w > ((CN-CH)/2.-2.)); //draw cube and his neighbors\n        \n        O = mix (O, C, C.a); //mix cell with cubes on floor\n    \n        u.y += (CN-CH-1.)/K; //shift for next layer\n        h = getHex(u); //hexagonal grid of next layer\n        a *= float B(h.w, abs(h.z), ((CN-CH)/2.-.5)) * (1.-C.a);  //check visibility for next layer\n        \n        R = h21(h.zw+N+I); //random factor for a next layer\n        CN = floor(R*5.)+4.; //num of cells  for a next layer\n        CH = floor(fract(R*10.)*(CN-3.)); //num of cubes for a next layer\n\n        u = h.xy*CN;\n    }\n    \n    O = pow(O ,vec4(1./1.8)); //gamma correction\n}","name":"Image","description":"","type":"image"}]}