{"ver":"0.1","info":{"id":"4st3Wn","date":"1448998829","viewed":380,"name":"Filled Mandelbrot","username":"Kramin","description":"Mandelbrot with interior colouring","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define AA 2\n\n#define maxIteration 300\n#define CX -0.75\n#define CY 0.0\n#define INVZOOM 2.5\n#define T 20.0\n\nfloat getColourValue(float mu, float s, float m, float e)\n{\n    if (mu<s) {\n        return 0.0;\n    } else if (mu<m) {\n        return (mu - s)/(m-s);\n    } else if (mu<e) {\n        return 1.0 - (mu - m)/(e-m);\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float modtime = iTime*1.5; //controls the slight pulsating\n    float sinsq1 = max(0.0,sin(modtime)); sinsq1 = sinsq1*sinsq1;\n    float sinsq2 = max(0.0,sin(modtime+0.75)); sinsq2 = sinsq2*sinsq2;\n    float sinsq3 = max(0.0,sin(modtime+1.5)); sinsq3 = sinsq3*sinsq3;\n    float sinsq4 = max(0.0,sin(modtime+2.25)); sinsq4 = sinsq4*sinsq4;\n    float izoom = INVZOOM;\n    vec3 colour = vec3(0.0,0.0,0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    vec2 c = vec2(CX,CY) + (fragCoord+vec2(float(m),float(n))/float(AA)-iResolution.xy/2.0)*izoom/iResolution.y;\n    float w = float(AA*m+n);\n#else\n    vec2 c = vec2(CX,CY) + (fragCoord-iResolution.xy/2.0)*izoom/iResolution.y;\n#endif\n\tvec2 z = c;\n\tfloat iteration = float(maxIteration);\n\t\n\tfloat zlen = length(z);\n\tfloat minz = zlen;\n\tint minziter = 0;\n\t\n\tfor (int i = 0; i<maxIteration; i++) {\n        if (zlen > 3000.0) {\n            iteration = float(i);\n            break;\n        }\n        \n\t\tif (zlen < minz){\n\t\t  minziter = i;\n\t\t  minz = zlen;\n\t\t}\n\t\t\n\t\t// do z = z^2 + c\n\t\tz = mat2(z,-z.y,z.x)*z + c;\n\t\t\n\t\tzlen = length(z);\n\t}\n    \n\tif (iteration < float(maxIteration)){\n\t\t//smooth colouring\n\t\tfloat mu = float(iteration) - log(log(length(vec2(z))))/0.6931471805599453; //log(2.0) = 0.6931471805599453\n    \tmu = max(mu,0.0);\n\t\t//transform to between 0 and 1\n\t\t//mu/(mu+constant) goes to 1 as mu goes to infinity and to 0 as mu goes to 0.\n\t\t//This transformation is much better than a simple mu = mu/maxIteration because it \n\t\t//is independent of maxIteration\n\t\tmu=mu/(mu+T);\n\t\t\n\t\t//colour.x += getColourValue(mu,0.5,1.0,1.0) + getColourValue(mu,0.0,0.5,1.0)*0.9 + getColourValue(mu,-1.0,-0.5,0.5)*0.3;\n\t\t//colour.y += getColourValue(mu,0.5,1.0,1.0) + getColourValue(mu,0.0,0.5,1.0)*0.1 + getColourValue(mu,-1.0,-0.5,0.5)*0.0;\n\t\t//colour.z += getColourValue(mu,0.5,1.0,1.0) + getColourValue(mu,0.0,0.5,1.0)*0.1 + getColourValue(mu,-1.0,-0.5,0.5)*0.4;\n        colour += getColourValue(mu,0.5+0.05*(-0.5*sinsq2+0.5),1.0,1.0) + (0.2*sinsq2+0.8)*getColourValue(mu,0.0,0.5,1.0)*vec3(0.867,0.282,0.078) + (0.2*sinsq1+0.8)*getColourValue(mu,-1.0,-0.5,0.5)*vec3(0.302,0.114,0.208);\n\t}\n\telse {\n\t  float mu = float(minziter);\n\t  mu = (0.5+0.25*(-0.2*sinsq4+0.8))*10.0/(mu+10.0)+0.25*(-0.2*sinsq3+0.8)*sqrt(minz);//sqrt(minz) adds a little gradient to the interior \n\t  //colour.x += getColourValue(mu,0.0,0.7,1.0)*0.1 + getColourValue(mu,0.0,0.4,0.7)*0.0 + getColourValue(mu,0.0,0.1,0.5);\n\t  //colour.y += getColourValue(mu,0.0,0.7,1.0)*0.0 + getColourValue(mu,0.0,0.4,0.7)*0.6 + getColourValue(mu,0.0,0.1,0.5);\n\t  //colour.z += getColourValue(mu,0.0,0.7,1.0)*0.2 + getColourValue(mu,0.0,0.4,0.7)*0.8 + getColourValue(mu,0.0,0.1,0.5);\n      colour += getColourValue(mu,0.0,0.7,1.0)*vec3(0.302,0.114,0.208) + getColourValue(mu,0.0,0.4,0.7)*vec3(0.867,0.282,0.078) + getColourValue(mu,0.0,0.1,0.5);\n\t}\n#if AA>1\n    }\n    colour /= float(AA*AA);\n#endif\n  fragColor = vec4( colour.x, colour.y, colour.z, 1.0 );\n}","name":"","description":"","type":"image"}]}