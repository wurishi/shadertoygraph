{"ver":"0.1","info":{"id":"7td3Wn","date":"1636090977","viewed":173,"name":"PreIntegrate Skin Copy Art Dir","username":"yuletian","description":"Easy for artist to modify. Modify the BRDF LUT to be sRGB","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["skin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//#define DIFFUSION_PROFILE 0  //DiffusionProfile by nVidia GPU Gems3\n#define DIFFUSION_PROFILE 1  //DiffusionProfile by UE4 SeparableSSS\n//#define DIFFUSION_PROFILE 2  //DiffusionProfile by Burley(now have bugs)...\n\n#define KEEP_DIRECT_BOUNCE 0\n\n////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.1415926\n\n////////////////////////////////////////////////////////////////////////////\n\n#if DIFFUSION_PROFILE == 0  ///////////////////////////////////////// nVidia GPU Gems3 //////////////////////\n\nfloat Gaussian(float v, float r)\n{\n    return 1.0 / sqrt(2.0 * PI * v) * exp(-(r*r)/(2.0*v));\n}\n\nvec3 DiffusionProfile(float r)\n{\n    return vec3(0.0, 0.0, 0.0)\n#if KEEP_DIRECT_BOUNCE\n        + Gaussian(0.0064, r) * vec3(0.233, 0.455, 0.649)\n#endif\n        + Gaussian(0.0484, r) * vec3(0.100, 0.336, 0.344)\n        + Gaussian(0.187, r) * vec3(0.118, 0.198, 0.0)\n        + Gaussian(0.567, r) * vec3(0.113, 0.007, 0.007)\n        + Gaussian(1.99, r) * vec3(0.358, 0.004, 0.0)\n        + Gaussian(7.41, r) * vec3(0.233, 0.0, 0.0);\n}\n\n#elif DIFFUSION_PROFILE == 1  ///////////////////////////////////////// UE4 SeparableSSS //////////////////////\n\nconst vec3 FalloffColor = vec3(1.0, 0.3, 0.2);\n\nvec3 SeparableSSS_Gaussian(float variance, float r, vec3 FalloffColor)\n{\n\t/**\n\t* We use a falloff to modulate the shape of the profile. Big falloffs\n\t* spreads the shape making it wider, while small falloffs make it\n\t* narrower.\n\t*/\n    vec3 rr = r / (0.001 + FalloffColor);\n    \n\tvec3 Ret = exp((-(rr * rr)) / (2.0 * variance)) / (2.0 * PI * variance);\n    \n\treturn Ret;\n}\n\nvec3 DiffusionProfile(float r)\n{\n\t/**\n\t* We used the red channel of the original skin profile defined in\n\t* [d'Eon07] for all three channels. We noticed it can be used for green\n\t* and blue channels (scaled using the falloff parameter) without\n\t* introducing noticeable differences and allowing for total control over\n\t* the profile. For example, it allows to create blue SSS gradients, which\n\t* could be useful in case of rendering blue creatures.\n\t*/\n\t// first parameter is variance in mm^2\n    \n    return vec3(0.0, 0.0, 0.0)\n#if KEEP_DIRECT_BOUNCE\n        + 0.233f * SeparableSSS_Gaussian(0.0064f, r, FalloffColor)  /* We consider this one to be directly bounced light, accounted by the strength parameter (see @STRENGTH) */\n#endif\n\t\t+ 0.100 * SeparableSSS_Gaussian(0.0484, r, FalloffColor)\n\t\t+ 0.118 * SeparableSSS_Gaussian(0.187, r, FalloffColor)\n\t\t+ 0.113 * SeparableSSS_Gaussian(0.567, r, FalloffColor)\n\t\t+ 0.358 * SeparableSSS_Gaussian(1.99, r, FalloffColor)\n\t\t+ 0.078 * SeparableSSS_Gaussian(7.41, r, FalloffColor);\n}\n\n#elif DIFFUSION_PROFILE == 2  ///////////////////////////////////////// Burley //////////////////////\n\nconst vec3 Albedo = vec3(0.02, 0.02, 0.02);\nconst vec3 BurleyD = vec3(1.0, 0.5, 0.25);\nconst vec3 DiffuseMeanFreePath = vec3(0.0001, 0.0001, 0.0001);\nconst float ScatterRadius = 1.0;\n\n// Reparameterization 3: The spectral of diffuse mean free path on the surface.\n// Avergate relative error: 7.7% (reference to MC)\nfloat GetSearchLightDiffuseScalingFactor(float SurfaceAlbedo)\n{\n\treturn 3.5 + 100.0 * pow(SurfaceAlbedo - 0.33, 4.0);\n}\n\nfloat BurleyRd(float r, float d, float A)\n{\n    return max(0.0, A * (exp(-r / d) + exp(-r / (3.0 * d))) / (8.0 * PI * d * r));\n}\n\nfloat BurleyRdBySearchLightDiffuseMeanFreepath(float r, float A)\n{\n    float s = GetSearchLightDiffuseScalingFactor(A);\n    return max(0.0, A * s * (exp(-r * s) + exp(-r * s / 3.0)) / (8.0 * PI * r));\n}\n\nfloat BurleyRdBySearchLightDiffuseMeanFreepath2(float r, float A, float L)\n{\n    float s = GetSearchLightDiffuseScalingFactor(A);\n    float D = 1.0 / s;\n    float R = r / L;\n    float Inv8Pi = 1.0 / (8.0 * PI);\n\tfloat NegRbyD = -R / D;\n\treturn A * max((exp(NegRbyD) + exp(NegRbyD / 3.0)) / (D*L)*Inv8Pi, 0.0);\n}\n\nvec3 DiffusionProfile(float r)\n{\n    r = clamp(r / ScatterRadius, 0.0, 1.0);\n\n//    return vec3(BurleyRd(r, BurleyD.r, Albedo.r),\n//                BurleyRd(r, BurleyD.g, Albedo.g),\n//                BurleyRd(r, BurleyD.b, Albedo.b));\n                \n//    return vec3(BurleyRdBySearchLightDiffuseMeanFreepath(r, Albedo.r),\n//                BurleyRdBySearchLightDiffuseMeanFreepath(r, Albedo.g),\n//                BurleyRdBySearchLightDiffuseMeanFreepath(r, Albedo.b));\n                \n    return vec3(BurleyRdBySearchLightDiffuseMeanFreepath2(r, Albedo.r, DiffuseMeanFreePath.r),\n                BurleyRdBySearchLightDiffuseMeanFreepath2(r, Albedo.g, DiffuseMeanFreePath.g),\n                BurleyRdBySearchLightDiffuseMeanFreepath2(r, Albedo.b, DiffuseMeanFreePath.b));\n}\n\n#endif\n\nvec3 PlotDiffusionProfile(vec2 uv)\n{\n    vec3 value = DiffusionProfile(uv.x * 3.5) * 0.2;\n    \n    return (1.0 - smoothstep(0.0, 0.02, abs(value.x - uv.y))) * vec3(1, 0, 0)\n        + (1.0 - smoothstep(0.0, 0.02, abs(value.y - uv.y))) * vec3(0, 1, 0)\n        + (1.0 - smoothstep(0.0, 0.02, abs(value.z - uv.y))) * vec3(0, 0, 1);        \n}\n\n////////////////////////////////////////////////////////////////////////////\n\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\n#define W 11.2\n\nvec3 Tonemap(vec3 x)\n{\n    return ((x * ( A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E/F;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\n// integrate SSS on 2D half ring\nvec3 GenSkinLUT(vec2 uv)\n{\n    float nol = uv.x;\n    float inv_r = uv.y;\n    float theta = acos(nol * 2.0 - 1.0);\n    float r = 1.0 / inv_r;\n    \n    vec3 scatteringFactor = vec3(0.0, 0.0, 0.0);\n    vec3 normalizationFactor = vec3(0.0, 0.0, 0.0);\n    for (float x = -PI/2.0; x < PI/2.0; x+=PI * 0.001)\n    {\n        float dist = 2.0 * r * sin(x * 0.5);\n        \n        scatteringFactor += max(0.0, cos(x + theta)) * DiffusionProfile(dist);\n        \n        normalizationFactor += DiffusionProfile(dist);\n    }\n    \n    vec3 result = scatteringFactor / normalizationFactor;\n    \n    vec3 tonedResult = Tonemap(result * 12.0);\n    vec3 whiteScale = 1.0 / Tonemap(vec3(W, W, W));\n    \n    tonedResult = tonedResult * whiteScale;\n    \n    //tonedResult.x = pow(tonedResult.x, 1.0 / 2.2);\n    //tonedResult.y = pow(tonedResult.y, 1.0 / 2.2);\n    //tonedResult.z = pow(tonedResult.z, 1.0 / 2.2);\n    \n    return pow(result, vec3(1.0f/2.2f));//tonedResult;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //fragColor = vec4(PlotDiffusionProfile(uv), 1.0);\n        \n    fragColor = vec4(GenSkinLUT(uv), 1.0);\n}","name":"Image","description":"","type":"image"}]}