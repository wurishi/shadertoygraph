{"ver":"0.1","info":{"id":"4fVGWm","date":"1712863185","viewed":95,"name":"Curl Noise with Simplex3D_Deriv","username":"Beherith","description":"Wombat's Value noise sampled along a mixed Simplex Perlin 3D curl field. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","perlin"],"hasliked":0,"parentid":"lsf3WH","parentname":"Noise - value - 2D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wombat's noise\nvec4 SimplexPerlin3D_Deriv(vec3 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D_Deriv.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHEDRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHEDRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tnormalize random gradient vectors\n    vec4 norm = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 );\n    hash_0 *= norm;\n    hash_1 *= norm;\n    hash_2 *= norm;\n\n    //\tevaluate gradients\n    vec4 grad_results = hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 m = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    m = max(0.5 - m, 0.0);\n    vec4 m2 = m*m;\n    vec4 m3 = m*m2;\n\n    //  calc the derivatives\n    vec4 temp = -6.0 * m2 * grad_results;\n    float xderiv = dot( temp, v1234_x ) + dot( m3, hash_0 );\n    float yderiv = dot( temp, v1234_y ) + dot( m3, hash_1 );\n    float zderiv = dot( temp, v1234_z ) + dot( m3, hash_2 );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  sum and return all results as a vec3\n    return vec4( dot( m3, grad_results ), xderiv, yderiv, zderiv ) * FINAL_NORMALIZATION;\n}\n\n//  Value Noise 3D\n//  Return value range of 0.0->1.0\nfloat Value3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n\t// quintic:\n    //vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0); \n\t// cube:\n    vec3 blend = Pf * Pf * (3.0 - 2.0 * Pf );\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ); \n}\n\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.025;\n    vec2 baseUVs = p;\n\t\n\tfloat f = 0.0;\n\n\n    // right: fbm - fractal noise (4 octaves)\n \n        \n        vec4 spd;\n        vec2 cuv;\n        \n        for (int s = 0; s <4; s++){\n            spd = SimplexPerlin3D_Deriv(vec3(uv + iTime* 0.1, iTime*0.1) * 4.0);\n            //spd.yzw = normalize(spd.yzw);\n            cuv = vec2(-spd.z, spd.y);\n            \n            // This is actually very interesting, normalizing these gives sharper curls\n            vec2 normcuv = normalize(cuv);\n            cuv = mix(cuv, normcuv, baseUVs.x);\n            //cuv = normalize(cuv);\n            uv += cuv * 0.015;\n        }\n     \n        //uv += vec2(-spd.y, spd.x);\n    \n        uv -= iTime* 0.1;\n\t\tuv *= 8.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n        float fTime = iTime * 1.5;\n\t\tf  = 0.5000*Value3D( vec3(uv, fTime * 0.3 )); uv = m*uv;\n\t\tf += 0.5000*Value3D( vec3(uv, fTime * 0.7 )); uv = m*uv;\n\t\t//f += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.25*Value3D( vec3(uv, fTime * 0.9 )); uv = m*uv;\n\t\tf += 0.125*Value3D( vec3(uv, fTime * 1.2 )); uv = m*uv;\n\t\n\n\tf = 0.0 + 0.8*f;\n\t\n    //f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n    //fragColor.rg = fract(uv * 0.01);\n}","name":"Image","description":"","type":"image"}]}