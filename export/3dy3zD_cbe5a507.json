{"ver":"0.1","info":{"id":"3dy3zD","date":"1569789761","viewed":479,"name":"PBR playground (silver sphere)","username":"lhog","description":"PBR with diffuse and specular smart environment sampling","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HDR_FOR_POORS\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n#define GAMMA 2.2\n// gamma correction & tonemapping\n#ifdef GAMMA\n    #define INV_GAMMA 1.0 / GAMMA\n    #define SRGBtoLINEAR(c) ( pow(c, vec3(GAMMA)) )\n    #define LINEARtoSRGB(c) ( pow(c, vec3(INV_GAMMA)) )\n#else\n    #define SRGBtoLINEAR(c) ( c )\n    #define LINEARtoSRGB(c) ( c )\n#endif\n\n\nconst vec3 LUMA = vec3(0.2126, 0.7152, 0.0722);\nconst float EPS = 1e-4;\n\nconst mat3 RGB2YCBCR = mat3(\n    0.2126, -0.114572, 0.5,\n    0.7152, -0.385428, -0.454153,\n    0.0722, 0.5, -0.0458471);\n\nconst mat3 YCBCR2RGB = mat3(\n    1.0, 1.0, 1.0,\n    0.0, -0.187324, 1.8556,\n    1.5748, -0.468124, -5.55112e-17);\n\nvec3 obj_pos = vec3(0.0,0.0,-10.0);\nfloat obj_size = 5.0;\n\nfloat sphere(vec3 dir, vec3 center, float radius) {\n    vec3 rp = -center;\n\tfloat b = dot(rp,dir);\n\tfloat dist = b * b - (dot(rp,rp) - radius * radius);\n\tif(dist <= 0.0) return -1.0;\n\treturn -b - sqrt(dist);\n}\n\nvec3 getFishEye(vec2 uv, float level) {\n    float len = length(uv);\n    float a = len * level;\n    return vec3(uv / len * sin(a), -cos(a));\n}\n\nconst float goldenAngle = PI * (3.0 - sqrt(5.0));\nvec3 SpherePoints_GoldenAngle(float i, float numSamples) {\n    float theta = i * goldenAngle;\n    float z = (1.0 - 1.0 / numSamples) * (1.0 - 2.0 * i / (numSamples - 1.0));\n    float radius = sqrt(1.0 - z * z);\n    return vec3(radius * vec2(cos(theta), sin(theta)), z);\n}\n\n\n#define reflectTex iChannel0\nvec3 sampleReflectionMap(vec3 sp, float lodBias){    \n    vec3 color = SRGBtoLINEAR(textureLod(reflectTex, sp, lodBias).rgb);\n    #if defined (HDR_FOR_POORS)\n    \tcolor *= 1.0 + 2.0*smoothstep(0.7, 1.0, dot(LUMA, color)); //HDR for poors\n   \t#endif\n    return color;\n}\n\n#define ENV_SMPL_NUM 128\nvoid TextureEnvBlured(in vec3 N, in vec3 Rv, out vec3 iblDiffuse, out vec3 iblSpecular) {\n    iblDiffuse = vec3(0.0);\n    iblSpecular = vec3(0.0);\n\n    vec2 sum = vec2(0.0);\n\n    vec2 ts = vec2(textureSize(reflectTex, 0));\n    float maxMipMap = log2(max(ts.x, ts.y));\n\n    vec2 lodBias = vec2(maxMipMap - 7.0, 4.0);\n\n    for (int i=0; i < ENV_SMPL_NUM; ++i) {\n        vec3 sp = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));\n\n        vec2 w = vec2(\n            dot(sp, N ) * 0.5 + 0.5,\n            dot(sp, Rv) * 0.5 + 0.5);\n\n\n        w = pow(w, vec2(4.0, 32.0));\n\n        vec3 iblD = sampleReflectionMap(sp, lodBias.x);\n        vec3 iblS = sampleReflectionMap(sp, lodBias.y);\n\n        iblDiffuse  += iblD * w.x;\n        iblSpecular += iblS * w.y;\n\n        sum += w;\n    }\n\n    iblDiffuse  /= sum.x;\n    iblSpecular /= sum.y;\n}\n#undef ENV_SMPL_NUM\n/////////////////////////////////////////////////////////////////////////////////////\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SphericalHarmonic( in int l, in int m, in vec3 n ) \n{ \n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    \n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    \n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return   k03*n.x*n.y;\n    if( l==2 && m==-1 ) return  -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return   k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return  -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return   k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\nmat3 shEvaluate(vec3 n) {\n    mat3 r;\n    r[0][0] =  SphericalHarmonic(0,  0, n);\n    r[0][1] = -SphericalHarmonic(1, -1, n);\n    r[0][2] =  SphericalHarmonic(1,  0, n);\n    r[1][0] = -SphericalHarmonic(1,  1, n);\n\n    r[1][1] =  SphericalHarmonic(2, -2, n);\n    r[1][2] = -SphericalHarmonic(2, -1, n);\n    r[2][0] =  SphericalHarmonic(2,  0, n);\n    r[2][1] = -SphericalHarmonic(2,  1, n);\n    r[2][2] =  SphericalHarmonic(2,  2, n);\n    return r;\n}\n\n// Adds two SH functions together.\nmat3 shAdd(mat3 shL, mat3 shR) {\n\treturn shL + shR;\n}\n\n// Scales a SH function uniformly by v.\nmat3 shScale(mat3 sh, float v) {\n\treturn sh * v;\n}\n\n// Recovers the value of a SH function in the direction dir.\nfloat shUnproject(mat3 functionSh, vec3 dir)\n{\n\tmat3 sh = shEvaluate(dir);\n\treturn\n        dot(functionSh[0], sh[0]) +\n        dot(functionSh[1], sh[1]) +\n        dot(functionSh[2], sh[2]);\n}\n\nconst vec3 convCoeff = vec3(1.0, 2.0/3.0, 1.0/4.0);\nmat3 shDiffuseConvolution(mat3 sh) {\n\tmat3 r = sh;\n    \n    r[0][0] *= convCoeff.x;\n\n    r[0][1] *= convCoeff.y;\n    r[0][2] *= convCoeff.y;\n    r[1][0] *= convCoeff.y;\n    \n    r[1][1] *= convCoeff.z;\n    r[1][2] *= convCoeff.z;\n    r[2][0] *= convCoeff.z;\n    r[2][1] *= convCoeff.z;\n    r[2][2] *= convCoeff.z;    \n    \n\treturn r;\n}\n\nmat3 shDiffuseConvolutionPI(mat3 sh) {\n\treturn PI * shDiffuseConvolution(sh);\n}\n\n#define ENV_SMPL_NUM 64\nvoid CubeMapToSH2(out mat3 shR, out mat3 shG, out mat3 shB) {\n    // Initialise sh to 0\n    shR = mat3(0.0);\n    shG = mat3(0.0);\n    shB = mat3(0.0);\n    \n    vec2 ts = vec2(textureSize(reflectTex, 0));\n    float maxMipMap = log2(max(ts.x, ts.y));\n    float lodBias = maxMipMap-7.0;\n    \n\n    for (int i=0; i < ENV_SMPL_NUM; ++i) {\n        vec3 sp = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));\n        vec3 color = sampleReflectionMap(sp, lodBias);\n\n        mat3 sh = shEvaluate(sp);\n        shR = shAdd(shR, shScale(sh, color.r));\n        shG = shAdd(shG, shScale(sh, color.g));\n        shB = shAdd(shB, shScale(sh, color.b));            \n    }\n\n    // integrating over a sphere so each sample has a weight of 4*PI/samplecount (uniform solid angle, for each sample)\n    float shFactor = 4.0 * PI / float(ENV_SMPL_NUM);\n    shR = shScale(shR, shFactor );\n    shG = shScale(shG, shFactor );\n    shB = shScale(shB, shFactor );\n}\n#undef ENV_SMPL_NUM\n\nvec3 SH2toColor(mat3 shR, mat3 shG, mat3 shB, vec3 rayDir) {\n    vec3 rgbColor = vec3(\n        shUnproject(shR, rayDir),\n        shUnproject(shG, rayDir),\n        shUnproject(shB, rayDir));\n    \n    // A \"max\" is usually recomended to avoid negative values (can happen with SH)\n    rgbColor = max(vec3(0.0), vec3(rgbColor));\n    return rgbColor;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n\n\nvoid TextureEnvBlured2(in vec3 N, in vec3 Rv, out vec3 iblDiffuse, out vec3 iblSpecular) {\n    iblDiffuse = vec3(0.0);\n    iblSpecular = vec3(0.0);\n\t\n    mat3 shR, shG, shB;\n    \n    CubeMapToSH2(shR, shG, shB);\n    \n    #if 1\n    \tshR = shDiffuseConvolution(shR);\n    \tshG = shDiffuseConvolution(shG);\n    \tshB = shDiffuseConvolution(shB);\n    #endif\n    \n    #if 0\n    \tshR = shDiffuseConvolutionPI(shR);\n    \tshG = shDiffuseConvolutionPI(shG);\n    \tshB = shDiffuseConvolutionPI(shB);\n    #endif    \n    \n    iblDiffuse = SH2toColor(shR, shG, shB, N);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\nvoid TextureEnvBlured3(in vec3 N, in vec3 Rv, out vec3 iblDiffuse, out vec3 iblSpecular) {\n    vec3 irradiance = vec3(0.0);   \n    \n    vec2 ts = vec2(textureSize(reflectTex, 0));\n    float maxMipMap = log2(max(ts.x, ts.y));\n    float lodBias = maxMipMap-7.0;    \n    \n    // tangent space calculation from origin point\n    vec3 up    = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up            = cross(N, right);\n       \n    float sampleDelta = PI / 75.0;\n    float nrSamples = 0.0f;\n    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n    {\n        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n        {\n            // spherical to cartesian (in tangent space)\n            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n            // tangent space to world\n            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \n\n            irradiance += sampleReflectionMap(sampleVec, lodBias) * cos(theta) * sin(theta);\n            nrSamples++;\n        }\n    }\n    iblDiffuse = PI * irradiance * (1.0 / float(nrSamples));    \n}\n\n\nvec3 SampleEnvironmentWithRoughness(vec3 samplingVec, float roughness) {\n    float maxLodLevel = log2(float(textureSize(iChannel0, 0).x));\n\n    // makes roughness of reflection scale perceptually much more linear\n    // Assumes \"CubeTexSizeReflection\" = 1024\n    maxLodLevel -= 4.0;\n\n    float lodBias = maxLodLevel * roughness;\n\n    return sampleReflectionMap(samplingVec, lodBias);\n}\n\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\nvec2 EnvBRDFApprox(float ndotv, float roughness) {\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn clamp(AB, vec2(0.0), vec2(1.0));\n}\n\n\n// Fresnel - Schlick\n// F term\nvec3 FresnelSchlick(vec3 R0, vec3 R90, float VdotH) {\n    return R0 + (R90 - R0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n// Fresnel - Schlick with Roughness - LearnOpenGL\nvec3 FresnelSchlickWithRoughness(vec3 R0, vec3 R90, float VdotH, float roughness) {\n    return R0 + (max(R90 - vec3(roughness), R0) - R0) * pow(1.0 - VdotH, 5.0);\n}\n\n// Fresnel - Blender - Seems like it's not applicable for us\nvec3 FresnelBlenderWithRoughness(vec3 R0, vec3 R90, vec2 envBRDF) {\n    return clamp(envBRDF.y * R90 + envBRDF.x * R0, vec3(0.0), vec3(1.0));\n}\n#define FresnelWithRoughness(R0, R90, VdotH, roughness, envBRDF) \\\nFresnelSchlickWithRoughness(R0, R90, VdotH, roughness)\n    //FresnelBlenderWithRoughness(R0, R90, envBRDF)\n\n// Smith Joint GGX\n// Note: Vis = G / (4 * NdotL * NdotV)\n#define VisibilityOcclusion(NdotL, NdotV, roughness2, roughness4) \\\nVisibilityOcclusionFast(NdotL, NdotV, roughness2)\n//VisibilityOcclusionSlow(NdotL, NdotV, roughness4)\n\nfloat VisibilityOcclusionFast(float NdotL, float NdotV, float roughness2) {\n    float GGXV = NdotL * (NdotV * (1.0 - roughness2) + roughness2);\n    float GGXL = NdotV * (NdotL * (1.0 - roughness2) + roughness2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nfloat VisibilityOcclusionSlow(float NdotL, float NdotV, float roughness4) {\n    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - roughness4) + roughness4);\n    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - roughness4) + roughness4);\n\n    float GGX = GGXV + GGXL;\n\n    return mix(0.0, 0.5 / GGX, float(GGX > 0.0));\n}\n\nfloat MicrofacetDistribution(float NdotH, float roughness4) {\n    float f = (NdotH * roughness4 - NdotH) * NdotH + 1.0;\n    return roughness4 / (PI * f * f);\n}\n\n\n// ----------------------------------------------------------------------------\n\n\n\n// ----------------------------------------------------------------------------\n//https://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/ (comments by STEVEM)\nvec3 SteveMTM1(in vec3 x) {\n    const float a = 10.0; /// Mid\n    const float b = 0.3; /// Toe\n    const float c = 0.5; /// Shoulder\n    const float d = 1.5; /// Mid\n\n    return LINEARtoSRGB((x * (a * x + b)) / (x * (a * x + c) + d));\n}\n\nvec3 SteveMTM2(in vec3 x) {\n    const float a = 1.8; /// Mid\n    const float b = 1.4; /// Toe\n    const float c = 0.5; /// Shoulder\n    const float d = 1.5; /// Mid\n\n    return LINEARtoSRGB((x * (a * x + b)) / (x * (a * x + c) + d));\n}\n\nvec3 FilmicTM(in vec3 x) {\n    vec3 outColor = max(vec3(0.0), x - vec3(0.004));\n    return (outColor * (6.2 * outColor + 0.5)) / (outColor * (6.2 * outColor + 1.7) + 0.06);\n}\n\nvec3 Reinhard(const vec3 x) {\n    // Reinhard et al. 2002, \"Photographic Tone Reproduction for Digital Images\", Eq. 3\n    return LINEARtoSRGB(x / (1.0 + dot(LUMA, x)));\n}\n\nvec3 ACESFilmicTM(in vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return LINEARtoSRGB((x * (a * x + b)) / (x * (c * x + d) + e));\n}\n\nvec3 Unreal(const vec3 x) {\n    // Unreal, Documentation: \"Color Grading\"\n    // Adapted to be close to Tonemap_ACES, with similar range\n    // Gamma 2.2 correction is baked in, don't use with sRGB conversion!\n    return x / (x + 0.155) * 1.019;\n}\n\nvec3 ACESRec2020(const vec3 x) {\n    // Narkowicz 2016, \"HDR Display вЂ“ First Steps\"\n    const float a = 15.8;\n    const float b = 2.12;\n    const float c = 1.2;\n    const float d = 5.92;\n    const float e = 1.9;\n    return LINEARtoSRGB((x * (a * x + b)) / (x * (c * x + d) + e));\n}\n// ----------------------------------------------------------------------------\n\n#define NORM2SNORM(value) (value * 2.0 - 1.0)\n#define SNORM2NORM(value) (value * 0.5 + 0.5)\n\n\n// Metals values in linear space\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n#define ALL1 vec3(1.0)\n\nconst vec3 albedoColor = SILVER;\nconst vec3 lightColor = vec3(1.0);\n\nconst vec3 lightPos = normalize(vec3(-1.0,0.3,0.0));\nconst vec3 DEFAULT_F0 = vec3(0.04);\n\n\n#define USE_ENVIRONMENT_SPECULAR\n#define USE_ENVIRONMENT_DIFFUSE\n\nvec3 getColor(vec3 ray) {\n    float dist = sphere(ray,obj_pos,obj_size);    \n    if(dist > 0.0) {\n        \n    \tvec3 point = ray * dist;\n    \tvec3 normal = point - obj_pos;\n        normal = normalize(normal);\n        \n        // material\n        float metalness = step(fract(normal.y * 0.5), 0.5);\n        float s = sign(sin(iTime * 0.125));\n        metalness = s > 0.0 ? metalness: 1.0 - metalness;\n\n        //metalness = 0.0;\n        metalness = clamp(metalness, 0.0, 1.0);\n        float roughness = step(fract(normal.x * 0.5), 0.5);\n\n        //roughness = fract(SNORM2NORM(sin(iTime * 0.5)));\n        roughness = clamp(roughness, 0.04, 1.0);\n        \n        float roughness2 = roughness * roughness;\n        float roughness4 = roughness2 * roughness2;\n        \n        vec3 H = normalize(-ray + lightPos);\n        #define L lightPos\n        #define N normal\n        #define V (-ray)\n        vec3 Rv = reflect(ray, normal);\n        \n        float NdotL = clamp(dot(L, N), 0.0, 1.0);\n\t\tfloat NdotH = clamp(dot(H, N), 0.0, 1.0);\n\t\tfloat NdotV = clamp(dot(N, V), 0.0, 1.0);\n\t\tfloat VdotH = clamp(dot(V, H), 0.0, 1.0);        \n        \n        ///\n        // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 \n        // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    \n        vec3 F0 = vec3(DEFAULT_F0); \n        F0 = mix(F0, albedoColor, metalness);\n        \n\t\tfloat reflectance = dot(LUMA, F0);\n\n\t\t// Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n\t\tvec3 F90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));\n        \n        vec2 envBRDF = EnvBRDFApprox(NdotV, roughness);\n\n        // https://google.github.io/filament/Filament.html#toc4.7.2\n        // Note in Filament envBRDF x and y are swapped\n        vec3 energyCompensation = 1.0 + F0 * (1.0 / max(envBRDF.x, EPS) - 1.0);\n        //energyCompensation = vec3(1.0);\n        \n        vec3 dirContrib = vec3(0.0);\n\t\tvec3 outSpecularColor = vec3(0.0);\n\n\t\tif (any( greaterThan(vec2(NdotL, NdotV), vec2(EPS)) )) {\n\t\t\t// Cook-Torrance BRDF\n\n\t\t\tvec3 F = FresnelSchlick(F0, F90, VdotH);\n\t\t\tfloat Vis = VisibilityOcclusion(NdotL, NdotV, roughness2, roughness4);\n\t\t\tfloat D = MicrofacetDistribution(NdotH, roughness4);\n\t\t\toutSpecularColor = F * Vis * D;\n\n\t\t\tvec3 maxSun = lightColor;\n\t\t\t#ifdef SUNMULT\n\t\t\t\tmaxSun *= SUNMULT;\n\t\t\t#endif\n\n\t\t\toutSpecularColor *= maxSun;\n\t\t\toutSpecularColor *= NdotL;\n\n            // Scale the specular lobe to account for multiscattering\n            // https://google.github.io/filament/Filament.md.html#toc4.7.2\n\t\t\toutSpecularColor *= energyCompensation;\n\n\t\t\t // kS is equal to Fresnel\n\t\t\tvec3 kS = F;\n\n\t\t\t// for energy conservation, the diffuse and specular light can't\n\t\t\t// be above 1.0 (unless the surface emits light); to preserve this\n\t\t\t// relationship the diffuse component (kD) should equal 1.0 - kS.\n\t\t\tvec3 kD = vec3(1.0) - kS;\n\n\t\t\t// multiply kD by the inverse metalness such that only non-metals\n\t\t\t// have diffuse lighting, or a linear blend if partly metal (pure metals\n\t\t\t// have no diffuse light).\n\t\t\tkD *= 1.0 - metalness;\n\n\t\t\t// add to outgoing radiance dirContrib\n\t\t\tdirContrib  = maxSun * (kD * albedoColor /* PI */) * NdotL;\n\t\t\tdirContrib += outSpecularColor;\n        }\n\n\n        vec3 outColor;\n\t\tvec3 ambientContrib;\n\t\tvec3 iblDiffuse, iblSpecular;\n        \n        vec3 iblD1;\n        vec3 iblD2;\n        vec3 iblD3;\n        \n\t\t// getSpecularDominantDirection (Filament)\n\t\t//Rv = mix(Rv, N, roughness4);     \n        \n        {\n            // ambient lighting (we now use IBL as the ambient term)\n\t\t\tvec3 F = FresnelWithRoughness(F0, F90, VdotH, roughness, envBRDF);\n\n            vec3 kS = F;\n            vec3 kD = 1.0 - kS;\n            kD *= 1.0 - metalness;\n\n            ///\n\t\t\tvec3 dummy;\n            \n\n\n\t\t\t#if (defined USE_ENVIRONMENT_DIFFUSE) || (defined USE_ENVIRONMENT_SPECULAR)\n\t\t\t\tTextureEnvBlured(N, Rv, iblD1, iblSpecular);\n            \tTextureEnvBlured2(N, Rv, iblD2, dummy);\n            \tTextureEnvBlured3(N, Rv, iblD3, dummy);\n\t\t\t#endif\n            ///\n            \n            iblDiffuse = iblD1;\n\n\n            vec3 diffuse = iblDiffuse * albedoColor;\n\n           \n            // sample both the pre-filter map and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.\n            vec3 reflectionColor = SampleEnvironmentWithRoughness(Rv, roughness);\n\n\t\t\t#if (defined USE_ENVIRONMENT_SPECULAR)\n\t\t\t\treflectionColor = mix(reflectionColor, iblSpecular, roughness);\n\t\t\t#endif\n\n            //vec3 specular = reflectionColor * (F * envBRDF.x + (1.0 - F) * envBRDF.y);\n\n\t\t\t// specular ambient occlusion (see Filament)\n\t\t\tvec3 specular = reflectionColor * mix(vec3(envBRDF.y), vec3(envBRDF.x), F);\n\t\t\tspecular *= energyCompensation;\n\n\n\t\t\toutSpecularColor += specular;\n\n            ambientContrib = (kD * diffuse + specular);\n\n            outColor = ambientContrib + dirContrib;\n        }\n\n        //return LINEARtoSRGB(ambientContrib);\n        //return vec3(any(greaterThan(abs(iblD1 - iblD3), vec3(0.05))));\n        return ACESFilmicTM(outColor);\n    } else {      \n        \n        return texture(iChannel0,ray).xyz;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = getFishEye(uv,1.2);\n    \n    // rotation\n    float c = cos(iTime);\n    float s = sin(iTime);\n    dir.xz = vec2(dir.x * c - dir.z * s, dir.x * s + dir.z * c);\n    obj_pos.xz = vec2(obj_pos.x * c - obj_pos.z * s, obj_pos.x * s + obj_pos.z * c);\n    \n    // color\n    float fish_eye = smoothstep(2.0,1.6,length(uv)) * 0.25 + 0.75;\n\tfragColor = vec4(getColor(dir) * fish_eye, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}