{"ver":"0.1","info":{"id":"4d3SzX","date":"1476353782","viewed":851,"name":"Watery noise refraction","username":"Maddius","description":"Using a generated noise function as refraction for a background image. The noise function came from another Shadertoy which I can no longer find, this however can be replaced by a tileable noise texture instead.\n\nhttp://www.twitter.com/SidiGames","likes":22,"published":1,"flags":0,"usePreview":1,"tags":["noise","refraction","distortion","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Disclaimer\n// ==========\n// Noise generation was pulled from elsewhere (I can't find the original anymore!).\n// However you can replace the noise generation code with a tileable noise texture instead.\n\n#define NORM_FOCUS (1)\n\nfloat random(float x) \n{ \n    return fract(sin(x) * 10000.);          \n}\n\nfloat noise(vec2 p) \n{\n    return random(p.x + p.y * 10000.);            \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) \n{\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);        \n}\n\nfloat fractalNoise(vec2 p) \n{\n    float x = 0.;\n    x += smoothNoise(p      );\n    x += smoothNoise(p * 2. ) / 2.;\n    x += smoothNoise(p * 4. ) / 4.;\n    x += smoothNoise(p * 8. ) / 8.;\n    x += smoothNoise(p * 16.) / 16.;\n    x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return x;            \n}\n\nfloat movingNoise(vec2 p) \n{ \n    float x = fractalNoise(p + iTime);\n    float y = fractalNoise(p - iTime);\n    return fractalNoise(p + vec2(x, y));    \n}\n\nfloat nestedNoise(vec2 p) \n{    \n    float x = movingNoise(p);\n    float y = movingNoise(p + 100.);\n    return movingNoise(p + vec2(x, y));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float n = nestedNoise(uv * 6.) * 1.0;\n    float lerp = (sin(iTime * 0.5) + 1.0) / 2.0;\n    float offset = mix(0.0, 2.0, lerp);\n    \n    #if NORM_FOCUS\n    \tvec2 offsetVector = normalize(vec2(0.5, 0.5) - uv) * (n * offset);\n    #else\n    \tvec2 offsetVector = (vec2(0.5, 0.5) - uv) * (n * offset);\n    #endif\n    \n    fragColor = texture(iChannel0, uv + offsetVector);\n}","name":"Image","description":"","type":"image"}]}