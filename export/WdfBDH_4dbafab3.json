{"ver":"0.1","info":{"id":"WdfBDH","date":"1589052981","viewed":150,"name":"Mjolnir","username":"ez21","description":"If he be worthy...","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","lightning","hammer","thor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.4;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 2.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float SCALE = 20.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 2.5;\n\n// ambient occlusion\nconst float KSTEP = 2.;\nconst float OCCDist = 0.085;\n\n// speed at which the ground flashes: higher = faster\nconst float SPEED = 4.;\n\n\n#define FLOOR_SDF plane(pos, vec3(0., 1.0, 0.), vec3(0., -2.5, 0.))\n#define HANDLE_SDF sdCappedCylinder(pos, vec3(-2.1, 5.95, 12.1), vec3(-0.25, -0.3, 8.5), 0.38)\n#define CAP_SDF sdCappedCylinder(pos, vec3(-2.25, 6.55, 12.25), vec3(-2.07, 5.85, 12.1), 0.5)\n#define SUN_SDF sphere(pos, 20.5, vec3(10., 0., 100.))\n\n#define HAMMER_SDF roundedBox(pos, vec3(3., 2., 3.), vec3(15., 0., 15.5), vec3(0., -1.3, 10.), 0.21)\n#define ATTACHLEFT_SDF roundedBox(pos, vec3(0.5, 1.4, 2.5), vec3(15., 0., 15.5), vec3(2.03, -0.77, 10.), 0.18)\n#define ONEATTACH_SDF smoothBlendSDF(pos, HAMMER_SDF, ATTACHLEFT_SDF, 0.35)\n#define ATTACHRIGHT_SDF roundedBox(pos, vec3(0.6, 1.4, 2.5), vec3(15., 0., 15.5), vec3(-2.05, -1.87, 10.), 0.18)\n#define MJOLNIR_SDF smoothBlendSDF(pos, ONEATTACH_SDF, ATTACHRIGHT_SDF, 0.3)\n\n#define RIBBON_SDF sdCappedTorus(pos + vec3(2.8 + cos(iTime * 3.) * 0.05, -6.35, -12.1 + cos(iTime * 3.) * 0.08), vec2(0.8,0.12), 1., 0.1)\n#define RIBBON2_SDF sdCappedTorus(pos + vec3(3. + cos(iTime * 3.) * 0.05, -6.85, -12.0 + cos(iTime * 3.) * 0.08), vec2(-0.8,0.12), 0.8, 0.1)\n#define STRING_SDF smoothBlendSDF(pos, RIBBON_SDF, RIBBON2_SDF, 0.2)\n\n#define FLOOR_ID 3\n#define HANDLE_ID 5\n#define SUN_ID 6\n#define MJOLNIR_ID 8\n#define STRING_ID 9\n#define CAP_ID 10\n\n\n\nconst float FOVY = (3.141569 * 2.) * 19.5 / 360.;\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n    vec3 n;\n};\n    \n/********************************/\n/***** NOISE FUNCTIONS BEGIN*****/\n/********************************/\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 191.999)),\n                          dot(p, vec3(269.5, 183.3, 765.54)), \n                          dot(p, vec3(420.69, 631.2, 109.21))))\n                 * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                 * 43758.5453);\n}\n\nfloat WorleyNoise2D(vec2 p) {\n    \n    // Tile the space\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(pointInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nconst vec3 a = vec3(0.05,0.05,0.5);\nconst vec3 b = vec3(0.5,0.5,0.5);\nconst vec3 c = vec3(0.55,0.55,0.55);\nconst vec3 d = vec3(0.55,0.55,0.55);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nconst vec3 a2 = vec3(0.7, 0.5, 0.5);\nconst vec3 b2 = vec3(0.5, 0.5, 0.5);\nconst vec3 c2 = vec3(0.8, 0.8, 0.2);\nconst vec3 d2 = vec3(0.8,0.8,0.05);\n\n\nvec3 colorPalette2(float t) {\n    return a2 + b2 * cos(6.28 * (t * c2 + d2));\n}\n\nfloat noise2D(vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n}\n\nfloat noise3D(vec3 p ) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 818.2))) *\n                 43758.5453);\n}\n\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1., intY));\n    float v3 = noise2D(vec2(intX, intY + 1.));\n    float v4 = noise2D(vec2(intX + 1., intY + 1.));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(vec2 p) {\n    float total = 0.;\n    float persistence = 0.73f;\n    float octaves = 16.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(p.x * freq,\n                               p.y * freq) * amp;\n    }\n    return total;\n}\n\nfloat fbm2(vec2 p) {\n    p *= 1.;\n    float total = 0.;\n    float persistence = 0.6f;\n    float octaves = 16.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(p.x * freq,\n                               p.y * freq) * amp;\n    }\n    return total;\n}\n\n/********************************/\n/***** NOISE FUNCTIONS END ******/\n/********************************/\n    \n\n// SDF of a sphere\nfloat sphere(vec3 p , float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n// SDF of plane\nfloat plane(vec3 p, vec3 n, vec3 c)\n{\n  \t// n must be normalized\n  \tvec3 a = p - c;\n  \tvec3 b = n;\n    \n    if (dot(a, b) < -0.001) {\n        return 10000.;\n    }\n    if (length(p - c) > 82.) {\n        return 1000000.;\n    }\n  \n  \treturn dot(a ,b) / length(b);\n}\n\n// transformation\nmat4 inverseTransform(vec3 s, vec3 rDeg, vec3 t) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 rMat = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 translateMat;\n    translateMat[0] = vec4(1., 0., 0., 0.);\n    translateMat[1] = vec4(0., 1., 0., 0.);\n    translateMat[2] = vec4(0., 0., 1., 0.);\n    translateMat[3] = vec4(t.x, t.y, t.z, 1.);\n    \n    mat4 scaleMat;\n    scaleMat[0] = vec4(s.x, 0., 0., 0.);\n    scaleMat[1] = vec4(0., s.y, 0., 0.);\n    scaleMat[2] = vec4(0., 0., s.z, 0.);\n    scaleMat[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = translateMat * rMat * scaleMat;\n    \n    return inverse(worldTrans);\n}\n\n// SDF of box\nfloat roundedBox(vec3 p, vec3 s, vec3 r, vec3 t, float radius) {\n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    \n  \tvec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    \n  \tp.x = abs(p.x);\n  \tfloat k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  \treturn sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat smoothBlendSDF(vec3 pos, float a, float b, float k) {\n\n    float h = clamp((0.5f + 0.5f * (b - a) / k), 0.f, 1.f);\n    return mix(b, a, h) - k * h * (1.f - h);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    \n    float t2;\n    if ((t2 = HANDLE_SDF) < t) {\n        t = t2;\n        obj = HANDLE_ID;\n    }\n    if ((t2 = SUN_SDF) <t) {\n        t = t2;\n        obj = SUN_ID;\n    }\n    if ((t2 = MJOLNIR_SDF) < t) {\n        t = t2;\n        obj = MJOLNIR_ID;\n    }\n    if ((t2 = STRING_SDF) < t) {\n        t = t2;\n        obj = STRING_ID;\n    }\n    if ((t2 = CAP_SDF) < t) {\n        t = t2;\n        obj = CAP_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = HANDLE_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SUN_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = MJOLNIR_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = CAP_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat shadowMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = HANDLE_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = MJOLNIR_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n\tvec3 scatterDir = lightDir + normal * DISTORTION; // Last term is tunable\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir),\n\t\t\t\t\t\t\t     0.0, 1.0), GLOW) * SCALE;\n\tfloat attenuation = max(0.0, dot(normal, lightDir)\n                             + dot(viewVec, -lightDir));\n    //attenutation = 1.f;\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n\treturn totalLight;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float max_t, float k) {\n    float res = 1.0;\n    for(float t = min_t; t < max_t; /*No update in loop header*/) {\n        float m = shadowMap3D(origin + t * dir, vec3(0., 0., 0.));\n        if(m < 0.0001) {\n            return 0.0; // In shadow\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(sin(a) * p.x + cos(a) * p.z, p.y, -cos(a) * p.x + sin(a) * p.z);\n}\n\nvec2 sphereUVMapSun(vec3 pos, vec3 lightPos) {\n    vec3 n = normalize(pos - lightPos); // sphere point - sphere center: for the sun\n    float phi = atan(n.z, n.x);\n    if (phi < 0.) {\n        phi += 2. * 3.1415926;\n    }\n    float theta = acos(n.y);\n    float u = 1. - phi / (2. * 3.1415926);\n    float v = 1. - theta / 3.1415926;\n    return vec2(u, v);\n}\n\nvec2 planeUVMap(vec3 pos) {\n    vec3 n = vec3(0., 1., 0.);\n    vec3 u = normalize(vec3(1., 0., 0.));\n    vec3 v = cross(n, u);\n    \n    float u_coord = dot(u, pos);\n\tfloat v_coord = dot(v,pos);\n    return vec2(u_coord, v_coord);\n}\n\nvec3 computeMaterial(int hitObj, vec3 pos, vec3 n, vec3 lightVec, vec3 view, float thickness, vec3 lightPos) {\n    float lambert = max(0., dot(lightVec, n)) * softShadow(lightVec, pos, 0.1, 50., 6.0);\n    \n    switch(hitObj) {\n        case FLOOR_ID:\n        \tif (pos.z > 70.) {\n\t\t\t\treturn vec3(0.);\n            }\n        \tvec3 warpedColor = vec3(1., 1., 1.) * lambert * colorPalette(cos(iTime * SPEED)* WorleyNoise2D(planeUVMap(2. * pos / 4.)));\n    \t\tvec3 warpedConstant = vec3(1., 1., 1.) * lambert * colorPalette(cos(2.6)* WorleyNoise2D(planeUVMap(pos)));\n        \t//warpedConstant /= 1.5;\n        \twarpedColor *= 1.3;\n        \tvec3 floorColor = warpedColor + warpedConstant;\n            if (pos.z > 60.) {\n\t\t\t\tfloorColor *= 0.7;\n            }\n        \treturn floorColor;\n        \tbreak;\n        case MJOLNIR_ID:\n        \n        \tvec3 diffuseColor = vec3(0.65, 0.65, 0.65) * fbm2(vec2(pos.x, pos.y));\n        \t// Calculate Bling Phong terms\n            float diffuseTerm = max(0., dot(normalize(n), normalize(lightVec)));\n            vec3 average = normalize((normalize(lightVec) + normalize(view)) / 2.f);\n            float specularIntensity = max(pow(dot(average, normalize(n)), 3.5), 0.);\n            float lightIntensity = diffuseTerm + 0.2f;\n\n            // Compute final shaded color\n        \tvec3 blingColor = vec3(diffuseColor * lightIntensity) + vec3(specularIntensity);\n        \tvec3 mjolnirColor = blingColor + subsurface(lightVec, n, view, thickness) * vec3(0.1, 0.3, 1.);\n        \n        \treturn mjolnirColor;\n            break;\n\t\tcase HANDLE_ID:\n        \n        \t// metal stripes\n            if ((pos.y <= 2. && pos.y > 1.85) || (pos.y <= 3. && pos.y > 2.85) ||\n               (pos.y <= 1. && pos.y > 0.85) || (pos.y <= 4. && pos.y > 3.85) || \n               (pos.y <= 5. && pos.y > 4.85)) {\n                \n                vec3 diffuseHandle = vec3(180., 180., 180.) / 255.;\n                float diffuseTerm2 = max(0., dot(normalize(n), normalize(lightVec)));\n            \tvec3 average2 = normalize((normalize(lightVec) + normalize(view)) / 2.f);\n            \tfloat specularIntensity2 = max(pow(dot(average2, normalize(n)), 50.f), 0.);\n            \tfloat lightIntensity2 = diffuseTerm2 + 0.2f;\n                vec3 shinyColor = vec3(diffuseHandle * lightIntensity2) + vec3(specularIntensity2);\n\t\t\t\treturn shinyColor;\n            }\n        \n        \t// wood\n        \tvec3 color = vec3(0.55, 0.26, 0.04) * lambert * fbm(pos.xy);\n        \treturn color + subsurface(lightVec, n, view, thickness) * vec3(0.2, 0.5, 1.);\n            break;\n        case SUN_ID:\n        \treturn vec3(1.0, 0.88, 0.7) * colorPalette2(fbm(sphereUVMapSun(pos, vec3(10., 0., 100.))) * mix(0.95, 1.15, cos(iTime / 4.)));\n        \tbreak;\n        case STRING_ID:\n        \tvec3 lightning = vec3(0.3, 0.8, 1.) * colorPalette(mix(1.2, 1.5, cos(iTime * 3.))* WorleyNoise2D(pos.xy * 64.));\n\n        \treturn lightning;\n        \tbreak;\n        case CAP_ID:\n        \tvec3 diffuseColor3 = vec3(0.45, 0.45, 0.45) * fbm2(vec2(pos.x * 32., pos.y * 32.));\n        \t// Calculate Bling Phong terms\n            float diffuseTerm3 = max(0., dot(normalize(n), normalize(lightVec)));\n            vec3 average3 = normalize((normalize(lightVec) + normalize(view)) / 2.f);\n            float specularIntensity3 = max(pow(dot(average3, normalize(n)), 20.f), 0.);\n            float lightIntensity3 = diffuseTerm3 + 0.2f;\n\n            // Compute final shaded color\n        \tvec3 blingColor3 = vec3(diffuseColor3 * lightIntensity3) + vec3(specularIntensity3);\n        \tvec3 mjolnirColor3 = blingColor3 + subsurface(lightVec, n, view, thickness) * vec3(0.1, 0.3, 1.);\n        \n        \treturn mjolnirColor3;\n        \tbreak;\n        case -1:\n            return vec3(0., 0., 0.);\n        \tbreak;\n    }\n    return vec3(0., 0., 0.);\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos), \n                    \t  sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n    \n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat AO5Step(vec3 p, vec3 n) {\n    float sum = 0.;\n    for (float i = 1.; i <= 5.; i = i + 1.) {\n        float distSDF = sceneMap3D(p + n * i * OCCDist, vec3(0.));\n        sum += (1. / pow(2., i)) * (i * OCCDist - distSDF);\n    }\n    float ao = 1.0 - KSTEP * sum;\n    return ao;\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, lightPos);\n    \n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = AO5Step(isect, -nor);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness, lightPos);\n        \n    return Intersection(t, surfaceColor, isect, hitObj, nor);\n}\n\n// returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0, 1, 0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\n/******** Lightning ****************/\n/***********************************/\n\n// credit: https://www.shadertoy.com/view/XlsGWS\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p+4.5476351));\n}\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 fbm2Light(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.0;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += abs(noise2(x)+.5 )* a;\n        x *= 2.;\n        a *= .5;\n    }\n     \n    return r;\n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\n\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), -0.2, 1. );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\n\n\n\nfloat thunderbolt(vec2 x,vec2 tgt)\n{\n    vec2 r = tgt;\n    float d=1000.;\n    float dist=length(tgt-x);\n     \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= (noise2(r+iTime)+vec2(0.,.7))*2.;\n        dist = dseg(s,x-r);\n        d=min(d,dist);\n        \n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return exp(-5.*d)+.2*exp(-1.*dist);\n   \n}\n\n/***********************************/\n/***********************************/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 5.5, -35);\n    vec3 ref = vec3(0, 2.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    vec3 lightPos = vec3(9., 8.4, 5.);\n    //vec3 lightPos = vec3(9.,8., 7.);\n    //vec3 lightPos = rotateY(vec3(0., 7.4, 10.), sin(iTime * 0.5));\n\n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n    \n    // ambient occlusion\n    float k = 2.5;\n    float occDist = 0.12;\n    float sum = 0.;\n    for (float i = 1.; i <= 5.; i = i + 1.) {\n        float distSDF = sceneMap3D(isect.p + isect.n * i * occDist, lightPos);\n        sum += (1. / pow(2., i)) * (i * occDist - distSDF);\n    }\n    float ao = 1.0 - k * sum;\n    \n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.) * ao;\n    \n    /**** Lightning *****/\n    vec2 p = 2.*fragCoord.xy/iResolution.yy-1.;\n    p.x -= 0.82;\n    p.y += 0.1;\n    vec2 p2 = vec2(p.x + 0.5, p.y);\n    \n    p *= 3.;\n    p2 *= 4.;\n    \n    vec2 tgt = vec2(1., -8.);\n    float c = 0.;\n    vec3 col;\n    \n    vec2 tgt2 = vec2(1., -10.);\n    float c2 = 0.;\n    vec3 col2;\n    \n    float t = hash(floor(2.*iTime));\n    tgt += 8.*hash2b(tgt+t);\n    float t2 = hash(floor(2.*iTime));\n    tgt2 += 8.*hash2b(tgt+t);\n    \n    if(hash(t+2.3)>.8)\n\t{\n\t\tc= thunderbolt(p*10.+2.*fbm2Light(3.*p),tgt);\t\n\t\tcol+=clamp(1.7*vec3(0.3,.6, 1.2)*c,0.,1.);\t\n\t}\n    \n    if(hash(t2+4.3)>.8)\n\t{\n\t\tc2= thunderbolt(p*6.+5.*fbm2Light(3.*p),tgt2);\t\n\t\tcol2+=clamp(1.7*vec3(0.3,.6, 1.2)*c2,0.,1.);\t\n\t}\n    \n    if (length(col) > 0.8) {\n        fragColor = vec4(col, 0.0);\n    }\n    \n    if (length(col2) > 0.8) {\n        if (p.y > -0.05 || p.y < -1.5) {\n            return;\n        }\n        fragColor = vec4(col2, 0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}