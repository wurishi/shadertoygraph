{"ver":"0.1","info":{"id":"ctX3WN","date":"1671733279","viewed":89,"name":"Ray Marching, Animação e Textura","username":"YagoDelfino","description":"Trabalho de Ray-Marching do professor Paulo Roma, UFRJ.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_OCTAVES 8\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n#define speed 0.5\n#define scale 10.0\n#define offset 0.0\n#define multiplier 1.0\n#define first 0.5\n#define second 0.5\n#define octaves 1.0\n#define lacunarity 2.0\n#define persistence 0.5\n#define colorNoise 1.0\n#define bumpmapNoise 0.0\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\nvec4 noised( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash(i+vec3(0.0,0.0,0.0));\n    float b = hash(i+vec3(1.0,0.0,0.0));\n    float c = hash(i+vec3(0.0,1.0,0.0));\n    float d = hash(i+vec3(1.0,1.0,0.0));\n    float e = hash(i+vec3(0.0,0.0,1.0));\n\tfloat f = hash(i+vec3(1.0,0.0,1.0));\n    float g = hash(i+vec3(0.0,1.0,1.0));\n    float h = hash(i+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise3(vec3 p) {\n  vec4 v = noised(p);\n  return v.x; \n}\n\nfloat octaveNoise (vec3 p) {\n  float total = 0.;\n  float frequency = 1.;\n  float amplitude = 1.;\n  float value = 0.;\n  for (int i = 0; i < MAX_OCTAVES; ++i) {\n    if (float(i) >= octaves) break;\n    value += noise3(p * frequency) * amplitude;\n    total += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n  return value / total;\n}\n\n\nvec3 phong (vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 N,\n            vec3 lightPos, vec3 lightIntensity) {\n    vec3 eye = 10.0*normalize(vec3(0.5-iMouse.xy/iResolution.xy,0.5)); // Position of the eye\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return k_a * lightIntensity;\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_a + k_d * dotLN);\n    }\n    return lightIntensity * (k_a + k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// Rotation matrix.\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat cubeSDF(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nfloat largeSphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.2;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    samplePoint.xz *= Rot(iTime);\n    samplePoint.yz *= Rot(iTime);\n    return max(cubeSDF(samplePoint),-largeSphereSDF(samplePoint));\n}\n\nfloat shortestDistanceToSurface(vec3 marchingDirection, float start, float end) {\n    const float fieldOfView = radians(45.0); // Vertical camera angle\n    vec3 eye = 10.0*normalize(vec3(0.5-iMouse.xy/iResolution.xy,0.5)); // Position of the eye\n  float depth = start;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    float dist = sceneSDF(eye + depth * marchingDirection);\n    if (dist < EPSILON) {\n      return depth;\n    }\n    depth += dist;\n    if (depth >= end) {\n      return end;\n    }\n  }\n  return end;\n}\n\nfloat getNoiseColor( vec3 p ) {\n  p.xz *= Rot(iTime);\n  p.yz *= Rot(iTime);\n  return offset + multiplier * octaveNoise(vec3 (scale*p + speed*iTime));\n}\n\nvec3 noiseNormal(vec3 p) {\n  return normalize (vec3 (getNoiseColor(p+vec3(EPSILON,0.0,0.0))-getNoiseColor(p-vec3(EPSILON,0.0,0.0)),\n                          getNoiseColor(p+vec3(0.0,EPSILON,0.0))-getNoiseColor(p-vec3(0.0,EPSILON,0.0)),\n                          getNoiseColor(p+vec3(0.0,0.0,EPSILON))-getNoiseColor(p-vec3(0.0,0.0,EPSILON))));\n}\n\nvec3 rayDirection(vec2 fragCoord) {\n  const float fieldOfView = radians(45.0); // Vertical camera angle\n  vec2 xy = fragCoord - iResolution.xy / 2.0;\n  float z = iResolution.y / tan(fieldOfView / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\nvec3 normal(vec3 p) {\n  return normalize (vec3 (sceneSDF(p+vec3(EPSILON,0.0,0.0))-sceneSDF(p-vec3(EPSILON,0.0,0.0)),\n                          sceneSDF(p+vec3(0.0,EPSILON,0.0))-sceneSDF(p-vec3(0.0,EPSILON,0.0)),\n                          sceneSDF(p+vec3(0.0,0.0,EPSILON))-sceneSDF(p-vec3(0.0,0.0,EPSILON))));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  const float fieldOfView = radians(45.0); // Vertical camera angle\n  vec3 eye = 10.0*normalize(vec3(0.5-iMouse.xy/iResolution.xy,0.5)); // Position of the eye\n  mat4 view = lookAt(eye,vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0)); \n  vec3 dir = (view*(vec4(rayDirection(gl_FragCoord.xy),1.0))).xyz;\n  float dist = shortestDistanceToSurface(dir, MIN_DIST, MAX_DIST);\n  if (dist > MAX_DIST - EPSILON) {\n    fragColor = vec4( 0.8, 0.8, 0.8, 1.0); // light gray\n  }\n  else {\n    vec3 p = eye + dist * dir;\n    vec3 N = normal(p);\n    float color = 1.0;\n    if( colorNoise == 1.0 ) {\n      color = getNoiseColor( p );\n    }\n    if( bumpmapNoise == 1.0 ) {\n      vec3 noise_normal = noiseNormal( p );\n      if ( dot( N, noise_normal ) < 0.0 ) noise_normal = reflect( noise_normal, N);\n      N = normalize( N + noise_normal );\n    }\n    fragColor = vec4(phong (vec3 (0.3), // ambient\n                               vec3 (0.8)*color, // diffuse\n                               vec3 (0.7)*color, // specular\n                               50.0, // shininess\n                               p, // point\n                               N, // normal at point\n                               vec3(5.0,5.0,10.0), // light position\n                               vec3(1.0,1.0,1.0)), // light color/intensity\n                        1.0);\n  }\n  \n }\n","name":"Image","description":"","type":"image"}]}