{"ver":"0.1","info":{"id":"csV3RV","date":"1678819854","viewed":129,"name":"More noise, 3D vector trick","username":"ianertson","description":"Was a bit bored so decided to write some more noise functions.\n Had an idea for re-using a \"two to one hash\" to also be able to output a 3D vector;\n by simply extracting 3 bytes from the \"two to one hash\".","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Was a bit bored so decided to write some more noise functions.\n    Had an idea for re-using a \"two to one hash\" to also be able to output a 3D vector;\n    by simply extracting 3 bytes from the \"two to one hash\".\n*/\n\n\n//////////////////// Hash functions //////////////////////////\n\n// all other 2D hash & noise functions in this code are\n// built upon this hash function.\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed); // re-using the same hash\n                                // but slicing 3 bytes from it\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\n// all other 3D hash & noise functions in this code are\n// built upon this hash function.\nuint hash31u(in vec3 ip, in float seed) {\n    uvec3 p = uvec3(floatBitsToUint(ip.x), floatBitsToUint(ip.y), floatBitsToUint(ip.z));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    s ^= (~p.z);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y + p.z) ^ (p.x * s + p.y * p.z))*293U;\n}\n\nfloat hash31(in vec3 ip, in float seed) { return float(hash31u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash33(in vec3 ip, in float seed) {\n    uint n = hash31u(ip, seed); // re-using the same hash\n                                // but slicing 3 bytes from it\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\n\n//////////////////// Noise functions //////////////////////////\n\n#define IMPL_NOISE_OCTAVE(VAR, FUNC)\\\n    float div = 0.0;\\\n    float amp = 1.0;\\\n    for (int i = 0; i < octaves; i++) {\\\n        VAR += amp * FUNC(p * freq, seed); div += amp; amp /= 2.0; freq *= 2.0; \\\n    }\\\n    return VAR / div;\n    \n#define IMPL_NOISE_OCTAVE_WARP_1(VAR, FUNC)\\\n    float div = 0.0;\\\n    float amp = 1.0;\\\n    for (int i = 0; i < octaves; i++) {\\\n        VAR += amp * FUNC(p * freq, seed); div += amp; amp /= 2.0; freq *= 2.0; \\\n        p += VAR * warp;\\\n    }\\\n    return VAR / div;    \n    \n#define IMPL_NOISE_OCTAVE_WARP_2(VAR, FUNC)\\\n    float div = 0.0;\\\n    float amp = 1.0;\\\n    for (int i = 0; i < octaves; i++) {\\\n        VAR += amp * FUNC(p * freq, seed); div += amp; amp /= 2.0; freq *= 2.0; \\\n        p += VAR.xy * warp;\\\n    }\\\n    return VAR / div;\n\nfloat noise21(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id + vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noise21(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float n = 0.0;\n    IMPL_NOISE_OCTAVE(n, noise21);\n}\n\nfloat noise21Warp(in vec2 p, in float seed, in float freq, const in int octaves, in float warp) {\n    float n = 0.0;\n    IMPL_NOISE_OCTAVE_WARP_1(n, noise21);\n}\n\nvec3 noise23(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash23(id, seed), hash23(id+vec2(1, 0), seed), lv.x),\n        mix(hash23(id + vec2(0, 1), seed), hash23(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise23(in vec2 p, in float seed, in float freq, const in int octaves) {\n    vec3 n = vec3(0.0);\n    IMPL_NOISE_OCTAVE(n, noise23);\n}\n\nvec3 noise23Warp(in vec2 p, in float seed, in float freq, const in int octaves, in float warp) {\n    vec3 n = vec3(0.0);\n    IMPL_NOISE_OCTAVE_WARP_2(n, noise23);\n}\n\nfloat noise31(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(\n            mix(hash31(id, seed), hash31(id+vec3(1, 0, 0), seed), lv.x),\n            mix(hash31(id + vec3(0, 1, 0), seed), hash31(id+vec3(1, 1, 0), seed), lv.x),\n            lv.y\n        ),\n        mix(\n            mix(hash31(id+vec3(0, 0, 1), seed), hash31(id+vec3(1, 0, 1), seed), lv.x),\n            mix(hash31(id + vec3(0, 1, 1), seed), hash31(id+vec3(1, 1, 1), seed), lv.x),\n            lv.y\n        ),\n        lv.z\n    );\n}\n\nfloat noise31(in vec3 p, in float seed, in float freq, const in int octaves) {\n    float n = 0.0;\n    IMPL_NOISE_OCTAVE(n, noise31);\n}\n\nfloat noise31Warp(in vec3 p, in float seed, in float freq, const in int octaves, in float warp) {\n    float n = 0.0;\n    IMPL_NOISE_OCTAVE_WARP_1(n, noise31);\n}\n\nvec3 noise33(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(\n            mix(hash33(id, seed), hash33(id+vec3(1, 0, 0), seed), lv.x),\n            mix(hash33(id + vec3(0, 1, 0), seed), hash33(id+vec3(1, 1, 0), seed), lv.x),\n            lv.y\n        ),\n        mix(\n            mix(hash33(id+vec3(0, 0, 1), seed), hash33(id+vec3(1, 0, 1), seed), lv.x),\n            mix(hash33(id + vec3(0, 1, 1), seed), hash33(id+vec3(1, 1, 1), seed), lv.x),\n            lv.y\n        ),\n        lv.z\n    );\n}\n\nvec3 noise33(in vec3 p, in float seed, in float freq, const in int octaves) {\n    vec3 n = vec3(0.0);\n    IMPL_NOISE_OCTAVE(n, noise33);\n}\n\nvec3 noise33Warp(in vec3 p, in float seed, in float freq, const in int octaves, in float warp) {\n    vec3 n = vec3(0.0);\n    IMPL_NOISE_OCTAVE_WARP_1(n, noise33);\n}\n\n////////////// visualization stuff\n\n#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (m.z > 0.001 && length(m.xy) > 0.001 && iFrame > 1 && iTime > 0.00003) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        rd.yz *= rot(T*0.2);\n        rd.xz *= rot(T*0.2);\n        \n    }\n    \n    vec2 w1 = vec2(R.y/2.);\n    \n    if (fc.x > 0. && fc.x < w1.x && fc.y > w1.y && fc.y < R.y) {\n        vec2 uv = (fc.xy)/w1;\n        uv += vec2(cos(T), sin(T));\n        col += noise21(uv, 0.4234215, 10.0, 6);\n    } else if (fc.x > 0.0 && fc.x < w1.x && fc.y > 0.0 && fc.y < w1.y) {\n        vec2 uv = (fc.xy - w1)/w1;\n        uv += vec2(sin(T), cos(T));\n        col += noise23(uv, 0.4234215, 10.0, 6);\n    } else if (fc.x > w1.x && fc.x < w1.x*2. && fc.y > w1.y && fc.y < R.y) {\n        vec2 uv = (fc.xy - w1)/w1;\n        uv += vec2(sin(T*0.1), cos(T*0.1))*0.00001;\n        col += hash21(uv*0.001, 0.123155);\n    } else if (fc.x > w1.x && fc.x < w1.x*2. && fc.y > 0.0 && fc.y < w1.y) {\n        vec2 uv = (fc.xy - w1)/w1;\n        uv += vec2(sin(T*0.1), cos(T*0.1))*0.00001;\n        col += hash23(uv*0.001, 0.123155);\n    }\n    else {\n        col += noise33Warp(rd, 0.32124, 10.0, 6, (0.5+cos(T)*0.5)*0.1);\n    }\n    \n    col = mix(col, vec3(0.0), 1.0-smoothstep(0., 10., abs((w1.x-fc.x)*2.0-1.0)));\n    col = mix(col, vec3(0.0), 1.0-smoothstep(0., 10., abs(((w1.x*2.)-fc.x)*2.0-1.0)));\n    col = mix(col, vec3(0.0), float(fc.x < w1.x*2.)*(1.0-smoothstep(0., 10., (abs((w1.x-fc.y)*2.0-1.0)))));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}