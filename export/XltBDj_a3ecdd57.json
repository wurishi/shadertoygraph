{"ver":"0.1","info":{"id":"XltBDj","date":"1695044393","viewed":16,"name":"RayMarching 1st","username":"n00bmind","description":"Bla","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ball\n{\n    vec3 pCenter;\n    float radius;\n};\n\nconst int BALL_COUNT = 15;\nBall metaballs[BALL_COUNT];\nbool initialized = false;\n\n\n\nvec2 screenToWorld( vec2 p )\n{\n    vec2 result = 2.0 * (p / iResolution.xy - 0.5);\n    result.x *= iResolution.x / iResolution.y;\n    return result;\n}\n\nvec3 GetCameraRay(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nfloat SDSphere( vec3 p, vec3 pCenter, float r )\n{\n    return distance( p, pCenter ) - r;\n}\n\nfloat sMinCubic( float a, float b, float K )\n{\n    float h = max( K - abs( a - b ), 0.0 );\n    return min( a, b ) - h * h * h / (6.0 * K * K);\n}\n\nfloat SDF( vec3 p )\n{\n    float speed = 0.7;\n    \n    float result = 1000.0;\n    vec3 pBall;\n    float r;\n    \n    for( int i = 0; i < 5; ++i )\n    {\n        switch( i )\n        {\n            case 0:\n            {\n                vec3 vDir = vec3( 0.0, 1.0, -0.2 );\n                pBall = vDir * 3.0 * (sin( iTime * speed ) + 0.342);\n                r = 1.0;\n            } break;\n            \n            case 1:\n            {\n                vec3 vDir = vec3( 0.7, -0.4, 0.1 );\n                pBall = vDir * 2.0 * (sin( iTime * speed ) - 0.87334);\n                r = 1.5;\n            } break;\n            \n            case 2:\n            {\n                vec3 vDir = vec3( 1.0, 0.8, 0.0 );\n                pBall = vDir * (-2.5) * (cos( iTime * speed ) - 0.243);\n                r = 0.9;\n            } break;\n\n            case 3:\n            {\n                vec3 vDir = vec3( 1.0, -0.8, 0.0 );\n                pBall = vDir * 1.5 * (cos( iTime * speed ) + 0.93284)\n                    + (-vDir) * 5.0 * sin( iTime * speed );\n                r = 0.9;\n            } break;\n            \n            case 4:\n            {\n                vec3 vDir = vec3( 0.6, -0.3, 0.0 );\n                pBall = vDir * 3.5 * (cos( iTime * speed ) + 0.13284)\n                    + (-vDir) * 0.5 * sin( iTime * speed );\n                r = 0.9;\n            } break;            \n        }\n        \n        float sd = SDSphere( p, pBall, 1.0 );\n        result = sMinCubic( sd, result, 2.0 );\n    }\n    \n    return result;\n}\n\nfloat CastRay( vec3 pSource, vec3 r, float maxDistance )\n{\n    float totalDistance = 0.0;\n    float nextDistance = SDF( pSource );\n    \n    while( nextDistance < maxDistance )\n    {\n        vec3 p = pSource + totalDistance * r;\n        nextDistance = SDF( p );\n        \n        if( nextDistance < 0.01 )\n            break;\n        \n        totalDistance += nextDistance;\n        if( totalDistance > maxDistance )\n        {\n            return -1.0;\n        }\n    }\n    \n    return totalDistance;\n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    // Center sample\n    float c = SDF(pos);\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3( SDF(pos + eps_zero.xyy), SDF(pos + eps_zero.yxy), SDF(pos + eps_zero.yyx) ) - c);\n}\n\nvec3 Shade( vec3 pSource, vec3 r, float d )\n{\n    vec3 pWorld = pSource + d * r;\n    vec3 L = normalize( vec3( 0.5, 1.0, 0.0 ) );\n    vec3 col = vec3( 0, 0, 0.8 );\n    \n    vec3 N = CalcNormal( pWorld );\n    \n    float NoL = max(dot(N, L), 0.0);\n    vec3 LDirectional = vec3(0.9, 0.9, 0.8) * NoL;\n    vec3 LAmbient = vec3(0.09, 0.09, 0.1);\n    vec3 diffuse = col * (LDirectional + LAmbient);\n    \n\treturn diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pScreen = screenToWorld( fragCoord );\n\n    vec3 pCam = vec3( 0.0, 3.0, -7.0 );\n    vec3 pLookAt = vec3( 0.0, 0.0, 0.0 );\n    vec3 r = GetCameraRay( pScreen, pCam, pLookAt );\n    \n    vec3 col = vec3( 1, 1, 1 );\n    float d = CastRay( pCam, r, 100.0 );\n    if( d == -1.0 )\n    {\n        // Skybox colour\n        col = vec3(0.8, 0.8, 0.8) - (r.y * 0.2);\n    }\n    else\n    {\n        // Shade it\n        col = Shade( pCam, r, d );\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}