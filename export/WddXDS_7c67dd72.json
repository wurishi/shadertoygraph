{"ver":"0.1","info":{"id":"WddXDS","date":"1572790290","viewed":284,"name":"Reflection-->Irradiance","username":"lhog","description":"Two methods of computing the Irradiance map from the environment(reflection) map\n1) Weighted sampling\n2) Spherical Harmonics\n\nSwitch between two by setting the right value to #define CONVO_METHOD\n\nInspired by https://www.shadertoy.com/view/XdlXDn","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics","irradiance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define HDR_FOR_POORS\n\n#define CONVO_METHOD_WS 1\n#define CONVO_METHOD_SH 2\n#define CONVO_METHOD_DIFF 3\n#define CONVO_METHOD_ERR_2_PERC 4\n\n#define CONVO_METHOD CONVO_METHOD_SH\n\n////////////////////////////\n\n#define LOD_BIAS 0.0\n\n////////////////////////////\n\n#define GAMMA 2.2\n// gamma correction & tonemapping\n#ifdef GAMMA\n    #define INV_GAMMA 1.0 / GAMMA\n    #define SRGBtoLINEAR(c) ( pow(c, vec3(GAMMA)) )\n    #define LINEARtoSRGB(c) ( pow(c, vec3(INV_GAMMA)) )\n#else\n    #define SRGBtoLINEAR(c) ( c )\n    #define LINEARtoSRGB(c) ( c )\n#endif\n\nhighp float Time;\n\nconst highp float PI = 3.1415926;\nconst highp float INV_PI = 1.0/PI;\nconst highp float PI_2 = PI * 2.0;\nconst highp float PI_4 = PI * 4.0;\n\nconst highp float MARCH_EPS = 0.065;\nconst highp float GRAD_EPS = 0.005;\n\nstruct sdv\n{\n    highp float d;\n    highp int idx;\n};\n\nstruct rayHit\n{\n    highp vec3 p;\n    highp int idx;\n};\n\nsdv combine(sdv a, sdv b)\n{\n    if(a.d < b.d)\n    {  \n        return a;\n    }\n    \n    return b;\n}\n\nconst int IDX_ROOM = 1;\nconst int IDX_ROOM_BOTTOM = 2;\nconst int IDX_SPHERE = 3;\n\nsdv scene(highp vec3 p)\n{\n    sdv sphere;\n    sphere.idx = IDX_SPHERE;\n\n\tvec3 c = vec3(0.0,0.0,0.0);\n\tfloat r = 24.0 + 0.5*(sin(0.05*p.x*p.y+Time*5.0));\n\tsphere.d = length(p-c) - r;\n\t\n    return sphere;\n}\n\nhighp vec3 sceneGrad(highp vec3 p)\n{\n    const highp float h = GRAD_EPS;\n    highp vec3 g;\n    g.x = scene(p+vec3(h,0.0,0.0)).d - scene(p-vec3(h,0.0,0.0)).d;\n    g.y = scene(p+vec3(0.0,h,0.0)).d - scene(p-vec3(0.0,h,0.0)).d;\n    g.z = scene(p+vec3(0.0,0.0,h)).d - scene(p-vec3(0.0,0.0,h)).d;\n    return g;// / (2.0*h);\n}\n\nrayHit rayQuery(highp vec3 start, highp vec3 dir)\n{\n    highp float d = 0.0;\n    const highp float eps = MARCH_EPS;\n    const int numIter = 76;\n    \n    for(int i = 0; i < numIter; ++i)\n    {\n        highp vec3 p = start + dir * d;\n        sdv v = scene(p);\n        if(v.d < eps)\n        {\n            rayHit ret;\n            ret.idx = v.idx;\n            ret.p = p;\n            return ret;\n        }\n        \n        d += v.d;\n    }\n    \n    rayHit ret;\n    ret.idx = -1;\n    ret.p = vec3(0.0);\n    return ret;\n}\n\nhighp vec3 sceneEmittance(highp int idx)\n{\n    return vec3(0.0);\n}\n\nhighp float computeAO(highp vec3 p, highp vec3 normal)\n{\n    highp float ao = 0.0;\n    highp vec3 k = p;\n    const int numSamps = 20;\n    const highp float h = 1.0 / float(numSamps);\n    const highp float d = 0.15;\n    \n    for(int i = 0; i < numSamps; ++i)\n    {\n        ao += h * exp(scene(k).d);\n        k += normal * d;\n    }\n    return clamp(ao*0.125,0.0,1.0);\n}\n\n\nconst float goldenAngle = PI * (3.0 - sqrt(5.0));\nvec3 SpherePoints_GoldenAngle(float i, float numSamples) {\n    float theta = i * goldenAngle;\n    float z = (1.0 - 1.0 / numSamples) * (1.0 - 2.0 * i / (numSamples - 1.0));\n    float radius = sqrt(1.0 - z * z);\n    return vec3(radius * vec2(cos(theta), sin(theta)), z);\n}\n\n//////////////////////////////////////////////////////\nconst vec3 LUMA = vec3(0.2126, 0.7152, 0.0722);\n\n\nconst float hdrThreshold = 0.6;\nconst float ldrShift = 10.0 / 255.0;\n//Inversed ACES_TM\nvec3 InvTM(vec3 ldr, float lumaThreshold) {\n    vec3 x = clamp(ldr - ldrShift, vec3(0.0), vec3(1.0));\n    \n    float luma = dot(x, LUMA);\n    \n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;        \n    vec3 bdx = b - d * x;    \n    vec3 hdr = (-b + d * x + sqrt(4.0 * e * x * (a - c * x) + bdx * bdx)) / (2.0 * (a - c * x));\n    hdr = max(hdr, vec3(0.0));\n    \n    float mixFactor = smoothstep(lumaThreshold, 1.0, luma);\n    //return hdr;\n    return mix(ldr, hdr, mixFactor);\n}\n\nvec3 sampleReflectionMap(vec3 sp, float lodBias){\n    #ifdef LOD_BIAS\n    \tlodBias = LOD_BIAS;\n    #endif\n    vec3 color = SRGBtoLINEAR(textureLod(iChannel0, sp, lodBias).rgb);\n    #if defined (HDR_FOR_POORS)\n    \t//color *= 1.0 + 2.0*smoothstep(hdrThreshold, 1.0, dot(LUMA, color)); //HDR for poors\n    \tcolor = InvTM(color, hdrThreshold);\n   \t#endif\n    return color;\n}\n\n//////////////////////////////////////////////////////\n\n#define ENV_SMPL_NUM 1024\nvec3 TextureEnvBlured(in vec3 N) {\n    vec3 iblDiffuse = vec3(0.0);\n\n    float sum = 0.0;\n\n    vec2 ts = vec2(textureSize(iChannel0, 0));\n    float maxMipMap = log2(max(ts.x, ts.y));\n\n    float lodBias = maxMipMap - 6.0;\n\n    for (int i=0; i < ENV_SMPL_NUM; ++i) {\n        vec3 sp = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));\n\n        float w = dot(sp, N ) * 0.5 + 0.5;\n\n        // 4 is somehow a magic number that makes results of\n        // weighted sampling and spherical harmonics convolutions match almost perfectly (~2% difference)\n        w = pow(w, 4.0); \n\n        vec3 iblD = sampleReflectionMap(sp, lodBias);\n\n        iblDiffuse  += iblD * w;\n\n        sum += w;\n    }\n\n    iblDiffuse  /= sum;\n    return iblDiffuse;\n}\n\n/////////////////////////////////////////////////////////\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SphericalHarmonic( in int l, in int m, in vec3 n ) \n{ \n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    \n    //----------------------------------------------------------\n\tif( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    \n    //----------------------------------------------------------\n\tif( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n\n\treturn 0.0;\n}\n\nmat3 shEvaluate(vec3 n) {\n    mat3 r;\n    r[0][0] =  SphericalHarmonic(0,  0, n);\n    r[0][1] = -SphericalHarmonic(1, -1, n);\n    r[0][2] =  SphericalHarmonic(1,  0, n);\n    r[1][0] = -SphericalHarmonic(1,  1, n);\n\n    r[1][1] =  SphericalHarmonic(2, -2, n);\n    r[1][2] = -SphericalHarmonic(2, -1, n);\n    r[2][0] =  SphericalHarmonic(2,  0, n);\n    r[2][1] = -SphericalHarmonic(2,  1, n);\n    r[2][2] =  SphericalHarmonic(2,  2, n);\n    return r;\n}\n\n// Adds two SH functions together.\nmat3 shAdd(mat3 shL, mat3 shR) {\n\treturn shL + shR;\n}\n\n// Scales a SH function uniformly by v.\nmat3 shScale(mat3 sh, float v) {\n\treturn sh * v;\n}\n\n// Recovers the value of a SH function in the direction dir.\nfloat shUnproject(mat3 functionSh, vec3 dir)\n{\n\tmat3 sh = shEvaluate(dir);\n\treturn\n        dot(functionSh[0], sh[0]) +\n        dot(functionSh[1], sh[1]) +\n        dot(functionSh[2], sh[2]);\n}\n\nconst vec3 convCoeff = vec3(1.0, 2.0/3.0, 1.0/4.0);\nmat3 shDiffuseConvolution(mat3 sh) {\n\tmat3 r = sh;\n    \n    r[0][0] *= convCoeff.x;\n\n    r[0][1] *= convCoeff.y;\n    r[0][2] *= convCoeff.y;\n    r[1][0] *= convCoeff.y;\n    \n    r[1][1] *= convCoeff.z;\n    r[1][2] *= convCoeff.z;\n    r[2][0] *= convCoeff.z;\n    r[2][1] *= convCoeff.z;\n    r[2][2] *= convCoeff.z;    \n    \n\treturn r;\n}\n\nmat3 shDiffuseConvolutionPI(mat3 sh) {\n\treturn PI * shDiffuseConvolution(sh);\n}\n\nvoid CubeMapToSH2(out mat3 shR, out mat3 shG, out mat3 shB) {\n    // Initialise sh to 0\n    shR = mat3(0.0);\n    shG = mat3(0.0);\n    shB = mat3(0.0);\n    \n    vec2 ts = vec2(textureSize(iChannel0, 0));\n    float maxMipMap = log2(max(ts.x, ts.y));\n    float lodBias = maxMipMap-6.0;\n    \n\n    for (int i=0; i < ENV_SMPL_NUM; ++i) {\n        vec3 rayDir = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));\n        vec3 color = sampleReflectionMap(rayDir, lodBias);\n\n        mat3 sh = shEvaluate(rayDir);\n        shR = shAdd(shR, shScale(sh, color.r));\n        shG = shAdd(shG, shScale(sh, color.g));\n        shB = shAdd(shB, shScale(sh, color.b));            \n    }\n\n    // integrating over a sphere so each sample has a weight of 4*PI/samplecount (uniform solid angle, for each sample)\n    float shFactor = 4.0 * PI / float(ENV_SMPL_NUM);\n    shR = shScale(shR, shFactor );\n    shG = shScale(shG, shFactor );\n    shB = shScale(shB, shFactor );\n}\n\nvec3 SH2toColor(mat3 shR, mat3 shG, mat3 shB, vec3 rayDir) {\n    vec3 rgbColor = vec3(\n        shUnproject(shR, rayDir),\n        shUnproject(shG, rayDir),\n        shUnproject(shB, rayDir));\n    \n    // A \"max\" is usually recomended to avoid negative values (can happen with SH)\n    rgbColor = max(vec3(0.0), vec3(rgbColor));\n    return rgbColor;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////\n\nvec3 TextureEnvBlured2(in vec3 N) {\n    vec3 iblDiffuse = vec3(0.0);\n\t\n    mat3 shR, shG, shB;\n    \n    CubeMapToSH2(shR, shG, shB);\n    \n    #if 1\n    \tshR = shDiffuseConvolution(shR);\n    \tshG = shDiffuseConvolution(shG);\n    \tshB = shDiffuseConvolution(shB);\n    #endif\n    \n    #if 0\n    \tshR = shDiffuseConvolutionPI(shR);\n    \tshG = shDiffuseConvolutionPI(shG);\n    \tshB = shDiffuseConvolutionPI(shB);\n    #endif    \n    \n    iblDiffuse = SH2toColor(shR, shG, shB, N);\n    return iblDiffuse;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n\nhighp vec3 computeRadiance(highp vec3 camPos, highp vec3 camDir)\n{\n    rayHit q = rayQuery(camPos,camDir);\n    if(q.idx >= 0)\n    {\n        highp vec3 normal = normalize(sceneGrad(q.p));\n        highp vec3 ambient = vec3(0.0);\n    \n        highp vec3 radiance = ambient;\n        radiance += sceneEmittance(q.idx) +\n            #if CONVO_METHOD == CONVO_METHOD_WS\n            \tTextureEnvBlured(normal);\n        \t#elif CONVO_METHOD == CONVO_METHOD_SH\n        \t\tTextureEnvBlured2(normal);\n        \t#elif CONVO_METHOD == CONVO_METHOD_DIFF\n        \t\tabs(TextureEnvBlured2(normal) - TextureEnvBlured(normal));\n        \t#else\n            \tvec3(any(greaterThan(abs(TextureEnvBlured2(normal) - TextureEnvBlured(normal)), vec3(0.02))));\n       \t\t#endif\n            \n        return radiance;\n    }\n    #if (CONVO_METHOD >= CONVO_METHOD_DIFF)\n    \treturn (texture(iChannel0,camDir).rgb);\n    #else\n\t\treturn SRGBtoLINEAR(texture(iChannel0,camDir).rgb);\n    #endif\t\n}\n\nhighp mat4 lookAtInv(highp vec3 eyePos, highp vec3 targetPos, highp vec3 upVector)\n{\n    highp vec3 forward = normalize(targetPos - eyePos);\n    highp vec3 right = normalize(cross(forward,upVector));\n    upVector = normalize(cross(right,forward));\n    \n    highp mat4 r;\n    r[0] = vec4(right,0.0);\n    r[1] = vec4(upVector,0.0);\n    r[2] = vec4(-forward,0.0);\n    r[3] = vec4(eyePos,1.0);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tTime = mod(iTime, PI_4 * 2.0);\n\t\n\thighp vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n\t\n\tfloat r = 120.0;\n\tfloat s = 0.5;\n\thighp mat4 m = lookAtInv(vec3(r*cos(Time*s),sin(Time*s)*50.0,r*sin(Time*s)),vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0));\n\thighp float sw = 0.0;\n\t\n\tconst highp float aspect = 2.0;\n\thighp vec3 camPos = vec3((uv.x-0.5)*aspect,uv.y-0.5,0.0);\n\thighp vec3 camDir = normalize(vec3(aspect*(uv.x-0.5),uv.y-0.5,-1.5-sw));\n\n    camPos = ( m * vec4(camPos,1.0) ).xyz;\n    camDir = ( m * vec4(camDir,0.0) ).xyz;\n    \n\thighp vec3 radiance = vec3(0.0);\n    radiance += computeRadiance(camPos,camDir);\n\n    #if (CONVO_METHOD >= CONVO_METHOD_DIFF)\n    \tfragColor = vec4((vec3(radiance)),0.0);\n    #else\n\t\tfragColor = vec4(LINEARtoSRGB(vec3(radiance)),0.0);\n    #endif\n}\n","name":"Image","description":"","type":"image"}]}