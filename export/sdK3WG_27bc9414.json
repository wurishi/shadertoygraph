{"ver":"0.1","info":{"id":"sdK3WG","date":"1632131697","viewed":756,"name":"GPU hacks #13 - Metal API","username":"PrzemyslawZaworski","description":"Comment contains Metal API (macOS / iOS) framework for vertex and pixel shaders - with working example, visually equivalent to visible shader.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["framework","tutorial","metal","apple","mac","programming","macos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n// Metal API minimal example. Tested with macOS Big Sur 11.4\n// Save as Demo.swift then compile from terminal: swiftc Demo.swift\nimport Cocoa\nimport AppKit\nimport Metal\nimport MetalKit\nimport simd\n\nclass AppDelegate: NSObject, NSApplicationDelegate, NSMenuDelegate\n{\n    var mainWindow: NSWindow?\n\n    func applicationDidFinishLaunching(_ notification: Notification)\n    {\n        let windowMask = NSWindow.StyleMask(rawValue: (NSWindow.StyleMask.titled.rawValue | NSWindow.StyleMask.closable.rawValue))\n        let window = NSWindow(contentRect: NSMakeRect(0, 0, 1280, 720), styleMask: windowMask, backing: NSWindow.BackingStoreType.buffered, defer: true)\n        window.orderFrontRegardless()\n        window.title = \"Metal API Demo\"\n        window.setFrameOrigin(NSMakePoint(100, 100))\n        window.backgroundColor = NSColor.black\n        window.contentViewController = ViewController()\n        self.mainWindow = window\n        app.activate(ignoringOtherApps: true)\n    }\n\n    func applicationWillBecomeActive(_ notification: Notification) { }\n\n    func applicationShouldTerminateAfterLastWindowClosed(_ app: NSApplication) -> Bool { return true }\n\n    public class func makeMenu() -> NSMenu\n    {\n        let mainMenu = NSMenu()\n        let mainAppMenuItem = NSMenuItem(title: \"\\(ProcessInfo.processInfo.processName)\", action: nil, keyEquivalent: \"\")\n        mainMenu.addItem(mainAppMenuItem)\n        let appMenu = NSMenu()\n        mainAppMenuItem.submenu = appMenu\n        appMenu.addItem(withTitle: \"Quit \\(ProcessInfo.processInfo.processName)\", action: #selector(NSApplication.terminate(_:)),keyEquivalent: \"q\")\n        return mainMenu\n    }\n}\n\nclass ViewController: NSViewController\n{\n    var metalView: MTKView?\n    var metalRenderer: MetalRenderer?\n\n    override func loadView() -> ()\n    {\n        self.metalView = MTKView()\n        self.view = self.metalView!\n        self.metalView?.frame =  NSMakeRect(0, 0, 1280, 720)\n        self.metalView?.layer = CAMetalLayer()\n        self.metalRenderer = MetalRenderer()\n        self.metalView?.delegate = self.metalRenderer\n        self.metalView?.preferredFramesPerSecond = 60\n    }\n\n    override func viewDidLoad() -> ()\n    {\n        super.viewDidLoad()\n    }\n}\n\nclass MetalRenderer: NSObject, MTKViewDelegate\n{\n    var device: MTLDevice?\n    var positionBuffer: MTLBuffer?\n    var uvBuffer: MTLBuffer?\n    var renderPipeline: MTLRenderPipelineState?\n    var commandQueue: MTLCommandQueue?\n\n    let shaderSource: String =\n        \"using namespace metal;\\n\" +\n        \"struct Attribute\\n\" +\n        \"{\\n\" +\n            \"float4 position [[position]];\\n\" +\n            \"float2 uv;\\n\" +\n        \"};\\n\" +\n        \"vertex Attribute VSMain(constant float4 *position [[buffer(0)]], constant float2 *uv [[buffer(1)]], uint id [[vertex_id]])\\n\" +\n        \"{\\n\" +\n            \"Attribute attribute;\\n\" +\n            \"attribute.position = position[id];\\n\" +\n            \"attribute.uv = uv[id];\\n\" +\n            \"return attribute;\\n\" +\n        \"}\\n\" +\n        \"float apple(float2 p)\\n\" +\n        \"{\\n\" +\n            \"float A = length(p-float2(-.078,.02))-.52;\\n\" +\n            \"float B = length(p-float2(.118,.045))-.552;\\n\" +\n            \"float sides = max(A, B);\\n\" +\n            \"float C = length(p-float2(-.181,.108))-.245;\\n\" +\n            \"float D = length(p-float2(.178,.108))-.245;\\n\" +\n            \"float top = min(C, D);\\n\" +\n            \"float E = length(p-float2(-.153,-.29))-.115;\\n\" +\n            \"float F = length(p-float2(.176,-.3))-.107;\\n\" +\n            \"float bottom = min(E, F);\\n\" +\n            \"float d = mix(min(top, bottom),sides, smoothstep(.05, -.05, p.y-.188) * smoothstep(-.05,.01, p.y+.382));\\n\" +\n            \"float G = length(p-float2(.01, -.608))-.247;\\n\" +\n            \"float h = clamp( 0.5+0.5*(-G-d)/(-.03), 0., 1. );\\n\" +\n            \"d =  mix( -G, d, h ) - (-.03) * h * (1.0 - h);\\n\" +\n            \"float H = length(p-float2(.487, .06))-.222;\\n\" +\n            \"d = max(d, -H);\\n\" +\n            \"float I = length(p-float2(0,.417))-.113;\\n\" +\n            \"float J = length(p-float2(0,.17))-.163;\\n\" +\n            \"d = min(d, max(-I, J));\\n\" +\n            \"float K = length(p-float2(.207, .365))-.222;\\n\" +\n            \"float L = length(p-float2(-.02, .567))-.222;\\n\" +\n            \"return min(d, max(K, L));\\n\" +\n        \"}\\n\" +\n        \"fragment float4 PSMain(Attribute attribute [[stage_in]])\\n\" +\n        \"{\\n\" +\n            \"float2 uv = 2.0 * attribute.uv - 1.0;\\n\" +\n            \"float aspect = 0.56;\\n\" +\n            \"float scale = 1.5;\\n\" +\n            \"uv.y *= aspect;\\n\" +\n            \"float k = 1.0 - step(apple(scale * uv), 0.0);\\n\" +\n            \"return float4(k, k, k, 1.0);\\n\" +\n        \"}\\n\";\n\n    override init()\n    {\n        super.init()\n        self.device = MTLCreateSystemDefaultDevice()\n        let positions: [Float] = [-1.0, -1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, -1.0, 1.0, 0.0, 1.0, 1.0, -1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, -1.0, 1.0, 0.0, 1.0]\n        let texcoords: [Float] = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]\n        self.positionBuffer = self.device?.makeBuffer(bytes:positions,length:(MemoryLayout<Float>.stride * positions.count),options:MTLResourceOptions.storageModeShared)\n        self.uvBuffer = self.device?.makeBuffer(bytes:texcoords,length:(MemoryLayout<Float>.stride * texcoords.count),options:MTLResourceOptions.storageModeShared)\n        let metalLibrary = try! self.device?.makeLibrary(source:shaderSource, options:nil)\n        let vertexFunction = metalLibrary?.makeFunction(name: \"VSMain\")\n        let fragmentFunction = metalLibrary?.makeFunction(name: \"PSMain\")\n        let renderPipelineDescriptor = MTLRenderPipelineDescriptor()\n        renderPipelineDescriptor.vertexFunction = vertexFunction\n        renderPipelineDescriptor.fragmentFunction = fragmentFunction\n        renderPipelineDescriptor.colorAttachments[0].pixelFormat = MTLPixelFormat.bgra8Unorm\n        self.renderPipeline = try! self.device?.makeRenderPipelineState(descriptor: renderPipelineDescriptor)\n        self.commandQueue = self.device?.makeCommandQueue()\n    }\n\n    public func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) -> () { }\n\n    public func draw(in view: MTKView) -> ()\n    {\n        (view.layer as! CAMetalLayer).device = self.device\n        if let drawable = (view.layer as! CAMetalLayer).nextDrawable()\n        {\n            let frameBufferTexture = drawable.texture\n            let renderPassDescriptor = MTLRenderPassDescriptor.init()\n            renderPassDescriptor.colorAttachments[0].texture = frameBufferTexture\n            renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0, 0.0, 0.0, 1.0)\n            renderPassDescriptor.colorAttachments[0].storeAction = MTLStoreAction.store\n            renderPassDescriptor.colorAttachments[0].loadAction = MTLLoadAction.clear\n            let commandBuffer = self.commandQueue?.makeCommandBuffer()\n            let commandEncoder = commandBuffer?.makeRenderCommandEncoder(descriptor: renderPassDescriptor)\n            commandEncoder?.setRenderPipelineState(self.renderPipeline!)\n            commandEncoder?.setVertexBuffer(self.positionBuffer!, offset: 0, index: 0)\n            commandEncoder?.setVertexBuffer(self.uvBuffer!, offset: 0, index: 1)\n            commandEncoder?.drawPrimitives(type:MTLPrimitiveType.triangle, vertexStart:0, vertexCount:6, instanceCount:1)\n            commandEncoder?.endEncoding()\n            commandBuffer?.present(drawable)\n            commandBuffer?.commit()\n        }\n    }\n}\n\nlet app = NSApplication.shared\napp.setActivationPolicy(NSApplication.ActivationPolicy.regular)\napp.mainMenu = AppDelegate.makeMenu()\nprint(app.mainMenu?.items as Any)\nlet controller = AppDelegate()\napp.delegate = controller\napp.run()\n\n*/\n\n// apple SDF by Martijn Steinrucken aka BigWings/CountFrolic: https://www.shadertoy.com/view/tldGD7\nfloat apple(vec2 p) \n{      \n    float A = length(p-vec2(-.078,.02))-.52;\n    float B = length(p-vec2(.118,.045))-.552;\n    float sides = max(A, B);   \n    float C = length(p-vec2(-.181,.108))-.245;\n    float D = length(p-vec2(.178,.108))-.245;\n    float top = min(C, D); \n    float E = length(p-vec2(-.153,-.29))-.115;\n    float F = length(p-vec2(.176,-.3))-.107;\n    float bottom = min(E, F); \n    float d = mix(min(top, bottom),sides, smoothstep(.05, -.05, p.y-.188) * smoothstep(-.05,.01, p.y+.382));   \n    float G = length(p-vec2(.01, -.608))-.247;\n    float h = clamp( 0.5+0.5*(-G-d)/(-.03), 0., 1. );\n    d =  mix( -G, d, h ) - (-.03) * h * (1.0 - h);    \n    float H = length(p-vec2(.487, .06))-.222;\n    d = max(d, -H);   \n    float I = length(p-vec2(0,.417))-.113;\n    float J = length(p-vec2(0,.17))-.163;\n    d = min(d, max(-I, J));   \n    float K = length(p-vec2(.207, .365))-.222;\n    float L = length(p-vec2(-.02, .567))-.222;\n    d = min(d, max(K, L));  \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float k = 1.0 - step(apple(uv), 0.0);\n    fragColor = vec4(k, k, k, 1.0);\n}","name":"Image","description":"","type":"image"}]}