{"ver":"0.1","info":{"id":"mtsSWS","date":"1675308670","viewed":79,"name":"1/(1+z)+1/(1-z) radius","username":"stevejtrettel","description":"Tristan Lecture 3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["complexfunctions"],"hasliked":0,"parentid":"dlXXWM","parentname":"1/z radius of convergence"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//take in the fragCoord on the screen and output the desired complex number\n//z that you want to be shown at that point:\nvec2 toZ(vec2 frag){\n\n    //to (-1,1)x(1,1)\n    vec2 z = 2.*frag/iResolution.xy;\n    z -= vec2(1);\n    \n    //adjust by scale (zoom in/out as you please)\n    float scale = 4.;\n    z *= scale;\n    \n    //fix aspect ratio\n    z*= vec2(1,iResolution.y/iResolution.x);\n    \n    return z;\n}\n\n\nvec2 f(vec2 z, vec2 a){\n\n    //the talyor series for 1/z centered at \"a\"\n    //is (-1/a) sum ((z+a)/a)^n\n    \n    //the taylor series for 1/1+z centered at \"a\"\n    // is (-1/1+a) sum ((z+a)/(1+a))^n\n\n    int N=300;\n    \n    //we are doing domain coloring, switch the sign of a\n    //as we are \"subtracting instead of adding\" \n    //(precompose with the inverse of the isometry for the right action)\n    a=-a;\n    \n    //the second singularity\n     vec2 s = vec2(2,0);\n\n     vec2 w1 = vec2(0,0);\n     vec2 w2 = vec2(0,0);\n     \n     vec2 temp1 = vec2(1,0);\n     vec2 diff1 = cdiv(z+a,a);\n     \n     vec2 temp2 = vec2(1,0);\n     vec2 diff2 = cdiv(z+a,s+a);\n     \n     for(int i=0;i<N;i++){\n     \n         w1+=temp1;\n         temp1=cmult(temp1,diff1);\n         \n         w2+=temp2;\n         temp2=cmult(temp2,diff2);\n     }\n     \n     vec2 final1 = cdiv(-w1,a);\n     vec2 final2 = cdiv(-w2,s+a);\n     \n    return final1+final2;\n}\n\n\n//at a point w of the complex plane, what color should we make it?\n//this function colors the plane as a grid, with hue depending on angle\n// and regular grids along the xy directions\nvec3 gridColor(vec2 w){\n\n    float x = w.x;\n    float y = w.y;\n    float theta = atan(y,x);\n\n    \n    float grid1 = (1.-pow(abs(sin(3.14*x)*sin(1.*3.14*y)),0.1))/10.;\n    float grid2 = (1.-pow(abs(sin(5.*3.14*x)*sin(5.*3.14*y)),0.1))/25.;\n    float grid3 = (1.-pow(abs(sin(10.*3.14*x)*sin(10.*3.14*y)),0.1))/50.;\n    float grid = grid1+grid2+grid3;\n    grid *=4.;\n            \n    vec3 base = hsb2rgb(vec3(theta/6.28,0.5,0.8-grid));\n    base += vec3(0.1);\n             \n    return base + 2.*vec3(grid);\n             \n}\n\n\n//draw a circle of radius 0.1 around the point z=a.\nvec3 pointColor(vec2 z,vec2 a){\n        if(length(z-a)<0.1){\n        return vec3(0,1,0);\n        }\n        return vec3(0,0,0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //compute the complex number you want to draw at a given pixel\n    vec2 z = toZ(fragCoord);\n    //compute the complex number corresponding to your mouse's location\n    vec2 a = toZ(iMouse.xy);\n    \n    //get the result of applying the taylor series\n    vec2 w = f(z,a);\n    \n    //color the screen using this information:\n    vec3 col;\n    //color the center point of the circle where your mouse is\n    col += pointColor(z,a);\n    //color the plane based on the output w=f(z)\n    col += gridColor(w);\n    //if the output of the function is large (greater than 1000 in magnitude)\n    //just color black as the taylor series is diverging.\n    if(length(w)>1000.){\n        col=vec3(0,0,0);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex math! \n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\n\n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmult (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c) {\n  return cmult(cmult(a, b), c);\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmult(cmult(a, b), cmult(c, d));\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmult(cmult(a, b, c), cmult(d, e));\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmult(cmult(a, b, c), cmult(d, e, f));\n} \n\n\n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\n\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n    6.0)-3.0)-1.0,\n    0.0,\n    1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n","name":"Common","description":"","type":"common"}]}