{"ver":"0.1","info":{"id":"WdsfDf","date":"1589202808","viewed":420,"name":"Pathtraced Cornell box","username":"M_cgode","description":"A Cornell box rendered using pathtracing for achieving indirect diffuse global illumination","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","cornellbox","globalillumination","pathtrace","pathtracing","progressive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 hdrColor = texture(iChannel0, uv).xyz / float(iFrame);\n    \n    float gamma = 1.0;\n    float exposure = 1.0;\n    \n    // Exposure tone mapping\n    vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure);\n    \n    // Gamma correction \n    mapped = pow(mapped, vec3(1.0 / gamma));\n    \n    fragColor = vec4(mapped, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Ray getScreenRay(in vec2 uv)\n{\n    float vFov = 3.14 / 10.0;\n    float hFov = atan(iResolution.x / iResolution.y * tan(vFov));\n    \n    vec2 coord = 2.0 * uv - 1.0;\n    \n    float dv = atan(coord.y * tan(vFov));\n    float dh = atan(coord.x * tan(hFov));\n    \n    vec3 direction = vec3(sin(dh), sin(dv) * cos(dh), -cos(dh)*cos(dv));\n    return Ray(vec3(0,0,9), direction);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 previousColor = texture(iChannel0, uv);\n\n    Ray screenRay = getScreenRay(uv);\n    vec3 position;\n    vec3 normal;\n    Material mat;\n    \n    bool intersected = raytraceScene(screenRay, position, normal, mat);\n    \n    vec3 ambientLight = vec3(0.02);\n\n    // Output to screen\n    fragColor = vec4(vec3(0), 1.0);\n    if (intersected)  {\n        vec3 color;\n        if (mat.emissive) {\n            color = mat.albedo;\n        } else {\n            int seed = (iFrame+1) * int(fragCoord.x+1.0) * int(fragCoord.y+1.0);\n            color = getPhysicalLighting(mat, position, normal, screenRay, seed) + ambientLight;\n        }\n  \n    \tfragColor = vec4(color, 1.0);\n    }\n    \n    fragColor += previousColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n    \nstruct InfinitePlane {\n    vec3 normal;\n    vec3 origin;\n    bool unidirectionnal;\n};\n\nstruct Disk {\n    vec3 normal;\n    vec3 origin;\n    float radius;\n};\n    \nstruct Quad {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n    \nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metalness;\n    bool emissive;\n};\n    \n    \n/// Raytracing functions\n    \n    \nbool intersectsSphere(in Ray ray, in Sphere sphere, out float t, out vec3 position, out vec3 normal) \n{ \n    float t0, t1; // solutions for t if the ray intersects \n    float radius2 = sphere.radius * sphere.radius;\n    // geometric solution\n    vec3 L = sphere.center - ray.origin; \n    float tca = dot(L, ray.direction); \n    // if (tca < 0) return false;\n    float d2 = dot(L, L) - tca * tca; \n    if (d2 > sphere.radius * sphere.radius) return false; \n    float thc = sqrt(sphere.radius * sphere.radius - d2); \n    t0 = tca - thc; \n    t1 = tca + thc;  \n    if (t0 > t1) {\n       \tfloat tmp = t0;\n        t0 = t1;\n      \tt1 = tmp;\n    } \n \n    if (t0 < 0.0) { \n        t0 = t1; // if t0 is negative, let's use t1 instead \n        if (t0 < 0.0) return false; // both t0 and t1 are negative \n    } \n \n    t = t0; \n    \n    position = ray.origin + ray.direction * t;\n    normal = normalize(ray.origin + ray.direction * t - sphere.center);\n \n    return true; \n} \n    \n    \nbool intersectsInfinitePlane(in Ray ray, in InfinitePlane plane, out float t, out vec3 position, out vec3 normal)\n{\n\tfloat denom = dot(plane.normal, ray.direction);\n    if (denom == 0.0) return false;\n    t = dot(plane.normal, plane.origin - ray.origin) / denom;\n    \n    position = ray.origin + ray.direction * t;\n    \n    if (denom > 0.0) { \n        if (plane.unidirectionnal) {\n            return false;\n        } else {\n        \tnormal = -plane.normal;\n        }\n    } else {\n        normal = plane.normal;\n    }\n    \n    return t > 0.0;\n}\n\n\nbool intersectsDisk(in Ray ray, in Disk disk, out float t, out vec3 position, out vec3 normal)\n{\n\tbool result = intersectsInfinitePlane(ray, InfinitePlane(disk.normal, disk.origin, false), t, position, normal);\n    \n    if (result) return length(position - disk.origin) <= disk.radius;\n    return false;\n}\n\n\nbool intersectsQuad(in Ray ray, in Quad quad, out float t, out vec3 position, out vec3 normal)\n{\n    if (quad.a == quad.b || quad.b == quad.c || quad.c == quad.a) return false;\n    \n    vec3 v1 = quad.b - quad.a;\n    vec3 v2 = quad.c - quad.a;\n    if (quad.a == quad.b || quad.b == quad.c || dot(normalize(v1), normalize(v2)) == 1.0) return false;\n    vec3 quadNorm = normalize(cross(v1, v2));\n    \n\tbool result = intersectsInfinitePlane(ray, InfinitePlane(quadNorm, quad.a, false), t, position, normal);\n    \n    if (result) {\n        vec3 u1 = normalize(v1), u2 = normalize(v2);\n        vec3 o = cross(quadNorm, u1);\n        float a = dot(u1, v2) / length(v1), b = dot(o, v2) / length(o);\n        vec3 p = position - quad.a;\n        float A = dot(u1, p) / length(v1), B = dot(o, p) / length(o);\n        float l1 = A - B * a / b, l2 = B / b;\n        return l1 >= 0.0 && l1 <= 1.0 && l2 >= 0.0 && l2 <= 1.0;\n    }\n    return false;\n}\n\n\n// RNG code taken from https://www.shadertoy.com/view/tsf3Dn\n\nint MIN = -2147483648;\nint MAX = 2147483647;\n\nint xorshift(in int value) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(inout int seed) {\n    seed = xorshift(seed);\n    return seed;\n}\n\nfloat nextFloat(inout int seed) {\n    seed = xorshift(seed);\n    // FIXME: This should have been a seed mapped from MIN..MAX to 0..1 instead\n    return abs(fract(float(seed) / 3141.592653));\n}\n\nfloat nextFloat(inout int seed, in float max) {\n    return nextFloat(seed) * max;\n}\n\n\n/// Scene handling\n\n\n#define HEIGHT 2.0\n#define WIDTH 0.5\nQuad lightQuad = Quad(vec3(-WIDTH,HEIGHT,-WIDTH), vec3(WIDTH,HEIGHT,-WIDTH), vec3(-WIDTH,HEIGHT,WIDTH));\n\n#define INF_PLANES_NB 6\nInfinitePlane[INF_PLANES_NB] boxPlanes = InfinitePlane[INF_PLANES_NB](\n\tInfinitePlane(vec3(-1,0,0), vec3(2,0,0), true),\n    InfinitePlane(vec3(1,0,0), vec3(-2,0,0), true),\n    InfinitePlane(vec3(0,-1,0), vec3(0,2,0), true),\n    InfinitePlane(vec3(0,1,0), vec3(0,-2,0), true),\n    InfinitePlane(vec3(0,0,1), vec3(0,0,-2), true),\n    InfinitePlane(vec3(0,0,-1), vec3(0,0,2), true)\n);\n\n#define SPHERES_NB 2\nSphere[SPHERES_NB] spheres = Sphere[SPHERES_NB](\n    Sphere(vec3(-1, -1.2, -1), 0.8),\n    Sphere(vec3(1, -1.4, 1), 0.6)\n);\n\nMaterial[1 + INF_PLANES_NB + SPHERES_NB] materials = Material[](\n    Material(vec3(20.0), 0.0, 0.0, true),\n    Material(vec3(.12,.55,.15), 1.0, 0.0, false),\n    Material(vec3(.65,.05,.05), 1.0, 0.0, false),\n    Material(vec3(1.0), 1.0, 0.0, false),\n    Material(vec3(1.0), 1.0, 0.0, false),\n    Material(vec3(1.0), 1.0, 0.0, false),\n    Material(vec3(1.0), 1.0, 0.0, false),\n    Material(vec3(0.972, 0.960, 0.915), 0.15, 0.4, false),\n    Material(vec3(1.0), 1.0, 0.0, false)\n);\n\n\nbool raytraceScene(in Ray ray, out vec3 position, out vec3 normal, out Material mat)\n{\n    float t;\n    bool intersected = false;\n    \n    float tmpT; \n    vec3 tmpPos, tmpNorm;\n    \n    if (intersectsQuad(ray, lightQuad, tmpT, tmpPos, tmpNorm)) {\n        t = tmpT;\n        position = tmpPos;\n        normal = tmpNorm;\n        mat = materials[0];\n        intersected = true;\n    }\n    \n    for (int i = 0; i < INF_PLANES_NB; i++) {\n        if (intersectsInfinitePlane(ray, boxPlanes[i], tmpT, tmpPos, tmpNorm) && !(intersected && tmpT >= t)) {\n        \tt = tmpT;\n        \tposition = tmpPos;\n        \tnormal = tmpNorm;\n        \tmat = materials[i + 1];\n        \tintersected = true;\n    \t}\n    }\n    \n    if (max(max(abs(position.x), abs(position.y)), abs(position.z)) > 2.0 + 0.001) \n        return false;\n    \n    for (int i = 0; i < SPHERES_NB; i++) {\n        if (intersectsSphere(ray, spheres[i], tmpT, tmpPos, tmpNorm) && !(intersected && tmpT >= t)) {\n        \tt = tmpT;\n        \tposition = tmpPos;\n        \tnormal = tmpNorm;\n        \tmat = materials[i + INF_PLANES_NB + 1];\n        \tintersected = true;\n    \t}\n    }\n    \n    return intersected;\n}\n\n\nbool shadowHit(const in Ray ray) \n{\n    float _t;\n    vec3 _p, _n;\n    for (int i = 0; i < SPHERES_NB; i++) {\n        if (intersectsSphere(ray, spheres[i], _t, _p, _n)) return true;\n    }\n    return false;\n}\n\n\n/// PBR functions\n\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n\n/// Indirect diffuse functions\n\nint depth = 10;\n\n\nmat3 createCoordinateSystem(in vec3 n)\n{\n    vec3 b, t;\n    if (abs(n.x) > abs(n.y)) {\n        b = normalize(vec3(n.z, 0.0, -n.x));\n    } else {\n        b = normalize(vec3(0.0, n.z, -n.y));\n    }\n    t = cross(n, b);\n    return mat3(t,n,b);\n}\n\n\nvec3 randomSample(in mat3 tnb, inout int seed)\n{\n    float cosTheta = nextFloat(seed);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = nextFloat(seed) * 2.0 * PI;\n    vec3 smpl = vec3(sinTheta * cos(phi), cosTheta, sinTheta * sin(phi));\n    return tnb * smpl;\n}\n\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout int seed ) {\n  \tvec2 r = vec2(nextFloat(seed), nextFloat(seed));\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\n\n#define BIAS 0.001\nvec3 indirectDiffuseCast(in Ray ray, inout int seed)\n{\n    vec3 pos;\n    vec3 norm;\n    Material mat;\n    \n    //return vec3(nextFloat(seed));\n    \n    vec3 color = vec3(1.0);\n    vec3 emitted = vec3(0);\n    Ray traceRay = ray;\n    for (int i = 0; i < depth; i++)\n    {\n        bool intersected = raytraceScene(traceRay, pos, norm, mat);\n    \n    \tif (!intersected) return vec3(0);\n    \tif (mat.emissive) return emitted;// + mat.albedo * dot(norm, traceRay.direction);\n    \n    \tmat3 coordSys = createCoordinateSystem(norm);\n        int s = seed;\n    \tvec3 smpl = randomSample(coordSys, seed);\n    \tcolor *= mat.albedo ;\n        \n        vec3 pointInSource = vec3(nextFloat(seed), 0.0, nextFloat(seed)) * vec3(2.0*WIDTH,0,2.0*WIDTH) + vec3(-WIDTH,HEIGHT,-WIDTH);\n        vec3 L = pointInSource - pos;\n        float rr = dot(L, L);\n        L = normalize(L);\n\n        Ray shadowRay = Ray(pos + L * BIAS, L);\n        if (L.y > BIAS && dot(norm, L) > 0. && !shadowHit(shadowRay)) {\n\t        const float area = (WIDTH*WIDTH*4.0);\n            float weight = area * L.y * dot(norm, L) / (3.14 * rr);\n            emitted += color * materials[0].albedo * weight;\n        }\n        \n        traceRay = Ray(pos + smpl * BIAS, smpl);\n    }\n    \n    return emitted;\n}\n\n\nfloat calculateAttenuation(in vec3 lightPos, in vec3 fragPos)\n{\n    return 1.0;\n}\n\n\n#define PASSES 20\n\nvec3 getPhysicalLighting(in Material mat, in vec3 position, in vec3 normal, in Ray camRay, in int seed)\n{\n    vec3 v = normalize(camRay.origin - position);\n    \n    vec3 kS = vec3(0);\n    vec3 kD = vec3(1) - kS;\n    kD *= 1.0 - mat.metalness;\n    \n    vec3 indirectDiffuse = vec3(0); \n    for (int i = 0; i < PASSES; i++) {\n        indirectDiffuse += indirectDiffuseCast(camRay, seed);\n    }\n    indirectDiffuse /= float(PASSES);\n    \n    return indirectDiffuse * kD;\n}\n    \n","name":"Common","description":"","type":"common"}]}