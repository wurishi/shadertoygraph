{"ver":"0.1","info":{"id":"XttGDS","date":"1474210688","viewed":186,"name":"scene3d","username":"andrewww1","description":"mouse click to change orbit view pitch/yaw","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" \nfloat opS(float d1, float d2) {\n  return max(-d2,d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.y<d2.y) ? d1 : d2;\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opRotY(vec3 p,float a) {\n  float c=cos(a);\n  float s=sin(a);\n  mat3 m=mat3(vec3(c,0.0,s),vec3(0.0,1.0,0.0),vec3(-s,0.0,c));\n  return m*p;\n}\n\nvec2 distScene(vec3 p) {\n  vec2 rs=vec2(0.1,opS(sdBox(p-vec3(0.0,5.0,0.0),vec3(9.0)),\n                       sdBox(p-vec3(2.0,7.0,2.0),vec3(10.0))));\n\t\t\t\t\t   \n  rs=opU(rs,vec2(0.2,sdBox(opRotY(p-vec3(2.0,-1.0,-2.0),1.0), vec3(2.0))));\t\n  rs=opU(rs,vec2(0.3,sdBox(opRotY(p-vec3(-0.2,-1.0,3.0),0.5), vec3(2.0))));\t\t\n  rs=opU(rs,vec2(0.4,sdBox(opRotY(p-vec3(1.0,2.5,0.5),0.2), vec3(1.5))));\t\t\t\t   \n  rs=opU(rs,vec2(0.5,sdSphere(p-vec3(-6.0,cos(iTime)*2.0+0.5,5.0), 1.5)));\n\n  return rs;\n}\n\nvec3 calcNormal(vec3 p) {\n  float h = 0.0001;\n  vec3 n;\n  n.x=distScene(p+vec3(h,0.0,0.0)).y-distScene(p-vec3(h,0.0,0.0)).y;\n  n.y=distScene(p+vec3(0.0,h,0.0)).y-distScene(p-vec3(0.0,h,0.0)).y;\n  n.z=distScene(p+vec3(0.0,0.0,h)).y-distScene(p-vec3(0.0,0.0,h)).y;\n  n=normalize(n);\n  return n;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n  //from 'Enhanced Sphere Tracing' paper\n    \n  // o, d : ray origin, direction (normalized)\n  // t_min, t_max: minimum, maximum t values\n  // pixelRadius: radius of a pixel at t = 1\n  // forceHit: boolean enforcing to use the\n  // candidate_t value as result\n  \n  const float t_min=0.01;\n  const float t_max=1000.0;\n  //const float pixelRadius=0.0025;\n  \n  float id=0.0;\n  \n  //float omega = 1.2;\n  float t = t_min;\n  float candidate_error = 9999999999.0;\n  float candidate_t = t_min;\n  //float previousRadius = 0.0;\n  float stepLength = 0.0;\n  float functionSign = (distScene(ro).y<0.0)?-1.0:1.0;\n\n  for(int i=0;i<48;++i) {\n    vec3 p = ro + rd * t;\n    vec2 rs=distScene(p);\n\tid=rs.x;\n    float signedRadius = functionSign * rs.y;\n    float radius = abs(signedRadius);\n    //bool sorFail = (omega>1.0) && (radius + previousRadius) < stepLength;\n\n    //if(sorFail) {\n    //  stepLength -= omega * stepLength;\n    //  omega = 1.0;\n    //} else {\n    //  stepLength = signedRadius * omega;\n    //}\n    stepLength = signedRadius;\n\n    //previousRadius = radius;\n    float error = radius/t;\n\n    if(/*!sorFail &&*/ error < candidate_error) {\n      candidate_t = t;\n      candidate_error = error;\n    }\n\n    //if(!sorFail && error < pixelRadius || t > t_max) {\n    //  break;\n    //}\n\n    t += stepLength;\n  }\n\n  if(t > t_max || candidate_error > 1.0) { //(|| candidate_error > pixelRadius)&& !forceHit\n    return vec2(0.0,0.0);\n  }\n\n  return vec2(id,candidate_t);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  //shadertoy.com/view/4ssGzS\n  float step = 0.4;\n  float ao = 0.0;\n  float dist;\n  \n  for (float i=1.0;i<=4.0;i++) {\n    dist = step*i;\n    ao += max(0.0, (dist - distScene(p + n * dist).y) / dist);  \n  }\n  \n  return 1.0 - ao * 0.075;\n}\n\nvec3 calcMtrlCol(float id,vec3 p,vec3 n) {\n    vec3 col;\n  col=texture(iChannel0,vec2(id+0.494)).rgb;\n\n\n\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col=vec3(0.0);\n  vec2 rs=castRay(ro,rd);\n  float t = rs.y;\n\n  if(rs.x!=0.0) {\n    vec3 p = ro + t*rd;\n    vec3 n = calcNormal(p);\n    col=calcMtrlCol(rs.x,p,n);\n\tcol*=ambientOcclusion(p,n);\n      \n    //\n    vec3  r = normalize(reflect(rd,n));\n    vec3 ld = normalize(vec3(45.,30.,45.));\n    float d = max(dot(ld,n),0.);\n    float s = pow(max(dot(ld,r), 0.), 60.);\n    \n    if(castRay(p+ld*.01,ld).x != 0.) {\n       d = 0.12; s = 0.0; \n    }\n      \n    col = col*d+s;\n  }\n \n \n    \n  return vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n  float d=1.0/tan(fovy/2.0);\n  vec3 v=vec3(screen.x*aspect,screen.y,-d);\n  v=normalize(v);\n  return v;\n}\n\nmat3 orbitRot(float yaw,float pitch) {\n    vec2 s=vec2(sin(pitch),sin(yaw));\n    vec2 c=vec2(cos(pitch),cos(yaw));\n    return mat3(c.y,0.0,-s.y,s.y*s.x,c.x,c.y*s.x,s.y*c.x,-s.x,c.y*c.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 ms = iMouse.xy / iResolution.xy;\n  float aspect=iResolution.x/iResolution.y;\n  float fovy=0.7854;\n\n    vec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.25,0.9):ms;\n\n  float pitch=ms2.y*1.5-1.5;\n  float yaw=ms2.x*2.0-0.25;\n  mat3 viewRot=orbitRot(yaw,pitch);\n    \n\n  vec3 ro=viewRot*vec3(0.0,0.0,30.0)+vec3(0.0,2.0,0.0);\n  vec3 rd=viewRot*calcPrimaryRay(uv*2.0-1.0,fovy,aspect);\n          \n  vec3 c=vec3(uv,0.5+0.5*sin(iTime));\n  c=render(ro,rd);\n    \n  if(length((uv-ms)*vec2(aspect,1.0)) < 0.01) {\n    c=mix(c,vec3(1.0),0.2); \n  }\n    \n  fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}