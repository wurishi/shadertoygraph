{"ver":"0.1","info":{"id":"Md3BzX","date":"1526103005","viewed":313,"name":"KIFS + Global Illumination","username":"efairbanks","description":"This can probably be optimized, but global illumination and real diffuse surfaces are neat. Morphing kaleidoscopic fractals are fun.\n\nIncrease MAX_REFLECTIONS for more realistic lighting and SSAA for less graininess. Decrease to prevent GFX murder.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["globalillumination","kifs","realshadows","realdiffusion","realgoodmoodfood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_BG\t\t\t-1.\n#define MAT_LT\t\t\t0.\n#define MAT_RFL\t\t\t1.\n#define MARCH_MIN\t\t1.\n#define MARCH_MAX\t\t40.\n#define MAX_REFLECTIONS\t5.\n#define SSAA\t\t\t20.\nvec2 rand32(vec3 p){\n\treturn vec2(fract(sin(dot(p.xyz,vec3(12.345,34.567,23.456)))*3456.7891),\n                fract(sin(dot(p.zxy,vec3(23.456,45.678,56.789)))*2345.5678));\n}\nvec2 rand22(vec2 p){\n\treturn vec2(fract(sin(dot(p.xyx,vec3(12.345,34.567,23.456)))*3456.7891),\n                fract(sin(dot(p.yxy,vec3(23.456,45.678,56.789)))*2345.5678));\n}\nvec2 rot(vec2 p, vec2 around, float rad){\n  vec2 o = around;\n  vec2 r = p-around;\n  float angle = atan(r.y,r.x)+rad;\n  float mag = length(r);\n  return vec2(cos(angle),sin(angle))*mag+o;\n}\nvec2 _min(vec2 a, vec2 b){if(a.x>b.x) return b;return a;}\nvec2 _max(vec2 a, vec2 b){if(a.x<=b.x) return b;return a;}\nvec2 _sub(vec2 a, vec2 b){vec2 tmp = vec2(-a.x,a.y);if(tmp.x<=b.x) return b;return tmp;}\nvec2 _sphere(vec3 p, float s, float m){return vec2(length(p)-s,m);}\nvec2 _box(vec3 p, vec3 b, float m){vec3 d = abs(p) - b;return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), m);}\n// get the distance to the shapes\nfloat scalesin(float i, float a, float b){float x = sin(i)*0.5+0.5; return a*x+b*(1.-x);}\nvec2 map(vec3 p){\n    /*\n\tvec2 d = _sphere(p+vec3(sin(p.y*5.),0.,cos(p.y*5.))*.0,1.5,1.0999);\n    d = _min(d, _sphere(p+vec3(sin(iTime*1.7),0.,cos(iTime*1.7))*3.,.5,0.0999));\n    d = _min(d, vec2(-p.y+2.,1.5755));\n\t*/\n    \n    vec2 d;\n    \n    d = _sphere(p,2.,0.1300);\n    float time = iTime*.15;\n    \n    for(int i=0;i<10;i++){\n        p = abs(p);\n        p.zx = rot(p.zx,vec2(0.),3.145*scalesin(time*.11579,.1,.15));\n        p.zy = rot(p.zy,vec2(0.),3.145*scalesin(time*.78,.1,.3));\n        p-=scalesin(time,1.01,3.);\n    }\n\n    d = _min(d,_box(p,vec3(.9,10.,0.9),1.8376*0.+1.9789));\n    \n    return d;\n}\n// get the ray to shoot from the camera origin for each pixel coordinate\nvec3 lookRay(vec3 origin, vec3 target, vec2 p){\n    vec3 ray = normalize(target-origin);\n    vec3 right = normalize(cross(ray,normalize(vec3(0.,1.,0.))));\n    vec3 up = normalize(cross(ray,normalize(right)));\n    return normalize(ray + right*p.x + up*p.y);\n}\n// get surface normal\nvec3 gradient( in vec3 pos )\n{\n     vec2 e = vec2(1.0,-1.0)*.01;\n     return normalize( e.xyy*map( pos + e.xyy ).x +\n                       e.yyx*map( pos + e.yyx ).x +\n                       e.yxy*map( pos + e.yxy ).x +\n                       e.xxx*map( pos + e.xxx ).x);\n}\n// march along the camera ray until we miss/hit the shapes\nvec2 march(vec3 origin, vec3 ray){\n    float rayLength = MARCH_MIN;\n    float material = MAT_BG+.0678;\n    bool hit = false;\n    for(float i=0.;i<80.;i++){\n        vec2 m = map(origin+ray*rayLength);\n    \tfloat dist = m.x;\n        float mat = m.y;\n        rayLength += dist*.99;\n        if(rayLength>=MARCH_MAX) break;\n        if(dist<.01) {\n        \thit = true;\n            material = mat;\n            break;\n        }\n    }\n    if(hit==false) rayLength = MARCH_MAX;\n    return vec2(rayLength,material);\n}\n// light the scene\nvec3 light(vec3 origin, vec3 ray){\n\tvec3 ro = origin;\n    vec3 rd = ray;\n    vec3 col = vec3(0.);\n    float totalDistance = 0.;\n    float r = 1.;\n    float g = 1.;\n    float b = 1.;\n    for(float i=0.;i<MAX_REFLECTIONS;i++){\n        // march\n        vec2 result = march(ro,rd);\n        totalDistance += result.x;\n    \t// lighting conditionals\n        float matType = floor(result.y);\n        float matVal = fract(result.y);\n        // --- //\n        float diff = fract(floor(matVal*10.)*.1);\n        r *= fract(floor(matVal*100.)*.1)+.1;\n        g *= fract(floor(matVal*1000.)*.1)+.1;\n        b *= fract(floor(matVal*10000.)*.1)+.1;\n        // --- //\n        if(matType==MAT_BG){col+=vec3(scalesin((ro+rd*result.x).y*.1,0.35,0.45),0.4,0.4)*125.;break;}\n        if(matType==MAT_LT){col+=vec3(1.,1.,1.)*220.;break;}\n        // new origin and direction\n        ro=ro+rd*(result.x-0.02); // we have to sub some length so we don't hit immediately after re-casting\n        rd=gradient(ro);\n        // randomize gradient\n        vec3 up = normalize(cross(rd,vec3(0.,1.,0.)));\n        vec3 right = normalize(cross(rd,up));\n        up = normalize(cross(rd,right));\n        vec2 rand = rand32(ro)*2.-1.;\n        rand *= diff;\n        rd = normalize(rd + up*rand.y + right*rand.x);\n    }\n    return col*vec3(r,g,b)/pow(totalDistance,1.1);\n}\n// this gets called for every pixel on the screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // screen coords\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = uv*2.-1.;\n    p.x *= (iResolution.x/iResolution.y);\n    // camera\n    float time = iTime*.3;\n    vec3 camera = vec3(0.4,(sin(time*.33)-1.)*2.,-5.);\n    camera.xz = vec2(sin(time),cos(time))*20.;\n    //\n    vec3 col = vec3(0.);\n    vec3 ray = vec3(0.);\n    float iterations = 0.;\n    for(float i=0.;i<SSAA;i++){\n        vec2 rand=rand22(p+vec2(3.34*i*(fract(iTime*3.45)+1.23),3.65*i*(fract(iTime*1.23)+2.34)));\n        rand*=.005;\n        // ray\n        ray = lookRay(camera,vec3(0.),p+rand);\n        // light\n        col += light(camera,ray);\n        iterations++;\n    }\n    col = col/iterations;\n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}