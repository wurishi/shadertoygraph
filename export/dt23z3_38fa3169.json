{"ver":"0.1","info":{"id":"dt23z3","date":"1673867267","viewed":92,"name":"Gridness","username":"kabbitron","description":"Some grids that bleed into each other","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float onGrid(vec2 pt, vec2 ptGridCenter, float gridAngle, float gridScale)\n{\n    // Transform from world to grid\n    pt -= ptGridCenter;\n    pt *= rotate2d(-gridAngle);\n    pt /= gridScale;\n\n    vec2 grid = smoothstep(0.8, 0.9, 1.0 - abs(2.0 * fract(pt) - 1.0));\n    return max(grid.x, grid.y);\n}\n\nfloat onGridSqr(vec2 pt, vec2 ptGridCenter, float gridAngle, float gridScale)\n{\n    // Transform from world to grid\n    pt -= ptGridCenter;\n    pt *= rotate2d(-gridAngle);\n    pt /= gridScale;\n\n    return sqr(linearstep(0.85, 0.95, 1.0 - abs(2.0 * fract(pt.x) - 1.0)))\n        + sqr(linearstep(0.85, 0.95, 1.0 - abs(2.0 * fract(pt.y) - 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 in y, square units)\n    vec2 pt = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    // Normalized pixel coordinates (from -1 to 1 in x and y)\n    vec2 ptS = (2.0 * fragCoord - iResolution.xy) / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = hsv2rgb(vec3(iTime * 0.1 + sin(pt.x * 8.0) + sin(pt.y * 5.0), 1.0, 1.0));\n\n    // Add squared \"contains values\" for shapes\n    float inShape = 0.0;\n    inShape += onGridSqr(pt, vec2(0.5 * cos(iTime * 0.023), sin(iTime * 0.017)), iTime * 0.03, 0.3);\n    inShape += onGridSqr(pt, vec2(0.5 * cos(iTime * 0.013), sin(iTime * 0.027)), -iTime * 0.02, 0.4);\n    inShape += onGridSqr(pt, vec2(0.5 * cos(iTime * 0.033), sin(iTime * 0.025)), iTime * 0.01, 0.5);\n    // Make it linear again\n    inShape = sqrt(inShape);\n    // Clamp it to [0.5, 1.0] and scale that to [0, 1] to make edges bleed into each other\n    inShape = clamp((inShape - 0.5) / 0.5, 0.0, 1.0);\n    // Go from linear to a steeper transition\n    inShape = smoothstep(0.0, 1.0, inShape);\n    inShape = smoothstep(0.0, 1.0, inShape);\n    \n    col *= inShape;\n\n    // Fade out at the edges\n    col *= smoothstep(1.5, 0.8, length(ptS)); // round fade\n    col *= smoothstep(1.2, 0.7, max(abs(ptS.x), abs(ptS.y))); // rect fade\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat linearstep(float start, float end, float x)\n{\n    return clamp((x - start) / (end - start), 0.0, 1.0);\n}\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\n// https://gist.github.com/983/e170a24ae8eba2cd174f\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}","name":"Common","description":"","type":"common"}]}