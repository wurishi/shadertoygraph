{"ver":"0.1","info":{"id":"MXKSWW","date":"1719980626","viewed":862,"name":"VMF Diffuse BRDF Reference","username":"eugenedeon","description":"Reference implementation of VMF Diffuse BRDF (EGSR 2024) - with comparison to other diffuse models.\n\nDrag the mouse left/right to rotate the light.\nDrag the mouse up/down to adjust the roughness","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["shading","diffuse","orennayar"],"hasliked":0,"parentid":"X3BSDD","parentname":"Rough Diffuse BRDFs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference vMF Diffuse BRDF Implementation from EGSR 2024 paper:\n//   VMF Diffuse: A unified rough diffuse BRDF\n//   Eugene d'Eon and Andrea Weidlich\n//\n// Based on BRDF comparison shadertoy originally written by Chris Kulla 2024\n\n// define constants to refer to the models by name\n#define MODEL_LAMBERT                0  // basic Lambertian\n#define MODEL_OREN_NAYAR_QUAL        1  \n#define MODEL_OREN_NAYAR_FULL        2\n#define MODEL_vMF_DIFFUSE            8\n\n// Pick the model to display on the top/bottom halves of the sphere here\n#define MODEL_TOP     MODEL_vMF_DIFFUSE\n#define MODEL_BOT     MODEL_OREN_NAYAR_FULL\n\n\n#define VIEW_MODE 0 // 0: eval with rotating directional light\n                    // 1: furnace test (cosine sampling)\n\n\nvec3 BRDF(vec3 N, vec3 V, vec3 L, vec3 Albedo, float Roughness, int Model)\n{\n    float NdotV = dot(N, V);\n    float NdotL = dot(N, L);\n    if (NdotL <= 0.0) return vec3(0.0); // pointing away from light\n\n    if (Model == MODEL_LAMBERT)\n    {\n        // Lambert\n        return Albedo * NdotL / PI;\n    }\n    if (Model == MODEL_OREN_NAYAR_QUAL || Model == MODEL_OREN_NAYAR_FULL)\n    {\n        // https://github.com/mitsuba-renderer/mitsuba/blob/master/src/bsdfs/roughdiffuse.cpp\n        float r = clamp(Roughness, 0.0, .9999);\n        float alpha = -log(1.0-sqrt(r));\n        float sigma = alpha / sqrt(2.0);\n        float sigma2 = sigma * sigma;\n\n        mat3 TangentToWorld = basis(N);\n        // left-multiply -- transform world vectors to tangent space (Z up)\n        vec3 wi = V * TangentToWorld;\n        vec3 wo = L * TangentToWorld;\n\n        float cosThetaI = wi.z, sinThetaI = sqrt(1.0 - cosThetaI * cosThetaI);\n        float cosThetaO = wo.z, sinThetaO = sqrt(1.0 - cosThetaO * cosThetaO);\n\n        float cosPhiDiff = 0.0;\n        if (sinThetaI > 0.0 && sinThetaO > 0.0) {\n            /* Compute cos(phiO-phiI) using the half-angle formulae */\n            float sinPhiI = clamp(wi.y / sinThetaI, -1.0, 1.0),\n                  cosPhiI = clamp(wi.x / sinThetaI, -1.0, 1.0),\n                  sinPhiO = clamp(wo.y / sinThetaO, -1.0, 1.0),\n                  cosPhiO = clamp(wo.x / sinThetaO, -1.0, 1.0);\n            cosPhiDiff = cosPhiI * cosPhiO + sinPhiI * sinPhiO;\n        }\n        if (Model == MODEL_OREN_NAYAR_QUAL)\n        {\n            // Qualitative model / Fast approximation\n            float A = 1.0f - 0.5f * sigma2 / (sigma2 + 0.33f),\n                  B = 0.45f * sigma2 / (sigma2 + 0.09f),\n                  sinAlpha, tanBeta;\n\n            if (cosThetaI > cosThetaO) {\n                sinAlpha = sinThetaO;\n                tanBeta = sinThetaI / cosThetaI;\n            } else {\n                sinAlpha = sinThetaI;\n                tanBeta = sinThetaO / cosThetaO;\n            }\n            return Albedo * (cosThetaO / PI) * (A + B * max(cosPhiDiff, 0.0) * sinAlpha * tanBeta);\n       }\n       else\n       {\n            // Full model\n            float thetaI = safeacos(wi.z),\n                  thetaO = safeacos(wo.z),\n                  alpha = max(thetaI, thetaO),\n                  beta  = min(thetaI, thetaO);\n\n            float sinAlpha, sinBeta, tanBeta;\n            if (wi.z > wo.z) {\n                sinAlpha = sinThetaO;\n                sinBeta = sinThetaI;\n                tanBeta = sinThetaI / cosThetaI;\n            } else {\n                sinAlpha = sinThetaI;\n                sinBeta = sinThetaO;\n                tanBeta = sinThetaO / cosThetaO;\n            }\n            float tmp = sigma2 / (sigma2 + 0.09f),\n                  tmp2 = (4.0 / (PI * PI)) * alpha * beta,\n                  tmp3 = 2.0 * beta / PI;\n\n            float C1 = 1.0f - 0.5f * sigma2 / (sigma2 + 0.33f),\n                  C2 = 0.45f * tmp,\n                  C3 = 0.125f * tmp * tmp2 * tmp2,\n                  C4 = 0.17f * sigma2 / (sigma2 + 0.13f);\n\n            if (cosPhiDiff > 0.0)\n                C2 *= sinAlpha;\n            else\n                C2 *= sinAlpha - tmp3*tmp3*tmp3;\n\n            /* Compute tan(0.5 * (alpha+beta)) using the half-angle formulae */\n            float tanHalf = (sinAlpha + sinBeta) / (sqrt(1.0f - sinAlpha * sinAlpha) + sqrt(1.0f - sinBeta  * sinBeta));\n\n            vec3 rho = Albedo,\n                 snglScat = rho * (C1 + cosPhiDiff * C2 * tanBeta + (1.0f - abs(cosPhiDiff)) * C3 * tanHalf),\n                 dblScat  = rho * rho * (C4 * (1.0f - cosPhiDiff*tmp3*tmp3));\n\n            return  (snglScat + dblScat) * (cosThetaO / PI);\n       }\n    }\n    if (Model == MODEL_vMF_DIFFUSE)\n    {\n        // VMF Diffuse BRDF (EGSR 2024)\n\n        float uo = NdotL;\n        float ui = NdotV;\n\n        mat3 TangentToWorld = basis(N);\n        // left-multiply -- transform world vectors to tangent space (Z up)\n        vec3 wi = V * TangentToWorld;\n        vec3 wo = L * TangentToWorld;\n\n        float cosThetaI = wi.z, sinThetaI = sqrt(1.0 - cosThetaI * cosThetaI);\n        float cosThetaO = wo.z, sinThetaO = sqrt(1.0 - cosThetaO * cosThetaO);\n\n        float cosPhiDiff = 0.0;\n        if (sinThetaI > 0.0 && sinThetaO > 0.0) {\n            /* Compute cos(phiO-phiI) using the half-angle formulae */\n            float sinPhiI = clamp(wi.y / sinThetaI, -1.0, 1.0),\n                  cosPhiI = clamp(wi.x / sinThetaI, -1.0, 1.0),\n                  sinPhiO = clamp(wo.y / sinThetaO, -1.0, 1.0),\n                  cosPhiO = clamp(wo.x / sinThetaO, -1.0, 1.0);\n            cosPhiDiff = cosPhiI * cosPhiO + sinPhiI * sinPhiO;\n        }\n        float phi = safeacos(cosPhiDiff);\n\n        float r = clamp(Roughness, 0.0, .9999);\n\n        return NdotL * vMFdiffuseBRDF(ui, uo, phi, r, Albedo); // higher-order bounces\n     }\n     return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float LightAngle = PI * iMouse.x / iResolution.x;\n    float Roughness = iMouse.y / iResolution.y;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv = 2.0 * uv - vec2(aspect, 1.0);\n\n#if VIEW_MODE == 0\n    // black background\n    vec3 col = vec3(0.0);\n#elif VIEW_MODE == 1\n    // grey background\n    vec3 col = vec3(0.5);\n#endif\n\n    float r = dot(uv, uv);\n    if (r < 1.0)\n    {\n        float z = sqrt(1.0 - dot(uv, uv));\n        vec3 N = vec3(uv, z);\n        vec3 V = vec3(0.0, 0.0, 1.0); // ortho camera\n        \n        int Model = uv.y >= 0.0 ? MODEL_TOP : MODEL_BOT;        \n#if VIEW_MODE == 0\n        // simple BRDF evaluation\n        vec3 Albedo = vec3(0.8, 0.4, 0.2);\n        float LightIntensity = 3.0;\n        vec3 L = vec3(sin(LightAngle), 0.0, cos(LightAngle));\n        col = BRDF(N, V, L, Albedo, Roughness, Model) * LightIntensity;\n#elif VIEW_MODE == 1\n        vec3 Albedo = vec3(1.0);\n        float Ns = 16.;\n        vec3 Average = vec3(0.0);\n        // stratified sampling\n        vec3 jitter = rand(uvec3(fragCoord, iFrame));\n        for (float dy = 0.; dy < Ns; dy++)\n        for (float dx = 0.; dx < Ns; dx++) {\n            float rx = (dx + jitter.x) / Ns;\n            float ry = (dy + jitter.y) / Ns;\n            float a = 1.0 - 2.0 * rx;\n            float b = sqrt(1.0 - a * a);\n            float phi = 2.0 * PI * ry;            \n            vec3 L = normalize(N + vec3(b * cos(phi), b * sin(phi), a));\n            float Pdf = max(dot(L, N), 0.0) / PI;\n            Average += col * BRDF(N, V, L, Albedo, Roughness, Model) / Pdf;\n        }\n        col = Average / (Ns * Ns);\n#endif\n    }\n    \n    // tone mapping\n\n    // Output to screen\n    fragColor = vec4(tonemap(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/////// utils\n\n#define PI 3.14159265358979323846264338327950288\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\nvec3 tonemap(vec3 c)\n{\n    // http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    vec3 x = max(vec3(0.0),c-vec3(0.004));\n    return (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nmat3 basis(vec3 n) {\n    // https://jcgt.org/published/0006/01/01/\n    float s = n.z >= 0.0 ? 1.0 : -1.0;\n    float a = -1.0 / (s + n.z);\n    float b = n.x * n.y * a;\n    vec3 u = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);\n    vec3 v = vec3(b, s + n.y * n.y * a, -n.y);\n    return mat3(u, v, n);\n}\n\nuvec3 pcg3d(uvec3 v) {\n    // http://www.jcgt.org/published/0009/03/02/\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nvec3 rand(uvec3 seed)\n{\n    return vec3(pcg3d(seed) >> 8) / float(1 << 24);\n}\n\nfloat sqr(float x) { return x * x; }\nvec3  sqr(vec3  x) { return x * x; }\n\n\n// copied from https://www.shadertoy.com/view/7dXXDN\n#define P  ( sqrt(3.14159265359)/2. )\n\nfloat erf(float x) {                        // very good approx https://en.wikipedia.org/wiki/Error_function\n    float e = exp(-x*x);                    // ( BÃ¼rmann series )\n    return sign(x)/P * sqrt( 1. - e ) * ( P + 31./200.*e - 341./8000. *e*e );\n}\n\n// -------------------------------\n// VMF DIFFUSE BRDF IMPLEMENTATION\n// -------------------------------\n\nfloat Coth(float x)\n{\n    return (exp(-x) + exp(x))/(-exp(-x) + exp(x));\n}\n\nfloat Sinh(float x)\n{\n    return -0.5*1.0/exp(x) + exp(x)/2.;\n}\n\n// cross section for the Beckmann NDF with roughness m and direction cosine u\nfloat sigmaBeckmannExpanded(float u, float m)\n{\n    if(0.0 == m) \n        return (u + abs(u))/2.;\n\n    float m2 = m * m;\n\n    if(1.0 == u)\n        return 1.0 - 0.5 * m2;\n        \n    float expansionTerm = -0.25 * m2 * (u + abs(u)); // accurate approximation for m < 0.25 that avoids numerical issues\n    \n    float u2 = u * u;\n    return ((exp(u2/(m2*(-1.0 + u2)))*m*sqrt(1.0 - u2))/sqrt(PI) + \n     u*(1.0 + erf(u/(m*sqrt(1.0 - u2)))))/2. + expansionTerm;\n}\n\n// vmf sigma (cross section)\nfloat sigmaVMF(float u, float m)\n{\n    if(m < 0.25)\n        return sigmaBeckmannExpanded(u, m);\n        \n    float m2 = m * m;\n    float m4 = m2 * m2;\n    float m8 = m4 * m4;\n\n    float u2 = u * u;\n    float u4 = u2 * u2;\n    float u6 = u2 * u4;\n    float u8 = u4 * u4;\n    float u10 = u6 * u4;\n    float u12 = u6 * u6;\n\n    float coth2m2 = Coth(2./m2);\n    float sinh2m2 = Sinh(2./m2);\n        \n    if(m > 0.9)\n        return 0.25 - 0.25*u*(m2 - 2.*coth2m2) + 0.0390625*(-1. + 3.*u2)*(4. + 3.*m4 - 6.*m2*coth2m2);\n        \n    return 0.25 - 0.25*u*(m2 - 2.*coth2m2) + 0.0390625*(-1. + 3.*u2)*(4. + 3.*m4 - \n      6.*m2*coth2m2) - 0.000732421875*(3. - 30.*u2 + 35.*u4)*(16. + 180.*m4 + 105.*m8 - \n      10.*m2*(8. + 21.*m4)*coth2m2) + 0.000049591064453125*(-5. + 105.*u2 - 315.*u4 + 231.*u6)*\n      (64. + 105.*m4*(32. + 180.*m4 + 99.*m8) - 42.*m2*(16. + 240.*m4 + 495.*m8)*coth2m2) + \n      (1.0132789611816406e-6*(35. - 1260.*u2 + 6930.*u4 - 12012.*u6 + 6435.*u8)*(1. + coth2m2)*\n      (-256. - 315.*m4*(128. + 33.*m4*(80. + 364.*m4 + 195.*m8)) + 18.*m2*(256. + 385.*m4*\n      (32. + 312.*m4 + 585.*m8))*coth2m2)*sinh2m2)/exp(2./m2) - (9.12696123123169e-8*(-63. + 3465.*u2 \n      - 30030.*u4 + 90090.*u6 - 109395.*u8 + 46189.*u10)*(1. + coth2m2)*(-1024. - \n      495.*m4*(768. + 91.*m4*(448. + 15.*m4*(448. + 1836.*m4 + 969.*m8))) + 110.*m2*(256. + 117.*m4*\n      (256. + 21.*m4*(336. + 85.*m4*(32. + 57.*m4))))*coth2m2)*sinh2m2)/exp(2./m2)\n      + (4.3655745685100555e-9*(231. - 18018.*u2 + 225225.*u4 - 1.02102e6*u6 + 2.078505e6*u8 \n      - 1.939938e6*u10 + 676039.*u12)*(1. + coth2m2)*(-4096. - 3003.*m4*(1024. + \n      45.*m4*(2560. + 51.*m4*(1792. + 285.*m4*(80. + 308.*m4 + 161.*m8)))) + 78.*m2*(2048. + 385.*m4*\n      (1280. + 153.*m4*(512. + 57.*m4*(192. + 35.*m4*(40. + 69.*m4)))))*coth2m2)*sinh2m2)/exp(2./m2);\n}\n\nvec3 Erf(vec3 c)\n{\n    return vec3(erf(c.x), erf(c.y), erf(c.z));\n}\n\nvec3 nonNegative(vec3 c)\n{\n    return vec3(max(0.0, c.x), max(0.0, c.y), max(0.0, c.z));\n}\n\nvec3 fm(float ui, float uo, float r, vec3 c)\n{\n    vec3 C = sqrt(1.0 - c);\n    vec3 Ck = (1.0 - 0.5441615108674713*C - 0.45302863761693374*(1.0 - c))/(1.0 + 1.4293127703064865*C);\n    vec3 Ca = c/pow(1.0075 + 1.16942*C,atan((0.0225272 + (-0.264641 + r)*r)*Erf(C)));\n    return nonNegative(0.384016*(-0.341969 + Ca)*Ca*Ck*(-0.0578978/(0.287663 + ui*uo) + abs(-0.0898863 + tanh(r))));\n}\n\n\nvec3 vMFdiffuseBRDF(float ui, float uo, float phi, float r, vec3 c)\n{\n    if(0.0 == r) return c / PI;\n    \n    float m = -log(1.0-sqrt(r));\n    float sigmai = sigmaVMF(ui,m);\n    float sigmao = sigmaVMF(uo,m);\n    float sigmano = sigmaVMF(-uo,m);\n    float sigio = sigmai * sigmao;\n    float sigdenom = uo * sigmai + ui * sigmano;\n\n    float r2 = r * r;\n    float r25 = r2 * sqrt(r);\n    float r3 = r * r2;\n    float r4 = r2 * r2;\n    float r45 = r4 * sqrt(r);\n    float r5 = r3 * r2;\n\n    float ui2 = ui * ui;\n    float uo2 = uo * uo;\n    float sqrtuiuo = sqrt((1.0 - ui2) * (1.0 - uo2));\n\n    float C100 = 1.0 + (-0.1 * r + 0.84 * r4) / (1.0 + 9.0 * r3);\n    float C101 = (0.0173 * r + 20.4 * r2 - 9.47 * r3)/(1.0 + 7.46 * r);\n    float C102 = (-0.927 * r + 2.37 * r2)/(1.24 + r2);\n    float C103 = (-0.11 * r - 1.54 * r2)/(1.0 - 1.05 * r + 7.1 * r2);\n    float f10 =  ((C100 + C101 * ui * uo + C102 * ui2 * uo2 + C103 * (ui2 + uo2)) * sigio) / sigdenom;\n\n    float C110 = (0.54*r - 0.182*r3)/(1. + 1.32*r2);\n    float C111 = (-0.097*r + 0.62*r2 - 0.375*r3)/(1. + 0.4*r3);\n    float C112 = 0.283 + 0.862*r - 0.681*r2;\n    float f11 = (sqrtuiuo * (C110 + C111 * ui * uo)) * pow(sigio, C112) / sigdenom;\n\n    float C120 = (2.25*r + 5.1*r2)/(1.0 + 9.8*r + 32.4*r2);\n    float C121 = (-4.32*r + 6.0*r3)/(1.0 + 9.7*r + 287.0*r3);\n    float f12 = ((1.0 - ui2) * (1.0 - uo2) * (C120 + C121 * uo) * (C120 + C121 * ui))/(ui + uo);\n\n    float C200 = (0.00056*r + 0.226*r2)/(1.0 + 7.07*r2);\n    float C201 = (-0.268*r + 4.57*r2 - 12.04*r3)/(1.0 + 36.7*r3);\n    float C202 = (0.418*r + 2.52*r2 - 0.97*r3)/(1.0 + 10.0*r2);\n    float C203 = (0.068*r - 2.25*r2 + 2.65*r3)/(1.0 + 21.4*r3);\n    float C204 = (0.05*r - 4.22*r3)/(1.0 + 17.6*r2 + 43.1*r3);\n    float f20 = (C200 + C201 * ui * uo + C203*ui2*uo2 + C202*(ui + uo) + C204*(ui2 + uo2))/(ui + uo);\n\n    float C210 = (-0.049*r - 0.027*r3)/(1.0 + 3.36*r2);\n    float C211 = (2.77*r2 - 8.332*r25 + 6.073*r3)/(1.0 + 50.0*r4);\n    float C212 = (-0.431*r2 - 0.295*r3)/(1.0 + 23.9*r3);\n    float f21 = (sqrtuiuo * (C210 + C211*ui*uo + C212*(ui + uo)))/(ui + uo);\n\n    float C300 = (-0.083*r3 + 0.262*r4)/(1.0 - 1.9*r2 + 38.6*r4);\n    float C301 = (-0.627*r2 + 4.95*r25 - 2.44*r3)/(1.0 + 31.5*r4);\n    float C302 = (0.33*r2 + 0.31*r25 + 1.4*r3)/(1.0 + 20.0*r3);\n    float C303 = (-0.74*r2 + 1.77*r25 - 4.06*r3)/(1.0 + 215.0*r5);\n    float C304 = (-1.026*r3)/(1.0 + 5.81*r2 + 13.2*r3);\n    float f30 = (C300 + C301*ui*uo + C303*ui2*uo2 + C302*(ui + uo) + C304*(ui2 + uo2))/(ui + uo);\n\n    float C310 = (0.028*r2 - 0.0132*r3)/(1.0 + 7.46*r2 - 3.315*r4);\n    float C311 = (-0.134*r2 + 0.162*r25 + 0.302*r3)/(1.0 + 57.5*r45);\n    float C312 = (-0.119*r2 + 0.5*r25 - 0.207*r3)/(1.0 + 18.7*r3);\n    float f31 =  (sqrtuiuo * (C310 + C311*ui*uo + C312*(ui + uo)))/(ui + uo);\n\n    return (1.0/PI) * (\n        c *         max(0.0, f10 + f11 * cos(phi) * 2. + f12 * cos(2.0 * phi) * 2.) +\n        c * c *     max(0.0, f20 + f21 * cos(phi) * 2.) +\n        c * c * c * max(0.0, f30 + f31 * cos(phi) * 2.)\n        ) + fm(ui, uo, r, c);\n}","name":"Common","description":"","type":"common"}]}