{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float tearAmount(float y, float time)\n{\n    time *= 0.1;\n    y *= 0.1;\n    float a = texture(iChannel1, vec2(fract(time), y)).x;\n    y *= 0.1;\n    float b = texture(iChannel1, vec2(fract(time), y)).x;\n    float dist = mix(a, b, 0.875);\n    dist = dist * 2.0 - 1.0;\n    dist = pow(abs(dist), 3.0) * sign(dist);\n    return dist;\n}\n\nfloat smoothTearAmount(float y, float time, float timeRange)\n{\n    const int timeSamples = 4;\n    float dist = tearAmount(y, time) * 1.0;\n    timeRange *= 0.5 / float(timeSamples);\n    for (int i = 1; i <= timeSamples; ++i) {\n        dist += tearAmount(y, time + float(i) * timeRange);\n        dist += tearAmount(y, time - float(i) * timeRange);\n    }\n    return dist / float(1 + 2 * timeSamples);\n}\n\nvec3 spectrum_offset(float t)\n{\n    float t0 = 3.0 * t - 1.5;\n\treturn clamp( vec3( -t0, 1.0-abs(t0), t0), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float dist = smoothTearAmount(uv.y, iTime, 1.5 / 60.0);\n    dist *= 3.0;\n\n    uv.x += texture(iChannel1, vec2(iTime * 0.1, uv.yy)).x * 0.01 * pow(abs(dist), 3.0) * sign(dist);\n\n\tvec3 c = vec3(0.0);\n\tvec3 fs = vec3(0.0);\n#define FILTER_TAPS 8\n\tfor (int i = 0; i < FILTER_TAPS; ++i) {\n\t\tfloat t = float(i) / float(FILTER_TAPS);\n        vec3 f = spectrum_offset(t);\n\t\tc += texture(iChannel0, uv + vec2((dist * 60.0) / iResolution.x, 0.0) * vec2(t)).rgb * f;\n\t\tfs += f;\n\t}\n\tfragColor = vec4(c / fs, 1.0);\n\n#if 1\n    vec2 noise_uv = vec2(fragCoord.xy / iChannelResolution[1].xy + fract(iTime * vec2(23.324, 30.234345)));\n    noise_uv /= 1.5; // \"blur\" the noise a bit\n    float noise = abs(dist) / 5.0;\n    noise = 1.0 / 20.0 + min(noise, 1.0);\n    fragColor.rgb += (texture(iChannel1, noise_uv).r - 0.5) * noise;\n\n#endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mss3R7","date":"1423482011","viewed":179,"name":"chromatic tearing","username":"kusma","description":"test some chromatic tearing for some fake video-glitching","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["glitch"],"hasliked":0,"parentid":"","parentname":""}}