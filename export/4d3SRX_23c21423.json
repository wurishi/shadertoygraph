{"ver":"0.1","info":{"id":"4d3SRX","date":"1460523966","viewed":2011,"name":"2D Fluid Flow Map","username":"JohnSietsma","description":"Simple 2D fluid sim to create a flow map.\nFluid sim mainly from: https://www.shadertoy.com/view/ldd3WS and http://http.developer.nvidia.com/GPUGems/gpugems_ch38.html.\nCombined with a flow map from here: http://johnsietsma.com/2015/12/01/flow-maps/\n","likes":19,"published":1,"flags":32,"usePreview":1,"tags":["fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VelocityField iChannel0\n#define DivergenceField iChannel1\n#define PressureField iChannel2\n\n#define DiffuseTexture iChannel3\n\n#define DisplayField VelocityField\n//#define DisplayField DivergenceField\n//#define DisplayField PressureField\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 flowDirection = texture(DisplayField,uv).xy * -0.002;\n    \n\n    fragColor = vec4( flowDirection, 0.0, 1.0 );\n    \n    if( fragColor.z == 0.0 ) {\n        const float cycleTime = 10.0;\n        const float flowSpeed = 0.5;\n\n        // Use two cycles, offset by a half so we can blend between them\n        float t1 = iTime / cycleTime;\n        float t2 = t1 + 0.5;\n        float cycleTime1 = t1 - floor(t1);\n        float cycleTime2 = t2 - floor(t2);\n        vec2 flowDirection1 = flowDirection * cycleTime1 * flowSpeed;\n        vec2 flowDirection2 = flowDirection * cycleTime2 * flowSpeed;\n        vec2 uv1 = uv + flowDirection1;\n        vec2 uv2 = uv + flowDirection2;\n        vec4 color1 = texture( DiffuseTexture, uv1 );\n        vec4 color2 = texture( DiffuseTexture, uv2 );\n\n        // Ping pong between the two flows, showing the least distorted and allowing uv resets on both.\n        fragColor = mix( color1, color2, abs(cycleTime1-0.5)*2.0 );\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Advection + Force\n\n#define VelocityField iChannel0\n\nconst float ForceStrength = 100.0;\nconst vec2 ForcePos = vec2(0.2, 0.5);\nconst float ForceRadius = 0.15;\n\nconst vec2 ObstaclePos = vec2(0.5,0.5);\nconst float ObstacleRadius = 0.1;\n\n\nvec2 uv;\nvec2 texelSize;\nvec2 fragCoord;\n\nvec2 calcForce()\n{\n    float forceDist = distance(uv, ForcePos);\n    float forceValue = (1.0-step(ForceRadius,forceDist)) * ForceStrength;\n    return vec2(forceValue, 0.0) * iTimeDelta;\n}\n\nvec2 calcAdvection()\n{\n    vec2 currVel = texture(VelocityField,uv).xy;\n    vec2 backPos = uv - currVel * texelSize * iTimeDelta;\n    return texture(VelocityField,backPos).xy;\n}\n\nvec2 clampBorder( vec2 value, float borderSize )\n{\n    // Clamp value at borders to zero.\n    if( fragCoord.x>iResolution.x ||\n      \tfragCoord.y>iResolution.y ||\n      \tfragCoord.x<0.0           ||\n        fragCoord.y<0.0 )\n    {\n        return vec2(0.0, 0.0);\n    }\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 _fragCoord )\n{\n    fragCoord = _fragCoord;\n    uv = fragCoord.xy / iResolution.xy;  \n    texelSize = vec2(1.0) / iResolution.xy;\n    \n    fragColor = vec4(0,0,99.0,1.0);\n    vec2 movingObstaclePosition = vec2(ObstaclePos.x, ObstaclePos.y+sin(iTime*0.2)*0.2);\n    if( distance(uv, movingObstaclePosition) > ObstacleRadius ) {\n    \tvec2 newVel = calcAdvection() + calcForce();\n    \tnewVel = clampBorder( newVel, 1.0 );\n    \tfragColor = vec4(newVel, 0.0, 1.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Divergence\n\n\n#define VelocityField iChannel0\n\nvec2 uv;\nvec2 texelSize;\n\nfloat calcDivergence()\n{\n    const float rHalfGridScale = 0.5; // 0.5/gridScale\n    vec2 xOffset = vec2(texelSize.x,0);\n    vec2 yOffset = vec2(0,texelSize.y);\n    \n    float x0 = texture(VelocityField,uv-xOffset).x;\n    float x1 = texture(VelocityField,uv+xOffset).x;\n    float y0 = texture(VelocityField,uv-yOffset).y;\n    float y1 = texture(VelocityField,uv+yOffset).y;\n    \n    return rHalfGridScale * ((x1-x0) + (y1-y0));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy / iResolution.xy;\n    texelSize = vec2(1.0) / iResolution.xy;\n    \n    fragColor = vec4( calcDivergence(), 0.0, 0.0, 1.0 );\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Pressure\n\n#define VelocityField iChannel0\n#define DivergenceField iChannel1\n#define PressureField iChannel2\n\n\nvec2 uv;\nvec2 texelSize;\nvec2 fragCoord;\n\nbool isBorder()\n{\n    if( fragCoord.x>iResolution.x ||\n      \tfragCoord.y>iResolution.y ||\n      \tfragCoord.x<0.0             ||\n        fragCoord.y<0.0 )\n    {\n        return true;\n    }\n    return false;\n}\n\nbool isObstacle()\n{\n    return texture(VelocityField, uv).z > 0.0;\n}\n\nfloat calcPressure()\n{\n    if( isBorder() ) return 0.0;\n    \n    const float rBeta = 0.25; // 1/4\n    vec2 xOffset = vec2(texelSize.x,0);\n    vec2 yOffset = vec2(0,texelSize.y);\n    \n    float x0 = texture(PressureField,uv-xOffset).x;\n    float x1 = texture(PressureField,uv+xOffset).x;\n    float y0 = texture(PressureField,uv-yOffset).x;\n    float y1 = texture(PressureField,uv+yOffset).x;\n    \n    float div = texture(DivergenceField,uv).x;\n    return ( x0 + x1 + y0 + y1 - div ) * rBeta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 _fragCoord )\n{\n    fragCoord = _fragCoord;\n    uv = fragCoord.xy / iResolution.xy;\n    texelSize = 1.0 / iResolution.xy;\n    \n    fragColor = vec4(1);\n    if( !isObstacle() ) {\n    \tfragColor = vec4( calcPressure(), 0.0, 0.0, 1.0 );\n    }\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Projection\n\n#define VelocityField iChannel0\n#define DivergenceField iChannel1\n#define PressureField iChannel2\n\nvec2 uv;\nvec2 texelSize;\n\nvec2 calcProjection()\n{\n    const float rHalfGridScale = 0.5; // 0.5/gridScale\n    \n    vec2 xOffset = vec2(texelSize.x,0);\n    vec2 yOffset = vec2(0,texelSize.y);\n    \n    float x0 = texture(PressureField,uv-xOffset).x;\n    float x1 = texture(PressureField,uv+xOffset).x;\n    float y0 = texture(PressureField,uv-yOffset).x;\n    float y1 = texture(PressureField,uv+yOffset).x;\n    \n    // Gradient subtraction\n    vec2 vel = texture(VelocityField,uv).xy;\n    vel -= rHalfGridScale * (vec2(x1,y1)-vec2(x0,y0));\n    \n    return vel;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy / iResolution.xy;\n    texelSize = 1.0 / iResolution.xy;\n    \n    fragColor = vec4(calcProjection(), 0.0, 1.0);\n}","name":"Buf D","description":"","type":"buffer"}]}