{"ver":"0.1","info":{"id":"3tXfWn","date":"1596471051","viewed":126,"name":"Multistereogram","username":"lapinozz","description":"Multistereogram attempt","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["stereogram","magiceye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat getDepth(vec2 uv)\n{\n   //return 1. - min(0.25, abs(distance(vec2(0.5,0.5),  uv)));\n   return 1. - texture(iChannel0, uv).x;\n}\n\nvec4 getColor(vec2 uv)\n{\n    //return vec4(random(uv + vec2(154, 535)), random(uv + vec2(15, 560)), random(uv + vec2(245, 163)), 1);\n   // return texture(iChannel1, uv / iResolution.xy);\n    \n    return texture(iChannel1, uv / vec2(textureSize(iChannel1,0).xy) / 1.5);\n   // return texture(iChannel1, mod(uv, repeatWidth / float(iResolution)));\n}\n\nvec4 getStereo(vec2 uv)\n{\n    uv = uv / 2.;\n    \n    float repeatWidth = 96.f;\n    float XDPI = 500.;\n    float EYE_SEP = XDPI*5.0;\n    float OBS_DIST = XDPI*12.;\n    \n    float baseDepth = 120.;\n    float depthFact = 60.;\n    \n    if(mod(floor(uv.y), 2.) == 0.)\n    {\n        repeatWidth = 96.f;\n        XDPI = 500.;\n        EYE_SEP = XDPI*5.0;\n        OBS_DIST = XDPI*12.;\n    \n        baseDepth = 120.;\n        depthFact = 60.;\n    }\n    else\n    {\n        repeatWidth = 96.f;\n        XDPI = 1000.;\n        EYE_SEP = XDPI*5.0;\n        OBS_DIST = XDPI*12.;\n    \n        baseDepth = 120.;\n        depthFact = 120.;\n    }\n    \n    float repeatUv = repeatWidth / iResolution.x;\n    float count = floor(iResolution.x / repeatWidth);\n\n    for(int i = 0; i < 1000; i++)\n    {\n        float depth = 120. + 50. * getDepth(uv / iResolution.xy);\n        float sep = EYE_SEP*depth/(depth + OBS_DIST);\n        //sep = floor(sep);\n        if(  uv.x <= 0.)\n            break;\n        uv.x -= sep;\n        //uv.x = floor(uv.x);\n    }\n\n    /*\n    uv = uv / iResolution.xy;\n    for(int i = 0; i < 100; i++)\n    {\n        if(uv.x <= repeatUv) break; \n        \n        float c = 1. / (count + 1.);\n        float b = 1. / count;\n        float a = (getDepth(vec2(uv.x, uv.y))) * 0.5;\n        uv.x = uv.x - a;\n    }\n    \n    uv.x - mod(uv.x, repeatUv);\n    \n    uv = uv * iResolution.xy;\n    */    \n        \n    return getColor(uv);\n    return uv.xxxx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n\n    fragColor = vec4(getDepth(uv));\n    //fragColor = getColor(uv);\n    fragColor = getStereo(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}