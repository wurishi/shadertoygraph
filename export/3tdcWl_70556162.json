{"ver":"0.1","info":{"id":"3tdcWl","date":"1610213591","viewed":87,"name":"My Second Basic Ray Marcher","username":"CrazySheep05","description":"An update to my first ray marcher\nNow the light bounces twice, allowing for reflections within reflections, and the emissive light also has some reflections!\n\nI started off using this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader designed based of this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE\n//Tutorial project: https://www.shadertoy.com/view/XlGBW3\n\n#define MAXDIS 100.\n#define MAXSTEP 500\n#define SURFDIS 0.001\n#define LIGHTINTENSITY 10.\n#define LIGHTCOL vec3(1,.0,.5)\n\nfloat GetDis(vec3 p)\n{\n\tvec4 s = vec4(0, 1.05, 6, 1);\n    \n    float sd =  abs(length(p-s.xyz)-s.w)-.1;\n    float pd = p.y-1.;\n    \n    float d = max(sd, pd);\n    pd = p.y;\n    d=min(d,pd);\n    \n\ts = vec4(3, 1.05, 6, 1);\n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    d = min(d,sd);\n    \n\ts = vec4(5, 4, 7, 2);\n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    d = min(d,sd);\n    \n\ts = vec4(-5.-sin(iTime), 4, 7, 1);\n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    d = min(d,sd);\n    \n    d = min(d,sd);\n    \n    return d;\n}\n\nfloat GetEDis(vec3 p)\n{\n    vec3 po = vec3(0,4.+sin(iTime),6);\n    vec4 s = vec4(po, 0.25);\n    \n    \n\t//vec4 s = vec4(3, 1.05, 6, 3);\n    return  abs(length(p-s.xyz)-s.w)-.1;\n    \n    //return abs(length(p-s.xyz)-s.w)-.1;\n}\n\nfloat GetRef(vec3 p)\n{\n\tvec4 s = vec4(0, 1.05, 6, 1);\n    \n    float sd =  abs(length(p-s.xyz)-s.w)-.1;\n    float pd = p.y-1.;\n    \n    float d = max(sd, pd);\n    \n    pd = p.y;\n    \n\ts = vec4(3, 1.05, 6, 1);\n    \n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    \n    d = min(sd,pd);\n    \n    d=sd;\n    d=min(sd,pd);\n    if(d<SURFDIS)return .8;\n    else return .2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    \n    return(d);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDis(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d-vec3(\n    GetDis(p-e.xyy),\n    GetDis(p-e.yxy),\n    GetDis(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 TestMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    vec3 p = ro + rd * d;\n    p = p;\n    return(p);\n}\n\nvec3 GetLight (vec3 p)\n{\n    vec3 light = vec3(0,4.+1.0*sin(iTime),6);\n    vec3 l = normalize(light-p);\n    vec3 n = GetNormal(p);\n    \n    float diff = dot(n,l);\n    \n    float d = RayMarch(p+n*SURFDIS*2.,l);\n    if(d<length(light-p))\n    {\n        diff*=.1;\n    }\n    diff*=LIGHTINTENSITY/(length(p-light)*length(p-light));\n    \n    vec3 dir=normalize(vec3(0, 5, -1)-p);\n    \n    vec3 lightCol = vec3(sin(iTime*5.)/2.+.5,0,.5);\n    lightCol=vec3(1,1,1);\n    \n    return max(diff,0.) * lightCol;\n}\n\nvec3 Emission(vec3 ro, vec3 rd)\n{\n    //vec3 p = vec3(0,3.+sin(iTime),6);\n    //vec4 s = vec4(p, 0.25);\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        //float ds = length(p-s.xyz)-s.w;\n        float ds = GetEDis(p);\n        d+=ds;\n        if(ds<SURFDIS)\n        {\n            //return vec3(1,1,1);\n            //return vec3(sin(iTime*5.)/2.+.5,0,.5);\n            \n\n            float de = GetEDis(p);\n            vec2 e = vec2(.01,0);\n\n            vec3 n = normalize(de-vec3(\n            GetEDis(p-e.xyy),\n            GetEDis(p-e.yxy),\n            GetEDis(p-e.yyx)));\n            \n            //return(normalize(n));\n            \n            vec3 pd = reflect(rd,n);\n            float ref = 0.9;\n            ref=GetRef(p);\n            //vec3 diff = 1.-ref;\n\n            vec3 rpos = TestMarch(p+n*SURFDIS*2.,pd);\n            vec3 r = GetLight(rpos);\n            ref=GetRef(rpos);\n            r*=1.-ref;\n            \n            return r + vec3(.9,.9,.9);// * 100.;\n        }\n        if(d>MAXDIS)\n        {\n            return vec3(0);\n        }\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 ro = vec3(0, 5.+2.0*cos(iTime), -1);\n    ro = vec3(0,5., -1.+3.0*cos(iTime));\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.3, 0.7));\n    \n    vec3 p = TestMarch(ro, rd);\n    \n    vec3 diff=GetLight(p);\n    \n    \n    //FIRST REFLECTION\n    vec3 n = GetNormal(p);\n    vec3 pd = reflect(rd,n);\n    float ref = 0.9;\n    ref=GetRef(p);\n    diff *= 1.-ref;\n    \n    vec3 rpos = TestMarch(p+n*SURFDIS*2.,pd);\n    vec3 r = GetLight(rpos);\n    ref=GetRef(rpos);\n    r*=1.-ref;\n    \n    //SECOND REFLECTION\n    n = GetNormal(rpos);\n    pd = reflect(pd,n);\n    vec3 r2p = TestMarch(rpos+n*SURFDIS*2.,pd);\n    \n    r+=ref*GetLight(r2p)*(1.-GetRef(r2p));\n    \n    \n    //COLOURING\n    diff+=r*GetRef(p);\n    //diff=Emission(ro,rd);\n    \n    vec3 col = diff;\n    col+=Emission(ro, rd);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}