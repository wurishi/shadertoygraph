{"ver":"0.1","info":{"id":"3dc3R8","date":"1567704217","viewed":169,"name":"Burning Buffer","username":"Agneseion","description":"My first GLSL thing. Pretty happy with how this looks. Crazy how much sampling you can do without impacting performance that much.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["random","burning","fireburn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float GOLD_PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat GOLD_PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat GOLD_SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\n#define TWO_PI 6.28318530718\n#define ANGLE_STEP TWO_PI/8.0\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+GOLD_PHI), vec2(GOLD_PHI, GOLD_PI)))*GOLD_SQ2);\n}\n\n#define CENTER_RADIUS 0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    float dX = uv.x - 0.5;\n    float dY = uv.y - 0.5;\n    \n    float r = sqrt(dX*dX + dY*dY);\n    \n\tfloat rand = gold_noise(uv, float(iFrame));\n    \n    vec2 pixelStep = vec2(1.0 / iChannelResolution[0].x,\n                           1.0 / iChannelResolution[0].y);\n    \n    float distanceToMouse = length(fragCoord - iMouse.zw);\n    \n    if (r < CENTER_RADIUS / iTime || distanceToMouse <= 0.05 * length(iResolution.xy))\n    {\n        rand = rand * TWO_PI;\n        float red = (1.0 + sin(rand)) / 2.0;\n        float green = (1.0 + sin(rand + 2.05)) / 2.0;\n        float blue = (1.0 + sin(rand + 4.10)) / 2.0;\n        fragColor = vec4(red, green, blue, 1.0);\n    }\n    else\n    {\n        float bestRoll = -1.0;\n        vec4 bestColour = vec4(0.0, 0.0, 0.0, 1.0);\n        \n        for (float angle = 0.0; angle < TWO_PI; angle += ANGLE_STEP)\n        {\n            rand = gold_noise(uv, rand);\n            \n            if (rand > bestRoll)\n            {\n                vec4 colourAtPixel = texture(iChannel0, \n                                     uv + pixelStep * vec2(cos(angle), sin(angle)));\n                \n                if (colourAtPixel != vec4(0.0, 0.0, 0.0, 1.0))\n                {\n                    bestRoll = rand;\n                    bestColour = colourAtPixel;\n                }\n            }\n            if (bestColour == vec4(0.0, 0.0, 0.0, 1.0))\n            {\n                discard;\n            }\n            else\n            {\n                fragColor = bestColour;\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}