{"ver":"0.1","info":{"id":"3ld3Dl","date":"1578450726","viewed":198,"name":"Pyramid Field","username":"spalmer","description":"made mostly to test fog stuff.\nwound up implementing a hella useful fly camera for debugging.\nuse WASD + mouse to fly around; must hold LMB to look.\nor use arrows for aiming, shift for faster.\nTODO  Improve marcher and fog.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","shadow","camera","fog","exponentialheightfog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see Common tab for more info.\n// It's a butchering of https://shadertoy.com/view/ls3fDr so there's that.\n// changed cubes to pyramid field, redid almost everything now.\n// I added debug fly camera controlled by WASD+mouse; see Buffer C.\n// added exponential height fog and other various atmospheric hacks.\n// heightfog cites iq.\n// windy fog noise is by blackle.\n// can't think of any other borrowed code used atm.\n// Surely there's some light paraphrasing of at least the example toys.\n\n// recent changelog:\n// added blackle analytic wind noise method\n// added my analytic wind noise method\n// fixed huge bug with reversed draw order of fog and atmo\n// fixed broken alpha blending of fog\n\n#define BufferC   iChannel0\n// shadowdepth,depth\n#define BufferB   iChannel3\n// Buffer A and B are full resolution rgba32Sfloat rendertargets, at least here on my browser :)\n#define Keyboard  iChannel1\n// blowing dust volume noise\n#define NoiseVol  iChannel2\n\n// FIXME this is notoriously difficult to tune, with the competing exponentials\n// trying to find a better parameterization (or even algorithm) which lets me control the look better.\n// I'm at least hoping to find a way to make it look semi-natural, \n// perhaps when the two distances are in fact equal?\n\n// I kind of have an idea about it\n// first, I want to calculate the apparent extinction distance given the fog density (densities, because height fog)\n// then I want to apply regular air atmospherics to that extinction distance, if it's closer than the scene depth.\n// the more heightfog there is, the closer it will appear to be, and the less regular atmo should apply.\n// if there's not enough fog to fully extinct visibility, just leave depth alone.  But define \"fully\".\n\n// btw these are in sdf coordinates (world space) so actually must be multiplied by depthscale somehow\n// yeah FIXME I'm currently calling heightfog with t argument, not datmo; so it's in sdf coords\n\n// small numbers for dfogexth work better; when large, the fog still goes to 1 in the far distance and looks wrong\nconst float dfogexth = .8; //1e-1; //1e-4; //1.; // should be able to see to the next pyramid - seems too short, actually\nconst float dfogextv = .5; // should go halfway up the pyramids - wait, shouldn't that be .25?\n\nconst float hatmo = 85000.; // atmospheric extinction distance\n// FIXME it's rather confusing, actually; should just use meters world space and scale the SDF internally by this.\n// either way it's sort of a hack, but idk which way is better.\nconst float depthscale = 1200.; // exaggerate depth to scale tiny scene to appear much larger - a 1x1x.5 pyramid appears big\n// that's great, but it should just be the object scale of the \n// tiled pyramid used to represent the world.\n// No sense making the entire toy deal with the kludge!!\n// just keep everything else in realistic world units like meters.\n// idk why you keep putting yourself through this, just fix it! FIXME FIXME FIXME\n// well for starters, even if the scene *were* in meters,\n// I may still want different scaling on the atmospherics.\n// sometimes you just want everything foggier!  But still.\n// I grow tired of dealing with such hacks everywhere.\n// Then I could delete all these shitty worthless comments about it too!\n\nconst vec3 diffuseColor = vec3(.8, .5, .4);\nconst vec3 specularColor = vec3(.5);\nconst float specularity = 12.0;\n\nconst vec4 csky = vec4(0. * vec3(.5, .7, .9), 1.); // all sky color actually comes from inscattering now\nconst vec3 cfogunlit = vec3(.80, .81, .82);\nconst vec3 cfoglit = vec3(1.19, 1.04, .94);\nconst vec3 wind = vec3(0.12, 0., 0.); //*.03;\nconst vec3 airextinction = 3e-5 * vec3(1.,2.,3.);\nconst vec3 airinscatter = 2e-4 * vec3(.1,.2,.3);\nconst vec3 airmie = 4e-2*vec3(.22,.15,.08); // fake mie scattering\nconst vec3 cglare = .15 * vec3(1.,.7,.3); // sun halo color\n\nconst float ambient = .5; // fraction of sun received from \"everywhere\"\n\n// the way I calculate density by extinction distance is based on this idea:\n// if you start with 100% visibility (0 alpha) and accumulate opacity over distance,\n// it will reach a point where it's effectively 100% opacity (alpha very close to 1.0)\n// at that distance, the base 2 logarithm of which can be calculated.\n// FIXME that's still some handwaving BS, not a real explanation.  What's the division mean?\n// I did derive this at some point, where'd that go?  Now I can't even remember how I got it this simple.\n// now, I can make the small number whatever I want, which varies how close to 1.0\n// let's call it epsilon, the extinction alpha would then be 1.0 - epsilon.\n// exp2(-d) = epsilon = 1 - alpha\n// it really depends on what you intend to use it for; for actual opacity,\n// .5/256 seems a fine choice, as that's already imperceptible.\n// but when integrated over a huge distance, those tiny amounts still add up\n// to something significant and visible; you can see fog up in the sky\n// above where it's supposed to be cutoff as infinitesimal.\n// if I tune it too tightly, though, the other reversed calculation goes nuts;\n// the above two exponentials interfere with each other and they can't both be tuned exactly, at least not here.\n\nfloat distanceToDensity(float extinction_range) // exponent in base 2, range units unspecified\n{\n    // we want exp2(-d * extinction_range) to give a really small number like 5e-3\n    // so d should be log2(small) / -extinction_range\n    return -5. / -extinction_range;\n}\n\n\nvec3 lightOrigin() \n{\n    return loadValue(BufferC, slotLightOrigin).xyz;\n}\n\n// read keyboard key, return true if down\nbool keydown(int vk)\n{\n    float s = texelFetch(Keyboard, ivec2(vk,0), 0).x; // read keyboard key state from texture\n    return s > .5; // test if down\n}\n\n// my atmo sucks.  my lighting sucks but is less bad than it was.  wah.  so much TODO\n\nvec4 LightingBlinnPhong(vec3 n, vec3 v, vec3 albedo, float d, float satten)\n{\n    float amb = clamp(0.5 + 0.5 * n.y, 0., 1.); // less coming from down; makes hemispherical ambient\n    float lv = clamp(dot(lightDir, n) * satten, 0., 1.); // n dot l\n    vec3 h = normalize(v + lightDir);\n\n\tfloat dl = mix(lv, amb, ambient); //amb * ambient + dif * (1. - ambient); // how much diffuse+ambient lighting\n\tvec3 c = dl * albedo;\n    \n    float spec = pow(clamp(dot(h, n), 0., 1.), specularity);\n    spec *= lv * specularity * .038f; // should mul by n*l and power, divide by 8*pi\n//    float reflectivity = 0.5;\n    // TODO reflections - should do another scene trace\n    //   vec3 ref = reflect(-rd, n);\n    //    vec3 crefl = texture(iChannel0, ref).rgb;\n\tc += spec * specularColor;\n    return vec4(c, 1);\n}\n\n\nvec4 alphaBlend(vec4 bg, vec4 fg) \n{\n    return vec4(bg.rgb * (1. - fg.a) + fg.rgb * fg.a, 1);\n}\n\n// iq as usual has a good height fog! https://iquilezles.org/articles/fog\n// he says he got it from Crytek though.\n\n// one of these densities is used in a sense of 1-exp2(n) though!  explains some of the weirdness.\n// idk actually if this is the best way to parameterize it, then.\n// f is the main fog density, so determines the visibility range limit when viewer is completely immersed in the fog bank looking laterally\n// f is the vertical density *falloff*, so determines the height at which the fog completely dissipates\n// accepts exponent in base 2, not base e, so uses exp2(-x) internally intead of exp(-x/ln(2))\n// it's no longer dividing by zero, but something can go wrong when y==0 or thereabouts.\n// You could notice it most when first clicking the mouse without moving it.\nfloat heightfog(float d, float h, float y, float f, float e)\n{\n    const float ylim = 1e-6;\n    if (abs(y) < ylim) { // handle the divide by zero and exp2(-0) == 1 problems when y near 0\n        y = ylim; // * sign(y); // sign factor breaks it\n    }\n    float i_y = 1. / y; //sign(y) / (abs(y) + 1e-6); //abs(y) < 1e-2 ? 1. : 1./y; // handle divide by zero? already did above.\n\treturn i_y * f/e\n        * exp2(max(-127.,-h*e)) //clamp(-h*e, -127., 127.)) //\n\t\t* (1. - exp2(clamp(-d*y*e, -127., 127.)));\n}\n//    if (y > 0.) { h -= d*y; y = -y; } // HACK swap so always aiming down - unnecessary when it's working as intended\n\n// fog noise based on 3D noise texture\n    // trying the 3d volume noise texture, but it's only 32^3\n    // TODO need some real 3D fbm noise\nfloat cloudNoise(vec3 q)\n{\n    const float dustscale = .1*8.*.5; // scale - larger clouds\n    q *= dustscale;\n    float n = texture(NoiseVol, q).x;\n    n = mix(n, texture(NoiseVol, q*2.).x, .5); // another octave\n    return n;\n}\n\n// I need to do obscurance marching\n// something like iq's Clouds https://shadertoy.com/view/XslGRr\n// I use a big 'ol hack though\nstruct HitCloud\n{\n  float // tracking a few quantities:\n\tz // depth to extinction, optical depth, equates to the visible \"depth\" of the cloud \"surface\" when it's thick enough.\n  , l // litness, or proportion visible that isn't in shadow from pov of light\n  , n // normal, glow, or proportion visible that has gradient facing toward the light source (basically a cosine used to fake lighting directionality)\n  , d // total accumulated density or alpha, without scale, actually - you multiply the fog density after the march.\n  ;\n};\n// query shadow attenuation of world position\nfloat rayshadowmap(vec3 ro) //, vec3 rd)\n{\n    // get light basis\n   \tvec3 light_pos = lightOrigin();\n    vec3 light_fwd = -lightDir;\n    mat3 M = cameraMatrix(light_fwd);\n//    vec3 sd = lightRayDir(q, light_fwd);\n    ro -= light_pos;\n    // to light space\n    vec2 uv = vec2(dot(M[0],ro), dot(M[1],ro)); //TODO\n    if (max(abs(uv.x),abs(uv.y))>1.) return 1.;\n    // world distance lightraysource to fragment, matching shadowmap storage\n    float fd = dot(ro, light_fwd); //lightDir); // - dot(light_pos, lightDir);\n    // sample     // TODO need filtering omg so much work\n    return textureLod(BufferB, uv, 0.).x < fd ? 0. : 1.;\n}\n// returns attenuation factor, not distance\n// assumes caller already biased to avoid self-shadow artifacts; not enough info here to do it properly.\nfloat rshadow(vec3 q)\n{    \n//    return rayshadowmap(q);\n    int nsteps = 64;\n    nsteps += UZERO; // HACK prevent unwise compiler loop unrolling - doesn't matter :(\n    return rayshadow(q, lightDir, nsteps); // FIXME way too slow to use for fog shadows - it's already busting on OpenGL in fullscreen without them\n}\n\n    \n// that should be enough information to do fairly convincing lighting on it.\n// ro=ray org, rd=ray dir, t=distance to bg, all in cloud space, result too\nHitCloud marchCloud(vec3 ro, vec3 rd, float t, int nsteps)\n{\n    float rstep = 1./float(nsteps); // total noise fraction for each step\n    HitCloud c;\n    c.z = c.l = c.n = c.d = 0.;\n    for (int i = nsteps; i > 0; --i) {\n        float f = float(i) * rstep;\n        c.z = t * f;\n        vec3 q = ro + c.z * rd;\n        float nz = cloudNoise(q);\n        nz *= exp2(min(0., -4.*dfogextv*max(0.,q.y))); // vertical density falloff\n        nz *= rstep;\n        // say you have quantity c, and you want to blend-behind it into buffer b,\n        // based on new alpha a and old alpha o\n        // then new b = mix(c, b, o) \n        // and new o = mix(o, 1., a)\n        // an important thing to note:\n        // the new quantity (consider color) can only increase when mixed with blend-behind;\n        // it had already assumed the behind-quantity (bg color) was zero/black anyway.\n        // I suppose if you allow negative quantities it'd be different.\n        // so in fact some of these mix could be simplified to mad.\n        nz = clamp(nz, 0., 1.);\n        //nl is the shadowed state at q\n        float nl = rshadow(q);\n        //nn is the directed gradient toward the light at q\n        float nn; // used as a sort of self-shadowing or lit normal direction\n        c.l = mix(nl, c.l, c.d);\n        c.n = mix(nn, c.n, c.d);\n        c.d = mix(c.d, 1., nz); // blend-behind\n        if (c.d >= .99) break; // total extinction?\n    }\n    c.z = clamp(c.z, 0., t); // final apparent optical depth\n    c.l = clamp(c.l, 0., 1.); // total apparent not-in-shadow-ness\n    c.n = clamp(c.n, 0., 1.); // total n*L\n    c.d = clamp(c.d, 0., 1.); // total alpha\n    return c;\n}\n\n#if 0\n/*\nconst float phi = (sqrt(5.)+1.)/2.; // golden ratio\n// pretty sure I originally got this matrix from iq's fbm somewhere\nconst mat3 lrotm3 = mat3( .00, .80, .60,\n\t\t\t\t\t\t -.80, .36,-.48,\n\t\t\t\t\t\t -.60,-.48, .64);\n// unfortunately, my idea isn't working so well, since\n// apparently it repeats periodically more than I thought.\n      #if 1\n      #else\n        // constant rotations almost as good? apparently not.\n        //a = scale * lrotm3 * a;\n        //b = scale * lrotm3 * b;\n        // FIXME smaller scales should contribute less\n\t\tfi += lineintegral(a, b) * pow(scale, float(-i));\n      #endif\n*/\n#else\n// trying blackle's rotations instead\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\n\nfloat hash(float a, float b)\n{\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) \n{\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n#endif\n\n#if 1\n// extremely clever fog using analytical line integral of sinewaves\n// originally by blackle at https://shadertoy.com/view/3lByRK\n// HACK prevent / 0\nvec3 div(vec3 a, vec3 b) \n{\n    //b = max(abs(b), 1e-3) * (step(0., b) * -2. - 1.); // hack\n    //b = max(abs(b), 1e-3) * (step(b, vec3(0)) * -2. - 1.); // sign() fails because it returns 0\n    b += vec3(equal(b, vec3(0))) * 1e-2; // blackle's hack\n    return a / b;\n}\n\nfloat antiderivative(float x, vec3 origin, vec3 dir, vec3 Q)\n{\n    // antiderivative for pow(dot(sin(origin + x*dir), vec3(1), 2.);\n    mat3 A = mat3( 1, 1, 0, -1, 0, 1,  0,-1,-1)\n       , B = mat3( 1, 1, 0,  1, 0, 1,  0, 1, 1);\n    vec3 /*Q = origin + dir*x // the caller already had Q computed!!! bah\n    ,*/ integral = div(sin(A * Q), A * dir)\n                 - div(sin(B * Q), B * dir)\n       + div(2.* Q - sin(2.* Q), 4.* dir);\n    return dot(integral, vec3(1,1,1)); //dot(integral, vec3(1)); //integral.x;// + integral.y + integral.z; //\n}\n\nfloat lineintegralblackle(vec3 a, vec3 b)\n{\n    float len = distance(a, b);\n    vec3 dir = (b - a) / len;\n    return antiderivative(len, a, dir, b)\n         - antiderivative(0.0, a, dir, a);\n}\n\n\n\n// with the parameterization here, something always ends up\n// being recomputed redundantly, either the dir and length or the point b\nfloat fogblackle(vec3 a, vec3 b, int niter)\n{\n    const float scale = 1.08; //phi * (2./3.);\n    float fi = 0.; float s = 1.;\n    for (int i = 0; i < niter; ++i) {\n\t\t// blackle's random rotations\n\t\tvec3 ax = normalize(tan(hash3(float(i),14353.)));\n\t\tfloat ro = hash(float(i),66123.)*10.;\n\t\ta = erot(a,ax,ro);\n\t\tb = erot(b,ax,ro);\n        s *= scale;\n        fi += lineintegralblackle(a, b) / sqrt(s);\n    }\n//\tfi /= pow(1. + scale, float(niter));\n    float fit = .002;\n    fi = clamp(fi * fit / float(niter), 0., 1.);\n    // HACK just prevent infinite fog at horizon, even though I really don't know if it's wise\n//    vec3 dir = normalize(b - a); // here we go computing it again!! FIXME\n//    fi *= pow(dir.y, 2.);\n    // result is simply treated as an alpha value\n    return fi;\n}\n\n#endif\n\n#if 1\n// from https://shadertoy.com/view/WlByzc\n/*\n// the basic fog noise squared sinewave function wiggles from 0..1 with period pi\nfloat F(float x)\n{\n    float s = sin(x);\n\treturn s*s; // s^2\n}\n// in 3D we don't show or evaluate the F function directly\nfloat F(vec3 p)\n{\n    return F(p.x) * F(p.y) * F(p.z);\n}\n*/\n// compute line integral of F(x) with x ranging between a and b\n// Maxima does integrate(F(x), x, a, b); producing (+2*b-2*a-sin(2*b)+sin(2*a))/4\nfloat A(float a, float b)\n{\n    return abs(.5*(b - a) + .25*(sin(2.*a) - sin(2.*b)));\n}\nfloat A(vec3 a, vec3 b)\n{ // FIXME why 127?!\n    return (A(a.x, b.x) * A(a.y, b.y) * A(a.z, b.z)) / 127.; // product shows up much more strongly\n}\n\nfloat rebend(float x)\n{\n    return pow(x, 2.); // just darken everything but the really dense fog, hopefully\n//    return x;\n    // FIXME HACK - why was I doing this?!  I think it's bending the wrong way anyway, looking at it today with fresh eyes.\n//    const float maxd = 12800.;\n//    return x / (x + 1280.01) * maxd; // reinhardesque hack - really?!  severe\n}\n\nfloat lineintegral(vec3 a, vec3 b) \n{\n    // find a scale where I can perceive it\n    const float s = .01; //1.; //2.; //.5; //200.; //1./200.; //\n    a *= s; b *= s; //\n    return rebend(A(a, b) / s)\n    //    / 8. // really dim too, brighten up\n        ;\n}\n// my adaptation of blackle's line integral fbm\nfloat lifogmultiscale(vec3 a, vec3 b, int niter)\n{\n    float fog = 0.\n    , prescale = 1200.\n \t, scale = 1.\n    , scalefactor = 1.06;\n    a *= prescale; b *= prescale; // massive HACK\n    vec3 oa = a, ob = b; // keep so each layer can be independent\n    // sum up multiple different versions of the fog\n    for (int i = 0; i < niter; ++i) {\n        // N.B. tan is blackle's distribution-uniformizing trick,\n        // helps fixup the cubic distribution hash3 gives,\n        // back into something more spherically-distributed.\n        // random rotation\n        vec3 ax = normalize(tan(hash3(float(i), 14353.))); // axis\n        float ro = hash(float(i), 66123.)*10.; // angle, yet another hash\n        // rotate both original points into this layer's basis\n        a = erot(oa,ax,ro);\n        b = erot(ob,ax,ro);\n        // contributes less for finer scales.\n        fog += lineintegral(a*scale,b*scale) / (scale*prescale); //sqrt(scale) * ;\n       \tscale *= scalefactor;\n    }\n    //fog /= float(niter) * prescale;\n    //fog = 1. - fog;\n    //fog *= pow(prescale * float(niter), -2.); // HACK scale total to 0..1 range\n    // massive rescaling is to remap the unit sinewave density\n    // to the actual fog density\n    fog *= exp2(-16.); //1./256.; // mega HACK, wtf man\n    //fog *= 16.; // more HACK\n    fog = clamp(fog, 0., 1.);\n    // more HACK, just reshapes the falloff completely, total hack\n    // but without it, I can't see the nearby fog, or it \n    // fogs scene completely too close to the camera, no middle ground.\n    fog = pow(fog, 1./16.);\n\treturn fog;\n}\n#endif\n\n// returns an \"alpha\"/coverage/opacity value\n// as well as outs a premultiplied alpha color representing the lit fog\n// to be blended atop lit world bg\nfloat fogNoise(vec3 ro, vec3 rd, float t) //, out vec4 c)\n{\n #if 1\n    const float hfogplane = dfogextv * 4.;\n    if (ro.y > hfogplane && rd.y < 0.) {\n        // clip the noise tracing to a slab above the ground plane\n        float adv = (ro.y - hfogplane) / rd.y;\n        ro += rd * adv;\n        t = max(t - adv, 0.);\n        // TODO clip end point too?  t?\n    }\n #endif\n    ro += wind * iTime; // wind\n #if 0\n    // using my rework of blackle's analytic line integral\n    // FIXME something's wrong with the tuning, I can't even see it atm\n    const int nsteps = 16;\n    return lifogmultiscale(ro, ro + rd * t, nsteps);    \n #elif 1\n    // using blackle's analytic line integral!\n    const float fs = 20.; // smallness of puffs\n    const int nsteps = 16;\n    return fogblackle(ro * fs, (ro + rd * t) * fs, nsteps);\n #elif 1\n    // old slow ugly stepping thru noise texture\n    t = min(t, 16.); // only step thru fairly nearby noise\n    const int nsteps = 1 << 1; //3; //5; //\n    HitCloud h = marchCloud(ro, rd, t, nsteps);\n    return h.d; // returns whatever total alpha marchCloud computed\n #else \n    t = min(t, 16.); // only step thru fairly nearby noise\n    const int nsteps = 1 << 1; //3; //5; //\n    // big ol' hack, not really rendering anything realistically here.  Better than when it's completely uniform.  yeah this is really lame\n    float a = 0.; //1.;\n//    float tbias = 1. * iTime;\n//    vec2 uv0 = p0.xz;\n    for (int i = nsteps; i > 0; --i) {\n        float f = float(i) / float(nsteps);\n        vec3 q = ro + t * f * rd;\n        float nz = cloudNoise(q);\n\t\t//nz = sin(6.2 * nz + 4. * q.y + tbias) * .5 + .5; // helps but is expensive, may as well use some ALU noise\n     //   nz *= exp2(min(0., -4.*dfogextv*q.y)); // idk - need falloff though\n        nz *= (1. - f*f); // more near camera\n        nz /= float(nsteps);\n        // this is all garbage atm.  I wouldn't do it like this but nothing's working yet.\n        a = min(1., a + nz * 1.); //mix(a, 1., nz); //\n    }\n    return 1.-a; //1.; //mix(.25, .5, a);\n #endif\n}\n\nvoid sceneHeightFog(inout vec4 c, vec3 ro, vec3 rd, float t, float lv)\n{\n//    return; // HACK disable\n    vec4 fc;\n\tfloat dust = 1.;\n    dust = fogNoise(ro, rd, t); //, fc);\n    dust = clamp(dust, 0., 1.);\n    float hfog = 1.;\n    float a = distanceToDensity(dfogexth);\n    float b = distanceToDensity(dfogextv);\n    hfog = heightfog(t, ro.y - 0.01, rd.y, a, b);\n    // TODO I get the feeling I must divide out the integral of the ground plane too\n    // if I wish to prevent infinitely thick fog off to the (near) horizon.\n    // Perhaps the trick would be to have the exponential height fog\n    // go to 1.0 at the horizon instead of infinity.\n    // then it'd be easier to manipulate.\n//    hfog = mix(.0, .75, hfog); //  just never want hfog to go completely opaque, I guess\n//    hfog *= dust; // want it to only reduce, but not completely\n//    hfog *= mix(dust, 1., .25); // idk; just gonna stop using exp height fog for now so I can see what the fog marcher is doing\n   // if (isnan(hfog)) { c = vec4(blink,0,0,1); return; }\n    hfog = clamp(hfog, 0., 1.);\n    // TODO could really use some self-shadowing and self-occlusion on the height fog, it looks so matte\n    // nasty HACK, should really be doing MSS exponentials instead, for all atmospherics\n    vec3 chfog = mix(cfogunlit, cfoglit, pow(clamp(lv, 0., 1.), 2.)); // height fog apparent color depends on light angle\n    fc.rgb = chfog; fc.a = 1.;\n   #if 1\n    // premultiplied alpha blending\n    fc *= dust * hfog;\n    c = c * (1.-fc.a) + fc;\n   #else \n    // non-premultiplied blend-over\n    fc.a *= dust;\n    fc.a *= hfog;\n    c = mix(c, vec4(fc.rgb,1), fc.a);\n   #endif\n}\n\nvoid sceneAtmosphere(inout vec4 c, vec3 ro, vec3 rd, float t, float lv, float datmo)\n{\n    datmo = t * depthscale;\n    c.rgb *= exp2(-airextinction * datmo); // extinction\n    float afog = mix(pow(max(lv * .5 + .5, 0.), 2.), 1., .875);\n    vec3 cfog = 1. - exp2(-airinscatter * datmo);\n    vec3 ad = abs(rd);\n    c.rgb += afog\n        * cfog; // inscatter - crappy phase function tho FIXME kind of vaguely rayleigh-like\n    c.rgb += (1. - exp2(-airmie*t)) * pow(max(lv, 0.), 8.) * .5; // fake mie\n    // FIXME glare should fade by inverse depth\n    c.rgb += pow(max(lv, 0.), 4.) * cglare; // glare - FIXME should attenuate by eye shadow trace\n}\n\nfloat shadowDepth(vec2 uv)\n{ // shadow depth in BufferB.x\n    return textureLod(BufferB, uv, 0.).x;\n}\n\n// p is fragment world pos, v is view dir (toward eye), n is surf normal, t is distance from p to camera plane\n// lv is dot(-L,v), albedo is diffuse/ambient color, datmo is (fake scaled) frag depth\n// returns premultiplied alpha color c of lit fragment\nvoid sceneLight(inout vec4 c, vec3 p, vec3 v, vec3 n, float t, float lv, vec3 albedo, float datmo) //vec3 ro, vec3 rd, float t,\n{\n    float satten = 1.;\n #if 1\n    // shadows?\n    satten = rshadow(p); // shadow attenuation depends on ambient factor\n #endif\n\tvec4 cobj = LightingBlinnPhong(n, v, albedo, t, satten);\n    c = alphaBlend(c, cobj);\n}\n \nfloat mainDepth(vec2 p, vec3 ro, vec3 rd)\n{\n    float t;\n #if 0\n    // no need to re-march if storing main depth into BufferB.y\n    // just sample from depth texture\n    vec4 dsamples = texelFetch(BufferB, ivec2(p), 0);\n    t = dsamples.y;  // but do still need to light & fog\n #else\n    // re-trace in Image pass\n    // but FIXME we should be able to get away with much fewer steps, imho - like 64 or so should be decent.\n    // Yeah but to get anywhere near the horizon, we need quite a few steps, like 256.\n    // yeah these are heightfields, not true sdfs, but still mostly linear, just has some kinks.\n    int nsteps = 128; //160; //192; //256; //512; //32; // \n    nsteps += UZERO; // HACK prevent unwise compiler loop unrolling? not helping though.\n //   t = raymarch(ro, rd, nsteps);\n    t = raymarchSlabY(ro, rd, nsteps); // cheating, though, a bit.  Now giving me NaNs if camera goes high enough.  ugh!\n //   if (!(t>=0.) && rd.y < 0.) { t = min(200., ro.y / -rd.y); } // and this test isn't catching the NaN either. :(  GLES doesn't have IEEE comparisons?\n #endif\n    return t;\n}\n\nvoid sceneDraw(vec3 ro, vec3 rd, inout float t, out vec3 albedo, out vec3 n, out float datmo)\n{\n    bool is_hit = isHit(t); //(t >= 0.); //\n    float dsky = hatmo / depthscale;\n    datmo = t;\n    bool sky = !is_hit || t > dsky;\n    float stripe = 1.; // texture\n    if (sky) {\n        datmo = hatmo; //dsky; //\n        n = -0.*rd;\n        t = dsky; //hatmo; //8.5e4;// / depthscale; // / 1200.; // decorrect for exaggeration\n        // TODO sky *dome* - not working :(\n      //  t *= 1. - .975*exp2(-35.*max(0., rd.y));\n     //   t = dsky; //datmo / depthscale; // decorrect for exaggeration\n    } else { // hit sdf, so render it over bg, lit\n        vec3 phit = ro + rd * t;\n\t\tn = sdfnormal(phit);\n      \tif (any(lessThan(fract(phit * -2. + .5), vec3(.02))))\n        \tstripe = mix(1., .9, exp2(-.04*t)); // NOT antialiased! just fades out\n        // contact shadows - need another scene trace - tracing up isn't optimized though.\n        albedo = diffuseColor * stripe;\n   \t\t// t sent for future reflection/shadow ray generation\n    \tdatmo *= depthscale;\n    }\n    //if (!isHit(t)) t = datmo; // HACK maybe sceneDraw should handle sky misses?\n}\n\nvoid renderScene(inout vec4 c, vec2 p, float snoize, out vec2 q, out vec3 rd, out float t)\n{\n    q = StoQ(p, iResolution.xy);\n\t// create view ray\n    rd = cameraRayDir(q, cameraDirection(BufferC));\n    vec3 ro = cameraPosition(BufferC);\n//\tro += .005 * snoize * rd; // dither start position helps break up banding due to screwups    \n    float lv = dot(lightDir, rd); // factor of all fog and eye glare lighting\n    vec4 bg = mix(.9, 1., lv) * csky; // lame rayleigh-ish hack\n    bg.rgb += pow(max(lv, 0.), 1024.) * 30. * vec3(1.,.7,.3); // way overblown sun disc so it shows thru atmo\n    c = bg;\n    t = mainDepth(p, ro, rd);\n    float datmo;\n    vec3 albedo, normal;\n    sceneDraw(ro, rd, t, albedo, normal, datmo);\n    vec3 hitps = ro + rd * t\n        + 1e-4 * (normal + lightDir * max(lv,0.)); // self-shadow bias\n    sceneLight(c, hitps, -rd, normal, t, lv, albedo, datmo);\n   #if 1 \n    // WIP, bear with me.  yes it helps a lot if you do it in the correct order!\n    sceneHeightFog(c, ro, rd, t, lv);\n   #endif\n    sceneAtmosphere(c, ro, rd, t, lv, datmo);\n}\n\nvoid debugScene(inout vec4 c, vec2 q, vec3 rd, float t)\n{\n    float blink = sqrt(sin(iTime*30.)*.5+.5); //sin(iTime*32.); // for errors\n   #if 0\n    // debug rays missed aiming downward should at least draw something besides sky; maybe an error blink\n    if (!(t>=0.) && rd.y < 0.) { c.rgb = vec3(1.,0.,0.) * blink; }\n   #endif\n    if (keydown(48+0)) // '0' = show depth map\n        c.rgb = vec3(1.-exp2(-.04*t));\n    if (keydown(48+9)) { // '9' = show shadow map\n      float ts = shadowDepth(q * .5 + .5);\n      c.rgb = vec3(1.-exp2(-.04*ts));\n    }\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{   \n    // need screen noise for dither \n    float snoize = rand(p.xy/4.);\n    float t; vec2 q; vec3 rd;\n    renderScene(c, p, snoize, q, rd, t);\n    debugScene(c, q, rd, t);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n    c.rgb += vec3(.75/256. * snoize);  // simple dither\n    c.a = 1.;\n}\n\n// FIXME\n// Sorry, I keep working on other stuff besides fog shadows and self-obscurance,\n// because on OpenGL full-screen is so glitchy when looking upward that I cannot\n// even stand to look at it closely enough to debug it.  So I'm fixing the crazy \n// slabY-clipping stuff so it works better and handles the upward-looking case better, first.\n// I may wind up needing to implement proper ray tracing or at least a proper SDF\n// so the ray marcher doesn't struggle so much and need so many iterations.\n\n//    if (iFrame == 0) c = vec4(1.,0.,0.,1.);\n\n// TODO some keys for debugging various features while held down; depth, normal, iterations, etc.\n    \n//    if (key(KEY_A) &&\n//        distance(fragCoord,vec2(25.0,50.0)) < 10.0) c = vec4(0.0,1.0,0.0,1.0);\n//    if (key(KEY_D) &&\n//        distance(fragCoord,vec2(75.0,50.0)) < 10.0) c = vec4(0.0,1.0,1.0,1.0);\n\n//    c.rgb = mix(c.rgb, vec3(0.), exp2(-.5*distance(p, abs(iMouse.xy))));\n\n//\tc.rgb = (rd * .5 + .5) * (1. - exp2(-2.*t)); // hack for debugging directions of world coordinate system\n//    c.rgb *= stripe; // stripes on fog?! sure! when debugging, maybe\n//    c.rgb = vec3(q, 0); // debug screen space uv\n//    float cd = 9.0;\n\n//    bg += pow(max(lv, 0.), 16.) * vec4(.7f,.3f,.2f,0);\n//    c.rgb += pow(max(lv, 0.), 4.) * vec3(.2f,.1f,.05f); // glare doesn't use depth\n\n// was using a texture but now there's no slots left\n//snoize = textureLod(iChannel2, uv * float(iResolution.y) / 256., 0.).x;\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// anything in this toy that I wrote is in the public domain as far as I'm concerned.\n// I'll note any other citations with licenses that may apply;\n// see Image tab for most of them.\n// In any case the site's Creative Commons Attribution license will apply.\n\n// Common #include shared definitions\n\n#define UZERO int(iTimeDelta*1e-34)\n\nconst float pi = 3.141592;\n\nvec3 lightDir = normalize(vec3(-.25, .1, -.5)); //.0, .0, 1.)); // white directional sunlight\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\nint slotid(ivec2 loc)\n{\n    return loc.x; // TODO if run out of x in buffer, could wrap to subsequent rows\n}\nivec2 slotloc(int id)\n{\n    return ivec2(id, 0);\n}\n\n// channel allocations can't be done in Common,\n// as the defines for the iChannel# samplers have not yet been set.\n// but we can allocate the slots within BufferA at least.\n\nconst int slotCameraPosition = 0;\nconst int slotCameraForward  = 1;\nconst int slotCameraForwardClick = 2; // captures camera forward at start of mouse click\nconst int slotLightOrigin = 3; // for shadow cascade anchor, don't want to calc per-pixel\nconst int slotCount = 4;\n\nvec4 loadValue(sampler2D ch, int slot_id)\n{\n    return texelFetch(ch, slotloc(slot_id), 0);\n}\n\nvec3 cameraPosition(sampler2D bufC) \n{\n    return loadValue(bufC, slotCameraPosition).xyz; //vec3(.0, .25, .0); // * cd;\n}\n\nvec3 cameraDirection(sampler2D bufC) \n{\n    return loadValue(bufC, slotCameraForward).xyz; //vec3(0., 0., 1.); //\n}\n\n\n// build a 3x3 camera matrix given forward direction vector, assuming up is +Y\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// implements inverse view*proj matrix transform (postclip to world dir)\n// with fovy at 60 degrees\nvec3 cameraRayDir(vec2 q, vec3 cam_fwd)\n{\n    mat3 M = cameraMatrix(cam_fwd);\n    return normalize(M * vec3(q, 2.));\n}\n\nvec3 lightRayDir(vec2 q, vec3 lgt_fwd)\n{\n    mat3 M = cameraMatrix(lgt_fwd);\n// FIXME perspective projection for light is wrong\n    return normalize(M * vec3(q, 20.));\n} // needs large near clip plane\n\nconst int KEY_SPACE = 32;\nconst int KEY_CTRL  = 17;\nconst int KEY_SHIFT = 16;\nconst int KEY_C     = 67;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n\n// you can mess around with this here: https://shadertoy.com/view/tdKSWW\nfloat rand(float x)\n{\n    // do something nonlinear to mantissa to eliminate any possible linear correlation\n #if 0\n    // smoothstep! works great.  Not expensive.\n    x = fract(x); // this is mostly just to enforce that the input value is 0..1\n    x = (3.0 - 2.0 * x) * x * x; // smoothstep decorrelates the mantissa with cubic and is cheaper than sine, I bet, unless they implement sine with magic instead of polynomials\n #else\n    // sine provides good decorrelation and as a bonus includes its own range reduction (don't need fract above)\n    x = sin(x); // *43787.97f; // I thought iq invented this for quite a while, but\n #endif \n    // see https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n\t// any old scaling constant will work, for the most part\n    x *= 43708.8672; //43758.5453; //40504.09375; //43997.97; //25314.67285; // magic constant is just a large almost-prime fraction that has noise in all bits of mantissa\n    x = fract(x); // final fma modulo wrap for chaos\n    return x;\n}\nfloat rand(vec2 x) { return rand(dot(x, vec2(11.07,10.71))); }\n\n// sdf shared here so I could do collision on the camera\n\n// The pyramids are height 1.0;\n// thus so is the vertical slab they all reside.\n// That makes the pyramids 2.0 wide which \n// seems to make computing it a bit easier.\n\nconst float hPyramid = 1.; // pyramids are only 1 high! no sense marching anything above that.\n// Serves as a better reference than 0.5 height.\n\n// FIXME not really a true sdf, more like a height field\n// it's not like I've tried to make this optimal in any sense, either.\nfloat sdf_old(vec3 p)\n{\n    float h = 0.; //-.25f; //\n    ivec2 j = ivec2(floor(p.xz));\n    bool i = // maybe not every cell should have one\n        j.x*j.x+j.y*j.y < (1<<17) && // so aliasy this far away, idk if we should try to draw them\n        ((j.x|j.y)&2) == 0; // different functions produce different patterns; I like this spacing.\n    if (i) { //false) { // pyramid in this cell?\n    \tp.xz = fract(p.xz / 2.); //mod(p.xz, 2.) / 2; //\n        vec2 b = vec2(abs(p.x - .5f), abs(p.z - .5f));\n        // btw this is not an accurate octahedron or half-octa; the edges are too sharp,\n        // the distances in edge and tip voronoi regions are too large.  It's a heightfield hack, only.\n         // half-octahedrons are rotated pyramids.  depending on metric, are rotated\n    //    h = .5f - abs(p.x - .5f) - abs(p.z - .5f); // diamond pyramids\n        h = 2. * (.5f - max(b.x, b.y)); // square pyramids\n        // well if the sdf wasn't broken enough as it was\n       #if 0\n        //  steps make it really chewed up\n        // and it becomes obvious that this is merely a heightfield, not a true sdf.\n        // but if we use *enough* steps, they get so small you can't really notice\n        // although they do start to alias, instead.  :(\n        // in any case, it looks like crap, so don't use it.\n        const float steps = 64.;\n        if (min(b.x, b.y) < .01) // only in the middle\n        \th = ceil(h * steps) / steps;\n       #endif\n        h = max(h, 0.0); //-0.125);\n    }\n    return p.y - h;\n}\n// now, usually, I'd go about trying to fixup this calculation so it's actually computing the\n// proper sdf for the pyramid field, but in this case I was leaving it because\n// a good chunk of the point of this demo is to stress test the raymarcher algorithm\n// and this sort of busted field serves as a pretty good test.  Should add some noise!\n\n// I could really just raytrace this scene with little effort.\n// This toy also serves as a testbed for raymarching strategy, so\n// may as well leave it a raymarcher, and leave the old sloppy field as a stress test.\n\n// I did that for a while, then I got fed up with having to use so many iterations\n// which was causing glitchy problems on OpenGL, so I changed over to a better sdf\n// (I hope) which is still too sharp in general but at least it's based on actual distance, not height:\n\n// radius 1 pyramid (octahedron) centered at origin\n// which means the pyramids are 2 units wide\n// so the field should repeat every 4 units\n// so this should wind up being called with -2<=q<=2\nfloat pyramids(vec3 q)\n{\n    q.xz = mod(q.xz + 9., 4.) - 2.;\n    q.xz = abs(q.xz);\n    //float dp = (dot(q, vec3(1.)) - 1.) * sqrt(.33); // diamond shaped (rotated 45 degrees)\n    float dp = (q.y + max(q.x,q.z) - 1.) * sqrt(.5); // square shaped\n    if (q.y > max(q.x,q.z) + 1.) dp = length(q-vec3(0,1,0));\n    return min(dp, q.y); // anyway this is almost a true proper sdf, except for edge regions\n}\n// the point is that if the distance calculations are more accurate,\n// the ray marcher can be tuned much more aggressively\n// to trust the distance information more.\n// to do steps better, should make a special shape for it based on box.\n\n// Considering folding space more cleverly but it would confuse even me.  Maybe later.\n\nfloat sdf(vec3 p)\n{\n    return pyramids(p);\n//    return sdf_old(p);\n}\n\n// TODO iq's tetrahedral gradient is better; so far that's just not an issue.\nvec3 sdfnormal(vec3 p)\n{\n    vec2 eps = vec2(0.002, 0); // not too small, beware inaccuracies in far distance\n    vec3 n = vec3( // forward is fine if eps is small enough\n       sdf(p + eps.xyy),\n       sdf(p + eps.yxy),\n       sdf(p + eps.yyx)) - sdf(p);\n   return normalize(n);\n}\n\n// FIXME why put this here and then only use it in the one place, though?\n// just make an anon struct variable, don't bother declaring a named type?\n// structs are fine, but I had an idea; why not just use mat3x2 as a ray?\n// or is it mat2x3?  conventions! agh!\n// I fear ray[0] and ray[1] aren't as self-documenting as ray.o and ray.d though.\n// I am unsure if glsl will allow referring to matrix rows by xyz letter instead of array index.\n// If so, ray.x and ray.y would be somewhat better, I suppose.\n// .stpq has some letters also, but ray.s and ray.t seem confusing too.\nstruct Ray3 \n{\n    vec3 o, d; // origin and direction vectors\n};\n\n// here's where my ray marcher technique diverges from most everybody else's:\n\n// I like simply finding the nearest zero (in positive direction) of\n// a one-dimensional parametric function of the query ray.\n// So my \"ray marcher\" truly is just a root-finder.  \n// And all of those ancient 1D root-finding algorithms apply.\n// Most aren't very robust against local minima, though,\n// so beware noisy fields and broken sdf functions.\n    \n// I tend to go back-and-forth using argument names x versus t\n// because raymarching tends to use t where rootfinding tends to use x.\n    \n// There aren't any first-order functions in glsl, so the only way to write generic algorithms\n// is to use macros, and they are not ideal.  There are many drawbacks.\n\n// I just thought of one way to avoid them in this case,\n// if I'm willing to hardcode the sdf function, anyway. \n// And that is to utilize global variables as parameters.\n// shader code runs single-threaded (within each thread) so this is no problem, actually.\nRay3 queryRay;\n\n// now bear with me, all of this is rather ad-hoc thrown together.\nvec3 queryAt(float t) \n{\n    return queryRay.o + queryRay.d * t;\n}\n\n// the parametric function of the ray;\n// given global queryRay and given index along it,\n// compute position along ray p and return sdf(p)\nfloat sdfQueryRay(float t)\n{\n    return sdf(queryAt(t));\n}\n\n// a single iteration of a linear bracketed root finder algorithm aka regula falsi;\n// Linearly interpolate the position of a root between two known values on either side\n// returns mix factor to use between original two points\n// v0 = sdf(x0) and v1 = sdf(x1), then xRoot ~= mix(x0, x1, FalsePositionEstimate(v0, v1))\n// x0 and x1 *must* bracket the root, so v0 and v1 must have opposite signs or be zero.\n// takes two samples from field and returns interpolation factor between them where zero is likely to be found\nfloat FalsePositionEstimate(float v0, float v1)\n{\n\tfloat l = v0 - v1; \n\treturn abs(l) < 1e-24 ? .5 : v0 / l;\n}\n\nvec2 sdfqrFalsePositionStep(inout float x0, inout float x1, inout float v0, inout float v1)\n{\n    float u = FalsePositionEstimate(v0, v1);\n    float x = mix(x0, x1, u); // new guess\n    float d = sdfQueryRay(x); // NOTE function is hardcoded.  maybe I can make a small enough part of this into a macro.\n\tif (d < 0. == v0 < 0.)\n        v0 = d, x0 = x;\n\telse\n        v1 = d, x1 = x;\n    return vec2(x, d);\n}\n// result.x should then be between input x0 and x1, and closer than either.\n// result.y is the function's value at the new point result.x\n// on exit, either x0 or x1 will now contain the return value.x, and the extent should have shrunk.\n// post-result bracketing situation *should* be an improvement.\n// at some point you can stop calling it, and just use the midpoint of the remaining bracket.\n\n// now all that remains is to call it, perhaps repeatedly, until satisfied\n\n// my other codebase doesn't do it like this.  adds a layer though.  should explain better TODO\n// ...could return the point itself with return pos, but I'd rather have the mu factor so caller can interpolate between the input points\n// or do something else if it needs a ray index, for instance.  If I returned a point they'd have to do extra work (sub, dot)\n// to find the index again but if they needed the point, a RayAt is cheap. (mul, add)  However we already computed the point.\n\n// tol should be a tiny epsilon threshold for your error tolerance;\n// smaller magnitudes count as close enough to zero to be the final root location.\n// making it large keeps iteration count down.\n// usually even a few iterations does wonders.\nfloat sdfqrFalsePosition(inout float p0, inout float p1, inout float v0, inout float v1, int niter, float tol)\n{\n\tfloat x;\n    for (int i = niter; i-- > 0; ) {\n        vec2 r = sdfqrFalsePositionStep(p0, p1, v0, v1);\n        x = r.x;\n        if (abs(r.y) < tol) break;\n    }\n    return x;\n}\n// should already have the values at p0 and p1; call them v0 and v1.\n// float v0 = sdfQueryRay(p0), v1 = sdfQueryRay(p1);\n\n// that should handle the final step.  Now for getting past \n// the (nearest) root as quickly as possible!\n// without overshooting and missing it.\n\n// t is ray index into queryRay\n// d should be sdfQueryAt(t)\n// ot is t at prior step\n// od is d at prior step aka sdfQueryAt(ot)\n// r is a scale factor relating progress along t to the d value; usually somewhere around .9 works well for sdfs.\n// a is a minimum step size and determines the fine structure scale where details won't be skipped.\n// yes I realize these names are horrible, but I'm just getting this working.\nvoid sdfQueryRayStep(inout float t, inout float d, inout float ot, inout float od, float i, float r, float a)\n{\n    float t0 = t, d0 = d; //, ot0 = ot, od0 = od; // copy input values for later\n    float p = .5f * d / od;\n    float s = 1e-4 + d * r; /* * (.5\n\t\t+ .25f * p // \n\t\t+ .25f * i // overestimate more as we run out of iterations (i almost 1)\n\t\t);*/\n     t += max(s, a); // TODO a better function of the available data\n    d = sdfQueryRay(t);\n    ot = t0, od = d0;\n}\n\n// for sdf argument t, anything not >= 0 is a miss.\nbool isHit(float t)\n{\n    return t >= 0.; //&& !isnan(t); // false for nan or any negative value\n}\n// so could use -infinity, NaN (!) or something else as the missed value.\n// except apparently certain shader subsystems (GLES?) do not support proper IEEE nan comparisons\n// so be careful anyway, you probably should use isnan(result) to be sure.\n\n// the raymarcher algorithm itself doesn't need to know anything about the ray\n// and can instead be a rootfinder of a one-dimensional parametric function of the ray.\n// keeping the 3d portion decoupled from the rootfinder, which can remain 1d,\n// simplifies the rootfinder immensely.  We're not doing conjugate gradient descent\n// or anything which would need the full gradient, and I intend to \n// suffice with a local directed estimate based on prior values, \n// pretty much exactly like secant and Newton methods do, just slightly different.\n// in fact, with this interface, or maybe an extra variable, I believe I could \n// probably tune this to implement either method.\n// I just now threw this together and got it working,\n// so the exit condition logic is probably yet clumsy; wip.\n// TODO knowing the expected scale difference between t and d would help tremendously.\n// it can be refined incrementally as we go, I suppose.\n// It could be left up to the programmer to arrange it such that the \n// sdf and queryRay are both in the same scale as t.\n// in that case, queryRay.d may not be unit length, \n// but its magnitude would indicate the scale.\nfloat sdfqrRayMarch(vec3 ro, vec3 rd, float rate, int iter)\n{\n    queryRay.o = ro, queryRay.d = rd;\n    float rit = 1. / float(iter);\n    float ret = -1.; // \"missed\". see isMiss.\n    float t = .0, t1 = -1e-9, d = sdfQueryRay(t);\n    float d1 = d + 1e-9; // d1 is just a wild guess at the value of sdfQueryRay(t1); shouldn't matter a whole lot but does influence the size of the first step, probably.\n    do {\n        if (d <= .0) {\n        \tt = sdfqrFalsePosition(t, t1, d, d1, 4, 5e-4);\n            ret = t;\n            break;\n        }\n        // loop counter is a useful progress indicator fraction etc.\n        sdfQueryRayStep(t, d, t1, d1, float(iter)*rit, rate, 9e-4); //1e-3); //5e-4); //\n    } while (iter-- > 0);\n    return ret;\n}\n        //    t = sdfqrFalsePositionStep(t, t1, d, d1).x; // just one step isn't usually quite enough; you can try it.\n\nfloat tracePlane(float h, float d)\n{\n    return h / -d; // 1D slope+intercept stuff\n}\n// raytrace Y==0 plane precisely\nfloat tracePlaneY(vec3 ro, vec3 rd)\n{\n    return rd.y >= 0. ? 1e9 :\n        tracePlane(ro.y, rd.y);\n}\n// TODO need tmax arg, limit max trace distance; really, lo, hi range would be nice\nfloat raymarch(vec3 ro, vec3 rd, int nsteps)\n{\n    float t = sdfqrRayMarch(ro, rd, .975, nsteps);\n//  if (!isHit(t)) t = tracePlaneY(); // HACK rescue march failures? let's not.\n\treturn t;\n}\n\nfloat rayshadow(vec3 ro, vec3 rd, int nsteps)\n{\n    if (rd.y <= 0. || ro.y <= 0.) return 1.;\n    float t = sdfqrRayMarch(ro, rd, 1.5, nsteps);\n\treturn t >= 0. ? 0. : 1.; // hard shadows atten\n}\n\n// I'm trying to avoid such aids, but for quality and performance, \n// it's best to avoid marching any space that isn't absolutely necessary,\n// so clip the trace to the slab where the pyramids can actually be found:\n// early outs avoiding the march completely should help perf looking at sky.\nfloat raymarchSlabY(vec3 ro, vec3 rd, float tmin, float tmax, int nsteps)\n{\n    if (!isHit(tmax)) return -1.; // sky early out\n    if (tmax == 0.) //||ro.y <= 0.\n        return 0.; // ro is under the zero plane\n    // FIXME need a max distance so it knows when to stop\n    float t = raymarch(ro + rd*tmin, rd, nsteps);\n    return isHit(t) ? t + tmin : tmax; // now tmax is jacked FIXME\n}\n\n// returns lo,hi in x,y\n// pretty sure I solved this way mo better in Trace 2D toy\nvec2 limitRayToSlabY(vec3 ro, vec3 rd, float h)\n{\n    if (ro.y <= 0.)\n        return vec2(0); // ro is under the plane\n    float ofs = 0.;\n   float t;\n        t = tracePlaneY(ro, rd); //ro.y / -rd.y; // HACK special case to rescue all the march failures? or should we do that first to limit the trace extent?\n    // could easily do the top plane afterward here\n    if (ro.y > h) {\n        ofs = t + h / rd.y;\n    }\n    return vec2(ofs, t);\n}\n\n// new & improved refactor\nfloat raymarchSlabY(vec3 ro, vec3 rd, int nsteps)\n{\n\tvec2 lim = limitRayToSlabY(ro, rd, hPyramid);\n    return raymarchSlabY(ro, rd, lim.x, lim.y, nsteps);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// fog really needs shadows, but it's insane to\n// try to march towards light on each step;\n// this is where caching to a shadow depth buffer helps tremendously.\n\n// TODO Buffer B is supposed to be the shadow buffer\n// but it's got 2 more channels we can use, so\n// I'm thinking about tracing the main scene too\n// and storing *it's* depth, so I can do\n// DoF blurs etc. in main Image scene.\n// maybe even CoC in yet another pass?\n#define BufferC   iChannel0 \n//#define NoiseTex1 iChannel1\n// blowing dust shadows?\n\nvec4 loadValue(int slot_id)\n{\n    return texelFetch(BufferC, slotloc(slot_id), 0);\n}\n\nvec3 cameraPosition() \n{\n    return loadValue(slotCameraPosition).xyz;\n}\n\nvec3 cameraDirection() \n{\n    return loadValue(slotCameraForward).xyz;\n}\n\nvec3 lightOrigin() \n{\n    return loadValue(slotLightOrigin).xyz;\n}\n\nfloat shadowDepth(vec2 p, vec3 so, vec3 sd)\n{\n    int nststeps = 64; //80; //48; //\n    nststeps += UZERO;// TODO?\n    float ts = raymarchSlabY(so, sd, nststeps); // cheating, though, a bit\n    if (!isHit(ts)) // && sd.y < 0.)\n        ts = 200.;\n    return ts;\n}\n\nfloat mainDepth(vec2 p, vec3 ro, vec3 rd)\n{\n    // but we should be able to get away with much fewer steps, imho - like 64 or so should be decent.\n    // Yeah but to get anywhere near the horizon, we need quite a few steps, like 256.\n    // yeah these are heightfields, not true sdfs, but still mostly linear, just has some kinks.\n    int nsteps = 128; //160; //192; //256; //512; //32; // \n    nsteps += UZERO; // HACK prevent unwise compiler loop unrolling? not helping though.\n    float t = raymarch(ro, rd, nsteps);\n  //  float t = raymarchSlabY(ro, rd, nsteps); // cheating, though, a bit.  Now giving me NaNs if camera goes high enough.  ugh!\n//    if (!(t>=0.) && rd.y < 0.) { t = min(200., ro.y / -rd.y); } // and this test isn't catching the NaN either. :(  GLES doesn't have IEEE comparisons?\n    bool is_hit = (t >= 0.) && !isnan(t); //isHit(t); //\n   #if 1 \n    // HACK rescue rays aiming downward (here)\n    if (!is_hit && rd.y < 0.) { \n        t = min(200., ro.y / -rd.y); is_hit = true; \n    }\n   #endif\n    if (!is_hit)\n        t = -1.; // ensure not storing some nan in the buffer so Image pass needn't worry\n    return t;\n}\n\nvec2 computeDepths(vec2 p)\n{\n    float tmain = -1., tshadow = -1.;\n\n    float snoize = rand(p.xy/4.);\n    vec2 q = StoQ(p, iResolution.xy);\n     \n  #if 0\n    // main depth buffer prepass\n\t// create view ray - it's critical this match the main pass camera setup.\n    // if it weren't for the loading from buffers, I'd move it all to Common.\n    vec3 ro = cameraPosition(), rd = cameraRayDir(q, cameraDirection());\n    ro += .005 * snoize * rd;\n    tmain = mainDepth(p, ro, rd);\n  #endif\n    \n  #if 0\n    // shadowmap\n    vec3 so = lightOrigin(), sd = lightRayDir(q, -lightDir);\n    tshadow = shadowDepth(p, so, sd);\n  #endif\n\n    return vec2(tshadow, tmain);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    if (iFrame < 3) return;\n    c = vec4(computeDepths(p), 0., 1.);\n}\n\n// TODO tracing fog for self-shadowing purposes when it becomes opaque? idk. hard to get quality right.\n\n //   mat3 mshadow = cameraMatrix(sd);\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// see https://shadertoy.com/view/WlVGDh, a simplified debug camera based on this\n\n// BufferC controls the state, mostly the camera location+direction\n\n#define BufferC   iChannel0\n#define Keyboard  iChannel1\n\nconst float moverate = .3; // tuned so that 1x1x.5 pyramids appear quite big; actually very slow for a real scene.\nconst float turnratemouse = .02; // since mouse can't go outside window, must be pretty fast\nconst float turnratekbd = 2.6;\n\nvec2 oldMouse() \n{\n    return vec2(loadValue(BufferC, slotCameraPosition).w, loadValue(BufferC, slotCameraForward).w);\n}\n\nvec3 cameraDirectionCapture() \n{\n    return loadValue(BufferC, slotCameraForwardClick).xyz;\n}\n\nvec3 lightOrigin() \n{\n    return loadValue(BufferC, slotLightOrigin).xyz;\n}\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = texelFetch(Keyboard, ivec2(vk,0), 0).x; // read keyboard key state from texture\n    return step(.5, s); //s > .5 ? 1. : 0.; // test if down\n}\n\nbool asleep() // in shadertoy.com shader browser thumbnail? \n{\n    return length(iMouse.xy) < .5;\n}\n\n// may not be the best debug camera controller ever,\n// but it's the best I can do in ShaderToy so far.\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition(BufferC);\n    float fw = key(KEY_W);\n    float lf = key(KEY_A);\n    float rt = key(KEY_D);\n    float bw = key(KEY_S);\n    float up = key(KEY_SPACE);\n    float dn = key(KEY_C); // anything but control!\n    if (asleep()) fw = .5; // automate forward in thumbnails\n    vec3 camfwd = cameraDirection(BufferC);\n    mat3 camori = cameraMatrix(camfwd);\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 2.0; // shift key for speed boost\n    campos += camori * cammove;\n    const float camradius = .04;\n    campos += sdfnormal(campos) * -min(sdf(campos) - camradius, .0); // collision with sdf\n    return campos;\n}\n\n// It used to reset on each mouse down, to +Z axis, on each click.\n// wound up having to save an old camera facing state too.\n// honestly the best solution may be to avoid routing everything through direct mouse control\n// and implementing the camera rotation better.\n// seriously, I usually avoid Euler angles so idk why I'm decomposing back to spherical every frame.  lazy.\n// at least I can easily solve the upside-down problems this way.\n// working directly on the forward vector tends to require more guards against flipping.\n// I suppose could make everything relative incl. mouse - currently everything absolute\n// if I did, maybe I could make shiftmod apply to mouse steering!\n// but really, don't work on this; go fix Debug Camera, then port the changes back here.\nvec3 cameraSteering(bool shift)\n{\n    vec3 ocf = cameraDirection(BufferC);\n    vec3 camfwd = ocf;\n    vec3 camcache = cameraDirectionCapture();\n    bool lmb = iMouse.z >= 0.;\n    bool rot = false;\n    float shiftmod = shift ? 2. : 1.;\n    vec2 orbit = vec2(atan(camcache.x, camcache.z),asin(camcache.y));  // cartesian to spherical    \n    if (asleep())  // attract mode - FIXME idk why so jerky.\n    \torbit.x += iTimeDelta * turnratekbd * -.75 * 0., rot = true; // automate left\n    else if (lmb) {\n        vec2 m = (iMouse.xy - iMouse.zw);\n        orbit += m * turnratemouse, rot = true;\n    } else {\n    \tfloat aL = key(KEY_LEFT), aR = key(KEY_RIGHT), aU = key(KEY_UP), aD = key(KEY_DOWN);\n        vec2 m = vec2(aR - aL, aU - aD);\n        orbit += m * iTimeDelta * turnratekbd * shiftmod, rot = dot(m,m) != 0.;\n    }\n    orbit.y = clamp(orbit.y, -.5*pi, .5*pi);\n    if (rot) {\n        float cy = cos(orbit.y); // spherical to cartesian\n        camfwd = vec3(cy*sin(orbit.x), sin(orbit.y), cy*cos(orbit.x));        \n    }\n    // smoothing filter\n    if (!asleep())\n    camfwd = normalize(mix(camfwd, ocf, exp2(-64.*iTimeDelta)));\n    return camfwd;\n}\n\n// implements a debugging fly camera using keyboard WASD + mouse + C/space\n// stores camera position,aim into Buffer A as a color coded vector\nvoid debugFlyCamera(out vec4 c, vec2 p)\n{    \n    ivec2 ip = ivec2(p); //-.5);\n    if (!(ip.y == 0 && ip.x < slotCount)) return;\n    c = loadValue(BufferC, ip.x); //vec4(0, 0, 0, 1); // passthru by default?\n    bool shift = key(KEY_SHIFT) > .5;\n    bool lmb = iMouse.z >= 0.;\n    bool init = iFrame < 3; //iFrame == 0; // thumbnail issues\n    switch (slotid(ip)) {\n      case slotCameraPosition: {\n \t    c.xyz = init ? vec3(-.5,.25,-.5) : cameraMovement(shift);            \n        if (!lmb) c.w = iMouse.x;\n        break;\n      }\n      case slotCameraForward: {\n        c.xyz = init ? vec3(0.,0.,-1.) : cameraSteering(shift);\n        if (!lmb) c.w = iMouse.y;\n        break;\n      }\n      // pardon me, I'm trying to fix the click reset orientation problem\n      // well, that did it, but I'm not happy with the fix.\n      case slotCameraForwardClick: {\n        if (init) c.xyz = vec3(0.,0.,-1.);\n        else if (!lmb) //iMouse.xy == -iMouse.zw)\n            c.xyz = cameraDirection(BufferC); // capture\n        break;\n      }\n      case slotLightOrigin: {\n        c.xyz = cameraPosition(BufferC) + lightDir * 1.;\n    //    c.xyz = mod(c.xyz,.03125); // snap helps appease jerkiness\n      \tbreak;\n      }\n      default:\n        break;\n    }\n}\n\n\nvoid mainImage(out vec4 c, vec2 p)\n{    \n    debugFlyCamera(c, p);\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}