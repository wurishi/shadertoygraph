{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/* macro */\n#define F 1.0\n#define R 2.0\n#define B 3.0\n#define L 4.0\n#define U 5.0\n#define D 6.0\n\n/* constant */\n\n// about raymarch\nconst int MAX_STEPS = 256; // 最长射线步长\nconst float MIN_DIST = 0.0; // 最小射线距离\nconst float MAX_DIST = 50.0; // 最大射线距离\nconst float PRECISION = 0.0001; // 命中精度值\n\n// about object\nconst float SPHERERADIUS = 1.5; // 球体半径\nconst float BOXRADIUS = 0.1; // 圆角弧度\nconst float FRAMESIZE = 0.50; // 框架的宽度\nconst float FRAMEWIDTH = 0.05; // 框架的厚度\nconst float SLICESIZE = FRAMESIZE - FRAMEWIDTH; // 贴片的宽度，为了完整贴到框架上，贴片宽度是框架宽度-框架厚度\nconst float SLICEWIDTH = 0.1; // 贴片的厚度，太小不明显，太大很丑\nconst float OFFSET = FRAMESIZE - 0.04; // 位移距离，为了内嵌效果需要减小\nconst float PLANEHEIGHT = FRAMESIZE * 3.0 * 2.0; // 地板距离中心的距离，3.0是魔方的整体高度，2.0是让魔方和地板之间隔一个魔方高度\n\n// about light\nconst float ALPHA = 3.0; // 高亮程度\nconst vec3 BGCOLOR = vec3(0.980,0.713,0.756); // 背景颜色，粉色，不属于魔方颜色，增加对比度\n\n// about math\nconst float INFINITY = 1000.0; // 大值，用于比较\nconst float EPSILON = 0.0005; // 小值，用于计算梯度\nconst float PI = 3.1415926; // 圆周率\n\n// about speed\nconst float ROTSPEED = 1.5;    // 旋转速度\nconst float TRUNSPEED = 3.5; // 鼠标旋转速度\n\n/* --------------------------------------------------------—------------------ */\n\n/* rotate 部分 */\n\n// 三维旋转，用于旋转相机，从而实现旋转魔方整体\nmat3 rot3D(vec3 axis, float angle) {\n    float c = cos(angle); float s = sin(angle); float t = 1.0 - c;\n    float x = axis.x; float y = axis.y; float z = axis.z;\n    // 逆时针旋转\n    return mat3(\n        t * x * x + c,        t * x * y - s * z,    t * x * z + s * y,\n        t * x * y + s * z,    t * y * y + c,        t * y * z - s * x,\n        t * x * z - s * y,    t * y * z + s * x,    t * z * z + c\n    );\n}\n\n// 绕x轴旋转\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\n\n// 绕y轴旋转\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// 绕z轴旋转\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// 通过鼠标来实现相机位置改变\nmat3 rotCamera() {\n    // 获取鼠标坐标\n    vec2 mouse = iMouse.xy / iResolution.xy - vec2(0.5);\n\n    // 得到鼠标移动代表的旋转角度\n    float rotAngleX = -mouse.x * TRUNSPEED;\n    float rotAngleY = mouse.y * TRUNSPEED;\n\n    // 计算相机绕x轴和y轴的旋转矩阵\n    mat3 camrotX = rot3D(vec3(0., 1., 0.), rotAngleX);\n    mat3 camrotY = rot3D(vec3(1., 0., 0.), rotAngleY);\n\n    return camrotX * camrotY;\n}\n\n// 魔方某一层旋转\nvoid rotRubik(inout vec3 p, float side, float angle, float num) {\n    p = (side == F) ? rotateZ(angle * num * step(FRAMESIZE, p.z)) * p   :\n        (side == R) ? rotateX(angle * num * step(FRAMESIZE, p.x)) * p   :\n        (side == B) ? rotateZ(-angle * num * step(FRAMESIZE, -p.z)) * p :\n        (side == L) ? rotateX(-angle * num * step(FRAMESIZE, -p.x)) * p :\n        (side == U) ? rotateY(-angle * num * step(FRAMESIZE, p.y)) * p  :\n        (side == D) ? rotateY(angle * num * step(FRAMESIZE, -p.y)) * p  :\n                      p;\n}\n\n/* --------------------------------------------------------—------------------ */\n\n/* animation 部分 */\n\n// 对称棋盘：L2 R2 F2 B2 U2 D2\nvoid twist1(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, L, rotAngles[15], 2.0);\n    rotRubik(p, R, rotAngles[14], 2.0);\n    rotRubik(p, F, rotAngles[13], 2.0);\n    rotRubik(p, B, rotAngles[12], 2.0);\n    rotRubik(p, U, rotAngles[11], 2.0);\n    rotRubik(p, D, rotAngles[10], 2.0);\n\n    rotRubik(p, D, rotAngles[5], 2.0);\n    rotRubik(p, U, rotAngles[4], 2.0);\n    rotRubik(p, B, rotAngles[3], 2.0);\n    rotRubik(p, F, rotAngles[2], 2.0);\n    rotRubik(p, R, rotAngles[1], 2.0);\n    rotRubik(p, L, rotAngles[0], 2.0);\n}\n\n// 六面回字：U' D F' B L R' U' D\nvoid twist2(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, U, rotAngles[17], -1.0);\n    rotRubik(p, D, rotAngles[16], 1.0);\n    rotRubik(p, F, rotAngles[15], -1.0);\n    rotRubik(p, B, rotAngles[14], 1.0);\n    rotRubik(p, L, rotAngles[13], 1.0);\n    rotRubik(p, R, rotAngles[12], -1.0);\n    rotRubik(p, U, rotAngles[11], -1.0);\n    rotRubik(p, D, rotAngles[10], 1.0);\n\n    rotRubik(p, D, rotAngles[7], 1.0);\n    rotRubik(p, U, rotAngles[6], -1.0);\n    rotRubik(p, R, rotAngles[5], -1.0);\n    rotRubik(p, L, rotAngles[4], 1.0);\n    rotRubik(p, B, rotAngles[3], 1.0);\n    rotRubik(p, F, rotAngles[2], -1.0);\n    rotRubik(p, D, rotAngles[1], 1.0);\n    rotRubik(p, U, rotAngles[0], -1.0);\n}\n\n// 六面彩条：F2 U2 F2 B2 U2 F B\nvoid twist3(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, F, rotAngles[16], 2.0);\n    rotRubik(p, U, rotAngles[15], 2.0);\n    rotRubik(p, F, rotAngles[14], 2.0);\n    rotRubik(p, B, rotAngles[13], 2.0);\n    rotRubik(p, U, rotAngles[12], 2.0);\n    rotRubik(p, F, rotAngles[11], 1.0);\n    rotRubik(p, B, rotAngles[10], 1.0);\n\n    rotRubik(p, B, rotAngles[6], 1.0);\n    rotRubik(p, F, rotAngles[5], 1.0);\n    rotRubik(p, U, rotAngles[4], 2.0);\n    rotRubik(p, B, rotAngles[3], 2.0);\n    rotRubik(p, F, rotAngles[2], 2.0);\n    rotRubik(p, U, rotAngles[1], 2.0);\n    rotRubik(p, F, rotAngles[0], 2.0);\n}\n\n// 六面T字：U2 F2 R2 D U' L2 B2 D U\nvoid twist4(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, U, rotAngles[18], 2.0);\n    rotRubik(p, F, rotAngles[17], 2.0);\n    rotRubik(p, R, rotAngles[16], 2.0);\n    rotRubik(p, D, rotAngles[15], 1.0);\n    rotRubik(p, U, rotAngles[14], -1.0);\n    rotRubik(p, L, rotAngles[13], 2.0);\n    rotRubik(p, B, rotAngles[12], 2.0);\n    rotRubik(p, D, rotAngles[11], 1.0);\n    rotRubik(p, U, rotAngles[10], 1.0);\n\n    rotRubik(p, U, rotAngles[8], 1.0);\n    rotRubik(p, D, rotAngles[7], 1.0);\n    rotRubik(p, B, rotAngles[6], 2.0);\n    rotRubik(p, L, rotAngles[5], 2.0);\n    rotRubik(p, U, rotAngles[4], -1.0);\n    rotRubik(p, D, rotAngles[3], 1.0);\n    rotRubik(p, R, rotAngles[2], 2.0);\n    rotRubik(p, F, rotAngles[1], 2.0);\n    rotRubik(p, U, rotAngles[0], 2.0);\n}\n\n// 四面I字公式 R2 F2 R2 L2 F2 L2\nvoid twist5(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, R, rotAngles[15], 2.0);\n    rotRubik(p, F, rotAngles[14], 2.0);\n    rotRubik(p, R, rotAngles[13], 2.0);\n    rotRubik(p, L, rotAngles[12], 2.0);\n    rotRubik(p, F, rotAngles[11], 2.0);\n    rotRubik(p, L, rotAngles[10], 2.0);\n\n    rotRubik(p, L, rotAngles[5], 2.0);\n    rotRubik(p, F, rotAngles[4], 2.0);\n    rotRubik(p, L, rotAngles[3], 2.0);\n    rotRubik(p, R, rotAngles[2], 2.0);\n    rotRubik(p, F, rotAngles[1], 2.0);\n    rotRubik(p, R, rotAngles[0], 2.0);\n}\n\n// 六面凹字公式 F2 L' R B2 U2 L R' D2\nvoid twist6(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, F, rotAngles[17], 2.0);\n    rotRubik(p, L, rotAngles[16], -1.0);\n    rotRubik(p, R, rotAngles[15], 1.0);\n    rotRubik(p, B, rotAngles[14], 2.0);\n    rotRubik(p, U, rotAngles[13], 2.0);\n    rotRubik(p, L, rotAngles[12], 1.0);\n    rotRubik(p, R, rotAngles[11], -1.0);\n    rotRubik(p, D, rotAngles[10], 2.0);\n\n    rotRubik(p, D, rotAngles[7], 2.0);\n    rotRubik(p, R, rotAngles[6], -1.0);\n    rotRubik(p, L, rotAngles[5], 1.0);\n    rotRubik(p, U, rotAngles[4], 2.0);\n    rotRubik(p, B, rotAngles[3], 2.0);\n    rotRubik(p, R, rotAngles[2], 1.0);\n    rotRubik(p, L, rotAngles[1], -1.0);\n    rotRubik(p, F, rotAngles[0], 2.0);\n}\n\n// 六面L字公式 L R U D F' B' L R\nvoid twist7(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, L, rotAngles[17], 1.0); // L\n    rotRubik(p, R, rotAngles[16], 1.0); // R\n    rotRubik(p, U, rotAngles[15], 1.0); // U\n    rotRubik(p, D, rotAngles[14], 1.0); // D\n    rotRubik(p, F, rotAngles[13], -1.0); // F'\n    rotRubik(p, B, rotAngles[12], -1.0); // B'\n    rotRubik(p, L, rotAngles[11], 1.0); // L\n    rotRubik(p, R, rotAngles[10], 1.0); // R\n\n    rotRubik(p, R, rotAngles[7], 1.0); // R\n    rotRubik(p, L, rotAngles[6], 1.0); // L\n    rotRubik(p, B, rotAngles[5], -1.0); // U\n    rotRubik(p, F, rotAngles[4], -1.0); // D\n    rotRubik(p, D, rotAngles[3], 1.0); // F'\n    rotRubik(p, U, rotAngles[2], 1.0); // B'\n    rotRubik(p, R, rotAngles[1], 1.0); // L\n    rotRubik(p, L, rotAngles[0], 1.0); // R\n}\n\n// 四面E字公式 R2 U2 F2 R2 U2 R2 F2 U2\nvoid twist8(inout vec3 p, float rotAngles[20]) {\n    rotRubik(p, R, rotAngles[17], 2.0);\n    rotRubik(p, U, rotAngles[16], 2.0);\n    rotRubik(p, F, rotAngles[15], 2.0);\n    rotRubik(p, R, rotAngles[14], 2.0);\n    rotRubik(p, U, rotAngles[13], 2.0);\n    rotRubik(p, R, rotAngles[12], 2.0);\n    rotRubik(p, F, rotAngles[11], 2.0);\n    rotRubik(p, U, rotAngles[10], 2.0);\n\n    rotRubik(p, U, rotAngles[7], 2.0);\n    rotRubik(p, F, rotAngles[6], 2.0);\n    rotRubik(p, R, rotAngles[5], 2.0);\n    rotRubik(p, U, rotAngles[4], 2.0);\n    rotRubik(p, R, rotAngles[3], 2.0);\n    rotRubik(p, F, rotAngles[2], 2.0);\n    rotRubik(p, U, rotAngles[1], 2.0);\n    rotRubik(p, R, rotAngles[0], 2.0);\n}\n\n// 处理键盘输入值\nvoid handleKeyboard(inout vec3 p){\n    // 获取缓冲区\n    vec4 bufferA = texelFetch(iChannel0, ivec2(1, 1), 0);\n    vec4 bufferB = texelFetch(iChannel1, ivec2(1, 1), 0);\n\n    // 当前到按下键盘相隔的时间\n    float time = iTime - bufferA.x;\n\n    // 周期时间偏移量\n    float timeOffset = mod(time*ROTSPEED, PI*10.0);\n\n    // 计算累计旋转角度\n    float rotAngles[20];\n    float j = 0.0;\n    for(int i = 0; i < 20; i++) {\n        float s = i <= 9 ? 1.0 : -1.0; \n        rotAngles[i] = s * PI / 2.0 * smoothstep(j*PI, (j+0.5)*PI, timeOffset);\n        j += 0.5;\n    }\n\n    // 根据键盘输入判断旋转类型\n    float twist_id = bufferA.y;\n    if (twist_id == 0.0) return ; // 复原，静止\n    else if (twist_id == 1.0) twist1(p, rotAngles); // 对称棋盘\n    else if (twist_id == 2.0) twist2(p, rotAngles); // 六面回字\n    else if (twist_id == 3.0) twist3(p, rotAngles); // 六面彩条\n    else if (twist_id == 4.0) twist4(p, rotAngles); // 六面T字\n    else if (twist_id == 5.0) twist5(p, rotAngles); // 四面I字\n    else if (twist_id == 6.0) twist6(p, rotAngles); // 六面凹字\n    else if (twist_id == 7.0) twist7(p, rotAngles); // 六面L字\n    else if (twist_id == 8.0) twist8(p, rotAngles); // 四面E字\n    //else if (twist_id == 9.0) twist9(p, rotAngles); // 保留\n    \n    // 用户自定义的twist\n    else if (twist_id == 10.0) {\n        float seq[3];\n        seq[0] = bufferB.x;\n        seq[1] = bufferB.y;\n        seq[2] = bufferB.z;\n        timeOffset = iTime - bufferB.w;\n        bool flag = true;\n        for (int i=2; i>=0; i--) {\n            if (seq[i] == 0.0) continue;\n            while (seq[i] != 0.0) {\n                // 不断解码得到最低位数字\n                float side = floor(mod(seq[i], 10.0));\n                seq[i] = floor(seq[i] / 10.0);\n                // 最后一个旋转要慢速\n                if (flag) {\n                    rotRubik(p, side,  PI / 2.0 * smoothstep(0.0, 0.5, timeOffset), 1.0);\n                    flag = false;\n                }\n                else \n                    rotRubik(p, side, PI / 2.0, 1.0);\n            }\n        }\n    }\n}\n\n// 决定方块每一面的颜色\nvec3 calColor(vec3 p) {\n    return (p.z > FRAMESIZE * 3.0)  ? vec3(1.0, 0.1, 0.1) : // 前面红色\n           (p.x > FRAMESIZE * 3.0)  ? vec3(0.1, 0.1, 1.0) : // 右面蓝色\n           (p.z < -FRAMESIZE * 3.0) ? vec3(0.9, 0.4, 0.1) : // 后面橙色\n           (p.x < -FRAMESIZE * 3.0) ? vec3(0.8, 0.8, 0.8) : // 左面白色\n           (p.y > FRAMESIZE * 3.0)  ? vec3(0.1, 1.0, 0.1) : // 上面绿色\n           (p.y < -FRAMESIZE * 3.0) ? vec3(1.0, 0.9, 0.1) : // 下面黄色\n           vec3(0.2); // 里面灰色\n}\n\n/* --------------------------------------------------------—------------------ */\n\n/* sdf 部分 */\n\n// 地板\nfloat Plane(vec3 p, float r) {\n    return length(p.xz) < 30.0 ? p.y + r : INFINITY;\n}\n\n// 球面\nfloat Sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// 贴片\nfloat Slice(vec3 p, vec3 b, vec3 offset) {\n    p -= offset;\n    vec3 q = abs(p) - b + BOXRADIUS;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - BOXRADIUS;\n}\n\n// 方块贴片\nfloat BlockSlice(vec3 p) {\n    // 根据面来确定长宽高\n    float sliceFront_sd = Slice(p, vec3(SLICESIZE, SLICESIZE, SLICEWIDTH), vec3(0.0, 0.0, OFFSET));\n    float sliceBack_sd = Slice(p, vec3(SLICESIZE, SLICESIZE, SLICEWIDTH), vec3(0.0, 0.0, -OFFSET));\n    float sliceRight_sd = Slice(p, vec3(SLICEWIDTH, SLICESIZE, SLICESIZE), vec3(OFFSET, 0.0, 0.0));\n    float sliceLeft_sd = Slice(p, vec3(SLICEWIDTH, SLICESIZE, SLICESIZE), vec3(-OFFSET, 0.0, 0.0));\n    float sliceUp_sd = Slice(p, vec3(SLICESIZE, SLICEWIDTH, SLICESIZE), vec3(0.0, OFFSET, 0.0));\n    float sliceDown_sd = Slice(p, vec3(SLICESIZE, SLICEWIDTH, SLICESIZE), vec3(0.0, -OFFSET, 0.0));\n    // 组成贴片盒子\n    float blockSlice_sd = INFINITY;\n    blockSlice_sd = min(blockSlice_sd, sliceFront_sd);\n    blockSlice_sd = min(blockSlice_sd, sliceBack_sd);\n    blockSlice_sd = min(blockSlice_sd, sliceRight_sd);\n    blockSlice_sd = min(blockSlice_sd, sliceLeft_sd);\n    blockSlice_sd = min(blockSlice_sd, sliceUp_sd);\n    blockSlice_sd = min(blockSlice_sd, sliceDown_sd);\n    return blockSlice_sd;\n}\n\n// 方块框架\nfloat BlockFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\n/* --------------------------------------------------------—------------------ */\n\n/* surface 部分 */\n\n// 表面结构体\nstruct Surface {\n    float sd; // 射线到表面的有符号距离\n    vec3 col; // 表面的颜色\n};\n\n// 合并表面：返回具有极小 sdf 的物体\nSurface Union(Surface obj1, Surface obj2) {\n    if (obj1.sd < obj2.sd)\n        return obj1;\n    else\n        return obj2;\n}\n\n// 整个场景表面\nSurface Scene(vec3 p) {\n    // 保存原始p\n    vec3 p_ = p;\n\n    // 处理旋转和颜色\n    handleKeyboard(p);\n    vec3 slice_col = calColor(p);\n    \n    // 复制成27个小方块\n    p = abs(p) - vec3(FRAMESIZE);\n    p = abs(p) - vec3(FRAMESIZE);\n\n    /* 作用于上面相同\n    float sign_x, sign_y, sign_z;\n    sign_x = p.x > 0.0 ? -1.0 : 1.0;\n    sign_y = p.y > 0.0 ? -1.0 : 1.0;\n    sign_z = p.z > 0.0 ? -1.0 : 1.0;\n    p = p + vec3(FRAMESIZE * sign_x, FRAMESIZE * sign_y, FRAMESIZE * sign_z);\n    sign_x = p.x > 0.0 ? -1.0 : 1.0;\n    sign_y = p.y > 0.0 ? -1.0 : 1.0;\n    sign_z = p.z > 0.0 ? -1.0 : 1.0;\n    p = p + vec3(FRAMESIZE * sign_x, FRAMESIZE * sign_y, FRAMESIZE * sign_z);\n    */\n\n    // 获取物体的有符号距离\n    float plane_sd = Plane(p_, PLANEHEIGHT);\n    float sphere_sd = Sphere(p_, SPHERERADIUS);\n    float blockblockSlice_sd = BlockSlice(p);\n    float blockframe_sd = BlockFrame(p, vec3(FRAMESIZE), FRAMEWIDTH);\n\n    // 获取物体的颜色\n    Surface plane = Surface(plane_sd, vec3(0.1 + 0.7 * mod(floor(p_.x) + floor(p_.z), 2.0))); // 格子地板\n    Surface sphere = Surface(sphere_sd, vec3(0.2));\n    Surface blockslice = Surface(blockblockSlice_sd, slice_col);\n    Surface blockframe = Surface(blockframe_sd, vec3(0));\n    \n    // 合并物体\n    Surface scene = Surface(INFINITY, vec3(0));\n    scene = Union(scene, plane);\n    scene = Union(scene, sphere);\n    scene = Union(scene, blockslice);\n    scene = Union(scene, blockframe);\n\n    return scene;\n}\n\n/* --------------------------------------------------------—------------------ */\n\n/* raymarch 部分 */\n\n// 视图变换矩阵\nmat3 view(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 direct = normalize(lookAtPoint - cameraPos);\n    vec3 right = normalize(cross(vec3(0, 1, 0), direct));\n    vec3 up = normalize(cross(direct, right));\n    return mat3(-right, up, -direct);\n}\n\n// 射线步进算法\nSurface rayMarch(vec3 camera, vec3 sight, float marchSpeed) {\n    float depth = MIN_DIST;\n    Surface object;\n    for (int i=0; i < MAX_STEPS; i++) {\n        vec3 p = camera + depth * sight;\n        object = Scene(p);\n        depth += object.sd * marchSpeed;\n        if (object.sd < PRECISION || depth > MAX_DIST)\n            break;\n    }\n    object.sd = depth;\n    return object;\n}\n\n/* --------------------------------------------------------—------------------ */\n\n/* light 部分 */\n\n// 计算法向量\nvec3 calNormal(vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * Scene(p + e.xyy).sd +\n      e.yyx * Scene(p + e.yyx).sd +\n      e.yxy * Scene(p + e.yxy).sd +\n      e.xxx * Scene(p + e.xxx).sd);\n}\n\n// phong照射模型\nfloat phong(vec3 p, vec3 normal, vec3 lightDirection, vec3 sight, vec3 color) {\n    // 自然光强度\n    float ambient = 0.4;\n    // 漫反射强度\n    float diffuse = clamp(dot(lightDirection, normal), 0.0, 1.0);\n    // 镜面反射强度\n    float specular = pow(clamp(dot(reflect(lightDirection, normal), -sight), 0.3, 1.0), ALPHA);\n    // 混合光照\n    return ambient + diffuse + specular;\n}\n\n// 求阴影\nfloat rayShadow(vec3 p, vec3 normal, vec3 lightDirection, vec3 lightPosition) {\n    // 避免自阴影\n    vec3 new_p = p + normal * PRECISION * 2.0;\n    // 射线步进得到的最短距离\n    float shadowDepth = rayMarch(new_p, lightDirection, 0.9).sd;\n    // 从光源到物体表面的距离\n    float lightDistance = length(lightPosition - new_p);\n    // 判断是否在阴影范围内\n    return  shadowDepth < lightDistance \n        ? mix(0.3, 1.0, clamp(shadowDepth / lightDistance, 0.1, 1.0))\n        : 1.0;\n}\n\n/* --------------------------------------------------------—------------------ */\n\n// 渲染函数\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 切换坐标系\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // 缓冲区\n    vec4 bufferA = texelFetch(iChannel0, ivec2(1, 1), 0);\n    vec4 bufferB = texelFetch(iChannel1, ivec2(1, 1), 0);\n\n    // 相机位置\n    vec3 camera = vec3(4.0, 4.0, 5.6);\n    camera *= rotCamera();          // 根据鼠标旋转\n    camera *= rotateY(bufferA.w);     // 根据按键旋转\n    camera *= bufferA.z;              // 根据按键缩放\n    camera.y = camera.y <= -PLANEHEIGHT + 0.1 ? -PLANEHEIGHT + 0.1 : camera.y; // 防止跑到地板下面\n\n    // 用户自定义情况，只在旋转过程渲染，防止卡顿！\n    if (iTime - bufferB.w > 0.6 && bufferA.y == 10.0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return ;\n    }\n\n    // 聚焦位置\n    vec3 lookAtPoint = vec3(0, 0, 0);\n    // 射线方向\n    vec3 sight = view(camera, lookAtPoint) * normalize(vec3(uv, -1));\n\n    // 命中物体表面\n    Surface object = rayMarch(camera, sight, 0.25);\n\n    // 像素颜色\n    vec3 color = vec3(0);\n\n    // 如果没命中就是背景颜色\n    if (object.sd > MAX_DIST) {\n        //color = texture(iChannel2, sight).rgb;\n        color = BGCOLOR;\n    }\n\n    // 否则取物体表面颜色\n    else {\n        // 计算射线位置\n        vec3 p = camera + sight * object.sd;\n        // 光源位置\n        vec3 lightPosition = vec3(5, 15, 7);\n        // 光线\n        vec3 lightDirection = normalize(lightPosition - p);\n        // 法线\n        vec3 normal = calNormal(p);\n        \n        // 物体颜色\n        color = object.col;\n        // 光照效果\n        color *= phong(p, normal, lightDirection, sight, color);\n        // 阴影效果\n        color *= rayShadow(p, normal, lightDirection, lightPosition);\n        // 雾化效果\n        color = mix(color, BGCOLOR, 1.0 - exp(-0.00005 * pow(object.sd, 3.0)));\n        // 伽马矫正\n        color = pow(color, vec3(0.8));\n    }\n    // 输出管道\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// 定义热键对应的 ASCII 码\nconst int KEY_LEFT   = 37;\nconst int KEY_UP     = 38;\nconst int KEY_RIGHT  = 39;\nconst int KEY_DOWN   = 40;\nconst int KEY_0      = 48;\nconst int KEY_1      = 49;\nconst int KEY_2      = 50;\nconst int KEY_3      = 51;\nconst int KEY_4      = 52;\nconst int KEY_5      = 53;\nconst int KEY_6      = 54;\nconst int KEY_7      = 55;\nconst int KEY_8      = 56;\nconst int KEY_9      = 57;\nconst int KEY_ENTER  = 13;\n\n// 定义旋转和缩放的速度\nconst float rotationSpeed = 0.05;\nconst float zoomSpeed = 1.01;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 只处理 (0,0) 像素，用于初始化或特殊用途\n    if (int(fragCoord.x) != 1 || int(fragCoord.y) != 1) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // 初始化第一帧\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        return;\n    }\n\n    // 获取前一帧的数据\n    vec4 prevFrame = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 curFrame = prevFrame; // 默认继承前一帧的数据\n\n    // 从 iChannel1 获取键盘输入状态\n    // 假设 iChannel1 的 x 轴索引对应 ASCII 码，y=0 表示键是否按下（1.0 为按下，0.0 为未按下）\n    float key0      = texelFetch(iChannel1, ivec2(KEY_0, 0), 0).x;\n    float key1      = texelFetch(iChannel1, ivec2(KEY_1, 0), 0).x;\n    float key2      = texelFetch(iChannel1, ivec2(KEY_2, 0), 0).x;\n    float key3      = texelFetch(iChannel1, ivec2(KEY_3, 0), 0).x;\n    float key4      = texelFetch(iChannel1, ivec2(KEY_4, 0), 0).x;\n    float key5      = texelFetch(iChannel1, ivec2(KEY_5, 0), 0).x;\n    float key6      = texelFetch(iChannel1, ivec2(KEY_6, 0), 0).x;\n    float key7      = texelFetch(iChannel1, ivec2(KEY_7, 0), 0).x;\n    float key8      = texelFetch(iChannel1, ivec2(KEY_8, 0), 0).x;\n    float key9      = texelFetch(iChannel1, ivec2(KEY_9, 0), 0).x;\n    float keyEnter  = texelFetch(iChannel1, ivec2(KEY_ENTER, 0), 0).x;\n    float keyLeft   = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x;\n    float keyUp     = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x;\n    float keyRight  = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x;\n    float keyDown   = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x;\n\n    // 处理魔方图案的选择\n    if (key0 == 1.0)\n        curFrame.xy = vec2(iTime, 0.0);\n    else if (key1 == 1.0)\n        curFrame.xy = vec2(iTime, 1.0);\n    else if (key2 == 1.0)\n        curFrame.xy = vec2(iTime, 2.0);\n    else if (key3 == 1.0)\n        curFrame.xy = vec2(iTime, 3.0);\n    else if (key4 == 1.0)\n        curFrame.xy = vec2(iTime, 4.0);\n    else if (key5 == 1.0)\n        curFrame.xy = vec2(iTime, 5.0);\n    else if (key6 == 1.0)\n        curFrame.xy = vec2(iTime, 6.0);\n    else if (key7 == 1.0)\n        curFrame.xy = vec2(iTime, 7.0);\n    else if (key8 == 1.0)\n        curFrame.xy = vec2(iTime, 8.0);\n    else if (key9 == 1.0)\n        curFrame.xy = vec2(iTime, 9.0);\n    else if (keyEnter == 1.0)\n        curFrame.xy = vec2(iTime, 10.0);\n\n    // 处理相机缩放\n    if (keyUp == 1.0)\n        curFrame.z = max(prevFrame.z / zoomSpeed, 0.5);\n    else if (keyDown == 1.0)\n        curFrame.z = min(prevFrame.z * zoomSpeed, 2.0);\n    else\n        curFrame.z = prevFrame.z;\n\n    // 处理相机旋转\n    if (keyLeft == 1.0)\n        curFrame.w = prevFrame.w - rotationSpeed;\n    else if (keyRight == 1.0)\n        curFrame.w = prevFrame.w + rotationSpeed;\n    else\n        curFrame.w = prevFrame.w;\n\n    fragColor = curFrame;\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/* 宏定义 */\n#define F 1.0\n#define R 2.0\n#define B 3.0\n#define L 4.0\n#define U 5.0\n#define D 6.0\n\n/* 常量定义 (ASCII码) */\nconst int KEY_F = 70;\nconst int KEY_R = 82;\nconst int KEY_B = 66;\nconst int KEY_L = 76;\nconst int KEY_U = 85;\nconst int KEY_D = 68;\nconst int KEY_ENTER = 13;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 仅处理 (0,0) 像素，用于初始化或特殊用途\n    if (int(fragCoord.x) != 1 || int(fragCoord.y) != 1) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // 初始化第一帧或在按下 ENTER 键时重置\n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(KEY_ENTER, 0), 0).x == 1.0) {\n        fragColor = vec4(vec3(0.0), iTime);\n        return;\n    }\n       \n    // 读取键盘状态\n    float side = 0.0;\n    side = texelFetch(iChannel1, ivec2(KEY_L, 0), 0).x == 1.0 ? L :\n           texelFetch(iChannel1, ivec2(KEY_R, 0), 0).x == 1.0 ? R :\n           texelFetch(iChannel1, ivec2(KEY_U, 0), 0).x == 1.0 ? U :\n           texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x == 1.0 ? D :\n           texelFetch(iChannel1, ivec2(KEY_F, 0), 0).x == 1.0 ? F :\n           texelFetch(iChannel1, ivec2(KEY_B, 0), 0).x == 1.0 ? B :\n           0.0;\n    \n    // 获取前一帧的数据\n    vec4 prevFrame = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 curFrame = prevFrame; // 默认继承前一帧的数据\n    \n    // 根据按键更新状态\n    if (side != 0.0) {\n        if (prevFrame.x < 1000000.0)        \n            curFrame.x = prevFrame.x * 10.0 + side;\n        else if (prevFrame.y < 1000000.0)   \n            curFrame.y = prevFrame.y * 10.0 + side;\n        else if (prevFrame.z < 1000000.0)   \n            curFrame.z = prevFrame.z * 10.0 + side;\n        else                                \n            curFrame.xyz = vec3(0.0); // 超过限制，重置\n        curFrame.w = iTime;\n    }\n\n    fragColor = curFrame;\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4fyfzc","date":"1734259280","viewed":78,"name":"Dasi's Rubik","username":"dasi","description":"Get idea from zackpudil, https://www.shadertoy.com/view/3tf3R. Press keyboard 1-8 to to select different rotation pattern and 0 for restoration. Press LRFBUD to rotate rubik as you wish.\n","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["rubik"],"hasliked":0,"parentid":"","parentname":""}}