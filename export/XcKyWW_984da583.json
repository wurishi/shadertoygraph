{"ver":"0.1","info":{"id":"XcKyWW","date":"1732275271","viewed":270,"name":"In the Mouth of Madness","username":"darnok","description":"\"A reality is just what we tell each other it is. Sane and insane could easily switch places, if the insane were to become the majority. You would find yourself locked in a padded cell, wondering what happened to the world.\"","likes":21,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","corridor","madness","structure"],"hasliked":0,"parentid":"433SW7","parentname":"template raymarching"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265\n#define WALL_SPACE 2.\n#define WALL_THICKNESS 1.\n#define ARK_WALL_THICKNESS 0.15\n\n// Light position and color     https://www.shadertoy.com/view/XlBSRz\n#define LPOS vec3( 0., 0., 3.0+iTime*2.)\n#define LCOL (600.*vec3( 1.0, 0.9, 0.5))\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\n// Funtion Distance\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// scene part\nfloat brickWall(vec3 p, float side) { \n    float distFractZ = 0.25;\n    float distFractY = 0.2;\n    \n    float idBlockZ = p.z - (mod(p.z, distFractZ));\n    float idBlockY = p.y - (mod(p.y, distFractY));\n    \n    vec3 q = p;\n    q.z = mod(q.z, distFractZ) - (distFractZ / 2.);\n    q.y = mod(q.y, distFractY) - (distFractY / 2.);\n    \n    float xGap = side * abs(sin((idBlockY*20.+idBlockZ*15.+(side+1.)*5.)*0.5 + iTime*0.)) * 0.025;\n    return sdBox(q - vec3(side*WALL_SPACE + xGap, 0., 0.), vec3(WALL_THICKNESS, 1., 100.));   \n}\n\nfloat brickCeilCapsule(vec3 p) { \n    float distFractZ = 0.25;\n    float distFractX = 0.2;\n    \n    float idBlockZ = p.z - (mod(p.z, distFractZ));\n    float idBlockX = p.x - (mod(p.x, distFractX));\n    \n    vec3 q = p;\n    q.z = mod(q.z, distFractZ) - (distFractZ / 2.);\n    q.x = mod(q.x, distFractX) - (distFractX / 2.);\n    \n    float yGap = abs(sin((idBlockX*20.+idBlockZ*15.)*0.5 + iTime*0.)) * 0.025;\n    return sdCapsule(p + vec3(0., yGap, 0.), vec3(0., 1., -50.), vec3(0., 1., 50.), WALL_SPACE - WALL_THICKNESS);\n}\n\nfloat wallFloorCeil(vec3 p) {\n    float wallLeft = brickWall(p, -1.);    \n    float wallRight = brickWall(p, 1.);\n    \n    float ceilBox = sdBox(p - vec3(0., WALL_THICKNESS * 2., 0.), vec3(WALL_SPACE, WALL_THICKNESS, 100.));    \n    float ceilCapsule = brickCeilCapsule(p);\n    float ceil = opSubtraction(ceilCapsule, ceilBox);\n    \n    float floor = sdBox(p - vec3(0., -WALL_THICKNESS * 2., 0.), vec3(WALL_SPACE, WALL_THICKNESS, 100.));\n    \n    return min(\n        min(wallLeft, wallRight), \n        min(ceil, floor)\n    );\n}\n\nfloat ark(vec3 p) {\n    float wallBarLeft = sdBox(p - vec3(-(WALL_SPACE-WALL_THICKNESS), 0., 0.), vec3(ARK_WALL_THICKNESS, 1., ARK_WALL_THICKNESS));    \n    float wallBarRight = sdBox(p - vec3((WALL_SPACE-WALL_THICKNESS), 0., 0.), vec3(ARK_WALL_THICKNESS, 1., ARK_WALL_THICKNESS));    \n    float wallBarCeilBox = sdBox(p + vec3(0., -2., 0.), vec3(WALL_SPACE, 1., ARK_WALL_THICKNESS));   \n    float wallBarSphere = sdSphere(p + vec3(0., -1., 0.), (WALL_SPACE/2.) - ARK_WALL_THICKNESS);\n    float wallBarCeil = opSubtraction(wallBarSphere, wallBarCeilBox);\n    \n    vec3 q = p - vec3(-(WALL_SPACE-WALL_THICKNESS) - 0.05, 1.1, 0.);  \n    q.xy *= rot2D(7. * PI/180.);\n    float wallBarBoxLeft = sdBox(q, vec3(ARK_WALL_THICKNESS * 1.1 + 0.1, ARK_WALL_THICKNESS * 1.1, ARK_WALL_THICKNESS * 1.1));\n    q = p - vec3((WALL_SPACE-WALL_THICKNESS) + 0.05, 1.1, 0.);  \n    q.xy *= rot2D(-7. * PI/180.);\n    float wallBarBoxRight = sdBox(q, vec3(ARK_WALL_THICKNESS * 1.1 + 0.1, ARK_WALL_THICKNESS * 1.1, ARK_WALL_THICKNESS * 1.1)); \n    \n    \n    float ark = min(\n        min(wallBarLeft, wallBarRight),\n        wallBarCeil\n    );\n    ark = min(\n        min(wallBarBoxLeft, wallBarBoxRight),\n        ark\n    );\n    \n    return ark;\n}\n\n// Move\nvoid ApplyRotation(inout vec3 p) {\n    p.xy *= rot2D(sin(iTime / 5.) * sin((p.z - iTime-0.8) / 3.) * 30. * PI/180.);\n}\n\n// Distance to the scene\nfloat map(vec3 pos) {    \n    vec3 p = pos;\n    p.x += sin(p.z/3.) * 0.2;\n    p.y += sin(p.z/3. + iTime) * 0.05 * (p.z - iTime-0.8);\n    ApplyRotation(p);\n    \n    float distFract = 4.;\n    vec3 q = p;\n    q.z = mod(p.z, distFract) - (distFract / 2.);    \n    \n    float wallCeilFloor = wallFloorCeil(q);\n    float ark = ark(q);\n    \n    return min(\n        wallCeilFloor, \n        ark\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, 0.8);                     // ray origin\n    ro.z += iTime;\n    vec3 rd = normalize(vec3(uv, 1));             // ray direction\n    /*rd.yz *= rot2D(-m.y);                          // rotation X\n    rd.xz *= rot2D(-m.x * 2.);*/                          // rotation Z\n    \n    vec3 p;\n    float t = 0.;                                 // total distance travelled\n    \n    // Raymarching\n    float i;\n    float d;\n    for (i = 0.; i < 80.; i++) {\n        p = ro + rd * t;                     // position along the ray\n\n        d = map(p);                         // current distance to the scene\n\n        t += d;                                   // \"march\" the ray\n        \n        //col = vec3(i) / 80.;                    // iteration count\n        \n        if (d < .001 || t > 100.) break;          // early stop\n    }\n    \n    \n    // Coloring\n    float mask = sign(max(1. - d, 0.));\n    \n    vec3 col = mask * palette(t * .05 + float(i) / 80. - (68. * 0.1),\n       vec3(0.884, 0.279, 0.215), vec3(0.656, 0.180, 0.109), vec3(0.426, 0.489, 0.333), vec3(5.410, 1.624, 2.516)\n    ); // http://dev.thi.ng/gradients/\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}