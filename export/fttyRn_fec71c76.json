{"ver":"0.1","info":{"id":"fttyRn","date":"1659118361","viewed":216,"name":"!?","username":"panna_pudi","description":"Luna's trick with weights is kinda neat ðŸ˜³","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","reproduction"],"hasliked":0,"parentid":"ts2cWm","parentname":"Primitive Portrait"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This tweet reminded me that I wanted to do \n// something similar.\n// https://twitter.com/Rainmaker1973/status/1552300277201502210\n// Bonk me if something doesn't work\n\n// Luna is great\n// original: https://www.shadertoy.com/view/ts2cWm\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv= fragCoord.xy / iResolution.xy;\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\tvec3 color = tex.rgb / tex.a;\n    \n    vec3 weights = vec3(2., .1, .1);\n    weights /= dot(weights, vec3(1));\n    color = vec3(dot(color, weights));\n    \n\tuv -= .5;\n\tcolor *= 1. - dot(uv, uv) * 1.5;\n\n    // exposure and tonemap\n    color *= 2.5;\n    color = 1. - exp(color * -2.);\n\n\t// gamma correction\n\tcolor = pow(color, vec3(.45));\n    \n    fragColor = vec4(vec3(color), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI acos(-1.)\n\nmat2 rot(float a)\n{\n    float c = cos(a),s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sd_box(vec3 p, vec3 h) {\n    vec3 q = abs(p) - h;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sd_cyl(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return max(a, b) + h * h * k * (1.0 / 4.0);\n}\n\nvec2 hash2(float n) {\n\treturn fract(sin(vec2(n, n + 1.)) * vec2(43758.5453123));\n}\n\nfloat scene(vec3 p) {\n    float ground = 0.25 - p.z;\n    float d = 1e9;\n    vec3 q = p.yxz - vec3(0., -0.15, 0.);\n    float r = smoothstep(-0.15, 2., q.y);\n    { // head\n        vec3 q = q - vec3(0.8, 0., .02);\n        q.xz *= rot(PI / 9.);\n        /* q.zy *= rot(PI / 22.); */\n        q *= vec3(1., 1., 0.8);\n        d = smin(d, sd_cyl(q, 0.06 - r * 0.25, 0.15), 0.02);\n    }\n    { // hand\n      vec3 q = q - vec3(0.6, 0., 0.1);\n      q.xz *= rot(-PI / 11.);\n      d = smin(d, sd_box(q, vec3(0.03 , 0.15, 0.13 - r * 0.25)), 0.10);\n    }\n    { // legs\n      vec3 q = q - vec3(0., 0., 0.1);\n      q.xz *= rot(-PI / 11.);\n      d = min(d, sd_box(q, vec3(0.05 - r / 2., 0.15, 0.19 - r)));\n    }\n    {\n      vec3 q = q - vec3(0.27, 0., 0.23);\n      q.x = abs(q.x) - 0.45;\n      q.xz *= rot(-0.15);\n      d = smin(d, sd_box(q, vec3(0.15 , 0.15, 0.06 - r)), 0.04);\n    }\n\n    // body\n    {\n        vec3 q = q;\n\n        q.xz *= rot(-0.09);\n        float body = sd_box(q - vec3(0.32, 0., -0.10),\n                            vec3(0.29 , 0.15, 0.05 - r));\n        /* body = smin(body, sd_cyl(q - vec3(0.52, 0., -0.14), 0.01 - r, 0.15), 0.15); */\n\n        d = smin(d, body, 0.16);\n    }\n    d = smin(d, sd_cyl(q - vec3(0.03, 0., -0.12), 0.01 - r, 0.15), 0.06);\n    d = max(d, -(p.x + 0.30));\n    d = max(d, (p.x + 0.00));\n\n    d -= 0.01;\n    d = min(d, sd_cyl((p - vec3(-0.15, -0.7, 0.25)).yzx, 0.15, 0.1) - 0.01);\n    d = min(d, ground);\n    return d;\n}\n\n// https://iquilezles.org/articles/filterableprocedurals\nfloat grid(in vec2 p) {\n    const float width = 25.0;\n    vec2 ddx = dFdx(p), ddy = dFdy(p);\n    vec2 pix = fwidth(p) + .001;\n\n    vec2 a = p + 0.5 * pix;\n    vec2 b = p - 0.5 * pix;\n    vec2 i = (floor(a) + min(fract(a) * width, 1.0) - floor(b) -\n              min(fract(b) * width, 1.0)) / (width * pix);\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nvec2 rv2;\nvec3 ortho(vec3 a){\n    // assume b is nonzero\n    return cross(vec3(-1, -1, .5), a);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rv2;\n\tr.x = r.x * 2. * PI;\n\tr.y=pow(r.y, 1.0 / (power + 1.0));\n\tfloat oneminus = sqrt(1.0 - r.y * r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rv2;\n\tr.x = r.x * 2. * PI;\n\tr.y = 1.0 - r.y * extent;\n\tfloat oneminus = sqrt(1.0 - r.y * r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nvec3 sky(vec3 viewDir) {\n    float toplight = step(.5, dot(viewDir, vec3(0, 1, -.2)));\n    float sidelight = step(.5, dot(viewDir, normalize(vec3(1, 0, -1))));\n    return vec3(0, toplight, sidelight);\n}\n\nbool trace5(vec3 cam, vec3 dir, float EPS, out vec3 h, out vec3 n, out float k) {\n\tfloat t = 0.;\n    for(int i = 0; i < 100; ++i) {\n        k = scene(cam + dir * t);\n        t += k;\n        if (abs(k) < EPS) {\n            break;\n        }\n    }\n\n    h = cam + dir * t;\n\t\n    // if we hit something\n    if(abs(k) < EPS) {\n        vec2 o = vec2(EPS, 0);\n        k=scene(h);\n        n = normalize(vec3(\n            scene(h + o.xyy),\n            scene(h + o.yxy),\n            scene(h + o.yyx))\n            - k);\n        return true;\n    }\n    return false;\n}\n\nvec3 trace2(vec3 cam, vec3 dir) {\n    const vec3 sunPos = vec3(-20, -3,-5);\n    const float sunSize = 1e-3;\n    vec3 sunColor = vec3(1, 0, 0);\n    \n    vec3 accum = vec3(1);\n    vec3 direct = vec3(0);\n    for(int ibounce = 0; ibounce < 2; ++ibounce) {\n        vec3 h,n;\n        float k;\n        if (trace5(cam, dir, .001, h, n, k)) {\n            cam = h + n * .002;\n            dir=getSampleBiased(n, 1.);\n             \n            vec3 sunDirection = sunPos - h;\n            vec3 sunSampleDir = getConeSample(sunDirection, sunSize);\n            float sunLight = dot(n, sunSampleDir);\n            vec3 dummy0, dummy1;\n            float dummy2;\n            if (sunLight > 0.0 && !trace5(h + n * .02, sunSampleDir, .01, dummy0, dummy1,dummy2)) {\n                direct += accum * sunLight * sunColor;\n                if (h.z > 0.23) {\n                    direct *= grid(h.xy * 5.);\n                }\n            }\n            rv2 = hash2(rv2.y);\n        }\n        else if (abs(k) > .1) {\n            return direct + sky(dir) * accum;\n        } else {\n            break;\n        }\n    }\n    \n    return vec3(-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \tfragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\t\n    \n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n\n\trv2 = hash2(iTime + (uv.x + iResolution.x * uv.y) * 1.51269341231);\n    uv += 2. * (rv2 - .5) / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    vec3 cam = vec3(-0.15, 0., -2.);\n    vec3 dir = normalize(vec3(uv, 1.));\n    \n\tvec3 pixel = trace2(cam,dir);\n        \n    if (iMouse.z > 0.) {\n        fragColor = vec4(0);\n    }\n\n    fragColor += (!isnan(pixel.r) && pixel.r >= 0.) ? vec4(vec3(pixel),1) : vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"}]}