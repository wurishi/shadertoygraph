{"ver":"0.1","info":{"id":"msf3RM","date":"1665839581","viewed":129,"name":"Better explicit graphs","username":"Envy24","description":"Hold LMB to see distance field.\n\nOther methods:\nhttps://www.shadertoy.com/view/mdsGDX","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","graph","plot","explicit"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Green shows problem with method from:               https://www.shadertoy.com/view/stVcDz\n      + works for explicit curves\n      + works for implicit curves\n      - useless for parametric curves\n    Red shows better method from:                       https://www.shadertoy.com/view/3sKSWc\n                              or:                       https://www.shadertoy.com/view/WlcXW8\n      + works for explicit curves\n      - useless for implicit curves\n      + works for explicit curves (with modifications): https://www.shadertoy.com/view/dss3R7, https://www.shadertoy.com/view/NtVfWG\n      \n    Implementation with thickness:                      https://www.shadertoy.com/view/Ddl3RM\n*/\n\n#define R                           iResolution\n#define AR                        (  R.x / R.y  )\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define SCENE_SCALE               ( 1.5 )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float signed_dist = NDC.y - fx;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n/**/\n#define M       ( sinOSC(1., 100., iTime*0.5) )\n#define func(x) ( cos(M*(x)) )\n#define dfdx(x) ( M*sin(M*(x)) )\n/**\n#define T       ( sinOSC(-AR, AR, iTime) )\n#define func(x) ( step(T, x) )\n#define dfdx(x) ( 0. )\n/**\n#define func(x) ( fract((x)*8.) > 0.5 ? 1. : 0. )\n#define dfdx(x) ( 0. )\n/**\n#define func(x) ( 1./sin(x) )\n#define dfdx(x) ( 1./(sin(x)*sin(x))*cos(x) )\n/**/\n\n/* IQ coloring scheme */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    color = 1.0 - sign(dist) * color;      // Change color if dist is negative.      \n\tcolor *= 1.0 - exp(-4.0 * abs(dist));  // Attenuate color around edges.   \n\tcolor *= 0.7 + 0.2 * cos(50.0 * dist); // Add interleaved curves.    \n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 6./R.y, abs(dist))); // Add white edges.\n}\n\n/*old saved for history (see comments)*\nfloat explicit_sdf(\n    in vec2 NDC,\n    in float pixel_size,\n    in float order)\n{\n    order = max(0., order);\n    \n    float minimal_distance = 99.;\n    vec2 B = vec2(NDC.x, func(NDC.x));\n    \n    for (float i = -order; i <= order; i += 1.)\n    {\n        float dx = pixel_size * i;\n        vec2 E = vec2(B.x + dx, func(B.x + dx));\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n    }\n    \n    return minimal_distance;\n}\n/*gives better result than old (see step function example)*/\nfloat explicit_sdf(\n    in vec2 NDC,\n    in float pixel_size,\n    in float order)\n{\n    order = max(0., order);\n    \n    float minimal_distance = 99.;\n    vec2 B = \n        vec2(NDC.x-order*pixel_size,\n             func(NDC.x-order*pixel_size));\n      \n    for (float i = -order + 1.; i <= order; i += 1.)\n    {\n        vec2 E = vec2(B.x + pixel_size, func(B.x + pixel_size));\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance;\n}\nfloat explicit_sdf2(vec2 NDC)\n{\n    return abs(NDC.y - func(NDC.x)) / sqrt(1.0 + dfdx(NDC.x) * dfdx(NDC.x));\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * SCENE_SCALE;\n\n    if (LMB_IS_HOLD == true)\n    {\n        vec3 color =\n            NDC.x > 0. ?\n                colorize_field(explicit_sdf(NDC, UNIT/8., 7.), vec3(0.1, 0.4, 0.7)) :\n                colorize_field(explicit_sdf2(NDC), vec3(0.1, 0.4, 0.7));\n         O = vec4(color, 1);\n         return;\n    }\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);         \n    /* Explicit function y=f(x) */\n         color = \n             SC.x > R.x*0.5 ?\n                 mix( color, vec3(1,0,0), SMAA(explicit_sdf(NDC, UNIT/8., 7.)) ) :\n                 mix( color, vec3(0,1,0), draw_explicit_func(NDC, func(NDC.x), dfdx(NDC.x)) );      \n    /**/      \n         color -= vertical_line(NDC, -1.)*.2;   color -= vertical_line(NDC, 1.)*.2;\n         color -= horizontal_line(NDC, -1.)*.2; color -= horizontal_line(NDC, 1.)*.2;\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}