{"ver":"0.1","info":{"id":"7lGfz1","date":"1664062507","viewed":111,"name":"Path with max sum","username":"Envy24","description":"Press to LMB to see sums.\n\nConstrains:\n1. Pass with max sum from lower left corner to right corner.\n2. Steps can be done only in two directions: right or up.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["dynamic","path","max","sum","finding"],"hasliked":0,"parentid":"NsB3Dm","parentname":"filter, pixelization"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define PIXEL_SIZE 50.00 // for 800x450 resolution\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n// for 800*450 resolution\nconst float width = 16.;\nconst float height = 9.;\nfloat D[int(width*height)];\n#define d(c, r) ( D[int((r)*w + (c))] )\n\nfloat HASH(float c, float r, float w)\n{\n    r += floor(iTime * 1.0); c += floor(iTime * 1.0);\n    return hash11(uint(r*w+c));\n}\n\nvoid mainImage(out vec4 O, vec2 SC)\n{\n    vec2 CC = floor(SC / PIXEL_SIZE);\n    \n    // Full screen mode doent't allowed.\n    if (CC.x >= 16. || CC.y >= 9.) { O = vec4(0); return; }\n    \n    // Adaptive width and height.\n    float w = min(width, R.x / PIXEL_SIZE);\n    float h = min(height, R.y / PIXEL_SIZE);\n    \n    /* Init first sum. */\n    D[0] = HASH(0., 0., width);          \n    /* Calculate sums A. *\n    for (float c = 0.; c < width; c += 1.)\n    {\n        for (float r = 0.; r < height; r += 1.)\n        {\n            if (r == 0. && c == 0.) { continue; }\n            \n            d(c, r) = 0.;\n            \n            if (r - 1. >= 0.) \n            {\n                d(c, r) = max(d(c, r), d(c, r - 1.) + HASH(c, r, width));\n            }\n\n            if (c - 1. >= 0.) {\n                d(c, r) = max(d(c, r), d(c - 1., r) + HASH(c, r, width));\n            }\n        }\n    }\n    /* Calculate sums B. */\n    for (float c = 1.; c < w; c += 1.) { d(c, 0.) = d(c - 1., 0.) + HASH(c, 0., w); }\n    for (float r = 1.; r < h; r += 1.) { d(0., r) = d(0., r - 1.) + HASH(0., r, w); }\n    for (float r = 1.; r < h; r += 1.)\n    {\n        for (float c = 1.; c < w; c += 1.)\n        {\n            d(c, r) = max(d(c, r - 1.), d(c - 1., r)) + HASH(c, r, w);         \n        }\n    }\n    /* Highlite sums */\n    if (LMB_IS_HOLD == true) { O = vec4(d(CC.x, CC.y)*0.05); return; }\n    /* Highlite path */\n    float r=0.,c=0., hw = h + w - 2.;\n    vec2 best = vec2(0);\n    for (float i = 0.; i < hw; i+=1.)\n    {\n        float d0 = d(c, r + 1.), d1 = d(c + 1., r);\n        r =\n            d0 < d1 ?\n                r :\n                r + 1.;\n        c = \n            d0 < d1 ?\n                c + 1. : \n                c;\n        best =\n            vec2(c, r) == CC ?\n                CC :\n                best;\n    }    \n    /**/\n    O = \n        best == CC ?\n            vec4(0,1,0,1) :\n            vec4( HASH(CC.x, CC.y, w) );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat hash11(uint value)\n{\n    // Try different values.\n    const uint seed0 = 12345u;\n    const uint seed1 = 67890u;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n    \n    return float(value * value * value) * 2.32830644e-10;\n}","name":"Common","description":"","type":"common"}]}