{"ver":"0.1","info":{"id":"Mt33R2","date":"1472768168","viewed":660,"name":"Dirty bomb","username":"public_int_i","description":"Dirty bomb - (finished rendering) http://i.imgur.com/xsNaVWb.png\n\nControls:\nlook - mouse\nmove - arrow keys","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["dirty","bomb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n/*\nFinished rendering:\nhttp://i.imgur.com/xsNaVWb.png\n\nLook at Buf A line 126 for the scene distance/material function.\n\nControls:\nlook - mouse\nmove - arrow keys\n\nAdded material to the volumetric path tracer i used in my last Shadertoy.\n*/\n\n\n\n\n//display montecarlo path trace result\n\n\n#define devrender 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if devrender == 0\n    vec4 csamp = texture(iChannel0, 0.5/iResolution.xy);\n    vec4 samp = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = pow(samp/samp.w/*/(float(iFrame-int(csamp.x*4096.)))*/, vec4(1./2.2));\n    \n    //used for exporting image in the format of r=lighting, g=opacity\n\t//fragColor = texture(iChannel0, fragCoord/iResolution.xy)/(float(iFrame-120));\n    //fragColor.x = pow(fragColor.x, 1./2.2);\n    \n\t#else\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(1./2.2));\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n//rendering pass\n\n\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n#define camera_fisheye 1.0\n\n#define iterations 256\n#define minDelta .3\n#define maxDelta .65\n#define skipDelta 1.\n\n#define range 1024.\n\n//#define sunImportance 0.05\n//#define sunDirectional 1.0\n\n\nvec3 sunDirection = normalize(vec3(-2.,5.,4.5)),\n     sunPosition = vec3(0.,200.,0.);\nconst vec3 sunColor = vec3(1.,.74,.94)*20.,\n    \t   skyColor = vec3(0.04,0.06,0.14)*0.,\n    \t   ambientColor = vec3(1.);\n\nconst float sunSize = 0.001,//0-1\n    \t\tambientDensity = 0.0;//0-2, global mist\n\n\n#define devrender 0\n\n\n\nstruct ctx {\n    vec3 point;\n    float distance_,\n          density, fluff, deformRoughness, deformAmount, deformScale, emission;\n    vec3 color;\n};\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n//random ray using p as a seed\nvec3 randomRay(in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\n\n\n//scene function, returns distance + material data at point\nctx scene(ctx i) {\n    vec3 p = i.point;\n    \n    const vec3 emissionColor = vec3(.89,1.,.94);\n    \n\t//ground\n    i.distance_ = p.y+10.;\n\ti.color = vec3(.43);\n    i.density = 2.;\n    i.deformAmount = 0.;\n    i.fluff = 0.;\n\ti.emission = 0.0;\n    \n    //flare\n    float ed = length(p.xz)-1.;\n    if (ed < i.distance_) {\n        i.distance_ = ed;\n        i.color = emissionColor;\n        i.deformAmount = 1.;\n        i.deformScale = 1.;\n        i.density = 0.1;\n        i.emission = 5.;\n    }\n    \n    //mushroom cloud\n    float mh = pow(min(1.,max(0.,p.y-50.+max(0.,length(p.xz)-(20.+max(0.,p.y-20.)/2.))*2.)/50.),2.2);\n    float md = max(abs(p.y)-100.,length(p.xz)-(5.+mh*50.));\n    if (md < i.distance_) {\n        float meh = pow(min(1.,max(0.,p.y)/70.),2.2);\n        float em = ceil(hash3(floor(abs(p)/1.)*182.4835)-.9-meh*.099);\n\n        \n        i.distance_ = md;\n        i.color = mix(vec3(.44,.54,.66),emissionColor,em);\n        i.density = 0.44;\n        i.fluff = 0.92;               \n        i.deformAmount = 0.24+mh*0.4;\n        i.deformScale = 1.3;\n        i.deformRoughness = 0.08;\n        \n        i.emission = (1.0-meh)*em*10.;\n    }\n    \n    \n    return i;\n}\n\n\n\n//backgrund\nvec3 background(vec3 d) {\n    \n    #ifdef sunDirectional\n    float sun = dot(normalize(sunDirection), d);\n    return mix(skyColor,\n               sunColor,\n               pow(max(0., sun-(1.-sunSize))/sunSize,.3));\n    #else\n    return skyColor;\n    #endif\n}\n\n\n\n//apply cloud warping and distance modifiers\nctx scene_warp(ctx cx) {\n    \n    cx = scene(cx);\n   \tfloat d = cx.distance_;\n    \n    vec3 p = cx.point;\n\n    //cloud shape deform\n    if (cx.deformAmount > 0.0) {\n        #define ldst d\n        for (int i = 1; i < 4; i++) {\n            float pfi = pow(float(i),2.)*cx.deformScale,\n                \tdmx = mix(1.,ldst+cos((p.x+p.y+p.z)/pfi)*pfi,cx.deformRoughness);\n            ldst -= abs(cos(p.x/pfi+cos(26.2348+dmx*(p.y*.39)/pfi)*4.)*\n                     cos(p.y/pfi+cos(29.8937+dmx*(p.z*.37)/pfi)*4.)*\n                     cos(p.z/pfi+cos(14.972+dmx*(p.x*.41)/pfi)*4.))*pfi*cx.deformAmount;\n        }\n    }\n    \n    cx.distance_ = max(skipDelta, d);\n    return cx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 camtex = texture(iChannel1, 0.5/iResolution.xy);\n    float frame = texture(iChannel2, 0.5/iResolution.xy).x*4096.;\n       \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //ray direction from uvs and ray position at origin\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)*vec2(-1.,1.)/iResolution.x,1./camera_fisheye)),\n         ird,\n         rp = camtex.xyz-range;\n    \n    vec2 cameraRot = decodeRot(camtex.w);\n    rd.yz = rot(rd.yz,cameraRot.y);\n    rd.xz = rot(rd.xz,cameraRot.x);\n    \n    ird = rd;\n    float ifrm = float(iFrame);\n    #define rndifrm(s) fract(fract(ifrm*.044877+s)*256.494+ifrm*.02934)\n    \n    vec4 c = vec4(1,1,1,0);\n    \n    ctx cx;\n    \n    #if devrender == 0\n    \n    vec3 l = vec3(0.0);\n    \n    //render\n    for (int i = 0; i < iterations; i++) {\n        cx.point = rp;\n        cx = scene_warp(cx);\n        float d = cx.distance_,\n              dt = d*(minDelta+hash3(rp+rndifrm(rp)*1024.)*(maxDelta-minDelta)),\n              k = min(1., (d-skipDelta)*10.*(1.-cx.fluff));\n        if (mix(cx.density,ambientDensity,k)*max(1.,dt*.1) > hash3(rp+rndifrm(rp)*256.)) {\n            c.xyz *= mix(cx.color,ambientColor,floor(k));\n            c.w = 1.;\n            l += cx.color*cx.emission*(1.0-floor(k));\n            #ifdef sunImportance\n            #ifdef sunDirectional\n            rd = mix(randomRay(rp+rndifrm(rp*1024.)*1024.), sunDirection, floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+sunImportance-1e-6));\n        \t#else\n            rd = mix(randomRay(rp+rndifrm(rp*1024.)*1024.), normalize(sunPosition-rp), floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+sunImportance-1e-6));\n            #endif\n            #else\n            rd = randomRay(rp+rndifrm(rp*1024.)*1024.);\n            #endif\n        }\n        \n        rp += rd*dt;\n        if (length(rp) > range) break;\n    }\n   \n    c.xyz = c.xyz*background(rd)*float(length(rp)/range > 1.)+ //if light ray makes it too edge of world illuminate it  \n    \t\tc.xyz*l;\n    fragColor = mix(vec4(background(ird),1.), c, c.w)+\n    texture(iChannel0, uv)*float(float(iFrame)-frame > 1.0);//blend result with background and add to buffer\n\n    //used for exporting image in the format of r=lighting, g=opacity\n    /*(fragColor = vec4(c.x*float(max(length(rp)/range,max(0.,-rp.y)/yRange) > 1.),c.w,0,0)+\n                     texture(iChannel0, uv);\n    */\n    \n    #else\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp);\n        if (d < .2 || c.w > range) break;\n        \n        rp += rd*d;\n        c.w += d;\n    }\n    if (df(rp) < .2) {\n       c = vec4(cloudColor*(.3+max(0.,(df(rp)-df(rp-sunDirection)))),1.);\n    } else {\n       c = vec4(background(ird),1.); \n    }\n    fragColor = c+texture(iChannel0,uv);\n    #endif\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n\n//camera move and look\n\n\n\n#define uv (.5/iResolution.xy)\n#define camerarange 1024.\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n\n#define mouse_sensitivity 0.025 * 60.0\n#define movement_sensitivity .5 * 60.0\n\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n\n\nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    if (iFrame < 10) {\n     \t//set default camera\n        vec3 camPos = vec3(0., 140., 120.),\n             camRot = vec3(3.14/-2., 3.14/1.4, 0.0);\n        \n        fragColor = vec4(camPos+camerarange, encodeRot(mod(camRot.xy,pi2)));\n        return;\n    }\n        \n   \tvec4 samp = texture(iChannel0, uv);\n    vec3 camPos = samp.xyz,\n             camRot = decodeRot(samp.w).xyy;\n    \n    //movement\n    float movementA = texture(iChannel1, vec2(38.5, 25.5)/255.).x-\n                                 texture(iChannel1, vec2(40.5, 25.5)/255.).x;\n    if (movementA != 0.) {\n        vec3 rdB = vec3(0.,0.,1.);    \n        rdB.yz = rot(rdB.yz,camRot.y);\n        rdB.xz = rot(rdB.xz,camRot.x);\n    \tcamPos.xyz += movementA*rdB*iTimeDelta*movement_sensitivity;\n    }\n    float movementB = texture(iChannel1, vec2(37.5, 25.5)/255.).x-\n                      texture(iChannel1, vec2(39.5, 25.5)/255.).x;\n    if (movementB != 0.) {\n         vec3 rdB = vec3(1.,0.,0.);    \n         rdB.yz = rot(rdB.yz,camRot.y);\n         rdB.xz = rot(rdB.xz,camRot.x);\n         camPos.xyz += movementB*rdB*iTimeDelta*movement_sensitivity;\n    }\n                \n    //rotation\n    if (iMouse.w > 0.) {\n    \tvec2 muv = (iMouse.xy/iResolution.xy)-.5;\n        camRot.xy += muv*vec2(1.,-1.)*mouse_sensitivity*iTimeDelta;\n    }\n\n    fragColor = vec4(max(camPos, 0.0), encodeRot(mod(camRot.xy,pi2)));\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n//frame of last camera change\n\n\n#define uv (.5/iResolution.xy)\n#define change_epsilon 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    vec4 csamp = texture(iChannel0, uv),\n         bsamp = texture(iChannel1, uv);\n    \n    float hash = fract(length(bsamp)+bsamp.w);\n    if (abs(hash-csamp.y) > change_epsilon) {\n     \tcsamp.y = hash;\n        csamp.x = float(iFrame)/4096.;\n    }\n    \n    fragColor = csamp;\n}","name":"Buf C","description":"","type":"buffer"}]}