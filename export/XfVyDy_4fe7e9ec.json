{"ver":"0.1","info":{"id":"XfVyDy","date":"1732326623","viewed":40,"name":"Wave Simulation ft @asmn79","username":"ademdj12","description":"wave simulation based on @asmn79 implementation. you can find it on Pinterest.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["wave","simulation","interactive","colorful"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    wave simulation based on @asmn79 implementation. you can find it on Pinterest.\n*/\n#define PI 3.1415926\n\nvec3 palette1(float x) {\n    float v = pow(sin(PI*x), 2.);\n    return v * vec3(1., .9*v, .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col.ggg,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    r channel for -value\n    g channel for -speed\n*/\n\n#define sin_of_45_deg 0.70710678118 \n\n#define damping .999\n\n// radius of the brush, cant be 0.\n#define paintRadius 10.\n\n#define AUTO 1\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Cell = texelFetch(iChannel0, ivec2(fragCoord.xy),0).rg; \n\n    float s = 0.;\n    \n    for(int x = -1; x < 2; x++){\n        for(int y = -1; y < 2; y++){\n            \n            if(x == 0 && y == 0) continue;\n            \n            float neighborValue = texelFetch(\n                    iChannel0, \n                    ivec2(fragCoord.xy) + ivec2(x,y),\n                    0\n                ).r;\n            \n            if(abs(x)+abs(y) == 2) neighborValue *= sin_of_45_deg;\n            \n            s += neighborValue;\n        }\n    }\n    \n    float offset = (s/8.) - Cell.r;\n    Cell.g = Cell.g + offset;\n    Cell.r = Cell.g + Cell.r;\n    \n    if(iMouse.z > 0.){\n        float d = distance(iMouse.xy, fragCoord.xy) / paintRadius < 1. ? 1. : 0.;\n        Cell += vec2(d);\n    }\n    \n    if(AUTO==1 && iFrame%50 < 2){\n        float d = distance(vec2(0.,iResolution.y/2.+10.), fragCoord.xy) / 10. < 1. ? 1. : 0.;\n        float d1 = distance(vec2(iResolution.x,iResolution.y/2.-10.), fragCoord.xy) / 10. < 1. ? 1. : 0.;\n\n        Cell += vec2(max(d,d1)*10.2);\n    }\n    \n    Cell *= damping;\n    fragColor = vec4(Cell.rg, 0., 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    r channel for -value\n    g channel for -speed\n*/\n\n#define sin_of_45_deg 0.70710678118 \n\n#define damping .999\n\n// radius of the brush, cant be 0.\n#define paintRadius 10.\n\n#define AUTO 1\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Cell = texelFetch(iChannel0, ivec2(fragCoord.xy),0).rg; \n\n    float s = 0.;\n    \n    for(int x = -1; x < 2; x++){\n        for(int y = -1; y < 2; y++){\n            \n            if(x == 0 && y == 0) continue;\n            \n            float neighborValue = texelFetch(\n                    iChannel0, \n                    ivec2(fragCoord.xy) + ivec2(x,y),\n                    0\n                ).r;\n            \n            if(abs(x)+abs(y) == 2) neighborValue *= sin_of_45_deg;\n            \n            s += neighborValue;\n        }\n    }\n    \n    float offset = (s/8.) - Cell.r;\n    Cell.g = Cell.g + offset;\n    Cell.r = Cell.g + Cell.r;\n    \n\n    \n    Cell *= damping;\n    fragColor = vec4(Cell.rg, 0., 0.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    r channel for -value\n    g channel for -speed\n*/\n\n#define sin_of_45_deg 0.70710678118 \n\n#define damping .999\n\n// radius of the brush, cant be 0.\n#define paintRadius 10.\n\n#define AUTO 1\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Cell = texelFetch(iChannel0, ivec2(fragCoord.xy),0).rg; \n\n    float s = 0.;\n    \n    for(int x = -1; x < 2; x++){\n        for(int y = -1; y < 2; y++){\n            \n            if(x == 0 && y == 0) continue;\n            \n            float neighborValue = texelFetch(\n                    iChannel0, \n                    ivec2(fragCoord.xy) + ivec2(x,y),\n                    0\n                ).r;\n            \n            if(abs(x)+abs(y) == 2) neighborValue *= sin_of_45_deg;\n            \n            s += neighborValue;\n        }\n    }\n    \n    float offset = (s/8.) - Cell.r;\n    Cell.g = Cell.g + offset;\n    Cell.r = Cell.g + Cell.r;\n    \n\n    \n    Cell *= damping;\n    fragColor = vec4(Cell.rg, 0., 0.);\n}","name":"Buffer C","description":"","type":"buffer"}]}