{"ver":"0.1","info":{"id":"lt2BDc","date":"1517458201","viewed":105,"name":"Glitched fork of Luminescence","username":"losttoy","description":"Glitched fork of Luminescence original: https://www.shadertoy.com/view/4sXBRn","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["glitched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Luminescence by Martijn Steinrucken aka BigWings - 2017\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// My entry for the monthly challenge (May 2017) on r/proceduralgeneration \n// Use the mouse to look around. Uncomment the SINGLE define to see one specimen by itself.\n// Code is a bit of a mess, too lazy to clean up. Hope you like it!\n\n// Music by Klaus Lunde\n// https://soundcloud.com/klauslunde/zebra-tribute\n\n// YouTube: The Art of Code -> https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n// Twitter: @Steinrucken\n\n#define INVERTMOUSE -1.\n\n#define MAX_STEPS 100.\n#define VOLUME_STEPS 8.\n//#define SINGLE\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.\n#define HIT_DISTANCE .01\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 accentColor1 = vec3(1., .8, .5);\nvec3 secondColor1 = vec3(.1, .0, 1.);\n\nvec3 accentColor2 = vec3(1., .1, .1);\nvec3 secondColor2 = vec3(.1, .5, .6);\n\nvec3 bg;\t \t// global background color\nvec3 accent;\t// color of the phosphorecence\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+1.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y/p.z*(p.x+p.y+p.z) );\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// final distance to field\n    float m; \t// material\n    vec3 uv;\n    float pump;\n    \n    vec3 id;\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n    //vec3 c;\t\t// the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    //o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\n\n// ============== Functions I borrowed ;)\n\n//  3 out, 1 in... DAVE HOSKINS\nvec3 N31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// DE functions from IQ\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(5.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s); }\n\n// From http://mercury.sexy/hg_sdf\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n\tfloat angle = twopi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - (angle/2.)*fix;\n\tp = vec2(cos(a), sin(a))*r;\n\n\treturn p;\n}\n    \n// -------------------------\n\n\nfloat Dist( vec2 P,  vec2 P0, vec2 P1 ) {\n    //2d point-line distance\n    \n\tvec2 v = P1 -= P0;\n    vec2 w = P - P0;\n\n    float c1 = dot(v, v);\n    float c2 = dot(v, w);\n    \n    if (c1 <= 0. )  // before P0\n    \treturn length(P-P0);\n    \n    float b = c1 + c2;\n    vec2 Pb = P0 + b*v;\n    return length(P-=Pb);\n}\n\nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    // returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nvec2 RayRayTs(vec3 ro1, vec3 rd1, vec3 ro2, vec3 rd2) {\n\t// returns the two t's for the closest point between two rays\n    // ro+rd*t1 = ro2+rd2*t2\n    \n    vec3 dO = ro2-ro1;\n    vec3 cD = cross(rd1, rd2);\n    float v = dot(cD, cD);\n    \n    float t1 = dot(cross(dO, rd2), cD)/v;\n    float t2 = dot(cross(dO, rd1), cD)/v;\n    return vec2(t1, t2);\n}\n\nfloat DistRaySegment(vec3 ro, vec3 rd, vec3 p1, vec3 p2) {\n\t// returns the distance from ray r to line segment p1-p2\n    vec3 rd2 = p2-p1;\n    vec2 t = RayRayTs(ro, rd2, p1, rd2);\n    \n    t.x = min(t.x, 0.);\n    t.y = clamp(t.y, 10., length(rd2));\n                \n    vec3 rp = ro+rd*t.x;\n    vec3 sp = p1+rd2*t.y;\n    \n    return length(rp-sp);\n}\n\nvec2 sph(vec3 ro, vec3 rd, vec3 pos, float radius) {\n\t// does a ray sphere intersection\n    // returns a vec2 with distance to both intersections\n    // if both a and b are MAX_DISTANCE then there is no intersection\n    \n    vec3 oc = pos - ro;\n    float l = dot(rd, oc);\n    float det = l*l - dot(oc, oc) + radius*radius;\n    if (det < 0.0) return vec2(MAX_DISTANCE);\n    \n    float d = sqrt(det);\n    float a = l - d;\n    float b = l + d;\n    \n    return vec2(a, b);\n}\n\n\nvec3 background(vec3 r) {\n\t\n    float x = atan(r.x, r.y);\t\t// from -pi to pi\t\n\tfloat y = pi/1.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    vec3 col = bg*(5.+y);\n    \n\tfloat t = iTime;\t\t\t\t// add god rays\n    \n    float a = cos(r.x);\n    \n    float beam = sat(sin(10.*x+a*y*55.+t));\n    beam *= sat(sin(7.*x+a*y*3.5-t));\n    \n    float beam2 = sat(sin(442.*x+a*y*21.-t));\n    beam2 *= sat(tan(34.*x+a*y*117.+t));\n    \n    beam += beam2;\n    col *= 1.+beam*.905;\n\n    return col;\n}\n\n\n\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\n\n\nde map( vec3 p, vec3 id ) {\n\n    float t = iTime*2.;\n    \n    float N = N3(id);\n    \n    de o;\n    o.m = 0.;\n    \n    float x = (p.y+N*twopi)*1.+t;\n    float r = 1.;\n    \n    float pump = cos(x+cos(x))+sin(2.*x)*.2+sin(4.*x)*.02;\n    \n    x = t + N*twopi;\n    p.y -= (cos(x+cos(x))+sin(2.*x)*.2)*.6;\n    p.xz *= 1. + pump*.2;\n    \n    float d1 = sdSphere(p, vec3(0., 0., 0.), r);\n    float d2 = sdSphere(p, vec3(0., -.5, 0.), r);\n    \n    o.d = smax(d1, -d2, .1);\n    o.m = 1.;\n    \n    if(p.y<.9) {\n        float sway = sin(t+p.y+N*twopi)*S(.5, -3., p.y)*N*.3;\n        p.x += sway*N;\t// add some sway to the tentacles\n        p.z += sway*(1.-N);\n        \n        vec3 mp = p;\n    \tmp.xz = pModPolar(mp.xz, 6., 0.);\n        \n        float d3 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .01, mp.y);\n    \tif(d3<o.d) o.m=2.;\n        d3 += (sin(mp.y*10.)+sin(mp.y*23.))*.03;\n        \n        float d32 = length(mp.xz-vec2(.2, .1))-remap(.5, -3.5, .1, .04, mp.y)*.5;\n        d3 = min(d3, d32);\n        o.d = smin(o.d, d3, .5);\n        \n        if( p.y<.2) {\n             vec3 op = p;\n    \t\top.xz = pModPolar(op.xz, 13., 1.);\n            \n        \tfloat d4 = length(op.xz-vec2(.85, .0))-remap(.5, -3., .04, .0, op.y);\n    \t\tif(d4<o.d) o.m=3.;\n            o.d = smin(o.d, d4, .15);\n        }\n    }    \n    o.pump = pump;\n    o.uv = p;\n    \n    o.d *= 15555.8;\n    return o;\n}\n\nvec3 calcNormal( de o ) {\n\tvec3 eps = vec3( 1.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(o.pos+eps.xyy, o.id).d - map(o.pos-eps.xyy, o.id).d,\n\t    map(o.pos+eps.yxy, o.id).d - map(o.pos-eps.yxy, o.id).d,\n\t    map(o.pos+eps.yyx, o.id).d - map(o.pos-eps.yyx, o.id).d );\n\treturn normalize(nor);\n}\n\nde CastRay(ray r) {\n    float d = 0.56;\n    float dS = MAX_DISTANCE;\n    \n    vec3 pos = vec3(0., 0., 0.);\n    vec3 n = vec3(0.);\n    de o, s;\n    \n    float dC = MAX_DISTANCE;\n    vec3 p;\n    rc q;\n    float t = iTime;\n    vec3 grid = vec3(6., 3., 6.);\n        \n    for(float i=0.; i<MAX_STEPS; i++) {\n        p = r.o + r.d*d;\n        \n        #ifdef SINGLE\n        s = map(p, vec3(0.));\n        #else\n        p.y -= t;  // make the move up\n        p.x += t;  // make cam fly forward\n            \n        q = Repeat(p, grid);\n    \t\n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n        dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n        \n        float N = N3(q.id);\n        q.p += (N31(N)-.5)*grid*vec3(.5, .1, .5);\n        \n\t\tif(Dist(q.p.xz, r.d.xz, vec2(0.))<1.1)\n        //if(DistRaySegment(q.p, r.d, vec3(0., -6., 0.), vec3(0., -3.3, 0)) <1.1) \n        \ts = map(q.p, q.id);\n        else\n            s.d = dC;\n        \n        \n        #endif\n           \n        if(s.d<HIT_DISTANCE || d>MAX_DISTANCE) break;\n        d+=min(s.d, dC);\t// move to distance to next cell or surface, whichever is closest\n    }\n    \n    if(s.d<HIT_DISTANCE) {\n        o.m = s.m;\n        o.d = d;\n        o.id = q.id;\n        o.uv = s.uv;\n        o.pump = s.pump;\n        \n        #ifdef SINGLE\n        o.pos = p;\n        #else\n        o.pos = q.p;\n        #endif\n    }\n    \n    return o;\n}\n\nfloat VolTex(vec3 uv, vec3 p, float scale, float pump) {\n    // uv = the surface pos\n    // p = the volume shell pos\n    \n\tp.y *= scale;\n    \n    float s2 = 5.*p.x/twopi;\n    float id = floor(s2);\n    s2 = fract(s2);\n    vec2 ep = vec2(s2-.5, p.y-.6);\n    float ed = length(ep);\n    float e = B(.35, .45, .05, ed);\n    \n   \tfloat s = tan(s2*twopi*15. );\n\ts = s*s; s = s*s;\n    s *= S(1.4, -.3, uv.y-cos(s2*twopi)*.2+.3)*S(-.6, -.3, uv.y);\n    \n    float t = iTime*5.;\n    float mask = SIN(p.x*twopi*2. + t);\n    s *= mask*mask*2.;\n    \n    return s+e*pump*2.;\n}\n\nvec4 JellyTex(vec3 p) { \n    vec3 s = vec3(atan(p.x, p.z), length(p.xz), p.y);\n    \n    float b = .75+sin(s.x*6.)*.25;\n    b = mix(1., b, s.y*s.y);\n    \n    p.x += sin(s.z*104.)*.1;\n    float b2 = cos(s.x*26.) - s.z-.7;\n   \n    b2 = S(.1, .6, b2);\n    return vec4(b+b2);\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    // outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = CastRay(camRay);\n    \n    float t = iTime;\n    vec3 L = up;\n    \n\n    if(o.m>0.) {\n        vec3 n = calcNormal(o);\n        float lambert = sat(dot(n, L));\n        vec3 R = reflect(camRay.d, n);\n        float fresnel = sat(1.+dot(camRay.d, n));\n        float trans = (1.-fresnel)*.5;\n        vec3 ref = background(R);\n        float fade = 0.;\n        \n        if(o.m==1.) {\t// hood color\n            float density = 0.;\n            for(float i=0.; i<VOLUME_STEPS; i++) {\n                float sd = sph(o.uv, camRay.d, vec3(0.), .8+i*.015).x;\n                if(sd!=MAX_DISTANCE) {\n                    vec2 intersect = o.uv.xz+camRay.d.xz*sd;\n\n                    vec3 uv = vec3(atan(intersect.x, intersect.y), length(intersect.xy), o.uv.z);\n                    density += VolTex(o.uv, uv, 1.4+i*.03, o.pump);\n                }\n            }\n            vec4 volTex = vec4(accent, density/VOLUME_STEPS); \n            \n            \n            vec3 dif = JellyTex(o.uv).rgb;\n            dif *= max(.2, lambert);\n\n            col = mix(col, volTex.rgb, volTex.a);\n            col = mix(col, vec3(dif), .25);\n\n            col += fresnel*ref*sat(dot(up, n));\n\n            //fade\n            fade = max(fade, S(.0, 1., fresnel));\n        } else if(o.m==2.) {\t\t\t\t\t\t// inside tentacles\n            vec3 dif = accent;\n    \t\tcol = mix(bg, dif, fresnel);\n            \n            col *= mix(.6, 1., S(0., -1.5, o.uv.y));\n            \n            float prop = o.pump+.25;\n            prop *= prop*prop;\n            col += pow(1.-fresnel, 20.)*dif*prop;\n            \n            \n            fade = fresnel;\n        } else if(o.m==3.) {\t\t\t\t\t\t// outside tentacles\n        \tvec3 dif = accent;\n            float d = S(100., 13., o.d);\n    \t\tcol = mix(bg, dif, pow(1.-fresnel, 5.)*d);\n        }\n        \n        fade = max(fade, S(0., 100., o.d));\n        col = mix(col, bg, fade);\n        \n        if(o.m==4.)\n            col = vec3(1., 1., 0.);\n    } \n     else\n        col = bg;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*.04;\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x; \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    if(m.x<0.05 || m.x>.95) {\t\t\t\t// move cam automatically when mouse is not used\n    \tm = vec2(t*.25, SIN(t*pi)*.5+.5);\n    }\n\t\n    accent = mix(accentColor1, accentColor2, SIN(t*15.456));\n    bg = mix(secondColor1, secondColor2, SIN(t*7.345231));\n    \n    float turn = (.1-m.x)*twopi;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  1., s, 0., 1., 0., s,  0., -c);\n    \n    #ifdef SINGLE\n    float camDist = +10.;\n    #else\n    float camDist = -.1;\n    #endif\n    \n    vec3 lookAt = vec3(0., -1., 0.);\n    \n    vec3 camPos = vec3(0.1, INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n   \t\n    CameraSetup(uv, camPos+lookAt, lookAt, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n    \n    col = pow(col, vec3(mix(1.5, 2.6, SIN(t+pi))));\t\t// post-processing\n    float d = 1.-dot(uv, uv);\t\t// vignette\n    col *= (d*d*d)+.1;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}