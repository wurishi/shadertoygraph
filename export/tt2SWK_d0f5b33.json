{"ver":"0.1","info":{"id":"tt2SWK","date":"1567266677","viewed":1126,"name":"Denoised SDF Path Tracer","username":"baldand","description":"It is raining lights, metal and glass balls\nA 1SPP path tracer using an animated SDF as the scene\nIncludes a denoising filter (image both with and without filter shown with horizontal slider)\nUse mouse to change view","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["3d","sdf","pathtracer","denoiser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nDenoised 1SPP SDF Path Tracer\n\nPath tracer based on:\nhttp://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n\nImplementation and denoiser: baldand/2019\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 crd = ivec2(fragCoord);\n    vec4 cf = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 cd = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 final = vec4(1.0);\n    bool ddd = fragCoord.x>iResolution.x*0.5+iResolution.x*0.5*sin(iTime);\n    final.rgb = ddd?cd.rgb:cf.rgb;\n    fragColor = pow(final,vec4(1.0/2.4));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\nDenoised 1SPP SDF Path Tracer\n\nPath tracer based on:\nhttp://www.realtimerendering.com/raytracing/Ray%20Tracing%20in%20a%20Weekend.pdf\n\nImplementation and denoiser: baldand/2019\n\n*/\n\n\n#define SAMPLES 1 \n#define APERTURE 0.05 // A little out of focus in foreground/background\n\nconst float M_PI = 3.141592653589793;\n\nstruct random_state {\n    uint z0;\n    uint z1;\n    uint z2;\n    uint z3;\n};\n\n    \nuint tst(in uint z, int S1, int S2, int S3, uint M) {\n    uint b = (((z << S1) ^ z) >> S2);\n    return (((z & M) << S3) ^ b);\n}\n\nuint lcg(in uint z, uint A, uint C) {\n    return (A*z+C);\n}\n\nvoid update_random(inout random_state rs) {\n    rs.z0 = tst(rs.z0, 13, 19, 12, 4294967294u);\n    rs.z1 = tst(rs.z1,  2, 25, 4,  4294967288u);\n    rs.z2 = tst(rs.z2, 3, 11, 17, 4294967280u);\n    rs.z3 = lcg(rs.z3, 1664525u, 1013904223u);\n    uint zt = rs.z3;\n    rs.z3 ^= rs.z2;\n    rs.z2 ^= rs.z1;\n    rs.z1 ^= rs.z0;\n    rs.z0 ^= zt;\n}\n\nvoid init_random(vec2 fragCoord, float time, inout random_state rs) {\n    rs.z0 = floatBitsToUint(fragCoord.y*0.1234567);\n    rs.z1 = floatBitsToUint(fragCoord.x*0.1234567);\n    rs.z2 = floatBitsToUint(time*0.1234567);\n    rs.z3 = floatBitsToUint(0.1234567);\n    // Mix up a bit\n    update_random(rs);\n    update_random(rs);\n    update_random(rs);\n    update_random(rs);\n}\n\nfloat random0(in random_state rs) {\n    return fract(0.00002328 * float(rs.z0));\n}\nfloat random1(in random_state rs) {\n    return fract(0.00002328 * float(rs.z1));\n}\nfloat random2(in random_state rs) {\n    return fract(0.00002328 * float(rs.z2));\n}\n\nvec3 random_in_unit_disk(inout random_state rs) {\n    update_random(rs);\n    vec3 r,p;\n    r.x = random0(rs);\n    r.y = random1(rs);\n    r.z = 0.0;\n    p =2.0 * r - vec3(1.0,1.0,0.0);\n    while (dot(p,p)>1.0) p *= 0.7;\n    return p;\n}\n\nconst uint Lambertian = 0u;\nconst uint Metal = 1u;\nconst uint Dielectric = 2u;\nconst uint DiffuseLight = 3u;\n\nstruct material {\n    uint mat_type;\n    vec3 albedo;\n    vec3 albedo2;\n    float fuzz;\n    float ref_idx;\n};\n    \nconst material materials[] = material[]( \n    material(Lambertian,  vec3(0.1, 1.0, 0.1), vec3(1.0, 0.1, 0.1), 0.0,0.0),\n    material(Lambertian,  vec3(0.75,0.75,0.5), vec3(0.75,0.75,0.5),0.0,0.0),\n    material(Metal,       vec3(0.7, 0.7, 0.7), vec3(0.7, 0.7, 0.7),0.0,0.0),\n    material(Dielectric,   vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0),0.0,1.5),\n    material(DiffuseLight,vec3(1.0,1.0,1.0),vec3(1.0,0.1,1.0),0.0,0.0)\n);\n\nvec2 model(vec3 pos, float tm) {\n    float ds1 = length(pos-vec3(0.0,1.4,0.0))-2.0; \n    vec3 ps = pos*0.5;\n    vec3 ds2v = vec3( fract(ps.x)-0.5, \n                      fract( (ps.y+tm*2.0+tm*0.31*mod(floor(ps.x),3.0)+0.21*floor(ps.z))*0.5 )*2.0-0.5,\n                      fract(ps.z)-0.5 );\n    float ds2 = length(ds2v) - 0.2*max(0.0,1.0-(abs(ps.y))*0.15);\n    float ds3 = length(pos-vec3(0.0,1.4,5.0))-2.0; \n    float ds4 = length(pos-vec3(5.0,1.4,5.0))-2.0; \n    float dground = pos.y + 0.4;\n    float ds34 = min(ds3, ds4);\n    float o34 = (ds3<ds4 ? -3.0 : -4.0);\n    float ds12 = min(ds1, ds2);\n    float o12 = (ds1<ds2 ? -1.0 : -2.0);\n    float ds1234 = min(ds12, ds34);\n    float o1234 = ds12 < ds34 ? o12 : o34; \n    return vec2(min(ds1234,dground), dground < ds1234?1.0:o1234);\n}\n\nvec3 get_normal(vec3 pos, float tm) {\n    float eps = 0.001;\n    float dx = model(pos+vec3(eps,0.,0.),tm).x-model(pos-vec3(eps,0.,0.),tm).x;\n    float dy = model(pos+vec3(0.,eps,0.),tm).x-model(pos-vec3(0.,eps,0.),tm).x;\n    float dz = model(pos+vec3(0.,0.,eps),tm).x-model(pos-vec3(0.,0.,eps),tm).x;\n    return normalize(vec3(dx,dy,dz));\n}\n                     \nstruct hit_record {\n    float t;\n    vec3 p;\n    vec3 normal;\n    float u;\n    float v;\n    int matidx;\n    float cohdist; // Coherence distance\n};\n\n\nvec3 emitted(hit_record rec) {\n    if (materials[rec.matidx].mat_type == DiffuseLight) {\n        return materials[rec.matidx].albedo;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nbool rm_hit(vec3 ro, vec3 rd, float t_min, float t_max, inout hit_record rec, float tm) {\n    rec.t = t_min;\n    vec3 p;\n    vec2 d;\n    \n    p = ro + rec.t*rd;\n    d = model(p, tm);\n    if (abs(d.x) < 0.00001) {\n        rec.p = p;\n        rec.normal = get_normal(p, tm);\n        if (d.y > 0.5) {\n            rec.matidx = 0;\n            rec.u = (p.x*0.4);\n            rec.v = (p.z*0.4);\n        }\n        else if (d.y > -1.5) {\n            rec.matidx = 1;\n            rec.u = fract(p.x*2.0+1.0);\n            rec.v = fract(p.y*2.0+0.5);\n        }\n        else if (d.y > -2.5) {\n            bool bx = fract(p.x*0.25)>0.5;\n            bool bz = fract(p.z*0.25)>0.5;\n            if (bx&&bz) rec.matidx = 4;\n            else if (bx) rec.matidx = 2;\n            else if (bz) rec.matidx = 3;\n            else rec.matidx = 1;\n            rec.u = 0.1;\n            rec.v = 0.1;\n        }\n        else if (d.y > -3.5) {\n            rec.matidx = 2;\n            rec.u = 0.1;\n            rec.v = 0.1;\n        }\n        else if (d.y > -4.5) {\n            rec.matidx = 4;\n            rec.u = 0.1;\n            rec.v = 0.1;\n        }\n        return true;\n    }\n    rec.t += abs(d.x)*0.5;\n    return false;\n}\n\nvec3 shade(hit_record rec) {\n    bool wu = fract(rec.u*0.5)>0.5;\n    bool wv = fract(rec.v*0.5)>0.5;\n    if (wu^^wv) {\n        return materials[rec.matidx].albedo;\n    } else {\n        return materials[rec.matidx].albedo2;\n    }\n}\n\nvec3 random_in_unit_sphere(vec3 r) {\n    vec3 p;\n    p = 2.0 * r - vec3(1.0);\n    while (dot(p,p) > 1.0) p *= 0.7;\n    return p;\n}\n\n\nbool refract2(vec3 v, vec3 n, float ni_over_nt, inout vec3 refracted) {\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float disc = 1.0 - ni_over_nt * ni_over_nt * (1.0-dt*dt);\n    if (disc > 0.0) {\n        refracted = ni_over_nt * (uv - n*dt) - n*sqrt(disc);\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfloat schlick(float csn, float idx) {\n    float r0 = (1.0-idx) / (1.0+idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow(1.0-csn,5.0);\n}\n\nbool scatter(hit_record rec, vec3 ro, vec3 rd, inout vec3 attenuation, inout vec3 scro, inout vec3 scrd, inout random_state rs, inout float cohdist) {\n   vec3 r;\n   update_random(rs);\n   r.x = random0(rs);\n   r.y = random1(rs);\n   r.z = random2(rs);\n   vec3 reflected = reflect(rd, rec.normal);\n   attenuation = shade(rec);\n   if (cohdist>0.0) cohdist += length(attenuation*vec3(313.0,513.0,713.0));\n   uint mt = materials[rec.matidx].mat_type;\n   if (mt == Lambertian) {\n       vec3 target = normalize(rec.normal + random_in_unit_sphere(r));\n       scro = rec.p;\n       scrd = target;\n       cohdist = -abs(cohdist); // Will not be increased after this\n       return true;\n   } else if (mt == Metal) {\n       vec3 rius = random_in_unit_sphere(r);\n       scro = rec.p;\n       float fuzz = materials[rec.matidx].fuzz;\n       scrd = ((1.0-fuzz)*reflected + fuzz*rius) + fuzz*(rec.normal + rius);\n       return dot(scrd,rec.normal) > 0.0; \n   } else if (mt == Dielectric) {\n       vec3 outward_normal;\n       float ni_over_nt;\n       vec3 refracted;\n       float reflect_prob = 1.0;\n       float csn;\n       float il = 1.0/length(rd);\n       float drdnor = dot(rd, rec.normal);\n       float idx = materials[rec.matidx].ref_idx;\n       if (drdnor > 0.0) {\n           outward_normal = -rec.normal;\n           ni_over_nt = idx;\n           csn = ni_over_nt * drdnor * il;\n       } else {\n           outward_normal = rec.normal;\n           ni_over_nt = 1.0/idx;\n           csn = -drdnor * il;\n       }\n       if (refract2(rd, outward_normal, ni_over_nt, refracted)) {\n           reflect_prob = schlick(csn, idx);\n       }\n       if (r.x < reflect_prob) {\n           scro = rec.p;\n           scrd = reflected;\n       } else {\n           scro = rec.p;\n           scrd = refracted;\n       }\n       return true;\n   } else if (mt == DiffuseLight) {\n       return false;\n   }\n   return false;\n}\n\nvec4 color(vec3 ro, vec3 rd, inout random_state rs, float tm) {   \n    vec3 emit_accum = vec3(0.0);\n    vec3 attenuation_accum = vec3(1.0);\n    int depth = 0;\n    bool done = false;\n    hit_record rec;\n    rec.t = 0.001;\n    int max_depth = 1000;\n    float tt;\n    rd = normalize(rd);\n    float initcohdist = 0.0*dot(rd,0.01*vec3(3.0,7.0,11.0));\n    rec.cohdist = initcohdist;\n    while (!done) {\n        tt = rec.t;\n        bool hit = rm_hit(ro, rd, rec.t, 1E9, rec, tm);\n        \n        if (hit && depth < max_depth) {\n            if (rec.cohdist>=initcohdist) rec.cohdist += tt;\n            vec3 scro, scrd;\n            vec3 attenuation;\n            vec3 emitcol = emitted(rec);\n            emit_accum += emitcol * attenuation_accum;\n            if (scatter(rec, ro, rd, attenuation, scro, scrd, rs, rec.cohdist)) {\n                attenuation_accum *= attenuation;\n                ro = scro;\n                rd = normalize(scrd);\n                rec.t = 0.001;\n            } else {\n                done = true;\n            }\n        } else if (depth >= max_depth) {\n            vec3 unit_direction = normalize(rd);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            vec3 albedo = ((1.0-t)*vec3(1.0) + t*vec3(0.25,0.5,1.0));\n            emit_accum += attenuation_accum * albedo * 0.01;\n            done = true;\n        }    \n        depth += 1;\n    }\n    \n    return vec4(emit_accum,abs(rec.cohdist)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize pseudo random number gen \n    random_state rs;\n    float time = iTime*1.0 + 25.0*iMouse.x/iResolution.x;\n    init_random(fragCoord, time+iMouse.y, rs);\n    \n    vec3 col = vec3(0.0);\n    float dav = 0.0;\n    float ddiv = 0.0;\n    \n    // Sample\n    int ns = SAMPLES;\n    for (int s=0; s<ns; s++) {\n        //world[6].center.y = 1.0+sin(time);\n        // Camera init\n        float orbit_radius = 15.0;\n        vec3 look_from = vec3(orbit_radius * sin(0.1*time), 1.5+cos(time*0.1)+5.0*iMouse.y/iResolution.y, orbit_radius*cos(0.1*time));\n        vec3 look_at = vec3(0.0);\n        float focus_dist = length(look_from - look_at) - 2.0;\n        float aspect = iResolution.x/iResolution.y;\n        vec3 vup = vec3(0.0,1.0,0.0);\n        float aperture = APERTURE; \n        float lens_radius = aperture * 0.5;\n        float vfov = 35.0;\n        float theta = vfov*M_PI/180.0;\n        float half_height = tan(theta*0.5);\n        float half_width = aspect * half_height;\n        vec3 origin = look_from;\n        vec3 w = normalize(look_from - look_at);\n        vec3 u = normalize(cross(vup, w));\n        vec3 v = cross(w, u);\n        vec3 lower_left_corner = origin - half_width * focus_dist * u - half_height*focus_dist*v - focus_dist*w;\n        vec3 horizontal = 2.0 * half_width * focus_dist* u;\n        vec3 vertical = 2.0 * half_height * focus_dist *v;\n        \n        // Generate a ray\n        vec2 st = vec2(fragCoord.x/iResolution.x + 0.0*random0(rs)/iResolution.x,\n                      fragCoord.y/iResolution.y + 0.0*random1(rs)/iResolution.y);\n        vec3 rd = lens_radius * random_in_unit_disk(rs);\n        vec3 offset = u*rd.x + v*rd.y;\n        vec3 ro = origin + offset;\n        rd = lower_left_corner + st.x*horizontal + st.y*vertical - origin - offset;\n        \n        // Sample from the scene along that ray\n        vec4 cold = color(ro, rd, rs, time);\n        col += cold.rgb;\n        float cd = cold.a;//max(cold.a,0.0001);\n        dav += cd;\n        ddiv += cd;//abs(1.0-float(s+1)*cd/dav);        \n        time += 1.0/(30.0*float(ns)); // Motion blur        \n    }\n    col.rgb *= (1.0/float(ns));\n    fragColor = vec4(clamp(col,0.0,10.0),ddiv/float(ns));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 crd = ivec2(fragCoord);    \n    ivec2 texsize = textureSize(iChannel0, 0);\n    vec4 c = texelFetch(iChannel0, crd, 0); \n    vec4 acc = c;\n    float count = 1.0;\n    float ra = c.a;\n    int size = texsize.y/8;\n    for (int yoff = -1; yoff > (-size-1); yoff--) {\n        // Weight far away source pixels less\n        float weight = 1.0-abs(float(yoff))/float(size);\n        \n\t\t// Reflect at edge        \n        ivec2 ycrd = crd+ivec2(0,yoff);\n        //if (ycrd.y<0) ycrd = ivec2(crd.x, yoff-crd.y);\n        \n        vec4 oth = texelFetch(iChannel0, ycrd, 0);\n        float ddist = abs(oth.a-ra);\n        if (ddist<0.5) {\n            acc.rgb += oth.rgb*weight; \n            count += weight; \n            ra = oth.a; \n        }\n    }\n    ra = c.a;\n    for (int yoff = 1; yoff < (size+1); yoff++) {\n        // Weight far away source pixels less\n        float weight = 1.0-abs(float(yoff))/float(size);\n        \n\t\t// Reflect at edge        \n        ivec2 ycrd = crd+ivec2(0,yoff);\n        //if (ycrd.y>=texsize.y) ycrd = ivec2(crd.x, texsize.y-ycrd.y);\n        \n        vec4 oth = texelFetch(iChannel0, ycrd, 0);\n        float ddist = abs(oth.a-ra);\n        if (ddist<0.5) {\n            acc.rgb += oth.rgb*weight; \n            count += weight; \n            ra = oth.a;\n        }\n    }\n    \n    // Is this an edge that needs some anti-aliasing?\n    if (count<=1.0) {\n        acc.rgb += 0.25*texelFetch(iChannel0, crd+ivec2(0,-2),0).rgb;\n        acc.rgb += 0.5*texelFetch(iChannel0, crd+ivec2(0,-1),0).rgb;\n        acc.rgb += 0.5*texelFetch(iChannel0, crd+ivec2(0,1),0).rgb;\n        acc.rgb += 0.25*texelFetch(iChannel0, crd+ivec2(0,2),0).rgb;\n        count += 1.5;\n    }\n    \n    fragColor = acc * (1.0/count);\n    fragColor.a = c.a;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 crd = ivec2(fragCoord);    \n    ivec2 texsize = textureSize(iChannel0, 0);\n    vec4 c = texelFetch(iChannel0, crd, 0); \n    vec4 acc = c;\n    float count = 1.0;\n    float ra = c.a;\n    int size = texsize.x/8;\n    for (int xoff = -1; xoff > (-size-1); xoff--) {\n        float weight = 1.0-abs(float(xoff))/float(size);\n        ivec2 xcrd = crd+ivec2(xoff,0);\n        vec4 oth = texelFetch(iChannel0, xcrd, 0);\n        float ddist = abs(oth.a-ra);\n        if (ddist<0.5) { \n            acc.rgb += oth.rgb*weight; \n            count += weight; \n            ra = oth.a; \n        }\n    }\n    ra = c.a;\n    for (int xoff = 1; xoff < (size+1); xoff++) {\n        float weight = 1.0-abs(float(xoff))/float(size);\n        ivec2 xcrd = crd+ivec2(xoff,0);\n        vec4 oth = texelFetch(iChannel0, xcrd, 0);\n        float ddist = abs(oth.a-ra);\n        if (ddist<0.5) {\n            acc.rgb += oth.rgb*weight; \n            count += weight; \n            ra = oth.a;\n        }\n    }\n    \n    // Is this an edge that needs some anti-aliasing?\n    if (count<=1.0) {\n        acc.rgb += 0.25*texelFetch(iChannel0, crd+ivec2(-2,0),0).rgb;\n        acc.rgb += 0.5*texelFetch(iChannel0, crd+ivec2(-1,0),0).rgb;\n        acc.rgb += 0.5*texelFetch(iChannel0, crd+ivec2(1,0),0).rgb;\n        acc.rgb += 0.25*texelFetch(iChannel0, crd+ivec2(2,0),0).rgb;\n        count += 1.5;\n    }\n    \n    fragColor = acc * (1.0/count);\n    fragColor.a = c.a;\n}","name":"Buffer C","description":"","type":"buffer"}]}