{"ver":"0.1","info":{"id":"lstXD7","date":"1459818183","viewed":396,"name":"collab x cabbibo","username":"macbooktall","description":"cabbibo and i are ping ponging some code and rendering gifs and this march is from the first we made here: https://twitter.com/Cabbibo/status/717753579553959936\n\nuse mouse to adjust camera","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n// License Creative Commons Attribution-NonCommercial License.\n// Includes code from hg_sdf library by Mercury http://mercury.sexy/hg_sdf/\n// Also includes smooth min by IQ https://iquilezles.org/articles/smin\n\nconst float MAX_TRACE_DISTANCE = 4.0; // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 50;\n\n#define MOUSE_CAM \n//#define ROTATE_SHAPE\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\nfloat fOctahedron(vec3 p, float r) {\nfGDFBegin\nfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\nfGDFEnd\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n, float phase) {\n    float d = min(a, b);\n    vec2 p = vec2(a, b);\n    pR45(p);\n    p = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n    p.x += 0.5*sqrt(2.)*r/n;\n    float x = r*sqrt(2.)/n;\n    p.x += phase * x;\n    pMod1(p.x, x);\n    d = min(d, p.y);\n    pR45(p);\n    return min(d, vmax(p -vec2(0.5*r/n)));\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p+halfsize, size) - halfsize;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n        p += size*(c - stop);\n        c = stop;\n    }\n    if (c <start) {\n        p += size*(c - start);\n        c = start;\n    }\n    return c;\n}\n\n// From https://www.shadertoy.com/view/XtjSRm\n// shane code\nfloat vNoise( in vec3 p )\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) ); p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy); \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\n\nfloat shapeSize = .75;\n\nvec2 map1(vec3 pos) {\n\n    vec3 p = pos;\n    float rep = 8.;\n    vec2 idx = floor((pos.xz - shapeSize) / max(pos.xz,0.3))*0.1;\n    float i = pModPolar(pos.xz, rep);\n    float clock = iTime*4.;\n    float phase = length(pos.xz)*4.;\n    float anim = sin(phase + clock);\n    \n    pos.x -= shapeSize*1. + anim*0.05;\n\n    float dist = fTorus(pos, shapeSize*0.25, shapeSize*0.5);\n    float centerTorus = fTorus(p, shapeSize*0.25, shapeSize);\n    float centerOcta = fOctahedron(p - vec3(0.,cos(clock)*0.05,0.), shapeSize*0.75);\n\n    dist = fOpUnionStairs(dist, centerTorus, .1 + anim*0.1, 4., 0.);\n    dist = smin(dist, centerOcta, 0.2);\n\n    vec2 res = vec2(dist, abs(pos.y));\n\nreturn res;\n}\n\nvec2 map2(vec3 pos , float io) {\n\n    vec3 p = pos;\n    float rep = 4.;\n\n    float i = pModPolar(pos.xz, rep);\n    float x = pModInterval1(pos.x, shapeSize*0.05, 0., 15.);\n    float clock = iTime*4.;\n    float phase = length(pos.xz)*2.;\n    float anim = sin(phase + clock);\n    \n    pos.x -= shapeSize*.35;\n    pos.z -= anim*0.1;\n\n    float dist = fOctahedron(pos, shapeSize*.25);\n    float centerShape = fOctahedron(p,shapeSize*0.8);\n\n    dist = min(dist, centerShape);\n    \n    vec2 res = vec2(dist, abs(pos.y));\n    res.x = io * res.x;\n\n    return res;\n}\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nvec2 map( vec3 pos , float io ){ \n\n    #ifdef ROTATE_SHAPE\n    pos.xz = rotate(pos.xz, iTime);\n    pos.xy = rotate(pos.xy, sin(iTime*4.)*0.1);\n\t#endif\n    \n\treturn mix(map1(pos),map2(pos , io),0.3);\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd , float io ){\n    float h = INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n    if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n    vec2 m = map( ro+rd*t , io );\n    h = m.x;\n    t += h;\n    id = m.y;\n\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return vec2( res , id );\n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos, in float io ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n    map(pos+eps.xyy , io).x - map(pos-eps.xyy , io).x,\n    map(pos+eps.yxy , io).x - map(pos-eps.yxy , io).x,\n    map(pos+eps.yyx , io).x - map(pos-eps.yyx , io).x );\n    return normalize(nor);\n}\n\n// Gets background color if nothing is hit\n// also used for refraction\nvec3 bgCol( in vec3 p ){\n\n    float n = vNoise( p * .2 + sin( iTime * 4.0 ) * .005) * vNoise( p * 1. + sin( iTime * 4.0 )* .005);\n    vec3 disPos = vec3( p );\n    vec3 c = n * (normalize(disPos)*.5+ .5 );// * texture( iChannel0 , normalize(-p )).xyz;\n    \n    c = vec3( n *n *n * 10.0);\n    \n    return c;\n}\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n    vec3 color = vec3( 0. );\n\n    vec3 lightPos = vec3( 1. , 4. , 3. );\n\n    float ior = .8; // index of refraction\n    float lba = .02; // light bend amount\n\n    if( res.y > -.5 ){\n\n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos , 1. );\n\n        vec3 lightDir = normalize( lightPos - pos );\n\n        float match = max( 0. , dot( lightDir , norm ));\n\n        vec3 refrR = refract( rd , norm , ior * (1. - lba) );\n        vec3 refrG = refract( rd , norm , ior * 1. );\n        vec3 refrB = refract( rd , norm , ior * (1. + lba) );\n\n        vec3 posR = pos + refrR * INTERSECTION_PRECISION * 1000.;\n        vec3 posG = pos + refrG * INTERSECTION_PRECISION * 1000.;\n        vec3 posB = pos + refrB * INTERSECTION_PRECISION * 1000.;\n\n        //vec3 colR = texture( iChannel0 , refrR ).xyz * vec3( 1. , 0., 0. );\n        //vec3 colG = texture( iChannel0 , refrG ).xyz * vec3( 0. , 1., 0. );\n        //vec3 colB = texture( iChannel0 , refrB ).xyz * vec3( 0. , 0., 1. );\n\n        float r = 0.;\n        float g = 0.;\n        float b = 0.;\n\n\n        vec2 resR = calcIntersection( posR , refrR , -1. );\n        vec2 resG = calcIntersection( posG , refrG , -1. );\n        vec2 resB = calcIntersection( posB , refrB , -1. );\n\n\n        vec3 p2 , n2 , r2;\n\n        if( resR.y == 2. ){\n        p2 = posR + refrR * resR.x;\n        n2 = calcNormal( p2 , -1. );\n\n\n        r = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n\n        p2 = posR + refrR * resR.x;\n        n2 = calcNormal( p2 , -1. );\n        r2 = refract( refrR , n2 , ior * (1. - lba) );\n\n        r = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).x;\n\n    }\n\n    if( resG.y == 2. ){\n\n        p2 = posG + refrG * resG.x;\n        n2 = calcNormal( p2 , -1. );\n        g = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n\n        p2 = posG + refrG * resG.x;\n        n2 = calcNormal( p2 , -1. );\n        r2 = refract( refrG , n2 , ior * 1. );\n        g = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).y;\n    }\n\n    if( resB.y == 2. ){\n\n    p2 = posB + refrB * resB.x;\n    n2 = calcNormal( p2 , -1. );\n    b = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n\n    p2 = posB + refrB * resB.x;\n    n2 = calcNormal( p2 , -1. );\n    r2 = refract( refrB , n2 , ior * (1. + lba) );\n\n    b = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).z;\n\n    }\n\n\n    color = vec3( r , g , b );\n\n\n\n\n\n\n\n\n\n\n\n    }else{\n\n    color = bgCol( rd * MAX_TRACE_DISTANCE );\n\n    }\n\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    #ifdef MOUSE_CAM    \n    float angle = iMouse.x / iResolution.x * 2. * 3.14 ;\n    float y = ((iMouse.y / iResolution.y ) -.5 ) * 2.0;\n\n    vec3 ro = vec3( cos( angle ) * shapeSize*4. , y , sin( angle ) * shapeSize*4. );\n    #else\n    vec3 ro = vec3( shapeSize*4. + cos( iTime*4. ) * 0.025 , 0. ,shapeSize +  sin( iTime*4. ) * .025 );    \n    #endif\n\n    vec3 ta = vec3( 0. , 0. , 0. );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, .0 ); // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.5) ); // 2.0 is the lens length\n\n    vec2 res = calcIntersection( ro , rd , 1. );\n\n\n    vec3 color = render( res , ro , rd );\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}