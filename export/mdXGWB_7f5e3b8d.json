{"ver":"0.1","info":{"id":"mdXGWB","date":"1666734384","viewed":185,"name":"Lissajous curves (L1, L2, Linf)","username":"Envy24","description":".","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["sdf","curves","norm","lissajous","metric","l1","l2","linf"],"hasliked":0,"parentid":"ddfGz2","parentname":"Distance field coloring"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) ) // PS - pixel size\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE               ( 10. )\n#define TAU                         6.2831853071795862\n\n// Pick one of this metrics:\n/* L1 metric *\n#define METRIC(B, E) ( L1(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_L1(P, B, E, R) )\n/* L2 metric */\n#define METRIC(B, E) ( L2(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_L2(P, B, E, R) )\n/* Linf metric *\n#define METRIC(B, E) ( Linf(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_Linf(P, B, E, R) )\n/**/\n\nvec2 Lissajous_curve(\n    in float t,   \n    in float a,\n    in float b,\n    in float phase)\n{ \n    return vec2(sin(a*t+phase), sin(b*t)); \n}\n\nfloat LissajousSDF(\n    in vec2 NDC,\n    in float a,\n    in float b,\n    in float phase)\n{\n    float min_dist = 99.,\n          count = 300.,\n          l = 0., r = TAU,\n          dt = (r-l) / (count-1.);\n    \n    vec2 B = Lissajous_curve(l, a, b, phase);\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        vec2 E = Lissajous_curve(l + dt * i, a, b, phase);\n        min_dist = \n            min(min_dist, SEGMENT(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return min_dist;\n}\n\n#define UNIT                      ( 32.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define F                         ( 30. )\n\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*SMAA((width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1.), SMAA(abs(dist)) );\n}\n\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    /**\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]\n    \n    return SC - origin;              // shift to new origin.\n}\n\nint gcd(int A, int B)\n{\n    while (B != 0)\n    {\n        int remainder = A % B;\n        A = B;\n        B = remainder;\n    }\n\n    return A;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{    \n    float cell_size = float(gcd(int(R.x), int(R.y))); // for square cells\n          cell_size = cell_size < 5. ? R.x/10. : cell_size; // if gcd is to small.\n    \n    vec2 cell_center =\n        map_to_centered_ndc(\n            PIXELATE(SC, cell_size) + cell_size*0.5,\n            FIELD_SCALE,\n            vec2(0));\n    vec2 NDC = map_to_centered_ndc(SC, FIELD_SCALE, cell_center);\n    \n    vec2 ab = 1.+floor(SC / cell_size);\n    float minDist = LissajousSDF(NDC, ab.x, ab.y, iTime*0.25);\n\n    vec3 color = colorize_field(minDist, vec3(0.7, 0.4, 0.1));\n    //color = mix( vec3(0), vec3(1), SMAA(minDist) );\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat Linf(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return max(abs(D.x), abs(D.y));\n}\n\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_L1(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    float invD0 = 1.0 / (S.y-E.y);\n    return min(L1(P(clamp((NDC.x-S.x) / (E.x-S.x), 0.0, 1.0)), NDC), \n               min(L1(P(clamp((NDC.y+S.y) * invD0, 0.0, 1.0)), NDC),\n                   L1(P(clamp((S.y-NDC.y) * invD0, 0.0, 1.0)), NDC))) - R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat segmentSDF_Linf(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    return min(Linf(P(clamp((S.y-S.x+NDC.x-NDC.y)/(E.x-S.x+S.y-E.y), 0.0, 1.0)), NDC), \n               Linf(P(clamp((S.y-NDC.y+S.x-NDC.x)/(S.x-E.x+S.y-E.y), 0.0, 1.0)), NDC)) - R;\n}","name":"Common","description":"","type":"common"}]}