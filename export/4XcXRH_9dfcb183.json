{"ver":"0.1","info":{"id":"4XcXRH","date":"1718571669","viewed":105,"name":"Spherical Harmonics Sandbox","username":"mxcop","description":"Reading radiance data from spherical harmonics!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Minimized version of \"https://www.shadertoy.com/view/lt2GRD\" for personal experimentation :D */\n\n// https://iquilezles.org/articles/intersectors\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat map(in vec3 p)\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 4.5;\n    \n\tfor( int i=0; i<1; i++ )\n    {\n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        b += iTime * 2.0;\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calc_normal(in vec3 pos, in float t, in float px)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, in float px)\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 ) return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\n\tfloat t = dis.x;\n\tfor(int i=0; i<128; i++)\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    if( t<dis.y )\n    {\n        res = t;\n    }\n\n    return res;\n}\n\n/* Near-field ambient occlusion for SDF\n * h : surface hit point.\n * n : surface hit normal.\n * stp : ao step size (should be small) */ \nfloat ray_nao(in vec3 h, in vec3 n, in float stp) {\n    vec3 p = h + n * stp;\n    float d = max(map(p), 0.0);\n    return (stp - d) / stp;\n}\n\n/* Ray sphere intersection test (return -1.0 if miss) */\nfloat ray_sphere(in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float r) {\n    vec3 ce = ro - sphere_pos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax) return t;\n    }\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*1.5);\n\n    /* Animate camera */\n    vec3 eye = vec3(0.0, 1.0, 2.0);\n    vec2 rot = 6.2831 * (vec2(0.6 + iTime * 0.1, sin(iTime * 0.5) * 0.06) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    /* Camera matrix */\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));   \n\n    vec3 col = vec3(0.0);\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n\n    /* Trace the sphere */\n    // float t = ray_sphere(ro, rd, tmin, tmax, sphere_radius);\n    float t = raycast(ro, rd, px);\n    if (t > tmin) {\n        vec3 spos = ro + rd * t;\n        vec3 n = calc_normal(spos, t, px);\n        float tst = clamp(dot(rd, n), 0.2, 0.8);\n        \n        // col = fetch_radiance(normalize(n + spos - sphere_pos));\n        vec3 spec = fetch_radiance(reflect(rd, n));\n        vec3 diff = fetch_radiance(n);\n        float ao = ray_nao(spos, n, 0.1);\n        col = spec * (1.0 - tst) + diff * (tst);\n        // col = eval_radiance(n, ao);\n    } else {\n        col = fetch_radiance(rd);\n    }\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 sphere_pos = vec3(0.0, 1.0, 0.0);\nfloat sphere_radius = 1.0;\n\nconst float PI = 3.14159265359;\n\nstruct SH9 {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SH9 grace = SH9(\n    vec3( 0.2953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.3646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\n/* Fetch radiance in given direction N from SH9 */\nvec3 fetch_radiance(vec3 n) {\n    const SH9 c = grace;\n    const float c1 = 0.429043;\n    const float c1x2 = 0.429043 * 2.0;\n    const float c2 = 0.511664;\n    const float c2x2 = 0.511664 * 2.0;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (n.x * n.x - n.y * n.y) +\n        c3 * c.l20 * n.z * n.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        c1x2 * c.l2m2 * n.x * n.y +\n        c1x2 * c.l21  * n.x * n.z +\n        c1x2 * c.l2m1 * n.y * n.z +\n        c2x2 * c.l11  * n.x +\n        c2x2 * c.l1m1 * n.y +\n        c2x2 * c.l10  * n.z\n    );\n}\n\nvec3 eval_radiance( vec3 _Direction, float _CosThetaAO ) {\n    const SH9 c = grace;\n    float   t2 = _CosThetaAO*_CosThetaAO;\n    float   t3 = t2*_CosThetaAO;\n    float   t4 = t3*_CosThetaAO;\n    float   ct2 = 1.0 - t2; \n\n    float       c0 = 0.88622692545275801364908374167057 * ct2;          // 1/2 * sqrt(PI) * (1-t^2)\n    float       c1 = 1.02332670794648848847955162488930 * (1.0-t3);     // sqrt(PI/3) * (1-t^3)\n    float       c2 = 0.24770795610037568833406429782001 * (3.0 * (1.0-t4) - 2.0 * ct2); // 1/16 * sqrt(5*PI) * [3(1-t^4) - 2(1-t^2)]\n    const float sqrt3 = 1.7320508075688772935274463415059;\n\n    float   x = _Direction.x;\n    float   y = _Direction.y;\n    float   z = _Direction.z;\n\n    return  max( vec3(0.0), c0 * c.l00                                       // c0.L00\n            + c1 * (c.l1m1*y + c.l10*z + c.l11*x)                     // c1.(L1-1.y + L10.z + L11.x)\n            + c2 * (c.l20*(3.0*z*z - 1.0)                              // c2.L20.(3z²-1)\n                + sqrt3 * (c.l22*(x*x - y*y)                           // sqrt(3).c2.L22.(x²-y²)\n                    + 2.0 * (c.l2m2*x*y + c.l2m1*y*z + c.l21*z*x)))    // 2sqrt(3).c2.(L2-2.xy + L2-1.yz + L21.zx)\n        );\n }\n","name":"Common","description":"","type":"common"}]}