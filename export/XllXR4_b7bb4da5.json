{"ver":"0.1","info":{"id":"XllXR4","date":"1434899433","viewed":654,"name":"Phong + reflection + soft shadow","username":"Lallis","description":"Trying out some phong lighting with added reflection and direct light with soft shadow in a raymarcher.\nEDIT: Thanks to Dave for help! :) ; Updated the shader to Blinn-Phong model.\nLet me know if you have any other suggestions!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["reflection","phong","raymarch","lighting","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat sphere(vec3 rp, vec3 c, float r)\n{\n\treturn distance(rp,c)-r;\n}\n\nfloat cube( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec4 map(vec3 rp)\n{\n\tvec4 d;\n\tvec4 sp = vec4( vec3(0.45, 0.31, 0.24), sphere(rp, vec3(-0.7,2.0,-0.7), 1.0) );\n\tvec4 sp2 = vec4( vec3(0.65, 0.52, 0.45), sphere(rp, vec3(0.7,2.0,0.7), 1.0) );\n\tvec4 cb = vec4( vec3(0.85, 0.30, 0.40), cube(rp, vec3(1.0,1.0,1.0), 0.025) );\n\tvec4 py = vec4( vec3(0.95, 0.84, 0.65), rp.y+1.0+sin(rp.x*10.0)*0.1+cos(rp.z*10.0)*0.1 );\n\td = (sp.a < cb.a) ? sp : cb;\n\td = (d.a < py.a) ? d : py;\t\n\td = (d.a < sp2.a) ? d : sp2;\n\treturn d;\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy).a - map(rp-eps.xyy).a,\n           map(rp+eps.yxy).a - map(rp-eps.yxy).a,   //shamelessly stolen from iq :(\n           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );\n\n}\n\nfloat softShadow(vec3 ro, vec3 lp)\n{\n\tvec3 rd = normalize(lp-ro);\n\tfloat tmax = distance(lp,ro);\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfor(int i = 0; i<256; i++ )\n\t{\n        if(t>=tmax) break;\n\t\tfloat d = map(ro+rd*t).a;\n\t\tif(d < 0.001) return 0.0;\n\t\tres = min(res, 8.0*d);\n\t\tt += d;\n\t}\n\treturn res;\n}\n\nfloat ao(vec3 ro, vec3 norm, float k)\n{\n    float res = 0.0;\n    float f = 0.1;\n    for(int i = 1; i<6; i++)\n    {\n        vec3 rp = ro + f*float(i)*norm;\n     \tres+=(1.0/pow(2.0,float(i)))*(f*float(i)-map(rp).a);    \n    }\n\treturn 1.0-k*res;\n}\n\n\n\nvec3 lp(){ \n    return vec3(1.0,4.0,3.0)*rot(vec3(0.0,time*0.5,0.0));\n}\n\nvec3 reflection(vec3 rro, vec3 rd, vec3 n, vec3 ro)\n{\n    vec3 res = vec3(0.80, 0.75, 0.70)*0.35; //ambient reflection\n    int chk = 1;\n    for(int j = 0; j<3; j++)\t\t// 3 reflections\n    {\n\t\trd = reflect(rd, n);\t\n\t\tfloat tmax = 50.0;\n   \t\tfloat t = 0.1;\n    \tvec3 rp = rro;\n    \tvec4 d = vec4(res, 1.0);\n    \tif(chk == 1)\n    \t{\n\t\t\tfor(int i = 0; i<256; i++ )\n\t\t\t{\n        \t\tif(t>=tmax) break;\n\t\t\t\trp = rro+rd*t;\n\t\t\t\td = map(rp);\n\t\t\t\tif(d.a < 0.001) break;\n\t\t\t\tt += d.a*(0.35+t/tmax);\n\t\t\t}\n    \t}\n    \tchk = 0;\n    \tif(d.a < 0.001) \n\t\t{\t\t\n    \t\tfloat ks = 0.1;\n\t\t\tfloat kd = 0.1;\t\t\n\t\t\tfloat ka = 0.04;\n        \tfloat a = 3.0;\n\t\t\tfloat aof = 0.06;\t\n\t\t\tfloat ss = 0.2;\t\t\n\t\t\t\n\t\t\tvec3 l = normalize(lp()-rp);          \n\t\t\tn = normal(rp);\t\t\t\t\n\t\t\tvec3 v = normalize(ro-rp);\n        \tvec3 h = normalize(l+v);\t\t\n\t\t\t\n\t\t\tfloat illumination  = ka*ao(rp,n, aof) \t\t\t\t\n\t\t\t\t\t\t\t\t+ kd*max(dot(l,n),0.0)\n                         \t    + ks*pow(max(dot(n,h),0.0),a)\t\t\n\t\t\t\t\t\t\t\t+ ss*softShadow(rp, lp());\n        \tillumination = max(illumination, 0.0);\n\t\t\tres += d.rgb*illumination*(1.0/pow(2.0,float(j)));\n        \tchk = 1;\n        \trro = rp;\n\t\t}\n    }\n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n\tp.y+=1.0;\n\tp.x*=iResolution.x/iResolution.y;\t\n\tfloat f = -5.0*(sin(time*0.2)*0.25+0.75);\n\tvec3 col = vec3(0.95, 0.84, 0.65)*0.35;\n\tvec3 ang = vec3((iMouse.y == 0.0 ? 0.25 :iMouse.y/iResolution.y)*3.141592*0.5,\n                     time*0.1+(iMouse.x/iResolution.y)*3.141592,\n                     0.0);\n\tvec3 ro = vec3(0.0,1.0,f-2.0);\n\tvec3 rd = normalize(vec3(p,f)-ro);\n\tro*=rot(ang);\n\trd*=rot(ang);\n\tvec3 rp;\n\tfloat tmax = 50.0;\n\tfloat t = 0.5;\n    vec4 d = vec4(col, 1.0);\n\tfor(int i = 0; i<256; i++)\n\t{\n        if(t >= tmax) break;\n\t\trp = ro+rd*t;\n\t\td = map(rp);\n\t\tif(d.a < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.a*(0.35+t/tmax);\n\t}\n\tif(d.a < 0.001)\n    {\n   \t\tfloat ks = 0.33;\t\t//specular reflection constant\n\t\tfloat kd = 0.33;\t\t//diffuse reflection constant\n\t\tfloat ka = 0.33;\t\t//ambient reflection constant\n\t\tfloat a = 3.0;\t\t//shininess constant\n\t\tfloat aof = 5.0;\t//ambient occlusion amount\n\t\tfloat ss = 0.5;\t\t//direct light amount\n\t\tfloat rf = 1.0;\t\t//reflection amount\n\t\t\t\n\t\tvec3 l = normalize(lp()-rp);          //surface to light vector\n\t\tvec3 n = normal(rp);\t\t\t\t//surface normal vector\n\t\tvec3 v = normalize(ro-rp);\t\t\t//surface to camera vector\n        vec3 h = normalize(l+v);\t\t\t//the \"half way vector\"\n\t\t\t\n\t\tvec3 illumination  =  ka*ao(rp,n, aof) \t\t\t\t//add ambient light\n\t\t\t\t\t\t\t+ kd*max(dot(l,n),0.0) \t\t\t//add diffuse light\n\t\t\t\t\t\t\t+ ks*max(pow(dot(n,h),a),0.0)\t//add specular light\n\t\t\t\t\t\t\t+ ss*softShadow(rp, lp())\t\t//add direct light\n           \t\t\t\t\t+ rf*reflection(rp,rd,n,ro);\n\t\t\t\t\t\t\t\t\n\t\t\t\n\t\tcol = d.rgb*illumination;\n    }\n    \n\tfloat dlp = length(cross(lp()-ro, lp()-(ro+rd)))/length((ro+rd)-ro);\n\tcol+=max(exp(-dlp*6.0),0.0);\n\n\tfragColor = vec4(col,1.0);\t\n}","name":"Image","description":"","type":"image"}]}