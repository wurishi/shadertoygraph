{"ver":"0.1","info":{"id":"sstyRB","date":"1653667553","viewed":64,"name":"A Broken PBR Stuff","username":"nelsonkuang","description":"A Broken PBR Stuff","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mainly referenced from: https://www.shadertoy.com/view/XlKSDR\n#ifndef saturate\n  #define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n#define PI 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float PRECISION = 0.001;\n\nfloat getAmp(float frequency) { // from: https://www.shadertoy.com/view/4ljGD1\n  return texture(iChannel0, vec2(frequency / 512.0, 0)).x;\n}\n\nfloat getWeight(float f) { // from: https://www.shadertoy.com/view/4ljGD1\n  return (+getAmp(f - 2.0) + getAmp(f - 1.0) + getAmp(f + 2.0) + getAmp(f + 1.0) + getAmp(f)) / 5.0;\n}\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n  return p.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n  return d1.x < d2.x ? d1 : d2;\n}\n\n// I just want to draw an egg, but wtf? out of control now.\nfloat sdWTF(vec3 p, float n, vec3 offset) {\n  float weight = getWeight(p.y * cos(iTime) + p.y * sin(iTime));\n  float scale = clamp(1.5 * weight, 1., 8.5);\n\n  p.x = p.x - offset.x;\n  p.y = p.y - offset.y;\n  p.z = p.z - offset.z;\n\n  p *= scale;\n\n  float x = p.x;\n  float y = p.y;\n  float z = p.z;\n\n  return (x * x + y * y + z * z) * (x * x + y * y + z * z) - 2.0 * (x * x + y * y + z * z) + n * (y * y + z * z);\n}\n\nvec2 scene(in vec3 position) {\n  vec2 scene = opUnion(vec2(sdPlane(position), 1.0), vec2(sdWTF(position, 4.0, vec3(0., 0.4, 0.)), 12.0));\n  return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n  float hit = 1.0;\n  float t = 0.02;\n\n  for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    float h = scene(origin + direction * t).x;\n    if(h < PRECISION)\n      return 0.0;\n    t += h;\n    hit = min(hit, 10.0 * h / t);\n    if(t >= 2.5)\n      break;\n  }\n\n  return clamp(hit, 0.0, 1.0);\n}\n\nvec2 rayMarch(in vec3 origin, in vec3 direction) {\n  float material = -1.0;\n\n  float t = 0.02;\n\n  for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec2 hit = scene(origin + direction * t);\n    if(hit.x < 0.002 || t > 20.0)\n      break;\n    t += hit.x;\n    material = hit.y;\n  }\n\n  if(t > 20.0) {\n    material = -1.0;\n  }\n\n  return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n  vec3 epsilon = vec3(PRECISION, 0.0, 0.0);\n  vec3 n = vec3(scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x, scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x, scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n  return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n  float x2 = x * x;\n  return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n  float oneMinusNoHSquared = 1.0 - NoH * NoH;\n  float a = NoH * linearRoughness;\n  float k = linearRoughness / (oneMinusNoHSquared + a * a);\n  float d = k * k * (1.0 / PI);\n  return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n  float a2 = linearRoughness * linearRoughness;\n  float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n  float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n  return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n  return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n  return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n  float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n  float lightScatter = F_Schlick(1.0, f90, NoL);\n  float viewScatter = F_Schlick(1.0, f90, NoV);\n  return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n  return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n  return max(vec3(0.754554516862612, 0.748542953903366, 0.790921515418539) + vec3(-0.083856548007422, 0.092533500963210, 0.322764661032516) * (n.y) + vec3(0.308152705331738, 0.366796330467391, 0.466698181299906) * (n.z) + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x), 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.040, -0.040);\n\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n  return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n  return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n  vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n  vec2 hit = rayMarch(origin, direction);\n  distance = hit.x;\n  float material = hit.y;\n\n    // We've hit something in the scene\n  if(material > 0.0) {\n    vec3 position = origin + distance * direction;\n\n    vec3 v = normalize(-direction);\n    vec3 n = normal(position);\n    vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n    vec3 h = normalize(v + l);\n    vec3 r = normalize(reflect(direction, n));\n\n    float NoV = abs(dot(n, v)) + 1e-5;\n    float NoL = saturate(dot(n, l));\n    float NoH = saturate(dot(n, h));\n    float LoH = saturate(dot(l, h));\n\n    vec3 baseColor = vec3(0.0);\n    float roughness = 0.0;\n    float metallic = 0.0;\n\n    float intensity = 2.0;\n    float indirectIntensity = 0.64;\n\n    if(material < 4.0) {\n            // Checkerboard floor\n      float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n      baseColor = 0.4 + f * vec3(0.6);\n      roughness = 0.1;\n    } else if(material < 16.0) {\n            // Metallic objects\n      baseColor = vec3(0.8 * sin(iTime * 0.8), 0.0, 0.8 * cos(iTime * 0.8));\n      roughness = 0.2;\n    }\n\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n    float attenuation = shadow(position, l);\n\n        // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, h);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3 F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n    color = Fd + Fr;\n    color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n    vec2 indirectHit = rayMarch(position, r);\n    vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n    if(indirectHit.y > 0.0) {\n      if(indirectHit.y < 4.0) {\n        vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n        float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n        indirectSpecular = 0.4 + f * vec3(0.6);\n      } else if(indirectHit.y < 16.0) {\n                // Metallic objects\n        indirectSpecular = vec3(0.8 * cos(iTime * 0.8), 0.0, 0.8 * sin(iTime * 0.8));\n      }\n    }\n\n        // indirect contribution\n    vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n    vec3 specularColor = f0 * dfg.x + dfg.y;\n    vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n    color += ibl * indirectIntensity;\n  }\n\n  return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n  vec3 forward = normalize(target - origin);\n  vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n  vec3 left = normalize(cross(forward, orientation));\n  vec3 up = normalize(cross(left, forward));\n  return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n  p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n  vec3 origin = vec3(0.0, .3, .0);\n  vec3 target = vec3(0.0);\n\n  origin.x += 1.7 * cos(iTime * 0.2);\n  origin.z += 1.7 * sin(iTime * 0.2);\n\n  mat3 toWorld = setCamera(origin, target, .0);\n  vec3 direction = toWorld * normalize(vec3(p.xy, 2.));\n\n    // Render scene\n  float distance;\n  vec3 color = render(origin, direction, distance);\n\n    // Tone mapping\n  color = Tonemap_ACES(color);\n\n    // Exponential distance fog\n  color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n  color = OECF_sRGBFast(color);\n\n  fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}