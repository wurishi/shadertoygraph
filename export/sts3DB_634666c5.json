{"ver":"0.1","info":{"id":"sts3DB","date":"1622799185","viewed":128,"name":"Cat Android Factory","username":"shyuriken","description":"modeled by SDF Editor","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingsdfglsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from original shader: https://www.shadertoy.com/view/ldcyW4\n// modeled by https://joetech.itch.io/sdf-editor\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 2,150 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nmat3 rotateMat(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle),\n\t      c = cos(angle),\n\t      r = 1. - c;\n\treturn mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s, a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s, a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n}\n\n#define LIGHT\tnormalize(vec3(1, 1, 0))\n\nfloat pSphere(float r, vec3 p) { return length(p) - r; }\n\nfloat pTriPrism(float h, float r, vec3 p) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h, max(q.x * .866025 + p.y * .5, -p.y) - r * .5);\n}\n\nfloat pCapsule(float r, float h, vec3 p) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat pRoundCone(float r1, float r2, float h, vec3 p) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat b = (r1 - r2) / h,\n\t      a = sqrt(1. - b * b),\n\t      k = dot(q, vec2(-b, a));\n\tif (k < 0.) return length(q) - r1;\n\tif (k > a * h) return length(q - vec2(0, h)) - r2;\n\treturn dot(q, vec2(a, b)) - r1;\n}\n\nfloat pEllipsoid(vec3 r, vec3 p) {\n\tfloat k0 = length(p / r);\n\treturn k0 * (k0 - 1.) / length(p / (r * r));\n}\n\nvec3 mTranslation(vec3 inv_translation, vec3 p) { return p + inv_translation; }\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nvec3 mMirror(vec3 normal, float dist, vec3 p) { return p - 2. * max(0., dot(normal, p) - dist) * normal; }\n\nvec3 mRepInf(vec3 cell_size, vec3 p) { return p - cell_size * round(p * vec3(greaterThan(cell_size, vec3(0))) / cell_size); }\n\nfloat oUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat oSubtraction(float d1, float d2) { return max(d1, -d2); }\n\nfloat sdf(vec3 p0) {\n\tfloat d1, d2, d3, d4, d5, d6, d7;\n\t{ }\n\t{\n\t\tvec3 p1 = mRepInf(vec3(3, -1, 3), p0);\n\t\t{\n\t\t\tmat3 mt = rotateMat(p1, iTime, vec3(0, 1, 0));\n\t\t\tvec3 p2 = mRotation(mt, p1);\n\t\t\t{ d1 = pEllipsoid(vec3(1.2, .05, .1), mTranslation(vec3(0, -.74, 0), p2)); }\n\t\t}\n\t\t{ d2 = pCapsule(.07, 1., mTranslation(vec3(0, .2, 0), p1)); }\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(1, 0, 0), .06, p1);\n\t\t\t{ d3 = pSphere(.15, mTranslation(vec3(.17, .1, -.52), p2)); }\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(1, 0, 0), .06, p1);\n\t\t\t{ d4 = pSphere(.2, mTranslation(vec3(.17, .1, -.52), p2)); }\n\t\t}\n\t\t{ d5 = pRoundCone(1.2, .5, 1., mTranslation(vec3(0, 3, 0), p1)); }\n\t\t{\n\t\t\tvec3 p2 = mMirror(vec3(1, 0, 0), 0., p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(.5, .09, 0), p2);\n\t\t\t\t{ d6 = pTriPrism(.02, .41, mRotation(mat3(.925417, -.163176, .34202, .044233, .942887, .330162, -.376361, -.290409, .879781), p3)); }\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tvec3 p2 = mTranslation(vec3(0, .84, 0), p1);\n\t\t\t{ d7 = pRoundCone(1., .5, 1., mRotation(mat3(1, -0, 0, 0, -1, -0, 0, 0, -1), p2)); }\n\t\t}\n\t}\n\treturn oUnion(d6, oUnion(d5, oUnion(oSubtraction(d7, d4), oUnion(d3, oUnion(d2, d1)))));\n}\n\nvec3 RayMarch(vec3 rayDir, vec3 cameraOrigin) {\n\tfloat dist = .01,\n\t      totalDist = 0.,\n\t      itter = 0.;\n\tvec3 pos = cameraOrigin;\n\tfor (int i = 0; i < 128; i++) {\n\t\tdist = sdf(pos);\n\t\titter++;\n\t\ttotalDist += dist;\n\t\tpos += dist * rayDir;\n\t\tif (dist < .01 || totalDist > 130.) break;\n\t}\n\n\treturn vec3(dist, totalDist, itter / 128.);\n}\n\nfloat AO(vec3 pos, vec3 n) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 3; i++) {\n\t\taopos = pos + n * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro),\n\t     cu = normalize(cross(cw, vec3(sin(cr), cos(cr), 0)));\n\treturn mat3(cu, normalize(cross(cu, cw)), cw);\n}\n\nvec4 NorCurv(vec3 p) {\n\tconst vec2 e = vec2(-.01, .01);\n\tfloat t1 = sdf(p + e.yxx),\n\t      t2 = sdf(p + e.xxy),\n\t      t3 = sdf(p + e.xyx),\n\t      t4 = sdf(p + e.yyy);\n\treturn vec4(normalize(e.yxx * t1 + e.xxy * t2 + e.xyx * t3 + e.yyy * t4), .25 / e.y * (t1 + t2 + t3 + t4 - 4. * sdf(p)));\n}\n\nvec3 Lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos) { return vec3(max(0., dot(LIGHT, n)), pow(max(0., dot(reflectDir, LIGHT)), 10.), 1. - max(0., dot(-n, rayDir))) * .5; }\n\nfloat TriplanarTexture(vec3 pos, vec3 n) { return 0.; }\n\nfloat BackGround(vec3 rayDir) { return smoothstep(1., 0., clamp(length(rayDir - LIGHT), 0., 1.)) * .5; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 cameraOrigin = vec3(0);\n\tif (iMouse.z > 0.) {\n\t\tcameraOrigin.x = sin(iMouse.x * .01) * 5.;\n\t\tcameraOrigin.y = iMouse.y * .05 - 10.;\n\t\tcameraOrigin.z = cos(iMouse.x * .01) * 5. + 15.;\n\t}\n\telse {\n\t\tcameraOrigin.x = sin(iTime * .25 + 2.) * (6. + sin(iTime * .1));\n\t\tcameraOrigin.y = sin(iTime * .3) + 3.;\n\t\tcameraOrigin.z = cos(iTime * .25 + 2.) * (6. + sin(iTime * .15));\n\t}\n\n\tvec2 screenPos = uv * 2. - 1.;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tmat3 cam = SetCamera(cameraOrigin, vec3(0, .25, -1), sin(iTime * .15) * .5);\n\tvec3 rayDir = cam * normalize(vec3(screenPos, 2)),\n\t     dist = RayMarch(rayDir, cameraOrigin);\n\tfloat res,\n\t      backGround = BackGround(rayDir);\n\tif (dist.x < .01) {\n\t\tvec3 l,\n\t\t     pos = cameraOrigin + dist.y * rayDir;\n\t\tvec4 n = NorCurv(pos);\n\t\tfloat col,\n\t\t      ao = AO(pos, n.xyz);\n\t\tl = Lighting(n.xyz, rayDir, reflect(rayDir, n.xyz), pos);\n\t\tcol = TriplanarTexture(pos, n.xyz);\n\t\tcol *= n.w * .5 + .5;\n\t\tcol *= ao;\n\t\tcol += ao * (l.x + l.y);\n\t\tcol += l.z * .75;\n\t\tcol += BackGround(n.xyz) * .25;\n\t\tres = col;\n\t}\n\telse res = backGround;\n\n\tfragColor = vec4(vec3(res), 1);\n}","name":"Image","description":"","type":"image"}]}