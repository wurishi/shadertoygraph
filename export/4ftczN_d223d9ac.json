{"ver":"0.1","info":{"id":"4ftczN","date":"1730558916","viewed":115,"name":"metallique","username":"pb","description":"tunnelling through","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","glints"],"hasliked":0,"parentid":"7tdcDS","parentname":"Sea Shells"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = u/R;\n\n    O *= 0.;\n\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    //golfed by fabriceneyret2\n    for (int k; k < 25; k++)      \n        O += gk1s[k] * texture(iChannel0, uv + ( vec2(k%5,k/5) - 2. ) / R );\n        \n    O += (1.-exp(-1e3*O*O*O*O));\n    O += 10.*fwidth(O)*vec4(1,1,.3,0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n\nvec3  ro, ifs_color, light_direction;\nfloat max_iter, normal_mult, norm_dist_expand, sc, glow=0.;\nfloat params[9] = float[9] (0.22,-.08,-.01,1.96,0., 1.15,1.,.2,3.);\n\nmat3 rot_xz_yz(float a1, float a2) {\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n    return mat3(    c1, 0.,    -s1,\n                -s2*s1, c2, -s2*c1,\n                 c2*s1, s2,  c2*c1 );\n}\n\nfloat mbox (vec3 p)\n{\n    ifs_color = vec3(0.);\n    vec4 offset=vec4(p,1.), v=offset;\n  \n    float n=0.;\n    for (; n<40.;n++) {\n\n        v.xyz = clamp (v.xyz, -1.-params[0], 1.+params[0]) * (2.+params[1]) \n                - (1.+params[2])*v.xyz;\n\n        v = v * params[3] / clamp (dot (v.xyz, v.xyz), (.2+params[4])-params[5], 1.+params[5]) + offset;\n   \n        if (v.x*v.y > 0. ) ifs_color.x ++;\n        if (v.y*v.z > 0. ) ifs_color.y ++;\n        if (v.z*v.x > 0. ) ifs_color.z ++;  \n    }\n\n    ifs_color /= n;\n    \n    sc = v.w;\n  \n    return length (v.xyz) / v.w ;\n}\n\nfloat all_objects(vec3 p) {\n    return max( mbox(p), -(length(p-ro)-.002 ) );\n}\n\nvec3 gradient(vec3 p) {\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = (.00001 + norm_dist_expand) * dpn; \n    vec3 df = dpn.xxx * all_objects(p+dp.xxx) +\n              dpn.yyx * all_objects(p+dp.yyx) +\n              dpn.xyy * all_objects(p+dp.xyy) +\n              dpn.yxy * all_objects(p+dp.yxy);\n    return normalize(df); \n}\n\n\nvec3 color(vec3 p, vec3 rd, float dist, float totdist) {\n\n    float t2 = totdist/1e2;\n    \n    norm_dist_expand = totdist/400.;\n\n    vec3 nv = gradient(p);\n\n    vec3 color  =  vec3(.2,.1,0)*cos(ifs_color.x*params[6]-.5)\n                 + vec3(0,.2,.2)*cos(ifs_color.y*params[7]+2.5)\n                 + vec3(.1,0,.2)*cos(ifs_color.z*params[8]+3.);\n                        \n    color = 1. - exp(-color*color);\n\n    color = exp(-t2*2e3)*color * max (0., dot (nv, -light_direction))  \n         +  exp(-t2*3e4)\n            *pow ( max (0., dot (-light_direction, reflect (rd, nv))), 16. );\n\n    return color;\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n\n    float tt = mod(iTime+30.,100.);\n    \n    xy = (2.*xy - iResolution.xy)/iResolution.y;\n    \n    ro = vec3(.001,0.006,-.019);\n    \n    mat3 rot = rot_xz_yz(1.24-tt/1500.,-.56);\n  \n    vec3 rd = rot * normalize(vec3(xy,-2.));\n    \n    tt > 70. ? rd *= rot_xz_yz(1.5,-.3) : rd;\n    \n    ro -= rot[2] * (tt+100.)/1700.;\n      \n\n    light_direction = normalize(-rot[2]*rot_xz_yz(sin(iTime),cos(iTime)) ); \n    \n    vec3  p=ro;\n    float dist,totdist;\n    float eps = 3e-5, hit_threshold=eps;\n\n    float distfac = 100.;\n    vec3  rgb = vec3(0.);\n    \n    for (float f=0.; f<200.; f++) {\n    \n        dist = all_objects(p);\n        \n        if ( \n        dist < hit_threshold || totdist > 2.) { rgb = color(p, rd, dist, totdist); break; }\n        \n        float stepsize = dist;\n        p += rd*stepsize;\n\n        totdist += stepsize;\n        \n        hit_threshold = eps*(1.+totdist*distfac);\n    \n    }\n    \n    rgba = vec4( rgb, totdist);\n}","name":"Buffer A","description":"","type":"buffer"}]}