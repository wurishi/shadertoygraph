{"ver":"0.1","info":{"id":"4dBcD1","date":"1491855075","viewed":884,"name":"tonemap test","username":"Jodie","description":"based on https://www.shadertoy.com/view/lslGzl\nrobo tonemap from https://www.shadertoy.com/user/robobo1221","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["test","tonemap","robin","robobo","jodie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 linearToSrgb(const vec3 x){\n    return sqrt((-2.8450663e-1*x+1.2580714)*x-2.4727747e-3);\n}\n \nvec3 getBaseColor(int i)\n{\n    if (i == 0) return vec3(1.0, 0.4, 0.2);\n    if (i == 1) return vec3(0.4, 1.0, 0.2);\n    if (i == 2) return vec3(0.2, 1.0, 0.4);\n    if (i == 3) return vec3(0.2, 0.4, 1.0);\n    if (i == 4) return vec3(0.4, 0.2, 1.0);\n    if (i == 5) return vec3(1.0, 0.2, 0.4);\n \n    return vec3(1.);\n}\n \nvec3 getBaseColor()\n{\n    float colorPerSecond = 0.5;\n    int i = int(mod(colorPerSecond * iTime, 7.));\n    int j = int(mod(float(i) + 1., 7.));\n \n    return mix(getBaseColor(i), getBaseColor(j), fract(colorPerSecond * iTime));\n}\n\nvec3 reinhardRobo(vec3 x,float y){\n    return x/pow(1.+pow(x,vec3(y) ),vec3(1./y) );\n}\nfloat reinhardRobo(float x,float y){\n    return x/pow(1.+pow(x,y ),1./y );\n}\nvec3 roboTonemap(vec3 c){\n    return c/sqrt(1.+c*c);\n}\n\nvec3 jodieRoboTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc=c/sqrt(c*c+1.);\n    return mix(c/sqrt(l*l+1.),tc,tc);\n}\nvec3 reinhardTonemap(vec3 c){\n    return c/(c+1.);\n}\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc=c/(c+1.);\n    return mix(c/(l+1.),tc,tc);\n}\nvec3 jodieReinhard2ElectricBoogaloo(const vec3 color){\n    float luma = dot(color, vec3(.2126, .7152, .0722));\n\n    // tonemap curve goes on this line\n    // (I used reinhard here)\n    vec4 rgbl = vec4(color, luma) / (luma + 1.);\n    \n    vec3 mappedColor = rgbl.rgb;\n    float mappedLuma = rgbl.a;\n    \n    float channelMax = max(max(max(\n    \tmappedColor.r,\n    \tmappedColor.g),\n    \tmappedColor.b),\n    \t1.);\n    \n    // this is just the simplified/optimised math\n    // of the more human readable version below\n    return (\n        (mappedLuma*mappedColor-mappedColor)-\n        (channelMax*mappedLuma-mappedLuma)\n    )/(mappedLuma-channelMax);\n    \n    const vec3 white = vec3(1);\n    \n    // prevent clipping\n    vec3 clampedColor = mappedColor/channelMax;\n    \n    // x is how much white needs to be mixed with\n    // clampedColor so that its luma equals the\n    // mapped luma\n    //\n    // mix(mappedLuma/channelMax,1.,x) = mappedLuma;\n    // \n    // mix is defined as\n    // x*(1-a)+y*a\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml\n    // \n    // (mappedLuma/channelMax)*(1.-x)+1.*x = mappedLuma\n\n    float x = (mappedLuma - mappedLuma*channelMax)\n        /(mappedLuma - channelMax);\n    return mix(clampedColor, white, x);\n}\nvec3 jodieRobo2ElectricBoogaloo(const vec3 color){\n    float luma = dot(color, vec3(.2126, .7152, .0722));\n\n    // tonemap curve goes on this line\n    // (I used robo here)\n    vec4 rgbl = vec4(color, luma) * inversesqrt(luma*luma + 1.);\n    \n    vec3 mappedColor = rgbl.rgb;\n    float mappedLuma = rgbl.a;\n    \n    float channelMax = max(max(max(\n    \tmappedColor.r,\n    \tmappedColor.g),\n    \tmappedColor.b),\n    \t1.);\n    \n    // this is just the simplified/optimised math\n    // of the more human readable version below\n    return (\n        (mappedLuma*mappedColor-mappedColor)-\n        (channelMax*mappedLuma-mappedLuma)\n    )/(mappedLuma-channelMax);\n    \n    const vec3 white = vec3(1);\n    \n    // prevent clipping\n    vec3 clampedColor = mappedColor/channelMax;\n    \n    // x is how much white needs to be mixed with\n    // clampedColor so that its luma equals the\n    // mapped luma\n    //\n    // mix(mappedLuma/channelMax,1.,x) = mappedLuma;\n    // \n    // mix is defined as\n    // x*(1-a)+y*a\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml\n    // \n    // (mappedLuma/channelMax)*(1.-x)+1.*x = mappedLuma\n\n    float x = (mappedLuma - mappedLuma*channelMax)\n        /(mappedLuma - channelMax);\n    return mix(clampedColor, white, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = getBaseColor();\n    //vec3 color = vec3(.1,1,.2);\n \n    float n = 6.;\n    if (uv.x > 0.2)\n    {\n        color *= (uv.x-0.2)*10.;\n\n        int i = int(n * (1. - uv.y));\n        if (i == 0) color = roboTonemap(color);\n        if (i == 1) color = jodieRoboTonemap(color);\n        if (i == 2) color = jodieRobo2ElectricBoogaloo(color);\n        if (i == 3) color = reinhardTonemap(color);\n        if (i == 4) color = jodieReinhardTonemap(color);\n        if (i == 5) color = jodieReinhard2ElectricBoogaloo(color);\n        \n    }\n    \n \n    if (abs(fract(n * uv.y + 0.5) - 0.5) < 0.02)\n        color = vec3(0.);\n    \n    color = linearToSrgb(color);\n    \n \n    fragColor = vec4(color, 1.);\n    //fragColor = vec4((color-1.)*1000., 1.);\n}","name":"Image","description":"","type":"image"}]}