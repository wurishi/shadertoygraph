{"ver":"0.1","info":{"id":"ctXXWr","date":"1674794666","viewed":142,"name":"Recursive Refraction","username":"foodini","description":"Lots still to do. Need gamma correct. The bad rand is killing antialiasing, soft shadows, and depth-of-field. Now that I have the base down, I want to generalize objects so they can be more complex. Lighting depends upon ground plane's orientation, etc.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TODO: Use a list of \"random\" numbers for rand and just iterate through them.\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    float ior;\n};\n\nstruct Light {\n    vec3 color;\n    vec3 pos;\n    float size;\n};\n\nconst int num_spheres = 4;\nSphere spheres[num_spheres];\nconst int num_lights = 3;\nLight lights[num_lights];\n\nconst float PI = 3.1415926538;\nfloat rand_seed = PI;\n// THIS SUCKS and is making antialiasing terrible.\nfloat rand(vec2 co){\n    //return abs(fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453)) * 2.0 -1.0;\n    rand_seed += dot(co, vec2(12.9898, 78.233)) + fract(iTime);\n    rand_seed *= 58.5453;\n    rand_seed = abs(fract(rand_seed))*2.0 - 1.0;\n    return rand_seed;\n}\n\nfloat sphere_dist(in vec3 c, in float r, in vec3 ray_start, in vec3 ray_dir) {\n    vec3 OC = c - ray_start;\n    float len_OC_squared = dot(OC, OC);\n    float r_squared = r*r;\n    float Tca_squared;\n    float Thc_squared;\n    \n    // Is the ray origin outside the sphere?\n    if(len_OC_squared >= r_squared) {\n        float Tca = dot(OC, ray_dir);\n        // Does the ray point away from the sphere?\n        if(Tca < 0.0) {\n            return -1.0;\n        } else {\n            Tca_squared = Tca * Tca;\n            Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        }\n        // Does the ray miss the sphere?\n        if(Thc_squared < 0.0)\n            return -1.0;\n        return Tca - sqrt(Thc_squared);\n    }\n}\n\n// NORMAL (n) MUST BE NORMALIZED!!! \nbool plane_dist(in vec3 n, float D, in vec3 o, in vec3 d, out float t) {\n    float Vprd = dot(n, d);\n    float Vpro = -(dot(n, o) + D);\n    t = Vpro / Vprd;\n    if(t>0.0)\n        return true;\n    return false;\n}\n\nvec3 grid(in vec3 p) {\n    float xcol = cos(p.x*3.1415925);\n    xcol *= xcol;\n    float zcol = cos(p.z*3.1415925);\n    zcol *= zcol;\n    return (xcol > 0.995 || zcol > 0.995) ? vec3(1.0) : vec3(0.0);\n}\n\nvec3 mand(in vec3 p) {\n    //return grid(p);\n\n    //mandel (&intersect, raycolor, .003, 0.14707684544406, 0.651762543252595, \"blues.map\");\n    //void mandel (Point3 *p, col color, double scale, double ztrans, double xtrans, char *filename)\n    vec2 c = vec2(p.x, p.z) * 0.003;// * (0.0005 + pow(sin(iTime/15.0), 2.0));\n    c += vec2(0.1382309, 0.643002);\n    vec2 z = c;\n    vec2 zn;\n    \n    for(float i=0.; i<500.; i++) {\n        if(dot(zn,zn) >= 4.0) {\n            float d = i + 1. - log(log(length(zn)))/log(2.);\n            return vec3(\n                (1.0+sin((iTime*5. + d)/17.))/2.0,\n                (1.0+cos((iTime*7. + d)/13.))/2.0,\n                (1.0+sin((iTime*11. + d)/11.))/2.0\n                );\n        } else {\n            zn = mat2(zn,-zn.y,zn.x) * zn + c;\n    \t\tz = zn;\n        }\n    }\n    return vec3(0.0);\n}\n\n// Returns 0.0 if shadowed. Otherwise, returns the y component of the to_light vector.\n// This is useful because to_light is normalized and y=1.0 is the normal of the plane. This means\n// that the y component is effectively the cosine of the angle between the normal and the light\n// direction and tells us the diffuse component of the lighting on the point.\nfloat shadow_test(vec3 light_pos, vec3 intersect_point, float size) {\n    float dx = size * rand(intersect_point.xz);\n    float dy = size * rand(vec2(iTime, intersect_point.z));\n    float dz = size * rand(vec2(intersect_point.x, iTime));\n    vec3 to_light = normalize(vec3(dx, dy, dz) + light_pos - intersect_point);\n    \n    float intersect_dist = \n        sphere_dist(spheres[0].c, spheres[0].r, intersect_point, to_light);\n    \n    if(intersect_dist > 0.0)\n        return 0.0;\n    else\n        return to_light.y;\n}\n\nvec3 lighting(vec3 intersect_point) {\n    vec3 retval = vec3(0.0);\n    for(int l=0; l<num_lights; l++) {\n        float lighting_intensity = \n            shadow_test(lights[l].pos, intersect_point, lights[l].size);\n        if(lighting_intensity > 0.0) {\n            retval += lighting_intensity * mand(intersect_point) * lights[l].color;\n        }\n    }\n    return retval/float(num_lights);\n}\n\nvec3 vis_light(vec3 ray_start, vec3 ray_dir) {\n    vec3 retval = vec3(0.0);\n    for(int l=0; l<num_lights; l++) {\n        vec3 to_light = normalize(lights[l].pos - ray_start);\n        float cos_between_ray_and_to_light = dot(to_light, ray_dir);\n        if(cos_between_ray_and_to_light > 0.0) {\n            retval += 3.0 * lights[l].color * pow(cos_between_ray_and_to_light, 80.0/lights[l].size);\n        }\n    }\n    return retval/float(num_lights);\n}\n\n// incident_dir MUST BE NORMALIZED\nvoid refraction(in vec3 incident_loc, in vec3 incident_dir, \n        in vec3 normal, in float ior, \n        out vec3 new_vec_origin, out vec3 new_vec_dir, out bool traversed) {\n    float c1 = -dot(incident_dir, normal);\n    float c2 = ior*ior - 1.0 + c1*c1;\n    \n    if(c2 <= 0.0) {\n        //Reflection. Don't switch sides of the object.\n        traversed = false;\n        new_vec_origin = incident_loc - (0.001 * incident_dir);\n        new_vec_dir = reflect(incident_dir, normal);\n    } else {\n        float B = c1 - sqrt(c2);\n        new_vec_dir = B * normal + incident_dir;\n        new_vec_dir /= ior;\n    }   \n}\n\nint stack[10];\nint top_of_stack = -1;\n\nvoid push(int sphere_id) {\n    top_of_stack++;\n    stack[top_of_stack] = sphere_id;\n}\n\nint stack_height() {\n    return top_of_stack + 1;\n}\n\n// Bad things will happen if there's nothing on the stack....\nint peek_id() {\n    return stack[top_of_stack];\n}\n\n// Bad things will happen if there's nothing on the stack....\nfloat peek_ior() {\n    return spheres[stack[top_of_stack]].ior;\n}\n\nfloat peek_ior_exiting() {\n    if(top_of_stack > 0)\n        return spheres[stack[top_of_stack-1]].ior / spheres[stack[top_of_stack]].ior;\n    else\n        return 1.0/spheres[stack[top_of_stack]].ior;\n}\n\nvoid pop() {\n    top_of_stack--;\n}\n\nvec3 bump_out(vec3 p, int sphere_id) {\n    vec3 dir = normalize(p - spheres[sphere_id].c);\n    return p + 0.0001 * dir;\n}\n\nvec3 bump_in(vec3 p, int sphere_id) {\n    vec3 dir = normalize(p - spheres[sphere_id].c);\n    return p - 0.0001 * dir;\n}\n\n// Since a glsl shader can't actually recurse, I've written the trace function to be tail recursive,\n// then just set it in a loop. The bubbles inside the sphere MUST NOT collide with each other, since\n// the system can only know what sphere it is inside (which is necessary to know the index of refraction\n// as it exits one sphere and enters another) by keeping track of a stack of spheres. As spheres are\n// entered, they are pushed onto the stack. When a raycast hits a sphere and it is a different sphere\n// than the top of the stack, we know we're entering a new sphere. When the ids match, we know we're\n// exiting the sphere at the top of the stack.\nvec3 trace(in vec3 ray_start, in vec3 ray_dir) {\n    int depth = 0;\n    \n    float sphere_intersect_dist, plane_intersect_dist, nearest_sphere_intersect_dist;\n    int sphere_intersect_id;\n    vec3 new_vec_origin;\n    vec3 new_vec_dir;\n    bool sphere_nearest, traversed;\n    bool sphere_intersect, plane_intersect;\n    while(depth < 10) {\n        sphere_intersect_id = -1;\n        for(int id=0; id<num_spheres; id++) {\n            sphere_intersect_dist = sphere_dist(spheres[id].c, spheres[id].r, ray_start, ray_dir);\n            sphere_intersect = sphere_intersect_dist > 0.0;\n            if(sphere_intersect) {\n                if(sphere_intersect_id == -1 || sphere_intersect_dist < nearest_sphere_intersect_dist) {\n                    sphere_intersect_id = id;\n                    nearest_sphere_intersect_dist = sphere_intersect_dist;\n                }\n            }\n        }\n        \n        //sphere_intersect_id = -1;\n        if(stack_height() == 0)\n            plane_intersect = \n                plane_dist(vec3(0.0, -1.0, 0.0), -1.0, ray_start, ray_dir, plane_intersect_dist);\n\n        sphere_nearest = false;\n        if(plane_intersect) {\n            if(sphere_intersect_id != -1 && nearest_sphere_intersect_dist < plane_intersect_dist) {\n                sphere_nearest = true;\n            } else {\n                // The plane's the nearest hit.\n                return\n                    lighting(ray_start + ray_dir * plane_intersect_dist) +\n                    vis_light(ray_start, ray_dir);\n            }\n        } else if(sphere_intersect_id != -1) {\n            sphere_nearest = true;\n        }\n        \n        if(!sphere_nearest) {\n            // We missed everything\n            float b = 1.0-ray_dir.y;\n            float rg = b*b*b*b*b*b;\n            return vis_light(ray_start, ray_dir);\n            return vec3(rg, rg, b);\n            \n        } else {\n            // Refraction time.\n            float ior;\n            bool push_on_traverse = true;\n            if(stack_height() == 0) {\n                ior = spheres[sphere_intersect_id].ior;\n            } else if(peek_id() == sphere_intersect_id) {\n                //we're hitting the inside of the sphere\n                ior = peek_ior_exiting();\n                push_on_traverse = false;\n            } else {\n                ior = spheres[sphere_intersect_id].ior/peek_ior();\n            }\n            vec3 intersect_point = ray_start + ray_dir * nearest_sphere_intersect_dist;\n            vec3 surface_normal = normalize(intersect_point - spheres[sphere_intersect_id].c);\n            refraction(\n                intersect_point, ray_dir,\n                surface_normal,\n                ior,\n                new_vec_origin, new_vec_dir, traversed);\n            if(traversed) {\n                // HOW IS THIS NEVER GETTING HIT?????\n                return vec3(0.5);\n                if(push_on_traverse) {\n                    push(sphere_intersect_id);\n                    ray_start = bump_in(new_vec_origin, sphere_intersect_id);\n                } else {\n                    pop();\n                    ray_start = bump_out(new_vec_origin, sphere_intersect_id);\n                }\n                ray_dir = new_vec_dir;\n            } else {\n                if(push_on_traverse)\n                    ray_start = bump_in(intersect_point, sphere_intersect_id);\n                else\n                    ray_start = bump_out(intersect_point, sphere_intersect_id);\n                //ray_dir = reflect(ray_dir, surface_normal);\n                ray_dir = new_vec_dir;\n            }\n        }\n        depth++;\n    }\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0].c = vec3(0.0);\n    spheres[0].r = 1.0;\n    spheres[0].ior = 0.9;\n    //float bounce_time = mod(iTime, 2.0);\n    //float y = (10.0*bounce_time - 0.5 * 10.0 * bounce_time*bounce_time) / 4.0;\n    //spheres[0].c.y = y;\n    spheres[1].c = spheres[0].c;\n    spheres[1].c.z +=  + 0.5*sin(iTime);\n    spheres[1].r = 0.2;\n    spheres[1].ior = 1.2;\n    spheres[2].c = spheres[0].c;\n    spheres[2].c.x +=  + 0.5*sin(iTime+2.0*PI/3.0);\n    spheres[2].r = 0.2;\n    spheres[2].ior = 1.2;\n    spheres[3].c = spheres[0].c;\n    spheres[3].c.y +=  + 0.5*sin(iTime+PI/3.0);\n    spheres[3].r = 0.2;\n    spheres[3].ior = 1.2;\n    \n    lights[0].pos = vec3(6.0, 5.0, 5.0);\n    lights[0].color = vec3(1.0, 0.0, 0.0);\n    lights[0].size = 0.2;\n    lights[1].pos = vec3(12.0, 5.0, -6.0);\n    lights[1].color = vec3(0.0, 1.0, 0.0);\n    lights[1].size = 0.2;\n    lights[2].pos = vec3(-12.0, 5, 0.0);\n    lights[2].color = vec3(0.0, 0.0, 1.0);\n    lights[2].size = 0.1;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screen_space = uv * 2.0 - 1.0;\n    screen_space.x *= (iResolution.x/iResolution.y);\n\n    float cos2 = cos(iTime/4.0);\n    vec3 cam_position = vec3(10.0 * sin(iTime/4.0), 0.8, 10.0 * cos(iTime/4.0));\n    \n    float dist_to_pix_plane = 3.0;\n    vec3 cam_look_at = vec3(3.0*sin((iTime-PI/2.0)/4.0), 0.7, 3.0*cos((iTime-PI/2.0)/4.0));\n    vec3 cam_look_dir = dist_to_pix_plane * normalize(cam_look_at - cam_position);\n    \n    vec3 right = cross(vec3(0.0, 1.0, 0.0), cam_look_dir);\n    right = normalize(right);\n    vec3 up = cross(cam_look_dir, right);\n    up = normalize(up);\n    \n    vec3 pixel_width = right/iResolution.x;\n    vec3 pixel_height = up/iResolution.y;\n    \n    float antialias_level = 4.0;\n    float depth_of_field_intensity = 0.0;\n    vec3 out_color = vec3(0.0);\n    vec3 ray_start, ray_dir;\n    for(float aa=0.0; aa<antialias_level; aa+=1.0) {\n        vec3 ray_screen_isect_point = cam_position + cam_look_dir + \n            (screen_space.x * right) + (screen_space.y * up);\n        \n        if(antialias_level > 1.0) {\n            ray_screen_isect_point += pixel_width * rand(uv*(aa+1.0));\n            ray_screen_isect_point += pixel_height * rand(uv*(aa+1.5));\n        }\n\n        ray_start = cam_position;\n        if(depth_of_field_intensity > 0.0) {\n            ray_start += depth_of_field_intensity * pixel_width * rand(uv*(aa+1.0));\n            ray_start += depth_of_field_intensity * pixel_height * rand(uv*(aa+1.5));                 \n        }\n\n        ray_dir = normalize(ray_screen_isect_point - ray_start);\n\n        out_color += trace(ray_start, ray_dir);\n    }\n    out_color /= float(antialias_level);\n\n    fragColor = vec4(\n        pow(out_color.x, 0.4),\n        pow(out_color.y, 0.4),\n        pow(out_color.z, 0.4),\n        1.0);\n    \n}","name":"Image","description":"","type":"image"}]}