{"ver":"0.1","info":{"id":"MtcyDn","date":"1532188371","viewed":187,"name":"Cone capsule","username":"TLC123","description":"three bones of cone capsules special \"synaptic\" blend mode and normaldriven bump texture.\nLooping thou combinations of three blend parameters and two bump noise parameters  (roughness and depth).\nUseful for bone and exoskeleton modelling","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["capsule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"   \n#ifdef GLSLVIEWER\nuniform vec3 u_eye3d;\nuniform vec3 u_centre3d;\nuniform vec3 u_up3d;\n#endif\n\n\nfloat   arandom (float aseed) {return mod( mod(aseed*43758.5453123, 1.9)+aseed* 78.233 ,1.0);}\n\nfloat value_at (float x,float y,float z) {return arandom(arandom(arandom(x)+y)+z);}\n\n\nfloat noise3d(vec3 p) {\n    \n    // single octave xyz noise\n\t  float  px= floor (p.x); \t   float    py= floor (p.y); \t   float    pz= floor (p.z);\n  \t\tfloat\tlbx= smoothstep(0.0,1.0,p.x-px);\t\n  \t\tfloat  lby= smoothstep(0.0,1.0,p.y-py);\t \n \t\t float  lbz= smoothstep(0.0,1.0,p.z-pz);\n\t  \t  float    p0 = value_at (px,  py,  pz);    float    p1 = value_at (px+1.0,py,  pz);\n      \t  float    p2 = value_at (px+1.0,py+1.0,pz);    float    p3 = value_at (px,  py+1.0,pz);\t\t\n      \t  float    p4 = value_at (px,  py,  pz+1.0);  float      p5 = value_at (px+1.0,py,  pz+1.0);\n      \t  float    p6 = value_at (px+1.0,py+1.0,pz+1.0);  float      p7 = value_at (px,  py+1.0,pz+1.0);   \t     \n          float  p01 =mix(p0,p1,lbx);\t\t\t  float  p32 =mix(p3,p2,lbx);\n    \t  float  \tp45 =mix(p4,p5,lbx);\t\t  float  \tp76 =mix(p7,p6,lbx);\n\t\t  float  \tp0132=mix(p01,p32,lby);\t\t  float  \tp4576=mix(p45,p76,lby);  \t \n    float   c1=mix(p0132,p4576,lbz);\n    return    (c1);}\n\n\nfloat  synmin(float a,float  b,float  r ,float w,float g) {\n    // drop-in function for smin  \n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*e*w*(exp(1.0-(e*g ))))/max(a,b)*0.5)\n \n            ;}\n\nfloat conecapsule2 (vec3 p, vec4 p1 ,vec4 p2  ) {\n// eats vec4 (x,y,z,r) X 2\nvec3 a=mix(p1.xyz,p2.xyz,0.15); // pull back a little from joint\nvec3 b=mix(p1.xyz,p2.xyz,0.9);\nfloat\t\td1=p1.w;\nfloat\t\td2=p2.w*0.9;\nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\n float conecapsule (vec3 p, vec4 p1 ,vec4 p2 ,float w, float z) {\n\n    // wrapper of conecapsule to introduce some bump noise\n    \n     vec3 n=normalize(vec3 (\n     conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.01,0.0,0.0) ,p1,p2),\n       conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.01,0.0),p1,p2 ),\n      conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.0,0.01),p1,p2 )\n           ));\n \n    \nfloat bumpb=noise3d(n*w+p/(45./w))*z;//mostly normaldriven with a dash of global p\n     \nreturn conecapsule2 (p,p1,p2) +bumpb \n   ; \n}\n \n\nvec4 map(vec4 r0)\n{  vec3 p=r0.xyz ;\n \n \n // make a few points\n vec4 p1= vec4(-0.+(sin(iTime*.5+1.)+1.25)*10.,0.,0.,8.);\n vec4 p2= vec4(45.,0.,0., 7.+(sin(iTime*.7+1.)+1.)*5.);\n vec4 p1b =vec4 ( p1.x, p1.y, p1.z, 5.5+(sin(iTime*.9)+1.1)*5. );\n  vec4 p3= vec4(-10.-(cos(iTime*.5)+1.25)*10.,0.,(sin(iTime*.5))*10., 4.5+(sin(iTime*.9)+1.1)*3.0);\n  vec4 p4= vec4(-40.,-1.+(cos(iTime*.95)+1.25)*10.,-45.+ (sin(iTime*.95)+1.25)*10., 3.1+(sin(iTime*.9)+1.)*3.0);\n// connect point with conecaplsule bones\n float v1= conecapsule(\n               p, \n                p2 , p1,\n             \n                                   \n               (sin(iTime*1.5)+1.5)*3.,(sin(iTime*2.)+1.5)*0.5                   \n                );\n \n float v2= conecapsule(\n               p,                  \n                   p1b,\n                  p3,\n                                   \n               (sin(iTime*1.3)+1.5)*3.,(sin(iTime*2.1)+1.5)*0.5                   \n                );\n  float v2b= conecapsule(\n               p,                  \n                   p1b,\n                  p3,\n                                   \n               3.,2.25                  \n                );\n \n  float v3= conecapsule(\n               p,                  \n                   p3,\n                  p4,\n                                   \n               (sin(iTime*3.1)+1.5)*3.,(sin(iTime*2.4)+1.5)*0.5                   \n                );\n \n \n // synmin union \n //return vec4(  v2b,0.56,0.51,0.52);   //uncomment for single bome demo\n \n return vec4( \n      synmin(v2,  min(v1,v3),(sin(iTime*0.39)+1.1)*8.,(sin(iTime*0.71)+1.4)*8.,(sin(iTime*0.59)+1.4)*2.)\n        ,v1>v2?0.015:0.025, v2<v3?0.015:0.025, 0.013)\n               ;\n\n }\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 300.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.42);\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( ro +vec3(0,10,10) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        vec3 lin = vec3(0.0);\n       lin += 1.30*dif*vec3(1.00,0.80,0.55);\n         lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        // lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n        // lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.6);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n#ifdef GLSLVIEWER\n    vec3 eye = vec3(u_eye3d.x, -u_eye3d.z, u_eye3d.y)*r + origin;\n    vec3 centre = vec3(u_centre3d.x, -u_centre3d.z, u_centre3d.y)*r + origin;\n    vec3 up = vec3(u_up3d.x, -u_up3d.z, u_up3d.y);\n#else\n   \n      vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\n   // vec3 eye = vec3(sin(iTime/4.)*100., cos(iTime/4.)*90., cos(iTime/4.)*26. +10.);\n    vec3 centre = vec3(0.0, 10.0, 0.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 01.0);\n\t \n#endif\n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}