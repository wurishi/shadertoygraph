{"ver":"0.1","info":{"id":"MlKGDK","date":"1476911310","viewed":192,"name":"Tortured blob","username":"roywig","description":"it's a blob","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat PI = 3.14159;\n\n\nfloat wiggle(vec3 p){\n    float n = 2./PI*4.;\n    return p.x+0.1*(sin((iTime)*PI*2.))*(cos(p.y*n)+sin(p.z*n));\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\nfloat map( vec3 p )\n{    \n    \n    float ang = PI/4.+iTime;\n    float si = sin(ang); float co = cos(ang);\n   mat3 cam_mat = mat3(\n      co, 0., si, \n      0., 1., 0., \n     -si, 0., co );\n   si = sin(ang); co = cos(ang);\n   cam_mat *= mat3(\n      1., 0., 0., \n      0., co, si, \n      0.,-si, co);\n\n   ang = p.y/7.*sin(iTime*PI*2.);\n   si = sin(ang); co = cos(ang);\n   cam_mat *= mat3(\n      co, 0., si, \n      0., 1., 0., \n     -si, 0., co );\n    \n   ang = p.z/6.*sin(iTime*PI);\n   si = sin(ang); co = cos(ang);\n   \n    cam_mat *= mat3(\n      1., 0., 0., \n      0., co, si, \n      0.,-si, co);\n\n       ang = p.x/6.*sin(iTime*PI);\n   si = sin(ang); co = cos(ang);\n   \n    cam_mat *= mat3(\n      co, 0., si, \n      0., 1., 0., \n     -si, 0., co );\n    p *= cam_mat;\n    \n\tfloat k = wiggle(p.zyx)-5.;\n    \n   \n    k = fOpIntersectionRound(k,-(wiggle(p.zyx)+5.),3.);\n    k = fOpIntersectionRound(k,-(wiggle(p)+5.),3.);\n    k = fOpIntersectionRound(k,wiggle(p)-5.,3.);\n    k = fOpIntersectionColumns(k,-(wiggle(p.yxz)+5.),3.,3.);\n    k = fOpIntersectionColumns(k,wiggle(p.yxz)-5.,3.,3.);  \n    return k;\n}\n \nvec3 getNormal( vec3 p )\n{\n    vec3 e = vec3( 0.001, 0, 0 );\n    float dX = map( p + e.xyy ) - map( p - e.xyy );\n    float dY = map( p + e.yxy ) - map( p - e.yxy );\n    float dZ = map( p + e.yyx ) - map( p - e.yyx );\n    \n    return normalize( vec3( dX, dY, dZ ) );\n}\n \nfloat trace( vec3 origin, vec3 direction, out vec3 p )\n{\n    float totalDistance = 0.0;\n\n    for( int i=0; i<16; ++i)\n    {\n        p = origin + direction * totalDistance;\n        float dist = map(p);\n        totalDistance += dist;\n        if( dist < 0.0001 ) break;\n        if( totalDistance > 10.0 )\n        {\n            totalDistance = 0.;\n            break;\n        }\n    }\n \n    return totalDistance;\n}\n \n//-----------------------------------------------------------------------------------------------\n// Standard Blinn lighting model.\n// This model computes the diffuse and specular components of the final surface color.\nvec3 calculateLighting(vec3 pointOnSurface, vec3 surfaceNormal, vec3 lightPosition, vec3 cameraPosition)\n{\n    vec3 fromPointToLight = normalize(lightPosition - pointOnSurface);\n    float diffuseStrength = clamp( dot( surfaceNormal, fromPointToLight ), 0.0, 1.0 );\n    \n    vec3 diffuseColor = diffuseStrength * vec3( 1.0, 0.0, 0.0 );\n    vec3 reflectedLightVector = normalize( reflect( -fromPointToLight, surfaceNormal ) );\n    \n    vec3 fromPointToCamera = normalize( cameraPosition - pointOnSurface );\n    float specularStrength = pow( clamp( dot(reflectedLightVector, fromPointToCamera), 0.0, 1.0 ), 10.0 );\n \n    // Ensure that there is no specular lighting when there is no diffuse lighting.\n    specularStrength = min( diffuseStrength, specularStrength );\n    vec3 specularColor = specularStrength * vec3( 1.0 );\n    \n    vec3 finalColor = diffuseColor + specularColor; \n \n    return finalColor;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 cameraPosition = vec3( 0.0, 0.0, -9.0 );\n    vec3 cameraDirection = normalize( vec3( uv.x, uv.y, 1.0) );\n    vec3 pointOnSurface;\n    float distanceToClosestPointInScene = trace( cameraPosition, cameraDirection, pointOnSurface );\n    vec3 finalColor = vec3(0.0);\n    if( distanceToClosestPointInScene > 0.0 )\n    {\n        vec3 lightPosition = vec3( 0, 0, -70.0 );\n        vec3 surfaceNormal = getNormal( pointOnSurface );\n        finalColor = calculateLighting( pointOnSurface, surfaceNormal, lightPosition, cameraPosition );\n    }\n    \n    fragColor = vec4( finalColor, 1.0 );\n}","name":"Image","description":"","type":"image"}]}