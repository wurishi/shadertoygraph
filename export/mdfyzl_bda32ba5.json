{"ver":"0.1","info":{"id":"mdfyzl","date":"1687102623","viewed":1427,"name":"Xor's Fast Sort 3D","username":"Xor","description":"Here's my first attempt at a pixel-sorting algorithm. Sorts red, green and blue channels","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["colors","pixel","sort"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Algorithim in Buffer A\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord-res*0.5)/res.y;\n\n    vec4 tex = texture(iChannel0,vec3(uv,.5));\n    fragColor = tex;\n    \n    //fragColor = vec4(tex[iFrame/144%3]);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"/*\n    An extension of my 2D sort: https://shadertoy.com/view/cdlcRf\n    Might have some issues. This is an early concept\n    \n*/\n\n#define TEX iChannel1\n//#define TEX iChannel2\n//#define TEX iChannel3\n\nconst vec2 RES  = vec2(1024);\nconst vec3 SIZE = vec3(128,128,64);\nvec3 map3(vec2 c)\n{\n    return (mod(vec3(c,dot(floor(c/SIZE.xy),vec2(1,RES.x/SIZE.x))),SIZE));\n}\nvec2 map2(vec3 p)\n{\n    return p.xy+vec2(mod(p.z,8.),floor(p.z/(RES.x/SIZE.x)))*SIZE.xy;\n}\n\nfloat index(vec3 p)\n{\n    return p.x+p.y*SIZE.x+p.z*SIZE.x*SIZE.y;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if (rayDir.z < max(abs(rayDir.x),abs(rayDir.y))) discard;\n    \n    vec2 res = iResolution.xy;\n    vec2 texel = 1.0 / res;\n    texel.y = -texel.y;\n    vec2 uv = fragCoord * texel;\n    \n    vec4 tex = texture(TEX,fragCoord*texel);\n    \n    int rate = int(iFrameRate);\n    int steps = int(log2(SIZE));\n    int f = (iFrame % (steps*rate))-steps*8;\n    \n   \n    vec3 v = map3(fragCoord);\n    float off = float(1<<steps-f/4%steps)-1.0;\n    vec3 o = off * sign(mod(v+float(f),2.0)-1.0);\n    \n    vec3 v0 = mod(v,SIZE);\n    vec3 v1 = mod(v+o*vec3(1,0,0),SIZE);\n    vec3 v2 = mod(v+o*vec3(0,1,0),SIZE);\n    vec3 v3 = mod(v+o*vec3(0,0,1),SIZE);\n    \n    vec2 p0 = map2(v0)-res/2.;\n    vec2 p1 = map2(v1)-res/2.;\n    vec2 p2 = map2(v2)-res/2.;\n    vec2 p3 = map2(v3)-res/2.;\n    \n    vec4 sort0 = texture(iChannel0, vec3(p0 * texel, .5));\n    vec4 sort1 = texture(iChannel0, vec3(p1 * texel, .5));\n    vec4 sort2 = texture(iChannel0, vec3(p2 * texel, .5));\n    vec4 sort3 = texture(iChannel0, vec3(p3 * texel, .5));\n    \n    float i0 = index(v0);\n    float i1 = index(v1);\n    float i2 = index(v2);\n    float i3 = index(v3);\n    \n    vec4 sortn = sort0;\n    sortn = (sortn - sort3).b * (i0-i3)<0.? sort3 : sortn;\n    sortn = (sortn - sort2).g * (i0-i2)<0.? sort2 : sortn;\n    sortn = (sortn - sort1).r * (i0-i1)<0.? sort1 : sortn;\n    \n    //sortn.rgb = vec3(map2(map3(fragCoord))/res,0);\n    fragColor = f<0? tex : sortn;\n}","name":"Cube A","description":"","type":"cubemap"}]}