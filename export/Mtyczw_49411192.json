{"ver":"0.1","info":{"id":"Mtyczw","date":"1535498966","viewed":1415,"name":"Manhattan Voronoi Distance Map","username":"curice","description":"Hello Shadertoy!!!\nThis is my attempt at generating smooth distances to Manhattan Voronoi Cell Edges. Blatantly inspired by IQ's euclidean version, I hope this doesn't offend anyone. I will be writing an article on this topic in the coming days. <3 <3 ","likes":32,"published":1,"flags":0,"usePreview":1,"tags":["2d","voronoi","worley","manhattan","manhattanvoronoi","voronoiedges","manhattannorm","manhattanedges"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2018 Jake Rice\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/* \n--AUTHOR NOTES--\nHi new Shadertoy friends!!!!\nInspired by IQ's lovely voronoi edge shader, I attempted to define a distance function for manhattan voronoi cells.\nThis proposed method results in evenly spaced isoline lines, which was my goal. \nThere are easier methods of calculating this distance if isoline smoothness is disregarded (but that's lame).\nI'll probably touch on those in my article on the subject.\n\nNext on my list is extending it into 3 dimensions.\n\nAnyways this is my first GLSL shader ever, I come from the land of Houdini, so this was a bit of a struggle.\nApologies if there are easy things I missed that would speed this up (though I'm getting 60fps!!!).\nI'm not sure how you guys make such incredible things with so few tools to help debug issues...\n<3 <3 <3\n*/\n#define ANIMATE\n\n//hash2 shamelessly stolen from IQ <(^.^<)\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 ident(){\n  return mat2(1.,0.,0.,1.);\n}\nfloat vmax(vec2 a){\n    return max(a.x, a.y);\n}\n\nvec2 avg(vec2 a, vec2 b){\n    return (a + b) / 2.;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec3 map(vec3 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat dot2(vec2 a){return dot(a,a);}\n\nfloat man_dist(in vec2 center_a, in vec2 center_b, in vec2 p, out vec2 gradient){\n    //remember, balls in the L1 norm are octohedrons\n\n    vec2 midp = avg(center_a, center_b);\n    vec2 min_c = min(center_a, center_b);\n    vec2 max_c = max(center_a, center_b);\n    \n    //find the largest bounding box axis between the two centers\n    vec2 cm_dir = (min_c - max_c) * (min_c - max_c);\n    float max_axis = vmax(cm_dir);     \n    int max_comp = max_axis == cm_dir.x ? 0 : 1;\n    \n      \n    //define the diagonal source pos\n    vec2 edge = center_a;\n    edge[max_comp] = center_b[max_comp];\n    edge = normalize(edge - center_a);\n    float cc = dot(midp - center_a, edge);\n    vec2 new_p =  center_a + edge * cc;\n    float l = length(new_p - midp);\n    \n    vec2 diag_p_0 = new_p + edge * l;\n    \n    //define the diagonal destination pos\n    edge = center_b;\n    edge[max_comp] = center_a[max_comp];\n\n    edge = normalize(edge - center_b);\n    cc = dot(midp - center_b, edge);\n    new_p =  center_b + edge * cc;\n    l = length(new_p - midp);\n    \n    vec2 diag_p_1 = new_p + edge * l;\n    \n    \n    //define the direction of the two axis aligned planes\n    int min_comp = 1 - max_comp;\n    \n    vec2 dir_a = min_comp == 0 ? vec2(1., 0.) : vec2(0., 1.);\n    vec2 dir_b = dir_a;\n\n    float a_sign =  diag_p_0[min_comp] == max_c[min_comp] ? 1. : -1.;\n    dir_a *= a_sign;\n    dir_b *= a_sign * -1.;\n    \n    //get the projection distance to the axis aligned planes\n    float a_dist = dot(p - diag_p_0, dir_a);\n    float b_dist = dot(p - diag_p_1, dir_b);\n    \n    //get the distance to the diagonal\n    vec2 diag = (diag_p_1 - diag_p_0);\n    \n    float diag_l =  dot2(diag);\n    float diag_dist = dot(p - diag_p_0, diag) / diag_l;\n    \n    //project our current pos onto the diagonal\n    //make sure you clamp it to just that edge\n    vec2 proj_diag = diag_p_0 + diag * clamp(diag_dist, 0., 1.);\n    vec2 proj_a = diag_p_0 + dir_a *  max(a_dist, 0.);\n    vec2 proj_b = diag_p_1 + dir_b * max(b_dist, 0.);\n    \n    //find the distance to the projected point on the planes\n    float a_p_dist = length(proj_a - p );\n    float b_p_dist = length(proj_b - p );\n    \n    float p_diag_dist = length(proj_diag - p) ;\n    \n    float min_dist = min(p_diag_dist, min(a_p_dist, b_p_dist));\n    \n    //this branching is not needed if you dont want shading normals\n    if(min_dist == p_diag_dist){\n        gradient = proj_diag - p;\n    }else if(min_dist == a_p_dist){\n        gradient = proj_a - p;\n    }else{\n        gradient = proj_b - p;\n    }\n    \n\n    //find the minimum of all the distances\n    return min_dist;\n    \n}\n\n//this portion is all based on IQ's Voronoi Edge Shader\n//any additions have been commented\nvec3 voronoi( in vec2 x, out vec2 gradient, out vec2 cell)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr, mr_2;\n\n    float md = 10.0;\n    \n    //we need to extend the search domain to two cells for voronoi generation (as opposed to one).\n    //this is due to the fact that the manhattan metric is not a straight distance\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime * .1 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        \n        //manhattan distance (L1 Norm)\n        float d = abs(r.x) +abs(r.y);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            cell = o;\n        }\n    }\n\t//cell = mg;\n    //----------------------------------\n    // second pass: distance to borders\n    //---------------------------------\n    \n    md = 10.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2;i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime * .1 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\t\t\n        //call our custom edge distance function\n        if( dot(mr-r,mr-r)>1e-4 ){\n            vec2 grad = vec2(0.);\n            float man_dist = man_dist(f - mr, f - r, f, grad);\n        \tmd = min(md, man_dist);\n            gradient = md == man_dist ? grad : gradient;\n        } \n            \n    }\n\t\n    return vec3( md, mr );\n}\n\n//Visualization also shamelessly stolen from IQ (>^.^)>\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = fragCoord/iResolution.xx;\n    vec2 grad = vec2(0.);\n    vec2 cell = vec2(0.);\n    vec3 c = voronoi(5.0*p, grad, cell);\n    \n    vec3 col = vec3(0.);\n    \n    grad = normalize(grad);\n    vec2 light_dir = vec2(1., 0.);\n    mat2 rotation = rotate2d(iTime * .25);\n    light_dir = normalize(light_dir * rotation);\n    float lighting = clamp(dot(grad, light_dir),0., 1.);\n    lighting = map(lighting, 0., 1., .25, 1.);\n    lighting = pow(lighting, .75);\n    //uncomment \n\n    vec3 cell_color = vec3(sin(cell.x * 30.28 + 50.), cos((cell.x * 50.28) + 20.) * .1, .5);                  \n    cell_color = map(cell_color, vec3(-1.), vec3(1.), vec3(.5), vec3(1.));\n    \n    cell_color = palette(cell.x, vec3(.5), vec3(0.3), vec3(.05,0.1,.6), vec3(.2, .6, .4));\n    \n    col = cell_color;\n    //isolines\n    col *=  pow(0.5 + 0.5*cos(200.0*c.x + iTime * 1.), 2.) *vec3(2.0);\n    col *= lighting;\n    \n    // borders\t\n    //col = mix( vec3(0.), col, pow(smoothstep( 0.002, 0.015, c.x ), .75) );\n    \n    \n    /*\n    //isolines\n    col += c.x * pow(0.5 + 0.5*sin(200.0*c.x + iTime * .1), 1.) *vec3(2.0);\n    // borders\t\n    col = mix( vec3(1.), col, pow(smoothstep( 0.002, 0.015, c.x ), 1.) );\n\t*/\n\n\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}