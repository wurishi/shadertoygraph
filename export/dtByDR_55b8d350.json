{"ver":"0.1","info":{"id":"dtByDR","date":"1691650728","viewed":241,"name":"skyland","username":"kaliuresis","description":"testing pixel art in shaders","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define halfsqrt3 0.86602540\n#define invsqrt3 0.57735026\n#define tau 6.28318530\n#define pi 3.14159265358979323846264338327950\n\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 65536.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\nvec2 hash2D(vec2 x)\n{\n    // based on: Inigo Quilez, Integer Hash - III, 2017\n    uvec4 q = uvec2(x * 65536.0).xyyx + uvec2(0u, 3115245u).xxyy;\n    q = 1103515245u * ((q >> 1u) ^ q.yxwz);\n    uvec2 n = 1103515245u * (q.xz ^ (q.yw >> 3u));\n    return vec2(n) * (1.0 / float(0xffffffffu));\n}\n\nfloat hash(vec2 x, float time)\n{\n    return 0.5+0.5*sin(tau*hash1D(abs(x))+time);\n}\n\n//value noise on a triangular lattice, with gradients\nvec3 tri_noise(vec2 p, float time)\n{\n    vec2 q = vec2(p.x-p.y*invsqrt3, p.y*2.0*invsqrt3);\n    vec2 iq = floor(q);\n    vec2 fq = fract(q);\n    vec3 v = vec3(0.0);\n    \n    float h = step(1.0, fq.x+fq.y); //which half of the unit cell does this triangle lie in\n    vec2 c = iq+h;\n    vec2 r = p-vec2(c.x+0.5*c.y, halfsqrt3*c.y);\n    float s = 1.0-2.0*h;\n    r *= s;\n    \n    //compute barrycentric coordinates\n    vec3 lambda = vec3(1.0-r.x-invsqrt3*r.y, r.x-invsqrt3*r.y, 2.0*invsqrt3*r.y);\n    vec3 dlambda_dx = vec3(-1.0,1.0,0.0)*s;\n    vec3 dlambda_dy = vec3(-invsqrt3,-invsqrt3,2.0*invsqrt3)*s;\n    \n    #if 1\n    //quintic////////////////////\n    vec3 lambda2 = lambda*lambda;\n    vec3 a = 15.0*lambda2*lambda2.zxy*lambda.yzx;\n    \n    vec3 da_dlambda_xyz = 30.0*lambda*lambda2.zxy*lambda.yzx;\n    vec3 da_dlambda_zxy = 30.0*lambda2*lambda.zxy*lambda.yzx;\n    vec3 da_dlambda_yzx = 15.0*lambda2*lambda2.zxy;\n    vec3 da_dx = da_dlambda_xyz*dlambda_dx + da_dlambda_zxy*dlambda_dx.zxy + da_dlambda_yzx*dlambda_dx.yzx;\n    vec3 da_dy = da_dlambda_xyz*dlambda_dy + da_dlambda_zxy*dlambda_dy.zxy + da_dlambda_yzx*dlambda_dy.yzx;\n    \n    //weights set to be quintic smoothstep along edges, with extra terms to set gradients in the normal direction to 0\n    //these magically add up to 1 without correction\n    vec3 w = lambda*lambda2*(10.0-15.0*lambda+6.0*lambda2)+a+a.yzx;\n        \n    //derivatives\n    vec3 dw_dx = 30.0*dlambda_dx*lambda2*(1.0-lambda)*(1.0-lambda) + da_dx+da_dx.yzx;\n    vec3 dw_dy = 30.0*dlambda_dy*lambda2*(1.0-lambda)*(1.0-lambda) + da_dy+da_dy.yzx;\n    \n    #else\n    //cubic//////////////////////\n    \n    //this is eqiuvalent to:\n    /*\n    vec3 w = lambda*lambda*(3.0-2.0*lambda)\n        +3.0*lambda*lambda*lambda.zxy*lambda.yzx*lambda.zxy/((lambda+lambda.yzx)*(1.0-lambda))\n        +3.0*lambda*lambda*lambda.zxy*lambda.yzx*lambda.yzx/((lambda+lambda.zxy)*(1.0-lambda));\n    w -= (dot(w, vec3(1.0))-1.0)/3.0;\n    */        \n    \n    vec3 den = 1.0/(1.0-lambda);\n    vec3 a0 = (2.0*lambda+1.0)*den;\n    \n    vec3 b0 = (3.0*lambda.yzx+lambda);\n    vec3 b1 = (3.0*lambda.zxy+lambda);\n    \n    vec3 c0 = b0*a0.zxy;\n    vec3 c1 = b1*a0.yzx;\n    \n    vec3 f = (1.0/3.0)*lambda*(3.0-2.0*lambda+c0+c1);\n    \n\n    vec3 w = f*lambda;\n    \n    //derivatives\n    vec3 dw_dx = 2.0*f*dlambda_dx\n                  +(1.0/3.0)*lambda*lambda\n                   *(-2.0*dlambda_dx\n                   \n                     +(3.0*dlambda_dx.yzx+dlambda_dx)*a0.zxy\n                     +2.0*dlambda_dx.zxy*b0*den.zxy\n                     +dlambda_dx.zxy*c0*den.zxy\n                     \n                     +(3.0*dlambda_dx.zxy+dlambda_dx)*a0.yzx\n                     +2.0*dlambda_dx.yzx*b1*den.yzx\n                     +dlambda_dx.yzx*c1*den.yzx\n                     );\n                     \n    vec3 dw_dy = 2.0*f*dlambda_dy\n                   +(1.0/3.0)*lambda*lambda\n                    *(-2.0*dlambda_dy\n                   \n                     +(3.0*dlambda_dy.yzx+dlambda_dy)*a0.zxy\n                     +2.0*dlambda_dy.zxy*b0*den.zxy\n                     +dlambda_dy.zxy*c0*den.zxy\n                     \n                     +(3.0*dlambda_dy.zxy+dlambda_dy)*a0.yzx\n                     +2.0*dlambda_dy.yzx*b1*den.yzx\n                     +dlambda_dy.yzx*c1*den.yzx\n                     );\n    #endif\n    ////////////////////////////\n    \n    v += vec3(w.x, dw_dx.x, dw_dy.x)*hash(c, time);\n    v += vec3(w.y, dw_dx.y, dw_dy.y)*hash(iq+vec2(1.0-h,h), time);\n    v += vec3(w.z, dw_dx.z, dw_dy.z)*hash(iq+vec2(h,1.0-h), time);\n    \n    return v;\n}\n\nvec3 fbm(vec2 p, float time, int octaves, float decay, float scale, float time_factor)\n{\n    vec4 v = vec4(0.0);\n    float weight = 1.0;\n    for(int i = 0; i < octaves; i++)\n    {\n        //time = mod(time, tau);\n        v += weight*vec4(tri_noise(p, time), 1.0);\n        p *= scale;//*mat2(4.0/5.0, -3.0/5.0, 3.0/5.0, 4.0/5.0);\n        weight *= decay;\n        time *= time_factor;\n    }\n    return v.xyz/v.w;\n}\n\nfloat noise1d(float x, float phase)\n{\n    float ix = floor(x);\n    float fx = x-ix;\n    float h0 = hash(vec2(ix,0.0), phase);\n    float h1 = hash(vec2(ix+1.0,0.0), phase);\n    return h0 + (h1-h0)*fx*fx*(3.0-2.0*fx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = float(iFrame)/360.0*pi;\n    float time = iTime;\n    vec2 uv = fragCoord/iResolution.y;\n    float pixel_scale = 48.0;\n    uv = floor(uv*pixel_scale)/pixel_scale;\n    float aspect_ratio = iResolution.x/iResolution.y;\n\n    vec2 p = uv-vec2(aspect_ratio*0.5,0.64);\n\n    vec3 noise = fbm(10.0*(p+vec2(aspect_ratio*0.5,0.7)), 10.0, 4, 0.7, 2.0, 1.6);\n    vec3 v = 0.6*noise*vec3(1.0,10.0,10.0) \n             +2.4*(smoothstep(-0.1,0.1,p.x)-0.5)*vec3(p.x-3.0*p.x*p.y, 1.0, 0.0)\n             -mix(2.0, -10.0, smoothstep(0.0,0.1,p.y))*vec3(p.y,0.0,1.0);\n    float a = clamp(-2.0*(p.y-0.02), 0.0, 1.0);\n    v.z -= 100.0*a*(1.0-a);\n    //1.2*p.x-1.2*3.0*p.x*p.y+p.y = C\n    float r = 1.0*(0.35+p.y)/(0.6-0.6*3.0*p.y);\n    v.y += 8.0*p.x*pow(max(r*r-p.x*p.x, 0.001), -0.5)*smoothstep(0.0, -0.2, p.y);\n           \n    vec4 sky_color0 = vec4(1.0,1.0,0.8,1.0);\n    vec4 sky_color1 = vec4(0.2,0.7,0.9,1.0);\n    fragColor = mix(sky_color0, sky_color1, 0.5+dot(p, vec2(0.3, -1.0)));\n    \n    //island\n    {\n        vec4 color;\n        color.a = smoothstep(0.0, 0.1, 1.0-clamp(v.x, 0.0, 1.0));\n\n        vec3 normal = vec3(v.yz, 1.0);\n\n        //island_color.xyz = 0.07*vec3(v.yz, 1.0) + 0.6;\n        color.rgb = 0.2*sky_color0.rgb;\n        color.rgb += clamp(vec3(0.5,0.5,0.5)*dot(normal, vec3(-0.1,0.1,0.7)), 0.0, 1.0);\n        color.rgb += clamp(0.03*sky_color1.rgb*dot(normal, vec3(-1.0,-0.1,0.7)), 0.0, 1.0);\n        color.rgb += 0.6*pow(clamp(dot(normalize(normal), normalize(vec3(1.0,-1.0,1.0))), 0.0, 1.0), 8.0);\n\n        vec3 grass_color = vec3(0.2,0.9,0.3)+noise.x*vec3(0.9,0.0,0.0);\n        color.rgb *= mix(vec3(1.0), grass_color, clamp(10.0*p.y+1.0*v.z+1.2,0.0, 1.0));\n        \n        fragColor.rgb = fragColor.rgb*(1.0-color.a)+color.rgb*color.a;\n    }\n    \n    //waterfall\n    {\n        vec2 p2 = p;\n        p2.x += 0.1*fbm(vec2(40.0, 5.0)*uv+vec2(0.0, 10.0*time), 0.1*time, 3, 0.5, 1.5, 1.5).x;\n        //p2.y += 0.1*fbm(vec2(20.0, 5.0)*uv+vec2(100.0, 6.0*iTime), time, 2, 0.5, 2.0, 1.6).x;\n        vec3 noise = fbm(vec2(10.0, 0.0)*p+vec2(0.0, -5.0*sqrt(max(0.1-p.y, 0.0)))+vec2(0.0, 6.0*time), 4.0*time, 6, 0.8, 2.0, 1.6)*vec3(1.0,20.0,10.0);\n        vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n        //color *= 0.5*noise.y+0.5;\n        vec3 normal = vec3(noise.yz, 1.0);\n        color.rgb = 0.5*sky_color0.rgb;\n        color.rgb += clamp(vec3(0.3,0.3,0.3)*abs(dot(normal, vec3(-0.1,0.1,0.7))), 0.0, 1.0);\n        color.rgb += clamp(0.01*sky_color1.rgb*abs(dot(normal, vec3(-1.0,-0.1,0.7))), 0.0, 1.0);\n        color.rgb += 0.1*pow(clamp(abs(dot(normalize(normal), normalize(vec3(-1.0,1.0,0.0)))), 0.0, 1.0), 2.0);\n        color *= mix(vec4(0.5,0.8,0.9,0.9), vec4(0.8, 0.9, 1.0, 0.0), pow(noise.x,2.0));\n\n        color.a *= smoothstep(-0.5, -0.4, p2.x)*smoothstep(0.2, 0.3, -p2.x)*smoothstep(0.125+0.1*p2.x, 0.12+0.1*p2.x, p2.y+0.03*noise.x);\n        color.a = smoothstep(0.0, max(1.0, -7.0*p.y), color.a);\n        \n        fbm(10.0*uv, 300.0, 4, 0.6, 2.0, 1.6);\n        fragColor.rgb = fragColor.rgb*(1.0-color.a)+color.rgb*color.a;\n    }\n    \n    //sun\n    {\n        vec2 r = p-vec2(-2.0,1.8);\n        float theta = atan(r.y,r.x)+0.01*time;\n        float n = noise1d(100.0*theta/pi, time);\n        fragColor.rgb += (0.0+0.1*n)*dot(normalize(r), vec2(1.0,-1.0));\n    }\n}","name":"Image","description":"","type":"image"}]}