{"ver":"0.1","info":{"id":"wtfcDB","date":"1592944478","viewed":266,"name":"Pathtracer-326lns","username":"ncortiz","description":"Naive pathtracer adapted from my own Cuda nvc++ code.\n\nWith dielectric, metallic fuzzy, emissive and diffuse BSDFs.\n\nSSAA.\n\n","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","pathtracing","realtime","renderer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 tone(vec3 color, float gamma) //Reinhard based tone mapping, from: https://www.shadertoy.com/view/XdSSRw\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); } //https://www.shadertoy.com/view/Xt23Ry\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n//float rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n//Copyright (C) 2020 Nicolas Ortiz\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415926538f\n\n//Primitives\nbool trace_sphere (vec3 ro, vec3 rd, vec3 o, float r, float tmin, float tmax, \n                  out vec3 p, out vec3 n, out vec3 t, out vec2 uv, out float dist)\n{\n\tvec3 oc = ro - o;\n    float a = dot (rd, rd);\n    float b = dot (oc, rd);\n    float c = dot (oc, oc) - r * r;\n    float t0 = b * b - a * c;\n    dist = tmax;\n\n    if (t0 > 0.0)\n    {\n        float t1 = (-b - sqrt (t0)) / a;\n\n        if (t1 < tmax && t1 > tmin)\n        {\n            dist = t1;\n            p = ro + rd * dist;\n            n = (p - o) * (1.0f / r);\n            t = cross(vec3 (0, 1, 0), n);\n\n            uv.x = (1.f + atan (n.z, n.x) / PI) * 0.5f;\n            uv.y = acos (n.y) / PI;\n\n            return true;\n        }\n\n        t1 = (-b + sqrt (t0)) / a;\n\n        if (t1 < tmax && t1 > tmin)\n        {\n            dist = t1;\n            p = ro + rd * dist;\n            n = (p - o) * (1.0f / r);\n            t = cross(vec3 (0, 1, 0), n);\n\n            uv.x = (1.f + atan (n.z, n.x) /PI) * 0.5f;\n            uv.y = acos (n.y) / PI;\n\n            return true;\n        }\n    }\n\n    return false;   \n}\n//BSDFs/PDFs\nvec3 sample_sphere (vec2 screen_uv) //Uniform sphere sample \n{\n    float cosPhi = 2.0 * rand (screen_uv*iTime) - 1.0;\n    float sinPhi = sqrt (1.0 - cosPhi * cosPhi);\n    float theta = 2.0 * PI * rand (rand (screen_uv*screen_uv * iTime));\n\n    return vec3 (sinPhi * sin (theta),\n        cosPhi,\n        sinPhi * cos (theta));\n}\n\nvec3 sample_metal(vec3 n, vec3 rd, float fuzzy, vec2 screen_uv) //Mix (interpolate) reflection with diffuse by fuzz param basically\n{\n    vec3 reflected = normalize(rd - n * dot(n, rd) * 2.0f);      \n    return normalize(reflected + sample_sphere(screen_uv) * fuzzy);\n}\n\nvec3 sample_cosine_weighted(vec3 n, vec2 screen_uv) //cosine weighted hemisphere sampling\n{\n    float phi = 2.f * PI * rand (screen_uv);\n    float r2 = rand(rand (screen_uv*iTime));\n    float r2s = sqrt (r2);\n\n    vec3 w = normalize (n);\n    vec3 u = normalize(cross((abs (w.x) > .1 ? vec3 (0, 1, 0) : vec3 (1, 0, 0)), w));\n    vec3 v = cross (w, u);\n\n    return normalize(u * cos (phi) * r2s + v * sin (phi) * r2s + w * sqrt (1.f - r2));\n}\n\nvec3 sample_phong_metal(vec3 n, vec3 rd, float e, vec2 screen_uv) //phong for metals\n{\n    float phi = 2.f * PI * rand(screen_uv);\n    float r2 = rand(rand(screen_uv));\n  \n    float cos_theta = pow(1.f - r2, 1.f / (e + 1.f));\n    float sin_theta = sqrt(1.f - cos_theta * cos_theta);\n    \n    vec3 w = normalize((rd - n * dot(n, rd) * 2.0f));\n    vec3 u = normalize(cross((abs(w.x) > 1.f ? vec3(0,1,0) : vec3(1,0,0)),w));\n    vec3 v = cross(w, u);\n    \n    return normalize(u * cos(phi) * sin_theta + v * sin(phi) * sin_theta + w * cos_theta);\n}\nfloat F_Schlick (float cosine, float ref_idx) //schlick fresnel factor\n{\n    float r0 = (1.0f - ref_idx) / (1.0f + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0f - r0) * pow (1.0f - cosine, 5.0f);\n}\n\nbool do_refract(vec3 v, vec3 n, float ni_over_nt, out vec3 refr)\n{\n    vec3 uv = normalize(v);\n    float dt = dot(uv, n);\n    float t = 1.0f - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n    \n    if(t > 0.0f)\n    {\n        refr = (uv - n * dt) * ni_over_nt - n * sqrt(t);\n     \treturn true;   \n    }\n    \n    return false;\n}\nvec3 sample_dielectric(vec3 n, vec3 rd, float ior, vec2 screen_uv)\n{\n    float idotn = dot (rd, n);\n    \n    vec3 outward_normal;\n    float ni_over_nt;\n    float cosine;\n    if (idotn > 0.0f) //from inside to outside or the other way around (dot(raydir, normal))\n    {\n        outward_normal = -n;\n        ni_over_nt = ior;\n        cosine = idotn / length(rd);\n        cosine = sqrt (1.0f - ior * ior * (1.0f - cosine * cosine));\n    }\n    else \n    {\n        outward_normal = n;\n        ni_over_nt = 1.0f / ior;\n        cosine = -idotn / length(rd);\n    }\n\n    vec3 refracted;\n    float p;\n    if (do_refract (rd, outward_normal, ni_over_nt, refracted)) //compute refr. dir and will it refract or reflect\n        p = F_Schlick (cosine, ior); //probability of reflection is fresnel-schlick\n    else\n        p = 1.0f; //reflect 100% \n\n    if (rand (screen_uv * iTime) < p)\n        return normalize(normalize((rd - n * dot (n, rd) * 2.0))); //reflection\n    else\n        return normalize(refracted); //refraction\n}\n\n\n//Main \nbool trace_scene(inout vec3 ro, inout vec3 rd, out vec3 d, out vec3 e, vec2 screen_uv)\n{ \n    //n: normal, p: point, t: tangent, d: diffuse, e: emission, ro: ray origin, rd: ray direction, uv: tex coords\n    vec3 n, p, t; \n    vec2 uv;\n    float tmax = 1000.f;\n    float dist;\n    //Here in the event of a ray-object collision we set diffuse and emission based on \n    //e objects properties and set the direction of the ray based on the objects bsdf.\n    //As well as tmax to the objects distance (doesnt make a difference yet since we lack depth sorting)\n        \n    bool o1 = trace_sphere(ro, rd, vec3(sin(iTime * 0.8f) - 0.8f,0.5f + sin(iTime * 2.f) * 0.5f,-10.f+sin(iTime * 1.5f)), 1.f, 0.001f, tmax, p, n, t, uv, dist);\n    if(o1)\n    {\n        d = vec3(0.9,0.9,0.9);\n        e = vec3(0);\n        \n        ro = p;\n        rd = sample_dielectric(n, rd, 1.52f, screen_uv);//or 1.02 for less of an effect\n        tmax = dist;\n        return true;\n    }\n    \n    bool o2 = trace_sphere(ro, rd, vec3(1.5f,0,-12.f + (sin((0.65f * PI) + iTime * 1.2f) * 1.5f)), 1.f, 0.001f, tmax, p, n, t, uv, dist);\n    if(o2)\n    {\n        d = vec3(.7,.7,0);\n        e = vec3(0);\n        \n        ro = p;\n        rd = sample_metal(n, rd, 0.7f, screen_uv);\n        tmax = dist;\n        return true;\n    }\n    \n        \n    bool o3 = trace_sphere(ro, rd, vec3(-1.5f + sin(iTime*3.0f)*0.6f,1.f + sin(iTime*3.f)*0.6f,-12), 1.f, 0.001f, tmax, p, n, t, uv, dist);\n    if(o3)\n    {\n        d = vec3(0,0,0);\n        e = vec3(1,1,0.4f) * 30.f;\n        \n        ro = p;\n        rd = vec3(0);\n        tmax = dist;\n        return true;\n    }\n    \n    //disabled to lower compilation time    \n    /*bool o4 = trace_sphere(ro, rd, vec3(-3.f + sin(iTime * 0.5f) * 0.5f,0,-12.f + sin(iTime * 0.5f) * .3f), 1.f, 0.001f, tmax, p, n, t, uv, dist);\n    if(o4)\n    {\n        d = texture(iChannel1, uv).rgb;\n        e = vec3(0);\n        \n        ro = p;\n        rd = sample_metal(n, rd, 0.0f, screen_uv);\n        tmax = dist;\n        return true;\n    }*/\n    \n    /*bool o5 = trace_sphere(ro, rd, vec3(3.5f,0,-12.f), 1.f, 0.001f, tmax, p, n, t, uv, dist);\n    if(o5)\n    {\n        d = texture(iChannel1, uv).rgb;\n        e = vec3(0);\n        \n        ro = p;\n        rd = sample_cosine_weighted(n, screen_uv);\n        tmax = dist;\n        return true;\n    }*/\n    \n    bool o6 = trace_sphere(ro, rd, vec3(-1.5f,-1001,-12), 1000.f, 0.001f, tmax, p, n, t, uv, dist);\n    if(o6)\n    {\n        d = vec3(.5,.2,.2); //diffuse color\n        e = vec3(0); //emission\n        \n        ro = p; //ray origin out \n        rd = sample_cosine_weighted(n, uv); //ray dir out\n        tmax = dist; //for depth testing \n        return true;\n    }\n\n    \n    return false;\n}\n\nvec3 radiance(in vec3 ro, in vec3 rd, vec2 uv)\n{\n    vec3 att = vec3(1);\n    vec3 col;\n    \n    for(int i = 0; i < 15; i++) //15 max bounces\n    {\n        vec3 d, e;\n        \n        if(!trace_scene(ro, rd, d, e, uv)) \n        {\n            vec4 hdri = texture(iChannel0, rd);\n            col += att * hdri.rgb * hdri.a;\n            break;\n        }\n        \n        col += att * e;    //Emission  \n        att *= d;         //Diffuse color\n        \n        if(i > 7) //Russian roulette sampling\n        { \n            float p = max(att.x, max(att.y, att.z));\n            if(rand(uv) > p)\n                break;\n            \n            att /= p;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int spp = 100; //Camera params\n    float aperture = 0.3;//clamp(sin(iTime * 0.7f) + 0.2f, 0.f, 1.f);\n    float vfov = 30.f;\n    vec3 pos = vec3(-0.7f,0,0);\n    float fl = 10.0f;\n\n    vec3 right = vec3(1,0,0); //Camera direction (use for rotation)\n    vec3 up = vec3(0,1,0);\n    vec3 fwd = vec3(0,0,1);\n   \n    float aspect = iResolution.x/iResolution.y; //Perspective calculations (frustum)\n    float hh = tan((vfov * (PI / 180.0f)) / 2.0f);\n    float hw = aspect * hh;\n    vec3 ll = pos - right * hw * fl - up * hh * fl - fwd * fl; \n    vec3 h = right * fl * 2.0f * hw; \n    vec3 v = up * fl * 2.0f * hh;\n    \n    vec3 color = vec3(0,0,0); \n    for(int i = 0; i < spp; i++) //Supersampling\n    {\n        vec2 uv_o = vec2(rand(fragCoord.xy * float(i)), rand(rand(fragCoord.xy)* float(i))); //Random offset\n        vec2 uv = (fragCoord + uv_o)/iResolution.xy; //Normalized screen coordinates with offset\n        \n        float r = sqrt(rand(iTime * uv));  //Disc sampling (DoF)\n        float theta = rand(rand((iTime * uv))) * 2.0f * PI;\n        vec3 ds = vec3(cos(theta), sin(theta), 0) * (aperture/2.0f);\n        vec3 o = right * ds.x + up * ds.y; //DoF offset \n        \n        vec3 ro = pos + o; //ray origin\n        vec3 rd = ll + h * uv.x + v * uv.y - pos - o; //ray dir\n        \n        color += clamp(tone(radiance(ro, rd, uv), 1.0f), 0.f, 1.f);\n    }\n    \n    fragColor = vec4(color / float(spp), 1); // Final color is average of samples tonemapped\n}","name":"Image","description":"","type":"image"}]}