{"ver":"0.1","info":{"id":"XfGGR1","date":"1712365821","viewed":65,"name":"Breathing Circle Fractal","username":"jj_elliott","description":"Simple Fractal Shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","colorful","geometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 pallete( in float t ){\n    vec3 a = vec3(0.5,0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos(6.28318 * (c*t*d));\n}\n\n// Function to rotate a point around the origin\nvec2 rotatePoint(vec2 point, float angle) {\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    return vec2(\n        point.x * cosTheta - point.y * sinTheta,\n        point.x * sinTheta + point.y * cosTheta\n    );\n}\n\n// Function to compute the triangle points, ensuring they maintain equilateral properties post-rotation\n// Now accepts 'aspect' to adjust for screen aspect ratio\nvoid computeTrianglePoints(float s, float angle, float aspect, out vec2 A, out vec2 B, out vec2 C) {\n    // Adjust initial positions considering aspect ratio\n    vec2 A_initial = vec2(0.0, (sqrt(3.0) * 0.5 * s) / aspect); // Vertex A\n    vec2 B_initial = vec2(-0.5 * s, (-sqrt(3.0) / 6.0 * s) / aspect); // Vertex B\n    vec2 C_initial = vec2(0.5 * s, (-sqrt(3.0) / 6.0 * s) / aspect); // Vertex C\n    \n    // Apply rotation uniformly to all vertices\n    A = rotatePoint(A_initial, angle);\n    B = rotatePoint(B_initial, angle);\n    C = rotatePoint(C_initial, angle);\n}\n\n// Signed Distance Function for the triangle, adjusted for precision\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n    vec2 pq0 = v0 - e0*clamp(dot(v0,e0)/dot(e0,e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1*clamp(dot(v1,e1)/dot(e1,e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2*clamp(dot(v2,e2)/dot(e2,e2), 0.0, 1.0);\n    float s = sign(e0.x*e2.y - e0.y*e2.x);\n    float d = min(min(dot(pq0,pq0), dot(pq1,pq1)), dot(pq2,pq2));\n    return sqrt(d) * ((dot(v0,e2)*e0.y > 0.0) ? -s : s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float freqMultiple = 1.0;\n    float timestepScale = 0.2;\n    float inverseScale = 0.005;\n    float fractalDimension = 4.0;\n    float fractalStep = 0.75;\n    float rotationStep = 0.;//3.14159 / 4.0;\n    float uvScale = 2.0;\n    float scaledTime = timestepScale * iTime;\n    \n    \n    // Center the UVs to [-1,1]\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i =0.0; i< fractalDimension; i+=fractalStep){\n        uv = fract(uv*(1.0 + sin(1.17*scaledTime)))-0.5;\n        uv = rotatePoint(uv,i * rotationStep);\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = pallete(length(uv0) + i*0.4 + scaledTime);\n        d = sin(d*8.0 + (1.09*scaledTime))/8.;\n        d = abs(d);\n        d = pow(inverseScale/d, 2.);\n        finalColor += col* d;\n    }\n    \n    //finalColor = vec3(1.0) - finalColor;\n    fragColor = vec4(finalColor,1.0);    \n}","name":"Image","description":"","type":"image"}]}