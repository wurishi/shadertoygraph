{"ver":"0.1","info":{"id":"3lVyDD","date":"1611869505","viewed":80,"name":"Miyagi Lines","username":"obecerra","description":"https://thebookofshaders.com/05/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["chaper5"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat plot (vec2 st, float val){\n  return  smoothstep( val-0.01, val, st.y) -\n          smoothstep( val, val+0.01, st.y);\n}\n\nfloat plot2(vec2 st, float val, float thicc){\n  return  smoothstep( val-thicc, val, st.y) -\n          smoothstep( val, val+thicc, st.y);\n}\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nconst float resetTime = 13.;\nconst float zoomOutDistance = 5.;\nconst float zoomInDistance = 0.05;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord / iResolution.xy;\n    vec3 color;\n    float di = 0.5;\n    float delta = abs(sinc(iTime * 0.25, 0.01));\n    \n    if (iTime > resetTime) {\n        delta = abs(sinc(iTime - resetTime, 0.01));\n    }\n       \n    st.x += 0.5;\n    st.x *= 4.;\n    st.y -= 0.5;\n    // st.y *= (step(resetTime, iTime) * zoomOutDistance) + zoomInDistance;\n    st.y *= zoomOutDistance;\n    \n    for (float i=0.; i < 10.; i+=0.1) {\n        di += delta;\n        \n        // without noise\n        float y = 3.0 * sinc(st.x, di);\n        color += plot(st, y) * vec3(0.2, di * 0.1 * delta + mod(di, 0.5), di * 0.9 * delta);\n\n        // with 2D Noise\n        y = 3.0 * sinc(st.x, di) * noise (vec2(di));\n        color += plot(st, y) * vec3(0.2, di * 0.1 * delta + mod(di, 0.5), di * 0.9 * delta);\n\n        // lots of 2D Noise\n        y = 3.0 * sinc(st.x, di) * 10.0 * noise (vec2(di));\n        color += plot(st, y) * vec3(0.2, di * 0.1 * delta + mod(di, 0.5), di * 0.9 * delta);\n\n        // even more 2D Noise\n        y = 3.0 * sinc(st.x, di) * 100.0 * noise (vec2(di));\n        color += plot(st, y) * vec3(0.2, di * 0.1 * delta + mod(di, 0.5), di * 0.9 * delta);\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Advanced 2d shaping functions\n//============================================================================================================\n\n#define PI 3.14159265359\n#define epsilon 0.00001\n\nfloat sq(float x) {\n    return x*x;\n}\n\n\n// Polynomial shaping functions\n// http://www.flong.com/archive/texts/code/shapers_poly/index.html\n//------------------------------------------------------------------------------------------------------------\n\n// Blinn Wyvill raised inverted cosine approximation\nfloat bwCos (float x) {\n    float x2 = x*x;\n    float x4 = x2*x2;\n    float x6 = x4*x2;\n    \n    float fa = 4./9.;\n    float fb = 17./9.;\n    float fc = 22./9.;\n    \n    return fa*x6 - fb*x4 + fc*x2;\n}\n\n// Double cubic seat\n// joining two cubic curves at a horizontal inflection point at coord (a,b) in the unit square\nfloat dcSeat (float x, float a, float b) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = min(max_param_a, max(min_param_a, a));  \n  b = min(max_param_b, max(min_param_b, b)); \n  \n  float y = 0.;\n  if (x <= a){\n    y = b - b*pow(1.-x/a, 3.0);\n  } else {\n    y = b + (1.-b)*pow((x-a)/(1.-a), 3.0);\n  }\n  return y;\n}\n\n// Double cubic seat with linear blend\n// a controls inflection point across the diagonal, b controls blending with identity function y = x\nfloat dcSeatBlend (float x, float a, float b) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = min(max_param_a, max(min_param_a, a));  \n  b = min(max_param_b, max(min_param_b, b)); \n  b = 1.0 - b; //reverse for intelligibility.\n  \n  float y = 0.;\n  if (x<=a){\n    y = b*x + (1.-b)*a*(1.-pow(1.-x/a, 3.0));\n  } else {\n    y = b*x + (1.-b)*(a + (1.-a)*pow((x-a)/(1.-a), 3.0));\n  }\n  return y;\n}\n\n// Double Odd Polynomial seat\n// uses paramater n (between 1 to ~20) to determine the flatness of the inflection point\nfloat dcSeatOdd(float x, float a, float b, float n) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = min(max_param_a, max(min_param_a, a));  \n  b = min(max_param_b, max(min_param_b, b)); \n  \n  float p = 2.*n + 1.;\n  float y = 0.;\n  if (x <= a)\n      y = b - b*pow(1.-x/a, p);\n  else\n      y = b + (1.-b)*pow((x-a)/(1.-a), p);\n     \n  return y;\n}\n\n// Symmetric Double Polynomial Sigmoids\n// a,b inflection point, n (int from 0 to 10) the steepness of the wall in between.\n// approximates raised inverted cos to within 2.8%\nfloat doublePolySigmoid (float x, float a, float b, float n) {\n  float y = 0.;\n  if (mod(n,2.) == 0.){ \n    // even polynomial\n    if (x <= 0.5)\n      y = pow(2.0 * x, n) / 2.0;\n    else\n      y = 1.0 - pow(2.*(x-1.), n)/2.0;\n  } \n  else { \n    // odd polynomial\n    if (x <= 0.5)\n      y = pow(2.0*x, n)/2.0;\n    else\n      y = 1.0 + pow(2.0*(x-1.), n)/2.0;\n  }\n\n  return y;\n}\n\n// Quadratic through a point\n// not all combinations of (a,b) will return a correct quad\nfloat quadAtPoint(float x, float a, float b) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = min(max_param_a, max(min_param_a, a));  \n  b = min(max_param_b, max(min_param_b, b)); \n  \n  float A = (1.-b)/(1.-a) - (b/a);\n  float B = (A*(a*a)-b)/a;\n  float y = A*(x*x) - B*(x);\n  y = min(1.,max(0.,y)); \n  \n  return y;\n}\n\n\n\n\n\n\n\n\n// Exponential shaping functions\n// http://www.flong.com/archive/texts/code/shapers_exp/index.html\n//------------------------------------------------------------------------------------------------------------\n\n// Exponential Ease-in and Ease-out\n// a varies the function from an ease out form to an ease in form\nfloat exponentialEase(float x, float a) {\n    float min_param_a = 0. + epsilon;\n    float max_param_a = 1. - epsilon;\n    a = max(min_param_a, min(max_param_a, a));\n    \n    if (a < 0.5)\n        return pow(x, 2.*a);\n    else\n        return pow(x, 1./(1.-(2.*(a-.5))));\n}\n\n// Double Exponential Seat\n// better derivatives than cubic, a from (0, 1)\nfloat doubleExpSeat(float x, float a) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  a = min(max_param_a, max(min_param_a, a)); \n\n  if (x <= 0.5)\n    return (pow(2.0*x, 1.-a))/2.0;\n  else\n    return 1.0 - (pow(2.0*(1.0-x), 1.-a))/2.0;\n}\n\n// Double Exponential Sigmoid\n// useful for adjustable-contrast functions, approximates raised inverted cosine to within 1% with a = 0.426\nfloat doubleExpSigmoid(float x, float a) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  a = min(max_param_a, max(min_param_a, a));\n  a = 1.0-a; // for sensible results\n  \n  if (x <= 0.5)\n    return (pow(2.0*x, 1.0/a))/2.0;\n  else\n    return 1.0 - (pow(2.0*(1.0-x), 1.0/a))/2.0;\n}\n\n// Logistic Sigmoid\n// can represent the growth of organic populations/ other natural phenomena. Often used for weighting \n// signal-response functions in neural networks. param a regulates the slope/ growth rate of the sigmoid\n// during its rise. a = 0 leads to y = x. Expensive to calculate. \nfloat logisticSigmoid(float x, float a) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  a = max(min_param_a, min(max_param_a, a));\n  a = (1./(1.-a) - 1.);\n\n  float A = 1.0 / (1.0 + exp(0. -((x-0.5)*a*2.0)));\n  float B = 1.0 / (1.0 + exp(a));\n  float C = 1.0 / (1.0 + exp(0.-a)); \n  float y = (A-B)/(C-B);\n  return y;\n}\n\n\n\n\n\n\n\n\n// Circular and Elliptical Shaping Functions\n// http://www.flong.com/archive/texts/code/shapers_circ/index.html\n//------------------------------------------------------------------------------------------------------------\n\nfloat circularEaseIn (float x){\n  float y = 1. - sqrt(1. - x*x);\n  return y;\n}\n\nfloat circularEaseOut (float x){\n  float y = sqrt(1. - sq(1. - x));\n  return y;\n}\n\n// Double Circle Seat\n// param a [0, 1] governs the location of the horizontal tangent\nfloat doubleCircleSeat(float x, float a) {\n    float min_param_a = 0.;\n    float max_param_a = 1.;\n    a = max(min_param_a, min(max_param_a, a));\n    \n    if (x <= a)\n        return sqrt(sq(a) - sq(x - a));\n    else\n        return 1. - sqrt(sq(1.-a) - sq(x-a));\n}\n\n// Double Circle Sigmoid\n// two circular arts meet at a vertical tangent \nfloat doubleCircleSigmoid(float x, float a) {\n    float min_param_a = 0.0;\n    float max_param_a = 1.0;\n    a = max(min_param_a, min(max_param_a, a));\n    \n    if (x <= a) \n        return a - sqrt(a*a - x*x);\n    else\n        return a + sqrt(sq(1.-a) - sq(x-1.));\n}\n\n\n// Double Elliptic Seat\n// double circle seat meeting at coord (a,b)\nfloat doubleEllipticSeat(float x, float a, float b) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = max(min_param_a, min(max_param_a, a)); \n  b = max(min_param_b, min(max_param_b, b)); \n\n  float y = 0.;\n  if (x<=a){\n    y = (b/a) * sqrt(sq(a) - sq(x-a));\n  } else {\n    y = 1. - ((1.-b)/(1.-a))*sqrt(sq(1.-a) - sq(x-a));\n  }\n  return y;\n}\n\n// Double Elliptic Sigmoid\n// double circle sigmoid meeting at coord (a,b)\nfloat doubleEllipticSigmoid(float x, float a, float b) {\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0;\n  float max_param_b = 1.0;\n  a = max(min_param_a, min(max_param_a, a)); \n  b = max(min_param_b, min(max_param_b, b));\n \n  float y = 0.;\n  if (x<=a){\n    y = b * (1. - (sqrt(sq(a) - sq(x))/a));\n  } else {\n    y = b + ((1.-b)/(1.-a))*sqrt(sq(1.-a) - sq(x-1.));\n  }\n  return y;\n}\n\n// Double-Linear with Circular Fillet\n// joins two straight lines with a circular arc whose radius is adjustable. param R is the radius, \n// coord of intersection is (a, b). Adapted from Robert D. Miller in Graphics Gems III\nfloat arcStartAngle;\nfloat arcEndAngle;\nfloat arcStartX,  arcStartY;\nfloat arcEndX,    arcEndY;\nfloat arcCenterX, arcCenterY;\nfloat arcRadius;\nvoid computeFilletParameters (\n  float p1x, float p1y, \n  float p2x, float p2y, \n  float p3x, float p3y, \n  float p4x, float p4y,\n  float r);\nfloat linetopoint (float a, float b, float c, float ptx, float pty);\n\n//--------------------------------------------------------\nfloat circularFillet (float x, float a, float b, float R){\n  \n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0 + epsilon;\n  float max_param_b = 1.0 - epsilon;\n  a = max(min_param_a, min(max_param_a, a)); \n  b = max(min_param_b, min(max_param_b, b)); \n\n  computeFilletParameters (0., 0., a, b, a, b, 1., 1.,  R);\n  float t = 0.;\n  float y = 0.;\n  x = max(0., min(1., x));\n  \n  if (x <= arcStartX){\n    t = x / arcStartX;\n    y = t * arcStartY;\n  } else if (x >= arcEndX){\n    t = (x - arcEndX)/(1. - arcEndX);\n    y = arcEndY + t*(1. - arcEndY);\n  } else {\n    if (x >= arcCenterX){\n      y = arcCenterY - sqrt(sq(arcRadius) - sq(x-arcCenterX)); \n    } else{\n      y = arcCenterY + sqrt(sq(arcRadius) - sq(x-arcCenterX)); \n    }\n  }\n  return y;\n}\n\n//------------------------------------------\n// Return signed distance from line Ax + By + C = 0 to point P.\nfloat linetopoint (float a, float b, float c, float ptx, float pty){\n  float lp = 0.0;\n  float d = sqrt((a*a)+(b*b));\n  if (d != 0.0){\n    lp = (a*ptx + b*pty + c)/d;\n  }\n  return lp;\n}\n\n//------------------------------------------\n// Compute the parameters of a circular arc \n// fillet between lines L1 (p1 to p2) and\n// L2 (p3 to p4) with radius R.  \n// \nvoid computeFilletParameters (\n  float p1x, float p1y, \n  float p2x, float p2y, \n  float p3x, float p3y, \n  float p4x, float p4y,\n  float r) {\n\n  float c1   = p2x*p1y - p1x*p2y;\n  float a1   = p2y-p1y;\n  float b1   = p1x-p2x;\n  float c2   = p4x*p3y - p3x*p4y;\n  float a2   = p4y-p3y;\n  float b2   = p3x-p4x;\n  if ((a1*b2) == (a2*b1)) {  /* Parallel or coincident lines */\n    return;\n  }\n\n  float d1, d2;\n  float mPx, mPy;\n  mPx = (p3x + p4x)/2.0;\n  mPy = (p3y + p4y)/2.0;\n  d1 = linetopoint(a1,b1,c1,mPx,mPy);  /* Find distance p1p2 to p3 */\n  if (d1 == 0.0) {\n    return; \n  }\n  mPx = (p1x + p2x)/2.0;\n  mPy = (p1y + p2y)/2.0;\n  d2 = linetopoint(a2,b2,c2,mPx,mPy);  /* Find distance p3p4 to p2 */\n  if (d2 == 0.0) {\n    return; \n  }\n\n  float c1p, c2p, d;\n  float rr = r;\n  if (d1 <= 0.0) {\n    rr= -rr;\n  }\n  c1p = c1 - rr*sqrt((a1*a1)+(b1*b1));  /* Line parallel l1 at d */\n  rr = r;\n  if (d2 <= 0.0) {\n    rr = -rr;\n  }\n  c2p = c2 - rr*sqrt((a2*a2)+(b2*b2));  /* Line parallel l2 at d */\n  d = (a1*b2)-(a2*b1);\n\n  float pCx = (c2p*b1-c1p*b2)/d; /* Intersect constructed lines */\n  float pCy = (c1p*a2-c2p*a1)/d; /* to find center of arc */\n  float pAx = 0.;\n  float pAy = 0.;\n  float pBx = 0.;\n  float pBy = 0.;\n  float dP,cP;\n\n  dP = (a1*a1) + (b1*b1);        /* Clip or extend lines as required */\n  if (dP != 0.0) {\n    cP = a1*pCy - b1*pCx;\n    pAx = (-a1*c1 - b1*cP)/dP;\n    pAy = ( a1*cP - b1*c1)/dP;\n  }\n  dP = (a2*a2) + (b2*b2);\n  if (dP != 0.0) {\n    cP = a2*pCy - b2*pCx;\n    pBx = (-a2*c2 - b2*cP)/dP;\n    pBy = ( a2*cP - b2*c2)/dP;\n  }\n\n  float gv1x = pAx-pCx; \n  float gv1y = pAy-pCy;\n  float gv2x = pBx-pCx; \n  float gv2y = pBy-pCy;\n\n  float arcStart = atan(gv1y, gv1x); // may need to swap these\n  float arcAngle = 0.0;\n  float dd = sqrt(((gv1x*gv1x)+(gv1y*gv1y)) * ((gv2x*gv2x)+(gv2y*gv2y)));\n  if (dd != 0.0) {\n    arcAngle = (acos((gv1x*gv2x + gv1y*gv2y)/dd));\n  } \n  float crossProduct = (gv1x*gv2y - gv2x*gv1y);\n  if (crossProduct < 0.0) { \n    arcStart -= arcAngle;\n  }\n\n  float arc1 = arcStart;\n  float arc2 = arcStart + arcAngle;\n  if (crossProduct < 0.0) {\n    arc1 = arcStart + arcAngle;\n    arc2 = arcStart;\n  }\n\n  arcCenterX    = pCx;\n  arcCenterY    = pCy;\n  arcStartAngle = arc1;\n  arcEndAngle   = arc2;\n  arcRadius     = r;\n  arcStartX     = arcCenterX + arcRadius*cos(arcStartAngle);\n  arcStartY     = arcCenterY + arcRadius*sin(arcStartAngle);\n  arcEndX       = arcCenterX + arcRadius*cos(arcEndAngle);\n  arcEndY       = arcCenterY + arcRadius*sin(arcEndAngle);\n}\n\n// Circular Arc through a point\n// not every point in a unit square works, works best around the diaganol. Adapted from Paul Bourke's\n// Equation of a Circle From 3 Points\nfloat m_Centerx;\nfloat m_Centery;\nfloat m_dRadius;\nvoid calcCircleFrom3Points(float pt1x, float pt1y, float pt2x, float pt2y, float pt3x, float pt3y);\nbool IsPerpendicular(float pt1x, float pt1y, float pt2x, float pt2y, float pt3x, float pt3y);\nvoid calcCircleFrom3Points(float pt1x, float pt1y, float pt2x, float pt2y, float pt3x, float pt3y);\n\n\nfloat circularArcAtPoint (float x, float a, float b){  \n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  float min_param_b = 0.0 + epsilon;\n  float max_param_b = 1.0 - epsilon;\n  a = min(max_param_a, max(min_param_a, a));\n  b = min(max_param_b, max(min_param_b, b));\n  x = min(1.0-epsilon, max(0.0+epsilon, x));\n  \n  float pt1x = 0.;\n  float pt1y = 0.;\n  float pt2x = a;\n  float pt2y = b;\n  float pt3x = 1.;\n  float pt3y = 1.;\n\n  if (!IsPerpendicular(pt1x,pt1y, pt2x,pt2y, pt3x,pt3y))\t\t\n     calcCircleFrom3Points (pt1x,pt1y, pt2x,pt2y, pt3x,pt3y);\t\n  else if (!IsPerpendicular(pt1x,pt1y, pt3x,pt3y, pt2x,pt2y))\t\t\n     calcCircleFrom3Points (pt1x,pt1y, pt3x,pt3y, pt2x,pt2y);\t\n  else if (!IsPerpendicular(pt2x,pt2y, pt1x,pt1y, pt3x,pt3y))\t\t\n     calcCircleFrom3Points (pt2x,pt2y, pt1x,pt1y, pt3x,pt3y);\t\n  else if (!IsPerpendicular(pt2x,pt2y, pt3x,pt3y, pt1x,pt1y))\t\t\n     calcCircleFrom3Points (pt2x,pt2y, pt3x,pt3y, pt1x,pt1y);\t\n  else if (!IsPerpendicular(pt3x,pt3y, pt2x,pt2y, pt1x,pt1y))\t\t\n     calcCircleFrom3Points (pt3x,pt3y, pt2x,pt2y, pt1x,pt1y);\t\n  else if (!IsPerpendicular(pt3x,pt3y, pt1x,pt1y, pt2x,pt2y))\t\t\n     calcCircleFrom3Points (pt3x,pt3y, pt1x,pt1y, pt2x,pt2y);\t\n  else { \n    return 0.;\n  }\n\n  // constrain\n  if ((m_Centerx > 0.) && (m_Centerx < 1.)) {\n     if (a < m_Centerx) {\n       m_Centerx = 1.;\n       m_Centery = 0.;\n       m_dRadius = 1.;\n     } else {\n       m_Centerx = 0.;\n       m_Centery = 1.;\n       m_dRadius = 1.;\n     }\n  }\n  \n  float y = 0.;\n  if (x >= m_Centerx) {\n    y = m_Centery - sqrt(sq(m_dRadius) - sq(x-m_Centerx)); \n  } else {\n    y = m_Centery + sqrt(sq(m_dRadius) - sq(x-m_Centerx)); \n  }\n  return y;\n}\n\n//----------------------\nbool IsPerpendicular(float pt1x, float pt1y, float pt2x, float pt2y, float pt3x, float pt3y)\n{\n  // Check the given point are perpendicular to x or y axis \n  float yDelta_a = pt2y - pt1y;\n  float xDelta_a = pt2x - pt1x;\n  float yDelta_b = pt3y - pt2y;\n  float xDelta_b = pt3x - pt2x;\n  float epsilon2 = 0.000001;\n\n  // checking whether the line of the two pts are vertical\n  if (abs(xDelta_a) <= epsilon2 && abs(yDelta_b) <= epsilon2){\n    return false;\n  }\n  if (abs(yDelta_a) <= epsilon2) {\n    return true;\n  }\n  else if (abs(yDelta_b) <= epsilon2) {\n    return true;\n  }\n  else if (abs(xDelta_a)<= epsilon2) {\n    return true;\n  }\n  else if (abs(xDelta_b)<= epsilon2) {\n    return true;\n  }\n  else return false;\n}\n\n//--------------------------\nvoid calcCircleFrom3Points(float pt1x, float pt1y, float pt2x, float pt2y, float pt3x, float pt3y)\n{\n    float yDelta_a = pt2y - pt1y;\n    float xDelta_a = pt2x - pt1x;\n    float yDelta_b = pt3y - pt2y;\n    float xDelta_b = pt3x - pt2x;\n    float epsilon2 = 0.000001;\n\n    if (abs(xDelta_a) <= epsilon2 && abs(yDelta_b) <= epsilon2){\n        m_Centerx = 0.5*(pt2x + pt3x);\n        m_Centery = 0.5*(pt1y + pt2y);\n        m_dRadius = sqrt(sq(m_Centerx-pt1x) + sq(m_Centery-pt1y));\n        return;\n    }\n\n    // IsPerpendicular() assure that xDelta(s) are not zero\n    float aSlope = yDelta_a / xDelta_a; \n    float bSlope = yDelta_b / xDelta_b;\n    if (abs(aSlope-bSlope) <= epsilon2) {\t\n        // checking whether the given points are colinear. \t\n        return;\n    }\n\n    // calc center\n    m_Centerx = (\n        aSlope*bSlope*(pt1y - pt3y) + \n        bSlope*(pt1x + pt2x) - \n        aSlope*(pt2x+pt3x) )\n        /(2.* (bSlope-aSlope));\n    m_Centery = -1.*(m_Centerx - (pt1x+pt2x)/2.)/aSlope +  (pt1y+pt2y)/2.;\n    m_dRadius = sqrt(sq(m_Centerx-pt1x) + sq(m_Centery-pt1y));\n}\n\n\n\n\n\n\n\n\n// Bezier and Other Parametric Shaping Functions\n// http://www.flong.com/archive/texts/code/shapers_bez/index.html\n//------------------------------------------------------------------------------------------------------------\n\n// Quadratic Bezier\n// 2nd order bezier with a single spline control point at (a,b). Same rates of change/ slope at its endpoints\nfloat quadraticBezier(float x, float a, float b) {\n    a = max(0., min(1., a)); \n    b = max(0., min(1., b)); \n    if (a == 0.5){\n        a += epsilon;\n    }\n    // solve t from x (an inverse operation)\n    float om2a = 1. - 2.*a;\n    float t = (sqrt(a*a + om2a*x) - a)/om2a;\n    float y = (1.-2.*b)*(t*t) + (2.*b)*t;\n    return y;   \n}\n\n// Cubic Bezier\nfloat slopeFromT (float t, float A, float B, float C);\nfloat xFromT (float t, float A, float B, float C, float D);\nfloat yFromT (float t, float E, float F, float G, float H);\n\nfloat cubicBezier (float x, float a, float b, float c, float d){\n    float y0a = 0.00; // initial y\n    float x0a = 0.00; // initial x \n    float y1a = b;    // 1st influence y   \n    float x1a = a;    // 1st influence x \n    float y2a = d;    // 2nd influence y\n    float x2a = c;    // 2nd influence x\n    float y3a = 1.00; // final y \n    float x3a = 1.00; // final x \n\n    float A =   x3a - 3.*x2a + 3.*x1a - x0a;\n    float B = 3.*x2a - 6.*x1a + 3.*x0a;\n    float C = 3.*x1a - 3.*x0a;   \n    float D =   x0a;\n\n    float E =   y3a - 3.*y2a + 3.*y1a - y0a;    \n    float F = 3.*y2a - 6.*y1a + 3.*y0a;             \n    float G = 3.*y1a - 3.*y0a;             \n    float H =   y0a;\n\n    // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n    // Assume for the first guess that t = x.\n    float currentt = x;\n    int nRefinementIterations = 5;\n    for (int i=0; i < nRefinementIterations; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n        currentt = clamp(currentt, 0., 1.);\n    } \n\n    float y = yFromT (currentt,  E,F,G,H);\n    return y;\n}\n\n// Helper functions:\nfloat slopeFromT (float t, float A, float B, float C) {\n    float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n    return dtdx;\n}\n\nfloat xFromT (float t, float A, float B, float C, float D) {\n    float x = A*(t*t*t) + B*(t*t) + C*t + D;\n    return x;\n}\n\nfloat yFromT (float t, float E, float F, float G, float H) {\n    float y = E*(t*t*t) + F*(t*t) + G*t + H;\n    return y;\n}\n\n// Cubic Bezier (nearly) at two points\n\n// Helper functions. \nfloat B0 (float t){\n    return (1.-t)*(1.-t)*(1.-t);\n}\nfloat B1 (float t){\n    return  3.*t* (1.-t)*(1.-t);\n}\nfloat B2 (float t){\n    return 3.*t*t* (1.-t);\n}\nfloat B3 (float t){\n    return t*t*t;\n}\nfloat  findx (float t, float x0, float x1, float x2, float x3){\n    return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n}\nfloat  findy (float t, float y0, float y1, float y2, float y3){\n    return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n}\n\nfloat cubicBezierAt(float x, float a, float b, float c, float d) {\n    float y = 0.;\n    float min_param_a = 0.0 + epsilon;\n    float max_param_a = 1.0 - epsilon;\n    float min_param_b = 0.0 + epsilon;\n    float max_param_b = 1.0 - epsilon;\n    a = max(min_param_a, min(max_param_a, a));\n    b = max(min_param_b, min(max_param_b, b));\n\n    float x0 = 0.;  \n    float y0 = 0.;\n    float x4 = a;  \n    float y4 = b;\n    float x5 = c;  \n    float y5 = d;\n    float x3 = 1.;  \n    float y3 = 1.;\n    float x1,y1,x2,y2; // to be solved.\n\n    // arbitrary but reasonable \n    // t-values for interior control points\n    float t1 = 0.3;\n    float t2 = 0.7;\n\n    float B0t1 = B0(t1);\n    float B1t1 = B1(t1);\n    float B2t1 = B2(t1);\n    float B3t1 = B3(t1);\n    float B0t2 = B0(t2);\n    float B1t2 = B1(t2);\n    float B2t2 = B2(t2);\n    float B3t2 = B3(t2);\n\n    float ccx = x4 - x0*B0t1 - x3*B3t1;\n    float ccy = y4 - y0*B0t1 - y3*B3t1;\n    float ffx = x5 - x0*B0t2 - x3*B3t2;\n    float ffy = y5 - y0*B0t2 - y3*B3t2;\n\n    x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n    y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n    x1 = (ccx - x2*B2t1) / B1t1;\n    y1 = (ccy - y2*B2t1) / B1t1;\n\n    x1 = max(0.+epsilon, min(1.-epsilon, x1));\n    x2 = max(0.+epsilon, min(1.-epsilon, x2));\n\n    // Note that this function also requires cubicBezier()!\n    y = cubicBezier (x, x1,y1, x2,y2);\n    y = max(0., min(1., y));\n    return y;\n}\n\n\n\n\n\n// Inigo Quilez Useful Functions\n// https://iquilezles.org/articles/functions\n\n// Almost Identity\n// smoothly blend a value against a lowerbound, anything above m remains unchanged,\n// n is the value to be taken when input is zero\nfloat almostIdentity(float x, float m, float n) {\n    if (x > m) return x;\n    float a = 2.*n - m;\n    float b = 2.*m - 3.*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\n// Almost Unit Identity\n// maps the unit interval, 0 deriv at origin and 1 deriv at 1. Ideal for transitioning from stationary to motion,\n// equivalent to almostIdentity(x, 1, 0)\nfloat almostIdentity(float x) {\n    return x*x*(2.-x);\n}\n\n// Almost Identity II\n// not as fast as cubics above, can also be used as a smooth-abs(), has a zero derivative, but has a non zero second\n// derivative\nfloat almostIdentity(float x, float n) {\n    return sqrt(x*x+n);\n}\n\n// Exponential Impulse\n// great for triggering behaviours or envelopes for music or animation or anything that grows fast then slowly decays.\n// use k to control the stretching of the function. its maximum of 1 is at x = 1/k\nfloat expImpulse(float x, float k) {\n    float h = k*x;\n    return h*exp(1.-h);\n}\n\n// Sustained Impulse\nfloat expSustainImpulse(float x, float f, float k) {\n    float s = max(x - f, .0);\n    return min(x*x/ (f*f), 1. + (2./f) * s * exp(-k*s));\n}\n\n// Polynomial Impulse\n// peaks at x = sqrt(1/k)\nfloat quaImpulse(float k, float x) {\n    return 2.0*sqrt(k)*x/(1.0+k*x*x);\n}\n// n is the degree of the polynomial \nfloat polyImpulse(float k, float n, float x) {\n    return (n/(n-1.0))*pow((n-1.0)*k,1.0/n) * x/(1.0+k*pow(x,n));\n}\n\n// Cubic Pulse\n// smoothstep(c-w,c,x)-smoothstep(c,c+w,x) replaces this since it isolates some features in a signal, \n// replaces a gaussian as well\nfloat cubicPulse(float c, float w, float x) {\n    x = abs(x - c);\n    if(x>w) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// Exponential Step\n// the higher the power n, the sharper s shaped curve you get until you get step()\nfloat expStep(float x, float k, float n) {\n    return exp(-k*pow(x,n));\n}\n\n// Gain\n// remaps the unit interval by expanding the sides and compressing the center (0.5 maps to 0.5). k=1 is the identity curve, k<1\n// produces classic gain shape, k>1 produces s curves. symmetric and inverse for k=a and k=1/a\nfloat gain(float x, float k) {\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// Parabola\n// maps x = 0, x = 1 to 0 and x = 0.5 to 1\nfloat parabola(float x, float k) {\n    return pow(4.0*x*(1.0-x), k);\n}\n\n// Power Curve\n// generalization of parabola, except a controls shape of left side of curve and b controls shape of the right side.\n// slow calculation of k ensures the curve's max is at 1\nfloat pcurve_uniform(float x, float a, float b) {\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow(x,a) * pow(1.0-x, b);\n}\n\n// Power Curve\nfloat pcurve(float x, float a, float b) {\n    return pow(x,a) * pow(1.0-x, b);\n}\n\n// Sinc Curve\n// phase shifted sinc curve, can be useful for bouncing behaviours, k increases num of bounces\nfloat sinc(float x, float k) {\n    float a = PI*(k*x-1.0);\n    return sin(a)/a;\n}\n","name":"Common","description":"","type":"common"}]}