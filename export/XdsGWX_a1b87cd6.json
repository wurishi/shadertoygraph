{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"mat4 LUT  = mat4( 0.  ,0.  ,0. ,0.,\n\t\t\t\t  0.2,0.1,0.1 ,1.,\n\t\t\t\t  1. , 0.0  ,0.1,1.,\n\t\t\t\t  1.  ,0.8  ,0.4 ,1.);\n#define LUT_DIST vec4(0.,0.33,0.67,1.)\n#define NB_LUT 4\n\nvec4 mapping(float dist, float min, float max){\t\n\t\n\tfloat distLut = (dist - min) / (max - min);\n\tint i1;\n\tfor(int i=0;i <NB_LUT;++i){\n\t\tif(distLut < LUT_DIST[i+1]){i1 = i;break;}\n\t}\n\tvec4 col1,col2;\n\tfloat mixVal;\n\tif\t\t(i1 == 0){\n\t\tcol1 = LUT[0];col2 = LUT[1];\n\t\tmixVal = (distLut - LUT_DIST[0]) / (LUT_DIST[1] - LUT_DIST[0]);\n\t}else if(i1 == 1){\n\t\tcol1 = LUT[1];col2 = LUT[2];\n\t\tmixVal = (distLut - LUT_DIST[1]) / (LUT_DIST[2] - LUT_DIST[1]);\n\t}else{\n\t\tcol1 = LUT[2];col2 = LUT[3];\n\t\tmixVal = (distLut - LUT_DIST[2]) / (LUT_DIST[3] - LUT_DIST[2]);\n\t}\n\t\n\t\n\t//return vec4(mixVal);\n\treturn mix(col1,col2,mixVal);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = mapping(uv.x, 0.0, 1.0);\n\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdsGWX","date":"1380644144","viewed":1322,"name":"Color LUT Mapping","username":"baccanno","description":"Simple base shader for color mapping. Trick done with mat4 and vec4 because constant array are not supported by GLSL ES. Could be done with a uniforme on regular environments.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["colormapping"],"hasliked":0,"parentid":"","parentname":""}}