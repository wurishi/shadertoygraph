{"ver":"0.1","info":{"id":"4l23WR","date":"1428116480","viewed":213,"name":"Nat's Perlin Noise Shader","username":"NattyBumppo","description":"My attempt at making Perlin noise.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Number of cells in a row/column\nint numCellsHorizontal = 100;\nint numCellsVertical = 80;\n\n// Cell dimensions\nfloat cellWidth;\nfloat cellHeight;\n\n// Turns on a mode where negative noise values\n// are always high rather than low\nbool stainedGlassMode = false;\n\n// Turns on a mode where the colors \"breathe\" by\n// the negative noise values going up and down\nbool glowMode = true;\n\n// Turns on a mode where the colors cycle\nbool cycleMode = true;\n\n// Turns on a mode where the noise moves slightly\nbool lifeMode = false;\n\n// Turns on interpolation via a quintic smoothing function\nbool smoothQuinticMode = false;\n\n// Turns on cosine interpolation\nbool coserpMode = true;\n\n// Frequency of cycling in cycle mode\nfloat redCycleFreq = 0.4;\nfloat greenCycleFreq = 0.2;\nfloat blueCycleFreq = 0.25;\n\nfloat gradOffset = 1.0;\n\n// This generates a pseudorandom number based on the seed, which is the\n// cell row and column (so that corner points have consistent gradients in\n// each of the cells in which they're present).\n// Adapted from\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nfloat rand(vec2 seed)\n{\n    // Augmenting the values by a small delta\n    // gets rid of a bug where zero seeds will result\n    // in a random number of zero\n    seed.x += 0.23434;\n    seed.y += 0.12424;\n       \n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(seed.xy, vec2(a,b));\n    highp float sn = mod(dt, 3.14159);\n    highp float fractionalPart = fract(sin(sn) * c);\n    \n    // A little fix for the terrible power of zero\n    if (fractionalPart == 0.0)\n    {\n        fractionalPart = 3.14159;    \n    }\n    \n    // Add a random-ish sign, too\n    float sign;\n    if (fractionalPart < 0.5)\n    {\n        sign = 1.0;\n    }\n    else\n    {\n        sign = -1.0;\n    }\n    \n    return fractionalPart * sign;\n}\n\n// Given a screen coordinate, returns which row it's in\nint getCellRow(vec2 uv)\n{\n    return int(floor(float(numCellsVertical) * (float(uv.y) / float(iResolution.y))));\n}\n\n// Given a screen coordinate, returns which column it's in\nint getCellCol(vec2 uv)\n{\n    return int(floor(float(numCellsHorizontal) * (float(uv.x) / float(iResolution.x))));    \n}\n\n// Get a pseudo-random gradient vector, based on the current fragment\n// coordinates and the local cell coordinates of the grid coordinate\n// in question.\nvec2 getGradient(vec2 uv, vec2 xy)\n{\n    // Find which cell we're in\n    int cellRow = getCellRow(uv);\n    int cellCol = getCellCol(uv);\n\n;\n    \n    // Fix edges, in order to make sure that the gradient\n    // at x=1.0 for one cell is the same as the gradient\n    // for the cell to the left at x=-1.0, etc.\n    if (xy.x == 1.0)\n    {\n        cellCol++;\n    }\n    if (xy.y == 1.0)\n    {\n        cellRow++;\n    }\n\n    // Get random offset for gradient magnitude\n    // that depends on elapsed time and cell position\n    gradOffset = rand(vec2(cellCol, cellRow)*2.0) * cos(iTime * 0.1);\n    \n    // Get a pseudo-random choice for a gradient, taking into account\n    // the position of the cell, and the fact that we want one point\n    // to have the same value when serving as a corner for multiple cells\n    float gradientX = rand(vec2(cellRow, cellCol));\n    float gradientY = rand(vec2(cellCol, cellRow));\n\n    if (lifeMode)\n    {\n        gradientX += gradOffset;   \n        gradientY += gradOffset;\n    }\n    \n    vec2 gradient = vec2(gradientX, gradientY);\n    gradient = normalize(gradient);\n    \n    return gradient;\n}\n\n// Uses a smoothed quintic interpolation (using an ease function)\n// to output the interpolated value, where weight ranges from\n// 0.0 to 1.0.\nfloat smoothQuintic(float startPoint, float endPoint, float weight)\n{    \n    // Get the value that would be produced with regular linear interpolation\n    float diff = endPoint - startPoint;\n    float linVal = startPoint + weight * diff;\n    \n    // Get the equivalent value from the ease function\n    float smoothedVal;\n    if (linVal < 0.0)\n    {\n        linVal *= -1.0;\n        smoothedVal = -(6.0 * pow(linVal, 5.0) - 15.0 * pow(linVal, 4.0) + 10.0 * pow(linVal, 3.0));\n    }\n    else\n    {\n        smoothedVal = 6.0 * pow(linVal, 5.0) - 15.0 * pow(linVal, 4.0) + 10.0 * pow(linVal, 3.0);\n    }\n    \n    return smoothedVal;\n}\n\n// Linear interpolation\nfloat lerp(float startPoint, float endPoint, float weight)\n{\n    float diff = endPoint - startPoint;\n    float linVal = startPoint + weight * diff;\n\n    return linVal;\n}\n\n\n// Cosine interpolation\nfloat coserp(float startPoint, float endPoint, float weight)\n{\n\n    float cosWeight = (1.0 - cos(weight * 3.14159)) * 0.5;\n    \n    return startPoint * (1.0 - cosWeight) + endPoint * cosWeight;\n}\n\n// Finds the Perlin weight at a given coordinate\nfloat getPerlinWeight(vec2 uv)\n{\n    // First get the gradient values for each corner of the cell\n    vec2 grad0 = getGradient(uv, vec2(-1.0, -1.0));\n    vec2 grad1 = getGradient(uv, vec2(-1.0, 1.0));\n    vec2 grad2 = getGradient(uv, vec2(1.0, -1.0));\n    vec2 grad3 = getGradient(uv, vec2(1.0, 1.0));\n    \n    // Let's also get the absolute coordinates of each cell corner,\n    // to make calculating the distance easier\n    vec2 pos0 = vec2(float(getCellCol(uv)) * cellWidth, float(getCellRow(uv)) * cellHeight);\n    vec2 pos1 = vec2(float(getCellCol(uv)) * cellWidth, float(getCellRow(uv)+1) * cellHeight);\n    vec2 pos2 = vec2(float(getCellCol(uv)+1) * cellWidth, float(getCellRow(uv)) * cellHeight);\n    vec2 pos3 = vec2(float(getCellCol(uv)+1) * cellWidth, float(getCellRow(uv)+1) * cellHeight);\n    \n    vec2 distVec0 = vec2((uv.x - pos0.x) / cellWidth, (uv.y - pos0.y) / cellHeight) / sqrt(2.0);\n    vec2 distVec1 = vec2((uv.x - pos1.x) / cellWidth, (uv.y - pos1.y) / cellHeight) / sqrt(2.0);\n    vec2 distVec2 = vec2((uv.x - pos2.x) / cellWidth, (uv.y - pos2.y) / cellHeight) / sqrt(2.0);\n    vec2 distVec3 = vec2((uv.x - pos3.x) / cellWidth, (uv.y - pos3.y) / cellHeight) / sqrt(2.0);\n\n    // Now, find the influence of each cell corner by taking the dot product of the\n    // distance and the gradient\n    float influence0 = dot(grad0, distVec0);\n    float influence1 = dot(grad1, distVec1);\n    float influence2 = dot(grad2, distVec2);\n    float influence3 = dot(grad3, distVec3);\n    \n    // One more thing we need: the position of this fragment in its cell's coordinates\n    vec2 uvCell;\n    uvCell.x = (float(uv.x) - float(getCellCol(uv)) * cellWidth) / cellWidth;\n    uvCell.y = (float(uv.y) - float(getCellRow(uv)) * cellHeight) / cellHeight;\n    \n    // Now, interpolate to get a weighted average of this particular\n    // point's value going both horizontally and vertically\n    float topWeight, bottomWeight, weight;\n    if (smoothQuinticMode)\n    {\n        // Perform higher-order interpolation\n        topWeight = smoothQuintic(influence1, influence3, uvCell.x);\n        bottomWeight = smoothQuintic(influence0, influence2, uvCell.x);\n        weight = smoothQuintic(bottomWeight, topWeight, uvCell.y);        \n    }\n    else if (coserpMode)\n    {\n        // Perform cosine interpolation\n        topWeight = coserp(influence1, influence3, uvCell.x);\n        bottomWeight = coserp(influence0, influence2, uvCell.x);\n        weight = coserp(bottomWeight, topWeight, uvCell.y);            \n    }\n    else\n    {\n        // Perform regular linear interpolation\n        topWeight = lerp(influence1, influence3, uvCell.x);\n        bottomWeight = lerp(influence0, influence2, uvCell.x);\n        weight = lerp(bottomWeight, topWeight, uvCell.y);        \n    }\n\n    \n    return weight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    cellWidth = float(iResolution.x) / float(numCellsHorizontal);\n    cellHeight = float(iResolution.y) / float(numCellsVertical);\n    \n    float intensity = getPerlinWeight(fragCoord.xy);\n    \n    // The intensity value will be between -1 and 1; let's\n    // display these two cases using [0.0, 0.5] for negative\n    // and [0.5, 1.0] for positive\n    if (intensity < 0.0)\n    {\n        if (stainedGlassMode)\n        {\n            // Display the negative intensities as bright,\n            // starting at 0.5 intensity\n            intensity = 0.5 - 0.5 * intensity;\n        }\n        else if (glowMode)\n        {\n            // Make the negative intensities cycle\n            // from no intensity to stainedGlass intensity\n            intensity = 0.5 + 0.5 * cos(iTime) * intensity;\n        }\n        else\n        {\n            // Regular display\n            intensity = 0.5 + 0.5 * intensity;\n        }\n    }\n    else\n    {\n        intensity =  0.5 + 0.5 * intensity;\n    }\n    \n    if (cycleMode)\n    {\n        float redWeight = 0.5 + 0.5 * sin(redCycleFreq*iTime);\n        float greenWeight = 0.5 + 0.5 * sin(greenCycleFreq*iTime + 3.14159 / 4.0);\n        float blueWeight = 0.5 + 0.5 * sin(blueCycleFreq*iTime + 3.14159 / 2.0);\n        \n        fragColor = vec4(redWeight * intensity, greenWeight * intensity, blueWeight * intensity, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, intensity, 1.0);\n    }\n}","name":"","description":"","type":"image"}]}