{"ver":"0.1","info":{"id":"wdlSDX","date":"1552422096","viewed":438,"name":"Sierpinski tree?","username":"saidwho12","description":"A friend sent me something looking similar to this and I thought it looked a lot like a Sierpinski triangle but as a tree. You can move the mouse while clicking horizontally to change depth or vertically to change alpha.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","transparency","sdf","antialiasing","tree","ao","aa","serpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\n#define TAU 6.28\n\nfloat udLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = TAU/repetitions;\n    float r = length(p);\n    float a = atan(p.y, p.x) + /*(.5+.5*cos(iTime))*angle/2. */angle/2. + .15 * sin(5. * iTime - 1.5 * r);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n    vec2 R = iResolution.xy;\n    vec3 p = vec3((u+u-R)/R.y,1);\n    O -= O;\n    O++;\n    \n    float vignette = .8+.2*smoothstep(2.5,.2,length((u+u-R)/R));\n    \n    bool clicked = iMouse.z > 0.;\n    float alpha = clicked ? iMouse.y/R.y : 1.;\n    \n    float X = 10.0;\n    for(float i = -1., N = clicked ? 1.+floor(X*iMouse.x/R.x) : X; ++i < N;) {\n        float x = (i+.5)/N;\n        \n        float angle = pModPolar(p.xy, 3.);\n        //p.xy*=rot(TAU/N*.3*sin(x-iTime));\n    \t\n        float t = udLine(p.xy, vec2(0), vec2(.5,0)) / p.z  - (.0014+.012*pow(1.-x,2.5));\n    \t\n        // Anti-aliasing\n        float s = smoothstep(3./R.y, 0., t);\n        vec4 col = vec4(mix(vec3(.55,.4,.07), vec3(.3,.97,.12), x), pow(1.-x,1.2)*s*alpha);\n        \n        // Ambient occlusion\n        //O.rgb *= 1.-.3*exp(-.25*clamp(t,0.,1.)*R.y)*(1.-s);\n        O.rgb *= 1.-.3*pow(1.-x,3.5)*exp(-(.2-.15*x)*clamp(t,0.,1.)*R.y);\n        \n        // Alpha blending\n        O = (1.-col.a)*O + col.a*col;\n        \n        p += p;\n        //p.x -= scale+.1*texture(iChannel0, vec2(.5)).r;\n        p.x--;\n        //p.x-=fract(iTime);\n    }\n    \n    O.rgb = clamp(O.rgb,0.,1.);\n    //O.rgb *= vignette;\n}","name":"Image","description":"","type":"image"}]}