{"ver":"0.1","info":{"id":"ltsXWj","date":"1439911216","viewed":189,"name":"Cloud 1","username":"darksky505","description":"Attempt to make a cloud shader.\n\nMouse pos moves the position of the \"sun\" giving the yellow color.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float Cloud( vec2 uv , float depth);\nfloat CloudOrder( vec2 uv );\nfloat CloudOne( vec2 uv);\nfloat CloudTwo( vec2 uv);\nfloat CloudThree( vec2 uv);\nfloat CloudFour( vec2 uv);\nfloat CloudFive( vec2 uv);\nfloat CloudSix( vec2 uv);\nfloat CloudSeven( vec2 uv);\n\nfloat Noise( in vec2 p );\nfloat Hash( vec2 p );\n\nfloat GetSunScaler(float mouseScaler, float uv);\n\nfloat Hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat Noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( Hash( i + vec2(0.0,0.0) ), \n                     Hash( i + vec2(1.0,0.0) ), u.x),\n                mix( Hash( i + vec2(0.0,1.0) ), \n                     Hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n vec3 blue = vec3(0.2 , 0.2 ,  0.8);\n vec3 darkBlue = vec3(0.0 , 0.0 ,  0.5);\n\n vec3 white = vec3(1.0 ,1.0 ,1.0);  \n vec3 yellow = vec3(1.0 ,1.0 ,0.0);  \n vec3 grey = vec3(0.5 ,0.5 ,0.5);  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p   = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x /iResolution.y,1.0);\n    \n    float genScaler = CloudOrder(uv);\n        \n \n    float t = genScaler;\n \n    \n    float mouseScalerX = iMouse.x / iResolution.x;\n    float mouseScalerY = iMouse.y / iResolution.y;\n    \n    \n    \n    float sunScaler = (GetSunScaler(mouseScalerX , p.x)  + GetSunScaler(mouseScalerY , p.y )  ) /2.0 ;        \n  \n//vec3 colour = t *blue  +  1.0-t * white;\n    \n    \n    vec3 cloudColour = sunScaler * yellow +  1.0-sunScaler*white;\n    vec4 colour = t * vec4(darkBlue,0)   +  1.0-t *vec4(cloudColour,0);\n\n     //  vec4 colour =  vec4(cloudColour,0)   ;\n    \n    colour.xy *= 0.4;\n   //  colour.x = clamp(colour.x , 0.0  ,1.0 );\n   // colour.y = clamp(colour.y , 0.0  ,1.0 );\n     //colour.z = clamp(colour.z , 0.0  ,1.0 );\n   \n    \n    \n    \n    \n    \n    fragColor =  colour;\n}\n\n\nfloat Cloud( vec2 uv , float depth)\n{\n    float colour = 0.0;\n  //  float bounce  = 0.5 + 0.00000000005*sin(iTime * uv.x );\n    \n   \n    float mouseScalerX = iMouse.x / iResolution.x;\n    float mouseScalerY = iMouse.y / iResolution.y;\n\n    float depthScaler =  (50.0    )/ depth ;\n    \n   uv.x += iTime  * 0.005 ;\n   uv.x += 10.0 + iTime  * 0.0025 * depth ;\n     \n      \n    colour = 4.0*( depth/7.0 ) * Noise(uv * depthScaler   )   ;\n    \n   // colour = clamp(colour , 0.0  ,1.0 );\n     return colour;\n}\n \n\nfloat CloudOrder( vec2 uv)\n{\n     \n  float colour =  Cloud(uv , 1.0) ;\n  const float depth = 15.0;\n  for(float  i = 1.0; i < depth; i++)\n    {\n        colour += Cloud(uv , i) ;\n    }\n    \n    colour =  colour / depth;\n    //colour = clamp(colour , 0.0  ,1.0 );\n    return colour;\n\n}\n\n\nfloat GetSunScaler(float mouseScaler, float uv)\n{\n\tfloat sunScaler = 0.0;\n    \n    if(mouseScaler< uv)        \n    {\n       sunScaler  =  uv -mouseScaler  ; // dsitance \n     }\n    else\n    {\n        sunScaler  = mouseScaler- uv;\n    }\n    \n    return 1.0 - sunScaler;\n}","name":"","description":"","type":"image"}]}