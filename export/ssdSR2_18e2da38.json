{"ver":"0.1","info":{"id":"ssdSR2","date":"1633554160","viewed":889,"name":"Raymarching optimization example","username":"amally","description":"Examples of how to optimize a raymarcher","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set this to 1 to prevent the march from\n// continuing after reaching a predefined max distance.\n// Prevents empty space from slowing down the march.\n#define DIST_LIMIT 0\n\n#define BOUNDING_SPHERE 0\n\n// This function only checks the three sphere SDFs\n// once the query point is inside the bounding volume of\n// a larger sphere that surrounds the three smaller ones\nfloat sceneSDF(vec3 queryPos) \n{\n#if BOUNDING_SPHERE\n    float bounding_sphere_dist = sphereSDF(queryPos,\n                                             vec3(0.),\n                                             2.0);\n    if(bounding_sphere_dist <= EPSILON) {\n        #endif\n        float t = sphereSDF(queryPos,\n                                  vec3(0.0, 0.0, 0.0),\n                                  1.0);\n        for(float i = 0.; i < 200.; ++i) {\n            float c = cos(i * 3.14159 / 100.);\n            float s = sin(i * 3.14159 / 100.);\n            t = min(t, sphereSDF(queryPos,\n                                 vec3(c - s, s + c, 0.),\n                                 0.015));\n        }\n        return t;\n        \n#if BOUNDING_SPHERE\n    }\n    return bounding_sphere_dist;\n    #endif\n}\n\nRay getRay(vec2 uv)\n{\n    Ray r;\n    \n    vec3 look = normalize(ORIGIN - EYE);\n    vec3 camera_RIGHT = normalize(cross(look, WORLD_UP));\n    vec3 camera_UP = cross(camera_RIGHT, look);\n    \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 screen_vertical = camera_UP * tan(FOV); \n    vec3 screen_horizontal = camera_RIGHT * aspect_ratio * tan(FOV);\n    vec3 screen_point = (look + uv.x * screen_horizontal + uv.y * screen_vertical);\n    \n    r.origin = EYE;\n    r.direction = normalize(screen_point - EYE);\n   \n    return r;\n}\n\n\nbool isRayTooLong(vec3 queryPoint, vec3 origin)\n{\n    return length(queryPoint - origin) > MAX_RAY_Z;\n}\n\nIntersection getRaymarchedIntersection(vec2 uv)\n{\n    Ray ray = getRay(uv);\n    Intersection intersection;\n    \n    vec3 queryPoint = ray.origin;\n    int i = 0;\n    while (i < MAX_RAY_STEPS)\n    {\n        #if DIST_LIMIT\n        if(isRayTooLong(queryPoint, ray.origin)) break;\n        #endif\n        \n        float distanceToSurface = sceneSDF(queryPoint);\n        \n        if (distanceToSurface < EPSILON)\n        {\n            \n            intersection.position = queryPoint;\n            intersection.normal = vec3(0.0, 0.0, 1.0);\n            intersection.distance = length(queryPoint - ray.origin);\n            intersection.material_id = i;\n            \n            return intersection;\n        }\n        i++;\n        queryPoint = queryPoint + ray.direction * distanceToSurface;\n    }\n    \n    intersection.distance = -1.0;\n    intersection.material_id = i;\n    return intersection;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getSceneColor(vec2 uv)\n{\n    Intersection intersection = getRaymarchedIntersection(uv);\n    if (intersection.distance > 0.0)\n    {\n        //vec3 light_vec = normalize(LIGHT_DIR - intersection.position); \n        //return vec3(1.0) * max(0.1, dot(light_vec, estimateNormal(intersection.position)));\n    }\n    return vec3(float(intersection.material_id) / float(MAX_RAY_STEPS), 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make symmetric [-1, 1]\n    uv = uv * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = getSceneColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int MAX_RAY_STEPS = 128;\nconst float MAX_RAY_Z = 10.0;\nconst float FOV = 45.0;\nconst float EPSILON = 1e-6;\n\nconst vec3 EYE = vec3(0.0, 0.0, 10.0);\nconst vec3 ORIGIN = vec3(0.0, 0.0, 0.0);\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_RIGHT = vec3(-1.0, 0.0, 0.0);\nconst vec3 WORLD_FORWARD = vec3(0.0, 0.0, 1.0);\nconst vec3 LIGHT_DIR = vec3(-1.0, 1.0, 2.0);\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection \n{\n    vec3 position;\n    vec3 normal;\n    float distance;\n    int material_id;\n};\n\nfloat sphereSDF(vec3 query_position, vec3 position, float radius)\n{\n    return length(query_position - position) - radius;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n","name":"Common","description":"","type":"common"}]}