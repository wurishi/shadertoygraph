{"ver":"0.1","info":{"id":"Dd2GRh","date":"1667219065","viewed":19,"name":"Exercise 8 - Ilia Esmaili Poor","username":"IEP","description":"Practice shader for computer graphics course.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 spherePos = vec3(0,0,-2);\nconst float sphereRadius = 1.0f;\nconst float groundHeight = -0.65f;\nvec3 finalColor = vec3(0,0.7,0.95);\nconst float epsilon = 0.001f;\nfloat sphereFloat;\nfloat groundFloat;\nvec3 p;\nint material;\n\nconst vec3 ambientColor = vec3(0.1,0.15,0.2);\nconst vec3 specularColor = vec3(0.85,0.9,1);\nconst float shininess = 70.0;\nvec3 camPos = vec3(0,0,0);\nconst vec3 lightDirection = vec3(0.45,0.8,0.25);\nconst vec3 lightColor = vec3(0.85,1,1);\nconst float ambientReflectivity = 0.170;\n\nfloat sdf_scene(vec3 point)\n{\n    sphereFloat = length(point - spherePos) - sphereRadius;\n    groundFloat =  point.y - groundHeight;\n    \n    material = 0;\n    float theDistance = 1000.0;\n    if (sphereFloat < theDistance)\n    {\n        material = 1;\n        theDistance = sphereFloat;\n    }\n    if (groundFloat < theDistance)\n    {\n        material = 2;\n        theDistance = groundFloat;\n    }\n    \n    return theDistance;\n}\n\nvec3 calculate_normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(sdf_scene(p + e.xyy) - sdf_scene(p - e.xyy),\n    sdf_scene(p + e.yxy) - sdf_scene(p - e.yxy),\n    sdf_scene(p + e.yyx) - sdf_scene(p - e.yyx)));\n}\n\nvoid DoBlinnPhong(vec3 currentPos)\n{\n   vec3 reflection = reflect(-lightDirection, calculate_normal(currentPos));\n   vec3 view = normalize(camPos - currentPos);\n   vec3 halfVector = (lightDirection + view) / length(lightDirection + view);   \n   vec3 specular = pow(max(dot(halfVector, calculate_normal(currentPos)), 0.0), shininess) * specularColor;\n   float diffuse = max(dot(lightDirection * lightColor, calculate_normal(currentPos)), 0.0);\n   finalColor = vec3(ambientColor * ambientReflectivity + finalColor + specular);\n}\n\nbool IsInShadow(vec3 currentPos)\n{\n    vec3 points; \n    float stepping = 0.0;\n    for (int i = 0; i < 500; ++i)\n    {\n        points = currentPos + stepping * lightDirection;\n        if(false) // idk\n            return true;\n        else\n            return false;\n        //stepping = stepping + ???;\n    }\n}\n   \nvoid cast_ray(vec3 ray_origin, vec3 ray_direction)\n{\n    float t = 0.0;\n    for (int i = 0; i < 500; ++i)\n    {\n        p = ray_origin + t * ray_direction;\n        float hitDistance = sdf_scene(p);\n        switch(material)\n        {\n            case 0:\n            finalColor = vec3(0,0.7,0.95);\n            break;\n            case 1:\n            finalColor = vec3(1,0.5,0);\n            //return sdf_scene(p);\n            break;\n            case 2:\n            finalColor = vec3(0,0.75,0);\n            //return sdf_scene(p);\n            break;\n        }\n        \n        if (material != 0) // Means we hit something\n        {\n            if (IsInShadow(p))\n                finalColor = ambientColor;\n            else    \n                DoBlinnPhong(p);\n        }\n        // vvv To test out the normal vvv\n        //finalColor = calculate_normal(p); \n        t = t + min(sphereFloat, groundFloat);\n    }\n}\n\nvoid ApplyFog(vec3 ray_origin)\n{\n    vec3 fogColor = vec3(0,0.7f,0.95f);\n    float fogIntensity = 0.075f;\n    float fog = exp(-fogIntensity * length(ray_origin - p));\n    finalColor = finalColor * fog + fogColor * (1.0f - fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    // Rescale x and y to a range between -1 and 1 and set z to -1\n    vec3 rd = vec3(uv * 2.f - 1.f, -1.0);\n    // Scale the x-axis by the aspect ratio\n    rd.x *= aspect_ratio;\n    // Normalize the ray direction\n    rd = normalize(rd);\n    \n    cast_ray(camPos, rd);\n    \n    \n    ApplyFog(camPos);\n    \n    // Output to screen\n    fragColor = vec4(finalColor,0);\n}","name":"Image","description":"","type":"image"}]}