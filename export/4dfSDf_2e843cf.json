{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Subpixels antialiased quadratic Bézier stroke curve with butt caps and self-cover\n// Nicolas P. Rougier (http://www.labri.fr/perso/nrougier/)\n// Released under BSD license.\n\nfloat\ncubic_root( float x )\n{\n\tif( x < 0.0 ) return -pow(-x,1.0/3.0);\n\treturn pow(x,1.0/3.0);\n}\n\nint\ncubic_solve( in float a, in float b, in float c, out float r[3] )\n{\n\tfloat  p = b - a*a / 3.0;\n\tfloat  q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat  d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif( d >= 0.0 )\n    {        \n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = cubic_root(u);\n\t\tv = cubic_root(v);\n\t\tr[0] = offset + u + v;\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\treturn 3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 _p0 = vec2(0.25, .5) * iResolution.xy;\n\tvec2 _p1 = vec2(.5 + .5*cos(iTime*.3), .75 + .5*sin(5.+iTime)) * iResolution.xy;\n\tvec2 _p2 = vec2(.75, .5) * iResolution.xy;\n    float linewidth = 100.0 + cos(iTime)*50.0;\n\tfloat antialias = 1.0;\n    vec3 color = vec3(.75,.75,1.0);\n\n    vec2 _position = fragCoord.xy;\n\n    \n\tvec2  sb = (_p1 - _p0) * 2.0;\n\tvec2  sc = _p0 - _p1 * 2.0 + _p2;\n\tvec2  sd = _p1 - _p0;\n\tfloat sA = 1.0 / dot(sc, sc);\n\tfloat sB = 3.0 * dot(sd, sc);\n\tfloat sC = 2.0 * dot(sd, sd);\n\tvec2  D = _p0 - _position;\n    float res[3];\n\tint n = cubic_solve( sB*sA, (sC+dot(D,sc))*sA, dot(D,sd)*sA, res );\n\n\tfloat t0 = res[0];\n\t//float t0 = clamp(res[0],0.0,1.0);\n    bool ct0 = (t0>=0.0) && (t0<=1.0);\n\tvec2 pos = _p0 + (sb + sc*t0)*t0;\n    float d0 = length(pos - _position);\n\n\tfloat d = 1e20;\n\n    if( n > 1 )\n    {\n        float t1 = res[1];\n        // float t1 = clamp(res[1],0.0,1.0);\n        bool ct1 = (t1>=0.0) && (t1<=1.0);\n        pos = _p0 + (sb + sc*t1)*t1;\n        float d1 = length(pos - _position);\n\n        float t2 = res[2];\n        // float t2 = clamp(res[2],0.0,1.0);\n        bool ct2 = (t2>=0.0) && (t2<=1.0);\n        pos = _p0 + (sb + sc*t2)*t2;\n        float d2 = length(pos - _position);\n\n        if( ct0 && ct1 && ct2 )\n        {\n            d =  min(min(d0,d1),d2) - linewidth/2.0;\n        }\n        else\n        {\n            if (ct0 && ct1 && !ct2)\n            {\n                float maxd0d1 = max(d0,d1);\n                if ( maxd0d1 < (linewidth/2.0 + 0.5*antialias))\n                    d = linewidth/2.0 - maxd0d1 - 0.5*antialias;\n                else\n                    d = min(d0,d1) - linewidth/2.0 + antialias;\n            }\n            else if (ct1 && ct2 && !ct0)\n            {\n                float maxd1d2 = max(d1,d2);\n                if ( maxd1d2 < (linewidth/2.0 + 0.5* antialias))\n                    d =  linewidth/2.0 - maxd1d2 - 0.5* antialias;\n                else\n                    d = min(d1,d2) - linewidth/2.0;\n            }\n            else if( ct2 && ct0 && !ct1 )\n            {\n                float maxd2d0 = max(d2,d0);\n                if ( maxd2d0 < (linewidth/2.0 + 0.5* antialias))\n                    d = linewidth/2.0 - maxd2d0 - 0.5* antialias;\n                else\n                    d =  min(d2,d0) - linewidth/2.0;\n            }\n            else\n            {\n                if( ct0 && (d0 < d) ) d = d0;\n                if( ct1 && (d1 < d) ) d = d1;\n                if( ct2 && (d2 < d) ) d = d2;\n                d =  d - linewidth/2.0;\n            }\n        }\n    }\n    else\n    {\n        if( ct0 )\n            d = d0 - linewidth/2.0;\n    }\n\n    // Butt cap at start\n    {\n        float l = dot(_p1-_p0,_p1-_p0);\n        float u =( (_position.x-_p0.x)*(_p1.x-_p0.x) + (_position.y-_p0.y)*(_p1.y-_p0.y) ) / l;\n        vec2 p = _p0 + u*(_p1-_p0);\n        float d1 = length(p-_p0);\n        float d2 = length(_position-p);\n        //d = min(d, max(d2-_thickness/2.0  + _antialiased, d1)); // - _antialiased));\n        d = min(d, max(d2-linewidth/2.0, d1 - antialias));\n    }\n\n    // Butt cap at end\n    {\n        float l = dot(_p1-_p2,_p1-_p2);\n        float u =( (_position.x-_p2.x)*(_p1.x-_p2.x) + (_position.y-_p2.y)*(_p1.y-_p2.y) ) / l;\n        vec2 p = _p2 + u*(_p1-_p2);\n        float d1 = length(p-_p2);\n        float d2 = length(_position-p);\n        //d = min(d, max(d2-_thickness/2.0  + _antialiased, d1)); // - _antialiased));\n        d = min(d, max(d2-linewidth/2.0, d1 - antialias));\n    }\n\n    d += antialias;\n\n    if( d < 0.0 )\n    {\n        fragColor.rgb = color;\n    }\n    else\n    {\n        float alpha = d/antialias;\n        alpha = exp(-alpha*alpha);\n        fragColor = vec4( color*alpha, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfSDf","date":"1407216022","viewed":637,"name":"Thick Quadratic Bézier","username":"rougier","description":"Quadratic Bézier with butt caps, harder than it seems (handling self-cover on/off mode).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bezier","antialias","subpixel","caps","butt"],"hasliked":0,"parentid":"","parentname":""}}