{"ver":"0.1","info":{"id":"NdsXWH","date":"1618583841","viewed":71,"name":"Fork Specular q antonf2000 676","username":"antonf2000","description":"ssssssss","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"tddcD8","parentname":"Specular quad sample"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(1.4, 1, -6);\nconst vec3 LIGHT1_POS = vec3(-2.5,1.0, 5.0);\nconst float LIGHT1_RADIUS = 0.4;\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(2.5, 1.0, -0.5);\nconst float LIGHT2_RADIUS = 0.4;\nconst vec3 LIGHT2_COLOR = vec3(1, 1, 1);\nvec3 randDir;\n\nstruct Quad {\n    vec3 pos[4];\n    vec3 color;\n};\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir1, vec3 a, vec3 b, vec3 c, out vec3 normal) {\n    float eps = 0.001;\n    vec3 ba = b - a;\n    vec3 ac = c - a;\n    vec3 dir = normalize(dir1);\n    vec3 die = dir1;\n    normal = normalize(cross(ba,ac));\n    if (dot(normal, dir) > 0.0){\n        normal = -normal;\n    }\n    float D = -dot(normal, a);\n    float n = dot(normal, dir);\n    if (n < eps && n > (-eps)) {\n        return INF;\n    }\n    float t = -(dot(normal, pos)+D)/n;\n    if (t < 0.0) {\n        return INF;\n    }\n    vec3 x;\n    x.x = pos.x+dir.x*t; \n    x.y = pos.y+dir.y*t; \n    x.z = pos.z+dir.z*t;\n    float dab = sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n    float dac = sqrt((a.x-c.x)*(a.x-c.x)+(a.y-c.y)*(a.y-c.y)+(a.z-c.z)*(a.z-c.z));\n    float dax = sqrt((a.x-x.x)*(a.x-x.x)+(a.y-x.y)*(a.y-x.y)+(a.z-x.z)*(a.z-x.z));\n    float dbc = sqrt((b.x-c.x)*(b.x-c.x)+(b.y-c.y)*(b.y-c.y)+(b.z-c.z)*(b.z-c.z));\n    float dbx = sqrt((b.x-x.x)*(b.x-x.x)+(b.y-x.y)*(b.y-x.y)+(b.z-x.z)*(b.z-x.z));\n    float dcx = sqrt((c.x-x.x)*(c.x-x.x)+(c.y-x.y)*(c.y-x.y)+(c.z-x.z)*(c.z-x.z));\n    float ppabc = (dab + dbc + dac)/2.0;\n    float ppabx = (dab + dbx + dax)/2.0;\n    float ppacx = (dac + dcx + dax)/2.0;\n    float ppbcx = (dbc + dcx + dbx)/2.0;\n    float pabc = sqrt(ppabc*(ppabc-dab)*(ppabc-dbc)*(ppabc-dac));\n    float pabx = sqrt(ppabx*(ppabx-dab)*(ppabx-dbx)*(ppabx-dax));\n    float pacx = sqrt(ppacx*(ppacx-dac)*(ppacx-dcx)*(ppacx-dax));\n    float pbcx = sqrt(ppbcx*(ppbcx-dbc)*(ppbcx-dcx)*(ppbcx-dbx));\n    if (pabc + eps > pabx + pacx + pbcx){\n        return t;\n    }\n    return INF; \n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 tri1Norm;\n    float triT1 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri1Norm);\n    if (triT1 < dist)\n        return true;\n    vec3 tri2Norm;\n    float triT2 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri2Norm);\n    if (triT2 < dist)\n        return true;\n    vec3 tri3Norm;\n    float triT3 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri3Norm);\n    if (triT3 < dist)\n        return true;\n    vec3 tri4Norm;\n    float triT4 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri4Norm);\n    if (triT4 < dist)\n        return true;\n    vec3 tri5Norm;\n    float triT5 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri5Norm);\n    if (triT5 < dist)\n        return true;\n    vec3 tri6Norm;\n    float triT6 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri6Norm);\n    if (triT6 < dist)\n        return true;\n    vec3 tri7Norm;\n    float triT7 = traceTriangle(pos, dir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri7Norm);\n    if (triT7 < dist)\n        return true;\n    vec3 tri8Norm;\n    float triT8 = traceTriangle(pos, dir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri8Norm);\n    if (triT8 < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 15.0f / distSq1;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 10.0f / distSq2;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nconst float PI = 3.14159265359;\n\nvec3 getLightSpecular(Quad light, vec3 worldPos, vec3 viewVec, vec3 normal, float specFactor) {\n    vec3 r = reflect(viewVec, normal);\n    float sp = 0.0;\n    for (int i = 0; i < 4; ++i) {\n        vec3 vi = normalize(light.pos[i] - worldPos);\n        vec3 vi1 = normalize(light.pos[(i + 1) % 4] - worldPos);\n        vec3 ni = -normalize(cross(vi, vi1));\n        vec3 ti = normalize(cross(vi, ni));\n        float c;\n        float delta;\n        {\n            float a = max(dot(vi, r), 1e-9);\n            float b = max(dot(ti, r), 1e-9);\n            c = sqrt(a * a + b * b);\n            delta = atan(b / a);\n        }\n        float Imin = 0.0;\n        float Imax = (pow(c, specFactor + 2.0) - 1.0) / (pow2(c) - 1.0);\n        float xw = PI / 3.0 * sqrt(1.0 - pow2(c - c / float(specFactor)));\n        float cosxw = cos(xw);\n        float fxw = c * cosxw;\n        float Ixw = (pow(fxw, specFactor + 2.0) - fxw) / (pow2(fxw) - 1.0);\n        float yw = (Ixw - Imin) / (Imax - Imin);\n        float a = (1.0 - yw - 4.0 * pow2(xw / PI)) / yw / pow2(xw);\n        float Pmax = 1.0 / (1.0 + a * pow2(0.0));\n        float Pmin = 1.0 / (1.0 + a * pow2(PI / 2.0));\n        float s = (Imax - Imin) / (Pmax - Pmin);\n        float t = Imin - s * Pmin;\n        float Phi = acos(dot(vi, vi1));\n        float sqrt_a = sqrt(a);\n        float F = s / sqrt_a * (\n            atan(sqrt_a * (Phi - delta)) - atan(-sqrt_a * delta)\n        ) + t * Phi;\n        float l = F * dot(ni, r);\n        sp += max(l, 0.0);\n\t}\n    return light.color * sp;\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat modFloat(float x){\n    while (x > 10.0){\n        x /= 10.0;\n    }\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    float specFactor = 32.0 * 2.0 + 1.0;\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    const float WATER_N = 1.33;\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    const float DIAMOND_N = 2.5;\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    Quad light;\n    light.pos = vec3[4](\n        vec3(3.0, 1.5, -0.3),\n        vec3(3.0, 0.5, -0.3),\n        vec3(2.0, 0.5, -0.7),\n        vec3(2.0, 1.5, -0.7)\n    );\n    light.color = vec3(1, 1, 1);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.3).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 tri1Norm;\n        float triT1 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri1Norm);\n        if (triT1 < t) {\n            t = triT1;\n            normal = tri1Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri2Norm;\n        float triT2 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri2Norm);\n        if (triT2 < t) {\n            t = triT2;\n            normal = tri2Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri3Norm;\n        float triT3 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri3Norm);\n        if (triT3 < t) {\n            t = triT3;\n            normal = tri3Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri4Norm;\n        float triT4 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), tri4Norm);\n        if (triT4 < t) {\n            t = triT4;\n            normal = tri4Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri5Norm;\n        float triT5 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri5Norm);\n        if (triT5 < t) {\n            t = triT5;\n            normal = tri5Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri6Norm;\n        float triT6 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(-1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri6Norm);\n        if (triT6 < t) {\n            t = triT6;\n            normal = tri6Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri7Norm;\n        float triT7 = traceTriangle(curPos, curDir, vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri7Norm);\n        if (triT7 < t) {\n            t = triT7;\n            normal = tri7Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        vec3 tri8Norm;\n        float triT8 = traceTriangle(curPos, curDir, vec3(0.0,0.0,-1.0), vec3(1.0,0.0,0.0), vec3(0.0,-1.0,0.0), tri8Norm);\n        if (triT8 < t) {\n            t = triT8;\n            normal = tri8Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(1.0, 1.0, 1.0);\n                materialType = REFRACTION;\n                if (n1 == AIR_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = AIR_N;\n            }\n        }\n        \n        vec3 tri9Norm;\n        float triT9 = traceTriangle(curPos, curDir, vec3(0.3,-0.3,-0.3), vec3(-0.3,-0.3,-0.3), vec3(-0.3,0.3,-0.3), tri9Norm);\n        if (triT9 < t) {\n                t = triT9;\n                materialType = REFRACTION;\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                normal = tri9Norm;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n        }\n        vec3 tri10Norm;\n        float triT10 = traceTriangle(curPos, curDir, vec3(0.3,-0.3,-0.3), vec3(0.3,0.3,-0.3), vec3(-0.3,0.3,-0.3), tri10Norm);\n        if (triT10 < t) {\n            t = triT10;\n            normal = tri10Norm;\n             {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n            colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri11Norm;\n        float triT11 = traceTriangle(curPos, curDir, vec3(0.3,-0.3,-0.3), vec3(0.3,0.3,-0.3), vec3(0.3,0.3,0.3), tri11Norm);\n        if (triT11 < t) {\n            t = triT11;\n            normal = tri11Norm;\n           {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri12Norm;\n        float triT12 = traceTriangle(curPos, curDir, vec3(0.3,-0.3,-0.3), vec3(0.3,-0.3,0.3), vec3(0.3,0.3,0.3), tri12Norm);\n        if (triT12 < t) {\n            t = triT12;\n            normal = tri12Norm;\n           if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri13Norm;\n        float triT13 = traceTriangle(curPos, curDir, vec3(0.3,-0.3,0.3), vec3(-0.3,-0.3,0.3), vec3(-0.3,0.3,0.3), tri13Norm);\n        if (triT13 < t) {\n            t = triT13;\n            normal = tri13Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri14Norm;\n        float triT14 = traceTriangle(curPos, curDir, vec3(0.3,-0.3,0.3), vec3(0.3,0.3,0.3), vec3(-0.3,0.3,0.3), tri14Norm);\n        if (triT14 < t) {\n            t = triT14;\n            normal = tri14Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xy * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n         vec3 tri15Norm;\n        float triT15 = traceTriangle(curPos, curDir, vec3(-0.3,-0.3,-0.3), vec3(-0.3,0.3,-0.3), vec3(-0.3,0.3,0.3), tri15Norm);\n        if (triT15 < t) {\n            t = triT15;\n            normal = tri15Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri16Norm;\n        float triT16 = traceTriangle(curPos, curDir, vec3(-0.3,-0.3,-0.3), vec3(-0.3,-0.3,0.3), vec3(-0.3,0.3,0.3), tri16Norm);\n        if (triT16 < t) {\n            t = triT16;\n            normal = tri16Norm;\n           if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.yz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri17Norm;\n        float triT17 = traceTriangle(curPos, curDir, vec3(-0.3,0.3,-0.3), vec3(-0.3,0.3,0.3), vec3(0.3,0.3,0.3), tri17Norm);\n        if (triT17 < t) {\n            t = triT17;\n            normal = tri17Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri18Norm;\n        float triT18 = traceTriangle(curPos, curDir, vec3(-0.3,0.3,-0.3), vec3(0.3,0.3,-0.3), vec3(0.3,0.3,0.3), tri18Norm);\n        if (triT18 < t) {\n            t = triT18;\n            normal = tri18Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri19Norm;\n        float triT19 = traceTriangle(curPos, curDir, vec3(-0.3,-0.3,-0.3), vec3(-0.3,-0.3,0.3), vec3(0.3,-0.3,0.3), tri19Norm);\n        if (triT19 < t) {\n            t = triT19;\n            normal = tri19Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 tri20Norm;\n        float triT20 = traceTriangle(curPos, curDir, vec3(-0.3,-0.3,-0.3), vec3(0.3,-0.3,-0.3), vec3(0.3,-0.3,0.3), tri20Norm);\n        if (triT20 < t) {\n            t = triT20;\n            normal = tri20Norm;\n            if (randVals.x < 0.2) {\n                materialType = REFLECTION;\n            } else {\n                vec3 worldPos = t * curDir + curPos;\n                colorMult *= texture(iChannel3, fragCoord/iResolution.xz * 0.9).rgb + vec3(0.4, 0.4, 0.7);\n                colorMult *= vec3(0.55, 0.55, 0.95);\n                materialType = REFRACTION;\n                if (n1 == WATER_N) nEnter = GLASS_N;\n                if (n1 == GLASS_N) nEnter = WATER_N;\n            }\n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult + vec3(0.08, 0.08, 0.08);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}