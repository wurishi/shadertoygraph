{"ver":"0.1","info":{"id":"XccyRf","date":"1730929269","viewed":87,"name":"animated test image","username":"KeyJ","description":"A Standard Test Image like in the good old TV days, but with a few extra features targeted to check common issues with today's displays and display interfaces.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["gamma","testimage","zoneplate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SPDX-FileCopyrightText: 2024 Martin J. Fiedler <keyj@emphy.de>\n// SPDX-License-Identifier: MIT\n\n// Animated \"modern\" Standard Test Image\n//\n// This shader renders a test image like in the good old TV days, but with a \n// few extra features targeted to check common issues with today's displays\n// and display interfaces.\n//\n// Overview of the elements:\n// - Background: 20% linear gray = approx. 50% gray in sRGB\n// - Grid: for checking the aspect ratio; cells should be perfectly square\n// - Big circle: for checking the aspect ratio; shouldn't be an ellipse\n// - Image corners: colored markers that cover 3% of the screen height;\n//   shouldn't be cropped away\n// - Image edges: single-pixel white outline; shouldn't be cropped away\n// - Main block, top section: Standard color bars, but at full-intensity RGB\n// - Main block, below: Grayscale gradient, in three parts, from top to bottom:\n//   - 16 discrete gray levels; all transitions should be clearly visible\n//   - smooth gradient in the display device's color space\n//   - 50% black/white pattern and gamma scale: Squint and read the number\n//     below the point where the patterned bar and the smooth gradient have\n//     the same apparent brightness to determine the display's approximate gamma\n// - Main block, above center: numerical displays with background gradient\n//   - big center number: image size in pixels; should match the display resolution\n//   - small right number: frame rate in Hz; should match the display refresh rate\n//   - small left number: frame time in milliseconds\n//   - the edges of the digits should be perfectly sharp; if the display\n//     performs any sharpening, the digits get a glow-like effect\n// - Main block, center left: Grayscale values 0, 16, 235 and 255; if both the\n//   left and right half don't show a clearly discernible step, the display may\n//   have exaggerated contrast or there's a full range / limited range mismatch\n// - Main block, center: Moving dots at 120, 240, 600 and 1200 pixels per second,\n//   black and white, center portions 50% transparent, on 50% linear gray\n//   background\n//   - used to check motion blur and/or overdrive overshoot\n//   - top region with slower objects also contain a striped background\n//     to check for motion interpolation artifacts\n// - Main block: center right: Red/blue pixel-alternating patterns to check\n//   for color subsampling artifacts; should be pixel-perfect alternations of\n//   100% red and 100% blue without and other colors inbetween\n// - Main block, bottom: RGB gradients; similar to the grayscale gradient above,\n//   but with a black - color - white sweep\n// - Circlular inset, top left: Siemens star high-frequency grayscale pattern\n// - Circlular inset, bottom right: zoneplate high-frequency grayscale pattern\n// - Circular insets, top right and bottom left: vertical and horizontal\n//   frequency sweeps in discrete steps (Nyquist, Nyquist/2, Nyquist/3, ...)\n//   with square wave (alternating pure black/white) and sine waveforms\n//\n// Some of the elements have high-frequency uniform patterns that immediately\n// turn into lower-frequency \"beats\" or disappear completely if the display\n// performs any kind of scaling.\n\nconst float Gamma = 2.2;\nconst float BackgroundLuminance = 0.2;\nconst float GridCellsV = 16.0;\nconst float BorderScale = 0.001;\nconst float BorderBarScale = 0.03;\nconst float BorderBarLength = 10.0;\nconst float CircleRadius = 0.9;\nconst float EdgeCircleRadius = 0.8;\nconst float SiemensSpikes = 30.0;\nconst float SiemensRotateSpeed = 0.005;\nconst float ZoneplateMaxFreq = 200.0;\nconst float ZoneplateZoomSpeed = 0.05;\n\nconst float BlurBusterBackgroundBaseLuminance = 0.5;\nconst float BlurBusterBackgroundLuminanceDelta = 0.3;\nconst float BlurBusterBaseSpeed = 120.0;\nconst float BlurBusterStrips = 4.0;\nconst float BlurBusterCircleRadius = 0.8;\n\nconst float Pi = 3.14159265358979;\n\nbool inRect(in vec2 tl, in vec2 br, in vec2 pos, out vec2 rel) {\n    rel = (pos - tl) / (br - tl);\n    return ((min(rel.x, rel.y) >= 0.0) && (max(rel.x, rel.y) < 1.0));\n}\n\nvec3 gradient(in vec3 color, in vec2 pos, in float tile) {\n    if (pos.y > 0.667) {\n        return (mod(gl_FragCoord.x, 2.0) <= 1.0) ? color :\n               (pos.x <= 1.0) ? vec3(0.0) : vec3(1.0);\n    } else {\n        float x = (pos.y > 0.333) ? pos.x : tile;\n        return (x <= 1.0) ? (color * x) : mix(color, vec3(1.0), x - 1.0);\n    }\n}\n\nvec3 rangeCheck(in vec2 pos) {\n    return vec3((pos.y < 0.5) ? ((pos.x < 0.5) ? ( 0.0 / 255.0) : (235.0 / 255.0))\n                              : ((pos.x < 0.5) ? (16.0 / 255.0) : (255.0 / 255.0)));\n}\n\nvec3 subsampleCheck(in vec2 pos) {\n    float a = (pos.x > 0.5) ? gl_FragCoord.x : gl_FragCoord.y;\n    float s = ((pos.x > 0.5) ? pos.y : pos.x) * ((pos.y > 0.5) ? 4.0 : 2.0);\n    float m = (pos.y > 0.5) ? 1.0 : 3.0;\n    return (mod(a - floor(m * s), 2.0 * m) < m)\n           ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n}\n\nfloat blurbuster(in vec2 pixelPos, in vec2 size) {\n    float stripHeight = floor(size.y / BlurBusterStrips);\n    float y = pixelPos.y - 0.5 * (size.y - stripHeight * BlurBusterStrips);\n    float s = floor(y / stripHeight);\n    float x = mod(pixelPos.x - iTime * BlurBusterBaseSpeed * (1.0 + s * s), size.x);\n    float c = (x < (0.5 * size.x)) ? 0.0 : 1.0;\n    if (x > (0.5 * size.x)) { x -= 0.5 * size.x; }\n    x -= 0.25 * size.x;\n    y = mod(y, stripHeight) - 0.5 * stripHeight;\n    float d = clamp(0.5 * BlurBusterCircleRadius * stripHeight - length(vec2(x, y)) + 0.5, 0.0, 1.0);\n    if (abs(x) < (stripHeight * 0.125)) { d *= 0.5; }\n    float b = 1.0 - pixelPos.y / size.y;  b *= b;  b *= b;\n    b *= (fract(gl_FragCoord.x * 0.25) < 0.5) ? 1.0 : -1.0;\n    b = BlurBusterBackgroundBaseLuminance + BlurBusterBackgroundLuminanceDelta * b;\n    return mix(pow(b, 1.0/Gamma), c, d);\n}\n\nvoid edgeCircle(inout vec3 pixelColor, in float distance, in float radius, in vec3 overlayColor) {\n    float d = radius - distance + 0.5;\n    float a = 1.0 - min(1.0, (1.0 - d) / (radius * 0.1));\n    a *= a;\n    a = 1.0 - 0.5 * a;\n    pixelColor = mix(pixelColor * a, overlayColor, clamp(d, 0.0, 1.0));\n}\n\nfloat siemens(in vec2 pos) {\n    float l = length(pos);\n    float ss = 1.0;\n    while ((ss > 0.03125) && (l < (SiemensSpikes * ss))) { ss *= 0.5; }\n    float a = 0.0, n = 0.0;\n    for (float dy = -0.5 + 0.5 * ss;  dy < 0.5;  dy += ss) {\n        for (float dx = -0.5 + 0.5 * ss;  dx < 0.5;  dx += ss) {\n            float t = abs(mod(atan(pos.y + dy, pos.x + dx) - iTime * SiemensRotateSpeed, 2.0 * Pi) - Pi) / Pi;\n            a += 0.5 + 0.5 * cos(t * (SiemensSpikes * Pi));\n            n += 1.0;\n        }\n    }\n    return pow(a / n, 1.0/Gamma);\n}\n\nfloat zoneplate(in float distance, in float radius) {\n    float l = distance / radius;\n    l *= l;\n    float a = 0.5 + 0.5 * cos(l * ZoneplateMaxFreq - ZoneplateZoomSpeed * iTime);\n    return pow(a, 1.0/Gamma);\n}\n\nfloat reschart(in float band, in float pos) {\n    float freq = ceil(abs(band) + 0.5);\n    return ((freq > 1.0) && (band < 0.0))\n         ? pow(0.5 + 0.5 * sin((pos + 0.5) / freq * Pi), 1.0/Gamma)\n         : ((mod(pos, freq * 2.0) > freq) ? 1.0 : 0.0);\n}\n\n// .##. | ..#. | .##. | ###. | ...# | #### | .##. | #### | .##. | .##. | .... | ....\n// #..# | .##. | #..# | ...# | ..## | #... | #... | ...# | #..# | #..# | .... | ....\n// #..# | ..#. | ...# | .##. | .#.# | ###. | ###. | ..#. | .##. | #..# | .... | #.#.\n// #..# | ..#. | ..#. | ...# | #..# | ...# | #..# | .#.. | #..# | .### | .... | .#..\n// #..# | ..#. | .#.. |  ..# | #### | ...# | #..# | .#.. | #..# | ...# | .... | #.#.\n// .##. | .### | #### | ###. | ...# | ###. | .##. | .#.. | .##. | .##. | ..#. | ....\n\nvoid glyph(inout vec3 pixelColor, in vec2 pos, in uint glyphID, in vec3 color) {\n    #define NGLYPHS 12\n    const uint glyphs[NGLYPHS] = uint[NGLYPHS](\n        0x699996u, 0xE44464u, 0xF24896u, 0x788687u, 0x8F9AC8u, 0x78871Fu, 0x699716u, 0x22248Fu, 0x699696u, 0x68E996u, 0x400000u, 0x052500u\n    );\n    if ((min(pos.x, pos.y) < 0.0) || (pos.x >= 4.0) || (pos.y >= 6.0) ) { return; }\n    uvec2 p = uvec2(floor(pos));\n    if (((glyphs[glyphID] >> ((p.y << 2u) | p.x)) & 1u) != 0u) { pixelColor = color; }\n}\n\nvoid decimal(inout vec3 pixelColor, in vec2 pos, in float value, in vec3 color) {\n    uint iv = uint(floor(value));\n    if (iv > 99u) {\n        glyph(pixelColor, pos - vec2(-15.0, 0.0), (iv / 100u) % 10u, color);\n    }\n    if (iv > 9u) {\n        glyph(pixelColor, pos - vec2(-10.0, 0.0), (iv / 10u) % 10u, color);\n    }\n    glyph(    pixelColor, pos - vec2( -5.0, 0.0), iv % 10u, color);\n    glyph(    pixelColor, pos - vec2( -2.0, 0.0), 10u, color);\n    glyph(    pixelColor, pos - vec2(  2.0, 0.0), uint(floor(value * 10.0)) % 10u, color);\n}\n\nvoid resolution(inout vec3 pixelColor, in vec2 pos, in uvec2 value, in vec3 color) {\n    glyph(pixelColor, pos - vec2(-1.0, 0.0), 11u, color);\n    float x = -6.0;\n    uint v = value.x;\n    while (v != 0u) { glyph(pixelColor, pos - vec2(x, 0.0), v % 10u, color); v = v / 10u; x -= 5.0; }\n    v = value.y; x = -2.0;\n    while (v != 0u) { x += 5.0; v = v / 10u; }\n    v = value.y;\n    while (v != 0u) { glyph(pixelColor, pos - vec2(x, 0.0), v % 10u, color); v = v / 10u; x -= 5.0; }\n}\n\nvoid gammaScale(inout vec3 pixelColor, in vec2 pos, in float width, in float scale, in vec3 color) {\n    #define NGAMMAS 6\n    const float gammas[NGAMMAS] = float[NGAMMAS]( 1.5, 1.8, 2.0, 2.2, 2.4, 2.8 );\n    float lx = -999.9;\n    for (uint i = 0u;  i < uint(NGAMMAS);  ++i) {\n        float f = pow(0.5, 1.0 / gammas[i]);\n        float x = (pos.x - floor(f * width + 0.5)) * scale;\n        if (abs(x - lx) >= 15.0) {\n            decimal(pixelColor, vec2(x, pos.y * scale), gammas[i], color);\n            lx = x;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 screenSize = iResolution.xy;\n    vec2 pixelPosTL = vec2(fragCoord.x, screenSize.y - fragCoord.y);\n\n    // base geometry\n    float borderSize = max(1.0, floor(screenSize.y * BorderScale));\n    float cellSize = floor((screenSize.y - 2.0 * borderSize) / GridCellsV);\n    float textScaleS = 1.0 / max(1.0, floor(cellSize * 0.02));\n    float textScaleM = 1.0 / max(1.0, floor(cellSize * 0.04));\n    float textScaleL = 1.0 / max(1.0, floor(cellSize * 0.08));\n    float barWidth = max(8.0, floor(screenSize.y * BorderBarScale));\n    float barLength = BorderBarLength * barWidth;\n    float ecOffset = floor(min((0.5 * screenSize.x - 8.0 * cellSize - barWidth) * 0.5 + barWidth, 0.25 * screenSize.y));\n    float ecRadius = (ecOffset - barWidth) * EdgeCircleRadius;\n    vec2 pixelPosC = pixelPosTL - floor(screenSize * 0.5);\n    vec2 pixelPosBR = screenSize - pixelPosTL;\n    vec2 subPos;\n    vec3 color = vec3(pow(BackgroundLuminance, 1.0/Gamma));\n\n    // background grid\n    vec2 tile = floor(pixelPosC / cellSize);\n    vec2 dist2edge = pixelPosC - tile * cellSize;\n    dist2edge = min(dist2edge, cellSize - dist2edge);\n    if (min(dist2edge.x, dist2edge.y) < borderSize) { color = vec3(1.0); }\n\n    // border bars\n    if      ((pixelPosTL.x < barLength) && (pixelPosTL.y < barWidth))  { color = vec3(.1, .5, .9); }\n    else if ((pixelPosTL.x < barWidth)  && (pixelPosTL.y < barLength)) { color = vec3(.9, .5, .1); }\n    else if ((pixelPosBR.x < barLength) && (pixelPosTL.y < barWidth))  { color = vec3(.5, .1, .9); }\n    else if ((pixelPosBR.x < barWidth)  && (pixelPosTL.y < barLength)) { color = vec3(.5, .9, .1); }\n    else if ((pixelPosTL.x < barLength) && (pixelPosBR.y < barWidth))  { color = vec3(.9, .1, .5); }\n    else if ((pixelPosTL.x < barWidth)  && (pixelPosBR.y < barLength)) { color = vec3(.1, .9, .5); }\n    else if ((pixelPosBR.x < barLength) && (pixelPosBR.y < barWidth))  { color = vec3(.9, .5, .1); }\n    else if ((pixelPosBR.x < barWidth)  && (pixelPosBR.y < barLength)) { color = vec3(.1, .5, .9); }\n\n    // text bar\n    if (inRect(vec2(-8.0, -1.0) * cellSize + vec2(borderSize, borderSize),\n               vec2( 8.0,  0.0) * cellSize - vec2(borderSize, borderSize), pixelPosC, subPos)) { color = vec3(1.0 - subPos.y * 0.4); }\n    resolution(color, pixelPosC * textScaleL - vec2(0.0, -8.0), uvec2(screenSize), vec3(0.3));\n    decimal(color, pixelPosC * textScaleM - vec2(-80.0, -12.0), iTimeDelta * 1000.0, vec3(0.4));\n    decimal(color, pixelPosC * textScaleM - vec2( 80.0, -12.0), iFrameRate, vec3(0.4));\n\n    // color bars\n    if (inRect(vec2(-8.0, -5.0) * cellSize + vec2(borderSize, borderSize),\n               vec2(-6.0, -3.0) * cellSize - vec2(0.0,        borderSize), pixelPosC, subPos)) { color = vec3(1.0, 1.0, 1.0); }\n    if (inRect(vec2(-6.0, -5.0) * cellSize + vec2(0.0,        borderSize),\n               vec2(-4.0, -3.0) * cellSize - vec2(0.0,        borderSize), pixelPosC, subPos)) { color = vec3(1.0, 1.0, 0.0); }\n    if (inRect(vec2(-4.0, -5.0) * cellSize + vec2(0.0,        borderSize),\n               vec2(-2.0, -3.0) * cellSize - vec2(0.0,        borderSize), pixelPosC, subPos)) { color = vec3(0.0, 1.0, 1.0); }\n    if (inRect(vec2(-2.0, -5.0) * cellSize + vec2(0.0,        borderSize),\n               vec2( 0.0, -3.0) * cellSize - vec2(0.0,        borderSize), pixelPosC, subPos)) { color = vec3(0.0, 1.0, 0.0); }\n    if (inRect(vec2( 0.0, -5.0) * cellSize + vec2(0.0,        borderSize),\n               vec2( 2.0, -3.0) * cellSize - vec2(0.0,        borderSize), pixelPosC, subPos)) { color = vec3(1.0, 0.0, 1.0); }\n    if (inRect(vec2( 2.0, -5.0) * cellSize + vec2(0.0,        borderSize),\n               vec2( 4.0, -3.0) * cellSize - vec2(0.0,        borderSize), pixelPosC, subPos)) { color = vec3(1.0, 0.0, 0.0); }\n    if (inRect(vec2( 4.0, -5.0) * cellSize + vec2(0.0,        borderSize),\n               vec2( 6.0, -3.0) * cellSize - vec2(0.0,        borderSize), pixelPosC, subPos)) { color = vec3(0.0, 0.0, 1.0); }\n    if (inRect(vec2( 6.0, -5.0) * cellSize + vec2(0.0,        borderSize),\n               vec2( 8.0, -3.0) * cellSize - vec2(borderSize, borderSize), pixelPosC, subPos)) { color = vec3(0.0, 0.0, 0.0); }\n\n    // color gradients\n    if (inRect(vec2(-8.0, -3.0) * cellSize + vec2(borderSize, borderSize),\n               vec2( 8.0, -1.0) * cellSize - vec2(borderSize, borderSize), pixelPosC, subPos)) { color = gradient(vec3(1.0, 1.0, 1.0), subPos, (tile.x + 8.0) / 15.0); }\n    if (inRect(vec2(-8.0,  2.0) * cellSize + vec2(borderSize, borderSize),\n               vec2( 8.0,  3.0) * cellSize - vec2(borderSize,        0.0), pixelPosC, subPos)) { color = gradient(vec3(1.0, 0.0, 0.0), subPos * vec2(2.0, 1.0), (tile.x + 8.0) / 7.5); }\n    if (inRect(vec2(-8.0,  3.0) * cellSize + vec2(borderSize,        0.0),\n               vec2( 8.0,  4.0) * cellSize - vec2(borderSize,        0.0), pixelPosC, subPos)) { color = gradient(vec3(0.0, 1.0, 0.0), subPos * vec2(2.0, 1.0), (tile.x + 8.0) / 7.5); }\n    if (inRect(vec2(-8.0,  4.0) * cellSize + vec2(borderSize,        0.0),\n               vec2( 8.0,  5.0) * cellSize - vec2(borderSize, borderSize), pixelPosC, subPos)) { color = gradient(vec3(0.0, 0.0, 1.0), subPos * vec2(2.0, 1.0), (tile.x + 8.0) / 7.5); }\n\n    // range check, subsampling check, blur buster\n    if (inRect(vec2(-8.0,  0.0) * cellSize + vec2(borderSize, borderSize),\n               vec2(-6.0,  2.0) * cellSize - vec2(borderSize, borderSize), pixelPosC, subPos)) { color = rangeCheck(subPos); }\n    if (inRect(vec2( 6.0,  0.0) * cellSize + vec2(borderSize, borderSize),\n               vec2( 8.0,  2.0) * cellSize - vec2(borderSize, borderSize), pixelPosC, subPos)) { color = subsampleCheck(subPos); }\n    vec2 blurbusterTL = vec2(-6.0,  0.0) * cellSize + vec2(borderSize, borderSize);\n    vec2 blurbusterBR = vec2( 6.0,  2.0) * cellSize - vec2(borderSize, borderSize);\n    if (inRect(blurbusterTL, blurbusterBR, pixelPosC, subPos)) {\n        color = vec3(blurbuster(pixelPosC - blurbusterTL, blurbusterBR - blurbusterTL));\n    }\n\n    // edge circles\n    float d;\n    float rcBandScale = 2.0 / cellSize;\n    subPos = pixelPosTL - vec2(ecOffset); d = length(subPos);\n    if (d < ecOffset) { edgeCircle(color, d, ecRadius, vec3(siemens(subPos))); }\n    subPos = pixelPosBR - vec2(ecOffset); d = length(subPos);\n    if (d < ecOffset) { edgeCircle(color, d, ecRadius, vec3(zoneplate(d, ecRadius))); }\n    subPos = vec2(pixelPosTL.x, pixelPosBR.y) - vec2(ecOffset); d = length(subPos);\n    if (d < ecOffset) { edgeCircle(color, d, ecRadius, vec3(reschart(subPos.y * rcBandScale, subPos.x))); }\n    subPos = vec2(pixelPosBR.x, pixelPosTL.y) - vec2(ecOffset); d = length(subPos);\n    if (d < ecOffset) { edgeCircle(color, d, ecRadius, vec3(reschart(subPos.x * rcBandScale, subPos.y))); }\n\n    // main circle overlay\n    color = mix(color, vec3(1.0), clamp((borderSize + 0.5) - abs(length(pixelPosC) - (0.5 * CircleRadius) * screenSize.y), 0.0, 1.0));\n\n    // gamma scales\n    gammaScale(color, pixelPosC - vec2(-8.0, -1.0) * cellSize - vec2(borderSize, 2.0 * borderSize),\n                      16.0 * cellSize - 2.0 * borderSize, textScaleS, vec3(0.5));\n    gammaScale(color, pixelPosC - vec2(-8.0,  5.0) * cellSize - vec2(borderSize, 2.0 * borderSize),\n                       8.0 * cellSize -       borderSize, textScaleS, vec3(0.0));\n\n    // outer border overlay\n    if (min(min(pixelPosTL.x, pixelPosTL.y), min(pixelPosBR.x, pixelPosBR.y)) < 1.0) { color = vec3(1.0); }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}