{"ver":"0.1","info":{"id":"ddXSzX","date":"1669380199","viewed":174,"name":"SDFVolumeTexture(Voxelize)","username":"Mario8664","description":"SDF Volume Texture\nVoxelize a sdf scene to texture. Then use distance transform algorithm, and then interpolate sample it using raymarching. \nin \"Common\", #define NOISE to use noise\nOr use sdf scene, and press A to show origin sdf scene.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","volume","sdf","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DISTANCE 10.0\n#define PI 3.1415926535897932384626\n#define FRESNEL 2.0\n#define AOSTEP 0.1\n#define LIGHT vec3(-1.0, 2.0, -1.0)\n#define SUNSIZE 0.01\n\nfloat apress = 0.0;\n\nvec2 rayBox(vec3 pos, vec3 boxmin, vec3 boxmax, vec3 rd)\n{\n    vec3 t0 = (boxmin - pos) / rd;\n    vec3 t1 = (boxmax - pos) / rd;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n\n    float d0 = max(tmin.x, max(tmin.y, tmin.z));\n    float d1 = min(tmax.x, min(tmax.y, tmax.z));\n\n    return vec2(d0, d1);\n}\n\n\nvec4 getVoxelScene(vec3 pos, float size)\n{\n#ifdef ORIGIN\n    return getScene(pos);\n#else\n    if(apress > 0.8)\n        return getScene(pos);\n    vec3 texelCoord = (pos + 0.49) * size;\n    float d = texelFetchSmooth3D(texelCoord, iChannel0, int(size), ivec2(iResolution.xy)).a;\n    return vec4(vec3(1.0), d);\n#endif\n}\n\nvec3 skyBox(vec3 rd)\n{\n    //return texture(iChannel0, rd).xyz;\n    vec3 sky = mix(vec3(1.2), vec3(0.7, 0.8, 1.0), smoothstep(-0.3, 0.7, rd.y));\n    vec3 land = mix(vec3(0.0), vec3(0.2, 0.2, 0.3), smoothstep(-0.9, 0.3, rd.y));\n    vec3 skybox = mix(land, sky, smoothstep(-0.05, 0.1, rd.y));\n    \n    float sun = dot(rd, normalize(LIGHT));\n    sun = (sun - 1.0 + SUNSIZE) / SUNSIZE;\n    sun = clamp(sun, 0.0, 1.0);\n    sun = pow(sun, 5.0);\n    \n    return skybox + sun;\n    //return ceil(rd * 10.0) / 10.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef DEBUG\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 uvw;\n    ivec3 fragCoord3D;\n    int size;\n    Get3DInfo(fragCoord, iResolution.xy, uvw, fragCoord3D, size);\n    \n    uv = fragCoord/iResolution.y;\n    float halfVoxel = 0.5 / float(size);\n    float z = 1.0 - fract(iTime * 0.5);\n    if(iMouse.z > 0.5)\n    {\n        z = clamp(iMouse.x / iResolution.x * 2.0 - 0.25, 0.0, 1.0);\n    }\n    \n    uv *= 2.0;\n    uv -= 0.25 + 0.3 * z;\n    vec3 uvslice = vec3(uv, z) - halfVoxel;\n    if(uvslice.x < 0.0 || uvslice.y < 0.0 || uvslice.x > 1.0 || uvslice.y > 1.0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec4 col = texelFetchSmooth3D(uvslice * float(size), iChannel0, size, ivec2(iResolution.xy));\n    fragColor = col.aaaa;// * float(size);\n#else\n    apress = texelFetch(iChannel2, ivec2(KEY_A,0), 0).r;\n\n    float size = floor(pow(iResolution.x * iResolution.y, 1.0 / 3.0));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    //Camera\n    vec2 m = texture(iChannel1, vec2(0.375)).xy;//Camera input\n    vec3 target = vec3(0.0, 0.0, 0.0);//Camera view target\n    float theta = m.x * 2.0 * PI;//Input to y-axis angle(0 ~ 2PI)\n    float fai = -(m.y - 0.5) * 0.8 * PI;//Input to local x-axis angle(-0.4Pi ~ 0.4PI)\n\n    //rotation vector(unit vector)\n    vec3 rotation = vec3(cos(theta), sin(fai) ,sin(theta));\n    rotation.xz *= cos(fai);\n    \n    float dd = DISTANCE * texture(iChannel1, vec2(0.75)).x;\n    vec3 cameraPos = rotation * dd;\n    vec3 cameraForward = normalize(target - rotation);\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n    \n    vec3 ro = cameraPos;\n    vec3 rd = cameraForward * 2.0 + uv.x * cameraRight + uv.y * cameraUp;\n    rd = normalize(rd);\n    \n    vec3 col = skyBox(rd);\n    vec2 box = rayBox(ro, vec3(-0.5), vec3(0.5), rd);\n    col += pow(max(box.y - box.x, 0.0) / 1.732050807568877, 0.3) * 0.1;//draw a volume\n    float t = max(box.x, 0.0);\n    vec3 pos = ro + rd * t;\n    for(int i = 0; i < 128; i++)\n    {\n        vec4 d = getVoxelScene(pos, size);\n        if(t > box.y)\n        {\n            break;\n        }\n        if(abs(d.w)<(0.001) * t)\n        {\n            vec2 offset = vec2(0.002, 0.0);\n            \n            vec3 normal = vec3(getVoxelScene(pos + offset.xyy, size).w - getVoxelScene(pos - offset.xyy, size).w,\n                               getVoxelScene(pos + offset.yxy, size).w - getVoxelScene(pos - offset.yxy, size).w,\n                               getVoxelScene(pos + offset.yyx, size).w - getVoxelScene(pos - offset.yyx, size).w);\n            if(t - box.x < 0.001)\n            {        \n                normal = pos;\n                vec3 man = abs(normal);\n                float maxn = max(man.x, max(man.y, man.z));\n                normal = sign(normal) * max(man - maxn + 0.001, 0.0);\n            }\n            \n            normal = normalize(normal);\n            //reflection\n            vec3 ref = skyBox(reflect(rd,normal));\n            //fresnel\n            float fresnel = (1.0 - dot(normal, -rd));\n            fresnel = pow(fresnel, FRESNEL);\n            ref *= fresnel;\n            //diffuse\n            float diffuse = dot(normal, normalize(LIGHT));\n            diffuse = clamp(diffuse, 0.1, 1.0);\n            diffuse = pow(diffuse, 0.5);\n            //specular\n            float specular = clamp(dot(normal,normalize(LIGHT-rd)), 0.0, 1.0);\n            specular = pow(specular, 18.0) * 0.1;\n            //ambient occlusion\n            ro = pos;\n            t = 0.0;\n            float ao = 0.0;\n            for(int j = 0; j < 4; j++)\n            {\n                ao += 1.0 / pow(2.0, float(j)) * (float(j) * AOSTEP - getVoxelScene(pos, size).w);\n                t -= AOSTEP;\n                pos = ro + rd * t;\n            }\n            ao = 1.0 - ao;\n        \tcol = diffuse * d.rgb + ref + vec3(0.05) + specular;\n            col *= ao;\n            break;\n        }\n        t += d.w;\n        pos = ro + rd * t;        \n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n#endif\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MOUSE_LERP 5.0\n#define MOUSE_STEP 0.5\n#define INIT vec2(0.6, 0.3)\n\n#define INITDISTANCE 0.3\n#define MINDISTANCE 0.1\n#define MAXDISTANCE 0.5\n#define ZOOM_LERP 5.0\n#define ZOOM_STEP 0.005\n\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_R 82\n#define KEY_S 83\n\n//#define DEBUG\n//#define ORIGIN\n//#define NOISE\n\n//sdf\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float d = min(d1, d2);\n    float dif = max(k - abs(d1 - d2), 0.0);\n    d = d - dif * dif * 0.25 / k;\n    return d;\n}\nvec4 getScene(vec3 pos)\n{\n    float d1 = sdSphere(pos, 0.2);\n    float d2 = sdSphere(pos + vec3(-0.0, 0.2, -0.1), 0.18);\n    float d3 = sdSphere(pos + vec3(-0.1, -0.1, 0.3), 0.1);\n    float d4 = sdSphere(pos + vec3(0.2, -0.1, 0.3), 0.15);\n    float d = opSmoothUnion(d1, d2, 0.05);\n    d = opUnion(d, d3);\n    d = opUnion(d, d4);\n    return vec4(vec3(1.0), d);\n}\n\n\n//3d\nvoid Get3DInfo(in vec2 fragCoord, in vec2 resolution, out vec3 uvw, out ivec3 fragCoord3D, out int size)\n{\n    size = int(floor(pow(resolution.x * resolution.y, 1.0 / 3.0)));\n    ivec2 iFragCoord = ivec2(floor(fragCoord));\n    ivec2 iResolution = ivec2(floor(resolution));\n    \n    int size2D = size * size;\n    int pixelID = iFragCoord.x + iFragCoord.y * iResolution.x;\n    int tileID = pixelID / size2D;\n    int inTileID = pixelID % size2D;\n    fragCoord3D = ivec3(inTileID % size, inTileID / size, tileID);\n    uvw = vec3(fragCoord3D) / float(size);\n}\n\nvec4 texelFetch3D(in ivec3 fragCoord3D,in sampler2D tex,in int size,in ivec2 resolution)\n{\n    fragCoord3D = clamp(fragCoord3D, 0, size);\n    int size2D = size * size;\n    int pixelID = fragCoord3D.z * size2D + fragCoord3D.y * size + fragCoord3D.x;\n    ivec2 pixelID2D = ivec2(pixelID % resolution.x, pixelID / resolution.x);\n    return texelFetch(tex, pixelID2D, 0);\n}\n\n\nvec4 texelFetch3DWhiteBoard(in ivec3 fragCoord3D,in sampler2D tex,in int size,in ivec2 resolution)\n{\n    if(fragCoord3D.x >= size || fragCoord3D.y >= size || fragCoord3D.z >= size ||\n    fragCoord3D.x < 0 || fragCoord3D.y < 0 || fragCoord3D.z < 0)\n    {\n        return vec4(1.0);\n    }\n    int size2D = size * size;\n    int pixelID = fragCoord3D.z * size2D + fragCoord3D.y * size + fragCoord3D.x;\n    ivec2 pixelID2D = ivec2(pixelID % resolution.x, pixelID / resolution.x);\n    return texelFetch(tex, pixelID2D, 0);\n}\n\nvec4 texelFetchSmooth3D(in vec3 fragCoord,in sampler2D tex,in int size,in ivec2 resolution)\n{    \n    //vec4 c = texelFetch3D(fragCoord3D, tex, size, resolution);\n    \n    vec3 uv = fragCoord;\n    vec2 bias = vec2(0.5, -0.5);\n    \n    ivec3 id000 = ivec3(floor((uv + bias.yyy)));\n    ivec3 id001 = ivec3(floor((uv + bias.yyx)));\n    ivec3 id010 = ivec3(floor((uv + bias.yxy)));\n    ivec3 id011 = ivec3(floor((uv + bias.yxx)));\n    ivec3 id100 = ivec3(floor((uv + bias.xyy)));\n    ivec3 id101 = ivec3(floor((uv + bias.xyx)));\n    ivec3 id110 = ivec3(floor((uv + bias.xxy)));\n    ivec3 id111 = ivec3(floor((uv + bias.xxx)));\n    \n    vec4 c000 = texelFetch3D(id000, tex, size, resolution);\n    vec4 c001 = texelFetch3D(id001, tex, size, resolution);\n    vec4 c010 = texelFetch3D(id010, tex, size, resolution);\n    vec4 c011 = texelFetch3D(id011, tex, size, resolution);\n    vec4 c100 = texelFetch3D(id100, tex, size, resolution);\n    vec4 c101 = texelFetch3D(id101, tex, size, resolution);\n    vec4 c110 = texelFetch3D(id110, tex, size, resolution);\n    vec4 c111 = texelFetch3D(id111, tex, size, resolution);\n    \n    vec3 center000 = floor(uv + bias.yyy) + 0.5;\n    vec3 samplePos = uv - center000;\n    \n    vec4 c00 = mix(c000, c001, samplePos.z);\n    vec4 c01 = mix(c010, c011, samplePos.z);\n    vec4 c10 = mix(c100, c101, samplePos.z);\n    vec4 c11 = mix(c110, c111, samplePos.z);\n    \n    vec4 c0 = mix(c00, c01, samplePos.y);\n    vec4 c1 = mix(c10, c11, samplePos.y);\n    \n    vec4 c = mix(c0, c1, samplePos.x);\n    \n    return c;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hash(vec3 p)\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 i = floor(pos);\n    vec3 f = fract(pos);\n    \n    vec3 u = f*f*(3.0-2.0*f);\n    \n    vec3 v0 = hash(i);\n    vec3 v1 = hash(i + vec3(1.0, 0.0, 0.0));\n    vec3 v2 = hash(i + vec3(0.0, 1.0, 0.0));\n    vec3 v3 = hash(i + vec3(1.0, 1.0, 0.0));\n    vec3 v4 = hash(i + vec3(0.0, 0.0, 1.0));\n    vec3 v5 = hash(i + vec3(1.0, 0.0, 1.0));\n    vec3 v6 = hash(i + vec3(0.0, 1.0, 1.0));\n    vec3 v7 = hash(i + vec3(1.0, 1.0, 1.0));\n    \n    float c0 = dot(v0, f);\n    float c1 = dot(v1, f - vec3(1.0, 0.0, 0.0));\n    float c2 = dot(v2, f - vec3(0.0, 1.0, 0.0));\n    float c3 = dot(v3, f - vec3(1.0, 1.0, 0.0));\n    float c4 = dot(v4, f - vec3(0.0, 0.0, 1.0));\n    float c5 = dot(v5, f - vec3(1.0, 0.0, 1.0));\n    float c6 = dot(v6, f - vec3(0.0, 1.0, 1.0));\n    float c7 = dot(v7, f - vec3(1.0, 1.0, 1.0));\n    \n    float lerpX0 = mix(c0, c1, u.x);\n    float lerpX1 = mix(c2, c3, u.x); \n    float lerpX2 = mix(c4, c5, u.x);\n    float lerpX3 = mix(c6, c7, u.x);\n    \n    float lerpY0 = mix(lerpX0, lerpX1, u.y);\n    float lerpY1 = mix(lerpX2, lerpX3, u.y);\n    \n    return mix(lerpY0, lerpY1, u.z);\n}\n\nfloat solid(vec3 uvw)\n{\n#ifndef NOISE\n    uvw = uvw - 0.5;\n    float d = getScene(uvw).w;\n    d = ceil(d);\n    return d;\n#else\n    mat3 rot = mat3( 0.00,  0.80,  0.60,\n                -0.80,  0.36, -0.48,\n                -0.60, -0.48,  0.64 );\n    float scale = 4.0;\n    float n = noise(scale * uvw) * 0.5;uvw = rot * uvw * 2.01;\n    n += noise(scale * uvw) * 0.25;uvw = rot * uvw * 2.02;\n    //n += noise(scale * uvw) * 0.125;uvw = rot * uvw * 2.03;\n    //n += noise(scale * uvw) * 0.0625;\n    return ceil(n + 0.1);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0 || texelFetch(iChannel1, ivec2(KEY_R,0), 0).r > 0.5)\n    {\n         vec3 uvw;\n         ivec3 fragCoord3D;\n         int size;\n         Get3DInfo(fragCoord, iResolution.xy, uvw, fragCoord3D, size);\n    \n         float s = solid(uvw);\n    \n         fragColor = vec4(s, s, s, 1.0);\n    }\n    else\n    {\n         vec2 uv = fragCoord / iResolution.xy;\n         fragColor = texture(iChannel0, uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//distance transform\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uvw;\n    ivec3 fragCoord3D;\n    int size;\n    Get3DInfo(fragCoord, iResolution.xy, uvw, fragCoord3D, size);\n    \n    ivec3 ios = ivec3(-1, 1, 0);\n    vec3 os = vec3(-1.0, 1.0, 0.0);\n    float unit = 1.0 / float(size);\n    \n    if(iFrame == 0 || texelFetch(iChannel2, ivec2(KEY_R,0), 0).r > 0.5)\n    {\n        float c = texelFetch3D(fragCoord3D, iChannel0, size, ivec2(iResolution.xy)).r;\n        fragColor = vec4(c);\n        return;\n    }\n    \n    vec4 cn = texelFetch3D(fragCoord3D, iChannel1, size, ivec2(iResolution.xy));\n    \n    //if(iFrame > size * size)\n    //{\n    //    fragColor = cn;\n    //    return;\n    //}\n    \n    vec3 c0 = texelFetch3DWhiteBoard(fragCoord3D + ios.xzz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.xzz;\n    vec3 c1 = texelFetch3DWhiteBoard(fragCoord3D + ios.yzz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.yzz;\n    vec3 c2 = texelFetch3DWhiteBoard(fragCoord3D + ios.zxz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zxz;\n    vec3 c3 = texelFetch3DWhiteBoard(fragCoord3D + ios.zyz, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zyz;\n    vec3 c4 = texelFetch3DWhiteBoard(fragCoord3D + ios.zzx, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zzx;\n    vec3 c5 = texelFetch3DWhiteBoard(fragCoord3D + ios.zzy, iChannel1, size, ivec2(iResolution.xy)).rgb + unit * os.zzy;\n\n    float cc0 = dot(c0, c0);\n    float cc1 = dot(c1, c1);\n    float cc2 = dot(c2, c2);\n    float cc3 = dot(c3, c3);\n    float cc4 = dot(c4, c4);\n    float cc5 = dot(c5, c5);\n    \n    vec3 c = c0;\n    float cc = cc0;\n    if(cc1 < cc)\n    {\n        c = c1;\n        cc = cc1;\n    }\n    if(cc2 < cc)\n    {\n        c = c2;\n        cc = cc2;\n    }\n    if(cc3 < cc)\n    {\n        c = c3;\n        cc = cc3;\n    }\n    if(cc4 < cc)\n    {\n        c = c4;\n        cc = cc4;\n    }\n    if(cc5 < cc)\n    {\n        c = c5;\n        cc = cc5;\n    }\n    \n    cc = sqrt(cc);\n    \n    if(cc < cn.a)\n    {\n        fragColor = vec4(c, cc);\n    }\n    else\n    {\n        fragColor = vec4(cn);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 i, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 lastil = texture(iChannel0, vec2(0.125));\n    \n    if(uv.x < 0.25)\n    {\n        i = vec4(0.0);\n        vec2 m = i.xy = iMouse.xy / iResolution.xy;\n        if(iMouse.w > 0.5 || iFrame == 0)\n        {\n            lastil.xy = m;\n        }\n        i.xy = m;\n        vec2 offset = (m - lastil.xy) * MOUSE_STEP;\n        i.zw = mix(lastil.zw, offset, MOUSE_LERP * iTimeDelta);\n    }\n    else if(uv.x < 0.5)\n    {\n        if(iFrame == 0)\n        {\n            i = vec4(INIT, 0.0, 0.0);\n        }\n        else\n        {\n            i = texture(iChannel0, vec2(0.375));\n            i.xy += lastil.zw;\n            i.x = fract(i.x);\n            i.y = clamp(i.y, 0.0, 1.0);\n        }\n    }\n    else\n    {\n        if(iFrame == 0)\n        {\n            i = vec4(INITDISTANCE, 0.0, 0.0, 0.5);\n        }\n        else\n        {\n            float wsInput = texelFetch(iChannel1, ivec2(KEY_W,0), 0).r - texelFetch(iChannel1, ivec2(KEY_S,0), 0).r;\n            wsInput = wsInput * 0.5 + 0.5;\n            i = texture(iChannel0, vec2(0.75));\n            i.w = mix(i.w, wsInput, ZOOM_LERP * iTimeDelta);\n            i.x -= (i.w * 2.0 - 1.0) * ZOOM_STEP;\n            i.x = clamp(i.x, MINDISTANCE, MAXDISTANCE);\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}