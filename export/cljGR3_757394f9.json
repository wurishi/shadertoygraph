{"ver":"0.1","info":{"id":"cljGR3","date":"1673620617","viewed":6471,"name":"Power (Chainsaw Man)","username":"panna_pudi","description":"https://www.youtube.com/watch?v=HEwAiwttN10","likes":142,"published":1,"flags":64,"usePreview":1,"tags":["fbm","animation","power","anime","reproduction","chainsawman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsdGzr","filepath":"https://soundcloud.com/streetwise-rhapsody/kick-back-chainsaw-man-opening-instrumental-cover?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/streetwise-rhapsody/kick-back-chainsaw-man-opening-instrumental-cover?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Power by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wrighter, Shane, z0rg, bendzz, Tater\n// BigWings, FabriceNeyret, iq and Blackle for sharing their knowledge\n//\n// Stinky Girl\n//\n// More anime girls on shadertoy:\n//\n// Code:002 by Pidhorskyi\n// https://www.shadertoy.com/view/tlsfzf\n\nfloat fbm(vec2 st, float n) {\n    st *= 3.;\n\n    float s = .5;\n    float ret = 0.;\n    for (float i = min(0., float(iFrame)); i < n; i++) {\n        ret += noise(st) * s;\n        st *= 2.5, s /= 2.;\n        st *= rot45;\n        st.y += iTime * 0.05;\n    }\n    return ret;\n}\n\nvec3 background(vec2 uv) {\n    uv *= rot(-PI / 2.);\n    uv = clog(uv);\n    uv.x -= iTime * 0.1;\n    uv /= PI;\n    float fa1 = fbm(uv * rot(sin(uv.x) * 0.001), 5.);\n    float fb1 = fbm(uv, 5.);\n\n    float fa2 = fbm(uv + sin(uv.x * 15.) + fa1 * 5., 4.);\n    float fb2 = fbm(uv + fb1, 5.);\n\n    //float fa3 = fbm(uv * 1.5 + fa2, 5.);\n\n    vec3 col = vec3(0);\n    col = mix(col, BACKGROUND_COLOR, pow(sat(fb2 * 2.4), 1.5));\n    col = mix(col, vec3(0.4, 0.3, 0.7), pow(sat(fb2 * .7), 1.9));\n    col = mix(col, vec3(0.3, 0.6, 0.6), pow(sat(fa2 * 1.5), 20.) * 0.7);\n    col = mix(col, vec3(0.), voronoi(uv * 10. + fa1 * 4.) * .8);\n\n    col.yz *= rot(-0.16);\n\n    return col;\n}\n\nstruct Params {\n    float stroke;\n    float displacement;\n    float time;\n    float shift;\n};\n\nfloat sd_teeth(vec2 coords,\n               float t,\n               float width,\n               float spacing,\n               vec2 size,\n               vec2 fang_range,\n               float fang_length,\n               float x) {\n    // center on curve middle\n    coords.y -= (t - 0.5) * width;\n    coords.y = op_rem_lim(coords.y, spacing, width + spacing / 1.3);\n    coords *= rot(-1.57);\n    // make fangs longer\n    fang_range *= spacing / width * 2.;\n    float off =\n        fang_length * smoothstep(fang_range.x, fang_range.y, abs(t * 2. - 1.));\n    size += vec2(x * off, off);\n    // move outwards\n    coords.y += size.y;\n    float tooth = sd_trig_isosceles(coords, size);\n    return tooth;\n}\n\nfloat make_mouth(inout vec4 final_color, vec2 uv, Params p) {\n    uv *= 1.15;\n    uv.y -= -0.02;\n    uv *= rot(0.03);\n    float poff = remap01(p.shift, -0.05, 0.05);\n    float lip_off = remap01(p.shift, 0., 0.2);\n\n    vec2 a = vec2(-0.5, 0.0 + poff);\n    vec2 b = vec2(0., -0.70);\n    vec2 c = vec2(0.5, 0.0 + poff);\n\n    float width = 3.8;\n    float spacing = .26;\n    vec2 size = vec2(0.25, 0.07);\n    vec4 curve_lower = sd_bezier_rep(uv, a, b, c);\n    float teeth_lower = sd_teeth(curve_lower.yz, curve_lower.w, width, spacing,\n                                 size, vec2(2.4, 5.3), 0.031, -8.);\n\n    vec2 la = c - vec2(0.04, 0.02);\n    vec2 lb = vec2(0., 0.1 + lip_off);\n    vec2 lc = a - vec2(-0.04, 0.02);\n\n    width = 3.7;\n    spacing = .31;\n    size = vec2(0.24, 0.09);\n    vec4 curve_upper = sd_bezier_rep(uv, la, lb, lc);\n    float teeth_upper = sd_teeth(curve_upper.yz, curve_upper.w, width, spacing,\n                                 size, vec2(3., 4.), 0.06, -1.);\n\n    float mouth = max(curve_lower.x, curve_upper.x);\n    LayerFlat(mouth, SKIN_COLOR * 0.35);\n    vec2 tuv = uv - vec2(0., -0.48 + poff);\n    tuv.x = abs(tuv.x);\n    float tongue = sd_line(tuv, vec2(0.1, 0.20), vec2(-0.3, 0.)) - 0.19 +\n                   p.displacement * 0.002;\n    tongue = max(tongue, mouth);\n    LayerFlat(tongue, BRIGHT_RED);\n    LayerStroked(teeth_upper, TEETH_COLOR, p.stroke * 1.3);\n    LayerStroked(teeth_lower, TEETH_COLOR, p.stroke * 1.3);\n    float border = smin(abs(curve_lower.x), abs(curve_upper.x), 0.1);\n    LayerFlat(border - 0.004, BORDER_COLOR);\n\n    vec2 huv = uv - vec2(0.06, -0.38 + poff * 0.4);\n    huv *= rot(-0.15);\n    huv *= vec2(0.3, 1.);\n    huv.y -= sqrt(pow2(huv.x) + 0.0001) * 0.5;\n    float highlight =\n        sd_circle(huv, max(0.015, smoothstep(-0.8, 1., p.shift) * 0.02));\n    draw_highlight(final_color, highlight);\n\n    return curve_lower.x - p.stroke * 0.5;\n}\n\nvec2 head_tranform(vec2 uv, Params p, float amp) {\n    vec2 head_uv = uv;\n    head_uv.y -= 0.85;\n    head_uv -= vec2(0.04, 0.1) * p.shift * amp;\n    head_uv *= rot(remap01(p.shift, 0., 0.05));\n    return head_uv;\n}\n\nvec2 head_tranform_point(vec2 p, Params par, float amp) {\n    vec2 head_p = p;\n    head_p += vec2(0.04, 0.1) * par.shift * amp;\n    head_p *= rot(-remap01(par.shift, 0., 0.05));\n    return head_p;\n}\n\nfloat make_head(inout vec4 final_color, vec2 uv, Params p) {\n    uv -= vec2(0.00, 0.8);\n    float egg = sd_egg(vec2(uv.x, -uv.y), 0.95, 0.3);\n\n    vec2 euv = uv - vec2(0.84, -0.71);\n    float b = dot(euv - 0.35, vec2(-4.88, 0.2));\n    float ear =\n        sd_uneven_capsule(euv, vec2(0.04, -0.04), vec2(0.17, 0.33), 0.07, 0.20);\n    ear = smax(ear, -b, 0.4);\n    float head = smin(egg, ear, 0.13);\n    LayerStroked(head, SKIN_COLOR, p.stroke);\n\n    float snail =\n        sd_uneven_capsule(euv, vec2(0.04, 0.05), vec2(0.17, 0.35), 0.10, 0.13);\n    snail = smax(snail, -b, 0.87);\n    snail = smax(snail, -egg, 0.4);\n    snail = smax(snail, -sd_circle(euv - vec2(0.01, 0.15), 0.05), 0.54);\n    LayerStroked(snail, vec3(0.5, 0.1, 0.1) * 0.4, p.stroke * 0.7);\n    float snail_inner = sd_uneven_capsule(\n        euv - pow2(uv.x) * 0.00, vec2(0.08, 0.15), vec2(0.09, 0.3), 0.03, 0.07);\n    snail_inner = max(snail_inner, snail);\n    LayerStroked(snail_inner, vec3(0.5, 0.1, 0.1) * 0.25, p.stroke * 0.9);\n\n    float highlight = 1e9;\n    float base = abs(egg - 0.015) - 0.01;\n    float right = base + smooth_hill(uv.x, -0.62, -0.26, 0.505);\n    highlight = min(highlight, right);\n    float left = base + smooth_hill(uv.x, 0.56, -0.39, 0.58) * 0.1;\n    left = max(left, dot(uv, vec2(2.14, -0.13)) - 1.82);\n    highlight = min(highlight, left);\n    highlight = max(highlight, egg);\n    float on_ear = abs(ear - 0.015) - 0.01;\n    on_ear += smooth_hill(uv.x, 1., -0.61, 0.98) * 0.1;\n    on_ear = max(on_ear, dot(uv, vec2(-0.54, 0.54)) + 0.88);\n    on_ear = max(on_ear, ear);\n    highlight = min(highlight, on_ear);\n\n    draw_highlight(final_color, highlight);\n\n    return head;\n}\n\nvoid make_nose(inout vec4 final_color, vec2 uv, Params p) {\n    uv.y -= -0.02;\n    vec2 nuv = vec2(abs(uv.x), uv.y);\n    uv -= vec2(0.08, 0.14 + remap01(p.shift, 0., 0.15));\n    nuv -= vec2(0.08, 0.14 + remap01(p.shift, 0., 0.15));\n    vec2 def = vec2(-1.06, 0.21);\n    nuv.x -= max(0.0, dot(nuv, def));\n    float shadow = sd_line(uv, vec2(-0.02, 0.03), vec2(0.05, 0.04)) - 0.02;\n    float ds =\n        sd_line(uv, vec2(0.05, 0.06), vec2(0.06, 0.08 + p.shift * 0.06)) - 0.01;\n    shadow = smin(shadow, ds, 0.10);\n    float nostrils = sd_circle(nuv, 0.04);\n    shadow = max(shadow, -nostrils + 0.008);\n    nostrils = abs(nostrils) - 0.004;\n    nostrils = max(nostrils, dot(nuv - vec2(0., 0.025), vec2(-0.06, -0.21)));\n    LayerFlat(nostrils, BORDER_COLOR);\n    draw_highlight(final_color, shadow);\n}\n\nvec2 translate_rotate(in vec2 p, in vec2 off, in float a) {\n    p = p - off;\n    p *= rot(a);\n    return p;\n}\n\nfloat intersection(float d1, float d2) {\n    float dmin = min(abs(d1), abs(d2));\n    return dmin * sign(d1) * sign(d2);\n}\n\nfloat make_body(inout vec4 final_color, vec2 uv, Params p) {\n    vec2 left_shoulder = vec2(0.98, -0.33), left_top = vec2(0.51, 1.06);\n    vec2 a = left_shoulder, b = vec2(-0.001, -0.29), c = left_top;\n    float base = sd_bezier_convex(uv, a, b, c);\n    float body = base;\n\n    vec2 right_shoulder = vec2(-1.16, -0.22), right_top = vec2(-0.37, 1.06);\n    a = right_top, b = vec2(-0.16, -0.30), c = right_shoulder;\n    base = sd_bezier_convex(uv, a, b, c);\n    body = intersection(body, base);\n\n    a = left_top, c = right_top, b = (a + c) / 2. - vec2(0., 0.1);\n    base = sd_bezier_convex(uv, a, b, c);\n    body = intersection(body, base);\n\n    vec2 right_side = vec2(-2.14, -1.71);\n    vec2 left_side = vec2(2.07, -2.17);\n\n    a = right_side, c = left_side, b = (a + c) / 2. + vec2(0., -0.1);\n    base = sd_bezier_convex(uv, a, b, c);\n    body = intersection(body, base);\n\n    a = right_shoulder, b = vec2(-2.3, -0.02), c = right_side;\n    float rbase = sd_bezier_convex(uv, a, b, c);\n    body = intersection(body, rbase);\n\n    a = left_side, b = vec2(2.79, -0.24), c = left_shoulder;\n    float lbase = sd_bezier_convex(uv, a, b, c);\n    body = intersection(body, lbase);\n\n    float arm = sd_line(uv, vec2(1.6, -1.03), vec2(2.76, -1.73)) - 0.5;\n    body = smin(body, arm, 0.1);\n\n    vec2 huv = head_tranform(uv, p, 0.5) - vec2(0., -0.15);\n    float head_shadow = sd_egg(vec2(huv.x, -huv.y), 0.5, 0.07);\n    head_shadow = max(head_shadow, body);\n\n    // collar bones\n    float areas = 1e9, strokes = 1e9;\n    a = vec2(-0.28, 0.09), b = vec2(-0.07, -0.53), c = vec2(-0.64, -0.56);\n    base = sd_bezier_convex(uv, a, b, c);\n    areas = intersection(areas, base);\n    b = vec2(-0.09, -0.63);\n    base = sd_bezier_convex(uv, a, b, c);\n    areas = intersection(areas, base);\n\n    a = vec2(-1.27, -0.28), c = vec2(-0.26, -0.60), b = vec2(-1.06, -0.52);\n    float bone_base = sd_bezier(uv, a, b, c).x;\n    strokes = min(strokes, abs(bone_base) - 0.005);\n    areas = max(areas, bone_base);\n    vec2 tuv = uv + vec2(1.11, 0.345);\n    tuv *= rot(-2.72);\n    float edge = sd_trig_isosceles(tuv, vec2(0.3, 0.2)) - 0.1;\n    edge = max(edge, bone_base);\n    areas = min(areas, edge);\n    c = vec2(1.23, -0.43), a = vec2(0.22, -0.60), b = vec2(1.18, -0.60);\n    bone_base = sd_bezier(uv, a, b, c).x;\n    strokes = min(strokes, abs(bone_base) - 0.005);\n    tuv = uv + vec2(-1.09, 0.47);\n    tuv *= rot(-3.3);\n    edge = sd_trig_isosceles(tuv, vec2(0.3, 0.2)) - 0.1;\n    edge = max(edge, bone_base);\n    areas = min(areas, edge);\n    a = vec2(-0.24, -0.61), c = vec2(0.20, -0.6), b = vec2(-0.01, -0.84);\n    strokes = smin(strokes, abs(sd_bezier(uv, a, b, c).x) - 0.005, 0.02);\n\n    a = vec2(0.28, 0.08), b = vec2(0.14, -0.51), c = vec2(0.51, -0.60);\n    base = sd_bezier_convex(uv, a, b, c);\n    areas = intersection(areas, base);\n    b = vec2(0.069, -0.62);\n    base = sd_bezier_convex(uv, a, b, c);\n    areas = intersection(areas, base);\n\n    // arms\n    a = vec2(1.70, -1.17), b = vec2(1.52, -1.81), c = vec2(5.63, -4.82);\n    vec2 bz = sd_bezier(uv, a, b, c);\n    areas = min(areas, abs(bz.x) - 0.6 * smoothstep(-0.04, 0.91, bz.y));\n    a = vec2(-1.31, -1.09), b = vec2(-1.20, -1.48), c = vec2(-1.63, -2.13);\n    bz = sd_bezier(uv, a, b, c);\n    areas = min(areas, abs(bz.x) - 0.05 * smoothstep(-0.11, 0.39, bz.y));\n\n    // chest\n    a = vec2(-0.26, -0.98), b = vec2(0.07, -1.12), c = vec2(0.23, -2.24);\n    bz = sd_bezier(uv, a, b, c);\n    float cleavage = abs(bz.x) - 0.1 * smoothstep(-0.07, 0.9, bz.y) -\n                     0.025 * pow2(sin(bz.y * 6.32 + 12.76));\n    areas = min(areas, cleavage);\n    \n    float w = 0.003;\n    float on_neck = sd_line_y(uv - vec2(0.17, -0.08), 0.3, w * 2.);\n    on_neck =\n        smin(on_neck, sd_line_y(uv - vec2(0.16, 0.02), 0.2, w * 2.), 0.02);\n    vec2 luv = translate_rotate(uv, vec2(0.21, 0.), 0.1);\n    on_neck = min(on_neck, sd_line_y(luv, 0.2, w * 1.5));\n\n    float weirmo = sin(uv.x * 10. + p.displacement * 24. + 3.1) * 0.003;\n    LayerStroked(body, SKIN_COLOR, p.stroke);\n    LayerFlat(on_neck, BLOOD_COLOR);\n    LayerFlat(head_shadow, vec4(SKIN_COLOR * 0.01, 0.5));\n    // TODO: should be the same color as head shadow\n    LayerStrokedMask(areas, vec4(vec3(0.3, 0.1, 0.1) * .25, 0.9), p.stroke,\n                     weirmo);\n    LayerFlat(strokes + weirmo, BORDER_COLOR);\n\n    float hbase = abs(body - 0.015) - 0.01;\n    float highlight = hbase + smooth_hill(uv.x, 1.94, -1.05, 0.55) * 0.05;\n    highlight =\n        min(highlight, hbase + smooth_hill(uv.x, -1.63, -0.49, 0.28) * 0.05);\n    highlight = max(highlight, body);\n    draw_highlight(final_color, highlight);\n\n    return body;\n}\n\nfloat make_hair_back(inout vec4 final_color, vec2 uv, Params p) {\n    // right side\n    vec2 c = vec2(1.16, 1.69), b = vec2(1.49, 0.69), a = vec2(3.36, -0.04);\n    c = head_tranform_point(c, p, .75);\n    vec2 base = sd_bezier(uv, a, b, c);\n    float hair = max(base.x, -uv.x);\n    vec2 cuv = translate_rotate(uv - vec2(1., 1.) * p.shift * 0.01,\n                                vec2(-0.19, -3.03), -1.11);\n    float cuts = sd_hook(cuv, 4.22, 0.25, 1.);\n    cuv = translate_rotate(uv - vec2(1., 1.) * p.shift * 0.02,\n                           vec2(-1.48, -2.51), 5.8);\n    cuts = min(cuts, sd_hook(cuv, 4.22, 0.1, 1.));\n    cuv = translate_rotate(uv, vec2(-2.65, -1.53), 5.8);\n    cuts = min(cuts, sd_hook(cuv, 4.22, 0.25, 1.));\n    cuv = translate_rotate(uv, vec2(-3.71, -0.12), 6.24);\n    cuts = min(cuts, sd_hook(cuv, 4.22, 0.25, 1.));\n\n    float highlight = abs(base.x + 0.020) - 0.008;\n    highlight = max(highlight, base.x);\n\n    // left side\n    a = vec2(-1.53, 2.5), c = vec2(-1.66, 0.64), b = vec2(-0.76, 0.90);\n    a = head_tranform_point(a, p, 1.);\n    float left_base = sd_bezier_convex(uv, a, b, c);\n    a = vec2(-1.56, 0.66), b = vec2(-2.98, 0.47), c = vec2(-3.15, -0.42);\n    c = head_tranform_point(c, p, 1.);\n    left_base = min(left_base, sd_bezier_convex(uv, a, b, c));\n    left_base = min(left_base, uv.y);\n    hair = min(hair, max(left_base, uv.x));\n    cuv = translate_rotate(uv, vec2(-1.01, -1.51), 0.73);\n    cuts = min(cuts,\n               sd_hook(cuv - vec2(-1., 1.) * p.shift * 0.02, 2.22, 0.25, -1.));\n    cuv = translate_rotate(uv, vec2(1.55, -2.34), 0.3);\n    cuts = min(cuts,\n               sd_hook(cuv - vec2(-1., 0.) * p.shift * 0.02, 4.22, 0.05, -1.));\n    cuv = translate_rotate(uv, vec2(2.0, -2.33), 0.33);\n    cuts = min(cuts, sd_hook(cuv, 4.22, 0.3, -1.));\n    hair = max(hair, -cuts);\n\n    float left_highlight = abs(left_base + 0.025) - 0.011;\n    left_highlight = max(left_highlight, left_base);\n    left_highlight = max(left_highlight, uv.x + 0.8);\n    left_highlight = max(left_highlight, -uv.y + 0.3);\n    highlight = min(highlight, left_highlight);\n    vec2 luv = translate_rotate(uv - vec2(-1., 1.) * p.shift * 0.02,\n                                vec2(-0.95, -1.49), 0.72);\n    float clight = sd_hook(luv, 2.22, 0.25, -1.);\n    luv = translate_rotate(uv - vec2(1., 1.) * p.shift * 0.01,\n                           vec2(-0.33, -3.00), -1.06);\n    clight = min(clight, sd_hook(luv, 4.22, 0.25, 1.));\n    clight = max(hair + p.stroke * 0.9, clight);\n    highlight = min(highlight, clight);\n\n    vec2 huv = (uv + vec2(0.02, 1.02)) * vec2(2., 1.);\n    huv = head_tranform(huv, p, 1.);\n    vec3 hair_color =\n        mix(HAIR_COLOR, HAIR_SHADOW_COLOR, AAstep(sd_circle(huv, 1.6), 0.));\n    LayerStroked(hair, hair_color, p.stroke * 1.2);\n\n    draw_highlight(final_color, highlight);\n\n    return hair;\n}\n\nvoid make_hair_front(inout vec4 final_color,\n                     vec2 uv,\n                     Params p,\n                     float dhead,\n                     float dbody,\n                     float dbhair) {\n    vec2 head_uv = head_tranform(uv, p, 1.);\n    vec2 cuv = head_uv - vec2(5.14, -0.81);\n    float right_hair = sd_circle(cuv, 5.99);\n    right_hair = abs(right_hair) - 0.2;\n    right_hair = max(right_hair, cuv.x);\n    right_hair = max(right_hair, -dbody);\n\n    float hbase = abs(right_hair - 0.015) - 0.01;\n    float highlight = hbase + smooth_hill(uv.y, 0.42, -0.67, 1.09) * 0.1;\n    highlight = max(highlight, right_hair);\n    highlight = max(highlight, uv.x + 0.7);\n\n    vec2 suv = uv - vec2(2.26, 0.13);\n    suv *= rot(0.13);\n    float right_hair_shadow = sd_hook(suv, 3.1, 0.19, -1.);\n    right_hair_shadow = max(right_hair_shadow, -dbody);\n\n    float skin_shadow = -sd_circle(head_uv - vec2(0.91, -0.32), 1.51);\n    skin_shadow = max(skin_shadow, dhead);\n    skin_shadow = max(skin_shadow, -right_hair);\n    skin_shadow = max(skin_shadow, head_uv.x);\n\n    vec2 a = vec2(-0.22, 1.53), c = vec2(-2.9, -1.52), b = vec2(-1.11, -1.04);\n    a = head_tranform_point(a, p, .3);\n    vec2 vuv = uv;\n    vec2 base = sd_bezier(vuv, a, b, c);\n    float right_curl = base.x;\n    right_curl = abs(right_curl) -\n                 remap(sin(base.y * 4.93 + 1.93), -1., 1., 0.01, 0.14) +\n                 smoothstep(0.43, 1.94, base.y) * 0.1;\n    vec2 huv = uv - vec2(-3.21, 2.74);\n    huv -= 0.1 * p.shift;\n    huv *= rot(0.64);\n    skin_shadow = min(skin_shadow, sd_hook(huv, 3.43, -0.1, 1.));\n\n    hbase = abs(right_curl - 0.015) - 0.01;\n    float clight = hbase + smooth_hill(base.y, 0.31, -0.15, 0.24) * 0.1;\n    clight = max(clight, right_curl);\n    clight = max(clight, dot(uv, vec2(0.28, -0.19)) + 0.26);\n    highlight = min(highlight, clight);\n\n    a = vec2(1.26, 1.02), c = vec2(1.00, -0.24), b = vec2(1.55, 0.43);\n    a = head_tranform_point(a, p, .3);\n    base = sd_bezier(uv, a, b, c);\n    float left_curl = base.x, t = base.y, tt = base.y;\n    a = c, c = vec2(1.28, -1.75), b = vec2(0.32, -1.07);\n    left_curl =\n        abs(left_curl) - remap(sin(t * -2.05 + 3.6), -1., 1., 0.01, 0.20);\n    base = sd_bezier(uv, a, b, c);\n    float sec = base.x;\n    t = 1. - base.y;\n    sec = abs(sec) - remap(sin(t * -2.05 + 3.6), -1., 1., 0.01, 0.20);\n    left_curl = min(left_curl, sec);\n    huv = translate_rotate(uv, vec2(1.99, -1.3), 0.47);\n    float lcurl_shadow = sd_hook(huv, 1.5, 0.2, -1.);\n    lcurl_shadow = max(lcurl_shadow, left_curl + p.stroke);\n    huv = translate_rotate(uv, vec2(-0.19, 0.95), 0.05);\n    float sh = sd_hook(huv, 1.5, 0.2, 1.);\n    sh = max(sh, -left_curl);\n    sh = max(sh, -dbody);\n    sh = max(sh, dbhair + p.stroke * 1.2);\n    lcurl_shadow = min(lcurl_shadow, sh);\n\n    hbase = abs(left_curl - 0.015) - 0.01;\n    clight = hbase + smooth_hill(tt, 0.54, -0.46, 0.7) * 0.1;\n    clight = max(clight, left_curl);\n    clight = max(clight, dot(uv, vec2(-0.47, 0.07)) + 0.62);\n    highlight = min(highlight, clight);\n\n    // LayerFlat(skin_shadow, vec4(SKIN_COLOR * 0.3, 0.5));\n    LayerFlat(skin_shadow, vec4(final_color.rgb * 0.2, 0.5));\n    float mask = dot(head_uv, vec2(5.13, 1.31)) + 3.81;\n    LayerStrokedMask(right_hair, vec4(HAIR_COLOR, 1.), p.stroke, mask);\n    mask = dot(suv, vec2(-3.86, -0.54)) + -12.;\n    LayerStrokedMask(right_hair_shadow, vec4(HAIR_SHADOW_COLOR, 1.),\n                     p.stroke * 1.4, mask);\n\n    LayerStroked(right_curl, HAIR_COLOR, p.stroke * 1.1);\n    mask = dot(uv, vec2(0.6, -0.48)) + -0.33;\n    LayerStrokedMask(left_curl, vec4(HAIR_COLOR, 1.), p.stroke * 1.4, mask);\n    LayerFlat(lcurl_shadow, vec4(HAIR_SHADOW_COLOR, 1.));\n\n    draw_highlight(final_color, highlight);\n}\n\nvoid make_blood(inout vec4 final_color,\n                vec2 uv,\n                Params p,\n                float dmouth,\n                float dhead) {\n    vec2 head_uv = head_tranform(uv, p, 1.);\n    float blood = 1e9;\n\n    float w = 0.003;\n    vec2 luv = translate_rotate(head_uv, vec2(0.64, 0.04), -0.53);\n    float lines = sd_line_y(luv, 0.15, w);\n    luv = translate_rotate(head_uv, vec2(0.66, 0.07), -0.53);\n    lines = min(lines, sd_line_y(luv, 0.11, w));\n    luv = translate_rotate(head_uv, vec2(0.68, 0.09), -0.63);\n    lines = min(lines, sd_line_y(luv, 0.09, w * 1.5));\n    blood = min(blood, lines);\n\n    luv = translate_rotate(head_uv, vec2(0.55, -0.18), -0.1);\n    float on_chin = sd_line_y(luv, 0.15, 0.015);\n    on_chin =\n        smin(on_chin, sd_circle(head_uv - vec2(0.57, -0.24), 0.015), 0.09);\n    float cut_plane = dot(head_uv, vec2(0.71, 0.52)) - 0.36;\n    on_chin = max(on_chin, cut_plane);\n    blood = min(blood, on_chin);\n\n    float on_mouth = sd_circle(head_uv - vec2(0.24, -0.53), 0.016);\n    on_mouth = smin(\n        on_mouth, sd_line_y(head_uv - vec2(0.235, -0.53), 0.34, w * 2.5), 0.05);\n    on_mouth =\n        max(on_mouth, -sd_line_y(head_uv - vec2(0.22, -0.535), 0.19, w * 3.5));\n    float poff = remap01(p.shift, -0.05, 0.05);\n    luv =\n        translate_rotate(uv, vec2(0.19 + poff * 0.3, 0.64 + poff * 1.40), 0.9);\n    float s = 0.12;\n    on_mouth = smin(\n        on_mouth,\n        sd_line_y(luv / s, 1.4, 0.0025) * s - fbm(head_uv * 2.73 + 0.1, 4.) * s,\n        0.06);\n    on_mouth = smin(on_mouth, dmouth + 0.004, 0.07);\n    on_mouth = max(on_mouth, -dmouth + 0.002);\n    blood = min(blood, on_mouth);\n\n    LayerFlat(blood, BLOOD_COLOR);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    uv *= 1.5;\n    uv.y -= 0.1;\n    float time = iTime;\n\n    float t = (time) + 0.1;\n    uv += (vec2(fbm(vec2(t, 0.), 3.), fbm(vec2(t, 1.), 3.)) * 2. - 1.) * 0.025 *\n          (1. - length(uv * 0.05));\n    Params p;\n    p.time = time;\n    p.shift = cos(p.time) * 0.5 + 0.5;\n    p.displacement = fbm(uv * 2.91, 2.) * 0.42;\n    p.stroke = fwidth(uv.y) * 0.5 + p.displacement * 0.05;\n\n    uv *= rot(0.05);\n\n    vec4 final_color = vec4(vec3(0.051), 1.);\n    final_color.rgb = background(uv);\n\n    float dbhair = make_hair_back(final_color, uv, p);\n    float dbody = make_body(final_color, uv, p);\n    vec2 head_uv = head_tranform(uv, p, 1.);\n    float dhead = 1e9, dmouth = 1e9;\n    if (uv.y > -0.1) {\n        dhead = make_head(final_color, head_uv, p);\n        dmouth = make_mouth(final_color, head_uv, p);\n        make_nose(final_color, head_uv, p);\n        make_blood(final_color, uv, p, dmouth, dhead);\n    }\n    make_hair_front(final_color, uv, p, dhead, dbody, dbhair);\n\n    final_color.rgb =\n        mix(final_color.rgb, vec3(0.), smoothstep(1.50, -2.84, uv.y));\n\n    vec3 col = final_color.rgb;\n\n    col = sat(col);\n    col = pow(col, vec3(1. / 1.9));\n    col = smoothstep(0., 1., col);\n    col = pow(col, vec3(1.74, 1.71, 1.48));\n    // col = pow(col, vec3(2.33, 1.47, 2.1));\n    // col = pow(col, vec3(2.15, 1.29, 1.43));\n    //col = pow(col, vec3(1. / 2.2));\n    \n    vec2 in_uv = fragCoord / iResolution.xy;\n    col *= sat(pow(500. * in_uv.x * in_uv.y * (1. - in_uv.x) * (1. - in_uv.y), .256));\n    \n    col += noise(uv * 500.) * .015 * smoothstep(-1.47, 0.58, uv.y);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec3 BLOOD_COLOR = vec3(179, 236, 15) / 255.;\nconst vec3 BACKGROUND_COLOR = vec3(179, 236, 15) / 255.;\nconst vec3 BRIGHT_RED = vec3(254, 81, 51) / 255.;\nconst vec3 TEETH_COLOR = vec3(224, 195, 226) / 255. * 1.2;\nconst vec3 BORDER_COLOR = vec3(0.01);\nconst vec3 SKIN_COLOR = vec3(158, 0, 24) / 255.;\nconst vec3 HIGHLIGHT_COLOR = vec3(240, 48, 18) / 255. * 1.2;\nconst vec3 HAIR_COLOR = vec3(68, 0, 50) / 255.;\nconst vec3 HAIR_SHADOW_COLOR = vec3(28, 0, 62) / 255.;\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\n#define sat(x) clamp(x, 0., 1.)\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\nfloat pow2(float x) {\n    return x * x;\n}\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\nfloat cross2(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat smooth_hill(float x, float off, float width, float gap) {\n    x -= off;\n    float start = width, end = width + max(0., gap);\n    return smoothstep(-end, -start, x) - smoothstep(start, end, x);\n}\nfloat remap(float val, float start1, float stop1, float start2, float stop2) {\n    return start2 + (val - start1) / (stop1 - start1) * (stop2 - start2);\n}\nfloat remap01(float val, float start, float stop) {\n    return start + val * (stop - start);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 3.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    // f *= f * f * (f * (f * 6. - 15.) + 10.);\n\n    float a = hash21(p + vec2(0, 0));\n    float b = hash21(p + vec2(1, 0));\n    float c = hash21(p + vec2(0, 1));\n    float d = hash21(p + vec2(1, 1));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nmat2 rot45 = mat2(0.707, -0.707, 0.707, 0.707);\n\nfloat voronoi(vec2 uv) {\n    float d = 1e9;\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    for (float i = -1.; i <= 1.; i++) {\n        for (float j = -1.; j <= 1.; j++) {\n            vec2 nbor = vec2(i, j);\n            d = min(d, length(uv - noise(id + nbor) - nbor));\n        }\n    }\n    return d;\n}\n\nvec2 clog(vec2 z) {\n    float r = length(z);\n    return vec2(log(r), atan(z.y, z.x));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\nfloat smax(in float a, in float b, in float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + h * h * k * (1.0 / 4.0);\n}\n\nfloat sd_circle(vec2 p, float r) {\n    return length(p) - r;\n}\nfloat sd_box(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat sd_hook(vec2 p, float r, float a, float s) {\n    float base = max(sd_circle(p, r), -p.x * sign(s));\n    p.x -= r;\n    p *= rot(a);\n    p.x += r;\n    float crop = sd_circle(p, r);\n\n    return max(base, -crop);\n}\nfloat sd_line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float k = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return distance(p, mix(a, b, k));\n}\nfloat sd_line_y(vec2 p, float h, float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat op_rem_lim(in float p, in float s, in float l) {\n    return p - s * clamp(round(p / s), -l, l);\n}\n\nfloat sd_trig_isosceles(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                 vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sd_uneven_capsule(vec2 p, vec2 pa, vec2 pb, float ra, float rb) {\n    p -= pa;\n    pb -= pa;\n    float h = dot(pb, pb);\n    vec2 q = vec2(dot(p, vec2(pb.y, -pb.x)), dot(p, pb)) / h;\n\n    q.x = abs(q.x);\n    float b = ra - rb;\n    vec2 c = vec2(sqrt(h - b * b), b);\n\n    float k = cross2(c, q);\n    float m = dot(c, q), n = dot(q, q);\n\n    if (k < 0.0) {\n        return sqrt(h * (n)) - ra;\n    } else if (k > c.x) {\n        return sqrt(h * (n + 1.0 - 2.0 * q.y)) - rb;\n    }\n    return m - ra;\n}\n\n// TODO: rb?!?!?!?!?\nfloat sd_egg(in vec2 p, in float ra, in float rb) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y < 0.0)             ? length(vec2(p.x, p.y)) - r\n            : (k * (p.x + r) < p.y) ? length(vec2(p.x, p.y - k * r))\n                                    : length(vec2(p.x + r, p.y)) - 2.0 * r) -\n           rb;\n}\n\nvec3 sd_bezier_base(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n    float t = 0.;\n\n    float res = 0.0;\n    float sgn = 1.0;\n\n    float p = ky - kx * kx;\n    float p3 = p * p * p;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float h = q * q + 4.0 * p3;\n\n    if (h >= 0.0) {  // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2 q = d + (c + b * t) * t;\n        res = dot2(q);\n        sgn = cross2(c + 2.0 * b * t, q);\n    } else {  // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec2 tt = clamp(vec2(m + m, -n - m) * z - kx, 0.0, 1.0);\n        vec2 qx = d + (c + b * tt.x) * tt.x;\n        float dx = dot2(qx), sx = cross2(c + 2.0 * b * tt.x, qx);\n        vec2 qy = d + (c + b * tt.y) * tt.y;\n        float dy = dot2(qy), sy = cross2(c + 2.0 * b * tt.y, qy);\n        if (dx < dy) {\n            res = dx;\n            sgn = sx;\n        } else {\n            res = dy;\n            sgn = sy;\n        }\n        t = res;\n    }\n\n    return vec3(res, sgn, t);\n}\nvec2 sd_bezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec3 bz = sd_bezier_base(pos, A, B, C);\n    return vec2(sqrt(bz.x) * sign(bz.y), bz.z);\n}\n\nfloat sd_bezier_convex(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    if (cross2(C - A, B - A) < 0.0) {\n        vec2 t = A;\n        A = C;\n        C = t;\n    }\n    float sa = cross2(A - 0., pos - 0.);\n    float sc = cross2(C - A, pos - A);\n    float s0 = cross2(0. - C, pos - C);\n    float o = cross2(C - A, -A);\n\n    float ts = (1.0 - 2.0 * float(sa < 0. && sc < 0. && s0 < 0.));\n    float ts2 = (1.0 - 2.0 * float(sa > 0. && sc > 0. && s0 > 0.));\n    ts = o > 0. ? ts2 : ts;\n\n    vec3 bz = sd_bezier_base(pos, A, B, C);\n    return sqrt(bz.x) * sign(sc < 0. ? 1.0 : -bz.y) * ts;\n}\n\nvec4 sd_bezier_rep(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 bz = sd_bezier(pos, A, B, C);\n    float t = bz.y;\n    vec2 tangent = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));\n    vec2 normal = vec2(tangent.y, -tangent.x);\n    mat2 mm = mat2(normal, tangent);\n    pos = mix(mix(A, B, t), mix(B, C, t), t) - pos;\n    return vec4(bz.x, pos * mm, t);\n}\n\nvec4 alpha_blending(vec4 d, vec4 s) {\n    // return mix(d, s, s.a);\n    vec4 res = vec4(0.);\n    res.a = mix(1., d.a, s.a);\n    if (res.a == 0.) {\n        res.rgb = vec3(0.);\n    } else {\n        res.rgb = mix(d.rgb * d.a, s.rgb, s.a) / res.a;\n    }\n    return res;\n}\nvoid alpha_blend_inplace(inout vec4 d, in vec4 s) {\n    d = alpha_blending(d, s);\n}\n\nfloat AAstep(float thre, float val) {\n    return smoothstep(-.5, .5, (val - thre) / min(0.03, fwidth(val - thre)));\n}\nfloat AAstep(float val) {\n    return AAstep(val, 0.);\n}\n\nvec4 render(float d, vec4 color) {\n    return vec4(color.rgb, color.a * AAstep(d));\n}\nvec4 render(float d, vec3 color) {\n    return render(d, vec4(color, 1.0));\n}\n\nvec4 render_stroked_masked(float d,\n                           vec4 color,\n                           float stroke,\n                           float stroke_mask) {\n    vec4 stroke_layer = vec4(vec3(0.01), AAstep(d));\n    vec4 color_layer = vec4(color.rgb, AAstep(d + stroke));\n    return vec4(mix(mix(stroke_layer.rgb, color_layer.rgb, AAstep(stroke_mask)),\n                    color_layer.rgb, color_layer.a),\n                stroke_layer.a * color.a);\n}\nvec4 render_stroked(float d, vec4 color, float stroke) {\n    return render_stroked_masked(d, color, stroke, 1.);\n}\nvec4 render_stroked(float d, vec3 color, float stroke) {\n    return render_stroked(d, vec4(color, 1.), stroke);\n}\n\n#define LayerFlat(d, color) alpha_blend_inplace(final_color, render(d, color))\n#define LayerStroked(d, color, stroke) \\\n    alpha_blend_inplace(final_color, render_stroked(d, color, stroke))\n#define LayerStrokedMask(d, color, stroke, mask) \\\n    alpha_blend_inplace(final_color,             \\\n                        render_stroked_masked(d, color, stroke, mask))\n\nvoid draw_highlight(inout vec4 final_color, float highlight) {\n    LayerFlat(highlight, HIGHLIGHT_COLOR);\n    float s = 0.15;\n    alpha_blend_inplace(final_color, vec4(HIGHLIGHT_COLOR,\n                                          0.07 * smoothstep(s, 0., highlight)));\n}\n","name":"Common","description":"","type":"common"}]}