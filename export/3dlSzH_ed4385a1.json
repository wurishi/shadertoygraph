{"ver":"0.1","info":{"id":"3dlSzH","date":"1550610387","viewed":441,"name":"Simple Split Tone Effects","username":"TheSandvichMaker","description":"mouse.x = dry/wet\nmouse.y morphs the split range controls for demonstration","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["filter","color","correction","colorcorrection","tone","split","splittone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 0: don't isolate \n// 1: isolate low range \n// 2: isolate middle range\n// 3: isolate high range\n#define ISOLATE_RANGE 0\n\n// you could use linearstep or smoothstep, i'm not sure\n// which actually looks nicer in practice, but smoothstep\n// looks cooler in graphs.\n#define SPLIT_RANGE_STEP_FUNCTION smoothstep\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define remap(v, a, b) (((v) - (a)) / ((b) - (a)))\n#define linearstep(a, b, v) saturate(remap(v, a, b))\n\nfloat graphFunction(float f, vec2 uv, float thickness)\n{\n    vec2 pix_size = 1.0 / iResolution.xy;\n\tthickness *= pix_size.y;\n    \n    f = (f - 0.5) * (1.0 - thickness) + 0.5 - uv.y;\n    \n    float dist = abs(f - uv.y);\n    return smoothstep(thickness, 0.0, dist);\n}\n\n// split range function\nvec3 splitRange(float lum, vec2 lo, vec2 hi)\n{\n    hi.x = 1.0 - hi.x;\n\n    hi.y = clamp(hi.y, lo.x, hi.x-1e-6);\n    lo.y = clamp(lo.y, lo.x+1e-6, hi.x);\n\n    vec3 res;\n    res.x = SPLIT_RANGE_STEP_FUNCTION(lo.y, lo.x, lum);\n    res.y = SPLIT_RANGE_STEP_FUNCTION(lo.x, lo.y, lum) - SPLIT_RANGE_STEP_FUNCTION(hi.y, hi.x, lum);\n    res.z = SPLIT_RANGE_STEP_FUNCTION(hi.y, hi.x, lum);\n\n    return saturate(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    bool mouse_click = iMouse.z > 0.5;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    if (uv.y < 0.1) col = vec3(uv.x);\n    \n    vec3 dry = col;\n    \n    // padding pads the outer ends of the low and and high ranges,\n    // cutoff controls the end of the low range and the start of the high range.\n    //                          padding   cutoff\n    vec2 lo_range_controls = vec2(0.0,     0.5);\n    vec2 hi_range_controls = vec2(0.0,     0.5);\n    \n    if (mouse_click) \n    {\n        lo_range_controls = saturate(mix(lo_range_controls, vec2(0.4, 0.2), mouse.y - 0.5));\n        hi_range_controls = saturate(mix(hi_range_controls, vec2(0.4, 0.8), mouse.y - 0.5));\n    }\n    \n    // splitRange will return a vec3 of weights, where:\n    // x = low  range\n    // y = mid  range\n    // z = high range\n    // the sum of the weights is always 1 (so long as you keep your inputs in the [0;1] range)\n    float luma = dot(col, vec3(0.333));\n    vec3 weights = splitRange(luma, lo_range_controls, hi_range_controls);\n    \n    // you can use the split range for tints \n    mat3x3 tint_matrix = mat3x3(\n        vec3(1.0, 0.4, 0.6), // low_col\n        vec3(0.2, 0.4, 0.7), // mid_col\n        vec3(1.0, 0.7, 0.2)  // high_col\n    );\n    \n    float high_rolloff = 0.7;\n    \n    // vec3 tint = \n    //     low_col  * weights.x +\n    //     mid_col  * weights.y +\n    //     high_col * weights.z;\n    vec3 tint = tint_matrix * weights;\n    \n    // normalize the tint to try and preserve luminance\n    tint = (tint / (tint.x+tint.y+tint.z)) * 3.0;\n    // roll off the tint near the top to preverse pure white\n    tint = mix(vec3(1.0), tint, SPLIT_RANGE_STEP_FUNCTION(1.0, high_rolloff, luma));\n    \n    col *= tint;\n    \n    // but you can use the split range for other things too \n    //                            lo   mid   hi\n    vec3 split_saturation = vec3(1.0,  1.5,  0.5);\n    float saturation = dot(weights, split_saturation);\n    col = mix(vec3(luma), col, saturation);\n\n    // dry/wet \n    float amount = mouse_click ? mouse.x * 0.75 : 0.5;\n    col = mix(dry, col, amount);\n    \n    // drawing the graph for the gradient\n    vec2 graph_uv = remap(uv, vec2(0.0), vec2(1.0, 0.2));\n    vec3 f = splitRange(graph_uv.x, lo_range_controls, hi_range_controls);\n    vec3 graph_col = vec3(0.0);\n    graph_col += graphFunction(f.x, graph_uv, 20.0) * tint_matrix[0];\n    graph_col += graphFunction(f.y, graph_uv, 20.0) * tint_matrix[1];\n    graph_col += graphFunction(f.z, graph_uv, 20.0) * tint_matrix[2];     \n    col += mix(vec3(dot(graph_col, vec3(0.333))), graph_col, amount);\n    \n#if (ISOLATE_RANGE != 0)\n    if (uv.y > 0.1)\n    {\n        vec3 background_col = \n            (int(fragCoord.x / 32.0) % 2 == 0) != \n            (int(fragCoord.y / 32.0) % 2 == 0) ?\n            vec3(1.0) : vec3(0.5);\n\n        #if   ISOLATE_RANGE == 1\n            col = mix(background_col, col, weights.x);\n        #elif ISOLATE_RANGE == 2\n            col = mix(background_col, col, weights.y);\n        #elif ISOLATE_RANGE == 3\n            col = mix(background_col, col, weights.z);\n        #endif\n    }\n#endif\n    \n\n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}