{"ver":"0.1","info":{"id":"3l3XW4","date":"1611336058","viewed":102,"name":"Attempt at basic shapes","username":"MinimilisticBits","description":"Trying to create basic 3d shapes","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","basic","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Move camera with mouse\n\nconst float ni = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y, a.x)+(c*ni/180.0);    \nreturn vec2(l*cos(ang), l*sin(ang));    \n}\n\n\nfloat capsule(vec3 a, vec3 b, vec3 p, float s){\nfloat h = dot(b-a, p-a)/pow(length(b-a),2.0);\nh = clamp(h,0.0,1.0);\nvec3 q = a + (b-a)*h;\nreturn length(q-p)-s;    \n}\n\nvec3 r(vec3 a, float c){\nreturn ((fract(a/c))*c)-0.5*c;\n}\nfloat r(float a, float c){\nreturn ((fract(a/c))*c)-0.5*c;\n}\n\nfloat box(vec3 p, vec3 c){\nvec3 a = abs(p)-c;\nreturn max(max(a.x,a.y), a.z);\n}\n\nfloat sphere(vec3 p, float s){\nreturn length(p)-s;\n}\n\n\nfloat pyramid(vec3 p){// fix function with position+scale\n//p=r(p, 4.);\n    vec3 pos = p;\n    pos.yz = rot(pos.yz, 45.0);\n    pos.xy = rot(pos.xy, 45.0);\n    pos = vec3(-pos.y, pos.x, pos.z);\n    return max(box(pos, vec3(1.3)), -box(p-vec3(0.0, 0.0, -0.9), vec3(3.0, 3.0, 1.5)));\n}\n\nfloat prism(vec3 p){ //fix function with position + scale\nvec3 ppos = vec3(0.0, 4.0, 2.0);\n    vec3 pos = p-ppos;\n    pos.xy = rot(pos.xy, 90.0);\n    pos.yz = rot(pos.yz, 45.0);\n    return max(box(pos, vec3(1.0)), -box(ppos-p-vec3(0.0,0.0,1.0), vec3(2.0, 2.0, 1.0)) );\n}\n\n\nfloat cone(vec3 pos, float h, float s, vec3 p){ //hallow\n    vec3 a = vec3(pos.xy + normalize(p.xy-pos.xy)*s, pos.z);\n    vec3 b = vec3(pos.xy, pos.z+h);\n    float h1 = dot(b-a, p-a)/pow(length(b-a),2.0);\n    h1 = clamp(h1, 0.0, 1.0);\n    vec3 q = a + (b-a)*h1;\n    return length(q-p)-0.1;\n}\n\nfloat cylinder(vec3 pos, vec3 p, float h, float s){\nvec3 q = vec3(pos.xy, clamp(p.z, pos.z, pos.z+h));\nreturn max(length(q-p)-s, box(pos-p+vec3(0.0, 0.0, h*0.5), vec3(s,s,h*0.5)));    \n}\n\nfloat torus(vec3 pos, vec3 p, float r1, float r2){\n    vec3 pp = vec3(pos.xy + normalize(p.xy-pos.xy)*r1, pos.z);\n    return length(pp-p)-r2;\n}\n\nfloat dis(vec3 p){\n    return min(min(min(min(min(min(min(min(torus(vec3(0.0, 3.0, 4.0*sin(iTime)), p, 2.0, 0.5),\n              cone(vec3(0.0, 3.0, 2.0*sin(iTime)), 3.0, 2.0, p)\n              ),\n              box(vec3(0.0, 3.0, -4.*sin(iTime))-p, vec3(2.0))\n              ),\n              capsule(vec3(-3.0, 3.0, 2.0*sin(iTime)), vec3(3.0, 3.0, 2.0*cos(iTime)),p, 0.6)\n              ),\n              length(vec3(6.0*sin(iTime), 3.0, 2.0)-p)-1.8\n              ),\n              pyramid(p-vec3(4.0, 2.0, 3.0*sin(iTime)))\n              ),\n              prism(p-vec3(-4.0, -1.0, 3.0*cos(iTime)))\n              ),cylinder(vec3(2.0*cos(iTime), 3.0, 4.0*sin(iTime)), p, 3.0, 1.0)),\n              box(vec3(0.0,3.0,-6.0)-p, vec3(40.0,40.0,2.0))\n              );\n           \n}\n\nbool trac(inout vec3 p, vec3 d, inout float dd){\n    for(int i = 0; i < 60; i++){\n        dd = dis(p);\n        if(dd < 0.01)return true;\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\nreturn normalize(\nvec3(\ndd-dis(vec3(p.x-0.1, p.yz)),\ndd-dis(vec3(p.x, p.y-0.1, p.z)),\ndd-dis(vec3(p.xy,p.z-0.1))\n));\n}\n\nfloat shadow(vec3 p, vec3 lig){\nvec3 d = normalize(lig-p);\n    float dd,lg;\n    for(int i = 0; i < 60; i++){\n        lg = length(lig-p)-1.3;\n        dd = min(dis(p), lg);\n        if(dd < 0.01)break;\n        p+=d*dd;\n    }\n    \n    if(dd < 0.01 && dd == lg)return 1.0;\n    return 0.2;\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a,2.0))/(ni*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, -mouse.x*90.);\n    vec3 p = vec3(0.0, -5.0, 2.0);\n    \n    vec3 col = vec3(0.3, 0.5, 0.6)*max(pow(dot(d, vec3(0.0,0.0,1.0)),0.5),0.2)*2.0;\n    float dd;\n    vec3 prevp;\n    vec3 lig = vec3(8.0, 4.0, 9.0);\n    if(trac(p,d,dd)){\n       vec3 n = norm(p,dd);\n       vec3 light = normalize(lig - p);\n       col = vec3(1.0)*max(dot(n,light),0.0)*shadow(p-d*0.1,lig)+\n           (vec3(0.3, 0.5, 0.6)*max(pow(dot(reflect(d,n), vec3(0.0,0.0,1.0)),0.5),0.2))*0.9 + rough(0.4, dot(reflect(d,n),light)); \n        \n        p-=d*0.2;\n        d = reflect(d,n);\n        if(trac(p,d,dd)){\n        n = norm(p,dd);\n        light = normalize(lig - p);\n        col += vec3(1.0)*max(dot(n,light),0.0)*shadow(p-d*0.1,lig)+\n           (vec3(0.3, 0.5, 0.6)*max(pow(dot(reflect(d,n), vec3(0.0,0.0,1.0)),0.5),0.2))*0.9+ rough(0.4, dot(reflect(d,n),light)); \n        }else{\n        col+= vec3(0.3, 0.5, 0.6)*max(pow(dot(d, vec3(0.0,0.0,1.0)),0.5),0.2)*2.0;\n        }\n        col/=2.0;\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}