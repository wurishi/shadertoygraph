{"ver":"0.1","info":{"id":"3tjGRW","date":"1558642695","viewed":233,"name":"Cornell Box RT","username":"Crimz8n","description":"Cornell Box with ray traced distance fields.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["ray","light","sphere","box","metal","cornell","trace","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EXPOSURE 4.0\n#define GAMMA 2.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 data = texture(iChannel0, uv);\n\tvec3 color = data.xyz / data.w;\n    color = vec3(1.0) - exp(-color*EXPOSURE);\n\tcolor = pow(color, vec3(1.0/GAMMA));\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON 0.0001\n#define FOV 35.0\n#define FAR 100.0\n#define STEPS 2048\n#define BOUNCES 4\n\n//\n// Utility\n//\nmat4 transform(vec3 translation, vec3 rotation, vec3 scale) {\n\tfloat cx = cos(radians(rotation.x));\n\tfloat sx = sin(radians(rotation.x));\n\tfloat cy = cos(radians(rotation.y));\n\tfloat sy = sin(radians(rotation.y));\n\tfloat cz = cos(radians(rotation.z));\n\tfloat sz = sin(radians(rotation.z));\n\n\treturn mat4(\n\t\t\t(cy*cz+sy*sx*sz) * scale.x,\n\t\t\t(cx*sz) * scale.x,\n\t\t\t(cy*sx*sz-cz*sy) * scale.x,\n\t\t\t0,\n\t\t\t(cz*sy*sx-cy*sz) * scale.y,\n\t\t\t(cx*cz) * scale.y,\n\t\t\t(cy*cz*sx+sy*sz) * scale.y,\n\t\t\t0,\n\t\t\t(cx*sy) * scale.z,\n\t\t\t(-sx) * scale.z,\n\t\t\t(cy*cx) * scale.z,\n\t\t\t0,\n\t\t\ttranslation.x,\n\t\t\ttranslation.y,\n\t\t\ttranslation.z,\n\t\t\t1\n\t);\n}\n// randomness\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nfloat seed;\nvec2 hash2() {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1,seed+=0.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\nvec3 hash3() {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=0.1,seed+=0.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nvec3 random_in_unit_sphere() {\n    vec3 h = hash3() * vec3(2.,6.28318530718,1.0)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 0.33333333333);\n\treturn r * vec3(sqrt(1.0-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n//\n// Geometry\n//\n// shapes\nfloat plane(in vec3 p, in vec3 n) { return dot(p, -n); }\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n// utils\nvec2 _union(in vec2 x, in vec2 y) { return x.x < y.x ? x : y; }\n// scene\nmat4 box_transform_inverse;\nvec2 scene(vec3 p) { //get hit distance and material at position\n\tvec2 top = vec2(plane(vec3(0.0, 4.0, 0.0) - p, vec3(0.0, -1.0, 0.0)), 2.0);\n\tvec2 bottom = vec2(plane(vec3(0.0, 0.0, 0.0) - p, vec3(0.0, 1.0, 0.0)), 2.0);\n\tvec2 front = vec2(plane(vec3(0.0, 0.0, 10.0) - p, vec3(0.0, 0.0, -1.0)), 2.0);\n\tvec2 back = vec2(plane(vec3(0.0, 0.0, -2.0) - p, vec3(0.0, 0.0, 1.0)), 2.0);\n\tvec2 left = vec2(plane(vec3(-2.0, 0.0, 0.0) - p, vec3(1.0, 0.0, 0.0)), 3.0);\n\tvec2 right = vec2(plane(vec3(2.0, 0.0, 0.0) - p, vec3(-1.0, 0.0, 0.0)), 4.0);\n\tvec2 room = _union(_union(_union(top,bottom), _union(front,back)), _union(left,right));\n\t\n\tvec2 cuboid = vec2(box((vec4(vec3(0.75, 1.5, 0.5) - p, 1.0) * box_transform_inverse).xyz, vec3(0.7, 1.5, 0.7)), 5.0);\n\tvec2 ball = vec2(sphere(vec3(-1.0, 1.25, 0.25) - p, 0.7), 1.0);\n\tvec2 shapes = _union(cuboid, ball);\n\t\n\tvec2 lamp = vec2(box(vec3(0.0, 4.0, 0.0) - p, vec3(0.35, 0.01, 0.35)), 0.0);\n    vec2 bulb = vec2(sphere(vec3(1.25, 0.1, 2.5) - p, 0.1), 0.0);\n    vec2 lights = _union(lamp, bulb);\n\t\n\treturn _union(_union(room, shapes), lights);\n}\nvec3 get_normal(in vec3 p) { //get normal at position\n    vec2 e = vec2(EPSILON, 0.0);\n\treturn normalize(\n\t\t\tvec3(\n\t\t\t\t\tscene(p+e.xyy).x - scene(p-e.xyy).x,\n\t\t\t\t\tscene(p+e.yxy).x - scene(p-e.yxy).x,\n\t\t\t\t\tscene(p+e.yyx).x - scene(p-e.yyx).x\n\t\t\t)\n\t);\n}\n//\n// Materials and lighting\n//\nstruct Ray {\n\tvec3 pos;\n\tvec3 dir;\n\tfloat mat;\n\tvec3 energy;\n};\nbool material(inout Ray ray) {\n\tif(ray.mat == 0.0) { // emission\n\t\tray.energy *= vec3(8.0);\n\t\treturn false;\n\t} else if(ray.mat == 1.0) { // metal\n\t\tray.energy *= vec3(0.8);\n\t\tray.dir = normalize(reflect(ray.dir, get_normal(ray.pos)));\n\t\tray.pos += ray.dir * (2.0*EPSILON);\n\t} else if(ray.mat == 2.0) { // white diffuse\n\t\tray.energy *= vec3(0.8);\n\t\tray.dir = normalize(get_normal(ray.pos) + random_in_unit_sphere());\n\t\tray.pos += ray.dir * (2.0*EPSILON);\n\t} else if(ray.mat == 3.0) { // red diffuse\n\t\tray.energy *= vec3(0.95, 0.05, 0.05);\n\t\tray.dir = normalize(get_normal(ray.pos) + random_in_unit_sphere());\n\t\tray.pos += ray.dir * (2.0*EPSILON);\n\t} else if(ray.mat == 4.0) { // blue diffuse\n\t\tray.energy *= vec3(0.2, 0.2, 0.95);\n\t\tray.dir = normalize(get_normal(ray.pos) + random_in_unit_sphere());\n\t\tray.pos += ray.dir * (2.0*EPSILON);\n\t} else if(ray.mat == 5.0) { // green diffuse\n\t\tray.energy *= vec3(0.05, 0.65, 0.05);\n\t\tray.dir = normalize(get_normal(ray.pos) + random_in_unit_sphere());\n\t\tray.pos += ray.dir * (2.0*EPSILON);\n\t}\n\treturn true;\n}\nvoid sky(inout Ray ray) {\n\tray.energy *= vec3(0.0);\n}\n//\n// Tracing\n//\nbool shoot(inout Ray ray) {\n\tfloat depth = 0.0;\n    for(int i=0; i<STEPS; i++) {\n        vec2 o = scene(ray.pos);\n        if(o.x < EPSILON) {\n\t\t\tray.mat = o.y;\n\t\t\treturn true;\n\t\t}\n\t\tif((depth += o.x) >= FAR)return false;\n\t\tray.pos += ray.dir*o.x;\n    }\n    return false;\n}\nvec3 trace(in Ray ray) {\n\tfor(int i=0; i<BOUNCES+1; i++) {\n\t\tif(!shoot(ray)) {\n\t\t\tsky(ray);\n\t\t\treturn ray.energy;\n\t\t}\n\t\telse if(!material(ray))return ray.energy;\n\t}\n\treturn vec3(0.0);\n}\n//\n// Screen space things\n//\nRay get_ray(in vec2 uv) {\n\tuv = uv*2.0 - 1.0;\n\tuv.x *= float(iResolution.x) / iResolution.y;\n\tRay ray;\n\tray.pos = vec3(0.0, 2.0, 9.0);\n    ray.dir = normalize(vec3(uv*tan(radians(FOV * 0.5)), -1.0));\n\tray.mat = 0.0;\n\tray.energy = vec3(1.0);\n\treturn ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    box_transform_inverse = inverse(transform(vec3(0.0), vec3(0.0, 45.0, 0.0), vec3(1.0)));\n\tvec2 uv = fragCoord/iResolution.xy;\n\tRay ray = get_ray(uv);\n\tvec3 color = trace(ray);\n\tfragColor = vec4(color, 1.0) + texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"}]}