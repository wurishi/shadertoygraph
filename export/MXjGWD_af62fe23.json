{"ver":"0.1","info":{"id":"MXjGWD","date":"1708664995","viewed":303,"name":"Domain Rep in Polar Coords","username":"incre_ment","description":"Domain repetition in both polar coordinate dimensions.  No neighbor checking required for this animation.\nThanks to IQ as always for the knowledge!","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float TAU = 2.*3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;  \n   vec3 col = vec3(0);\n\n   // Number of Radial Cells\n   float numRadCells = 8.;\n\n   // Radial Cells IDs\n   float rCell = round(numRadCells*length(uv));\n\n   // Number of circles per ring. Dependent on radius\n   float numCirc = 6.*rCell;\n   \n   // Angle delta between circles\n   float angDelta = TAU/numCirc;\n   \n   // Angle of UV coordinate\n   float angVal = atan(uv.y, uv.x);\n   \n   // Angular CellID for point\n   float cellID = round(angVal/angDelta);\n   \n   // Rotation amount for cell\n   float rotAng = angDelta*cellID;\n   \n   // Rotate the uv coordinate;\n   vec2 uv_rot = mat2(cos(rotAng),-sin(rotAng),sin(rotAng),cos(rotAng))*uv;\n   \n   // Circle SDF with radius dynamics dependent on time, radial distance, and angle\n   float circSDF = length(uv_rot - vec2(rCell/numRadCells,0.)) - .025+.025*sin((iTime-TAU*length(uv_rot) + rotAng));\n   \n   // Thanks FN!\n   float w = 1./iResolution.y;\n   col += smoothstep(w,-w,circSDF);\n   \n   fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}