{"ver":"0.1","info":{"id":"lfBczG","date":"1722771215","viewed":122,"name":"Redondo Game - Chess Update","username":"rubixcom","description":"The shader responsible for rendering the 3D view of different board games that are available in my game, playable here: https://redondo.web.app\n\nToggle different games and other options in the code.\n\nEarlier version: https://www.shadertoy.com/view/XXtGDS","likes":3,"published":1,"flags":1,"usePreview":1,"tags":["game","chess","board"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The WebGL shader responsible for rendering the 3D view of different board games that are available \n// in my game, playable here: https://redondo.web.app\n\n// Toggle the games and other options by toggling constants in code, below.\n\n// Based on the amazing work and code (c) Inigo Quilez 2013-16.\n// https://iquilezles.org/articles/raymarchingdf/\n// https://iquilezles.org/articles/distfunctions/\n// https://iquilezles.org/articles/rmshadows/\n// https://www.shadertoy.com/view/Xds3zN\n\n// Using Noise functions\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// https://www.shadertoy.com/view/4dS3Wd\n\n// I reserve the copyright to my own code. You are welcome to use it in your own shader on \n// shadertoy.com. I have learned everything about the amazing visuals that you can create with shaders \n// from seeing the amazing work of talented individuals on this site and sharing my work is a way for \n// me to give back to the community. If you can attribute my code back to this shader, it would be \n// nice. If you want to use my code in any other way, please contact me and I would be happy to chat \n// and am likely to allow it.\n\n// Except for the aforementioned use cases, I do not permit the copying or use of this code to train \n// AI models, publishing it without my permission, including it in archives (including archive.org) or \n// publishing screenshots of the output. Please respect my wishes.\n\n// Tweak settings, here:\n\n// Uncomment one of the 4 supported boards\n//#define REDONDO\n#define CHESS\n//#define CHECKERS \n//#define HEXAGON\n\n// Uncomment to use a realistic chess set for chess game\n#define REAL_CHESS_SET\n\n// Uncomment on of these pre configured rendering modes\n//#define NICE_SHAPE_BLACK_BORDERS_MODE\n//#define HQ_MODE\n#define DEFAULT_MODE\n\n// Mobile rendering mode\n//#define MOBILE\n\n// Number of lights 1-3\n#define LIGHTS 1\n\n// Uncomment to render reflections (when turned off, iChannel2 is used for reflections)\n#define REFLECTIONS \n#define REFLECTION_MIX 0.3\n//#define SECONDARY_REFLECTIONS\n#define ENV_MAP_TEXTURE iChannel2\n\n// Uncomment to render transparent pieces with refractions\n#define REFRACTIONS\n#define REFRACTION_MIX 0.3\n#define REFRACTION_INDEX 1.03\n\n// Uncomment to render shadows or colour from refractions\n#define SHADOWS\n\n// Make board surface shiny\n#define SHINY_BOARD\n#define MODERN_BOARD_WITH_ROUNDED_SQUARES\n\n// Uncomment one of 3 for different board/table rendering\n#define GENERATED_TABLE wood\n//#define GENERATED_TABLE spiral\n// Use texture in iChannel1 for table\n//#define TEXTURED_TABLE\n#define TABLE_TEXTURE iChannel1\n#define BOARD_SHADE_WHEN_NOT_GENERATED .5\n\n// This controls the glow of selected piece and piece path highlighting\n#define BOARD_GLOW\n//#define CIRCLE_HIGHLIGHT\n#define SQUARE_HIGHLIGHT\n//#define BOARD_GLOW_NOISE\n//#define BOARD_GLOW_NOISE_FUNC noise(p * 5.) / 50.\n\n// Uncomment one of 2 piece rendering options\n//#define STRIPED_PIECES\n// Use texture in iChannel3 for pieces (best to turn off refraction of this)\n//#define TEXTURED_PIECES\n#define PIECES_TEXTURE iChannel3\n\n// Show selection regions used by the game to drive piece selection\n// #define DEBUG_SELECTION_FIELD\n\n// More complex stuff here, best to leave it alone:\n#ifdef MODERN_BOARD_WITH_ROUNDED_SQUARES\n    #define ROUNDED_CORNERS_ENABLED\n    #define boardSquareSize 0.425\n#else\n    #define boardSquareSize 1.0\n#endif\n#define boardRoundedCornerSize 0.28333\n\n//#define MATERIAL_LOCK\n\n#ifdef CHESS\n    #define RINGS 8\n    #define SECTORS 8\n    #define SQUARE_BOARD\n    #define CHESS_BOARD_PATTERN\n    #define PIECE_ENABLED_PAWN\n    #define PIECE_ENABLED_QUEEN\n    #define PIECE_ENABLED_BISHOP\n    #define PIECE_ENABLED_ROOK\n    #define PIECE_ENABLED_KNIGHT\n    #define PIECE_ENABLED_KING\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](5,2,3,9,6,3,2,5,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1001,1001,1001,1001,1001,1001,1001,1001,1005,1002,1003,1009,1006,1003,1002,1005);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25);\n    float piecesFlipAngles[RINGS*SECTORS] = float[RINGS*SECTORS](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    int selectedPiece = 11;\n#endif\n\n#ifdef CHECKERS\n    #define RINGS 8\n    #define SECTORS 8\n    #define SQUARE_BOARD\n    #define CHESS_BOARD_PATTERN\n    #define PIECE_ENABLED_TOKEN\n    #define PIECE_ENABLED_TOKEN_QUEEN\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](7,0,7,0,7,0,7,0,0,7,0,7,0,7,0,7,7,0,7,0,7,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1007,0,1007,0,1007,0,1007,1007,0,1007,0,1007,0,1007,0,0,1007,0,1007,0,1007,0,1007);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25);\n    float piecesFlipAngles[RINGS*SECTORS] = float[RINGS*SECTORS](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    int selectedPiece = 20;\n#endif    \n\n#ifdef HEXAGON\n    #define RINGS 9\n    #define SECTORS 9\n    #define HEX_BOARD\n    #define PIECES_FLIP_ENABLED\n    #define HEX_PIECES\n    #define PIECE_ENABLED_TOKEN\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](100,100,100,100,1007,100,100,100,100,100,100,0,0,0,0,0,100,100,7,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,100,0,100,0,0,0,0,0,0,0,100,0,0,0,0,1007,0,0,0,0,0,0,0,1007,100,0,0,0,0,0,0,0,100,100,100,100,0,7,0,100,100,100);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222);\n    float piecesFlipAngles[RINGS*SECTORS] = float[RINGS*SECTORS](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    int selectedPiece = 26;\n#endif    \n\n\n#ifdef REDONDO\n    #define RINGS 4\n    #define SECTORS 16 \n    #define PIECE_ENABLED_PAWN\n    #define PIECE_ENABLED_BISHOP\n    #define CHESS_BOARD_PATTERN\n\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](3,3,3,3,3,3,0,3,1003,1003,1003,1003,1003,1003,1003,1003,1,1,1,1,1,0,1,1,1001,0,1001,1001,1001,1001,1001,1001,0,0,0,0,0,1,0,0,0,1001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25);\n    float piecesFlipAngles[RINGS*SECTORS] = float[RINGS*SECTORS](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n    int selectedPiece = 6+48-3;\n#endif\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    #define HIGHP highp\n#else\n    #define HIGHP mediump\n#endif\n\n#ifdef HQ_MODE\n    #define CLOSEST_DISTANCE_TO_SHAPE 0.01\n    #define DEFAULT_RENDER_TO_FLOOR\n\t#ifdef MOBILE\n        precision HIGHP float;\n        precision HIGHP int;\n        #define maxSteps 40\n        #define shadowSteps 15 // can be 10 to increase frame rate\n        #define reflectionSteps 15 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 10\n        #define refractionStepsInside 3\n        #define refractionStepsOutside 3\n        #define CLOSEST_DISTANCE_TO_SHAPE_REFRACTION CLOSEST_DISTANCE_TO_SHAPE\n        #define MARCH_OVERSTEP_MAX_LIMIT .08\n    #else\n        precision mediump float;\n        precision mediump int;\n        #define maxSteps 65\n        #define shadowSteps 25 // can be 10 to increase frame rate\n        #define reflectionSteps 25 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 25\n        #define refractionStepsInside 8\n        #define refractionStepsOutside 8\n        #define CLOSEST_DISTANCE_TO_SHAPE_REFRACTION CLOSEST_DISTANCE_TO_SHAPE*.5\n        #define MARCH_OVERSTEP_MAX_LIMIT 0.08\n        #define DYNAMIC_MARCH_STEPS_LIMIT\n\n        #ifndef HEX_BOARD \n          #define RAISED_BOARD \n        #endif\n    #endif\n#endif\n\n#ifdef DEFAULT_MODE\n    #define DEFAULT_RENDER_TO_FLOOR\n\t#ifdef MOBILE\n        #define CLOSEST_DISTANCE_TO_SHAPE 0.01\n        precision HIGHP float;\n        precision HIGHP int;\n        // Taller pieces require more marching\n        #ifdef REAL_CHESS_SET\n            #define maxSteps 40\n        #else\n            #define maxSteps 25\n        #endif\n        #define shadowSteps 8 // can be 10 to increase frame rate\n        #define reflectionSteps 10 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 5\n        #define refractionStepsInside 5\n        #define refractionStepsOutside 5\n        #define CLOSEST_DISTANCE_TO_SHAPE_REFRACTION CLOSEST_DISTANCE_TO_SHAPE * 2.\n        #define MARCH_OVERSTEP_MAX_LIMIT .28\n    #else\n        #define CLOSEST_DISTANCE_TO_SHAPE 0.01\n        precision mediump float;\n        precision mediump int;\n        // Taller pieces require more marching\n        #ifdef REAL_CHESS_SET\n            #define maxSteps 55\n        #else\n            #define maxSteps 35\n        #endif\n        #define shadowSteps 15 // can be 10 to increase frame rate\n        #define reflectionSteps 15 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 10\n        #define refractionStepsInside 8\n        #define refractionStepsOutside 8\n        #define CLOSEST_DISTANCE_TO_SHAPE_REFRACTION CLOSEST_DISTANCE_TO_SHAPE*.5\n        #define MARCH_OVERSTEP_MAX_LIMIT .28\n        #ifndef HEX_BOARD \n          #define RAISED_BOARD \n        #endif\n    #endif\n#endif\n\n#ifdef NICE_SHAPE_BLACK_BORDERS_MODE\n    #define CLOSEST_DISTANCE_TO_SHAPE 0.01\n    #define CLOSEST_DISTANCE_TO_SHAPE_REFRACTION CLOSEST_DISTANCE_TO_SHAPE*.5\n\t#ifdef MOBILE\n        precision HIGHP float;\n        precision HIGHP int;\n        #define maxSteps 35\n        #define shadowSteps 20 // can be 10 to increase frame rate\n        #define reflectionSteps 20 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 10\n        #define refractionStepsInside 3\n        #define refractionStepsOutside 3\n        #define CLOSEST_DISTANCE_TO_SHAPE_REFRACTION CLOSEST_DISTANCE_TO_SHAPE\n        #define MARCH_OVERSTEP_MAX_LIMIT .28\n    #else\n        precision mediump float;\n        precision mediump int;\n        #define maxSteps 40\n        #define shadowSteps 20 // can be 10 to increase frame rate\n        #define reflectionSteps 20 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 10\n        #define refractionStepsInside 8\n        #define refractionStepsOutside 8\n        #define CLOSEST_DISTANCE_TO_SHAPE_REFRACTION CLOSEST_DISTANCE_TO_SHAPE*.5\n        #define MARCH_OVERSTEP_MAX_LIMIT 0.28\n        #ifndef HEX_BOARD \n          #define RAISED_BOARD \n        #endif\n    #endif\n#endif\n\n    #define M_PI 3.1415926535897932384626433832795\n    #ifdef SQUARE_BOARD\n        #define SHAPE_SIZE (2.0 / float(RINGS))\n    #endif\n    #ifdef HEX_BOARD\n        #define SHAPE_SIZE (2.0 / float(RINGS))\n    #endif\n    #ifndef SQUARE_BOARD\n        #ifndef HEX_BOARD\n            #define SHAPE_SIZE (1.0 / float(RINGS))\n        #endif\n    #endif\n    #define DIST_SCALE (0.375 * float(RINGS))\n    #define DIST_SCALE_R (0.15 * float(RINGS))\n    #define DIST_SCALE_S (0.15 * float(SECTORS))\n    #define OFFSET_R 3.3\n    #define OFFSET_S 3.3\n    #ifdef REAL_CHESS_SET\n        #define TOP_OF_BOARD SHAPE_SIZE*3.5\n    #else\n        #define TOP_OF_BOARD SHAPE_SIZE*2.2\n    #endif\n    #define GLOW_INC 0.05\n\n    #define materialEmpty 0\n    #define materialEmptyBoardSpace 1\n    #define materialPlayerPiecesStart 2\n    \n    #define pawn 1\n    #define knight 2\n    #define bishop 3\n    #define rook 5\n    #define queen 9\n    #define king 6\n    #define token 7\n    #define tokenQueen 8\n    #define capturedToken 9\n    #define noSquare 100\n\n    #define turn 0\n    #define highlightPlayer -1\n    float highlightAmount = .2;\n\n#ifdef REDONDO\n    vec3 animationPiecePos = vec3(0.);\n    int animationPieceType = bishop;\n    int animationPiecePlayer = 0;\n#else\n    #ifdef CHESS\n        vec3 animationPiecePos = vec3(0.);\n        int animationPieceType = pawn;\n        int animationPiecePlayer = 0;\n    #else\n        #define animationPiecePos vec3(0.)\n        #define animationPieceType 0\n        #define animationPiecePlayer 0\n   #endif\n#endif\n    \n    #define boardRotation 0.0\n    #define zoom 1.0\n\n    #define ambientColor vec3(5.)\n    vec3 rotatedLightPositions[3] = vec3[](vec3(0.,4.,0.),vec3(3.,4.,0.),vec3(-3.,4.,0.));\n    vec3 lightPositions[3] = vec3[](vec3(0., 4.,0.),vec3(3.,4.,0.),vec3(-3.,4.,0.));\n    vec3 lightColors[3] = vec3[](vec3(4.,4.,4.), vec3(0.0,5.0,3.0), vec3(3.25,0.0,5.0));\n\n    #define emptySurfaceColor vec4(vec3(0.0), 0.6)\n    #ifdef TEXTURED_TABLE\n        #define emptyBoardColor vec4(0.2, 0.2, 0.2, 0.1)\n        vec4 boardColors[2] = vec4[](vec4(vec3(1.0),.8), vec4(vec3(0.4),.2));\n    #else\n        #define emptyBoardColor vec4(0.1, 0.1, 0.1, 0.4)\n        vec4 boardColors[2] = vec4[](vec4(vec3(.702,0.553,0.459)*1.1,.8), vec4(vec3(0.4,0.3,0.3)*.6,.8));\n    #endif\n    vec4 playerColors[2] = vec4[](vec4(1.0,0.75,0.5,.9), vec4(.8,0.1,0.1,.9));\n\n    // Prevent negative 0 becoming positive zero on int conversion\n    #define intC(f) int(f < 0.0 ? -1.0 : f)\n\n\n    // Noises\n    // By Morgan McGuire @morgan3d, http://graphicscodex.com\n    // Reuse permitted under the BSD license.\n    // https://www.shadertoy.com/view/4dS3Wd\n\n    // Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\n    lowp float hash(lowp float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n    lowp float hash(lowp vec2 p) {lowp vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\n    float noise(vec2 x) {\n        lowp vec2 i = floor(x);\n        lowp vec2 f = fract(x);\n\n        // Four corners in 2D of a tile\n        lowp float a = hash(i);\n        lowp float b = hash(i + vec2(1.0, 0.0));\n        lowp float c = hash(i + vec2(0.0, 1.0));\n        lowp float d = hash(i + vec2(1.0, 1.0));\n\n        lowp vec2 u = f * f * (3.0 - 2.0 * f);\n        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n    }\n\n\n    lowp float noise(vec3 x) {\n        const vec3 step = vec3(110, 241, 171);\n\n        lowp vec3 i = floor(x);\n        lowp vec3 f = fract(x);\n\n        // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n        // incremental change to the 1D based on the 3D -> 1D wrapping\n        lowp float n = dot(i, step);\n\n        lowp vec3 u = f * f * (3.0 - 2.0 * f);\n        return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                       mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n                   mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                       mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n    }\n\n    lowp float wood(in lowp vec2 p) {\n        return .7 + .2 * noise(p * vec2(3., 20.));\n    }\n    \n    lowp float spiral(in lowp vec2 uv) {\n        float r = sqrt(uv.x*uv.x+uv.y*uv.y);\n        float c = r * 10.;//+iTime/10.;\n        vec3 col = vec3(fract(c) < .3 ? 1.0 : 0.0);\n        float a = atan(uv.y,uv.x);\n        a = floor((M_PI+a)*10.);\n        float ia = 20.*r + floor(a);\n        float rr = (1.0+sin(ia*6.))/2.0;\n        return ((1.0+sin(mod(20.*r + a+0.*3., M_PI*10.)))/2.0);\n    }\n   \n    // SDFs\n    // https://iquilezles.org/articles/distfunctions/\n    float polynomial_smin(float a, float b, float k) {\n        float h = max(k - abs(a - b), 0.0) / k;\n        return min(a, b) -  h * h * k * (1.0 / 4.0);\n    }\n\n    float opSmoothUnion( float d1, float d2, float k )\n    {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h);\n    }\n\n    float opExtrusion( in vec3 p, in float sdf, in float h )\n    {\n        vec2 w = vec2( sdf, abs(p.x) - h );\n        return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n    }\n\n    // https://iquilezles.org/articles/distfunctions2d\n    float sdCross( in vec2 p, in vec2 b, float r ) \n    {\n        p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n        \n        vec2  q = p - b;\n        float k = max(q.y,q.x);\n        vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n        \n        return sign(k)*length(max(w,0.0)) + r;\n    }\n\n    float sdSphere( in vec3 p, in float s )\n    {\n        return length(p)-s;\n    }\n    \n    float sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n    {\n        vec2 q = vec2( length(p.xz), p.y );\n    \n        vec2 k1 = vec2(r2,h);\n        vec2 k2 = vec2(r2-r1,2.0*h);\n        vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n        vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n        float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n        return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n    }\n    \n    float sdOctahedron(in vec3 p, in float s)\n    {\n        p = abs(p);\n        float m = p.x + p.y + p.z - s;\n        return m*0.57735027;\n    }\n\n    // c is the sin/cos of the desired cone angle\n    float sdSolidAngle(in vec3 pos, in vec2 c, in float ra)\n    {\n        vec2 p = vec2( length(pos.xz), pos.y );\n        float l = length(p) - ra;\n        float m = length(p - c*clamp(dot(p,c),0.0,ra) );\n        return max(l,m*sign(c.y*p.x-c.x*p.y));\n    }\n\n    float dot2( in vec2 v ) { return dot(v,v); }\n    float dot2( in vec3 v ) { return dot(v,v); }\n\n    float sdBox( in vec3 p, in vec3 b )\n    {\n        vec3 d = abs(p) - b;\n        return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    }\n\n    float sdRoundCone(in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2)\n    {\n        // sampling independent computations (only depend on shape)\n        vec3  ba = b - a;\n        float l2 = dot(ba,ba);\n        float rr = r1 - r2;\n        float a2 = l2 - rr*rr;\n        float il2 = 1.0/l2;\n        \n        // sampling dependant computations\n        vec3 pa = p - a;\n        float y = dot(pa,ba);\n        float z = y - l2;\n        float x2 = dot2( pa*l2 - ba*y );\n        float y2 = y*y*l2;\n        float z2 = z*z*l2;\n\n        // single square root!\n        float k = sign(rr)*rr*rr*x2;\n        if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n        if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                                return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n    }\n\n    // My version of a chess set\n    float sdfPawn( in vec3 p, in float planeX, in float s) {\n        float planeY = p.y;\n        return min(\n                    max(planeX + (planeY - .3) * 0.3, -s-planeY), // base\n                    length(vec2(planeX, planeY-.2))-s*.5 // sphere\n        );\n    }\n\n    float sdfRook( in vec3 p, in float planeX, in float ang, in float s ) {\n        float planeY = p.y;\n        return \n            (\n                max(max(planeX-(s-(0.08 + .04 * cos(2.*planeY/ s))), // top bit\n                (p.y-s- clamp(.015 + .03 * sin(ang * 6.), 0., 0.04))), // spiky subtract\n                  -(planeX-(s-.12))) // middle hole\n            );\n    }\n\n    float sdfKnight( in vec3 p, in float planeX, in float s, in bool flipFace ) {\n        // Squished in X\n        float sPlaneX = length(vec2((p.x * (flipFace ? -1. : 1.)  - .1)*.5,p.z));\n        float planeY = p.y;\n        float sPlaneY = p.y - p.x * -.24 * (flipFace ? -1. : 1.); // bend down the nose\n        return opSmoothUnion(\n                    max(planeX + (planeY - .45) * 0.25, -s-planeY), // base\n                    length(vec2(sPlaneX, sPlaneY-.3))-s*.4,\n                    0.15\n                );\n    }\n\n    float sdfBishop( in vec3 p, in float planeX, in float s ) {\n        float planeY = p.y;\n        return \n            max(\n                min(\n                min(\n                    max(planeX + (planeY - .45) * 0.25, -s-planeY), // base\n                    length(vec2(planeX, 0.9*planeY-.25))-s*.5  // large sphere\n                ),\n                    length(vec2(planeX, planeY-.45))-s*.2  // small sphere\n                )\n                , (p.y-(s*2.2))); // Top\n    }\n\n    float sdfQueen( in vec3 p, in float planeX, in float ang, in float s ) {\n        float planeY = p.y;\n        return  min(min(\n                max(\n                    min(\n                        planeX + (planeY - .3) * 0.25, // base\n                        // max\n                        (planeX + (-planeY - .3) * 0.25//, // top\n                           //-(planeX + (-planeY - .2) * 0.25) // top cone cutout\n                        )\n                ),\n                planeY - s-.14 - 0.02*sin((M_PI + ang) * 6.) // crown top\n                ),\n                length(vec2(planeX, planeY-.35))-s*.5),  // large sphere\n                length(vec2(planeX, planeY-.5))-s*.2)  // small sphere\n            ;\n    }\n\n    float sdfKing( in vec3 p, in float planeX, in float s ) {\n        float planeY = p.y;\n        return  min(min(\n                max(\n                    min(\n                        planeX + (planeY - .35) * 0.25, // base\n                        //max\n                        (planeX + (-planeY - .35) * 0.25//, // top\n                            //-(planeX + (-planeY - .3) * 0.25) // top cone cutout\n                        )\n                ),\n                planeY - s-.14 // flat top\n                ),\n                length(vec2(planeX, planeY-.35))-s*.5),  // large sphere\n                opExtrusion( p, sdCross( p.zy-vec2(0, 0.545), vec2(0.8/8.,0.35/8.), 0.2/8. ), 0.02)) // cross\n            ;\n    }\n\n    // Other pieces\n    float sdHexPiece( in vec3 p, in float s )\n    {\n        return length(vec3(p.x, (p.y * 2. + s * .5), p.z))-s;\n    }\n\n    float sdChecker( in vec3 p, in float h, in float r1 )\n    {\n        float l = length(p.xz);\n        return max(max(l - r1, -(p.y + h)), p.y + 0.6 * h - cos(l * 70.) * .005);\n    }\n\n    float sdCheckerQueen( in vec3 p, in float h, in float r1 )\n    {\n        float l = length(p.xz);\n        return max(max(l - r1, -(p.y + h)), p.y + 0.6 * h);\n    }\n\n    \n    // convert 2D vector p into board co-ordinates (ii, jj) as well as co-ordinates inside a board cell (pp)\n    // this is used to draw the game board\n    void mapToBoardSpace( in vec2 p, out vec2 pp, out int ii, out int jj, out float ll) \n    {\n        #ifdef SQUARE_BOARD\n                float ang = (p.y + OFFSET_S) * DIST_SCALE_S;\n                float dist = (p.x + OFFSET_R) * DIST_SCALE_R;\n                ii = intC(ang);\n                jj = intC(dist);\n\n                pp = abs(vec2(fract(dist) - .5, fract(ang) - .5));\n                ll = length(pp/2.);\n        #endif\n        #ifdef HEX_BOARD\n                float ang = (p.y + OFFSET_S) * DIST_SCALE_S;\n                float dist = (p.x + OFFSET_R) * DIST_SCALE_R;\n\n                ii = intC(ang);\n                float shift = mod(float(ii), 2.0) == 1.0 ? 0.5 : 0.0;\n                jj = intC(dist + shift);\n                \n                float px = abs(fract(dist + shift) - .5);\n                float py = abs(fract(ang) - .5);\n\n                py += -0.1 + px/2.;\n                pp = vec2(px, py);\n                ll = length(pp/2.);\n        #endif\n        #ifndef HEX_BOARD\n            #ifndef SQUARE_BOARD\n                float ang = M_PI + atan(p.x,p.y);\n                float dist = length(p.xy) * DIST_SCALE;\n                ii = intC(float(SECTORS/2) * ang / M_PI);\n                jj = RINGS - intC(dist);\n\n                float ang2 = (float(ii) + .5) * M_PI / float(SECTORS/2);\n                float dist2 = (float(jj - RINGS) - .5) / DIST_SCALE;\n\n                pp = abs(vec2(fract(dist) - .5, (ang2 - ang) / (M_PI * 2. / float(SECTORS))));\n                ll = length(pp/2.);\n            #endif\n        #endif\n    }\n\n    // convert 3D vector pos into 3D piece space co-ordinates (posC) as well as co-ordinates inside a piece space (ang, dist)\n    // and game board location (ii, jj).\n    // This is used to compute SDFs for pieces\n    void mapToPieceSpace( in vec3 pos, out vec3 posC, out float ang, out float dist, out int ii, out int jj) \n    {\n        #ifdef SQUARE_BOARD\n                ang = pos.z + OFFSET_S;\n                dist = pos.x + OFFSET_R;\n                ii = intC(ang * DIST_SCALE_S);\n                jj = intC(dist * DIST_SCALE_R);\n\n                float ang2 = (float(ii) + .5) / DIST_SCALE_S - OFFSET_S;\n                float dist2 = (float(jj) + .5) / DIST_SCALE_R - OFFSET_R;\n\n                posC = vec3(dist2, 0., ang2);\n        #endif\n\n        #ifdef HEX_BOARD\n                ang = pos.z + OFFSET_S;\n                dist = pos.x + OFFSET_R;\n                ii = intC(ang * DIST_SCALE_S);\n                float shift = mod(float(ii), 2.0) == 1.0 ? -0.5 : 0.0;\n                jj = intC(dist * DIST_SCALE_R - shift);\n\n                float ang2 = (float(ii) + .5) / DIST_SCALE_S - OFFSET_S;\n                float dist2 = (float(jj) + shift + .5) / DIST_SCALE_R - OFFSET_R;\n\n                posC = vec3(dist2, 0., ang2);\n        #endif\n\n        #ifndef SQUARE_BOARD\n            #ifndef HEX_BOARD\n                ang = M_PI + atan(pos.x,pos.z);\n                dist = length(pos.xz);\n                ii = intC(float(SECTORS/2) * ang / M_PI);\n                jj = RINGS - intC(dist * DIST_SCALE);\n\n                float ang2 = (float(ii) + .5) * M_PI / float(SECTORS/2);\n                float dist2 = (float(jj - RINGS) - .5) / DIST_SCALE;\n\n                posC = vec3(dist2*sin(ang2), 0., dist2*cos(ang2));\n            #endif\n        #endif\n    }\n    \n    \n    // SDF mapping function.\n    // Takes the 3D co-ordinate (pos) to returns the SDF distance (dist)\n    // as well as many other useful things:\n    // material - type of material (empty, board, piece..)\n    // materialTex - 3D co-ordinate of a texture map\n    // inBoard - are we on the board\n    // boardSquareIdx - index representing the location in board co-oridinate space used mostly \n    //                  to \"colour\" piece selection regions\n    // inverse - if we should be computing the SDF from inside the pieces, used for refraction\n    // materialLock - tries to map to the same material to help with normal calculations\n    void map( in vec3 pos, out float dist, out int material, out vec3 materialTex, out bool inBoard, out int boardSquareIdx, in bool inverse, in int materialLock)\n    {\n        inBoard = false;\n        material = materialEmpty;\n\n        int ii = 0, jj = 0; float ang, d;\n        vec3 posC;\n        mapToPieceSpace(pos, posC, ang, d, ii, jj);\n        boardSquareIdx = ii+jj*(SECTORS);\n        dist = pos.y;\n        float stripe = 1.0;\n        float sign = inverse ? -1.0 : 1.0;\n\n        int piece = -1;\n        if (ii >= 0 && jj >= 0 && ii < SECTORS && jj < RINGS \n        #ifdef MATERIAL_LOCK\n                && (materialLock == -1 || materialLock >= materialPlayerPiecesStart)\n        #endif\n                ) {\n            int v = pieces[boardSquareIdx];\n            piece = v % 1000;\n            int pTurn = v / 1000;\n            material = materialPlayerPiecesStart + pTurn;\n            posC.y = piecesHeights[boardSquareIdx];\n\n            inBoard = true;\n            if (piece == noSquare) {\n                inBoard = false;\n                material = materialEmptyBoardSpace;\n            }\n\n    #ifdef PIECES_FLIP_ENABLED\n            float flipAngle = piecesFlipAngles[boardSquareIdx];\n    #endif            \n            vec3 diff = (pos-posC)\n    #ifdef ROTATE_PIECES_ON_BOARD\n                * mat3(cos(-ang), 0., sin(-ang),\n                                0., 1., 0.,\n                                -sin(-ang), 0., cos(-ang))\n    #endif            \n    #ifdef PIECES_FLIP_ENABLED\n                * mat3(1., 0., 0.,\n                    0., cos(flipAngle), -sin(flipAngle),\n                    0., sin(flipAngle), cos(flipAngle))\n    #endif            \n                ;\n            materialTex = diff;\n\n\n        #ifdef REAL_CHESS_SET\n            float planeX = length(sign * diff.xz);\n            float ang = sign * atan(diff.x, diff.z);\n        #endif\n\n        // No squares\n        #ifdef SQUARE_BOARD \n            #ifdef RAISED_BOARD\n                if (piece == noSquare) {\n                    dist = pos.y + smoothstep(boardSquareSize, boardSquareSize-.1, max(abs(posC.x-pos.x),abs(posC.z-pos.z))) * .1;\n                } else\n            #endif\n        #endif\n\n\n#ifdef PIECE_ENABLED_TOKEN\n            if (piece == token) {\n                #ifndef HEX_PIECES\n                    dist = sign*sdChecker( sign*diff, SHAPE_SIZE, SHAPE_SIZE );\n                #endif\n                #ifdef HEX_PIECES\n                    dist = sign*sdHexPiece( sign*diff, SHAPE_SIZE );\n                #endif\n            } else \n#endif\n#ifdef PIECE_ENABLED_TOKEN_QUEEN\n            if (piece == tokenQueen) {\n                dist = sign*sdCheckerQueen( sign*diff, SHAPE_SIZE, SHAPE_SIZE );\n            } else \n#endif\n#ifdef PIECE_ENABLED_PAWN\n            if (piece == pawn) {\n                #ifdef REAL_CHESS_SET\n                    dist = sign*sdfPawn( sign*diff, planeX, SHAPE_SIZE);\n                #else\n                    dist = sign*sdSphere( sign*diff, SHAPE_SIZE );\n                #endif\n            } else \n#endif\n#ifdef PIECE_ENABLED_BISHOP\n            if (piece == bishop) {\n                #ifdef REAL_CHESS_SET\n                    dist = sign*sdfBishop( sign*diff, planeX, SHAPE_SIZE);\n                #else\n                    // No *sign here for the diff because it looks bad\n                    dist = sign*sdCappedCone( diff, SHAPE_SIZE * .9, SHAPE_SIZE * .75, SHAPE_SIZE * .4 );\n                #endif\n            } else \n#endif\n#ifdef PIECE_ENABLED_ROOK\n            if (piece == rook) {\n                #ifdef REAL_CHESS_SET\n                    dist = sign*sdfRook( sign*diff, planeX, ang, SHAPE_SIZE );\n                #else\n                    dist = sign*sdBox( sign*diff, vec3(SHAPE_SIZE * .65, SHAPE_SIZE, SHAPE_SIZE * .65) );\n                #endif\n            } else \n#endif\n#ifdef PIECE_ENABLED_KNIGHT\n            if (piece == knight) {\n            #ifdef REAL_CHESS_SET\n                dist = sign*sdfKnight( sign*diff, planeX, SHAPE_SIZE, pTurn == 1 );\n            #else\n                dist = sign*sdRoundCone( sign*diff, vec3(0.0,0.0,0.0), vec3(0.1,0.15,0.1), SHAPE_SIZE * .75, SHAPE_SIZE * .4 );\n            #endif\n            } else \n#endif\n#ifdef PIECE_ENABLED_QUEEN\n            if (piece == queen) {\n            #ifdef REAL_CHESS_SET\n                dist = sign*sdfQueen( sign*diff, planeX, ang, SHAPE_SIZE);\n            #else\n                dist = sign*sdSolidAngle( sign*diff - vec3(0,-SHAPE_SIZE,0),  vec2(3,4)/5.0, SHAPE_SIZE * 1.7 );\n            #endif\n            } else \n#endif\n#ifdef PIECE_ENABLED_KING\n            if (piece == king) {\n            #ifdef REAL_CHESS_SET\n                dist = sign*sdfKing( sign*diff, planeX, SHAPE_SIZE);\n            #else\n                dist = sign*sdOctahedron( sign*diff, SHAPE_SIZE * .8 );\n            #endif\n            } else\n#endif\n            {}\n        }\n\n        if (animationPieceType != 0) {\n#ifdef SQUARE_BOARD\n            float ang3 = (animationPiecePos.y + .5) / DIST_SCALE_R - OFFSET_R;\n            float dist3 = (animationPiecePos.x + .5) / DIST_SCALE_S - OFFSET_S;\n            vec3 posC3 = vec3(dist3, SHAPE_SIZE * animationPiecePos.z, ang3);\n#endif\n#ifdef HEX_BOARD\n            float m =  mod(animationPiecePos.y, 2.0);\n            float shift =  (m <= 1.0 ? m : 2.0 - m) * -0.5;\n            float ang3 = (animationPiecePos.y + .5) / DIST_SCALE_S - OFFSET_S;\n            float dist3 = (animationPiecePos.x + shift + .5) / DIST_SCALE_R - OFFSET_R;\n            vec3 posC3 = vec3(dist3, SHAPE_SIZE * animationPiecePos.z, ang3);\n#endif\n#ifndef SQUARE_BOARD\n    #ifndef HEX_BOARD\n            float ang3 = (animationPiecePos.y + .5) * M_PI / float(SECTORS/2);\n            float dist3 = (animationPiecePos.x-float(RINGS) - .5) / DIST_SCALE;\n            vec3 posC3 = vec3(dist3*sin(ang3), SHAPE_SIZE * animationPiecePos.z, dist3*cos(ang3));\n    #endif\n#endif\n            float ang4 = 0.5;\n            vec3 diff3 = (pos-posC3)\n#ifdef ROTATE_PIECES_ON_BOARD\n                        * mat3(cos(-ang3), 0., sin(-ang3),\n                            0., 1., 0.,\n                            -sin(-ang3), 0., cos(-ang3))\n#endif\n                ;\n            float prevDist = dist;\n            #ifdef REAL_CHESS_SET\n                float planeX = length(sign * diff3.xz);\n                float ang = sign * atan(diff3.x, diff3.z);\n            #endif\n\n#ifdef PIECE_ENABLED_TOKEN            \n            if (animationPieceType == token) {\n                #ifndef HEX_PIECES\n                    dist = min(sign*dist, sdChecker( sign*diff3, SHAPE_SIZE, SHAPE_SIZE ));\n                #endif\n                #ifdef HEX_PIECES\n                    dist = polynomial_smin(sign*dist, sdHexPiece( sign*diff3, SHAPE_SIZE ), .1);\n                #endif\n            } else \n#endif            \n#ifdef PIECE_ENABLED_TOKEN_QUEEN\n            if (animationPieceType == tokenQueen) {\n                dist = min(sign*dist, sdCheckerQueen( sign*diff3, SHAPE_SIZE, SHAPE_SIZE));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_PAWN\n            if (animationPieceType == pawn) {\n                #ifdef REAL_CHESS_SET\n                    dist = min(sign*dist, sdfPawn( sign*diff3, planeX, SHAPE_SIZE ));\n                #else\n                    dist = min(sign*dist, sdSphere( sign*diff3, SHAPE_SIZE ));\n                #endif\n            } else \n#endif            \n#ifdef PIECE_ENABLED_BISHOP\n            if (animationPieceType == bishop) {\n                #ifdef REAL_CHESS_SET\n                    dist = min(sign*dist, sdfBishop( diff3, planeX, SHAPE_SIZE ));\n                #else\n                    // No *sign here for the diff because it looks bad\n                    dist = min(sign*dist, sdCappedCone( diff3, SHAPE_SIZE * .9, SHAPE_SIZE * .75, SHAPE_SIZE * .4 ));\n                #endif\n            } else \n#endif            \n#ifdef PIECE_ENABLED_ROOK\n            if (animationPieceType == rook) {\n                #ifdef REAL_CHESS_SET\n                    dist = min(sign*dist, sdfRook( sign*diff3, planeX, ang, SHAPE_SIZE ));\n                #else\n                    dist = min(sign*dist, sdBox( sign*diff3, vec3(SHAPE_SIZE * .65, SHAPE_SIZE, SHAPE_SIZE * .65) ));\n                #endif\n            } else \n#endif            \n#ifdef PIECE_ENABLED_KNIGHT\n            if (animationPieceType == knight) {\n                #ifdef REAL_CHESS_SET\n                    dist = min(sign*dist, sdfKnight( sign*diff3, planeX, SHAPE_SIZE, animationPiecePlayer == 1 ));\n                #else\n                    dist = min(sign*dist, sdRoundCone( sign*diff3, vec3(0.0,0.0,0.0), vec3(0.1,0.15,0.1), SHAPE_SIZE * .75,  SHAPE_SIZE * .4 ));\n                #endif\n            } else \n#endif            \n#ifdef PIECE_ENABLED_QUEEN\n            if (animationPieceType == queen) {\n                #ifdef REAL_CHESS_SET\n                    dist = min(sign*dist, sdfQueen( diff3, planeX, ang, SHAPE_SIZE ));\n                #else\n                    dist = min(sign*dist, sdSolidAngle( sign*diff3 - vec3(0,-SHAPE_SIZE,0),  vec2(3,4)/5.0, SHAPE_SIZE * 1.7 ));\n                #endif\n            } else \n#endif            \n#ifdef PIECE_ENABLED_KING\n            if (animationPieceType == king) {\n                #ifdef REAL_CHESS_SET\n                    dist = min(sign*dist, sdfKing( diff3, planeX, SHAPE_SIZE ));\n                #else\n                    dist = min(sign*dist, sdOctahedron( sign*diff3, SHAPE_SIZE * .8 ));\n                #endif\n            } else\n#endif            \n            {}\n            dist *= sign;\n\n            if (prevDist != dist) {\n                materialTex = diff3;\n                material = materialPlayerPiecesStart + animationPiecePlayer;\n            }\n        }\n\n        // Floor, board edge\n        #ifdef RAISED_BOARD \n            if (\n            #ifdef MATERIAL_LOCK\n            (materialLock == -1 || materialLock == materialEmpty || materialLock == materialEmptyBoardSpace) && \n            #endif\n            dist >= pos.y && piece != noSquare) {\n                float steper = .8;\n                #ifdef SQUARE_BOARD \n                    steper = smoothstep(3.4, 3.5, max(abs(pos.x),abs(pos.z)));\n                    dist = pos.y + steper * .1;\n                #endif\n                #ifndef HEX_BOARD\n                    #ifndef SQUARE_BOARD\n                        steper = smoothstep(float(RINGS)/2.+.1, float(RINGS)/2.+.3, abs((d * DIST_SCALE - 1.) - float(RINGS)/2.));\n                        dist = pos.y + steper * .1;\n                    #endif\n                #endif\n\n                material = steper < .9 ? materialEmptyBoardSpace : materialEmpty;\n            }\n        #else \n            if (\n            #ifdef MATERIAL_LOCK\n                (materialLock == -1 || materialLock == materialEmpty || materialLock == materialEmptyBoardSpace) && \n            #endif\n            dist >= pos.y) {\n                #ifdef SQUARE_BOARD \n                    material = max(abs(pos.x),abs(pos.z)) < 3.4 ? materialEmptyBoardSpace : materialEmpty;\n                #endif\n                #ifdef HEX_BOARD\n                    material = materialEmptyBoardSpace;\n                #endif\n                #ifndef HEX_BOARD\n                    #ifndef SQUARE_BOARD\n                        material = abs((d * DIST_SCALE - 1.) - float(RINGS)/2.) < float(RINGS) / 2. + .1 ? materialEmptyBoardSpace : materialEmpty;\n                    #endif\n                #endif\n                dist = pos.y;\n            }\n        #endif\n\n    }\n\n    // Helper method to return SDF distance at a location\n    float getDist( in vec3 pos, in int materialLock, in bool inverse) {\n        int material; vec3 materialTex; bool inBoard; int boardSquareIdx; float dist;\n        map(pos, dist, material, materialTex, inBoard, boardSquareIdx, inverse, materialLock);\n        return dist;\n    }\n\n    // IQ's normal calculation\n    vec3 normal( in vec3 pos, in int materialLock, in bool inverse )\n    {\n        HIGHP vec2 e = vec2(0.003, -0.003);\n        return normalize( e.xyy*getDist( pos + e.xyy, materialLock, inverse ) + \n                          e.yyx*getDist( pos + e.yyx, materialLock, inverse ) + \n                          e.yxy*getDist( pos + e.yxy, materialLock, inverse ) + \n                          e.xxx*getDist( pos + e.xxx, materialLock, inverse ) );\n    }\n\n    // Very primitive calculation of shading... mostly designed to look ok whilst not dragging down the rendering\n    // material - of the surface (possibly can be removed)\n    // pos - 3D location in space\n    // normal - computed normal for current location\n    // cameraVector - viewer vector\n    // lightPos - position of light this is computed for\n    // lightColor - colour of light\n    // surfact - colour of surface\n    // playerColor - this is the glow added to the surface to highlight board or region\n    // shadow - shadow colour\n    vec3 shade(in int material, in vec3 pos, in vec3 normal, in vec3 cameraVector, in vec3 lightPos, in vec3 lightColor, in vec4 surface, in vec3 playerColor, in vec3 shadow)\n    {\n        vec3 diff = lightPos - pos;\n        float dist = length(diff);\n        vec3 light = diff / dist;\n        float dotlight = dot(normal, light);\n    \n        vec3 cameraReflected = normalize(reflect(cameraVector, normal));\n        float spec = 0.0;\n        float lightAngle = dot(cameraReflected, light);\n        if (lightAngle < 0.0)            \n            spec = min(1.0, pow(lightAngle, 2.0));\n            \n        #ifdef SHINY_BOARD\n            spec -= (material == materialEmptyBoardSpace ? cos(lightAngle * 10.) * .3 : 0.0);\n        #endif\n\n        return\n            playerColor + // Glow\n#ifdef REFRACTIONS\n            ( lightColor * shadow * .5 +\n#else\n            shadow * (\n#endif            \n            surface.xyz * ambientColor // ambient\n            + max(0., dotlight) * lightColor * surface.xyz // surface\n            + spec * lightColor * surface.w) / dist; // spec\n    }\n\n    // Compute the texture of the game board given 2D co-ordinate (p)\n    // material - mainly used to decide if we are on the board or off the board\n    // playerColor - is returned seperatly to texture as it shaded as a glow\n    vec4 boardColor( in vec2 p, in int material, out vec3 playerColor)\n    {\n        vec2 pp; float ll; int ii, jj;\n        mapToBoardSpace(p, pp, ii, jj, ll);\n\n        int dd = ii+jj*(SECTORS);\n\n        bool insideASquare = \n            (jj >= 0 && jj < RINGS && ii >= 0 && ii < SECTORS)\n            && pieces[dd] != noSquare\n            && ((\n                    pp.x < boardSquareSize && pp.y < boardSquareSize\n        #ifdef ROUNDED_CORNERS_ENABLED\n                    && (boardRoundedCornerSize == 0.0 || ll < boardRoundedCornerSize)\n        #endif\n                ));\n\n        if (insideASquare && (highlighted[dd] != -1 || selectedPiece == dd)) {\n            bool insideHighlightedRegion = false;\n            #ifdef SQUARE_HIGHLIGHT\n                if (pp.x >.3 || pp.y >.3 || ll > .2) {\n                    insideHighlightedRegion = true;\n                }\n            #endif                \n            #ifdef CIRCLE_HIGHLIGHT\n                if (ll < .125)   {\n                    insideHighlightedRegion = true;\n                }\n            #endif                \n            if (selectedPiece == dd) {\n                insideHighlightedRegion = true;\n            }\n\n            if (insideHighlightedRegion) {\n                playerColor = playerColors[highlighted[dd]].xyz * highlightAmount * 5.;\n            }\n        }\n        \n        lowp vec4 wood = vec4(\n        #ifdef TEXTURED_TABLE\n             (material == materialEmptyBoardSpace ? texture(TABLE_TEXTURE, abs(p.xy * .5)).xyz : vec3(1.0))\n        #else \n              vec3(\n                #ifdef GENERATED_TABLE\n                        (material == materialEmptyBoardSpace ? GENERATED_TABLE(p.xy) : 1.0)\n                #else                        \n                        (material == materialEmptyBoardSpace ? BOARD_SHADE_WHEN_NOT_GENERATED : 1.0)\n                #endif\n                )\n        #endif\n        , 1.0);\n\n\n        return (\n            (   insideASquare ? \n        #if defined(CHESS_BOARD_PATTERN)\n                (mod(float(ii+jj), 2.0) == 1.0 ? boardColors[0] * wood : boardColors[1] * wood)\n        #elif defined(COLS_BOARD_PATTERN)\n                (mod(float(ii), 2.0) == 1.0 ? boardColors[0] * wood : boardColors[1] * wood)\n        #elif defined(ROWS_BOARD_PATTERN)\n                (mod(float(jj), 2.0) == 1.0 ? boardColors[0] * wood : boardColors[1] * wood)\n        #else\n                boardColors[0] * wood\n        #endif\n                : \n        #ifndef HEX_BOARD\n                emptyBoardColor * wood\n        #else\n                emptySurfaceColor\n        #endif                \n            ));\n    }\n    \n    // Returns texture of given surface as well as glow (playerColor)\n    // p - 3D co-ordinate in world (used for board surface calculations)\n    // material - surface material\n    // includeFloor - is floor to be required (is not included in secondary reflections)\n    // playerColor - player selector glow\n    vec4 textured(in vec3 p, int material, vec3 texc, bool includeFloor, out vec3 playerColor)\n    {\n        if (materialPlayerPiecesStart <= material) // player pieces\n        {\n            return playerColors[material-materialPlayerPiecesStart] \n            #ifdef STRIPED_PIECES\n                * (.8 + .2*step(M_PI / 2.0, mod((M_PI+atan(texc.x, texc.z)+40.0*texc.y), M_PI)))\n            #endif\n            #ifdef TEXTURED_PIECES\n                * texture(PIECES_TEXTURE, abs(texc.zy+vec2(texc.x)))\n            #endif\n                ;\n        }\n        else if (includeFloor && materialEmptyBoardSpace <= material) // board\n        {\n            return boardColor(p.xz, material, playerColor);\n        }\n        return emptySurfaceColor;\n\n    }\n    \n    // IQ's approach to generating soft shadows\n    // po - 3D location\n    // rd - 3D direction of surface (normal)\n    // lightPos - position of light\n    vec3 shadow(in vec3 ro, in vec3 rd, in vec3 lightPos)\n    {\n        float res = 1.0;\n        float t = 0.2;\n        int material;\n        for(int i = 1; i < shadowSteps; ++i)\n        {\n            vec3 p = ro + rd * t;\n            float depth = 0.;\n            vec3 materialTex; bool inBoard; int boardSquareIdx;\n            map(p, depth, material, materialTex, inBoard, boardSquareIdx, false, -1);\n            if ( depth < 0.001)\n#ifdef REFRACTIONS            \n                return playerColors[material-materialPlayerPiecesStart].xyz;\n#else\n                return vec3(0.001);\n#endif            \n            res = min( res, \n#ifdef REFRACTIONS            \n                6. * \n#else\n                4. * \n#endif            \n            depth / t);\n            t += clamp(depth, 0.0, 0.05);\n        }\n        \n#ifdef REFRACTIONS            \n        return (1.0 - res) * playerColors[material-materialPlayerPiecesStart].xyz;\n#else\n        return vec3(res);\n#endif            \n    }\n\n    // Reflections from reflections\n    // ro - 3D location\n    // rd - 3D direction (surface normal)\n    vec3 secondaryReflection(in vec3 ro, in vec3 rd)\n    {\n        float t = 0.1;\n        vec3 p;\n        float depth = 0.;\n        bool match = false;\n        int material; vec3 materialTex; bool inBoard; int boardSquareIdx;\n        for(int i = 0; i < secondaryReflectionSteps; ++i)\n        {\n            p = ro + rd * t;\n            \n            map(p, depth, material, materialTex, inBoard, boardSquareIdx, false, -1);\n            if(depth < CLOSEST_DISTANCE_TO_SHAPE)\n            {\n                match = true;\n                break;\n            }\n    \n            t += clamp(depth, 0.0, .2) ; // Reduced overstep\n        }\n\n        if (!match) {\n            return vec3(0.0);\n        }\n        \n        vec3 normal = normal(p, material, false); vec3 playerColor;\n        vec4 texc = textured(p, material, materialTex, false, playerColor);\n\n        vec3 color = vec3(0.0);\n#if LIGHTS==1\n        {\n            int j = 0;\n#else\n            for (int j = 0; j < LIGHTS; j++) {\n#endif                    \n                    // material is empty here to turn off shiny board and avoid wavy patterns in reflections \n            color += shade(materialEmpty, p, normal, -rd, rotatedLightPositions[j], lightColors[j], texc, playerColor, \n#ifdef REFRACTIONS\n            vec3(0.0)\n#else\n            vec3(1.0)\n#endif                    \n                );\n            }\n        return color\n            #if LIGHTS != 1\n                / float(LIGHTS)\n            #endif\n            ;\n    }\n    \n    // Reflection\n    // ro - 3D location\n    // rd - 3D direction (surface normal)\n    vec3 reflection(in vec3 ro, in vec3 rd)\n    {\n        HIGHP float t = 0.05;\n        float boardSideDepth = 0.0;\n        vec3 p;\n        bool match = false;\n        float depth; int material; vec3 materialTex; bool inBoard; int boardSquareIdx;\n\n        for(int i = 0; i < reflectionSteps; ++i)\n        {\n            p = ro + rd * t;\n            \n            map(p, depth, material, materialTex, inBoard, boardSquareIdx, false, -1);\n            #ifdef BOARD_GLOW\n            if (selectedPiece != - 1 && boardSquareIdx == selectedPiece + 1 && p.y < SHAPE_SIZE * 2.0) {\n                boardSideDepth += GLOW_INC\n                #ifdef BOARD_GLOW_NOISE\n                     + BOARD_GLOW_NOISE_FUNC\n                #endif\n                 ;\n            }\n            #endif\n            if(depth < CLOSEST_DISTANCE_TO_SHAPE)\n            {\n                match = true;\n                break;\n            }\n    \n            t += depth;\n        }\n    \n        if (!match) {\n            return vec3(.0);\n        }\n\n        vec3 normal = normal(p, material, false); vec3 playerColor;\n        vec4 texc = textured(p, material, materialTex, true, playerColor);\n\n        vec3 color = vec3(0.0);\n#if LIGHTS==1\n        {\n            int j = 0;\n#else\n        for (int j = 0; j < LIGHTS; j++) {\n#endif                    \n                    // material is empty here to turn off shiny board and avoid wavy patterns in reflections \n            color += shade(materialEmpty, p, normal, -rd, rotatedLightPositions[j], lightColors[j], texc, playerColor, \n#ifdef REFRACTIONS\n            vec3(0.0)\n#else\n            vec3(1.0)\n#endif                    \n            );\n        }\n\n        #ifdef SECONDARY_REFLECTIONS\n            vec3 cameraReflected = reflect(rd, normal);\n            vec3 r = secondaryReflection(p, cameraReflected);\n            color = mix(color, r, REFLECTION_MIX);\n        #endif\n\n        #ifdef BOARD_GLOW\n            if (boardSideDepth != 0.0)\n            {\n                color += vec3(\n#ifdef GLOW_LIMIT\n                    min\n#endif\n                    (boardSideDepth * boardSideDepth\n#ifdef GLOW_LIMIT\n                        , GLOW_LIMIT\n#endif\n                        ) * highlightAmount * playerColors[highlightPlayer != -1 ? highlightPlayer : turn]);\n            }\n        #endif\n\n        return color \n#if LIGHTS != 1\n            / float(LIGHTS)\n#endif\n        ;\n\n    }\n\n    // Refraction after we leave the inside of the piece\n    // ro - 3D location\n    // rd - 3D direction (surface normal)\n    vec3 refractionOutside(in vec3 ro, in vec3 rd) \n    {\n        // Ceiling\n        if (rd.y >= 0.0) {\n            return vec3(0.);\n        }\n\n        HIGHP float t = 0.2;\n        vec3 p;\n        float depth; int material; vec3 materialTex; bool inBoard; int boardSquareIdx;\n\n        for(int i = 0; i < refractionStepsOutside; ++i)\n        {\n            p = ro + rd * t;\n            map(p, depth, material, materialTex, inBoard, boardSquareIdx, false, -1);\n\n            if (depth < CLOSEST_DISTANCE_TO_SHAPE_REFRACTION\n            #ifdef RENDER_CLOSEST_MATCH            \n                || i == refractionStepsOutside - 1\n            #endif\n            )\n            {\n                break;\n            }\n            t += depth;\n        }\n\n\n        vec3 n2 = normal(p, material, true);  vec3 playerColor;\n        vec4 texc = textured(p, material, materialTex, true, playerColor);\n\n\n        vec3 color = vec3(0.0);\n#if LIGHTS==1\n        {\n            int j = 0;\n#else\n            for (int j = 0; j < LIGHTS; j++) {\n#endif                    \n                color += \n                    shade(materialEmpty, p, n2, -rd, rotatedLightPositions[j], lightColors[j], texc, playerColor,\n#ifdef REFRACTIONS\n                        vec3(0.0)\n#else\n                        vec3(1.0)\n#endif                    \n                    )\n                    ;\n            }\n            color = color \n                * (material == materialEmptyBoardSpace ? BOARD_SHADE_WHEN_NOT_GENERATED : 1.0)\n\n#if LIGHTS != 1\n                / float(LIGHTS)\n#endif\n            ;\n            return color;\n    }\n\n    // Refraction inside of the piece\n    // ro - 3D location\n    // rd - 3D direction (surface normal)\n    vec3 refractionInside(in vec3 ro, in vec3 rd)\n    {\n        vec3 p;\n        float depth; int material; vec3 materialTex; bool inBoard; int boardSquareIdx;\n        HIGHP float t = 0.2;\n        for(int i = 0; i < refractionStepsInside; ++i)\n        {\n            p = ro + rd * t;\n            map(p, depth, material, materialTex, inBoard, boardSquareIdx, true, -1);\n\n            if (depth < CLOSEST_DISTANCE_TO_SHAPE_REFRACTION)\n            {\n                break;\n            }\n            t += depth;\n        }\n    \n        vec3 normal = normal(p, material, true);\n        return refractionOutside(p, refract(rd, normal, REFRACTION_INDEX));\n    }\n\n    // Initial marching\n    // ro - 3D location of camera\n    // rd - 3D direction away from camera\n    vec4 march(in vec3 ro, in vec3 rd)\n    {\n        HIGHP float t = ((TOP_OF_BOARD) - ro.y) / rd.y; // Start on top of shape\n        float boardSideDepth = 0.0;\n        vec3 p;\n        float depth; int material; vec3 materialTex; bool inBoard; int boardSquareIdx; vec3 playerColor;\n        bool match = false;\n        for(int i = 0; i < maxSteps; ++i)\n        {\n            p = ro + rd * t;\n    \n            map(p, depth, material, materialTex, inBoard, boardSquareIdx, false, -1);\n            #ifdef BOARD_GLOW\n                int piece = pieces[boardSquareIdx];\n                if (selectedPiece != - 1 && inBoard && (\n                    boardSquareIdx == selectedPiece ||\n                    (highlightPlayer != -1 && piece != 0 && piece / 1000 == highlightPlayer)\n                    ) && p.y < SHAPE_SIZE * 2.0) {\n                    #ifdef HEX_BOARD\n                        // Hack to stop hexagon selected pieces looking square (to optimise)\n                        boardSideDepth += GLOW_INC //length(boardColor(p.xz, boardSquareIdx, material, playerColor).xyz) / 8.\n                            #ifdef BOARD_GLOW_NOISE\n                                + BOARD_GLOW_NOISE_FUNC\n                            #endif\n                            ;                    \n                    #else\n                        boardSideDepth += GLOW_INC\n                            #ifdef BOARD_GLOW_NOISE\n                                + BOARD_GLOW_NOISE_FUNC\n                            #endif\n                        ;\n                    #endif\n                }\n            #endif\n            if (depth < CLOSEST_DISTANCE_TO_SHAPE \n            #ifdef RENDER_CLOSEST_MATCH            \n                || i == maxSteps - 1\n            #endif\n            #ifdef DEFAULT_RENDER_TO_FLOOR\n                || (i == maxSteps - 1 && (material == materialEmpty || material == materialEmptyBoardSpace)) // Special case for floor\n            #endif\n            ) // if max steps reached go with nearest shape, produces interesting merging\n            {\n                match = true;\n                break;\n            }\n    \n            t += \n            #ifdef MARCH_OVERSTEP_MAX_LIMIT\n                clamp(depth, 0.0, MARCH_OVERSTEP_MAX_LIMIT) ; // Reduced overstep\n            #else\n                depth;\n            #endif\n        }\n        \n        vec3 normal = normal(p, material, false);\n        vec4 texc = textured(p, material, materialTex, true, playerColor);\n\n        vec3 color = vec3(0.0);\n        if (match) {\n#ifndef REFLECTIONS\n        if (material != materialEmpty) {\n#endif\n#if LIGHTS==1\n        int j = 0;\n        color = \n#else\n        color = vec3(0.0);\n        for (int j = 0; j < LIGHTS; j++) {\n            color += \n#endif                    \n            shade(material, p, normal, -rd, rotatedLightPositions[j], lightColors[j], texc, playerColor,\n            #ifdef SHADOWS\n                shadow(p, normalize(rotatedLightPositions[j]-p), rotatedLightPositions[j])\n            #else\n    #ifdef REFRACTIONS\n                vec3(0.0)\n    #else\n                vec3(1.0)\n    #endif                    \n#endif \n            )\n\n#if LIGHTS != 1\n            / float(LIGHTS); }\n#endif\n        ;\n#ifndef REFLECTIONS\n        }\n#endif\n        }\n\n        #ifdef REFLECTIONS\n            vec3 cameraReflected = normalize(reflect(rd, normal));\n            vec3 r = reflection(p, cameraReflected);\n            color = mix(color, r, REFLECTION_MIX);\n        #else\n            if (match && material != materialEmpty) {\n                vec3 cameraReflected = normalize(reflect(rd, normal));\n                vec3 r = texture(ENV_MAP_TEXTURE, cameraReflected).xyz; \n                color = mix(color, r, REFLECTION_MIX);\n            } else {\n                color = texture(ENV_MAP_TEXTURE, p.xz*.2).xyz * .75;\n            }\n        #endif\n\n        #ifdef REFRACTIONS\n            if (material >= materialPlayerPiecesStart) {\n                vec3 cameraRefracted = normalize(refract(rd, normal, 1./REFRACTION_INDEX));\n                vec3 r2 = refractionInside(p, cameraRefracted);\n                color = mix(color, r2, REFRACTION_MIX);\n            }\n        #endif\n\n        #ifdef BOARD_GLOW\n        if (boardSideDepth != 0.0)\n        {\n            color += vec3(\n#ifdef GLOW_LIMIT\n                    min\n#endif\n                (boardSideDepth * boardSideDepth\n#ifdef GLOW_LIMIT\n                , GLOW_LIMIT\n#endif\n                ) * highlightAmount * playerColors[highlightPlayer != -1 ? highlightPlayer : turn]);\n        }\n        #endif\n\n        return vec4(color, !inBoard ? 0.0 : float(boardSquareIdx + 1) / 255.0);\n    }\n    \n    // Calculate a camera vector from a given screen location (fragCoord) and camera (position, target)\n    vec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n    {\n        vec3 eye = normalize(target - position);\n        vec3 up = vec3(0., 1., 0.);\n        vec3 right = cross(eye, up);\n        up = cross(eye,right);\n    \n        mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                                 right.y, up.y, eye.y,\n                                 right.z, up.z, eye.z);\n    \n        vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n        float ar = iResolution.x/iResolution.y;\n        uv.x = uv.x * ar;\n\t\tfloat focalDistance = zoom * (iResolution.x > iResolution.y ? 2.4-(position.y/21.) : 1.3 * ar);\n\n        return normalize(vec3(uv.x,-uv.y,focalDistance)) * cameraMatrix;\n    }\n    \n    // https://www.shadertoy.com/view/ll2GD3\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n    {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 cpal(float x) {\n        return pal( x * 30., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n    \n    void animation() {\n        #ifdef REDONDO\n            animationPiecePos = vec3(1.6*sin(iTime)+1.5, 21.5-(1.6*sin(iTime)+1.), 4.*SHAPE_SIZE);\n        #endif\n        #ifdef CHESS\n            float h = clamp(2. * sin(iTime * .25 + 3.*M_PI/2.) + 1., -2.0, 0.25);\n            for (int j = 0; j < RINGS; j++) {\n              for (int i = 0; i < SECTORS; i++) {\n                  piecesHeights[j*SECTORS + i] = h;\n              }\n            }\n            if (h >= 0.25) {\n                animationPiecePos = vec3(2. + sin(iTime), 3., 4.*SHAPE_SIZE);\n            } else {\n                animationPiecePos = vec3(-100., -100., -100.);\n            }\n            highlightAmount = h > 0.0 ? h : 0.0;;\n        #endif\n    }\n    \n    // Shader entry point\n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        animation();        \n        vec3 cameraTarget = vec3(0.0);\n        mat3 br = mat3(cos(boardRotation+iTime*.2), 0.0, sin(boardRotation+iTime*.2),\n                  0.0, 1.0, 0.0,\n                 -sin(boardRotation+iTime*.2), 0.0, cos(boardRotation+iTime*.2));\n\n        vec2 cl = vec2(iMouse.x, iMouse.y) / iResolution.xy;\n        vec2 planePos = normalize(vec2(-cl.x, 1.0));\n        vec3 cameraLoc = br*10.*vec3( -planePos.y, clamp(cl.y, .4, 16.5), planePos.x);\n\n        vec3 ro = cameraLoc;\n        vec3 rd = rayVector(cameraLoc, cameraTarget, fragCoord);\n\n        vec4 result = march(ro, rd);\n        #ifdef DEBUG_SELECTION_FIELD\n            fragColor = mix(vec4(cpal(result.w), 1.0), result, 0.5);\n        #else\n            fragColor = result;\n        #endif\n    }\n\n\n    void mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n        animation();        \n        fragColor = march(fragRayOri, fragRayDir);        \n    }","name":"Image","description":"","type":"image"}]}