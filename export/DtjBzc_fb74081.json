{"ver":"0.1","info":{"id":"DtjBzc","date":"1694357167","viewed":98,"name":"GraphHW1+3","username":"jackofblades232","description":"--","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 1e-5\n#define PI 3.14159265359\n\n#define SDF_DIST_COEFF 0.8\n#define SDF_ITER 100\n\nmat3 mv = mat3(1.0);\n\nfloat runion(float d1, float d2)\n    { return min(d1, d2); }\nfloat rinters(float d1, float d2)\n    { return max(d1, d2); }\n\nfloat smin(float a, float b, float k)\n{\n    float t = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, t) - k*t*(1.0-t);\n}\n\nfloat sunion(float d1, float d2, float k)\n    { return smin(d1, d2, k); }\n\nfloat d_quad(vec3 p, float size)\n{\n    vec3 mp = mv*p;\n    float dx = max(0.0, max(mp.x - size, -size-mp.x));\n    float dz = max(0.0, max(mp.z - size, -size-mp.z));\n    return length(vec3(dx, mp.y, dz));\n}\n\n// Drop = Sphere + circular cone \n// (which is obtained as R3/two tangent circles\n//  clipped by two planes)\nfloat d_drop(vec3 p, float y, float r)\n{\n    vec3 op = mv*p - vec3(0.0, y, 0.0);\n    float ds = length(op) - r;\n    \n    float pr = length(op.xz);\n    vec2 op2 = vec2(pr, op.y);\n    vec2 cl = normalize(vec2(-1.0, 1.0)) * 4.0*r;\n    vec2 cr = vec2(-cl.x, cl.y);\n    float dl = length(cl-op2) - 3.0*r;\n    float dr = length(cr-op2) - 3.0*r;\n    \n    float dup = op.y - 4.0*r/sqrt(2.0);\n    float ddown = r/sqrt(2.0) - op.y;\n    \n    float dclamp = pr - 3.0*r;\n    \n    return rinters(runion(\n        ds, rinters(rinters(-dl, -dr), \n                    rinters(dup, ddown))),\n        dclamp);\n}\n\nfloat get_drop_y(float period, float maxh, float time_off)\n    { return maxh*(1.0-mod((iTime + time_off)/period, 2.0)); }\n\n// Base wave amplitude is zero initially, then quickly\n// rises linearly as the drop hits the water, and then\n// slowly goes back to zero\nfloat calc_drop_base_amp(float period, float maxh, \n                         float r, float time_off,\n                         out float phase_t, out float phase_h)\n{\n    const float max_amp = 0.4629/3.5;\n    const float dying_speed = 0.12/3.0;\n    const float rt_offset = 0.05;\n    \n    float t = mod(iTime + time_off, period*2.0);\n    float v = maxh/period;\n    float t1 = (maxh-r+rt_offset)/v;\n    float t2 = (maxh+r+rt_offset)/v;\n    phase_t = t-t1;\n    phase_h = phase_t/(period*2.0-t1);\n    if (t <= t1)\n        return 0.0;\n    else if (t <= t2)\n        return mix(0.0, max_amp, (t-t1)/(t2-t1));\n    else\n        return max(max_amp - dying_speed*(t-t2), 0.0);\n}\n\n// Sine wave with dying aplitude\nfloat d_drop_wave(float pr, \n                  float period, float maxh, float r,\n                  float time_off)\n{\n    const float max_pow = 6.0;\n    const float min_pow = 1.0;\n    \n    // Base amplitude is large when drop lands, and dies linearly with time\n    // The fade-out of the waves follows 1/(rad+1)^k formula, where\n    // k is large when drop lands (high splash, waves only nearby),\n    // but dies down linearly with time\n\n    float phase_t, phase_h;\n    float base_amp = calc_drop_base_amp(period, maxh, r, time_off,\n                                        phase_t, phase_h);\n    if (base_amp < EPS)\n        return 0.0;\n    float amp = base_amp/pow(pr+1.0, mix(max_pow, min_pow, phase_h));\n\n    amp = smin(amp, 0.04, 0.02);\n\n    return amp - \n        cos(22.0*(pr-0.25*phase_t/2.0))*amp;\n}\n\nfloat d_wave(float t, float coeff, float amp, float inv_period)\n    { return amp * (1.0 - sin(t*coeff + iTime*inv_period)); }\n\nfloat d_regular_waves(vec3 p)\n{\n    vec3 mp = mv*p;\n    \n    float xwave1 = d_wave(mp.x, 7.0, 0.004, 1.0);\n    float xwave2 = d_wave(mp.x, 15.0, 0.002, 5.0);\n    float xwave3 = d_wave(mp.x, 5.0, 0.004, 0.5);\n    float xwave4 = d_wave(mp.x, 1.0, 0.004, 1.7);\n    float zwave1 = d_wave(mp.z, 7.0, 0.004, 1.0);\n    float zwave2 = d_wave(mp.z, 15.0, 0.002, 5.0);\n    float zwave3 = d_wave(mp.z, 5.0, 0.0004, 0.5);\n    float zwave4 = d_wave(mp.z, 1.0, 0.004, 1.7);\n    float xzwave1 = d_wave(mp.x-mp.z, 7.0, 0.002, 1.0);\n    float xzwave2 = d_wave(mp.x-mp.z, 15.0, 0.0005, 5.0);\n    float xzwave3 = d_wave(mp.x-mp.z, 5.0, 0.01, 0.5);\n    float xzwave4 = d_wave(mp.x-mp.z, 1.0, 0.0018, 1.7);\n    \n    return xwave1 + xwave2 + xwave3 + xwave4 +\n           zwave1 + zwave2 + zwave3 + zwave4 +\n           xzwave1 + xzwave2 + xzwave3 + xzwave4;\n}\n\nfloat sdf(vec3 p)\n{\n    const float period = 6.0;\n    const float maxh = 2.0;\n    const float r = 0.13;\n    \n    float pr = length((mv*p).xz);\n    \n    // 4 drops and a wavy quad\n    \n    float drop1_offset = 0.0;\n    float drop2_offset = 3.0;\n    float drop3_offset = 6.0;\n    float drop4_offset = 9.0;\n    \n    float dd1 = d_drop(p, get_drop_y(period, maxh, drop1_offset), r);\n    float dd2 = d_drop(p, get_drop_y(period, maxh, drop2_offset), r);\n    float dd3 = d_drop(p, get_drop_y(period, maxh, drop3_offset), r);\n    float dd4 = d_drop(p, get_drop_y(period, maxh, drop4_offset), r);\n    \n    float drop_waves = d_drop_wave(pr, period, maxh, r, drop1_offset) +\n                       d_drop_wave(pr, period, maxh, r, drop2_offset) +\n                       d_drop_wave(pr, period, maxh, r, drop3_offset) +\n                       d_drop_wave(pr, period, maxh, r, drop4_offset);\n    \n    float dq = d_quad(p, 3.0) - 1.5*drop_waves - d_regular_waves(p);\n    \n    float drops = runion(dd1, runion(dd2, runion(dd3, dd4)));\n    return sunion(dq, drops, 0.05);\n}\n\nvec3 trace(vec3 orig, vec3 dir, out bool hit)\n{\n    float tot_d = 0.0;\n    hit = false;\n    for (int i = 0; i < SDF_ITER; i++) {\n        float d = sdf(orig);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n        d *= SDF_DIST_COEFF;\n        tot_d += d;\n        if (tot_d > 20.0)\n            break;\n        orig += d*dir;\n        \n    }\n    return orig;\n}\n\nvec3 gen_normal(vec3 p, float d)\n{\n    float e = max(d*0.5, EPS);\n    \n    vec3 dx = vec3(e, 0.0, 0.0);\n    vec3 dy = vec3(0.0, e, 0.0);\n    vec3 dz = vec3(0.0, 0.0, e);\n    float grx = sdf(p+dx) - sdf(p-dx);\n    float gry = sdf(p+dy) - sdf(p-dy);\n    float grz = sdf(p+dz) - sdf(p-dz);\n    \n    return normalize(vec3(grx, gry, grz));\n}\n\nvec3 get_triplanar_weights(vec3 n)\n{\n    vec3 w = n*n;\n    return w / (w.x + w.y + w.z);\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    vec2 uv = (frag_coord - 0.5*iResolution.xy)/iResolution.x;\n    vec3 eye = vec3(0.0, 0.0, -5.0);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    vec3 light = vec3(-0.4, 0.4, -5.0);\n    \n    // Set default pos to 30/60 degrees from center, otherwise use mouse\n    vec2 mouse_pos = vec2(iMouse.x > 0.0 ? iMouse.x : iResolution.x*0.5 + 30.0,\n                          iMouse.y > 0.0 ? iMouse.y : iResolution.y*0.5 + 60.0);\n    \n    float xrad = PI*((mouse_pos.x/iResolution.x) - 0.5);\n    float yrad = PI*((mouse_pos.y/iResolution.y) - 0.5);\n    float xcos = cos(xrad);\n    float xsin = sin(xrad);\n    float ycos = cos(yrad);\n    float ysin = sin(yrad);\n    mv = inverse(mat3(xcos, 0.0, -xsin,\n                      0.0,  1.0, 0.0,\n                      xsin, 0.0, xcos) *\n                 mat3(1.0, 0.0,  0.0,\n                      0.0, ycos, -ysin,\n                      0.0, ysin, ycos));\n    \n    bool hit;\n    vec3 p = trace(eye, dir, hit); \n    \n    if (hit) {\n        // Light blue\n        vec3 base_rgb = 2.0*vec3(0.019, 0.764, 0.866);\n\n        vec3 n = gen_normal(p, 0.001);\n        vec3 l = normalize(light - p);\n        float nl = max(dot(n, l), 0.0);\n        vec4 notex_col = vec4(nl * base_rgb, 1.0);\n        \n        vec3 w = get_triplanar_weights(n);\n        vec4 cx = texture(iChannel1, p.yz);\n        vec4 cy = texture(iChannel1, p.zx);\n        vec4 cz = texture(iChannel1, p.xy);\n        vec4 trip_color = notex_col * (w.x*cx + w.y*cy + w.z*cz);\n        \n        \n        if ((mv*p).y < 0.2)\n            frag_color = trip_color * texture(iChannel0, (mv*p).zx/6.0 + 0.5);\n        else\n            frag_color = trip_color;\n    } else\n        frag_color = vec4(0.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 frag_color, in vec2 frag_coord )\n{\n    vec2 c1 = vec2(0.25, 0.25);\n    vec2 c2 = vec2(0.66, 0.5);\n    vec2 c3 = vec2(0.5, 0.8);\n    \n    float rline = 0.005;\n    float rstep = 0.025;\n    float rmod = rline+rstep;\n    \n    float speed1 = 0.05;\n    float speed2 = 0.08;\n    float speed3 = 0.02;\n    \n    float off1 = mod(speed1 * iTime, rmod);\n    float off2 = mod(speed2 * iTime, rmod);\n    float off3 = mod(speed3 * iTime, rmod);\n    \n    vec2 uv = vec2(frag_coord.x / iResolution.x, frag_coord.y / iResolution.y);\n    float r1 = mod(length(uv - c1) - off1, rmod);\n    float r2 = mod(length(uv - c2) - off2, rmod);\n    float r3 = mod(length(uv - c3) - off3, rmod);\n    \n    if (r1 >= rstep || r2 >= rstep || r3 >= rstep)\n        frag_color = vec4(vec3(1.5), 1.0);\n    else\n        frag_color = vec4(vec3(0.75), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}