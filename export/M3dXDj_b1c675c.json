{"ver":"0.1","info":{"id":"M3dXDj","date":"1719616847","viewed":68,"name":"3D Perlin Noise sample","username":"pacaro","description":"Demonstrates 3d perlin noise using smoothstep.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 randomGradient(vec3 pt) {\n    ivec2 spt = ivec2(pt.xy + 101.0 * pt.z) % 256;\n    \n    vec4 t = texelFetch(iChannel0, spt, 0);\n    \n    return t.xyz * 2.0 - 1.0;\n}\n\nfloat dotGridGradient(vec3 corner, vec3 p) {\n    vec3 gradient = randomGradient(corner);\n    \n    vec3 d = corner - p;\n    \n    return dot(d, gradient);\n}\n\nfloat perlin3(vec3 p, float octave) {\n    p *= octave;\n    vec3 p0 = floor(p);\n    vec3 p1 = p0 + vec3(1.0);\n    \n    vec3 s = p - p0;\n    \n    vec4 gvv0 = vec4(\n        dotGridGradient(mix(p0, p1, vec3(0, 0, 0)), p),\n        dotGridGradient(mix(p0, p1, vec3(1, 0, 0)), p),\n        dotGridGradient(mix(p0, p1, vec3(0, 1, 0)), p),\n        dotGridGradient(mix(p0, p1, vec3(1, 1, 0)), p));\n    vec4 gvv1 = vec4(\n        dotGridGradient(mix(p0, p1, vec3(0, 0, 1)), p),\n        dotGridGradient(mix(p0, p1, vec3(1, 0, 1)), p),\n        dotGridGradient(mix(p0, p1, vec3(0, 1, 1)), p),\n        dotGridGradient(mix(p0, p1, vec3(1, 1, 1)), p));\n        \n    s = smoothstep(0.0, 1.0, s);\n        \n    vec4 gvvx = mix(gvv0, gvv1, s.z);\n    vec2 gvxx = mix(gvvx.xy, gvvx.zw, s.y);\n    return mix(gvxx.x, gvxx.y, s.x);\n    \n   \n}\n\n// Defines the number of octaves of perlin noise to combine.\nconst int OCTAVES = 5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\n    vec3 pos = vec3(uv * 5.0, iTime / 4.0);\n    \n    float g = 0.0;\n    float octave = 0.5;\n    for (int i = 0; i != OCTAVES; i++) {\n        octave *= 2.0;\n        g += perlin3(pos, octave) / octave;\n    }\n    \n    g = (g + 1.0) * 0.5;\n    \n    fragColor = vec4(g,g,g, 1.0);\n}","name":"Image","description":"","type":"image"}]}