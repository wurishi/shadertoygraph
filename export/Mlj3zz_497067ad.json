{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// An attempt to create DLA-like particles flying in space (sort of),\n// unfortunately it runs a little bit slow... maybe can be optimized, maybe not?\n\n// Comment this out to disable scaling animation\n#define SCALE_ANIMATION\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat hash(in float n){ return fract(n*43758.5453); }\n\nfloat df(vec3 p, float anim, float scale)\n{\n    vec4 src[9];\n    vec4 dst[9];\n    \n    //float anim = iTime*.125; //(sin(iDate.w)+1.0)*.4999;\n    float anim_scale = .5;\n    \n    for(int i=0; i<3; ++i) {\n    \tfloat f = float(i)*(1.0/3.0);\n        float a = f*(M_PI*2.0);\n        float ds = .4*scale;\n        vec4 s = vec4(cos(a)*ds,sin(a)*ds,0,f+float(i*21));\n        dst[i] = s;\n    }\n\n    for(int lev=0; lev<6; ++lev) {\n        // Replicate:\n        for(int k=0; k<3; ++k) {\n          vec4 s = dst[k];\n          float ds = .2*scale;\n          float sw = floor(s.w);\n          float h = hash(sw) - .5;\n          float f = fract(s.w) + anim*h*anim_scale;\n          float a = h + f*(2.0*M_PI) + sw*.31;\n          src[k] = s + vec4(cos(a)*ds,sin(a)*ds,h*ds,1);\n          a += M_PI*2.0/3.0;\n          src[k+3] = s + vec4(cos(a)*ds,sin(a)*ds,ds,3);\n          a += M_PI*2.0/3.0;\n          src[k+6] = s + vec4(cos(a)*ds,sin(a)*ds,-ds,7);\n        }\n        if (lev==5) break;\n        // Copy only 3 closest to dst:\n        float dmax = 0.0;\n        vec4 o = src[0];\n        for(int k=0; k<3; ++k) {\n            float dmin = 1e32;\n            for(int i=0; i<9; ++i) {\n               vec4 s = src[i];\n               vec3 dp = p.xyz - s.xyz;\n               float d = dot(dp,dp);\n               if (d > dmax && d < dmin) { o = s; dmin = d; }\n            }\n            dst[k] = o;\n            dmax = dmin;\n        }\n        scale *= .5;\n        anim_scale *= 1.5;\n    }\n    \n    float dist = 32.0;\n    for(int i=0; i<9; ++i) {\n        vec4 s = src[i];\n        vec3 dp = p.xyz - s.xyz;\n    \tfloat d = dot(dp,dp);\n\t\tdist = min(dist, d);\n    }\n    dist = sqrt(dist);\n    dist = min(dist, max(0.0, length(p.xyz)-.7));\n    return dist;\n}\n\nfloat voro3(vec3 p)\n{\n\tvec3 sp = p - vec3(.5,.5,.5);\n    vec3 fp = fract(sp);\n    vec3 gp = sp - fp;\n\tfloat dmin = 1e32;\n    for(int i=0; i<2; i++)\n    for(int j=0; j<2; j++)\n    for(int k=0; k<2; k++)\n    {\n       vec3 hp = gp + vec3(float(i),float(j),float(k));\n       for(int seed=1; seed<8; ++seed) {\n          float seed1 = float(seed);\n          seed1 += fract(hp.x*234.12467 + hp.y*5472.1346 + hp.z*5725.1364);\n          vec3 dp = vec3(\n              hp.x + fract(seed1*2345.127+.317),\n              hp.y + fract(seed1*6234.171+.217),\n              hp.z + fract(seed1*7133.271+.171))\n              - p;\n          dmin = min(dmin,dot(dp,dp));\n       }\n    }\n\treturn dmin;\n}\n\nvec4 trace(vec3 p, vec3 n)\n{\n    float time = iTime;\n    float anim = time*.125;\n    float scale = 4.0;\n#ifdef SCALE_ANIMATION\n    scale += exp(-time*.5)*4.0;\n    if (time>24.0) {\n        scale += log(time+1.0-24.0)*2.0;\n    }\n#endif\n\tfloat d;\n    float lit = 0.0;\n    float cen = 0.0;\n    float halo = 0.0;\n    // It's quite slow... 13 steps is already too much for my GTX 460\n    const int steps = 13;\n    for(int k=0; k<steps; ++k) {\n    \td = df(p,anim,scale);\n        p += d*.95*n;\n        lit += 1.0/(d + 0.15);\n        float dcen = dot(p.xyz,p.xyz);\n        cen += 1.0/dcen;\n        halo += 1.0/(max(0.0,dcen-.7) + 0.15);\n    }\n    lit *= .2/float(steps);\n    lit = pow(lit,1.5);\n    \n    halo = halo*.007;\n\n    //lit += cen*texture(iChannel0,p.xy*.2).r*.1;\n    \n    vec4 col = vec4(lit-d*.1+halo,lit*.95+halo,.3+lit*.08+halo,1);\n    //float bkg = df(vec3(n.xy*3.0,0), 4.0);\n    float bkg = voro3(n*(4.0+sin(anim-M_PI*.3)*2.0));\n                      //vec3(sin(n.z*4.0+anim)*3.0,sin(n.x*4.0-anim)*3.0,sin(n.y*4.0+anim)*3.0));\n    float star = max(0.0,1.0-voro3(n*32.0+vec3(0,0,anim*.1))*iResolution.x);\n    bkg += star*2.0*(bkg*.5+.8);\n    vec4 bkg_col = vec4(bkg,bkg,bkg,1);\n    return mix(col,bkg_col,d*.08);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    float a = iMouse.x / iResolution.x * 2.0; // - 1.0;\n    float co = cos(a);\n    float si = sin(a);\n    const float ds = 10.0;\n    vec3 p1 = vec3(-ds*si, 0, -ds*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    fragColor = trace(p1, n2);\n    \n    /*\n    a = iMouse.y / iResolution.y * 2.0 - 1.0;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n    fragColor = trace(p2, n3);\n    */\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define pi 3.1415926535897932384626433832795\n\nfloat wave(float t) { \n    return sin(t+sin(t+fract(sin(t*.8)*400.0)*.2)*3.0);\n}\n\nfloat wave2(float t) { \n    return sin(t+sin(t+fract(sin(t*.8)*400.0)*.1)*2.0);\n}\n\nfloat tune1(float x) {\n    return max(wave(x*500.0)*(fract(x*2.0)*500.0-400.0),0.0);\n}\nfloat tune2(float x) {\n    return max(wave(x*250.0)*(fract(x+.5)*500.0-400.0),0.0);\n}\nfloat tune3(float x) {\n    float t = fract(x*(1.0/16.0));\n    if (t > .75+.125) {\n        return max(wave2(x*666.6)*(fract(x*.125)*500.0-490.0),0.0)*.6;\n    }\n    if (t > .75) {\n        return max(wave2(x*787.5)*(fract(x*.125)*500.0-490.0),0.0);\n    }\n    if (t > .5) {\n        return max(wave2(x*888.8)*(fract(x*.25)*500.0-490.0),0.0)*.7;\n    }\n    if (t > .5-.125) {\n        return max(wave2(x*666.6)*(fract(x*.25)*500.0-490.0),0.0)*.4;\n    }\n    if (t > .25) {\n        return max(wave2(x*787.5)*(fract(x*.25)*500.0-490.0),0.0)*.6;\n    }\n    if (t > .25-(1.0/16.0)) {\n        return max(wave2(x*750.0)*(fract(x*.125)*500.0-490.0),0.0);\n    }\n    if (t > .25-.125) {\n        return max(wave2(x*666.6)*(fract(x*.125)*500.0-490.0),0.0)*.6;\n    }\n    return max(wave2(x*750.0)*(fract(x*.25)*500.0-490.0),0.0);     \n}\n\nvec2 mixtune(float time) {\n    if (time>24.0) {\n    \tfloat t = (time-24.0)*500.0;\n    \treturn vec2(sign(sin(t*.25)*sin(t*0.248))*exp(t*-.0005))*200.0;\n    }\n\tfloat x = time*2.0;\n    float f = tune1(x)*(.5+sin(time*.125)*.3);\n    float g = tune2(x)*.5;\n    float h = tune3(x)*(.4+sin(time*(1.0/4.0))*.3);\n    float a = time*.1;\n    float co = cos(a);\n    float si = sin(a);\n    return vec2( f*co + g*si + h, f*si - g*co + h );\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    vec2 f = vec2(0);\n    float x = time*2.0;\n    //float b = sin(x*120.0+sin(x*100.0)*2.0)*10.0*max(0.0,abs(fract(x*1.0)-.5)-.4);\n    float d = .0005*(1.0 + sin(time*.1)*.9);\n    for(int i=0; i<8; i++) {\n        f += mixtune(time+float(i)*d)*sin(float(i)*pi/8.0);\n    }\n    return f*(1.0/5000.0); // + vec2(b,b);\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mlj3zz","date":"1426721458","viewed":319,"name":"[NV15] Space DLA","username":"tomkh","description":"3D DLA...in space;)\nFull animation takes ~32 sec.\nSide note: all code was written from scratch for NV15 hackathon.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","distancefield","nv15"],"hasliked":0,"parentid":"","parentname":""}}