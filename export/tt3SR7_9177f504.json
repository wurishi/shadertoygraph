{"ver":"0.1","info":{"id":"tt3SR7","date":"1580617710","viewed":116,"name":"mazetest","username":"Del","description":"mazetest, use mouse to play around with twist / extrude depth\n - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["mazetest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cylinder maze test - feel free to improve the cutout if you have a better method :)\n#define AA 2\n\n\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * MOD3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat _maze(vec3 p)\n{\n\tvec3 p2 = p+vec3(p.y, -p.x, 0.);\n\tfloat d = float(hash13(floor(p2))<.5 ? 2. * abs(fract(p.x)-.5) : 2. * abs(fract(p.y)-.5));\n\treturn d;\n}\n\nfloat maze(vec2 uv)\n{\n\tvec3 cp = vec3(0.);\n\tvec3 cd = 4. * vec3(uv, 1.);\n\tcp += cd;\n\tfloat m = _maze(cp)+0.25;\n    return 1.0-smoothstep(0.6,1.0,m);\n    //return 1.-step(.7, m);\n}\n\n#define HEIGHT 12.5\n#define DEPTH .8\n#define INNER 1.9\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nmat2 rot(float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}    \n \nfloat map( in vec3 pos )\n{\n    float inner = INNER;\n    float outer = inner+DEPTH;\n    \n    if (iMouse.z>0.5)\n    {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \tpos.xz *= rot(sin(pos.y*mouse.y*0.5));\t\t\t// twist (mousey)\n        outer+=abs(mouse.x*2.0);\t\t\t\t\t\t// depth (mousex)\n    }\n    \n    vec2 uv = vec2(atan(pos.x,pos.z),pos.y) * 0.5;\n    \n    float d1 = sdCylinder(pos,vec2(outer,HEIGHT));\n    float d2 = sdCylinder(pos,vec2(inner,HEIGHT));\n    \n    float t = mod(iTime,16.0);\n    uv.y -= iTime*0.2;\n    uv.y *= 0.5;\n    float maze = maze(uv*2.0)*0.05;    \n\n    // test: sample height from a texture\n\t//maze = (texture(iChannel0, uv*0.1, -100.0).w+0.00001)-0.5; \n    \n    \n   if (iMouse.z>0.5 || t<8.0)\n   {\n        d1 = max(maze,d1);\n   }    \n   else\n   {\n        uv.x = mod(uv.x,0.2)-0.1;\n        uv.y = mod(uv.y,0.2)-0.1;\n        float d = length(uv)-0.05;\n       \td1 = max(d,d1);\n   }\n    \n   return min(d1,d2);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\t//float an = 0.5*(iTime-10.0);\n    float an = sin(iTime);\n\tvec3 ro = vec3( 7.0*cos(an), sin(iTime*0.75)*5.0, 7.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 25.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.4,0.3,0.2)*1.0-abs(p.x*0.025+p.y*0.125);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.1,0.35,0.4)*amb + vec3(0.9,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}