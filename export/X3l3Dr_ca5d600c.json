{"ver":"0.1","info":{"id":"X3l3Dr","date":"1707363944","viewed":487,"name":"Dispersion Path-Tracing","username":"Fuergu","description":"Use three functions to get RGB color for Ray. BUT, this make it very slow to compile.\nMOVE your mouse to change the position of the orange light ball!","likes":22,"published":1,"flags":48,"usePreview":1,"tags":["3d","pathtracing","pathtracing","physics","dispersion","optic","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float calculateClearness(float depth, float center, float range) {\n    float lowerBound = center - range;\n    float upperBound = center + range;\n    float clearness = 0.;\n    if (depth<lowerBound)\n    clearness = smoothstep(1.,0., depth/lowerBound);\n    if (depth>upperBound)\n    clearness = smoothstep(0.,1., map(depth,upperBound,1.,0.,1.));\n    return clearness;\n}\n\nvec3 blur( int index, vec2 fragCoord )\n{\n    //https://xorshaders.weebly.com/tutorials/blur-shaders-5-part-2\n    vec2 uv = fragCoord/iResolution.xy;\n    float Directions = 30.; \n    float Quality = 4.0; \n    float Size = Blur; \n    vec3 Color = vec3(0.);\n    if(index == 0)\n    Color = texture( iChannel0,uv).rgb;\n    if(index == 1)\n    Color = texture( iChannel1,uv).rgb;\n    vec2 Radius = Size/iResolution.xy;\n    // Blur calculations\n    for( float d=0.0; d<c_twopi; d+=c_twopi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n            if(index == 0)\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i).rgb;\t\t\n            if(index == 1)\n\t\t\tColor += texture( iChannel1, uv+vec2(cos(d),sin(d))*Radius*i).rgb;\t\t\n        \n        }\n    }\n    Color /= Quality * Directions - 15.0;\n    return Color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 meanColor  = blur(0,fragCoord);\n    float depth = texture(iChannel1,uv).r;\n    float clearness = calculateClearness(depth,(clearDistance-minDistance)/(maxDistance-minDistance),DOF/(maxDistance-minDistance));\n    fragColor.rgb = col*(1.-clearness) + meanColor*clearness;\n    //fragColor.rgb =meanColor;\n    //fragColor = vec4(vec3(clearness), 1.0f);\n    //fragColor = vec4(col, 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***************Buffer for color map*******************/\nstruct SMaterialInfo\n{\n    vec3  albedo;\n    vec3  emissive;\n    float specular;\n    float specularRoughness;\n    vec3  specularColor;\n    float IOR;\n    float refraction;\n    float refractionRoughness;\n    vec3  refractionColor;\n};\n\nSMaterialInfo GetZeroedMaterial()\n{\n    SMaterialInfo ret;\n    ret.albedo = vec3(0.0f, 0.0f, 0.0f);\n    ret.emissive = vec3(0.0f, 0.0f, 0.0f);\n    ret.specular = 0.0f;\n    ret.specularRoughness = 0.0f;\n    ret.specularColor = vec3(0.0f, 0.0f, 0.0f);\n    ret.IOR = 1.0f;\n    ret.refraction = 0.0f;\n    ret.refractionRoughness = 0.0f;\n    ret.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n    return ret;\n}\n\nstruct SRayHitInfo\n{\n    bool fromInside;\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        vec3 temp = d;\n        d = a;\n        a = temp;\n        temp = b;\n        b = c;\n        c = temp;\n    }\n\n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n\n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = false;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }    \n\n    return false;\n}\n\nbool TestBoxTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 startPoint, in vec3 endPoint)\n{\n    vec3 minPoint = min(startPoint, endPoint);\n    vec3 maxPoint = max(startPoint, endPoint);\n\n    float t1 = (minPoint.x - rayPos.x) / rayDir.x;\n    float t2 = (maxPoint.x - rayPos.x) / rayDir.x;\n    float t3 = (minPoint.y - rayPos.y) / rayDir.y;\n    float t4 = (maxPoint.y - rayPos.y) / rayDir.y;\n    float t5 = (minPoint.z - rayPos.z) / rayDir.z;\n    float t6 = (maxPoint.z - rayPos.z) / rayDir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0. || tmin > tmax)\n    {\n        return false;\n    }\n\n    float dist;\n    vec3 normal;\n\n    if (tmin > 0.)\n    {\n        dist = tmin;\n        vec3 hitPoint = rayPos + rayDir * tmin;\n\n        vec3 hitNormal;\n\n        if (abs(hitPoint.x - minPoint.x) < 0.001)\n        {\n            hitNormal = vec3(-1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.x - maxPoint.x) < 0.001)\n        {\n            hitNormal = vec3(1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.y - minPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, -1.0, 0.0);\n        }\n        else if (abs(hitPoint.y - maxPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, 1.0, 0.0);\n        }\n        else if (abs(hitPoint.z - minPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, -1.0);\n        }\n        else if (abs(hitPoint.z - maxPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, 1.0);\n        }\n\n        normal = normalize(hitNormal);\n    }\n    else\n    {\n        dist = tmax;\n        normal = vec3(0.0);\n    }\n    bool fromInside = false;\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }\n\n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n    vec3 m = rayPos - sphere.xyz;\n    float b = dot(m, rayDir);\n    float c = dot(m, m) - sphere.w * sphere.w;\n\n    if(c > 0.0 && b > 0.0)\n        return false;\n\n    float discr = b * b - c;\n\n    if(discr < 0.0)\n        return false;\n\n    bool fromInside = false;\n    float dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normalize((rayPos + rayDir * dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n\n    return false;\n}\n\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*2.;\n    \n    // small light cube\n    {\n        vec3 A = vec3(-24.f, -11., 27.5f);\n        vec3 B = A+vec3(1.,2.,1.)*3.;\n        if (TestBoxTrace(rayPos, rayDir, hitInfo, A, B))\n        {\n            hitInfo.material.albedo = vec3(0.996,0.624,0.945);\n            hitInfo.material.emissive = vec3(1.000*cos(iTime/2.)*5.,0.20,0.933);\n            //hitInfo.material.emissive = 5.*palette(iTime/10.,vec3(0.5, 0.5, 0.5),vec3(.5, 0.5, 0.5),vec3(1.0, 1.0, 1.0),vec3(0.00, 0.33, 0.67));\n            hitInfo.material.specular = .5f;\n            hitInfo.material.specularRoughness = .3f;\n            hitInfo.material.specularColor = vec3(1.000,1.000,1.000);\n        }\n\t}\n    \n    // silver cube box on the right\n    {\n        vec3 A = vec3(15.f, -12., 26.f);\n        vec3 B = A+vec3(2.,2.5,2.)*3.;\n        if (TestBoxTrace(rayPos, rayDir, hitInfo, A, B))\n        {\n            hitInfo.material.albedo = vec3(1.000,1.000,1.000);\n            hitInfo.material.emissive = vec3(0.);\n            hitInfo.material.specular = .000000001f;\n            hitInfo.material.specularRoughness = 0.f;\n            hitInfo.material.specularColor = vec3(1.000,1.000,1.000);\n            hitInfo.material.IOR =1.5;\n            hitInfo.material.refraction = 1.0f;\n            hitInfo.material.refractionRoughness = 0.;\n            hitInfo.material.refractionColor = vec3(0.0f, 0.5f, 1.0f);\n        }\n\t}\n    \n    // big golden cube\n    {\n        vec3 A = vec3(-23.f, -12., 31.f);\n        vec3 B = A+vec3(2.,5.,1.)*3.;\n        if (TestBoxTrace(rayPos, rayDir, hitInfo, A, B))\n        {\n            hitInfo.material.albedo = vec3(0.996,0.898,0.624);\n            hitInfo.material.emissive = vec3(0.);\n            hitInfo.material.specular = .8f;\n            hitInfo.material.specularRoughness = .3f;\n            hitInfo.material.specularColor = vec3(0.867,0.686,0.431);\n        }\n\t}\n    \n    // forward wall light\n    {\n        vec3 A = vec3(-50.f, -18., -20.) + sceneTranslation;\n        vec3 B = vec3( 50.f, -18., -20.) + sceneTranslation;\n        vec3 C = vec3( 50.f,  18., -20.) + sceneTranslation;\n        vec3 D = vec3(-50.f,  18., -20.) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.839,0.988,1.000)*.5;\n            hitInfo.material.specular = 0.0f;\n            hitInfo.material.specularRoughness = 1.f;\n            hitInfo.material.specularColor = vec3(1.);\n        }\n\t}\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-50., -50., 25.0f) + sceneTranslation;\n        vec3 B = vec3( 50., -50., 25.0f) + sceneTranslation;\n        vec3 C = vec3( 50.,  50., 25.0f) + sceneTranslation;\n        vec3 D = vec3(-50.,  50., 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n            float shade = floor(mod(hitPos.x*2., 1.f) * 2.f);\n            if(hitPos.y>-12. && hitPos.y<-5.)\n            hitInfo.material.albedo = vec3(shade, shade, shade);\n            else\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            //hitInfo.material.albedo =vec3(texture(iChannel1,rayPos.xz*.5).r);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specular = 0.5f;\n            hitInfo.material.specularRoughness = 0.5;\n            hitInfo.material.specularColor = vec3(1.);\n        }\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-50., -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 50., -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 50., -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-50., -12.45f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specular = 1.f;\n            hitInfo.material.specularRoughness = 0.0f;\n            hitInfo.material.specularColor = vec3(1.);            \n        }        \n    }\n    \n    // ceiling\n    {\n        vec3 A = vec3(-24., 24., 25.0f) + sceneTranslation;\n        vec3 B = vec3( 24., 24., 25.0f) + sceneTranslation;\n        vec3 C = vec3( 24., 24., 15.0f) + sceneTranslation;\n        vec3 D = vec3(-24., 24., 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specular = 1.f;\n            hitInfo.material.specularRoughness = 0.0f;\n            hitInfo.material.specularColor = vec3(1.);\n        }        \n    }    \n    \n    // ceiling light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n            hitInfo.material.specular = 0.0f;\n            hitInfo.material.specularRoughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    \n    \n    //middle glass ball\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-0.6f, -8.5, 18.f, 4.f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(1.);\n        hitInfo.material.emissive = vec3(0.);   \n        hitInfo.material.specular = .02;\n        hitInfo.material.specularRoughness = 0.;\n        hitInfo.material.specularColor = vec3(1.); \n        hitInfo.material.IOR =1.1;\n        hitInfo.material.refraction = 1.f;\n        hitInfo.material.refractionRoughness = 0.;\n        hitInfo.material.refractionColor = vec3(0.,0.,0.);\n    }    \n    \n    //left matt glass ball\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.f, -5., 20.0f, 3.f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(1.);\n        hitInfo.material.emissive = vec3(0.);   \n        hitInfo.material.specular = 0.1;\n        hitInfo.material.specularRoughness = 0.7;\n        hitInfo.material.specularColor = vec3(0.278,1.000,0.784); \n        hitInfo.material.IOR =1.5;\n        hitInfo.material.refraction = 1.0f;\n        hitInfo.material.refractionRoughness = 0.7;\n        hitInfo.material.refractionColor = vec3(1.000,0.000,0.000);\n    }  \n    \n    // a ball which has blue diffuse but red specular. an example of a \"bad material\".\n    // a better lighting model wouldn't let you do this sort of thing\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.0f, 0.0f, 1.0f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.specular = 0.5f;\n        hitInfo.material.specularRoughness = 0.4f;\n        hitInfo.material.specularColor = vec3(0.000,1.000,0.984);        \n    }\n    \n    // shiny green balls of varying roughnesses\n    {\n           \n        //橘色\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(mouse.x*20., mouse.y*20.,17.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(1.000,0.302,0.000)*20.;        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 0.;\n            hitInfo.material.specularColor = vec3(1.);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 0.5f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 0.75f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }        \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.,0.,1.)*10.;        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 1.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }           \n    }\n}\n\nfloat GetRedColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    float ret = 0.;\n    float throughput = 1.;\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n            break;\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor.r * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0f;\n\n        if (specularChance > 0.)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR - DispersionIOR : 1.,\n                !hitInfo.fromInside ? hitInfo.material.IOR - DispersionIOR : 1.,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.);\n            float chanceMultiplier = (1. - specularChance) / (1. - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.;\n        float doRefraction = 0.;\n        float raySelectRoll = RandomFloat01(rngState);\n\n        if (specularChance > 0. && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0. && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1. - (specularChance + refractionChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0f)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness*hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? (hitInfo.material.IOR-DispersionIOR) : 1.0f / (hitInfo.material.IOR-DispersionIOR));\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness*hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        ret += hitInfo.material.emissive.r * throughput;\n\n        if (doRefraction == 0.0f)\n            throughput *= mix(hitInfo.material.albedo.r, hitInfo.material.specularColor.r, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = throughput;\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0f / p;\n        }\n    }\n    return ret;\n}\n\nfloat GetGreenColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    float ret = 0.;\n    float throughput = 1.;\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n            break;\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor.g * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0f;\n\n        if (specularChance > 0.)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR : 1.,\n                !hitInfo.fromInside ? hitInfo.material.IOR : 1.,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.);\n            float chanceMultiplier = (1. - specularChance) / (1. - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.;\n        float doRefraction = 0.;\n        float raySelectRoll = RandomFloat01(rngState);\n\n        if (specularChance > 0. && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0. && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1. - (specularChance + refractionChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0f)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness*hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? (hitInfo.material.IOR) : 1.0f / (hitInfo.material.IOR));\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness*hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        ret += hitInfo.material.emissive.g * throughput;\n\n        if (doRefraction == 0.0f)\n            throughput *= mix(hitInfo.material.albedo.g, hitInfo.material.specularColor.g, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = throughput;\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0f / p;\n        }\n    }\n    return ret;\n}\n\nfloat GetBlueColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    float ret = 0.;\n    float throughput = 1.;\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n\n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n            break;\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor.b * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0f;\n\n        if (specularChance > 0.)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR + DispersionIOR : 1.,\n                !hitInfo.fromInside ? hitInfo.material.IOR + DispersionIOR : 1.,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.);\n            float chanceMultiplier = (1. - specularChance) / (1. - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.;\n        float doRefraction = 0.;\n        float raySelectRoll = RandomFloat01(rngState);\n\n        if (specularChance > 0. && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0. && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1. - (specularChance + refractionChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0f)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness*hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? (hitInfo.material.IOR+DispersionIOR) : 1.0f / (hitInfo.material.IOR+DispersionIOR));\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness*hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        ret += hitInfo.material.emissive.b * throughput;\n\n        if (doRefraction == 0.0f)\n            throughput *= mix(hitInfo.material.albedo.b, hitInfo.material.specularColor.b, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = throughput;\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0f / p;\n        }\n    }\n    return ret;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(2003) + uint(fragCoord.y) * uint(200306) + uint(iFrame) * uint(20030608)) | uint(1);\n\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 uv = (fragCoord + jitter - 0.5 * iResolution.xy) / iResolution.y;\n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);\n    vec3 rayTarget = vec3(uv, cameraDistance);\n    \n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    vec3 color = vec3(0.);\n    \n    float c_numRendersPerFrame = texture(iChannel3,uv).z;\n    float doRefresh = texture(iChannel3,uv).a;\n    \n    for (float index = 0.; index < c_numRendersPerFrame; index++)\n    {\n        color.r += GetRedColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n        color.g += GetGreenColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n        color.b += GetBlueColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n    }\n\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (doRefresh==1.||iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    fragColor = vec4(color, blend);\n}\n\n \n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define DispersionIOR 0.005\nconst float c_minimumRayHitTime = 0.01f;\nconst float c_rayPosNormalNudge = 0.01f;\nconst float c_superFar = 100.0f;\nconst float c_FOVDegrees = 90.0f;\nconst int c_numBounces = 12;\n\nconst float c_exposure = 1.f; \nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float KEY_SPACE = 32.5/256.0;\n\n//camera depth of field\nconst float minDistance = 0.;\nconst float maxDistance = 30.;\nconst float clearDistance = 12.;\nconst float DOF = 10.;\nconst float Blur = 5.;\n\nuint hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(56)) ^ uint(seed >> uint(12));\n    seed *= uint(8);\n    seed = seed ^ (seed >> 5);\n    seed *= uint(0x18b3ce5f);\n    seed = seed ^ (seed >> 6);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float min_reflectance, float max_reflectance)\n{\n    float R = (n1 - n2) *(n1 - n2)/ (n1 + n2)*(n1 + n2);\n    float cosI = -dot(normal, incident);\n    \n    if (n1 > n2)\n    {\n        float n = n1 / n2;\n        float sinT2 = n * n * (1.0 - cosI * cosI);\n        if (sinT2 > 1.0)\n            return max_reflectance;\n            \n        cosI = sqrt(1.0 - sinT2);\n    }\n    \n    float x = 1.0 - cosI;\n    float ret = R + (1.0 - R) * x * x * x * x * x;\n\n    return mix(min_reflectance, max_reflectance, ret);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n\nfloat map(float value, float in_min, float in_max, float out_min, float out_max) {\n    return out_min + (out_max - out_min) * (value - in_min) / (in_max - in_min);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***************Buffer for depth map*******************/\n\n/*************************************************************\n\nIt's basically a copy from bufferA.\nActually most things are useless for calculate distance.\n\n**************************************************************/\nstruct SMaterialInfo\n{\n    vec3  albedo;\n    vec3  emissive;\n    float specular;\n    float specularRoughness;\n    vec3  specularColor;\n    float IOR;\n    float refraction;\n    float refractionRoughness;\n    vec3  refractionColor;\n};\n\nSMaterialInfo GetZeroedMaterial()\n{\n    SMaterialInfo ret;\n    ret.albedo = vec3(0.0f, 0.0f, 0.0f);\n    ret.emissive = vec3(0.0f, 0.0f, 0.0f);\n    ret.specular = 0.0f;\n    ret.specularRoughness = 0.0f;\n    ret.specularColor = vec3(0.0f, 0.0f, 0.0f);\n    ret.IOR = 1.0f;\n    ret.refraction = 0.0f;\n    ret.refractionRoughness = 0.0f;\n    ret.refractionColor = vec3(0.0f, 0.0f, 0.0f);\n    return ret;\n}\n\nstruct SRayHitInfo\n{\n    bool fromInside;\n    float dist;\n    vec3 normal;\n    SMaterialInfo material;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        vec3 temp = d;\n        d = a;\n        a = temp;\n        temp = b;\n        b = c;\n        c = temp;\n    }\n\n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n\n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = false;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }    \n\n    return false;\n}\n\nbool TestBoxTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 startPoint, in vec3 endPoint)\n{\n    vec3 minPoint = min(startPoint, endPoint);\n    vec3 maxPoint = max(startPoint, endPoint);\n\n    float t1 = (minPoint.x - rayPos.x) / rayDir.x;\n    float t2 = (maxPoint.x - rayPos.x) / rayDir.x;\n    float t3 = (minPoint.y - rayPos.y) / rayDir.y;\n    float t4 = (maxPoint.y - rayPos.y) / rayDir.y;\n    float t5 = (minPoint.z - rayPos.z) / rayDir.z;\n    float t6 = (maxPoint.z - rayPos.z) / rayDir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0. || tmin > tmax)\n    {\n        return false;\n    }\n\n    float dist;\n    vec3 normal;\n\n    if (tmin > 0.)\n    {\n        dist = tmin;\n        vec3 hitPoint = rayPos + rayDir * tmin;\n\n        vec3 hitNormal;\n\n        if (abs(hitPoint.x - minPoint.x) < 0.001)\n        {\n            hitNormal = vec3(-1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.x - maxPoint.x) < 0.001)\n        {\n            hitNormal = vec3(1.0, 0.0, 0.0);\n        }\n        else if (abs(hitPoint.y - minPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, -1.0, 0.0);\n        }\n        else if (abs(hitPoint.y - maxPoint.y) < 0.001)\n        {\n            hitNormal = vec3(0.0, 1.0, 0.0);\n        }\n        else if (abs(hitPoint.z - minPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, -1.0);\n        }\n        else if (abs(hitPoint.z - maxPoint.z) < 0.001)\n        {\n            hitNormal = vec3(0.0, 0.0, 1.0);\n        }\n\n        normal = normalize(hitNormal);\n    }\n    else\n    {\n        dist = tmax;\n        normal = vec3(0.0);\n    }\n    bool fromInside = false;\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normal;\n        return true;\n    }\n\n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n    vec3 m = rayPos - sphere.xyz;\n    float b = dot(m, rayDir);\n    float c = dot(m, m) - sphere.w * sphere.w;\n\n    if(c > 0.0 && b > 0.0)\n        return false;\n\n    float discr = b * b - c;\n\n    if(discr < 0.0)\n        return false;\n\n    bool fromInside = false;\n    float dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    if (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.fromInside = fromInside;\n        info.dist = dist;\n        info.normal = normalize((rayPos + rayDir * dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n\n    return false;\n}\n\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*2.;\n    \n    // small light cube\n    {\n        vec3 A = vec3(-24.f, -11., 27.5f);\n        vec3 B = A+vec3(1.,2.,1.)*3.;\n        if (TestBoxTrace(rayPos, rayDir, hitInfo, A, B))\n        {\n            hitInfo.material.albedo = vec3(0.996,0.624,0.945);\n            hitInfo.material.emissive = vec3(1.000*cos(iTime/2.)*5.,0.20,0.933);\n            //hitInfo.material.emissive = 5.*palette(iTime/10.,vec3(0.5, 0.5, 0.5),vec3(.5, 0.5, 0.5),vec3(1.0, 1.0, 1.0),vec3(0.00, 0.33, 0.67));\n            hitInfo.material.specular = .5f;\n            hitInfo.material.specularRoughness = .3f;\n            hitInfo.material.specularColor = vec3(1.000,1.000,1.000);\n        }\n\t}\n    \n    // silver cube box on the right\n    {\n        vec3 A = vec3(15.f, -12., 26.f);\n        vec3 B = A+vec3(2.,2.5,2.)*3.;\n        if (TestBoxTrace(rayPos, rayDir, hitInfo, A, B))\n        {\n            hitInfo.material.albedo = vec3(1.000,1.000,1.000);\n            hitInfo.material.emissive = vec3(0.);\n            hitInfo.material.specular = .000000001f;\n            hitInfo.material.specularRoughness = 0.f;\n            hitInfo.material.specularColor = vec3(1.000,1.000,1.000);\n            hitInfo.material.IOR =1.5;\n            hitInfo.material.refraction = 1.0f;\n            hitInfo.material.refractionRoughness = 0.;\n            hitInfo.material.refractionColor = vec3(0.0f, 0.5f, 1.0f);\n        }\n\t}\n    \n    // big golden cube\n    {\n        vec3 A = vec3(-23.f, -12., 31.f);\n        vec3 B = A+vec3(2.,5.,1.)*3.;\n        if (TestBoxTrace(rayPos, rayDir, hitInfo, A, B))\n        {\n            hitInfo.material.albedo = vec3(0.996,0.898,0.624);\n            hitInfo.material.emissive = vec3(0.);\n            hitInfo.material.specular = .8f;\n            hitInfo.material.specularRoughness = .3f;\n            hitInfo.material.specularColor = vec3(0.867,0.686,0.431);\n        }\n\t}\n    \n    // forward wall light\n    {\n        vec3 A = vec3(-50.f, -18., -20.) + sceneTranslation;\n        vec3 B = vec3( 50.f, -18., -20.) + sceneTranslation;\n        vec3 C = vec3( 50.f,  18., -20.) + sceneTranslation;\n        vec3 D = vec3(-50.f,  18., -20.) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.839,0.988,1.000)*.5;\n            hitInfo.material.specular = 0.0f;\n            hitInfo.material.specularRoughness = 1.f;\n            hitInfo.material.specularColor = vec3(1.);\n        }\n\t}\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-50., -50., 25.0f) + sceneTranslation;\n        vec3 B = vec3( 50., -50., 25.0f) + sceneTranslation;\n        vec3 C = vec3( 50.,  50., 25.0f) + sceneTranslation;\n        vec3 D = vec3(-50.,  50., 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n            float shade = floor(mod(hitPos.x*2., 1.f) * 2.f);\n            if(hitPos.y>-12. && hitPos.y<-5.)\n            hitInfo.material.albedo = vec3(shade, shade, shade);\n            else\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            //hitInfo.material.albedo =vec3(texture(iChannel1,rayPos.xz*.5).r);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specular = 0.5f;\n            hitInfo.material.specularRoughness = 0.5;\n            hitInfo.material.specularColor = vec3(1.);\n        }\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-50., -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 50., -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 50., -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-50., -12.45f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specular = 1.f;\n            hitInfo.material.specularRoughness = 0.0f;\n            hitInfo.material.specularColor = vec3(1.);            \n        }        \n    }\n    \n    // ceiling\n    {\n        vec3 A = vec3(-24., 24., 25.0f) + sceneTranslation;\n        vec3 B = vec3( 24., 24., 25.0f) + sceneTranslation;\n        vec3 C = vec3( 24., 24., 15.0f) + sceneTranslation;\n        vec3 D = vec3(-24., 24., 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.specular = 1.f;\n            hitInfo.material.specularRoughness = 0.0f;\n            hitInfo.material.specularColor = vec3(1.);\n        }        \n    }    \n    \n    // ceiling light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 10.0f;\n            hitInfo.material.specular = 0.0f;\n            hitInfo.material.specularRoughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    \n    \n    //middle glass ball\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-0.6f, -8.5, 18.f, 4.f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(1.);\n        hitInfo.material.emissive = vec3(0.);   \n        hitInfo.material.specular = .02;\n        hitInfo.material.specularRoughness = 0.;\n        hitInfo.material.specularColor = vec3(1.); \n        hitInfo.material.IOR =1.1;\n        hitInfo.material.refraction = 1.f;\n        hitInfo.material.refractionRoughness = 0.;\n        hitInfo.material.refractionColor = vec3(0.,0.,0.);\n    }    \n    \n    //left matt glass ball\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.f, -5., 20.0f, 3.f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(1.);\n        hitInfo.material.emissive = vec3(0.);   \n        hitInfo.material.specular = 0.1;\n        hitInfo.material.specularRoughness = 0.7;\n        hitInfo.material.specularColor = vec3(0.278,1.000,0.784); \n        hitInfo.material.IOR =1.5;\n        hitInfo.material.refraction = 1.0f;\n        hitInfo.material.refractionRoughness = 0.7;\n        hitInfo.material.refractionColor = vec3(1.000,0.000,0.000);\n    }  \n    \n    // a ball which has blue diffuse but red specular. an example of a \"bad material\".\n    // a better lighting model wouldn't let you do this sort of thing\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.0f, 0.0f, 1.0f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.specular = 0.5f;\n        hitInfo.material.specularRoughness = 0.4f;\n        hitInfo.material.specularColor = vec3(0.000,1.000,0.984);        \n    }\n    \n    // shiny green balls of varying roughnesses\n    {\n           \n        //橘色\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(mouse.x*20., mouse.y*20.,17.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(1.000,0.302,0.000)*20.;        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 0.;\n            hitInfo.material.specularColor = vec3(1.);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 0.5f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 0.75f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }        \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.,0.,1.)*10.;        \n            hitInfo.material.specular = 1.0f;\n            hitInfo.material.specularRoughness = 1.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }           \n    }\n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    vec3 ret = vec3(0.);\n    vec3 throughput = vec3(1.);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    float totalDistance = 0.;\n    for (int bounceIndex = 0; bounceIndex <= 0; ++bounceIndex)\n    {\n        SRayHitInfo hitInfo;\n        hitInfo.material = GetZeroedMaterial();\n        hitInfo.dist = c_superFar;\n        hitInfo.fromInside = false;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n\n        if (hitInfo.dist == c_superFar)\n        {\n            //ret += SRGBToLinear(texture(iChannel1, rayDir).rgb) * throughput;\n            break;\n        }\n\n        if (hitInfo.fromInside)\n            throughput *= exp(-hitInfo.material.refractionColor * hitInfo.dist);\n\n        float specularChance = hitInfo.material.specular;\n        float refractionChance = hitInfo.material.refraction;\n\n        float rayProbability = 1.0f;\n\n        if (specularChance > 0.)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.fromInside ? hitInfo.material.IOR : 1.,\n                !hitInfo.fromInside ? hitInfo.material.IOR : 1.,\n                rayDir, hitInfo.normal, hitInfo.material.specular, 1.);\n            float chanceMultiplier = (1. - specularChance) / (1. - hitInfo.material.specular);\n            refractionChance *= chanceMultiplier;\n        }\n\n        float doSpecular = 0.;\n        float doRefraction = 0.;\n        float raySelectRoll = RandomFloat01(rngState);\n        if (specularChance > 0. && raySelectRoll < specularChance)\n        {\n            doSpecular = 1.;\n            rayProbability = specularChance;\n        }\n        else if (refractionChance > 0. && raySelectRoll < specularChance + refractionChance)\n        {\n            doRefraction = 1.;\n            rayProbability = refractionChance;\n        }\n        else\n        {\n            rayProbability = 1. - (specularChance + refractionChance);\n        }\n\n        rayProbability = max(rayProbability, 0.001);\n\n        if (doRefraction == 1.0f)\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;\n        }\n        else\n        {\n            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        }\n\n        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness * hitInfo.material.specularRoughness));\n        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? hitInfo.material.IOR : 1.0f / hitInfo.material.IOR);\n        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness * hitInfo.material.refractionRoughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        rayDir = mix(rayDir, refractionRayDir, doRefraction);\n\n        if (dot(rayDir, vec3(0., 0., 1.)) > 0.)\n            totalDistance += dot(hitInfo.dist * normalize(rayDir), vec3(0., 0., 1.));\n        if (dot(rayDir, vec3(0., 0., 1.)) < 0.)\n            totalDistance += dot(hitInfo.dist * normalize(rayDir), vec3(0., 0., -1.));\n\n        if (doRefraction == 0.0f)\n            throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);\n\n        throughput /= rayProbability;\n\n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            throughput *= 1.0f / p;\n        }\n    }\n    totalDistance = clamp(totalDistance, minDistance, maxDistance);\n    totalDistance = map(totalDistance, minDistance, maxDistance, 0., 1.);\n    totalDistance = pow(totalDistance, 2.);\n    ret = vec3(totalDistance);\n    return ret;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 uv = (fragCoord + jitter - 0.5 * iResolution.xy) / iResolution.y;\n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);\n\n    vec3 rayTarget = vec3(uv, cameraDistance);\n    \n    vec3 rayDir = normalize(rayTarget - rayPosition);\n\n    vec3 color = vec3(0.);\n    \n    float c_numRendersPerFrame = texture(iChannel3,uv).z;\n    float doRefresh = texture(iChannel3,uv).a;\n    \n    for (float index = 0.; index < c_numRendersPerFrame; index++)\n        color += GetColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);\n\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (doRefresh==1.||iFrame < 2 || iMouse.z > 0.0 || lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n\n    fragColor = vec4(color, blend);\n}\n\n \n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// This buffer keeps track of the screen resolution and adapts the number of samples\n// per frame depending on hardware(fps) performaces.\n// It enables Buffer A & B to invalidate previously computed samples in case the screen is\n// resized.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n\tvec2 uv = fragCoord/iResolution.xy;\n\n    vec4 prevParams = texture(iChannel0, uv);\n\n    // Ensure the buffer is first initialized with null \n    // parameters and checks for resolution changes   \n    if (abs(prevParams.x - iResolution.x) > 1. ||\n        abs(prevParams.y - iResolution.y) > 1.) {        \n        fragColor = vec4(\n            iResolution.xy,\n            1.,//update c_numRendersPerFrame, start at 1\n            1);//to reset or not\n    } else {\n        fragColor = vec4(\n            iResolution.xy, \n            prevParams.z, \n            0);\n    }\n\n    // Adaptative samples per frame, updates each 10 frames\n    if (fragColor.w > 0.5 && iFrame%20 == 0) {\n        if (iFrameRate >= 25.0) {\n            fragColor.z = prevParams.z+1.;\n        } else if (iFrameRate <= 15.0 && prevParams.z>=1.) {\n            fragColor.z = prevParams.z-1.;\n            \n        }\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"}]}