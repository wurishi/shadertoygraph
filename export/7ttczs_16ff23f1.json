{"ver":"0.1","info":{"id":"7ttczs","date":"1678371126","viewed":70,"name":"cloudz","username":"timspik","description":"cloudz3 shadows","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Get screen dimensions\n    vec2 screenResolution = iResolution.xy;\n    float screenWidth = screenResolution.x;\n    float screenHeight = screenResolution.y;\n\n    // Gaussian blur parameters\n    float sigma = 5.0; // Adjust this value for blur strength\n    int radius = int(3.0 * sigma);\n\n    vec3 blurColor = vec3(0.0);\n\n    for (int i = -radius; i <= radius; i++)\n    {\n        float offset = float(i);\n        float weight = exp(-0.5 * (offset * offset) / (sigma * sigma)) / (sigma * sqrt(2.0 * 3.14159));\n\n        // Debug: Output sampled color before blur\n        vec3 sampleColor = texture(iChannel0, fragCoord / screenResolution).rgb;\n\n        // Accumulate blurred color\n        blurColor += sampleColor * weight;\n\n        // Debug: Output accumulated color at each step\n        fragColor = vec4(blurColor, 1.0);\n    }\n\n    // Normalize the accumulated color\n    blurColor /= float(2 * radius + 1);\n\n    // Output the final result\n    fragColor = vec4(blurColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray{\n    vec3 r;\n    float e;\n};\n\nconst int MAX_STEPS = 500;\nconst float STEP_DISTANCE = 0.01;\n\n\nconst vec3 VOLUME_ORIGIN = vec3(-2,-2,-1);\nconst float timeSpeed = 0.2;\nvec3 VOLUME_X = vec3(1,0,0);\nvec3 VOLUME_Y = vec3(0,1,0);\nvec3 VOLUME_Z = vec3(0,0,1);\nconst float VOLUME_WIDTH = 2.;\nconst float VOLUME_HEIGHT = 2.;\nconst float VOLUME_DEPTH = 2.;\n \n/*float findClosest(vec2 uv)\n{\n    //top\n    //left\n    //right\n\n}*/\nvec3 dummyTex(vec2 uv){\n    if( (uv.x > 0. && uv.y > 0.) && (uv.x < .1 && uv.y < .2)){\n        return vec3(0,0,0);\n    }else if( (uv.x > 0.2 && uv.y > 0.)){\n        return vec3(0.5,0.5,0.5);\n    }\n    else\n        return vec3(-1,-1,-1);\n}\nvec3 sampleTex(vec2 front,vec2 side,vec2 bot){\n   float f = texture(iChannel1, front).x;\n   float s = texture(iChannel2, side).x;\n   float b = texture(iChannel3, bot).x;\n   \n   vec3 pos = vec3(f,s,b);\n   return pos;\n}\nvec3 getNormal(vec3 pos,vec3 origin){\n    return normalize(pos - origin);\n}\nRay shadowFound(Ray r){\n   \n   vec3 prerotated = r.r;\n     mat3 rotator = mat3(cos(iTime*timeSpeed),0.,sin(iTime*timeSpeed),0,1.,0.,-sin(iTime*timeSpeed),0.,cos(iTime*timeSpeed));\n      mat3 mover = mat3(1,0,0,0,1,0,0,0,1);\n        r.r *= rotator; \n        \n    /* LIGH */\n    vec3 lightPos = vec3(0,0,1000);        \n    //\n\n    float x = (r.r.x - VOLUME_ORIGIN.x)/VOLUME_WIDTH;\n    float y = (r.r.y - VOLUME_ORIGIN.y)/VOLUME_HEIGHT;\n    float z = (r.r.z - VOLUME_ORIGIN.z)/VOLUME_DEPTH;\n    if((x < 0. || y < 0. || z < 0.)){\n      r.r = prerotated;\n\n        return r;\n    }\n    vec2 side = vec2(z,y);\n    vec2 front = vec2(x,y);\n    vec2 bot = vec2(z,x);\n    \n    /*\n    vec3 sideSample = dummyTex(side);\n    vec3 frontSample =  dummyTex(front);\n    vec3 botSample =  dummyTex(bot);\n    */\n    //mat3 rotator = mat3(cos(iTime*.02),0.,sin(iTime*.02),0,1.,0.,-sin(iTime*.02),0.,cos(iTime*.02));\n    /*VOLUME_X *= rotator; \n    VOLUME_Y *= rotator; \n    VOLUME_Z *= rotator; \n    \n    VOLUME_X = rotator*VOLUME_X; \n    VOLUME_Y = rotator*VOLUME_Y; \n    VOLUME_Z = rotator*VOLUME_Z;*/\n    \n    vec3 samplePosition = sampleTex(front,side,bot);\n    vec3 wP = VOLUME_ORIGIN + (VOLUME_X * samplePosition.x*VOLUME_WIDTH) + \n                              (VOLUME_Y * samplePosition.y*VOLUME_HEIGHT) +\n                              (VOLUME_Z * samplePosition.z*VOLUME_DEPTH);\n    // vec3 wP = VOLUME_ORIGIN + vec3(frontSample.x*VOLUME_WIDTH,botSample.x*VOLUME_HEIGHT,sideSample.x*VOLUME_DEPTH);\n    //vec3 wP = VOLUME_ORIGIN; //+ vec3(frontSample.x*VOLUME_WIDTH,botSample.y*VOLUME_HEIGHT,sideSample.z*VOLUME_DEPTH);\n   \n     if(length(r.r-wP) > 2. || samplePosition.x < 0. ||  samplePosition.y < 0. ||  samplePosition.z < 0.){\n     r.r = prerotated;\n     return r;\n    }\n    else{\n        r.e += .002; \n        //calculate energy loos       \n    \n        r.r = prerotated;\n     return r;\n\n    }\n    \n    \n/*\n    if(length(rO-wP) > 0.5 || sideSample.x < 0. ||  frontSample.x < 0. ||  botSample.x < 0.)\n        return false;\n    else\n        return true;\n*/\n        \n}\nfloat shadowRayMarch(vec3 rO,vec3 rD){\n    Ray r = Ray(rO,0.);\n     \n    for(int i = 0;i < 100;i++){\n        //float d = findClosest(rO);\n        /*if(d < 0.0005)\n            return 1.;*/\n        r.r = r.r + (rD * STEP_DISTANCE/*d*/);\n      \n        r = shadowFound(r);\n    }\n    return r.e;\n}\nRay found(Ray r){\n   \n   vec3 prerotated = r.r;\n     mat3 rotator = mat3(cos(iTime*timeSpeed),0.,sin(iTime*timeSpeed),0,1.,0.,-sin(iTime*timeSpeed),0.,cos(iTime*timeSpeed));\n      mat3 mover = mat3(1,0,0,0,1,0,0,0,1);\n        r.r *= rotator; \n        \n    /* LIGH */\n    vec3 lightPos = vec3(1,cos(1.)*100.,100);        \n    //\n\n    float x = (r.r.x - VOLUME_ORIGIN.x)/VOLUME_WIDTH;\n    float y = (r.r.y - VOLUME_ORIGIN.y)/VOLUME_HEIGHT;\n    float z = (r.r.z - VOLUME_ORIGIN.z)/VOLUME_DEPTH;\n    if((x < 0. || y < 0. || z < 0.)){\n      r.r = prerotated;\n\n        return r;\n    }\n    vec2 side = vec2(z,y);\n    vec2 front = vec2(x,y);\n    vec2 bot = vec2(z,x);\n    \n    /*\n    vec3 sideSample = dummyTex(side);\n    vec3 frontSample =  dummyTex(front);\n    vec3 botSample =  dummyTex(bot);\n    */\n    //mat3 rotator = mat3(cos(iTime*.02),0.,sin(iTime*.02),0,1.,0.,-sin(iTime*.02),0.,cos(iTime*.02));\n    /*VOLUME_X *= rotator; \n    VOLUME_Y *= rotator; \n    VOLUME_Z *= rotator; \n    \n    VOLUME_X = rotator*VOLUME_X; \n    VOLUME_Y = rotator*VOLUME_Y; \n    VOLUME_Z = rotator*VOLUME_Z;*/\n    \n    vec3 samplePosition = sampleTex(front,side,bot);\n    vec3 wP = VOLUME_ORIGIN + (VOLUME_X * samplePosition.x*VOLUME_WIDTH) + \n                              (VOLUME_Y * samplePosition.y*VOLUME_HEIGHT) +\n                              (VOLUME_Z * samplePosition.z*VOLUME_DEPTH);\n    // vec3 wP = VOLUME_ORIGIN + vec3(frontSample.x*VOLUME_WIDTH,botSample.x*VOLUME_HEIGHT,sideSample.x*VOLUME_DEPTH);\n    //vec3 wP = VOLUME_ORIGIN; //+ vec3(frontSample.x*VOLUME_WIDTH,botSample.y*VOLUME_HEIGHT,sideSample.z*VOLUME_DEPTH);\n   \n     if(length(r.r-wP) > 2. || samplePosition.x < 0. ||  samplePosition.y < 0. ||  samplePosition.z < 0.){\n     r.r = prerotated;\n     return r;\n    }\n    else{\n        r.e += .002; \n        //calculate energy loos       \n        float se = shadowRayMarch(r.r,lightPos-r.r);\n        r.e -= se*.5;\n        r.r = prerotated;\n     return r;\n\n    }\n    \n    \n/*\n    if(length(rO-wP) > 0.5 || sideSample.x < 0. ||  frontSample.x < 0. ||  botSample.x < 0.)\n        return false;\n    else\n        return true;\n*/\n        \n}\nfloat findClosest(vec3 rO){\n    return length(rO - VOLUME_ORIGIN) - 2.;\n}\n\nfloat rayMarch(vec3 rO,vec3 rD){\n    Ray r = Ray(rO,0.);\n     \n    for(int i = 0;i < MAX_STEPS;i++){\n        //float d = findClosest(rO);\n        /*if(d < 0.0005)\n            return 1.;*/\n        r.r = r.r + (rD * STEP_DISTANCE/*d*/);\n      \n        r = found(r);\n    }\n    return r.e;\n}\n// ... (previous code)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x = uv.x * (iResolution.x / iResolution.y);\n    vec3 ct = vec3(uv, -4);\n    vec3 cO = vec3(0, 0.3, -5);\n\n    mat3 rotator = mat3(cos(iTime), 0.0, sin(iTime), 0.0, 1.0, 0.0, -sin(iTime), 0.0, cos(iTime));\n    //cO *= rotator;\n    //ct *= rotator;\n\n    float c = rayMarch(cO, normalize(ct - cO));\n\n    fragColor = vec4(c,c,c, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}