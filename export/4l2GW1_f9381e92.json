{"ver":"0.1","info":{"id":"4l2GW1","date":"1428706699","viewed":535,"name":"Evacuation ","username":"Xor","description":"3D hall evacuation test.","likes":19,"published":1,"flags":8,"usePreview":0,"tags":["procedural","3d","sound","xor","lights","hall","crates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\nHere is a test of the sound functions.\nI wanted a nice kind of spooky feel to this with the light buzz.\nI also added alarms and blinking lights to add to the effect.\n\nBy Xor\n*/\n#define lcolor mix(vec3(1.0,0.5,0.2),vec3(1.2,0.2,0.1),clamp(iTime-10.0,0.0,1.0))\n#define lights 16.0\n#define crates 32.0\n#define barrels 8.0\n#define alarm clamp(iTime-10.0,0.0,2.0)\n\n#define SHADOWS\nfloat rand(vec3 p)\n{\n \treturn fract(abs(cos(mod(dot(p,vec3(84.53,93.38,65.26)),8060.0))*46.35));\n}\nfloat srand(vec3 p)\n{\n \tvec3 f = floor(p);\n    vec3 s = smoothstep(vec3(0.0),vec3(1.0),fract(p));\n    \n    return mix(mix(mix(rand(f),rand(f+vec3(1.0,0.0,0.0)),s.x),\n           mix(rand(f+vec3(0.0,1.0,0.0)),rand(f+vec3(1.0,1.0,0.0)),s.x),s.y),\n           mix(mix(rand(f+vec3(0.0,0.0,1.0)),rand(f+vec3(1.0,0.0,1.0)),s.x),\n           mix(rand(f+vec3(0.0,1.0,1.0)),rand(f+vec3(1.0,1.0,1.0)),s.x),s.y),s.z);\n}\nvec3 srand3(vec3 p)\n{\n \treturn vec3(srand(p.xyz),srand(p.yzx),srand(p.zxy));\n}\nfloat dcrate(vec3 p, vec3 c)\n{\n \treturn length(max(abs(c)-vec3(0.6,0.6,0.6),0.0)); \n}\nfloat dbarrel(vec3 p, vec3 b)\n{\n \tvec2 d = abs(vec2(length(p.xz-b.xz),p.y-b.y)) - vec2(0.4,0.6);\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)); \n}\nfloat model(vec3 p)\n{\n    vec3 P = vec3(mod(p.x,lights)-lights*0.5,p.y,abs(p.z));\n    //float light = length(vec3(floor(p.x/lights)*lights+lights*0.5,2.0,0.0)-p)-0.2;\n    vec3 cc = vec3(mod(p.x,crates)-rand(vec3(floor(p.x/crates),0.0,0.0))\n              *(crates-1.0),p.y,p.z+3.0+rand(vec3(0.0,0.0,floor(p.x/crates)))*2.0);\n    float crate = dcrate(p,cc-vec3(0.0,-1.7,2.4));\n    \n    vec3 bc = vec3(mod(p.x,barrels)-2.0-rand(vec3(floor(p.x/barrels)))\n              *(barrels),p.y,p.z-rand(vec3(floor(p.x/barrels)))*1.0);\n    float ceiling = floor(min(abs(p.z*2.0),max(sign(p.y),0.0)))*0.5;\n    float barrel = dbarrel(bc,vec3(0.0,-1.7,1.0)); \n    float pillar = length(max(abs(P-vec3(0.0,0.0,2.6))-vec3(0.1,3.0,0.4),0.0));\n \treturn min(min(3.0-abs(p.z),2.0+ceiling-abs(p.y))*0.7,min(barrel,min(pillar,crate)));\n}\nvec3 background(vec3 d)\n{\n    return vec3(0.05);\n}\nfloat shadow(vec3 p, vec3 L)\n{\n    float l = 1.0;\n    #ifdef SHADOWS\n    float h = 1.0;\n    float r = 1.0;\n    vec3 d = (L-p)/8.0;\n    for(int i = 0;i<80;i++)\n    {\n\t    h = model( p+d*r);\n        l = min(l,h/r*4.0);\n        r = max(r-h,0.2);\n        if (h < 0.0 || r < 0.2 ) break; \n    }\n    #endif\n    return l;\n}\nvec3 color(vec3 p,vec3 norm, vec3 d)\n{\n    vec2 uv = (p.xz+vec2(srand3(p).xy+(srand3(p*2.0).zx))*0.1+p.y)*0.23;\n    float s = (srand(p)*0.2+srand(p*6.0)*0.125+srand(p*16.0)*0.0625)*0.5+0.3;\n    s *= clamp(1.0-min(3.0-abs(p.z),2.0-abs(p.y))*100.0,0.5,1.0);\n    float t = 1.0-abs(norm.y-0.8)*0.5*(0.25-abs(0.5-fract(p.x))*abs(0.5-fract(p.z)));\n    \n    vec3 light = vec3(floor(p.x/lights)*lights+lights*0.5,1.9,0.0);\n    vec3 l = (dot(norm,normalize(light-p))*0.5+0.5)*lcolor;\n    float S = pow(clamp(dot(reflect(norm,d),normalize(light-p)),0.0,1.0)*0.5+texture(iChannel0,uv).r*0.5,8.0);\n    float f = 1.0-pow(srand(vec3(floor(p.x/lights))),4.0)*srand(vec3(iTime*8.0))-cos(iTime*8.0)*alarm*0.5;\n    float a = max(1.0-length(light-p)/lights*2.0,0.0)*f;\n    float b = shadow(p,light);\n \treturn vec3(b*s*t*mix(vec3(0.2),l,a*0.5+0.5)+S*lcolor*a+max(0.5-length(light-p),0.0)*f*lcolor*8.0);  \n}\nfloat dist(vec3 p, vec3 d)\n{\n    float h = 1.0;\n    float r = 1.0;\n    float dis = -1.0;\n    for(int i = 0;i<80;i++)\n    {\n\t    h = model( p+d*r);\n        r += h;\n        if (h < 0.0 || r > 40.0 ) break; \n    }\n    if( r < 40.0 ) dis = r;\n    return dis;\n}\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, float roll)//Function by Iq\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = ( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = ( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 calcNormal(vec3 pos )//Also by Iq\n{\n    const float eps = 0.002;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*model( pos + v1*eps ) + \n\t\t\t\t\t  v2*model( pos + v2*eps ) + \n\t\t\t\t\t  v3*model( pos + v3*eps ) + \n\t\t\t\t\t  v4*model( pos + v4*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 f = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;//2D Position\n    vec3 p = vec3((iTime-10.0)*(2.0+clamp(iTime-10.0,0.0,4.0)),srand3(vec3(0.0,iTime*2.0,0.0)).xy*alarm*0.2-alarm*0.1);//3D Position\n    vec3 m = vec3(1.0,0.0,0.0);//Motion direction\n    mat3 cm = calcLookAtMatrix(p,p+m,0.0);//Camera matrix\n    vec3 d = normalize( cm * vec3(f.xy,2.0) );//Ray direction\n    float r = dist(p,d);//Ray distance\n    vec3 c = background(d);//Background Color\n    if (r>0.0)\n    {\n    \tc = mix(color(p+d*r,calcNormal(p+d*r),d),c,pow(r/40.0,2.0));//Material color and fade\n    }\n\tfragColor = vec4(c,1.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define lights 16.0\n#define pi atan(1.0)*8.0\n\nvec2 mainSound( in int samp,float time)\n{\n    float light = fract(80.0*time)*(0.05*sin(time/lights*2.0*6.2831)+0.1);//Light buzz\n    float alarm = sin(pi*fract(time)*(80.0+fract(time)*40.0))*2.0;\n    return vec2(mix(light,alarm,clamp(time-10.0,0.0,1.0)) );\n}","name":"","description":"","type":"sound"}]}