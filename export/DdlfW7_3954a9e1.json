{"ver":"0.1","info":{"id":"DdlfW7","date":"1688822122","viewed":202,"name":"Spectral Light Tracing 2D","username":"pppp11111","description":"Spectral Light Tracing\n\nAdjust RT2D_RAY_PER_FRAME at common tab to 1~4(impressive pattern) or very high value(1000~) (fast convergence)\n\nInspired by https://benedikt-bitterli.me/tantalum/","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["2d","light","tracing","dispersion","path","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Spectral Light Tracing 2D\n    \n    \n    This is spectral rendering to accrately simulate dispersion effect at boundary.\n    \n    7.11 23 : light tracing default light type to delta light not area for faster convergence.\n    \n    10.28 23 : On MacOS, Use OpenGL as backend!!!\n    \n    10.29 23 : Metal does not work with 'discard'. Replaced all discard woth return.\n    \n    11.29 23 : Add more aggressive if condition on BufferB most inner loop, \n                result in signifiantly improve the performance.\n                How?\n                Gathering rays Correctly require ray's origin, direction, length and intensity.\n                But BufferA does not save ray data as it is but pre calc some terms\n                    to save the instructions on BufferB's gatering pass\n                    and to preserve the direction's precision.(some device has RGBA16F buffer)\n                So first fetch the vec4: ray_origin/ray_inv_dir, ray_inv_dir\n                    and if current pixel passes slab test with this ray,   \n                    than (<---CHANGE POINT) fetch extra data vec4: intensity.xyz, ray_length\n                    and adjust ray intensity based on delta: (ray_length - ray_origin_to_slab_dist).\n    \n    Change setting from common tab\n        Light tracing (default) works well with small light source\n            ray traced from the light source\n            trace ray from buffer A, gather ray from Buffer B\n            (light sampling is hardcoded ;;)\n            \n        Unidirectional tracing works well with large light source\n            ray traced form each pixel\n            trace ray from buffer A, Buffer B unused.\n    \n    \n    Current dispersion profile is very exaggerated.\n        change iors(float wl) at common tab if you want other profile.\n    \n    \n    \n    if you found bug, please report !!\n    \n    \n    \n    current supported material type: light, lambert, glossy reflection, specular glass\n    todo : add somthing like aspheric lens :)\n*/\n\nvec3 XYZ_to_RGB(vec3 x)\n{\n\tconst mat3 XYZ_to_RGB = (mat3(\n\t\t3.2404542,-1.5371385,-0.4985314,\n\t\t-0.9692660, 1.8760108, 0.0415560,\n\t\t0.0556434,-0.2040259, 1.0572252));\n\n\treturn x * XYZ_to_RGB;\n}\n\n\nvec3 linear_to_gamma_sRGB(vec3 x)\n{\n    return pow(x, vec3(0.45454545));\n    \n\treturn vec3(\n\t\tx.r > 0.0031308 ? 1.055 * pow(x.r, 1.0 / 2.4) - 0.055 : 12.92 * x.r,\n\t\tx.g > 0.0031308 ? 1.055 * pow(x.g, 1.0 / 2.4) - 0.055 : 12.92 * x.g,\n\t\tx.b > 0.0031308 ? 1.055 * pow(x.b, 1.0 / 2.4) - 0.055 : 12.92 * x.b);\n}\n\n\n// Approximate ACES tone mapper\n// https://www.google.co.kr/amp/s/knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/amp/\nvec3 ACESFilm(vec3 x)\n{\n    // return x;\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn (x*(a*x+b)) / (x*(c*x+d)+e);\n}\n\n#if 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n}\n\n\n#else\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n#ifdef RT2D_UNIDIRECTIONAL\n    vec4 radiance = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    fragColor = radiance.w == 0.0 ? vec4(0) : vec4(linear_to_gamma_sRGB(ACESFilm(XYZ_to_RGB(radiance.xyz / radiance.w))), 1.0);\n#else\n    vec4 flu = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    fragColor = flu.w == 0.0 ? vec4(0) : vec4(linear_to_gamma_sRGB(ACESFilm(XYZ_to_RGB(flu.xyz / flu.w))), 1.0);\n#endif\n\n    // Debug.  green boundary should be same at Uni & Light tracing\n    // if(abs(dot(fragColor.xyz,vec3(0.3333)) -0.9) < 0.01) fragColor = vec4(0,3,0,0);\n\n}\n\n\n#endif\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define M_PI 3.1415926535897932\n#define M_PI_2 1.5707963267948966\n#define M_1_PI 0.3183098861837067\n\n\n#define M_2PI 6.2831853071795864\n\n\n\n\n\nstruct Mat\n{\n\tint type;\n    int volume_flag_type;\n\tvec3 albedo;\n};\n\nstruct Circle\n{\n\tvec2 center;\n\tfloat radius;\n\tint mat_index;\n};\n\n\nstruct Box\n{\n\tvec2 center;\n\tvec2 radius;\n\tint mat_index;\n};\n\nstruct RNG\n{\n    uint seed;\n};\n\nstruct PathState\n{\n\tvec2 P;\n\tvec2 D;\n    vec2 N;\n    int flag;\n    int tmp;\n    vec4 wl;\n};\n\nstruct PathRadiance\n{\n\tvec4 throughput;\n#ifdef RT2D_UNIDIRECTIONAL\n\tvec4 radiance;\n#endif\n};\n\n\n\nconst int PRIMITIVE_NONE = 0;\nconst int PRIMITIVE_CIRCLE = 1;\nconst int PRIMITIVE_BOX = 2;\n\nconst int FLAG_BSDF_NONE = (1<<0);\nconst int FLAG_BSDF_REFLECT = (1<<1);\nconst int FLAG_BSDF_TRANSMIT = (1<<2);\n\nconst int FLAG_BSDF_DISPERSION = (1<<8);\nconst int FLAG_BSDF_FAIL = (1<<31);\n\nconst int FLAG_NONE = (1<<0);\nconst int FLAG_VOLUME = (1<<31);\nconst int FLAG_VOLUME_NO_SCATTERING = (1<<30);\n\nconst int FLAG_PATH_NONE = 0;\nconst int FLAG_PATH_DISPERSED = (1<<2);\n\n#define EMISSION 0\n#define DIFFUSE 1\n#define GLOSSY 2\n#define DIELECTRIC 3\n\n\n\n\n\n#if defined(RT2D_AOS_CONSTANT) \n//|| defined(RT2D_LIGHTTRACING) unstable on mac os\nconst \n#endif\nCircle circle[] = Circle[](\n\n#ifdef RT2D_UNIDIRECTIONAL\nCircle( vec2(-5, 0), .333, 5),\n#else\nCircle( vec2(99999, 0), .333, 5),\n#endif\n\nCircle( vec2(-5., 9.), 4., 1),\nCircle( vec2(0., -0.5), 2.333, 4),\nCircle( vec2(8., 8.), 3., 4)\n);\n\nconst Box box[] = Box[](\nBox( vec2(5., -15.), vec2(4., 0.1), 3),\nBox( vec2(-5., -15.), vec2(4., 0.1), 2),\nBox( vec2(-0., 18.), vec2(4., 1.), 4),\nBox( vec2(20., 4), vec2(2., 2.), 4)\n);\n\nconst Mat material[] = Mat[](\nMat( EMISSION, FLAG_NONE, 5.* vec3(0.3, 0.3,0.923)),\nMat( DIELECTRIC, FLAG_VOLUME, 0.05*vec3(1.,0.25,0.2)),\nMat( DIFFUSE, FLAG_NONE, vec3(1.0)),\nMat( GLOSSY, FLAG_NONE, vec3(1.)),\nMat( DIELECTRIC, FLAG_NONE, vec3(1.)),\nMat( EMISSION, FLAG_NONE, vec3(80)),\nMat( GLOSSY, FLAG_NONE, vec3(1.))\n);\n\n\n\n\n\n\n\n\n\n\n\n\n// Generaliazed golden ratio\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nfloat R1(float s, float n) {\n\tconst float a1 = 1.0 / 1.6180339887498948482;\n\n\treturn fract(s + a1 * n);\n}\n\nvec2 R2(vec2 s, float n) {\n\tconst float a1 = 1.0 / 1.32471795724474602596;\n\tconst float a2 = a1 * a1;\n\n\treturn fract(s + vec2(a1, a2) * n);\n}\n\nvec3 R3(vec3 s, float n) {\n\tconst float a1 = 1.0 / 1.22074408460575947536;\n\tconst float a2 = a1 * a1;\n    const float a3 = a2 * a1;\n    \n\treturn fract(s + vec3(a1, a2, a3) * n);\n}\n\n// avoid large value\nvec2 R2m(vec2 n) {\n\tconst float a1 = 1.0 / 1.32471795724474602596;\n\tconst float a2 = a1 * a1;\n\n\treturn fract(n + vec2(a1, a2));\n}\n\nvec3 R3m(vec3 n) {\n\tconst float a1 = 1.0 / 1.22074408460575947536;\n\tconst float a2 = a1 * a1;\n    const float a3 = a2 * a1;\n\n\treturn fract(n + vec3(a1, a2, a3));\n}\n\nfloat radicsalInverse_VdC(uint bits ) {\n  return float(reverse_bits(bits)) * 2.3283064365386963e-10;\n}\n\n\nfloat random(inout RNG rng) { // from https://www.shadertoy.com/view/llGSzw  Base: Hugo Elias. ToFloat: http://iquilezles.org/www/articles/sfrand/sfrand.htm\n\tuint seed = rng.seed;\n    seed = (seed >> 13U) ^ seed;\n    seed = seed * (seed * seed * 15731U + 789221U) + 1376312589U;\n    \n    rng.seed = seed;\n    return uintBitsToFloat( (seed>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Exact dielectric fresnel. \n// Andrew S. Glassner. 1995. \"Principles of Digital Image Synthesis\"\nfloat fresnel_dielectric(float n, float cosNV) {\n  float g = n*n + cosNV*cosNV - 1.0;\n  if (g <= 0.0) return 1.0;\n  g = sqrt(g);\n  float a = (g - cosNV) / (g + cosNV);\n  float b = ((g + cosNV) * cosNV - 1.0) / ((g - cosNV) * cosNV + 1.0);\n\n  return 0.5 * a*a * (1.0 + b*b);\n}\n\n\n\n\n\nvec2 sample_semicircle_cosine(float xi) {\n\tfloat cos_theta = 2.0 * xi - 1.0;\n\treturn vec2(cos_theta, safe_sqrt(1.0 - cos_theta*cos_theta));\n}\n\nvec2 sample_circle_uniform(float xi) {\n\tfloat phi = M_2PI * xi;\n\treturn vec2(cos(phi), sin(phi));\n}\n\n\n\nint bsdf_sample_lambert(vec4 albedo, vec2 N, vec2 V, float xi, out vec4 eval, out vec2 L) {\n    if (dot(N, V) < 1e-5) return FLAG_BSDF_FAIL;\n    \n\tvec2 local = sample_semicircle_cosine(xi);\n    vec2 X = vec2(N.y, -N.x);      \n\tL =  X * local.x + N * local.y;\n    \n    eval = albedo;\n\treturn FLAG_BSDF_REFLECT;\n}\n\nvec2 sample_beckmann( float alpha, vec2 N, vec2 V, float xi) {\n    bool si = xi < 0.5;\n    xi = abs(xi*2.0 - 1.0);\n\n    float tan_theta = -alpha * log(1.0 - xi);\n    float cos_theta = inversesqrt(1.0 + tan_theta*tan_theta);\n    float sin_theta = safe_sqrt(1.0 - cos_theta*cos_theta);\n    sin_theta *= (si) ? -1.0 : 1.0;\n\n    vec2 L = vec2(sin_theta, cos_theta);\n    vec2 X = vec2(N.y, -N.x);\n\n    return X * L.x + N * L.y;\n}\n\n// correct ???\nint bsdf_sample_glossy(vec4 albedo, float alpha, vec2 N, vec2 V, float xi, out vec4 eval, out vec2 L)\n{\n\talpha = alpha * alpha;\n    \n    if(alpha < 1e-4) {\n        L = reflect(-V, N);\n        eval = albedo;\n        return FLAG_BSDF_REFLECT;\n    }\n    \n\tvec2 H = sample_beckmann(alpha, N, V, xi);\n\tL = reflect(-V, H);\n\n\tfloat cosNH = dot(N, H);\n\tfloat cosVH = max(0., dot(V, H));\n\tfloat cosNL = dot(N, L);\n\tfloat cosNV = dot(N, V);\n\n\tfloat v = alpha * safe_sqrt(1.0 - cosNV * cosNV) / cosNV;\n\tfloat Gv = 1.0 /(1.0 + v*exp(-1./v));\n\tfloat l = alpha * safe_sqrt(1.0 - cosNL * cosNL) / cosNL;\n\tfloat Gl = 1.0 /(1.0 + l*exp(-1./l));\n\n\t// D = exp(-1/(a * tan)) / (2a*cos^3)\n\t// dm dm~ jacobian = 1/cos^2\n\t// p2 = D *cos^3\n\t// A = a*tan*exp(-1/(a*tan))\n\t// eval = cosNL * D F G *cosVH / (2 *cosNV *cosNL)\n\t// do dh jacobian = 1/2\n\t// pdf = D * cosNH / 2\n\n    eval = Gv * Gl/ cosNV *cosVH * cosNH * albedo;\n    return FLAG_BSDF_REFLECT;\n}\n\n\nvec3 bsdf_eval_dielectric(vec3 albedo, bool inside, vec2 N, vec2 V, vec2 L) {\n\tfloat ind = 1.5;\n\tfloat cosNV = dot(N, V);\n\tfloat ior = inside ? ind: 1./ind;\n\n\n\tvec2 Lv = refract( -V, N, ior );\n\tfloat si = dot(Lv, L) > 0.9999 ? 1. : 0.;\n\treturn si* albedo;\n}\n\nint bsdf_sample_dielectric(vec4 albedo, float wl, bool dispersed, vec2 N, vec2 V, float xi, out vec4 eval, out vec2 L)\n{\n    int label = FLAG_BSDF_REFLECT;\n\tfloat ior = iors(wl);\n\tfloat cosNV = dot(N, V);\n    float att = 1.0;\n    \n\tif (cosNV < 0.0) {\n        cosNV = -cosNV;\n        N = -N;\n        ior = 1.0/ior;\n    }\n    \n\tfloat F = fresnel_dielectric(ior, cosNV);\n    \n\tif(xi < F) {\n\t\tL = -V + 2.0 * cosNV * N;\n\t}\n    else {\n        L = refract(-V, N, 1.0/ior);\n#ifdef RT2D_UNIDIRECTIONAL\n// http://photorealizer.blogspot.com/2012/12/transmitted-radiance.html\n        att = 1.0/(ior);\n#endif        \n        label = FLAG_BSDF_TRANSMIT;\n\t}\n    \n    if (dispersed) {\n        eval = vec4(att, 0, 0, 0);\n    }\n    else {\n        eval = vec4(4.0*att, 0, 0, 0);\n        label |= FLAG_BSDF_DISPERSION;\n    }\n    \n    //eval = vec4(1);\n\treturn label;\n}\n\n\n\nbool interesction_scene_all( PathState ps, out float dist, out vec2 N, out int mat_index)\n{\n\tbool hit = false;\n    \n#ifdef RT2D_UNIDIRECTIONAL\n    float t0 = 9999.0;\n    int tmp = max(-iFrame, 0);\n#else\n   float t0 = 80.0; // to conserve ray-box precision at bufferB\n   int tmp = max(-iFrame, 1);\n#endif\n\t\n    mat_index = -1;\n    vec2 N0;\n    \n    \n    //ivec2 obj = ivec2(0);\n    //circle[1].radius+= float(iFrame)*1e-9;\n\n\tfor (int i = tmp; i < circle.length(); ++i) {\t\n        Circle cir = circle[i];\n\t\tvec2 f = ps.P - cir.center;\n        float b = dot(-f, ps.D);\n        vec2 k =  f + b * ps.D;\n        float k2 = dot(k, k);\n        float r2 = cir.radius * (cir.radius);\n        \n        if (r2 > k2) {\n            float q = b + sqrt(r2 - k2);\n            float f2 = dot(f, f);\n            float t = f2 < r2 ? q: (f2 - r2) / q;\n            if (t > 0.0 && t < t0) {\n                mat_index = cir.mat_index;\n                N0 = f + ps.D * t;\n                t0 = t;\n              //  obj = ivec2(PRIMITIVE_CIRCLE, i);\n            }\n        }\n\t}\n \n    // Majercik et al. 2018. \"A Ray-Box Intersection Algorithm and Efficient Dynamic Voxel Rendering\"\n\tfor (int i = max(-iFrame,0); i < box.length(); ++i) {\n        Box box = box[i];\n        vec2 origin = ps.P - box.center;\n\n        float winding = max2(abs(origin) / box.radius) < 1.0 ? -1.0 : 1.0;\n        vec2 sgn = -sign(ps.D);\n\n        vec2 d = (box.radius * winding * sgn - origin) / ps.D;\n\n        #define TEST(U, V) (d.U >= 0.0) && (abs(origin.V + ps.D.V * d.U) < box.radius.V ? true : false )\n        bvec2 test = bvec2(TEST(x, y), TEST(y, x));\n        sgn = test.x ? vec2(sgn.x,0.) : (test.y ? vec2(0.,sgn.y) : vec2(0., 0.));\n        #undef TEST\n\n        float t = (sgn.x !=0.0) ? d.x : (sgn.y !=0.0) ? d.y : -1.0;\n\n        if (t > 0.0 && t < t0) {\n            t0 = t;\n            N0 = sgn*winding;\n            mat_index = box.mat_index;\n           // obj = ivec2(PRIMITIVE_BOX, i);\n        }\n\t}\n    /*\n    for( int i = 0; i < 1; i++)\n\t{\n\n            if (t > 0. && t < t0) {\n                mat_index = cir.mat_index;\n                N = normalize(f + ps.D * t);\n                t0 = t;\n                obj = ivec2(PRIMITIVE_CIRCLE, i);\n            }\n        \n\t}\n    */\n\tdist = t0;\n    N = normalize(N0);\n    //obj_=obj;\n    \n\treturn (mat_index > -1);\n}\n\n\n/*\nvoid interesction_scene_volume(vec2 P, vec2 D)\n{\n\tfor (int i = 0; i < NUM_CIRCLE; ++i) {\n\t\tCircle cir = circle[i];\n        if(!bool(material[cir.mat_index].volume_flag_type & FLAG_VOLUME)) continue;\n        \n\t\tvec2 f = P - cir.center;\n\n        if (dot(f, f) < cir.radius*cir.radius) {\n            stack[stack_idx++] = ivec2(PRIMITIVE_CIRCLE, i);\n        }\n\t}\n    \n    for (int i = 0; i < NUM_BOX; ++i) {\n\t\tBox box = box[i];\n        if(!bool(material[box.mat_index].volume_flag_type & FLAG_VOLUME)) continue;\n        \n\t\tvec2 f = abs(P - box.center);\n\n        if (all(lessThan(f, box.radius))) {\n            stack[stack_idx++] = ivec2(PRIMITIVE_BOX, i);\n        }\n\t}\n    \n    for (int i = 1; i < stack_idx; ++i){}\n    \n\treturn ;\n}\n*/\n\n\n\nint sample_bsdf(\n    PathState ps,\n    inout PathRadiance pr,\n    inout RNG rng,\n    int mat_index,\n    int bounce,\n    \n\tout vec2 L)\n{\n    int label = FLAG_BSDF_FAIL;\n\tMat materials = material[mat_index];\n    vec4 albedo = rgb_to_spectral(materials.albedo, ps.wl);\n    \n    vec4 eval = vec4(1);\n#ifdef RT2D_UNIDIRECTIONAL\n    vec4 emission = vec4(0);\n#endif    \n    vec2 tL;\n    float xi = random(rng);\n    bool dispersed = bool(ps.flag & FLAG_PATH_DISPERSED);\n\n\tswitch( materials.type )\n\t{\n    \n\t\tcase DIFFUSE :\n\t\t{\n\t\t\tlabel = bsdf_sample_lambert(albedo, ps.N, -ps.D, xi, eval, tL);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GLOSSY :\n\t\t{\n\t\t\tlabel = bsdf_sample_glossy(albedo, 0.0, ps.N, -ps.D, xi, eval, tL);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase DIELECTRIC :\n\t\t{\n\t\t\tlabel = bsdf_sample_dielectric(albedo, ps.wl.x, dispersed, ps.N, -ps.D, xi, eval, tL);\n\t\t\tbreak;\n\t\t}\n#ifdef RT2D_UNIDIRECTIONAL\n\t\tcase EMISSION :\n\t\t{\n            // normalize\n\t\t\temission = dot(ps.N, -ps.D) > 0.0 ? albedo / (M_2PI*circle[0].radius) : emission;\n\t\t\tlabel = FLAG_BSDF_FAIL;\n\t\t\tbreak;\n\t\t}\n#endif\n        default :\n\t\t{\n\t\t\tlabel = FLAG_BSDF_FAIL;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n#ifdef RT2D_UNIDIRECTIONAL\n#ifdef NO_ZERO_BOUNCE_LIGHT   \n    if (bounce > 0)\n#endif\n    pr.radiance += pr.throughput * emission;\n#endif  \n    \n    pr.throughput *= eval;\n    L = tL;\n\n\treturn label;\n}\n\n\n\n\n\nfloat aspect;\n\n\n\n\nvec2 transform_screen_to_world(vec2 fragCoord)\n{\n    vec2 w = RT2D_VIEW_ZOOM * (fragCoord / iResolution.xy * 2.0 - 1.0);\n    w.x *= aspect;\n    \n    return w;\n}\n\nvec2 transform_world_to_screen(vec2 worldCoord)\n{\n    worldCoord.x /= aspect;\n    vec2 s = (worldCoord / RT2D_VIEW_ZOOM + 1.0) * 0.5 * iResolution.xy  ;\n\n    return s;\n}\n\n\n#ifdef RT2D_UNIDIRECTIONAL\n\n#ifndef RT2D_AOS_CONSTANT\nvoid init(vec2 lo)\n{\n    // ray generation for light tracing method is hardcoded. \n    // to automate ray generation, randomly select primitive which has EMISSION and sample from its outline.\n\tcircle[0].center = lo;//Circle( lo, .1333, 5); // light. \n\n}\n\n#endif\n\n\n\nvec4 trace(PathState ps, inout RNG rng)\n{\n\t\n    PathRadiance pr;\n\tpr.radiance = vec4(0.0);\n\tpr.throughput = vec4(1.0);\n    \n\n\tfor (int i = max(-iFrame,0); i < RT2D_BOUNCE_MAX; ++i) {\n        float dist;\n\t\tint mat_index = 0;\n        vec2 N;\n\t\tbool hit = interesction_scene_all( ps, dist, N, mat_index);\n        \n\t\tif (!hit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tps.N = N;\n        vec2 L;\n\t\tint label = sample_bsdf(ps, pr, rng, mat_index, i, L);\n\n\t\tif (bool(label & FLAG_BSDF_FAIL)) break;\n        \n        ps.flag |= bool(label & FLAG_BSDF_DISPERSION) ? FLAG_PATH_DISPERSED : 0;\n\t\tps.P = ps.P + ps.D * dist  + ps.N * (dot(ps.N, L) < 0.0 ? -1e-4 : 1e-4);\n        ps.D = normalize(L); // normalize to ensure th \n\t}\n\n\treturn pr.radiance;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec4 buffer = iFrame==0 || iMouse.z > 0.0 ? vec4(0) : texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    //buffer.w += 1.0;\n    \n    // Initate RNG seed of each pixel.\n    // unifom seed over all pixel gives also interesting pattern\n    \n    //float bn = texelFetch(iChannel3, ivec2(fragCoord.xy), 0).x;   // texture repeat not work?\n    float bn = texture(iChannel3, fragCoord.xy / iResolution.xy).x;\n\n    \n    aspect = iResolution.x / iResolution.y;\n    vec2 xi0 = R2(vec2(bn), float(iFrame));\n\n#ifndef RT2D_AOS_CONSTANT\n    init(transform_screen_to_world(iMouse.xy));\n#endif\n    \n\n    RNG rng;\n    /* Framebuffer is 16bit ;; */\n    //rng.seed = reverse_bits(uint(iFrame));//uint(bn*256.0 + float(iFrame)*25600.);\n    //if (iFrame==0)\n    uint seed = uint(bn*256.);//reverse_bits(uint(fragCoord.x + iResolution.x*fragCoord.y));\n    rng.seed = seed+uint(iFrame*256);\n    //else\n    //rng.seed = \tfloatBitsToUint(buffer.w);\n      \n    PathState ps;\n    ps.P = transform_screen_to_world(fragCoord.xy + xi0 - 0.5);\n    ps.flag = FLAG_PATH_NONE;\n\n    vec3 radiance = vec3(0);\n\n    for (int i = max(-iFrame,0); i < RT2D_RAY_PER_FRAME; ++i) {\n       \n        vec2 xi = shuffled_scrambled_sobol2(uint(i + iFrame*RT2D_RAY_PER_FRAME), seed);\n    \n        ps.D = sample_circle_uniform(xi.x);    \n        \n        // Wilkie et al. 2014. \"Hero Wavelength Spectral Sampling\"\n        ps.wl.x = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * xi.y;\n        ps.wl.y = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * fract(xi.y + 1.0 / 4.0);\n        ps.wl.z = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * fract(xi.y + 2.0 / 4.0);\n        ps.wl.w = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * fract(xi.y + 3.0 / 4.0);\n\n        vec4 radiance_i = trace(ps, rng);\n        \n        radiance += \n        radiance_i.x * xyz_1931(ps.wl.x) + \n        radiance_i.y * xyz_1931(ps.wl.y) +  \n        radiance_i.z * xyz_1931(ps.wl.z) + \n        radiance_i.w * xyz_1931(ps.wl.w);\n    }\n    radiance *= 1.0 / float(4*RT2D_RAY_PER_FRAME);\n\n    fragColor = vec4(radiance, uintBitsToFloat(rng.seed));\n}\n\n\n\n\n\n#else \n\n\nvec2 transform_world_to_screen_dir(vec2 worldDir)\n{\n    worldDir.x /= aspect;\n    vec2 s = 1.0/normalize(worldDir*iResolution.xy)  ;\n\n    return s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 global_dim = ivec2(iResolution);\n    ivec2 global_id = ivec2(fragCoord);\n    \n    ivec2 group_dim = global_dim / RT2D_WORK_DIM;\n    ivec2 group_id = global_id / RT2D_WORK_DIM;\n    int group_idx = group_id.x + group_id.y*group_dim.x;\n    \n    ivec2 work_id = global_id - group_id*RT2D_WORK_DIM;\n    int work_idx = work_id.x + work_id.y*RT2D_WORK_DIM;\n\n    if (group_idx > RT2D_RAY_PER_FRAME-1 || any(greaterThanEqual(group_id, group_dim)))  {\n        return;\n    }\n    \n    \n    RNG rng;\n    rng.seed = uint(group_idx+RT2D_RAY_PER_FRAME*iFrame);\n    \n    vec3 R3state = shuffled_scrambled_sobol3(rng.seed, uint(9999));\n \n    aspect = iResolution.x / iResolution.y;\n\n    vec2 light = transform_screen_to_world(iMouse.xy);\n  \n\n\n    PathState ps;\n#if RT2D_DELTA_POINTLIGHT \n    ps.P = light; \n    ps.D = sample_circle_uniform(R3state.x);\n#else\n    vec2 n = sample_circle_uniform(R3state.x);\n    ps.P = light + (1e-4 + circle[0].radius) * n; \n    ps.D = sample_semicircle_cosine(R3state.y);\n    float ct = ps.D.y;\n    ps.D = ps.D.x * vec2(n.y, -n.x) + ps.D.y * n; //\n#endif\n    ps.flag = FLAG_PATH_NONE;\n    \n    // Wilkie et al. 2014. \"Hero Wavelength Spectral Sampling\"\n    ps.wl.x = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * R3state.z;\n    ps.wl.y = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * fract(R3state.z + 1.0 / 4.0);\n    ps.wl.z = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * fract(R3state.z + 2.0 / 4.0);\n    ps.wl.w = RT2D_SPECTRUM_START + RT2D_SPECTRUM_INTERVAL * fract(R3state.z + 3.0 / 4.0);\n\n    vec3 kh = xyz_1931(ps.wl.x);\n    vec3 k1 = xyz_1931(ps.wl.y);\n    vec3 k2 = xyz_1931(ps.wl.z);\n    vec3 k3 = xyz_1931(ps.wl.w);\n\n\n    PathRadiance pr;\n    // pixel term(??) & normalize\n\tpr.throughput = \n        1.0/sqrt(2.0) * \n        0.5 * M_PI * M_2PI * \n        rgb_to_spectral(material[5].albedo, ps.wl);\n\n    // track double of real bounce count\n    bool is_odd_work = (work_idx % 2 == 0);\n    \n    int bounce = max(-iFrame,0);\n    \n    \n\tfor (; bounce < 2*RT2D_BOUNCE_MAX; ) {\n        \n        bounce+=2;\n        \n        float dist;\n        int mat_index = 0;\n        vec2 N;  \n\t\tbool hit = interesction_scene_all(ps, dist, N, mat_index);\n        \n        if (work_idx < bounce) {\n            vec2 a = transform_world_to_screen(ps.P);\n            vec2 b = -a + transform_world_to_screen(ps.P+ps.D* dist);\n            float le = length(b);\n            b = le/b;\n            // now b is inverse of ray direction\n            \n            // precompute part of ray slab test : a * b\n            fragColor = is_odd_work ? vec4(a * b, b) : vec4(0.25*(pr.throughput.x * kh + pr.throughput.y * k1 +  pr.throughput.z * k2 + pr.throughput.w * k3), le);\n            \n            break;\n        }\n        \n\t\tif (!hit) {\n\t\t\tbreak;\n\t\t}\n        \n\t\tps.N = N;\n        vec2 L;\n\t\tint label = sample_bsdf(ps, pr, rng, mat_index, bounce, L);\n\n\t\tif (bool(label & FLAG_BSDF_FAIL)) break;\n                     \n        ps.flag |= bool(label & FLAG_BSDF_DISPERSION) ? FLAG_PATH_DISPERSED : 0;\n\t\tps.P = ps.P + ps.D * dist  + ps.N * (dot(ps.N, L) < 0.0 ? -1e-4 : 1e-4);\n        ps.D = normalize(L); // normalize to ensure th \n\t}\n    \n    // Use 2 pixel for extra data\n    if (work_idx > RT2D_WORK_DIM*RT2D_WORK_DIM-3) { // maybe framebuffer isn't 32bit?\n        fragColor = is_odd_work ? vec4(bounce) : vec4(0);//uintBitsToFloat(rng.seed)\n    }\n}\n\n\n#endif\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Rendering mode.\n    \n    default : LIGHT TRACING\n        ray tracing from light source\n        impressive pattern but slower convergence\n    \n    uncomment : UNIDIRECTIONAL TRACING\n        ray tracing from each pixel(path tracing)\n        faster\n    \n*/\n//  #define RT2D_UNIDIRECTIONAL \n\n\n\n\n\n\n/*\n    Not draw directly visible light to clearly view secondary ray.\n*/\n// #define NO_ZERO_BOUNCE_LIGHT\n\n\n\n\n#ifdef RT2D_UNIDIRECTIONAL\n    /*\n        UNIDIRECTIONAL TRACING SETTING\n    */\n    \n    \n    #define RT2D_RAY_PER_FRAME 16\n\n    #define RT2D_BOUNCE_MAX 12\n\n\n\n    // Aessing non const array is critical to performance!!!!!!!!!!!!!!!!\n    // Undefine to move light source with mouse in RT2D_UNIDIRECTIONAL mod. \n    //#define RT2D_AOS_CONSTANT\n    \n#else\n\n    /*\n        LIGHT TRACING SETTING\n    */\n    #define RT2D_LIGHTTRACING\n\n    /* \n        Up to the viewport size and RT2D_WORK_DIM. \n        maximum : int(iResolution.x/RT2D_WORK_DIM) * int(iResolution.x/RT2D_WORK_DIM)\n        example : 800x450 size -> 100*56\n        \n        RTX3070 & 800x450 60fps at 2000 ray per frame (OpenGL)\n                  1600x900 12fps at 4096 ray per frame (OpenGL)\n                  \n        M1 Pro & 1600x900 9fps at 1024 4096 ray per frame (Metal)\n        \n        set value which saturates your gpu\n        \n        low RT2D_RAY_PER_FRAME like 1, 2 seems also interesting pattern :)\n    */\n    #define RT2D_RAY_PER_FRAME 128\n\n\n    // Up to RT2D_WORK_DIM. \n    // maximum = (RT2D_WORK_DIM*RT2D_WORK_DIM-2) / 2\n    #define RT2D_BOUNCE_MAX 12\n\n    \n    // Size of group(tile). set even value between 8, 16.\n    #define RT2D_WORK_DIM 8\n\n    /*\n        Set Light as point not circle(zero area)\n        not guarantee to converge same image as inital pdf is wrong?\n        but superior convergence rate.(lower the dimesion)\n        you can add laser type by slightly modify bifferA line 695~\n        \n        0 : area light(match with RT2D_UNIDIRECTIONALresult)\n        1 : detla light\n    */\n    #define RT2D_DELTA_POINTLIGHT 1\n\n    /*\n        One light sample(ray) uses an one group(tile). The group size is one of 8x8, 16x16, 32*32. \n        maximum light bounce count depand on tile size, each bounce consume 2 pixel, and defaultly 2pixel for extra data.\n\n        example RT2D_WORK_DIM(8) : 8x8 -> 64pixel -> (64-2) / 2 = 31 is maxinum bounce(RT2D_BOUNCE_MAX).\n\n        group_id []\n        work_idx : each group's scanline.\n        .\n        .\n        |  [0,1]  |  [1,1]  |  [2,1]\n        |         |         |\n        |_________|_________|________..\n        |54 ... 63|54 ... 63|...\n        |. .     .|. .     .|\n        |. [0,0] .|. [1,0] .|  [2,0]\n        |.     . .|.     . .|  \n        |0 1 ... 7|0 1 ... 7|  \n        |_____________________________..\n\n\n        work_idx usage:\n\n        0: vec4(vec2(startP), vec2(endP))\n        1: vec4(XYZWradiance)\n\n        2: vec4(vec2(startP), vec2(endP))\n        3: vec4(XYZWradiance)\n\n        ...\n\n        62: vec4(group data)\n        63: vec4(RNG state)\n    */\n#endif\n\n\n\n/*\n    scene scaling factor\n    maximun intersection distance is hardcoed at interesction_scene_all()\n*/\n#define RT2D_VIEW_ZOOM 20.0\n\n\n\n\n// const\n// wavelength 380nm - 780nm\n#define RT2D_SPECTRUM_START 380.0\n#define RT2D_SPECTRUM_INTERVAL 400.0\n\n\n// Index of Refraction depends on wavelength ogf light\n// float wl : wavelength in [nm]. \n// returns the index of refraction at given wavelength.\nfloat iors(float wl) {\n    \n    // No dispersion\n    //return 1.0;\n    \n    // Exaggerated profile\n    return 0.5 + exp(4e-4*(560.0-wl));\n    \n    \n    \n    // Some realistic profile from wikipedia\n    float w2 = wl*wl*1e-6;\n    vec3 B = vec3(1.5039759, 0.55069141, 6.5927379);\n    vec3 C = vec3(5.48041129e-3, 1.47994281e-2, 402.89514);\n    return sqrt(1.0 + w2*(B.x/(w2-C.x)+B.y/(w2-C.y)+B.z/(w2-C.z)));\n}\n\n\n\n\n\n// 81\n// http://www.cie.co.at/technical-work/technical-resources\nconst vec3 standardObserver1931[] =\nvec3[] (\nvec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\nvec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\nvec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\nvec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\nvec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\nvec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\nvec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\nvec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\nvec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\nvec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\nvec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\nvec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\nvec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\nvec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\nvec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\nvec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\nvec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\nvec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\nvec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\nvec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\nvec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\nvec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\nvec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\nvec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\nvec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\nvec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\nvec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\nvec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\nvec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\nvec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\nvec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\nvec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\nvec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\nvec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\nvec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\nvec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\nvec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\nvec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\nvec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\nvec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\nvec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\nvec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\nvec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\nvec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\nvec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\nvec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\nvec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\nvec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\nvec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\nvec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\nvec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\nvec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\nvec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\nvec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\nvec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\nvec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\nvec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\nvec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\nvec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\nvec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\nvec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\nvec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\nvec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\nvec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\nvec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\nvec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\nvec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\nvec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\nvec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\nvec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\nvec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\nvec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\nvec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\nvec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\nvec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\nvec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\nvec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\nvec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\nvec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\nvec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\nvec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\n\n// 97\nconst float cie_d65_300_5_780[] =\nfloat[] (\n0.0341,\n1.6643,\n3.2945,\n11.7652,\n20.236,\n28.6447,\n37.0535,\n38.5011,\n39.9488,\n42.4302,\n44.9117,\n45.775,\n46.6383,\n49.3637,\n52.0891,\n51.0323,\n49.9755,\n52.3118,\n54.6482,\n68.7015,\n82.7549,\n87.1204,\n91.486,\n92.4589,\n93.4318,\n90.057,\n86.6823,\n95.7736,\n104.865,\n110.936,\n117.008,\n117.41,\n117.812,\n116.336,\n114.861,\n115.392,\n115.923,\n112.367,\n108.811,\n109.082,\n109.354,\n108.578,\n107.802,\n106.296,\n104.79,\n106.239,\n107.689,\n106.047,\n104.405,\n104.225,\n104.046,\n102.023,\n100.0,\n98.1671,\n96.3342,\n96.0611,\n95.788,\n92.2368,\n88.6856,\n89.3459,\n90.0062,\n89.8026,\n89.5991,\n88.6489,\n87.6987,\n85.4936,\n83.2886,\n83.4939,\n83.6992,\n81.863,\n80.0268,\n80.1207,\n80.2146,\n81.2462,\n82.2778,\n80.281,\n78.2842,\n74.0027,\n69.7213,\n70.6652,\n71.6091,\n72.979,\n74.349,\n67.9765,\n61.604,\n65.7448,\n69.8856,\n72.4863,\n75.087,\n69.3398,\n63.5927,\n55.0054,\n46.4182,\n56.6118,\n66.8054,\n65.0941,\n63.3828\n);\n\n\n// Mallett and Yuksel. 2019. \"Spectral Primary Decomposition for Rendering with sRGB Reflectance\"\n// https://github.com/geometrian/simple-spectral/blob/master/data/cie1931-basis-bt709-380%2B5%2B780.csv\n// 81\nconst vec3[] cie1931_basis_bt709_380_780 = \nvec3[](\nvec3(0.327457413827055,0.331861713085874,0.340680791548052),\nvec3(0.323750578270541,0.329688187759399,0.346561186624852),\nvec3(0.313439461251577,0.327860021624697,0.358700493140351),\nvec3(0.288879382755265,0.319173580231756,0.391947026588195),\nvec3(0.239205681158886,0.294322583694842,0.466471730587333),\nvec3(0.189702036890535,0.258697064768736,0.551600895598602),\nvec3(0.121746067959218,0.188894319254765,0.689359610948928),\nvec3(0.074578270669466,0.125388381991689,0.800033346878607),\nvec3(0.0444331586340337,0.0786870603106217,0.876879780935314),\nvec3(0.0289286321285029,0.0531432708659453,0.917928097443955),\nvec3(0.0223166534847512,0.0422881460313421,0.935395200669632),\nvec3(0.0169113072926318,0.0333183455029171,0.949770347115183),\nvec3(0.0141811071179667,0.0297559481859724,0.95606294480524),\nvec3(0.0130531426774873,0.0303312505369047,0.956615606890316),\nvec3(0.011986163627845,0.0309885718973007,0.957025264931328),\nvec3(0.0112887147124048,0.0316863551888381,0.957024930534713),\nvec3(0.0109060664656517,0.0346699615029974,0.954423972737066),\nvec3(0.0104007134810042,0.034551957443675,0.955047329020204),\nvec3(0.0106373602541465,0.0406848061948297,0.948677833093334),\nvec3(0.0109076625337741,0.0544600373694056,0.934632299842328),\nvec3(0.0110327124480988,0.0809052874204737,0.908061999852269),\nvec3(0.0113106565912268,0.146348302857044,0.842341039463727),\nvec3(0.0111546420569403,0.379679643296617,0.609165715365647),\nvec3(0.0101487704062122,0.766744268654033,0.223106960959533),\nvec3(0.00891858211883843,0.87621474761337,0.114866670291336),\nvec3(0.00768557633847106,0.918491655613843,0.0738227678957437),\nvec3(0.00670570828469526,0.940655562534437,0.0526387287910555),\nvec3(0.00599580598764424,0.95373188453302,0.0402723090168887),\nvec3(0.00553725664234189,0.961643279840238,0.0328194626509591),\nvec3(0.00519378424120663,0.967200019685078,0.0276061959270456),\nvec3(0.00502536226522334,0.970989746390046,0.0239848911270394),\nvec3(0.00513636276967508,0.972852303563554,0.0220113333527922),\nvec3(0.00543320026053983,0.973116594076444,0.0214502052559966),\nvec3(0.00581998590243535,0.973351069154143,0.0208289445095685),\nvec3(0.00640057277462412,0.973351115544369,0.0202483113888087),\nvec3(0.00744952868340878,0.972261079731725,0.0202893914512066),\nvec3(0.00858363581937657,0.973351021746917,0.018065342335913),\nvec3(0.0103957624651674,0.973148495185693,0.0164557422344685),\nvec3(0.0135654335386492,0.971061306300914,0.0153732601340955),\nvec3(0.0193845158399742,0.966371305955183,0.0142441784845517),\nvec3(0.0320840712020024,0.954941967502548,0.0129739615543347),\nvec3(0.0743560378459411,0.913578989551261,0.0120649741345218),\nvec3(0.624393724178075,0.364348803907687,0.0112574781603901),\nvec3(0.91831003276872,0.0715072425408851,0.0101827246716942),\nvec3(0.949253030175051,0.0412304344713751,0.00951653538723741),\nvec3(0.958187833329246,0.0324238741836685,0.00938829272866817),\nvec3(0.958187751332698,0.0319246297982003,0.00988761909067028),\nvec3(0.958187625087782,0.0312760331730969,0.0105363420064589),\nvec3(0.955679060771746,0.0326303704290574,0.0116905688374448),\nvec3(0.958006154893429,0.0295308721490739,0.0124629728871037),\nvec3(0.954101573456564,0.0315617611702464,0.0143366651774203),\nvec3(0.947607606237237,0.0356742182708204,0.0167181753275443),\nvec3(0.938681328447549,0.0414030053955673,0.0199156660750025),\nvec3(0.924466682751434,0.0506042604489561,0.024929056163281),\nvec3(0.904606025333056,0.0634343003817003,0.0319596735860402),\nvec3(0.880412198927933,0.0789182452939229,0.0406695540952484),\nvec3(0.8477878731517,0.0995427426653747,0.0526693824219396),\nvec3(0.805779126623019,0.125595760093287,0.0686251105141947),\nvec3(0.752531853871421,0.15759091044168,0.0898772323000136),\nvec3(0.686439396844578,0.19539823904421,0.118162358926434),\nvec3(0.61869457086061,0.231474474772178,0.149830947442133),\nvec3(0.540264443959111,0.268852136095262,0.190883409341834),\nvec3(0.472964416293838,0.296029164217928,0.231006403025217),\nvec3(0.432701596704049,0.309754994441945,0.257543385422202),\nvec3(0.405358045528392,0.317815883383822,0.276826038721536),\nvec3(0.385491834974902,0.322990347389898,0.291517772810795),\nvec3(0.370983584551061,0.326353847938009,0.302662506083233),\nvec3(0.357608701523081,0.32914390227898,0.313247301302886),\nvec3(0.348712800108393,0.330808726803682,0.320478325124633),\nvec3(0.344880119344691,0.331482689922243,0.323636994707961),\nvec3(0.341917877323291,0.331984550352389,0.3260973088469),\nvec3(0.339531092987129,0.332341172522545,0.328127369340184),\nvec3(0.337169503774367,0.332912009415539,0.329917975958888),\nvec3(0.336172018527717,0.332919279695214,0.330907901216649),\nvec3(0.335167443433363,0.333027672578856,0.331803633095995),\nvec3(0.334421625306463,0.33317970467326,0.332396627255361),\nvec3(0.334008760376402,0.333247030974549,0.332740780726824),\nvec3(0.333915792790082,0.333259349210601,0.332820857081489),\nvec3(0.333818454946367,0.333275050279383,0.332901731283444),\nvec3(0.333672774928456,0.333294328448732,0.333025967488632),\nvec3(0.333569513405591,0.333309424957775,0.333111083081497)\n);\n\n\nconst uint sobol_directions_64[] = uint[](\n0x80000000u, 0x40000000u, 0x20000000u, 0x10000000u,\n0x08000000u, 0x04000000u, 0x02000000u, 0x01000000u,\n0x00800000u, 0x00400000u, 0x00200000u, 0x00100000u,\n0x00080000u, 0x00040000u, 0x00020000u, 0x00010000u,\n0x00008000u, 0x00004000u, 0x00002000u, 0x00001000u,\n0x00000800u, 0x00000400u, 0x00000200u, 0x00000100u,\n0x00000080u, 0x00000040u, 0x00000020u, 0x00000010u,\n0x00000008u, 0x00000004u, 0x00000002u, 0x00000001u,\n\n0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu,\n\n0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\n\n);\n\n\n\n\n\nfloat square(float x) { return x*x; }\nvec3 square(vec3 x) { return x*x; }\n\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0.0), vec3(1.0) ); }\nvec4 saturate(vec4 x) { return clamp(x, vec4(0.0), vec4(1.0) ); }\n\nfloat safe_sqrt( float x ) { return x > 0.0 ? sqrt(x) : 0.0; }\n\nfloat max2(vec2 x) { return max(x.x, x.y); }\n\n\n\n// Wyman et al. 2013. \"Simple Analytic Approximations to the CIE XYZ Color Matching Functions\"\nfloat xFit_1931(float wave) {\n\tfloat t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374);\n\tfloat t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323);\n\tfloat t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n\treturn 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5f*t2*t2) - 0.065*exp(-0.5*t3*t3);\n}\n\nfloat yFit_1931(float wave) {\n\tfloat t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247);\n\tfloat t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n\treturn 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\n\nfloat zFit_1931(float wave) {\n\tfloat t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278);\n\tfloat t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n\treturn 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\nvec3 xyz_1931(float wave) {\n\treturn vec3(xFit_1931(wave), yFit_1931(wave), zFit_1931(wave));\n}\n\nvec3 xyz_1931_quantized(float wavelength) {\n    float fIndex = ((wavelength - 380.0) / 400.0) * 80.0;\n    float fFloorIndex = floor(fIndex);\n    float fBlend = saturate(fIndex - fFloorIndex);\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = min(iIndex0 + 1, 80);\n\n    return mix(standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend);\n}\n\nfloat d65_spectrum(float wavelength) {\n    float fIndex = ((wavelength - 380.0) / 480.0) * 96.0;\n    float fFloorIndex = floor(fIndex);\n    float fBlend = saturate(fIndex - fFloorIndex);\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = min(iIndex0 + 1, 96);\n\n    return mix(cie_d65_300_5_780[iIndex0], cie_d65_300_5_780[iIndex1], fBlend);\n}\n\n// Mallett and Yuksel. 2019. \"Spectral Primary Decomposition for Rendering with sRGB Reflectance\"\nvec4 rgb_to_spectral(vec3 rgb, vec4 wl) {\n    ivec4 wli = ivec4(80.0 * saturate((wl - 380.0) / 400.0));\n    \n    return vec4(\n    dot(rgb, cie1931_basis_bt709_380_780[wli.x]),\n    dot(rgb, cie1931_basis_bt709_380_780[wli.y]),\n    dot(rgb, cie1931_basis_bt709_380_780[wli.z]),\n    dot(rgb, cie1931_basis_bt709_380_780[wli.w]));\n}\n\n\nuint reverse_bits(uint x) {\n  x = (((x & 0xaaaaaaaau) >> 1u) | ((x & 0x55555555u) << 1u));\n  x = (((x & 0xccccccccu) >> 2u) | ((x & 0x33333333u) << 2u));\n  x = (((x & 0xf0f0f0f0u) >> 4u) | ((x & 0x0f0f0f0fu) << 4u));\n  x = (((x & 0xff00ff00u) >> 8u) | ((x & 0x00ff00ffu) << 8u));\n  return ((x >> 16u) | (x << 16u));\n}\n\nuint sobol(uint index, uint dim) {\n    uint X = 0u;\n    for (uint bit = 0u; bit < 32u; ++bit) {\n      uint mask = (index >> bit) & 1u;\n      X ^= mask * sobol_directions_64[dim*32u + bit];\n    }\n    return X;\n}\n\nuvec2 sobol2(uint index, uvec2 dim) {\n    uvec2 X = uvec2(0u);\n    dim *= 32u;\n    for (uint bit = 0u; bit < 32u; ++bit) {\n      uint mask = (index >> bit) & 1u;\n      X.x ^= mask * sobol_directions_64[dim.x + bit];\n      X.y ^= mask * sobol_directions_64[dim.y + bit];   \n    }\n    \n    return X;\n}\n\nuvec3 sobol3(uint index, uvec3 dim) {\n    uvec3 X = uvec3(0u);\n    dim *= 32u;\n    for (uint bit = 0u; bit < 32u; ++bit) {\n      uint mask = (index >> bit) & 1u;\n      X.x ^= mask * sobol_directions_64[dim.x + bit];\n      X.y ^= mask * sobol_directions_64[dim.y + bit];\n      X.z ^= mask * sobol_directions_64[dim.z + bit];     \n    }\n    \n    return X;\n}\n\n\nuvec2 sobol2(uint i) {\n  return uvec2(sobol(i, 0u), sobol(i, 1u));\n}\n\nvec2 sobol2f(uint i) {\n  return vec2(sobol2(i, uvec2(0u, 1u))) * (1.0/float(0xffffffffu));\n}\n\nvec3 sobol3f(uint i) {\n  return vec3(sobol3(i, uvec3(0u, 1u, 2u))) * (1.0/float(0xffffffffu));\n}\n\n// https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\nuint laine_karras_permutation(uint x, uint seed) {\n#if 1\n    x ^= x * 0x3d20adeau;\n    x += seed;\n    x *= (seed >> 16u) | 1u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n#else\n    x += seed;\n    x ^= x * 0x6c50b47cu;\n    x ^= x * 0xb82f1e52u;\n    x ^= x * 0xc7afe638u;\n    x ^= x * 0x8d22f6e6u;\n#endif\nreturn x;\n}\n\nuint hash_combine(uint seed, uint v) {\n  return seed ^ (v + (seed << 6u) + (seed >> 2u));\n}\n\nuint nested_uniform_scramble(uint x, uint seed) {\n\tx = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    return x;\n}\n\n// Brent Burley. 2020. \"Practical Hash-based Owen Scrambling\"\nvec2 shuffled_scrambled_sobol2(uint index, uint seed) {\n\n\tindex = nested_uniform_scramble(index, seed);\n\tuvec2 X = sobol2(index, uvec2(0u, 1u));\n\n\tX.x = nested_uniform_scramble(X.x, hash_combine(seed, 0u));\n\tX.y = nested_uniform_scramble(X.y, hash_combine(seed, 1u));\n    \n\treturn vec2(X) * (1.0 / float(0xffffffffu));\n}\n\nvec3 shuffled_scrambled_sobol3(uint index, uint seed) {\n\n\tindex = nested_uniform_scramble(index, seed);\n\tuvec3 X = sobol3(index, uvec3(0u, 1u, 2u));\n\n\tX.x = nested_uniform_scramble(X.x, hash_combine(seed, 0u));\n\tX.y = nested_uniform_scramble(X.y, hash_combine(seed, 1u));\n    X.z = nested_uniform_scramble(X.z, hash_combine(seed, 2u));\n\n\treturn vec3(X) * (1.0 / float(0xffffffffu));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#ifdef RT2D_UNIDIRECTIONAL\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer = iFrame==0 || iMouse.z > 0.0 ? vec4(0) : texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    vec4 radiance = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    buffer.w += 1.0; // total number of ganerated ray \n    fragColor = vec4(buffer.xyz + radiance.xyz, buffer.w);\n    \n    //return;\n    //vec4 radiance = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    //fragColor = vec4(((XYZ_to_RGB(radiance.xyz / float(iFrame+1)))), 1.0);\n    //if(abs(dot(fragColor.xyz,vec3(0.3333)) -0.9) < 0.01) fragColor = vec4(0,3,0,0);\n}\n\n\n#else\n\n\nfloat max3(float x, float y, float z)\n{\n    return max(max(x, y), z);\n}\n\nivec2 calc(int bounce)\n{\n    int a = bounce / RT2D_WORK_DIM;\n    return ivec2(bounce - a*RT2D_WORK_DIM, a);\n}\n\n// Gather rays generated from bufferA.\n// All pixels fetch same ray data\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 global_id = ivec2(fragCoord);\n     \n    ivec2 group_dim = ivec2(iResolution) / RT2D_WORK_DIM;\n    \n    \n#ifdef NO_ZERO_BOUNCE_LIGHT\n    int tmp = 2;//max(-iFrame, 2);\n#else\n    int tmp = 0;//max(-iFrame, 0);\n#endif\n    vec4 buffer = iFrame==0 || iMouse.z > 0.0 ? vec4(0) : texelFetch(iChannel1, global_id, 0);\n    vec2 fragbox_min = floor(fragCoord);\n\n    for (int group_idx = max(-iFrame, 0); group_idx < RT2D_RAY_PER_FRAME; ++group_idx) {\n        \n        ivec2 group_global_id;\n        group_global_id.y = group_idx / group_dim.x;\n        group_global_id.x = group_idx - group_global_id.y * group_dim.x;\n        // group_global_id = group_id * RT2D_WORK_DIM\n        group_global_id *= RT2D_WORK_DIM;\n        \n        float data = texelFetch(iChannel0, group_global_id + ivec2(RT2D_WORK_DIM-2, RT2D_WORK_DIM-1), 0).x;\n        \n \n        for (int bounce = tmp; bounce < int(data); bounce+=2) {\n                  \n            vec4 a = texelFetch(iChannel0, group_global_id + calc(bounce), 0);\n            \n            // ray - slab test.\n            // box_min = fragbox_min\n            // box_max = fragbox_min + vec2(1)\n            vec2 t0 = fragbox_min.xy * a.zw - a.xy;// no fma() ;_ _;\n            vec2 t1 = t0 + a.zw;\n\n            float tnear = max3(0.0, min(t0.x, t1.x), min(t0.y, t1.y));\n            float tfar = min(max(t0.x, t1.x), max(t0.y, t1.y));\n\n            if (tnear <= tfar) {\n                vec4 b = texelFetch(iChannel0, group_global_id + calc(bounce+1), 0);\n                if (tnear < b.w) {\n                    buffer.xyz += b.xyz*(min(b.w, tfar)-tnear);\n                }\n            }\n        }\n    }\n    \n    buffer.w += float(RT2D_RAY_PER_FRAME); // total number of ganerated ray \n    fragColor = buffer;\n}\n\n#endif","name":"Buffer B","description":"","type":"buffer"}]}