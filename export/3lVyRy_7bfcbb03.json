{"ver":"0.1","info":{"id":"3lVyRy","date":"1611268787","viewed":144,"name":"Icosahedron wrap","username":"kastorp","description":"there should be a more elegant way","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["icosahedron","wrap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------\n// ICOSAHEDRON WRAP by Kastorp\n//--------------------------------------\n\n#define TK .02\n\n\n//SDF functions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) ;\n}\n\n#define dot2(x) dot(x,x)\nfloat udTri(  vec3 a, vec3 b, vec3 c,vec3 p )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec4 mmin(vec4 a, float b ,vec3 c){return a.x<b?a:vec4(b,c);}\n\n//fetch vertex position from Buffer A\n#define ds(i,k) texelFetch(iChannel0,ivec2(k,i),0).xyz\nvec4  mapScene( vec3 p )\n{\n   vec4 m =vec4(1000.,0,0,0);\n    \n    for(int i = 0;i<=4;i++) for(int j0=0;j0<=2;j0++) \n    {\n    \n       int j= j0 <2?j0:-1, k =i*3+j+1;\n     \n       vec3 d0=ds(0,k),d1=ds(1,k),d2=ds(2,k),d3=ds(3,k);\n\n       m=mmin(m,sdCapsule(p,j<0? d1: d0,d1)-TK,vec3(1.,0,0));   \n       m=mmin(m,sdCapsule(p,j<0  || (j==0 && i==4 ) ? d1: d0,j<0 || (j==0 && i==4 )?d3:d2)-TK,vec3(0,0,1.));      \n       m=mmin(m,sdCapsule(p, d1,d2)-TK,vec3(0,1.,0));\n\n       if(j>=0) m=mmin(m ,udTri(d0,d1,d2,p)-TK/2.,vec3(1.));\n       if(j<=0) m=mmin(m,udTri(d3,d1,d2,p)-TK/2.,vec3(1.));\n    }\n    return m;\n}\n\nint gFrame=0; \nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    for(int i=gFrame;i<=2;i++){\n        vec3 e=  0.001* ((i==0)?vec3(1,0,0):(i==1)?vec3(0,1,0):vec3(0,0,1));\n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapScene(p + j* e).x ;\n    }\n    return normalize(n);\n \n}\n\nvec3 rot(vec3 p,float tt)\n{\n \n    float c1 = cos(tt), s1 = sin(tt);\n    float c2 = c1, s2 = s1;\n    p.xz *= mat2(c1, s1, -s1, c1);\n    p.yz *= mat2(c2, s2, -s2, c2);\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(.5, .5, .5, 1.0);\n    gFrame=min(iFrame,0);\n\n    vec3 ro = rot(vec3(0.0, 0.3, 4.5),iTime/3.);\n    vec3 rd = normalize(  rot(vec3(uv, -1.2),iTime/3.));\n  \n\n    \n    float t = 0.0;\n    for (float iters=0.0; iters < 40.0; iters++) {\n        vec3 p = ro + rd * t;\n      \n        vec4 m = mapScene(p);\n        if (m.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n\n            fragColor.rgb +=m.yzw;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += m.x;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n//--------------------------------------\n// ICOSAHEDRON Wrap\n//\n// object is divided in 15 quads, each composed of 4 vertexes and 2 triangles\n// quads are aligned into a stripe of 5 x 3 (where lateral quads only have one triangle)\n// quads on central stripe are evaluated from 0 to 4 \n// lateral quads are evaluated after relative central quad\n//--------------------------------------\nvoid mainImage(out vec4 Q, in vec2 U) {\n    ivec2 uv = ivec2(U);\n    if(uv.x>14 || uv.y>4 ) discard;\n    \n    vec3 ds[60];\n    float rot=sin(iTime)*.727;\n \n     const mat3 t =mat3(0,.866,0,1.,.5,0,0,0,1) *1.;\n    vec3 orig= vec3(0.,0,-sin(rot)*2.);\n\n    for(int i = 0;i<=4;i++) for(int j0=0;j0<=2;j0++) \n    {\n     \n       int j= j0 <2?j0:-1, k =i*3+j+1;\n \n       if(j==0){//if  from below (ds1,ds3)\n            ds[k*4]= i==0 ? orig: ds[1+(k-3)*4];\n            ds[k*4+2]= i==0 ? orig+vec3(0.,1.,0.)*t: ds[(k-3)*4+3];\n            ds[k*4+1]= i==0 ? orig+vec3(1.,0.,0.)*t: ds[k*4] + erot(ds[2+(k-3)*4]-ds[k*4],  normalize(ds[2+k*4]-ds[k*4]),  3.14 +rot);            \n            ds[k*4+3] = ds[2+k*4] + erot(ds[k*4]-ds[2+k*4],  normalize(ds[1+k*4]-ds[2+k*4]),  3.14 -rot);\n        }\n        else if (j==1)// from left (ds2,ds3)\n        {\n            ds[k*4]= ds[2+(k-1)*4]; \n            ds[1+k*4]= ds[3+(k-1)*4];            \n            ds[2+k*4]= ds[k*4]  + erot(ds[1+(k-1)*4]-ds[k*4],  normalize(ds[1+k*4]-ds[k*4]),  3.14 -rot);    \n        }\n        else // from right (ds0,ds1)\n        {\n            ds[2+k*4]=ds[(k+1)*4] ; \n            ds[3+k*4]=ds[1+(k+1)*4] ;\n            ds[1+k*4]=ds[2+ k*4] + erot(ds[2+ (k+1)*4]-ds[2+k*4],  normalize(ds[3+k*4]-ds[2+k*4]),  3.14 +rot);         \n        }\n    }\n     Q.xyz= ds[uv.x*4+uv.y];\n           \n\n}","name":"Buffer A","description":"","type":"buffer"}]}