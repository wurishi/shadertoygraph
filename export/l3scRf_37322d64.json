{"ver":"0.1","info":{"id":"l3scRf","date":"1726520337","viewed":24,"name":"Smoothing Forms + Texture","username":"Kabanya","description":"2nd MIPT hw","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hwmipt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int   maxSteps = 70;\nconst float eps      = 0.01;\nconst float maxDist = 15.0;\nconst vec3  wLightDir = normalize(vec3(-1, -1, -1));\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 translate(vec3 offs){\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(offs.x, offs.y, offs.z, 1)\n        );\n}\n\nvec3 transformPoint(in mat4 m, in vec3 v) {\n    return (m * vec4(v, 1)).xyz;\n}\n\nvec3 transformVector(in mat4 m, in vec3 v) {\n    return (m * vec4(v, 0)).xyz;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat dTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdfPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nvec2 sdf(in vec3 p) { \n    float cylinderSdf = sdRoundedCylinder(p, 0.5, 0.2, 0.8);\n    float moveSpeed = sin(iTime * 1.5) * 2.4;\n    vec3 spherePosition = vec3(0.0, moveSpeed, 0.0);\n    float sphereSdf = dSphere(p - spherePosition, 0.6);\n    float orbitRadius = 2.0;\n    float orbitSpeed = iTime;\n    vec3 torusPosition = vec3(orbitRadius * cos(orbitSpeed), 0.0, orbitRadius * sin(orbitSpeed));\n    float torusSdf = dTorus(p - torusPosition, vec2(0.6, 0.15));\n    float ballSpeed = iTime;\n    float ballHeight = sin(ballSpeed) * 1.5; \n    vec3 ballPosition = torusPosition + vec3(0.0, ballHeight, 0.0);\n    float ballSdf = dSphere(p - ballPosition, 0.2);\n    vec4 planeNormal = vec4(0.0, .34, 0.0, 1.0);\n    float planeSdf = sdfPlane(p, planeNormal);\n    float smoothFactor = 1.0;\n    float blendedSdf = smin(cylinderSdf, sphereSdf, smoothFactor);\n\n    if (blendedSdf < min(planeSdf, min(torusSdf, ballSdf))) {\n        return vec2(blendedSdf, cylinderSdf < sphereSdf ? 1.0 : 2.0); // Changed 4.0 to 2.0 for sphere\n    }\n    return planeSdf < min(torusSdf, ballSdf) ? vec2(planeSdf, 3.0) \n           : (torusSdf < ballSdf ? vec2(torusSdf, 4.0) : vec2(ballSdf, 5.0));\n}\n\nvec3 trace(in vec3 from, in vec3 dir, out bool hit, out float id) {\n    vec3 p = from;\n    float totalDist = 0.0;\n    id = -1.0;\n    hit = false;\n\n    for (int steps = 0; steps < maxSteps; steps++) {\n        vec2 distAndID = sdf(p);\n        float dist = abs(distAndID.x);\n        \n        if (dist < eps) {\n            hit = true;\n            id = distAndID.y; \n            break;\n        }\n        \n        totalDist += dist;\n        if (totalDist > maxDist) {\n            break;\n        }\n        p += dist * dir; \n    }\n    return p;\n}\n\nvec3 generateNormal(vec3 z) {\n    float e = max(0.01, eps);\n    float dx1 = sdf(z + vec3(e, 0, 0)).x;\n    float dx2 = sdf(z - vec3(e, 0, 0)).x;\n    float dy1 = sdf(z + vec3(0, e, 0)).x;\n    float dy2 = sdf(z - vec3(0, e, 0)).x;\n    float dz1 = sdf(z + vec3(0, 0, e)).x;\n    float dz2 = sdf(z - vec3(0, 0, e)).x;\n\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool hit;\n    float id;\n    vec3 cEye = vec3(0, 0, 10);\n    vec3 mouse = vec3(iMouse.xy / iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat4 camToWorld = \n        translate(vec3(0, 0, 0))\n        * rotateY(6.0 * mouse.x)\n        * rotateX(6.0 * -mouse.y)\n        * translate(vec3(0, 0, -1));\n    mat4 worldToCam       = inverse(camToWorld);\n    mat4 normalCamToWorld = transpose(worldToCam);\n    mat4 normalWorldToCam = transpose(normalCamToWorld);\n    \n    vec2 scale = 9.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec3 cPixel = vec3(scale * (fragCoord / iResolution.xy - vec2(0.5)), 1); \n    vec3 wDir = normalize(transformVector(normalCamToWorld, normalize(cPixel - cEye)));\n    vec3 wEye = transformPoint(camToWorld, cEye);\n    vec3 wSurf = trace(wEye, wDir, hit, id); \n\n    vec3 color = texture(iChannel0, wDir).rgb;\n\n    if (hit) {\n        vec3 wNorm = generateNormal(wSurf);\n        vec3 wViewDir = normalize(wEye - wSurf);\n        vec3 wLightDir = normalize(vec3(1.0, 1.0, -1.0));\n        \n        vec3 objColor;\n        if (id == 1.0) { \n            vec3 w = abs(wNorm);\n            w /= (w.x + w.y + w.z);\n            objColor = w.x * texture(iChannel1, wSurf.yz).rgb \n                     + w.y * texture(iChannel1, wSurf.xz).rgb\n                     + w.z * texture(iChannel1, wSurf.xy).rgb;\n        } else if (id == 2.0) { \n            vec3 w = abs(wNorm);\n            w /= (w.x + w.y + w.z);\n            objColor = w.x * texture(iChannel1, wSurf.yz).rgb \n                     + w.y * texture(iChannel1, wSurf.xz).rgb\n                     + w.z * texture(iChannel1, wSurf.xy).rgb;\n            \n            objColor = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0),\n                           wSurf.y * 0.5 + 0.5) * (1.0 - (wSurf.y * 0.5 + 0.5) * (wSurf.y * 0.5 + 0.5));\n        } else if (id == 4.0) { \n            objColor = vec3(0.0, 0.5, 1.0); \n        } else if (id == 5.0) { \n            objColor = vec3(0.8, 0.4, 0.0); \n        } else {\n            vec2 uv = wSurf.xz * 0.5 + 0.5;  \n            objColor = texture(iChannel2, uv).rgb;\n        }\n\n        float ambientStrength = 0.1;\n        vec3 ambient = ambientStrength * objColor;\n        float diffuseStrength = 0.8;\n        vec3 diffuse = diffuseStrength * objColor * max(dot(wNorm, wLightDir), 0.0);\n        float specularStrength = 0.5;\n        float specularShine = 32.0;\n        vec3 reflectDir = reflect(-wLightDir, wNorm); \n        float spec = pow(max(dot(wViewDir, reflectDir), 0.0), specularShine);\n        vec3 specular = specularStrength * spec * vec3(1.0, 1.0, 1.0); \n        color = ambient + diffuse + specular;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}