{"ver":"0.1","info":{"id":"4cXXW2","date":"1705702066","viewed":45,"name":"Rippling Light (W.I.P)","username":"TheCatIs","description":"D + Click - Start Ripple\n0-2 - Ripple\n↔↕ - Move\nShift + ↔↕ : Cycle X/Y Distortion (Alt: Both)\nCtrl + ↔↕ : Cycle color\nC - Reset Colors\nV - Reset Distortion\nW - Wipe\nP - Pause1\nQ - Pause2\nT - Text\nX/Y/A - Mirroring\nB - Blur1\nN - Blur2\nI - Invert","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["2d","simulation","light","colorful","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCredit to \"kishimisu\" for the text creation! Original ShaderToy:\nhttps://www.shadertoy.com/view/dsGXDt\n*/\n\n/*\nCredit to whoever made the HSV function, it is not mine. Original found at:\nhttps://gist.github.com/983/e170a24ae8eba2cd174f\n*/\n\nmakeStr1i(printNumDistX)  _D _i _s _t _o _r _t _i _o _n __ _X _COL __ _dig(i) _end\nmakeStr1i(printNumDistY)  _D _i _s _t _o _r _t _i _o _n __ _Y _COL __ _dig(i) _end\nmakeStr1i(printNumDistType)  _R _i _p _p _l _e __ _T _y _p _e _COL __ _dig(i) _end\n\nmakeStr1i(printColMap)  _C _o _l _o _r __ _M _a _p _COL __ _dig(i) _end\nmakeStr1i(printColType)  _C _o _l _o _r __ _T _y _p _e _COL __ _dig(i) _end\n\nconst int exp = 0;\n\nbool holdKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 0), 0).x));\n}\nbool pressKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 1), 0).x));\n}\nbool toggleKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 2), 0).x));\n}\n\nvec3  hsv2rgb     (vec3 c)    {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid valVersions(inout vec4 col, in int version){\n\nswitch(version) {\ncase(0):\n    col.x = 1.0 - pow(2.0 * col.x - 1.0, 2.0);\n    break;\ncase(2):\n    col.x = 1.0 - pow(2.0 * col.x - 1.0, 2.0);\n    col.x = 1.0 - pow(2.0 * col.x - 1.0, 2.0);\n    break;\ncase(3):\n    col.x = abs(sin(col.x*6.0*2.0*3.14)) * col.x;\n    break;\ncase(4):\n    col.x = 1.0 - pow(2.0 * col.x - 1.0, 2.0);\n    col.x = abs(sin(col.x*15.0*2.0*3.14 - 1.6)) * col.x;\n    break;\ncase(5):\n    col.x = abs(sin(col.x*15.0*2.0*3.14));\n    break;\n}\n}\n\nvoid colVersions(in vec4 col, in int version, out vec4 fragColor){\nswitch(version) {\ncase(0):\n    col.x = pow(col.x,3.0);\n\n    vec4 newCol = col.yxxw * vec4(0,col.x/1.7,1,0);\n\n    newCol = newCol + 1.0/(abs(col.x - 1.0)*80.0 + 1.0);\n\n    fragColor = newCol;\n    break;\ncase(1):\n    fragColor = col;\n    break;\ncase(2):\n    col.x = pow(col.x,3.0);\n    fragColor = col;\n    break;\ncase(3):\n    col.x = pow(col.x,0.45);\n\n    newCol = col.xxyy * vec4(1,pow(col.x,9.0),0,0);\n\n    newCol = newCol + 1.0/(abs(col.x - 1.0)*80.0 + 1.0);\n\n    fragColor = newCol;\n    break;\ncase(4):\n    col.x = 1.0 - col.x;\n    col.x = pow(col.x,0.9);\n\n    newCol = col.xxyy * vec4(1,pow(col.x,9.0),0,0);\n\n    newCol = newCol + 1.0/(abs(col.x - 1.0)*80.0 + 1.0);\n\n    fragColor = newCol;\n    break;\ncase(5):\n    float tempCol = col.x;\n\n    fragColor.xyz = hsv2rgb(vec3(col.x*5.0 + iTime/5.0,1.0,col.x));\n    break;\n}\n}\n\nvec4 find(float select) {\n\nselect = floor(select);\n\nfloat X = 1.0/pow(2.0,float(exp + 1))/8.0 + pow(2.0,float( - exp))*mod(select,pow(2.0,float(exp)));\nfloat Y = floor( select/pow(2.0,float(exp)) )/10.0 + 0.05/8.0;\n\nvec2 get = vec2(X,Y);\n\nreturn texture( iChannel1 , get );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//Input Buffer Dependencies\nint distX = int(find(0.0).x);\nint distY = int(find(0.0).y);\nint distType = int(find(1.0).x);\n\nint colMap = int(find(0.0).z);\nint colType = int(find(0.0).w);\n\nvec2 uv = fragCoord;\n\nvec2 uv2 = uv/iResolution.xy;\n\nvec2 uvText = uv/iResolution.y;\n\nuv.y *= iResolution.y/iResolution.x;\n\nvec4 col = abs(texture( iChannel0 , uv2 ));\n\nif(iTime < 0.01 || toggleKey(80)) {\n\nfragColor.y = 0.0;\nfragColor.x = col.x == 0.0 ? 0.0 : 0.40;\nfragColor = fragColor.yyxx;\n\n}\n\nelse{\n\nvalVersions(col, colMap);\n\ncolVersions(col, colType, fragColor);\n\n}\n\nif(toggleKey(84)) {\nfloat fontSize = 1.5; fontSize /= 25.0;\n\nvec3 colText = vec3(0);\n\ncolText += vec3(1,.4,.4) * printNumDistX((uvText - vec2(0.0,0.94)) / fontSize, distX);\ncolText += vec3(1,.4,.4) * printNumDistY((uvText - vec2(0.0,0.88)) / fontSize, distY);\n\ncolText += vec3(1,.4,.4) * printColMap((uvText - vec2(0.0,0.82)) / fontSize, colMap);\ncolText += vec3(1,.4,.4) * printColType((uvText - vec2(0.0,0.76)) / fontSize, colType);\n\ncolText += vec3(1,.4,.4) * printNumDistType((uvText - vec2(0.0,0.70)) / fontSize, distType);\n\nfragColor.xyz = (colText.x == 0.0 ? fragColor.xyz : colText);\n\n//fragColor.xyz += colText;\n}\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n\nDistortion 0: None\nDistortion 1: Sine\nDistortion 2: Counter-Clockwise Rotate\nDistortion 3: Square Wave 1\nDistortion 4: Square Wave 2\nDistortion 5: Wiggle\nDistortion 6: Co-Secant\nDistortion 7: Secant\nDistortion 8: Mega Secant 1\nDistortion 9: Mega Secant 2\nDistortion 10 ( : ): Mega Secant 3\n\n\n* Special *\nDistortion -1 ( / ): Alternate Secant\nDistortion -2 ( . ): Alternate Sine\nDistortion -3 ( - ): Alternate Rotate\nDistortion -4 ( , ): Zoom Heaven (Slow)\nDistortion -5 ( + ): Zoom Heaven (Fast)\nDistortion -6 ( * ): Unstable Grid 1\nDistortion -7 ( ) ): Unstable Grid 2\n*/\n\nconst float zoom = 900.0;\n\n/*\nfloat bounce(float x) {\nreturn mod(floor(x), 2.0) == 0.0 ? x - floor(x) : 1.0 - x + floor(x) - 0.5;\n}\n*/\n\nbool holdKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 0), 0).x));\n}\nbool pressKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 1), 0).x));\n}\nbool toggleKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 2), 0).x));\n}\n\nconst int exp = 0;\n\nvec4 find(float select) {\n\nselect = floor(select);\n\nfloat X = 1.0/pow(2.0,float(exp + 1)) + pow(2.0,float( - exp))*mod(select,pow(2.0,float(exp)));\nfloat Y = floor( select/pow(2.0,float(exp)) )/10.0 + 0.05;\n\nvec2 get = vec2(X,Y);\n\nreturn texture( iChannel1 , get );\n\n}\n\nvec4 read(vec2 base, float offsetA,float offsetB) {\n\nvec2 vec = base - vec2(offsetA,offsetB*1.77777778)/150.0;\n\nif(vec.x < 0.0 || vec.x > 1.0 || vec.y < 0.0 || vec.y > 1.0) {\nreturn vec4(0,0,0,0);\n//texture( iChannel0 , vec)/1.85;\n}\n\nreturn texture( iChannel0 , vec);\n}\n\nvoid animCaser(int version, out int set, float uvCoord){\n\nswitch (version) {\ncase -3:\n    set = -2;\n    break;\ncase -2:\n    set = -1;\n    break;\ncase -1:\n    set = mod(iTime,3.0) < 1.5 ? 6 : 7;\n    break;\ndefault: set = version;\n}\n\n}\n\nvoid caser(int version, out float set, float uvCoord, float uvCoordAlt, bool isX){\n\nvec2 o;\nfloat xCoord;\nfloat yCoord;\nfloat s;\n\nswitch (version) {\ncase -7:\n\n    xCoord = isX ? uvCoordAlt : uvCoord;\n    yCoord = isX ? uvCoord : uvCoordAlt;\n    \n    o = vec2(xCoord,yCoord)/11.0;\n    \n    o = mod(o, vec2(12.0)) - 6.0;\n    \n    o /= 30.0;\n    o *= sin(iTime*1.3 + xCoord/34.0);\n   \n    set = isX ? o.x : o.y;\n    \n    break;\ncase -6:\n\n    xCoord = isX ? uvCoordAlt : uvCoord;\n    yCoord = isX ? uvCoord : uvCoordAlt;\n    \n    o = vec2(xCoord,yCoord)/11.0;\n    \n    o = mod(o, vec2(12.0)) - 6.0;\n    \n    o /= 30.0;\n    o *= sin(iTime*1.3);\n   \n    set = isX ? o.x : o.y;\n    \n    break;\ncase -5:\n    o = zoom*vec2(0.5,0.5);\n    o.y *= iResolution.y/iResolution.x;\n    \n    xCoord = isX ? uvCoordAlt : uvCoord;\n    yCoord = isX ? uvCoord : uvCoordAlt;\n    o = sin(iTime/1.0) * /*normalize*/(vec2(xCoord,yCoord)-o)/390.0;\n    \n    set = isX ? o.x : o.y;\n    \n    break;\ncase -4:\n    o = zoom*vec2(0.5,0.5);\n    o.y *= iResolution.y/iResolution.x;\n    \n    xCoord = isX ? uvCoordAlt : uvCoord;\n    yCoord = isX ? uvCoord : uvCoordAlt;\n    o = sin(iTime/3.0) * /*normalize*/(vec2(xCoord,yCoord)-o)/390.0;\n    \n    set = isX ? o.x : o.y;\n    \n    break;\ncase -2:\n    o = zoom*vec2(0.5,0.5);\n    o.y *= iResolution.y/iResolution.x;\n    \n    xCoord = isX ? uvCoordAlt : uvCoord;\n    yCoord = isX ? uvCoord : uvCoordAlt;\n    o = sin(iTime/3.0) * /*normalize*/(vec2(xCoord,yCoord)-o)/390.0;\n    \n    o.xy = o.yx * vec2(-1,1);\n    \n    set = isX ? o.x : o.y;\n    \n    break;\ncase -1:\n          s = sin(iTime*1.5);\n          s = pow(abs(s),1.4)*sign(s);\n    set = sin(iTime/1.6 + uvCoord/89.0) * 0.45 * s;\n    break;\ncase 0:\n    set = 0.0;\n    break;\ncase 1:\n    set = sin(iTime/4.0 + uvCoord/89.0)*0.2;\n    break;\ncase 2:\n    o = zoom*vec2(0.5,0.5);\n    o.y *= iResolution.y/iResolution.x;\n    \n    xCoord = isX ? uvCoordAlt : uvCoord;\n    yCoord = isX ? uvCoord : uvCoordAlt;\n    o = /*normalize*/(vec2(xCoord,yCoord)-o)/490.0;\n    \n    o.xy = o.yx * vec2(-1,1);\n    \n    set = isX ? o.x : o.y;\nbreak;\ncase 3:\n    s = sin(iTime/4.0 + uvCoord/39.0);\n    set = pow(abs(s),0.4)*sign(s)*0.2;\nbreak;\ncase 4:\n    s = sin(iTime/2.0 + uvCoord/19.0);\n    set = pow(abs(s),0.0001)*sign(s)*0.2;\nbreak;\ncase 5:\n          s = sin(iTime*1.5);\n          s = pow(abs(s),99.4)*sign(s);\n    set = sin(iTime/1.6 + uvCoord/89.0) * 0.45 * s;\n    break;\ncase 6:\n    set = 1.0/sin(iTime/4.0 + uvCoord/89.0)*0.2;\n    break;\ncase 7:\n    set = 1.0/cos(iTime/4.0 + uvCoord/89.0)*0.2;\n    break;\ncase 8:\n    set = 1.0/cos(iTime/4.0 + uvCoord/89.0 + sin(uvCoord/3.0))*0.2;\n    break;\ncase 9:\n    set = 1.0/cos(iTime/4.0 + uvCoord/89.0 + sin(uvCoord/2.0)*15.0)*0.2;\n    break;\ncase 10:\n    set = 1.0/cos(iTime/4.0 + uvCoord/89.0 + tan(uvCoord/200.0 - iTime/15.0)*1.0)*0.2;\n    break;\n}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//Input Buffer Dependencies\nint verXAnim = int(find(0.0).x);\nint verYAnim = int(find(0.0).y);\nint distType = int(find(1.0).x);\n\nvec2 uv = fragCoord/iResolution.xy;\n\nvec2 uv2 = uv;\n\nuv = uv*zoom;\n\nuv.y *= iResolution.y/iResolution.x;\n\nvec2 m = iMouse.xy/iResolution.xy;\n\nvec2 m2 = m;\n\nm = zoom*m;\n\nm.y *= iResolution.y/iResolution.x;\n\nfloat offX = 0.0;\nfloat offY = 0.0;\n\nint verX = 0;\nint verY = 0;\n\nif(!toggleKey(80)) {\nanimCaser(verXAnim,verX,uv.y);\nanimCaser(verYAnim,verY,uv.x);\n\ncaser(verX,offX, uv.y, uv.x, true);\ncaser(verY,offY, uv.x, uv.y, false);\n\noffX += (!holdKey(18) && !holdKey(17) && !holdKey(16)) ? (holdKey(37) ? -1.0 : (holdKey(39) ? 1.0 : 0.0)) : 0.0;\noffY += (!holdKey(18) && !holdKey(17) && !holdKey(16)) ? (holdKey(40) ? -1.0 : (holdKey(38) ? 1.0 : 0.0)) : 0.0;\n}\n\nfloat test = read(uv2, offX, offY).x;\n\nfloat tOffset = 0.002;\n\nfloat testUp = read(uv2,              offX, tOffset  + offY).x;\nfloat testDown = read(uv2,            offX, -tOffset + offY).x;\nfloat testLeft = read(uv2, -tOffset + offX,            offY).x;\nfloat testRight = read(uv2, tOffset + offX,            offY).x;\n\n/*\nfloat testUp = read(uv2, 0.0 + offX, tOffset + offY).x;\nfloat testDown = read(uv2, 0.0 + offX, -tOffset + offY).x;\nfloat testLeft = read(uv2, -tOffset + offX, 0.0 + offY).x;\nfloat testRight = read(uv2, tOffset + offX, 0.0 + offY).x;\n*/\n\nbool keyA = holdKey(65);\nbool keyX = holdKey(88);\nbool keyY = holdKey(89);\n\nbool keyB = holdKey(66);\nbool keyN = holdKey(78);\n\nbool keyI = holdKey(73);\n//bool keyO = holdKey(79);\n\nbool keyD = holdKey(68);\n\n//bool key1 = pressKey(49);\n\nif(keyB || keyN) {\n\nfloat blurVal = 0.0;\n\nfloat amt = 40.0;\n\nfor(float i = 0.0; i < amt; i++){\n\nif(!(holdKey(66) || holdKey(78))) {\nbreak;\n}\n\nfloat tOffsetBlur = 0.004*i;\n\n\n\nblurVal += read(uv2, offX,                tOffsetBlur + offY).x;\nblurVal += read(uv2, offX,               -tOffsetBlur + offY).x;\nblurVal += read(uv2, -tOffsetBlur + offX, offY).x;\nblurVal += read(uv2, tOffsetBlur  + offX, offY).x;\n}\n\ntest = (test + blurVal)/(amt*4.0 + 1.0);\n\n}\n\nfloat allTest = max(test, max(testUp, max(testDown, max(testLeft, testRight))));\n\nif(keyD) {\n\nfloat dis = 0.001*zoom;\n\nif(distance(m,uv) < dis) {\ntest += 0.00001;\n}\n\nif(toggleKey(88) && distance(vec2(zoom - m.x,m.y),uv) < dis){\ntest += 0.00001;\n}\n\nif(toggleKey(89) && distance(vec2(m.x,zoom*0.5625 - m.y),uv) < dis){\ntest += 0.00001;\n}\n\nif(toggleKey(65) && distance(vec2(zoom - m.x,zoom*0.5625 - m.y),uv) < dis){\ntest += 0.00001;\n}\n\n}\n\n/*if(pressKey(49) && test != 0.0) { test += 0.1; }*/\n\nif(iTime < 0.01) {\ntest = test == 0.0 ? 0.0 : 0.999999;\n}\n\nelse if(test == 0.0 && allTest != 0.0 && !toggleKey(80) && !toggleKey(81)) {\ntest = allTest;\n}\n\nelse if(allTest != 0.0 && !toggleKey(80) && !toggleKey(81) && !holdKey(78)) {\n\nfloat avg;\n\nswitch(distType){\ncase 0:\n    test = mod(test,1.0) + 1.0/255.0;\n    break;\n\ncase 1:\n    avg = (testUp + testDown + testLeft + testRight + test)/5.0;\n    test = mod(test,1.0) + (avg + 0.01)/65.0;\n    break;\n\ncase 2:\nif(test < -1.0) {test = 1.0;} else if(test > 1.0){test = -1.0;}\n\navg = (testUp + testDown + testLeft + testRight)/4.0;\n\nif(abs(test-avg) > 0.0005) {\n\nvec2 o = uv/zoom - vec2(0.5,0.28125);\nvec2 o2 = 1.3/(abs(o*5.0) + 1.0);\n\n\n\nfloat oM = max(pow(o2.x,9.0), pow(o2.y,9.0));\n\n\n\ntest = test*0.1 + avg*0.9; test /= 1.15 + 20.0*sin(-iTime/2.0 + zoom*length(o)/20.0 + oM)/100.0;\n}\n\n    test -= 2.5/255.0;\n    \n    break;\ncase 3:\n\nfloat minVal = -15.0/2550.0;\n\nif(test < 0.0) {\n    float allMin = min(test, min(testUp, min(testDown, min(testLeft, testRight)))) + 1.0/2550.0;\n    test = min(allMin, 0.0);\n    test = max(test, minVal);\n}\nelse if(allTest < 1.0) {\n    test += 1.0/255.0;\n}\nelse {\n    test = minVal;\n}\n    break;\n}\n\n}\n\nelse if(test < 0.03 && toggleKey(81)) {\ntest = 0.0;\n}\n\nif(pressKey(73) && test != 0.0) {\ntest = 1.0-test;\n}\n\nfragColor = vec4(clamp(test,-1.1,1.1), vec3(0));\n\n//test = read(uv2, 0.00 + offX, 0.00 + offY).x;\n\n//fragColor = vec4(clamp(test,-1.1,1.1), vec3(0));\n\n//fragColor = vec4(test,0,0,0);\n\nif(pressKey(87)) {\nfragColor = vec4(0,0,0,0);\n}\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int exp = 0;\n\nvoid resetClamp(inout float num, float low, float high) {\n\nif(num > high) {\nnum = low; return;\n}\nif(num < low) {\nnum = high; return;\n}\n\n}\n\nvec4 find(float select) {\n\nselect = floor(select);\n\nfloat X = 1.0/pow(2.0,float(exp + 1))/8.0 + pow(2.0,float( - exp))*mod(select,pow(2.0,float(exp)));\nfloat Y = floor( select/pow(2.0,float(exp)) )/10.0 + 0.05/8.0;\n\nvec2 get = vec2(X,Y);\n\nreturn texture( iChannel1 , get );\n\n}\n\nbool holdKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 0), 0).x));\n}\nbool pressKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 1), 0).x));\n}\nbool toggleKey(int key) {\nreturn (1 == int(texelFetch(iChannel2, ivec2(key, 2), 0).x));\n}\n\nconst int length = int( pow(2.0,float(exp)) ) * 10;\n\nvec4 arr[length];\n\nint limit = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\nbool keyShiftHold = holdKey(16);\nbool keyCtrlHold = holdKey(17);\nbool keyAltHold = holdKey(18);\n\nbool keyLeftPress = pressKey(37);\nbool keyUpPress = pressKey(38);\nbool keyRightPress = pressKey(39);\nbool keyDownPress = pressKey(40);\n\nbool keyVPress = pressKey(86);\nbool keyCPress = pressKey(67);\n\nbool key0 = pressKey(48);\nbool key1 = pressKey(49);\nbool key2 = pressKey(50);\nbool key3 = pressKey(51);\n\narr[0] = find(0.0);\narr[1] = find(1.0);\n\nif(keyVPress) {\narr[0].x = 0.0;\narr[0].y = 0.0;\n}\nif(keyCPress) {\narr[0].z = 0.0;\narr[0].w = 0.0;\n}\n\nif(keyAltHold){\narr[0].y = arr[0].x;\n}\n\nif     (keyRightPress && keyShiftHold) {\narr[0].x += 1.0;\n}\nelse if(keyLeftPress && keyShiftHold) {\narr[0].x -= 1.0;\n}\n\nelse if(keyUpPress && keyShiftHold) {\narr[0].y += 1.0;\n}\nelse if(keyDownPress && keyShiftHold) {\narr[0].y -= 1.0;\n}\n\nelse if(keyRightPress && keyCtrlHold) {\narr[0].z += 1.0;\n}\nelse if(keyLeftPress && keyCtrlHold) {\narr[0].z -= 1.0;\n}\n\nelse if(keyUpPress && keyCtrlHold) {\narr[0].w += 1.0;\n}\nelse if(keyDownPress && keyCtrlHold) {\narr[0].w -= 1.0;\n}\n\nelse if(keyRightPress && keyAltHold) {\narr[0].y += 1.0;\narr[0].x += 1.0;\n}\nelse if(keyLeftPress && keyAltHold) {\narr[0].y -= 1.0;\narr[0].x -= 1.0;\n}\n\nelse if(key0) {\narr[1].x = 0.0;\n}\n\nelse if(key1) {\narr[1].x = 1.0;\n}\n\nelse if(key2) {\narr[1].x = 2.0;\n}\n\n\nresetClamp(arr[0].x,-7.0,10.0);\nresetClamp(arr[0].y,-7.0,10.0);\n\nresetClamp(arr[0].z,0.0,5.0);\nresetClamp(arr[0].w,0.0,5.0);\n\nvec2 uv = fragCoord/iResolution.xy;\n\nfloat amt = 1.0 / pow(2.0,float(exp));\nfloat invAmt = pow(2.0,float(exp));\n\nvec4 col = vec4(0,0,0,0);\n\nfor(float i = 0.0; i < 10.0; i += amt) {\n\nif(int(i * invAmt) > limit) {\nbreak;\n}\n\nif( mod(i,1.0) < uv.x && uv.x < mod(i,1.0) + amt &&\n  floor(i)*0.1 < uv.y && uv.y < floor(i)*0.1 + 0.1) {\n\ncol = arr[int(i * invAmt)];\n\n}\n\n}\n\nfragColor = col;\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\nCredit to \"kishimisu\" for the text creation! Original ShaderToy:\nhttps://www.shadertoy.com/view/dsGXDt\n*/\n\n/*   ### How to use this shader ? ###\n   \n   = Setup =\n   0. Copy the content of the Common Tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n   \n   = Declare String =\n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printAnother) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n   \n   = Print String =\n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printAnother(uv);\n   \n   Note that by default a character has a height of 1 (which is full height if \n   the coordinates are normalized). You are responsible for scaling/offsetting \n   the uvs to control the text placement before calling the function.\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _EXC _QUOT ... (see Common)\n   \n   \n   ### Javascript string generator helper ###\n   \n   To make things even easier, I've made a tiny javascript helper function that you\n   can use to convert strings to the right _F _o _r _m _a _t !\n   (I've written it in the comments of this shader)\n   \n   \n   ### Special functions ###\n   \n   _dig(i)       : write a specific digit [i ranges between 0-9]\n   _dec(i, prec) : write a floating point number [prec: number of decimals to print]\n   _ch(i)        : Write an uppercase character [i ranges between 0-25]\n   \n   To use these special functions, you need to pass additional parameters into makeStr:\n   \n   \"makeStr1i\" allows you to pass 1 int parameter named \"i\" :\n   \n   makeStr1i(test) _dig(i) _end\n   test(uv, 5);\n   \n   \"makeStr1f\" allows you to pass 1 float parameter named \"i\":\n   \n   makeStr1f(test) _dec(i, 3) _end\n   test(uv, 5.);\n   \n   You can also create your own makeStr with any parameter type! (see below)\n   \n   \n   ### Help me optimize it! ###\n   \n   The _dec() function is only for debug purposes, I've never used it in a published shader.\n   It's *very* intensive and can have rounding issues (ie 21.999 when the float is 22.), \n   however it's done with a pretty naive approach so if you can come up with a better one\n   I'd be glad! The function is defined at the very end of this tab.\n*/\n\n/// SETTINGS ///\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel3\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n\n/// SPECIAL FUNCTIONS ///\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n\n/// SPECIAL CHARACTERS ///\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n\n/// CHARACTER DEFINITIONS ///\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).r * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    (0 _DOT ); // Print a dot\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}","name":"Common","description":"","type":"common"}]}