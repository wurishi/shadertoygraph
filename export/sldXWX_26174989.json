{"ver":"0.1","info":{"id":"sldXWX","date":"1639941491","viewed":217,"name":"Snowman and The Tree","username":"tsaari42","description":"\"Joulu meni jo.\" (the idea was to improve with denoising/etc before xmas, but didn't have the time - so this quick hack it is and will be)\n\nChristmas tree by TekF, Snowing fx by HeGu, check the src. Suggested listening.. \"Walking in the Air\"","likes":5,"published":1,"flags":32,"usePreview":1,"tags":["christmas","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// using heavy postprocessing to hide rendering imperfections\n// is an old gamedev trick, too, define to see what's going on\n//#define NO_POST_PROCESSING\n\nconst int num_bloom_samples = 132;\nconst float bloom_r = 0.01;\nconst float bloom_threshold = 0.9;\nconst float bloom_pow = 64.0;\n\n//----------------------------------------------------------------------\nconst float PI = 3.141592; // close enough\nconst float TWO_PI = 2.*PI;\n\n// texnoise\nvec2 tnoise2d_2f(vec2 v, float m) {\n    return texture(iChannel1, v + vec2(m*7.7)).xy;\n}\n\n// iq\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); } // [0,1]\nfloat rnd_signed() { return 2.*rnd() - 1.; } // [-1,1]\n\n// gaussian filter, \"bell curve/surface\"\nfloat gaussian(in vec2 v, float m) {\n    return (1.0 / (TWO_PI*m*m)) * exp(-(v.x*v.x + v.y*v.y) / (2.0*m*m));\n}\n\n\n//----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n#ifdef NO_POST_PROCESSING\n    fragColor = vec4(color, 1.0f);\n#else\n    vec2 uv = fragCoord / iResolution.xy; // [0,1], no aspect\n    seed = iTime + uv.x*1234.5 + uv.y*6543.2; // TODO\n    \n    // LDR bloom with noise.. bring the noise! :D\n    vec3 bloom = vec3(0);\n    for(int n=0; n < num_bloom_samples; ++n) {\n        vec2 ran = tnoise2d_2f(uv, iTime);\n        float a = ran.x * TWO_PI; //rnd() * TWO_PI;\n        float r = ran.y * bloom_r; //rnd() * bloom_r;\n        vec2 v = vec2(cos(a)*r, sin(a)*r);\n        float w = gaussian(v, 0.01);\n        vec3 s = texture(iChannel0, uv + v).rgb; // note: iChannel0 wrap clamped\n        s = clamp(s - vec3(bloom_threshold), 0.0, 1.0) / (1.0 - bloom_threshold); // [0,1] \n        s = pow(s, vec3(bloom_pow));\n        bloom += w*s;\n    }\n    bloom /= float(num_bloom_samples);\n    \n    // DEBUG: show out-of-color-ranges problems..\n    //if( c.r < 0.0 || c.g < 0.0 || c.b < 0.0 ) c = vec3(1,0,0);\n    //if( c.r > 1.0 || c.g > 1.0 || c.b > 1.0 ) c = vec3(1,0,1);\n\n    // crossfade into different post-processing..\n    vec3 c = bloom;\n    float t = fract(iTime/20.0);\n    //t = 0.0; // DEBUG\n    c = (t < 0.5) ? \n            mix(c, color, smoothstep(0.3, 0.5, t)):\n            mix(color, c, smoothstep(0.8, 1.0, t));\n    \n    fragColor = vec4(c, 1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright (c) Timo Saarinen 2021\n// You can use this Work in a Good and Cool Spirit.\n//\n// Disclaimer: WIP!\n//------------------------------------------------------------------------\nconst int NUM_SAMPLES = 1;\nconst float EXPOSURE = 30.0;\n    \nconst float PI = 3.141592; // close enough\nconst float TWO_PI = 2.*PI;\nconst float EPSILON = 0.0001;\nconst float NOHIT = 999999999.0; // keep positive intersection miss, so can easily min() the closest one\nconst float FADE_DIST = 500.;\n\nconst int ID_NONE       = 0;\nconst int ID_SPHERE01   = 1;\nconst int ID_SPHERE02   = 2;\nconst int ID_SPHERE03   = 3;\nconst int ID_PLANE      = 4;\nconst int ID_CARROTCONE = 5;\n\nconst vec3 sun_dir = normalize(vec3(1,1,1));\nconst float camera_alt = 1.9;\nconst float camera_distance = 2.5;\nconst vec3 camera_look_at_tree = vec3(0,3,0);\nconst float sphere_radius[3] = float[3](0.3, 0.25, 0.15); // legs, torso, head\nconst float sphere_alt[3]    = float[3](-0.1 + 0.3, -0.1 + 1.5*0.3 + 0.25, -0.1 + 1.5*0.3 + 1.8*0.25 + 0.15);\nconst float sphere_dist = 1.9;\nconst float jump_altitude = 0.5;\nconst vec3 planen = vec3(0,1,0);\nconst float plane_alt = 1.6;\nconst float plane_radius = 500.0; // floor circle\n\n//------------------------------------------------------------------------\nvec3 HDR_to_LDR(vec3 c) { return pow(c, vec3(1.0/2.2)); }\nvec3 LDR_to_HDR(vec3 c) { return pow(c, vec3(2.2)); }\n\n//------------------------------------------------------------------------\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); } // [0,1]\nfloat rnd_signed() { return 2.*rnd() - 1.; } // [-1,1]\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec4 iCappedCone( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n         if( m1<0.0 ) { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) return vec4(-m1/m3,-ba*inversesqrt(m0)); }\n    else if( m2>0.0 ) { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) return vec4(-m2/m3, ba*inversesqrt(m0)); }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) \n    {\n        return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));\n    }\n    \n    return vec4(NOHIT); //vec4(-1.0);\n}\n\n//------------------------------------------------------------------------\nvec3 random_hemisphere_dir(in vec3 n) {\n    vec3 dir;\n    dir.x = rnd_signed();\n    dir.y = rnd_signed();\n    dir.z = rnd_signed();\n    dir = normalize(dir);\n    return dot(dir,n) > 0. ? dir : -dir;\n}\n\n// https://www.shadertoy.com/view/MsXfz4\n// https://www.shadertoy.com/view/4sSSW3\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\nmat3 mat3FromNormal(in vec3 n) {\n    vec3 x;\n    vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\nvec3 l2w( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y / rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\nvec3 sampleHemisphereCosWeighted(in vec2 xi) {\n    float theta = acos(sqrt(1.0-xi.x));\n    float phi = TWO_PI * xi.y;\n    return sphericalToCartesian( 1.0, phi, theta );\n}\nvec3 sampleHemisphereCosWeighted( in vec3 n, in vec2 xi ) {\n    return l2w( sampleHemisphereCosWeighted( xi ), n );\n}\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n//------------------------------------------------------------------------\n// Star background\n// https://www.shadertoy.com/view/XsyGWV\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n//------------------------------------------------------------------------\nvec3 fog(vec3 dir, vec3 c) {\n    float t = 1.0 - clamp(abs(dir.y) / 0.05, 0.0, 1.0);\n    t *= t;\n    return mix(c, vec3(0.0015), t);\n}\n\nvec3 background_ldr(vec3 dir) { // specular\n    vec3 c = (dir.y >= 0.0) ? stars(dir) : vec3(0);\n    c += vec3(clamp(pow(clamp(dot(normalize(vec3(1,1,1)), dir), 0.0, 1.0), 256.0) * 0.2, 0.0, 0.02)); // full moon\n    c += pow(1.0 - abs(dir.y), 4.0) * 0.03 * LDR_to_HDR(vec3(11.0/255.0, 24.0/255.0, 56.0/255.0)); // horizon gradient\n    return fog(dir, c);\n}\nvec3 background_hdr(vec3 dir) { // specular\n    return background_ldr(dir);\n}\nvec3 background_diffuse(vec3 dir) {\n    return background_hdr(dir); // TODO: convolute?\n}\n\n// TODO\nvec3 snow_noise(vec3 p) {\n    //return normalize(vec3(1.0 + noise(p), 1.0 + noise(p*1.13), 1.0 + noise(p*0.97))); //return vec3(cos(p.x*7.17)*cos(p.z*3.13), cos(p.y*3.71), cos(p.z*5.71));\n    vec3 c = texture(iChannel3, p*7.7).xyz * texture(iChannel3, p*77.7).xyz; // TODO\n    return c*c;\n}\n\n// Snow, returns xyz=diffuse, w=specular. Very ad hoc.\nvec4 gen_snow(vec3 ro, vec3 rd, vec3 p, inout vec3 n) {\n    vec3 normal = normalize(n + snow_noise(p)*0.5);\n    float diff = 0.5 + 0.5*snow_noise(1.17*p).x; //texture(iChannel2, 0.7*p.xz).r * texture(iChannel2, 7.7*p.xz);\n    diff = pow(diff, 0.5);\n    float spec = 0.01; // + pow(max(0.0, 1.0 - dot(normal, -rd)), 64.0);\n    n = normal;\n    return vec4(diff * vec3(1.0 - spec), spec);\n}\n\n// Ground plane color, snow!\nvec3 planeground(vec3 ro, vec3 rd, vec3 p, inout vec3 n) {\n    return gen_snow(ro, rd, p, n).rgb;\n}\n\n//-------------------------------------------------------------------------------\n// Snowing by HeGu: https://www.shadertoy.com/view/4dl3R4\n// This shader useds noise shaders by stegu -- http://webstaff.itn.liu.se/~stegu/\n// This is supposed to look like snow falling, for example like http://24.media.tumblr.com/tumblr_mdhvqrK2EJ1rcru73o1_500.gif\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(vec4 x) {\n    return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec2 v)\n{\n        const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n        \n        vec2 i1;\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n        \n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n            + i.x + vec3(0.0, i1.x, 1.0 ));\n        \n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n        \n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n        \n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n        \n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n        return 130.0 * dot(m, g);\t\t\n}\n\nfloat cellular2x2(vec2 P)\n{\n        const float K=0.142857142857; // 1/7\n        const float K2=0.0714285714285; // K/2\n        const float jitter=0.8; // jitter 1.0 makes F1 wrong more often\n        \n        vec2 Pi = mod(floor(P), 289.0);\n        vec2 Pf = fract(P);\n        vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n        vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n        vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n        p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n        vec4 ox = mod(p, 7.0)*K+K2;\n        vec4 oy = mod(floor(p*K),7.0)*K+K2;\n        vec4 dx = Pfx + jitter*ox;\n        vec4 dy = Pfy + jitter*oy;\n        vec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n        // Sort out the two smallest distances\n        \n        // Cheat and pick only F1\n        d.xy = min(d.xy, d.zw);\n        d.x = min(d.x, d.y);\n        return d.x; // F1 duplicated, F2 not computed\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    float w = 0.5;\n    for (int i = 0; i < 5; i ++) {\n                f += w * snoise(p);\n                p *= 2.;\n                w *= 0.5;\n    }\n    return f;\n}\n\nvec3 snowing_layer_2d( in vec2 fragCoord )\n{\n    float speed=2.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x*=(iResolution.x/iResolution.y);\n    \n    vec2 suncent=vec2(0.3,0.9);\n    \n    float suns=(1.0-distance(uv,suncent));\n    suns=clamp(0.2+suns,0.0,1.0);\n    float sunsh=smoothstep(0.85,0.95,suns);\n\n    float slope;\n    slope=0.8+uv.x-(uv.y*2.3);\n    slope=1.0-smoothstep(0.55,0.0,slope);\t\t\t\t\t\t\t\t\n    \n    float noise=abs(fbm(uv*1.5));\n    slope=(noise*0.2)+(slope-((1.0-noise)*slope*0.1))*0.6;\n    slope=clamp(slope,0.0,1.0);\n                            \n    vec2 GA;\n    GA.x-=iTime*1.8;\n    GA.y+=iTime*0.9;\n    GA*=speed;\n\n    float F1=0.0,F2=0.0,F3=0.0,F4=0.0,F5=0.0,N1=0.0,N2=0.0,N3=0.0,N4=0.0,N5=0.0;\n    float A=0.0,A1=0.0,A2=0.0,A3=0.0,A4=0.0,A5=0.0;\n\n\n    // Attentuation\n    A = (uv.x-(uv.y*0.3));\n    A = clamp(A,0.0,1.0);\n\n    // Snow layers, somewhat like an fbm with worley layers.\n    F1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n    A1 = 1.0-(A*1.0);\n    N1 = smoothstep(0.998,1.0,F1)*1.0*A1;\t\n\n    F2 = 1.0-cellular2x2((uv+(GA*0.2))*6.0);\t\n    A2 = 1.0-(A*0.8);\n    N2 = smoothstep(0.995,1.0,F2)*0.85*A2;\t\t\t\t\n\n    F3 = 1.0-cellular2x2((uv+(GA*0.4))*4.0);\t\n    A3 = 1.0-(A*0.6);\n    N3 = smoothstep(0.99,1.0,F3)*0.65*A3;\t\t\t\t\n\n    F4 = 1.0-cellular2x2((uv+(GA*0.6))*3.0);\t\n    A4 = 1.0-(A*1.0);\n    N4 = smoothstep(0.98,1.0,F4)*0.4*A4;\t\t\t\t\n\n    F5 = 1.0-cellular2x2((uv+(GA))*1.2);\t\n    A5 = 1.0-(A*1.0);\n    N5 = smoothstep(0.98,1.0,F5)*0.25*A5;\t\t\t\t\n                    \n    float Snowout=N5+N4+N3+N2+N1;\n                    \n    //Snowout = 0.35+(slope*(suns+0.3))+(sunsh*0.6)+N1+N2+N3+N4+N5;\n    Snowout = 0.35+slope*0.3+N1+N2+N3+N4+N5;\n\n    return vec3(Snowout*0.9, Snowout, Snowout*1.1);\n}\n\n//-------------------------------------------------------------------------------\n// Christmas tree by TekF: https://www.shadertoy.com/view/wtd3D4\n\n// reduce this to improve frame rate in windowed mode\n#define AA_QUALITY .5\n// allow a little bleed between pixels - I think this looks more photographic, but blurrier\n#define AA_ROUND true\n#define AA_ROUND_RADIUS 0.7071\n\n// hashes from https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 exp2(-32.)\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2  hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3  hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4  hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\nfloat TreeBoundsSDF( vec3 pos )\n{\n    // just a cone\n    float r = length(pos.xz);\n    return max( dot( vec2(pos.y-7.,r), normalize(vec2(.3,1)) ), -pos.y+1.8+r*.6 );\n}\n\n/*\nWarp space into a series of repeated cells (\"branches\") around the y axis\nThis causes some distortion, causing marching errors near the axis when branches are\nparticularly sparse. But this can be worked round by tweaking the SDF.\n\nCells are mirrored so whatever's placed in them will tile with itself!\n\nyByOutStep - tilts branches along the axis, but breaks vertical tiling.\n*/\nvec3 HelixGrid( out ivec2 grid, vec3 pos, int numSpokes, float yStepPerRotation, float yByOutStep )\n{\n    // convert to polar coordinates\n    vec3 p = vec3(atan(pos.x,pos.z),pos.y,length(pos.xz));\n\n    p.y -= yByOutStep*p.z;\n    float l = sqrt(1.+yByOutStep*yByOutStep);\n    \n    // draw a grid of needles\n    vec2 scale = vec2(6.283185/float(numSpokes),yStepPerRotation);\n    p.xy /= scale;\n    \n    // rotate and skew the grid to get a spiral with nice irrational period\n    float sn = 1./float(numSpokes); // so we step by an integer number of rows\n\n    p.xy += p.yx*vec2(-1,1)*sn;\n   \n    // make horizontal triangle-waved, so edges of cells match up no matter what's put inside them!\n    grid = ivec2(floor(p.xy));\n    vec2 pair = fract((p.xy + 1.)*.5)*2.-1.;\n    p.xy = (abs(pair)-.5);\n    vec2 flip = step(0.,pair)*2.-1.; // sign() but without a 0.\n    p.xy *= scale;\n\n    // unshear...\n    p.y += flip.y*yByOutStep*p.z;\n    \n    // reconstruct a non-bent space\n    p.xz = p.z*vec2(sin(p.x),cos(p.x));\n\n    // ...and apply rotation to match the shear (now we've sorted out the grid stuff)\n    p.yz = ( p.yz + flip.yy*p.zy*vec2(-1,1)*yByOutStep )/l; // dammit - I think it breaks the wrap\n    \n// might be worth returning a bound on y to mask the discontinuous area\n// I think it will just be yByAngleStep/sqrt(1.+yByOutStep*yByOutStep) which caller can do if desired\n// Or, could make z NOT start at 0 - so caller has to bound using parent-level's length (totally viable and I'm doing it a lot)\n// so mirroring WOULD line up!\n    \n    return p;\n}\n\nstruct TreeSpace\n{\n    vec3 branch;\n    vec3 twig;\n    vec3 needle;\n    ivec2 branchGrid;\n    ivec2 twigGrid;\n    ivec2 needleGrid;\n};\n\nTreeSpace GetTreeSpace( in vec3 pos )\n{\n    TreeSpace o;\n    o.branch    = HelixGrid( o.branchGrid, pos, 12, .5, .5 );\n    o.twig      = HelixGrid( o.twigGrid, o.branch.xzy, 5, .5, 1. );\n    o.needle    = HelixGrid( o.needleGrid, o.twig.xzy, 9, .04, 1. );   \n    return o;\n}\n\nfloat TreeSDF( vec3 pos )\n{\n    float bounds = TreeBoundsSDF(pos);   \n    if ( bounds > 1. ) return bounds;\n    \n\tTreeSpace ts = GetTreeSpace(pos);\n\n\tfloat branchRand = hash1(coord2(uvec2(ts.branchGrid+0x10000)));\n    float branchEndLength = .3*(branchRand-.5);\n    \n    return\n        min(\n            max(\n                min(\n                    min(\n                        // twig\n                        length(ts.twig.xy)-.005,\n                        // needle\n                        length( vec3( ts.needle.xy, max(0.,ts.needle.z-.05) ) ) - .003\n                    ),\n                    // branch\n                    max(\n                    \t(length(ts.branch.xy\n                               + .004*sin(vec2(0,6.283/4.)+ts.branch.z*6.283/.1) // spiral wobble\n                              )-.01)*.9,\n                    \tbounds - branchEndLength - .2 // trim branches shorter than twigs\n                    )\n            \t),\n            \t// branch length (with rounded tip to clip twigs nicely)\n                length( vec3(ts.branch.xy,max(0.,bounds\n                                              -branchEndLength  // this seems to cause more floating twigs (or more obvious ones)\n                                             )) )-.3\n            ),\n            max(\n                // trunk\n                length(pos.xz)-.03,\n                bounds  // this will give a sharp point - better to just chop it - but might not show it\n            )\n        )*.7; // the helical distortion bends the SDF, so gradient can get higher than 1:1\n}\n\n// baubles only spawn in negative areas of this mask\nfloat BaubleBoundsSDF( vec3 pos )\n{\n    return abs(TreeBoundsSDF(pos))-.3; // half the width of the area bauble centres can be placed in\n}\n\n// pass different seeds and densities to generate different sets of baubles\n// if spacing = radius*2. the baubles will lie on a grid touching each other\nfloat BaublesSDF( vec3 pos, uint seed, float spacing, float radius, float power, float twist )\n{\n    // avoid looping over every bauble - find closest one from a handful of candidates, using a jittered grid\n    float f = BaubleBoundsSDF(pos);\n    f -= radius;\n    \n    float margin = .1; // distance at which to start computing bauble SDFs - affects speed of marching (trial and error suggests .1 is fairly optimal)\n    if ( f > margin ) return f;\n    \n\tvec3 offset = spacing*(hash3(coord1(seed))-.5); // use a different grid for each set of baubles\n\tpos += offset;\n\n    // find closest centre point\n    vec3 c = floor(pos/spacing);\n    ivec3 ic = ivec3(c);\n    c = (c+.5)*spacing; // centre of the grid square\n    \n    c += (spacing*.5 - radius /*- margin*/) * ( hash1(coord3(uvec3(ic+63356))^seed)*2. - 1. );\n    \n    // cull it if it's outside bounds\n    if ( BaubleBoundsSDF(c-offset) > 0. ) return margin; // could do max (margin, distance to grid cell edge)\n    \n    vec3 v = pos-c;\n    v.xz = v.xz*cos(v.y*twist) + v.zx*vec2(1,-1)*sin(v.y*twist);\n    v = abs(v)/radius;\n    f = (pow(dot(v,pow(v,vec3(power-1.))),1./power)-1.)*radius;\n    return min( f, margin ); // don't return values > margin otherwise we'll overshoot in next cell!\n}\n\nfloat Baubles1( vec3 pos ) { return BaublesSDF( pos, 0x1002U, .8, .08, 2.1, -150. ); }\nfloat Baubles2( vec3 pos ) { return BaublesSDF( pos, 0x2037U, 1., .08, 1.2, -45. ); }\nfloat Baubles3( vec3 pos ) { return BaublesSDF( pos, 0x3003U, .8, .08, 1.8, 50. ); }\n\nfloat Ground( vec3 pos )\n{\n    return length(pos-vec3(0,-2,0))-2.-1.7 + .003*textureLod(iChannel2,pos.xz*5.,0.).x - .04*textureLod(iChannel2,pos.xz*.4,0.).x;\n}\n\nfloat SDF( vec3 pos )\n{\n    return min(min(min(min(\n        \tTreeSDF(pos),\n        \tBaubles1(pos)),\n        \tBaubles2(pos)),\n        \tBaubles3(pos)),\n        \tGround(pos));\n}\n\n\n// assign a material index to each of the SDFs\n// return whichever one we're closest to at this point in space\nint GetMat( vec3 pos )\n{\n    struct MatDist { int mat; float dist; };\n    MatDist mats[] = MatDist[](\n        \tMatDist( 0, TreeSDF(pos) ),\n        \tMatDist( 1, Baubles1(pos) ),\n        \tMatDist( 2, Baubles2(pos) ),\n        \tMatDist( 3, Baubles3(pos) ),\n        \tMatDist( 4, Ground(pos) )\n        );\n    \n    MatDist mat = mats[0];\n    for ( int i=1; i < mats.length(); i++ )\n    {\n        if ( mats[i].dist < mat.dist ) mat = mats[i];\n    }\n    \n    return mat.mat;\n}\n\n\nfloat epsilon = .0004; // todo: compute from t everywhere it's used (see \"size of pixel\"\\/\\/)\nint loopCount = 400; // because of the early out this can actually be pretty high without costing much\n\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far, out int count )\n{\n\tfloat t = epsilon;\n    for ( int i=0; i < loopCount; i++ )\n    {\n        float h = SDF(rayDirection*t+rayStart);\n        t += h;\n        if ( t > far || h < epsilon ) // *t )\n            return t;\n    }\n    \n    return t;\n}\n\n// Trace the tree in 3D space\n// @returns color in .xyz and hit distance in .w\nvec4 trace_tree(vec3 camPos, vec3 ray, float far) {\n    int count = 0;\n    float t = Trace( camPos, ray, far, count );\n    if(t >= far) return vec4(0,0,0,NOHIT);\n    \n    vec3 pos = camPos + t*ray;\n    vec3 uvw = pos;\n    int matIdx = GetMat(uvw);\n\n    vec2 d = vec2(-1,1) * t / iResolution.y;\n    vec3 normal = normalize(\n            SDF(pos+d.xxx)*d.xxx +\n            SDF(pos+d.xyy)*d.xyy +\n            SDF(pos+d.yxy)*d.yxy +\n            SDF(pos+d.yyx)*d.yyx\n        );\n    \n    struct Material\n    {\n        vec3 albedo;\n        vec3 subsurfaceColour;\n        float metallicity;\n        float roughness; // blurriness of the metallicity\n    };\n        \n    Material mat = Material[](\n        Material( vec3(0/*overridden*/), vec3(0/*overridden*/), 0., 0. ), // tree\n        Material( vec3(1,.7,.5), vec3(0), .5, .7 ),\n        Material( vec3(1,.4,.1), vec3(0), 1., .0 ),\n        Material( vec3(1,.1,.15), vec3(0), 1., .4 ),\n        Material( vec3(.9)*smoothstep(-.8,1.5,TreeBoundsSDF(uvw)), vec3(.2), .0, .05 ) // not getting enough shine on the snow so make it metallic\n    )[matIdx]; // is this bad? I kind of like it!\n\n    if ( matIdx == 3 )\n    {\n        // glitter bauble / snow\n        normal += .4*(hash3(coord3(uvec3(pos/.002 + 65536.)))-.5);\n        normal = normalize(normal);\n    }\n    \n    vec3 refl = reflect( ray, normal );\n    \n    // very broad AO - just use the tree's bound SDF\n    float AO = exp2(min(0.,TreeBoundsSDF(uvw)-.3)/.3);\n    \n    TreeSpace ts = GetTreeSpace(uvw);\n    if ( matIdx == 0 )\n    {\n        // compute tree albedo           \n        float leafness = smoothstep(.0,.05, ts.needle.z) // // gradient along needle\n                        * smoothstep(.01,.04, length(ts.branch.xy))\n                        * smoothstep(.03,.06, length(uvw.xz));\n        \n        // blend wood to leaf colour\n        mat.albedo = mix( vec3(.05,.025,.01), vec3(0,.3,0), leafness );\n        mat.subsurfaceColour = mix( vec3(0), vec3(.04,.5,0), leafness );\n        \n        // snow\n        float snow = textureLod(iChannel2,pos.xz/.02,log2(t/iResolution.x)+13.).r;\n        snow = smoothstep(.1,.5,normal.y*.1+snow-.3*(1.-AO));\n        mat.albedo = mix( mat.albedo, vec3(1), snow );\n        mat.subsurfaceColour = mix( mat.subsurfaceColour, vec3(.1), snow );\n        \n        // and use the same things to paint the albedo trunk/branch colours\n        mat.roughness = .7;\n    }\n        \n    // fake reflection of the tree\n    // I can probably afford a reflection trace - but I want to blur it based on roughness\n    float SO = smoothstep(-1.,1.,(TreeBoundsSDF(uvw + refl*1.)\n                                        -1.*(texture(iChannel2,refl.yz*2.,0.).r*2.-.7)*pow(1.-mat.roughness,5.)\n                                    +.4)/(1.*(mat.roughness+.3))\n                            );\n    \n    vec3 diffuseLight = background_diffuse(normal.xyz);\n    \n    // sub surface scattering\n    vec3 subsurfaceSample = background_diffuse(-normal.xyz);\n    diffuseLight += mat.subsurfaceColour * subsurfaceSample.rgb;\n    \n    diffuseLight *= AO;\n    \n    vec3 specularLight = mix(4.,9.,mat.roughness) * background_hdr(refl);\n    specularLight = mix( vec3(.01,.02,.0)+.0, specularLight, SO ); // blend to a rough tree colour\n    \n    float fresnel = pow(1.-abs(dot(ray,normal)),5.);\n    \n    return vec4(\n        mix(\n            mix ( mat.albedo, vec3(1.), mat.metallicity*(1.-mat.roughness)*fresnel ) *\n            mat.albedo *\n            mix(\n                diffuseLight,\n                specularLight,\n                mat.metallicity\n            ),\n            specularLight,\n            mix( .02, 1., fresnel )*(1.-mat.roughness)\n        ), \n        t);\n}\n\n\n//-------------------------------------------------------------------------------\n\n// Look from origin \"o\" to target point \"p\" with up vector \"up\"\nmat4 lookat(in vec3 o, in vec3 p, in vec3 up, float rotate)\n{\n    vec3 delta = p - o;\n    up = vec3(sin(rotate), cos(rotate), 0.0); // TODO: overwrites actual up, if not (0,1,0)..\n    vec3 z = normalize(delta); // the direction to look at (Z-axis)\n    vec3 x = normalize(cross(z, up)); // -> to-right direction (X-axis)\n    vec3 y = normalize(cross(x, z)); // -> to-up direction (Y-axis)\n    return mat4(\n        vec4(x.xyz, -dot(o,x)),\n        vec4(y.xyz, -dot(o,y)),\n        vec4(z.xyz, -dot(o,z)),\n        vec4(0,0,0, 1));\n}\n\n// Transform a 3D direction vector by a 4x4 matrix\nvec3 transform_dir(vec3 dir, mat4 m) {\n    return (m * vec4(dir, 0.0)).xyz;\n}\n\n// Find an intersection between ray ro+t*rd, where t=[0, <NOHIT]\n// and a sphere located at \"p\" with radius \"r\".\n//\n// If hits, returns \"t\", otherwise NOHIT.\nfloat isect_ray_sphere(in vec3 ro, in vec3 rd, in vec3 p, in float r) {\n    vec3 oc = ro - p;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r*r;\n    float t = b*b - c;\n    float t2 = (t > 0.0) ? -b - sqrt(t) : NOHIT;\n    return (t2 > 0.0) ? t2 : NOHIT;\n}\n\n// Find an intersection between ray ro+t*rd, where t=[0, <NOHIT]\n// and a plane going through point \"p\" with normal \"n\".\n//\n// If hits, returns t >= 0.0, otherwise NOHIT.\nfloat isect_ray_plane(in vec3 ro, in vec3 rd, in vec3 p, in vec3 n) {\n    \n    float denom = dot(rd, -n);\n    return (denom > 0.0) ? -dot(p - ro, n) / denom : NOHIT;\n}\n\n// Find an intersection between ray ro+t*d and a cone\nfloat isect_ray_cone(in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra, float rb) {\n    vec4 v = iCappedCone(ro, rd, pa, pb, ra, rb);\n    if(v.x < 0.0) v.x = NOHIT;\n    return v.x;\n}\n\n//-------------------------------------------------------------------------------\n\n// Animate sphere positions\nvec3 sphere_center(int n) {\n    // snowman!\n    const float speed = 0.0; //0.1;\n    const float phase = 0.0;\n    float r = sphere_radius[n];\n    vec3 p;\n    p.x = sin(phase + speed*iTime)*sphere_dist;\n    p.z = cos(phase + speed*iTime)*sphere_dist;\n    p.y = plane_alt + sphere_alt[n];\n\n/*\n    // and.. bounce!\n    float ifreq = 2.*PI;\n    float dur = 0.75*4.;\n    float t = (mod(iTime, ifreq) - (ifreq-dur)) / dur; // [0,1] if bouncing\n    if(t >= 0.0) p.y += abs(sin(t*PI)*jump_altitude); // jump!\n*/\n    return p;\n}\n\n//-------------------------------------------------------------------------------\n\n// Returns \"t\" if hits something, otherwise NOHIT\nfloat hit(in vec3 ro, in vec3 rd, out vec3 hitp, out vec3 hitn, out int id) {\n    // scene: 3 spheres + plane\n    vec3 scenter1 = sphere_center(0);\n    vec3 scenter2 = sphere_center(1);\n    vec3 scenter3 = sphere_center(2);\n    vec3 carrotce = scenter3 + vec3(0, 0, -0.3);\n\n    float sphe1_t = isect_ray_sphere(ro, rd, scenter1, sphere_radius[0]);\n    float sphe2_t = isect_ray_sphere(ro, rd, scenter2, sphere_radius[1]);\n    float sphe3_t = isect_ray_sphere(ro, rd, scenter3, sphere_radius[2]);\n    float plane_t = isect_ray_plane(ro, rd, vec3(0,plane_alt,0), planen);\n    float carro_t = isect_ray_cone(ro, rd, scenter3, carrotce, 0.05, 0.01);\n    \n    float t = min(sphe1_t, min(sphe2_t, min(sphe3_t, min(plane_t, carro_t)))); // closest hit or NOHIT\n    hitp = ro + t*rd; // world hit point\n\n    // object id + world hit normal\n    if( t == NOHIT   ) { id = ID_NONE;     hitn = -rd; } else\n    if( t == sphe1_t ) { id = ID_SPHERE01; hitn = normalize(hitp - scenter1); } else\n    if( t == sphe2_t ) { id = ID_SPHERE02; hitn = normalize(hitp - scenter2); } else\n    if( t == sphe3_t ) { id = ID_SPHERE03; hitn = normalize(hitp - scenter3); } else\n    if( t == plane_t ) { id = ID_PLANE;    hitn = planen; } else\n    if( t == carro_t ) { id = ID_CARROTCONE; hitn = normalize(hitp - carrotce); } // TODO\n\n    // add some epsilon to position to compensate floating point inaccuracies\n    hitp += EPSILON*hitn;\n    return t;\n}\n\n// TODO:\nvec3 trace2(in vec3 ro, in vec3 rd) {\n    const int maxdepth = 3;\n    uint rs = uint(rd.x + rd.y + rd.z); // TODO: better seed?\n    for(int depth=0; depth < maxdepth; ++depth) {\n        int id;\n        vec3 hitp; // world position of hit point\n        vec3 hitn; // world normal of hit point\n        float t = hit(ro, rd, hitp, hitn, id); // sets \"hitp\", \"hitn\", \"id\"\n\n        switch(id) {\n            case ID_SPHERE01:\n            case ID_SPHERE02:\n            case ID_SPHERE03: {\n                // hits a sphere - 100% reflective, so continue path to reflection direction\n                vec3 reflection = normalize(reflect(rd, hitn)); // reflect the ray around sphere normal\n                ro = hitp;\n                rd = reflection;\n                break;\n            }\n            default:\n                // misses scene objects -> background, terminate path\n                return background_hdr(rd);\n        }\n    }\n}\n\n// return 0.0, if occluded to direction, otherwise 1.0\nfloat occlusion(in vec3 ro, in vec3 rd) {\n    vec3 unused_p; vec3 unused_n; int unused_id;\n    float hitt = hit(ro, rd, unused_p, unused_n, unused_id); // 1.0 if unblocked\n    return (hitt < NOHIT) ? 0.0 : 1.0; // TODO: distance mix?\n}\n\n// sample hemisphere for irradiance\nvec3 hemilighting(in vec3 hitp, in vec3 hitn) {\n    vec3 hemidir = random_hemisphere_dir(hitn); // world space                  \n    float occlusion = occlusion(hitp, hemidir); // check if hits something\n    vec3 irradiance = occlusion * background_diffuse(hemidir);\n    return irradiance;\n}\n\n// mix\nvec3 mixsum(in vec4 sum, in vec3 c) {\n    return sum.xyz + c.xyz*(1.0 - sum.w);\n}\n\n// path tracing\nvec3 trace(in vec3 ro, in vec3 rd) {\n    const int maxdepth = 3;\n    vec4 sum = vec4(0);\n    for(int depth=0; depth < maxdepth; ++depth) {\n        int id;\n        vec3 hitp; // world position of hit point\n        vec3 hitn; // world normal of hit point\n        float t = hit(ro, rd, hitp, hitn, id); // sets \"hitp\", \"hitn\", \"id\"\n\n        vec4 tree = trace_tree(ro, rd, 10.0); // the christmas tree\n        if( tree.w < t ) {\n            return mixsum(sum, tree.xyz);\n        }\n\n        switch(id) {\n            case ID_SPHERE01:\n            case ID_SPHERE02:\n            case ID_SPHERE03: {\n                // hits a sphere - semi-reflective, so continue path to reflection direction\n                vec4 snow = gen_snow(ro, rd, hitp, hitn); // note: changes hitn\n                sum.xyz += snow.rgb * hemilighting(hitp, hitn) * vec3(10.0);\n                sum.w += 1.0 - snow.w;\n\n                vec3 reflection = normalize(reflect(rd, hitn));\n                ro = hitp;\n                rd = reflection;\n                \n                break;\n            }\n            case ID_CARROTCONE: {\n                // Emissive Snowman Carrot!\n                vec3 emissive = 0.01*LDR_to_HDR(vec3(179.0/255.0, 95.0/255.0, 28.0/255.0));\n                return emissive;\n            }\n            default:\n                // make up circular floor plane area\n                if( id == ID_PLANE && length(hitp) < plane_radius ) { \n                    vec3 irradiance = hemilighting(hitp, hitn) * vec3(10.0);\n                    vec3 tex = planeground(ro, rd, hitp, hitn); // note: changes hitn\n                    vec3 pc = irradiance * tex;\n                    //return mixsum(sum, mix(pc, background_hdr(rd), min(1., t/FADE_DIST)));\n                    return mixsum(sum, fog(rd, pc));\n                } else { \n                    // misses scene objects -> background, terminate path\n                    return mixsum(sum, background_hdr(rd));\n                }\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y; // initialize random seed\n    vec2 rotation = vec2(iMouse.x/iResolution.x, 0.0); // Mouse [0,1]\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y; // Pixel coordinates y=[-1,1], x=[-1*aspect,1*aspect] where aspect=width/height\n    \n    float look_mix = 0.5 + 0.5*sin(0.1*iTime);\n    vec3 look_to = mix(sphere_center(0), camera_look_at_tree, look_mix); // TODO\n    \n    if(iMouse.z <= 0.0) rotation.x = sin(0.02*iTime*0.6);\n    vec3 ro = vec3(sin(-rotation.x*TWO_PI)*camera_distance, camera_alt, cos(-rotation.x*TWO_PI)*camera_distance); // Mouse rotation around the sphere -> ray origin (camera position)  \n    mat4 m = lookat(ro, look_to, vec3(0,1,0), 0.07*cos(0.25*iTime)); // Camera->World transformation matrix\n\n    // simple over-the-top adhoc DOF, TODO: better one\n    float dofi = 135.0/iResolution.y;\n    float dofa = rnd() * TWO_PI;\n    float dofr = rnd() * dofi;\n    ro += (m * vec4(cos(dofa)*dofr, sin(dofa)*dofr, 0.0, 1.0)).xyz;\n    m = lookat(ro, look_to, vec3(0,1,0), 0.07*cos(0.25*iTime));\n\n    vec3 ldir = normalize(vec3(p, 1.0)); // Local ray direction (Camera Space)\n    vec3 rd = transform_dir(ldir, m); // -> World Space\n    \n\n    // trace multiple samples per pixel, average\n    vec3 c = vec3(0);\n    for(int i=0; i < NUM_SAMPLES; ++i) {\n        vec2 jitter;\n        jitter.x = 1.5/iResolution.x * rnd();\n        jitter.y = 1.5/iResolution.y * rnd();\n        vec3 offset = (m * vec4(jitter.x, jitter.y, 0.0, 1.0)).xyz;\n        \n        vec3 s = trace(ro + offset, rd);\n        c += s;\n    }\n    c /= float(NUM_SAMPLES);\n    c = pow(c, vec3(0.5)); // some curve.. TODO:\n    c.rgb *= EXPOSURE;\n    c.rgb = HDR_to_LDR( c.rgb );\n\n    // snow effect on top\n    c += snowing_layer_2d(fragCoord);\n    \n    // vignette and like\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    c *= 0.5 + 0.5*pow(abs(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y)), 0.20);\n \n    // TODO: temporal AA\n   \n    c = 1.0 - exp(-c*3.0);\n     \n    fragColor = vec4(c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}