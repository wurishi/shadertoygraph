{"ver":"0.1","info":{"id":"7dcBDj","date":"1657199878","viewed":186,"name":"example: using rodrigues vectors","username":"jt","description":"Implementation of using rodrigues vectors to combine rotations, for comparison with quaternion rotation.\nRequires only 3 floats to represent rotations.\nWarning: if dot(g, f) == 1 a division by zero occurs when combining g, f rotations. Can this be fixed?\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["vector","rotation","formula","rodrigues","rodriguesvector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/7dcBDj\n// example: using rodrigues vectors (2022 by jt)\n// Implementation of using rodrigues vectors to combine rotations (for comparison with quaternion rotation).\n// NOTE: Rotations by pi are represented by rodrigues vectors of infinite length!\n// Warning: if dot(g, f) == 1 a division by zero occurs when combining g, f rotations. Can this be fixed?\n// Otherwise very elegant, requires only three floats to represent rotations (quaternions require four floats).\n\n// Variants:\n// https://www.shadertoy.com/view/fdtfWM example: using quaternions\n// https://www.shadertoy.com/view/fsdBDM example: using dual quaternions\n\n// tags: vector, rotation, formula, rodrigues, rodriguesvector\n\n// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions#Rodrigues_vector\nvec3 angle_axis(float phi, vec3 axis)\n{\n    return tan(phi / 2.0) * normalize(axis); // NOTE: normalize can be omitted if using only unit vectors\n}\n\nvec3 extract_axis(vec3 r)\n{\n    return normalize(r);\n}\n\nfloat extract_angle(vec3 r)\n{\n    return atan(length(r)) * 2.0;\n}\n\n// Warning: if dot(g, f) == 1 a division by zero occurs - can this be fixed?\nvec3 combine_rotations(vec3 g, vec3 f) // NOTE: parameter order chosen to be similar to matrix multiplication\n{\n    return (g + f - cross(f, g)) / (1.0 - dot(g, f));\n}\n\nvec3 rotate(vec3 r, vec3 p) // rotation of point by rodrigues-vector can be derived via https://en.wikipedia.org/wiki/Euler-Rodrigues_formula\n{\n    // extract axis & angle\n    //float ll = dot(r, r);\n    //float l = sqrt(ll);\n    //vec3 axis = r / l;\n    //float angle = atan(l);\n    // apply Euler-Rodrigues Formula\n    //float c = cos(angle);\n    //float s = sin(angle);\n    // cancel-out trigonometric functions:\n    // apply https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions\n    //float c = 1.0 / sqrt(l*l + 1.0);\n    //float s = l / sqrt(l*l + 1.0);\n    \n    //return p + 2.0 * c * cross(axis*s, p) + 2.0 * cross(axis*s, cross(axis*s, p)); // Euler-Rodrigues Formula\n    //return p + 2.0 * c * s * cross(axis, p) + 2.0 * s * s * cross(axis, cross(axis, p));\n    //return p + 2.0 * cross(axis, p) / (l * l + 1.0) * l + 2.0 * cross(axis, cross(axis, p)) * l * l / (l * l + 1.0);\n    //return p + 2.0 * cross(r, p) / (ll + 1.0) + 2.0 * cross(r, cross(r, p)) / (ll + 1.0);\n    //return p + 2.0 * (cross(r, p) + cross(r, cross(r, p))) / (ll + 1.0);\n    return p + 2.0 * (cross(r, p) + cross(r, cross(r, p))) / (dot(r, r) + 1.0); // NOTE: very similar to the original Euler-Rodrigues Formula, only insteal of scaling just the first cross product with c both cross products are divided by (r*r+1) \n    \n    // apply vector triple product\n    // a x (b x c) = b(c*a) - c(a*b)\n    // r x (r x p) = r(p*r) - p(r*r)\n    \n    //return p + 2.0 * (cross(r, p) + r * dot(p, r) - p * dot(r, r)) / (dot(r, r) + 1.0); // alternative - can this be simplified?\n}\n\n/*\nvec3 rotate(vec3 r, vec3 p) // XXX this approach is unstable (e.g. first frame of animation empty, probably due to division by zero XXX\n{\n    // extract axis & angle\n    float l = length(r);\n    vec3 axis = r / l;\n    //float angle = atan(l) * 2.0;\n    // apply Rodrigues Rotation Formula\n    //float c = cos(angle);\n    //float s = sin(angle);\n    // cancel-out trigonometric functions:\n    // apply https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions\n    // and https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Multiple-angle_formulae\n    float c = (1.0 - l * l) / (l * l + 1.0);\n    float s = 2.0 * l / (l * l + 1.0);\n\n    return c * p + s * cross(axis, p) + (1.0 - c) * (dot(p, axis) * axis); // Rodrigues' Rotation Formula\n}\n*/\n/*\n// Rodrigues' Rotation Formula: can be used to rotate a point around an axis. However to combine rotations use rodrigues vectors!\nvec3 rotate(float angle, vec3 axis, vec3 point) // NOTE: axis must be unit!\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return c * point + s * cross(axis, point) + (1.0 - c) * (dot(point, axis) * axis); // Rodrigues' Rotation Formula\n}\n*/\nmat4 make_proj_mat(float focal_length)\n{\n    return\n        mat4\n        (\n            vec4(focal_length, 0.0, 0.0, 0.0),\n            vec4(0.0, focal_length, 0.0, 0.0),\n            vec4(0.0, 0.0, 0.0, 1.0),\n            vec4(0.0, 0.0, 0.0, 0.0)\n        );\n}\n\n\n#define pi 3.1415926\n\nvec2 project(mat4 projection, vec3 v)\n{\n    vec4 w = projection * vec4(v, 1.0);\n    return vec2(w) / w.w;\n}\n\nvec3 yaw_pitch_roll(float Yaw, float Pitch, float Roll)\n{\n    return\n        combine_rotations\n        (\n            angle_axis(Pitch, vec3(1,0,0)),\n            combine_rotations\n            (\n                angle_axis(Yaw, vec3(0,1,0)),\n                angle_axis(Roll, vec3(0,0,1))\n            )\n        );\n}\n\nvec3 get_camera_rotation()\n{\n    float Pitch = 0.05 * 2.0 * pi * iTime;\n    float Yaw = 0.2 * 2.0 * pi * iTime;\n    float Roll = 0.3 * 2.0 * pi * iTime;\n\n    return yaw_pitch_roll(Yaw, Pitch, Roll);\n}\n\nvec3 get_camera_position()\n{\n    return vec3(0.5 * cos(0.3 * 2.0 * pi * iTime), 0.5 * sin(0.2 * 2.0 * pi * iTime), 1.0);\n}\n\nfloat draw_line(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\nfloat draw_quad(vec2 A, vec2 B, vec2 C, vec2 D, vec2 p)\n{\n    return min(min(draw_line(A, B, p), draw_line(B, C, p)), min(draw_line(C, D, p), draw_line(D, A, p)));\n}\n\nfloat draw_cube(mat4 projection, vec3 camera_rotation, vec3 camera_translation, vec3 cube_position, float cube_size, vec2 p)\n{\n    vec3 v000 = cube_position + vec3(-1,-1,-1) * cube_size;\n    vec3 v001 = cube_position + vec3(-1,-1,+1) * cube_size;\n    vec3 v010 = cube_position + vec3(-1,+1,-1) * cube_size;\n    vec3 v011 = cube_position + vec3(-1,+1,+1) * cube_size;\n    vec3 v100 = cube_position + vec3(+1,-1,-1) * cube_size;\n    vec3 v101 = cube_position + vec3(+1,-1,+1) * cube_size;\n    vec3 v110 = cube_position + vec3(+1,+1,-1) * cube_size;\n    vec3 v111 = cube_position + vec3(+1,+1,+1) * cube_size;\n\n    vec2 V000 = project(projection, rotate(camera_rotation, v000) + camera_translation);\n    vec2 V001 = project(projection, rotate(camera_rotation, v001) + camera_translation);\n    vec2 V010 = project(projection, rotate(camera_rotation, v010) + camera_translation);\n    vec2 V011 = project(projection, rotate(camera_rotation, v011) + camera_translation);\n    vec2 V100 = project(projection, rotate(camera_rotation, v100) + camera_translation);\n    vec2 V101 = project(projection, rotate(camera_rotation, v101) + camera_translation);\n    vec2 V110 = project(projection, rotate(camera_rotation, v110) + camera_translation);\n    vec2 V111 = project(projection, rotate(camera_rotation, v111) + camera_translation);\n\n    return\n        min\n        (\n            min\n            (\n                draw_quad(V000, V001, V011, V010, p),\n                draw_quad(V100, V101, V111, V110, p)\n            ),\n            min\n            (\n                min(draw_line(V000, V100, p), draw_line(V001, V101, p)),\n                min(draw_line(V011, V111, p), draw_line(V010, V110, p))\n            )\n        );\n    /*\n    return\n        min\n        (\n            min\n            (\n                min(spot(0.02, V000, p), spot(0.02, V001, p)),\n                min(spot(0.02, V010, p), spot(0.02, V011, p))\n            ),\n            min\n            (\n                min(spot(0.02, V100, p), spot(0.02, V101, p)),\n                min(spot(0.02, V110, p), spot(0.02, V111, p))\n            )\n        );\n        */\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 projection = make_proj_mat(1.0/*focal length*/);\n    //mat4 projection = make_proj_mat(1.0 + 0.5 * cos(iTime)/*focal length*/);\n    //o = projection * view * model * i\n\n    vec3 camera_rotation = get_camera_rotation();\n    vec3 camera_position = get_camera_position();\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float o = 1.0;\n    o = min(o, draw_cube(projection, camera_rotation, camera_position, vec3(0,0,0)/*cube_position*/, 0.25/*cube_size*/, p));\n\n    vec3 col = vec3(0.0);\n    //col = max(col, mix(vec3(1.0), vec3(0.0), smoothstep(0.00, 0.01, o)));\n    col = max(col, mix(vec3(1.0), vec3(0.0), smoothstep(0.00, 5./iResolution.y, o)));\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}