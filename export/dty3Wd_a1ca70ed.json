{"ver":"0.1","info":{"id":"dty3Wd","date":"1684861143","viewed":70,"name":"Noisy Polies","username":"gee8sh","description":"Just a hybrid between two of my other shaders: Noisy Contours & Second Degree Polies ... I was just curious to what the result would look like.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","raycasting","polynomials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = atan(0.0, -1.0);\n\nconst vec3 color = vec3(0.2, 0.4, 0.8);\n\n// Observer params\nconst float focalLength = 2.0;\nconst float distanceToPoly = 8.0;\n\n// Sun params\nconst vec3 sunDirection = normalize(vec3(1.0, 1.0, 2.0));\nconst float sunDistance = 128.0;\n\nconst float animationSpeed = 1.0 / 64.0;\n\n// Noise scaling\nconst uint depth = 8u;\nconst float spaceScale = sqrt(2.0);\nconst float noiseScale = 1.0 / spaceScale;\nconst float scale = \n    (1.0 - noiseScale) / \n    (1.0 - pow(noiseScale, float(depth) + 1.0));\n\n// Noise matrix\nconst vec3 i = normalize(vec3(1.0, 2.0, 3.0));\nconst vec3 k = normalize(cross(i, i.zxy));\nconst vec3 j = normalize(cross(k, i));\nconst mat3 matrix = mat3(i, j, k);\n\n// Noise displacement\nvec3 displacement = vec3(0.6, 0.5, 0.4);\n\n// Poly\nconst mat3 A0 = mat3(\n    vec3( 3.0,  5.0,  7.0),\n    vec3(11.0, 13.0, 17.0),\n    vec3(19.0, 23.0, 29.0)\n);\nconst vec3 B0 = vec3(1.0, 2.0, 4.0); \nconst float C = 3.0;\n\nconst mat3 diag = 0.5 * PI * mat3(\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0)\n);\n\n// Precalculated values\nconst vec3 orig = vec3(0.0, 0.0, distanceToPoly);\nconst float distanceToPolySquared = distanceToPoly * distanceToPoly;\n\nfloat base(in vec3 v) {\n    vec3 alias = 2.0 * fract(0.5 * v) - 1.0;\n    vec3 a = abs(alias);\n    vec3 s = smoothstep(0.0, 1.0, a);\n    return s.x * s.y * s.z;\n}\n\nfloat noise(in vec3 pos) {\n    vec3 v = pos;\n    mat3 m = matrix;\n    float s = noiseScale;\n    float result = base(v);\n    for (uint i = 1u; i < depth; i++) {\n        v = spaceScale * matrix * v + displacement;\n        float r = base(v);\n        result += s * r;\n        m *= matrix;\n        s *= noiseScale;\n    }\n    return result * scale;\n}\n\nfloat sampleNoise(in vec3 v) {\n    float n = noise(v * 0.125);\n    return pow(2.0 * abs(fract(n * 16.0) - 0.5), 0.125);\n}\n\nvec4 shootPoly(in vec3 ray, in mat3 A, in mat3 A2, in vec3 B) {\n    float a = dot(ray, A * ray);\n    float b = dot(ray, A2 * orig + B);\n    float c = dot(orig, A * orig) + dot(orig, B) - C;\n    float halfB = 0.5 * b;\n    float hitDistance = 0.0;\n    if (a != 0.0) {\n        float delta = abs(halfB * halfB - a * c);\n        float sqrtD = sqrt(delta);\n        float d1 = (-halfB - sqrtD) / a;\n        float d2 = (-halfB + sqrtD) / a;\n        hitDistance = d1 <= d2\n            ? (d1 >= 0.0 ? d1 : d2) \n            : (d2 >= 0.0 ? d2 : d1);\n    } else if (halfB != 0.0) {\n        hitDistance = -c / b;\n    }\n    return vec4(hitDistance * ray + orig, hitDistance > 0.0 ? 1.0 : 0.0);\n}\n\nvec4 calcNormal(in vec4 hitPosition, in vec3 ray, in mat3 A2, in vec3 B) {\n    vec3 n = normalize(A2 * hitPosition.xyz + B);\n    float f = -dot(n, ray);\n    return vec4(n * sign(f), f);\n}\n\nvec3 calcColor(in vec3 ray, in vec3 normal, float f) {\n    vec3 c = (f > 0.0 ? color : color.bgr); \n    return c + 2.0 * pow(max(dot(reflect(ray, normal), sunDirection), 0.0), sunDistance);\n}\n\nfloat calcShade(vec3 normal, float hit) {\n    float l = dot(normal, sunDirection);\n    return hit * max(l, 0.0);\n}\n\nvec4 sampleColor(in vec2 xy, in mat3 A, in mat3 A2, in vec3 B) {\n    vec3 ray = normalize(vec3(xy, -focalLength));\n    vec4 hitPosition = shootPoly(ray, A, A2, B);\n    vec4 n = calcNormal(hitPosition, ray, A2, B);\n    vec3 normal = n.xyz;\n    float f = n.w;\n    vec3 color = calcColor(ray, normal, f);\n    float shade1 = calcShade(normal, hitPosition.w);\n    float shade2 = sampleNoise(hitPosition.xyz);\n    return vec4(shade1 * shade2 * color, 1.0);\n    //return vec4(normal, 1.0);\n}\n\nvec2 pixelCoordinates(in vec2 fragCoord, in float halfPixelSize) {\n    float aspect = iResolution.x * halfPixelSize;\n    return 2.0 * halfPixelSize * fragCoord - vec2(aspect, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float halfPixelSize = 1.0 / iResolution.y;\n\n    vec2 xy = pixelCoordinates(fragCoord, halfPixelSize);\n    \n    float time = iTime * animationSpeed;\n    \n    mat3 A = mat3(\n        sin(A0[0] * time + diag[0]),\n        sin(A0[1] * time + diag[1]),\n        sin(A0[2] * time + diag[2])\n    );\n    mat3 AT = transpose(A); \n    mat3 A2 = A + AT; \n    vec3 B = sin(B0 * time);\n    \n    fragColor = sqrt(0.25 * (\n        sampleColor(xy, A, A2, B) + \n        sampleColor(xy + vec2(halfPixelSize, 0.0), A, A2, B) + \n        sampleColor(xy + vec2(0.0, halfPixelSize), A, A2, B) + \n        sampleColor(xy + vec2(halfPixelSize), A, A2, B)\n    ));\n}\n\n","name":"Image","description":"","type":"image"}]}