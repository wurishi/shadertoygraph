{"ver":"0.1","info":{"id":"7tSfRm","date":"1651923421","viewed":173,"name":"Geodesic Wrap","username":"kastorp","description":"faces=20*N*N where N=tessellation factor ","likes":23,"published":1,"flags":32,"usePreview":0,"tags":["icosahedron","wrap"],"hasliked":0,"parentid":"3lVyRy","parentname":"Icosahedron wrap"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Geodesic Mesh by Kastorp\n\nconst float N=6.; //tesselation factor\n           \nbool tesselate(in float i,in float N,out vec2 p1,out vec2 p2,out vec2 p3)\n{\n        float y= floor(sqrt(i)),x=(i-y*y)*.5, iN=1./N;\n        bool inv=mod(x,1.)>.4;        \n        p1 = vec2(x,N-y)*iN  + (inv?vec2(.5*iN,0):vec2(0));\n        p2 = p1 +vec2(iN,-iN) - (inv?vec2(iN,0):vec2(0));\n        p3 = inv?p1-vec2(iN,0):  p1-vec2(0,iN);\n        return inv;\n}\n\n#define ds(i,k) texelFetch(iChannel0,ivec2(k,i),0).xyz\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n        //float tm= (1. + sin(iTime))/2.;\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        mat3 rot = mat3(1,0,0,0,cos(iTime*.1),-sin(iTime*.1),0,sin(iTime*.1),cos(iTime*.1));\n        vec3 ro = vec3(0.0, 0.0, 10.0 -6.*tm)*rot;\n        vec3 rd = normalize( vec3(p,-4.0) )*rot;\n       \n        vec3 col = (vec3(0.08) + 0.02*rd.y)*(1.0-0.3*length(p));\n\n        float tmin = 1e10;\n        for(int f = 0;f<20;f++)         \n        {\n           //icosaedron face\n           int i= f/4,f0=f%4, j=f0==3?-1:f0/2,m=f0&1, k =i*3+j+1;\n           vec3 d0=(m==0)?ds(0,k):ds(3,k) ,d1=ds(1,k),d2=ds(2,k);\n            \n            //BVH\n            vec3 dmin= min(min(d0,d1),d2), dmax= max(max(d0,d1),d2),\n                bc=(dmin+dmax)/2.,bs=(dmax-dmin)/2.+.15;\n            if(boxIntersection(ro-bc,rd,bs).x<0.) continue;\n            \n            //tesselation\n           for(float f1=0.;f1<N*N;f1++){\n               vec2 p1,p2,p3; // relative coords\n                bool inv = tesselate(f1,N, p1,p2,p3);\n                \n                //absolute coords\n                vec3 c0=(d0* p1.x+d1*p1.y +d2*(1.-p1.x-p1.y)),\n                     c1=(d0* p2.x+d1*p2.y +d2*(1.-p2.x-p2.y)),\n                     c2=(d0* p3.x+d1*p3.y +d2*(1.-p3.x-p3.y));\n                     \n               if(tm>0.5)\n               {\n                    //flat --> spherical\n                    c0*=mix(1.,.75/length(c0),tm*2.-1.); \n                    c1*=mix(1.,.75/length(c1),tm*2.-1.);\n                    c2*=mix(1.,.75/length(c2),tm*2.-1.); \n               }\n               \n               vec3 res = triIntersect( ro, rd,c0,c1,c2);\n               float t2 = res.x;\n               if( t2>0.0 && t2<tmin )\n               {\n                    tmin = t2;\n                    float t = t2;\n                    vec3 pos = ro + t*rd;\n                    vec3 nor = normalize( cross( c2-c1, c0-c1 ) );\n                    float bo=smoothstep(0.02,.08,min(min(res.y,res.z),1.-res.y-res.z));\n                    col =mix(vec3(0.7,0.1,0.1), vec3(1.000,0.9,0.7),bo )*(0.55 + 0.45*faceforward(-nor, -rd, nor).y);\n               }\n               \n           }\n    }\n        \n\tO = vec4( sqrt(col), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//same as https://www.shadertoy.com/view/3lVyRy\nvoid mainImage(out vec4 Q, in vec2 U) {\n    ivec2 uv = ivec2(U);\n    if(uv.x>14 || uv.y>4 ) discard;\n    \n    vec3 ds[60];\n    float rot=.731*min(1.,tm*2.);\n \n     const mat3 t = mat3(1.,.5,0,0.,.866,0,0,0,1);\n    vec3 orig= vec3(-.5,-.433,.75);//approximated https://www.fxsolver.com/browse/formulas/Regular+Icosahedron++%28+inscribed+sphere+radius%29\n\n    for(int i = 0;i<=4;i++) for(int j0=0;j0<=2;j0++) \n    {\n     \n       int j= j0 <2?j0:-1, k =i*3+j+1;\n \n       if(j==0){//if  from below (ds1,ds3)\n            ds[k*4]= i==0 ? orig: ds[1+(k-3)*4];\n            ds[k*4+2]= i==0 ? orig+vec3(0.,1.,0.)*t: ds[(k-3)*4+3];\n            ds[k*4+1]= i==0 ? orig+vec3(1.,0.,0.)*t: ds[k*4] + erot(ds[2+(k-3)*4]-ds[k*4],  normalize(ds[2+k*4]-ds[k*4]),  3.14 +rot);            \n            ds[k*4+3] = ds[2+k*4] + erot(ds[k*4]-ds[2+k*4],  normalize(ds[1+k*4]-ds[2+k*4]),  3.14 -rot);\n        }\n        else if (j==1)// from left (ds2,ds3)\n        {\n            ds[k*4]= ds[2+(k-1)*4]; \n            ds[1+k*4]= ds[3+(k-1)*4];            \n            ds[2+k*4]= ds[k*4]  + erot(ds[1+(k-1)*4]-ds[k*4],  normalize(ds[1+k*4]-ds[k*4]),  3.14 -rot);    \n        }\n        else // from right (ds0,ds1)\n        {\n            ds[2+k*4]=ds[(k+1)*4] ; \n            ds[3+k*4]=ds[1+(k+1)*4] ;\n            ds[1+k*4]=ds[2+ k*4] + erot(ds[2+ (k+1)*4]-ds[2+k*4],  normalize(ds[3+k*4]-ds[2+k*4]),  3.14 +rot);         \n        }\n    }\n     Q.xyz= ds[uv.x*4+uv.y];\n           \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define tm (iMouse.z>0.? iMouse.x/iResolution.x:(1.+sin(iTime))/2.)\n\n//Iq\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0, v2v0 = v2 - v0, rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 ), q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n ), u = d*dot( -q, v2v0 ), v = d*dot(  q, v1v0 ), t = d*dot( -n, rov0 ); \n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;    \n    return vec3( t, u, v );\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize)//, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    //outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n//Blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}","name":"Common","description":"","type":"common"}]}