{"ver":"0.1","info":{"id":"Nl2BWG","date":"1652961609","viewed":144,"name":"sphere and plain","username":"Itay_milles","description":"raymarcher with colors and movment","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITR 120\n#define MIN_DST .01\n#define pi 3.14159\n\n#define sphere1 vec4(0., .51, 3., .5)\n#define sphere1col vec3(0.3, 0., 0.)\n#define plain1 .0\n#define plain1col vec3(0., 0., 0.)\n#define sun1 vec4(3.*sin(.5*iTime), 2., -3.*cos(.5*iTime), .02)\n#define sun1col vec3(1., 1., 0.)\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\nconst ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int LEFT  = 37;\nconst int UP    = 38;\nconst int RIGHT = 39;\nconst int DOWN  = 40;\n\n\nfloat sphereSdf(vec4 sphere, vec3 p)\n{\n    return length(sphere.xyz - p) - sphere.w;\n}\n\nfloat plainSdf(float plain, vec3 p)\n{\n    return p.y - plain;\n}\n\nfloat sceneSdf(vec3 p)\n{\n    float ds = sphereSdf(sphere1, p);\n    float dp = plainSdf(plain1, p);\n    \n    return min(ds, dp);\n}\n\nvec2 sphereToTexture(vec3 p)\n{\n    float R = sphere1.w;\n    float longitude = p.x / R;\n    float latitude = 2. * atan(exp(p.y/R)) - pi/2.;\n    \n    return vec2(-latitude, longitude);\n}\n\nvec4 dstToScene(vec3 rd, vec3 ro)\n{\n    float d = 0.;\n    float ds;\n    vec3 p;\n    for (int i = 0; i < MAX_ITR && d < 100.; i++)\n    {\n        p = rd*d + ro;\n        ds = sceneSdf(p);\n        if (ds < MIN_DST) {break;}\n        d += ds;\n    }\n    bool s1 = sphereSdf(sphere1, p) < MIN_DST;\n    bool p1 = plainSdf(plain1, p) < MIN_DST;\n    bool nn = !(p1 || s1);\n    \n    //texture(iChannel0, p.xz)*0.6)\n    vec3 col = vec3(float(s1)*sphere1col) + vec3(float(p1)*texture(iChannel0, p.xz)*0.6) + float(nn)*vec3(-1.);\n    return vec4(col, d);\n}\n\nvec3 cnormal(vec3 p)\n{\n    return normalize(vec3(\n                sceneSdf(p) - sceneSdf(p-vec3(.01, 0., 0.)),\n                sceneSdf(p) - sceneSdf(p-vec3(0., .01, 0.)),\n                sceneSdf(p) - sceneSdf(p-vec3(0., 0., .01))));\n}\n\nfloat clight(vec3 p, vec3 sun)\n{\n    vec3 light = normalize(sun - p);\n    vec3 normal = cnormal(p);\n    return dot(light, normal);\n}\n\nvec3 cfog(vec3 col, float d)\n{\n    vec3 fogcolor = vec3(.5294, .8078, .9216);\n    float weight = (1. - exp(-d*0.01));\n    return mix(col, fogcolor, weight);\n}\n\nfloat cshadow(vec3 ro, vec3 rd, float mint, float maxt)\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSdf(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= 1.7777777777777777777777777777778;\n    vec2 mouse = iMouse.xy / iResolution.xy - .5;\n    mouse.x *= 1.7777777777777777777777777777778;\n    \n    //camera\n    vec3 ro = fetchData(iChannel1, SCREEN_COLOR_ADDR).xyz;\n    vec3 rd = normalize(vec3(uv.x + mouse.x*2.*pi, uv.y, 1.));\n    \n    vec3 sun = sun1.xyz;\n    \n    //raymarch\n    vec4 d = dstToScene(rd, ro);\n    if (d.xyz == vec3(-1.)) {fragColor = vec4(.5294, .8078, .9216,1.0); return;}\n    vec3 p = ro + rd*d.w;\n    float light = .4*clight(p, sun);\n    float shadow = cshadow(p, normalize(sun - p), 0.1, 50.);\n    vec3 col = clamp(light, 0., 1.)*vec3(1., 0.788, 0.392)*.4*shadow + cfog(d.xyz, d.w);\n    col = pow( col, vec3(1.0/2.2) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int LEFT  = 37;\nconst int UP    = 38;\nconst int RIGHT = 39;\nconst int DOWN  = 40;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0); // Initial value\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n            fragColor = fetchData(iChannel0, SCREEN_COLOR_ADDR); // Load value from previous frame\n\n            // Update:\n            float stepsize = 0.1;\n            fragColor.x += texelFetch(iChannel1, ivec2(LEFT, 0), 0).x*-stepsize;\n            fragColor.x += texelFetch(iChannel1, ivec2(RIGHT, 0), 0).x*stepsize;\n            fragColor.z += texelFetch(iChannel1, ivec2(UP, 0), 0).x*stepsize;\n            fragColor.z += texelFetch(iChannel1, ivec2(DOWN, 0), 0).x*-stepsize;\n            }\n        }\n    }","name":"Buffer A","description":"","type":"buffer"}]}