{"ver":"0.1","info":{"id":"Ms2yDR","date":"1491705776","viewed":1847,"name":"Golden Spiral.","username":"TinyTexel","description":"far from perfect but good enough for now","likes":67,"published":1,"flags":32,"usePreview":0,"tags":["spiral","bloom","glow","golden"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nTODO:\n- frame rate independence\n- linear segments instead of individual spots\n- fix esthetics of the center part\n*/\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n\t//col = col.bgr;    \n\n    float vig = tex.x * tex.y * (1.0 - tex.x) * (1.0 - tex.y) * 16.0;\n    vig = sqrt(vig);\n    vig = mix(0.6, 1.0, vig);\n    col *= vec3(vig);\n    \n    //col = (1.0 - exp2(-col*col * 5.1));\n    //col *= col;\n    \n    fragColor = vec4(GammaEncode(col), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define lerp mix\n#define rsqrt inversesqrt\n#define clamp(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp);\n\n    float g = 1.0 / (max(0.0, v /dr - 1.0) * 8.0 + 1.0);\n    g *= g;\n\n    return g;\n}\n\n\nconst float GAng = Pi * (3.0 - sqrt(5.0));\n\n/*\nIN:\n\ti\t: sample number; integer [0..n-1]\n\tn\t: sample count; integer > 0\n\th0  : angle hash [-1..1]\n\th1  : radius hash [0..1]\n\nRETURN: position on unit disk\n\nEXAMPLE:\t\n\th1 = clamp(h1 * 0.5 + 0.5);\n\tvec2 p = Sample_Disk_GS(i, n, h0, h1);\n*/\nvec2 Sample_Disk_GS(float i, float n, float h0, float h1)\n{\n    float I = i + h1;\n\n    float rad = sqrt(I / n);\n\n    float theta = GAng * I + h0 * Pi;\n\n    return AngToVec(theta) * rad;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n    vec2 uv = floor(uv0.xy);\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    vec2 c = (PixelCount * 0.5);\n    vec2 vec = uv - c;\n    \n    float rr = PixelCount.y * 0.4;\n    float r = PixelCount.y * 0.013;\n    \n    vec3 col = vec3(0.0);\n    float v = 0.0;\n \n\tconst float n = 16.0;// dot count\n\n    float h0 = Frame * 0.003;\n    float h1 = 1.0 - clamp(fract((Frame) * 0.01));\n    \n    for(float i = 0.0; i < n; ++i)\n    {        \n        vec2 off = vec2(0.0);\n        \n        off = Sample_Disk_GS(i, n, h0, h1);\n        \n        vec2 p = c + off * rr;\n        \n        float l = clamp((i + h1) / n);// [0..1]\n        float l0 = l;\n\n        l = clamp((1.0 - l) * 8.0);\n        l = l*l*(3.0 - 2.0*l);// s-curve\n        \n        l *= 1.0 + Pow2(max(0.0, 0.4 - l0) / 0.4) * 4.0;// gettin brighter close to center \n        \n        float d = PlotDot(uv0, p, r);\n        d *= l;\n        \n        v += d;\n    }\n    \n    col = vec3(0.0, 0.01, 0.1);// bg\n\tcol = lerp(col, (vec3(1.0, 0.15, 0.025))*400.0, v);// dots\n\tcol += PlotDot(uv0, c, r * 6.0) * (vec3(1.0, 0.005, 0.001))*800.0;// center\n\n    vec3 col0 = textureLod(iChannel0, tex, 0.0).rgb;\n\n    col = lerp(col0, col, 0.02);// feedback\n    \n\t//fragColor = vec4(GammaEncode(col), 1.0);\n    fragColor = vec4(col, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}