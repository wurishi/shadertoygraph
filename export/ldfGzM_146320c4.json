{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Copyright (c) 2014 Andrew Baldwin (baldand)\n// License = Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) (http://creativecommons.org/licenses/by-sa/4.0/)\n\n#define SHADOW\n#define AO\n\nfloat rnd(vec2 n)\n{\n  return fract(sin(dot(n.xy, vec2(12.345,67.891)))*12345.6789);\n}\n\nfloat rnd2(vec3 n)\n{\n  return fract(sin(dot(n.xyz, vec3(12.345,67.891,40.123)))*12345.6789);\n}\n\n\nfloat saw(float t)\n{\n\treturn abs(fract(t*.5)*2.-1.)*2.-1.;\n}\n\nfloat obj(vec3 pos, vec3 opos)\n{\n\tpos *= vec3(1.,.5,1.);\n\tvec3 coord = floor(pos);\n\tcoord = vec3(coord.x,0.,coord.z);\n\tvec3 f = fract(pos);\n\tvec3 diff = vec3(1.,0.,0.);\n\tfloat tl = rnd(coord.xz);\n\tfloat ltl = length(pos-coord);\n\tfloat tr = rnd(coord.xz+diff.xz);\n\tfloat ltr = length(pos-coord-diff);\n\tfloat bl = rnd(coord.xz+diff.yx);\n\tfloat lbl = length(pos-coord-diff.yyx);\n\tfloat br = rnd(coord.xz+diff.xx);\n\tfloat lbr = length(pos-coord-diff.xyx);\n\tfloat b = .25*(ltl+ltr+lbl+lbr)-0.;\n    f = f*f*(3.0-2.0*f);\n\tfloat off = .5*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.z);\n\tb = min(min(ltl-off,ltr-off),min(lbl-off,lbr-off));\n\t\n\tvec3 opos1 = opos*10.;\n\tvec3 fopos = floor(opos1);\n\tb = max(b,-.1*length(opos1-.5-fopos)+.05);\n\tvec3 opos2 = opos*13.21873;\n\tfopos = floor(opos2);\n\tb = max(b,-length(opos2-.5-fopos)/13.21873+.05);\n\t\n\treturn b;\n}\n\nfloat height(vec3 pos) \n{\n\treturn -10.*sin(.06*((pos.x+.5)))*sin(.05*((pos.z+.5)))-30.*sin(.01*(pos.x+.5))*sin(.01*(pos.z+.5));\n}\n\nfloat gridheight(vec3 pos)\n{\n\treturn -10.*sin(.06*floor((pos.x+.5)))*sin(.05*floor((pos.z+.5)))-30.*sin(.01*floor(pos.x+.5))*sin(.01*floor(pos.z+.5));\n}\n\nvec3 map(vec3 pos, float time)\n{\n\tvec3 floorpos = pos;\n\tfloorpos.y -= height(pos);\n\tvec3 res = vec3(floorpos.y+1.,0.,0.0);\n\tif (floorpos.y<3.) {\n\t\tvec3 opos = pos;\n\t\tpos.y -= gridheight(pos);\n\t\tfloat b = obj(pos,opos);\n\t\tfloat b2 = 0.;\n\t\tb = max(b,b2);\n\t\tif (b<res.x) {\n\t\t\tres.x = b;\n\t\t\tres.y = 1.;\n\t\t}\n\t} else {\n\t\tres.x = max(floorpos.y-10000.,1.);\n\t\tres.y = 4.;\n\t}\n\tres.z = floorpos.y;\n\treturn res;\n}\n\nvec3 normal(vec3 pos, float time)\n{\n\tvec3 eps = vec3(0.001,0.,0.);\n\tfloat dx = map(pos+eps.xyy,time).x;\n\tfloat dy = map(pos+eps.yxy,time).x;\n\tfloat dz = map(pos+eps.yyx,time).x;\n\tfloat mdx = map(pos-eps.xyy,time).x;\n\tfloat mdy = map(pos-eps.yxy,time).x;\n\tfloat mdz = map(pos-eps.yyx,time).x;\n\treturn normalize(vec3(dx-mdx,dy-mdy,dz-mdz));\n}\n\nvec3 model(vec3 rayOrigin, vec3 rayDirection,float time)\n{\n\tfloat t = 0.;\n\tvec3 p;\n\tfloat d = 2.;\n\tbool nothit = true;\n\tvec3 r;\n\tfloat scatter = 0.;\n    \n    vec3 sundir = normalize(vec3(cos(0.1),sin(0.1),0.4));\n    vec3 skycol = vec3(0.13,.2,.6); \n\tfloat sun = clamp(dot(sundir,rayDirection),0.0,1.0);\n    skycol = 0.75*mix(vec3(.3,.3,.1),skycol,.95+.05*sun)+vec3(1.0,0.8,0.7)*pow(sun,16.0);\n    \n\tfor (int i=0;i<2000;i++) {\n\t\tif (nothit) {\n\t\t\tt += min(d*.5,10.);\n\t\t\tp = rayOrigin + t * rayDirection;\n\t\t\tr = map(p,time);\n            scatter += d*5.*clamp(-p.y+2.-r.z,0.,1.)\n                     + d*.2*clamp(p.y+5.+r.z-10.,0.,1.)\n                \t + d*.5\n                \t + d*1.*clamp(\n                         0.01*r.z*(sin((p.x+r.z)*.05))\n                        + (sin( (p.y+r.z*.5)*.1)) * (sin(r.z*.3))\n                         ,0.0,10.0)*clamp(p.y-150.+r.z,0.0,5.0);\n\t\t\td = r.x;\n\t\t\tnothit = d>t*.001 && t<100000.;\n\t\t}\n\t}\n\tt += d*.5;\n\tp = rayOrigin + t * rayDirection;\n\tvec3 n = normal(p,time);\n\tfloat lh = abs(fract(iTime*.1)*2.-1.);\n\tlh = 79.*lh*lh*(3.-2.*lh);\n\tvec3 lightpos = p+sundir;\n\tvec3 lightdist = lightpos - p;\n\tfloat light = 2.+dot(lightdist,n)*1./length(lightdist);\n#ifdef AO\n\t// AO\n\tfloat at = 0.4;\n\tfloat dsum = d;\n\tvec3 ap;\n\tfor (int i=0;i<4;i++) {\n\t\tap = p + at * n;\n\t\tdsum += map(ap,time).x/(at*at);\n\t\tat += 0.1;\n\t}\n\tfloat ao = clamp(dsum*.1,0.,1.);\n\tlight = light*ao;\n#endif\n#ifdef SHADOW\n\t// March for shadow\n\tvec3 s;\n\tfloat st;\n\tfloat sd=0.;\n\tfloat sh=1.;\n\tst=.3;//+.5*rnd2(p+.0123+fract(iTime*.11298923));\n\tvec3 shadowRay = normalize(sundir);\n\tnothit = true;\n\tfor (int i=0;i<10;i++) {\n\t\tif (nothit) {\n\t\t\tst += sd*.5;\n\t\t\ts = p + st * shadowRay;\n\t\t\tsd = map(s,time).x;\n\t\t\tsh = min(sh,sd);\n\t\t\tnothit = sd>0.00001;\n\t\t}\n\t}\n\tlight = 5.0*light * clamp(sh,0.1,1.);\n#endif\n\tvec3 m;\n\tm=.5+.2*abs(fract(p)*2.-1.);\n\tm=mix(vec3(.05,.15,.03),vec3(.25,.1,.03),rnd(floor(p.xz*.5)));\n\tif (r.y==0.) {\n\t\tm=vec3(.08,0.05,0.01);\n\t} else if (r.y==2.) {\n\t\tm=.3+vec3(m.x+m.y+m.z)*.333;\n\t} else if (r.y==3.) {\n\t\tm=vec3(1.,0.,0.);\n\t} else if (r.y==4.) {\n\t\tm=skycol;\n\t}\n\tvec3 c = vec3(clamp(1.*light,0.,10.))*vec3(m)+vec3(scatter*.001);\n\treturn c; \n}\n\nvec3 camera(in vec2 sensorCoordinate, in vec3 cameraPosition, in vec3 cameraLookingAt, in vec3 cameraUp)\n{\n\tvec2 uv = 1.-sensorCoordinate;\n\tvec3 sensorPosition = cameraPosition;\n\tvec3 direction = normalize(cameraLookingAt - sensorPosition);\n\tvec3 lensPosition = sensorPosition + 2.*direction;\n\tconst vec2 lensSize = vec2(1.);\n    vec2 sensorSize = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 offset = sensorSize * (uv - 0.5);\n\tvec3 right = cross(cameraUp,direction);\n\tvec3 rayOrigin = sensorPosition + offset.y*cameraUp + offset.x*right;\n\tvec3 rayDirection = normalize(lensPosition - rayOrigin);\n\tvec3 colour = vec3(0.);\n\tcolour = 2.*max(model(rayOrigin, rayDirection,iTime),vec3(0.));\n\tcolour = colour/(1.+colour);\n    return colour;\n}\n\t\t\nvec3 world(vec2 fragCoord)\n{\n\t// Position camera with interaction\n\tfloat anim = saw(iTime*.1);\n\tfloat rotspeed = .75+10.*iMouse.x/iResolution.x;\n\tfloat radius = (1.+anim+iMouse.y/iResolution.y)*10.;//10.+5.*sin(iTime*.2);\n    float speed = 0.5;\n    float time = speed*iTime;\n\tvec3 base = vec3(time*3.71,0.,time*5.);\n    float up = 0.;\n    if (iMouse.z>1.) up = 4.0*iMouse.y/iResolution.y-2.0;\n\tvec3 cameraTarget = vec3(0.,0.,0.)+base+vec3(sin(rotspeed)*cos(up),sin(up),cos(rotspeed)*cos(up));\n\tvec3 cameraPos = vec3(0.0)+base;//radius*sin(rotspeed),0.,radius*cos(rotspeed))+base;\n\tfloat h = height(cameraPos)+2.;\n\tcameraTarget.y += h;\n\tcameraPos.y += h;\n\tvec3 cameraUp = vec3(0.,1.,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\treturn camera(uv,cameraPos,cameraTarget,cameraUp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(world(fragCoord),1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldfGzM","date":"1409292949","viewed":733,"name":"Autumn Morning Lego Trees","username":"baldand","description":"Simple landscape populated with vaguely tree like objects. Mist/fog/clouds to give a bit of atmosphere.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""}}