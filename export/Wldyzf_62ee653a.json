{"ver":"0.1","info":{"id":"Wldyzf","date":"1609634218","viewed":151,"name":"Bouncy Ball-analytic motion blur","username":"athibaul","description":"Just a silly bouncing ball. Make sure to press \"Reset time\" [ |< ] to synchronize the sound.","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["2d","physics","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define squared(x) (x)*(x)\n\nfloat dot2(vec2 p){ return dot(p,p); }\n\n/*\nfloat calcTimeInBall(vec2 fragCoord)\n{\n    float timeInBall = 0.;\n    const float STEP = 0.1;\n    for(float i=0.; i<1.; i+=STEP) // Motion blur\n    {\n        float t = iTime + i*iTimeDelta;\n        float ballRadius = 0.1*min(iResolution.x, iResolution.y);\n        vec2 ball;\n        ball.x = t;\n        ball.x = mod(ball.x, 2.);\n        ball.x = 1.-abs(1.-ball.x);\n        ball.y = 1.618*t;\n        ball.y = mod(ball.y, 2.);\n        ball.y = 1.-squared(1.-ball.y);\n\n        vec2 ballCoord = ballRadius + (iResolution.xy - 2.*ballRadius) * ball;\n\n        float d = length(fragCoord - ballCoord) - ballRadius;\n        timeInBall += smoothstep(1.,-1.,d)*STEP; // Anti-aliasing\n    }\n    return timeInBall;\n}\n*/\n\nfloat calcTimeInBallAnalytic(vec2 p)\n{\n    // Analytic motion blur\n    \n    // Ball trajectory\n    float t = iTime;\n    float ballRadius = 0.1*min(iResolution.x, iResolution.y);\n    vec2 ball;\n    ball.x = t;\n    ball.x = mod(ball.x, 2.);\n    ball.x = 1.-abs(1.-ball.x);\n    ball.y = 1.618*t;\n    ball.y = mod(ball.y, 2.);\n    ball.y = 1.-squared(1.-ball.y);\n    \n    vec2 screenScale = (iResolution.xy - 2.*ballRadius);\n    vec2 ballCoord = ballRadius + screenScale * ball;\n    \n    // Speed of the ball (time is in frames)\n    vec2 dball = vec2(sign(1.-mod(t,2.)), 2.*(1.-mod(1.618*t,2.)))* iTimeDelta;\n    vec2 dballCoord = screenScale * dball;\n\n    // Solve second order equation to find first and last time of\n    // intersection with the circle, assuming a linear trajectory\n    float dist2 = dot2(p - ballCoord);\n    float r2 = ballRadius*ballRadius;\n    float d2 = dot2(dballCoord);\n    float distDotD = dot(p-ballCoord, dballCoord);\n    float discr = squared(distDotD) - (dist2 - r2) * d2;\n    \n    if(discr < 0.) return 0.;\n    \n    vec2 t12 = (distDotD + vec2(-1,1)*sqrt(discr))/d2;\n    t12.x = max(t12.x, -0.5);\n    t12.y = min(t12.y, 0.5);\n    \n    return max(t12.y - t12.x, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float timeInBall = calcTimeInBallAnalytic(fragCoord);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col = mix(col, vec3(1.), timeInBall);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// Phase Modulation synthesis\n// https://en.wikipedia.org/wiki/Frequency_modulation_synthesis\n// https://www.shadertoy.com/view/tdyfRy\n// https://www.shadertoy.com/view/3scfD2\n#define TAU (2.*3.1415926)\n#define SinOsc(f,m) sin(TAU*(f)*t+(m))\n\nfloat marimba(float t, float freq)\n{\n    if(t<0.) return 0.;\n    return SinOsc(freq, SinOsc(3000.,0.)*exp(-60.*t)+0.1*SinOsc(20.,0.)) * exp(-20.*t);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v = vec2(0);\n    float t = mod(time, 2.);\n    v.x += marimba(t, 440.);\n    v.y += marimba(t-1., 660.);\n    \n    float ballx = 1.-abs(1.-t);\n    \n    float t2 = mod(time, 2./1.618);\n    float mar = marimba(t2, 550.);\n    v += mar * normalize(vec2(1.-ballx, ballx));\n    \n    return v * 0.2;\n}","name":"Sound","description":"","type":"sound"}]}