{"ver":"0.1","info":{"id":"wsGBzR","date":"1606395943","viewed":202,"name":"Rotating Planet","username":"AzazelN28","description":"Rotating Planet","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["light","sphere","map","normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define R0 1.0000\t// Nomralized Earth radius (6360 km)\n#define R1 1.0094\t// Atmosphere radius (6420 km) \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y;\n    \n\tvec2 uv = vec2(ratio, 1.) * (2. * fragCoord.xy / iResolution.xy - 1.);\n    \n    // Distancia con respecto al centro.\n    float luv = length(uv);\n    if (luv > 1.1) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    // Normal de la esfera.\n    vec3 n = vec3(uv, sqrt(1. - clamp(dot(uv, uv), 0., 1.)));\n    \n    // Dirección de la luz.\n    // NOTA: Si quieres que rote la luz descomenta esta línea\n    // y comente la siguiente.\n    vec3 l = vec3(cos(iTime * 0.1), 0., sin(iTime * 0.1));\n    // vec3 l = vec3(-0.5, 0., 0.5);\n    \n    // Ángulo de incidencia de la luz.\n    float a = dot(n, l);\n    \n    // Color de la atmósfera.\n    // TODO: Esto se podría mejorar con una atmósfera que pueda tener\n    // más de un color o que el color varíe en función del ángulo de\n    // incidencia. Debería consultar: https://es.wikipedia.org/wiki/Dispersi%C3%B3n_de_Rayleigh\n    vec3 atmc = vec3(0.75, 0.5, 0.25);\n    if (luv > 1.0) {\n        float atm = mix(clamp(a, 0., .25), 0.0, (luv - 1.0) / (1.1 - 1.0));\n        fragColor = vec4(atmc * atm, atm);\n        return;\n    }\n    \n    vec3 t = vec3(n);\n\n    // En los cálculos originales en vez de Pi, usan Tau\n    // porque realmente están mapeando una esfera completa.\n    // En nuestro caso se puede considerar que es una semi-esfera,\n    // por lo tanto, usamos Pi.\n    // float s = 0.5 + atan(n.z, n.x) / (2. * 3.1415);\n    float phase = mod(iTime * 0.01, 1.0);\n    vec2 tuv = vec2(\n        phase + atan(t.z, t.x) / 3.1415, \n    \t0.5 - asin(t.y) / 3.1415\n    );\n    \n    // Encontré una forma de simular el scattering de una superficie\n    // @see https://www.shadertoy.com/view/lsGGDd\n    float scatter = 4.0 * pow((sqrt(R1 - dot(uv, uv)) - n.z) / sqrt(R1 - R0), 1.35);\n\n    // vec3 color = 0.5 + 0.5 * n;\n    vec3 tex = texture(iChannel0, tuv).xyz;\n    vec3 color = mix(\n        vec3(0.5), \n        tex,\n        smoothstep(1.01, 1., dot(uv, uv))\n    ) * a;\n    \n    vec3 halo = mix(vec3(0.0), color, scatter);\n\n    \n    // Esta no es la manera correcta de aplicar el especular pero...\n    //  ¯\\_(ツ)_/¯\n    fragColor = vec4(color + halo, 1.0);\n}","name":"Image","description":"","type":"image"}]}