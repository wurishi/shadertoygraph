{"ver":"0.1","info":{"id":"sdKXD3","date":"1635524136","viewed":164,"name":"Lights, Camera, Action!","username":"spalmer","description":"golfing Jorge's lighting from [url=https://shadertoy.com/view/ssySDV]truchet 3d -basic v2[/url], trying for simple yet correct shading in re-usable package. \ncan enable FLY cam option in BufferA, controlled w mouse, spacebar to move forward, shift reverse","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["shadow","lighting","shading","camera","occlusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// post-processing; Buffer A has rendering, state\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy, or = r;\n    r *= min(r.y, maxRes) / r.y; // limit\n  //#if FLY\n    if (all(lessThan(p, vec2(1)))) p = vec2(1.5); // use neighbor of data pixel instead\n  //#endif\n    o = textureLod(iChannel0, p*r/or/or, 0.); // bilinear upscale\n    // TODO further post-processing\n    o *= 1.15 / (o + .18); // Reinhard tonemap, gamma\n    o -= .02 * texelFetch(iChannel3, ivec2(p) & 1023, 0).g; // blue noise dither\n}\n\n// o = pow(o, vec3(1./2.2)); // power gamma","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// jorge2017a2's truchet toy https://shadertoy.com/view/ssySDV\n// but golfed the frijoles out of it!  Original is 7405 ch\n// also fixed the shading and other minor tweaks,\n// added fly cam and upscaling support\n\nconst vec3 palette[2] = vec3[] ( vec3(.6,.5,.4), vec3(1,1,1) );\n\n// TODO more attributes; roughness, bumpmap\nvec3 materialColor(int id_material, int id_color, vec2 uv, inout vec3 n, out float sexp) // returns albedo\n{\n    if (uint(id_color) > uint(palette.length())) id_color = 0;\n    vec3 colobj = palette[id_color];\n    // TODO can modify normal n also\n    colobj *= texture(iChannel2, uv).rgb * .5 + .5;\n    sexp = 16. + 16. * float(id_material); // phong specular power\n    return colobj;\n}\n\n// directional light\nvec3 sunDir = vec3(-.5,.2,-.3), sunColor = vec3(1.2,.1,.0); //1,.8,.5); //\n\nvec3 sky(vec3 d) // background function for ray misses\n{\n    float t = (d.x + 1.) / 2.; // FIXME coordsys\n    vec3 c = vec3(.01, .1, .4) * vec3((1. - t) + t * .3, (1. - t) + t * .5, (1. - t) + t);\n    return mix(c, vec3(.4, .6, .8), 1. - d.y) * sunColor;\n}\n\n\n// point lights\nstruct Light\n{\n    vec3 c, p; // color, position\n};\n\nLight lights[1] = Light[] (\n    Light(vec3(.9,.6,.3), vec3( 1,.4,1))\n//  , Light(vec3(.1,.5,1), vec3(-1,0,1))\n);\n\n\nvec2 rot(vec2 p, float rad)\n{\n    float c = cos(rad), s = sin(rad);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, float rad)\n{\n    float c = cos(rad), s = sin(rad);\n    vec3 t = a*c - b*s;\n    b = a*s + b*c;\n    a = t;\n}\n\n\nfloat hash21(vec2 p)\n{   \n    p = fract(p * vec2(234.34, 435.345));\n    p += dot(p, p + 34.26);\n    return fract(p.x * p.y);\n}\n\nfloat truchet(vec2 q)\n{\n    vec2 gv = fract(q) - .5, id = floor(q);\n    float n = hash21(id), rh = sqrt(.5);\n    if (n < .5) gv.x = -gv.x;    \n    float d = abs(gv.x + gv.y) * rh; // Diagonal line.\n    gv = abs(gv) - .5; // Corners.\n    d = min(d, abs(gv.x + gv.y) * rh); \n    return d - .1;\n}\n\nstruct Surface\n{\n    float d; // distance to surface\n    int c; // color id\n    int m; // material id // TODO uv?\n};\n\n// either union (op = >) or intersection (op = <),\n// can get difference by intersecting negated b\n#define sCombine(op, s, b) if (s.d op b.d) s = b\n\nSurface scene(vec3 p)\n{\n\tfloat dbot = p.y + 2.5  // ground\n    , dtop = dbot - 1.5\n    , period = 47.; // try 2., 3., 4., 5. etc.\n    vec2 pmaze = p.xz;\n    pmaze = rot(pmaze * .65, radians(45.));\n    pmaze = mod(pmaze, period);\n    float dwal = truchet(pmaze); //length(fract(pmaze) - .5) - .1; //\n    Surface s = Surface(9e9, -1, -1);\n    sCombine(>, s, Surface(dbot, 0, 0));\n    sCombine(>, s, Surface(dwal, 0, 1));\n    sCombine(<, s, Surface(dtop, 1, 1));\n    return s;\n}\n\nfloat dScene(vec3 p) { return scene(p).d; }\n\n// simple backward difference gradient\nvec3 gScene(vec3 p, float h)\n{\n    vec2 e = vec2(h, 0);\n    return dScene(p) - vec3(\n        dScene(p - e.xyy), \n        dScene(p - e.yxy),\n        dScene(p - e.yyx)\n        );\n}\n\n// trace results, info about surface intersection\nstruct Hit\n{\n    vec3 pos;\n    float range; // hit distance\n    float dist; // closest distance found from ray to any object\n    int iterations;\n    // can I just include a Surface struct?\n    int material; // BSDF id\n    int color; // palette id\n    //int texid; // texture id\n    bool miss; // miss? trace fail flag, hit sky/bg, most other fields invalid\n};\n\n// sphere cast ray march trace scene\nHit trace(vec3 ro, vec3 rd, float tmax, int nstep)\n{   \n    Surface s = Surface(9e9,-1,-1);\n    vec3 p;\n    float minDist = 9e9\n    , sa = .0001 // TODO pixel angle sine\n    , t = 0.\n    , maxh = .1;\n    Hit hit; hit.miss = true; hit.range = tmax; //-1.; //\n    int i;\n    for (i = 0; i < nstep && t < tmax; ++i) {\n        p = ro + rd*t;\n        s = scene(p);\n        float d = s.d;\n        minDist = min(minDist, d);\n        const float dBias = 1.; //.9; //.7; //\n        t += d * dBias;\n        if (abs(d) < sa * t) { hit.miss = false; break; }\n    }\n    if (hit.miss && (abs(s.d) < .02 * t || (rd.y < 0. && p.y < maxh && t < tmax)))\n        hit.miss = false; // close enough!\n    hit.iterations = i;\n    if (!hit.miss) {\n        hit.pos = p;\n        hit.range = t;\n        hit.dist = abs(s.d);\n        hit.color = s.c;\n        hit.material = s.m;\n        //hit.texid = 0;\n    }\n    //hit.miss = true;\n    return hit;\n}\n\nfloat shadow(vec3 p, vec3 l, float d, int nstep)\n{\n    Hit hit = trace(p, l, d, nstep);\n    if (!hit.miss && hit.range < d) return 0.;\n    else return 1.;\n}\n\nfloat occlusion(vec3 pos, vec3 norm, int niter)\n{\n    float sca = 2., occ = 0.;\n    for (int i = 0; i < niter; ++i) {\n        float hr = .01 + float(i)/float(niter) * .5\n        , dd = dScene(norm * hr + pos);\n        occ += (hr - dd) * sca;\n        sca *= .6;\n    }\n    return max(0., 1. - occ);\n}\n\n// takes normal, light dir, view dir, surface color, light color, phong specular power\nvec3 lightShading(vec3 n, vec3 l, vec3 v, vec3 albedo, vec3 cl, float specpower)\n{\n    float nl = max(0., dot(n, l));\n    vec3 diffuse = vec3(nl) * albedo\n    , r = reflect(-l, n);\n    float sf = pow(max(0., dot(r, v)), specpower)\n        * nl * specpower * .038;\n    vec3 specular = vec3(sf);\n    return (diffuse + specular) * cl;\n}\n\nvec3 lightPoint(vec3 hitpos, vec3 n, vec3 v, vec3 albedo, float specexp, vec3 pl, vec3 cl)\n{\n    vec3 ph = hitpos\n    , l = pl - ph;\n    float ll = dot(l, l) + .001;\n    cl /= 1. + .1 * ll; // atten\n    float dl = sqrt(ll);\n    l /= dl;\n    int zero = min(0, iFrame);\n    float sh = shadow(ph, l, dl, 65 + zero);    \n    return lightShading(n, l, v, albedo, cl, specexp) * sh;\n}\n\nvec3 lightDir(vec3 hitpos, vec3 n, vec3 v, vec3 albedo, float specexp, vec3 dl, vec3 cl)\n{\n    dl = normalize(dl);\n    int zero = min(0, iFrame);\n    float sh = shadow(hitpos, dl, 3., 65 + zero);    \n    return lightShading(n, dl, v, albedo, cl, specexp) * sh;\n}\n\nvec3 lighting(vec3 v, Hit hit, int zero)\n{\n    float pdist = .001 * hit.range; // perspective corrected tiny bias\n    vec3 normal = normalize(gScene(hit.pos, pdist))\n    , an = abs(normal)\n    , uvw = fract(hit.pos * 4.);\n    vec2 uv = (an.x > max(an.y, an.z)) ? uvw.yz :\n        (an.y > an.z) ? uvw.zx : uvw.yx; // triplanar, no blending;  in world space doesn't work for moving objects!\n    int mid = hit.material; float sexp;\n    vec3 albedo = materialColor(mid, hit.color, uv, normal, sexp);\n    hit.pos += 2. * pdist * normal; // self shadow bias\n    // TODO reflections\n    float occ = occlusion(hit.pos, normal, 10 + zero);\n    vec3 c = vec3(.1,.15,.2) * occ * albedo; // ambient\n    c += lightDir(hit.pos, normal, v, albedo, sexp, sunDir, sunColor); // sun\n    for (int i = lights.length(); i-- > 0; )\n        c += lightPoint(hit.pos, normal, v, albedo, sexp, lights[i].p, lights[i].c);\n    return c;\n}\n\nfloat lightHalo(vec3 d, vec3 l)\n{\n    return dot(l, d) < 0. ? 0. :\n        8. * exp2(-128. * dot(l = cross(l, d), l));\n}\n\nvec3 halos(vec3 ro, vec3 rd, Hit hit)\n{\n    vec3 c = vec3(0);\n    for (int i = lights.length(); i-- > 0; ) {\n        Light li = lights[i];\n        vec3 lr = li.p - ro;\n        if (hit.miss || hit.range*hit.range >= dot(lr, lr))\n            c += lightHalo(lr, rd) * li.c;\n    } // if not obscured\n    if (hit.miss) c += lightHalo(sunDir, rd * 4.) * sunColor;\n    return c;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  \n    int zero = min(0, iFrame);\n    float tmax = 30.;\n    Hit hit = trace(ro, rd, tmax, 110 + zero);\n    vec3 c = sky(rd);\n    if (!hit.miss) {\n        float fog = 1. - pow(hit.range / tmax, 2.5);\n        c = mix(c, lighting(-rd, hit, zero), fog);\n    }\n    // TODO more atmospherics\n    c += halos(ro, rd, hit);\n    return c;\n}\n\n#define FLY 0\n// can easily strip out this simple debug fly camera,\n// but good to have during development.\n// using offscreen buffer anyway for upscaling support!\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy, or = r, op = p;\n    r *= min(r.y, maxRes) / r.y;\n    if (any(lessThan(r, p))) discard; //{ o = vec4(0); return; } // limit resolution\n    mat3 V = mat3(1);\n    vec2 look = vec2(0, radians(-40.));\n    vec3 ro;\n  #if FLY\n    vec4 data = iFrame < 3 ? vec4(0,0,0,0) : texelFetch(iChannel0, ivec2(0), 0); // data pixel at lower left corner\n    ro = data.xyz;\n    look = iMouse.z > 1.\n        ? (iMouse.xy - abs(iMouse.zw)) * vec2(6,3) / or.y\n        : sin(vec2(iTime * vec2(.2,.09))) * vec2(.15, .07);\n  #endif\n    rot(V[0], V[2], look.x);\n    rot(V[1], V[2], look.y);\n    vec3 rd = V * normalize(vec3((p - .5*r) / r.y, 1))\n    , fd = V[2]; // forward facing dir\n  #if FLY\n   #define K(k) texelFetch(iChannel1, ivec2(k, 0), 0).x\n    // space = move, shift = reverse\n    float move = step(.5, K(32)) * (step(.5, K(16)) * -2. + 1.);\n    ro += move * .8 * iTimeDelta * fd; // spacebar = move!\n    if (dot(iMouse.zw, iMouse.zw) < 2.)\n  #endif\n        ro = vec3(0,3,.5 * iTime);\n    lights[0].p.xz = (ro + vec3( 1,0,0)).xz; // light 0 follow camera\n    //lights[1].p = ro + vec3(-1,0,0); // light 1 follow camera\n    vec3 c = Render(ro, rd); //, noiz);\n  #if FLY\n    if (all(lessThan(op, vec2(1)))) { // data pixel?\n        c = ro; // store eye pos\n    }\n  #endif\n    o = vec4(c,1);\n}\n\n/* // unused\nfloat sdBox(vec3 q, vec3 e)\n{\n    q = abs(q) - e; return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n*/\n    //float d2 = sdBox(p - vec3(0,3,0), vec3(20,2,20));\n    \n     //exp2(-.01 * hit.range); // Beer's law fog\n    \n    //vec4 noiz = texelFetch(iChannel3, ivec2(p) & 1023, 0); // blue noise all channels for various purposes\n\n    //, rd.yz *= mat2(1,1,-1,1) * sqrt(.5);\n\n    //o = texelFetch(iChannel0, ivec2(p), 0); // prior buffer - blend over time?\n    ///if (dot(d, od) > .99999) \n    // c = mix(texture(iChannel0, reprojectedp, 0).rgb, c, .33); // TODO TAA blending prior frame","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// fullscreen, high resolutions can be problematic; just upscale instead.\nconst float maxRes = 1440.; //1080.; //512.; //320.; //2160.; //","name":"Common","description":"","type":"common"}]}