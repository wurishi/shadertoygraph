{"ver":"0.1","info":{"id":"fdsyWj","date":"1642712222","viewed":111,"name":"Directional Lights","username":"clauswilke","description":"Experimenting with ray marching, soft shadow, phong shading, and directional lights. Click and move the mouse to change the camera position.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"7slyWB","parentname":"Phong + soft shadows"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Directional Lights\" by Claus O. Wilke\n// Jan. 20, 2022\n// Published under MIT License\n\n// Includes various code snippets from Inigo Quilez, licensed under MIT, https://iquilezles.org/www/index.htm\n// Also includes code by Martijn Steinrucken, licensed under MIT, https://www.shadertoy.com/view/WtGXDD\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 rotMatrix(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// smooth minimum\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y + 0.4;\n}\n\nfloat getDist(vec3 p) {\n    float d = sdFloor(p);\n    \n    float dspheres = smin(\n        sdSphere(p - vec3(0, 1.5, .4), 1.0 + .3*sin(iTime)),\n        smin(\n            sdSphere(p - vec3(-.8, 1, 0), .8 + .2*sin(3.*iTime+2.)),\n            sdSphere(p - vec3(.3, .5*cos(iTime/.8)+.7, .7*cos(iTime/.8)), 1.1),\n            0.1\n        ),\n        0.1\n    );\n    \n    return min(d, dspheres);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat t = mint;\n    float k = 20.;  // \"softness\" of shadow. smaller numbers = softer\n\n    // unroll first loop iteration\n    float h = getDist(ro + rd*t);\n    float res = min(1., k*h/t);\n    t += h;\n    float ph = h; // previous h\n    \n    for( int i=1; i<60; i++ )\n    {\n        if( res<0.01 || t>tmax ) break;        \n\n        h = getDist(ro + rd*t);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, k*d/max(0.0, t-y));\n        ph = h;\n        t += h;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);  // smoothstep, smoothly transition from 0 to 1\n}\n\n\n\n// from https://www.shadertoy.com/view/wlXSD7\nfloat calcOcclusion(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hrconst = 0.03; // larger values create more occlusion\n        float hr = hrconst + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = getDist( aopos );\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - occ*1.5, 0.0, 1.0);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n// Camera system explained here:\n// https://www.youtube.com/watch?v=PBxuVlp7nuM\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 lookat, float zoom) {\n    vec3 forward = normalize(lookat-ro),\n        right = normalize(cross(forward, vec3(0, 1., 0))),\n        up = cross(right, forward),\n        center = forward*zoom,\n        intersection = center + uv.x*right + uv.y*up,\n        d = normalize(intersection);\n    return d;\n}\n\n// cut1 and cut2 define the center cone and the max width of the light\n// they are cosines of the corresponding angles, so a center cone of\n// 15 degrees and a max width of 30 degrees would correspond to\n// cut1 = 0.9659258 and cut2 = 0.8660254\n// lr is the normalized light ray\nfloat calcDirLight(in vec3 p, in vec3 lookfrom, in vec3 lookat,\n                           in float cut1, in float cut2, out vec3 lr) {\n    lr = normalize(lookfrom - p);\n    float intensity = dot(lr, normalize(lookfrom - lookat));\n    return smoothstep(cut2, cut1, intensity);\n}\n\n\nvec3 renderLight1(in vec3 p, in vec3 n, in vec3 rdref, in float ao, in vec3 material) {\n    // Phong shading\n    // https://en.wikipedia.org/wiki/Phong_reflection_model\n    float ks = 0.6, // specular reflection constant\n        kd = 0.4,   // diffuse\n        ka = 0.2;   // ambient\n    \n    vec3 col_light = vec3(.8, .001, .8),\n        is = 6.*col_light,  // specular light intensity\n        id = 2.*col_light,  // diffuse\n        ia = 1.*col_light;  // ambient\n        \n    vec3 pl = vec3(5.*cos(-iTime), 4, 5.*sin(-iTime)); // light position\n    vec3 plat = vec3(0.5, 0, 0); // light direction\n\n    float alpha_p = 20.; // Phong alpha exponent\n\n    vec3 lr = vec3(0); // light ray to point p, will be assigned\n                       // by calcDirLight()\n    float light = calcDirLight(p, pl, plat, 0.96, 0.86, lr);\n    vec3 lrref = reflect(lr, n); // reflected light ray\n\n    float shadow = 1.;\n    if (light > 0.001) { // no need to calculate shadow if we're in the dark\n        shadow = calcSoftshadow(p, lr, 0.01, 20.0);\n    }\n    vec3 dif = light*kd*id*max(dot(lr, n), 0.)*shadow;\n    vec3 spec = light*ks*is*pow(max(dot(lr, rdref), 0.), alpha_p)*shadow;\n    vec3 amb = light*ka*ia*ao;\n\n    return material*(amb + dif + spec);\n}\n\nvec3 renderLight2(in vec3 p, in vec3 n, in vec3 rdref, in float ao, in vec3 material) {\n    // Phong shading\n    // https://en.wikipedia.org/wiki/Phong_reflection_model\n    float ks = 0.6, // specular reflection constant\n        kd = 0.4,   // diffuse\n        ka = 0.2;   // ambient\n    \n    vec3 col_light = vec3(.8, .8, .001),\n        is = 6.*col_light,  // specular light intensity\n        id = 2.*col_light,  // diffuse\n        ia = 1.*col_light;  // ambient\n        \n    vec3 pl = vec3(5.*cos(iTime + 2.09), 4, 5.*sin(iTime + 2.09)); // light position\n    vec3 plat = vec3(0, 0, 0.5); // light direction\n\n    float alpha_p = 20.; // Phong alpha exponent\n\n    vec3 lr = vec3(0); // light ray to point p, will be assigned\n                       // by calcDirLight()\n    float light = calcDirLight(p, pl, plat, 0.96, 0.86, lr);\n    vec3 lrref = reflect(lr, n); // reflected light ray\n\n    float shadow = 1.;\n    if (light > 0.001) { // no need to calculate shadow if we're in the dark\n        shadow = calcSoftshadow(p, lr, 0.01, 20.0);\n    }\n    vec3 dif = light*kd*id*max(dot(lr, n), 0.)*shadow;\n    vec3 spec = light*ks*is*pow(max(dot(lr, rdref), 0.), alpha_p)*shadow;\n    vec3 amb = light*ka*ia*ao;\n\n    return material*(amb + dif + spec);\n}\n\nvec3 renderLight3(in vec3 p, in vec3 n, in vec3 rdref, in float ao, in vec3 material) {\n    // Phong shading\n    // https://en.wikipedia.org/wiki/Phong_reflection_model\n    float ks = 0.6, // specular reflection constant\n        kd = 0.4,   // diffuse\n        ka = 0.2;   // ambient\n    \n    vec3 col_light = vec3(.001, .8, .8),\n        is = 6.*col_light,  // specular light intensity\n        id = 2.*col_light,  // diffuse\n        ia = 1.*col_light;  // ambient\n        \n    vec3 pl = vec3(5.*cos(2.*iTime + 4.19), 4, 5.*sin(2.*iTime + 4.19)); // light position\n    vec3 plat = vec3(0.5, 0, 0.5); // light direction\n\n    float alpha_p = 20.; // Phong alpha exponent\n\n    vec3 lr = vec3(0); // light ray to point p, will be assigned\n                       // by calcDirLight()\n    float light = calcDirLight(p, pl, plat, 0.96, 0.86, lr);\n    vec3 lrref = reflect(lr, n); // reflected light ray\n\n    float shadow = 1.;\n    if (light > 0.001) { // no need to calculate shadow if we're in the dark\n        shadow = calcSoftshadow(p, lr, 0.01, 20.0);\n    }\n    vec3 dif = light*kd*id*max(dot(lr, n), 0.)*shadow;\n    vec3 spec = light*ks*is*pow(max(dot(lr, rdref), 0.), alpha_p)*shadow;\n    vec3 amb = light*ka*ia*ao;\n\n    return material*(amb + dif + spec);\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n   \n    float d = rayMarch(ro, rd);\n    \n    if (d<MAX_DIST) {\n        vec3 p = ro + rd * d,   // point on 3D surface\n            n = getNormal(p),   // surface normal\n            rdref = reflect(rd, n); // reflected ray\n            \n        float ao = calcOcclusion(p, n);\n\n        vec3 material = vec3(1., 1., 1.); // material color\n        col += renderLight1(p, n, rdref, ao, material);\n        col += renderLight2(p, n, rdref, ao, material);\n        col += renderLight3(p, n, rdref, ao, material);\n        col += vec3(0.01)*ao; // just a touch of ambient light throughout\n    }\n    return clamp(col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    // ensure good starting point, m = vec2(0) \n    // when shader first loads\n    if (m.x != 0. || m.y != 0.) {\n        m -= vec2(.5, .5);\n    }\n    m.y = clamp(m.y, -.3, .15);\n\n    vec3 ro = vec3(0, 4, 8);\n    ro.yz *= rotMatrix(m.y*3.14);\n    ro.xz *= rotMatrix(m.x*2.*3.14);\n    \n    vec3 rd = getRayDir(uv, ro, vec3(0., 1., 0.), .9);\n    \n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}