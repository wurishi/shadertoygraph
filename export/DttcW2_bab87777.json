{"ver":"0.1","info":{"id":"DttcW2","date":"1726087822","viewed":15,"name":"Atmospheric Sky","username":"renzhen","description":"Atmospheric Sky","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265359;\nconst float invPi = 1.0 / pi;\n\nconst float zenithOffset = 0.0;\nconst float multiScatterPhase = 0.0;\nconst float density = 0.5;\n\nconst float anisotropicIntensity = 0.8; //Higher numbers result in more anisotropic scattering\n\nconst vec3 skyColor = vec3(0.39, 0.57, 1.0) * (1.); //Make sure one of the conponents is never 0.0\n\n#define smooth(x) x*x*(3.0-2.0*x)\n\nvec2 pixel;\n\nfloat horizonCurve(float x)\n{\n    //return 16.0 * (1.0 - smoothstep(0.0, 1.0, x)) + 1.0;\n    return min(density / pow(max(x + 0.2, 0.001), 1.2), 4.);\n}\n\nfloat sunCurve(float x)\n{\n    return 11.0 * (1.0 - smoothstep(0.0, 1.0, x)) + 1.0;\n}\n\n//#define zenithDensity(x) density * 5. * x\n\nvec3 sun_direction;\n\nvec3 getSkyAbsorption(vec3 x, float y){\n\t\n\tvec3 absorption = - x * y;\n\t     absorption = exp2(absorption) * 3.2;\n\t\n\treturn absorption;\n}\n\n\nfloat getRayleigMultiplier(vec3 p, vec3 lp){\n\treturn 1.0 + pow(1.0 - clamp(distance(p, lp), 0.0, 1.0), 2.0) * pi * 0.5;\n}\n\nfloat getMie(vec3 p, vec3 lp){\n\tfloat disk = clamp(1.0 - pow(distance(p, lp), 0.1), 0.0, 1.0);\n\treturn smoothstep(0., 1., disk) * 2.0 * pi;\n\treturn disk*disk*(3.0 - 2.0 * disk) * 2.0 * pi;\n}\n\n\nvec3 getAtmosphericScattering(vec3 p, vec3 lp){\n\t//vec2 correctedLp = lp / max(iResolution.x, iResolution.y) * iResolution.xy;\n    vec3 correctedLp = lp;\n\t\t\n\tfloat zenith = horizonCurve(p.y + 0.2);\n\tfloat sunPointDistMult =  clamp(correctedLp.y, 0.0, 1.0);\n\t\n\tfloat rayleighMult = getRayleigMultiplier(p, correctedLp);\n\t\n\tvec3 absorption = getSkyAbsorption(skyColor, zenith);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, sunCurve(correctedLp.y));\n\tvec3 sky = skyColor * zenith * rayleighMult;\n\tvec3 mie = getMie(p, correctedLp) * sunAbsorption;\n\t\n\tvec3 totalSky;\n    totalSky += mix(sky * absorption, sky / (sky + 1.), sunPointDistMult);\n         totalSky += mie;\n\t     totalSky *= 0.5 * (sunAbsorption + length(sunAbsorption));\n\t\n\treturn totalSky;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\n\nvec3 getSunColor(vec3 lp)\n{\n    vec3 color = getSkyAbsorption(skyColor, sunCurve(lp.y));\n    return 1.2 * jodieReinhardTonemap(color).xyz;\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n              \nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n                       \nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return 2. * (f - 0.2) - 1.;\n}\n\nfloat random1(vec3 p) {\n    return fract(sin(dot(p,vec3(127.1, 311.7, 191.999)))\n                 *43758.5453);\n}\n\nfloat mySmoothStep(float a, float b, float t) {\n    t = smoothstep(0., 1., t);\n    return mix(a, b, t);\n}\n\nfloat cubicTriMix(vec3 p) {\n    vec3 pFract = fract(p);\n    float llb = random1(floor(p) + vec3(0,0,0));\n    float lrb = random1(floor(p) + vec3(1,0,0));\n    float ulb = random1(floor(p) + vec3(0,1,0));\n    float urb = random1(floor(p) + vec3(1,1,0));\n\n    float llf = random1(floor(p) + vec3(0,0,1));\n    float lrf = random1(floor(p) + vec3(1,0,1));\n    float ulf = random1(floor(p) + vec3(0,1,1));\n    float urf = random1(floor(p) + vec3(1,1,1));\n\n    float mixLoBack = mySmoothStep(llb, lrb, pFract.x);\n    float mixHiBack = mySmoothStep(ulb, urb, pFract.x);\n    float mixLoFront = mySmoothStep(llf, lrf, pFract.x);\n    float mixHiFront = mySmoothStep(ulf, urf, pFract.x);\n\n    float mixLo = mySmoothStep(mixLoBack, mixLoFront, pFract.z);\n    float mixHi = mySmoothStep(mixHiBack, mixHiFront, pFract.z);\n\n    return mySmoothStep(mixLo, mixHi, pFract.y);\n}\n\nfloat fbm1(vec3 p) {\n    float amp = 0.5;\n    float freq = 4.0;\n    float sum = 0.0;\n    for(int i = 0; i < 8; i++) {\n        sum += (2.0 * cubicTriMix(p * freq) - 1.) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return 2. * sum - 1.;\n}\n\nfloat map(vec3 p)\n{\n    float sum = 0.;\n    float amp = 2.05;\n    float fre = 1.1;\n    for( int i=0; i<8; ++i )\n    {\n        sum += (2.0 * noise(p * fre) - 1.) * amp;\n        amp *= 0.5;\n        fre *= 2.;\n    }\n    return sum + 0.1;\n}\n\n// sample cloud density for a point in space\nfloat getDensity(vec3 p){\n    const float densMult = 12.;\n    const float scale = 0.003;\n    const float densThresh = 0.5;\n    const float offsetSpeed = 0.2;\n    \n    float f = fbm(p * scale + iTime * offsetSpeed);\n    f = max(0., f);\n    \n    return (f + 0.15) * (1. - smoothstep(512.,530.,p.y));\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nvec4 cloudsFbm( vec3 pos )\n{\n    return fbmd_8(pos*0.0015+vec3(2.0,1.1,1.0)+0.07*vec3(iTime,0.5*iTime,-0.15*iTime));\n}\nvec4 cloudsMap( in vec3 pos)\n{\n    float d = abs(pos.y-512.0);\n    vec3 gra = vec3(0.0,sign(pos.y-512.0),0.0);\n    \n    //vec4 n = cloudsFbm(pos);\n    float m = map(pos * 0.002+vec3(2.0,1.8,1.0)+0.07*vec3(iTime,0.5*iTime,-0.15*iTime));\n    d += 200.0 * m * (0.8+0.2*gra.y);\n    \n    //if( d>0.0 ) return vec4(-d,0.0,0.0,0.0);\n    \n    //nnd = -d;\n    //d = min(-d/100.0,0.25);\n    \n    return vec4( -d, gra );\n}\n\nfloat scene(vec3 p)\n{\t\n    return getDensity(p);\n\treturn .1-length(p)*.05+fbm(p*.3);\n}\n\nfloat HenyeyGreenstein(float g, float mu) {\n  float gg = g * g;\n\treturn (1.0 / (4.0 * pi))  * ((1.0 - gg) / pow(1.0 + gg - 2.0 * g * mu, 1.5));\n}\n\nvec4 iqcloud(vec3 ro, vec3 rd)\n{\n    vec4 sum = vec4(0.0);\n\n    float tmin = (352. - ro.y) / rd.y;\n    float tmax = (672. - ro.y) / rd.y;\n    if (tmin < 0.0 || tmin > 900.) return sum;\n    tmax = min(tmax, 900.);;\n    \n    float t = tmin;\n    if (t > tmax) return vec4(0);\n    for(int i=0; i<32; ++i)\n    { \n        vec3  pos = ro + t*rd; \n        vec4  v = cloudsMap( pos); \n        float den = min(v.x / 10.0, 0.5);\n        float phase = HenyeyGreenstein(0.3, dot(rd, sun_direction));\n        float dt = 0.01*t;\n        if( den>0.01 ) \n        { \n            vec4 lightV = cloudsMap( pos+sun_direction*30.0);\n            float kk = lightV.x;\n            float sha = (1.0-smoothstep(-50.0,50.0,kk)) * 1.2;\n            //sha = pow(smoothstep(-2.0,2.0,ld.x), 1.);\n            \n            vec3 nor = normalize(v.yzw);\n            float dif = clamp( 0.4+0.6*dot(nor,sun_direction), 0.0, 1.0); \n            float occ = 0.2+0.7*max(1.0-kk/30.0,0.0) + 0.1*(1.0-den);\n            //occ = 1.0;\n            // lighting\n            vec3 lin  = vec3(0.0);\n                 //lin += skyColor*0.2*(0.5-0.5*nor.y)*occ;\n                 lin += getSunColor(sun_direction)*0.9*(0.5-0.5*nor.y)*occ;\n                 lin += getSunColor(sun_direction)*2.0*dif*occ*sha + 0.1;\n                 //lin *= 4. * phase;\n\n            // color\n            //lin *= 0.3;\n\n            //col *= lin;\n\n            //col = fog( col, t );\n\n            // front to back blending    \n            float alp = clamp(den / dt,0.0,1.0);\n            lin.rgb *= alp;\n            sum = sum + vec4(lin,alp)*(1.0-sum.a);           \n        }\n        else \n        {\n            dt = abs(den) + 3.;\n\n        }\n        float frame = float(iFrame % 64);\n        //float offset = fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)) + float(iFrame % 64));\n        float offset = texture(iChannel1, pixel / 1024.0f).r;\n        offset = fract(offset + float(frame) * 0.61803398875f) + hash(t);\n        //rayHitTime * ((float(i)+startRayOffset) / float(c_numRayMarchSteps));\n        t += dt;\n        t += 0.3 * offset;\n        if( sum.a>0.99 || t>tmax ) break;\n    }\n    \n    //resT = min(resT, (150.0-ro.y)/rd.y );\n    //if( lastT>0.0 ) resT = min(resT,lastT);\n    //if( lastT>0.0 ) resT = mix( resT, lastT, sum.w );\n    \n    \n    //sum.xyz += max(0.0,1.0-0.0125*thickness)*vec3(1.00,0.60,0.40)*0.3*pow(clamp(dot(sun_direction,rd),0.0,1.0),32.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 position = fragCoord.xy / max(iResolution.x, iResolution.y) * 2.0;\n\tvec2 lightPosition = iMouse.xy / iResolution.xy * 2.0 + ((iMouse.x + iMouse.y) == 0.0 ? vec2(1.0, 0.4) : vec2(0.0));\n    pixel = fragCoord;\n\t// rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n    float ratio = iResolution.x / iResolution.y;\n    \n    float angle = mod(iTime * 1.2, 2.0 * pi);\n    vec3 lp = vec3(0, sin(angle), cos(angle));\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= ratio;\n    vec3 p = vec3(uv - vec2(0.5), -1.);\n    p = rot * p;\n    p = normalize(p);\n\t\n\tvec3 color = getAtmosphericScattering(p, lp) * pi;\n    \n    sun_direction = lp;\n    \n\tcolor = jodieReinhardTonemap(color);\n    //color = getSunColor(lp);\n    color = pow(color, vec3(2.2)); //Back to linear\n    //color += iqcloud(vec3(0), p).xyz;\n    vec4 iqcol = iqcloud(vec3(0, 0, 0), p);\n    \n\tif (abs(p.y) < 0.01) color = vec3(0);\n\tfragColor = vec4(getSunColor(sun_direction), 1.0 );\n    fragColor = vec4(color, 1.0 ) + iqcol * iqcol.a;\n\n}","name":"Image","description":"","type":"image"}]}