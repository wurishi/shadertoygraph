{"ver":"0.1","info":{"id":"MldBWX","date":"1546313773","viewed":183,"name":"Kaleidescopia","username":"WB","description":"Raymarching a 4D gradient noise field.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SAMPLES 8\n#define STEP_SIZE 0.4\n#define NOISE_SIMPLEX_1_DIV_289 0.00346020761245674740484429065744\n#define _Radius 1.0\n#define _FoV 45.0\n#define _Deg2Rad 0.01745329\n\nconst float _Freq = 10.0;\nconst float _Timescale = 0.1;\n\n//-------------------------------------------------------------------\n// Description : Array and textureless GLSL 4D simplex\n//               noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//-------------------------------------------------------------------\n\nfloat mod289(float x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nfloat permute(float x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec3 permute(vec3 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n{\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p, s;\n\tp.xyz = floor( fract(j * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot( abs(p.xyz), ones.xyz );\n\t\n\t// GLSL: lessThan(x, y) = x < y\n\t// HLSL: 1 - step(y, x) = x < y\n\ts = vec4(\n\t\t1.0 - step(0.0, p)\n\t);\n\tp.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www; \n\t\n\treturn p;\n}\n\n//4D\nfloat snoise(vec4 v)\n{\n\tconst vec4 C = vec4(\n\t\t0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t0.276393202250021, // 2 * G4\n\t\t0.414589803375032, // 3 * G4\n\t -0.447213595499958  // -1 + 4 * G4\n\t);\n\n// First corner\n\tvec4 i = floor(\n\t\tv +\n\t\tdot(\n\t\t\tv,\n\t\t\tvec4(0.309016994374947451) // (sqrt(5) - 1) / 4\n\t\t)\n\t);\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp(i0, 0.0, 1.0);\n\tvec4 i2 = clamp(i0-1.0, 0.0, 1.0);\n\tvec4 i1 = clamp(i0-2.0, 0.0, 1.0);\n\n\t//\tx0 = x0 - 0.0 + 0.0 * C.xxxx\n\t//\tx1 = x0 - i1  + 1.0 * C.xxxx\n\t//\tx2 = x0 - i2  + 2.0 * C.xxxx\n\t//\tx3 = x0 - i3  + 3.0 * C.xxxx\n\t//\tx4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n// Permutations\n\ti = mod289(i); \n\tfloat j0 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute(i.w) + i.z\n\t\t\t) + i.y\n\t\t) + i.x\n\t);\n\tvec4 j1 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute (\n\t\t\t\t\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 )\n\t\t\t\t) + i.z + vec4(i1.z, i2.z, i3.z, 1.0 )\n\t\t\t) + i.y + vec4(i1.y, i2.y, i3.y, 1.0 )\n\t\t) + i.x + vec4(i1.x, i2.x, i3.x, 1.0 )\n\t);\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\tconst vec4 ip = vec4(\n\t\t0.003401360544217687075, // 1/294\n\t\t0.020408163265306122449, // 1/49\n\t\t0.142857142857142857143, // 1/7\n\t\t0.0\n\t);\n\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(\n\t\tdot(p0, p0),\n\t\tdot(p1, p1),\n\t\tdot(p2, p2),\n\t\tdot(p3, p3)\n\t));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt( dot(p4, p4) );\n\n// Mix contributions from the five corners\n\tvec3 m0 = max(\n\t\t0.6 - vec3(\n\t\t\tdot(x0, x0),\n\t\t\tdot(x1, x1),\n\t\t\tdot(x2, x2)\n\t\t),\n\t\t0.0\n\t);\n\tvec2 m1 = max(\n\t\t0.6 - vec2(\n\t\t\tdot(x3, x3),\n\t\t\tdot(x4, x4)\n\t\t),\n\t\t0.0\n\t);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\t\n\treturn 49.0 * (\n\t\tdot(\n\t\t\tm0*m0,\n\t\t\tvec3(\n\t\t\t\tdot(p0, x0),\n\t\t\t\tdot(p1, x1),\n\t\t\t\tdot(p2, x2)\n\t\t\t)\n\t\t) + dot(\n\t\t\tm1*m1,\n\t\t\tvec2(\n\t\t\t\tdot(p3, x3),\n\t\t\t\tdot(p4, x4)\n\t\t\t)\n\t\t)\n\t);\n}\n\nvec3 raySample(vec3 position)\n{\n    vec3 value = vec3(0.0);\n    \n    float t = _Timescale * iTime;\n    \n    float div = snoise(vec4(position * snoise(vec4(position + 16.0, t)) * 1.0, t));\n    value.r = snoise(vec4(position*div, t));\n    value.g = snoise(vec4(position*div + 4.0, t));\n    value.b = snoise(vec4(position*div + 8.0, t));\n    value = abs(value);\n    value = clamp(value, 0.0, 1.0);\n\n    return value;\n}\n\n//Transfer function\nvec3 rayIntegral(vec3 position, vec3 direction)\n{\n    vec3 integral;\n\n    for(int i = 0; i < NUM_SAMPLES; i++)\n    {\n        integral += raySample(position) * STEP_SIZE;\n\n        position += direction * STEP_SIZE;\n    }\n\n    return integral;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 rayOrigin = vec3(0.0);\n    \n    //Compute eye vector from field of view\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan((_FoV/2.0) * _Deg2Rad);    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n        \n    vec3 col = vec3(1.0);\n    \n    col = rayIntegral(rayOrigin, rayDir);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}