{"ver":"0.1","info":{"id":"wdfBWs","date":"1589259581","viewed":91,"name":"lr94/asteroidProto","username":"lucasrumney94","description":"Look-Dev for an asteroids project I am currently working on. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["asteroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_RAYMARCH_DISTANCE = 100.;\nconst int MAX_RAYMARCH_STEPS = 100;\nconst float EPSILON = 0.0001;\nconst float VERTICAL_FOV = 45.0;\n\n//Phong Parameters\nconst float ambientReflectionConstant = 1.;\nconst float ambientLightingLevel = 1.3;\nconst float diffuseReflectionConstant = .8;\nconst float diffuseLightingLevel = .9;\nconst float specularReflectionConstant = .5;\nconst float specularLightingLevel = .7;\nconst float shininess = 16.;\n\nvec3 rand3(vec3 st)\n{\n    st = vec3( dot(st, vec3(12.9898,78.233, 37.135)),\n               dot(st, vec3(325.800, 228.540, 561.121)),\n               dot(st, vec3(285.760, 189.060, 126.580)) );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n// returns from 0 to 1\nvec3 smootherstep(vec3 x){\n\treturn x*x*x*(x*(x*6.-15.)+10.);\n}\n\nfloat noise(vec3 st)\n{\n    vec3 i = floor(st);\n    vec3 fractional = fract(st);\n    \n    // Eight samples from cube corners\n    float a = dot( rand3(i), fractional );\n    float b = dot( rand3(i + vec3(1.0, 0.0, 0.0)), fractional - vec3(1.0, 0.0, 0.0) );\n    float c = dot( rand3(i + vec3(0.0, 1.0, 0.0)), fractional - vec3(0.0, 1.0, 0.0) );\n    float d = dot( rand3(i + vec3(1.0, 1.0, 0.0)), fractional - vec3(1.0, 1.0, 0.0) );\n    float e = dot( rand3(i + vec3(0.0, 0.0, 1.0)), fractional - vec3(0.0, 0.0, 1.0) );\n    float f = dot( rand3(i + vec3(1.0, 0.0, 1.0)), fractional - vec3(1.0, 0.0, 1.0) );\n    float g = dot( rand3(i + vec3(0.0, 1.0, 1.0)), fractional - vec3(0.0, 1.0, 1.0) );\n    float h = dot( rand3(i + vec3(1.0, 1.0, 1.0)), fractional - vec3(1.0, 1.0, 1.0) );\n    \n    vec3 u = smootherstep(fractional);\n    \n    float ab = mix(a, b, u.x);\n    float cd = mix(c, d, u.x);\n    float ef = mix(e, f, u.x);\n    float gh = mix(g, h, u.x);\n    float c1 = mix(ab, cd, u.y);\n    float c2 = mix(ef, gh, u.y);\n    return mix(c1, c2, u.z);\n}\n\nfloat sphere(vec3 uv, vec3 position, float radius){\n    return (distance(position, uv) - radius);\n}\n\nfloat displacedSphereSDF(vec3 samplePoint){\n\tfloat actualDistance = sphere(samplePoint, vec3(0.,0.,0.), .5);\n    float modifiedDistance = actualDistance;\n    modifiedDistance -= 0.15+0.01*sin(23.98+120.*samplePoint.y*samplePoint.x*samplePoint.z);\n    modifiedDistance -= 0.15+0.03*sin(2.*iTime+33.*samplePoint.y);\n    modifiedDistance -= 0.15+0.01*sin(123.3+14.*samplePoint.x);\n    modifiedDistance -= .2*noise(5.*samplePoint+324.4);\n    \n\treturn modifiedDistance;\n}\n\n// Defines the surfaces \n// returns the nearest distance from the provided position to the scene's surfaces\nfloat sceneSDF(vec3 samplePoint){\n    float largeSphere = sphere(samplePoint, vec3(0.,0.,0.), .5);\n\n    return displacedSphereSDF(samplePoint);\n}\n\n\n\nfloat rayMarch(vec3 cameraPoint, vec3 cameraRay){\n\tvec3 samplePoint = cameraPoint;\n    float depth = 0.;\n\n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++){\n        float closestDistance = sceneSDF(samplePoint);\n        // If we are close enough\n        if (closestDistance < EPSILON){\n        \tbreak;\n        }\n        depth += closestDistance;\n        // If we have exhausted the raymarching\n        if (depth > MAX_RAYMARCH_DISTANCE) {\n            depth = 0.;\n            break;\n        }\n        // March the Sample Point forward by the closestDistance\n        samplePoint += (closestDistance)*cameraRay;  \n    }\n            \n    // 0. cameraPoint INSIDE the SDF\n    // +f distance to the surface\n    return depth; // pointOnShape\n}\n\nvec3 getNormal(vec3 position){\n\tvec3 normal = vec3(0.);\n    \n    vec3 x1Sample = position+vec3(EPSILON, 0.,0.);\n    vec3 x2Sample = position-vec3(EPSILON, 0.,0.);\n    float x1SampleDistance = sceneSDF(x1Sample);\n    float x2SampleDistance = sceneSDF(x2Sample);\n    normal.x = x1SampleDistance-x2SampleDistance;\n    \n    vec3 y1Sample = position+vec3(0.,EPSILON,0.);\n    vec3 y2Sample = position-vec3(0.,EPSILON,0.);\n    float y1SampleDistance = sceneSDF(y1Sample);\n    float y2SampleDistance = sceneSDF(y2Sample);\n    normal.y = y1SampleDistance-y2SampleDistance;\n    \n    vec3 z1Sample = position+vec3(0.,0.,EPSILON);\n    vec3 z2Sample = position-vec3(0.,0.,EPSILON);\n    float z1SampleDistance = sceneSDF(z1Sample);\n    float z2SampleDistance = sceneSDF(z2Sample);\n    normal.z = z1SampleDistance-z2SampleDistance;\n    \n    return normalize(normal);\n}\n\nvec3 cameraRayFromFrag(float vFoVDegrees, vec2 fragCoord){\n\t\n    // Remap coordinate (0,0) to center of screen\n    fragCoord = fragCoord-iResolution.xy/2.;\n    \n    float z = iResolution.y / tan(radians(vFoVDegrees) / 2.);\n\n    vec3 cameraRay = vec3(fragCoord.x, fragCoord.y, -z);\n    return normalize(cameraRay);\n}\n\nfloat phong(vec3 pointOnSurface, vec3 normal, vec3 cameraPoint, vec3 lightPoint){\n    \n    float ambient = ambientReflectionConstant*ambientLightingLevel;\n    vec3 L = normalize(lightPoint-pointOnSurface);\n    float diffuse = diffuseReflectionConstant*dot(L,normal)*diffuseLightingLevel;\n    \n    vec3 R = normalize(reflect(-L, normal));\n    vec3 view = normalize(cameraPoint-pointOnSurface);\n    float reflectionFactor = dot(R, view);\n    float specular = 0.;\n    if (reflectionFactor > 0.){\n    \tspecular = specularReflectionConstant*pow(dot(R, view), shininess)*specularLightingLevel;\n    }\n    \n    return ambient+diffuse+specular;\n}\n\nvec3 asteroidShader(vec3 pointOnSurface, vec3 normal){\n\t\n    vec3 outputColor = vec3(0.); \n    //float threshold = step(1.1, length(pointOnSurface));\n    \n    float elevation = clamp((length(pointOnSurface)-.87)*3.03, 0., 1.);\n    float slope = length(cross(pointOnSurface, normal));\n    float slopeElevbyElev = pow(mix(elevation, 1.-slope, elevation),2.);\n    outputColor = mix(vec3(0.02,.01,0.),\n                      vec3(.8,.6,.3), \n                      slopeElevbyElev);\n    \n\n    \n    //.87 to 1.1\n    \n    return outputColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // Grey Background\n    vec3 col = vec3(0.2);\n    \n\t\n    vec3 cameraPoint = vec3(0.,0.,5.);\n    vec3 cameraRay = cameraRayFromFrag(VERTICAL_FOV, fragCoord);\n    float rayMarchDistance = rayMarch(cameraPoint, cameraRay);\n    vec3 pointOnSurface = cameraPoint+cameraRay*rayMarchDistance;\n    vec3 normal = getNormal(pointOnSurface);\n    vec3 lightPoint = vec3(cos(1.3*iTime),2.,2.+sin(1.1*iTime));\n    \n    float phongLighting = phong(pointOnSurface,normal,cameraPoint,lightPoint);\n    vec3 asteroidShaderColor = asteroidShader(pointOnSurface, normal);\n    \n    col = mix(col, phongLighting*asteroidShaderColor, clamp(rayMarchDistance, 0., 1.));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}