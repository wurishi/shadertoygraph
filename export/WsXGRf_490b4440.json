{"ver":"0.1","info":{"id":"WsXGRf","date":"1546952192","viewed":370,"name":"Orthographic Projection X","username":"fserreau","description":"Une projection orthographique est une projection cartographique azimutale. C'est une projection de perspective par laquelle une sphère est projetée sur un plan tangent. Le point de perspective est à une distance infinie. ","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["ortho"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795    \n#define M_HALF_PI (M_PI / 2.0)\n#define M_2PI (M_PI * 2.0)\n\n// retourne la longitude dans l'interval [-PI, +PI]\n//\nfloat normalizeLongitude(float longitudeInRadians)\n{\n    return mod(longitudeInRadians + M_PI, M_2PI) - M_PI;\n}\n\nvec4 blackBackground()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);    // Noir   \n}\n\nvec4 fogColor = vec4(0.0, 0.0, 0.0, 1.0);    \nvec4 floorColor = vec4(1.0, 0.3, 0.0, 1.0);\n\n\nvec4 degradeBackground(vec2 uv)\n{\n   if (uv.y < 0.0)\n   {\n\t\tfloat dist = (-uv.y);\n\t\treturn mix(fogColor, floorColor, dist);\n\t}\n    else\n    {\n        return fogColor;\n    }    \n}\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) {\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\nvec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n    \n    vec2 diff = center-uv;\n    float len = length(diff);\n\n    len += variation(diff, vec2(0.0, 1.0), 1.0, 2.0);\n    len -= variation(diff, vec2(1.0, 0.0), 1.0, 2.0);\n    \n    float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n    return vec3(circle);\n}\n\n//---------------------------------------------------------\n// draw circle at pos with given radius and halo\n//---------------------------------------------------------\nfloat circle(vec2 uv, vec2 pos, float radius, float halo)\n{\n  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 color1 = vec3(235.0/255.0, 1.0, 1.0);\n    vec3 color2 = vec3(42.0/255.0, 61.0/255.0, 108.0/255.0);\n    \n\n    \n    // Reverse Formula first \n\n    // earth radius        \n    float R = 1.0;\t\t\t\n\n    /*\n    float xm = - iMouse.x / iResolution.x * M_PI;\n    float ym = - iMouse.y / iResolution.y * M_PI;    \n    float zm = - iMouse.z / iResolution.x * M_PI;        */\n    \n    // longitude du centre de la projection en radians\n   \tfloat lambda0 = iTime * 0.1;\t\n    \n    // latitude du centre de la projection en radians             \n    float phi1 = 0.4;\t\n    \n    // Zoom\n    float zoom = 0.9;\n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    float circ = circle(uv, vec2(0.5, 0.5), 3.0, 0.5);    \n    \n    // On passe sur l'interval [-R, +R]\n    uv -= 0.5;\n    uv.x *= (R * 2.0);    \n    uv.y *= (R * 2.0);\n\n    float x = uv.x * 1.0/zoom * aspectRatio;\n    float y = uv.y * 1.0/zoom;\n    \n    float p = sqrt(x*x + y*y);\n    float c = asin(p/R);\n    \n    float cosC = cos(c);\n    float sinC = sin(c);\n    \n    // On teste si cos C est positif\n    if (cosC >= 0.0)\n    {\n       \tfloat lambda = normalizeLongitude(lambda0 + (atan((x * sinC) / (p * cos(phi1) * cosC - y * sin(phi1) * sinC))));\n        float phi = asin(cosC * sin(phi1) + (y * sinC * cos(phi1)) / p);\n        \n        // on passe de l'interval [-PI, +PI, M_HALF_PI, +M_HALF_PI] \n        // à l'interval [0..1] de la texture\n        vec2 xy = vec2(lambda / M_2PI, phi / M_PI);\n        xy += 0.5;\n/*\n  \t\tlen += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n    \tlen -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);        \n        */\n        \n        vec3 col0 = vec3(170.0/255.0, 218.0/255.0, 1.0); //textureLod(iChannel0, xy, 1.0).rgb;\n        vec3 col1 = textureLod(iChannel1, xy, 1.0).rgb; \n        \n        \n        // \n        col0 = vec3(0.3, 0.3, 0.3);\n        \n        col0 = textureLod(iChannel0, xy, 1.0).rgb;\n        \n\n       \n        fragColor += vec4(col1, 1.0);\n        fragColor += vec4(col0, 1.0);        \n   //    \n      \n    }\n    else\n    {\n\t\tfragColor = vec4(mix(color1, color2, circ), 1.0);    //degradeBackground(uv);                  \n        \n  \t\tuv = fragCoord/iResolution.xy;   \n        uv.x *= aspectRatio;\n        uv.x -= 0.39;\n        \n    \tvec3 color;\n    \tfloat radius = 0.5 * zoom;\n    \tvec2 center = vec2(0.5);\n    \n        \n        // ==> https://www.shadertoy.com/view/ltBXRc\n        /*\n    \t//paint color circle\n    \tcolor = paintCircle(uv, center, radius, 0.05);\n    \n    \t//color with gradient\n    \tvec2 v = rotate2d(iTime) * uv;\n   \t\tcolor *= vec3(v.x, v.y, 0.7-v.y*v.x);\n    \n    \t//paint white circle\n    \tcolor += paintCircle(uv, center, radius, 0.01);\n        */\n        \n        fragColor += vec4(color, 1.0);                \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#version 130\n/*\nuniform vec3      iResolution;           // viewport resolution (in pixels)\nuniform float     iGlobalTime;           // shader playback time (in seconds)\n//uniform int       iGlobalFrame;          // shader playback frame\n//uniform float     iChannelTime[4];       // channel playback time (in seconds)\n//uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\nuniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\nuniform sampler2D iChannel0;          // input channel. XX = 2D/Cube\n//uniform vec4      iDate;                 // (year, month, day, time in seconds)\n//uniform float     iSampleRate;           // sound sample rate (i.e., 44100)\n\nuniform vec2      iGridOffsets;\n\nvarying highp vec2 qt_TexCoord0;\nuniform lowp float qt_Opacity;\n*/\nconst float PI = 3.1415926535897932384626433832795;\nconst float HALF_PI = 1.57079632679;\nconst float  TWO_PI = 6.28318530718;\nconst vec2 HD = vec2(1920.0, 1200.0);\n\n\n\n/*************************************************************************************\n\n        INITIALIZE\n\n*************************************************************************************/\n\n\n//\t\t[0..width, 0..height]\nconst int REF_PIXELS = 0;\n//\t\t[0..width, height.. 0]\nconst int REF_PIXELS_INVERTED = 1;\n//\t\t[-0.8..+0.8, -0.5..+0.5]\nconst int REF_CENTERED = 2;\n// \t\t[0..1, 0..1]\nconst int REF_LINEAR = 3;\n\nstruct TContext\n{\n    vec3 resolution;\n        vec2 uv;\n        float aspect;\n        vec2 ratio;\n        vec2 uvc;\n    vec2 fragCoord;\n    vec4 fragColor;\n    float time;\n};\n\nstruct TGraphics {\n    vec4 fragColor;\n};\n\nTContext initialize(vec2 fragCoord, vec3 resolution, float time)\n{\n    TContext ctx;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    ctx.uv = fragCoord/resolution.xy;\n    ctx.aspect = resolution.x / resolution.y;   // aspect ratio x/y\n        ctx.ratio = vec2(ctx.aspect, 1.0);              // aspect ratio (x/y,1)\n        ctx.uvc = (2.0 * ctx.uv - 1.0) * ctx.ratio;       // -1.0 .. 1.0\n    ctx.fragCoord = fragCoord;\n    ctx.resolution = resolution;\n    ctx.fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ctx.time = time;\n\n    return ctx;\n}\n\n\n\nvec2 reference(in TContext ctx, int ref)\n{\n//    if (ref == REF_PIXELS)\n        return vec2(0.0, ctx.resolution.y) - ctx.fragCoord * vec2(-1.0, 1.0);\n/*\n    else if (ref == REF_CENTERED)\n        return ctx.uvc;\n    else if (ref == REF_LINEAR)\n        return ctx.uv;\n\n        return ctx.uv;*/\n}\n\n/*************************************************************************************\n\n        BACKGROUNDS\n\n*************************************************************************************/\n\nstruct TBackground\n{\n    vec3 color;\n};\n\nstruct TGridBackground\n{\n    float gridStep;\n    float lineWidth;\n    vec2 offsets;\n    vec4 color;\n//    bool\n};\n\nstruct TVerticalGradiantBackground\n{\n        vec3 topColor;\n        vec3 bottomColor;\n};\n\nstruct THorizontalGradiantBackground\n{\n        vec3 leftColor;\n        vec3 rightColor;\n};\n\n\nstruct TMist {\n    vec3 color1;\n    vec3 color2;\n    vec3 color3;\n    vec3 color4;\n    float p;\n};\n\n\n/*************************************************************************************\n\n        SHAPES\n\n*************************************************************************************/\n\n\nstruct Coordinate {\n    vec2 pos;\n    int ref;\n};\n\nstruct TPoint\n{\n    vec2 center;\n    float blur;\n    vec4 color;\n    int ref;\n};\n\nstruct TCircle\n{\n    vec2 center;\n    float radius;\n    float blur;\n    int ref;\n};\n\nstruct TSquircle\n{\n    vec2 center;\n        float radius;\n        float power;\n    int ref;\n};\n\nstruct TArcAngle\n{\n    vec2 center;\n    float startAngle;\n    float endAngle;\n    float radius1;\n    float radius2;\n    float blur;\n    int ref;\n};\n\nstruct TLine {\n    vec2 pointA;\n    vec2 pointB;\n    float radius;\n    int ref;\n};\n\nstruct TSegment {\n    vec2 pointA;\n    vec2 pointB;\n    float radius;\n    int ref;\n};\n\nstruct TRectangle {\n    vec2 pos;\n    vec2 size;\n    int ref;\n};\n\nstruct TRing {\n    vec2 center;\n        float radius;\n        float thick;\n    int ref;\n};\n\nstruct TNGon {\n    vec2 center;\n    float n;\n    float radius;\n    int ref;\n};\n\n\nfloat toShape(TContext ctx, TGridBackground g)\n{\n    float sx = g.gridStep;\n    float sy = g.gridStep;\n\n    float cx = gl_FragCoord.x + g.offsets.x;\n\n        float h = floor(cx / sx) * sx;\n        float c = step(cx, h + g.lineWidth);\n        float d = step(h - g.lineWidth, cx);\n\n    float cy = gl_FragCoord.y + g.offsets.y;\n\n    h = floor(cy / sy) * sy;\n        float e = step(cy, h + g.lineWidth);\n        float f = step(h - g.lineWidth, cy);\n\n    return (c * d + e * f);\n/*\n    if (ctx.fragCoord.x > 200.0)\n        return 0.0;\n\n    return 1.0; //    return step(ctx.fragCoord.x, 10.0);*/\n}\n\nfloat toShape(in TContext ctx, in TSegment seg)\n{\n        vec2 g = seg.pointB - seg.pointA;\n        vec2 h = reference(ctx, seg.ref) - seg.pointA;\n        float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n        return smoothstep(seg.radius, 0.5*seg.radius, d);\n}\n\nvec3 toColor(float shape, vec3 colorIn, vec3 colorOut)\n{\n        return (shape) * vec3(mix(colorIn, colorOut, shape));\n}\n\n//---------------------------------------------------------\n// draw segment line from point A to point B and radius r\n// see also sdCapsule(p,a,b,r) from inigo quilez\n// https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------\nfloat segment(vec2 P, vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  vec2 h = P - A;\n  float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n  return smoothstep(r, 0.5*r, d);\n}\n\n/*************************************************************************************\n\n        DRAWING FUNCTIONS\n\n*************************************************************************************/\n\n//void draw(out TContext ctx, in TSegment segment, vec4 color)\n//{\n//\tctx.fragColor += vec4(toColor(toShape(ctx, segment) * color.a, color.rgb, color.rgb), 1.);\n//}\n\n//void draw(out TContext ctx, in TArcAngle arcAngle, vec4 color)\n//{\n//\tctx.fragColor += vec4(toColor(toShape(ctx, arcAngle) * color.a, color.rgb, color.rgb), 1.);\n//}\n\nvoid draw(out TContext ctx, TVerticalGradiantBackground background)\n{\n    //background\n    vec3 bgCol = mix(background.bottomColor, background.topColor, clamp(ctx.uv.y * 2., 0.0, 1.0));\n\n    ctx.fragColor += vec4(bgCol, 1.0);\n}\n\nvoid draw(out TContext ctx, TGridBackground grid)\n{\n        float s = toShape(ctx, grid);\n\n    vec3 col = grid.color.rgb * s * grid.color.a;\n\n    ctx.fragColor += vec4(col, 1.);\n\n//    gl_FragColor += vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //coords\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\n    // INITIALISATION\n    /////////////\n\n   // vec2 fc = vec2(gl_FragCoord.x, gl_FragCoord.y);\n\n    TContext ctx = initialize(fragCoord, iResolution, iTime);\n\n    // BACKGROUND\n    /////////////\n\n    vec3 bgColorTop = vec3(0.0, 0.0, 0.0);\n    vec3 bgColorBottom = vec3(0.05, 0.1, 0.05);\n\n    TVerticalGradiantBackground background = TVerticalGradiantBackground(bgColorTop, bgColorBottom);\n\n    // GRIDS\n    /////////////\n\n    float gridAlpha = 0.25;\n    vec2 gridOffsets = vec2(0.0, 0.0);\n  //  vec2 gridOffsets = vec2(iGlobalTime * 250.0, 0.0);\n    vec4 gridColor = vec4(0.0, 1.0, 0.0, 1.0/*gridAlpha*/);\n\n    float largeCellHeight = iResolution.y / 2.0;\n    float smallCellHeight = iResolution.y / 20.0;\n\n    TGridBackground smallGrid = TGridBackground(20.0, 1.0, gridOffsets, gridColor);\n    TGridBackground largeGrid = TGridBackground(100.0, 2.0, gridOffsets, gridColor);\n\n//    draw(ctx, background);\n    draw(ctx, smallGrid);\n    draw(ctx, largeGrid);\n\n    fragColor = ctx.fragColor;\n}\n/*\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x/iResolution.y;        \n    \n    \n    float dx = iResolution.x / 400.0;\n    float dy = iResolution.y / 400.0 * (aspectRatio);    \n\n    \n    if (mod(fragCoord.x + dx/2.0, iResolution.x / 9.0) < dx)\n    {\n        fragColor = vec4(0, 1, 0, 0);\n    }\n    \n    if (mod(fragCoord.y + dy/2.0, iResolution.y / 6.0) < dy)\n    {\n        fragColor = vec4(0, 1, 0, 0);\n    }  \n}\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n/****************************************************************\n\n  COLORS\n\n*****************************************************************/\n\n\n//sepia colour, adjust to taste\nconst vec3 SEPIA = vec3(1.2, 1.0, 0.8); \n\nfloat toGrayScale( vec4 color)\n{\n\tfloat gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n    \n    return gray;\n}\n\nvec3 toSepia(vec4 color)\n{\n\t//create our sepia tone from some constant value\n\tvec3 sepiaColor = vec3(toGrayScale(color)) * SEPIA;    \n    \n    return sepiaColor;\n}\n\n\n/****************************************************************\n\n  MATH\n\n*****************************************************************/\n\n\n#define left -2.2\n#define right 2.2\n#define bottom -2.2\n#define top 2.2\n#define pi 3.14159265359\n#define blurIterations 24\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, -dot(r, eye)),\n        vec4(u, -dot(u, eye)),\n        vec4(-f, -dot(f, eye)),\n        vec4(0., 0., 0., 1.));\n}\n\nconst mat4 proj = mat4(\n\tvec4(2. / (right - left), 0., 0., -(right + left) / (right - left)),\n    vec4(0., 2. / ( top - bottom), 0., -(top + bottom) / (top - bottom)),\n    vec4(0., 0., 0., 0.),\n    vec4(0., 0., 0., 1.)\n);\n\nmat4 rotateY(float rads)\n{\n    return mat4(\n        vec4(cos(rads), 0., sin(rads), 0.),\n        vec4(0., 1., 0., 0.),\n        vec4(-sin(rads), 0., cos(rads), 0.),\n        vec4(0.)\n    );\n}\n\nfloat ease(float t)\n{\n    return t < .5 ? 4. * pow(t, 3.) : (t - 1.) * (2. * t - 2.) * (2. * t - 2.) + 1.;\n}\n\n\n/****************************************************************\n\n  GEOMETRY\n\n*****************************************************************/\n\nfloat Circle(vec2 uv, vec2 pos, float r, float blur) {\n    return smoothstep(r, r - blur, length(uv - pos));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main2( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy*3.;\n    // st += st * abs(sin(iTime*0.1)*3.0);\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 0.00*iTime);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*iTime );\n    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*iTime);\n\n    float f = fbm(st+r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n  //  vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    main2(fragColor, fragCoord);\n    \n    \n    // Output to screen\n  //  fragColor = vec4(col,1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}