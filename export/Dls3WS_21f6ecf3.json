{"ver":"0.1","info":{"id":"Dls3WS","date":"1672410050","viewed":133,"name":"Spherical Video Projector","username":"wagyx","description":"The texture is projected onto the scene from the light position.\nThe mouse sets where the center of the image should lie in the scene.\nWorks for sampler2D tetxure and for samplerCubemap (see lines 247 to 252)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["texture","light","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n*/\n\n\n/**\nRAYMARCHING ALGORITHM\nfrom  Ray Marching: Part 2 by jfwong : https://www.shadertoy.com/view/lt33z7\nfrom  Raymarching - Primitives by iq : https://www.shadertoy.com/view/Xds3zN\n*/\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653589793;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\nfloat sdPlane( vec3 p ){\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s ){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat opU( float d1, float d2 ) {\n\treturn min(d1,d2);\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size * 0.5;\n    float z = size.y / tan(radians(fieldOfView) * 0.5);\n    return normalize(vec3(xy, z));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float res = 1e10;\n    res = opU(res, sdSphere(samplePoint-vec3(1.0,0.5,-1.), 0.5));\n    res = opU(res, sdBox(samplePoint-vec3(-1.0,0.5,1.), vec3(0.5,0.5,0.5)));\n    \n    float size=2.;\n    float thickness=0.01;\n    res = opU(res, sdBox(samplePoint-vec3(0.0,0.0,0.0),vec3(size,thickness,size)));\n    res = opU(res, sdBox(samplePoint-vec3(0.0,2.*size,0.0),vec3(size,thickness,size)));\n    res = opU(res, sdBox(samplePoint-vec3(-size,size,0.0),vec3(thickness,size,size)));\n    res = opU(res, sdBox(samplePoint-vec3(size,size,0.0),vec3(thickness,size,size)));\n    res = opU(res, sdBox(samplePoint-vec3(0.0,size,size),vec3(size,size,thickness)));\n    return res;\n}\n\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n///////////////////////////////////////////////////////////\n//SOME MATHS FOR ROTATIONS\n/////////////////////////////////////////////////////\n\n// taken from https://www.shadertoy.com/view/WtjcDt\nmat3 rotationMatrix(vec3 axis, float cosAngle, float sinAngle) {\n    float s = sinAngle;\n    float c = cosAngle;\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    // taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    // angle = radians(angle);\n    //axis = normalize(axis);\n    float c = cos(angle);\n    float s = sin(angle);\n    return rotationMatrix(axis, c, s);\n}\n\n//taken from https://www.shadertoy.com/view/WtjcDt\nvec3 apply_rot(mat3 r, vec3 p) {\n    return r*p;\n}\n\nvec3 rotateVectorFromRef(vec3 view, vec3 direction, vec3 refDirection) {\n    vec3 axis = cross(refDirection,direction);\n    float sinAngle = length(axis);\n    float cosAngle = dot(refDirection,direction);\n    axis /= sinAngle;\n    mat3 mat = rotationMatrix(axis, cosAngle, sinAngle);\n    return apply_rot(mat,view);\n}\n\n\n\n///////////////////////////////////////////////////////////\n// LIGHTS\n///////////////////////////////////////////////////////////\n\nvec3 cart2sph(vec3 cart) {\n    // cartesian z is up\n    //sph is radius, inclination (from z), azimuth\n    vec3 sph = cart*cart;\n    sph.y = sph.x+sph.y;\n    sph.x = sqrt(sph.z+sph.y);\n    sph.y = atan(sqrt(sph.y), cart.z);\n    sph.z = atan(cart.y, cart.x);\n    sph.z = mod(sph.z,2.*PI);\n    return sph;\n}\n\nvec3 sph2cart(vec3 sph) {\n    // cartesian z is up\n    // sph is radius, inclination (from z), azimuth\n    vec3 cart;\n    cart.x = sin(sph.y);\n    cart.z = sin(sph.z);\n    cart.y = cart.x * cart.z * sph.x;\n    cart.z = cos(sph.z);\n    cart.x *= cart.z * sph.x;\n    cart.z = cos(sph.y) * sph.x;\n    return cart;\n}\n\nvec3 sphericalProjectorForImg(vec3 view, sampler2D img) {\n    vec3 sph = cart2sph(view.zxy);\n    //azimuth is at z maps to uv x, inclination is at y and maps to uv y\n    // and scale to [0,1[\n    vec2 uv = sph.zy / vec2(2.*PI,PI); \n    return texture(img, uv).xyz;\n    //return vec3(floor(8.*uv.xy)/8.,0.);\n}\n\nvec3 sphericalProjectorForCubemap(vec3 view, samplerCube img) {\n    return texture(img, view.xzy).xyz;\n}\n\n////////////////////////////////////////////////////////\n// MAIN\n////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 camPos = vec3(0.,2.,-6.);\n    float camFov = 90.0;\n    Ray ray = Ray(camPos, rayDirection(camFov, iResolution.xy, fragCoord));\n    // compute intersection of camera ray with the scene\n    float dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0,0.0,0.0, 1.0);\n        return;\n    }\n    vec3 hitPoint = ray.origin + dist * ray.direction;\n    vec3 hitPointNormal = estimateNormal(hitPoint);\n    // adds a first point light on the camera so that we can still see things even outside of the second light range\n    //vec3 col = vec3(1.0)*dot(hitPointNormal, -ray.direction)/(dist*dist);\n    vec3 col = vec3(0.);\n    \n    // set the light properties of the second point light\n    vec3 lightPos = vec3(0.0,2.0,0.0);\n    float lightLum = 3.;\n    \n    \n    // user driven light\n    ray = Ray(camPos, rayDirection(camFov, iResolution.xy, iMouse.xy));\n    dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    vec3 mouseHit = ray.origin + dist * ray.direction;\n    vec3 lightAxis = normalize(lightPos-mouseHit);\n    //vec3 lightAxis = vec3(0.,1.,0.); // for debug\n    \n    // animated light\n    if (length(iMouse.xy) < 20.) {\n        lightAxis = normalize(vec3(1.,cos(iTime),sin(iTime*0.5)));\n    }\n   \n    vec3 dirToLight = lightPos-hitPoint;\n    float distToLight = length(dirToLight);\n    dirToLight = dirToLight/distToLight;\n    \n    // compute intersection of light ray with geometry and then the light intensity\n    ray = Ray(lightPos, -dirToLight);\n    dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    if (abs(dist - distToLight) < 0.001) {\n        col += \n        lightLum // the light radiance\n        \n         // use a texture for the intensity distribution\n        * sphericalProjectorForImg(rotateVectorFromRef(dirToLight,lightAxis,vec3(0.,0.,-1.)), iChannel0)\n        //* sphericalProjectorForImg(dirToLight, iChannel0) // cuncomment for default behaviour\n         // uncomment to use a cubemap instead\n        //* sphericalProjectorForCubemap(-dirToLight.xyz, iChannel1)\n        //* sphericalProjectorForCubemap(rotateVectorFromRef(dirToLight,lightAxis,vec3(0.,-1.,0.)), iChannel1)\n\n        // because it is a point light, we need to convert to irradiance\n        * dot(hitPointNormal, dirToLight)/(distToLight*distToLight);\n    }\n    \n    // Output to screen\n    //fragColor = vec4((hitPointNormal+1.)*0.5, 1.);\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"}]}