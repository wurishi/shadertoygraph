{"ver":"0.1","info":{"id":"lftcD4","date":"1730688760","viewed":98,"name":"circular tiling","username":"DjinnKahn","description":"use mouse to change parameters\n\nbased on this image in this post: https://www.facebook.com/share/p/14e9pUXvsC/","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["tiling","circular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ZOOM_LEVEL = 7.;\nconst float THICKNESS = .06;\n\nconst vec2 U = vec2( 2.*sqrt(3.), 0. );\nconst vec2 V = vec2( sqrt(3.), 3. );\nfloat PI = acos(0.) * 2.;\n\nmat2 rot( float a ) { return mat2( cos(a), sin(a), -sin(a), cos(a) ); }\nvec2 rot( vec2 p, float a, vec2 c )\n{\n    return rot( a ) * ( p - c ) + c;\n}\n\nfloat udTiling( vec2 p, float radius, float theta )\n{\n    // map p to base parallelogram (in UV coordinates)\n    vec2 q = fract( inverse( ( mat2( U, V ) ) ) * p );\n        \n    // map p to base triangle (in UV coordinates)\n    if ( dot( q, vec2( 1., 1. ) ) >= 1. )\n        q = 1. - q;\n    \n    // map to back to orthogonal coordinates\n    vec2 P = mat2( U, V ) * q;\n    \n    // split triangle in 3 kites and map P to the base kite\n    if ( dot( q, vec2( 2., 1. ) ) >= 1. && q.x > q.y )\n        P = rot( P, -2.*PI/3., (U+V)/3. );\n    else if ( dot( q, vec2( 1., 2. ) ) >= 1. )\n        P = rot( P, 2.*PI/3., (U+V)/3. );    \n                     \n    // calculate the center of one arc\n    vec2 CIRCLE_CENTER_OFFSET = rot( -1.*PI/3. ) * ( (U+V)/3. - V + rot( theta ) * vec2( radius, 0. ) );\n            \n    // find distances to each arc/ring\n    float d0 = abs( distance( P, U + CIRCLE_CENTER_OFFSET ) ) - radius;\n    float d1 = abs( distance( P, U + rot( PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    float d2 = abs( distance( P, V + rot( 2.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    float d3 = abs( distance( P, V + rot( 1.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;    \n    // small fix for the three-way intersection: \n    float d3_b = abs( distance( rot( P, 4.*PI/3., (U+V)/3. ), V + rot( 1.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    // fix when radius is large\n    float d2_b = abs( distance( rot( -PI/3. ) * P, V + rot( 2.*PI/3. ) * CIRCLE_CENTER_OFFSET ) ) - radius;\n    \n    // calculate SDF (UDF)\n    float d = 99.;\n    \n    if ( d2 > 0. || d3 < 0. || iMouse.z <= 0. )\n        d = min( d, abs( d0 ) );      \n    if ( d2 > 0. )\n        d = min( d, abs( d1 ) );\n    d = min( d, abs( d2 ) );\n    d = min( d, abs( d3 ) );\n    if ( d3 > 0. )\n        d = min( d, abs( d3_b ) );\n    \n    d = min( d, abs( d2_b ) );\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;    \n    p *= ZOOM_LEVEL;\n    \n    vec2 m = iMouse.z == 0. ? vec2( 0. ) : iMouse.xy / iResolution.xy - .5;\n    float radius = 2.45 + m.x * .9;\n    float theta = 1.8 + m.y * .3;\n    float d = udTiling( p, radius, theta );\n    \n    float feather = dFdx( p.x ) * 1.0;\n    fragColor.a = 1.;\n    fragColor.rgb = vec3( smoothstep( THICKNESS - feather, THICKNESS + feather, d ) );\n    \n    ////hollow:\n    //fragColor.rgb = vec3( 1. - smoothstep( .03, .09, d ) + smoothstep( .13, .19, d ) );\n}","name":"Image","description":"","type":"image"}]}