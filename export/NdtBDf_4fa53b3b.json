{"ver":"0.1","info":{"id":"NdtBDf","date":"1657388628","viewed":131,"name":"Exact Reuleaux Triangle SDF L2","username":"Envy24","description":"Exact Reuleaux Triangle SDF L2\nhttps://en.wikipedia.org/wiki/Reuleaux_triangle\nhttps://www.desmos.com/calculator/f4ug2lysmr","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","triangle","distance","euclid","reuleaux","l2"],"hasliked":0,"parentid":"sddBWB","parentname":"Not Exact Reuleaux Triangle SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 3.0\n#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\n/* Solution from: https://www.desmos.com/calculator/f4ug2lysmr */\nfloat ReuleauxTriangleSDF_L2(\n    vec2 NDC,\n    float R) \n{\n    float rad = sinOSC(0.0, 2.*PI, iTime * 0.5);\n    vec2 C0 = rotateAroundZ(vec2(0, 1),             rad),\n         C1 = rotateAroundZ(vec2(-0.8660254, -0.5), rad),\n         C2 = rotateAroundZ(vec2(0.8660254, -0.5),  rad);\n       \n    float t0 = clamp(findRootBisection(0.0, 1.0, C0.x, C0.y, NDC.x, NDC.y), 0.0, 1.0),\n          t1 = clamp(findRootBisection(0.0, 1.0, C1.x, C1.y, NDC.x, NDC.y), 0.0, 1.0),\n          t2 = clamp(findRootBisection(0.0, 1.0, C2.x, C2.y, NDC.x, NDC.y), 0.0, 1.0);\n          \n    float h = sqrt(3.0), k = PI/6.0,\n          theta = k*(2.0*t0+5.0), c = cos(theta), s = sin(theta),\n          x = h*(C0.x*c-C0.y*s)+C0.x, y = h*(C0.x*s+C0.y*c)+C0.y;\n          \n    float sqd0 = (x-NDC.x)*(x-NDC.x)+(y-NDC.y)*(y-NDC.y);\n    \n          theta = k*(2.0*t1+5.0); c = cos(theta); s = sin(theta);\n          x = h*(C1.x*c-C1.y*s)+C1.x; y = h*(C1.x*s+C1.y*c)+C1.y;\n          \n    float sqd1 = (x-NDC.x)*(x-NDC.x)+(y-NDC.y)*(y-NDC.y);\n    \n          theta = k*(2.0*t2+5.0); c = cos(theta); s = sin(theta);\n          x = h*(C2.x*c-C2.y*s)+C2.x; y = h*(C2.x*s+C2.y*c)+C2.y;\n    \n    float sqd2 = (x-NDC.x)*(x-NDC.x)+(y-NDC.y)*(y-NDC.y);\n    \n    float sign_ = sqd0 < 3. && sqd1 < 3. && sqd2 < 3. ? -1.0: 1.0;\n    \n    return sign_ * sqrt(min(sqd0, min(sqd1, sqd2)))-R;\n    //return abs(sign_ * sqrt(min(sqd0, min(sqd1, sqd2)))-R); // outline\n}\n/* Outline *\nfloat ReuleauxTriangleSDF_L2(\n    vec2 NDC,\n    float R) \n{\n    float rad = sinOSC(0., TAU, iTime * 0.5);\n    vec2 C0 = rotateAroundZ(vec2(0, 1),             rad), diff0 = C0 - NDC,\n         C1 = rotateAroundZ(vec2(0.8660254, -0.5),  rad), diff1 = C1 - NDC,\n         C2 = rotateAroundZ(vec2(-0.8660254, -0.5), rad), diff2 = C2 - NDC;\n \n    float angle =\n        dot(NDC, C1-C2) >= 0.0 ?\n            dot(NDC, C2-C0) >= 0.0 ?\n                0.0 :\n                -(2.*PI)/3. :\n            dot(NDC, C0-C1) >= 0.0 ?\n                (2.*PI)/3. :\n                0.0;\n       \n    NDC=rotateAroundZ(NDC, angle);\n     \n    float t = clamp(findRootBisection(0.0, 1.0, C0.x, C0.y, NDC.x, NDC.y), 0.0, 1.0); \n    float q = sqrt(3.0), g = PI/6.0,\n          theta = g*(2.0*t+5.0), c = cos(theta), s = sin(theta),\n          x = q*(C0.x*c-C0.y*s)+C0.x, y = q*(C0.x*s+C0.y*c)+C0.y;\n      \n    float minSqDist =\n        min(\n            min((x-NDC.x)*(x-NDC.x)+(y-NDC.y)*(y-NDC.y),  dot(diff0, diff0)),\n            min(dot(diff1, diff1),                        dot(diff2, diff2)) );\n\n    return sqrt(minSqDist)-R;\n}\n/**/\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    float r,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * FIELD_SCALE :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.5;\n            //vec2(0);\n            \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(ReuleauxTriangleSDF_L2(M, r));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * FIELD_SCALE;\n    float R = sinOSC(0., 2.0, iTime);\n    float minDist = ReuleauxTriangleSDF_L2(NDC, R);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, R, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI                          3.1415926535897932\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.x * s + p.y * c);\n}\n\n/*\n    (a,b) - center of circle\n    (u,v) - arbitrary point\n*/\nfloat findRootBisection(\n    float xl,\n    float xr,\n    float a,\n    float b,\n    float u,\n    float v)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    const float C0 = PI/6.0; \n          float C1 = b*b-v*b+a*a-u*a;\n          float C2 = v*a-u*b;\n    \n    float fl = C1*sin(C0*(2.*xl+5.))+C2*cos(C0*(2.*xl+5.)); // f(xl)\n    float fr = C1*sin(C0*(2.*xr+5.))+C2*cos(C0*(2.*xr+5.)); // f(xr)\n    float f = 0.5;\n\n    // Different signs?\n    if (sign(fl) == sign(fr)) { return xl; }\n\n    for (int i = 0; (i < 10) && (abs(f) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = xl+(xr-xl)*0.5;\n        float f = C1*sin(C0*(2.*x+5.))+C2*cos(C0*(2.*x+5.));\n\n        // Pick new range.\n        xr = sign(fl) != sign(f) ? x : xr;\n        xl = sign(fl) == sign(f) ? x : xl;\n        \n        fl = C1*sin(C0*(2.*xl+5.))+C2*cos(C0*(2.*xl+5.)); // f(xl)\n        fr = C1*sin(C0*(2.*xr+5.))+C2*cos(C0*(2.*xr+5.)); // f(xr)\n    }\n\n    return xl+(xr-xl)*0.5;\n}","name":"Common","description":"","type":"common"}]}