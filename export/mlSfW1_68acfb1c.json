{"ver":"0.1","info":{"id":"mlSfW1","date":"1694007691","viewed":56,"name":"Planet0","username":"sphi","description":"A 3D planet","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TAU = 3.14159265358979323846 * 2.0;\nconst float EPSILON = 0.01;\n\nconst vec3 lightAColor = vec3(1.0, 1.0, 1.0);\nconst vec3 lightANormal = normalize(vec3(4.0, 3.0, -2.0));\nconst vec3 lightBColor = vec3(0.3, 0.0, 0.2);\nconst vec3 lightBNormal = normalize(vec3(-2.0, -5.0, -1.0));\n\nconst vec3 ringNormal = normalize(vec3(0.5, 1.0, -0.2));\nconst float ringThick = 0.005;\n\nconst vec3 planetColor = vec3(0.8, 0.5, 0.2);\n\nconst vec3 moonARotAxis = normalize(vec3(0.2, 1.0, 0.3));\nconst vec3 moonAXAxis = normalize(cross(moonARotAxis, vec3(1.0, 0.0, 0.0)));\nconst vec3 moonAYAxis = normalize(cross(moonARotAxis, moonAXAxis));\nconst vec3 moonAColor = vec3(0.7, 0.7, 0.3);\n\nconst vec3 moonBRotAxis = normalize(vec3(0.15, 1.0, -0.1));\nconst vec3 moonBXAxis = normalize(cross(moonBRotAxis, vec3(1.0, 0.0, 0.5)));\nconst vec3 moonBYAxis = normalize(cross(moonBRotAxis, moonBXAxis));\nconst vec3 moonBColor = vec3(0.4, 0.6, 0.7);\n\nfloat distToLine(vec3 p, vec3 lineOrig, vec3 lineDir) {\n    float t = dot(p - lineOrig, lineDir) / dot(lineDir, lineDir);\n    vec3 closestToP = lineOrig + t * lineDir;\n    return length(p - closestToP);\n}\n\nfloat distToSphere(vec3 p, vec3 center, float size) {\n    vec3 local = center - p;\n    return sqrt(dot(local, local)) - size;\n}\n\nfloat planet(vec3 p) {\n    return distToSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n}\n\nfloat ring(vec3 p) {\n    float ringPlane = abs(dot(p * ringNormal, vec3(1)));\n    float distFromRingCenter = distToLine(p, vec3(0, 0, 0), ringNormal);\n    float ringSide = min(0.2 - abs(distFromRingCenter - 1.7), 0.0);\n    return sqrt(ringPlane * ringPlane + ringSide * ringSide) - ringThick;\n}\n\nvec3 moonAPos() {\n    float theta = iTime * TAU / 12.0;\n    float dist = 2.6;\n    return (moonAXAxis * cos(theta) + moonAYAxis * sin(theta)) * dist;\n}\n\nvec3 moonBPos() {\n    float theta = iTime * TAU / 19.0;\n    float dist = 3.1;\n    return (moonBXAxis * cos(theta) + moonBYAxis * sin(theta)) * dist;\n}\n\nfloat moonA(vec3 p) {\n    return distToSphere(p, moonAPos(), 0.2);\n}\n\nfloat moonB(vec3 p) {\n    return distToSphere(p, moonBPos(), 0.15);\n}\n\nfloat map(vec3 p) {\n    return min(min(min(planet(p), ring(p)), moonA(p)), moonB(p));\n}\n\nvoid setIfLess(inout vec4 color, inout float dist, vec4 newColor, float newDist) {\n    if (newDist < dist) {\n        color = newColor;\n        dist = newDist;\n    }\n}\n\nvec4 colorMap(vec3 p) {\n    vec4 c = vec4(1.0, 1.0, 1.0, 0.0);\n    float d = EPSILON * 10.0;\n    setIfLess(c, d, vec4(planetColor, 0.0), planet(p));\n    setIfLess(c, d, vec4(0.6, 0.5, 0.4, 0.0), ring(p));\n    setIfLess(c, d, vec4(moonAColor, 0.0), moonA(p));\n    setIfLess(c, d, vec4(moonBColor, 0.0), moonB(p));\n    return c;\n}\n\nfloat pointLight(vec3 pos, vec3 normal, vec3 light) {\n    vec3 localPos = light - pos;\n    float amount = dot(normalize(localPos), normal);\n    if (amount > 0.0) {\n        return amount / dot(localPos, localPos);\n    } else {\n        return 0.0;\n    }\n}\n\nvec3 light(vec3 p, vec3 normal) {\n    return (\n        lightAColor * max(dot(normal, lightANormal), 0.0) +\n        lightBColor * max(dot(normal, lightBNormal), 0.0) +\n        pointLight(p, normal, vec3(0.0, 0.0, 0.0)) * planetColor +\n        pointLight(p, normal, moonAPos()) * moonAColor +\n        pointLight(p, normal, moonBPos()) * moonBColor\n    );\n}\n\nbool isStar(vec3 dir) {\n    int p = 199;\n    int id =\n        int(dir.x * float(p)) +\n        int(dir.y * float(p)) * p +\n        int(dir.z * float(p)) * p * p;\n    return (id * 2654435724) % 1753 == 0;\n}\n\nvec3 ray(vec3 pos, vec3 dir) {\n    for (int i = 0; i < 100; i++) {\n        float dist = map(pos);\n        pos += dir * dist;\n    }\n    float dist = map(pos);\n    vec3 normal = normalize(vec3(\n        map(pos + vec3(EPSILON, 0.0, 0.0) - dist),\n        map(pos + vec3(0.0, EPSILON, 0.0) - dist),\n        map(pos + vec3(0.0, 0.0, EPSILON) - dist)\n    ));\n    vec4 color = colorMap(pos);\n    if (dist < EPSILON && dot(normal, dir) <= 0.0) {\n        vec3 light = light(pos, normal);\n        return color.rgb * color.w + (light * (1.0 - color.w)) * color.rgb;\n    } else if (isStar(dir)) {\n        return vec3(0.7, 0.7, 0.7);\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ((fragCoord- iResolution.xy / 2.0)*2.0)/iResolution.yy;\n    float camTheta = (iTime + 12.0) * TAU / 24.0;\n    vec3 cam = vec3(-sin(camTheta), 0.0, cos(camTheta)) * 4.0;\n    float rayTheta = camTheta + uv.x * TAU / 8.0;\n    vec3 dir = normalize(vec3(sin(rayTheta), sin(uv.y * TAU / 8.0), -cos(rayTheta)));\n    fragColor = vec4(ray(cam, dir).xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}