{"ver":"0.1","info":{"id":"4t3SWS","date":"1481300527","viewed":133,"name":"Space manipulations","username":"tiagosr","description":"Old raymarching experiment I bundled with ofxShadertoy, without the camera matrix (for the moment)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float VERY_LARGE_DISTANCE = 100.;\nconst float CAMERA_DISTORT = .6;\nconst int MAX_STEPS = 160;\nconst int MAX_SS_STEPS = 40;\n\n#define pMod(a, b) (mod(a,b)-0.5*b)\n#define STANDARD_RAYMARCH\n//#define WATCH_DISTANCE\n//#define WATCH_STEPS\n\nvec3 opRotX(in float x, in vec3 point) {\n    return vec3(point.x, point.y*cos(x)-point.z*sin(x), point.y*sin(x)+point.z*cos(x));\n}\n\nmat3 mRotX(in float x) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(x), -sin(x),\n        0.0, sin(x), cos(x)\n        );\n}\n\nvec3 opRotY(in float y, in vec3 point) {\n    return vec3(point.x*cos(y)-point.z*sin(y), point.y, point.x*sin(y)+point.z*cos(y));\n}\n\nmat3 mRotY(float y) {\n    return mat3(\n        cos(y), 0.0, -sin(y),\n        0.0, 1.0, 0.0,\n        sin(y), 0.0, cos(y)\n        );\n}\n\nvec3 opRotZ(in float z, in vec3 point) {\n    return vec3(point.x*cos(z)-point.y*sin(z), point.x*sin(z)+point.y*cos(z), point.z);\n}\n\nmat3 mRotZ(in float z) {\n    return mat3(\n        cos(z), -sin(z), 0.0,\n        sin(z), cos(z), 0.0,\n        0.0, 0.0, 1.0\n        );\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat fSphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdBox(in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(in vec3 p, in vec3 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -p.y-c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2),0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdCappedCone(in vec3 p, in vec2 c) {\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat fCylinder(in vec3 p, in float r, in float height) {\n    return max(length(p.xz)-r,abs(p.y)-height);\n}\nfloat fInfCylinder(in vec2 p, in float r) {\n    return length(p)-r;\n}\n\nfloat fCapsule(in vec3 p, in float r, in float c) {\n    return mix(length(p.xz)-r,\n               length(vec3(p.x,abs(p.y)-c,p.z))-r,\n               step(c, abs(p.y)));\n}\n\nfloat fPlane(in vec3 p, in vec3 n) {\n    return dot(p, n);\n}\n\nvec3 opTx(in vec3 p, in mat4 m) {\n    return (inverse(m)*vec4(p,1.0)).xyz;\n}\n\n\n\n/*\nfloat wSphere(in vec3 center, in float radius, in vec3 pos, in vec3 dir, in float mindist) {\n    float r = radius+mindist;\n    vec3 cr = cross(center-pos, dir);\n    float dist = length(cr);\n    if(dist>r) return VERY_LARGE_DISTANCE;\n    float ra = sqrt(r*r-dist*dist);\n    return length(center-pos+cr)-ra;\n}\nfloat wYPlane(in float height, in vec3 pos, in vec3 dir, in float mindist) {\n    if (dir.y >=0.) return VERY_LARGE_DISTANCE;\n    else return (pos.y+height+mindist)/dir.y;\n}\n*/\n//=====================================================\n\nfloat map( in vec3 p )\n{\n    // ground plane\n    float ground = p.y + 1.0;\n    vec3 v1 = vec3(0.5, 0.5, -0.5)-p;\n    vec3 v2 = vec3(0.5, 0.4, -0.5)-p;\n    vec3 vt = opRotX(iTime+v1.x+v1.y, v1);\n    float d1 = sdTorus(vec3(pMod(v1.xz, 2.), v1.y).xzy, vec2(0.5,0.1+cos(iTime*4. + (floor(v1.x/2.0)+floor(v1.z/2.0))*0.5)*0.05));\n    float d3 = fSphere(vec3(pMod(v2.xz, 2.), v2.y).xzy, 0.15);\n    vec2 p4 = vec2(iTime*.1,1.2)-p.xy;\n    float d4 = fInfCylinder(vec2(pMod(p4.x, 5.), p4.y), 0.5);\n    \n    return min(ground,min(d1,min(d3, d4)));\t\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = VERY_LARGE_DISTANCE;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n#ifdef WATCH_STEPS\n        if(h<0.001 || t>maxd) return float(i)/float(MAX_STEPS);\n#else\n        if( h<0.001 || t>maxd ) break;\n#endif\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<MAX_SS_STEPS; i++ )\n    {\n        //t += max(warpzone(ro+rd*t, rd, k),0.);\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = (vec4(0., 0., 0., 1.0)).xyz;\n\tvec3 rd = vec3(p,1.0);\n    rd.z -= length(rd)*CAMERA_DISTORT;\n    rd = (vec4(normalize(rd), 1.)).xyz - ro;\n    vec3 col = vec3(0.0);\n\n\n#ifdef WATCH_DISTANCE\n    float t = intersect(ro,rd);\n    fragColor = vec4(vec3(1.-t/VERY_LARGE_DISTANCE),1.);\n#endif\n\n#ifdef WATCH_STEPS\n    fragColor = vec4(vec3(1.0-intersect(ro, rd)), 1.);\n#endif\n\n\n#ifdef STANDARD_RAYMARCH\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\tfragColor = vec4( col, 1.0);\n#endif\n    //fragColor = vec4( col.x, warpzone(ro,rd)*5., col.z, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}