{"ver":"0.1","info":{"id":"4XK3Wc","date":"1718332987","viewed":42,"name":"ray_tracing_9  ","username":"shanebenlolo","description":"a ray tracer that I am stuck on when implementing the examples in chapter 9 of ray tracing in one weekend, https://raytracing.github.io/books/RayTracingInOneWeekend.html#overview","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float randomDouble(vec2 seed) {\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 randomVec3(vec2 seed) {\n    return vec3(\n        randomDouble(seed),\n        randomDouble(seed + vec2(1.0, 0.0)),\n        randomDouble(seed + vec2(0.0, 1.0))\n    );\n}\n\nvec3 randomVec3Range(vec2 seed, float min, float max) {\n    return vec3(\n        mix(min, max, randomDouble(seed)),\n        mix(min, max, randomDouble(seed + vec2(1.0, 0.0))),\n        mix(min, max, randomDouble(seed + vec2(0.0, 1.0)))\n    );\n}\n\nvec3 randomInUnitSphere(vec2 seed) {\n    while (true) {\n        vec3 p = randomVec3Range(seed, -1.0, 1.0);\n        if (dot(p, p) < 1.0) {\n            return p;\n        }\n        seed += vec2(1.0);\n    }\n}\n\nvec3 randomOnHemisphere(vec3 normal, vec3 randomInUnitSphere) {\n    if (dot(randomInUnitSphere, normal) > 0.0) {\n        return randomInUnitSphere;\n    } else {\n        return randomInUnitSphere * -1.0;\n    }\n}\n\nvec3 attenuateColor(vec3 color) {\n    return 0.5 * color;\n}\n\nvec3 testRaySphereIntersect(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float sphereRadius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float b = dot(oc, rayDir);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float discriminant = b * b - c;\n\n    if (discriminant > 0.0) {\n        float dist = -b - sqrt(discriminant);\n        if (dist > 0.0) {\n            return rayOrigin + rayDir * dist;\n        }\n    }\n    return vec3(1e5);\n}\n\nvec3 calculateBouncedRayColor(vec3 color, vec3 rayDir, vec3 hitPoint, vec2 uv, vec4 objects[2]) {\n    for (int bounce = 0; bounce < 3; bounce++) {\n        vec3 closestHitPoint = vec3(1e5);\n        bool hitSomething = false;\n\n        for (int i = 0; i < 2; i++) {\n            vec3 objectCenter = objects[i].xyz;\n            float objectRadius = objects[i].w;\n\n            vec3 newHitPoint = testRaySphereIntersect(hitPoint, rayDir, objectCenter, objectRadius);\n            if (newHitPoint.z < closestHitPoint.z) {\n                closestHitPoint = newHitPoint;\n                vec3 normal = normalize(newHitPoint - objectCenter);\n                vec3 randomInUnitSphere = randomInUnitSphere(uv + vec2(bounce, i));\n                rayDir = randomOnHemisphere(normal, randomInUnitSphere);\n                color = attenuateColor(color);\n                hitSomething = true;\n            }\n        }\n\n        if (!hitSomething) {\n            return color;\n        }\n\n        hitPoint = closestHitPoint;\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Scene setup\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n\n    // Spheres\n    vec3 sphereCenter = vec3(0.0, 0.0, 5.0);\n    float sphereRadius = 1.0;\n    vec3 groundCenter = vec3(0.0, -100.0, 25.0);\n    float groundRadius = 100.0;\n    vec4 objects[2] = vec4[](\n        vec4(groundCenter, groundRadius),\n        vec4(sphereCenter, sphereRadius)\n    );\n\n    // Begin trace\n    vec3 closestHitPoint = vec3(1e5);\n    vec3 finalColor = vec3(1.0);\n    for (int i = 0; i < 2; i++) {\n        vec3 objectCenter = objects[i].xyz;\n        float objectRadius = objects[i].w;\n\n        vec3 hitPoint = testRaySphereIntersect(cameraPos, rayDir, objectCenter, objectRadius);\n        if (hitPoint.z < closestHitPoint.z) {\n            closestHitPoint = hitPoint;\n            finalColor = calculateBouncedRayColor(vec3(1.0), rayDir, hitPoint, uv, objects);\n        }\n    }\n\n    if (closestHitPoint.z == 1e5) {\n        vec3 a = 0.5 * vec3(rayDir.y + 1.0);\n        vec3 bgColor = (1.0 - a) * vec3(1.0) + a * vec3(0.5, 0.7, 1.0);\n        fragColor = vec4(bgColor, 1.0);\n    } else {\n        fragColor = vec4(finalColor, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}