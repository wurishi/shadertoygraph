{"ver":"0.1","info":{"id":"Xs3SzM","date":"1458237589","viewed":307,"name":"Cornell Box of Mirrors","username":"aaecheve","description":"Classic cornell box + mirrors","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","cornellbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float infinity = 1e10;\n\n\nstruct Sphere {\n  vec3 position;\n  float radius;\n  int materialIndex;\n};\n\nstruct Material {\n  vec4 diffuse;\n  vec4 specular;\n  float shininess;\n  float reflectivity;\n};\n\nstruct Light {\n  vec3 position;\n  vec4 color;\n};\n\nstruct Ray {\n  vec3 position;\n  vec3 direction;\n};\n\nstruct Camera {\n  vec3 position;\n};\n\nstruct Scene {\n  vec4 ambient;\n  vec4 background;\n};\n\nconst int numberOfSpheres = 8;\nconst int numLights = 2;\nconst int numberOfMaterials = 8;\nconst int maxNumberOfReflections = 1;\n\nSphere spheres[numberOfSpheres];\nMaterial materials[numberOfMaterials];\nLight lights[numLights];\nCamera camera = Camera(vec3(0.5, 0.5, 1.5));\nScene scene = Scene(vec4(0.1,0.1,0.1,1), vec4(0,0,0,1));\n\n\n//ray-sphere intersection\nfloat intersect(Ray ray, Sphere sphere)\n{\n  //float a = 1.0;//dot(ray.direction, ray.direction); //Optimization suggested by Phi\n  float b = dot(ray.position - sphere.position, ray.direction);\n  float c = dot(ray.position - sphere.position, ray.position - sphere.position) - sphere.radius*sphere.radius;\n \n  float discr = b*b - c;// - a*c; //Optimization suggested by Phi\n  if(discr < 0.0)\n    return infinity;\n\n  discr = sqrt(discr);\n  float t0 = (-b - discr);// / a; //Optimization suggested by Phi\n  float t1 = (-b + discr); // / a; //Optimization suggested by Phi\n\n  float tMin = min(t0, t1);\n  if(tMin < 0.0)\n    return infinity;\n\n  return tMin;\n\n}\n\n//shadows\nbool isInShadow(vec3 p, Sphere sphere, Light light)\n{  \n  float lightDistance = distance(light.position, p);\n  vec3 shadowDir = normalize(light.position - p);\n  Ray shadowRay = Ray(p + 0.1 * shadowDir, shadowDir);    \n  float tShadow = intersect(shadowRay, sphere);\n  if(!isinf(tShadow) && tShadow < lightDistance)\n\treturn true;\n  \n  return false;\n}\n\nbool isInOtherSphereShadow(vec3 p, Sphere thisSphere, Light light)\n{\n\tfor(int i=0; i<numberOfSpheres; i++)\n\t{\n\t\tif(isInShadow(p, spheres[i], light))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n//blinn-phong shading\nvec4 blinnPhongShading(vec3 p, vec3 n, Sphere sphere, Material material)\n{\n  //Material material\t= materials[0];\n  vec3 v = camera.position - p;\n  v = normalize(v);\n \n  vec4 shadedColor = scene.ambient * material.diffuse;\n  for(int i=0; i<numLights; i++)\n  {\n\tvec4 lightColor = lights[i].color;\n\tif(isInOtherSphereShadow(p, sphere, lights[i]))\n\t\tlightColor = vec4(0,0,0,1);\n    vec3 l = lights[i].position - p;\n    l = normalize(l);  \n    vec3 h = v + l;\n    h = normalize(h);\n\n    shadedColor = shadedColor + lightColor * (max(0.0,dot(n,l)) * material.diffuse + pow(max(0.0,dot(n,h)), material.shininess) * material.specular);\t  \n  }\n  return shadedColor;\n}  \n\n\n\nvec4 rayTrace(Ray ray)\n{\n  vec4 accumulatedColor = vec4(0,0,0,1);\n  float frac = 1.0;\n  for(int i=0; i < maxNumberOfReflections + 1; i++)\n  {\n\t  float tMin = infinity;\n\t  int sphereMin = -1;\n      Sphere sphere = spheres[0];\n      Material material = materials[0];\n\t  for(int i=0; i<numberOfSpheres; i++)\n\t  {\t\n\t\tfloat t = intersect(ray, spheres[i]);\n\t\tif(t < tMin)\n\t\t{\n\t\t\ttMin = t;\n\t\t\tsphereMin = i;\n            sphere = spheres[i];\n            material = materials[i];\n\t\t}\n\t  }\n\n\t  if(!isinf(tMin))\n\t  {\n\t\tvec3 p = ray.position + tMin*ray.direction;\n\t\tvec3 n = normalize(p - sphere.position);\n\t\tMaterial mat = materials[0];\n\t\tvec4 localColor = blinnPhongShading(p, n, sphere, material);\n\t\taccumulatedColor += localColor * frac;\n\t\tif(mat.reflectivity > 0.0)\n\t\t{\n\t\t\tray.position = p;\n\t\t\tray.direction = normalize(reflect(ray.direction, n));\n\t\t\tfrac *= mat.reflectivity;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t  }  \n\t \n\t  accumulatedColor += scene.background * frac;\n  }\n  return accumulatedColor;\n}\n\nvoid init()\n{ \n  materials[0] = Material(vec4(0.156,0.126,0.507,1), vec4(1,1,1,1), 100.0, 0.3);   // Blue specular\n  materials[1] = Material(vec4(0.656,0.626,0.107,1), vec4(0,0,0,1), 1.0, 0.5);     // Yellow\n  materials[2] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[3] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[4] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  materials[6] = Material(vec4(0.639, 0.06, 0.062, 1), vec4(0,0,0,1), 1.0, 0.5);   // Red\n  materials[5] = Material(vec4(0.156, 0.426, 0.107, 1), vec4(0,0,0,1), 1.0, 0.5);  // Green\n  materials[7] = Material(vec4(0.739, 0.725, 0.765, 1), vec4(0,0,0,1), 1.0, 0.5);  // White\n  \n\n  lights[0] = Light(vec3(0.5,0.99,0.5),  vec4(0.8,0.7,0.6,1));\n  lights[1] = Light(vec3(0.5,0.99,-0.5),  vec4(0.2,0.2,0.2,1));\n\n  spheres[0] = Sphere(vec3(0.35, 0.24, -0.72), 0.2, 0); //Blue sphere\n  spheres[1] = Sphere(vec3(0.82, 0.2, -0.25), 0.19, 1); //Yellow sphere\n  spheres[2] = Sphere(vec3(0.5, 0.5, -1004), 1000.0, 2); //Back wall\n  spheres[3] = Sphere(vec3(0.5, 1001.1, -0.5), 1000.0, 2); //Ceiling\n  spheres[4] = Sphere(vec3(0.5, -1000.1, -0.5), 1000.0, 2); //Floor\n  spheres[5] = Sphere(vec3(1001.1, 0.5, -0.5), 1000.0, 4); //Right wall\n  spheres[6] = Sphere(vec3(-1000, 0.5, -0.5), 999.9, 3); //Left wall\n  spheres[7] = Sphere(vec3(0.5, 0.7, -0.5), 0.03, 2); //White sphere\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Initialize elements\n  init();\n\n  //Light movement \n  vec2 normMouse = iMouse.xy / iResolution.xy;\n  lights[0].position = vec3(normMouse.x, normMouse.y, 0.0); \n\t\t  \t\t  \n  //Object movement\n  float speed = 1.0;\n  spheres[0].position = vec3(0.5, 0.24, -0.5) + 0.3 * vec3(sin(speed*(iTime)),0.0,cos(speed*(iTime)));\n  spheres[1].position = vec3(0.5, 0.2, -0.5) + 0.23 * vec3(sin(speed*(iTime) + 10.0),0.0,cos(speed*(iTime)+ 10.0));\n  spheres[7].position = vec3(0.5, 0.7, -0.5) + 0.2 * vec3(0, sin(speed*(iTime)), 0.0);\n\t   \t\n  //Raytrace objects\n  vec2 pixelCoords = fragCoord.xy / iResolution.y;\n  vec3 pixel = vec3(pixelCoords - vec2(0.5,0), 0);\n  Ray ray = Ray(camera.position, normalize(pixel - camera.position));\n  fragColor = rayTrace(ray);\n}","name":"Image","description":"","type":"image"}]}