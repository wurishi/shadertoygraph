{"ver":"0.1","info":{"id":"Xf3yW2","date":"1731141358","viewed":55,"name":"hyperfrac","username":"maxiie","description":"3d mandelbrot/julia fractal","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nconst float iDist=10.;\n\nconst float iPowerZ1=2.;\nconst float iPowerC1=0.;\nconst float iQuot1=1.;\n\nconst float iPowerZ2=0.;\nconst float iPowerC2=1.;\nconst float iQuot2=1.;\n\nconst float iPowerZ3=0.;\nconst float iPowerC3=0.;\nconst float iQuot3=0.;\n\nconst float iVoxRes=3.0;\nconst int iMaxTrace=500;\nconst bool isJulia=false;\nconst bool isAnti=false;\nconst float iAlpha=1.;\n\nconst bool intermode=true;\nconst float intervoidstepsize=5.0;\nconst float interhitstepsize=0.05;\nconst int interhitbreakval=100;\n\nconst float huefactor=3.0;\nconst float hueshift=0.0;\nconst float saturation=1.0;\nconst float colval=2.0;\nconst int colormode=0;\nconst float cm1base=0.1;\n\nconst int alphamode=0;\nconst float hitfactor=0.1;\n\nconst float pi = 3.141592;\nconst float tau = 2.0*pi;\n\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nvoid cAdd(vec3 a,vec3 ad,vec3 b, vec3 bd,out vec3 c,out vec3 cd){\n    c=vec3(a.x+b.x,a.y+b.y,a.z+b.z);\n\n\n    if(length(a)==0.0){cd=bd;return;}\n    if(length(b)==0.0){cd=ad;return;}\n\n\n    if(length(bd.x)+length(ad.x)==0.0){cd.x=0.;}\n    else{\n      cd.x=atan(sin(ad.x)/length(c.xy)*length(a.xy)+sin(bd.x)/length(c.xy)*length(b.xy),cos(ad.x)/length(c.xy)*length(a.xy)+cos(bd.x)/length(c.xy)*length(b.xy));\n      }\n\n    if(length(bd.y)+length(ad.y)==0.0){cd.y=0.;}\n    else{\n      cd.y=atan(sin(ad.y)/length(c.yz)*length(a.yz)+sin(bd.y)/length(c.yz)*length(b.yz),cos(ad.y)/length(c.yz)*length(a.yz)+cos(bd.y)/length(c.yz)*length(b.yz));\n    }\n    if(length(bd.z)+length(ad.z)==0.0){cd.z=0.;}\n    else{\n      cd.z=atan(sin(ad.z)/length(c.zx)*length(a.zx)+sin(bd.z)/length(c.zx)*length(b.zx),cos(ad.z)/length(c.zx)*length(a.zx)+cos(bd.z)/length(c.zx)*length(b.zx));\n    }\n\n\n}\n\n\n\nvoid cMul(vec3 a, vec3 ad,vec3 b,vec3 bd,out vec3 c,out vec3 cd){\n    c=vec3(1,0,0);\n    cd=ad+bd;\n\n    vec3 n=c;\n    vec3 nd=cd;\n\n    c.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c;\n    c.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    c.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=c;\n    c.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    c.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n    c*=length(a)*length(b);\n\n}\n\nvoid cDiv(vec3 a, vec3 ad,vec3 b,vec3 bd,out vec3 c,out vec3 cd){\n    c=vec3(1,0,0);\n    cd=ad-bd;\n\n    vec3 n=c;\n    vec3 nd=cd;\n\n    c.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    c.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=c;\n    c.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    c.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=c;\n    c.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    c.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n    c*=length(a)/length(b);\n\n}\n\nvoid cPowf(vec3 a,vec3 ad,float npow,out vec3 b,out vec3 bd){\n    b=vec3(1,0,0);\n    bd=ad*npow;\n    if(npow==0.)return;\n\n    vec3 n=b;\n    vec3 nd=bd;\n\n    b.x=n.x*cos(nd.x)-n.y*sin(nd.x);\n    b.y=n.x*sin(nd.x)+n.y*cos(nd.x);\n\n    n=b;\n    b.y=n.y*cos(nd.y)-n.z*sin(nd.y);\n    b.z=n.y*sin(nd.y)+n.z*cos(nd.y);\n\n    n=b;\n    b.x=n.x*cos(nd.z)-n.z*sin(nd.z);\n    b.z=n.x*sin(nd.z)+n.z*cos(nd.z);\n\n    b*=pow(length(a),npow);\n\n\n}\n\nvoid cInit(float a, float b, float c,float q, out vec3 d, out vec3 dd){\n    cAdd(vec3(a,0.0,0.0),vec3(((a<0.)?PI:0.),0.0,0.0),vec3(0.0,b,0.0),vec3(PI/2.+((b<0.)?PI:0.),0.0,0.0),d,dd);\n    cAdd(d,dd,vec3(0.0,0.0,c),vec3(0.0,0.0,PI/2.+((c<0.)?PI:0.)),d,dd);\n    cAdd(d,dd,vec3(0.0,0.0,q),vec3(0.0,PI/2.+((q<0.)?PI:0.),0.0),d,dd);\n    //cPowf(d,dd,1.,d,dd);\n}\n\n\nvec3 mandi(in vec3 p ) {\n\n    vec3 z = vec3(0.,0.,0.);\n    vec3 zd=vec3(0.,0.,0.);\n\n    vec3 c;\n    vec3 cd;\n    vec3 q;\n    vec3 qd;\n    vec3 k;\n    vec3 kd;\n    vec3 m;\n    vec3 md;\n    vec3 g;\n    vec3 gd;\n    vec3 wo1;\n    vec3 wod1;\n    vec3 wo2;\n    vec3 wod2;\n    vec3 wo3;\n    vec3 wod3;\n    cInit(p.x,p.y,p.z,0.0,c,cd);\n    cInit(iQuot1,0.,0.,0.,wo1,wod1);\n    cInit(iQuot2,0.,0.,0.,wo2,wod2);\n    cInit(iQuot3,0.,0.,0.,wo3,wod3);\n\n    bool inMandelbrotSet = true;\n\n    for (int i=0; i<100; i++) {\n\n\tm=vec3(0,0,0);\n\tmd=vec3(0,0,0);\n\tif(iQuot1==0.){\n\t\tg=vec3(0,0,0);\n\t\tgd=vec3(0,0,0);\n\t}\n\telse{\n\t  cPowf(z,zd,iPowerZ1,q,qd);\n    cPowf(c,cd,iPowerC1,k,kd);\n\t\tcMul(q,qd,k,kd,g,gd);\n\t\tcMul(g,gd,wo1,wod1,m,md);\n\t}\n\tcAdd(m,md,g,gd,m,md);\n\tif(iQuot2==0.){\n\t\tg=vec3(0,0,0);\n\t\tgd=vec3(0,0,0);\n\t}\n\telse{\n    cPowf(z,zd,iPowerZ2,q,qd);\n    cPowf(c,cd,iPowerC2,k,kd);\n\t\tcMul(q,qd,k,kd,g,gd);\n\t\tcMul(g,gd,wo2,wod2,g,gd);\n\t}\n\n\n        cAdd(m,md,g,gd,m,md);\n\tif(iQuot3==0.){\n\t\tg=vec3(0,0,0);\n\t\tgd=vec3(0,0,0);\n\t}\n\telse{\n\t\tcPowf(z,zd,iPowerZ3,q,qd);\n    cPowf(c,cd,iPowerC3,k,kd);\n\t\tcMul(q,qd,k,kd,g,gd);\n\t\tcMul(g,gd,wo3,wod3,g,gd);\n\t}\n        cAdd(m,md,g,gd,m,md);\n\n\tz=m;\n\tzd=md;\n\n        if (length(z) > 2.) {\n            inMandelbrotSet = false;\n            break;\n        }\n    }\n    if (inMandelbrotSet^^isAnti) {\n        return(z);\n    } else {\n        return(vec3(0.));\n    }\n}\n\nvec3 julia(in vec3 p ) {\n\n    vec3 z = vec3(0.,0.,0.);\n    vec3 zd=vec3(0.,0.,0.);\n\n    vec3 c;\n    vec3 cd;\n    vec3 q;\n    vec3 qd;\n    cInit(p.x,p.y,p.z,0.0,z,zd);\n    cInit(0.3,0.5,0.4,0.6,c,cd);\n    int j=0;\n\n    for (int i=0; i<100; i++) {\n\n        cPowf(z,zd,iPowerZ1,q,qd);\n\n        cAdd(q,qd,c,cd,z,zd);\n\n        if (length(z) > 100.) {\n            break;\n        }\n        j++;\n    }\n\tif((float(j)/100.<0.1)^^isAnti){return vec3(0.0);}\n\telse return(z);\n}\n\n\n\n#define TIME iTime/2.0\n\n\nstruct hit {\n    bool didHit;\n    vec3 col;\n};\n\nhit getVoxel(vec3 p) {\n        vec3 c;\n        if(isJulia){c=julia(vec3(p)*.05/iVoxRes);}\n        else{c=mandi(vec3(p)*.05/iVoxRes);}\n    if (length(c)!=0.) {\n        vec3 color=vec3(1);\n        if(colormode==0){\n            color=hsv2rgb(vec3(length(c)*huefactor+hueshift,saturation,colval));}\n        if(colormode==1){\n            color=rgb2hsv(vec3(pow(cm1base,c.x),pow(cm1base,c.y),pow(cm1base,c.z)));\n            color.y=saturation;\n            color.z=colval;\n            color=hsv2rgb(color);\n            }\n            \n        return hit(true, color);}\n    else\n        return hit(false, vec3(0,0,0));\n\n}\n\nvec3 lighting(vec3 norm, vec3 pos, vec3 rd, vec3 col) {\n    vec3 lightDir = normalize(vec3(-1.0, 3.0, -1.0));\n    float diffuseAttn = max(dot(norm, lightDir), 0.0);\n    vec3 light = vec3(1.0,0.9,0.9);\n\n    vec3 ambient = vec3(0.2, 0.2, 0.3);\n\n    vec3 reflected = reflect(rd, norm);\n    float specularAttn = max(dot(reflected, lightDir), 0.0);\n\n    return col*(diffuseAttn*light*1.0 + specularAttn*light*0.6 + ambient);\n}\n\n// Voxel ray casting algorithm from \"A Fast Voxel Traversal Algorithm for Ray Tracing\"\n// by John Amanatides and Andrew Woo\n// http://www.cse.yorku.ca/~amana/research/grid.pdf\nhit intersect(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = (ro*iVoxRes);\n\n    vec3 step = sign(rd);\n\n    vec3 tDelta = step / rd;\n\n\n    float tMaxX, tMaxY, tMaxZ;\n\n    vec3 fr = fract(ro*iVoxRes);\n\n    tMaxX = tDelta.x * ((rd.x>0.0) ? (1.0 - fr.x) : fr.x);\n    tMaxY = tDelta.y * ((rd.y>0.0) ? (1.0 - fr.y) : fr.y);\n    tMaxZ = tDelta.z * ((rd.z>0.0) ? (1.0 - fr.z) : fr.z);\n\n    vec3 norm;\n    int maxTrace = iMaxTrace;\n    int hits=0;\n    hit q=hit(false,vec3(0,0,0));\n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(vec3(pos));\n        if (h.didHit) {\n          if(iAlpha==1.){\n            return hit(true, (lighting(norm, pos, rd, h.col)+h.col)/2.);\n            }\n            else{\n              hits+=1;\n              if(alphamode==0){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)));\n              }\n              if(alphamode==1){\n                  q=hit(true,(h.col*(iAlpha)*float(hits)*hitfactor+q.col*(1.0-iAlpha))/(float(hits)*hitfactor));}\n              if(alphamode==2){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)*float(hits)*hitfactor)/(float(hits)*hitfactor));}\n              \n            }\n        }\n\n        if (tMaxX < tMaxY) {\n            if (tMaxZ < tMaxX) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0,-step.z);\n            } else {\n                tMaxX += tDelta.x;\n            \tpos.x += step.x;\n                norm = vec3(-step.x, 0, 0);\n            }\n        } else {\n            if (tMaxZ < tMaxY) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0, -step.z);\n            } else {\n            \ttMaxY += tDelta.y;\n            \tpos.y += step.y;\n                norm = vec3(0, -step.y, 0);\n            }\n        }\n    }\n\n \treturn q;\n}\n\nhit intersect2(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = (ro*iVoxRes);\n\n    vec3 step = normalize(rd)/iVoxRes;\n\n    vec3 tDelta = step / rd;\n    int hits=0;\n\n    vec3 norm=vec3(1.);\n    int maxTrace = iMaxTrace;\n    hit q=hit(false,vec3(0,0,0));\n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(vec3(pos));\n        if (h.didHit) {\n          if(iAlpha==1.){\n            return hit(true, (lighting(norm, pos, rd, h.col)+h.col)/2.);\n            }\n            else{\n              hits+=1;\n              if(alphamode==0){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)));\n              }\n              if(alphamode==1){\n                  q=hit(true,(h.col*(iAlpha)*float(hits)*hitfactor+q.col*(1.0-iAlpha))/(float(hits)*hitfactor));}\n              if(alphamode==2){\n                  q=hit(true,(h.col*(iAlpha)+q.col*(1.0-iAlpha)*float(hits)*hitfactor)/(float(hits)*hitfactor));}\n              \n              \n              pos+=step*interhitstepsize;\n              \n              i=0;\n              if(hits==interhitbreakval)return q;\n            }\n        }else pos+=step*intervoidstepsize;\n\n    }\n\n \treturn q;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv =fragCoord.xy / iResolution.xy - 0.5;\n    vec3 worldUp = vec3(0,1,0);\n    vec3 camPos = vec3(iDist*sin(TIME), 10, 1.0*iDist*cos(TIME));\n    vec3 lookAt = vec3(0,0,0);\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camDir, worldUp));\n    vec3 camUp = cross(camRight, camDir);\n\n    vec3 filmCentre = camPos + camDir*0.3;\n    vec2 filmSize = vec2(1,iResolution.y / iResolution.x);\n\n    vec3 filmPos = filmCentre + uv.x*filmSize.x*camRight + uv.y*filmSize.y*camUp;\n    vec3 ro = camPos;\n    vec3 rd = normalize(filmPos - camPos);\n    hit h;\n    if(intermode){h = intersect2(ro, rd);}\n    else{h = intersect(ro, rd);}\n    if(h.didHit) {\n        fragColor = vec4(h.col,1);\n    } else{\n       fragColor = vec4(0,0,0,0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}