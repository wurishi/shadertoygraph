{"ver":"0.1","info":{"id":"432SzW","date":"1710328329","viewed":54,"name":"krikilion triangle","username":"Jan300100","description":"krikilion triangle","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["krikiliontriangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / vec2(iResolution.xy));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 createTriangle(vec2 fragCoord, float time, float angleOffset)\n{\n    vec4 fragColor = vec4(0);\n    float zoom = pow(2.0, time);\n    float startSize =  pow(2., 10.);\n    float zoomOffset = 0.5;\n    vec2 px = (fragCoord/iResolution.xy - zoomOffset) * startSize;\n    px /= zoom; // Should make it zoom out... doesn't anymore\n\n    \n    // Cycle stuff\n    float cycleProgress = fract(-time * 1.0f);\n    px = (px *= zoom) * exp2(cycleProgress);\n    \n    float angle = time + angleOffset;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * mat2(.87,-.5,0,1);\n    vec2 pxr = px*rot;\n\n    // Binary AND create serpinski\n    float r = float(int(pxr.x)&int(pxr.y));\n    // Color!\n    fragColor = r != 0. ? vec4(0,0,0,0) : vec4(1,1,1,0);\n\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = fragColor * vec4(col,1.0);\n    return fragColor;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.1f;\n    \n    vec4 result = vec4(0);    \n    for (int i =1; i < 8; i++)\n    {\n        result += createTriangle(fragCoord, time * float(i * i), 0.0f) + createTriangle(fragCoord, time * float(i), 3.1415f );\n    }\n    \n    fragColor = texture(iChannel1, fragCoord / vec2(iResolution.xy));\n    if ((fragColor.x - 13.0/255.0f < 0.2f) \n        && (fragColor.y - 163.0/255.0f < 0.1f)\n        && (fragColor.z - 37.0/255.0f < 0.1f)) \n    {\n        fragColor = result;\n    }\n    \n    //fragColor += texture(iChannel0, fragCoord / vec2(iResolution.xy)) * 0.5f;\n}","name":"Buffer A","description":"","type":"buffer"}]}