{"ver":"0.1","info":{"id":"td23zV","date":"1551739962","viewed":996,"name":"Impossible Chainmail","username":"BigWIngs","description":"Playing around with hexagons.","likes":71,"published":1,"flags":0,"usePreview":0,"tags":["escher","hexagon","knot","impossible","chainmail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Impossible Chainmail by Martijn Steinrucken aka BigWings - 2019\n// countfrolic@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Inspired by:\n// https://twitter.com/anniek_p/status/1092632749423370240\n//\n// After playing with it for a bit I realized that with the right settings, \n// this turns into a neat impossible knot\n//\n// Code is a bit of a mess, I know ;)\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define R3 1.73205080757\n\nvec2 s = vec2(1, R3);\nvec4 red = vec4(1, .3, .3,1);\nvec4 blue = vec4(.3, .3, 1,1);\n\n\nvec4 HexCoords(vec2 uv, float angle) {\n    \n    vec2 h = .5*s;\n    \n    vec2 a = mod(uv, s)-h;\n    vec2 b = mod(uv+h, s)-h;\n    \n    vec2 ab = dot(a,a)<dot(b,b) ? a : b;\n    \n    \n    vec2 id = uv-ab;\n    \n    float d = length(s);\n    vec2 hc = abs(ab);\n\n    float x = min(hc.x, min( abs(dot(ab, s/d)), abs(dot(ab, vec2(1,-R3)/d))));\n    float y = min(1.-2.*hc.x, 1.-dot(hc, s));\n    \n    return vec4(x, y, id.x, id.y);\n}\n\nvec4 HexCol(vec2 uv, vec2 offs, float waveSpeed, float size) {\n\n    vec4 hc = HexCoords(uv, 1.);\n\t\n    float cd = length(hc.zw-offs);\n    if(cd>1.75)  return vec4(0);\n    \n    \n    float center = size;//mix(.2, .37, sin(iTime)*.5+.5);\n    float c = abs(hc.y-center);\n    //cd = length(uv-offs);\n    float w = .15;//-sin(cd*3.+iTime*0.)*.05;\n    float mainMask = S(w, w*.9, c);\n    \n    vec4 col = vec4(1.);\n    \n    \n    vec2 hv = uv-hc.zw;\n    float x = atan(hv.x, hv.y);\n    float swap = sign(cos(x*3.))*.01;\n    float corners = S(.01, .0, hc.x);\n    corners *= S(center, center+swap, hc.y);\n\n    float edges = S(.01, .03, abs(c-w*.9))*S(.01, .02, c);\n    \n    float side = step(center, hc.y);\n    \n    float wave = sin(x*3.+iTime*waveSpeed);\n    \n    x = x/6.2831+.5;\n    \n    float sector = x;\n    \n    x = fract(x+.333+ .333*1.5*side)*3.;\t\t// three sectors\n    float shade = floor(x)/2.;\n    shade = shade*.7+.3 +(wave*.5+.5)*step(.75, shade);\n    //shade *= 1.+S(0., .5, wave)*step(shade, .75);\n    \n    col.r = shade*edges;\n    col.g = sector;\n    col.b = corners;\n    col.a = mainMask;\n    \n\n    return col;\n}\n\nfloat SS(float x) { return S(0.,1.,S(0.,1.,S(0.,1.,x)));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*2.;\n    \n    float fade = SS(cos(t)*.5+.5);\n    float fade2 = SS(cos(t*.5));\n    \n    float size = .3+fade*.2;\n    \n    vec3 col = vec3(.25,.2,.2)*3.-length(uv)*.5;\n\t\n    float grid = 4.;\n   \t\n    vec2 UV = uv*grid+vec2(.5,-.3);\n    \n    vec2 offs = (1.-fade)*vec2(sin(t), cos(t))*.03;\n    \n    vec4 hex1 = HexCol(UV+offs, vec2(.3,-.3), 1., size);\n    vec4 hex2 = HexCol(UV+vec2(.5,-.2886)-offs, vec2(1.,-.3), -1.,size);\n    \n    float sector = mod(floor(hex1.g*6.)+1., 2.);\n    \n    vec4 col1 = mix(red, blue, fade2);\n    col1-=hex1.b*step(sin((hex1.g+.1)*6.*3.1415), 0.);\n    \n    vec4 col2 = mix(blue, col1, fade);\n    //col2 = mix(col2, col1, colSwap);\n    col2-=hex2.b*step(sin((hex2.g+.2)*6.*3.1415), 0.);\n    \n    col1.a=col2.a=1.;\n    vec4 hexCol = mix(\n        hex1.x*col1, \n        hex2.x*col2, \n        hex2.a*max(sector, (1.-hex1.a))\n    );\n    hexCol.a = max(hex1.a, hex2.a);\n    //hexCol = hex1.x*vec4(1., .3, .3,1); hexCol.a = hex1.a; \n    col = mix(col, hexCol.rgb, hexCol.a);\n  \n    //if(abs(uv.x)<.002 || abs(uv.y)<.002) col += 1.;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}