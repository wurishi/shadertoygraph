{"ver":"0.1","info":{"id":"sdtyRf","date":"1653862346","viewed":109,"name":"Edge-lit sdf experiment","username":"Dubswitcher","description":"No particular purpose or goal behind this. First public post to use 3d SDFs after finally making progress on learning how they work. Many thanks to IQ for his research and documentation.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","test","sdf","experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotate(float x, float y, float z) {\n    vec3 c = cos(vec3(x,y,z));\n    vec3 s = sin(vec3(x,y,z));\n    return mat3(vec3(1, 0, 0),vec3(0, c.x, -s.x),vec3(0, s.x, c.x)) *\n           mat3(vec3(c.y, 0, s.y),vec3(0, 1, 0),vec3(-s.y, 0, c.y)) *\n           mat3(vec3(c.z, -s.z, 0),vec3(s.z, c.z, 0),vec3(0, 0, 1));\n}\n\nfloat hash(in vec2 uv){\n    return fract(sin(dot(uv, vec2(14.478473612, 53.252567))) * 37482.1);\n}\n\nvec2 hash2(in vec2 uv)\n{\n    vec3 o = fract(vec3(uv.yxx*893.335)*vec3(0.146651, 0.185677, 0.135812));\n    o += dot(o.zxy, o.yzx+60.424);\n    return fract((o.yx+o.zy)*o.xz);\n}\n\nfloat voronoiPoint (in vec2 uv, in float zPos, in float seed, in float blend)\n{\n    float build = 0.;\n    float dist = 0.;\n    for (float x = -2.; x <= 2.; x++)\n    {\n        for (float y = -2.; y <= 2.; y++)\n        {\n            vec2 cell = vec2(x,y);\n            vec2 ID = floor(uv)-cell+seed;\n            float rand = (zPos+hash(ID))*(hash(ID)*0.5+0.5);\n            float B = fract(rand);\n            vec3 offs = vec3(floor(rand),ceil(rand),B*B*(3.-2.*B));\n            vec2 point = mix(hash2(ID+offs.x),hash2(ID+offs.y),offs.z);\n            \n            float distP = distance(point,fract(uv)+cell)-2.;\n            build = mix(distP,build,smoothstep(build-blend,build+blend,distP));\n        }\n    }\n    return build+2.;\n}\n\nfloat objCarve(float a, float b, float s)\n{\n    float x = clamp(.5-.5*(b+a)/s,0.,1.);\n    return mix(b,-a,x) + s*x*(1.-x);\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 scene (vec3 p)\n{\n    float ball = sdSphere(p,1.);\n    ball = max(ball,-sdSphere(p,0.95));\n    \n    vec3 bPos = p * rotate(0.3,iTime,0.6);\n    \n    float box = sdBox(bPos,vec3(4.,0.3,4.));\n    vec2 c = vec2(objCarve(box,ball,0.05),1.);\n    \n    return c;\n}\n\nmat3 camera(in vec3 cPos, in vec3 targ, in float roll)\n{\n    vec3 ww = normalize(targ - cPos);\n    vec3 uu = normalize(cross(ww,vec3(sin(roll),cos(roll),0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 getNorm( in vec3 pos ){\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nvec2 view(in vec3 cPos, in vec3 rd){\n    float pr = 0.001, nc = 0., fc = 50.; //Precision, near clipping, far clipping\n    float h = pr;    \n    float t = 0., ray = -1., mat = -1.;    \n    for(int i = 0; i < 200; i++)\n    {\n        if(h < pr || t > fc) break;\n\t   \tvec2 m = scene(cPos+rd*t);\n        h = m.x; t += h; mat = m.y;       \n    }\n    if(t < fc) {\n        if(t > nc) ray = t; else mat = -1.;\n    } else mat = -1.;    \n    \n    return vec2(ray, mat);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 eye = vec3(0.,0.,4.);\n    vec3 look = vec3(0.);\n    \n    mat3 cam = camera(eye,look,0.);\n    vec3 ray = normalize(cam*vec3(uv,1.8));\n    vec2 pix = view(eye, ray);\n    \n    vec3 col = mix(vec3(0.,0.,0.1),vec3(0.2,0.4,0.5),voronoiPoint(uv*4.,iTime,0.,0.));\n    vec3 obj = vec3(0.);\n    if (pix.y > 0.)\n    {\n        vec3 p = eye+ray*pix.x;\n        vec3 n = getNorm(p);\n        n += voronoiPoint(uv*8.,iTime*3.,0.4325,0.)/10. - 0.2;\n        \n        \n        float sun = max(dot(vec3(0.5,0.5,0.5),n),0.);\n        float pt = max(dot(normalize(vec3(-1.6,-1.2,2.)-n),n),0.);\n        vec3 plight = vec3(0.2,0.3,0.5)*pt;\n        if (pix.y == 1.) obj = vec3(0.8,0.7,0.3) * (sun+plight) + 0.05;\n        \n        col += obj * pow((1.-dot(vec3(0.,0.,1.),n))*2.,5.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}