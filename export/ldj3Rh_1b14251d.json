{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct tSphere {\n\tvec3 center;\n\tfloat radius;\n\tvec3 color;\n\tfloat spec;\n};\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// Adapted from http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/\nfloat rayIntersectsTriangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tif (a > -0.00001 && a < 0.00001)\n\t\treturn -1.0;\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tif (u < 0.0 || u > 1.0)\n\t\treturn -1.0;\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\n\tif (v < 0.0 || u + v > 1.0)\n\t\treturn -1.0;\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\tuv = vec2(u, v);\n\t\n\tif (t > 0.00001) // ray intersection\n\t\treturn t;\n\n\telse // this means that there is a line intersection\n\t\t // but not a ray intersection\n\t\t return -1.0;\n\n}\n\nvec3 rotateTime(float k, vec3 cen)\n{\n\tfloat time = iTime + 450.0;\n\tcen.xy = rotate(cen.xy, time*0.2);\n\tcen.xz = rotate(cen.xz, sin(k+time*0.3));\n\treturn cen;\n}\n\nfloat intersect(inout vec3 ray, vec3 dir, inout vec3 nml, inout tSphere sphere, float pick)\n{\n\tfloat dist = 100.0;\n\n\tsphere.radius = 0.0;\n\tsphere.center = vec3(0.0);\n\n\tfloat time = iTime + 450.0;\n\t\n\tfloat st = sin(time);\n\tfloat ct = cos(time);\n\tfor (float i=0.0; i<3.0; i++) {\n\t\tfor (float j=0.0; j<3.0; j++) {\n\t\t\tfloat k = i*3.0 + j;\n\t\t\t\n\t\t\tfloat r = 0.3+(1.4-0.3*abs(2.0+sin(i+j*4.0)))+0.2*sin(time+k*0.2);\n\t\t\tvec3 cen = vec3(4.0*cos(time*0.12+k), \n\t\t\t\t\t\t\t(-4.5 + k)*(4.0+r),\n\t\t\t\t\t\t\tsin(time*0.33+k));\n\t\t\tcen = rotateTime(k, cen);\n\t\t\tvec3 px = rotateTime(k+st+ct+sin(dir.y*2.4), vec3(1.0, 0.0, 0.0));\n\t\t\tvec3 py = rotateTime(k+st+ct+sin(dir.x*2.5), vec3(0.0, 1.0, 0.0));\n\t\t\tvec3 pz = rotateTime(k+st+ct+sin(dir.z*3.0), vec3(0.0, 0.0, 1.0));\n\t\n\t\t\tcen.z += 3.0;\n\t\t\t\n\t\t\tvec3 rc = ray-cen;\n\t\t\tfloat b = dot(dir, rc);\n\t\t\tfloat c = dot(rc, rc) - r*r*0.25;\n\t\t\tfloat d = b*b - c;\n\t\n\t\t\tif (d > 0.0) {\n\t\t\t\tfloat t = -b - sqrt(d);\n\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\tdist = t;\n\t\t\t\t\tsphere.radius = r;\n\t\t\t\t\tsphere.center = cen;\n\t\t\t\t\tfloat odd = mod(k, 2.0);\n\t\t\t\t\tsphere.color = mix(vec3(0.01, 0.01, 0.01), vec3(0.06+0.05*sin(k), 0.02, 0.06+cos(k)*0.03), odd);\n\t\t\t\t\tsphere.spec = mix(64.0, 64.0, odd);\n\t\t\t\t\tif (k == pick) {\n\t\t\t\t\t\tsphere.spec *= -1.0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvec3 p1 = cen;\n\t\t\tvec3 p2 = p1 + py*4.5*r - px*1.5*r;\n\t\t\tvec3 p3 = p1 + py*1.5*r + px*1.5*r;\n\t\t\tvec3 p4 = p1 - py*2.5*r + px*3.5*r;\n\t\t\tvec2 uv;\n\t\t\tfloat t = rayIntersectsTriangle(ray, dir, p2, p3, p1, uv);\n\t\t\tif (t < 0.0) {\n\t\t\t\tt = rayIntersectsTriangle(ray, dir, p4, p1, p3, uv);\n\t\t\t\tuv = vec2(1.0) - uv;\n\t\t\t}\n\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\tdist = t;\n\t\t\t\tsphere.radius = 100.0;\n\t\t\t\tsphere.center = p1 + pz*80.0; //ray + dir*t + pz;\n\t\t\t\tsphere.color = vec3(0.5, 0.01, 0.02); //texture(iChannel0, uv).rgb;\n\t\t\t\tsphere.spec = sphere.color.r * 16.0;\n\t\t\t\tif (k == pick) {\n\t\t\t\t\tsphere.spec *= -1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tray += dist*dir;\n\tnml = normalize(sphere.center - ray);\n\treturn dist;\n}\n\nfloat pick(vec3 ray, vec3 dir)\n{\n\tfloat dist = 100.0;\n\n\tfloat pick = -1.0;\n\tfloat time = iTime + 450.0;\n\t\n\tfor (float i=0.0; i<3.0; i++) {\n\t\tfor (float j=0.0; j<3.0; j++) {\n\t\t\tfloat k = i*3.0 + j;\n\t\t\t\n\t\t\tfloat r = 0.3+(1.4-0.3*abs(2.0+sin(i+j*4.0)))+0.2*sin(time+k*0.2);\n\t\t\tvec3 cen = vec3(4.0*cos(time*0.12+k), \n\t\t\t\t\t\t\t(-4.5 + k)*(4.0+r),\n\t\t\t\t\t\t\tsin(time*0.33+k));\n\t\t\tcen = rotateTime(k, cen);\n\t\n\t\t\tcen.z += 3.0;\n\t\t\t\n\t\t\tvec3 rc = ray-cen;\n\t\t\tfloat b = dot(dir, rc);\n\t\t\tfloat c = dot(rc, rc) - r*r*2.0;\n\t\t\tfloat d = b*b - c;\n\t\n\t\t\tif (d > 0.0) {\n\t\t\t\tfloat t = -b - sqrt(d);\n\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\tpick = k;\n\t\t\t\t\tdist = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pick;\n}\n\nvec3 shade(vec3 ray, vec3 dir, vec3 nml, float dist, tSphere sphere)\n{\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\n\tvec3 lightPos = vec3(cos(iTime*0.1)*-8.5, sin(iTime*.03)*1.4+5.0, sin(iTime*0.1)*4.0-5.4);\n\t\n\tvec3 shadow = ray-nml*0.0001, snml = vec3(0.0);\n\ttSphere s;\n\tfloat sdist = intersect(shadow, normalize(lightPos - shadow), snml, s, -1.0);\n\n\tvec3 light = normalize(lightPos - ray);\n\tvec3 specCol = normalize(sphere.color+vec3(0.001));\n\t\n\tvec3 bgCol = vec3(0.5, 0.55, 0.65);\n\tvec3 bgLight = normalize(lightPos);\n\tfloat bgDiff = max(0.0, dot(-nml, -bgLight));\n\tvec3 bgRef = reflect(dir, -nml);\n\tfloat bgSpec = max(dot(bgRef, bgLight), 0.0);\n\tbgSpec = pow(bgSpec, 1.0);\n\t\n\tbgCol *= bgDiff;\n\tbgCol += bgSpec * vec3(0.02);\n\tbgCol += max(0.0, dot(-nml, bgLight)) * vec3(0.75, 0.55, 0.35) * 0.1;\n\n\t\t// lighting\n\t\tcol = sphere.color;\n\t\tfloat diff = max(0.0, dot(nml, -light));\n\t\tvec3 ref = reflect(dir, nml);\n\t\tfloat spec = max(dot(ref, light), 0.0);\n\t\tspec = pow(spec, abs(sphere.spec));\n\t\t\n\t\tcol *= diff;\n\tif (s.radius == 0.0) {\n\t\tcol += spec * specCol * 2.0;\n\t} else {\n\t\tcol *= 0.5;\n\t}\n\tfloat a = 1.0 - abs(dot(dir, nml));\n\tif (sphere.spec < 0.0) {\n\t\tcol += a * vec3(0.7, 0.6, 0.4);\n\t}\n\tif (sphere.radius == 0.0) {\n\t\tcol = bgCol;\n\t}\n\n\treturn mix(bgCol, col, 1.0-a*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mUv = iMouse.zw / iResolution.xy;\n\tmUv = 2.0 * mUv - 1.0;\n\tmUv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 eye = vec3(0.0, 1.0, -6.0);\n\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\t\n\tvec3 mouseDir = normalize(vec3(mUv, 1.0));\n\n\tvec3 ray = eye;\n\tvec3 nml = vec3(0.0);\n\t\t\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\t\n\ttSphere sphere;\n\t\n\tfloat picked = pick(ray, mouseDir);\n\t\n\tfloat dist = intersect(ray, dir, nml, sphere, picked);\n\n\t//float fog = clamp(dist / 15.0, 0.0, 1.0);\n\t//fog *= fog;\n\t\n\tfloat refF = 0.0;\n\t\n\tvec3 ref = dir;\n\tcol = shade(ray, ref, nml, dist, sphere);\n\n\tif(sphere.radius > 0.0)\n\t{\n\t\tvec3 diff = normalize(sphere.color);\n\t\tref = reflect(ref, nml);\n\t\tdist = intersect(ray, ref, nml, sphere, picked);\n\t\tcol += 0.3 * diff * shade(ray, ref, nml, dist, sphere);\n\t}\n\n\t//col = (1.0-fog) * col + fog * vec3(0.9, 0.6, 0.4);\n\t\n\t\n\t// gamma correction\n\tcol = 1.0 - exp(-col * 3.5);\n\t\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldj3Rh","date":"1383949542","viewed":458,"name":"Flying on foil wings","username":"kig","description":"Testing ray-triangle intersection and picking. And wobbly rays. Click on the heads to do nothing much.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","picking"],"hasliked":0,"parentid":"","parentname":""}}