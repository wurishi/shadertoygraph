{"ver":"0.1","info":{"id":"MlfBRN","date":"1511227104","viewed":270,"name":"Halftone Test","username":"gsitcia","description":"A simple half-tone shader...","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["halftone","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float avt(sampler2D chan, vec2 uv) {\n    vec3 a = texture(chan,uv).xyz;\n    return (a.r+a.g+a.b)/3.0;\n}\n\nfloat mat(sampler2D chan, vec2 uv, vec3 mask) {\n    vec3 a = texture(chan,uv).xyz;\n    return (a.r*mask.r+a.g*mask.g+a.b*mask.b)/(mask.r+mask.g+mask.b);\n}\n\nvec2 turn(vec2 uv, float angl) {\n    angl = angl*3.141592/180.0;\n    float q = atan(uv.y/uv.x);\n    return vec2(length(uv)*cos(angl+q),length(uv)*sin(angl+q));\n}\n\nfloat halfize(vec2 uv, sampler2D chan, float scale, float angle, vec3 mask) {\n    uv *= scale;\n    angle = -mod(angle,90.0);\n    uv = turn(uv,angle);\n    vec2 ut = vec2(floor(uv.x),floor(uv.y))+vec2(0.5);\n    vec2 u1 = ut+vec2(0.5,0.5);\n    vec2 u2 = ut+vec2(0.5,-0.5);\n    vec2 u3 = ut+vec2(-0.5,0.5);\n    vec2 u4 = ut+vec2(-0.5,-0.5);\n    u1 = turn(u1,-angle);\n    u2 = turn(u2,-angle);\n    u3 = turn(u3,-angle);\n    u4 = turn(u4,-angle);\n    uv = turn(uv,-angle);\n    float z1 = 1.0-mat(iChannel0,u1/scale,mask);\n    float z2 = 1.0-mat(iChannel0,u2/scale,mask);\n    float z3 = 1.0-mat(iChannel0,u3/scale,mask);\n    float z4 = 1.0-mat(iChannel0,u4/scale,mask);\n    float s = (0.4*sqrt(2.0));\n    if (s*z1 < distance(uv,u1)) {\n        z1 = 0.0;\n    } else {\n        z1 = 1.0;\n    }\n    if (s*z2 < distance(uv,u2)) {\n        z2 = 0.0;\n    } else {\n        z2 = 1.0;\n    }\n    if (s*z3 < distance(uv,u3)) {\n        z3 = 0.0;\n    } else {\n        z3 = 1.0;\n    }\n    if (s*z4 < distance(uv,u4)) {\n        z4 = 0.0;\n    } else {\n        z4 = 1.0;\n    }\n    \n    float q = 1.0-clamp(z1+z2+z3+z4,0.0,1.0);\n    return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / min(iResolution.x,iResolution.y);\n\tfloat angle = 15.0;//iTime*10.0; //will be moduloed beteen 0 and 90\n    //float scale = iTime+100.0; /* \n    float scale = 50.0; /**/\n    \n    //         /* \"Uncomment\" this line to see the color version\n    /*/\n    float r = halfize(uv, iChannel0, scale, angle, vec3(1.0,0.0,0.0));\n    float g = halfize(uv, iChannel0, scale+5.0, angle+60.0, vec3(0.0,1.0,0.0));\n    float b = halfize(uv, iChannel0, scale-5.0, angle-15.0, vec3(0.0,0.0,1.0));\n    fragColor = vec4(r,g,b,1.0);\n\t/*/\n    float z = halfize(uv, iChannel0, scale, angle, vec3(1.0,1.0,1.0));\n    fragColor = vec4(z,z,z,1.0);\n    /**/\n    \n    //fragColor = vec4(vec3(clamp(0.0,1.0,z4)),1.0);\n    /*uv = fragCoord.xy / min(iResolution.x,iResolution.y);\n    fragColor = vec4(texture(iChannel0, uv).xyz,1.0); /**/\n    //fragColor = vec4(vec3(z),1.0);\n}","name":"Image","description":"","type":"image"}]}