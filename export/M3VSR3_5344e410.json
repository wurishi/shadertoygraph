{"ver":"0.1","info":{"id":"M3VSR3","date":"1720300408","viewed":62,"name":"spheres-radnyx","username":"radnyx","description":"spheres","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    Learning basic raytracing concepts.\n    Radnyx 2024\n    \n    TODO: \n    - fix reflection color computation\n    - optimizations if necessary\n**/\n\n#define SPHERE_COUNT 3\n#define LIGHT_COUNT 3\n#define INF 1e20\n#define SCALE 256.0\n#define REFLECTION_DEPTH 3\n\n\nconst float FLOOR_Y = -1.15;\nconst vec3 FLOOR_COLOR_1 = vec3(0.8, 0.6, 0.5);\nconst vec3 FLOOR_COLOR_2 = vec3(0.2, 0.3, 0.5);\nconst vec3 AMBIENT_LIGHT_COLOR = vec3(0.2, 0.3, 0.5);\nconst vec3 FOG_COLOR = vec3(0.05, 0.08, 0.25);\n\nconst int TYPE_NONE = 0;\nconst int TYPE_SPHERE = 1;\nconst int TYPE_PLANE = 2;\n\nstruct Sphere {\n    vec3 pos;\n    vec3 col;\n    float r;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    float intensity;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Hit {\n    int type;\n    float t;\n    vec3 normal;\n    int data;\n};\n\nSphere[SPHERE_COUNT] spheres = Sphere[SPHERE_COUNT] (\n    Sphere(vec3(0.4, 0.3, 5.0), vec3(0.2,0.2,1.0), 1.2),\n    Sphere(vec3(-0.6, -0.4, 3.0), vec3(1.0,0.2,0.2), 0.5),\n    Sphere(vec3(1.4, 0.5, 3.0), vec3(0.2,1.0,0.5), 0.25)\n);\n\nLight[LIGHT_COUNT] lights = Light[LIGHT_COUNT] (\n    Light(vec3(2.0, 1.5, 3.0), vec3(1.0, 1.0, 0.8), 10.0), \n    Light(vec3(-1.0, 2.0, -1.0), vec3(0.7, 0.1, 0.6), 20.0),\n    Light(vec3(-1.0, 2.0, 4.0), vec3(0.7, 0.5, 0.1), 14.0)\n);\n\n\nbool hitSphere(int sphere, in Ray ray, float nearestT, out float t) {\n    vec3 pos = spheres[sphere].pos;\n    float r = spheres[sphere].r;\n    \n    vec3 origin = ray.origin - pos;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(origin, ray.dir);\n    float c = dot(origin, origin) - r * r;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) {\n        return false;\n    }\n    \n    float sqrtDiscriminant = sqrt(discriminant); \n    float t1 = (-b + sqrtDiscriminant) / (2.0 * a);\n    float t2 = (-b - sqrtDiscriminant) / (2.0 * a);\n    if (t1 > t2) {\n        float temp = t1;\n        t1 = t2;\n        t2 = temp;\n    }\n    if (t1 >= 0.0) {\n        t = t1;\n        return t < nearestT;  \n    } else if (t2 >= 0.0) {\n        t = t2;\n        return t < nearestT;  \n    }\n    return false;\n}\n\nHit raycast(in Ray ray) {\n    Hit hit = Hit(TYPE_NONE, INF, vec3(0.0), 0);\n    vec3 nearestHitPos = vec3(INF);\n    float nearestDist = INF;\n    \n    float floorT = (FLOOR_Y - ray.origin.y) /  ray.dir.y;\n    if (floorT > 0.0) {\n        hit.type = TYPE_PLANE;\n        hit.t = floorT;\n        hit.normal = vec3(0.0, 1.0, 0.0);\n    }\n    \n    float t;\n    for (int i = 0; i < SPHERE_COUNT; i++) {\n        if (hitSphere(i, ray, hit.t, t)) {\n            hit.type = TYPE_SPHERE;\n            hit.t = t;\n            hit.data = i;\n            hit.normal = normalize((ray.origin + ray.dir * t) - spheres[i].pos);\n        }\n    }\n    return hit;\n}\n\nvec3 color(in Hit hit, in Ray ray) \n{\n    if (hit.type == TYPE_SPHERE) \n    {\n        return spheres[hit.data].col;\n    } \n    else if (hit.type == TYPE_PLANE) \n    {\n        vec3 pos = ray.origin + ray.dir * hit.t;\n        if (int(fract(pos.x) * 2.0) == int(fract(pos.z) * 2.0)) \n        {\n            return FLOOR_COLOR_1;\n        } \n        else \n        {\n            return FLOOR_COLOR_2;\n        }\n    }\n    return vec3(0.0);\n}\n\nvec3 lighting(in Hit hit, in Ray incidentRay) {\n    vec3 incidentPos = incidentRay.origin + incidentRay.dir * hit.t;\n    \n    vec3 light = AMBIENT_LIGHT_COLOR;\n    for (int i = 0; i < LIGHT_COUNT; i++) \n    {\n        vec3 lightPos = lights[i].pos;\n        \n        vec3 dir = normalize(lightPos - incidentPos);\n        vec3 origin = incidentPos + dir * 0.01;\n        Ray shadowRay = Ray(origin, dir);\n        \n        float lightT = (lightPos.x - origin.x) / dir.x;//length(lightPos - origin);\n        Hit lightHit = raycast(shadowRay);\n        \n        \n        \n        \n        // in view of light\n        if (lightHit.t > lightT)\n        {\n            float dotNormalDir = dot(hit.normal, dir);\n            float diffuse = dotNormalDir / (length(hit.normal) * length(dir));\n            \n            vec3 refl = reflect(-dir, hit.normal);\n            vec3 view = normalize(lightPos - incidentRay.origin);\n            float specular = pow(max(0.0, dot(refl, view)) / (length(refl) * length(view)), 8.0);\n            \n            float amount = max(0.0, diffuse) + specular;\n            \n            \n            float distSquared = dot(incidentPos - lightPos, incidentPos - lightPos);\n            light += lights[i].intensity * lights[i].col / distSquared * amount;\n            \n        }\n        // covered in shadow\n        else\n        {\n           \n        }\n    }\n    \n    return clamp(light, vec3(0.0), vec3(2.0));\n}\n\nvec3 getSurfaceColor(in Ray ray, out Hit hit) {\n    hit = raycast(ray);\n    \n    if (hit.type == TYPE_NONE) {\n        return FOG_COLOR;\n    }\n    \n    float fog = 1.0 - clamp(50.0/hit.t, 0.0, 1.0);\n    return mix(color(hit, ray) * lighting(hit, ray), FOG_COLOR, fog);\n}\n\nvec3 raytrace(vec2 uv) {\n    float ratio = iResolution.x / iResolution.y;\n    \n    \n    vec3 position = vec3(0.0, 0.0, 0.0);\n    \n    \n    float xzDist1 = distance(spheres[1].pos.xz, position.xz);\n    position.xz = spheres[0].pos.xz + vec2(cos(iTime * 0.2) * xzDist1, sin(iTime * 0.2) * xzDist1);\n\n    float yaw = 3.14159+atan((position.x - spheres[0].pos.x), (position.z - spheres[0].pos.z));\n    \n    \n    // vec3 position = vec3(0.3 + cos(iTime * 0.9) * 0.8, 0.0, 1.0 + sin(iTime * 0.9) * 0.7);\n    // float yaw = sin(iTime * 0.5) * 0.24 + 0.07;\n    \n    \n    \n    \n    vec3 dir = (vec3((uv.x - 0.5) * ratio, uv.y - 0.5, 1.0));\n    mat2 rot = mat2(cos(yaw), -sin(yaw), sin(yaw), cos(yaw));\n    dir.xz = rot * dir.xz;\n    \n    \n    Ray ray = Ray(position, dir);\n    \n    \n    Hit hit;\n    vec3 col = getSurfaceColor(ray, hit);\n    for (int i = 1; i <= REFLECTION_DEPTH; i++) {\n        // Reflect ray across the surface normal\n        vec3 refl = reflect(ray.dir, hit.normal);\n        \n        // Start at incidence and point toward reflected angle\n        ray.origin = ray.origin + ray.dir * hit.t;\n        ray.dir = refl;\n        ray.origin += ray.dir * 0.01;\n        \n        col = mix(col, getSurfaceColor(ray, hit), 0.3 / float(i));\n    }\n    \n    return col;\n}\n\nvoid fun() {\n    \n    float xzDist1 = distance(spheres[1].pos.xz, spheres[0].pos.xz);\n    spheres[1].pos.zx = spheres[0].pos.zx + vec2(cos(iTime * 0.6) * xzDist1, sin(iTime * 0.6) * xzDist1);\n    \n    float xzDist2 = distance(spheres[2].pos.xz, spheres[0].pos.xz);\n    spheres[2].pos.zx = spheres[0].pos.zx + vec2(cos(-iTime) * xzDist1, sin(-iTime) * xzDist1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = floor(uv * SCALE) / SCALE;\n    \n    fun();\n    \n    // Supersample for anti-aliasing\n    vec3 col = (\n        raytrace(uv + vec2(0.0, 0.25/SCALE)) +\n        raytrace(uv + vec2(0.0, -0.25/SCALE)) +\n        raytrace(uv + vec2(0.25/SCALE, 0.0)) +\n        raytrace(uv + vec2(-0.25/SCALE, 0.0)) \n    ) / 4.0;\n    \n    col.x = pow(col.x, 1.1);\n    col.y = pow(col.y, 1.1);\n    col.z = pow(col.z, 1.1);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}