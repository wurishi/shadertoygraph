{"ver":"0.1","info":{"id":"WlyXRz","date":"1582030527","viewed":160,"name":"P6m with interlaced ribbons","username":"curena","description":"\nA bug in shadertoy introduced two different \"image\" boxes, so this doesn't run, and I've moved this to: [url]https://www.shadertoy.com/view/tlyXzW[/url]","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["p6mm","planarsymmetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int   n_aa  = 3 ;\nconst float pi    = 3.1415927 ;\nconst float xfrec = 3.0 ;\n\nvec4 p6mm_patterns_sum( vec2 p )\n{  \n    \n    const float w   = 30.0 ; // time units for each rotation\n    float       a   = (iTime*2.0*pi)/w,        \n                ca  = cos(a), \n                sa  = sin(a),\n                s   = 3.5 + 3.0*sin( iTime/2.0 );\n    mat2        rot = mat2( ca, -sa, sa, ca );\n    vec2        d   = 0.001*vec2( iTime, 0.2*iTime );\n        \n    return p6mm_pattern( s*rot*(d+p) );\n}\n\n//-------------------------------------------------------------------------------------\nvec4 AA_pixel_color( in vec2 pixel_coords )\n{\n    vec4        sum    = vec4( 0.0, 0.0, 0.0, 1.0 );\n    const float n      = float(n_aa);\n    const vec2  c      = vec2( 0.5, 0.5 );\n    float       scale  = xfrec/iResolution.x ;\n\n    for( int i = 0 ; i < n_aa ; i++ )\n    for( int j = 0 ; j < n_aa ; j++ )\n    {\n       vec2 samplep = pixel_coords + 1.001*(c+vec2(i,j)/n) ;\n       sum = sum + p6mm_patterns_sum( scale*(samplep-0.5*iResolution.xy) ); ;\n    }\n    return sum/(n*n);\n}\n\n//-------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AA_pixel_color( fragCoord ) ;\n    //fragColor = p6mm_pattern( 0.001*fragCoord );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// -----------------------------------------------------------------------------------\n//\n// Carlos UreÃ±a, Apr,2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n// ----------------------------------------------------------------\n// ISLAMIC STAR PATTERN related functions\n\n\n// parameters and pre-calculated constants\nconst float \n    sqr2       = 1.41421356237, // square root of 2\n    sqr3       = 1.73205080756, // square root of 3.0\n    sqr2_inv   = 1.0/sqr2 ,\n    sqr3_inv   = 1.0/sqr3 ,\n    cos30      = 0.86602540378, // cos(30 degrees)\n    sin30      = 0.50000000000, // sin(30 degrees)\n    l          = 5.5,          // length of triangle in NDC (mind --> 1.0)\n    l_inv      = 1.0/l ,       // length inverse\n    line_w     = 0.03,         // line width for basic symmetry lines render\n    sw         = 0.020 ;       // stripes half width for islamic star pattern\n\nconst vec2  \n    u        = 1.0*vec2( 1.0, 0.0  ) ,          // grid basis: U vector\n    v        = 0.5*vec2( 1.0, sqr3 ) ,          // grid basis: V vector\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,     // dual grid basis: U vector\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,     // dual grid basis: V vector\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ;      // triangle center\n\n    \n// -----------------------------------------------------------------------------------\n// point orbit transformation parameters\nint \n    nMirrorOdd = 0 , \n    nMirror    = 0 ,\n\tnGridX     = 0 , \n    nGridY     = 0 ;\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through 'v1' and 'v2'\n// (only for points to right of the line from v1 to v2)\n//\nvec2 Mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n    \n    if ( 0.0 <= d )\n    {\n       nMirrorOdd = 1-nMirrorOdd ;\n       nMirror = nMirror+1 ;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to line through 'v1' and 'v2'\n\nfloat SignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------\n// un-normalized signed distance to line\n\nfloat UnSignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           un = vec2( s.y, -s.x ) ;\n    return dot(p-v1,un) ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to polyline from 'v1' \n// to 'v2' then to 'v3'\n\nfloat DoubleSignedDistance( vec2 p, vec2 v1, vec2 v2, vec2 v3 )\n{\n \t\n    vec2  dir1 = v2 + normalize(v1-v2),\n          dir3 = v2 + normalize(v3-v2);      \n    vec2  vm   = 0.5*(dir1+dir3) ;\n    float dm   = UnSignedDistance( p, v2, vm ) ;\n    \n    if ( dm >= 0.0 )\n   \t\treturn SignedDistance( p, v1, v2 ) ;\n   \telse\n        return SignedDistance( p, v2, v3 ) ; \n}\n// -------------------------------------------------------------------------------\n// Takes 'p0' to the group's fundamental region, returns its coordinates in that region\n\nvec2 p6mm_ToFundamental( vec2 p0 ) \n{\n    nMirrorOdd = 0 ;\n    nMirror    = 0 ;\n    \n    // p1 = fragment coords. in the grid reference frame\n    \n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n    \n    // p2 = fragment coords in the translated grid reference frame \n    \n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n    \n    nGridX = int(p1.x-p2.x) ; // largest integer g.e. to p1.x\n    nGridY = int(p1.y-p2.y) ; // largest integer g.e. to p2.x\n    \n    // p3 = barycentric coords in the translated triangle\n    // (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n    \n    vec2 p3 = Mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n    \n    // p4 = p3, but expressed back in cartesian coordinates\n    \n    vec2 p4 = p3.x*u + p3.y*v ;\n    \n    // p7 = mirror around the three lines through the barycenter, perp. to edges.\n    \n    vec2 p5 = Mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = Mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = Mirror( p6, tri_cen, vec2(0.0,0.0) );\n  \n    return p7 ;\n}\n\n// --------------------------------------------------------------------\n// A possible distance function\n\nfloat DistanceFunc( float d )\n{\n   return 1.0-smoothstep( line_w*0.5, line_w*1.5, d );   \n}\n\n// -------------------------------------------------------------------------------\n// Point color for basic symmetry lines in (r,g,b)\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    \n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( SignedDistance( pf, tri_cen, vec2(0.0,0.0) ) );\n     \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n        \n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n    \n    return res ;    \n}\n\n// ---------------------------------------------------------------------\n// Stripe half width for star pattern\n\nvec4 Stripe( float d )\n{\n   if ( d > sw*0.85 )\n     return vec4( 0.0,0.0,0.0,1.0 );\n   else\n     return vec4(1.0,1.0,1.0,1.0)  ;\n}\n\n// ---------------------------------------------------------------------\n// Color for islamic star pattern\n\nvec4 p6mm_pattern( vec2 p )\n{\n    vec2 pf = p6mm_ToFundamental( p );\n    \n    //return p6mm_SimmetryLines( p ) ;\n    vec2 c  = tri_cen ;\n    \n    // constants defining the stripes \n    float \n        f   = 0.30 ,\n        fs1 = 0.14 ,\n        s1  = fs1*c.x,\n        s2  = 0.5*s1 ;\n        \n    // stripes vertexes\n    vec2 \n        // upper strip\n        u1 = vec2( f*c.x, 0.0 ) ,\n        u2 = vec2( c.x, (1.0-f)*c.y ),\n        \n        // lower strip\n        l1 = vec2( c.x, s1+s2 ),\n        l2 = vec2( c.x-s2, s1 ),\n        l3 = vec2( sqr3*s1, s1 ),\n        \n        // right strip\n        r1 = vec2( c.x-s1, (1.0-fs1)*c.y ),\n        r2 = vec2( c.x-s1, s2 ) ,\n        r3 = vec2( c.x-s1-s2, 0.0 ),\n        \n    \t// origin star strip\n        mm = vec2( s1*(sqr3-1.0/3.0), s1*(1.0-sqr3_inv) );\n                        \n    // signed and unsigned distances to stripes:\n    \n    float\n        d1s = SignedDistance( pf, u1, u2 ) ,\n        d2s = DoubleSignedDistance( pf, l1, l2, l3 ) ,\n        d3s = DoubleSignedDistance( pf, r1, r2, r3 ) ,\n        d4s = DoubleSignedDistance( pf, u1, mm, l3 ) ,\n        d1  = abs( d1s ),\n        d2  = abs( d2s ),\n        d3  = abs( d3s ),\n        d4  = abs( d4s );\n    \n   \n    // stripes inclusion\n    bool in1, in2, in3, in4 ;\n    \n    if ( nMirrorOdd == 0 )\n    {\n        in1 = (d1 < sw) && ! (d2 < sw) && ! (d4 < sw);\n        in2 = (d2 < sw) && ! (d3 < sw);\n        in3 = (d3 < sw) && ! (d1 < sw);\n        \n        in4 = (d4 < sw) && ! (d2 < sw);\n    }\n    else\n    {\n        in1 = (d1 < sw) && ! (d3 < sw) ;\n        in2 = (d2 < sw) && ! (d1 < sw) && ! (d4 < sw);;\n        in3 = (d3 < sw) && ! (d2 < sw);\n        \n        in4 = (d4 < sw) && ! (d1 < sw);\n    } \n    \n    vec4 col ;\n    \n    // compute final color\n    \n    if ( in1 )      \n        col = Stripe( d1 ) ;\n    else if ( in2 ) \n        col = Stripe( d2 ) ;\n    else if ( in3 ) \n        col = Stripe( d3 ) ; \n    else if ( in4 )\n        col = Stripe( d4 ) ;   \n    else if ( d2s < 0.0 && d3s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.0, 1.0 ) ;\n    else if ( d1s < 0.0 && d2s < 0.0 || d1s <0.0 && d3s < 0.0 )\n        col = vec4( 0.1, 0.1, 0.1, 1.0 );\n    else if ( d1s < 0.0 || d2s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.9, 1.0 );   \n    else    \n        col = vec4( 0.6, 0.0, 0.0, 1.0 ) ; \n       \n    return col ;\n}\n\nbool lastInFundamental()\n{\n \treturn nGridX ==0  && nGridY == 0 && nMirrorOdd == 0 && nMirror == 0  ;   \n}","name":"Common","description":"","type":"common"}]}