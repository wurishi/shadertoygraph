{"ver":"0.1","info":{"id":"3dXGR2","date":"1546806178","viewed":269,"name":"KoleidoRose","username":"gPlatl","description":"Milo's Rose koleidoscopic coated - just trying out a crazy idea ... improvable ...\nChange Koleidoscope colors and rotate rose with your mouse.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","colors","flower","rose","koleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------------------\n// KoleidoRose_Image.glsl                            by Gerd Platl                    \n//\n//  https://www.shadertoy.com/view/3dXGR2 \n//  v1.0   2019-01-06  \n//\n// Fractal Koleidoscope coats Milo's Rose...\n// Milo's Rose:     https://www.shadertoy.com/view/XsdyWr  \n// Fractaloscopic:  https://www.shadertoy.com/view/4lXyWS \n//\n// Change Koleidoscope colors and rotate rose with your mouse.\n//\n// tags: rose, flower, raymarching, koleidoscope, fractal, colors\n//----------------------------------------------------------------\n\n// ray marching\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01;\nconst float grad_step = 0.01;\nconst float clip_far = 10.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 rotationXY( vec2 angle ) \n{\n\tvec2 c = cos(angle), s = sin(angle);\n\treturn mat3(\n        c.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x);\n}\n\n// distance function\nfloat opI(float d1, float d2) { return max(d1, d2); }\nfloat opU(float d1, float d2) { return min(d1, d2); }\nfloat opS(float d1, float d2) { return max(-d1,d2); }\n\nfloat sdPetal(vec3 p, float s)\n{\n    p = p * vec3(0.8, 1.5, 0.8) + vec3(0.1, 0.0, 0.0);\n    vec2 q = vec2(length(p.xz), p.y);\n    \n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n    \n    float upper = length((q - vec2(s, 0)) * vec2(1, 1)) + 1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n    \n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) \n{\n    float d = 1000.0, s = 2.0;\n    mat3 r = rotationXY(vec2(0.1, PI2 * 0.618034));\n    r = r * mat3(1.08,0.0,0.0 ,0.0,0.995,0.0, 0.0,0.0,1.08);\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.02, 0.0);\n        s *= 1.05;\n    }\n    return d;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) \n{\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = map( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.3;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nconst vec3 light_pos = vec3( 20.0, 50.0, 20.0 );\n\nvec3 shading(vec3 v, vec3 n, vec3 eye) \n{\n\tvec3 ev = normalize(v - eye);\n    vec3 mat_color = vec3(0.7+0.3*sin(iTime)\n                         ,0.7+0.3*sin(iTime*0.988)\n                         ,0.7+0.3*sin(iTime*1.234));\n    vec3 col = texture(iChannel0, mod(0.2*n.xz+0.5, 1.0)).xyz;\n\tmat_color = mix(mat_color, col, 0.6);\n    \n    vec3 vl = normalize(light_pos - v);\n\n    float diffuse = dot(vl, n) * 0.5 + 0.5;\n    vec3 h = normalize(vl - ev);\n    float rim = pow(1.0 - max(dot(n, -ev), 0.0), 2.0) * 0.15;\n    float ao = clamp(v.y * 0.5 + 0.5, 0.0, 1.0);\n    return (mat_color * diffuse + rim) * ao;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) \n{\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mp = iMouse.xy / iResolution.xy;\n\n\t// default ray dir\n\tvec3 dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 5.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY(vec2(-1.0, 1.0));\n    if (iMouse.x > 0.0)\n\t\trot = rotationXY(mp.yx * vec2(PI,-PI2) \n                               + vec2(PI * -0.5, PI));\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching(eye, dir, 0.0, clip_far);\n    vec3 pos = eye + dir * depth;\n    vec3 c = vec3(0.3, 0.1, 0.2);\n    if (depth < clip_far) \n    {   // shading\n        vec3 n = gradient( pos );\n        c = shading(pos, n, eye);\n    }\n    \n    float r = 1.2 - length(mp.xy - 0.5) * 0.5;\n//\tc = texture(iChannel0, uv).xyz;   // Fractaloscopic picture test\n    fragColor = vec4(c * r, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//----------------------------------------------------------------\n// KoleidoRose_BufA.glsl                             by Gerd Platl\n// see Fractaloscopic        https://www.shadertoy.com/view/4lXyWS \n//----------------------------------------------------------------\n\n#define time iTime\n#define resolution iResolution\n\n//----------------------------------------------------------------\n\nconst float NUM_SIDES = 5.0;  // set your favorite mirror factor here\n\nconst float PI = 3.14159265359;\n\nconst float KA = PI / NUM_SIDES;\n\n//----------------------------------------------------------------\n// transformation to koleidoscopic coordinates\n//----------------------------------------------------------------\nvoid koleidoscope(inout vec2 uv)\n{\n  // get the angle in radians of the current coords relative to origin (i.e. center of screen)\n  float angle = atan (uv.y, uv.x);\n  // repeat image over evenly divided rotations around the center\n  angle = mod (angle, 2.0 * KA);\n  // reflect the image within each subdivision to create a tilelable appearance\n  angle = abs (angle - KA);\n  // rotate image over time\n  angle += 0.1*time;\n  // get the distance of the coords from the uv origin (i.e. center of the screen)\n  float d = length(uv); \n  // map the calculated angle to the uv coordinate system at the given distance\n  uv = d * vec2(cos(angle), sin(angle));\n}\n//----------------------------------------------------------------\n// equal to koleidoscope, but more compact \n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv)\n{\n  float angle = abs (mod (atan (uv.y, uv.x), 2.0 * KA) - KA) + 0.1*time;\n  uv = length(uv) * vec2(cos(angle), sin(angle));\n}\n//----------------------------------------------------------------\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 12.0*(2.0 * fragCoord.xy / resolution.xy - 1.0);\n  uv.x *= resolution.x / resolution.y;\n  //uv.x += 2.*sin(2.*time);\n  vec2 mouse = iMouse.xy / resolution.xy;\n  uv *= 0.1+mouse.x;\n    \n  //koleidoscope(uv);\n  smallKoleidoscope(uv);\n    \n  // Fractal Colors by Robert SchÃ¼tze (trirop): http://glslsandbox.com/e#29611\n  vec3 p = vec3 (uv, mouse.x);\n  for (int i = 0; i < 44; i++)\n    p.xzy = vec3(1.3,0.999,0.678)*(abs((abs(p)/dot(p,p)-vec3(1.0,1.02,0.4-mouse.y*0.04))));\n  \n  fragColor = vec4(p,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}