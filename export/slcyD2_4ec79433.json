{"ver":"0.1","info":{"id":"slcyD2","date":"1660568019","viewed":161,"name":"Transmittance Table For Sky","username":"H2ongzh","description":" \nReference:\nhttps://ebruneton.github.io/precomputed_atmospheric_scattering/","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["atmosphererendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Authur: Hong Zhang\n// Date: 08/15/2022\n// precompute the transmittance table for the sky rendering\n\n#define outScatterSamples 600\n#define MaxV 1e9\nconst float r_e = 6360.0;  // the radius of the earth\nconst float r_a = 6420.0;  // the radius of the atmosphere\nconst float r_a_limit = 6421.0;  \n\nconst float Hr = 8.0; // scale height for rayleight\nconst float Hm = 1.2; // scale height for mie\nconst vec3 betaR = vec3(5.8, 13.5, 33.1) * 1e-3; // rayleigh scattering coeffcient\nconst vec3 betaMS = vec3(4e-3);   // mie scattering coeffcient\nconst vec3 betaME = betaMS / 0.9;   // mie extinction coeffcient\n\n// compute the intersections\nvec2 computeIntersection(vec3 origin, vec3 ray, float radius){\n    float factor = pow(dot(origin, ray), 2.) - (dot(origin, origin) - radius * radius);\n    if(factor >= 0.){\n        float t1 = -dot(origin, ray) - sqrt(factor);\n        float t2 = -dot(origin, ray) + sqrt(factor);\n        return vec2(t1, t2);\n    }\n    return vec2(MaxV, -MaxV);\n}\n\n// compute the entry point of the sun ray on the top of atmosphere\nvec3 computeEnd(vec3 start, vec3 dir){\n    vec2 t_ab = computeIntersection(start, dir, r_a_limit);\n    return start + max(t_ab.x , t_ab.y) * dir;\n}\n\n\n\n// compute the optical depth\nfloat opticalDepth(float Hs, float rh, float cos_alpha){\n    if(cos_alpha < -sqrt(1. - r_e * r_e / rh / rh)){  // if the sun ray is below the horizon (in the shadow of the Earth)\n        return MaxV;\n    }\n    vec3 start = vec3(0., rh, 0.);\n    vec3 dir = vec3(1. - sqrt(cos_alpha * cos_alpha), cos_alpha, 0.0);\n    vec3 end = computeEnd(start, dir);\n    \n    vec3 interval = (end - start)/float(outScatterSamples);\n    float sum = 0.;\n    for (int i = 0; i < outScatterSamples; ++i) {\n        vec3 sample_p = start + interval * float(i);\n        sum += exp(- (length(sample_p) - r_e)/ Hs);\n    }\n    return sum * length(interval); \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float r_h, cos_alpha;\n    r_h = 1. - fragCoord.y / iResolution.y; // altitude for y axis\n    cos_alpha = fragCoord.x / iResolution.x; // view-zenith angle for x axis\n\n    r_h = r_e + pow(r_h, 2.0) * (r_a - r_e);  // non-linear sampling\n    cos_alpha = -0.15 + tan(1.5 * cos_alpha) / tan(1.5) * (1.0 + 0.15); // non-linear sampling\n    \n    vec3 depth = betaR * opticalDepth(Hr, r_h, cos_alpha) + betaME * opticalDepth(Hm, r_h, cos_alpha);\n    fragColor = vec4(exp(-depth), 0.0);\n   \n}\n\n\n","name":"Image","description":"","type":"image"}]}