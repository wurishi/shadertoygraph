{"ver":"0.1","info":{"id":"ltS3Dh","date":"1429979343","viewed":1054,"name":"Stairs","username":"dila","description":"Coloured light projection test.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["light","window","stairs","project"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define DUST_SAMPLES 0\n#define WND_DIST 2.0\n#define WND_WIDTH 3.5\n#define WND_HEIGHT 3.0\n#define WND_FREQ 8.0\n\nconst float pi = 3.14159265359;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat infBox( vec3 p, float b )\n{\n  \treturn max(abs(p.x)-b,0.0);\n    //p.y -= p.z * 0.5;\n    //return length(max(abs(p.xy)-vec2(b,10.0),0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 post(vec3 pos, float t)\n{\n    //pos.x += sin(t*0.25) * 2.0;\n    return pos;\n}\n\nvec3 glass(vec3 pos, vec3 size)\n{\n    //return vec3(1.0, 1.0, 0.0);\n\tvec2 uv = pos.zy / size.zy;\n    uv.x *= WND_WIDTH / WND_HEIGHT;\n    \n    vec2 auv = abs(uv);\n    \n    if (auv.x > 1.0 || auv.y > 1.0) {\n        //return vec3(1.0, 1.0, 0.5);\n    }\n    \n    vec2 bv = fract(uv*5.0) * 2.0 - 1.0;\n    vec2 fl = floor(uv*5.0);\n    \n    float lt = -0.8;\n    if (bv.x<lt || bv.y<lt) {\n    \treturn vec3(0.0);\n    }\n    \n    vec3 col = vec3(cos(fl.x)*cos(fl.y),\n                    sin(fl.x)*cos(fl.y),\n                    sin(fl.y));\n    \n    col = col * 0.25 + 0.75;\n    \n\treturn col;\n}\n\nvec3 glassrep(vec3 pos)\n{\n    float wdist = 4.5;\n    float sp = WND_FREQ;\n    vec3 wps = pos;\n    wps.y -= floor(wps.z/sp) * sp * 0.5;\n    wps.z = fract(wps.z/sp)*sp;\n    float wndx = abs(wps.x);\n    vec3 wnd = vec3(wdist-wndx, wps.y-5.0, wps.z-4.0);\n    return glass(wnd+vec3(0.0,WND_DIST,0.0), vec3(2.0,WND_HEIGHT,WND_WIDTH));\n}\n\nvec2 staircase(vec3 pos)\n{\n    vec3 spos = pos;\n    vec3 lpos = vec3(spos.x,pos.y,spos.z);\n    float d = 1000.0;\n    for (int i = -1; i <= 1; ++i) {\n        float repz = fract(-lpos.z) * 0.5 - 0.5 + float(i);\n        float stepinc = floor(lpos.z);\n        vec3 crep = vec3(lpos.x, (lpos.y*2.0-stepinc-float(i)), repz);\n        float k = udBox(crep, vec3(6.0, 2.0, 1.0)*0.5);\n        d = min(d, k);\n    }\n    return vec2(d,1.0);\n}\n\nbool alpha;\n\nvec2 walls(vec3 pos)\n{\n    float wdist = 4.5;\n    vec3 axp = vec3(wdist-abs(pos.x), pos.y, pos.z);\n    float pl = infBox(axp, 1.0);\n    \n    float d = 1000.0;\n    for (int i = -1; i <= 1; ++i) {\n        float sp = WND_FREQ;\n        vec3 wps = pos;\n        wps.y -= floor(wps.z/sp) * sp * 0.5;\n        wps.z = fract(wps.z/sp)*sp;\n        wps.z += float(i) * sp;\n        float wndx = wps.x;//abs(wps.x);\n        vec3 wnd = vec3(wdist-wndx, wps.y-5.0, wps.z-4.0);\n        float wp = sdBox(wnd+vec3(0.0,WND_DIST,0.0), vec3(2.0,WND_HEIGHT,WND_WIDTH));\n        d = min(d, wp);\n    }\n    float fd = max(pl, -d);\n    return vec2(fd, 2.0);\n}\n\nvec2 skybox(vec3 pos)\n{\n\tfloat ps = abs(pos.y) - 20.0 - pos.z * 0.5;\n    return vec2(-ps, 0.0);\n}\n\nvec2 pane(vec3 pos)\n{\n    if (!alpha) {\n        float gl = 4.5 - abs(pos.x);\n        return vec2(gl, 3.0);\n    }\n    return vec2(1000.0, 3.0);\n}\n\nfloat material(vec3 pos)\n{\n\tvec2 sa = staircase(pos);\n    vec2 wp = walls(pos);\n    if (wp.x < sa.x) {\n    \tsa = wp;\n    }\n    wp = pane(pos);\n    if (wp.x < sa.x)\n    {\n        sa = wp;\n    }\n\treturn sa.y;\n}\n\nfloat map(vec3 pos)\n{\n\tvec2 sa = staircase(pos);\n    vec2 wp = walls(pos);\n\tvec2 pn = pane(pos);\n\treturn min(min(sa.x,wp.x),pn.x);\n}\n\nvec3 surfaceNormal(vec3 pos)\n{\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);\n    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);\n    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 pos = o + r * t;\n        float d = map(post(pos,t));\n        if (abs(d)<0.0001) {\n            break;\n        }\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 lightpos(vec3 world)\n{\n    //vec3 lps = vec3(10.0,0.0,0.0) * zrot(iTime);\n    vec3 lps = vec3(10.0,4.0,-2.5);\n    return lps;\n}\n\nvec3 light(vec3 world, vec3 wsn)\n{\n    vec3 col = vec3(0.0);\n    float lm = 1.0;\n    vec3 lps = lightpos(world);\n    vec3 lp = world + lps;\n    vec3 ublv = world - lp;\n    vec3 lv = ublv + wsn * 0.01;\n    float ld = length(lv);\n    lv /= ld;\n    float lt = trace(lp, lv);\n    if (lt >= ld) {\n\t\tvec3 plane = vec3(1.0, 0.0, 0.0);\n        vec3 porg = vec3(3.5, 0.0, 0.0);\n        vec3 del = porg - world;\n        float x = dot(del, plane) / dot(normalize(ublv), plane);\n\t\tvec3 proj = world + lv * x;\n        col = glassrep(proj);\n    }\n    return col;\n}\n\nvec2 projtex(vec3 p, vec3 sn)\n{\n    vec3 asn = abs(sn);\n    float msn = max(asn.x, max(asn.y, asn.z));\n    if (asn.x == msn) {\n        return vec2(p.y, p.z);\n    } else if (asn.y == msn) {\n        return vec2(p.x, p.z);\n    } else {\n        return vec2(p.x, p.y);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ns = uv;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv)*0.33)) * 0.95;\n    \n    //r *= xrot(-pi*0.2);\n    //r *= yrot(iTime*0.25);\n    r *= yrot(-pi*0.3);\n    \n    float gt = iTime * 1.0;\n    \n    vec3 o = vec3(0.0,1.0,2.0) * gt;\n    \n    float eve = abs(sin(gt*10.0))*0.25;\n    o += vec3(0.0, 4.0, 0.0);\n    \n    alpha = false;\n    float t = trace(o, r);\n    \n    vec3 world = o + r * t;\n    vec3 wsn = surfaceNormal(post(world,t));\n    float tp = max(dot(wsn,-r), 0.0);\n    \n    float fd = map(post(world,t));\n    float fog = 1.0 / (1.0 + t * t * 0.01 + fd * 100.0);\n    \n    vec2 tuv = projtex(world, wsn) * 0.2;\n    vec3 texf = texture(iChannel1, tuv).xyz;\n    vec3 diff = texf * 0.5;\n    \n    if (material(world) == 3.0) {\n\t\tdiff = glassrep(world) * 0.25;\n        //vec3 ref = reflect(wsn, -r);\n        //vec3 rtex = texture(iChannel1, ref).xyz;\n        //diff = mix(diff, rtex, 1.0-tp);\n    }\n    \n    alpha = true;\n    \n\tvec3 lm = light(world, wsn);\n    \n    const int ni = DUST_SAMPLES;\n    vec3 vol = vec3(0.0);\n    for (int i = 0; i < ni; ++i) {\n        vec3 rll = r * zrot(float(i)/float(ni)*pi*2.0);\n        float xtex = atan(rll.z,rll.x);\n        vec2 ltf = vec2(xtex,rll.y) * 1.0;\n        float bs = texture(iChannel0, ltf).x;\n        bs = min(pow(bs,2.0),1.0);\n        float td = bs * min(t,20.0);\n        float tds = 1.0 / (1.0 + td * 0.01);\n        vec3 p = o + r * td;\n        vec3 vl = light(p,vec3(0.0));\n        vol += vl / float(ni) * tds;\n    }\n    \n    float skyp = 1.0 / (1.0 + t * t * 1.0);\n    \n    vec3 lpos = lightpos(world);\n    vec3 ldel = normalize(lpos - world);\n    float ldn = abs(dot(ldel,-wsn));\n    vec3 refv = reflect(ldel, wsn);\n    float spd = max(dot(refv, -r), 0.0);\n    \n    //diff += vec3(1.0) * pow(spd,4.0);\n    \n    vec3 fogc = vec3(255.0, 255.0, 255.0) / 255.0;\n    \n    //diff *= 0.25;\n    \n    vec3 fc = diff * fog;//mix(fogc, diff, fog);\n    \n    vec3 lit = lm * fog + vol;// * (1.0 + t * 0.05);\n    \n    fc += lit;\n    \n\tfragColor = vec4(fc,1.0);\n}","name":"","description":"","type":"image"}]}