{"ver":"0.1","info":{"id":"WtScW3","date":"1595453030","viewed":299,"name":"minecraft biomes perlin noise","username":"HalbFettKaese","description":"Made to mirror minecraft's biome mechanics.\nFor elaboration, see slicedlime's video:\nhttps://youtu.be/VYZl2MUat-M","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//The weights of the different noise frequencies.\nstruct NoiseType { \n    int firstOctave;\n\tfloat[3] amplitudes;\n};\n    \nNoiseType altitude_noise = NoiseType(-1, float[](1., 0.5, 0.25));\nNoiseType weirdness_noise = NoiseType(-1, float[](1., 0.5, 0.25));\nNoiseType temperature_noise = NoiseType(-1, float[](1., 0.5, 0.25));\nNoiseType humidity_noise = NoiseType(-1, float[](1., 0.5, 0.25));\n\n//The layout of a biome definition.\nstruct Biome {\n\tvec3 color;\n    vec4 noise;\n    float offset;\n};\n\n//The list of biomes in the world.\nconst Biome[] biomes = Biome[](\n\tBiome(\n        vec3(0.25, 0.25, 1.0), //color \n        vec4(1, 0, 0, 0),      //noise parameters, i.e. temparature, weirdness etc.\n        0.),                   //offset\n\tBiome(\n        vec3(0.5, 0.7, 0.22), \n        vec4(0, -.5, 0, .5), \n        .3),\n\tBiome(\n        vec3(0.97, 0.91, 0.64), \n        vec4(0, -1, 0, .25), \n        0.)\n);\n\n//The zoom that the image is rendered at.\nconst float zoom = 5.;\n\n//The seed of the world. Note that the RNG method is most likely different from the real game.\nconst int initialSeed = 0;\n\n//Used to draw the chunk borders.\n//Describes the length on the screen at zoom = 1. that one chunk corresponds to.\n//This is only really an external variable because I don't know the actual unit size.\nconst float unit = .25;\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}\n\nfloat hash21(vec2 q, int seed) {\n    vec3 p = vec3(q, seed);\n    p = fract(p * vec3(233.34, 851.74, 137.43));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 grad(vec2 p, int seed) {\n\tint val = int(hash21(p, seed) * 1024.);\n    return vec2((val & 1) * 2 - 1, (val & 2) - 1);\n}\n\nfloat lerp(float a, float b, float c) {\n\treturn a + smoothstep(0., 1., c) * (b - a);\n}\n\nfloat perlin(vec2 uv, int seed) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    vec2 ij = vec2(0, 1);\n    float a = dot(fr - ij.xx, grad(fl + ij.xx, seed));\n    float b = dot(fr - ij.xy, grad(fl + ij.xy, seed));\n    float c = dot(fr - ij.yx, grad(fl + ij.yx, seed));\n    float d = dot(fr - ij.yy, grad(fl + ij.yy, seed));\n\treturn lerp(\n    \tlerp(a, b, fr.y), lerp(c, d, fr.y), fr.x\n    );\n}\n\nfloat layeredPerlin(vec2 uv, int seed, NoiseType noise) {\n\tint l = noise.amplitudes.length();\n    float result = 0.;\n    float total = 0.;\n    float octave = float(noise.firstOctave);\n    for (int i = 0; i < l; i++) {\n        seed = hash(seed);\n    \tresult += perlin(uv * pow(2., -octave), seed) * noise.amplitudes[i];\n        total += noise.amplitudes[i];\n        octave -= 1.;\n    }\n    return -result/total;\n}\n\nfloat sq(float x) {\n\treturn pow(x, 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iMouse.xy)/iResolution.xx;\n    \n    uv *= zoom;\n    \n    //Draw grid lines\n    vec2 m = mod(uv, unit);\n    \n    if (m.x < zoom/iResolution.x || m.y < zoom/iResolution.x) {\n    \tfragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    //Generate noise map\n    int s = initialSeed;\n    vec4 n = vec4(\n        layeredPerlin(uv, s + 3, altitude_noise), \n        layeredPerlin(uv, s + 5, weirdness_noise), \n        layeredPerlin(uv, s + 7, temperature_noise), \n        layeredPerlin(uv, s + 11, humidity_noise));\n\n    vec3 col = vec3(0);\n    \n    //Get biome closest to noise map at current position\n    float closestDist = 0.;\n    \n    for (int i = 0; i < biomes.length(); i++) {\n    \tBiome biome = biomes[i];\n        vec4 n2 = biome.noise;\n        float dist = \n            sq(n.x - n2.x) + \n            sq(n.y - n2.y) + \n            sq(n.z - n2.z) + \n            sq(n.w - n2.w) + \n            sq(biome.offset);\n        if (i == 0 || dist < closestDist) {\n            col = biome.color;\n        \tclosestDist = dist;\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}