{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Quadratic bezier curve distance evaluation\n\nfloat length2(vec2 v) { return dot(v, v); }\n\nint SolveCubic(in float a, in float b, in float c, out float r[3])\n{\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tif(abs(p) < abs(q)*0.005) {\n\t\t\tif(q < 0.0) v = p / (3.0 * -pow(-q,1.0/3.0));\n\t\t\telse u = p / (3.0 * pow(q,1.0/3.0));\t\n\t\t}\t\n\t\tr[0] = offset + u + v;\t\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\treturn 3;\n}\n\nfloat Distance2ToQBSpline(in vec2 P0, in vec2 P1, in vec2 P2, in vec2 p)\n{\n\tvec2  sb = (P1 - P0) * 2.0;\n\tvec2  sc = P0 - P1 - P1 + P2;\n\tvec2  sd = P1 - P0;\n\tfloat sA = 1.0 / dot(sc, sc);\n\tfloat sB = 3.0 * dot(sd, sc);\n\tfloat sC = 2.0 * dot(sd, sd);\n\t\n\tvec2  D = P0 - p;\n\n\tfloat a = sA;\n\tfloat b = sB;\n\tfloat c = sC + dot(D, sc);\n\tfloat d = dot(D, sd);\n\n    float res[3];\n\tint n = SolveCubic(b*a, c*a, d*a, res);\n\n\tfloat t = clamp(res[0],0.0, 1.0);\n\tvec2 pos = P0 + (sb + sc*t)*t;\n\t\n\tfloat dis2 = length2(pos - p);\n\t\n\tif(n>1) {\n\t\tt = clamp(res[1],0.0, 1.0);\n\t\tpos = P0 + (sb + sc*t)*t;\n\t\tdis2 = min(dis2, length2(pos - p));\n\t\t\n\t\tt = clamp(res[2],0.0, 1.0);\n\t\tpos = P0 + (sb + sc*t)*t;\n\t\tdis2 = min(dis2, length2(pos - p));\t    \n\t}\n\t\n\treturn dis2;\n}\n\n// Put the function to the test, draw a bunch of connected curves -------------------\n\n\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\n// motion of control points and tangents.\nvec2 P(float i) {\n    float t = iTime*.5;\n\tvec4 c = hash4(i);\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int segCount = 8;\n\tvec2 p[2 * segCount + 1];\n\t\n\tfloat j =0.;\n\tfor (int i = 0; i <= segCount*2; ++i) {\n\t\tp[i] = P(j)*iResolution.xy*.25 + iResolution.xy*.5;\n\t\tj += 1.;\n\t}\n\t\n\tfloat d0 = 1e10; // Distance(squared) to spline \n\tfloat d1 = 1e10; // Distance(squared) to control point (segment start/end)\n\tfor (int i = 0; i < segCount; ++i) {\n\t\tif(i > 0) p[2*i+1] = 2.0 * p[2*i] - p[2*i - 1];\n\t\td0 = min(d0, Distance2ToQBSpline(p[2*i], p[2*i + 1], p[2*i + 2], fragCoord.xy));\n\t\td1 = min(d1, length2(p[2*i] - fragCoord.xy));\n\t}\n\td1 = min(d1, length2(p[segCount*2] - fragCoord.xy));\n\n\td0 = sqrt(d0);\n\td1 = sqrt(d1);\n\n\tfloat c = mix(.5, .8, clamp(d0-6., 0., 1.));\n\tfragColor = mix(vec4(c), vec4(0,1,0,1),1.- clamp(d1-5., 0., 1.));\n\t\n\tif(iMouse.z > 0.) {\n\t\td0 /= iResolution.x*.2;\n\t\td0 = 1.-d0;\n\t\tfragColor = vec4(d0); \n\t}\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MslXWr","date":"1399587243","viewed":441,"name":"Quadratic Bezier","username":"Trisomie21","description":"Distance to Quadratic Bezier (Click to view clamped distances)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["bezier","distance"],"hasliked":0,"parentid":"","parentname":""}}