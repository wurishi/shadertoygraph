{"ver":"0.1","info":{"id":"3lj3Rh","date":"1558540350","viewed":167,"name":"Pulsating ring tunnel","username":"Neebz","description":"Ring shader used in a school project of mine. Based off of a shader made by one of my group members, although altered in a lot of ways in order to create the current effect.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rings","pulsating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ringThickness .05\n#define numberOfRings 15.\n#define minimumSize 10.\n#define maximumSize 0.\n#define ringSpeed .1\n#define colorChangeSpeed 10.\n#define ringIntensity 1.5\n\nvec3 spaceCircles(vec2 uv){\n\t//Define a mask to contain all the rings\n\tvec3 mask = vec3(0);\n\n\t//Forloop for number of rings\n\tfor (float x = 0.; x < 1.; x += 1./numberOfRings){\n\t\t//Define time at offsets, defined by indexer\n\t\tfloat t = (iTime * ringSpeed + x);\n\t\t//Color time defined, as the time variable to change ring color, defined by indexer\n\t\tfloat colorT = (iTime * colorChangeSpeed + x);\n\n\t\t//Define size as a value, by linearly scaling between two values\n\t\t//using the fraction of the time variable as the input.\n\t\tfloat size = mix(minimumSize, maximumSize, fract(t));\n\t\t//Scaling the uv\n\t\tvec2 uvScaled = uv * size;\n\t\t//Define a fade, to fade in the rings at a certain depth.\n\t\tfloat fade = smoothstep(0.,.05, fract(t));\n\t\t//Change color over time\n\t\tvec3 col = 0.5 + 0.5 * cos(colorT + uvScaled.xyx *  + vec3(1, 2, 4));\n\t\t\n\t\t//Create ring, by calculating the multiplicative inverse distance between\n\t\t//the current uv coord and the center of the screen.\n\t\tfloat dis = 1. / distance(uvScaled, vec2(0., 0.));\n\t\t\n\t\t//Multiply number to create different colors on the ring\n\t\tdis *= 2.;\n\n\t\t//To make sure we only create 1 ring, we cut out all values outside of a certain range.\n\t\t//Multiple rings are otherwise created because of the sine / cosine. The 'dist' value gets quite large as it\n\t\t//gets closer to the center, since 1 dvivded by a small number creates a large number, which input into one of \n\t\t//these functions (sine or cosine), will return a greater frequency in the fluxuation.\n\t\tif (dis < 4.5 && dis > 2.){\n\t\t\t//Outer thickness of the rings\n\t\t\tcol *= ringThickness / (sin(dis));\n\t\t\t//Inner thickness of the rings\n\t\t\tcol = (col / sin(dis)) * ringThickness;\n\t\t\t//Adds the current ring to the mask, times the fade, to make sure it slowly fades in to the screen.\n\t\t\t//Multiplied is also an intensity value, used to make the intensity of the rings greater or smaller.\n\t\t\tmask += col * ringIntensity * fade;\n\t\t}\n\t}\n\n\treturn mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 mask = vec3(0);\n\tmask += spaceCircles(uv);\n    fragColor = vec4(mask, 1.);\n} ","name":"Image","description":"","type":"image"}]}