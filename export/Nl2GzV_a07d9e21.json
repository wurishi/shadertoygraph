{"ver":"0.1","info":{"id":"Nl2GzV","date":"1624291887","viewed":165,"name":"triangular linear interpolation","username":"yunhai","description":"~","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**Log\n*updated:\n*2021/9/4->arbitrary SSAA\n*/\n#define SS(a,b,t) smoothstep(a,b,t)\n#define SL(d) smoothstep(HLW,HLW-.005,d)\nconst float PI=3.14159265;\n//---------------------Lines-------------------\nconst float HLW=.05;//half line width\nfloat lineSeg(vec2 uv,vec2 start,vec2 end)\n{\n    vec2 sp=uv-start;\n    vec2 se=end-start;\n    vec2 closp=clamp(dot(sp,se)/dot(se,se),0.,1.)*se+start;\n    return SL(length(uv-closp));\n}\nfloat line(vec2 uv,vec2 ori,vec2 dir)\n{\n    vec2 sp=uv-ori;\n    vec2 closp=dot(sp,dir)*dir+ori;\n    return SL(length(uv-closp));\n}\n//----------------------------------------------\nvec3 cartesian(vec2 uv)\n{\n    vec3 col=vec3(0.);\n    float msp=2.;//mesh space interval\n    float lhlw=HLW/2.;//local HLW\n    vec3 mesh=vec3(SS(lhlw,lhlw-.005,abs(uv.x-round(uv.x/msp)*msp)));\n    mesh+=vec3(SS(lhlw,lhlw-.005,abs(uv.y-round(uv.y/msp)*msp)));\n    col+=mesh*.5;\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(1.,0.)));\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(0.,1.)));\n    return col;\n}\n//-------------------extra-----------------\nvec3 palette(float t)//Color Palette\n{\n    t*=1.732;\n    return vec3(.5)+vec3(.5)*cos(2.*PI*(vec3(.71,.31,.21)*t+vec3(.2,.4,.6)));\n}\nvec3 triLinearInterpolate2D(vec2 p,vec2 a,vec2 b,vec2 c)\n{\n    //alpha*A+beta*B+gamma*C=P\n    //alpha+beta+gamma=1\n    mat3 m=mat3(a,1.,\n                b,1.,\n                c,1. );       \n    return inverse(m)*vec3(p.x,p.y,1);\n}\nvec3 barycentricCoordInterpolate2D(vec2 p,vec2 a,vec2 b,vec2 c)\n{\n    vec3 p3=vec3(p,0),a3=vec3(a,0),b3=vec3(b,0),c3=vec3(c,0),    \n         ab=b3-a3,ap=p3-a3,ac=c3-a3;\n    vec3 n=cross(ab,ac);\n    float s=length(n);n/=s;\n    float v=dot(n,cross(ap,ac))/s,\n          w=dot(n,cross(ab,ap))/s,\n          u=1.-v-w;\n    return vec3(u,v,w);\n}\nfloat min3(vec3 v){return min(v.x,min(v.y,v.z));}\nvec4 render(vec2 C)\n{\n    vec4 O=vec4(0);\n    vec2 uv= (C-.5*iResolution.xy)/iResolution.y;uv*=10.;\n    float x=uv.x,y=uv.y,t=iTime*.5;\n    O.rgb+=cartesian(uv)*palette((uv.x+uv.y)*.05+1.1);    \n    \n    vec2 a=vec2(0,3)+cos(t),\n        b=vec2(-2,-1)+sin(t*.7),\n        c=vec2(2,1)+cos(t*.65);\n    #define MIX(col,t) O.rgb=mix(O.rgb,col,t)\n    MIX(vec3(1),lineSeg(uv,a,b));\n    MIX(vec3(1),lineSeg(uv,b,c));\n    MIX(vec3(1),lineSeg(uv,c,a));\n    \n    vec3 factors= //triLinearInterpolate2D(uv,a,b,c);\n                 barycentricCoordInterpolate2D(uv,a,b,c);\n\n    if(min3(factors)>0.)\n        O.rgb=factors;\n    //barycentric\n    MIX(vec3(1.,.3,.1),SS(.08,.08-HLW,length(uv-(a+b+c)/3.)));\n    return O;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    C-=.5;\n    vec2 dx=vec2(.25,.75);\n    //SSAA\n    O=render(C+dx.xx)+\n      render(C+dx.yx)+\n      render(C+dx.xy)+\n      render(C+dx.yy);\n    O/=4.;\n}","name":"Image","description":"","type":"image"}]}