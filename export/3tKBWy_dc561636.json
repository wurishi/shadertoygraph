{"ver":"0.1","info":{"id":"3tKBWy","date":"1614976042","viewed":424,"name":"Fork Halftone W mix  fractal 2","username":"mrarm84","description":"I just bought a webcam so I made a simple halftone filter! Mouse controls brightness.","likes":4,"published":1,"flags":6,"usePreview":0,"tags":["halftone","webcam"],"hasliked":0,"parentid":"4sXGRn","parentname":"Deform - relief tunnel"},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// comment these out for different effects\n#define monochrome 1\n//#define nearestDot 1\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nconst float numberOfDots = 377.; // horizontally across screen\n\nvec3 PixelGrid ( vec2 p )\n{\n    float dotSize = iResolution.x/numberOfDots;\n    vec2 tileSize = vec2(.5,sqrt(3./4.)) * dotSize;\n    p /= tileSize;\n    p = fract(p/2.)*2.-1.;\n    vec2 s = sign(p);\n    p = abs(p);\n    p *= tileSize;\n\n    // this is not the best way to do this, but I am lazy (could just mirror it)\n    if ( length(p) > length(p-tileSize) )\n        p = p-tileSize;\n    \n    float value = dot(p,p)*4./dot(tileSize,tileSize); // based on area\n    \n    return vec3( p*s, clamp(1.-value,0.,1.) );\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\n  \n   // create pixel coordinates\n // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel1, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel1, ivec2(tx,1), 0 ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( fft, 14.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    // add wave form on top\t\n\tcol += 1.0 -  step( 0.0,  abs(fft - uv.y) );\n\t\n\t// output final color\n\t//fragColor = vec4(col,1.0);\n\n\n        vec3 grid = PixelGrid(fragCoord);\n\n\n    #ifdef nearestDot\n        fragCoord.xy -= grid.xy;\n    #endif\n\n    fragColour = texture(iChannel0,fragCoord.xy/iResolution.xy);\n\n\n  //  fragColour=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((fragCoord-.5*r.xy)/r.y,1));  \n    for(float i=1.,g=0.,e,s,a;\n        ++i<99.;\n        a=cos(i*i/80.),fragColour.rgb+=mix(vec3(1),H(log(s)/5.),.5)*a*a/e/2e4\n    )\n    {\n        p=g*d-vec3(-.8,.2,2);\n        p=R(p,normalize(vec3(10,1,1)),iTime*.1);\n    s=3.;\n    for(int i=0;i++<5;p=abs(p)*e)\n        p=vec3(8,4,2)-abs(p-vec3(fft,4,2)),\n        s*=e=8./clamp(dot(p,p),.1,7.);\n        g+=e=min(length(p.xz),p.y)/s+.001;\n    }\n      \n    fragColour.rgb = pow( fragColour.rgb, vec3(2.2) ); // gamma->linear\n\n    #ifdef monochrome\n        fragColour.rgb = vec3( dot( fragColour.rgb, vec3(.2,.7,.1) ) );\n    #endif\n    \n    float brightness = fft;\n    if ( iMouse.y > 0. ) brightness = iMouse.y/iResolution.y;\n    if ( iMouse.y > 0. ) vec3 grid = PixelGrid(fragCoord);\n\n    fragColour.rgb = (fragColour.rgb-.0)*(1.+20.*brightness*col*10.0);\n\n    // aliased version\n//    float spots = step( .0, monochrome - grid.z );\n    \n    // anti-aliased version\n    vec3 f = fragColour.rgb-grid.z;\n    vec3 spots = smoothstep( -f, 2.-f, f/max(fwidth(fft),.01) );\n\n    fragColour.rgb = spots;\n\n    //if ( fragCoord.x < iMouse.x ) fragColour.rgb = vec3(monochrome);  // test the gamma and dot area maths is correct\n\n    fragColour.rgb = pow( fragColour.rgb, vec3(fft*10.2) ); // linear->gamma\n}\n","name":"Image","description":"","type":"image"}]}