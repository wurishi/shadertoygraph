{"ver":"0.1","info":{"id":"MtlfRl","date":"1513256099","viewed":960,"name":"Tunnel Squared","username":"shau","description":"a quick variation on my previous tunnel with only one pass and two colours :) Music \"The Tunnel\" by Richie Hawtin","likes":28,"published":1,"flags":64,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsjXR1","filepath":"https://soundcloud.com/anoukforza/richie-hawtin-the-tunnel-2005","previewfilepath":"https://soundcloud.com/anoukforza/richie-hawtin-the-tunnel-2005","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define EPS 0.002\n#define FAR 40.0 \n#define PI 3.14159265359\n#define T iTime\n#define NTILES 12.0\n\nvec3 ro = vec3(0.0);\nvec4 sphere = vec4(0.0, 0.0, 0.0, 0.3);\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nvec3 path(float t) {\n    float a = sin(t * PI / 16.0 + 1.5707963 * 1.0);\n    float b = cos(t * PI / 16.0);\n    return vec3(a * 2.0, b * a, t);    \n}\n\nfloat glyphcell(float uvz, float uva, vec2 cellid) {\n    vec2 cuv = vec2(uvz, uva) * 10.0 - 5.0;\n    vec2 cmx = mod(cuv, 1.0) - 0.5;\n    float lc = length(cmx);\n    float r1 = rand(floor(vec2(cuv.x + cellid.y, cuv.y + cellid.x + floor(T)))) > 0.7 ? 1.0 : 0.0;\n    float pc = smoothstep(0.4, 0.3, lc) * r1; \n    pc *= step(cuv.x, 2.0) * step(-2.0, cuv.x);\n    pc *= step(cuv.y, 0.0) * step(-4.0, cuv.y);\n    return pc;\n}\n\n//IQ - Sphere functions\n//https://iquilezles.org/articles/spherefunctions\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    h = sqrt(h);\n    return -b - h;\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\t\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b*b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec4 map(vec3 rp) {\n\n    rp.xy -= path(rp.z).xy;      \n\n    rp.xy *= rot(T * 0.5);\n    rp.z += T;\n    \n    vec3 q = rp;\n    \n    float a = atan(q.y, q.x) / 6.2831853;\n    float ia = floor(a * NTILES) / NTILES * 6.2831853;\n\n    vec2 cell = vec2(rp.z, a * NTILES);\n\n    //panels\n    q.xy *= rot(ia);\n    q.z = abs(mod(q.z, 1.0) - 0.5);\n    vec2 panels = vec2(max(length(q.xy) - 1.7, 1.65 - length(q.xy)), 1.0);\n    panels.x = max(panels.x, q.z - 0.25);    \n    panels.x = max(panels.x, q.y - 0.5);\n    \n    //rings\n    q = rp;\n    q.z = abs(mod(q.z + sin(T * 0.4) * 30.0, 80.0) - 40.0);\n    vec2 rings1 = vec2(max(length(q.xy) - 1.5, 1.45 - length(q.xy)), 2.0);\n    rings1.x = max(rings1.x, max(q.z - 0.3, 0.25 - q.z));\n\n    q = rp;\n    q.z = abs(mod(q.z + cos(T * 0.5) * 20.0, 60.0) - 30.0);\n    vec2 rings2 = vec2(max(length(q.xy) - 0.8, 0.75 - length(q.xy)), 2.0);\n    rings2.x = max(rings2.x, max(q.z - 0.3, 0.25 - q.z));\n\n    q = rp;\n    q.z = abs(mod(q.z + sin(T * 0.6) * 15.0, 40.0) - 20.0);\n    vec2 rings3 = vec2(max(length(q.xy) - 0.4, 0.35 - length(q.xy)), 2.0);\n    rings3.x = max(rings3.x, max(q.z - 0.3, 0.25 - q.z));\n\n    return vec4(nearest(panels, nearest(rings1, nearest(rings2, rings3))), cell);\n}\n\nstruct Scene {\n    float t;\n    float id;\n    float li;\n    vec2 cell;\n};\n\nScene march(vec3 ro, vec3 rd) {\n\n    float t = 0.0;\n    float li = 0.0;\n    float id = 0.0;\n    vec2 cell = vec2(0.0);\n    \n    for (int i = 0; i < 96; i++) {\n        vec3 rp = ro + rd * t;\n        vec4 scene = map(rp);\n        if (scene.x < EPS || scene.x > FAR) {\n            id = scene.y;\n            cell = scene.zw;\n            break;\n        }\n        \n        li += 0.005 / (1.0 + scene.x * scene.x * 20.5);\n        \n        t += scene.x;\n    }\n    \n    return Scene(t, id, li, cell);\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    float ct = T * 6.0;\n\n    vec3 lookAt = vec3(0.0, 0.0, ct);\n    ro = lookAt + vec3(0.0, 0.0, -5.0);\n    sphere.xyz = ro + vec3(0.0, 0.0, sin((T + 80.0) * 0.16) * 80.0);\n    \n    lookAt.xy += path(lookAt.z).xy;\n    ro.xy += path(ro.z).xy;\n    sphere.xy += path(sphere.z).xy;\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n\n    vec3 rd;\n    setupCamera(fragCoord, rd);\n\n    vec3 c1 = vec3(0.0, 1.0, 0.0);\n    vec3 c2 = vec3(0.5, 1.0, 0.0);\n    \n    if (sphere.z < ro.z) {\n        c1 = vec3(1.0, 0.0, 0.0);\n        c2 = vec3(1.0, 0.5, 0.0);\n    }\n    \n    Scene scene = march(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) { \n                \n        if (scene.id == 1.0) {\n            vec2 cellid = floor(scene.cell);\n            vec2 celluv = fract(scene.cell);\n\n            float r = rand(cellid);\n\n            if (r > 0.4 && r < 0.8) {\n                pc = c2 * glyphcell(celluv.x, celluv.y, cellid);\n                pc /= scene.t * 0.25;\n            }\n        } else if (scene.id == 2.0 || scene.id == 3.0) {\n            pc = c2;\n        }\n        \n        mint = scene.t;\n    }\n    \n    pc += c1 * scene.li;\n    \n    float st = sphIntersect(ro, rd, sphere);\n    if (st > 0.0 && st < mint) {\n        \n        float h = sphDensity(ro, rd, sphere, mint);\n        if (h > 0.0) {\n            pc = mix(pc, vec3(1.0, 0.0, 0.0), h);\n            pc = mix(pc, 0.85 * vec3(1.0, 0.7, 0.0), h * h * h);   \n        }\n    }\n    \n    fragColor = vec4(sqrt(clamp(pc, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}