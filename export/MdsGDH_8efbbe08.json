{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Original DE from Knighty's Fragmentarium frag.\n// PostFX from jmpep.\n// Whatever is left (not much) by Syntopia.\n\n#define MaxSteps 30\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define PI 3.141592\n#define Scale 3.0\n#define FieldOfView 0.5\n#define Jitter 0.06\n#define FudgeFactor 1.0\n\n#define Ambient 0.32184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(0.6,1.0,0.158824)\n#define LightDir2 vec3(1.0,-1.0,1.0)\n#define LightColor2 vec3(1.0,0.933333,1.0)\n#define Offset vec3(0.92858,0.92858,0.32858)\n\n// Return rotation matrix for rotating around vector v by angle\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n#define Type 5\nfloat U;\nfloat V ;\nfloat W ;\nfloat T =  1.0;\n\nfloat VRadius = 0.05048;\nfloat SRadius = 0.05476;\nvec3 RotVector = vec3(0.0,1.0,1.0);\nfloat RotAngle = 0.0;\n\n\nmat3 rot;\nvec4 nc,nd,p;\nvoid init() {\n     U = 0.0*cos(iTime)*0.5+0.1;\n    V =  0.2*sin(iTime*0.1)*0.5+0.2;\n     W =  1.0*cos(iTime*1.2)*0.5+0.5;\n\n\tif (iMouse.z>0.0) {\n\t\tU = iMouse.x/iResolution.x;\n\t\tW = 1.0-U;\n\t\tV = iMouse.y/iResolution.y;\n\t\tT = 1.0-V;\n\t}\n\tfloat cospin=cos(PI/float(Type)), isinpin=1./sin(PI/float(Type));\n\tfloat scospin=sqrt(2./3.-cospin*cospin), issinpin=1./sqrt(3.-4.*cospin*cospin);\n\n\tnc=0.5*vec4(0,-1,sqrt(3.),0.);\n\tnd=vec4(-cospin,-0.5,-0.5/sqrt(3.),scospin);\n\n\tvec4 pabc,pbdc,pcda,pdba;\n\tpabc=vec4(0.,0.,0.,1.);\n\tpbdc=0.5*sqrt(3.)*vec4(scospin,0.,0.,cospin);\n\tpcda=isinpin*vec4(0.,0.5*sqrt(3.)*scospin,0.5*scospin,1./sqrt(3.));\n\tpdba=issinpin*vec4(0.,0.,2.*scospin,1./sqrt(3.));\n\t\n\tp=normalize(U*pabc+V*pbdc+W*pcda+T*pdba);\n\n\trot = rotationMatrix3(normalize(RotVector), RotAngle);//in reality we need a 4D rotation\n}\n\nvec4 fold(vec4 pos) {\n\tfor(int i=0;i<Type*(Type-2);i++){\n\t\tpos.xy=abs(pos.xy);\n\t\tfloat t=-2.*min(0.,dot(pos,nc)); pos+=t*nc;\n\t\tt=-2.*min(0.,dot(pos,nd)); pos+=t*nd;\n\t}\n\treturn pos;\n}\n\nfloat DD(float ca, float sa, float r){\n\t//magic formula to convert from spherical distance to planar distance.\n\t//involves transforming from 3-plane to 3-sphere, getting the distance\n\t//on the sphere then going back to the 3-plane.\n\treturn r-(2.*r*ca-(1.-r*r)*sa)/((1.-r*r)*ca+2.*r*sa+1.+r*r);\n}\n\nfloat dist2Vertex(vec4 z, float r){\n\tfloat ca=dot(z,p), sa=0.5*length(p-z)*length(p+z);//sqrt(1.-ca*ca);//\n\treturn DD(ca,sa,r)-VRadius;\n}\n\nfloat dist2Segment(vec4 z, vec4 n, float r){\n\t//pmin is the orthogonal projection of z onto the plane defined by p and n\n\t//then pmin is projected onto the unit sphere\n\tfloat zn=dot(z,n),zp=dot(z,p),np=dot(n,p);\n\tfloat alpha=zp-zn*np, beta=zn-zp*np;\n\tvec4 pmin=normalize(alpha*p+min(0.,beta)*n);\n\t//ca and sa are the cosine and sine of the angle between z and pmin. This is the spherical distance.\n\tfloat ca=dot(z,pmin), sa=0.5*length(pmin-z)*length(pmin+z);//sqrt(1.-ca*ca);//\n\treturn DD(ca,sa,r)-SRadius;\n}\n//it is possible to compute the distance to a face just as for segments: pmin will be the orthogonal projection\n// of z onto the 3-plane defined by p and two n's (na and nb, na and nc, na and and, nb and nd... and so on).\n//that involves solving a system of 3 linear equations.\n//it's not implemented here because it is better with transparency\n\nfloat dist2Segments(vec4 z, float r){\n\tfloat da=dist2Segment(z, vec4(1.,0.,0.,0.), r);\n\tfloat db=dist2Segment(z, vec4(0.,1.,0.,0.), r);\n\tfloat dc=dist2Segment(z, nc, r);\n\tfloat dd=dist2Segment(z, nd, r);\n\t\n\treturn min(min(da,db),min(dc,dd));\n}\n\nfloat DE(vec3 pos) {\n\tfloat r=length(pos);\n\tvec4 z4=vec4(2.*pos,1.-r*r)*1./(1.+r*r);//Inverse stereographic projection of pos: z4 lies onto the unit 3-sphere centered at 0.\n\tz4.xyw=rot*z4.xyw;\n\tz4=fold(z4);//fold it\n\n\treturn min(dist2Vertex(z4,r),dist2Segments(z4, r));\n}\n\nvec3 lightDir;\nvec3 lightDir2;\n\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0,1.0,1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i <= MaxSteps; i++) {\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) ;\n\t\tfloat ao = 1.0-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\tvec3 bg = vec3(0.2);\n\tif (steps == MaxSteps) {\n\t\treturn vec4(bg,1.0);\n\t}\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\t\n\tcolor = mix(color*Ambient+light,bg,1.0-ao);\n\treturn vec4(color,1.0);\n}\n\n#define BLACK_AND_WHITE\n#define LINES_AND_FLICKER\n#define BLOTCHES\n#define GRAIN\n\n#define FREQUENCY 10.0\n\nvec2 uv;\nfloat rand(float c){\n\treturn rand(vec2(c,1.0));\n}\n\nfloat randomLine(float seed)\n{\n\tfloat b = 0.01 * rand(seed);\n\tfloat a = rand(seed+1.0);\n\tfloat c = rand(seed+2.0) - 0.5;\n\tfloat mu = rand(seed+3.0);\n\t\n\tfloat l = 1.0;\n\t\n\tif ( mu > 0.2)\n\t\tl = pow(  abs(a * uv.x + b * uv.y + c ), 1.0/8.0 );\n\telse\n\t\tl = 2.0 - pow( abs(a * uv.x + b * uv.y + c), 1.0/8.0 );\t\t\t\t\n\t\n\treturn mix(0.5, 1.0, l);\n}\n\n// Generate some blotches.\nfloat randomBlotch(float seed)\n{\n\tfloat x = rand(seed);\n\tfloat y = rand(seed+1.0);\n\tfloat s = 0.01 * rand(seed+2.0);\n\t\n\tvec2 p = vec2(x,y) - uv;\n\tp.x *= iResolution.x / iResolution.y;\n\tfloat a = atan(p.y,p.x);\n\tfloat v = 1.0;\n\tfloat ss = s*s * (sin(6.2831*a*x)*0.1 + 1.0);\n\t\n\tif ( dot(p,p) < ss ) v = 0.2;\n\telse\n\t\tv = pow(dot(p,p) - ss, 1.0/16.0);\n\t\n\treturn mix(0.3 + 0.2 * (1.0 - (s / 0.02)), 1.0, v);\n}\n\n\n\nvec3 degrade(vec3 image)\n{\n\t\t// Set frequency of global effect to 20 variations per second\n\t\tfloat t = float(int(iTime * FREQUENCY));\n\t\t\n\t\t// Get some image movement\n\t\tvec2 suv = uv + 0.002 * vec2( rand(t), rand(t + 23.0));\n\t\t\n\t\t#ifdef BLACK_AND_WHITE\n\t\t// Pass it to B/W\n\t\tfloat luma = dot( vec3(0.2126, 0.7152, 0.0722), image );\n\t\tvec3 oldImage = luma * vec3(0.7, 0.7, 0.7);\n\t\t#else\n\t\tvec3 oldImage = image;\n\t\t#endif\n\t\t// Create a time-varyting vignetting effect\n\t\tfloat vI = 16.0 * (uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y));\n\t\tvI *= mix( 0.7, 1.0, rand(t + 0.5));\n\t\t\n\t\t// Add additive flicker\n\t\tvI += 1.0 + 0.4 * rand(t+8.);\n\t\t\n\t\t// Add a fixed vignetting (independent of the flicker)\n\t\tvI *= pow(16.0 * uv.x * (1.0-uv.x) * uv.y * (1.0-uv.y), 0.4);\n\t\t\n\t\t// Add some random lines (and some multiplicative flicker. Oh well.)\n\t\t#ifdef LINES_AND_FLICKER\n\t\tint l = int(8.0 * rand(t+7.0));\n\t\t\n\t\tif ( 0 < l ) vI *= randomLine( t+6.0+17.* float(0));\n\t\tif ( 1 < l ) vI *= randomLine( t+6.0+17.* float(1));\n\t\tif ( 2 < l ) vI *= randomLine( t+6.0+17.* float(2));\t\t\n\t\tif ( 3 < l ) vI *= randomLine( t+6.0+17.* float(3));\n\t\tif ( 4 < l ) vI *= randomLine( t+6.0+17.* float(4));\n\t\tif ( 5 < l ) vI *= randomLine( t+6.0+17.* float(5));\n\t\tif ( 6 < l ) vI *= randomLine( t+6.0+17.* float(6));\n\t\tif ( 7 < l ) vI *= randomLine( t+6.0+17.* float(7));\n\t\t\n\t\t#endif\n\t\t\n\t\t// Add some random blotches.\n\t\t#ifdef BLOTCHES\n\t\tint s = int( max(8.0 * rand(t+18.0) -2.0, 0.0 ));\n\n\t\tif ( 0 < s ) vI *= randomBlotch( t+6.0+19.* float(0));\n\t\tif ( 1 < s ) vI *= randomBlotch( t+6.0+19.* float(1));\n\t\tif ( 2 < s ) vI *= randomBlotch( t+6.0+19.* float(2));\n\t\tif ( 3 < s ) vI *= randomBlotch( t+6.0+19.* float(3));\n\t\tif ( 4 < s ) vI *= randomBlotch( t+6.0+19.* float(4));\n\t\tif ( 5 < s ) vI *= randomBlotch( t+6.0+19.* float(5));\n\t\n\t\t#endif\n\t\n\t\tvec3 outv = oldImage * vI;\n\t\t\n\t\t// Add some grain (thanks, Jose!)\n\t\t#ifdef GRAIN\n        outv *= (1.0+(rand(uv+t*.01)-.2)*.15);\t\t\n        #endif\n\t\treturn outv;\t\n}\t\t\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy / iResolution.xy;\n\t\n\tinit();\n\t\n\t// Camera position //(eye), and camera target\n\tvec3 camPos = (12.0+2.0*sin(iTime*0.6))*vec3(cos(iTime*0.3),0.0,sin(iTime*0.3));\n\tvec3 target = vec3(0.0,0.0,0.0);\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tlightDir= -normalize(camPos+7.5*camUp);\n\tlightDir2=-normalize( camPos- 6.5*camRight);\n\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tfloat vignette = 0.4+(1.0-coord.x*coord.x)\n\t\t*(1.0-coord.y*coord.y);\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tvec3 col = rayMarch(camPos, rayDir, fragCoord).xyz;   \n\n    // vignetting \n    // col *= clamp(vignette,0.0,1.0);\n\tcol = degrade(col);\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdsGDH","date":"1369436431","viewed":1630,"name":"Polychora (4D)","username":"Syntopia","description":"This is a depiction of 4D Polychora, stereographically projected to 3D dimensions. \n*All the math (and original Fragmentaruim code) was created by the always brilliant Knighty.*\n*The postfx stuff was shamelessly ripped from jmpep's 'Old Video' shadertoy*\n","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["4d","polychora","knighty"],"hasliked":0,"parentid":"","parentname":""}}