{"ver":"0.1","info":{"id":"DslXD8","date":"1668864458","viewed":268,"name":"Woven Pipes Tiling","username":"fizzer","description":"In a similar way to my [url=https://www.shadertoy.com/view/3dVSRm]older[/url] shader, this pattern is produced by picking pairs of points on the edge of the square tile and linking them with line segments. Neighbouring tiles share 2 points on their edge.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","tiling","weave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Line segment\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a, b - a), 0., 1.)));\n}\n\n// Two-segment 90-degree angle pipe\nfloat Rline(vec2 p, vec2 a, vec2 b)\n{\n    if(abs(a.y - .5) > abs(a.x - .5))\n    {\n        vec2 nx = vec2(clamp(p.x, min(a.x, b.x), max(a.x, b.x)), b.y);\n        vec2 ny = vec2(a.x, clamp(p.y, min(a.y, b.y), max(a.y, b.y)));\n        return min(distance(p,ny), distance(p, nx));\n    }\n    else\n    {\n        vec2 nx = vec2(clamp(p.x, min(a.x, b.x), max(a.x, b.x)), a.y);\n        vec2 ny = vec2(b.x, clamp(p.y, min(a.y, b.y), max(a.y, b.y)));\n        return min(distance(p,ny), distance(p, nx));\n    }\n}\n\n// Three-segment S-shaped pipe\nfloat Sline(vec2 p, vec2 a, vec2 b, float t)\n{\n    vec2 mid = mix(a, b, t);\n    if(abs(b.x - a.x) > abs(b.y - a.y))\n    {\n        vec2 c = vec2(mid.x, a.y), d = vec2(mid.x, b.y);\n        return min(min(line(p, a, c), line(p, d, b)), line(p, c, d));\n    }\n    else\n    {\n        vec2 c = vec2(a.x, mid.y), d = vec2(b.x, mid.y);\n        return min(min(line(p, a, c), line(p, d, b)), line(p, c, vec2(b.x, mid.y)));\n    }\n}\n\n// Three-segment U-shaped pipe\nfloat Uline(vec2 p, vec2 a, vec2 b)\n{\n    float m = .2;\n    if(abs(b.x - a.x) > abs(b.y - a.y))\n    {\n        vec2 c = vec2(a.x, a.y + sign(b.y - .5) * m), d = vec2(b.x, a.y + sign(b.y - .5) * m);\n        return min(min(line(p, a, c), line(p, c, d)), line(p, d, b));\n    }\n    else\n    {\n        vec2 c = vec2(a.x + sign(b.x - .5) * m, a.y), d = vec2(a.x + sign(b.x - .5) * m, b.y);\n        return min(min(line(p, a, c), line(p, c, d)), line(p, d, b));\n    }\n}\n\nfloat rand(vec2 p)\n{\n    p = floor(vec2(p.x + p.y, p.x - p.y));\n    float x = texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n    return mix(.25, .75, floor(x * 4.) / 4.);\n}\n\n// Based on https://www.shadertoy.com/view/llGSzw\nuint hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nvec3 draw(vec3 b, float d, float f)\n{\n    d /= 1.6;\n    f /= 1.6 * 2.0;\n\n    // A simple colour ramp for the pipes\n    vec3 c0 = mix(vec3(1), vec3(.6, .1, .05), .5 + .5 * smoothstep(0.004, 0.009, d + .001)) +\n            vec3(.6, .2, .05) * smoothstep(0.0, 0.02, abs(d - 0.03))+\n            vec3(1, .5, .5) * (1. - smoothstep(0.0, 0.02, d)) * .1;\n    \n    // Shadowed background\n    vec3 c1 = b * smoothstep(0.02, .15, d);\n\n    c0 = mix(c0, vec3(dot(c0, vec3(1. / 3.))), .2);\n\n    float n0 = 0.05;\n\n    return mix(c0, c1, smoothstep(n0 - f, n0 + f, d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv = uv.xy * 6. - iMouse.xy / iResolution.xy * 15. + 80.;\n\n    // Background pattern\n    vec3 col = mix(vec3(.25), vec3(.05, .1, .2)/2. +\n                vec3(.05) * step(.8, fract((uv.x + uv.y) * 10.1)), .55);\n                \n    float m = .1;\n    vec2 p = fract(uv);\n    vec2 q = floor(uv);\n    \n    // Eight points around the perimeter of the current square cell\n    vec2 c[8] = vec2[8](vec2(mix(m, .5, rand(q + vec2(.5, 0))), 0.),\n                        vec2(mix(.5, 1. - m, rand(q + vec2(.5, 0))), 0.),\n                        vec2(1., mix(m, .5,rand(q + vec2(1., .5)))),\n                        vec2(1., mix(.5, 1. - m, rand(q + vec2(1., .5)))),\n                        vec2(mix(m, .5, rand(q + vec2(.5, 1))), 1.),\n                        vec2(mix(.5, 1. - m, rand(q + vec2(.5, 1))), 1.),\n                        vec2(0., mix(m,.5, rand(q + vec2(0, .5)))),\n                        vec2(0., mix(.5, 1. - m, rand(q + vec2(0, .5)))));\n\n    // Shuffle the indices by using the Fisher-Yates algorithm\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\n    uint inds[8];\n    \n\tinds[0] = 0U;\n\n    uint seed = uint(q.x + q.y * 8192.)*319U;\n    for(uint j = 1U; j < 8U; ++j)\n    {\n        seed = hash1(seed);\n        uint k = seed % j;\n        uint temp = inds[k];\n        inds[k] = j;\n        inds[j] = temp;\n    }\n    \n    // Try to avoid creating small rings or terminations\n    for(uint j = 0U; j < 8U; j += 2U)\n    {\n        if(inds[j] / 2U == inds[j + 1U] / 2U)\n        {\n            uint temp = inds[(j + 3U) % 8U];\n            inds[(j + 3U) % 8U] = inds[j];\n            inds[j] = temp;\n        }\n    }\n    \n    float f = max(length(dFdx(uv)), length(dFdy(uv)));\n    \n    // Draw pipes connecting pairs of points on the cell perimeter\n    for(uint j = 0U; j < 8U; j += 2U)\n    {\n        uint ia = inds[j];\n        uint ib = inds[j + 1U];\n        \n        if(ia / 2U == ib / 2U)\n        {\n            // The points are on the same side of the cell\n            col.rgb = draw(col.rgb, Uline(p, c[ia], c[ib]), f);\n        }\n        else if(abs(float(ia / 2U) - float(ib / 2U)) == 2.)\n        {\n            // The points are on opposite sides of the cell\n            float t = floor(texelFetch(iChannel0, ivec2(p + 30.) & 255, 0).r * 11.) / 11.;\n            col.rgb = draw(col.rgb, Sline(p, c[ia], c[ib], mix(.1, .9, t)), f);\n        }\n        else\n        {\n            // The points are on perpendicular sides of the cell\n            col.rgb = draw(col.rgb, Rline(p, c[ia], c[ib]), f);\n        }\n    }\n\n    fragColor = vec4(pow(max(col, 0.), vec3(1. / 2.2)), 1.);\n}","name":"Image","description":"","type":"image"}]}