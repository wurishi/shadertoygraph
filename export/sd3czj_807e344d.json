{"ver":"0.1","info":{"id":"sd3czj","date":"1653723656","viewed":60,"name":"lightball","username":"vivavolt","description":"fancy lightball that likes music","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tFiery Spikeball\n\t---------------\n\n\tMaking some modifications to Duke's \"Cloudy Spikeball\" port to produce a fiery version.\n\n\tI trimmed the original shader down a bit, changed the weighting slightly, made a couple of \n\tsacrifices to the spike shape to tighten up the distance equation, etc.\n\n\n\tCloudy Spikeball - Duke\n\thttps://www.shadertoy.com/view/MljXDw\n\n    // Port from http://glslsandbox.com/e#1802.0, with some modifications.\n    //--------------\n    // Posted by Las\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\t// By the way, the demo is really good. Definitely worth watching.\n\n\n*/\n\n\nmat2 rM; // Rotation matrix.\n\n\n// IQ's noise\nfloat pn(in vec3 p){\n\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0 - 2.0*p);\n    vec2 uv = (ip.xy + vec2(37.0, 17.0)*ip.z) + p.xy;\n    uv = texture(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix(uv.x, uv.y, p.z);\n}\n\n// FBM\nfloat fpn(vec3 p){\n    return pn(p*.06125)*.57 + pn(p*.125)*.28 + pn(p*.25)*.15;\n}\n\n//Distance Functions\nfloat sd_sph(vec3 p, float r) { return length(p) - r; }\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\n//Distance Map\nfloat map(vec3 p)\n{\n    vec2 u = p.xy*0.1+ iTime / 10.;\n    vec2 um = u*2.;\n    um.x += sin(iTime)*0.05;\n    um.y += -cos(iTime)*0.025;\n    float h   = texture(iChannel0, um).x;\t\t//Non twisted height\n    um.x += (um.y)*2.0;\n    \n    float hlg = texture(iChannel0, um).x + .1*texture(iChannel1, um/5.).x;\t\t//Large details\n    float hfn = texture(iChannel0, u).x;\t\t//Fine details\n   \n    float disp = hlg*0.4 + hfn*0.1*(1.0-hlg);\t//Accumulative displacement\n    \n    return disp * sd_sph(p, 1.5*pow(texture(iChannel1, log(um / 4.)).x, 1.));\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(3.4+1.*i*i+.5*sin(1.1*iTime), 2.+3.*i*i+sin(2.3*iTime), 8.6+2.*i*i*i+sin(2.114*iTime)); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0 - exp(-1e7/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  \n   // p: position on the ray\n   // rd: direction of the ray\n   //\n   // Trimmed \"rd\" down. Plus, moved \"ro\" back 6 units to get rid of the \"p.z += 6\" line\n   // in the distance equation. Also, reversed the Z-coordinates, because it's a personal preference.\n   vec3 rd = normalize(vec3((fragCoord.xy - 0.5*iResolution.xy)/iResolution.y, 1.));\n   vec3 ro = vec3(0., 0., -8.);\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld = 0., td = 0., w;\n\n   // t: length of the ray\n   // d: distance function\n   float d = 1., t = 0.;\n   \n   // Distance threshold.\n   const float h = .1;\n    \n   // total color\n   vec3 tc = vec3(0.);\n    \n    \n   // Setting up the matrix outside of the loop, which might save a few cycles.\n   float cs = cos(iTime), si = sin(iTime);\n   rM = mat2(cs, si, -si, cs);\n    //p.xy=c*p.xy+s*vec2(p.y, -p.x); // Rotate p.xy\n    //p.xz=c*p.xz+s*vec2(p.z, -p.x); // Rotate p.xz\n    \n   // Tidied the raymarcher up a bit. Plus, got rid some redundancies... I think.\n\n   // rm loop\n   for (int i=0; i<64; i++) {\n\n      // Loop break conditions. Seems to work, but let me know if I've \n      // overlooked something. The middle break isn't really used here, but\n      // it can help in certain situations.\n      if(td>(1. - 1./200.) || d<0.001*t || t>12.)break;\n       \n      // evaluate distance function\n      // Took away the \"0.5\" factor, and put it below. \n      d = map(ro + t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      //const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./50.;  // Different weight distribution.\n      td += w + 1./200.;\n\n      \n      // enforce minimum stepsize\n      d = max(d, 0.04); // Increased the minimum, just a little.\n      \n      // step forward\n      t += d*0.5;\n      \n   }\n\n   // Fire palette.\n   tc = firePalette(tc.x);\n    \n   // No gamma correction. It was a style choice, but usually, you should have it.   \n   fragColor = vec4(tc, 1.0); //vec4(tc.x+td*2., ld*3., 0, tc.x);\n}","name":"Image","description":"","type":"image"}]}