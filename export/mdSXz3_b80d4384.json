{"ver":"0.1","info":{"id":"mdSXz3","date":"1670674728","viewed":122,"name":"Fork of  Envy24's Harmonogra","username":"blurryroots","description":"Changed the curve function to a supershape https://en.wikipedia.org/wiki/Superformula","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","graph","plot","superformula","harmonograph","parametric","supershape"],"hasliked":0,"parentid":"dsBXR3","parentname":"Harmonograph __"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROTATE\n#define ROTATE_SPEED (0.005*sin (1.*iTime))\n#define ITERATIONS 128\n#define BASE_LINE_SIZE 32.*UNIT\n\nfloat vertical_line(vec2 NDC, float x0) {\n    float d = abs(NDC.x - x0);\n    return SMAA(BASE_LINE_SIZE * d);\n}\nfloat horizontal_line(vec2 NDC, float y0) {\n    float d = abs(NDC.y - y0);\n    return SMAA(BASE_LINE_SIZE * d);\n}\nfloat y_axis(vec2 NDC) {\n    return vertical_line(NDC, 0.);\n}\nfloat x_axis(vec2 NDC) {\n    return horizontal_line(NDC, 0.);\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) {\n    return length(C - NDC) - R; \n}\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\n// Source: https://www.shadertoy.com/view/ftyGDm\nfloat pendulum(float t, vec4 param) {\n    // https://en.wikipedia.org/wiki/Harmonograph\n    // vec4 -> (amplitude, frequency, phase, damping)  \n    return (param.x) * sin(t * param.y + param.z) * exp(-t * param.w);\n}\n\n// Based on https://www.shadertoy.com/view/Mdy3DV\nfloat superformula (float angle, vec4 shape, vec2 symmetry) {    \n    float m = shape.x;\n    float n1 = shape.y;\n    float n2 = shape.z;\n    float n3 = shape.w;\n    float a = symmetry.x;\n    float b = symmetry.y;\n\n    float rpart = (m * angle) / 4.;\n    float apart = abs (cos (rpart) / a);\n    float bpart = abs (sin (rpart) / b);\n\n    float r = pow (\n        pow (apart, n2) + pow (bpart, n3),\n        -1. / n1\n    );\n    \n    return r;\n}\n\nfloat animate_m (float t, vec2 mr, float interval, float alloc, float blend) {\n    float interval_m0 = interval * clamp (alloc, 0., 1.);\n    float tm = mod (iTime, interval);\n    // smoothly blend between to m values.\n    float m = \n        interval_m0 < tm\n        ? ((interval - blend) < tm // when within blend range of interval\n            ? mr.y - mr.x * ((tm - (interval - blend))/blend)\n            : mr.y\n          )\n        : ((interval_m0 - blend) < tm // when within blend range of alloc\n            ? mr.x + (mr.y-mr.x) * ((tm - (interval_m0 - blend))/blend)\n            : mr.x\n          )\n        ;\n    \n    return m;\n}\n\nconst float ANIM_BLEND = 0.23;\nconst float ANIM_INTERVAL = 13.;\nconst float ANIM_INTERVALSPLIT = PHI0;\n\nfloat calc_angle (float t) {\n    vec2 mr = vec2 (PI/6., -PI/2.);\n    float m = animate_m (iTime, mr\n        , ANIM_INTERVAL, ANIM_INTERVALSPLIT, ANIM_BLEND\n    );\n    \n    float rotation = \n    #ifdef ROTATE\n        ROTATE_SPEED * iTime\n    #else\n        0.\n    #endif\n        ;\n    \n    float angle = t + m + rotation;\n    return angle;\n}\n\nvec2 func(float t) {\n    vec2 mr = vec2 (6., 10.);\n    float blend = 0.23;\n    float interval = 13.;\n    float intervalsplit = PHI0;\n    float m = animate_m (iTime, mr\n        , ANIM_INTERVAL, ANIM_INTERVALSPLIT, ANIM_BLEND\n    );\n    m = floor (m); // allow only discrete shape orders.\n    vec4 shape = vec4 (\n        m,\n        0.1 + 0.9*psin (iTime / 2.),\n        0.0, // + 0.9*psin (iTime / 1.5),\n        PHI + PHI * PHI * psin (iTime / PHI0)\n    );\n\n    vec2 sym = vec2 (1.);\n    float angle = calc_angle (t);\n    float s = superformula (angle, shape, sym);\n    return s * vec2 (cos (t), sin (t));\n}\n\nfloat linear_remap(\n    float val,\n    vec2 from,\n    vec2 to)\n{\n    // inverse linear map from [from.x; from.y] to [0; 1].\n    val = (val - from.x) / (from.y - from.x);\n    // linear map from [0; 1] to [to.x; to.r].\n    return val * (to.y - to.x) + to.x;        \n}\n\n// https://www.shadertoy.com/view/NtVfWG\nfloat parametric_sdf(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count,\n    in float thickness)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = func(linear_remap(from.x + dt * count, from, to));\n      \n    for (float i = 0.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from, to);\n        // float t = iTime;\n        vec2 E = func(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, thickness));\n        B = E;\n    }\n    \n    return minimal_distance - thickness;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_LOC(loc) (loc.xy * vec2 (1., 1.))\n#define MOUSE_OFFSET ( iMouse.z > 0. ? MOUSE_LOC(iMouse) - MOUSE_LOC(R) * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse) {\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / DA) * scale - origin;\n}\n\nvoid mainImage (out vec4 O, in vec2 SC) {\n    vec2 NDC = map_to_centered_ndc(SC, AR*SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(PHI0i / 2.); // background color\n         color += x_axis(NDC); color += y_axis(NDC);         \n         \n\n    /* Parametric function (x,y)=f(t) */\n    vec2 from = vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE),\n         to = vec2(0, 2.*PI);\n    vec3 line_color = 1.*PHI*vec3(PHI0,0,PHI0);\n    float d_curve = SMAA(parametric_sdf(NDC, from, to, float (ITERATIONS), 8.0*UNIT));\n    d_curve = pow (d_curve, 0.2);\n    color = mix (color, line_color, d_curve);      \n         \n  \n  \n    /* Moving point */\n    float t = mod(iTime * PHI, to.y);\n    vec2 P = func(t);\n    vec3 color_dot = vec3(0., PHI0, 0.);\n    float d_dot = SMAA(diskSDF_L2(NDC, P, 32.*UNIT));\n    color = mix(color, color_dot, d_dot);\n\n\n\n    /* Cells */\n    NDC = fract(NDC); \n    color += vertical_line(NDC, 0.)*.2;  color += horizontal_line(NDC, 0.)*.2;\n    #if 0\n    color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2; \n    color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    #endif        \n    /* */ \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float PHI = (1. + sqrt (5.)) / 2.;\nconst float PHI0 = PHI - 1.;\nconst float PHI0i = 1. - PHI0;\n#define R                           iResolution\n#define AR                        ( R.x / R.y  )\n#define DA                        ( max(R.x, R.y) )\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 2.0 )\n#define UNIT                      ( 1.*SCENE_SCALE / DA  )\n#define SMAA(x)                   ( smoothstep(UNIT/2., -UNIT/2., x) )\n#define PI                          3.1415926535897932\n#define HALF_PI                     1.5707963267948966\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T) {\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat psin (float t) {\n    return (1. + sin (t)) / 2.0;\n}","name":"Common","description":"","type":"common"}]}