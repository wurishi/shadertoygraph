{"ver":"0.1","info":{"id":"7t2cRd","date":"1650144817","viewed":458,"name":"Spring On Shadertoy","username":"sylvain69780","description":"The flowers are blooming on Shadertoy !","likes":52,"published":1,"flags":0,"usePreview":0,"tags":["icosahedron","symmetry","spring","flowers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI    = 3.14159265359;\nconst float TWOPI = 6.28318530717;\nconst float C = cos(PI/5.), S=sqrt(0.75-C*C);\nconst vec3 P35 = vec3(-0.5, -C, S); // normalized plan normal\n// boundaries of coordinate domains\nconst vec3 ICOMIDEDGE = vec3(0,0,1);\nconst vec3 ICOVERTEX = normalize(vec3(S,0.0,.5));  \nconst vec3 ICOMIDFACE = normalize(vec3(0.0,S,C)); \n// base change matrices to align with the corners of coordinate domains\n// transform domain corners to make it the y axis\nconst mat2 baseDode = mat2(ICOVERTEX.z,-ICOVERTEX.x,ICOVERTEX.xz);\nconst mat2 baseIco = mat2(ICOMIDFACE.z,-ICOMIDFACE.y,ICOMIDFACE.yz);\nconst int MAX_STEPS =100;\nconst float MAX_DIST  =100.;\nconst float SURF_DIST =.001;\n// #define AA\n#define T iTime\n// I think there are as many ways to achieve icosahedral symmetry as there are shadertoy users. \n// This one is based on the folding of the domain of the coordinates, \n// with always the problem of preserving the polarity, necessary for the animations like here.\n// https://en.wikipedia.org/wiki/Point_group\n// https://en.wikipedia.org/wiki/Polyhedral_group\n\nvec3 opIcosahedralSymmetryWithPolarity( vec3 p, out float pol )\n{ \n    const vec3 plane35 = vec3(-0.5, -0.809, 0.309);   \n\tint polarity = p.z < 0.0 ? 1 : 0;\n    if (p.x < 0.0) polarity++;\n    if (p.y < 0.0) polarity++;\n    p = abs(p);\n    for(int i=0;i<3;i++)\n    {\n        float side = dot(p, plane35);\n        if (side >= 0.0) break;\n        polarity++;\n        p -= 2.*min(0., side)*plane35;\n        if (i==2) break;\n        if (p.x < 0.0) polarity++;\n        if (p.y < 0.0) polarity++;\n        p.xy = abs(p.xy);        \n    }\n    pol = polarity % 2 == 0 ? 1.0 : -1.0;\n    return p;\n}    \n\nvec3 opIcosahedralSymmetryWithId( vec3 p, out float pol )\n{    \n\tint polarity = p.z < 0.0 ? (1<<4)+1 : 0;\n    if (p.x < 0.0) polarity+=(1<<5)+1;\n    if (p.y < 0.0) polarity+=(1<<6)+1;\n    p = abs(p);\n    for(int i=0;i<3;i++)\n    {\n        float side = dot(p, P35);\n        if (side >= 0.0) break;\n        polarity+=(1<<i*3+7)+1;\n        p -= 2.*min(0., side)*P35;\n        if (i==2) break;\n        if (p.x < 0.0) polarity+=(1<<i*3+4)+1;\n        if (p.y < 0.0) polarity+=(1<<i*3+5)+1;\n        p.xy = abs(p.xy);        \n    }\n    pol = polarity % 2 == 0 ? 1.0 : -1.0;\n    return p;\n}    \n\nvec3 opIcosahedralSymmetryOLD( vec3 p, out float polarity )\n{    \n\tvec3 s= sign(p);\n    p = abs(p);\n    float mirr = dot(p, P35);\n    p -= 2.*min(0., mirr)*P35;\n\ts *= sign(vec3(p.xy,mirr));\n    p.xy = abs(p.xy);\n    mirr = dot(p, P35);\n    p -= 2.*min(0., mirr)*P35;\n\ts *= sign(vec3(p.xy,mirr));\n    p.xy = abs(p.xy);\n    mirr = dot(p, P35);\n    p -= 2.*min(0., mirr)*P35;\n    polarity = s.x*s.y*s.z*sign(mirr);\n    return p;\n} \n\n// From IQ\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n\treturn smin(a, b, -k);\n}\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// uneven capsule\nfloat sdUnevenCapsuleY( in vec2 p, in float ra, in float rb, in float h )\n{\n\tp.x = abs(p.x);\n    \n    float b = (ra-rb)/h;\n    vec2  c = vec2(sqrt(1.0-b*b),b);\n    float k = cro(c,p);\n    float m = dot(c,p);\n    float n = dot(p,p);\n    \n         if( k < 0.0   ) return sqrt(n)               - ra;\n    else if( k > c.x*h ) return sqrt(n+h*h-2.0*h*p.y) - rb;\n                         return m                     - ra;\n}\n    \nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 opPolar(vec2 p,int n) {\n    float angle = TWOPI/float(n);\n    float at=atan(p.y,p.x); \n    // IQ video about polar symetry https://youtu.be/sl9x19EnKng?t=1745\n    float sector = round(at/angle); \n    p = Rot(angle*sector) * p;\n    return p;\n}\n\nvec4 flower(vec3 q, int n, float t) {\n    // stem\n    float cycle = sin(t*.25);\n    float h = 1.05+(n == 8 ? .60 : .35)*smoothstep(-0.5,-0.25,cycle);\n    float d = length(q-vec3(0.,0.,min(q.z,h)));\n    vec4 hit = vec4(d,2.0,q.z-h,d);\n    hit.x -= .05;\n    if (q.z < h) hit.x -= .002*min(1.0,cos((q.z-h)*150.)+.9);\n    // petals\n    q.xy *= Rot(t*.5);\n    q.yx = opPolar(q.yx,n);\n    q.z -= h;\n    q.xy-=vec2(0.0,.04);\n    q.zy *= Rot(1.55-0.9*smoothstep(-0.3,0.2,cycle));\n    q.z -= cos((q.y-.2)*10.)*.04*(smoothstep(-0.25,0.0,cycle)-.5);\n    float fan = sdUnevenCapsuleY(q.xy-vec2(0.0,.015),.015,.08,.30);\n    float fan3d = opExtrussion(q,fan,.0)-.02; \n    fan3d -= .001*min(1.0,cos((fan)*220.)+.9);\n\n    if ( fan3d < hit.x ) hit = vec4(fan3d,1.0,-fan,q.z);\n    return hit;\n}\n\nvec4 opU(vec4 a, vec4 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec4 map4(vec3 p) {\n    p.yz *= Rot(.5*cos(TWOPI*fract(iTime*.03)));\n    p.xz *= Rot(TWOPI*fract(iTime*.0234));\n    float center = length(p);\n    if ( center > 2.5 ) return vec4(center-2.4,vec3(0)); // bound volume\n    float polarity;\n    vec3 q = opIcosahedralSymmetryWithPolarity(p,polarity);\n    float base = min(center-.8,min(min(q.x,q.y),dot(q,P35))-.01);\n    float rTube = .08;\n    float h0 = length(q.xy)-rTube;\n    float h1 = length(q-ICOVERTEX*dot(q,ICOVERTEX))-rTube; // tube 1\n    float h2 = length(q-ICOMIDFACE*dot(q,ICOMIDFACE))-rTube; // tube 2\n    base = min(max(base,-h1),abs(h1)-.01);\n    base = min(max(base,-h2),abs(h2)-.01);\n    base = min(max(base,-h0),abs(h0)-.01);\n    base = smax(base,center-1.0,.02); \n    base -= .002*min(1.0,cos((center)*100.)+.8); // some carving\n    vec4 hit = vec4(base,4.0,center,0.0);\n    // Flowers\n    // Each time I get origin of xz coordinates starting from 2 edges of the domain (like dode and ico vertexes)\n    // Flower 1 at DODE face center, symetry is 5\n    // Flower 2 at ICO face center, symetry is 3\n    // Flower 3 at ICO mid edge, symetry is 4\n    // hit = opU(hit,flower(vec3(q.x,q.y*parity,q.z),8,iTime));\n    hit = opU(hit,flower(vec3((q.xz*baseDode).x,q.y*polarity,(q.xz*baseDode).y),10,T+8.));\n    hit = opU(hit,flower(vec3(q.x*polarity,q.yz*baseIco),9,T+16.));\n    hit = opU(hit,flower(vec3((q.xz).x,q.y*polarity,(q.xz).y),8,T));\n    return hit;\n}\n\nfloat map(vec3 p) {\n    return map4(p).x;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = map(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// IQ\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.5, 0, -3.6);\n\n    if ( iMouse.x > 0.0 ) {\n        ro.yz *= Rot(-.5*m.y*3.14);\n        ro.xz *= Rot(-.5*m.x*6.2831);\n    }    \n    vec3 tcol = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 bg =  vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5; // IQ https://youtu.be/Cfe5UQ-1L9Q?t=13898\n    vec2 suv = 20.0*rd.xy;\n    float cl = 1.0*(sin(suv.x*1.0+iTime)+sin(suv.y*1.0))+\n               0.5*(sin(suv.x*2.0+iTime)+sin(suv.y*2.0));\n    vec3 sky_color = vec3(.9,.9,1.0);\n    bg = mix(bg,sky_color,0.5*smoothstep(-0.4,0.4,-0.6+cl));\n    \n    vec3 col = bg;\n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec4 hit = map4(p);\n        vec3 objCol = vec3(0);\n        if ( hit.y < 1.5 ) {\n            // petals\n            objCol = mix(vec3(1.000,0.141,0.141),vec3(1.000,0.078,0.525),smoothstep(0.0,0.015,hit.z));\n            objCol = mix(objCol,vec3(1.000,0.784,0.000)+.2,smoothstep(.056,.060,hit.z));\n            objCol = mix(objCol,vec3(1),smoothstep(.005,-.02,hit.w));\n        } else if ( hit.y <= 2.5 ) {\n            // stem\n            objCol = mix(vec3(0.000,1.000,0.251),vec3(0.349,1.000,0.000),smoothstep(-0.25,0.0,hit.z));\n        } else if ( hit.y <= 4.5 ) {\n            // base\n            objCol = mix(.5+.5*vec3(0.933,1.000,0.000),vec3(1),1.0-smoothstep(0.95,0.93,hit.z));\n        }\n        vec3 sun_lig = normalize(vec3(1,1,-3));\n        float dif = max(0.0,dot(n, sun_lig));\n        float spe = pow(clamp(dot(n,normalize( sun_lig-rd )),0.0,1.0),8.0) * dif; // Blinn \n        float occ = 0.5+0.5*calcOcclusion(p,n);\n        float sha = .5+.5*calcSoftshadow( p+0.01*n, sun_lig, 0.01, 1.4 );\n        float fre = clamp(1.0+dot(rd,n),0.0,1.0); // Fresnel https://youtu.be/beNDx5Cvt7M?t=1510\n        // IQ https://www.shadertoy.com/view/3lsSzf\n        float bou_dif = sqrt(clamp( 0.1-0.9*n.y, 0.0, 1.0 ))*clamp(1.0-0.1*p.y,0.0,1.0);\n        vec3 sun_col = vec3(1.64,1.27,0.99);\n        vec3 lin = vec3(0);\n        lin += dif * sun_col * .9 * occ * sha;\n        lin += bou_dif*vec3(0.239,0.545,0.176) * occ;\n        lin += fre * sky_color * occ * sha;\n        col = objCol * lin * occ *.6;\n        col += spe * occ * .4 * sun_col * sha;\n    } \n    col = mix(col,bg,smoothstep(3.0,5.0,d)); // fog\n    col = mix(col, smoothstep(0.0,1.0,col),.4); // pop filter - YX - Is This Your Card?  - https://www.shadertoy.com/view/sl2yWK\n    tcol+=col;\n#ifdef AA\n\t\t}\n\ttcol /= 4.;\n#endif\n    tcol = pow(tcol, vec3(.4545));\t// gamma    \n    fragColor = vec4(tcol,1.0);\n}\n","name":"Image","description":"","type":"image"}]}