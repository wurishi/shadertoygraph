{"ver":"0.1","info":{"id":"MfdSWl","date":"1714643914","viewed":78,"name":"3D Sound viz","username":"Chrisy","description":"Inspired by https://www.youtube.com/watch?v=9XeE0v5JLiQ \nfork  https://www.shadertoy.com/view/ssc3zS","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["surroundsound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 drawSound(vec2 fragCoord){\n  vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float dx = 1./iResolution.y;\n    \n    float x1 = uv.x - dx;\n    float x2 = uv.x + dx;\n    float y = uv.y;\n    float time = round(iTime*55.)/55.;\n    float scale = 3.;\n    float scalex = 100.;\n    float fx1 = mainSound(0, x1/scalex + time).x * scale;\n    float fx2 = mainSound(0, x2/scalex + time).x * scale;\n    float alpha = (fx2-fx1)/(2.*dx),\n          beta  = (fx2+fx1)/(2.*dx);\n    float d = abs(beta*dx - y)/length(vec2(1., alpha));\n  \n    float _fx1 = mainSound(0, x1/scalex + time).y * scale;\n    float _fx2 = mainSound(0, x2/scalex + time).y * scale;\n    float _alpha = (_fx2-_fx1)/(2.*dx),\n          _beta  = (_fx2+_fx1)/(2.*dx);\n    float _d = abs(_beta*dx - y)/length(vec2(1., _alpha));\n    \n    return  vec3(smoothstep(3./iResolution.y,0.,d),smoothstep(3./iResolution.y,0.,_d),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (iResolution.xy*-.5 + fragCoord)/iResolution.y; //MAD INV MAD\n    vec2 uv2 = fragCoord/iResolution.xy;\n  \n    \n\n\n\n    \n\n\n\n// Calculate the ray direction 'rd', normalize to ensure unit length\n    \n //   _listenerPos vec3(-2.0, 0.0, 0.0)\n//#define _listenerForward vec3(1.0, 0.0, 0.0)\n//#define _listenerRight vec3(0.0, 0.0, 1.0)\n//#define _listenerUp vec3(0.0, 1.0, 0.0)\n\n\n\n    vec3 right   = normalize(cross(_listenerForward, _listenerUp)); \n    vec3 up      = normalize(cross(right, _listenerForward)); \n    vec2 uv1 = fragCoord / iResolution.xy;\n    uv1    = (uv1 * 2.0) - 1.0; \n    uv1.x *= (iResolution.x / iResolution.y); \n\n    vec3 rd = normalize((uv1.x * right) + (uv1.y * up) + (_listenerForward * 1.0)); \n\n    vec3 col = vec3(0.);\n    \n    vec3 ro = _listenerPos;\n\n    //vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    float d = 0.;\n    vec3 p = vec3(0);\n    bool h = raymarch(ro,rd,d,p,iTime);\n   \n    \n    col.xyz = rd;\n    col += min(d*0.1,0.5)*0.5;\n    col += drawSound(fragCoord)*2.0;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define bpm 100.\n#define beatdur (60./bpm)\n\n#define FM(fc, fm, iom) sin(TWOPI*fract((fc)*t) + (iom)*sin(TWOPI*fract((fm)*t)))\n#define FM2(pc, pm, iom) sin(mod(pc,TWOPI) + (iom)*sin(mod(pm,TWOPI)))\n#define N(nn) 440.*exp2(((nn)-9.)/12.)\n\n\n#define _listenerPos vec3(0.0, -0.9, 0.0)\n#define _listenerForward vec3(1.0, 0.0, 0.0)\n#define _listenerRight vec3(0.0, 0.0, 1.0)\n#define _listenerUp vec3(0.0, 1.0, 0.0)\n#define _radiusMovement 3.0\n#define TWOPI 6.28318530718\n\n\nvec2 sinWave(vec2 f,vec2 t){\n    return vec2(sin(TWOPI * f * t));\n}\nvec2 filteredSaw(vec2 f, float fc, float t)\n{\n    // f frequency\n    // fc cutoff frequency\n    // t time\n    vec2 x = f*t;\n    vec2 w = 0.5*f/fc;\n    w = min(w, 0.5);\n    x -= round(x);\n    return vec2(mix(-2.*x-1., -2.*x+1., smoothstep(-w, w, x)));\n}\nvec2 invfilteredSaw(vec2 f, float fc, float t)\n{\n    // f frequency\n    // fc cutoff frequency\n    // t time\n    vec2 x = f*t;\n    vec2 w = 0.5*f/fc;\n    w = min(w, 0.5);\n    x -= round(x);\n    return vec2(mix(-2.*x-1., -2.*x+1., smoothstep(-w, w, x)));\n}\n\n// ========== MARIMBA ==========\n\nvec2 marimba(vec2 f, vec2 fadeFactor,float t)\n{\n    // Classic FM \"marimba\" patch\n    // Super simple and effective.\n    vec2 low = FM(f*0.25, 0.5*f, 0.2*exp(-(2.5*fadeFactor)*t)) * exp(-(1.*fadeFactor)*t) *0.5;\n    vec2 medium = FM(f*1., 4.*f, 2.5*exp(-(1.*fadeFactor)*t)) * exp(-(555.*fadeFactor)*t) * 0.5;\n    vec2 high = FM(f*2.0, 5.01*f, 0.5*exp(-(0.3*fadeFactor)*t)) * exp(-(5.*fadeFactor)*t) * 0.1;\n    \n    return low+medium+high;\n    //return filteredSaw(f*0.5,-0.1,t)* exp(-(64.*fadeFactor)*t);\n}\n\nvec2 marimbaPattern(vec2 f , float t,vec2 reverb)\n{\n    // Pop-ish dotted eighth note pattern\n    t = mod(t, 16.*beatdur);\n    // Take two notes from the chords\n    vec2 nn = \n        (t < 4.5*beatdur) ? vec2(4.,12.) :\n        (t < 8.*beatdur) ? vec2(5.,9.) :\n        (t < 12.5*beatdur) ? vec2(9.,12.) :\n        (t < 14.*beatdur) ? vec2(7.,12.) :\n                            vec2(7.,11.);\n    t = mod(t, 8.*beatdur); // Make sure we restart the notes every two bars\n    t = mod(t, 6.*beatdur);\n    t = mod(t, 0.75*beatdur); // and repeat them four times in three beats\n    vec2 sig = vec2(0);\n    sig += marimba(N(nn.x)*f,reverb, t) * vec2(0.7,0.2);\n    sig += marimba(N(nn.y)*f,reverb, t) * vec2(0.1,0.5);\n    return sig;\n}\n\n\nvec2 soundWave(vec2 f,vec2 reverb,float t){\n    //return filteredSaw(f,0.1,t)*15.0;\n    return marimbaPattern(f,t,reverb)*15.0;\n}\n\nvec2 soundFxPan(vec2 sound,float pan){\n    float left = sound.x * (0.5 * (1.0 - pan) + 0.5); // Adjust left channel based on pan\n    float right = sound.y * (0.5 * (1.0 + pan) + 0.5); // Adjust right channel based on pan\n    return vec2(left,right);\n}\nvec4 environment_sfx3D(float t,float f,float pan , float angleToFront , float angletoTop,float attenuation){\n    float front = 1.0-pow(1.0-pow(angleToFront*0.5+0.5,1.0),2.0);\n\n    vec2 soundWaveDirect = soundWave(vec2(1.0),vec2(1.0),t)*attenuation*1.;\n    vec2 soundWaveIndirect = soundWave(vec2(1.0),vec2(1.0),t+angletoTop*0.1)*max(0.1,attenuation)*0.0; // less reverb on the bottom more reverb above head\n         soundWaveIndirect += soundWave(mix(soundFxPan(vec2(1.0,1.0),-pan*0.01*angletoTop),vec2(1.0),front),mix(soundFxPan(vec2(0.8,0.8)*attenuation,pan),vec2(1.0),front*0.4),t+angletoTop*0.01)*max(0.0,attenuation); // less reverb on the bottom more reverb above head\n         soundWaveIndirect += soundWave(mix(soundFxPan(vec2(1.0,1.0),-pan*0.05*angletoTop),vec2(1.0),front),mix(soundFxPan(vec2(0.5,0.5)*attenuation,pan),vec2(1.0),front*0.1),t+angletoTop*0.02)*max(0.4,attenuation); // less reverb on the bottom more reverb above head\n    return vec4(soundWaveDirect,soundWaveIndirect);\n    \n}\n\nvec2 sound(float t){\n    // Position of the sound source and listener in 3D space\n    vec3 sourcePos = vec3(sin(t) * _radiusMovement, 0.0, cos(t) * _radiusMovement); // Source moves in a circle\n    vec3 listenerPos = _listenerPos; // Listener at origin\n    vec3 listenerForward = _listenerForward; // Assuming listener is facing along the x-axis\n    vec3 listenerRight = _listenerRight; // Right vector perpendicular to forward\n\n    // Calculate distance and direction from listener to source\n    vec3 dirToListener = -normalize(sourcePos - listenerPos);\n    float distance = length(sourcePos - listenerPos);\n\n    // Calculate attenuation based on distance using inverse square law\n    float attenuation = 1.0 / (1.0 + distance * distance);\n\n    // Calculate panning and head-shadowing effect\n    float pan = dot(dirToListener, listenerRight); // -1 when fully left, 1 when fully right\n    float angleToFront = dot(dirToListener, listenerForward); // -1 when behind, 1 when in front\n    float angleToTop = dot(dirToListener, _listenerUp)*0.5+0.5; // -1 when behind, 1 when in front\n    float angleEffect = acos(clamp(angleToFront, -1.0, 1.0)); // Ensure value is within acos range and convert angle to radians\n    \n    // Mimic the effect of head and ear shape, enhancing front more significantly\n    float headShadowing = exp(-pow(angleEffect - 3.14159 * 0.5, 2.0) / (2.0 * pow(3.14159 * 0.25, 2.0))); // Narrower Gaussian for more focused front\n    float earGain = 1.0 + 0.5 * cos(angleEffect); // Increased gain when directly in front\n\n    // Apply directional attenuation\n    float Attenuation = attenuation ;\n    float directional =  headShadowing * earGain;\n\n    // Generate a basic sine wave as sound\n    float frequency = 440.0*0.5; // Standard A note\n    vec4 environment_sfx = environment_sfx3D(t,frequency,pan,angleToFront,angleToTop,attenuation);\n    // Apply attenuation to the sound wave\n    vec2 directSound = directional* environment_sfx.xy;\n    vec2 indirectSound = environment_sfx.zw*Attenuation*mix(directional,1.0,0.7); // more diffuse on the top just like lighting\n\n    vec2 perceivedSound = directSound+indirectSound;\n\n\n    // Calculate stereo output\n    // Output the modified sound wave to stereo channels\n    return soundFxPan(perceivedSound,pan);\n}\n\n\nvec2 mainSound(int samp, float t){\n    return sound(t);\n}\n\n\n//------------------------------------------------------------------------------------------\n// Quaternion Functions\n//------------------------------------------------------------------------------------------\n\nvec4 Quat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    return normalize(vec4(axis * sin(angle), cos(angle)));\n}\n\nvec4 QxQ(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = (q1.w * q2.w) - dot(q1.xyz, q2.xyz);\n    res.xyz = (q1.w * q2.xyz) + (q2.w * q1.xyz) + cross(q1.xyz, q2.xyz);\n    return normalize(res);\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + (q.w * t) + cross(q.xyz, t);\n}\n\n// Essential RM options\n#define MAX_STEPS 500.\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// Optimization\n#define RELAX 1.7\n\n// Stress testing\n#define STRESS 1.\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat GetDist( vec3 p ,float iTime) {\n    float d = MAX_DIST;\n    #define GD(x); d = min(d,x);\n    vec3 sourcePos = vec3(sin(iTime)*_radiusMovement,0.0 , cos(iTime)*_radiusMovement); // Source moves in a circle\n    GD(sdSphere(p+sourcePos,1.));\n    GD(p.y+1.0);\n    \n    // stressful loop used to lower framerate for testing\n    for(int i=0; float(i)<STRESS; i+=1){\n        if(fract(atan(p.x))>.5) {\n            d += 0.0000001;\n        }\n        if(fract(cos(p.y))>.5) {\n            d -= 0.0000001;\n        }\n        if(fract(sin(p.z))>.5) {\n            d += 0.0000001;\n        }\n    }\n    \n    return d;\n}\n\n\nbool raymarch( in vec3 ro, in vec3 rd, out float dO, out vec3 p,float iTime ) {\n    dO = 0.;\n    float i = 0.;\n    #ifdef RELAX\n    bool r = true;\n    float dSp = MAX_DIST;\n\n    for(; i<MAX_STEPS; ++i) {\n        p = (rd * dO) + ro; //MAD\n        float dS = GetDist(p,iTime);\n        if ( dS + dSp > dSp * RELAX ) break;\n        dO += dS * RELAX; //MAD\n        dSp = dS;\n        if ( abs(dS) < SURF_DIST || dO > MAX_DIST ) break;\n    }\n    #endif\n    \n    for(; i<MAX_STEPS; ++i) {\n        p = (rd * dO) + ro; //MAD\n        float dS = GetDist(p,iTime);\n        dO += dS;\n        if ( abs(dS) < SURF_DIST || dO > MAX_DIST ) break;\n    }\n    return ( abs(GetDist(p,iTime)) < SURF_DIST );\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"","name":"Sound","description":"","type":"sound"}]}