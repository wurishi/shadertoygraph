{"ver":"0.1","info":{"id":"3dfcW8","date":"1584614879","viewed":148,"name":"Basic : Projective Geometry","username":"Gijs","description":"Spherical model of projective geometry. Pascal's Theorem is visualized. One should first look around using just the mouse and be amazed by the oddities of projective geometry. Then, afterwards, move the camera using WASD+shift+space and be mind-blown!","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","geometry","projective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    \n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y*ZOOM;\n\n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    \n    vec3 ori = cameraPosition;\n    vec3 dir = normalize(cameraForward+p.x*cameraRight+p.y*cameraUpward);\n \n    vec3 col = vec3(0);\n    \n    //solving ray unit sphere intersection\n    float b = 2.*dot(ori,dir);\n    float c =    dot(ori,ori) - 1.;\n    float d = b*b - 4.*c;\n    \n    if(d>0.){\n        float t1 = (-b + sqrt(d))/2.;\n    \tfloat t2 = (-b - sqrt(d))/2.;\n        \n        float tmin = min(t1,t2);\n        float tmax = max(t1,t2);\n        \n                    draw(col, ori + dir*tmax);\n        if(tmin>0.) draw(col, ori + dir*tmin);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v){\n\tfloat c = cos(angle);\n\tvec3 s = sin(angle) * v;\n\tvec3 d =  (1.0 - c) * v;\n    return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>3 || p.y > 0) return;\n    \n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    \n    if(iFrame==0){\n        cameraPosition = vec3( 0, 0, 0);\n        cameraForward  = vec3( 0, 0, 1);\n    \tcameraRight    = vec3( 1, 0, 0);\n    \tcameraUpward   = vec3( 0, 1, 0);\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||rollleft||rollright||down||up||mouseLeft;\n    \n    float stepSize = MOVEMENT_SPEED*iTimeDelta*ZOOM;\n    \n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUpward *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    float r = (float(rollleft)-float(rollright))*0.01;\n    cameraRight  = rotate(cameraRight , r, cameraForward);\n    cameraUpward = rotate(cameraUpward, r, cameraForward);\n    \n    if(mouseLeft){\n\t\tvec2 s = (iMouse.xy*2. - iResolution.xy)/iResolution.y;\n\t\t\t\n\t\tcameraForward = rotate(cameraForward, s.x*ZOOM*0.02, cameraUpward);\n        cameraRight  = normalize(cross(cameraUpward, cameraForward ));\n        \n\t\tcameraForward = rotate(cameraForward,-s.y*ZOOM*0.02, cameraRight );\n\t\tcameraUpward = normalize(cross(cameraForward, cameraRight ));   \n\t\t\n    }\n    \n    if(p.x==0){\n    \tfragColor.rgb = cameraPosition;\n    }else if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUpward;\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Camera\nconst float ZOOM           = 1.5;\nconst float MOVEMENT_SPEED = 2.;\n\n//points are actually line through the origin in R^3. \n//We need only know its direction. (So they could be normalized)\nconst vec3 point1 = vec3( 1,1.4142, 1);\nconst vec3 point2 = vec3( 0,1, 1);\nconst vec3 point4 = vec3(-1,1, 0);\nconst vec3 point3 = vec3(-1,1.4142,-1);\nconst vec3 point6 = vec3( 0,1,-1);\nconst vec3 point5 = vec3( 1,1, 0);\n\n//lines are actually planes through the origin in R^3. \n//We need only know its normal. (So they could be normalized)\nconst vec3 line1 = cross(point1,point2);\nconst vec3 line2 = cross(point2,point3);\nconst vec3 line3 = cross(point3,point4);\nconst vec3 line4 = cross(point4,point5);\nconst vec3 line5 = cross(point5,point6);\nconst vec3 line6 = cross(point6,point1);\n\n//more points\nconst vec3 point7 = cross(line1,line4);\nconst vec3 point8 = cross(line2,line5);\nconst vec3 point9 = cross(line3,line6);\n\n//final point\nconst vec3 line7 = cross(point7,point8);\n\n//some colors\nvec3 c1 = vec3(.5,.9,.5);\nvec3 c2 = vec3(1,.5,0);\nvec3 c3 = vec3(.5,.5,.9);\nvec3 c4 = vec3(.9,.5,.5);\nvec3 c5 = vec3(.5,0,.5);\n\n//conics in the frame are actually cones at the origin in R^3. \n//MUST BE SYMMETRIC\nconst mat3 cone = mat3( 1,  0, 0,\n                        0, -1, 0,\n                        0,  0, 1);\n\n\nconst float lb1 = 0.02  , lb2 = 0.01;\nconst float pb1 = 0.9985, pb2 = 0.999;\nconst float cb1 = 0.04  , cb2 = 0.03;\n\nvoid draw(inout vec3 col, vec3 h){\n    col = mix(col, c1, smoothstep(lb1,lb2,abs(dot(normalize(line1),h))));\n    col = mix(col, c1, smoothstep(lb1,lb2,abs(dot(normalize(line2),h))));\n    col = mix(col, c1, smoothstep(lb1,lb2,abs(dot(normalize(line3),h))));\n    col = mix(col, c1, smoothstep(lb1,lb2,abs(dot(normalize(line4),h))));\n    col = mix(col, c1, smoothstep(lb1,lb2,abs(dot(normalize(line5),h))));\n    col = mix(col, c1, smoothstep(lb1,lb2,abs(dot(normalize(line6),h))));\n    col = mix(col, c2, smoothstep(lb1,lb2,abs(dot(normalize(line7),h))));\n\n    col = mix(col, c3, smoothstep(cb1, cb2, abs(dot(h,normalize(cone*h)))));\n    \n    col = mix(col, c4, smoothstep(pb1, pb2, abs(dot(normalize(point1), h))));\n\tcol = mix(col, c4, smoothstep(pb1, pb2, abs(dot(normalize(point2), h))));\n    col = mix(col, c4, smoothstep(pb1, pb2, abs(dot(normalize(point3), h))));\n    col = mix(col, c4, smoothstep(pb1, pb2, abs(dot(normalize(point4), h))));\n    col = mix(col, c4, smoothstep(pb1, pb2, abs(dot(normalize(point5), h))));\n    col = mix(col, c4, smoothstep(pb1, pb2, abs(dot(normalize(point6), h))));\n    col = mix(col, c5, smoothstep(pb1, pb2, abs(dot(normalize(point7), h))));\n    col = mix(col, c5, smoothstep(pb1, pb2, abs(dot(normalize(point8), h))));\n    col = mix(col, c5, smoothstep(pb1, pb2, abs(dot(normalize(point9), h))));\n}\n\nvoid dualDraw(inout vec3 col, vec3 h){    \n\n    col = mix(col, c4, smoothstep(lb1,lb2, abs(dot(normalize(point1), h))));\n\tcol = mix(col, c4, smoothstep(lb1,lb2, abs(dot(normalize(point2), h))));\n    col = mix(col, c4, smoothstep(lb1,lb2, abs(dot(normalize(point3), h))));\n    col = mix(col, c4, smoothstep(lb1,lb2, abs(dot(normalize(point4), h))));\n    col = mix(col, c4, smoothstep(lb1,lb2, abs(dot(normalize(point5), h))));\n    col = mix(col, c4, smoothstep(lb1,lb2, abs(dot(normalize(point6), h))));\n    col = mix(col, c5, smoothstep(lb1,lb2, abs(dot(normalize(point7), h))));\n    col = mix(col, c5, smoothstep(lb1,lb2, abs(dot(normalize(point8), h))));\n    col = mix(col, c5, smoothstep(lb1,lb2, abs(dot(normalize(point9), h))));\n    \n    col = mix(col, c3, smoothstep(cb1, cb2, abs(dot(h,normalize(cone*h)))));\n    \n    col = mix(col, c1, smoothstep(pb1, pb2, abs(dot(normalize(line1),h))));\n    col = mix(col, c1, smoothstep(pb1, pb2, abs(dot(normalize(line2),h))));\n    col = mix(col, c1, smoothstep(pb1, pb2, abs(dot(normalize(line3),h))));\n    col = mix(col, c1, smoothstep(pb1, pb2, abs(dot(normalize(line4),h))));\n    col = mix(col, c1, smoothstep(pb1, pb2, abs(dot(normalize(line5),h))));\n    col = mix(col, c1, smoothstep(pb1, pb2, abs(dot(normalize(line6),h))));\n    col = mix(col, c2, smoothstep(pb1, pb2, abs(dot(normalize(line7),h))));\n\n}","name":"Common","description":"","type":"common"}]}