{"ver":"0.1","info":{"id":"ll3SD2","date":"1481710112","viewed":1141,"name":"Icebreaker (Voronoi Cracks)","username":"Hadyn","description":"A modification of iq's awesome voronoi distance shader to create a fracturing/melting ice pattern.","likes":36,"published":1,"flags":0,"usePreview":1,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on original code by by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/ldl3W8\n// https://iquilezles.org/articles/voronoilines\n\n// Modified by hadyn lander\n\n// #define ROUNDED_MODE\n#define PHASE_POWER 2.0\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\tfloat oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\t\n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timeStep = 0.05*iTime - 0.5;\n    \n    vec2 p = fragCoord.xy/iResolution.xx;\n    p *= 12.0; // higher values zoom out further - don't go too high or the sine waves will become quite obvious...\n    p.x += timeStep*6.0;\n    p.y += timeStep*3.0;\n    vec2 unscaledPos = fragCoord.xy/iResolution.xy;\n    vec4 c = voronoi( p );\n    c.x = 1.0-pow(1.0-c.x, 2.0);\n\n    float cellPhase = p.x + c.y + 2.0*sin((p.y + c.z)*0.8 + (p.x + c.y)*0.4);\n    cellPhase *= 0.025;\n    cellPhase = clamp(abs(mod(cellPhase -timeStep, 1.0)-0.5)*2.0, 0.0, 1.0);\n    cellPhase = pow(clamp(cellPhase*2.0-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    float edgePhase = p.x + 2.0*sin(p.y*0.8 + p.x*0.4);\n    edgePhase *= 0.025;\n    edgePhase = clamp(abs(mod(edgePhase -timeStep, 1.0)-0.5)*2.0, 0.0, 1.0);\n    edgePhase = pow(clamp(edgePhase*2.0-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    float phase = mix(edgePhase, cellPhase, smoothstep(0.0,0.2, edgePhase));\n    float shapedPhase = 1.0-pow(1.0-phase, 2.0);\n\n    vec3 col;\n    \n    #ifdef ROUNDED_MODE\n        col = mix( vec3(0.0,0.6,1.0), vec3(1.0,1.0,1.0), smoothstep( shapedPhase-mix(0.025, 0.001, shapedPhase), shapedPhase, mix(c.x, 0.999-c.w, shapedPhase) ) );\n\t#else\n   \t\tcol = mix( vec3(0.0,0.6,1.0), vec3(1.0,1.0,1.0), smoothstep( phase-0.025, phase, c.x ) );\n    #endif\t\n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}