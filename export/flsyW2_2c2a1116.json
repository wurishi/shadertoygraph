{"ver":"0.1","info":{"id":"flsyW2","date":"1648726738","viewed":67,"name":"Jumping Sumos - DCFL","username":"DCFL","description":"Fully procedural scene with raymarching  (WIthOUT bounding Volumes)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sumoraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All rights belong to us, ask in the comments before share!\n// Compiles a bit long, be patient XD\n\n// background is id 0\n// floor is id 1\n// blob is id 2\n// dude is id 3\n// sky is id 4\n// pants is id 5\n// sumo ring is 6\n// Temple posts is 7\n// Temple Roof is 8\n// Glowing Bobble is id 9\n// Maoi is id 10\n// visibility of bounding volumes is id 11\n\n#define MAX_STEPS 1000\n#define MAX_DIST 800.\n#define SURF_DIST .01\n#define SKY_HEIGHT 15.\n#define PI 3.1415926\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r){\n    return length(p - pos) - r;\n}\n\nfloat sdPlain(vec3 p, vec3 n, float h){\n    return dot(p, n) + h;\n}\n\n\nvec2 vec_s_min(vec2 u, vec2 v, float w){\n    return vec2(smin(u.x, v.x, w), u.x < v.x ? u.y : v.y);\n}\n\nvec2 vec_min(vec2 u, vec2 v){\n    return u.x < v.x ? u : v;\n}\n\nbool lt(float a, float b){\n    return sign(a - b) == -1.;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot( pa*l2 - ba*y, pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCutHollowSphere( vec3 p, vec3 pos, float r, float h, float t ){\n    p = p - pos;\n    float w = sqrt(r*r-h*h);\n  \n    vec2 q = vec2( length(p.xz), p.y );\n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )    // Sumo Ring\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//for pseudorandom numbers\nfloat Rand21(vec2 p){\n    return fract(sin(p.x*100.+p.y*657.)*564.);\n}\n\nfloat StarRand21(vec2 p){\n    p=p*0.08;\n    return fract(sin(p.x*632.32+p.y*657.23)*56.23);\n}\n\n\n\n\n//Smoothnoise for Sand and Clouds\nfloat Smoothnoise(vec2 uv){\n    vec2 localchords = smoothstep(0.,1.,fract(uv)); //10*10 fields on screen, inner coordinates go from 0 to 1\n    vec2 gridID = floor(uv);\n    float bl = Rand21(gridID);\n    float br = Rand21(gridID + vec2(1,0));\n    float b = mix(bl,br,localchords.x);\n    float tl = Rand21(gridID + vec2(0,1));\n    float tr = Rand21(gridID + vec2(1,1));\n    float t = mix(tl,tr,localchords.x);\n    return mix(b,t,localchords.y);\n}\n\n\nfloat daytime(){\n    float day_cycle_speed = 0.;\n    float T = mod(iTime*day_cycle_speed + 0.7,6.283);\n    return T;\n}\n\n\nfloat basic_stars(vec2 p){\n  \n    float noise = StarRand21(p);\n    if(noise > 0.999 )\n        return 1.;\n    return 0.;\n}\n\nfloat get_cloud_value(vec2 iv){\nfloat speed = 0.35;\n        float c = Smoothnoise(iv*4.+vec2(speed*iTime*1.,0.));\n        c += Smoothnoise(iv*8.+vec2(speed*iTime*1.5,0.))*0.5;\n        c += Smoothnoise(iv*16.+vec2(speed*iTime*3.,0.))*0.25;\n        c += Smoothnoise(iv*32.+vec2(speed*iTime*5.,0.))*0.125;\n        return c / (3. - sin(daytime())*0.4+1.); //cloud strength changes over time\n}\n\n\nfloat sdMoai(vec3 pos){\n    pos.z = abs(pos.z);  //mirror a second statue\n    vec3 moai_pos = vec3(-3,-1., 20);\n    float base =  sdRoundCone(pos, moai_pos, moai_pos + vec3(0,7,0), 2.25, 1.6 );\n    float bounding_box = sdBox((pos-moai_pos)+vec3(0.0,-3.5,2.5),vec3(4.,1.5,2.));\n    float nose =  sdRoundCone((pos-moai_pos) + vec3(0,-0.5,1.), vec3(0.0,2.0,-0.5), vec3(0.0,5.,0.5), 0.9, 0.4 );\n    float ear_left =  sdRoundCone((pos-moai_pos), vec3(2.4,2.,0.0), vec3(1.7,5.,0.0), 0.3,0.2 );\n    float ear_right =  sdRoundCone((pos-moai_pos), vec3(-2.4,2.,0.0), vec3(-1.7,5.,0.0), 0.3,0.2 );\n    return smin(smin(max(base, -bounding_box), nose, 1.), min(ear_left, ear_right), 1.);\n\n}\n\n\n\nvec2 GetDist(vec3 p, bool ignore_sky, bool use_inner_radius, bool ignore_lights) {\n    vec2 d = vec2(MAX_DIST, 0.);\n    float slowdown = .7;\n\n    if(!ignore_sky){//plane for clouds\n        float cloudplane = sdPlain(p,vec3(0,-1,0),SKY_HEIGHT);\n        d = vec_min(d,vec2(cloudplane,4.)); //cloud has ID = 4\n    }\n    \n    {// plane with wobble\n        float pd = sdPlain(p, vec3(0,1,0), .0);\n\n        float time = iTime * slowdown;\n        vec2 bounce_pos = vec2(0., -8.283); // center of wobble\n        //if(3.1415 < mod(iTime, 6.283)){bounce_pos.x = 6.283;}\n        float bounce_time = 3.1415;\n    \n        pd += sin(p.x * .1) * cos(p.z * .2) - clamp(length(p.xz)*sin((length(p.xz)-50.)/300.),0.0,15.) * sin(p.x * 0.03 +sin(p.z*0.04)) * cos(p.z * .05); // landscaping\n        float abst = min(length(bounce_pos - p.xz), length(vec2(bounce_pos.x, -bounce_pos.y) - p.xz)); // distance to the closest wobble origin\n        float offset = -cos(abst + -6. * iTime) / (lt(abst, 4.) ? 4. : abst) * 2.; // wobble\n        float intensity = mod(time, bounce_time); // current wobble\n        offset *= (1. - intensity / bounce_time);  // time since wobble -> intensity\n        offset *= clamp(mod(time, bounce_time) - abst * .1, 0., 1.); // increase wobble radius over time\n        if(length(p.xz)<12.){\n            pd += offset; // wobble the plane\n        }\n        d = vec_s_min(d, vec2(pd, 1.), 1.); // new distance\n    }\n    \n    {// balls with wobble\n        if(ignore_lights == false){\n            //limiting carved cylinder for bubbles\n    \n            float ocd = sdCappedCylinder(p,30.,15.);\n            float icd = sdCappedCylinder(p,12.,15.);\n            float cut = max(-icd,ocd);\n        \n   \n            //actual bubbles\n            \n            float time_mult = iTime; //speed of the bubbles\n            float y = mod(round(p.x / 12.) * 4. + round(p.z / 18.) * 3. + time_mult - 7., 15.) -3.; // height of ball\n            \n            vec3 pos = + vec3(round(p.x / 14.) * 14. + 1., y, round(p.z / 18.) * 18. + 1.); //position of ball\n            float br = 1.;    //base radius\n            float br_fade = br - br*(clamp(y,6.,12.)-6.)/6.; //base radius and fade out at the top, smooth shadows still a bit faulty here\n            float wobble_radius = br_fade + 0.6*(clamp(-y+12.,8.,9.)-8.)*\n                                  ((clamp(y+(sin(pos.x * .1)*cos(pos.z * .2))-br-0.8,0.,0.01)*100.)/\n                                  (clamp(y,1.0,100.) * 10.))*(sin(y * 25.) + cos(y * 14.)); // idk, questions -> dalemke@students.uni-mainz.de\n            float inner_radius = wobble_radius/8.;                      \n            float sd = sdSphere(p, pos, use_inner_radius ? inner_radius : wobble_radius); // distance to wobbled ball\n            d = vec_s_min(d, vec2(max(sd,cut), 9.),1.5);\n        }\n    }\n       \n    \n    \n    {\n    //Sumo Ring\n    vec3 pp = p;\n    pp.xy = pp.xy*Rot(.05);\n    float td = sdTorus(pp-vec3(0,0.2,0), vec2(11.8,.8));\n    d = vec_min(d, vec2(td, 6.));\n    }\n    \n    \n    {//Japanese Temple\n    //Posts\n    vec3 pp = vec3(p.x,p.y,abs(p.z)); //mirroring\n    float pd = sdCapsule(pp,vec3(-25,0,12),vec3(-25,12,12),1.);\n    d = vec_min(d, vec2(pd, 7.));\n    \n    //Roof\n    vec3 temple_pos = p;\n    temple_pos -= vec3(-25,62,0);//offset\n    temple_pos.xy = temple_pos.xy*Rot(3.1415/2.);\n    float rd1 = sdTorus(temple_pos,vec2(50.,1.));\n    \n    \n    //capping of Temple roof\n    float boxd = sdCappedCylinder(p-vec3(-25,0,0),30.,15.);\n    float cut_roof = max(boxd, rd1);\n    d = vec_min(d, vec2(cut_roof, 8.));\n    }\n    \n    \n    {//Fan Flags\n    vec3 pp = vec3(p.x,p.y,abs(p.z)); //mirroring\n    float cd = sdCapsule(pp,vec3(-5.5,1., 20.),vec3(-5.5,9.,17.),0.3);\n    d = vec_min(d, vec2(cd, 7.));\n    \n    pp = pp - vec3(0,5,0) - vec3(-5.5 ,9.,17.);\n    pp.yz = Rot(-0.33) * pp.yz;\n    float wave = sin(pp.z*2. + iTime*6.) * clamp(-(pp.z+2.),0.,1.);\n    pp = pp + vec3(0,5,0) + vec3(-5.5 + wave,9.,17.);\n    float fd = sdBox(pp-vec3(-5.5,8.,12.5),vec3(0.1,1.5,3.));\n    d = vec_min(d, vec2(fd*0.5, 5.));\n    }\n    \n    \n    \n    {//DUDDDDDDDDDDDDDDDDDE\n        vec3 pp = p; pp.z = abs(pp.z);\n        \n        float t = (iTime - .2) * slowdown;\n        vec2 sm = vec2(MAX_DIST, .0);\n        float x = mod(t, 6.283);\n        if(x > 3.1415){ x = 6.283 - x;} // Jump from left to right\n        x = (x - 1.57075) * 4.;\n        float z = 0.;\n        float y = sqrt(abs(sin(t))) * 7. + sin(-x * .1) * cos(-z * .2) + .5;\n        vec3 pos = vec3(z, y+1.5, abs(x) + 2.);\n        \n        float bounding_sphere = sdSphere(pp, pos, 4.5); //for performance\n        //if(bounding_sphere < d.x){\n        \n            float ymin = .5;\n            float ymax = 3.5;\n            float y_move_perc = (y - ymin) / (ymax - ymin);\n        \n            float wobble_offset = 0.2* clamp((sin(t*4.)),0.0,0.1)*10.*clamp(abs(cos(t*2.)),0.0,1.0)*(sin(t * 25.) + cos(t * 14.)); //collision every pi, starting pi/2\n            float lower_bod_r = 2.1 + wobble_offset; \n            float body = sdRoundCone(pp, pos + vec3(0, -1, 0), pos + vec3(0, 1, 0), lower_bod_r, 1.25); // body\n            sm = vec_s_min(sm, vec2(body, 3.), .5);\n\n            float head = sdSphere(pp, pos + vec3(0, 2.75, 0), .75); // head\n            sm = vec_s_min(sm, vec2(head, 3.), .75);\n        \n            float arm_left = sdCapsule(pp, pos + vec3(1., 1.5, 0), pos + vec3(2.5, (1.5 - y_move_perc) * .5, 0), .5); // arm left\n            sm = vec_s_min(sm, vec2(arm_left, 3.), .5);\n        \n            float arm_right = sdCapsule(pp, pos + vec3(-1., 1.5, 0), pos + vec3(-2.5, (1.5 - y_move_perc) * .5, 0), .5); // arm right\n            sm = vec_s_min(sm, vec2(arm_right, 3.), .5);\n        \n            float leg_left = sdCapsule(pp, pos + vec3(1.5, -2., 0), pos + vec3(1.5, -3.5, y_move_perc - 1.5), .5); // leg left\n            sm = vec_s_min(sm, vec2(leg_left, 3.), .5);\n        \n            float leg_right = sdCapsule(pp, pos + vec3(-1.5, -2., 0), pos + vec3(-1.5, -3.5, y_move_perc - 1.5), .5); // leg right\n            sm = vec_s_min(sm, vec2(leg_right, 3.), .5);  \n        \n        \n            float pants_radius = lower_bod_r + 0.05;\n            float pants = sdCutHollowSphere(pp, pos - vec3(0, 1, 0), pants_radius, -0.5, .1);\n            sm = vec_min(sm, vec2(pants, 5.));\n            d = vec_min(d, sm);\n        //}\n    }\n    \n    {//Moai\n        \n        vec3 mpos = vec3(p.x,p.y,abs(p.z)); //for mirroring\n        //if(length(mpos - vec3(-3,2.5, 20)) - 4. < d.x){\n            float sdm = sdMoai(p);\n            d = vec_min(d, vec2(sdm, 10.));\n        //}\n    }\n    \n    \n    \n    return d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, bool use_inner_radius) {\n    vec2 dO=vec2(0., 0.);\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p, false, use_inner_radius, false);\n        dO.x += dS.x;                         \n        if(dO.x>MAX_DIST){dO.y = 0.; break;}\n        if(abs(dS.x)<SURF_DIST){dO.y = dS.y; break;}\n    }\n    return dO;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt){\n    float res = 1.0;\n    for( float t=mint; t<maxt; ){\n        float h = GetDist(ro + rd*t, true, false, true).x;\n        if( h < 0.0001 )\n            return 0.1;\n        res = min( res, 16. * max(h,0.)/t +0.1 );\n        if(res < 0.1001) break;\n        t += clamp(h,0.001,1.0); //lower higher bound for more precision\n    }\n    return res;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p, false, false, false).x;\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, false, false, false).x,\n        GetDist(p-e.yxy, false, false, false).x,\n        GetDist(p-e.yyx, false, false, false).x);\n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p,vec2 mouse) {\n    \n    float shininess = 10.;\n    vec3 lightPos = vec3(0, 0, 0);\n    float light_rot_radius = 80.;\n    float dt = daytime();\n    lightPos.xy += vec2(cos(dt)*light_rot_radius,sin(dt)*light_rot_radius);   //movement of lightpos\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(-l, n);\n    vec3 help_view_pos = vec3(0, 4, -18) ;\n    help_view_pos.yz *= Rot(-mouse.y+.4);         //rotation of Viewpos for the spectral light\n    help_view_pos.xz *= Rot(-mouse.x*6.2831);\n    vec3 v = normalize(help_view_pos - p); \n    float dif = clamp(dot(n, l), 0., 1.);\n    float spec = pow(max(dot(r,v), .0), shininess);\n    \n    // shadow by objects\n    float shadow = softshadow(p,l,SURF_DIST*2.,length(p-lightPos));\n    \n    // shadow by clouds\n    vec3 cloud_pos = p + (SKY_HEIGHT - p.y) * l;\n    float cloud_intensity = .1;\n    shadow = min(shadow, (1. - clamp(get_cloud_value(cloud_pos.xz * 0.01), .0, 1.)));\n   \n    dif += spec*0.6;\n    \n    dif *= shadow*0.9; \n \n    return dif ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {  //Mouse movement Method\n    vec3 f = normalize(l-p),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = p+f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i-p);\n    return d;\n}\n\n\nvec3[20] get_ball_pos(){\n    vec3 lp[20];\n    for(int i = 0; i < 20; i+=1)\n        lp[i] = vec3(0);\n    float x_step = 14., z_step = 18.;\n    float min_dis = 12., max_dis = 30.;\n    int cnt = 0;\n    for(float i = 0.; i < max_dis; i += x_step)\n        for(float j = 0.; j < max_dis; j += z_step){\n            float d = sqrt(i*i+j*j);\n            if(d > min_dis && d < max_dis){\n                for(float ii = -1.; ii <= 1.; ii += 2.)\n                    for(float jj = -1.; jj <= 1.; jj += 2.){\n                        float y = mod(ii*round(i / 12.) * 4. + jj*j / 18. * 3. + iTime - 7., 15.) -3.;\n                        lp[cnt] = vec3(ii*i+1., y, jj*j+1.);\n                        cnt++;\n                    }\n            }\n    }\nreturn lp;\n}\n\n\n\nvec3 get_color_2(float id, vec3 p, vec3 ro, vec3 rd, float d, vec2 m, bool lightspots){  //no recursion allowed, so we used this\n    vec3 col = vec3(0.,0.,1.0);\n    //coloring using the id\n    if(id < .5){col = vec3(0.65,0.8,1.);}\n    else if(id < 1.5){\n        float snow_intensity = 2.2;\n        float snow_height_start = 7.0;\n            //plain color and dots    \n            float dis = sqrt((1. - mod(p.x, 2.)) * (1. - mod(p.x, 2.)) + (1. - mod(p.z, 2.)) * (1. - mod(p.z, 2.)));\n            dis *= 2.; dis -= .5;\n            dis = clamp(dis, 0., 1.);\n            if(p.y < snow_height_start +1.){        //only color the dots, if not on a mointain top\n                col = mix(vec3(.5,.8,.2), vec3(.3,.5,.2), dis);\n            }else{\n                col = vec3(.3,.5,.2);\n            }\n            if(length(p.xz) < 12. ){      \n                col = vec3(1,0.9,0.5)*clamp(Smoothnoise(p.xz*4.),0.3,0.7);\n            }\n        \n        float snow_fade =clamp(p.y- (snow_height_start + sin(p.x)),0.,1.);\n       \n        col += p.y/10. * snow_intensity * snow_fade * vec3(1,1,1);//Snow on mountains \n       \n    }\n    \n    else if(id < 2.5){col = vec3(.5,.8,.2);}\n    else if(id < 3.5){\n        col = mix(vec3(1.44,0.9,0.036),vec3(3.6,1.,0.4), clamp(sdSphere(p, vec3(0,1.,0), 0.1) / 10., 0., 1.));\n    }\n    else if(id < 4.5){\n        vec2 iv = vec2(p.x*0.01,p.z*0.01);\n        float c = get_cloud_value(iv);\n        vec3 star_color = vec3(1);\n        vec3 sky_color = vec3(0.5,0.65,0.99)*clamp((sin(daytime())/2.+0.5),0.,0.8); //babyblue: vec3(0.5,0.65,0.99)    orange: vec3(0.9333,0.286,0.165)\n        col = sky_color   + vec3(c) + basic_stars(floor(iv*1000.)/1000.)*star_color* abs((-sin(daytime())/2.+0.5)-0.1) ; \n        \n        \n        \n    }else if(id < 5.5){\n        col = p.z < 0. ? vec3(1,0,0) : vec3(0,0,1);\n    }else if(id < 6.5){\n        col = vec3(1,1.,0.08)*1.3*clamp(Smoothnoise(p.xz),0.45,0.55);\n    }else if(id<7.5){\n        col = vec3(0.55,0.27,0.07);  //temple posts color\n    }else if(id<8.5){\n        col = vec3(0.9,0.2,0.2);   //temple roof color\n    }else if(id == 10.){\n        col = vec3(.8,.8,.8);\n    }\n    \n    \n    if(id != 9. && id != 4. && length(p)<40. && lightspots == true){\n        vec3[20] ball_array = get_ball_pos();\n        \n        for(int i = 0; i < 20; i++){\n            if(ball_array[i] != vec3(0)){\n                float dist = length(p-ball_array[i]);\n                vec3 glow_col = vec3(sin(ball_array[i].y)/4.+0.75,sin(ball_array[i].z/10.)/4.+0.75,sin(ball_array[i].x/10.)/4.+0.75);  \n                vec3 col_add = (8./(dist*dist))*(glow_col+ vec3(sin(-daytime())*0.1))*(1.-sin(daytime()));\n                if(length(col_add) > 0.01){\n                    col += col_add;\n                }\n              \n            }\n        }\n    }\n    \n    \n    if(id != 9.){\n        float fog = 1. - exp(-0.005*0.005 * d * d);\n        col = mix(col, mix(vec3(0.9333,0.286,0.165),vec3(.5, .7, .9),abs(sin(daytime())*sin(daytime())*sin(daytime()))), fog);   //grey fog color : vec3(.5, .7, .9)\n        \n        // lighting using the id\n        float dif = 0.;\n        if(id < 0.5 || id > 3.5 && id < 4.5){dif = 1.;}\n        else{dif = GetLight(p,m);}\n        col *= (dif+0.1)*0.9;   //Shadow Compression\n    }\n    if(id == 11.){\n        col += vec3(0.2,-0.1,-0.1);\n    }\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col); //color compression\n    \n    col = pow(col, vec3(.45)); //gamma\n    return col;\n}\n\n\nvec3 get_color(float id, vec3 p, vec3 ro, vec3 rd, float d, vec2 m, bool lightspots){\n    vec3 col = vec3(0.,0.,1.0);\n    \n    float time_mult = iTime; //speed of the bubbles\n    float y = mod(round(p.x / 12.) * 4. + round(p.z / 18.) * 3. + time_mult - 7., 15.) -3.; // height of ball\n            \n    vec3 pos = vec3(round(p.x / 14.) * 14. + 1., y, round(p.z / 18.) * 18. + 1.); //position of ball\n    \n    //coloring using the id\n    if(id < .5){col = vec3(0.65,0.8,1.);}\n    else if(id < 1.5){\n        float snow_intensity = 2.2;\n        float snow_height_start = 7.0;\n            //plain color and dots    \n            float dis = sqrt((1. - mod(p.x, 2.)) * (1. - mod(p.x, 2.)) + (1. - mod(p.z, 2.)) * (1. - mod(p.z, 2.)));\n            dis *= 2.; dis -= .5;\n            dis = clamp(dis, 0., 1.);\n            if(p.y < snow_height_start +1.){        //only color the dots, if not on a mointain top\n                col = mix(vec3(.5,.8,.2), vec3(.3,.5,.2), dis);\n            }else{\n                col = vec3(.3,.5,.2);\n            }\n            if(length(p.xz) < 12. ){           //sand in the middle\n                col = vec3(1,0.9,0.5)*clamp(Smoothnoise(p.xz*4.),0.3,0.7);\n            }\n        \n        float snow_fade =clamp(p.y- (snow_height_start + sin(p.x)),0.,1.);\n       \n        col += p.y/10. * snow_intensity * snow_fade * vec3(1,1,1);//Snow on mountains \n        \n        \n       \n    }\n    \n    else if(id < 2.5){col = vec3(.5,.8,.2);}\n    else if(id < 3.5){\n        col = mix(vec3(1.44,0.9,0.036),vec3(3.6,1.,0.4), clamp(sdSphere(p, vec3(0,1.,0), 0.1) / 10., 0., 1.));\n    }\n    else if(id < 4.5){\n        vec2 iv = vec2(p.x*0.01,p.z*0.01);\n        float c = get_cloud_value(iv);\n        vec3 star_color = vec3(1);\n        vec3 sky_color = vec3(0.5,0.65,0.99)*clamp((sin(daytime())/2.+0.5),0.,0.8); //babyblue: vec3(0.5,0.65,0.99)    orange: vec3(0.9333,0.286,0.165)\n        col = sky_color   + vec3(c) + basic_stars(floor(iv*1000.)/1000.)*star_color* abs((-sin(daytime())/2.+0.5)-0.1) ; \n        \n        \n         //sun\n        //float light_rot_radius = 40.;\n        //vec2 lightpos = vec2(cos(daytime())*light_rot_radius,sin(daytime())*light_rot_radius);\n        //vec2 sun_center = vec2(lightpos.x/(lightpos.y/15.),0.);\n        //float angle = acos(dot(normalize(lightpos-rd.xy), vec2(1.,0.)));  \n        //float a = tan(-angle + 1.5708)+1.;\n        //float b = 1.;\n        //float ppx = abs(sun_center.x - p.x);\n        //float ppz = abs(sun_center.y - p.z);\n        //if(ppx*ppx/(a*a) + ppz*ppz/(b*b) < 3.){\n        //    col = vec3(1);\n        //}\n        \n        \n    }else if(id < 5.5){\n        col = p.z < 0. ? vec3(1,0,0) : vec3(0,0,1);\n    }else if(id < 6.5){\n        col = vec3(1,1.,0.08)*1.3*clamp(Smoothnoise(p.xz),0.45,0.55);\n    }else if(id<7.5){\n        col = vec3(0.55,0.27,0.07);  //temple posts color\n    }else if(id<8.5){\n        col = vec3(0.9,0.2,0.2);   //temple roof color\n    }else if(id<9.5){// glowing bobble\n  \n        //position is calculated at the top\n        float br = 1.;    //base radius\n        float br_fade = br - br*(clamp(y,6.,12.)-6.)/6.;\n        float wobble_radius = br_fade + 0.6*\n                              ((clamp(y+(sin(pos.x * .1)*cos(pos.z * .2))-br-0.66,0.,0.01)*100.)/ //start of wobble at right height\n                              (clamp(y,1.0,100.) * 10.))* //damping of wobble over time (/height)\n                              (sin(y * 25.) + cos(y * 14.)); //essential Wobble\n        float inner_radius = wobble_radius/8.;\n        \n        vec3 u = ro - pos; // kugel pos\n        float dist_sphere = length(cross(p - ro, u)) / length(u);//abst punkt gerade durch zentrum -> d = |(p-q) x u| /|u|, g=q + s:*u\n        vec3 bg_col = vec3(1);\n        vec2 rm = RayMarch(ro, rd, true);\n        bg_col = (rm.y > 8.5 && rm.y < 9.5) ? vec3(1) : get_color_2(rm.y, ro+rd*rm.x, ro, rd, rm.x, m, lightspots);\n        col = vec3(sin(pos.y)/4.+0.75,sin(pos.z/10.)/4.+0.75,sin(pos.x/10.)/4.+0.75)*smoothstep(0.,1.,(wobble_radius-dist_sphere))+ bg_col;\n    \n    }else if(id == 10.){\n        col = vec3(.8,.8,.8);\n    }\n    \n    if(id != 9. && id != 4. && length(p)<40. && lightspots == true){  //light of bubbles\n        vec3[20] ball_array = get_ball_pos();\n        \n        for(int i = 0; i < 20; i++){\n            if(ball_array[i] != vec3(0)){\n                float dist = length(p-ball_array[i]);\n                vec3 glow_col = vec3(sin(ball_array[i].y)/4.+0.75,sin(ball_array[i].z/10.)/4.+0.75,sin(ball_array[i].x/10.)/4.+0.75);  \n                vec3 col_add = (8./(dist*dist))*(glow_col+ vec3(sin(-daytime())*0.1))*(1.-sin(daytime()));\n                if(length(col_add) > 0.01){\n                    col += col_add;\n                }\n              \n            }\n        }\n    }\n    \n    \n    \n    \n    if(id != 9.){\n        float fog = 1. - exp(-0.005*0.005 * d * d);\n        col = mix(col, mix(vec3(0.9333,0.286,0.165),vec3(.5, .7, .9),abs(sin(daytime())*sin(daytime())*sin(daytime()))), fog);   //grey fog color : vec3(.5, .7, .9)\n        \n        // lighting using the id\n        float dif = 0.;\n        if(id < 0.5 || id > 3.5 && id < 4.5){dif = 1.;}\n        else{dif = GetLight(p,m);}\n        col *= (dif+0.1)*0.9;   //Shadow Compression\n        \n        \n        col = clamp(col,0.0,1.0);\n        col = col*col*(3.0-2.0*col); //color compression\n    \n        col = pow(col, vec3(.45)); //gamma\n        \n    }\n    \n    if(id == 11.){\n        col += vec3(0.2,-0.1,-0.1);\n    }\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy - 0.2; //for default rotation\n    \n    \n    bool lightspots = true;\n   \n\n    vec3 ro = vec3(0, 4, -18);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = R(uv, ro, vec3(0,5,0), .7);  //rotation center\n\n    vec2 rm = RayMarch(ro, rd, false);\n    float d = rm.x; \n    float id = rm.y;\n    vec3 p = ro + rd * d;\n    \n    vec3 col = get_color(id, p, ro, rd, d, m, lightspots);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}