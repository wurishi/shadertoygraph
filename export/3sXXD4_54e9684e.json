{"ver":"0.1","info":{"id":"3sXXD4","date":"1551239880","viewed":187,"name":"noise over time","username":"turnage","description":"noise","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\n#define RGB(r, g, b, a) vec4(vec3(float(r)/255., float(g)/255., float(b)/255.), a)\n#define NO_DISTANCE 10000.\n\n// NOISE IMPL FROM: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#perlin-noise\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = 0.5*(1.-cos(PI*mod(p,unit)/unit));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res, float scale, float lacunarity){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = scale;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p + iTime, f);\n\t\tf*=lacunarity;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf*3.0;\n}\n\nfloat noiseTextureScalar(vec2 p, float distortion, float scale, int detail, float lower) {\n    float distortionTheta = pNoise(p, detail, scale, 2.) * 2. * PI;\n    vec2 distortionOffset = distortion*vec2(cos(distortionTheta), sin(distortionTheta));\n    return abs(pNoise(p + distortionOffset, detail, scale, 2.));\n}\n\nvec4 noiseTexture(vec2 p, float distortion, float scale, int detail, float lower) {\n    return vec4(\n        noiseTextureScalar(p+10000., distortion, scale, detail, lower),\n        noiseTextureScalar(p+20000., distortion, scale, detail, lower),\n        noiseTextureScalar(p, distortion, scale, detail, lower),\n        1.0\n    );\n}\n\n// 4th param should be point on ramp\n#define RAMP_STEPS 6\nvec3 colorRamp(float p, vec4 steps[RAMP_STEPS]) {\n    /*float sum = 0;\n    for (int i = 0; i < RAMP_STEPS; ++i) {\n        sum += 1.0 - abs(steps[i].w - p);\n    }\n    vec3 color = vec3(0.);\n    for (int i = 0; i < RAMP_STEPS; ++i) {\n        color += steps[i].xyz * (1.0 - abs(steps[i].w - p))/sum;\n    }*/\n    vec3 color = mix(steps[0].xyz, steps[1].xyz, smoothstep(steps[0].w, steps[1].w, p));\n    color = mix(color, steps[2].xyz, smoothstep(steps[1].w, steps[2].w, p));\n    color = mix(color, steps[3].xyz, smoothstep(steps[2].w, steps[3].w, p));\n    color = mix(color, steps[4].xyz, smoothstep(steps[3].w, steps[4].w, p));\n    return color;\n}\n\nvec4 christmasNoise(vec2 p) {\n    vec4 c1 = RGB(23, 39, 44, 1.0);\n    vec4 c2 = RGB(27, 85, 82, 1.0);\n    vec4 c3 = RGB(111, 177, 128, 1.0);\n    vec4 c4 = RGB(231, 204, 129, 1.0);\n    vec4 c5 = RGB(228, 98, 65, 1.0);\n\n    vec4 rampColors[RAMP_STEPS];\n    \n    rampColors[0] = RGB(140, 70, 12, 0.1);\n    rampColors[1] = RGB(100, 0, 0, 0.0);\n    rampColors[2] = RGB(198, 73, 69, 0.2);\n    rampColors[3] = RGB(231, 204, 129, 0.7);\n    rampColors[4] = RGB(180, 60, 65, 1.0);\n    rampColors[5] = RGB(0, 0, 0, 2.0);\n  \n\n    vec4 n1 = noiseTexture(p, 0., 0.1 + 0.0001*iTime, 16, 0.0);\n    \n    vec2 samplePoint = n1.xy*iResolution.xy;\n    \n    vec4 n2 = noiseTexture(samplePoint, 10., 8., 16, 0.0);\n    \n    vec4 n3 = noiseTexture(n2.xy*iResolution.xy, 3., 4., 16, 0.0);\n\n    //fragColor = mix(orangeLayer, blueLayer, abs(sin(iGlobalTime/100.)));\n    return vec4(colorRamp(n3.x, rampColors), 1.0);//mix(orangeLayer, blueLayer, abs(sin(iGlobalTime/100.)));//vec4(orangeLayer.x, blueLayer.z, greenLayer.y, 1.0);\n}\n\n\n\nstruct Candidate {\n\tvec4 color;\n\tfloat distance;\n};\n\nbool candidate_passes(Candidate candidate, vec4 color, vec4 us, float dir) {\n\tif (candidate.distance == NO_DISTANCE) {\n\t\treturn true;\n\t}\n\tfloat delta = candidate.distance - length(us - color);\n\treturn delta * dir > 0.;\n}\n\nvec4 layer1(vec2 pos) {\n    return christmasNoise(pos*iResolution.xy);\n}\n\nCandidate consider(vec2 pos, Candidate candidate, vec4 us, float dir) {\n\tvec4 color = layer1(pos);\n\tif (candidate_passes(candidate, color, us, dir)) {\n\t\tcandidate.color = color;\n\t\tcandidate.distance = length(color - us);\n\t}\n\treturn candidate;\n}\n\nvec4 closest_neighbor(vec2 pos, float distance, float dir) {\n\tvec2 unit = vec2(1.0 / iResolution.x, 1.0 / iResolution.y) * distance;\n\tvec4 us = layer1(pos);\n\n\tCandidate candidate;\n\tcandidate.color = us;\n\tcandidate.distance = NO_DISTANCE;\n\n\tcandidate = consider(pos - unit, candidate, us, dir);\n\tcandidate = consider(pos + unit, candidate, us, dir);\n\n\tcandidate = consider(pos + vec2(unit[0], 0), candidate, us, dir);\n\tcandidate = consider(pos + vec2(0, unit[1]), candidate, us, dir);\n\n\tcandidate = consider(pos - vec2(unit[0], 0), candidate, us, dir);\n\tcandidate = consider(pos - vec2(0, unit[1]), candidate, us, dir);\n\n\tcandidate = consider(pos + vec2(-unit[0], unit[1]), candidate, us, dir);\n\tcandidate = consider(pos + vec2(unit[0], -unit[1]), candidate, us, dir);\n\n\treturn candidate.color;\n}\n\nvec4 closest_neighbor_n(vec2 pos, float start, float step, int n, float dir) {\n\tvec4 us = layer1(pos);\n\tCandidate candidate;\n\tcandidate.color = us;\n\tcandidate.distance = NO_DISTANCE;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfloat distance = float(i + 1) * step + sign(step) * start;\n\t\tvec4 color = closest_neighbor(pos, distance, dir);\n\t\tif (candidate_passes(candidate, color, us, dir)) {\n\t\t\tcandidate.color = color;\n\t\t\tcandidate.distance = length(color - us);\n\t\t}\n\t}\n\n\treturn candidate.color;\n}\nvec4 layer3(vec2 uv) {\n    float start = 0.05;\n    float step = 0.0000005;\n    int steps = 5;\n    return closest_neighbor_n(uv, iResolution.x * start, iResolution.x * step, steps, -1.);\n}\n\nvec2 domainWarp(vec2 fragCoord) {\n    float scale = abs(pNoise(fragCoord, 4, 4., 2.))*1000.;\n    vec2 off = vec2(pNoise(fragCoord, 3, 4., 2.) * scale, pNoise(-1.0 * fragCoord, 3, 4., 2.)*scale);\n    return fragCoord + off;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = layer1(domainWarp(fragCoord/iResolution.xy));\n}","name":"Image","description":"","type":"image"}]}