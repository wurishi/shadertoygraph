{"ver":"0.1","info":{"id":"WlX3RM","date":"1555830125","viewed":179,"name":"Cartoon shade","username":"Kua256","description":"cartoon shade","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float sphereSize = 1.0;\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nvec3 hsv2rgb(vec3 c)\n{\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n  return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n              a.x * a.x * r + c,  a.y * a.x * r + a.z * s,  a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,        a.y * a.y * r + c,  a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,  a.y * a.z * r - a.x * s,  a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sub(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat distanceFunc(vec3 p)\n{\n    float d1 = box(rotate(p, iTime * 0.3, vec3(1.0, 0.5, 1.0)), vec3(0.5));\n    float d2 = sphere(p, 0.65);\n    float d3 = torus(rotate(p, iTime, vec3(1.0, 0.5, 0.0)), vec2(0.7, 0.2));\n    float d4 = sub(d2, d1);\n    \n    int pair = int(floor(mod(iTime * 0.5, 4.0)));\n    float a = smoothstep(0.2, 0.7, mod(iTime * 0.5, 1.0));\n    \n    if(pair == 0) return mix(d1, d2, a);\n    if(pair == 1) return mix(d2, d3, a);\n    if(pair == 2) return mix(d3, d4, a);\n    else\t\t  return mix(d4, d1, a);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceFunc(pos + vec3(  d, 0.0, 0.0)) - distanceFunc(pos + vec3( -d, 0.0, 0.0)),\n        distanceFunc(pos + vec3(0.0,   d, 0.0)) - distanceFunc(pos + vec3(0.0,  -d, 0.0)),\n        distanceFunc(pos + vec3(0.0, 0.0,   d)) - distanceFunc(pos + vec3(0.0, 0.0,  -d))));\n}\n\nfloat circle(vec2 pos)\n{\n    return length(pos);\n}\n\nfloat square(vec2 pos)\n{\n  vec2 a = pow(abs(pos), vec2(1.0));\n  return pow(a.x + a.y, 1.0);\n}\n\nfloat heart(vec2 pos)\n{\n\tpos = (pos - vec2(0.5, 0.48)) * vec2(2.1, -2.8);\n\n\treturn pow(pos.x, 2.0) + pow(pos.y - sqrt(abs(pos.x)), 2.0);\n}\n\nfloat create2DShape(vec2 pos)\n{\n    pos = vec2(0.5) - pos;\n    float s1 = circle(pos);\n    float s2 = square(pos);\n    float s3 = heart(pos + vec2(0.5));\n    \n    int pair = int(floor(mod(iTime, 3.0)));\n    float a = smoothstep(0.2, 0.7, mod(iTime, 1.0));\n    \n    if(pair == 0) return mix(s1, s2, a);\n    if(pair == 1) return mix(s2, s3, a);\n    else\t\t  return mix(s3, s1, a);\n}\n\nfloat createScreenTone(vec2 pos, float NdotL)\n{\n    float iNdotL = 1.0 - NdotL;\n    iNdotL *= 0.5;\n                \n    pos = pos * 50.0 * iNdotL;\n    pos.x += step(1.0, mod(pos.y, 2.0)) * 0.5;\n    pos = fract(pos);\n\n    float r = 0.7 * iNdotL;\n    return smoothstep(r, r + 0.15, create2DShape(pos));\n}\n\nvec4 render(vec2 pos)\n{\n    vec3 cPos = vec3(0.0,  0.0,  1.25);\n    vec3 cDir = vec3(0.0,  0.0, -1.0);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    vec3 ray = normalize(cSide * pos.x + cUp * pos.y + cDir * targetDepth);\n    \n    float d = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < 32; ++i)\n    {\n        d = distanceFunc(rPos);\n        rLen += d;\n        rPos = cPos + ray * rLen;\n    }\n    \n    if(abs(d) < 0.001)\n    {\n        vec3 normal = getNormal(rPos);\n        float nDotL = dot(lightDir + vec3(acos(cos(iTime * 0.7)), 0.0, 0.0), normal);\n\t\tnDotL = nDotL > 0.65 ? 1.0 \n\t\t\t: nDotL > 0.3 ? 0.5\n\t\t\t: 0.1;\n        \n\t\tfloat tone = createScreenTone(pos, nDotL);\n        vec3 hsv = vec3(abs(sin(iTime * 0.5)), 1.0, 0.7);\n\t\tvec3 color = mix(hsv2rgb(hsv), vec3(1.0), tone);\n        \n        return vec4(color, 1.0);\n    }\n    else\n    {\n        pos = pos + vec2(0.5);\n        pos = fract(pos * 2.0);\n        return vec4(vec4(0.3) - step(0.1, 0.4 * create2DShape(pos)));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) \n        / min(iResolution.x, iResolution.y);\n\n    vec4 color = vec4(0);\n    const int iter = 3;\n    for(int i = 1; i <= iter; ++i)\n    {\n        float fi = float(i);\n        vec2 offset = (vec2(step(fi, 2.0), mod(fi, 2.0)) - 0.5) * 0.005;\n        color += render(uv + offset);\n    }\n\n    color /= float(iter);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}