{"ver":"0.1","info":{"id":"Mc3BWM","date":"1733161817","viewed":119,"name":"Raymarchin Cel Shading 0 - DJ","username":"DjBlueBear","description":"Cel Shader\n#define celshade to turn on/off Cel Shading\n#define outline to turn on/off the Outlines\nIt looks kinda funky with multiple light sources","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","rendering"],"hasliked":0,"parentid":"MctfR8","parentname":"Raymarchin 6 - DJ"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 outLineColor = vec3(0.0, 0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 buffer1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 buffer2 = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 buffer3 = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    #ifdef renderposition\n    fragColor = buffer2;\n    return;\n    #else\n    #ifdef rendernormal\n    fragColor = buffer3;\n    return;\n    #else\n    #ifdef renderdepth\n    fragColor = vec4(vec3(10.0 / buffer2.w),1.0);\n    return;\n    #endif\n    #endif\n    #endif\n    \n    #ifdef outline\n    fragColor = buffer1.xyz == vec3(1.0) ? vec4(outLineColor,1.0) : buffer0;\n    #else\n    fragColor = buffer0;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define celshade\n//^^ comment out to remove cel shading\n#define outline\n//^^ comment out to remove outlines\n//#define renderposition\n//#define rendernormal\n//#define renderdepth\n#define skybox\n\nconst float PI = 3.14159265;\nconst float E = 2.71828182846;\n\nconst float DEG2RAD = PI / 180.0;\n\nvec3 cameraPosition = vec3(0.0,2.0,-20.0);\nvec3 cameraLooking = normalize(vec3(0.0, 0.0, 1.0));\nconst float FOV = 65.0;\n\nconst float RAYMARCH_MAX_DISTANCE = 1000.0;\nconst float RAYMARCH_MIN_DISTANCE = 0.01;\nconst int RAYMARCH_MAX_ITERATIONS = 256;\n\nconst float BOUNDING_SPHERE_MIN_DIST = 0.1;//keep greater than RAYMARCH_MIN_DISTANCE (causes cool artifacts)\n//i'm not sure what the best value is for this number ^^ (it's for performance)\nstruct Material {\n    vec3 color;\n    float smoothness;\n};\n\nstruct Object {\n    vec3 position;\n    vec3 size;\n    Material material;\n    uint shape;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float brightness;\n};\n\nconst Material defaultMaterial = Material(vec3(0.9,0.9,0.9), 0.75);\nconst Material red = Material(vec3(1.0,0.25,0.25), 0.25);\nconst Material green = Material(vec3(0.25,1.0,0.25), 0.25);\nconst Material blue = Material(vec3(0.25,0.25,1.0), 0.25);\n\n//position size material shape\nconst Object[4] objectList = Object[](\n    Object(vec3(0.0,1.0,0.0), vec3(3.0,0.0,0.0), defaultMaterial, 2u),\n    Object(vec3(-6,-1.0,0.0), vec3(2.0,2.0,2.0), red, 1u),\n    Object(vec3(0.0,-2.0,0.0),vec3(2.0,1.0,2.0), green, 3u),\n    Object(vec3(6.0,-1.0,0.0), vec3(2.0,0.5,1.0), blue, 0u)\n);\n\nconst Light[1] lightList = Light[](\n    Light(vec3(0.0,4.0,-5.0), vec3(1.0,1.0,1.0), 64.0)\n);\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r)\n{\n    vec3 q = p - c;\n    return length(q) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 c,in vec3 b )\n{\n  vec3 q = abs(p - c) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(in vec3 p, in vec3 c, in vec2 t )\n{\n  p -= c;\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat mapObject(vec3 point, Object obj)\n{\n    switch(obj.shape)\n    {\n        case 0u:\n        {\n            return sdSphere(point, obj.position, obj.size.x);\n        }\n        case 1u:\n        {\n            float boundingSphere = sdSphere(point, obj.position, max(max(obj.size.x,obj.size.y),obj.size.z) * 2.0);\n            //since the SDF of a sphere is much cheaper than that of a box or other shape\n            //instead of calculating the SDF of the original object it calculates the SDF of the sphere\n            //that contains that object when the ray is far enough away\n            if(boundingSphere < BOUNDING_SPHERE_MIN_DIST)\n            {\n                return sdBox(point, obj.position, obj.size.xyz);\n            }\n            else\n            {\n                return boundingSphere;\n            }\n            break;\n        }\n        case 2u:\n        {\n            return sdPlane(point, obj.position, obj.size.x);\n        }\n        case 3u:\n        {\n            float boundingSphere = sdSphere(point, obj.position, obj.size.x + obj.size.y);\n            \n            if(boundingSphere < BOUNDING_SPHERE_MIN_DIST)\n            {\n                return sdTorus(point, obj.position, obj.size.xy);\n            }\n            else\n            {\n                return boundingSphere;\n            }\n        }\n        case 4u:\n        {\n            float boundingSphere = sdSphere(point, obj.position, obj.size.x);\n            \n            if(boundingSphere < BOUNDING_SPHERE_MIN_DIST)\n            {\n                return sdOctahedron(point - obj.position, obj.size.x);\n            }\n            else\n            {\n                return boundingSphere;\n            }\n        }\n    }\n    \n    return RAYMARCH_MAX_DISTANCE;\n}\n\nfloat mapWorld(in vec3 point)\n{\n    float minDist = RAYMARCH_MAX_DISTANCE;\n    \n    for(int i=0; i<objectList.length(); i++)\n    {\n        float objDist = mapObject(point, objectList[i]);\n        \n        if(objDist < minDist)\n        {\n            minDist = objDist;\n            \n            if(objDist < RAYMARCH_MIN_DISTANCE)\n            {\n                break;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nfloat mapWorld(in vec3 point, out Object obj)\n{\n    float minDist = RAYMARCH_MAX_DISTANCE;\n    \n    for(int i=0; i<objectList.length(); i++)\n    {\n        float objDist = mapObject(point, objectList[i]);\n        \n        if(objDist < minDist)\n        {\n            minDist = objDist;\n            obj = objectList[i];\n            \n            if(objDist < RAYMARCH_MIN_DISTANCE)\n            {\n                break;\n            }\n        }\n    }\n    \n    return minDist;\n}//returns the nearest object aswell\n\nvec3 calcNormal(in vec3 p)\n{\n  const vec3 small_step = vec3(0.0001, 0.0, 0.0);\n  \n  float grad_x = mapWorld(p + small_step.xyy) - mapWorld(p - small_step.xyy);\n  float grad_y = mapWorld(p + small_step.yxy) - mapWorld(p - small_step.yxy);\n  float grad_z = mapWorld(p + small_step.yyx) - mapWorld(p - small_step.yyx);\n\n  vec3 normal = vec3(grad_x, grad_y, grad_z);\n\n  return normalize(normal);\n}\n\nvec3 raymarch(in vec3 origin, in vec3 direction, out bool hit)\n{\n    hit = false;\n    \n    direction = normalize(direction);\n    \n    float totalDistance = 0.0;\n    \n    vec3 position;\n    \n    for(int i=0; i<RAYMARCH_MAX_ITERATIONS; i++)\n    {\n        position = origin + direction * totalDistance;\n        \n        float dist = mapWorld(position);\n        \n        if(dist < RAYMARCH_MIN_DISTANCE)\n        {\n            hit = true;\n            \n            return position;\n        }\n        else if(dist > RAYMARCH_MAX_DISTANCE)\n        {\n            break;\n        }\n        totalDistance += dist;\n    }\n    \n    return position;\n}\n\nvec3 raymarch(in vec3 origin, in vec3 direction, in float maxDist, out bool hit)\n{\n    hit = false;\n    \n    direction = normalize(direction);\n    \n    float totalDistance = 0.0;\n    \n    vec3 position;\n    \n    for(int i=0; i<RAYMARCH_MAX_ITERATIONS; i++)\n    {\n        position = origin + direction * totalDistance;\n        \n        float dist = mapWorld(position);\n        \n        if(dist < RAYMARCH_MIN_DISTANCE)\n        {\n            hit = true;\n            \n            return position;\n        }\n        else if(dist > RAYMARCH_MAX_DISTANCE || totalDistance + dist >= maxDist)//INACCURATE (only slightly) (ray stops barley before maxDist)\n        {\n            break;\n        }\n        totalDistance += dist;\n    }\n    \n    return position;\n}\n\nvec3 raymarch(in vec3 origin, in vec3 direction, out bool hit, out Object obj)\n{\n    hit = false;\n    \n    direction = normalize(direction);\n    \n    float totalDistance = 0.0;\n    \n    vec3 position;\n    \n    for(int i=0; i<RAYMARCH_MAX_ITERATIONS; i++)\n    {\n        position = origin + direction * totalDistance;\n        \n        float dist = mapWorld(position, obj);\n        \n        if(dist < RAYMARCH_MIN_DISTANCE)\n        {\n            hit = true;\n            \n            return position;\n        }\n        else if(dist > RAYMARCH_MAX_DISTANCE)\n        {\n            break;\n        }\n        totalDistance += dist;\n    }\n    \n    return position;\n}\n\nvec3 raymarch(in vec3 origin, in vec3 direction, out float totalDistance)\n{\n    direction = normalize(direction);\n    \n    totalDistance = 0.0;\n    \n    for(int i=0; i<RAYMARCH_MAX_ITERATIONS; i++)\n    {\n        vec3 position = origin + direction * totalDistance;\n        \n        float dist = mapWorld(position);\n        \n        if(dist < RAYMARCH_MIN_DISTANCE)\n        {\n            return position;\n        }\n        else if(dist > RAYMARCH_MAX_DISTANCE)\n        {\n            break;\n        }\n        \n        totalDistance += dist;\n    }\n    \n    totalDistance = RAYMARCH_MAX_DISTANCE + 1.0;\n    \n    return vec3(0.0);\n}\n\nvec2 calcScreenSpaceUV(in vec2 fragCoord, in vec2 iResolution)\n{\n    return fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y / 2.0,0.5);\n}\n\nvec3 calcRayDir(in vec2 uv)\n{\n    return normalize(vec3(uv,0.0) * tan(DEG2RAD * FOV / 2.0) + cameraLooking);\n}\n\nvec3 calcNormalEdge(in vec3 p)\n{\n    float dist = mapWorld(p);\n    \n    if(dist > 1.0)\n    {\n        return vec3(0.0);\n    }\n    return calcNormal(p);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cameraPosition = vec3(sin(iTime)*4.0, cos(iTime)+1.0, cameraPosition.z);\n    vec2 uv = calcScreenSpaceUV(fragCoord, iResolution.xy);\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDir = calcRayDir(uv);;//not good math stupid bad incorrect inaccurate not even working type shit\n    float dist;\n    vec3 color = raymarch(rayOrigin, rayDir, dist);\n    fragColor = vec4(color, dist);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"const vec3 sunDir = normalize(vec3(0.0,10.0,300.0));\nconst vec3 SUN_COLOR = vec3(1.0,0.98,0.96);\nconst float SUN_RADIUS = 0.10;\n\nconst float ATMOSPHERE_HEIGHT = 400.0;\n\nconst float PLANET_RADIUS = 1000.0;\n\nconst float scatterStrength = 1.0;\n\nconst vec3 wave = vec3(700,530,440);\nconst vec3 scatter = pow(400.0 / wave, vec3(4.0)) * scatterStrength;\n\n//.y returns the length of the line between the intersection point of the ray(point, dir) with the sphere(center, radius)\nvec2 raySphere(in vec3 center, in float radius, in vec3 origin, in vec3 dir)\n{\n\n    vec3 offset = origin - center;\n    float a = dot(dir,dir);\n    float b = 2.0 * dot(offset, dir);\n    float c = dot(offset, offset) - radius * radius;\n    \n    float discriminant = b*b-4.0*a*c;\n    \n    \n    if(discriminant > 0.0)\n    {\n        float s = sqrt(discriminant);\n        float distToSphereNear = max(0.0, (-b - s) / (2.0 * a));\n        float distToSphereFar = (-b + s) / (2.0 * a);\n        \n        if(distToSphereFar >= 0.0) \n        {\n            return vec2(distToSphereNear, distToSphereFar - distToSphereNear);\n        }\n     }\n     \n     //ray did not intersect sphere\n     return vec2(10000.0,0.0);\n}\n\nvec3 distance2color(in float dist)\n{\n    return dist * scatter / PLANET_RADIUS;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    #ifndef skybox\n    discard;\n    #endif\n    float atmosphere = raySphere(vec3(0.0,-PLANET_RADIUS,0.0),PLANET_RADIUS+ATMOSPHERE_HEIGHT,vec3(0.0),rayDir).y;\n    vec3 color = distance2color(atmosphere);\n    vec3 sun = SUN_COLOR / (1.0 + pow(distance(normalize(sunDir), rayDir),2.0) * 4.0 / SUN_RADIUS) / atmosphere * 400.0;\n    color += sun;\n    fragColor = vec4(color, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(calcNormalEdge(buffer0.xyz),1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float root3 = sqrt(3.0);\n\nvec3 mapSkybox(in vec3 dir)\n{\n    #ifdef skybox\n    return texture(iChannel3, dir).xyz;\n    #else\n    return vec3(0.0);\n    #endif\n}\n\nfloat normalFunc(in float x)\n{\n    return pow(E,-pow(x,2.0));\n}\n\nfloat quantize(in float value, in float resolution)\n{\n    return round(value * resolution) / resolution;\n}\n\nvec3 quantize(in vec3 value, in float resolution)\n{\n    return round(value * resolution) / resolution;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);//positions, distance\n    vec4 buffer1 = texelFetch(iChannel1, ivec2(fragCoord), 0);//normals\n    \n    vec2 uv = calcScreenSpaceUV(fragCoord, iResolution.xy);\n    vec3 rayDir = calcRayDir(uv);\n    \n    vec3 color = vec3(0.0);\n    \n    if(buffer0.w < RAYMARCH_MAX_DISTANCE)\n    {\n        Object obj;\n        mapWorld(buffer0.xyz,obj);\n            \n        for(int i=0; i<lightList.length(); i++)\n        {\n            Light light = lightList[i];\n            \n            vec3 lightDir = light.position - buffer0.xyz;\n            \n            float lightDist = length(lightDir);\n            \n            lightDir = normalize(lightDir);\n            \n            float lightDot = dot(buffer1.xyz,lightDir);\n            \n            if(lightDot <= 0.0)\n            {\n                continue;\n            }\n            \n            vec3 addColor = vec3(0.0);\n            \n            bool inShadow;\n            raymarch(buffer0.xyz + buffer1.xyz * 0.1, lightDir, lightDist, inShadow);\n            \n            if(!inShadow)\n            {\n                float lightFacing = max(lightDot,0.0);\n            \n                addColor += light.brightness * obj.material.color * light.color * lightFacing / pow(lightDist,2.0);\n            }\n            \n            color += addColor;\n        }\n        \n        color += mapSkybox(reflect(rayDir, buffer1.xyz)) * obj.material.smoothness * obj.material.color;\n    }\n    else\n    {\n        color += mapSkybox(rayDir);\n    }\n    \n    #ifdef celshade\n    if(length(color) > 2.0 * root3)\n    {\n        color = normalize(color) * 2.0 * root3;\n    }\n    else if(length(color) > root3)\n    {\n        color = normalize(color) * root3;\n    }\n    else if(length(color) > root3 / 2.0)\n    {\n        color = normalize(color) * root3 / 2.0;\n    }\n    else if(length(color) > root3 / 4.0)\n    {\n         color = normalize(color) * root3 / 4.0;\n    }\n    else if(length(color) > root3 / 8.0)\n    {\n        color = normalize(color) * root3 / 8.0;\n    }\n    else\n    {\n        color = vec3(0.0);\n    }\n    #endif\n    fragColor = vec4(color,0.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const vec3 outLineColor = vec3(1.0);//keep 1.0\nconst vec3 nonOutLineColor = vec3(0.0);//keep 0.0\n\nconst int kernalRadius = 1;//outline thickness (best at 1)\n//calculates edges using normals and depth maps\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 buffer1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    if(buffer0.xyz == vec3(0.0))\n    {\n        fragColor = vec4(nonOutLineColor,1.0);\n        return;\n    }\n    \n    for(int y=-kernalRadius; y<=kernalRadius; y++)\n    {\n        for(int x=-kernalRadius; x<=kernalRadius; x++)\n        {\n            vec4 texel0 = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(x,y), 0);\n            vec4 texel1 = texelFetch(iChannel1, ivec2(fragCoord) + ivec2(x,y), 0);\n            \n            if(dot(buffer1.xyz, texel1.xyz) < 0.9)\n            {\n                fragColor = vec4(outLineColor,1.0);\n                return;\n            }//if the normals are too different\n            \n            if(abs(buffer0.w - texel0.w) / buffer0.w > 0.25)\n            {\n                fragColor = vec4(outLineColor,1.0);\n                return;\n            }//if the depth is too different\n        }\n    }\n    \n    fragColor = vec4(nonOutLineColor, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}