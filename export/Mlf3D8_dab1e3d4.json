{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":2,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//// input\n// keys\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77;\nint kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n// TOGGLES:\nint kRed = 49;\nint kGreen = 50;\nint kBlue = 51;\n\nfloat lodBias = -2.2;\nfloat time = 0.;\n\nfloat PI = 3.14159;\nfloat TAO = 2.0 * 3.14159;\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKeyBool( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat ReadKeyFloat( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn step(.5,keyVal);\n}\n\n\n//// convert screen/mouse coords to -asp to +asp for x (to the right), -1 to +1 for y (to the top), asp = aspect ratio \n// normalized device coords\nvec2 ndc(vec2 p)\n{\n    p *= 2.0/iResolution.y;\n    p += vec2(-iResolution.x/iResolution.y,-1.0);\n\treturn p;\n}\n\n//// convert screen/mouse coords to -1 to +1 for x (to the right), -1 to +1 for y (to the top), asp = assumed to be 1.0\n// normalized device coords\nvec2 ndc_noasp(vec2 p)\n{\n    p *= vec2(2.0/iResolution.x,2.0/iResolution.y);\n    p += -1.;\n\treturn p;\n}\n\n// generate a 2d rotation matrix\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 Rotate(vec2 v, float angle)\n{\n    return v*rot(angle);\n}\n\nvec2 Kaleido(vec2 v,float power)\n{\n    return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);\n    //return vec2(0.1,0.1);\n}\n\n\n//// raytrace plane\n// return color of plane at xyz, this plane is at y = 0\nvec3 planeColor(vec3 loc,bool pc)\n{\n    loc *= 10.;\n    vec2 loct = loc.xz * vec2(.1,-.1);\n    vec3 ret3 = texture(iChannel2,loct,lodBias).xyz;\n    if (pc) {\n        if (loc.x >= 0.0)\n        \tret3.r += .25;\n    \tif (loc.z >= 0.0)\n        \tret3.b += .25;\n        if (fract(loc.x*.05) >= .5)\n            ret3.r -= .15;\n        if (fract(loc.z*.05) >= .5)\n            ret3.g -= .15;\n\t    vec2 loc2 = loct;\n        if (fract(loc2.x*.05) >= .5)\n            ret3.b -= .45;\n        if (fract(loc2.y*.05) >= .5)\n            ret3.g -= .45;\n    }\n\treturn ret3;\n}\n\n\n//// sky and plane\nvec3 skyPlane(vec3 rs,vec3 rd,bool planeaxis) // unnormalized direction\n{\n// sky color\n    vec3 skycolor = vec3(0.0,0.0,1.0) - vec3(0.0,0.0,rd.y);\n    \n    // plane color\n    float t = -rs.y/rd.y;\n    vec3 isect = rs + rd*t;\n    vec3 planecolor = planeColor(isect,planeaxis);\n    \n    vec3 skyplanecolor;\n    if (rd.y >= 0.0 || rs.y < 0.0)\n        skyplanecolor = skycolor;\n    else\n        skyplanecolor = planecolor;\n    return skyplanecolor;\n}\n\n\n//// raymarch\nvec3 sceneCol;\n\n// some lighting\nconst vec3 light_1d     = vec3(0.0,0.0,1.0);\nconst vec3 light_2d     = vec3(-.7071,0.0,.7071);\n\nvec3 shade(vec3 color, vec3 point, vec3 normal,vec3 rd)\n{\n\t//vec3 dtl       = normalize(light_1 - point);\n   \tvec3 dtl = -light_1d;\n\tfloat diffuse  = dot(dtl, normal); //diffuse\n\tfloat specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //specular\n\tvec3 c = (diffuse + specular) * color * 0.85;\n\t\n\t//dtl      =  normalize(light_2 - point);\n    dtl = -light_2d;\n\tdiffuse  = dot(dtl, normal); //more diffuse\n\tspecular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 256.0); //more specular\n\treturn clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);\n}\n\nvec3 getTex(vec3 p)\n{\n\tp = fract(p);\n    //p.xy *= rot(iTime*.5);\n    //p.xz *= rot(iTime*.25);\n    return p;\n    //return vec3(1.0);\n}\n\n\n\n\n//// primitives\n\nfloat sdSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p,vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// h.x = radius h.y = height\nfloat sdCappedCylinder(vec3 p,vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// c.xy is the position if xz, c.z is the radius\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,-p.z));\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xy), -p.z );\n#if 0\n\treturn max( max( dot(q,c.xy), -p.z), p.z-c.z );\n#else\n    float d1 = p.z-c.z;\n    float d2 = max( dot(q,c.xy), -p.z);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif    \n}\n\n// n.w is the distance from origin to the plane P*N = D\nfloat sdPlane(vec3 p,vec4 n)\n{\n  // n.xyz must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n\n\n//// CSG\n\n// CSG Union d1 U d2\nfloat opU(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// CSG Intersection d1 ^ d2\nfloat opI(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// CSG union like, blend d1 B d2\nfloat opUBlend(float d1,float d2,float k)\n{\n\tfloat h = clamp(.5 + .5*(d2 - d1)/k,0.,1.);\n    return mix(d2,d1,h)-k*h*(1.0-h);\n    //return d2;\n    //return min(d1,d2);\n}\n\n// CSG Subtract d1 - d2\nfloat opS(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\n\n\n\n//// sample scene buildup\n\n// move selected parts of scene with sceneOffset\n#define MOVESCENE\n#ifdef MOVESCENE\nvec3 sceneOffset = vec3(0.,0.,5.);\n#endif\n\n//// the cones tree scene\n\n// some test scene for trying out fractals ( folding )\nfloat scene_pat(vec3 p)\n{\n#ifdef MOVESCENE\n    p += sceneOffset;\n#endif\n    //vec3 pr = p + vec3(-4.5,-2.0,-4.5);\n    vec3 pr = p + vec3(.5,-2.0,.5);\n    pr.yz *= rot(PI*.625);\n\tfloat o1 = sdCappedCone(pr,vec3(12.0/13.0,5.0/13.0,2.0));\n    \n    pr = p + vec3(-.5,-2.0,.5);\n\tfloat o2 = sdBox(pr,vec3(2.*.4,2.*.9,2.*.1));\n    \n    pr = p + vec3(.5,-2.0,-.5);\n    pr.xz *= rot(PI*.125);\n\tfloat o3 = sdCappedCone(pr,vec3(12.0/13.0,5.0/13.0,2.0));\n    \n    pr = p + vec3(-.5,-2.0,-.5);\n    pr.yz *= rot(PI*.5);\n\tfloat o4 = sdCappedCone(pr,vec3(12.0/13.0,5.0/13.0,2.0));\n    \n    pr = p + vec3(0.0,-2.0,0.0);\n\tfloat o5 = sdTorus(pr,vec2(1.,.5));\n    \n    return opU(opU(opU(opU(o1,o2),o3),o4),o5);\n}\n\n// normal cone\nfloat scene_cone1(vec3 p)\n{\n   //p.xz =  Kaleido(p.xz,4.0);\n   //p.x = abs(p.x);\n//#ifdef MOVESCENE\n//   \tp += sceneOffset;\n//#endif\n    p += vec3(0.0,0.,7.5);\n    //p.yz *= rot(PI*.5);\n    return sdCappedCone(p,vec3(264.0/265.0,23.0/265.0,7.5));\n}\n\n// offset cone\nfloat scene_cone2(vec3 p)\n{\n    p += vec3(3.0,-2.0,0.0);\n    p.yz *= rot(PI*.5);\n    return sdCappedCone(p,vec3(12.0/13.0,5.0/13.0,2.0));\n}\n\n// normal rep pattern\nfloat opRep_scene_cone(vec3 p,vec3 c)\n{\n    vec3 q = mod(p+.5*c,c)-.5*c;\n    return scene_cone1(q);\n    //return scene_cone2(q);\n}\n\n\n// normal rep pattern 2D XZ\nfloat opRepXZ_scene_cone(vec3 p,vec3 c)\n{\n    //p.xz = mod(p.xz+.5*c.xz,c.xz)-.5*c.xz;\n    return scene_cone1(p);\n}\n\n\n\n// some kind of fractal pattern\nfloat opRepTree_scene_cone(vec3 p,vec3 c)\n{\n   \tfloat scl = .5;\n    float sclpow = 1.;\n    float sc;\n    float sym = 5.0;\n    p.xz = Kaleido(p.xz,sym);\n    float d = scene_cone1(p);\n\tfor (int i=0;i<6;++i) {\n#ifdef MOVESCENE\n        p += sceneOffset;\n#endif\n        p *= 1./scl;\n        sclpow *= scl;\n\t\tp.xz = Kaleido(p.xz,sym);\n        sc = scene_cone1(p) * sclpow;\n        d = opU(d,sc);\n//    \tp.z += 5.0;\n    }\n   \n    //p.xz = Kaleido(p.xz,4.0);\n    \n    return d;\n    //return opU(scene_cone1(p) * sclpow,sc);\n}\n\n#if 0\nfloat opRepTree_scene_cone(vec3 p,vec3 c)\n{\n\tfloat scl = .5;\n    float off = 5.;\n    p.xz = Kaleido(p.xz,4.0);\n    p.z += off\n    p *= 1./scl;\n    p.xz = Kaleido(p.xz,4.0);\n    return scene_cone1(p) * scl;\n}\n#endif\n\n// mirrorX pattern\nfloat opMirrorX_scene_pat(vec3 p)\n{\n    vec3 pm = p;\n    pm.x = abs(p.x);\n    return scene_pat(pm);\n}\n\n// Kaleido pattern\nfloat opKaleido_scene_pat(vec3 p)\n{\n    vec3 pm = p;\n\tpm.xz = Kaleido(p.xz,11.0);\n    return scene_pat(pm);\n}\n\n// Kaleido pattern\nfloat opKaleido_scene_cone(vec3 p)\n{\n    vec3 pm = p;\n\tpm.xz = Kaleido(p.xz,4.0);\n    return scene_cone1(pm);\n}\n\n\n//// some reference spheres\n\nfloat scene_spheres(vec3 p)\n{\n    vec3 pr = p + vec3(10.0,0.0,0.0);\n    float sph1 = sdSphere(pr,1.0);\n    pr = p + vec3(0.0,0.0,10.0);\n    float sph2 = sdSphere(pr,1.0);\n    pr = p + vec3(-10.0,0.0,0.0);\n    float sph3 = sdSphere(pr,1.0);\n    return opU(sph1,opU(sph2,sph3));\n\n}\n\n\n\n\n\n//// the main scene\n\nfloat scene(vec3 p)\n{\n    //float cones = opRepXZ_scene_cone(p,vec3(10.0,10.0,10.0));\n    float cones = opRepTree_scene_cone(p,vec3(10.0,10.0,10.0));\n    //float pat = opMirrorX_scene_pat(p);\n    //float pat = opKaleido_scene_pat(p);\n    //float pat = opRepTree_scene_cone(p,vec3(0.));\n    float spheres = scene_spheres(p);\n    //return opU(pat,spheres);\n    //return spheres;\n    return opU(cones,spheres);\n}\n\n\n\n\n\n// process the main scene\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = .001;\n    float d0x = scene(vec3(p.x - eps,p.yz));\n    float d1x = scene(vec3(p.x + eps,p.yz));\n    float d0y = scene(vec3(p.x,p.y - eps,p.z));\n    float d1y = scene(vec3(p.x,p.y + eps,p.z));\n    float d0z = scene(vec3(p.xy,p.z - eps));\n    float d1z = scene(vec3(p.xy,p.z + eps));\n    //return vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(.5/eps);\n    //return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(2.5/eps));\n    return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z));\n    //return vec3(1.0,0.0,0.0);\n}\n    \n// very simple ambient occlusion\nfloat getAO(vec3 rs,vec3 rd)\n{\n    // move away along the normal\n    float d = .3;\n    float k = 1.0;\n    float ret = 1.0;\n    for (int i = 1;i<5;++i) {\n        float fi = float(i);\n        k *= .5;\n        float distBack = scene(rs + rd*(d*fi));\n        ret -= k*(fi*d - distBack);\n    }\n    return ret;\n    //return 1.0;\n    //return distBack/k;\n    //return k/distBack;\n}\n\nvec3 march(vec3 rs,vec3 rd,out bool hit)\n{\n    const float conserve = .57;//1.0; // .87; // compensate for errors in distance function esp. rotate box repeat\n    const int steps = 150;\n    float eps = .001;\n    float toobig = 1000.0;\n\tvec3 col = vec3(0.0,0.0,0.0);\n    hit = false;\n    for (int i=0;i<steps;++i) {\n        float d = scene(rs);\n        if (d > toobig) { // bail early if clearly can't hit anything\n            hit = false;\n            break;\n        }\n        if (d < eps) {\n            //if (true) {\n            if (rs.y >= 0.0) { // hit above ground\n                vec3 norm = getNormal(rs);\n \t\t\t\t// normal color, very simple lighting .5 ambient, .5 directional\n \t\t\t\t// normal in opposite direction of light gets the light\n                //col += max(-norm.x,0.0)*.5+.5; // dir +1x\n                //col += max(norm.y,0.0)*.5+.5; // dir -1y\n                //col += max(-norm.z,0.0)*.5+.5; // dir +1z\n                //col += -norm.z; // dir +1z, no ambient all directional\n                col += shade(vec3(1.),rs,norm,rd)*.9;\n\t\t\t\tcol += sceneCol*.1;\n                //col += getTex(rs); // texture color\n                //col += norm*.5 + vec3(.5); // normal color 0 to 1\n                //col += norm; // raw normal color -1 to 1\n    \t\t\t//col += float(i)*(10.0/256.0); // brighter if more iterations\n                float ao = getAO(rs,norm);\n                col *= ao;\n                hit = true;\n            }\n            break;\n        }\n        rs += rd*d*conserve; // compensate for the slight error from rotating boxes distance modulo function\n    }\n\n    return col;\n}\n\n//// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool roll = ReadKeyBool(k1,true);\n    bool planeaxis = !ReadKeyBool(k2,true);\n    bool movexy = ReadKeyBool(k3,true);\n    bool moveobj = ReadKeyBool(k4,true);\n\n    // ndc\n    vec2 pos = ndc(fragCoord.xy);\n    //vec2 pos = ndc_noasp(fragCoord.xy);\n    vec2 mouse;// = vec2(0.0,0.0);\n    \n    if (iMouse.x == 0.0) // hack for mouse not yet clicked\n        mouse = vec2(0.0,-.45);\n    else\n    \tmouse = ndc(iMouse.xy);\n    \n    // keyboard color, for circle (press 1,2,3)\n    vec3 keycolor = vec3(ReadKeyFloat(kRed,true),\n             ReadKeyFloat(kGreen,true),\n             ReadKeyFloat(kBlue,true));\n    \n    //// camera\n    const float zoom = 2.0;\n    // make a ray, left handed coords\n    vec3 rs; // ray start\n    vec3 rd = vec3(pos,1.0); // ray direction to the pixel\n    vec3 nrd;\n    vec3 rc = vec3(0.0,0.0,1.0); // ray direction from center of camera\n    // zoom factor\n    rd.xy /= zoom;\n    vec3 cd = vec3(0.0,0.0,1.0); // camera direction (center, look at)\n    if (moveobj) {\n#ifdef MOVESCENE\n\t\tsceneOffset = -vec3(mouse.x,0.0,mouse.y)*20.; //vec3(-5.0,0.0,0.0);\n#endif\n\t\trs = vec3(0.0,12.0,-15.0);// + vec3(mouse*5.99,0.0); // ray start\n        float pit = -PI/4.0;\n\t\trd.yz *= rot(pit); // pitch\n\t\trc.yz *= rot(pit); // pitch\n\t\tnrd = normalize(rd);\n    } else {\n#ifdef MOVESCENE\n\t\t//sceneOffset = vec3(0.0,0.0,12.0);\n#endif\n        if (movexy) { // mouse move camera in xy, always facing forward\n            rs = vec3(0.0,6.0,-15.0) + vec3(mouse*5.99,0.0); // ray start\n            nrd = normalize(rd);\n        } else { // mouse rotates camera 2 different ways\n            rs = vec3(0.);//vec3(0.0,.4,0.0); // ray start\n            rd.yz *= rot(mouse.y*3.14 ); // pitch\n            rc.yz *= rot(mouse.y*3.14 ); // pitch\n            if (roll) {\n                rd.xy *= rot(mouse.x*3.14 ); // roll\n                rc.xy *= rot(mouse.x*3.14 ); // roll\n            } else {\n                rd.xz *= rot(mouse.x*3.14 ); // yaw\n                rc.xz *= rot(mouse.x*3.14 ); // yaw\n            }\n            nrd = normalize(rd); // normalized for the marching, unnormalized for the sky gradient\n            rs += rc * -13.0; // adjust with lookat vector\n        }\n    }\n     \n    // cursor color\n    vec3 circlecolor = keycolor;\n    // is inside circle\n    vec2 del =  pos - mouse;\n    float d2 = dot(del,del);\n    float rad = 1.0/30.0;\n    bool iscursor = d2<rad*rad;\n    \n    // sky plane color\n    vec3 skyplanecolor = skyPlane(rs,rd,planeaxis); // do this with an unnormalized ray\n       \n    // ray march for color\n    bool hit; // did hit something\n    vec3 marchcol = march(rs,nrd,hit);\n    \n    // put it all together\n    vec3 comp;\n    if (iscursor)\n        comp = circlecolor;\n    else if (hit)\n\t\tcomp = marchcol;\n\telse\n        comp = skyplanecolor;\n\tfragColor = vec4(comp,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mlf3D8","date":"1421479701","viewed":160,"name":"fractal_cones","username":"rickiters","description":"subdividing spaces using cones","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["raymarchingfractals"],"hasliked":0,"parentid":"","parentname":""}}