{"ver":"0.1","info":{"id":"ltcczj","date":"1533169355","viewed":324,"name":"Red Ripples","username":"pixlpa","description":"Some flowy stuff","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise","texture","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat bumpFunc(vec2 st){\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);    \n    float center = length((st-(iMouse.xy/iResolution.xy*2.-vec2(1.)))*aspect);\n    float noisevalue = noise((st+vec2(0.,iTime*0.5))*5.*aspect);\n    noisevalue += noise((st+vec2(0.,iTime*0.25))*20.*aspect)*0.1;\n    return pow(smoothstep(1.3,0.,center)*0.5+noisevalue*0.8,3.);\n}\n\n//LIGHTING and BUMP section adapted from https://www.shadertoy.com/view/4l2XWK\n\nvec3 bumpMap(vec3 st){\n    vec2 ts = st.xy+(0.,iTime*0.2);\n    vec3 noisedist = vec3(noise(ts.xy*3.6),noise((ts.xy+4.)*3.5),0.)*0.1;\n    noisedist += vec3(noise((ts.xy+0.39)*8.),noise((ts.xy+4.2)*8.),0.)*0.05;\n    vec3 sp = st+noisedist;\n    vec2 eps = vec2(4./iResolution.y, 0.);\n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n\n\tconst float bumpFactor = 0.2;\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    return vec3(fx,fy,0.)*bumpFactor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    vec3 sp = vec3(uv, 0); // Surface position.\n    vec3 rd = normalize(vec3(uv, 1.)); // Direction vector from the origin to the screen plane.\n    vec3 lp = vec3(iMouse.xy/iResolution.xy*2.-vec2(1.), -0.5); // Light position\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n    \n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\" \n    sn = normalize( sn + bumpMap(sp));           \n   \n    \n    // LIGHTING\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;  \n    float atten = 1./(1.0 + lDist*lDist*0.15);\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.);\n    float grain = noise(uv.xy*110.);\n    fragColor = vec4(vec3(diff*0.7+spec*0.75)*(vec3(1.,0.2,0.2)+vec3(grain*0.1)),1.);\n}","name":"Image","description":"","type":"image"}]}