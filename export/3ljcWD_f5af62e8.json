{"ver":"0.1","info":{"id":"3ljcWD","date":"1672170492","viewed":129,"name":"Mandelbub Front ","username":"faportero","description":"Front view","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","mandelbub"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Referencia : http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n// Visions of Chaos : https://softology.com.au/gallery/gallery.htm\n\nconst float PI = 3.1415926;\nfloat cy = 0.1;\n\nfloat mandelbub(vec3 position)\n{\n            \n    vec3 z = position;\n    float dr = 1.;\n    float r = 0.0;\n    float power =4.;\n    //float power = iTime/20.4;\n    \n    //MATRIZ DE ROTACION\n    float an = .0;\n    //float an = iTime*20.2;\n    mat2 rot = mat2(\n        cos(an), -sin(an),\n        sin(an), cos(an)\n    );\n    \n    vec3 q = position;\n    q.xz = rot*q.xz;\n\n    \n    for (int i = 0; i <6; ++i)\n    {\n    r = length(z);\n        if (r > 2.)\n        {\n        break;\n        }\n        \n        \n        float cPower = iTime / 5.0;\n        float theta = acos(z.z/r) * power * cPower ;\n        float phi = atan(z.y, z.x) * power * cPower;\n        float zr = pow(r, power);\n        \n        dr = pow(r, power - 1.) * power * dr + 1.;\n        \n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin (theta), cos(theta));\n        z +=.5*q;       \n    }\n    \n    \n        \n    float d2 = length (vec2(q.y+1.5, length(q.xz) -2.5)) - 0.2;\n    //return d2;\n\treturn  .5 * log(r) * r / dr;\n       \n}\n\n\n// Calculo del gradiente\nvec3 calcNormal(vec3 position)\n{\n    float rbgx, rgby, rgbz;\n\treturn normalize(vec3(\n    \tmandelbub(position + vec3(-0.001, 0.0, 0.0)) -mandelbub(position - vec3(-0.001, 0.0, 0.0)),\n        mandelbub(position + vec3(0.0, -0.005, 0.0))+mandelbub(position - vec3(0.0, -.001, 0.0)),\n        mandelbub(position + vec3(0.0, 0.0, -0.001)) - mandelbub(position - vec3(0.0, 0.0, -0.001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen_pos = ((2.0 * fragCoord.xy - iResolution.xy )/ iResolution.y )+ (0.0,0.0,0.0);\n    \n    //float cam_an = 2.*PI;\n    float cam_an = iTime*0.5;\n    float frec = .5;\n    //vec3 cam_orig = vec3 (1.*sin(-6.5)+cos(2.4), 3.*(sin(.9)+cos(2.4)), -1.3);\n\tvec3 cam_orig = vec3 (0., 0., -1.2);\n\t\n    //vec3 cam_orig = vec3 (.5*sin(frec*cam_an)+cos(frec*cam_an), .5*sin(cam_an)+cos(cam_an), -2.5*sin(cam_an));\n    \n    \n    float an = 0.4;\n    //float an = iTime*5.;\n    mat2 rot = mat2(\n        cos(an), sin(an),\n        -sin(an), cos(an)\n    );\n    \n\n\n    \n    \n    vec3 cam_target = vec3(.0, 0.,.0);    \n\n    vec3 q = cam_target;\n    q.xz = rot*q.xz;\n    \n    vec3 cam_forward = normalize(cam_target - cam_orig);\n    vec3 cam_right = normalize(cross(cam_forward, vec3 (0.0, 1.0, 0.0)));\n    vec3 cam_up = normalize(cross(cam_right, cam_forward));\n    \n    vec3 ro = cam_orig;\n    vec3 rd = normalize(vec3(\n    \tscreen_pos.x * cam_right + \n        screen_pos.y * cam_up + \n        .8 * cam_forward       \n    ));\n    \n    vec3 col = vec3(0.0);\n    \n    float t = 0.0;\n    \n    for (int step_march = 0; step_march < 100; ++step_march)\n    {\n    \tvec3 p = ro + t * rd;\n        float h = mandelbub(p);\n        if (h < 0.0001)\n        {\n        \tcol = calcNormal(p);\n            //col = vec3(0.0,cy,0.0);\n            break;\n        }\n        \n        t +=h;   \n        \n    }\n    \n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}