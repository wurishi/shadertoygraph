{"ver":"0.1","info":{"id":"mlXcDX","date":"1691698106","viewed":106,"name":"Sketch #4: Polka Dots","username":"MOONtyzoo","description":"Based on what I learned here: https://thebookofshaders.com/09/\n\nUsing the fract function on the space is a nice way to create patterns but at the same time it is difficult to keep track of since the tiles have to match up continuously to keep the pattern.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nfloat sdfCircle(in vec2 p, in float r)\n{\n    return length(p) - r;\n}\n\nvec2 rotate2D(in vec2 uv, in float angle)\n{\n    return uv*mat2(cos(angle), -sin(angle),\n                   sin(angle), cos(angle));\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    /*\n        Pan the screen\n    */\n    uv = rotate2D(uv, -PI/10.0);\n    vec2 offset = rotate2D( vec2(0.3*iTime, 0.2*cos(1.5*iTime)), PI/4.0 );\n    uv += offset;\n    \n    /*\n        Label tiles into rows and columns\n    */\n    float gridSize = 6.0;\n    vec2 gridCount = floor(2.0*fract(uv*gridSize/2.0)); // Labels tiles alternatingly as 0 and 1\n    float gridRow = gridCount.y;\n    float gridCol = gridCount.x;\n    \n    /*\n        Shift the tiles\n    */\n    float gridAnim = floor(mod(iTime, 4.0)); // 0.0, 1.0, 2.0, 3.0, loops over time\n    \n    // Filters what gets shifted based on row/column\n    vec2[] shiftTable = vec2[4](vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(-1.0, 0.0), vec2(0.0, -1.0));\n    vec2 shift = 2.0*(shiftTable[int(gridAnim)]/gridSize);\n    shift *= gridRow*(1.0-mod(gridAnim, 2.0)) + gridCol*mod(gridAnim, 2.0);\n    uv += iTime*shift;\n    \n    // Relabel tiles after shift for coloring\n    gridCount = floor(2.0*fract(uv*gridSize/2.0)); // Labels tiles alternatingly as 0 and 1\n    gridRow = gridCount.y;\n    gridCol = gridCount.x;\n    \n    uv = fract(uv*gridSize);\n    \n    /*\n        Draw circles in each tiles\n    */\n    vec2 center = vec2(0.5, 0.5);\n    float circle = sdfCircle(uv - center, 0.25);\n    \n    vec3 HSV;\n    HSV[0] = 0.5*gridRow;\n    HSV[1] = 1.0-0.8*gridCol;\n    HSV[2] = 1.0-smoothstep(0.0, 10.0/iResolution.y, circle);\n    \n    fragColor = vec4(hsv2rgb(HSV), 1.0);\n}","name":"Image","description":"","type":"image"}]}