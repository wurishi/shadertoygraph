{"ver":"0.1","info":{"id":"ctsXW4","date":"1674772993","viewed":100,"name":"Wobbly stuff","username":"BetaSoftCologne","description":"Just a combination of some experiments ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wobbly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: BSC\n// Title: wobbly stuff\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat gx = -20.;\n\nfloat circle(in vec3 pos, in float radius) {\n    float d = length(pos) - radius;\n    return d;\n}\n\nfloat pattern_x(in vec2 pos) {\n    float col = 0.5;\n\n    // vertical gradient\n    float py = smoothstep(0.1, 0.6, pos.y);\n    py -= smoothstep(0.1, 0.8, -pos.y);\n\n    // horizontal\n    float px = mod(pos.x, 0.05);\n    px += 0.2 * floor(pos.x);\n    px += 0.1 * px;\n\n    return 0.5 + px + py;\n}\n\nfloat pattern_y(in vec2 pos) {\n    float col = 0.5;\n\n    // vertical gradient\n    float py = smoothstep(0.1, 0.6, pos.x);\n    py -= smoothstep(0.1, 0.8, -pos.y);\n\n    // horizontal\n    float px = mod(pos.x, 0.05);\n    px += 0.2 * floor(pos.x);\n \n    return 0.5 * px - 0.5 * py;\n}\n\nmat2 rotMatDeg(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvec4 addCircles(in vec2 fragCoord, in float a) {\n    mat2 rot = rotMatDeg(a / 10.0);\n    vec2 xy = rot * fragCoord;\n    xy = xy / gx;\n    \n    float r = sin(xy.x) - cos(xy.y);\n    float g = sin(xy.x) + cos(xy.y);\n    float b = sin(xy.y) - cos(xy.x);\n    return vec4(r, g, b, 1.0);\n}\n\n\nvec4 two_circles(in vec3 pos, in vec2 pix) {\n#if 1\n    // repeat domain\n    float d = 2.5;\n    pos.x = mod(pos.x + d, d * 2.) - d;\n    pos.y = mod(pos.y + d, d * 2.) - d;\n    pos.z = mod(pos.z + d, d * 2.) - d;\n#endif\n\n#if 1\n    // rotate around center\n    pos.x += sin(iTime * 1.5);\n    pos.y += cos(iTime * 1.5);\n#endif\n\n#if 1\n    // distort\n    pos.x *= 1. + 0.25 * sin(iTime * 5.);\n    pos.y *= 1. + 0.15 * cos(iTime * 3.);\n#endif \n\n    // main ball\n    float x = circle(pos, 0.5);\n\n    // wandering ball\n    // use sin/cos to wander outside\n    vec3 new_pos = vec3(pos.x + 0.5*sin(iTime), pos.y + 0.5*sin(iTime), pos.z);\n    float y = circle(new_pos, 0.4);\n\n    // create a pattern based on screen pos\n    vec2 uv = gl_FragCoord.xy; \n    float b = iDate.w / 2.0; // wall clock seconds  \n\n    // take the one which is closer\n    float a = 0.;\n    vec3 rgb;\n    if (x < y) {\n        a = x; // big ball\n        float col = pattern_x(pos.xy);\n        rgb += col;\n        float p = fract(iDate.w);\n        if (p < 0.5) {\n            vec4 foo = addCircles(uv * 0.5, b);\n            rgb += foo.rgb * 0.3 * p;\n        }\n    } else {\n        a = y; // tiny ball\n        float zoom = 0.3; // + sin(0.9*iTime);\n        vec4 foo = addCircles(uv * zoom, b);\n        float col = pattern_y(pos.xy); \n        rgb = vec3(foo.z, col * foo.y, col);\n        rgb *= col;\n    }\n\n    return vec4(rgb, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n\n    // Normalize pixel coordinates (from -1 to 1)    \n    vec2 p = (2. * pos - iResolution.xy) / iResolution.y;\n    \n    // ray origin is outside of the screen\n    vec3 ro = vec3(0.,0.,3.);\n\n    // ray direction starts at the current pixel position \n    vec3 rd = normalize(vec3(p.xy, -1.5));\n\n#if 1\n    // rotate some more\n    float a = sin(iTime) + 0.567*cos(iTime) + 0.3*sin(iTime / 3.33);\n    mat2 rot = rotMatDeg(a / 2.0);\n    rd.xy *= rot;\n    rd.yz *= rot;\n#endif \n\n    // march\n    float max = 50.0;\n    vec3 col = vec3(0.0235, 0.0471, 0.1608);\n    float dist, t = 0.;\n    vec4 result;\n\n    for (int i=0; i<25; i++) {\n        vec3 pos = ro + t*rd;\n#if 0\n        float f = fract(sin(iTime));\n        pos.z += f;\n#endif\n        result = two_circles(pos, p);\n\n        // the distance is in the a-component\n        dist = result.a;\n        if (dist < 0.001) break; // we hit something!\n\n        // advance the current distance   \n        t += dist;\n        // until we went too far\n        if (t>max) break;\n    }\n    \n    if (t<max) {\n        // still in the scene, so we must have hit something. \n        // extract the color of the object that was hit\n        col = result.rgb;\n    }\n       \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}