{"ver":"0.1","info":{"id":"sdtBD4","date":"1656549649","viewed":154,"name":"d20 bubbles","username":"pb","description":"kind of looks like soap bubbles at certain points","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["reflection","bubble","icosahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Philip Bertani - philip.bertani@gmail.com\n\n#define MAX_RAY_STEPS 100\n#define MAX_PRIME_RAY_DIST 10.\n#define PI 3.14159265\n\nint max_iter = 2;\nvec3 ifs_color;\nfloat ifs_scale = 4.;\n\nvec3 ambientL  = vec3(.2,.1,.5);\nvec3 diffuseL  = vec3(.5,0.,.6);\nvec3 specularL = vec3(.7,.1,0.);\nvec3 ambdir    = normalize(vec3(1.,0.,1.));\n\n\nstruct RAYMARCH_RESULT {\n    vec3  raypos;\n    float dist_from_origin;\n    float object_id;\n};\n\n\nvec3  light_pos = vec3(0.,0., 1.);\nvec2  myMouse;\nvec3  ro,rd;\n\nfloat sphere_sdf( vec3 pos, float r ) {\n    return length(pos) - r;\n}\n\nmat3 rot_xz(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(cc,0.,ss,0.,1.,0.,-ss,0.,cc);\n\n}\n\nvec2 dist_func01(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    ifs_color = vec3(0.);\n\n    for (int i=0; i<100; i++) {\n       \n        if ( i > max_iter ) break;\n\n        float w = iTime/3.;\n        vec3 dd_0 = rot_xz(w)*d20[0];\n        min_vtx = dd_0;\n        min_dist=length(z-dd_0);\n        for (int j=1; j<12; j++) {\n            vec3 ddj = rot_xz(w)*d20[j];\n            dist_to_vtx=length(z-ddj); \n            if (dist_to_vtx<min_dist) {min_vtx=ddj; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n\n        //potentially interesting colors\n        /*\n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n        */\n        \n    }\n\n    //ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    //scene_dist = max( scene_dist, -(length(orig_z-ro)-.81) ); //looks cool with this but don't use for now\n    return vec2( scene_dist, objid );\n}\n\n\nvec3 estimate_normal_vec( vec3 pos, float neps ) {\n\n    // in other words - the Gradient Vector...\n    \n    float norm_sign = 1.; \n\n    vec2  np = norm_sign * normalize(vec2( 1., -1)); //putting the wrong sign here makes a glossy effect\n\n    vec2  dp = vec2( neps, -neps);\n   \n    vec3 df1 = np.xxx * dist_func01( pos + dp.xxx ).x;\n    vec3 df2 = np.xyy * dist_func01( pos + dp.xyy ).x;\n    vec3 df3 = np.yxy * dist_func01( pos + dp.yxy ).x;\n    vec3 df4 = np.yyx * dist_func01( pos + dp.yyx ).x;\n    \n    \n    return normalize( df1 + df2 + df3 + df4 );\n\n}\n\n\nRAYMARCH_RESULT raymarch( vec3 ro, vec3 rd, float eps, float initial_object_id ) {\n\n    float dist_from_origin = 0.; \n    vec3 raypos = ro;\n    RAYMARCH_RESULT result;\n    result.object_id = initial_object_id; \n    result.dist_from_origin = 0.;\n   \n    float threshold = eps;\n    \n    for (int i=0; i<MAX_RAY_STEPS && dist_from_origin < MAX_PRIME_RAY_DIST; i++) {\n    \n        vec3 raypos = ro + dist_from_origin * rd;\n        vec2 dist_to_closest = dist_func01(raypos);\n        if ( abs(dist_to_closest.x) < threshold ) {\n        \n            result.object_id = dist_to_closest.y;\n            result.raypos = raypos;\n            result.dist_from_origin = dist_from_origin;\n            \n            break;\n        }\n        \n\n        raypos += dist_from_origin*rd; \n\n        dist_from_origin += dist_to_closest.x;\n        \n        threshold *= (1.+dist_from_origin*40.);\n        \n    }\n       \n    return result;\n    \n}\n\nvec3  main_loop( vec3 ro, vec3 rd ) {\n    \n    RAYMARCH_RESULT prime_ray = raymarch( ro, rd, .00003, 100.);\n    \n    vec3 color = vec3(0.);\n    \n    if (prime_ray.object_id > -1. ) { \n    \n        vec3 nn = estimate_normal_vec( prime_ray.raypos, .01 );\n        \n        vec3 lt_pos = light_pos + vec3( 6.*cos(iTime/3.), .5*sin(iTime/5.) , 6.*sin(iTime/2.) );  \n        float spec_pow = 16.; \n        float spec_amp = 1.;\n        \n        vec3 light_dir=normalize(lt_pos-prime_ray.raypos); \n        float diffuse_light = clamp(dot(light_dir, -nn), 0., 1.);\n        float ambient_light = 0.5 * dot(nn, ambdir);\n       \n        vec3 view_dir= rd;      \n        vec3 refl = reflect(-view_dir,nn);      \n        float specular_light=pow(max(dot(refl,light_dir),0.0),spec_pow);\n        \n\n        color = ambient_light  * ambientL + \n                diffuse_light  * diffuseL +\n                spec_amp*specular_light * specularL;\n             \n        color *= exp(-prime_ray.dist_from_origin/20.);\n        \n        vec3 new_ro = prime_ray.raypos + nn*.01;\n        vec3 new_rd = reflect( rd, nn );\n        RAYMARCH_RESULT reflection = raymarch( new_ro, new_rd, .00005, 100.);\n        \n        \n        if ( reflection.object_id > -1. ) {\n  \n            \n            vec3 nn2 = estimate_normal_vec( reflection.raypos, .02 ); \n         \n            vec3 light_dir2=normalize(lt_pos-reflection.raypos); \n            \n            float diffuse_light2 = clamp(dot(light_dir2, -nn2), 0., 1.);\n            float ambient_light2 = 0.5 * dot(nn2, ambdir);\n    \n            vec3 view_dir2 = new_rd;\n            vec3 refl2=reflect(-view_dir2,nn);\n            float specular_light2 = pow(max(dot(refl2,light_dir2),0.0),spec_pow);\n        \n            vec3 reflect_color = ambient_light2 * ambientL +\n                                 diffuse_light2 * diffuseL +\n                                 spec_amp*specular_light2 * specularL; \n                                 \n            float color_fac = 1.;\n            \n            reflect_color *= exp(-reflection.dist_from_origin/30.);\n\n            color += color_fac *  reflect_color;\n            \n        }\n        \n        \n                      \n    }\n\n    return clamp(color, 0., 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float myTime = iTime/5.;\n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    //myMouse = (iMouse.xy*2.0 - iResolution.xy) / iResolution.y;\n    \n    ifs_scale = 4. - 2.*abs(sin(iTime/60.));\n    max_iter = 5 - int(4.*abs(sin(myTime/2.)));\n    ro = vec3(0.,0.,-1.4 + max(-.9,min(1.1,1.5*(sin(myTime-PI/2.)))) );  //ray origin\n    rd = normalize( vec3(uv, 1.8) );  //ray direction\n    \n    vec3 color = main_loop(ro, rd);\n \n    //color = pow( color, vec3(.6) );\n    \n    fragColor = vec4(color,1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//hard coded icosahedron vertices for fractal generation\nconst float sqr5 = sqrt(5.);\nconst float p1 = 1./sqr5;\nconst float p2 = 2./sqr5;\nconst float p3 = sqrt( (5.+sqr5)/10. );\nconst float p4 = sqrt( (5.-sqr5)/10. );\nconst float p5 = (5.-sqr5)/10.;\nconst float p6 = (-5.-sqr5)/10.;\nconst float p7 = (5.+sqr5)/10.;\nconst float p8 = (-5.+sqr5)/10.;\n\nvec3[] d20 = vec3[] (\nvec3(1.,0.,0.),\nvec3(p1, p2, 0.),\nvec3(p1, p5, p3),\nvec3(p1, p6, p4),\nvec3(p1, p6, -p4),\nvec3(p1, p5, -p3),\nvec3(-1.,0.,0.),\nvec3(-p1, -p2, 0.),\nvec3(-p1, p8, -p3),\nvec3(-p1, p7, -p4),\nvec3(-p1, p7, p4),\nvec3(-p1, p8, p3)\n);\n","name":"Common","description":"","type":"common"}]}