{"ver":"0.1","info":{"id":"McyGRK","date":"1712957142","viewed":44,"name":"Naive Mandlebrot w/ comments","username":"JoshK","description":"I am certain that there are better ways to do this, but I wanted to figure it out for myself so that I can better understand the maths behind Mandelbrot  and complex functions.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","maths","complexnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Maximum number of steps to take before assuming the Mandlebrot function will cycle\nconst int MAX_STEPS = 128;\n\n// A complex number\nstruct Z\n{\n    float r;\n    float i;\n};\n\n// Adding two complex numbers\nZ Zadd(Z z1, Z z2)\n{\n    return Z(z1.r + z2.r, z1.i + z2.i);\n}\n\n// Squaring a complex number\nZ Zsquared(Z z)\n{\n    return Z(z.r*z.r - z.i*z.i, z.r*z.i + z.i*z.r);\n}\n\n// Finds the distance between '0 + 0i' and z\nfloat ZsqrDist(Z z)\n{\n    return z.r*z.r + z.i*z.i;\n}\n\n// The Mandlebrot function\nZ Mandlebrot(Z z, Z c)\n{\n    return Zadd(Zsquared(z), c);\n}\n\n// Is defined as in the set if the distance from the origin remains less than 2\n// after an infinite number of (or in our case, MAX_STEPS) iterations\n// We return the number of steps taken rather than a bool so we can use it for pretty rendering\nint InSet(Z c)\n{\n    Z z = Z(0.0, 0.0);\n    for (int i = 1; i <= MAX_STEPS; i++)\n    {\n        z = Mandlebrot(z, c); // Compute the value of the Mandelbrot function with this value of z and c\n        \n        // Is this value more than 2 units away? If so, we know it won't even come back, so we can stop here\n        // Can use the squared distance instead to make it a bit faster\n        if (ZsqrDist(z) > 4.0) return i;\n    }\n    return -1;\n}\n\n// For each pixel,\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // The coordinates of this pixel\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    \n    // The dimensions of the screen, halved (needed so we can center the image)\n    float W2 = iResolution.x / 2.0;\n    float H2 = iResolution.y / 2.0;\n    \n    // Calculated to be slightly less than the screen height so that it's framed a little nicer\n    float SCALE = H2 * 0.8;\n    \n    // Calculate the number of steps it takes for the complex number 'x + yi'\n\t// to be more than 2 units away from the origin (past that point it converges to infinity)\n    int result = InSet(Z((x-W2)/SCALE, (y-H2)/SCALE));\n    \n    // Will return -1 if it endlessly loops instead\n\t// Colour the pixel with the number of steps taken\n    if (result == -1)\n    {\n        // Black\n        fragColor = vec4(0.0);\n    }\n    else\n    {\n        // Greyscale - the more steps taken, the whiter the pixel\n        fragColor = vec4(vec3(float(result)/float(MAX_STEPS)), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}