{"ver":"0.1","info":{"id":"MlXcR2","date":"1514355273","viewed":473,"name":"Minimal Raycast Engine","username":"OccamsLaser","description":"Use the arrow keys to move\n\nGamestate code derived from iq's fantastic pacman shader https://www.shadertoy.com/view/Ms3XWN\n\nMusic done by collaborator: https://www.shadertoy.com/view/Mtlcz2","likes":7,"published":1,"flags":56,"usePreview":0,"tags":["procedural","game","wolfenstein","maze","fps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rendering\n\nconst ivec2 txPosition\t= ivec2(32,1);\nconst ivec2 txState\t\t= ivec2(32,7);\nconst ivec4 txCells\t\t= ivec4(0,0,31,31);\n\n//============================================================\n\nvec3 cast_ray(vec4 position, in vec2 frag_coord) {\n    vec3 color;\n    \n    vec2 direction = vec2((16./9.)*((frag_coord.x/iResolution.x)-0.5),1.0);\n    mat2 rotate = mat2( cos(position.w), sin(position.w),\n                       -sin(position.w), cos(position.w));\n    direction *= rotate;\n    \n    //vec2 direction = vec2(sin(position.w) + cos(position.w)*((frag_coord.x/iResolution.x)-0.5),\n    //                      cos(position.w) - sin(position.w)*((frag_coord.x/iResolution.x)-0.5));\n        \n    //while the ray is still in the level, check if it hits something when crossing an axial unit\n    vec2 map = floor(position.xy);\n    //direction of next cell in given bearing\n    vec2 sign_dir = sign(direction);\n    \n    //distance to next cell in the map\n    vec2 next = vec2(sqrt(1.0 + (direction.y*direction.y)/(direction.x*direction.x)),\n                     sqrt(1.0 + (direction.x*direction.x)/(direction.y*direction.y)));\n    //total distance traveled;\n    vec2 traveled;\n        \n    //calculate distance to the next cell\n    if(sign_dir.x < 0.0) {\n    \ttraveled.x = (position.x-float(map.x))*next.x;\n    } else {\n    \ttraveled.x = (map.x+1.0-position.x)*next.x;\n    }\n    if(sign_dir.y < 0.0) {\n    \ttraveled.y = (position.y-float(map.y))*next.y;\n    } else {\n        traveled.y = (map.y+1.0-position.y)*next.y;\n    }\n    \n    //prepare and trace\n    int side = -1;\n    float wall;\n    \n    while(true){\n        wall = texture(iChannel0, (map+vec2(0.5))/iResolution.xy).x;\n        \n        if(wall > 0.0) {\n            break;\n        }\n        \n        if(traveled.x < traveled.y) {\n            traveled.x += next.x;\n            map.x += sign_dir.x;\n            side = 0;\n        } else {\n            traveled.y += next.y;\n            map.y += sign_dir.y;\n            side = 1;\n        }\n    }\n    \n    //calculate actual distance travelled\n    float ray_traveled;\n    \n    if(side == 0) {\n        ray_traveled = (map.x-position.x+(1.0-sign_dir.x)/2.0)/direction.x;\n    } else if(side == 1) {\n        ray_traveled = (map.y-position.y+(1.0-sign_dir.y)/2.0)/direction.y;\n    }\n    \n    //calculate height of wall at given distance, start and end of wall column\n    float height = iResolution.y/ray_traveled;\n    \n    int drawStart = int(iResolution.y/2.0 - height/2.0);\n    int drawEnd = int(iResolution.y/2.0 + height/2.0);\n    \n    //determine color of wall\n    if(wall == 0.0) {\n    \tcolor = vec3(0.0);\n    } else if(wall == 1.0) {\n        color = vec3(0.5,0.3,0.3);   \n    } else if(wall == 2.0) {\n     \tcolor = vec3(0.2,0.132,0.132);   \n    } else if(wall == 3.0) {\n    \t//cell x coordinate of hit\n        float wallx;\n        if (side == 0) {\n            wallx = position.y + ray_traveled*direction.y;\n        } else {\n            wallx = position.x + ray_traveled*direction.x;\n        }\n\n        wallx -= floor((wallx));\n\n        //x coordinate on the texture\n        int texX = int(wallx * 512.0);\n\n        float texY = (frag_coord.y-float(drawStart))*(512.0/height);\n        \n        color = texture(iChannel1,(vec2(texX,texY)+vec2(0.5))/iResolution.xy).xyz;\n    }\n    \n    if(side == 1) {\n    \tcolor /= 2.0;   \n    }\n    \n    if(int(frag_coord.y) < drawStart) {\n        color = vec3(0.05,0.05,0.05);\n    } else if(int(frag_coord.y) > drawEnd) {\n    \tcolor = vec3(0.3,0.3,0.3);\n    }\n    \n    return color;\n}\n\n\nfloat sd_circle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nvec4 load_value(in ivec2 re) {\n    return texelFetch(iChannel0, re, 0);\n}\n\nvec2 cell2ndc(vec2 c) {\n    c = (c+0.5)/16.0; //\"32.0\" is cell grid height, why magic number -_-\n    c.x -= 0.5*(1.0-iResolution.x/iResolution.y); // center\n    return c;\n}\n\nvec3 draw_viewport(vec3 col, in vec2 frag_coord, in vec4 playerPos) {\n    if(frag_coord.y >= iResolution.y/6.0) {\n    \tcol = cast_ray(playerPos, frag_coord);\n    } else {\n        col = vec3(0.2,0.0,0.2);\n    }\n    \n    return col;\n}\n\nvec3 draw_map(vec3 col, in vec2 frag_coord) {\n    vec2 p = frag_coord/(iResolution.y/6.0);\n    p.x += 0.5*(1.0-iResolution.x/(iResolution.y/6.0)); // center\n\n    vec2 q = floor(p*16.0);\n\n    if(q.x>=0.0 && q.x<=15.0 && q.y>=0.0 && q.y<=15.0) {\n        float c = texture(iChannel0, (q+0.5)/iResolution.xy, -100.0).x;\n\n        col = vec3(c/4.0);\n    }\n    \n    return col;\n}\n\nvec3 draw_player(vec3 col, in vec2 fragCoord, in vec4 playerPos) {   \n    vec2 mPlayerPos = playerPos.xy;\n\n    vec2 p = fragCoord/(iResolution.y/6.0);\n    p.x += 0.5*(1.0-iResolution.x/(iResolution.y/6.0));\n    p.x += 0.4;\n    \n    float eps = 1.0/(iResolution.y/6.0);\n\n    vec2 q = p-cell2ndc(mPlayerPos-vec2(0.5));\n\n    float c = sd_circle(q, 0.023);\n    float f = c;\n\n    f = 1.0 - smoothstep(-0.5*eps, 0.5*eps, f);\n    \n    col = mix(col, vec3(1.0-playerPos.z/16.0,0.0,0.0), f);\n\n    return col;\n}\n\n\n//============================================================\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    //------------------------\n    // load game state\n    //------------------------\n    vec4  position  = load_value(txPosition);\n    float state\t\t= load_value(txState).x;\n\n    //------------------------\n    // render\n    //------------------------\n    vec3 col = vec3(0.0);\n    \n    // viewport\n    col = draw_viewport(col, frag_coord, position);\n    \n    // map\n    col = draw_map(col, frag_coord);\n    col = draw_player(col, frag_coord, position);\n    \n    frag_color = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PA(a,b,c,d,e,f,g,h) (a+4*(b+4*(c+4*(d+4*(e+4*(f+4*(g+4*h)))))))\n#define DD(id, c0,c1,c2,c3,c4,c5,c6,c7) if(y==id) m = (x<8) ? PA(c0,c1,c2,c3,c4,c5,c6,c7):PA(c7,c6,c5,c4,c3,c2,c1,c0);\n\nint map(in ivec2 q) {\n    int x = q.x;\n    int y = q.y;\n    int m = 0;\n    \n    DD(15,  3,3,3,3,3,3,3,3)\n    DD(14,  3,0,0,0,0,0,0,3)\n    DD(13,\t3,0,2,2,2,2,0,3)\n    DD(12,\t3,0,3,0,0,0,0,0)\n    DD(11,\t3,0,3,3,0,3,3,3)\n    DD(10,\t3,0,3,0,0,3,0,0)\n    DD( 9,\t3,0,3,3,3,3,0,3)\n    DD( 8,\t3,0,3,0,0,0,0,3)\n    DD( 7,\t1,0,3,0,2,2,2,2)\n    DD( 6,  1,0,3,0,0,0,0,1)\n    DD( 5,  1,0,1,3,3,3,0,1)\n    DD( 4,  1,0,0,0,0,0,0,2)\n    DD( 3,  1,0,1,3,3,3,0,0)\n    DD( 2,  1,0,3,2,0,2,0,2)\n    DD( 1,  1,0,3,0,0,0,0,0)\n    DD( 0,  1,1,1,2,2,2,2,2)\n    \n    return (m>>(2*(x%8)))&3;\n}\n\n//----------------------------------------------------------------------------------------------\n\nconst ivec2 txPosition  = ivec2(32,1);\nconst ivec2 txState     = ivec2(32,7);\nconst ivec4 txCells     = ivec4(0,0,31,31);\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float move_speed = 0.05;\nconst float turn_speed = 0.05;\n\n\n//----------------------------------------------------------------------------------------------\n\nvec4 load_value(in ivec2 re) {\n    return texelFetch(iChannel0, re, 0);\n}\n\nvoid store_value(in ivec2 re, in vec4 va, inout vec4 frag_color, in ivec2 frag_coord) {\n    frag_color = (re.x==frag_coord.x && re.y==frag_coord.y) ? va : frag_color;\n}\n\nvoid store_value(in ivec4 re, in vec4 va, inout vec4 frag_color, in ivec2 frag_coord) {\n    vec2 r = 0.5*vec2(re.zw);\n    vec2 d = abs(vec2(frag_coord-re.xy)-r)-r-0.5;\n    frag_color = (-max(d.x,d.y)>0.0) ? va : frag_color;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 ifragCoord = ivec2(fragCoord-0.5);\n\n    // don't compute gameplay outside of the data area\n    if(ifragCoord.x>32 || ifragCoord.y>32) discard;\n    \n    //---------------------------------------------------------------------------------   \n    // load game state\n    //---------------------------------------------------------------------------------\n    vec4  position  = load_value(txPosition);\n    float state     = load_value(txState).x;\n    int   cell      = int(load_value(ifragCoord).x);\n    \n    //---------------------------------------------------------------------------------\n    // reset\n    //---------------------------------------------------------------------------------\n    if(iFrame==0) state = -1.0;\n\n    vec4 cell_position;\n    \n    if(state < -0.5) {\n        position\t= vec4(1.5,1.5,1.0,0.0);\n        state\t\t= 0.0;\n        if(ifragCoord.x<31 && ifragCoord.y<31) \n            cell = map(ifragCoord);\n        \n        state = 1.0;\n    } else {\n        // move with keyboard\n        if(texelFetch(iChannel1, ivec2(KEY_RIGHT,0), 0).x > 0.5) {\n            position.w += turn_speed;\n        }\n        \n        if(texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5) {\n            position.w -= turn_speed;\n        }\n        \n        if(texelFetch(iChannel1, ivec2(KEY_UP,   0), 0).x > 0.5) {\n        \tvec2 test_position = position.xy + move_speed*vec2(sin(position.w),cos(position.w));\n            \n            if(map(ivec2(floor(test_position))) < 1) {\n                position.xy = test_position;\n            } else if(map(ivec2(test_position.x,position.y)) < 1) {\n            \tposition.xy = vec2(test_position.x,position.y);\n            } else if(map(ivec2(position.x,test_position.y)) < 1) {\n            \tposition.xy = vec2(position.x,test_position.y);\n            }\n        }\n        \n        if(texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5) {\n            vec2 test_position = position.xy - move_speed*vec2(sin(position.w),cos(position.w));\n            \n            if(map(ivec2(floor(test_position))) < 1) {\n                position.xy = test_position;\n            } else if(map(ivec2(test_position.x,position.y)) < 1) {\n            \tposition.xy = vec2(test_position.x,position.y);\n            } else if(map(ivec2(position.x,test_position.y)) < 1) {\n            \tposition.xy = vec2(position.x,test_position.y);\n            }\n        }\n    }\n  \n    //---------------------------------------------------------------------------------\n    // store game state\n    //---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n    \n    store_value(txPosition,  vec4(position),\t\t\tfragColor, ifragCoord);\n    store_value(txState,     vec4(state,0.0,0.0,0.0),\tfragColor, ifragCoord);\n    store_value(txCells,     vec4(cell,0.0,0.0,0.0),\tfragColor, ifragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Sequencer credit to jocopa3\n\n/**************************************\\\n|* Global Parameters                  *|\n\\**************************************/\n\n\n// 128 bpm is the usual speed for house/dance music\nconst float bpm = 80.0;\n\n// How fast the music plays in relation to a minute (no need to modify)\nconst float rate = bpm/60.0;\n\n\n/**************************************\\\n|* Instruments                        *|\n\\**************************************/\n\n\n// Sine wave\n#define sine(freq, time) (sin(6.28318531*time*freq)+sin(6.28318531*time*freq))\n\n// Saw wave\n#define saw(freq, time) ((time*freq - floor(time*freq)) * 2.0 - 1.0)\n\n// Square wave\n#define square(freq, time) (sign(sin(6.28318531*time*freq)))\n\n// Triangle wave\n#define tri(freq, time) (1.0 - abs(mod(freq*time, 1.0)-2.0))\n\n\n/**************************************\\\n|* Notes                              *|\n\\**************************************/\n\n\n// This essentially creates a pulse\n// Evaluates to 1.0 if a note should be played during the interval, and 0.0 if the note should not be played\n// start refers to the start of the note in a measure; each beat is in intervals of 0.25\n// end refers to the end of the note in a measure\n#define note(start, end, seqTime) (max(1.0 - sign(seqTime - end), 0.0) * max(sign(seqTime - start), 0.0))\n\n// Notes C0 to B8 all in one line! (How gross!)\n// Taken from: http://www.phy.mtu.edu/~suits/notefreqs.html\n// Converted using a JavaScript function I ran on that webpage to convert the table into compileable code\n// For sharp/flat notes, such as G-sharp/A-flat, use GA[octave]\nfloat C0 = 16.35;float CD0 = 17.32;float D0 = 18.35;float DE0 = 19.45;float E0 = 20.60;float F0 = 21.83;float FG0 = 23.12;float G0 = 24.50;float GA0 = 25.96;float A0 = 27.50;float AB0 = 29.14;float B0 = 30.87;float C1 = 32.70;float CD1 = 34.65;float D1 = 36.71;float DE1 = 38.89;float E1 = 41.20;float F1 = 43.65;float FG1 = 46.25;float G1 = 49.00;float GA1 = 51.91;float A1 = 55.00;float AB1 = 58.27;float B1 = 61.74;float C2 = 65.41;float CD2 = 69.30;float D2 = 73.42;float DE2 = 77.78;float E2 = 82.41;float F2 = 87.31;float FG2 = 92.50;float G2 = 98.00;float GA2 = 103.83;float A2 = 110.00;float AB2 = 116.54;float B2 = 123.47;float C3 = 130.81;float CD3 = 138.59;float D3 = 146.83;float DE3 = 155.56;float E3 = 164.81;float F3 = 174.61;float FG3 = 185.00;float G3 = 196.00;float GA3 = 207.65;float A3 = 220.00;float AB3 = 233.08;float B3 = 246.94;float C4 = 261.63;float CD4 = 277.18;float D4 = 293.66;float DE4 = 311.13;float E4 = 329.63;float F4 = 349.23;float FG4 = 369.99;float G4 = 392.00;float GA4 = 415.30;float A4 = 440.00;float AB4 = 466.16;float B4 = 493.88;float C5 = 523.25;float CD5 = 554.37;float D5 = 587.33;float DE5 = 622.25;float E5 = 659.25;float F5 = 698.46;float FG5 = 739.99;float G5 = 783.99;float GA5 = 830.61;float A5 = 880.00;float AB5 = 932.33;float B5 = 987.77;float C6 = 1046.50;float CD6 = 1108.73;float D6 = 1174.66;float DE6 = 1244.51;float E6 = 1318.51;float F6 = 1396.91;float FG6 = 1479.98;float G6 = 1567.98;float GA6 = 1661.22;float A6 = 1760.00;float AB6 = 1864.66;float B6 = 1975.53;float C7 = 2093.00;float CD7 = 2217.46;float D7 = 2349.32;float DE7 = 2489.02;float E7 = 2637.02;float F7 = 2793.83;float FG7 = 2959.96;float G7 = 3135.96;float GA7 = 3322.44;float A7 = 3520.00;float AB7 = 3729.31;float B7 = 3951.07;float C8 = 4186.01;float CD8 = 4434.92;float D8 = 4698.63;float DE8 = 4978.03;float E8 = 5274.04;float F8 = 5587.65;float FG8 = 5919.91;float G8 = 6271.93;float GA8 = 6644.88;float A8 = 7040.00;float AB8 = 7458.62;float B8 = 7902.13;\n\n\n/**************************************\\\n|* Utilities                          *|\n\\**************************************/\n\n\n// Effects that return a float (such as attack, decay, sustain, release, adsr, volume, etc.) are multiplied by\n// the notes that you wish to modify with that effect\n\n// Effects that return a vec2 (such as panning, delay, reverb, etc.) are done after all the desired notes have \n// been played\n\n// More to come in the future!\n\n// A hacky linear decay\nfloat decay(float seqTime, float start, float length, float amount)\n{\n    return 1.0 - clamp((seqTime - start) / length, 0.0, amount);\n}\n\n// Pans the given instrument by a certain amount\n// Set amount to -1.0 for left-panning, set to 0.0 for center, set to 1.0 for right-panning\nvec2 pan(float inst, float amount)\n{\n    amount = (amount + 1.0) / 2.0;\n    return vec2(inst * (1.0 - amount), inst * amount);\n}\n\n\n/**************************************\\\n|* Main Song                          *|\n\\**************************************/\n\n\n\nvec2 measureA(float time);\nvec2 measureB(float time);\nvec2 measureC(float time);\nvec2 measureD(float time);\nvec2 measureE(float time);\nvec2 measureX(float time);\n\nvec2 mainSound( in int samp, float time )\n{\n    // 8 measure sequence\n    float seqTime = mod(time * rate / 4.0, 8.0);\n    \n    vec2 sound = vec2(0.0);\n    \n    float panAmount = mod(seqTime*8.0, 2.0)*0.125 - 0.0625;\n    \n    if(seqTime < 1.0){\n    \tsound += measureA(time);\n    }else if(seqTime < 2.0){\n        sound += measureB(time);\n    }else if(seqTime < 3.0){\n        sound += measureA(time);\n    }else if(seqTime < 4.0){\n        sound += measureC(time);\n    }else if(seqTime < 5.0){\n        sound += measureX(time);\n\t}else if(seqTime < 7.0){\n        sound += measureD(time);\n    }else if(seqTime < 8.0){\n        sound += measureE(time);\n    }\n    \n    return 0.1*pan(sound.x, panAmount);\n}\n\n\n/**************************************\\\n|* Individual Measures                *|\n\\**************************************/\n\n\nvec2 measureA(float time)\n{\n    float seqTime = mod(time * rate / 4.0, 1.0);\n    \n        float notes = \n        decay(seqTime, 0.0, 0.25, 0.5) * (\n\t\tnote(0.0, 0.25, seqTime) * sine(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.25, 0.5, 0.5) * (\n\t\tnote(0.25, 0.5, seqTime) * sine(A3, time) * 0.25) +\n            \n        decay(seqTime, 0.5, 0.75, 0.5) * (\n\t\tnote(0.5, 0.75, seqTime) * sine(AB3, time) * 0.25) +\n            \n        decay(seqTime, 0.75, 1.0, 0.5) * (\n\t\tnote(0.75, 1.0, seqTime) * sine(A3, time) * 0.25) \n            \n            \n        ;\n    \n    return vec2(notes);    \n}\n\nvec2 measureB(float time)\n{\n    float seqTime = mod(time * rate / 4.0, 1.0);\n    \n        float notes = \n        decay(seqTime, 0.0, 0.25, 0.5) * (\n\t\tnote(0.0, 0.25, seqTime) * sine(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.25, 1.0, 0.5) * (\n\t\tnote(0.25, 1.0, seqTime) * sine(F3, time) * 0.25)    \n            \n        ;\n    \n    return vec2(notes);    \n}\n\nvec2 measureC(float time)\n{\n    float seqTime = mod(time * rate / 4.0, 1.0);\n    \n        float notes = \n        decay(seqTime, 0.0, 0.25, 0.5) * (\n\t\tnote(0.0, 0.25, seqTime) * sine(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.25, 0.75, 0.5) * (\n\t\tnote(0.25, 0.75, seqTime) * sine(C4, time) * 0.25) +   \n        \n         decay(seqTime, 0.75, 1.0, 0.5) * (\n\t\tnote(0.75, 1.0, seqTime) * sine(F3, time) * 0.25    \n            \n        );\n\n   return vec2(notes);  \n}\n\nvec2 measureD(float time)\n{\n    float seqTime = mod(time * rate / 4.0, 1.0);\n    \n        float notes = \n        decay(seqTime, 0.0, 0.25, 0.5) * (\n\t\tnote(0.0, 0.25, seqTime) * square(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.25, 0.5, 0.5) * (\n\t\tnote(0.25, 0.5, seqTime) * square(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.5, 0.75, 0.5) * (\n\t\tnote(0.5, 0.75, seqTime) * square(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.75, 1.0, 0.5) * (\n\t\tnote(0.75, 1.0, seqTime) * square(F3, time) * 0.25    \n            \n        );\n\n   return vec2(notes); \n}\n\nvec2 measureE(float time)\n{\n    float seqTime = mod(time * rate / 4.0, 1.0);\n    \n        float notes = \n        decay(seqTime, 0.0, 1.0, 0.5) * (\n\t\tnote(0.0, 1.0, seqTime) * sine(G3, time) * 0.25)  \n        ;\n\n   return vec2(notes);\n       }\n\nvec2 measureX(float time)\n{\n    float seqTime = mod(time * rate / 4.0, 1.0);\n    \n        float notes = \n        decay(seqTime, 0.0, 0.25, 0.5) * (\n\t\tnote(0.0, 0.25, seqTime) * sine(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.25, 0.5, 0.5) * (\n\t\tnote(0.25, 0.5, seqTime) * sine(A3, time) * 0.25) +\n            \n        decay(seqTime, 0.5, 0.75, 0.5) * (\n\t\tnote(0.5, 0.75, seqTime) * sine(AB3, time) * 0.25) +\n            \n        decay(seqTime, 0.75, 1.0, 0.5) * (\n\t\tnote(0.75, 1.0, seqTime) * sine(A3, time) * 0.25) + \n            \n        decay(seqTime, 0.0, 0.25, 0.5) * (\n\t\tnote(0.0, 0.25, seqTime) * square(G3, time) * 0.25) +\n            \n        decay(seqTime, 0.25, 0.5, 0.5) * (\n\t\tnote(0.25, 0.5, seqTime) * square(A3, time) * 0.25) +\n            \n        decay(seqTime, 0.5, 0.75, 0.5) * (\n\t\tnote(0.5, 0.75, seqTime) * square(AB3, time) * 0.25) +\n            \n        decay(seqTime, 0.75, 1.0, 0.5) * (\n\t\tnote(0.75, 1.0, seqTime) * square(A3, time) * 0.25)\n            \n            \n        ;\n    \n    return vec2(notes);    \n}","name":"Sound","description":"","type":"sound"}]}