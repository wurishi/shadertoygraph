{"ver":"0.1","info":{"id":"slB3Ww","date":"1623997834","viewed":209,"name":"noita-style SandBox 2D","username":"yunhai","description":"my try for a sandbox simulation shader version\nidea came from GDC2019: noita's developer\n\n2021/9/11-updated:now you can make sand by LMB","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","pixelstyle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 C )\n{\n    O.rgb = TEX;  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 getBlockCol(vec2 pos){return getPixelCol(pos*BW);}\nvec3 getEnv(vec2 C)\n{\n    vec3 col=BG_COL;\n    float wall;\n    wall=step(C.y,BW)+step(iR.y-C.y,BW);\n    wall=mix(wall,1.,step(C.x-iR.x*.5,BW)*step(-BW,C.x-iR.x*.5));\n    wall=mix(wall,1.,step(C.x,BW)+step(iR.x-C.x,BW));\n    col+=wall*WALL_COL;\n    return col;\n}\nfloat rand(float t){return fract(sin(t*123.+21.)*987.);}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv=C/iR;\n    float t=iTime;\n    vec3 col=TEX;\n    \n    if(iFrame%FramePerUpdate==0)\n    {\n        vec2 pos=uv*nrs;\n        vec2 top=pos+vec2(0,1);\n        vec2 bot=pos+vec2(0,-1);\n        vec2 lft=pos+vec2(-1,0);\n        vec2 rit=pos+vec2(1,0);\n        vec2 lftop=uv*nrs+vec2(-1,1);\n        vec2 ritop=uv*nrs+vec2(1,1);\n        vec2 lfbot=uv*nrs+vec2(-1,-1);\n        vec2 ribot=uv*nrs+vec2(1,-1);\n\n        if(getPixelCol(C)==BG_COL)\n        {\n            col+=badd(C,SandUVPos*nrs+vec2(5.*sin(t),0.),SAND_COL);//creat sand origin\n            col+=badd(C,WaterUVPos*nrs+vec2(5.*sin(t),0.),WATER_COL);//creat water origin\n            #define TSAND(pos) (getBlockCol(pos)==SAND_COL)\n            #define TWATER(pos) (getBlockCol(pos)==WATER_COL)\n            #define TBG(pos) (getBlockCol(pos)==BG_COL)\n            if(TSAND(top)||\n               (TSAND(lft)&&TSAND(lftop))||\n               (TSAND(rit)&&TSAND(ritop)) )//create(move) sand\n                col=badd(C,pos,SAND_COL);\n            if(TWATER(top)||\n               (TWATER(lft)&&TWATER(lftop))||\n               (TWATER(rit)&&TWATER(ritop))||\n               (TWATER(lft)&&!TBG(lfbot)&&!TBG(bot)&&!TBG(lfbot+vec2(-2,-1)))||\n               (TWATER(rit)&&!TBG(ribot)&&!TBG(bot)&&!TBG(lfbot+vec2(2,-1))))//create(move) water\n                col=badd(C,pos,WATER_COL);\n        }\n        else if(getPixelCol(C)==SAND_COL)\n        {\n            \n            if(TBG(bot)||TBG(lfbot)||TBG(ribot))//clear sand\n                col=BG_COL;\n        }\n        else if(getPixelCol(C)==WATER_COL)\n        {\n            \n            if(TBG(bot)||\n               TBG(lfbot)||\n               TBG(ribot)||\n               (TBG(lft)&&(rand(t)>.5))||\n               (TBG(rit)&&(rand(t+100.)>.5)))//clear water\n                col=BG_COL;\n        }\n        \n    }\n    O.rgb=iFrame==0?getEnv(C):col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define iR iResolution.xy\n#define getPixelCol(coord) (texture(iChannel0,coord/iR).xyz)\nconst float BW=10.;//block width\nconst int FramePerUpdate=3;\nconst vec3 BG_COL=vec3(0.,0.,0.);\nconst vec3 SAND_COL=vec3(.9,.8,.1);\nconst vec3 WALL_COL=vec3(.5,.5,.5);\nconst vec3 WATER_COL=vec3(.2,.2,.7);\nconst vec2 SandUVPos=vec2(.25,.35);\nconst vec2 WaterUVPos=vec2(.75,.35);\nvec3 padd(vec2 coord,vec2 pos,vec3 col){return (int(coord.x)==int(pos.x))&&(int(coord.y)==int(pos.y))?col:vec3(0);}\nvec3 badd(vec2 coord,vec2 pos,vec3 col)//block add\n{\n    pos=floor(pos);\n    vec3 res=vec3(0);\n    for(float i=0.;i<BW-.1;i++)\n        for(float j=0.;j<BW-.1;j++)\n            res+=padd(coord,pos*BW+vec2(i,j),col);\n    return res;\n}\n\n#define nrs (iR/BW)//new draw resolution\n#define TEX (texelFetch(iChannel0,ivec2(C),0).rgb)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//deal with input\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    O.rgb=TEX;\n    if(iMouse.z>0.&&getPixelCol(iMouse.xy)==BG_COL&&iFrame%(2*FramePerUpdate)==0)\n        O.xyz+=badd(C,iMouse.xy/iR*nrs,SAND_COL);\n}","name":"Buffer B","description":"","type":"buffer"}]}