{"ver":"0.1","info":{"id":"lsy3Wt","date":"1456994949","viewed":778,"name":"Grassy field","username":"davidar","description":"Based on [url]https://www.shadertoy.com/view/MsV3D3[/url] and [url]https://www.shadertoy.com/view/XsVGz3[/url]","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["clouds","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// FastGrass\n// Created by Alexey Borisov / 2016\n// License: GPLv2\n\n// v1.01 added elevation (click and move)\n// v1.00 public release\n\n#define GRASS_CONTRAST (5.5)\n#define GRASS_SHADOW_CONTRAST (3.6)\n#define GRASS_CONTRAST_INV (1.0 / GRASS_CONTRAST)\n#define GRASS_SHADOW_CONTRAST_INV (1.0 / GRASS_SHADOW_CONTRAST)\n#define GRASS_WIDTH (0.04)\n#define GRASS_WIDTH_INV (1.0 / GRASS_WIDTH)\n#define GRASS_BENDING_AMP 5.0\n#define GRASS_BENDING_PERIOD 0.03\n#define GP2 0.4317\n\n#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(0.2, 0.1)\n\nvec3 sundir = normalize(vec3(1.0,0.75,1.0));\n\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    p.xz += WIND * iTime;\n    vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n    vec2 rg = texture(iChannel0, (uv + 0.5)/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.y);\n}\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    // add animation\n    //p = p - vec3(1.0, 1.0, 0.0) * iTime * 0.1;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    \n    return f;\n}\n\nfloat density(vec3 pos)\n{    \n    float den = 3.0 * fractal_noise(pos * 0.3) - 2.0 + (pos.y - MIN_HEIGHT);\n    float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n    edge *= edge;\n    den *= edge;\n    den = clamp(den, 0.0, 1.0);\n    \n    return den;\n}\n\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol)\n{   \n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 40; i++) {\n        if (sum.a > 0.99 || \n            pos.y < (MIN_HEIGHT-1.0) || \n            pos.y > (MAX_HEIGHT+1.0)) break;\n        \n        float den = density(pos);\n        \n        if (den > 0.01) {\n            float dif = clamp((den - density(pos+0.3*sundir))/0.6, 0.0, 1.0);\n\n            vec3 lin = vec3(0.65,0.7,0.75)*1.5 + vec3(1.0, 0.6, 0.3)*dif;        \n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.1, vec3(0.35,0.4,0.45), den), den);\n            col.rgb *= lin;\n\n            // front to back blending    \n            col.a *= 0.5;\n            col.rgb *= col.a;\n\n            sum = sum + col*(1.0 - sum.a); \n        }\n        \n        t += max(0.05, 0.02 * t);\n        pos = ro + rd * t;\n    }\n    \n    sum = clamp(sum, 0.0, 1.0);\n    \n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    \n    return mix(backCol, sum.xyz, sum.a);\n}\n\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid skyImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    vec2 mo = vec2(0.0);\n    \n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    \n    // Rotate the camera\n    vec3 target = vec3(ro.x+10., 1.0+mo.y*3.0, ro.z);\n    \n    vec2 cossin = vec2(cos(mo.x), sin(mo.x));\n    mat3 rot = mat3(cossin.x, 0.0, -cossin.y,\n                   \t0.0, 1.0, 0.0,\n                   \tcossin.y, 0.0, cossin.x);\n    target = rot * (target - ro) + ro;\n    \n    // Compute the ray\n    vec3 rd = setCamera(ro, target, 0.0) * normalize(vec3(p.xy, 1.5));\n    \n    float dist = planeIntersect(ro, rd, MIN_HEIGHT);\n    \n    float sun = clamp(dot(sundir, rd), 0.0, 1.0);\n\tvec3 col = mix(vec3(0.78,0.78,0.7), vec3(0.3,0.4,0.5), p.y * 0.5 + 0.5);\n\tcol += 0.5*vec3(1.0,0.5,0.1)*pow(sun, 8.0);\n    \n    if (dist > 0.0) {\n        col = raymarching(ro, rd, dist, col);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvec4 get_grass(vec2 uv, float seed)\n{\n    if (uv.y > 1.0)\n        return vec4(0.0);\n    else if (uv.y < 0.0)\n        return vec4(1.0);\n    else \n    {        \n        float seed2 = seed * 11.2;\n        float seed3 = seed * 3.621 - 43.32;\n        float bending = abs(0.5 - fract(seed2 + uv.x * GRASS_BENDING_PERIOD * GRASS_WIDTH_INV)) - 0.25;\n        uv.x += GRASS_WIDTH * GRASS_BENDING_AMP * 4.0 * uv.y * uv.y * uv.y * bending;\n        float shadowX = uv.x - uv.y * (0.25 + fract(seed2) * 0.22);\n        float top = 4.0 * abs(0.5 - fract(seed + uv.x * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 + uv.x * GRASS_WIDTH_INV * GP2));\n        float topB= 4.0 * abs(0.5 - fract(seed + (uv.x + 0.005) * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 + (uv.x - 0.009) * GRASS_WIDTH_INV * GP2));\n        float topR= 4.0 * abs(0.5 - fract(seed + (uv.x + 0.006) * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 + (uv.x + 0.009) * GRASS_WIDTH_INV * GP2));\n        float topS= 2.5 * abs(0.5 - fract(seed + 0.7 * (shadowX + 0.31) * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 +  0.7 * (shadowX + 0.161) * GRASS_WIDTH_INV * GP2));\n        uv.y = uv.y * uv.y;\n        float alpha = GRASS_CONTRAST * (uv.y - (1.0 - GRASS_CONTRAST_INV) * top);\n        float bright = GRASS_CONTRAST * (uv.y - topB);\n        float bright2 = GRASS_CONTRAST * (uv.y - topR);\n        float shadow = GRASS_SHADOW_CONTRAST * (uv.y - (1.0 - GRASS_SHADOW_CONTRAST_INV) * topS);\n        return clamp(vec4(1.0 - alpha, bright, 1.0 - shadow, bright2), 0.0, 1.0);\n    }\n}\n\nvoid mainImage(out vec4 result, in vec2 fragCoord)\n{\n    float t = iTime/5.;\n    result = vec4(0, 0, 0, 1);\n    fragCoord -= iResolution.xy * 0.5;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv.y += 0.35 * (1. + cos(t));\n    \n    float elevation = 1.;//iMouse.y / iResolution.y;\n    \n    uv.y += 0.3 - elevation * 0.8;\n    uv.y *= 1.8;\n    float k = 1.0;\n    \n    vec3 grassColor = vec3(0.4, 0.9, 0.1);\n    vec3 grassBackColor = grassColor * (0.25 + elevation * 0.2);\n    vec3 grassColorR = vec3(0.6, 0.7, 0.3);\n    vec3 grassShadow = grassColor * vec3(0.15, 0.2, 0.9);\n    \n    float pos = iTime * 3.0;\n    float iPos = floor(pos);\n    float fPos = fract(pos);\n    \n    uv.x += sin(pos * 0.3) * 0.4;\n     \n    //vec3 c = mix(vec3(0.53, 0.63, 0.78), vec3(0.42, 0.52, 0.65), uv.y - uv.x * 0.5);\n    vec4 skycol;\n    skyImage(skycol, (uv + 0.5) * iResolution.y);\n    vec3 c = skycol.rgb;\n    \n    for (int i = 50; i >= 0; i--)\n    {\n        float dist = (float(i) - fPos) / (60. + 40. * cos(t));\n        vec2 uv2 = uv;\n        uv2 *= 0.15 + dist * 1.4;\n        uv2 *= 6. + 4. * cos(t);\n        uv2.y += elevation + 0.45 - dist * (0.5 + elevation);\n        vec4 grass = get_grass(uv2, fract((iPos + float(i)) * 43.2423));\n        vec3 color = mix(grassBackColor, grassColor, grass.y);\n        color = mix(color, grassColorR, grass.w);\n        color = mix(color, grassShadow, grass.z);\n        if (i == 0)\n            grass.x *= smoothstep(0.0, 1.0, 1.0 - fPos);\n        if (i == 50)\n            grass.x *= fPos;\n        c = mix(c, color, grass.x);\n    }\n       \n\tresult = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}