{"ver":"0.1","info":{"id":"wllczj","date":"1592573939","viewed":234,"name":"deep-sea mandelbox","username":"wj","description":"This is a stripped down version of a shader that  I had used here: https://youtu.be/0RuYh-5gRGk\n\nThe basic algorithm is very simular to what was used in an old version of Fractal Lab and I thought it might be useful to have it here on shadertoy.","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","mandelbox","ambientocclusion","blinnbong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlBSRR","filepath":"https://soundcloud.com/wright-and-bastard/clara-bitfellas-analysis-evoke-2016","previewfilepath":"https://soundcloud.com/wright-and-bastard/clara-bitfellas-analysis-evoke-2016","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// deep-sea mandelbox\n// by wj\n// \n// This is a stripped down version of a shader I had used on my 2017 page:\n// https://www.wothke.ch/modum\n//\n// The code is rather verbose and it might be useful to play around with\n// here on shadertoy.\n//\n// It is heavily based on the logic from an old version of Fractal Lab \n// (see http://www.subblue.com). Copyright 2011, Tom Beddard\n// \n// I am therefore using the same licence here that Tom Beddard's \n// respective code had used:\n//\n// Licensed under the GPL Version 3 license.\n// http://www.gnu.org/licenses/\n\nprecision highp float;\n\n#define HALFPI 1.570796\n#define MIN_EPSILON 6e-7\n#define MIN_NORM 1.5e-7\n\n#define maxIterations 15                              // 1 to 30\n#define stepLimit 105                                 // 10 to 300\n#define aoIterations 3                                // 0 to 10\n\n#define minRange 6e-5\n\n\t\t\t\n// fractal params\t\t\t\nconst float deFactor= 1.;                             // 0 to 1\nconst float scale= -2.81;                             // -10 to 10\nconst float surfaceDetail= 0.66;                      // 0.1 to 2\nconst float surfaceSmoothness= 0.79;                  // 0.01 to 1\nconst float boundingRadius= 114.02;                   // 0.1 to 150\nconst vec3 offset= vec3(0., 0., 0.);                  // -3 to 3\n\nconst float sphereScale= 1.;                          // 0.01 to 3\nfloat boxScale= 0.5;                                  // 0.01 to 3\nconst float boxFold= 1.;                              // 0.01 to 3\nconst float fudgeFactor= 0.;                          // 0 to 100\n\nfloat glitch;                                         // 0 to 0.02\n\n// unused..  uncomment if needed\n//mat3  objectRotation;\n//mat3  fractalRotation1;\n//mat3  fractalRotation2;\n\n// color\nconst int   colorIterations= 3;                       // 0 to 30\nconst vec3  color1= vec3(0.4, 0.3, 0.9);\nconst float color1Intensity= 2.946;                   // 0 to 3 \nconst vec3  color2= vec3(0.1, 0.1803, 0.1);\nconst float color2Intensity= 0.16;                    // 0 to 3\nconst vec3  color3= vec3(0.3, 0.3, 0.9);\nconst float color3Intensity= 0.11;                    // 0 to 3\nconst bool  transparent= false;                       // transparent background\nconst float gamma= 0.799;                             // gamma correction; 0.1 to 2\n\n// lights\nconst vec3  light= vec3(48, 191, -198);               // light position\nconst vec2  ambientColor= vec2(0.41, 0);              // ambient intensity, ambient color\nconst vec3  background1Color= vec3(0.7882, 1, 1);\nconst vec3  background2Color= vec3(0,0,0);            // background bottom\n\n// glow\nconst vec3  innerGlowColor= vec3(0.23, 0.249, 0.9019);\nconst float innerGlowIntensity= 0.24;                 // 0, 1\nconst vec3  outerGlowColor= vec3(1.0, 1.0, 1.0);\nconst float outerGlowIntensity= 0.08;                 // 0, 1\n\n// fog\nconst float fogIntensity= 0.06;                       // 0, 1\nconst float fogFalloff= 2.8;                          // 0, 10\n\n// shinyness\nconst float specularity= 0.86;                        // 0, 3\nconst float specularExponent= 7.0;                    // 0, 50\n\n// ambient occlusion\nconst float aoIntensity= 0.21;                        // 0 to 1\nconst float aoSpread= 11.79;                          // 0 to 20\n\n// camera\nconst float cameraFocalLength= 0.9;                   // 0.1 to 3\nfloat fovfactor;                                      // field of view\nvec3 cameraPosition;\nmat3  cameraRotation;\n\nfloat aspectRatio;\nfloat pixelScale;\nfloat epsfactor;\n\nvec2  size;\nvec2  halfSize;\n\nvec3  w = vec3(0, 0, 1);\nvec3  v = vec3(0, 1, 0);\nvec3  u = vec3(1, 0, 0);\n\n\n// Pre-calculations\nfloat mR2;                                           // Min radius\nfloat fR2;                                           // Fixed radius\nvec2  scaleFactor;\n\t\t\t\t\t\t\n\n// Details about the Mandelbox DE algorithm:\n// http://www.fractalforums.com/3d-fractal-generation/a-mandelbox-distance-estimate-formula/\nvec3 Mandelbox(vec3 w)\n{\n//    w *= objectRotation;\n    float md = 1000.0;\n    vec3 c = w;\n\t\t\t\t\n\t// distance estimate\n    vec4 p = vec4(w.xyz, deFactor),\n        p0 = vec4(w.xyz, 1.0);  // p.w is knighty's DEfactor\n\t\t\t\t\n    for (int i = 0; i < int(maxIterations); i++) {\n\t\t// box fold:\n        p.xyz = clamp(p.xyz, -boxFold, boxFold) * 2.0 * boxFold - p.xyz;  // box fold\n//        p.xyz *= fractalRotation1;\n\t\t\t\t\t\n\t\t// sphere fold:\n        float d = dot(p.xyz, p.xyz);\n        p.xyzw *= clamp(max(fR2 / d, mR2), 0.0, 1.0);  // sphere fold\n\t\t\t\t\t\n        p.xyzw = p * scaleFactor.xxxy + p0 + vec4(offset, 0.0);\n//        p.xyz *= fractalRotation2;\n\n        if (i < colorIterations) {\n            md = min(md, d);\n            c = p.xyz;\n        }\n    }\n\t\t\t\t\n\t// Return distance estimate, min distance, fractional iteration count\n    return vec3((length(p.xyz) - fudgeFactor) / p.w, md, 0.33 * log(dot(c, c)) + 1.0);\n}\n\n\n// Define the ray direction from the pixel coordinates\nvec3 rayDirection(vec2 pixel)\n{\n    vec2 p = (0.5 * halfSize - pixel) / vec2(halfSize.x, -halfSize.y);\n    p.x *= aspectRatio;\n    vec3 d = (p.x * u + p.y * v - cameraFocalLength * w);\n    return normalize(cameraRotation * d);\n}\n\n\n// Intersect bounding sphere\n//\n// If we intersect then set the tmin and tmax values to set the start and\n// end distances the ray should traverse.\nbool intersectBoundingSphere(vec3 origin,\n                             vec3 direction,\n                             out float tmin,\n                             out float tmax)\n{\n    bool hit = false;\n    float b = dot(origin, direction);\n    float c = dot(origin, origin) - boundingRadius;\n    float disc = b*b - c;           // discriminant\n    tmin = tmax = 0.0;\n\n    if (disc > 0.0) {\n\t\t// Real root of disc, so intersection\n        float sdisc = sqrt(disc);\n        float t0 = -b - sdisc;          // closest intersection distance\n        float t1 = -b + sdisc;          // furthest intersection distance\n\n        if (t0 >= 0.0) {\n\t\t\t// Ray intersects front of sphere\n            tmin = t0;\n            tmax = t0 + t1;\n        } else {\n\t\t\t// Ray starts inside sphere\n            tmax = t1;\n        }\n        hit = true;\n    }\n\n    return hit;\n}\n\n// Calculate the gradient in each dimension from the intersection point\nvec3 generateNormal(vec3 z, float d)\n{\n    float e = max(d * 0.5, MIN_NORM);\n\t\t\t\t\n    float dx1 = Mandelbox(z + vec3(e, 0, 0)).x;\n    float dx2 = Mandelbox(z - vec3(e, 0, 0)).x;\n\t\t\t\t\n    float dy1 = Mandelbox(z + vec3(0, e, 0)).x;\n    float dy2 = Mandelbox(z - vec3(0, e, 0)).x;\n\t\t\t\t\n    float dz1 = Mandelbox(z + vec3(0, 0, e)).x;\n    float dz2 = Mandelbox(z - vec3(0, 0, e)).x;\n\t\t\t\t\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\n\n// Blinn phong shading model\n// http://en.wikipedia.org/wiki/BlinnPhong_shading_model\n// base color, incident, point of intersection, normal\nvec3 blinnPhong(vec3 color, vec3 p, vec3 n)\n{\n\t\t\t\t// Ambient colour based on background gradient\n    vec3 ambColor = clamp(mix(background2Color, background1Color, (sin(n.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0);\n    ambColor = mix(vec3(ambientColor.x), ambColor, ambientColor.y);\n\t\t\t\t\n    vec3  halfLV = normalize(light - p);\n    float diffuse = max(dot(n, halfLV), 0.0);\n    float specular = pow(diffuse, specularExponent);\n\t\t\t\t\n    return ambColor * color + color * diffuse + specular * specularity;\n}\n\n// Ambient occlusion approximation.\n// Based upon boxplorer's implementation which is derived from:\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat ambientOcclusion(vec3 p, vec3 n, float eps)\n{\n    float o = 1.0;                  // Start at full output colour intensity\n    eps *= aoSpread;                // Spread diffuses the effect\n    float k = aoIntensity / eps;    // Set intensity factor\n    float d = 2.0 * eps;            // Start ray a little off the surface\n\t\t\t\t\n    for (int i = 0; i < aoIterations; ++i) {\n        o -= (d - Mandelbox(p + n * d).x) * k;\n        d += eps;\n        k *= 0.5;                   // AO contribution drops as we move further from the surface \n    }\n\t\t\t\t\n    return clamp(o, 0.0, 1.0);\n}\n\n// Calculate the output color for each input pixel\nvec4 render(vec2 pixel)\n{\n    vec3  ray_direction = rayDirection(pixel);\n\t\n    float ray_length = minRange;\n    vec3  ray = cameraPosition + ray_length * ray_direction;\n    vec4  bg_color = vec4(clamp(mix(background2Color, background1Color, (sin(ray_direction.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0), 1.0);\n    vec4  color = bg_color;\n\t\t\t\t\n    float eps = MIN_EPSILON;\n    vec3  dist;\n    vec3  normal = vec3(0);\n    int   steps = 0;\n    bool  hit = false;\n    float tmin = 0.0;\t// 'out' params of intersectBoundingSphere()\n    float tmax = 0.0;\n\t\t\t\n    if (intersectBoundingSphere(ray, ray_direction, tmin, tmax)) {\n        ray_length = tmin;\n        ray = cameraPosition + ray_length * ray_direction;\n\n\t   \tvec3  lastDist= vec3(0.,0.,0.);\n\t\t\t\n        for (int i = 0; i < stepLimit; i++) {\n            steps = i;\n            dist = Mandelbox(ray);\n            dist.x *= surfaceSmoothness;\n\t\t\t\t\t\t\n\t\t\t// If we hit the surface on the previous step check again to make sure it wasn't\n\t\t\t// just a thin filament\n            if (hit && dist.x < eps || ray_length > tmax || ray_length < tmin) {\t// XXX ray_length < tmin impossible!\n                steps--;\n                break;\n            }\n\t\t\t\t\t\t\n            hit = false;\n            ray_length += dist.x;\t// XXX dist.x is always positive...\n            ray = cameraPosition + ray_length * ray_direction;\n            eps = ray_length * epsfactor;\n\n\t\t\t// add-on effect hack: \"distant\" stuff turns into water... \t\t\t\n\t\t\tif (ray_length > 0.1) {\n\t\t\t\tray_length+=glitch;\n\t\t\t\thit = true;\n\t\t\t} else if (dist.x < eps || ray_length < tmin) {\n\t\t\t\thit = true;\t// normal mode\n\t\t\t\tlastDist= dist;\t\t\t\n\t\t\t}\n    \t}\n    }\n\t\t\t\t\n\t// Found intersection?\n    float glowAmount = float(steps)/float(stepLimit);\n    float glow;\n\t\t\t\t\n    if (hit) {\n        float aof = 1.0, shadows = 1.0;\n        glow = clamp(glowAmount * innerGlowIntensity * 3.0, 0.0, 1.0);\n\n        if (steps < 1 || ray_length < tmin) {\n            normal = normalize(ray);\n        } else {\n            normal = generateNormal(ray, eps);\n            aof = ambientOcclusion(ray, normal, eps);\n        }\n\t\t\t\t\t\n        color.rgb = mix(color1, mix(color2, color3, dist.y * color2Intensity), dist.z * color3Intensity);\n        color.rgb = blinnPhong(clamp(color.rgb * color1Intensity, 0.0, 1.0), ray, normal);\n        color.rgb *= aof;\n        color.rgb = mix(color.rgb, innerGlowColor, glow);\n\t\t\t\n\t\t// make details disapear in the distant fog\n        color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(abs(ray_length * exp(fogFalloff)), 2.0) * fogIntensity));\n        color.a = 1.0;\n    } else {\n\t\t// Apply outer glow and fog\n        ray_length = tmax;\n        color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(abs(ray_length * exp(fogFalloff)), 2.0)) * fogIntensity);\n        glow = clamp(glowAmount * outerGlowIntensity * 3.0, 0.0, 1.0);\n\t\t\t\t\t\n        color.rgb = mix(color.rgb, outerGlowColor, glow);\n        if (transparent) color = vec4(0.0);\n    }\n    return color; \n}\n\n// Return rotation matrix for rotating around vector v by angle\nmat3 rotationMatrixVector(vec3 v, float angle)\n{\n    float c = cos(radians(angle));\n    float s = sin(radians(angle));\n\t\t\t\t\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n              (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n              (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t// size of generated texture   \n\tsize = iResolution.xy;\n\thalfSize= size/2.0;\n\t   \n\t// setup camera\n    vec3 dir= vec3(20.*sin(iTime*.33), 20.*sin(iTime*.33), -22.); \t// 180= full circle\n\tcameraPosition= vec3( 0.17963 + sin(iTime*.1)*.4, \n\t\t\t\t\t\t  0.099261, \n\t\t\t\t\t\t -1.3678434 + sin(iTime*.05)*.2);\t\n\t\t\n    cameraRotation= \trotationMatrixVector(u, dir.x) *\n        \t\t\t\trotationMatrixVector(v, dir.y) * \n        \t\t\t\trotationMatrixVector(w, dir.z);\n\t\n    fovfactor = 1.0 / sqrt(1.0 + cameraFocalLength * cameraFocalLength);\n\taspectRatio = size.x / size.y;\n\tpixelScale = 1.0 / min(size.x, size.y);\n\tepsfactor = 2.0 * fovfactor * pixelScale * surfaceDetail;\n\n\t// animate box scale\n    float freq= 1.0;\t// 0 to 512\t(use some bass frequeny)\n\tfloat fft= texelFetch( iChannel0, ivec2(freq,0), 0 ).x; \n\tboxScale= 0.5 + fft*0.03;\n    \n\t\t// update derived fractal\n\tmR2 = boxScale * boxScale;\n\tfR2 = sphereScale * mR2;\n\tscaleFactor = vec2(scale, abs(scale)) / mR2;\n\t\n\t\n\t// throw in glitch effect once in a while \n\tfloat m= mod(iTime*.2, 2.0); \n    if (m <= 1.0) {\n\t\tglitch= 0.002*(2.0-(cos(m*HALFPI*4.)+1.0));\n    } else {\n\t\tglitch= 0.00;\n\t}\n\t\t\t\t\t\t\n    vec4 color = render(fragCoord);\t// do without antialiasing to limit GPU load\t\t\t\t\n\tfragColor = vec4(pow(abs(color.rgb), vec3(1.0 / gamma)), color.a);\n}\n","name":"Image","description":"","type":"image"}]}