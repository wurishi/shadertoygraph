{"ver":"0.1","info":{"id":"XXVSWy","date":"1720447489","viewed":60,"name":"i=n^i","username":"ozazl","description":"fractal inspired by life.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Function to compute rotation matrix in 3D\nmat3 rotationMatrix(float angle, vec3 axis) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(\n        oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n    );\n}\n\n// Function to compute the distance from a point to the fractal surface\nfloat fractalDistance(vec3 p) {\n    float scale = 20.0;\n    float dist = length(p);\n    vec3 offset = vec3(1.0, 1.0, 1.0);\n    \n    for (int i = 0; i < 8; i++) {\n        p = abs(p) - offset;\n        p = rotationMatrix(iTime * 0.1, vec3(1.0, 1.0, 1.0)) * p;\n        dist = length(p) / scale;\n    }\n    return dist;\n}\n\n// Function to perform ray marching\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = fractalDistance(p);\n        dO += dS;\n        if (dS < 0.001) break;\n    }\n    return dO;\n}\n\n// Function to compute the normal at a point\nvec3 getNormal(vec3 p) {\n    float d = fractalDistance(p);\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = d - vec3(\n        fractalDistance(p - e.xyy),\n        fractalDistance(p - e.yxy),\n        fractalDistance(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(3.0, 3.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = getNormal(p);\n    vec3 lightDir = normalize(vec3(2.0, 4.0, 1.0));\n    float diff = max(dot(n, lightDir), 0.0);\n    \n    vec3 col = vec3(0.0);\n    if (d < 10.0) {\n        col = vec3(diff);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}