{"ver":"0.1","info":{"id":"Mc2yW3","date":"1723091354","viewed":90,"name":"Drop 03 - Polar rain explained","username":"Elsio","description":"click to see the grid","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["grid","raymarch","balls"],"hasliked":0,"parentid":"XfjcWV","parentname":"Drop 03 - march without loop!"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h11(a) fract(sin(a * 453.2734) * 994.3434)\n\nfloat cell(vec2 p){\n    return max(\n               length(max(abs(p) - vec2(.11), 0.)),\n               -length(p) + .11\n           );\n}\n\nfloat sph(vec2 p){\n    if(iMouse.z < .40)\n        return length(p) - .11;\n    \n    return min(abs(length(p) - .1),\n                length(p) - .011);\n}\n\nfloat objs(vec2 p) {\n    vec2  w = vec2(3.14 / 13.);\n    \n    float t, id, fw,\n          l = length(p),\n          h = 22.;\n    \n    // assim como em 'drop 01', onde separamos colunas de objetos\n    // aqui utilizaremos coordenadas polares, \n    // onde as colunas são 'fatias', setores circulares, definidos por atan()\n    p.x = atan(p.y, p.x);\n    \n    // cada fatia tem seu tamanho definido por w.x \n    // e a identificação de cada fatia é feita usando floor()\n    id  = floor(p.x / w.x); \n    \n    // usando h11() e tendo `id` como parâmetro \n    // podemos individualizar um valor de t para cada fatia.\n    t  = h11(id) + iTime * .4  ;\n    \n    // `fw` é o coração do algoritmo. O valor é uma propriedade da fatia.\n    // calculado a partir de `t`, esta propriedade nos ajuda a definir\n    // para cada fragmento, qual a posição dele em relação a grade\n    // e também, qual animação aplicar. \n    fw = fract(t) * w.y;\n    \n    // no início, definimos `p.x` como o ângulo do fragmento em relação a origem\n    // agora, definimos `p.y` como o log da distância do fragmento a origem\n    // ao somar `fw` estamos definindo um limite entre os dois tipos de animação \n    // que estamos lidando. a saber: a animação do objeto único acima do limite\n    // e a animação da fila de objetos que deslizam juntos e lentamente \n    // em direção ao centro.\n    // o componente sen() oferece um tipo de variação extra nesse limite.\n    p.y = log(l) + fw + sin(id + t) * .3;\n    \n    \n    // O teste diferencia a qual das animações o fragmento atual pertence.\n    // se `p.y` estiver acima de zero (depois da soma na linha acima)\n    // significa que o objeto está em queda. Caso contrário o objeto deverá\n    // juntar-se aos outros, na posição adequada, para iniciar a descida lenta.\n    if(p.y < .0)\n        h = 1.;\n    \n    // A linha abaixo só será executada caso o fragmento represente um objeto\n    // posicionado na parte de cima do limite determinado por `fw`.\n    // em caso contrário, `h = 1` torna esse incremento nulo.\n    // por outro lado, se o fragmento representa um objeto abaixo do limite,\n    // esta linha incrementa em `p.y` um valor de `h` \n    // proporcional ao ofset da animação, determinado por `fw`\n    p.y += (h / 2. - .5) * fw;\n\n    // se `h`, neste momento for diferente de 1, o estaço dedicado ao objeto é maior\n    // e a sua posição depende da posição do fragmento em relação a célula.\n    w.y *= h;\n    \n    // por último, a explicação do porque `w` é do tipo vec2()\n    // ao particionar espaço do objeto com mod() temos a sua componente `x`\n    // que define o ângulo do objeto e a componente `y` que particiona a fatia\n    // em direção ao centro. Ao usar um vec2() \n    // podemos fazer as duas partições ao mesmo tempo.\n    p = mod(p, w) - w / 2.;\n    \n    // convém observar no link abaixo, como é feita a partição de espaço\n    // para objestos posicionados em coordenadas polares usando \n    //\n    //    p = vec2(\n    //       log(length(p)),\n    //       atan(p.y, p.x)\n    //   );\n    //   p = mod(p, w) - w/2.;\n    //\n    // https://www.shadertoy.com/view/lcSyWV\n    //\n    // convém também analisar como o algoritmo original se comporta\n    // utilizando coordenadas cartesianas:\n    //\n    // https://www.shadertoy.com/view/4fByDV\n    //\n    // A versão com coordenadas polares é ligeiramente mais complexa\n    // mas, essencialmente igual. Exige pensar um pouco mais.\n    \n    return l * sph(p);\n}\n\n\nfloat grid(vec2 p) {\n    float t, id, fw,\n          l = length(p),\n          w = 3.14 / 13.,\n          h = 1.;\n        \n    p.x = atan(p.y, p.x);\n    id  = floor(p.x / w);\n    t   = h11(id) + iTime * .4;\n    p.y = log(l) + fract(t) * w + sin(id + t) * .3;\n    p   = mod(p, w) - w / 2.;\n    return l * cell(p);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy; \n         u = vec2(u + u - r) / r.y;\n    \n    o = vec4(0);\n    //if(iMouse.z > 40.) \n        o += vec4(smoothstep(.0, 3. / r.y, grid(u))) * .2;\n    o += vec4(smoothstep(3. / r.y, .0, objs(u)));\n}\n\n\n\n\n\n/*\n        Eternamente grato ao @Hyeve\n        que me possibilitou chegar nesse algoritmo\n\n            Crystal Ball Rainfall \n            https://www.shadertoy.com/view/NdV3Dw\n\n                from @tater... \n                    Sea of Pearls \n                    https://www.shadertoy.com/view/fsV3WD\n\n\n        ...eu sei, tá irreconhecível, mas\n        o algoritmo atual é uma refatoração dele\n\n*/\n\n","name":"Image","description":"","type":"image"}]}