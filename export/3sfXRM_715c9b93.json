{"ver":"0.1","info":{"id":"3sfXRM","date":"1550790077","viewed":312,"name":"[TWITCH] Fountain","username":"Flopine","description":"This shader was coded during a live twitch session on 21/02. \nI wanted to experiment on scenery again :)","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting","specular","geometry","liquid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI  3.141592\n#define time iTime\n\nfloat rand (vec2 st)\n{return fract(sin(dot(st, vec2(12.181, 35.154)))*2445.458);}\n\n\nfloat stmin (float a, float b, float k , float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\n// iq smooth minimum function: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.z,max(q.x,q.y))) + length(max(q,0.));\n}\n\nfloat cylH (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\n// iq hexagonal function : https://iquilezles.org/articles/distfunctions\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n        length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n        p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat od (vec3 p, float d)\n{\n    p.xz *= rot(time);\n    p.yz *= rot(time);\n    return dot(p, normalize(sign(p)))-d;\n}\n\n\nfloat vortex (vec3 p)\n{\n    p *= 2.;\n    p.xz *= rot(p.y + time);\n    //p.x += sin(p.y);\n    p.y += sin(p.x*0.8 + p.y*1.5+ time);\n    p.x += sin(p.y+time*2.);\n    return cylH(p.xzy, 5.-p.y*0.6, 8.)/2.;\n}\n\nfloat g1 = 0.;\nfloat ball(vec3 p)\n{\n    float d = length(p)-1.3;\n    g1 += 0.1/(0.1*d*d);\n    return d;\n}\n\nfloat water (vec3 p)\n{\n\n    p.y -= .5;\n    float s = ball (vec3(p.x, p.y-4.+sin(time)*0.5, p.z));\n    float v = vortex(p);\n    p.y += sin(length(p.xz*2.)-time)*0.1;\n    return smin(smin(v, s, 3.), max(sdHexPrism(p.xzy, vec2(4.2, 2.)),abs(p.y)-0.5), 15.);\n}\n\nfloat pillars (vec3 p)\n{\n    p.x = abs(p.x);\n    p.z -= 2.;\n    p.x -= 8.8;\n    p.y -= 2.;\n    return box(p, vec3(0.5+abs(p.y)*0.3, 2., 0.5+abs(p.y)*0.3));\n}\n\nfloat gems (vec3 p)\n{\n    p.x = abs(p.x);\n    p.z -= 2.;\n    p.x -= 8.8;\n    p.y -= 6.;\n    return od(p,.8);\n}\n\nfloat background (vec3 p)\n{\n    float b = -box(vec3(p.x, p.y-15., p.z+45.), vec3(13.,15., 50));\n    float h1 = max(-sdHexPrism(p.xzy, vec2(4.2, 2.)),sdHexPrism(p.xzy, vec2(5., 1.5)));\n    return stmin(pillars(p),stmin(h1,b, 1. , 3.),0.5, 3.);\n}\n\nint mat = 0;\nfloat SDF (vec3 p)\n{\n    float g = gems(p);\n    float b = background(p);\n    float w = water(p);\n    float d = min(g,min(b, w));\n    // tricks learned during YX stream\n    if (d == b) mat = 1;\n    if (d == g) mat = 2;\n    if (d == w) mat = 3; \n    return d;\n}\n\nvec3 get_cam (vec3 ro, vec3 target, vec2  uv, float fov)\n{\n    vec3 forward = normalize(target-ro);\n    vec3 left = normalize(cross(vec3(0.,1.,0.), forward));\n    vec3 up = normalize(cross(forward, left));\n    return normalize(forward*fov + left*uv.x + up*uv.y);\n}\n\nvec3 norms (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy) - SDF(p-eps.xyy),\n                          SDF(p+eps.yxy) - SDF(p-eps.yxy),\n                          SDF(p+eps.yyx) - SDF(p-eps.yyx)\n                         )\n                    );\n}\n\nfloat dir_light(vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5 + 0.5;}\n\nfloat point_light (vec3 p, vec3 n, vec3 lpos)\n{\n    vec3 ldir = normalize(lpos-p);\n    float att = length(lpos-p);\n    float dotNL = dot(n, ldir)*0.5+0.5;\n    return dotNL / ((0.1*att*att));\n}\n\nfloat spec_light (vec3 l, vec3 rd, vec3 n, float spec_power)\n{\n    vec3 h = normalize(l - rd);\n    float spe = pow(max(dot(h,n),0.),spec_power);\n    return spe;\n}\n\nfloat fresnel (vec3 rd, vec3 n, float fre_power)\n{\n    return pow(1.-clamp(dot(n, -rd), 0., 1.), fre_power);\n}\n\nvoid back_mat (inout vec3 col, vec3 n, vec3 p ,vec3 rd)\n{\n    vec3 dir_pos = vec3(-2.,5,5.);\n    col = mix(vec3(0.3,0.1,0.2), vec3(0.3,0.6,0.8), dir_light(n, dir_pos));\n}\n\nvoid water_mat(inout vec3 col, vec3 n, vec3 p , vec3 rd)\n{\n    vec3 point_pos = vec3(0.,5., -5.);\n    vec3 light_dir = normalize(vec3(0.,12., 4.));\n    col += fresnel (rd, n, 3.)*vec3(0.3,0.1,.2);\n    col += spec_light(light_dir, rd, n , 20.);\n    col += point_light(p, n, point_pos)*vec3(0.3,0.6,0.8);\n}\n\nvoid gems_mat (inout vec3 col, vec3 n, vec3 p , vec3 rd)\n{\n    vec3 dir_pos = vec3(0.,3.,-5.);\n    col += fresnel (rd, n, 1.5)*vec3(0.3,0.1,0.8);\n    col += spec_light(dir_pos, rd, n , 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = rand(uv);\n\n    vec3 ro = vec3(-3.,7., -14); vec3 p = ro;\n    vec3 target = vec3(0., 2., 0.);\n    vec3 rd = get_cam(ro, target, uv, 1.);\n    vec3 col = vec3(0.);\n\n    bool hit = false;\n    float shad = 0.;\n    for(float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.5 + dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = norms(p);\n        if (mat == 1) back_mat(col, n, p, rd);\n        if (mat == 2)\n        {\n            col = vec3(0.1,0.5,0.3);\n            gems_mat(col, n, p, rd);\n        } \n        if (mat == 3) \n        {\n            col = vec3(0.4);\n            water_mat(col, n, p, rd);\n        }\n    }\n    // fake AO\n    col *= 1.-shad;\n    fragColor = vec4(pow(col, vec3(1.2)),1.);\n}","name":"Image","description":"","type":"image"}]}