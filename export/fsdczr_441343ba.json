{"ver":"0.1","info":{"id":"fsdczr","date":"1652978587","viewed":75,"name":"compute modes","username":"donniet","description":"experimenting with graphing 3d graphs in webgl","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["compute"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nEdgeComputeCost(ComputeSpeed, Latency) = A * 2^ComputeSpeed + B * Latency\nCloudComputeCost(ComputeSpeed, Latency) = A * ComputeSpeed + B * Latency^2\nCloudComputeCost(Compute, Bandwidth, Latency) = A (medium) * Compute(flop/sec) / ( Bandwidth(bytes/sec)  * AlgorithmEfficiency (flop/byte) ) + B * Bandwidth + func(Latency) [INCOMPLETE]\nDataCenterCost(Compute, Bandwidth, Latency) = D (cheap) * Compute(flop/sec) / ( Bandwidth(bytes/sec) * AlgorithmEfficiency (flop/byte) ) + ---------  + func2(Latency)\nStoresAndDCCost(Compute, Bandwidth, Latency) = E (high) * Compute(flop/sec)^2 / (Bandwidth(bytes/sec) [fixed] * AlgorithmEfficiency(flop/byte) + ------- + --------\nEdgeComputeCost(Compute, Bandwidth, Latency) = [different by device]\n*/\n\n/*\nCompute [flop/byte]\nBandwidth [byte/sec]\nLatency [sec]\nCost [$]\nAlgorithmEfficiency [flop/byte]\n\nComputeCost [$/flop]\nBandwidthCost [$/byte]\nHardwareCost [$]\n\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec4 edgeColor = vec4(1., 0., 0., 1.);\n    vec4 dataCenterColor = vec4(0., 1., 0., 1.);\n    vec4 cloudColor = vec4(0., 0., 1., 1.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float compute;\n    float bandwidth;\n    getComputeBandwidth(uv, compute, bandwidth);\n    \n    float frequency = 0.1;\n    \n    \n    float e = edgeCost(compute, bandwidth, frequency);\n    float d = dataCenterCost(compute, bandwidth, frequency);\n    float c = cloudCost(compute, bandwidth, frequency);\n    \n    if(e < d && e < c) {\n        fragColor = edgeColor;\n    } else if(d < e && d < c) {\n        fragColor = dataCenterColor;\n    } else {\n        fragColor = cloudColor;\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,1.);\n        \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n/*\nEdgeComputeCost(ComputeSpeed, Latency) = A * 2^ComputeSpeed + B * Latency\nCloudComputeCost(ComputeSpeed, Latency) = A * ComputeSpeed + B * Latency^2\nCloudComputeCost(Compute, Bandwidth, Latency) = A (medium) * Compute(flop/sec) / ( Bandwidth(bytes/sec)  * AlgorithmEfficiency (flop/byte) ) + B * Bandwidth + func(Latency) [INCOMPLETE]\nDataCenterCost(Compute, Bandwidth, Latency) = D (cheap) * Compute(flop/sec) / ( Bandwidth(bytes/sec) * AlgorithmEfficiency (flop/byte) ) + ---------  + func2(Latency)\nStoresAndDCCost(Compute, Bandwidth, Latency) = E (high) * Compute(flop/sec)^2 / (Bandwidth(bytes/sec) [fixed] * AlgorithmEfficiency(flop/byte) + ------- + --------\nEdgeComputeCost(Compute, Bandwidth, Latency) = [different by device]\n*/\n\n/*\nCompute Speed [flop/sec]\nCompute Needed [flop/byte]\nInput Size [byte]\nBandwidth [byte/sec]\nFrequency [1/sec]\nLatency [sec]\nCost [$]\n\nComputeCost [$/flop]\nBandwidthCost [$/byte]\nHardwareCost [$/year]\n\n*/\n\n\n\nfloat edgeCost(float compute, float bandwidth, float frequency) {\n    // Edge Compute Cost [$/flop]\n    float computeCost = 1.;\n    \n    \n    //     upfront       cost per cycle                cost of bandwidth\n    return 0.75 * compute +        1.* computeCost * (compute * bandwidth) +      0.; // no bandwidth cost, compute is done as close to input as possible\n}\n\nfloat dataCenterCost(float compute, float bandwidth, float frequency) {\n    //     upfront       cost per cycle                cost of bandwidth\n    return 0.45 * compute  +    0.75 *  (compute * bandwidth)  + 0.1 * bandwidth;\n}\n\nfloat cloudCost(float compute, float bandwidth, float frequency) {\n    return 2. * compute * bandwidth * 1. + 1. * bandwidth;\n}\n\nvoid getComputeBandwidth(vec2 uv, out float compute, out float bandwidth) {\n    vec2 computeRange = vec2(0,1.);\n    vec2 latencyRange = vec2(0,1.);\n    vec2 bandwidthRange = vec2(0,1.);\n    \n    //uv.x = exp(uv.x)-1.;\n    //uv.y = exp(uv.y)-1.;\n    \n    bandwidth = uv.x * (bandwidthRange[1] - bandwidthRange[0]) + bandwidthRange[0];\n    compute = uv.y * (computeRange[1] - computeRange[0]) + computeRange[0];\n}\n","name":"Common","description":"","type":"common"}]}