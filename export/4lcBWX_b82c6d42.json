{"ver":"0.1","info":{"id":"4lcBWX","date":"1541174833","viewed":413,"name":"Gyrobifastigium Voxel Tracing","username":"fizzer","description":"Raytracing Gyrobifastigium-shaped voxels with analytic intersections. There is also a version with Octahedron-shaped voxels: https://www.shadertoy.com/view/4lcfDB","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voxel","gyrobifastigium","j26"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here is analytic intersection and traversal of packed Gyrobifastigium polytopes.\n// The Gyrobifastigium is also known as J26. More info: https://en.wikipedia.org/wiki/Gyrobifastigium\n\n// This ray traversal works by finding the nearest J26 in a regular tiling\n// and testing the ray against the inner sides of that J26. There are some scalings by sqrt(3)\n// because the voxel traversal is done on 1x1x1 cells, but the J26 with an edge length of 1\n// has a height of sqrt(3). Normalising to 1x1x1 first makes the math easier to manage.\n\n// Other shaders that use the same general approach to traversal non-cuboid voxels:\n//\n// https://www.shadertoy.com/view/4lcfDB - Octahedral Voxel Tracing by fizzer\n// https://www.shadertoy.com/view/XdSyzK - Hex grid traversal by mattz\n// https://www.shadertoy.com/view/XdS3DG - Escher's Planaria by mattz\n// https://www.shadertoy.com/view/XssfDN - Truncated Octohedron Voxel Scene by culdevu\n//\n\n#define AA 2 // Anti-aliasing factor\n\nfloat time;\n\n// Camera path\nvec2 path(float z)\n{\n    vec2 p = vec2(0);\n    p.x += cos(z / 4.) * 2. * sin(z / 6.) * .7 + cos(z / 2. + sin(z * .5) / 2.) * 3. * sin(z / 5.);\n    p.y += sin(z / 3.) * 2. + cos(z / 5.) / 3. + sin(z / 5. + cos(z * 1.) / 3.) * 3.;\n    return p;\n}\n\n// Voxel solid/empty function\nfloat f(vec3 p)\n{\n    // Unscale to put p in to worldspace\n    p.y *= sqrt(3.);\n    \n    vec3 op = p;\n    p.xy += path(p.z);\n    float d = -(length(p.xy) - 4.);\n    op.z = mod(op.z, 21.) - 10.5;\n    return d + cos(p.x * 80.) + cos(p.y * 180.);\n}\n\n// Ray intersection with inner sides of J26 (scaled in Y by 1 / sqrt(3))\nfloat traceJ26int(vec3 o, vec3 r, float mint)\n{\n    // Intersect with XY and ZY planes of a cuboid. This gives\n    // the intersections for the axis-aligned sides of the J26.\n    \n    vec2 bt1 = (step(vec2(0), r.xz) - .5 - o.xz) / r.xz;\n    float bt = min(bt1.x, bt1.y);\n\n    // Intersect with the other 4 (slanted) sides.\n    \n    float t0 = (.5 - o.x - o.y) / (r.x + r.y);\n\n    if(t0 > mint)\n        bt = min(bt, t0);\n\n    float t1 = (.5 - o.y + o.x) / (r.y - r.x);\n\n    if(t1 > mint)\n        bt = min(bt, t1);\n\n    float t2 = (.5 - o.z + o.y) / (r.z - r.y);\n\n    if(t2 > mint)\n        bt = min(bt, t2);   \n\n    float t3 = (.5 + o.z + o.y) / (-r.z - r.y);\n\n    if(t3 > mint)\n        bt = min(bt, t3);\n\n    return bt;\n}\n\n// Snap to the nearest J26 in the tiling, and orient the given ray direction\n// to the local space of that J26. Also returns the ray origin in local space as oc,\n// and the center of the J26 as c.\nvoid classifyJ26(vec3 o, inout vec3 r, vec3 p, out vec3 c, out vec3 oc)\n{\n    // First quantise to the first grid\n    \n    vec3 fp = fract(p - mod(floor(p.y), 2.) * vec3(.5, 0, .5));\n\n    c = p - fp + .5;\n    oc = o - c;\n\n    vec2 sv = fp.y < .5 ? (fp.zy - vec2(.5, 0)) : (fp.xy - vec2(.5, 1));\n\n    if(abs(sv.x) > abs(sv.y))\n    {\n        // The query point is outside the J26 aligned to the first grid,\n        // so use the second grid. The query point is guaranteed to be within the\n        // J26 aligned to this second grid.\n        \n    \tfp = fract(p + vec3(0, .5, .5) + mod(floor(p.y + .5), 2.) * vec3(.5, 0, .5));\n\n        c = p - fp + .5;\n        oc = (o - c).zyx;\n        r = r.zyx;\n        fp = fp.zyx;\n    }\n}\n\n// Returns the surface normal of the nearest J26 at point p, scaled in Y\n// by 1 / sqrt(3).\nvec3 getNormalJ26(vec3 p)\n{\n    vec3 n;\n\n    vec3 fp = fract(p - mod(floor(p.y), 2.) * vec3(.5, 0, .5));\n    vec3 cp = fp - .5;\n\n    // This normal vector calculation is similar to the calculation that would be done for\n    // a cube, except that the separating planes are slanted, hence the addition of vec2(cp.y, 0).\n\n    vec2 acp = abs(cp.xz) + vec2(cp.y, 0);\n    vec2 ss = step(acp.yx, acp);\n\n    n.xz = ss * sign(cp.xz);\n    n.y = abs(fp.y > .5 ? n.x : n.z) * sign(cp.y);\n\n    vec2 sv = fp.y < .5 ? (fp.zy -vec2(.5, 0)) : (fp.xy - vec2(.5, 1));\n\n    if(abs(sv.x) > abs(sv.y))\n    {\n    \tfp = fract(p + vec3(0, .5, .5) + mod(floor(p.y + .5), 2.) * vec3(.5, 0, .5));\n\n        fp = fp.zyx;\n        vec3 cp = fp - .5;\n\n        vec2 acp = abs(cp.xz) + vec2(cp.y, 0);\n        vec2 ss = step(acp.yx, acp);\n\n        n.xz = ss * sign(cp.xz);\n        n.y = abs(fp.y > .5 ? n.x : n.z) * sign(cp.y);\n        n = n.zyx;\n    }\n\n    return n;\n}\n\n// Traces a ray\nfloat trace(vec3 ro, vec3 rd, float maxt, out vec3 c)\n{\n    vec3 p = ro;\n\n    float t0 = 0., t1;\n\n    for(int i = 0; i < 64; ++i)\n    {\n        vec3 r = rd, oc;\n        classifyJ26(ro, r, p, c, oc);\n\n        t1 = traceJ26int(oc, r, t0);\n\n        if(f(c) < 0.)\n            break;\n\n        p = ro + rd * (t1 + 1e-3);\n        t0 = t1 + 1e-3;\n\n        if(t0 > maxt)\n            break;\n    }\n\n    return t0;\n}\n\n// Procedural 3D surface texture.\nfloat tx(vec3 p)\n{\n    // Edge darkening.\n    vec3 fp = vec3(1) - abs(fract(p) - .5) * 1.;\n    fp *= fp * fp * fp;\n    float s = 1. - fp.x * fp.y * fp.z * 4.;\n    \n    // Distortion\n    for(int i = 0; i < 3; ++i)\n        p += cos(p.yzx * 10.) * .1;\n    \n    // Noise\n    return mix(.5, .8, smoothstep(texture(iChannel0, p / 1.5).r +\n                                  texture(iChannel0, p * 1.5).r / 2., .1, .4)) * s;\n}\n\nvec3 image(vec2 fragCoord)\n{\n    vec4 fragColor;\n\n    // Set up primary ray direction\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    vec2 t = uv.xy;\n    t.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0., 0., -time) + 1e-3, rd = normalize(vec3(t, 1.1));\n    vec3 targ = ro;\n\n    targ.z -= 4.;\n\n    // Offset ray origin and camera target by path displacement\n    ro.xy -= path(ro.z);\n    targ.xy -= path(targ.z);\n\n    // Camera coordinate system\n    vec3 dir = normalize(targ - ro);\n    vec3 left = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(left, dir));\n\n    rd = rd.z * dir + rd.x * left + rd.y * up;\n\n    // Scale the whole scene so each J26 fits in a 1x1x1 cell. This makes\n    // the whole raytracing algorithm easier to manage.\n    ro.y /= sqrt(3.);\n    rd.y /= sqrt(3.);\n\n    vec3 c;\n\n    // Trace primary ray\n    float dist = trace(ro, rd, 100., c);\n    vec3 p = ro + rd * dist;\n\n    vec3 n = getNormalJ26(p);\n    \n    // Unscale the normal to put it back in to worldspace.\n    n.y *= sqrt(3.);\n    n = normalize(n);\n\n    // Directional shadow ray direction\n    vec3 ld = normalize(vec3(1, 2, 3)) * 1.5;\n\n    fragColor.a = 1.;\n\n    // Distance darkening and directional light cosine term\n    fragColor.rgb = vec3(exp(-dist / 5.) * pow(.5 + .5 * dot(n, normalize(ld)), 2.));\n\n    // Colour selection\n    float cs = (.5 + cos(c.z * 4. + 5. + c.x + c.y * 17.) * .5);\n\n    // Apply colour\n    fragColor.rgb *= mix(vec3(.1),\n                         mix(vec3(0.1,0.1,1.), vec3(1,1,.1), step(.75, cs)), step(.1,cs));\n\n    // Texture map\n    float ts = tx(p - c);\n    fragColor.rgb *= ts;\n    fragColor.rgb += vec3(pow(ts, 4.)) * .03;\n\n    // Trace directional shadow ray\n    float st = trace(p + n * 2e-3, ld, length(ld) * 2., c);\n\n    // Apply (attenuated) directional shadow\n    fragColor.rgb *= mix(.2, 1., clamp(st / length(ld), 0., 1.));\n\n    // Fake AO\n    fragColor.rgb *= 1. - smoothstep(2., 5.8, distance(p.xy, -path(p.z)));\n\n    // Specular highlight\n    fragColor.rgb *= 1. + pow(clamp(dot(normalize(ld), reflect(rd,n)), 0., 1.), 4.) * 16.;\n\n    // Fog\n    fragColor.rgb = mix(vec3(.5), fragColor.rgb, exp(-dist / 1000.));\n\n    return fragColor.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    fragColor.rgb = vec3(0);\n\n    // Multisampling loop\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            // Jittered time for motionblur\n            time = iTime - texelFetch(iChannel1, ivec2(mod(fragCoord * float(AA) + vec2(x, y), 1024.)), 0).r * .02;\n            fragColor.rgb += image(fragCoord + vec2(x, y) / float(AA));\n        }\n\n    fragColor.rgb /= float(AA * AA);\n\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .3;\n\n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.4)) * .5;\n\n    // Gamma\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}