{"ver":"0.1","info":{"id":"4ddfWX","date":"1527007099","viewed":4748,"name":"The Sanctuary","username":"srtuss","description":"The secrets of the universe, hidden away for centuries, long forgotten.","likes":128,"published":1,"flags":8,"usePreview":0,"tags":["sound","music","art","temple","meditation","ambiance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// srtuss, 2018\n//\n// This began as an elaborate soundshader-experiment. I tried to create very clear-sounding\n// instruments and mix them nicely, with a feel of depth and dark atmosphere to it. I added\n// visuals based the images this music spawns in my head. Hope you enjoy it. :)\n//\n// Here is a recording of how the shader sounds, on the computers i created/tested it on:\n// http://srtuss.thrill-project.com/art/sanctuary_soundtrack.ogg\n//\n// Music production with a soundshader: :)\n// http://srtuss.thrill-project.com/music/shader.ogg\n//\n\nvec2 rotate(vec2 p, float a)\n{\n    float co = cos(a), si = sin(a);\n    return p * mat2(co, si, -si, co);\n}\n\nvec2 scene(vec3 p, bool details)\n{\n    float v = 1e38;\n    \n    float wall = 3. - dot(vec2(abs(p.x), p.y), normalize(vec2(1., .3)));\n    float floorr = p.y;\n    v = min(v, wall);\n    float srs = .8;\n    float strut = max(wall - .5, abs(fract(p.z * srs) - .5) / srs - .1);\n    v = min(v, strut);\n    v = min(v, max(strut, floorr) - .1);\n    \n    v = min(v, max(strut - .1, abs(floorr - 2.) - .5));\n    \n    float hole = 1.2 - length(p.xz);\n    v = min(v, max(floorr, hole));\n    v = min(v, max(abs(floorr), abs(hole)) - .2);\n    \n    vec3 q = p + vec3(0., sin(iTime) * .1 - 1., 0.);\n    float sphere = length(q) - .4;\n    \n    v = min(v, sphere);\n    \n    return vec2(v, step(sphere, v));\n}\n\nvec3 normal(vec3 p)\n{\n    float c = scene(p, true).x;\n    vec2 h = vec2(.005, 0.);\n    return normalize(vec3(scene(p + h.xyy, true).x - c, scene(p + h.yxy, true).x - c, scene(p + h.yyx, true).x - c));\n}\n\nvec4 trip(sampler2D sampler, vec3 nml, vec3 pos)\n{\n    vec3 b = abs(nml);\n    b = pow(b, vec3(50.));\n    b /= dot(b, vec3(1.));\n    return texture(iChannel0, pos.yz) * b.x + texture(iChannel0, pos.xz) * b.y + texture(iChannel0, pos.xy) * b.z;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n\tfor(int i = 0; i < 32; ++i)\n\t{\n\t\tfloat h = scene(ro + rd * t, false).x;\n\t\tif(h < 0.001)\n\t\t\treturn 0.0;\n\t\tres = min(res, k * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nfloat amb_occ(vec3 p, float h)\n{\n\tfloat acc = 0.0;\n\tacc += scene(p + vec3(-h, -h, -h), false).x;\n\tacc += scene(p + vec3(-h, -h, +h), false).x;\n\tacc += scene(p + vec3(-h, +h, -h), false).x;\n\tacc += scene(p + vec3(-h, +h, +h), false).x;\n\tacc += scene(p + vec3(+h, -h, -h), false).x;\n\tacc += scene(p + vec3(+h, -h, +h), false).x;\n\tacc += scene(p + vec3(+h, +h, -h), false).x;\n\tacc += scene(p + vec3(+h ,+h, +h), false).x;\n\treturn acc / h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1.66));\n    vec3 ro = vec3(0., 1., -2.);\n    float tilt = sin(iTime * .1 + 1.5) * .2 + .2;\n    ro.yz = rotate(ro.yz, tilt);\n    rd.yz = rotate(rd.yz, tilt);\n    \n    ro.xz = rotate(ro.xz, sin(iTime * .1) * .5);\n    rd.xz = rotate(rd.xz, sin(iTime * .1) * .5);\n    \n    float d = 0.;\n    for(int i = 0; i < 60; ++i)\n    {\n        d += scene(ro + rd * d, false).x;\n    }\n    \n    vec3 hit = ro + rd * d;\n    vec3 nml = normal(hit);\n    \n    vec3 lpos1 = vec3(0.5, 2., 4.);\n    \n    float mtl = scene(hit, false).y;\n    vec3 diffMap = vec3(0.);\n    if(mtl < .5)\n    {\n        float k = .001;\n        diffMap = trip(iChannel0, nml, hit * 1.111).xyz;\n        vec3 diffMap2 = trip(iChannel0, nml, hit * 1.111 + vec3(.005)).xyz;\n        nml = normalize(nml + (diffMap.x - diffMap2.x) * .7);\n    }\n    else\n    {\n        vec3 mov = hit + vec3(0., sin(iTime) * .1 - 1., 0.);\n        //nml = normalize(nml + sin(hit * 200.) * .03);\n        \n        float k = .001;\n        diffMap = trip(iChannel0, nml, mov * 1.111).xyz;\n        vec3 diffMap2 = trip(iChannel0, nml, mov * 1.111 + vec3(.005)).xyz;\n        nml = normalize(nml + (diffMap.x - diffMap2.x) * .7);\n    }\n    \n\tvec3 col = vec3(0.);// * exp(length(hit.xy - vec2(0., 1.)) * -1.) * exp(d * -.3);\n    \n    for(int i = 0; i < 2; ++i)\n    {\n        vec3 light = i == 1 ? lpos1 : vec3(cos(iTime * .4), 2., sin(iTime) + 1.);\n        vec3 vLight = light - hit;\n        vec3 lcol = i == 1 ? vec3(1, 1., .7) : vec3(.3, .7, 1.);\n        float lfade = exp(length(vLight) * -1.3);\n        vec3 diff = max(dot(nml, normalize(vLight)), 0.) * lfade * lcol;\n        vec3 ref = reflect(rd, nml);\n        float spec = pow(max(0., dot(normalize(vLight), ref)), 32.);\n\n        vec3 ccol = vec3(1.);\n        ccol *= pow(diffMap, vec3(2.));\n\n        ccol *= diff;\n        ccol += vec3(.4) * spec * lfade;\n        \n        col += ccol;\n    }\n    \n    col *= smoothstep(-5., 1., amb_occ(hit, .15));\n    \n    //col = nml * .5 + .5;\n    \n    col += exp((7. - dot(rd, lpos1 - ro)) * -6.);// * softshadow(ro, normalize(lpos1 - ro), .1, 128.);\n    \n    float pt = iTime * .2;\n    for(int i = 0; i < 20; ++i)\n    {\n        float pd = 2.;\n        hit = ro + rd * pd;\n        float h = float(i);\n        if(d > pd)\n        {\n            col += exp(length(hit.xy - vec2(sin(h) * .4 + sin(pt + h) * .1, cos(pt + h) * .1 + fract(pt * .1 + cos(h)))) * -400.) * .05 * (1.1 + sin(h * 10.));\n        }\n    }\n    \n    col = sqrt(col);\n    col *= 2.9;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// srtuss, 2018\n\n#define PI 3.1415926535897932384626433832795\n\nfloat tempo = 2.;\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 897612.531);\n}\nfloat hsh(float x)\n{\n    return fract(sin(x * 237.234234) * 982734.1235);\n}\nfloat rnd(float x, float mn, float mx)\n{\n    return mn + floor((mx - mn) * hash(floor(x)));\n}\n\n// perlin noise\nfloat nse(float x)\n{\n    float y = floor(x);\n    x -= y;\n    x = x * x * (3. - 2. * x);\n    return mix(hash(y), hash(y + 1.), x) - .5;\n}\n\n// FM-bell\nvec2 inst0(float t, float f)\n{\n    vec2 v;\n    v.x = sin(t * f * PI * 2. + sin(t * f * 80.) * exp(t * -50.)) * min(t * 800., 1.) * exp(t * -5.) * .25;\n    v.y = cos(t * f * PI * 2. + sin(t * f * 80.) * exp(t * -50.)) * min(t * 800., 1.) * exp(t * -5.) * .25;\n    return v;\n}\n\n// crude vowel-\"A\" instrument\nfloat voc(float t, float f, float formant)\n{\n    float x = fract(t * f) / f;\n    return (sin(x * 6. * formant) * .4 + sin(x * 12. * formant) + sin(x * 26. * formant) * .2) * min(x * 1000., 1.) * exp(x * -200.);\n}\n\n// a swarm of voc()'s\nvec2 inst2(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    float formant = 300. * exp2(sin(t * .1));\n    for(int i = 0; i < 16; ++i)\n    {\n        float h = float(i);\n       \tfloat m = voc(t + h / 3., f + pow(2.01, (h - 8.) * .2), formant);\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .1;\n}\n\nfloat tri(float x)\n{\n    return abs(fract(x) * 2. - 1.);\n}\n\n// squarewave-ish instrument\nvec2 inst4(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    for(int i = 0; i < 8; ++i)\n    {\n        float h = float(i) * 2. + 1.;\n        float x = h;\n       \tfloat m = sin(t * f * 2. * PI * x) * (1. + nse(h * 41. + t * 10.)) / h;\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .25;\n}\n\n// pentatonic scale\nfloat penta(float x)\n{\n    x /= 5.;\n    float y = floor(x);\n    x = fract(x);\n    x *= 5.;\n    return step(1., x) * 2. + step(2., x) * 3. + step(3., x) * 2. + step(4., x) * 2. + y * 12.;\n}\n\n// 2 octaves of choir + playing harmonics, which gives some symphonic qualities\nvec2 choir(float time, float n)\n{\n    vec2 v = inst2(time, 140. * pow(2., n / 12.));\n    v += inst2(-time, 140. * pow(2., n / 12. - 1.));\n    if(time > 128. / tempo)\n    {\n        v += inst4(time, 140. * 5. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .44 + 10.));\n        v += inst4(time, 140. * 4. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .33));\n        v += inst4(time, 140. * 3. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .12));\n        v += inst4(time, 140. * 5. / 2. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .32 + 4.));\n    }\n    return v;\n}\n\n// a snaredrum with fake reverb tail\nvec2 snare(float t)\n{\n    if(t < 0.)\n        return vec2(0.);\n    t *= 3.;\n    float env = exp(t * -10.) + exp(t * -1.) * .07;\n    vec2 w = vec2(hsh(t), hsh(t + .1)) * env * .4;\n    w += sin(t * 400.) * exp(t * -10.) * min(1., t * 5000.) * .1;\n    return w * (max(exp(-1. * fract(t * 20.)), min(t * 9., 1.)) + 3. * clamp(1. - abs(t - .4) * 10., 0., 1.));\n}\n\n// channel to be echo-ed\nvec2 echomix(float time)\n{\n    vec2 v = vec2(0.);\n    \n    float x = mod(time, 8. / tempo);\n    v += vec2(.5) * sin(pow(x, .9) * 300.) * min(1., x * 200.) * exp(x * -5.);\n    \n    float rate = tempo * 2.;\n    if(time > 32. / tempo)\n\t    v += inst0(fract(time * rate) / rate, 140. * 2. * pow(2., penta(rnd(time * rate, 0., 10.)) / 12.)) * .4;\n    return v;\n}\n\n// tempo-synced echo effect\nvec2 echo(float t)\n{\n    vec2 s = vec2(0, 0);\n    float k = 3. / 4. / tempo;\n    float a = 1.;\n    float damp = .5;\n    vec2 sep = vec2(.3, 1.);\n    s += echomix(t); a *= damp; sep = sep.yx;\n    s += echomix(t - k).yx * a * sep; a *= damp; sep = sep.yx;\n    s += echomix(t - k * 2.) * a * sep; a *= damp; sep = sep.yx;\n    s += echomix(t - k * 3.).yx * a * sep;\n    return s;\n}\n\n// putting everything together + postprocessing\nvec2 mainSound( in int samp, float time )\n{\n    vec2 v = echo(time);\n    \n    float x;\n    x = mod(time, 32. / tempo);\n    v += choir(time, -5.) * clamp(x * tempo * .5, 0., 1.) * smoothstep(16. + 4., 15., x * tempo);\n    v += choir(time, -7.) * (clamp((x * tempo - 16.) * .5, 0., 1.) * smoothstep(32. + 4., 31., x * tempo + 1.) + smoothstep(5., 0., x * tempo));\n    \n    if(time >= 128. / tempo)\n    {\n        v += snare(mod(time - 1. / tempo, 2. / tempo));\n        x = mod(time, 16. / tempo);\n        v += snare(x - tempo * (7. + 16.) / 16.);\n    }\n        \n    vec2 ms = vec2(v.x + v.y, v.y - v.x);\n    \n    v = vec2(ms.x * .5 + ms.y, ms.x * .5 - ms.y);\n    \n    \n    return v;\n}","name":"Sound","description":"","type":"sound"}]}