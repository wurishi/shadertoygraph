{"ver":"0.1","info":{"id":"MlsXWn","date":"1436032060","viewed":708,"name":"FrickinLasers","username":"dila","description":"Laser security system.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["laser","room"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTube(vec3 p, float a)\n{\n    return length(p.xy) - a;\n}\n\nfloat room(vec3 p)\n{\n\tfloat fd = sdBox(p, vec3(8.0));\n    fd = min(fd, sdBox(p+vec3(0.0,6.0,0.0), vec3(2.0,2.0,100.0)));\n    fd = min(fd, sdBox(p+vec3(0.0,6.0,0.0), vec3(100.0,2.0,2.0)));\n    return fd;\n}\n\nbool alpha = false;\n\nvec2 map(vec3 p)\n{   \n\tfloat d = -room(p);\n    float m = 0.0;\n    \n    float pe = sdBox(p+vec3(0.0,8.0,0.0), vec3(1.0, 2.0, 1.0));\n    if (pe < d) {\n        d = pe;\n        m = 1.0;\n    }\n    \n    if (alpha) {\n        float c = sdBox(p+vec3(0.0,5.0,0.0), vec3(1.0));\n        if (c < d)\n        {\n            d = c;\n            m = 2.0;\n        }\n    } else {\n        float c = length(p+vec3(0.0,5.3,0.0)) - 0.7;\n        if (c < d)\n        {\n            d = c;\n            m = 3.0;\n        }\n    }\n    \n    return vec2(d, m);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d;\n    }\n    return t;\n}\n\nfloat mapl(vec3 p)\n{\n    p *= yrot(pi*0.25);\n\tfloat r = 0.01;\n    float o = 7.0;\n    vec3 q = fract(p) * 2.0 - 1.0;\n    float a = sdTube(vec3(q.z,q.y,q.x), r);\n    float b = sdTube(vec3(q.x,q.y,q.z), r);\n    return min(a,b);\n}\n\nfloat tracel(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n        vec3 p = o + r * t;\n        float d = mapl(p);\n        t += d * 0.8;\n    }\n    return t;\n}\n\nvec3 _texture(vec3 p)\n{\n\tvec3 ta = texture(iChannel0, vec2(p.y,p.z)).xyz;\n    vec3 tb = texture(iChannel0, vec2(p.x,p.z)).xyz;\n    vec3 tc = texture(iChannel0, vec2(p.x,p.y)).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvec4 diffcol(vec3 w, vec3 r, vec3 sn, vec2 fd, float t)\n{\n    vec3 mdiff = vec3(0.0); \n    float gloss = 0.0;\n    float light = 1.0;\n    if (fd.y == 1.0) {\n        mdiff = vec3(1.0);\n        gloss = 1.0;\n    } else if (fd.y == 2.0) {\n        mdiff = vec3(1.0);\n    } else if (fd.y == 3.0) {\n        mdiff = vec3(1.0);\n        gloss = 1.0;\n    } else {\n        if (sn.y > 0.9) {\n    \t\tmdiff = vec3(1.0) * vec3(0.2,0.5,0.2);\n            gloss = 0.1;\n        } else if (sn.y < -0.9) {\n            mdiff = vec3(5.0);\n            gloss = 1.0;\n            light = 0.0;\n        } else {\n            mdiff = _texture(w*0.1) * vec3(0.0, 1.0, 1.0);\n            gloss = 1.0;\n        }\n    }\n    float fog = 1.0 / (1.0 + t * t * 0.05);\n    mdiff = mix(mdiff, vec3(1.0), abs(w.y) / 8.0 * light);\n    return vec4(mdiff*fog, gloss);\n}\n\nvec3 laser(vec3 o, vec3 r)\n{\n    float t = tracel(o, r);\n    float k = 1.0 / (1.0 + t * t * 0.1);\n    return vec3(1.0, 0.0, 0.0) * k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    mat3 xfm = xrot(sin(-iTime*0.25)*0.25) * yrot(iTime);\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    r *= xrot(pi * 0.25) * xfm;\n    \n    vec3 o = vec3(0.0, 0.0, -3.0);\n    o *= xfm;\n    o.y -= 3.0;\n    \n    alpha = true;\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec2 fd = map(w);\n    vec3 sn = normal(w);\n\n\tvec4 mdiff = diffcol(w, r, sn, fd, t);\n    \n    if (fd.y == 2.0) {\n    \talpha = false;\n    \tvec3 rr = refract(r, sn, 0.9);\n    \tfloat art = trace(w, rr);\n        vec3 aw = w + rr * art;\n    \tvec2 afd = map(aw);\n        vec3 asn = normal(aw);\n\t\tmdiff = diffcol(aw, rr, asn, afd, t+art);\n        mdiff.xyz += laser(w, rr);\n        mdiff.w = 1.0;\n        \n        if (afd.y == 3.0) {\n            alpha = false;\n            vec3 brf = reflect(rr, asn);\n            float brt = trace(aw + asn * 0.1, brf);\n            vec3 bw = aw + brf * brt;\n            vec2 bfd = map(bw);\n            vec3 bsn = normal(bw);\n            vec4 bdiff = diffcol(bw, brf, bsn, bfd, brt);\n            float prod = max(dot(rr, -asn), 0.0);\n            mdiff.xyz = bdiff.xyz * prod + laser(aw, t+art+brf);\n        }\n    }\n\n    alpha = true;\n    vec3 rf = reflect(r, sn);\n    float tr = trace(w + sn * 0.01, rf);\n    vec3 rw = w + rf * tr;\n    vec2 rfd = map(rw);\n    vec3 rsn = normal(rw);\n    vec4 rdiff = diffcol(rw, rf, rsn, rfd, t+tr);\n    \n    float prod = max(dot(r, -sn), 0.0);\n    \n\tvec3 fdiff = mix(mdiff.xyz, rdiff.xyz, mdiff.w*(1.0-prod));\n\n    vec3 fc = fdiff + laser(o, r);\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}