{"ver":"0.1","info":{"id":"ddXyz2","date":"1687034017","viewed":58,"name":"fermat spiral domain","username":"MonterMan","description":"use fermat spiral as domain repetition","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fermat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"fermat spiral SDF\" by MonterMan. https://shadertoy.com/view/dsXyR2\n// 2023-06-17 05:30:36\n\n#define PI 3.1415926\n#define GOLDEN_ANGLE 2.39996734783236271464\n\n// N: number of fermat spiral samples\n// golden_angle: really should be 2.39996734783236271464, but you can tweak it to get other nice effects!\nvec2 opFermatSpiralRepeat(vec2 p, float golden_angle, int N)\n{\n    // NOTE: adjust this based on how many fermat samples you have\n    const float test_neighbor_count = 10.0;\n\n    // theta <- [0, 2*PI]\n    float theta = atan(p.y, p.x) + PI;\n    float r = length(p);\n    \n    float sqrt_N = sqrt(float(N));\n    float radial_index = floor(r*r*float(N));\n    if (radial_index < float(N))\n    {\n        float min_dist = 10e31;\n        int closest_sample_index = -1;\n        for (float i = radial_index-test_neighbor_count;\n             i <= radial_index+test_neighbor_count;\n             i += 1.0)\n        {\n            float radius = sqrt(i)/sqrt_N;\n            float angle = i * golden_angle;\n            vec2 fermat_point = radius * vec2(cos(angle), sin(angle));\n            float dist = length(fermat_point - p);\n            if (dist < min_dist)\n            {\n                closest_sample_index = int(i);\n                min_dist = dist;\n            }\n        }\n        \n        float sample_angle = float(closest_sample_index) * golden_angle;\n        float sample_radius = sqrt(float(closest_sample_index))/sqrt_N;\n        \n        mat2 inv_rot = mat2(cos(-sample_angle), sin(-sample_angle),\n                            sin(sample_angle), cos(-sample_angle));\n        p = inv_rot * p;\n        p.x -= sample_radius;\n        return p;\n    }\n    else\n    {\n        return p;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv = opFermatSpiralRepeat(uv, GOLDEN_ANGLE, 512);\n    \n    float dist = abs(uv.x) + abs(uv.y);\n    fragColor = vec4(0.0003/pow(dist,2.0));\n}","name":"Image","description":"","type":"image"}]}