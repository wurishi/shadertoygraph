{"ver":"0.1","info":{"id":"ftScWR","date":"1649415156","viewed":231,"name":"GameOfLife3D (VoxelTraverse)","username":"GameOfLifeCGA","description":"Controls: \n- Movement: WASD\n- Camara rotation: Mouse + Q,E\n- Reset camara position: Space\n- Re-initialize board: R\n- Switch background: B\n\nCommon: configurable parameters\n\nTodo: \n- Improve buffer management for boxes to enable larger boards","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarch","voxels","dda","gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nbool box(int i){\n    if(i < 0 || i >= int(pow(float(bordsize),3.))) return false;\n    vec4 data = load0(ivec2(floor(float(i)/(float(bordsize)*4.)),floor(mod(float(i),float(bordsize)*4.)/4.)) + bpos1);\n    int comp = int(mod(float(i),4.));\n    if(comp == 0) return data.x == 1. ? true : false;\n    if(comp == 1) return data.y == 1. ? true : false;\n    if(comp == 2) return data.z == 1. ? true : false;\n    if(comp == 3) return data.w == 1. ? true : false;\n    return false;\n}\n\nfloat boxColor(int i){\n    if(i < 0 || i >= int(pow(float(bordsize),3.))) return 0.;\n    vec4 data = load0(ivec2(floor(float(i)/(float(bordsize)*4.)),floor(mod(float(i),float(bordsize)*4.)/4.)) + fpos1);\n    int comp = int(mod(float(i),4.));\n    if(comp == 0) return data.x;\n    if(comp == 1) return data.y;\n    if(comp == 2) return data.z;\n    if(comp == 3) return data.w;\n    return 0.;\n}\n\n//Reference: https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 bp, vec3 b ){\n    bp=bp+vec3(0.5,0.5,0.5);\n    vec3 q = abs(p-bp) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 duplicatePoint(vec3 mapPos){\n    if(mapPos.x < 0. || mapPos.y < 0. || mapPos.z < 0.) return mapPos;\n    if(mapPos.x >= 0. && mapPos.x < float(bordsize) && mapPos.y >= 0. && mapPos.y < float(bordsize) && mapPos.z >= 0. && mapPos.z < float(bordsize)) return mapPos;\n    if(mapPos.x < float(bordsize)*float(duplicateSize.x)\n        && mapPos.y < float(bordsize*duplicateSize.y)\n        && mapPos.z < float(bordsize*duplicateSize.z))\n        return mod(mapPos,float(bordsize));\n    \n    return mapPos;\n}\n\nfloat GetDist(vec3 p,out int indx) {\n    float minTracker = 1000.;\n    for(int i=0;i<int(pow(float(bordsize),3.));i++){\n        if(box(i)){\n            float lastmin = minTracker;\n            minTracker = min(minTracker,sdBox(duplicatePoint(p),vec3(mod(float(i),float(bordsize)),\n                                                     floor(mod(float(i),float(bordsize)*float(bordsize))/float(bordsize)+0.01),\n                                                     floor(float(i)/(float(bordsize)*float(bordsize)))), b));                                        \n            if(lastmin > minTracker) indx = i;\n        }\n    }\n    return minTracker;\n}\n\nivec3 duplicateBox(ivec3 mapPos){\n    if(mapPos.x < 0 || mapPos.y < 0 || mapPos.z < 0) return ivec3(-1); // invalid box\n    if(mapPos.x >= 0 && mapPos.x < bordsize && mapPos.y >= 0 && mapPos.y < bordsize && mapPos.z >= 0 && mapPos.z < bordsize) return mapPos;\n    if(mapPos.x < bordsize*duplicateSize.x \n        && mapPos.y < bordsize*duplicateSize.y \n        && mapPos.z < bordsize*duplicateSize.z)\n        return ivec3(mod(vec3(mapPos),float(bordsize)));\n    \n    return ivec3(-1);\n}\n\nbool collisionTest(vec3 pos,vec3 rd,ivec3 boxPos){\n    float dist = 0.;\n    while(dist < 2.){\n        float temp = sdBox(pos+normalize(rd)*dist,vec3(boxPos),b);\n        if (temp < SURF_DIST) return true;\n        dist += temp;\n    }\n    return false;\n}\n\n\n//Reference: DDA March Idea from: https://www.shadertoy.com/view/4dfGzs\nivec3 voxelTraverseKoord(in vec3 ro, in vec3 rd, bool checkInnerBox){\n\n    vec3 mapPos = floor(ro);\n\t\n\tvec3 rayStep = sign(rd); // kein ivec3 benutzen\n    \n    vec3 sideDist = (vec3(mapPos) - ro + 0.5 + rayStep * 0.5)/ rd;\n\t\n    vec3 mask;\n    \n    float d = 0.;\n\tfor (int i = 0; i < max(bordsize*3,100); i++) {\n        mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\t\t\n        sideDist += mask * rayStep / rd;\n        mapPos += mask * rayStep;\n        \n\t\tivec3 boxPos = duplicateBox(ivec3(mapPos));\n        if(boxPos == ivec3(-1)) continue;\n        if(box(boxPos.x+boxPos.y*bordsize+boxPos.z*bordsize*bordsize)){\n            if(checkInnerBox){\n                vec3 pos = ro + sdBox(ro,vec3(mapPos),vec3(0.5, 0.5, 0.5)) * rd;\n                if(collisionTest(duplicatePoint(pos),rd,boxPos)) return ivec3(mapPos);\n            }else return ivec3(mapPos);\n        }\n    }\n    return ivec3(-1);\n}\n\nbool voxelTraverse(in vec3 ro, in vec3 rd, bool checkInnerBox){\n    if(voxelTraverseKoord(ro,rd,checkInnerBox) == ivec3(-1)) return false;\n    else return true;\n}\n\nfloat voxelTraverseRayMarch(vec3 ro, vec3 rd, out float glow, out int glowPos, out float minDist){\n    rd=normalize(rd);\n    int glowIndx = 0;\n    int glowIndxtemp = 0;\n    float glowtemp = 0.;\n    float dStemp = 100.;\n    float dO=0.;\n    float dS=0.;\n    minDist = 0.1;\n    glow = 0.;\n    \n    ivec3 nextBox = voxelTraverseKoord(ro,rd,false);\n    ivec3 currBox = nextBox;\n    ivec3 oldBox = ivec3(floor(ro + sdBox(ro,vec3(currBox),b)*rd));\n    ivec3 lastBox = voxelTraverseKoord(ro,rd,true);\n    vec3 p = ro;\n    if(currBox != ivec3(-1)){\n        //int maskBoxidx = maskBox.x+maskBox.y*bordsize+maskBox.z*bordsize*bordsize;\n        for(int i=0; i<MAX_STEPS; i++) {\n            p = ro + (sdBox(ro,vec3(currBox),b) + dO) * rd;\n            \n            if(ivec3(floor(p)) == currBox ){\n                if(nextBox == currBox) nextBox = voxelTraverseKoord(p,rd,false);\n            }\n            //else if(ivec3(floor(p)) != oldBox && ivec3(floor(p)) != nextBox){\n            //    dStemp=dStemp/2.;\n            //    dO=dO-dStemp;\n            //}\n            \n            dS = sdBox(p,vec3(currBox),b);//GetDist(p, glowIndx);\n            if(dS>dStemp){\n                if(nextBox == ivec3(-1)) return MAX_DIST;\n                //if(nextBox == currBox && ivec3(floor(p)) != oldBox){\n                //    dO-=dS;\n                //    continue;\n                //}\n                \n                minDist = min(dStemp,minDist);\n                if(glowtemp > glow){\n                    glow = glowtemp;\n                    glowPos = glowIndx;\n                }\n                currBox = nextBox;\n                oldBox = ivec3(floor(ro + sdBox(ro,vec3(currBox),b)*rd));\n                dO = 0.;\n                dStemp=100.;\n                continue;\n                \n            }\n            glowIndx = currBox.x+currBox.y*bordsize+currBox.z*bordsize*bordsize;\n            glowtemp = ((0.012/dS)-0.1)*1./0.9 *(1.-smoothstep(0.,1.,boxColor(glowIndx)))*7.;\n            if(glowtemp > glow && lastBox != currBox){\n                glow = glowtemp;\n                glowPos = glowIndx;\n            }\n            dO += dS;\n            dStemp = dS;\n            if(dS<SURF_DIST || dO>MAX_DIST) break;\n        }\n        return length(p-ro);\n    }\n    return MAX_DIST;\n}\n\nvec3 GetNormal(vec3 p,vec3 ro,vec3 rd) {\n    vec3 pos = round(p);\n    ivec3 mapPos = voxelTraverseKoord(ro,rd,true);\n    if(mapPos==ivec3(-1)) return vec3(0.);\n    ivec3 m = ivec3(lessThanEqual(abs(pos-p).xyz, min(abs(pos-p).yzx, abs(pos-p).zxy)));\n    float sgn = 1.;\n    if(m.x==1 && (ivec3(pos)-mapPos).x == 0) sgn = -1.;\n    if(m.y==1 && (ivec3(pos)-mapPos).y == 0) sgn = -1.;\n    if(m.z==1 && (ivec3(pos)-mapPos).z == 0) sgn = -1.;\n    return vec3(m)*sgn;\n}\n\nfloat GetLight(vec3 p,vec3 ro,vec3 rd) {\n    //vec3 lightPos = load1(ropos).xyz; // lightPos = Ray Origin\n    vec3 lightPos = vec3(-1, 6, -5);\n    vec3 lightPos2 = vec3(-1, 6, -5);\n    lightPos2.xyz += vec3(sin(iTime)*float(bordsize)*0.8 , cos(iTime)*float(bordsize), sin(iTime)*float(bordsize)*5.);\n    vec3 l = normalize(lightPos-p);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n = GetNormal(p,ro,rd);\n    if(n==vec3(0.)) return 0.;\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float dif2 = clamp(dot(n, l2), 0., 1.);\n    \n    vec3 pos = p+n*SURF_DIST*2.;\n    \n    ivec3 boxHit = voxelTraverseKoord(pos,l,true);\n    if(boxHit.x != -1){\n        float d = sdBox(pos,vec3(boxHit),b);\n        if(d<length(lightPos-p)) dif *= .2;\n    }\n    boxHit = voxelTraverseKoord(pos,l2,true);\n    if(boxHit.x != -1){\n        float d = sdBox(pos,vec3(boxHit),b);\n        if(d<length(lightPos-p)) dif2 *= .2;\n    }\n    return (dif+dif2)/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 ro = load1(ropos).xyz;\n    vec3 u = load1(upos).xyz;\n    vec3 f = normalize(load1(fpos).xyz + load1(mcpos).xyz);\n    \n    vec3 r = normalize(cross(u,f));\n    u = normalize(cross(f-r*dot(r,f),r));\n    \n    vec3 c = ro + f;\n    vec3 rd = normalize(c + uv.x * r + uv.y * u -ro);\n    \n    float minDist = 1.; // ambient Occlusion (not currently working)\n    float glow = 0.;\n    int glowPos=0;\n    \n    float d = 0.;\n    float rt = load1(rtpos).x;\n    \n    d = voxelTraverseRayMarch(ro,rd,glow,glowPos,minDist); // voxelTraverse + Raymarching\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p,ro,rd);\n    \n    vec3 bgvec = load1(bgpos).xyz;\n    vec3 bg = vec3(0.012); // grey\n    if(bgvec==vec3(0.,1.,0.)) bg = load2(fragCoord/iResolution.xy*vec2(400.,380.)).xyz; // activate Britney\n    else if(bgvec==vec3(0.,0.,1.)) bg = texture(iChannel3,rd).xyz; // Cubemap\n    \n    ivec3 mapPos = duplicateBox(voxelTraverseKoord(ro,rd,true));\n    \n    if(mapPos != ivec3(-1)){\n        int boxColIdx = mapPos.x+mapPos.y*bordsize+mapPos.z*bordsize*bordsize;\n        float boxCol = boxColor(boxColIdx);\n        col = vec3(dif);\n        col.yz*=boxCol;\n    }else col = bg; \n    \n    col += vec3(1.,0.,0.)*glow; // glow\n    //col *= (0.05+clamp(0.01,0.1,minDist))*0.15*100.; // ambient Occlusion (not currently working)\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    //col = vec3(voxelTraverseKoord(ro,rd,true))/float(bordsize); //rainbow\n    //col = vec3(voxelTraverse(ro, rd, true) ? 1. : 0.); // Raymarch mask\n    //if(length(vec2(ivec2(fragCoord)-ivec2(iResolution.xy/2.)))<100.) col = vec3(voxelTraverseKoord(ro,rd,true))/float(bordsize);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define load0(pos) texelFetch(iChannel0,ivec2(pos),0)\n#define load1(pos) texelFetch(iChannel1,ivec2(pos),0)\n#define load2(pos) texelFetch(iChannel2,ivec2(pos),0)\n#define load3(pos) texelFetch(iChannel3,ivec2(pos),0)\n#define store(pos,sdata) if(all(equal(ivec2(fragCoord),pos))) fragColor = sdata\n\nconst int bordsize = 50; // \nconst float p = 0.115; // spawn probability; 0.115; 0.315\nconst ivec3 duplicateSize = ivec3(1,1,1);\nconst float speed = .25; // animation speed\nconst vec3 b = vec3(0.4, 0.4, 0.4); \n\n// rules: 4,5,5,5 ; 5,7,6,6 ; 10,21,10,21 ; 4,5,2,6 ; 5,6,5,5\nconst int[] ruleSet = int[] (4,5,5,5);\n\nconst ivec2 bgpos = ivec2(0,0);\nconst ivec2 ropos = ivec2(1,0);\nconst ivec2 fpos = ivec2(2,0);\nconst ivec2 upos = ivec2(3,0);\nconst ivec2 mcpos = ivec2(4, 0);\nconst ivec2 repos = ivec2(5,0);\nconst ivec2 tpos = ivec2(6,0);\nconst ivec2 sppos = ivec2(7,0);\nconst ivec2 rtpos = ivec2(8, 0);\nconst ivec2 bpos1 = ivec2(0,0);\nconst ivec2 bpos2 = ivec2(ceil(float(bordsize)*float(bordsize)*0.25-1.),bordsize-1);\nconst ivec2 fpos1 = ivec2(0, bordsize);\nconst ivec2 fpos2 = ivec2(ceil(float(bordsize)*float(bordsize)*0.25-1.),2*bordsize-1);\n\n\n//Reference: https://stackoverflow.com/a/4275343\nfloat rand(vec2 co){ \n    return floor(fract(sin(dot(co*.1, vec2(12.9898, 78.233))) * 43758.5453)+p);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Reference Keyboard handle: https://www.shadertoy.com/view/4lVXRm\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n\nbool key(int K){\n    float wert = texelFetch(iChannel0, ivec2(K, 0), 0).x;\n    if(wert==1.) return true;\n    else return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = load1(fragCoord);\n    \n    if(iTime == 0.0 || iFrame == 0){\n        store(ropos,vec4(float(bordsize)/2., float(bordsize)/2., -float(bordsize),0.));\n        store(fpos,vec4(0.,0.,1.,0.));\n        store(upos,vec4(0.,1.,0.,0.));\n        store(bgpos,vec4(1.,0.,0.,0.));\n        store(rtpos,vec4(0.,0.,0.,0.));\n        store(mcpos, vec4(0.0));\n        store(repos, vec4(0.));\n        store(tpos, vec4(0.));\n        store(sppos, vec4(0.));\n        return;\n    }\n\n    if(ivec2(fragCoord) == ropos || ivec2(fragCoord) == fpos || ivec2(fragCoord) == mcpos || ivec2(fragCoord) == upos || ivec2(fragCoord) == repos || ivec2(fragCoord) == bgpos || ivec2(fragCoord) == rtpos){\n        vec3 ro = load1(ropos).xyz; // current position\n        vec4 mc = load1(mcpos).xyzw; // current mouse delta\n        vec3 f = load1(fpos).xyz; // forward\n        vec3 u = load1(upos).xyz; // up\n        vec3 r = normalize(cross(u,f)); // right\n        vec3 bg = load1(bgpos).xyz;\n        float rt = load1(rtpos).x;\n        vec3 fmc = normalize(f + mc.xyz);\n        vec3 rmc = normalize(cross(u,fmc));\n        vec3 umc = normalize(cross(r,fmc));\n        float refresh = load1(repos).x;\n        if(key(KEY_W)) ro+=fmc*0.1;\n        if(key(KEY_A)) ro+=rmc*-0.1;\n        if(key(KEY_S)) ro+=fmc*-0.1;\n        if(key(KEY_D)) ro+=rmc*0.1;\n        if(key(KEY_Q)) u+=r*-0.005;\n        if(key(KEY_E)) u+=r*0.005;\n        if(refresh > 0.) refresh = max(refresh-0.05, 0.);\n        if(key(KEY_B) && refresh == 0.){\n            if(bg==vec3(1.,0.,0.)) bg = vec3(0.,1.,0.);\n            else if(bg==vec3(0.,1.,0.)) bg = vec3(0.,0.,1.);\n            else if(bg==vec3(0.,0.,1.)) bg = vec3(1.,0.,0.);\n            refresh = 0.9;\n        }\n        if(key(KEY_SP)){ ro = vec3(float(bordsize)/2., float(bordsize)/2., -float(bordsize)); f = vec3(0.,0.,1.); u = vec3(0.,1.,0.);}\n        if(key(KEY_R) && refresh == 0.) refresh = 1.; \n        \n        if(iMouse.z > 0.0) {\n            mc = vec4(rmc*(abs(iMouse.z) - iMouse.x)-umc*(abs(iMouse.w) - iMouse.y),1.)/iResolution.x;\n        }else if (mc.w != 0.0) {\n            u = normalize(cross(fmc-rmc*dot(rmc,fmc),rmc));\n            f = fmc;\n            mc = vec4(0.0, 0.0, 0.0, 0.0);\n            \n        }\n        store(mcpos,mc);\n        store(bgpos,vec4(bg,0.));\n        store(rtpos,vec4(rt,0.,0.,0.));\n        store(ropos,vec4(ro,0.));\n        store(upos,vec4(normalize(u),0.));\n        store(fpos,vec4(f,0.));  \n        store(repos, vec4(refresh, 0., 0., 0.));\n    }\n    \n    float t = load1(tpos).x;\n    vec4 sp=vec4(0.,0.,0.,0.);\n    \n    if(speed > 1.){\n        // tick alle x > 1 Sekunden\n        sp = load1(sppos);\n        if(sp.y >= 1.) sp = vec4(1.,0.,0.,0.);\n        else if(t > mod(iTime,1.)) sp = vec4(0.,sp.y+1./speed,0.,0.); \n        else sp = vec4(0.,sp.yzw);\n        t = mod(iTime,1.);\n    }\n    else if(speed == 1.){\n        // tick jede Sekunde\n        if(t > mod(iTime,1.)) sp=vec4(1.,0.,0.,0.); \n        t = mod(iTime,1.);\n    }\n    else if(speed < 1.){\n        // tick alle 1./x, x >= 2 Sekunden\n        if(min(abs(mod(iTime,1.)-t),abs(mod(iTime,1.)+1.-t)) > (speed-0.01)){ \n            sp = vec4(1.,0.,0.,0.);\n            t = mod(iTime,1.); \n        }\n    }\n    \n    store(tpos,vec4(t,0.,0.,0.));\n    store(sppos,sp);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool box(int i){\n    if(i < 0 || i >= int(pow(float(bordsize),3.))) return false;\n    vec4 data = load0(ivec2(floor(float(i)/(float(bordsize)*4.)),floor(mod(float(i),float(bordsize)*4.)/4.)) + bpos1);\n    int comp = int(mod(float(i),4.));\n    if(comp == 0) return data.x == 1. ? true : false;\n    if(comp == 1) return data.y == 1. ? true : false;\n    if(comp == 2) return data.z == 1. ? true : false;\n    if(comp == 3) return data.w == 1. ? true : false;\n    return false;\n}\n\nfloat boxColor(int i){\n    if(i < 0 || i >= int(pow(float(bordsize),3.))) return 0.;\n    vec4 data = load0(ivec2(floor(float(i)/(float(bordsize)*4.)),floor(mod(float(i),float(bordsize)*4.)/4.)) + fpos1);\n    int comp = int(mod(float(i),4.));\n    if(comp == 0) return data.x;\n    if(comp == 1) return data.y;\n    if(comp == 2) return data.z;\n    if(comp == 3) return data.w;\n    return 0.;\n}\n\nfloat getRandom(float f, vec2 fragCoord) {\n    return rand(iTime * fragCoord * 6. * f);\n}\n\nint getNeighbors(int i) {\n    \n    int neighbors = 0;\n    int x = int(mod(float(i),float(bordsize)));\n    int y = int(floor(mod(float(i),float(bordsize)*float(bordsize))/float(bordsize)));\n    int z = int(floor(float(i)/(float(bordsize)*float(bordsize))));\n    \n    for(int ix = -1; ix <= 1; ix++) {\n        for(int iy = -1; iy <= 1; iy++) {\n            for(int iz = -1; iz <= 1; iz++) {\n                if(ix == 0 && iy == 0 && iz == 0) continue;\n                if(box(int(mod(float(x+ix),float(bordsize)))+(bordsize*int(mod(float(y+iy),float(bordsize))))+(bordsize*bordsize*int(mod(float(z+iz),float(bordsize)))))) neighbors += 1;\n            }\n        }\n    }\n    return neighbors;\n}\n\n\nvec4 gameLogic(int i, bool useColor) {\n    int neighbors = 0;\n    float[] data = float[](0.,0.,0.,0.);\n    \n    //4,5,5,5\n    //Reference rulesets: https://content.wolfram.com/uploads/sites/13/2018/02/01-3-1.pdf\n    for(int j = i;j < i+4;j++){\n        int neighbors = getNeighbors(j);\n        \n        // living cell\n        if(box(j) && (neighbors < ruleSet[0] || neighbors > ruleSet[1])){\n            if(!useColor) data[j-i] = 0.;\n            else if(useColor) data[j-i] = 1.;\n        }\n        else if(box(j) && (neighbors >= ruleSet[0] && neighbors <= ruleSet[1])) {\n            if (!useColor) data[j-i] = 1.;\n            else if(useColor) data[j-i] = max(boxColor(j) - 0.2,0.);\n        }\n        // dead cell\n        else if(!box(j) && (neighbors >= ruleSet[2] && neighbors <= ruleSet[3])){\n            if(!useColor) data[j-i] = 1.;\n            else if(useColor) data[j-i] = 1.;\n        }\n        else if (!box(j) && useColor) data[j-i] = 1.;\n        \n        else{\n            if (!useColor) data[j-i] = box(j) ? 1. : 0.;\n            else if (useColor) data[j-i] = boxColor(j);\n        }\n        \n    }\n    return vec4(data[0], data[1], data[2], data[3]);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = load0(fragCoord);\n    bool refresh = load1(repos).x == 1. ? true : false;\n    float sp = load1(sppos).x;\n    if(iTime == 0.0 || iFrame == 0 || refresh){       \n        if(int(fragCoord.x) >= bpos1.x && int(fragCoord.x) <= bpos2.x && int(fragCoord.y) >= bpos1.y && int(fragCoord.y) <= bpos2.y){\n            fragColor=vec4(getRandom(1., fragCoord),getRandom(2., fragCoord),getRandom(3., fragCoord),getRandom(4., fragCoord));\n        }\n        else if(int(fragCoord.x) >= fpos1.x && int(fragCoord.x) <= fpos2.x && int(fragCoord.y) >= fpos1.y && int(fragCoord.y) <= fpos2.y){\n            fragColor=vec4(1.);\n        }\n        else fragColor=vec4(0.);\n        return;\n    }\n    \n    if(sp == 1.) {\n        \n        if(int(fragCoord.x) >= bpos1.x && int(fragCoord.y) >= bpos1.y && int(fragCoord.x) <= bpos2.x && int(fragCoord.y) <= bpos2.y) {\n            int i = (bordsize* (ivec2(fragCoord)-bpos1).x + (ivec2(fragCoord)-bpos1).y)*4;\n            fragColor = gameLogic(i, false);\n        }\n        else if(int(fragCoord.x) >= fpos1.x && int(fragCoord.y) >= fpos1.y && int(fragCoord.x) <= fpos2.x && int(fragCoord.y) <= fpos2.y) {\n            int i = (bordsize * (ivec2(fragCoord)-fpos1).x + (ivec2(fragCoord)-fpos1).y)*4;\n            fragColor = gameLogic(i, true);\n        }\n        else fragColor = vec4(0.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}