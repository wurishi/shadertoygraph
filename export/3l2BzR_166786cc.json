{"ver":"0.1","info":{"id":"3l2BzR","date":"1598220787","viewed":175,"name":"Griddy Headache","username":"scanlime","description":"Still Bad.!?\n\nJust playing with grids and raymarching, it's a rounded checkerboard reflected in a rounded cube.\n\nMouse moves the light source.\n\nVideo rendering: https://diode.zone/videos/watch/63097c93-77dc-4201-b876-a47731711b0a","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","cubes","grids","gridjunk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float box(vec3 p, vec3 r)\n{\n\treturn length(max(vec3(0.), abs(p) - r));\n}\n\nmat3 rotX(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat3(1.,0.,0.,0.,c,-s,0.,s,c);\n}\n\nmat3 rotY(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat3(c,0.,s,0.,1.,0.,-s,0.,c);\n}\n\nfloat sdf(vec3 p)\n{\n    float t = iTime * .01;\n    float d = -length(p - vec3(0.)) + 10.;\n\tp -= vec3(0., 0., 5.);\n    p *= rotX(t);\n    p *= rotY(t);\n    d = min(d, box(p, vec3(1.)) - .5\n            + 0.03*length(sin(p * vec3(3.)))\n     );\n    return d;\n}\n\nfloat pattern(vec3 p)\n{\n    float fz = .1;\n    vec3 gridcoord = vec3(1e2) + vec3(.2,0.,0.) * iTime + p * vec3(8.);\n    vec3 gridval = mod(gridcoord, vec3(1.));\n\tfloat g = (smoothstep(.2-fz, .2+fz, gridval.x) - smoothstep(.7-fz, .7+fz, gridval.x)) +\n              (smoothstep(.2-fz, .2+fz, gridval.y) - smoothstep(.7-fz, .7+fz, gridval.y));    \n\treturn smoothstep(.5-fz, .5+fz, g) -\n           smoothstep(1.5-fz, 1.5+fz, g);\n}\n\nvec3 samp(vec2 coord)\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (coord/res - vec2(.5)) * vec2(res.x/res.y, 1.);\n\n    vec3 ep = vec3(0.01, 0., 100.);\n    vec3 eye = vec3(0., 0., 0.);\n\tvec3 view = normalize(vec3(uv.xy, 1.));\n  \tfloat dist = 0., st = 0.;\n\n    vec3 light = normalize(vec3(iMouse.xy / iResolution.xy, -1.));\n\n    for (int i=0; i<60; i++) {\n        vec3 pt = eye + view * dist;\n\t\tdist += (st = sdf(pt));\n        if (st < ep.x) {\n\t\t\tvec3 grad = normalize(\n                vec3(sdf(pt + ep.xyy) - st,\n                     sdf(pt + ep.yxy) - st,\n                     sdf(pt + ep.yyx) - st));            \n            return\n                vec3(.2,.2,.6) * dot(grad, light) +\n                vec3(.3,.4,.3) * pow(dot(grad, light), 20.) +\n                vec3(.4,.3,.5) * pattern(grad);\n        }\n    }\n\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    int i = 0;\n    color = vec4(0.,0.,0.,1.);\n    while (++i <= 8) {\n\t\tcolor.rgb += samp(coord + vec2(\n            float((i * 13) & 15)/12.,\n            float((i * 40) & 15)/12.));\n    }\n\tcolor.rgb /= float(i-1);\n}","name":"Image","description":"","type":"image"}]}