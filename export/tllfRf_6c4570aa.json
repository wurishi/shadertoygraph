{"ver":"0.1","info":{"id":"tllfRf","date":"1597366662","viewed":425,"name":"Color Balance(Photoshop)","username":"Wunkolo","description":"A simple sample of Photoshop's \"Color Balance\" feature, a 3-point piece-wise linear interpolation that remaps input color values into an output color value","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["colorcorrection","colorgrading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 InvLerp( vec3 A, vec3 B, vec3 t)\n{\n    return (t - A) / (B - A);\n}\n\nconst vec3 Shadows = vec3(-0.25, 0.0, 0.0); // Remove some red from the shadows(make it more cyan)\nconst vec3 Midtones = vec3(0.0, 0.125, 0.125); // Add a bit of blue-green to the midtones\nconst vec3 Hilights = vec3(0.5, 0.0, 0.0); // Add some red to the hilights\n\nvec3 ColorGrade( in vec3 InColor )\n{\n    // Calculate the three offseted colors up-front\n    vec3 OffShadows  = InColor + Shadows;\n    vec3 OffMidtones = InColor + Midtones;\n    vec3 OffHilights = InColor + Hilights;\n    \n    // Linearly interpolate between the 3 new colors, piece-wise\n    return mix(\n        // We pick which of the two control points to interpolate from based on which side of\n        // 0.5 the input color channel lands on\n        mix(OffShadows,  OffMidtones, InvLerp(vec3(0.0), vec3(0.5), InColor)), // <  0.5\n        mix(OffMidtones, OffHilights, InvLerp(vec3(0.5), vec3(1.0), InColor)), // >= 0.5\n        greaterThanEqual(InColor, vec3(0.5))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord.xy / vec2(iResolution.xy);\n    fragColor.a = 1.0;\n    fragColor.rgb = texture(iChannel0, UV).rgb;\n    if( UV.y <= pow(sin(iTime * 0.5),2.0) )\n    {\n        fragColor.rgb = ColorGrade(fragColor.rgb);\n    }\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(2.2));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord.xy / vec2(iResolution.xy);\n    fragColor = vec4(fragCoord.x/float(iResolution.x));\n    \n    if( (1.0 - UV.x) + (UV.y + 0.5 * pow(sin(iTime),2.0)) <= 1.0)\n    {\n        fragColor = texture(iChannel1, UV);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}