{"ver":"0.1","info":{"id":"NtsGDf","date":"1623009934","viewed":141,"name":"Sherbert Swirl","username":"ptrgags","description":"An experiment with domain warping on the unit disk. This swirls points around by using a combination of non-uniform stretching and twisting interleaved.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spiral","domainwarping","unitdisk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141593\n#define ITERATIONS 12\n\nvec3 pick_color(vec2 polar) {\n    // Divide the circle into grid cells and color each randomly\n    vec2 polar_cell = floor(vec2(4, 8) * polar);\n    vec2 uv = polar_cell / iChannelResolution[0].xy;\n    return texture(iChannel0, uv + vec2(0.1, 0.2)).rgb;\n}\n\nvec2 twist(vec2 polar, float twist_amount) {\n  return vec2(polar.x, fract(polar.y + twist_amount));\n}\n\nvec2 radial_stretch(vec2 polar, float control_point) {\n    float r = polar.x;\n    // This polynomial goes through the curves (0, 0), (1, 1)\n    // and the point (0.5, control_point). \n    float stretched = \n        (2.0 - 4.0 * control_point) * r * r + \n        (4.0 * control_point - 1.0) * r;\n    // The polynomial doesn't necessarily stay in range.\n    stretched = clamp(stretched, 0.0, 1.0);\n    return vec2(stretched, polar.y);\n}\n\nvec2 warp(vec2 polar) {\n    // Alternate between stretching radially and twisting. The stretching\n    // varies sinusoidally, and the twisting falls off with the number\n    // of iterations.\n    for (int i = 0; i < ITERATIONS; i++) {\n      float stretch_amount = 0.5 + 0.01 * sin(2.0 * PI * 8.0 * polar.y);\n      polar = radial_stretch(polar, stretch_amount);\n      float amp = 0.3 / (float(i) + 1.0);\n      polar = twist(polar, amp * polar.x - 0.03 * iTime);\n    }\n    return polar;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    float r = length(uv);\n    float theta = fract((atan(uv.y, uv.x) / 2.0 / PI) + 1.0);\n    vec2 polar = vec2(r, theta);\n    \n    \n    // warp the domain\n    vec3 color = pick_color(warp(polar));\n\n    // I'm only concerned with the unit disk.\n    float unit_disk = smoothstep(1.01, 1.0, length(uv));\n    fragColor = vec4(unit_disk * color, 1.0);\n}","name":"Image","description":"","type":"image"}]}