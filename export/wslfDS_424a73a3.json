{"ver":"0.1","info":{"id":"wslfDS","date":"1589022546","viewed":153,"name":"Blocky Screen Transition Effect","username":"LunarLambda","description":"A rough approximation of an idea for a screen transition I had.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// World Famous\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 get_color(vec2 a) {\n\tint c = int(rand(a) * 7.);\n    \n    switch (c) {\n    \tcase 0:\n        \treturn vec3(1.,0.,0.);\n       \tcase 1:\n        \treturn vec3(0.,1.,0.);\n        case 2:\n        \treturn vec3(0.,0.,1.);\n        case 3:\n        \treturn vec3(1.,.5,0.);\n        case 4:\n        \treturn vec3(1.,1.,0.);\n        case 5:\n        \treturn vec3(1.,0.,1.);\n        case 6:\n        \treturn vec3(0.,1.,1.);\n    }\n    \n    return vec3(1.);\n}\n\n// Thanks to The6P4C for the help with maths\nvec2 rotate(vec2 uv) {\n    float theta = radians(-11.25);\n    mat2 rot = mat2(\n        cos(theta), -sin(theta),\n        sin(theta), cos(theta)\n    );\n    \n    vec2 center = iResolution.xy/2.;\n    uv = (uv - center) * rot + center;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Loop every ~5s for demonstration purposes\n    // In game this should be done with real time\n    float t = mod(iTime, 5.) / 2.;\n    \n    // Normalized coordinates, quantized to 16x16 squares\n    // There's probably a nicer way to express this\n    fragCoord = rotate(fragCoord);\n    vec2 uv = (fragCoord-mod(fragCoord, 16.)) / iResolution.xy;\n\n    // Average of x and y creates a diagonal gradient from bottom left to top right\n    // Make y smaller to give the gradient a steeper angle\n    // This may need aspect ratio correction? Not sure\n    float a = (uv.x + uv.y*0.25) / 2.;\n\n    // Add a bit of randomness to make it look swankier :3\n    a += rand(uv) * 0.05;\n    \n    // Colorful! Like Tetrominoes\n    vec3 color = get_color(uv)+0.25;\n    //color = vec3(0.,a*1.5,1.);\n    \n    // Use that gradient as a measure of when to color each square\n    if (t > a && t < a+1.) {\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.);\n    }\n}","name":"Image","description":"","type":"image"}]}