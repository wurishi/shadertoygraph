{"ver":"0.1","info":{"id":"XftSRB","date":"1714076844","viewed":39,"name":"FieldFX nÂ°1","username":"Marex","description":"This is weird 3d animation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shaderjam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//GLOBAL VARIABLES\n\nconst vec2 ep= vec2 (.00035,-.00035);\nconst float far=80.;\n\nfloat box1(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat box2(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat sphere(vec3 p,float r){return length(p)-r;}\n\n\nfloat map(vec3 p){\n  float Box1=box1(p-vec3(sin(iTime*20.)-10.,0,10.),vec3(sin(iTime*5.)/2.+2.));\n  float Box2=box2(p-vec3(-sin(iTime*20.)+10.,0,10.),vec3(sin(iTime*5.)/2.+1.));\n  float Sphere=sphere(p+vec3(sin(iTime*10.)*5.,0,0),2.);\n  float scene= min(Box1/Box2,Sphere);\n  return scene;\n}\n  \nfloat raycast( vec3 rayOrigin, vec3 rayDirection ){\n    float dist,result=0.;                           //Distance & result variables\n    for(int i=0;i<128;i++){                         //Raymarching forward in loop\n        dist=map(rayOrigin+rayDirection*result);    //Get distance\n        if(dist<.0001||result>far) break;           //.0001 = precision; 80 = FAR plane; If dist < precision OR gone too far: stop marching\n        result+=dist;                               //Jump forward\n    }\n    return result;\n}\n\nmat2 rotate2d(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\n\n //If shader runs more than a few minutes, modulo _t by 10*PI to avoid noisy glitches due to sin precision, see below\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    //time=mod(_t,62.832); //If shader runs for more than few minutes, modulo _t by 20*pi and use \"time\" instead of \"_t\" everywhere\n    vec2 uv=(fragCoord/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1.);     //Raymarching UVs\n\n  uv = uv*sin(iTime)*2.;\n  \n  vec2 rotatedUV=uv*rotate2d(abs(sin(iTime*2.))*2.5);\n  vec2 rotatedUV2=uv*rotate2d(-iTime);\n\n  float pattern =sin(iTime*20.+rotatedUV2.x/rotatedUV2.y*20.);\n  \n  vec3 rayOrigin=vec3(0,0,-10);\n  vec3 rayDirection=normalize(vec3(rotatedUV,-abs(sin(iTime*10.))/2.+1.));\n  vec3 backgroundColor=vec3(-abs(sin(iTime*5.))+0.25*pattern*2.);\n  vec3 color=backgroundColor;\n  float result=raycast(rayOrigin,rayDirection);\n  if(result < far){\n    color=vec3(0.5+0.5*cos(iTime+uv.xyx+vec3(0,3,3)));\n  }\n\n    fragColor=vec4(pow(max(color,0.),vec3(.4545)),1);   //Avoid negative values: max(color,0.); Gamma correction: pow(x,vec3(.4545))\n}","name":"Image","description":"","type":"image"}]}