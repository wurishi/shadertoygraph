{"ver":"0.1","info":{"id":"MtdGW7","date":"1469723878","viewed":610,"name":"Alien radar","username":"runekill","description":"My first experiments with shader based on &quot;The Book of Shaders by Patricio Gonzalez Vivo &amp; Jen Lowe&quot; and some community examples. Probably my imlementation of digits is siliest among represented.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["simple","mouse","tutorial","line","circle","radar","digit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Alien detector v 0.2\n//alien meter added.\n// Based on works:\n//https://www.shadertoy.com/view/4s2SRt by ndel\n//https://www.shadertoy.com/view/Xsy3zG by Andre\n//http://patriciogonzalezvivo.com/2015/thebookofshaders/08/ by patricio gonzalez\n//welcome to use\n#define outerRadius 0.24\n#define outerDottedRadius 0.23\n#define innerDottedRadius 0.11\n#define innerRadius 0.1\n#define cirleWidth 0.01\n#define PI 3.1415926535897932384626433832795\n#define red   vec3(1.00,0.38,0.227)\n#define blue vec3(0.09,0.45,0.76)\n//one segment for alien meter\nfloat segment(vec2 uv)\n{\n    uv = abs(uv.yx);\n\treturn (1.0-smoothstep(0.08,0.10,uv.x))\n         * (1.0-smoothstep(0.46,0.49,uv.y+uv.x))\n         * (1.3 - length(uv*vec2(2.8,2.0)));\n}\n//convert one segment to digit\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    //two left segment of the digit\n    float twoLeft = segment(vec2(abs(uv.y),uv.x-0.5))+segment(vec2(abs(uv.y-1.),uv.x-0.5));\n    //three horizontal segement\n    float threeHorizontal=segment(vec2((uv.x),abs(uv.y-1.5)))+segment(vec2((uv.x),abs(uv.y-0.5)))\n        +segment(vec2((uv.x),abs(uv.y+0.5)));\n    //one left down and one right up\n    float downUpVertical = segment(vec2(abs(uv.y),uv.x+0.5)) \n        + segment(vec2(abs(uv.y-1.),uv.x-0.5));\n    //opposite to previous\n    float upDownVertical = segment(vec2(abs(uv.y),uv.x-0.5)) \n        + segment(vec2(abs(uv.y-1.),uv.x+0.5));\n       \n    if (num==1) seg = twoLeft;\n    if (num==2) seg = downUpVertical + threeHorizontal;\n    if (num==3) seg = twoLeft + threeHorizontal;\n    if (num==4) seg = twoLeft+segment(vec2(abs(uv.y-1.),uv.x+0.5))+segment(vec2((uv.x),abs(uv.y-0.5)));\n    if (num==5) seg = upDownVertical + threeHorizontal;\n    if (num==6) seg = upDownVertical + threeHorizontal+segment(vec2(abs(uv.y),uv.x+0.5));\n    if (num==7) seg = twoLeft+segment(vec2((uv.x),abs(uv.y-1.5)));\n\tif (num==8) seg = upDownVertical+ downUpVertical + threeHorizontal;\n    if (num==9) seg = upDownVertical+ twoLeft + threeHorizontal;\n    if (num==0) seg = upDownVertical+ downUpVertical+segment(vec2((uv.x),abs(uv.y-1.5)))+segment(vec2((uv.x),abs(uv.y+0.5)));\n    \n    seg += (upDownVertical+ downUpVertical+threeHorizontal)*0.15;\n    \n\treturn seg;\n}\n//make value out of digit\nfloat printValue(vec2 uv,float num){\n\t\n\tfloat v=0.; \n\n    for(float i=0. ; i<2. ; i++){\n        //convert float to two figures\n\t\tfloat d=num/pow(10.,i)*10.;\n        d = mod(floor(d+0.000001),10.0);\n\t\tv+=sevenSegment(uv+vec2(i*1.3,0.),int(d));\n\t}\n\n    return v;\n}\n//rotate radar\nvec2 rotate(vec2 uv, float angle)\n{\n    float a = angle*PI/180.0; \n    vec2 c = vec2(uv.x*cos(a)-uv.y*sin(a), //rotate\n                    uv.x*sin(a)+uv.y*cos(a));\n    return c;\n}\nfloat line(vec2 center, vec2 uv, float radius, float theta,float start,float finish)\n{\n\tvec2 d = uv - center;\n\n    vec2 p = vec2(cos(theta*PI/180.0),\n                        -sin(theta*PI/180.0));\n    float l = length( d - p*clamp( dot(d,p)/dot(p,p), radius*start, radius*finish) );\n    l = smoothstep(cirleWidth,cirleWidth-0.02,l);\n    return l;\n}\nvec3 bip(vec2 uv, vec2 center, float width)\n{\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float scale = mod(iTime,2.);\n    float angle = 0.5 * abs(cos(center.x));\n    float circle = smoothstep(min(0.0,scale), scale+width, r)\n       * smoothstep(scale+width, min(0.0,scale), r);\n    circle += smoothstep(scale, scale+width/4., r)\n       * smoothstep(scale+width/4.,scale, r)*2.*PI;\n\n    return vec3(circle);\n}\n\nfloat circle (vec2 center, vec2 uv, float r)\n{\n    float distanceToCenter = distance(center,uv);\n\tfloat distancePointToCircle = abs(distanceToCenter - r);\n\treturn smoothstep(r,r+cirleWidth,distancePointToCircle) * \n        smoothstep(r+cirleWidth, r,distancePointToCircle);\n}\nfloat outerDottedCircle (vec2 center, vec2 uv, float r)\n{\n    float distanceToCenter = distance(center,uv);\n\tfloat distancePointToCircle = abs(distanceToCenter - r);\n\tfloat c = smoothstep(r,r+cirleWidth,distancePointToCircle) * \n        smoothstep(r+cirleWidth, r,distancePointToCircle)\n        *(step(0.39,abs(uv.y))*step(0.39,abs(uv.x)));\n    \n    return c;\n   \n    \n}\nfloat innerDottedCircle (vec2 center, vec2 uv, float r)\n{\n    float distanceToCenter = distance(center,uv);\n\tfloat distancePointToCircle = abs(distanceToCenter - r);\n\tfloat c = smoothstep(r,r+cirleWidth,distancePointToCircle) * \n        smoothstep(r+cirleWidth, r,distancePointToCircle)\n        *(step(0.39,abs(uv.x))+step(0.39,abs(uv.y)));\n    \n    return c;\n   \n    \n}\nfloat alien (vec2 coord, vec2 uv)\n{\n    float distanceToCenter = distance(coord,uv);\n    return abs(sin(5.*iTime)) * smoothstep(cirleWidth*2.,cirleWidth,distanceToCenter);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 color;\n    vec2 alienCoord = vec2(-0.2,-0.25); //coordinates of alien\n    vec2 uv = fragCoord.xy / iResolution.xy; //move coordinates to 0..1\n    vec2 center = uv/2.; //find center\n    //distance meter\n    float digit = length(alienCoord*10.);\n    float digitSize = 40.;\n    float l = printValue(uv*digitSize-vec2(19.8,2.),digit);\n    color.r+=l;\n    //bottom frontier\n    float bottom = step(0.9,1.-uv.y);\n    float bottom2 = step(0.975,1.-uv.y);\n    float r=step(.2, length(center.xy)); //left side cut\n    float r2=step(.2, length(center.xy-vec2(0.49,0.0))); //right side cut\n    color+=clamp(bottom-r,0.0,1.0)*blue;\n    color+=clamp(bottom-r2,0.0,1.0)*blue;\n    color+=clamp(bottom2*r2*r,0.0,1.0)*blue;\n\n    //coordinates for radar\n    uv = uv*2.; // scale coordinates to 0..+2\n    uv.x *= iResolution.x/iResolution.y; //correct x coordinate\n    uv.x-=1.7; //translate x to center\n    vec2 mouse = vec2(iMouse.xy);\n    uv = rotate(uv,mouse.x);\n\tcenter = uv/2.; //find center\n    \n\n\t//circles\n    color += vec3(outerDottedCircle(center,uv,outerDottedRadius))*2.*blue;\n    color += vec3(innerDottedCircle(center,uv,innerDottedRadius))*2.*blue;\n    color += vec3(circle(center,uv,outerRadius))*2.*blue;\n    color += vec3(circle(center,uv,innerRadius))*2.*blue;\n    //bip\n    color += bip(uv,center,0.1)*blue;\n    //aim big lines\n    color += line (center,uv,outerRadius,45.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,90.,0.7,2.1)*blue;\n    color += line (center,uv,outerRadius,135.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,180.,0.7,2.1)*blue;\n    color += line (center,uv,outerRadius,225.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,270.,0.7,2.1)*blue;\n    color += line (center,uv,outerRadius,315.,0.8,2.1)*blue;\n    color += line (center,uv,outerRadius,0.,0.7,2.1)*blue;\n    //small lines\n    color += line (center,uv,outerRadius,25.,1.9,2.1);\n    color += line (center,uv,outerRadius,65.,1.9,2.1);\n    color += line (center,uv,outerRadius,115.,1.9,2.1);\n    color += line (center,uv,outerRadius,155.,1.9,2.1);\n    color += line (center,uv,outerRadius,205.,1.9,2.1);\n    color += line (center,uv,outerRadius,245.,1.9,2.1);\n    color += line (center,uv,outerRadius,295.,1.9,2.1);\n    color += line (center,uv,outerRadius,335.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,30.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,60.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,120.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,150.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,210.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,240.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,300.,1.9,2.1);\n    color += line (center,uv,innerDottedRadius,330.,1.9,2.1);\n    //alien\n\tcolor += alien(center+alienCoord,uv);\n\n    //final color\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}