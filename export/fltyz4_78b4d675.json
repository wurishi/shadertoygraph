{"ver":"0.1","info":{"id":"fltyz4","date":"1659410682","viewed":602,"name":"Earth Shell","username":"H2ongzh","description":"Reference: \n1. https://www.shadertoy.com/view/lslXDr\n2. https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n\nCurrently, only rayleigh scattering is applied.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["space","atmosphererendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Hong Zhang\n// Date: 08/01/2022\n// a sample for atmosphere rendering\n\n#define inScatterSample 50\n#define outScatterSample 10\n#define PI 3.14159265359\n#define MaxV 10e10\n#define Gramma(x) pow(x, vec3(1./2.2))\n#define rad(x) x * PI / 180.\n\n// the radius of the earth and atmosphere\n#define r_e 1.\n#define r_a 1.5 * r_e\n\n// the camera \n#define FOV 45.\n#define cam vec3(0., 0., 2.5 * r_a)\n\n// scatter \nconst vec3 Kr = vec3(3.8, 13.5, 33.1); // rayleigh constant coeffcient\nconst vec3 Km = vec3(21.0); // mie constant coeffcient\nconst float Hr = 0.04;  // rayleight scale height\nconst float Hm = 0.01;  // mie scale height, not be used currently\n\n// the sun\nconst float sunIntensity = 10.;\n\n\n// Commons\n// compute the view ray in the camera coordinate\nvec3 computeView(vec2 uv){\n    float w_h_ratio = iResolution.x/iResolution.y;   \n    float h = tan(rad(FOV/2.));\n    return normalize(vec3(-w_h_ratio*h, -h, -1.) + vec3(uv.x*2.*h*w_h_ratio, uv.y*2.*h, 0.));\n}\n\n// compute the intersections\nvec2 computeIntersection(vec3 origin, vec3 ray, float radius){\n    float factor = pow(dot(origin, ray), 2.) - (dot(origin, origin) - radius * radius);\n    if(factor >= 0.){\n        float t1 = -dot(origin, ray) - sqrt(factor);\n        float t2 = -dot(origin, ray) + sqrt(factor);\n        return vec2(t1, t2);\n    }\n    return vec2(MaxV, -MaxV);\n}\n\n// compute the density of atmosphere\nfloat density(vec3 p, float hp){\n    float h = max(0., length(p) - r_e);\n    return exp(-h/hp);\n}\n\n// transmittance\nvec3 transmittance(vec3 begin, vec3 end){\n    vec3 interval = (end - begin) / float(outScatterSample);\n    float t_ray = 0.;\n    vec3 sum = vec3(0.);\n    for(int i = 0; i < outScatterSample; i += 1){\n        vec3 p = begin + float(i) * interval;\n        t_ray += density(p, Hr);\n    }\n    sum = exp(-Kr * t_ray * length(interval));\n    return sum;\n}\n\n// scatter\nvec3 scatter(vec3 p, float theta){\n    vec3 s_r = Kr * 3./16./PI * (1. + theta * theta) * density(p, Hr); // rayleigh\n    return s_r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float alpha = iTime;\n    vec3 sun_dir = vec3(cos(alpha), 0., sin(alpha));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    // compute the view dir\n    vec3 view = computeView(uv);\n    \n    // AB segment\n    vec2 AB = computeIntersection(cam, view, r_a);\n    vec2 AE = computeIntersection(cam, view, r_e);\n    if(AB == vec2(MaxV, -MaxV)){\n        fragColor = vec4(0.);\n    }\n    \n    vec3 A = cam + view * min(AB.x, AB.y);\n    vec3 B;\n    if(AE == vec2(MaxV, -MaxV)){\n        B = cam + view * max(AB.x, AB.y);\n    }\n    else{\n        B = cam + view * min(AE.x, AE.y);\n    }\n    \n    float theta = dot(view, -sun_dir);\n    vec3 interval = (B - A)/float(inScatterSample);\n    vec3 col = vec3(0.);\n    // in scatter\n    for(int i = 0; i < inScatterSample; ++i){\n        vec3 P = A + float(i) * interval;\n        \n        vec2 SP = computeIntersection(P, -sun_dir, r_a);\n        vec3 S = P + max(SP.x, SP.y) * (-sun_dir);\n        \n        vec3 s_p = scatter(P, theta);\n        vec3 T_sp = transmittance(S, P);\n        vec3 T_pa = transmittance(P, A);\n        col += s_p * T_sp * T_pa;\n    }\n    \n    col = Gramma(sunIntensity * col * length(interval));\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}