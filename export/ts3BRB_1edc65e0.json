{"ver":"0.1","info":{"id":"ts3BRB","date":"1605999914","viewed":101,"name":"Lines dance 5","username":"gusvogel","description":"music video for martin chapman's ep treasure\nmouse up on Y axis to show circles.","likes":2,"published":1,"flags":96,"usePreview":0,"tags":["music","lines","dance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// track - Garbage by Martin Chapman\n\n// hashes by dave hoshkins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float circlesMode = getCirclesMode(iTime);\n    vec2 quadrant = fragCoord.xy/iResolution.xy * 2.;\n    float index = floor(quadrant.x) + floor(quadrant.y) * 2. + 1.;\n    quadrant-=1.;\n    \n    //quadrant.x *= iResolution.x/iResolution.y; \n    quadrant = abs(quadrant);\n    float xoff = (iResolution.x - iResolution.y) / iResolution.x; \n    //quadrant.x += (iResolution.x - iResolution.y) / iResolution.x * .5;\n   \n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tvec3 col = vec3(.9);\n\tvec4 p = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n\tfloat d = p.r;\n    float floorTime = floor(iTime * bpm );\n    float mode = .75 + .25 * cos(.3* iTime + index); // try .5;\n    \n    float colorPhase = smoothstep(outro + 12., outro, iTime); // by time, but lets do it by mouse instead.\n   \tcolorPhase = smoothstep(0.95, 0.85, iMouse.x / iResolution.x);\n    \n    if(circlesMode < 1.){\n    \td = 0.; // get rid of lines\n    }\n    fragColor.rgb = mix(vec3(1.4 , .5*abs(sin(iTime)), .76 * cos(iTime)), col, max(mode + d, 0.));\n    \n    // add circles to one quadrant\n    if(circlesMode < 1. || mod(index + floorTime, 4.) < -.31 + iMouse.y/iResolution.y * 4.){\n    \tfragColor.rgb = mix(fragColor.rgb, fragColor.rgb *= vec3(2., 1. , 0.) * vec3(colorPhase), p.g);\n        //fragColor.b += p.b * (1. + cos(iTime)); /// too long on pink. use this to change color per circle\n    }\n    // recolor the lines per quadrant\n    fragColor.rgb = mix(vec3(1., index*.2, 1. - index*.2) * colorPhase, fragColor.rgb, smoothstep(-1.,.1, .2+d * (index)) );\n\t\n    //fragColor.rgb = mix( fragColor.rgb *= vec3(2., 1. , 0.) * vec3(colorPhase),fragColor.rgb, smoothstep(-1.,.1, .2+d ));\n\n    \n    \n    vec4 \n        n = texelFetch(iChannel1, ivec2(fragCoord.xy)+ivec2(0,1) , 0),\n     \ts = texelFetch(iChannel1, ivec2(fragCoord.xy)+ivec2(0,-1) , 0),\n        e = texelFetch(iChannel1, ivec2(fragCoord.xy)+ivec2(1,0) , 0),\n     \tw = texelFetch(iChannel1, ivec2(fragCoord.xy)+ivec2(-1,0) , 0);\n    \n    //fragColor.g += w.r; fragColor.b += e.r;\n            \n    vec3 norm = normalize(vec3(e.a-w.a, n.a-s.a, .0));\n    vec3 normUps = normalize(vec3(e.a-w.a, n.a-s.a, .0) *.5 + .5);\n    vec3 gradient = 1. - normUps;\n    \n    //fragColor.rg *= norm.xy; // show normal\n    fragColor.rgb *= gradient + .5;\n    \n    vec3 crazy3 = vec3(cos(3.*iTime - index),sin(iTime + index),0.);\n    vec3 ncol = fragColor.rgb + (vec3(1. * sin(iTime), -.2* cos(iTime), -.5)+ .09*hash12((uv)*1000.)) * vec3(clamp(0.,.1,dot(norm, crazy3)));\n    \n    fragColor.rgb = mix(fragColor.rgb, ncol , 1.5 );//* fract(iTime * bpm * .125 ));//* smoothstep(.85, .95, iMouse.x / iResolution.x));\n    \n    //float distL1 = distance(vec2(sin(iTime), cos(iTime)), (uv - .5)*3.);\n    //fragColor *= (1.-distL1);\n        \n    float vig = length(uv);\n    fragColor.rgb *= (1.-pow(vig, 3.));\n\n    //fragColor *= fragColor;\n    //fragColor *= 1.45;\n    //fragColor *= 1. + .09*hash12((uv)*1000.); // add a grain to the backgroun\n    \n    //fragColor.rgb = vec3(1. + d); // show lines only\n    \n    \n    #if SQUARERATIO\n    if(quadrant.x > (iResolution.y/iResolution.x)) fragColor *= .5; // frame for instagram, square aspect ratio\n   \t#endif\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XljGDd","filepath":"https://soundcloud.com/martin-renan-chapman/garbage","previewfilepath":"https://soundcloud.com/martin-renan-chapman/garbage","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define gradientWidth .018\n#define lineWidth .011\n\n#define testTime 264.53\n\n// hashes by dave hoshkins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat ln (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n\nfloat lnd (vec2 p, vec2 a, vec2 b) {\n    vec2 v = p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n    if(v.x * v.y > 0.) return 1.;\n    else return 0.;\n}\n\nfloat circle(vec2 p, vec2 c, vec2 center){\n    return 1.-smoothstep(0., .01, abs(length(p - center) - length(c - center)));\n}\n\nfloat interiorCircle(vec2 p, vec2 c, vec2 center, float fuz){\n    float r = length(c - center);\n    return smoothstep(0., -r * fuz, length(p - center) - r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    float circlesMode = getCirclesMode(iTime);\n    vec2 quadrant = fragCoord.xy/iResolution.xy * 2.;\n    float index = floor(quadrant.x) + floor(quadrant.y) * 2. + 1.;\n    quadrant -= 1.;\n    quadrant.x *= iResolution.x/iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / iResolution.yy; //\n    \n    uv = abs(quadrant);\n    uv.x += .3; // cent\n    \n    vec2 center = vec2(.5/iResolution.y*iResolution.x, .5);\n    \n    //float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n\tvec3 col = vec3(0.) ;\n    float d = 0.;\n    float h = 0.;\n    float c = 0.;\n    vec2 pt = center;\n    #if SQUARERATIO\n    pt = vec2(.5);\n    #endif\n    \n    float fft  = texelFetch( iChannel0, ivec2(50. * index,0), 0 ).x; \n    float time = floor(iTime * bpm );// +floor(fft * 3.);\n    float ftime = fract(iTime * bpm + index*.2 );\n    \n    vec2 prev = pt - (hash23(vec3(time, 1000.*index, time)) -.5) * fft*.2;\n    \n    prev.x *= iResolution.x/iResolution.y;\n    vec2 dir = hash23(vec3(0.*100., time, 1000.*index)) -.5;\n    prev += dir * ftime * 1. *cos(ftime);\n    vec2 orig = prev;\n    \n    float i = 0.;\n    for(i; i < 4.; ++i){\n    \n\n        vec2 curr = .5 - (hash23(vec3(time * index, 1000.*index, i)) -.5)*2. * fft * .3;\n        \n        #if RIGHTANGLES\n        if(mod(i, 2.) == 0.){ // force right angles\n            curr.y = prev.y;\n            curr.x *= iResolution.x/iResolution.y;\n        }\n        else curr.x = prev.x;\n        #else\n        \n        curr.x *= iResolution.x/iResolution.y;\n        #endif\n        \n        vec2 dir = hash23(vec3(i*100. * index, index*1000., time)) -.5;\n        \n        vec2 choose = vec2(mod(index, 2.), mod(i, 2.));\n        curr += dir * choose * ftime * cos(ftime);\n        \n        vec2 toCenter = center-curr;\n        float lenToCenter = length(toCenter);\n        curr.x +=  1. * toCenter.x * lenToCenter*lenToCenter; // prevent random points from leaving the \n        \n        \n        float ld = ln(uv, prev, curr);\n        d -= 1. - smoothstep(0., lineWidth, ld);\n        h +=  clamp(0.,1.,pow(1.-ld,2.));\n        \n        float cdist = circle(uv, curr, prev);\n        if(circlesMode >= 1.)\n        \tcdist = interiorCircle(uv, orig, prev, (1.)/4. + .001);\n        c+= cdist;\n        //h += interiorCircle(uv, curr, prev, 4.); \n        col.b += cdist * i;\n        prev = curr;\n        \n    }\n    \n    // reconnect to original pt\n    float ld = ln(uv, prev, orig);\n    d -= 1. - smoothstep(0., lineWidth, ld);\n    h +=  clamp(0.,1.,pow(1.-ld,2.));\n    float cdist = interiorCircle(uv, orig, prev, (1.)/4. + .001);\n    c+= cdist;\n    col.b += cdist * i;\n\tcol.r = d;\n    col.g = c;\n    \n    \n\tfragColor = vec4(col,h);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SQUARERATIO 1\n#define RIGHTANGLES 1\n\n#define intro 12.5\n#define outro 200.\n\nfloat bpm  = 157./ 60. / 2.;\n\nfloat getCirclesMode(float time){ \n   return 2.* fract(time * bpm * .125);\n}","name":"Common","description":"","type":"common"}]}