{"ver":"0.1","info":{"id":"XfdXDs","date":"1714721669","viewed":63,"name":"Penumbra via angle intervals","username":"Ultraviolet","description":"I saw @chronos [url=https://www.shadertoy.com/view/4ctSRX]shader[/url] and it made me want to try another approach.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["shadow","circle","penumbra","analytical","soft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    forked from  https://www.shadertoy.com/view/4ctSRX\n*/\n\nconst float PI = 3.14159265;\n\n\n\n// computes the boolean intersection of input intervals\nvec2 intersect(vec2 i0, vec2 i1) {\n    return vec2(max(i0.x, i1.x), min(i0.y, i1.y));\n}\n\n// computes the measure of input interval\nfloat measure(vec2 i) {\n    return max(0., i.y-i.x);\n}\n\n// split input interval at PI\nvec4 split(vec2 i) {\n    return vec4(i.x, min(PI, i.y), max(PI, i.x), i.y);\n}\n\n\n// computes the length of the intersection of input intervals\n// note: accounts for angle wrap around +/- PI\nfloat measure_intersection(vec2 i0, vec2 i1) {\n    vec4 i0_  = split(i0);\n    vec4 i1_  = split(i1);\n    \n    float o = 0.;\n    o += measure(intersect(i0_.xy, i1_.xy));\n    //o += measure(intersect(i0_.xy, i1_.zw));\n    //o += measure(intersect(i0_.zw, i1_.xy));\n    o += measure(intersect(i0_.zw, i1_.zw));\n    \n    return o;\n}\n\n// computes the occlusion factor of object 1 regarding object 0\nfloat occlude(vec3 a0, vec3 a1) {\n    float o = measure(a0.xy);\n    if(a1.z > a0.z)\n        return o;\n        \n    o -= measure_intersection(a0.xy, a1.xy);\n    o -= measure_intersection(a0.xy+vec2(2.*PI), a1.xy);\n    o -= measure_intersection(a0.xy-vec2(2.*PI), a1.xy);\n    \n    return o;\n}\n\n// computes the angle interval + depth of the occluding circular obstacle as seen from pos\nvec3 get_angles(vec2 obs_pos, float obs_rad, vec2 pos) {\n    vec2 diff = obs_pos-pos;\n    float d = length(diff);\n    float beta = atan(diff.y, diff.x);\n    if(obs_rad > d)\n        return vec3(-PI, PI, 0.);\n    float alpha = asin(obs_rad / d);\n    return vec3(beta-alpha, beta+alpha, d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 mouse = ( 2.*iMouse.xy - iResolution.xy ) / iResolution.y;\n    float ps = 2. / iResolution.y;\n\n    vec2 sun_pos  = vec2(-1,0);\n    vec2 moon_pos = vec2(0.75 + .75 * sin(iTime*.75),0);\n    \n    if(iMouse.z>0.5)\n        moon_pos = mouse;\n    \n    float sun_radius = 0.4 + 0.25 * cos(iTime);\n    float moon_radius = 0.2;\n    \n    vec3 i_moon = get_angles(moon_pos, moon_radius, uv);\n    vec3 i_sun = get_angles(sun_pos, sun_radius, uv);\n    float visible_sun = occlude(i_sun, i_moon);\n    visible_sun /= 2.*PI;\n    vec3 color = vec3(visible_sun);\n    \n    \n    float moon_alpha = smoothstep(moon_radius+ps, moon_radius-ps, distance(uv, moon_pos));\n    color = mix(color, vec3(0.5), moon_alpha);\n\n    float sun_alpha = smoothstep(sun_radius+ps, sun_radius-ps, distance(uv, sun_pos));\n    color = max(color, sun_alpha);\n    \n    color = pow(color, vec3(1./2.2));\n    \n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}