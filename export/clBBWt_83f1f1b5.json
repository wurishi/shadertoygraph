{"ver":"0.1","info":{"id":"clBBWt","date":"1694598802","viewed":161,"name":"a cdrom method with refraction","username":"ljs_harbin","description":"This cdrom algorithm is based on refraction and reflection, and is different from the Alan Zucconi's method on diffraction.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","anisotropy","cdrom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Many years ago, I implemented a cdrom material in VisTitle, a character generator software, using hlsl of Direct3D.\n// This cdrom algorithm is based on refraction and reflection, and different from the Alan Zucconi's method on diffraction.\n// https://www.alanzucconi.com/2017/07/15/the-nature-of-light/\n// This time I rewrite it to glsl for shadertoy.\n// Click and drag to rotate the CD manually.\n// Adjust fGrooveAngle and fRefraction param to get other result.\n\nconst float pi = 3.1415926535897932;\nfloat radius_in = 0.2;\nfloat radius_out = 0.9;\nfloat fGrooveAngle = pi / 10.0;\nvec3 fRefraction = vec3(1.1, 1.2, 1.3);\nconst float LOD = 4.0;\n\nmat3 axis_x_rotation_matrix(float angle) {\n\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t0.0, cos(angle), -sin(angle),\n\t\t\t\t0.0, sin(angle), cos(angle));\n}\n\nmat3 axis_y_rotation_matrix(float angle) {\n\treturn mat3(cos(angle), 0.0, sin(angle),\n\t\t\t\t0.0,        1.0, 0.0,\n\t\t\t\t-sin(angle), 0.0, cos(angle));\n}\n\nvec3 trace_color(float fSinKeep, vec3 normal, vec3 v3InputDirVKeep, vec3 v3NormalGroove)\n{\n    vec3 outColor = vec3(0.0);\n\tint i;\n\tfor (i=0; i<3; i++)\n\t{\n\t\tfloat fSin = fSinKeep / fRefraction[i];\n\t\tfloat fAngleOutput1 = asin(fSin);\n\t\tfloat fCos = cos(fAngleOutput1);\n\t\tvec3 v3DirOut1 = -normal * fCos - v3InputDirVKeep * fSin;\n\t\t\n\t\t// 2: reflect\n\t\tfloat fDot2 = dot(v3NormalGroove, -v3DirOut1);\n\t\tif (fDot2 > 0.0)\n\t\t{\n\t\t\tvec3 v3InputDirU = v3NormalGroove * fDot2;\n\t\t\tvec3 v3DirOut2 = v3InputDirU * 2.0f + v3DirOut1;\n\t\t\t\n\t\t\t// 3: refraction(inverse)\n\t\t\tfloat fDot3 = dot(-normal, -v3DirOut2);\n\t\t\tif (fDot3 > 0.0)\n\t\t\t{\n                fDot3 = clamp(fDot3, 0.0, 1.0);\n\t\t\t\tv3InputDirU = -normal * fDot3;\n\t\t\t\tvec3 v3InputDirV = -v3DirOut2 - v3InputDirU;\n\t\t\t\tv3InputDirV = normalize(v3InputDirV);\n\t\t\t\tfloat fAngleInput1 = acos(fDot3);\n\t\t\t\tfSin = sin(fAngleInput1);\n\t\t\t\tfSin *= fRefraction[i];\n                if (fSin > 1.0)\n                    outColor[i] = 0.0;\n                else\n                {\n                    // fAlpha for soften hard border\n                    float fAlpha = clamp(fSin * (-10.0f) + 10.0f, 0.0, 1.0f);\n                    fAngleOutput1 = asin(fSin);\n                    fCos = cos(fAngleOutput1);\n                    vec3 v3DirOut3 = normal * fCos - v3InputDirV * fSin;\n\n                    vec3 v3Refract = textureLod(iChannel0, v3DirOut3, LOD).xyz;\n                    outColor[i] = v3Refract[i] * fAlpha;\n                }\n\t\t\t}\n\t\t}\n\t}\n\n    return outColor;\n}\n\nvec4 refraction_color(vec3 pos, vec3 normal, vec3 view_dir)\n{\n    float radius = length(pos);\n    if (radius < radius_in || radius > radius_out)\n        return vec4(0.0);\n\n    vec3 binormal = normalize(pos);\n    vec3 tangent = cross(binormal, normal);\n    vec3 v3RefractionColor = vec3(0.0);\n    float fDot1 = dot(view_dir, normal);\n    if (fDot1 > 0.0)\n    {\n        fDot1 = clamp(fDot1, 0.0, 1.0);\n        float fSin = sin(fGrooveAngle);\n        float fCos = cos(fGrooveAngle);\n\n        vec3 v3Temp = binormal * fSin;\n        vec3 v3NormalPos = normal * fCos + v3Temp;\n        vec3 v3NormalNeg = normal * fCos - v3Temp;\n\n        // 1: refraction\n\t\tvec3 v3InputDirU = fDot1 * normal;\n\t\tvec3 v3InputDirVKeep = view_dir - v3InputDirU;\n\t\tv3InputDirVKeep = normalize(v3InputDirVKeep);\n\t\tfloat fAngleInput1 = acos(fDot1);\n\t\tfloat fSinKeep = sin(fAngleInput1);\n\n        vec3 v3RefractionColorPos = trace_color(fSinKeep, normal, v3InputDirVKeep, v3NormalPos);\n        vec3 v3RefractionColorNeg = trace_color(fSinKeep, normal, v3InputDirVKeep, v3NormalNeg);\n        v3RefractionColor = max(v3RefractionColorPos, v3RefractionColorNeg);\n    }\n    return vec4(v3RefractionColor, 1.0);\n}\n\nvec4 scene(vec3 view_direction, vec3 camera_location)\n{\n    vec3 normal[2];\n    normal[0] = vec3(0.0, 0.0, 1.0);\n    normal[1] = vec3(0.0, 0.0, -1.0);\n    vec3 pos = vec3(0.0);\n    for (int i = 0; i < 2; i++)\n    {\n        float den = dot(view_direction, normal[i]);\n        if (den >= 0.0)\n            continue;\n        float t = dot(-camera_location, normal[i]) / den;\n        pos = camera_location + view_direction * t;\n        return refraction_color(pos, normal[i], -view_direction);\n    }\n\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera_location = vec3(0.0, 0.0, 16.0);\n\n\tvec2 screen_space_coords = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tscreen_space_coords.x *= aspect_ratio;\n\n    vec2 screen_space_mouse_coords = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n\tscreen_space_mouse_coords.x *= aspect_ratio;\n\tscreen_space_mouse_coords.y = -screen_space_mouse_coords.y;\n\n\tmat3 rotation = axis_y_rotation_matrix(screen_space_mouse_coords.x + iTime);\n\trotation *= axis_x_rotation_matrix(screen_space_mouse_coords.y);\n\tvec3 view_direction = normalize(vec3(screen_space_coords, 0) - camera_location);\n\tview_direction *= rotation;\n    camera_location *= rotation;\n\n    fragColor = scene(view_direction, camera_location);\n}","name":"Image","description":"","type":"image"}]}