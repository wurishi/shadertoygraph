{"ver":"0.1","info":{"id":"3d3yzn","date":"1631671423","viewed":62,"name":"a fish","username":"mkorenchan","description":"this is a fish","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHES 100\n#define MIN_MARCH_DIST .01\n#define MAX_MARCH_DIST 100.\n#define LAMBERT_SHININESS 32.\n#define PI 3.14159265358979323846264338397\n\n\nbool approx(float x, float y) {\n\treturn abs(x-y) < 0.01;\n}\n\nmat2 rotMat(float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot(vec3 p, int axis, float angle) {\n    if (axis == 0) {\n        p.yz *= rotMat(angle);\n    }\n    else if (axis == 1) {\n        p.xz *= rotMat(angle);\n    }\n    else {\n        p.xy *= rotMat(angle);\n    }\n    return p;\n}\n\nvec3 scale(vec3 p, int axis, float k) {\n    if (axis == 0) {\n        p.x *= k;\n    }\n    else if (axis == 1) {\n        p.y *= k;\n    }\n    else {\n        p.z *= k;\n    }\n    return p;\n}\n\n\nvec2 uvAtPoint(vec3 p) {\n\tvec3 n = normalize(p - vec3(0, 1, 0));\n    float rho = length(n);\n    float u = atan(n.z, n.x);\n    float v = acos(n.y / rho);\n    return vec2(u,v);\n}\n\nfloat scaleTexture(vec2 texCoord) {\n    vec2 uv = texCoord;\n    float f = 0.;\n    for (float i = 0.; i < 3.; i += 1.) {\n        vec2 new_uv = uv + 4.552*sin(2.*i) + .5*cos(6.*i);\n        vec2 tile =  2.*fract(10.*new_uv) - 1.;\n        \n        float r = length(tile);\n        f += smoothstep(1.,0.3,r);\n    }\n    f /= 2.;\n    return clamp(f,0.,1.);\n}\n\nfloat distToSphere(vec3 point, vec4 sphere) {\n    float offset = scaleTexture(.6*uvAtPoint(point));\n\n\treturn -.01*offset + length(point-sphere.xyz) - sphere.w;\n}\n\nfloat distToGroundPlane(vec3 point) {\n\treturn point.y;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2(length(p.xz), p.y );\n    float d1 = -q.y - c.z;\n    float d2 = max(dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdRoundCone(vec3 p, \n\nfloat sdFish(vec3 p) {\n    //p.z += .5*sin(iTime+p.x);\n    float body = sdCapsule(vec3(p.x, .4*p.y + .5, p.z), vec3(-.5,1,0), vec3(.5,1,0), .3);\n    float tail = sdCone(scale(rot(p-vec3(.7,1.3,0),2,-PI/2.), 2, 5.), vec2(.3), .5);\n    \n\n    \n    return min(body, tail); //- scaleTexture(uvAtPoint(p))*.005 ;\n}\n\n\n\n\n\n\n\n\nfloat sdf(vec3 point) {\n\tfloat ds = sdFish(point);\n    float dg = distToGroundPlane(point);\n    return ds;\n}\n\nvec3 getColorAtPoint(vec3 point) {\n    return vec3(1.);\n    return texture(iChannel0, uvAtPoint(point)).xyz;\n}\n\nvec3 normalAtPoint(vec3 point) {\n\t//approximate the gradient of the distance function\n    float epsilon = 0.001;\n    float distP = sdf(point);\n    float distPx = sdf(point - vec3(epsilon, 0, 0));\n    float distPy = sdf(point - vec3(0, epsilon, 0));\n    float distPz = sdf(point - vec3(0, 0, epsilon));\n    vec3 grad = vec3(distP - distPx, distP - distPy, distP - distPz);\n    return normalize(grad);\n}\n\nfloat rayMarch(vec3 point, vec3 dir) {\n \tfloat march_dist = 0.;\n    for(int i = 0; i < MAX_MARCHES; i++) {\n    \tvec3 p = point + march_dist * dir;\n        float t = sdf(p);\n        if (t > MAX_MARCH_DIST || t < MIN_MARCH_DIST) break;\n        march_dist += t;\n    }\n    return march_dist;\n}\n\nvec3 getLightingAtPoint(vec3 point, vec3 cam_pos) {\n\t//vec3 lightPos = 2.*vec3(cos(iTime), 1, sin(iTime));\n    vec3 lightPos = vec3(-8,6,-5);\n    \n    vec3 lightDir = normalize(lightPos - point);\n    vec3 viewDir = normalize(point - cam_pos);\n    vec3 normal = normalAtPoint(point);\n    point += 0.1 * normal;\n    \n    vec3 lambertAmbient = vec3(0.11);\n    //vec3 lambertDiffuse = vec3(clamp(dot(normal, lightDir), 0., 1.));\n    float diff = clamp(dot(normal, lightDir), 0., 1.);\n    vec3 lambertDiffuse = diff * getColorAtPoint(point);\n    float spec = 0.*pow(clamp(dot(lightDir, reflect(viewDir, normal)), 0.,1.), LAMBERT_SHININESS);\n    vec3 lambertSpecular = vec3(spec);\n    //Handle shadows\n//    if(rayMarch(point, lightDir) < length(lightPos - point)) {\n //   \tlambertDiffuse *= 0.4;\n  //  }\n    vec3 lambertComposite = lambertAmbient + lambertDiffuse + lambertSpecular;\n    \n    \n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(length(uv));\n    \n    vec3 cam_pos = vec3(0, 1, -3);\n    vec3 ray_dir = normalize(vec3(uv, 1));\n    \n    mat2 rot = rotMat(-(iMouse.x - abs(iMouse.z)) / 40.);\n    cam_pos.xz *= rot;\n    ray_dir.xz *= rot;\n    \n    float dist = rayMarch(cam_pos, ray_dir);\n    vec3 point = cam_pos + dist * ray_dir;\n    \n    col = dist > MAX_MARCH_DIST ? vec3(0) : getLightingAtPoint(point, cam_pos);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}