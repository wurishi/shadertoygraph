{"ver":"0.1","info":{"id":"DlcBDs","date":"1701717029","viewed":106,"name":"Log Spiral Mapping with AA","username":"UnstableLobster","description":"This works well for any kind of SDF because the derivatives are the same in both X and Y directions in polar space, the AA factor would need to be interpolated based on the SDF normal otherwise.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["spiral","mapping","aa","log"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.0)\n#define TAU (PI*2.0)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define erf(x) tanh(2.0/sqrt(PI) * (x + (11.0/123.0)*x*x*x))\n//#define erf(x) clamp(x, -1.0, 1.0)\n#define mixSDF(a, b, s, t) mix(a, b, erf(-s/t*2.0)*0.5+0.5)\n\nvec2 logCoords(vec2 uv)\n{\n    float a = atan(uv.y, uv.x)/TAU;\n    float d = log(length(uv)) - a + iTime*0.1;\n    \n    float x = floor(d) + a;\n    float y = fract(d);\n    \n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 O, vec2 P )\n{\n    vec2 uv = (P - iResolution.xy*0.5)/iResolution.x;  \n    vec2 logUV = logCoords(uv);\n\n    // Derivative\n    float wd = 1.0/length(uv) / iResolution.x;\n    \n    // X parameters\n    float xStretch = TAU;\n    float xFactor = 0.0;\n    \n    logUV.x *= xStretch;\n    logUV.x += logUV.y*xFactor;\n    \n       \n    O = vec4(1.0);\n    \n    // Grid\n    float xLines = 2.0*6.0 / TAU;\n    float yLines = 3.0;\n    float gridLinePixels = 1.0;\n    \n    vec2 grid = logUV;\n    \n    grid.x = fract(grid.x * xLines);\n    grid.x = 1.0 - abs(grid.x - 0.5) - 0.5;\n    grid.x /= xLines;\n    \n    grid.y = fract(grid.y * yLines);\n    grid.y = 1.0 - abs(grid.y - 0.5) - 0.5;\n    grid.y /= yLines;\n    \n    \n    float gx = grid.x - 0.5*gridLinePixels*wd;\n    float gy = grid.y - 0.5*gridLinePixels*wd;\n    \n    O.xyz = mixSDF(O.xyz, vec3(0.5), gx, wd);\n    O.xyz = mixSDF(O.xyz, vec3(0.5), gy, wd);\n   \n    \n    // Equator\n    vec2 equator = logUV;\n    equator.y = 1.0 - abs(equator.y - 0.5) - 0.5;\n    \n    float linePixels = 3.0;\n    float cd = equator.y - 0.5*linePixels*wd;\n   \n    O.xyz = mixSDF(O.xyz, vec3(0.0), cd, wd);\n    \n    \n    // Basis vectors\n    vec2 basis = logUV;\n    basis.x -= iTime*(xStretch/10.0) - 13.0;\n    \n    float xArrowSdf = sdArrow(basis, vec2(0.25, 1.0/3.0), vec2(0.5, 1.0/3.0), 0.008, 0.03) - 0.01;\n    float yArrowSdf = sdArrow(basis, vec2(0.25, 1.0/3.0), vec2(0.25, 0.575), 0.008, 0.03) - 0.01;\n    float zArrowSdf = length(basis - vec2(0.25, 1.0/3.0)) - 0.04;\n    \n    O.xyz = mixSDF(O.xyz, vec3(1.000,0.302,0.302), xArrowSdf, wd);\n    O.xyz = mixSDF(O.xyz, vec3(0.298,0.902,0.298), yArrowSdf, wd);\n    O.xyz = mixSDF(O.xyz, vec3(0.200,0.333,1.000), zArrowSdf, wd);\n    \n    \n    // Random arrows\n    vec2 arrows = logUV;\n    arrows.x += iTime*4.0;\n    float arrowID = abs(floor(arrows.x*0.1));\n    arrows.x = fract(arrows.x*0.1);\n    arrows.x /= 0.1;\n    \n    float h = (hash(uint(arrowID))-0.5)*0.5;\n    \n    float arrow = sdArrow(arrows, vec2(1.75, 0.5 + h), vec2(0.75, 0.5 + h), 0.008, 0.035) - 0.01;\n    O.xyz = mixSDF(O.xyz, O.xyz*0.5, arrow, wd);\n    \n   \n    // Gamma\n    O = pow(O , vec4(1.0/2.2));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//https://www.shadertoy.com/view/slj3Dd\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    // constant setup\n    const float k = 3.0;   // arrow head ratio\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    // === distance (four segments) === \n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n    //----\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n    //----\n    if( p.x<w1 ) // conditional is optional\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n    //----\n    if( pz.x>0.0 ) // conditional is optional\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    // === sign === \n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 ) //if( p.x>0.0 && z>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\n//https://www.shadertoy.com/view/WttXWX\n#define hashi(x)   triple32(x) \n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat smoothWave(float a, float t, float s, float d)\n{\n    float tau = acos(-1.0)*2.0;\n    return a/atan(1.0/d) * atan(sin(tau*t*s)/d);\n}","name":"Common","description":"","type":"common"}]}