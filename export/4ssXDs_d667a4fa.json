{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI 3.14\n#define GLOSS_SAMPLES 512.0\n#define INV_GLOSS_SAMPLES 0.0025\n\n// define a sphere\nvec3 spherePos = vec3( 0.0, 0.0, -10.0 );\nfloat sphereRadius = 20.0;\n\n// define cameraPos\nvec3 eyePos = vec3( 0.0, 0.0, 50.0 );\n\n// define near plane distance from cameraPos (towards -Z)\nfloat nearPlaneDistanceFromEye = 20.0;\nfloat nearPlaneSize = 35.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenSpacePixelNormalized = fragCoord.xy / iResolution.xy;\n    vec2 worldSpacePixelNormalized = 2.0 * screenSpacePixelNormalized - vec2( 1.0, 1.0 );\n    worldSpacePixelNormalized.x *= iResolution.x / iResolution.y;\n    vec3 worldSpacePixel = vec3( worldSpacePixelNormalized * nearPlaneSize, 0.0 );\n    \n    // We have to rotate the pixel position too as we are rotating the camera \n    float s = sin( iTime * 0.2 );\n    float c = cos( iTime * 0.2 );\n \t\n    // Camera rotation around sphere\n    float r = length( eyePos - spherePos );\n    eyePos.x = r * s;\n    eyePos.z = r * c + spherePos.z;\n\n    // rotate the near plane too\n    worldSpacePixel.z = worldSpacePixel.x * -s;\n    worldSpacePixel.x = worldSpacePixel.x * c; \n    \n    // Now translate the near plane from eyePos towards spherePos\n    vec3 los = normalize( eyePos - spherePos );\n    worldSpacePixel.xz += spherePos.xz + nearPlaneDistanceFromEye * los.xz;\n    \n    // Ray direction\n    vec3 rayDir = worldSpacePixel - eyePos;\n    rayDir = normalize( rayDir );\n    \n    float t = dot( spherePos - eyePos, rayDir );\n    vec3 intersectionPoint = eyePos + t * rayDir;\n    \n    // find min intersection point\n    if ( distance( intersectionPoint, spherePos ) < sphereRadius )\n    {\n        float p = length( intersectionPoint - spherePos );\n        float dist = sqrt( sphereRadius * sphereRadius - p * p );\n        vec3 surfacePoint = intersectionPoint - dist * rayDir;\n        \n        // normal at intersectionPoint \n        vec3 normalDir = normalize( surfacePoint - spherePos );\n        vec3 reflectedRay = reflect( rayDir, normalDir );\n        \n         // Compute UV mapping for the sphere\n        float u = 0.5 + ( atan( -normalDir.z, -normalDir.x ) / ( 2.0 * PI ) );\n        float v = 0.5 - ( asin( -normalDir.y ) / PI );\n        \n        vec4 textureColor = texture( iChannel2, vec2( v, u  ) );\n        // perturb the refleted ray according to the textureColor\n        reflectedRay += length(textureColor.xyz) * 0.2;\n        \n        vec4 reflectedColor = texture( iChannel0, reflectedRay ); \n        \n        \n        vec4 shadingColor = reflectedColor * 0.5;\n        float glossFactor = ( ( 1.0 - cos( 7.2 * 0.2 ) ) * 0.45 );\n        \n        // For a glossy object, sample the cubemap with reflectedRay with some noise applied\n        for ( float i = 0.0; i < GLOSS_SAMPLES; i++ )\n        {\n \t\t\tfloat randomSampler = i * INV_GLOSS_SAMPLES;\n            vec4 noiseValue = texture( iChannel3, screenSpacePixelNormalized + vec2(2.0 * randomSampler, -randomSampler) );\n            vec3 perturbedReflectedRay = reflectedRay + noiseValue.xyz * glossFactor;\n            shadingColor += texture( iChannel0, perturbedReflectedRay );\n        }\n        \n        shadingColor *= INV_GLOSS_SAMPLES;       \n        \n        // This is not a correct interpolation\n        // When shadingColor is high the textureColor should be lower\n        // So the \n        fragColor = mix( shadingColor, textureColor, length(textureColor) / length(shadingColor) * 0.4 );\n        //fragColor = mix( shadingColor, textureColor, 0.5 );\n    }\n    else\n    {\n        fragColor = texture( iChannel0, rayDir );\n    }  \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssXDs","date":"1407884906","viewed":585,"name":"Glossy reflections","username":"pdsharma","description":"Glossy reflections are a result of tracing rays in a solid angle around reflection vector and accumulating results from the cubemap.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ibl","physicallybasedshading"],"hasliked":0,"parentid":"","parentname":""}}