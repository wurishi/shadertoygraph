{"ver":"0.1","info":{"id":"lXcXzf","date":"1719346585","viewed":116,"name":"snell's window","username":"Swifter","description":"https://www.youtube.com/watch?v=fBVexeNj7wE","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["refraction","water","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 1e-3\n#define OCEAN_HEIGHT 10.0\n#define PI2 6.28318530718\n#define PROJECTION_DIST 0.3\n\n// some functions/concepts adapted from https://www.shadertoy.com/view/Ms2SD1\n\nfloat luminance(vec3 col) {\n  return dot(col, vec3(0.2126, 0.7152, 0.0722)); \n}\n\nvec3 getSkyboxCol(vec3 dir) {\n   vec3 blue = vec3(0.1,0.5,0.7);\n\n   float l = 1.0 - length(dir.xz);\n   l = pow(l, 2.0) * 5.0;\n   vec3 col = blue + vec3(l);\n   return vec3(col);\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat seaMap(vec3 p) {\n    float theta = noise(p.xz * 0.5 + iTime * 0.4) * 3.;\n    vec2 dir = vec2(cos(theta), sin(theta));\n\n    float result = noise(p.xz + iTime * 0.4 + dir * 0.6);\n    result *= 0.2;\n    return result;\n}\n\nvec3 getSeaNormal(vec3 p) {\n    vec3 n;\n    n.y = seaMap(p);    \n    n.x = seaMap(vec3(p.x + EPSILON, p.y, p.z)) - n.y;\n    n.z = seaMap(vec3(p.x, p.y, p.z + EPSILON)) - n.y;\n    n.y = EPSILON;\n    return normalize(n);\n}\n\nvec3 intersectPlaneXZ(vec3 dir, float height) {\n    float amp = height / dir.y;\n    return dir * amp;\n}\n\nvec3 lightRays(vec2 uv) {\n    vec2 p;\n    p.x = atan(uv.y, uv.x);\n    p.y = length(uv) * 0.1 - iTime * 0.03;\n    p *= 10.0;\n    float n = noise(p);\n    float mask = min(1.0, abs(uv.y * 10.0));\n    n *= mask;\n    n *= 0.05;\n    return vec3(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float aspect = iResolution.y / iResolution.x;\n    uv.x /= aspect;\n\n    vec3 viewDir = normalize(vec3(uv.x, PROJECTION_DIST, uv.y));\n    vec3 point = intersectPlaneXZ(viewDir, OCEAN_HEIGHT);\n    vec3 waterNormal = getSeaNormal(point);\n    vec3 refraction = refract(viewDir, waterNormal, 1.333);\n    \n    vec3 col = vec3(0.0);\n    \n    float l = length(uv);\n    \n    if (refraction.y == 0.0) { // view vector hit critical angle\n        refraction = viewDir;\n        refraction.y *= -1.0;\n        \n        vec3 c1 = vec3(0.1,0.4,0.5);\n        vec3 c2 = vec3(0.2,0.5,0.8);\n        col = mix(c2, c1, l * 0.4);\n    }\n    else { // view vector made it into air\n        vec3 sky = getSkyboxCol(refraction);\n        col = sky;\n    }\n    \n    col += (1.0 - l) * 0.4;\n    col += pow(max(0.0, 1.0 - l * 2.), 4.0);\n    \n    col += lightRays(uv);\n\n    fragColor = vec4(col, 0.0);\n    \n}","name":"Image","description":"","type":"image"}]}