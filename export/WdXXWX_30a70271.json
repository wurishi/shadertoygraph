{"ver":"0.1","info":{"id":"WdXXWX","date":"1552281661","viewed":135,"name":"triangle rain","username":"twopointfive","description":"triangle rain","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["trianglerain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// lorry    twopointfive@163.com    crapell engine\n// https://blog.csdn.net/twopointfive/article/details/8925003\n\n\n//闪烁 三角雨\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.732050;//sqrt(3.0); 1.73205080756\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nvec3 hash( vec2 p ) // rand in [0,1]\n{  \t\t\t\t\t\t\n\tvec3 r = vec3( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)),\n              dot(p,vec2(173.7,153.3)));\n\treturn  fract(sin(r+20.)*53758.5453123);\n}\n\n// rotation\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    mat4 R = rotationMatrix(axis, angle);\n    return (R*vec4(p,1.0)).xyz;\n}\n        \n//xz轴边长gridSize划分格子 一个格子一个三角形\nfloat gridSize = 1.;\nfloat maxStep( in vec3 pos ,in vec3 rd,in vec3 gridFloorPos)\n{\n    //return gridSize*0.2;\n    float res = 1e10;\n    /*\n        a b\n\t\tc d\n       比如射线依次穿过cdb，cb里的球等高，d里球特高，相交d球时可能返回很大的跨步\n\t*/\n    if( rd.x>0.)\n    {\n        vec3 planeNormal = vec3(-1.,0.,0.);\n        vec3 planePos = gridFloorPos + vec3(gridSize,0.,0.);\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    else if( rd.x<0.)\n    {\n        vec3 planeNormal = vec3(1.,0.,0.);\n        vec3 planePos = gridFloorPos;\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    \n    if( rd.y>0.)\n    {\n        vec3 planeNormal = vec3(0.,-1.,0.);\n        vec3 planePos = gridFloorPos + vec3(0.,gridSize,0.);\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    else if( rd.y<0.)\n    {\n        vec3 planeNormal = vec3(0.,1.,0.);\n        vec3 planePos = gridFloorPos;\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.0001,res);\n    }\n    \n    if( rd.z>0.)\n    {\n        vec3 planeNormal = vec3(0.,0.,-1.);\n        vec3 planePos = gridFloorPos + vec3(0.,0.,gridSize);\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    else if( rd.z<0.)\n    {\n        vec3 planeNormal = vec3(0.,0.,1.);\n        vec3 planePos = gridFloorPos;\n        float t = (dot(planeNormal,planePos) - dot(planeNormal,pos)) / dot(planeNormal,rd);\n        res = min(t+0.001,res);\n    }\n    return res;\n}\n\nvec2 map2( in vec3 pos ,in vec3 rd)\n{\n    float time = mod(iTime,20.);\n    vec2 res = vec2( 1e10, 0.0 );\n    vec3 gridFloor = floor(pos/gridSize);\n    vec3 gridNoise = hash(gridFloor.xz);\n        \n\tvec3 primPos = (gridFloor*gridSize) + vec3(gridSize*0.5,0.,gridSize*0.5);\n\tprimPos.y = 4.-mod(time*(gridNoise.x*0.8+0.2),8.);//一条竖线画一个球  ，也可以尝试画多个球\n\n\t//trans\n\tvec3 posLocal = (pos-primPos);\n\t//rot\n\tposLocal = rotate(posLocal, (gridNoise*2.-1.), time);\n\t//scale 导致dist被缩放而不正确\n    vec3 scale = vec3(gridNoise.xy*0.6+0.4,1.)*2.3;//max 2.5;\n\t//posLocal *= scale;\n\n    vec2 resP = vec2( sdTriPrism(  posLocal, vec2(0.5*scale.x,0.05) ),43.5 );\n    //vec2 resP = vec2( sdSphere( posLocal, 0.5),43.5 ) ;\n    //vec2 resP = vec2( sdBox( posLocal, vec3(0.5,0.5,0.5)),43.5 ) ;\n    \n    //resP.x  /= scale; //不正确 \n\tres = opU( res,  resP);\n    \n    /////////////////////\n    vec3 gridFloorPos = gridFloor*gridSize;\n\tfloat maxstep = maxStep( pos , rd, gridFloorPos);\n    res.x = min(maxstep,res.x);\n    return res;\n}\n\n\nvec2 map( in vec3 pos ,in vec3 rd)\n{\n    float time = mod(iTime,20.);\n    vec2 res = vec2( 1e10, 0.0 );\n    vec3 gridFloor = floor(pos/gridSize);\n    \n    //if(gridFloor.z ==-3.)\n    {\n        \n    vec3 gridNoise = hash(gridFloor.xz);\n        \n\tvec3 primPos = (gridFloor*gridSize) + vec3(gridSize*0.5,0.,gridSize*0.5);\n\tprimPos.y = 4.-mod(time*(gridNoise.x*0.8+0.2),8.);\n    \n\n\t//trans\n\tvec3 posLocal = (pos-primPos);\n\t//rot\n\tposLocal = rotate(posLocal, (gridNoise*2.-1.), time);\n\t//scale 导致dist被缩放而不正确\n    vec3 scale = vec3(gridNoise.xy*0.6+0.4,1.)*2.3;//max 2.5;\n\t//posLocal *= scale;\n\n    vec2 resP = vec2( sdTriPrism(  posLocal, vec2(0.5*scale.x,0.05) ),43.5 );\n\tres = opU( res,  resP);\n    }\n    \n    /////////////////////\n    vec3 gridFloorPos = gridFloor*gridSize;\n\tfloat maxstep = maxStep( pos , rd, gridFloorPos);\n    res.x = min(maxstep,res.x);\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    //floor plane\n    float tp1 = (-5.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    } \n    \n    // raymarch primitives   \n    {\n        tmin = 1.;\n        tmax = 30.;\n        float t = tmin;\n        for( int i=0; i<70 ; i++ )\n        {\n            if(t>=tmax) break;\n            vec2 h = map( ro+rd*t ,rd);\n            if( h.x<0.0001 )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n\t\t\tt += h.x;\n        }\n    }\n    return res;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ,rd).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos , in vec3 rd)\n{\n    rd = vec3(0.,0.,0.);\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ,rd).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx  ,rd).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy  ,rd).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx  ,rd).x );   \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec3 rd )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos,rd ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) ;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos,rd );\n        vec3 ref = reflect( rd, nor );\n        \n        // material   \n        \n        //reflect\n        col = texture(iChannel0,ref).rgb;\n\n        // lighting\n        //float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        //dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00);//*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n        //fog\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.001*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0;// + iTime;\n\t\n    vec3 ro = vec3( 0., 2., 0. );\n    vec3 ta = vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    vec3 col = render( ro, rd );\n\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}