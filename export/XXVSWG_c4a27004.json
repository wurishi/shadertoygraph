{"ver":"0.1","info":{"id":"XXVSWG","date":"1720464483","viewed":50,"name":"Fractal Generator 3D","username":"Imagyx","description":"I used my Generator from the 2D examples and applied it a to a generalized (tbd) form of a 3D fractal.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","raytrace","generator","parametrize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/************************************************************************************************************************\\\n|* 3D Fractal Generator                                                                                                 *|\n|*   based on formula from distance estimator compendium (https://jbaker.graphics/writings/images/DEC/fractal_de15.png) *|\n|*   and raytracer from iq (https://www.shadertoy.com/view/3ljcRh)                                                      *|\n|*   as well as pseudo random generator from Dave_Hoskins (https://www.shadertoy.com/view/XdGfRR)                       *|\n|*                                                                                                                      *|\n|* Defines                                                                                                              *|\n|* REFINE: Factor < 1.0 to compensate for inaccuracies in the distance estimation                                       *|\n|* SPEED: Horizontal scroll speed for showing \"all\" random fractals generated by parameters and ranges                  *|\n|* EPS: Defines how fine the details of the fractal should be (between a big sphere and fine dust ;-))                  *|\n|* OFFSET: To show and save position of a certain fractal (starting point)                                              *|\n\\************************************************************************************************************************/\n\n/*\nTODOs (for a later version, this is just a POC)\n- Better shading\n- Better way for clamping or bounding the fractal to make it tileable like the 2D case\n- Fix artefacts (maybe this contains a solution: https://iquilezles.org/articles/sdfrepetition/) \n- More parameters\n- Add transformations and operations\n- Add AO and soft shadows\n*/\n\n#define REFINE 0.5\n#define SPEED 1.0\n#define EPS 0.002\n#define OFFSET 219.0\n\n#define SPLIT 2.0\n\nfloat de(vec3 q) {\n    float ca, cb, cc, cd, ce, cf, cg, ch;\n    vec3 da, db;\n    vec3 id = 2394.0 + floor((q - SPLIT) / (2.0 * SPLIT));\n    applyRange(ca, vec2(3.0, 7.0), id + 96.971);\n    applyRange(cb, vec2(0.05, 0.2), id + 117.971);\n    applyRange(cc, vec2(0.9, 1.1), id + 328.971);\n    applyRange(cd, vec2(1.2, 1.8), id + 436.971);\n    applyRange(ce, vec2(1.0, 1.4), id + 545.971);\n    applyRange(cf, vec2(0.0, 1.0), id + 654.971);\n    applyRange(da, mat2x3(vec3(0.5, 0.5, 3.4), vec3(0.7, 0.7, 3.6)), id + 7683.33);\n    applyRange(db, mat2x3(vec3(0.0), vec3(0.2, 0.2, 0.0)), id + 8592.33); // only x and y\n\n// Create 3D-tiles (and find a better solution...)\nq = q - SPLIT * round(q / SPLIT);\n\nq = abs(q) - ce;\n    if(q.x < q.z){\n        q.xz = -q.zx;\n    }\n    if(q.y < q.z){\n        q.yz = -q.zy;\n    }\n    if(q.y < q.x){\n        q.xy = -q.yx;\n    }\n    float s = 1.0;\n    for(float i = 0.0; i < ca; i+= 1.0) {\n        q = abs(q);\n        if(cf > 0.8){ // not too often\n            q = eulerRotation(db) * q; // sometimes creates a really ugly effect on the fractal...\n        }\n        float r = 2.0 / clamp(dot(q, q), cb, cc);\n        s *= r;\n        q *= r;\n        q -= da;\n    }\n    q -= clamp(q, -cd, cd);\n    return length(q) / s; \n}\n\nfloat sdf(in vec3 p){\n    p.x -= (iTime + OFFSET) * SPEED;\n    float dist = de(p) * REFINE;\n    dist = max(dist, p.z + 1.0); // clipping\n    return dist;\n}\n\n/**************************************************************************/\n/* Source of basic raytracing code: https://www.shadertoy.com/view/3ljcRh */\n/* Only adjusted for purpose of scrolling, detail, viewing position etc.  */\n/**************************************************************************/\nfloat map(in vec3 pos){\n    return sdf(pos);\n}\nvec3 calcNormal( in vec3 pos){\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = EPS * 0.1;\n    return normalize( e.xyy*map(pos + e.xyy * eps) + \n\t\t\t\t\t  e.yyx*map(pos + e.yyx * eps) + \n\t\t\t\t\t  e.yxy*map(pos + e.yxy * eps) + \n\t\t\t\t\t  e.xxx*map(pos + e.xxx * eps) );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat an = 3.1415926536 * 0.5; // make horizontal scrolling possible at the x-axis\n\tvec3 ro = 1.0 * vec3(1.0 * cos(an), 0.0, 1.0 * sin(an));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 tot = vec3(0.0);\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n    const float tmax = 6.0;\n    float t = 0.0;\n    for(int i = 0; i < 512; i++){ // more steps for more details\n        vec3 pos = ro + t * rd;\n        float h = map(pos);\n        if(h < EPS || t > tmax ){\n            break;\n        }\n        t += h;\n    }\n    vec3 col = vec3(rd.y * 2.0, 0.6, 1.0); // background\n    if(t < tmax) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        float dif = clamp(dot(nor, vec3(0.57703)), 0.0, 1.0);\n        float amb = 0.5 + 0.5 * dot(nor, vec3(0.0, 1.0, 0.0));\n        col = vec3(0.2, 0.3, 0.4) * amb + vec3(0.85, 0.75, 0.65) * dif;\n    }\n\tfragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Source: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n// Source: https://www.shadertoy.com/view/XdGfRR\nfloat hash13(vec3 p){\n\tuvec3 q = uvec3(ivec3(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\n\tuint n = (q.x ^ q.y ^ q.z) * 1597334673U;\n\treturn float(n) * 2.328306437080797e-10;\n}\n// Source: https://www.shadertoy.com/view/fsGcW3\nmat3 eulerRotation(vec3 rot){\n\t// Rotation: X - pitch, Y - yaw, Z - roll  -> Rz * Ry * Rx\n\tfloat cx = cos(rot.x);\n\tfloat sx = sin(rot.x);\n\tfloat cy = cos(rot.y);\n\tfloat sy = sin(rot.y);\n\tfloat cz = cos(rot.z);\n\tfloat sz = sin(rot.z);\n\tmat3 RzRyRx = mat3(\n\t\tvec3(  cy * cz,\t\t\t-cy * sz,\t\t\t sy\t ),\n\t\tvec3(  sx * sy * cz + cx * sz,\t-cy * sz + cx * cz,\t\t-sx * cy ),\n\t\tvec3( -cx *sy * cz + sx * sz,\t cx * sy * sz + sx * cz,\t cx * cy )\n\t);\n\treturn RzRyRx;\n}\n// Basic\nvoid rotate(inout vec2 q, in float deg){\n    float rad = radians(deg);\n    q = mat2x2(cos(rad),sin(rad),-sin(rad),cos(rad)) * q;\n}\n// Mine\nvoid applyRange(inout float v, in vec2 r, in vec3 id){\n    v = r.x + hash13(id * 13371.931 + 130223.82) * (r.y - r.x);\n}\nvoid applyRange(inout vec3 v, in mat2x3 r, in vec3 id){\n    v = r[0] + hash13(id * 13371.931 + 130223.82) * (r[1] - r[0]);\n}\n","name":"Common","description":"","type":"common"}]}