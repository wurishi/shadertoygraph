{"ver":"0.1","info":{"id":"XtKSWc","date":"1486240425","viewed":1168,"name":"Geodesic tiling (abs position)","username":"tdhooper","description":"Version of [url]https://www.shadertoy.com/view/llGXWc[/url] with full absolute positions.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["sphere","hexagon","tile","minimal","geodesic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tGeodesic tiling, with absolute positions\n\t----------------------------------------\n\n\tSimilar to https://www.shadertoy.com/view/llGXWc\n\texcept with the full absolute position of each\n    point.\n\n*/\n\n\n#define HEX_TILE\n\n\n// --------------------------------------------------------\n// Icosahedron faces and vertices\n// --------------------------------------------------------\n\n#define PHI (1.618033988749895)\n\n// Return a or b, depending if p is in front of,\n// or behind the plane normal\nvec3 splitPlane(vec3 a, vec3 b, vec3 p, vec3 plane) {\n    float split = max(sign(dot(p, plane)), 0.);\n    return mix(a, b, split);\n}\n\n// An icosahedron vertex for the nearest face,\n// a bit like finding the nearest icosahedron vertex,\n// except we only need one per face\nvec3 icosahedronVertex(vec3 p) {\n    vec3 sp, v1, v2, result, plane;\n    sp = sign(p);\n    v1 = vec3(PHI, 1, 0) * sp;\n    v2 = vec3(1, 0, PHI) * sp;\n    plane = vec3(1, PHI, -PHI - 1.) * sp;\n    result = splitPlane(v2, v1, p, plane);\n    return normalize(result);\n}\n\n// Nearest dodecahedron vertex (nearest icosahrdron face)\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 sp, v1, v2, v3, v4, result, plane;\n    sp = sign(p);\n    v1 = sp;\n\tv2 = vec3(0, 1, PHI + 1.) * sp;\n\tv3 = vec3(1, PHI + 1., 0) * sp;\n    v4 = vec3(PHI + 1., 0, 1) * sp;\n    plane = vec3(-1. - PHI, -1, PHI);\n    result = splitPlane(v1, v2, p, plane * sp);\n    result = splitPlane(result, v3, p, plane.yzx * sp);\n    result = splitPlane(result, v4, p, plane.zxy * sp);\n    return normalize(result);\n}\n\n\n// --------------------------------------------------------\n// Triangle tiling\n// Adapted from mattz https://www.shadertoy.com/view/4d2GzV\n//\n// Finds the closest triangle center on a 2D plane \n// --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2tri = mat2(1, 0, i3, 2. * i3);\nconst mat2 tri2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\nvec2 pick3(vec2 a, vec2 b, vec2 c, float u) {\n\tfloat v = fract(u * 0.3333333333333);\n\treturn mix(mix(a, b, step(0.3, v)), c, step(0.6, v));\n}\n\nvec2 closestHex(vec2 p) {\n    p = cart2tri * p;\n\tvec2 pi = floor(p);\n\tvec2 pf = fract(p);\n\tvec2 nn = pick3(\n        vec2(0, 0),\n        vec2(1, 1),\n        vec2(1, 0),\n        pi.x + pi.y\n    );\n\tvec2 hex = mix(nn.xy, nn.yx, step(pf.x, pf.y)) + pi;\n    hex = tri2cart * hex;\n    return hex;\n}\n\nvec2 closestTri(vec2 p) {\n    p = cart2tri * p;\n    vec2 pf = fract(p);\n    vec2 v = vec2(1./3., 2./3.);\n    vec2 tri = mix(v, v.yx, step(pf.y, pf.x));\n    tri += floor(p);\n    tri = tri2cart * tri;\n    return tri;\n}\n\n\n// --------------------------------------------------------\n// Geodesic tiling\n//\n// Finds the closest triangle center on the surface of a\n// sphere:\n// \n// 1. Intersect position with the face plane\n// 2. Convert that into 2D uv coordinates\n// 3. Find the closest triangle center (tile the plane)\n// 4. Convert back into 3D coordinates\n// 5. Project onto a unit sphere (normalize)\n//\n// You can use any tiling method, such as one that returns\n// hex centers or adjacent cells, so you can create more\n// interesting geometry later.\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec3 facePlane = vec3(0);\nvec3 uPlane = vec3(0);\nvec3 vPlane = vec3(0);\n\n// Intersection point of vector and plane\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal) + planeOffset) / -denominator;\n    return n * t;\n}\n\n// 3D position -> 2D (uv) coordinates on the icosahedron face\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 i = intersection(normalize(p), facePlane, -1.);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\n// 2D (uv) coordinates -> 3D point on a unit sphere\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\n// Edge length of an icosahedron with an inscribed sphere of radius of 1\nconst float edgeLength = 1. / ((sqrt(3.) / 12.) * (3. + sqrt(5.)));\n// Inner radius of the icosahedron's face\nconst float faceRadius = (1./6.) * sqrt(3.) * edgeLength;\n\n// Closest geodesic point (triangle center) on unit sphere's surface\nvec3 geodesicTri(vec3 p, float subdivisions) {\n    \n    vec3 dv = dodecahedronVertex(p);\n    vec3 iv = icosahedronVertex(p);\n    \n    facePlane = dv;\n    vPlane = normalize(cross(iv, dv));\n    uPlane = normalize(cross(vPlane, dv));\n    \n    // faceRadius is used as a scale multiplier so that our triangles\n    // always stop at the edge of the face\n\tfloat uvScale = subdivisions / faceRadius;\n\n    vec2 uv = icosahedronFaceCoordinates(p);\n    \n    #ifdef HEX_TILE\n        uvScale /= 1.3333;\n        vec2 closest = closestHex(uv * uvScale);\n    #else\n        uvScale /= 2.;\n        vec2 closest = closestTri(uv * uvScale);\n    #endif\n    \n    return faceToSphere(closest / uvScale);\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 color;\n};\n\nvoid spin(inout vec3 p) {\n    float r = iTime / 6.;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n   \tp.xz *= rot;\n    p.zy *= rot;\n}\n\n// Smooth transition between subdivisions\nfloat animSubdivitions(float start, float end) {\n    \n    float t = mod(iTime, 2.) - 1. + .5;\n    t = clamp(t, 0., 1.);\n    t = cos(t * PI + PI) * .5 + .5;\n    \n    float n = floor(iTime / 2.);\n\n    float diff = end - start;\n    n = mod(n, diff + 1.);\n\n    if (n == diff) {\n    \treturn end - diff * t;\n    }\n\n    return n + start + t;\n} \n\n// The actual model\nModel map(vec3 p) {\n    \n    // Spin the whole model\n    spin(p);\n    \n\tfloat subdivisions = animSubdivitions(1., 10.);\n\tvec3 point = geodesicTri(p, subdivisions);\n\n\tfloat sphere = length(p - point) - .195 / subdivisions; \n    \n    // Indicate point's position\n    vec3 color = point * .5 + .5;\n\n\treturn Model(sphere, color);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 8.;\nconst float INTERSECTION_PRECISION = .001;\nconst int NUM_OF_TRACE_STEPS = 100;\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 render(Hit hit){\n    if (hit.isBackground) {\n        return vec3(0);\n    }\n    vec3 color = hit.model.color;\n    color += sin(dot(hit.normal, vec3(0,1,0))) * .2; // lighting\n    color *= 1. - clamp(hit.ray.len * .4 - .8, 0., 1.); // fog\n    return color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 camPos = vec3(0, 0, 2.5);\n    vec3 camTar = vec3(0);\n    float camRoll = 0.;\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camRoll);\n    \n    vec3 rd = normalize(camMat * vec3(p.xy, 2.));\n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}