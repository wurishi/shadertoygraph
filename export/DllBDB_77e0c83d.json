{"ver":"0.1","info":{"id":"DllBDB","date":"1693433424","viewed":99,"name":"First Raymarcher & Phong Shading","username":"kastanileel","description":"Hey there ^^! I crafted my first raymarching scene. \n\nGot a soft spot for the way SDFs intersect!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","phong","sdf","sphere","phongshading","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfPlane( vec3 p, vec4 n ){\n\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdfSphere(vec3 p, vec3 center, float radius){\n\n    return length(p - center) - radius;\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette( in float t)\n{\n    vec3 a = vec3(.9f, .5f, .5f);\n    vec3 b = vec3(.5f, .5f, .5f);\n    vec3 c = vec3(2.0f, .5f, .7f);\n    vec3 d = vec3(.5f, .2f, 1.0f);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\n\nfloat sdfAll(vec3 p){\n\n    float displacement = sin(5.0 * p.x + iTime) * sin(5.0 * p.y + iTime) * sin(5.0 * p.z +iTime) * .35;\n\n    float sdf1 = sdfSphere(p, vec3(.5, 0, 0), .65) + displacement;\n\n    vec3 center = vec3(sin(iTime - 3.1415/2.) * .7 -.2 , 0, 0.);\n    float sdf2 = sdfSphere(p, center, .7);\n    \n    float interpolated = smin(sdf1, sdf2, 0.1);\n    \n    float sdf3 = sdfPlane(p, normalize(vec4(0., 1. , 0., 1.8))) + displacement/30.;\n\n\n    return min(interpolated, sdf3);\n}\n\nvec3 getNormal(vec3 p){\n\n    vec3 offset = vec3(0.001, 0., 0.);\n    \n    float gradientX = sdfAll(p + offset.xyy) - sdfAll(p - offset.xyy);\n    float gradientY = sdfAll(p + offset.yxy) - sdfAll(p - offset.yxy);\n    float gradientZ = sdfAll(p + offset.yyx) - sdfAll(p - offset.yyx);\n    \n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.* fragCoord/iResolution.xy -1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //origin of rays\n    const vec3 ro = vec3(0., 1., 5.);\n    //normalized direction of rays\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    \n    //light ray\n    vec3 lightRay = normalize(vec3(sin(iTime*2.)*0.5,1.5,1.));\n    \n    vec3 currentRayPos;\n    float totalMarchedDist = 0.;\n    \n    vec3 color = vec3(0);\n    vec3 fog = vec3(0);\n\n    for(int i = 0; i < 200; i ++)\n    {\n        //march along ray\n        currentRayPos = ro + totalMarchedDist * rd;\n        \n        //smallest distance to closest object\n        float distToSDF = sdfAll(currentRayPos);\n        //=> distance aided raymarching\n        totalMarchedDist += distToSDF;\n        \n        \n        if(distToSDF < 0.001){  \n            \n            vec3 normal = getNormal(currentRayPos);\n        \n            //calculate diffuse shading\n            float diffuseLight =  0.6 * dot(normal, lightRay);\n            \n            //calculate specular shading\n            float specularLight = dot(reflect(lightRay,normal), normalize(currentRayPos - ro));\n            specularLight = pow(specularLight, 9.);\n            \n            //filter light values outside [0.0, 1.0]\n            specularLight = max(0.0, specularLight);\n            diffuseLight = max(0.0, diffuseLight);\n            \n            float ambientLight = 0.2;\n        \n            float light =  min(diffuseLight+specularLight, 1.) + 0.2;\n            \n            color = palette(iTime/5. +  length(currentRayPos + iTime/4.));\n            color *= (light );\n        \n            break;\n        }\n        \n        \n        float fogFactor = pow(length(currentRayPos - ro), 2.) / 800.;\n        fog = vec3(fogFactor, fogFactor, fogFactor);\n    }\n    \n    // apply fog\n    color -= fog;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}