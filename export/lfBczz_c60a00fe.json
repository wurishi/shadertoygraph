{"ver":"0.1","info":{"id":"lfBczz","date":"1721843670","viewed":459,"name":"Playstation","username":"kishimisu","description":"A tribute to my very first console","likes":48,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","gi","global","illumination","logo","pathtracing","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Playstation by @kishimisu\n   \n   A path-traced rendering of the Playstation logo using 4 light bounces\n   \n   Released in Japan in 1994, rendered using the same number of characters.\n*/\n\nvoid mainImage(out vec4 O, vec2 F) \n{\n    O = texture(iChannel0, F/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define RENDER_QUALITY 1 // Render iterations per frame (increase to reduce noise)\n\n// fract noise - https://www.shadertoy.com/view/4djSRW\nvec2 hash(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .103, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// SDFs - https://iquilezles.org/articles/distfunctions2d/\nfloat rbox(vec2 p, vec2 b, vec4 r) {\n    r.xy = (p.x>0.) ? r.xy : r.zw;\n    r.x  = (p.y>0.) ? r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.) + length(max(q,0.)) - r.x;\n}\nfloat seg(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    return -length(pa-ba*(clamp(dot(pa,ba)/dot(ba,ba),0.,1.)));\n}\n\n// hemisphere sampling\nvec3 hemi(vec2 s, vec3 n) {\n    vec3 t = vec3(1.+n.z-n.xy*n.xy, -n.x*n.y) / (1.+n.z);\n    return sqrt(1.-s.x) * n + sqrt(s.x) *\n           (cos(6.*s.y) * vec3(t.xz,-n.x) + \n            sin(6.*s.y) * vec3(t.zy,-n.y) );\n}\n\n// scene distance\nfloat map(vec3 p) {\n    vec2 pp = p.xy - vec2(.43, 0),\n         ps = p.zx * vec2(1,-1) - vec2(0,.75);\n    \n    // \"P\" shape\n    float P =  rbox(pp,  vec2(.3, 1),  vec4(0));\n    P = min(P, rbox(pp - vec2(.4,.45), vec2(.55), vec4(.4, .4, 0, 0)));\n    P = max(P,  seg(pp,  vec2(.3, -2), vec2(.3,.6)) + .1);   \n    P = max(P,  abs(p.z+1.15) - .02);\n\n    // \"S\" shape\n    if (ps.x > ps.y*2.3 + .8) {\n        ps.x *= sign(ps.y);\n        ps.y  =  abs(ps.y) - .74;\n    }\n    float S = rbox(ps, vec2(1.1, .6), vec4(0, 0, .6, .6));\n    S = max(S, seg(ps, vec2(-.5, 0),  vec2(5, 0)) + .1);\n    S = max(S, abs(++p.y)-.02);\n    \n    // Combine shapes\n    return min(min(min(min(P, S), p.x+1.5), p.y+.3), 1.4-p.z);\n}\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2 R = iResolution.xy,\n         e = vec2(1,-1)*1e-4,      // epsilon for normal calculation\n         h = hash(vec3(F, iTime)), // random hash\n         o = F + h - .5,\n         u = (o+o-R)/R.y; // clip-space UVs\n    \n    vec4 acc = vec4(0); // Final accumulated color\n    \n    for (int i = 0; i < RENDER_QUALITY; i++) \n    {\n        // Setup orthographic camera\n        vec3 ro = vec3(2., 1.15, -3),\n             rd = normalize(-ro), \n             r  = cross(vec3(0,1,0), rd) * 1.4, p;\n\n        ro += u.x*r + u.y*cross(rd, r) - vec3(.2,.4,0);\n\n        // Setup path-tracing\n        vec4 bcol = vec4(0),\n             mask = vec4(1);\n\n        for (int b = 0; b < 4; b++) { // 4 bounces\n            // Raymarching\n            float d, t = 0.;\n            for (int j = 0; j < 40; j++) {\n                p = ro + t * rd;\n                t += d = map(p);\n                if (d < .002) break;\n            }\n            if (t > 7.) break;\n            p -= rd*.01;\n\n            // Compute normal\n            vec3 n = normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + \n                               e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n            // Colorize\n            vec4 col = vec4(1,.9,.9,.04);\n\n            if (abs(p.x) < 1.4 && abs(p.y) < 1.1 && abs(p.z) < 1.2) {\n                if (p.z < -1.11)     col = vec4(1,0,.1, 1);\n                else if (p.z < -.35) col = vec4(1,.8,0, 1);\n                else if (p.z < .4)   col = vec4(0,.7,.6,1);\n                else                 col = vec4(0,.4,.7,1);\n            }\n\n            mask *= col;\n            bcol += mask * col.a * max(1. - abs(n.x)*.5, 0.);\n\n            // Bounce direction\n            h = hash(vec3(h*9., b));\n            ro = p;\n            rd = hemi(h, n*.999);\n        }\n\n        acc += bcol / float(RENDER_QUALITY); \n    }\n            \n    O = mix(texture(iChannel0, F/R), acc, .01);\n}","name":"Buffer A","description":"","type":"buffer"}]}