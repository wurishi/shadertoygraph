{"ver":"0.1","info":{"id":"stVXRz","date":"1640174404","viewed":95,"name":"Retro Cityscape","username":"MulattoKid","description":"Trying to implement https://youtu.be/lVYksrvNe28","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["retro","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define     PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat half_circle_fill(vec2 xy, vec2 center, float radius)\n{\n    float x = xy.x;\n    float y = xy.y;\n\n    // Circle equation: r^2 = (x-center.x)^2 + (y-center.y)^2\n    x -= center.x;\n    y -= center.y;\n    float r = sqrt((x * x) + (y * y));\n    \n    // Check if r is below half of screen\n    float y_above_zero = step(0.0, y);\n    float r_within_radius = 1.0 - step(radius, r);\n    return min(y_above_zero, r_within_radius);\n}\n\nvec2 sine_wave(vec2 xy)\n{\n    float x = xy.x;\n    float y = xy.y;\n\n    // Sine wave\n    float amplitude = 0.5;\n    float frequency = 4.0;\n    float y_offset = 0.0;\n    x *= frequency;\n    x += iTime;\n    \n    // Roof lines\n    float roof_sine = y_offset + (amplitude * sin(floor(x) * 4321.0));\n    float dist_y_from_pixel_to_roof_sine = abs(y - roof_sine);\n    float roof = 1.0 - step(0.0065, dist_y_from_pixel_to_roof_sine);\n    \n    // Outline: is 1.0 if pixel is outline\n    float x_about_to_change_sign = fract(abs(x));\n    float draw_line_x_changing_sign = 1.0 - step(0.04, x_about_to_change_sign);\n    float previous_roof_sine = y_offset + (amplitude * sin(floor(x - 1.0) * 4321.0));\n    // If y is between previous roof and this roof\n    float this_roof_sine_is_below_previous_roof_sine = min(step(roof_sine, y), 1.0 - step(previous_roof_sine, y));\n    float this_roof_sine_is_above_previous_roof_sine = min(1.0 - step(roof_sine, y), step(previous_roof_sine, y));\n    float outline = max(roof, draw_line_x_changing_sign * max(this_roof_sine_is_below_previous_roof_sine, this_roof_sine_is_above_previous_roof_sine));\n    \n    // Fill: is 1.0 if pixel is filled\n    float fill = 1.0 - step(roof_sine, y);\n    \n    return vec2(outline, fill);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Move UV from [0,1] to [-1,1]\n    vec2 xy = (uv * 2.0) - 1.0;\n    \n    // Correct for aspect ratio\n    float aspect_ratio = iResolution.x / iResolution.y;\n    xy.x *= aspect_ratio;\n\n    // Background ocean\n    float ocean_visible = 1.0 - step(0.501, uv.y); // Ocean goes from uv.y=[0,0.5]\n    float ocean_y = uv.y * 2.0;\n    vec3 ocean_color = mix(vec3(0.1, 0.1, 0.7), vec3(0.9, 0.3, 0.9), ocean_y);\n    vec3 color = ocean_color * ocean_visible;\n    \n    // Background sky\n    float sky_visible = step(0.501, uv.y); // Sky goes from uv.y=(0.5,1.0]\n    float sky_y = (uv.y * 2.0) - 1.0;\n    vec3 sky_color = mix(vec3(0.8, 0.3, 0.5), vec3(0.95, 0.5, 0.1), sky_y);\n    color = (color * (1.0 - sky_visible)) + (sky_color * sky_visible);\n    \n    // Sun\n    float sun_visible = half_circle_fill(xy, vec2(0.0, 0.0), 0.8);\n    vec3 sun_color = mix(vec3(0.7, 0.5, 0.1), vec3(0.9, 0.9, 0.1), uv.y);\n    color = (color * (1.0 - sun_visible)) + (sun_color * sun_visible);\n    \n    // City\n    vec2 city_visible = sine_wave(xy);\n    // Fill\n    vec3 city_fill_color = vec3(0.0);\n    color = (color * (1.0 - city_visible.y)) + (city_fill_color * city_visible.y);\n    // Outline\n    vec3 city_outline_color = vec3(1.0);\n    color = (color * (1.0 - city_visible.x)) + (city_outline_color * city_visible.x);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}