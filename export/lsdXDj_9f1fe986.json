{"ver":"0.1","info":{"id":"lsdXDj","date":"1461651199","viewed":356,"name":"Crater Nation","username":"Passion","description":"Using the bumpmap, 3d texturing, and greyscale fuctions from Shane's 'Abstract Corridor' and magicBox function from dgreensp's 'Magic Fractal'","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","raymarch","bumpmap","magicbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 32\n#define EPS .001\n\nconst int MAGIC_BOX_ITERS = 16;\nconst float MAGIC_BOX_MAGIC = 0.65;\n\n//https://www.shadertoy.com/view/4ljGDd - dgreensp\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n// Rotation\nmat2 rot2D(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a),  cos(a));       \n}\n\n// Sphere or moon in this case\nfloat map(vec3 p){\n    return length(p) - 1.; //min(s, s2);\n}\n\n// Raymarching\nfloat trace(vec3 o, vec3 r, inout vec3 hitPos){\n    float hit = 0.0;\n    for(int i = 0; i<MAX_STEPS; i++){\n        vec3 p = o + r * hit;\n        float dist = map(p);\n        if(dist < EPS) break;\n        hit += dist * 0.5;\n    }\n    hitPos = o + hit*r;\n    \n    return hit;\n}\n\n// Normal mapping\nvec3 getNormal( in vec3 p ){\n\n    vec2 e = vec2(0.5773,-0.5773)*EPS;   //0.001;\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + \n                      e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n\n// Specular highlights from an article I was looking at\n// https://machinesdontcare.wordpress.com/2008/10/29/subsurface-scatter-shader/\nfloat blinnPhongSpe(vec3 norm, vec3 dLight, float shine){\n    vec3 halfVecAngle = normalize(vec3(norm + dLight));\n    return pow(clamp(dot(norm, halfVecAngle), 0.0, 1.0), shine);\n}\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Directional Light\n    vec3 dLight = normalize(vec3(0.25, 0.8, 0.5));\n    \n    // Adjust and set up uv Coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Initializing fragColor\n    fragColor = vec4(0.0);\n    \n    // Rotate Light a bit\n    dLight.xz *= rot2D(iTime*.5);\n    dLight.xy *= rot2D(iTime);\n    \n    // Create the ray with a bit of wide angle/fish eye lens effect\n    vec3 r = normalize(vec3(uv, 1.0- dot(uv,uv) * 0.333)); // \n    \n    // Camera origin\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    \n    // Rotate the ray and camera a look at function may be better...\n    r.xz*=rot2D(iTime/2.-iMouse.x/50.);\n    o.xz*=rot2D(iTime/2.-iMouse.x/50.);\n    \n    r.zy*=rot2D(iTime/3.);\n    o.zy*=rot2D(iTime/3.);\n    \n    // Hit position for normal mapping\n    vec3 hitPos = vec3(0.0);\n    float t = trace(o, r, hitPos);\n    \n    // Sphere or background for\n    float sphOrBg = map(o + r*t);\n    \n    // Get the normal\n    vec3 norm = getNormal(hitPos);\n    // Reset the normal using the bump map function\n    norm = doBumpMap(iChannel0, hitPos*(1.0/3.0), norm, 0.025);\n    \n    // Diffuse\n    float diff = clamp(dot(norm, dLight), 0.015, 1.0);\n    // Specular\n    float spec = blinnPhongSpe(norm, dLight, 180.);\n    \n    vec4 bg = vec4(0.0); //vec4(.69, .79, 1.0 , 1.0);\n    //bg *= dot(dLight, r)*.5 + .5;\n    vec3 p = 0.26*M*r;\n    vec3 p2 = 0.24*M*r;\n    \n    float mb = magicBox(p2+iTime*.015);\n    mb *= .025;\n    // level of detail.\n    //vec3(uv*3., 0.0);\n    \n    float result = magicBox(p+iTime*.01);\n    // Scale to taste.  Also consider non-linear mappings.\n    result *= 0.018;\n    // Background color\n    bg = vec4(result*result*mb,result*result*result*mb,result*result*result*result*mb,1.0);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    if(abs(sphOrBg) < 0.5){\n        // mixing for fog not nessecary here...\n        fragColor = vec4(diff+spec); //mix(vec4(vec3(diff+spec), 1.0), bg, smoothstep(.2, .4, t*.03));\n    }else\n        fragColor = bg;\n}","name":"Image","description":"","type":"image"}]}