{"ver":"0.1","info":{"id":"fsK3z3","date":"1631882723","viewed":263,"name":"Path Arc 1 SDF","username":"TheTurk","description":"Distance function for an arc that can be used as a building block to create complex shapes like [url]https://www.shadertoy.com/view/DdjyDW[/url]\nOther path distance functions:\n[url]https://www.shadertoy.com/playlist/scBBRD[/url]","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","distance","path","arc","shape","rounded","corner","primitive","odd","corners","even"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nconstructs an arc given 3 points of two intersecting lines, which will \nbe tangent to the arc. the end point of the arc is set to currentPoint \nso that it can be used to continue the contour. the sign of the \ndistance field is computed using the even-odd rule and determines \nwhether a point lies inside (negative sign) or outside (positive \nsign) a given shape.\n*/\n\nfloat arc(vec2 position, inout vec2 currentPoint, vec2 tangent1End, vec2 tangent2End, float radius) {    \n    vec2 p = position - tangent1End;\n    vec2 a = normalize(currentPoint - tangent1End);\n    vec2 b = normalize(tangent2End - tangent1End);\n    vec2 center = (a + b) * radius / abs(a.x * b.y - a.y * b.x);\n    vec2 start = tangent1End + a * dot(center, a);\n    vec2 end = tangent1End + b * dot(center, b);\n    p -= center;\n    // even-odd rule\n    float s = 1.0;\n    float c = radius * radius - p.y * p.y;\n    if (c > 0.0) {\n        c = sqrt(c);\n        vec2 p1 = vec2(-c, p.y); \n        vec2 p2 = vec2(c, p.y);\n        float s1 = dot(p1, a);\n        float s2 = dot(p1, b);\n        float s3 = dot(p2, a);\n        float s4 = dot(p2, b);\n        if (p.x < p1.x && s1 < 0.0 && s2 < 0.0) {\n            s = -s;\n        }\n        if (p.x < p2.x && s4 < 0.0 && s3 < 0.0) {\n            s = -s;\n        }\n    } \n    vec2 e = start - currentPoint;\n    vec2 q = position - currentPoint;    \n    if ((q.y > 0.0) != (q.y > e.y)) {\n        if ((e.y * q.x < e.x * q.y) != (e.y < 0.0)) {\n            s = -s;\n        } \n    }\n    currentPoint = end;\n    float s1 = dot(p, a);\n    float s2 = dot(p, b);\n    if (s1 < 0.0 && s2 < 0.0) {\n        return abs(length(p) - radius) * s;\n    }\n    vec2 d1 = q - e * clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d2 = position - end;\n    return sqrt(min(dot(d1, d1), dot(d2, d2))) * s;\n}\n\nfloat line(vec2 position, inout vec2 currentPoint, vec2 end) {\n    vec2 p = position - currentPoint;\n    vec2 e = end - currentPoint;\n    float h = clamp(dot(p, e) / dot(e, e), 0.0, 1.0);\n    float d = length(p - e * h);\n    float s = 1.0;\n    // even-odd rule\n    if ((p.y > 0.0) != (p.y > e.y)) {\n        if ((e.y * p.x < e.x * p.y) != (e.y < 0.0)) {\n            s = -s;\n        } \n    }\n    currentPoint = end;\n    return d * s;\n}\n\n// example\nfloat hexagon(vec2 position, float radius, float cornerRadius) {\n    vec2 point1 = vec2(0.0, radius);\n    vec2 point2 = vec2(point1.x * 0.5 - point1.y * -sqrt(3.0) * 0.5, point1.x * -sqrt(3.0) * 0.5 + point1.y * 0.5);\n    float d = float(0xffffffffU);\n    float s = 1.0;\n    for (int i = 0; i < 7; i++) {\n        vec2 point3 = vec2(point2.x * 0.5 - point2.y * -sqrt(3.0) * 0.5, point2.x * -sqrt(3.0) * 0.5 + point2.y * 0.5);\n        float ds = arc(position, point1, point2, point3, cornerRadius);\n        if (i > 0) {\n            d = min(d, abs(ds));\n            s *= sign(ds);\n        }   \n        point2 = point3;\n    }\n    return d * s;\n}\n\nfloat segment(vec2 position, vec2 start, vec2 end) {\n    position = position - start;\n    end = end - start;\n    float t = min(max(dot(position, end) / dot(end, end), 0.0), 1.0);\n    return length(position - end * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 point1 = vec2(1.3, 0.9) * cos((iTime + 37.0) * 0.5 + vec2(0.0, 5.0));\n    vec2 point2 = vec2(1.3, 0.9) * cos((iTime + 37.0) * 0.6 + vec2(3.0, 4.0));\n    vec2 point3 = vec2(1.3, 0.9) * cos((iTime + 37.0) * 0.7 + vec2(2.0, 0.0));    \n    float a = length(point2 - point1);\n    float b = length(point3 - point2);\n    float c = length(point1 - point3);\n    float s = 0.5 * (a + b + c);\n    float radius = sqrt((s - a) * (s - b) * (s - c) / s);\n    vec2 currentPoint = point1;\n    float d = arc(position, currentPoint, point2, point3, radius);\n    \n    // d = hexagon(position, 0.5, 0.2); // example \n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d);\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.003) * iResolution.y));\n    float d1 = min(segment(position, point1, point2), segment(position, point2, point3)) - (1.0 / iResolution.y);\n    float d2 = length(position - point1) - (12.0 / iResolution.y);\n    float d3 = length(position - point2) - (12.0 / iResolution.y);\n    float d4 = length(position - point3) - (12.0 / iResolution.y);\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d1 * iResolution.y));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d2 * iResolution.y));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d3 * iResolution.y));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 3.0, d4 * iResolution.y));        \n    if (iMouse.z > 0.0) {\n        vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        vec2 currentPoint = point1;\n        float d = arc(mousePosition, currentPoint, point2, point3, radius);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 3.0, abs(length(position - mousePosition) - abs(d)) * iResolution.y - 1.0));\n    }\n    fragColor = vec4(color, 1.0);\n} ","name":"Image","description":"","type":"image"}]}