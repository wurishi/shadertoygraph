{"ver":"0.1","info":{"id":"3tdXWS","date":"1581625178","viewed":79,"name":"Slidable Julia Set","username":"enslow","description":"You can edit the values of a, b, and t to control what the fractal looks like","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int isInSet(vec2 uv);\n\n//define function\nint isInSet(vec2 uv)\n{\n    //define coordinate and initial value\n    vec2 z = vec2(uv.x,uv.y);\n    \n    \n    //Changing this c cooridnate changes the geometry of the fractal\n    \n\n    float a = 4.*iMouse.x/(iResolution.x)-2.;\n    float b = 4.*iMouse.y/(iResolution.y)-2.;\n    \n    vec2 c = vec2(a,b);\n\n    \n    \n    \n    //set for the amount of steps of iteration\n\n    int iter = 1000;\n    \n    \n    //determine if after 50 tries, if (a+bi)^2 > 2, is not in set.\n    int i;\n    for (i = 0; i < iter; i++)\n    {       \t\n        \n        //conditional statement that can break loop early\n        //normally you do not want to define this type of conditional inside a loop because\n        //it will run on every interation, but here it saves more memory than it uses.\n        if (sqrt(z.x*z.x + z.y*z.y)>2.0)\n        {\n            return i;\n        }\n        \n        \n        //basically multiplying complex numbers\n        float newx = 1.0*(z.x * z.x - z.y * z.y) + c.x;\n        float newy = 1.0*(z.y * z.x + z.x * z.y) + c.y;        \n        z.x = newx;\n        z.y = newy;        \n    }    \n\treturn -1;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float winsize = 3.0;\n    vec2 uv = winsize*fragCoord/iResolution.y;\n\n    uv.x -= 0.5*winsize+0.8;\n    uv.y -= 0.5*winsize;\n    \n\tint val = isInSet(uv);\n    \n    \n    if (val == -1)\n    {\n        vec3 color = vec3(0.0,0.0,0.0);\n        fragColor = vec4(color,1.0);\n    }\n    else\n    {\n\n        float intensity = 3.0*float(val)/50.0;\n        vec3 color;\n        color.rgb = vec3(1.0);\n        \n        float d = sqrt(pow(uv.x,2.0)+pow(uv.y,2.0));\n        \n        //These three lines determine the color based on the amount of iterations\n        color.r =  sin(intensity+0.00);\n        color.g =  sin(intensity+0.75);\n        color.b =  sin(intensity+1.57);\n        \n        fragColor = vec4(color,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}