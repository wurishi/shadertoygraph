{"ver":"0.1","info":{"id":"NtsGW7","date":"1622257075","viewed":108,"name":"crazy disco","username":"yunhai","description":"cleaned my code and write this for fun","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SS(a,b,t) smoothstep(a,b,t)\nconst int MAX_STEPS=70;\nconst float MAX_DIS=100.;\nconst float MIN_DIS=.01;\nvec4 s;//sphere\nfloat plane=-5.3;//plane height\nconst int LIGHT_NUM=3;\nconst int nid=0;//nothing id\nconst int pid=1;//plane id\nconst int sid=2;//sphere id\nmat2 rotMat;\nstruct Light\n{\n    vec3 pos;\n    vec3 col;\n};\nLight lig[3];//light pos \nvoid initEnv()\n{\n    lig[0].pos=vec3(0.,5.,0.);\n    lig[0].col=vec3(.5);\n    lig[1].pos=vec3(2.,8.,2.);\n    lig[1].col=vec3(0.,0.,1.);\n    lig[2].pos=vec3(-2.,8.,-2.);\n    lig[2].col=vec3(1.,.3,0.);\n    s=vec4(0.,1.,0.,2.);\n}\n#define DREMAP(type)\\\ntype remap(float a,float b,float x,float y,type t)\\\n{return (t-a)/(b-a)*(y-x)+x;}\\\ntype remapS(float x,float y,type t)\\\n{return remap(-1.,1.,x,y,t);}\nDREMAP(float)\nDREMAP(vec3)\n\n//----------------------Camera------------------------\nstruct Cam\n{\n    vec3 o;\n    vec3 lookat;\n    vec3 f,r,u;\n}cam;\n//----------------------------------------------------\n\n\n//----------------------RayMarch----------------------\nstruct Hit\n{\n    int id;\n    vec3 pos;\n    vec3 norm;\n};\nfloat getDist(vec3 pos)\n{\n    float sd=length(pos-s.xyz)-s.w;\n    vec3 pPos=pos;\n    pPos.xy=rotMat*pos.xy;\n    float pd=pPos.y-plane;\n    return min(sd,pd);\n}\nint getId(vec3 pos)\n{\n    float minDis=MAX_DIS;\n    int id;\n    float sd=length(pos-s.xyz)-s.w;\n    vec3 pPos=pos;\n    pPos.xy=rotMat*pos.xy;\n    float pd=pPos.y-plane;\n    if(pd<minDis)\n    {\n        minDis=pd;\n        id=pid;\n    }\n    if(sd<minDis)\n    {\n        minDis=sd;\n        id=sid;\n    }\n    if(minDis>2.*MIN_DIS)\n        id=0;\n    return id;\n}\nfloat rayMarch(vec3 ori,vec3 dir)\n{\n    dir=normalize(dir);\n    float eod=0.;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 curPos=ori+dir*eod;\n        float d=getDist(curPos);\n        eod+=d;\n        if(abs(d)<MIN_DIS||eod>MAX_DIS) break;\n    }\n    return eod;\n}\nvec3 getNormal(vec3 pos)\n{\n   vec2 e=vec2(.01,.00);\n   //getDist is the mapping D=f(x,y,z),\n   //so the following code finds its gradient by grad(f)=(dD/dx,dD/dy,dD/dz)\n   //the gradient point to the direction where the dist increases fastest\n   vec3 normal=getDist(pos)-\n   vec3(getDist(pos-e.xyy),\n       getDist(pos-e.yxy),\n       getDist(pos-e.yyx));\n   return normalize(normal);\n}\nvec3 getLight(Hit h)\n{\n    float ambient=.3;\n    //diffuse\n    vec3 diff=vec3(0.)+ambient;\n    for(int i=0;i<LIGHT_NUM;i++)\n    {\n        vec3 ld=normalize(lig[i].pos-h.pos);\n        float tdiff=clamp(dot(h.norm,ld),0.,1.);\n        \n        //shadow\n        h.pos+=h.norm*MIN_DIS*2.;//take out from attach point\n        if(rayMarch(h.pos,ld)<length(lig[i].pos-h.pos)-MIN_DIS*2.)\n        {\n            tdiff*=.1;\n        }\n        diff+=tdiff*lig[i].col;\n    }      \n    return min(diff,1.);\n}\nHit rayCast(vec3 ro,vec3 rd)\n{\n    Hit h;\n    float len=rayMarch(ro,rd);\n    if(len>MAX_DIS) len=MAX_DIS;\n    h.pos=ro+rd*len;\n    h.norm=getNormal(h.pos);\n    h.id=getId(h.pos);\n    return h;\n}\n//----------------------------------------------------\n\n\n//----------------------hexCoord----------------------\nfloat hexDist(vec2 p)\n{\n    p=abs(p);\n    float d=dot(p,normalize(vec2(1.,1.732)));\n    d=max(d,p.x);//p.x=dot(p,normalize(vec2(1.,0.)));\n    return d;\n}\nvec4 hexCoord(vec2 uv)\n{\n    vec2 r=vec2(1.,1.732)*2.;\n    vec2 auv=mod(uv,r)-.5*r;\n    vec2 buv=mod(uv-.5*r,r)-.5*r;\n    vec2 guv=length(auv)<length(buv)?auv:buv;\n    \n    vec2 id=round(uv-guv);\n    vec2 polar=vec2(hexDist(guv),atan(-guv.y,-guv.x)/6.2832+.5);\n    vec4 coord=vec4(polar.x,polar.y,id.x,id.y);\n    return coord;    \n}\n//----------------------------------------------------\nfloat hash21(vec2 p)\n{\n    p+=127368.;\n    uint a=uint(p.x);\n    uint b=uint(p.y)*817913u;\n    a*=89734129u;\n    a=(a<<10)^(a>>10)^a;\n    a*=(b<<5)^(b>>5);\n    a=(a<<3)^(a>>3)^a;\n    return float(a)/4294967296.0;\n}\n\nvec3 shade(Hit h)\n{\n    if(h.id==0)\n        return vec3(0.);\n    vec3 diff=getLight(h);\n    vec3 col;\n    if(h.id==pid)\n    {\n        float scale=3.;\n        vec4 hc=hexCoord(h.pos.xz/scale);\n        vec3 hcpos;\n        hcpos.xz=hc.zw*scale;\n        hcpos.y=plane;\n        float hcr=min(1.,length(s.xyz-hcpos)/10.);\n        col=vec3(step(hc.x,.98*hcr));\n        if(hcr<.98)\n            col*=vec3(.45,.75,1.);\n        float hcyt=hc.y+iTime+hash21(hc.zw)*6.28;\n        \n        col*=remapS(.5,.7,sin(vec3(hcyt,hcyt*2.,hcyt*4.)));\n\n    }\n    else if(h.id==sid)\n        col=vec3(.8,.8,0.);\n    return col*diff;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    \n    vec2 uv = (C-.5*iResolution.xy)/iResolution.y;\n    float t=iTime;\n    float a=3.1415*remapS(0.,.05,sin(t));\n    float rc=cos(a);\n    float rs=sin(a);\n    rotMat=mat2(rc,-rs,rs,rc);\n    initEnv();\n    \n    float camMovR=remapS(30.,50.,sin(t*.8));\n    float camMovH=remapS(8.,15.,sin(cos(t*.2)*10.));\n    vec3 ro=vec3(sin(t)*camMovR,camMovH,cos(t)*camMovR);\n    cam.o=ro;\n    cam.lookat=vec3(0);\n    cam.f=normalize(cam.lookat-ro);\n    cam.r=cross(vec3(0.,1.,0.),cam.f);\n    cam.u=cross(cam.f,cam.r);\n    vec3 rd=normalize(cam.r*uv.x+cam.u*uv.y+cam.f);\n            \n    //scene manage\n    lig[1].pos+=vec3(sin(t*2.),0,cos(t*3.))*30.;\n    lig[2].pos+=vec3(cos(t*4.),0,sin(t*2.))*30.;\n    s.y+=remapS(0.,3.,sin(sin(t)*15.));\n    s.xz+=vec2(sin(t*3.),cos(t*3.))*remapS(5.,20.,sin(t));\n    s.w*=(texture(iChannel0,vec2(100./iResolution.x,0)).x*20.+10.)/20.;\n    //rayMarch\n    Hit h=rayCast(cam.o,rd);  \n    \n    O.rgb=shade(h);\n}","name":"Image","description":"","type":"image"}]}