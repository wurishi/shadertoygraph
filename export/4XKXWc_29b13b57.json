{"ver":"0.1","info":{"id":"4XKXWc","date":"1720631003","viewed":71,"name":"Procedural Jupiter 2","username":"ArchaicVirus","description":"Attempt at procedurally texturing a more realistic Jupiter-like gas giant.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sdf","domain","space","planet","worley","warp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Texture is based on image @ https://i.natgeofe.com/k/7c7e4173-5ad3-4ef7-8252-354de21430db/jupiter_3x4.jpg\n//I tried to make it look exactly like the image, minus the great red spot and moons\n//Maybe add some more faded darker-blue swirls\n//Could possibly improve by squashing y, and stretching x\n\n//Credits\n//https://iquilezles.org/articles/warp/\n//https://iquilezles.org/articles/distfunctions/\n//https://iquilezles.org/articles/fbm/\n//Worley noise from VitaleMarco - https://www.shadertoy.com/view/fscSzr\n\nvec3 getPlanetTexture(vec3 p) {\n    vec3 norm = normalize(p);\n    vec3 colors[5] = vec3[5](\n        vec3(125.0 / 255.0, 56.0 / 255.0, 28.0 / 255.0),\n        vec3(200.0 / 255.0, 190.0 / 255.0, 220.0 / 255.0),\n        vec3(150.0 / 255.0, 140.0 / 255.0, 140.0 / 255.0),\n        vec3(237.0 / 255.0, 200.0 / 255.0, 190.0 / 255.0),\n        vec3(145.0 / 255.0, 59.0 / 255.0, 1.0 / 255.0));\n        \n    //Horizontal bands\n    float frequency = warp3(norm + vec3(-iTime * 0.1, 1.0, 1.0), -iTime) * 0.1 + (cos(-iTime) * 0.02) * 0.5;\n    float wave = sin(p.y - 0.75 * frequency * warp3(norm * 3.5, -iTime * 0.2)) * 1.65;\n    //Wave to band index\n    float bandIndex = floor((wave + 1.0) * 0.4 * 10.0);\n    float blendFactor = fract((wave + 1.0) * 0.4 * 10.0);\n    //Blend adjacent bands\n    vec3 lowerColor = colors[int(mod(bandIndex + 0.0, 5.0))];\n    vec3 upperColor = colors[int(mod(bandIndex + 1.0, 5.0))];\n    \n    vec3 noiseInput = vec3(-iTime * 1.1, 5.0, 1.0) + vec3(1.0, 10.0 * bandIndex, 1.0);\n    float noise = fBmWorleyNoise3D(p * noiseInput, vec3(0.2), vec3(0.0, 0.0, -iTime * 0.5), 8, 1.0, 0.5);\n    \n    vec3 warpedUv = p * warp3(p * 0.25, -iTime * 0.5 * noise);\n    \n    float finalNoise = fBmWorleyNoise3D(p * warpedUv, vec3(5.0, 5.0, 1.0), vec3(iTime * 0.1, -iTime * 0.15, 1.0), 8, 1.0, 0.5);\n    //Warp final band texture\n    vec3 baseColor = mix(lowerColor, upperColor, blendFactor);\n    vec3 finalColor = mix(baseColor, vec3(finalNoise * 0.75), 0.15 * finalNoise);\n    \n    return finalColor;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 eye = vec3(0.0, 1.0, 6.5);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    if (ROTATE_VIEW) {\n        float angle = iTime * 0.15;\n        eye = vec3(6.0 * cos(angle), 1.0 + (2.0 * (sin(angle) * 2.0)), 6.0 + (12.0 * sin(angle)));\n    }\n    mat4 viewToWorld = viewMatrix(eye, target, up);\n    vec2 quantizedFragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, quantizedFragCoord);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    vec3 p = eye + dist * worldDir;\n    vec3 rotatedP = rotateY(p, iTime * 0.1);\n    vec3 col;\n    float noiseValue;\n    vec3 lightPos;\n    if (ROTATE_LIGHT) {\n        float anglel = iTime * 0.2;\n        lightPos = vec3(6.0 * cos(anglel), 1.0 + (2.0 * (sin(anglel) * 2.0)), 6.0 + (12.0 * sin(anglel)));\n    } else {\n        lightPos = vec3(5.0, 15.0, 20.0);\n    }\n    vec3 lightIntensity = vec3(0.75);\n    vec3 lightDir = normalize(lightPos - rotatedP);\n    vec3 normal = estimateNormal(p) * 2.0;\n\n    //Planet texture\n    col = getPlanetTexture(rotatedP);\n\n    float diffuse = max(dot(normal, lightDir), 0.35);\n    vec3 color = col * diffuse * lightIntensity;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define DITHER_STRENGTH 0.1\n#define PIXEL_SIZE 0.5\n\n//toggle camera animation \n#define ROTATE_VIEW false\n\n//toggle light animation\n#define ROTATE_LIGHT false\n\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n#define RETURN_WORLEY m_dist;\n\nfloat hash(float n, float seed) {\n    return fract(sin(n + seed) * 53738.14534123);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n\n    return mix(\n        mix(hash(ip.x + ip.y * 57.0, seed), hash(ip.x + 1.0 + ip.y * 57.0, seed), u.x),\n        mix(hash(ip.x + (ip.y + 1.0) * 57.0, seed), hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0, seed), u.x),\n        u.y\n    );\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves, float seed) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency, seed) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat n3d(vec3 p, float amplitude, float frequency, float persistence, int octaves, float seed) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency, seed) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat n2d(vec2 p, float amplitude, float frequency, float persistence, int octaves, float seed) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency, seed) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return n;\n}\n\n\nfloat warp1(in vec2 p) {\n    float amplitude = 1.0;\n    float frequency = 2.0;\n    float persistence = 0.5;\n    int octaves = 8;\n    float seed = 0.123486;\n    return n2d(p, amplitude, frequency, persistence, octaves, seed);\n}\n\nfloat warp2(in vec2 p, float time) {\n    float amplitude = 1.0;\n    float frequency = 2.0;\n    float persistence = 0.5;\n    int octaves = 8;\n    float seed = 0.123486;\n    vec3 q = vec3(n3d(vec3(p.xy, -time*0.01) + vec3(1.0, 0.0, 2.2), amplitude, frequency, persistence, octaves, seed),\n                  n3d(vec3(p.xy, -time*0.01) + vec3(5.8, 4.9, 5.2), amplitude, frequency, persistence, octaves, seed),\n                  0.0);\n    return n3d(vec3(p.xy, 0.0) + (4.0 * q), amplitude, frequency, persistence, octaves, seed);\n}\n\nfloat warp3(in vec3 p, float time) {\n    float amplitude = 1.0;\n    float frequency = 2.0;\n    float persistence = 0.5;\n    int octaves = 8;\n    float seed = 0.123486;\n    vec3 q = vec3(n3d(p + vec3(1.0, 0.0, (time * 0.1)), amplitude, frequency, persistence, octaves, seed),\n                  n3d(p + vec3((-time * 0.1), 4.9, 5.2), amplitude, frequency, persistence, octaves, seed),\n                  0.0);\n    return n3d(p + (4.0 * q), amplitude, frequency, persistence, octaves, seed);\n}\n\nvec3 rbg(vec3 col) {\n    return col / 255.0;\n}\n\nvec3 rbg(int r, int g, int b) {\n    return vec3(float(r)/255.0, float(g)/255.0, float(b)/255.0);\n}\n\n\nvec3 rotateY(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\n//Start of VitaleMarco's \"Worley Noise Functions\"----------------------------------------/\n//https://www.shadertoy.com/view/fscSzr\nfloat rand3dTo1d(vec3 value, vec3 dotDir){\n    vec3 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec3 rand3dTo3d(vec3 value){\n    return vec3(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155)),\n        rand3dTo1d(value, vec3(73.156, 52.235, 09.151))\n    );\n}\n\nfloat rand2dTo1d(vec2 value, vec2 dotDir){\n    vec2 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec2 rand2dTo2d(vec2 value){\n    return vec2(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135))\n    );\n}\n\nfloat worleyNoise2D(vec2 uv, vec2 scale, vec2 offset){\n    //APPLY SCALE\n    uv *= scale;\n    \n    //APPLY OFFSET\n    uv += offset;\n\n    //TILE THE SPACE INTO CELLS\n    vec2 floor_uv = floor(uv);\n    vec2 fract_uv = fract(uv);\n\n    //INITIAL DISTANCE\n    float m_dist = 1.0;\n\n    //LOOP THROUGH ALL THE NEIGHBOUR CELLS\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            //GET THE NEIGHBOUR CELL IN THE GRID\n            vec2 neighbor = vec2(x, y);\n\n            //GET THE POSITION OF THE CURRENT CELL AND THE NEIGHBOUR\n            vec2 point = rand2dTo2d(floor_uv + neighbor);\n\n\t\t\t//GET THE VECTOR BETWEEN THE CELLS\n            vec2 diff = neighbor + point - fract_uv;\n\n            //CALCULATE THE DISTANCE BETWEEN THE NEIGHBOUR AND THE CURRENT POINT\n            float dist = length(diff);\n\n            //KEEP THE CLOSER DISTANCE\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    //RETURN THE MINIMUM DISTANCE\n    return RETURN_WORLEY\n}\n\nfloat worleyNoise3D(vec3 pos, vec3 scale, vec3 offset){\n    //APPLY SCALE\n    pos *= scale;\n    \n    //APPLY OFFSET\n    pos += offset;\n\n    //TILE THE SPACE INTO CELLS\n    vec3 floor_pos = floor(pos);\n    vec3 fract_pos = fract(pos);\n\n    //INITIAL DISTANCE\n    float m_dist = 1.0;\n\n    //LOOP THROUGH ALL THE NEIGHBOUR CELLS\n    for (int z = -1; z <= 1; z++) {\n        for (int y= -1; y <= 1; y++) {\n            for (int x= -1; x <= 1; x++) {\n                //GET THE NEIGHBOUR CELL IN THE GRID\n                vec3 neighbor = vec3(x, y, z);\n\n                //GET THE POSITION OF THE CURRENT CELL AND THE NEIGHBOUR\n                vec3 point = rand3dTo3d(floor_pos + neighbor);\n\n                //GET THE VECTOR BETWEEN THE CELLS\n                vec3 diff = neighbor + point - fract_pos;\n\n                //CALCULATE THE DISTANCE BETWEEN THE NEIGHBOUR AND THE CURRENT POINT\n                float dist = length(diff);\n\n                //KEEP THE CLOSER DISTANCE\n                m_dist = min(m_dist, dist);\n            }\n        }\n    }\n    //RETURN THE MINIMUM DISTANCE\n    return RETURN_WORLEY\n}\n\nfloat fBmWorleyNoise2D(vec2 uv, vec2 scale, vec2 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n    \n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * worleyNoise2D(uv, scale, offset);\n        uv*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nfloat fBmWorleyNoise3D(vec3 pos, vec3 scale, vec3 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n\n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * worleyNoise3D(pos, scale, offset);\n        pos*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n////End of VitaleMarco's \"Worley Noise Functions\"---------------------------------------/\n\nconst mat4 bayerMatrix = mat4(\n    0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n    12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,\n    3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n    15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0\n);\n\nvec3 applyDithering(vec3 color, vec2 uv) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    return color + threshold * DITHER_STRENGTH;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.25;\n}\n\nfloat ringSDF(vec3 p, float innerRadius, float outerRadius) {\n    vec2 d = vec2(length(p.xz) - outerRadius, abs(p.y) - 0.001);\n    float outer = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    vec2 innerD = vec2(innerRadius - length(p.xz), abs(p.y) - 0.001);\n    float inner = length(max(innerD, 0.0)) + min(max(innerD.x, innerD.y), 0.0);\n    return max(max(inner, -outer), outer);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sphereSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sphereSDF(vec3(p.x + EPSILON, p.y, p.z)) - sphereSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sphereSDF(vec3(p.x, p.y + EPSILON, p.z)) - sphereSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sphereSDF(vec3(p.x, p.y, p.z + EPSILON)) - sphereSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}","name":"Common","description":"","type":"common"}]}