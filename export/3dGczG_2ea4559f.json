{"ver":"0.1","info":{"id":"3dGczG","date":"1603070170","viewed":121,"name":"warped blast off","username":"trancor","description":"Warped ray marching with \"boolean\" cuts from the \"geo\".\nJust a test to learn geo sdf Ray Marching; based off of the Operators tutorial by Martijn Steinrucken; yt- \"Art Of Code\"\nTrying out some triplanar mapped marched geo too.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","triplanar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Diving into better ray marching methods after all these years\n// Started with a tutorial, but added in triplanar texturing and animated the heck out of it\n// modded by Kevin Edzenga\n// -- -- -- --\n// Based off of by Art Of Code - \"ShaderToy Tutorial - Ray Marching Operators 2\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This is the starting point for a YouTube tutorial:\n// https://youtu.be/Vmb7VGBVZJA\n\n\n#define MAX_STEPS 50\n#define MAX_DIST 12.\n#define SURF_DIST .25\n\n// Untouched from tutoial\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Used to be math for a cube\n// Now its just a mess of distance based warping\nfloat sdBox(vec3 p, vec3 s) {\n    p = min( (p)-s, (p)+s);\n\treturn length(p)+(p.x+p.y);\n}\n\n\n// Slice'n'Dice!\n// Duel plane cutting a botched up box with warped planes and distance in space\nfloat GetDist(vec3 p, vec3 ro) {\n\tfloat time = iTime*.3;\n    vec3 pd = p;\n    pd.x = abs(p.x) + tan(p.z*.2) * cos(-p.y*.3);\n    pd.y *= pd.x<0.0 ? -2.0 : 1.1;\n    pd.z = mix( pd.z, pd.x, sin(p.z)*.15-.1 );\n    \n    float scalar = sin( dot(normalize(ro-pd),pd)*.1) * (pd.x+pd.z)*.4;\n    pd.z = mix( -pd.z, pd.y+pd.x, abs(scalar) );\n\n   \n    vec2 tUv = vec2( sin(pd.x*.01+scalar*.1), cos(pd.z*.1+scalar*.01)) *.1+.5;\n    vec3 tex = texture(iChannel0, tUv ).rgb;\n\n    vec3 slicer = normalize( vec3(sin(time+pd.z-pd.x+1.2)*.50+.5, -0.71, cos(time+pd.z+pd.y)*.10+.2) );\n\tslicer -= texture(iChannel1, slicer.rg*.01).rgb;\n    float plane = dot(pd, slicer); // Dot Plane 1\n    \n    \n    slicer = vec3( sin(-time*1.5+pd.z+tex.g+5.1)*2.0, .90, cos(time+pd.y+tex.g)*2.0 );\n \n    float pa = dot( pd*vec3(1.27,.07,.95), slicer ); // Dot Plane 2\n    plane = plane*abs(pa); // Combine both cutting planes\n    \n    float box = sdBox(pd+vec3(.0,.15,.0), vec3(.7)); // Warped Box Math 1\n    \n    slicer = vec3( sin(-time*1.5+pd.x+tex.g), .0, cos(time+pd.y+tex.g)*2.0 );\n    float boxf = sdBox( pd*vec3(-1,1,-1)-vec3(0.0,.2,1.0), vec3(-slicer*0.5+.5) ); // Warped Box Math 2\n    box = box+abs(boxf)-0.10; // Combine both boxes\n    \n    float d = max( plane, box) * min(1.0,length(pd));\n    \n    return d;\n}\n\n// Minor tweeks\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dS=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p, ro);\n        dO += dO>MAX_DIST || dS<SURF_DIST ? 0.00 : dS;\n    }\n    \n    return vec4( ro + rd*dO,dO); // ##\n}\n\nvec3 GetNormal(vec3 p, vec3 ro, float dO) {\n\tfloat d = GetDist(p, ro);\n    vec2 e = vec2(.005, 0); // ##\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, ro),\n        GetDist(p-e.yxy, ro),\n        GetDist(p-e.yyx, ro));\n    \n    return normalize(n);\n}\n\n\n// Minor tweeks\nvec4 GetLight(vec3 p, vec3 n) {\n    vec3 lightPos = vec3(3.0, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    \n    float dif = dot(n, l)*.5+.5;\n\n    return vec4(n,dif); // #\n}\n\n// Untouched from tutoial\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, 3.4);\n    \n    float ds = length(uv)*.1+1.0;\n    vec3 rd = rayDir(uv, ro, vec3(0,-.37,0), ds);\n\n    vec4 d = RayMarch(ro, rd); // vec3(rayMarchEnd), float lastStepSize\n\tfloat bgMask = step(d.w,MAX_DIST);\n    \n    vec3 p = d.xyz;\n    \n    vec3 n = GetNormal(p, ro, d.w);\n\tfloat dotEdge = dot( p.xyz ,n.xyz)* bgMask ; // Edge fall off\n    vec4 dif = GetLight(p, n); // Lighting dir vector\n\n\t// Get some warping from surface bend direction to apply as an offset to the xyz texture reads\n\tvec3 texWarp=cross( normalize(ro-d.xyz), n.xyz )*dotEdge*.5+.5;\n\n\n\t// Triplanar, it ainy pretty, but it works ... sorta\n    vec3 tx = texture(iChannel0, p.yz*.1+texWarp.yz).rgb;\n    vec3 ty = texture(iChannel0, p.xz*.1+texWarp.xz).rgb;\n    vec3 tz = texture(iChannel0, p.xy*.1+texWarp.xy).rgb;\n    vec3 td = abs( vec3( dot(vec3(1,0,0),n), dot(vec3(0,1,0),n), dot(vec3(0,0,1),n) ) );\n\tvec3 tdInv = vec3( 1.0-td.x, 1.0-td.y, 1.0-td.z );\n\t// Scale by other axes prominance\n    vec3 tm = vec3(\n\t\t\ttd.x * (tdInv.y * tdInv.z),\n\t\t\ttd.y * (tdInv.x * tdInv.z),\n\t\t\ttd.z * (tdInv.x * tdInv.y));\n    vec3 tex = tx*tm.x + ty*tm.y + tz*tm.z; // Combine the triplanar colors\n\n    // Boost the color of the center mass\n\tvec3 tf = texture(iChannel2, uv*.1+d.zz*.1+texWarp.xy*.1).rgb;\n\n    float dscale = max(0.0,(d.w-3.0)*.02); // Boost green/blue bg colored bits\n\ttex += cross(vec3(.1,1,0), p.xyz)*(1.0+dotEdge*dscale);\n\tfloat bBrown=max(0.0, 1.0-max(0.0, d.w-2.5)); // Boost Brown;\n    tex += tf*(1.0+bBrown);\n\n    col = vec3(tex*dif.w* bgMask * (1.0-dotEdge*dscale) );\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}