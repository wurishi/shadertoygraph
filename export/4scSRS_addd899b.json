{"ver":"0.1","info":{"id":"4scSRS","date":"1459997397","viewed":121,"name":"3D_test","username":"DeMaCia","description":"test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttp://glslsandbox.com/e#26011.0\nhttp://www.it165.net/pro/html/201506/44235.html\nhttp://blog.csdn.net/baidu_26153715/article/details/47032201\n*/\n\n\n//////////////////////////////////////\n//////////////////////////////////////\nvec3 rotate_y(vec3 v, float angle)\n{\n    float ca = cos(angle); float sa = sin(angle);\n    return v*mat3(\n        ca, .0, -sa,\n        .0,1.0, .0,\n        sa, .0, ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n    float ca = cos(angle); float sa = sin(angle);\n    return v*mat3(\n        1.0, .0, .0,\n         .0, ca, -sa,\n         .0, sa, ca);\n}\n\nvec3 rotate_z(vec3 v,float angle)\n{\n    float ca = cos(angle),sa = sin(angle);\n    return v*mat3(\n        ca,-sa,0.,\n        sa, ca,0.,\n        0., 0.,1.\n    );\n}\n\n////////////////OBJ//////////////////////\n//////////////////////////////////////\n\nfloat sdSphere( vec3 p)\n{\n    float radius = .7;\n    return length(p)-radius;\n}\n\n\nfloat sdCylinder( vec3 p)\n{\n    float radius = .7;\n    float height = 2.;\n    \n    float rlen = length(p.xz)-radius;\n    float hlen = abs(p.y) - height*.5;\n    \n    return max(rlen,hlen);\n    \n}\n\nfloat sdBox( vec3 p)\n{\n    vec3 b = vec3(.6,.6,.6);\n    return length(max(abs(p)-b,0.0)) - 0.001;\n}\n\n\nfloat toSphere(in vec3 p)\n{\n    return length(pow(abs(p),vec3(.7,.68,.4)))-1.1;\n    //you can try this another DE vertion\n    //return length(pow(abs(p),vec3(.7,0.68,0.4))-vec3(.6,0.35,0.4))-1.;\n}\n\n\n\n//////////////////////////////////////\n//////////////////////////////////////\n\nfloat objMap(in vec3 pos)\n{\n    pos = rotate_z(pos,iTime*.5);\n    pos = rotate_y(pos,iTime*.5);\n    \n    \n\tfloat dBox = sdBox(pos);\n    float dSp = sdSphere(pos);\n    \n    float d = max(dBox,dSp);\n    \n\treturn d;\n}\n\n//////////////////////////////////////\n//////////////////////////////////////\n\nvec3 getNormal(in vec3 pos){\n\tvec2 offset = vec2(0.001,0);\n\tvec3 nDir = normalize(\n\t\tvec3(\n\t\t\tobjMap(pos+offset.xyy)-objMap(pos-offset.xyy),\n\t\t\tobjMap(pos+offset.yxy)-objMap(pos-offset.yxy),\n\t\t\tobjMap(pos+offset.yyx)-objMap(pos-offset.yyx)\n\t\t)\n\t);\n\treturn nDir;\n}\n\n\n\n\n\n\n\n//////////////render//////////////////\n//////////////////////////////////////\n\n// RaymarchingMaxDis\nconst float MaxDis = 6.;\n\nvoid norColRender(out vec4 fragCol,vec3 camPos,vec3 rd,float f)\n{\n\t\n    if (f < MaxDis) \n    {\n        vec3 nor = getNormal(camPos + rd*f);\n        fragCol = vec4(nor, 1.);\n\t}\n    else\n    {\n    \tfragCol = vec4(0.);\n    }\n}\n\nvoid sdColRender(out vec4 fragCol,vec3 camPos,vec3 rd,float f)\n{\n    \n\tif (f < MaxDis) \n    {\n        vec3 lightDir = camPos;\n    \tvec3 objCol = vec3(.5,.5,.8);\n        vec3 nor = getNormal(camPos + rd*f);\n        \n        float b = dot(nor, normalize(lightDir));\n        fragCol = vec4((b*objCol + pow(b, 16.))*(1. - f*.01), 1.);\n        \n\t}\n    else\n    {\n    \tfragCol = vec4(0.);\n    }\n\n}\n\nvoid reflectRender(out vec4 fragCol,vec3 camPos,vec3 rd,float f)\n{\n    \n\tif (f < MaxDis) \n    {\n        vec3 nor = getNormal(camPos + rd*f);\n        \n        \n        vec3 refNor = normalize(reflect(rd,nor));\n        vec3 refCol = texture(iChannel0,refNor).rgb;\n        fragCol = vec4(refCol,0.);\n\t}\n    else\n    {\n    \tfragCol = vec4(texture(iChannel0,rd).rgb,1.);\n    }\n\n}\n\n\n\nvoid fresnelRender(out vec4 fragCol,vec3 camPos,vec3 rd,float f)\n{\n    \n\tif (f < MaxDis) \n    {\n        vec3 nor = -getNormal(camPos + rd*f);\n        \n        \n        vec3 refNor = normalize(reflect(-rd,nor));\n        \n        vec3 refCol = texture(iChannel0,refNor).rgb;\n        \n        vec3 fra0 = normalize(refract(-rd,nor,0.4));\n        vec3 fra1 = normalize(refract(-rd,nor,0.6));\n        vec3 fra2 = normalize(refract(-rd,nor,0.8));\n        \n        vec3 fraCol;\n        fraCol.r = texture(iChannel0,fra0).r;\n        fraCol.g = texture(iChannel0,fra1).g;\n        fraCol.b = texture(iChannel0,fra2).b;\n        \n        float fresnel = pow(1.-max(0.,dot(rd,nor)),2.)*0.55+0.5;\n        \n        fragCol = vec4(mix(fraCol,refCol,fresnel),1.)*vec4(1.0,1.0,1.6,1.0);\n\t}\n    else\n    {\n    \tfragCol = vec4(texture(iChannel0,rd).rgb,1.);\n    }\n\n}\n\n\n//////////////////////////////////////\n//////////////////////////////////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 vPos = ( fragCoord.xy / iResolution.xy )*2. - 1.;\n\tvPos.x *= iResolution.x/iResolution.y;\n\n     \n    \n     \n    //camera set\n    vec3 sc = normalize(vec3(vPos,2.));\n    vec3 camPos = vec3(iMouse.xy *(3./iResolution.xy),3.);\n\tvec3 camTar = vec3(0.,0.,0.);\n\tvec3 camUp = vec3(0.,1.,0.);\n\tvec3 z = normalize(camTar - camPos);\n\tvec3 x = normalize(cross(z,camUp));\n\tvec3 y = normalize(cross(z,x));\n\tvec3 rd = mat3(x,y,z)*sc;\n    \n        \n    \n        \n     \n\t// Raymarching\n\tvec3 p;\n\tfloat f = .5,d = .0;\n\tfor(int i = 0; i < 32; i++) \n    {\n        f += d;\n        p = camPos + rd*f;\n        d = objMap(p);\n        if ((abs(d) < .005) || (f > MaxDis)) break;\n\t}\n  \t\n     \n     \n     //render\n     //norColRender(fragColor,camPos,rd,f);\n     //sdColRender(fragColor,camPos,rd,f);\n     //reflectRender(fragColor,camPos,rd,f);\n     fresnelRender(fragColor,camPos,rd,f);\n    \t\n\t\n}","name":"Image","description":"","type":"image"}]}