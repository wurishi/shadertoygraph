{"ver":"0.1","info":{"id":"MXjcD3","date":"1727829963","viewed":32,"name":"noisy rainbow warp","username":"Creatorbyte","description":"Just a test of some shader stuff I've been playing with lately","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fbm","colorful","warp","rainbow","noisy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nvec3 palette(float t) {\n    vec3 b = vec3(0.45);\n    vec3 c = vec3(0.35);\n    return b + c * cos(6.28318 * (t * vec3(1.0) + vec3(0.7, 0.39, 0.2)));\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat value_noise(vec2 p) {\n    vec2 cell = floor(p);\n    vec2 sub = p - cell;\n    vec2 cube = sub * sub * (3.0 - 2.0 * sub);\n    const vec2 off = vec2(0, 1);\n    return mix(\n        mix(hash12(cell + off.xx), hash12(cell + off.yx), cube.x),\n        mix(hash12(cell + off.xy), hash12(cell + off.yy), cube.x),\n        cube.y\n    );\n}\n\nfloat fbm(vec2 p) {\n    float total = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float max_value = 0.0;\n    int fbm_octaves = 16;\n    float fbm_persistence = 0.5;\n\n    for (int i = 0; i < fbm_octaves; i++) {\n        total += value_noise(p * frequency) * amplitude;\n        max_value += amplitude;\n        amplitude *= fbm_persistence;\n        frequency *= 2.0;\n    }\n\n    return total / max_value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 center = vec2(0.5, 0.45);\n    vec2 noise_uv = uv;\n\n    noise_uv.x += sin(noise_uv.y * 1.54 * PI + iTime) * cos(noise_uv.y * 1.31 * PI + iTime) * 0.1;\n    noise_uv.y += cos(noise_uv.x * 1.74 * PI + iTime) * -sin(noise_uv.y * 1.64 * PI + iTime) * 0.1;\n\n    float noise_scale = 11.392;\n    float value_noise_freq = 1.456;\n    float palette_mod_scale = 2.469;\n\n    float noise = fbm(noise_uv * noise_scale + iTime);\n    float distance = length(noise_uv - center) + noise * value_noise_freq;\n    float t = mod(distance * palette_mod_scale + iTime, 1.0);\n    vec3 color = palette(t);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}