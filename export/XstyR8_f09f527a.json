{"ver":"0.1","info":{"id":"XstyR8","date":"1517931339","viewed":122,"name":"kataki","username":"jmaire","description":"flower\n* mon premier shader\n* inspiration:katati de  gaz \"https://www.shadertoy.com/view/Xts3zf\"","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["jmaire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n/* katati\n* mon premier shader\n* inspiration:katati de  gaz \"https://www.shadertoy.com/view/Xts3zf\"\n* jacques maire le 05/01/2018\n*/\n#define PI  3.14159265359\n#define PI6  ( PI * 6.0 )\n\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nmat2 rotate(float a)\n{\n return mat2(cos(a), sin(a), -sin(a), cos(a));   \n}\n\n\nfloat map(in vec3 p)//RETOURNE LA DISTANCE DE p AUX OBJETS\n{     \n   p.xy *= rotate(PI * 0.5);\n    p.yz *= rotate(PI * 0.5);\n    float a = atan(p.z, p.x);\n   p.xz *= rotate(a);\n     \n    p.x -= 0.9;\n    p.xy *= rotate(a* (mod(iTime*0.2,PI*5.0) *cos(1.8*iTime)* sin(iTime * 0.5)));\n   p.x = abs(p.x) - 0.2;//DUPLICATION\n    p.x = abs(p.x) - 0.2;//DUPLICATION\n    p.x = abs(p.x) - 0.2;//DUPLICATION\n  return length(p.xy) - 0.14;//BOUDIN DE RAYON 0.14\n}\nvec3 doColor(in vec3 p)\n{  return clamp(p,0.0,1.0);}\n\nvec3 calcNormal(in vec3 p)\n{\n  const vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(\n    map(p + e.xyy) - map(p - e.xyy),\n    map(p + e.yxy) - map(p - e.yxy),\n    map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n  float res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n    float h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n  const float maxd = 50.0;\n  const float precis = 0.001;\n    float h = precis * 2.0;\n    float lambda = 0.0;\n  float res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || lambda > maxd) break;\n      h = map(ro + rd * lambda);\n        lambda += h;\n    }\n    if(lambda < maxd) res = lambda;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p2d = ( 2.0 * fragCoord.xy - iResolution.xy ) /iResolution.xy;\n  vec3 col = vec3(0.435,0.107,0.988)*((p2d.y+1.0) );//COULEUR DU FOND DEGRADE\n     vec3 rdir = normalize(vec3(p2d, -0.9));//DIRECTION DES RAYONS\n  vec3 posor = vec3(0.0,0.0, 1.8);//POSITION DU POINT DE VUE\n    vec3 li = normalize(vec3(10.,1.0, 5.0));// DIRECTION LUMIERE\nfloat tho= march(posor, rdir);\n    if(tho > -0.001)\n    {\n        vec3 p3d = posor + tho * rdir;\n        vec3 n = calcNormal(p3d);\n   \t float dif = clamp((dot(n, li) + 0.9) * 0.7, 0.2, 1.0);\n        col = doColor(p3d)* dif;\n    }\n     fragColor = vec4(col, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}]}