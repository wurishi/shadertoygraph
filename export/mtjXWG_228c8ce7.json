{"ver":"0.1","info":{"id":"mtjXWG","date":"1677060656","viewed":130,"name":"hex-tiling and edge smoothing","username":"songjo","description":"this work is for real time hatching\ninspire from https://www.youtube.com/watch?v=9VhbXyYIXhc&t=28\n\nsampling 4 times\n\ncredit to laserdog for hexagon tiling algorithm(https://www.shadertoy.com/view/Mlcczr)\nthanks for Gaktan","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simple","hexagon","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// hex-tiling and edge smoothing \n//\n// 2023-2-24 / im dongye from https://github.com/imdongye\n//\n\nconst vec2 dlo = vec2(1.7320508076, 3); // double line offset\nconst vec2 nlo = dlo*0.5; // next line offset (length:sqrt3)\n\nvec2 hash2( vec2 p ) { return fract(sin(vec2( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0))))*103.0); }\n\n// hexagon: width(sqrt3), height(2)\n// return: {offset, hexpos}\nvec4 calcHexInfo( vec2 uv )\n{\n    vec4 center = (round( vec4(uv, uv-nlo) / dlo.xyxy )) * dlo.xyxy;\n    center.zw += nlo;\n    vec4 offset = vec4(uv, uv) - center; //+tileoffset\n    return ( dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) )\n           ? vec4( offset.xy, center.xy )\n           : vec4( offset.zw, center.zw );\n}\n\nfloat calcHexDistance( vec2 off )\n{\n    off = abs(off);\n    return max(dot(nlo, off)/1.5, off.x/nlo.x);\n}\n\nvec3 calcHexSepDistance( vec2 off )\n{\n    off = abs(off);\n    // side, verticaly(inside, outside)\n    return vec3( off.x/nlo.x, dot(nlo, off)/1.5, dot(nlo*vec2(-1,1), off)/1.5);\n}\n\nvec3 mixEdge(vec3 main, vec3 side, vec3 veri, vec3 vero, vec3 coefs)\n{\n    float mainCoef = 1.-max(coefs.x,max(coefs.y,coefs.z));\n    float totalCoef = mainCoef+coefs.x+coefs.y+coefs.z;\n    vec3 rst = mainCoef*main + coefs.x*side + coefs.y*veri + coefs.z*vero;\n    rst /= totalCoef;\n    //return vec3(mainCoef);\n    return rst;\n}\n\nvec2 getPatchUv( vec2 puv, vec2 uv, float scale ) \n{\n    // read vector field\n    vec2 dir = normalize(hash2(puv)-0.5);\n    \n    mat2 rot = mat2(dir, -dir.y, dir.x);\n    \n    vec2 offset = uv-puv;\n    \n    return scale*(rot*offset)+vec2(.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float mixoff = 0.1;\n    const float texScale = 2.;\n    const float hexRowCount = 5.;\n    vec2 uv = fragCoord/iResolution.y*2.*hexRowCount;\n\n    vec4 hi = calcHexInfo(uv);\n    vec2 main = hi.zw;\n    vec2 side = main + vec2(dlo.x,0)*sign(hi.x);\n    vec2 veri = main + nlo*sign(hi.xy);            // vertical inside (right)\n    vec2 vero = main + nlo*sign(hi.xy)*vec2(-1,1); // vertical outside(left)\n    \n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    \n    float total = 1./texScale*(1.-mixoff);\n    vec3 tex =     textureGrad(iChannel0, getPatchUv(main, uv, total), dx, dy).rgb;\n    vec3 sideTex = textureGrad(iChannel0, getPatchUv(side, uv, total), dx, dy).rgb;\n    vec3 veriTex = textureGrad(iChannel0, getPatchUv(veri, uv, total), dx, dy).rgb;\n    vec3 veroTex = textureGrad(iChannel0, getPatchUv(vero, uv, total), dx, dy).rgb;\n    \n    vec3 dist = calcHexSepDistance(hi.xy);\n    vec3 coefs = 1.-smoothstep(-mixoff, mixoff, vec3(1.)-dist);\n    vec3 col =  mixEdge(tex, sideTex, veriTex, veroTex, coefs);\n    \n    // debug\n    //col = vec3(hilo/3.,0)*(1.-step(0.9, dist));\n    //col = sideTex*(1.-step(0.9, dist.y));\n    //col = texture(iChannel0, uv).rgb;\n    //col = coefs;\n    //col = sideTex;\n    //col = tex;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}