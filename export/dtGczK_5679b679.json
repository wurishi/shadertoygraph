{"ver":"0.1","info":{"id":"dtGczK","date":"1700414731","viewed":86,"name":"Random Gaussians","username":"chronos","description":"Random gaussian sampling using Box-Muller transform.\nChannel intensities are normalized to unit integral.\nIf you lean back and squint really hard to blur, the two sides should look the same after a short while :)\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","random","sampling","gaussian","splats","boxmullertransform"],"hasliked":0,"parentid":"csKBzh","parentname":"Random Gaussian Splats 2D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Random Gaussians by chronos\n    \n    ----------------------------------------------------------------------\n    \n    The left hand side is a sum of analytic normal distributions normalized to unit integral per channel.\n    \n    The right hand side are the same gaussian parameters used to randomly sample pixels to acculumate colors in,\n    using the Box-Muller transform.\n    \n    If I didn't mess up anywhere, then the right hand should converge to the left had side.\n    If you lean back and squint really hard to blur, the two sides should look the same after a short while :)\n    Linearity is important for this, so I took care to use the proper sRGB encoding instead of gamma 2.2 here.\n    \n*/\n\n\nGaussian get_gaussian(int j)\n{\n    ivec2 jia = ivec2(j*2, 0);\n    ivec2 jib = ivec2(j*2+1, 0);\n    vec4 a = texelFetch(iChannel0, jia, 0);\n    vec4 b = texelFetch(iChannel0, jib, 0);\n    \n    Gaussian G;\n    G.pos = a.xy;\n    G.scale = a.zw;\n    G.color = b.rgb;\n    G.angle = b.w;\n    return G;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    // Animate mouse if idle or preview\n    if(length(iMouse.xy) < 10.)\n        mouse = vec2(sin(iTime), 0);\n\n    vec3 color = vec3(0);\n\n    if(mouse.x < uv.x) // if right side of mouse pointer, display the randomly drawn samples (histogram)\n    {\n        // Normalize to average number of samples per frame scaled by screen area in UV coordinate units.\n        float width  = 2. * iResolution.x/iResolution.y;\n        float height = 2.;\n\n        float screen_area = (iResolution.x / width) * (iResolution.y / height);\n        float total_sample_count = float((iFrame+1) * samples_per_frame);\n\n        vec3 bufB = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n        color.rgb = bufB.rgb;\n        color.rgb *= screen_area / total_sample_count;\n    }\n    else // if left side of mouse pointer, display the analytic Gaussians / Normal distributions.\n    {\n        // Note that since this doesn't currently change per frame,\n        // It could instead be writen to a separate buffer one, and then just\n        // Read from there afterwards, instead of re-drawing each frame.\n        for(int j = 0; j < num_gaussians; j++)\n        {\n            Gaussian G = get_gaussian(j);\n\n            float c = cos(G.angle);\n            float s = sin(G.angle);\n            mat2 Rotate = mat2(c, s, -s, c);\n            mat2 Scale  = mat2(G.scale.x, 0., 0., G.scale.y);\n\n            mat2 RS = Rotate * Scale;\n\n            mat2 covariance = RS * transpose(RS);\n            \n            color.rgb += G.color * normal_dist(uv, G.pos, covariance);\n        }\n        color.rgb /= float(num_gaussians);\n    }\n    \n    float pix_size = 2./iResolution.y; // Size of a pixel in centered UV coordinates\n        \n    // Draw a vertical black seperator line\n    color = mix(color, vec3(0), smoothstep(2. * pix_size, pix_size, abs(uv.x - mouse.x)));\n    \n    // Optional tone-mapping, since the values can get higher than 1 for certain distribution parameters\n    #if 0\n    color = tanh(color);\n    #endif\n    \n    color = sRGBencode(color);\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nconst int samples_per_frame = 500;\nconst int num_gaussians = 40;\n\nstruct Gaussian\n{\n    vec2 pos;\n    vec2 scale;\n    vec3 color;\n    float angle;\n};\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\n// Just yanked this from one of my previous shaders.\n// Idk how I came up with this. I think it may just be repeated xorshift star or PCG hash that I repeated three times,\n// to incorporate all the channels, where the bits are just shoved into the mantissa of a float at the end.\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\nfloat normal_dist(vec2 x, vec2 mean, float variance)\n{\n    return exp(-.5 * dot(x-mean, x-mean)/variance) / sqrt(pow(variance * 2. * PI, 2.));\n}\n\nfloat normal_dist(vec2 x, vec2 mean, mat2 covariance)\n{\n    return exp(-.5 * dot(x-mean,inverse(covariance)*(x-mean))) / sqrt(determinant(covariance) * pow(2. * PI, 2.));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    Buffer A\n    \n    ----------------------------------------------------------------------\n    \n    This buffer just reads the texture data of some noise textures\n    to initialize the parameters of the Gaussians / normal distributions.\n    The parameters don't fit in one pixel (without packing/compression at least)\n    so I'm using two pixels per gaussian. Perhaps not the most elegant solution,\n    but it gets the job done :)\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ji = ivec2(fragCoord.xy);\n        \n    vec2 xy = texelFetch(iChannel0, ivec2(fragCoord), 0).xy * 2. - 1.;\n    vec2 scale = sqrt(texelFetch(iChannel1, ivec2(fragCoord), 0).xy) / 4.;\n    vec3 rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float angle = texelFetch(iChannel1, ivec2(fragCoord), 0).z * 2. * PI;\n    \n    if((ji.x & 1) == 0)\n    {\n        fragColor = vec4(xy, scale);\n    }\n    else\n    {\n        fragColor = vec4(rgb, angle);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\n    Buffer B\n    \n    ----------------------------------------------------------------------\n    \n    This buffer draws a predetermined number of random samples from a uniformly randomly\n    picked Gaussian (normal distribution), which makes the resulting distribution a valid\n    probability distribution as well.\n    I believe this is a Mixture of Gaussians (as in Gaussian Mixture Model) of sorts.\n\n    The parameters of the randomly picked Gaussians are retrieved from Buffer A.\n    \n    The drawn samples are bucketed into pixels and added to their counts, like a histogram.\n    \n    One idea could be to splat more than one pixel (e.g. based on a a Gaussian distribution with std ~ pixel radius)\n    where a sample lands, so that the sub-pixel position is taken into account, giving a form of\n    'anti-aliasing'.\n    \n*/\n\nGaussian get_gaussian(int j)\n{\n    ivec2 jia = ivec2(j*2, 0);\n    ivec2 jib = ivec2(j*2+1, 0);\n    vec4 a = texelFetch(iChannel0, jia, 0);\n    vec4 b = texelFetch(iChannel0, jib, 0);\n    Gaussian G;\n    G.pos = a.xy;\n    G.scale = a.zw;\n    G.color = b.rgb;\n    G.angle = b.w;\n    return G;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Just to bucket values in each pixel\n    vec2 uv_lower = (2. * floor(fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv_upper = (2. *  ceil(fragCoord) - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec3 prev_color = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n   \n    for(int i = 0; i < samples_per_frame; i++)\n    {\n        vec2 smp = vec2(0); // sample \n        \n        // Using Box-Muller transform\n        float U0 = hash(vec3(0., float(i), iFrame));\n        float U1 = hash(vec3(1., float(i), iFrame));\n        \n        smp = sqrt(\n            -2. * log(U0)\n        ) * vec2(cos(2. * PI * U1), sin(2.*PI*U1));\n        \n        // Pick random gaussian uniformly\n        Gaussian G = get_gaussian(\n            clamp(\n                int(float(num_gaussians) * hash(vec3(2., float(i), iFrame))),\n                0,\n                num_gaussians-1\n                )\n            );\n        \n        // Rescale normal gaussian to some other mean / variance:\n        {\n            // Target variance for the distribution\n            vec2 mean = G.pos;\n\n            float angle = G.angle;\n            float c = cos(angle);\n            float s = sin(angle);\n            mat2 Rotate = mat2(c, s, -s, c);\n            mat2 Scale  = mat2(G.scale.x, 0., 0., G.scale.y);\n\n            mat2 RS = Rotate * Scale;\n\n            mat2 covariance = RS * transpose(RS);\n\n            smp = RS * smp + mean;\n        \n             // Put the sample in its bucket\n            if(\n                uv_lower.x <= smp.x\n                &&\n                smp.x < uv_upper.x\n                &&\n                uv_lower.y <= smp.y\n                &&\n                smp.y < uv_upper.y\n            )\n            {\n                color.rgb += G.color;\n            }  \n        }\n    }\n\n    fragColor = vec4(prev_color + color, 1.);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}