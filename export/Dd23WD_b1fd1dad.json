{"ver":"0.1","info":{"id":"Dd23WD","date":"1667613450","viewed":276,"name":"Yet Another POM","username":"LVutner","description":"Simple parallax occlusion mapping shader.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["parallax","occlusion","mapping","fake3d","pom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Parallax occlusion mapping\n    \n    Author:\n        @LVutner\n\n    Info:\n        That's just an example of parallax occlusion mapping.\n        The heightmap is inverted, please remember about it whenever you port this shader\n        to your project.\n        \n        Possible optimizations:\n        One might improve it with batched ray sampling (https://www.youtube.com/watch?v=w8MNyE8OTDA)\n        Also, please use a linear filtering on height map textures.\n        Fade out parallax quickly to save some performance as well.\n\n    References:\n        [N. Tatarchuk, 2006] \"Practical Dynamic Parallax Occlusion Mapping\"\n*/\n\n//Settings\n#define ENABLE_POM //Enables parallax occlusion mapping\n#define ENABLE_INTERPOLATION //Enables linear interpolation\n#define MAX_HEIGHT 0.15 //Max parallax height\n#define MIN_SAMPLES 4 //Minimal sample count\n#define MAX_SAMPLES 16 //Maximal sample count\n\nfloat rcp(float x)\n{\n    return 1.0 / x;\n}\n\nvec2 calc_parallax(vec2 uv, vec3 V_tangent)\n{\n    //In fact, we don't need POM in this case\n    if(V_tangent.z <= 0.0)\n        return uv;\n\n\t//Texture space derivatives\n\tvec4 dx_dy = vec4(dFdx(uv), dFdy(uv)); \n\n    //Dynamic sampling rate, as in Tatarchuk's document\n\tvec2 sample_count = vec2(MIN_SAMPLES, MAX_SAMPLES); //Min-max    \n    float actual_sample_count = mix(sample_count.x, sample_count.y, clamp(V_tangent.z, 0.0, 1.0));\n\tfloat rcp_actual_sample_count = rcp(actual_sample_count);\n\t\n\t//Current raymarch data (layer and depth)\n    vec2 current_data = vec2(0.0, 1.0 - textureGrad(iChannel0, uv.xy, dx_dy.xy, dx_dy.zw).x);\n\n\t//Ray data\n\tvec2 ray_increment = V_tangent.xy * rcp_actual_sample_count * MAX_HEIGHT;\n\tvec2 ray_position = uv;\n\t\n\t//Raymarch...\n    //Consider implementing batched sampling as in: https://www.youtube.com/watch?v=w8MNyE8OTDA\n    for(int i = 0; i < int(actual_sample_count); i+=1)\n\t{\n\t\tif(current_data.x <= current_data.y)\n\t\t{\n            //March the ray\n\t\t\tray_position += ray_increment;\n\n            //Accumulate layer step and depth\n            current_data.x += rcp_actual_sample_count;\n\t\t\tcurrent_data.y = 1.0 - textureGrad(iChannel0, ray_position.xy, dx_dy.xy, dx_dy.zw).x;\n\t\t}\n        else\n            break;\n    }\n    \n\t//Linear interpolation\n    //Refer to Tatarchuk's document for more information.\n#ifdef ENABLE_INTERPOLATION\n    //Previous ray position\n    vec2 previous_ray_position = ray_position - ray_increment;    \n\n\t//'Previous' raymarch data - used for interpolation\n    vec2 previous_data;\n    previous_data.x = current_data.x - rcp_actual_sample_count;\n    previous_data.y = 1.0 - textureGrad(iChannel0, previous_ray_position, dx_dy.xy, dx_dy.zw).x;\n\n    //Current-Previous step\n    vec2 currprev_step = vec2(current_data.y, previous_data.y) - vec2(current_data.x, previous_data.x);\n\n    //Interpolation weight\n    float weight = currprev_step.x * rcp(currprev_step.x - currprev_step.y);\n\n    //Interpolate positions\n    vec2 interpolated_ray_position = mix(ray_position, previous_ray_position, weight);\n\n    //Output interpolated UVs\n    return interpolated_ray_position;\n#else\n    //Output traced UVs\n    return ray_position;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    //Texture UVs\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    //View direction in tangent space\n    vec3 V_tangent = normalize(vec3(-0.25, 0.50, 0.75));\n  \n    //Apply parallax\n#ifdef ENABLE_POM    \n    uv = calc_parallax(uv, V_tangent);\n#endif\n\n    //Sample textures\n    float ambient_occlusion = pow(texture(iChannel0, uv).x, 2.2) * 2.0; //God forgive me this one\n    vec3 diffuse = pow(texture(iChannel1, uv).xyz, vec3(2.2));\n    \n    //Apply AO\n    diffuse *= vec3(ambient_occlusion);\n\n    //Convert back to sRGB\n    diffuse = pow(diffuse, vec3(1.0 / 2.2));\n\n    //Output\n    fragColor = vec4(diffuse, 1.0);\n}","name":"Image","description":"","type":"image"}]}