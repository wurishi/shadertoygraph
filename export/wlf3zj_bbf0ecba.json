{"ver":"0.1","info":{"id":"wlf3zj","date":"1557504658","viewed":112,"name":"test: reflection floor","username":"takumifukasawa","description":"testes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["testes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\n#define MAT_NONE 0.\n#define MAT_PLANE 1.\n#define MAT_SPHERE 2.\n\n// ref: https://www.shadertoy.com/view/ldlcRf\n#define TEST_MAT_LESS(a, b) a < (b + .1)\n#define TEST_MAT_GREATER(a, b) a > (b - .1)\n\nprecision highp float;\n\nconst int maxIterations = 64;\nconst int maxRefIterations = 64;\nconst int shadowIterations = 16;\nconst float stepScale = 1.;\nconst float stopThreshold = .0001;\n\nfloat fov = 1.2;\nfloat nearClip = 0.;\nfloat farClip = 60.;\n\nstruct Light {\n\tvec3 position;\n\tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n  \tfloat attenuation;\n};\n    \nLight pointLightRed;\nLight pointLightGreen;\nLight pointLightBlue;\n    \nstruct Surface {\n  \tfloat dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n    float material;\n};\n    \nstruct Hit {\n  \tSurface surface;\n  \tSurface near;\n};\n    \n\nfloat saturate(float s) {\n\treturn clamp(s, 0., 1.);\n}\n\nfloat distanceToLine(vec3 origin, vec3 dir, vec3 point) {\n\tvec3 pointToOrigin = point - origin;\n    float pointToOriginLength = length(pointToOrigin);\n    vec3 pointToOriginNorm = normalize(pointToOrigin);\n    float theta = dot(dir, pointToOriginNorm);\n    return pointToOriginLength * sqrt(1. - theta * theta);\n}\n\n\n//------------------------------------------------------------------------\n// // ref: https://www.shadertoy.com/view/ldlcRf\n//------------------------------------------------------------------------\n\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec2 sminMat(vec2 a, vec2 b, float k, float c) {\n    float h = clamp(.5 + .5 * (b.x - a.x) / k, 0., 1.);\n    float x = mix(b.x, a.x, h) - k * h * (1. - h);\n    return vec2(x, (h < c) ? b.y : a.y);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(a, b, h) + k * h * (1.- h);\n}\n\n//------------------------------------------------------------------------\n\n\nvec3 repeat(vec3 p, float c) {\n  \treturn mod(p, c) - c * .5;\n}\n\nfloat repeat(float x, float c) {\n    return mod(x, c) - c * .5;\n}\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\n\nmat2 rot2(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec2 scene(vec3 p) {\n\tfloat d = FLT_MAX;\n    float m = MAT_NONE;\n    \n    vec3 pl = p;\n        \n    vec3 ps = p;\n    ps.x = repeat(ps.x, 6.);\n    ps.z = repeat(ps.z, 6.);\n    \n    float planeDist = sdPlane(pl, vec4(0., 1., 0., 1.));\n    vec2 plane = vec2(planeDist, MAT_PLANE);\n    \n    ps.y += sin(iTime * 2.) * .3 - .15;\n    //ps.y += 2.;\n    \n    float sphereDist = sdSphere(ps, .6);\n    vec2 sphere = vec2(sphereDist, MAT_SPHERE);\n    \n    d = min(plane.x, sphere.x);\n    \n\tm = minMat(plane, sphere).y;\n    \n    return vec2(m, d);\n}\n\n// render pass\nHit rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  \tSurface cs;\n  \tcs.dist = -1.;\n    \n  \tHit hit;\n\n  \tfloat sceneDist = 0.;\n  \tfloat rayDepth = start;\n    \n  \tfor(int i = 0; i < maxIterations; i++) {\n    \tvec2 res = scene(origin + dir * rayDepth);\n      \tsceneDist = res.y;      \n        \n    \tif((sceneDist < stopThreshold) || (rayDepth >= end)) {\n            break;\n    \t}\n        // update march\n\t    rayDepth += sceneDist * stepScale;\n    \tcs.material = res.x;\n  \t}\n    \n    if(rayDepth >= end) {\n    \tcs.material = MAT_NONE;\n    }\n    \n\tcs.dist = rayDepth;\n    hit.surface = cs;\n\n\treturn hit;\n}\n\n// render pass for reflection\nHit rayMarchingRef(vec3 origin, vec3 dir, float start, float end) {\n  \tSurface cs;\n  \tcs.dist = -1.;\n    \n  \tHit hit;\n\n  \tfloat sceneDist = 0.;\n  \tfloat rayDepth = start;\n    \n  \tfor(int i = 0; i < maxRefIterations; i++) {\n    \tvec2 res = scene(origin + dir * rayDepth);\n      \tsceneDist = res.y;      \n        \n    \tif((sceneDist < stopThreshold) || (rayDepth >= end)) {\n            break;\n    \t}\n        // update march\n\t    rayDepth += sceneDist * stepScale;\n    \tcs.material = res.x;\n  \t}\n    \n    if(rayDepth >= end) {\n    \tcs.material = MAT_NONE;\n    }\n    \n\tcs.dist = rayDepth;\n    hit.surface = cs;\n\n\treturn hit;\n}\n\n\n\nfloat calcAO(vec3 p, vec3 n) {\n\tfloat k = 1.;\n\tfloat occ = 0.;\n\tfor(int i = 0; i < 5; i++) {\n    \tfloat len = .15 * (float(i) + 1.);\n    \tfloat distance = scene(n * len + p).y;\n    \tocc += (len - distance) * k;\n    \tk *= .5;\n  \t}\n  \treturn clamp(1. - occ, 0., 1.);\n}\n\nfloat softShadow(vec3 origin, vec3 dir, float mint, float maxt, float k) {\n    float res = 1.;\n    float t = mint;\n    float ph = 1e10;\n    for(int i = 0; i < shadowIterations; i++) {\n    \tfloat h = scene(origin + dir * t).y;\n\n        //if(h < EPS) return 0.;\n        \n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0., t - y));\n        ph = h;\n        t += h;\n\n\t\tif(res < EPS || t > maxt) break;\n    }\n    return clamp(res, 0., 1.);\n}\n\nvec3 getNormal(vec3 p) {\n  \tconst float e = EPS;\n  \treturn normalize(vec3(\n    \tscene(p + vec3(e,   0.0, 0.0)).y - scene(p + vec3(-e,  0.0, 0.0)).y,\n    \tscene(p + vec3(0.0,   e, 0.0)).y - scene(p + vec3(0.0,  -e, 0.0)).y,\n    \tscene(p + vec3(0.0, 0.0,   e)).y - scene(p + vec3(0.0, 0.0,  -e)).y\n  \t));\n}\n\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  \tvec3 lightDir = light.position - position;\n  \tvec3 ref = reflect(-normalize(lightDir), normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - normal)));\n    \tfloat specularPower = 32.;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  \tvec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  \t// specular\n  \tfloat specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  \tlight.diffuse = diffuse;\n  \tlight.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \tfloat d = distance(light.position, surface.position);\n  \tvec3 k = vec3(.06, .08, .09);\n  \tlight.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  \t// point light\n  \tvec3 lightDir = light.position - surface.position;\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(lightDir)));\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  \t// specular\n  \tfloat specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  \tlight.diffuse = diffuse;\n  \tlight.specular = specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 sceneColor = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n    if(TEST_MAT_LESS(surface.material, MAT_PLANE)) {\n\t\tsurface.baseColor = vec3(1.);\n    } else if(TEST_MAT_LESS(surface.material, MAT_SPHERE)) {\n    \tsurface.baseColor = vec3(1., 0., 0.);\n    }\n    \n  \tvec3 specularColor = vec3(.9);\n\n  \tLight directionalLight;\n  \tdirectionalLight.position = vec3(0., 80., 0.);\n  \tdirectionalLight.intensity = 1.;\n  \tdirectionalLight.color = vec3(1., 1., 1.);\n  \tdirectionalLight.attenuation = 1.;\n  \tcalcDirectionalLight(directionalLight, surface, cameraPos);\n\n  \t// update lights\n  \tfloat m = 2.;    \n  \tpointLightRed.color = vec3(1., .1, .1);\n  \tpointLightRed.intensity = 1.;\n  \tpointLightRed.position = vec3(cos(iTime * 1.6) * m, .5, sin(iTime * 2.) * m);\n  \tcalcPointLight(pointLightRed, surface, cameraPos);\n\n  \tpointLightGreen.color = vec3(.1, 1., .1);\n  \tpointLightGreen.intensity = 1.;\n  \tpointLightGreen.position = vec3(cos(iTime * 2.) * m, .5, sin(iTime * 1.8) * m);\n  \tcalcPointLight(pointLightGreen, surface, cameraPos);\n\n  \tpointLightBlue.color = vec3(.1, .1, 1.);\n  \tpointLightBlue.intensity = 1.;\n  \tpointLightBlue.position = vec3(cos(iTime * 1.8) * m, .5, sin(iTime * 1.8) * m);            \n  \tcalcPointLight(pointLightBlue, surface, cameraPos);  \n    \n  \t// ambient\n  \tLight ambientLight;\n  \tambientLight.color = vec3(1., 1., 1.);\n  \tambientLight.intensity = .5;\n  \tvec3 ambientColor = ambientLight.color * ambientLight.intensity * surface.baseColor;\n  \tfloat ao = calcAO(position, normal);\n  \tvec3 ambient = ambientColor * ao;\n\n  \tvec3 diffuse = \n    \tdirectionalLight.diffuse\n    \t+ pointLightRed.diffuse\n    \t+ pointLightGreen.diffuse\n    \t+ pointLightBlue.diffuse;\n      \n  \tvec3 specular =\n    \tdirectionalLight.specular\n    \t+ pointLightRed.specular\n    \t+ pointLightGreen.specular\n    \t+ pointLightBlue.specular;\n    \n    float shadow = softShadow(position, normalize(directionalLight.position), .0001, 80., 16.);\n    shadow = 0.;\n    \n  \tcolor += surface.baseColor * diffuse * shadow + specularColor * specular + ambient;\n  \n  \treturn color;\n}\n\nvec3 emissiveLight(Light light, Surface surface, vec3 rayOrigin, vec3 rayDirection) {\n  \tvec3 eyeDirection = rayOrigin + rayDirection;\n  \n  \tfloat lightEmissive = pow(distanceToLine(eyeDirection, rayDirection, light.position) + .8, -7.5);\n\n  \tfloat c = dot(surface.normal, normalize(light.position - surface.position));\n  \tc = clamp(c, 0., 1.);\n  \tfloat em = 0.;\n\n  \tem = c + (1. - c) * step(farClip, surface.dist);\n\n  \treturn lightEmissive * light.color * light.intensity * em;  \n}\n\nvec3 emissiveLighting(Surface surface, vec3 rayOrigin, vec3 rayDirection) {\n  \tvec3 eyeDirection = rayOrigin + rayDirection;\n  \tvec3 normal = surface.normal;\n\n  \t// adjust for emissive lighting\n  \tpointLightRed.intensity = 1.;    \n  \tpointLightGreen.intensity = 1.;    \n  \tpointLightBlue.intensity = 1.;    \n    \n  \tvec3 color = vec3(0.);\n  \tcolor += emissiveLight(pointLightRed, surface, rayOrigin, rayDirection);\n  \tcolor += emissiveLight(pointLightGreen, surface, rayOrigin, rayDirection);\n  \tcolor += emissiveLight(pointLightBlue, surface, rayOrigin, rayDirection);\n\n  \treturn color;\n}\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n\tfloat fogAmount = 1. - exp(-distance * b);\n  \treturn mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 mouse = iMouse.xy;\n    \n  \tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  \tvec2 screenCoord = (fragCoord.xy / iResolution.xy - .5) * aspect;\n    \n    // displacement\n    vec2 uv = screenCoord;\n\n  \tmouse = mouse.xy / iResolution.xy - .5;\n  \n  \t// camera settings\n  \t//vec3 lookAt = vec3(0., 0., 0.);\n    vec3 lookAt = vec3(0., 0., 0.);\n    vec3 cameraPos = vec3(mouse.x * 3., mouse.y * 3. + 4., 8.);\n\n  \t// camera vectors\n  \tvec3 forward = normalize(lookAt - cameraPos);\n  \tvec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  \tvec3 up = normalize(cross(right, forward));   \n    \n  \t// raymarch\n  \tvec3 rayOrigin = cameraPos;\n  \tvec3 rayDirection = normalize(\n        forward\n        + fov * uv.x * right\n        + fov * uv.y * up\n\t);\n    Hit hit = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n  \tSurface surface = hit.surface;\n\n    // update surfade\n  \tsurface.position = rayOrigin + rayDirection * surface.dist;\n\tsurface.normal = getNormal(surface.position);    \n    \n  \t// color\n  \tvec3 sceneColor = vec3(0.);\n\n\t// no hit or too far\n\tif(surface.dist >= farClip) {\n    \tvec3 bgColor = vec3(0.);\n  \t\tsceneColor = bgColor;\n  \t} else {\n    \tsceneColor += lighting(surface, cameraPos);\n  \t}\n    \n    if(surface.material > .5 && surface.material < 1.5) {\n\t\tfloat refCoef = .5;\n        vec3 refDir = reflect(rayDirection, surface.normal);\n        Hit refHit = rayMarchingRef(surface.position, refDir, stopThreshold * 1000., farClip * 1.);\n        \n        Surface refSurface = refHit.surface;\n        refSurface.position = surface.position + refDir * refSurface.dist;\n\t\trefSurface.normal = getNormal(refSurface.position);    \n\n        vec3 refScene = lighting(refSurface, cameraPos);\n        \n        sceneColor += refCoef * refScene;\n        //sceneColor = vec3(refSurface.dist / farClip);\n       // sceneColor = refDir;\n    }\n    \n    // debug material color\n    //sceneColor = vec3(surface.material / 2.);    \n    \n   \tsceneColor = fog(sceneColor, surface.dist, vec3(0.), .05);\n    \n    // debug distance color\n    //sceneColor.rgb = vec3(surface.dist / farClip);\n    \n  \tfragColor = vec4(sceneColor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}