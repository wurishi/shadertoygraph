{"ver":"0.1","info":{"id":"llBXR3","date":"1445310467","viewed":387,"name":"[CIS565 2015F] ShaderHSQ","username":"hsiqi","description":"source:\nhttps://github.com/siqihuang/Project5-GLSL-Ray-Marcher/blob/master/raymarch.glsl\nReference:\nMorgan McGuire, Williams College. Numerical Methods for Ray Tracing Implicitly Defined Surfaces (2014)\nIÃ±igo QuÃ­lez. Raymarching Primitives (2013).","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["modeswitchfrom16"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define mode 5\n\nvec4 groundIntersection(in vec3 gPos,in vec3 rPos){\n    return vec4(0,1,0,rPos.y-gPos.y);\n}\n\nvec3 groundNormal(){\n    return vec3(0,1,0);\n}\n\nvec4 sphereIntersection(in vec3 sPos,in vec3 rPos,float radius){\n    vec3 dis=sPos-rPos;\n    vec4 m;\n    m.w=length(dis)-radius;\n    m.xyz=normalize(rPos-sPos);\n    return m;\n}\n\nvec3 sphereNormal(in vec3 sPos,in vec3 rPos){\n    return normalize(rPos-sPos);\n}\n\nvec4 cubeIntersection(in vec3 cPos,in vec3 rPos,float len){\n    vec3 dis=cPos-rPos;\n    float x=abs(dis.x),y=abs(dis.y),z=abs(dis.z);\n    vec4 m;\n    if(x>=y&&x>=z){\n        y=len/2.0*y/x;\n        z=len/2.0*z/x;\n        x=len/2.0;\n        m.xyz=-vec3(sign(dis.x),0.0,0.0);\n    }\n    else if(y>=x&&y>=z){\n        x=len/2.0*x/y;\n        z=len/2.0*z/y;\n        y=len/2.0;\n        m.xyz=-vec3(0.0,sign(dis.y),0.0);\n    }\n    else{\n        x=len/2.0*x/z;\n        y=len/2.0*y/z;\n        z=len/2.0;\n        m.xyz=-vec3(0.0,0.0,sign(dis.z));\n    }\n    m.w=length(dis)-length(vec3(x,y,z));\n    return m;\n}\n\nvec3 cubeNormal(in vec3 cPos,in vec3 rPos){\n    vec3 dir=rPos-cPos;\n    float x=abs(dir.x),y=abs(dir.y),z=abs(dir.z);\n    if(x>=y&&x>=z) return vec3(sign(dir.x),0.0,0.0);\n    else if(y>=x&&y>=z) return vec3(0.0,sign(dir.y),0.0);\n    else return vec3(0.0,0.0,sign(dir.z));\n}\n\nvec4 cylinderIntersection(in vec3 cPos,in vec3 rPos,float len,float radius){\n    vec3 dis=cPos-rPos;\n    float x=abs(dis.x),y=abs(dis.y),z=abs(dis.z);\n    float r=length(vec2(x,z));\n    vec4 m;\n    if(2.0*y/len>r/radius){\n        x=len/2.0*x/y;\n        z=len/2.0*z/y;\n        y=len/2.0;\n        m.xyz=-vec3(0.0,sign(dis.y),0.0);\n    }\n    else{\n        x=radius*x/r;\n        y=radius*y/r;\n        z=radius*z/r;\n        vec3 normal=vec3(dis.x,0.0,dis.z);\n        normal=normalize(normal);\n        m.xyz=-normal;\n    }\n    m.w=length(dis)-length(vec3(x,y,z));\n    return m;\n}\n\nvec3 cylinderNormal(in vec3 cPos,in vec3 rPos,float len,float radius){\n    vec3 dir=rPos-cPos;\n    float x=abs(dir.x),y=abs(dir.y),z=abs(dir.z);\n    float r=length(vec2(x,z));\n    if(2.0*y/len>r/radius){\n        return vec3(0.0,sign(dir.y),0.0);\n    }\n    else{\n        vec3 normal=vec3(dir.x,0.0,dir.z);\n        normal=normalize(normal);\n        return normal;\n    }\n}\n\nmat4 transform(in vec3 scale,in vec3 rotate,in vec3 translate){\n    mat4 ms,mx,my,mz,mt;\n    float PI=3.1415926;\n    float rx=rotate.x/180.0*PI;\n    float ry=rotate.y/180.0*PI;\n    float rz=rotate.z/180.0*PI;\n    ms=mat4(1);\n    ms[0].x=1.0/scale.x;\n    ms[1].y=1.0/scale.y;\n    ms[2].z=1.0/scale.z;\n    vec4 m00=vec4(cos(rx),sin(rx),0,0);\n    vec4 m01=vec4(-sin(rx),cos(rx),0,0);\n    vec4 m02=vec4(0,0,1,0);\n    vec4 m03=vec4(0,0,0,1);\n    vec4 m10=vec4(cos(ry),0,-sin(ry),0);\n    vec4 m11=vec4(0,1,0,0);\n    vec4 m12=vec4(sin(ry),0,cos(ry),0);\n    vec4 m13=vec4(0,0,0,1);\n    vec4 m20=vec4(1,0,0,0);\n    vec4 m21=vec4(0,cos(rz),sin(rz),0);\n    vec4 m22=vec4(0,-sin(rz),cos(rz),0);\n    vec4 m23=vec4(0,0,0,1);\n    mx[0]=m00;mx[1]=m01;mx[2]=m02;mx[3]=m03;\n    my[0]=m10;my[1]=m11;my[2]=m12;my[3]=m13;\n    mz[0]=m20;mz[1]=m21;mz[2]=m22;mz[3]=m23;\n    mt=mat4(1);\n    mt[3]=vec4(translate,1);\n    return mt*mz*my*mx*ms;\n    //return ms;\n}\n\nvec3 lightColor(in vec3 ro,in vec3 rd,in vec3 normal,in vec3 lPos,float t){\n    vec3 pos=ro+t*rd;\n    vec3 lDir=normalize(lPos-pos);\n    vec3 diff=vec3(1)*clamp(dot(normal,lDir),0.0,1.0);\n    vec3 ref=normalize(-lDir-2.0*normal*dot(-lDir,normal));\n    vec3 spec=vec3(1)*pow(max(0.0,dot(ref,-rd)),20.0);\n    return 0.8*diff+0.2*spec;\n    //return vec3(1,1,1)*clamp(dot(normal,lDir),0.0,1.0);\n}\n\nbool Union(vec4 m1,vec4 m2){\n    return m1.w<m2.w;\n}\n\nvec3 rayCastSmart(in vec3 ro,in vec3 rd){\n    float max=50.0;\n    float t=0.01;\n    float eplison=0.00001;\n    vec3 oPos0=vec3(1,1,1);\n    vec3 oPos1=vec3(0,0.3,0);\n    vec3 oPos2=vec3(0,0,0);\n    vec3 oPos3=vec3(1.2,0.8,-0.2);\n    float radius=0.4;\n    float len=0.6;\n    vec4 res,res1,res2,res3;\n    mat4 m[4],m0;\n    m[0]=transform(vec3(1,1,1),vec3(30,0,20),vec3(0));\n    m[1]=transform(vec3(1.0,1.0,1.0),vec3(0,0,0),vec3(0,0,0));\n    m[2]=transform(vec3(1.0,1.0,1.0),vec3(0,0,0),vec3(0,0,0));\n    m[3]=transform(vec3(1.0,1.0,1.0),vec3(-20,-30,-20),vec3(0,0,0));\n    vec3 o,d;\n    for(int i=0;i<1000;++i){\n        o=(m[0]*vec4(ro,0)).xyz;\n    \td=(m[0]*vec4(rd,1)).xyz;\n        res=cylinderIntersection(oPos0,o+t*d,len,radius);\n        o=(m[1]*vec4(ro,0)).xyz;\n    \td=(m[1]*vec4(rd,1)).xyz;\n        res1=sphereIntersection(oPos1,o+t*d,radius);\n        o=(m[2]*vec4(ro,0)).xyz;\n    \td=(m[2]*vec4(rd,1)).xyz;\n        res2=groundIntersection(oPos2,o+t*d);\n        o=(m[3]*vec4(ro,0)).xyz;\n    \td=(m[3]*vec4(rd,1)).xyz;\n        res3=cubeIntersection(oPos3,o+t*d,len);\n        if(Union(res,res1)){ \n            res=res;\n            m0=m[0];\n        }\n        else{\n            m0=m[1];\n            res=res1;\n        }\n        if(Union(res,res2)){\n            res=res;\n            //m0=m[2];\n        }\n        else{\n            res=res2;\n            m0=m[2];\n        }\n        if(Union(res,res3)){\n            res=res;\n            //m0=m[2];\n        }\n        else{\n            res=res3;\n            m0=m[3];\n        }\n        if(t>max||abs(res.w)<eplison) break;\n        t+=res.w;\n    }\n    if(res.w<eplison){\n        vec3 normal=res.xyz;\n        vec3 lPos=vec3(0,3,3);\n        lPos=(m0*vec4(lPos,0)).xyz;\n        vec3 color=lightColor(ro,rd,normal,lPos,t);\n        return color;\n        //return vec3(1);\n    }\n    else return vec3(0.8,0.9,1);\n}\n\nvec3 rayCastNaive(in vec3 ro,in vec3 rd){\n    float max=100.0;\n    float t=0.0;\n    float dt=0.01;\n    float eplison=0.01;\n    vec3 sPos=vec3(0,1,0);\n    float radius=0.2;\n    vec4 res=sphereIntersection(sPos,ro,radius);\n    for(int i=0;i<1000;++i){\n        if(t>max||res.w<eplison) break;\n       \tt+=dt;\n        res=sphereIntersection(sPos,ro+t*rd,radius);\n    }\n    if(res.w<eplison) return vec3(1);\n    else return vec3(0.8,0.9,1);\n}\n\nvec4 map( in vec3 pos )\n{\n   \tvec4 res=sphereIntersection(vec3(0.0,0.25,0.0),pos,0.25);\n    vec4 res1=cubeIntersection(vec3(0.5,0.25,0.6),pos,0.4);\n    vec4 res2=cylinderIntersection(vec3(-0.6,0.5,0.4),pos,0.8,0.3);\n    vec4 res3=groundIntersection(vec3(0,0,0),pos);\n    if(res.w>res1.w) res=res1;\n    if(res.w>res2.w) res=res2;\n    if(res.w>res3.w) res=res3;\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).w;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map(aopos).w;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 rayCastAO(in vec3 ro,in vec3 rd){\n    float max=50.0;\n    float t=0.01;\n    float eplison=0.00001;\n    vec4 res;\n    vec3 color;\n    for(int i=0;i<1000;++i){\n        res=map(ro+t*rd);\n        if(abs(res.w)<eplison||t>max) break;\n        t+=res.w;\n    }\n    if(t<max){\n    \t//float m = res.y;\n        float m=2.0;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.xyz;\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        color = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n        if( m<1.5 )\n        {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            color = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n        brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        brdf += 0.02;\n        color = color*brdf;\n\n        color = mix( color, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n\t    return vec3( clamp(color,0.0,1.0) );\n    }\n    return vec3(0.8,0.9,1);\n}\n\nvec3 rayCastDebug(in vec3 ro,in vec3 rd){\n    float max=20.0;\n    float t=0.01;\n    float eplison=0.00001;\n    vec4 res;\n    vec3 color;\n    for(int i=0;i<1000;++i){\n        res=map(ro+t*rd);\n        if(abs(res.w)<eplison||t>max) break;\n        t+=res.w;\n    }\n    return vec3(1)*t/max;\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat heightFun(float x,float z){\n    float h=noise(vec3(cos(x/1.2),sin(x/1.3)*cos(z/1.3),cos(z/1.4)));\n    return 2.0*h;\n}\n\nvec3 getNormalInHeightMap(in vec3 p ){\n    float eps=0.01;\n    vec3 n = vec3( heightFun(p.x-eps,p.z) - heightFun(p.x+eps,p.z),\n                         2.0*eps,\n                         heightFun(p.x,p.z-eps) - heightFun(p.x,p.z+eps) );\n    return normalize( n );\n}\n\nvec3 rayCastHeightMap(in vec3 ro,in vec3 rd){\n    float max=30.0;\n    float t=0.0;\n    float dt=0.01;\n    ro.y+=2.0;\n    for(int i=0;i<2000;++i){\n        vec3 pos=ro+t*rd;\n        if(pos.y<heightFun(pos.x,pos.z)){ \n            //return t/max*vec3(1);\n            vec3 normal=getNormalInHeightMap(ro+t*rd);\n            vec3 lightPos=vec3(2,3,4);\n            vec3 color=lightColor(ro,rd,normal,lightPos,t);\n            vec2 xz=vec2(pos.x,pos.z);\n            xz.x-=5.0*floor(xz.x/5.0);\n            xz.y-=5.0*floor(xz.y/5.0);\n            color = color*texture( iChannel1, xz/vec2(5,5) ).xyz;\n            return color;\n        }\n        t+=dt;\n        if(t>max) break;\n    }\n    return vec3(0.8,0.9,1);\n}\n\nvec4 cubeFractalIntersection(in vec3 cPos,in vec3 rPos,float len,int level){\n    float half_len=len/2.0;\n    float Len=len;\n    vec3 pos=cPos;\n    if(rPos.x>cPos.x+half_len||rPos.x<cPos.x-half_len) return vec4(0);\n    if(rPos.y>cPos.y+half_len||rPos.y<cPos.y-half_len) return vec4(0);\n    if(rPos.z>cPos.z+half_len||rPos.z<cPos.z-half_len) return vec4(0);\n    for(int l=0;l<2;++l){\n        float u=0.0,v=0.0,w=0.0;\n        if(rPos.x<pos.x+Len/6.0&&rPos.x>pos.x-Len/6.0) u=0.0;\n        else if(rPos.x>=pos.x+Len/6.0) u=1.0;\n        else u=-1.0;\n    \tif(rPos.y<pos.y+Len/6.0&&rPos.y>pos.y-Len/6.0) v=0.0;\n        else if(rPos.y>=pos.y+Len/6.0) v=1.0;\n        else v=-1.0;\n        if(rPos.z<pos.z+Len/6.0&&rPos.z>pos.z-Len/6.0) w=0.0;\n        else if(rPos.z>=pos.z+Len/6.0) w=1.0;\n        else w=-1.0;\n        float sum=abs(u)+abs(v)+abs(w);\n        if(sum<=1.0) return vec4(0);\n        Len/=3.0;\n        pos.x+=Len*u;\n        pos.y+=Len*v;\n        pos.z+=Len*w;\n    }\n    vec4 m;\n    m.xyz=pos;\n    m.w=Len;\n    return m;\n    //vec4 m=cubeIntersection(pos,rPos,Len);\n    //m.w=1.0;\n    //return m;\n    //return vec4(1);\n}\n\nvec3 rayCastFractal(in vec3 ro,in vec3 rd){\n    float max=50.0;\n    float t=0.0;\n    float dt=0.01;\n    float eplison=0.00001;\n    int level=3;\n    float len=1.0;\n    vec4 res;\n    for(int i=0;i<1000;++i){\n        res=cubeFractalIntersection(vec3(0),ro+t*rd,len,3);\n        //if(t>max) break;\n        if(t>max||res.w!=0.0) break;\n        t+=dt;\n    }\n    vec4 m=res;\n    if(m.w!=0.0){\n        t=0.0;\n        vec3 o=m.xyz;\n        for(int i=0;i<1000;++i){\n            res=cubeIntersection(o,ro+t*rd,m.w);\n \t       \tif(t>max||abs(res.w)<eplison) break;\n    \t    t+=res.w;\n    \t}\n        if(res.w<eplison){\n        \tvec3 normal=res.xyz;\n\t        vec3 lPos=vec3(0,3,3);\n        \tvec3 color=lightColor(ro,rd,normal,lPos,t);\n\t        return color;\n\t    }\n    }\n    return vec3(0.8,0.9,1);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    // TODO\n    #if mode==1\n    \tvec3 res=rayCastSmart(ro,rd);\n    #endif\n    #if mode==2\n    \tvec3 res=rayCastNaive(ro,rd);\n    #endif\n    #if mode==3\n    \tvec3 res=rayCastHeightMap(ro,rd);\n    #endif\n    #if mode==4\n    \tvec3 res=rayCastFractal(ro,rd);\n    #endif\n    #if mode==5\n    \tvec3 res=rayCastAO(ro,rd);\n    #endif\n    #if mode==6\n    \tvec3 res=rayCastDebug(ro,rd);\n    #endif\n    return res;  // camera ray direction debug view\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n    //ro=vec3(0,10,0);\n    //ta=vec3(1,0,0);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n} ","name":"","description":"","type":"image"}]}