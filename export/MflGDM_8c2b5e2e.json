{"ver":"0.1","info":{"id":"MflGDM","date":"1703155625","viewed":233,"name":"SAMSA - Fragment I","username":"Awayko_Wakee","description":"// Searching for the Terminal //","likes":21,"published":3,"flags":64,"usePreview":0,"tags":["raymarching","normal","morph","fresnel","bool","cineshader","samsa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Msd3Rf","filepath":"https://soundcloud.com/richarddjames/1a1?in=richarddjames/sets/selected-ambient-works-6&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/richarddjames/1a1?in=richarddjames/sets/selected-ambient-works-6&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \"Samsa - Fragment I\"\n    2023\n    by Awayko Wakee\n    License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n    \n//========================================================//\n\n    \"Samsa\" is a generative series depicting a shape in a\n    continuous state of morphing as it seeks its ultimate\n    form. Although it will never attain this ultimate shape,\n    at certain points, it returns to its original form and\n    recommences the process, altering its silhouette in the\n    quest for its eventual shape.\n    \n    Prints are available at lichterloh.tv/store\n\n//========================================================//\n\nCHOOSE FROM DIFFERENT STYLES HERE\n\nDefault Shade = NORMALS\n1 = BLACK & WHITE (stolen from FabriceNeyret2s comment:)\n*/    \n\n#define SHADE 0\n\nfloat SDF(vec3 p){\n    \n    float t = iTime*.5;\n    t += sin(iTime*.7)*.3+.5;\n    float iter = 16.;\n        \n    // TORUS\n    float tor = 1e9;\n    for(float i=min(t,0.);i<iter;i++){\n        vec3 pt = p;\n        float j = i-iter*.5;\n        float s = sin(t+i)*.2+.7;\n        pt.x += sin(t*.15+i*1.3)*3.;\n        pt.y += sin(t*.52+i*1.2);\n        pt.z += sin(t*.32+i*1.1)*2.;\n        pt.xz *= Rot(t*.59-i);\n        pt.xy *= Rot(t*.62+i);\n        pt.yz *= Rot(t*.47-i);\n        tor = Smin(tor,Torus(pt,vec2(s,s*.2)),.8);\n    }\n    \n    // SPHERE\n    float sph = 1e9;\n    for(float i=min(t,0.);i<iter*.5;i++){\n        vec3 ps = p;\n        ps.x += sin(t*.33+i*1.1)*3.;\n        ps.y += sin(t*.21+i*1.4);\n        ps.z -= sin(t*.27+i*1.5);\n        sph = Smin(sph,Sphere(ps,1.),1.);\n        sph += (cos(t*.13+i-ps.x*2.)+sin(t*.13-i+ps.y*2.)+sin(t*.15+i+ps.z*2.))*.1;\n    }\n    \n    // GYROID\n    vec3  pg = p;\n    float sg = 1.3;\n    float gyr = abs(dot(sin(pg*sg), cos(pg.zxy*sg)))/sg-.6;\n    \n    // COMPOSITION               // == Boolsche Operation ==\n    float d = Smax(sph,-tor,1.); // Subtraction:::Sdf = Sphere NOT Torus\n    d = Smin(d,tor+.02,.1);      // Union:::::::::Sdf OR smaller Torus\n    gyr = Smax(gyr,d-.1,.2);     // Intersection::Gyroid AND bigger Sdf\n    d = min(d,gyr);              // Union:::::::::Gyroid OR Sdf\n        \n    return d;\n}\n\nfloat March(vec3 ro, vec3 rd){\n    float h=0.;\n    for(int i=0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        float dS = SDF(p);\n        h += dS;\n        if(h>MAX_DIST||abs(dS)<SURF_DIST) break;\n    }\n    return h;\n}\n\nvec3 CalcNormal (vec3 p){\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ ){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*SDF(p+.001*e);\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*.5;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,7),\n         rd = CastRay(uv, ro, vec3(0), 2.),\n         col = vec3(0);\n    float d = March(ro, rd);\n    \n    if(d<MAX_DIST){ \n        vec3 p = ro + rd*d,\n             n = CalcNormal(p);\n             n.xz *= Rot(sin(t)*.5);\n        float fresnel = pow(1.+dot(rd, n),2.);\n        col = vec3(fresnel)*(n.y*.5+.5);\n        col += n*.5+.5;\n        \n    }\n    \n    col = mix( col, vec3(1), 1.-exp(-pow(.12*d,6.)));//fog    \n    col = pow(col, vec3(.4545)); //gamma correction\n\n\n    fragColor = vec4(col,1.0);\n\n#if SHADE == 1\n    fragColor = vec4(length(col)/1.8);//thanks to https://www.shadertoy.com/user/FabriceNeyret2\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \"Samsa - Fragment I\"\n    2023\n    by Awayko Wakee\n    License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n    \n//========================================================//\n\n    \"Samsa\" is a generative series depicting a shape in a\n    continuous state of morphing as it seeks its ultimate\n    form. Although it will never attain this ultimate shape,\n    at certain points, it returns to its original form and\n    recommences the process, altering its silhouette in the\n    quest for its eventual shape.\n    \n    Prints are available at lichterloh.tv/store\n    \n//========================================================*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);}\n\n//===================================================================//\n// below by https://iquilezles.org/\n\nfloat Smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat Smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat Sphere(vec3 p,float s){\n    return length(p)-s;\n    }\n\nfloat Torus( vec3 p, vec2 t){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n    }\n\nfloat Box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// above by https://iquilezles.org/\n//===================================================================//\n\nvec3 CastRay(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}","name":"Common","description":"","type":"common"}]}