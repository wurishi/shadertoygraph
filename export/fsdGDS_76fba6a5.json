{"ver":"0.1","info":{"id":"fsdGDS","date":"1633875937","viewed":60,"name":"Raymarch_renderer_sidps","username":"kingcrimson1112","description":"A 3D Renderer to display objects to screen","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","lighting","renderer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------\n// SCENE_SETTINGS\n//----------------------------------------------------\nvec3 bgColor = vec3(0.4f,0.8f,0.9f);\nfloat yScale = 1.0f;\nvec3 wUp = vec3(0.0f, 1.0f, 0.0f);\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// CAMERA_SETTINGS\n//----------------------------------------------------\nvec3 cPos = vec3(0.0f, 0.0f, -5.0f);\nvec3 cLookAt = vec3(0.0f,0.0f,0.0f);\nfloat fov = 45.0f;\n\nvec3 get_target(vec2 uv, vec3 origin, vec3 lookAt)\n{\n    vec3 view = normalize(lookAt - origin);\n    vec3 right = normalize(cross(view , wUp));\n    vec3 up = normalize(cross(right , view));\n    right *= tan(radians(fov));\n    up *= tan(radians(fov));\n    vec3 target = ((origin + view) + (up * uv.y) + (right * uv.x));\n    return target;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// SCENE_DATA\n//----------------------------------------------------\nvec4[2] spheres = vec4[2](\nvec4(-6.0f,0.0f,5.0f,4.0f),\nvec4(6.0f,0.0f,5.0f,4.0f)\n);\nfloat plane = -4.0f;\nvec3 lPos = vec3(10.0f,8.0f,10.0f);\nvec3 lightCol = vec3(1.0f,1.0f,0.5f);\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// RAYMARCHING\n//----------------------------------------------------\n#define MAX_STEPS 2000\n#define MAX_DISTANCE 2000.0f\n#define SURFACE_DISTANCE 0.001f\n\nfloat get_dist(vec3 point)\n{\n    float dist=MAX_DISTANCE;\n    for(int i=0;i<2;i++)\n    {\n        vec3 sp=spheres[i].xyz;\n        sp.x += sin(iTime*2.5f)*2.5f;\n        sp.z += cos(iTime*2.5f)*2.5f;\n        float dSphere = distance(point, sp) - spheres[i].w;\n        dist=min(dSphere,dist);\n    }\n    float dPlane = point.y - plane;\n    return min(dist, dPlane);\n}\n\nfloat ray_march(vec3 rO, vec3 rD)\n{\n    float dist = 0.0f;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 current = rO + (dist * rD);\n        float delta = get_dist(current);\n        dist += delta;\n        if(dist <= SURFACE_DISTANCE || dist >= MAX_DISTANCE)\n        {\n            break;\n        }\n    }\n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n    float dist=get_dist(p);\n    vec2 e=vec2(0.01f,0.0f);\n    vec3 n = dist- vec3(get_dist(p-e.xyy),\n                        get_dist(p-e.yxy),\n                        get_dist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat get_diffuse(vec3 p)\n{\n    vec3 lp=lPos;\n    lp.xz =vec2(sin(iTime*5.0f),cos(iTime*5.0f))*7.0f;\n    vec3 l = normalize(lp-p);\n    vec3 n = get_normal(p);\n    float dif=clamp(dot(n,l),0.0f,1.0f);\n    // Shadows\n    float d = ray_march(p + n*1.5f,lp);\n    if(d<length(lp-p))\n    {\n        dif*=0.1f;\n    }\n    return dif;\n}\n\nvec3 trace_ray(vec2 uv)\n{\n    vec3 col = vec3(0.0f);\n    vec3 rOrigin = cPos;\n    vec3 offset=vec3(1.0f,0.0f,0.0f)*sin(iTime)*50.0f;\n    //rOrigin+=offset;\n    vec3 target = get_target(uv, rOrigin, cLookAt);\n    vec3 rDir = normalize(target - rOrigin);\n    float rayMarch = ray_march(rOrigin, rDir);\n    if(rayMarch >= MAX_DISTANCE)\n    {\n        col= bgColor;\n    }\n    else\n    {\n        vec3 end = rOrigin + rayMarch*rDir;\n        float diff=get_diffuse(end);\n        col=lightCol*diff;\n    }\n    return col;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// UTILITY\n//----------------------------------------------------\n\n// Gets the UV coordinate for Image\nvec2 get_uv(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * 2.0f) - 1.0f;\n    uv *= yScale;\n    uv.x *= (iResolution.x / iResolution.y);\n    return uv;\n    // return (yScale * 2.0f * (fragCoord - 0.5f * (iResolution.xy))) / iResolution.y;\n}\n\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n// Main Image Function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From (-X,-Y) to (X,Y)\n    vec2 uv = get_uv(fragCoord);\n    \n    // Pixel Color\n    vec3 col = trace_ray(uv);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0f);\n}\n","name":"Image","description":"","type":"image"}]}