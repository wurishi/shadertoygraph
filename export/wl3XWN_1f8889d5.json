{"ver":"0.1","info":{"id":"wl3XWN","date":"1580939323","viewed":512,"name":"Tracing Warm Light","username":"enci","description":"Simple Monte Carlo path tracing. The BRDF is very fake for now.","likes":26,"published":1,"flags":0,"usePreview":1,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FLT_MAX 1000000000.0\n#define EPSILON 0.001\n#define SLOPE_EPSILON 0.008\n#define SAMPLES 64\n#define BOUNCES 4\n#define COSINE_SAMPLING 1\n\n#define MAT_WHITE           0\n#define MAT_LIGHT           1\n#define MAT_PIXEL           2\n#define MAT_NOISE           3\n#define MAT_STRIPES         4\n#define MAT_ROUGH           5\n#define MAT_WET             6\n#define MAT_PULSE           7\n#define MAT_MIRROR          8\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Simplex Noise\n////////////////////////////////////////////////////////////////////////////////\n\nfloat randFancy(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat rand3D(in vec3 co)\n{\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);\n}\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n//\tSimplex 3D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nfloat snoise(in vec3 v)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n//\tSimplex 4D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n}\n\nstruct Intersection\n{\n    float distance;\n    int objectID;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 color;\n    float emmisive;\n    float roughness;\n};\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n    int material;    \n};\n\nstruct Box\n{\n    vec3 origin;\n    vec3 extent;\n    int material;    \n};\n\nstruct Camera\n{\n    vec3 origin;\n\tvec3 lowerLeftCorner;\n\tvec3 horizontal;\n\tvec3 vertical;\n};\n\n// From Lighthouse\nuint WangHash(inout uint s)\n{\n    s = (s ^ uint(61)) ^ (s >> 16);\n    s *= uint(9);\n    s = s ^ (s >> 4);\n    s *= uint(0x27d4eb2d);\n    s = s ^ (s >> 15);\n    return s;\n}\n\nuint RandomInt(inout uint s)\n{\n    s ^= s << 13;\n    s ^= s >> 17;\n    s ^= s << 5;\n    return s;\n}\n\nfloat RandomFloat(inout uint s)\n{\n    //return float(RandomInt(s)) * 2.3283064365387e-10;    \n    return fract(float(RandomInt(s)) / 3141.592653);\n}\n\nvec3 RandomVec3(inout uint s)\n{\n    vec3 v = vec3(\n        (RandomFloat(s) - 0.5f) * 2.0,\n        (RandomFloat(s) - 0.5f) * 2.0,\n        (RandomFloat(s) - 0.5f) * 2.0);\n    return v;\n}\n\nvec3 RandomUnitSphere(inout uint s)\n{\n    vec3 v = vec3(1.0);\n    for(int i = 0; i < 16; i++)\n\t{\n        v = RandomVec3(s);\n        if(length(v) <= 1.0)\n            break;\n\t}    \n    //return v;\n    return normalize(v);\n}\n\n#define SPHERE_COUNT 11\nconst Sphere spheres[SPHERE_COUNT] = Sphere[SPHERE_COUNT](\n\t  Sphere(vec3(0.0, 2.0, 0.0), 2.0, MAT_STRIPES)                     // Big middle\n\t, Sphere(vec3(3.0, 1.0, 0.0), 1.0, MAT_ROUGH)            \n    , Sphere(vec3(0.0, 0.5, 2.6), 0.5, MAT_PULSE)                       \n    , Sphere(vec3(0.0, 1.0, -4.0), 1.0, MAT_MIRROR)\n    , Sphere(vec3(-3.0, 0.7, 0.0), 0.7, MAT_WHITE)\n    , Sphere(vec3(0.0, -10000.0, 0.0), 10000.0, MAT_WET)              // Bottom\n    , Sphere(vec3(0.0, 10009.0, 0.0), 10000.0, MAT_WHITE)               // Top\n    , Sphere(vec3(10009.0, 0.0, 0.0), 10000.0, MAT_PIXEL)               // Side\n    , Sphere(vec3(-10009.0, 0.0, 0.0), 10000.0, MAT_NOISE)              // Side\n    , Sphere(vec3(0.0, 0.0, 10009.0), 10000.0, MAT_WHITE)               // Side\n    , Sphere(vec3(0.0, 0.0, -10009.0), 10000.0, MAT_WHITE)              // Side    \n);\n\nconst vec3 background = vec3(1.0f, 0.96, 0.92);\n\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    // compute basis from normal\n    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n    // (link provided by nimitz)\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return  sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nfloat sphereTest(in Ray ray, in Sphere sphere)\n{\n    float t = -1.0;\n\tvec3 rc = ray.origin - sphere.origin;\n\tfloat c = dot(rc, rc) - (sphere.radius * sphere.radius);\n\tfloat b = dot(ray.direction, rc);\n\tfloat d = b*b - c;\n    if(d > 0.0)\n    {\n\t    t = -b - sqrt(abs(d));\n        return t;\n\t    float st = step(0.0, min(t,d));\n    } else  \n    {\n        return -1.0;\n    }\n}\n\nIntersection intersect(in Ray ray)\n{\n    float minD = FLT_MAX;\n    Intersection intersection;\n    for(int i = 0; i < SPHERE_COUNT; i++)\n    {\n        Sphere s = spheres[i];\n        float t = sphereTest(ray, s);\n        if(t > 0.0 && t < minD)\n        {\n            minD = t;\n            intersection.distance = t;\n            intersection.objectID = i;\n        }\n    }\n    return intersection;\n}\n\nvec3 getNormal(in vec3 position, in int objectID)\n{\n    Sphere s = spheres[objectID];\n    return normalize(position - s.origin);\n}\n\nMaterial getMaterial(in vec3 position, in int objectID)\n{\n    int mat = spheres[objectID].material;\n    switch(mat)\n    {\n        case MAT_WHITE :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, 1.0);\n        }\n        case MAT_LIGHT :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 1.0, 1.0);\n        }\n        case MAT_PIXEL :\n          {\n            if(rand3D(round(position + vec3(iTime * 6.0, 0.0, 0.0))) > 0.70)\n                return Material(vec3(1.20, 1.0, 1.0), 1.0, 1.0);\n            else\n                return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.05);\n        }                \n        case MAT_NOISE : \n        {\n            //if(abs(snoise(position + vec3(iTime * 1.0, 0.0, 0.0))) < 0.01)\n            //if(rand3D(round(position * 5.0 + vec3(iTime * 6.0, 0.0, 0.0))) > 0.70)\n            if(sin((position.y - position.z + iTime * 2.9) * 4.0) < 0.0)\n                return Material(vec3(1.20, 1.0, 1.0), 1.0, 1.0);\n            else\n                return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.85);\n        }\n        case MAT_STRIPES :\n        {\n            if(sin((position.y + position.z + iTime * 0.9) * 12.0) < 0.0)\n                return Material(vec3(1.20, 1.0, 1.0), 1.0, 1.0);\n            else\n                return Material(vec3(1.0, 1.0, 1.0), 0.0, 1.0);\n        }\n        case MAT_ROUGH :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.5);\n        }\n        case MAT_WET :\n        {\n            float noiz = abs(pow(snoise(position), 2.0));\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, noiz);            \n        }\n        case MAT_PULSE :\n        {\n            float v = pow(max(sin(iTime * 10.9), 0.0), 3.0);\n            return Material(vec3(v, v, v), 2.0, 1.0);            \n        }\n        case MAT_MIRROR :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.0);\n        }\n            break;\n    }\n}\n\nvec3 getBackground(in vec3 direction)\n{\n    return vec3(0.9, 0.85, 1.0);\n}\n\nCamera MakeCamera(  in vec3 origin,\n                    in vec3 lookAt,\n                    in vec3 up,\n\t                float fov,\n\t                float aspect)\n{\n    Camera camera;\n    vec3 u, v, w;\n\tfloat theta = radians(fov);\n\tfloat halfHeight = tan(theta * 0.5f);\n\tfloat halfWidth = aspect * halfHeight;\n\tw = normalize(origin - lookAt);\n\tu = normalize(cross(normalize(up), w));\n\tv = normalize(cross(w, u));\n    camera.origin = origin;\n\tcamera.lowerLeftCorner =  origin - halfWidth * u - halfHeight * v - w;\n\tcamera.horizontal = 2.0f * halfWidth * u;\n\tcamera.vertical = 2.0f * halfHeight * v;\n    return camera;\n}\n\nRay MakeRay(in Camera camera,float s, float t)\n{\n    vec3 direction = camera.lowerLeftCorner + s * camera.horizontal + (1.0f -  t) * camera.vertical - camera.origin;\n    direction = normalize(direction);\n\treturn Ray(camera.origin, direction);\n}\n\nvec3 lightDirection()\n{\n    float x = sin(0.5 * 5.0);\n    float y = 1.0;\n    float z = cos(0.5 * 5.0) - 3.0;\n    return normalize(vec3(x, y, z));\n}\n\nfloat sphereTest(   vec3 ray,\n                    vec3 dir,\n                    vec3 center,\n                    float radius,\n                    out vec3 normal,\n                    out float t)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tt = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n    vec3 pos = ray + dir * t;\n    normal = pos - center;\n    normal = normalize(normal);\n    return mix(-1.0, t, st);\n}\n\nvec3 applyLighting(in vec3 position, in vec3 normal, int objectID)\n{\n    return vec3(0.0);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    return vec3(max(dot(normal, light), 0.0));\n}\n\nvec3 getBRDFRay(in vec3 position, in vec3 normal, in vec3 incident, int objectID, inout uint seed)\n{    \n    vec3 ref = reflect(incident, normal);\n    Sphere sphere = spheres[objectID];\n    Material material = getMaterial(position, objectID);\n    vec3 offset = mix(ref, normal, material.roughness);\n    //return normalize(RandomUnitSphere(seed) * material.roughness + offset);\n    return normalize(RandomUnitSphere(seed) * material.roughness + ref);\n}\n\nvec3 GetHemisphereVector(in vec3 normal, inout uint seed)\n{\n    vec3 r = RandomUnitSphere(seed);\n    if(dot(normal, r) < 0.0)\n        return -r;\n    return r;\n}\n\n// create light paths iteratively\nvec3 rendererCalculateColor(Ray ray, in int bounces, uint seed)\n{\n    vec3 accumulator = vec3(0.0);  // accumulator - should get brighter\n    vec3 mask = vec3(1.0);  // mask - should get darker\n\n    for( int i = 0; i < bounces; i++)\n    {\n        // intersect scene\n        Intersection intersection = intersect(ray);\n        \n        // if nothing found, return background color or break\n        if(intersection.distance <= 0.0) \n            break;\n        \n        // get position and normal at the intersection point\n        vec3 pos = ray.origin + ray.direction * intersection.distance;\n        vec3 normal = getNormal(pos, intersection.objectID);\n        \n        // get color for the surface\n        Material material = getMaterial(pos, intersection.objectID);\n\n        // compute direct lighting\n        vec3 emmisive = material.emmisive * material.color;\n\n        // prepare ray for indirect lighting gathering        \n#ifdef COSINE_SAMPLING\n        vec3 dir = getBRDFRay(pos, normal, ray.direction, intersection.objectID, seed);        \n#else   \n        vec3 dir = GetHemisphereVector(normal, seed);     \n#endif\n        ray.direction = dir;\n        float ND = max(dot(ray.direction, normal), 0.0);\n        ray.origin = pos + normal * (1.0 - pow(ND, 2.0)) * SLOPE_EPSILON;\n\n        // surface * lighting\n#ifdef COSINE_SAMPLING\n        mask *= material.color;\n#else   \n        mask *= material.color * ND * (3.14 / 2.0);             \n#endif\n\n        accumulator += mask * emmisive;\n    }\n\n    return accumulator;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    float width = iResolution.x;\n    float height = iResolution.y;\n    \n    float cx = sin(iTime * 1.0) * 10.0;\n    float cy = 1.0;\n    float cz = cos(iTime * 1.0) * 10.0; \n\n    Camera camera = MakeCamera(\n        vec3(cx, cy, cz),\n        vec3(0.0, 2.0, 0.0),\n        vec3(0.0, 0.1, 0.0),\n        60.0, 1.6);\n\n    vec3 sa = hash( uvec3(x, y, iTime * 60.0) );\n    uint seed = (uint(x) + uint(y) * uint(width)) ^ uint(iTime * 10000000.0);\n    seed = WangHash(seed);\n\n    vec3 color = vec3(0.0);\n    for( int i = 0; i < SAMPLES; i++)\n    {\n        float xs = x + RandomFloat(seed) + 0.5;\n        float ys = y + RandomFloat(seed) + 0.5;\n        Ray ray = MakeRay(camera, xs / width, 1.0 - (ys / height));\n        color += rendererCalculateColor(ray, BOUNCES, seed);\n        seed += uint(hash(float(i)) * 100.0);\n    }\n    color /= float(SAMPLES);\n\n    fragColor = vec4(pow(color, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}