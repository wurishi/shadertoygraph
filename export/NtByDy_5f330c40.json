{"ver":"0.1","info":{"id":"NtByDy","date":"1650179442","viewed":190,"name":"2D light room parallel light","username":"batersy","description":"A fork of my pervious work, only change point light source into parallel light source.  \nWait longer to look better, might be used to evaluate caustic and ambient occlusion.\nClick mouse to change point light direction (relative top center), have fun.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["2d","reflection","refraction","laser"],"hasliked":0,"parentid":"stSyRd","parentname":"2D light room with glass"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * 2D light room parallel light by batersy\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// A fork of my pervious work\n// https://www.shadertoy.com/view/stSyRd\n// 2022/04/18 update: You can choose whether screen edges will diffuse(default)\n// or reflect light by switch EDGE_LIGHT_DIFFUSE in Buffer A\n// 2022/04/19 update: Add blackbody function to make it physically right,\n// if you like previous effect, switch USE_BLACK_BODY to 0 and brightness to 160\n\n// from ENDESGA that make light softer\n#define OPTIMIZ_COLOR 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n\n    col = pow( col, vec3(0.4545) );\n#if OPTIMIZ_COLOR\n    fragColor = vec4( 1.-exp(-col*col), 1.0 );\n#else\n    fragColor = vec4( col, 1.0 );\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TYPE_EDGE 0\n#define TYPE_SHAPE 1\n\nfloat laserThickness = .0001;\nfloat shapeThickness = .005;\nint maxBounceCount = 8;\n\n// set bigger to accelerate iteration, but will reduce fps\nint sampleCount = 4;\n// set bigger to be brighter\nint brightness = 50;\n\n// transmittance config\n#define ENABLE_ATTENUATION 1\nfloat sigmaAir = 0.5;\nfloat sigmaShape = 2.0;\nfloat transmittanceStop = .1;\n\n// light only from the top edge, else will cover total box\n#define LIGHT_ONLY_TOP_EDGE 1\n// set light will diffuse or only reflect at box edge, diffuse is more natural\n#define EDGE_LIGHT_DIFFUSE 1\n// whether to use blackbody function\n#define USE_BLACK_BODY 1\n\n// ------shape definition-----------\n// screen edge\nvec2 edge = vec2(16.,9.) / 9.;\n// circle define as format vec3(x, y, radius)\nvec3[] circles = vec3[](vec3(.3, .5, .2),\n                          vec3(1.4, .7, .1));\nstruct triangle {vec2 a, b, c;};\n// vertex should be given in anti-clockwise order\ntriangle[] triangles = triangle[](triangle(vec2(.9, .7),\n                                           vec2(.65, .25),\n                                           vec2(1.15, .25)));\nstruct quadrangle {vec2 a, b, c, d;};\n// vertex should be given in anti-clockwise order\nquadrangle[] quadrangles = quadrangle[](quadrangle(vec2(1.3, .5),\n                                                   vec2(1.3, .1),\n                                                   vec2(1.5, .1),\n                                                   vec2(1.5, .5)));\n\n\n// ------screen edge definition-----------\nfloat rayIntersectBox(vec2 ro, vec2 rd, vec2 size, out vec2 normal) {\n    float xDis, ydis;\n    if(rd.x > 0.) xDis = (size.x - ro.x) / rd.x;\n    else xDis = abs(ro.x / rd.x);\n    if(rd.y > 0.) ydis = (size.y - ro.y) / rd.y;\n    else ydis = abs(ro.y / rd.y);\n    \n    float t = min(xDis, ydis);\n    vec2 pos = ro + t * rd;\n    float buffer = .01;\n    if(pos.x <= buffer) normal = vec2(1.,0.);\n    if(pos.y <= buffer) normal = vec2(0.,1.);\n    if(pos.x >= size.x - buffer) normal = vec2(-1.,0.);\n    if(pos.y >= size.y - buffer) normal = vec2(0.,-1.);\n    return t;\n}\n\n// ------circle shape definition-----------\nfloat rayIntersectCircle(vec2 ro, vec2 rd, vec3 circle, out vec2 normal) {\n\tvec2 oc = ro - circle.xy;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - circle.z*circle.z;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n    float x1 = -b - sqrt( h ), x2 = -b + sqrt( h );\n    float t = (x1 > 0.)? x1 : x2;\n    vec2 pos = ro + t * rd;\n    normal = normalize(pos - circle.xy);\n\treturn t;\n}\nfloat sdfCircle(vec2 p, vec3 circle) {\n    return length(p - circle.xy) - circle.z;\n}\n\n// ------line segment definition-----------\nfloat rayIntersectLine(vec2 ro, vec2 rd, vec2 from, vec2 to, out vec2 normal) {\n    vec2 rofrom = from - ro;\n    vec2 tofrom = from - to;\n    // solve equation t * rd + k * tofrom = rofrom\n\tfloat det = determinant(mat2(rd.x,tofrom.x,\n                                 rd.y,tofrom.y));\n    if(abs(det) < 0.00001) return -1.0;\n    float k = determinant(mat2(rd.x,rofrom.x,\n                               rd.y,rofrom.y)) / det;\n    if(k < 0.0 || k > 1.0) return -1.0;\n    float t = determinant(mat2(rofrom.x,tofrom.x,\n                               rofrom.y,tofrom.y)) / det;\n    if(t < 0.0) return -1.0;\n    // rotate 90 degress clockwise to get normal\n    vec2 fromto = normalize(to - from);\n    normal = vec2(fromto.y, -fromto.x);\n    return t;\n}\nfloat sdfLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// ------triangle definition-----------\nfloat rayIntersectTriangle(vec2 ro, vec2 rd, triangle tri, out vec2 normal) {\n    float t = -1.0, tmp_t;\n    vec2 tmp_normal;\n\n    tmp_t = rayIntersectLine(ro, rd, tri.a, tri.b, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, tri.b, tri.c, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, tri.c, tri.a, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n\n    return t;\n}\nfloat sdfTriangle(vec2 p, triangle tri) {\n    float sdf1 = sdfLine(p, tri.a, tri.b);\n    float sdf2 = sdfLine(p, tri.b, tri.c);\n    float sdf3 = sdfLine(p, tri.c, tri.a);\n    return min(min(sdf1, sdf2), sdf3);\n}\n\n// ------quadrangle definition-----------\nfloat rayIntersectQuadangle(vec2 ro, vec2 rd, quadrangle quad, out vec2 normal) {\n    float t = -1.0, tmp_t;\n    vec2 tmp_normal;\n\n    tmp_t = rayIntersectLine(ro, rd, quad.a, quad.b, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, quad.b, quad.c, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, quad.c, quad.d, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    tmp_t = rayIntersectLine(ro, rd, quad.d, quad.a, tmp_normal);\n    if(tmp_t > 0.0 && (tmp_t < t || t < 0.0)) {\n        t = tmp_t;\n        normal = tmp_normal;\n    }\n    return t;\n}\nfloat sdfQuadrangle(vec2 p, quadrangle quad) {\n    float sdf1 = sdfLine(p, quad.a, quad.b);\n    float sdf2 = sdfLine(p, quad.b, quad.c);\n    float sdf3 = sdfLine(p, quad.c, quad.d);\n    float sdf4 = sdfLine(p, quad.d, quad.a);\n    return min(min(sdf1, sdf2), min(sdf3, sdf4));\n}\n\n// ------common things-----------\nfloat random(float seed) {\n    return fract(sin(seed * iTime)*43758.5453 + float(iFrame) * seed);\n}\nvec3 drawLine(vec2 ro, vec2 rd, float dis, vec2 p, in vec3 color, in vec2 trans) {\n    vec2 pnew = p - ro;\n    float d = dot(pnew, rd);\n    float lineDis = dot(pnew, pnew) - d * d;\n    if(d > 0. && d < dis && lineDis < laserThickness) {\n        float tran = 1.0;\n#if ENABLE_ATTENUATION\n        tran = mix(trans.x, trans.y, d / dis);\n#endif\n        return color * tran * smoothstep(1., 0., lineDis / laserThickness);\n    }\n    return vec3(0);\n}\nfloat getNearestShape(vec2 ro, vec2 rd, out int type, out vec2 normal) {\n    float t = rayIntersectBox(ro, rd, edge, normal);\n    type = TYPE_EDGE;\n\n    float tmp_t;\n    vec2 tmp_normal;\n    for(int i = 0; i < circles.length(); i++) {\n        tmp_t = rayIntersectCircle(ro, rd, circles[i], tmp_normal);\n        if(tmp_t > 0. && tmp_t < t) {\n            type = TYPE_SHAPE;\n            t = tmp_t;\n            normal = tmp_normal;\n        }\n    }\n\n    for(int i = 0; i < triangles.length(); i++) {\n        triangle tri = triangles[i];\n        tmp_t = rayIntersectTriangle(ro, rd, tri, tmp_normal);\n        if(tmp_t > 0. && tmp_t < t) {\n            type = TYPE_SHAPE;\n            t = tmp_t;\n            normal = tmp_normal;\n        }\n    }\n    \n    for(int i = 0; i < quadrangles.length(); i++) {\n        quadrangle quad = quadrangles[i];\n        tmp_t = rayIntersectQuadangle(ro, rd, quad, tmp_normal);\n        if(tmp_t > 0. && tmp_t < t) {\n            type = TYPE_SHAPE;\n            t = tmp_t;\n            normal = tmp_normal;\n        }\n    }\n    return t;\n}\nvoid paintShape(vec2 p, inout vec3 color) {\n    float sdf, dis;\n    for(int i = 0; i < circles.length(); i++) {\n        vec3 circle = circles[i];\n        sdf = abs(sdfCircle(p, circle));\n        if(sdf < shapeThickness)\n            color += vec3(.2) * smoothstep(shapeThickness, 0., sdf);\n    }\n    for(int i = 0; i < triangles.length(); i++) {\n        triangle tri = triangles[i];\n        sdf = abs(sdfTriangle(p, tri));\n        if(sdf < shapeThickness)\n            color += vec3(.2) * smoothstep(shapeThickness, 0., sdf);\n    }\n    for(int i = 0; i < quadrangles.length(); i++) {\n        quadrangle quad = quadrangles[i];\n        sdf = abs(sdfQuadrangle(p, quad));\n        if(sdf < shapeThickness)\n            color += vec3(.2) * smoothstep(shapeThickness, 0., sdf);\n    }\n}\nfloat sdfShapeOutside(vec2 p) {\n    float outside = 1.0, sdf;\n    for(int i = 0; i < circles.length(); i++) {\n        vec3 circle = circles[i];\n        sdf = sdfCircle(p, circle);\n        if(sdf < 0.) return -1.0;\n    }\n    for(int i = 0; i < triangles.length(); i++) {\n        triangle tri = triangles[i];\n        sdf = sdfTriangle(p, tri);\n        if(sdf < 0.) return -1.0;\n    }\n    for(int i = 0; i < quadrangles.length(); i++) {\n        quadrangle quad = quadrangles[i];\n        sdf = sdfQuadrangle(p, quad);\n        if(sdf < 0.) return -1.0;\n    }\n    return outside;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.y;\n    float rate = iResolution.x / iResolution.y;\n    vec2 rd = normalize(vec2(-1.0, -2.0));\n    if(iMouse.xy != vec2(0)) rd = normalize(iMouse.xy / iResolution.y - vec2(0.5 * rate, 1.0));\n    uint state = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x) + uint(iFrame) * uint(iResolution.x) * uint(iResolution.y);\n    vec3 color = vec3(0);\n\n    // remember when the mouse moved\n    vec4 persistentState = texelFetch(iChannel0, ivec2(0), 0);\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = persistentState;\n        if (iFrame == 0) fragColor = vec4(0);\n        if (iMouse.z > 0.) fragColor.w = float(iFrame);\n        return;\n    }\n\n    float t, f, sigma;\n    vec2 pos, normal;\n    const float A = 1.2280;\n    const float B = 0.09;\n    float n1 = 1.0;\n    float outside = 1.0;\n    vec2 rdTmp;\n    float rangeLeft = 0.;\n    float rangeRight = rate;\n#if !LIGHT_ONLY_TOP_EDGE\n    rangeLeft = min(0., rd.x / rd.y);\n    rangeRight += max(0., rd.x / rd.y);\n#endif\n    for(int i = 0; i < sampleCount; ++i) {\n        vec2 ro = vec2(mix(rangeLeft, rangeRight, pcg(state)), 1.0);\n        if(ro.x < 0.0) ro = vec2(0.00001, 1.0 - ro.x * rd.y / rd.x);\n        else if(ro.x > rate) ro = vec2(rate - 0.00001, 1.0 - ro.x * rd.y / rd.x);\n        float w = mix(380.0, 750.0, pcg(state));\n        float n2 =  A + B/(w*w*1e-6);\n        vec3 rayColor = xyzToRgb(xyzFit_1931(w));\n#if USE_BLACK_BODY\n        rayColor *= 1e-13 * BlackBody(6000.0, w);\n#endif\n        int count = 0, type;\n        \n        float transmittance = 1.0, transmittanceNew;\n        while(transmittance > transmittanceStop && count < maxBounceCount) {\n            // find nearest sdf\n            t = getNearestShape(ro, rd, type, normal);\n            sigma = (outside > 0.) ? sigmaAir : sigmaShape;\n            transmittanceNew = transmittance * exp(-sigma * t);\n\n            // paint path and update transmittance\n            color += drawLine(ro, rd, t, p, rayColor, vec2(transmittance,transmittanceNew));\n            transmittance = transmittanceNew;\n\n            // update ray\n            pos = ro + t * rd;\n            ro = pos;\n            if(type == TYPE_EDGE) {\n#if EDGE_LIGHT_DIFFUSE\n                // path tracing, random choose a direction when hit on diffuse surface\n                float rotateAngle = PI * (pcg(state) - 0.5);\n                rd = rotateClockwise2D(normal, rotateAngle);\n#else\n                // only reflect light, means specular surface\n                f = 1.;\n                type = TYPE_SHAPE;\n#endif\n            }\n\n            if(type != TYPE_EDGE) {\n                if(outside > 0.) f = fresnel(n1, n2, abs(dot(rd, normal)));\n                else f = fresnel(n2, n1, abs(dot(rd, normal)));\n                //if(random(dot(pos, rd)) < f) {\n                if(pcg(state) < f) {\n                    rd = reflect(rd, normal);\n                } else {\n                    rd = refract(rd, normal * outside, pow(n2, -outside));\n                    outside = -outside;\n                }\n            }\n            \n            // prevent chaos when checking whether ro inside sdf\n            ro += rd * 0.00001;\n            count++;\n        }\n    }\n\n    color *= float(brightness / sampleCount);\n    paintShape(p, color);\n    if( iFrame!=0 ) {\n        vec3 lastColor = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n        color = mix(lastColor, color, 1./(float(iFrame) - persistentState.w));\n    }\n    fragColor = vec4(color, 1.0);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Spectrum to xyz approx function from Sloan\n// Inputs:  Wavelength in nanometers\n#define PI 3.14159265359\nfloat xFit_1931( float wave ) {\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\n\nfloat yFit_1931( float wave ) {\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\n\nfloat zFit_1931( float wave ) {\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \nvec3 xyzToRgb(vec3 XYZ) {\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\n\t                  -0.969256 , 1.875991,  0.041556,\n\t                   0.055648, -0.204043,  1.057311 );\n}\n\nfloat remap(const float originalValue, const float originalMin, const float originalMax, const float newMin, const float newMax) {\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nfloat fresnelSchlick(float n1, float n2, float cosi) {\n    float sint2 = n1 * n1 / (n2 * n2) * (1.0 - cosi * cosi);\n    // Total Internal Reflection\n    if(sint2 >= 1.0) return 1.0;\n    float cost = sqrt(1.0 - sint2);\n    float R0 = (n1 - n2)/(n1 + n2); R0 *= R0;\n    float cosin = (n1 < n2) ? cosi : cost;\n    return R0 + (1.0 - R0) * pow(1.0 - cosin, 5.0);\n}\nfloat fresnel(float n1, float n2, float cosi) {\n    float sint2 = n1 * n1 / (n2 * n2) * (1.0 - cosi * cosi);\n    // Total Internal Reflection\n    if(sint2 >= 1.0) return 1.0;\n    float cost = sqrt(1.0 - sint2);\n    float n1cosi = n1 * cosi;\n    float n1cost = n1 * cost;\n    float n2cosi = n2 * cosi;\n    float n2cost = n2 * cost;\n    float Rs = (n1cosi - n2cost) / (n1cosi + n2cost); Rs *= Rs;\n    float Rp = (n1cost - n2cosi) / (n1cost + n2cosi); Rp *= Rp;\n    return 0.5 * (Rs + Rp);\n}\n\n// https://www.pcg-random.org/\nfloat pcg(inout uint state)\n{\n\tstate = state * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float((word >> 22u) ^ word) / float(0xffffffffu);\n}\n\nvec2 rotateClockwise2D(vec2 rd, float theta) {\n    float cosin = cos(theta);\n    float sine = sin(theta);\n    mat2 rotate = mat2(cosin, sine,\n                       -sine, cosin);\n    return rotate * rd;\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}","name":"Common","description":"","type":"common"}]}