{"ver":"0.1","info":{"id":"ttVBDm","date":"1614522913","viewed":234,"name":"Rectangular Bezier Stroke","username":"nr4","description":"Quadratic bezier distance, closest point on curve and normal, used for computing the distance to a rectangular stroke.\n\nSuggestions for optimizations welcome! :)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","stroke","spline","distance","normal","box","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Rectangular Bezier Stroke\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// minimum distance to spline, nearest point on spline and normal in that point\nvoid spline2(in vec2 x, in vec2 p0, in vec2 p1, in vec2 p2, out float ds, out vec2 xn, out vec2 n)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;\n    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = -tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.)\n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        float np = clamp(ui.x+ui.y-tau,0.,1.);\n        \n        xn = mix(mix(p0,p1,np),mix(p1,p2,np),np);\n        ds = length(x-xn);\n        n = normalize(2.*mix(p1-p0, p2-p1, np));\n        \n        return;\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.,\n        dsa;\n    vec3 t = clamp(c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau,0.,1.);\n    vec2 xna;\n    \n    xn = mix(mix(p0,p1,t.x),mix(p1,p2,t.x),t.x);\n    ds = length(x-xn);\n    n = 2.*mix(p1-p0, p2-p1, t.x);\n    \n    xna = mix(mix(p0,p1,t.y),mix(p1,p2,t.y),t.y);\n    dsa = length(x-xna);\n    if(dsa < ds)\n    {\n        xn = xna;\n        ds = dsa;\n        n = 2.*mix(p1-p0, p2-p1, t.y);\n    }\n    \n    xna = mix(mix(p0,p1,t.z),mix(p1,p2,t.z),t.z);\n    dsa = length(x-xna);\n    if(dsa < ds)\n    {\n        xn = xna;\n        ds = dsa;\n        n = 2.*mix(p1-p0, p2-p1, t.z);\n    }\n    n = normalize(n);\n}\n\n// minimum distance to line, nearest point on line and normal in that point\nvoid linesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d, out vec2 xn, out vec2 n)\n{\n    vec2 da = p2-p1;\n    float t = clamp(dot(x-p1, da)/dot(da,da),0.,1.);\n    xn = mix(p1, p2, t);\n    d = length(x-xn);\n    n = normalize(p2-p1).yx*c.xz;\n}\n\n// regular box distance\nvoid dbox(in vec2 x, in vec2 b, out float d)\n{\n    vec2 da = abs(x)-b;\n    d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n}\n\n// apply the box distance to arbitrary curve distance functions\nvoid rect_stroke(in vec2 x, in float d2d, in float size, in vec2 xn, in vec2 n, out float d)\n{\n    dbox(mat2(n, n.yx*c.xz)*(x-xn), size*c.xx, d);\n}\n\n// paint with antialiasing\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float d, \n        da;\n    vec2 xn, n;\n    spline2(uv, -.3*vec2(cos(iTime),sin(iTime)), -.2*c.xz*vec2(cos(1.4*iTime), sin(-1.1*iTime)), .1*vec2(cos(1.4*iTime),-1.1*sin(iTime)), d, xn, n);\n    \n    // Try this with lines as well:\n    // linesegment(uv, -.3*vec2(cos(iTime),sin(iTime)), -.2*c.xz*vec2(cos(1.4*iTime), sin(-1.1*iTime)), d, xn, n);\n    \n    rect_stroke(uv, d, .025, xn, n, d);\n    \n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    \n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}