{"ver":"0.1","info":{"id":"fscSRf","date":"1633592351","viewed":145,"name":"Volume Rendering+Opaque Shpere","username":"OSevenC","description":"1.确定光线发射点和发射方向\n2.找到光线与不透明物体的交点\n3.找到光线与volume的交点\n4.1若光线先与不透明物体相交，则直接Phong\n4.2若光线先与Volume相交，则RayMarching，计算Volume的颜色，同时计算直接opaqueVisiblity，然后用Phong画不透明物体，最后叠加。","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["volumerendering","raymarhcing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LARGE_NUMBER 1e20\n#define MAX_VOLUME_MARCH_STEPS 160//在Volume中光线步进的最大次数\n#define MAX_SDF_DETECT_STEPS 15//最大探测次数，用于确定物体边界\n#define MARCH_STRIDE 0.4//固定的光线步长（在Volume中）\n#define ABSORPTION_COEFFICIENT 0.5\n#define ABSORPTION_CUTOFF 0.25\n\nstruct Sphere{\n    vec3 Position;\n    float Radius;\n};\nSphere mSphere1 = Sphere(\n    vec3(0,0,0),\n    8.0\n);\nSphere mSphere2 = Sphere(\n    vec3(32,0,0),\n    8.0\n);\nstruct Box{\n    vec3 Position;\n    vec3 EdgeLength;\n};\n\nBox mBox = Box(\n    vec3(0,0,0),\n    vec3(16.0)\n);\n\nstruct Camera\n{\n    vec3 Position;//\n    vec3 LookAt;    \n\n    float ImageHeight;//成像高度//根据屏幕长宽比可求宽度\n    float FocalDistance;//焦距\n};\nCamera mCamera = Camera(\n    vec3(120, 20, -165),\n    vec3(0, 0, 0),\n    2.0,\n    7.0\n);\n\n//https://www.shadertoy.com/view/wssBR8\nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in Sphere sphere, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphere.Position;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphere.Radius * sphere.Radius);\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphere.Position);\n      return t;\n}\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out vec3 normal)\n{\n    float t;\n    normal = vec3(0, 0, 0);\n    vec3 nor1 = vec3(0, 0, 0);\n    vec3 nor2 = vec3(0, 0, 0);\n    float d1 = SphereIntersection(rayOrigin, rayDirection, mSphere1, nor1);\n    float d2 = SphereIntersection(rayOrigin, rayDirection, mSphere2, nor2);\n    if(d1<.0)//如果一个是无穷大，就返回另一个\n    {\n        normal = nor2;\n        t = d2;\n    }\n    else if(d2<.0)\n    {\n        normal = nor1;\n        t = d1;\n    }\n    else if(d1>d2)//如果都不是无穷远处，再比较哪个更近\n    {\n        normal = nor2;\n        t = d2;\n    }\n    else\n    {\n        normal = nor1;\n        t = d1;\n    }\n    return t;\n    //return t<0?LARGE_NUMBER:t;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p /*到中心的距离*/, vec3 b/*立方体中心->顶点*/ )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat QueryVolumetricDistanceField( in vec3 pos)\n{\n    float sdfValue= sdBox( pos-  mBox.Position, mBox.EdgeLength);\n    return sdfValue;\n}\n\nfloat IntersectRayMarch(in vec3 rayOrigin, in vec3 rayDirection, float maxD)//用于确定物体边界\n{\n\tfloat precis = MARCH_STRIDE; //这个值太大，会导致边界判断不精确，导致Volume表面有很多曲线形的分界线\n    float D = 0.0f;\n    for(int i=0; i<MAX_SDF_DETECT_STEPS; i++ )\n    {\n\t    float dis = QueryVolumetricDistanceField( rayOrigin + rayDirection * D);\n        if( dis < precis || D > maxD ) \n            break;\n        D += dis;\n    }\n    return  D >= maxD  ? -1.0 : D;//没有碰到物体则返回-1，否则返回深度（据摄像机距离）\n}\n\nvec3 CameraOrbit(float speedRatio)//相机在轨道上旋转\n{\n    float theta = iTime * speedRatio;\n    float radius = 165.0;\n    \n    return vec3(radius * cos(theta), mCamera.Position.y + 50.0 /** sin(theta*4.0)*/, radius * sin(theta));\n}\n\nvoid SetCamera(in vec2 _uv, in float _aspectRatio, out vec3 _rayOrigin, out vec3 _rayDirection)\n{\n    float ImageWidth = mCamera.ImageHeight * _aspectRatio;\n    \n    //vec3 ImagePosition = mCamera.Position;\n    vec3 ImagePosition = CameraOrbit(0.3);\n    vec3 CameraView = mCamera.LookAt - ImagePosition;\n    float ViewLength = length(CameraView);\n    vec3 CameraViewDir = CameraView / ViewLength;\n\n    vec3 CameraRight = cross(CameraViewDir, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraViewDir);\n\n    vec3 focalPoint = ImagePosition - mCamera.FocalDistance * CameraViewDir;//焦点位置\n    \n    vec3 ImagePoint = ImagePosition;//用Image的中心点初始化成像点\n    //根据uv坐标偏移成像点\n    ImagePoint += CameraRight * (_uv.x * 2.0 - 1.0) * ImageWidth *.5;\n    ImagePoint += CameraUp * (_uv.y * 2.0 - 1.0) * mCamera.ImageHeight *.5;\n    \n    _rayOrigin = focalPoint;\n    _rayDirection = normalize(ImagePoint - focalPoint);\n}\n\nvec3 GetAmbientLight()\n{\n\treturn vec3(0.01);\n}\n\n//https://www.shadertoy.com/view/wssBR8\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetVolumeValue(vec3 pos)\n{\n    float scale = 32.0*(2.0+sin(iTime));\n    vec3 conner = mBox.Position-mBox.EdgeLength/2.0;\n    float value = texture(iChannel0, (pos-conner)/scale).x;//选取3D纹理的一部分进行采样\n    float target =  0.5+0.2 * sin(iTime);\n               \n    if(value<target||value>target+0.1)\n        value =0.0;\n    return value;\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, inout vec3 color)\n{\n    vec3 lightDirection = vec3(-1.0,1.0,-1.0);//方向光\n    float lightDistance = length(lightDirection);\n    lightDirection /= lightDistance;//normalize\n\n    vec3 lightColor = vec3(1.0,.0,.0); \n        \n    color +=  lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n    color +=  lightColor * Diffuse(normal, lightDirection, vec3(1.0));\n    \n    color += GetAmbientLight() * vec3(1.0);\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDirection)\n{\n    vec3 normal;\n    float opaqueDepth = IntersectOpaqueScene(rayOrigin, rayDirection, normal);\n\n    float MaxDepth = opaqueDepth<.0?LARGE_NUMBER:opaqueDepth;\n    //找到volume的边界(若有外部传入的模型，可以直接得到深度。这里的模型是在shader中用代码生成的，所以使用RayMarch的方式确定边界)\n    float volumeDepth = IntersectRayMarch(rayOrigin, rayDirection, MaxDepth);\n    \n\n    vec3 volumetricColor = vec3(0.0f);\n    vec3 opaqueColor = vec3(0.0f);\n    float opaqueVisiblity = 1.0f;\n\n    //从Volume的边界开始RayMarch\n    if(volumeDepth > 0.0)//若可以触碰到Volume(没有被其他物体遮挡或Volume不在这条路径上)\n    {\n        float signedDistance = .0;\n        for(int i = 0; i < MAX_VOLUME_MARCH_STEPS; i++)\n        {\n            volumeDepth += max(MARCH_STRIDE, signedDistance);//若还没有到达Volume边界，则先步进到边界处\n           // volumeDepth += MARCH_STRIDE;\n           if(volumeDepth>MaxDepth)\n               continue;\n            vec3 position = rayOrigin + volumeDepth * rayDirection;\n\n            signedDistance = QueryVolumetricDistanceField(position);\n\n\t\t\tif(signedDistance < 0.0f)//在Volume中\n            {\n                float value = GetVolumeValue(position);\n                \n                float lastVisibility = opaqueVisiblity;\n                \n                opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * value, MARCH_STRIDE);\n                \n                float absorbtion = lastVisibility - opaqueVisiblity;\n\n                volumetricColor += value * GetAmbientLight()*absorbtion*15.0;\n            }\n        }\n    }\n    if( opaqueDepth>.0 && opaqueVisiblity > ABSORPTION_CUTOFF)\n    {\n        vec3 position = rayOrigin + opaqueDepth*rayDirection;\n\t\t\n    \tvec3 reflectionDirection = reflect( rayDirection, normal);\n\n\t    CalculateLighting(position, normal, reflectionDirection, opaqueColor);\n    }\n    return min(volumetricColor, 1.0f) + opaqueVisiblity * opaqueColor;\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 GammaCorrect(vec3 color) \n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y;\n    \n    vec3 rayOrigin,rayDirection;\n    \n    SetCamera(\n        uv, aspectRatio, //输入\n        rayOrigin, rayDirection//输出\n        );\n        \n    vec3 color = Render(rayOrigin, rayDirection);\n    \n    //fragColor=vec4( color, 1.0 );\n    fragColor=vec4( GammaCorrect(clamp(color, 0.0, 1.0)), 1.0 );\n}","name":"Image","description":"","type":"image"}]}