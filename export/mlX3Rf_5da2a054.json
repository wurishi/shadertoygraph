{"ver":"0.1","info":{"id":"mlX3Rf","date":"1672155040","viewed":870,"name":"Animated Fancam","username":"MysteryPancake","description":"My first real experiment using raymarching :)","likes":14,"published":3,"flags":2,"usePreview":0,"tags":["3d","raymarching","raymarch","video","sdf","texture","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\n// From https://easings.net/\nfloat outPow(float x, float p) {\n    x = clamp(x, 0.0, 1.0);\n    return 1.0 - pow(1.0 - x, p);\n}\n\nfloat inPow(float x, float p) {\n    x = clamp(x, 0.0, 1.0);\n    return pow(x, p);\n}\n\nfloat outElastic(float x) {\n    const float c4 = (2.0 * PI) / 3.0;\n    return pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\n\nfloat stars(vec3 p, float t) {\n    float d = 9999.9;\n    for (float i = 0.0; i < 4.0; i++) {\n        vec3 offset = vec3(i * 1.4, i * 1.2, i * -0.5);\n        float grid = length(mod(p + offset, 4.0) - 2.0);\n        d = min(grid - 0.08, d);\n    }\n    return d;\n}\n\nvec2 map(vec3 p, float t) {\n    vec2 res = vec2(sdBox(p + vec3(0.0, 0.0, 0.1), vec3(0.5, 0.5, 0.05)), 1.5);\n    res = opU(res, vec2(stars(p, t), 0.5));\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 q = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float mod2 = mod(iTime, 2.0);\n    float mod4 = mod(iTime, 4.0);\n    \n    // Main camera animation\n    float xrot = 4.0 - outElastic(0.3 * mod4) * 4.0;\n    float yrot = 16.0 - outPow(mod4 * 2.0, 3.0) * 16.0\n        - inPow(mod2 - 1.0, 5.0) * 16.0;\n    float zrot = mod4 > 2.0\n        ? 8.0 - outPow(mod2, 4.0) * 8.0\n        : sin(iTime * PI) * 0.5;\n    \n    // Flip motion every 2 iterations\n    if (mod(iTime, 8.0) > 4.0) {\n        xrot *= -1.0;\n        yrot *= -1.0;\n        zrot *= -1.0;\n    }\n    \n    float fov = sin(iTime * PI) * 0.3 + 0.7;\n    vec3 ro = vec3(xrot, yrot, fov);\n    mat3 ca = setCamera(ro, vec3(0.0), zrot);\n    vec3 rd = ca * normalize(vec3(q, fov));\n\n    // Raymarching with only 20 iterations produces glow\n    vec2 h; vec3 p;\n    float t = 0.1;\n    const int iters = 20;\n    const float tmax = 22.0;\n    for (int i = 0; i < iters && t < tmax; i++) {\n        p = ro + rd * t;\n        h = map(p, iTime);\n        if (abs(h.x) < 0.001) {\n            break;\n        }\n        t += h.x;\n    }\n    \n    vec4 red = vec4(1.0, uv.y, 0.5, 1.0);\n    vec4 blu = vec4(0.0, uv.y, 1.0, 1.0);\n    float fog = min(10.0, 2.0 + 6.0 * mod2) / t;\n    vec4 color = (mod4 > 2.0 ? blu : red) * fog;\n    \n    if (h.y > 1.0) {\n        // Video\n        vec2 size = vec2(textureSize(iChannel0, 0));\n        vec2 uv = vec2(p.x * size.y / size.x, p.y);\n        fragColor = texture(iChannel0, 0.5 + uv);\n    } else {\n        // Background and stars\n        fragColor = color;\n    }\n}","name":"Image","description":"","type":"image"}]}