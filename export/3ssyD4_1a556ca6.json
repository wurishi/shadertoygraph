{"ver":"0.1","info":{"id":"3ssyD4","date":"1585035681","viewed":120,"name":"Creature's Plant","username":"takumifukasawa","description":"# references\n## sss\nhttps://www.shadertoy.com/view/wljSz1\n## tri-planner mapping\nhttps://qiita.com/edo_m18/items/c8995fe91778895c875e\nhttps://www.shadertoy.com/view/wtjGWy","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// memo:\n// it may be wrong directional light specular.\n\n#define EPS .0001\n#define NORMAL_EPS .0001\n#define PI 3.14159265359\n#define PI2 PI * 2.\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n\n#define MAT_ROOM 1.\n\n#define saturate(a) clamp(a, 0., 1.)\n#define repeat(a, b) mod(a, b) - b * .5 \n\nconst float stopThreshold = .0001;\nconst int maxShadowIterations = 32;\n\nprecision highp float;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n  \tfloat attenuation;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \t// float dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n    vec3 specularColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};  \n\n//---------------------------------------------------------------------------------------------\n// utils\n//---------------------------------------------------------------------------------------------\n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nbool checkMat(float material, float check) {\n\treturn material < (check + .5);\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rot3(float roll, float pitch, float yaw) {\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n    return mat3(\n    \tcp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n        cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n        -sp, sr * cp, cr * cp\n    );\n}\n\nvec3 hash3(vec3 p) {\n\tvec3 q = vec3(\n        dot(p, vec3(127.1, 311.7, 114.5)),\n        dot(p, vec3(269.5, 183.3, 191.9)),\n        dot(p, vec3(419.2, 371.9, 514.1))\n    );\n    return fract(sin(q) * 43758.5433);\n}\n\nvec3 rgbColor(float r, float g, float b) {\n\treturn vec3(r / 255., g / 255., b / 255.);\n}\n\n\n\n//---------------------------------------------------------------------------------------------\n// sdf\n//---------------------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 pos, float rad) {\n\treturn length(pos) - rad;\n}\n\n// ra: radius\n// rb: round\n// h: height\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;\n}\n\n// a: begin pos\n// b: begin thin\n// ra: end pos\n// rb: end thin\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float r = mix(ra, rb, h);\n\treturn length(pa - h * ba) - r;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad) {\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.) / k1;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat sdOctahedron(vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// d1 subtract to d2\nfloat opSub(float d1, float d2) {\n\treturn max(-d1, d2);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p, n.xyz) + n.w;\n}\n\n\nfloat smin(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn min(a, b) - h * h / (k * 4.);\n}\n\nfloat smax(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn max(a, b) + h * h / (k * 4.);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = atan(p.x, p.y) + PI / r;\n    float n = PI * 2. / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\n//---------------------------------------------------------------------------------------------\n// raymarch\n//---------------------------------------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n    float d = FLT_MAX;\n    float objD = 0.;\n    float m = 0.;\n    \n\tp.xz = rot(iTime * .2) * p.xz;\n    \n    // floor\n    {\n        vec3 _p = p;\n        _p -= vec3(0., -2.5, 0.);\n        float r = 100.;\n        objD = min(d, sdSphere(_p - vec3(0., -r - 2.5, 0.), r));\n    \td = min(objD, d);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;        \n    }\n    \n    // top\n    {\n        vec3 _p = p;\n        float r = 100.;\n        objD = sdSphere(_p - vec3(0., r + 2.5, 0.), r);\n        d = min(objD, d);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;\n    }\n\n    // tubes\n    {\n        vec3 _p = p;\n        float repeatNum = 4.;\n        vec3 id = vec3(0.);\n        id.xz = floor((_p.xz/* + repeatNum * .5*/) / repeatNum);\n        vec3 rnd = hash3(id);\n        _p.xz = repeat(_p.xz, repeatNum);\n        objD = sdCylinder(_p, vec3(0., 0., .2));\n        d = smin(d, objD, 1.);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;\n\n        // thick\n        vec3 sphereOffset = vec3(0., 7.5 - mod(iTime * .3 + rnd.x * 10., 1.) * 15., 0.);\n        float r = .1 + sin(iTime * 10. + rnd.z * 100.) * pow(.1, .9);\n        objD = sdSphere(_p - sphereOffset, r);\n        d = smin(d, objD, 1.4);\n        m = minMat(vec2(d, m), vec2(objD, MAT_ROOM)).y;\n    }\n    \n    return vec2(d, m);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    // raymarching\n    float tmax = 40.;\n    float depth = 0.;\n    float dist = 0.;\n    vec2 result = vec2(0.);\n    for(int i = 0; i < 99; i++) {\n    \tresult = scene(ro + rd * depth);\n        dist = result.x;\n        if(dist < stopThreshold || depth > tmax) {\n            break;\n        }\n        depth += result.x;\n    }    \n    \n    if(depth > tmax) result.y = -1.;\n    \n\treturn vec2(depth, result.y);\n}\n\n//---------------------------------------------------------------------------------------------\n// shadings\n//---------------------------------------------------------------------------------------------\n\n// ref: https://www.shadertoy.com/view/wtjGWy\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n) {\n    vec3 blending = abs(n);\n    blending = normalize(max(blending, EPS));\n    \n    float b = (blending.x + blending.y + blending.z);\n    blending /= b;\n    \n    vec4 xaxis = texture(tex, p.yz); // yz plane\n    vec4 yaxis = texture(tex, p.xz); // xz plane\n    vec4 zaxis = texture(tex, p.xy); // xy plane\n\n    return (xaxis * blending.x + yaxis * blending.y + zaxis * blending.z).rgb;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float power) {\n  float res = 1.;\n  float t = mint;\n  float ph = 1e10;\n  for(int i = 0; i < maxShadowIterations; i++) {\n    float h = scene(ro + rd * t).x;\n\n    // pattern 1\n    // res = min(res, power * h / t);\n\n    // pattern 2\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, power * d / max(0., t - y));\n    ph = h;\n\n    t += h;\n\n    float e = EPS;\n    if(res < e || t > tmax) break;\n  }\n  return clamp(res, 0., 1.);\n}\n \n\nfloat getSpecular(vec3 lightDir, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  \t// vec3 lightDir = light.position - position;\n  \tvec3 ref = reflect(-normalize(lightDir), normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - normal)));\n    \tfloat specularPower = 32.;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  \tvec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  \t// specular\n  \tfloat specularCoef = getSpecular(normalize(light.position), surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  \tlight.diffuse = diffuse/* * softShadow(surface.position, normalize(light.position), .1, 3., 5.)*/;\n    light.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \tfloat d = distance(light.position, surface.position);\n  \tvec3 k = vec3(.06, .08, .09);\n  \tlight.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  \t// point light\n  \tvec3 lightDir = light.position - surface.position;\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(lightDir)));\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  \t// specular\n  \tfloat specularCoef = getSpecular(lightDir, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  \tlight.diffuse = diffuse/* * softShadow(surface.position, normalize(light.position), .1, 3., 5.)*/;\n  \tlight.specular = specular;\n}\n\nfloat ambientOcculusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++) {\n    \tfloat h = .01 + .11 * float(i) / 4.;\n        vec3 opos = pos + h * nor;\n        float d = scene(opos).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2. * occ, 0., 1.);\n}\n\nvec3 fog(vec3 color, float dist, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-dist * b);\n  return mix(color, fogColor, fogAmount);\n}\n\n// ref: https://www.shadertoy.com/view/wljSz1\nvec4 subsurface(vec3 o, vec3 dir){\n    vec3 p = o;\n    float e = 0.0;\n    for(int i = 0; i < 7; ++i){\n        float d = scene(p).x;\n        e += -d;\n        if(d > -0.001)\n            break;\n        p -= d*dir;\n    }\n    \n    return vec4(p, e);\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos, vec3 cameraDir) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n  \tLight directionalLight;\n  \tdirectionalLight.position = vec3(.5, 0., -1.);\n  \tdirectionalLight.intensity = .5;\n  \tdirectionalLight.color = vec3(1., 1., 1.);\n  \tdirectionalLight.attenuation = 1.;\n  \tcalcDirectionalLight(directionalLight, surface, cameraPos);\n    \n  \tLight pointLight;\n  \tpointLight.position = vec3(0., -1., -0.);\n  \tpointLight.intensity = .3;\n  \tpointLight.color = vec3(.4, .8, .8);\n  \t//pointLight.attenuation = 1.;\n  \tcalcPointLight(pointLight, surface, cameraPos);\n    \n  \tvec3 diffuse = directionalLight.diffuse + pointLight.diffuse;\n  \tvec3 specular = directionalLight.specular + pointLight.specular;\n    \n\tfloat occ = ambientOcculusion(surface.position, surface.normal);\n  \tfloat amb = clamp(.5 + .5 * surface.normal.y, 0., 1.);\n  \tvec3 ambient = surface.baseColor * amb * occ * vec3(0., .08, .1);  \n    \n    // ref: https://www.shadertoy.com/view/wljSz1\n    // subsurface scattering\n    vec3 h = normalize(mix(-getNormal(surface.position), cameraDir, 0.5));\n    // sv.zyz contains outgoing position, w contains accumulate distance (path \"tightness\")\n    vec4 sv = subsurface(surface.position+h*0.02, cameraDir);\n    // subsurface magic term\n    float sss = max(0.0, 1.0-3.0*sv.w);\n    // light visibility across the volume\n    vec3 l = vec3(0.);\n    float ssha = max(0.0, dot(getNormal(sv.xyz), normalize(l-sv.xyz)));\n    // sss /= att;\n    //ssha /= att;\n    diffuse = mix(diffuse, vec3(mix(sss, ssha, 0.2)), 0.5);\n            \n  \tcolor =\n        surface.emissiveColor +\n        surface.baseColor * diffuse +\n        surface.specularColor * specular +\n        ambient;  \n  \n  \treturn color;\n}\n\n//---------------------------------------------------------------------------------------------\n// main\n//---------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(mouse * 1. + vec2(.75, -3.) + vec2(sin(iTime * .8), cos(iTime * 1.2)) * .15, 5.);\n    vec3 target = vec3(0., -2.4, 0.) + vec3(sin(iTime * .3), cos(iTime * .8), 0.) * .15;\n    float fov = .5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n\tvec2 result = raymarch(ro, rd);\n\tvec3 color = vec3(0.);\n    \n    if(result.y > 0.) {\n\t    float depth = result.x;\n    \tfloat material = result.y;    \n   \n    \tvec3 position = ro + rd * depth;\n    \tvec3 normal = getNormal(position);\n        \n\t    Surface surface;\n    \tsurface.depth = depth;\n    \tsurface.position = position;\n    \tsurface.normal = normal;\n    \tsurface.material = result.y;\n    \n    \tvec3 objColor = vec3(0.);\n\n        if(checkMat(material, MAT_ROOM)) {\n            surface.baseColor = rgbColor(100., 220., 214.);\n            vec3 _p = surface.position;\n            _p.xz = rot(iTime * .2) * _p.xz;\n            surface.baseColor *= tex3D(iChannel0, _p, surface.normal);\n        }\n        surface.specularColor = vec3(1.);\n        \n        color = lighting(surface, ro, rd);  \n    }\n\n    // fog\n    color = fog(color, result.x, vec3(.02, .02, .04), .08);\n    \n    // gamma\n    color = pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}