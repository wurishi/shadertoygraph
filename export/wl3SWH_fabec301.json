{"ver":"0.1","info":{"id":"wl3SWH","date":"1580845717","viewed":407,"name":"4deditos-verdes","username":"bitnenfer","description":"I did a weird SDF 4 finger hand yesterday. Today while waiting for my project compilation to finish I did this.\n","likes":36,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLACK_AND_WHITE 0\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = acesFilm(texture(iChannel0, uv).rgb);\n\t#if BLACK_AND_WHITE\n    fragColor = vec4(vec3(dot(color, vec3(0.2126, 0.7152, 0.07722))),1.0);\n\t#else\n    fragColor = vec4(color, 1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 300.0\n#define MIN_DIST 0.001\n#define PI 3.14159265359\n#define TAU (PI * 2.0)\n#define RAD(r) (r) * PI / 180.0\n\nstruct HitPayload\n{\n    float dist;\n    float light;\n    vec3 color;\n};\n\nconst HitPayload INVALID_PAYLOAD = HitPayload(MAX_DIST, 0.0, vec3(1.0));\n\nfloat gSeed = 0.0;\nvec2 gUV;\n\nHitPayload minPayload(HitPayload a, HitPayload b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n + gSeed)*43758.5453);\n}\n\nfloat random() {\n\n    return hash(fract(sin(dot(gUV, vec2(12.9898, 78.233)) * (gSeed += 1.0)) * 43758.5453));\n}\n\nvec3 randomHemispherePoint()\n{\n    float theta = random() * (PI*2.0);\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\n// Stolen from iq >:D\nvec3 cosineDirection()\n{\n    float u = random();\n    float v = random();\n\n    // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize(vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nmat2 rot(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat palm(vec3 p)\n{\n    p.x += p.x * 0.3;\n    p.yz *= rot(0.3);\n    p.xy *= rot(-p.x * 0.07);\n    p.zy *= rot(p.x * 0.01);\n    float topPalm = sdRoundedCylinder(p + vec3(0.0, 0.7, -3.9), 3.0, 1.5, 0.1);\n    return topPalm;\n}\n\nfloat finger3(vec3 p, float len, float r)\n{\n    float d = MAX_DIST;\n    float rotation = -0.01;\n    for (int i = 0; i < 3; ++i)\n    {\n        p.yz *= rot(rotation);\n        p.z += len;\n        float dd = sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, len), 1.0);\n        d = smin(d, dd, 0.4);\n        rotation += r;\n    }\n    return d;\n}\n\nfloat fingers(vec3 p)\n{\n    vec3 pd1 = p;\n    vec3 pd2 = p - vec3(2.5, 0.0, -0.5);\n    vec3 pd3 = p + vec3(2.5, 0.8, 1.0);\n    vec3 pd4 = p - vec3(2.5, -2.5, 3.6);\n    \n    pd2.xz *= rot(0.1);\n    pd3.xz *= rot(-0.3);\n    pd4.xy *= rot(-2.1);\n    pd4.yz *= rot(1.0);\n    \n    float right = finger3(pd2, 3.1, -0.08);    \n    float middle = finger3(pd1, 3.2, -0.6);\n    float left = finger3(pd3, 2.5, -0.8);\n    float thumb = finger3(pd4, 2.8, -0.4);\n    \n    return min(min(min(right, middle), left), thumb);\n}\n\nfloat hand(vec3 p, float thickAdded)\n{\n    float pl = (palm(p) - thickAdded) * 0.7;\n    float fing = fingers(p + vec3(0.0, 0.4, 0.0));\n    \n    pl = smin(pl, fing, 1.0);\n    \n    return pl;\n}\n\nvec3 tpm(vec3 p, vec3 n)\n{\n    float sc = 0.1;\n    vec3 colX = texture(iChannel1, p.zy * sc).rgb;\n    vec3 colY = texture(iChannel1, p.xz * sc).rgb;\n    vec3 colZ = texture(iChannel1, p.xy * sc).rgb;\n    vec3 bw = abs(n);\n    bw = bw / (bw.x + bw.y + bw.z);\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\nHitPayload map(vec3 p)\n{\n    vec3 h1p = p;\n    vec3 h2p = p;\n    \n    h1p.z -= 7.5;\n    h1p.x -= 9.0;\n    h1p.xy *= rot(RAD(-30.0));\n    h1p.xz *= rot(RAD(-90.0));\n    \n    h2p.x += 10.0;\n    h2p.y -= 11.0;\n    h2p.xy *= rot(RAD(-30.0));\n    h2p.xz *= rot(RAD(90.0));\n\n    float h1 = hand(h1p, 0.27);\n    float h2 = hand(h2p, 0.0);\n    \n    float scene =  min(h1, h2);    \n\n    float arm1 = sdEllipsoid(p + vec3(35.0, -12.0, 0.0), vec3(20.0, 3.0, 3.0));\n    vec3 arm2p = p - vec3(30.0, -10.5, 7.5);\n    arm2p.xy *= rot(RAD(-14.0));\n    float arm2 = sdEllipsoid(arm2p, vec3(20.0, 2.8, 4.5));\n\n    scene = smin(scene, arm1, 1.0);\n    scene = smin(scene, arm2, 1.0);\n\t\n    HitPayload scenePayload = HitPayload(scene , 0.0, vec3(0.3, 0.4, 0.2));\n    HitPayload lightPayload = HitPayload(length(p + vec3(-30.7, -100.7, 46.4)) - 50.0, 1.0, vec3(8.0, 8.0, 10.0) * 0.6);\n    \n    return minPayload(scenePayload, lightPayload);\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.0, MIN_DIST);\n    return normalize(vec3(\n        map(p + e.yxx).dist - map(p - e.yxx).dist,\n        map(p + e.xyx).dist - map(p - e.xyx).dist,\n        map(p + e.xxy).dist - map(p - e.xxy).dist\n    ));\n}\n\nHitPayload raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    HitPayload payload = INVALID_PAYLOAD;\n    \n    for (int i = 0; i < 100; ++i)\n    {\n        payload = map(ro + rd * t);\n        t += payload.dist * 0.7;\n        if (payload.dist < MIN_DIST ||t > MAX_DIST)\n            break;\n    }\n    payload.dist = t;\n    return payload;\n}\n\n#define BOUNCE_COUNT 3\n#define DEBUG 0\n#define MOUSE_RETRACE 1\n\nvec3 trace(vec2 uv)\n{\n    vec3 accum = vec3(0.0);\n    vec3 co = vec3(0.0);\n    vec3 ro = vec3(-1.0, 2.4, -100.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 7.2));\n    float atten = 1.0;\n    \n    #if DEBUG\n    float mx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14;\n    #else\n    float mx = RAD(130.0) + 0.1;\n    #endif\n    rd.xz *= rot(mx);\n    ro.xz *= rot(mx);\n    \n    // diffuse\n    #if 1\n    vec3 dro = ro;\n    vec3 drd = rd;\n    for (int i = 0; i < BOUNCE_COUNT; ++i)\n    {\n        HitPayload payload = raymarch(dro, drd);\n        if (payload.dist < MAX_DIST && payload.light < 0.5)\n        {\n            vec3 p = dro + drd * payload.dist;\n            vec3 n = norm(p);\n            #if DEBUG\n            return n;\n            #endif\n            vec3 t = tpm(p, n);\n            accum = (payload.color * clamp(t.r, 0.6, 1.0)) * atten;\n            drd = n + cosineDirection() * 0.7;\n            dro = p + drd * 0.1;\n            atten *= 0.45;\n        }\n        if (payload.light > 0.0)\n        {\n            co += accum * payload.color;\n            break;\n        }\n    }\n    #endif\n        \n    #if 1\n    vec3 sro = ro;\n    vec3 srd = rd;\n    atten = 1.0;\n    for (int i = 0; i < BOUNCE_COUNT; ++i)\n    {\n        HitPayload payload = raymarch(sro, srd);\n        if (payload.dist < MAX_DIST && payload.light < 0.5)\n        {\n            vec3 p = sro + srd * payload.dist;\n            vec3 n = norm(p);\n            accum = payload.color * vec3(1.0, 0.3, 0.1) * atten;\n            srd = normalize(refract(srd, n, 1.0)) + cosineDirection() * 1.5;\n            sro = p + srd * 0.2;\n            atten *= 0.45;\n        }\n        if (payload.light > 0.0)\n        {\n            co += accum * payload.color;\n            break;\n        }\n    }\n    #endif\n    \n    return co;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * ar;\n\n    gSeed = iTime;\n    gUV = uv;\n\n    vec4 prev = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    float ss = 0.96;\n    vec2 offsetSize = 4.0 / iResolution.xy;\n    vec2 jitter = vec2(random(), random()) * offsetSize;\n        \n   \t#if MOUSE_RETRACE\n    float iframe = mix(prev.a, 0.0, clamp(iMouse.z, 0.0, 1.0));\n    {\n        ss += mix(0.00, 0.1, clamp(iframe / 400.0, 0.0, 1.0));\n        ss = clamp(ss, 0.0, 0.999);\n    }\n    \n    #if DEBUG\n    fragColor = vec4(trace(uv), 1.0);\n    #else\n    fragColor = vec4(mix(trace(uv + jitter), prev.rgb, mix(ss, 0.0, clamp(iMouse.z, 0.0, 1.0))), iframe + 1.0);\n    #endif\n    #else\n    ss += mix(0.00, 0.1, clamp(float(iFrame) / 400.0, 0.0, 1.0));\n    ss = clamp(ss, 0.0, 0.999);\n    \n    #if DEBUG\n    fragColor = vec4(trace(uv), 1.0);\n    #else\n    fragColor = vec4(mix(trace(uv + jitter), prev.rgb, ss), 1.0);\n    #endif\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}