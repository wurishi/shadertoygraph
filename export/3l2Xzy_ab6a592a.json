{"ver":"0.1","info":{"id":"3l2Xzy","date":"1566304645","viewed":483,"name":"Fast sin and random without sin","username":"alenwesker","description":"Sin only faster in mobile devices, and good for avoiding metal pre-z flickering when using fast math","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","sin","random","sine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.14159265359\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n#define float2 vec2\n#define fmod mod\n#define saturate(x) clamp(x, 0.0f, 1.0f)\n#define frac fract\n\n\n/*\nIf you are using HLSL, which fmod differs from GLSL, https://stackoverflow.com/questions/7610631/glsl-mod-vs-hlsl-fmod\nTurn fmod to x - floor(x / y) * y;\n*/\n\nfloat FastSinV4(float x) //Only faster in mobile devices, and good for avoiding metal pre-z flickering when using fast math\n{\n\tfloat zeroTo2PI = fmod(x, TWO_PI); //move to range 0-2pi\n\n    //This calculation is achieved by Desmo; Combination of two saturated quadratic curve\n    float2 core = float2(zeroTo2PI, zeroTo2PI) + float2(-HALF_PI, -PI-HALF_PI);\n    float2 corePower2 = core * core;\n    float2 result2 = saturate(corePower2 * (-1.0f / (HALF_PI * HALF_PI)) + float2(1.0f,1.0f));\n    return result2.x - result2.y;\n}//Deprecated, V5 is better\n\nfloat FastSinV5(float x) //Only faster in mobile devices, and good for avoiding metal pre-z flickering when using fast math\n{\n    //Base on v4, and try to optimize the instruction number a little\n\tfloat zeroTo2PI = fmod(x, TWO_PI); //move to range 0-2pi\n\n    //This calculation is achieved by Desmo; Only 3 instructions !!!\n    float2 core = float2(zeroTo2PI, zeroTo2PI) * (1.0f / HALF_PI)  + float2(-1.0f, -3.0f);\n    float2 result2 = saturate(-core * core + float2(1.0f, 1.0f));\n    return result2.x - result2.y;\n}\n\n//  1 out, 2 in... //This one is also workable\nfloat hash12(vec2 p)  //from Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Rand2Dto1_V5(float2 remain) { \n\tfloat dotResult = dot(remain, float2(12.9898, 78.233));\n\treturn frac(FastSinV5(dotResult) * 43758.5453); // This value is achieved by testing\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\t#if 1    \n    float value = Rand2Dto1_V5(uv);\n    #else\n    float v = 400.0;  //A ralatively big number is needed\n    vec2 pos = (uv * v + 50.0);\n    float value = hash12(pos);  \n    #endif\n    \n    vec3 col = vec3(value, value, value);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}