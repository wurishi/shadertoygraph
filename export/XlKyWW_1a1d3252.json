{"ver":"0.1","info":{"id":"XlKyWW","date":"1536266244","viewed":140,"name":"Raycast Graphics","username":"tague","description":"Raycasting (wolfenstein-style, but working my way toward implementing doom-style varying height walls and maybe even floors) renderer.\n\nSee \"Common\" for an explanation of how this whole thing works, in a large comment right at the bottom.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Main shader\n\n   Takes per-column input from Buffer A shader and draws out the vertical walls using\n   the given raycasting data.\n\n   Copyright (C) 2018 Ethan McTague\n   Usage and adaptation is permitted under all circumstances.\n */\n\n#define D_MIN_Y data.g\n#define D_MAX_Y data.b\n#define D_HEIGHT data.a\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (uv.y < 0.5) fragColor = vec4 (0.5, 0.6, 0.8, 1.0) + (1.0 - uv.y) * 0.2;\n    else fragColor = vec4 (0.9, 0.95, 1.0, 1.0) + uv.y * 0.005;\n    \n    for (int j = checkRowCount - 1; j >= 0; j--) {\n        vec4 data = texture(iChannel1, vec2(uv.x, float(j) / iResolution.y));    \n        int i = int(data.r) - 1;    \n        if (i != -1 && uv.y > D_MIN_Y && uv.y < D_MAX_Y) {\n            // If a wall should be drawn at this location, draw it (with a slight lightness gradient)\n            fragColor = vec4 (lines[i].color + D_HEIGHT, 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Raycasting data shader\n\n   This buffer is used to perform calculations on a per-column basis.\n\n   The first row of the output represents what wall is visible in each column.\n   Numerous rows are rendered in this format, each with information on the nth-nearest\n   wall to allow for taller walls to 'peek out' behind nearer ones.\n\n   The output for each column consists of:\n\n   - r: i - wall index + 1 (0 = no wall)\n   - g: minY - the bottom UV coordinate at which this wall starts\n   - b: maxY - the top UV coordinate at which this wall ends\n   - a: height - Represents the unscaled height of the wall, used for some shading\n\n   Copyright (C) 2018 Ethan McTague\n   Usage and adaptation is permitted under all circumstances.\n */\n\n// Vec2 -> float Cross Product\nfloat v2cross (vec2 a, vec2 b) {\n    return a.x * b.y - b.x * a.y;\n}\n\n// The result from the the lsi function call\nstruct lsiResult {\n    bool intersects;\n    vec2 intersection;\n};\n\n/* Line Segment Intersection\n   Checks if two line segments intersect, and gives the intersection point if they do.\n   Based off of an article I found online, and heavily adapted to work in GLSL, with parts\n   cut out and optimized for my purposes. I cannot find the original article again :(\n */\nlsiResult lsi(line p, line q)\n{\n    vec2 r = p.second - p.first;\n    vec2 s = q.second - q.first;\n    float rxs = v2cross(r, s);\n\n    // skip out colinear or parallel lines\n    if (abs(rxs) < 0.00001) return lsiResult (false, vec2(0));\n\n    float t = v2cross((q.first - p.first), s) / rxs;\n    float u = v2cross((q.first - p.first), r) / rxs;\n    \n    if (0.0f <= t && t <= 1.0f && 0.0f <= u && u <= 1.0f)\n    {\n        return lsiResult(true, p.first + t * r);\n    }\n\n    return lsiResult (false, vec2(0));\n}\n\n// Calculate line collisions\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Number of overlapping walls to check for\n\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4 (0);\n    \n    int rowNum = int(fragCoord.y);\n    \n    // Only perform complicated calculations on the first row or so\n    if (rowNum < checkRowCount) {\n        vec2 offset = vec2(cos(iTime) * 0.15f, sin(iTime) * 10.0f);\n        line lray = line(vec2 (uv.x - .5, 100.0f) + offset, offset, 0.0f, 0.0f, vec3 (0));\n        float minDepths[checkRowCount];\n        int minWalls[checkRowCount];\n       \t\n        for (int i = 0; i < checkRowCount; i++) minDepths[i] = lray.first.y;\n\t\tfor (int i = 0; i < checkRowCount; i++) minWalls[i] = -1;\n        \n        // Check each wall and see if it collides at this column\n        for (int i = 0; i < lineCount; i++) {\n            lsiResult l = lsi(lines[i], lray);\n\n            if (l.intersects) {\n                float d = distance(l.intersection, offset) / lray.first.y;        \n\t\t\t\tint insertBefore = -1;\n                \n                for (int i = 0; i < checkRowCount; i++) {\n                    if (d < minDepths[i]) {\n                        insertBefore = i;\n                        break;\n                    }\n                }\n                \n                if (insertBefore != -1) {\n                    for (int j = checkRowCount - 1; j > insertBefore; j--) minDepths[j] = minDepths[j - 1];\n                    minDepths[insertBefore] = d;\n                    for (int j = checkRowCount - 1; j > insertBefore; j--) minWalls[j] = minWalls[j - 1];\n                    minWalls[insertBefore] = i;\n                }\n            }\n        }\n        \n        if (minWalls[rowNum] != -1) {\n            int i = minWalls[rowNum];\n            float d = minDepths[rowNum];\n            \n            float height = 1.0f - d;\n            float offset = d / 2.0f;\n            float minY = offset + lines[i].z;\n            float maxY = ((1.0 - offset) * lines[i].height + lines[i].z);\n\n            fragColor = vec4 (float(i + 1), minY, maxY, height);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* Common data shader for raycasting graphics\n   Defines any data that is shared between shaders in this project\n\n   Copyright (C) 2018 Ethan McTague\n   Usage and adaptation is permitted under all circumstances.\n */\n\n// Implements the line that represents a given wall\nstruct line {\n    vec2 first;   // 2D line segment point 1\n    vec2 second;  // 2D line segment point 2\n    float z;      // Wall Z position\n    float height; // Wall height multiplier (extends upward only)\n    vec3 color;   // Wall color\n};\n\nconst int lineCount = 5;\n\n// The list of lines in the scene - Update lineCount whenever a line is added or removed\nline lines[lineCount] = line[] (\n    line(vec2 (-.1, 40.0f), vec2 (0, 45.0f), 0.0f, 0.95f, vec3 (0.3, 0.2, 0.4)),\n    line(vec2 (-.1, 50.0f), vec2 (.1, 50.0f), 0.0f, 1.1f, vec3 (0.2, 0.3, 0.2)),\n    line(vec2 (-.5, 70.0f), vec2 (-.2, 70.0f), 0.0f, 1.0f, vec3 (0.2, 0.2, 0.5)),\n    line(vec2 (-.22, 60.0f), vec2 (0.2, 55.0f), 0.0f, 1.3f, vec3 (0.2, 0.2, 0.5)),\n    line(vec2 (0.15, 65.0f), vec2 (1.0, 67.0f), 0.0f, 0.8f, vec3 (0.2, 0.2, 0.5))\n);\n\n// Number of overlapping walls to check for\nconst int checkRowCount = 3;\n\n\n/*\n\nExplanation\n===========\n\nThis project was built in a few hours simply to see if I could implement a rudimentary\nraycasting-based rendering engine. I used several online sources to find information on\nline-segment intersection mathematics, and some of my code is very loosely based off of it,\nbut all of the source code in this project is unique and I worked out everything else on my\nown.\n\n\nFeatures\n--------\n\nIn its current state, the renderer supports:\n  - Basic, wolfenstein-esque 3D raycast walls projected from 2D lines\n  - Walls with varying heights and Z-positions\n  - Colored walls (no alpha channel)\n  - Slight color gradient where walls darken slightly as they move away from the camera\n\nThe renderer lacks support for these important features:\n  - Sane camera translation (moving forward/backward causes strange FOV change)\n  - Camera rotation\n  - Doom-style floors and cielings\n  - Projecting textures onto walls\n  - Wolfenstein-esque 2D sprites within the scene\n\n\nHow Raycasting Graphics Works\n-----------------------------\n\nRaycasting graphics are a rather simple way of rendering perspective-correct walls in\na scene. Essentially, for each column of pixels on the screen there is a 'ray' that\nextends outward from the camera's position at an angle.\n\nWalls in the scene are represented as a line segment in a 2D world, and when a ray is\nfound to intersect with one or more of these lines, the nearest one is chosen as the wall\nto display in that column.\n\nFrom there, an illusion of perspective can be created by reducing the height of these walls\nthe further away from the camera point they are. For example, of the distance to the camera\nis 0 and the wall's height is set to 1, the wall will occupy the entire screen. If the distance\nis 0.5, we multiply the height by one minus that distance (1 - 0.5 = 0.5), getting the new\nperspective-correct height of the wall.\n\nShifting wall Z-positions and varying wall heights can be accomplished by simply offsetting\nthe edges of the wall and by multiplying this height value, a rather simple task.\n\n\nOptimizations\n-------------\n\nRaycasting calculations are moderately expensive, becoming more so with an increasing number of\nwalls to check. Since raycasting results are consistent for every pixel in a given column of the\nscreen, we can optimize this process by performing all perspective-related calculations in a separate\nshader which operates only across each row of the scene. Then, each pixel of the final shader can\nsample a single pixel from a single row of that first shader to retrieve this expensive information,\navoiding repetition of costly calculations.\n\nUnfortunately, this alone would result in walls becoming invisible when behind other walls, even\nif they are significantly taller. As a solution, we calculate a specific number of raycast-data rows,\neach one supplying data for the `n`th nearest wall, and then layer these over top of one another. \n\n*/","name":"Common","description":"","type":"common"}]}