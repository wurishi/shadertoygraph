{"ver":"0.1","info":{"id":"XtXfDS","date":"1513124981","viewed":3530,"name":"Flows along conic sections","username":"Reedbeta","description":"Any conic section is mapped to itself by a one-parameter family of affine transformations.","likes":27,"published":3,"flags":0,"usePreview":0,"tags":["procedural","2d","grid","math","conic","diagram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvoid renderCircle(float r, vec2 pos, inout vec3 fragColor)\n{\n    float sdist = length(pos) - r;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderCirclePoints(float bigR, float littleR, mat2 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    int numCircles = 20;\n    for (int i = 0; i < numCircles; ++i)\n    {\n        float theta = float(i) / float(numCircles) * (2.0 * 3.141592654);\n        vec2 center = xfm * (bigR * vec2(cos(theta), sin(theta)));\n        float sdist = length(pos - center) - littleR;\n        sdistMin = min(sdistMin, sdist);\n    }\n    \n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid renderEllipse(float rx, float ry, vec2 pos, inout vec3 fragColor)\n{\n    // TODO: more accurate distance to ellipse function\n    float sdist = length(vec2(pos.x * ry/rx, pos.y)) - ry;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderEllipsePoints(float rx, float ry, float littleR, mat2 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    int numCircles = 20;\n    for (int i = 0; i < numCircles; ++i)\n    {\n        float theta = float(i) / float(numCircles) * (2.0 * 3.141592654);\n        vec2 center = xfm * vec2(rx * cos(theta), ry * sin(theta));\n        float sdist = length(pos - center) - littleR;\n        sdistMin = min(sdistMin, sdist);\n    }\n    \n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid renderHyperbolas(float r, vec2 pos, inout vec3 fragColor)\n{\n    // TODO: more accurate distance to hyperbola function\n    float sdist = sqrt(abs(pos.y*pos.y - pos.x*pos.x)) - r;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderHyperbolaPoints(float bigR, float littleR, mat2 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    for (int q = 0; q < 4; ++q)\n    {\n        float qx = float(abs(q - 2) - 1); // 1, 0, -1, 0\n        float qy = float(1 - abs(q - 1)); // 0, 1, 0, -1\n        vec2 qvec = vec2(qx, qy);\n        vec2 qvec2 = ortho(qvec);\n\n        int numCircles = 15;\n        for (int i = -numCircles/2; i <= numCircles/2; ++i)\n        {\n            float omega = float(i) / float(numCircles/2) * 2.2;\n            vec2 center = bigR * vec2(cosh(omega), sinh(omega));\n            center = xfm * (center.x * qvec + center.y * qvec2);\n            float sdist = length(pos - center) - littleR;\n            sdistMin = min(sdistMin, sdist);\n        }\n    }\n\n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid renderParabola(float b, vec2 pos, inout vec3 fragColor)\n{\n    // TODO: more accurate distance to parabola function\n    float sdist = pos.y - pos.x*pos.x - b;\n    stroke(sdist, vec3(0,0.5,1), fragColor, 0.01, length(fwidth(pos)));\n}\n\nvoid renderParabolaPoints(float b, float littleR, mat3 xfm, vec2 pos, inout vec3 fragColor)\n{\n    float sdistMin = 1e10;\n    \n    int numCircles = 31;\n    for (int i = -numCircles/2; i <= numCircles/2; ++i)\n    {\n        float x = float(i) / float(numCircles/2) * 1.7;\n        vec2 center = vec2(x, x*x + b);\n        center = (xfm * vec3(center, 1)).xy;\n        float sdist = length(pos - center) - littleR;\n        sdistMin = min(sdistMin, sdist);\n    }\n    \n    vec3 dotColor = vec3(sin(pos.x)*0.6+0.3, sin(pos.y)*0.8+0.4, 1);\n    fill(sdistMin, dotColor, fragColor, length(fwidth(pos)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = ((fragCoord / iResolution.xy) - 0.5) * vec2(aspect, 1.0) * 1.2;\n    vec2 posOrig = pos;\n\n    int conic = int(iTime / 20.0) % 4;\n    float timeConic = mod(iTime, 20.0);\n    float fade = smoothstep(0.0, 0.5, timeConic) * smoothstep(20.0, 19.5, timeConic);\n\n    float ellipseAspect = 0.8 / 0.5;\n    mat2 xfm, xfmInv;\n    mat3 xfm3, xfm3Inv;\n    \n    // TODO: mouse control?\n\n    switch (conic)\n    {\n        case 0:\n        {\n            // (circle) rotate the coordinates\n            float theta = iTime * 0.2;\n            float cosTheta = cos(theta), sinTheta = sin(theta);\n            xfm = mat2(cosTheta, -sinTheta, sinTheta, cosTheta);\n            xfmInv = inverse(xfm);\n            pos = xfm * pos;\n            break;\n        }\n\n        case 1:\n        {\n            // (ellipse) scale, rotate, unscale the coordinates\n            float theta = iTime * 0.3;\n            float cosTheta = cos(theta), sinTheta = sin(theta);\n            xfm = mat2(cosTheta, -sinTheta / ellipseAspect, sinTheta * ellipseAspect, cosTheta);\n            xfmInv = inverse(xfm);\n            pos = xfm * pos;\n\t\t\tbreak;\n        }\n    \n\t\tcase 2:\n        {\n            // (parabola) shear and translate the coordinates\n            float k = 1.5 * sin(iTime * 0.3);\n            xfm3 = mat3(1, k, 0, 0, 1, 0, 0.5*k, 0.25*k*k, 1);\n            xfm3Inv = inverse(xfm3);\n            pos = (xfm3 * vec3(pos, 1)).xy;\n            break;\n        }\n\n        case 3:\n        {\n            // (hyperbolas) apply Lorentz transform\n            float omega = 1.3 * sin(iTime * 0.3);\n            float coshOmega = cosh(omega), sinhOmega = sinh(omega);\n            xfm = mat2(coshOmega, sinhOmega, sinhOmega, coshOmega);\n            xfmInv = inverse(xfm);\n            pos = xfm * pos;\n            break;\n        }\n    }\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n    renderAxes(vec2(0), pos, fragColor.rgb);\n\n    switch (conic)\n    {\n        case 0:\n            renderCircle(0.5, posOrig, fragColor.rgb);\n            renderCirclePoints(0.5, 0.015, xfmInv, posOrig, fragColor.rgb);\n        \tbreak;\n\n        case 1:\n            renderEllipse(0.5 * ellipseAspect, 0.5, posOrig, fragColor.rgb);\n            renderEllipsePoints(0.5 * ellipseAspect, 0.5, 0.015, xfmInv, posOrig, fragColor.rgb);\n        \tbreak;\n\n        case 2:\n            renderParabola(-0.5, posOrig, fragColor.rgb);\n            renderParabolaPoints(-0.5, 0.015, xfm3Inv, posOrig, fragColor.rgb);\n        \tbreak;\n\n        case 3:\n            renderHyperbolas(0.4, posOrig, fragColor.rgb);\n            renderHyperbolaPoints(0.4, 0.015, xfmInv, posOrig, fragColor.rgb);\n        \tbreak;\n    }\n    \n    fragColor.rgb *= fade;\n}\n","name":"Image","description":"","type":"image"}]}