{"ver":"0.1","info":{"id":"4dXyD8","date":"1487856388","viewed":156,"name":"Sphere shadow","username":"miffy","description":"raytracing shadow","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @param x....radian around x-axis\n// @param y....radian around y-axis\n// @param z....radian around z-axis\n//from https://www.shadertoy.com/view/XdlGzn\nmat4 rotate( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x, y, z, 1.0 );\n}\n//from https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\n//ray and triangle hit test\n// @param orig...origin of ray\n// @param dir...ray direction\n// @param a,b,c....triangle vertices\n// @return u,v,t\nbool hit(vec3 orig,vec3 dir,vec3 a,vec3 b,vec3 c,out vec3 uvt){\n   float eps= 0.0000001;\n   vec3 ab=b-a;\n   vec3 ac=c-a;\n   \n   vec3 n=cross(dir,ac);\n\n   float det=dot(ab,n);\n   // if the determinant is negative the triangle is backfacing\n   // if the determinant is close to 0, the ray misses the triangl\n   if(det<=eps){ return false;}\n   \n   vec3 ao=orig-a;\n   float u=dot(ao,n)/det;\n   if(u<0.0 || u>1.0){ return false;}\n    \n   vec3 e=cross(ao,ab);\n   float v=dot(dir,e)/det;\n   if(v<0.0||u+v>1.0){ return false;}\n\n   float t= dot(ac,e)/det;\n   uvt = vec3(u,v,t);\n   return true;\n}\n//hit ray sphere test\nbool hitSphere(vec3 orig,vec3 dir,vec3 center,float r,out vec3 intersect){\n    vec3 oc = orig - center;\n    float b = dot(oc,dir);\n    float c = dot(oc,oc) - r * r;\n    if(c>0.0 && b > 0.0) return false;\n    float discriminant = b*b -c;\n    if(discriminant < 0.0) return false;\n    float t= -b-sqrt(discriminant);\n    if(t<0.0) return false;\n    intersect = orig + t*dir;\n    return true;  \n}\nstruct Triangle\n{\n    vec4 a; vec2 aUV;\n    vec4 b; vec2 bUV;\n    vec4 c; vec2 cUV;\n    vec4 n;//normal\n};\nstruct Sphere{\n    vec3 center;\n    float radius;\n};\nTriangle triangles[2];\nSphere lightSource;\nSphere sphere;\nvoid createFloor( void )\n{\n    vec4 verts[8];\n\tfloat size = 5.0;\n    verts[0] = vec4( -size, -1.0, -size ,1.0);\n    verts[1] = vec4( -size, -1.0,  size ,1.0);\n    verts[2] = vec4(  size, -1.0,  size ,1.0);\n    verts[3] = vec4(  size, -1.0, -size ,1.0);\n\n    triangles[0].a = verts[0]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = verts[1]; triangles[0].bUV = vec2(0.0,3.0);\n    triangles[0].c = verts[3]; triangles[0].cUV = vec2(3.0,0.0);\n    triangles[0].n = vec4( 0.0, 1.0, 0.0 ,0.0);\n    triangles[1].a = verts[1]; triangles[1].aUV = vec2(0.0,3.0);\n    triangles[1].b = verts[2]; triangles[1].bUV = vec2(3.0,3.0);\n    triangles[1].c = verts[3]; triangles[1].cUV = vec2(3.0,0.0);\n    triangles[1].n = vec4( 0.0, 1.0, 0.0 ,0.0);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.8*iTime;\n    mat4 mv = translate(0.0,0.0,-7.0)\n        *rotate(3.14*0.15,0.0,0.0)\n       *rotate(0.0,0.4,0.0);\n    \n    createFloor();\n    lightSource.radius = 0.1;\n    lightSource.center = (mv*vec4(2.5*sin(time),1.5,2.5*cos(time),1.0)).xyz;\n    vec4 origin = mv*vec4(0.0,-1.0,0.0,1.0);\n    vec3 lightdir = normalize(lightSource.center-origin.xyz);\n    sphere.center=(mv*vec4(0.0,0.0,0.0,1.0)).xyz;\n    sphere.radius = 0.8;\n\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    //triangle verts\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //z position of near clipping plane\n    float near=0.2;\n    vec3 p= vec3(uv*2.0-1.0,near);\n    //considering aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n    //calc ray direction\n    vec3 camera = vec3(0.0,0.0,5.0);\n    vec3 dir = p-camera;\n\tdir = normalize(dir);\n\n\n    // clear zbuffer\n    float mindist = -10000000.0;\n   \n    vec3 intersect;\n    bool isHit = hitSphere(camera,dir,sphere.center,sphere.radius,intersect);\n\n    if(isHit)\n    {\n        if( intersect.z > mindist )\n        {\n            mindist = intersect.z;\n        }\n        vec3 normal = intersect-sphere.center;\n        normal = normalize(normal);\n        //lambertian\n        float diffuse = dot(lightdir,normal);\n        color = vec4(165.0,217.0,221.0,255.0)/vec4(255.0,255.0,255.0,255.0);\n        color.rgb = diffuse*color.rgb;\n    }\n     //draw light source\n    isHit = hitSphere(camera,dir,lightSource.center,lightSource.radius,intersect);\n\n    if(isHit && intersect.z > mindist)\n    {\n        mindist = intersect.z;\n        color= vec4(1.0,1.0,1.0,1.0);\n    }\n    //each triangle in scene\n    for(int i=0;i<2;i++){\n        vec4 a=triangles[i].a;\n        vec4 b=triangles[i].b;\n        vec4 c=triangles[i].c;\n        vec4 n=triangles[i].n;\n\n        \n        vec4 ra = mv*a;\n        vec4 rb = mv*b;\n        vec4 rc = mv*c;\n        vec4 rn = mv*n;\n\n        vec3 uvt;\n        bool isHit =hit(camera,dir,ra.xyz,rb.xyz,rc.xyz,uvt);\n        if(isHit)\n        {\n            vec3 intersect = camera + dir*uvt.z;\n            float z = intersect.z;\n            // depth  buffer test\n\t\t\tif( z > mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n                //lambertian\n                float diffuse = dot(lightdir,rn.xyz);\n                vec3 mate = texture( iChannel0, uv ).xyz;\n                color = vec4(mate,1.0);\n                color.rgb = diffuse*color.rgb;\n               \n                //shadow on floor test\n                \n                //hit point to light vector\n                vec3 shadowray = lightSource.center - intersect;\n               \tshadowray = normalize(shadowray);\n                \n                vec3 uvt;\n                //is shadow ray hits sphere?\n                bool isOccluded = hitSphere(intersect,shadowray,sphere.center,sphere.radius,uvt);\n                if(isOccluded){\n                    color.rgb *= 0.5;\n                }\n                \n\t\t\t}\n        }\n    }//end i loop\n   \n    fragColor = color;\n}\n//reference from https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/ligth-and-shadows","name":"Image","description":"","type":"image"}]}