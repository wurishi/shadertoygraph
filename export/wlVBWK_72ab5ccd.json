{"ver":"0.1","info":{"id":"wlVBWK","date":"1615104197","viewed":112,"name":"Blur Experiment - 2 GaussianBlur","username":"Learner_CC","description":"KernelRadius : Control the size of matrix\nTheta : Key para in gaussian formula\nPixelOffsetStep : the step length of pixeloffset","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blur2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define KernelRadius 5\n#define Theta 5.0\n#define PixelOffsetStep 2.5\n\nvec3 GetTexture(vec2 uv) {\n    float boundarylimit =  step(0.0, uv.x) * step(0.0, uv.y) * step(uv.x, 1.0) * step(uv.y, 1.0);\n    return texture(iChannel0, uv).rgb * boundarylimit;\n}\n\nfloat GetGaussKernel(float x, float theta) {\n    float expPara = -(x * x) / (2.0 * theta * theta);\n    return 1.0 / (sqrt(2.0 * PI) * theta) * exp(expPara);\n}\n\nvec3 GaussBlur(vec2 fragCoord) {\n    vec3 result = vec3(0.0);\n    // -------- Caculate kernel -------- // \n    float kernel[KernelRadius];\n    for (int i = 0; i < KernelRadius; i++) {\n        kernel[i] = GetGaussKernel(float(i), 5.0);\n    }\n    float account = kernel[0] / 2.0;\n    for (int i = 1; i < KernelRadius; i++) {\n        account += kernel[i];\n    } \n    account *= 2.0;   \n    // -------- Get Texture -------- //\n    for (int i = 0; i < 2 * KernelRadius - 1; i++) {\n        for (int j = 0; j < 2 * KernelRadius - 1; j++) {\n            int pixeloffset_X = i - KernelRadius + 1;\n            int pixeloffset_Y = j - KernelRadius + 1;\n            vec2 pixelPosition = vec2(float(pixeloffset_X) * PixelOffsetStep + fragCoord.x, float(pixeloffset_Y) * PixelOffsetStep + fragCoord.y);\n            vec2 uv =  pixelPosition / iResolution.xy;\n            \n            float weight = kernel[abs(pixeloffset_X)] * kernel[abs(pixeloffset_Y)] / (account * account);\n            result += GetTexture(uv) * weight;\n        }\n    }\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color = vec4(GaussBlur(fragCoord.xy), 1.0);\n    fragColor = color; \n}","name":"Image","description":"","type":"image"}]}