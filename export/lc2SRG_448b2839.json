{"ver":"0.1","info":{"id":"lc2SRG","date":"1714452893","viewed":46,"name":"Raytraced PBR of heightmap","username":"arkelley77","description":"This shader implements Cook-Torrance shading (with GGX) alongside raytracing to achieve realistic lighting of a heightmap.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// The light follows the mouse\n\nconst vec3 lightColor = normalize(vec3(251,176,59));\nconst float lightIntensity = 3.0;\nconst float lightHeightPx = 512.0;\nconst float lightRadiusPx = 128.0;\n\nconst float stoneRoughness = 0.7;\nconst float stoneReflectivity = 0.5;\nconst float stoneIOR = 1.5;\n\nconst int rayMarchSamples = 1;\n\nconst bool enableColorMap = true;\nconst bool enableLightFalloff = true;\nconst bool enableDiffuseShading = true;\nconst bool enableCookTorranceSpecularHighlights = true;\nconst bool enableEnvironmentReflections = true;\nconst bool enableRayTracedShadows = true;\n\n// ----\n\nconst float f0 = pow(stoneIOR - 1.0, 2.0) / pow(stoneIOR + 1.0, 2.0);\n\nconst float rayMarchSamplesPerSide = floor(sqrt(float(rayMarchSamples)));\n\nvec4 bumpMap(vec2 uv) {\n    float height = texture(iChannel0, uv).r;\n    \n    vec2 uv_grad_x = dFdx(uv), uv_grad_y = dFdy(uv);\n    mat2 kernel = mat2(uv_grad_y.y, -uv_grad_y.x, -uv_grad_x.y, uv_grad_x.x);\n    \n    vec2 height_grad = vec2(dFdx(0.1 * height), dFdy(0.1 * height)) * kernel\n        / (uv_grad_y.x * uv_grad_x.y - uv_grad_y.y * uv_grad_x.x);\n    \n    vec3 normal = vec3(height_grad, 1.0 - length(height_grad));\n    return vec4(normal, height * 255.0);\n}\n\n\nfloat lightFalloff(float lightSourceIntensity, float d) {\n    return lightSourceIntensity / pow(d, 2.0);\n}\n\n\nfloat ggx(float nDotH, float roughness) {\n    float alpha2 = pow(roughness, 2.0);\n    return (nDotH > 0.0) \n        ? (alpha2 / (4.0 * pow(1.0 + pow(nDotH, 2.0) * (alpha2 - 1.0), 2.0)))\n        : 0.0;\n}\nfloat geometricAttenuation(float nDotH, float nDotL, float nDotV, float vDotH) {\n    return min(1.0, 2.0 * nDotH * min(nDotV, nDotL) / vDotH);\n}\nfloat fresnel(float vDotH) {\n    return f0 + (1.0 - f0) * pow(1.0 - vDotH, 5.0);\n}\nfloat cookTorrance(vec3 dirToLight, vec3 dirToCamera, vec3 normal, float roughness) {\n    \n    vec3 reflectionAxis = (dirToLight + dirToCamera) / 2.0;\n    \n    float nDotH = dot(normal, reflectionAxis);\n    float nDotL = dot(normal, dirToLight);\n    float nDotV = dot(normal, dirToCamera);\n    float vDotH = dot(dirToLight, reflectionAxis);\n    float specularReflectance = ggx(nDotH, roughness) \n        * geometricAttenuation(nDotH, nDotL, nDotV, vDotH)\n        * fresnel(vDotH)\n        / (4.0 * nDotL * nDotV);\n        \n    return specularReflectance;\n}\n\n\nfloat rayMarch(vec3 fragLocation, vec3 lightLocation, float lightRadius) {\n    vec3 vToLight = lightLocation - fragLocation;\n    float dToLight = length(vToLight);\n    vec3 dirToLight = normalize(vToLight);\n    \n    float lightApparentRadius = atan(lightRadius / dToLight);\n    float elAngleToLight = asin(dirToLight.z);\n    float elAngleToTopOfLight = elAngleToLight + lightApparentRadius;\n    float lightApparentDiameter = 2.0 * lightApparentRadius;\n    \n    float amtOfLightVisible = 1.0;\n    float t = 0.25;\n    while (t <= dToLight) {\n        vec2 sampleCoord = fragLocation.xy + dirToLight.xy * t;\n        float sampleHeight = bumpMap(sampleCoord / iResolution.xy).a;\n        vec3 vToSample = vec3(sampleCoord, sampleHeight) - fragLocation;\n        \n        float elAngleToSample = asin(vToSample.z / length(vToSample));\n        // if (elAngleToSample >= elAngleToTopOfLight) {\n        //   // the peak completely blocks the light source\n        //   return 0.0;\n        // }\n        // ^^^^ I had to remove the above code because it created a lot of artifacts for some reason\n        \n        float localAmtLightVisible = (elAngleToTopOfLight - elAngleToSample) / lightApparentDiameter;\n        \n        amtOfLightVisible = min(amtOfLightVisible, localAmtLightVisible);\n        \n        vec2 deltas = (step(0.0, dirToLight.xy) - fract(sampleCoord)) / dirToLight.xy;\n        t += max(min(deltas.x, deltas.y), 0.1);\n    }\n    return amtOfLightVisible;\n}\nfloat occludedLight(vec3 fragLocation, vec3 lightLocation, float lightRadius, vec2 uv) {\n    if (rayMarchSamples > 0) {\n        float half_step = 1.0 / rayMarchSamplesPerSide;\n        float full_step = half_step * 2.0;\n        float ret = 0.0;\n        for (float samp_pos_y = half_step - 0.5; samp_pos_y < 1.0; samp_pos_y += full_step) {\n            for (float samp_pos_x = half_step - 0.5; samp_pos_x < 1.0; samp_pos_x += full_step) {\n                ret += rayMarch(fragLocation + vec3(samp_pos_x, samp_pos_y, 0.0), lightLocation, lightRadius);\n            }\n        }\n        ret /= rayMarchSamplesPerSide * rayMarchSamplesPerSide;\n        return ret;\n    } else {\n        return 1.0;\n    }\n}\n\n\nfloat luminance(vec3 color) {\n    return (color.r + color.g + color.b) / 3.0;\n}\n\nvec3 toneMap(vec3 hdrColor) {\n    float lum = luminance(hdrColor) / lightIntensity;\n    return hdrColor * lum / (lum + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 norm_height = bumpMap(uv);\n    vec3 normal = norm_height.rgb;\n    float height = norm_height.a;\n    \n    float iResDiagonal = length(iResolution.xy);\n    \n    vec3 fragCoord3d = vec3(fragCoord.xy, height);\n    vec3 fragLocation = fragCoord3d / iResDiagonal;\n    \n    vec3 lightCoord3d = vec3(iMouse.xy, lightHeightPx);\n    // get the light source *slightly* off-grid to avoid most issues with Moire patterns\n    lightCoord3d += vec3(0.125, 0.0625, 0.0);\n    vec3 lightLocation = lightCoord3d / iResDiagonal;\n    \n    vec3 vToLight = lightLocation - fragLocation;\n    \n    float dToLight = length(vToLight);\n    vec3 dirToLight = vToLight / dToLight;\n    \n    vec3 stoneColor = lightColor;\n    if (enableColorMap) {\n        stoneColor *= texture(iChannel2, uv).rgb;\n    }\n    float diffuseAmt = stoneRoughness;\n    if (enableDiffuseShading) {\n        diffuseAmt *= max(dot(dirToLight, normal), 0.0);\n    }\n    vec3 diffuse = stoneColor * diffuseAmt;\n    \n    float specularAmt = (1.0 - stoneRoughness);\n    if (enableCookTorranceSpecularHighlights) {\n        specularAmt *= cookTorrance(dirToLight, vec3(0.0, 0.0, 1.0), normal, stoneRoughness);\n    }\n    vec3 specular = specularAmt * lightColor;\n    \n    vec3 reflection = vec3(0.0);\n    if (enableEnvironmentReflections) {\n        vec3 reflectionVector = normalize(reflect(vec3(0.0, 0.0, 1.0), normal));\n        vec3 reflectionColor = texture(iChannel3, reflectionVector).rgb;\n        reflection = reflectionColor * stoneReflectivity;\n    }\n    \n    float localLightIntensity = 1.0;\n    if (enableLightFalloff) {\n        localLightIntensity = lightFalloff(lightIntensity, dToLight) * luminance(lightColor);\n    }\n    if (enableRayTracedShadows) {\n        localLightIntensity *= rayMarch(fragCoord3d, lightCoord3d, lightRadiusPx);\n    }\n    \n    vec3 colorHDR = localLightIntensity * (diffuse + specular) + reflection;\n    \n    fragColor.rgb = toneMap(colorHDR);\n}","name":"Image","description":"","type":"image"}]}