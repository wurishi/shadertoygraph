{"ver":"0.1","info":{"id":"3d2BW1","date":"1589974798","viewed":406,"name":"infernal error","username":"Carandiru","description":"abstract animation for video screen (ingame)","likes":9,"published":3,"flags":32,"usePreview":0,"tags":["explosion","palette","heat","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3d2BW1\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n\tvec3 color = texture(iChannel0, uv).rgb;\n    color += (texture(iChannel1, uv).b * 2.0f - 1.0f) * (3.0f/255.0f);\n    \n    float bar = mod(uv.y + iTime*1.333, 1.) < 0.0333 ?  1.4  : 1.;\n    \n    // Output to screen\n    fragColor = vec4(color*bar,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3d2BW1\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define PI (3.14159265358979323846)\n\n#define EPSILON 0.000000001f\n#define light rgb\n#define tran a\n#define MIN_STEP 0.00005f\t// absolute minimum before performance degradation or infinite loop, no artifacts or banding\n#define MAX_STEPS 48.0f\n#define TIME_SCALAR 1.0f\n#define CAMERA_SPEED 0.111f\n#define ZOOM 0.111f  \t\t// less = more zoom\n\n\n#define sq(a) (a*a)\n\nconst float k_sqrtMaxSteps = sqrt(MAX_STEPS);\nconst vec3  k_eyePos = vec3(-120.0f, -84.851589f, -120.0f).xzy * 0.1f * ZOOM;\nconst float k_VolumeDimensions = (MAX_STEPS);\nconst float k_InvVolumeDimensions = 1.0f / k_VolumeDimensions;\n\nvec2 intersect_box(in vec3 orig, in vec3 dir) {\n\n\tvec3 inv_dir = 1.0f / dir;\n\tvec3 tmin_tmp = (vec3(-1.0f) - orig) * inv_dir;\n\tvec3 tmax_tmp = (vec3(1.0f) - orig) * inv_dir;\n\tvec3 tmin = min(tmin_tmp, tmax_tmp);\n\tvec3 tmax = max(tmin_tmp, tmax_tmp);\n\n\treturn vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\n#define fma(a,b,c) ((a) * (b) + (c))\n\nvec3 v3_rotate_azimuth(in vec3 p, in float angle)\n{\n    vec2 inOrient = vec2(cos(angle), sin(angle));\n    \n\treturn vec3(fma(p.x, inOrient.x, -p.y * inOrient.y),\n\t\t\t\tfma(p.x, inOrient.y, p.y * inOrient.x),\n\t\t\t\tp.z);\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.;\t// size of perpendicular vector\nconst float normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p, float t)\n{\n    float n = -mod(t * 0.2,-2.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricExplosion(vec3 p, float r, float t)\n{\n    p = p/1.5f;\n\n    float final = 0.0f;\n    final += SpiralNoiseC(p.zxy*0.4132+333., t)*(4.0f-r);\n\n    return (1.0f-final) * 0.25f;\n}\n\nfloat tT;\n\nfloat fetch_distance(in vec3 uvw)\n{   \n    vec3 grid = vec3(3.,3.,9.) * 7.0f;\n    vec3 grid_uvw = floor(uvw * grid) / grid;\n    \n    float grid_d = -VolumetricExplosion(grid_uvw, 400.0f, tT);\n    \n    return grid_d;\n}\n\nvec3 fetch_normal(in vec3 uvw, in vec3 rd, in float dt)\n{\n\tvec3 gradient;\n\n\tgradient.x = fetch_distance(uvw + (vec3(dt, 0.0f, 0.0f) * rd)) - fetch_distance(uvw - (vec3(dt, 0.0f, 0.0f) * rd));\n\tgradient.y = fetch_distance(uvw + (vec3(0.0f, dt, 0.0f) * rd)) - fetch_distance(uvw - (vec3(0.0f, dt, 0.0f) * rd));\n\tgradient.z = fetch_distance(uvw + (vec3(0.0f, 0.0f, dt) * rd)) - fetch_distance(uvw - (vec3(0.0f, 0.0f, dt) * rd));\n\n    // bugfix: nan, add epsilon\n\treturn( -normalize(gradient + EPSILON) ); // normal from central differences (gradient) \n}\n\nvec3 eye;\nvec3 camera(in vec3 v)\n{\n    v.y -= 3.0f * (2.0f/3.0f); // center offset\n        \n    // orthographic isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    iso = v3_rotate_azimuth(iso, tT * CAMERA_SPEED);\n    \n    // camera world position\n    eye = v3_rotate_azimuth(k_eyePos, tT * CAMERA_SPEED);\n    iso = iso * k_eyePos;\n\n    return iso;\n}\n\n// https://www.shadertoy.com/view/WlfXRN\n\nvec3 inferno(float t) {\n\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tT = (iTime + 5.0f) * TIME_SCALAR;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 v = uv*2.-1.;\n\t    \n    // init raymarch\n    vec3 ro = camera(vec3(v.xy, 1.0f));\n\n    vec3 rd = normalize(-ro);\n    \n    vec2 t_hit = intersect_box(ro, rd);\n\tif (t_hit.x > t_hit.y) {\n        discard;\n        //fragColor = vec4(0);\n        //return;\n\t}\n\n\tt_hit.x = max(t_hit.x, 0.0f);\n    \n\tfloat interval_length = (t_hit.y - t_hit.x);\n    \n    float inv_num_steps = 1.0f / length(k_VolumeDimensions * abs(rd)); // number of steps for full volume\n\tfloat dt = (interval_length) * inv_num_steps;\t// dt calculated @ what would be the full volume interval\n    dt = max(MIN_STEP, dt);\n    \n    vec3 p = eye + t_hit.x * rd + textureLod(iChannel1, uv, 0.0f).r * rd * dt * 0.5f; // start with bluenoise jitter offset (up to 1/2 dt)\n    \n    // begin volumetric raymarch\n    vec4 voxel = vec4(vec3(0.0f), 1.0f);\n\tfloat d;\n    for( float interval_remaining = interval_length; \n         interval_remaining >= 0.0f ; interval_remaining -= dt ) \n    {  // fast sign test       \n\n        vec3 n = fetch_normal(p, rd, dt);\n        d = fetch_distance(p);\n\t\t        \n        float NdotV = max(0.0f, dot(rd, n));\n        float fresnel = pow(1.0f - NdotV, 5.0f);\n        vec3 wave_light = inferno(NdotV);\n                               \n        vec3 light_color = wave_light;\n\n        // integration\n        float sigmaS = d;\n\t\tfloat sigmaE = max(EPSILON, sigmaS); // to avoid division by zero extinction\n                \n        vec3 Li = light_color * sigmaS;// incoming light\n        float sigma_dt = exp2(sigmaE * k_sqrtMaxSteps * dt * -2.0f);\n        vec3 Sint = (Li - Li * sigma_dt) / sigmaE; // integrate along the current step segment\n\n        voxel.light += voxel.tran * Sint; // accumulate and also take into account the transmittance from previous steps\n\n        // Evaluate transmittance to view independentely (change in transmittance)\n        voxel.tran *= sigma_dt;\n\t\t\n        //emission\n        voxel.tran = min(1.0f, voxel.tran + voxel.tran * fresnel * sigma_dt);\n        \n        p += (dt) * rd;\n    }\n        \n    // Output to screen\n    vec4 prevColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    fragColor.rgb = mix(prevColor.light * prevColor.tran, voxel.light * (1.0f - voxel.tran), 0.5f);\n    fragColor.a = 1.0f - voxel.tran;\n}","name":"Buffer A","description":"","type":"buffer"}]}