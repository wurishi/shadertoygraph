{"ver":"0.1","info":{"id":"WlsSzS","date":"1563654560","viewed":475,"name":"Reaction diffusion box","username":"hamtarodeluxe","description":"3D reaction diffusion, click to interact. This time I'm storing 2 voxels per texel so it's finer :-)\nCommon -> simulation to tweak the reaction.","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["3d","volume","simulation","interactive","diffusion","buffer","reaction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float dim = floor(pow(iResolution.x*iResolution.y*2.,1./3.));  \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3 ro = RO;\n   \tvec3 lookAt = LOOKAT;\n    vec3 fw = normalize(lookAt-ro);\n    vec3 right = normalize(cross(vec3(0.,1.,0.), fw));\n    vec3 up = normalize(cross (fw, right));\n    vec3 rd = normalize( fw * 1. + right * uv.x + up * uv.y);\n    vec3 col = vec3(0.);\n    float stp = 0.01;\n    vec3 n = normalize(ro);\n    float t = 0.0;\n    vec3 tp = vec3(1.);\n    \n   \tfloat tmin, tmax;\n    bool hit = intersectBox(ro, rd, vec3(0.5), tmin,tmax);\n    vec3 hTexCoords = fract(vec3(fragCoord, iFrame)/32.);\n    vec3 h = texture(iChannel1, vec3(hTexCoords)).rgb;\n\n    if(hit)\n    {\t\n        float ss = STEPSIZE;\n        int nSteps = int(floor((tmax-tmin)/ss));\n        vec3 rdT = rd * tmin;\n        rdT = (vec3(dot(rdT,right),dot(rdT,up),dot(rdT, fw)));  \n        rdT.z = (floor(rdT.z/ss))*ss;\n        rdT = (rdT.x*right+rdT.y*up+rdT.z*fw);\n        tmin = length(rdT);\n        ss = (ss/(dot(rd,fw)));\n      \ttmin += 0.05*(h.r-0.5);\n        \n        ro = ro+rd*tmin;\n        vec3 tp = vec3(1.);\n        int i = 0;\n        for (i=0; i<nSteps; i++)\n        {\n            vec3 p = ro + rd*t;\n            vec3 voxelCoord = (p+0.5)*dim; //coordinate in grid space, not floored\n            \n            if (isInside(voxelCoord,dim))     \n            {\n                //trilinear interpolation\n                vec3 fl = floor(voxelCoord);\n                vec2 C0 = sampleVoxel(fl, iResolution.xy, dim, iChannel0);\n                vec2 C1 = sampleVoxel(fl + vec3(0,0,1), iResolution.xy, dim, iChannel0);\n                vec2 C2 = sampleVoxel(fl + vec3(1,0,1), iResolution.xy, dim, iChannel0);\n                vec2 C3 = sampleVoxel(fl + vec3(1,0,0), iResolution.xy, dim, iChannel0);\n                vec2 C4 = sampleVoxel(fl + vec3(0,1,0), iResolution.xy, dim, iChannel0);\n                vec2 C5 = sampleVoxel(fl + vec3(0,1,1), iResolution.xy, dim, iChannel0);\n                vec2 C6 = sampleVoxel(fl + vec3(1,1,1), iResolution.xy, dim, iChannel0);\n                vec2 C7 = sampleVoxel(fl + vec3(1,1,0), iResolution.xy, dim, iChannel0);  \n\n                vec3 d = voxelCoord - fl;\n\n                vec2 C01 = mix(C0, C1, d.z); vec2 C32 = mix(C3, C2, d.z);\n                vec2 C45 = mix(C4, C5, d.z); vec2 C76 = mix(C7, C6, d.z);\n                vec2 C0132 = mix(C01, C32, d.x); vec2 C4576 = mix(C45, C76, d.x);\n                vec2 C = mix(C0132,C4576, d.y);\n\t\t\t\t\n                //gradients\n                vec2 G01 = C1-C0; vec2 G32 = C2-C3; vec2 G45 = C5-C4; vec2 G76 = C6-C7;\n                vec2 G03 = C3-C0; vec2 G12 = C2-C1; vec2 G47 = C7-C4; vec2 G56 = C6-C5;\n                vec2 G04 = C4-C0; vec2 G15 = C5-C1; vec2 G37 = C7-C3; vec2 G26 = C6-C2;\n\n                vec2 GZ = mix(mix(G01, G32, d.x), mix(G45,G76, d.x), d.y);\n                vec2 GX = mix(mix(G03, G12, d.z), mix(G47,G56, d.z), d.y);\n                vec2 GY = mix(mix(G04, G37, d.x), mix(G15,G26, d.x), d.z);\n\n                vec3 gA = vec3(GX.x,GY.x,GZ.x); float lgA = length(gA);\n                vec3 gB = vec3(GX.y,GY.y,GZ.y); float lgB = length(gB);\n                gA = lgA == 0. ? vec3(0.) : gA/lgA;\n                gB = lgB == 0. ? vec3(0.) : gB/lgB;\n\n                //lighting\n                vec3 lp = LIGHTPOS;\n                vec3 tl = (lp-p);\n                float ld2 = tl.x*tl.x+tl.y*tl.y+tl.z*tl.z;\n                tl = ld2 == 0. ? vec3(0.) : tl/sqrt(ld2);\n                ld2 = max(ld2,0.01);\n                float light = 0.8/(ld2);\n                vec3 v;       \n                v.x = (smoothstep(RENDERA-0.1,RENDERA,C.x)-smoothstep(RENDERA,RENDERA+0.2,C.x));\n                v.y = (smoothstep(RENDERB-0.1,RENDERB,C.y)-smoothstep(RENDERB,RENDERB+0.1,C.y));     \n                v.z = (smoothstep(RENDERB2-0.15,RENDERB2,C.y)-smoothstep(RENDERB2+0.1,RENDERB2+0.3,C.y));     \n                vec3 localCol = vec3(0.);\n                vec2 l = vec2 (-dot(gA,tl)*0.5+0.5,-dot(gB,tl)*0.5+0.5);\n                localCol += mix(vec3(1,0.2,0.2),vec3(0.5,0.5,0.2),pow(v.x,6.))*v.x * pow(l.x,1.)*0.3*light;\n                localCol += mix(vec3(0.2,0.5,1),vec3(0.2,0.5,1),pow(v.y,5.))*v.y * pow(l.y,2.)*1.5*light;\n                localCol += mix(vec3(0,1,1),vec3(0.3,3.,0.5),pow(v.z,5.))*v.z * pow(l.y,1.)*light;\n                tp *= exp(-1.*(localCol)*ss);\n                col +=  localCol*tp;\n            }\n            t += ss;\n    \t}  \n        col/=float(nSteps+1);\n    }\n    col *= 1.5;\n    col = pow(col+0.015,vec3(0.45));\n    float v = 1.-length(uv+0.05*(h.g-0.5));\n    fragColor = vec4((col)*v + (5./255.)*h.g,1); \n   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 mouse = iMouse.xy/iResolution.xy; \n    mouse -= 0.5;\n    mouse.x *= iResolution.x/iResolution.y;\n    \n    float dim = floor(pow(iResolution.x*iResolution.y*2.,1./3.));\n    \n    vec3 os[26];   \n    os[0 ] = vec3( 0, 1, 1);\n    os[1 ] = vec3( 0,-1, 1);\n    os[2 ] = vec3( 1, 0, 1);\n    os[3 ] = vec3(-1, 0, 1);\n    os[4 ] = vec3( 1, 1, 1);\n    os[5 ] = vec3( 1,-1, 1);\n    os[6 ] = vec3(-1, 1, 1);\n    os[7 ] = vec3(-1,-1, 1);\n    os[8 ] = vec3( 0, 0, 1);\n    os[9 ] = vec3( 0, 1,-1);\n    os[10] = vec3( 0,-1,-1);\n    os[11] = vec3( 1, 0,-1);\n    os[12] = vec3(-1, 0,-1);\n    os[13] = vec3( 1, 1,-1);\n    os[14] = vec3( 1,-1,-1);\n    os[15] = vec3(-1, 1,-1);\n    os[16] = vec3(-1,-1,-1);\n    os[17] = vec3( 0, 0,-1);  \n    os[18] = vec3( 0, 1, 0);\n    os[19] = vec3( 0,-1, 0);\n    os[20] = vec3( 1, 0, 0);\n    os[21] = vec3(-1, 0, 0);\n    os[22] = vec3( 1, 1, 0);\n    os[23] = vec3( 1,-1, 0);\n    os[24] = vec3(-1, 1, 0);\n    os[25] = vec3(-1,-1, 0);\n        \n    vec4 C = texelFetch(iChannel0, ivec2(fragCoord),0);\n    float sum = 0.;\n    vec4 K = vec4(0.); \n    vec3 voxel0 = texToVox(fragCoord, iResolution.xy, dim, false);\n    vec3 voxel1 = texToVox(fragCoord, iResolution.xy, dim, true);\n    \n    for (int i=0; i<26; i++)\n    {      \n        vec3 sampVoxel0 = voxel0 + os[i];\n        vec3 sampVoxel1 = voxel1 + os[i];\n        \n        float v =  1./length(os[i]);\n        sum += v;\n        float m = MIXBORDERS;\n        vec2 outside = BORDERS;\n        if (isInside(sampVoxel0,dim))\n        {\n          \tK.xy += v*sampleVoxel(sampVoxel0,iResolution.xy,dim,iChannel0);//  (sampTexelD.z == 0. ?texelFetch(iChannel0, ivec2(sampTexelD.xy), 0).xy : texelFetch(iChannel0, ivec2(sampTexelD.xy), 0).zw);  \n        }else \n        {\n        \tK.xy +=  v*mix(C.xy,outside,m);\n        }\n\t\tif(isInside(sampVoxel1,dim))\n        {\n            K.zw += v*sampleVoxel(sampVoxel1,iResolution.xy,dim,iChannel0);\n        }else\n        {\n            K.zw += v*mix(C.zw, outside,m);\n        }\n\n\t} \n    \n    vec3 texel0 = voxToTex(voxel0, iResolution.xy, dim);\n    vec3 texel1 = voxToTex(voxel1, iResolution.xy, dim);    \n    C.xy = texelFetch(iChannel0, ivec2(texel0.xy), 0).xy;  \n    C.zw = texelFetch(iChannel0, ivec2(texel1.xy), 0).zw;  \n    \n\tK /= sum;\n    vec4 D = K-C;\n    float s = 1.;\n    vec2 dr = vec2(1.,0.5);\n    vec4 deltaC = vec4(0.);\n\tdeltaC.x = (D.x*dr.x-C.x*C.y*C.y + FEED*(1.-C.x)) * s ;\n    deltaC.y = (D.y*dr.y+C.x*C.y*C.y - (KILL+FEED)*C.y) * s ;\n   \tdeltaC.z = (D.z*dr.x-C.z*C.w*C.w + FEED*(1.-C.z)) * s ;\n    deltaC.w = (D.w*dr.y+C.z*C.w*C.w - (KILL+FEED)*C.w) * s ;\n    C += deltaC;\n     \n\n    if (iMouse.z>0.)\n    {\n        vec3 ro = RO;\n        vec3 lookAt = LOOKAT;\n        vec3 fw = normalize(lookAt-ro);\n        vec3 right = normalize(cross(vec3(0.,1.,0.), fw));\n        vec3 up = normalize(cross (fw, right));\n        vec3 rd = normalize( fw * 1. + right * mouse.x + up * mouse.y);\n        float t = 0.;\n        vec2 acc = vec2(0.);\n        float tmin, tmax;\n\t\tbool hit = intersectBox(ro, rd, vec3(0.5), tmin,tmax);\n        vec3 p = ro + rd * (tmin+(tmax-tmin)*0.5);\n        if (hit)\n        {\n            vec3 vp = (p+0.5)*dim;\n        \tvec3 mouseVoxelCoord = floor(vp);          \n            C.y += 0.5*max(1.-((length(voxel0-mouseVoxelCoord)/dim)/0.05),0.);\n            C.w += 0.5*max(1.-((length(voxel1-mouseVoxelCoord)/dim)/0.05),0.);\n        }    \t\n    } \n    C = clamp(C,vec4(0.0),vec4(1.));\n\n    if(iFrame <= 4) \n    {\n        float a =0.8; float b =0.001;\n        C = vec4(a,b,a,b);\n\t}\n\n    fragColor = C;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\n/* simulation */\n// out of bounds kernel sample computed like :\n// vec2 sampledValue = mix(kernelCenterValue, BORDERS, MIXBORDERS);\n// Unstable pattern from https://pmneila.github.io/jsexp/grayscott/\n#define FEED 0.014\n#define KILL 0.045\n#define BORDERS vec2(0.,0.) \n#define MIXBORDERS 0.12\n\n/* scene */\n#define RO vec3 (cos(iTime*0.1)*1.35,0.9,sin(iTime*0.1)*1.35)\n#define LOOKAT vec3(0.,-0.1,0.);\n#define LIGHTPOS vec3 (cos(iTime*0.5+0.5*PI)*.73,00.3,sin(iTime*0.5+0.5*PI)*0.73)\n\n/* render */\n// RENDERs are concentration tresholds of interest for shading\n#define STEPSIZE 0.01\n#define RENDERA 0.55\n#define RENDERB 0.1\n#define RENDERB2 0.38\n\n\nfloat hash( uint n ) //iq\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 texToVox(vec2 coords, vec2 res, float dim, bool side)\n{ \n    coords = floor(coords);\n    res = floor(res);\n    float i = (coords.y*res.x+coords.x);\n    if(side) i += (floor(res.x*res.y));\n    vec3 voxCoord;\n    voxCoord.z = floor(i/(dim*dim));\n    voxCoord.y = floor((i-(dim*dim*voxCoord.z))/dim);\n    voxCoord.x = floor( i - dim*dim*voxCoord.z - dim*voxCoord.y);\n    return voxCoord;\n}\n\nvec3 voxToTex(vec3 coords, vec2 res, float dim)\n{\n    float side = 0.;\n    res= floor(res);\n    float i = floor(coords.x + coords.y*dim + coords.z*dim*dim);\n    if (i > res.x*res.y)side = 1.0;\n    i = mod(i,floor(res.x*res.y));\n    \n    vec2 texCoord;\n    texCoord.y = floor(i/res.x);\n    texCoord.x = i-texCoord.y*res.x;\n    return vec3(texCoord,side);\n}\nbool isInside(vec3 vox, float dim)\n{\n\treturn vox.x < dim && vox.y < dim && vox.z < dim && vox.x>= 0.&& vox.y>= 0.&& vox.z>= 0.;\n}\n\nvec2 sampleVoxel(vec3 voxelCoord,vec2 res, float dim, sampler2D sampler)\n{\n\tif (!isInside(voxelCoord, dim)) return vec2(0.);\n    vec3 frag = voxToTex(voxelCoord, res, dim);\n    \n    return frag.z == 0. ? texelFetch(sampler, ivec2(frag),0).xy : texelFetch(sampler, ivec2(frag),0).zw;           \n}\n\n\nfloat smallestPositive(float x,float y)\n{\n\tif(x<0.&&y>=0.) return y;\n    if(y<0.&&x>=0.) return x;\n    else return min(x,y);\n}\n\nbool intersectBox(vec3 ro, vec3 rd, vec3 size, out float t1, out float t2)//expect normalized rd\n{\n    bool hasHit = true;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax; \n    vec3 invRd = 1./rd;\n    vec3 signRd = sign(invRd);\n    \n    tmin =  (-signRd.x*size.x - ro.x) * invRd.x;\n\ttmax =  ( signRd.x*size.x - ro.x) * invRd.x;\n    tymin = (-signRd.y*size.y - ro.y) * invRd.y;\n\ttymax = ( signRd.y*size.y - ro.y) * invRd.y;\n    tzmin = (-signRd.z*size.z - ro.z) * invRd.z;\n\ttzmax = ( signRd.z*size.z - ro.z) * invRd.z;\n    \n    tmin = max(tmin,tymin);\n    tmax = min(tmax,tymax);\n\n    tmin = max(tmin,tzmin);\n    tmax = min(tmax,tzmax);\n    \n \tif((tmin > tzmax) || (tzmin > tmax) ||(tmin > tymax) || (tymin > tmax))\n    {\n        hasHit = false;\n    }\n   \n   \tt1 = smallestPositive(tmin,tmax);\n    \n   \tif(t1<=0.)\n    {\n        hasHit = false;\n    }\n    t1 = min(tmin,tmax);\n    t2 = max(tmin,tmax);\n\n    return hasHit;\n} \n\n\n","name":"Common","description":"","type":"common"}]}