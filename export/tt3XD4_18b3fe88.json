{"ver":"0.1","info":{"id":"tt3XD4","date":"1580928820","viewed":370,"name":"3D Truchet Pattern","username":"NivBehar","description":"3D Truchet Pattern","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Ml2Gzm","filepath":"https://soundcloud.com/loopcrew/part-11?in=loopcrew/sets/rhian-sheehan","previewfilepath":"https://soundcloud.com/loopcrew/part-11?in=loopcrew/sets/rhian-sheehan","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//to do:\n\n// mode = 0. for a convenient environment to develop\n// mode = 1. for a regular environment\n// mode > 1. for more speed\n# define mode 1.\n# define pipesOnly false\n\n# define MaxSteps 70\n# define MaxDist 10.\n# define time iTime\n# define PI 3.141592654\n\nfloat camSpeed() {return mode*.3*time;}\nfloat pipeSpeed() {return 0.*15.*time;}\nfloat Hash21(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(a.y*a.z*a.x);\n}\nfloat tube(vec2 p){ // saw this one on Shane's shader\n    return max(max(p.x, p.y), (p.x + p.y)*.7071); // .7071 for an octagon, etc.\n    //return max(p.x, p.y); // Square tube, etc.\n}\nvec2 GetTorusUV(vec3 p, vec2 torusSize)\n{\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-torusSize.x, p.y);\n    return vec2(x,y);    \n}\nfloat sdTorus(vec3 p, vec2 r)\n{\n    vec2 tUV = GetTorusUV(p, r);\n    return length( vec2(length(p.xz + 0.004*(0.5+0.5*sin(tUV.x * 200. + pipeSpeed()))) - r.x, p.y) ) - r.y;\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec3 spherePos() {\n    return vec3(0.,1.2 + 0.3*sin(time),0.);\n}\nfloat Hash31(vec3 p)\n{\n    vec3 a = fract(p*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return (a.x*a.y*a.z);\n}\nvec3 GetTorusCol(vec3 torPos, vec2 torusRad, vec3 ID)\n{\n    float soundWave = texture(iChannel2, vec2(1., 0.)).x;\n    //soundWave = soundWave > 0.15 ? soundWave : 0.;\n    soundWave = smoothstep(0.,1., soundWave);\n    vec2 torUV = GetTorusUV(torPos, torusRad);\n    vec3 tex = texture(iChannel1, torUV + time*0.6).xyz;\n   \n    float whiteEdges = 0.5 + 0.5*sin(torUV.x*6.);\n    whiteEdges = smoothstep(0., 0.5, whiteEdges);\n    //vec3 torCol = vec3(1.)*whiteEdges;//*( 2. + sin(ID.x*412.3));  \n    vec3 torCol;\n    torCol += 3.*(whiteEdges * (fract(Hash21(torUV*vec2(1.,15.5)*0.000000005))*0.2+0.5));\n    \n    \n    float ripples = 0.5 + 0.5*sin(torUV.x*200. + pipeSpeed());\n    torCol += vec3(1.,0.7,0.6)*ripples*(1.-whiteEdges)*tex;\n    \n    //vec3 lava = texture(iChannel3, torUV).xyz;\n    \n    float waves = 0.5+0.5*sin(ID.x*5. + torUV.x*5. + 3.*time);\n    waves = smoothstep(0.3, 0., waves);\n    vec3 wavesCol = vec3(3.8 + 3.*cos(ID.x*213. + time*0.291),\n                         0.87,\n                         5.+4.*cos(ID.z*323. + time*0.512))\n        \t\t\t\t *tex*tex;//*lava;\n    //wavesCol *= 3.;\n    torCol += waves*wavesCol*(1.-whiteEdges);//ripples*waves*wavesCol;\n    \n    float lines = 0.5+0.5*sin(torUV.y*7. + 0.*10.*time);\n    lines = smoothstep(0.4, 0., lines);\n    vec3 linesCol = vec3(0., 3.4, 10.66);//*tex;//*lava;\n    //linesCol.x = 3. + 3.*sin(ID.x*ID.y*ID.z*104.21);\n    float ripples2 = 0.5 + 0.5*sin(torUV.x*200. + 10.*time);\n    //linesCol *= 5.;//*soundWave;\n    linesCol = ripples2*lines*(linesCol)*(1.-whiteEdges);//*soundWave;\n    linesCol *= 3.5 + 3.3*sin(time*7.);\n    torCol += linesCol;\n    \n    return torCol;\n}\nfloat sdBox2(vec3 p, vec3 s, float speed) \n{\n  vec3 a = vec3(0.05*sin(p.y*p.z*3. + speed), 0.,0.);\n  vec3 q = abs(p + a.xyy) - s - s*0.5*a.xyx;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 truchetBox(vec3 p, vec3 boxPos, float calcCol)\n{\n    vec3 a = vec3(0.5, 0., 0.5);\n    vec3 b = vec3(-0.5, -0.5, 0.);\n    vec3 c = vec3(0., 0.5, -0.5);\n    \n    vec3 boxPosNew = p - boxPos;\n\n    if(mode != 0.) {\n    boxPosNew.yz = fract(boxPosNew.yz+0.5)-0.5;\n    boxPosNew.x = fract(boxPosNew.x+0.5 + camSpeed())-0.5;\n    }\n        \n    vec3 ID = floor(p+0.5);\n    ID.x = floor(p.x+0.5 + camSpeed() );\n    \n    float hash = Hash31(ID);\n    float xRotBy = mod(floor(hash), 1.);\n    float yRotBy = mod(floor(hash), 2.);\n    float zRotBy = mod(floor(hash), 3.);\n    boxPosNew = RotX(boxPosNew, PI*xRotBy);\n    boxPosNew = RotY(boxPosNew, PI*yRotBy);\n    boxPosNew = RotZ(boxPosNew, PI*zRotBy);\n    \n    //boxPosNew = RotZ(boxPosNew, PI);\n    //boxPosNew = RotY(boxPosNew, PI);\n    //boxPosNew = RotY(boxPosNew, PI*0.5);\n    float boxDist = sdBox(boxPosNew, vec3(0.488));\n    \n    vec2 torusRad = vec2(0.5, 0.03);\n    vec3 tor1Pos = (boxPosNew - a); //p - vec3(1.,0.5,1.);\n    float tor1 = sdTorus(tor1Pos, torusRad);\n    vec3 tor1Col = calcCol == 0.? vec3(0.) : GetTorusCol(tor1Pos, torusRad, ID);\n    \n    vec3 tor2Pos = (boxPosNew - b); //vec3(0.,0.,0.5);\n\ttor2Pos = RotX(tor2Pos, PI*0.5);\n    tor2Pos = RotY(tor2Pos, PI); // this is to get convenient uv's later\n    float tor2 = sdTorus(tor2Pos, torusRad);\n    vec3 tor2Col = calcCol == 0.? vec3(0.) : GetTorusCol(tor2Pos, torusRad, ID);\n\t\n    vec3 tor3Pos = (boxPosNew - c); //vec3(0.5,1.,0.);\n    tor3Pos = RotX(tor3Pos, PI*0.5);\n    tor3Pos = RotZ(tor3Pos, PI*0.5);\n    tor3Pos = RotY(tor3Pos,PI*0.5);\n    float tor3 = sdTorus(tor3Pos, torusRad);\n    vec3 tor3Col = calcCol == 0.? vec3(0.) : GetTorusCol(tor3Pos, torusRad, ID);\n    \n    vec4 allTorusDist = min2(min2(vec4(tor1Col,tor1), vec4(tor2Col,tor2)), vec4(tor3Col,tor3));\n    vec3 allTorusCol = vec3(1.,0.1,0.1);\n    \n   \tfloat d = 10.;\n    float arm1 = arm1Dist(boxPosNew);\n    vec3 arm1Col = calcCol == 0.? vec3(0.) : texture(iChannel0, GetTorusUV(tor1Pos, torusRad)).xyz;\n    float arm2 = arm2Dist(boxPosNew);\n    vec3 arm2Col = calcCol == 0.? vec3(0.) : texture(iChannel0, GetTorusUV(tor2Pos, torusRad)).xyz;\n    float arm3 = arm3Dist(boxPosNew);\n    vec3 arm3Col = calcCol == 0.? vec3(0.) : texture(iChannel0, GetTorusUV(tor3Pos, torusRad)).xyz;\n    vec4 arms = min2(min2(vec4(arm1Col,arm1), vec4(arm2Col,arm2)), vec4(arm3Col,arm3));\n    //arms = arm3;\n\n\n    //float truchetBoxDist = min(min(tor1, tor2), tor3);\n    vec4 truchetBoxDist = opUS(arms, allTorusDist, 0.004);\n    //truchetBoxDist = min2(truchetBoxDist, spheresDist);\n    //truchetBoxDist = vec4(armsCol,arms);\n    if(pipesOnly)\n        truchetBoxDist = allTorusDist;\n    //truchetBoxDist = min2(truchetBoxDist, sphereDist);\n    //truchetBoxDist = smin(truchetBoxDist, boxCenter, 0.25+0.05*sin(xRotBy + yRotBy + zRotBy + time*0.4));\n    truchetBoxDist = max(truchetBoxDist, boxDist);\n    \n    return truchetBoxDist;\n}\n\nvec4 GetDist(vec3 p, float calcCol) // return vec2(min Distance, Object ID)\n{    \n    //ground\n    float groundDist = p.y;\n    float groundID = 1.;\n    \n    \n    //truchetBox\n    vec4 truchetBoxDist = truchetBox(p, vec3(0.), calcCol);\n    //float truchetBox2Dist = truchetBox(p, vec3(0.5,1.5,0.5));\n    //truchetBoxDist = smin(truchetBoxDist, truchetBox2Dist, 0.05);\n    //truchetBoxDist.xyz = vec3(0.5,0.3,0.7);\n    \n    vec3 boxPosNew = p; \n    if(mode != 0.) {\n    boxPosNew.yz = fract(boxPosNew.yz+0.5)-0.5;\n    boxPosNew.x = fract(boxPosNew.x+0.5 + camSpeed())-0.5;\n    }\n    \n    vec3 ID = floor(p+0.5);\n    ID.x = floor(p.x+0.5 + camSpeed() );\n       \n    vec3 cylSize = vec3(1.,2.,1.);\n    vec3 cyl1Pos = boxPosNew;\n    vec3 n = p;\n    float x = (PI+atan(n.x, n.z))*PI*0.5;\n    float y = p.y;\n\n    vec3 cylLightCol = vec3(0.2,0.,1.)*15.;\n    float cylGreyIntensity = 1.5;\n    float ripples1 = smoothstep(0.2, 0.1, 0.5 + 0.5*sin(p.y*200.*PI));\n    float ripples2 = smoothstep(0.15, 0.149, 0.5 + 0.5*sin(p.y*10.*PI + PI*0.5));\n    float ripples = ripples1*ripples2;\n    float timing = 0.5 + 0.5*sin(floor(time)*0.5*PI);\n    vec3 cyl1Col = timing*cylLightCol*ripples;\n    cyl1Col += cylGreyIntensity*(1.-ripples);\n    \n    //cyl1Col = texture(iChannel0, vec2(x,y)*0.1).xyz;\n    vec4 cyl1 = vec4( cyl1Col, sdCylinder(cyl1Pos, vec3(0.,0.,0.015)));\n\n    vec3 cyl2Pos = RotX(boxPosNew, 0.5*PI);\n    ripples1 = smoothstep(0.2, 0.1, 0.5 + 0.5*sin(p.z*200.*PI));\n    ripples2 = smoothstep(0.15, 0.149, 0.5 + 0.5*sin(p.z*10.*PI + PI*0.5));\n    ripples = ripples1*ripples2;\n    vec3 cyl2Col = timing*cylLightCol*ripples;\n    cyl2Col += cylGreyIntensity*(1.-ripples);\n    vec4 cyl2 = vec4( cyl2Col, sdCylinder(cyl2Pos, vec3(0.,0.,0.015)));\n    \n    vec3 cyl3Pos = RotZ(boxPosNew, 0.5*PI);\n\tripples1 = smoothstep(0.2, 0.1, 0.5 + 0.5*sin(p.x*200.*PI + PI*200.*camSpeed()));\n    ripples2 = smoothstep(0.15, 0.149, 0.5 + 0.5*sin(p.x*10.*PI + PI*10.*camSpeed() + PI*0.5));\n    ripples = ripples1*ripples2;\n    vec3 cyl3Col = timing*cylLightCol*ripples;\n    cyl3Col += cylGreyIntensity*(1.-ripples); \n    vec4 cyl3 = vec4( cyl3Col, sdCylinder(cyl3Pos, vec3(0.,0.,0.015)));\n    \n    vec4 cyls = opUS(min2(cyl1, cyl2), cyl3, 0.013);\n    \n    vec4 res = min2(truchetBoxDist, cyls);\n    //vec4 res = min2(truchetBoxDist,spheresDist);\n    //if(skyDist < truchetBoxDist.w)\n    //    res = vec4(vec3(0.), skyDist);\n\n\tres.w *= 0.9;\n    return res;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p, 0.).w;\n    vec2 e = vec2(.01, 0.);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy, 0.).w, \n                        GetDist(p-e.yxy, 0.).w, \n                        GetDist(p-e.yyx, 0.).w);\n    return normalize(n);\n}\n// fog by iq\nvec3 applyFog( vec3  rgb, float distance)\n{\n    float soundWave1 = texture(iChannel2, vec2(0.2, 0.)).x;\n    float soundWave2 = texture(iChannel2, vec2(0.6, 0.3)).x;\n    float soundWave3 = texture(iChannel2, vec2(1., 0.7)).x;\n    float b = 0.5;\n    float fogAmount = 1.0 - exp( -distance*b );\n    vec3  fogColor1  = vec3(0.3,0.2,0.6);\n    fogColor1 *= fogColor1*1.5*(0.2 + 1.5*max(soundWave1,soundWave1));\n    float fogR = soundWave2*0.6;\n    float fogB = soundWave1*0.5;\n    vec3 fogColor = vec3(fogR, 0., fogB);\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec4 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec3 result= vec3(1.,1.,0.)*0.;\n    vec4 dS;\n    float dO = 0.05;\n    vec3 p;  \n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        if(dO > MaxDist) {\n            result = vec3(0.);\n            break;\n        }\n        dS = GetDist(p, 1.);\n        if(abs(dS.w) < 0.001) {\n            result = dS.xyz;\n            break; \n        }\n        dO += 0.9*dS.w;\n    }     \n    return vec4(result.xyz,dO);\n}\nfloat GetLight(vec3 p, vec3 lightpos, int steps)\n{\n    float lightpower = 1.;\n    float shadowstrength = 0.3;\n    vec3 l = normalize(lightpos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l*lightpower), 0., 1.);\n    float d = RayMarch(p + n*0.01, l, steps).w;\n    if(d < length(lightpos-p)) {dif *= shadowstrength;}\n    //float sha = hardShadow(p, lightpos, lightShadowDist.x, lightShadowDist.y) * 0.5 + 0.5;\n    //sha = max(0., pow(sha, lightShadowIntensity));\n    return dif;//*sha;\n}\n// calcOcclusion by iq\nfloat calcOcclusion(vec3 p)\n{\n    vec3 n = GetNormal(p);\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = p + h*n;\n        float d = GetDist(opos, 0.).w;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 cam(vec2 mou)\n{\n    vec3 ro = vec3(0.5,0.5,0.5);\n    ro.xy += mou.xy + sin(camSpeed()*0.5 + 3.*0.5*PI) + cos(camSpeed()*0.25);\n    \n    return ro;\n}\nfloat specularReflection(vec3 p, vec3 rd, vec3 lightPos, float intensity, float shininessVal)\n{\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.,0.,0.);\n \n    vec3 lookat = vec3(0.);\n\n    float zoom = 0.6;\n    \n    vec2 mou = 5.*(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    //mou.y += 2.;\n    //mou.y = max(0.01, mou.y);\n    vec3 ro = vec3(1.,5.,1.);//vec3(mou,-1.);\n\n    //ro.y = mou.y;\n    \n    //ro = vec3(0.5);\n    //ro.xz *= 10.3*Rot(time*0.03 + mou.x*0.1);\n\tro = cam(mou);\n    //ro = RotX(ro,camSpeed()+PI*0.5);\n    //ro.x += time;\n    \n    lookat = ro + vec3(1.,0.0001, 0.0001);\n\n    lookat.xz *= Rot(3.*cos(time*0.178));\n    lookat.y = 0.7*sin(time*0.321);\n    \n    //lookat = RotY(lookat, 0.25*mou.x);\n    //lookat = RotZ(lookat, mou.y*0.4);\n    \n    //lookat.y += mou.y;\n    //lookat.x += mou.x;\n\n    if(mode == 0.) {\n    ro = vec3(0., 0., -1.);\n    ro.xz *= Rot(mou.x);\n    ro.y += mou.y;\n    zoom += abs(mou.x)*abs(mou.y);\n    lookat = vec3(0.01);// + vec3(mou.x, 0., 0.);\n    }\n    \n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    vec4 d = RayMarch(ro,rd, MaxSteps); // d.y = Object ID\n    vec3 p = ro + rd*d.w;\n    \n    vec3 lightPos = ro + 0.1*normalize(lookat);\n\tif(mode == 0.)\n        lightPos = ro;\n    \n    float dif = GetLight(p, lightPos, 30);\n    float occ = calcOcclusion(p);\n    float spRef = specularReflection(p, rd, lightPos, 0.6, 1.);\n\tcol = d.xyz*dif*occ + spRef*vec3(1., 1., 0.8);\n\t//    col = applyFog(col, d.w,ro, rd);\n    //col = pow( col, vec3(1.0/2.2) );\n    //float soundWave = texture(iChannel2, vec2(0.2, 0.)).x;\n\tcol = applyFog(col, d.w);\n    \n    //if(uv.x < soundWave)\n    //    col = vec3(1.);\n\n    fragColor = vec4(col,0.1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//# define time iTime\n# define PI 3.141592654\nvec3 RotX (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x, p.y*cc + p.z*-ss,  p.y*ss + p.z*cc);\n}\nvec3 RotY (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc + p.z*ss, p.y, p.x*-ss + p.z*cc);\n}\nvec3 RotZ (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc  + p.y*-ss, p.x*ss + p.y*cc, p.z);\n}\nvec4 opUS( vec4 d1, vec4 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    vec3 color = mix(d2.xyz, d1.xyz, h);\n    float dist = mix( d2.w, d1.w, h ) - k*h*(1.0-h); \n \treturn vec4(color, dist);\n}\nvec4 min2(vec4 d1, vec4 d2)\n{\n    return min(d1.w,d2.w) == d1.w ? d1 : d2;\n}\nfloat sdBox(vec3 p, vec3 s) \n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 s, float r )\n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z);///(2.*PI) + 0.5;\n    float y = n.y;//0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r) {\n    float d =  length(p) - r;\n    return d;\n}\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nvec4 HexCoords(vec2 UV) \n{\n    \tvec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nfloat arm1Dist(vec3 boxPosNew)\n{\n    vec3 box1Size = vec3(0.175, 0.05, 0.05);\n    vec3 box1Pos = (boxPosNew - vec3(0.375, 0., 0.));\n    float box1Dist = sdBox(box1Pos, box1Size);\n    \n    vec3 box2Pos = (boxPosNew - vec3(0.25, 0., 0.125));\n    box2Pos = RotY(box2Pos, PI*0.5);\n    float box2Dist = sdBox(box2Pos, box1Size);\n    \n    vec3 box3Pos = (boxPosNew - vec3(0.125, 0., 0.25));\n    float box3Dist = sdBox(box3Pos, box1Size);\n    \n    vec3 box4Pos = (boxPosNew - vec3(0., 0., 0.375));\n    box4Pos = RotY(box4Pos, PI*0.5);\n    float box4Dist = sdBox(box4Pos, box1Size);\n    \n    float boxesDist = min(min(min(box1Dist, box2Dist), box3Dist), box4Dist);\n    return boxesDist;\n}\nfloat arm2Dist(vec3 boxPosNew)\n{\n    vec3 box1Size = vec3(0.175, 0.05, 0.05);\n    vec3 box1Pos = (boxPosNew + vec3(0.375, 0., 0.));\n    float box1Dist = sdBox(box1Pos, box1Size);\n    \n    vec3 box2Pos = (boxPosNew + vec3(0.25, 0.125, 0.));\n    box2Pos = RotY(box2Pos, PI*0.5);\n    box2Pos = RotZ(box2Pos, PI*0.5);\n    float box2Dist = sdBox(box2Pos, box1Size);\n    \n    vec3 box3Pos = (boxPosNew + vec3(0.125, 0.25, 0.));\n    float box3Dist = sdBox(box3Pos, box1Size);\n    \n    vec3 box4Pos = (boxPosNew + vec3(0., 0.375, 0.));\n    box4Pos = RotY(box4Pos, PI*0.5);\n    box4Pos = RotZ(box4Pos, PI*0.5);\n    float box4Dist = sdBox(box4Pos, box1Size);\n    \n    float boxesDist = min(min(min(box1Dist, box2Dist), box3Dist), box4Dist);\n    return boxesDist;\n}\nfloat arm3Dist(vec3 boxPosNew)\n{\n    vec3 box1Size = vec3(0.175, 0.05, 0.05);\n    vec3 box1Pos = (boxPosNew - vec3(0., 0.375, 0.));\n    box1Pos = RotZ(box1Pos, PI*0.5);\n    float box1Dist = sdBox(box1Pos, box1Size);\n    \n    vec3 box2Pos = (boxPosNew - vec3(0., 0.25, -0.125));\n    box2Pos = RotY(box2Pos, PI*0.5);\n    float box2Dist = sdBox(box2Pos, box1Size);\n    \n    vec3 box3Pos = (boxPosNew - vec3(0., 0.125, -0.25));\n    box3Pos = RotZ(box3Pos, PI*0.5);\n    float box3Dist = sdBox(box3Pos, box1Size);\n    \n    vec3 box4Pos = (boxPosNew + vec3(0., 0., 0.375));\n    box4Pos = RotY(box4Pos, PI*0.5);\n    float box4Dist = sdBox(box4Pos, box1Size);\n    \n    float boxesDist = min(min(min(box1Dist, box2Dist), box3Dist), box4Dist);\n    return boxesDist;\n}","name":"Common","description":"","type":"common"}]}