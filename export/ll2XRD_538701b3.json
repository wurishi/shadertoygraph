{"ver":"0.1","info":{"id":"ll2XRD","date":"1442228171","viewed":201,"name":"Minkowski","username":"denosya","description":"added envmap","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dojo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float zNear = 1.0;\nconst float zFar  = 400.0;\n\n\nfloat minkowskiLength(vec3 v, float d) {\n    v = abs(v);\n\treturn pow(pow(v.x,d)+pow(v.y,d)+pow(v.z,d), 1.0/d);\n}\n\nfloat debug;\n\nfloat map(in vec3 m) {\n    \n\tvec3 sphereCenter = vec3(cos(iTime)*4.0, 0.0, 12.0);\n    float radius = 4.0+sin(iTime)*2.0;\n\n \t sphereCenter = vec3(0.0, 0.0, 25.0);\n     radius = 8.0;\n\n    float timeDistortion = 0.5;\n    float distordedTime = pow(mod(iTime, pow(3.1415*2.0, 1.0/timeDistortion)), timeDistortion);\n    float dim = 12.0 + cos(distordedTime)*10.0;\n    \n    return minkowskiLength(m - sphereCenter, dim) - radius;\n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<50; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = dot(normal, -lightRay);\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), 20.0);\n    \n    vec3 diffuseComponent = vec3(1.0, 0.0, 0.0) * diffuse;\n    vec3 hilightComponent = vec3(1.0, 1.0, 1.0) * hilight;    \n    vec3 ambiantComponent = vec3(0.2, 0.0, 0.0);       \n    \n    vec3 reflectray = reflect(m-eye, normal);\n    vec3 envmap \t= texture( iChannel0, reflectray).xyz;\n    \n    vec3 sphereColor = diffuseComponent + hilightComponent + ambiantComponent;\n    \n    return vec4(mix(sphereColor, envmap, 0.9), 1.0);\n}\n\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n    \n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= vec3(-15.0*cos(iTime), 25.0*cos(iTime/3.0), -5.0);\n    \n    light.xy=vec2(10,10);\n    \n    vec3\tm;\n    \n    if(rayMarching(eye, ray, m)) {\n        \n        vec3 normal = computeNormal(m);\n        \n        fragColor = computeColor(ray, m, normal, light, eye);\n       // fragColor =vec4(debug);\n    }\n    else {\n        fragColor = vec4(0.0, 0, 0, 1.0);        \n    }\n}","name":"Image","description":"","type":"image"}]}