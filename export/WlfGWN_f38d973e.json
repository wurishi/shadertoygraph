{"ver":"0.1","info":{"id":"WlfGWN","date":"1556380917","viewed":184,"name":"Equithirds","username":"fizzer","description":"A recreation of the \"Equithirds\" substitution-based tiling from here: [url]http://tilings.math.uni-bielefeld.de/substitution/equithirds/[/url].\nDrag with the mouse to change the number of iterations.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["tiling","substitution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://tilings.math.uni-bielefeld.de/substitution/equithirds/\n\nfloat th = 3.14159265358979323 / 3.;\nfloat sidelength = 1., r, h;\n\nvec2 n, n2, n3;\n\nvec2 tri1(vec2 p)\n{\n    p.x = abs(p.x);\n    if(dot(p, n) > 0.)\n        p = reflect(p, n);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set up constants\n    \n    n = vec2(cos(th), sin(th));\n    n2 = vec2(cos(-th / 2.), sin(-th / 2.));\n    n3 = vec2(cos(th / 2.), sin(th / 2.));\n\n    r = sidelength / 2. / cos(th / 2.);\n    h = cos(th) * r;\n\n    // Coordinate mapping\n    \n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv.xy / 5.;\n\n    p.x += iTime / 20.;\n    \n    float w = 2. * r + sin(th / 2.) * r * 2.;\n\n    // Divide frame in to a grid of hexgons, and divide each of\n    // those hexagons in to six triangles.\n    \n    p.x = mod(p.x, w) - w / 2.;\n    p.y = fract(p.y) - .5;\n    p = abs(p);\n\n    if(dot(p, n2) > 0.)\n        p = reflect(p, n2);\n\n    if(p.y > .5)\n        p.y = 1. - p.y;\n    \n    if(dot(p, n3) < 0.)\n        p = reflect(p, n3);\n\n    p *= (r + h) * 2.;\n    p.y = r - p.y;\n\n\n\n    float tritype = 0.;\n    float prevtritype = tritype;\n\n    float scale = length(fwidth(uv.xy / 2.));\n\n    // Recursively classify the sample point and subdivide\n    \n    int iterations = 7;\n    \n    if(iMouse.z > .5)\n        iterations = 3 + int(iMouse.y / iResolution.y * 6.);\n    \n    for(int i = 0; i < iterations; ++i)\n    {\n        prevtritype = tritype;\n        \n        if(tritype < .5)\n        {\n            p = tri1(p);\n            tritype = 1.;\n        }\n        else\n        {\n            p.x = abs(p.x);\n            \n            if(p.x < -p.y / tan(th))\n            {\n                float base = h / tan(th) * 2.;\n                p /= base;\n                scale /= base;\n                p.y += r;\n                tritype = 0.;\n            }\n            else\n            {\n                p = vec2(dot(p, vec2(n.y, -n.x)), -dot(p, n));\n                p /= r;\n                scale /= r;\n                p.x -= .5;\n                p.y -= h;\n                tritype = 1.;\n            }\n        }\n    }\n\n    float ss = scale * 20., d = 0.;\n\n    if(tritype > .5)\n    {\n        d = min(abs(p.y + h), min(abs(dot(p, n)), abs(dot(p, vec2(-n.x, n.y)))));\n    }\n    else\n    {\n        p = tri1(p);\n        d = abs(p.y + h);\n    }\n\n    // Shade according to which triangle type the point is contained by.\n    \n    fragColor.rgb = mix(vec3(.25, .25, 1) / 2., vec3(1, 1, .5), step(.5, tritype)) *\n        \t\t\t\tsmoothstep(0., .03 * ss, d - .01 * ss);\n\n    // Gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}