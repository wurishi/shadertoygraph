{"ver":"0.1","info":{"id":"mt2GzK","date":"1673571649","viewed":194,"name":"Shiny Cubes","username":"Pyromican","description":"Figuring out reflections.\nUpdate: Added Anti-aliasing\n           Change the condition on line 237 to turn Anti-aliasing on or off (aaON/aaOFF)\n\nIf y'all got any suggestions or tips in general feel free to post a comment below :D","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["cubes","reflections","learning","shiny","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_RAYMARCH_STEPS = 500;\nconst float nearPlane = 0.0001;\nconst float farPlane = 100.0;\nconst float PI = 3.1415926535;\nconst float GAMMA = 2.2;\nconst int aaON = 4;\nconst int aaOFF = 1;\n\nvec3 camera = vec3(0.0, 0.0, 5.0);\nvec3 col = vec3(0.0);\n\nfloat attConst = 1.0;\nfloat attLinear = 0.0035f;\nfloat attQuad = 0.0005f;\n\nstruct Material\n{\n    vec3 ambientCol;\n    vec3 diffCol;\n    vec3 specCol;\n    float alpha;\n};\n\nstruct Surface\n{\n    float sd;\n    vec3 color;\n    Material mat;\n};\n\n//----------Materials----------//\nMaterial Brass()\n{\n    vec3 a = vec3(0.07690, 0.037028, 0.0);\n    vec3 d = vec3(0.57955, 0.288815, 0.00837);\n    vec3 s = vec3(0.98283, 0.875137, 0.62535);\n    float alpha = 38.0;\n    return Material(a, d, s, alpha);\n}\n\nMaterial Cyan()\n{\n    vec3 a = vec3(0.00155, 0.00137, 0.00255);\n    vec3 d = vec3(0.02377, 0.12027, 0.13769);\n    vec3 s = vec3(0.088845, 0.55, 0.55);\n    float alpha = 55.0;\n    return Material(a, d, s, alpha);\n}\n\nMaterial Pink()\n{\n    vec3 a = vec3(0.07, 0.025, 0.025);\n    vec3 d = vec3(0.45, 0.23, 0.23);\n    vec3 s = vec3(0.85, 0.85, 0.85);\n    float alpha = 42.0;\n    \n    return Material(a, d, s, alpha);\n}\n\nMaterial Checkerboard(vec3 p)\n{\n    vec3 a = vec3(mod(floor(p.x * 3.0) + floor(p.z * 2.0), 2.0)) * 0.5; //mod 2.0 with a floor will force it to either be 0.0(black) or 1.0(white)\n    vec3 d = vec3(a * 0.2);\n    vec3 s = vec3(0.2);\n    float alpha = 100.0;    \n    return Material(a, d, s, alpha);\n}\n\n//----------Fract----------//\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n//----------Signed Distance Fields----------//\nSurface SDFfloor(vec3 p, vec3 color, Material mat) // Waves\n{\n    float d = p.y - (0.5 * sin(p.z + iTime) - 0.5 * sin(p.x + iTime)) / 2.0 + 1.0;\n    return Surface(d, color, mat);\n}\n\nSurface SDFplane(vec3 p, vec3 color, Material mat) // Flat\n{\n    float d = p.y + 1.0;\n    return Surface(d, color, mat);\n}\n\nSurface SDFsphere(vec3 p, float radius, vec3 move, vec3 color, Material mat)\n{\n    float d = length(p - move) - radius;    \n    return Surface(d, color, mat);\n}\n\nSurface SDFbox(vec3 p, vec3 rect, vec3 move, vec3 color, Material mat)\n{\n    float c = cos(iTime * 0.75);\n    float s = sin(iTime * 0.75);\n    \n    mat3 rotZ = mat3(c, -s, 0.0,\n                     s,  c, 0.0,\n                     0.0, 0.0, 1.0);\n\n    mat3 rotY = mat3(c, 0.0, s,\n                     0.0, 1.0, 0.0,\n                     -s, 0.0, c);                       \n                                          \n    mat3 rotX = mat3(1.0, 0.0, 0.0,\n                     0.0, c, -s,\n                     0.0, s,  c);\n                     \n    p = p - move;\n    p *= rotY * rotZ;\n    float d = length(max(abs(p) - rect, 0.0)) - 0.01;\n    return Surface(d, color, mat);\n}\n\nSurface minObjectDistance(Surface obj1, Surface obj2)\n{\n    if (obj1.sd < obj2.sd)\n        return obj1;        \n    return obj2;\n}\n\nSurface map(vec3 p)\n{\n    Surface d;\n    Surface box = SDFbox(p, vec3(0.75), vec3(0.0, 0.5, -1.0), vec3(0.0), Cyan());\n    Surface box2 = SDFbox(p, vec3(0.25), vec3(-2.5 * sin(iTime * 0.5), 0.5 , -2.5 * cos(iTime * 0.5)), vec3(0.0), Pink());\n    Surface sphere = SDFsphere(p, 0.25, vec3(-2.5 * -cos(iTime * 0.5), 0.5 , -2.5 * sin(iTime * 0.5)), vec3(0.0), Brass());\n    Surface scene = minObjectDistance(box, box2);\n    Surface scene2 = minObjectDistance(scene, sphere);\n    return minObjectDistance(scene2, SDFplane(p, vec3(0.0), Checkerboard(p)));\n}\n\n//----------Normals----------//\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0001;    \n    return normalize (e.xyy * map(p + e.xyy).sd +\n                      e.yyx * map(p + e.yyx).sd +\n                      e.yxy * map(p + e.yxy).sd +\n                      e.xxx * map(p + e.xxx).sd);\n}\n\n//----------Ray Marching Methods----------//\nSurface rayMarch(vec3 ro, vec3 rd)\n{\n    float depth = nearPlane; //Starting depth\n    Surface d;\n\n    for(int i = 0; i < MAX_RAYMARCH_STEPS; i++)\n    {\n        vec3 p = ro + rd * depth;\n        vec3 n = calcNormal(p);\n        d = map(p); // Calculates the SDF\n        depth += d.sd;// adds the SDF to the length of the ray\n        \n        if (d.sd < nearPlane || depth > farPlane)\n            break;\n    }   \n    d.sd = depth;\n    return d;\n}\n\nfloat softShadow(vec3 fragPos, vec3 lightPos)\n{\n    float res = 1.0;\n    float depth = 0.01; //Artifacts appear if you start lower\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++)\n    {\n        float d = map(fragPos + lightDir * depth).sd;\n        res = min(res, (d * 5.0) / depth);\n        depth += d;\n        \n        if (d < nearPlane || depth > farPlane) //the lower limit of \"d\" needs to be lower than the one in the rayMarch function to avoid having a streak of light on overlapping shadows.\n            break;\n    }\n    return clamp(res, 0.02, 1.0 ); //clamps the res value between nonzero numbers so it doesn't black out everything\n}\n\nfloat AmbientOcclusion(vec3 fragPos, vec3 normal)\n{\n    float occ = 0.0;\n    float weight = 1.0;\n    for(int i = 0; i < 8; i++)\n    {\n        float len = 0.01 + 0.02 * float(i * i);\n        vec3 p = fragPos + normal * len;\n        float dist = map(p).sd;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\n//----------BRDF (Blinn Phong)----------//\nvec3 BlinnPhong(vec3 normal, vec3 lightPos, vec3 fragPos, Material mat)\n{ \n    //ambient\n    float occ = AmbientOcclusion(fragPos, normal);\n    vec3 ambient = mat.ambientCol;\n    //return vec3(0.9) * occ; //Occlusion test\n    \n    //diffuse\n    vec3 lightDir = normalize(lightPos - fragPos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * mat.diffCol;\n    \n    //specular with normalization\n    vec3 reflectDir = reflect(-lightDir, normal);\n    vec3 viewDir = normalize(camera - fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = max(dot(normal, halfwayDir), 0.0);\n    spec = pow(spec, mat.alpha) * ((mat.alpha + 2.0) / (4.0 * PI * (2.0 - exp(-mat.alpha/2.0))));\n    vec3 specular = spec * mat.specCol;\n    \n    //phong\n    return (ambient*occ + diffuse + specular*occ);\n}\n\n//----------Anti-Aliasing----------//\n// Takes four evenly spaced supersamples in each pixel\nvec2 RGSS(int num)\n{\n    if (num == 0) return vec2(0.125, 0.375);\n    if (num == 1) return vec2(-0.125, -0.375);\n    if (num == 2) return vec2(0.375, -0.125);\n    else return vec2(-0.375, 0.125);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 background;\n    Surface d;\n    int i;\n    \n    for (i = 0; i < aaOFF; i++) //Change condition to turn Anti-aliasing on and off with \"aaON\" or \"aaOFF\"\n    {\n        vec2 uv = ((fragCoord + RGSS(i)) - 0.5 * iResolution.xy)/iResolution.y; //aspect ratio       \n        vec3 rd = normalize(vec3(uv, -1.0)); //Turns the uv into a 3D vector by making it point outwards\n        //background = vec3(0.65, 0.85, 1.0) + uv.y * 0.75;\n        background = mix(vec3(1.0, 0.75, 0.5), vec3(0.65, 0.85, 1.0), uv.y + 0.55);\n        //background = vec3(0.0);\n\n        d = rayMarch(camera, rd);\n        Material shine = d.mat;\n        float attenuation = 1.0 / (attConst + attLinear * d.sd + attQuad * d.sd * d.sd); //inverse square law\n        vec3 fragPos = camera + rd * d.sd;\n        vec3 normal = vec3(calcNormal(fragPos));\n        vec3 reflectDir = reflect(rd, normal);\n        vec3 lightPos = vec3(10.0 * cos(iTime), 10.0, 10.0);\n\n        if (d.sd <= farPlane)\n        {   \n            //Fresnel - Makes the surface more reflective the more the frag is angled away from the camera\n            float fresnel = clamp(pow(1.0 - dot(normal, -rd), 5.0), 0.2, 1.0);\n\n            //Reflections - Adds the reflections to the colors before running through the BRDF\n            for (int i = 0; i < 1; i++)\n            {\n                Surface bounce = rayMarch(fragPos + normal * 0.003, reflectDir);\n                if (bounce.sd <= farPlane)\n                    shine = Material(shine.ambientCol + bounce.mat.ambientCol * fresnel, shine.diffCol + bounce.mat.diffCol * fresnel, shine.specCol + bounce.mat.specCol * fresnel, shine.alpha);\n\n                else\n                    shine = Material(shine.ambientCol + background * fresnel, shine.diffCol + background * fresnel, shine.specCol + background * fresnel, shine.alpha);\n                reflectDir = reflect(reflectDir, normal);\n            }\n\n            //Blinn-Phong + softshadows\n            vec3 b_phong = BlinnPhong(normal, lightPos, fragPos, shine);\n            float softShadow = softShadow(fragPos + normal * 0.003, lightPos);\n            col += b_phong * softShadow * attenuation ;\n        }\n        else col += background; //Rays go into the v o i d ~\n    }\n    \n    col /= float(i);\n    col = mix(col, background, 1.0 - exp(-0.00001 * d.sd * d.sd * d.sd)); //fog\n    fragColor.rgb = pow(col.rgb, vec3(1.0/GAMMA));\n}\n","name":"Image","description":"","type":"image"}]}