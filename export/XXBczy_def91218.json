{"ver":"0.1","info":{"id":"XXBczy","date":"1727363869","viewed":34,"name":"ifinite zoom and cubic","username":"nayk","description":"originals https://www.shadertoy.com/view/XXjcWD","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159;\nconst float pi2 = pi * 2.;\nconst vec2 cellSizePixels = vec2(192.,192.);\nfloat edgeSizePixels = 2.5;\nconst float iterations = 5.;\n\nvec2 q(vec2 x, vec2 p) {\n    return floor(x/p)*p;\n}\n\nconst float zoomSpeed = 0.5; // how fast to zoom (negative to zoom out)\nconst float zoomScale = 0.3; // how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount = 6; // how deep to recurse\nconst int glyphSize = 3; // width & height of glyph in pixels\nconst float curvature = 0.6; // time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\nconst float e = 2.718281828459;\n\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c)\n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n   \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt ;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    i = (i+r) + (glyphPosLast.x + glyphPosLast.y + glyphPos.x + glyphPos.y);\n\n    vec3 myColor = vec3\n    (\n    mix(-0.3, 0.3, RandFloat(i)),\n    mix(0.0, 0.6, RandFloat(i + 10)),\n        mix(0.0, 0.6, RandFloat(i + 20))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    myColor.y = pow(myColor.y, 2.0);\n    myColor.z = pow(myColor.z, 2.0);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.01*iTime;\n   \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    float theta = 7.0*pi/4.0;\nfloat c = cos(theta);\nfloat s = sin(theta);\nuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n     \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\nivec2 glyphPosLast = GetFocusPos(-2);\nivec2 glyphPos =     GetFocusPos(-1);\nvec3 color = InitPixelColor();\n   \nfor (int r = 0; r <= recursionCount + 1; ++r)\n{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\nreturn color;\n           \n   \n\n        // get glyph and pos within that glyph\n\n       \n       \n        // next glyph\n\n}\n}\n \nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rand3(vec2 p) {\n    vec3 p2 = vec3(p, rand(p));\n    return fract(sin(vec3(\n        dot(p2,vec3(127.1,311.7,427.89)),\n        dot(p2,vec3(269.5,183.3,77.24)),\n        dot(p2,vec3(42004.33,123.54,714.24))\n    ))*43758.5453);\n}\n\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br) {\n    vec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\nmat2 rot2D(float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat pulse(float x, float pulseWidth, float totalPeriod) {\n    x = mod(x,totalPeriod);\n    x -= pulseWidth /= 2.;\n    return 1.-smoothstep(0.,pulseWidth, abs(x));\n}\n\n// New function to generate neon cyberpunk colors\nvec3 neonColor(float t) {\n    vec3 color1 = vec3(0.0, 1.0, 1.0);  // Cyan\n    vec3 color2 = vec3(1.0, 0.0, 1.0);  // Magenta\n    vec3 color3 = vec3(1.0, 1.0, 0.0);  // Yellow\n   \n    float t1 = fract(t);\n    float t2 = fract(t + 0.33333);\n    float t3 = fract(t + 0.66666);\n   \n    return color1 * smoothstep(0.0, 0.5, t1) * smoothstep(1.0, 0.5, t1) +\n           color2 * smoothstep(0.0, 0.5, t2) * smoothstep(1.0, 0.5, t2) +\n           color3 * smoothstep(0.0, 0.5, t3) * smoothstep(1.0, 0.5, t3);\n}\n\n// Glow effect\nvec3 neonGlow(vec3 color, float intensity) {\n    return color * intensity / (1.0 + length(color));\n}\n\nvoid mainImage(out vec4 o, in vec2 i) {\n    vec2 uv = i / iResolution.xy - .5;\n    vec2 uvn = uv;\n    uv += iMouse.xy * .1 / iResolution.xy;\n   \n    if(iResolution.x > iResolution.y)\n        uv.x *= iResolution.x / iResolution.y;\n    else\n        uv.y /= iResolution.x / iResolution.y;\n   \n   \n   \n    float rotation = -(iTime+40.)*0.008;\n    uv *= rot2D(rotation);\n\n    uv = InitUV(uv);\n    vec2 cPos = -1.0 + 2.0 * i.xy / iResolution.xy;\n   \n    // distance of current pixel from center\nfloat cLength = length(cPos);\n\nuv +=(cPos/cLength)*cos(cLength*1.0-iTime*4.0) * 0.03;\n    // time warp\n    float time = (iTime*1.1+length(dot(uv*2., uv*2.)));\n   \n    // BigWIngs - spinning\n    //float s = sin(time);\n//float c = cos(time);\n//uv *= mat2(-s, c, c, s);\n   \n// get time\nfloat timePercent = time*zoomSpeed;\nint iterations2 = int(floor(timePercent));\ntimePercent -= float(iterations2);\n\n// update zoom, apply pow to make rate constant\nfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\n   \n// get offset\nvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\nfor (int i = 0; i < 5; ++i)\noffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n   \n\n    uv*=  zoom + offset;\n    vec2 cellSize = cellSizePixels / iResolution.x;\n    vec2 cellOrig;\n    float cellID;\n    float edgeSizePixels = 7.;\n    for(float i = 0.; i < iterations; i++) {\n        cellSize *= .5;\n        edgeSizePixels *= .5;\n        cellOrig = q(uv, cellSize);\n        cellID = rand(cellOrig);\n        if(i/iterations > sin(cellID*6.28+iTime*.3)*.5+.3)\n            break;\n    }\n    edgeSizePixels = max(edgeSizePixels, 1.);\n   \n    float distToCenter = distance(uv, cellOrig+cellSize/2.)/(length(cellSize)/2.);\n    vec2 tl = cellOrig;\n    vec2 br = cellOrig + cellSize;\n    float distToEdge = sdAxisAlignedRect(uv, tl, br) / length(cellSize);\n   \n    float edgeSize = edgeSizePixels/iResolution.x/length(cellSize);\n    float aEdge = smoothstep(-edgeSize, 0., distToEdge);\n   \n    float totalPulsePeriod = 0.; // in seconds\n    float highlightDuration = 0.6;\n    float highlightStrength = 3.0;\n    float highlight = pulse((cellID*totalPulsePeriod*totalPulsePeriod)+iTime,highlightDuration,totalPulsePeriod)*highlightStrength+1.;\n   \n    // cell background\n    vec3 cellColor = neonColor(cellID + iTime * 0.1);\n    o = vec4(cellColor.rgb, 1.0) * 0.8;\n\n    o.rgb = neonGlow(o.rgb, 1.5);\n    o *= 1.-distToCenter*.3;\n   \n    // edge color\n    vec4 edgeColor = vec4(1.0, 1.0, 1.0, 1.0);\n    o = mix(o, edgeColor, aEdge);\n   \n    // saturation boost\n    o = clamp(o, 0., 1.);\n    o.rgb = mix(o.rgb, vec3(dot(o.rgb, vec3(0.299, 0.587, 0.114))), -0.7);\n   \n    // cyberpunk scan lines\n    float scanLine = sin(uvn.y * 500.0 + iTime * 5.0) * 0.05;\n    o.rgb += vec3(scanLine);\n   \n    // digital noise\n\n    // vignette\n\n    // color aberration\n    float aberration = 0.01;\n    o.r += texture(iChannel0, uv + vec2(aberration, 0.0)).r * 0.5;\n    o.b += texture(iChannel0, uv - vec2(aberration, 0.0)).b * 0.5;\n   \n    // gamma\n    o = clamp(o,0.,1.);\n    o = pow(o, vec4(1./1.1));\n}\n\n","name":"Image","description":"","type":"image"}]}