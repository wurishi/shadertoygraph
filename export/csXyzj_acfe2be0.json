{"ver":"0.1","info":{"id":"csXyzj","date":"1687671887","viewed":50,"name":"Motionblur - rgbguy","username":"rgbGuy","description":"This is inefficient. Needs optimisation.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["motionblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    \n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 2.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 2.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color1 = texture(iChannel1, uv);\n    vec4 Color2 = texture(iChannel2, uv);\n    vec4 Color3 = texture(iChannel3, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor1 += texture( iChannel1, uv+vec2(cos(d),sin(d))*Radius*i);\t\n\t\t\tColor2 += texture( iChannel2, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n\t\t\tColor3 += texture( iChannel3, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    Color1 /= Quality * Directions - 15.0;\n    Color2 /= Quality * Directions - 15.0;\n    Color3 /= Quality * Directions - 15.0;\n\n    // Time varying pixel color\n    vec3 col =  texture(iChannel0, uv).rgb*0.5+\n                Color1.rgb*0.3+\n                Color2.rgb*0.15+\n                Color3.rgb*0.05\n                ;\n                \n    if(texture(iChannel0, uv).r > 0.01) col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 500\n#define SURF_DIST 0.01\n#define ZFAR 10.\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat smoothMin(float a, float b, float k)\n{\n    return -smoothMax(-a, -b, k);\n}\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir; // this shouldn't be normalized as it is the point in space from which the ray passes\n};\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 c)\n{\n    return p.y - c.y;\n}\n\nfloat boxSDF(vec3 p, vec3 c, vec3 R)\n{\n    return length(max(abs(p - c) - R, 0.0));\n}\n\nfloat sceneSDF(vec3 p) {\n    float delta = 0.0;\n\n    return sphereSDF(p, vec3(0., 0.4 * sin(4. * iTime - delta), 2), 0.3);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.01);\n    vec3 n = vec3(sceneSDF(p)) - vec3(sceneSDF(p - e.yxx),\n        sceneSDF(p - e.xyx),\n        sceneSDF(p - e.xxy));\n    return normalize(n);\n}\n\nfloat RayMarch(Ray r) {\n\n    float D = 0.;\n    vec3 p = vec3(0);\n\n    for (float i = 0.; i < float(MAX_STEPS); i = i + 1.)\n    {\n        p = r.ori + D * r.dir;\n        float dS = sceneSDF(p);\n        D = D + dS;\n        if (dS < SURF_DIST || D > ZFAR) break;\n    }\n\n    return D;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 2., -2);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float intensity = clamp(dot(n, lightDir), 0., 1.);\n\n    // shadows\n    float d = RayMarch(Ray(p + n * SURF_DIST * 2., lightDir));\n    //if (d < length(lightPos - p)) intensity *= 0.1;\n\n    return intensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.y) - vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    Ray ray = Ray(vec3(0), vec3(uv, 1.));\n    vec3 col = vec3(0.1);\n\n    float d = RayMarch(ray);\n    vec3 pointOnSurface = ray.ori + d * ray.dir;\n\n    float light = GetLight(pointOnSurface);\n\n    vec3 normal = getNormal(pointOnSurface);\n\n    col = vec3(light);\n\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_STEPS 500\n#define SURF_DIST 0.01\n#define ZFAR 10.\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat smoothMin(float a, float b, float k)\n{\n    return -smoothMax(-a, -b, k);\n}\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir; // this shouldn't be normalized as it is the point in space from which the ray passes\n};\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 c)\n{\n    return p.y - c.y;\n}\n\nfloat boxSDF(vec3 p, vec3 c, vec3 R)\n{\n    return length(max(abs(p - c) - R, 0.0));\n}\n\nfloat sceneSDF(vec3 p) {\n    float delta = 0.1;\n\n    return sphereSDF(p, vec3(0., 0.4 * sin(4. * iTime - delta), 2), 0.3);\n\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.01);\n    vec3 n = vec3(sceneSDF(p)) - vec3(sceneSDF(p - e.yxx),\n        sceneSDF(p - e.xyx),\n        sceneSDF(p - e.xxy));\n    return normalize(n);\n}\n\nfloat RayMarch(Ray r) {\n\n    float D = 0.;\n    vec3 p = vec3(0);\n\n    for (float i = 0.; i < float(MAX_STEPS); i = i + 1.)\n    {\n        p = r.ori + D * r.dir;\n        float dS = sceneSDF(p);\n        D = D + dS;\n        if (dS < SURF_DIST || D > ZFAR) break;\n    }\n\n    return D;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 2., -2);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float intensity = clamp(dot(n, lightDir), 0., 1.);\n\n    // shadows\n    float d = RayMarch(Ray(p + n * SURF_DIST * 2., lightDir));\n    //if (d < length(lightPos - p)) intensity *= 0.1;\n\n    return intensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.y) - vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    Ray ray = Ray(vec3(0), vec3(uv, 1.));\n    vec3 col = vec3(0.1);\n\n    float d = RayMarch(ray);\n    vec3 pointOnSurface = ray.ori + d * ray.dir;\n\n    float light = GetLight(pointOnSurface);\n\n    vec3 normal = getNormal(pointOnSurface);\n\n    col = vec3(light + 0.2);\n\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define MAX_STEPS 500\n#define SURF_DIST 0.01\n#define ZFAR 10.\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat smoothMin(float a, float b, float k)\n{\n    return -smoothMax(-a, -b, k);\n}\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir; // this shouldn't be normalized as it is the point in space from which the ray passes\n};\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 c)\n{\n    return p.y - c.y;\n}\n\nfloat boxSDF(vec3 p, vec3 c, vec3 R)\n{\n    return length(max(abs(p - c) - R, 0.0));\n}\n\nfloat sceneSDF(vec3 p) {\n    float delta = 0.2;\n\n    return sphereSDF(p, vec3(0., 0.4 * sin(4. * iTime - delta), 2), 0.3);\n\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.01);\n    vec3 n = vec3(sceneSDF(p)) - vec3(sceneSDF(p - e.yxx),\n        sceneSDF(p - e.xyx),\n        sceneSDF(p - e.xxy));\n    return normalize(n);\n}\n\nfloat RayMarch(Ray r) {\n\n    float D = 0.;\n    vec3 p = vec3(0);\n\n    for (float i = 0.; i < float(MAX_STEPS); i = i + 1.)\n    {\n        p = r.ori + D * r.dir;\n        float dS = sceneSDF(p);\n        D = D + dS;\n        if (dS < SURF_DIST || D > ZFAR) break;\n    }\n\n    return D;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 2., -2);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float intensity = clamp(dot(n, lightDir), 0., 1.);\n\n    // shadows\n    float d = RayMarch(Ray(p + n * SURF_DIST * 2., lightDir));\n    //if (d < length(lightPos - p)) intensity *= 0.1;\n\n    return intensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.y) - vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    Ray ray = Ray(vec3(0), vec3(uv, 1.));\n    vec3 col = vec3(0.1);\n\n    float d = RayMarch(ray);\n    vec3 pointOnSurface = ray.ori + d * ray.dir;\n\n    float light = GetLight(pointOnSurface);\n\n    vec3 normal = getNormal(pointOnSurface);\n\n    float sdfOnSurface = sceneSDF(pointOnSurface);\n    float sdfOnSide = sceneSDF(pointOnSurface + vec3(0.1, 0, 0));\n\n    col = vec3(light + 0.2);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define MAX_STEPS 500\n#define SURF_DIST 0.01\n#define ZFAR 10.\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat smoothMin(float a, float b, float k)\n{\n    return -smoothMax(-a, -b, k);\n}\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir; // this shouldn't be normalized as it is the point in space from which the ray passes\n};\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat planeSDF(vec3 p, vec3 c)\n{\n    return p.y - c.y;\n}\n\nfloat boxSDF(vec3 p, vec3 c, vec3 R)\n{\n    return length(max(abs(p - c) - R, 0.0));\n}\n\nfloat sceneSDF(vec3 p) {\n    float delta = 0.3;\n    return sphereSDF(p, vec3(0., 0.4 * sin(4. * iTime - delta), 2), 0.3);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.01);\n    vec3 n = vec3(sceneSDF(p)) - vec3(sceneSDF(p - e.yxx),\n        sceneSDF(p - e.xyx),\n        sceneSDF(p - e.xxy));\n    return normalize(n);\n}\n\nfloat RayMarch(Ray r) {\n\n    float D = 0.;\n    vec3 p = vec3(0);\n\n    for (float i = 0.; i < float(MAX_STEPS); i = i + 1.)\n    {\n        p = r.ori + D * r.dir;\n        float dS = sceneSDF(p);\n        D = D + dS;\n        if (dS < SURF_DIST || D > ZFAR) break;\n    }\n\n    return D;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 2., -2);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float intensity = clamp(dot(n, lightDir), 0., 1.);\n\n    // shadows\n    float d = RayMarch(Ray(p + n * SURF_DIST * 2., lightDir));\n    //if (d < length(lightPos - p)) intensity *= 0.1;\n\n    return intensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.y) - vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    Ray ray = Ray(vec3(0), vec3(uv, 1.));\n    vec3 col = vec3(0.1);\n\n    float d = RayMarch(ray);\n    vec3 pointOnSurface = ray.ori + d * ray.dir;\n\n    float light = GetLight(pointOnSurface);\n\n    vec3 normal = getNormal(pointOnSurface);\n\n    col = vec3(light + 0.2);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}