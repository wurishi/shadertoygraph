{"ver":"0.1","info":{"id":"XfsczS","date":"1721256999","viewed":73,"name":"[steve] SDF Editor with color","username":"import_shader_steve","description":"Fork of [steve] SDF Editor, but added more color","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["3d","sdf","color","editor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define SURF_DIST 0.01\n#define MAX_DIST 100.\n#define PI 3.14159\n\n// id:\n// 0 - nothing\n// 1 - ground\n// 2 - box 1\n\nstruct HitInfo {\n    float d;\n    vec3 color;\n    float id;\n};\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nHitInfo sdBox( vec3 p, vec3 b, vec3 color, float id )\n{\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return HitInfo(d, color, id);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nHitInfo sdGround(vec3 p, vec3 color, float id) {\n    float d = p.y;\n    return HitInfo(d, color, id);\n}\n\nHitInfo minHit(HitInfo a, HitInfo b) {\n    if (a.d < b.d) return a;\n    else return b;\n}\n\nHitInfo GetDist(vec3 p) {\n    // scene, start from nothing\n    HitInfo hScene = HitInfo(MAX_DIST, NOTHING_COLOR, 0.);\n    // ground\n    vec3 pGround = vec3(0., 0., 0.);\n    HitInfo hGround = sdGround(p - pGround, vec3(1.), 1.);\n    hScene = minHit(hScene, hGround);\n    // box\n    vec3 pBox = vec3(0., 1., 0.);\n    HitInfo hBox = sdBox(p - pBox, vec3(1.), vec3(1.), 2.);\n    hScene = minHit(hScene, hBox);\n    \n    return hScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    HitInfo h = GetDist(p);\n    vec3 n = h.d - vec3(\n        GetDist(p - e.xyy).d,\n        GetDist(p - e.yxy).d,\n        GetDist(p - e.yyx).d\n    );\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    // LIGHT_POSITION.xz = vec2(sin(iTime*2.), cos(iTime*2.)) * 5.;\n    vec3 lv = normalize(LIGHT_POSITION - p);\n    vec3 nv = GetNormal(p);\n    float nl = dot(lv, nv);\n    float diffuse = clamp(nl, 0., 1.);\n    float ambient = 0.5;\n    \n    float final = clamp(diffuse + ambient, 0., 1.);\n    return final;\n}\n\nHitInfo RayMarch(vec3 ro, vec3 rd) {\n    HitInfo h0 = HitInfo(0., NOTHING_COLOR, 0.);\n    for (int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * h0.d;\n        HitInfo hs = GetDist(p);\n        h0.d += hs.d;\n        h0.color = hs.color;\n        h0.id = hs.id;\n        if (hs.d < SURF_DIST || h0.d > MAX_DIST) break;\n    }\n    return h0;\n}\n\nfloat GetShadow(vec3 p) {\n    vec3 rd = normalize(LIGHT_POSITION - p);\n    vec3 pOffset = p + GetNormal(p) * SURF_DIST * 2.;\n    float ds = RayMarch(pOffset, rd).d;\n    float dl = length(p - LIGHT_POSITION);\n    if (ds < dl) {\n        return 0.3;\n    } else {\n        return 1.;\n    }\n}\n\n// input camera position, lookAt point, & zoomFactor, output camera ray direction\nvec3 makeCamera(vec3 ro, vec3 lookAt, float zoomFactor, vec2 uv) {\n    vec3 fVect = normalize(lookAt - ro);\n    vec3 rVect = normalize(cross(vec3(0., 1., 0.), fVect));\n    vec3 uVect = normalize(cross(fVect, rVect));\n    vec3 rd = normalize(uv.x * rVect + uv.y * uVect + zoomFactor * fVect);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy; //[0, 1]\n    vec3 col = vec3(0.);\n    \n    vec3 lookAt = vec3(1.);\n    lookAt = normalize(lookAt);\n    vec3 ro = lookAt + vec3( 4. * cos(7.0*-m.x), 3., 4. * sin(7.0*-m.x) );\n    // haven't taken into account the m.y\n    // maybe should normalize the two rotations in order to get rid of the weird \"zooming out\"\n    // effect in my previous \"Flappy Bird on a 3D Console\" code\n\n    float zoomFactor = 1.;\n    vec3 rd = makeCamera(ro, lookAt, zoomFactor, uv);\n    \n    HitInfo hit = RayMarch(ro, rd);\n    if (hit.d > MAX_DIST) {\n        col = BACKGROUND_COLOR;\n    } else {\n        vec3 p = ro + rd * hit.d;\n        float l = GetLight(p) * GetShadow(p);\n        vec3 diffuse = hit.color;\n        \n        if (hit.id == 2.) {\n            vec3 n = GetNormal(p);\n            // diffuse = n;\n            diffuse = texture(iChannel0, vec2(p.xz / 2. + 0.5)).rgb;\n            \n        }\n        \n        \n        col = diffuse * vec3(l);\n        //col = diffuse;\n    }\n    \n    \n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BACKGROUND_COLOR vec3(1., 169./256., 20./256.)\n#define NOTHING_COLOR vec3(0.)\n\nvec3 LIGHT_POSITION = vec3(2, 5, 10);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadValue( in ivec2 valueCoord )\n{\n    return texelFetch( iChannel0, valueCoord, 0 );\n}\n\nvoid storeValue( in ivec2 valueCoord, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( valueCoord.x == fragCoord.x && valueCoord.y == fragCoord.y ) \n    ? value : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}