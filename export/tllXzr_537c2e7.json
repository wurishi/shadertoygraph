{"ver":"0.1","info":{"id":"tllXzr","date":"1561931497","viewed":1276,"name":"GPU hacks #10 - NV Mesh Shader ","username":"PrzemyslawZaworski","description":"I've tested new OpenGL extensions for NVIDIA RTX GPUs: GL_NV_mesh_shader (it introduces new programmable shader types called Task and Mesh shaders) and GL_NV_fragment_shader_barycentric (which provides built-in variables holding barycentric weight vector)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","triangle","code"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nSave file as triangle.c and compile with Visual Studio command line:\ncl triangle.c opengl32.lib user32.lib gdi32.lib\nReferences:\nhttps://devblogs.nvidia.com/introduction-turing-mesh-shaders/\nhttps://www.khronos.org/registry/OpenGL/extensions/NV/NV_mesh_shader.txt\nhttps://www.khronos.org/registry/OpenGL/extensions/NV/NV_fragment_shader_barycentric.txt\n*/\n\n/*\n#include <windows.h>\n#include <GL/gl.h>\n#include <stdio.h>\n\n#define width 1280\n#define height 720\n\ntypedef GLuint(WINAPI *PFNGLCREATEPROGRAMPROC) ();\ntypedef GLuint(WINAPI *PFNGLCREATESHADERPROC) (GLenum t);\ntypedef void(WINAPI *PFNGLSHADERSOURCEPROC) (GLuint s, GLsizei c, const char*const*string, const GLint* i);\ntypedef void(WINAPI *PFNGLCOMPILESHADERPROC) (GLuint s);\ntypedef void(WINAPI *PFNGLATTACHSHADERPROC) (GLuint p, GLuint s);\ntypedef void(WINAPI *PFNGLLINKPROGRAMPROC) (GLuint p);\ntypedef void(WINAPI *PFNGLUSEPROGRAMPROC) (GLuint p);\ntypedef void(WINAPI *PFNGLGETSHADERIVPROC) (GLuint s, GLenum v, GLint *p);\ntypedef void(WINAPI *PFNGLGETSHADERINFOLOGPROC) (GLuint s, GLsizei b, GLsizei *l, char *i);\ntypedef void(WINAPI *PFNGLDRAWMESHTASKSNVPROC) (GLuint f, GLuint c);\n\nstatic const char* MeshShader = \\\n\t\"#version 450 \\n\"\n\t\"#extension GL_NV_mesh_shader : enable\\n\"\n\t\"layout(local_size_x = 3) in;\"\n\t\"layout(max_vertices = 64) out;\"\n\t\"layout(max_primitives = 126) out;\"\n\t\"layout(triangles) out;\"\n\t\"const vec3 vertices[3] = {vec3(-1,-1,0), vec3(1,-1,0), vec3(0,1,0)};\"\n\t\"void main()\"\n\t\"{\"\n\t\t\"uint id = gl_LocalInvocationID.x;\"\n\t\t\"gl_MeshVerticesNV[id].gl_Position = vec4(vertices[id], 2);\"\n\t\t\"gl_PrimitiveIndicesNV[id] = id;\"\n\t\t\"gl_PrimitiveCountNV = 1;\"\n\t\"}\";\n\t\nstatic const char* FragmentShader = \\\n\t\"#version 450 \\n\"\n\t\"#extension GL_NV_fragment_shader_barycentric : enable\\n\"\n\t\"out vec4 color;\"\n\t\"void main()\"\n\t\"{\"\t\n\t\t\"color = vec4(gl_BaryCoordNV, 1.0);\"\n\t\"}\";\n\t\nvoid Debug(int sh)\n{\n\tGLint isCompiled = 0;\n\t((PFNGLGETSHADERIVPROC)wglGetProcAddress(\"glGetShaderiv\"))(sh,0x8B82,&isCompiled);\n\tif(isCompiled == GL_FALSE)\n\t{\n\t\tGLint length = 0;\n\t\t((PFNGLGETSHADERIVPROC)wglGetProcAddress(\"glGetShaderiv\"))(sh,0x8B84,&length);\n\t\tGLsizei q = 0;\n\t\tchar* log = (char*)malloc(sizeof(char)*length);\n\t\t((PFNGLGETSHADERINFOLOGPROC)wglGetProcAddress(\"glGetShaderInfoLog\"))(sh,length,&q,log);\n\t\tif (length>1)\n\t\t{\n\t\t\tFILE *file = fopen (\"debug.log\",\"a\");\n\t\t\tfprintf (file,\"%s\\n%s\\n\",(char*)glGetString(0x8B8C),log);\n\t\t\tfclose (file);\n\t\t\tExitProcess(0);\n\t\t}\n\t}\n}\n\nint MakeShaders(const char* MS, const char* FS)\n{\n\tint p = ((PFNGLCREATEPROGRAMPROC)wglGetProcAddress(\"glCreateProgram\"))();\n\tint sm = ((PFNGLCREATESHADERPROC)wglGetProcAddress(\"glCreateShader\"))(0x9559);\t\n\tint sf = ((PFNGLCREATESHADERPROC)wglGetProcAddress(\"glCreateShader\"))(0x8B30);\t\n\t((PFNGLSHADERSOURCEPROC)wglGetProcAddress(\"glShaderSource\"))(sm,1,&MS,0);\n\t((PFNGLSHADERSOURCEPROC)wglGetProcAddress(\"glShaderSource\"))(sf,1,&FS,0);\t\n\t((PFNGLCOMPILESHADERPROC)wglGetProcAddress(\"glCompileShader\"))(sm);\n\t((PFNGLCOMPILESHADERPROC)wglGetProcAddress(\"glCompileShader\"))(sf);\t\n\t((PFNGLATTACHSHADERPROC)wglGetProcAddress(\"glAttachShader\"))(p,sm);\n\t((PFNGLATTACHSHADERPROC)wglGetProcAddress(\"glAttachShader\"))(p,sf);\t\n\t((PFNGLLINKPROGRAMPROC)wglGetProcAddress(\"glLinkProgram\"))(p);\n\tDebug(sm);\n\tDebug(sf);\n\treturn p;\n}\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif (uMsg==WM_CLOSE || uMsg==WM_DESTROY || (uMsg==WM_KEYDOWN && wParam==VK_ESCAPE))\n\t{\n\t\tPostQuitMessage(0); return 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"Mesh Shader Demo\"};\n\tRegisterClass(&win);\n\tHWND hwnd = CreateWindowEx(0, win.lpszClassName, \"Mesh Shader Demo\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, width, height, 0, 0, 0, 0);\n\tHDC hdc = GetDC(hwnd);\n\tPIXELFORMATDESCRIPTOR pfd = { 0,0,PFD_DOUBLEBUFFER };\n\tSetPixelFormat(hdc,ChoosePixelFormat(hdc,&pfd),&pfd);\n\twglMakeCurrent(hdc,wglCreateContext(hdc));\n\tint PS = MakeShaders(MeshShader,FragmentShader);\n\t((PFNGLUSEPROGRAMPROC)wglGetProcAddress(\"glUseProgram\"))(PS);\n\twhile (!exit)\n\t{\n\t\twhile(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif( msg.message==WM_QUIT ) exit = 1;\n\t\t\tTranslateMessage( &msg );\n\t\t\tDispatchMessage( &msg );\n\t\t}\n\t\tglClear(GL_COLOR_BUFFER_BIT);\n\t\t((PFNGLDRAWMESHTASKSNVPROC)wglGetProcAddress(\"glDrawMeshTasksNV\"))(0,1);\n\t\twglSwapLayerBuffers(hdc, WGL_SWAP_MAIN_PLANE);\n\t} \n\treturn 0;\n}\n*/\n\nvec3 barycentric(in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p0)\n{\n\tvec3 a = p2 - p3;\n\tvec3 b = p1 - p3;\n\tvec3 c = p0 - p3;\n\tfloat ab = a.x * b.x + a.y * b.y + a.z * b.z;\n\tfloat ac = a.x * c.x + a.y * c.y + a.z * c.z;\n\tfloat bc = b.x * c.x + b.y * c.y + b.z * c.z;\n\tfloat m = a.x * a.x + a.y * a.y + a.z * a.z;\n\tfloat n = b.x * b.x + b.y * b.y + b.z * b.z;\n\tfloat d = m * n - ab * ab;\n\tfloat u = (m * bc - ab * ac) / d;\n\tfloat v = (n * ac - ab * bc) / d;\n\tfloat w = 1.0 - u - v;\n    vec3 p = vec3(u,v,w);\n    return ((p.x >= 0.0) && (p.x <= 1.0) && (p.y >= 0.0) && (p.y <= 1.0) && (p.z >= 0.0) && (p.z <= 1.0)) ? p : vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * 2.0;   \n\tvec3 v0 = vec3(-1, -1, 0);\n\tvec3 v1 = vec3( 1, -1, 0);\n\tvec3 v2 = vec3( 0,  1, 0);\t\n\tvec3 color = barycentric(v0, v1, v2, vec3(uv, 0.0));\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}