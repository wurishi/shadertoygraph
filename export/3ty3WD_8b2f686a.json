{"ver":"0.1","info":{"id":"3ty3WD","date":"1580307615","viewed":112,"name":"Mountains and Snow","username":"nr4","description":"Mountains and Snow as shown in Unsafe by Team210 at Under Construction 2k19.\nYoutube: [url]https://www.youtube.com/watch?v=-Ci49Szvguk&feature=youtu.be[/url]\nPouet: [url]https://www.pouet.net/prod.php?which=84414[/url]","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["demoscene","mountains"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Mountains and Snow as shown in Unsafe by Team210 at Under Construction 2k19\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nconst float fsaa = 64.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*3./max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= fsaa;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Mountains and Snow as shown in Unsafe by Team210 at Under Construction 2k19\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\nvoid rand(in vec2 x, out float n)\n{\n    x += 400.;\n    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid lfnoise(in vec2 t, out float n)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1, v2;\n    rand(i, v1.x);\n    rand(i+c.xy, v1.y);\n    rand(i+c.yx, v2.x);\n    rand(i+c.xx, v2.y);\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    n = mix(v1.x, v1.y, t.x);\n}\n\nvoid lcfnoise(in vec2 t, out float n)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n//     t = mix(c.yy, c.xx, t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1, v2;\n    rand(i, v1.x);\n    rand(i+c.xy, v1.y);\n    rand(i+c.yx, v2.x);\n    rand(i+c.xx, v2.y);\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    n = mix(v1.x, v1.y, t.x);\n    n = 1.-2.*abs(.5-abs(n));\n}\n\nvoid mfnoise(in vec2 x, in float d, in float b, in float e, out float n)\n{\n    n = 0.;\n    float a = 1., nf = 0., buf;\n    for(float f = d; f<b; f *= 2.)\n    {\n        lcfnoise(f*x+.1*a, buf);\n        n += a*buf;\n        a *= e;\n        nf += 1.;\n    }\n    n *= (1.-e)/(1.-pow(e, nf));\n}\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nvoid hash22(in vec2 p, out vec2 d)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    d = fract((p3.xx+p3.yz)*p3.zy);\n}\n// End of CCA-SA\n\nvoid dist(in vec2 a, in vec2 b, out float d)\n{\n    d = length(b-a);\n}\n\nvoid nearest_controlpoint(in vec2 x, out vec2 p)\n{\n    float dmin = 1.e5, \n        d;\n    vec2 dp,\n        y = floor(x);\n    \n    float i = 0.;\n    for(float i = -1.; i <= 1.; i += 1.)\n        for(float j = -1.; j <= 1.; j += 1.)\n        {\n            hash22(y+vec2(i,j), dp);\n            dp += y+vec2(i,j);\n            dist(x, dp, d);\n            if(d<dmin)\n            {\n                dmin = d;\n                p = dp;\n            }\n        }\n}\n\nvoid dvoronoi(in vec2 x, out float d, out vec2 p, out float control_distance)\n{\n    d = 1.e4;\n    vec2 y,\n        dp;\n    \n    nearest_controlpoint(x, p);\n    y = floor(p);\n    \n    control_distance = 1.e4;\n    \n    for(float i = -2.; i <= 2.; i += 1.)\n        for(float j = -2.; j <= 2.; j += 1.)\n        {\n            if(i==0. && j==0.) continue;\n            hash22(y+vec2(i,j), dp);\n            dp += y+vec2(i,j);\n            vec2 o = p - dp;\n            float l = length(o);\n            d = min(d,abs(.5*l-dot(x-dp,o)/l));\n            control_distance = min(control_distance,.5*l);\n        }\n}\n\nvoid add(in vec2 sda, in vec2 sdb, out vec2 sdf)\n{\n    sdf = (sda.x<sdb.x)?sda:sdb;\n}\n\n// iq's smooth minimum\nvoid smoothmin(in float a, in float b, in float k, out float dst)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    dst = min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvoid scene(in vec3 x, out vec2 sdf)\n{\n    x.y += .3*iTime;\n    \n    float flo, fhi;\n    mfnoise(x.xy,1.,200.,.4, flo);\n    flo = .5+.5*flo;\n    flo = 2.*smoothstep(1.,0.,flo);\n    float dx;\n    lfnoise(x.y*c.xx, dx);\n    flo *= smoothstep(-.2,.2,abs(x.x-.3*dx));\n    \n    mfnoise(x.xy, 22., 2200., .75, fhi);\n    sdf = vec2(x.z-.4*flo+.003*fhi-.12*abs(x.x*x.x)+.1, 0.);\n}\n\nvoid normal(in vec3 x, out vec3 n, in float dx)\n{\n    vec2 s, na;\n    \n    scene(x,s);\n    scene(x+dx*c.xyy, na);\n    n.x = na.x;\n    scene(x+dx*c.yxy, na);\n    n.y = na.x;\n    scene(x+dx*c.yyx, na);\n    n.z = na.x;\n    n = normalize(n-s.x);\n}\n\nvoid floor_texture(in vec2 uv, in vec3 n, inout vec3 col)\n{\n    uv.y += .3*iTime;    \n    \n    float flo, fhi;\n    mfnoise(uv, 22., 2200., .7, fhi);\n    col = c.xxx;\n    col = mix(col, c.xyy, (.5+.5*fhi)*dot(n,c.yzy));\n\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set up coordinates and camera\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y,\n        s,\n        dsky_sphere;\n    uv *= .5;\n    vec3 col = c.xxx,\n        o0 = .3*c.yyx+1.*c.yzy,\n        o = o0,\n        r = c.xyy,\n        t = .3*c.yyx, \n        u = cross(normalize(t-o),-r),\n        dir,\n        n, \n        x,\n        c1 = c.yyy,\n        l;\n    int N = 450,\n        i;\n    float d = 0.,\n        dlower,\n        dupper;\n    t += uv.x * r + uv.y * u;\n    dir = normalize(t-o);\n    \n    d = -(o.z-.3)/dir.z;\n    \n    if(uv.y < .025+abs(uv.x*uv.x))\n    {\n\t    // Raymarch mountains\n        for(i = 0; i<N; ++i)\n        {\n            x = o + d * dir;\n            scene(x,s);\n            if(s.x < 1.e-4) break;\n            d += s.x<4.e-2?min(s.x,3.e-3):min(s.x, 2.e-2);\n            if(d>10.)\n            {\n                i = N;\n                break;\n            }\n        }\n        \n        if(i<N)\n        {\n            normal(x, n, 5.e-4);\n            l = normalize(.5*n);\n          \n            if(s.y == 0.)\n            {\n                floor_texture(x.xy,n, col);\n                col = mix(col, c.xxx, clamp(x.z/.2,0.,1.));\n            }\n            col = .1*col \n                + .2*col*dot(l, n)\n                + 1.4*mix(col, vec3(0.59,0.58,0.55), dot(n,c.yyx))*pow(abs(dot(reflect(l,n),dir)),6.);\n            col = mix(col, 1.3*c.xxx, clamp(dot(n,c.xyy+.3*c.yzx),0.,1.));\n        }\n    }\n    else \n    {\n        col = c.xxx;\n        d = 10.;\n    }\n    col = mix(col, mix(2.5*vec3(0.80,0.55,0.47),vec3(0.39,0.54,0.57), clamp((length(uv))/.5,0.,1.)), clamp(sqrt(d)/3.,0.,1.));\n    \n    col *= col;\n    col = clamp(col, 0., 1.);\n    \n    // Snowflakes\n    for(float ka = 0.; ka < 3.; ka += 1.)\n    {\n        vec2 dx;\n        lfnoise(2.*uv-iTime, dx.x);\n        lfnoise(2.*uv-iTime-1337., dx.y);\n    \n        float v, vc;\n        vec2 vi;\n        float vsize = 16.+8.*ka;\n        dvoronoi(vsize*(uv+.5*iTime*c.yx-.1*dx), v, vi, vc);\n        vc /= vsize;\n        vi /= vsize;\n        col = mix(col, c.xxx, sm((length(vi-uv-.5*iTime*c.yx+.1*dx)-(.1-.2*ka)*vc)/(5.)));\n    }\n    \n    fragColor = vec4(clamp(col,0.,1.),1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}