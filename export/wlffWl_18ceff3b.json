{"ver":"0.1","info":{"id":"wlffWl","date":"1675611451","viewed":130,"name":"generalized symmetric smoothstep","username":"iestyn","description":"An alternative to smoothstep with some interesting advantages (see code for detailed pros+cons).\n\n[  I have realized I'm never going to finish 'tidying up' this code, so I'm just publishing it as-is... sorry for all the crap :o(  ]","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["smoothstep","interpolation","easing","tween"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A generalized version of smoothstep\n//\n// This remaps a section of the curve \"y = 1/x\" into the range [0,1] to yield a curve of variable sharpness\n//\n// Anyone recognize this formulation?\n// I'm sure Jim Blinn invented it 30 years ago but I can't find his article... :)\n//\n// Pros:\n//  - sharpness is a continuous parameter; it can go from flat (identity) to ultra-sharp (right angles)\n//  - it is rotationally symmetric, unlike smoothstep\n//  - you can use it to both stretch (push values towards 0 and 1) or compress (push values towards 0.5)\n//  - it is its own inverse (no need for the asin variant of inverse smoothstep)\n//\n// Cons:\n//  - more ops, including a divide. Please let me know if you see any more gains to be had! :)\n//  - numerically unstable near the midpoint of the sharpness parameter range (my fix is trivial to comment out if you prefer to put a workaround in calling code)\n//  - the behaviour is a little non-linear w.r.t the sharpness parameter. I can make it linear but it requires a sqrt :(\n//  - the gradient is not zero at the endpoints (given it encompasses both identity and inverse-smoothstep)\n//  - composing the function with its inverse  \"x ~= f(f(x,+a),-a)\"  deviates from the identity for sharpness near +1.0 and -1.0\n//    (uncomment VALIDATE_SELF_INVERSE below to see what this looks like)\n//  - with sharpness -1.0, yields NaNs for 0.0 and 1.0 (could be fixable, need to look into it)\n//\n\n\n// Use the optimized version of the math\n// (I think both versions have the same numerical deficiencies... and the optimized form actually responds more linearly w.r.t the sharpness parameter)\n//#define OPTIMIZED_MATH 1\n\n// This visually subdivides the sharpness parameter range into stripes (even numbers are more numerically useful, but odd numbers look better)\n//#define NUM_STRIPES 15.0\n#define NUM_STRIPES 16.0\n\n// Uncomment to validate the self-inverse claim:  f(x,+a)  is the inverse of  f(x,-a)  therefore  x == f(f(x,+a),-a)\n//#define VALIDATE_SELF_INVERSE 1\n\n\nfloat generalized_smoothstep( float x, float a )\n{\n\tif ( abs( a ) < 0.001 )  return x;  // NOTE: this fixes the numerical instability around the zero-sharpness point where the curve approaches identity\n\n\n// TODO: optimization 3:\n//        - instead of doing the a-flip \"0.5 - 0.5*sign_a + x*sign_a\" before AND after the core calculation...\n//        - ...instead, and use \"1/x\" within the [-1,0] range, which is the inverse shape and only requires a simpler sign-flip\n   \n// TODO: undo temp change in draw_curve_generalized_smoothstep related to OPTIMIZATION 3\n\n    \n// TODO: when sharpness is -1.0, you get NaN for inputs for 0.0 or 1.0\n//        - set NUM_STRIPES to an even value and click-drag to the extremes to see the bottom dot disappear\n//        - somehow sharpness +1.0 does not have this issue... can we use symmetry to fix this?\n//        - does this apply to the original math or just the optimized math?\n\n// TODO: look at the self-inverse problem again (see notes in sawtooth and draw_curve_generalized_smoothstep)\n\n// TODO: does the non-optimized math differ in terms of numerical issues? (x at 0.0, 0.5, 1.0... sharpness at -1.0, 0.0, +1.0)\n\n// TODO: is the function (a) continuously differentiable and (b) differentiable for all inputs? (at x 0/1 and for sharpness -1/+1)\n\n    \n#ifdef OPTIMIZED_MATH\n   \n    // This is the optimized math with no conditionals and only one divide\n    float sign_a = sign( a );\n    float sign_x = sign( x );\n    x = abs( x );\n    x = 0.5 - 0.5*sign_a + x*sign_a; // Note: \"0.5 - 0.5*sign_a\" may be reused by the compiler below, depending on register pressure\n\n    // Raising sx2 to a power makes the motion of the curve almost linear w.r.t 'a'\n    // sx^2 is good, sx2^3 is better (but sx2^4 seems to visibily slow down at the extrema - try it and look at the width of the purple bands)\n    float sx2 = 1.0 - a*sign_a;\n    sx2 = sx2*sx2*sx2; // This can be removed for perf if you don't care about linearity w.r.t 'a'\n\n    float p = sx2 + x - x*sx2;\n    float y = (sx2 - sx2*p) / (p - p*sx2); // This is numerically unstable when sx2 ~= 1.0 ...any ideas how to eliminate this elegantly?\n\n\ty = 0.5 - 0.5*sign_a + y*sign_a;\n\treturn sign_x - sign_x*y;\n\n    \n#else // OPTIMIZED_MATH\n\n    \n    // This is the original easier to grok math.\n\n    // We use symmetry to flip the curve \"y = 1/x\" between concave and convex forms\n    // This handles both the two halves of the s-curve (below 0.5 and above 0.5)\n    // as well as the sign of the sharpness parameter 'a' ( +ve -> stretch,  -ve -> compress)\n/*/\n\tfloat sign_x = sign(x);\n\tx = 1.0 - abs(x);\n\n    // This remaps a section of the curve \"y = 1/x\" so that the endpoints land at (0,1) and (1,0).\n    // The larger the section, the sharper the resulting curve, with a tiny section being essentially flat (identity).\n    // If 'a' is negative, the curve bends the other way (compress <--> stretch).\n\tif ( a < 0.0 )\n    \ta = 1.0 / (1.0 + a);\n\telse\n    \ta = 1.0 - a;\n    float sx = 1.0/a;\n    x = sx + x*(1.0/sx - sx);\n    float y = 1.0/x;\n    y = (y - sx) / (1.0/sx - sx);\n\n    return y*sign_x;\n/*/\n    \n   \n// OPTIMIZATION 3:\n//if a is negative then use the -ve portion of the 1/x curve:\n// - pre: subtract sign_x from x\n// - post: add sign_x to y\n//\n//\n// this is not working\n// I am confused\n// I don't get the shape of the curve for the case where both x and a are +ve... it should be the inverse of that...\n//\n// taxonomy of available curves:\n// the +ve 1/x curve has two output variants: an x-flip (bulge bot-right) and a y-flip (bulge top-left)\n// the -ve 1/x curve has two output variants: an x-flip (bulge top-left) and a y-flip (bulge bot-right)\n//\n// negating x gives you the option of performing an x-flip in all cases (so you dont need a y-flip)\n// BUT it does require you to shift the result if it needs to land in the upper half of the S-curve\n// HOWEVER, you are already doing a shift for the lower part of the S-curve\n//\n// taxonomy of desired outputs:\n// +x +a:  top-left  bulge [0,+1]\n// -x +a:  bot-right bulge [-1,0]\n// +x -a:  bot-right bulge [0,+1]\n// -x -a:  top-left  bulge [-1,0]\n\n\n/*/\n// version 3A:\n//  o abs(x)\n//  o -ve a: x-flip\n//  o 1/x\n//  o +ve a: y-flip\n//  o multiply by sign(x)\n//  o OKAY... this is just the optional-pre-x-flip and optional-post-y-flip from the optimized code... so no benefits here\n{\n    float sign_a = sign(a);\n    a = 1.0 - abs( a );\n\tfloat sign_x = sign(x);\n\tx = abs(x);\n    if ( sign_a < 0.0 )\n        x = 1.0 - x;\n\n    float sx = 1.0/a;\n    x = sx + x*(1.0/sx - sx);\n    float y = 1.0/x;\n    y = (y - sx) / (1.0/sx - sx);\n\n\tif ( sign_a > 0.0 )\n\t    y = 1.0 - y;\n    return y*sign_x;\n}\n/**/\n\n/*/\n// version 3B:\n//  o see if not doing abs(x) yields a reasonable result or not (is it actually symmetric?)\n//  o yep, as long as the translation offset sx is multiplied by sign_x (affects both x and y offsets)\n//  o if so then try to utilize the -ve x curve to flip the bulge (based on sign_a)\n{\na = -a;\nfloat sign_a = sign( a );\na = sign_a - a;\n\n    float sign_x = sign(x);\n\n// so... 1/x gives a bot-left bulge\n// with a negative 'scale', this gets double-flipped to a top-right bulge\n// and the x-flip flips this to a top-left bulge\n//\n// the question is, can you flip the sign of x to invert the curve and end up with a bot-right bulge... with simpler math than you had originally?\n//  - it's really messy... I actually think the original formulation was somewhat optimal w.r.t conditionals since it only had a condition on (a < 0.0)\na = 1.0 / abs( a );\nx = sign_x - x;\nif ( sign_a < 0.0 )\n{\n\tx -= sign_x;\n\tsign_x = -sign_x;\n}\n\n// for a=+0.5, offset=2, scale=-1.5... scale is negative so it does an x-flip and a y-flip as well as scaling to [0,1]\n// if you take the reciprocal of a then you don't get either flip\n    float offset = sign_x / a;\n    float scale  = a - 1.0/a;\n\tx = offset + x*scale;\n    float y = 1.0/x;\n    y = (y - offset) / scale;\n\nif ( sign_a < 0.0 )\n\ty -= sign_x;\n\n    return y;\n}\n/**/\n\n//a = -0.5;\n\n// version 3C:\n//  o look at the original math for adjusting -ve a:  a = 1/(1+a)\n//  o how does this affect the curve? it seems to boil everything down to a single conditional (x sign is handled more simply via abs(x) and y*sign_x)\n//  o understand how this eliminates one of the conditionals... is the other one handled by \"1.0 - abs(x)\" and \"y*sign_x\"?\n//   - (1/sx-sx) does an x-flip if negative... this occurs if a is < 1.0... so negating a causes an x-flip\n//   - 1-abs(x) removes the sign of x but y*sign_x restores it so you get a y-flip if x is negative\n//   - HOWEVER... this means that flipping the sign of a only introduces an x-flip... whereas our other versions have required both an x-flip and y-flip\n//   - so the other magic must come from allowing a > 1 ...[-1,0] maps to [+inf,1] and [0,+1] maps to [1,0]...\n//   - OR a[-1,0] maps to sx[0,1] and sdx[+inf,0] and a[0,+1] maps to sx[1,+inf] and sdx[0,-inf] (where sdx = (1/sx-sx))\n//   - AHA! changing the sign of sdx actually causes both an x-flip AND a y-flip, since x is multiplied by sdx and y is divided by it...\n//   - so I think the key is twiddling input a so that the sign of sx & sdx changes\n//    o ### create a version of the optimized code that uses the conditional on a to see if it actually yields the right results when sx goes outside [0,1]\n//    o ### figure out how to express the a if/else in non-conditional math\n//     - ### this is the tough part... getting rid of one conditional clause is how I eliminated the divide!\n//     - ### maybe you can sub in sxr=a (instead of sx=1/a) and see what falls out when you rearrange the math... how similar is it to the math you get for sx?\n//    o ### add notes that you can eliminate some math if you don't require negative a (stretch only)\n/**/\n\tfloat sign_x = sign(x);\n\tx = 1.0 - abs(x);\n\n\tif ( a < 0.0 )\n    \ta = 1.0 / (1.0 + a);\n\telse\n    \ta = 1.0 - a;\n    float sx = 1.0/a;\n    x = sx + x*(1.0/sx - sx);\n    float y = 1.0/x;\n    y = (y - sx) / (1.0/sx - sx);\n\n    return y*sign_x;\n/**/\n\n    // Here's how I rearranged the original math to reduce the number of divides... maybe you can spot further improvements? :)\n    // Note that I eliminated the divide in the sx2 calculation below by adding a second symmetry-flip.\n    //\n    //float sx  = 1.0/a;\n    //float sx2 = 1.0/(a*a);\n    //x = sx + x*(1.0/sx - sx);\n    //float y = (1.0/x - sx) / (1.0/sx - sx);\n    //float y = (1.0/(sx + x*(1.0/sx - sx)) - sx) / (1.0/sx - sx);\n    //float y = (1.0/(sx + x*(1.0/sx - sx)) - sx) / ((1.0-sx2)/sx);\n    //float y = (sx/(sx + x*(1.0/sx - sx)) - sx2) / (1.0-sx2);\n    //float y = (sx/(sx + x*((1.0-sx2)/sx)) - sx2) / (1.0-sx2);\n    //float y = (1.0/(sx2 + x*(1.0-sx2)) - 1.0) / (1.0/sx2-1.0);\n    //float y = (1.0/(sx2 + x*(1.0-sx2)) - 1.0) / ((1.0-sx2)/sx2);\n    //float y = (sx2/(sx2 + x*(1.0-sx2)) - sx2) / (1.0-sx2);\n    //float y = ((sx2 - sx2*(sx2 + x*(1.0-sx2)))/(sx2 + x*(1.0-sx2))) / (1.0-sx2);\n    //float y = (sx2 - sx2*(sx2 + x*(1.0-sx2))) / ((sx2 + x*(1.0-sx2)) * (1.0-sx2));\n    //float p = sx2 + x - x*sx2;\n    //float y = (sx2 - sx2*p) / (p - p*sx2);\n\n#endif // OPTIMIZED_MATH\n}\n\n// NOTE: generalized smoothstep operates most naturally in [-1,+1] so for comparison we remap smoothstep and smootherstep to/from [0,1]\nfloat traditional_smoothstep( float x )\n{\n    x = 0.5*(x + 1.0);\n    float y = 3.0*x*x - 2.0*x*x*x;\n    return y*2.0 - 1.0;\n}\n\nfloat smoother_smoothstep( float x )\n{\n    x = 0.5*(x + 1.0);\n    float y = 6.0*x*x*x*x*x - 15.0*x*x*x*x + 10.0*x*x*x;\n    return y*2.0 - 1.0;\n}\n\n#define DX 0.00001\n\nfloat traditional_smoothstep_gradient( float x )\n{\n    return 0.5*( traditional_smoothstep( x + DX ) - traditional_smoothstep( x - DX ) ) / DX;\n}\n\nfloat smoother_smoothstep_gradient( float x )\n{\n    return 0.5*( smoother_smoothstep( x + DX ) - smoother_smoothstep( x - DX ) ) / DX;\n}\n\nfloat sawtooth( float t, float period )\n{\n    // Click and drag to override the time-based animation\n    if ( iMouse.z > 0.0 )\n    {\n        t = ( iMouse.x / iResolution.x )*2.0 - 0.5;\n        t = 0.5*period*clamp( t, 0.0, 1.0 );\n\n// TODO: look at the self-inverse problem again\n//\n// Up to 0.9 self-inverse works well\n// For extreme values, symmetry is broken (sign matters)\n// +0.99/-0.99 looks bad, little notches everywhere...\n// +0.999 looks almost the same as +1.0, with some corruption (and -0.999 looks almost like -1.0)\n// +0.9999 looks exactly like +1.0 (and -0.9999 looks like -1.0)\n// So up to 0.9 its fine\n// After that, it starts to ignore the second part of the inverse until at 0.9999 it is totally ignoring it (one half of the calculation dominates)\n\n//return 0.9999;\n\n    }\n\n    t = 4.0*fract( t / period );\n    return ( ( ( t > 2.0 ) ? ( 4.0 - t ) : t ) - 1.0 );\n}\n\n\nfloat curve_alpha( float y_dist, float gradient, float thickness )\n{\n    // Use the gradient to compute distance to the curve (so line thickness remains pretty much constant)\n    float dist = y_dist / sqrt( gradient*gradient + 1.0 );\n    return clamp( thickness - abs( dist * iResolution.y ), 0.0, 1.0 );\n}\n\nvec3 draw_curve( float y, float value, float gradient, vec3 c, vec3 curve_colour )\n{\n    return mix( c, curve_colour, curve_alpha( y - value, gradient, 5.0 ) );\n}\n\nfloat generalized_smoothstep_gradient( float x, float a )\n{\n    return 0.5*( generalized_smoothstep( x + DX, a ) - generalized_smoothstep( x - DX, a ) ) / DX;\n}\n\nvec3 draw_curve_generalized_smoothstep( vec2 xy, vec3 c, vec3 curve_colour )\n{\n    float sharpness = sawtooth( iTime, 3.0 );\n    \n    // The curve gets very steep and we can't compute a reliable gradient for sharpness -1.0 or +1.0,\n    // so we have to find the distance to the pixel in both the x and y directions...\n    // Thankfully this curve is trivial to mirror around \"y = x\", so this is easy to do!\n    float y_value = generalized_smoothstep( xy.x, +sharpness );\n    float x_value = generalized_smoothstep( xy.y, -sharpness );\n#ifdef VALIDATE_SELF_INVERSE\n    y_value = generalized_smoothstep( y_value, -sharpness );\n    x_value = generalized_smoothstep( x_value, +sharpness );\n#endif // VALIDATE_SELF_INVERSE\n\n    \n// TODO: look at the self-inverse problem again\n//        - with the mouse dragged left, it looks like TWO lines are drawn... one janky and one nice and straight\n//        - so is this a rendering problem?\n//        - alternatively, does this suggest we can use symmetry to fix it again?\n//          (i.e if the x-distance is accurate but the y-distance is inaccurate, then use the x-distance!)\n//\n// with this rendering method, the self-inverse result looks much worse behaved for sharpness near -1.0 then near +1.0\n// so maybe this relates to the other problem with sharpness -1.0\n// and maybe there is a symmetry we can use to avoid both problems...\n\n// return mix( c, curve_colour, step( xy.y, y_value ) );\n\n    \n    float dx = xy.x - x_value;\n    float dy = xy.y - y_value;\n    float dist = sqrt( dx*dx + dy*dy );\n    if ( dist > 0.0 )\n    {\n        // This keeps line thickness more or less constant\n        float scale = max( abs(dx), abs(dy) ) / dist;\n        dx *= scale;\n        dy *= scale;\n    }\n    float y_alpha = curve_alpha( dy, 0.0, 6.0 );\n    float x_alpha = curve_alpha( dx, 0.0, 6.0 );\n\nx_alpha = 0.0; // OPTIMIZATION 3\n    \n    return mix( c, curve_colour, max( x_alpha, y_alpha ) );\n}\n\nvec3 draw_dot( float value, float sharpness, vec2 xy, vec3 c, vec3 dot_colour, float radius )\n{\n    float dx    = xy.x - value;\n    float dy    = xy.y - sharpness;\n    float alpha = curve_alpha( sqrt( dx*dx + dy*dy ), 0.0, radius );\n\n    return mix( c, dot_colour, alpha );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Graph the curve on the left, representing the range [-1,+1] on both axes\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 0.5 + 1.25*(uv - vec2(0.25,0.5))*vec2(aspect,1.0);\n    if ( uv == fract(uv.xy) )\n    {\n        // Show a few example curves for different sharpness values\n        vec3 c  = vec3(1.0,1.0,1.0);\n        vec2 xy = uv*2.0 - 1.0;\n        for ( float sharpness = -1.0; sharpness <= 1.0; sharpness += 0.125 )\n        {\n            float fixed_value = generalized_smoothstep( xy.x, sharpness );\n            if ( fixed_value > xy.y )\n        \t\tc = mix( c, vec3(0.4,0.18,0.45), 0.125 );\n        }\n\n        // Show smoothstep (red) and smootherstep (yellow) for comparison\n        c = draw_curve( xy.y, traditional_smoothstep( xy.x ), traditional_smoothstep_gradient( xy.x ), c, vec3(0.90,0.40,0.15) );\n        c = draw_curve( xy.y,    smoother_smoothstep( xy.x ),    smoother_smoothstep_gradient( xy.x ), c, vec3(0.75,0.85,0.20) );\n\n        // Show the generalized smoothstep curve, animating through the range of sharpness values from -1.0 to +1.0\n\t\tc = draw_curve_generalized_smoothstep( xy, c, vec3(0.0,0.8,1.0) );\n\n        fragColor = vec4(c.xyz,1.0);\n    }\n\n    // Show animated dots on the right, demonstrating easing behaviour across the sharpness range (+1.0 top, 0.0 middle, -1.0 bottom)\n    uv.x -= 1.1;\n    if ( uv == fract(uv.xy) )\n    {\n        float n = NUM_STRIPES;\n        vec3  c = vec3(0.85,0.61,0.3);\n\t\tvec2 xy = 2.0*uv - 1.0;\n\t\tfloat sharpness = floor( xy.y * 0.5 * n + 0.5 ) / ( 0.5 * n );\n        c *= mix( 0.35, 1.0, pow( abs( sharpness ), 1.25 ) );\n\n    \tfloat x = sawtooth( iTime, 3.0 );\n\n        // Show smoothstep (red) and smootherstep (yellow) motion for comparison (in the middle stripe)\n        c = draw_dot(    smoother_smoothstep( x ), 0.0, vec2( xy.x, 0.0 ), c, vec3(0.75,0.85,0.20), 6.0 );\n        c = draw_dot( traditional_smoothstep( x ), 0.0, vec2( xy.x, 0.0 ), c, vec3(0.90,0.40,0.15), 6.0 );\n\n        // Show generalized smoothstep motion\n        c = draw_dot( generalized_smoothstep( x, sharpness ), sharpness, xy, c, vec3(0.0,0.8,1.0), 10.0 );\n\n        fragColor = vec4(c.xyz,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}