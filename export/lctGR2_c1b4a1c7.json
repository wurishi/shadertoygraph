{"ver":"0.1","info":{"id":"lctGR2","date":"1711921468","viewed":87,"name":"THE SPIRAL","username":"jarvarvarvis","description":"Another raymarching test with music","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"MfX3WH","parentname":"kishimisu's raymarching starter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 iqPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    const float twoPi = 6.28318;\n    return a + b * cos(twoPi * (c * t + d));\n}\n\nvec3 palette(float value, vec2 uv) {\n    // Calculate palette values\n    vec3 col1 = iqPalette(value, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67));\n    vec3 col2 = iqPalette(value, vec3(0.3,0.2,0.5), vec3(0.2,0.3,0.2), vec3(2.0,1.0,1.0), vec3(0.0,0.25,0.25));\n\n    // Scale uv and rotate\n    uv *= 1.5;\n    uv *= rot2D(iTime * 0.12);\n    \n    uv.x *= 0.5;\n\n    // Mix colors based on length(uv)\n    float mixValue = length(uv) * 1.2;\n    mixValue = clamp(mixValue, 0.0, 1.0);\n    return mix(col1, col2, mixValue);\n}\n\n// Scene distance\nfloat scene(vec3 p) {\n    // Twist point along z direction before everything\n    p.xy *= rot2D(p.z * 0.5);\n\n    // Initialization\n    float moveSpeed = 0.5;\n    float tiling = 0.75;\n    \n    float movement = (fract(iTime * moveSpeed) * 2.0 - 1.0);\n    float rotationAngle = fract(iTime * 0.12) * 3.141;\n    \n    // Create first point\n    vec3 p1 = p.xyz;\n    p1.xy *= rot2D(rotationAngle);\n    p1.z += movement * tiling;\n    \n    p1 = opRepetition(p1, vec3(tiling));\n    \n    // Create second point\n    vec3 p2 = p.xyz;\n    p2.xy *= rot2D(rotationAngle);\n    p2.z += (movement + .5) * tiling;\n    \n    p2 = opRepetition(p2, vec3(tiling));\n    \n    // Calculate distance to octahedra (position dependent scale)\n    float scaleValue = remap(sin(p.z * 4.0));\n    float scale = 0.2 + scaleValue * 0.15;\n    \n    float s1 = sdOctahedron(p1, scale);\n    float s2 = sdOctahedron(p2, scale);\n    \n    // Get smooth union between octahedra\n    float unionSmoothness = 0.25;\n    float sUnion = opSmoothUnion(s1, s2, unionSmoothness);\n    \n    // Create infinite cylinder along view direction to make space for camera\n    float viewCyl = sdCylinder(p.xzy, vec3(0.0, 0.0, tiling * 0.5));\n    \n    // Subtract that cylinder from the union\n    return opSubtract(sUnion, viewCyl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ro = vec3(0, 0, 0);            // ray origin\n    vec3 rd = normalize(vec3(uv, 1));   // ray direction\n    vec3 col = vec3(0);                 // final pixel color\n\n    const float MAX_DIST = 100.;\n    float t = 0.; // total distance travelled\n\n    // Raymarching\n    const int MAX_STEPS = 80;\n    int steps = 0;\n    \n    for (steps = 0; steps < MAX_STEPS; steps++) {\n        // Position along the ray\n        vec3 p = ro + rd * t;\n        \n        // Current distance to the scene\n        float d = scene(p);\n\n        // \"March\" the ray\n        t += d;\n\n        // Early stop if close enough or too far\n        if (d < .001 || t > MAX_DIST) break;\n    }\n\n    // Coloring\n    float stepValue = float(steps) / float(MAX_STEPS);\n    \n    float distValue = 1.0 - exp(-t * 0.1);\n    //float distValue = t * 0.02;\n    \n    // Mix step and distance based values for more detail\n    float value = mix(stepValue, distValue, 0.85);\n    col = palette(value, uv);\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Remap value from [-1, 1] to [0, 1]\n// ft. a terrible, non-descriptive name\nfloat remap(float value) {\n    return (value + 1.) * 0.5;\n}\n\n// 2D rotation matrix\nmat2 rot2D(float a) {\n    return mat2(\n        cos(a), -sin(a), \n        sin(a), cos(a)\n    );\n}\n\n// Shapes\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCylinder(vec3 p, vec3 c) {\n    return length(p.xz-c.xy)-c.z;\n}\n\n// Operators\nvec3 opRepetition(vec3 p, vec3 s) {\n    vec3 q = p - s*round(p/s);\n    return q;\n}\n\nfloat opSubtract(float d1, float d2) {\n    return max(d1,-d2); \n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"#define TWO_PI 6.2831\n\nfloat envelope(float t, float decay, float factor) {\n    return exp(-decay * t) * factor;\n}\n\nfloat FM(float fc, float fm, float iom, float t) {\n    return sin(TWO_PI*fc*t + iom*sin(TWO_PI*fm*t));\n}\n\nfloat fmPluck(float fc, float fm, float iom, float decay, float t) {\n    return FM(fc, fm, iom, t) * envelope(t, decay, 0.1);\n}\n\nvec2 pan(float pos) {\n    vec2 p = vec2(1. - pos, 1. + pos);\n    return normalize(p);\n}\n\nfloat interval(float semitones) {\n    return pow(2., semitones / 12.);\n}\n\nconst int NOTES = 8;\nconst float notes[] = float[NOTES]( -12., 3., 1., 0., -7., -2., -3., 0. );\n\nvec2 jingle(float t) {\n    vec2 sig = vec2(0);\n    float noteDuration = 0.9;\n    \n    for (int i = 0; i < NOTES; ++i) {\n        float nn = notes[i];\n        float freq = 440.0 * interval(nn);\n        float t0i = noteDuration * float(i);\n        float ti = mod(t - t0i, noteDuration * float(NOTES));\n        \n        sig += fmPluck(freq, freq * .5, 1., 1.2, ti);\n    }\n    \n    return sig;\n}\n\nvec2 mainSound(int samp, float t) {\n    vec2 sig = vec2(0);\n   \n    sig += jingle(t);\n   \n    return sig;\n}","name":"Sound","description":"","type":"sound"}]}