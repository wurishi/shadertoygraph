{"ver":"0.1","info":{"id":"ws3XRj","date":"1572959327","viewed":259,"name":"Neon Jungle v0.2","username":"Delvar","description":"Flying around a smog filled Mega City, Mouse to free look.\nA new version here:  'Neon Jungle v0.5'  https://www.shadertoy.com/view/WdyXzz","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fog","windows","neon","concrete","megacity","fly","smog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =================================================================\n//  'Neon Jungle v0.2'\n//  https://www.shadertoy.com/view/ws3XRj\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  A new version here:  'Neon Jungle v0.5'  https://www.shadertoy.com/view/WdyXzz\n//\n//\tThe 'Face Fog' hides a multitude of sins :)\n//\n//\tCredits: \n//\tIdea sparked from the 2d shader,  mhnewman : 'Descent ' : https://www.shadertoy.com/view/XtSGWD\n//\n//\tThe bulk of the ray tracer and lighting was inspired by watching a video by Inigo Quilez https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\tand his related shadertoy iq: 'Happy Jumping' : https://www.shadertoy.com/view/3lsSzf\n//\n//\tDistance functions from https://iquilezles.org/articles/distfunctions\n//\t\tand implementation iq : 'Raymarching - Primitives' : https://www.shadertoy.com/view/Xds3zN\n//\n//\tWindows bassed off (but rewitten so I understand it!) otaviogood : 'Skyline' : https://www.shadertoy.com/view/XtsSWs\n//\n//\tMost of the other Math came from wikipedia https://www.wikipedia.org/\n// =================================================================\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 35.0\n#define OBJECT_MIN_SURFACE_DISTANCE 0.005\n\n#define RAY_MAX_STEPS_SHADOW 30\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW 0.01\n#define OBJECT_MIN_SURFACE_DISTANCE_SHADOW_OFFSET 0.041\n\n#define PI 3.1415926535897932384626433832795\n\n#define DEBUG_RAY_DITHER\n#define DEBUG_CAMERA_FLY\n#define DEBUG_WHITE_NEON\n#define DEBUG_DISTANCE_FOG\n#define DEBUG_FACE_FOG\n#define DEBUG_LIGHTING\n#define DEBUG_AMBIENT\n#define DEBUG_AMBIENT_OCCLUSION\n#define DEBUG_RENDER_RAILS\n#define DEBUG_VIGNETTE\n\n//#define DEBUG_OCCLUSION   // used instead of DEBUG_AMBIENT_OCCLUSION when you want the efect but without adding DEBUG_AMBIENT or DEBUG_LIGHTING\n\n//change the filtering method, Linier, Smoothstep or Quintic, little visual change when noise is stacked but can impact performance.\n//#define VALUE_NOISE_FILTER_SMOOTH\n//#define VALUE_NOISE_FILTER_QUINTIC\n\n// Flags to use texture lookups instead of noise functions, should be faster but introduces repetiton.\n//#define NOISE_TEXTURE_3D iChannel0\n//#define NOISE_TEXTURE_2D iChannel1\n\n// -- The Materials\n#define MAT_SKY \t0\n#define MAT_WINDOW\t1\n#define MAT_WALL\t2\n#define MAT_SOLID\t3\n#define MAT_RAIL\t4\n#define MAT_NEON\t5\n\n// ========== Structs ==========\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nstruct rayMarchHit {\n    vec3 origin, surfaceNormal;\n    float distance;\n    vec3 neon;\n    int materialId;\n    int iteration;\n};\n\n// ========== ==========\n\n// ========== Constants ==========\n\nconst float gridSize = 5.0;\nconst float gridSizeH = gridSize*0.5;\nconst float gridSizeQ = gridSize*0.25;\n\nconst float roadLength = gridSize*5.0;\nconst float roadLengthH = roadLength*0.5;\nconst float roadLengthQ = roadLength*0.25;\n\nconst float roadWidth = gridSize;\nconst float roadWidthH = roadWidth*0.5;\nconst float roadWidthQ = roadWidth*0.25;\n\nconst float blockSize = roadLength + gridSize;\nconst float blockSizeH = blockSize*0.5;\nconst float blockSizeQ = blockSize*0.25;\n\nconst vec3 roadLightColour = vec3(0.9,0.6,0.1);\nconst float roadLightBrightness = 5.0;\n\n// ========== ==========\n\n// ========== Rotation ==========\n\nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\n\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\n//Converts a unit vector into polar coordinates , vec2(Yaw, Pitch).\nvec2 toPolar(vec3 point) {\n    return vec2(atan(point.x,point.z),asin(point.y));\n}\n\n// ========== ==========\n\n// ========== Ray Constructor ==========\n\nray getRay(vec2 uv, camera camera) {\n    ray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\n// ========== ==========\n\n// ========== Hash Functions ==========\n\n//#define HE 702.566665305\n//#define HF 149.311292882\n//#define HG 446.230257362\n//#define HH 833.597411735\n\n#define HD 43758.5453123\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n\nfloat hash11(float st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(vec3(HF,HG,HH)*st)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(vec2(HF,HG)*st)&255,0).x;\n    # else\n    return fract(sin(st*HE)*HD); \n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\n\nfloat hash31(vec3 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE)&31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st.x*HE+st.z*HF,st.y*HG+st.z*HH)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec3(HE,HF,HG)))*HD);\n    #endif\n}\n\n\n//FIXME: find alternativs with texture lookup\nvec3 hash13(float st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HD);\n}\n\nvec3 hash23(vec2 st) {\n    return fract(sin(st.xyx*vec3(HE,HF,HG))*HD);\n}\n\nvec3 hash33(vec3 st) {\n    return fract(sin(st*vec3(HE,HF,HG))*HD);\n}\n\n// ========== ==========\n\n// ========== Helper Functions ==========\n\n//Simple remap of value and range to new value in new range\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\nvec3 valueNoiseFilter(vec3 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nvec2 valueNoiseFilter(vec2 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat valueNoiseFilter(float x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat lengthSquare(vec2 a) {\n    return dot(a,a);\n}\n\nfloat lengthSquare(vec3 a) {\n    return dot(a,a);\n}\n\n// ========== ==========\n\n// ========== Coherent Noise ==========\n\n// - Value Noise, 3d, Unsigned\nfloat valueNoise3du(vec3 samplePoint) {\n    vec3 pointI = floor(samplePoint);\n    vec3 pointF = fract(samplePoint);\n    vec3 u = valueNoiseFilter(pointF);\n\n    //Slight Optimisation\n    vec4 m = mix(\n        vec4(\n            hash31(pointI ),//bbl,\n            hash31(pointI + vec3(0.0,1.0,0.0) ),//btl,\n            hash31(pointI + vec3(0.0,0.0,1.0) ),//fbl,\n            hash31(pointI + vec3(0.0,1.0,1.0) )//ftl\n        ),vec4(\n            hash31(pointI + vec3(1.0,0.0,0.0) ),//bbr,\n            hash31(pointI + vec3(1.0,1.0,0.0) ),//btr,\n            hash31(pointI + vec3(1.0,0.0,1.0) ),//fbr,\n            hash31(pointI + vec3(1.0,1.0,1.0) )//ftr\n        ),u.x);\n\n    vec2 n = mix(m.xz, m.yw, u.y);\n    return mix(n.x,n.y,u.z);\n\n    /*\n//The original function, just for referance.\nfloat bbl = hash31(pointI + vec3(0.0,0.0,0.0) );\nfloat bbr = hash31(pointI + vec3(1.0,0.0,0.0) );\nfloat btl = hash31(pointI + vec3(0.0,1.0,0.0) );\nfloat btr = hash31(pointI + vec3(1.0,1.0,0.0) );\n\nfloat fbl = hash31(pointI + vec3(0.0,0.0,1.0) );\nfloat fbr = hash31(pointI + vec3(1.0,0.0,1.0) );\nfloat ftl = hash31(pointI + vec3(0.0,1.0,1.0) );\nfloat ftr = hash31(pointI + vec3(1.0,1.0,1.0) );\n\nfloat bb = mix(bbl,bbr,u.x);\nfloat bt = mix(btl,btr,u.x);\n\nfloat b = mix(bb,bt,u.y);\n\nfloat fb = mix(fbl,fbr,u.x);\nfloat ft = mix(ftl,ftr,u.x);\n\nfloat f = mix(fb,ft,u.y);\n\nreturn mix(b,f,u.z);\n*/\n}\n\n\n// - Value Noise, 2d, Unsigned\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    vec2 u = valueNoiseFilter(pointF);\n\n    vec2 m = mix(\n        vec2(\n            hash21(pointI), //bl\n            hash21(pointI + vec2(0.0,1.0)) //fl\n        ),\n        vec2(\n            hash21(pointI + vec2(1.0,0.0) ),//br\n            hash21(pointI + vec2(1.0,1.0) ) //fr\n        ),u.x);\n\n    return mix(m.x,m.y,u.y);\n\n    /*\n//The original function, just for referance.\nfloat bl = hash21(pointI + vec2(0.0,0.0) );\nfloat br = hash21(pointI + vec2(1.0,0.0) );\nfloat fl = hash21(pointI + vec2(0.0,1.0) );\nfloat fr = hash21(pointI + vec2(1.0,1.0) );\nvec2 u = valueNoiseFilter(pointF);\nfloat b = mix(bl,br,u.x);\nfloat f = mix(fl,fr,u.x);\n\nreturn mix(b,f,u.y);\n*/\n}\n\n// - Value Noise, 1d, Unsigned\nfloat valueNoise1du(float samplePoint) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(pointI),hash11(pointI + 1.0 ),valueNoiseFilter(fract(samplePoint)));\n    /*\n//The original function, just for referance.\nfloat pointI = floor(samplePoint);\nfloat pointF = fract(samplePoint);\nfloat b = hash11(pointI);\nfloat f = hash11(pointI + 1.0 );\nfloat u = valueNoiseFilter(pointF);\nreturn mix(b,f,u);\n*/\n}\n\n// - Value Noise, 1d, Unsigned, Wraped\nfloat valueNoise1duw(float samplePoint, float wrap) {\n    float pointI = floor(samplePoint);\n    return mix(hash11(mod(pointI, wrap)),hash11(mod(pointI + 1.0 ,wrap)),valueNoiseFilter(fract(samplePoint)));\n    /*\n//The original function, just for referance.\nfloat pointI = floor(samplePoint);\nfloat pointF = fract(samplePoint);\n\nfloat a = hash11(mod(pointI, wrap));\nfloat b = hash11(mod(pointI + 1.0 ,wrap));\nfloat u = valueNoiseFilter(pointF);\nreturn mix(a,b,u);\n*/\n}\n\n// ========== ==========\n\n// ========== Distance Feilds ==========\n// All primitives are centered at the origin.\n\n// == 2D ==\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// == ==\n\n// == 3D ==\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdXAlignedCylinder( vec3 p, float l, float r )\n{\n    p.z -= clamp( p.z, 0.0, l );\n    return length(p) - r;\n}\n\nfloat sdZAlignedCylinder( vec3 p, float l, float r )\n{\n    p.x -= clamp( p.x, 0.0, l );\n    return length(p) - r;\n}\n\n// == ==\n\n// ========== ==========\n\nfloat getFog(vec3 direction, float time) {\n    time=time*0.1;\n    float fog = 0.0;\n    vec2 t = vec2(time,-time);\n\n    fog+= valueNoise3du(direction + vec3(t.x));\n    fog+= valueNoise3du((direction + vec3(t.xyx)) * 2.0) * 0.5;\n    fog+= valueNoise3du((direction + vec3(t.xxy)) * 4.0) * 0.25;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 8.0) * 0.125;\n    fog+= valueNoise3du((direction + vec3(t.yyy)) * 16.0)* 0.0625;\n    \n    //return fog/1.9375;\n    return fog;//*0.516129032258;\n}\n\n// --quick hack to strobe the road lights so they always strobe away from the camera\n\nfloat getRoadLightStrobe(float distanceFromCamera, float time) {\n    return smoothstep(0.0,1.0,clamp(sin(time*5.0 - (distanceFromCamera/RAY_MAX_DISTANCE)*PI*5.0)*0.5,0.0,1.0));\n}\n\n// ========== ==========\n\n// ========== Camera Motion ==========\n\nvec3 getCameraPath(float time) {\n    time *= 0.05;\n\n    float b = blockSize;\n\n    vec3 path[16];\n    int i=0;\n\n    path[i++] = vec3( 0.0*b,\t0.0,\t 0.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b - gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 1.0*b + gridSize);\n    path[i++] = vec3( 0.0*b,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b - 1.0,\t0.0,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 2.0*b);\n    path[i++] = vec3( 2.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t 0.0*b);\n    path[i++] = vec3( 4.0*b,\t1.0*b,\t-2.0*b+1.0);\n    path[i++] = vec3( 4.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3( 2.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-4.0*b);\n    path[i++] = vec3( 0.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t-2.0*b);\n    path[i++] = vec3(-2.0*b,\t0.0,\t 0.0*b);\n\n    time = mod(time,float(path.length()));\n\n    float cornerRadius = 0.1;\n    float inverseCornerRadius = 1.0 - cornerRadius;\n\n    int timeI = int(floor(time));\n    float timeF = fract(time)*inverseCornerRadius+cornerRadius;\n\n    vec3 p0 = path[timeI];\n    vec3 r;\n    timeI += 1;\n    if (timeI>=path.length()) {\n        timeI = 0;\n    }\n    vec3 p1 = path[timeI];\n    if (timeF >= inverseCornerRadius) {\n        timeI += 1;\n        if (timeI>=path.length()) {\n            timeI = 0;\n        }\n        vec3 p2 = path[timeI];\n        vec3 p01 = p0 + ((p1-p0) * (inverseCornerRadius));\n        vec3 p12 = p2 + ((p1-p2) * (inverseCornerRadius));\n        float t = map(timeF,inverseCornerRadius,1.0,0.0,1.0);\n        vec3 a = mix(p01,p1,t);\n        vec3 b = mix(p1,p12,t);\n        r= mix(a,b,t);\n    } else {\n        r=mix( p0, p1, timeF);\n    }\n\n\n    vec3 rd;\n    rd.y = (sin(time*5.0) + sin(time*9.0)) * 0.8;\n    rd.x = sin(time*6.0) + sin(time*8.0);\n    rd.z = sin(time*7.0) + sin(time*7.0);\n\n    rd *= sin(fract(time)*PI);\n    rd *= clamp(length(r)/gridSize-gridSize,0.0,1.0);\n    r+=rd*0.5;\n    return r;\n}\n\ncamera getCamera(vec3 origin, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n    camera.origin = origin;\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw);\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec3 origin, vec3 forward, float roll, float zoom) {\n    float yaw = atan(forward.x,forward.z);\n    float pitch = asin(forward.y);\n    return getCamera(origin, roll, pitch, yaw, zoom);\n}\n\ncamera getCamera(vec2 mouse, float time) {\n    #if defined(DEBUG_CAMERA_FLY)\n    vec3 cameraPos1 = getCameraPath(time);\n    if (iMouse.z<0.5) {\n        vec3 cameraPos2 = getCameraPath(time+0.5);\n        vec3 cameraPos3 = getCameraPath(time-0.5);\n\n        vec3 cameraForward = normalize(cameraPos2 - cameraPos1);\n\n        vec3 cameraForward2 = normalize(cameraPos1 - cameraPos3);\n\n        //Take atan and nivt to -1 to +1 range\n        float yaw1 = atan(cameraForward.x,cameraForward.z)/PI;\n        float yaw2 = atan(cameraForward2.x,cameraForward2.z)/PI;\n\n        // get the differance and renormalize using fract.\n        float roll = -(fract((yaw1-yaw2)*0.5+0.5)*2.0-1.0);\n        roll = clamp(roll,-0.5,0.5);//clamp(-0.1,0.1,1.0-pow(1.0-roll,5.0));\n        return getCamera(cameraPos1, cameraForward, roll,  0.5);\n    } else  {\n        return getCamera(cameraPos1, 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);\n    }\n    #else\n    return getCamera(vec3(0.0,0.0,0.0), 0.0, mouse.y*PI, mouse.x*2.0*PI,  0.5);    \n    #endif\n}\n\n// ========== ==========\n\n// ========== Ray Marcher ==========\n\nrayMarchHit GetRayMarchHit(vec3 position, float time) {\n    rayMarchHit hit;\n    #if defined(DEBUG_USE_SQUARE_DISTANCE)\n    hit.distance = RAY_MAX_DISTANCE*RAY_MAX_DISTANCE;\n    #else\n    hit.distance = RAY_MAX_DISTANCE;\n    #endif\n\n    float newDistance = hit.distance;\n\n    vec3 pBlockCenter = position + (0.5*blockSize);\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    vec3 pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n    //wold position of the center of the grid, positionGI*blockSize\n    vec3 pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    vec3 pBlockWF = pBlockF*blockSize; \n\n    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;\n\n    //on north/south - -2.5 < mod(x,blockSize) < 2.5\n    bool onNorthSouth = (pBlockWF.x >= -gridSizeH && pBlockWF.x <= gridSizeH && (pBlockWF.z < -gridSizeH || pBlockWF.z > gridSizeH) );\n    bool onEastWest = (pBlockWF.z >= -gridSizeH && pBlockWF.z <= gridSizeH && (pBlockWF.x < -gridSizeH || pBlockWF.x > gridSizeH) );\n\n    #if defined(DEBUG_RENDER_RAILS)\n    //Road Main Beams\n    //FIXME: the length of beams *0.8?!?!\n    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));\n    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF.zyx)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));\n\n    //Intersection Main Beams\n    newDistance = min(newDistance,sdCircle( abs(pBlockWF.xz) - vec2(2.0,2.2), 0.05 ));\n    newDistance = min(newDistance,sdCircle( abs(pBlockWF.zx) - vec2(2.0,2.2), 0.05 ));\n\n    //dont crossbrase the road\n    if (pBlockWF.y < -gridSizeH || pBlockWF.y > gridSizeH) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));\n    }\n\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));\n\n    if (onNorthSouth) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));\n    }\n\n    if (onEastWest) {\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));\n        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_RAIL;\n        hit.neon = vec3(0.0);\n    }\n    #endif\n\n\n    // Lights\n    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.2,1.25,2.0), vec3(2.0,1.25,2.2), 0.1));\n\n    if (onNorthSouth) {\n        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));\n    }\n\n    if (onEastWest) {\n        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_NEON;\n        hit.neon = roadLightColour*4.0;\n    }\n\n    //Buildings.\n    //rework the grids so 0,0,0 is the center of the buildings\n    pBlockCenter = position;\n\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n\n    //wold position of the center of the grid, positionGI*blockSize\n    pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    pBlockWF = pBlockF*blockSize; \n\n    float floorCount=2.0;\n    float buildingFloor = floor(pBlockWF.y);\n    float blockHash = hash21(pBlockI.xz);\n    float round = clamp(blockHash-0.5,0.0,0.5);\n    for(float i=-floorCount;i<=floorCount;i++) {\n        float width=valueNoise1du(buildingFloor + i + blockHash)*0.1+0.8;\n        float buildingfloorSize = floor(width * roadLength)*0.5+0.25;\n        buildingfloorSize-=round;\n        newDistance = min(newDistance, sdBox(vec3(pBlockWF.x,fract(pBlockWF.y)-i,pBlockWF.z), vec3(buildingfloorSize,0.5-round,buildingfloorSize))-round);\n    }\n\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_WALL;\n        hit.neon = vec3(0.0);\n    }\n\n    //Corners\n    newDistance = min(newDistance, sdBox( abs(pBlockWF.xz)-(roadLength*0.5)+(gridSize*0.4), vec2(0.5) ) - 0.5 );\n\n    //Mid Beams\n    if (abs(pBlockWF.z) < (roadLength*0.5)) {\n        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.x)-(roadLength*0.5)+(gridSize*0.2),pCellWF.z), vec2(0.375) ) - 0.125);\n    }\n    if (abs(pBlockWF.x) < (roadLength*0.5)) {\n        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.z)-(roadLength*0.5)+(gridSize*0.2),pCellWF.x), vec2(0.375) ) - 0.125);\n    }\n    if (newDistance < hit.distance) {\n        hit.origin = position;\n        hit.distance = newDistance;\n        hit.materialId = MAT_SOLID;\n        hit.neon = vec3(0.0);\n    }\n\n    return hit;\n}\n\nrayMarchHit RayMarch(ray ray, float maxDistance, float minSurfaceDistance, int maxSteps, float time)\n{\n    rayMarchHit hit;\n    //float lastDistance = 1.0;\n    float accumilatedDistance = 0.0;\n    vec3 accumilatedNeon = vec3(0.0);\n    float modulatedMinSurfaceDistance = minSurfaceDistance;\n    int i;\n    for(i=0; i<maxSteps; i++) {\n        float distanceRatio = clamp((accumilatedDistance/maxDistance),0.0,1.0);\n\n        //the more itterations the less precise we are, improve perfomance a bit with only mild artifacts\n        modulatedMinSurfaceDistance=mix(minSurfaceDistance,minSurfaceDistance*20.0,distanceRatio);\n\n        vec3 currentPoint = ray.origin + ray.direction * accumilatedDistance;\n        hit = GetRayMarchHit(currentPoint, time);\n\n        if (hit.materialId==MAT_NEON) {\n            vec3 neon;\n            if (hit.distance > minSurfaceDistance) {\n                neon = (hit.neon) * max(1.0-hit.distance/2.0,0.0) * 0.05;\n            }\n            neon *= 1.0-distanceRatio;\n\n            float lightStrobe = getRoadLightStrobe(accumilatedDistance, time);\n\n            accumilatedNeon += neon*lightStrobe;\n        }\n        #if defined (DEBUG_RAY_DITHER)\n        if(hit.distance > 0.0) {\n            //we take smaller steps closer to the camera, gives a better Neon result.           \n            hit.distance *= 0.5+mix(distanceRatio,1.0, hash31(fract(currentPoint+time)))*0.5;\n        }\n        #endif\n\n        accumilatedDistance += hit.distance;\n\n        if(accumilatedDistance >= maxDistance) {\n            accumilatedDistance = maxDistance;\n            hit.surfaceNormal = -ray.direction;\n            hit.materialId=MAT_SKY;\n            break;\n        }\n        //terminate if we are very close or bounce back out if we end up within an object. \n        //else if(hit.distance > -minSurfaceDistance && hit.distance < minSurfaceDistance) {\n\n        //forget bouncing back, if we end up inside just terminate\n        else if(hit.distance < modulatedMinSurfaceDistance) {\n            break;\n        }\n\n    }\n    hit.iteration = i;\n    hit.distance = accumilatedDistance;\n    hit.neon = accumilatedNeon;\n    return hit;\n}\n// ========== ==========\n\n// ========== Texturing ==========\n\n\nfloat getConcreteErosion(vec3 position, bool showLine) {\n    float concrete=0.0;\n    concrete+= valueNoise3du(position * 4.0) * 0.25;\n    concrete+= valueNoise3du(position * 8.0) * 0.125;\n    concrete+= valueNoise3du(position * 16.0) * 0.0625;\n    concrete+= valueNoise3du(position * 32.0) * 0.03125;\n    concrete/=0.25+0.125+0.0625+0.03125;\n    concrete = (abs(concrete*2.0-1.0)+0.3);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        if(line < 0.05) {\n            line = smoothstep(-0.5,1.0,clamp(line*15.0,0.0,1.0));\n            line = 1.0-line;\n            line*=4.0;\n            line=1.0-line;\n            line = clamp(line,-10.0,1.0);\n            concrete = min(line,concrete*line);\n        }\n    }\n\n    return concrete;\n}\n\nfloat sampleConcrete(vec3 position, bool showLine) {\n    float concrete;\n\n    concrete= valueNoise3du(position);\n    concrete+= valueNoise3du(position * 2.0) * 0.5;\n    concrete+= valueNoise3du(position * 4.0) * 0.25;\n    concrete+= valueNoise3du(position * 8.0) * 0.125;\n    concrete+= valueNoise3du(position * 16.0) * 0.0625;\n    concrete/=1.0+0.5+0.25+0.125+0.0625;\n    concrete = (abs(concrete*2.0-1.0)+0.9);\n\n    if(showLine) {\n        float line = abs(fract(position.y)-0.5);\n        if(line < 0.05) {\n            line = smoothstep(0.0,1.0,clamp(line*10.0,0.0,1.0))*3.0;\n            line = clamp(line+0.5,0.0,1.0);\n            concrete *= line;\n        }\n    }\n\n    return concrete;\n}\n\nfloat getConcrete(vec3 position, inout vec3 normal, bool showLine) {\n    vec3 rightDir = normalize(cross(vec3(0.0,1.0,0.0), normal))*0.00001;\n    vec3 upDir =  normalize(cross(normal, rightDir))*0.00001;\n\n    float center = getConcreteErosion(position, showLine);\n    float right = getConcreteErosion(position+rightDir, showLine);\n    float up = getConcreteErosion(position+upDir, showLine);\n    \n    //FIXME: apply correct normal calculations, this is NOT how you do it!\n    //vec3 worldNormal = tangent * texNormal.x + binormal * texNormal.y + normal * texNormal.z;\n    vec3 pNormal;\n    pNormal=(vec3(\n        right - center,\n        up - center,\n        right - center\n    ));\n\n    pNormal*=-3000.0;\n    normal = normalize(normal + pNormal);\n    float concrete=sampleConcrete(position, showLine);//*0.5+0.5;\n    return concrete;\n}\n\nvoid textureSolid(vec2 block, vec3 position, inout vec3 colour, inout vec3 normal) {\n    float concrete = getConcrete(position, normal, true);\n    colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n    colour = clamp(colour,vec3(0.0),vec3(1.0));\n    colour *= concrete;\n}\n\nvoid textureWall(vec2 block, vec3 position, inout vec3 colour, inout vec3 normal, inout int material) {\n    float scale = 2.0;\n\n    float windowHeight =\thash21(block*39.195)*0.4+0.4;\n    float windowWidth =\t\thash21(block*26.389)*0.7+0.2;\n\n    if (windowWidth > 0.8){\n        windowWidth=1.0;\n    }\n\n    vec3 ramp = fract(position*scale)*2.0-1.0;\n\n    vec2 uv;\n    if (windowWidth==1.0) {\n        uv.x=0.0; \n    } else if (abs(ramp.x) > abs(ramp.z)) {\n        uv.x = ramp.x;\n    } else {\n        uv.x = ramp.z;\n    }\n    uv.y = ramp.y;\n\n    if ( (abs(uv.x) < windowWidth) && abs(uv.y) < windowHeight) {\n        colour=vec3(0.0);\n        material = MAT_WINDOW;\n    } else {\n        //uv.x=clamp(abs(uv.x)-windowWidth,0.0,1.0)/(1.0-windowWidth);\n        //uv.y=clamp(abs(uv.y)-windowHeight,0.0,1.0)/(1.0-windowHeight);\n\n        //Remove vertical lines when windows are close togther\n        if (windowWidth>=0.7) {\n            uv.x=0.0; \n        }\n\n        //FIXME: apply correct normal calculations, this is NOT how you do it!\n        vec3 pNormal;\n        uv*=uv*uv*0.5;\n        pNormal = vec3(uv.x,uv.y,uv.x);\n        normal = normalize(normal-pNormal);\n\n        float concrete = getConcrete(position, normal, false);\n        colour = hash33(block.xyx) * vec3(0.25,0.1,0.2) + 0.5;\n        colour = clamp(colour,vec3(0.0),vec3(1.0));\n        colour *= concrete;\n    }\n}\n\n// ========== ==========\n\nfloat getOcclusion( in vec3 origin, in vec3 normal, float time)\n{\n    float occlusion = 0.0;\n    float scale = 2.0;\n    rayMarchHit hit;\n\n    for( float i=0.0; i<3.0; i++ )\n    {\n        float distance = 0.1*i;\n        vec3  currentPoint = origin + distance*normal;\n        hit = GetRayMarchHit(currentPoint, time);\n        occlusion += (distance-hit.distance)*scale;\n        scale *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occlusion, 0.0, 1.0 );\n}\n\nfloat getShadow(vec3 origin, vec3 destination, float soft, float time) {\n    float currentDistance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW;\n    float maxDistance = distance(destination, origin);\n    vec3 direction = normalize(destination-origin);\n    rayMarchHit rayMarchHit;\n    float light = 1.0;\n\n    for(int i=0; i<RAY_MAX_STEPS_SHADOW; i++) {\n        vec3 currentPoint = origin + direction*currentDistance;\n        rayMarchHit = GetRayMarchHit(currentPoint, time);\n        //Soft Shadows!\n        light = min(light,soft * rayMarchHit.distance/currentDistance);\n        currentDistance += rayMarchHit.distance;\n        if(currentDistance > maxDistance) {\n            break;\n        } else if(rayMarchHit.distance < OBJECT_MIN_SURFACE_DISTANCE_SHADOW) {\n            light = 0.0;\n            break;\n        }\n    }\n\n    return light;\n}\n\nvoid getOffsetLight(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance = length(lightOffset);\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    dotProd *= diffuseBrightness;\n    specularBrightness = dotProd;\n}\n\nvoid getOffsetLight2(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, bool xAligned, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {\n    float distance;\n\n    if(xAligned) {\n        distance = sdXAlignedCylinder(lightOffset, 0.4, 0.1 );\n    } else {\n        distance = sdZAlignedCylinder(lightOffset, 0.4, 0.1 );\n    }\n\n    if (distance > maxDistance) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n    vec3 lightDirection = normalize(lightOffset);\n    float dotProd = dot(lightDirection,normal);\n\n    if (dotProd <= 0.0) {\n        diffuseBrightness=0.0;\n        specularBrightness=0.0;\n        return;\n    }\n\n    //fake the light falloff to limit distance\n    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));\n    fallOff*=fallOff;\n\n    //dotProd = pow(dotProd,shine);\n    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;\n\n    vec3 specDirection = reflect(lightDirection, normal);\n    dotProd = dot(specDirection, rayDirection);\n    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);\n    dotProd *= diffuseBrightness;\n    specularBrightness = dotProd;\n}\n\nvoid getLight(vec3 position, vec3 normal, vec3 rayDirection, float shininess, vec3 cameraOrigin, out vec3 diffuseLight, out vec3 specularLight, float time) {\n    diffuseLight = vec3(0.0);\n    specularLight = vec3(0.0);\n\n    // -- Camera Light\n    vec3 lightOrigin = cameraOrigin;\n\n    float diffuseBrightness;// = 0.0;\n    float specularBrightness;// = 0.0;\n\n    getOffsetLight(position, normal, rayDirection,lightOrigin-position, 9.0, shininess, diffuseBrightness, specularBrightness);\n    diffuseLight = vec3(0.5 * diffuseBrightness);\n    specularLight = vec3(0.5 * specularBrightness);\n    // -- Road Lights\n\n    //get the closest road light\n    vec3 pBlockCenter = position+(0.5*blockSize);\n\n    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0\n    vec3 pBlockI = floor(pBlockCenter/blockSize);\n    // fraction of distance withinteh grid, -0.5 to + 0.5\n    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;\n    //wold position of the center of the grid, positionGI*blockSize\n    //vec3 pBlockWI = pBlockI*blockSize;\n    // -0.5*blockSize to +0.5*blockSize\n    vec3 pBlockWF = pBlockF*blockSize;\n    // Cell\n    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;\n\n    //sample just past the cross over point, has some artifacts but enlarges the light area.\n    float maxDistance = gridSize*0.75;\n\n    float lightStrobe;\n    vec3 lightPositionOffset;\n\n    if(abs(pBlockWF.y) -1.0 < gridSize) {\n\n        if(pBlockWF.y>0.0) {\n            lightPositionOffset.y = 1.0-pBlockWF.y;\n        } else {\n            lightPositionOffset.y = -1.0-pBlockWF.y;\n        }\n\n        // North/South\n        if(abs(pBlockWF.x) < gridSize) {\n            if(pBlockWF.z > gridSize*-0.5 && pBlockWF.z < 0.0) {\n                lightPositionOffset.z = -pCellWF.z - gridSize;\n            } else if(pBlockWF.z < gridSize*0.5 && pBlockWF.z > 0.0) {\n                lightPositionOffset.z = -pCellWF.z + gridSize;\n            } else {\n                lightPositionOffset.z = -pCellWF.z;\n            }\n            if(pBlockWF.x>0.0) {\n                lightPositionOffset.x = 2.0-pBlockWF.x;\n            } else {\n                lightPositionOffset.x = -2.0-pBlockWF.x;\n            }\n\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            if(lightStrobe>0.0) {\n                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, true, maxDistance, shininess, diffuseBrightness, specularBrightness);\n                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n                specularLight += roadLightColour * (specularBrightness*lightStrobe);\n            }\n        }\n\n        // East/West\n        if(abs(pBlockWF.z) < gridSize) {\n\n            if(pBlockWF.x > gridSize*-0.5 && pBlockWF.x < 0.0) {\n                lightPositionOffset.x = -pCellWF.x - gridSize;\n            } else if(pBlockWF.x < gridSize*0.5 && pBlockWF.x > 0.0) {\n                lightPositionOffset.x = -pCellWF.x + gridSize;\n            } else {\n                lightPositionOffset.x = -pCellWF.x;\n            }\n            if(pBlockWF.z>0.0) {\n                lightPositionOffset.z = 2.0-pBlockWF.z;\n            } else {\n                lightPositionOffset.z = -2.0-pBlockWF.z;\n            }\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            if(lightStrobe>0.0) {\n                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, false, maxDistance, shininess, diffuseBrightness, specularBrightness);\n                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n                specularLight += roadLightColour * (specularBrightness*lightStrobe);\n            }\n        }\n    } \n\n    // Up/Down\n    maxDistance = gridSize*1.4;\n    if (abs(pBlockWF.x)-2.0 < maxDistance && abs(pBlockWF.z)-2.0 < maxDistance) {\n        if(pBlockWF.x>0.0) {\n            lightPositionOffset.x = 2.0-pBlockWF.x;\n        } else {\n            lightPositionOffset.x = -2.0-pBlockWF.x;\n        }\n\n        if(pBlockWF.z>0.0) {\n            lightPositionOffset.z = 2.0-pBlockWF.z;\n        } else {\n            lightPositionOffset.z = -2.0-pBlockWF.z;\n        }\n\n        lightPositionOffset.y = 0.0-pCellWF.y;\n\n        lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n        getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n        diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n        specularLight += roadLightColour * (specularBrightness*lightStrobe);\n\n        //apply lights from above and below to get smooth transitions\n        if (pCellWF.y>0.0) {\n            lightPositionOffset.y = gridSize-pCellWF.y;\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n            specularLight += roadLightColour * (specularBrightness*lightStrobe);\n        } else {\n            lightPositionOffset.y = -gridSize-pCellWF.y;\n            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);\n            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);\n            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*5.0);\n            specularLight += roadLightColour * (specularBrightness*lightStrobe);\n        }\n    }\n}\n\n// ========== ==========\n\n// ========== Calculate Normal ==========\n\nfloat map(in vec3 pos, float time ){\n    return GetRayMarchHit(pos, time).distance;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n\n    #if 0\n    vec2 e = vec2(1.0,-1.0)*0.005773;\n    return normalize( e.xyy*map( pos + e.xyy, time ) + \n                     e.yyx*map( pos + e.yyx, time ) + \n                     e.yxy*map( pos + e.yxy, time ) + \n                     e.xxx*map( pos + e.xxx, time ) );\n    #else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time);\n    }\n    return normalize(n);\n    #endif    \n}\n// ==========  ==========\n\n// ========== Entry Point ==========\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    float time = iTime;\n    //vec3 debugOverlay = vec3(0.0);\n\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n\n    //Snap to center on startup.\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    camera camera = getCamera(mouse, time);\n\n    // --\n    ray ray = getRay(uv, camera);\n    rayMarchHit hit = RayMarch(ray, RAY_MAX_DISTANCE, OBJECT_MIN_SURFACE_DISTANCE, RAY_MAX_STEPS, time);\n    hit.surfaceNormal = calcNormal( hit.origin, time );\n\n    // ---- Render\n    vec3 colour;\n    vec3 skybox = mix(vec3(0.03,0.1,0.25),vec3(0.5,0.4,0.3),(ray.direction.y*0.5+0.5)+0.2);\n\n    if (hit.materialId == MAT_WALL) {\n        vec2 block= floor(hit.origin.xz/blockSize);\n        textureWall(block, hit.origin, colour, hit.surfaceNormal, hit.materialId);        \n    }else if (hit.materialId == MAT_SOLID) {\n        vec2 block= floor(hit.origin.xz/blockSize);\n        textureSolid(block, hit.origin, colour, hit.surfaceNormal);        \n    }else if (hit.materialId == MAT_NEON) {\n        #if defined(DEBUG_WHITE_NEON)\n        float lightStrobe = getRoadLightStrobe(hit.distance, time);\n        colour = mix(roadLightColour*0.1,vec3(4.0),lightStrobe);\n        #else \n        colour = vec3(0.0);\n        #endif\n    } else {\n        colour = vec3(0.5,0.4,0.3);\n    }\n\n    if(hit.materialId == MAT_WINDOW) {\n        vec3 hash = hash33(floor(hit.origin*2.0));\n        float on = (hash.x+hash.y+hash.z)+sin(time*0.4+hash.y)*0.05;\n        if(on >1.5) {\n            vec3 wColour = normalize(hash+vec3(0.99));\n            colour=wColour * 5.0;\n        } else {\n            colour=vec3(0.0);\n        }\n    }\n\n    #if defined(DEBUG_LIGHTING)\n    if (hit.materialId != MAT_NEON && hit.materialId != MAT_SKY) {\n        vec3 diffuseLight;\n        vec3 specularLight;\n        float shininess = 10.0;\n        float specularIntensity = 0.1;\n\n        if (hit.materialId == MAT_SOLID) {\n            shininess = 2.0;\n            specularIntensity = 0.1;\n        } else if (hit.materialId == MAT_WALL) {\n            shininess = 20.0;\n            specularIntensity = 0.5;\n        } else if (hit.materialId == MAT_WINDOW) {\n            shininess = 100.0;\n            specularIntensity = 2.0;\n        } \n\n        getLight(hit.origin, hit.surfaceNormal, ray.direction, shininess, camera.origin, diffuseLight, specularLight, time);\n\n        #if defined(DEBUG_AMBIENT)\n        vec3 ambient = skybox*0.5;\n        #if defined(DEBUG_AMBIENT_OCCLUSION)\n        if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n            ambient *=(getOcclusion(hit.origin, hit.surfaceNormal, time));\n        }\n        #endif\n        diffuseLight += ambient;\n        #endif\n\n        if (hit.materialId != MAT_WINDOW) {\n            colour*=diffuseLight;\n        }\n        colour+=(specularLight*specularIntensity);\n\n    }\n    #endif\n\n    #if defined(DEBUG_OCCLUSION)\n    if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {\n        colour *=(getOcclusion(hit.origin, hit.surfaceNormal, time));\n    }\n    #endif\n\n    #if defined(DEBUG_DISTANCE_FOG)\n    float distanceFog = hit.distance/RAY_MAX_DISTANCE;\n    colour = mix(colour, skybox, distanceFog);\n    #endif\n\n    #if defined (DEBUG_FACE_FOG)\n    float faceFog = getFog(ray.direction+ray.origin,time) * (0.4+0.1*sin(time*0.1));\n    colour += hit.neon * (0.5+faceFog*2.0);\n    colour = mix(colour, vec3(2.0), faceFog);\n    //colour=vec3(faceFog);\n    #else\n    colour += hit.neon;\n    #endif\n\n    // Exposure and Gamma \n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n\n    //Clamp\n    colour = clamp(colour,0.0,1.0); \n\n    // colour grading\n    //colour = colour*vec3(1.0,0.8,0.9);\n    // compress        \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    #if defined(DEBUG_VIGNETTE) \n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv; \n    float vignette = clamp(pow( uv.x*uv.y*5.0,0.5)+0.4,0.0,1.0);\n    //Burn it in\n    colour=vec3(1.0)-((vec3(1.0)-colour)/vignette);\n    #endif\n\n    fragColour = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}