{"ver":"0.1","info":{"id":"MdyfWw","date":"1529607127","viewed":6306,"name":"Jupiter","username":"viclw17","description":"Jupiter UV effect WIP\nTry increasing iteration, and enabling fullscreen to see less aliasing artifact. :)\n\nBased on --> https://www.shadertoy.com/view/ltc3Rj\nBlog post --> http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["2d","uv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float iteration = 10.;\nfloat timeScale = 3.;\nvec2 zoom = vec2(25.,5.5);\nvec2 offset = vec2(0,2.);\n\n//////////////////////////////////////////////////////////////////////\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 scene( in vec3 pos )//reception d'une sphere\n{\n    vec3 dim = vec3(1, 1, 1);\n    \n    pos += vec3(0, 0., 0);\n    \n    float resSphere = sdSphere(pos, 1.3);\n    \n   \n    vec2 res = vec2(resSphere, 2.);\n    \n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\nvec2 getUV(vec3 pos)\n{\n    vec3 nor = calcNormal(pos);\n    float lon = atan(nor.x,nor.z)/3.14;\n    float lat = acos(nor.y)/3.14;\n    vec2 r = vec2(lat, lon);\n    \n    return r;\n}\n\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\n{\n    float dMin = 1.;\n    float dMax = 50.;\n    float precis = 0.002;\n    float traveledDistance = dMin;\n    float color = -1.;\n    \n    for( int i = 0 ; i < 50 ; i++ )\n    {\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\n        \n        if( res.x<precis || traveledDistance>dMax )\n        {\n            break;\n        }\n        \n        traveledDistance += res.x;\n        color = res.y;\n    }\n    \n    if( traveledDistance > dMax )\n    {\n        color = -1.0;\n    }\n    return vec2( traveledDistance, color );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);//z (dir)\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalisÃ©)\n    return mat3( cu, cv, cw );\n}\n\n/*\nfloat makeCheker(vec2 p)\n{\n    vec2 checker = p*10.;\n    vec2 cells = floor(checker);\n    float chekerColor = 0.;\n    if(mod(cells.x+cells.y, 2.)== 0.)\n    {\n        chekerColor = 1.;\n    }\n    else\n    {\n     \tchekerColor = 0.;   \n    }\n    return chekerColor;\n}\n*/\n\nvec3 makeJupiter(vec2 uv)\n{\n\tfloat time = iTime;\n    vec2 point = uv * zoom + offset;\n    float p_x = float(point.x); \n    float p_y = float(point.y);\n    \n    float a_x = .2;\n    float a_y = .3;\n    \n    for(int i=1; i<int(iteration); i++){\n        float float_i = float(i); \n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\n        point.y+=a_y*cos(float_i*point.x);\n    }\n    \n    float r = sin(point.y)*.5+.4;\n    float g = cos(point.y)*.5+.7;\n    float b = cos(point.y)*.5+.8;\n    \n    r+=.3;\n    \n    r = cos(point.x+point.y+1.3)*.5+.5;\n    g = sin(point.x+point.y+2.)*.5+.5;\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\n      \n     \n    r = pow(r,.8);\n    g = pow(g,.8);\n    b = pow(b,1.);\n    \n    vec3 col = vec3(r,g,b);\n    col += vec3(.1);\n    \n    return col;\n}\n\nvec2 seeCoords(vec2 p)\n{\n    return p.xy;\n}\n\nvec2 arrangeCoords(vec2 p)\n{\n    vec2 q = p.xy/iResolution.xy;\n    vec2 r = -1.0+2.0*q;\n\tr.x *= iResolution.x/iResolution.y;\n    return r;\n}\n\n//->START\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = arrangeCoords(fragCoord);\n     \n    vec3 lookAt = vec3(0.);\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\n    camPos = vec3(2,2.1,2.);\n    \n    mat3 camera = setCamera(camPos, lookAt, 0.);\n    \n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \n    \n    float rayDistance = rayResult.x;\n    float rayColor = rayResult.y;\n    vec3 hitPos = camPos + rayDirection*rayDistance;\n    vec2 chekerUv;\n    \n    vec3 color;\n    \n    vec3 sphereColor = vec3(0, 0, 0);  \n    \n    if(rayColor > 1.)\n    {\n        color = vec3(1. , 0.4 ,0.1 );\n     \n        if(rayDistance>1.)\n        {\n        \tchekerUv = getUV(hitPos);\n            //sphereColor = vec3(makeCheker(chekerUv));\n            sphereColor = vec3(makeJupiter(chekerUv));\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\n        }       \n    }\n    else\n    {\n        color = vec3(0., 0., 0.);\n    }\n   \n    vec3 pos = camPos + rayDistance * rayDirection;\n    vec3 nor = calcNormal( pos );\n    \n\n\t\n    fragColor = vec4(sphereColor, 1);\n}","name":"Image","description":"","type":"image"}]}