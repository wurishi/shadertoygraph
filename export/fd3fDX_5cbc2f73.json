{"ver":"0.1","info":{"id":"fd3fDX","date":"1657305225","viewed":262,"name":"Shady Bridge","username":"panna_pudi","description":"Parallel to ray walls? Pfff!","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["3d","tunnel","walls","concrete","shadowmap","vollight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    \n    vec3 col = tex.rgb;\n    \n    col = pow(col, vec3(1. / 2.2));\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LIGHT_FALLOFF 8.0\nvec3 LIGHT_POS;\nfloat day; float day_night; bool is_day; vec3 sun_color; float angle;\n\nfloat shadow_mask(vec2 p) {\n    float s = 2.1;\n    p.y = mod(p.y - s / 2., s) - s / 2.;\n    \n    float w = .7;\n    float d = sd_square(p, vec2(1., w));\n    float hole = length(p) - w / 4.;\n    d = max(d, -hole);\n    return clamp(smoothstep(-0.25, 0.25, d) + 0.5, 0., 1.);\n}\n\nconst float REP_DIST = 2.1;\n\nfloat shapes(vec2 p, float w, float id) {\n    vec2 center = p - vec2(0., id);\n    id = hash11(id);\n    float d;\n    if (id < 0.333) {\n        d = length(p - vec2(0.0, 0.)) - w;\n    } else if (id < 0.666) {\n        p = id > 0.45 ? rot(PI / 4.) * p : p;\n        d = sd_square(p, vec2(w / sqrt(2.)));\n    } else {\n        p = id > 0.45 ? rot(sqrt(3.)) * p : p;\n        p.y += 0.1;\n        d = sd_trig(p / w) * w; \n    }\n    return d;\n}\n\nfloat map(vec3 p) {\n    p -= vec3(1.06, -0.6, 0.0);\n    p.xy *= rot(PI / 8.);\n    \n    float s = REP_DIST;\n    float id = floor((p.z + s / 2.) / s); \n    p.z = mod(p.z - s / 2., s) - s / 2.;\n    \n    float box = sd_box(p, vec3(0.3, 2.62, 0.8)) - 0.03;\n    float holes = shapes(p.yz, 0.3, id);\n    \n    float d = max(box, -holes);\n    \n    return d;\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.001);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nvec2 march(vec3 ro, vec3 rd, int steps, float tmin, float tmax) {\n    float t = tmin, eps = 1.0 / iResolution.y;\n    for (int i = 0; i < steps; ++i) {\n        float d = map(ro + rd * t);\n        if (d < eps * t) { return vec2(t, 1.); }\n        t += d;\n        if (t > tmax) { return vec2(1e9, -1.); }\n    }\n    return vec2(t, -1.);\n}\n\n// eiffie https://www.shadertoy.com/view/XsKGRz\nint SHADOWMAP_STEPS = 32;\nfloat build_shadow_map(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv *= vec2(PI * 2.0, PI);\n    vec3 rd = vec3(cos(uv.y) * cos(uv.x), sin(uv.y), cos(uv.y) * sin(uv.x));\n    vec2 t = march(LIGHT_POS, rd, SHADOWMAP_STEPS, 0., LIGHT_FALLOFF);\n    return t.x;\n}\n\nvec3 march_shadow_map(vec3 ro, vec3 rd, float hit_dist, vec2 fragCoord) {\n    float dt = min(hit_dist, LIGHT_FALLOFF) / float(SHADOWMAP_STEPS);\n    float t = dt * hash31(rd);\n    vec3 col = vec3(0.);\n    for (int i = 0; i < SHADOWMAP_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        vec3 light = p - LIGHT_POS;\n        float d = length(light);\n        if (d < LIGHT_FALLOFF) {\n            light /= d;\n            float phi = asin(light.y);\n            vec2 pt = vec2(asin(light.z / cos(phi)), phi);\n            if (light.x < 0.0) { pt.x = sgn(light.z) * PI - pt.x; }\n            pt /= vec2(PI * 2.0, PI);\n            pt += 0.5;\n            if (d < texture(iChannel0, pt).w * LIGHT_FALLOFF) {\n                col += sun_color / (2.0 + 5.0 * d * d);\n            }\n        }\n        t += dt;\n        if (t > LIGHT_FALLOFF) { break; }\n    }\n    return col;\n}\n\nbool trace(in vec3 ro, in vec3 rd, inout Hit hit) {\n    bool is_bonked = false;\n\n    float plane_dist = 1e9;\n    vec3 plane_norm = normalize(vec3(0., -1., 0.));\n    bool floor = clamped_plane(ro, rd, vec3(-0.7, -1.0, 0.), plane_norm, 1.7, plane_dist);\n    if (floor) {\n        hit = _min(hit, Hit(plane_dist, vec3(1.), -plane_norm));\n        is_bonked = true;\n    }\n\n    plane_norm = normalize(vec3(0.9, 1., 0.));\n    bool ceiling = clamped_plane(ro, rd, vec3(-0.3, 1.2, 0.), plane_norm, 2.2, plane_dist);\n    if (ceiling) {\n        hit = _min(hit, Hit(plane_dist, vec3(1.), -plane_norm));\n        is_bonked = true;\n    }\n\n    plane_norm = normalize(vec3(-1., 0.2, 0.));\n    bool left_wall = clamped_plane(ro, rd, vec3(-1.5, 0., 0.), plane_norm, 2.0, plane_dist);\n    if (left_wall) {\n        hit = _min(hit, Hit(plane_dist, vec3(1.), -plane_norm));\n        is_bonked = true;\n    }\n\n    plane_norm = -plane_norm;\n    bool right_wall = clamped_plane(ro, rd, vec3(0.2, -0.5, 0.), plane_norm, 0.6, plane_dist);\n    if (right_wall) {\n        vec2 apertures = march(ro, rd, 50, plane_dist, plane_dist + 10.);\n        if (apertures.y > 0.) {\n            vec3 norm = get_norm(ro + rd * apertures.x);\n            hit = _min(hit, Hit(apertures.x, vec3(1.), norm));\n            is_bonked = true;\n        }\n    }\n\n    return is_bonked;\n}\n\n// iq's soft shadows\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float pres = is_day ? 0.01 : 0.0001;\n    for (float t = mint; t < maxt;) {\n        float h = map(ro + rd * t);\n        if (h < pres) return 0.0;\n        \n        float y = h * h / (5. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0.0, t - y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 ro;\nfloat shading(in vec3 pos, in vec3 nor) {\n    float shade = 0.;\n    float intensity = 1.0;\n    if (!is_day) intensity = 0.1;\n    \n    vec3 light_pos = ro - vec3(0., 0.1, 5.);\n    vec3 light_dir = normalize(light_pos - pos);\n    float shade0 = dot(light_dir, nor);\n    shade += intensity * mix(max(shade0, 0.), shade0 * 0.5 + 0.5, 0.05);\n\n    vec3 lp = LIGHT_POS;\n    vec3 ld = normalize(lp - pos);\n    if (is_day) {\n        float angle = PI / 3.3 - angle * 0.25 * PI / 2.;\n        vec2 xy = vec2(cos(angle), sin(angle));\n        ld = normalize(vec3(xy, 0.));\n    }\n    shade += softshadow(pos, ld, .0, 50., 60.);\n    \n    shade = mix(max(shade, 0.), shade * 0.5 + 0.5, 0.05);\n    return shade;\n}\n\nconst float DAY_LENGTH = 10.; const float DTENTH = DAY_LENGTH / 20.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * 0.5 + 2.5;\n    day = mod(time, DAY_LENGTH);\n    day_night = ladder(0., DAY_LENGTH / 2. + DTENTH, day) -\n                ladder(DAY_LENGTH / 2. - DTENTH, DAY_LENGTH, day);\n    is_day = day_night < 0.;\n    sun_color = sky_col(1. - abs(day_night));\n    LIGHT_POS = vec3(1.5, -1., -4.5 + time);\n    angle = 0.5 * (S(0., DTENTH, mod(day, DAY_LENGTH / 2.)) +\n        S(DAY_LENGTH / 2. - DTENTH, DAY_LENGTH / 2., mod(day, DAY_LENGTH / 2.)));\n    //vec2 m = iMouse.xy / iResolution.xy;\n    angle = PI / 2. + angle * PI * 1.1;\n    LIGHT_POS.xy += 2.* vec2(-cos(angle), sin(angle));\n    \n    ro = vec3(-0.5, 0., -9.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    ro.z += time;\n\n    float shad = build_shadow_map(fragCoord);\n    vec3 col = vec3(0.);\n    \n    Hit hit = default_hit();\n    bool is_bonked = trace(ro, rd, hit);\n    if (is_bonked) {\n        vec3 pos = ro + rd * hit.dist;\n        vec3 nor = hit.norm;\n        float focc = 2.1 - length(pos.xy - vec2(-0.1, 0.1));\n        float shade = shading(pos, nor);\n\n        vec3 light_col = vec3(1.0, 0.8, 0.7) * 0.7;\n        light_col = sun_color;\n        light_col = clamp(light_col, 0., 0.6);\n        \n        vec3 albedo = boxmap(iChannel1, pos, nor, 1.).rgb;\n        vec3 noise = texture(iChannel2, pos.zx * .3).rgb * .1;\n\n        vec3 q = pos;\n        q.xy *= rot(PI / 8.);\n        float dimple = smoothstep(-0.02, 0.05, abs(q.x + 0.5 + noise.x));\n        albedo = mix(vec3(0.57, .9, 0.) * noise * 2.5, albedo, dimple);\n  \n        col = shade * light_col * focc * albedo;\n        \n        if (!is_day) {\n            col += march_shadow_map(ro, rd, hit.dist, fragCoord);\n        }\n    }\n\n    float fog = max(0., 1. - exp((9. - hit.dist) * .04));\n    col = mix(col, vec3(0.01), max(fog, 0.));\n\n    vec3 sunLig = vec3(5., -1.5, 0.);\n    vec3 q = ro + rd;\n    q.xy *= rot(PI / 6.);\n    vec2 blare_dir = q.yz;\n    \n    col += 0.09 * sun_color *\n           smoothstep(-2., 3., dot(rd - vec3(0.45, 0., 0.), sunLig)) *\n           shadow_mask(blare_dir) * float(is_day);\n           // * (1. + min(0., day_night));\n    \n    fragColor = vec4(col, sat(shad / LIGHT_FALLOFF));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float MIN_FLOAT = 1e-6;\nconst float MAX_FLOAT = 1e6;\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n#define sat(x) clamp(x, 0., 1.)\n#define S(a, b ,x) smoothstep(a, b, x)\nfloat sgn(float x) { return (x < 0. ? -1. : 1.); }\n\nfloat ladder(float a, float b, float x) {\n    float w = (b - a) / 10.;\n    return S(a, a + w, x) - S(b - w, b, x);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct Hit {\n    float dist;\n    vec3 albedo;\n    vec3 norm;\n};\n\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nfloat sd_square(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat sd_trig(in vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1.0 / k;\n    if(p.x + k * p.y > 0.0) {\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nHit default_hit() {\n    return Hit(1e9, vec3(1.), vec3(0.));\n}\n\nfloat hash11(float p) {\n    return fract(sin(p * 78.233) * 43758.5453);\n}\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat hash31(vec3 p) {\n    return fract(sin(dot(p * 0.123, vec3(12.9898, 78.233, 112.166))) * 43758.5453);\n}\n\nvec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\n\nvec4 _min(vec4 a, vec4 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\n\nHit _min(Hit a, Hit b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k ) {\n    vec4 x = texture( s, p.yz );\n    vec4 y = texture( s, p.zx );\n    vec4 z = texture( s, p.xy);\n    \n    vec3 w = pow( abs(n), vec3(k) );\n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\n\nbool clamped_plane(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, in float border, out float dist) {\n    vec3 orto = cross(pn, vec3(0., 0., 1.));\n    bool floor = plane_hit(ro, rd, po, pn, dist);\n    vec3 hit_pos = ro + rd * dist;\n    vec3 from_orig = po - hit_pos;\n    return floor && abs(dot(orto, from_orig)) < border;\n}\n\nvec3 tone(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 sky_col(float x){\n    vec4 phases = vec4(0.98, 0.985, 0.99, 0.);\n    const vec4 amp = vec4(1.00, 1.00, 1.00, 0.);\n    const vec4 freq = vec4(-.41, -.44, -.47, 0.);\n    const vec4 offsets = vec4(-0.05, -0.04, -0.04, 0.);\n    phases *= TAU; x *= TAU;\n    return vec3(\n        offsets.r + amp.r * 0.5 * cos(x * freq.r + phases.r) + 0.5,\n        offsets.g + amp.g * 0.5 * cos(x * freq.g + phases.g) + 0.5,\n        offsets.b + amp.b * 0.5 * cos(x * freq.b + phases.b) + 0.5\n    );\n}","name":"Common","description":"","type":"common"}]}