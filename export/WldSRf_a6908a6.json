{"ver":"0.1","info":{"id":"WldSRf","date":"1581619184","viewed":63,"name":"random, triangular pdf remapping","username":"hornet","description":"visualising triangular pdf remapping","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["remap","pdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modification of https://www.shadertoy.com/view/4ssXRX\n// Added a second way to do triangle noise without doing\n// a second random sample.\n\nconst int NUM_BUCKETS = 128;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\n\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n\n// ====\n//note: from https://loopit.dk/rendering_inside.pdf\nfloat remap_pdf_tri_erp( const float v )\n{\n    float r2 = 0.5 * v;\n    float f1 = sqrt( r2 );\n    float f2 = 1.0 - sqrt( r2 - 0.25 );\n    return (v < 0.5) ? f1 : f2;\n}\n\n// ====\n//note: from https://www.shadertoy.com/view/Mt2XW1\nfloat remap_pdf_tri_tf( float v )\n{\n    float orig = v*2.0-1.0;\n    v = orig/sqrt(abs(orig));\n    \n    v = max(-1.0, v); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!   \n    v = v - sign(orig);\n\n\t//return v;\n    return v*0.5 + 0.5;\n}\n\n// ====\n//note: from https://github.com/Unity-Technologies/ScriptableRenderPipeline/blob/master/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/FinalPass.shader#L124\nfloat remap_pdf_tri_unity( float v )\n{\n    v = v*2.0-1.0;\n    v = sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n\n    //return v;\n    return v*0.5 + 0.5;\n}\n\n//note: from comments https://www.shadertoy.com/view/4t2SDh\nfloat remap_pdf_tri_aw(float rnd)\n{\n    rnd = fract(rnd + 0.5f);\n    float orig = rnd * 2.0f - 1.0f;\n    rnd = (orig == 0.0f) ? -1.0f : (orig / sqrt(abs(orig)));\n    rnd = rnd - sign(orig) + 0.5f;\n\n    //return rnd;\n    return rnd*0.5 + 0.25;\n}\nfloat remap_pdf_tri_aw_fixed( float rnd )\n{\n\tfloat in_rnd = rnd;\n\n\trnd = fract(rnd + 0.5f);\n\tfloat orig = rnd * 2.0f - 1.0f;\n\trnd = (orig == 0.0f) ? -1.0f : (orig / sqrt(abs(orig)));\n\trnd = rnd - sign(orig) + 0.5f;\n\t\n\tif (rnd < -1.0f)\n\t{\n\t\tif (in_rnd < 0.1f)\n\t\t\trnd = -0.5f;\n\t\telse if (in_rnd > 0.9f)\n\t\t\trnd = 1.5f;\n\t}\n\n\treturn rnd*0.5 + 0.25;\n}\n\nfloat remap_pdf_tri( float rnd, int idx )\n{\n    if ( idx==1 ) return remap_pdf_tri_erp( rnd );\n    else if ( idx==2 ) return remap_pdf_tri_tf( rnd );\n    else if ( idx==3 ) return remap_pdf_tri_unity( rnd );\n    else if ( idx==4 ) return remap_pdf_tri_aw_fixed( rnd );\n    //else if ( idx==4 ) return remap_pdf_tri_aw( rnd );\n        \n    return rnd;\n}\n\nfloat base_noise_rpdf( vec2 p )\n{\n    ivec2 ip = ( 1337 * iFrame + ivec2(p) ) % textureSize(iChannel0,0).xy;\n\treturn texelFetch( iChannel0, ip, 0 ).r;    \n}\n\nfloat bluenoise_swizzle( vec2 p )\n{\n    ivec2 ip = ( 1337 * iFrame + ivec2(p) ) % textureSize(iChannel0,0).xy;\n    vec2 c = texelFetch( iChannel0, ip, 0 ).rg;\n    return 0.5 * (c.r + c.g);\n}\nfloat bluenoise_swizzle_uv( vec2 uv )\n{\n    return bluenoise_swizzle( uv * iResolution.xy );\n}\n\nvec3 histcol = vec3(1,1,1);\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n    //TODO: calc num buckets from size on screen, to get one per pixel\n    \n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( truncate(t,NUM_BUCKETS_F), truncate(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tint bucketvali = 0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed;\n        //= float(i); // / ITER_PER_BUCKET_F;\n\t\t//float rnd = n1rand( vec2(seed,0.5) );\n        //float rnd = base_noise_rpdf( vec2(seed,0.5) );\n        \n\t\tfloat r, rm;\n        if ( iter < 1 )\n        {\n            seed = float(i) / ITER_PER_BUCKET_F;\n            //float rnd = base_noise_rpdf( vec2(seed,0.5) );\n            r = bluenoise_swizzle_uv( vec2(seed,0.5) ); //n2rand( vec2(seed,0.5) );\n            rm = 0.0;\n            histcol = mix( vec3(1,0,0), vec3(0,1,1), t ); //note: fake \"remap\"-coloring for illustration purposes\n        }\n        else\n        {\n            seed = float(i) / ITER_PER_BUCKET_F;\n            float rnd = base_noise_rpdf( vec2(ITER_PER_BUCKET_F*seed,0.5) );\n            r = remap_pdf_tri( rnd, iter );\n            rm = remap_pdf_tri( seed, iter );\n        }\n\t\t\n        float ival = step(bucket.x,r) * step(r,bucket.y);           \n        bucketvali += int(ival);\n\n        if ( step(bucket.x,rm)*step(rm,bucket.y) > 0.5 )\n        {\n            histcol = mix( vec3(1,0,0), vec3(0,1,1), seed );\n        }   \n\t}\n\n    float bucketval = float(bucketvali);\n\tbucketval /= ITER_PER_BUCKET_F;\n    bucketval *= float(NUM_BUCKETS);\n    bucketval /= 32.0;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nfloat sat( float v )\n{\n    return clamp( v, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx = int(5.0*uv.x);\n    vec2 uvrange = vec2(idx, idx+1)/5.0;\n\tif ( uv.x < 1.0/5.0 )\n\t{\n\t\to = bluenoise_swizzle(fragCoord);\n\t}\n\telse\n\t{\n\t\to = base_noise_rpdf(fragCoord); //n1rand( uv );\n        o = remap_pdf_tri( o, idx );\n\t}\n\n    \n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n    {\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    }\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n\n    if ( uv.y < 0.51 && uv.y > 0.5)\n        fragColor.rgb = vec3(fract(5.0*uv.x));\n\n    //note: display remapping graph\n    if ( uv.y > 1.0/4.0 && uv.y < 2.0/4.0 )\n    {\n        vec2 luv = vec2( fract(uv.x*5.0), remap(1.0/4.0, 2.0/4.0,uv.y) );\n        \n        float v = remap_pdf_tri(luv.x, idx);        \n        float t = sat( abs(v-luv.y) / dFdy(luv.y) );\n        \n        vec3 c = vec3(0.5);\n        c = mix( vec3(0.0), c, sat(abs(0.5-luv.y) / dFdy(luv.y)) );\n        c = mix( vec3(0.0), c, sat(abs(0.5-luv.x) / dFdx(luv.x)) );\n\n        c = vec3(mix( vec3(1.0), c, t ));\n        \n        fragColor = vec4( c, 1);\n\n    }\n\n    if ( uv.y < 1.0/4.0)\n        fragColor.rgb *= histcol;\n        \n    //display lines\n    if ( fract(5.0*uv.x) < 5.0*dFdx(uv.x) ) fragColor = vec4(0.0);\n}\n","name":"Image","description":"","type":"image"}]}