{"ver":"0.1","info":{"id":"NsffDs","date":"1645538130","viewed":462,"name":"2D noise on a Fibonacci sphere","username":"stegu","description":"2D simplex noise with \"flow noise\" features, but defined natively on a Fibonacci sphere instead of on a plane. Uses a modified version of the inverse Fibonacci sphere mapping by Keinert et al  (2015).\n\nUpdated to fix a weird bug with using an\"inout mat4\".","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["sphere","barycentric","inverse","fibonacci","chamfer"],"hasliked":0,"parentid":"fsffDl","parentname":"Patched Fibonacci sphere mapping"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sphere_size = 1.0; // Unit sphere\n    // The number of facets can be anything from 8 to 2e6\n    const float FibN = 471.0;\n\n    vec3 bgcolor = vec3(0.0, 0.0, 0.3);\n\n    // Default view: fit unit circle in viewport\n    vec3 uvw;\n    uvw.xy = (2.0*fragCoord- iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = pow(0.98,iMouse.y-abs(iMouse.w));\n    uvw.xy = zoom*uvw.xy;\n    // uv is scaled but not rotated\n    float sphere_mask = 1.0 - aastep(sphere_size, length(uvw.xy));\n    // Early exit outside object - big saving in distant views\n    if(sphere_mask == 0.0) {\n        fragColor = vec4(bgcolor, 1.0);\n        return;\n    }\n\n    // Fake sphere z in unit circle\n    uvw.z = sqrt(max(0.0, sphere_size*sphere_size-dot(uvw.xy,uvw.xy)));\n\n    // Spin vertically (rotate only the texcoords)\n    float el = 3.5*sin(iTime*0.05*sqrt(3.0));\n    float Se = sin(el);\n    float Ce = cos(el);\n    // Spin horizontally\n    float az = 7.0*sin(iTime*0.05*sqrt(2.0));\n    float Sa = sin(az);\n    float Ca = cos(az);\n    mat3 R = mat3(1.0,0.0,0.0, 0.0,Ce,-Se, 0.0,Se,Ce);\n    R *= mat3(Ca,0.0,Sa, 0.0,1.0,0.0, -Sa,0.0,Ca);\n    mat3 Ri = transpose(R); // orthonormal, hence inverse = tranpose\n\n    vec3 v = normalize(R*uvw); // Rescale coords to unit sphere\n\n\tfloat n;\n\tvec3 vw, g, gtemp;\n\n\tfloat warp = 1.0;\n\tn = fibnoise(v, FibN, iTime, g);\n    // Display one component of \"fibnoise\" on the left half,\n    // and a more interesting warped fractal sum on the right.\n    if(uvw.x > 0.0) {\n        vw = normalize(v + warp*g);\n        n += 0.5*fibnoise(vw, FibN*4.0, -iTime*1.9, gtemp);\n        g += 0.5*gtemp;\n        vw = normalize(v + warp*g);\n        n += 0.25*fibnoise(vw, FibN*16.0, iTime*3.9, gtemp);\n    }\n\n\tvec3 mixcolor;\n    // Fun thing to try: change the + to - here. Totally different look.\n\tmixcolor = mix(bgcolor, vec3(0.5 + 0.35*n), sphere_mask);\n\n    fragColor = vec4(mixcolor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nfloat fracmodphi(float k) {\n    // Compute fract(k/Phi) where Phi=(sqrt(5)-1)/2, but do it\n    // in a manner that yields high precision even for large k,\n    // where neither fract(k/Phi) nor mod(k,Phi)/Phi will do.\n    // Thanks to @mla for this integer expression:\n    // 1) Realize that fract(n*p/q) = ((n*p)%q)/q = (((n%q)*p)%q)/q\n    // 2) Use F23/F24 as a rational approximation of Phi\n    uint p = 28657u, q = 46368u;\n    uint n = uint(k);\n    return float(n%q*p%q)/float(q);\n}\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n\n// Compute point k on N-point fibsphere (helper for other functions)\nvec3 evalSFpoint(float k, float N) {\n\tfloat phi = 2.0*PI*fracmodphi(k);\n\tfloat cosTheta = 1.0 - (2.0*k + 1.0)*(1.0/N);\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\treturn vec3(cos(phi)*sinTheta, sin(phi)*sinTheta,cosTheta);\n}\n\n// Compute neighbors in the local Cartesian map, and their distances.\nfloat evalNearest(float N, vec2 B, vec2 i, vec2 c, vec3 v, out vec4 p) {\n    float cosTheta = dot(B, i + c) + (1.0-1.0/N);\n\tcosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n\tp.w = floor(N*0.5 - cosTheta*N*0.5);\n\tp.xyz = evalSFpoint(p.w, N);\n\treturn dot(v-p.xyz, v-p.xyz);\n}\n\n// Find the 3-4 nearest neighbors on an N-point Fibonacci sphere.\n// Evolved version of an algorithm from the article \"Spherical\n// Fibonacci Mapping\" by Keinert et al, ACM Trans. on Graphics\n// 34 (2015), 6, 193.\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com) 2021-2022.\n//\n// Return four neighbors, packing the result into a 4-vector\n// and a 4x4 matrix for convenience.\n// p[i].xyz is the location of neighbor i, p[i].w is its index.\n// d[i] is the squared distances from v to each of the neighbors.\n// p[0] is the closest point. The other three are not sorted, and\n// there are errors and duplicates, most notably around the poles.\n// See the function patchpoles() below for a remedy.\n//\n// This function is Copyright 2022 by Stefan Gustavson.\n// It is released under the terms of the MIT license:\n// https://opensource.org/licenses/MIT\n// (\"Use freely for any purpose, but keep the attribution\")\n//\nvoid inverseSF(vec3 v, float N, out vec4 p0, out vec4 p1,\n                   out vec4 p2, out vec4 p3, out vec4 d) {\n\tfloat phi = min(atan(v.y, v.x), PI); // min() to dodge NaN\n\tfloat cosTheta = v.z;\n\tfloat k = max(2.0, floor(\n\t\tlog(N * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))\n\t\t/ log(PHI*PHI)));\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 = floor(Fk * PHI + 0.5);\n\tmat2 B = mat2(\n\t\t2.0*PI*fracmodphi(F0+1.0) - 2.0*PI*(PHI-1.0), -2.0*F0/N,\n\t\t2.0*PI*fracmodphi(F1+1.0) - 2.0*PI*(PHI-1.0), -2.0*F1/N);\n\tmat2 invB = inverse(B);\n\tvec2 c = floor(invB * vec2(phi, cosTheta - (1.0-1.0/N)));\n\n\tvec2 Bvec = vec2(B[0][1],B[1][1]);\n\t// Compute all four neighbors first, *then* find closest point\n\t// (Sorting is more efficient with all values available)\n    d.x = evalNearest(N, Bvec, vec2(0.0, 0.0), c, v, p0);\n    d.y = evalNearest(N, Bvec, vec2(1.0, 0.0), c, v, p1);\n    d.z = evalNearest(N, Bvec, vec2(0.0, 1.0), c, v, p2);\n    d.w = evalNearest(N, Bvec, vec2(1.0, 1.0), c, v, p3);\n\n\t// Incomplete sort: Just make sure p0 is closest\n   \tvec4 ptemp;\n\tbvec3 smaller = lessThan(d.yzw, d.xxx);\n\tif(any(smaller)) {\n\t\tbvec3 smallest = lessThan(d.yyz, d.zww);\n\t\tif(all(smallest.xy)) { // d.y smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = ptemp;\n\t\t\td.xy = d.yx;\n\t\t}\n\t\telse if(!any(smallest.yz)) { // d.w smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p3;\n\t\t\tp3 = ptemp;\n\t\t\td.xw = d.wx;\n\t\t}\n\t\telse { // d.z smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p2;\n\t\t\tp2 = ptemp;\n\t\t\td.xz = d.zx;\n\t\t}\n\t}\n}\n\n// Patch up errors around the sphere's +z and -z poles.\n// Several errors remain, but this fixes the relevant ones\n// for our purposes: after patching, all neighbors are\n// correct within a radius of the global maximum distance\n// to the nearest point in the set.\n\n// A (dest,src) array to specify which patches to apply, and where:\n// \"For cell x, try adding neighbor y if it wasn't found already\".\n// The entries must be sorted on destination (x) in ascending order.\n//\n// This set of patches makes the algorithm work from N=8 and up.\n// If you don't need low N values, several of them can be omitted:\n// (2,0) is needed only for N=8,9\n// (5,3) is needed only for N=9\n// (4,1) is needed only for N=10,11\n// (3,6) is needed only for N<=11\n// (6,0) is needed only for N=11\n// (9,4) is needed only for N=20\n// (10,13) is needed only for N=21\n// If trashed duplicates (negative k) are tolerated for distant p3 (they\n// cause errors in the current code), some others could be omitted as well.\nconst vec2 polepatch[29] = vec2[](vec2(0.0, 3.0), vec2(0.0, 5.0), vec2(1.0, 3.0),\n\tvec2(1.0, 4.0),\tvec2(1.0, 6.0), vec2(2.0, 0.0), vec2(2.0, 5.0), vec2(2.0, 7.0),\n\tvec2(2.0, 10.0), vec2(3.0, 0.0), vec2(3.0, 6.0), vec2(3.0, 11.0), vec2(4.0,1.0),\n\tvec2(4.0, 9.0),\tvec2(5.0, 3.0), vec2(5.0, 8.0),\tvec2(5.0, 10.0), vec2(6.0, 0.0),\n\tvec2(6.0, 3.0),\tvec2(6.0, 11.0), vec2(7.0, 2.0), vec2(8.0, 5.0), vec2(8.0, 21.0),\n\tvec2(9.0, 4.0),\tvec2(9.0, 22.0), vec2(10.0, 13.0), vec2(10.0, 15.0), vec2(13.0, 21.0),\n\tvec2(14.0, 22.0));\n\n// The patching function. Only a few iterations of the \"for\" loop will amount\n// to any real amount of work, and there are early exits to speed it up further.\n// A modern GPU with \"peer-aware SIMD conditionals\" will execute this efficiently.\nvoid patchpoles(vec3 v, float N, inout vec4 p0, inout vec4 p1,\n                    inout vec4 p2, inout vec4 p3, inout vec4 d) {\n\n\tfloat k0 = p0.w;\n\n    // If we are not near either pole, no patches are needed\n\tif((k0 > 15.0) && (k0 < N-16.0)) return;\n\t// Trash duplicate neighbors for the patching to work\n\tvec4 ki = vec4(p0.w, p1.w, p2.w, p3.w);\n\t// p0 is correct, but not always unique\n\tbvec3 duplicates = equal(ki.xxx, ki.yzw);\n\tif(duplicates.x) { // trash p1\n\t\tp1 = vec4(0.0,0.0,0.0, -1.0); // Set invalid k\n\t\tki.y = -1.0;\n\t\td.y = 12.0; // More than sphere diameter squared\n\t}\n\tif(duplicates.y) { // trash p2\n\t\tp2 = vec4(0.0,0.0,0.0, -2.0);\n\t\tki.z = -2.0;\n\t\td.z = 11.0;\n\t}\n\tif(duplicates.z) { // trash p3\n\t\tp3 = vec4(0.0,0.0,0.0, -3.0);\n\t\tki.w = -3.0;\n\t\td.w = 10.0;\n\t}\n\t// p1, p2 or p3 might be duplicates of each other\n\tduplicates = equal(ki.yyz, ki.zww);\n\tif(any(duplicates.yz)) { // p3 dup of p1 or p2, trash p3\n\t\tp3 = vec4(0.0,0.0,0.0, -3.0);\n\t\td.w = 10.0;\n\t}\n\tif(duplicates.x) { // p2 dup of p1, trash p2\n\t\tp2 = vec4(0.0,0.0,0.0, -2.0);\n\t\td.z = 11.0;\n\t}\n\n\t// Mirror indices from opposite pole for the patch loop\n\tbool kflip = (k0 > N*0.5-0.5);\n\tif(kflip) k0 = N-1.0-k0;\n\n\tfor(int i = 0; i < 29; i++) {\n\t\t// \"Patch cell x by including neighbor y\"\n\t\tvec2 dstsrc = polepatch[i];\n\t\t// A \"break\" has the rather unexpected side effect of\n        // preventing the GLSL compiler from unrolling the loop,\n        // which is an advantage in this case. The unrolled\n        // version of this loop has a huge instruction count\n        // and takes a long time to compile.\n\t\tif(k0 < dstsrc.x) break; // No more relevant patches\n\t\tif(dstsrc.x >= N*0.5) break; // No more relevant patches\n\t\tif(dstsrc.y >= N) continue; // This patch is not relevant\n\t\tif(k0 == dstsrc.x) { // This patch is relevant here\n\t\t\tvec3 k123 = vec3(p1.w, p2.w, p3.w);\n\t\t\tif(kflip) k123 = N-1.0-k123;\n\t\t\t// If this neighbor was already found, move on\n\t\t\tif(any(equal(k123, vec3(dstsrc.y)))) continue;\n\t\t\t// Evaluate the suggested neighbor, at correct pole\n\t\t\tfloat knew = kflip ? N-1.0-dstsrc.y : dstsrc.y;\n\t\t\tvec3 pnew = evalSFpoint(knew, N);\n\t\t\tfloat dnew = dot(v-pnew, v-pnew);\n\t\t\tif(any(lessThan(vec3(dnew), d.yzw))) {\n\t\t\t\tbvec3 largest = greaterThan(d.yyz, d.zww);\n\t\t\t\tif(all(largest.xy)) { // d[1] largest\n\t\t\t\t\tp1 = vec4(pnew, knew); // replace p1\n\t\t\t\t\td.y = dnew;\n\t\t\t\t}\n\t\t\t\telse if(!any(largest.yz)) { // d[3] largest\n\t\t\t\t\tp3 = vec4(pnew, knew);\n\t\t\t\t\td.w = dnew;\n\t\t\t\t}\n\t\t\t\telse { // d[2] largest\n\t\t\t\t\tp2 = vec4(pnew, knew);\n\t\t\t\t\td.z = dnew;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Sort all points p1 to p3 on distance\n// (not always needed, see \"sortp0p1\" below)\nvoid sortpoints(inout vec4 p0, inout vec4 p1,\n                inout vec4 p2, inout vec4 p3, inout vec4 d) {\n    vec4 ptemp;\n    if((d.y <= d.z) && (d.z <= d.w))\n        return; // Already sorted\n    if(d.z < d.y) { // Swap 1,2\n        d.yz = d.zy;\n        ptemp = p1;\n        p1 = p2;\n        p2 = ptemp;\n    }\n    if(d.w < d.y) { // Swap 1,3\n        d.yw = d.wy;\n        ptemp = p1;\n        p1 = p3;\n        p3 = ptemp;\n    }\n    if(d.w < d.z) { // Swap 2,3\n        d.zw = d.wz;\n        ptemp = p2;\n        p2 = p3;\n        p3 = ptemp;\n    }\n}\n\n// Sort to make p0, p1 the two closest points\n// (Leave p2, p3 unsorted)\nvoid sortp0p1(inout vec4 p0, inout vec4 p1, inout vec4 p2,\n                    inout vec4 p3, inout vec4 d) {\n    vec4 ptemp;\n    if((d.y <= d.z) && (d.z <= d.w))\n        return; // Already sorted\n    if((d.z < d.y) && (d.z < d.w)){ // Swap 1,2\n        d.yz = d.zy;\n        ptemp = p1;\n        p1 = p2;\n        p2 = ptemp;\n    } else if(d.w < d.y) { // Swap 1,3\n        d.yw = d.wy;\n        ptemp = p1;\n        p1 = p3;\n        p3 = ptemp;\n    }\n}\n\n// This is an absolutely horrid hash in terms of repeatability\n// between platforms and control over what actually happens,\n// but it seems to work OK on current (2022) GPUs all the way\n// up to 2M points. Not great, but OK.\nvec4 hash4(vec4 i) {\n\treturn fract(sin(i*0.0023749863) * 43758.5453123);\n}\n\n//\n// Simplex noise on a sphere, with flow noise capabilities\n// (rotating gradients, low cost analytic derivative).\n// The spatial scale is porportional to sqrt(N), so if you\n// want a fractal \"fBm\" sum of this, take steps of 1, 4, 16,...\n//\n// The function \"fibnoise\" and its sub-functions \"inverseSF\",\n// \"evalNearest\" and \"patchpoles\" are Copyright 2022 by Stefan\n// Gustavson. They are released under the terms of the MIT\n// license: https://opensource.org/licenses/MIT\n// (\"Use freely for any purpose, but keep the attribution\")\n// The function \"fracmodphi\" is courtesy of @mla on Shadertoy.\n// and distributed under the same conditions.\n//\nfloat fibnoise(vec3 v, float N, float alpha, out vec3 g) {\n\n\tvec4 f0, f1, f2, f3;\n\tvec4 d;\n\tvec4 k;\n\tvec3 p0, p1, p2, p3;\n\tvec3 x0, x1, x2, x3;\n\t\n\t// Get all four neighbors of current point\n\tinverseSF(v, N, f0, f1, f2, f3, d);\n\tpatchpoles(v, N, f0, f1, f2, f3, d);\n\tp0 = f0.xyz;\n\tp1 = f1.xyz;\n\tp2 = f2.xyz;\n\tp3 = f3.xyz;\n\tk = vec4(f0.w, f1.w, f2.w, f3.w);\n\tx0 = v - p0; // These could be returned without\n\tx1 = v - p1; // cost from a modified inverseSF()\n\tx2 = v - p2;\n\tx3 = v - p3;\n\t\n\tfloat r = 2.65/sqrt(N);\n\tfloat rsq = r*r;\n\tvec4 w = vec4(rsq) - d;\n\tw = w / rsq;\n\tw = max(w, 0.0);\n\tvec4 w2 = w*w;\n\tvec4 w3 = w2*w;\n\tvec3 g0x = normalize(cross(p0,vec3(0.0,0.0,1.0)));\n\tvec3 g1x = normalize(cross(p1,vec3(0.0,0.0,1.0)));\n\tvec3 g2x = normalize(cross(p2,vec3(0.0,0.0,1.0)));\n\tvec3 g3x = normalize(cross(p3,vec3(0.0,0.0,1.0)));\n\tvec3 g0y = normalize(cross(p0,g0x));\n\tvec3 g1y = normalize(cross(p1,g1x));\n\tvec3 g2y = normalize(cross(p2,g2x));\n\tvec3 g3y = normalize(cross(p3,g3x));\n\n\tvec4 psi = hash4(k)*2.0*PI + alpha;\n\tvec4 sPsi = sin(psi);\n\tvec4 cPsi = cos(psi);\n\tvec3 g0 = cPsi.x*g0x + sPsi.x*g0y;\n\tvec3 g1 = cPsi.y*g1x + sPsi.y*g1y;\n\tvec3 g2 = cPsi.z*g2x + sPsi.z*g2y;\n\tvec3 g3 = cPsi.w*g3x + sPsi.w*g3y;\n\n\tvec4 ramp = vec4(dot(x0,g0), dot(x1,g1), dot(x2,g2), dot(x3,g3));\n\n\t// Compute the first order partial derivatives\n\t// TODO: This does not take into consideration the curvature\n    // of the sphere. It's actually the gradient in the tangent\n    // plane, and it becomes somewhat inaccurate for small N.\n\tvec4 dw = -6.0 * w2 * ramp;\n\tvec3 dn0 = w3.x * g0 + dw.x * x0;\n\tvec3 dn1 = w3.y * g1 + dw.y * x1;\n\tvec3 dn2 = w3.z * g2 + dw.z * x2;\n\tvec3 dn3 = w3.w * g3 + dw.w * x3;\n\tg = 1.12/sqrt(N) * (dn0 + dn1 + dn2 + dn3); // Adjust for scale\n\n\treturn 1.12*sqrt(N) * dot(ramp, w3);\n}\n","name":"Common","description":"","type":"common"}]}