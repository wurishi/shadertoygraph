{"ver":"0.1","info":{"id":"Dlffzs","date":"1695379567","viewed":54,"name":"Implicit Distance Fields","username":"Seebone","description":"Distance to the roots of a 2-variable function. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Viewport parameters */\n// The distance from the left to the right of the viewport\n#define WIDTH 25.\n// Don't change, dependent on height\n#define HEIGHT (WIDTH * iResolution.y/iResolution.x)\n// Coordinates at center of viewport\n#define CENTER (vec2(0.))\n\n/* The distance algorithm to be used */\n/* Can be one of:\n * \"exact(uv)\" (doesn't work on some devices for some reason)\n * \"divideByGrad(uv)\"\n * \"extendedNewton(uv)\"\n */\n#define FUNCTION extendedNewton(uv)\n\n/* \"exact(uv)\" algorithm parameters */\n#define R_MAX .14*WIDTH\n// radius samples for \"exact\" algorithm (resolution of field):\n#define R_SAMPLES 60.\n// Animate samples:\n//#define R_SAMPLES mod(iTime, 60.)\n\n/* zero plane */\n// Manual\n//#define Z_LEVEL 0.\n// Animated 0-level\n#define Z_LEVEL (adjustedSine(iTime, -2.9, .9, 8.))\n\n/* constants */\n#define M_PI 3.1415926535897932384626433832795\n#define M_TAU 6.2831853071795864769252867665590\n#define M_SQRT2 1.4142135623730950488016887242096\n#define FLT_MAX 3.402823466e+38\n\n// Change to any function\nfloat implicit(float x, float y) {\n      //return x * y * (abs(x) + abs(y) - 1.);\n      //return abs(x+y) + abs(x-y)-1.;\n      //return pow(3.*x*x - y*y, 2.)*y*y - pow(x*x + y*y, 4.);\n      //return pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\n      //return tan(x*y*sin(y*x)*cos(x*x)) ;\n      //return cos(x*x) + sin(y*x);\n      return cos(x * y) + y * sin(x) -1.;\n      //return x*x*y + y*y*x;\n      //return sin(y)+cos(x);\n      //return sin(x+y)-cos(x*y) - 1.;\n      //return x*x*x + y*y-1.;\n      //return x*x;\n      //return sin(x*x) - y;\n      //return abs(x*y)-x;\n}\n\n// Not adjusted to begin at 0\nfloat adjustedSine(float x, float yMin, float yMax, float period) {\n    return .5*((yMax - yMin) * sin(M_TAU*x/period) + yMax + yMin);\n}\n\n// z-shifted since all algorithms are made to detects roots\nfloat f(vec2 p) {\n    return implicit(p.x, p.y) - Z_LEVEL;\n} \n\n/* IQ coloring scheme \n * Explanation from Envy24: https://www.shadertoy.com/view/fsGcRc\n */\nvec3 colorizeField(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4. * abs(dist));\n    \n    // Add interleaved curves.\n\tcolor *= .7 + .3 * cos(800./WIDTH * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0., 3.*WIDTH/iResolution.x, abs(dist)));\n}\n\n/* All 4 algorithms */\n\n/* Can be used to demonstrate the problem */\nfloat naive(vec2 uv, float cw) {\n    return smoothstep(0., cw, abs(f(uv)));\n}\n\n\n/* Mostly good for distance fields */\nfloat exact(vec2 uv) {\n    const vec2 h = vec2(1e-4, 0.);\n    // Increase iterations to avoid artifacts. f is sampled 3 times every iteration.\n    const int NEWTON_ITERATIONS = 8; // The convergence is often very fast\n    // The precision will be bettter than this, this value is only used to determine if a root was found.\n    const float rootErr = 1e-4;\n    const float nAngle = 3.; // number of starting points when finding angle root\n   \n    float radius0;\n    float angle0;\n    \n    float rStep = R_MAX/R_SAMPLES;\n    float aStep = M_TAU/nAngle;\n    \n    for(radius0 = 0.; radius0 <= R_MAX; radius0 += rStep) {\n        for(angle0 = 0.; angle0 <= M_TAU; angle0 += aStep) {\n            float radius = radius0;\n            float angle = angle0;\n\n            float fVal;\n            vec2 fGrad;\n\n            for(int i = 0; i < NEWTON_ITERATIONS; i++) {\n                vec2 dir = vec2(cos(angle), sin(angle));\n                vec2 p = uv+radius*dir;\n                fVal = f(p);\n                                \n                // Gradient with respect to x and y at p\n                fGrad = vec2(f(p+h)-fVal, f(p+h.yx)-fVal) / h.x;\n                // partial derivative with respect to angle using multivariable chain rule\n                float dfdAngle = dot(fGrad, radius*vec2(-dir.y, dir.x));\n                // Other way of doing it:\n                // float dfdAngle = (f(uv + radius*vec2(cos(angle+h.x), sin(angle+h.x))) - fVal)/h.x;\n                \n                // Updating using newton's method\n                angle -= fVal/dfdAngle;\n            }\n            // Check is placed after loop since we always want to find the best approximataion before\n            // returning. \n            // This check is here to determine if a root was found. To avoid precision errors,\n            // especially in the case where the function approaches the root very slowly leading to\n            // incorrect detection of roots, we divide by the gradient length to enhance flat areas and\n            // squash infinities. Only problem is if gradient is 0.\n            if(abs(fVal)*inversesqrt(dot(fGrad, fGrad)) <= rootErr) {\n            // Theretically correct:\n            //if(abs(fVal) <= rootErr) {\n                return radius;\n            }\n        }\n    }\n    // If no root was found withing specified radius\n    return FLT_MAX;\n}\n\n/* Works by 'normalizing' the gradient of f to create a function that increases linearly (like a true distance function) in close proximity to a root of f. */ \nfloat divideByGrad(vec2 uv) {\n    const vec2 h = vec2(.0001, 0.);\n    // f is evaluated 3 times for cheap version and 5 times for expensive version\n    \n    // Expensive version:\n    //vec2 grad = vec2(f(uv+h) - f(uv-h), f(uv + h.yx) - f(uv - h.yx))/(2.*h.x);\n    //return smoothstep(0., .5*cw, abs(f(uv))*inversesqrt(dot(grad,grad)));\n    \n    \n    \n    // Cheap version:\n    float fVal = f(uv);\n    vec2 grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n    return abs(fVal)*inversesqrt(dot(grad,grad));\n    \n}\n\n/* Works by extending newton's method to 2 variables and treating the found root as the closest point on the curve */ \nfloat extendedNewton(vec2 uv) {\n    const vec2 h = vec2(1e-5, 0.);\n    // Increase iterations to avoid artifacts. f is sampled 3 times every iteration.\n    const int NEWTON_ITERATIONS = 10; // The convergence is often very fast\n    /* In almost all cases, the precision will be much bettter than this,\n     * this value is only used to determine if a root was found.\n     */ \n    const float rootErr = 1e-2; \n    \n    vec2 uv0 = uv;\n    float fVal;\n    vec2 grad;\n    \n    for(int i = 0; i < NEWTON_ITERATIONS; i++) {\n        fVal = f(uv);\n        // placing the check here would create more problems than it solved\n\n        // Expensive:\n        // vec2 grad = .5*vec2(f(uv+h) - f(uv-h), f(uv + h.yx) - f(uv - h.yx))/h.x;\n        // Cheap:\n        grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n\n        uv -= fVal/dot(grad, grad) * grad;\n    }\n    // Update to use latest uv\n    fVal = f(uv);\n    grad = vec2(f(uv+h)-fVal, f(uv+h.yx)-fVal) / h.x;\n    \n    // Check is placed after loop since we always want to find the best approximataion before returning\n    // Divide by gradient length to smooth out asymptotes and enhance \n    if(abs(fVal)*inversesqrt(dot(grad, grad)) <= rootErr) {\n        return distance(uv0, uv);\n    } else {\n        return 1.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalizes x-distance to 1 while keeping aspect ratio and shifting so that (0,0) is at center of viewport.\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n\n    // transforming to correct size and position\n    uv *= WIDTH;\n    uv += CENTER;\n    \n    vec3 col = colorizeField((f(uv) >= 0. ? 1. : -1.)*FUNCTION, vec3(0.1, 0.4, 0.7));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}