{"ver":"0.1","info":{"id":"4XXXW8","date":"1710706125","viewed":119,"name":"Details on implicit surfaces","username":"Moon519","description":"The accompanying shadertoy for the blog post https://aparis69.github.io/public_html/posts/2024_implicit_details.html\n\nFeaturing hypertexturing, star-shaped noise primitive, and triplanar warping. No particular attention was put in optimization.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","warping","triplanar","details"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 128;\nconst float EPSILON = 0.01f;\nconst float LIPSCHITZ = 1.5f;\n\nfloat hash(ivec3 p) {\n    // From https://www.shadertoy.com/view/4sfGzS\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat noise(in vec3 x) {\n    // From https://www.shadertoy.com/view/4sfGzS\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 pos, int o) {\n    vec3 q = pos * 12.0f;\n    float f = 0.0f;\n    float a = 0.5f;\n    for (int i = 0; i < o; i++) {\n        f += a*noise(q);   \n        q = q*2.02;     \n        a *= 0.5f;\n    }\n    return f;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    // From https://www.shadertoy.com/view/Xds3zN\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec4 boxmap(in sampler2D s, in vec3 p, in vec3 n, in float k) {\n    // From https://www.shadertoy.com/view/MtsGWH\n    // \"p\" point apply texture to\n    // \"n\" normal at \"p\"\n    // \"k\" controls the sharpness of the blending in the\n    //     transitions areas.\n    // \"s\" texture sampler\n    \n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nvec3 gradientSphere(vec3 p, vec3 c, float r) {\n    float v = sphereSDF(p, c, r);\n    vec3 n;\n    n.x = sphereSDF(vec3(p.x + EPSILON, p.y, p.z), c, r) - v;\n    n.y = sphereSDF(vec3(p.x, p.y + EPSILON, p.z), c, r) - v;\n    n.z = sphereSDF(vec3(p.x, p.y, p.z + EPSILON), c, r) - v;\n    return normalize(n);\n}\n\nfloat sceneNoiseField(vec3 p, int o) {\n    const float r = 1.0f;\n    float n = 0.5f * fbm(p * 0.35f, o);\n    return sphereSDF(p, vec3(0), r + n);\n}\n\nfloat sceneStarShapedNoise(vec3 p, int o) {\n    float r = 1.0f;\n    float l = length(p);\n    vec3 q = vec3(0.f) + (r / l) * p;\n    float n = 0.5f * fbm(q * 0.35f, o);\n    r = r + n;\n    return sphereSDF(p, vec3(0), r);\n}\n\nfloat sceneTriplanarWarping(vec3 p) {\n   const float r = 1.2f;\n   const float strength = 0.25f;\n   const float sharpness = 4.f;\n   const float texScale = 0.6f;\n   vec3 n = normalize(gradientSphere(p, vec3(0), r));\n   vec4 textureCol = boxmap(iChannel0, p * texScale, n, sharpness);\n   return sphereSDF(p - n * textureCol.r * strength, vec3(0), r);\n}\n\nfloat sceneTriplanarWarping2(vec3 p) {\n   const float r = 1.2f;\n   const float strength = 0.15f;\n   const float sharpness = 6.f;\n   const float texScale = 0.1f;\n   vec3 n = normalize(gradientSphere(p, vec3(0), r));\n   vec4 textureCol = boxmap(iChannel1, p * texScale, n, sharpness);\n   return sphereSDF(p - n * textureCol.r * strength, vec3(0), r);\n}\n\nfloat figureHypertexturing(vec3 p) {\n    float ret = 10000.0f;\n    ret = min(ret, sceneNoiseField(p - vec3(3, 0, 0), 1));\n    ret = min(ret, sceneNoiseField(p, 3));\n    ret = min(ret, sceneNoiseField(p + vec3(3, 0, 0), 5));\n    return ret;\n}\n\nfloat figureStarShapedNoise(vec3 p) {\n    float ret = 10000.0f;\n    ret = min(ret, sceneStarShapedNoise(p - vec3(3, 0, 0), 1));\n    ret = min(ret, sceneStarShapedNoise(p, 3));\n    ret = min(ret, sceneStarShapedNoise(p + vec3(3, 0, 0), 5));\n    return ret;\n}\n\nfloat figureTriplanar(vec3 p) {\n    float ret = 10000.0f;\n    ret = min(ret, sceneTriplanarWarping(p - vec3(1.5, 0, 0)));\n    ret = min(ret, sceneTriplanarWarping2(p + vec3(1.5, 0, 0)));\n    return ret;\n}\n\nfloat figureComparison(vec3 p) {\n    float ret = 10000.0f;\n    ret = min(ret, sceneNoiseField(p - vec3(3, 0, 0), 4));\n    ret = min(ret, sceneStarShapedNoise(p, 4));\n    ret = min(ret, sceneTriplanarWarping(p + vec3(3, 0, 0)));\n    return ret;\n}\n\nfloat scene(vec3 p) {\n    float ret = 10000.0f;\n    if(sdBox(p, vec3(4.5, 2, 2)) < 6.8f) {\n        //ret = figureHypertexturing(p);\n        //ret = figureStarShapedNoise(p);\n        //ret = figureTriplanar(p);\n        ret = figureComparison(p);\n    }  \n    return ret;\n}\n\nvec3 gradient(vec3 p) {\n    const float eps = 0.01f;\n    float v = scene(p);\n    vec3 n;\n    n.x = scene(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = scene(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = scene(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\nbool sphereTrace(vec3 ro, vec3 rd, out float t) {\n    t = 0.f;\n  \tfor(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float v = scene(p);\n        if (v < 0.f)\n            return true;    \n        t += max(EPSILON, abs(v) / LIPSCHITZ);\n\t}\n    return false;\n}\n\nvec3 shadeBackground(vec3 rd) {\n    return vec3(245.f/255.f, 245.f/255.f, 240.f/255.f);\n}\n\nvec3 shade(vec3 p, vec3 n) {\n    const vec3 l1 = normalize(vec3(-2.0, -0.5, 2.5));\n    const vec3 l2 = normalize(vec3(2.0, -1.1, -1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.5);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 4.0);\n    return vec3(0.6) + 0.25 * (d1 + d2)* shadeBackground(n);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 32.0 + iTime*1.5;\n  \tvec3 ta = vec3(0.f, 0.f, 0.f);\n    float dd = 8.5f;\n    vec3 ro = ta + vec3(dd*cos(0.1*time + 7.0*mo.x), 2.2, dd*sin(0.1*time + 7.0*mo.x) );\n    mat3 ca = setCamera(ro, ta, 0.0);\n    const float fl = 2.5;\n    vec2 pp = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = ca * normalize(vec3(pp, fl));\n    \n    float a = (iTime * 0.25f);\n    ro = rotateY(ro, a);\n    rd = rotateY(rd, a);\n       \n    float t;\n    bool h = sphereTrace(ro, rd, t);\n    if (h) {\n        vec3 p = ro + rd * t;\n        vec3 n = gradient(p);\n        fragColor = vec4(shade(p, n), 1.f);\n    }\n    else {\n        fragColor = vec4(shadeBackground(rd), 1.f);\n    }\n}","name":"Image","description":"","type":"image"}]}