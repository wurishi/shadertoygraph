{"ver":"0.1","info":{"id":"X3dSRn","date":"1718514045","viewed":97,"name":"JPEG shader (DCT)","username":"int_45h","description":"rough JPEG compression effect, it's just DCT + quantization, then inverse DCT. It's not a true representation of how JPEG works, since there's no RGB to YCbCr conversion, but it at least looks the part. DCT is in horizontal/vertical passes for performance","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define SQRT2 0.70710678118\n\nfloat mdct[64] = float[64](\n0.707106769, 0.707106769, 0.707106769, 0.707106769, 0.707106769, 0.707106769, 0.707106769, 0.707106769, \n0.980785251, 0.831469595, 0.555570245, 0.195090324, -0.195090324, -0.555570245, -0.831469595, -0.980785251, \n0.923879504, 0.382683426, -0.382683426, -0.923879504, -0.923879504, -0.382683426, 0.382683426, 0.923879504, \n0.831469595, -0.195090324, -0.980785251, -0.555570245, 0.555570245, 0.980785251, 0.195090324, -0.831469595, \n0.707106769, -0.707106769, -0.707106769, 0.707106769, 0.707106769, -0.707106769, -0.707106769, 0.707106769, \n0.555570245, -0.980785251, 0.195090324, 0.831469595, -0.831469595, -0.195090324, 0.980785251, -0.555570245, \n0.382683426, -0.923879504, 0.923879504, -0.382683426, -0.382683426, 0.923879504, -0.923879504, 0.382683426, \n0.195090324, -0.555570245, 0.831469595, -0.980785251, 0.980785251, -0.831469595, 0.555570245, -0.195090324\n);\n\n//float a(float x){return (x<.5)?SQRT2:1.;}\n//float dc(vec2 a, vec2 b) {return cos(PI*a.x*b.x)*cos(PI*a.y*b.y);}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 dct_h(vec2 fc)\n{\n    vec2 grid = floor(fc/8.)*8.;\n    vec2 uv = fract(fc/8.)*8.;\n    \n    vec3 s = vec3(0);\n    for (int x=0; x<8; x++)\n    {\n        vec3 c = texture(iChannel0, (grid+vec2(x,floor(uv.y))+.5)/iResolution.xy).rgb;\n        s += c*mdct[int(uv.x)*8+x]; //cos(PI*uv.x*(x+.5)/8.);\n    }\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(dct_h(fragCoord),1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define STEPS (.5+3.*(.5+.5*sin(iTime)))\nvec3 dct_v(vec2 fc)\n{\n    vec2 grid = floor(fc/8.)*8.;\n    vec2 uv = fract(fc/8.)*8.;\n    \n    vec3 s = vec3(0);\n    for (int y=0; y<8; y++)\n    {\n        vec3 c = texture(iChannel0, (grid+vec2(floor(uv.x),y)+.5)/iResolution.xy).rgb;\n        s += c*mdct[int(uv.y)*8+y]; //cos(PI*uv.y*(y+.5)/8.);\n    }\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = dct_v(fragCoord)*.25;\n    col = round(col*STEPS)/STEPS;\n    fragColor = vec4(col,1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 idct_h(vec2 fc)\n{\n    vec2 grid = floor(fc/8.)*8.;\n    vec2 xy = fract(fc/8.)*8.;\n    vec3 s = vec3(0.);\n    \n    for (int u=0; u<8; u++)\n    {\n        vec3 c = texture(iChannel0, (grid+vec2(u, xy.y-.5)+.5)/iResolution.xy).rgb;\n        s += c*mdct[u*8+int(xy.x)]; //*cos(PI*(xy.x+.5)/8.*u);\n    }\n    \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(idct_h(fragCoord),1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec3 idct_v(vec2 fc)\n{\n    vec2 grid = floor(fc/8.)*8.;\n    vec2 xy = fract(fc/8.)*8.;\n    vec3 s = vec3(0.);\n    \n    for (int v=0; v<8; v++)\n    {\n        vec3 c = texture(iChannel0, (grid+vec2(xy.x-.5, v)+.5)/iResolution.xy).rgb;\n        s += c*mdct[v*8+int(xy.y)]; //*cos(PI*(xy.y+.5)/8.*v);\n    }\n    \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(idct_v(fragCoord)*.25,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}