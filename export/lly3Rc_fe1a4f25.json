{"ver":"0.1","info":{"id":"lly3Rc","date":"1475837857","viewed":1599,"name":"Infinite quad grid","username":"sebbbi","description":"Infinite grid of quads. Analytical modulo ray trace. Fixed cost O(1). No loops.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["grid","raytrace","analytical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rayIntersectNearestGridPlanes(vec3 orig, vec3 ray)\n{\n    orig = fract(orig);\n    float zInv = 1.0 / ray.z;\n    float dFront = (1.0 - orig.z) * zInv;\n    float dBack = (2.0 - orig.z) * zInv;\n\n    if (ray.z < 0.0)\n    {\n    \tdFront = (orig.z) * -zInv;\n        dBack = (orig.z + 1.0) * -zInv;        \n    }\n    \n    return vec2(dFront, dBack);\n}\n\nvec4 moduloUvPlanes(vec3 orig, vec3 ray, vec2 dist)\n{\n    return vec4(fract(orig.xy + ray.xy * dist.x), fract(orig.xy + ray.xy * dist.y));\n}\n\nvec2 shortestPathStepDist(vec4 uvs)\n{\n    vec2 stepDist = uvs.zw - uvs.xy;\n    \n    // Modulo range [-0.5, +0.5]\n    stepDist = fract(stepDist + 0.5) - 0.5;\n    return stepDist;\n}\n\nfloat calculateSteps(float orig, float dist)\n{\n    // Plane hit: xy = [0, 0.5] modulo range on each integer z\n    if (orig < 0.5) return 0.0;\n    \n    // How many steps to hit (modulo) 0.0 or 1.0?\n    float steps = (dist < 0.0) ? \n        (orig - 0.5) / -dist :\n    \t(1.0 - orig) / dist;\n    \n    return ceil(steps);\n}\n\nvec3 intersectInfiniteGrid(vec3 orig, vec3 ray)\n{\n    vec2 intersections = rayIntersectNearestGridPlanes(orig, ray);\n    vec4 uv = moduloUvPlanes(orig, ray, intersections);\n\tvec2 dist = shortestPathStepDist(uv);\n    float stepsX = calculateSteps(uv.x, dist.x);\n    float stepsY = calculateSteps(uv.y, dist.y);\n\n    float steps = min(stepsX, stepsY);\n    uv.xy += steps * dist.xy;\n    \n    return vec3(uv.xy, intersections.y + steps / abs(ray.z));\n}\n\nmat2 rot2D(float angle) \n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,s,-s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord / iResolution.xy ) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n    \n    float time = iTime;\n    vec3 orig = vec3(0.65, 0.75, 0.1 + time);\n    vec3 ray = normalize(vec3(uv, 1.2));\n    \n    ray.xz *= rot2D(iMouse.z > 0. ? iMouse.x/100. : time * 0.15 );\n    ray.yz *= rot2D(iMouse.z > 0. ? iMouse.y/100. : time * 0.1 );\n    \n   \tvec3 uvDist = intersectInfiniteGrid(orig, ray);\n\n\tfragColor = texture(iChannel0, 2.*uvDist.xy, log2(uvDist.z) * 0.25);\n}\n\n","name":"Image","description":"","type":"image"}]}