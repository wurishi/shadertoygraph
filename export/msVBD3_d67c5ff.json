{"ver":"0.1","info":{"id":"msVBD3","date":"1700127026","viewed":218,"name":"Gravity Sucks","username":"shau","description":"Audio reactive 148s loop synced to the music for a while so you may have to rewind on start","likes":22,"published":1,"flags":96,"usePreview":0,"tags":["3d","grid","audio","sparse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n    Abusing sparse grid marching by Nimitz\n    Loosley based on Tigris by MFX\n*/\n\n//DEPTH OF FIELD\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(0.002*R.y/R.x,0.002), angle = vec2(0,rad);\n    rad = 1.0;\n\tfor (int j=ZERO; j<80; j++) {  \n        rad += 1.0/rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.0)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.0;\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n\tC = vec4(dof(iChannel0,U/R,texture(iChannel0,U/R).w),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//GLOBAL VARS & NOISE\n\n//balls\n#define B1 vec2(410.5,0.5)\n#define B2 vec2(410.5,1.5)\n//camera position and focus\n#define CAM vec2(410.5,2.5)\n//look at\n#define LOOK_AT vec2(410.5,3.5)\n//sound\n#define SND vec2(410.5,4.5)\n//scene\n#define SCENE vec2(410.5,5.5)\n//animation time points\n#define AP01 22.0\n#define AP02 28.0\n#define AP03 29.0\n#define AP10 59.0\n#define AP20 88.6\n#define AP21 118.0\n#define AP30 133.0\n#define AP40 139.0\n\n#define ZERO (min(iFrame,0))\n#define T mod(iTime,1476.0)\n#define AT mod(T,147.6)\n#define R iResolution.xy\n#define S(a, b, v) smoothstep(a, b, v)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - Hash without sin\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3*vec3(0.1031,0.1030,0.0973));\n    p3 += dot(p3,p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx)*0.1031);\n    p3 += dot(p3,p3.yzx + 33.33);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n//Shane or IQ?\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7,157,113);\n    vec4 h = vec4(0.0,s.yz,s.y + s.z) + dot(ip,s);\n    rp = rp*rp*(3.0 - 2.0*rp); \n    h = mix(fract(sin(h)*43758.5),fract(sin(h + s.x)*43758.5),rp.x);\n    h.xy = mix(h.xz,h.yw,rp.y);\n    return mix(h.x,h.y,rp.z); \n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0,\n          w = 1.0,\n          s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w*noise(s*x);\n    }\n    return r;\n}\n\nvec3 clouds(vec3 rd, float time) \n{\n    float CT = time/14.0,\n          nz = fbm(vec3((rd.xz/(rd.y + 0.4))*1.4 + vec2(CT*2.0,0.0),CT))*1.5;\n    return clamp(pow(vec3(nz),vec3(4.0))*rd.y,0.0,1.0);\n}\n\nfloat patt1(vec2 xz, float time)\n{\n    xz.y += time*3.0;\n    vec3 p = vec3(xz.x*0.3,time*0.23,xz.y*0.3);\n    return S(0.3,0.7,noise(p*1.0));\n}\n\nfloat patt2(vec2 xz, float time)\n{\n  return clouds(vec3(xz.x*0.1+time*0.3,0.2,xz.y*0.1+time*0.03),\n                time).x;  \n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdcGz2","filepath":"https://soundcloud.com/countzerointerupt/acid-house-mix","previewfilepath":"https://soundcloud.com/countzerointerupt/acid-house-mix","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//AUDIO BUFFER BASED ON CUBESCAPE BY IQ - https://www.shadertoy.com/view/Msl3Rr\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    C = vec4(0.0);\n    \n    if (U==SND && iFrame>5)\n    {\n        vec4 currentSound =  texture(iChannel0,SND/R),\n             newSound = vec4(texture(iChannel1,vec2(0.01,0.25)).x,\n                             texture(iChannel1,vec2(0.07,0.25)).x,\n                             texture(iChannel1,vec2(0.15,0.25)).x,\n                             texture(iChannel1,vec2(0.30,0.25)).x);\n        C = mix(currentSound,newSound,0.5); //smooth transients    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//ANIMATION BUFFER\n\n#define G -9.8\n\n\nvec2 ballInteraction(vec4 ball, \n    vec2 uv, \n    float prev,\n    float at, \n    inout float freefall)\n{\n    float cubeHeight = 0.0,\n          h1 = hash12(floor(uv)),\n          l = length(ball.xz - (uv - vec2(200.0))),\n          v0 = (12.0+h1*16.2)/(1.0 + l*l*0.01),\n          maxCurve = 10.0/(1.0 + l*l*0.02),\n          currentCurve = (ball.y+ball.w)/(1.0 + l*l*0.02);\n\n    if (currentCurve > maxCurve)\n    {\n        //freefall\n        if (prev==0.0)\n        {\n            //start time for freefall\n            freefall = at;\n        } \n        else \n        {\n            freefall = prev;\n        }\n        float at2 = at - freefall,\n              dY = maxCurve + v0*at2 + 0.5*G*at2*at2; //gravity\n        cubeHeight = min(ball.y,dY); //stop upwards overshoot\n    }\n    else\n    {\n        cubeHeight = currentCurve;\n    }\n    return vec2(cubeHeight * S(ball.w+20.0,ball.w+12.0,l),l);\n}\n\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    C = vec4(0.0);\n    \n    //*\n    float fade = (S(0.0 ,1.0     ,AT)*S(AP03,AP03-1.0,AT) + \n                  S(AP03,AP03+1.0,AT)*S(AP10,AP10-1.0,AT) +\n                  S(AP10,AP10+1.0,AT)*S(AP20,AP20-1.0,AT) +\n                  S(AP20,AP20+1.0,AT)*S(AP21,AP21-1.0,AT) +\n                  S(AP21,AP21+1.0,AT)*S(147.6,146.6,AT)) *\n                 (S(0.0,8.0,T)*S(AP02,20.0,T) + step(AP03,T)),\n    //*/             \n    //float fade = 1.0,\n          pt1a = step(AP03,AT)-step(AP10,AT),       \n          ampl = ((AT<AP03) ? 6.0 : 2.0) + \n                 (S(38.0,AP10,AT)-step(AP10,AT))*4.0,\n          lava = step(AP21,AT),\n          ra = AT<AP10 ? 1.5 : 0.4,\n          at = 0.0;\n\n    vec4 ball1 = vec4(1000.0,1000.0,1000.0,6.0),\n         ball2 = vec4(1000.0,1000.0,1000.0,6.0),\n         snd = texture(iChannel1,SND/R),\n         cam = vec4(10.0+sin(AT*0.1)*13.0,20.0-AT*0.07,-5.0-AT*1.3,1.4),\n         lookAt = vec4(0.0,1.0,0.0,1.0);\n    \n    \n    if (T<AP03) \n    {\n        cam = vec4(-40.0+T*2.0,35.0-T,-8.0,1.4-S(18.0,24.0,T)*0.5);\n    }\n    if (AT>=AP03 && AT<AP10)\n    {\n        at = AT - AP03;\n        cam = vec4(-9.0-sin(T*0.23)*3.0,20.0-at*0.14,-3.0-at*1.5,1.4);   \n    }\n    \n    if (AT>=AP10 && AT<AP20)\n    {\n        at = AT - AP10;\n        cam = vec4(-30.0+at*1.1,12.0,-5.0,1.0);\n        cam.xz*=rot(T*0.23);\n        ball1 = vec4(-7.0-sin((T+7.1)*0.63)*13.7 + cos((T+9.1)*1.7)*2.3,\n                     sin(T*0.7)*1.3 + sin((T-21.3)*1.3)*2.0,\n                     cos((T-9.3)*0.45-9.1)*16.3,\n                     6.0);\n        lookAt = ball1;             \n    }\n\n    if (AT>AP20)\n    {\n        at = AT - AP20;\n        if (AT<AP21)\n        {\n            cam = vec4(-15.0,10.0+at*0.4,-17.0,1.4+S(100.0,128.0,AT)*0.6);\n            cam.xz *= rot(sin(T*0.05)*8.0);\n        }\n        else\n        {\n            at = AT - AP21;\n            cam = vec4(9.0,10.0+at*0.2,-17.0,1.4);\n            cam.xz *= rot(T*0.05);\n        }\n        float descent = 2.0 + S(AP30,AP40,AT)*60.0;\n        ball1 = vec4(-15.0 + sin(T*0.37)*2.0,\n                     (sin(T*0.9) + sin((T-21.3)*1.3)*3.1) - descent,\n                     cos(T*0.45-9.1)*3.3,\n                     6.0);\n        ball2 = vec4(17.0 + sin(T*0.3)*3.3,\n                     (sin((T + 51.0)*0.21)*3.0 + cos((T-7.1)*2.1)) - descent,\n                     sin(T*0.13)*2.1,\n                     6.0);\n\n        ball1.xz *= rot(T*0.7);\n        ball2.xz *= rot(T*0.7);\n        \n        if (AT>AP40)\n        {\n            ball1 = vec4( 0.0 ,(AT - AP40  - 0.125)*40.0,0.0 ,6.0);\n            ball2 = vec4(-20.0,(AT - 142.0 - 0.125)*40.0,20.0,6.0);\n        }\n        //lookAt = ball2*(1.0-lava);\n    }\n\n    if (U.x < 401.0)\n    {\n        //grid animation\n        vec4 prev = texture(iChannel0,U/R);\n        float id = hash12(floor(U)),\n              baseHeight = 0.0,\n              cubeHeight = 0.0,\n              cubeSize = 0.3,\n              freefall1 = 0.0,\n              freefall2 = 0.0,\n              wave = sin(((U.x*0.23) + T)*0.44)*0.8 *\n                     sin(((U.y*0.37) + T*0.7)*0.4)*0.5,        \n              pattern1 = patt1(U - vec2(200.0),T),\n              pattern2 = patt2(U - vec2(200.0),T);\n        \n        baseHeight = wave*4.0+3.0*pattern1;\n        baseHeight += pattern2*pow(snd.x+snd.y,4.0)*id*ampl;\n        \n        if (AT>AP10)\n        {\n            vec2 bi = ballInteraction(ball1,U,prev.y,AT,freefall1);\n            cubeHeight = mix(bi.x,baseHeight,S(ball1.w,16.0,bi.y));\n            bi = ballInteraction(ball2,U,prev.z,AT,freefall2);\n            cubeHeight = mix(bi.x,cubeHeight,S(ball2.w,16.0,bi.y));\n            \n        }\n        cubeHeight = max(baseHeight,cubeHeight);\n        cubeSize *= (1.0 - clamp(cubeHeight*0.04,0.1,0.9));\n        \n        C = vec4(cubeHeight,freefall1,freefall2,cubeSize);\n    }\n    \n    \n    if (U==B1)\n    {\n        C = ball1;\n    }\n    if (U==B2)\n    {\n        C = ball2;\n    }\n    if (U==CAM)\n    {\n        C = cam;\n    }\n    if (U==LOOK_AT)\n    {\n        C = lookAt;\n    }\n    if (U==SCENE)\n    {\n        C = vec4(fade,lava,pt1a,ra);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//RENDER BUFFER\n\n#define EPS 0.002\n#define FAR 160.0\n\n//Nimitz - sparse grid marching\n//https://www.shadertoy.com/view/XlfGDs\nconst float c = 1.0,\n            ch = c*0.5,\n            ch2 = ch + 0.01;\nfloat dBox(vec3 ro, vec3 rd)  \n{\n    vec3 m = 1.0/rd,\n         t = -m*ro + abs(m)*ch2;\n\treturn min(min(t.x,t.y),t.z);\n}\n\n//distance functions from IQ\n//https://iquilezles.org/articles\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd ),\n          c = dot( oc, oc ) - sph.w*sph.w,\n          h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat sphDensity( vec3  ro, vec3  rd,   // ray origin, ray direction\n                  vec3  sc, float sr,   // sphere center, sphere radius\n                  float dbuffer )       // depth buffer\n{\n    // normalize the problem to the canonical sphere\n    float ndbuffer = dbuffer / sr;\n    vec3  rc = (ro - sc)/sr;\n\t\n    // find intersection with sphere\n    float b = dot(rd,rc),\n          c = dot(rc,rc) - 1.0,\n          h = b*b - c;\n\n    // not intersecting\n    if( h<0.0 ) return 0.0;\n\t\n    h = sqrt( h );\n    \n    //return h*h*h;\n\n    float t1 = -b - h,\n          t2 = -b + h;\n\n    // not visible (behind camera or behind ndbuffer)\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n\n    // clip integration segment from camera to ndbuffer\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    // analytical integration of an inverse squared density\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0),\n          i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat map(vec3 p, vec3 rd) \n{\n    vec4 cubeData = texture(iChannel0,(floor(p.xz) + vec2(200.5))/R);\n    p.y -= cubeData.x;\n    vec3 qd = fract(p/c)*c -ch,\n         qid = floor(p/c),\n         h3 = hash33(qid);\n    float t = dBox(qd, rd); //Base distance is cell exit distance\n    if (qid.y <= 0.0)\n    {\n        qd.yz *= rot(h3.y + h3.x*T*2.0);\n        qd.zx *= rot(h3.x + h3.y*T*2.0);\n        t = min(t,sdBox(qd,vec3(cubeData.w)));    \n    }\n    return t;\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n, vec3 rd) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 12.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n*d,rd));\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//IQ - https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, rd );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 normal(vec3 p, vec3 rd) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p,0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz,rd);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nfloat march(vec3 ro, vec3 rd, float maxt) \n{\n    float t = 0.0;   \n    for (int i=ZERO; i<400; i++)\n    {\n        float ns = map(ro + rd*t,rd);\n        if (abs(ns)<EPS) break;\n        t += ns;\n        if (t>maxt) \n        {\n            t = -1.0;\n            break;\n        }        \n    }\n    return t;\n}\n\nvec3 pal(float t)\n{\n    return vec3(0.5,0.5,0.5) + vec3(0.5,0.5,0.5)*cos( 6.28318*(vec3(1.0,1.0,1.0)*t+vec3(0.0,0.33,0.67)) );\n}\n\nvec3 BG()\n{\n    return vec3(0.5,0.5,0.5) + vec3(0.5,0.5,0.5)*cos( 6.28318*(vec3(1.0,1.0,1.0)*T*0.02+vec3(0.0,0.33,0.67)) );\n}\n\nvec3 renderBall(vec4 ball, vec3 ro, vec3 rd)\n{\n    float h = sphDensity(ro,rd,ball.xyz,ball.w,FAR);\n    return vec3(1.0,0.4,0.0) + vec3(11.0,0.5,0.1)*h*0.8;\n}\n\nvec3 renderBalls(vec4 ball1, \n                 vec4 ball2, \n                 vec3 ro, \n                 vec3 rd, \n                 vec3 la,\n                 inout float dof,\n                 inout float fog,\n                 inout float maxt)\n{\n    float s1 = sphIntersect(ro,rd,ball1),\n          s2 = sphIntersect(ro,rd,ball2);\n    \n    if (s1>0.0 && (s2<0.0 || s2>s1))\n    {\n        maxt = s1;\n        dof = length(ball1.xyz - la);\n        fog = length(ball1.xyz);\n        return renderBall(ball1,ro,rd);\n    } \n    else if(s2>0.0) \n    {\n        maxt = s2;\n        dof = length(ball2.xyz - la);\n        fog = length(ball2.xyz);\n        return renderBall(ball2,ro,rd);\n    }\n    return vec3(0.0);\n}\n\nvec3 ballAmbience(vec3 p, vec3 n, vec3 rd, vec4 ball, vec3 sc)\n{\n    vec3 ld = normalize(ball.xyz-p);\n    float lt = length(ball.xyz-p)-ball.w;\n    float sh = calcSoftshadow(p,ld,EPS,10.0,1);\n    sc = mix(sc,\n             vec3(1.0,0.3,0.0)*max(0.05,dot(ld,n))*sh,\n             1.0/(1.0 + lt*lt*0.05));\n    return sc + vec3(1.0,0.6,0.0)*pow(max(dot(reflect(-ld,n),-rd),0.0),8.0)\n             /(1.0 + lt*lt*0.1);\n}\n\nvec3 ballLava(vec3 p, vec3 n, vec4 ball, vec3 sc)\n{\n    float lt3d = length(ball.xyz - p) - ball.w,\n          lt2d = length(ball.xz - p.xz),\n          dY = max(0.0,ball.y - p.y);\n    vec3 ld = normalize(ball.xyz - p);\n    sc = mix(sc,vec3(0.8,0.2,0.0), 1.0/(1.0+lt3d*lt3d*0.1)) +\n                  vec3(1.0,0.5,0.0)/(1.0+lt3d*lt3d*2.4)*0.6;\n    return mix(sc,vec3(1.0,0.5,0.0), \n                S(0.0,30.0,dY)*10.0/(1.0+lt2d*lt2d*1.2));\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5)/R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd,rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    C = vec4(0.0);\n\n    vec4 ball1 = texture(iChannel0,B1/R),\n         ball2 = texture(iChannel0,B2/R),\n         cam =   texture(iChannel0,CAM/R),\n         snd =   texture(iChannel1,SND/R),\n         scene = texture(iChannel0,SCENE/R),\n         la =    texture(iChannel0,LOOK_AT/R);\n    \n    vec3 lp =  vec3(3.0,40.0,-5.0),\n         lp2 = vec3(35.0,55.0,-25.0),    \n         rd =  camera(U,cam.xyz,la.xyz,cam.w),\n         sky = clouds(rd,T)*BG()*2.0;\n\n    float maxt = FAR, dof = FAR, fog = FAR;\n    //spheres\n    vec3 pc = renderBalls(ball1,ball2,cam.xyz,rd,la.xyz,dof,fog,maxt);\n    //cubes\n    float c = march(cam.xyz,rd,maxt);\n    if (c>0.0)\n    {\n        vec3 p = cam.xyz + rd*c,\n             n = normal(p,rd),\n             ld1 = normalize(lp - p),\n             ld2 = normalize(lp2 - p),\n             skyRefl = clouds(reflect(rd,n),T);\n        float spec = pow(max(dot(reflect(-ld2,n),-rd),0.0),32.0),\n              fres = pow(clamp(dot(n,ld2),0.0,1.0),8.0),\n              pt1 = patt1(p.xz,T),\n              pt2 = patt2(p.xz,T);\n\n        maxt = c;\n        dof = length(p - la.xyz);\n        fog = length(p);\n\n        pc = (vec3(0.16,0.08,0.08)*max(0.0,dot(ld1,n)) + max(0.0,-n.x)*vec3(0.0,0.0,0.03)) *\n            AO(p,n,rd);\n        pc = ballAmbience(p,n,rd,ball1,pc);        \n        pc = ballAmbience(p,n,rd,ball2,pc);\n        \n        if (scene.y>0.0)\n        {\n           pc = ballLava(p,n,ball1,pc);\n           pc = ballLava(p,n,ball2,pc);\n        }\n\n        vec3 rc = mix(BG(),vec3(1.0,0.0,0.0),pt1*scene.z);\n        rc = mix(rc,pal((T-45.7)*0.37),min(1.0,pt2*6.0*(snd.z+snd.w)));\n        vec3 r = rc*fres*0.7 +\n                 mix(rc,vec3(1.0),0.8)*spec +\n                 vec3(0.5)*skyRefl;\n        float yt = max(0.0,p.y*-1.0);\n        r /= (1.0 + yt*yt*0.4);\n                 \n        pc += r*scene.w;\n    }\n    \n    pc = pow(pc,vec3(0.4545)); //gamma correction\n    pc = mix(sky,pc,1.0/(1.0 + fog*fog*0.0006));\n    pc *= scene.x; //fades\n\n    C = vec4(pc*1.0,dof/100.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}