{"ver":"0.1","info":{"id":"7t3czr","date":"1659107246","viewed":234,"name":"Laser Pointer in Clouds","username":"pb","description":"kind of...  actually more like an evaporating ball of plasma\nhold down mouse button to slow down time","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["clouds","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// philip.bertani@gmail.com\n\n\n#define oct 5   //number of fbm octaves\n#define pi  3.14159265\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 1e5 );\n}\n\n\n//this is taken from Visions of Chaos shader \"Sample Noise 2D 4.glsl\"\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f);\n    \n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n    vec3 shift = vec3(100.);  //play with this\n    \n    float angle = pi/4.;      //play with this\n    float cc=cos(angle), ss=sin(angle); \n    mat3 rot = mat3( cc,  0., ss, \n                      0., 1., 0.,\n                     -ss, 0., cc );\n    for (int i=0; i<oct; i++) {\n        v += a * noise(p);\n        p = rot * p * 2. + shift;\n        a *= .67;  //changed from the usual .5\n    }\n    return v;\n}\n\nmat3 rxz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(cc,0.,-ss,\n                0.,1.,0.,\n                ss,0.,cc);                \n}\nmat3 ryz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(1.,0.,0.,\n                0.,cc,-ss,\n                0.,ss,cc);\n}   \n\nvec3 get_color(vec3 p) {\n    vec3 q;\n    q.x = fbm3d(p);\n    q.y = fbm3d(p.yzx);\n    q.z = fbm3d(p.zxy);\n\n    float f = fbm3d(p + q);\n    \n    return q*f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float tt = iTime / 8.;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mm = vec2(1.7,0.); // (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 rd = normalize( vec3(uv, -2.) );  \n    vec3 ro = vec3(0.,0.,0.);\n    \n    float delta = 2.*pi/10.;\n    //float initm = -.5 * delta;\n    mat3 rot = rxz(-mm.x*delta) * ryz(-mm.y*delta);\n    \n    float timefac = 1.;\n    if (iMouse.z > 0.) timefac = 3.;\n    ro -= rot[2]*iTime/timefac;\n    \n    rd = rot * rd;\n    vec3 orig_rd = rd;\n    \n    vec3 p = ro + rd;\n    \n    vec3 cc = vec3(0.);\n\n    float stepsize = .05;\n    float totdist = stepsize;\n    \n    for (int i=0; i<20; i++) {\n       vec3 cx = get_color(p);\n       p += stepsize*rd;\n       float fi = float(i);\n       cc += exp(-totdist*totdist*2.)* cx;\n       totdist += stepsize;\n       rd = ryz(.5)*rd;   //yz rotation here\n    }\n    \n    \n    vec3 x2 = ro + vec3(10.,-1.,-5.), x1= ro + vec3(-10.,2.,0.);\n    vec3 x0 = p + length(cc)*orig_rd;\n    \n    //laser (kind of) here\n    float dist_to_line = length( cross( (x0-x1), (x0-x2) ) ) / length( x2 - x1 );\n    float dd = dist_to_line * dist_to_line;\n    float extra_lum = exp(-dd*dd/10.);\n    float extra_lum2 = exp(-dd/200.);\n    float extra_lum3 = exp(-dd/5.);\n    \n    cc.g += 5.*extra_lum;\n    cc.g += extra_lum2;\n    cc.r += extra_lum2;\n    cc.b += 2.* extra_lum2;\n    cc.b += 2.*extra_lum3; cc.r += 3.*extra_lum3;  //add some more color to center\n    \n    //cc = .5 + 1.2*(cc-.5);  \n    cc = pow( cc/9. , vec3(4.));   \n\n    fragColor = vec4(cc,1.0);\n    \n    \n}\n\n","name":"Image","description":"","type":"image"}]}