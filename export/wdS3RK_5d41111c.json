{"ver":"0.1","info":{"id":"wdS3RK","date":"1549322465","viewed":401,"name":"signed distance bun","username":"daisyowl","description":"its a bunny","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bunny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdf(vec3);\nvec3 normal(vec3);\nfloat sphere(vec3, float);\nfloat union_smooth(float, float, float);\nfloat sub_smooth(float, float, float);\nfloat ao(vec3, vec3, float);\nfloat ss(vec3, vec3);\nfloat mirrorX(vec3);\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nmat3 eulerToMat(vec3 e){\n  float sx = sin(e.x);\n  float sy = sin(e.y);\n  float sz = sin(e.z);\n  float cx = cos(e.x);\n  float cy = cos(e.y);\n  float cz = cos(e.z);\n  return mat3(\n    cy*cz, cz*sx*sy-cx*sz, cx*cz*sy+sx*sz,\n    cy*sz, cx*cz+sx*sy*sz, cx*sy*sz-cz*sx,\n    -sy, cy*sx, cx*cy);\n}\n\nconst float EPS = 0.0001;\nconst float MAX_DIST = 100.0;\nconst int MAX_STEPS = 128;\nconst float MIN_STEP_SIZE = 0.005;\n\nconst int AO_STEPS = 5;\nconst float AO_DIST_PER_STEP = 0.5;\nconst float D2R = 3.141528 / 180.0;\nconst vec3 bg = vec3(0.7, 0.7, 1.2) * 0.5;\n\nvec3 lightPos = normalize(vec3(1, 1, 1));\n\nstruct Shape {\n  bool additive;\n  float r;\n  float blend;\n  vec3 pos;\n  vec3 scale;\n  vec3 rot;\n};\n\n\nShape shapes[16] = Shape[16](\n  Shape(true, 1.0, 1.0, vec3(0.0, 0.5, 0.0), vec3(1,1,1), vec3(0,0,0)*D2R), // head\n  Shape(true, 0.4, 0.3, vec3(0, 0.2, 0.6), vec3(1,1,1), vec3(0,0,0)*D2R), // snoot\n  Shape(true, 0.4, 0.3, vec3(-0.5, 1.5, -0.5), vec3(1,3,1), vec3(-20,25,0)*D2R), // ear\n  Shape(true, 0.4, 0.3, vec3(+0.5, 1.5, -0.5), vec3(1,3,1), vec3(-20,-25,0)*D2R), // ear\n  Shape(false, 0.2, 0.2, vec3(-0.7, 2.1, -0.3), vec3(1,3,1), vec3(-20,25,0)*D2R), // ear-cut\n  Shape(false, 0.2, 0.2, vec3(+0.7, 2.1, -0.3), vec3(1,3,1), vec3(-20,-25,0)*D2R), // ear-cut\n  Shape(false, 0.35, 0.3, vec3(+0.5, 0.7, 0.8), vec3(1,1,1), vec3(0,0,0)*D2R), // eye-socket\n  Shape(false, 0.35, 0.3, vec3(-0.5, 0.7, 0.8), vec3(1,1,1), vec3(0,0,0)*D2R), // eye-socket\n  Shape(true, 0.5, 0.0, vec3(+0.2, 0.6, 0.35), vec3(1,1,1), vec3(0,0,0)*D2R), // eye\n  Shape(true, 0.5, 0.0, vec3(-0.2, 0.6, 0.35), vec3(1,1,1), vec3(0,0,0)*D2R), // eye\n  Shape(true, 0.5, 0.1, vec3(0.0, -0.8, 0.0), vec3(1,1,1), vec3(0,0,0)*D2R), // chest\n  Shape(true, 0.7, 0.5, vec3(0.0, -1.5, 0.0), vec3(1,1,1), vec3(0,0,0)*D2R), // tummy\n  Shape(true, 0.2, 0.1, vec3(-0.7, -0.8, 0), vec3(1,2,1), vec3(0,0,-45)*D2R), // arm\n  Shape(true, 0.2, 0.1, vec3(0.7, -0.8, 0), vec3(1,2,1), vec3(0,0,45)*D2R), // arm\n  Shape(true, 0.2, 0.1, vec3(-0.3, -2, 0), vec3(1,2,1), vec3(0,0,-15)*D2R), // leg\n  Shape(true, 0.2, 0.1, vec3(0.3, -2, 0), vec3(1,2,1), vec3(0,0,15)*D2R) // leg\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  vec2 mouse = iMouse.xy/iResolution.xy;\n\n  float camDist = 6.0;\n  float spinRate = 0.5;\n  vec3 p = vec3(sin(iTime * spinRate + mouse.x * 6.0) * camDist, (mouse.y - 0.5) * -6.0, cos(iTime * spinRate + mouse.x * 6.0) * camDist);\n  vec3 camDir = normalize(-p);\n\n  mat3 cMatrix = setCamera(p, camDir, 0.0);\n  float aspect = iResolution.x / iResolution.y;\n  vec3 dir = cMatrix * normalize(vec3((uv.x - 0.5) * aspect, uv.y - 0.5, 1));\n\n  //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n  bool hit = false;\n\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sdf(p);\n\n    if (dist < EPS) {\n      hit = true;\n      break;\n    }\n\n    if (length(p) > MAX_DIST) {\n      break;\n    }\n\n    p += dir * max(MIN_STEP_SIZE, dist);\n  }\n\n\n  vec3 outColor = bg.rgb;\n\n\n  if (hit)  {\n    vec3 normal = normal(p);\n    float lamp = max(0.0, dot(normal, cMatrix * lightPos)) * 1.0;\n    vec3 light = vec3(lamp * 1.5, lamp * 1.3, lamp);\n    light += bg.xyz;\n\n    float fBias = 0.0;\n    float fScale = 0.5;\n    float fPower = 2.0;\n    float fresnel = max(0.0, min(1.0, fBias + fScale * pow((1.0 + dot(dir, normal)), fPower)));\n    light += fresnel * bg;\n    \n    float _ao = ao(p, normal, 0.6);\n    light *= _ao;\n\n    float _ss = ss(p, -dir);\n    light += _ss * vec3(1,0,0.2) * 1.0;\n\n    vec3 baseColor = vec3(0.8,0.8,0.8);\n\n    //float gray = log(1.0 + light);\n    outColor = light * baseColor;\n    //fragColor = vec4(ao,ao,ao, 1.0);\n  }\n  \n  fragColor = vec4(log2(1.0 + outColor.r), log2(1.0 + outColor.g), log2(1.0 + outColor.b), 1.0);\n\n  // for debugging values\n  // fragColor = vec4(dir, 1.0);\n}\n\nfloat sdf(vec3 p) {\n  float dist = 1000000.0;\n  for(int i = 0; i < shapes.length(); i++) {\n    Shape s = shapes[i];\n    mat3 mat = eulerToMat(s.rot);\n    dist = s.additive\n      ? union_smooth(dist, sphere(mat * (p - s.pos) / s.scale, s.r), s.blend)\n      : sub_smooth(sphere(mat * (p - s.pos) / s.scale, s.r), dist, s.blend);\n  }\n  return dist;\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 normal(vec3 p) {\n  return normalize(vec3(\n    sdf(p + vec3(EPS, 0.0, 0.0)) - sdf(p + vec3(-EPS, 0.0, 0.0)),\n    sdf(p + vec3(0.0, EPS, 0.0)) - sdf(p + vec3(0.0, -EPS, 0.0)),\n    sdf(p + vec3(0.0, 0.0, EPS)) - sdf(p + vec3(0.0, 0.0, -EPS))\n  ));\n}\n\nfloat union_smooth(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sub_smooth(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat ao(vec3 p, vec3 normal, float k) {\n  float actualSum = 0.0;\n  for(int i = 1; i <= AO_STEPS; i++) {\n    float exp = (1.0 / pow(2.0, float(i)));\n    vec3 sampleP = p + normal * float(i) * AO_DIST_PER_STEP;\n    actualSum += exp * (float(i) * AO_DIST_PER_STEP - sdf(sampleP));\n  }\n  return 1.0 - k * actualSum;\n}\n\nconst int SS_STEPS = 3;\nconst float SS_DIST_PER_STEP = 0.5;\nfloat ss(vec3 p, vec3 normal) {\n  float actualSum = 0.0;\n  for(int i = 1; i <= SS_STEPS; i++) {\n    float exp = (1.0 / pow(2.0, float(i)));\n    vec3 sampleP = p + -normal * float(i) * SS_DIST_PER_STEP;\n    actualSum += exp * max(0.0, sdf(sampleP));\n    // actualSum += exp * (float(i) * AO_DIST_PER_STEP - sdf(sampleP));\n  }\n  return actualSum;\n}","name":"Image","description":"","type":"image"}]}