{"ver":"0.1","info":{"id":"4dKfWG","date":"1530682259","viewed":202,"name":"Conformal Fields","username":"dust","description":"Investigating mappings of sets of child fields over arbitrary parent-fields with minimal distortion. Undefine [DISPLAY_PARENT] to see how children trace the contours of the parent field in the limit.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","math","sdf","projection","distance","mapping","rendering","functions","gfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Settings\n#define DISPLAY_PARENT\n#define SPIN_AXIS vec3(0, 1, 0)\n#define CHILD_FREQ 5.0\n\n// Composite field; generates main sphere + children\nfloat SceneDF(vec3 coord,\n              vec4 sphInfo)\n{\n    // Find baseline distance to the parent SDF\n    float parentDist = SphDF(coord,\n                             sphInfo);\n        \n\t// Find distance to the child field after projecting into the\n    // XY plane\n    float childDistXY = SphFieldSDF(CHILD_FREQ,\n               \t\t\t\t\t    vec3(coord.xy, parentDist));\n    \n    // Find distance to the child field after projecting into the\n    // XZ plane\n    float childDistXZ = SphFieldSDF(CHILD_FREQ,\n               \t\t\t\t\t    vec3(coord.xz, parentDist));\n    \n    // Find distance to the child field after projecting into the\n    // YZ plane\n    float childDistYZ = SphFieldSDF(CHILD_FREQ,\n               \t\t\t\t\t    vec3(coord.yz, parentDist));\n    \n    // Compose separate images into a minimally-distorted map over the parent field\n    float childDist = mix(mix(childDistXY, childDistYZ, tan(1.0 - abs(coord.z))), childDistXZ, sin(abs(coord.y)));\n    \n    // Return composite field\n    #ifdef DISPLAY_PARENT\n    \treturn min(parentDist, childDist);\n    #else\n    \treturn childDist;\n    #endif\n}\n\n// Four-tap tetrahedral normals from nimitz\n// (https://www.shadertoy.com/view/Xts3WM)\nvec3 norml(vec3 coord,\n           vec4 sphInfo)\n{\n    vec2 e = vec2(-1.0, 1.0) * EPSILON;\n    return normalize(SceneDF(coord + e.yxx, sphInfo) * e.yxx +\n                     SceneDF(coord + e.xxy, sphInfo) * e.xxy +\n                     SceneDF(coord + e.xyx, sphInfo) * e.xyx +\n                     SceneDF(coord + e.yyy, sphInfo) * e.yyy);\n}\n\n// Core render function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Simple marching loop\n    vec3 eyePos = vec3(0, 0.0, -2.5);\n    vec3 rayDir = RayDir(fragCoord,\n                         iResolution.xy);\n    float currRayDist = 0.0;\n    vec3 rgb = vec3(0.25, 0.25, 0.25);\n    for (int i = 0; i < 256; i += 1)\n    {\n        vec3 ray = eyePos + (rayDir * currRayDist);\n        vec4 spinQtn = Qtn(SPIN_AXIS, iTime);\n        vec3 spinRay = QtnRotate(ray,\n                             \t spinQtn);\n        float dist = SceneDF(spinRay,\n                             vec4(0.0, 0.0, 0.0, \n                                  1.0));\n        if (dist < EPSILON)\n        {\n            vec3 ltPos = QtnRotate(vec3(0, 0.2, -3),\n                                   spinQtn);\n            rgb = vec3(0.1, 0.1, 0.1) * dot(vec3(ltPos - ray), norml(spinRay,\n                                                                     vec4(0.0, 0.0, 0.0, \n                                  \t\t\t\t\t\t\t\t\t\t  1.0)));\n            break;\n        }\n        else\n        {\n            currRayDist += dist;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// Epsilon value used to define approximate contact distance\n// for fields within the scene\n#define EPSILON 0.001\n\n// Spherical distance function\n// [sphInfo] has position in [xyz], radius in [r]\nfloat SphDF(vec3 coord,\n            vec4 sphInfo)\n{\n    return length(coord - sphInfo.xyz) - sphInfo.w;\n}\n\n// Small function to evaluate sphere sets in XZ\n#define SPH_FIELD_HEIGHT 0.1\nfloat SphFieldSDF(float freq,\n                  vec3 coord)\n{\n    // Translate the field slightly above the origin\n    coord.z -= SPH_FIELD_HEIGHT * 0.5;\n    \n    // Extract a period from the given frequency\n    float period = 1.0 / freq;\n    \n    // Trap the given position in the interval [-period, period]\n    // Also allow for a half-period buffer around each figure\n    //vec3 xzPos = vec3(mod(coord.x, period) - (0.5 * period), \n    //                  coord.y, \n    //                  mod(coord.z, period) - (0.5 * period));\n    vec3 xzPos = vec3(mod(coord.x, period) - (0.5 * period), \n                      mod(coord.y, period) - (0.5 * period),\n                      coord.z);\n    \n    // Evaluate distance to implicit members of the set\n    return SphDF(xzPos, \n                 vec4(0,0,0,SPH_FIELD_HEIGHT));\n}\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\n// Generate a quaternion from the given axis/angle pair\nvec4 Qtn(vec3 axis, float angleRads)\n{\n    return vec4(axis * cos(angleRads), sin(angleRads));\n}\n\n// Ray generator for a perspective pinhole camera\nvec3 RayDir(vec2 pixPos,\n            vec2 viewSizes)\n{\n    vec3 dir = vec3(pixPos - (viewSizes / 2.0),\n                \tviewSizes.y / tan(1.62 / 2.0));\n    return normalize(dir);\n}\n","name":"Common","description":"","type":"common"}]}