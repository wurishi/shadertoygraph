{"ver":"0.1","info":{"id":"cdSyDW","date":"1687695616","viewed":103,"name":"Basic Jump Flooding","username":"chronos","description":"This is neither the shortest nor most efficient implementation, but the concept should be reasonably clear.\nAt each step, each pixel stores it's current closest found seed by a relative offset, like a waypoint by adding search- plus sample- offsets.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["basic","flood","jump","flooding","jfa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Buffer A is the source buffer, or input, from which the distance / offset should be calculated\n// Buffer B samples buffer A as a seed and itself to iteratively apply jump flooding\n\n// This buffer visualizes the result :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float dist = length(samp.rg);\n    vec3 color = vec3(.5*(1.+normalize(samp.rg)), dist / 500.);\n    fragColor = vec4(pow(color, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    \n    vec4 color = vec4(0);\n    \n    if(length(uv) < 0.125) \n    {\n        color.rg = -(fragCoord - iResolution.xy / 2.) ;\n        color.a = 1.;\n    }\n\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 ij = ivec2(fragCoord);\n    \n    const int STEP_FRAMES = 30;\n    if(iFrame % STEP_FRAMES != 0)\n    {\n       fragColor = texelFetch(iChannel1, ij, 0);\n       return;\n    }\n\n    const int N = 9;\n    \n    // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n    int jump_size = (1 << N) >> min(iFrame/STEP_FRAMES, N); \n    \n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(0);\n    float current_fill = 0.;\n    \n    \n    if(iFrame == 0)\n    {\n        fragColor = texelFetch(iChannel0, ij, 0);\n        return;\n    }\n    \n    \n    \n    for(int x = -1; x <= 1; ++x)\n    for(int y = -1; y <= 1; ++y)\n    {\n        ivec2 jump = jump_size*ivec2(x,y);\n        ivec2 coord = ij + jump;\n        if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n        {\n            continue;\n        }\n\n        vec4 samp = texelFetch(iChannel1, coord, 0);\n\n        bool samp_fill = samp.a >= 1.;\n        vec2 samp_offset = samp.rg;\n\n        vec2 candidate_offset = vec2(jump) + samp_offset;\n        float candidate_dist = length(candidate_offset);\n\n        if (candidate_dist <= current_dist && samp_fill)\n        {\n            current_dist = candidate_dist;\n            current_offset = candidate_offset;\n            current_fill = 1.;\n        }\n\n    }\n\n    // save offset and fill\n    fragColor = vec4(current_offset, 0., current_fill);\n}","name":"Buffer B","description":"","type":"buffer"}]}