{"ver":"0.1","info":{"id":"4dGXW1","date":"1463977610","viewed":1949,"name":"Anti-Aliasing Compare","username":"JasonD","description":"ANTI-ALIASING:\n- = none\nQC = nVidia quincunx\n2x = 2x2 \n3D = 3Dfx rotate grid\nNx = 4x4\nR1 = rand 8x8\nR2 = rand 8x8 dynamic\n\nCONTROL\nMouse click and move:\nleft/right = move split screen (AA methods: left to right)\nup/down = change zoom factor","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","random","quincunx","supersample","3dfx","2x2","compare","nxn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Anti-Aliasing Tests - rev. 53J\n   May 21 - June 5, 2016\n\n   Authors: \n     Jason Doucette:    https://www.shadertoy.com/user/JasonD        \n                        http://xona.com/jason/\n     Michael Pohoreski: https://www.shadertoy.com/user/MichaelPohoreski\n\n  Methods:                       # Samples:\n  ----------------------------------------------\n  1. none                        1\n  2. nVidia Quincunx             2\n  3. standard 2x2 supersample    4\n  4. 3Dfx rotated grid           4\n  5. standard NxN supersample    4^2 (*N^2 set in #define METHOD_NXN_N     below)\n  6. random supersample static   8^2 (*N^2 set in #define METHOD_RND_NXN_N below)\n  7. random supersample dynamic  8^2 (*N^2 set in #define METHOD_RND_NXN_N below)\n*/\n\n\n// ---- MAIN SETTINGS --------------------------------\n\n// see Note 5 and 6 above:\n#define METHOD_NXN_N     4 \n#define METHOD_RND_NXN_N 8\n//  4x 4 =   16 samples\n//  8x 8 =   64 samples\n// 16x16 =  256 samples\n// 32x32 = 1024 samples\n\n#define GAMMA_CORRECTION 2.2\n// check your monitor gamma here:  https://www.shadertoy.com/view/ldVSD1\n\n// (NOTE: More internal settings are listed much further below.)\n\n\n// ---- METHOD EXPLANATIONS --------------------------------\n/*\n\n======== 1. none ========\n\nA single sample is used from the pixel's center:\n\n+------+------+\n|             |        \n|             |\n|             |\n+      X      +  <--- X marks the spot\n|             |\n|             |\n|             |        \n+------+------+\n\n\n======== 2. nVidia Quincunx ========\n\n5 samples are used:\n- 1 in the center\n- 4 at the corners of the pixel, which are shared with 3 other pixels (4 in total).\nThe result is that only 2 samples per pixel need to be taken\n\nX------+------X  <--- note the samples from ALL FOUR corners\n|             |        \n|             |\n|             |\n+      X      +\n|             |\n|             |\n|             |        \nX------+------X  <---- they are shared with adjacent pixels\n|             |        \n|             |\n|             |\n+      X  <- -+- - - - weight = 1/2 = 50%\n|             |\n|             |\n|             |        \nX------+------X < - - - weight = 1/8 = 12.5%\n\nThis is essentiall a blur.\n\n\n\n======== 3. standard 2x2 supersample ========\n\n4 samples are taken within a pixel,\nequi-distance from each other,\nand from samples from adjacent pixels\n\n+------+------+\n|      |      |        \n|  x       x  |\n|      |      |\n+ - - - - - - +\n|      |      |\n|  x       x  |\n|      |      |        \n+------+------+\n\n\n======== 4. 3Dfx rotated grid ========\n\n4 samples are taken within a pixel.\nequi-distance from each other,\nand from samples from adjacent pixels\n\n^^^ SOUND FAMILIAR? ^^^\n    Yup, it's very much like 2x2,\n\n    EXCEPT....\n\nThe pixel grid is rotated:\n\n+------+------+\n|    X-| - - -| - - - - }\n|             |         } dy = constant\n|      |    X | - -}- - }\n+ - - - - - - +    } dy\n| X- - | - - -|- - }- }\n|             |       } dy\n|      | X - -| - - - }       \n+------+------+\n  ^  ^   ^  ^\n  |  |   |  |\n  |  -----  |\n  |  |dx |  |\n  |  |   ----\n  ----     dx = constant\n\n     dx = dy\n\n3Dfx rotation angle is such that the four points are \nEQUI-DISTANCE from each other IN BOTH ORTHOGONAL DIRECTIONS.\n\nThus, when a near horizontal or near vertical plane moves \nthrough the pixel, instead of seeing 2 steps (as in a 2x2 AA):\n(step 1 = passing through the top    (or right) two samples)\n(step 2 = passing through the bottom (or left)  two samples)\n\nYou will see 4 steps:\n(step 1 = passing through the first sample)\n(step 2 = passing through the second sample)\n(step 3 = passing through the third sample)\n(step 4 = passing through the fourth sample)\n\nThis is maximum possible steps!  4 steps for 4 samples.\n\n\nMATHEMATICS FOR THE ANGLE:\n\nIt's not so hard.\nPicture the bottom & right dots, and make a right triangle:\n\n    X\n   /|\n  / o\n /  |\n X--o\n\nThe angle is within a triangle of:\n- oppsite side = exactly 2x length of adjacent.\n\n tan( angle ) =    opp / adj\n tan( angle ) =      1 / 2\n      angle   = atan(1 / 2)\n              = 26.5650512 degrees \n              = 0.46364760 radians\n\n\nHARD CODE THE RESULT FOR SPEED:\n\nRotate a point (0.25, 0.25), from the 2x2,\nby 26.5650512 degrees:\n    \n    vec2 p = rotateX( \n        vec2(0.25, 0.25),  \n        0.463647609 );  // radians (26.5650512 degrees)\n\nResult = (x,y) = 0.11218413712, 0.33528304367\n               =     small    ,     large\n\nThe 4 resultant dots (rotated 26.5 degrees clockwise) are:\n 1. -small, +large\n 2. +large, +small\n 3. +small, -large\n 4. -large, -small\n\n\n======== 5. standard NxN supersample ========\n\nSubdivides the pixel by N in both directions.\nFor N = 4:\n\n+------+------+\n| X  X | X  X |        \n|             |\n| X  X | X  X |\n+ - - - - - - +\n| X  X | X  X |        \n|             |\n| X  X | X  X |\n+------+------+\n\n\n======== 6. & 7. random supersample ========\n\nSame as NxX, except it's random.\n6. This could be static, which avoids moire patterns.\n7. However, this should CHANGE EVERY FRAME, to produce random photons reaching your eye.\n   Thus, this should run at the HIGHEST FRAME-RATE for best results:\n\n+-X----+---X--+\nX    X | X    |        \n| X    X      X\n|   X  |   X  |\n+ - - - -X- - +\nX  X   |    X |        \n|    X   X    |\n| X    |   X  X\nX----X-+-X----+\n\n\n\n======== 8. ADDITIONAL METHODS: EXERCISE FOR THE READER :) ========\n\n-\tmake a higher sample rate for 3Dfx's method, say a 4x4 grid!\n-\tcompare identical sample numbers, say 4x4 square vs. 4x4 random.\n\n*/\n\n\n// ---- INTERNAL SETTINGS --------------------------------\n\n// pattern 1:\n#define CIRCLE_PERCENTAGE_OF_SCREEN 0.90\n// these should be integers:\n#define MIN_ZOOM 1.0\n#define MAX_ZOOM 8.0\n// colors:\n#define BG_COLOR         vec3( 0.8, 1.0, 0.8 )\n#define COLOR_TITLE      vec3( 0.0, 0.3, 1.0 )\n#define COLOR_ZOOM       vec3( 0.8, 0.0, 0.8 )\n#define COLOR_EQUALS     vec3( 0.0, 0.0, 0.0 )\n#define COLOR_ZOOMFACTOR vec3( 1.0, 0.0, 0.0 )\n\n\n// ---- GLOBALS --------------------------------\n\n    // TODO -- could prefix these with \"g\" or \"g_\"\n\n    #define PI 3.1415926535897932384626\n    \n    // quantized zoom:\n    float ZOOM;\n\n    // ORIGINAL positions BEFORE zoom:\n    vec2 origM; // 0..1 (mouse)\n    vec2 origP; // 0..1 (pixel position)\n\n    // MODIFIED based on quantized zoom, used in many functions:\n    vec2  res; // resolution\n    vec2  mou; // mouse coordinates\n\n\n// ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ----\n// ---- GLSL NUMBER PRINTING --------------------------------\n// ---- @P_Malin --------------------------------\n\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nconst vec2 gvFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n\nfloat DigitBin(const in int x)\n{\n    if (x < 9) // NOTE: Not using 9\n        return\n           x==0 ? 480599.0\n          :x==1 ? 143906.0 // Note: Original '1' without top-left serif: 139810.0\n          :x==2 ? 476951.0\n          :x==3 ? 476999.0\n          :x==4 ? 350020.0\n          :x==5 ? 464711.0\n          :x==6 ? 464727.0\n          :x==7 ? 476228.0\n          :/* 8*/ 481111.0;\n    else\n    if (x < 91)\n        return // only include glyphs actually need to minimize the shader complexity\n           x==42 ?  21072.0 // *\n          :x==45 ?   3840.0 // -\n          :x==61 ?  61680.0 // =\n          :x==67 ? 921886.0 // C\n          :x==68 ? 498071.0 // D\n          :x==78 ? 638361.0 // N\n          :x==81 ? 432606.0 // Q\n          :x==82 ? 497561.0 // R\n          :/* 90*/ 475671.0;// Z\n/*\n    if (x < 10)\n        return // originals glyphs\n           x==0 ? 480599.0\n          :x==1 ? 143906.0 // Note: Original '1' without top-left serif: 139810.0\n          :x==2 ? 476951.0\n          :x==3 ? 476999.0\n          :x==4 ? 350020.0\n          :x==5 ? 464711.0\n          :x==6 ? 464727.0\n          :x==7 ? 476228.0\n          :x==8   481111.0\n          :       481095.0;\n    if (x < 78)\n        return // Glyphs added by Michael Pohoreski\n           x==42 ?  21072.0 // *\n          :x==45 ?   3840.0 // -\n          :x==61 ?  61680.0 // =\n          :x==65 ? 434073.0 // A\n          :x==66 ? 497559.0 // B\n          :x==67 ? 921886.0 // C\n          :x==68 ? 498071.0 // D\n          :x==69 ? 988959.0 // E\n          :x==70 ? 988945.0 // F\n          :x==71 ? 925086.0 // G\n          :x==72 ? 630681.0 // H\n          :x==73 ? 467495.0 // I\n          :x==74 ? 559239.0 // J\n          :x==75 ? 611161.0 // K\n          :x==76 ?  69919.0 // L\n          :        653721.0 // M\n          ;\n    else\n    if (x < 91)\n        return // Glyphs added by Michael Pohoreski\n           x==78 ? 638361.0 // N\n          :x==79 ? 432534.0 // O\n          :x==80 ? 497425.0 // P\n          :x==81 ? 432606.0 // Q\n          :x==82 ? 497561.0 // R\n          :x==83 ? 923271.0 // S\n          :x==84 ? 467490.0 // T\n          :x==85 ? 629142.0 // U\n          :x==86 ? 349474.0 // V\n          :x==87 ? 629241.0 // W\n          :x==88 ? 628377.0 // X\n          :x==89 ? 348706.0 // Y\n          :        475671.0;// Z\n*/\n    return 0.0;\n}\n\n// ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ---- 8< ----\n\n\n// ---- TEXT --------------------------------\n\nvec2 gvPrintCharXY = vec2( 0.0, 0.0 );\nvec3 Char( vec3 backgroundColor, vec3 textColor, vec2 fragCoord, float fValue)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - gvPrintCharXY) / gvFontSize;\n    if ((vStringCharCoords.y <  0.0) || \n        (vStringCharCoords.y >= 1.0) || \n        (vStringCharCoords.x <  0.0))\n    {\n        return backgroundColor;\n    }\n\n    float fCharBin = float(vStringCharCoords.x < 1.0) * DigitBin(int(fValue));\n\n    // Auto-Advance cursor one glyph plus 1 pixel padding\n    // thus characters are spaced 9 pixels apart    \n    // except for characters 3 pixels wide\n    // TODO -- LOTS OF COMPARES... BAD?\n    float fAdvance = /* false        \n        || (fValue == 42.) // *\n        || (fValue == 73.) // I\n        || (fValue == 84.) // T\n        || (fValue == 86.) // V\n        || (fValue == 89.) // Y\n        || (fValue == 90.) // Z        \n        ? 0.0 // glyph width has no padding\n        : */ 2.0; \n    gvPrintCharXY.x += gvFontSize.x + fAdvance;\n        \n    float a = floor(\n        mod(\n            (fCharBin / pow(\n                2.0, \n                floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), \n            2.0)\n    );\n    return mix( backgroundColor, textColor, a );\n}\n\n\n// ---- UTILITY --------------------------------\n\nvec2 rotateXY( vec2 p, float angleRadians )\n{\n    float s = sin( angleRadians );\n    float c = cos( angleRadians );\n    mat2  m = mat2( c, -s, \n                    s,  c );\n    return m * p; // vec2\n}\n\n// De facto \"noise\" function, modified to supply two values\nvec2 noise2( vec2 location, vec2 delta ) {\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location +      delta            , c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        );\n}\n\n\n// ---- PATTERNS TO ANTI-ALIAS --------------------------------\n\n// ------------------------------------------------------------\n// patternSet_circleWithSpokes\nfloat pattern1( vec2 uv )\n{    \n    // full circle\n    vec2 p = (2.*uv - 1.) / CIRCLE_PERCENTAGE_OF_SCREEN;\n   \n    // quick semi-distance to circle formula:\n    float g = dot( p, p );\n    \n    float insideCircle = float(\n        ((g < 1.0 ) && (g > 0.85 )) ||\n        ((g < 0.6 ) && (g > 0.5  )) ||\n        ((g < 0.2 ) && (g > 0.1  ))\n    );\n    \n    float insideSpokes = float(mod(atan(p.y, p.x) + iTime / 40., PI/8.) < 0.15);\n\n    return \n    \tmod(insideCircle + \n            insideSpokes * (1. - g), \n            1.333);\n}\n\n// ------------------------------------------------------------\n// patternSet_2Dchecker\nfloat pattern2(vec2 uv)\n{\n    // correct for aspect ratio    \n    float aspect = iResolution.y/iResolution.x;\n    \n    // rotate with time distortion in Y    \n    float angle = -iTime * 0.05;\n    \n    // TODO -- I suspect this could be massively optimized.\n    //         We are translating, rotating, scaling, translating\n    //         Twice.  Grabbing coordinates within each.\n\n    const float NUM_CELLS = 8.0;\n    const float SHIFT_POSITIVE = 32.0; // ensure no negatives are rendered, since we use int(x)\n    \n    vec2 pStart = uv.xy - vec2(0.5);\n    pStart.y *= aspect;\n    \n    // 1. normal checkerboard\n    \n    // translate\n    vec2 p1 = pStart;\n    // rotate\n    p1 = rotateXY( p1, angle );\n    // translate back\n    p1 += vec2(SHIFT_POSITIVE + 0.5);    \n\n    p1.xy = floor(p1.xy * NUM_CELLS);\n    \n    // 2. 45 degree rotated checkerboard, zoomed to match vertices\n    \n    // translate\n    vec2 p2 = pStart;\n    // rotate\n    p2 = rotateXY( p2, angle + PI / 4.0);\n    // expand\n    p2 *= 1.41421356237;\n    // translate back\n    p2 += vec2(SHIFT_POSITIVE + 0.5);    \n\n    p2.xy = floor(p2.xy * NUM_CELLS);\n    \n    // combine\n    return mod(p1.x+p1.y + p2.x+p2.y, 2.0);\n}\n\n// ------------------------------------------------------------\n// patternSet_3Dchecker\nfloat pattern3(vec2 uv)\n{\n    // distance from center\n    // NOTE: 0.499 is to avoid the infinity in mid-Y,\n    // which, for our checkerboard calculation, produces NaN,\n    // which shows as black (fully visible during transitions!)   \n    vec2 dCenter = vec2(0.5, 0.499) - uv.xy;\n    \n    float X_INV_SCALE = 1.0;\n    float Z_INV_SCALE = 0.5;\n    \n    // 3D perspective: 1/Z = constant\n    vec3 cam;\n    cam.z = 1.0 / dCenter.y;\n    cam.xy = vec2(\n        X_INV_SCALE * dCenter.x,\n        Z_INV_SCALE)\n         * cam.z;\n\n    // rotate\n    float angle = (iTime * 0.05) \n        * float(uv.y < 0.5); // only allow the ground to rotate, not the ceiling\n    cam.xy = rotateXY( cam.xy, angle );\n\n    // textured\n\tcam.xy = floor(cam.xy * 2.0); \n    return mod(cam.x+cam.y, 2.0);\n}\n\n// ------------------------------------------------------------\nfloat pixelSet(vec2 uv)\n{\n    \n    // our position (already quantized ZOOM):\n    // res is the NEW resolution after ZOOM\n    vec2 p = uv.xy / res.xy; \n    \n    // get slow time:\n    float tDistort = iTime * 1.5 + \n        dot( \n            origP, \n            vec2(0.5, 0.5) // NOTE: changing X vs. Y will change the angle of the swipe fade\n        );\n    \n    // the idea is that we will cycle through a bunch of \"frames\"\n    // each \"frame\" is either:\n    // 1. a static image of a pattern \n    //    (well, the pattern itself may be animating, but that's its own discretion)\n    // 2. a fade between two patterns.\n    // Since all \"frames\" are the same time length,\n    // we should double / triple (or more) up frames for static patterns,\n    // so the fades take a short amount of time.    \n    \n    const float REPEAT_PER_PATTERN = 9.0; // number of frames of just a single pattern (between fades)\n    const float NUM_FRAMES_PER_PATTERN = REPEAT_PER_PATTERN + 1.0; // + 1.0 for the fade\n    \n    const float NUM_PATTERNS = 3.0;\n\n    const float NUM_FRAMES = NUM_PATTERNS * NUM_FRAMES_PER_PATTERN;\n\n    // Thus for our three patterns, with a repeat of 2:\n    // E.g.:\n    // 1. A\n    // 2. A\n    // 3. A -> B  \n    // 4.      B\n    // 5.      B\n    // 6.      B -> C\n    // 7.           C\n    // 8.           C\n    // 9. A <------ C\n    \n    // Thus for our three patterns, with a repeat of 3:\n    // E.g.:\n    //  1. A\n    //  2. A\n    //  3. A\n    //  4. A -> B  \n    //  5.      B\n    //  6.      B\n    //  7.      B\n    //  8.      B -> C\n    //  9.           C\n    // 10.           C\n    // 11.           C\n    // 12. A <------ C\n    \n    float t = mod(tDistort, NUM_FRAMES ); // 0.0..NUM_FRAMES, wraps\n    float f = smoothstep(0.0, 1.0, fract(tDistort)); // change from linear to smooth\n    \n    // Optimized    \n         if (t < REPEAT_PER_PATTERN                              ) return     pattern1(p);\n    else if (t < NUM_FRAMES_PER_PATTERN)                           return mix(pattern1(p), pattern2(p), f);\n    else if (t < REPEAT_PER_PATTERN + NUM_FRAMES_PER_PATTERN     ) return                  pattern2(p);\n    else if (t < NUM_FRAMES_PER_PATTERN * 2.)                      return mix(             pattern2(p), pattern3(p), f);\n    else if (t < REPEAT_PER_PATTERN + NUM_FRAMES_PER_PATTERN * 2.) return                               pattern3(p);\n    else                                                           return mix(                          pattern3(p), pattern1(p), f);\n}\n\n// ---- HUD TITLE & ZOOM --------------------------------\n\n// -------------------------------------------------\nvec3 drawTitle( in vec2 fragCoord, \n               // TODO --- these are equidistant, so why not pass in START and DELTA_X?\n               float mx0, \n               float mx1, \n               float mx2, \n               float mx3, \n               float mx4,\n               float mx5)\n{\n    vec3 color = BG_COLOR;\n    \n    float scale  = iResolution.x;\n    float center = (mx1 - mx0) * 0.5 * scale;\n\n    gvPrintCharXY.y = iResolution.y - gvFontSize.y - 1.;\n    \n    gvPrintCharXY.x = mx0*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 45.); // -\n\n    gvPrintCharXY.x = mx1*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 81.); // Q\n    color = Char( color, COLOR_TITLE, fragCoord, 67.); // C\n\n    gvPrintCharXY.x = mx2*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord,  2.); // 2\n    color = Char( color, COLOR_TITLE, fragCoord, 42.); // *\n\n    gvPrintCharXY.x = mx3*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord,  3.); // 3\n    color = Char( color, COLOR_TITLE, fragCoord, 68.); // D\n\n    gvPrintCharXY.x = mx4*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 78.); // N\n    color = Char( color, COLOR_TITLE, fragCoord, 42.); // *\n\n    gvPrintCharXY.x = mx5*scale - center;\n    color = Char( color, COLOR_TITLE, fragCoord, 82.); // R\n    color = Char( color, COLOR_TITLE, fragCoord, 1. ); // 1\n\n    gvPrintCharXY.x = mx5*scale + center;\n    //                          ^-- positive, to show on the other side of the line\n\n    color = Char( color, COLOR_TITLE, fragCoord, 82.); // R\n    color = Char( color, COLOR_TITLE, fragCoord, 2. ); // 2\n\n    return color;\n}\n\n// -------------------------------------------------\nvec3 drawZoom ( vec2 fragCoord, vec3 color ) \n{\n    // \"Z=x\" text, where x = the zoom factor\n    gvPrintCharXY = vec2( 1.0, iResolution.y - gvFontSize.y - 1.);\n    \n    //color = drawStatus( color, fragCoord, nameLit, equalsLit );\n    color = Char( color, COLOR_ZOOM  , fragCoord, 90.0); // Z\n    color = Char( color, COLOR_EQUALS, fragCoord, 61.0); // =\n\n    // show Zoom factor in upper-left\n    color = Char( color, COLOR_ZOOMFACTOR, fragCoord, ZOOM);\n    return color;\n}\n\n// ---- MAIN --------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---- ORIGINAL POSITIONS ----\n    \n    // get original positions before ZOOM:\n    \n    // mouse y\n    origM = iMouse.xy    / iResolution.xy; // 0..1\n    origP = fragCoord.xy / iResolution.xy; // 0..1\n    \n    // ---- RESET ZOOM WHEN (LIKELY) IN THUMBNAIL MODE ----\n\n    // if we're not using the mouse\n    // AND the window size is LIKELY THAT of a thumbnail,\n    // force defaults to show off a nice thumbnail:\n    // NOTE: this will think it's a thumbnail, even when not, if you're in a very small browser window,\n    //       since the site will shrink the output target to the size of a thumbnail.\n    // ALSO: the site increases thumbnail sizes if your browser window is large; this makes life difficult! :(\n\n    // method of changing X and Y without if-statements:\n    \n    float multChange = \n        float(iMouse.z < 0.5) * \n        float(iResolution.y < 310.0);\n    \n    // 0.5 = center, to see most of the AA methods\n    origM.x = mix(origM.x, 0.5, multChange);\n    \n    // 1.5 is the middle of the ZOOM=2 region\n    origM.y = mix(origM.y, 1.5 / MAX_ZOOM, multChange);\n\n    \n    // ---- ZOOM QUANTIZE ----\n    \n    // get ZOOM factor from the original positions\n    ZOOM = MIN_ZOOM + \n        floor(\n            origM.y * (MAX_ZOOM + 0.99 - MIN_ZOOM) // +0.99 since we floor() the result, \n                                               // and want MAX_ZOOM to be selectable as well\n             ); // needs to be integer \n                // (unless you want cool but inaccurate video game pixel blur animations)\n    ZOOM = clamp(ZOOM, MIN_ZOOM, MAX_ZOOM); // can get out of range when window resizes.\n    \n    \n    // ---- COMPUTE SPLIT SCREEN SECTIONS ----\n        \n    // mouse position relative\n    float mx0 = origM.x - 0.40;\n    float mx1 = origM.x - 0.20;\n    float mx2 = origM.x       ;\n    float mx3 = origM.x + 0.20;\n    float mx4 = origM.x + 0.40;\n    float mx5 = origM.x + 0.60;\n        \n\tvec3 color = vec3(0.0); // final RGB color\n\tfloat colorRGB = 0.0; // single color channel: represents ALL three RGB = grayscale only!\n\t\t\n    // ----------------------------------------------------------------\n    // 1. Header\n    // background bar\n    if (fragCoord.y > (iResolution.y - gvFontSize.y - 2.0))\n    {\n        // the AA method names:\n        color = drawTitle( fragCoord, mx0, mx1, mx2, mx3, mx4, mx5 );\n        color = drawZoom ( fragCoord, color );\n    }\n    \n    // ----------------------------------------------------------------\n    // 2. Main Image (between the header/footer)\n    else\n    {\n        // ---- QUANTIZE TO ZOOM ----\n        \n        vec2 uv = floor(fragCoord / ZOOM) * ZOOM;\n        \n        // then do actual zoom (center zoom on 0.5,0.5)\n        res = (vec2(0.5) - iResolution.xy) / ZOOM;\n        mou = (vec2(0.5) - iMouse.xy     ) / ZOOM;\n        uv  = (vec2(0.5) - uv.xy         ) / ZOOM;\n        \n        // ---- SPLIT SCREEN ---- DIFFERENT AA METHODS ----\n        \n        /* (UNOPTIMIZED VERSION)\n             if (origP.x < mx0) color = pixelSet   ( uv ); // no AA\n        else if (origP.x < mx1) color = aa_quincunx( uv ); // 2 samples          }\n        else if (origP.x < mx2) color = aa_2x2     ( uv ); // 4 samples          }-> similar algorithms\n        else if (origP.x < mx3) color = aa_3dfx    ( uv ); // 4 samples (better) }   (in this shader, that is = share code)\n        else if (origP.x < mx4) color = aa_nxn     ( uv ); // 16 samples\n        else                    color = aa_random  ( uv ); // 64 samples\n        */\n        \n        // TODO -- we should show the resultant if-statement layoyut below\n        //         in a simple format where we just call getColorX(),\n        //         and setCommon(), so that we can see what we've optimized,\n        //         in terms of if statement depth.\n\t\t\n        // ---- METHOD 1. NO AA ----\n        \n        if( origP.x < mx0 )\n        {\n            colorRGB = pixelSet   ( uv );\n        }\n        else\n          \n        // ===========================\n        // EXPLANATION\n        // ===========================\n        // Because pixel shaders don't like too many if-statements, we tried to reduce them.\n        // Since 2x2, Quincunx, and 3Dfx are so similar pixel-shader-wise, we combined them.\n        // Individually, this isn't optimal, but globally (for the pixel shader to use less\n        // \"if-statement resources\", it is.  THIS MEANS MORE PEOPLE CAN RUN THIS SHADER.\n        // ===========================\n            \n        if (origP.x < mx3) {\n            \n            // ---- METHOD 2 & 3 & 4 ---- ALL ARE SHARING SOME PIXEL SHADER CODE ----\n\n            // ---- METHOD 3. 2x2 ----\n            \n            // fragCoord = pixel, not normalized\n            vec2  q = vec2( 0.25, 0.25 ); // common factor: aa_2x2(), aa_3dfx()\n            \n            float w1 = 0.25;\n            float w2 = 0.0 ;\n            \n\n            // ---- METHOD 4. 3DFX ----\n\n            if (origP.x > mx2) {\n                // WE KNOW THE RESULT OF THIS:\n                // small = 0.11218413712\n                // large = 0.33528304367\n                q = vec2(0.11218413712, 0.33528304367);\n            }\n            \n            // ---- METHOD 2. QUINCUNX ----\n\n            if (origP.x < mx1) {\n                // colorRGB = aa_quincunx( uv ); \n                //q = vec2( 0.5, 0.5 );\n                q *= 2.0; // 0.5, 0.5\n\n                // Weightings\n                // quincunx = 1/8th power for four corners that are shared with other pixels\n                //          = 1/2   power for one center\n                //          = TOTAL of 100%\n                w1 = 0.125;\n                w2 = 0.5  ;\n               \n            }\n\n            colorRGB = ( pixelSet(uv + vec2(-q.x, +q.y)) +\n                         pixelSet(uv + vec2(+q.y, +q.x)) +\n                         pixelSet(uv + vec2(+q.x, -q.y)) +\n                         pixelSet(uv + vec2(-q.y, -q.x)) ) * w1 +\n                       ( pixelSet(uv + vec2( 0.0,  0.0)) ) * w2;\n        }\n        \n        // ---- METHOD 5. NxN ----\n        \n        else if (origP.x < mx4) {\n\n            #define invNxN (1. / float(METHOD_NXN_N))\n\n            for (int i=0; i<METHOD_NXN_N; i++) {\n                float n1 = float(i) * invNxN;\n                for (int j=0; j<METHOD_NXN_N; j++) {\n                    \n                    // TODO: could be optimized with additions of a single constant delta \n                    //       applied to both x and y.\n                    // TODO: along with that optimization, the vec(.5,.5) could be placed\n                    //       there too.\n                    \n                    float n2 = float(j) * invNxN;                    \n                    \n                    vec2 offset = vec2(n1, n2) - vec2(0.5, 0.5); \n                    colorRGB += pixelSet(uv + offset);\n                }\n            }\n            colorRGB /= float(METHOD_NXN_N * METHOD_NXN_N);\n        }\n\n        // ---- METHOD 6. RANDOM NxN STATIC ----\n        // ---- METHOD 7. RANDOM NxN DYNAMIC ----\n        \n        else\n        {\n            float t = (origP.x > mx5 ? iTime : 1.0);\n            for (int i=0; i<METHOD_RND_NXN_N; i++) {\n                for (int j=0; j<METHOD_RND_NXN_N; j++) {\n                    \n                    // noise\n                    vec2 q = t * vec2(float(i), float(j)); // this could partially be optimized outside the loop\n                    vec2 n = noise2( uv , q );\n                    vec2 offset = vec2(n.x, n.y) - vec2(0.5, 0.5);\n                    colorRGB += pixelSet(uv + offset);\n                }\n            }\n            colorRGB /= float(METHOD_RND_NXN_N * METHOD_RND_NXN_N);           \n        }        \n\n\t\t// ---- GAMMA CORRECTION ----\n\t\t\n\t\tconst float invGamma = 1. / GAMMA_CORRECTION;\n\t\tcolor = vec3(pow(colorRGB, invGamma));\n        \n    } // else 2. MAIN IMAGE\n\n    // ---- SHOW BLACK BAR SPLITS BETWEEN AA METHODS ----\n\n    // float fade = 1.0; // TODO: Need to account for mouse y position: m.y;\n    #define X1 0.002\n    #define X2 0.003\n    color *=        smoothstep( X1, X2, abs(origP.x-mx0) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx1) );\n    color.g += 1. - smoothstep( X1, X2, abs(origP.x-mx2) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx3) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx4) );\n    color *=        smoothstep( X1, X2, abs(origP.x-mx5) );\n    \n    // ---- FINAL RESULT ----\n    fragColor = vec4(color, 1.);    \n}\n","name":"Image","description":"","type":"image"}]}