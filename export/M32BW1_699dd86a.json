{"ver":"0.1","info":{"id":"M32BW1","date":"1729426048","viewed":27,"name":"My 3D Map","username":"antuzxc","description":"A 3D scenario that has a map generated with perlin noise.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","perlinnoise","map"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float twoPi = 6.283185;\n\nvec2 angle(vec3 p)\n{\n    float X = atan(p.y,p.z);\n    float Y = atan(p.x,p.z);\n    float Z = atan(p.x,p.y);\n    return vec2(X,Y);\n}\n\nvec2 n22 (vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 get_gradient(vec2 pos)\n{\n    float twoPi = 6.283185;\n    float angle = n22(pos).x * twoPi;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat noise(vec2 uv,float amplitude,float scale)\n{\n    vec2 pos_in_grid = uv * scale;\n    vec2 cell_pos_in_grid =  floor(pos_in_grid);\n    vec2 local_pos_in_cell = (pos_in_grid - cell_pos_in_grid);\n    vec2 blend = local_pos_in_cell * local_pos_in_cell * (3.0f - 2.0f * local_pos_in_cell);\n    \n    vec2 left_top = cell_pos_in_grid + vec2(0, 1);\n    vec2 right_top = cell_pos_in_grid + vec2(1, 1);\n    vec2 left_bottom = cell_pos_in_grid + vec2(0, 0);\n    vec2 right_bottom = cell_pos_in_grid + vec2(1, 0);\n    \n    float left_top_dot = dot(pos_in_grid - left_top, get_gradient(left_top));\n    float right_top_dot = dot(pos_in_grid - right_top,  get_gradient(right_top));\n    float left_bottom_dot = dot(pos_in_grid - left_bottom, get_gradient(left_bottom));\n    float right_bottom_dot = dot(pos_in_grid - right_bottom, get_gradient(right_bottom));\n    \n    float noise_value = mix(\n                            mix(left_bottom_dot, right_bottom_dot, blend.x), \n                            mix(left_top_dot, right_top_dot, blend.x), \n                            blend.y);\n   \n    \n    return (0.5 + 0.5 * (noise_value / 0.7)) * amplitude;\n}\n\nmat2 rot(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat map(vec3 p)\n{\n    float Size = 5.;\n    return p.y +1.5 - max(noise(p.xz, 1.,1.),0.45);\n}\n\nvec3 Normal(vec3 p) {\n    const float eps = 0.0001; // Small epsilon value for gradient estimation\n\n    vec3 normal = vec3(\n        map(p + vec3(eps, 0, 0)) - map(p - vec3(eps, 0, 0)),\n        map(p + vec3(0, eps, 0)) - map(p - vec3(0, eps, 0)),\n        map(p + vec3(0, 0, eps)) - map(p - vec3(0, 0, eps))\n    );\n\n    return normalize(normal);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,-3);\n    vec3 rd = normalize(vec3(uv,1));\n    ro.yz *= rot(-3.*m.y);\n    rd.yz *= rot(-3.*m.y);\n    ro.xz *= rot(-3.*m.x);\n    rd.xz *= rot(-3.*m.x);\n    \n    \n    vec3 ls = vec3(0,3,0);\n    float t = 0.;\n    for (int i = 1;i < 80;i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d;\n        if (d<0.001 || t>100.) {break;}\n        \n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 col;\n    if (noise(p.xz,1.,1.) < 0.45)\n    {\n        col = vec3(0,0,1);\n    } else {\n        if (noise(p.xz,1.,1.) < 0.5)\n        {\n            col = vec3(1,1,0);\n        } else {\n            col = vec3(0,1,0);\n        }\n    }\n    vec3 normal = Normal(p);\n    float light = dot(normal,normalize(ls - p));\n    \n    col *= light;\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}