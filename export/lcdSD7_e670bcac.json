{"ver":"0.1","info":{"id":"lcdSD7","date":"1714030442","viewed":51,"name":"waves of coherence","username":"akr51","description":"I do a ray marching template and then some lighting, with shadow, then attempt some kind of hypertexture on the cube and plane, add palette play around with colors and add some warping effects and blending effects between two different color settings.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    \n#define SURFD 0.0001\n#define MAX_D 100.0\n#define ITERATIONS 130\n\n\nvec3 pal(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\n\n    return a + b * cos(c * t + d);\n\n}\n\n\nmat2 rt(float t)\n{\n\n    \n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n    \n\n}\n\nfloat gyroid2(vec3 sp)\n{\n\n\n    return dot(sin(sp.xzy * 2.0 + iTime), cos(sp.zxy * 3.0 + iTime));\n\n}\n\n\n\nfloat gyroid(vec3 sp)\n{\n\n\n    return dot(sin(sp.xzy * 19.0), cos(sp.zxy * 23.0));\n\n}\n\n\nfloat plane(vec3 sp, vec3 n)\n{\n\n\n    sp.x = sin(sp.x * 1.0 + sp.y * 1.0) * 0.1 + gyroid2(sp) * 0.2;\n    return dot(sp, n);\n\n}\n\n\n\nfloat cube(vec3 sp, vec3 dm)\n{\n\n    sp.xy *= rt(iTime);\n    sp.xz *= rt(iTime);\n    sp = abs(sp) - dm;\n    \n    return length(max(sp, 0.0)) + min(max(sp.x, max(sp.y, sp.z)), 0.0);\n    \n}\n\n\n\nfloat map(vec3 sp)\n{\n\n    \n    vec3 pp = vec3(0.0, -3.5, 0.0);\n    vec3 cp = vec3(0.0, -0.3, 3.2);\n    vec3 cpp = sp - cp;\n    float d = cube(cpp, vec3(0.86)) + gyroid(sp) * 0.07;\n    d = min(d, plane(sp - pp, vec3(0.5, 1.0, 0.0)));\n    \n    return d;\n\n\n}\n\n\n\nvec3 nml(vec3 p)\n{\n\n    \n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(p) - vec3(map(p - d.xyy), map(p - d.yxy), map(p - d.yyx)));\n\n}\n\n\nfloat mrch(vec3 ro, vec3 rd)\n{\n\n    float d0 = 0.0;\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n    \n    \n        vec3 sp = ro + rd * d0;\n\n        float ds = map(sp);\n        \n        if (abs(ds) < SURFD || d0 >= MAX_D) break;\n        d0 += ds * 0.55;\n        \n    }\n    \n    return d0;\n}\n\n\n\nfloat light(vec3 sp, vec3 pos)\n{\n\n\n    vec3 l = normalize(pos - sp);\n    vec3 n = nml(sp);\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = mrch(sp + n * 0.01, l);\n    \n    if (d < length(pos - sp))\n    {\n    \n        dif *= 0.8; // shadow\n    \n    }\n    \n    return dif;\n    \n}\n\n\n\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n\n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n    \n\n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    \n    vec2 rr = iResolution.xy, uv = (u + u - rr) / rr.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 cc = ro;\n    vec3 fx = vec3(0.0, 0.0, 0.0);\n    uv.x += sin(uv.x * 2.0 + iTime) * 0.2;\n    uv.y += cos(uv.y * 2.0 + iTime) * 0.2;\n    vec3 rd = dir(uv, ro, fx);\n    vec3 cl = vec3(0.0);\n    \n    float d0 = mrch(ro, rd);\n    \n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(6.0, 6.0, 6.0);\n    \n    vec3 d = vec3(2.0 + iTime * 0.25, 3.5 + iTime * 0.5, 3.0 + iTime);\n    float dif = 0.0;\n    if (d0 < MAX_D)\n    {\n    \n    \n        vec3 sp = ro + rd * d0;\n        dif = light(sp, vec3(cos(iTime), 1.5, sin(iTime)));\n        cl += dif / 0.8;\n    \n    }\n    \n    cl.r = pow(cl.r, 13.0);\n    cl.g = pow(cl.g, 13.0);\n    cl.b = pow(cl.b, 13.0);\n    vec3 clc = cl;\n    vec3 cccl = cl * vec3(0.25, 0.25, 0.25);\n    cl = (pal(a, b, c, d, d0 * 0.01) * 1.9) + clc;\n    \n    vec3 ccc = mix(1.0 - cl, cccl, 0.5 * cos((uv.x + uv.y + iTime) * 0.4) + 0.5);\n    \n    c_out = vec4(ccc, 1.0);\n    \n}\n\n\n","name":"Image","description":"","type":"image"}]}