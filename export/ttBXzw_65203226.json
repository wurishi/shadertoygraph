{"ver":"0.1","info":{"id":"ttBXzw","date":"1606481421","viewed":121,"name":"Cube vortex","username":"Peetu","description":"One of the shaders used in my Assembly 2020 entry Clockwork","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float E = 0.001;\n\nmat2 rot(float a) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 SDF(vec3 p) {\n    p.xy *= rot(p.z * .2 + iTime*.2);\n    vec3 op = p;\n    p = mod(p, vec3(1.));\n    p -= vec3(0.5);\n    \n    p.xy *= rot(p.x * .1 + p.z * .2 + iTime*.4);\n    \n    p = abs(p);\n    float f = fract(sin(dot(floor(op.xy), vec2(56.125, 34.124))));\n    return vec2(max(p.x, max(p.y, p.z)) - .2, f);\n}\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n    float depth = 0.;\n    \n    for(int i = 0; i < 250 && depth < 20.; i++) {\n    \tvec3 p = eye + ray * depth;\n        \n        vec2 data = SDF(p);\n        float dist = data.x;\n        \n        if(dist < E) {\n            vec3 col = mix(\n                vec3(0., 0.25, 0.3) + data.y * .1,\n                vec3(1.,1.,0.),\n                pow(fract(1. - (data.y * 25. + iTime * .2 + depth / 50.)), 8.));\n\n            //return vec3(data.y);\n        \treturn vec3(1. - depth*.05) * col;   \n        }\n        \n        depth+=dist;\n    }\n    \n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\tuv -= vec2(0.9, 0.5) + vec2(sin(iTime)*.1, sin(iTime * .3)*.1);\n    \n    // Time varying pixel color\n    vec3 col;\n    \n    vec3 eye = vec3(0., 0.3, iTime);\n    vec3 ray = normalize(vec3(uv, 2.));\n    \n    col = rayMarch(eye, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}