{"ver":"0.1","info":{"id":"Nd23Wh","date":"1618150354","viewed":56,"name":"BlinnPhong Shading","username":"zxuccv","description":"Learning Raymarching and shading","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Author:Xuan Yang\n\n#define PI 3.14159265359\n#define MaxRMStep 1000\n#define MaxRMDistance 100.\nconst float epsilon = 1e-3;\n\n//Structures\nstruct DirectionalLight{\n    vec3 color;\n    vec3 direction;\n    float intensity;\n};\n\nstruct RayHit{\n    vec3 hitPoint;\n    vec3 N;\n    vec3 color;\n};\n\n//apply texture to sphere\nvec3 spherical_texturing(in vec3 normal, in sampler2D text, float delta) {\n    float u = atan(normal.z, normal.x) / PI * 2.0 + delta;\n\tfloat v = asin(normal.y) / PI * 2.0;\n    return texture(text, vec2(u, v)).xyz;\n}\n\n//apply texture to plane\nvec3 plane_texturing(vec2 uv, in sampler2D text, float scale){\n    return texture(text, uv * scale).xyz;\n}\n\n//procedural grid texture\nvec3 grid_texture(vec2 uv, float scale){\n    uv = fract(uv * scale);\n    vec3 col = vec3(1);\n    if(uv.x < 0.05 || uv.y < 0.05){\n        col = vec3(.5);\n    }\n    return col;\n}\n/*\n------------------------------------------------------------------------\nSDF\n------------------------------------------------------------------------\n*/\n//SDF operations\nfloat SDF_union(float dist1, float dist2) {\n    return min(dist1, dist2);\n}\nfloat SDF_substract(float dist1, float dist2) {\n    return max(dist1, -dist2);\n}\n\n//https://www.shadertoy.com/view/lt3BW2\nfloat SDF_smoothUnion(float dist1, float dist2, float sr) {\n    float d = max(sr - abs(dist1 - dist2), 0.);\n    return min(dist1, dist2) - d * d*0.25/sr;\n}\n\nfloat SDF_smoothSubstract(float dist1, float dist2, float sr){\n    float d = max(sr - abs(dist1 - dist2), 0.);\n    return max(dist1, -dist2) + d * d*0.25/sr;\n}\n\n//SDF objects\nfloat SDF_sphere(vec3 origin, float radius, vec3 point){\n    return length(point - origin) - radius;\n}\n\nfloat SDF_box(vec3 center, vec3 size, vec3 point){\n    vec3 dis = abs(point - center);\n    float res = max(dis.x-size.x, dis.y-size.y);\n    res = max(res, dis.z-size.z);\n    return res;\n}\n\nfloat SDF_plane(float height, vec3 point){\n    return abs(point.y - height);\n}\n\n// Main Scene \nfloat SDF_main(vec3 point){\n    float sphere1 = SDF_sphere(vec3(sin(iTime), 0., cos(iTime)), 0.5, point);\n    float sphere2 = SDF_sphere(vec3(-2.*sin(iTime), 0., cos(iTime)), 0.3, point);\n    float box_base = SDF_box(vec3(0, -1.3, 0.), vec3(5.,.5,5.), point);\n    \n    float ret = SDF_smoothUnion(sphere1, sphere2,.5);\n    ret = SDF_union(ret, SDF_smoothSubstract(box_base, ret, 1.5));\n    return ret;\n}\n\n/*\n------------------------------------------------------------------------\nRay Marching\n------------------------------------------------------------------------\n*/\n\n//march forward basd on current distance to surface until hit surface or reach max \n//iteration step or max distance.\nfloat RM_march(out vec3 point, vec3 direction){\n    float marchDist = 0., dist = 0.;\n    for(int i = 0; i < MaxRMStep; i++){\n        point += dist * direction;\n        dist = SDF_main(point);\n        if(dist < epsilon){\n            return dist;\n        }\n        marchDist += dist;\n        if(marchDist > MaxRMDistance){\n            return marchDist;\n        }\n    }\n    return marchDist;\n}\n\n// Get ray direction pass current pixel\nvec3 RM_rayDirection(vec2 fragCoord){\n    vec2 xy = fragCoord - iResolution.xy / 2.;\n    float z = iResolution.y / tan(PI/4.);\n    return normalize(vec3(xy,-z));\n}\n\n// Estimate the normal on the hit point using gradient of SDF.\n// https://iquilezles.org/articles/normalsSDF\nvec3 estimateNormal(vec3 p) {\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*SDF_main( p + k.xyy*epsilon ) + \n                      k.yyx*SDF_main( p + k.yyx*epsilon ) + \n                      k.yxy*SDF_main( p + k.yxy*epsilon ) + \n                      k.xxx*SDF_main( p + k.xxx*epsilon ) );\n}\n\n/*\n------------------------------------------------------------------------\nShadow\n------------------------------------------------------------------------\n*/\n// Simple hard shadow\nfloat Shadow_hard(RayHit rh, vec3 direction){\n    // get light direction from hit point\n    direction *= -1.;\n    \n    // Move out a little so it won't collide with it self at the beginning.\n    // TODO: any better way to do this?\n    rh.hitPoint += 0.3 * direction;\n    \n    // march to chech if there are object between the hitpoint and the light.\n    float dist = RM_march(rh.hitPoint, direction);\n    return step(dist, epsilon);\n}\n\n/*\n------------------------------------------------------------------------\nBlinn-Phong Shading\n   L = Ambient + Diffuse + Specular\n     = La + Ld + Ls\n     = ka*Ia + kd*I*max(0,N*L) + ks*I*max(0,N*H)^p\n------------------------------------------------------------------------\n*/\nvec3 BP(RayHit rh, vec3 cameraPos, DirectionalLight light){\n    // get texture\n    vec3 basecolor = spherical_texturing(rh.N, iChannel1, 0.);\n    if(rh.hitPoint.y <= -1.2 + epsilon){\n        basecolor = plane_texturing(rh.hitPoint.xz, iChannel0, 0.5);\n    }else if(rh.hitPoint.y <= -0.7 + epsilon){\n        basecolor = grid_texture(rh.hitPoint.xz, 3.);\n    }\n    \n    // Apply only Ambient light if in shadow.\n    float shadowMask = 1.-Shadow_hard(rh, light.direction);\n    \n    vec3 L = -light.direction;// Light direction(from hit point)\n    vec3 V = normalize(cameraPos - rh.hitPoint);// View direction\n    vec3 H = (L + V) / length(L + V);// mid of the view and light vector \n    float ka = 0.3;\n    float kd = 0.8;\n    float ks = 0.2;\n    vec3 I = light.intensity * light.color;\n    \n    // ambient light\n    vec3 ambientLight = vec3(1);\n    vec3 color = ka * I * ambientLight * basecolor;\n    \n    // diffuse\n    float NL = max(0.,dot(rh.N, L));\n    color += kd * I * NL * basecolor * shadowMask;\n    \n    // specular\n    float NH = max(0.,dot(rh.N, H));\n    float specular = pow(NH, 100.);\n    color += ks * I * specular * vec3(1) * shadowMask;\n    \n    return color;\n}\n\n/*\n------------------------------------------------------------------------\nMain\n------------------------------------------------------------------------\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize Camera\n    vec3 CamPosition = vec3(0., 1.8, 4.);\n    vec3 direction = RM_rayDirection(fragCoord);\n    \n    float rotX = (iMouse.x / iResolution.x) * 2.0 * PI;\n    float rotY = (iMouse.y / iResolution.y) * 0.5 * PI - 0.25 * PI;\n    \n    direction *= mat3(vec3(1.,0.,0.), vec3(0., cos(rotY), -sin(rotY)), vec3(0., sin(rotY), cos(rotY)) );\n    \n    // Initialize light\n    DirectionalLight light;\n    light.direction = normalize(vec3(1.0 * sin(0.5 * iTime), -1.0, 1.0 * cos(iTime)));\n    light.color = vec3(1.,1.,0.9);\n    light.intensity = 1.0;\n    \n    // Ray march to get hit point\n    RayHit rh;\n    rh.hitPoint = CamPosition;\n    float dist = RM_march(rh.hitPoint, direction);\n    float hitMask = step(dist, epsilon);\n    rh.N = estimateNormal(rh.hitPoint);\n    \n    \n    // Shading\n    vec3 color = BP(rh, CamPosition, light);\n    color *= hitMask;\n    \n    // Apply cubemap background\n    color += texture(iChannel2, direction).rgb * (1.-hitMask);\n    \n    // Output\n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}