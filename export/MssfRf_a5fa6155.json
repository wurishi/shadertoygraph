{"ver":"0.1","info":{"id":"MssfRf","date":"1497368890","viewed":179,"name":"Voxel 01","username":"darkace65","description":"Experimenting with voxel rendering","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n\nconst vec3 VOXEL_SIZE = vec3(0.2);\nconst int MAX_MARCHING_STEPS = 200;\nconst float MAX_DEPTH = 20.0;\n\nmat4 viewMatrix(vec3 eye, vec3 focus, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(focus - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 viewDir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, 0.5 * sin(iTime / 2.0) + 0.6);\n}\n\nbool voxeltrace(vec3 camera, vec3 ray, out vec3 hit, out vec3 normal) {\n    vec3 currentVoxel = floor(camera / VOXEL_SIZE);\n    vec3 closestVoxel = currentVoxel + max(sign(ray), 0.0);\n    \n    vec3 next = (closestVoxel * VOXEL_SIZE - camera) / ray;\n    vec3 step = sign(ray);\n    vec3 delta = VOXEL_SIZE / abs(ray);\n    \n    hit = currentVoxel;\n    float depth = 0.0;\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(currentVoxel * VOXEL_SIZE);\n        if(dist < EPSILON) {\n            hit = (camera + ray * depth) * (1.0 - abs(normal));\n\t\t\treturn true;\n        }\n        if(depth >= MAX_DEPTH) {\n\t\t\treturn false;\n        }\n        \n        if(next.x < next.y && next.x < next.z) {\n            currentVoxel.x += step.x;\n            depth = next.x;\n            next.x += delta.x;\n            normal = vec3(-step.x, 0.0, 0.0);\n        }\n        else if(next.y < next.x && next.y < next.z) {\n            currentVoxel.y += step.y;\n            depth = next.y;\n            next.y += delta.y;\n            normal = vec3(0.0, -step.y, 0.0);\n        }\n        else if(next.z < next.x && next.z < next.y) {\n            currentVoxel.z += step.z;\n            depth = next.z;\n            next.z += delta.z;\n            normal = vec3(0.0, 0.0, -step.z);\n        }\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float y = 4.0;\n    float c = iTime / 8.0;\n    if(iMouse.z > 0.0) {\n        c = -iMouse.x / iResolution.x * radians(360.0);\n        y = -iMouse.y / iResolution.y * 20.0 + 10.0;\n    }\n    vec3 camera = vec3(-9.0 * cos(c), y, 9.0 * sin(c));\n    vec3 focus = vec3(0.0) + VOXEL_SIZE / 2.0;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 viewToWorld = viewMatrix(camera, focus, up);\n    \n    vec3 viewRay = viewDir(45.0, iResolution.xy, fragCoord);\n    vec3 cameraRay = normalize((viewToWorld * vec4(viewRay, 0.0)).xyz);\n    \n    vec3 hitPoint;\n    vec3 normal;\n    bool hit = voxeltrace(camera, cameraRay, hitPoint, normal);\n    \n    vec3 color = vec3(0.0);\n    if(hit) {\n        vec3 block = mod(hitPoint, VOXEL_SIZE) / VOXEL_SIZE;\n        vec3 l = max(abs(normal), smoothstep(0.0, 0.1, block));\n        vec3 u = max(abs(normal), smoothstep(0.0, 0.1, 1.0 - block));\n        float edge = l.x * l.y * l.z *\n                     u.x * u.y * u.z;\n\n        color = mix(vec3(0.4), vec3(0.95), edge);\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}