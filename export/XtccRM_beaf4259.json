{"ver":"0.1","info":{"id":"XtccRM","date":"1531941429","viewed":517,"name":"Basic : Panning & Zooming & Grid","username":"Gijs","description":"Panning & Zooming & Gridlines","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["grid","lines","zooming","panning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //aquire animation\n    vec3 a = PanZoom(\n        vec2(0,0),\n        1.,\n        vec2(1.),\n        0.001953125,\n        fract(iTime*0.05)\n    );\n    vec2  center = a.xy;\n    float zoom = a.z;\n    \n    //scale pixels accordingly\n    vec2 sp = (fragCoord*2.-iResolution.xy)/iResolution.y*zoom+center;  \n\t\n    fragColor = vec4(gridlines(sp,3./iResolution.y,zoom));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GRID_DEPTH 3.\n\n//Pans from b to e where t=0 is at b and t=1 is at e\nvec2 Pan(vec2 b, vec2 e, float t){\n    return b+(e-b)*t;\n}\n\n//Zooms from zb to ze where t=0 is zb and t=1 is ze\nfloat Zoom(float zb, float ze, float t){\n    return zb*pow(ze/zb,t);\n}\n\n//Pans and Zooms at the same time\nvec3 PanZoom(vec2 b, float zb, vec2 e, float ze, float t){\n    float z = Zoom(zb,ze,t);\n    return vec3(\n        Pan(b,e,(zb-z)/(zb-ze)),\n        z                       \n    );\n}\n\n//Makes gridlines of width e at point p and zoom z\nfloat gridlines(vec2 p, float e, float z){\n    //initiliaze color to black.\n    float col = 0.;\n    \n    //we must first take the log2 of our current zoom level to aquire\n    //the amount of times we have zoomed in 2x.\n    float  lz =  log2(z);\n    \n    //our gridlines are integer powers of 2 so we floor lz.\n    //the minus makes it such that we can multiply rather than divide \n    //later on in the code, after we have exponentiated, which is faster.\n    float clz = -ceil(lz);\n    \n    //when we take the fractional part of lz we get a measure of how close\n    //we where to the next integer power of 2.\n    float rlz =  fract(-lz);\n    \n    //fz is now an integer power of 2 nearest to 1./zoom.\n    float fz  =  pow(2.,clz);\n    \n    //w is the width of the gridlines calculated such\n    //that they are always visible on every zoom level\n    float w = e*z;\n\n    for(float d=0.;d<=GRID_DEPTH;d++){\n        //first and last layer should fade in and out\n        float fade = d==0. ? (1.-rlz) : d==GRID_DEPTH ? rlz : 1.;\n        \n        //horizontal and vertical distance to current gridlines\n        vec2 m = abs(fract(p*fz-.5)-.5)/fz; \n        \n        //and the final coloring\n    \tcol += smoothstep(w,w*.25,min(m.x,m.y))/GRID_DEPTH*fade;\n        \n        //make the grid finer for the next iteration\n        fz *= 2.;\n    }\n\n    return col;\n}\n","name":"Common","description":"","type":"common"}]}