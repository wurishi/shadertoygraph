{"ver":"0.1","info":{"id":"WtGfRK","date":"1614630914","viewed":198,"name":"Lightroom","username":"josemorval","description":"Single pass GI with fractal-like thing","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nvec3 randomsphere(float seed){float a = 2.*3.1415*hash(seed);float b = 3.1415*hash(11.3*seed+0.4);return vec3(cos(a)*cos(b),sin(b),sin(a)*cos(b));}\n\n\n#define sph(p,s) length(p)-s\n#define box(p,s) max(max(abs(p.x)-s.x,abs(p.y)-s.y),abs(p.z)-s.z)\nfloat mat;\nfloat map(vec3 p){\n    float d = 1000.;\n    float s = 0.;\n    mat = 0.;\n    \n\n    vec3 q = p;\n    float angle=1.*time;\n    mat2 rot = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n    for(int i=0;i<5;i++){\n        q=abs(q)-0.1*float(i);\n        q.xy*=rot;\n        q.yz*=rot;\n        \n    }\n    d = abs(box(q,0.1*vec3(1.)))-0.2;    \n    d = mix(sph(p,1.),d,1.-sin(3.14*fract(0.1*time)));\n    \n      \n    s=-box(p,vec3(6.));\n    if(s<d){\n        mat = 1.;\n        d=s; \n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e=0.01*vec2(1.,-1.);\n    float m = map(p+e.xxx);\n    return normalize(vec3(m-map(p+e.yxx),m-map(p+e.xyx),m-map(p+e.xxy)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 ro,rd,fw,ri,up;float fov=0.8;\n\n    \n    vec3 accumcol = vec3(0.);\n    \n    const float num =50.;\n    \n    //render: raymarching with some bounces\n    for(float k=0.;k<num;k+=1.){\n    \n        col = vec3(0.);\n        ro=vec3(5.*cos(0.2*time),0.5,5.*sin(0.7*time));\n        fw=normalize(-ro); up = normalize(vec3(0.,1.,0.)); ri = cross(fw,up); up=cross(ri,fw);\n        rd = normalize(mat3(ri,up,fw)*vec3(uv,fov));\n        \n        \n        //raymarching part\n        for(float j=0.;j<4.;j+=1.){\n            float t = 0.;\n            float m = -1.;        \n            for(int i=0;i<32;i++){\n                float d = map(ro+rd*t);\n                if(abs(d)<0.001*t){\n                    m=mat;\n                    break;\n                }\n                t+=d;\n            }\n            \n            vec3 pos = ro+rd*t; vec3 n = normal(pos);\n            \n            float s=0.;\n            s += smoothstep(0.995,1.,sin(0.1*pos.y-floor(0.5*pos.x+0.*time)*floor(0.5*pos.z+1.3*floor(0.5*pos.y+2.*time))));\n            s += smoothstep(0.995,1.,sin(0.3*pos.x+floor(0.1*pos.y+time)*floor(0.01*pos.x+1.3*floor(0.5*pos.z+2.*time))));\n            \n            vec3 rdir = randomsphere(0.133*pos.x+0.31*pos.y+0.51*pos.z+5.11*float(j)+3.411*float(k+2.1)+0.1+time);\n            rd = normalize(mix(reflect(rd,n),rdir*sign(dot(rdir,n)),0.5+0.3*sin(0.3*pos.x+time)));\n            ro=pos+0.01*n;\n           \n           if((s>0. && m==1.) ||m==2.){        \n                col +=2.*vec3(0.5-0.1*pos.y,0.4,0.8-0.01*pos.x);\n                break;\n            }else{\n                col *= 0.;\n            }\n            \n        }\n        \n        accumcol+=col;\n    }\n    \n    col=accumcol/num;\n    \n    \n    \n    //some gamma correction\n    float gamma = 0.45;\n    col.r = pow(col.r,gamma);\n    col.g = pow(col.g,gamma);\n    col.b = pow(col.b,gamma);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}