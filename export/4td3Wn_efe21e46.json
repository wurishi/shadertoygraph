{"ver":"0.1","info":{"id":"4td3Wn","date":"1468750457","viewed":3049,"name":"fun with pareidolia ","username":"abznak","description":"This shader combines the previous frame with a frame from a video to give a Rorschach ink blot like effect.\n\nThe model's dark makeup mean the her eyes tend to appear in the resulting white blob, which makes faces appear.\n\n","likes":7,"published":3,"flags":40,"usePreview":0,"tags":["2d","face","buffer","rorschach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* the interesting code is all in Buf A */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //copy Buf A to the screen\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* \n * This shader combines the previous frame with a frame for a video to give a Rorschach \n * ink blot like effect.\n * \n * Specifically, it sums the 9 adjacent pixels with 9 copies of the pixel from the video.  \n * If the x channel of the result is more than 9 (i.e. the average colour is more than half) then\n * the resulting pixel is white.  Otherwise it is black.\n */\n\n// old color, reliative to current pixel\nvec4 oldColor(in vec2 fragCoord, in vec2 dxy) {    \n    return texture(iChannel0,  (fragCoord.xy + dxy) / iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // current coordinates, normalised 0..1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // just the use static texture for the first second.\n    const float start_time = 1.0;\n    if (iTime < start_time) {\n        fragColor = texture(iChannel1, uv);\n        return;\n    }\n \n    // sum the adjacent pixels (including the current pixel)\n    vec4 tot = vec4(0.0, 0.0, 0.0, 0.0);\n    for (float dx = -1.0; dx < 2.0; dx++) {\n        for (float dy = -1.0; dy < 2.0; dy++) {\n            tot += oldColor(fragCoord, vec2(dx, dy));                       \n        }\n    }\n    \n    // add in a pixel from the video, with the same total weight as the existing samples\n    tot += texture(iChannel2, uv) * vec4(9.0, 9.0, 9.0, 9.0);\n    \n\t// output white if x value is more than half of max\n    // I've done the calculations so far with all the channels, even though I only use x because\n    // I'm planning on doing something more interesting with the other channel's data in the future.\n    if (tot.x > 9.0) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp, float time )\n{\n    return vec2( 0 );\n}","name":"Sound","description":"","type":"sound"}]}