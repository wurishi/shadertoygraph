{"ver":"0.1","info":{"id":"fsScWR","date":"1643397012","viewed":68,"name":"Grid(y) Perfect Pistons 2","username":"panna_pudi","description":"See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","pistons"],"hasliked":0,"parentid":"3lcBD2","parentname":"Perfect Pistons Example 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork, all credits to Blackle Mori\n\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//In this example we extend the \"assume-the-worst\" trick to 2 dimensional domain repetition.\nconst float PI = acos(-1.);\nfloat piston(vec2 p, float width, float height) {\n    p.x = abs(p.x) - width;\n    p.y -= height;\n    return length(max(p,0.0)) + min(0.0, max(p.x,p.y));\n}\n\nfloat piston3D(vec3 p, float width, float height) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    return piston(p2, width, height);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    float height = .2; // sin(center.y + center.x+iTime)*2.;\n    float width = .3;\n    float piston = piston3D(p, width, height) - .03;\n    return piston;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 traverseGrid2D( vec2 ro, vec2 rd ) {\n    const float GRID_INTERVAL = 1.;\n\n    vec2 grid = floor( ( ro + rd * 1E-2 * GRID_INTERVAL ) / GRID_INTERVAL )\n                       * GRID_INTERVAL + 0.5 * GRID_INTERVAL;\n    \n    vec2 src = ( ro - grid ) / rd;\n    vec2 dst = abs( 0.5 * GRID_INTERVAL / rd );\n    vec2 bv = -src + dst;\n    float b = min( bv.x, bv.y );\n    \n    return vec3( grid, b );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 0, -7);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    float yrot = .5;\n    float zrot = iTime * .2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1. - 4. * mouse.y, -0., 3.14 / 2.);\n        zrot = 4. * mouse.x;\n    }\n    \n    rd = erot(rd,vec3(1,0,0),yrot);\n    ro = erot(ro,vec3(1,0,0),yrot);\n    rd = erot(rd,vec3(0,1,0),zrot);\n    ro = erot(ro,vec3(0,1,0),zrot);\n    ro.y += 1.;\n    \n    float rl = 0.0;\n    vec3 rp = ro + rd * rl;\n    float dist;\n    vec3 gridCenter;\n    float lenToNextGrid = 0.0;\n    vec2 normalizeRdXZ = normalize( rd.xz );\n    float gridLenMultiplier = 1.0 / length( rd.xz );\n\n    bool hit = false;\n    for (int i = 0; i < 200 && !hit; i++) {\n        if ( lenToNextGrid <= rl ) {\n            rl = lenToNextGrid;\n            rp = ro + rd * rl;\n\n            vec3 grid = traverseGrid2D( rp.xz, normalizeRdXZ );\n            gridCenter = vec3( grid.x, 0.0, grid.y );\n            gridCenter.y -= sin(gridCenter.x + gridCenter.z + iTime) * 2.;\n\n            lenToNextGrid += grid.z * gridLenMultiplier;\n        }\n        dist = scene(rp - gridCenter);\n        hit = dist*dist < 1e-6;\n        rl += dist;\n        rp += dist * rd;\n        if ( abs( dist ) < 1E-3 ) { break; }\n\n        if(distance(rp, ro)>50.)break;\n    }\n    vec3 n = norm(rp - gridCenter);\n    vec3 r = reflect(rd, n);\n    float col = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    col = col*.1 + pow(col, 6.); \n    fragColor = hit ? vec4(col) : vec4(0.03);\n    fragColor = sqrt(fragColor);\n}\n","name":"Image","description":"","type":"image"}]}