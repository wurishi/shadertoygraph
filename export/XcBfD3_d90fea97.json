{"ver":"0.1","info":{"id":"XcBfD3","date":"1725639659","viewed":97,"name":"eye-hurt torus","username":"ARCASHH","description":"My first attempt. It's just beautiful)\nthere are some problems with shadows and light.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","lightning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LIGHT_SOURCES 3\n#define MAX_SHADOWS_STEPS 100\n#define MAX_MARCHING_STEPS 80\n#define MARCH_STEP_COEF 0.6\n#define MIN_DIST 0.0\n#define MAX_DIST 6.\n\n#define PRECISION 0.001\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y \n      + 0.04 * sin(20.0*p.y + iTime )\n      + 0.08 * sin(10.0*p.x + iTime )\n      + 0.08 * sin(5.0*p.z + iTime * 2.);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\n// Rotation matrix around the axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Material\n{\n    vec3 color;\n    float k_ambient; //main color\n    float k_diffusion;\n    float k_specular;\n    float metal; // degree of spec\n    float reflex; // reflex coef\n};\n\nstruct Light\n{\n    vec3 color;\n    vec3 pos;\n};\n\n// operations\nvec2 Union( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\nvec2 smoothSubtraction ( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d1.x + d2.x) / k, 0.0, 1.0 );\n    return vec2(mix( d1.x, -d2.x, h ) + k * h * (1.0 - h), d1.y); \n}\nvec2 smoothUnion ( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5 * (d2.x - d1.x) / k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k * h * (1.0 - h), d2.y); \n}\n\n//scene\nvec2 map(vec3 p)\n{\n    mat3 rot = rotateX(iTime * 0.2)*rotateY(iTime * 0.1)*rotateZ(iTime * 0.1);\n    vec2 res = vec2( 1e2, 0.0 ); // second component - material id of object\n    \n    float m_id1 = 1., m_id2 = 2.;\n    float smooth_coef1 = .8, smooth_coef2 = .2;\n    \n    res = smoothUnion (res, vec2(sdPlane(p - vec3(0., 0., -1.1), vec3(0., 0., 1.), 0.), m_id1), smooth_coef1);\n    res = smoothUnion (res, vec2(sdPlane(p - vec3(0., -1.1, 0.), vec3(0., 1., 0.), 0.), m_id1), smooth_coef1);\n    res = smoothUnion (res, vec2(sdPlane(p - vec3(-1.1, 0., 0.), vec3(1., 0., 0.), 0.), m_id1), smooth_coef1);\n    \n    res = Union (res, vec2(sdTorus((p - vec3(0.2, 0.2, 0.2)) * rot, vec2(.5, .3)), m_id2));\n    res = smoothSubtraction(res, vec2(sdTorus(p - vec3(0.5, 0.5, 0.5), vec2(.5, .3)), m_id2 ), smooth_coef2);\n    \n    return res;\n}\n\nvec3 generateNormal ( vec3 p)\n{\n    float e = PRECISION;\n    float dx = map(p + vec3(e, 0, 0)).x - map(p - vec3(e, 0, 0)).x;\n    float dy = map(p + vec3(0, e, 0)).x - map(p - vec3(0, e, 0)).x;\n    float dz = map(p + vec3(0, 0, e)).x - map(p - vec3(0, 0, e)).x;   \n    return normalize ( vec3 ( dx, dy, dz ) );\n}\n\nvec2 rayMarch( vec3 ro,  vec3 rd) {\n  vec2 depth = vec2(MIN_DIST, 0.);\n  vec2 d = vec2(0.);\n  for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n    vec3 p = ro + depth.x * rd;\n    d = map(p);\n    depth.x += d.x * MARCH_STEP_COEF;\n    if (d.x < PRECISION || depth.x > MAX_DIST) \n        break;\n  }\n  depth.y = d.y;\n  return depth;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float w)\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i = 0; i < MAX_SHADOWS_STEPS && t < MAX_DIST; ++i )\n    {\n        float h = map(ro + t * rd).x;\n        if( h < PRECISION )\n            return 0.0;\n        res = min( res, h / (t * w) );\n        t += clamp(h, 0.01, 0.2);\n    }\n    return res;\n}\n\nvec3 getColor(vec2 res, vec3 p, vec3 ro, vec3 b_color, Light lightArray[NUM_LIGHT_SOURCES])\n{\n    Material m;\n    if (res.y < 2.)\n       m = Material(b_color, .7, .3, 0., 0., 0.);\n    else\n       m = Material(vec3(1., 1., 1.), .1, .2, .6, 60.,  .4);\n    \n    vec3 diffusion_color = vec3(0.);\n    vec3 specular_color = vec3(0.);\n    \n    vec3 normal = generateNormal(p);\n    \n    for(int i = 0; i < lightArray.length(); ++i){\n        vec3 lightDirection = normalize(lightArray[i].pos - p);\n        vec3  h  = normalize ( lightDirection + normalize( ro - p ) );\n\n        float softShadow = softShadow(p, lightDirection, .01, .03);\n        \n        float diffusion = clamp(dot(normal, lightDirection), 0., 1.) * softShadow;\n        float specular = pow(max( 0., dot(h, normal)), m.metal) * softShadow;\n        \n        diffusion_color += diffusion * lightArray[i].color;\n        specular_color += specular * lightArray[i].color;\n    }\n\n    float reflex = m.reflex * (1. - dot(normal, normalize(ro - p)));\n    \n    return m.k_ambient * m.color + //main color\n        m.k_diffusion * diffusion_color  + //diffusion\n        m.k_specular * specular_color + // phong\n        reflex * b_color; // reflex from the background\n}\n\n\nvec3 render( vec3 rd, vec3 ro)\n{\n    Light lightArray[NUM_LIGHT_SOURCES] = Light[NUM_LIGHT_SOURCES](\n        Light( vec3(0.3, .9, 0.2), vec3(0., 5., 0.) ),\n        Light( vec3(0.2, 0.2, 1.), vec3(0., 0., 5.) ),\n        Light( vec3(1.0, 0.2, 0.2), vec3(5., 0., 0.) )\n        );\n        \n    vec3 col = vec3(1., .8, 0.3); // background color\n    \n    vec2 res = rayMarch(ro, rd); \n    if (res.x < MAX_DIST) // if hit\n    {\n        vec3 p = (ro + rd * res.x);\n        col = getColor(res, p, ro, col, lightArray);\n    }\n    return col;\n}\n\nmat3 camera(vec3 cameraPos) {\n    vec3 cd = normalize(- cameraPos); \n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); \n    vec3 cu = normalize(cross(cd, cr)); \n    return mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;  \n    vec3 ro = vec3(0., 0., 2.5); //camera position\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    ro = ro * rotateX(2.5) * rotateY(0.9);\n    ro = ro * rotateX(mix(1.7, 0.3, mouse.y)) * rotateY(mix(2.7, 3.8, mouse.x ));\n    vec3 rd = camera(ro) * normalize(vec3(uv, -1));\n    \n    vec3 color = render(rd, ro);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}