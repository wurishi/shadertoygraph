{"ver":"0.1","info":{"id":"4ctSzX","date":"1714249726","viewed":61,"name":"Generative landscape","username":"tytr","description":"Still needs a lot of work, but I enjoyed this one!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["landscape","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nvec3 SKY_COLOR = vec3(0.6, 0.8, 0.9);\nvec3 NIGHT_SKY_COLOR = vec3(0.161, 0.071, 0.4);\nvec3 MOUNTAIN_COLOR = vec3(0.6, 0.3, 0.0);\nvec3 SUN_COLOR = vec3(1.0, 0.8, 0.0);\nvec3 MOON_COLOR = vec3(0.9, 0.9, 1.0);\nvec3 GROUND_COLOR = vec3(0.0, 0.7, 0.4);\nvec3 TREE_COLOR = vec3(0.4, 0.267, 0.188);\nvec3 TREETOP_COLOR = vec3(0.3, 0.8, 0.3);\nvec3 CLOUD_COLOR = vec3(1.0);\nvec3 STAR_COLOR = vec3(1.0);\nvec3 BLACK = vec3(0.0);\n\nfloat SUN_TIME_FACTOR = 0.3;\nfloat SUN_HEIGHT_FACTOR = 1.2;\nfloat SUN_HEIGHT_OFFSET = 0.2;\nfloat SUN_WIDTH_FACTOR = 1.5;\nfloat SUN_RADIUS = 0.2;\nfloat SKY_INTERP_FACTOR = 1.0;\nfloat SUN_TEXTURE_SCALE = 3000.0;\nfloat LIGHT_FACTOR_INFLUENCE = 0.001;\nfloat MAX_LIGHT_DIFF = 0.1;\n\nfloat MOUNTAIN_BASE_HEIGHT = -0.8;\nfloat MOUNTAIN_HEIGHT_SCALE = 0.834;\nfloat MOUNTAIN_WIDTH_SCALE = 4.123879;\nfloat MOUNTAIN_SHARPNESS = 0.891739;\nfloat MOUNTAIN_TEXTURE_SCALE = 250.0;\nfloat MOUNTAIN_OFFSET = 2.123487;\n\nfloat GROUND_HEIGHT = -0.89;\n\nfloat TREE_SPARSENESS = 0.7;\nfloat TREE_WIDTH = 0.04;\nfloat TREETOP_WIDTH = 0.04;\n\nvec2 CLOUD_SCALE = vec2(2.0, 2.0);\nfloat CLOUD_TIME_FACTOR = 0.1;\nfloat CLOUD_CHANGE_TIME_SCALE = 0.01;\n\n// Util\nfloat snapValue(float value, float width) {\n    float scaled = (value + 1.0) / width;\n    float floored = floor(scaled);\n    return floored * width - 1.0;\n}\n\n// Randomness & Noise\nfloat random(float x) {\n    return fract(sin(x * 78.233) * 43758.5453);\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermite curve.  Same as smoothstep()\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // Mix 4 corners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// Fractal noise function for smoother cloud patterns\nfloat fractalNoise(vec2 st) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 2.0;\n    for (int i = 0; i < 8; i++) {\n        value += amplitude * noise(st + iTime * CLOUD_CHANGE_TIME_SCALE);\n        st *= frequency;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Shaping Functions\nbool isPointInCircle(vec2 point, vec2 center, float radius) {\n    float dist = dot(point - center, point - center);\n    return dist <= (radius * radius);\n}\n\n// Landscape checks\n\n// Function to apply texture effect using noise\nvec3 applyTexture(vec3 baseColor, vec2 position, float scale) {\n    float n = noise(position * scale);\n    return baseColor * (0.7 + 0.1 * n); // Modulate the base color with noise\n}\n\nvec3 applyMountainTexture(vec2 pos) {\n    return applyTexture(MOUNTAIN_COLOR, pos, MOUNTAIN_TEXTURE_SCALE);\n}\n\nvec3 applyGroundTexture(vec2 pos) {\n    return applyTexture(GROUND_COLOR, pos, MOUNTAIN_TEXTURE_SCALE);\n}\n\nvec3 applySunTexture(vec2 pos) {\n    return SUN_COLOR;\n    //return applyTexture(SUN_COLOR, pos, SUN_TEXTURE_SCALE);\n}\n\nbool isInMountains(vec2 uv) {\n    float x = uv.x + MOUNTAIN_OFFSET;\n    // Use a low-frequency sine wave to modulate the frequency of the main sine wave\n    float modulator = sin(sin(x * MOUNTAIN_WIDTH_SCALE));  // Varies between 1.0 and 2.0\n    float sineValue = cos(sin(x * modulator));\n    float peaks = pow(abs(sineValue), sineValue * MOUNTAIN_SHARPNESS); // 6.28 approximates 2*PI\n\n    // Smooth the transition of peaks using a smoothstep\n    //float mountainHeight = smoothstep(MOUNTAIN_BASE_HEIGHT, MOUNTAIN_BASE_HEIGHT + peaks, peaks);\n    float mountainHeight = MOUNTAIN_BASE_HEIGHT + MOUNTAIN_HEIGHT_SCALE * peaks;\n\n    // Check if uv.y is below the mountainHeight\n    return uv.y < mountainHeight;\n}\n\nvec2 getSunPos() {\n    float sunTime = iTime * SUN_TIME_FACTOR;\n    return vec2(-cos(sunTime) * SUN_WIDTH_FACTOR, sin(sunTime) * SUN_HEIGHT_FACTOR - SUN_HEIGHT_OFFSET);\n}\n\nvec2 getMoonPos() {\n    vec2 sunPos = getSunPos();\n    return sunPos * -1.0;\n}\n\nfloat getLightFactor() {\n    vec2 sunPos = getSunPos();\n    return clamp((sunPos.y + 1.0) / 2.0, 0.0, 1.0);\n}\n\nvec3 getSkyColor() {\n    float factor = getLightFactor();\n    return mix(NIGHT_SKY_COLOR, SKY_COLOR, pow(factor, SKY_INTERP_FACTOR));\n}\n\nbool isNight() {\n    vec2 sunPos = getSunPos();\n    return sunPos.y < 0.0;\n}\n\nbool isInSun(vec2 uv) {\n    vec2 sunPos = getSunPos();\n    return isPointInCircle(uv, sunPos, SUN_RADIUS);\n}\n\nbool isInMoon(vec2 uv) {\n    vec2 moonPos = getMoonPos();\n    moonPos.y -= 0.5;\n    return isPointInCircle(uv, moonPos, SUN_RADIUS);\n}\n\nbool isStar(vec2 uv) {\n    float starProbability = random(random(uv));\n    return starProbability > 0.995;\n}\n\nbool isOnGround(vec2 uv) {\n    return uv.y < GROUND_HEIGHT;\n}\n\nbool isTreeWidth(vec2 uv, float width) {\n    float map = snapValue(uv.x, width);\n    return random(map) > TREE_SPARSENESS;\n}\n\nbool isTreetop(vec2 uv) {\n    bool treeWidth = isTreeWidth(uv, TREE_WIDTH);\n    bool treetopWidth = treeWidth || isTreeWidth(uv, TREETOP_WIDTH);\n    return treetopWidth && uv.y > -0.84 && uv.y < -0.8;\n}\n\n\nbool isTree(vec2 uv) {\n    bool treeWidth = isTreeWidth(uv, TREE_WIDTH);\n    return treeWidth && uv.y > -0.93 && uv.y < -0.8;\n}\n\n//bool isCloud(vec2 uv) {\n  //  float clouds = fractalNoise(uv * CLOUD_SCALE);\n    //clouds = smoothstep(0.5, 0.8, clouds);\n//}\n\n// Shader!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalize uv coord\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    bool sun = isInSun(uv);\n    bool moon = isInMoon(uv);\n    bool star = isStar(uv);\n    bool mountain = isInMountains(uv);\n    bool ground = isOnGround(uv);\n    bool tree = isTree(uv);\n    bool treetop = isTreetop(uv);\n    bool night = isNight();\n    \n    float lightFactor = getLightFactor();\n    float flipped = 1.0 / lightFactor;\n    float diff = flipped * LIGHT_FACTOR_INFLUENCE;\n    float clampedLightDiff = clamp(diff, 0.0, MAX_LIGHT_DIFF);\n    \n    float xCloudOffset = iTime * CLOUD_TIME_FACTOR;\n    vec2 cloudUV = vec2(uv.x - xCloudOffset, uv.y);\n    vec2 noiseValue = cloudUV * CLOUD_SCALE;\n    float clouds = fractalNoise(noiseValue);\n    clouds = smoothstep(0.5, 0.8, clouds);\n    \n    if (treetop) {\n        fragColor = vec4(TREETOP_COLOR, 1.0);\n    }\n    else if (tree) {\n        fragColor = vec4(TREE_COLOR, 1.0);\n    }\n    else if (ground) {\n        vec3 groundColor = applyGroundTexture(uv);\n        fragColor = vec4(groundColor - clampedLightDiff, 1.0);\n    }\n    else if (mountain) {\n        vec3 mountainColor = applyMountainTexture(uv);\n        fragColor = vec4(mountainColor - clampedLightDiff, 1.0);\n    }\n    else if (sun) {\n        vec3 sunColor = applySunTexture(uv);\n        fragColor = vec4(sunColor, 1.0);\n    }\n    else if (moon) {\n        fragColor = vec4(MOON_COLOR, 1.0);\n    }\n    else if (star) {\n        vec3 starColor = mix(STAR_COLOR, SKY_COLOR, lightFactor);\n        fragColor = vec4(starColor, 1.0);\n    }\n    else {\n        vec3 skyColor = getSkyColor();\n        vec3 mixed = mix(skyColor, CLOUD_COLOR, clouds);\n        fragColor = vec4(mixed, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}