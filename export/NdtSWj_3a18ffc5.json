{"ver":"0.1","info":{"id":"NdtSWj","date":"1633987832","viewed":203,"name":"Raytracing CSG","username":"kastorp","description":"https://en.wikipedia.org/wiki/Constructive_solid_geometry\nsuperfast with angle, slow with opengl","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["raytracing","csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raytracing CSG  by Kastorp\n//------------------------------------------------------\n// CSG is easy with SDF, but harder with Ray Tracing,\n// especially with subtraction and with cascade operations\n// This is my tentative, I'm satisfied with the result,\n// performances are very good, compilation time is acceptable.\n// There were issues with arrays in angle, which I solved with manual \n// array lookup. \n// Don't know if it is compatible with all GPUs.\n//-------------------------------------------------------\n\n//motion blur https://www.shadertoy.com/view/wt3fDH\n//#define iTime ( iTime + fract(1e4*sin(dot(gl_FragCoord.xy,vec2(137,-13))))* iTimeDelta )\n\nvoid trace(vec3 rd,vec3 ro ,out RayOut oRay) { \n    RayIn m0=RayIn(rd);\n    RayOut r =  Ray(getObj(iPlane(ro,m0.rd,vec3(0,1.,0),0.),1.));\n#if 1    \n    obj s3= getObj(iBox(ro-vec3(3.,1.,0.),m0.rd,vec3(1.2,1.,1.2)),2.);\n    obj s4= getObj(iSphere(ro-vec3(3.,1. ,0.),m0.rd,1.4),3.);\n    obj s= Sub(s3,s4);\n    Add(r,Ray(s)); \n    \n    \n    obj s1= getObj(iBox(ro-vec3(0.,1.5,0.),m0.rd,vec3(1.2,1.5,1.2)),2.);\n    obj s2= getObj(iBox(ro-vec3(0.,2.1 ,0.),m0.rd,vec3(1.)),3.);    \n    s=Sub(s1,s2);\n    obj s2b= getObj(iBox(ro-vec3(0.,2.1 ,0.),m0.rd,vec3(2.,.5,.5)),3.);\n    s= Sub(s,s2b);   \n    Add(r,Ray(s));        \n    \n    \n    obj s5= getObj(iBox(ro-vec3(-3.,1.,0.),m0.rd,vec3(1.2,1.,1.2)),2.);\n    obj s6= getObj(iSphere(ro-vec3(-3.,1. ,0.),m0.rd,1.4),3.);\n    s= Inter(s5,s6);\n    Add(r,Ray(s)); \n\n    RayOut rr;\n    RotGroup(ro, m0, rr, vec3(0,1,0), vec3(0.,0,0.) ,iTime*4.,\n     obj s7= getObj(iCylinder( ro, m0.rd, vec3(-2.,3.4,2) , vec3(2.,3.4,-2), .2 ),4.);\n     obj s8= getObj(iCylinder( ro, m0.rd, vec3(2.,3.4,2) , vec3(-2,3.4,-2), .2 ),4.);\n     obj s9= getObj(iCylinder( ro, m0.rd, vec3(0.,0,0) , vec3(0,3.4,0), .2 ),4.);\n     obj s10=getObj(iSphere(ro-vec3(0.,3.4 ,0.),m0.rd,.3),4.);\n     rr=FastUnion(FastUnion(Ray(s9),Ray(s10)),FastUnion(Ray(s7),Ray(s8)));\n     \n    );\n    Add(r,rr); \n#else\n    obj s3= getObj(iSphere(ro-vec3(0.,2.,0.),m0.rd,2.2),2.);\n    for(float h=-1.5;h<2.;h+=.5){\n        obj s4= getObj(iBox(ro-vec3(0.,2.+h,0.),m0.rd,vec3(3.,.1,3.)),3.);\n        s3= Sub(s3,s4);\n    }\n    for(float h=-1.5;h<2.;h+=.5){\n        obj s4= getObj(iBox(ro-vec3(h,2.,0.),m0.rd,vec3(.1,3.,3.)),3.);\n        s3= Sub(s3,s4);\n    }\n    \n    for(float h=-1.5;h<2.;h+=.5){\n        obj s4= getObj(iBox(ro-vec3(0,2.,h),m0.rd,vec3(3.,3.,.1)),3.);\n        s3= Sub(s3,s4);\n    }\n    Add(r,Ray(s3)); \n    \n#endif    \n\n     \n    oRay=r;\n}\n\nvec3[4] mat = vec3[4](vec3(0.2,0.4,0.1), //terrain\n                     vec3(0.9,0.4,0.4), // pink\n                      vec3(0.2,0.3,0.6), //blue\n                      vec3(0.7,0.5,0.0)); // yellow\n\n//------------------------------------\n\nvec3 lights(vec3 p, vec3 rd, float d, vec3 n) {\n    vec3 lightDir = normalize( vec3(8.,19.,18.) );\n\tvec3 ld = normalize(lightDir*16.5 - p);\n\n\tfloat ao = 1.,\n\tl1 = max(0., .5 + .5 * dot(ld, n)),\n\t\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n   \n    vec3 pp=p+.002*n; \n    RayOut rRay;\n    trace( ld, pp,rRay);\n\tl1 *=    smoothstep(.001,500.,  rRay.d  );\n         \n\tvec3 lig = ((l1 *.9+.1)* ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n    vec2 m= iMouse.x>0.? +iMouse.xy/iResolution.xy:.5* vec2(iResolution.xy/iResolution.y) +vec2(iTime*.2,-.2);\n    float t= -.6+m.x*3.14;\n\tvec3 ro =2.*vec3(3.*cos(t), 1.+6.*m.y, 3.*sin(t));\n\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd =  getRayDir(ro, vec3(0,1,0), uv);\n        \n    RayOut oRay;\n    trace(rd, ro,oRay);\n      \n    vec3 p=ro+rd*oRay.d; \n    vec3 alb=mat[int(oRay.id)-1];\n    vec2 uvt= fract(oRay.fuv.yz)-.5;\n    if(uvt.x*uvt.y<0.)alb*=.75;\n    //if(oRay.id>=2. && oRay.fuv.x==5.) alb*=0.; //debug face id\n    \n    vec3 col=lights(p, rd, oRay.d,oRay.n) * exp(-oRay.d * .085)*alb;\n    \n\tfragColor = vec4(pow(col, vec3(.5)), oRay.d);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define MAXN 3 //maximum number of intervals \n#define NOHIT 1e5\n#define REPLACE  // replace the farthest interval when intervals >MAXN\n#define ANGLE //enable this if using Angle, disable with opengl\n\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\tvec3 fuv;  //face & uv \n};\n\nconst its  NO_its=its(NOHIT,vec3(0.),vec3(0.));\nstruct span\n{\n\tits n;\n\tits f;\n    float mat;\n\tbool merged;\n};\n\nstruct obj\n{\n\tint l; \n\tspan[MAXN] s;\n};\n\n\nvoid init(inout obj y){\n\ty.l=0;\n}\n\nits getIx(inout obj y,inout float mat){\n\n    float tMin=1e5;\n    int idm=-1;\n    for(int i=0;i<y.l;i++) if(y.s[i].n.t<tMin && y.s[i].f.t>0.001 ) {idm=i;tMin=y.s[i].n.t;}\n    if(idm>=0) {mat=y.s[idm].mat;  return y.s[idm].n;}\n    return NO_its;\n\n}\n\nvoid add(inout obj y,  span x){\n \n //st_assert(y.l<MAXN,0);\n#ifdef REPLACE\n    int id=y.l++;   \n    if(id>=MAXN) {       \n        //replace:\n        float tMax=-1e5;\n        id=10;\n        int idm;\n        for(int i=0;i<MAXN;i++) if(y.s[i].n.t>tMax) {idm=i;tMax=y.s[i].n.t;}\n        if(tMax>x.n.t) { id=idm;}\n        y.l--;        \n    } \n#else \n\n    \n    if(y.l>=MAXN) return;\n    int id=y.l++; \n#endif\n\n#ifdef ANGLE\n    for (int j=0;j<MAXN;j++) if(id==j) y.s[j]=x;\n    \n#else\n    y.s[id]=x;\n#endif\n}\n\nbool seq(inout its a1, inout its a2, inout its a3,inout its a4)\n{\n    return a1.t<a2.t && a2.t<a3.t && a3.t<a4.t;\n}\nbool seq(inout its a1,inout its a2)\n{\n    return a1.t<a2.t ;\n}\nobj getObj( span x,float mat){\n    obj s;s.l=0; x.mat=mat; add(s,x);\n    return s;\n}\n\n\nbool no_hit(span x) {return x.n.t==NOHIT;}\n//-------------------------------\n//UNION A+B:\nvoid addMerge(inout obj cs,  span y,bool reduce){\n    if(reduce){\n        if(y.merged) return;\n        for(int j=0;j<cs.l;j++)\n        {           \n            span x=cs.s[j];\n            if(x.merged) continue;\n            else if(seq(x.f,y.n)|| seq(y.f,x.n )) continue;\n            else if(seq(x.n,y.n,x.f,y.f)) {cs.s[j].merged=true; y=span(x.n,y.f,x.mat,false);}\n            else if(seq(y.n,x.n,y.f,x.f)) {cs.s[j].merged=true; y=span(y.n,x.f,y.mat,false);}\n            else if(seq(x.n,y.n,y.f,x.f)) {cs.s[j].merged=true; y=span(x.n,x.f,x.mat,false);}\n            else if(seq(y.n,x.n,x.f,y.f)) {cs.s[j].merged=true; y=span(y.n,y.f,y.mat,false); }\n        }\n    }\n    add(cs,y);    \n}\n\nobj Union(obj as, obj bs,bool reduce){   \n    obj cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) addMerge(cs,as.s[i],reduce);\n    for(int i=0;i<bs.l;i++) addMerge(cs,bs.s[i],reduce);\n\n    if(!reduce) return cs;    \n    //ds=REDUCE(cs)\n    obj ds;\n    init(ds);\n    for(int i=0;i<cs.l;i++) if(!cs.s[i].merged) add(ds,cs.s[i]);\n    return ds;\n}\n\n \n\n//-------------------------------\n//INTERSECTION A*B:\nobj Inter(obj as, obj bs){ \n    obj cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) {\n        span a=as.s[i];\n        if(no_hit(a)) continue;\n        for(int j=0;j<bs.l;j++) {\n            span b=bs.s[j];\n            if(no_hit(b)) continue;\n            else if(seq( a.f,b.n)|| seq(b.f,a.n )) continue;\n            else if(seq(a.n,b.n,a.f,b.f)) add(cs,span(b.n,a.f,b.mat,false));\n            else if(seq(b.n,a.n,b.f,a.f)) add(cs,span(a.n,b.f,a.mat,false));\n            else if(seq(a.n,b.n,b.f,a.f)) add(cs,b);\n            else if(seq(b.n,a.n,a.f,b.f)) add(cs,a);\t\t\n        }\n    }\n    return cs;\n}\n//-----------------------------\n//SUBTRACTION A-B:\nobj Sub(obj as, span b){\n    obj cs;\n    init(cs);\n     for(int j=0;j<as.l;j++) {\n        span a=as.s[j];\n        if(no_hit(a)) continue;\n        if(seq( a.f,b.n)) add(cs,a);\n        else if(seq(b.f,a.n )) add(cs,a);\n        else if(seq(a.n,b.n,a.f,b.f)) add(cs,span(a.n,b.n,a.mat,false)); \n        else if(seq(b.n,a.n,b.f,a.f)) add(cs,span(b.f,a.f,b.mat,false)); \n        else if(seq(a.n,b.n,b.f,a.f)) {add(cs,span(a.n,b.n,a.mat,false)); add(cs,span(b.f,a.f,b.mat,false)); }\n        else if(seq(b.n,a.n,a.f,b.f)) continue;\t\n    }\n    return cs;\n}\n\nobj Sub(obj as, obj bs){ \n    for(int i=0;i<bs.l;i++) {\n        span b=bs.s[i];        \n        if(!no_hit(b)) as=Sub( as,  b);        \n    }\n    return as;\n}\n\n//----------------------------\n\n#define ZERO min(iFrame, 0)\n#define time iTime*2.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\n//-----------Interscetion functions--------------------\nspan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return span(NO_its,NO_its,0.,true); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 oFuv=vec3(0.,atan(oNor.y,length(oNor.xz)),atan(oNor.z,oNor.x))*ra*1.5708  ;\n    vec3 fNor= normalize(ro-(b-h)*rd); \n    vec3 fFuv=vec3(0.,atan(fNor.y,length(fNor.xz)),atan(fNor.z,fNor.x))*ra*1.5708  ;\n    if( h-b < 0. ) return  span(NO_its,NO_its,0.,true);\n    return span(its(-b-h,oNor,oFuv) , its(-b+h,-fNor,fFuv),0.,false);\n}\n\nspan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return span(NO_its,NO_its,0.,true); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    vec3 oFuv=vec3( dot(abs(oNor),vec3(1,5,9)+ oNor)/2.,dot(ro+rd*tN,oNor.zxy),dot(ro+rd*tN,oNor.yzx));      \n    vec3  fNor=- sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    vec3 fFuv=vec3( dot(abs(fNor),vec3(1,5,9)+ fNor)/2.,dot(ro+rd*tF,fNor.zxy),dot(ro+rd*tF,fNor.yzx));\n    return  span(its(tN,oNor,oFuv) , its(tF,fNor,fFuv),0.,false);\n}\n\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d= -(dot(ro,n)+h)/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oFuv=vec3(1.,dot(ro+d*rd,u), dot(ro+d*rd,v));\n    vec3 oNor=n;\n    if(d<0.)  return span(NO_its,NO_its,0.,true);\n    return span(its(d,oNor,oFuv),NO_its,0.,false);\n}\n\nspan iCylinder( in vec3 ro, in vec3 rd,  in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, \n{\n    span no_hit =  span(NO_its,NO_its,0.,true);;\n\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 )  return no_hit;\n    h = sqrt(h);\n    \n    float t = (-k1-h)/k2;\n    float y = baoc + t*bard; \n    float t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;   \n    \n    if( (y<0.0 || y>baba )  && abs(k1+k2*t2)>h)  return no_hit;\n    its iN,iF;\n    vec3 w = normalize(ba), u = normalize(cross(ba,vec3(0,0,1))), v = normalize(cross(u,w) );\n    \n    //entry point\n    vec3 q = (oc+t*rd-ba)*mat3(u,v,w);   \n    if( y>0.0 && y<baba ) iN= its( t, (oc+t*rd - ba*y/baba)/ra,vec3(0.,atan(q.y,q.x)*ra,q.z) ); \n    else iN= its(t2, ba*sign(y)/baba ,vec3(1.,dot(oc+t2*rd-ba,u) ,dot(oc+t2*rd-ba,v) )); \n        \n  \n    //exit point\n    t = (-k1+ h)/k2;\n    y = baoc + t*bard; \n    t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    q = (oc+t*rd-ba)*mat3(u,v,w); \n    if( y>0.0 && y<baba ) iF= its( t, (oc+t*rd - ba*y/baba)/ra,vec3(0.,atan(q.y,q.x)*ra,q.z) ); \n    else iF= its(t2, ba*sign(y)/baba ,vec3(1.,dot(oc+t2*rd-ba,u) ,dot(oc+t2*rd-ba,v) )); \n    \n    return span(iN , iF ,0.,false);\n  \n}\n\n//---------mixed functions--------------------------\nstruct RayIn{\n    vec3 rd; \n};\n\nstruct RayOut{   \n    float d;\n    vec3 n;\n    vec3 fuv;\n    float id;\n};\n\n\nRayOut FastUnion( RayOut a, RayOut b)\n{\n   if(a.d<b.d) return a;\n   else return b;\n}\n#define Add(_ro,_func) _ro = FastUnion(_ro,_func);\n\n#define  RotGroup( _p, _ri,_ro, _ax,  _c ,  _a,  _body) \\\n     vec3 _rd= _ri.rd; \\\n    _p=erot( _p , _ax, _a); \\\n    _ri.rd=  normalize(erot( _ri.rd , _ax, _a)); \\\n    _body \\\n    _ro.n=  normalize(erot( _ro.n , _ax, -_a)); \\\n\n\n//------------------------------------\nRayOut Ray(obj s){\n    float mat;\n    its ix = getIx(s,mat);\n    return RayOut( ix.t,ix.n,ix.fuv,mat);\n}","name":"Common","description":"","type":"common"}]}