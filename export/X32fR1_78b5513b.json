{"ver":"0.1","info":{"id":"X32fR1","date":"1729202521","viewed":127,"name":"Hyperchromatic Neon Pulse","username":"nilberlin","description":"This digital synesthesia experience transforms sound into a visual feast of vibrant, ever-shifting colors. ","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["neonwaveshyperchromaticartshaderartdigitalsynesthesia96bpmgenerativeartglowingabstractvisualmusic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hyperchromatic Neon Pulse Shader mit spezifischen Neonfarben\n#define PI 3.14159265359\n\n// Spezifische Neonfarben-Palette\nvec3 neonColors[7] = vec3[7](\n    vec3(1.0, 0.431, 0.780),  // Neon Pink\n    vec3(0.224, 1.0, 0.078),  // Neon Green\n    vec3(1.0, 1.0, 0.2),      // Neon Yellow\n    vec3(1.0, 0.373, 0.122),  // Neon Orange\n    vec3(0.122, 0.318, 1.0),  // Neon Blue\n    vec3(0.690, 0.149, 1.0),  // Neon Purple\n    vec3(1.0, 0.027, 0.227)   // Neon Red\n);\n\n// Funktion zum Mischen von Neonfarben\nvec3 mixNeonColors(float t) {\n    float scaledT = t * float(neonColors.length());\n    int index = int(floor(scaledT));\n    float fraction = fract(scaledT);\n    vec3 color1 = neonColors[index % neonColors.length()];\n    vec3 color2 = neonColors[(index + 1) % neonColors.length()];\n    return mix(color1, color2, fraction);\n}\n\n// Welleneffekt\nfloat wave(vec2 uv, float time) {\n    return sin(uv.x * 10.0 + time) * cos(uv.y * 8.0 + time * 0.9) * 0.25 +\n           sin(uv.y * 12.0 - time * 1.2) * cos(uv.x * 9.0 - time * 1.1) * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // 96 BPM Timing\n    float bpm = 100.0;\n    float beatsPerSecond = bpm / 60.0;\n    float time = iTime * beatsPerSecond;\n    \n    // Verbesserter Welleneffekt\n    float waveEffect = wave(uv, time);\n    \n    // Dynamischer Farb체bergang mit spezifischen Neonfarben\n    float colorIndex = (uv.x + uv.y + waveEffect + time) * 0.2;\n    vec3 color = mixNeonColors(fract(colorIndex));\n    \n    // Helligkeit basierend auf der Welle\n    float brightness = 0.8 + waveEffect * 1.2;\n    color *= brightness;\n    \n    // Verst채rkter Gl체heffekt\n    float glow = 0.08 / length(uv);\n    color += glow * mixNeonColors(fract(time * 0.15));\n    \n    // Gamma-Korrektur f체r besseren Neon-Look\n    color = pow(color, vec3(0.6));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}