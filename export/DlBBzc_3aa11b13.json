{"ver":"0.1","info":{"id":"DlBBzc","date":"1694286741","viewed":88,"name":"genn yarn art","username":"chenxianming","description":"it's 2way addSegment for ribbon / wind curve effects calc in cpu.\none of random next position and calculated the offset, the algorithm i'v somewhere seens.\ndemo file\nhttp://benchart.cn/ribbon/ribbon.html","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nit's 2 way addSeg for ribbon / wind curve effects calc in cpu.\none of random next position and calculated the offset, the algorithm i'v somewhere seens.\nother way is concated some quadratic bezier curves, p3 was random point, \np2 was related b1 points.\n\neg. we can prepeared 3 bezier curves and the part of code example i was using threejs\n\ndemo file ( in 2019 dev99 )\nhttp://benchart.cn/ribbon/ribbon.html\n\n// concated function\n// found this algorithm in wikipedia.\n\ndrawContact( p3, p2 ){\n    var conactPoint = new THREE.Vector3();\n\n    conactPoint.x = 2 * p3.x - p2.x;\n    conactPoint.y = 2 * p3.y - p2.y;\n    conactPoint.z = 2 * p3.z - p2.z;\n\n    return conactPoint;\n}\n\nfor (var i = 0; i < 3; i++) {\n    if (i == 0) {\n        // init bezier\n        curves[i] = new THREE.CubicBezierCurve3(\n            randomVec3D(-camerPosZ * .7, camerPosZ * .7), randomVec3D(-camerPosZ * .7, camerPosZ * .7), randomVec3D(-camerPosZ * .7, camerPosZ * .7), randomVec3D(-camerPosZ * .7, camerPosZ * .7)\n        );\n\n        this.tracks = this.tracks.concat(curves[i].getPoints(pointCount));\n    } else {\n        // next bezier\n        curves[i] = new THREE.CubicBezierCurve3(\n            curves[i - 1].v3, drawContact(curves[i - 1].v3, curves[i - 1].v2), randomVec3D(-camerPosZ * .7, camerPosZ * .7), randomVec3D(-camerPosZ * .7, camerPosZ * .7)\n        );\n\n        this.tracks = this.tracks.concat(curves[i].getPoints(pointCount));\n    }\n}\n\nand you can got each point for effects.\n\n*/\n\n#define I iResolution\n#define PI 3.1415926\n\n// timeline\nfloat tl( float t ){\n    float l = ( t >= 0. ) ? t : 0.;\n    \n    return ( t >= 1. ) ? 1. : l;\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// IQ's addSegm\n// you can also use it line to vec3\nfloat h(in vec2 a) { return dot(a, a); }\n// same way for sdf3 but needs sqrt line\nfloat G(in vec2 c, in vec2 a, in vec2 d) { \n  vec2 e = c - a, b = d - a;\n  return h(e - b * clamp(dot(e, b) / dot(b, b), 0., 1.));\n}\n\nvec4 gxy( float i, float ii, float c ){\n    float x = ( i / c * 2.5 ) - 1.25;\n    float y = cos( i * .8 * ( i / c ) ) * .01 * i;\n\n    float x1 = ( ii / c * 2.5 ) - 1.25;\n    float y1 = cos( ii * .8 * ( ii / c ) ) * .01 * ii;\n\n    return vec4( x, y, x1, y1 );\n}\n\n// generated curve\nfloat tg( vec2 uv ){\n\n    float p = 0.1,\n          c = 30.,\n          i;\n\n    for( ; i < c; i++ ){\n        \n        if( i >= c * tl(iTime * .4) ){\n            break ;\n        }\n        \n        float ii = i + 1.;\n\n        vec4 v = gxy( i, ii, c );\n\n        p = min(\n            p,\n            G( uv, vec2( v.x, v.y ), vec2(v.z, v.w) )\n        );\n\n    }\n    \n    return sqrt( p );\n\n}\n\nfloat mp(vec3 p)\n{   \n    p.yz *= rot( PI * .3 );\n    p.xy *= rot( PI * .25 );\n    \n    /*\n        mat3( \n            1., 0., 0.,\n            0., 1., 0.,\n            0., 0., 1.\n        );\n        \n        p *= mat3( \n            cos( PI * .25 ), sin( PI * .25 ), 0.,\n            -sin( PI * .25 ), cos( PI * .55 ), sin( PI * .3 ),\n            0., -sin( PI * .3 ), cos( PI * .3 )\n        );\n    \n        // :O\n        // tweenlite.js can generated css3 mat values\n        // but something like Rubik's cube..\n        \n    */\n    \n    p.yz *= -rot( iTime > 2.5 ? iTime - 2.5 : 0. );\n    \n    return max(\n        tg( p.xy * rot( p.z * 1.2 ) ),\n        abs( p.z ) - .3\n    );\n}\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( (V/I.xy - .5) * 2. ) * vec2( I.x / I.y, 1. );\n    \n    vec3 c, p, o = vec3( 0., 0., -6. ), r = vec3( u * .2, 1. );\n    c += .1;\n    float t, d, i, dp, e = sqrt( 1e-5 );\n    for( ; i < 64.; i++ )\n        p = o + r * t,\n        d = mp( p ),\n        dp = ( 1. - abs( d ) / e ),\n        c += ( dp > 0. ) ? .15 * dp / t : 0.,\n        t += max( abs( d ) * .55555, e );\n\n    // Output to screen\n    U = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}