{"ver":"0.1","info":{"id":"mdVGRy","date":"1678826440","viewed":54,"name":"Raymarch: Szene mit Lichtern","username":"St0fF_ToM","description":"Soll auch wieder was zum Raymarch-Szenen bauen sein ...\n-> eine Sonne, die auf- und ab geht (~1 Min pro Phase)\n-> 3 Spotlights, die sich im Kreise drehen\n-> abschaltbares KS und Lichtobjekte\nDanke HG!  Danke HG!  Danke HG!  Danke HG!  Danke HG!  Danke HG!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Show or don't show stuff\n#define SHOW_BASE 1\n#define SHOW_CS 0\n#define SHOW_LIGHTS 0\n#define BASEPLANE_DISPLACEMENT 0.\n#define BASEPLANE_INCLUDE_LIGHTING 1\n// raycasting-settings\n#define ZERO (min(iFrame,0))\n#define MAX_ITERATIONS 500\n#define TOO_FAR_AWAY 250.0\n#define CLOSE_ENOUGH 0.001\n#define dstMarkWidth 0.1\n#define UnitDisplayFactor 5.0\n//camera settings\n#define FOCAL_LENGTH 2.5\n#define CAM_POS vec3( 0., 0., -50. )\n#define CAM_POI vec3( 0., 0., 0. )\n#define CAM_SWING 4.0\n#define CAM_RELAX 8.0\n// Beleuchtung\nconst vec3 SPOT_pos = vec3( 10, 10, 15 );\nconst vec3 SPOT_focus = vec3( 5, 5, 0 );\nconst vec3 SPOT_color[3] = vec3[](\n    vec3( 1., .3, .3 ),\n    vec3( .3, 1., .3 ),\n    vec3( .3, .3, 1. ) );\nconst float SPOT_angle = cos( radians( 20. ) );\n#define SPOTPOS(i) ( SPOT_pos * vec3( cos( t + float( i ) * radians( 120. ) ), sin( t + float( i ) * radians( 120. ) ), 1.0 ) )\n#define SPOTFOCUS(i) ( SPOT_focus * vec3( cos( 2.0 * t + float( i ) * radians( 120. ) + PI ), sin( 2.0 * t + float( i ) * radians( 120. ) + PI ), 1.0 ) )\n#define SPOTDIR(i) normalize( SPOTFOCUS( i ) - SPOTPOS( i ) )\n//#define SPOTPOWER(i) length( SPOTPOS( i ) - SPOTFOCUS( i ) )\n#define SPOTPOWER(i) 15.0\n// material helpers\n#define MAT_CNT 8\nconst vec3 ambient[MAT_CNT] = vec3[](\n/* NONE   */vec3( 0.0 ),\n/* BASE   */vec3( 0.11, 0.12, 0.13 ),\n/* CS     */vec3( 0.1 ),\n/* BODY   */vec3( 0.09, 0.11, 0.08 ),\n/* L1     */SPOT_color[ 0 ],\n/* L2     */SPOT_color[ 1 ],\n/* L3     */SPOT_color[ 2 ],\n/* SUN    */vec3( 1.0, 0.7, 0.9 ) );\n#define MAT(X) float( X )\n#define NONE 0\n#define BASE 1\n#define CS 2 /* Coordinate System */\n#define BODY 3\n#define L1 4\n#define L2 5\n#define L3 6\n#define SUN 7\n// Materialkonstanten???\n#define KSL 15.0\n#define KSR 0.25\nconst vec3[] dist_col = vec3[](\n    vec3( 0.35, 0.18, 0.12 ),\n    vec3( 0.25, 0.25, 0.17 ),\n    vec3( 0.20, 0.35, 0.22 ),\n    vec3( 0.20, 0.22, 0.35 )\n);\n// die Sonne\n#define SUN_SLOW 3.\n#define SUNX ( 25.0 * -cos( t / SUN_SLOW ) )\n#define SUNY ( 15.0 * abs( sin( t / SUN_SLOW ) ) )\n#define SUNZ ( 50.0 * sin( t / SUN_SLOW ) )\n#define SUN_POS vec3( SUNX, SUNY, SUNZ )\n#define SUN_DIR normalize( vec3( 0.0 ) - SUN_POS )\n\nfloat t;\nvec2 uv;\nvec3 p0, ro, rd;\n\nvec3 makeSmoothStep()\n{\n    #define POINT(X,Y) vec3( float(X),float(Y) )\n    #define RANGE(X0,Y0,X1,Y1) vec4( float(X0),float(Y0), float(X1),float(Y1) )\n    // Einfache Logik: wir projezieren eine Funktion auf die Ebene.  Ebenenkoordinaten\n    // kommen als uv -> ([0..1],[0..1])\n    // wir müssen wie folgt transformieren:\n    vec4 rng = RANGE(-1,-1,2,2);      // Anzeige Eckpunkte\n    vec2 scale = rng.zw - rng.xy;    // daraus folgende Skalierung\n    vec2 curpos = rng.xy + uv*scale;// current uv position in der Skalierung drinne\n    float v_val = smoothstep( SPOT_angle + 0.02, SPOT_angle - 0.02, curpos.x );\n    float val = pow( 1.0 - clamp( abs( curpos.y - (v_val)), 0., 1.), 32.);\n    return vec3( val );\n}\nfloat makeLightArrow( in vec3 p, in vec3 dir )\n{\n    // we build a sphere at our point p\n    // then we connect a cylinder of UnitDisplayFactor x unit size\n    // finally that cylinder gets a cone cap\n    float ds = fSphere( p, 1. );\n    // rotate coordinate system towards that direction\n    float dc = fCapsule( p, vec3( 0.05 * dir ), dir * UnitDisplayFactor, UnitDisplayFactor * 0.05 );\n    // move to the tip of our vector\n    p -= dir * UnitDisplayFactor * 0.9;\n    float de = TOO_FAR_AWAY;//fCone( p.xzy * vec3( 1,-1,1 ), 0.25 * UnitDisplayFactor, 0.1 * UnitDisplayFactor  );\n    return fOpUnionSoft( de, fOpUnionSoft( dc, ds, 0.02 ), 0.02 );\n}\nfloat makeArrow( in vec3 p )\n{\n    vec3 q = p;\n    q.x = abs( q.x ) - KSL*0.8; // achse spiegeln, dann verschieben\n    pR( q.yx, radians( 90.0 ) );          // für den Code nochmal swizzlen\n    return min( fCylinder( p, KSR, KSL*0.8 ), fCone( q, KSR*3.0, KSL*0.2 ) );\n}\nfloat makeCenter( in vec3 p )\n{\n    return\n        fOpUnionChamfer( makeArrow( p.xyz ),\n        fOpUnionChamfer( makeArrow( p.yzx ),\n                         makeArrow( p.zxy ), KSR ), KSR );\n}\nvec2 world( in vec3 p )\n{\n//    vec2 res = vec2( fRoundBox( p, vec3( 1,1,1 ), 0.25 ), MAT( BODY ) );\n    vec2 res = vec2( fBlob( p ), MAT( BODY ) );\n    return res;\n}\nvec2 map(in vec3 p, bool withBasePlane )\n{\n#if SHOW_BASE\n    // start up into the world ...              plane            displacement\n    vec2 res = vec2( withBasePlane ? fPlane( p, vec3( 0, 0, 1 ), BASEPLANE_DISPLACEMENT ) :\n#else\n    vec2 res = vec2(\n#endif\n                                   TOO_FAR_AWAY, MAT( BASE ) );\n#if ( SHOW_CS )\n    res = OPU( vec2( makeCenter( p ), MAT( CS ) ), res );\n#endif\n    // Sonne und die Leuchten ...\n#if ( SHOW_LIGHTS )\n    res = OPU( vec2( makeLightArrow( p - SUN_POS, SUN_DIR ), MAT( SUN ) ), res );\n    res = OPU( vec2( makeLightArrow( p - SPOTPOS(0), SPOTDIR(0) ), MAT( L1 ) ), res );\n    res = OPU( vec2( makeLightArrow( p - SPOTPOS(1), SPOTDIR(1) ), MAT( L2 ) ), res );\n    res = OPU( vec2( makeLightArrow( p - SPOTPOS(2), SPOTDIR(2) ), MAT( L3 ) ), res );\n#endif\n    // Baue Deine eigene Welt ab hier ...\n    return OPU( world( p ), res );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3( 0.0 );\n    for( int i = ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * map( pos + CLOSE_ENOUGH * 0.5 * e, true ).x;\n    }\n    return normalize(n);\n}\nvec3 shade( in vec3 whatTheRaymarcherDid )\n{\n    float lastDistanceTraveled = whatTheRaymarcherDid.x;\n    int   material = int( round( whatTheRaymarcherDid.y ) );\n    float fullDistanceTraveled = whatTheRaymarcherDid.z;\n    vec3 pos = ro + rd * fullDistanceTraveled;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n    // Materialbasisfarbe\n    vec3 lin = ambient[material];\n    if ( material == BASE )\n    {   // Basisplatte: Abstandsanzeige zum nächsten Welt-Objekt\n        float d = map( pos, false ).x;\n        // Abstand hammer - logarithmische Farbänderungen?\n        float z = clamp( log2( d ), 0.0, 2.999 );\n        lin = mix(   mix( dist_col[ int( z ) ], \n                          dist_col[ int( z+1.0 ) ],\n                          fract( z ) ),\n                     vec3( .15, .18, .01 ),\n                     vec3( smoothstep( 0.05, 0.0, fract( d ) ) \n                         * smoothstep( 1.0, 0.95, fract( d ) ) ) );\n#if BASEPLANE_INCLUDE_LIGHTING\n    }{\n#else\n    } else {\n#endif\n        if ( material == CS ) // Koordinatensystem bekommt\n            lin = clamp( abs( pos ), 0., 1. ); // Achsenfarben\n        // Jetzt die eigentliche Beleuchtung\n        vec3 light = vec3( 0 );\n        // Wir wollen 3 Spots und eine Sonne integrieren.\n        // Beginnen wir mit der Sonne\n        if ( material == SUN )\n            lin *= 0.3; // Die Sonnenkugel soll nicht superweiß sein ...\n        else {         // und alle anderen Objekte werden besonnt\n            vec3 reflectDir = reflect( nor, SUN_DIR );\n            float spec = pow( max( dot( rd, reflectDir ), 0.0 ), 32.0 );\n            float diff = max( dot( nor, -SUN_DIR ), 0.0 );\n            light += 0.5*(diff + 0.5 * spec) * ambient[ SUN ];\n        }\n        // Als nächstes die 3 Spots:\n        // SPOTPOS, SPOTFOCUS, SPOTPOWER = length(SPOTPOS-SPOTFOCUS)\n#if SHOW_LIGHTS\n        if ( material < L1 || material > L3 )\n#endif\n        {   // Die Leuchten selbst beleuchten sich nicht ...\n            for ( int ij = L1; ij <= L3; ++ij )\n            {\n                int i = ij - L1;\n            // Richtung von Pixel zum Spot: SPOTPOS-POS\n                vec3 to_spot = SPOTPOS(i) - pos;\n            // SPOT_DIR muss auch berechnet werden (SPOTFOCUS-SPOTPOS)\n            // Winkel zwischen den Richtungen zumSpot, SpotRichtung\n                float cosa = max( dot( normalize( to_spot ), -SPOTDIR(i) ), 0.0 );\n            // Abgerundete scharfe Kanten, wo der Spot aufhört\n                cosa *= smoothstep( SPOT_angle - 0.02, SPOT_angle + 0.02, cosa );\n                float d = length( to_spot ) / SPOTPOWER(i) + 1.0;\n            // die Intensität nimmt ja auch noch ab ...\n                cosa *= clamp( 1.0 / ( d * d ), 0., 1.);\n            // jetzt brauchen wir noch den diffusen und den\n            // spekulären Lichtanteil von dieser Quelle\n                to_spot = normalize( to_spot );\n                float diff = clamp( dot( nor, to_spot ), 0., 1.);\n                float spec = pow( max( dot( rd, reflect( nor, to_spot ) ), 0.0 ), 16.0 );\n                light += 10.*(diff + spec) * cosa * SPOT_color[ i ];\n            }\n        }\n        lin *= light;\n    }\n    return lin;\n}\nvec3 raymarch( in vec3 ro, in vec3 rd )\n{\n    // march the ray ... find shortest Distance to world ...\n    vec3 res = vec3( map( ro, true ), 0. );\n    res.z = res.x;\n    int i = 0;\n    while ( i < MAX_ITERATIONS && res.z < TOO_FAR_AWAY )\n    {\n        if ( abs( res.x ) < CLOSE_ENOUGH )\n            break;\n        res.xy = map( rd * res.z + ro, true );\n        res.z += res.x;\n        i++;\n    }\n    if (i == MAX_ITERATIONS || res.z >= TOO_FAR_AWAY )\n        res.y = MAT( NONE ); // No Material, as not hit was found.\n    return res;\n}\nvoid camera( out vec3 ro, out vec3 rd, in vec3 np, in float rotate )\n{\n    // Camera Point of Interest\n    vec3 ta = CAM_POI;\n    // to Camera Position\n    ro = ta - CAM_POS;\n    // rotate the camera a little by displacing the CAM_POS\n    ro.xy += sin( t / CAM_RELAX ) * CAM_SWING * vec2( cos( t ), sin( t ) );\n    // calculate the camera matrix\n    vec3 cw = normalize( ta - ro );\n    // rotate the xy-plane\n    vec3 cp = vec3( sin( rotate ), cos( rotate ), 0.0 );\n    vec3 cu = normalize( cross( cw, cp ) );\n    vec3 cv =          ( cross( cu, cw ) );\n    // ray direction from camera-to-world transformation and focal length\n    rd = mat3( cu, cv, cw ) * normalize( np );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalisierte Pixel Koordinaten (von 0 bis 1)\n    uv = fragCoord/iResolution.xy;\n    // Normalisierte Raum Koordinaten\n    p0 = vec3( ( 2.0 * fragCoord - iResolution.xy ) / iResolution.xy\n                    , FOCAL_LENGTH );\n    // Zeitgeber: alle 10s als Zyklus festgelegt\n    t = iTime / 10. * TAU;\n    \n    // Kamera setzen\n    camera( ro, rd, p0, 0.0 );\n    \n    // Strahl verfolgen\n    vec3 res = raymarch( ro, rd ); // ( di, mat, d )\n    \n    // Schattieren\n    vec3 linCol = shade( res );\n    //linCol += makeSmoothStep(); // Coding helper\n    \n    // Farbausgabe mit Gammakorrektur\n    fragColor = vec4( pow( linCol, vec3( 0.4545 ) ), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn ( x < 0.0 ) ? -1.0 : 1.0;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.0)?-1.0:1.0, (v.y<0.0)?-1.0:1.0);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\nfloat fRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs( p ) - b;\n  return length( max( q, 0.0 ) ) + min( vmax( q ), 0.0 ) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1.0))),\n\t\tdot(p.xz, normalize(vec2(PHI+1.0, 1.0)))),\n\t\tdot(p.yx, normalize(vec2(1.0, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1.0, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.0)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0.0 ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.0)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.0)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.0)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\nconst vec3 GDFVectors[19] = vec3[](\n\tnormalize(vec3(1, 0, 0)),\n\tnormalize(vec3(0, 1, 0)),\n\tnormalize(vec3(0, 0, 1)),\n\n\tnormalize(vec3(1, 1, 1 )),\n\tnormalize(vec3(-1, 1, 1)),\n\tnormalize(vec3(1, -1, 1)),\n\tnormalize(vec3(1, 1, -1)),\n\n\tnormalize(vec3(0, 1, PHI+1.0)),\n\tnormalize(vec3(0, -1, PHI+1.0)),\n\tnormalize(vec3(PHI+1.0, 0, 1)),\n\tnormalize(vec3(-PHI-1.0, 0, 1)),\n\tnormalize(vec3(1, PHI+1.0, 0)),\n\tnormalize(vec3(-1, PHI+1.0, 0)),\n\n\tnormalize(vec3(0, PHI, 1)),\n\tnormalize(vec3(0, -PHI, 1)),\n\tnormalize(vec3(1, 0, PHI)),\n\tnormalize(vec3(-1, 0, PHI)),\n\tnormalize(vec3(PHI, 1, 0)),\n\tnormalize(vec3(-PHI, 1, 0))\n);\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\nfloat fGDF(vec3 p, float r, float e, int begin, int end) {\n\tfloat d = 0.0;\n\tfor (int i = begin; i <= end; ++i)\n\t\td += pow(abs(dot(p, GDFVectors[i])), e);\n\treturn pow(d, 1.0/e) - r;\n}\n\n// Version with without exponent, creates objects with sharp edges and flat faces\nfloat fGDF(vec3 p, float r, int begin, int end) {\n\tfloat d = 0.0;\n\tfor (int i = begin; i <= end; ++i)\n\t\td = max(d, abs(dot(p, GDFVectors[i])));\n\treturn d - r;\n}\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 3, 6);\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 13, 18);\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 3, 12);\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 0, 6);\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 3, 18);\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 6);\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 13, 18);\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 12);\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 0, 6);\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 18);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// rotate system into a normal vector\nvec3 pRotNorm( in vec3 p, in vec3 n )\n{\n    float phi = atan( n.z, n.x );\n    float rho = -asin( n.y );\n    pR( p.xy, phi );\n    pR( p.xz, rho );\n    return p;\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2.0 - 1.0;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.0)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c < start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n\tp -= size/2.0;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.0);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.0) {\n\t\tp = p - (2.0*t)*planeNormal;\n\t}\n\treturn sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\nvec2 OPU( vec2 d, vec2 last_d)\n{\n    return d.x < last_d.x ? d : last_d;\n}\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/((n-1.0)*2.0+sqrt(2.0));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.0)/2.0*r;\n\t\tp.x += columnradius*sqrt(2.0);\n\t\tif (mod(n,2.0) == 1.0) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.0);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.0)/((n-1.0)*2.0+sqrt(2.0));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.0)/2.0*r;\n\t\tp.x += -columnradius*sqrt(2.0)/2.0;\n\n\t\tif (mod(n,2.0) == 1.0) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.0);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.0);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n","name":"Common","description":"","type":"common"}]}