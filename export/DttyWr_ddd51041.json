{"ver":"0.1","info":{"id":"DttyWr","date":"1699067985","viewed":30,"name":"curve-tangents","username":"gboyraz","description":"Explore the undulating dance of a time-variant quadratic curve and its tangents, changing direction every 9 seconds. A color transition from red to blue highlights the slope changes, blending math with art.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["curve","tangents"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Curve function: y = ax^2 + bx + c\nconst float a = 1.5;\nconst float b = -1.5;\nconst float c = 0.0;\n\n// Curve function definition with time-based variation\nfloat curve(float x, float time) {\n    // The time function oscillates between -1 and 1 over a period of 9 seconds.\n    float periodicTime = 9.0 * sin(time * 3.14159265 / 9.0);\n    return periodicTime * a * x * x + b * x + c;\n}\n\n// Curve function's derivative with time-based variation\nfloat curveDerivative(float x, float time) {\n    // We use the same time function for the derivative calculation.\n    float periodicTime = 9.0 * sin(time * 3.14159265 / 9.0);\n    return periodicTime * 2.0 * a * x + b;\n}\n\n// Helper function to color the tangent based on its slope\nvec4 colorForTangent(float slope) {\n    // Normalize the slope to get a value between 0 and 1\n    float normalizedSlope = atan(slope) / 3.14159265 + 0.5;\n    // Create a gradient from red to blue\n    return vec4(normalizedSlope, 0.5, 1.0 - normalizedSlope, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates with respect to screen resolution\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Calculate the curve at this point\n    float curveY = curve(uv.x, iTime);\n\n    // Draw the curve itself\n    float curveWidth = 0.05; // The thickness of the curve\n    bool onCurve = abs(uv.y - curveY) < curveWidth;\n\n    // Find if we are near a point that could be on a tangent\n    float sampleStep = 0.05; // How far apart our samples are on the x-axis\n    float tangentThreshold = 0.02; // How close we need to be to the tangent line\n    vec4 tangentColor = vec4(0.0);\n\n    for (float x = -1.0; x < 1.0; x += sampleStep) {\n        // For each sample point on the curve, calculate the derivative\n        float slope = curveDerivative(x, iTime);\n        // Calculate y intercept of the tangent line\n        float yIntercept = curve(x, iTime) - slope * x;\n        // Get the y value of this tangent line at our current x (which is uv.x)\n        float tangentY = slope * uv.x + yIntercept;\n\n        if (abs(tangentY - uv.y) < tangentThreshold) {\n            // If our current pixel is close to this tangent line, we use its color\n            tangentColor += colorForTangent(slope);\n            break; // Stop if we've found a close tangent line\n        }\n    }\n\n    // Coloring logic\n    if (onCurve) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0); // White color for the curve\n    } else if (tangentColor != vec4(0.0)) {\n        fragColor = tangentColor; // Color determined by the slope of the tangent\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color\n    }\n}","name":"Image","description":"","type":"image"}]}