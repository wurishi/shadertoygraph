{"ver":"0.1","info":{"id":"wsBfW3","date":"1591197599","viewed":294,"name":"Welcome Home, spacemen!","username":"winlandiano","description":"A remake of nimitz great \"Re-entry\", first time modelling on Shadertoy. Added cinematic camera behaviour.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["fbm","space","volumetricfire","spacecapsule","cinematiccamera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Welcome Home, spacemen! by Ridge/winlandiano\n// based on \"Re-entry\" by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4dGyRh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define ITR 35\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 objmov(vec3 p) {\n    p.xy *= rot(sin(time * 4.) / (1. + time));\n    return p;\n}\n\nfloat sdObj(vec3 p) {\n    float rT = 0.75, rB = 1., h = 0.5;\n    vec3 pos = vec3(0, 0, 0);\n    float rT2 = rT * rT;\n    float d;\n\n    float topRatio = 2.;\n    float botRatio = 4.;\n    float dcc = sdCappedCone(p - pos, h, rB, rT);\n\n    // top sphere\n    float rsTop = topRatio * h;\n    float rsTop2 = rsTop * rsTop;\n    vec3 sTopPos = vec3(pos.x, pos.y + h - sqrt(rsTop2 - rT2), pos.z);\n    float dsTop = sdSphere(p - sTopPos, rsTop);\n    dsTop = max(dsTop, -p.y + pos.y + h - eps);\n    d = min(dcc, dsTop);\n\n    // top exit\n    float rC = 1.1 * h;\n    float hC = rsTop - sqrt(rsTop2 - rC * rC);\n    vec3 cPos = sTopPos + vec3(0, rsTop, 0);\n    float dcTop = sdCylinder(p - cPos, vec3(0, -hC, 0), vec3(0, hC * .1, 0), rC);\n    d = min(d, dcTop);\n\n    // sind window\n    rC = 0.4 * h;\n    hC = 0.05 * h;\n    cPos = pos + vec3(0, 0, (rB - rT) / 2.);\n    cPos = pos + vec3(0, 0, rT + (rB - rT) / 2.);\n    float k = (rB - rT) / h;\n    float dWindow = sdCylinder(p - cPos, vec3(0, -hC * k, -hC / k), vec3(0, hC * k, hC / k), rC);\n    d = min(d, dWindow);\n\n    // bottom sphere\n    float rsBot = botRatio * h;\n    float dsBot = sdSphere(p - vec3(pos.x, pos.y - h + sqrt(rsBot * rsBot - rB * rB), pos.z), rsBot);\n    dsBot = max(dsBot, p.y - pos.y + h - eps);\n    d = min(d, dsBot);\n\n    return d;\n}\n\nfloat tri(in float x) { return abs(fract(x) - 0.5) - .25; }\nfloat trids(in vec3 p) { return max(tri(p.z), min(tri(p.x), tri(p.y))); }\nfloat tri2(in float x) { return abs(fract(x) - .5); }\nvec3 tri3(in vec3 p) { return vec3(tri(p.z + tri(p.y * 1.0)), tri(p.z + tri(p.x * 1.05)), tri(p.y + tri(p.x * 1.1))); }\n\nmat2 m2 = mat2(0.970, 0.242, -0.242, 0.970);\nfloat triNoise3d(in vec3 p, in float spd) {\n    float z = 1.45;\n    float rz = 0.;\n    vec3 bp = p;\n    for (float i = 0.; i < 4.; i++) {\n        vec3 dg = tri3(bp);\n        p += (dg + time * spd + 10.1);\n        bp *= 1.65;\n        z *= 1.5;\n        p *= .9;\n        p.xz *= m2;\n\n        rz += (tri2(p.z + tri2(p.x + tri2(p.y)))) / z;\n        bp += 0.9;\n    }\n    return rz;\n}\n\nfloat map(vec3 p) {\n    p *= 1.5;\n    p = objmov(p);\n    p.xy *= rot(PI);\n    p.xz *= rot(PI / 2.);\n    p.y += 1.5;\n    float d = sdObj(p - vec3(0, 1.2, 0));\n    return d / 1.5;\n}\n\nfloat map2(vec3 p) {\n    p = objmov(p);\n    return length(p) - 1.3;\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n    float precis = 0.001;\n    float h = precis * 2.0;\n    float d = 0.;\n    for (int i = 0; i < ITR; i++) {\n        if (abs(h) < precis || d > FAR) break;\n        d += h;\n        float res = map(ro + rd * d);\n        h = res;\n    }\n    return d;\n}\n\nvec3 normal(const in vec3 p) {\n    vec2 e = vec2(-1., 1.) * 0.04;\n    return normalize(e.yxx * map(p + e.yxx) + e.xxy * map(p + e.xxy) + e.xyx * map(p + e.xyx) + e.yyy * map(p + e.yyy));\n}\n\nfloat gradm(in vec3 p) {\n    float e = .06;\n    float d = map2(vec3(p.x, p.y - e, p.z)) - map2(vec3(p.x, p.y + e, p.z));\n    d += map2(vec3(p.x - e, p.y, p.z)) - map2(vec3(p.x + e, p.y, p.z));\n    d += map2(vec3(p.x, p.y, p.z - e)) - map2(vec3(p.x, p.y, p.z + e));\n    return d;\n}\n\n// Main fireball\nfloat mapVol(vec3 p, in float spd) {\n    float f = smoothstep(0.0, 1.25, 1.7 - (p.y + dot(p.xz, p.xz) * .62));\n    float g = p.y;\n    p.y *= .27;\n    p.z += gradm(p * 0.73) * 3.5;\n    p.y += time * 6.;\n    float d = triNoise3d(p * vec3(0.3, 0.27, 0.3) - vec3(0, time * .0, 0), spd * 0.7) * 1.4 + 0.01;\n    d += max((g - 0.) * 0.3, 0.);\n    d *= f;\n\n    return clamp(d, 0., 1.);\n}\n\nvec3 marchVol(in vec3 ro, in vec3 rd, in float t, in float mt) {\n    vec4 rz = vec4(0);\n#if 1\n    t -= (dot(rd, vec3(0, 1, 0)) + 1.);\n#endif\n    float tmt = t + 15.;\n    for (int i = 0; i < 25; i++) {\n        if (rz.a > 0.99) break;\n\n        vec3 pos = ro + t * rd;\n        float r = mapVol(pos, .1);\n        float gr = clamp((r - mapVol(pos + vec3(.0, .7, 0.0), .1)) / .3, 0., 1.);\n        vec3 lg = vec3(0.72, 0.28, .0) * 1.2 + 1.3 * vec3(0.55, .77, .9) * gr;\n        vec4 col = vec4(lg, r * r * r * 2.5);  // Could increase this to simulate entry\n        col *= smoothstep(t - 0.0, t + 0.2, mt);\n\n        pos.y *= .7;\n        pos.zx *= ((pos.y - 5.) * 0.15 - 0.4);\n        float z2 = length(vec3(pos.x, pos.y * .75 - .5, pos.z)) - .75;\n        col.a *= smoothstep(.4, 1.2, .7 - map2(vec3(pos.x, pos.y * .17, pos.z)));\n        col.rgb *= col.a;\n        rz = rz + col * (1. - rz.a);\n\n        t += abs(z2) * .1 + 0.12;\n        if (t > mt || t > tmt) break;\n    }\n\n    rz.g *= rz.w * 0.9 + 0.12;\n    rz.r *= rz.w * 0.5 + 0.48;\n    return clamp(rz.rgb, 0.0, 1.0);\n}\n\n// \"Particles\"\nfloat mapVol2(vec3 p, in float spd) {\n    p *= 1.3;\n    float f = smoothstep(0.2, 1.0, 1.3 - (p.y + length(p.xz) * 0.4));\n    p.y *= .05;\n    p.y += time * 1.7;\n    float d = triNoise3d(p * 1.1, spd);\n    d = clamp(d - 0.15, 0.0, 0.75);\n    d *= d * d * d * d * 47.;\n    d *= f;\n\n    return d;\n}\n\nvec3 marchVol2(in vec3 ro, in vec3 rd, in float t, in float mt) {\n    vec3 bpos = ro + rd * t;\n    t += length(vec3(bpos.x, bpos.y, bpos.z)) - 1.;\n    t -= dot(rd, vec3(0, 1, 0));\n    vec4 rz = vec4(0);\n    float tmt = t + 1.5;\n    for (int i = 0; i < 25; i++) {\n        if (rz.a > 0.99) break;\n\n        vec3 pos = ro + t * rd;\n        float r = mapVol2(pos, .01);\n        vec3 lg = vec3(0.7, 0.3, .2) * 1.5 + 2. * vec3(1, 1, 1) * 0.75;\n        vec4 col = vec4(lg, r * r * r * 3.);\n        col *= smoothstep(t - 0.25, t + 0.2, mt);\n\n        float z2 = length(vec3(pos.x, pos.y * .9, pos.z)) - .9;\n        col.a *= smoothstep(.7, 1.7, 1. - map2(vec3(pos.x * 1.1, pos.y * .4, pos.z * 1.1)));\n        col.rgb *= col.a;\n        rz = rz + col * (1. - rz.a);\n\n        t += z2 * .015 + abs(.35 - r) * 0.09;\n        if (t > mt || t > tmt) break;\n    }\n\n    return clamp(rz.rgb, 0.0, 1.0);\n}\n\n// MIT Licensed hash From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p) {\n    p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz + 19.27);\n    return fract(vec3(p.x * p.y, p.z * p.x, p.y * p.z));\n}\n\nvec3 stars(in vec3 p) {\n    vec3 c = vec3(0.);\n    float res = iResolution.x * 0.8;\n\n    for (float i = 0.; i < 4.; i++) {\n        vec3 q = fract(p * (.15 * res)) - 0.5;\n        vec3 id = floor(p * (.15 * res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1. - smoothstep(0., .6, length(q));\n        c2 *= step(rn.x, .0005 + i * i * 0.001);\n        c += c2 * (mix(vec3(1.0, 0.49, 0.1), vec3(0.75, 0.9, 1.), rn.y) * 0.25 + 0.75);\n        p *= 1.4;\n    }\n    return c * c * .65;\n}\n\nfloat curv(in vec3 p, in float w) {\n    vec2 e = vec2(-1., 1.) * w;\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return 1.0 / e.y * (t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy / iResolution.xy - 0.5;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy - .5;\n    mo = vec2(-0.27, 0.31);\n    mo.x *= iResolution.x / iResolution.y;\n    const float roz = 7.3;\n    vec3 ro = vec3(-1.5, 0.5, roz);\n    vec3 rd = normalize(vec3(p, -1.5));\n    mo.x += sin(time * 0.3 + sin(time * 0.05)) * 0.03 + 0.03;\n    mo.y += sin(time * 0.4 + sin(time * 0.06)) * 0.03;\n    mat2 mx = mm2(mo.x * 6.);\n    mat2 my = mm2(mo.y * 6.);\n    ro.xz *= mx;\n    rd.xz *= mx;\n    ro.xy *= my;\n    rd.xy *= my;\n\n    // shake camera as in telescope\n    float t;\n    float w;\n    t = 8. * time;\n    w = noise2(vec2(0, t));\n    rd.yz *= rot(w * 0.02);\n    t = 12. * time;\n    w = noise2(vec2(0.5, t));\n    rd.xz *= rot(w * 0.02);\n\n    float rz = march(ro, rd);  // march geometry\n    vec3 col = stars(rd);\n\n    float maxT = rz;\n    if (rz > FAR) maxT = 25.;\n    vec3 mv = marchVol(ro, rd, roz - 1.5, maxT);\n\n    if (rz < FAR) {\n        vec3 pos = ro + rz * rd;\n        vec3 nor = normal(pos);\n        float crv = clamp(curv(pos, 0.3) * 0.35, 0., 1.3);\n\n        vec3 col2 = vec3(1, 0.1, 0.02) * (crv * 0.8 + 0.2) * 0.5;\n        float frict = dot(pos, normalize(vec3(0., 1., 0.)));\n        col = col2 * (frict * 0.3 + 0.7);\n\n        col += vec3(1, 0.3, 0.1) * (crv * 0.7 + 0.3) * max((frict * 0.5 + 0.5), 0.) * 1.3;\n        col += vec3(.8, 0.8, .5) * (crv * 0.9 + 0.1) * pow(max(frict, 0.), 1.5) * 1.9;\n        pos = objmov(pos);\n\n        col *= 1.2 - mv;\n        col *= triNoise3d(pos * 2.8, 0.) * 0.25 + 0.45;\n        col = pow(col, vec3(1.5, 1.2, 1.2)) * .9;\n    }\n    col += mv;\n    col += marchVol2(ro, rd, roz - 5.5, rz);\n    col = pow(col, vec3(1.4)) * 1.1;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793238\n#define eps 1e-5\n\n// @iq MIT License https://www.shadertoy.com/view/Xds3zN\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat dot2(in vec3 v) { return dot(v, v); }\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba, ba);\n    float paba = dot(pa, ba);\n\n    float x = length(pa * baba - ba * paba) - r * baba;\n    float y = abs(paba - baba * 0.5) - baba * 0.5;\n    float x2 = x * x;\n    float y2 = y * y * baba;\n    float d = (max(x, y) < 0.0) ? -min(x2, y2) : (((x > 0.0) ? x2 : 0.0) + ((y > 0.0) ? y2 : 0.0));\n    return sign(d) * sqrt(abs(d)) / baba;\n}\n\nfloat sdRoundCone(in vec3 p, in float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if (k < 0.0) return length(q) - r1;\n    if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sdCappedCone(in vec3 p, in float h, in float r1, in float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot2(ca), dot2(cb)));\n}\n// !iq\n\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rot(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash2(vec2 p) {\n    p = 50.0 * fract(p * 0.3183099 + vec2(0.71, 0.113));\n    return -1.0 + 2.0 * fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat hash3(vec3 p) {\n    p = fract(p * 0.3183099 + .1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash2(i);\n    float b = hash2(i + vec2(1.0, 0.0));\n    float c = hash2(i + vec2(0.0, 1.0));\n    float d = hash2(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}","name":"Common","description":"","type":"common"}]}