{"ver":"0.1","info":{"id":"lsd3zN","date":"1448494127","viewed":4028,"name":"sRGB demo","username":"TomF","description":"Each colour is shown three times: as a linear ramp, an sRGB ramp, and a 2.2 gamma ramp (which isn't a real format, but shows how 2.2 and sRGB are similar but significantly different). The ramps are quantised to 6 bits to emphasise the banding.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//////////////////////////////////////////////////////////\n//\n// Illustration of the precision distribution of linear\n// and sRGB formats.\n//\n// A ramp of 64 shades of each colour is shown to\n// emphasise the distribution of banding in each format.\n// Real formats of course have 256 shades.\n// \n// The leftmost bar of each colour is a linear format\n// As you can see, although this format is linear in\n// \"photons per second\", the difference in shades between\n// the darker bands is far more obvious to the eye than\n// the difference between the brighter bands. Thus,\n// although linear space is a good place to do maths,\n// when stored in a buffer the distribution of precision\n// is poorly matched to the eye's preception of brightness.\n//\n// The middle bar of each colour is an sRGB format.\n// While this is a strange non-linear format, and doing\n// maths in it is not a good idea, it is an excellent\n// format for storing \"picturelike\" data. You can see\n// that the change in perceived brightness between adjacent\n// bands is very uniform across the entire range of\n// brightnesses, meaning that it has a distribution of\n// precision that matches the eye's perception very well.\n//\n// The rightmost bar of each colour is a gamma 2.2 bar.\n// This is not directly supported by hardware, and is there\n// to illustrate that although it is quite similar to sRGB,\n// there are significant differences between them, and\n// care must be taken if trying to approximate one with\n// the other. In general, it's not worth the very small\n// performance difference.\n//\n//////////////////////////////////////////////////////////\n\n\n// Taken from D3DX_DXGIFormatConvert.inl\nfloat D3DX_FLOAT_to_SRGB ( float val )\n{\n\tif( val < 0.0031308 )\n\t\tval *= 12.92;\n\telse\n\t\tval = 1.055 * pow(val,1.0/2.4) - 0.055;\n\treturn val;\n}\n\n// Taken from D3DX_DXGIFormatConvert.inl\n// Technically this is not bit-exact - that requires a look-up table,\n// but it's accurate enough for our purposes here.\nfloat D3DX_SRGB_to_FLOAT(float val)\n{\n    if( val < 0.04045 )\n        val /= 12.92;\n    else\n        val = pow((val + 0.055)/1.055,2.4);\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float yShade = uv.y;\n\n    int colCol = int(floor(uv.x*4.0));\n\tfloat fraction = uv.x*4.0 - float(colCol);\n    int colRamp = int(floor(fraction * 3.1));\n       \n    // Make the basic colour.\n    vec3 baseCol;\n    if ( colCol == 0 )\n    {\n        baseCol = vec3(yShade,yShade,yShade); // white\n    }\n    else if ( colCol == 1 )\n    {\n        baseCol = vec3(yShade*0.6,yShade,0.0); // light green\n    }\n    else if ( colCol == 2 )\n    {\n        baseCol = vec3(yShade,yShade*0.5,yShade*0.2); // bronzeish\n    }\n    else\n    {\n        baseCol = vec3(yShade*0.5,0.0,yShade); // purple\n    }\n    \n    \n    // Artificially quantise to emphasise precision distribution\n    float shadeSteps = 64.0;\n    baseCol = (1.0/shadeSteps) * floor ( baseCol * shadeSteps );\n    \n    // Now interpret that value as if it was a value stored in a texture of various formats.\n    \n    vec3 linearCol;\n    if ( colRamp == 0 )\n    {\n        // Linear texture\n        linearCol = baseCol;\n    }\n    else if ( colRamp == 1 )\n    {\n        // sRGB texture\n        linearCol.x = D3DX_SRGB_to_FLOAT ( baseCol.x );\n        linearCol.y = D3DX_SRGB_to_FLOAT ( baseCol.y );\n        linearCol.z = D3DX_SRGB_to_FLOAT ( baseCol.z );\n    }\n    else if ( colRamp == 2 )\n    {\n        // 2.2 gamma for illustration\n        linearCol.x = pow ( baseCol.x, 2.2 );\n        linearCol.y = pow ( baseCol.y, 2.2 );\n        linearCol.z = pow ( baseCol.z, 2.2 );\n    }\n    else\n    {\n        // Separator.\n        linearCol = vec3(0.0,0.0,0.0);\n    }\n    \n    \n    // But then assume the display we're outputting to is gamma 2.2\n    float displayGamma = 2.2;\n    fragColor.x = pow ( linearCol.x, 1.0/displayGamma );\n    fragColor.y = pow ( linearCol.y, 1.0/displayGamma );\n    fragColor.z = pow ( linearCol.z, 1.0/displayGamma );\n    fragColor.w = 1.0;\n}","name":"","description":"","type":"image"}]}