{"ver":"0.1","info":{"id":"clSyzW","date":"1692087092","viewed":91,"name":"Polygon Kernel Shapes","username":"servostar","description":"Various custom shapes for sampling kernels tested with a simple bokeh filter. The goal was to create pseudo randomly sampled kernels which do not discard any samples like its classically done in rendering.","likes":8,"published":1,"flags":32,"usePreview":1,"tags":["bokeh","shapes","kernel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define BOX_SAMPLE\n//#define RING\n//#define CIRCLE\n//#define TRIANGLE\n\n#define POLYGON\n\n// wether to fill the polygons\n// comment this out if you only want the outline\n//#define POLYGON_FILL\n\n// amount of vertices for the polygons (does not affect performance)\n#define N 6.0\n\nconst float TWO_PI = 6.283185307179586;\n\nfloat seed = 0.0;\nfloat rand()\n{\n    seed += iTime *.1 + .2874365;\n    return fract(sin(seed * 475.89756) * 45.487);\n}\n\nfloat luminance(in vec3 rgb)\n{\n    return dot(rgb, vec3(0.21, 0.72, 0.07));\n}\n\n/**\n* Intensifies the brightest pixels of the applied kernel based on the luminance() function\n* This is a modified dilation filter\n*/\nvec3 bokeh(in sampler2D tex, in vec2 uv, in float sep)\n{\n    vec3 cc = texture(tex, uv).rgb;\n    vec3 tc = cc;\n    float cl = luminance(cc);\n\n    vec2 texSize = sep/vec2(textureSize(tex, 0));\n\n    for (float i = 0.0; i < 32.0; i++)\n    {\n        // offset of the sample to take\n        vec2 xy;\n    \n        #if defined(BOX_SAMPLE)\n\n            xy = vec2(rand(), rand());\n\n        #elif defined(RING)\n        \n            float r = rand()*TWO_PI;\n            xy = vec2(sin(r), cos(r));\n\n        #elif defined(CIRCLE)\n\n            vec2 rr = vec2(rand(), rand())*vec2(TWO_PI, 1);\n            xy = vec2(sin(rr.x), cos(rr.x))*rr.y;\n\n        #elif defined(TRIANGLE)\n\n            vec2 st = vec2(rand(), rand());\n            xy = vec2(st.x, abs(fract(st.x-0.5)-0.5)*st.y);\n        \n        #elif defined(POLYGON)\n\n            // deriviation: https://www.desmos.com/calculator/wgvjo5jlza\n\n            float w = rand()*TWO_PI;\n\n            float k = N/TWO_PI;\n            float wk = w * k;\n            float fwk = floor(wk);\n            float x = mix(sin(fwk/k), sin(ceil(wk)/k), wk-fwk);\n            float y = mix(cos(fwk/k), cos(ceil(wk)/k), wk-fwk);\n            \n            float r = rand();\n\n            xy = vec2(x,-y);\n                \n            #if defined(POLYGON_FILL)\n            \n                xy *= r;\n            \n            #endif\n\n        #else\n            #error \"no kernel sampling method specified\"\n        #endif\n    \n        vec2 off = xy*texSize;\n        vec3 s = texture(tex, uv + off).rgb;\n        float b = luminance(s);\n\n        if (cl < b)\n        {\n            cl = b;\n            tc = s;\n        }\n    }\n    \n    return tc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 bokeh = bokeh(iChannel0, uv, 48.0);\n    \n    vec3 col = max(texture(iChannel1, fragCoord.xy/iResolution.xy).rgb, bokeh*sqrt(bokeh));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}