{"ver":"0.1","info":{"id":"wsyyRh","date":"1602508774","viewed":299,"name":"Spherical distance primitives","username":"munrocket","description":"Spherical geometry primitives for visualization where SDF is measured as segment of a great circle.\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sdf","primitives","distance","spherical","geodesic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License. Â© 2020 munrocket\n\nfloat ssdHemisphere(vec3 p, vec3 n) {\n    return acos(dot(p, n)) - M_PI_2;\n}\n\nfloat ssdMeridian(vec3 p, vec3 n) {\n    vec3 m = normalize(p - n * dot(n, p));\n    return acos(dot(p, m));\n}\n\nfloat ssdCircle(vec3 p, vec3 o, float r) {\n    return acos(dot(p, o)) - r;\n}\n\nfloat ssdSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 o = normalize(a + b);\n    vec3 j = normalize(cross(a, b));\n    vec3 x = normalize(p - j * dot(p, j));\n    float zone = length(o - x) / length(o - b);\n    x = (zone < 1.) ? x : normalize(o - sign(dot(cross(o, x), j)) * (o - b / dot(o, b)));\n    return acos(dot(p, x)) - r;\n}\n\nfloat ssdBiangle(vec3 p, vec3 a, vec3 b) {\n\tvec3 j = normalize(cross(a, b));\n\tvec3 o = normalize(a + b);\n    p += step(0., dot(cross(p, o), j)) * (reflect(p, cross(j, o)) - p);\n    float db = acos(dot(p, cross(b, j))) - M_PI_2;\n    vec3 px = normalize(p - j * dot(p, j));\n    float dx = acos(dot(p, -px)) - M_PI_2;\n    float zone = acos(dot(p, b)) - M_PI_2;\n    return zone > 0. ? dx : db;\n}\n\nfloat ssdTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n    vec3 ab = normalize(cross(a, b));\n    vec3 bc = normalize(cross(b, c));\n    vec3 ca = normalize(cross(c, a));\n    float da = acos(dot(p, a));\n    float db = acos(dot(p, b));\n    float dc = acos(dot(p, c));\n    float dab = acos(dot(p, ab)) - M_PI_2;\n    float dbc = acos(dot(p, bc)) - M_PI_2;\n    float dca = acos(dot(p, ca)) - M_PI_2;\n    float d = max(dab, max(dbc, dca));\n    float dd = min(da, min(db, dc));\n    d += step(0., min(dot(p, cross(a, ab)), dot(p, cross(ca, a)))) * (dd - d);\n    d += step(0., min(dot(p, cross(b, bc)), dot(p, cross(ab, b)))) * (dd - d);\n    d += step(0., min(dot(p, cross(c, ca)), dot(p, cross(bc, c)))) * (dd - d);\n\treturn d;\n}\n\nfloat ssdRectangle(vec3 p, vec3 o, vec3 c, vec3 i) {\n    vec3 j = normalize(cross(o, i));\n    i = cross(j, o);\n    vec3 k = cross(i, j);\n    p += step(0., dot(cross(p, o), j)) * (reflect(p, i) - p);\n    p += step(0., dot(cross(o, p), i)) * (reflect(p, j) - p);\n    vec3 ic = normalize(cross(j, c));\n    vec3 jc = normalize(cross(c, i));\n    vec3 kc = cross(ic, jc);\n    vec3 px = normalize(p - ic * dot(p, ic));\n    vec3 py = normalize(p - jc * dot(p, jc));\n    float dx = acos(dot(p, px)) * sign(dot(cross(p, px), k));\n    float dy = acos(dot(p, py)) * sign(dot(cross(py, p), k));\n    float zone = min(dot(cross(p, jc), kc), dot(cross(ic, p), kc));\n    return zone > 0. ? acos(dot(c, p)) : max(dx, dy);\n}\n\nvec4 traceSphere(vec3 camera, vec3 dir, float radius) {\n    float k = dot(camera, dir);\n    float c = dot(camera, camera) - radius * radius;\n    float D = k * k - c;\n    if (D < 0.) return vec4(0); \n    float s = -k - sqrt(D);\n    vec3 p = camera + s * dir;\n    return vec4(normalize(p), smoothstep(0., 0.03, D));\n}\n\nvec3 colorize(float d, int cellid) {\n    vec3 col = vec3(1.0) - sign(d)*(vec3(0.1,0.4,0.7) + 0.2 * sin(float(cellid-1)*vec3(1.,4.,7.)));\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\treturn mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 gridsize = vec2(3., 2.);\n    float gridzoom = 1.1;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 cellcoord = fract(uv * gridsize);\n    vec2 ratio = vec2(iResolution.x / gridsize.x / iResolution.y * gridsize.y , 1.0);\n    vec2 xy = (2. * cellcoord - 1.) / gridzoom * ratio;\n    \n    vec3 dir = normalize(vec3(xy, -2.));\n    vec3 camera = vec3(0., 0., 2.5);\n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.02);\n    camera = rotate(camera, mouse);\n    dir = rotate(dir, mouse);\n    \n    vec4 t = traceSphere(camera, dir, 1.);\n    vec3 p = t.xyz;\n    float r = 0.1 + 0.1 * cos(2. * iTime);\n    float d;\n    \n    vec2 cellgrid = floor(uv * gridsize);\n    int cellid = int((gridsize.x - 1.) * gridsize.y - cellgrid.y * gridsize.x + cellgrid.x);\n    if (cellid == 1) {\n        d = ssdMeridian(p, vec3(0,1,0)) - r;\n    } else if (cellid == 2) {\n        d = ssdCircle(p, normalize(vec3(0,0,1)), r);\n    } else if (cellid == 3) {\n        d = ssdSegment(p, normalize(vec3(.3,0,1)), normalize(vec3(-.3,0,1)), 0.) - r;\n    } else if (cellid == 4) {\n        d = ssdBiangle(p, normalize(vec3(0,.15,1)), normalize(vec3(0,-.15,1))) - r;\n    } else if (cellid == 5) {\n        d = ssdTriangle(p, normalize(vec3(-.2,-.2,1)), normalize(vec3(.2,-.2,1)), normalize(vec3(0,.15,1)))-r;\n    } else if (cellid == 6) {\n        d = ssdRectangle(p, vec3(0,0,1), normalize(vec3(.4,.2,1.)), vec3(1,0,0)) - r;\n    }\n    \n    vec3 col = colorize(d, cellid) * t.w;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n#define M_PI_4 0.7853982\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}","name":"Common","description":"","type":"common"}]}