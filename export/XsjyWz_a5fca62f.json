{"ver":"0.1","info":{"id":"XsjyWz","date":"1491648696","viewed":1744,"name":"Atmosphere spectral rendering","username":"sergey_reznik","description":"Atmosphere scattering using spectral rendering","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["spectrum","scattering","atmosphere","rayleigh","spectral","mie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * https://www.fourmilab.ch/documents/specrend/\n * https://en.wikipedia.org/wiki/Planck%27s_law\n */\n\n#define ONE_SAMPLE 0 // RGB only\n\n#define MIN_WL 380.0\n#define WL_STEP 5.0\n#define MAX_WL 780.0\n\n#define MIN_TEMP 800.0\n#define MAX_TEMP 12000.0\n\n#define SPECTRUM_SAMPLES 81\n\n#define PI 3.1415926\n#define inScatteringSamples 32\n#define outScatteringSamples 32\n#define atmosphereHeight (100e+3)\n#define height (0.0)\n#define Re (6371e+3)\n#define Ra (Re + atmosphereHeight) \n#define H0r (7994.0)\n#define H0m (1200.0)\n#define mieG 0.85\n#define positionOnPlanet vec3(0.0, Re + height, 0.0)\n\n#define exposure 5.0e-14\n\nconst vec3 cie[SPECTRUM_SAMPLES] = vec3[](\n    vec3(0.0014, 0.0000, 0.0065), vec3(0.0022, 0.0001, 0.0105), vec3(0.0042, 0.0001, 0.0201),\n    vec3(0.0076, 0.0002, 0.0362), vec3(0.0143, 0.0004, 0.0679), vec3(0.0232, 0.0006, 0.1102),\n    vec3(0.0435, 0.0012, 0.2074), vec3(0.0776, 0.0022, 0.3713), vec3(0.1344, 0.0040, 0.6456),\n    vec3(0.2148, 0.0073, 1.0391), vec3(0.2839, 0.0116, 1.3856), vec3(0.3285, 0.0168, 1.6230),\n    vec3(0.3483, 0.0230, 1.7471), vec3(0.3481, 0.0298, 1.7826), vec3(0.3362, 0.0380, 1.7721),\n    vec3(0.3187, 0.0480, 1.7441), vec3(0.2908, 0.0600, 1.6692), vec3(0.2511, 0.0739, 1.5281),\n    vec3(0.1954, 0.0910, 1.2876), vec3(0.1421, 0.1126, 1.0419), vec3(0.0956, 0.1390, 0.8130),\n    vec3(0.0580, 0.1693, 0.6162), vec3(0.0320, 0.2080, 0.4652), vec3(0.0147, 0.2586, 0.3533),\n    vec3(0.0049, 0.3230, 0.2720), vec3(0.0024, 0.4073, 0.2123), vec3(0.0093, 0.5030, 0.1582),\n    vec3(0.0291, 0.6082, 0.1117), vec3(0.0633, 0.7100, 0.0782), vec3(0.1096, 0.7932, 0.0573),\n    vec3(0.1655, 0.8620, 0.0422), vec3(0.2257, 0.9149, 0.0298), vec3(0.2904, 0.9540, 0.0203),\n    vec3(0.3597, 0.9803, 0.0134), vec3(0.4334, 0.9950, 0.0087), vec3(0.5121, 1.0000, 0.0057),\n    vec3(0.5945, 0.9950, 0.0039), vec3(0.6784, 0.9786, 0.0027), vec3(0.7621, 0.9520, 0.0021),\n    vec3(0.8425, 0.9154, 0.0018), vec3(0.9163, 0.8700, 0.0017), vec3(0.9786, 0.8163, 0.0014),\n    vec3(1.0263, 0.7570, 0.0011), vec3(1.0567, 0.6949, 0.0010), vec3(1.0622, 0.6310, 0.0008),\n    vec3(1.0456, 0.5668, 0.0006), vec3(1.0026, 0.5030, 0.0003), vec3(0.9384, 0.4412, 0.0002),\n    vec3(0.8544, 0.3810, 0.0002), vec3(0.7514, 0.3210, 0.0001), vec3(0.6424, 0.2650, 0.0000),\n    vec3(0.5419, 0.2170, 0.0000), vec3(0.4479, 0.1750, 0.0000), vec3(0.3608, 0.1382, 0.0000),\n    vec3(0.2835, 0.1070, 0.0000), vec3(0.2187, 0.0816, 0.0000), vec3(0.1649, 0.0610, 0.0000),\n    vec3(0.1212, 0.0446, 0.0000), vec3(0.0874, 0.0320, 0.0000), vec3(0.0636, 0.0232, 0.0000),\n    vec3(0.0468, 0.0170, 0.0000), vec3(0.0329, 0.0119, 0.0000), vec3(0.0227, 0.0082, 0.0000),\n    vec3(0.0158, 0.0057, 0.0000), vec3(0.0114, 0.0041, 0.0000), vec3(0.0081, 0.0029, 0.0000),\n    vec3(0.0058, 0.0021, 0.0000), vec3(0.0041, 0.0015, 0.0000), vec3(0.0029, 0.0010, 0.0000),\n    vec3(0.0020, 0.0007, 0.0000), vec3(0.0014, 0.0005, 0.0000), vec3(0.0010, 0.0004, 0.0000),\n    vec3(0.0007, 0.0002, 0.0000), vec3(0.0005, 0.0002, 0.0000), vec3(0.0003, 0.0001, 0.0000),\n    vec3(0.0002, 0.0001, 0.0000), vec3(0.0002, 0.0001, 0.0000), vec3(0.0001, 0.0000, 0.0000),\n    vec3(0.0001, 0.0000, 0.0000), vec3(0.0001, 0.0000, 0.0000), vec3(0.0000, 0.0000, 0.0000));\n\nconst mat3 xyz_to_rgb_matrix = mat3(\n\t3.240479, -1.537150, -0.498535,\n    -0.969256, 1.875992, 0.041556,\n    0.055648, -0.204043, 1.057311);\n\nvec3 spectrum_to_xyz(in float w)\n{\n    w = clamp(w, MIN_WL, MAX_WL) - MIN_WL;\n    float n = floor(w / WL_STEP);\n    int n0 = min(SPECTRUM_SAMPLES - 1, int(n));\n    int n1 = min(SPECTRUM_SAMPLES - 1, n0 + 1);\n    float t = w - (n * WL_STEP);\n    return mix(cie[n0], cie[n1], t / WL_STEP);\n}\n\nvec3 xyz_to_rgb(in vec3 xyz)\n{\n    return xyz * xyz_to_rgb_matrix;\n}\n\nfloat black_body_radiation(in float temperature, in float wavelength)\n{\n    float e = exp(1.4387752e+7 / (temperature * wavelength));\n    return 3.74177e+29 / (pow(wavelength, 5.0) * (e - 1.0));\n}\n\nvec4 black_body_radiation(in float t, in vec4 w)\n{\n    return vec4(\n        black_body_radiation(t, w.x), \n        black_body_radiation(t, w.y), \n        black_body_radiation(t, w.z),\n        black_body_radiation(t, w.w));\n}\n\nvec3 toneMapping(vec3 color)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    float W = 11.2;\n    float GAMMA_CORRECTION_OUT = 1.0 / 2.2;\n    color *= exposure;\n    color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n    float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n    return pow(abs(color / white), vec3(GAMMA_CORRECTION_OUT, GAMMA_CORRECTION_OUT, GAMMA_CORRECTION_OUT));\n}\n\nfloat atmosphereIntersection(in vec3 origin, in vec3 direction)\n{\n    float b = dot(direction, origin);\n    float d = b * b - dot(origin, origin) + Ra * Ra;\n    return (d >= 0.0) ? (-b + sqrt(d)) : 0.0;\n}\n\nfloat planetIntersection(in vec3 origin, in vec3 direction)\n{\n    float b = dot(direction, origin);\n    float d = b * b - dot(origin, origin) + Re * Re;\n    return (d >= 0.0) ? (-b - sqrt(d)) : 0.0;\n}\n\nfloat phaseFunctionRayleigh(in float cosTheta)\n{\n    return (3.0 / 4.0) * (1.0 + cosTheta * cosTheta);\n}\n\nfloat phaseFunctionMie(in float cosTheta, in float g)\n{\n    return (3.0 * (1.0 - g * g) * (1.0 + cosTheta * cosTheta)) / \n        (2.0 * (2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * cosTheta, 3.0 / 2.0));\n}\n\nvec2 density(in vec3 pos)\n{\n    float h = max(0.0, length(pos) - Re);\n    return vec2(exp(-h / H0r), exp(-h / H0m));\n}\n\nvec2 opticalDensity(in vec3 from, in vec3 to)\n{\n    vec3 dp = (to - from) / float(outScatteringSamples);\n\n    vec2 result = vec2(0.0);\n    for (int i = 0; i < outScatteringSamples; ++i)\n    {\n        result += density(from);\n        from += dp;\n    }\n    return result * length(dp);\n}\n\nfloat in_scattering(in vec3 target, in vec3 light, in vec2 phase, in float betaR, in float betaM)\n{\n    vec3 posStep = (target - positionOnPlanet) / float(inScatteringSamples);\n    float ds = length(posStep);\n\n    float resultR = 0.0;\n    float resultM = 0.0;\n    vec3 pos = positionOnPlanet;\n    vec2 opticalDepthToCamera = vec2(0.0);\n    for (int i = 0; i < inScatteringSamples; ++i)\n    {\n        vec2 d = density(pos);\n        vec2 opticalDepthToLight = opticalDensity(pos, pos + light * atmosphereIntersection(pos, light));\n        vec2 total_optical_depth = opticalDepthToCamera + opticalDepthToLight;\n        float transmittance = exp(-betaR * total_optical_depth.x - betaM * total_optical_depth.y);\n        resultR += d.x * transmittance;\n        resultM += d.y * transmittance;\n        \n        opticalDepthToCamera += d * ds;\n        pos += posStep;\n    }\n    \n    return (resultR * betaR * phase.x + resultM * betaM * phase.y) * (ds / (4.0 * PI));\n}\n\nvec3 fromSpherical(in float phi, in float theta)\n{\n    return vec3(cos(phi) * cos(theta), sin(theta), sin(phi) * cos(theta));\n}\n\nfloat betaR(in float wl)\n{\n    wl /= 100.0;\n    float wl2 = wl * wl;\n    return (0.012) / (wl2 * wl2);\n}\n\nfloat betaM(in float wl)\n{\n    wl /= 100.0;\n    return 2.913e-4 / (wl * wl);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float u = fragCoord.x / iResolution.x;\n    float v = fragCoord.y / iResolution.y;\n    \n    if (v < 0.025)\n    {\n        /*\n \t\t * spectrum test \n\t\t */ \n\t\tvec3 xyz = spectrum_to_xyz(mix(MAX_WL, MIN_WL, u));\n        fragColor = vec4(xyz_to_rgb(xyz), 1.0);\n        return;\n    }\n    \n    if (v < 0.05)\n    {\n        /* \n \t\t * color temperature test \n\t\t */\n        float t = mix(MIN_TEMP, MAX_TEMP, u);\n        \n        vec3 xyz = vec3(0.0);\n        for (float w = MIN_WL; w < MAX_WL; w += WL_STEP)\n        {\n            float r = black_body_radiation(t, vec4(w)).x;\n            xyz += r * spectrum_to_xyz(w);\n        }\n        \n        vec3 result = xyz_to_rgb(xyz);\n        result /= max(result.x, max(result.y, result.z));\n        fragColor = vec4(result, 1.0);\n        return;\n    }\n\n    float time_scale = 1.0 / 32.0;\n    \n    vec3 light = fromSpherical(time_scale * iTime, cos(time_scale * iTime) * 0.75 + 0.25);\n    vec3 dir = fromSpherical(2.0 * PI * u, v * PI - PI / 2.0);\n    float a = atmosphereIntersection(positionOnPlanet, dir);\n    vec3 target = positionOnPlanet + a * dir;\n    \n    float cosTheta = dot(dir, light);\n    vec2 phase = vec2(phaseFunctionRayleigh(cosTheta), phaseFunctionMie(cosTheta, mieG));\n\n\tvec3 xyz = vec3(0.0);\n    for (int i = 0; i < SPECTRUM_SAMPLES; ++i)\n    {\n        float wl = 360.0 + float(MAX_WL - MIN_WL) * float(i) / float(SPECTRUM_SAMPLES - 1);\n        float radiation = black_body_radiation(6500.0, wl);\n\t\tfloat s = radiation * in_scattering(target, light, phase, betaR(wl), betaM(wl));\n        xyz += 0.25 * s * spectrum_to_xyz(wl);\n    }\n    \n    vec3 result = xyz_to_rgb(xyz);\n    fragColor = vec4(toneMapping(result), 1.0);\n}","name":"Image","description":"","type":"image"}]}