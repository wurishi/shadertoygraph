{"ver":"0.1","info":{"id":"4ftBWX","date":"1733615414","viewed":28,"name":"Non-Iterative Ray Tracing","username":"Rogprog","description":"Mirror effect with one step plane and sphere raytracer","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"MftfW2","parentname":"Mirror Box demo"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define N 10\n\nstruct info {\n\n    vec3 normal;\n    \n    vec3 sphereNormal;\n    \n    vec3 point;\n    \n    float dist;\n\n    bool Hit;\n\n};\n\n\n\nvec3 rotate3D(vec3 v, vec3 axis, float angle) {\n    axis = normalize(axis); // Ensure axis is a unit vector\n    float c = cos(angle);\n    float s = sin(angle);\n    float dotA = dot(v, axis);\n    return v * c + cross(axis, v) * s + axis * dotA * (1.0 - c);\n}\n\nvec3 rotateZ(vec3 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 rotationMatrix = mat3(\n        c, -s, 0.0,\n        s,  c, 0.0,\n        0.0, 0.0, 1.0\n    );\n    return rotationMatrix * v;\n}\n\nvec3 rotateY(vec3 v,float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 rotationMatrix = mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n    \n    return rotationMatrix * v;\n    \n}\n// Function to compute the projection of p onto a\nvec3 projection(vec3 p, vec3 a) {\n    return dot(p, a) / dot(a, a) * a;\n}\n\n// Function to compute the normal (perpendicular) component of p relative to a\nvec3 normalComponent(vec3 p, vec3 a) {\n    return p - projection(p, a);\n}\n\n\nbool findPlanePoint(vec3 rayOrigin,vec3 rayDir,vec3 planePoint, vec3 u, vec3 v, float a, float b, out info ret) {\n\n    vec3 planeNormal = normalize(cross(u, v));\n\n    // Check for parallel ray\n    float denom = dot(rayDir, planeNormal);\n    if (abs(denom) < 1e-6) {\n        return false; // No intersection or parallel ray\n    }\n\n    // Compute t\n    float t = dot(planePoint - rayOrigin, planeNormal) / denom;\n\n    // Intersection point\n    vec3 ints = rayOrigin + t * rayDir;\n\n    vec3 pu = projection(ints - planePoint,u);\n    vec3 pv = projection(ints - planePoint,v);\n\n    if ((length(pu) < a) && (length(pv) < b)) {\n    \n        ret.normal = normalize(cross(u,v));\n        ret.point = ints;\n        \n        return true;\n                    \n    }\n\n    return false;\n\n}\n\nbool findSpherePoint(vec3 rayOrigin,vec3 rayDir,vec3 sphereCenter,float sphereRadius,out info ret) {\n\n    vec3 oc = rayOrigin - sphereCenter; // Vector from sphere center to ray origin\n    float a = dot(rayDir, rayDir);      // A = 1 if rayDir is normalized\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return false; // No intersection\n    }\n    \n    // Solve for t (smallest positive root)\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    float t = (t1 > 0.0) ? t1 : t2; // Use the smallest positive t\n    if (t < 0.0) {\n        return false; // No positive intersection\n    }\n    \n    // Compute the intersection point\n    vec3 intersectionPoint = rayOrigin + t * rayDir;\n    \n    ret.normal = normalize(intersectionPoint - sphereCenter);\n    ret.point = intersectionPoint;\n    \n    return true;\n\n}\n\nfloat hash(int n) {\n    return fract(sin(float(n)) * 43758.5453123);\n}\n\n\n\nbool findSpheresPoint(vec3 rayOrigin,vec3 rayDir, out info ret) {\n\n    vec3 pos[N];\n    vec3 axis[N];\n\n    info sphereInfo;\n\n    info foundInfo;\n\n    bool foundSphere = false;\n\n    for (int i = 0; i < N ; i++) {\n\n        pos[i] = vec3(hash(i + 4)*6.0-3.0,hash(i+12)*6.0-3.0,hash(i+21)*6.0-3.0);\n        \n        axis[i] = normalize(vec3(hash(i+3),hash(i+11),hash(i+26)));\n        \n        pos[i] = rotate3D(pos[i],axis[i],iTime*hash(i+99)*4.0);\n\n        vec3 boxCenter = vec3(0.0,0.0,-1.0);\n\n        bool sphereBool = findSpherePoint(rayOrigin,rayDir,boxCenter + pos[i],hash(i+222)*0.6,sphereInfo);\n    \n        float near = 10000.0;\n        \n        if (sphereBool) {\n        \n            if (length(sphereInfo.point) < near) {\n            \n                foundInfo = sphereInfo;\n            \n                near = length(sphereInfo.point);\n                \n                foundSphere = true;\n                \n            }\n            \n        }\n        \n    }\n\n\n    foundInfo.dist = length(foundInfo.point);\n\n    foundInfo.Hit = false;\n        \n    ret = foundInfo;\n\n    return foundSphere;\n\n}\n\n\nbool findBoxPoint(vec3 rayOrigin,vec3 rayDir,vec3 boxCenter, float size, out info ret) {\n\n    float hd2 = size;\n\n    vec3 bu[6] = vec3[6](\n        vec3(0.0,0.0,-1.0),\n        vec3(0.0,0.0,-1.0),\n        vec3(0.0,-1.0,0.0),\n        vec3(0.0,-1.0,0.0),\n        vec3(-1.0,0.0,0.0),\n        vec3(-1.0,0.0,0.0));\n\n    vec3 bv[6] = vec3[6](\n        vec3(0.0,1.0,0.0),\n        vec3(0.0,-1.0,0.0),\n        vec3(1.0,0.0,0.0),\n        vec3(-1.0,0.0,0.0),\n        vec3(0.0,0.0,1.0),\n        vec3(0.0,0.0,-1.0));\n        \n    vec3 pp[6] = vec3[6](\n        vec3(hd2,0.0,0.0),\n        vec3(-hd2,0.0,0.0),\n        vec3(0.0,0.0,hd2),\n        vec3(0.0,0.0,-hd2),\n        vec3(0.0,hd2,0.0),\n        vec3(0.0,-hd2,0.0));\n        \n        \n    float near = 10000.0;\n        \n    info foundInfo;\n        \n    bool foundBox = false;\n    \n    vec3 foundNormal;\n        \n    for (int i = 0; i < 6 ; i++) {\n    \n        vec3 uu = rotateY(bu[i],iTime);\n        vec3 vv = rotateY(bv[i],iTime); \n        vec3 p = rotateY(pp[i],iTime); \n \n \n        uu = rotateZ(uu,iTime*2.5);\n        vv = rotateZ(vv,iTime*2.5); \n        p = rotateZ(p,iTime*2.5); \n \n        info planeInfo;\n    \n        bool planeBool = findPlanePoint(rayOrigin,rayDir,boxCenter + p,uu,vv,size,size,planeInfo);\n    \n        if (planeBool) {\n        \n            if (length(planeInfo.point) < near) {\n                \n                foundInfo = planeInfo;\n                \n                near = length(planeInfo.point);\n                \n                foundBox = true;\n            \n                foundNormal = normalize(cross(uu,vv));\n            \n            }\n        \n        }\n    \n    }\n       \n    info sphereInfo;\n        \n    bool foundSphere = findSpheresPoint(foundInfo.point,foundNormal,sphereInfo);\n        \n    sphereInfo.dist = length(foundInfo.point);\n                \n    sphereInfo.Hit = foundBox;\n                \n    ret = sphereInfo;\n       \n    return foundSphere;\n        \n}\n\nbool findReflectiveSphere(vec3 rayOrigin,vec3 rayDir,vec3 sphereCenter, float radius, out info ret) {\n\n\n    info sphereInfo;\n\n    bool sphereBool = findSpherePoint(rayOrigin,rayDir,sphereCenter,radius,sphereInfo);\n\n    if (!sphereBool)\n        return false;\n    \n    \n    \n    info spheresInfo;\n        \n    bool foundSphere = findSpheresPoint(sphereInfo.point,sphereInfo.normal,spheresInfo);\n\n    spheresInfo.Hit = sphereBool;\n\n    spheresInfo.sphereNormal = sphereInfo.normal;\n\n    ret = spheresInfo;\n    \n    return sphereBool;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   \n    float factor = 1.0/iResolution.y;\n   \n    vec2 uv = vec2(2.0*fragCoord*factor) - vec2(iResolution.x*factor,1.0);\n\n\n    vec3 rayOrigin = vec3(uv,1.0);\n    \n    vec3 rayDir = normalize(vec3(uv,-1));\n\n    vec3 p = vec3(0.0,0.0,-1.0);\n\n\n    vec3 a = vec3(1.0,0.0,0.0);\n    vec3 b = vec3(0.0,1.0,0.0);\n\n    vec3 axis = normalize(vec3(1.0,0.2,0.2));\n    \n    //a = rotate3D(a,axis,iTime);\n    //b = rotate3D(b,axis,iTime);\n    \n    vec3 aa = rotateZ(a,iTime/0.7);\n    vec3 bb = rotateZ(b,iTime/0.7);\n    \n    aa = rotateY(aa,iTime/1.1);\n    bb = rotateY(bb,iTime/1.1);\n    \n    //info planeInfo;\n    \n    //bool planeBool = findPlanePoint(rayOrigin,rayDir,p,aa,bb,length(a),length(b),planeInfo);\n    \n    info boxInfo;\n    \n    bool sphereInBoxBool = findBoxPoint(rayOrigin,rayDir,vec3(0.0,0.0,-2.0), 1.0, boxInfo);\n\n    \n    vec3 lightPos = vec3(1.0,0.0,0.6);\n    \n    lightPos = rotate3D(lightPos,axis,iTime);\n    \n    float boxDiffuse = max(0.0,dot(boxInfo.normal,-lightPos));\n    \n    \n    \n    info sphereInfo;\n    \n    //bool sphereBool = findSpherePoint(rayOrigin,rayDir,sphereCenter,0.5,sphereInfo);\n    \n    bool sphereBool = findSpheresPoint(rayOrigin,rayDir, sphereInfo);\n    \n    float sphereDiffuse = max(0.0,dot(normalize(sphereInfo.normal),-lightPos));\n    \n    \n    info reflectiveSphereInfo;\n    \n    bool reflectiveSphereBool = findReflectiveSphere(rayOrigin,rayDir,vec3(2.0,0.0,0.0),0.4,reflectiveSphereInfo);\n\n    float reflectiveSphereDifuse = max(0.0,dot(reflectiveSphereInfo.sphereNormal,-lightPos));\n\n    float reflectionDifuse = max(0.0,dot(reflectiveSphereInfo.normal,-lightPos));\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0,0.0,0.0);\n\n    if (reflectiveSphereInfo.Hit) {\n    \n        if (!reflectiveSphereBool) {\n        \n            col = vec3(0.2,0.2,0.2) + vec3(0.0,0.8,0.0) * reflectiveSphereDifuse;\n            \n        } else {\n        \n            col = vec3(0.2,0.2,0.2) + vec3(0.0,0.8,0.0) * reflectionDifuse;\n\n        }\n    \n    } else if (sphereInBoxBool && sphereBool) {\n    \n        if (sphereInfo.dist > boxInfo.dist) {\n           \n           col = vec3(0.1,0.1,0.1) + vec3(0.0,0.9,0.0) * boxDiffuse;\n        \n        } else {\n    \n            col = vec3(0.1,0.0,0.0) + vec3(0.0,0.9,0.0) * sphereDiffuse;\n\n        }\n     \n    } else if (sphereInBoxBool) {\n     \n        col = vec3(0.1,0.0,0.0) + vec3(0.0,0.9,0.0) * boxDiffuse;\n     \n    } else if (boxInfo.Hit) {\n    \n        col = vec3(0.1,0.1,0.1);\n        \n    } else if (sphereBool) {\n    \n        col = vec3(0.1,0.1,0.1) + vec3(0.1,0.9,0.0) * sphereDiffuse;     \n    \n    } else {\n    \n        col = vec3(0.0,0.0,0.0);\n        \n    }\n    \n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}