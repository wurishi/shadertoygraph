{"ver":"0.1","info":{"id":"sssXWS","date":"1619193768","viewed":172,"name":"Brewed Refreshment","username":"xx3000","description":"Some things you won't find in the real St. Peter's Basilica.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bubbles","liquid","beer","pint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 128\n#define TIR_RETRACE 1\n#define BOTTLE_NOISE 1\n#define AA 1\n\n#define MISS 0.0\n#define GLASS 1.0\n#define HANDLE 2.0\n#define BUBBLE 3.0\n#define FOAM 4.0\n\n#define RI_AIR 1.0\n#define RI_GLASS 1.52\n#define RI_BOOZE 1.36\n#define RI_PET 1.5750\n\n#define GLASS_THICKNESS 0.01\n#define LOWER_GLASS_EDGE -0.45\n\n#define ROT_45y mat3(0.707106781 , 0 , 0.707106781, 0 , 1, 0, -0.707106781 , 0, 0.707106781);\n\n#define PI 3.1415926\n\n//hash functions from\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//sdf functions by iq\n//https://iquilezles.org/articles/distfunctions\nfloat sphere (vec3 pos, vec3 center, float r)\n{\n    return length(pos-center) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n    \nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 move ( vec3 pos, vec3 amount)\n{\n    return pos + amount;\n}\n\nfloat repeatBubbles(vec3 pos, float dom, vec3 range, float size, vec3 rndCutoff, float speed, bool repeatHeight)\n{     \n    pos.y -= iTime * speed;\n    vec3 center = round(pos/range);\n    float rnd = hash13(center.xyz*5.0);\n    rnd = step(rndCutoff.x, rnd);\n\n    vec3 rep1 = range * clamp(center,-dom,dom);\n\n    vec3 q = pos - rep1;\n    \n    if(repeatHeight)\n        q.y = mod(pos.y+0.5*range.y,range.y)-0.5*range.y;\n    else\n        q.y = pos.y;\n    \n    vec3 distToBorder = (vec3(1.0) - abs(fract(pos/range))) * range;\n    float db = max(distToBorder.z,max(distToBorder.x, distToBorder.y)) * 0.35;\n   \n    float bubbleDist = sphere(q, vec3(0,-0.0,0), size );\n\n    return mix(bubbleDist, db, rnd);\n}\n\nfloat bubbles(vec3 pos)\n{\n    float dist = sdCylinder(pos,vec3(0,0,0.2));\n    float waterHeight = -0.0;\n    \n    dist = opIntersection (dist, sdPlane(pos,vec3(0,1,0),waterHeight - 0.02));\n    dist = opIntersection (dist, sdPlane(pos,vec3(0,-1,0),-0.43));\n    \n    float bDist = repeatBubbles(move(pos,vec3(0)), 5.0, vec3(0.04), 0.001, vec3(0.2), 0.15, true);\n    bDist = opUnion(bDist, repeatBubbles(move(pos,vec3(0.01)), 3.0, vec3(0.06), 0.0015, vec3(0.1), 0.07, true));\n    bDist = opUnion(bDist, repeatBubbles(move(pos,vec3(0.01, 0.2, 0.0)), 3.0, vec3(0.035), 0.0012, vec3(0.3), 0.11, true));\n    \n    dist = opIntersection(dist,bDist);\n    return dist;\n}\n\nvec2 handle(vec3 pos)\n{\n    vec3 rPos = vec3(pos.x,pos.z,pos.y);\n    float dist = sdTorus(move(rPos, vec3(-0.18,0.0,0.2)),vec2(0.15,0.02));\n    return vec2(dist, HANDLE);\n}\n\nvec2 glass(vec3 pos)\n{\n    float dist = sdRoundBox(move(pos, vec3(0,0.2,0)), vec3(0.1,0.25,0.1),0.05);\n    vec3 pos2 = pos * ROT_45y;\n    dist = opSmoothUnion(dist, sdRoundBox(move(pos2, vec3(0,0.2,0)), vec3(0.1,0.25,0.1),0.05), 0.05);\n    dist = opSubtraction(sdPlane(move(pos, vec3(0,-0.07,0)),vec3(0,-1,0),0.0), dist );\n\n    vec2 glass = vec2(dist, GLASS);\n    vec2 handle = handle(pos);\n\n    vec2 result;\n    result.y = glass.x < handle.x ? glass.y : handle.y;\n    result.x = opSmoothUnion(glass.x, handle.x, 0.05);\n    return result;\n}\n\nfloat foam(vec3 pos, bool extend)\n{\n    float dist = sphere(pos, vec3(0,-0.9,0), 1.0 );\n    dist = opSmoothUnion(sphere(pos, vec3(0.045,0.03,0.045), 0.1 ), dist, 0.05);\n    dist = opSmoothUnion(sphere(pos, vec3(0.0,0.03,-0.05), 0.1 ), dist, 0.07);\n    dist = opSmoothUnion(sphere(pos, vec3(-0.04,0.03,0.055), 0.1 ), dist, 0.04);\n    \n    float gdist = sdRoundBox(move(pos, vec3(0,0.2,0)), vec3(0.1,0.25,0.1),0.05);\n    vec3 pos2 = pos * ROT_45y;\n    gdist = opSmoothUnion(gdist, sdRoundBox(move(pos2, vec3(0,0.2,0)), vec3(0.1,0.25,0.1),0.05), 0.05);\n    gdist = opUnion(gdist, sdPlane(pos, vec3(0, -1, 0), 0.1));\n    \n    dist = opSubtraction(-gdist, dist);\n    \n    if(!extend)\n    {   \n        dist = opSubtraction(sdPlane(pos, vec3(0, 1, 0), 0.0), dist);\n    }\n\n    return dist;\n}\n\n\nvec2 field(vec3 pos)\n{\n    return glass(pos);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*field( pos + e.xyy*eps).x + \n\t\t\t\t\t  e.yyx*field( pos + e.yyx*eps).x + \n\t\t\t\t\t  e.yxy*field( pos + e.yxy*eps).x + \n\t\t\t\t\t  e.xxx*field( pos + e.xxx*eps).x );\n}\n\nvec3 calcFoamNormal( vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*foam( pos + e.xyy*eps , false) + \n\t\t\t\t\t  e.yyx*foam( pos + e.yyx*eps , false) + \n\t\t\t\t\t  e.yxy*foam( pos + e.yxy*eps , false) + \n\t\t\t\t\t  e.xxx*foam( pos + e.xxx*eps , false) );\n}\n\n\nvec2 rayMarch(vec3 ro, vec3 rd, float inv)\n{\n    const float tmax = 3.0;\n    float t = 0.0;\n    float material = MISS;\n    for( int i=0; i<MAX_STEPS && t < tmax; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec2 h = field(pos);\n        h.x *= inv;\n        if( h.x < 0.0001) \n        {\n            material = h.y;\n            break;\n        }\n        t += h.x;\n    }\n    \n    return vec2(t, material);\n}\n\nvec2 rayMarchBubbles(vec3 ro, vec3 rd)\n{\n    const float tmax = 3.0;\n    float t = 0.0;\n    float material = MISS;\n    for( int i=0; i<MAX_STEPS && t < tmax; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = bubbles(pos);\n        if( h < 0.0001) \n        {\n            material = BUBBLE;\n            break;\n        }\n        t += h;\n    }\n    \n    return vec2(t, material);\n}\n\nvec2 rayMarchFoam(vec3 ro, vec3 rd, float inv, bool extend)\n{\n    const float tmax = 3.0;\n    float t = 0.0;\n    float material = MISS;\n    for( int i=0; i<MAX_STEPS && t < tmax; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = foam(pos, extend);\n        h *= inv;\n        if( h < 0.0001) \n        {\n            material = FOAM;\n            break;\n        }\n        t += h;\n    }\n    \n    return vec2(t, material);\n}\n\n//schlick's fresnel approx\nfloat fres(vec3 rd, vec3 nor, float n1, float n2)\n{\n    \n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 = r0 * r0;\n    float cosTheta = 1.0 - dot(-rd,nor);\n    cosTheta = cosTheta*cosTheta*cosTheta*cosTheta*cosTheta;\n    return r0 + ( 1.0 - r0) * cosTheta;\n}\n\n//move the ray by the bottle thickness adjusted by angle\nvec3 calcAdjustedInnerWallHit(vec3 pos, vec3 nor, vec3 dir)\n{\n    float refrCos =  1.0 + 1.0 - dot(-nor, dir);\n    return pos + (GLASS_THICKNESS * refrCos * dir);   \n}\n\nvec3 calcInvAdjustedInnerWallHit(vec3 pos, vec3 nor, vec3 dir)\n{\n    float refrCos =  dot(-nor, dir);\n    return pos + (0.05 * refrCos * dir);   \n}\n\nfloat rayPlane (vec3 ro, vec3 rd, vec4 plane)\n{\n    float denom = dot(rd, plane.xyz);\n    if(denom == 0.0)\n    return -1.0;\n    return dot((plane.xyz*plane.z) - ro, plane.xyz) / denom;\n}\n\nvec3 sampleCubemap(vec3 dir, float f)\n{\n    return texture(iChannel0, dir).xyz ;\n}\n\nvec3 shadeBottle(vec3 ro, vec3 rd, vec2 hit, vec3 nor, vec3 pos)\n{\n    vec3 color;\n \n    bool blur = false;\n \n    float rrAG = RI_AIR / RI_GLASS;\n    float rrAB = RI_AIR / RI_BOOZE;\n    float rrGA = RI_GLASS;\n    float rrGB = RI_GLASS / RI_BOOZE;\n    float rrBG = RI_BOOZE / RI_GLASS;\n    float rrBA = RI_BOOZE;\n\n    //refraction 1 air - glass\n    vec3 refrDir = refract(rd, nor, rrAG);\n    \n    //hacked uv estimation\n    vec3 rotPos = pos;\n    vec2 cyl = (normalize(vec2(rotPos.x, rotPos.z)));\n    float nHeight = rotPos.y*4.0 + 0.45;\n\n    float lum = 1.0;\n#if BOTTLE_NOISE == 1\n    vec2 noise = texture(iChannel1, vec2(atan(cyl.x, cyl.y), nHeight) * 5.0).xy;\n    vec3 decal = texture(iChannel2, vec2(atan(cyl.x, cyl.y), nHeight) * 0.05).xyz;\n    lum = decal.x+decal.y+decal.z / 3.0;\n    lum = clamp(lum * 2.0, 0.8,1.0);\n    \n    float u = noise.x;\n    float v = noise.y;\n    \n    \n\tfloat a = 6.2831853 * v;\n\tu = 2.0*u - 1.0;\n    float magn = 0.003;\n\trefrDir =  normalize(refrDir + vec3(sqrt(1.0 - u * u) * vec2(cos(a), sin(a)), u) * magn);\n\n#endif\n    \n    vec3 initialRefr = refrDir;\n    \n    vec3 innerWallPos = calcAdjustedInnerWallHit(pos, nor, refrDir);\n    vec3 innerNormal = calcNormal(innerWallPos);\n    \n    //refraction 2 glass - inner\n    float rr = rrGB;\n    \n    refrDir = refract(refrDir, innerNormal, rr);\n    float isTIR = dot(refrDir, refrDir);\n    \n\n    \n    //total internal reflection, immediately trace to the outside\n    vec3 finalTirDir = initialRefr;\n#if TIR_RETRACE == 1\n\n    bool isLowerEdge = innerWallPos.y < LOWER_GLASS_EDGE;\n    if(isTIR == 0.0  || isLowerEdge)\n    {\n        vec3 tirDir = reflect(initialRefr, innerNormal);\n        vec3 tirWallPos = calcAdjustedInnerWallHit(innerWallPos, innerNormal, tirDir);\n        vec3 tirNormal = calcNormal(tirWallPos);\n\n        finalTirDir = tirDir;\n\n        //refraction 2 glass - air\n        finalTirDir = refract(tirDir, -tirNormal, rrGA);\n    }\n#endif\n\n    bool hitBubbles = false;\n    if(isTIR > 0.0)\n    {\n        //secondary trace through the bottle\n        vec3 refRo = innerWallPos + refrDir * 0.0011;\n        vec2 refHit= rayMarch(refRo, refrDir, -1.0);\n        refRo = innerWallPos + refrDir * 0.001;\n        \n        vec3 backPos = refRo + refHit.x*refrDir;\n        \n        hitBubbles = rayMarchBubbles(refRo, refrDir).y != MISS;\n        \n        \n        if(!hitBubbles)\n        {           \n            vec3 backNor = calcNormal(backPos);\n\n            //refraction 3 inner - glass\n            rr = rrBG;\n            refrDir = refract(refrDir, -backNor, rr);\n\n            vec3 outerWallPos = calcAdjustedInnerWallHit(backPos, -backNor, refrDir);\n            vec3 outerNormal = calcNormal(outerWallPos);\n\n            finalTirDir = refrDir;\n            //refraction 4 glass - air\n            refrDir = refract(refrDir, -outerNormal, rrGA);\n            isTIR = dot(refrDir, refrDir);\n        }\n        \n    }\n\n    color = sampleCubemap(refrDir, 0.0);\n    \n#if TIR_RETRACE == 1\n    if(isTIR == 0.0 || isLowerEdge)\n    {   \n        vec3 colorTIR = sampleCubemap(finalTirDir, 0.0);\n        if(isTIR == 0.0)\n        {\n            color = colorTIR;\n        }\n    \n        if(isLowerEdge)\n        {\n            color = mix(color, colorTIR, smoothstep(LOWER_GLASS_EDGE,LOWER_GLASS_EDGE - 0.01,innerWallPos.y));\n        }\n    }\n    \n#endif\n    \n    float interp = 1.0-min(1.0,max(0.0,-(pos.y + 0.05) * 10.0));\n    vec3 prevCol = color;\n    color = mix(color * vec3(1.0,0.9,0.2588), vec3(0.4,0.18,0.05),interp);\n    color = mix(color, prevCol,  1.0-min(1.0,max(0.0,(innerWallPos.y - LOWER_GLASS_EDGE + 0.02) * 10.0)));\n\n    if(hitBubbles)\n    {\n       lum = 1.5;\n    }\n    return color * lum;\n}\n\nvec3 shading(vec3 ro, vec3 rd, vec2 hit)\n{\n    vec3 pos = ro + hit.x*rd;\n\n    vec3 nor = calcNormal(pos);\n\n    vec3 diffcol = vec3(0,0,0);      \n    \n    if( hit.y == GLASS || hit.y == HANDLE)\n    {\n        diffcol = shadeBottle(ro, rd, hit, nor, pos);\n    }\n    \n    if( hit.y == HANDLE)\n    {\n        float rrAG = RI_AIR / RI_GLASS;\n        float rrGA = RI_GLASS;\n            //refraction 1 air - glass\n        vec3 refrDir = refract(rd, nor, rrAG);\n        vec3 prevDir = refrDir;\n        vec3 backPos = calcInvAdjustedInnerWallHit(pos, nor, refrDir);\n        vec3 outerNormal = calcNormal(backPos);\n        refrDir = refract(refrDir, -outerNormal, rrGA);\n        float isTIR = dot(refrDir, refrDir);\n        if(isTIR == 0.0)\n        {\n            refrDir = prevDir;\n        }\n        vec3 handleCol = sampleCubemap(refrDir, 0.0);\n        diffcol = mix(diffcol, handleCol, clamp((length(pos.xz) - 0.20) * 20.0,0.0,1.0));\n    }\n     \n    \n    float fresnel = fres(rd, nor, RI_AIR, RI_GLASS);\n    vec3 reflectionDir = reflect(rd, nor);\n    vec3 reflectionColor = sampleCubemap(reflectionDir,0.0);\n    diffcol = mix(diffcol, reflectionColor, fresnel);\n    return diffcol;\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 fragCoord)\n{\n\tvec3 col = vec3(0.0);\n\n    // raymarch\n    vec2 hit = rayMarch(ro,rd, 1.0);\n    vec3 pos = ro + hit.x*rd;\n    \n    vec2 foam = rayMarchFoam(ro,rd, 1.0, false);\n   \n    // shading/lighting\t\n    if( hit.y != MISS )\n    {\n        col = shading(ro, rd, hit);\n    }\n    else\n    {\n        col = sampleCubemap(rd, 0.0);\n    }\n    \n    if(foam.y != MISS)\n    {\n        vec3 fpos = ro + foam.x * rd;\n        \n        vec3 inPos = fpos + rd * 0.01;\n        \n        float thickness = rayMarchFoam(inPos, rd, -1.0, true).x;\n        thickness = (thickness - 0.2) * 5.0;\n        \n        vec3 posn = normalize(fpos);\n        float u = 0.5 + atan(posn.z, posn.x) / (2.*PI);\n        float v = 0.5 - asin(posn.y ) / PI;\n        float tcol = texture(iChannel1, vec2(u,v)* 0.5).x;\n        float lum = mix(0.0,1.0, clamp((1.0 - tcol) + 0.3,0.0,1.0));\n        \n        vec3 nor = calcFoamNormal(fpos);\n        float fresnel = fres(rd, nor, RI_GLASS, RI_PET);\n        vec3 reflectionDir = reflect(rd, nor);\n        vec3 reflectionColor = sampleCubemap(reflectionDir,0.0);\n        float reflLum = (reflectionColor.x + reflectionColor.y + reflectionColor.z) * 0.333333;\n        reflLum = (clamp (reflLum, 0.7, 1.0) - 0.7) / 0.3 * 0.3 ;\n        \n        float baseLum = (col.x + col.y + col.z) * 0.333333;\n        \n        vec3 withThickness = mix(vec3(0.99,0.97,0.93) ,vec3(0.65,0.54,0.46), clamp(thickness, 0.0, 1.0));\n        vec3 withReflection = withThickness;\n        if(fpos.y < 0.083)\n        {\n            withReflection = mix(withReflection, reflectionColor, fresnel);\n            withReflection = mix(withReflection, vec3(1,1,1), reflLum );\n        }\n        \n        vec3 foamCol = withReflection;\n        foamCol *= (1.0 - (lum * 0.1))* 1.1;\n        float interp = min(1.0,max(0.0,-(fpos.y - 0.02) * 200.0));\n        col = mix(foamCol, col, interp);\n\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n    float an1 = (iTime + 7.0) * 0.2;\n    float an2 = PI * 0.5 + PI * 0.1 * cos(iTime * 0.2 + 4.3);\n    vec2 mo = iMouse.xy/iResolution.xy;\n    mo *= 5.0;\n\n    if(iMouse.z <= 0.0)\n    {\n        mo = vec2(0,0);\n    }\n    else\n    {\n        an1 = 0.0;\n        an2 = 0.0;\n    }\n    \n    vec3 ro = vec3( cos(mo.x - an1), cos(mo.y - an2 ) , sin(mo.x + an1) ) * 0.7;\n\n    vec3 ww = normalize(vec3(0,-0.15,0) -ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 col = vec3(0);\n    \n    #if AA == 1\n        for( int m=0; m<2; m++ )\n            for( int n=0; n<2; n++ )\n            {\n                // pixel coordinates\n                vec2 o = vec2(float(m),float(n)) / 2.0 - 0.5;\n                vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n                // ray direction\n                vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n                col += render(ro, rd, fragCoord);\n            }\n\n        col /= 4.0;\n    #else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        col = render(ro, rd, fragCoord, transf);\n    #endif\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}