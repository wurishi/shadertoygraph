{"ver":"0.1","info":{"id":"wlffzs","date":"1597632657","viewed":118,"name":"Raymarched Sierpenski Pyramid","username":"IAmLegend","description":"A raymarched sierpenski pyramid with diffuse + specular lighting and hard shadows. No ambient occlusion >w<","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sierpenskipyramidraymarched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14;\nfloat EPSILON = 0.001;\n\n// Map values to unsquish resolution\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n// rotation matrix around origin\nvec3 rotate(vec3 p, vec3 r){\n    // d --> r\n    r.x *= PI/180.0;\n    r.y *= PI/180.0;\n    r.z *= PI/180.0;\n    mat3 xRot = mat3 (1,0,0,\n                      0,cos(r.x),-sin(r.x),\n                      0,sin(r.x), cos(r.x));\n    mat3 yRot = mat3 (cos(r.y),0,sin(r.y),\n                      0,1,0,\n                      -sin(r.y),0,cos(r.y));\n    mat3 zRot = mat3 (cos(r.z),-sin(r.z),0,\n                      sin(r.z),cos(r.z),0,\n                      0,0,1);\n    return xRot * yRot * zRot * p;\n}\n// DE from http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat pyramidDE(vec3 p){\n    float scale = 1.75;\n    float offset = 2.5;\n    for (int n = 0; n < 16; ++n) {\n        if(p.x + p.y < 0.0){ \n            p.xy = - p.yx;\n        } \n        if(p.x + p.z < 0.0){ \n            p.xz = - p.zx;\n        } \n        if(p.y + p.z < 0.0){ \n            p.zy = - p.yz;\n        } \n        p = p * scale - offset*(scale - 1.0);\n    }\n\n    return length(p) * pow(scale, - 16.0);\n}\n// Derivative of the fractal\nvec3 approxNormal(vec3 p)\n{\n    return normalize(vec3(\n        pyramidDE(p + vec3(EPSILON, 0, 0)) - pyramidDE(p - vec3(EPSILON, 0, 0)),\n        pyramidDE(p + vec3(0, EPSILON, 0)) - pyramidDE(p - vec3(0, EPSILON, 0)),\n        pyramidDE(p + vec3(0, 0, EPSILON)) - pyramidDE(p - vec3(0, 0, EPSILON))));\n}\n// shadows raymarch towards the light from the intersection and see if theres collision cool :o\nfloat hardshadow (vec3 origin, vec3 direction, float smoothness, float time){\n    float distance = EPSILON;\n    for (float iters = 0.0; iters < 200.0; ++iters){\n        vec3 pos = origin + distance * direction;\n        vec3 rPos = rotate(pos, vec3(0.0, mod(time, 360.0) * 30.0 + 45.0, 55.0));\n        float nextDistance = pyramidDE(rPos);\n        distance += nextDistance;\n        if (abs(nextDistance) < EPSILON){\n            return distance * .5;\n        }\n    }\n    return 1.0;\n}\nvec3 raymarch(vec3 origin, vec3 direction, vec3 light, float time){\n    float distance = 0.0;\n    for (float iters = 0.0; iters < 200.0; ++iters){\n        vec3 pos = origin + distance * direction;\n        vec3 rPos = rotate(pos, vec3(0.0, mod(time, 360.0) * 30.0 + 45.0, 55.0));\n        float nextDistance = pyramidDE(rPos);\n        distance += nextDistance;\n        if (abs(nextDistance) < EPSILON){ \n            vec3 normal = approxNormal(pos);\n            // Take dot product of normal and light vectors for diffuse\n            // Don't forget to clamp the min at 0\n            float diffuse = max(0.0, dot(normal, light)); \n            vec3 reflected = reflect(direction, normal);\n            // Phong exponent 16 for a nice look\n            float specular = pow(max(dot(reflected, light), 0.0), 16.0); \n            float shade = diffuse * 0.7 + specular * 0.3; \n            vec3 ambient = vec3(1.0, 1.0, 1.0);\n            return shade * ambient * hardshadow(pos, light, .2, time);\n        }\n        if (distance > 100.0){\n            break;\n        }\n    }\n    // Background blue\n    return vec3(0.5, 0.25, 0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // window relative -> clip space\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x = map(uv.x, -1.0, 1.0, -512.0/288.0, 512.0/288.0);\n    \n    vec3 center = vec3(0.3, -0.3, 0.0);\n    float time = iTime;\n    // directional light\n    vec3 light = normalize(vec3(-1.0, 0.8, -1.0)); \n    fragColor = vec4(raymarch(vec3(0.0, 0.0, -6.0), normalize(vec3(uv, 0.0) - vec3(0.0, 0.0, -1.0)), light, time), 1.0);\n}","name":"Image","description":"","type":"image"}]}