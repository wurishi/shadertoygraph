{"ver":"0.1","info":{"id":"tlKXzh","date":"1582219629","viewed":464,"name":"Noise Combinations","username":"amally","description":"Showcasing various combinations of noise.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// These three are mutually exclusive. Uncomment the one\n// that specifies the noise you want to use for your warping vector.\n//#define WARP_FBM\n//#define WARP_WORLEY\n#define WARP_PERLIN\n\n// Define the frequency of your warping noise, and\n// how much the warp affects the input to your final noise\n#define WARP_FREQUENCY 8.0\n#define WARP_MAGNITUDE 2.0\n\n// These three are mutually exclusive. Uncomment the one\n// that specifies the noise you want to warp.\n#define FBM\n//#define WORLEY\n//#define PERLIN\n\n// How frequent do you want your output noise to be\n#define NOISE_FREQUENCY 4.0\n\n#define FBM_OCTAVES 6\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float rad = deg * 3.14159 / 180.0;\n    return vec2(cos(rad) * p.x - sin(rad) * p.y,\n                sin(rad) * p.x + cos(rad) * p.y);\n}\n\nfloat bilerpNoise(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    float ll = random1(floor(uv));\n    float lr = random1(floor(uv) + vec2(1,0));\n    float ul = random1(floor(uv) + vec2(0,1));\n    float ur = random1(floor(uv) + vec2(1,1));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\nfloat WorleyNoise(vec2 uv);\nfloat PerlinNoise(vec2 uv);\n\n// Returns a vector in the range [-1, 1]\n// based on the output of FBM\nvec2 NoiseVectorFBM(vec2 uv) {\n    float x = fbm(uv) * 2.0 - 1.0;\n    float y = fbm(rotate(uv, 60.0)) * 2.0 - 1.0;\n    return vec2(x, y);\n}\n\n// Returns a vector in the range [-1, 1]\n// based on the output of Worley Noise\nvec2 NoiseVectorWorley(vec2 uv) {\n    float x = WorleyNoise(uv) * 2.0 - 1.0;\n    float y = WorleyNoise(rotate(uv, 60.0)) * 2.0 - 1.0;\n    return vec2(x, y);\n}\n\n// Returns a vector in the range [-1, 1]\n// based on the output of Perlin Noise\nvec2 NoiseVectorPerlin(vec2 uv) {\n    float x = PerlinNoise(uv);\n    float y = PerlinNoise(rotate(uv, 60.0));\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    vec2 warp;\n    #ifdef WARP_FBM\n    warp = NoiseVectorFBM(uv * WARP_FREQUENCY) * WARP_MAGNITUDE;\n    #endif\n    #ifdef WARP_WORLEY\n    warp = NoiseVectorWorley(uv * WARP_FREQUENCY) * WARP_MAGNITUDE;\n    #endif\n    #ifdef WARP_PERLIN\n    warp = NoiseVectorPerlin(uv * WARP_FREQUENCY) * WARP_MAGNITUDE;\n    #endif\n    \n    float h;\n    #ifdef FBM\n    h = fbm(uv * NOISE_FREQUENCY + warp);\n    #endif\n    #ifdef WORLEY\n    h = WorleyNoise(uv * NOISE_FREQUENCY + warp);\n    #endif\n    #ifdef PPERLIN\n    h = PerlinNoise(uv * NOISE_FREQUENCY + warp);\n    #endif\n   \n\n    fragColor = vec4(h, h, h, 1);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    // Tile the space\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Animate the point\n//            point = 0.5 + 0.5 * sin(u_Time * 0.01 + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat surflet(vec2 P, vec2 gridPoint) {\n    // Compute falloff function by converting linear distance to a polynomial (quintic smootherstep function)\n    float distX = abs(P.x - gridPoint.x);\n    float distY = abs(P.y - gridPoint.y);\n    float tX = 1.0 - 6.0 * pow(distX, 5.0) + 15.0 * pow(distX, 4.0) - 10.0 * pow(distX, 3.0);\n    float tY = 1.0 - 6.0 * pow(distY, 5.0) + 15.0 * pow(distY, 4.0) - 10.0 * pow(distY, 3.0);\n\n    // Get the random vector for the grid point\n    vec2 gradient = random2(gridPoint);\n    // Get the vector from the grid point to P\n    vec2 diff = P - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * tX * tY;\n}\n\n\nfloat PerlinNoise(vec2 uv) {\n    // Tile the space\n    vec2 uvXLYL = floor(uv);\n    vec2 uvXHYL = uvXLYL + vec2(1,0);\n    vec2 uvXHYH = uvXLYL + vec2(1,1);\n    vec2 uvXLYH = uvXLYL + vec2(0,1);\n\n    return surflet(uv, uvXLYL) + surflet(uv, uvXHYL) + surflet(uv, uvXHYH) + surflet(uv, uvXLYH);\n}","name":"Image","description":"","type":"image"}]}