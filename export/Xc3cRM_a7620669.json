{"ver":"0.1","info":{"id":"Xc3cRM","date":"1730390553","viewed":47,"name":"Medial Axis - fab","username":"FabriceNeyret2","description":"This is the (simplified) first attempt at shading a medial axis by bradphelan.\n( republished since he replaced it by a new better method https://shadertoy.com/view/McccRN ,\n  but I thought both the look and the 1st method were worth archiving ).","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["medialaxis"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Medial Axis\" by bradphelan. https://shadertoy.com/view/McccRN\n// 2024-10-31 10:22:41\n\n#define T(x,y) texelFetch(iChannel0, ivec2( u + vec2(x,y)), 0)\n\nbool isMedialPoint(vec2 u) {\n    for ( int k; k<9; k+= k==3 ?2 :1 ) {\n            int i = int(T(0,0)),\n                j = int(T( k%3-1, k/3-1 )),\n                d = abs(i-j);\n            if ( d > 1 && d != N-1 ) return true;\n    }\n    return false;\n}\nvoid mainImage(out vec4 O, vec2 u)\n{     \n    O = iMouse.z <= 0.? vec4( isMedialPoint(u) ) \n                      : vec4( hashcolor(int(T(0,0))), 1);  \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int medialDistanceField(vec2 p, vec2 points[N]) {\n\n    int j, i;\n    for ( float m = 1. ; i < N; i++) {\n        vec2  a = points[i],\n              b = points[(i+1)%N];\n        float d = abs( sdLine(p, a, b) );\n        if(d < m) m = d, j = i;\n    }\n    return j;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n        uv = ( 2.*u - R ) / R.y,\n        points[N];\n    for (int i ; i < N; i++)\n        points[i] = getPoint(i, iTime);\n    \n    O = vec4( isInsidePolygon(uv, points) ?  medialDistanceField(uv, points) : 2*N );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Number of vertices in the polygon\nconst int N = 100;\n\n// Frequency and amplitude of wobble\nfloat WOBBLE_FREQ = .5,\n       WOBBLE_AMP = .05,\n\n// Thresholds for medial axis rendering\n MEDIAL_AXIS_THRESHOLD = .07,\n    DISTANCE_THRESHOLD = .005;\n\n// Function to create a point with wobble\nvec2 getPoint(int i, float time) {\n    float angle = float(i) * 6.283 / float(N);\n    float radius = .5 + WOBBLE_AMP * sin(WOBBLE_FREQ * time + float(i));\n    return vec2(3.*cos(angle), sin(angle)) * radius;\n}\n\n// Signed distance to a line segment\nfloat sdLine(vec2 p, vec2 a, vec2 b) {\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );\n}\n\n// 2D cross product (determinant)\nfloat cross2D(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Check if a point is inside a polygon using winding number\nbool isInsidePolygon(vec2 p, vec2 points[N]) {\n    int windingNumber;\n    for (int i; i < N; i++) {\n        vec2 a = points[i],\n             b = points[(i + 1) % N];\n        bool xdet = cross2D(b-a, p-a) > 0.;\n        if (a.y <= p.y) {\n            if (b.y > p.y && xdet) windingNumber++;\n        } else \n            if (b.y <= p.y && !xdet) windingNumber--;\n    }\n    return windingNumber != 0;\n}\n\n\n\nvec3 hashcolor( int p )\n{ \n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n   \n}","name":"Common","description":"","type":"common"}]}