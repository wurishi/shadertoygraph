{"ver":"0.1","info":{"id":"dddSDl","date":"1680686918","viewed":23,"name":"Pikachu-Low-Cost","username":"loic77780","description":"First shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["assignment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l*0.5,th);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdNestedCircle(vec2 p, vec2 center, float radiusBig, float radiusSmall)\n{\n    float d1 = length(p - center) - radiusBig;\n    float d2 = length(p - center) - radiusSmall;\n    return max(-d1,d2);\n}\n\nvec3 circleColor = vec3(0.4, 0.7, 0.9);\nvec3 smallCircleColor = vec3(0.9, 0.1, 0.1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col;\n    //eyes\n    float c1 = sdCircle(p + vec2(0.1,0.15), 0.8);\n    float c2 = sdCircle(p + vec2(-0.20,-0.1), 0.2);\n    float c3 = sdCircle(p + vec2(0.55,-0.1), 0.2);\n\n    float y = 0.9*sin(iTime) + 1.5;\n    vec2 v1 = vec2(0.0,1.0);\n\tvec2 v2 =  vec2(0.0,y) + 1.5 ;\n    float th = 0.1;\n    float d_box = sdOrientedBox(p + vec2(-0.3,0.5), v1, v2, th);\n    \n    y = 0.9*sin(iTime) + 1.5;\n    v1 = vec2(1.0,0.0);\n\tv2 =  vec2(0.0,y);\n    float d2_box = sdOrientedBox(p + vec2(1.0,-0.1), v1, v2, th);\n\n    float d = opUnion(c1, d_box);\n    d = opUnion(d, d2_box);\n    //mouth\n    float ellipse = sdEllipse(p+ vec2(0.2,0.5), vec2(0.11,0.14));\n    \n    //thunder\n    v1 = vec2(-0.6,0.4);\n\tv2 = vec2(-1,-0.4);\n\tvec2 v3 = vec2(-0.9,0.45);\n\ty = (mod(iTime, 2.0) * 2.) - 1.5; \n    float t1 = sdTriangle(p + vec2(0.5, y), v1, v2, v3 );\n    \n    v1 = vec2(-0.7,0.2);\n\tv2 = vec2(-0.9,-0.4);\n    th = 0.11;\n    float d_box2 = sdOrientedBox(p + vec2(0.55, y-0.75), v1, v2, th);\n    \n    float thunder = opUnion(d_box2,t1);\n    \n    if(thunder < 0.0){\n        col = vec3(0.957,0.576,0.059);\n    }\n    \n    if(thunder > 0.0 && thunder < 0.1){\n        col =  mix(vec3(0.), vec3(0.957,0.576,0.059),(thunder - 0.1) / -0.1);\n    }\n     \n    if(d < 0.0){\n        col = vec3(0.910,0.839,0.490);\n    }\n      \n    if(c2 < 0.0){\n      col = 0.9 + 0.5*cos(iTime+p.xyx+vec3(4,0,2));\n    }\n    \n    if(c3 < 0.0){\n     col = 0.4 + 0.5*cos(iTime+p.xyx+vec3(3,0,1));\n    }\n    \n    if(ellipse < 0.){\n        col = vec3(0.961,0.588,0.239);\n    }\n    \n    if(ellipse > 0. && ellipse < 0.005){\n        col = vec3(0.);\n    }\n    \n    \n    // Add glow effect\n    float glowRadius = 0.05;\n    float glowIntensity = 5.0;\n    float glow = smoothstep(glowRadius, 0.0, abs(thunder));\n    col += glow * glowIntensity * mix(vec3(0.0), col, 0.5); \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}