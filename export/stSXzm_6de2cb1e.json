{"ver":"0.1","info":{"id":"stSXzm","date":"1627313904","viewed":889,"name":"2d spectral ray tracer","username":"riouxld","description":"Vaguely inspired by an afternoon listening to the dark side of the moon album. Can reset accumulation by pressing SPACEBAR and move light with a LEFT-CLICK from the mouse. can change parameters, such as n_samples, in common and the scene in buffer B.","likes":48,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","montecarlo","spectral","dielectric","flux"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------ //\n// 2D spectral ray tracer: Vaguely inspired by an afternoon listening to dark     //\n// side of the moon. Some other inspirations:                                     //\n// https://benedikt-bitterli.me/tantalum/                                         //\n// https://www.shadertoy.com/view/NtXSR4                                          //\n// https://www.shadertoy.com/view/llVSDz                                          //\n// https://www.shadertoy.com/view/wlSXz3                                          //\n// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions#sec:mc-specular-deltas //\n// Could be more efficient and simpler but I wanted to do it fast and have some   //\n// fun. For the same reason, there might be some mistakes such has forgotten      //\n// or duplicated cosines                                                          //\n// ------------------------------------------------------------------------------ // \n\n\n// XYZ to sRGB conversion \n// ---------------------\n// https://www.shadertoy.com/view/llVSDz     \n\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \n\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \n// intersect the intersection point may be stored in the floats i_x and i_y.\n\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    vec2 s1 = p1-p0, s2 = p3-p2;\n\n    float d = cross2(s1,s2),\n          s = cross2(s1, p0-p2) / d,\n          t = cross2(s2, p0-p2) / d;\n\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\n         ? p0 + t*s1    // Collision detected\n         : p0;\n}\n\nvec3 constrainXYZToSRGBGamut(vec3 col)\n{\n    vec2 xy = col.xy / (col.x + col.y + col.z);\n    \n    vec2 red   = vec2(0.64,   0.33  ),\n         green = vec2(0.3,    0.6   ),\n         blue  = vec2(0.15,   0.06  ),\n         white = vec2(0.3127, 0.3290);\n    \n    const float desaturationAmount = 0.1;\n    xy = mix(xy, white, desaturationAmount);\n    \n    xy = intersectSegment(xy, white, red,   green);\n    xy = intersectSegment(xy, white, green, blue );\n    xy = intersectSegment(xy, white, blue,  red  );\n    \n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\n}\n\nvec3 xyzToRgb(vec3 XYZ)\n{\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\n\t                  -0.969256 , 1.875991,  0.041556,\n\t                   0.055648, -0.204043,  1.057311 );\n}\n\n// gamma correction\nvec3 gamma_correction(vec3 RGB) {\n    float gamma = 2.2;\n    return pow(RGB, vec3(1./gamma));\n}\n\nvec3 final_color(vec3 XYZ) {\n    return gamma_correction(xyzToRgb(constrainXYZToSRGBGamut(XYZ)));\n}\n\n// main\n// ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // uv texture coordinate (0,1)x(0,1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n\n\n    // accumulated color \n    vec3 col_xyz = texture(iChannel1, uv).xyz;\n    \n    // longer exposition, for brighter results\n    col_xyz *= 2.5;\n    \n    // correct and show\n    fragColor = vec4(final_color(col_xyz), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ------------------------------------------------------------------------------ //\n// Memory & keyboard management: Could be way simpler but I wanted to investigate //\n//     how to keep global variable using buffers.                                 //\n// ------------------------------------------------------------------------------ // \n\n\n\n// keyboard / mouse input\n// ----------------------\nbool isKeyPressed(int key)\n{\n\treturn texelFetch( iChannel3, ivec2(key, 0), 0 ).x != 0.0;\n}\n\n// mouse input\n// ----------------------\n\nbool isMousePressed()\n{\n\treturn iMouse.z > 0.0;\n}\n\n\n// main\n// ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixelindices (0,width-1)x(0, height-1)\n    ivec2 indices = ivec2(fragCoord);\n    \n    // uv texture coordinate (0,1)x(0,1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    \n    // initial state (x reset time, yz light pos)\n    if (iFrame == 0 ) {\n         if (indices == reset_time_loc) {\n             fragColor = vec4(0.);\n         } else if (indices == light_pos_loc) {\n             fragColor = vec4(vec2(0.3,0.35), vec2(0.0));\n         } else {\n             fragColor = vec4(0.);\n         } \n         return;\n    }\n    \n    \n    // if reset simulation\n    if (isKeyPressed(KEY_SPACE) ) {\n         if (ACCUMULATE && indices == reset_time_loc) {\n             fragColor = vec4(float(iFrame) , vec3(0.));\n         } else {\n             fragColor = texture(iChannel0, uv);\n         }\n         return;\n    }\n    \n    \n    // if light has moved\n    if (isMousePressed() ) {\n         if (ACCUMULATE && indices == reset_time_loc) {\n             fragColor = vec4(float(iFrame), vec3(0.));\n         } \n         else if (indices == light_pos_loc) {\n             fragColor = vec4(iMouse.xy/iResolution.y, vec2(0.0));\n         } else {\n             fragColor = texture(iChannel0, uv);\n         }\n         return;\n    }\n    \n    // Accumulate fluence with walking average\n    fragColor = texture(iChannel0, uv);\n}\n\n\n\n/*\n// initial state (x reset time, yz light pos)\nif (iFrame == 0 ) {\n     if (indices.x == 0 && indices.y == 0) {\n         fragColor = vec4(0.);\n     } else if (indices.x == 0 && indices.y == 1) {\n         fragColor = vec4(vec2(0.15,0.5), vec2(0.0));\n     }\n     fragColor = vec4(0., vec2(0.15,0.5), 0.0);\n     return;\n}\n\n\n// if reset simulation\nif (isKeyPressed(KEY_SPACE) ) {\n     fragColor = vec4(float(iFrame), texture(iChannel0, uv).yz, 0.0);\n     return;\n}\n\n\n// if light has moved\nif (isMousePressed() ) {\n     fragColor = vec4(float(iFrame), iMouse.xy/iResolution.y, 0.0);\n     return;\n}\n\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ------------------------------------------------------------------------------ //\n// Spectral, ray tracing and core: this is where the magic happens. Basically, at //\n// each pixels we compute flux of incoming ray using Monte Carlo. This means that //\n// we sample directions / wavelength uniformly and trace rays from them until     //\n// an emiter is met or a maxiumum depth is attained                               //\n// ------------------------------------------------------------------------------ // \n\n\n// structures\n// ----------\n\nstruct Ray {\n    vec2 origin;\n    vec2 dir;\n    float wavelength;\n};\n\nstruct Sample {\n    Ray ray;\n    float contrib;\n    float pdf;\n    float attenuation;\n};\n\nstruct HitQuery {\n    float t;\n    vec2 p;\n    vec2 normal;\n    int material;\n    float throughput;\n};\n\nstruct Sphere {\n    vec2 center;\n    float radius;\n    int material;\n\n};\n\nstruct Scene {\n    Sphere[nb_emiters] emiters;\n    Sphere[nb_objects] objects;\n};\n\n\n// dummy missed hit\nconst HitQuery no_hit = HitQuery(infinity, vec2(0.0), vec2(0.0), none, 0.0);\n\n// RNG: oldschool rand() from Visual Studio, hash to initialize \n// the random sequence (copied from Hugo Elias)\n// ------------------------------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n\n\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// Wavelength to XYZ conversion \n// ---------------------\n// https://www.shadertoy.com/view/llVSDz                  \n\n// Spectrum to xyz approx function from Sloan (& Fabrice)\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931(float lambda_nano)\n{\n    float t1 = (lambda_nano-442.0)*((lambda_nano<442.0)?0.0624:0.0374),\n          t2 = (lambda_nano-599.8)*((lambda_nano<599.8)?0.0264:0.0323),\n          t3 = (lambda_nano-501.1)*((lambda_nano<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\nfloat yFit_1931(float lambda_nano)\n{\n    float t1 = (lambda_nano-568.8)*((lambda_nano<568.8)?0.0213:0.0247),\n          t2 = (lambda_nano-530.9)*((lambda_nano<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\nfloat zFit_1931(float lambda_nano)\n{\n    float t1 = (lambda_nano-437.0)*((lambda_nano<437.0)?0.0845:0.0278),\n          t2 = (lambda_nano-459.0)*((lambda_nano<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\nvec3 xyzFit_1931(float lambda_nano) {\n    return vec3( xFit_1931(lambda_nano), yFit_1931(lambda_nano), zFit_1931(lambda_nano) );\n}\n\n\n// get ior with respect to wavelength\n// ----------------------------------\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\n// https://www.shadertoy.com/view/wlSXz3\n// Inputs:  Wavelength in nanometers, convert to micro (coefficients are computed that way)\nfloat cauchy_ior(in float lambda_nano) {\n    float lambda_micro = lambda_nano*1e-3;\n    // impossible material\n    return 1.0 + 0.25 / (lambda_micro*lambda_micro);\n}\n\n// sampler \n// -------\n\nfloat sample_uniform(void) {\n    return float(rand())/32767.0;\n}\n\nfloat sample_wavelength(void) {\n    return (float(spectrum_width))*sample_uniform() + float(spectrum_start);\n}\n\n\nfloat pdf_direction_uniform () {\n    return 1.0f / two_pi;\n}\n\nvec2 sample_direction_uniform() {\n    float theta = two_pi * sample_uniform();\n\treturn vec2(cos(theta), sin(theta));\n}\n\n// coordinates transformations\n// ---------------------------\n\nvec2 world2local(vec2 normal, vec2 dir) {\n    vec2 tangent = vec2(normal.y, -normal.x);\n    return vec2( dir.x * tangent.x + dir.y * tangent.y, \n                 dir.x * normal.x  + dir.y * normal.y );\n}\n\n\nvec2 local2world(vec2 normal, vec2 dir) {\n    \n    vec2 tangent = vec2(normal.y, -normal.x);\n    return vec2(dir.x * tangent.x + dir.y * normal.x, \n                dir.x * tangent.y + dir.y * normal.y );\n    \n}\n\n// materials\n// ---------\n\nSample sample_mirror(HitQuery hit, Ray ray) {\n    \n    \n    vec2 wi = -ray.dir;\n    vec2 normal = hit.normal;\n    wi = world2local(normal, wi);\n    float cos_theta_i = wi.y;\n    \n    cos_theta_i = abs(cos_theta_i);\n    \n    vec2 wo = vec2(-wi.x, wi.y);\n    float pdf = 1.0;\n    float contrib = 1.0 / cos_theta_i;\n    vec2 pert = eps * hit.normal;\n\n    \n    wo = local2world(normal, wo);\n    \n    return Sample(Ray(hit.p + pert, wo, ray.wavelength), contrib, pdf, cos_theta_i);\n}\n\n\nvec2 my_faceforward(vec2 n, vec2 v) {\n    return (dot(n, v) < 0.0) ? -n : n;\n}\n\nfloat compute_fresnel(float cos_theta_i, float eta_i, float eta_t) {\n\n    float eta = eta_i / eta_t;\n    \n    float sin_theta_i = sqrt(max(0.0, 1.0 - cos_theta_i * cos_theta_i));\n    float sin_theta_t = eta * sin_theta_i;\n    \n    if (sin_theta_t >= 1.0)\n        return 1.0;\n        \n    float cos_theta_t = sqrt(max(0.0, 1.0 - sin_theta_t * sin_theta_t));\n    \n    float R_par = ((eta_t * cos_theta_i) - (eta_i * cos_theta_t)) /\n                  ((eta_t * cos_theta_i) + (eta_i * cos_theta_t));\n    float R_per = ((eta_i * cos_theta_i) - (eta_t * cos_theta_t)) /\n                  ((eta_i * cos_theta_i) + (eta_t * cos_theta_t));\n    float fresnel = (R_par * R_par + R_per * R_per) / 2.0;\n    \n    return fresnel;\n}\n\n\nSample sample_dielectric(HitQuery hit, Ray ray) {\n\n    vec2 wi = -ray.dir;\n    vec2 normal = hit.normal;\n    wi = world2local(normal, wi);\n    float cos_theta_i = wi.y;\n    \n    \n    bool entering = cos_theta_i > 0.0;\n    float eta_i = entering ? 1.0: cauchy_ior(ray.wavelength);\n    float eta_t = entering ? cauchy_ior(ray.wavelength): 1.0;\n    float eta = eta_i / eta_t;\n    \n    cos_theta_i = abs(cos_theta_i);\n    float fresnel = compute_fresnel(cos_theta_i, eta_i, eta_t);\n    \n    \n    vec2 wo, pert;\n    float pdf, contrib;\n    if (sample_uniform() < fresnel) {\n        wo = vec2(-wi.x, wi.y);\n        pdf = fresnel;\n        contrib = fresnel / cos_theta_i;\n        pert = ( entering ? 1. : -1.) * eps * hit.normal;\n    } else {\n        float sin2_theta_I = max(0.0, 1.0 - cos_theta_i * cos_theta_i);\n        float sin2_theta_t = eta * eta * sin2_theta_I;\n        float cos_theta_t = sqrt(1.0 - sin2_theta_t);\n        wo = -eta * wi + (eta * cos_theta_i - cos_theta_t) * my_faceforward(vec2(0.0,1.0), wi);\n        pdf = 1.0 - fresnel;\n        contrib = (1.0 - fresnel) / cos_theta_i;\n        pert = ( entering ? -1. : 1.) * eps * hit.normal;\n        if (false) {\n            contrib *= eta * eta;\n        }\n    }\n    \n    \n    wo = local2world(normal, wo);\n    \n    // return sampled ray \n    return Sample(Ray(hit.p + pert, wo, ray.wavelength), contrib, pdf, cos_theta_i);\n}\n\n\n// sphere / ray intersection\n// -------------------------\nHitQuery intersect_sphere(Ray ray, Sphere sphere) {\n\n    \n    float radius_sq = sphere.radius *  sphere.radius;\n    \n    vec2 origin2center = sphere.center - ray.origin;\n    float origin2center_norm = length(origin2center);\n    float origin2center_norm_sq = origin2center_norm * origin2center_norm;\n    \n    bool is_inside =  origin2center_norm <= sphere.radius;\n    \n    float projection = dot(origin2center, ray.dir);\n    float projection_sq = projection*projection;\n    \n    if ( !is_inside && projection < eps) {\n        return no_hit;\n    }\n    \n    float perp_sq = origin2center_norm_sq - projection_sq;\n    \n    if (!is_inside && perp_sq > radius_sq) {\n        return no_hit;\n    }\n    \n    float dist_proj2bdr = sqrt(radius_sq - perp_sq);\n    float t1 = projection - dist_proj2bdr;\n    float t2 = projection + dist_proj2bdr;\n    float t = t1 >= eps ? t1 : (t2 >= eps ? t2 : infinity);\n\n\n    vec2 p = ray.origin + t * ray.dir;\n\n    vec2 normal = normalize(p - sphere.center);\n\n\n    return HitQuery(t, p, normal, sphere.material, 1.0);\n    \n}\n\n\n// scene intersection\n// ------------------\nHitQuery intersect_scene(Ray ray, Scene scene) { \n    HitQuery neareast_hit = no_hit;\n    \n    // find nearest intersected object in the scene (no need for shadow ray)\n    for (int i = 0 ; i < nb_emiters ; i++) {\n        \n        // test intersection with current object\n        HitQuery sphere_hit = intersect_sphere(ray, scene.emiters[i]);\n        \n        // if the object is not intersected, go to next one\n        if (sphere_hit.material == none) {\n            continue;\n        }\n        \n        // if closer, set as current hit\n        if (sphere_hit.t <= neareast_hit.t) {\n            neareast_hit = sphere_hit;\n        }\n        \n    }\n    \n    // find nearest intersected object in the scene (no need for shadow ray)\n    for (int i = 0 ; i < nb_objects ; i++) {\n        \n        // test intersection with current object\n        HitQuery sphere_hit = intersect_sphere(ray, scene.objects[i]);\n        \n        // if the object is not intersected, go to next one\n        if (sphere_hit.material == none) {\n            continue;\n        }\n        \n        // if closer, set as current hit\n        if (sphere_hit.t <= neareast_hit.t) {\n            neareast_hit = sphere_hit;\n        }\n        \n    }\n    return neareast_hit;\n    \n}\n\n// ray tracing\n// -----------\n\nHitQuery ray_trace(Ray ray, Scene scene) { \n    \n \n    float throughput = 1.0;\n    HitQuery hit_query = no_hit;\n    \n    // trace a path recursivly until max_depth\n    for (int i = 0; i < max_depth; i++) {\n        \n        // intersect ray with scene\n        hit_query = intersect_scene(ray, scene);\n        \n        \n        // if missed or emiter, stop\n        if (hit_query.material == none || hit_query.material == emiter) {\n            if (i == 0 && ONLY_INDIRECT) {\n                hit_query = no_hit;\n            }\n            break;\n        }\n        // oherwise, sample new ray according to material\n        else {\n            Sample sample_dir;\n            if (hit_query.material == mirror) {\n                sample_dir = sample_mirror(hit_query, ray);\n            } \n            else if (hit_query.material == dielectric) {\n                sample_dir = sample_dielectric(hit_query, ray);\n            } \n            ray = sample_dir.ray;\n            // everything should cancel out, but just for the form.\n            throughput *= sample_dir.contrib * sample_dir.attenuation/(sample_dir.pdf + eps);\n        }\n        \n        \n        \n    }\n    hit_query.throughput = throughput;\n    return hit_query;\n\n}\n\n// flux computation\n// -------------------\nvec3 compute_flux( vec2 p , Scene scene) { \n    // Monte Carlo estimator of the flux\n    vec3 flux = vec3(0.0);\n    for (int i = 0 ; i < n_samples ; i++){\n        \n        // sample direction uniformly\n        vec2 wo = sample_direction_uniform();\n        float wavelength = sample_wavelength();\n        Ray ray = Ray(p, wo, wavelength);\n        \n        // ray trace\n        HitQuery hit_query = ray_trace(ray, scene);\n        \n        // if missed, nothing to do\n        if (hit_query.material == none) {\n            continue;\n        }\n        \n        // if last hit was emiter, accumulate contribution\n        if (hit_query.material == emiter) {\n            flux += xyzFit_1931(wavelength) * hit_query.throughput / pdf_direction_uniform();\n        }\n        \n    }\n    flux /= float(n_samples);\n    \n    return flux;\n}\n\n\nvec4 accumulate(vec2 uv, vec3 color, int start_frame) {\n    if (ACCUMULATE) {\n        return texture(iChannel1, uv) * (float(iFrame - start_frame) / float(iFrame + 1 - start_frame)) \n            + vec4(color,1.0)/ float(iFrame + 1 - start_frame);\n    } else {\n        return vec4(color, 1.0);\n    }\n            \n\n}\n\n// main\n// ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // starting frame accumulation\n    int start_frame = int( texelFetch(iChannel0, reset_time_loc,0).x);\n        \n    // pixelindices (0,width-1)x(0, height-1)\n    ivec2 indices = ivec2(fragCoord);\n    \n    // uv texture coordinate (0,1)x(0,1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    \n     // init rng seed for each time and pixels\n    srand( hash(indices.x+hash(indices.y+hash(iFrame))));\n    \n    // pixel scrambled coordinate for antialiasing (0,aspectratio)x(0,1)\n    vec2 p_center = (fragCoord)/iResolution.y;\n    vec2 p = (fragCoord + sample_uniform())/iResolution.y;\n   \n    // construct scene \n    vec2 light_pos = texelFetch(iChannel0, light_pos_loc, 0).xy; \n    Sphere emiter_1 = Sphere(light_pos, 0.025, emiter);\n    Sphere object_1 = Sphere(vec2(0.63,0.5), 0.2, dielectric);\n    Sphere object_2 = Sphere(vec2(1.13,0.5), 0.2, dielectric);\n    Scene scene = Scene(Sphere[nb_emiters](emiter_1), Sphere[nb_objects](object_1,object_2));\n    \n    // if insight emitters, show light\n    for (int i = 0 ; i < nb_emiters ; i++) {\n        if (length(p_center - scene.emiters[i].center)  < scene.emiters[i].radius) {\n            fragColor = accumulate(uv, vec3(1.0), start_frame);\n            return;\n        }\n    }\n    \n    // if object border, show object \n    for (int i = 0 ; i < nb_objects ; i++) {\n        if (length(p - scene.objects[i].center) <= scene.objects[i].radius + 0.001 \n            && length(p - scene.objects[i].center) >= scene.objects[i].radius - 0.001) {\n            fragColor = accumulate(uv, vec3(0.25), start_frame);\n            return;\n        }\n    }\n    \n    \n    // compute flux\n    vec3 flux = compute_flux(p, scene);\n\n            \n    // Accumulate fluence with walking average\n    fragColor = accumulate(uv, flux, start_frame);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// debugging options\n#define ACCUMULATE true\n#define ONLY_INDIRECT false\n\n\n// constants & parameters\n// ----------------------\n\nconst float eps = 0.001;\nconst float infinity = 10000.0;\nconst float two_pi = 6.283185;\nconst float pi = 3.1415925;\n\nconst int n_samples = 16;\nconst int max_depth = 20;\n\nconst int nb_emiters = 1;\nconst int nb_objects = 2;\n\nconst int none = -1;\nconst int emiter = 0;\nconst int mirror = 1;\nconst int dielectric = 2;\n\nconst int spectrum_start = 380;\nconst int spectrum_end = 720;\nconst int spectrum_width = (spectrum_end - spectrum_start);\n\n// Keyboard\n// --------\n\n//const int KEY_ONE  = 49;\n//const int KEY_A  = 65;\nconst int KEY_SPACE  = 32;\n\n// variable buffer locations\n// ----------------------\nconst ivec2 reset_time_loc = ivec2(0,0);\nconst ivec2 light_pos_loc = ivec2(1,0);\n\n","name":"Common","description":"","type":"common"}]}