{"ver":"0.1","info":{"id":"MfBSDy","date":"1706759278","viewed":93,"name":"A Little Bit of Perlin Noise...","username":"Squidz","description":"...as a treat","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(float value){\n\tfloat mutator = 0.69420;\n    float _out = fract(sin(value + mutator) * 42069.80085);\n    _out = fract(sin(_out + mutator) * 95453.54515);\n    return _out;\n}\n\nvec2 random2d(float value0, float value1){\n    float mutator0 = 0.80085;\n    float mutator1 = 0.42069;\n    float val2 = dot(value0, value1);\n    return vec2(random(val2 - mutator0), random(val2 - mutator1));\n}\n\nvec3 random3d(float value0, float value1, float value2){\n    float mutator0 = 0.80085;\n    float mutator1 = 0.42069;\n    float mutator2 = 3.14159;\n    \n    float val3 = value0 * value1 * value2;\n    \n    return vec3(random(val3 - mutator0), random(val3 - mutator1), random(val3 - mutator2));\n}\n\nfloat flerp(float val0, float val1, float interpolator){\n    return ((1.0 - interpolator) * val0) + (interpolator * val1);\n}\n\nvec3 v3lerp(vec3 val0, vec3 val1, float interpolator){\n    float x = ((1.0 - interpolator) * val0.x) + (interpolator * val1.x);\n    float y = ((1.0 - interpolator) * val0.y) + (interpolator * val1.y);\n    float z = ((1.0 - interpolator) * val0.z) + (interpolator * val1.z);\n    return vec3(x,y,z);\n}\n\nfloat easeIn(float val){\n    return val * val;\n}\n\nfloat easeOut(float val){\n    return 1.0 - easeIn(1.0 - val);\n}\n\nfloat easeInOut(float val){\n    return flerp(easeIn(val), easeOut(val), val);\n}\n\nfloat gradientNoise(float value){\n    float decimal = fract(value);\n    float line0gradient = (random(floor(value)) * 2.0) - 1.0;\n    float line0point = line0gradient * decimal;\n    float line1gradient = (random(ceil(value)) * 2.0) - 1.0;\n    float line1point = line1gradient * (decimal - 1.0);\n    \n    return flerp(line0point, line1point, easeInOut(decimal));\n}\n\nfloat Perlin(vec2 value){\n    vec2 decimal = fract(value);\n    \n    vec2 x0y0direction = random2d(floor(value.x), floor(value.y)) * 2.0 - 1.0;\n    vec2 x0y1direction = random2d(floor(value.x), ceil(value.y)) * 2.0 - 1.0;\n    vec2 x1y0direction = random2d(ceil(value.x), floor(value.y)) * 2.0 - 1.0;\n    vec2 x1y1direction = random2d(ceil(value.x),ceil(value.y)) * 2.0 - 1.0;    \n    \n    float x0y0point = dot(x0y0direction, decimal - vec2(0.0,0.0));\n    float x0y1point = dot(x0y1direction, decimal - vec2(0.0,1.0));\n    float x1y0point = dot(x1y0direction, decimal - vec2(1.0,0.0));\n    float x1y1point = dot(x1y1direction, decimal - vec2(1.0,1.0));\n    \n    \n    float y0points = flerp(x0y0point, x1y0point, easeInOut(decimal.x));\n    float y1points = flerp(x0y1point, x1y1point, easeInOut(decimal.x));\n    float final = flerp(y0points, y1points, easeInOut(decimal.y));\n    \n    return final;\n}\n\nfloat Perlin3(vec3 value){\n    vec3 decimal = fract(value);//use the intergers as the grid... love this strategy\n    \n    //get some gradient vectors\n    vec3 x0y0z0direction = random3d(floor(value.x), floor(value.y), floor(value.z));\n    vec3 x0y0z1direction = random3d(floor(value.x), floor(value.y), ceil(value.z));\n    vec3 x0y1z0direction = random3d(floor(value.x), ceil(value.y), floor(value.z));\n    vec3 x0y1z1direction = random3d(floor(value.x), ceil(value.y), ceil(value.z));\n    vec3 x1y0z0direction = random3d(ceil(value.x), floor(value.y), floor(value.z));\n    vec3 x1y0z1direction = random3d(ceil(value.x), floor(value.y), ceil(value.z));\n    vec3 x1y1z0direction = random3d(ceil(value.x), ceil(value.y), floor(value.z));\n    vec3 x1y1z1direction = random3d(ceil(value.x), ceil(value.y), ceil(value.z));\n    \n    //interperet the vectors\n    float x0y0z0point = dot(x0y0z0direction, decimal - vec3(0.0,0.0,0.0));\n    float x0y0z1point = dot(x0y0z1direction, decimal - vec3(0.0,0.0,1.0));\n    float x0y1z0point = dot(x0y1z0direction, decimal - vec3(0.0,1.0,0.0));\n    float x0y1z1point = dot(x0y1z1direction, decimal - vec3(0.0,1.0,1.0));\n    float x1y0z0point = dot(x1y0z0direction, decimal - vec3(1.0,0.0,0.0));\n    float x1y0z1point = dot(x1y0z1direction, decimal - vec3(1.0,0.0,1.0));\n    float x1y1z0point = dot(x1y1z0direction, decimal - vec3(1.0,1.0,0.0));\n    float x1y1z1point = dot(x1y1z1direction, decimal - vec3(1.0,1.0,1.0));\n    \n    //lerp(smoothly) between the adjacent grids\n    float x0y0points = flerp(x0y0z0point, x0y0z1point, easeInOut(decimal.z));\n    float x0y1points = flerp(x0y1z0point, x0y1z1point, easeInOut(decimal.z));\n    float x1y0points = flerp(x1y0z0point, x1y0z1point, easeInOut(decimal.z));\n    float x1y1points = flerp(x1y1z0point, x1y1z1point, easeInOut(decimal.z));\n    \n    float x0points = flerp(x0y0points, x0y1points, easeInOut(decimal.y));\n    float x1points = flerp(x1y0points, x1y1points, easeInOut(decimal.y));\n    \n    float final = flerp(x0points, x1points, easeInOut(decimal.x));\n    \n    return final;\n}\n\nvec3 colourRamp(float value){\n    //set up some colours\n    vec3 col0 = vec3(1.0,1.0,1.0);//white\n    vec3 col1 = vec3(0.204,0.306,0.255);//dark green\n    vec3 col2 = vec3(0.733,0.835,0.557);//light green\n    vec3 col3 = vec3(0.15,0.0,0.0);//dark red\n    vec3 col4 = vec3(0.45, 0.0, 0.0);//less dark red\n    vec3 col5 = vec3(0.75,0.05,0.0);//orange\n    vec3 col6 = vec3(0.1, 0.0, 0.0);//very dark red\n    vec3 col7 = vec3(0.0,0.0,0.0);//black\n    vec3 col8 = vec3(0.3, 0.0, 0.0);//another red\n    \n    vec3 _out = col6;\n    \n    float interpolator = 0.0;\n    \n    float point0 = 0.8;\n    float point1 = 0.4;\n    float point2 = 0.1;\n    float point3 = 0.025;\n    \n    if(value > point0){\n        interpolator = (value - point0)/(1.0 - point0);\n        _out = v3lerp(col4, col5, interpolator);\n    } else if(value > point1){\n        interpolator = (value - point1)/(point0 - point1);\n        _out = v3lerp(col8, col4, interpolator);\n    } else if (value > point2){\n        interpolator = (value - point2)/(point1 - point2);\n        _out = v3lerp(col3, col8, interpolator);\n    }else if (value > point3){\n        interpolator = (value - point3)/(point2 - point3);\n        _out = v3lerp(col6, col3, interpolator);\n    }else{\n        interpolator = value/point1;\n        _out = v3lerp(col7, col6, interpolator);\n    };\n    \n    \n    \n    return _out;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //set up some colours\n    vec3 col1 = vec3(0.204,0.306,0.255);//dark green\n    vec3 col2 = vec3(0.733,0.835,0.557);//light green\n    vec3 col3 = vec3(0.204,0.0,0.0);//dark red\n    vec3 col4 = vec3(0.404, 0.0, 0.0);//less dark red\n    vec3 col5 = vec3(1.0,0.118,0.0);//orange\n    \n    //pixel color\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    //distance from line as defined\n    \n    //interperet uv\n    vec3 start = vec3(10.0,10.0, 10.0);\n    float xrange = 3.0;\n    vec2 range = vec2(xrange, xrange/1.778);\n    vec3 position = vec3(uv.x * range.x, uv.y * range.y, iTime/40.0) + start;\n    vec3 position2 = vec3(uv.x * range.x * 2.0, uv.y * range.y * 2.0, iTime/40.0) + start + (iTime/3.0);\n    \n    float a = Perlin3(position) + 0.5;\n    float b = Perlin3(position2)/10.0;\n    \n    //mix up the colours\n    float bandInterval = flerp(0.04, 0.01, ((sin(iTime/20.0) + 1.0) / 2.0));\n    float currentPos = 0.0;\n    float polarity = 1.0;\n    \n    a = clamp(a + b, 0.0, 1.0);\n    \n    float adjustedValue = a;\n    \n    for(currentPos = 0.0; currentPos <= 1.0; currentPos += bandInterval){\n        float dp = abs(a - currentPos);\n        \n        if(a > currentPos){\n            \n            switch(int(polarity)){\n                case 1:\n                adjustedValue = dp/bandInterval;\n                //col = v3lerp(col3, col4, easeInOut(dp/bandInterval));\n                break;\n                case -1:\n                adjustedValue = (1.0 - dp/bandInterval);\n                //col = v3lerp(col3, col4, easeInOut(1.0 - (dp/bandInterval)));\n                break;\n            };\n        };\n        \n        polarity *= -1.0;\n    };\n    \n    //col = v3lerp(col4, col5, easeOut(adjustedValue));\n    \n    col = colourRamp(adjustedValue);\n    \n    //col = vec3(a,a,a);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}