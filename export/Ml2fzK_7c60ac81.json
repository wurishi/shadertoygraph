{"ver":"0.1","info":{"id":"Ml2fzK","date":"1516648667","viewed":166,"name":"menger sponge","username":"unnick","description":"made another raymarcher, but this time with a fractal, some glow, more lights, and a simple tv effect.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tau 6.283\n\n#define raymul 0.5\n#define near 0.001\n#define far 5.0\n\n#define rand(v) fract( sin( dot( v, vec2(12.9898,78.233 )) ) * 43758.5453 )\n\nvec4 lights[] = vec4[](\n    vec4(5.0, 5.0, 0.0, 1.0),\n    vec4(-5.0, 5.0, 0.0, 1.0),\n    vec4(0.0, 5.0, 5.0, 1.0),\n    vec4(0.0, 5.0, -5.0, 1.0)\n);\nvec4 lightcolor[] = vec4[](\n    vec4(1.0, 1.0, 1.0, 2.0),\n    vec4(1.0, 1.0, 1.0, 2.0),\n    vec4(1.0, 1.0, 1.0, 2.0),\n    vec4(1.0, 1.0, 1.0, 2.0)\n);\n\n//copy pasted code from https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n//end of copy pasted code\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 pos){\n    float pdist = -pos.z-5.0;\n    int iters = 4;\n    float mul = 3.0;\n    vec3 ofs = vec3(1.0, 1.0, 1.0);\n    mat4 rot = rotationMatrix(vec3(1.0, 1.0, 1.0), iMouse.x/iResolution.x*tau/3.0);\n    for(int i = 0; i < iters; i++){\n        pos = (rot * vec4(pos, 1.0)).xyz;\n        pos = abs(pos);\n        if(pos.x-pos.y<0.0) pos.xy = pos.yx;\n        if(pos.x-pos.z<0.0) pos.xz = pos.zx;\n        if(pos.y-pos.z<0.0) pos.yz = pos.zy;\n        pos *= mul;\n        pos.xy -= ofs.xy*(mul-1.0);\n        if(pos.z > 0.5 * ofs.z * (mul-1.0)) pos.z -= ofs.z * (mul - 1.0);\n    }\n    pos /= pow(mul, float(iters));\n    return max(sdBox(pos, vec3(1.0/pow(mul, float(iters)))), pdist)-0.01;\n}\n\nvec3 getnormal(vec3 pos){\n    //basically computes the gradient and then normalizes it.\n    float d = 0.0005;\n    float dx = (map(pos+vec3(d, 0.0, 0.0)) - map(pos-vec3(d, 0.0, 0.0)));\n    float dy = (map(pos+vec3(0.0, d, 0.0)) - map(pos-vec3(0.0, d, 0.0)));\n    float dz = (map(pos+vec3(0.0, 0.0, d)) - map(pos-vec3(0.0, 0.0, d)));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 intersect(vec3 cam, vec3 ray, out bool collision, out float tdist, out float mdist){\n    collision = false;\n    tdist = 0.0;\n    mdist = 1e8;\n    for(int i = 0; i < 256; i++){\n        //get current distance\n        float cdist = map(cam);\n        \n        //raymarch\n        cam += ray * cdist * raymul;\n        //add to total distance\n        tdist += cdist * raymul;\n        //update minimum distance\n        mdist = min(mdist, cdist);\n        if(cdist < near){\n            collision = true;\n            return cam;\n        }\n        \n        if(tdist > far){\n            return cam;\n        }\n    }\n}\n\nfloat softshadow(vec3 cam, vec3 ray, float dmin, float dmax, float k){\n    float res = 1.0;\n    for(float d = dmin; d < dmax;)\n    {\n        float cdist = map(cam + ray * d);\n        if(cdist < 0.001) return 0.0;\n        res = min(res, k*cdist/d);\n        d += cdist;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    vec2 mpos = (iMouse.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y) * 2.0;\n    vec3 ray = normalize(vec3(pos, 1.0));\n    ray = rotate(ray, vec3(1.0, 0.0, 0.0), -tau/20.0);\n    ray = rotate(ray, vec3(0.0, 1.0, 0.0), -iTime+tau/2.0);\n    vec3 cam = vec3(sin(iTime)*3.0, 0.75, cos(iTime)*3.0);\n    \n    float tdist;\n    float mdist;\n    bool collision;\n    cam = intersect(cam, ray, collision, tdist, mdist);\n    if(collision){\n        vec3 normal = getnormal(cam-ray*0.001);\n        fragColor = vec4(0.0);\n        for(int j = 0; j < lights.length(); j++){\n            vec3 lightray = normalize(cam-lights[j].xyz);\n            float nlang = max(dot(-lightray, normal), 0.0);\n            fragColor +=\n                vec4(nlang)\n                * lights[j].w\n                * lightcolor[j]\n                * softshadow(cam, -lightray, 0.01, length(cam)*1.0, lightcolor[j].w);\n        }\n    }else{\n\t    fragColor = mix(vec4(0.1), vec4(0.2, 0.2, 0.1, 1.0), exp(-mdist));\n    }\n    fragColor *= (int(fragCoord.y)&2)==0?vec4(1.0):vec4(0.9, 0.9, 1.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}