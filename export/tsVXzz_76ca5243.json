{"ver":"0.1","info":{"id":"tsVXzz","date":"1573307773","viewed":241,"name":"blue bottle","username":"mgjunior","description":"where is my bear","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float perStep=0.4;\nconst float PI = 3.14;\nconst float epsilon = 0.001;  \n\nstruct Ray\n{\n    vec3 from;\n    vec3 dir;\n};\n\nbool hitPlane(in Ray ray,in vec3 planeN,in vec3 planeC,inout vec3 hitPos)\n{\n    // ray hit plane \n    vec3 from =ray.from;\n    vec3 dir = ray.dir;\n    //(F-C)。N + t (D。N) = 0\n    // t  = (C-F)。N / (D。N)\n    // t  = (A / (B)\n    float B = dot(dir, planeN);\n    float A = dot(planeC- from, planeN);\n\n    // avoid divide by 0\n    if (abs(B) < epsilon)\n        return false;\n\n    float t = A / B;\n    hitPos = from + t * dir;\n    \n    if(t>0.0)\n    \treturn true;\n}\n\nRay[4] createRayDiff(vec3 eye, vec3 xAxis,vec3 yAxis,vec3 p){\n    vec2[4] multisampleDiff;\n    float x = 0.5;\n    float y =0.5;\n    // offset from p\n    multisampleDiff[0]=vec2(x,y)/iResolution.y;   \n    multisampleDiff[1]=vec2(-y,x)/iResolution.y; \n    multisampleDiff[2]=vec2(-x,-y)/iResolution.y;\n    multisampleDiff[3]=vec2(y,-x)/iResolution.y;\n\n    Ray[4] rays;\n    for(int i=0;i<4;++i){\n        rays[i].from =p+( multisampleDiff[i].x*xAxis + multisampleDiff[i].y*yAxis );\n        rays[i].dir =normalize(rays[i].from-eye);\n    }\n\n    return rays;\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r,float offset )\n{\n    p.y -= clamp( p.y, offset, h+offset );\n    return length( p ) - r;\n}\n\nfloat bottle(vec3 pos){\n\tfloat H =2.,R =1.,Offset=0.;\n\tfloat h=1.,r=0.25,offset =3.;\n    \n    //return sdVerticalCapsule(pos,h,r,offset);\n    return min(sdVerticalCapsule(pos,H,R,Offset),sdVerticalCapsule(pos,h,r,offset));\n}\n\n// gradient is normal\nvec3 getNormal(vec3 pos){\n    float delta =0.01;\n    vec3 temp=vec3(bottle(pos+vec3(delta,0.,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,delta,0.))-bottle(pos),\n                   bottle(pos+vec3(0.,0.,delta))-bottle(pos)\n                  );\n\treturn normalize(temp);\n}\n\nvec3 shading(Ray ray,vec3 eye){\n    vec3 shadingColor = vec3(0.0,0.0,0.0);\n    \n    // obj 3 axis and offset\n    vec3 obj_offset=vec3(0.,1.,0.);\n    vec3 zAxis =vec3(0.,0.,1.);\n    float para_obj_rot=iTime;\n    vec3 yAxis = vec3(-sin(para_obj_rot),cos(para_obj_rot),0.);\n    vec3 xAxis =vec3(cos(para_obj_rot),sin(para_obj_rot),0.);\n    \n    // to local space\n    vec3 temp=(ray.from-obj_offset);\n    Ray localRay;\n    localRay.from =vec3(dot(xAxis,temp),dot(yAxis,temp),dot(zAxis,temp));\n    localRay.dir=vec3(dot(xAxis,ray.dir),dot(yAxis,ray.dir),dot(zAxis,ray.dir));\n    \n    vec3 lightDir=normalize(vec3(1.,1.,1.));\n    vec3 localLightDir =vec3(dot(xAxis,lightDir),dot(yAxis,lightDir),dot(zAxis,lightDir));\n    \n    temp= eye-obj_offset;\n    vec3 localEye =vec3(dot(xAxis,temp),dot(yAxis,temp),dot(zAxis,temp));\n    \n    vec3 back_color=vec3(0.2,0.2,0.2);\n    //vec3 water_color =vec3(0.4,0.1,0.6);\n    vec3 water_color =vec3(1.0,0.9,0.15);\n    \n    //front side of bottle\n    bool hit_bottle;\n    vec3 bottle_color;\n    vec3 bottle_hit_pos;\n    float dist_bottle_to_eye;\n    for(int i=0;i<20;i++){\n    \tfloat dist = bottle(localRay.from);\n        if(dist<0.01){\n            \n            //shading bottle color\n            vec3 n=getNormal(localRay.from);\n        \tbottle_color= vec3(0.0,1.0,0.75)*max(0.,dot(n,localLightDir))\n                +vec3(1.0,1.0,0.0)*max(0.,dot(n,-localLightDir));\n            \n            hit_bottle=true;\n            bottle_hit_pos= localRay.from;\n            dist_bottle_to_eye=length(localRay.from-localEye);\n            break;\n        }\n        \n        localRay.from+=dist*localRay.dir;\n    }\n    \n    \n    //back side of bottle\n    localRay.from+=100.*localRay.dir;\n    localRay.dir=-localRay.dir;\n    \n    float dist_back_bottle_to_eye;\n    for(int i=0;i<20;i++){\n        float dist = bottle(localRay.from);\n        if(dist<0.01){\n\n            dist_back_bottle_to_eye=length(localRay.from-localEye);\n            break;\n        }\n        \n        localRay.from+=dist*localRay.dir;\n    }\n    \n    //plane of water\n    float param_plane_rot=0.5*PI+0.1*PI*(sin(iTime*5.0));\n    vec3 planeN =vec3(0.,sin(param_plane_rot),cos(param_plane_rot));\n    vec3 help = vec3(0.0,1.0,0.0);\n    vec3 planeAxisX = vec3(1.0,0.0,0.0);\n    float lower_factor=1.5;\n     \n    //pull cos funciton  down，for reasonable water level\n    vec3 planeC =obj_offset+vec3(0.,(cos(iTime)-1.0)*lower_factor+1.0,0.);\n    \n\tvec3 planeColor;\n    vec3 hitPos;\n    bool hit_plane=hitPlane(ray,planeN,planeC,hitPos);\n    if(hit_plane )\n    {\n        float d=length(hitPos-eye);\n        //between back side of bottle and front side of bottle\n        if(d<dist_back_bottle_to_eye && d>dist_bottle_to_eye )\n        {\n            float thickness_inverse =min(max(1.0-(dist_back_bottle_to_eye-d)*0.3,0.),1.);\n            return mix(vec3(0.1)+water_color*thickness_inverse,bottle_color,0.25);  \n        }\n    }\n    \n    vec3 bottle_hit_pos_world = obj_offset\n        + bottle_hit_pos.x* xAxis+bottle_hit_pos.y* yAxis+bottle_hit_pos.z* zAxis;\n    \n    bool normalBackFace =dot(bottle_hit_pos_world-planeC,planeN)<0.0;\n    \n    if(hit_bottle)\n    {\n        \n        if(normalBackFace){\n    \t\tfloat thickness_inverse =min(max(1.0-(dist_back_bottle_to_eye-dist_bottle_to_eye)*0.3,0.),1.);\n        \treturn mix(back_color,mix(water_color*thickness_inverse,bottle_color,0.25),0.5);\n        }else\n            return mix(back_color,bottle_color,0.5);       \n    }\n    \t\n    shadingColor=back_color;\n    return shadingColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // weight (from -1 to 1)\n    vec2 weight = fragCoord/iResolution.xy;\n    weight= weight*2.0-1.0;\n\n    vec3 lookAt =vec3(0.0,1.0,0.0);\n    vec3 eye = vec3(0.0,1.0,5.0);\n    //vec3 eye = lookAt+ 5.0*vec3(cos(iTime),0.0,sin(iTime))+vec3(0.0,1.0,0.0);\n\n    // camera 3 axis\n    vec3 zAsix = normalize(eye-lookAt);\n    vec3 yAxis = vec3(0.0,1.0,0.0);\n    vec3 xAxis = cross(yAxis,zAsix);\n    \n    //near plane of view frustum (z = -1)\n    float fovDegree =90.0;\n    float halfFov = radians(0.5*fovDegree);\n    float tanH = tan(halfFov);\n    float tanW = tanH*iResolution.x/iResolution.y;\n\n    // generate point from the plane\n    vec3 pointOnPlane = eye -zAsix + xAxis*weight.x*tanW + yAxis*weight.y*tanH;\n\n    // disturb ray dir\n    float A =0.1*sin(0.5*iTime);\n    //pointOnPlane+=vec3(A*sin(10.*weight.y+5.*iTime),0.,0.);\n    \n    // Antialiasing\n    Ray[4] rays =createRayDiff(eye,xAxis,yAxis,pointOnPlane);\n    \n    vec3 color= vec3(0.0,0.0,0.0);\n    for(int i=0;i<1;++i)\n        color += shading(rays[i],eye);\n    // color *=0.25;\n\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}