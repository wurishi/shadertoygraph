{"ver":"0.1","info":{"id":"dsffz8","date":"1688436951","viewed":52,"name":"Madeira","username":"lidaniel321","description":"Animation of a fixed piece of wood, rotated by a light and generating its shadow. Use the mouse to rotate the animation.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["wood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON .0001\n#define MAX_VIEW_STEPS 100\n#define MAX_SHADOW_STEPS 64\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR .5\n#define MAX_DEPTH 10.0\n#define BUMP_FACTOR .03\n#define TEX_SCALE_FACTOR .4\n#define BOX_POS vec3 (0.0, 0.0, 0.0)\n#define BOX_DIM vec3 (2.0,1.0, 0.5)\n#define SPHERE_POS vec3(0.0, 0.0, 0.0)\n#define SPHERE_DIM 1.25\n#define LIGHT_COLOR vec4(10.0)\n#define PEN_FACTOR 50.0\n#define MAT_COLOR vec4(0.139, 0.069, 0.019, 1.0)\n#define MAT_GLOSS 1.0\n\nstruct Light\n{\n\tvec3 position;\n\tvec4 color;\n\tfloat brightness;\n\tfloat penumbraFactor;\n};\n\nstruct Material\n{\n\tvec4 color;\n\tfloat gloss;\n};\n\t\nvoid camPolar( out vec3 pos, out vec3 dir, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 fragCoord )\n{\n\tvec2 c = cos(rotation);\n\tvec4 s;\n\ts.xy = sin(rotation);\n\ts.zw = -s.xy;\n\n\tdir.xy = fragCoord.xy - iResolution.xy*.5;\n\tdir.z = iResolution.y*zoom;\n\tdir = normalize(dir);\n\t\n\tdir.yz = dir.yz*c.x + dir.zy*s.zx;\n\tdir.xz = dir.xz*c.y + dir.zx*s.yw;\n\t\n\tpos = origin - dist*vec3(c.x*s.y,s.z,c.x*c.y);\n}\t\n\t\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\nfloat distSphere( vec3 samplePos, vec3 spherePos, float radius)\n{\n\tvec3 normal;\n\tfloat bump = 0.0;\n\tif(length(samplePos-spherePos) < radius+BUMP_FACTOR)\n\t{\t\n\t\tnormal = normalize(samplePos-spherePos);\n\t\tbump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;\n\t}\n\treturn length(samplePos-spherePos)-radius+bump;\n}\n\nfloat distBox(vec3 samplePos, vec3 boxPos, vec3 boxDim)\n{\t\n\tvec3 normal;\n\tfloat bump = 0.0;\n\tif(length(samplePos-boxPos) < length(boxDim))\n\t{\n\t   \tnormal = normalize(samplePos-boxPos);\n \t\tbump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;\n\t}\n\tvec3 d = abs(samplePos-boxPos) - boxDim;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0))+bump;\n}\n\nfloat getDist(vec3 samplePos)\n{\n\treturn min(distBox(samplePos, BOX_POS, BOX_DIM), \n\t\t\t   distBox(samplePos, vec3(0.0, -5.0, 0.0), vec3(4.0, 4.0, 4.0)));\n}\n\nvoid marchThroughField(inout vec3 pos, vec3 dir, vec3 eye)\n{\n\tfloat dist;\n\tfor(int i = 0; i < MAX_VIEW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON || length(pos-eye) > MAX_DEPTH-EPSILON)\t\t\t\n\t\t\treturn;\n\t\telse\t\n\t\t\tpos += dir*dist;\n\t}\n\treturn;\n}\n\nvec3 getNormal(vec3 pos)\n{\n\tfloat d=getDist(pos);\n\treturn normalize(vec3( getDist(pos+vec3(EPSILON,0,0))-d, getDist(pos+vec3(0,EPSILON,0))-d, getDist(pos+vec3(0,0,EPSILON))-d ));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-getDist(normalPos);\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\nfloat calcShadow( vec3 origin, vec3 lightDir, Light light)\n{\n\tfloat dist;\n\tfloat result = 1.0;\n\tfloat lightDist = length(light.position-origin);\n\t\n\tvec3 pos = vec3(origin)+(lightDir*(EPSILON*15.0+BUMP_FACTOR));\n\t\n\tfor(int i = 0; i < MAX_SHADOW_STEPS; i++)\n\t{\n\t\tdist = getDist(pos);\n\t\tif(dist < EPSILON)\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\t\tif(length(pos-origin) > lightDist || length(pos-origin) > MAX_DEPTH)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tpos+=lightDir*dist;\n\t\tif( length(pos-origin) < lightDist )\n\t\t{\n\t\t\tresult = min( result, light.penumbraFactor*dist / length(pos-origin) );\n\t\t}\n\t}\n\treturn result;\n}\n\nvec4 calcLighting(vec3 samplePos, vec3 eye, Light light, Material material)\n{\n\tfloat lightDist = length(light.position-samplePos);\n\tvec3 lightDir = normalize(light.position-samplePos);\n\tvec3 eyeDir = normalize(samplePos-eye);\n\tvec3 surfaceNormal = getNormal(samplePos);\n\tvec3 reflection = normalize(reflect(eyeDir, surfaceNormal));\n\t\n\tfloat specular = pow(max( 0.0, dot(lightDir, reflection)), 72.0);\n\tfloat diffuse = max( 0.0, dot(lightDir, surfaceNormal));\n\tfloat ambient = .05;\n\t\n\tfloat attenuation = min(1.0, 1.0/(lightDist/light.brightness));\n\tfloat shadow = calcShadow(samplePos, lightDir, light);\n\tfloat occlusion = calcOcclusion(samplePos, surfaceNormal);\n\t\n\treturn light.color*material.color*clamp(((specular+diffuse)*shadow*attenuation)+(ambient*occlusion), 0.0, 1.0);\n}\n\nvec4 shade(vec3 pos, vec3 eye, Light light, Material material)\n{\n\tif(length(pos-eye) > MAX_DEPTH-EPSILON) return vec4(0.0);\n\telse return calcLighting(pos, eye, light, material);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 pos, dir, eye;\n\tcamPolar(pos, dir, vec3(0.0), vec2(.5,iMouse.x*.0075+.025), 3.75, 1.0, fragCoord);\n\teye = vec3(pos);\n\tLight light = Light(vec3(3.0*sin(iTime+1.3), 3.5, 3.0*cos(iTime+1.3)), LIGHT_COLOR, 3.0, PEN_FACTOR);\n\tMaterial mat = Material(MAT_COLOR, MAT_GLOSS);\n\t\n\tmarchThroughField(pos, dir, eye);\n\t\n\tfragColor = shade(pos, eye, light, mat);\n}\n","name":"Image","description":"","type":"image"}]}