{"ver":"0.1","info":{"id":"flyXR1","date":"1640134832","viewed":79,"name":"octagon viewer","username":"Jonkel","description":"did this to prove that octagons exist and it's okay, a friend had problems seeing slightly rotated octagons being the same thing, so made this visualizer for him. you can click to zoom in and stuff.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["octagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// ab is segment, c is point\nfloat sqDistPointSegment(in vec2 a, in vec2 b, in vec2 c)\n{\n    vec2 ab = b-a, ac = c-a, bc = c-b;\n    \n    float e = dot(ac, ab);\n    \n    if(e <= 0.0) return dot(ac, ac);\n    \n    float f = dot(ab, ab);\n    \n    if(e >= f) return dot(bc,bc);\n    \n    return dot(ac,ac) - e*e/f;\n}\n\n\n\nvec2 size = vec2(100.0, 100.0);\n\nint lineCount = 0;\n\nfloat maxTime = 1.0;\n\nfloat radius = 15.0;\n\nfloat tau = 6.283185307179586;\n    \n\nvec2 getVertForIndex(in int index, float addedAngle, vec2 ringPos)\n{\n\n    \n    float angle = tau / 8.0 * float(index);\n    \n    return vec2( radius * cos( addedAngle + angle) + ringPos.x, radius * sin( addedAngle + angle) + ringPos.y); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n\n\n    \n    vec3 col;\n    \n    vec2 cameraTL = vec2(0,0);\n    \n        \n        \n     \n    // Camera transform\n    \n    float sizeFactor = 5.5;\n    vec2 currentSize = iResolution.xy / sizeFactor;\n    \n    if(iMouse.z > 0.0 || iMouse.w > 0.0)\n    {\n   \n        currentSize = iResolution.xy / sizeFactor * 0.2;\n       \n        cameraTL.x = iMouse.x / sizeFactor - currentSize.x / 2.0;\n        cameraTL.y = iMouse.y / sizeFactor - currentSize.y / 2.0;\n    }\n    \n    \n    \n\n    vec2 pos = uv * currentSize + cameraTL;\n    \n    \n\n\n    float dist1 = 0.0;\n    float dist2 = 0.0;\n    float dist3 = 0.0;\n    float dist4 = 0.0;\n    float dist5 = 0.0;\n    float dist6 = 0.0;\n    int currentLineCount = 8;\n    \n    vec2 ringPos = vec2(35.0,50.0);\n   \n\n\n    float lineWidth = 0.5;\n    \n    for(int i = 0; i < currentLineCount; i++)\n    {\n        float angle = tau / 16.0;\n        dist1 += lineWidth-clamp(sqDistPointSegment(getVertForIndex(i,angle,ringPos), getVertForIndex(i+1,angle, ringPos), pos), 0.0, lineWidth);   \n    }\n    \n    col.g += dist1 * 3.0;\n    \n\n    for(int i = 0; i < currentLineCount; i++)\n    {\n        float angle = tau / 16.0;\n        float timeFac =  sin(iTime * 2.0) / 4.0 - 0.1;\n        dist2 += lineWidth-clamp(sqDistPointSegment(getVertForIndex(i,angle + timeFac, ringPos), getVertForIndex(i+1,angle + timeFac, ringPos), pos), 0.0, lineWidth);   \n    }\n    col.r +=  dist2 * 3.0;\n    \n    \n    for(int i = 0; i < currentLineCount; i++)\n    {\n        // 0.261799 radians is 15 degrees\n        float angle = 0.261799;\n        dist3 += lineWidth-clamp(sqDistPointSegment(getVertForIndex(i,angle, ringPos), getVertForIndex(i+1,angle, ringPos), pos), 0.0, lineWidth);   \n    }\n    col.b +=  dist3 * 3.0f;\n    \n    \n    for(int i = 0; i < currentLineCount; i++)\n    {\n        // 0.261799 radians is 15 degrees\n        float angle = 0.261799;\n        dist4 += lineWidth-clamp(sqDistPointSegment(getVertForIndex(i,angle, vec2(70, 50)), getVertForIndex(i+1,angle, vec2(70, 50)), pos), 0.0, lineWidth);   \n    }\n    col.b +=  dist4 * 3.0f;\n    \n    \n    for(int i = 0; i < currentLineCount; i++)\n    {\n        float angle = tau / 16.0;\n        float timeFac =  sin(iTime * 2.0) / 4.0 - 0.1;\n        dist5 += lineWidth-clamp(sqDistPointSegment(getVertForIndex(i,angle + timeFac, vec2(70, 50) + vec2(35,0) * abs(sin(iTime / 4.0))), getVertForIndex(i+1,angle + timeFac,  vec2(70, 50) + vec2(35,0) * abs(sin(iTime / 4.0))), pos), 0.0, lineWidth);   \n    }\n    col.r +=  dist5 * 3.0;\n    \n      for(int i = 0; i < currentLineCount; i++)\n    {\n        float angle = tau / 16.0;\n        dist6 += lineWidth-clamp(sqDistPointSegment(getVertForIndex(i,angle, vec2(70, 18) + vec2(0,32) * abs(sin(iTime / 4.0)) ), getVertForIndex(i+1,angle,  vec2(70, 18) + vec2(0,32) * abs(sin(iTime / 4.0))), pos), 0.0, lineWidth);   \n    }\n    \n    col.g += dist6 * 3.0;\n\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}