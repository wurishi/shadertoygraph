{"ver":"0.1","info":{"id":"ldcyW4","date":"1518902570","viewed":6234,"name":"tardigrade","username":"zguerrero","description":"A cute little  tardigrade, you can use the mouse to turn around","likes":165,"published":1,"flags":32,"usePreview":0,"tags":["ray","blur","modeling","marching","distance","field","micro","tardigrade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 SinusNoise(vec2 uv)\n{\n    vec4 s = sin(uv.xyxy * vec4(6.0, 5.5, 5.8, 6.3) + iTime * vec4(0.1, 0.13, -0.2, -0.06));\n    vec4 s2 = sin(uv.xyxy * vec4(7.2, 6.8, 7.4, 6.5) + iTime * vec4(-0.07, -0.08, 0.1, 0.8) + s); \n    return vec2(s2.x + s2.y, s2.z + s2.w);\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 sNoise = SinusNoise(uv*2.0);\n    uv += sNoise*0.005;\n    \n\tvec4 t0 = textureLod(iChannel0, uv, 0.0);\n    \n    float h = hash12(uv)*0.2+0.8;\n    \n\tvec4 res = (t0.xxxx + t0.w*1.5) * mix(1.0, h, clamp(t0.y, 0.5, 1.0));\n        \n\tfragColor = pow(res*1.1, vec4(1.75));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float epsilon = 0.01;\nconst float pi = 3.14159265359;\nconst float halfpi = 1.57079632679;\nconst float twopi = 6.28318530718;\n\n#define LIGHT normalize(vec3(1.0, 1.0, 0.0))\n\n//Quatertion Formula taken from http://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 RotationToQuaternion(vec3 axis, float angle)\n{\n    float half_angle = angle * halfpi / 180.0;\n    vec2 s = sin(vec2(half_angle, half_angle + halfpi));\n    return vec4(axis * s.x, s.y);\n}\n\nvec3 Rotate(vec3 pos, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n\tvec4 q = RotationToQuaternion(axis, angle);\n    return pos + 2.0 * cross(q.xyz, cross(q.xyz, pos) + q.w * pos);\n}\n\nmat2 Rot(float a) \n{\n    vec2 s = sin(vec2(a, a + pi/2.0));\n    return mat2(s.y,s.x,-s.x,s.y);\n}\n\n//Distance Field function by iq :\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) \n{\n    return (length(p/r ) - 1.) * min(min(r.x,r.y),r.z);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//taken from shane's desert canyon, originaly a modification of the smin function by iq\n//https://www.shadertoy.com/view/Xs33Df\nfloat smax(float a, float b, float s)\n{   \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\nfloat Claws(vec3 pos, vec3 size, vec4 angles)\n{\n    vec2 s = normalize(vec2(10.0, 1.0));\n    float height = 5.0;\n    vec3 a =  pos.y * angles.w + angles.xyz;\n    float c1 = sdEllipsoid(Rotate(pos, vec3(0.0, 0.0, 1.0), a.x), size);\n    float c2 = sdEllipsoid(Rotate(pos + vec3(0.0, 0.0, size.x), vec3(1.0, 0.0, 1.0), a.y), size);\n    float c3 = sdEllipsoid(Rotate(pos - vec3(0.0, 0.0, size.x), vec3(-1.0, 0.0, 1.0), a.z), size);\n    \n    return max(min(min(c1, c2), c3), pos.y);\n}\n\nfloat Leg(vec3 pos, vec3 axis, float angle, vec3 size, vec4 angles)\n{\n    pos = Rotate(pos, axis, angle);\n    float claw = Claws(pos + vec3(0.0, size.y*0.5, 0.0), vec3(0.075, 0.75, 0.075)*size.y, angles);\n    float leg = sdEllipsoid(pos, size);\n    return min(leg, claw);\n}\n\nfloat Teeth(vec3 pos)\n{\n    vec3 polarPos;\n    polarPos.x = atan(pos.x, pos.y) / 3.14;\n    polarPos.y = length(pos.xy)-0.12;\n    polarPos.z = pos.z;\n    \n    vec3 p = opRep(polarPos, vec3(0.25, 7.0, 0.0));\n    p.y = polarPos.y;\n    p.z = pos.z;\n    \n    return sdEllipsoid(p, vec3(0.07, 0.05, 0.07));\n}\n\nfloat ZCylindricalDisplace(vec3 pos, vec2 size)\n{\n    vec2 uv;\n    uv.x = (atan(pos.x, pos.y));\n    uv.y = pos.z;\n    float m = smoothstep(0.1, 1.0, length(pos.xy)) * smoothstep(-1.0, -0.75, cos(uv.x));\n    \n    return textureLod(iChannel0, uv * size, 0.0).x * m;\n}\n\nvec3 TransformPosition(vec3 pos)\n{\n    pos.yz *= Rot((pos.z + 2.0)*sin(iTime*0.3)*0.2);\n    pos.xy *= Rot(pos.z*sin(iTime*0.1)*0.25);\n    pos.y -= 0.5 + sin(iTime*0.5)*0.2; \n    \n    return pos;\n}\n\nfloat Tardigrade(vec3 pos)\n{ \n\tpos = TransformPosition(pos);\n    float s = 0.01;\n    \n    //Body\n    float bodyCenter = sdEllipsoid(Rotate(pos, vec3(1.0, 0.0, 0.0), 10.0), vec3(1.2,0.9,1.0));\n    float bodyFront = sdEllipsoid(Rotate(pos + vec3(0.0, 0.1, 0.8), vec3(1.0, 0.0, 0.0), 20.0), vec3(1.0,0.7,0.9));\n    float bodyFront2 = sdEllipsoid(Rotate(pos + vec3(0.0, 0.3, 1.5), vec3(1.0, 0.0, 0.0), 40.0), vec3(0.7,0.5,0.7));\n    float bodyBack = sdEllipsoid(Rotate(pos + vec3(0.0, 0.0, -0.6), vec3(1.0, 0.0, 0.0), -10.0), vec3(1.0,0.75,1.0));\n    float bodyBackHole = sdEllipsoid(pos + vec3(0.0, 0.2, -1.5), vec3(0.03,0.03,0.5));\n    \n    float body = smax(smin(smin(bodyCenter, smin(bodyFront, bodyFront2, s), s), bodyBack, s), -bodyBackHole, 0.15);\n    body -= ZCylindricalDisplace(pos + vec3(0.0, 0.3, 0.0), vec2(0.05, 0.25)) * 0.15;\n    \n    //Mouth\n    float mouth0 = sdSphere(pos + vec3(0.0, 0.7, 2.25), 0.15);\n    float mouth1 = sdEllipsoid(pos + vec3(0.0, 0.6, 2.125), vec3(0.22,0.175,0.175));\n    float mouth2 = sdEllipsoid(pos + vec3(0.0, 0.67, 2.25), vec3(0.125,0.1,0.2));\n    float teeth0 = Teeth(Rotate(pos + vec3(0.0, 0.62, 2.15), vec3(1.0, 0.0, 0.0), 35.0));\n     \n    //Head\n    float head = sdEllipsoid(Rotate(pos + vec3(0.0, 0.45, 1.9), vec3(1.0, 0.0, 0.0), 50.0), vec3(0.45,0.3,0.5));\n    head = min(smax(smin(mouth1, smax(head, -mouth0, 0.3), s), -mouth0, 0.02), teeth0);\n    head -= textureLod(iChannel0, pos.xy*0.4, 0.0).x*0.03;\n    \n    vec3 symPos = vec3(-abs(pos.x), pos.y ,pos.z); \n    vec3 p;\n    \n    //Legs\n    p = Rotate(symPos + vec3(0.75, 0.5, -1.15), vec3(1.0, 0.0, -1.0), 20.0);\n    float leg0 = Leg(p, vec3(1.0, 0.0, 0.0), 0.0, vec3(0.2,0.5,0.25), vec4(20.0, -10.0, -10.0, 30.0));\n    \n    p = Rotate(symPos + vec3(1.0, 0.55, 0.0), vec3(1.0, 0.0, -1.0), 10.0);\n    float leg1 = Leg(p, vec3(1.0, 0.0, 0.0), 0.0, vec3(0.3,0.6,0.35), vec4(25.0, -5.0, -10.0, 40.0));\n    \n    p = Rotate(symPos + vec3(0.9, 0.6, 1.0), vec3(1.0, 0.0, 1.0), -5.0);\n    float leg2 = Leg(p, vec3(1.0, 0.0, 0.0), 0.0, vec3(0.2,0.5,0.25), vec4(15.0, -10.0, -5.0, 35.0));\n\n    p = Rotate(symPos + vec3(0.55, 0.7, 1.7), vec3(1.0, 0.0, 0.0), -10.0);\n    float leg3 = Leg(p, vec3(1.0, 0.0, 0.0), 0.0, vec3(0.15,0.3,0.15), vec4(15.0, -15.0, -15.0, 50.0));\n    \n    float legs = min(min(min(leg0, leg1), leg2), leg3);\n    legs -= textureLod(iChannel0, pos.yz*vec2(0.2, 0.5), 0.0).x * 0.02;\n    \n    body = smin(body, legs, 0.05);\n\n    float res = smin(body, head, s);\n    \n\treturn res;\n}\n\nvec3 RayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int maxItter = 128;\n\tconst float maxDist = 30.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = epsilon;\n    float itter = 0.0;\n    \n    for(int i = 0; i < maxItter; i++)\n\t{\n       \tdist = Tardigrade(pos);\n        itter += 1.0;\n\t\ttotalDist += dist; \n\t\tpos += dist * rayDir;\n        \n        if(dist < epsilon || totalDist > maxDist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return vec3(dist, totalDist, itter/128.0);\n}\n\nfloat AO(vec3 pos, vec3 n)\n{\n\tfloat res = 0.0;\n    vec3 aopos = pos;\n    \n\tfor( int i=0; i<3; i++ )\n\t{   \n        aopos = pos + n*0.2*float(i);\n\t\tfloat d = Tardigrade(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0.0, 1.0);   \n}\n\n\n//Camera Function by iq :\n//https://www.shadertoy.com/view/Xds3zN\nmat3 SetCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//Normal and Curvature Function by Nimitz;\n//https://www.shadertoy.com/view/Xts3WM\nvec4 NorCurv(in vec3 p)\n{\n    vec2 e = vec2(-epsilon, epsilon);   \n    float t1 = Tardigrade(p + e.yxx), t2 = Tardigrade(p + e.xxy);\n    float t3 = Tardigrade(p + e.xyx), t4 = Tardigrade(p + e.yyy);\n\n    float curv = .25/e.y*(t1 + t2 + t3 + t4 - 4.0 * Tardigrade(p));\n    return vec4(normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4), curv);\n}\n\nvec3 Lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos)\n{\n    float diff = max(0.0, dot(LIGHT, n));\n    float spec = pow(max(0.0, dot(reflectDir, LIGHT)), 10.0);\n    float rim = (1.0 - max(0.0, dot(-n, rayDir)));\n\n    return vec3(diff, spec, rim)*0.5; \n}\n\nfloat TriplanarTexture(vec3 pos, vec3 n)\n{\n    pos = TransformPosition(pos);\n    n = abs(n);\n    float t0 = texture(iChannel1, pos.yz).x * n.x;\n    float t1 = texture(iChannel1, pos.zx).y * n.y;\n    float t2 = texture(iChannel1, pos.xy).z * n.z;\n    \n    return t0 + t1 + t2; \n}\n\nfloat BackGround(vec3 rayDir)\n{\n    float grad = 1.0 - abs(rayDir.y);\n    vec2 uv = vec2((atan(rayDir.x, rayDir.z) - pi)/(twopi), rayDir.y*0.5+0.5);\n\tfloat t0 = texture(iChannel0, uv * vec2(1.0, 0.75) + iTime * vec2(0.01, 0.01)).x;\n    float t1 = texture(iChannel0, uv * vec2(1.0, 0.6) + iTime * vec2(-0.01, -0.01)).x;\n   \tfloat sun = smoothstep(1.0, 0.0, clamp(length(rayDir - LIGHT), 0.0, 1.0));\n    \n    return grad * t0 * t1 * 1.5 + sun*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec3 cameraOrigin = vec3(0.0, 0.0, 0.0);\n    \n    if(iMouse.z > 0.0)\n    {\n    \tcameraOrigin.x = sin(iMouse.x*0.01) * 5.0;\n    \tcameraOrigin.y = iMouse.y*0.05 - 10.0;\n    \tcameraOrigin.z = cos(iMouse.x*0.01) * 5.0;  \n    }\n    else    \n    {\n        cameraOrigin.x = sin(iTime*0.25 + 2.0) * (6.0 + sin(iTime * 0.1));\n    \tcameraOrigin.y = sin(iTime*0.3) - 0.5;\n    \tcameraOrigin.z = cos(iTime*0.25 + 2.0) * (6.0 + sin(iTime * 0.15)); \n    }\n    \n\tvec3 cameraTarget = vec3(0.0, 0.25, -1.0);\n    \n\tvec2 screenPos = uv * 2.0 - 1.0;\n    \n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n    mat3 cam = SetCamera(cameraOrigin, cameraTarget, sin(iTime*0.15)*0.5);\n    \n    vec3 rayDir = cam*normalize(vec3(screenPos.xy,2.0));\n    vec3 dist = RayMarch(rayDir, cameraOrigin);\n    \n    float res;\n\tfloat backGround = BackGround(rayDir);\n    \n\tif(dist.x < epsilon)\n    {\n        vec3 pos = cameraOrigin + dist.y*rayDir;\n        vec4 n = NorCurv(pos);\n        float ao = AO(pos, n.xyz);\n        vec3 r = reflect(rayDir, n.xyz);\n\t\tvec3 l = Lighting(n.xyz, rayDir, r, pos);\n        \n        float col = TriplanarTexture(pos, n.xyz);\n        col *= n.w*0.5+0.5;\n        col *= ao;\n        col += ao * (l.x + l.y);\n        col += l.z*0.75;\n        col += BackGround(n.xyz)*0.25;\n\n        res = col;\n    }\n    else\n    {\n        res = backGround; \n    }\n    \n\tfragColor = vec4(res, dist.x, 0.0, dist.z);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//BlurPass 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = BlurPass(fragCoord.xy, iResolution.xy, 1.5, iChannel0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//BlurPass 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = BlurPass(fragCoord.xy, iResolution.xy, 3.0, iChannel0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 BlurPass(vec2 fragCoords, vec2 resolution, float sampleDistance, sampler2D tex)\n{     \n    vec2 uv = fragCoords/resolution;\n    float v = smoothstep(0.15, 0.5, length(uv - vec2(0.5)));\n    vec4 t = vec4(0.0);\n    float itter = 0.0;\n    \n    for(float i = -2.0; i <= 2.0; i++)\n    {\n        for(float j = -2.0; i <= 2.0; i++)\n        {\n\t\t\tt += texture(tex, uv + (vec2(i, j) / resolution) * sampleDistance * v);\n            itter += 1.0;\n        } \n    }\n    \n    return t / itter;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//BlurPass 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = BlurPass(fragCoord.xy, iResolution.xy, 6.0, iChannel0);\n}","name":"Buf D","description":"","type":"buffer"}]}