{"ver":"0.1","info":{"id":"3tGBD1","date":"1614225504","viewed":86,"name":"Lichen","username":"baksej","description":"Lichen","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","life"],"hasliked":0,"parentid":"WlGfW1","parentname":"Color Wars"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//\tadded color and initialization to https://www.shadertoy.com/view/lddGWj -- can use the mouse\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://thebookofshaders.com/11/\nfloat rnd (vec2 st) {\n    return fract(sin(dot(st.xy * .01,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rnd(i);\n    float b = rnd(i + vec2(1.0, 0.0));\n    float c = rnd(i + vec2(0.0, 1.0));\n    float d = rnd(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat food(vec2 st) {\n return noise((st/iResolution.xy)*17.0+vec2(iTime*.1, 0.0)) + .1;\n}\nbool hot(vec2 st) {\n    float freq = .2;\n    float f = food(st);\n    return rnd(st + vec2(iTime)) < freq * f;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n            \n    \n\t\n    \n    \n    //float r = rnd(fragCoord *.01+ vec2(iTime, iTime));\n    \n    \n    if (iFrame == 0){\n        float r = rnd(fragCoord + vec2(0, iDate[3])) + rnd(fragCoord + vec2(0, 2));\n       \n\n        fragColor = vec4(r < .001, 0.0, 0.0, 1);\n    }else{\n        vec2 left = fragCoord+vec2(-1,0);\n        vec2 right = fragCoord+vec2(1,0);\n        vec2 above = fragCoord+vec2(0,-1);\n        vec2 below = fragCoord+vec2(0,1);\n        \n        vec4 a = texture(iChannel0, fragCoord/iResolution.xy);\n        vec4 b = vec4(0);\n        \n        \n        float freq = .15;\n        \n        \n        // hot neighbor?\n        if (hot(left)) {\n            b = texture(iChannel0, left/iResolution.xy);\n        }\n        if (hot(right)) {\n            b = texture(iChannel0, right/iResolution.xy);\n        }\n        if (hot(above)) {\n            b = texture(iChannel0, above/iResolution.xy);\n        }\n        if (hot(below)) {\n            b = texture(iChannel0, below/iResolution.xy);\n        }\n        if (b.r > 0.5 && a.r == 0.0) {\n            a.r = 1.0;\n        } \n           \n        // i'm hot?\n        if (hot(fragCoord)) {   \n           a.r -= .01;\n        }\n        \n        // maybe don't factor food into hot\n        // just factor it into spread\n        \n     //  a.b = food(fragCoord);\n        \n        \n        \n        // vec4 right = texture(iChannel0,(fragCoord+vec2( 0, 1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 0,-1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 1,-1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 1, 0))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2( 1, 1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2(-1,-1))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2(-1, 0))/iResolution.xy);\n             //texture(iChannel0,(fragCoord+vec2(-1, 1))/iResolution.xy);\n             \n       // float r = rnd(fragCoord *.01+ vec2(0, 1));\n       // r += rnd(fragCoord *.01+ vec2(0, 2));\n        \n        \n        fragColor = clamp(a, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}