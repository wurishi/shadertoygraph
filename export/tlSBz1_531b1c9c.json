{"ver":"0.1","info":{"id":"tlSBz1","date":"1663188078","viewed":146,"name":"Twin peaks","username":"Alpaga","description":"The floor texture is filtered","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A good occasion for me to learn texture filtering from Inigo Quilez:\n// https://iquilezles.org/articles/filtering/\n//\n// I hope I implemented it correctly!\n\nconst float azimuthSpeed = 0.3;\nconst float altitudeSpeed = 0.4;\n\nconst float fov = 35.0;\n\n// Quality of filtering\n// Try 1.0 to see the difference.\nconst float aa = 4.0;\n\nconst float roomSize = 2.0;\nconst vec3 lightColor = 5.0*vec3(1.0,0.8,0.5);\n\nconst vec3 ambient = vec3(0.05,0.00,0.0);\nconst vec2 lamp = vec2(0.8,1.6);\n\nconst vec2 delta = vec2(0.0,0.01);\n\nfloat hash( float x ) {\n    return fract(sin(x * 12.9898) * 43758.5453);\n}\nfloat noise(float x) {\n    float p = floor(x);\n    float f = x-p;\n    return mix(hash(p),hash(p+1.0),f);\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\nfloat sdLamp(vec3 p) {\n    float radius = length(p.xz-lamp);\n    \n    float cyl = max(p.y-0.5, radius-0.007);\n    float cone = max(p.y-0.8,max(0.5-p.y,0.5*(radius-0.007-pow(p.y-0.5,2.0))));\n    return min(cyl,cone);\n}\nfloat sdLamps(vec3 p) {\n    vec3 q = p;\n    q.xz = abs(q.xz);\n    return sdLamp(q);\n}\nfloat sdCurtain(vec3 p) {\n    // Sending p to the region p.x >= abs(p.z)\n    float sum = abs(p.x+p.z);\n    float dif = abs(p.x-p.z);\n    p.xz = 0.5*vec2(sum+dif,sum-dif);\n\n    return max(0.05-p.y,\n        0.5*(abs(p.x - roomSize + \n        0.025*smoothstep(-2.0,0.0,-p.y) * sin((60.0+6.0*noise(15.0*p.z))*p.z))-0.05));\n}\nfloat sd(vec3 p) {\n    float df = sdFloor(p);\n    float dc = sdCurtain(p);\n    float dl = sdLamps(p);\n    return min(min(df,dc),dl);\n}\nint getId(vec3 p) {\n    float df = sdFloor(p);\n    float dc = sdCurtain(p);\n    float dl = sdLamps(p);\n    return df < min(dc,dl) ? 0 : dc < dl ? 1 : 2;\n}\nvec3 normalCurtain(vec3 p) {\n    float d = sdCurtain(p);\n    return normalize(vec3(\n        sdCurtain(p+delta.yxx),\n        sdCurtain(p+delta.xyx),\n        sdCurtain(p+delta.xxy))-d);\n}\nvec3 normalLamps(vec3 p) {\n    float d = sdLamps(p);\n    return normalize(vec3(\n        sdLamps(p+delta.yxx),\n        sdLamps(p+delta.xyx),\n        sdLamps(p+delta.xxy))-d);\n}\nvec3 floorColor(vec2 p) {\n    p.xy *= 3.0;\n    p.x = abs(mod(p.x,1.0)-0.5);\n    vec3 col;\n    float a = mod(p.y-p.x, 0.5);\n    if(a<0.25)\n        col = vec3(0.1,0.0,0.0);\n    else\n        col = vec3(1.0);\n\n    return col;\n}\n// Filtering the floor procedural texture\n// https://iquilezles.org/articles/filtering/\nvec3 floorColor(vec2 p, vec2 px, vec2 py, vec2 pxy) {\n    vec3 col = vec3(0.0);\n    vec2 pbot, ptop;\n    float e = 1.0/aa;\n    for(float i = 0.5*e; i < 1.0; i += e) {\n    \tpbot = mix(p, px, i);\n        ptop = mix(py, pxy, i);\n        for(float j = 0.5*e; j < 1.0; j += e) {\n        \tcol += floorColor(mix(pbot, ptop, j));\n        }\n    }\n    col /= (aa*aa);\n    return col;\n}\n\nfloat march(vec3 start, vec3 dir) {\n\tfloat t = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    for(int i=0; i<200; i++) {\n        if(d<epsilon || t>100.0) break;\n        d = sd(start + t * dir);\n        t += d;\n    }\n    return t;\n}\n\n// Taken from Inigo Quilez:\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sd(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 shade(vec3 pos, vec3 toEye, vec3 normal, vec3 color, vec3 lightPosition, float reflectivity) {\n    vec3 lightDir = lightPosition - pos;\n    float lightDist = length(lightDir);\n    lightDir = lightDir/lightDist;\n  \n    // Diffuse\n    float diff = max(dot(normal, lightDir), 0.0);\n\n    // Specular\n    vec3 h = normalize(lightDir + toEye);\n    float spec = pow(max(dot(h, normal), 0.0), 20.0) * reflectivity;\n    \n    float sh = softshadow(pos, lightDir, 0.1, lightDist, 15.0);\n    \n    return sh * (diff * color + spec) * lightColor/(1.0+10.0*lightDist*lightDist);\n}\nvec3 shade(vec3 pos, vec3 toEye, vec3 normal, vec3 color, float reflectivity) {\n    vec3 col = vec3(0.0);\n    for(float i=-1.0; i<1.1; i+=2.0) {\n        for(float j=-1.0; j<1.1; j+=2.0) {\n            col += shade(pos,toEye,normal,color,vec3(i*lamp.x,0.9,j*lamp.y),reflectivity);\n        }\n    }\n    return ambient * color + col;\n}\n\nvec3 rayColor(vec3 start, vec3 dir, vec3 dirx, vec3 diry, vec3 dirxy) {\n    float minD;\n \tfloat t = march(start, dir);\n\n    vec3 p = start + t * dir;\n    int id = getId(p);\n    \n    vec3 normal;\n    vec3 albedo;\n   \tfloat refl;\n    \n    switch(id) {\n        case 0:// Floor\n            albedo = floorColor(p.xz,\n                start.xz-dirx.xz * start.y/dirx.y,\n                start.xz-diry.xz * start.y/diry.y,\n                start.xz-dirxy.xz * start.y/dirxy.y);\n            refl = 0.04;\n            normal = vec3(0.0,1.0,0.0);\n            break;\n        case 1:// Curtain\n            albedo = vec3(0.3,0.0,0.0);\n            refl = 0.0;\n            normal = normalCurtain(p);            \n            break;\n        default:// Lamp\n            albedo = vec3(0.3);\n            refl = 1.0;\n            normal = normalLamps(p);\n    }\n    \n    return shade(p, -dir, normal, albedo, refl);\n}\nmat3 viewMatrix(vec3 cam, vec3 cen, vec3 up) {\n \tvec3 w = normalize(cam-cen);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float azimuth = azimuthSpeed*iTime;\n    float altitude = 0.35+0.1*sin(altitudeSpeed*iTime);\n    float camDistance = 1.8;\n    \n    vec3 cam = camDistance * vec3(sin(azimuth)*cos(altitude),sin(altitude),cos(azimuth)*cos(altitude));\n    vec3 center = vec3(0.0,0.35,0.0), up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 m = viewMatrix(cam, center, up);\n\n    vec2 uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 uvx = 2.0*(fragCoord + vec2(1,0) - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 uvy = 2.0*(fragCoord + vec2(0,1) - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 uvxy = 2.0*(fragCoord + vec2(1,1) - 0.5 * iResolution.xy)/iResolution.y;\n\n    float k = tan(0.5*fov*0.01745);\n    vec3 dir = normalize(m * vec3(k*uv,-1.0));\n    vec3 dirx = normalize(m * vec3(k*uvx,-1.0));\n    vec3 diry = normalize(m * vec3(k*uvy,-1.0));\n    vec3 dirxy = normalize(m * vec3(k*uvxy,-1.0));\n\n    vec3 color = rayColor(cam, dir, dirx, diry, dirxy);\n    \n    // Vignette\n    // Taken from https://www.shadertoy.com/view/XsGyDh\n    uv = fragCoord/iResolution.xy,\n    color = mix(color, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)));\n\n    // Gamma correction\n    color = pow(color,vec3(0.45));\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}