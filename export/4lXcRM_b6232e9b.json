{"ver":"0.1","info":{"id":"4lXcRM","date":"1531511401","viewed":108,"name":"background-test","username":"bytearray","description":"background and raymarching. looks funny","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarchingmusic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define MAX_MARCHING_STEPS 100\n#define EPSILON 0.0001\n#define start 0.1\n#define end 100.0\n#define mint 0.01\n\nvec3 bug = vec3(0);\n\n\nfloat sphere(in vec3 pos, in float r)\n{\n    return length(pos) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat soundSphere(vec3 pos, float r)\n{\n    float ry = atan(pos.x / pos.z);\n    float rx = atan(pos.y / pos.z);\n    \n    int a = int(fract((ry / PI / 4. + .5) * 3.) * 512.);\n    int b = int(fract((rx / PI / 4. + .5) * 3.) * 512.);\n    \n    float freq = texelFetch( iChannel0, ivec2(0, 0), 0).x; \n    float wave = texelFetch( iChannel0, ivec2(0, 1), 0).x;\n    //bug.r = float(a);\n    float disp = wave / 10. + freq;\n    \n    return length(pos) - r - disp;\n}\n\n\nvoid intersect(inout float distA, float distB)\n{\n    distA = max(distA, distB);\n}\n\nvoid combine(inout float distA, float distB)\n{\n    distA = min(distA, distB);\n}\n\nvoid difference(inout float distA, float distB)\n{\n    distA = max(-distA, distB);\n}\n\n//pos, layer direction, layer gap, laver offet, ball size\nfloat layer(vec3 p, vec3 d, vec3 g, vec3 o, float s)\n{\n    p += mod(d * iTime + o, g);\n    vec3 q = mod(p, vec3(g))-0.5*vec3(g);\n    return sphere(q, s);\n}\n\nfloat sdf(vec3 pos)\n{\n    float b = 10000.;\n    float u = .4;\n    float s = .33;\n    float k = .5;\n    \n    combine(b, layer(pos, vec3( 0., 0., s ), vec3(u*3.), vec3(0., u , 0.), k));\n    combine(b, layer(pos, vec3( 0., s , 0.), vec3(u*3.), vec3(u , 0., 0.), k));\n    combine(b, layer(pos, vec3( s , 0., 0.), vec3(u*3.), vec3(0., 0., u ), k));\n    combine(b, layer(pos, vec3( 0., 0.,-s ), vec3(u*3.), vec3(0., -u, 0.), k));\n    combine(b, layer(pos, vec3( 0.,-s , 0.), vec3(u*3.), vec3(-u, 0., 0.), k));\n    combine(b, layer(pos, vec3(-s , 0., 0.), vec3(u*3.), vec3(0., 0., -u), k));\n    \n    difference(b, soundSphere(pos, 1.));\n    return b;\n}\n\nfloat ray(vec3 eye, vec3 dir)\n{\n    float depth = start;\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        float dist = sdf(eye + depth * dir);\n        \n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nfloat shadow(vec3 pos, vec3 light)\n{\n    vec3 dir = normalize(light - pos);\n\tfloat maxt = length(light - pos);\n\n    for( float t=mint; t < maxt; )\n    {\n        float h = sdf(pos + dir*t);\n        if( h < EPSILON )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    uv.x += (1. - iResolution.x / iResolution.y) / 2.;\n    vec2 st = uv - vec2(.5);\n    \n    vec3 eye = vec3(sin(iTime)*7., cos(iTime)*5., 4.);\n    vec3 dir = vec3(st / 2., -1.);\n    vec3 light = vec3(10., 5., sin(iTime*2.)*3.);\n    \n    mat4 mat = viewMatrix(eye, vec3(0.), vec3(0., 1., 0.));\n    dir = (mat * vec4(dir, 1.)).xyz;\n    \n    float depth = ray(eye, dir);\n    if(!(depth >= end - EPSILON))\n    {\n        vec3 hit = eye + dir * depth;\n    \tvec3 norm = estimateNormal(hit)+vec3(.5);\n        float shad = shadow(hit, light);\n        norm *= shad<.5 ? vec3(.3) : vec3(1.);\n        \n        fragColor = vec4(norm, 1.);\n    }\n    else\n    {\n        vec2 bufuv = fragCoord/iResolution.xy;\n        fragColor = texture(iChannel1, bufuv);\n    }\n    fragColor.rgb += bug;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 getDirection(vec2 uv)\n{\n    return vec2(.005 * sin(uv.y*10.), 0.);\n}\n\nvec4 lastFrame(vec2 uv)\n{\n    uv += getDirection(uv);\n    if(uv.x <= 0. || uv.x >= 1. || uv.y <= 0. || uv.y >= 1.) return vec4(0);\n    \n    return texture(iChannel0, uv) * .95;\n}\n\nvec4 thisFrame(vec2 uv)\n{\n   \treturn (mod(uv.x, .1) < .01 && mod(uv.y + iTime/5., .1) < .01) ? \n        vec4(sin(iTime)/2.+.7, cos(iTime)/2.+.7, 0., 1.) : vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord / iResolution.xy;\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    fragColor = lastFrame(uv1);\n    fragColor += thisFrame(uv);\n}\n","name":"Buf A","description":"","type":"buffer"}]}