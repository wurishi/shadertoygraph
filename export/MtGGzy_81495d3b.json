{"ver":"0.1","info":{"id":"MtGGzy","date":"1475178223","viewed":493,"name":"sound path tracer","username":"sqaxomonophonen","description":"Attempt at real-time sound path tracing. The \"Image\" and \"Sound\" shaders share the same path tracing code, but they use the result in different ways. (See also https://github.com/sqaxomonophonen/echochamber for an \"offline\" version)","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["soundpathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// const int MAX_BOUNCES = 10;\n\nconst float INF = 1e10;\nconst float ROOM_SIZE = 2.0;\nconst float ROOM_EXTEND = 6.0;\nconst int MAX_BOUNCES = 5;\nconst int N_SAMPLES = 2;\n\n\n// common.glsl\n\nfloat seed;\nfloat rand() {\n\treturn fract(sin(seed+=0.15342)*35423.7652344);\n}\n\nfloat ray_aabb_intersect(in vec3 pos, in vec3 dir, in vec3 aabb_min, in vec3 aabb_max, out vec3 normal)\n{\n\tfloat t = 0.0;\n\tint hit_axis = -1;\n\tfor (int axis = 0; axis < 3; axis++) {\n\t\tfloat d = dir[axis];\n\t\tfloat p = pos[axis];\n\t\tfloat mn = aabb_min[axis];\n\t\tfloat mx = aabb_max[axis];\n\t\tfloat nt = 0.0;\n\t\tif (d >= 0.0 && p < mn) {\n\t\t\tfloat nt = (mn-p)/d;\n\t\t\tif (axis == 0 || nt > t) {\n\t\t\t\tt = nt;\n\t\t\t\thit_axis = axis;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = -1.0;\n\t\t\t}\n\t\t} else if (d < 0.0 && p > mx) {\n\t\t\tfloat nt = (mx-p)/d;\n\t\t\tif (axis == 0 || nt > t) {\n\t\t\t\tt = nt;\n\t\t\t\thit_axis = axis;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = 1.0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hit_axis < 0) return INF;\n\n\tvec3 hit = pos + dir * t;\n\tfor (int axis = 0; axis < 3; axis++) {\n\t\tif (axis == hit_axis) continue;\n\t\tif (hit[axis] < aabb_min[axis] || hit[axis] > aabb_max[axis]) {\n\t\t\treturn INF;\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat ray_invaabb_intersect(in vec3 pos, in vec3 dir, in vec3 aabb_min, in vec3 aabb_max, out vec3 normal)\n{\n\tfloat t = 0.0;\n\tfor (int axis = 0; axis < 3; axis++) {\n\t\tfloat d = dir[axis];\n\t\tfloat p = pos[axis];\n\t\tfloat mn = aabb_min[axis];\n\t\tfloat mx = aabb_max[axis];\n\t\tfloat nt = 0.0;\n\t\tif (d >= 0.0 && p < mx) {\n\t\t\tfloat nt = (mx-p)/d;\n\t\t\tif (axis == 0 || nt < t) {\n\t\t\t\tt = nt;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = -1.0;\n\t\t\t}\n\t\t} else if (d < 0.0 && p > mn) {\n\t\t\tfloat nt = (mn-p)/d;\n\t\t\tif (axis == 0 || nt < t) {\n\t\t\t\tt = nt;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = 1.0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat ray_scene_intersect(in vec3 pos, in vec3 dir, out vec3 normal, out bool hit_source)\n{\n\tfloat tt = INF;\n\n\t// source\n\tvec3 n0;\n\tfloat t0 = ray_aabb_intersect(pos, dir, vec3(-0.2, -ROOM_SIZE/3.0, -0.2), vec3(0.2, ROOM_SIZE/3.0, 0.2), n0);\n\tif (t0 < tt) {\n\t\ttt = t0;\n\t\tnormal = n0;\n\t\thit_source = true;\n\t}\n\n\t// occluder\n\tvec3 n1;\n\tfloat t1 = ray_aabb_intersect(pos, dir, vec3(-0.5, -ROOM_SIZE/2.0, -0.5), vec3(0.5, ROOM_SIZE/2.0, -0.4), n1);\n\tif (t1 < tt) {\n\t\ttt = t1;\n\t\tnormal = n1;\n\t\thit_source = false;\n\t}\n\n\tif (tt < INF) return tt;\n\n\t// room\n\thit_source = false;\n\treturn ray_invaabb_intersect(pos, dir, vec3(-ROOM_SIZE, -ROOM_SIZE, -ROOM_SIZE), vec3(ROOM_SIZE, ROOM_SIZE, ROOM_SIZE + ROOM_EXTEND), normal);\n}\n\nvec3 hemisphere_cosine_random()\n{\n\t/* see http://people.cs.kuleuven.be/~philip.dutre/GI/TotalCompendium.pdf (19a + 35) */\n\tfloat r1 = rand();\n\tfloat r2 = rand();\n\tfloat r = sqrt(r1);\n\tfloat phi = 6.2830 * r2;\n\n\treturn vec3(\n\t\tr * cos(phi),\n\t\tr * sin(phi),\n\t\tsqrt(1.0 - r*r));\n}\n\nvec3 diffuse_bdrf(vec3 normal)\n{\n\tvec3 d = hemisphere_cosine_random();\n\tvec3 bz = normal;\n\tvec3 bx = abs(bz.x) < 0.5 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 by = cross(bz, bx);\n\tbx = cross(bz, by);\n\treturn bx*d.x + by*d.y + bz*d.z;\n}\n\nfloat path_trace(in vec3 pos, in vec3 dir, out int n_bounces)\n{\n\tfloat dist = 0.0;\n\tfor (int i = 0; i < MAX_BOUNCES; i++) {\n\t\tvec3 normal;\n\t\tbool hit_source;\n\t\tfloat t = ray_scene_intersect(pos, dir, normal, hit_source);\n\t\tvec3 hit = pos + dir*t;\n\t\tdist += length(hit - pos);\n\t\tif (hit_source) {\n\t\t\tn_bounces = i;\n\t\t\treturn dist;\n\t\t} else {\n\t\t\tpos = hit;\n\t\t\tdir = diffuse_bdrf(normal);\n\t\t}\n\t}\n\treturn -1.0;\n}\n\n        \nmat4 get_observer_tx(float time)\n{\n\tfloat l = 1.9;\n\tfloat px = sin(time) * l;\n\tfloat pz = cos(time) * l;\n\n\tvec3 p = -vec3(px, 0, pz);\n\n\tvec3 r = vec3(0.1, 1.0, 0.0);\n\tvec3 w = normalize(p);\n\tvec3 u = normalize(cross(w, r));\n\tvec3 v = normalize(cross(u, w));\n\n\treturn mat4(\n\t\tvec4(u, 0.0),\n\t\tvec4(v, 0.0),\n\t\tvec4(w, 0.0),\n\t\tvec4(p, 1.0));\n}\n\nfloat mod_time()\n{\n    return fract(iTime);\n}\n\nfloat chirp_amplitude()\n{\n\treturn 1.0 / exp(10.0 * mod_time());    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \tseed = fragCoord.x + fragCoord.y/iResolution.x + iTime*0.01;\n    \n\tmat4 tx = get_observer_tx(iTime);\n\tvec3 pos = vec3(-tx[3]);\n\tvec2 dirxy = fragCoord.xy / iResolution.xy - 0.5;\n\tdirxy.x *= iResolution.x / iResolution.y;\n\tvec3 dir = mat3(tx) * vec3(dirxy, 0.7);\n\n\tvec3 col = vec3(0.0);\n\tfor (int i = 0; i < N_SAMPLES; i++) {\n\t\tint n_bounces;\n\t\tif (path_trace(pos, dir, n_bounces) > 0.0) {\n            vec3 base = vec3(2.0,2.0,0.0) * chirp_amplitude() + vec3(0.0,0.2,1.0);\n\t\t\tcol += base * vec3(\n                pow(0.9, float(n_bounces)),\n                pow(0.6, float(n_bounces)),\n                pow(0.5, float(n_bounces)));\n\t\t}\n\t}\n\tfragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"const float INF = 1e10;\nconst float ROOM_SIZE = 2.0;\nconst float ROOM_EXTEND = 10.0;\nconst int MAX_BOUNCES = 10;\nconst int N_SAMPLES = 10;\nconst float SPEED_OF_SOUND = 34.2;\n\n\nfloat seed;\nfloat rand() {\n\treturn fract(sin(seed+=0.15342)*35423.7652344);\n}\n\nfloat ray_aabb_intersect(in vec3 pos, in vec3 dir, in vec3 aabb_min, in vec3 aabb_max, out vec3 normal)\n{\n\tfloat t = 0.0;\n\tint hit_axis = -1;\n\tfor (int axis = 0; axis < 3; axis++) {\n\t\tfloat d = dir[axis];\n\t\tfloat p = pos[axis];\n\t\tfloat mn = aabb_min[axis];\n\t\tfloat mx = aabb_max[axis];\n\t\tfloat nt = 0.0;\n\t\tif (d >= 0.0 && p < mn) {\n\t\t\tfloat nt = (mn-p)/d;\n\t\t\tif (axis == 0 || nt > t) {\n\t\t\t\tt = nt;\n\t\t\t\thit_axis = axis;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = -1.0;\n\t\t\t}\n\t\t} else if (d < 0.0 && p > mx) {\n\t\t\tfloat nt = (mx-p)/d;\n\t\t\tif (axis == 0 || nt > t) {\n\t\t\t\tt = nt;\n\t\t\t\thit_axis = axis;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = 1.0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hit_axis < 0) return INF;\n\n\tvec3 hit = pos + dir * t;\n\tfor (int axis = 0; axis < 3; axis++) {\n\t\tif (axis == hit_axis) continue;\n\t\tif (hit[axis] < aabb_min[axis] || hit[axis] > aabb_max[axis]) {\n\t\t\treturn INF;\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat ray_invaabb_intersect(in vec3 pos, in vec3 dir, in vec3 aabb_min, in vec3 aabb_max, out vec3 normal)\n{\n\tfloat t = 0.0;\n\tfor (int axis = 0; axis < 3; axis++) {\n\t\tfloat d = dir[axis];\n\t\tfloat p = pos[axis];\n\t\tfloat mn = aabb_min[axis];\n\t\tfloat mx = aabb_max[axis];\n\t\tfloat nt = 0.0;\n\t\tif (d >= 0.0 && p < mx) {\n\t\t\tfloat nt = (mx-p)/d;\n\t\t\tif (axis == 0 || nt < t) {\n\t\t\t\tt = nt;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = -1.0;\n\t\t\t}\n\t\t} else if (d < 0.0 && p > mn) {\n\t\t\tfloat nt = (mn-p)/d;\n\t\t\tif (axis == 0 || nt < t) {\n\t\t\t\tt = nt;\n\t\t\t\tnormal = vec3(0.0);\n\t\t\t\tnormal[axis] = 1.0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat ray_scene_intersect(in vec3 pos, in vec3 dir, out vec3 normal, out bool hit_source)\n{\n\tfloat tt = INF;\n\n\t// source\n\tvec3 n0;\n\tfloat t0 = ray_aabb_intersect(pos, dir, vec3(-0.2, -ROOM_SIZE/3.0, -0.2), vec3(0.2, ROOM_SIZE/3.0, 0.2), n0);\n\tif (t0 < tt) {\n\t\ttt = t0;\n\t\tnormal = n0;\n\t\thit_source = true;\n\t}\n\n\t// occluder\n\tvec3 n1;\n\tfloat t1 = ray_aabb_intersect(pos, dir, vec3(-0.5, -ROOM_SIZE/2.0, -0.5), vec3(0.5, ROOM_SIZE/2.0, -0.4), n1);\n\tif (t1 < tt) {\n\t\ttt = t1;\n\t\tnormal = n1;\n\t\thit_source = false;\n\t}\n\n\tif (tt < INF) return tt;\n\n\t// room\n\thit_source = false;\n\treturn ray_invaabb_intersect(pos, dir, vec3(-ROOM_SIZE, -ROOM_SIZE, -ROOM_SIZE), vec3(ROOM_SIZE, ROOM_SIZE, ROOM_SIZE + ROOM_EXTEND), normal);\n}\n\nvec3 hemisphere_cosine_random()\n{\n\t/* see http://people.cs.kuleuven.be/~philip.dutre/GI/TotalCompendium.pdf (19a + 35) */\n\tfloat r1 = rand();\n\tfloat r2 = rand();\n\tfloat r = sqrt(r1);\n\tfloat phi = 6.2830 * r2;\n\n\treturn vec3(\n\t\tr * cos(phi),\n\t\tr * sin(phi),\n\t\tsqrt(1.0 - r*r));\n}\n\nvec3 diffuse_bdrf(vec3 normal)\n{\n\tvec3 d = hemisphere_cosine_random();\n\tvec3 bz = normal;\n\tvec3 bx = abs(bz.x) < 0.5 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 by = cross(bz, bx);\n\tbx = cross(bz, by);\n\treturn bx*d.x + by*d.y + bz*d.z;\n}\n\nfloat path_trace(in vec3 pos, in vec3 dir, out int n_bounces)\n{\n\tfloat dist = 0.0;\n\tfor (int i = 0; i < MAX_BOUNCES; i++) {\n\t\tvec3 normal;\n\t\tbool hit_source;\n\t\tfloat t = ray_scene_intersect(pos, dir, normal, hit_source);\n\t\tvec3 hit = pos + dir*t;\n\t\tdist += length(hit - pos);\n\t\tif (hit_source) {\n\t\t\tn_bounces = i;\n\t\t\treturn dist;\n\t\t} else {\n\t\t\tpos = hit;\n\t\t\tdir = diffuse_bdrf(normal);\n\t\t}\n\t}\n\treturn -1.0;\n}\n\n        \nmat4 get_observer_tx(float time)\n{\n\tfloat l = 1.9;\n\tfloat px = sin(time) * l;\n\tfloat pz = cos(time) * l;\n\n\tvec3 p = -vec3(px, 0, pz);\n\n\tvec3 r = vec3(0.1, 1.0, 0.0);\n\tvec3 w = normalize(p);\n\tvec3 u = normalize(cross(w, r));\n\tvec3 v = normalize(cross(u, w));\n\n\treturn mat4(\n\t\tvec4(u, 0.0),\n\t\tvec4(v, 0.0),\n\t\tvec4(w, 0.0),\n\t\tvec4(p, 1.0));\n}\n\n\nfloat source(float time, float cut)\n{\n    float mt = fract(time);\n    const float pi2 = 6.2831;\n    float signal = sin(mt*pi2*(880.0-mt*440.0)) * (1.0/exp(2.0*mt));\n    return signal * pow(0.6,cut);\n}\n\n\nvec2 mainSound( in int samp,float time)\n{\n    seed = time*0.01;\n\n    mat4 tx = get_observer_tx(time);\n    vec3 pos = vec3(-tx[3]);\n    vec3 ear = tx[2].xyz;\n\n    float left = 0.0;\n    float right = 0.0;\n    float sgn = 1.0;\n    for (int i = 0; i < N_SAMPLES; i++) {\n        sgn *= -1.0;\n        {\n            vec3 dir = diffuse_bdrf(ear);\n            int n_bounces;\n        \tfloat dist = path_trace(pos, dir, n_bounces);\n        \tif (dist > 0.0) {\n                left += source(time - dist / SPEED_OF_SOUND, float(n_bounces))*sgn;\n        \t}\n        }\n        {\n            vec3 dir = diffuse_bdrf(-ear);\n            int n_bounces;\n        \tfloat dist = path_trace(pos, dir, n_bounces);\n        \tif (dist > 0.0) {\n                right += source(time - dist / SPEED_OF_SOUND, float(n_bounces))*sgn;\n        \t}\n        }\n    }\n    return vec2(left, right);\n}","name":"Sound","description":"","type":"sound"}]}