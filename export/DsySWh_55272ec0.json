{"ver":"0.1","info":{"id":"DsySWh","date":"1681495761","viewed":119,"name":"x Gimme","username":"EDragon","description":"more shaders lesgooo","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["colorful","recreation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define s smoothstep\n#define pi 3.1415\n#define res iResolution.xy\n#define t iTime\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n\nvec3 tc = vec3(0.345, 0.294, 0.373);\nvec3 bc = vec3(0.447, 0.302, 0.424);\n\n\nfloat s2(float uv, float a){\n    return s(-a, -a+0.005, -uv);\n}\n\n\nvec2 rotate(vec2 v, vec2 o, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * (v-o) + o;\n}\n// shamelessly yoinked from https://shadertoy.com/view/MlsfRj\n\nvec2 TransformPlane(vec2 uv, vec2 center, float XRot, float YRot) {\n    // First Rotate around Y axis\n    vec2 RayDirection =  vec2(uv.x, 0.0);\n    vec2 A1 = vec2(0.0, -1.0);\n    vec2 B1 = RayDirection - A1;\n    vec2 C1 = rotate(vec2(-1.0, 0.0), vec2(center.x, 0.0), YRot);\n    vec2 D1 = rotate(vec2( 1.0, 0.0), vec2(center.x, 0.0), YRot) - C1;\n    // calculate intersection point\n    float u = ( (C1.y + 1.0) * D1.x - C1.x * D1.y ) / (D1.x*B1.y-D1.y*B1.x);\n    // position on the plane:\n    float sx = u * B1.x;\n \tfloat sy = u * uv.y;\n    // Now Rotate around X axis\n    RayDirection = vec2(sy, .0);\n    vec2 B2 = RayDirection - A1;\n    vec2 C2 = rotate(vec2(-1.0, 0.00), vec2(center.y, 0.0), XRot);\n    vec2 D2 = rotate(vec2( 1.0, 0.0), vec2(center.y, 0.0), XRot) - C2;\n    // calculate intersection point\n    float v = ( (C2.y + 1.0) * D2.x - C2.x * D2.y ) / (D2.x*B2.y-D2.y*B2.x);\n    // final position on the plane:\n    return vec2(v * sx, v * B2.x );\n    \n}\n\n//uv, pos, arms size, size, bloom size, rotation\nfloat x(vec2 uv, vec2 p, vec2 sz, float si, float bl, float bs, float r){\n    uv -= p; uv /= si; uv *= rot(pi*r);\n    vec2 uv2 = uv;\n    uv.x *= si+sz.y; uv.y /= sz.y;\n    uv *= rot(pi*0.25);\n    uv2.x /= sz.x; uv2.y *= si+sz.x; uv2 *= rot(-pi*0.25);\n    \n    return min((0.0+bs)/(\n    (1.0+bs)-s(0.1+bl, 0.1, abs(uv.x))*s(0.1+bl, 0.1, abs(uv.y)) \n    )+(0.0+bs)/(\n    (1.0+bs)-s(0.1+bl, 0.1, abs(uv2.x))*s(0.1+bl, 0.1, abs(uv2.y)) \n    ),1.0);\n}\n\nfloat box(vec2 uv, float si, float r){\n    uv *= rot(pi*r);\n    float b = 0.05/((1.0-s(si+0.02, si, abs(uv.x))*s(si+0.02, si, abs(uv.y))))\n    ;\n    \n    return min(s(.0, 0.5, b), 1.0);\n}\nfloat box2(vec2 uv, float si, float r){\n    uv *= rot(pi*r);\n    float b = 0.05/((s(si+0.02, si, abs(uv.x))*s(si+0.02, si, abs(uv.y))))\n    ;\n    \n    return min(s(0.0, 0.5, b), 1.0);\n}\nfloat boxs(vec2 uv, float si, float r){\n    uv *= rot(pi*r);\n    float b = s2(abs(uv.x), si)*s2(abs(uv.y), si);\n    \n    return b;\n}\n\nfloat circ(vec2 uv, vec2 p, float si){\n    uv -= p; uv /= si;\n    return s(0.1, 0.09, length(uv))*s(0.07, 0.08, length(uv))+s(0.06, 0.05, length(uv));\n}\n\nfloat rand(float f){\n    return fract(sin(f*5321.53126)*351.3637);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xo = (fragCoord-0.5*res)/res.xy;\n    vec2 uv = (fragCoord-0.5*res)/res.y;\n    vec2 uv3 = uv;\n    vec2 uv4 = uv;\n    uv = TransformPlane(uv, vec2(0.0, 0.0), -pi*0.05, 0.0);\n    vec2 uv2 = uv;\n\n\n\n    vec3 col = vec3(0.0);\n    float overlay = s(1.0, 0.2, length(xo));\n    \n    float st;\n    \n    float st1 = mod(t, 2.);\n    \n    float br = outCubic(0.0, 1.0, 0.25, st1);\n\n    br += outCubic(1.0, 1.0, 0.25, st1);\n    \n    \n    float st2 = mod(t, 2.0);\n    float st3 = mod(t, 3.0);\n    float bp1 = inOutExpo(0.0125, 3.0, 1.0, st3);\n    float bp2 = inOutExpo(0.0, 3.0, 1.0, st3);\n    float bb1 = inOutExpo(0.03, 2.0, 1.0, st2);\n    float bb2 = inOutExpo(0.0, 2.0, 1.0, st2);\n    \n    \n    \n    float cro = s(0.6, 0.595, length(uv3))*s(0.59, 0.595, length(uv3));\n\n    float bo = clamp(box(uv3, 0.400, br)*\n               box2(uv3, 0.38, br), 0.0, 1.0);\n               \n               \n    bo = s(0.0, 1.0, bo);\n    \n    for (float i=1.0; i < 20.0; i++){\n        st += clamp(x(uv,\n        vec2((rand(i*5.2)-0.5)*2.0, (rand(i*3.9)-0.5)+sin(2.0*t+i)*0.01), \n        vec2(1.25+sin(2.0*t+sin(i*234.12574))*0.25, \n        2.0+cos(2.0*t+sin(i*234.12574))*0.25), \n        0.15+sin(i)*0.075, \n        0.75, \n        0.001, \n        0.0), 0.0, 1.0-(bo));\n        st = min(st, 1.0);\n    }\n    \n    \n    float po11 = outExpo(0.5, 1.0, 0.2, st3);\n    float po12 = outCubic(0.5, 1.0, 0.2, st3);\n    float poof1 = flip(linear(1.0+0.5, 0.01, 1.0, st3));\n    \n    \n    \n    float st4 = mod(t, 4.0);\n    float po21 = outExpo(0.75, 1.0, 0.25, st4);\n    float po22 = outCubic(0.75, 1.0, 0.25, st4);\n    float po31 = outExpo(0.75, 1.0, 0.15, st4);\n    float po32 = outCubic(0.75, 1.0, 0.15, st4);\n    float poof2 = flip(linear(0.7+0.75, 0.0001, 1.0, st4));\n    float poof13 = linear(0.625+1.5, 0.0001, 10.0, st2);\n    \n    \n    \n    uv4.y *= 0.5;\n    \n    vec3 dip;\n    \n    dip.x += outExpo(1.5, 0.75, 0.075+0.05, st2);\n    dip.y += outCubic(1.5, 0.75, 0.075*2.+0.025, st2);\n    dip.z -= inOutCubic(0.0, 2.0, 0.015, st2);\n    dip.z += outExpo(1.5, 1.0, 0.015, st2);\n\n\n    \n    float di = box(uv4, 0.075+dip.z, 0.25);\n    uv4 += poof13;\n    di += box(uv4, 0.05+dip.x, 0.25)*box2(uv4, dip.y, 0.25);\n    di = min(di, 1.0);\n\n    float pop1 = s(0.0, 1.0,\n          clamp(box(uv-vec2(-0.5, 0.45), po11, 0.0)*\n               box2(uv-vec2(-0.5, 0.45), po12, 0.0)\n               , 0.0, 1.0-(cro+st+bo)))*poof1;\n               \n    float pop21 = s(0.0, 1.0,\n          clamp(box(uv-vec2(0.6, 0.0), po21, 0.0)*\n               box2(uv-vec2(0.6, 0.0), po22, 0.0)\n               , 0.0, 1.0-(cro+st+bo)))*poof2;\n    float pop22 = s(0.0, 1.0,\n          clamp(box(uv-vec2(0.6, 0.0), po31, 0.0)*\n               box2(uv-vec2(0.6, 0.0), po32, 0.0)\n               , 0.0, 1.0-(cro+st+bo)))*poof2;\n               \n    float st5 = mod(t, 3.35);\n    float po41 = outExpo(0.25, 1.0, 0.25+0.2, st5);\n    float po42 = outQuart(0.25, 1.0, 0.25+0.175, st5);\n    float poof3 = flip(outBounce(1.0, 0.3, 1.0, st5));\n               \n    float pop3 = s(0.0, 1.0,\n          clamp(box(uv-vec2(-0.65, -0.4), po41, 0.0)*\n               box2(uv-vec2(-0.65, -0.4), po42, 0.0)\n               , 0.0, 1.0-(cro+st+bo)))*poof3;\n               \n    float st6 = mod(t, 3.66);\n    float po51 = outExpo(1.75, 1.0, 0.25+0.2, st6);\n    float po52 = outQuart(1.75, 1.0, 0.25+0.175, st6);\n    float poof4 = flip(outBounce(1.0+1.5, 0.3, 1.0, st6));\n               \n    float pop4 = s(0.0, 1.0,\n          clamp(box(uv-vec2(0.65, 0.65), po51, 0.0)*\n               box2(uv-vec2(0.65, 0.65), po52, 0.0)\n               , 0.0, 1.0-(cro+st+bo)))*poof4;\n               \n               \n    //\n    float bl2 = bo+st+cro+pop1+pop21+pop22+pop3+pop4+di;\n    \n    float bi1 = max(clamp(box(uv, 0.50, 0.25+bp1)*\n               box2(uv, 0.48, 0.25+bp2), 0.0, 1.0-(bl2)), 0.0);\n    float bi2 = clamp(box(uv, 0.70, 0.25+bb1)-\n               box(uv, 0.68, 0.25+bb2), 0.0, 1.0-(bl2+bi1));\n    \n    st = min(st, 1.0);\n    \n    uv2.y += -cos(uv2.x)*0.2+0.2;\n    \n    //\n    float bl1 = st+bo+bi1+bi2+cro+pop1+pop21+pop22+pop3+pop4+di;\n    float bot = clamp(s2(uv2.y, 0.0), 0.0, 1.0-(bl1));\n    float top = clamp(s2(-uv2.y, 0.0), 0.0, 1.0-(bl1));\n    \n    \n    col += min(bot*bc*s(2.0, 0.0, length(uv))*bc*2.5, 1.0);\n    col += min(top*tc*s(1.5, 0.0, length(uv))*tc*2.5, 1.0);\n    col += st;\n    col += bo*vec3(1.0, 1.0, 0.6);\n    col += bi1*vec3(1.0, 0.5, 1.0);\n    col += bi2*vec3(0.7, 1.0, 1.0);\n    col += cro;\n    col += pop1*vec3(1.0, 1.0, 0.6);\n    col += pop21*vec3(1.0, 1.0, 0.6);\n    col += pop22*vec3(1.0, 1.0, 0.6);\n    col += pop3*vec3(1.0, 0.5, 1.0);\n    col += pop4*vec3(1.0, 0.5, 1.0);\n    col += di*vec3(0.7, 1.0, 1.0);\n\n\n\n    \n    col *= overlay;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shoutout to easings.net\n\n#define pi 3.1415\n#define tr start,dur,x\n#define par float start, float dur, float p, float x\n// writing start,dur,x everywhere gets annoying\n#define xs (x-start)\n// same thing with par, just to make things less clutered\n\n\n// reminder for whenever you touch eases here ever again\n// 1 - stop being dumb\n// 2 - no the ease function does not have to do anything with the timing\n// 3 - when you add x please PLEASE add it as (x - start) (it's \"xs\" now)\n// 4 - stop being a silly little bean\n\nfloat c(float x){\n    return max(0.0, min(1.0, (x - 0.0) / (1.0 - 0.0)));\n}\n\nfloat o(float x){\n    return clamp(x, -1.0, 0.0);\n}\n\nfloat o2(float x){\n    return clamp(x, 1.0, 0.0);\n}\n\nfloat ease(float easing, float start, float dur, float x){\n    start += 1.0;\n    if (x >= start - 1.0 && x <= start){\n        return easing;\n    }else return o(xs) + 1.0;\n}\n\nfloat ease2(float easing, float start, float dur, float x){\n    start += 1.0;\n    if (x >= start - 1.0 && x <= start){\n        return easing;\n    }else return o2(xs);\n}\n\nfloat linear(par){\n    start /= dur; x /= dur;\n    return p*ease(xs,tr);\n}\n\nfloat inSine(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - cos((xs * pi) / 2.0),tr);\n}\n\nfloat outSine(par){\n    start /= dur; x /= dur;\n    return p*ease(sin((xs * pi) / 2.0),tr);\n}\n\n// I am pretty sure doing inEase + outEase would give the same result\n// but whatev, I've already wrote everything out\n\nfloat inOutSine(par){\n    start /= dur; x /= dur;\n    return p*ease(-(cos(pi * xs) - 1.0) / 2.0, tr);\n}\n\nfloat outInSine(par){\n    start /= dur; x /= dur;\n    return p*outSine(start, 0.5, 0.5, x) + p*inSine(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 2.0),tr);\n}\n\nfloat outQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 2.0),tr);\n}\n\nfloat inOutQuad(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5 \n    ? p*ease(2.0 * (xs * xs),tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 2.0) / 2.0,tr);\n}\n\nfloat outInQuad(par){\n    start /= dur; x /= dur;\n    return p*outQuad(start, 0.5, 0.5, x) + p*inQuad(start + 0.5, 0.5, 0.5, x);\n}\n\n\nfloat inCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 3.0),tr);\n}\n\nfloat outCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow( 1.0 - xs, 3.0),tr);\n}\n\nfloat inOutCubic(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease(4.0 * xs * xs * xs, tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 3.0) / 2.0, tr);\n}\n\nfloat outInCubic(par){\n    start /= dur; x /= dur;\n    return p*outCubic(start, 0.5, 0.5, x) + p*inCubic(start+0.5, 0.5, 0.5, x);\n}\n\nfloat inQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 4.0),tr);\n}\n\nfloat outQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 4.0), tr);\n}\n\nfloat inOutQuart(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5 \n    ? p*ease(8.0 * pow(xs, 4.0), tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 4.0) / 2.0, tr);\n}\n\nfloat outInQuart(par){\n    start /= dur; x /= dur;\n    return p*outQuart(start, 0.5, 0.5, x) + p*inQuart(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(xs, 5.0),tr);\n}\n\nfloat outQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(1.0 - xs, 5.0), tr);\n}\n\nfloat inOutQuint(par){\n    start /= dur; x /= dur;\n    return xs < 0.5 \n    ? p*ease(16.0 * pow(xs, 5.0), tr)\n    : p*ease(1.0 - pow(-2.0 * xs + 2.0, 5.0) / 2.0, tr);\n}\n\nfloat outInQuint(par){\n    start /= dur; x /= dur;\n    return p*outQuint(start, 0.5, 0.5, x) + p*inQuint(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(2.0, 10.0 * xs - 10.0),tr);\n}\n\nfloat outExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(1.0 - pow(2.0, -10.0 * xs), tr);\n}\n\nfloat inOutExpo(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease(pow(2.0, 20.0 * xs - 10.0) / 2.0, tr)\n    : p*ease((2.0 - pow(2.0, -20.0 * xs + 10.0)) / 2.0, tr);\n}\n\nfloat outInExpo(par){\n    start /= dur; x /= dur;\n    return p*outExpo(start, 0.5, 0.5, x) + p*inExpo(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(1.0 - sqrt(1.0 - pow(xs, 2.0))), tr);\n}\n\nfloat outCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(sqrt(1.0 - pow(xs - 1.0, 2.0))), tr);\n}\n\nfloat inOutCirc(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.0) < 1.5\n    ? p*ease((1.0 - sqrt(1.0 - pow(2.0 * xs * 2.0, 1.0))) / 2.0, tr)\n    : p*ease((sqrt(1.0 - pow(-2.0 * xs * 2.0 + 2.0, 2.0)) + 1.0) / 2.0, tr);\n}\n\nfloat outInCirc(par){\n    start /= dur; x /= dur;\n    return p*outCirc(start, 0.5, 0.5, x) + p*inCirc(start + 0.5, 0.5, 0.5, x);\n}\n\nfloat inBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < 0.0) c1 = 1.70158;\n    float c3 = c1 + 1.0;\n    \n    return p*ease(c3 * pow(xs, 3.0) - c1 * pow(xs, 2.0), tr);\n}\n\nfloat outBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < .0) c1 = 1.70158;\n    float c2 = c1 + 1.;\n    \n    return p*ease(1. + c2 * pow(xs - 1., 3.) + c1 * pow(xs - 1.0, 2.0), tr);\n}\n\nfloat inOutBack(par){\n    start /= dur; x /= dur;\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n    \n    return x - (start - 1.0) < 1.5\n    ? p*ease((pow(2.0 * xs, 2.0) * ((c2 + 1.0) * 2.0 * xs - c2)) / 2.0, tr)\n    : p*ease((pow(2.0 * xs - 2.0, 2.0) * ((c2 + 1.0) * (xs * 2.0 - 2.0) + c2) + 2.0) / 2., tr);\n}\n\nfloat outInBack(par, float c1){\n    start /= dur; x /= dur;\n    return p*outBack(start, 0.5, 0.5, x, c1) + p*inBack(start + 0.5, 0.5, 0.5, x, c1);\n}\n\nfloat inElastic(par){\n    start /= dur; x /= dur;\n    float c = (2.0 * pi) / 3.0;\n    \n    return p*ease(-pow(2.0, 10.0 * xs - 10.0) * sin((xs * 10.0 - 10.75) * c), tr);\n}\n\nfloat outElastic(par){\n    start /= dur; x /= dur;\n    float c = (2.0 * pi) / 3.0;\n    \n    return p*ease(pow(2.0, -10.0 * xs) * sin((xs * 10.0 - 0.75) * c) + 1.0, tr);\n}\n\nfloat inOutElastic(par){\n    start /= dur; x /= dur;\n    float c = (2. * pi) / 4.5;\n    \n    return xs < 0.5\n      ? p*ease(-(pow(2.0, 20.0 * xs - 10.0) * sin((20.0 * xs - 11.125) * c)) / 2.0, tr)\n      : p*ease((pow(2.0, -20.0 * xs + 10.0) * sin((20.0 * xs - 11.125) * c)) / 2.0 + 1.0, tr);\n}\n\nfloat outInElastic(par){\n    start /= dur; x /= dur;\n    return p*outElastic(start, 0.5, 0.5, x) + p*inElastic(start + 0.5, 0.5, 0.5, x);\n}\n\n// I can't figure this out,,,\n// (^lie^) I FIGURE TI OUTBJkfnlajskbf\nfloat outBounce(par){\n    start /= dur; x /= dur;\n    float n = 7.5625;\n    float d = 2.75;\n    \n\tif (xs < 1.0 / d){\n\t\treturn p*ease(n * xs * xs, tr);\n\t}else if (xs < 2.0 / d){\n\t\tx = x - 1.5 / d;\n\t\treturn p*(n * xs * xs + 0.75);\n\t}else if (xs < 2.5 / d){\n\t\tx = x - 2.25 / d;\n\t\treturn p*(n * xs * xs + 0.9375);\n\t}else{\n\t\tx = x - 2.625 / d;\n\t\treturn p*min(n * xs * xs + 0.984375, 1.);\n\t}\n}\n\nfloat inBounce(par){\n    return p*(1.0-outBounce(start, 1.0, 1.0, 1.0-xs));\n}\n\nfloat inOutBounce(par){\n    start /= dur; x /= dur;\n    return xs < 0.5\n    ? p*(1.0 - outBounce(start, 1.0, 1.0, (1.0+start) - 2.0 * xs)) / 2.0\n    : p*(1.0 + outBounce(start, 1.0, 1.0, 2.0 * xs - (1.0-start))) / 2.0;\n}\n\n\n// mirin eases\n\nfloat bounce(par){\n    start /= dur; x /= dur;\n    return p*ease2(4.0 * xs * (1.0 - xs), tr);\n}\n\nfloat tri(par){\n    start /= dur; x /= dur;\n    return p*ease2(1.0 - abs(2.0 * xs - 1.0), tr);\n}\n\nfloat bell(par){\n    start /= dur; x /= dur;\n    return p*inOutQuint(start, 1.0, 1.0, tri(start, 1.0, 1.0, x)+start);\n}\n\nfloat pop(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * (1.0 - xs) * (1.0 - xs) * sqrt(xs), tr);\n}\n\nfloat tap(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * xs * xs * sqrt(1.0 - xs), tr);\n}\n\nfloat pulse(par){\n    start /= dur; x /= dur;\n    return p*tap(start, 0.5, 0.5, x)-pop(start+0.5, 0.5, 0.5, x);\n}\n\nfloat spike(par){\n    start /= dur; x /= dur;\n    return p*ease2(exp(-10.0 * abs(2.0 * xs - 1.0)), tr);\n}\n\nfloat invert(par){\n    start /= dur; x /= dur;\n    return p*ease2(xs * xs * (1.0 - xs) * (1.0 - xs) / (0.5 - xs), tr);\n}\n\nfloat flip(float ease){\n    return 1.0-ease;\n}\n","name":"Common","description":"","type":"common"}]}