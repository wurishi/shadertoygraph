{"ver":"0.1","info":{"id":"fsXSzj","date":"1618892188","viewed":96,"name":"Distance Field Soft Shadows 2","username":"ZJUMSJ","description":"distance field soft shadow","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shengjie MA\n// 2021-04-20\n// 21821065@zju.edu.cn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// reference\n// https://www.shadertoy.com/view/sdlXR7\n// https://www.shadertoy.com/view/XlBSRz\n// https://www.bilibili.com/video/BV1YK4y1T7yY?p=5\n\n#define VERY_FAR 100000.f\n#define EPS 1e-3f\n#define MAX_MARCHING_STEPS 128\n#define MAX_RANGE 1000.f\n\n//#define DEBUG\n\n// light define\nvec3 ambient_color = vec3(0.0002f);\nvec3 specular_color = vec3(0.0003f);\nvec4 light_pos = vec4(0.f,17.f,0.f,1.f);\nvec3 light_color = vec3(0.9f,1.f,0.8f) * 350.f;\n\n\n// geometry define\nfloat plane_pos0 = 0.f; vec4 plane_range0 = vec4(-30.f,30.f,-30.f,20.f);\n\nvec4 sphere_pos1 = vec4(10.f,4.f,-10.f,4.f);\n\nmat4 box_trans2 = \\\nmat4(0.707f,0.f,0.707f,0.f,\n0.f,1.f,0.f,0.f,\n0.707f,0.f,-0.707f,0.f,\n7.f,-5.f,4.f,1.f);\nvec3 box_scale2 = vec3(2.f,5.f,2.f);\n\nmat4 box_trans3 = \\\nmat4(0.5f,0.f,0.8660254f,0.f,\n0.f,1.f,0.f,0.f,\n-0.8660254f,0.f,0.5f,0.f,\n-1.f,-1.f,-7.f,1.f);\nvec3 box_scale3 = vec3(5.f,1.f,5.f);\n\nvec4 sphere_pos4 = vec4(6.f,4.f,4.f,2.f);\n\n\nfloat sceneSDF(vec3 pos);\n\n\n////////////////////////\n// tool\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// hash by Hugo Elias\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvoid swap(inout float a,inout float b){\n\tfloat c = a;\n\ta = b;\n\tb = c;\t\n}\n\nvoid swap(inout int a,inout int b){\n\tint c = a;\n\ta = b;\n\tb = c;\t\n}\n\n///////////////////\n// SDF\n\nfloat SDFUnion(float a,float b){\n\treturn min(a,b);\n}\n\nfloat Sphere_SDF(vec4 sphere, vec3 pos){\n\treturn abs(length(sphere.xyz - pos) - sphere.w);\t\n}\n\nfloat Box_SDF(mat4 world_to_box,vec3 box_scale,vec3 pos){\n\tvec3 pos_ = (world_to_box * vec4(pos,1.f)).xyz;\n\tfloat x_dist = 0.f;\n    float y_dist = 0.f;\n    float z_dist = 0.f;\n    if(pos_.x < -box_scale.x)\n       x_dist = -box_scale.x - pos_.x;\n    else if (pos_.x > box_scale.x)\n       x_dist = pos_.x - box_scale.x;\n    \n    if(pos_.y < -box_scale.y)\n       y_dist = -box_scale.y - pos_.y;\n    else if (pos_.y > box_scale.y)\n       y_dist = pos_.y - box_scale.y;\n       \n    if(pos_.z < -box_scale.z)\n       z_dist = -box_scale.z - pos_.z;\n    else if (pos_.z > box_scale.z)\n       z_dist = pos_.z - box_scale.z;\n    return sqrt(x_dist * x_dist + y_dist * y_dist + z_dist * z_dist);\n}\n\nfloat YQuad_SDF(float v, vec4 range, vec3 pos){\n\t\n\tfloat y_dist = abs(pos.y - v);\n\tfloat x_dist = 0.f;\n\tif (pos.x < range.x)\n\t\tx_dist = range.x - pos.x;\n\telse if (pos.x > range.y)\n\t\tx_dist = pos.x - range.y;\n\tfloat z_dist = 0.f;\n\tif (pos.z < range.z)\n\t\tz_dist = range.z - pos.z;\n\telse if (pos.z > range.w)\n\t\tz_dist = pos.z - range.w;\n\treturn sqrt(x_dist * x_dist + y_dist * y_dist + z_dist * z_dist);\n}\n\n//////////////////\n// geometry\n\nvoid IntersectSphere(int idx,vec4 sphere,\n\tvec3 O,vec3 D,\n\tinout float t,inout vec3 normal,inout int out_idx\n){\n\tvec3 b = O - sphere.xyz;\n\tfloat ia = dot(D,D);\n\tfloat ib = dot(b,D);\n\tfloat ic = dot(b,b)-sphere.w * sphere.w;\n\tfloat root_delta = ib * ib - ia * ic;\n\tfloat root;\n\tif(root_delta >= 0.f){\n\t\troot_delta = sqrt(root_delta);\n\t\troot = (-ib - root_delta)/ia;\n\t\tif(root < 0.f){\n\t\t   root = (-ib + root_delta)/ia;\t\n\t\t}\n        if(root > 0.f && root < t){\n           t = root;\n\t\t   normal = normalize(b + t * D);\n\t\t   out_idx = idx;\n\t\t}\n\t}\n\t\n}\n\nvoid IntersectBox(int idx,mat4 world_to_box,vec3 box_scale,\n\tvec3 O,vec3 D,\n\tinout float t,inout vec3 normal,inout int out_idx\n){\n\tvec3 O_ = (world_to_box * vec4(O,1.f)).xyz;\n\tvec3 D_ = world_to_box[0].xyz * D.x + world_to_box[1].xyz * D.y + world_to_box[2].xyz * D.z;\n\t\n\tvec3 tmin = (-box_scale - O_)/D_;\n\tvec3 tmax = (box_scale - O_)/D_;\n\tvec3 normal_ = vec3(0.f);\n\t\n\tivec3 itmin = ivec3(0,2,4);//-\n\tivec3 itmax = ivec3(1,3,5);//+\n\t\n\tif(tmin.x > tmax.x){\n\t\tswap(tmin.x,tmax.x); swap(itmin.x,itmax.x);\n\t}\n\tif(tmin.y > tmax.y){\n\t\tswap(tmin.y,tmax.y); swap(itmin.y,itmax.y);\n\t}\n\tif(tmin.z > tmax.z){\n\t\tswap(tmin.z,tmax.z); swap(itmin.z,itmax.z);\n\t}\n\t\n\tfloat t_in = tmin.x; int it_in = itmin.x;\n\tif( tmin.y > t_in ){\n\t\tt_in = tmin.y; it_in = itmin.y;\n\t}\n\tif( tmin.z > t_in ){\n\t\tt_in = tmin.z; it_in = itmin.z;\n\t}\n\tfloat t_out = tmax.x; int it_out = itmax.x;\n\tif( tmax.y < t_out){\n\t\tt_out = tmax.y; it_out = itmax.y;\n\t}\n\tif( tmax.z < t_out){\n\t\tt_out = tmax.z; it_out = itmax.z;\n\t}\n\t\n\tfloat t_ = 0.f; int it_;\n\tif(t_in < t_out ){ \n\t\tif(t_in > 0.f){\n\t\t\tt_ = t_in; it_ = it_in; \n\t\t}\n\t\telse if(t_out > 0.f){\n\t\t\tt_ = t_out; it_ = it_out;\n\t\t} \n\t\tif(t_ > 0.f && t_ < t){\n\t\t\tt = t_;\n\t\t\tout_idx = idx;\n\t\t\tif(it_ < 2){\n\t\t\t\tnormal_.x = it_ == 0 ? -1.f : +1.f; \n\t\t\t}else if (it_ < 4){\n\t\t\t\tnormal_.y = it_ == 2 ? -1.f : +1.f;\n\t\t\t}else{\n\t\t\t\tnormal_.z = it_ == 4 ? -1.f : +1.f;\n\t\t\t}\n\t\t\tnormal.x = dot(normal_,world_to_box[0].xyz);\n\t\t\tnormal.y = dot(normal_,world_to_box[1].xyz);\n\t\t\tnormal.z = dot(normal_,world_to_box[2].xyz);\n\t\t}\n\t}\t\n} \n\n// range: x_start,x_end,y_start,y_end\nvoid IntersectYQuad(int idx,float v, vec4 range,\n\tvec3 O,vec3 D,\n\tinout float t,inout vec3 normal,inout int out_idx\n){\n\tfloat t_ = (v - O.y)/D.y ;\n\tvec3 insert = O + D * t_;\n\tif(t_ > 0.f && t_ < t &&\n\t\tinsert.x >= range.x && insert.x < range.y && \n\t\tinsert.z >= range.z && insert.z < range.w\n\t){\n\t\tt = t_;\n\t\tout_idx = idx;\n\t\tnormal = vec3(0.f,1.f,0.f);\n        if(O.y < v)\n          normal.y = -normal.y;\n\t}\n}\n\n\nfloat debugFunc(vec3 insert,vec3 normal){\n\n    vec3 start_point = insert + normal * EPS ;\n\tfloat t = 0.f;\n    float step = sceneSDF(start_point);\n    float mindist = step;\n    vec3 p;\n    for(int i = 0;i<MAX_MARCHING_STEPS;i++){\n        t = t + step;\n        if(t>MAX_RANGE)\n            break;\n        p = start_point + normal * t;\n        step = sceneSDF(p);\n        if(step < mindist)\n            mindist = step;\n        if(mindist < EPS)\n            return 0.0;        \n    }\n    return mindist;\n}\n\nfloat softShadow(vec3 insert,vec3 normal){\n\t\n\tvec3 start_point = insert + normal * EPS;\n\tfloat t = 0.f;\n\tvec3 light_dir = normalize(light_pos.xyz - start_point);\n\tfloat offset = sceneSDF(start_point);\n\tfloat step = offset;\n\tvec3 p;\n\tfloat visibility = 1.f;\n\tfloat hardness = 5.f;\n\t\n\tfor(int i = 0;i<MAX_MARCHING_STEPS;i++){\n\t\tt = t + step * (0.7 + 0.3 * frand());\n\t\tif(t > MAX_RANGE)\n\t\t\tbreak;\n\t\tp = start_point + light_dir * t;\n\t\tstep = sceneSDF(p);\n\t\tfloat v_ = hardness * step / (t + hardness * offset);\n\t\t//float v_ = max(step - offset,0.f) * hardness / t;\n\t\tif( v_ < visibility)\n\t\t\tvisibility = v_;\n        if( visibility < EPS)\n            return 0.0;\n\t}\n\t\n\treturn visibility;\n\t//return 1.f;\n\t\n}\n\nvec3 shading(vec3 normal,vec3 insert, int idx){\n        \n    vec4 color[5];\n\tcolor[0] = vec4(0.5f,0.5f,0.5f,0.f);\n    color[1] = vec4(0.2f,0.5f,0.1f,15.f);\n    color[2] = vec4(0.8f,0.3f,0.1f,20.f);\n    color[3] = vec4(0.4f,0.5f,0.6f,40.f);\n    color[4] = vec4(0.3f,0.3f,0.3f,0.f);\n   \n    vec3 out_color = vec3(1.f,1.f,1.f);//shading light\n        \n       \n    if(idx >= 0){\n        // Blinn-Phong Shading\n        out_color = ambient_color * color[idx].xyz;\n        vec3 lightDir = light_pos.xyz - insert;\n        float light_att = length(lightDir);\n        lightDir = normalize(lightDir);\n\t\tlight_att = 1.f/(light_att * light_att);\n        //light_att = 1.f/light_att;\n\t\t\n        float diff = max(dot(lightDir,normal),0.f);\n        vec3 shadow_color = diff * color[idx].xyz;\n\t\tif( color[idx].w > 0.f){\n            vec3 H = lightDir + normal;\n\t\t    H = normalize(H);\n\t\t    shadow_color += pow(max(dot(H,normal),0.f),color[idx].w) * \\\n              (sqrt(color[idx].w) * specular_color);\n        }\n\t\tfloat shadow_k = softShadow(insert,normal);\n        //float shadow_k = 1.f;\n\t\tout_color += shadow_color * shadow_k * light_att ;\n\t\tout_color *= light_color;\n   }\n   return out_color;\n}\n\nfloat sceneSDF(vec3 pos){\n\t\n\tfloat sdf = VERY_FAR;\n\tsdf = SDFUnion(sdf,YQuad_SDF(plane_pos0,plane_range0,pos));\n\tsdf = SDFUnion(sdf,Sphere_SDF(sphere_pos1,pos));\n\tsdf = SDFUnion(sdf,Box_SDF(box_trans2,box_scale2,pos));\n    sdf = SDFUnion(sdf,Box_SDF(box_trans3,box_scale3,pos));\n    sdf = SDFUnion(sdf,Sphere_SDF(sphere_pos4,pos));\n\treturn sdf;\t\n\t\t\n}\n\nvec3 traceScene(vec3 rO,vec3 rD){\n\t\n    float dist = VERY_FAR;\n\tvec3 normal;\n\tint idx;\n    vec3 out_color = vec3(0.f,0.f,0.f);//BKG color\n\t\n    // draw light \n    IntersectSphere(-1,light_pos,rO,rD,dist,normal,idx);\n\tIntersectYQuad(0,plane_pos0,plane_range0,rO,rD,dist,normal,idx);\n    IntersectSphere(1,sphere_pos1,rO,rD,dist,normal,idx);\n    IntersectBox(2,box_trans2,box_scale2,rO,rD,dist,normal,idx);\n    IntersectBox(3,box_trans3,box_scale3,rO,rD,dist,normal,idx);\n\tIntersectSphere(4,sphere_pos4,rO,rD,dist,normal,idx);\n\t\t\n\tif(dist < VERY_FAR){\n\t\tvec3 insert = rO + rD * dist;\n        out_color = shading(normal,insert,idx);\n\t}\n\t\n\treturn out_color;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 uv = fragCoord.xy / iResolution.xy; //[0,1]\n    \n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // move light\n    const float kt = 3.f;\n    light_pos.xyz = light_pos.xyz + vec3(12.f,4.f,12.f) * \\\n        vec3(sin(iTime * kt / 2.71828),\n        sin(iTime * kt / 3.14159 + 0.2),\n        sin(iTime * kt - 0.7));\n    \n    // make camera\n    float hfactor = float(iResolution.y) / float(iResolution.x); // make it screen ratio independent\n\tvec2 uv2 = vec2(2.0, 2.0*hfactor) * fragCoord.xy / iResolution.xy - vec2(1.0, hfactor); //[-1,1][-r,r]\n\t\n\tvec3 camPos = vec3( 0.0, 18.0, 30.0);\n     if(iMouse.x+iMouse.y > 0.0) // to handle first loading and see somthing on screen\n        camPos -= vec3(0.05,0.12,0.0)*(vec3(iMouse.x, iMouse.y, 0.0)-vec3(iResolution.xy*0.5, 0.0));\n\tvec3 camX   = vec3( 1.0, 0.0, 0.0);\n\tvec3 camY   = vec3( 0.0, 0.8660254, -0.5);\n\tvec3 camZ   = vec3( 0.0, 0.5, 0.8660254);\n\t\n\tvec3 rO = camPos;\n\tvec3 rD = normalize(uv2.x*camX + uv2.y*camY - camZ);\n\t\t\n#ifdef DEBUG\n    float visibility = debugFunc(rO,rD);\n\tfragColor = vec4(visibility);\n#else\t\n\t\n\tvec3 color = traceScene(rO,rD);\n\t\n\tcolor.x = sqrt(color.x);// approximate gamma correction\n\tcolor.y = sqrt(color.y);\n\tcolor.z = sqrt(color.z);\n\t\n\tfragColor = vec4(color,1.f);\t\n#endif\n}","name":"Image","description":"","type":"image"}]}