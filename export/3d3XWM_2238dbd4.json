{"ver":"0.1","info":{"id":"3d3XWM","date":"1572125176","viewed":80,"name":"Helix (1)","username":"Synth4NTAGONIST","description":"An animated helix with blue and red spheres.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["helix3draymarchsdspheresdcapsule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (acos(-1.))\n\nstruct mapdata {\n    int id;\n    float dist;\n};\n\nstruct hitpoint {\n    bool hit;\n    mapdata data;\n\tvec3 pos;\n    vec3 normal;\n};\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nmapdata mapMin(mapdata d1, mapdata d2) {\n    mapdata result = d1;\n    if (d2.dist < d1.dist) {\n        result.id = d2.id;\n        result.dist = d2.dist;\n    }\n    return result;\n}\n\nmapdata map(vec3 p) {\n    mapdata result;\n    \n    vec3 pp1 = p;\n    vec3 pp2 = p;\n    \n    float r = 0.2;\n    float t = PI + 0.5 * iTime;\n    float twist = -0.67 * p.y;\n    pp1.x += r * cos(t + twist);\n    pp1.z += r * sin(t + twist);\n    pp2.x += r * cos(t + PI + twist);\n    pp2.z += r * sin(t + PI + twist);\n    \n    float rep = 0.33;\n    pp1.y = mod(p.y, rep)-0.5*rep;\n    pp2.y = pp1.y;\n    \n    // Spheres\n    float spr = 0.09;\n    float spd1 = sdSphere(pp1, spr);\n    float spd2 = sdSphere(pp2, spr);\n    result = mapMin(mapdata(1, spd1), mapdata(2, spd2));\n    \n    // Connecting line\n   \tfloat cad = sdCapsule(pp1, vec3(0, 0, 0), pp1 - pp2, 0.02);\n    result = mapMin(result, mapdata(3, cad));\n    \n    return result;\n}\n\nvec3 lookAt(vec2 uv, vec3 origin, vec3 target, float fov) {\n\tvec3 zz = normalize(target - origin);\n    vec3 xx = normalize(cross(zz, vec3(0,1,0)));\n    vec3 yy = normalize(cross(xx, zz));\n    return normalize(uv.x * xx + uv.y * yy + fov * zz); \n}\n\nvec3 normal(vec3 pos) {\n    vec2 e = vec2(0.0005, 0.);\n    return normalize(\n        vec3(\n            map(pos + e.xyy).dist - map(pos - e.xyy).dist,\n            map(pos + e.yxy).dist - map(pos - e.yxy).dist,\n            map(pos + e.yyx).dist - map(pos - e.yyx).dist\n        )\n    );\n}\n\nfloat diffuse(vec3 nor, vec3 lightDir) {\n    return clamp( dot(nor, lightDir), 0.0, 1.0);\n}\n\nhitpoint raycast(vec3 ro, vec3 rd) {\n    hitpoint h;\n    \n    // Raymarching\n    float t = 0.0;\n    mapdata m;\n    for(int i=0; i<100; i++) {\n        mapdata m = map(ro + t * rd);\n        float d = m.dist; \n        if (abs(d) < 0.001) {\n            h.hit = true;\n            h.data = m;\n            h.pos = ro + t * rd;\n            h.normal = normal(h.pos);\n            break;\n        }\n        t += d;\n        if (t > 20.) {\n            break;\n        }\n    }\n    return h; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.1, 0.1, .6 * (uv.y + 0.5));\n    \n    // Camera\n    float ct = -0.5 * iTime;\n    vec3 ro = vec3(0, ct, 1.);\n    vec3 rd = lookAt(uv, ro, vec3(0, -2. + ct, 0), 1.);\n    \n    // Render\n    hitpoint h = raycast(ro, rd);\n    if (h.hit) {\n    \tfloat c = 0.0;\n    \tc += (2. * uv.y + 0.8) * diffuse(h.normal, vec3(1, 1, 2));\n        float shadow = 0.8 * diffuse(h.normal, vec3(-1, 0, 0));\n    \tc += pow(shadow, 3.);\n        \n        vec3 mat = vec3(0);\n        if (h.data.id == 1) {\n            mat = vec3(0.9, 0.1, 0.1);\n        } else if (h.data.id == 2) {\n            mat = vec3(0.1, 0.1, 0.9);\n        } else if (h.data.id == 3) {\n            mat = vec3(0.3, 0.6, 0.3);\n        }\n        \n\t    col = mat * c;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}