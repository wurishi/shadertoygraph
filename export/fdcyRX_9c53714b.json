{"ver":"0.1","info":{"id":"fdcyRX","date":"1653796514","viewed":165,"name":"Temporal Normal Map","username":"MisterSirCode","description":"Because why not? Wait about 2 seconds for it to smooth itself out.\n\nPart of my Simple Fractals playlist: [URL]https://www.shadertoy.com/playlist/NfSGW3[/URL]","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot","normal"],"hasliked":0,"parentid":"sdtcz2","parentname":"Smooth iterations"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float ct = texture(iChannel2, vec2(0)).x; // grab custom time from buffer c\n    \n    // If you want a different fractal, change the \"Mandelbrot\" function in Buffer A\n    \n    vec4 fr = texture(iChannel0, uv);\n    vec4 cfr = texture(iChannel1, uv);\n    \n    cfr = mix(fr, cfr, clamp(ct, 0.0, 1.0)); \n    // Transition to the denoised image after letting the normal map sample for a couple seconds\n    \n    fragColor = cfr;\n    //fragColor = texture(iChannel3, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// This layer temporally denoises the fractal to make it look nicer\n\nvec3 mandelbrot(vec2 z, vec2 c, float iter) {\n    float l = 0.0;\n    for (l = 0.0; l < iter; l += 1.0) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if(dot(z, z) > 65536.0) break;\n    }\n    \n    // This is a smooth iteration system. Only change the fractal above.\n\n    // Though this may not work with non-mandelbrot derived fractals. Beware.\n    \n    l = l - log2(log2(dot(z, z))) + 4.0;\n    if(dot(z, z) < 65536.0) l = iter; // color the inside white\n    l /= iter;\n    \n    // return the iterations and z for further processing.\n    return vec3(l, z);\n}\n\nbool useSquareDistribution = false;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 uv = ((2. * fragCoord - res) / res.x) * 2.;\n    vec3 pr = texture(iChannel0, fragCoord / res).xyz;\n    if (useSquareDistribution) {\n        vec2 pad = 1.333 * hash21(mod(iTime, 1000.)) / res;\n        uv += pad;\n    } else {\n        vec2 pad = diskPt(hash21(mod(iTime, 1000.))) / res;\n        uv += pad;\n    }\n    \n    uv.x -= 0.5;\n    vec3 m = mandelbrot(vec2(0), uv * 1.5, 100.);\n    float fr = sqrt(m.x);\n        \n    fr = clamp(fr, 0., 1.);\n    fr = mix(fr, pr.x, .99);\n    \n    fragColor = vec4(vec3(fr), res);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// This layer just grabs the normal map\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 pix = 1. / iResolution.xy / 32.;\n    float h = 0.0, dx = 0.0, dy = 0.0;\n    float tex;\n    for (int nml = 0; nml < 3; nml++) {\n        vec2 tuv = uv;\n        if (nml == 1) tuv += vec2(pix.x, 0.0);\n        if (nml == 2) tuv += vec2(0.0, pix.y);\n        tex = texture(iChannel0, tuv).x;\n        if (nml == 0) h = tex;\n        if (nml == 1) dx = tex;\n        if (nml == 2) dy = tex;\n    }\n    vec2 dxy = h - vec2(dx, dy);\n    vec3 norm = normalize(vec3(dxy * 0.1 / pix, 1.0));\n    norm.xy = norm.xy / 2.0 + 0.5;\n    fragColor = vec4(norm, 0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// This layer temporally denoises the normal map to make it look nicer\n\nbool useSquareDistribution = true;\n\n// For once it seems the square distribution is better. Not sure why, but the normal map looks nicer with it.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec3 pr = texture(iChannel0, uv).xyz;\n    if (useSquareDistribution) {\n        vec2 pad = 0.5 * hash21(mod(iTime, 1000.)) / res;\n        uv += pad;\n    } else {\n        vec2 pad = diskPt(hash21(mod(iTime, 1000.))) / res;\n        uv += pad;\n    }\n    \n    vec4 fr = texture(iChannel1, uv);\n        \n    fr.x = mix(fr.x, pr.x, .99);\n    fr.y = mix(fr.y, pr.y, .99);\n    fr.z = mix(fr.z, pr.z, .99);\n    \n    fragColor = vec4(fr.xyz, res);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Stuff for the temporal denoising:\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 diskPt(vec2 p) {\n    return sqrt(p.x) * vec2(sin(6.2832 * p.y), cos(6.2832 * p.y));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// This layer basically just runs a little timer and sends the data to the mainImage\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 pr = texture(iChannel0, vec2(0));\n    float ct = pr.w; // grab current time from last frame\n    if (iTime > 2.)\n        ct += .01;\n    fragColor = vec4(ct);\n}","name":"Buffer D","description":"","type":"buffer"}]}