{"ver":"0.1","info":{"id":"3lV3WW","date":"1579460992","viewed":158,"name":"Ltd.","username":"onlinerocker","description":" (o)(o)\n\\_____/","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","eye","sin","cos","trippy","colorfull"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(vec2 p)\n{\n    p *= 200.0;\n    p = floor(p);\n    \n \treturn mod(sin(p.x*p.y+3.23)*65213.943 + cos(p.y*p.x+1.0)*61235.364, 1.01);   \n}\n\nfloat randomRan(vec2 p, float range)\n{\n    p *= 200.0;\n    p = floor(p);\n    \n \treturn mod(sin(p.x*p.y+3.23)*65213.943 + cos(p.y*p.x+1.0)*61235.364, range);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = textureLod(iChannel0, uv, 10.0);\n    \n    col.rgb += vec3(0,0.2,0.5)*0.05+0.5*sin(5.0*iTime*random(uv)+random(uv))*random(uv)*sin(random(uv)+iTime*5.0*random(uv))*vec3(0.15)*random(uv);\n    //uv.x -= 0.01*sin(uv.y*5.0+iTime);\n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define VIEW_DIST 200.0\n\nstruct Object\n{\n    int ref;\n\tfloat d;\n    float specKs;\n    float specVal;\n    vec3 c;\n};\n    \n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise( float x , float low, float ran)\n{\n    float frac = fract(x);\n    //if(x < 0.0) frac = 1.0 - abs(frac);\n    x = floor(x);\n    \n    float val = (low + mod(sin(x+3.23)*35213.943, ran));\n    float val1 = (low + mod(sin(x+4.23)*35213.943, ran));\n    \n    float final = mix(val, val1, frac);\n    \n\treturn final;\n}\n\n//IQ - https://www.shadertoy.com/view/XsX3RB\nfloat noise3d( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f.z = 0.0;\n    p.z = 0.0;\n    \n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, 0.5 );\n}\n\nfloat rand( float x , float low, float ran)\n{\n    float val = (low + mod(cos(x-435.435)*sin(x+3564.23)*35213.943, ran));\n\n    return val;\n}\n\nvec3 calcSpecLight(vec3 color, vec3 lightPos, vec3 pos, vec3 camPos, vec3 normal, float specKs, float specVal)\n{\n \tvec3 dir = normalize(lightPos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(normal, dir), 0.0, 1.0) * normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n\n    vec3 col = specKs*1.0*(color*pow(spec, specVal));\n    return col;\n}\n    \n//iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 eyeColor(vec3 p, vec3 eyeFwd)\n{\n    vec3 color;\n    float len = dot(p, eyeFwd) / length(eyeFwd);\n    \n\tcolor = vec3(1);\n    color *= mix(vec3(0.005), vec3(1), smoothstep(0.92, 0.99, len));\n    color *= mix(vec3(1), vec3( rand(floor((1.0+iTime)/2.0) , 0.0, 1.0),0.1,1), smoothstep(0.89, 0.96, len));\n    color *= mix(vec3(1), vec3(0.01), smoothstep(0.985, 0.995, len));\n    if(length(color) < 0.01)\n        color = mix(vec3(1,0,0), vec3(1), smoothstep(0.0, 1.0+noise3d(p*15.0)*0.1, len));\n\treturn color;\n}\n\n\n\nObject map(vec3 p)\n{\n \tObject o;\n   \to.d = 1000.0;\n    o.specKs = 10.0;\n    o.specVal = 55.0;\n    \n    vec3 eyeDir = vec3(0,0,1);\n    float ang;// =  noise(5.0*iTime, -PI/4.0, PI/2.0);\n    float ang1;// = noise(5.0*iTime, -PI/4.0, PI/2.0);\n    \n    //eyeDir.xz = mat2(cos(ang), sin(ang), -sin(ang), cos(ang)) * eyeDir.xz;\n    //eyeDir.yz = mat2(cos(ang1), sin(ang1), -sin(ang1), cos(ang1)) * eyeDir.yz;\n    \n\tfloat d;\n    \n    vec3 bPt = p;\n    float s = sign(bPt.z);\n    bPt.z = -abs(bPt.z);\n    bPt -= vec3(-10, 13.0+step(0.0, s)*-5.0,-10.0+step(0.0, s)*-5.0);\n    bPt.y += cos(bPt.z+iTime*5.0);\n    ang = PI/4.0 * 1.0+0.25*cos(p.z*PI);\n    float bAng = PI/3.0;\n    float bAng1 = -PI/4.0;\n    \n    bPt.yz = mat2(cos(bAng), -sin(bAng), sin(bAng), cos(bAng)) * bPt.yz;\n    bPt.xz = mat2(cos(bAng1), -sin(bAng1), sin(bAng1), cos(bAng1)) * bPt.xz;\n    bPt.xy = mat2(cos(-iTime), -sin(-iTime), sin(-iTime), cos(-iTime)) * bPt.xy;\n    bPt.xy = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * bPt.xy;\n    d = sdBox(bPt, vec3(1,1,30));\n    if(d < o.d)\n    {\n        o.d = d;\n    \to.c = vec3(step(0.0, s)*1.0,cos(iTime*10.0+p.x*p.z),sin(iTime*22.0+p.z*p.x));\n    }    \n    \n    bPt = p;\n    bPt -= vec3(-11,5,-12);   \n    //bPt.x = abs(bPt.x);\n    bPt.x = -20.0 + mod(bPt.x, 38.0);\n    bPt.y += sin(bPt.z+iTime*5.0);\n\n    ang = PI/4.0 * 1.0+0.25*cos(p.z*PI);\n    bAng = PI/2.5;\n    bAng1 = PI/6.0;\n    \n    bPt.yz = mat2(cos(bAng), -sin(bAng), sin(bAng), cos(bAng)) * bPt.yz;\n    bPt.xz = mat2(cos(bAng1), -sin(bAng1), sin(bAng1), cos(bAng1)) * bPt.xz;\n    bPt.xy = mat2(cos(-iTime), -sin(-iTime), sin(-iTime), cos(-iTime)) * bPt.xy;\n    bPt.xy = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * bPt.xy;\n    d = sdBox(bPt, vec3(1,1,30));\n    if(d < o.d)\n    {\n        o.d = d;\n    \to.c = vec3(sin(iTime*12.0+p.z*p.x),-sin(iTime*12.0+p.z*p.x),cos(iTime*10.0+p.y));\n    }  \n    \n    bPt = p;\n    vec3 id = bPt;\n    id = floor(id*100.0);\n    bPt.y = mod(bPt.y , 30.0);\n    //bPt.x = abs(bPt.x);\n    bPt -= vec3(50,25,-20);\n    bPt.y += sin(bPt.z+iTime*5.0);\n    ang = PI/4.0 * 1.0+0.25*cos(p.z*PI);\n    bAng = PI/2.5;\n    bAng1 = PI/2.5;\n    \n    bPt.yz = mat2(cos(bAng), -sin(bAng), sin(bAng), cos(bAng)) * bPt.yz;\n    bPt.xz = mat2(cos(bAng1), -sin(bAng1), sin(bAng1), cos(bAng1)) * bPt.xz;\n    bPt.xy = mat2(cos(-iTime), -sin(-iTime), sin(-iTime), cos(-iTime)) * bPt.xy;\n    bPt.xy = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * bPt.xy;\n    d = sdBox(bPt, vec3(1,1,90));\n    if(d < o.d)\n    {\n        o.d = d;\n    \to.c = vec3(id.y/2500.0+sin(iTime*10.0*-p.y),cos(iTime*12.0-p.x),cos(iTime*13.0*p.z));\n    }  \n\n    bPt = p;\n    id = bPt;\n    id = floor(id*100.0);\n    bPt.x = mod(bPt.x , 30.0);\n    bPt.y = abs(bPt.y);\n    bPt.z = abs(bPt.z);\n    bPt -= vec3(20,7,30);\n    bPt.y += sin(bPt.z+iTime*5.0);\n    ang = PI/4.0 * 1.0+0.25*cos(p.z*PI);\n    bAng = PI/2.5;\n    bAng1 = PI;\n    \n    bPt.yz = mat2(cos(bAng), -sin(bAng), sin(bAng), cos(bAng)) * bPt.yz;\n    bPt.xz = mat2(cos(bAng1), -sin(bAng1), sin(bAng1), cos(bAng1)) * bPt.xz;\n    bPt.xy = mat2(cos(-iTime), -sin(-iTime), sin(-iTime), cos(-iTime)) * bPt.xy;\n    bPt.xy = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * bPt.xy;\n    d = sdBox(bPt, vec3(2,2,80));\n    if(d < o.d)\n    {\n        o.d = d;\n    \to.c = vec3(-id.y/200.0 + 1.0,cos(iTime*10.0 + cos(id.z)*id.z/50.0),abs(id.z/100.0));\n    }  \n    \n    bPt = p;\n    id = bPt;\n    id = floor(id*100.0);\n    bPt.y = mod(bPt.y, 20.0);\n    bPt.z = abs(bPt.z);\n    bPt -= vec3(0,10,20);\n    bPt.y += sin(bPt.z+iTime*5.0);\n    ang = PI/4.0 * 1.0+0.25*cos(p.z*PI);\n    bAng1 = -PI/2.2;\n\n    bPt.xz = mat2(cos(bAng1), -sin(bAng1), sin(bAng1), cos(bAng1)) * bPt.xz;\n    bPt.xy = mat2(cos(-iTime), -sin(-iTime), sin(-iTime), cos(-iTime)) * bPt.xy;\n    bPt.xy = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * bPt.xy;\n    \n    d = sdBox(bPt, vec3(1,1,80));\n    if(d < o.d)\n    {\n        o.d = d;\n    \to.c = vec3(noise(2.0*(id.y/100.0), 0.0, 1.0), sin(10.0*iTime+p.x), 1.0+sin(iTime*10.0+p.y));\n    }  \n    \n    d = length(p) - 1.0;\n    float d1 = length(p-vec3(0,0,-0.5-0.5*cos(-iTime*PI))) - 1.3;\n    \n    \n    if(d < o.d)\n    {\n        o.d = smin(d1, d, 0.1);\n        if(d1 < d)\n        {\n            o.specKs = 30.0;\n            o.specVal = 10.0;\n            o.ref = 1;\n            o.c = vec3(-sin(12.0*iTime*p.x*p.z),0,0.3);\n        }else\n        {\n    \t\to.c = eyeColor(p, eyeDir);\n    \t}\n    }\n    \n    return o;\n}\n\nvec3 norm(vec3 p)\n{\n    float e = 0.01;\n    \n \tfloat x = map(p + vec3(e,0,0)).d - map(p - vec3(e,0,0)).d;\n    float y = map(p + vec3(0,e,0)).d - map(p - vec3(0,e,0)).d;\n    float z = map(p + vec3(0,0,e)).d - map(p - vec3(0,0,e)).d;\n    \n    return normalize(vec3(x,y,z));\n}\n\nfloat random(vec2 p)\n{\n    p *= 1000.0;\n    p = floor(p);\n    \n \treturn mod(sin(p.x*p.y+3.23)*65213.943 + cos(p.y*p.x+1.0)*61235.364, 1.01);   \n}\n\nvec3 bg(vec2 p)\n{\n\treturn vec3(0);\t\n}\n\nvec3 bg(vec3 col, float d)\n{\n \t//col += 0.0003*d;\n    col = vec3(0.05);\n    return col;\n}\n\nvec3 reflColor(vec3 pos, vec3 normal)\n{\n \tvec3 col;\n    vec3 p;\n    vec3 d = normal;\n    float td = 0.01;\n    Object o;\n    for(int x=0; x<100; x++)\n    {\n   \t\tp = pos + td*d;\n        o = map(p);\n        \n        if(abs(o.d) < 0.001)\n        {\n            vec3 norm = norm(p);\n         \tcol = o.c*dot(norm, normalize(vec3(1,4,5) - p));\n            col += calcSpecLight(col, vec3(1,4,5), p, pos, norm, o.specKs, o.specVal);\n            //col = fog(col, td);\n            break;\n        }else if(td > VIEW_DIST)\n        {\n            col = bg(col, td);\n            break;\n        }\n        \n        td += o.d*0.7;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 uvC = uv;\n    //uvC.y += 0.3*sin(iTime);\n    //uvC.x += 0.1*cos(iTime);\n    vec3 col = vec3(0);\n    \n    //col *= 2.0+3.0*step(0.5, floor(random(uvC)*1.7));\n    \n\tvec3 camEye = vec3(0,0,3.0); //*random(vec2(1,step(0.0, sin(PI*iTime*15.0)))));\n    vec3 d = normalize(vec3(uv, -1));\n    \n    float ang = 0.1*cos(iTime);//iMouse.x / 20.0;\n    camEye.xz = mat2(cos(ang), sin(ang), -sin(ang), cos(ang)) * camEye.xz;\n    d.xz = mat2(cos(ang), sin(ang), -sin(ang), cos(ang)) * d.xz;\n    \n    Object o;\n\n    vec3 p;\n    float td;\n    for(int x=0; x<100; x++)\n    {\n   \t\tp = camEye + td*d;\n        o = map(p);\n        \n        if(abs(o.d) < 0.001)\n        {\n            vec3 norm = norm(p);\n            if(o.ref > 0)\n            {\n                col = vec3(0.66)*reflColor(p, norm);\n            }else\n            {\n         \t\tcol = o.c*dot(norm, normalize(vec3(1,4,5) - p));\n            \t//col = fog(col, td);\n            }\n            col += calcSpecLight(col, vec3(1,4,5), p, camEye, norm, o.specKs, o.specVal);\n            break;\n        }else if(td > VIEW_DIST)\n        {\n            col = bg(col, td);\n            break;\n        }\n        \n        td += o.d*0.7;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}