{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* \"Plastic Sphere Garden\" by MasterM/Asenses */\n\n// Constant parameters\n\n#define PI  3.14159265\n#define PI2 6.28318531\n\n#define INFINITY  1000.0\n#define THRESHOLD 0.01\n#define EPSILON   0.0001\n#define MAX_STEPS 150\n\n#define L_AMBIENT  vec3(0.1,0.1,0.1)\n#define L_DIFFUSE  0.6\n#define L_SPECULAR 1.0\n#define L_SHADOW   6.0\n#define L_FOG      20.0\n#define L_FOG_COL  vec3(0.6,0.1,0.1)\n\n#define AO_BASEP  1.5\n#define AO_STEPS  5\n#define AO_DELTA  0.1\n\n// Utility structures\n\nstruct light_t { vec3 pd; vec3 color; float power; };\nstruct ray_t { vec3 p; vec3 d; };\nstruct hit_t { vec3 p; vec3 n; vec3 v; vec3 color; float d; };\n\t\n// Time\n\nfloat T(const float t)\n{\n\treturn mod(t, PI2);\n}\n\n// Operations\n\t\nvec4 ADD(in vec4 o1, in vec4 o2)\n{\n\treturn o1.x<o2.x ? o1 : o2;\n}\n\t\nvec3 REPXZ(in vec3 p, in vec2 factor)\n{\n\tvec2 tmp = mod(p.xz, factor) - 0.5*factor;\n\treturn vec3(tmp.x, p.y, tmp.y);\n}\n\t\n// Shapes\n\nfloat sphere(in vec3 p, in vec3 pos, in float radius)\n{\n\treturn length(p-pos) - radius;\n}\n\nfloat ground(in vec3 p)\n{\n\treturn p.y + 0.3*sin(mod(p.x,PI2))*cos(mod(p.z,PI2));\n}\n\n// Scene definition\n\nvec4 scene(in vec3 p)\n{\n\treturn ADD(\n\t\tvec4(ground(p), 0.97, 0.98, 0.82),\n\t\tvec4(sphere(REPXZ(p, vec2(5.0, 5.0)), vec3(0.0, 1.0, 1.2), 1.0), 0.7, 1.0, 0.7)\n\t);\n}\n\n// Rendering code\n\nvec3 normal(in vec3 p, in float dist)\n{\n\tvec3 n;\n\tn.x = scene(p + vec3(EPSILON, 0.0, 0.0)).x - dist;\n\tn.y = scene(p + vec3(0.0, EPSILON, 0.0)).x - dist;\n\tn.z = scene(p + vec3(0.0, 0.0, EPSILON)).x - dist;\n\treturn normalize(n);\n}\n\nbool raymarch(in ray_t ray, const float maxt, out hit_t hit)\n{\n\tfloat t=0.0;\n\tfor(int i=0; i<MAX_STEPS; i++) {\n\t\tvec4 result = scene(ray.p);\n\t\tif(result.x <= THRESHOLD) {\n\t\t\thit.p     = ray.p;\n\t\t\thit.v     = ray.d;\n\t\t\thit.d     = t + result.x;\n\t\t\thit.n     = normal(ray.p, result.x);\n\t\t\thit.color = result.yzw;\n\t\t\treturn true;\n\t\t}\n\t\t\t\n\t\tif((t += result.x) >= maxt)\n\t\t\tbreak;\n\t\tray.p += result.x * ray.d;\t\n\t}\n\treturn false;\n}\n\nbool raymarch(in ray_t ray, const float maxt)\n{\n\tfloat t=0.0;\n\tfor(int i=0; i<MAX_STEPS; i++) {\n\t\tfloat dist = scene(ray.p).x;\n\t\tif(dist <= THRESHOLD)\n\t\t\treturn true;\n\t\t\n\t\tif((t += dist) >= maxt)\n\t\t\tbreak;\n\t\tray.p += dist * ray.d;\n\t}\n\treturn false;\n}\n\nfloat computeAO(in hit_t hit)\n{\n\tray_t ao_ray = ray_t(hit.p, hit.n);\n\tao_ray.p += AO_DELTA * ao_ray.d;\n\t\n\tfloat ao = 0.0;\n\tfor(int i=0; i<AO_STEPS; i++) {\n\t\tfloat dist = scene(ao_ray.p).x;\n\t\tao += 1.0/pow(AO_BASEP,float(i)) * (float(i)*AO_DELTA - dist);\n\t\tao_ray.p += AO_DELTA * ao_ray.d;\n\t}\n\treturn 1.0 - ao;\n}\n\nfloat is_lit(in vec3 P, in vec3 L, const float maxt)\n{\n\tray_t shadow_ray = ray_t(P, L);\n\tshadow_ray.p += 0.1 * shadow_ray.d;\n\t\n\tfloat t=0.0, lit=1.0;\n\tfor(int i=0; i<MAX_STEPS; i++) {\n\t\tfloat dist = scene(shadow_ray.p).x;\n\t\tif(dist <= THRESHOLD)\n\t\t\treturn 0.0;\n\t\t\n\t\tlit = min(lit, L_SHADOW*dist/t);\n\t\tif((t += dist) >= maxt)\n\t\t\tbreak;\n\t\tshadow_ray.p += dist * shadow_ray.d;\n\t}\n\treturn lit;\n}\n\nvec3 shade(in hit_t hit, in vec3 cam)\n{\n\tlight_t light0 = light_t(\n\t\tvec3(cam.x + 20.0*sin(T(iTime)), 20, cam.z+20.0+5.0*cos(T(iTime))),\n\t\t vec3(1,1,1), 450.0);\n\t\n\tvec3  color = L_AMBIENT;\n\tfloat R     = length(light0.pd - hit.p);\n\tvec3  L     = (light0.pd - hit.p) / R;\n\t\n\tR = light0.power / (R*R);\n\t\n\tfloat dp   = clamp(hit.d, 0.0, INFINITY)/INFINITY;\n\tfloat fog  = clamp(exp(-(L_FOG * L_FOG * dp * dp)), 0.0, 1.0);\n\tfloat lit  = is_lit(hit.p, L, INFINITY);\n\t\n\tif(lit > 0.0) {\n\t\tfloat dotNL = max(0.0, dot(hit.n, L));\n\t\tfloat dotVR = max(0.0, dot(hit.v, reflect(L, hit.n)));\n\t\tcolor += L_DIFFUSE * dotNL * light0.color * hit.color * lit * R;\n\t\tcolor += L_SPECULAR * pow(dotVR, 20.0) * lit * R;\n\t}\n\treturn mix(color * computeAO(hit), L_FOG_COL, 1.0-fog);\n}\n\n// Camera\n\nvec3 lookat(const vec2 fragCoord, const vec3 forward, const vec3 up)\n{\n\tvec3 _forward = normalize(forward);\n\tvec3 _right   = cross(_forward, normalize(up));\n\tvec3 _up      = cross(_right, _forward);\n\t\n\tfloat aspect  = iResolution.x / iResolution.y;\n\tvec2  uv      = fragCoord.xy / iResolution.xy;\n\tvec2  pixel   = vec2((uv.x-0.5)*aspect, uv.y-0.5);\n\t\n\treturn normalize(pixel.x * _right + pixel.y * _up + _forward);\n}\n\n// Shader main\n\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 color = L_FOG_COL;\n\n\tray_t ray;\n\tray.p = vec3(cos(T(iTime*0.1))*20.0, 6.0, 10.0 * iTime);\n\tray.d = lookat(fragCoord, vec3(0.0, -0.32, 0.68), vec3(0.2*cos(T(0.25*iTime)), 0.8, 0.0));\n\t\n\thit_t hit;\n\tif(raymarch(ray, INFINITY, hit))\n\t\tcolor = shade(hit, ray.p);\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsBGW1","date":"1386933372","viewed":1456,"name":"Plastic Sphere Garden","username":"MasterM","description":"Toying around with simple ray marching after a long break from shader programming. :-)","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","spheres"],"hasliked":0,"parentid":"","parentname":""}}