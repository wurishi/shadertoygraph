{"ver":"0.1","info":{"id":"slB3WD","date":"1623904006","viewed":209,"name":"Fragment Shader Concepts","username":"Sudospective","description":"Made for Yasmyn in the UKSRT Discord. This will be updated periodically with new demonstrations when I'm able.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n1. Basic color output\n2. Spacial shading: X coordinate\n3. Spacial shading: Y coordinate\n4. Spacial shading: XY coordinate\n5. Temporal shading\n6. UV texture mapping\n7. Drawing shapes\n8. Scaling UV\n9. Shifting shape position\n10. Time-based shape positioning\n11. Multi-axis position\n12. Multiple textures\n13. Aligning textures to moving shapes\n14. Texture adjustment\n15. Mouse coordinates\n16. Magnifying glass\n17. Hiding shapes between textures\n18. Antialiasing with smoothstep\n*/\n\n// Change this number to see different demonstrations\n#define DEMO 1\n\n// 1. Basic color output\n#if DEMO == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This outputs black to the entire screen.\n    // No matter where the pixel is at any point in time, paint it black.\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n\n// 2. Color via spacial position using X coordinate\n#if DEMO == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This colors pixels a varied amount of red based on their X position on the canvas.\n    // Notice it's more black (0.0) on the LEFT, and more red (1.0) on the RIGHT.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv.x, 0.0, 0.0, 1.0);\n}\n#endif\n\n// 3. Color via spacial position using Y coordinate\n#if DEMO == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This colors pixels a varied amount of green based on their Y position on the canvas.\n    // Notice it's more black (0.0) on the BOTTOM, and more green (1.0) on the TOP.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0.0, uv.y, 0.0, 1.0);\n}\n#endif\n\n// 4. Color via spacial position using X and Y coordinate\n#if DEMO == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This takes the last two demonstrations and combines them.\n    // Notice the yellow at the top-right corner, where both red and green are equal to 1.0.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n#endif\n\n// 5. Color via temporal position using time variable\n#if DEMO == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This adds a new element, time, into the blue channel, pulsing the entire screen blue based on how much time has passed.\n    // Note the sine function used to make sure that our output stays between 0.0 and 1.0.\n    // You can go higher, but it is not recommended.\n    // Please try your best to NEVER go below 0.0 on a color channel.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(uv.x, uv.y, time, 1.0);\n}\n#endif\n\n// 6. Mapping texture to UV\n#if DEMO == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This takes a texture from our first channel, iChannel0, and colors pixels based on the correlating coordinate of our texture.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n#endif\n\n// 7. Positional color overwriting; first steps of complex shading\n#if DEMO == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We can color sections of our UV red to form a square...almost.\n    // Notice how the shape is drawn on top, as we changed those color values last.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    float size = 0.5;\n    if (abs(uv.x - size) < 0.25 && abs(uv.y - size) < 0.25) {\n        col = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    fragColor = col;\n}\n#endif\n\n// 8. Scaling UV\n#if DEMO == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screens aren't usually 1:1 ratio. We need to scale our UV based on only screen height to account for this.\n    // Notice the if statement and the use of absolute value. If we plug in values to uv.x between 0.0 and 1.0,\n    // how does this affect what we solve to?\n    vec2 uv = fragCoord.xy / iResolution.y;\n    vec4 col = texture(iChannel0, uv);\n    float size = 0.5;\n    if (abs(uv.x - size) < 0.25 && abs(uv.y - size) < 0.25) {\n        col = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    fragColor = col;\n}\n#endif\n\n// 9. Positioning elements based on scaled UV\n#if DEMO == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Now we can get a ratio of our screen size to shift our actual square to the center of our screen.\n    // Notice where the ratio is multiplied, and how that corresponds to the position of our square.\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec4 col = texture(iChannel0, uv);\n    float size = 0.5;\n    if (abs(uv.x - size * ratio) < 0.25 && abs(uv.y - size) < 0.25) {\n        col = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    fragColor = col;\n}\n#endif\n\n// 10. Shifting shape position based on time\n#if DEMO == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Let's move our square left to right in a sine wave.\n    // We need to alter where our drawing begins, so notice\n    // where iTime is used to do this.\n    // Also notice the speed and amplitude variables. Change them\n    // and see what they do.\n    // And again, notice the use of ratio for amplitude. Why would we might need this?\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec4 col = texture(iChannel0, uv);\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.2;\n    if (abs(uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed)) < size && abs(uv.y - 0.5) < size) {\n        col = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    fragColor = col;\n}\n#endif\n\n// 11. Adding Y axis movement\n#if DEMO == 11\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // We can change the Y coordinage using cosine to move our square in a circle.\n    // Note the if statement for the Y coordinate and how it differs from X.\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec4 col = texture(iChannel0, uv);\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.2;\n    // This is formatted for easier reading. It's still the same code.\n    if (\n        abs(uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed)) < size &&\n        abs(uv.y - 0.5 + amplitude * cos(iTime * speed)) < size\n    ) {\n        col = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    fragColor = col;\n}\n#endif\n\n// 12. Adding textures\n#if DEMO == 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // How about we add a texture to our square instead of a solid color?\n    // Note the addition of a new vec4, squareTex, and how it is defined and used.\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec4 col = texture(iChannel0, uv);\n    vec4 squareTex = texture(iChannel1, uv);\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.2;\n    if (\n        abs(uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed)) < size &&\n        abs(uv.y - 0.5 + amplitude * cos(iTime * speed)) < size\n    ) {\n        col = squareTex;\n    }\n    fragColor = col;\n}\n#endif\n\n// 13. Aligning texture to square\n#if DEMO == 13\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Right now our square acts as a hole punching through the bottom texture.\n    // Let's fix that so the square has a texture that appears static.\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec4 col = texture(iChannel0, uv);\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.2;\n    vec2 squarePos;\n    squarePos.x = uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed);\n    squarePos.y = uv.y - 0.5 + amplitude * cos(iTime * speed);\n    if (\n        abs(squarePos.x) < size &&\n        abs(squarePos.y) < size\n    ) {\n        col = texture(iChannel1, squarePos);\n    }\n    fragColor = col;\n}\n#endif\n\n// 14. Correcting the square texture\n#if DEMO == 14\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Right now, our square's texture is too big, but we can scale it\n    // based on our square's size.\n    // Note the subtraction of 0.25 on squarePos in the texture function.\n    // What could be the reason for this and why would it be useful?\n    // Why are we shifting the UV mapping a quarter of the size to the left?\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec4 col = texture(iChannel0, uv);\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.2;\n    vec2 squarePos;\n    squarePos.x = uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed);\n    squarePos.y = uv.y - 0.5 + amplitude * cos(iTime * speed);\n    if (\n        abs(squarePos.x) < size &&\n        abs(squarePos.y) < size\n    ) {\n        col = texture(iChannel1, (squarePos - 0.25) / (2.0 * size));\n    }\n    fragColor = col;\n}\n#endif\n\n// 15. Special request: Mouse coordinate shading\n#if DEMO == 15\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Going back to demonstration 12, we can use the mouse to control\n    // a kind of window into the other texture.\n    // Clicking and dragging along the shader will move our square\n    // along with the cursor, and releasing will set it back on its\n    // original path.\n    // Note the changes between squarePos and mouseOffset.\n    // Where did all the extra math go? What was it for?\n    // Also note the use of iMouse.z. If X and Y are position,\n    // What could Z be doing when we only have two axes for a mouse?\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 squarePos;\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.1;\n    vec4 col = texture(iChannel0, uv);\n    vec4 squareTex = texture(iChannel1, uv);\n    squarePos.x = uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed);\n    squarePos.y = uv.y - 0.5 + amplitude * cos(iTime * speed);\n    vec2 mouseOffset;\n    mouseOffset.x = uv.x - (iMouse.x / iResolution.y);\n    mouseOffset.y = uv.y - (iMouse.y / iResolution.y);\n    if (iMouse.z > 0.0) {\n        if (\n            abs(mouseOffset.x) < size &&\n            abs(mouseOffset.y) < size\n        ) {\n            col = squareTex;\n        }\n    } else {\n        if (\n            abs(squarePos.x) < size &&\n            abs(squarePos.y) < size\n        ) {\n            col = squareTex;\n        }\n    }\n    fragColor = col;\n}\n#endif\n\n// 17. Magnifying glass\n#if DEMO == 16\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Let's turn our square into a magnifying glass.\n    // Notice we used the same texture for the square, but now\n    // we multiply it by a float as well as offset the position.\n    // What happens if this magnify float value is negative?\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 squarePos;\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.1;\n    float magnify = 0.5;\n    vec4 col = texture(iChannel0, uv);\n    vec4 squareTex = texture(iChannel0, uv * (1.0 - magnify) + vec2(magnify * 0.5 * ratio, magnify * 0.5));\n    squarePos.x = uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed);\n    squarePos.y = uv.y - 0.5 + amplitude * cos(iTime * speed);\n    vec2 mouseOffset;\n    mouseOffset.x = uv.x - (iMouse.x / iResolution.y);\n    mouseOffset.y = uv.y - (iMouse.y / iResolution.y);\n    if (iMouse.z > 0.0) {\n        if (\n            abs(mouseOffset.x) < size &&\n            abs(mouseOffset.y) < size\n        ) {\n            col = squareTex;\n        }\n    } else {\n        if (\n            abs(squarePos.x) < size &&\n            abs(squarePos.y) < size\n        ) {\n            col = squareTex;\n        }\n    }\n    fragColor = col;\n}\n#endif\n\n\n// 17. Hide-and-seek\n#if DEMO == 17\n    // We can hide images that can be revealed with our square.\n    // If we make changes to squareTex before we use it, we can\n    // insert hidden objects within it to only be seen when moving\n    // the square.\n    // We're going to use circles for this.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 squarePos;\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.1;\n    float magnify = 0.5;\n    vec4 col = texture(iChannel0, uv);\n    vec4 squareTex = texture(iChannel0, uv * (1.0 - magnify) + vec2(magnify * 0.5 * ratio, magnify * 0.5));\n    squarePos.x = uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed);\n    squarePos.y = uv.y - 0.5 + amplitude * cos(iTime * speed);\n    vec2 mouseOffset;\n    mouseOffset.x = uv.x - (iMouse.x / iResolution.y);\n    mouseOffset.y = uv.y - (iMouse.y / iResolution.y);\n    \n    if (length(uv - vec2(0.15 * ratio, 0.75)) < 0.1) {\n        squareTex = vec4(1.0);\n    }\n    \n    if (length(uv - vec2(0.75 * ratio, 0.15)) < 0.1) {\n        squareTex = vec4(1.0);\n    }\n    \n    if (length(uv - vec2(0.944 * ratio, 0.9)) < 0.1) {\n        squareTex = vec4(1.0);\n    }\n    \n    if (iMouse.z > 0.0) {\n        if (\n            abs(mouseOffset.x) < size &&\n            abs(mouseOffset.y) < size\n        ) {\n            col = squareTex;\n        }\n    } else {\n        if (\n            abs(squarePos.x) < size &&\n            abs(squarePos.y) < size\n        ) {\n            col = squareTex;\n        }\n    }\n    fragColor = col;\n}\n#endif\n\n// 18. Antialiasing\n#if DEMO == 18\n// Our circles are looking a bit like legos.\n// Let's do some antialiasing using a function called\n// smoothstep. This will give a smooth transition between\n// the colors of our texture and the colors of our circles.\n\nfloat antialias( float circle, float size ) {\n    float m = smoothstep( size - 0.002, size + 0.002, circle);\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.1;\n    float magnify = 0.5;\n    vec4 col = texture(iChannel0, uv);\n    vec4 squareTex = texture(iChannel0, uv * (1.0 - magnify) + vec2(magnify * 0.5 * ratio, magnify * 0.5));\n    vec2 squarePos;\n    squarePos.x = uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed);\n    squarePos.y = uv.y - 0.5 + amplitude * cos(iTime * speed);\n    vec2 mouseOffset;\n    mouseOffset.x = uv.x - (iMouse.x / iResolution.y);\n    mouseOffset.y = uv.y - (iMouse.y / iResolution.y);\n    \n    // Let's assign these to variables.\n    float circ1 = length(uv - vec2(0.15 * ratio, 0.75));\n    float circ2 = length(uv - vec2(0.75 * ratio, 0.15));\n    float circ3 = length(uv - vec2(0.944 * ratio, 0.9));\n    float circSize = 0.1;\n    \n    // Now we capture the pixels of our circle, put it through\n    // our antialias function, and mix it to our canvas. The\n    // built-in function mix tells our shader to mix the two colors\n    // we give, in this case white and our texture color, by a certain\n    // amount, in this case our variable m, which can be anywhere from\n    // 0.0 to 1.0 depending on the pixel on the circle.\n    // Outer edges will be more like the texture color, and inner colors\n    // will be more white.\n    if (circ1 < size) {\n        float m = antialias(circ1, circSize);\n        squareTex = mix(vec4(1.0), squareTex, m);\n    }\n    if (circ2 < size) {\n        float m = antialias(circ2, circSize);\n        squareTex = mix(vec4(1.0), squareTex, m);\n    }\n    if (circ3 < size) {\n        float m = antialias(circ3, circSize);\n        squareTex = mix(vec4(1.0), squareTex, m);\n    }\n    \n    if (iMouse.z > 0.0) {\n        if (\n            abs(mouseOffset.x) < size &&\n            abs(mouseOffset.y) < size\n        ) {\n            col = squareTex;\n        }\n    } else {\n        if (\n            abs(squarePos.x) < size &&\n            abs(squarePos.y) < size\n        ) {\n            col = squareTex;\n        }\n    }\n    fragColor = col;\n}\n#endif\n\n// 19. ???\n#if DEMO == 19\n\n// Currently a copy of 18.\n\nfloat antialias( float circle, float size ) {\n    float m = smoothstep( size - 0.002, size + 0.002, circle);\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    float size = 0.25;\n    float speed = 4.0;\n    float amplitude = 0.1;\n    float magnify = 0.5;\n    vec4 col = texture(iChannel0, uv);\n    vec4 squareTex = texture(iChannel0, uv * (1.0 - magnify) + vec2(magnify * 0.5 * ratio, magnify * 0.5));\n    vec2 squarePos;\n    squarePos.x = uv.x - (0.5 * ratio) + amplitude * sin(iTime * speed);\n    squarePos.y = uv.y - 0.5 + amplitude * cos(iTime * speed);\n    vec2 mouseOffset;\n    mouseOffset.x = uv.x - (iMouse.x / iResolution.y);\n    mouseOffset.y = uv.y - (iMouse.y / iResolution.y);\n    \n    float circ1 = length(uv - vec2(0.15 * ratio, 0.75));\n    float circ2 = length(uv - vec2(0.75 * ratio, 0.15));\n    float circ3 = length(uv - vec2(0.944 * ratio, 0.9));\n    float circSize = 0.1;\n    \n    if (circ1 < size) {\n        float m = antialias(circ1, circSize);\n        squareTex = mix(vec4(1.0), squareTex, m);\n    }\n    if (circ2 < size) {\n        float m = antialias(circ2, circSize);\n        squareTex = mix(vec4(1.0), squareTex, m);\n    }\n    if (circ3 < size) {\n        float m = antialias(circ3, circSize);\n        squareTex = mix(vec4(1.0), squareTex, m);\n    }\n    \n    if (iMouse.z > 0.0) {\n        if (\n            abs(mouseOffset.x) < size &&\n            abs(mouseOffset.y) < size\n        ) {\n            col = squareTex;\n        }\n    } else {\n        if (\n            abs(squarePos.x) < size &&\n            abs(squarePos.y) < size\n        ) {\n            col = squareTex;\n        }\n    }\n    fragColor = col;\n}\n#endif\n\n\n// Sidenote:\n/*\n    An important and almost fundemental concept to understand when making shaders is that\n    it is vastly different from writing code for a website or a video game.\n    Nothing ever moves.\n    Colors, however, can always change.\n    With this square we've made, we didn't actually make any object or sprite or texture\n    for this square. It's not really made out of anything. All this square is is just a\n    grouping of pixels colored the same shade of red.\n    And furthermore, when we \"move\" this square, it doesn't actually ever move.\n    Nothing is ever moving in a shader (unless the texture itself moves), but colors can\n    and possibly will be constantly changing across several pixels.\n    So this square is actually a bunch of red pixels, and this movement is just the colors\n    being changed to give the illusion of these pixels moving left and right. This is the same\n    concept of everything you see on your monitor, but taken to a much less abstract level.\n    In order to write shaders effectively, it's very useful to understand the concept that\n    everything in a shader is just colors changing in ways that make patterns or movement or\n    wacky warpy effects. It all is essentially made of certain pixels in certain places changing to\n    certain colors at certain times.\n*/\n","name":"Image","description":"","type":"image"}]}