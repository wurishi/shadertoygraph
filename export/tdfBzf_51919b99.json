{"ver":"0.1","info":{"id":"tdfBzf","date":"1588744409","viewed":138,"name":"CTJuliaMorph","username":"Chris_M_Thomasson","description":"A pure experiment!","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","vector","morph","bio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fractal Morph Spin by Chris M. Thomasson\n\n\n#define PI 3.1459\n\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\nmat3 ct_rot_x(float angle) \n{\n    float cos_temp = cos(angle);\n    \n    float sin_temp = sin(angle);\n    \n    return mat3(\n        vec3(1., 0., 0.),\n        vec3(0., cos_temp, -sin_temp),\n        vec3(0, sin_temp, cos_temp)\n    );\n}\n\n\nmat3 ct_rot_y(float angle) \n{\n    float cos_temp = cos(angle);\n    float sin_temp = sin(angle);\n    return mat3(\n        vec3(cos_temp, 0., sin_temp),\n        vec3(0., 1., 0.),\n        vec3(-sin_temp, 0., cos_temp)\n    );\n}\n\n\nvec4 ct_circle(\n    in vec2 c,\n    in vec2 z,\n    in float radius\n){\n    float d = length(c - z);\n    \n    if (d < radius) \n    {\n        d = d / radius;\n        float b = -(.25 + abs(sin(iTime)));\n        return exp(b*dot(d,d) ) * vec4(1,.7,.4,0)*2.;\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n\n\nfloat ct_torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(vec2(p.x, p.z)) - t.x, p.y);\n    return length(q) - t.y * 0.5;\n}\n\n\nfloat ct_de(vec3 p)\n{\n    p *= ct_rot_x(iTime);\n    p *= ct_rot_y(iTime);\n    float de = ct_torus(p, vec2(.5 + abs(sin(iTime)) * .5, .5 + abs(cos(iTime * .25))) * .5);\n    return de;\n}\n\n\n\nmat3 ct_cam(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 norm_0 = normalize(ta - ro);\n    vec3 p2d = vec3(sin(cr), cos(cr),0.0);\n    vec3 cnorm_0 = normalize( cross(norm_0, p2d) );\n    vec3 cnorm_1 = normalize( cross(cnorm_0, norm_0) );\n    return mat3( cnorm_0, cnorm_1, norm_0 );\n}\n\n\nfloat ct_march_along(vec3 from, vec3 direction) {\n    float dis_sum = 0.0;\n    int i;\n    for (i = 0; i < 64; i++) {\n        vec3 p = from + dis_sum* direction;\n        \n        vec3 origin = vec3(1, 0, 0);\n        \n        float distance = ct_de(p);\n        \n        distance = min(distance, ct_de(p - origin));\n        distance = min(distance, ct_de(p + origin));\n        distance = min(distance, ct_de(p + origin + vec3(.0, .5, sin(iTime))));\n        \n        dis_sum+= distance;\n        if (distance < .001)\n        {\n            break;\n        }\n    }\n    \n    return 1.0 - float(i) / float(64);\n}\n\n\nvec3 ct_main(vec3 pt, vec3 direction) {\n    float dis = ct_march_along(pt, direction);\n    float color_1 = mod(dis * 5., 1.);\n    return vec3(dis, dis, dis);\n}\n\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0., \n        0., \n        abs(sin(iTime * .25)) + .5\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    \n    \n    vec2 cj = vec2(-.5 + abs(cos(iTime * .5)) * .25, sin(iTime) * .1);\n    vec2 zj = c;\n    \n    zj = ct_cmul(zj, zj) + cj;\n    zj = ct_cmul(zj, zj) + cj;\n    //zj = ct_cmul(zj, zj) + cj;\n    //zj = ct_cmul(zj, zj) + cj;\n    \n    c = zj;\n    \n    \n    \n    vec3 dis = vec3( 0, 0, 5 );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    mat3 cam_mat = ct_cam( dis, origin, 0.0 );\n    vec3 rai_vec = cam_mat * normalize( vec3(c.xy, 2.0) );\n    \n    // Exec...\n    vec4 color = vec4(ct_main(dis, rai_vec), 1.);\n    \n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}