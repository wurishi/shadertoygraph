{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define STEPPED\n#define SPEED 8.\n#define COLOR_SPEED 6.\n#define COLOR_CYCLES 1.\n\nbool in_region(ivec2 pos, ivec2 x1, ivec2 x2) {\n    ivec2 bl = x1;\n    ivec2 tr = x2;\n    \n    if (x2.x < x1.x) {\n        bl.x = x2.x;\n        tr.x = x1.x;\n    }\n    if (x2.y < x1.y) {\n        bl.y = x2.y;\n        tr.y = x1.y;\n    }\n    \n    return all(lessThanEqual(bl, pos)) && all(lessThan(pos, tr));\n}\n\n// algorithm from: https://github.com/jakubcerveny/gilbert\nfloat GilbertIndex( ivec2 canvas, ivec2 pos )\n{\n    float canvas_size = float(canvas.x * canvas.y);\n    int start_ix = 0;\n    ivec2 p = ivec2(0);\n    ivec2 a = ivec2(canvas.x, 0);\n    ivec2 b = ivec2(0, canvas.y);\n    ivec2 da;\n    ivec2 db;\n    ivec2 wh;\n    ivec2 a2;\n    ivec2 b2;\n    ivec2 wh2;\n    \n    if (canvas.x < canvas.y) {\n        a = ivec2(0, canvas.y);\n        b = ivec2(canvas.x, 0);\n    }\n    \n    // limit the looping, just in case there's an infinite loop bug XD\n    int levels = 5 * int(log2(float(max(canvas.x, canvas.y)))) + 1;\n    for(int i = 0; i < levels; i++) {\n        da = sign(a);\n        db = sign(b);\n\n        wh = abs(ivec2(a.x + a.y, b.x + b.y));\n\n        if (wh.y <= 1) {\n            return float(start_ix + da*(pos - p).x) / canvas_size;\n        }\n\n        if (wh.x <= 1) {\n            return float(start_ix + db*(pos - p).y) / canvas_size;\n        }\n\n        a2 = a/2;\n        b2 = b/2;\n\n        wh2 = abs(ivec2(a2.x + a2.y, b2.x + b2.y));\n\n        if (2*wh.x > 3*wh.y) {\n            if (((wh2.x & 1) == 0) && (wh.x > 2)) {\n                a2 += da;\n            }\n\n            // long case: split in two parts only\n            if (in_region(pos, p, p + a2 + b)) {\n                a = a2;\n            } else {\n                start_ix += abs(wh.y) * abs((a2.x + a2.y));\n                p += a2;\n                a -= a2;\n            }\n        } else {\n            if (((wh2.y & 1) == 1) && (wh.y > 2)) {\n                // prefer even steps\n                b2 += db;\n            }\n\n            // standard case: one step up, one long horizontal, one step down\n            if (in_region(pos, p, p + a2 + b2)) {\n                a = b2;\n                b = a2;\n            } else if (in_region(pos, p + b2, p + a + b)) {\n                ivec2 q = a2 + b2;\n                start_ix += abs(q.x*q.y);\n                p += b2;\n                b -= b2;\n            } else {\n                ivec2 q = a2 + b2;\n                start_ix += abs(q.x*q.y);\n                q = a + b2;\n                start_ix += abs(q.x*q.y);\n                p += a + b2;\n                b = a2 - a;\n                a = -b2;\n            }\n        }\n    }\n    \n    return -1.;\n}\n\n// color formula taken from: https://iquilezles.org/articles/palettes/\nvec3 color(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.30, 0.20, 0.20);\n    return a + b*cos( 6.283185*(c*t + d) );\n}\n\nfloat positiveSigmoid(float x) {\n    return 2. / (1. + exp(-x*3.)) - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    float t = iTime;\n    \n    #ifdef STEPPED\n    int level = int(11. * positiveSigmoid(fract(t * SPEED / 100.)));\n    float scale = level >= 10 ? iResolution.y : float(1u << level);\n    #else\n    float level = 11. * positiveSigmoid(fract(t * SPEED / 200.));\n    float scale = level >= 10. ? iResolution.y : pow(2., level);\n    #endif\n    \n    // center the curve, since lower resolutions might not align with the screen\n    vec2 canvas = iResolution.xy / iResolution.y * scale;\n    vec2 pos = uv * scale;\n    pos -= fract(canvas)/2.;\n    \n    vec3 c = vec3(0);\n    \n    // only display the curve in the integer canvas area\n    if (all(lessThanEqual(vec2(0.), pos)) && all(lessThan(pos, canvas - fract(canvas)))) {\n        float Index = GilbertIndex(ivec2(canvas), ivec2(pos));\n        if (0. <= Index) {\n            Index += t * COLOR_SPEED / 100.;\n            c = color(Index * COLOR_CYCLES);\n        }\n        //c = vec3(.4, .6, 0.);\n    }\n    \n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lccfDs","date":"1733723349","viewed":66,"name":"Gilbert Curve Demo","username":"notscared","description":"a demo of the gilbert curve -- the arbitrary rectangle variant of the hilbert curve as detailed on https://github.com/jakubcerveny/gilbert\n\ni based this shader on https://www.shadertoy.com/view/XtGBDW, initially","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","hilbert","short","hilbertcurve","gilbert","gilbertcurve"],"hasliked":0,"parentid":"","parentname":""}}