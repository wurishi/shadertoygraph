{"ver":"0.1","info":{"id":"MttGz8","date":"1467991664","viewed":856,"name":"SDF Material blending","username":"XDargu","description":"Basic SDF material blending","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sdf","blend"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n   I wanted to make basic material blending capable of blending materials using only \n   the material ID, without the actual colour. This is my clumsy first attempt. \n   Currently the shader can't blend more than two materials, and it's probably much more expensive\n   than it shoud be. Artifacts are evident when it tries to blend three or more colours.\n   \n   The way it works is having two material IDs and a blend amount between them. The first id\n   is always the dominant material of the surface, using the blend amount to mix between the\n   materials. In the render function we can get the material info of the current surface and\n   set the colour using the material ID. This is done for both materials, and then both colours\n   are mixed in order to produce the final value.\n\n Sources:\n - http://mercury.sexy/hg_sdf/\n - https://iquilezles.org/articles/distfunctions\n\n*/\n#define BLEND_SIZE 0.3\n\n#define PI 3.14159\n#define BLEND\n#define BLEND_AMOUNT 8.0\n\n//#define VIEW_BLEND\n//#define VIEW_SECOND_COL\n\n// SDF result struct\nstruct SDFRes\n{\n    float d; // distance\n    float m; // material\n    float m2; // secondary material\n    float b; // blend amount: 0=m, 1=m2\n};\n    \n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat getBlend(float d1, float d2)\n{\n    float diff = -abs(d1 - d2);\n    float blend = diff / BLEND_SIZE;\n    blend = saturate((blend + 1.0) * 0.5);\n    return blend;\n}\n\n// Operations\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat add(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat substract(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nSDFRes addSDF(in SDFRes f1, SDFRes f2 )\n{\n    if (f1.d < f2.d)\n    \treturn f1;\n    return f2;\n}\n\nSDFRes substractSDF(SDFRes f1, SDFRes f2 )\n{\n    float t = substract(f1.d, f2.d);\n    return SDFRes(t, (t < f2.d) ? f1.m : f2.m, 0.0, 0.0);\n}\n\nSDFRes blendSDF(SDFRes f1, SDFRes f2, float k)\n{\n    // Branching a lot :( Needs more work\n    \n   \tSDFRes closest  = f1;\n    SDFRes furthest = f2;\n\t\n\tfloat diff = float(f1.d > f2.d);\n    \n\tclosest.d =  mix(f1.d, f2.d,   diff);\n\tclosest.m =  mix(f1.m, f2.m,   diff);\n\tclosest.m2 = mix(f1.m2, f2.m2, diff);\n\tclosest.b =  mix(f1.b, f2.b,   diff);\n\t\n\tfurthest.d =  mix(f2.d, f1.d,   diff);\n\tfurthest.m =  mix(f2.m, f1.m,   diff);\n\tfurthest.m2 = mix(f2.m2, f1.m2, diff);\n\tfurthest.b =  mix(f2.b, f1.b,   diff);\n    \n\t// Dominant materials\n\tfloat mf1 = mix(closest.m2, closest.m, float(closest.b < 0.5));\n\tfloat mf2 = mix(furthest.m2, furthest.m, float(furthest.b < 0.5));\n    \n    // New distance\n    float t  = smin(f1.d, f2.d, k);\n    \n    // New blend\n    float bnew = getBlend(f1.d, f2.d);\n    float b = max(closest.b, bnew);\n    float bhigher = float(b > bnew);\n\n\tfloat m  = mix(mf1, closest.m,  bhigher);\n\tfloat m2 = mix(mf2, closest.m2, bhigher);\n    \n    return SDFRes(t, m, m2, b);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere(in vec3 p, in float size )\n{\n    return length(p) - size;\n}\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdWaves( vec3 p )\n{\n    return p.y + cos(p.x)*cos(p.z)*0.2;\n}\n\nSDFRes map(in vec3 pos )\n{   \n    SDFRes plane = SDFRes( sdWaves(  pos - vec3(0.0, 0.0, 0.0) ), 1.0, 0.0 ,0.0);\n    \n    SDFRes dist = SDFRes( sdSphere( pos - vec3( -0.2,0.5, -0.4 + sin(iTime)*2.0), 0.7 ), 200.0, 0.0, 0.0);\n    \n    #ifdef BLEND\n    dist = blendSDF( dist, SDFRes( sdSphere( pos - vec3( 0.6,0.5, -0.4), 0.5 ), 245.0, 0.0, 0.0), BLEND_AMOUNT );\n    #else\n    dist = addSDF( dist, SDFRes( sdSphere( pos - vec3( 0.6,0.5, -0.4), 0.5 ), 245.0, 0.0, 0.0) );\n    #endif\n    \n    #ifdef BLEND    \n    dist = blendSDF( dist, SDFRes( sdTorus( pos-vec3( 0.0,0.5+ sin(iTime*0.4), 1.0), vec2(0.5, 0.2) ), 40.6, 0.0, 0.0 ), BLEND_AMOUNT);\n    #else    \n    dist = addSDF( dist, SDFRes( sdTorus( pos-vec3( 0.0,0.5+ sin(iTime*0.4), 1.0), vec2(0.5, 0.2) ), 40.6, 0.0, 0.0 ));\n    #endif    \n    \n    #ifdef BLEND\n    dist = blendSDF(dist, plane, BLEND_AMOUNT);\n    #else\n    dist = addSDF(dist, plane);\n    #endif\n    \n    return dist;\n}\n\nvec3 getNormal(in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t    map(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t    map(pos+eps.yyx).d - map(pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\nSDFRes castRay(in vec3 ro, in vec3 rd, in float tmin)\n{    \n    float tmax = 20.0;    \n    \n    SDFRes p;\n    p.d = tmin;\n    p.m = 0.0;\n    p.m2 = 0.0;\n    p.b = 0.0;\n    \n\tfloat precis = 0.000001;\n    \n    for (int i=0; i<50; i++)\n    {\n        SDFRes s = map( ro + rd * p.d );\n        if (s.d < precis || s.d > tmax)\n        {\n            break;\n        }\n        \n        p.m = s.m;\n        p.m2 = s.m2;\n        p.b = s.b;\n        p.d += s.d;\n    }\n    \n    if (p.d > tmax)\n        p.m = -1.0;\n    \n    return p;\n}\n\n\nfloat shadows(in vec3 ro, in vec3 rd, in float tmin)\n{\n    //return 1.0;\n    const float tmax = 20.0;\n    float res = 1.0;\n    float k = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<50; i++)\n    {\n        SDFRes h = map(ro + rd*t);\n        if( h.d<0.0001 )\n            return 0.0;\n        if (t > tmax)\n            return res;\n        \n        res = min( res, k*h.d/t );\n        t += h.d;\n    }\n    return res;\n}\n\nfloat occlusion(in vec3 ro, in vec3 rd)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  rd * hr + ro;\n        float dd = map( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvoid getMaterialData(in float m, in vec3 pos, in vec3 nor, inout vec3 col, inout float spow )\n{\n    col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    spow = 256.0;\n    \n    if ( m < 100.0 )\n        spow = 2.0;\n    \n    if( m<1.5 && m != 0.0 )\n    {\n        pos.x += sin(pos.z);\n        pos.z += cos(pos.x);\n        float f = mod( floor(2.0*pos.z) + floor(2.0*pos.x), 2.0);\n        col = 0.4 + 0.1*f*vec3(1.0);\n        spow = 32.0 + 240.0 * (1.0 - f);\n        \n    }\n    \n    // 200, 245, 240\n}\n\nvec3 getColour(in vec3 ro, in vec3 rd, in float tmin)\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;  \n    vec3 lig = normalize( vec3(0.6, 0.5, 0.7) );\n    \n    SDFRes ray = castRay(ro, rd, tmin);\n    float t = ray.d;\n    float m = ray.m;\n    float m2 = ray.m2;\n    float b = ray.b;\n    float spow = 128.0;\n\n    if( m >-0.5 )\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = getNormal(pos);\n        vec3 ref = reflect( rd, nor );\n\n        getMaterialData(m, pos, nor, col, spow);\n        vec3 col2;\n        float spow2;\n        getMaterialData(m2, pos, nor, col2, spow2);\n        \n        #ifdef VIEW_SECOND_COL\n        col = col2;\n        #endif\n        \n        col = mix(col, col2, b);\n        spow = mix(spow, spow2, b);\n        \n        #ifdef VIEW_BLEND\n        col = mix(vec3(col), vec3(0.0, 1.0, 0.0), b*2.0);\n        #endif\n\n        float dif = saturate(dot(nor, lig));\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),spow);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n\n        float shadow = shadows(pos, lig, 0.1);\n        float occ = occlusion(pos, nor);\n\n        dif *= shadow;\n        dom *= shadows(pos, nor, 0.01);\n\n        vec3 lin = vec3(0.0);\n        lin += dif;\n        lin += spe*dif*occ;\n        lin += fre*0.3*occ;\n        lin += amb*0.3*occ;\n        lin += dom*0.1*occ;\n\n        col = col * lin;\n    }    \n    \n    return vec3(col);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd )\n{\n    return getColour(ro, rd, 0.1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = 15.0 + iTime;\n    \n    // camera\t\n\tvec3 ro = vec3( -0.5+4.5*cos(0.1*time + 6.0*mo.x), \n                    2.0 + 1.0*mo.y, \n                    0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n    \n    mat3 camera = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = camera * normalize( vec3(p.xy, 2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) ); // gamma\n\n    fragColor=vec4( col, 1.0 );    \n    \n}","name":"Image","description":"","type":"image"}]}