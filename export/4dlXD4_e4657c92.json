{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\nconst float PI = 3.14159265358979323846264;\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n// IQ's value noise function\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// generates noise in range -1 to 1\nfloat fractalnoise (in vec2 uv)\n{\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise( uv ); uv = m*uv;\n\tf = 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\treturn f;\n}\n\n\n\n// -----------------------------------------------\n\n\n\nfloat concentricbands(vec2 muv, vec2 noisevar)\n{\t\n\tfloat mdist = length(muv);\n\t\n\tfloat bandsize = 0.2;\n\tvec2 variation = vec2(sin(iTime*noisevar.x)*bandsize*0.2, cos(iTime*noisevar.y)*bandsize*0.2);\n\tfloat noise = fractalnoise(muv + variation) * bandsize * 0.7;\n\tfloat band = mod (mdist, bandsize + noise );\n\treturn band;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rectuv has coords (0 to 1, 0 to 1)\n    vec2 rectuv = fragCoord.xy / iResolution.xy;\n\t// uv has coords (width/height * 0 to 1, 0 to 1)\n\tvec2 uv = rectuv*vec2(iResolution.x/iResolution.y,1.0);\n\trectuv;\n\t// mid origin vect uv\n\tvec2 mrectuv = 2.0 *( rectuv - 0.5);\n\t// mid origin square uv\n\tvec2 muv = mrectuv * vec2 (iResolution.x/iResolution.y, 1.0);\n\t\n\tfloat vis1 = max(0.0,sin(iTime * 1.0 + PI));\n\tvec2 offset1 = vec2(sin(iTime/10.0 + PI), cos(iTime/10.0 + PI));\n\tfloat layer1 = concentricbands(muv + offset1, vec2(1.232, 1));\n\t\n\tfloat vis2 = max(0.0,sin(iTime * 1.22));\n\tvec2 offset2 = vec2(sin(iTime/9.0),cos(iTime/9.0));\n\tfloat layer2 = concentricbands(muv + offset2 , vec2(1.123, 1.222));\n\n\tfloat result = mix(0.0,layer1,vis1)+mix(0.0,layer2,vis2);\n\n\tfragColor = vec4(result,result,result,1.0 );\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dlXD4","date":"1402320103","viewed":175,"name":"Glimpses of Companionship","username":"keshi","description":"Moving concentric not quite circular patterns","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise"],"hasliked":0,"parentid":"","parentname":""}}