{"ver":"0.1","info":{"id":"NlSBRt","date":"1652561351","viewed":165,"name":"Sphereflake_v1","username":"perushinkov","description":"Thanking Inigo for the SDF Ray marcher. Adapted from me following an Inigo Quilez tutorial.\nsdfSphereFlake formulas are from me.\nFeel free to make derivatives!\n\n\n\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sphereflake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\nSDF Ray marcher is adapted from me following an Inigo Quilez tutorial.\nThank you Inigo for inspiring me!\n\nsdfSphereFlake formulas are from me.\n\ncode/perf are far from optimized! Feel free to suggest rewrites!\n\n\nFeel free to play around with the rotators at lines 267, 268\n*/\nfloat PI = 3.141592653;\nfloat MAX_CARE_DISTANCE = 20.0;\nint FRACTAL_ITERATIONS = 5;\n\nvec4 sdfSphereFlake(in vec3 pt, in float radius) {\n    // centre of starting sphere\n    vec3 ptO, ptO_next, ptO_saved;\n    // normalized vector for UP direction\n    vec3 dirUp, dirUp_next, dirUp_saved;\n    // normalized vector for equator phase\n    vec3 dirEqPhase, dirEqPhase_next, dirEqPhase_saved;\n    // scale factor determining sphere size\n    float scale, scale_next;\n    // temp var named after the famous right hand rule\n    vec3 middleFinger;\n\n    // set initial values\n    ptO = vec3(0.,0.,0.);\n    dirUp = vec3(0.,1.,0.);\n    dirEqPhase = vec3(1.,0.,0.);\n    scale = radius;\n    middleFinger = normalize(cross(dirUp, dirEqPhase));\n\n    // set values that need to be calculated as we \"recurse\" down the sphere flake fractal\n    int iterations = 0;\n    float lowestDistance = length(pt) - radius;\n    int chosenIteration = 0;\n    float distanceChild;\n    float lowestDistanceChild;\n\n    while(iterations < FRACTAL_ITERATIONS && lowestDistance > 0.) {\n        scale_next = scale / 3.;\n        lowestDistanceChild = MAX_CARE_DISTANCE;\n        // child 1:\n        dirUp_next = dirEqPhase;\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = -dirUp;\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n\n        // child 2:\n        dirUp_next = -dirEqPhase;\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = -dirUp;\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n\n        // child 3:\n        dirUp_next = normalize(0.5 * dirEqPhase + 0.5 * sqrt(3.) * middleFinger);\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = -dirUp;\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n\n        // child 4:\n        dirUp_next = normalize(0.5 * dirEqPhase - 0.5 * sqrt(3.) * middleFinger);\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = -dirUp;\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n\n\n        // child 5:\n        dirUp_next = normalize( - 0.5 * dirEqPhase + 0.5 * sqrt(3.) * middleFinger);\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = -dirUp;\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n\n        // child 6:\n        dirUp_next = normalize(- 0.5 * dirEqPhase - 0.5 * sqrt(3.) * middleFinger);\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = -dirUp;\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n\n        // child 7:\n        dirUp_next = normalize(-middleFinger + sqrt(3.) * dirUp);\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = normalize(dirUp - 0.5 * sqrt(3.) * dirUp_next);\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n        // child 8:\n        dirUp_next = normalize(0.5 * sqrt(3.) * dirEqPhase + 0.5 * middleFinger + sqrt(3.) * dirUp);\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = normalize(dirUp - 0.5 * sqrt(3.) * dirUp_next);\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n        // child 9:\n        dirUp_next = normalize(- 0.5 * sqrt(3.) * dirEqPhase + 0.5 * middleFinger + sqrt(3.) * dirUp);\n        ptO_next = ptO + dirUp_next * scale * (4./3.);\n        dirEqPhase_next = normalize (dirUp - 0.5 * sqrt(3.) * dirUp_next);\n\n        distanceChild = length(ptO_next - pt) - scale_next;\n\n        if (lowestDistanceChild > distanceChild) {\n            lowestDistanceChild = distanceChild;\n\n            // save the subsphere\n            dirUp_saved = dirUp_next;\n            dirEqPhase_saved = dirEqPhase_next;\n            ptO_saved = ptO_next;\n        }\n\n\n        if (iterations == 0) {\n            // child 10:\n            dirUp_next = normalize(-middleFinger - sqrt(3.) * dirUp);\n            ptO_next = ptO + dirUp_next * scale * (4./3.);\n            dirEqPhase_next = normalize(- dirUp - 0.5 * sqrt(3.) * dirUp_next);\n\n            distanceChild = length(ptO_next - pt) - scale_next;\n\n            if (lowestDistanceChild > distanceChild) {\n                lowestDistanceChild = distanceChild;\n\n                // save the subsphere\n                dirUp_saved = dirUp_next;\n                dirEqPhase_saved = dirEqPhase_next;\n                ptO_saved = ptO_next;\n            }\n            // child 11:\n            dirUp_next = normalize(0.5 * sqrt(3.) * dirEqPhase + 0.5 * middleFinger - sqrt(3.) * dirUp);\n            ptO_next = ptO + dirUp_next * scale * (4./3.);\n            dirEqPhase_next = normalize(-dirUp - 0.5 * sqrt(3.) * dirUp_next);\n\n            distanceChild = length(ptO_next - pt) - scale_next;\n\n            if (lowestDistanceChild > distanceChild) {\n                lowestDistanceChild = distanceChild;\n\n                // save the subsphere\n                dirUp_saved = dirUp_next;\n                dirEqPhase_saved = dirEqPhase_next;\n                ptO_saved = ptO_next;\n            }\n            // child 12:\n            dirUp_next = normalize(- 0.5 * sqrt(3.) * dirEqPhase + 0.5 * middleFinger - sqrt(3.) * dirUp);\n            ptO_next = ptO + dirUp_next * scale * (4./3.);\n            dirEqPhase_next = normalize (-dirUp - 0.5 * sqrt(3.) * dirUp_next);\n\n            distanceChild = length(ptO_next - pt) - scale_next;\n\n            if (lowestDistanceChild > distanceChild) {\n                lowestDistanceChild = distanceChild;\n\n                // save the subsphere\n                dirUp_saved = dirUp_next;\n                dirEqPhase_saved = dirEqPhase_next;\n                ptO_saved = ptO_next;\n            }\n\n        }\n\n        if (lowestDistanceChild < lowestDistance) {\n            chosenIteration = iterations;\n            lowestDistance = lowestDistanceChild;\n        } else if (lowestDistanceChild - lowestDistance > 0.5 * scale - scale_next) {\n            break;\n        }\n\n        dirUp = dirUp_saved;\n        dirEqPhase = dirEqPhase_saved;\n        ptO = ptO_saved;\n\n        iterations++;\n        scale = scale_next;\n        middleFinger = normalize(cross(dirUp, dirEqPhase));\n\n    }\n    // Each color is a sine-wave with a period of one. Red/Green/Blue have different peaks to ensure each colour is interesting\n    return vec4(lowestDistance, vec3(\n        sin((-float(chosenIteration) * 0.1 - 0.25 + iTime*0.1) * 2.*PI) * 0.5 + 0.5,\n        sin((-float(chosenIteration) * 0.1 - 0.25 + 0.33 + iTime*0.1) * 2.*PI) * 0.5 + 0.5,\n        sin((-float(chosenIteration) * 0.1 - 0.25 + 0.66+ iTime*0.1) * 2.*PI) * 0.5 + 0.5\n    ));\n}\n\nvec4 map(in vec3 pos)\n{\n\n\n    // rotation around y axis over time\n    float rotAngle1 = iTime*0.15;\n    float rotAngle2 = iTime*0.2;\n    mat2 rotMatrix1 = mat2(\n    vec2(cos(rotAngle1),-sin(rotAngle1)),\n    vec2(sin(rotAngle1),cos(rotAngle1))\n    );\n    mat2 rotMatrix2 = mat2(\n    vec2(cos(rotAngle2),-sin(rotAngle2)),\n    vec2(sin(rotAngle2),cos(rotAngle2))\n    );\n    pos.xz = pos.xz * rotMatrix1;\n    pos.xy = pos.xy * rotMatrix2;\n\n    return //min(\n    //sdfGround(pos, -1.),\n    sdfSphereFlake(pos, 0.2)\n    //)\n    ;\n}\n// calc surface normal... or gradient ascent vector\n// The reason we go for gradient ascent instead of gradient descent is that at the surface of an SDF defined object,\n// the surface normal should point outside of the object, and not inside (for lighting purposes)\nvec3 calcNormal(in vec3 pt) {\n    // this constant determines the size of the area over which the gradient is determined\n    // and it's a vector because it's easy to transform into VAL,0,0  or 0,VAL,0 or 0,0,VAL as seen below\n    vec2 epsilon = vec2(0.000001,0.0);\n    // over each axis the gradient descent vector should be positive if lower values\n    return normalize(vec3(\n    map(pt + epsilon.xyy).x - map(pt - epsilon.xyy).x,\n    map(pt + epsilon.yxy).x - map(pt - epsilon.yxy).x,\n    map(pt + epsilon.yyx).x - map(pt - epsilon.yyx).x\n    ));\n}\n\n\nvec3 getColour(in vec3 surfacePoint) {\n    // sun direction here is direction to sun, not direction from sun\n    vec3 sunDir = normalize(vec3(0.8,0.4,0.2));\n    vec3 surfaceNormal = calcNormal(surfacePoint);\n\n    vec3 UP = vec3(0., 1., 0.);\n\n    vec3 baseColour = map(surfacePoint).yzw;\n    vec3 skyColour = vec3(0.6,0.93,1.0);\n\n\n    // Here we assume sunlight is not coloured\n    float sunPart = clamp(dot(surfaceNormal, sunDir), 0., 1.);\n    float skyPart = clamp(0.5 + 0.5 * dot(surfaceNormal, UP), 0., 1.);\n\n    return sunPart * baseColour + 0.3 * skyPart * skyColour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // ray origin (where the camera is)\n    vec3 rayOrigin = vec3(0.0, sin(0.2*iTime) * 0.2, 1.4);\n    // ray direction (in the cone of the camera we make sure the ray passes through the pixels of the viewport at some distance away from the ray)\n    // it is negative because the camera looks in the opposite direction of where it is placed (i.e. it faces the origin)\n    vec3 rayDirection = normalize(vec3(p,(-5.1 - 1.4 * sin(0.3 * iTime))));\n\n    // ray marching\n    float minDist = 0.2;\n    float distanceMarched=minDist;\n    float maxDist =100.0;\n    vec3 rayEnd;\n    for (int i = 0; i<90; i++) {\n        rayEnd = rayOrigin + distanceMarched * rayDirection;\n\n        float distanceToNearest = map(rayEnd).x;\n        if (distanceToNearest<0.0002)\n        break;\n\n        distanceMarched += distanceToNearest;\n        // max distance we march the ray... we don't care for points beyond.\n\n        if (distanceMarched > maxDist) break;\n    }\n    vec3 col;\n    if (distanceMarched<maxDist) {\n        // object\n        col = getColour(rayEnd);\n    } else {\n        // background\n        col = vec3(.1,.2,.4);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}