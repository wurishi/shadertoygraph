{"ver":"0.1","info":{"id":"XclcDl","date":"1721783001","viewed":38,"name":"PLATFORM","username":"netfetti","description":"ever evolving platform and spheres","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["color","geometry","blendingshapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene(vec3 p) {\n    float t = iTime * 0.5;\n    \n    // Rotate the entire scene\n    p.xz *= rot(t * 0.3);\n    p.yz *= rot(sin(t * 0.2) * 0.5);\n    \n    // Create multiple spheres\n    float spheres = 9999.;\n    for(int i = 0; i < 5; i++) {\n        vec3 sp = p;\n        sp.x += sin(t + float(i) * 1.5) * 3.;\n        sp.y += cos(t * 0.7 + float(i) * 1.2) * 2.;\n        sp.z += sin(t * 0.5 + float(i) * 0.9) * 2.5;\n        float s = sdSphere(sp, 0.7 + 0.3 * sin(t + float(i)));\n        spheres = smin(spheres, s, 1.);\n    }\n    \n    // Add a warped box\n    vec3 bp = p;\n    bp.xz *= rot(t * 0.8);\n    float box = sdBox(bp, vec3(2.5, 0.1, 2.5));\n    box += 0.1 * sin(5. * p.x + t) * sin(5. * p.y + t) * sin(5. * p.z + t);\n    \n    // Combine shapes\n    return smin(spheres, box, 0.5);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = scene(p) - vec3(\n        scene(p-e.xyy),\n        scene(p-e.yxy),\n        scene(p-e.yyx));\n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = scene(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 render(vec2 uv) {\n    vec3 ro = vec3(0, 0, -5);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 col = vec3(0);\n    \n    if(d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        vec3 lightPos = vec3(sin(iTime) * 4., 3, cos(iTime) * 4.);\n        vec3 l = normalize(lightPos - p);\n        \n        float diff = max(dot(n, l), 0.);\n        float spec = pow(max(dot(reflect(-l, n), -rd), 0.), 32.);\n        \n        // Dynamic color based on position and time\n        vec3 objCol = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0,2,4));\n        \n        col = objCol * diff + vec3(0.8) * spec;\n        \n        // Add rim lighting\n        float rim = 1. - max(dot(n, -rd), 0.);\n        rim = smoothstep(0.5, 1., rim);\n        col += objCol * rim * 0.5;\n        \n        // Fake ambient occlusion\n        float ao = 1. - smoothstep(0., 1.5, scene(p + n * 0.5));\n        col *= 1. - ao * 0.5;\n    }\n    \n    // Fog\n    col = mix(col, vec3(0.1, 0.11, 0.13), smoothstep(0., 15., d));\n    \n    // Contrast and saturation adjustment\n    col = pow(col, vec3(0.8));  // Increase contrast\n    float luminance = dot(col, vec3(0.299, 0.587, 0.114));\n    col = mix(vec3(luminance), col, 1.5);  // Increase saturation\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Anti-aliasing\n    vec3 col = vec3(0);\n    for(int i = 0; i < 4; i++) {\n        vec2 offset = (vec2(hash21(uv + float(i)), hash21(uv + float(i) + 0.1)) * 2. - 1.) / iResolution.xy;\n        col += render(uv + offset);\n    }\n    col /= 4.;\n    \n    // Tone mapping\n    col = col / (1. + col);\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}