{"ver":"0.1","info":{"id":"ct3fD2","date":"1701584123","viewed":113,"name":"fireworks in space","username":"nayk","description":"particles, fireworks, timing,fbm, stars,new,space,copypast","likes":2,"published":1,"flags":1,"usePreview":0,"tags":["fbm","space","particles","stars","new","fireworks","timing","copypast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/4d3SzX https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/wslcWN*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nvec2 computeUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n    nUv.y = 1. - nUv.y;\n \n    return nUv;\n    \n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n\t\ta*=a*a; \n\t\tif (r>6) fade*=1.1; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\n\nvec2 GetOffsetFromCenter(vec2 screenCoords, vec2 screenSize)\n{\n    vec2 halfScreenSize = screenSize / 2.0;\n    \n\treturn (screenCoords.xy - halfScreenSize) / min(halfScreenSize.x, halfScreenSize.y);\n}\n\n\nfloat EffectDuration = 1.0;\nfloat EffectFadeInTimeFactor = 0.5;\nfloat EffectWidth = 0.4;\nfloat EffectMaxTexelOffset = 20.0;\n\nvec2 GetDistortionTexelOffset(vec2 offsetDirection, float offsetDistance, float time)\n{\n    float progress = mod(time, EffectDuration) / EffectDuration;\n    \n    float halfWidth = EffectWidth / 2.0;\n    float lower = 1.0 - smoothstep(progress - halfWidth, progress, offsetDistance);\n    float upper = smoothstep(progress, progress + halfWidth, offsetDistance);\n    \n    float band = 1.0 - (upper + lower);\n    \n    \n    float strength = 1.0 - progress;\n    float fadeStrength = smoothstep(0.0, EffectFadeInTimeFactor, progress);\n    \n    float distortion = band * strength * fadeStrength;\n    \n    \n    return distortion * offsetDirection * EffectMaxTexelOffset;\n}\n\n\nvec3 GetTextureOffset(vec2 coords, vec2 textureSize, vec2 texelOffset)\n{\n    vec2 texelSize = 1.0 / textureSize;\n    vec2 offsetCoords = coords + texelSize * texelOffset;\n    \n    vec2 halfTexelSize = texelSize / 2.0;\n    vec2 clampedOffsetCoords = clamp(offsetCoords, halfTexelSize, 1.0 - halfTexelSize);\n    \n    return texture(iChannel0, clampedOffsetCoords).rgb;\n}\n\nmat2 rotationMatrix(float angle)\n{\nangle *= 3.14 / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, s, -s, c );\n}\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\n#define NORM_FOCUS (1)\n\nfloat random(float x) \n{ \n    return fract(sin(x) * 10000.);          \n}\n\nfloat noise(vec2 p) \n{\n    return random(p.x + p.y * 10000.);            \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) \n{\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);        \n}\n\nfloat fractalNoise(vec2 p) \n{\n    float x = 0.;\n    x += smoothNoise(p      );\n    x += smoothNoise(p * 2. ) / 2.;\n    x += smoothNoise(p * 4. ) / 4.;\n    x += smoothNoise(p * 8. ) / 8.;\n    x += smoothNoise(p * 16.) / 16.;\n    x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return x;            \n}\n\nfloat movingNoise(vec2 p) \n{ \n    float x = fractalNoise(p + iTime);\n    float y = fractalNoise(p - iTime);\n    return fractalNoise(p + vec2(x, y));    \n}\n\nfloat nestedNoise(vec2 p) \n{    \n    float x = movingNoise(p);\n    float y = movingNoise(p + 100.);\n    return movingNoise(p + vec2(x, y));    \n}\n#define SPARKS 30\n#define FIREWORKS 8.\n#define BASE_PAUSE FIREWORKS / 30.\n#define PI 3.14\n#define PI2 6.28\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 randomSpark(float noise) {\n    vec2 v0 = vec2((noise - .5) * 13., (fract(noise * 123.) - .5) * 15.);\n    return v0;\n}\n\nvec2 circularSpark(float i, float noiseId, float noiseSpark) {\n    noiseId = fract(noiseId * 7897654.45);\n    float a = (PI2 / float(SPARKS)) * i;\n    float speed2 = 10.*clamp(noiseId, .7, 1.);\n    float x = sin(a + iTime*((noiseId-.5)*3.));\n    float y = cos(a + iTime*(fract(noiseId*4567.332) - .5)*2.);\n    vec2 v0 = vec2(x, y) * speed2;\n    return v0;\n}\n\n\nvec2 rocket(vec2 start, float t) {\n    float y = t;\n    float x = sin(y*10.+cos(t*3.))*.1;\n    vec2 p = start + vec2(x, y * 8.);\n    return p;\n}\n\nvec3 firework(vec2 uv, float index, float pauseTime) {\n    vec3 col = vec3(0.);\n\n\n    float timeScale = 1.;\n    vec2 gravity = vec2(0., -9.8);\n\n    float explodeTime = .9;\n    float rocketTime = 1.1;\n    float episodeTime = rocketTime + explodeTime + pauseTime;\n\n    float ratio = iResolution.x / iResolution.y;\n\n    float timeScaled = (iTime - pauseTime) / timeScale;\n\n    float id = floor(timeScaled / episodeTime);\n    float et = mod(timeScaled, episodeTime);\n\n    float noiseId = n21(vec2(id+1., index+1.));\n\n    float scale = clamp(fract(noiseId*567.53)*30., 10., 30.);\n    uv *= scale;\n\n    rocketTime -= (fract(noiseId*1234.543) * .5);\n\n    vec2 pRocket = rocket(vec2(0. + ((noiseId - .5)*scale*ratio), 0. - scale/2.), clamp(et, 0., rocketTime));\n\n    if (et < rocketTime) {\n        float rd = length(uv - pRocket);\n        col += pow(.05/rd , 1.9) * vec3(0.9, .3, .0);\n    }\n\n\n    if (et > rocketTime && et < (rocketTime + explodeTime)) {\n        float burst = sign(fract(noiseId*44432.22) - .6);\n        for(int i = 0 ; i < SPARKS ; i++) {\n                vec2 center = pRocket;\n                float fi = float(i);\n                float noiseSpark = fract(n21(vec2(id*10.+index*20., float(i+1))) * 332.44);\n                float t = et - rocketTime;\n                vec2 v0;\n\n                if (fract(noiseId*3532.33) > .5) {\n                    v0 = randomSpark(noiseSpark);\n                    t -= noiseSpark * (fract(noiseId*543.) * .2);\n                } else {\n                    v0 = circularSpark(fi, noiseId, noiseSpark);\n\n                    if ( (fract(noiseId*973.22) - .5) > 0.) {\n                        float re = mod(fi, 4. + 10. * noiseId);\n                        t -= floor(re/2.) * burst * .1;\n                    } else {\n                        t -= mod(fi, 2.) == 0. ? 0. : burst * .5*clamp(noiseId, .3, 1.);\n                    }\n                }\n\n                vec2 s = v0*t + (gravity * t * t) / 2.;\n\n                vec2 p = center + s;\n\n                float d = length(uv - p);\n\n                if (t > 0.) {\n                    float fade = clamp((1. - t/explodeTime), 0., 1.);\n                    vec3 sparkColor = vec3(noiseId*.9, .5*fract(noiseId *456.33), .5*fract(noiseId *1456.33));\n                    vec3 c = (.05 / d) * sparkColor;\n                    col += c * fade;\n                }\n            }\n    }\n\n\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-0.5;\n\t    float k = 1.0 * sin( iTime * .9 );\n    float kcube = 1.5 * sin( iTime );\n     \n    vec2 screenCoords = fragCoord.xy;\n    vec2 screenSize = iResolution.xy;\n     float time2 = iTime*0.1;\n    float offset = .01 * sin( iTime * .05 );\n   vec2 offsetFromCenter = GetOffsetFromCenter(screenCoords, screenSize);\n    vec2 offsetDirection = normalize(-offsetFromCenter);\n    float offsetDistance = length(offsetFromCenter);\n  float t = iTime * .1 + ((.25 + .05 * sin(iTime * 1.1))/(length(uv.xy) + .012)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);  \n     vec3 col = vec3(0.);\n\n    for (float i = 0. ; i < FIREWORKS ; i += 1.) {\n        col += firework(uv*ma, i + 1., (i * BASE_PAUSE));\n    }\n\n    vec2 offset2 = GetDistortionTexelOffset(offsetDirection, offsetDistance, time2);\n  uv.x *= iResolution.x / iResolution.y;\n    \n        float n = nestedNoise(uv * 2.) * 1.0;\n    float lerp = (sin(iTime * 0.05) + 1.1) / 2.0;\n    float offset3 = mix(1.0, 3.2, lerp);\n    \n   \n    \tvec2 offsetVector = normalize(vec2(0.5, 0.5) - uv) * (n * offset3);\n  \n    \t\n\n\n\nuv.xy*=offsetVector*ma;\n\n\tvec3 dir=vec3(uv,1.);\n\tfloat time=iTime*speed+.25;\n\n  uv.x *= iResolution.x / iResolution.y;\n    \n    float dist = sqrt(abs(1.0-dot(uv,uv)));\n    \n    //vec3 col = vec3(dist);\n    vec3 col2 = texture(iChannel0, iTime/10.0 + dir.xy/dist).rgb*(0.3 + dist*0.7);\n\n   \n    \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = cos(iTime * 2.0) * 0.1 + 1.0;    \n\n   dir.xy*=ma;\n    vec2 coords = (fragCoord.xy / screenSize);\n    coords.y = 1.0 - coords.y;\n\n\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n   \n\t\n\n\tmainVR(fragColor, fragCoord, from, dir);\n      fragColor*= vec4(cheap_star(uv,anim) * vec3(0.55,0.5,0.55), 1.0);\n      fragColor+= vec4(col,1.);\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}