{"ver":"0.1","info":{"id":"3dtcWH","date":"1600866768","viewed":77,"name":"fast-noise-v2","username":"jorge2017a1","description":"fast-noise-v2","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fastnoisev2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//desconocido autor\n// 00f404afdd835ac3af3602c8943738ea - please mark changes (and/or add docs), and retain this line.\n\nfloat _MinStep = 0.125;\n\n//////////////////////////////////////////////////////////////\n// http://www.gamedev.net/topic/502913-fast-computed-noise/\n// replaced costly cos with z^2. fullreset\nvec4 random4 (const vec4 x) {\n    vec4 z = mod(mod(x, vec4(5612.0)), vec4(3.1415927 * 2.0));\n    return fract ((z*z) * vec4(56812.5453));\n}\nconst float A = 1.0;\nconst float B = 57.0;\nconst float C = 113.0;\nconst vec3 ABC = vec3(A, B, C);\nconst vec4 A3 = vec4(0, B, C, C+B);\nconst vec4 A4 = vec4(A, A+B, C+A, C+A+B);\nfloat cnoise4 (const in vec3 xx) {\n    vec3 x = xx; // mod(xx + 32768.0, 65536.0); // ignore edge issue\n    vec3 fx = fract(x);\n    vec3 ix = x-fx;\n    vec3 wx = fx*fx*(3.0-2.0*fx);\n    float nn = dot(ix, ABC);\n\n    vec4 N1 = nn + A3;\n    vec4 N2 = nn + A4;\n    vec4 R1 = random4(N1);\n    vec4 R2 = random4(N2);\n    vec4 R = mix(R1, R2, wx.x);\n    float re = mix(mix(R.x, R.y, wx.y), mix(R.z, R.w, wx.y), wx.z);\n\n    return 1.0 - 2.0 * re;\n}\n\n//////////////////////////////////////////////////////////////\n// distance functions\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\nfloat udBox( vec3 p, vec3 b ) {  return length(max(abs(p)-b,0.0)); }\nfloat udRoundBox( vec3 p, vec3 b, float r ) { return length(max(abs(p)-b,0.0))-r; }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nvec3  opRep(vec3 p, vec3 r) { return mod(p,r)-0.5*r; }\nvec3  opTx(vec3 p, mat4 m ) { return (m*vec4(p,1.0)).xyz; }\nfloat cyl(vec3 p, float r, float c) { return max(length(p.xz)-r, abs(p.y)-c); }\n/////////////////////////////////////////////////////\n// the rest\n\nfloat fbm(vec3 p) {\n float N = 0.0;\n  float D = 0.0;\n  int i=0;\n  float R = 0.0;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n//  D += (R = 1.0/pow(2.0,float(i+1))); N = cnoise4(p*pow(2.0,float(i)))*R + N; i+=1;\n  return N/D;\n}\n\nfloat scene(vec3 p) {\n  float n = fbm(iTime + p);\n  vec3 pw = vec3(0.,0.,10.);\n  float pa = udRoundBox(p+pw,vec3(100.,5.,500.),0.22) + .5 *  n;\n  float d = pa;\n\n  vec3 c = opRep(p,vec3(20.,4.5,14.))-vec3(0.,0.,7.);\n  d = min(d,cyl(c+pw+vec3(0.,0.,-3.),2.,2.5));//udRoundBox(c+pw+vec3(0.,0.0,-3.),vec3(1.75,2.,0.75),0.1));\n\n  float e = udRoundBox(p-vec3(0.,30.,4.),vec3(100.,0.1,0.1),0.1);\n  \n  n = fbm(p);  \t\n  return min(e,sin(p.x * 5.)*.15+cos(p.z * 5.)*.15+n*0.215+d); // 'texture'\n}\n\nvec4 color(float d) { \n  return mix(vec4(1.,1.,1.,0.25),vec4(.2,.2,.2,0.1),smoothstep(0.,0.1,d)); \n}\n\nvec4 ray(vec3 pos, vec3 step) {\n    vec4 sum = vec4(0.);\n    vec4 col;\n    float d = 9999.0;\n#define RAY1  { d = scene(pos); col = color(d); col.rgb *= col.a; sum += col*(1.0 - sum.a); pos += step*max(d,_MinStep); }\n#define RAY4  RAY1 RAY1 RAY1 RAY1\n    RAY4 RAY4 RAY4 RAY4\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 e = vec3(sin(iTime*0.2)*20.,12.,-20.); \n  vec3 p = vec3((fragCoord.xy / iResolution.xy) * 2. -1., 1.);\n  p.x *= iResolution.x/iResolution.y;\n  p += e;\n  fragColor = ray(p, normalize(p-e));\n}","name":"Image","description":"","type":"image"}]}