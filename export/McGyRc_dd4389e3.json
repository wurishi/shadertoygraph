{"ver":"0.1","info":{"id":"McGyRc","date":"1732149072","viewed":108,"name":"Pathtracer From iPhone","username":"pg_dev","description":"A simple pathtracer I made on my phone!","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["3d","lighting","pathtracer","iphone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 finalColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(linearToSRGB(finalColor.xyz / finalColor.w), finalColor.w);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray {\n    vec3 orig;\n    vec3 dir;\n    float t;\n};\n\nmat4 createCameraMatrix(vec3 position, vec3 rotation) {\n\tmat4 camRotationXMat = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(rotation.x), -sin(rotation.x), 0.0, 0.0, sin(rotation.x), cos(rotation.x), 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camRotationYMat = mat4(cos(rotation.y), 0.0, sin(rotation.y), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(rotation.y), 0.0, cos(rotation.y), 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camRotationZMat = mat4(cos(rotation.z), -sin(rotation.z), 0.0, 0.0, sin(rotation.z), cos(rotation.z), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camPosMat = mat4(1.0, 0.0, 0.0, position.x, 0.0, 1.0, 0.0, position.y, 0.0, 0.0, 1.0, position.z, 0.0, 0.0, 0.0, 1.0);\n\n\treturn camPosMat * ((camRotationZMat * camRotationYMat) * camRotationXMat);\n}\n\nstruct Material {\n    vec3 diffuseCol;\n    float specular;\n    vec3 specularCol;\n    float specularRoughness;\n    float IOR;\n};\n\nMaterial getBaseMaterial() {\n    Material mat;\n    mat.diffuseCol = vec3(0.95);\n    mat.specular = 0.0;\n    mat.specularCol = vec3(0.95);\n    mat.specularRoughness = 0.0;\n    mat.IOR = 1.0;\n    return mat;\n}\n\nstruct Object {\n    // Sphere\n    vec3 position;\n    vec3 position_2;\n    float radius;\n    \n    // Triangle\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n    vec3 v0_2;\n    vec3 v1_2;\n    vec3 v2_2;\n    bool isDoubleSided;\n    \n    // Both\n    Material material;\n    bool isMoving;\n};\n\nObject makeSphereObj(vec3 position, float radius, Material material) {\n    Object sO;\n    sO.position = position;\n    sO.radius = radius;\n    sO.material = material;\n    return sO;\n}\n\nObject makeSphereObj(vec3 position, float radius, Material material, vec3 position_2) {\n    Object sO;\n    sO.position = position;\n    sO.position_2 = position_2;\n    sO.isMoving = true;\n    sO.radius = radius;\n    sO.material = material;\n    return sO;\n}\n\nObject makeTriangleObj(vec3 v0, vec3 v1, vec3 v2, Material material) {\n    Object tO;\n    tO.v0 = v0;\n    tO.v1 = v1;\n    tO.v2 = v2;\n    tO.material = material;\n    tO.isDoubleSided = true;\n    return tO;\n}\n\nObject makeTriangleObj(vec3 v0, vec3 v1, vec3 v2, Material material, vec3 v0_2, vec3 v1_2, vec3 v2_2) {\n    Object tO;\n    tO.v0 = v0;\n    tO.v1 = v1;\n    tO.v2 = v2;\n    tO.v0_2 = v0_2;\n    tO.v1_2 = v1_2;\n    tO.v2_2 = v2_2;\n    tO.isMoving = true;\n    tO.material = material;\n    tO.isDoubleSided = true;\n    return tO;\n}\n\nstruct HitInfo {\n    float t;\n    vec3 normal;\n    bool fromInside;\n    Material material;\n};\n\nvoid hitSphere(Ray r, Object sphere, inout HitInfo hitInfo) {\n    vec3 position = mix(sphere.position, sphere.position_2, r.t * float(sphere.isMoving));\n    \n    vec3 oc = r.orig - position;\n    float b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float discrim = b * b - c;\n\n    if (discrim < 0.0) return;\n\n    float sqrtDiscrim = sqrt(discrim);\n    float t1 = (-b - sqrtDiscrim);\n    float t2 = (-b + sqrtDiscrim);\n\n    bool fromInside = false;\n    float t = t1;\n    \n    if (t < 0.0) {\n        t = t2;\n        if (t < 0.0) return;\n        fromInside = true;\n    }\n\n    if (t > surfaceEpsilon && t < hitInfo.t) {\n        vec3 hitPoint = r.orig + t * r.dir;\n        vec3 normal = normalize(hitPoint - position) * (fromInside ? -1.0 : 1.0);\n\n        hitInfo.t = t;\n        hitInfo.normal = normal;\n        hitInfo.fromInside = fromInside;\n        hitInfo.material = sphere.material;\n    }\n}\n\nvoid hitTriangle(Ray r, Object triangle, inout HitInfo hitInfo) {\n    float mt = r.t * float(triangle.isMoving);\n\n    vec3 v0 = mix(triangle.v0, triangle.v0_2, mt);\n    vec3 v1 = mix(triangle.v1, triangle.v1_2, mt);\n    vec3 v2 = mix(triangle.v2, triangle.v2_2, mt);\n\n    vec3 v0v1 = v1 - v0;\n    vec3 v0v2 = v2 - v0;\n    vec3 normal = normalize(cross(v0v1, v0v2));\n\n    float normalDotRayDirection = dot(normal, r.dir);\n\n    if (normalDotRayDirection >= 0.0 && !triangle.isDoubleSided) return;\n\n    float d = -dot(normal, v0);\n    float t = -(dot(normal, r.orig) + d) / normalDotRayDirection;\n\n    if (t < surfaceEpsilon || t >= hitInfo.t) return;\n\n    vec3 p = r.orig + t * r.dir;\n\n    vec3 v0p = p - v0;\n    vec3 v2p = p - v2;\n    vec3 v1p = p - v1;\n\n    if (dot(normal, cross(v0v1, v0p)) < 0.0) return;\n    if (dot(normal, cross(v2 - v1, v1p)) < 0.0) return;\n    if (dot(normal, cross(v0 - v2, v2p)) < 0.0) return;\n\n    hitInfo.t = t;\n    hitInfo.material = triangle.material;\n    hitInfo.fromInside = false;\n    hitInfo.normal = (normalDotRayDirection > 0.0 ? -normal : normal);\n}\n\n/*vec3 getEnvLight(Ray r, vec3 rayColor) {\n    vec3 sunDirection = normalize(vec3(0.0, 1.0, 0.0)); // Sun overhead\n    vec3 sunColor = vec3(1.0, 0.95, 0.89); // Slightly warm sunlight\n    float sunIntensity = 30.0;\n\n    // Rayleigh scattering coefficients for RGB (precalibrated for a realistic sky)\n    vec3 rayleighCoefficients = vec3(5.5e-6, 1.35e-5, 3.31e-5) * 512.0;\n\n    // Mie scattering parameters\n    float mieCoefficient = 0.001; // Adjust for haziness\n    float mieG = 0.76; // Scattering asymmetry factor (near 1.0 for forward scattering)\n\n    // Angle between ray direction and sun\n    float cosTheta = dot(r.dir, sunDirection);\n\n    // Phase function for Rayleigh scattering (isotropic scattering)\n    float rayleighPhase = 3.0 / (16.0 * pi) * (1.0 + cosTheta * cosTheta);\n\n    // Phase function for Mie scattering (Henyey-Greenstein)\n    float miePhase = (1.0 - mieG * mieG) / pow(1.0 + mieG * mieG - 2.0 * mieG * cosTheta, 1.5);\n    miePhase *= 1.0 / (4.0 * pi);\n\n    // Optical depth approximation\n    float atmosphereHeight = 128.0; // Radius of the atmosphere shell\n    float atmosphereThickness = 16.0; // Effective scattering depth\n    float t = 1.0 - exp(-abs(r.dir.y) * atmosphereThickness);\n\n    // Rayleigh and Mie scattering contributions\n    vec3 rayleighScatter = rayleighPhase * rayleighCoefficients * exp(-t * rayleighCoefficients);\n    vec3 mieScatter = miePhase * vec3(mieCoefficient) * exp(-t * vec3(mieCoefficient));\n\n    // Sunlight contribution\n    float sunDisk = smoothstep(0.999, 1.0, cosTheta); // Soft edge for the sun\n    vec3 sunLight = sunDisk * sunColor * sunIntensity;\n\n    // Combine scattering and sunlight\n    return rayleighScatter * rayColor + mieScatter * rayColor + sunLight * rayColor;\n}*/\n\nfloat easeInOutCos(float t) {\n\treturn cos(pi * t) * -0.5 + 0.5;\n}\n\nvec3 getEnvLight(Ray r, vec3 rayColor) {\n    float t = r.dir.y;\n    vec3 skyHorizon = vec3(0.75, 1.0, 1.0);\n    vec3 skyZenith = vec3(0.5, 0.7, 1.0);\n    vec3 skyNadir = vec3(0.125, 0.25, 0.5);\n    \n    if (t >= 0.0) {\n        return mix(skyHorizon, skyZenith, easeInOutCos(t)) * rayColor;\n    }\n    \n    return mix(skyHorizon, skyNadir, easeInOutCos(abs(t)));\n}\n\nvoid hitScene(Ray r, inout HitInfo hitInfo) {\n    Material baseMat = getBaseMaterial();\n    Material orangeMat = baseMat;\n    orangeMat.diffuseCol = vec3(0.95, 0.0095, 0.0095);\n    orangeMat.specularCol = vec3(0.95, 0.95, 0.95);\n    orangeMat.specular = 0.125;\n\n    vec3 v0 = vec3(-128.0, 0.0, 128.0);\n    vec3 v1 = vec3(128.0, 0.0, 128.0);\n    vec3 v2 = vec3(128.0, 0.0, -128.0);\n    vec3 v3 = vec3(-128.0, 0.0, -128.0);\n\n    hitSphere(r, makeSphereObj(vec3(0.0, 16.0, 0.0), 16.0, orangeMat), hitInfo);\n    hitTriangle(r, makeTriangleObj(v0, v1, v2, baseMat), hitInfo);\n    hitTriangle(r, makeTriangleObj(v2, v3, v0, baseMat), hitInfo);\n}\n\nfloat fresnelReflectAmount(float n1, float n2, vec3 incident, vec3 normal, float f0, float f90) {\n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 *= r0;\n    float cosX = -dot(incident, normal);\n        \n    if (n1 > n2) {\n        float n = n1 / n2;\n        float sinT2 = n * n * (1.0 - cosX * cosX);\n            \n        if (sinT2 > 1.0) {\n            return f90;\n        }\n            \n        cosX = sqrt(1.0 - sinT2);\n    }\n        \n    float x = 1.0 - cosX;\n    float ret = r0 + (1.0 - r0) * x * x * x * x * x;\n \n    return mix(f0, f90, ret);\n}\n\nvec3 fireRay(Ray r, inout uint rngS) {\n    vec3 incomingLight = vec3(0.0, 0.0, 0.0);\n\tvec3 rayColor = vec3(1.0, 1.0, 1.0);\n\t\n\tfor (int i = 0; i <= maxRayBounces; i++) {\n\t    if (rayColor.x <= 0.0 && rayColor.y <= 0.0 && rayColor.z <= 0.0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\trngS += uint(i);\n\t\t\n\t\tHitInfo hitInfo;\n\t\thitInfo.t = maxDist + 1.0;\n\t\t\n\t\thitScene(r, hitInfo);\n\t\t\n\t\tif (hitInfo.t > maxDist) {\n            incomingLight += getEnvLight(r, rayColor);// * rayColor;\n\t\t    break;\n\t\t}\n        \n        float specularChance = hitInfo.material.specular;\n        \n        if (specularChance > 0.0) {\n            specularChance = fresnelReflectAmount(1.0, hitInfo.material.IOR, r.dir, hitInfo.normal, hitInfo.material.specular, 1.0);\n        }\n\n        float isSpecularBounce = (randomValue(rngS) < specularChance) ? 1.0 : 0.0;\n        \n        vec3 p = r.orig + hitInfo.t * r.dir;\n        vec3 diffuseDir = normalize(hitInfo.normal + randomUnitVector(rngS));\n        vec3 specularDir = reflect(r.dir, hitInfo.normal);\n        specularDir = normalize(mix(specularDir, diffuseDir, hitInfo.material.specularRoughness));\n        \n        r.dir = diffuseDir;\n        r.dir = mix(r.dir, specularDir, isSpecularBounce);\n        \n        r.orig = p;\n        \n        vec3 emittedLight = vec3(0.0);\n\t\t\n        incomingLight += emittedLight * rayColor;\n\t\trayColor *= mix(hitInfo.material.diffuseCol, hitInfo.material.specularCol, isSpecularBounce);\n\t}\n\t\n\treturn incomingLight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ndc = uv - 0.5;\n    vec2 nuv = ndc * 2.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec3 cameraPos = vec3(0.0, 16.0, -128.0);\n    \n    vec2 mousePos = (iMouse.xy / iResolution.xy) - 0.5;\n    float theta = -mousePos.x * tau;\n    float phi = -mousePos.y * pi;//clamp(-mousePos.y * tau, -pi / 2.0, pi / 2.0);\n\n    vec3 orbitTarget = vec3(0.0, 16.0, 0.0);\n\n    cameraPos = 64.0 * vec3(cos(phi) * sin(theta), sin(phi), -cos(phi) * cos(theta)) + orbitTarget;\n    \n    vec3 cameraRot = vec3(-phi, theta, 0.0);\n    \n    mat4 cameraMat = createCameraMatrix(cameraPos, cameraRot);\n    \n    float fov = radians(fovDeg);\n\tfloat screenWidth = 2.0 * tan(fov / 2.0);\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\tfloat screenHeight = screenWidth / aspectRatio;\n\t\n\tivec2 numPixels = ivec2(iResolution.x, iResolution.y);\n\tivec2 pixCoord = ivec2(uv * vec2(numPixels));\n\tuint pixelIndex = uint(pixCoord.y * numPixels.x + pixCoord.x);\n\t\n\t//uint rngState = floatBitsToUint(uv.x * uv.y * float(float(iFrame) + 211234.0 / (uv.x + 252.42243 * uv.y)));\n    uint rngState = pcgHash(uint(uv.x * 1009.0) * 1000003u + uint(uv.y * 1009.0) * 314159u + uint(iFrame) * 1618033999u + uint(iTime * 54321.0));\n    \n    for (int i = 0; i < numRaysPerPixel; i++) {\n        vec2 mNdc = ((fragCoord + randomPointInDisk(1.0, rngState)) / iResolution.xy) - 0.5;\n    \tvec3 rayDirLocal = normalize(vec3(mNdc.x * screenWidth, mNdc.y * screenHeight, 1.0));\n        \n        vec3 rayDirWorld = normalize((cameraMat * vec4(rayDirLocal, 0.0)).xyz);\n        \n        Ray r;\n        r.orig = cameraPos;\n        r.dir = rayDirWorld;\n        r.t = randomValue(rngState);\n        \n        color += fireRay(r, rngState);\n    }\n    \n    color /= float(numRaysPerPixel);\n    \n    float shouldAccum = iMouse.z > 0.0 ? 0.0 : 1.0;\n    \n    vec4 lastFrameColor = texture(iChannel0, uv);\n    color += lastFrameColor.xyz * shouldAccum;\n    \n    fragColor = vec4(color, shouldAccum == 1.0 ? lastFrameColor.w + 1.0 : 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.14159265358979;\nconst float tau = 6.28318530717958;\n\nconst float surfaceEpsilon = 1.0 / 512.0;\nconst float maxDist = 2048.0;\n\nconst int maxRayBounces = 8;\nconst int numRaysPerPixel = 2;\nconst float fovDeg = 70.0;\n\nuint pcgHash(uint seed) {\n\tuint state = seed * 747796405u + 2891336453u;\n\tuint result = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (result >> 22u) ^ result;\n}\n\nfloat randomValue(inout uint state) {\n\tstate = pcgHash(state);\n\treturn float(state) / 4294967295.0;\n}\n\nvec3 randomUnitVector(inout uint rngS) {\n\tfloat u = randomValue(rngS);\n\tfloat v = randomValue(rngS);\n\tfloat theta = 2.0 * pi * u;\n\tfloat phi = acos(2.0 * v - 1.0);\n\tfloat px = sin(phi) * cos(theta);\n\tfloat py = sin(phi) * sin(theta);\n\tfloat pz = cos(phi);\n\treturn vec3(px, py, pz);\n}\n\nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0, 1.0);\n    return mix(\n        pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055,\n        rgb * 12.92,\n        vec3(lessThan(rgb, vec3(0.0031308)))\n    );\n}\n\nvec3 sRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0, 1.0);\n    return mix(\n        pow((rgb + 0.055) / 1.055, vec3(2.4)),\n        rgb / 12.92,\n        vec3(lessThan(rgb, vec3(0.04045)))\n    );\n}\n\nvec2 randomPointInDisk(float radius, inout uint rngS) {\n    float angle = randomValue(rngS) * tau;\n    float r = sqrt(randomValue(rngS)) * radius;\n\n    float x = cos(angle) * r;\n    float y = sin(angle) * r;\n\n    return vec2(x, y);\n}\n","name":"Common","description":"","type":"common"}]}