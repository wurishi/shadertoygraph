{"ver":"0.1","info":{"id":"WdyyWR","date":"1605394247","viewed":172,"name":"My raytracing","username":"iuryBorgesRodrigues","description":"My raytracing","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nconst vec3 W = vec3(11.2);\n\nconst vec3 lp = normalize(vec3(0.0,0.0,1.0));\nconst vec3 lc = vec3(1.0,0.9,0.8)*20.0;\n\n\nstruct mat{\nvec3 col;\nvec3 rcol;\nfloat frc;\nfloat frm; \n};\n    \nstruct ray{\nvec3 o;\nvec3 d;\nfloat m;\n};\n    \nvec3 CubemapToHDR( vec3 bg ){\n   bg = bg * bg;\n   bg = -log( 1.01f - bg );            \n   return bg;\n}\n\nmat getMat(float n){\n  \tmat m;   \n    \n    m.col = vec3(0.8);\n    m.rcol= vec3(1.0);\n    m.frm = 0.5;\n    m.frc = 0.05;\n   \n    \n    if(n < 1.0){\n        //n = floor(texture(iChannel0,vec2(n,0.0)).r*10.0)/10.0-0.1;\n        \n        if(n == 0.1){\n\n        m.col = vec3(1.0,0.0,0.0);\n\n        }else if(n == 0.2){\n\n        m.col = vec3(1.0,1.0,0.0);\n\n        }else if(n == 0.0){\n\n        m.col = vec3(0.1);\n\n        }else if(n == 0.3){\n\n        m.col = vec3(0.0,1.0,0.0);\n\n        }else if(n == 0.4){\n\n        m.col = vec3(0.0,1.0,1.0);\n\n        }else if(n == 0.5){\n\n        m.col = vec3(0.0,0.0,1.0);\n\n        }else if(n == 0.6){\n\n        m.col = vec3(1.0,0.0,1.0);\n\n        }\n    }else if(n < -0.1){  \n    m.frm = 0.9;\n    m.frc = 0.05;\n    }else{\n        m.frm = 1.0;\n         m.frc = 0.45*m.frm;\n         m.col = vec3(0.0);\n\n        if(n == 1.0){\n            \n        m.rcol= vec3(1.0,0.766,0.336);\n       \n        }else if(n == 1.2){\n       \n        m.rcol= vec3(0.955,0.637,0.538);\n      \n        }else if(n >= 1.1){\n\n        m.rcol= vec3(0.972, 0.960, 0.915);  \n\n        }\n        \n    }\n \n    return m;\n}\n\n\nvec3 uncharted2ToneMapping(vec3 x){\n\t\n\t\t\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec2 plane( vec3 p)\n{\n    \n    float x = float(int(mod(p.x*5.0,2.0)+1.00));\n    float z = float(int(mod(p.z*5.0,2.0)+1.00));\n    float check = abs(x-z)*-0.1;\n\treturn vec2(p.y,check);\n}\n\nfloat length8( vec3 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y+p.z, 1.0/8.0 );\n}\n\n\nfloat plane2( vec3 p ,vec3 d)\n{\n    \n\treturn dot(d,p);\n}\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(vec2(c,-s),vec2(s,c));\n    return vec3(m*p.xz,p.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\nvec2 comp(vec2 a,vec2 b){\n    \n    return (a.x < b.x) ? a : b;\n}\n\n/*vec2 comp(vec2 a,vec2 b){\n    \n    return vec2(smin(a.x , b.x,32.0),(a.x < b.x) ? a.y : b.y);\n}*/\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(center - pos) - radius;\n}\n\nfloat sdSphere2(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\nfloat sphere(vec3 p,float r){\n    \n       return length(p)-r; \n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//Boolean operations for distance fields\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opShell(float d, float thickness)\n{\n    return abs(d) - thickness;\n}\nfloat vase(in vec3 pos)\n{   \n   \n   \n   float freq = 6.0;\n    \n   float d1 = sdCappedCylinder(pos, vec2(0.08,0.75));\n    \n   float d2 = sdRoundCone(pos+vec3(0.0,0.3,0.0),0.25,0.25,0.1);\n    \n    \n   float d3 = sdSphere(pos, vec3(0.0,1.0,0.0), 0.2);\n    \n   float d4 = sdCappedCylinder(pos + vec3(0.0,-1.75,0.0), vec2(1.0,1.0));\n   float d5 = sdSphere2(pos+vec3(0.0,-0.9,0.0), 0.15);\n   float d6 = sdCappedCylinder(pos, vec2(0.09,0.75));\n   d6 += cos(((pos.y)*90.0))/160.0;\n        \n    float df = opSmoothUnion(d1, d2, 0.2);\n     df = min(df,d6);\n    df = opSmoothUnion(df, d3, 0.2);\n    df = opShell(df, 0.005);\n    df = opSubtraction(d4, df);\n    df = min(df, d5);\n   \n   // df = max(df, 0.045-abs(noise(pos * freq)));\n   // df += cos((pos.y*64.0))/128.0;\n    //df += cos(pos.x*16.0)/48.0;\n    //df += cos(pos.z*16.0)/48.0;\n    \n    return  max (df, -df - 1.0);\n}\n\n\nvec2 map(vec3 rp){\n    vec2 dis = vec2(50.0);\n\n    \n    dis = comp(dis,vec2(plane(rp-vec3(0,-1,0)).xy ));\n    \n    \n    dis = comp(dis,vec2(sphere(rp - vec3(lp),0.1),2.0));\n     dis = comp(dis,vec2(sphere(rp - vec3(-1.52,-0.5,-1.0),0.5),0.1));\n dis = comp(dis,vec2(sphere(rp - vec3(-0.51,-0.5,-1.0),0.5),0.2));\n    \n    dis = comp(dis,vec2(vase(rp+vec3(0.0,0.2,0.0)),-0.7));\n   dis = comp(dis,vec2(sphere(rp - vec3(0.51,-0.5,-1.0),0.5),0.3));\n    dis = comp(dis,vec2(sphere(rp - vec3(1.52,-0.5,-1.0),0.5),0.5));\n    \n    dis = comp(dis,vec2(sphere(rp - vec3(-1.0,0.5,-1.0),0.5),1.0));\n    dis = comp(dis,vec2(sphere(rp - vec3(0.0,0.5,-1.0),0.5),1.1));\n    dis = comp(dis,vec2(sphere(rp - vec3(1.0,0.5,-1.0),0.5),1.2));\n    \n    dis = comp(dis,vec2(sdTorus(rp - vec3(0.0,-0.95,0.0),vec2(0.45,0.05)),-0.1));\n   \n  \n    return dis;\n}\n\n\n\n\nvec4 castRay(vec3 ro , vec3 rd,float imax){\n    \n    float i = 0.002;\n    vec2 dat;\n    \n    for(int n = 0; n < 256; n++){\n        \n        dat.xy = map(ro+rd*i);\n        \n        if(dat.x < 0.002)return vec4(ro+rd*i,dat.y);\n        \n        if(i > imax)return vec4(ro+rd*i,-1.1);\n        \n        i+=max(abs(dat.x),0.002);\n    }\n    \n    return vec4(ro+rd*i,-1.1);\n}\n\n\nvec3 calcNormal(vec3 pos){\n   #if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nray castRayR(vec3 ro , vec3 rd,float imax){\n    \n    float i = 0.002;\n    vec2 dat;\n    bool pass = false;\n    float pre = 1.0;\n    \n    for(int n = 0; n < 512; n++){\n        \n        dat.xy = map(ro+rd*i);\n        \n        \n        if(dat.x < 0.002 && dat.y > -0.5)return ray(vec3(ro+rd*i),vec3(rd),dat.y);\n        \n        if(i > imax)return ray(vec3(ro+rd*i),vec3(rd),-1.1);\n        \n        if(pre < 0.0 && dat.x > 0.0){\n            pass=true;\n            ro=ro+rd*i;\n            rd=normalize(rd+calcNormal(ro)*1.0/1.5);\n            i=0.000;\n        }\n        \n      \n        i+=max(abs(dat.x),0.002);\n        pre=dat.x;\n    }\n    \n    return ray(vec3(ro+rd*i),vec3(rd),-1.1);\n}\n\n\n\n\n\n\n\n//from iq's raytracer \nfloat calcAO( in vec3 pos, in vec3 nor,int i )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n   \n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n   \n    return clamp( 1.0 - 3.0*occ, 0.1, 1.0 );    \n}\n\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n// COMPUTE LIGHTING\nvec3 lighting( vec3 pos, vec3 nor, vec3 ro, vec3 rd,int i) {\n  \n  \tvec3  ref = reflect( rd, nor );\n\tfloat occ = calcAO( pos, nor ,i);\n\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\tdif *= softshadow( pos, lig, 0.02, 2.5 );\n\tdom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20 * dif * vec3(1.00,0.90,0.60);\n\tbrdf += 1.20 * spe * vec3(1.00,0.90,0.60) * dif;\n\tbrdf += 0.30 * amb * vec3(0.50,0.70,1.00) * occ;\n\tbrdf += 0.40 * dom * vec3(0.50,0.70,1.00) * occ;\n\tbrdf += 0.30 * bac * vec3(0.25,0.25,0.25) * occ;\n\tbrdf += 0.40 * fre * vec3(1.00,1.00,1.00) * occ;\n\tbrdf += 0.02;\n\n\treturn brdf;\n}\n\n\nvec3 renderR(vec3 ro,vec3 rd, int j){\n    vec3 pos = vec3(0,0,0),normal = vec3(0.0,0.0,0.0),color = vec3(0.0,0.0,0.0),ref = vec3(1.0);\n    mat mate; \n   \tfloat prec = 0.002;\n    vec3 bg = vec3(0.3,0.7,1.0)*1.0;\n    float dist = 0.0;\n    float cons = 1.0;\n    float lin = 0.14;\n    float quad = 0.07;\n    vec3 p= ro + rd * map(ro+rd).x;\n    vec3 nor = calcNormal( p );\n\t\n        bg=textureLod(iChannel0, rd,0.0).rgb;\n    \tbg=CubemapToHDR(bg);\n        vec4 dat = vec4(0.0);\n        if(j < 2){\n     \tray temp = castRayR(ro,rd,15.0/float(j));\n        rd = temp.d;\n        dat = vec4(temp.o,temp.m);\n        }else{\n        dat = castRay(ro,rd,15.0/float(j));\n \n        }\n     \tpos = dat.xyz;\n \t\n     \t\n            \n            dist+=length(ro-pos);\n            float fog = exp(-dist/10.0);\n            float dist1 = dist+length(lp-pos);\n           \tfloat atten = 1.0/(cons + lin*dist1 + quad * (dist1 * dist1)); \n            \n            if(dat.w >= 2.0){\n     \t       color+=lc*ref;    \n     \t       return color;\n               \n     \t    }else if(dat.w <= -1.0){\n            \n            dist+=length(ro-pos);\n  \t\t\tfog = exp(-dist/10.0);\n   \t\t\tcolor+=ref*bg;\n   \t\t\treturn color;\n                \n            }else{\n     \t         \n     \t        mate = getMat(dat.w);\n                vec3 c = pow(mate.col,vec3(2.2));   \n     \t        vec3 rc = pow(mate.rcol,vec3(2.2));\n                \n     \t        normal = calcNormal(pos);\n     \t        vec3 ld = normalize(lp-pos);\n                \n     \t        float fren =pow(1.0 - max(dot(-rd,normal),0.0),5.0);\n     \t        fren = mix(mate.frc,mate.frm,fren);\n                \n     \t        vec3 lit = (max(dot(ld,normal),0.0))*lc/12.0;\n              vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n \n                lit*=softshadow( p, lig, 0.02, 2.5 );\n                \n                \n         \n     \t        vec3 dif = c*lit*(1.0-fren)*ref;\n                vec3 amb = c*bg/6.3*ref*(1.0-fren)*calcAO(pos,normal,j);\n                \n                dif*=atten;\n                \n     \t    \tcolor+= dif + amb;\n                \n     \t        ref*=fren*rc; \n                \n              color*=lighting(p, nor, ro, rd ,j); \n                \n     \t    \n        \n            \n     \t    ro=pos;\n     \t\trd=reflect(rd,normal);\n     \t  \t  \t\n    }\n   dist+=length(ro-pos);\n    fog = exp(-dist/10.0);\n   color+=ref*bg;\n   return color;\n    \n}\n\nvec3 render(vec3 ro,vec3 rd){\n    vec3 pos = vec3(0,0,0),normal = vec3(0.0,0.0,0.0),color = vec3(0.0,0.0,0.0),ref = vec3(1.0);\n    mat mate; \n   \tfloat prec = 0.002;\n    vec3 bg = vec3(0.3,0.7,1.0)*1.0;\n    float dist = 0.0;\n    float cons = 1.0;\n    float lin = 0.14;\n    float quad = 0.07;\n    int j;\n    vec3 p= ro + rd * map(ro+rd).x;\n    vec3 nor = calcNormal( p );\n    while(true){\n   \t\tj++;\n     \tvec4 dat = castRay(ro,rd,15.0/float(j));\n     \t pos = dat.xyz;\n \t\n     \tbg=textureLod(iChannel0, rd,0.0).rgb;\n       \n            bg=CubemapToHDR(bg);\n            dist+=length(ro-pos);\n            float fog = exp(-dist/10.0);\n            float dist1 = dist+length(lp-pos);\n           \tfloat atten = 1.0/(cons + lin*dist1 + quad * (dist1 * dist1)); \n            \n            if(dat.w >= 2.0){\n     \t       color+=lc*ref;    \n     \t       return color;\n               \n     \t    }else if(dat.w < -1.0){\n            \n            dist+=length(ro-pos);\n  \t\t\tfog = exp(-dist/10.0);\n   \t\t\tcolor+=ref*bg;\n   \t\t\treturn color;\n                \n            }else if(dat.w < -0.5 && j < 3){\n                \n             \n     \t        mate = getMat(dat.w);\n                vec3 c = pow(mate.col,vec3(2.2));   \n     \t        vec3 rc = pow(mate.rcol,vec3(2.2));\n                \n     \t        normal = calcNormal(pos);\n     \t        vec3 ld = normalize(lp-pos);\n                \n     \t        float fren =pow(1.0 - max(dot(-rd,normal),0.0),5.0);\n     \t        fren = mix(mate.frc,mate.frm,fren);\n               \n                \n     \t        vec3 dif = renderR(ro,rd,j)*(1.0-fren)*ref;\n                vec3 amb = c*bg/24.0*ref*(1.0-fren)*calcAO(pos,normal,j);\n                \n                dif*=atten;\n                \n     \t    \tcolor+= dif;\n                \n     \t        ref*=fren*rc; \n                \n            }else{\n     \t         \n     \t        mate = getMat(dat.w);\n                vec3 c = pow(mate.col,vec3(2.2));   \n     \t        vec3 rc = pow(mate.rcol,vec3(2.2));\n                \n     \t        normal = calcNormal(pos);\n     \t        vec3 ld = normalize(lp-pos);\n                \n     \t        float fren =pow(1.0 - max(dot(-rd,normal),0.0),5.0);\n     \t        fren = mix(mate.frc,mate.frm,fren);\n                \n     \t        vec3 lit = (max(dot(ld,normal),0.0))*lc/12.0;\n                vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n \n                lit*=softshadow( p, lig, 0.02, 2.5 );\n                \n               \n                \n                \n     \t        vec3 dif = c*lit*(1.0-fren)*ref;\n                vec3 amb = c*bg/10.0*ref*(2.0-fren)*calcAO(pos,normal,j);\n                \n                \n                \n                dif*=atten;\n                \n     \t    \tcolor+= (dif + amb);\n                \n     \t        ref*=fren*rc; \n                \n          \n            \n             color*=lighting(p, nor, ro, rd ,j);\n         \t\n     \t  \t     \n                \n            if(j>=10)break;\n                    \n                    \n                    \n                \n                \n     \t    }\n            \n     \t    ro=pos;\n     \t\trd=reflect(rd,normal);\n     \t  \t  \t\n    }\n\n  \n   dist+=length(ro-pos);\n   float fog = exp(-dist/10.0);\n   color+=ref*bg;\n   return color;\n    \n}\n\n\n#define ZERO (min(iFrame,0))\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5; \n\t\n\t\nvec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\n    vec2 mouse;\n    \n    mouse = (iMouse.xy/iResolution.xy*2.0-vec2(1.0))*vec2(iResolution.x/iResolution.y,1.0)*2.0;\n    mouse.y = max(mouse.y,-0.5);\n    \n    mat3 rot = mat3(vec3(sin(mouse.x+3.14159/2.0),0,sin(mouse.x)),\n                    vec3(0,1,0),\n                    vec3(sin(mouse.x+3.14159),0,sin(mouse.x+3.14159/2.0)));\n    \n    //float p0 = texture(iChannel0,vec2(0.0,0.0)).g;\n    \n\tvec3 lp2=vec3(0.0,0.0,1.0);\n    lp2=vec3(0.0,mouse.y,0.5);\n    \n    vec3 ro = vec3(0.0,0.0,2.9)+vec3(0.0,0.0,0.0);\n    vec3 rd = normalize(vec3(uv,-2.0));\n   \trd = rot*rd;\n\tro = rot*ro;\n    \n    \n    vec3 color = render(ro,rd);\n\tcolor=Tonemap_ACES(color);\n       \n    vec3 curr = uncharted2ToneMapping(color.xyz*5.0);\n\tvec3 whiteScale = 1.0/uncharted2ToneMapping(W); \n\tvec3 mapped = curr*whiteScale;\n\t\n\tmapped = pow(mapped, vec3(1.0 / 2.2));\n     \n    tot += mapped;\n    }\n     tot /= float(AA*AA);\n\t\n\tfragColor =  vec4(tot,1.0) ;\n}","name":"Image","description":"","type":"image"}]}