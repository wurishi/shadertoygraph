{"ver":"0.1","info":{"id":"sts3RM","date":"1621811459","viewed":283,"name":"hypnogif","username":"Carandiru","description":"sound pressure level : https://www.desmos.com/calculator/mgwxsxscqi","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["voxel","shockwave","iso","radiation","cherenkov"],"hasliked":0,"parentid":"wdSczm","parentname":"Cherenkov radiation shockwave"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// - carandiru\n// http://bit.ly/supersinfulsilicon\n\n// shader is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/wdSczm\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// based on sound pressure level\n// [ https://www.desmos.com/calculator/mgwxsxscqi ]\n// thermo nuclear sound pressure gradient\n// tweening\n\n#define PI (3.14159265358979323846)\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n#define EPSILON 0.000000001f\n#define light rgb\n#define tran a\n#define MIN_STEP 0.00005f\t// absolute minimum before performance degradation or infinite loop, no artifacts or banding\n#define MAX_STEPS 256.0f\n#define WAVE_TIME_OFFSET 63.0f\n#define WAVE_TIME_SCALAR 1.0f\n#define CAMERA_SPEED 0.111f\n#define REPEAT_MOD 28.0f\n\n#define ZOOM 0.4f  \t\t// less = more zoom\n\n#define sq(a) (a*a)\n\nconst float k_sqrtMaxSteps = sqrt(MAX_STEPS);\nconst vec3  k_eyePos = vec3(-120.0f, -84.851589f, -120.0f).xzy * 0.1f * ZOOM;\nconst float k_VolumeDimensions = (MAX_STEPS);\nconst float k_InvVolumeDimensions = 1.0f / k_VolumeDimensions;\n\nvec2 intersect_box(in vec3 orig, in vec3 dir) {\n\n\tvec3 inv_dir = 1.0f / dir;\n\tvec3 tmin_tmp = (vec3(-1.0f) - orig) * inv_dir;\n\tvec3 tmax_tmp = (vec3(1.0f) - orig) * inv_dir;\n\tvec3 tmin = min(tmin_tmp, tmax_tmp);\n\tvec3 tmax = max(tmin_tmp, tmax_tmp);\n\n\treturn vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\nvec3 v3_rotate_azimuth(in vec3 p, in float angle)\n{\n    vec2 inOrient = vec2(cos(angle), sin(angle));\n    \n\treturn vec3(fma(p.x, inOrient.x, -p.y * inOrient.y),\n\t\t\t\tfma(p.x, inOrient.y, p.y * inOrient.x),\n\t\t\t\tp.z);\n}\n\nfloat singlewave(float x, float t)\n{\n    float X = x - t * t;\n    return -cos(X) * exp(-X * X);\n}\n\nfloat soundwave(float l, float t, float r1, float s0)\n{\n    s0 += 10.0f * log( (0.5f * PI * l) + (4.0f/r1) );\n    \n    return -smoothstep(0.0f, 200.0f, t + 4.0 * s0);\n}\n\nfloat tT;\nfloat fetch_wave_power(in vec3 v)\n{\n    //return singlewave(length(v.xy), mod(tT, REPEAT_MOD));\n    float l = length(v.xy);\n    return soundwave(l, REPEAT_MOD - mod(tT - WAVE_TIME_OFFSET, REPEAT_MOD), 4.0f, 0.0);\n}\n\nfloat fetch_distance(in vec3 uvw)\n{   \n    return fetch_wave_power(uvw);\n\n    // power -> distance\n    // w = wavelength\n    // p = sq(w) / (sq(4pi) * sq(d))\n    // d = (w * sqrt(p)) / (4pi * p)\n    \n    //float d = (w * sqrt(p)) / (4.0*PI * p);\n}\n\nvec3 fetch_normal(in vec3 uvw, in vec3 rd, in float dt)\n{\n\tvec3 gradient;\n\n\tgradient.x = fetch_distance(uvw + (vec3(dt, 0.0f, 0.0f) * rd)) - fetch_distance(uvw - (vec3(dt, 0.0f, 0.0f) * rd));\n\tgradient.y = fetch_distance(uvw + (vec3(0.0f, dt, 0.0f) * rd)) - fetch_distance(uvw - (vec3(0.0f, dt, 0.0f) * rd));\n\tgradient.z = fetch_distance(uvw + (vec3(0.0f, 0.0f, dt) * rd)) - fetch_distance(uvw - (vec3(0.0f, 0.0f, dt) * rd));\n\n    // bugfix: nan, add epsilon\n\treturn( -normalize(gradient + EPSILON) ); // normal from central differences (gradient) \n}\n\nconst float grid_stroke = 0.666f;\nfloat comb(float v)\n{\n    return (grid_stroke * 0.5f) - 0.05f / pow(0.5 + 0.5 * cos(v * 2.0 * PI), 10.0);\n}\n\nfloat texGrid(vec3 v)\n{\n    v.xy = fract(v.xy * grid_stroke);\n    float q = 0.0;\n    q = max(q, comb(v.x));\n    q = max(q, comb(v.y));\n    return q;\n}\n\nvec2 texHeight(float d)\n{\n    return vec2(d, 1.0f - d);\n}\n\nvec3 eye;\nvec3 camera(in vec3 v)\n{\n    v.y -= 3.0f * (2.0f/3.0f); // center offset\n        \n    // orthographic isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    iso = v3_rotate_azimuth(iso, tT * CAMERA_SPEED);\n    \n    // camera world position\n    eye = v3_rotate_azimuth(k_eyePos, tT * CAMERA_SPEED);\n    iso = iso * k_eyePos;\n\n    return iso;\n}\n\n// Cherenkov radiation\n// - a (almost) pure natural source of blue noise (reality)\n// emission is also blue light when observed\n// Cherenkov radiation is a particle emission that travels\n// faster than the speed of light inside a specific medium (like water)\n// but is still slower than the speed of light in a vacuum (space)\n\n// the hypothetical \"tachyon\" derives from this type of radiation\n// however has never been observed or proven that they exist\n// tachyon's would be particles that travel faster than the speed of light in a vacuum\n//\n// the blue noise rabbit hole seems to be even more interesting\n// than I originally thought with its applications in cg....\nfloat cherenkov_radiation(out float b, in float h, in float dt)\n{\n    const float c = 299792458.0f;  // universal constant for speed of light in a vacuum (m/s)\n    const float n = 1.33f; // refraction index of water\n    const float e = 10e5f; // total energy emitted\n    const float q = 24e3f; // energy in a particle\n    \n    // n = refraction index of medium\n    // c/n < v < c  : speed of particle is greater than speed of light\n    //\t\t\t\t  in the medium, but still less than the speed of light in a vacuum\n    // B = v/c\t\t: speed of particle in medium / speed of light\n    // cos = 1/(nB) : angle of emission\n    \n    // (modified) frank-tamm formula\n    // sq(d) * e      sq(q)                sq(c)\n    // ---------  =  -------  *  1 -  --------------- \n    //     d           4pi             sq(v) * sq(n)\n    \n    //                sq(q) * (sq(n)*sq(v) - sq(c))\n    //     d       = -------------------------------\n    //                  4 * e * pi * sq(n) * sq(v)\n    \n    float v = c/n;\n    v += (h) * v * dt;\n    v = min(v, c);\n    \n    b = (1.0f / (n * (v / c)));\n    \n    float d;\n    d = sq(q) * (sq(n)*sq(v) - sq(c));\n    d /= 4.0f * e * PI * sq(n) * sq(v);\n    \n    return (d);\n}\n\nconst vec3 grid_color = vec3(0.5f);\n// rgb(0.222f,0.222f,1.0f) (far depth color) - royal blue (cooler)\nconst vec3 royal_blue = vec3(0.222f,0.222f,1.0f); // components are maximized\n// rgb(0.80f,0.65f,1.0f) (near depth color) - royal purle (warmer) \nconst vec3 royal_purple = vec3(0.80f,0.65f,1.0f); // components are maximized\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tT = iTime * WAVE_TIME_SCALAR + WAVE_TIME_OFFSET;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n\t    \n    // init raymarch\n    vec3 ro = camera(vec3(v.xy, 1.0f));\n\n    vec3 rd = normalize(-ro);\n    \n    vec2 t_hit = intersect_box(ro, rd);\n\tif (t_hit.x > t_hit.y) {\n        discard;\n        //fragColor = vec4(0);\n        //return;\n\t}\n\n\tt_hit.x = max(t_hit.x, 0.0f);\n    \n\tfloat interval_length = (t_hit.y - t_hit.x);\n    \n    float inv_num_steps = 1.0f / length(k_VolumeDimensions * abs(rd)); // number of steps for full volume\n\tfloat dt = (interval_length) * inv_num_steps;\t// dt calculated @ what would be the full volume interval\n    dt = max(MIN_STEP, dt);\n    \n    vec3 p = eye + t_hit.x * rd + textureLod(iChannel1, uv, 0.0f).r * rd * dt * 0.5f; // start with bluenoise jitter offset (up to 1/2 dt)\n    \n    // begin volumetric raymarch\n    vec4 voxel = vec4(vec3(0.0f), 1.0f);\n\t\n    for( float interval_remaining = interval_length; \n         interval_remaining >= 0.0f ; interval_remaining -= dt ) \n    {  // fast sign test       \n\n        vec3 n = fetch_normal(p, rd, dt);\n        float d = fetch_distance(p);\n\t\t        \n        // signed distance (wave & grid)\n        vec2 height = texHeight(d);\n        float wave = (height.x + (1.0 - height.y)) * 0.5f + 0.5;\n        d = d * 0.5f + 0.5f;\n        \n        float grid = texGrid(p);\n        float dot_emission;\n        float rad = cherenkov_radiation(dot_emission, d, dt);\n        \n        float NdotV = max(0.0f, dot(rd, n));\n        float fresnel = pow(1.0f - NdotV, 5.0f);\n        vec3 wave_light = vec3(wave);\n        wave_light += dot_emission * fresnel + d * (1.0f - fresnel);\n        wave_light += dot_emission * rad * fresnel;\n   \n        vec3 light_color = wave_light * rad;\n        light_color = viridis(dot(light_color, LUMA));\n        \n        // integration\n        float sigmaS = wave;\n\t\tfloat sigmaE = max(EPSILON, sigmaS); // to avoid division by zero extinction\n                \n        vec3 Li = light_color * sigmaS;// incoming light\n        float sigma_dt = exp2(sigmaE * k_sqrtMaxSteps * dt * -2.0f);\n        vec3 Sint = (Li - Li * sigma_dt) / sigmaE; // integrate along the current step segment\n\n        voxel.light += voxel.tran * Sint; // accumulate and also take into account the transmittance from previous steps\n\n        // Evaluate transmittance to view independentely (change in transmittance)\n        voxel.tran *= sigma_dt;\n\n        p += (dt) * rd;\n    }\n    \n    // Output to screen\n    fragColor = vec4(voxel.light * (1.0f - voxel.tran),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// viridis palette function port //             \n#define fma(a,b,c) (a*b+c)\n\nvec3 viridis(float t) \n{\n\tconst vec3 _c0 = vec3( 0.2777273272234177, 0.005407344544966578, 0.3340998053353061 );\n\tconst vec3 _c1 = vec3( 0.1050930431085774, 1.404613529898575, 1.384590162594685 );\n\tconst vec3 _c2 = vec3( -0.3308618287255563, 0.214847559468213, 0.09509516302823659 );\n\tconst vec3 _c3 = vec3( -4.634230498983486, -5.799100973351585, -19.33244095627987 );\n\tconst vec3 _c4 = vec3( 6.228269936347081, 14.17993336680509, 56.69055260068105 );\n\tconst vec3 _c5 = vec3( 4.776384997670288, -13.74514537774601, -65.35303263337234 );  \n    const vec3 _c6 = vec3( -5.435455855934631, 4.645852612178535, 26.3124352495832 );  \n\n\tvec3 xmT = vec3(t);\n    \n    vec3 x;\n\n    // c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))))\n    x = fma(xmT, _c6, _c5);\n    x = fma(x, xmT, _c4);\n    x = fma(x, xmT, _c3);\n    x = fma(x, xmT, _c2);\n    x = fma(x, xmT, _c1);\n    x = fma(x, xmT, _c0);\n\n    return(x);\n}","name":"Common","description":"","type":"common"}]}