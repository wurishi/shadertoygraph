{"ver":"0.1","info":{"id":"MltGWS","date":"1471421966","viewed":187,"name":"Ray casting?","username":"chazbg","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\nprecision mediump int;\n\n// Transform UVs from [0..1] to [-1..1] space\nvec2 normalizeUVs(vec2 uvs)\n{\n\treturn uvs * 2.0 - 1.0;\n}\n\nstruct Sphere\n{\n\tvec3 pos;\n\tfloat r;\n};\n\n#define SPHERE_COUNT 36\nSphere spheres[SPHERE_COUNT];\n\nvoid initializeSpheres()\n{    \n    for (int sphereIt = 0; sphereIt < SPHERE_COUNT; sphereIt++)\n    {\n        float sqrtCount = sqrt(float(SPHERE_COUNT));\n        \n   \t\tfloat i = (mod(float(sphereIt), sqrtCount)  / sqrtCount) * 2.0 - 1.0;\n        float j = (float(sphereIt / int(sqrtCount)) / sqrtCount) * 2.0 - 1.0;\n        \n        spheres[sphereIt].pos = vec3(i, j, 0.0) * 400.0;\n\t\tspheres[sphereIt].r   = 64.0;        \n    }\n}\n\nvec3 getCubemapColor(vec3 viewDir, vec3 normal)\n{\n    vec3 R = reflect(viewDir, normal);\n    return texture(iChannel0, R).rgb;\n}\n\nbool getIntersection(vec3 ray, vec3 cameraPos, out vec3 intersection, out Sphere s, out vec3 n)\n{\n    bool res = false;\n    float nearestIntersection = 1000000000.0;\n    \n    for (int i = 0; i < SPHERE_COUNT; i++)\n\t{\n        vec3 cameraToCenter = spheres[i].pos - cameraPos;\n        float projLength = dot(cameraToCenter, ray);\n        if (projLength > 0.0)\n        {\n        \n            vec3 rayProj = ray * projLength;\n            float distanceToRay = length(rayProj - cameraToCenter);\n\n            float r = spheres[i].r;\n            if (distanceToRay < r)\n            {\n                float distToIntersection = projLength - sqrt(r * r - distanceToRay * distanceToRay);\n\n                if (distToIntersection < nearestIntersection)\n                {\n                    nearestIntersection = distToIntersection;\n                    intersection = cameraPos + distToIntersection * ray;\n                    n = normalize(intersection - spheres[i].pos);\n                    s = spheres[i];\n                    res = true;\n                }\n            }\n        }\n\t}\n    return res;\n}\n\nvec3 getCameraPos(float time)\n{\n    mat3 rot = mat3(\n        vec3(cos(time), 0.0, -sin(time)),\n        vec3(0.0,       1.0,  0.0),\n        vec3(sin(time), 0.0,  cos(time)));\n    return rot * vec3(0.0, 0.0, 1000.0);\n}\n\nvec3 getViewDirection(vec3 cameraPos)\n{\n    return normalize(vec3(0.0) - cameraPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tinitializeSpheres();\n\t\n\tvec3  lightDir    = normalize(vec3(1.0, 1.0, 1.0));\n\tvec2  offset      = normalizeUVs(fragCoord.xy / iResolution.xy);\n\tvec3  cameraPos   = getCameraPos(iTime);\n\tvec3  cameraView  = getViewDirection(cameraPos);\n\tvec3  cameraUp    = vec3(0.0, 1.0,  0.0);\n\tvec3  cameraRight = cross(cameraView, cameraUp);\n\tfloat cameraNear  = 4.0;\n\t\n\tvec3 ray = normalize(cameraRight * offset.x * (iResolution.x / iResolution.y) + cameraUp * offset.y + cameraView * cameraNear);\n\t\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec3 intersection = cameraPos;\n    vec3 n;\n    Sphere s;\n    \n    for (int i = 0; i < 20; i++)\n    {\n        fragColor = ((20.0 - float(i)) / 20.0) * texture(iChannel0, ray);\n        if (!getIntersection(ray, intersection, intersection, s, n))\n        {\n            break;\n        }\n        ray = reflect(ray, n);\n        \n    }    \n}","name":"Image","description":"","type":"image"}]}