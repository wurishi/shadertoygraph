{"ver":"0.1","info":{"id":"ls2yRV","date":"1492952720","viewed":495,"name":"flowingalong","username":"tomviolin","description":"flowing wind tunnel\n","likes":5,"published":1,"flags":34,"usePreview":0,"tags":["lbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 smoke = texture(iChannel3,fragCoord/iResolution.xy);\n    fragColor=smoke; return;\n    fragColor=smoke*.99;\n    \n    vec4 fragColor1 = vec4(smoke.rgb,1.);\n    vec4 fragColor2 = texture(iChannel2,fragCoord/iResolution.xy);\n    fragColor = fragColor1;//*fragColor2;// + (1.-fragColor1);//*(1.-fragColor1);\n    fragColor.a=1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#pragma optimize(on)\nprecision highp float;\n// actual fluid model \n#define C 6\n#define Cf (float(C))\n//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n\n\n#define f0(x,y) texture(iChannel0, (vec2(C*x,C*y)+0.5)/iResolution.xy).r;\n\n\n#define f0(x,y) texture(iChannel0, (vec2(C*x,C*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(C*x,C*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(C*x,C*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(C*x+1,C*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(C*x+1,C*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(C*x+1,C*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(C*x,C*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(C*x,C*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(C*x,C*y+1)+0.5)/iResolution.xy).b;\n\n#define relax 1.9\n#define lbv .09\n#define stabfix 0.3\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\tfloat v= fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n    return v > .95 ? 1.:0. ;\n}\n\n\nfloat getFEq(float rhoh, vec2 u, vec2 offset) {\n    vec2 e = vec2(offset.x, offset.y);\n    float dotProd = dot(u, e); //-u.x*xoffset + u.y*yoffset;\n\n    float scD;\n    scD = (e == vec2(0.0,0.0) ? 4.0 / 9.0 :  1.0 / (36.0 - 27.0 * (1.0-abs(e.x*e.y))));\n    /*\n    if (offset == vec2(0.0,0.0)) {\n        scD = 4.0 / 9.0;\n    } else\n        scD = 1.0 / (36.0 - 27.0 * (1.0-abs(offset.x*offset.y)));\n    */\n    return scD * rhoh * (1.0 + 3.0 * dotProd + 4.5 * dotProd * dotProd - 1.5 * dot(u, u)\n     //                   + (27./2.)*(dot(e,e)-(4./3.))*(u.x*u.x*u.x*e.x+u.y*u.y*u.y*e.y )\n    );\n\t//return scD * rho * (exp((3./2.)*(2*dotProd-dot(u,u))));\n}\n\n\nfloat barrier(vec2 fragCoord)\n{\n    vec3 k1= texture(iChannel2,fragCoord/iResolution.xy).rgb;\n    vec2 p2 = vec2(fragCoord/iResolution.xy);\n    p2.x=1.-p2.x;\n    vec3 k2= texture(iChannel1,p2).rgb;\n\treturn atan(pow(length(k2-k1),2.)*90.)*2.;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float barr=0.;\n\n    //relaxation time\n    float w = relax;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/Cf);\n    int LatSizeY = int(iResolution.y/Cf);\n    //int LatSizeX = 200;\n    //int LatSizeY = 200;\n    //4 texels per voxel\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/Cf));\n    int iy = int(floor(fragCoord.y/Cf));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - C*ix;\n    int ity = int(fragCoord.y) - C*iy;\n    if (itx>1 || ity>1) return;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    f0 = f0(ix,iy); //if 0, reinitialise\n    if( (iFrame<10) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        vx = vy = 0.0;\n        vx=lbv;\n        //add a small disk near the entrance\n        //if( distance(vec2(LatSizeX/2,LatSizeY/2),vec2(ix,iy)) < 10.0 )\n        //    rho = 1.1;\n        float sq_term = (vx*vx+vy*vy);\n        vec2 vxy=vec2(vx,vy);\n        f0=getFEq(rho,vxy,-vec2(0,0));\n        f1=getFEq(rho,vxy,-vec2(-1,0));\n        f2=getFEq(rho,vxy,-vec2(1,0));\n        f3=getFEq(rho,vxy,-vec2(0,-1));\n        f4=getFEq(rho,vxy,-vec2(0,1));\n        f5=getFEq(rho,vxy,-vec2(-1,-1));\n        f6=getFEq(rho,vxy,-vec2(1,1));\n        f7=getFEq(rho,vxy,-vec2(1,-1));\n        f8=getFEq(rho,vxy,-vec2(-1,1));\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        //velocity cap for stability\n        float norm = sqrt(vx*vx+vy*vy);\n        if(norm>stabfix)\n        {\n            vx = vx*(stabfix/norm);\n            vy = vy*(stabfix/norm);\n        }\n        if (ix > LatSizeX-5) {\n            vx = vx*.95+lbv*.05;\n            vy = vy * .95;\n        }\n        //enforced motion\n        \n\n        if (ix == 0) {\n            vx=lbv;\n            vy=0.;\n        }        \n        \n        //if( distance(vec2(5.0+10.0*iTime,float(LatSizeY/2)+10.0*sin(-/3.0)),vec2(ix,iy)) < 4.0)\n        //{\n         //   rho = 1.1;\n         //   w = 1.0;\n        //}\n        \n        //barrier(fragCoord);\n        //if (barrier(fragCoord)>.1){\n            //rho+=.002*(exp(barr)-1.);\n            //w*=(1.0-.002*barr);\n        //}\n        if (length(vec2(ix,iy)-vec2(float(LatSizeX)/6.,float(LatSizeY)/2.1))<float(LatSizeX)/12.) {\n            vx=vy=0.;\n            barr=1.0;\n        }\n        //mouse motion\n        float dd = distance(iMouse.xy/Cf,vec2(ix,iy));\n        if( iMouse.w>0.01 && dd < 4.0)\n        {\n            //rho=1.1;\n            //float f=(10./(dd*dd+10.));\n            //rho = rho-f/30.;\n            vx=vy=0.;\n            barr=1.;\n        }\n        //velocity cap for stability\n        norm = sqrt(vx*vx+vy*vy);\n        if(norm>stabfix)\n        {\n            vx = vx*(stabfix/norm);\n            vy = vy*(stabfix/norm);\n        }\n\n        \n        vec2 vxy=vec2(vx,vy);\n        float f0eq=getFEq(rho,vxy,-vec2(0,0));\n        float f1eq=getFEq(rho,vxy,-vec2(-1,0));\n        float f2eq=getFEq(rho,vxy,-vec2(1,0));\n        float f3eq=getFEq(rho,vxy,-vec2(0,-1));\n        float f4eq=getFEq(rho,vxy,-vec2(0,1));\n        float f5eq=getFEq(rho,vxy,-vec2(-1,-1));\n        float f6eq=getFEq(rho,vxy,-vec2(1,1));\n        float f7eq=getFEq(rho,vxy,-vec2(1,-1));\n        float f8eq=getFEq(rho,vxy,-vec2(-1,1));\n\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = (1.-w) * f0 + w * f0eq;\n        f1 = (1.-w) * f1 + w * f1eq;\n        f2 = (1.-w) * f2 + w * f2eq;\n        f3 = (1.-w) * f3 + w * f3eq;\n        f4 = (1.-w) * f4 + w * f4eq;\n        f5 = (1.-w) * f5 + w * f5eq;\n        f6 = (1.-w) * f6 + w * f6eq;\n        f7 = (1.-w) * f7 + w * f7eq;\n        f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n        //fragColor.rgb = vec3(1.0,0.0,0.0);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n        //fragColor.rgb = vec3(0.0,1.0,0.0);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n        //fragColor.rgb = vec3(0.0,0.0,1.0);\n    else //stores rho,vx,vy\n        fragColor = vec4(vx,vy,rho,barr);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#pragma optimize(on)\nprecision highp float;\n\n#define C 6\n#define Cf (float(C))\n\nvec4 quadi(float x, vec4 alpha, vec4 beta, vec4 gamma) {\n\n\treturn (alpha*(x)*(x - 1.) / 2. +\n\t\t-beta * (x + 1.)*(x - 1.) +\n\t\tgamma * (x)*(x + 1.) / 2.);\n}\n\n//=======================================================================================\nvec4 CubicHermite(vec4 A, vec4 B, vec4 Cx, vec4 D, float t)\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t * t*t;\n\tvec4 a = -A / 2.0 + (3.0*B) / 2.0 - (3.0*Cx) / 2.0 + D / 2.0;\n\tvec4 b = A - (5.0*B) / 2.0 + 2.0*Cx - D / 2.0;\n\tvec4 c = -A / 2.0 + Cx / 2.0;\n\tvec4 d = B;\n\n\treturn a * t3 + b * t2 + c * t + d;\n}\n/*\n//=======================================================================================\nvec4 BicubicHermiteTextureSample(sampler2D iChannel0, vec2 Ps, vec2 pAM)\n{\n\t//vec2 P=Ps*TM;\n\tvec2 pixel = Ps + 0.5;\n\n\tvec2 frac = fract(pixel);\n\tpixel = floor(pixel) * pAM - vec2(pAM / 2.0);\n\n\tvec4 C00 = texture(iChannel0, pixel + pAM * vec2(-1, -1));\n\tvec4 C10 = texture(iChannel0, pixel + pAM * vec2(0.0, -1));\n\tvec4 C20 = texture(iChannel0, pixel + pAM * vec2(1., -1.));\n\tvec4 C30 = texture(iChannel0, pixel + pAM * vec2(2, -1));\n\n\tvec4 C01 = texture(iChannel0, pixel + pAM * vec2(-1.0, 0.0));\n\tvec4 C11 = texture(iChannel0, pixel + pAM * vec2(0.0, 0.0));\n\tvec4 C21 = texture(iChannel0, pixel + pAM * vec2(1.0, 0.0));\n\tvec4 C31 = texture(iChannel0, pixel + pAM * vec2(2.0, 0.0));\n\n\tvec4 C02 = texture(iChannel0, pixel + pAM * vec2(-1.0, 1.0));\n\tvec4 C12 = texture(iChannel0, pixel + pAM * vec2(0.0, 1.0));\n\tvec4 C22 = texture(iChannel0, pixel + pAM * vec2(1.0, 1.0));\n\tvec4 C32 = texture(iChannel0, pixel + pAM * vec2(2.0, 1.0));\n\n\tvec4 C03 = texture(iChannel0, pixel + pAM * vec2(-1.0, 2.0));\n\tvec4 C13 = texture(iChannel0, pixel + pAM * vec2(0.0, 2.0));\n\tvec4 C23 = texture(iChannel0, pixel + pAM * vec2(1.0, 2.0));\n\tvec4 C33 = texture(iChannel0, pixel + pAM * vec2(2.0, 2.0));\n\n\tvec4 CP0X = CubicHermite(C00, C10, C20, C30, frac.x);\n\tvec4 CP1X = CubicHermite(C01, C11, C21, C31, frac.x);\n\tvec4 CP2X = CubicHermite(C02, C12, C22, C32, frac.x);\n\tvec4 CP3X = CubicHermite(C03, C13, C23, C33, frac.x);\n\n\treturn CubicHermite(CP0X, CP1X, CP2X, CP3X, frac.y);\n}\n\n//=======================================================================================\nvec4 bchTexture2D(sampler2D iChannel0, vec2 Ps, vec2 pAM)\n{\n\t//vec2 P=Ps*TM;\n\tvec2 pixel = Ps/pAM + 0.5;\n\n\tvec2 frac = fract(pixel);\n\tpixel = floor(pixel) * pAM - vec2(pAM / 2.0);\n\n\tvec4 C00 = textureOffset(iChannel0, pixel, ivec2(-1, -1));\n\tvec4 C10 = textureOffset(iChannel0, pixel, ivec2(0.0, -1));\n\tvec4 C20 = textureOffset(iChannel0, pixel, ivec2(1., -1.));\n\tvec4 C30 = textureOffset(iChannel0, pixel, ivec2(2, -1));\n\n\tvec4 C01 = textureOffset(iChannel0, pixel, ivec2(-1.0, 0.0));\n\tvec4 C11 = textureOffset(iChannel0, pixel, ivec2(0.0, 0.0));\n\tvec4 C21 = textureOffset(iChannel0, pixel, ivec2(1.0, 0.0));\n\tvec4 C31 = textureOffset(iChannel0, pixel, ivec2(2.0, 0.0));\n\n\tvec4 C02 = textureOffset(iChannel0, pixel, ivec2(-1.0, 1.0));\n\tvec4 C12 = textureOffset(iChannel0, pixel, ivec2(0.0, 1.0));\n\tvec4 C22 = textureOffset(iChannel0, pixel, ivec2(1.0, 1.0));\n\tvec4 C32 = textureOffset(iChannel0, pixel, ivec2(2.0, 1.0));\n\n\tvec4 C03 = textureOffset(iChannel0, pixel, ivec2(-1.0, 2.0));\n\tvec4 C13 = textureOffset(iChannel0, pixel, ivec2(0.0, 2.0));\n\tvec4 C23 = textureOffset(iChannel0, pixel, ivec2(1.0, 2.0));\n\tvec4 C33 = textureOffset(iChannel0, pixel, ivec2(2.0, 2.0));\n\n\tvec4 CP0X = CubicHermite(C00, C10, C20, C30, frac.x);\n\tvec4 CP1X = CubicHermite(C01, C11, C21, C31, frac.x);\n\tvec4 CP2X = CubicHermite(C02, C12, C22, C32, frac.x);\n\tvec4 CP3X = CubicHermite(C03, C13, C23, C33, frac.x);\n\n\treturn CubicHermite(CP0X, CP1X, CP2X, CP3X, frac.y);\n}\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{ \n\tfloat v= fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n    return v > .95 ? 1.:0. ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (iTime ==0.) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 pos=fragCoord/iResolution.xy;\n    //only one pixel out of 4 stores the moments\n    int ix0 = int(floor(fragCoord.x/float(C)))*C;\n    int iy0 = int(floor(fragCoord.y/float(C)))*C;\n    vec4 m = texture(iChannel0, (vec2(ix0+1,iy0+1)+0.5)/iResolution.xy);\n    vec4 mx1 = texture(iChannel0, (vec2(ix0+1-C,iy0+1)+0.5)/iResolution.xy);\n    vec4 mx2 = texture(iChannel0, (vec2(ix0+1+C,iy0+1)+0.5)/iResolution.xy);\n    vec4 my1 = texture(iChannel0, (vec2(ix0+1,iy0+1-C)+0.5)/iResolution.xy);\n    vec4 my2 = texture(iChannel0, (vec2(ix0+1,iy0+1+C)+0.5)/iResolution.xy);\n    \n    float divm = (mx2.x-mx1.x)*m.x + (my2.y-my1.y)*m.y;\n    vec4 s = BicubicHermiteTextureSample(\n        iChannel3,\n        fragCoord-m.xy*Cf,1./iResolution.xy);//-m.xy*Cf, vec2(1.));\n    if (s.a > .5) s=vec4(0.);\n    //s=s*(1.-divm*5.);\n    fragColor=vec4(s.rgb,1.);// *(1.0-m.a);\n    \n    // inject tracers\n    if (length(vec2(mod(fragCoord.x,800.),mod(fragCoord.y,32.))-vec2(4.,16.))<2.24) {\n        float k=floor(iTime*3.);\n        fragColor = vec4(\n            smoothstep(.1,1.,pos.y),\n           \t-abs(pos.y)*1.5+1.5,\n            smoothstep(.3,1.,1.-pos.y),\n     \t\t1.);\n    }\n    \n    fragColor = clamp(fragColor,vec4(0.),vec4(1.,1.,1.,.5));\n\tif (m.a>0.) fragColor=vec4(.3,.3,.2,1.);\n}\n    */\n    \n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //only one pixel out of 4 stores the moments\n    int ix0 = int(floor(fragCoord.x/float(C)));\n    int iy0 = int(floor(fragCoord.y/float(C)));\n    int ix=ix0; int iy=iy0;\n    //vec3 m = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).xyz;\n    //ix=ix0-0;iy=iy+1;\n    vec2 N = texture(iChannel0, (vec2(C*ix+1,C*iy+1)+0.5)/iResolution.xy).xy;\n    ix=ix0-0;iy=iy-1;\n    vec2 S = texture(iChannel0, (vec2(C*ix+1,C*iy+1)+0.5)/iResolution.xy).xy;\n    ix=ix0+1;iy=iy-0;\n    vec2 E = texture(iChannel0, (vec2(C*ix+1,C*iy+1)+0.5)/iResolution.xy).xy;\n    ix=ix0-1;iy=iy-0;\n    vec2 W = texture(iChannel0, (vec2(C*ix+1,C*iy+1)+0.5)/iResolution.xy).xy;\n\n    float dx=E.x-W.x;\n    float dy=N.x-S.x;\n    dx*=1.1;\n    dy*=1.1;\n    //dx=clamp(dx,-.1,.1);\n    //dy=clamp(dx,-.1,.1);\n    float theta = length(vec2(dx-0.01,dy+0.01))*.9;\n    float light = 1./((theta*theta*10000.)+1.);\n    fragColor = clamp(vec4(light)*1.2-.4,-.2,1.)+texture(iChannel2, (-vec2(dx,dy)*1.)+vec2(iResolution.x-fragCoord.x,iResolution.y-fragCoord.y)/iResolution.xy);\n    //fragColor.xyz *= light;\n    return;\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 20) {\n        float weight=.1;\n        if (iFrame == 0) weight=1.0;\n        fragColor = texture(iChannel2,vec2(iResolution.x-fragCoord.x,\n                   fragCoord.y)/iResolution.xy)*weight+\n            texture(iChannel1,fragCoord/iResolution.xy)*(1.-weight);\n\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n         fragColor = texture(iChannel2,vec2(iResolution.x-fragCoord.x,\n                                    fragCoord.y)/iResolution.xy)*.2+\n\t\t\t         texture(iChannel1,fragCoord/iResolution.xy)*.8 ;\n}","name":"Buffer D","description":"","type":"buffer"}]}