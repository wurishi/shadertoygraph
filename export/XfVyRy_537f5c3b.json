{"ver":"0.1","info":{"id":"XfVyRy","date":"1732035272","viewed":36,"name":"2d ocean with noice noise","username":"ademdj12","description":"this shader is a simple ocean side view scrolling multiple noise ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ocean","boat","buoyancy","2docean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// todo:\n//      - clean/refactor\n//      - foam\n//      - goo sky with sun\n//      - lighting \n//      - add a boat\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float level = seaLevel;\n    vec4 ocean = vec4(0,0.2,.7,1.);\n    for(int i = 0; i< 6;i++){\n        float hs = hash(ivec2(i,i));\n        float waveHeight = (hs) * largestWave;\n        float dlevel = waveHeight*\n                 (  -largestWave/3.+\n                    noise(\n                        vec2(fragCoord.x,0) *.015 +\n                        vec2(0.5,0) * iTime * sign(hs-.5) * (hs+.1)\n                        )*\n                    float(6-i-1)/6. );\n        level += dlevel;\n        \n    }\n    float oceanMask = smoothstep(0.105,0.1,level - fragCoord.y/iResolution.y);\n    vec4 sky = mix(vec4(.5,.6,.9,1.),vec4(0.8,.85,.96,1.),uv.y+.1);\n    fragColor = mix(ocean,sky,oceanMask);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// noise from https://www.shadertoy.com/view/ftsfDf\n\n// 0 = linear, 1 = smoothstep, 2 = cosine\n#define LERP 1\n#define largestWave .06\n#define seaLevel iResolution.y/(3.*iResolution.y)\n// Very fast hash function\nfloat hash(ivec2 p) {\n    ivec2 q = p * ivec2(1317301, 1712759) + p.yx;\n    return float((((q.x ^ q.y) * 3536471) & 0xFFFF)) * 0.00001526;\n}\n\nfloat lerp(float a, float b, float x) {\n    #if (LERP == 1)\n        return a + (b - a) * smoothstep(0.0, 1.0, x);\n    #elif (LERP == 2)\n        return mix(a, b, 0.5 - cos(x * 3.1415) * 0.5);\n    #else\n        return mix(a, b, x);\n    #endif\n}\n\nfloat layer(vec2 p0) {\n    const float f = 0.35;\n    vec2 p = p0 + (p0.x + p0.y) * f;\n    \n    const ivec2 iota = ivec2(0, 1);\n    \n    ivec2 ip = ivec2(p);\n    float v00 = hash(ip + iota.xx);\n    float v11 = hash(ip + iota.yy);\n    \n    vec2 fp = fract(p);\n    if (fp.x > fp.y) {\n        float v10 = hash(ip + iota.yx);\n        return lerp(\n            lerp(v00, v10, (fp.x - fp.y) / (1.0 - fp.y)),\n            v11,\n            fp.y\n        );\n    } else {\n        float v01 = hash(ip + iota.xy);\n        return lerp(\n            v00,\n            lerp(v01, v11, fp.x / fp.y),\n            fp.y\n        );\n    }\n}\n\nfloat noise(vec2 p) {\n    const float layer_scale = 0.5;\n    const float detail = 0.05;\n    \n    float total = 0.0;\n    float cap = 0.0;\n    for (float scale = 1.0; scale > detail; scale *= layer_scale) {\n        total += layer(p / scale) * scale;\n        cap += scale;\n    }\n    return total / cap;\n}\n","name":"Common","description":"","type":"common"}]}