{"ver":"0.1","info":{"id":"lfjyRD","date":"1722006695","viewed":43,"name":"Sparkling Ghost Face","username":"zhangrm","description":"A sparkling ghost mask wth y-axis served as symmetry axis, and flash like lightning is hitting. The fractal function is changed. Moreover, hsv representation is directly expressed as rgb. Music vibration is added. ref:https://www.shadertoy.com/view/sdKcDz","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","fbm","music","mask","face","symmetry"],"hasliked":0,"parentid":"M3GSzV","parentname":"Sparkling ghost mask"},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 zhangrm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A modified version of mrange's Face in the clouds \n// https://www.shadertoy.com/view/sdKcDz\n#define PI 3.1415926\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TIME*TAU)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x, x)\n#define RESOLUTION  iResolution\n\nconst mat2 frot = ROT(PI/3.33);\n\nvec2 g_vx = vec2(0.0, 0.0);\nvec2 g_vy = vec2(3.2, 1.3);\n\nvec2 g_wx = vec2(1.7, 9.2);\nvec2 g_wy = vec2(8.3, 2.8);\n\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.5;\n  }\n  return f/s;\n}\n\nvec2 df(vec2 p) {\n  vec2 p0 = p;\n  p0.x = abs(p0.x);\n  p0 -= vec2(0.75, 0.4);\n  p0 *= ROT(PI/9.0);\n  float d0 = vesica(p0, vec2(0.45, 0.2));\n  float g0 = length(p0);\n\n  float d = d0;\n  float g = g0;\n\n  return vec2(d, g);\n}\n\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  float d = df(p).x-0.1;\n  p.x = -pabs(p.x, 0.125);\n\n  v = vec2(fbm(p + g_vx), fbm(p + g_vy));\n  w = vec2(fbm(p + 3.0*v + g_wx), fbm(p + 3.0*v + g_wy));\n\n  float h = fbm(p + 2.25*w);\n\n  float aa = 0.2;\n  h *= mix(1.0, 0.05, smoothstep(aa, -aa, d));\n\n  return h*smoothstep(2.5, 0.15, abs(p.x+0.5*p.y));\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  float eps = 2.0/RESOLUTION.y;\n  vec2 e = vec2(eps, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nfloat rand(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nvec3 smear(vec2 p, vec2 q, float depth) {\n  float aa = 2.0/RESOLUTION.y;\n  g_vx *= ROT(TTIME/1000.0);\n  g_vy *= ROT(TTIME/900.0);\n  g_wx *= ROT(TTIME/800.0);\n  g_wy *= ROT(TTIME/700.0);\n\n  vec2 v;\n  vec2 w;\n \n  vec2 d2 = df(p);\n  float d = abs(d2.x) - 2.0*aa;\n  float g = d2.y;\n  float h = warp(p, v, w);\n  vec3 n  = normal(p);\n\n  vec3 ld1  = normalize(vec3(0.5, 0.2, 0.4));\n  vec3 ld2  = normalize(vec3(-0.5, 0.2, -0.4));\n  vec3 lcol1 = vec3(1.0, 0.8, 0.2); \n  vec3 lcol2 = vec3(1.0, 0.0, 0.0); \n  vec3 acol = vec3(0.2, 0.3, 0.8); \n\n  float dif1 = pow(max(dot(ld1, n), .0), 1.0);\n  float dif2 = pow(max(dot(ld2, n), .0), 2.0);\n\n  vec3 col11 = vec3(0.7, 0.8, 0.9);\n  vec3 col21 = vec3(0.5, 0.6, 0.7); \n  vec3 col12 = vec3(0.4, 0.5, 1.0); \n  vec3 col22 = vec3(0.2, 0.4, 1.0); \n\n  vec3 col1 = mix(col11, col12, q.x);\n  vec3 col2 = mix(col21, col22, q.y);\n  \n  vec3 col = vec3(0.0);\n  float lv = length(v);\n  float lw = length(w);\n  col += lv*col1*dif1*lcol1;\n  col += lw*col2*dif1*lcol1;\n  col += lv*col1*dif2*lcol2;\n  col += lw*col2*dif2*lcol2;\n  col += lv*col1*acol;\n  col += lw*col2*acol;\n  col *= smoothstep(0.0, 1.0, (h*h+0.05+0.75*0.125*(1.0+p.y)));\n  col *= smoothstep(0.0, 4.0, TIME); \n  \n  vec3 colorA = vec3(0.6, 0.8, 1.0); \n  vec3 colorB = vec3(1.0, 0.5, 0.0); \n  vec3 colorC = vec3(0.3, 0.9, 0.3); \n  vec3 colorD = vec3(0.8, 0.2, 0.5); \n  vec3 colorE = vec3(0.1, 0.9, 0.7); \n  float t1 = 0.5 + 0.5 * sin(TTIME / 8.0);\n  float t2 = 0.5 + 0.5 * cos(TTIME / 8.0);\n  float t3 = 0.5 + 0.5 * sin(TTIME / 4.0);\n  vec3 interpolatedColor = mix(colorA, colorB, t1); \n  interpolatedColor = mix(interpolatedColor, colorC, t2); \n  interpolatedColor = mix(interpolatedColor, colorD, t3);\n  interpolatedColor = mix(interpolatedColor, colorE, 0.5 + 0.5 * sin(TTIME / 2.0));\n  col += mix(5.0, 1.0, t1) * interpolatedColor * exp(-40.0 * (g-0.01));\n  \n  col *= 1.0 / (1.0 + depth * 0.1);\n\nfloat sl = texture(iChannel0, vec2(0.)).x ;\nfloat sl2 = texture(iChannel0, vec2(0.25)).x * .5 ;\nfloat sm = texture(iChannel0, vec2(0.5)).x * .2 ;\nfloat sm2 = texture(iChannel0, vec2(0.75)).x * .2 ;\nfloat sh = texture(iChannel0, vec2(1.)).x * .2;\nfloat st = (sl+sl2+sm+sm2+sh);\n\n  col *= mix(.7, 2.3, st); \n\n  return col;\n}\n\n// Function to get audio data from iChannel0\nfloat getAudio(vec2 uv) {\n    return texture(iChannel0, uv).r;\n}\n\n// Main image function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord / RESOLUTION.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= RESOLUTION.x / RESOLUTION.y;\n    float depth = length(p);\n\n    vec3 col = smear(p, q, depth);\n    col = aces_approx(col);\n    col = sRGB(col);\n\n    // Get audio data (e.g., average of a few samples)\n    float audioStrength = getAudio(vec2(0.4, 0.25));\n    // Adjust flicker intensity based on audio strength\n    float flicker_intensity = smoothstep(0.5, 2.0, audioStrength);\n\n    // Apply flicker effect to the color\n    col *= mix(1.0, 2.5, flicker_intensity);\n\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}