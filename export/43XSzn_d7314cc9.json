{"ver":"0.1","info":{"id":"43XSzn","date":"1709050037","viewed":104,"name":"Cell spread","username":"rileyjshaw","description":"Small demo of cyclic cellular automata. For [red, green, blue], if a color is surrounded by the next color in the list itâ€™ll change into the surrounding color. Also, if a color is mostly surrounded by itself, it flips back into the previous list color.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["automata","cyclic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec4 R = vec4(0.886, 0.055, 0., 1.);\nconst vec4 G = vec4(1., 0.922, 0.278, 1.);\nconst vec4 B = vec4(0.055, 0.161, 0.89, 1.);\n\n// Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 self = texture(iChannel0, uv);\n    fragColor = R * self.r + G * self.g + B * self.b;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Configurable.\nconst int NEIGHBORHOOD_RANGE = 2;\n\n// Derived.\nconst float TOTAL_NEIGHBORS = float((NEIGHBORHOOD_RANGE * 2 + 1) * (NEIGHBORHOOD_RANGE * 2 + 1) - 1);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        // Initialize with random colors in the first frame.\n        fragColor = vec4(\n            fract(sin(dot(fragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453),\n            fract(sin(dot(fragCoord.xy, vec2(63.7264, 34.9583))) * 43758.5453),\n            fract(sin(dot(fragCoord.xy, vec2(29.879, 64.233))) * 43758.5453),\n            1.0\n        );\n    } else {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec2 offset = 1.0 / iResolution.xy;\n\n        vec4 neighborSum = vec4(0.0);\n        for(int x = -NEIGHBORHOOD_RANGE; x <= NEIGHBORHOOD_RANGE; x++) {\n            for(int y = -NEIGHBORHOOD_RANGE; y <= NEIGHBORHOOD_RANGE; y++) {\n                if(x == 0 && y == 0) continue; // Skip the current pixel\n                vec2 wrappedUV = mod(uv + vec2(float(x), float(y)) * offset, 1.0); // Wrap around\n                neighborSum += texture(iChannel0, wrappedUV);\n            }\n        }\n\n        vec4 self = texture(iChannel0, uv);\n        \n        float maxSelfChannelValue = max(max(self.r, self.g), self.b);\n        float maxNeighborChannelValue = max(max(neighborSum.r, neighborSum.g), neighborSum.b);\n\n        bool shouldTurnGreen = maxSelfChannelValue == self.r && maxNeighborChannelValue == neighborSum.g || (maxSelfChannelValue == self.b && maxNeighborChannelValue == neighborSum.b && maxSelfChannelValue < maxNeighborChannelValue * 1.25 / TOTAL_NEIGHBORS);\n        bool shouldTurnBlue = maxSelfChannelValue == self.g && maxNeighborChannelValue == neighborSum.b || (maxSelfChannelValue == self.r && maxNeighborChannelValue == neighborSum.r && maxSelfChannelValue < maxNeighborChannelValue * 1.25 / TOTAL_NEIGHBORS);\n        bool shouldTurnRed = maxSelfChannelValue == self.b && maxNeighborChannelValue == neighborSum.r || (maxSelfChannelValue == self.g && maxNeighborChannelValue == neighborSum.g && maxSelfChannelValue < maxNeighborChannelValue * 1.25 / TOTAL_NEIGHBORS);\n\n        if (shouldTurnRed) {\n            fragColor = vec4(1, 0, 0, 1);\n        } else if (shouldTurnGreen) {\n            fragColor = vec4(0, 1, 0, 1);\n        } else if (shouldTurnBlue) {\n            fragColor = vec4(0, 0, 1, 1);\n        } else {\n            fragColor = self;\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}