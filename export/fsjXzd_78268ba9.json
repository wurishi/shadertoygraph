{"ver":"0.1","info":{"id":"fsjXzd","date":"1620833478","viewed":290,"name":"My Second Raymarcher","username":"Peace","description":"Supports: reflections, multi reflections, specular lighting, diffuse lighting, metallness, roughness, textures, materials, soft punembra shadows, fog and refractions","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["raymarcher","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 512\n#define MAX_DISTANCE 64.0\n#define SURFACE 0.002\n#define FOV 90.0\n#define SHADOW 0.5\n#define SHADOW_HARDNESS 16.0\n#define SHADOW_STRENGTH 0.75\n#define AO .15\n#define AO_ITERATIONS 16\n#define AO_STEP_SIZE 0.01\n#define REFLECTIVITY 0.9\n#define MAX_REFLECTIONS 8\n\n#define AIR_IOR 1.01\n#define GLASS_IOR 1.45\n\n#define PI 3.1415926535\n#define GAMMA 2.2\n#define SUNLIGHT_COLOR vec3(0.9921568, 0.9843137, 0.8274509)\n\nfloat normalDistributionGGX(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = PI * denom * denom;\n\t\n    return nom / denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = geometrySchlickGGX(NdotV, roughness);\n    float ggx1  = geometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    if(cosTheta > 1.0)cosTheta = 1.0;\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}  \n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\nRay camera = Ray(vec3(0), vec3(0.0, 0.0, 0.0));\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float linear;\n    float quadratic;\n};\nLight sun = Light(vec3(32.0, 64.0, -48.0), vec3(1), 0.0f, 0.0f);\n\nstruct Material\n{\n    vec4 color;\n    int textureSlot;\n    float roughness;\n    float metallic;\n    float indexOfRefraction;\n};\n\nstruct Object\n{\n    vec3 position;\n    vec3 scale;\n    Material material;\n};\n\nObject objects[32];\n\nfloat getSphereDistance(vec3 point, Object sphere)\n{\n    return length(point - sphere.position) - sphere.scale.x;\n}\n\nfloat getBoxDistance(vec3 point, Object cube)\n{\n  return length(max(abs(point - cube.position)-cube.scale,0.0));\n}\n\nstruct SceneInfo\n{\n    float dist;\n    int objectID;\n};\n\nvoid getInfo(inout SceneInfo currentInfo, SceneInfo sceneInfo, Object object)\n{\n    objects[sceneInfo.objectID] = object;\n    if(currentInfo.dist <= sceneInfo.dist)return;\n    currentInfo = sceneInfo;\n}\n\nSceneInfo getDistance(vec3 point)\n{\n    SceneInfo info;\n    info.dist = 1e6;\n    int id = 0;\n    \n    Object box = Object(vec3(1.2, cos(iTime * 2.) * 0.25, 4.0), vec3(.5), Material(vec4(0.0, 1.0, 1.0, 1.0), -1, 0.999, 0., GLASS_IOR));\n    getInfo(info, SceneInfo(getBoxDistance(point, box), id++), box);\n    \n    Object sphere = Object(vec3(-1.2, sin(iTime * 2.) * 0.25, 4.0), vec3(1.0), Material(vec4(1.0, 1.0, 1.0, 0.), 0, .95, 0., GLASS_IOR));\n    getInfo(info, SceneInfo(getSphereDistance(point, sphere), id++), sphere);\n    \n    Object plane = Object(vec3(-8.0, -2., -8.0), vec3(64.0, 1.0, 64.0), Material(vec4(1), 0, 1.0, 0.0, GLASS_IOR));\n    getInfo(info, SceneInfo(getBoxDistance(point, plane), id++), plane);\n    \n    return info;\n}\n\nvec3 getTextureColor(int textureSlot, vec2 uv)\n{\n    switch(textureSlot)\n    {\n        case 0: return texture(iChannel0, uv).rgb;\n        case 1: return texture(iChannel1, uv).rgb;\n        case 2: return texture(iChannel2, uv).rgb;\n    }\n    return vec3(1.0, 1.0, 1.0);\n}\n\nvec3 getNormal(vec3 point)\n{\n    vec2 e = vec2(0.002,-0.002);\n    return normalize(e.xxx * getDistance(point+e.xxx).dist\n                   + e.xyy * getDistance(point+e.xyy).dist\n                   + e.yxy * getDistance(point+e.yxy).dist\n                   + e.yyx * getDistance(point+e.yyx).dist);\n}\n\nstruct MarchingResult\n{\n    SceneInfo info;\n    float shadow;\n};\n\nMarchingResult march(Ray ray, float side)\n{\n    MarchingResult result;\n    result.info.objectID = -1;\n    result.shadow = 1.0;\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 point = ray.origin + ray.direction * result.info.dist;\n        SceneInfo info = getDistance(point);\n        info.dist *= side;\n        result.info.dist += info.dist;\n        if(result.info.dist >= MAX_DISTANCE)break; \n        if(abs(info.dist) < SURFACE)\n        { \n            result.info = SceneInfo(result.info.dist, info.objectID);\n            result.shadow = 1.0 - SHADOW_STRENGTH; \n            break; \n        }   \n        result.shadow = min(result.shadow, SHADOW_HARDNESS * info.dist / result.info.dist + (1.0 - SHADOW_STRENGTH));\n    }\n    return result;\n}\n\nfloat getAmbient(vec3 point, vec3 normal)\n{\n\tvec3 vNormal = normal;\n\tfloat fAmbientOcclusion = 1.0;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i <= AO_ITERATIONS; i++)\n\t{\n\t\tfDist += AO_STEP_SIZE;\n\n\t\tfloat vSceneDist = getDistance(point + vNormal * fDist).dist;\n\n\t\tfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist) * AO / fDist );                                  \n\t}\n\treturn max(fAmbientOcclusion, 0.0);\n}\n\nvec3 Lo = vec3(0);\nvec3 getLight(vec3 point, vec3 normal, Ray ray, Light light, Material material)\n{\n    vec3 lightDir = normalize(light.position - point);\n    vec3 viewDir = normalize(ray.origin - point);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n    float dist = length(light.position - point);\n    float attenuation = 1.0 / (1.0 + light.linear * dist + light.quadratic * (dist * dist)); \n    vec3 radiance = light.color * attenuation;\n \n    vec3 albedo = vec3(1);\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, material.metallic);\n    float NDF = normalDistributionGGX(normal, halfwayDir, material.roughness);\n    float G = geometrySmith(normal, viewDir, lightDir, material.roughness);\n    vec3 F = fresnelSchlick(max(0.0, dot(halfwayDir, viewDir)), F0);\n    \n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - material.metallic;\n    \n    float NdotL = max(dot(normal, lightDir), 0.0);  \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(NdotL, 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001); \n    \n    //albedo should be devided by PI\n    Lo += (kD * albedo + specular) * radiance * NdotL;\n    \n    float ambientOcclusion = getAmbient(point, normal);\n    float shadow = march(Ray(point + normal * 0.02, lightDir), 1.).shadow;\n    vec3 ambient = vec3(0.05) * albedo;\n                             \n    vec3 lightColor = (ambient + Lo) * shadow * ambientOcclusion; \n    \n    lightColor = pow(lightColor, vec3(1.0 / GAMMA));\n    \n    return vec3(lightColor);\n}\n\nvec4 getColor(vec3 point, Ray ray, MarchingResult marchingResult, vec3 normal)\n{\n    if(marchingResult.info.dist >= MAX_DISTANCE) return texture(iChannel3, ray.direction);\n    Object obj = objects[marchingResult.info.objectID];\n    vec3 colXZ = getTextureColor(obj.material.textureSlot, point.xz / obj.scale.xz + obj.scale.xz * 0.5 - obj.position.xz);\n    vec3 colYZ = getTextureColor(obj.material.textureSlot, point.yz / obj.scale.yz + obj.scale.yz * 0.5 - obj.position.yz);\n    vec3 colXY = getTextureColor(obj.material.textureSlot, point.xy / obj.scale.xy + obj.scale.xy * 0.5 - obj.position.xy);\n    vec3 n = pow(abs(normal), vec3(4.));\n    n /= n.x + n.y + n.z;\n    vec3 color = (colYZ * n.x + colXZ * n.y + colXY * n.z) * obj.material.color.rgb;\n    color *= getLight(point, getNormal(point), ray, sun, obj.material);\n    return vec4(color, obj.material.color.a);\n}\n\nvec3 getReflection(Ray ray, vec3 normal, Material material)\n{\n    vec3 color = vec3(0);\n    for(int i = 0; i < MAX_REFLECTIONS; ++i)\n    {\n        if(material.metallic <= 0.0) continue;\n        ray.origin += normal * SURFACE * 3.0;\n        vec3 reflectDir = reflect(ray.direction, normal);\n        MarchingResult marchingResult = march(Ray(ray.origin, reflectDir), 1.);\n        vec3 point = ray.origin + marchingResult.info.dist * reflectDir;\n        color += getColor(point, Ray(ray.origin, reflectDir), marchingResult, normal).rgb * material.metallic;\n        if(marchingResult.info.dist > MAX_DISTANCE)return color;\n        ray.origin = point;\n        ray.direction = reflectDir;\n        material = objects[marchingResult.info.objectID].material;\n        normal = getNormal(ray.origin);\n    }\n    return color;\n}\n\nvec3 getRefraction(Ray ray, vec3 normal, Material material)\n{\n    vec3 color = vec3(0);\n    float IOR = (material.indexOfRefraction > AIR_IOR) ? (1.0 / material.indexOfRefraction) : material.indexOfRefraction;\n    vec3 refractDirIn = refract(ray.direction, normal, IOR);\n    vec3 pEnter = ray.origin - normal * SURFACE * 3.0;\n    float dIn = march(Ray(pEnter, refractDirIn), -1.).info.dist;\n    vec3 pExit = pEnter + refractDirIn * dIn;\n    vec3 exitNormal = -getNormal(pExit);\n    vec3 refractDirOut = refract(refractDirIn, exitNormal, 1.0 / IOR);\n    if(dot(refractDirOut, refractDirOut) == 0.0)\n        refractDirOut = reflect(refractDirIn, exitNormal);\n    Ray outRay = Ray(pExit - exitNormal * SURFACE * 3.0, refractDirOut);\n    MarchingResult outMarchingResult = march(outRay, 1.);\n    vec3 pOut =  outRay.origin + outRay.direction * outMarchingResult.info.dist;\n    color = getColor(pOut, outRay, outMarchingResult, normal).rgb;\n    //color = texture(iChannel3, refractDirOut).rgb;\n    return color;\n}\n\nvec3 getRayDir(vec3 cameraDir, vec2 uv)\n{\n     const float fov = tan(PI / 2.0 - radians(FOV) / 2.0);\n     vec3 rd = normalize(vec3(uv, fov) + camera.direction);\n     return rd;\n}\n\nvec3 getSceneColor(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord -  .5 * iResolution.xy) / iResolution.y;\n    Ray ray = Ray(camera.origin, getRayDir(camera.direction, uv));\n    MarchingResult marchingResult = march(ray, 1.);\n    vec3 point = ray.origin + marchingResult.info.dist * ray.direction;\n    vec3 normal = getNormal(point);   \n    vec4 color = getColor(point, ray, marchingResult, normal);\n    Ray newRay = Ray(point, ray.direction);\n    color.rgb += getReflection(newRay, normal, objects[marchingResult.info.objectID].material); \n    if(color.a < 1.0)\n    color.rgb = mix(getRefraction(newRay, normal, objects[marchingResult.info.objectID].material), color.rgb, color.a);\n    \n    return color.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = getSceneColor(fragCoord);\n}","name":"Image","description":"","type":"image"}]}