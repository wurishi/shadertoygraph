{"ver":"0.1","info":{"id":"fl3SRB","date":"1639298910","viewed":732,"name":"[TDF2021] Alien Spaceship","username":"gam0022","description":"Released at GLSL Graphics Compo, Tokyo Demo Fest 2021\n\nPouet https://www.pouet.net/prod.php?which=90438\nYouTube https://youtu.be/_F0Pxq7TKqs\nGLSLSandbox https://glslsandbox.com/e#77788.0","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","tdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    _    _ _              ____                            _     _       \n   / \\  | (_) ___ _ __   / ___| _ __   __ _  ___ ___  ___| |__ (_)_ __  \n  / _ \\ | | |/ _ \\ '_ \\  \\___ \\| '_ \\ / _` |/ __/ _ \\/ __| '_ \\| | '_ \\ \n / ___ \\| | |  __/ | | |  ___) | |_) | (_| | (_|  __/\\__ \\ | | | | |_) |\n/_/   \\_\\_|_|\\___|_| |_| |____/| .__/ \\__,_|\\___\\___||___/_| |_|_| .__/ \n                               |_|                               |_|    \n\n*/\n\n// Alien Spaceship by @gam0022\n// Released at GLSL Graphics Compo, Tokyo Demo Fest 2021\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BPM 114.0\n#define TAU 6.28318530718\n#define saturate(x) clamp(x, 0., 1.)\n#define opRep(p, a) p = mod(p, a) - a * 0.5\n#define opRepLim(p, c, l) p = p - c * clamp(floor(p / c + 0.5), -l, l);\n\nvec3 ro, target;\nfloat fov;\nvec3 scol;\nfloat beat;\nfloat beatTau;\n\n// For Debugging\nvec4 PU;  // [ 0 1]\nvec4 PN;  // [-1 1]\n\n// Timeline\nfloat prevEndTime = 0., t = 0.;\n#define TL(beat, end) if (t = beat - prevEndTime, beat < (prevEndTime = end))\n\n// Material Types\n#define VOL 0.0\n#define SOL 1.0\n\n// https://www.shadertoy.com/view/3tX3R4\nfloat remap(float val, float im, float ix, float om, float ox) { return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox); }\nfloat remap01(float val, float im, float ix) { return saturate((val - im) / (ix - im)); }\n\nvoid opUnion(inout vec4 m, float d, float type, float roughness_or_emissive, float hue) {\n    if (d < m.x) m = vec4(d, type, roughness_or_emissive, hue);\n}\n\nvec3 pal(vec4 m) {\n    // Integer part: Blend ratio with white (0-10)\n    // Decimal part: Hue (0-1)\n    vec3 col = vec3(0.5) + 0.5 * cos(TAU * (vec3(0.0, 0.33, 0.67) + m.w));\n    return mix(col, vec3(1), 0.1 * floor(m.w));\n}\n\n// Ref. Energy Lab by kaneta\n// https://www.shadertoy.com/view/3dd3WB\nfloat smoothPulse(float start, float end, float period, float smoothness, float t) {\n    float h = abs(end - start) * 0.5;\n    t = mod(t, period);\n    return smoothstep(start, start + h * smoothness, t) - smoothstep(end - h * smoothness, end, t);\n}\n\n// Hash without Sine by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash23(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// hemisphere hash function based on a hash by Slerpy\nvec3 hashHs(vec3 n, vec3 seed) {\n    vec2 h = hash23(seed);\n    float a = h.x * 2. - 1.;\n    float b = TAU * h.y * 2. - 1.;\n    float c = sqrt(1. - a * a);\n    vec3 r = vec3(c * cos(b), a, c * sin(b));\n    return r;\n}\n\n// https://www.shadertoy.com/view/lssGWn\nfloat sdEgg(vec3 p, float r) {\n    p.y *= 0.8;\n    p.y += 0.15 * pow(1.5 * dot(p.xz, p.xz), 0.6);\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvec4 map(vec3 pos) {\n    vec4 m = vec4(1, VOL, 0, 0);\n    // x: Distance\n    // y: MaterialType (VOL or SOL)\n    // z: Roughness in (0-1), Emissive when z>1\n    // w: ColorPalette\n\n    float roughness = 0.05;\n    float a = 1.;\n    float W = 8.;\n    float H = 4.;\n    float D = 8.;\n\n    // Final Room\n    if (pos.z >= D * 6.) {\n        W *= 2.;\n        H *= 2.;\n        D *= 2.;\n        roughness = 0.3;\n    }\n\n    vec3 p1 = pos, p;\n    p1.x = abs(p1.x);\n    opRep(p1.z, 2. * D);\n\n    float roomID = max(floor(pos.z / (2. * D)), 0.0);\n\n    // egg\n    p = p1;\n    opUnion(m, sdEgg(p - vec3(0, 1, 0), 1.), SOL, 0.01, 0.0);\n\n    // floor\n    float pz = smoothPulse(0.0, 0.6, 1.0, 0.5, 0.25 * p.z);\n    float emi = smoothPulse(0.2, 0.25, 1.0, 0.5, pz + p.x / 2.0) * saturate(sin(beatTau / 8. + pos.z)) * step(4., beat);\n    float h = a + 0.1 * floor(2. * sin(p.x)) + 0.2 * floor(1. * sin(2. * p.z));\n    opUnion(m, sdBox(p - vec3(0, -a, 0), vec3(W, h, D)), SOL, roughness + 2. * emi, 0.4);\n\n    // door innner\n    emi = 2. * step(beat, 4. * 16.);\n    float py = smoothPulse(0.0, 0.6, 1.0, 0.5, 0.25 * p.y);\n    emi += 1.8 * smoothPulse(0.0, 0.25, 1.0, 0.5, py + 0.5 * p.x) * saturate(sin(beatTau / 8. + pos.y / 4. - py));\n    opUnion(m, sdBox(p - vec3(0, H - a, D - 2. * a), vec3(W, H, 0.5 * a)), VOL, emi, 2.0 + fract(0.9 + 0.325 * roomID));\n\n    // door outer\n    p.x = pos.x;\n    p.x -= 0.5 * (smoothPulse(0.0, 0.6, 1.0, 0.5, 0.3 * p.y) - 0.5);\n\n    /*\n    float doorOpen = 0.05 * saturate(beat / 4.);\n    if (roomID < 2.)\n        doorOpen += remap(beat, 4. * 16., 4. * 18., 0.0, 0.9);\n    else\n        doorOpen += remap(beat, 4. * 32., 4. * 36., 0.0, 0.9);\n    */\n\n    float openStart = 16. + step(2., roomID) * 18.;\n    float doorOpen = 0.05 * saturate(beat / 4.) + 0.9 * (1. - exp(-3. * remap01(beat, 4. * openStart, 4. * (openStart + 2.))));\n\n    float doorPX = (0.5 + 0.5 * doorOpen) * W;\n    opUnion(m, sdBox(p - vec3(doorPX, H - a, D - 2. * a), vec3(0.5 * W, H, a)), SOL, 0.1, -0.5);\n    opUnion(m, sdBox(p - vec3(-doorPX, H - a, D - 2. * a), vec3(0.5 * W, H, a)), SOL, 0.1, -0.5);\n\n    // wall light\n    p = p1;\n    opUnion(m, sdBox(p - vec3(W + a, 0.5 * H + a, 0), vec3(a, H, D)), SOL, 0.1, 0.0);\n    opRep(p.z, 2.);\n    p.y -= H * 0.5 + a;\n    p.x -= W - 0.5 * abs(p.y);\n\n    float freq = 0.25 * step(4. * 4., beat) + 0.75 * step(4. * 8., beat) - 0.75 * step(4. * 16., beat);\n    float rand = TAU * step(4. * 16., beat) * hash12(floor(pos.xz / vec2(W, 2.0)));\n    emi = 1.8 * saturate(sin(beatTau * freq + 0.5 * step(4. * 4., beat) * pos.z * TAU / D + rand));\n    opUnion(m, sdBox(p, vec3(a * 2., H, 0.2)), VOL, roughness + emi, 2.0 + fract(0.4 + 0.325 * roomID));\n    opUnion(m, sdBox(p, vec3(a * 1.7, H, 0.24)), SOL, roughness, 0.0);\n\n    // wall detail\n    p = p1;\n    opRep(p.z, 0.5);\n    p.y -= H * 0.5 + a;\n    p.x -= W - 0.5 * abs(p.y) - 0.3 * floor(0.8 * abs(p.y));\n    opUnion(m, sdBox(p, vec3(a * 0.8, H, 0.06)), SOL, 2. * roughness, 0.0);\n\n    // ceil light\n    p = p1;\n    p.z -= -2. * a;\n    opRepLim(p.z, 4., 1.);\n    p.x -= W * 0.21;\n    opRepLim(p.x, 0.4, 1.);\n    emi = 1.8 * step(12., beat);\n    opUnion(m, sdBox(p - vec3(0.0, 2.0 * H - 1.1, 0), vec3(0.05, 0.1, 1.)), SOL, emi, 10.0);\n\n    // ceil detail\n    p = p1;\n    opRep(p.x, 1.0);\n    p.y -= 2. * H + 0.1 * smoothPulse(0.0, 0.6, 1.0, 0.5, 0.5 * p.z);\n    p.y -= -0.4 * smoothPulse(0.0, 0.6, 1.0, 0.5, p1.x / W * 2. + 0.4);\n    p.x -= 0.1 * smoothPulse(0.0, 0.6, 1.0, 0.5, p.z);\n    opUnion(m, sdBox(p, vec3(0.4, 1.0, D)), SOL, roughness, 0.0);\n\n    // IFS\n    if (pos.z >= D * 3.) {\n        vec4 ifs = vec4(875, 482, 197, 545) / vec2(1200, 675).xyxy;\n        // ifs = PU;\n\n        p = pos;\n        p -= vec3(0, H, 16. * 3.5);\n\n        for (int i = 0; i < 5; i++) {\n            p = abs(p) - ifs.w;\n            rot(p.xz, -4. * ifs.x);\n            p = abs(p) - ifs.z;\n            rot(p.xy, -4. * ifs.y);\n        }\n\n        opUnion(m, sdEgg(p, 0.1), SOL, 0.0, 0.0);\n        opUnion(m, sdBox(p, vec2(1, 0.01).xyy), SOL, roughness, 0.0);\n        opUnion(m, sdBox(p - vec2(0.001, 0).yxy, vec2(1, 0.01).xyy), VOL, 2.4 * saturate(cos(beatTau / 2. + 10. * p.x)), 2.4);\n    }\n\n    return m;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0, .05);\n    return normalize(map(p).x - vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\n// https://www.shadertoy.com/view/tltGWj\n/*vec3 normal(vec3 p) {\n    float delta = 0.1;\n    vec4 n = vec4(0.0);\n    for (int i = min(iFrame, 0); i < 4; i++) {\n        vec4 s = vec4(p, 0.0);\n        s[i] += delta;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz - n.w);\n}*/\n\n// Ref. EOT - Grid scene by Virgill\n// https://www.shadertoy.com/view/Xt3cWS\nvoid madtracer(vec3 ro1, vec3 rd1, float seed) {\n    scol = vec3(0);\n    float t = 0., t2 = 0.;\n    vec4 m1, m2;\n    vec3 rd2, ro2, nor2;\n    for (int i = 0; i < 160; i++) {\n        m1 = map(ro1 + rd1 * t);\n        // t += m1.y == VOL ? 0.25 * abs(m1.x) + 0.0008 : 0.25 * m1.x;\n        t += 0.25 * mix(abs(m1.x) + 0.0032, m1.x, m1.y);\n        ro2 = ro1 + rd1 * t;\n        nor2 = normal(ro2);\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, vec3(seed, i, iTime)), saturate(m1.z));\n        m2 = map(ro2 + rd2 * t2);\n        // t2 += m2.y == VOL ? 0.25 * abs(m2.x) : 0.25 * m2.x;\n        t2 += 0.25 * mix(abs(m2.x), m2.x, m2.y);\n        scol += .007 * (pal(m2) * step(1., m2.z) + pal(m1) * step(1., m1.z));\n\n        // force disable unroll for WebGL 1.0\n        if (t < -1.) break;\n    }\n}\n\nvoid raymarching(vec3 ro1, vec3 rd1) {\n    scol = vec3(0);\n    float t = 0.;\n    vec4 m;\n    for (int i = 0; i < 160; i++) {\n        vec3 p = ro1 + rd1 * t;\n        m = map(p);\n        t += m.x;\n\n        if (m.x < 0.01) {\n            vec3 light = normalize(vec3(1, 1, -1));\n            vec3 albedo = vec3(0.3);\n            if (m.z > 1.) albedo = pal(m);\n            scol = albedo * (0.5 + 0.5 * saturate(dot(normal(p), light)));\n            break;\n        }\n    }\n}\n\nvoid setCamera(vec4 v, float roY) {\n    vec4 u = v / vec2(1200, 675).xyxy;\n    vec4 n = u * 2. - 1.;\n    ro = vec3(8. * n.z, roY, 16. * u.w);\n    target = ro + vec3(2. * n.xy, 1);\n}\n\nvoid setCameraRot(vec4 v, float roY) {\n    vec4 u = v / vec2(1200, 675).xyxy;\n    vec4 n = u * 2. - 1.;\n    ro = vec3(8. * n.z, roY, 16. * u.w);\n    vec3 fwd = vec3(0, 0, 1);\n    rot(fwd.xz, n.x * TAU / 2.);\n    rot(fwd.yz, n.y * TAU / 4.);\n    target = ro + fwd;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    beat = iTime * BPM / 60.0;\n    beatTau = beat * TAU;\n\n    PU = abs(iMouse / iResolution.xyxy);  // [0 1] zwはマイナスっぽいのでabsをつける\n    PN = PU * 2. - 1.;                    // [-1 1]\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Camera\n    vec2 noise = hash23(vec3(iTime, fragCoord)) - 0.5;  // AA\n    vec2 uv2 = (2. * (fragCoord.xy + noise) - iResolution.xy) / iResolution.x;\n\n    float FD = 675. * 3.;  // Final Room Depth\n    fov = 120.;\n\n// #define DEBUG_CAMERA\n#ifdef DEBUG_CAMERA\n    setCamera(abs(iMouse) + 1. * vec4(0, 0, 0, FD), 5.0);\n    // setCameraRot(abs(iMouse), 3.);\n#else\n\n    // Room1\n    TL(beat, 4. * 8.) setCamera(vec4(600, 250. + t * 3., 600, 243. - t * 6.), 3.);\n    else TL(beat, 4. * 10.) setCamera(vec4(600, 307, 600, 44. + t * 4.), 3.);\n    else TL(beat, 4. * 12.) setCamera(vec4(494, 322, 695, 216), 2.4 + 0.2 * t);\n    else TL(beat, 4. * 14.) setCamera(vec4(600, 481. + 10. * t, 600, 59), 3.);\n    else TL(beat, 4. * 16.) setCamera(vec4(909, 158. - 10.0 * t, 470. + 10.0 * t, 158), 3.);\n    else TL(beat, 4. * 18.) setCamera(vec4(541, 335., 609., 384. + 2.0 * t), 3.);\n\n    // Room2-4\n    else TL(beat, 4. * 36.) setCamera(vec4(541, 335., 609., 480. + 20.0 * t), 3.);\n\n    // Final\n    else TL(beat, 4. * 40.) setCamera(vec4(572., 335. + 5. * t, 617., 106. + FD + t), 2.);                       // 見上げる\n    else TL(beat, 4. * 44.) setCamera(vec4(572., 375. + 0. * t, 617., 106. + FD), mix(8., 2., exp(-0.1 * t)));   // 上昇\n    else TL(beat, 4. * 46.) setCamera(vec4(585. + 2. * t, 268., 705., 205. + FD + 3. * t), 10.);                 // 高所の前進\n    else TL(beat, 4. * 48.) setCamera(vec4(593., 319., 622., 322. + FD - 3. * t), mix(10., 9., exp(-0.1 * t)));  // 高所の後退\n    else TL(beat, 4. * 50.) setCamera(vec4(880., 0., 452., 166. + FD), mix(7., 14., exp(-0.5 * t)));             // 落下\n    else TL(beat, 4. * 52.) setCamera(vec4(525. + 3. * t, 256., 704., 70. + FD + t), 5.);                        // 入口から俯瞰（右）\n    else TL(beat, 4. * 54.) setCamera(vec4(733. + 3. * t, 241., 447., 133. + FD + t), 5.);                       // 入口から俯瞰（左）\n    else TL(beat, 4. * 56.) setCamera(vec4(492. + 2. * t, 319., 750., 181. + FD), 4.);                           // 柱（右）\n    else TL(beat, 4. * 60.) setCamera(vec4(593., 319., 622., 322. + FD + t), 3.);                                // 中央から前進\n    else TL(beat, 4. * 62.) setCamera(vec4(884., 131., 452., 216. + FD), mix(2., 4., exp(-0.1 * t)));            // 落下\n    else TL(beat, 4. * 64.) setCamera(vec4(435., 354., 494., 216. + FD + 2. * t), 1.);                           // 地面を前進（左）\n    else TL(beat, 4. * 66.) setCamera(vec4(1039., 294., 463. + 5. * t, 247. + FD), 1.);                          // 地面を右移動\n    else TL(beat, 4. * 68.) setCamera(vec4(567., 391., 664., 256. + FD + 2. * t), 1.);                           // 地面の中央を前進\n    else TL(beat, 4. * 70.) setCamera(vec4(645., 326., 705., 270. + FD), 1.9);                                   // 卵に注目\n    else TL(beat, 4. * 72.) {\n        setCamera(vec4(645, 326., 705., FD + 272.), 1.9);\n        fov = mix(90., 120., exp(-t));\n    }\n\n#endif\n\n    vec3 up = vec3(0, 1, 0);\n    vec3 fwd = normalize(target - ro);\n    vec3 right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    vec3 rd = normalize(right * uv2.x + up * uv2.y + fwd / tan(fov * TAU / 720.));\n\n// #define DEBUG_SCENE\n#ifdef DEBUG_SCENE\n    raymarching(ro, rd);\n    fragColor = vec4(scol, 1.);\n#else\n    madtracer(ro, rd, hash12(uv2));\n    vec3 bufa = texture(iChannel0, uv).xyz;\n    scol = mix(scol, vec3(0), remap01(beat, 4. * 70., 4. * 72.));\n    fragColor = saturate(vec4(0.7 * scol + 0.7 * bufa, 0.));\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}