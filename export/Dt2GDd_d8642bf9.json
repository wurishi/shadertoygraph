{"ver":"0.1","info":{"id":"Dt2GDd","date":"1674167598","viewed":87,"name":"Colorful bouncing ball","username":"Gariam","description":"Ray marching example with soft shadows, ambient occlusion and a very simple sky.\n\np.s. My imagination sucks.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sphere","sky","ball","softshadows","ambientocclusion","hill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ray Marching\n#define MINDIST 0.001\n#define MAXSTEP 100\n#define MAXDIST 1000.0\n\n//Shadows\n#define SHADOWBRIGHT 0.1\n#define SOFTSHADOWS 0.15\n\n//Ambient Occlusion\n#define AO_MULTIPLIER 3.0\n#define AO_MAXSTEP 3\n#define AO_STEPSIZE 0.075\n\n//Atmosphere (approximated with a simple fog)\n#define ATM_DENSITY 0.015\n#define ATM_COLOR vec3(0.0, 1.0, 1.0)\n#define ATM_HEIGHT 500.0\n\n//Post-processing\n#define GAMMA 2.2\n#define BRIGHTNESS 1.0\n\n//Animation\n#define BOUNCE_SPEED 1.3\n#define LIGHT_SPEED 0.7\n#define CAM_ROT_SPEED 10.0\n#define BALL_HUE_SPEED 2.0\n\n//distance form a sphere\nvec4 sphereSDF(vec3 point, vec3 sphereOrigin, float sphereRadius){\n    return vec4(hue(vec3(1.0, 0.0, 0.0), iTime * BALL_HUE_SPEED), distance(point, sphereOrigin) - sphereRadius);\n}\n\n//gets the distance from the closest object\nvec4 getDist(vec3 point){\n    vec4 plane = vec4(vec3(0.0, 0.8, 0.0), point.y + snoise(vec2(point.x, point.z) * 0.03) * 2.0);\n    vec4 sphere = sphereSDF(point, vec3(0.0, abs(sin(iTime * BOUNCE_SPEED)) * 2.0 + 3.0, -9.0), 1.0);\n    \n    if (plane.a < sphere.a) return plane;\n    else return sphere;\n}\n\n//gets the normal vector of the surface\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.01,0);\n    float d = getDist(p).a;\n    vec3 normal = vec3(\n        d - getDist(p-e.xyy).a,\n        d - getDist(p-e.yxy).a,\n        d - getDist(p-e.yyx).a\n    );\n    return normalize(normal);\n}\n\n//gets the world position of the point where the ray hits something\nvec3 rayMarch(vec3 rayDir, vec3 rayOrigin){\n    vec3 pos = rayOrigin;\n    float dist = 0.0, step;\n    \n    for(int i = 0; i < MAXSTEP; i++){\n        step = getDist(pos).a;\n        dist += step;\n        pos += rayDir * step;\n        if (dist > MAXDIST || abs(step) < MINDIST){\n            pos = rayOrigin + rayDir * min(dist, MAXDIST);\n            break;\n        }\n    }\n    return pos;\n}\n\n//checks if there's something between the point and the light source and returns a returns a multiplier value to reduce the brightness\nfloat getShadows(vec3 pos, vec3 light){\n    vec3 rayDir = normalize(light - pos);\n    float lightDist = distance(light, pos), dist = 0.0, step, shadow = 1.0;\n    pos += rayDir * 0.01;\n    \n    for(int i = 0; i < MAXSTEP; i++){\n        step = getDist(pos).a;\n        shadow = min(shadow, max(0.0, step) / dist);\n        dist += step;\n        if (dist > MAXDIST || abs(step) < MINDIST) break;\n        pos += rayDir * step;\n    }\n    \n    return clamp(shadow / SOFTSHADOWS, -1.0, 1.0) * 0.5 + 0.5;\n}\n\n//calculates how close is the point to another object and returns a multiplier value to reduce the brightness\nfloat getAmbientOcclusion(vec3 pos, vec3 normal){\n    float dist = 0.0, occlusion = 0.0, multiplier = 1.0;\n    \n    for(int i = 0; i < AO_MAXSTEP; i++){\n        pos += normal * AO_STEPSIZE;\n        dist = getDist(pos).a;\n        if (abs(dist) < MINDIST) break;\n        occlusion += dist * multiplier;\n        multiplier *= 0.5;\n    }\n    \n    return clamp(occlusion * AO_MULTIPLIER, 0.0, 1.0);\n}\n\n//calculates the color of the pixel\nvec3 getLight(vec3 rayDir, vec3 rayOrigin, vec3 lightPos, vec3 lightColor){\n    vec3 pos = rayMarch(rayDir, rayOrigin);\n    float dist = distance(rayOrigin, pos);\n    vec3 lightRayDir = normalize(lightPos - pos);\n    vec3 color = getDist(pos).rgb;\n    vec3 normal = getNormal(pos);\n    \n    float lightInfluence = clamp(lightPos.y / 10.0, 0.0, 1.0) + 0.2;\n    float atmosphere = (1.0 - exp(-dist * ATM_DENSITY));\n    vec3 atmColor = mix(clamp(ATM_COLOR + 0.5, 0.0, 1.0), ATM_COLOR, clamp(pos.y / ATM_HEIGHT, 0.0, 1.0)) * lightInfluence;\n    \n    float directLight = max(dot(normal, lightRayDir), 0.0);\n    float shadows = getShadows(pos, lightPos);\n    float ambientOcclusion = getAmbientOcclusion(pos, normal);\n    \n    return max(SHADOWBRIGHT, directLight * shadows * ambientOcclusion) * color * lightColor + atmosphere * atmColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //position and direction of the camera\n    vec3 cam = vec3(0.0, 6.0, -15.5);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    //rotates the camera\n    rayDir.yz = rotateVec2(rayDir.yz, (abs(sin(iTime * BOUNCE_SPEED)) * 2.0) * 10.0 -20.0);\n    float camRotSpeed = iTime * CAM_ROT_SPEED;\n    rayDir.xz = rotateVec2(rayDir.xz, camRotSpeed);\n    cam.xz = rotateVec2(cam.xz - vec2(0.0, -9.0), camRotSpeed) + vec2(0.0, -9.0);\n    \n    //moves the light source\n    float lightSpeed = iTime * LIGHT_SPEED;\n    vec3 lightPos = vec3(cos(lightSpeed) * 70.0, 40.0, sin(lightSpeed) * 70.0 - 9.0);\n    vec3 lightColor = vec3(1.0);\n    \n    vec3 col = getLight(rayDir, cam, lightPos, lightColor);\n    \n    fragColor = vec4(pow(col, vec3(1.0 / GAMMA)) * BRIGHTNESS,1.0); //applies gamma and brightness corrections\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hue(vec3 color, float shift) {\n\tconst vec3 k = vec3(0.57735);\n\tfloat cosAngle = cos(shift);\n\treturn color * cosAngle + cross(k, color) * sin(shift) + k * dot(k, color) * (1.0 - cosAngle);\n}\n\nvec2 rotateVec2(vec2 vector, float angle){\n    angle = radians(angle);\n    return vector * mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nvec3 permute (vec3 x) {return mod(((x * 34.0) + 1.0) * x, 289.0);}\nvec3 taylorInvSqrt(vec3 r) {return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec2 P) {\n  const vec2 C = vec2(0.211324865405187134, 0.366025403784438597);\n\n  vec2 i = floor(P + dot(P, C.yy));\n  vec2 x0 = P - i + dot(i, C.xx);\n\n  vec2 i1;\n  i1.x = step(x0.y, x0.x);\n  i1.y = 1.0 - i1.x;\n  vec4 x12 = x0.xyxy + vec4(C.xx, C.xx * 2.0 - 1.0);\n  x12.xy -= i1;\n\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n\n  vec3 x = fract(p * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec3 gy = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 gx = x - ox;\n\n  m *= taylorInvSqrt(gx * gx + gy * gy);\n\n  vec3 g;\n  g.x = gx.x * x0.x + gy.x * x0.y;\n  g.yz = gx.yz * x12.xz + gy.yz * x12.yw;\n  \n  return 130.0 * dot(m, g);\n}","name":"Common","description":"","type":"common"}]}