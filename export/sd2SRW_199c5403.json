{"ver":"0.1","info":{"id":"sd2SRW","date":"1673366913","viewed":174,"name":"Refractive Ellipsoid + Caustics","username":"Holeum","description":"Refractive Ellipsoid formula visualization with soft shadow and true caustics.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["refraction","shadow","caustics","cornell","ellipsoid","soft","superellipsoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Ivan Shevchenko\n  \n  Reflective/Refractive Superellipsoid: https://www.shadertoy.com/view/7sSXRR\n  Reflective Superellipsoid: https://www.shadertoy.com/view/4dcBDH\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = texelFetch(iChannel0, ivec2(1, 0), 0);\n    int blurw = int(round(mix(0.0, 255.0, value.x)));\n    int blurh = int(round(mix(0.0, 255.0, value.y)));\n    float blurs0 = mix(0.0, 255.0, value.z);\n    float blurs1 = mix(0.0, 255.0, value.w);\n\n    cameraSetAspectRatio(camera, iResolution.x / iResolution.y);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    Ray camera_ray; cameraGetRay(camera, uv, camera_ray);\n\n    // scene rendering\n    float t = mod(0.075 * iTime, 1.0);\n    const vec3 axis0 = vec3(1.0, 0.0, 0.0);\n    const vec3 axis1 = vec3(0.0, 1.0, 0.0);\n    const vec3 axis2 = vec3(0.0, 0.0, 1.0);\n    vec3 axis = axis1;\n    mat3 orientation = mat3(AxisAngleToMatrix(normalize(axis), deg2rad(360.0 * t)));\n    subjectSetOrientation(subj, orientation);\n\n    // ray vs superellipsoid, iTime\n    vec3 ipoint = camera_ray.Direction * defaultFar;\n    vec3 normal = vec3(0.0);\n    \n    vec3 color = vec3(0.0);\n    vec3 rl_brightness = vec3(0.0);\n    vec3 rr_brightness = vec3(0.0);\n\n    vec3 Lc, Ld;\n\n    // reflection & refraction\n    bool isIntersect = subjectIntersect(subj, camera_ray, ipoint, normal);\n    if(isIntersect) {\n        // reflective part\n        pointLightParams(light, ipoint, Lc, Ld);\n        rl_brightness += normalized_blinn_phong(Lc, Ld, -camera_ray.Direction, normal, 1.0, 1.5, 256.0);\n\n        Ray reflect_ray = Ray(ipoint, reflect(camera_ray.Direction, normal));\n        vec3 ipoint2 = vec3(0.0);\n        vec3 normal2 = vec3(0.0);\n\n        //ray vs box\n        isIntersect = boxIntersect(cornellBox, reflect_ray, ipoint2, normal2);\n        if(isIntersect) {\n            pointLightParams(light, ipoint2, Lc, Ld);\n            rl_brightness += boxSideColor(cornellBox, ipoint2, normal2) * lambert(Lc, Ld, normal2);\n        }\n\n        // refractive part\n        vec3 normal0 = normal;\n        vec3 view0 = -camera_ray.Direction;\n        Ray refr_ray0 = Ray(ipoint, snell(camera_ray.Direction, normal, me.RefractiveIndex, subj.RefractiveIndex));\n        refr_ray0.Origin += M_SAFE_DISTANCE * refr_ray0.Direction;\n\n        Ray refr_ray1 = Ray(vec3(0.0), vec3(0.0));\n        isIntersect = subjectIntersect(subj, refr_ray0, refr_ray1.Origin, normal);\n\n        vec3 normal1 = -normal;\n        vec3 view1 = -refr_ray0.Direction;\n        refr_ray1.Direction = snell(refr_ray0.Direction, -normal, subj.RefractiveIndex, me.RefractiveIndex);\n        refr_ray1.Origin += M_SAFE_DISTANCE * refr_ray1.Direction;\n\n        isIntersect = boxIntersect(cornellBox, refr_ray1, ipoint, normal);\n        if(isIntersect) {\n            float Fi = fresnel(me.RefractiveIndex, subj.RefractiveIndex, max(0.0, dot(normal0, view0)));\n            float Fo = fresnel(subj.RefractiveIndex, me.RefractiveIndex, max(0.0, dot(normal1, view1)));\n            pointLightParams(light, ipoint, Lc, Ld);\n            rr_brightness += (1.0 - Fi) * (1.0 - Fo) * boxSideColor(cornellBox, ipoint, normal) * lambert(Lc, Ld, normal);\n        }\n\n        // final color\n        color = subj.ReflectColor * rl_brightness + subj.RefractColor * rr_brightness;\n    }\n    else {\n        //ray vs box\n        isIntersect = boxIntersect(cornellBox, camera_ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting\n            pointLightParams(light, ipoint, Lc, Ld);\n            vec3 brightness = lambert(Lc, Ld, normal);\n            \n            vec3 box_albedo = boxSideColor(cornellBox, ipoint, normal);\n            color = box_albedo * brightness;\n\n            // get shadow and caustics\n            vec3 shadow = vec3(1.0);\n            if(true) {\n                shadow = adaptive_gaussian_blur(blurw, blurh, blurs0, blurs1, iChannel1, iResolution.xy, fragCoord.xy);\n            }\n            else {\n                shadow = texture(iChannel1, uv).rgb;\n            }\n            color = clamp(color * shadow, vec3(0.0), vec3(1.0));\n        }\n    }\n\n    // Tone mapping\n    color = ACESFilm(color);\n\n    // Gamma correction\n    color = Linear2sRGB(color);\n\n    float vignette = pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.05);\n    fragColor = vec4(color * vignette, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x >= 2.0 || fragCoord.y >= 1.0) {\n        discard;\n    }\n    \n    vec4 value = vec4(0.0);\n    if(fragCoord.x < 1.0 && fragCoord.y <= 1.0) {\n        value = texelFetch(iChannel0, ivec2(0, 0), 0);\n        value.x = 127.0 / 255.0;\n        value.y = 51.0 / 255.0;\n    }\n    else {\n        if(fragCoord.x < 2.0 && fragCoord.y <= 1.0) {\n            value = texelFetch(iChannel0, ivec2(1, 0), 0);\n            value.x = 5.0 / 255.0;\n            value.y = 5.0 / 255.0;\n            value.z = 1.0 / 255.0;\n            value.w = 3.0 / 255.0;\n        }\n    }\n\n    fragColor = value;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n  Written by Ivan Shevchenko\n  \n  Reflective/Refractive Superellipsoid: https://www.shadertoy.com/view/7sSXRR\n  Reflective Superellipsoid: https://www.shadertoy.com/view/4dcBDH\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = texelFetch(iChannel0, ivec2(0, 0), 0);\n    int caustics_rays_num = int(round(mix(0.0, 3000.0, value.x)));\n    float att_in_shadow_zone = mix(0.0, 1.0, value.y);\n        \n    cameraSetAspectRatio(camera, iResolution.x / iResolution.y);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    Ray camera_ray; cameraGetRay(camera, uv, camera_ray);\n\n    // scene rendering\n    float t = mod(0.075 * iTime, 1.0);\n    const vec3 axis0 = vec3(1.0, 0.0, 0.0);\n    const vec3 axis1 = vec3(0.0, 1.0, 0.0);\n    const vec3 axis2 = vec3(0.0, 0.0, 1.0);\n    vec3 axis = axis1;\n    mat3 orientation = mat3(AxisAngleToMatrix(normalize(axis), deg2rad(360.0 * t)));\n    subjectSetOrientation(subj, orientation);\n\n    // caustics parameters\n    float max_extent = max(subj.HalfExtent.x, max(subj.HalfExtent.y, subj.HalfExtent.z));\n    float asigma = atan(max_extent / length((subj.Center - max_extent) - light.Position));\n    float dsigma = 0.03;\n\n    // ray vs superellipsoid\n    vec3 ipoint = camera_ray.Direction * defaultFar;\n    vec3 normal = vec3(0.0);\n    \n    vec3 color = vec3(1.0);\n    vec3 rl_brightness = vec3(0.0);\n    vec3 rr_brightness = vec3(0.0);\n\n    vec3 Lc, Ld;\n\n    // reflection & refraction\n    bool isIntersect = subjectIntersect(subj, camera_ray, ipoint, normal);\n    if(!isIntersect)\n    {\n        //ray vs box\n        isIntersect = boxIntersect(cornellBox, camera_ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting\n            pointLightParams(light, ipoint, Lc, Ld);\n\n            Ray ray = Ray(ipoint, Ld);\n            bool isIntersect = subjectIntersect(subj, ray);\n            \n            float attenuation = 1.0;\n            float amplification = 0.0;\n            if(isIntersect) {\n                attenuation = att_in_shadow_zone;\n                amplification = calc_caustics_intensity(light.Position, ipoint, me, subj, asigma, dsigma, caustics_rays_num);\n            }\n            color *= max(attenuation, amplification);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n#define M_PI 3.1415926535\n#define M_2PI 2.0 * M_PI\n#define M_SQRT_2PI sqrt(2.0 * M_PI)\n#define M_EPSILON pow(2.0, -10.0)\n#define M_SAFE_DISTANCE 10.0 * M_EPSILON\n#define M_TOLERANCE 0.00001\n\n#define InitialStepFactor 1.0 / 128.0\n#define TorchColor vec3(1.0, 1.0, 1.0)\n\nconst mat4 Identity = mat4(1.0, 0.0, 0.0, 0.0,\n                           0.0, 1.0, 0.0, 0.0,\n                           0.0, 0.0, 1.0, 0.0,\n                           0.0, 0.0, 0.0, 1.0);\n\n//vec3 P = vec3(0.0, 0.0, 1.05); // default viewer position\nconst mat4 defaultInvView = mat4(1.0, 0.0, 0.0, 0.0,\n                                 0.0, 1.0, 0.0, 0.0,\n                                 0.0, 0.0, 1.0, 0.0,\n                                 0.0, 0.0, 1.075, 1.0);\n\n//float fovy = 90.0;\n//float aspect = 1.0\nconst float defaultNear = 0.1;\nconst float defaultFar = 32.0;\nconst mat4 defaultInvProj = mat4(1.0, 0.0,  0.0,  0.0,\n                                 0.0, 1.0,  0.0,  0.0,\n                                 0.0, 0.0,  0.0, -4.984375,\n                                 0.0, 0.0, -1.0,  5.015625);\n\nconst vec3 PLANECOLOR[6] = vec3[6](vec3(180.0, 16.0 , 18.0 ) / 255.0,  // right\n                                   vec3(51.0 , 180.0, 50.0 ) / 255.0,  // left\n                                   vec3(241.0, 241.0, 212.0) / 255.0,  // top\n                                   vec3(241.0, 241.0, 212.0) / 255.0,  // bottom\n                                   vec3(180.0, 180.0, 180.0) / 255.0,  // near\n                                   vec3(54.0 , 117.0, 135.0) / 255.0); // far\n\n\n// ------------------ Miscellaneous ----------------------\nuvec2 prng_state = uvec2(521288629u, 362436069u);\nuint rand() {\n    prng_state = uvec2(18000u, 36969u) * (prng_state & uvec2(65535u, 65535u)) + (prng_state >> uvec2(16u, 16u));\n    return((prng_state.x << 16u) + prng_state.y);\n}\nfloat random01() {\n    return(float(rand()) / 4294967295.0);\n}\nvoid rand_init(in uvec2 state) {\n    prng_state = uvec2(521288629u, 362436069u);\n    rand();\n    prng_state += state;\n    rand();\n}\n\nfloat sgn(in float x) {\n    return((x < 0.0)? -1.0: 1.0);\n}\nvec3 sgn(in vec3 v) {\n    return(vec3(sgn(v.x), sgn(v.y), sgn(v.z)));\n}\n\nfloat deg2rad(in float deg)\n{\n    return(deg * M_PI / 180.0);\n}\n\nfloat infinite2unit(in float x)\n{\n    x = abs(x);\n    return(sqrt(x / (1.0 + x)));\n}\n\nfloat normpdf(in float x, in float sigma) {\n    return(exp(-0.5 * (x * x) / (sigma * sigma)) / (sigma * M_SQRT_2PI));\n\n}\n\nvec3 gaussian_blur(in int width, in int height, in float sigma, in sampler2D sampler, in vec2 resolution, in vec2 frag_coord) {\n    float Z = 0.0;\n    vec3 value = vec3(0.0);\n\n    for(int i = -height; i <= height; ++i) {\n        float fi = float(i);\n        float ypdf = normpdf(fi, sigma);\n        Z += ypdf;\n\n        for(int j = -width; j <= width; ++j) {\n            float fj = float(j);\n            float xpdf = normpdf(fj, sigma);\n            value += ypdf * xpdf * texture(sampler, (frag_coord + vec2(fi, fj)) / resolution).rgb;\n        }\n    }\n    value /= (Z * Z);\n    \n    return(value);\n}\nvec3 adaptive_gaussian_blur(in int width, in int height, in float sigma0, in float sigma1, in sampler2D sampler, in vec2 resolution, in vec2 frag_coord) {\n    vec3 v = texture(sampler, frag_coord / resolution).rgb;\n    float sigma = mix(sigma0, sigma1, clamp(length(v), 0.0, 1.0));\n    return(gaussian_blur(width, height, sigma, sampler, resolution, frag_coord));\n}\n\n// point P0 to line (P1, s) distance \nfloat point2line(in vec3 P0, in vec3 P1, in vec3 s)\n{\n    return(max(M_EPSILON, length(cross(P1 - P0, s))) / max(M_EPSILON, length(s)));\n}\n\nvec3 snell(in vec3 s, in vec3 n, in float n1, in float n2) {\n\tfloat r1 = n1 / n2;\n\tfloat r2 = r1 * r1;\n\tfloat d = dot(n, s);\n\n    vec3 v1 = (s - (d * n)) *  r1;\n    vec3 v2 = sqrt(1.0 - r2 * (1.0 - d * d)) * n;\n    \n    vec3 r = v1 - v2;\n\treturn(r);\n}\n\nfloat fresnel(in float etha_i, in float etha_t, in float cos_theta)\n{\n    float cos_i = cos_theta;\n\n    // Compute sin_t using Snell's law    \n    float sin_t = (etha_i / etha_t) * sqrt(max(0.0, 1.0 - cos_i * cos_i)); \n\n    float F = 1.0; // Total internal reflection\n    if(sin_t < 1.0)\n    { \n        float cos_t = sqrt(max(0.0, 1.0 - sin_t * sin_t)); \n        cos_i = abs(cos_i); \n        float Rs = ((etha_t * cos_i) - (etha_i * cos_t)) / ((etha_t * cos_i) + (etha_i * cos_t)); \n        float Rp = ((etha_i * cos_i) - (etha_t * cos_t)) / ((etha_i * cos_i) + (etha_t * cos_t)); \n        F = (Rs * Rs + Rp * Rp) / 2.0; \n    }\n    return(F);\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 Linear2sRGB(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n// ------------------ Miscellaneous ----------------------\n\n\n// ------------------ BLAS/LAPACK elements ----------------------\nmat4 QuaternionToMatrix(vec4 q)\n{\n    mat4 m1 = mat4( q.w,  q.z, -q.y, q.x,\n                   -q.z,  q.w,  q.x, q.y,\n                    q.y, -q.x,  q.w, q.z,\n                   -q.x, -q.y, -q.z, q.w);\n\n    mat4 m2 = mat4( q.w,  q.z, -q.y, -q.x,\n                   -q.z,  q.w,  q.x, -q.y,\n                    q.y, -q.x,  q.w, -q.z,\n                    q.x,  q.y,  q.z,  q.w);\n\n    mat4 m = m1 * m2;\n\n    return(m);\n}\n\nmat4 AxisAngleToMatrix(vec3 axis, float angle)\n{\n    float s = sin(angle / 2.0);\n    float c = cos(angle / 2.0);\n\n    vec4 q = vec4(s, s, s, c);\n    q.x *= axis.x;\n    q.y *= axis.y;\n    q.z *= axis.z;\n\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n\n// pitch (attitude) - rotation around X-axis\n// yaw (heading)    - rotation around Y-axis\n// roll (bank)      - rotation around Z-axis\nmat4 EulerToMatrix(float pitch, float yaw, float roll)\n{\n    // The definition can be found in glm/gtc/quaternion.hpp\n    vec3 c = vec3(cos(pitch / 2.0), cos(yaw / 2.0), cos(roll / 2.0));\n    vec3 s = vec3(sin(pitch / 2.0), sin(yaw / 2.0), sin(roll / 2.0));\n\n    vec4 q = vec4(0.0);\n\n    // XYZ ordering\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n\n    //q = normalize(q);\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n// ------------------ BLAS/LAPACK elements ----------------------\n\n\n// ------------------ Ray ------------------\nstruct Ray {\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\nvoid rayConstruct(vec2 uv, mat4 invProj, mat4 invView, inout Ray ray) {\n    // Ray in screen space\n    vec2 sXY = 2.0 * uv - 1.0;\n    vec4 sP0 = vec4(sXY, -1.0, 1.0);\n    vec4 sP1 = vec4(sXY,  1.0, 1.0);\n\n    // Ray in world space\n    vec4 wP0 = invProj * sP0; wP0 /= wP0.w;\n    vec4 wP1 = invProj * sP1; wP1 /= wP1.w;\n   \n    wP0 = invView * wP0;\n    wP1 = invView * wP1;\n    \n    ray.Origin = invView[3].xyz;\n    ray.Direction = normalize(wP1.xyz - wP0.xyz);\n}\n// ------------------ Ray ------------------\n\n\n// ------------------ Plane ------------------\nstruct Plane\n{\n\tvec3 M;\n\tvec3 Normal;\n};\n\nvoid planeConstruct(vec3 point, vec3 normal, inout Plane pl)\n{\n    pl.M = point;\n    pl.Normal = normal;    \n}\n\nbool planeIntersect(Plane pl, Ray ray)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    return(true);\n}\n\nbool planeIntersect(Plane pl, Ray ray, out vec3 ipos, out vec3 norm)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    ipos = ray.Origin + t * ray.Direction;\n    norm = pl.Normal;\n\n    return(true);\n}\n// ------------------ Plane ------------------\n\n\n// ------------------ Box ------------------\nstruct Box\n{\n\tvec3 Center;\n\tvec3 HalfExtent;\n    mat3 Orientation;\n};\n\nvoid boxConstruct(in vec3 center, in vec3 halfextent, inout Box box)\n{\n    box.Center = center;\n    box.HalfExtent = halfextent;\n    box.Orientation = mat3(1.0);\n}\n\nbool boxIntersect(in Box box, in Ray ray)\n{\n    // OBB -> AABB\n    vec3 bmin = -box.HalfExtent;\n    vec3 bmax =  box.HalfExtent;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(box.Orientation);\n    vec3 ori = invm * (ray.Origin - box.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 v1 = (bmin - ori) / dir;\n    vec3 v2 = (bmax - ori) / dir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    return(t >= 0.0);\n}\n\nbool boxIntersect(in Box box, in Ray ray, out vec3 ipoint, out vec3 inormal)\n{\n    // OBB -> AABB\n    vec3 bmin = -box.HalfExtent;\n    vec3 bmax =  box.HalfExtent;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(box.Orientation);\n    vec3 pos = invm * (ray.Origin - box.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = sgn(dir);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (bmin - pos) * idir;\n    vec3 v2 = (bmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    vec3 lp = pos + t * dir;\n\n    vec3 d = abs(abs(lp) - box.HalfExtent);\n    float nx = (d.x > M_EPSILON)? 0.0: sgn(lp.x);\n    float ny = (d.y > M_EPSILON)? 0.0: sgn(lp.y);\n    float nz = (d.z > M_EPSILON)? 0.0: sgn(lp.z);\n    vec3 ln = -vec3(nx, ny, nz);\n\n    ipoint = box.Orientation * lp + box.Center;\n    inormal = box.Orientation * ln;\n\n    return(t >= 0.0);\n}\n\nvec3 boxSideColor(in Box box, in vec3 P, in vec3 N)\n{\n    int xindex = (N.x > 1.0 - M_EPSILON)? 2: ((N.x < -1.0 + M_EPSILON)? 1: 0);\n    int yindex = (N.y > 1.0 - M_EPSILON)? 4: ((N.y < -1.0 + M_EPSILON)? 3: 0);\n    int zindex = (N.z > 1.0 - M_EPSILON)? 6: ((N.z < -1.0 + M_EPSILON)? 5: 0);\n    int index = max(xindex, max(yindex, zindex)) - 1;\n\n    P -= box.Center;\n\n    float a = 1.0;\n    if(index == 3) {\n        float f = mod(floor(6.0 * P.z) + floor(6.0 * P.x), 2.0);\n        a = 0.2 + f * 0.8;\n    }\n    \n    P = min(vec3(1.0), abs(P) / box.HalfExtent);\n    float b = max(P.x, P.y);\n    float c = max(P.y, P.z);\n    float d = max(P.z, P.x);\n    float e = mix(1.0, 0.25, pow(b * c * d, 64.0));\n\n    return(PLANECOLOR[index] * a * e);\n}\n// ------------------ Box ------------------\n\n\n// ------------------ Medium ------------------\nstruct Medium\n{\n    float RefractiveIndex;\n};\n// ------------------ Medium ------------------\n\n\n// ------------------ Subject ------------------\n// Ellipsoid\nstruct Subject\n{\n    float RefractiveIndex;\n    vec3 ReflectColor;\n    vec3 RefractColor;\n\n    vec3 Center;\n\tvec3 HalfExtent;\n    mat3 Orientation;\n};\n\nvoid subjectSetHalfExtent(inout Subject subj, in vec3 radius) {\n    subj.HalfExtent = radius;\n}\nvoid subjectSetOrientation(inout Subject subj, in mat3 orientation) {\n    subj.Orientation = orientation;\n}\n\nbool subjectIntersect(in Subject subj, Ray ray) {\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(subj.Orientation);\n    vec3 pos = invm * (ray.Origin - subj.Center);\n    vec3 dir = invm * ray.Direction;\n\n    // Hit points with AABB\n    vec3 invr2 = vec3(1.0) / (subj.HalfExtent * subj.HalfExtent);\n    float a = dot(dir * dir, invr2);\n    float b = 2.0 * dot(pos * dir, invr2);\n    float c = dot(pos * pos, invr2) - 1.0;\n    \n    float b2 = b * b;\n    float D = b2 - 4.0 * a * c;\n    if(D < 0.0 || (b > 0.0 && b2 > D)) {\n        return(false);\n    }\n    return(true);\n}\n\nbool subjectIntersect(in Subject subj, Ray ray, out vec3 ipos, out vec3 norm) {\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(subj.Orientation);\n    vec3 pos = invm * (ray.Origin - subj.Center);\n    vec3 dir = invm * ray.Direction;\n\n    // Hit points with AABB\n    vec3 invr2 = vec3(1.0) / (subj.HalfExtent * subj.HalfExtent);\n    float a = dot(dir * dir, invr2);\n    float b = 2.0 * dot(pos * dir, invr2);\n    float c = dot(pos * pos, invr2) - 1.0;\n    \n    float b2 = b * b;\n    float D = b2 - 4.0 * a * c;\n    if(D < 0.0 || (b > 0.0 && b2 > D)) {\n        return(false);\n    }\n\n    float inv2a = 1.0 / (2.0 * a);\n    float SD = sqrt(D);\n    \n    float tn = (-b - SD) * inv2a;\n    float tf = (-b + SD) * inv2a;\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n\n    vec3 lpos = pos + t * dir;\n    vec3 lnrm = normalize(2.0 * lpos * invr2);\n    ipos = subj.Orientation * lpos + subj.Center;\n    norm = subj.Orientation * lnrm;// always external normal!\n    \n    return(true);\n}\n\n/*\n// Glass Box\nbool subjectIntersect(in Subject subj, in Ray ray)\n{\n    // OBB -> AABB\n    vec3 bmin = -subj.HalfExtent;\n    vec3 bmax =  subj.HalfExtent;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(subj.Orientation);\n    vec3 pos = invm * (ray.Origin - subj.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = sgn(dir);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (bmin - pos) * idir;\n    vec3 v2 = (bmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    return(t >= 0.0);\n}\n\nbool subjectIntersect(in Subject subj, in Ray ray, out vec3 ipoint, out vec3 inormal)\n{\n    // OBB -> AABB\n    vec3 bmin = -subj.HalfExtent;\n    vec3 bmax =  subj.HalfExtent;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(subj.Orientation);\n    vec3 pos = invm * (ray.Origin - subj.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = sgn(dir);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (bmin - pos) * idir;\n    vec3 v2 = (bmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    vec3 lp = pos + t * dir;\n\n    vec3 d = abs(abs(lp) - subj.HalfExtent);\n    float nx = (d.x > M_EPSILON)? 0.0: sgn(lp.x);\n    float ny = (d.y > M_EPSILON)? 0.0: sgn(lp.y);\n    float nz = (d.z > M_EPSILON)? 0.0: sgn(lp.z);\n    vec3 ln = vec3(nx, ny, nz);\n\n    ipoint = subj.Orientation * lp + subj.Center;\n    inormal = subj.Orientation * ln;\n\n    return(t >= 0.0);\n}\n*/\n// ------------------ Subject ------------------\n\n\n// ------------------ Camera ----------------------\nstruct Camera\n{\n    mat4 invView;\n    mat4 invProj;\n};\n\nvoid cameraConstruct(in float fovy, in float aspect, in float near, in float far, inout Camera camera)\n{\n    camera.invView = mat4(1.0);\n\n    fovy = deg2rad(fovy);\n    float d = 1.0 / tan(0.5 * fovy);\n    camera.invProj = mat4(aspect / d, 0.0,      0.0, 0.0,\n                          0.0,        1.0 / d,  0.0, 0.0,\n                          0.0,        0.0,      0.0, (near - far) / (2.0 * near * far),\n                          0.0,        0.0,     -1.0, (near + far) / (2.0 * near * far));\n}\n\nvoid cameraSetPosition(inout Camera camera, vec3 origin) {\n    camera.invView[3] = vec4(origin, 1.0);\n}\nvoid cameraSetOrientation(inout Camera camera, float pitch, float yaw, float roll) {\n    pitch = deg2rad(pitch);\n    yaw = deg2rad(yaw);\n    roll = deg2rad(roll);\n    \n    mat4 m = camera.invView;\n    camera.invView = EulerToMatrix(pitch, yaw, roll);\n    camera.invView[3] = m[3];\n}\n\nvoid cameraSetAspectRatio(inout Camera camera, float aspect) {\n    camera.invProj[0][0] = aspect * camera.invProj[1][1];\n}\nvoid cameraSetFOV(inout Camera camera, float fovy) {\n    float aspect = camera.invProj[0][0] / camera.invProj[1][1];\n    camera.invProj[1][1] = tan(0.5 * deg2rad(fovy));\n    camera.invProj[0][0] = aspect * camera.invProj[1][1];\n}\nvoid cameraSetAspectRatioAndFOV(inout Camera camera, float aspect, float fovy) {\n    camera.invProj[1][1] = tan(0.5 * deg2rad(fovy));\n    camera.invProj[0][0] = aspect * camera.invProj[1][1];\n}\nvoid cameraSetNearAndFar(inout Camera camera, float near, float far) {\n    camera.invProj[2][3] = (near - far) / (2.0 * near * far);\n    camera.invProj[3][3] = (near + far) / (2.0 * near * far);\n}\n\n\nvoid cameraGetRay(Camera camera, vec2 uv, inout Ray ray) {\n    rayConstruct(uv, camera.invProj, camera.invView, ray);\n}\n// ------------------ Camera ----------------------\n\n\n// ------------------ Lighting ------------------\nstruct PointLight\n{\n\tvec3 Color;\n\tvec3 Position;\n    float a; // const attenuation factor\n    float b; // linear attenuation factor\n    float c; // exponential attenuation factor\n};\n\nvoid pointLightParams(PointLight light, vec3 dst, out vec3 color, out vec3 dir) {\n    dir = light.Position - dst;\n    float dist = length(dir);\n    dir.xyz /= dist;    \n\n    color = light.Color / (light.a + dist * (light.b + light.c * dist));\n}\n\nvec3 lambert(vec3 I, vec3 L, vec3 N) {\n    float NdotL = dot(N, L);\n    vec3 brightness = max(0.0, NdotL) * (I / M_PI);\n    return(brightness);\n}\n\nvec3 normalized_blinn_phong(vec3 I, vec3 L, vec3 V, vec3 N, float etha_i, float etha_t, float alpha)\n{\n    vec3 H = normalize(L + V);\n    float NdotL = dot(N, L);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n    float F = fresnel(etha_i, etha_t, LdotH);\n\n    vec3 brightness = ((alpha + 2.0) / 8.0) * pow(max(NdotH, 0.0), alpha) * F * (max(0.0, NdotL) * I);\n    return(brightness);\n}\n// ------------------ Lighting ------------------\n\n// ------------------ Caustics Solver ------------------\n// trick with Householder matrix to construct two orthogonal vectors in plane\n// https://math.stackexchange.com/questions/64430/find-extra-arbitrary-two-points-for-a-plane-given-the-normal-and-a-point-that-l\n// https://ru.stackoverflow.com/questions/1193785/%D0%A1%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D1%8B%D0%B9-%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80-%D0%B2-%D0%BF%D0%BE%D0%BB%D1%83%D1%81%D1%84%D0%B5%D1%80%D0%B5-%D0%B2-%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B0%D1%85-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D1%83%D0%B3%D0%BB%D0%B0-%D0%BD%D0%B0%D0%B8%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B0%D0%BB%D0%B3\nfloat calc_caustics_intensity(in vec3 src,\n                              in vec3 dst,\n                              in Medium md,\n                              in Subject subj,\n                              in float asigma,\n                              in float dsigma,\n                              in int points_num)\n{\n    uvec2 seed;\n    seed.x = uint((dst.x < 0.0)? -521288629.0 * dst.x: 362436069.0 * dst.x);\n    seed.y = uint((dst.y < 0.0)? -362436069.0 * dst.y: 521288629.0 * dst.y);\n    rand_init(seed);\n    \n    vec3 A = normalize(subj.Center - src);\n    vec3 w1 = A; w1.x += 1.0;\n    vec3 w2 = A; w2.x -= 1.0;\n    vec3 w = normalize((abs(w1.x) > abs(w2.x))? w1: w2);\n    \n    mat3 I = mat3(1.0, 0.0, 0.0,\n                  0.0, 1.0, 0.0,\n                  0.0, 0.0, 1.0);\n\n    float c = 2.0 / dot(w, w);\n    mat3 H = I - mat3((c * w.x) * w, (c * w.y) * w, (c * w.z) * w);\n\n    // Main logic\n    float Ci = 0.0;\n    float Ci_norm_factor = sqrt(1.0 / float(points_num));\n    \n    bool is_intersect = false;\n    vec3 iP;\n    vec3 iN;\n    Ray ray;\n    \n    while(points_num > 0) {\n        while(!is_intersect) {\n            float phi = M_2PI * random01();\n            vec3 D = H[1] * cos(phi) + H[2] * sin(phi);\n            \n            float theta = asigma * random01();\n            vec3 E = A * cos(theta) + D * sin(theta); // probe light ray direction\n\n            ray = Ray(src, E);\n            is_intersect = subjectIntersect(subj, ray, iP, iN);\n        }\n\n        ray.Direction = snell(ray.Direction, iN, md.RefractiveIndex, subj.RefractiveIndex);\n        ray.Origin = iP + M_SAFE_DISTANCE * ray.Direction;\n        float Fi = fresnel(md.RefractiveIndex, subj.RefractiveIndex, max(0.0, dot(iN, -ray.Direction)));\n\n        is_intersect = subjectIntersect(subj, ray, iP, iN);\n        if(is_intersect) {\n            ray.Direction = snell(ray.Direction, -iN, subj.RefractiveIndex, md.RefractiveIndex);\n            ray.Origin = iP + M_SAFE_DISTANCE * ray.Direction;            \n            float Fo = fresnel(subj.RefractiveIndex, md.RefractiveIndex, max(0.0, dot(-iN, -ray.Direction)));\n\n            // intensity propagation factor\n            float d = point2line(dst, ray.Origin, ray.Direction);\n            Ci += (1.0 - Fi) * (1.0 - Fo) * normpdf(d, dsigma);\n            \n            --points_num;\n        }\n        is_intersect = false;\n    } \n    Ci *= Ci_norm_factor;\n\n    return(Ci);\n}\n// ------------------ Caustics Solver ------------------\n\n\nconst PointLight light = PointLight(TorchColor, vec3(0.75, 0.75, 1.0), 0.0, 0.0, 0.15);\nconst Box cornellBox = Box(vec3(0.0, 0.0, 0.0), vec3(1.1, 1.1, 1.1), mat3(1.0));\nconst Medium me = Medium(1.0); // medium\n\n\nSubject subj = Subject(1.5,\n                       vec3(1.0),\n                       vec3(0.53, 0.81, 0.92),\n                       vec3(0.0, 0.0, 0.0),\n                       vec3(0.36, 0.36, 0.05),\n                       mat3(Identity));\n\nCamera camera = Camera(defaultInvView, defaultInvProj);\n\n\n\n\n\n\n\n\n\n/*\n// ------------------ Superellipsoid ------------------\nstruct Superellipsoid\n{\n    float RefractiveIndex;\n    vec3 ReflectColor;\n    vec3 RefractColor;\n\n    vec3 Center;\n\tvec3 Radius;\n    vec3 Exponent;\n    mat3 Orientation;    \n};\n\nvoid superellipsoidSetExponent(inout Superellipsoid se, in vec3 exponent) {\n    se.Exponent = exponent;\n}\n\nvoid superellipsoidSetOrientation(inout Superellipsoid se, in mat3 orientation) {\n    se.Orientation = orientation;\n}\n\n// Superellipsoid Inside-Outside Function\nfloat superellipsoidIOF(Superellipsoid se, vec3 pos, vec3 dir, float t) {\n    vec3 ee = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 ir = vec3(1.0) / se.Radius;\n\n    vec3 p = pos + t * dir;\n    vec3 A = p * ir;\n    vec3 B = pow(A * A, ee.xxy);\n    float E = B.x + B.y;\n    float F = pow(E, ee.z);\n    float P = F + B.z;\n    return(P - 1.0);\n}\n\nvec3 superellipsoidNormal(Superellipsoid se, vec3 p) {\n    vec3 ee = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 ir = vec3(1.0) / se.Radius;\n\n    vec3 A = p * ir;\n    vec3 B = pow(A * A, ee.xxy);\n    vec3 C = B / A;\n\n    float E = B.x + B.y;\n    float F = pow(E, ee.z);\n    float G = ee.z * (F / E);\n\n    vec3 n = (2.0 * ee.xxy) * (C * ir);\n    n.xy *= G;\n\n    n = normalize(n);\n    return(n);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance, int MAXIters) {\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = sgn(dir);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (vmin - pos) * idir;\n    vec3 v2 = (vmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative procedure of finding intersection point with superellipsoid    \n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = -2.0 * dt + ((tn < 0.0)? tf: tn);\n    float t1 = -1.0 * dt + ((tn < 0.0)? tf: tn);\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(se, pos, dir, t0);\n    float S1 = superellipsoidIOF(se, pos, dir, t1);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(se, pos, dir, t1);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n            break;\n        }\n    }    \n    return(success);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance, int MAXIters, out vec3 ipos, out vec3 norm) {\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = sgn(dir);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (vmin - pos) * idir;\n    vec3 v2 = (vmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid\n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = -2.0 * dt + ((tn < 0.0)? tf: tn);\n    float t1 = -1.0 * dt + ((tn < 0.0)? tf: tn);\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(se, pos, dir, t0);\n    float S1 = superellipsoidIOF(se, pos, dir, t1);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(se, pos, dir, t1);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n        \n            vec3 lpos = pos + t1 * dir;\n            norm = superellipsoidNormal(se, lpos); // always external normal!\n            ipos = se.Orientation * lpos + se.Center;\n            norm = se.Orientation * norm;\n            break;\n        }\n    }\n\n    return(success);\n}\n// ------------------ Superellipsoid ------------------\n\n// attention new exponent was redefined\nvec4 superellipsoidImplicitForm(in Superellipsoid se, in vec3 p) {\n    vec3 r2 = se.Radius * se.Radius;\n    vec3 rp = p - se.Center;\n    if(abs(rp.x) < M_EPSILON) rp.x = sgn(rp.x) * M_EPSILON;\n    if(abs(rp.y) < M_EPSILON) rp.y = sgn(rp.y) * M_EPSILON;\n    if(abs(rp.z) < M_EPSILON) rp.z = sgn(rp.z) * M_EPSILON;\n\n    vec3 p2 = rp * rp;\n    vec3 s = p2 / r2;\n\n    vec3 D = vec3(0.0);\n    D.x = pow(s.x, 1.0 / se.Exponent.x); // 1 / r\n    D.y = pow(s.y, 1.0 / se.Exponent.x); // 1 / r\n    D.z = pow(s.z, 1.0 / se.Exponent.y); // 1 / t\n\n    vec3 c = (2.0 / se.Exponent.y) * (D / rp);\n    float W = pow(D.x + D.y, se.Exponent.x / se.Exponent.y - 1.0);\n    \n    vec4 ret = vec4(c.xy * W, c.z, pow(D.x + D.y, se.Exponent.x / se.Exponent.y) + D.z);\n    return(ret);\n}\n\nvec4 IoR(in Medium md, in Superellipsoid se, in vec3 pos, in float trans_coeff, in float trans_power) {\n    vec3 o = pos - se.Center;\n\n    vec4 sif = superellipsoidImplicitForm(se, pos);\n\n    float F = exp(-trans_coeff * pow(sif.w, trans_power));\n    float C = -trans_coeff * trans_power * F * pow(sif.w, trans_power - 1.0);\n    sif.xyz *= C;\n\n    float dn = se.RefractiveIndex - md.RefractiveIndex;\n    vec4 grad_rf = vec4(dn * sif.xyz, md.RefractiveIndex + dn * F);\n    return(grad_rf);\n}\n\nbool calc_caustics_ray_path(in vec3 src,\n                            in vec3 dst,\n                            in Medium md,\n                            in Superellipsoid se,\n                            in float dt2dl,\n                            in float tolerance,\n                            in float trans_coeff,\n                            in float trans_power,\n                            in int points_num,\n                            in int cs_iters_max,\n                            in int is_iters_max,\n                            out vec3 iP,\n                            out vec3 oP,\n                            out vec3 iN,\n                            out vec3 oN,\n                            out vec3 iD,\n                            out vec3 oD)\n{\n    vec4 a[N_MAX];\n    vec3 b[N_MAX];\n    vec3 c[N_MAX];\n    vec3 d[N_MAX];\n    vec3 e[N_MAX];\n    vec3 f[N_MAX];\n    vec3 g[N_MAX];\n    \n    vec3 src2dst = dst - src;\n    float L0 = length(src2dst);\n    \n    Ray ray = Ray(src, src2dst / L0);\n    if(!superellipsoidIntersect(se, ray, tolerance, is_iters_max)) {\n        return(false);\n    }\n    \n    float T0 = L0 * L0;\n    float dl = 1.0 / float(points_num - 1);\n    float dt = dt2dl * dl;\n\n    float c0 = 1.0 / dt;\n    float c1 = dt * L0 / 2.0;\n\n    // first approximation (normalized space)\n    for(int i = 0; i < points_num; i++) {\n        float t = float(i) * dl;\n        vec3 p = (src + (t * src2dst)) / L0;\n        e[i] = p;\n        f[i] = p;\n        g[i] = p;\n    }\n\n    float error = 1.0;\n    for(int iters_num = 0; (iters_num < cs_iters_max) && (error > tolerance); iters_num++) {\n        a[0] = vec4(g[0], md.RefractiveIndex);\n        for(int i = 1; i < points_num - 1; i++) {\n            vec4 ior = IoR(md, se, L0 * g[i], trans_coeff, trans_power);\n            a[i] = vec4(c0 * distance(g[i - 1], g[i + 1]) * (f[i] - e[i] / 4.0 - c1 * ior.xyz), ior.w);\n        }\n        a[points_num - 1] = vec4(g[points_num - 1], md.RefractiveIndex);\n\n        // fill diagonals\n        b[0] = vec3(0.0);\n        c[0] = vec3(1.0);\n        d[0] = vec3(0.0);\n        for(int i = 1; i < points_num - 1; i++) {\n            vec3 g_1 = g[i - 1];\n            vec3 g0  = g[i    ];\n            vec3 g1  = g[i + 1];\n\n            vec4 a_1 = a[i - 1];\n            vec4 a0  = a[i    ];\n            vec4 a1  = a[i + 1];\n        \n            float dl0 = distance(g_1, g1);\n            float dl1 = distance(g_1, g0);\n            float dl2 = distance(g0,  g1);\n\n            float rf1 = (a_1.w + a0.w) / 2.0;\n            float rf2 = (a0.w  + a1.w) / 2.0;\n\n            float v0 = -rf1 / dl1;\n            float v1 = (rf1 / dl1 + rf2 / dl2 + (3.0 / 4.0) * c0 * dl0);\n            float v2 = -rf2 / dl2;\n\n            b[i] = vec3(v0);\n            c[i] = vec3(v1);\n            d[i] = vec3(v2);\n        }\n        b[points_num - 1] = vec3(0.0);\n        c[points_num - 1] = vec3(1.0);\n        d[points_num - 1] = vec3(0.0);\n\n        // tridiagonal solver\n        //for(int i = 1; i < points_num; i++) {\n        //    vec3 m = b[i] / c[i - 1];\n        //    c[i] -= m * d[i - 1];\n        //    a[i].xyz -= m * a[i - 1].xyz;\n        //}\n        //g[points_num - 1] = a[points_num - 1].xyz / c[points_num - 1];\n        //for(int i = points_num - 2; i >= 0; i--) {\n        //    g[i] = (a[i].xyz - (d[i] * g[i + 1])) / c[i];\n        //}\n\n        for(int i = 1; i < points_num; i++) {\n            vec2 m = b[i].yz / c[i - 1].yz;\n            c[i].yz -= m * d[i - 1].yz;\n            a[i].yz -= m * a[i - 1].yz;\n        }\n        g[points_num - 1].yz = a[points_num - 1].yz / c[points_num - 1].yz;\n        for(int i = points_num - 2; i >= 0; i--) {\n            g[i].yz = (a[i].yz - (d[i].yz * g[i + 1].yz)) / c[i].yz;\n        }\n\n\n        // error estimator\n        error = 0.0;\n        for(int i = 1; i < points_num - 1; i++) {\n            float fm0 = length(f[i]);\n            float fm1 = length(g[i]);\n            float dfm = (fm1 - fm0) / max(tolerance, max(fm0, fm1));\n            error += dfm * dfm;\n\n            e[i] = f[i];\n            f[i] = g[i];\n        }\n        error = sqrt(error / float(points_num - 3));\n    }\n\n    // restore the ray path in world space\n    int ray_points = 1 + (points_num / 2) / 10;\n\n    Ray iR = Ray(f[0] * L0, vec3(0.0));\n    Ray oR = Ray(f[points_num - 1] * L0, vec3(0.0));\n\n    vec3 iP0 = iR.Origin;\n    vec3 oP0 = oR.Origin;\n    for(int i = 1; i < ray_points; i++) {\n        vec3 iP1 = f[i] * L0;\n        vec3 oP1 = f[(points_num - 1) - i] * L0;\n        iR.Direction = iR.Direction + (iP1 - iP0);\n        oR.Direction = oR.Direction + (oP1 - oP0);\n        iP0 = iP1;\n        oP0 = oP1;\n    }\n    iR.Direction = normalize(iR.Direction / float(ray_points - 1));\n    oR.Direction = normalize(oR.Direction / float(ray_points - 1));\n    iD = iR.Direction;\n    oD = oR.Direction;\n    \n    bool is_intersect = error <= tolerance;\n    is_intersect = is_intersect && superellipsoidIntersect(se, iR, tolerance, is_iters_max, iP, iN);\n    is_intersect = is_intersect && superellipsoidIntersect(se, oR, tolerance, is_iters_max, oP, oN);\n\n    return(is_intersect);\n}\n*/\n\n","name":"Common","description":"","type":"common"}]}