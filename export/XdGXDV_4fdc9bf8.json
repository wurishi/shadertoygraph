{"ver":"0.1","info":{"id":"XdGXDV","date":"1466635187","viewed":751,"name":"Mandelbox Flythrough","username":"zackpudil","description":"A simple mandelbox flythrough. Click and hold to change the camera trajectory. ","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cdot(a, b) clamp(dot(a, b), 0.0, 1.0)\n\nconst float PI = 3.14159265359;\nconst float tmax = 100.0;\n\n// mat2(cos(1), sin(1), -sin(1), cos(1))\nconst mat2 rot = mat2(0.54030230586, 0.8414709848 , -0.8414709848, 0.54030230586);\n\nvec2 shape(vec3 p) {\n    float a = length(abs(p.xz) - vec2(2, 1.9)) - 75.5;\n    float b = length(abs(p.xy) - vec2(1.9, 2)) - 75.0;\n    float c = length(abs(p.yz) - vec2(2, 1.9)) - 75.1;\n    \n    vec2 res = vec2(min(a, b), a < b ? 1.0 : 2.0);\n    return res.x < c ? res : vec2(c, 3.0);\n}\n\nvec4 orb;\nvec2 map(vec3 p) {\n\tp.x = mod(p.x + 1.0, 2.0) - 1.0;\n\tvec4 q = vec4(p, 1.0);\n\tvec4 o = q;\n\t\n    orb = vec4(1000.0);\n\tfor(int i = 0; i < 12; i++) {\n\t\tq.zy = rot*q.zy;\n\t\tq.xyz = clamp(q.xyz, -1.0, 1.0)*2.0 - q.xyz;\n\t\tq /= clamp(dot(q.xyz, q.xyz), 0.1, 1.0);\n        \n\t\tq = (3.5)*q - o;\n    }\n\n\treturn (shape(q.xyz))/vec2(q.w, 1.0);\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\tfloat m = 0.0;\n\n\tfor(int i = 0; i < 250; i++) {\n\t\tvec2 d = map(ro + rd*t);\n\t\tif(d.x < 0.001*(1.0+t) || t >= tmax) break;\n\t\tt += 0.4*d.x;\n        m = d.y;\n\t}\n\n\treturn vec2(t, m);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.0001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy).x - map(p - h.xyy).x,\n\t\tmap(p + h.yxy).x - map(p - h.yxy).x,\n\t\tmap(p + h.yyx).x - map(p - h.yyx).x\n\t);\n\treturn normalize(n);\n}\n\n\nvec4 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    \n    vec4 x = texture(s, p.yz);\n    vec4 y = texture(s, p.xz);\n    vec4 z = texture(s, p.xy);\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 bump(vec3 p, vec3 n, sampler2D s, float bf) {\n    vec2 h = vec2(0.005, 0.0);\n    vec3 g = mat3(\n        texcube(s, p - h.xyy, n).xyz,\n        texcube(s, p - h.yxy, n).xyz,\n        texcube(s, p - h.yyx, n).xyz)*vec3(0.299, 0.584, 0.114);\n    \n    g -= dot(vec3(0.299, 0.584, 0.114), texcube(s, p, n).xyz);\n    g -= n*dot(g, n);\n    \n    return normalize(n + bf*g);\n}\n\nmat3 camera() {\n    vec2 mo = vec2(-90.0, 0.0);\n    if(iMouse.z > 0.0) {\n        mo += -0.5 + 1.0*(iMouse.xy - iMouse.zw);\n        mo.y = -mo.y;\n    }\n    vec2 rad = mo*PI/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvec3 pbr(vec3 p, vec3 n, vec3 l, vec3 rd, \n         vec3 a, float r, float m,\n         inout vec3 f, inout float hov, inout float nov) {\n    \n    vec3 v = normalize(-rd);\n    vec3 h = normalize(v + l);\n    \n    float nol = clamp(dot(n, l), 0.0, 1.0);\n    float noh = clamp(dot(n, h), 0.0, 1.0);\n    nov = clamp(dot(n, v), 0.0, 1.0);\n    hov = dot(h, v);\n    \n    f = mix(vec3(0.1), a, m);\n    vec3 F = f + (1.0 - f)*pow(1.0 - hov, 5.0);\n    \n    float a2 = pow(r, 4.0);\n    float D = a2/pow(noh*noh*(a2 - 1.0) + 1.0, 2.0);\n    \n    float k = 0.5*pow(0.5*r + 0.5, 2.0);\n    float kl = nol*(1.0 - k) + k;\n    float kv = nov*(1.0 - k) + k;\n    float V = 1.0/(4.0*kl*kv);\n    \n    vec3 spe = F*D*V;\n    vec3 dif = (1.0 - F)*(1.0 - m);\n    \n    return (dif*a/3.141 + spe)*nol;\n}\n\nvec3 ibl(vec3 p, vec3 n, vec3 rf, vec3 a, float r, float m,\n         vec3 f, float hov, float nov) {\n    \n    vec3 F = f + (max(vec3(1.0 - r), f) - f)*pow(1.0 - hov, 5.0);\n    vec3 irr = textureLod(iChannel2, n, 10.0).rgb;\n    vec3 dif = irr*(1.0 - F)*(1.0 - m)*a;\n    \n    vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 cr = c0*r + c1;\n    float a4 = min(cr.x*cr.x, exp2(-9.28*nov))*cr.x + cr.y;\n    vec2 ab = vec2(-1.04, 1.04)*a4 + cr.zw;\n    \n    vec3 pc = textureLod(iChannel2, rf, 10.0*r).rgb;\n    vec3 spe = pc*(F*ab.x + ab.y);\n    \n    float occ = exp2(-pow(max(0.0, 1.0 - map(p + n*0.05).x/0.05), 2.0));\n    return (dif + spe)*occ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0*(fragCoord.xy/iResolution.xy);\n    \n\tvec3 col = vec3(0);\n        \n    vec3 ro = texture(iChannel0, vec2(0)).xyz;\n\tvec3 rd = normalize(camera()*vec3(uv, 1.97));\n\tvec3 mat;\n\n\tvec2 i = march(ro, rd);\n\tif(i.x < tmax) {\n\t\tvec3 pos = ro + rd*i.x;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\n\t\tvec3 lig = normalize(vec3(0.8, 0.7, -0.6));\n        vec3 alb;\n        float m, r;\n        \n        if (i.y == 1.0) {\n            alb = vec3(1, .3, .3);\n            m = 0.0;\n            r = 0.1;\n        } else if (i.y == 2.0) {\n            alb = vec3(0.2, 0.2, 1);\n            m = 1.0;\n            r = 0.4;\n        } else {\n            alb = vec3(1, 0.3, 1);\n            m = 0.0;\n            r = 0.1;\n        }\n\t\t\n        vec3 f;\n        float hov, nov;\n        \n        col = pbr(pos, nor, lig, rd, alb, r, m, f, hov, nov);\n        \n        vec3 rf = reflect(rd, nor);\n        col += ibl(pos, nor, rf, alb, r, m, f, hov, nov);\n\t}\n    \n\tcol = mix(col, vec3(1, 0.8, 0.8), 1.0 - exp(-0.08*i.x));    \n    col = 1.0 - exp(-0.9*col);\n    col = pow(abs(col), vec3(1.0/2.2));\n\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265359;\n\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.0) ).x;\n}\n\nmat3 cameraMatrix() {\n    vec2 mo = vec2(-90.0, 0.0);\n    \n    if(iMouse.z > 0.0) {\n        mo += -0.5 + 1.0*(iMouse.xy - iMouse.zw);\n        mo.y = -mo.y;\n    }\n    vec2 rad = mo*PI/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvec3 cameraPosition() {\n    vec3 p =  texture(iChannel0, vec2(0)).xyz;\n    if(iFrame == 0) return vec3(0.0, 0.83, -1.8);\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 cp = cameraPosition();\n    mat3 cm = cameraMatrix();\n    \n    cp += cm[2]*0.005;\n    \n    \n    fragColor = vec4(cp, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}