{"ver":"0.1","info":{"id":"DdGfD3","date":"1698689810","viewed":116,"name":"Genjutsu love and peace","username":"nayk","description":"universe galaxy stars copy past","likes":5,"published":1,"flags":1,"usePreview":0,"tags":["universegalaxystars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom2   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.03),sin(iTime*0.03),-sin(iTime*0.03),cos(iTime*0.03));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\n\nconst float pi = radians(180.0);\nconst float twoPi = 2.0 * pi;\nconst float sqrt3 = sqrt(3.0);\n\nconst int SUPERSAMPLE = 2; // Decrease to speed things up, increase to reduce aliasing\nconst float increment = 1.0 / float(SUPERSAMPLE);\nconst float offset = increment / 2.0 - 0.5;\n\n\nconst float borderWidth = 0.0022;\n\n// Parameters for primary recursion\nconst int maxIterations = 12; // This does not include iterations that are skipped when it zooms in\nfloat scalePerIteration; // set in mainImage\nfloat anglePerIteration; // set in mainImage\nfloat zoom; // set in mainImage\n\nfloat secondsPerIteration = 30.0;\n\n// Primary triangle geometry\nconst float primaryLength = 0.72; // side length\nconst float primaryRadius = 0.7; // radius of triangle center from origin\n\n// The angle offset that the first triangle will be\n// Other triangles are 120 degrees apart\nconst float primaryAngleOffset = 30.0;\n\nconst vec2[] triangleCenters = vec2[](\n\tvec2(0.0, 0.0),\n    \n\tprimaryRadius * vec2(\n        cos(radians(primaryAngleOffset)),\n        sin(radians(primaryAngleOffset))),\n    \n\tprimaryRadius * vec2(\n        cos(radians(primaryAngleOffset + 120.0)),\n        sin(radians(primaryAngleOffset + 120.0))),\n    \n\tprimaryRadius * vec2(\n        cos(radians(primaryAngleOffset + 240.0)),\n\t\tsin(radians(primaryAngleOffset + 240.0))));\n\n// Parameters for secondary recursion\nconst bool renderSecondaryTriangles = true; // TODO Set to false to only render primary triangles - this greatly speeds up rendering\nconst int secondaryIterations = 3; // Iterations of the secondary triangle\nconst float secondaryShrinkage = 1.0 / float(secondaryIterations); // The linear shrinkage per iteration\n\nconst float secondaryLength = 0.25;\nconst float secondaryRadius = 0.82;\nconst float secondaryMirrorOffset = secondaryLength * 0.8;\n\n\nconst float secondaryAngleOffset = 90.0;\n\nvec2[] secondaryTriangleCenters = vec2[](\n    secondaryRadius * vec2(\n        cos(radians(secondaryAngleOffset)),\n\t\tsin(radians(secondaryAngleOffset))),\n\n    secondaryRadius * vec2(\n        cos(radians(secondaryAngleOffset + 120.0)),\n    \tsin(radians(secondaryAngleOffset + 120.0))),\n\n\tsecondaryRadius * vec2(\n        cos(radians(secondaryAngleOffset + 240.0)),\n\t\tsin(radians(secondaryAngleOffset + 240.0))));\n\n\n\nfloat oscillate(float min, float max, float time) {\n\tfloat halfInterval = (max - min) / 2.0;\n\tfloat middle = min + halfInterval;\n\treturn middle - halfInterval * cos(time);\n}\n\n// Returns 2D rotation matrix of angle in degrees\nmat2 getRotationMatrix(float degrees) {\n    float rads = radians(degrees);\n    vec2 cs = vec2(cos(rads), sin(rads));\n\treturn mat2(cs.x, -cs.y,\n                cs.y, cs.x);\n}\n\n\nfloat sdEquilateralTriangle(vec2 point, vec2 center, float angle, float sideLength)\n{\n    float radius = sideLength/2.0;\n    point = point - center;\n    if (angle != 0.0) {\n     \tpoint = getRotationMatrix(angle) * point;   \n    }\n    const float k = sqrt3;\n\n    point.x = abs(point.x) - radius;\n    point.y = point.y + radius/k;\n    \n    if (point.x + k*point.y > 0.0)\n        point = vec2(point.x - k*point.y, -k*point.x - point.y) / 2.0;\n    \n    point.x -= clamp( point.x, -2.0*radius, 0.0 );\n    return -length(point)*sign(point.y);\n}\n\nvec3 getBackgroundColor(vec2 point, int level)\n{    \n    \n    vec3 baseColor = vec3(\n        oscillate(0.0, 0.8, float(level) * 1.1) + float(level) / float(maxIterations) / 3.0,\n        oscillate(0.0, 0.5, float(level) * 0.8) + float(level) / float(maxIterations) / 3.0,\n        oscillate(0.9, 0.0, float(level) * 0.5) + float(level) / float(maxIterations) / 1.5);\n    \n\tfloat angle = atan(point.y, point.x);\n    float distance = distance(point, vec2(0.0));\n    float angleIntensity = (sin(9.0*angle) / 4.0) + 0.75;\n    float distanceIntensity = (cos(10.0 * distance) / 4.0) + 0.75;\n    return baseColor * distanceIntensity * angleIntensity;\n}\n\n// Get rainbow color of screen the same way a default shadertoy does\nvec3 getRainbowColor(vec2 point) {\n    return 0.5 + 0.5*cos(iTime+point.xyx+vec3(0,2,4));\n}\n\n\nfloat getPrimaryGlowIntensity(float distanceFromTriangle, float distanceFromCenter)\n{\n    // First, set center distance to start at the edge\n    distanceFromCenter -= primaryLength / (2.0 * sqrt3);\n    // Get a shape between triangle and circle distance, then calculate some function that falls off\n    float interpolatedDistance = mix(distanceFromTriangle, distanceFromCenter, 0.2);\n    float falloff = 1.0 / (interpolatedDistance * 50.0 + 1.0) - 0.08;\n    return  clamp(falloff, 0.0, 1.0);\n}\n\n// Gets the intensity of a secondary triangle glow, clamped from 0 to 1\nfloat getSecondaryGlowIntensity(float distanceFromTriangle, float distanceFromCenter, int recursionLevel)\n{\n    // First, set center distance to start at the edge\n    distanceFromCenter -= secondaryLength / (2.0 * sqrt3);\n    \n    // Scale distances to make glow intensity oscillate\n    float scale = oscillate(0.5, 1.5, 0.5*pi*(iTime + 2.0*float(recursionLevel)/float(secondaryIterations - 1)));\n    \n    distanceFromTriangle /= scale;\n    distanceFromCenter /= scale;\n    \n    // Get a shape between triangle and circle distance, then calculate some function that falls off\n    float interpolatedDistance = mix(distanceFromTriangle, distanceFromCenter, 0.2);\n    float falloff = 1.0 / (interpolatedDistance * 150.0 + 1.0) - 0.1;\n    return  clamp(falloff, 0.0, 1.0);\n}\n\n// Calculates the new coordinate if we are inside a main triangle\nvec2 recurseOnMainTriangle(vec2 point, mat2 rotationMatrix, int triangleIndex)\n{\n    return scalePerIteration * rotationMatrix * (point - triangleCenters[triangleIndex]);\n}\n\n// Calculates the new coordinate if we are inside a secondary triangle\nvec2 recurseOnSecondaryTriangle(vec2 originalPoint, vec2 center, int recursionLevel)\n{\n    // Scale linearly based on level\n    float scale = (1.0 - float(recursionLevel + 1) * secondaryShrinkage);\n    return (originalPoint - center) / scale + center;\n}\n\n// For skipping iterations when zoomed in\nconst float inscribeRadius = primaryLength / 2.0 / sqrt3 - borderWidth;\n\n// Main algorithm - computes color at point, with rotation matrix passed to save computations\nvec3 getColor(vec2 coord, mat2 rotationMatrix)\n{ \t\n    // Point to recurse on\n    vec2 point = coord;\n    \n    // If the point is close to the center, advance the start level to save computation\n    float exponent = 0.5 * log(inscribeRadius * inscribeRadius / dot(point, point)) / log(scalePerIteration);\n    float start = max(ceil(exponent), 0.0);\n    \n    point = getRotationMatrix(anglePerIteration * start) * point * pow(scalePerIteration, start);\n    \n    // Recurse a few levels deep, keep track of level for color calculation\n    vec3 result;\n    for (int level = int(start); level < maxIterations + int(start); level++)\n    {\n        // Calculate background with pattern and some rainbow action\n        vec3 background = getBackgroundColor(point, level);\n        vec3 rainbow = getRainbowColor(point);\n        \n        // Reset result at beginning of recursion\n        result = mix(background, rainbow, 0.25);\n        \n        int insideTriangleIndex = -1; // Index of the triangle we are inside - -1 if outside all triangles\n        \n        // Iterate over each main triangle\n        for (int i = 0; i < triangleCenters.length(); i++) {\n            vec2 center = triangleCenters[i];\n            \n            float distanceFromCenter = distance(point, center);\n            // Optimize - stop calculations for this triangle if we are far from it\n            if(distanceFromCenter > 0.8) \n                continue;\n            \n            float distanceFromTriangle = sdEquilateralTriangle(point, center, 0.0, primaryLength);\n            \n            // Break to recurse on this triangle if inside \n            if(distanceFromTriangle < 0.0)\n            {\n                // Add border to triangle\n                if(distanceFromTriangle > -borderWidth)\n                    return vec3(1.0);\n                \n                insideTriangleIndex = i;\n                break;\n            }\n            \n            // Add glow to result color\n            float glowIntensity = getPrimaryGlowIntensity(distanceFromTriangle, distanceFromCenter);\n            result += vec3(glowIntensity);\n        }\n        \n        // If inside a triangle, set up and perform recursion\n        if (insideTriangleIndex >= 0) {\n        \tpoint = recurseOnMainTriangle(point, rotationMatrix, insideTriangleIndex);\n            continue;\n        }\n        \n        // Otherwise, render secondary triangles, then break recursion\n        if (renderSecondaryTriangles) {\n            for (int i = 0; i < secondaryTriangleCenters.length(); i++)\n            {\n                vec2 center = secondaryTriangleCenters[i];\n\n                // Store original point, because recursion will calculate from the original point\n                // rather than the previous iteration's point\n                vec2 originalPoint = point;\n\n                // Render mirror copies\n                for(int mirror = 0; mirror < 2; mirror++)\n                {\n                    // Reset point to originalPoint for each mirror copy\n                    point = originalPoint;\n\n                    for (int secondaryLevel = 0; secondaryLevel < secondaryIterations; secondaryLevel++)\n                    {\n                        // Optimize - abort rendering if we are too far away\n                        float distanceFromCenter = distance(point, center);\n                        if(distanceFromCenter > 0.3)\n                            break;\n\n                        float distanceFromTriangle = sdEquilateralTriangle(point, center, 60.0 * float(mirror), secondaryLength); // Add 60 degrees on mirror\n\n                        // We are inside triangle\n                        if(distanceFromTriangle < 0.0)\n                        {\n                            // Add border to triangle\n                            if(distanceFromTriangle > -borderWidth)\n                                return vec3(1.0);\n\n                            // Reset result\n                            result = 0.5 * getRainbowColor(point);\n\n                            // Set up recursion\n                            point = recurseOnSecondaryTriangle(originalPoint, center, secondaryLevel);\n                            continue;\n                        }\n\n                        // Add glow and break recursion if outside triangle\n                        float glowIntensity = getSecondaryGlowIntensity(distanceFromTriangle, distanceFromCenter, secondaryLevel);\n\n                        result += vec3(glowIntensity);\n                        break;\n                    }\n                    // Subtract offset of second triangle\n                    vec2 offset = secondaryMirrorOffset * normalize(center);\n                    center -= offset;\n                }\n            }\n        }\n        break; // Break from primary triangle recursion (because we are outside a primary triangle)\n    }\n    return result;\n}\n\n\n   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\t\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.03);\n\tfloat time=iTime*speed+.25;\n\n\n\n   vec4 O = fragColor;\n   vec2 I = fragCoord;\n  \n  dir.xy=rotate(uv,iTime/10.-length(uv)*1.);\n   \n // Smaller screen dimension will have coordinates on [-1, 1]\n    float minDimension = min(iResolution.x, iResolution.y);\n    \n    // Set up angle, scale, and zoom\n    scalePerIteration = oscillate(1.55, 5.0, iTime * twoPi / secondsPerIteration);\n    zoom = exp(oscillate(0.0, 10.0, iTime * pi / secondsPerIteration));\n    anglePerIteration = iTime * 20.0 / secondsPerIteration;\n    \n    // Angle/Zoom defaults overwritten by mouse x/y respectively if clicked\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouse = (cos(iTime), iResolution.xy); // so changing resolution doesn't waz it\n        anglePerIteration = -60.0 * (2.0 * cos(iTime) - iResolution.x) / iResolution.x;\n        scalePerIteration = mix(1.55, 5.0, pow(exp2(mouse.y / iResolution.y) - 1.0, 1.5));\n    }\n    mat2 rotationMatrix = getRotationMatrix(anglePerIteration);\n    \n   \n    vec3 color = vec3(0.0);\n    \n    for(int j = 0; j < SUPERSAMPLE; j++) {\n        for(int i = 0; i < SUPERSAMPLE; i++)\n        {\n            vec2 screenCoord = fragCoord + offset + increment * vec2(float(i), float(j));\n            vec2 coord = 2.0 * (screenCoord - iResolution.xy/2.0) / minDimension;\n\n\n            \n            coord = rotationMatrix * coord / zoom;\n\n            color += getColor(coord, rotationMatrix);\n        }\n    }\n    color /= float(SUPERSAMPLE * SUPERSAMPLE);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n\n   \n     \n        \n   \n    \n    \n\tvec3 from=vec3(1.,.5,0.5)+color;\n    \n    \n \n\tfrom+=vec3(time*2.,time,-2.);\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    \n    \n}","name":"Image","description":"","type":"image"}]}