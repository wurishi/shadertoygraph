{"ver":"0.1","info":{"id":"DdKGWz","date":"1678420693","viewed":152,"name":"Coffee and Cookies","username":"ianertson","description":"Use the mouse to look around :)","likes":12,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","raymarch","coffee","materials","textures","smoke","cookies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\nvoid edgeKernel(inout vec4 n[9], sampler2D tex, vec2 coord, float width, float height)\n{\n  float w = 1.0/width;\n  float h = 1.0/height;\n\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\n\nfloat edgeDetectSobel(sampler2D tex, vec2 coord) {\n\n  vec2 texSize = vec2(textureSize(tex, 0).xy);\n\n  vec4 n[9];\n  edgeKernel(n, tex, coord, texSize.x, texSize.y);\n\n  vec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n\n  return clamp(max(max(sobel.r, sobel.g), sobel.b), 0.0, 1.0);\n}\n\n\nfloat cdiff(in vec3 a, in vec3 b) {\n    return distance(a, b);\n}\n\nfloat edgeDetect(sampler2D tex, vec2 uv) {\n\n  vec2 texSize = vec2(textureSize(tex, 0).xy);\n  float sobel = edgeDetectSobel(tex, uv);\n  \n  vec2 e = 1.0 / texSize;\n  vec3 a = texture(tex, uv).rgb;\n  vec3 b = texture(tex, uv + vec2(e.x, 0)).rgb;\n  vec3 c = texture(tex, uv + vec2(0, e.y)).rgb;\n  vec3 d = texture(tex, uv + vec2(e.x, e.y)).rgb;\n  \n  float ab = cdiff(a, b);\n  float bc = cdiff(b, c);\n  float cd = cdiff(c, d);\n  float ac = cdiff(a, c);\n  float ad = cdiff(a, d);\n  float bd = cdiff(b, d);\n  \n  \n  return max(sobel*0.3, max(ab, max(bc, max(cd, max(ac, max(ad, bd))))));\n}\n\n\nvec3 mipBlur(in vec2 uv, float f) {\n    float ex = dFdx(uv.x) * (1.0 + f) * 6.;\n    float ey = dFdy(uv.y) * (1.0 + f) * 6.;\n    \n    vec3 a = textureGrad(iChannel0, uv, vec2(ex, 0), vec2(0, ey)).rgb;\n    vec3 b = textureLod(iChannel0, uv, f*10.).rgb;\n    return max(a, b);\n}\n\nvec3 processImage(in vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float edge = edgeDetect(iChannel0, uv);\n    \n    vec3 blurred = mipBlur(uv, edge);\n    vec3 proc = mix(col, blurred, clamp(edge*10.*edge, 0.0, 1.0));\n    \n    proc = mix(proc, proc*proc, clamp(depth*4.1*depth, 0.0, 1.0));  \n    proc += 0.45*pow(luma(proc), 2.9 + depth)/(1.0 + (depth*4.1));\n    return proc;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = processImage(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime+9.95)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define AMBIENT 0.05\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat rand2(in vec2 p, in float seed);\nfloat rand(in vec2 ip, in float seed);\nvec3 trand(in vec2 p, in float seed, in float lod);\nfloat xnoise(in vec2 p, in float seed);\nfloat xnoise(in vec2 p, in float seed, in float freq, const in int levels);\nvec3 snoise(in vec2 p, in float seed, in float lod);\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int levels);\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, in float warp, const in int levels);\nfloat wnoise(in vec2 uv, in int iter, float dim);\nvec3 snoise3D(in vec3 p, in float seed, in float freq);\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float zm; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\n\n\nstruct Data { vec3 ro; vec3 rd; vec3 p; vec3 n; vec2 uv; float d; int id; int skip; Material m; };\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n        light.type == LIGHT_POINT ? normalize(light.p - p) :\n            normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(distance(\n            light.p, p), 2.0))); break;\n        case LIGHT_DIR: {\n            vec3 L2 = normalize(light.p - p);\n            return light.c * NdotL * light.s * smoothstep(0.8, 1.0, dot(\n                L2,\n                L\n            ));\n        }; break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 normal = normalize(cross(vec3(dx, bumpScale), vec3(dy, bumpScale)));\n    normal += bumpScale * normalize(normal);\n    \n   \n    vec3 next = normalize(wn+normal);\n    float dp = max(0.0, dot(wn, next));\n   \n    \n    return normalize(mix(wn, next, mx*dp*length(next)));\n    \n}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nbool ibox(\n    vec3 org,\n    vec3 rd,\n    vec3 boxPos,\n    vec3 boxSize,\n    float tnear,\n    float tfar\n ) {\n    vec3 inv_dir = 1.0 / rd;\n    vec3 box_min = boxPos-boxSize*0.5;\n    vec3 box_max = boxPos+boxSize*0.5;\n    vec3 tmin = (box_min - org) * inv_dir;\n    vec3 tmax = (box_max - org) * inv_dir;\n    vec3 t0 = min(tmin, tmax);\n    vec3 t1 = max(tmin, tmax);\n    vec2 v = vec2(\n        max(t0.x, max(t0.y, max(t0.z, tnear))),\n        min(t1.x, min(t1.y, min(t1.z, tfar))));\n        \n    return v.x < v.y;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 60.0\n#define STEPS 96\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_TABLE 3\n#define ID_TABLE_LEG 4\n#define ID_CUP 5\n#define ID_PLATE 6\n#define ID_COOKIE 7\n#define ID_COOKIE_CHIP 8\n#define ID_SMOKE 9\n#define ID_CUP_LIQUID 10\n\n#define CUP_H 0.16\n#define CUP_POS vec3(0.34, 1.1-(CUP_H+0.029), 0)\n#define SMOKE_POS (CUP_POS + vec3(0, 0.29, 0))\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat tableSDF(in vec3 p, in float w, in float h, in int skip, inout int id) {\n    id = ID_TABLE;\n    float dist = FAR;\n    \n    float thick = 0.05;\n    float sm = 0.01;\n    float board = boxSDF(p - vec3(0, h + thick, 0), vec3(w, 0.05, w/2.)) - sm;\n    float legThick = 0.08;\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3((w/2.)+legThick+0.25, 0, w/3.), vec3(0, 0, 0), vec3(0, h+thick, 0), legThick) - sm;\n\n    SAMPLE(board, ID_TABLE);\n    SAMPLE(leg, ID_TABLE_LEG);\n    \n    return dist;\n}\n\nfloat cupSDF(in vec3 p, in float h, in float r) {\n    r = mix(r, r*0.5, smoothstep(0.0, 0.3, max(0.0, -p.y+0.21)));\n    float d = cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), r);\n    float inside = cylSDF(p - vec3(0, 0.049, 0), vec3(0, 0, 0), vec3(0, h, 0), r*0.79)-0.005;\n    \n\n    float sx = smoothstep(0.0, 1.0, max(0.0, p.x+0.04));\n    float sy = smoothstep(0.0, 1.0, max(0.0, p.y+0.1));\n    float ss =(sx*sy);\n    p.y -= ss;\n    float handle = torusSDF((p.xzy) - vec3(0.1, h-0.05, 0.0).xzy, 0.04, 0.004)-0.001;\n    handle = max(handle, -inside);\n    d = smin(d, handle, 0.012);\n    d = smax(d, -inside, 0.02);\n\n    return d-0.001;\n}\n\nfloat plateSDF(in vec3 p, in float h, in float r) {\n    float ss = 0.01;\n    float f = smoothstep(0.07, 1.0, max(0.0, distance(abs(p.xz)+0.001, vec2(0.0))-ss));\n    float f2 = smoothstep(0.09, 1.01, max(0.0, distance(abs(p.xz)+0.001, vec2(0.0))-ss));\n    vec3 a = vec3(0, 0.0 + max(0.0, f-(f2*0.2)), 0);\n    vec3 b = vec3(0, h + max(0.0, f2-(f*0.2)), 0); \n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return ((e + i)/1.1)-0.0001;\n}\n\nfloat cookieSDF(in vec3 p, in float r, in float seed0, in float seed, in int skip, inout int id) {\n    if (p.y > 2.0) return p.y;\n    if (p.x > 2.0 || p.x < -2. || p.z > 2. || p.z < -2.) return FAR;\n    id = ID_COOKIE;\n    float dist = FAR;\n    vec3 n = snoise(p.xz*0.5, seed0, 0.1, 6.4, 6);\n    \n    float chipR = 0.009;\n    chipR = mix(chipR, chipR*0.5, n.z);\n    \n    p.y += (n.y*2.0-1.0)*0.15;\n  \n    float base = sphereSDF(p, r+0.01);\n    base = smax(base, abs(p.y)-0.01, 0.01);\n    \n    vec3 chipId = floor(vec3(p.x*r, p.y, p.z*r)-0.1);\n    \n    float ra = rand2(chipId.xz*9.23821, seed);\n\n    \n    vec2 offset = vec2(cos(ra*TAU), sin(ra*TAU))*0.01;\n    \n    float chip1 = sphereSDF(vec3(abs(p.x), p.y, p.z + offset.y) - vec3(r/2., 0.009, 0.0), chipR);\n    float chip2 = sphereSDF(vec3(p.x + offset.x, p.y, abs(p.z)) - vec3(0.0, 0.009, r/2.0), chipR);\n    float chip = min(chip1, chip2);\n    \n    SAMPLE(base, ID_COOKIE);\n    SAMPLE(chip, ID_COOKIE_CHIP);\n    return dist;\n}\n\n\n\nfloat sdf(inout Data data, in vec3 p) {\n    int id = ID_NONE;\n    int skip = data.skip;\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n    \n    int tableId = 0;\n    float table = tableSDF(p, 1.1, 0.8, skip, tableId);\n    SAMPLE(table, tableId);\n    \n    float cupH = CUP_H;\n    float cup = cupSDF(p - CUP_POS, cupH, 0.09);\n    SAMPLE(cup, ID_CUP);\n   \n    float r = 0.09;\n    r = mix(r, r*0.5, smoothstep(0.0, 0.3, max(0.0, -p.y+0.21)));\n    float cupLiq = cylSDF(p - (CUP_POS + vec3(0.0, 0.07, 0.0)), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.05, 0.0), r*0.68);\n    SAMPLE(cupLiq, ID_CUP_LIQUID);\n    \n    float plateH = 0.02;\n    float plate = plateSDF(p - vec3(0.0, 0.91, 0), plateH, 0.2);\n    SAMPLE(plate, ID_PLATE);\n    \n    // want to avoid the cookies as much as possible.\n    // very expensive for some reason\n    if (ibox(\n        data.ro,\n        data.rd,\n        vec3(0., 0.91+0.03, 0.),\n        vec3(0.4),\n        NEAR,\n        FAR\n    ) || data.skip > 2) {\n        \n        int cookieId = 0;\n        float cookieR = 0.04;\n        float cookie = cookieSDF(p - vec3(0.0, 0.91+0.03, 0.0), cookieR, 0.029123, 2.324, skip, cookieId);\n        SAMPLE(cookie, cookieId);\n    \n\n        if (skip != ID_COOKIE && skip != ID_COOKIE_CHIP) {\n            int cookie2Id = 0;\n            float cookie2R = 0.035;\n            float cookie2 = cookieSDF(p - vec3(0.12, 0.91+0.04, 0.0), cookie2R, 0.129123, 7.324, skip, cookie2Id);\n            SAMPLE(cookie2, cookie2Id);\n        }\n    }\n    \n\n    data.id = id;\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    data.ro = ro;\n    data.rd = rd;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0+abs(d)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    data.d = d;\n    \n    return true;\n}\n\nfloat smokeSDF(in vec3 p) {\n    float time = T*0.05;\n    vec3 shift = vec3(0, -time*0.8, 0);\n    vec3 n1 = snoise3D(p+shift, 0.02813156, 10.09);\n    shift += (n1*0.2) + vec3(cos(time+n1.x), sin(time+9.9872711223+n1.y), sin(time+n1.z));\n    vec3 n2 = snoise3D(p+shift, 4.8372156933, 12.0) * 2.0- 1.0;\n    vec3 n = reflect(n1, n2);\n    return (clamp(length(n+(dot(n1, n2)/2.)) - length(p/2.), 0.0, 1.0)*0.8);\n}\n\nvec3 marchSmoke(in vec3 ro, in vec3 rd, in float minD, in Light light) {\n    float d = 0.0;\n    vec3 col = vec3(0.0);\n    float sum = 0.0;\n    for (float d = 10.0; d > 0.002;  d -= 0.5) {\n        vec3 p = ro+(rd*d);\n        \n        vec3 dir = normalize(SMOKE_POS -p);\n    \n        p += dir * 0.009*max(0.0, 10.0 - (d*d));\n        p.y -= 0.1;\n        \n        float next = smokeSDF(p);\n        sum += next;\n        \n        if (sum > 0.0002) {\n            vec3 L = getLightDir(light, p);\n            col += max(0.0, next - smokeSDF(p + L)) * light.s * mix(light.c, vec3(1.0), 0.61) * smoothstep(0.0, 1.0, max(0.0, p.y-0.44));\n        }\n    }\n    \n    return col;//pow(col, vec3(2.))*2.;\n}\n\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far, in int skip)\n{\n    \n    float d = 0.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float t = 0.01;\n    float r = 1.0;\n    float f = 0.33;\n    float fw = f;\n    \n    const int steps = STEPS / 3;\n    for (int i = ZERO; i < steps; i++) {\n        float j = float(i) / float(steps);\n        fw = mix(f, 1.0, max(0.0, 1.0 - j));\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/(t));\n        t += clamp(next, 0.1, 0.5);\n        d += next*fw*0.5;\n        if (r < -1.0 || t > far || d >= far) break;\n    }\n\n    return clamp((r/(0.001+fw))+((d*fw)*0.5), AMBIENT, 1.0);\n}\n\nfloat getAO(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float d = NEAR*12.;\n    float t = 0.01;\n    float r = 1.0;\n    float k = 0.007;\n    for (int i = ZERO; i < 3; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next+0.05;\n        r = min(r, k*d/t);\n        t += (r*0.04);\n    }\n    r = clamp(r, AMBIENT, 1.0);\n    return pow(clamp(r+r/0.13, AMBIENT*0.7, 1.0), 2.);\n}\n\n\n//#define DEBUG_TEXTURE cookieTexture\n\nvec3 cookieTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(179, 107, 36);\n    vec3 c2 = rgb(232, 203, 154);\n    vec3 c3 = rgb(165, 120, 72);\n    vec3 c4 = rgb(180, 144, 95);\n    \n    vec3 hf1 = snoise(uv, 0.099821, 0.0, 100.0, 6);\n    vec3 lf1 = snoiseWarp(uv, 2.333214, 0.3, 10.0, 0.015, 6);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    float cracks = max(0.0, 1.0-smoothstep(0.02, 0.14, abs(lf1.x*2.0-1.0)));\n    \n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    col += col1;\n    \n    float crackF = cracks*grain.x*lf1.z;\n    col = mix(col, col*col, crackF);\n    \n    m.spec = 0.002;\n    m.z = clamp((cracks+grain.x)*0.6, 0.0, 1.0);\n    m.zm = lf1.x*m.z;\n    \n    return col;\n}\n\nvec3 porcelainTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 1.09298382, 0.0, 100.0, 6);\n    vec3 lf1 = snoiseWarp(uv, 2.22299781, 0.2, 10., 0.02, 6);\n    \n    vec3 c1 = rgb(208, 208, 208);\n    vec3 c2 = rgb(176, 176, 176);\n    vec3 c3 = rgb(223, 213, 212);\n    vec3 c4 = rgb(219, 205, 189);\n    vec3 c5 = rgb(81, 81, 81);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    col += col1;\n    \n    float pat = max(0.0, 1.0-smoothstep(0.01, 0.03, abs(lf1.x*2.0-1.0)));\n    float mpat = pat*lf1.y*hf1.z*lf1.x*pat;\n    col = mix(col, mix(c5, c4, lf1.z), mpat);\n    \n    m.spec = clamp(1.0-mpat, 0.1, 1.0);\n    m.z = clamp(luma(col)-(mpat), 0.0, 1.0);\n    m.zm = 0.15;\n    \n    return col;\n}\n    \n\nvec3 concreteTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(131, 119, 105);\n    vec3 c2 = rgb(46, 44, 38);\n    vec3 c3 = rgb(80, 70, 60);\n    vec3 c4 = rgb(146, 138, 130);\n    vec3 c5 = rgb(116, 100, 87);\n    float r = wnoise(uv*9., 6, 0.6);\n\n    \n    vec3 lf1 = snoiseWarp(uv, 0.0398291, 0.3, 8.0, 0.33, 5);\n    vec3 lf2 = snoise(uv, 8.9292031, 0.1, 9.0, 6);\n    vec3 hf1 = snoise(uv, 2.93872123, 0.25, 64.0, 6);\n    \n    \n    vec3 col1 = mix(mix(mix(c1, c2, lf1.x), c3, lf1.y), c4, lf1.z);\n    vec3 col2 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    col = mix(col1, col2, lf2.x);\n    col = mix(col, c5, smoothstep(0.55, 0.7, lf2.y));\n    \n    \n    float concavity = clamp(hf1.z*hf1.z, 0.2, 1.0);\n    col = mix(col, r*c1, concavity*lf2.z);\n   \n    m.z = clamp(concavity*max(0.2, hf1.z), 0.0, 1.0);\n    m.zm = m.z*0.5;\n    m.spec = (r*r*r)*0.25;\n    \n    return col;\n}\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    uv += 0.302123;\n    vec3 col = vec3(0.0);\n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    vec3 grain1 = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 grain2 = textureLod(iChannel3, (uv.yx + 0.0029837215)*1.1, 0.0).xyz;\n    \n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    float tile = 4.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile); vec2 slv = smoothstep(0.0, 1.0, lv);\n    vec2 alv = abs(lv*2.0-1.0);\n\n    float x = 1.0+fract(uv.x/2.);\n    float y = 1.0+fract(uv.y/2.);\n    \n    \n    float seed = 0.9827812;\n    float r = mix(\n        mix(rand(id, seed), rand(id + vec2(1, 0), seed), slv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    float ang = radians(mix(0.0, 45.0,  r));\n    vec2 k = vec2(r, r) + vec2(cos(ang), sin(ang));\n    \n    float pat1 = exp(cos(((k.y*2.0-1.0)*TAU*TAU*(k.x*2.0-1.0))-sin((alv.y*3.932812+alv.x)*3.))-1.);\n    \n    float pat = pat1*lf1.z*(0.5+(r*0.5));\n    \n    col = mix(col, col*col, pat);\n    \n    vec3 grainCol = mix(mix(mix(mix(c1, c2, grain1.x), c3, grain1.y), c4, grain1.z), c5, grain2.x);\n    \n    col = mix(col, grainCol, max(0.0, 1.0-(pat1*(0.5+(0.5*lf1.z))))*grain2.z);\n    \n    float dk = lf1.x*lf1.z;\n    col = mix(col, col*col, dk);\n    \n    m.z = clamp((grain1.x*0.01)+dk, 0.0, 1.0);\n    m.zm = m.z;\n    m.spec = clamp(dk+pat*grain2.x, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    \n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    float tile = 2.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lines = mod(length(vec2(alv.x/2., alv.y)), 0.4*cos(alv.y*(TAU-(alv.x/2.+hf2.y)))*hf2.z);\n    lines = max(0.002, 1.0-max(0.0, 0.5-lines));\n    \n    col = mix(col, col*col*col, lines);\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x*tile)*10.*lf1.y, sin((uv.y*tile)*TAU)*2.));\n    col = mix(col, mix(c1, c5, hf1.z), w2*0.6);\n    \n    float t2 = fract(uv.y*tile*2.);\n    float gs = smoothstep(0.5-0.25, 0.5+0.25, abs(t2*2.0-1.0)-0.5);\n    col = mix(col, col*col, gs);\n    \n    m.z = clamp((w2*lf1.x)*max(0.0, 0.5-gs), 0.0, 1.0);\n    m.zm = max(0.02, m.z);\n    m.spec = clamp(w2*lf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\n\nvec3 coffeeTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    p -= CUP_POS;\n    vec3 c1 = rgb(57, 40, 40);\n    vec3 c2 = rgb(100, 60, 21);\n    col = c2;\n    col += c1 * smoothstep(0.06, 0.05, length(p.xz));\n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = concreteTexture(uv, p, data.m);\n    \n    vec3 norm = makeNormal(data.n, data.m.z, data.m.zm, 0.02);\n    data.n = norm;\n    return col;\n}\n\n\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = woodTexture(uv, p, data.m);\n    \n    vec3 norm = makeNormal(data.n, data.m.z, data.m.zm, 0.02);\n    data.n = norm;\n    return col;\n}\n\nvec3 getAlbedoTable(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    uv *= 1.1;\n    uv.y += 0.12;\n    vec3 col = plankTexture(uv, p, data.m);\n    \n    vec3 norm = makeNormal(data.n, data.m.z, data.m.zm, 0.02);\n    data.n = norm;\n    return col;\n}\n\nvec3 getAlbedoTableLeg(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = woodTexture(uv, p, data.m);\n    \n    vec3 norm = makeNormal(data.n, data.m.z, data.m.zm, 0.02);\n    data.n = norm;\n    return col;\n}\n\nvec3 getAlbedoPlate(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = porcelainTexture(uv, p, data.m);\n    \n    vec3 norm = makeNormal(data.n, data.m.z, data.m.zm, 0.02);\n    data.n = norm;\n    return col;\n}\n\nvec3 getAlbedoCup(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = porcelainTexture(uv, p, data.m);\n    \n    vec3 norm = makeNormal(data.n, data.m.z, data.m.zm, 0.02);\n    data.n = norm;\n    return col;\n}\n\nvec3 getAlbedoCupLiquid(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = coffeeTexture(uv, p, data.m);\n    \n    return col;\n}\n\nvec3 getAlbedoCookie(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = cookieTexture(uv, p, data.m);\n    \n    vec3 norm = makeNormal(data.n, data.m.z, data.m.zm, 0.02);\n    data.n = norm;\n    return col;\n}\n\nvec3 getAlbedoCookieChip(inout Data data) {\n    vec3 col = rgb(127, 76, 45);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_TABLE: return getAlbedoTable(data); break;\n        case ID_TABLE_LEG: return getAlbedoTableLeg(data); break;\n        case ID_PLATE: return getAlbedoPlate(data); break;\n        case ID_CUP: return getAlbedoCup(data); break;\n        case ID_COOKIE: return getAlbedoCookie(data); break;\n        case ID_COOKIE_CHIP: return getAlbedoCookieChip(data); break;\n        case ID_CUP_LIQUID: return getAlbedoCupLiquid(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 blue = vec3(0.29, 0.69, 0.9);\n    return pow(blue, vec3(1.0 + dotup));\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse, in vec3 oN) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    \n    float NdotL = cdot(n, L);\n    \n    float shadow = NdotL > 0.0002 ? getShadow(p+(oN*NEAR), L, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p), data.id) : 1.0;\n        \n        \n   float ao = getAO(p+(n*NEAR*2.), L, oN, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow * ao;\n}\n\nvec3 lightEffect(in Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    return light.c * light.s * pow(VdotL, 16.0);\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.69), 2.0, LIGHT_AMBIENT);\n    \n    if (march(data, ro, rd)) {\n        vec3 n = data.n;\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        col += forEachLight(data, light, ro, rd, diffuse, n);\n    } else {\n        col += getSky(rd);\n    }\n    \n    if (ibox(\n        ro,\n        rd,\n        SMOKE_POS - vec3(0, -0.05, 0),\n        vec3(0.41, 0.5, 0.41),\n        NEAR,\n        FAR\n    )) {\n        vec3 dirSmoke = normalize(SMOKE_POS-ro);\n        float dotSmoke = cdot(rd, dirSmoke);\n        col += marchSmoke(ro-(SMOKE_POS + vec3(0.6, -0.9, 0)), rd, data.d, light) *(pow(dotSmoke, 128.0));\n    }\n\n    col += lightEffect(data, light, ro, rd);\n    \n    depth = data.d / FAR;\n    \n    col += smoothstep(0.02, 1.0, depth) * max(0.0, 1.0-smoothstep(0.0, 0.33, dotup)) * depth;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -0.5);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (length(m.xy) > 0.001 && m.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        ro.z -= 0.1;\n        ro.y += 0.3;\n        ro.xz = vec2(cos(T*0.2), sin(T*0.2))*0.5;\n        rd = look(uv, vec3(0, 0.1, 0), ro);\n    }\n    \n    ro.y += 1.;\n    ro.y = max(1.0, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col += (col*luma(col)*col);\n    col /= 1.0 + max(col-0.33, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n\n\n/////////////////////////////////////////////////////////////////////////\n\nfloat rand2(in vec2 p, in float seed) {\n    vec2 p2 = fract((p-(seed*3.392814))*40.9238125);\n    float r1 = fract(dot(p, p2)*3.9281854);\n    return fract(cos((r1+seed)*6.938871) * dot(p-p2, vec2(24.9382815, 29.777278152)));\n}\nfloat rand(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= (s ^ ((~p.x << s) + (~p.y << s)));\n    \n    p ^= (p << 17U);\n    p ^= ((p ^ s) >> 13U);\n    p ^= (p << 5U);\n    p ^= ((s + (s&(p.x^p.y))) >> 3U);\n    \n    uint n = (p.x*s+p.y)+((p.x ^ p.y) << ~p.x ^ s) + ((p.x ^ p.y) << ~p.y ^ s);\n    return float(n*50323U) / float(0xFFFFFFFFU);\n}\n\nvec3 trand(in vec2 p, in float seed, in float lod) {\n    return textureLod(iChannel3, (p + (seed*1.90928382))/256., lod).xyz;\n}\n\nfloat xnoise(in vec2 p, in float seed) {\n    p += 9.03231;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(rand(id, seed), rand(id+vec2(1, 0), seed), lv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat xnoise(in vec2 p, in float seed, in float freq, const in int levels) {\n    p += 9.03231;\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*xnoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 9.03231;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(trand(id, seed, lod), trand(id+vec2(1, 0), seed, lod), lv.x),\n        mix(trand(id + vec2(0, 1), seed, lod), trand(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int levels) {\n    p += 9.03231;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, in float warp, const in int levels) {\n    p += 9.03231;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n        p += ((n.xy*(0.5+(0.5*n.z)))*2.0-1.0)*warp; \n    }\n    \n    return n / div;\n}\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i =  ZERO; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8,6,-8,6)*.1 + r*.4;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8,6,-8,6)*.1 + r*.4;\n    }\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nvec3 noise3D(in vec3 p, in float seed) { return textureLod(iChannel2, (p+(seed*1.928271731))/10., 0.0).xyz;}\n\nvec3 snoise3D(in vec3 p, in float seed) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n    mix(\n        mix(noise3D(id + vec3(0, 0, 0), seed), noise3D(id + vec3(1, 0, 0), seed), lv.x),\n        mix(noise3D(id + vec3(0, 1, 0), seed), noise3D(id + vec3(1, 1, 0), seed), lv.x),\n        lv.y\n    ),\n    mix(\n        mix(noise3D(id + vec3(0, 0, 1), seed), noise3D(id + vec3(1, 0, 1), seed), lv.x),\n        mix(noise3D(id + vec3(0, 1, 1), seed), noise3D(id + vec3(1, 1, 1), seed), lv.x),\n        lv.y\n    ), lv.z);\n}\n\nvec3 snoise3D(in vec3 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*snoise3D(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n / div;\n}","name":"Buffer A","description":"","type":"buffer"}]}