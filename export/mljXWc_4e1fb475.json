{"ver":"0.1","info":{"id":"mljXWc","date":"1676728004","viewed":73,"name":"Infinite minibrot zoom","username":"grevel","description":"!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot","zoom","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec2 start_pos = vec2(-1.0, 0.0);\nconst float start_rot = 0.0;\nconst float start_zoom = 3.5;\nconst int start_iters = 80;\n\n// const vec2 end_pos = vec2(-1.254802703, -0.382753676);\n// const float end_rot = 2.16;\n// const float end_zoom = 0.01;\n// const int end_iters = 500;\nconst vec2 end_pos = vec2(-1.786201, 0.0);\nconst float end_rot = 0.0;\nconst float end_zoom = 0.0012;\nconst int end_iters = 500;\n\nvec3 hsv2rgb(vec3 c) {\n\tc = clamp(c, 0.0, 1.0);\n\tvec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn clamp(c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), 0.0, 1.0);\n}\n\nvec2 square_complex(vec2 z) {\n\treturn vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n\t// a2 - b2 + 2abi\n}\n\nvec2 lerp(vec2 a, vec2 b, float t) {\n\treturn b*t + (1.0-t)*a;\n}\nfloat lerp(float a, float b, float t) {\n\treturn b*t + (1.0-t)*a;\n}\nfloat inv_lerp(float v, float a, float b) {\n\treturn (v-a)/(b-a);\n}\n\nfloat map(float v, float a1, float b1, float a2, float b2) {\n\treturn lerp(inv_lerp(v, a1, b1), a2, b2);\n}\n\nvec2 rotate(vec2 v, float r) {\n\treturn vec2(cos(r)*v.x - sin(r)*v.y, sin(r)*v.x+cos(r)*v.y);\n}\n\nfloat get_mandelbrot(vec2 uv, float t) {\n\t\n\tfloat zoom = pow(2.718, lerp(log(start_zoom), log(end_zoom), t));\n\tfloat t_zoom = inv_lerp(zoom, start_zoom, end_zoom);\n\tvec2 pos = lerp(start_pos, end_pos, t_zoom);\n\tfloat rot = lerp(start_rot, end_rot, t);\n\tint iters = int(lerp(float(start_iters), float(end_iters), t_zoom));\n\n\tvec2 c = rotate(uv*zoom, rot) + pos;\n\tvec2 z = c;\n\tint i = 0;\n\tfor(; i < iters; i ++) {\n\t\tz = square_complex(z) + c;\n\t\tif(length(z) > 2.0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(i == iters) {\n\t\treturn 0.0;\n\t}\n\tif(i <= 1) {\n\t\treturn 1.0;\n\t}\n\treturn float(i)/float(iters);\n\t// return (float(i) - log(log(length(z))/log(2.0)))/float(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) / vec2(1.0, iResolution.x / iResolution.y);\n\t\n\t// float t = step(mod(time*2.0, 1.0), 0.5);//-pow(0.5, time * 0.1);\n\tfloat t = mod(iTime*0.1, 1.0);\n\n\n\tfloat man1 = get_mandelbrot(uv, t);\n\tvec3 rgb1 = hsv2rgb(vec3(pow(man1, 0.8), 1.0, step(0.000001, man1))).yzx;\n\t\n\tfloat man2 = get_mandelbrot(uv, t + 1.0);\n\tvec3 rgb2 = hsv2rgb(vec3(pow(man2, 0.8), 1.0, step(0.000001, man2))).yzx;\n\n\tvec3 rgb = mix(rgb1, rgb2, smoothstep(0.05, 0.0, t));\n\t// vec3 rgb = mix(rgb1, rgb2, 0.5);\n\n\tfragColor = vec4(rgb*0.5,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}