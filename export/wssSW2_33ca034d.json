{"ver":"0.1","info":{"id":"wssSW2","date":"1552319499","viewed":69,"name":"MCG: intersections","username":"tale3d","description":"In this lecture we discuss intersections of geometric primitives.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n\n    //Adding more to the common section:\n    //This example has a mouse as an input device.\n    //The mouse coordinates are taking in uv space, and then is modified in the same way\n    //  as the pixel coordinates (see above). \n    vec2 mouse = 2.0*(iMouse.xy / iResolution.xy) - vec2(1.0,1.0);\n    mouse.x *= aspect_ratio;\n\n\n    //Background colour (default)\n    vec3 colour = vec3(1.0,1.0,1.0);\n\n    //Here we define our triangle. \n    // It has three vertices, two with fixed position and third depends on the mouse\n    vec2 p2 = vec2(-0.6,0.5);\n    vec2 p1 = mouse;\n\n    vec2 p3 = vec2(-0.8,0.4);\n    vec2 p4 = vec2(0.4,-0.8);\n\n\n    //if we are close enough to the points defining the first line, we colour those green\n    if (dot(c-p1, c-p1) < 0.001) colour = vec3(0.0,1.0,0.0);\n    if (dot(c-p2, c-p2) < 0.001) colour = vec3(0.0,1.0,0.0);\n\n    //the same is for two points on the second line, we colour those blue\n    if (dot(c-p3, c-p3) < 0.001) colour = vec3(0.0,0.0,1.0);\n    if (dot(c-p4, c-p4) < 0.001) colour = vec3(0.0,0.0,1.0);\n\n    //Direction for the first line\n    vec2 dp1 = p2-p1;\n    \n    //now the implicit equation: we use one of the equations from the lecture\n    float implicit1 = (c.x-p1.x)/dp1.x - (c.y-p1.y)/dp1.y;\n\n    //if it is equal to 0, then we are on our straight line, but as we work with pixels \n    //   which might be slightly off, we use proximity test once again.\n    if (abs(implicit1) < 0.01) colour = vec3(0.0,0.0,0.0);     //Colour the line black.     \n\n    //repeat for the second line\n    vec2 dp2 = p4-p3;\n    float implicit2 = (c.x-p3.x)/dp2.x - (c.y-p3.y)/dp2.y;\n    if (abs(implicit2) < 0.01) colour = vec3(0.0,0.0,0.0);     //Colour the line black.     \n\n    //now draw the circle \n\tfloat circx = 0.7, circy = 0.7, circr2 = 0.2;\n    //uing implicit form\n    float circle = (c.x-circx)*(c.x-circx)/circr2 + (c.y-circy)*(c.y-circy)/circr2 - 1.0;\n    if (abs(circle) < 0.01) colour = vec3(0.0,0.0,0.0);     //Colour the line black.     \n\n    //line-line intersection\n    \n    //At this stage we need to collect coefficients for the general form from parametric one.\n    //Note that if we have a form (x-x1)/dx1 - (y-y1)/dy1 = 0, then by multiplying by dx1*dy1 we have\n    //(x-x1)dy1 - (y-y1)dx1 = 0 ->\n    //x*dy1 - y*dx1 -x1*dy1 + y1*dx1 = 0 ->\n    //a = dy1, b = -dx1, c = y1*dx1 - x1*dy1\n    float a1 = dp1.y, b1 = -dp1.x, c1 = dp1.x*p1.y-dp1.y*p1.x;\n    //similar logic for the second equation\n    float a2 = dp2.y, b2 = -dp2.x, c2 = dp2.x*p3.y-dp2.y*p3.x;\n\n    //intersection point by using equation from the lecture\n    vec2 pi = vec2((b1*c2-b2*c1)/(a1*b2-a2*b1), (c1*a2-c2*a1)/(a1*b2-a2*b1));\n\n    //segment-segment intersection test\n    float pt = (pi.x-p1.x)/(p2.x-p1.x); //patameter for the first line\n    float ps = (pi.x-p3.x)/(p4.x-p3.x); //parameter for the second line\n\n   \n    //now the intersection test: if we are close enough to the line\n    //AND the parameters for the intersection point is in bounds [0,1]\n    if (dot(c-pi, c-pi) < 0.001 && pt > 0.0 && pt < 1.0 && ps > 0.0 && ps < 1.0) \n        colour = vec3(1.0,0.0,0.0); //paint the proximity of the intersection point red\n    \n    //now line-circle intersection\n  \n    //see the lecture notes: we had quadratic equation as a result of substitution\n    //as*t^2 + bs*t + cs = 0\n    float as = dp1.x*dp1.x+dp1.y*dp1.y;\n    float bs = 2.0*dp1.x*(p1.x-circx)+2.0*dp1.y*(p1.y-circy);\n    float cs = (p1.x-circx)*(p1.x-circx) + (p1.y-circy)*(p1.y-circy) - circr2;\n    float disc = bs*bs-4.0*as*cs; //discriminant\n    if (disc >= 0.0) //if it is negative, no points of intersection\n    {\n        //otherwise we have two intersection points (which might coincide, but we do not care\n        float ts1 = (-bs-sqrt(disc))*0.5/as;\n        float ts2 = (-bs+sqrt(disc))*0.5/as;\n        //from parameters go back to coordinates\n        pi = p1+ts1*dp1;\n        //as previously, if we have intersection and the current pixel is close enough, paint it red\n        if (dot(c-pi, c-pi) < 0.001) colour = vec3(1.0,0.0,0.0);\n        //...and for the second point\n        pi = p1+ts2*dp1;        \n        if (dot(c-pi, c-pi) < 0.001) colour = vec3(1.0,0.0,0.0);\n    }\n    \n    //That is it, assign the colour to the pixel.\n    fragColor = vec4(colour,1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}