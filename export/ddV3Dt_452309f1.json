{"ver":"0.1","info":{"id":"ddV3Dt","date":"1681659946","viewed":83,"name":"Harlequine Torus ","username":"shau","description":"Cut torus with IDs. Started as an exersize playing with IQs revolution and onion functions.\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define PI2 6.2831853\n#define ZERO (min(iFrame,0))\n#define EPS .001\n#define FAR 20.\n#define T iTime\n#define R iResolution.xy\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//IQ\n//https://iquilezles.org\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nvec2 opRevolution(vec3 p, float w )\n{\n    return vec2( length(p.xy) - w, p.z );\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = PI/repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nfloat sdStrips(vec2 p,\n    vec2 b,\n    float a,\n    float a2,\n    float r,\n    float segments)\n{\n    vec2 q = p;\n    p *= rot(a);\n    q *= rot(a2);\n    pModPolar(p,segments*0.5);\n    pModPolar(q,segments*0.5);\n    p -= vec2(r,0.0);\n    q -= vec2(r,0.0);\n    vec2 d = abs(p)-b;    \n    vec2 d2 = abs(q)-b;    \n    return min(length(max(d, 0.0)) + min(max(d.x, d.y), 0.0), \n               length(max(d2,0.0)) + min(max(d2.x,d2.y),0.0));\n}\n\nvec3 cutTorus(vec3 p, \n    float segments, \n    float r1, \n    float r2)\n{\n    float AT = T/PI2;\n    float a = atan(p.x,p.y);\n    float a1 = (a/PI2) + 0.5;\n    float a2 = (atan(length(p.xy)-4.0, p.z)/PI2) + 0.5;\n    float id1 = mod(floor(a2*segments - a1*segments),segments);\n    float id2 = mod(floor(a2*segments + (a1+AT)*segments),segments);\n    float gap = 0.1;\n\n    float t = min(1e10,onion(sdTorus(p,vec2(r1,r2)),0.04));\n    t = max(t,-sdStrips(opRevolution(p,r1),vec2(0.2,gap),a+T,-a,r2,segments));\n    return vec3(t,vec2(id1, id2));\n}\n\nvec4 map(vec3 p)\n{\n    return vec4(cutTorus(p,8.0,4.0,1.0),0.0);\n}\n\n//IQ\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec3 march(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec2 idaa = vec2(0.0);\n    for (int i=ZERO; i<200; i++)\n    {\n        vec4 ns = map(ro+rd*t);\n        \n        if (ns.x<EPS) \n        {\n            idaa = ns.yz;\n            break;\n        }\n        t += ns.x;\n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    return vec3(t,idaa);\n}\n\n//IQ\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.0),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    float fl = 1.0;\n    vec3 la = vec3(0.0),\n         ro = vec3(0.0,sin(T*0.3)*2.0,-8.0);\n    ro.zy *= rot(sin(T*0.17));\n    ro.xz *= rot(T*0.3);\n    mat3 cam = camera(la,ro,sin(T*0.13)*0.4);\n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    vec3 rd = cam*normalize(vec3(uv,fl));\n    \n    vec2 uv2 = U/R+0.5; \n    float lt = length(uv);\n    vec3 col = vec3(1.0)/(1.0+lt*lt*0.06);\n    \n    vec3 s = march(ro,rd);\n    if (s.x>0.0)\n    {\n        vec3 lp = vec3(3.0,5.0,-6.0);\n        vec3 p = ro+rd*s.x;\n        vec3 n = normal(p);\n        vec3 ld = normalize(lp-p);\n        float diff = max(0.7,dot(ld,n));\n        float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),2.0);\n        \n        vec3 h3 = hash32(s.yz);\n        col = mix(h3,vec3(1.0),0.7)*diff + vec3(0.2)*spec;\n    }\n    \n    C = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}