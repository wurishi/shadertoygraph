{"ver":"0.1","info":{"id":"Ws3cD7","date":"1600991409","viewed":446,"name":"RYB Conversion","username":"omnnai","description":"Derived from the \"RYB Color Compositing\" paper.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2dcolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float min3 (vec3 v) {\n  \treturn min (min (v.x, v.y), v.z);\n}\n\nfloat max3 (vec3 v) {\n  \treturn max (max (v.x, v.y), v.z);\n}\n\n// ref: http://nishitalab.org/user/UEI/publication/Sugita_IWAIT2015.pdf\nvec3 RGBtoRYB(vec3 RGB)\n{\n    vec3 rgb = RGB;\n    \n    // Remove white component\n    float Iw = min3(RGB);\n    rgb -= Iw;\n    \n    vec3 RYB;\n    \n    // Derive RYB\n    float rg = min(rgb.r, rgb.g);\n    RYB.r = rgb.r - rg;\n    RYB.y = 0.5 * (rgb.g + rg);\n    RYB.b = 0.5 * (rgb.b + rgb.g - rg);\n    \n    // Normalize\n    float n = max3(RYB) / max3(rgb);\n    if (n > 0.0)\n    \tRYB /= n;\n    \n    // Add black \n    float Ib = min3(vec3(1.0) - RGB);\n    RYB += Ib;\n    \n    return RYB;\n}\n\nvec3 RYBtoRGB(vec3 RYB)\n{\n    vec3 ryb = RYB;\n    \n    // Remove white component\n    float Iw = min3(RYB);\n    ryb -= Iw; \n    \n    vec3 RGB;\n    \n    // Derive RGB\n    float yb = min(ryb.y, ryb.b);\n    RGB.r = ryb.r + ryb.y - yb;\n    RGB.g = ryb.y + (2.0 * yb);\n    RGB.b = 2.0 * (ryb.b - yb);\n    \n    // Normalize\n    float n = max3(RGB) / max3(ryb);\n    if (n > 0.0)\n        RGB /= n;\n    \n    // Add black\n    float Ib = min3(vec3(1.0) - RYB);\n    RGB += Ib;\n    \n    return RGB;\n}\n\n#define AA 5.0 / iResolution.y\n\nfloat Circle(vec2 uv, vec2 pos, float rad) {\n\treturn smoothstep(rad, rad - AA, length(pos - uv));\n}\n\n#define RADIUS 0.5\n#define HALF_RADIUS RADIUS * 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Positions\n    vec2 centerPosition = vec2(0.0);\n    \n    vec2[] positions = vec2[] \n    (\n    \tcenterPosition + vec2( HALF_RADIUS, -HALF_RADIUS),\n        centerPosition + vec2(         0.0,  HALF_RADIUS),\n        centerPosition + vec2(-HALF_RADIUS, -HALF_RADIUS)\n    );\n    \n    vec3[] colors = vec3[]\n    (\n        vec3(1, 0, 0),  // R\n        vec3(1, 1, 0),  // Y\n        vec3(0, 0, 1)   // B\n    );\n    \n    // Draw Color Composite Wheel\n    vec3 c = RGBtoRYB(vec3(1.0));\n    \n    for (int i = 0; i < 3; i++)\n    {\n        float m = Circle(uv, positions[i], RADIUS);\n        \n        c += RGBtoRYB(colors[i]) * m;\n    }\n    \n    fragColor = vec4(RYBtoRGB(c), 1.0);\n}","name":"Image","description":"","type":"image"}]}