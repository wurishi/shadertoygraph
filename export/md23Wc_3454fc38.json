{"ver":"0.1","info":{"id":"md23Wc","date":"1668322760","viewed":226,"name":"a corridor with a red circle ","username":"Poisson","description":"A tunnel with a Japanese flag, rendered with raymarching.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","fractal","reflection","tunnel","ray","music","dof","raymarcher","menger","japan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// IF THERE'S NO MUSIC GO IN THE BUFFER A\n\n//░░░░░██╗░█████╗░██████╗░░█████╗░███╗░░██╗  ██████╗░███████╗░█████╗░████████╗\n//░░░░░██║██╔══██╗██╔══██╗██╔══██╗████╗░██║  ██╔══██╗██╔════╝██╔══██╗╚══██╔══╝\n//░░░░░██║███████║██████╔╝███████║██╔██╗██║  ██████╦╝█████╗░░███████║░░░██║░░░\n//██╗░░██║██╔══██║██╔═══╝░██╔══██║██║╚████║  ██╔══██╗██╔══╝░░██╔══██║░░░██║░░░\n//╚█████╔╝██║░░██║██║░░░░░██║░░██║██║░╚███║  ██████╦╝███████╗██║░░██║░░░██║░░░\n//░╚════╝░╚═╝░░╚═╝╚═╝░░░░░╚═╝░░╚═╝╚═╝░░╚══╝  ╚═════╝░╚══════╝╚═╝░░╚═╝░░░╚═╝░░░\n\n// bloom and post processing\n\n// blur function\nvec4 bloom(sampler2D sam, vec2 p) {\n    vec4 col = vec4(0);\n    \n    for (int i=-4; i<=4; i++) {\n    for (int j=-4; j<=4; j++) {\n        vec2 off = vec2(i,j)*.005;\n        col += textureLod(sam, p+off, 3.);\n    }\n    }\n    return col/81.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, p).rgb;\n    vec3 bloom = bloom(iChannel0, p).rgb;\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    col += .6*pow(bloom,vec3(1,1,.8)); // bloom\n\n    // vignette\n    col *= .5+.5*clamp(pow(32. * p.x*p.y*(1.-p.x)*(1.-p.y), .5), 0., 1.);\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA 1 // antialiasing, et it to 2 if you have a fast computer\n\nvec3 ro; // ray origin\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// scene (menger sponge)\n// thanks to iq: https://iquilezles.org/articles/menger/\nfloat map(vec3 p) {\n    vec3 q = abs(p-ro)-vec3(1.2,1.2,3.5);\n    float d = max(q.x,max(q.y,q.z));\n    \n    float s = 1.;\n    for (int i=0; i<3; i++) {\n        p.xz *= rot(float(i)*2.);\n        p.yz *= rot(float(i)*2.);\n        vec3 a = mod(p*s, 2.) - 1.;\n        s *= 3.;\n        vec3 r = 1.-3.*abs(a);\n\n        r = abs(r);\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n    \n        float c = min(da,min(db,dc)) - 1.;\n        \n        d = max(d, c/s);\n    }\n    return d;\n}\n\n// raymarching loop\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    \n    for (int i=0; i<512 && t<64.; i++) {\n        vec3 p = ro + rd*t;\n        float h = map(p);\n        if (abs(h)<.001*t) break;\n        t += h;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = map(p);\n    const vec2 e = vec2(.0001,0);\n    \n    return normalize(h - vec3(map(p-e.xyy),\n                              map(p-e.yxy),\n                              map(p-e.yyx)));\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(1);\n    \n    for (int i=0; i<8; i++) { // reflections bounces\n        float t = intersect(ro, rd);\n        if (t<64.) {\n            vec3 p = ro + rd*t; // point on surface\n            vec3 n = calcNormal(p); // surface normal\n            \n            ro = p+n*.01;\n            rd = reflect(rd, n); // reflect the ray\n                        \n            col *= .5;\n        } else {\n            // Japanese flag\n            float d = length(rd.xy);\n            if (i==0) col = mix(col, vec3(1,0,0), step(d-.1,0.));\n            return col;\n        }\n    }\n    return col;\n}\n\n// camera matrix\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    \n    // antialiasing loops\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n)/float(AA) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n        ro = vec3(0,0,.5*iTime); // ray origin\n        vec3 ta = ro+vec3(0,0,.1); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n\n        float z = 1.25+.5*texture(iChannel0, vec2(0,1)).r;\n        vec3 rd = ca * normalize(vec3(p,z)); // ray direction\n        rd.xy *= rot(.3*iTime); // ray rotation\n\n        vec3 col = render(ro, rd);\n        float t = intersect(ro, rd); // distance to the scene\n        tot += vec4(col,t);\n    }\n    tot /= float(AA*AA);\n            \n    fragColor = tot;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// depth of field buffer\n\n// depth of field function, thanks to iq\nvec4 dof(sampler2D sam, vec2 p) {\n    const float focus = 1.2;\n    vec4 col = vec4(0);\n    \n    for(int i=-4; i<=4; i++) {\n    for(int j=-4; j<=4; j++) {\n        vec2 off = vec2(i,j);\n        vec4 tmp = texture(iChannel0, p+off*.002); \n        float depth = tmp.w;\n        float coc = 6.*abs(depth-focus)/depth;\n        if(dot(off,off) < coc*coc) {\n            float w = 1./(coc*coc); \n            col += vec4(tmp.rgb*w,w);\n        }\n    }\n    }\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec3 col = dof(iChannel0, p).rgb;\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// chromatic abberation buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec2 off = (p-.5)*.01; // abberation offset\n    vec3 col = vec3(texture(iChannel0, p+off).r,\n                    texture(iChannel0, p).g,\n                    texture(iChannel0, p-off).b);\n                    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}