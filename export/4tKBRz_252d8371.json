{"ver":"0.1","info":{"id":"4tKBRz","date":"1543964982","viewed":129,"name":"Clouds?","username":"lhog","description":"Clouds","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//SETTINGS//\nconst float timeScale = 10000.0;\nconst float cloudScale = 0.001;\nconst float skyCover = 0.5; //overwritten by mouse x drag\nconst float softness = 0.2;\nconst float brightness = 0.9;\nconst int noiseOctaves = 4;\nconst float curlStrain = 0.1;\n//SETTINGS//\n\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\nfloat saturate(float num)\n{\n    return clamp(num,0.0,1.0);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise(vec2 n)\n{\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b), hash12(b + d.yx), f.x), mix(hash12(b + d.xy), hash12(b + d.yy), f.x), f.y);\n}\n\nvec2 rotate(vec2 uv)\n{\n    uv = uv + noise(uv*0.2)*0.005;\n    float rot = curlStrain;\n    float sinRot=sin(rot);\n    float cosRot=cos(rot);\n    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);\n    return uv * rotMat;\n}\n\nfloat fbm (vec2 uv)\n{\n    float f = 0.0;\n    float total = 0.0;\n    float mul = 0.5;\n    \n    for(int i = 0;i < noiseOctaves;i++)\n    {\n        f += noise(uv+iTime*0.00015*timeScale*(1.0-mul))*mul;\n        total += mul;\n        uv *= 3.0;\n        uv=rotate(uv);\n        mul *= 0.5;\n    }\n    return f/total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenUv = fragCoord.xy/iResolution.xy;\n    vec2 uv = fragCoord.xy/(40000.0*cloudScale);\n    \n    //float mouseXAffect = (iMouse.x/iResolution.x);\n    \n    //float cover = mouseXAffect*1.1+0.1;\n    //if( iMouse.z<=0.0001 ) cover = 0.5;\n    float cover = skyCover;\n    \n    float bright = brightness*(1.8-cover);\n    \n    float color1 = fbm(uv-0.5+iTime*0.00004*timeScale);\n    float color2 = fbm(uv-10.5+iTime*0.00002*timeScale);\n    \n    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);\n    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);\n    \n    float cloudsFormComb = saturate(clouds1+clouds2);\n    \n    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);\n   \t//cloudCol = (cloudCol);\n    vec3 clouds1Color = vec3(cloudCol,cloudCol,cloudCol);\n\n    //fragColor = mix(texture(iChannel1, screenUv), vec4(0.0), cloudsFormComb);\n    fragColor.rgb = mix(0.3 * clouds1Color, texture(iChannel1, screenUv).rgb, cloudsFormComb);\n    //fragColor = texture(iChannel1, screenUv) * cloudsFormComb;\n    //fragColor = texture(iChannel1, screenUv) * (1.0 - cloudsFormComb) + clouds1Color * cloudsFormComb;\n}","name":"Image","description":"","type":"image"}]}