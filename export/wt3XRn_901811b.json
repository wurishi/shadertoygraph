{"ver":"0.1","info":{"id":"wt3XRn","date":"1583624344","viewed":115,"name":"Un ptit train","username":"Axioplase","description":"Trying to do a small animation.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","train","vaporwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is super ugly. I've messed up many things when building this, but I'm learning!\n// Missing: trees, electric posts.\n// I'm gonna stop there, though.\n\nvec2 rot(float alpha, vec2 uv) {\n    float c = cos(alpha);\n    float s = sin(alpha);\n    return mat2(c, -s, s, c) * uv;\n}\n\nvec3 sky(vec2 p) {\n    return vec3(p.y/2.+0.25)*vec3(0.8,0.,0.8)*3.+.5;\n}\n\nvec3 sun(vec2 p, vec2 center, float radius) {\n    if (length(p-center) <= radius) {\n        return vec3(.8,0.8,.0)*length(p-center+vec2(0.,0.2));\n    }\n    return vec3(0);\n}\n\nvec3 mountains(vec2 p, float height, vec3 col, float freq, float amp, float speed) {\n    p += .4;\n    if (p.y+height + cos(freq*p.x+iTime*speed)/amp < .1) {\n        return col;\n    }\n    return vec3(0);\n}\n\n// not good for small objects\nfloat dist_Rect(vec2 pixel, vec2 rect_center, vec2 rect_size) {  \n    vec2 d = abs(rect_center - pixel) - rect_size*0.5;\n    return length(max(d,0.0));\n}\n\nfloat dist_RoundRect(vec2 pixel, vec2 rect_center, vec2 rect_size, float rect_round) {\n    return dist_Rect(pixel, rect_center, rect_size - vec2(rect_round*2.0)) - rect_round;\n}\n\nbool disk(vec2 pos, float radius) {\n    return (length(pos) < radius);\n}\n\nbool reflekt(vec2 uv, vec2 p, float win, float x, float y) {\n    return (uv.y - p.y < y &&\n            uv.y - p.y > y-0.005 &&\n            uv.x - (p.x-win) < x+0.01 &&\n            uv.x - (p.x-win) > x);\n}\nbool line(vec2 uv, vec2 start, float len, float thick) {\n    return (uv.x >= start.x &&\n            uv.x < start.x + len &&\n            uv.y >= start.y - thick/2. &&\n            uv.y < start.y + thick/2.);\n}\n\nvec3 car(vec2 uv, vec2 p, float phase) {\n    //float bump = smoothstep(1.0 ,1.2,1.0+sin(iTime+phase)/40.);\n    //p -= vec2(0., bump);\n\n    vec3 c;\n    // box car\n    vec2 pp = p;\n    float bump = smoothstep(0.99,1., sin(p.x*0.51+iTime))/150.;\n    bump += cos(p.x*2.7+iTime*2.)/300.;\n    pp = vec2(p.x, p.y-bump);\n    if (dist_RoundRect(uv, pp, vec2(0.5, 0.25), 0.05) <= 0.) {\n        // wagon\n        c = vec3(1.,.1,0.);\n        // decoration\n        if (line(uv, pp-vec2(1.,0.025) ,10., 0.01) ||\n            line(uv, pp-vec2(1.,0.045) ,10., 0.01) ||\n            (uv.y - pp.y < -.06)) {\n            c = vec3(.5,.08,1.);\n        }\n\n        vec2 ww = rot(0.8, uv-pp);\n        if (ww.y < -0.01) {\n            c-=vec3(.1);\n        }\n\n        // Lower part under the step.\n        if (uv.y - pp.y < -0.105) {\n            c = vec3(.5,.08,0.);\n        }\n        // windows\n        float from = -0.2;\n        float to = 0.2;\n        float step = (to-from)/5.;\n        for (float win = from+step; win <= to ; win += step) {\n            if (dist_RoundRect(uv, pp-vec2(win,-0.04), vec2(0.05, 0.08), 0.005) <= 0.) {\n                c = vec3(.5,.5,.5); // outer\n                if (dist_RoundRect(uv, pp-vec2(win+0.007,-0.035), vec2(0.05, 0.08), 0.004) <= 0.) {\n                    c = vec3(.4,.2,.4); // inner\n                    // reflections. I was not able to make it with a rotation of a line\n                    // that ends up in each window, so I'm doing pixel art...\n                    // I probably want to\n                    // 1) rotate space\n                    // 2) shift by the amount of the window center\n                    // 3) draw a small line around the new origin\n                    if (reflekt(uv, pp, win, -.00, 0.050) ||\n                        reflekt(uv, pp, win, -.01, 0.045) ||\n                        reflekt(uv, pp, win, -.02, 0.040) ||\n                        reflekt(uv, pp, win, -.03, 0.035) ||\n                        reflekt(uv, pp, win, .02, 0.045) ||\n                        reflekt(uv, pp, win, .01, 0.040) ||\n                        reflekt(uv, pp, win, .00, 0.035) ||\n                        reflekt(uv, pp, win, -.01, 0.030) \n                       ) {\t\n                        c = vec3(0.7, 0.3, 0.7);\n                    }\n                }\n            } \n        }\n\n        // door\n        if (dist_RoundRect(uv, pp-vec2(from,-0.006), vec2(0.05, 0.15), 0.005) <= 0.) {\n            if (disk(uv-pp+vec2(from-0.01, .01), 0.004)) {\n                c = vec3(0.8); // knob\n            } else {\n                if (dist_RoundRect(uv, pp-vec2(from,-0.006), vec2(0.045, 0.14), 0.005) <= 0.) {\n                    c = vec3(.3,.2,.3);\n                } else {\n                    c = vec3(.2,.1,.2);\n                }\n            }\n        }     \n    } \n    // wheels\n    else if (disk(uv-p+vec2(-0.15, 0.11), 0.04) || disk(uv-p+vec2(0.15, 0.11), 0.04)) {\n        if (disk(uv-p+vec2(-0.15, 0.11), 0.03) || disk(uv-p+vec2(0.15, 0.11), 0.03)) {\n            c = vec3(0.3); // inside\n        } else {\n            c = vec3(0.01); // outside\n        }\n\n        vec2 p1 = rot(iTime*10., vec2(0.02, 0.));\n        vec2 p2 = rot(6.+iTime*10., vec2(-0.02, 0.));\n        if (disk(p1+uv-p+vec2(-0.15, 0.11), 0.005) ||\n            disk(p2+uv-p+vec2(-0.15, 0.11), 0.005) ||\n            disk(p1+uv-p+vec2(0.15, 0.11), 0.003) ||\n            disk(p2+uv-p+vec2(0.15, 0.11), 0.003)\n           ) {\n            c = vec3(0.2);\n        }\n    }\n    else {\n        c = vec3(0);\n    }\n\n    // step\n    if (line(uv, pp-vec2(0.25,0.105), .49, .005)) {\n        c = vec3(.2,.0,.15);\n    } \n\n    // hook\n    if (line(uv, pp-vec2(0.26,.08), 0.013, .01)) {\n        c = vec3(.2,.0,.1);\n    } \n\n    return c;\n\n}\n\nfloat carHeight() {\n    float height = .3;\n    float freq = .4;\n    float speed = 1.3;\n    float amp = .01;\n    float y = height + cos(freq+iTime*speed)*amp;\n\n    return y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = sky(uv);\n    col += sun(uv, vec2(.4,.3), .15);\n\n    vec3 m;\n    m = mountains(uv, -.39, vec3(0.3,0.15,0.3), 2., 25., .1);\n    if (length(m) > 0.) {\n        col=m;\n    }\n    m = mountains(uv, -0.28, vec3(0.5,0.12,0.5), 3., 20., 0.3);\n    if (length(m) > 0.) {\n        col=m;\n    }\n\n\n    float y = carHeight();\n    float p = y-.575;\n    if (uv.y < p) {\n        if (uv.y > p-0.01) {\n            col = vec3(0.);\n        } else {\n            col *= 3.5 * -uv.y;\n        }\n    }\n\n    for (int ccar = 4; ccar >=0; ccar--) {\n        float bump = smoothstep(0.99,1., sin(-0.8+float(ccar)*0.51+iTime))/200.;\n        vec3 c = car(uv, vec2(-0.8+float(ccar)*0.51, bump+y-.43), 1.);\n        if (length(c) > 0.) {\n            col=c;\n        }\n    }\n\n\n    m = mountains(uv, 0.04, vec3(0.8,0.1,0.8), 4., 40., 0.9);\n    if (length(m) > 0.) {\n        col=m;\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}