{"ver":"0.1","info":{"id":"mtSfRV","date":"1694231637","viewed":29,"name":"Shader Assignment 1b Silas Ogren","username":"Silas","description":"complex 3d rotating shape with shading from surface normals and textures","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//I am sorry for the eye-sore.\n//Hexagonal Prism combined with rounded cylinder both by Inigo Quilez on https://iquilezles.org/articles/distfunctions/\nfloat sdHexPrismAndCylinder( vec3 p, vec2 h, float ra, float rb, float h2)\n{\n  vec3 p2 = vec3(p.x, p.y-0.3, p.z);\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xz -= 2.0*min(dot(k.xy, p.xz), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xz-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.z-h.x),\n       p.y-h.y );\n  vec2 cd = vec2( length(p2.xz)-2.0*ra+rb, abs(p2.y) - h2 );\n  return min(min(max(d.x,d.y),0.0) + length(max(d,0.0)), min(max(cd.x,cd.y),0.0) + length(max(cd,0.0)) - rb);\n}\n\n\nvec3 plaid(vec2 Pos){\n Pos = floor(Pos);\n return vec3(1.0/(sin(Pos.x)*sin(Pos.y)), sin(Pos.x)*sin(Pos.y), 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //rots\n    float s = sin(iTime);\n    float c = cos(iTime);\n    \n    mat3 rotx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c);\n    \n    mat3 rotz = mat3(\n    c, s, 0.0,\n    -s, c, 0.0,\n    0.0, 0.0, 0.1);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.xy -= 0.5;\n\n    // Time varying pixel color\n    vec3 col = vec3(0, cos(fragCoord.y*(abs(uv.x-0.5)) + iTime*30.0), sin(fragCoord.x*(abs(uv.y-0.5)) + iTime*30.0))*2.0*sin((uv.x+0.5)*3.14159)*(sin((uv.y+0.5)*3.14159));\n    \n    //create 3 rays using orthographic perspective to calculate normal vector\n    vec3 rayPt = vec3(uv.xy, 0.0);\n    vec3 rayPtdx = vec3(uv.x + 0.00001, uv.y, 0.0);\n    vec3 rayPtdy = vec3(uv.x, uv.y + 0.00001, 0.0);\n    //vec3 rayDir = vec3(0,0, 1); //ortho\n    \n    //perspective\n    vec3 eyePos = vec3(0,0,-5);\n    vec3 rayDir = normalize(vec3(uv.xy, 0) - eyePos);\n    float t = 0.0, tdx = 0.0, tdy = 0.0;\n    \n    \n    //object properties\n    vec3 objPos = vec3 (0.0, 0.0, 6.0);\n    vec2 objDim = vec2(0.2, 0.2);\n    \n    \n    for(int i = 0; i < 20; i++){\n        //put pt some distance along ray\n        vec3 pos = rayPt + rayDir * t;\n        vec3 posdx = rayPtdx + rayDir * tdx;\n        vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        //I decided to combine the shapes in the sd function and not using min\n        float dist = sdHexPrismAndCylinder(rotx*(pos - objPos), objDim, 0.08, 0.05, 0.2);\n        float distdx = sdHexPrismAndCylinder(rotx*(posdx - objPos), objDim, 0.08, 0.05, 0.2);\n        float distdy = sdHexPrismAndCylinder(rotx*(posdy - objPos), objDim, 0.08, 0.05, 0.2);\n        \n        \n        //float dist = sdHexPrism(rotz*rotx*(pos - objPos), objDim);\n        //float distdx = sdHexPrism(rotz*rotx*(posdx - objPos), objDim);\n        //float distdy = sdHexPrism(rotz*rotx*(posdy - objPos), objDim);\n        \n        if(dist < 0.01 && distdx < 0.01 && distdy < 0.01){\n            vec3 lightDir = rayDir;\n            vec3 objCol = plaid((vec2((fragCoord.x + iTime)/(2.0*t), (fragCoord.y + iTime)/(2.0*t))));\n            \n            col = objCol*dot(-lightDir, normalize(cross(posdy - pos, posdx - pos)));\n        }\n        t = t + dist;\n        tdx = tdx + distdx;\n        tdy = tdy + distdy;\n    }\n\n    col = col*vec3(texture(iChannel0, (uv.xy)*(sin((uv.x + cos(iTime))*3.14159)*sin((uv.y+sin(iTime))*3.14159))).rrr);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}