{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lengthRound(vec3 p)\n{\n\tfloat n = 1.7;\n\treturn pow(pow(p.x,n) + pow(p.y,n) + pow(p.z,n), 1.0/n);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  \n  //float lengthRounded = lengthRound(max(d,0.0));\n  //return min(max(d.x,max(d.y,d.z)),0.0) + lengthRounded;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeatPos(vec3 p, vec3 c)\n{\n\treturn mod(p,c)-.5 * c;\n}\n\nfloat getDistance(vec3 position)\n{\t\n    //Repeat shape\n\tvec3 repPos = repeatPos(position, vec3(5.0,20.0,4.5));\n    \n    //Draw cubes\n\t//return sdBox(repPos, vec3(1.,1.,1.));\n\t\n    //Draw spheres\n\treturn sdSphere(repPos, 1.0);\n}\n\nvec4 getColor(vec3 position)\n{\n\tfloat e = 0.01;\n\tfloat f0 = getDistance(position);\n\t\n    //Approximate the normal by stepping a minimal amount in each of the axes' direction\n\tfloat fx = getDistance(vec3(position.x + e, position.y, position.z));\n\tfloat fy = getDistance(vec3(position.x, position.y + e, position.z));\n\tfloat fz = getDistance(vec3(position.x, position.y, position.z + e));\n\t\n\t\n\t\n\tvec3 normal = normalize(vec3(fx - f0, fy - f0, fz - f0));\n\tvec3 lightPosition = vec3\n\t\t(\n\t\t\t0.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t3.0, //+ 12.0*sin(iTime*2.0),\n            iTime * -20.0 - sin(iTime) * 200.0\n            //50.0\n\t\t\t//-(280.0 + 300.0*sin(iTime*1.0)) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightDir = normalize(lightPosition - position);\n\tvec4 lightColor = vec4(0.0,0.6,0.0,0.2);\n\tvec4 lightIntensity = lightColor * dot(normal, lightDir);\n\tfloat reflectance = 0.5;\n\t\n\tfloat lightDistance = length(position-lightPosition);\n    \n    //Hacky but pretty good looking light intensity diminishing over distance\n\tfloat distanceIntensity = (1.0 / (pow(lightDistance / 100.0, 1.1))); \n\t\n\treturn reflectance * lightIntensity * (distanceIntensity);\n\t\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{\n        //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    vec3 eye = vec3(0, 3, iTime * -20.0 + 50.0);\n    \n    //Still eye\n\t//vec3 eye = vec3(0, 3, 0);\n    //vec3 eye = fragRayOri;\n\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = -vec3(1, 0, 0);\n    /*\n    vec3 right = cross(fragRayDir, vec3(0,1,0));\n    if(right.x < 0.0) {\n        right = cross(vec3(0,1,0),fragRayDir); \n    }\n    \n    vec3 up = cross(right, fragRayDir);\n    if(up.y < 0.0){\n        up = cross(fragRayDir, right);\n    }\n\t*/\n    \n    \n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    //vec3 rayDirection = normalize(pImagePlane - eye);\n    vec3 rayDirection = fragRayDir;\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.0,\n\t\t\t0.2,\n\t\t\t0.2,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    vec3 eye = vec3(0, 3, iTime * -20.0 + 50.0);\n    \n    //Still eye\n\t//vec3 eye = vec3(0, 3, 0);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = -vec3(1, 0, 0);\n    \n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.0,\n\t\t\t0.2,\n\t\t\t0.2,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":true,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfSRX","date":"1404670107","viewed":539,"name":"Ray marching big spacious thing","username":"Tsarpf","description":"Ray marching cubes with moving lighting","likes":4,"published":1,"flags":1,"usePreview":0,"tags":["raymarchingcubes"],"hasliked":0,"parentid":"","parentname":""}}