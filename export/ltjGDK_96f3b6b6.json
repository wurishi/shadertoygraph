{"ver":"0.1","info":{"id":"ltjGDK","date":"1432655524","viewed":328,"name":"inverting texture","username":"micahscopes","description":"I wanted something like MtjGz3 but with a texture :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tiling","inversion","scale","moebiustransformation","blossoming"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// \"texture inversion\" by Micah 2015\n// modified from \"p6mm inversion\" by Carlos UreÃ±a (https://www.shadertoy.com/view/MtjGz3#)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// *******************************************************************\n// global defs and params\n//\n\nconst float\n    sqr2     = 1.4142135623730950488016887242096980785696, // square root of 2\n    sqr3     = 1.7320508075688772935274463415058723669428, // square root of 3.0\n    sqr2_inv = 1.0/sqr2 ,\n    sqr3_inv = 1.0/sqr3 ,\n    l        = 0.025,       // scaling factor\n    l_inv    = 1.0/l ,\n    line_w   = 0.02 ,  // 0.015\n    speedFactor = 1.0 ;\n\n\nvec2\n    center, //   = 0.5*iResolution.xy, // viewport center in DC\n    invDirection = vec2(0.0,1.0);\n\nfloat\n    mind; //   = min(iResolution.x,iResolution.y);\n\n// -------------------------------------------------------------------------------\n\nfloat dist( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------------------\n\nfloat DistanceFunc( float d )\n{\n\n   return 1.0-smoothstep( line_w*0.85, line_w*1.15, d );\n}\n\n// -------------------------------------------------------------------------------\n\nvec2 DCToNDC( vec2 p_dc )\n{\n    return l_inv*(p_dc - center)/mind ;\n}\n// --------------------------------------------------------------------\n\nvec2 Inversion( vec2 p, vec2 cen )\n{\n   float secs = iTime*speedFactor ;\n   vec2  vr   = p  -cen ;\n   float r    = length( vr );\n\n    return cen + normalize(vr)/(r*0.1)\n              + secs/4.0*invDirection\n              + 1.0*l*vec2( sin(secs/40.0), cos(secs/42.0) ) ;\n}\n\n// -------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    center = 0.5*iResolution.xy, // viewport center in DC\n    mind = min(iResolution.x,iResolution.y);\n\n    vec2 mou = DCToNDC( vec2(0.5*iResolution.x,0.0) );\n    if ( iMouse.w != 0.0 )\n        mou  = DCToNDC( iMouse.xy  ) ;\n\n   vec2 pNDC = DCToNDC( fragCoord );\n\n   vec2 pinv = Inversion( pNDC, mou ) ;\n\n   fragColor = texture(iChannel0, pinv);\n}\n// -------------------------------------------------------------------------------\n","name":"Image","description":"","type":"image"}]}