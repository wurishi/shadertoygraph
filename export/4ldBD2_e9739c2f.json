{"ver":"0.1","info":{"id":"4ldBD2","date":"1543529942","viewed":100,"name":"FBM cosine vs linear interp","username":"jgkling","description":"fbm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_FBM_OCTAVES 4\n#define PI 3.14159\n\nconst vec2 offset = vec2(1.0, 0.0);\nconst bool cosine = true;\n\nfloat noise( in vec2 x ) {\n\treturn fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat InterpolateNoise2D( in vec2 pos ) {\n    vec2 pos_floor = floor(pos);\n    vec2 pos_fract = fract(pos);\n    pos_fract = pos_fract * pos_fract * (3.0 - 2.0 * pos_fract);\n    \n    float noise00 = noise(pos_floor);\n    float noise01 = noise(pos_floor + vec2(1.0, 0.0));\n    float noise10 = noise(pos_floor + vec2(0.0, 1.0));\n    float noise11 = noise(pos_floor + vec2(1.0, 1.0));\n    \n    if (cosine) {\n        noise00 = mix(noise00, noise01, -cos(pos_fract.x * PI) * 0.5 + 0.5);\n    \tnoise11 = mix(noise10, noise11, -cos(pos_fract.x * PI) * 0.5 + 0.5);\n    \treturn mix(noise00, noise11, -cos(pos_fract.y * PI) * 0.5 + 0.5);\n    } else {\n        noise00 = mix(noise00, noise01, pos_fract.x);\n        noise11 = mix(noise10, noise11, pos_fract.x);\n    \treturn mix(noise00, noise11, pos_fract.y);\n    }\n}\n\nfloat ComputeFBM( in vec2 pos ) {\n    float scale = 2.0;\n    float pers = 1.0 / scale;\n    \n    float amplitude = 0.5;\n    float freq = 1.0;\n    \n    float sum = 0.0;\n    \n    for(int i = 0; i < NUM_FBM_OCTAVES; ++i) {\n        sum += InterpolateNoise2D(pos * freq) * amplitude;\n        amplitude *= pers;\n        freq *= scale;\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(vec3(ComputeFBM(uv * 16.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}