{"ver":"0.1","info":{"id":"3tcGR4","date":"1575821732","viewed":121,"name":"inside_the_torus","username":"skaplun","description":"The code is quite twisted, especially the camera setup","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","animation","nosense"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 96\n#define EPSILON 0.0001\n#define TINT vec3(.8, .4, .2)\n\nfloat world(vec3 worldPos){\n    float time = PI;\n    {\n        vec3 p = worldPos;\n        vec3 rp = vec3(-PI, length(p.xy), p.z);\n        p = vec3(rp.y * sin(rp.x), rp.y * cos(rp.x), rp.z);\n    \t\n        float a = atan(worldPos.x, worldPos.y) * 2.5;\n        p.y += 2.;\n        p.zy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\t\t\n        {\n        \tvec2 mp = p.zy;\n            vec2 a = vec2(atan(mp.y, mp.x)+iTime, length(mp.xy));\n            a.x = mod(a.x, PI/16.)-PI/32.;\n            p.zy = vec2(a.y * cos(a.x), a.y * sin(a.x));\n        }\n        \n        return max(p.x, length(p.zy - vec2(1., 0.)) - .05);\n    }\n}\n\nfloat march(vec3 eye, vec3 marchingDirection){\n\tconst float precis = .001;\n    \n    float t = 0.0;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n        float hit = world( eye + marchingDirection * t );\n        if( hit < precis ) return t;\n        t += hit*.5;\n    }\n    return -1.;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)) - world(vec3(p.x - EPSILON, p.y, p.z)),\n        world(vec3(p.x, p.y + EPSILON, p.z)) - world(vec3(p.x, p.y - EPSILON, p.z)),\n        world(vec3(p.x, p.y, p.z  + EPSILON)) - world(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec4 render(in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float a = iMouse.x/iResolution.x * PI * 2.;\n    a = mix(PI/4., PI * 3./4., a);\n    vec3 eye = vec3(2.9, 0., 0.);\n    vec3 viewDir = rayDirection(90., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0.), vec3(0., 0., 1.)) * viewDir;\n\t\n    float hit = march(eye, worldDir);\n    if (hit > 0.) {\n        vec3 p = (eye + hit * worldDir);\n        vec3 norm = estimateNormal(p);\n        color = TINT * (abs(dot(worldDir, norm)));\n    }\n    return vec4(color, 1.);\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\nconst float PI = acos(-1.); \nconst float TAU = PI*2.; \nstruct Ray{vec3 origin, direction;};\n    \nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n","name":"Common","description":"","type":"common"}]}