{"ver":"0.1","info":{"id":"M3dSRB","date":"1719237227","viewed":22,"name":"UETest","username":"NomadRob","description":"Testing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793238462643383279502884197;\nconst int NumWedges = 512; // number wedge triangles. eg: wedges_count = 2, pattern would be a circle with 1/2 white, 1/2 black\nconst float HumanEyeAngularResolution_Radians = 0.0003;\n\nfloat remap(float min1, float max1, float min2, float max2, float value) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n// black or white value of a point within an unbounded wedge pattern\nfloat GetWedgePatternColor(\n    float sample_radius, // radius of the sample point measured from the center of the pattern\n    float theta_radians  // angle theta in radians\n)\n{\n    float wedge_angle = 2.0 * PI / float(NumWedges);\n    int wedge_idx = int(floor(theta_radians / wedge_angle));    \n    return mod(float(wedge_idx), 2.0);\n}\n\n\n// analytical color given a resolution radius\nfloat SampleWedgePatternColorAnalytical( \n    float sample_radius,    // radius of the sample point measured from the center of the pattern\n    float theta_radians,    // angle theta in radians\n    float resolution_radius // this might be the more general criteria since the render is orthographic. ie: an angular resolution at a certain distance gives you a radius\n)\n{\n    // Niave infinite resolution answer - This is not the answer!\n    float grayscale = GetWedgePatternColor(sample_radius, theta_radians);\n    //return grayscale;\n    \n    /*\n        Real answer will look something sort of like this\n        Except arrive at the conclusion without any magic numbers or cheats\n    */\n    float wedge_angle = 2.0 * PI / float(NumWedges);\n    float angle_to_next_wedge = mod(theta_radians, wedge_angle);\n    float angle_to_nearest_wedge_boundary = min(angle_to_next_wedge, wedge_angle - angle_to_next_wedge);\n    float nearest_boundary_dist_max = sin(wedge_angle * 0.5) * sample_radius;                 // maximum distance to a wedge boundary at the given radius, kind of like a width\n    float nearest_boundary_dist = sin(angle_to_nearest_wedge_boundary * 0.5) * sample_radius; // distance to nearest wedge boundary at the given sample point\n    grayscale = remap(0.0, resolution_radius, 0.5, grayscale, nearest_boundary_dist);\n    return grayscale;\n    \n    \n    // TODO write something that replaces the code above, accounts for the resolution radius crossing multiple wedges,\n    // and takes into account angular resolution properly. Maybe something that measures the exact area of each triangle\n    // that overlaps the resolution circle. Maybe you need to weigh data closer to the center of the circle higher\n    \n    // Answers might be here:\n    // https://en.wikipedia.org/wiki/Angular_resolution\n    // \"The imaging system's resolution can be limited either by aberration or by diffraction causing blurring of the image.\" Seems like diffraction limit may be what you need\n\n}\n\n\n// ShaderToy stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert normalized uv coordinates to polar coordinates about the center\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float angle = atan(uv.y, uv.x);\n    angle = mod(angle+iTime * 0.025, 2.0 * PI); // animate\n    float radius = length(uv);\n    \n    // Resolution radius - angular resolution at test pattern depth\n    float pixel_radius = 0.5 /length(iResolution.xy);\n    pixel_radius *= 2.0; // bumping it up because it seems to look prettier\n    \n    // compute result\n    float grayscale = SampleWedgePatternColorAnalytical(radius, angle, pixel_radius);\n    \n    // output\n    fragColor = vec4(vec3(grayscale), 1.0);\n}","name":"Image","description":"","type":"image"}]}