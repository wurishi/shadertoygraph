{"ver":"0.1","info":{"id":"ttjBDy","date":"1599792950","viewed":81,"name":"nD shadow test4 in 6 dimensions","username":"timeparticle","description":"This is test code to generate and view objects in N dimensions. Things may be difficult to interpret in N dimensions. The code probably contains many errors.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shadow","tests","4","timeparticle","nd","ndimensions","ndim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n//\n//  This is a toy code to explore N dimensional frag shading.\n//\n//  N is currently defined to be 6 dimensions in the common section of the code.\n//\n// \n//  Shadertoy tutorial and variations\n//\n//  Following:\n//\n//\t\tYouTube:\thttps://www.youtube.com/watch?v=PGtv-dBi2wE&feature=youtu.be\n//\n//\t\tShadertoy:\thttps://www.shadertoy.com/view/XlGBW3\n//\n//\n//  In my defense, I was left unsupervised.\n//\n//\n//  Copyright Â© 2020 timeparticle\n//\n//  The MIT License\n//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//\n\n\n#define MAX_RAY_MARCH_STEPS 100\n#define MAX_RAY_MARCH_DISTANCE 100.0\n#define MIN_SURFACE_DISTANCE 0.01\n\n\n// list of (perhaps) useful colors\nconst vec3 red_rgb     = vec3(1.0,0.0,0.0);\nconst vec3 green_rgb   = vec3(0.0,1.0,0.0);\nconst vec3 blue_rgb    = vec3(0.0,0.0,1.0);\nconst vec3 white_rgb   = vec3(1.0,1.0,1.0);\nconst vec3 black_rgb   = vec3(0.0,0.0,0.0);\nconst vec3 gray_rgb    = vec3(0.1,0.1,0.1);  //vec3(0.5,0.5,0.5);\nconst vec3 cyan_rgb    = vec3(0.0,1.0,1.0);\nconst vec3 magenta_rgb = vec3(1.0,0.0,1.0);\nconst vec3 maroon_rgb  = vec3(0.5,0.0,0.0);\nconst vec3 olive_rgb   = vec3(0.0,0.1,0.0);  //vec3(85./255.,107./255.,47./255.);\nconst vec3 purple_rgb  = vec3(0.5,0.0,0.5);\nconst vec3 teal_rgb    = vec3(0.0,0.5,0.5);\nconst vec3 violet_rgb  = vec3(0.1,0.0,0.2);\nconst vec3 yellow_rgb  = vec3(1.0,1.0,0.0);\n\n\n// Specify the colors for the cube and sphere.\nconst vec3 cube_color = blue_rgb;\nconst vec3 sphere_color = red_rgb;\nconst vec3 squareCircle_color = teal_rgb;\nconst vec3 circleSquare_color = purple_rgb;\nconst vec3 plane_color = violet_rgb;\nconst vec3 cube123_color = olive_rgb;\n\n\n\n// maybe handy axis definitions\n#define xIndex 0\n#define yIndex 1\n#define zIndex 2\n#define aIndex 3\n#define bIndex 4\n#define cIndex 5\n\n\n\n// cube in nD (n dimensions)\nfloat sdfCubenD (in float[nD] currentRay, in float sideLength)\n{\n    return maximum(absnD(currentRay)) - sideLength;   \n}\n\n\n// cube in dimensions 1, 2, 3\nfloat sdfCube123(in float[nD] currentRay, in float sideLength)\n{\n    float[nD] tempnD = absnD(currentRay);\n    return (max(tempnD[0], max(tempnD[1], tempnD[2]))) - sideLength; \n}\n\n\n// Sphere, in n dimensions, signed distance functions (sdf)\nfloat sdfSpherenD(in float[nD] currentRay, in float radius, in float[nD]sphereLocation)\n{\n        return lengthnD(minus(currentRay,sphereLocation)) - radius;\n}\n\n// XZ plane signed distance functions (sdf)\nfloat sdfPlaneXZ(in float[nD] currentRay)\n{\n    return currentRay[yIndex];\n}\n\n\n// XZ plane signed distance functions (sdf)\nfloat sdfPlaneAC(in float[nD] currentRay)\n{\n    return currentRay[bIndex];\n}\n\n\n\n/*\n// XZ plane signed distance functions (sdf)\nfloat sdfPlanesXZAC(in float[nD] currentRay)\n{\n    float currentDistance = currentRay[yIndex];\n    \n    if(currentRay[bIndex] > currentRay[yIndex]){currentDistance = currentRay[bIndex];}\n    \n    return currentDistance;\n}\n*/\n\n\n\n\n//\n// Compute the distanced from the objects in the scene.\n//\nvec4 getDistanceAndColor(float[nD] currentRay)\n{  \n    vec3 currentColor = vec3(0.0);  // default to black\n    float currentDistance = MAX_RAY_MARCH_DISTANCE;  // default to far away\n\n\n    // sphere at location x, y, z, and radius 1\n    float[nD] sphereLocation = values(0.0);\n    sphereLocation[0] = 0.0;  sphereLocation[1] = 1.0;  sphereLocation[2] = 4.0;\n    float sphereRadius = 1.0;\n    \n    // distnace to the sphere\n    float sphereDistance = sdfSpherenD(currentRay, sphereRadius, sphereLocation);\n    \n    // Replace current distance and color if current object is closer.\n    if(sphereDistance<currentDistance)\n    {\n        currentDistance = sphereDistance;\n        currentColor = sphere_color;\n    }\n\n    \n    // distance to the cube (in dims 1 2 3 only)\n    float sideLength = 0.5;\n    //float objectDistance = sdfCube123(currentRay, sideLength);\n    \n    // distance to the cube, n dimensional version\n    float objectDistance = sdfCubenD(currentRay, sideLength);\n\n    // Replace current distance and color if current object is closer.\n\tif(objectDistance < currentDistance)\n    {\n        currentDistance = objectDistance;\n        currentColor = cube123_color;\n    }\n            \n    \n    // distance to the plane\n    // just the height of the camera above the plane\n    //float planeDistance = sdfPlaneXZ(currentRay);\n    \n    float planeDistance = sdfPlaneXZ(currentRay);\n    \n    // Replace current distance and color if current object is closer.\n    if(planeDistance<currentDistance)\n    {\n        currentDistance = planeDistance;\n        currentColor = plane_color;\n    }\n        \n    vec4 localPixel = vec4(currentDistance, currentColor);\n   \n    return localPixel;\n}\n    \n\n//\n// basic ray marching (aka trace) routine\n//\nvec4 rayMarch(float[nD] rayOrigin, float[nD] rayDirection)\n{\n    float distanceFromOrigin = 0.0;\n    vec4 currentPixel;  // packet of distance and color\n\n    \tfor(int i=0; i<MAX_RAY_MARCH_STEPS; i++)\n        {\n            float[nD] currentRay = plus(rayOrigin, times(rayDirection, distanceFromOrigin));\n            \n            currentPixel = getDistanceAndColor(currentRay);\n            float currentDistance = currentPixel.x;  // distance is the 1st value of the packet\n            \n            distanceFromOrigin += currentDistance;\n            \n            if( (distanceFromOrigin > MAX_RAY_MARCH_DISTANCE) || (currentDistance < MIN_SURFACE_DISTANCE) ) break;\n        }\n    \n    currentPixel.x = distanceFromOrigin;\n    \n    return currentPixel;\n}\n\n\n\n//\n// Approximate a normal vector at a point on an object.\n//\n\nfloat[nD] getNormal(float[nD] point)\n{\n    float[nD] nDtemp;\n    float[nD] result;    \n    float epsilon = 0.01;\n    \n    for(int i=0; i<nD; i++)\n    {\t\n        nDtemp = values(0.0);\n        nDtemp[i] = epsilon;\n        \n        // quick (difference) approximation, not currently used\n        //result[i] = map(minus(point, nDtemp)).x;\n        \n        // another (difference) approximation\n        // https://iquilezles.org/articles/normalsSDF\n        result[i] = getDistanceAndColor(plus(point, nDtemp))[0] - getDistanceAndColor(minus(point, nDtemp))[0];\n    }\n    return normalizenD(result);\n}\n   \n\n\n//\n// part of shadow calculations\n//\nfloat getLight(float[nD] objectPoint)\n{    \n    // define a light above and away from the scene\n    float[nD] lightPosition = vec2floatnD(vec3(0,5,6));\n    \n    // Move the light.\n    // lightPosition.xz += 2.0 * vec2(sin(iTime), cos(iTime));\n    \n    float[nD] moveLight = values(0.0);\n    moveLight[0] = 2.0*sin(iTime);\n    moveLight[2] = 2.0*cos(iTime);\n    \n//    moveLight[3] = 2.0*sin(iTime);\n//    moveLight[5] = 2.0*cos(iTime);\n    \n    lightPosition = plus(lightPosition, moveLight);\n    \t    \n    // difuse lighting = lightDirection DOT localNormal\n    float[nD] lightDirection = normalizenD(minus(lightPosition, objectPoint));    \n    \n    float[nD] localNormal = getNormal(objectPoint);\n    \n    float difuseLighting = clamp(dotnD(localNormal, lightDirection), 0.0, 1.0);\n    \n    //\n    // Compute a simple shadow.\n    //\n    // Ray march from the object toward the light.\n    // If another object is encountered before the light,\n    // then this point must be in a shadow.\n    float fudgeFactor = 2.0;  // eliminates a flaw on the sphere surface\n    // vec3 justAboveObject = objectPoint + fudgeFactor*localNormal*MIN_SURFACE_DISTANCE;\n    float[nD] justAboveObject = plus(objectPoint, times(localNormal, fudgeFactor*MIN_SURFACE_DISTANCE));\n    \n    vec4 localPixel = rayMarch(justAboveObject, lightDirection);\n    \n    float distanceTowardLight = localPixel[0];  // distance is in the 1st slot\n    \n    // If point is in shadow, shadow = 10% of light.\n    if(distanceTowardLight < lengthnD(minus(lightPosition, objectPoint))) difuseLighting *= 0.1;  \n    \n    return difuseLighting;\n}\n\n\n\n//\n// frag shader\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n\t// Start with a black pixel.\n    vec3 color = vec3(0.0);\n    \n    // trivial camera\n    float[nD] rayOrigin = vec2floatnD(vec3(0.0,1.0,-6.0), values(0.0));\n    float[nD] rayDirection = normalizenD(vec2floatnD(vec3(uv.x, uv.y, 1.0), values(0.0)));\n    \n    //\n    //\n    // Rotate the origin and direction vectors.\n    // The rotation is defined by rotating from an original origin and direction\n    // by a rotation matrix using 2 principle axes, eg axis 2 and axis 4. \n    //\n    //invoke by:  getRotationMatrix(in int axis1, in int axis2, in float theta)\n    float angle = iTime / 3.0;\n    matnD rotationMatrix = getRotationMatrix(2,4, angle);  //(0,2, angle);\n    rayOrigin = times(rotationMatrix, rayOrigin);\n    rayDirection = times(rotationMatrix, rayDirection);\n    \n    \n    // Ray march and set the color.\n    vec4 objectDistanceAndColor = rayMarch(rayOrigin, rayDirection);\n    color = vec3(objectDistanceAndColor[0]/6.0);\n    \n    // Compute a vector to the object encountered in the ray march.\n    float[nD] objectPoint = plus(rayOrigin, times(rayDirection, objectDistanceAndColor[0]));\n    \n    float difuseLighting = getLight(objectPoint);\n    \n    // test only:  color = getNormal(objectPoint);\n    \n    color = vec3(difuseLighting) * objectDistanceAndColor.yzw ;\n    \n    // gamma correction\n    color = pow(color, vec3(0.45445));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n                                  \n                                  \n                                  \n                                  \n                                  \n                                  \n                                  \n                                  \n                                  ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n//\n//  This is a toy code to explore N dimensional frag shading.\n//\n//  Below are definitions to extend a data types to include\n//  vectors of length nD,\n//  intended for n dimensional ray marching, and other uses.\n//\n//  The full spec of glsl already contains these vectors,\n//  but implementing a full spec is rare, and perhaps even ill advised.\n//\n//  Caution:  one can cause runtime errors by defining nD to be below 4.\n//\n//  In my defense, I was left unsupervised.\n//\n//\n//  Copyright Â© 2020 timeparticle\n//\n//  The MIT License\n//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n//\n\n\n// number of dimensions\n#define nD 6\n\n// a handy shorcut...\n#define fornD for(int i=0; i<nD; i++)\n\n// whether to do compile time \"tests\"\n#define doVecnDMatnDCompileTimeTests 0\n\n\n//\n//\n// list of n dimensional functions defined herein:\n//\n//\t\tRETURN\t\tNAME\t\t INPUT TYPE(S)\n//\t\t TYPE\n//\n//\t\tfloat[nD] \tvalues\t\t \t (in float value)\n//\t\tfloat      \tsum    \t  \t \t (in float[nD] vector)\n//\t\tfloat[nD]  \tabsnD\t  \t \t (in float[nD] vector)\n//\t\tfloat[nD]  \tplus\t \t \t (in float[nD] vector1, in float[nD] vector2)\n//\t\tfloat[nD] \tminus\t\t \t (in float[nD] vector1, in float[nD] vector2)\n//\t\tfloat[nD]  \ttimes\t  \t \t (in float scalar, in float[nD] vector)\n//\t\tfloat[nD]  \ttimes\t  \t \t (in float[nD] vector, in float scalar)\n//\t\tfloat[nD] \ttimes\t\t \t (matnD matrix, float[nD] vector)\n//\t\tfloat      \tdotnD\t \t  \t \t (in float[nD] vector1, in float[nD] vector2)\n//\t\tfloat      \tlengthnD \t  \t \t (in float[nD] vector)\n//\t\tfloat \t   \tL2norm\t  \t \t (in float[nD] vector)\n//\t\tfloat \t   \tL1norm\t  \t \t (in float[nD] vector)\n//\t\tfloat[nD]  \tnormalizenD  \t \t (in float[nD] vector)\n//\t\tfloat[nD] \tfractnD\t\t \t (in float[nD] vector)\n//\t\tfloat \t\tmaximum\t\t \t (in float[nD] vector)\n//\t\tfloat[nD] \tmaximum\t\t \t (in float[nD] vector1, in float[nD] vector2)\n//\t\tfloat \t\tmaximum\t\t \t (in vec3 vec)\n//\t\tfloat \t\tminimum\t\t \t (in float[nD] vector)\n//\t\tfloat[nD] \tminimum\t\t \t (in float[nD] vector1, in float[nD] vector2)\n//\t\tvec2 \t\tfloatnD2vec2 \t (in float[nD] vector)\n//\t\tvec3 \t\tfloatnD2vec3 \t (in float[nD] vector)\n//\t\tvec4 \t\tfloatnD2vec4 \t (in float[nD] vector)\n//\t\tfloat[nD] \tvec2floatnD\t \t (in vec2 vec)\n//\t\tfloat[nD] \tvec2floatnD\t \t (in vec2 vec, in float[nD] vector)\n//\t\tfloat[nD] \tvec2floatnD  \t (in vec3 vec)\n//\t\tfloat[nD] \tvec2floatnD\t \t (in vec3 vec, in float[nD] vector)\n//\t\tfloat[nD] \tvec2floatnD  \t (in vec4 vec)\n//\t\tfloat[nD] \tvec2floatnD\t \t (in vec4 vec, in float[nD] vector)\n//\n//\t\tvecnD\t\tstruct vecnD\t ()\n//\t\tfloat[nD]\tvecnD2floatnD\t (in vecnD vector)\n//\t\tmatnD \t\tstruct matnD \t ()\n//\t\tmatnD \t\tvalues\t\t \t (in float value, in matnD dummy)\n//\t\tmatnD \t\tidentity\t \t ()\n//\t\tmatnD \t\tidentity\t \t (matnD dummy)\n//\t\tmatnD \t\tgetRotationMatrix(in int axis1, in int axis2, in float theta)\n//\t\tfloat[nD] \ttimes\t\t\t (in matnD matrix, in float[nD] vector)\n//\n//\n//\n// unfinished\t\tfloat \t\tdoDeterminant(in vecnD[nD] matrix)\n//\n//\n\n\n\n//\n// Set all elements of a float[nD] to a specific value.\n//\nfloat[nD] values(in float value)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = value;}\n    return result;\n}\n\n\n//\n// Sum the elements of a vector to a grand total.\n//\nfloat sum(in float[nD] vector)\n{\n    float result;\n    for(int i=0; i<nD; i++) {result += vector[i];}\n    return result;\n}\n\n\n//\n// Return a vector of elementwise absolute values.\n//\nfloat[nD] absnD(in float[nD] vector)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = abs(vector[i]);}\n    return result;\n}\n\n\n//\n// Return a vector of the elementwise sum of 2 vectors.\n//\nfloat[nD] plus(in float[nD] vector1, in float[nD] vector2)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = vector1[i] + vector2[i];}\n    return result;\n}\n// Return elementwise sum of a vector element and a scalar.\nfloat[nD] plus(in float[nD] vector, in float scalar)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = vector[i] + scalar;}\n    return result;\n}\n// Return elementwise sum of a vector element and a scalar.\nfloat[nD] plus(in float scalar, in float[nD] vector) {return plus(vector, scalar);}\n\n\n//\n// Return a vector of the elementwise difference of 2 vectors.\n//\nfloat[nD] minus(in float[nD] vector1, in float[nD] vector2)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = vector1[i] - vector2[i];}\n    return result;\n}\n// Return elementwise difference of a vector element and a scalar.\nfloat[nD] minus(in float[nD] vector, in float scalar)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = vector[i] - scalar;}\n    return result;\n}\n// Return elementwise difference of a scalar element and a vector.\nfloat[nD] minus(in float scalar, in float[nD] vector)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = scalar - vector[i];}\n    return result;\n}\n    \n    \n//\n// Product of a scalar times elements of a vector.\n//\nfloat[nD] times(in float scalar, in float[nD] vector)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = scalar * vector[i];}\n    return result;\n}\n// reverse the operands\nfloat[nD] times(in float[nD] vector, in float scalar) {return times(scalar, vector);}\n\n\n//\n// Dot product of 2 vectors.\n//\nfloat dotnD(in float[nD] vector1, in float[nD] vector2)\n{\n    float result = 0.0;\n    for(int i=0; i<nD; i++) {result += (vector1[i] * vector2[i]);}\n    return result;\n}\n \n\n//\n// L2 norm of a vector.\n//\nfloat lengthnD(in float[nD] vector) {return sqrt(dotnD(vector,vector));}\n//\n// Alternate call to same function...\n//\nfloat L2norm(in float[nD] vector) {return lengthnD(vector);}\n\n\n//\n// L1 norm of a vector, \n// which is the sum of the absolute value of the individual elements.\n//\nfloat L1norm(in float[nD] vector) {return sum(absnD(vector));}\n\n\n//\n// Normalize an nD vector.\n//\nfloat[nD] normalizenD(in float[nD] vector) {return times(1.0/lengthnD(vector), vector);}\n\n\n//\n// Do an elementwise fractional part of number, on a vector.\n// Computed as:  x - floor(x), elementwise.\n//\nfloat[nD] fractnD(in float[nD] vector)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = fract(vector[i]);}\n    return result;\n}\n\n\n//\n// Find the maximum across all elements of a float[nD].\n//\nfloat maximum(in float[nD] vector)\n{\n    float result = vector[0];  // get an initial \"maximum\"\n    for(int i=1; i<nD; i++) {result = max(result,vector[i]);}\n    return result;\n}\n// Elementwise maximum between 2 float[nD] vectors\nfloat[nD] maximum(in float[nD] vector1, in float[nD] vector2)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = max(vector1[i], vector2[i]);}\n    return result;\n}\n// Elementwise maximum between a float[nD] and a scalar.\nfloat[nD] maximum(in float[nD] vector, in float scalar)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = max(vector[i], scalar);}\n    return result;\n}\n// Find the maximum across a vec3 vector.\nfloat maximum(in vec3 vec) {return max(vec.x, max(vec.y, vec.z));}\n\n//\n// Find the maximum across all elements of a float[nD].\n//\nfloat minimum(in float[nD] vector)\n{\n    float result = vector[0];  // get an initial \"maximum\"\n    for(int i=1; i<nD; i++) {result = min(result,vector[i]);}\n    return result;\n}\n// Elementwise maximum between 2 vectors\nfloat[nD] minimum(in float[nD] vector1, in float[nD] vector2)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++) {result[i] = min(vector1[i], vector2[i]);}\n    return result;\n}\n\n\n//\n// Compute an n dimensional deterimant.\n// Following:  https://www.programming-techniques.com/2011/09/numerical-methods-determinant-of-nxn-matrix-using-c.html\n//\n\n/*  REFACTOR AND TEST\n\nfloat doDeterminant(in vecnD[nD] matrix)\n{\n    float ratio;\n    float result;\n    \n    \n/// test:   matrix[0].ele[1] = 0.0;\n    \n    // convert the matrix to upper triangular\n    for(int i = 0; i<nD; i++)\n    {\n        for(int j=0; j<nD; j++)\n        {\n            if(j>i)\n            {\n                ratio = matrix[j].ele[i]/matrix[i].ele[i];\n                for(int k=0; k<nD; k++)\n                {\n                    matrix[j].ele[k] -= ratio * matrix[i].ele[k];\n     }}}}\n    \n    //now determinant = product of diagonals\n    result = 1.0; \n    for(int i=0; i<nD; i++) result *= matrix[i].ele[i];\n    return result;\n}   \n\n*/\n\n\n\n//\n// Convert a float[nD] to a vec2. Use only the 1st 2 elements.\n//\nvec2 floatnD2vec2(in float[nD] vector)\n{\n    vec2 result;\n    for(int i=0; i<2; i++) {result[i] = vector[i];}\n    return result;\n}\n\n\n//\n// Convert a float[nD] to a vec3. Use only the 1st 3 elements.\n//\nvec3 floatnD2vec3(in float[nD] vector)\n{\n    vec3 result;\n    for(int i=0; i<3; i++) {result[i] = vector[i];}\n    return result;\n}\n\n    \n//\n// Convert a float[nD] to a vec3. Use only the 1st 4 elements.\n//\nvec4 floatnD2vec4(in float[nD] vector)\n{\n    vec4 result;\n    for(int i=0; i<4; i++) {result[i] = vector[i];}\n    return result;\n}\n\n\n//\n// Convert a vec2 to a float[nD]. Only the 1st 2 elements are written,\n// all other elements of the float[nD] are set to zero.\n//\nfloat[nD] vec2floatnD(in vec2 vec)\n{\n    float[nD] result = values(0.0);\n    for(int i=0; i<2; i++) {result[i] = vec[i];}\n    return result;\n}\n// Put a vec2 into the 1st elements of an existing float[nD],\n// preserving the other elements of the float[nD].\nfloat[nD] vec2floatnD(in vec2 vec, in float[nD] vector)\n{\n    float[nD] result = vector;\n    for(int i=0; i<2; i++) {result[i] = vec[i];}\n    return result;\n}\n\n\n\n//\n// Convert a vec3 to a float[nD]. Only the 1st 3 elements are valid,\n// all other elements \n//\nfloat[nD] vec2floatnD(in vec3 vec)\n{\n    float[nD] result = values(0.0);\n    for(int i=0; i<3; i++) {result[i] = vec[i];}\n    return result;\n}\n// Put a vec3 into the 1st elements of an existing float[nD],\n// preserving the other elements of the float[nD].\nfloat[nD] vec2floatnD(in vec3 vec, in float[nD] vector)\n{\n    float[nD] result = vector;\n    for(int i=0; i<3; i++) {result[i] = vec[i];}\n    return result;\n}\n\n\n\n//\n// Convert a vec4 to a float[nD]. Only the 1st 4 elements are valid,\n// all other elements \n//\nfloat[nD] vec2floatnD(in vec4 vec)\n{\n    float[nD] result = values(0.0);\n    for(int i=0; i<4; i++) {result[i] = vec[i];}\n    return result;\n}\n// Put a vec4 into the 1st elements of an existing float[nD],\n// preserving the other elements of the float[nD].\nfloat[nD] vec2floatnD(in vec4 vec, in float[nD] vector)\n{\n    float[nD] result = vector;\n    for(int i=0; i<4; i++) {result[i] = vec[i];}\n    return result;\n}\n\n\n\n//\n// Define an explicit vector type of length nD.\n// This is useful for defining nD x nD matricies\n//\n// This structure should generall be avoided in favor\n// of using:  float[nD]\n//\n// This stuff is needed for the clumsy matrix handling.\n//\nstruct vecnD \n{\n    float[nD] col;  // short for element\n};\n    \n    \n//\n// Define an explicit type of nD x nD matrix.\n// This is useful for determinants, and the like.\n//\n// This structure should generall be avoided.\n//\nstruct matnD\n{\n    vecnD[nD] row;  // short for element\n};\n    \n\n//\n// Convert a vecnD to a float[nD].\n// This stuff is needed for the clumsy matrix handling.\n//    \nfloat[nD] vecnD2floatnD(in vecnD vector)\n{\n    float[nD] result;\n    for(int i=0; i<nD; i++){result[i] = vector.col[i];}\n    return result;\n}\n\n\n//\n// Convert a float[nD] to a vecnD.\n// This stuff is needed for the clumsy matrix handling.\n//    \nvecnD floatnD2vecnD(in float[nD] vector)\n{\n    vecnD result;\n    for(int i=0; i<nD; i++){result.col[i] = vector[i];}\n    return result;\n}\n\n    \n    \n//\n// Fill a matrix with a float value.\n// The dummy is only included so the function 'values'\n// can identify the type to return.\n//    \nmatnD values(in float value, in matnD dummy)    \n{\n    matnD result;\n    for(int i; i<nD; i++)\n    {\n        for(int j; j<nD; j++)\n        {\n            result.row[i].col[j] = value;\n        }\n    }\n    return result;\n}\n    \n\n\n//\n// Return an identity matrix, ie a zero matrix with 1 on the diagonal. \n//\nmatnD identity()\n{\n    matnD result;\n    result = values(0.0, result);\n    \n    for(int i=0; i<nD; i++)\n    {\n        result.row[i].col[i] = 1.0;\n    }\n    return result;\n}\nmatnD identity(in matnD dummy)\n{\n    matnD result;\n    result = values(0.0, result);\n    \n    for(int i=0; i<nD; i++)\n    {\n        result.row[i].col[i] = 1.0;\n    }\n    return result;\n}\n \n\n//\n// Construct a rotation matrix around a principle axis, starting with dimension 0. Specify the axis number,\n// and the angle, theta.\n//\nmatnD getRotationMatrix(in int axis1, in int axis2, in float theta)\n{\n    // reverse the axes, if axis2 is smaller.\n    if(axis2 < axis1) {int temp = axis1; axis1 = axis2; axis2 = temp;}\n    \n    //\n    // construct the rotation matrix.\n    //\n    // Make an identity matrix\n    matnD rotation = identity();\n    \n    //\n    // Set the rotation values.\n    // \n    // 1st the diagonals: cos\n    rotation.row[axis1].col[axis1] = cos(theta);\n    rotation.row[axis2].col[axis2] = cos(theta);\n    //\n    // then the lower value:  sin\n    rotation.row[abs(axis2)].col[axis1] = sin(theta);\n    //\n    // last the upper value:  -sin\n    rotation.row[abs(axis1)].col[axis2] = -sin(theta);\n    \n    return rotation;\n}\n\n\n\n\n//\n// Matrix times a vector:  Mv    ie vector on right\n//\nfloat[nD] times(in matnD matrix, in float[nD] vector)\n{\n    float[nD] result = values(0.0);\n    \n    for(int i=0; i<nD; i++) \n    {\n        float[nD] currentRow = vecnD2floatnD(matrix.row[i]);\n\t\tresult[i] = dotnD(currentRow, vector);\n    }\n    \n    return result;\n}\n    \n\n\n\n","name":"Common","description":"","type":"common"}]}