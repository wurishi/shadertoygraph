{"ver":"0.1","info":{"id":"XXKSzG","date":"1720105715","viewed":39,"name":"Raymarching Sample","username":"MisterSirCode","description":"This is a Template Shader for my future Raymarching projects","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Minimum distance cuts off stuff near the camera. Useful for clipping shaders.\n// Max distance cuts off stuff far from the camera... Also draws the background at that distance.\n// Max steps is simply the \"precision\" of the raymarching stepper. \n//    Lower numbers will cause culling near corners and edges, especially with complex objects.\n// Epsilon is just the precision for certain math operations. You wont need to change it much.\n\n#define MIN_DIST 0.0\n#define MAX_DIST 200.0\n#define MAX_STEPS 1024\n#define EPSILON 0.0001\n\n// Set AA to 1 for \"default\" rendering, no Antialiasing\n\n#define AA 4\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Include Basic Antialiasing... Otherwise this whole thing is kind of pointless for rendering.\n    // Technique barrowed from Inigo Quilez.\n    // Simply put, spin UV / Directional UVs by Pixel Coordinates. Divide the Result by AA^2 (Average)\n    // Everything else works like a normal raymarcher.\n    \n    vec3 ttl; // Total Color\n    \n    for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++) {\n    \n        #if AA>1\n\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5; // Pixel Coordinates\n        vec3 dir = getDir(45.0, iResolution.xy, fragCoord + o); // 45* FOV for every point on the UV\n\n        #else\n\n        vec3 dir = getDir(45.0, iResolution.xy, fragCoord); // 45* FOV for every point on the UV\n\n        #endif\n\n        float cuTime = iTime / 10.0;\n        vec3 eye = vec3(sin(cuTime) * 6.0, 3.0, cos(cuTime) * 6.0); // Spin Camera Position around 0,0,0\n        mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)); // Point Camera to 0,0,0\n        vec3 worldDir = viewToWorld * dir; // Apply matrix to UV Directions\n\n        // Raymarch from the now transformed UV positions, to the scene\n        \n        float dist = getDist(eye, worldDir, MIN_DIST, MAX_DIST, MAX_STEPS, EPSILON);\n        if (dist > MAX_DIST - 0.00001) {\n            \n            ttl += vec3(0); // Draw Background\n            \n        } else {   \n        \n            vec3 pos = eye + dist * worldDir; // Positional Data for any 3D point in the scene\n            vec3 norm = getNorm(pos, eye, EPSILON); // Normals for any 3D point in the scene\n\n            // Output Color Total\n            ttl += norm;\n            \n        }\n    }\n    \n    // Finish Antialiasing and Render\n    #if AA>1\n    \n    ttl /= float(AA*AA);\n    \n    #endif\n    \n    fragColor = vec4(ttl, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Actual Scene\nfloat getScene(vec3 pos, vec3 eye) {\n    return length(pos) - 1.0;\n}\n\n\n// Create Directional UVs\nvec3 getDir(float fov, vec2 size, vec2 fragCoord) {\n    vec2 coord = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(coord, -z));\n}\n\n// Raymarcher\nfloat getDist(vec3 eye, vec3 dir, float start, float end, int maxSteps, float eps) {\n    float depth = start;\n    for (int i = 0; i < maxSteps; i++) {\n        float dist = getScene(eye + depth * dir, eye);\n        if (dist < eps)\n\t\t\treturn depth;\n        depth += dist;\n        if (depth >= end)\n\t\t\treturn end;\n    }\n}\n\n// Simple View Matrix\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// 4-Way Numerical Normals (Barrowed from Inigo Quilez)\nvec3 getNorm(vec3 pos, vec3 eye, float px) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.25 * px;\n    return normalize(e.xyy * getScene(pos + e.xyy, eye) + \n\t\t\t\t\t e.yyx * getScene(pos + e.yyx, eye) + \n\t\t\t\t\t e.yxy * getScene(pos + e.yxy, eye) + \n\t\t\t\t\t e.xxx * getScene(pos + e.xxx, eye));\n}","name":"Common","description":"","type":"common"}]}