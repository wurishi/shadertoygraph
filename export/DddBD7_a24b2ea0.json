{"ver":"0.1","info":{"id":"DddBD7","date":"1699832271","viewed":120,"name":"Navigable Fractal with AA","username":"stb","description":"Uses a basic temporal antialiasing technique. Controls are listed in the Image shader.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","antialiasing","complex","aa","inversion","temporal","taa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Navigable Fractal with AA\n    \n    Options in Buffer A.\n    \n    Controls\n        WASD ....... pan canvas (ESDF is also available)\n        UP, DOWN ... zoom in / out\n        1, 2 ....... change fractal parameter 1\n        3, 4 ....... change fractal parameter 2\n        5, 6 ....... change fractal scaling factor (not a zoom)\n        SHIFT ...... hold to accelerate controls\n        B .......... freeze color (for taking full-screen screen shots)\n        Mouse ...... change colors (x/y, color 1/2 from palette)\n        SPACE ...... reset canvas\n        R .......... reset to default values\n\n    Tips\n        * to fully refresh aa when entering/exiting full screen, press SHIFT\n        * for even smoother results, raise Blend value in Buffer A (0.99 is good, but slow to converge)\n*/\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n    vec2 uv = fc / iResolution.xy;\n\n    fo = vec4(texture(iChannel0, uv).rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n/* Options */\n\n#define Iters 64\n\n#define InitOffset vec2(1.0, .01)\n#define InitScale 2.\n#define InitColAt vec2(.39, .1);\n#define InitCanvas vec3(1.75, 1.75, 1.) // x, y, zoom\n\n#define AARadius 1.5\n#define Blend .975 // (0.0 to 1.0)\n\n#define SpeedMult vec2(1.0, 12.0) // .x=normal, .y=when shift is pressed\n#define PanSpeed  0.0075\n#define ZoomSpeed 0.0125\n#define OffsetSpeed .0005\n#define ScaleSpeed .005\n\n// navigation multiplier when pressing shift key\n#define ShiftSpeed float(keyPressed(KEY_SHIFT)==1. ? SpeedMult.y: SpeedMult.x)\n\n// uncomment for ESDF panning\n//#define ESDF\n\n/* End Options */\n\n\n// hash without sine: https://www.shadertoy.com/view/4djSRW\n// Dave_Hoskins\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.8975, 397.2973, 491.1871));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n/*vec2 pinnedInversion(in vec2 p, vec2 o) {\n    p = p / dot(p, p) - o;\n    p = p / dot(p, p);\n    return p;\n}*/\n\n// feel free to change this to whatever\nfloat fractal(in vec2 p, vec2 o, float s) {\n\tconst int I = Iters;\n\tfloat f = 0.;\n\tfor(int i=0; i<I; i++) {\n        // pinned inversion\n        p = p / dot(p, p) - o;\n        p = p / dot(p, p);\n        \n        // julia\n        p = vec2(p.x*p.x-p.y*p.y, 2.*p.x*p.y);\n        \n        // mirror\n\t\tp = abs(p);\n        \n        // scale\n        p = s * (p-.5);\n        \n        // add to value\n\t\tf += 2.*max(0., 1.-(length(p)/sqrt(2.))) / float(I);\n\t}\n\treturn clamp(f, 0., 1.);\n}\n\n// data in\n#define getData(i) texelFetch(iChannel0 , ivec2(i, 0), 0)\n\n// data out\n#define putData(i, v4) if(i==int(fc.x) && floor(fc.y)==0.) fo = v4;\n\n// keyboard values found with mattz's shader: https://www.shadertoy.com/view/4dGyDm\nconst int KEY_SHIFT = 16;\n//const int KEY_CTRL  = 17;\n//const int KEY_ALT  = 18;\nconst int KEY_SPACE  = 32;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\nconst int KEY_4  = 52;\nconst int KEY_5  = 53;\nconst int KEY_6  = 54;\n\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_W = 87;\n\n#define keyPressed(k) float(texelFetch(iChannel1, ivec2(k, 0), 0).x > 0.)\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fc/res.xy;\n    vec2 p = (fc-res/2.) / res.y;\n    \n    // get stored values\n    vec3 canvas = getData(0).xyz;\n    float fScale = getData(0).w;\n    vec2 fOffset = getData(1).xy;\n    vec2 colAt = getData(1).zw;\n    \n    // initialize things for first frame\n    if(iFrame==0) {\n        canvas = InitCanvas;\n        \n        fScale = InitScale;\n        \n        fOffset = InitOffset;\n        \n        colAt = InitColAt;\n    }\n    \n    // is key pressed\n    bool ikp = false;\n    \n    \n    /*   Input Controls   */\n    \n    // panning direction\n    vec2 Dir = vec2(0.);\n    #ifdef ESDF\n        Dir =\n            vec2(\n                keyPressed(KEY_F) - keyPressed(KEY_S),\n                keyPressed(KEY_E) - keyPressed(KEY_D)\n            );\n    #else\n         Dir =\n            vec2(\n                keyPressed(KEY_D) - keyPressed(KEY_A),\n                keyPressed(KEY_W) - keyPressed(KEY_S)\n            );\n    #endif\n    \n    // pan canvas\n    canvas.xy += PanSpeed * ShiftSpeed * Dir * pow(2., canvas.z);\n    \n    // zoom canvas\n    canvas.z += ZoomSpeed * ShiftSpeed * (keyPressed(KEY_DOWN)-keyPressed(KEY_UP));\n    p *= pow(2., canvas.z);\n    \n    // shift fractal scale (not zoom)\n    fScale += ScaleSpeed * ShiftSpeed * (keyPressed(KEY_5)-keyPressed(KEY_6));\n    \n    // pan canvas\n    p += canvas.xy;\n   \n    // fractal offset\n    fOffset +=\n        OffsetSpeed * ShiftSpeed * vec2(\n            keyPressed(KEY_1) - keyPressed(KEY_2),\n            keyPressed(KEY_3) - keyPressed(KEY_4)\n        );\n    \n    /*   End Input Controls   */\n   \n    // fractal value\n    float f;\n    if(true) // square aa\n        f = fractal(p+AARadius*(.5-hash22(mod(p+iTime, 100.)))/res.y*pow(2., canvas.z), fOffset, fScale);\n    else {   // circular aa\n        vec2 h = hash22(mod(p+iTime, 100.));\n        h = .5 * sqrt(h.x) * vec2(sin(6.2832*h.y), cos(6.2832*h.y));\n        f = fractal(p+AARadius*h/res.y*pow(2., canvas.z), fOffset, fScale);\n    }\n    \n    // is key pressed or this the initial frame? (ugh-code)\n    ikp =\n        bool(\n            float(iFrame==0) +\n            keyPressed(KEY_W) +\n            keyPressed(KEY_A) +\n            keyPressed(KEY_S) +\n            keyPressed(KEY_D) +\n            keyPressed(KEY_E) +\n            keyPressed(KEY_F) +\n            keyPressed(KEY_R) +\n            keyPressed(KEY_1) +\n            keyPressed(KEY_2) +\n            keyPressed(KEY_3) +\n            keyPressed(KEY_4) +\n            keyPressed(KEY_5) +\n            keyPressed(KEY_6) +\n            keyPressed(KEY_UP) +\n            keyPressed(KEY_DOWN) +\n            keyPressed(KEY_SPACE) +\n            keyPressed(KEY_SHIFT)\n        );\n    \n    // basic colors for x & y position\n    vec3 c1, c2;\n    for(float i=0.; i<3.; i++) {\n        c1[int(i)] = .5 + 3. * abs(fract((colAt.x+.23*i-.34)*4.*(i+1.))-.5);\n        c2[int(i)] = 5. * abs(fract((colAt.y+1.7734-.417*i)*4.*(i+1.))-.5) - .5;\n    }\n    \n    // mix colors\n    vec3 col = mix(c1, c2, abs(fract(f*2.)-.5)*2.) * f;\n    \n    //col *= abs(fract(col*8.)-.5)*2.;\n    \n    // lock everything when B is toggled\n    bool BLock = texelFetch(iChannel1, ivec2(KEY_B, 2), 0).x > 0.;\n    vec3 oCol = texture(iChannel0, uv).rgb;\n    if(BLock) col = oCol;\n    \n    // use blend when key is not pressed\n    if(iMouse.z<=0. && !ikp)\n        col = mix(col, oCol, Blend);\n    \n    // set color position\n    if(iMouse.z>0.)\n        colAt = iMouse.xy / res.xy;\n    \n    // initial vec4 output\n    fo = vec4(col, 1.);\n    \n    // reset canvas\n    if(bool(keyPressed(KEY_SPACE)))\n        canvas = InitCanvas;\n    \n    // write variables\n    putData(0, vec4(canvas, fScale))\n    putData(1, vec4(fOffset, colAt))\n    \n    // initial frame or reset\n    if(iFrame==0 || bool(keyPressed(KEY_R))) {\n        // reset canvas and fScale\n        putData(0, vec4(InitCanvas, InitScale))\n        \n        colAt = InitColAt;\n        \n        // initial offset\n        putData(1, vec4(InitOffset, colAt))\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}