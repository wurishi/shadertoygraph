{"ver":"0.1","info":{"id":"DtXfD7","date":"1693066952","viewed":165,"name":"Contrast Preserving Blend","username":"gehtsiegarnixan","description":"This is a comparison as well as a simple, commented demo on how to preserve contrast when interpolating colors.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["test","mix","contrast","lerp","blend","interpolation","comparison"],"hasliked":0,"parentid":"dsjBzh","parentname":"Dither UV Interpolation"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is a simple demo and guide designed to help you understand contrast-preserving \ninterpolation techniques.\n\nThe interpolation between two colors leads to a reduction in contrast, which can \nbecome quite noticeable. To mitigate the diminished contrast, we compare two \nmethods I found on Shadertoy.\n\nThe shader illustrates these two methods standalone functions, with comments and \nreformatting for improved readability. The columns, from top to bottom, showcase:\n1. The alpha parameter utilizing the Viridis Colormap.\n2. A toggle between two textures at an alpha value of 0.5.\n3. Standard interpolation between the two textures.\n4. Histogram-Preserving Blending (by Fabrice Neyret, https://www.shadertoy.com/view/4dcSDr).\n5. Contrast-Aware Blending (by huwb, https://www.shadertoy.com/view/MtcGWs).\n\nIn my opinion, Histogram-Preserving Blending is superior. However, it requires either \nsampling a texture with the lowest-resolution mip or manually recording the average \ncolor of the texture. It does slightly affect colors outside of the blending region. \nI recommend using this technique for general blending; it even produces excellent \nresults with barycentric and bilinear interpolation.\n\nOn the other hand, huwb's method doesn't necessitate an additional sample. \nNevertheless, the blending region remains visible, and textures outside of the \ndesignated blend regions continue to blend together. I advise against using this \nmethod beyond its intended purpose, as it may not yield optimal results.\n*/\n\n// select the texture using an index. Acts like a crude texture array\nvec4 textureArray(int index, vec2 uv) {\n    vec4 color;\n    if (index == 0) {\n        color = texture(iChannel0, uv);\n    } else if (index == 1) {\n        color = texture(iChannel1, uv);\n    } else if (index == 2) {\n        color = texture(iChannel2, uv);\n    } else {\n        color = texture(iChannel3, uv);\n    }\n    return color;\n}\n\n// select the texture using an index. Acts like a crude texture array with mip level\nvec4 textureArray(int index, vec2 uv, float mip) {\n    vec4 color;    \n    if (index == 0) {\n        color = texture(iChannel0, uv, mip);\n    } else if (index == 1) {\n        color = texture(iChannel1, uv, mip);\n    } else if (index == 2) {\n        color = texture(iChannel2, uv, mip);\n    } else {\n        color = texture(iChannel3, uv, mip);\n    }\n    return color;\n}\n\n// hard Edge from switching directly between on or the other\nvec4 twoTextureSwitch(int texIndex, vec2 uvA, vec2 uvB, float alpha) {\n    // switch between uvs at halfway point of alpha\n    vec2 uvSwitch = (alpha < 0.5) ? uvA : uvB;\n    \n    // sample a texture array for the demo, but can be replaced default texture\n    return textureArray(texIndex, uvSwitch);\n}\n\n// vanilla interpolation of two textures\nvec4 twoTextureLerp(int texIndex, vec2 uvA, vec2 uvB, float alpha) {\n     // sample a texture array for the demo, but can be replaced default texture\n     vec4 A = textureArray(texIndex, uvA);\n     vec4 B = textureArray(texIndex, uvB);\n     \n     // Interpolation between the textures\n     return mix(A, B, alpha);\n}\n\n// NB: trick published in https://hal.inria.fr/inria-00536064v2\n// deeper conservation: see histogram-preserving here: https://hal.inria.fr/hal-01824773\n// modified version of FabriceNeyret2 https://www.shadertoy.com/view/4dcSDr \nvec4 conrastCorrectBlend(int texIndex, vec2 uvA, vec2 uvB, float alpha) {\n    // sample a texture array for the demo, but can be replaced default texture\n    vec4 A = textureArray(texIndex, uvA);\n    vec4 B = textureArray(texIndex, uvB);\n    \n    // Interpolation between the textures\n    vec4 col = mix(A, B, alpha);\n    \n    // redudant for true alpha with sum 1\n    float alphaSum = 1.; // alpha + (1.-alpha);\n    \n    // square alphas and add them up\n    float squaredAlphaSum = alpha * alpha + (1.-alpha) * (1.-alpha);\n    \n    // sampling mips lowest level to get the mean, could be a constant if known\n    vec4 mean = textureArray(texIndex, uvA, 12.);\n    \n    // variance restoration with normalization\n    return mean + (col - alphaSum * mean) / sqrt(squaredAlphaSum);\n}\n\n// from huwb https://www.shadertoy.com/view/MtcGWs\nvec4 contrastBlend(int texIndex, vec2 uvA, vec2 uvB, float alpha ) {\n    // sample a texture array for the demo, but can be replaced default texture\n    vec4 A = textureArray(texIndex, uvA);\n    vec4 B = textureArray(texIndex, uvB);\n     \n    // brightness\n    float Ab = A.x * B.y * A.z;\n    float Bb = B.x * B.y * B.z;\n    \n    // work out blend param based on relative brightness, smoothstep\n    // to increase contrast.\n    float contrastAlpha = smoothstep(0.,1.,2.*Ab/(Ab+Bb));\n    \n    // push our alpha towards the contrastAlpha, but still follow alpha to 0 and 1.\n    \n    // goes to 0 when alpha is near 0 or 1\n    float proximityTo01 = min(alpha,1.-alpha);\n        \n    // powering it up seems to give better results\n    proximityTo01 = pow( proximityTo01, 0.25);\n    \n    // mix between alpha and contrast-aware alpha\n    alpha = mix( alpha, contrastAlpha, proximityTo01);\n    \n    //return vec4(viridis(alpha), 0.);\n    \n    // Interpolation\n    return mix( A, B, alpha );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // square UVs\n    float scale = 9.;\n    vec2 uvA = fragCoord/iResolution.y * scale;\n    \n    // rotate UVs to have two sets of UVs\n    vec2 direction = normalize(vec2(1., -1.));\n    vec2 uvB = mat2x2(direction.y, direction.x, -direction.x, direction.y)*uvA; \n\n    // normalized UV, Alpha.y for spliting up and Alpha.x the interpolation\n    vec2 Alpha = fragCoord / iResolution.xy;\n    \n    // add some animation\n    float aniPeriod = 5.; // in seconds for a full cycle\n    float aniValue = pow(abs(fract(iTime/aniPeriod+.5)-.5)*2.,2.);\n    \n    // slightly increase contrast of alpha.x\n    float Contrast = mix(1., 8., aniValue);\n    Alpha.x = straightContrast(Alpha.x, 1.5); // so small region stays a or b\n    Alpha.x = smoothContrast(Alpha.x, Contrast);  // increases contrast of alpha\n    Alpha.x = clamp(Alpha.x, 0.0, 1.0); // prevents float errors\n    \n    // setup breakup of screen\n    float ComparisonCount = 5.; // how many sections we have\n    float zeroSectionSize = 0.5; // alpha display smaller\n    Alpha.y = 1.-Alpha.y; // invert coordinates\n    float zeroOffset = (zeroSectionSize-1.)/(ComparisonCount-1.);\n    Alpha.y = ((Alpha.y - zeroOffset)/(1.-zeroOffset));\n    float y = floor(Alpha.y*ComparisonCount);\n        \n    // switch textures around to see method on different textures\n    float switchPerid = aniPeriod * 4.0; // in seconds for a full cycle\n    int texIndex = int(4.0 * fract(iTime / switchPerid)); //0-4 values\n    \n    // add the comparison methods\n    if (y == 0.) {\n        // show the alpha value, with pretty colormap\n        fragColor.xyz = viridis(Alpha.x);\n    } else if (y == 1.) {\n        // hard switch between two texture\n        fragColor = twoTextureSwitch(texIndex, uvA, uvB, Alpha.x);\n    } else if (y == 2.) {\n        // default 2 texture lookup lerp\n        fragColor = twoTextureLerp(texIndex, uvA, uvB, Alpha.x);\n    } else if (y == 3.) {\n        // default 2 texture lookup lerp\n        fragColor = conrastCorrectBlend(texIndex, uvA, uvB, Alpha.x);\n    } else if (y == 4.) {\n        // default 2 texture lookup lerp\n        fragColor = contrastBlend(texIndex, uvA, uvB, Alpha.x);\n    }\n\n    // black bars\n    float BorderThickness = 0.04;\n    float ZigzagPattern = abs(fract(Alpha.y*(ComparisonCount))-0.5);\n    fragColor *= vec4(step(ZigzagPattern, 0.5-BorderThickness*0.5)); \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//_____________________GENERIC FUNCTIONS______________________________\n\n// Increases the steepness of Alpha while forcing 0-1 range and 1 sum\n// See desmos graph example (https://www.desmos.com/calculator/dpxa6mytnv)\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInfAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInfAlpha);\n}\n\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}","name":"Common","description":"","type":"common"}]}