{"ver":"0.1","info":{"id":"4ffyR2","date":"1721295176","viewed":20,"name":"Raymatching_BaseDiffuse","username":"Imanity","description":"a common Raymatching Baseframe","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymatching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TMIN 0.1\n#define TMAX 20.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n\nvec3 PointLightPos=vec3(-1.,1.,1.);\nvec3 ro=vec3(0.,0.,-2.);\n\nvec3 Sphere1pos=vec3(0.,0.,0.);\nfloat Sphere1R=0.5;\nvec3 Cube1pos=vec3(0.7,0.,0.3);\nvec3 BaseColor=vec3(0.4,0.4,0.4);\n\nvec2 fixUV(in vec2 c)\n{\n    return (-iResolution.xy+2.0*c)/min(iResolution.x,iResolution.y);\n}\n\n\n\n    //-----PUT SDF HERE----\n\nfloat SDF(in vec3 pos)\n{\n    float Sphere1SDF=length(pos+Sphere1pos)-Sphere1R;\n    \n    vec3 C1p=vec3(pos.xyz-Cube1pos.xyz);\n\n    return \n    Sphere1SDF;   \n}\n    //-----SDF END------\n    \nfloat rayMarch(in vec3 ro,in vec3 rd)\n{\n    float t =TMIN;\n    for(int i =0;i<RAYMARCH_TIME && t<TMAX;i++)\n    {\n        vec3 p=ro+t*rd;\n        float d=SDF(p);\n        if(d<PRECISION)\n        {\n        break;\n        }\n        t+=d;\n    }\n    return t;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h=0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*SDF(p+k.xyy*h)+\n                      k.yyx*SDF(p+k.yyx*h)+\n                      k.yxy*SDF(p+k.yxy*h)+\n                      k.xxx*SDF(p+k.xxx*h));\n}\n\nvec3 render(in vec2 uv,in vec3 lightpos)\n{\n    vec3 color=vec3(0.);\n\n    vec3 rd=normalize(vec3(uv,0.)-ro);\n    float t = rayMarch(ro,rd);\n    \n    if(t<TMAX)\n    {\n        vec3 p=ro+t*rd;\n        vec3 n=calcNormal(p);\n        vec3 light=lightpos;\n        float dif=dot(normalize(light-p),n);\n        color=dif*vec3(1.);\n    }\n    return color;\n}\n\nvec3 VNormal(in vec2 uv)\n{\n    vec3 color=vec3(0.);\n\n    vec3 rd=normalize(vec3(uv,0.)-ro);\n    float t = rayMarch(ro,rd);\n    \n    if(t<TMAX)\n    {\n        vec3 p=ro+t*rd;\n        vec3 n=calcNormal(p);\n        vec3 Nor=normalize(n);\n        color=Nor;\n    }\n    return color;\n}\n\nvec3 Alpha(vec2 uv)\n{\n    vec3 color=vec3(0.);\n\n    vec3 rd=normalize(vec3(uv,0.)-ro);\n    float t = rayMarch(ro,rd);\n    \n    if(t<TMAX)\n    {\n        color=vec3(1.);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float MR=iMouse.x/iResolution.x;\n    \n    vec2 uv = fixUV(fragCoord.xy);\n    vec3 color =render(uv,\n    vec3(1.,1.,-1.)\n                       );\n    vec3 cameraVectorZ=clamp(render(uv,vec3(0.,0.,-2.)),0.,1.);\n    \n                       \n    vec3 AM=Alpha(uv);\n    vec3 Res=(color+1.)/2.*AM;\n    vec3 N=VNormal(uv)*AM;\n    vec3 skylight=vec3(dot(N,vec3(0.,-1.,0.)))*vec3(0.03,0.05,0.08);\n    vec3 highlight=vec3(clamp(pow(color.x-0.3,5.),0.,1.));\n    vec3 Frensel=vec3(pow(1.-cameraVectorZ.x,3.))*0.1*AM;\n    \n    vec3 Diffuse=AM*BaseColor*Res*2.+clamp(skylight,0.,1.)+highlight+Frensel;\n    fragColor=vec4(Diffuse,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}