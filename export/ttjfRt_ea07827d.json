{"ver":"0.1","info":{"id":"ttjfRt","date":"1599648565","viewed":194,"name":"5th Dimentional Flower 2.","username":"julianlumia","description":"Not really 5D I know:p still it looks kinda cool;)","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["creature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec2 N(float angle)\n{\n return vec2(sin(angle),cos(angle));\n}\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 10e6;\n t = pmod(t,2./.1);\n t *=.1;\n float yid = (floor( (p.y + 0.)*0. ) );\n float W = 2.;\n float modd = .4;\n float sqD = max(abs(t.y), abs(t.y));\n sqD +=2. + yid*1.;\n float sqid = floor(sqD/modd);\n d = min(d, sqD);\n o +=  pal(.1, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*40.), -0.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n sqD -= 1.;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n return o;\n}\n\nfloat g1;\n#define time iTime\nvec2 mouse;\nfloat PI = acos(-1.);\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));    \t    \n}\n\nmat2 rot2d(float a) {\n float c = cos(a), s = sin(a);\n return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float s, float tf) {\n float f = sin(iTime*.25)-6.;\n for (int i = 0; i <4; i++) {\n   p.xy *= -rot2d(f);\n   p.zy *= rot2d(f);\n   p.xz *= rot2d(f);\n   p =  (max (abs(p)-vec3(0.05,0.1,0.05),0.));  \n  }\n  return p;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n vec2 d =vec2(0.);   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot(cos(iTime*.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n vec3 q = (text(p.xy, p*1.)).xyz*1.;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nvec2 GetDist(vec3 p) {\n\n vec2 d =vec2(0.);\n vec3 q = p;   \n float dp = dot(p,p*0.1)*.8;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot(cos(iTime*.05));\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n d = vec2(sdBox(p,vec3(3.)) + sdBox(q,vec3(0,0.,0.)),1);\n d.x *=1.;\n d.x =(((d.x*dp)/5.));\n g1 +=1./(.000008+pow(abs(d.x),10.));\n d = condmin( d,d);    \n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<MAX_STEPS; i++) \n  {\n\t h = GetDist(ro + t.x * rd);\n \tif(h.x<SURF_DIST||t.x>MAX_DIST) break;\n \t\t t.x+=h.x*1.;\n \t\t t.y=h.y;\n  }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime)*1., cos(iTime)*2., 2);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n //vec3 col = vec3(0);  \nvec3      col = abs(vec3(-0.5,1.*uv.y,.2)-.1)*.1;\n\n vec3 ro = vec3(3.,3., 5.);\n ro.xy *= Rot(sin(iTime*0.2)*6.2831);\n ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n if(d.y==1.) col += tex3D(p,n)*2.;\n }\n col*=g1*vec3(.000005);  \n float fog = 1. / (1. + d.x * d.x *5.);\n col *= vec3(fog); \n col*= 1.; \n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}