{"ver":"0.1","info":{"id":"NtycWz","date":"1661213812","viewed":196,"name":"Forest Marcher","username":"MrHAX00","description":"Thought I'd try making a scene and ended up with this!","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["simple","sdf","lighting","grass","tree","forest","firstperson","pebble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MaxDistance 30.\n#define MinDistance .0075\n\n//SDF functions\nfloat GroundSDF(vec3 Point)\n{\n    return Point.y;\n}\n\nfloat ConeSDF(vec3 Point)\n{\n    Point -= ConePosition + (Hash33(floor(Point / 2. / ConeSize)) - .5) * vec3(.9, .2, .9);\n    Point /= ConeSize * vec3(1., 2., 1.);\n    Point = vec3(mod(Point.x + 1., 2.) - 1., Point.y - .25, mod(Point.z + 1., 2.) - 1.);\n    Point *= ConeRotation;\n    return max(length(Point) - 1.392 * -Point.y, length(Point - clamp(Point, vec3(-.5), vec3(.5)))) * .8;\n}\n\nconst vec3 TrunkPosition = ConePosition - vec3(0., TrunkHeight, 0.);\nfloat TrunkSDF(vec3 Point)\n{\n    Point -= TrunkPosition + (Hash33(floor(Point / 2. / ConeSize)) - .5) * vec3(1., .2, 1.);\n    Point /= TrunkSize * vec3(1., 2., 1.);\n    Point = vec3(mod(Point.x + 1., 2.) - 1., Point.y - .25, mod(Point.z + 1., 2.) - 1.);\n    Point *= ConeRotation;\n    return max(length(Point) - 1.392 * -Point.y, length(Point - clamp(Point, vec3(-.5), vec3(.5))));\n}\n\nfloat PebbleSDF(vec3 Point)\n{\n    vec3 Hash = Hash33(floor(Point / PebbleSize / .25 + .5)) - .5;\n    Point -= vec3(Hash.x * .37, -(Hash.y * Hash.y) * 1.5, Hash.z * .37);\n    Point /= PebbleSize;\n    Point = vec3(mod(Point.x + .125, .25) - .125, Point.y, mod(Point.z + .125, .25) - .125);\n    return length(Point) - PebbleRadius;\n}\n\n//Normals\nvec3 GroundNormal(vec3 Hit)\n{\n    vec3 Offset = texture(iChannel0, vec2(floor(Hit.x * 200.) * .005, floor(Hit.z * 200.) * .005)).rgb;\n    return normalize(vec3(Offset.r * .3 - .15, Offset.g + .3, Offset.b * .3 - .15));\n}\n\nconst vec3 ConeTip = vec3(0., ConeSize.y, 0.);\nvec3 ConeNormal(vec3 Hit)\n{\n    Hit -= ConePosition + (Hash33(floor(Hit / 2. / ConeSize)) - .5) * vec3(.9, .2, .9);\n    Hit /= ConeSize;\n    Hit = vec3(mod(Hit.x + 1., 2.) - 1., Hit.y, mod(Hit.z + 1., 2.) - 1.);\n    Hit *= ConeRotation;\n    \n    vec2 uv = (ConeRotation * (Hit * .6)).xz;\n    return normalize(ConeRotation * (LookAt(Hit, ConeTip) * vec3(0., 1., 0.)) + texture(iChannel0, uv).rgb * .8 - .4);\n}\n\nconst vec3 TrunkTip = vec3(0., TrunkSize.y, 0.);\nvec3 TrunkNormal(vec3 Hit)\n{\n    Hit -= TrunkPosition + (Hash33(floor(Hit / 2. / ConeSize)) - .5) * vec3(1., .2, 1.);\n    Hit /= ConeSize * vec3(1., 2., 1.);\n    Hit = vec3(mod(Hit.x + 1., 2.) - 1., Hit.y - .25, mod(Hit.z + 1., 2.) - 1.);\n    Hit *= ConeRotation;\n    \n    return ConeRotation * (LookAt(Hit, TrunkTip) * vec3(0., 1., 0.));\n}\n\nvec3 PebbleNormal(vec3 Hit)\n{\n    vec3 Hash = Hash33(floor(Hit / PebbleSize / .25 + .5)) - .5;\n    Hit -= vec3(Hash.x * .37, -abs(Hash.y) * .2, Hash.z * .37);\n    Hit /= PebbleSize;\n    Hit = vec3(mod(Hit.x + .125, .25) - .125, Hit.y, mod(Hit.z + .125, .25) - .125);\n    \n    return normalize(Hit);\n}\n\n//March\nfloat GetDistance(vec3 Position)\n{\n    return min(min(GroundSDF(Position), ConeSDF(Position)), min(TrunkSDF(Position), PebbleSDF(Position)));\n}\n\nfloat March(vec3 Origin, vec3 Direction, float DistanceLimit)\n{\n    float Distance = GetDistance(Origin);\n    for (int i = 1; true; i++)\n    {\n        float Delta = GetDistance(Origin + Direction * Distance);\n        \n        Distance += Delta;\n        if (Delta < MinDistance || Distance > DistanceLimit) break;\n    }\n    \n    return clamp(Distance, 0., DistanceLimit);\n}\n\n//Apply materials\nvec3 GetColor(vec3 Hit, vec3 Direction)\n{\n    vec3 BaseColor;\n    \n    float Distance = GetDistance(Hit);\n    \n    float Length = length(LightPos - Hit);\n    float Light = clamp((LightDistance - Length) / LightDistance, 0., 1.);\n    float Dot = dot(Direction, vec3(0., 0., 1.));\n    Light *= (Dot * Dot * Dot * Dot * Dot) * 2.;\n    Direction = normalize(LightPos - Hit);\n    float Shadow = March(Hit + Direction * .1, Direction, Length) / Length;\n    \n    if (GroundSDF(Hit) == Distance)\n    {\n        BaseColor = vec3(mod(floor(Hit.x + texture(iChannel0, Hit.xz).z * .1) + floor(Hit.z + texture(iChannel0, Hit.zx).x * .1), 2.)) * .15 + .85;\n        BaseColor *= Shadow * clamp(dot(GroundNormal(Hit), Direction), 0., 1.) * Light;\n        BaseColor *= vec3(.6, .8, .4);\n    } else if (ConeSDF(Hit) == Distance)\n    {\n        vec3 Normal = ConeNormal(Hit);\n        vec2 uv = Hit.xz * .4;\n        BaseColor = vec3(.7, .8, .4) * (dot(Normal, Direction) * Light * Shadow) * (Hash33(floor(Hit / 2. / ConeSize)) * .3 + .7) * (texture(iChannel0, uv).r * .3 + .7);\n    } else if (TrunkSDF(Hit) == Distance)\n    {\n        vec3 Normal = TrunkNormal(Hit);\n        vec2 uv = floor(Normal.xz * 20.) * .05 + Hit.xz * .3;\n        BaseColor = vec3(.4, .25, .1) * (dot(Normal, Direction) * Light * Shadow) * (Hash33(floor(Hit / 2. / ConeSize)) * .3 + .7) * texture(iChannel0, uv).r;\n    } else if (PebbleSDF(Hit) == Distance)\n    {\n        BaseColor = (Hash33(floor(Hit / PebbleSize / .25 + .5)).rrr * .5 + .4) * (texture(iChannel0, floor(Hit.xz * 300.) * .0015).bbb * dot(PebbleNormal(Hit), Direction) * Shadow * .8 + .2) * Light;\n    }\n    \n    return BaseColor;\n}\n\n//Output to screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    \n    vec3 RayOrigin = CamPos;\n    vec3 RayDirection = CamRot * normalize(vec3(uv, 1.));\n\n    float Depth = March(RayOrigin, RayDirection, MaxDistance);\n    \n    vec3 Hit = RayOrigin + RayDirection * Depth;\n    \n    vec3 col = GetColor(Hit, RayDirection);\n    \n    fragColor = vec4(col, Depth);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159\n\n#define ConePosition vec3(1.5, 2., 7.5)\n#define ConeRotation AxisAngle(vec3(0., 1., 0.), cos(iTime * pi * .04) * pi) * AxisAngle(vec3(1., 0., 0.), cos(iTime * .2) * .1)\n#define ConeSize vec3(1.5, 2.5, 1.5)\n\n#define TrunkHeight 4.\n#define TrunkSize vec3(1.5, 7., 1.5)\n\n#define CamPos vec3(0., 1., iTime + cos(iTime * pi * 2. + .2) * .025)\n#define LightPos CamPos + vec3(-.3, 1.3, 0.)\n#define Shake AxisAngle(vec3(1., 0., 0.), cos(iTime * pi * .125) * .03) * AxisAngle(vec3(0., 1., 0.), cos(iTime * pi * .3) * .03) * AxisAngle(vec3(0., 0., 1.), cos(iTime * pi * .4) * .02)\n#define CamRot AxisAngle(vec3(1., 0., 0.), pow(cos(iTime * pi), 2.) * .075) * Shake\n#define LightDistance 30.\n\n#define PebbleSize vec3(2., 1., 2.)\n#define PebbleRadius .025\n\n//from https://www.shadertoy.com/view/Nl33W8\nmat3 AxisAngle(vec3 Axis, float Angle) {\n    float Sin = cos(Angle + pi * .5);\n    float Cos = cos(Angle);\n    return mat3(\n        Axis * Axis.x * (1. - Cos) + vec3(Cos, Axis.z * Sin, -Axis.y * Sin),\n        Axis * Axis.y * (1. - Cos) + vec3(-Axis.z * Sin, Cos, Axis.x * Sin),\n        Axis * Axis.z * (1. - Cos) + vec3(Axis.y * Sin, -Axis.x * Sin, Cos)\n    );\n}\n\n//from https://www.shadertoy.com/view/Nl33W8\nmat3 LookAt(vec3 From, vec3 To) {\n    vec3 Forward = normalize(To - From);\n    vec3 Right = normalize(cross(Forward, vec3(0., 1., 0.)));\n    vec3 Up = cross(Right, Forward);\n    return mat3(Right, Up, Forward);\n}\n\n//from iq\nvec3 Hash33(vec3 Point){\n    return vec3(\n        fract(cos(dot(Point, vec3(67.47834, 52.5363, 67.4353)))*45363.46356),\n        fract(cos(dot(Point, vec3(84.25652, 76.4533, 34.5474)))*34364.57434),\n        fract(cos(dot(Point, vec3(32.63437, 56.7483, 87.2445)))*67343.64473)\n    );\n}\n\n//from iq\nvec3 Hash23(vec2 Point){\n    return vec3(\n        fract(cos(dot(Point, vec2(67.47834, 52.5363)))*45363.46356),\n        fract(cos(dot(Point, vec2(84.25652, 34.5474)))*34364.57434),\n        fract(cos(dot(Point, vec2(56.74834, 87.2445)))*67343.64473)\n    );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Grass noise\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 1) discard;\n    fragColor = vec4(Hash23(fragCoord), 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}