{"ver":"0.1","info":{"id":"3d33WX","date":"1569344780","viewed":278,"name":"tower of doom ","username":"vjblind","description":"tower of doom is cool name ? isnt it ? ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["doom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.shadertoy.com/view/tstGD2\n///based on https://www.shadertoy.com/view/3l23Rh //\n\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\n\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;    \n   // p = p*m3;\n  //  p = sin(p.xyz*0.75 + iTime*.08);\n    f  = 0.5000 * noise(p); p =  p * 2.02;\n    f += 0.2500 * noise(p); p =  p * 2.03;\n    f += 0.1250 * noise(p); \n    f += 0.1250 * noise(p*30.);\n    return f;\n}\nfloat map5( in vec3 p )\n{    p.x = p.z+p.x;  \n p = sin(p.xyz*1.75 + iTime*.0);\n\tvec3 q = p - vec3(1.10,01.0,1.0)*iTime*0.4;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn  clamp(p.x* 1. - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\nfloat sphere(vec3 ro,vec3 p,float s)\n{\n//return length(ro-p)-s;\n      return  length(ro-p)  * -s + fbm(ro * 0.3);;\n} \n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\nfloat scene(in vec3 p)\n{ /*p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n   // p = sin(p.xyz*0.75 + iTime*.8);\n       p -= abs(dot(cos(p), sin(p.yzx)));*/\n   p = p*m3*0.01;\n  p.xy -= disp(p.z).xy;\n  // p +=p+0.0*p*.5*fbm(p * 0.01)*m3;// fbm(p * .3)*.0;\n\n\n    return  map5(  p );//length(p) * -0.00591+ fbm(p * .3);\n}\nvec2 map(vec3 ro){\nfloat res=0.0;\nfloat color=0.;\nres=  sphere(ro,vec3(0.0,1.0 ,0.0),20.5) ;\n \n\nif(res==sphere(ro,vec3(0.0,1.52 ,3.0),2.5))color=2.;\n \n\nreturn vec2(res,color);}\n\n\n\n\n\nvec4 march(vec3 ro,vec3 rd)\n{\nfloat d=0.0; //\nfloat material=0.;  \n    // Transmittance\n    float T = 1.0;\n    // Substantially transparency parameter.\n    float absorption = 100.0;\n    vec4 color = vec4(0.0);\n   for (int i = 0; i < 64; i++)\n    {\n        // Using distance function for density.\n        // So the function not normal value.\n        // Please check it out on the function comment.\n        float d = scene(ro);\n        \n        // The density over 0.0 then start cloud ray marching.\n        // Why? because the function will return negative value normally.\n        // But if ray is into the cloud, the function will return positive value.\n        if (d > 0.0)\n        {\n            // Let's start cloud ray marching!\n           // d = abs(dot(cos(d*20.), sin(1.1-rd.z)));\n          //ro = ro*rd*m3;\n    \t\td/=0.51;\n            // why density sub by sampleCount?\n            // This mean integral for each sampling points.\n            float tmp = d / float(64);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            // Return if transmittance under 0.01. \n            // Because the ray is almost absorbed.\n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            \n            // Add ambient + light scattering color\n            float opaity = 8.0;\n            float k = opaity * tmp * T;\n            vec4 cloudColor = vec4(1.0);\n        cloudColor = vec4(sin(vec3(5.,0.4,0.2) +  +sin(d*0.4)*0.5 + 1.8)*1.5 + 0.5,0.08);\n  // cloudColor.xyz *= d*(vec3(0.005,.045,.075) + 1.5*vec3(0.33,0.07,0.03));\n     \n            vec4 col1 =((rd.y*.00083))*vec4(-1.51,10.,5.,0.10)+ cloudColor * k/2.;\n           col1=vec4(1.5,-1.,1.,10.)*col1.xyzw;\n            col1.xyz+=+col1.xyz*-m3*0.51;\n            \n            color += col1*15. ;\n        }\n        \n      ro += rd * 20.;\n    //    ro+= clamp(01.5 - d*d*.5, 0.9, -2.3);\n       \n    }\n    \n   \n            return 0.31+ color*color*.75;\n\n}\n\n\n\n\nvec4 render(vec3 ro,vec3 rd){\n\nreturn march(ro,rd);//+vec4(glowmarch(ro,rd).rgb,1.)+vec4(glowmarch1(ro,rd).rgb*glowmarch1(ro,rd).a,1);\n//march(ro,rd)*\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \nvec2 mo = vec2(iTime * 0.1, cos(iTime * 0.25) * 3.0);\n      // Camera\n    float camDist = 25.0;\n    \n    // target\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    \n    // Ray origin\n    //vec3 ori = vec3(sin(iTime) * camDist, 0, cos(iTime) * camDist);\n    vec3 ro = camDist * normalize(vec3(cos(2.75 - 3.0 * mo.x), 0.7 - 1.0 * (mo.y - 1.0), sin(2.75 - 3.0 * mo.x)));\n     \n    // Ray origin. oving along the Z-axis.\n  ro = vec3(1,1500.,-1200.+iTime*250.);\n \n    \n  \n    // Output to screen\n   vec4  res=render(ro,rd)*render(ro,rd);\n    \n  \n    // res+=vec4(0.5,-res.x*1.5,res.z*30,0.5);\n    fragColor = vec4 (res.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}