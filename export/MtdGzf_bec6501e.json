{"ver":"0.1","info":{"id":"MtdGzf","date":"1470720813","viewed":195,"name":"Plasma tree","username":"sillsm","description":"Plasma tree","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills 2016, licensed under the MIT license.\n// Plasma tree\n#define PI 3.14159265\n#define MIRROR\n//#define DEBUG\nstruct Datum\n{\n  vec3 location;\n  float distance;\n  float material;\n};\n\nmat4 Ry (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Rz (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Disp (vec3 displacement)\n{\nreturn  mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(displacement, 1)\n); \n}\n\n// Derived from http://www.bidouille.org/prog/plasma\nfloat plasma2 (vec2 uv)\n{\n    uv *= 2.;\n    float v = sin((uv.x+iTime));\n    v += sin((uv.y+iTime)/2.0);\n    v += sin((uv.x+uv.y+iTime)/2.0);\n    vec2 c = uv/2.0 * vec2(sin(iTime/3.0), cos(iTime/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+iTime);\n    v = v/2.0;\n    return v;\n}\n\nvec2 opU( float d1, float d2, float m1, float m2 )\n{\n    return (d1<d2) ? vec2(d1, m1) : vec2(d2, m2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{ \n\treturn p.y;\n}\n\n// Rounded box with a plasma displacement.\nfloat pudBox( vec3 p, vec3 b )\n{\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  float dist = max(length(max(abs(p)-b,0.0)) - 1., -1.*(length(p)));\n  return dist - plasma2(5.*p.xy)/6.;\n}\n\n\nmat4 branch(float a_y, float a_z, float height, float b_len) \n{\n    mat4 dd = Disp(vec3(b_len*sin(a_z),-height + b_len*cos(a_z),0));\n    return Rz(a_z) * dd * Ry(a_y);\n}\n\nfloat tree(vec3 p)\n{\n  vec4 hom = vec4(p, 1); //homogenous coordinates.\n\n  float b1_a = 2.0;\n  float phi = iTime; // How much you want to rotate branch\n    \n  // First branch\n  float replication = clamp((iTime + 2.)/2., 3., 7.);\n  mat4 b1_f = branch(PI/replication - PI, b1_a, 3., 9.);\n    \n  // Second branch\n  float r2 = clamp((iTime+12.)/2., 3., 5.);;\n  float b2_a = 1.1;\n  float b2_size = clamp(iTime+1.,1.,5.);\n  float c = clamp(iTime+2.,1.,5.);\n  mat4 b2_f = branch(PI/r2 - PI, b2_a, -6., b2_size);   \n    \n  // Reflection symmetry around trunk for first branch.\n  hom = Ry(-phi) * hom;\n  float theta = atan(hom.z, hom.x);//(goes from -pi to pi)\n  float t = theta;\n  t = mod(t, 2.*PI);\n  #ifdef MIRROR\n  t = mod(t, 2.*PI/replication);\n  #endif\n  float r = length(hom.xz);\n  vec3 new_p = vec3(r*cos(t), hom.y, r*sin(t));\n    \n  // Debug Code\n  #ifdef DEBUG\n  if ((t > 2.*PI/replication - .1 && t < 2.*PI/replication + .1) ||\n      t < .1 && t > -.1) return 15.;\n  #endif   \n    \n  // Reflection symmetry around first branch for second branch.\n  hom = Ry(-phi)* b1_f * vec4(new_p, 1);\n  theta = atan(hom.z, hom.x);//(goes from -pi to pi)\n  t = theta;\n  t = mod(t, 2.*PI);\n  #ifdef MIRROR\n  t = mod(t, 2.*PI/r2);\n  #endif\n  r = length(hom.xz);\n  vec3 new_p2 = vec3(r*cos(t), hom.y, r*sin(t));\n     \n  // Apply branch coordinate system to symmetry coordinates.  \n  vec4 b1_p = b1_f * vec4(new_p,1);\n  vec4 b2_p = b2_f * vec4(new_p2,1);\n  vec4 b3_p = Disp(vec3(0.,b2_size-2.,0)) * b2_p;\n  \n  // Place a trunk, two branches, and abox.\n  float trunk = sdCappedCylinder(p, vec2(3., 6));\n  float b1 = sdCappedCylinder(b1_p.xyz, vec2(.5, 6));\n  float b2 = sdCappedCylinder(b2_p.xyz, vec2(.25, b2_size));\n  float b3 = pudBox(b3_p.xyz,vec3(.5,.5,.5));\n    \n  return min(b3,min(b2, min(b1, trunk)));    \n}\n\n// Returns distance_to_shape, material index\nvec2 scene(vec3 ray)  \n{\n    float planeMat = .4;\n    float boxMat   = .1;\n    return opU(tree(ray), sdPlane(ray), boxMat, planeMat);\n}\n\nDatum trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    const float hitThreshold = 0.001;\n    vec3 p = vec3(0);\n    float t = 0.0;\n    float m = 0.0;\n    for (int i = 0; i < 100; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\n        vec2 data = scene(p);\n        float dist = data.x;\n        m  = data.y;\n        t += dist;// * .9;\n        \n        if ( dist < hitThreshold ){\n            break;\n        }\n    }\n    return Datum(p, t, m);\t\t\t\t\t\t\n}\n\n// iq normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\n// Stolen from nmz\nfloat f(in vec2 p)\n{\n    return sin(p.x+sin(p.y+iTime*0.1)) * sin(p.y*p.x*0.1+iTime*0.2);\n}\n\n// Stolen from nmz\nvec2 field(in vec2 p)\n{\n\tvec2 ep = vec2(.05,0.);\n    vec2 rz= vec2(0);\n\tfor( int i=0; i<7; i++ )\n\t{\n\t\tfloat t0 = f(p);\n\t\tfloat t1 = f(p + ep.xy);\n\t\tfloat t2 = f(p + ep.yx);\n        vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\n\t\tvec2 t = vec2(-g.y,g.x);\n        \n        p += .9*t + g*0.3;\n        rz= t;\n\t}\n    \n    return rz;\n}\n\n\n// Stolen from ming's tutorial.\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\t//float vis = shadow( pos, toLight, 0.01, toLightLen );\n\tfloat vis = 1.;//shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n// Given distance to shape, material index, world coord, and pixel, color.\nvec4 color (float t, float m, vec3 p, vec2 uv)\n{\n    float v = plasma2(5.*p.xy);\n    t = clamp(t, -5., 5.);\n    vec3 col = 5.*(1./t)*vec3(1, sin(3.14*v), cos(3.14*v));\n    col *= .8; // Gamma correction.\n\n    if (length(p) > 100.) {\n        float v2 = plasma2(uv*20.);\n        col = .5*vec3(sin(v2), sin(v2 + iTime), sin(v2+7.)); \n        return vec4(col,0);\n    }\n    if (abs(m -.4) < .001) {\n        vec2 fld = field(p.xz*.10);\n        col = sin(vec3(-.3,0.1,0.5)+fld.x-fld.y)*0.65+0.35;\n    }\n    vec3 nrm = calcNormal(p);\n    vec4 light1 = vec4(20., 20., -10.0, 40.0 );\n    vec3 cc  = shade(p,nrm,light1);\n    //return vec4(cc,0);\n\n    return cc.x*vec4(col, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    // Rotate the viewer position (near clipping plane center).\n    vec3 position = vec3(0,0,-40.);\n    position += vec3(20.*cos(iTime/5.), 30., -60.*abs(sin(iTime/5.)));\n    position += vec3(iMouse.x/10.,0,iMouse.y/10.);\n    \n    #ifdef DEBUG\n    position = vec3(0,40,1);\n    #endif\n    \n    mat4 mat = LookAtRH(position, vec3(0,0,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    Datum d     = trace(ray, pt);\n    fragColor   = color(d.distance, d.material, d.location, uv); \n}","name":"Image","description":"","type":"image"}]}