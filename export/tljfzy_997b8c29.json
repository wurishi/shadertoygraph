{"ver":"0.1","info":{"id":"tljfzy","date":"1599266596","viewed":142,"name":"Mixing 4 perlins","username":"heyx3","description":"Trying to find interesting ways to combine 4 separate octave noise signals\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["perlin","experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The noise functions are taken from here: https://www.shadertoy.com/view/MdsGDN\n\n\n// noise\nfloat noise(vec2 pos)\n{\n\treturn fract( sin( dot(pos*0.001 ,vec2(24.12357, 36.789) ) ) * 12345.123);\t\n}\n\n\n// blur noise\nfloat smooth_noise(vec2 pos)\n{\n\treturn   ( noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) + noise(pos + vec2(1,1)) ) / 16.0 \t\t\n\t\t   + ( noise(pos + vec2(1,0)) + noise(pos + vec2(-1,0)) + noise(pos + vec2(0,1)) + noise(pos + vec2(0,-1)) ) / 8.0 \t\t\n    \t   + noise(pos) / 4.0;\n}\n\n\n// linear interpolation\nfloat interpolate_noise(vec2 pos)\n{\n\tfloat\ta, b, c, d;\n\t\n\ta = smooth_noise(floor(pos));\t\n\tb = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y)));\n\tc = smooth_noise(vec2(floor(pos.x), floor(pos.y+1.0)));\n\td = smooth_noise(vec2(floor(pos.x+1.0), floor(pos.y+1.0)));\n\t\t\n\ta = mix(a, b, fract(pos.x));\n\tb = mix(c, d, fract(pos.x));\n\ta = mix(a, b, fract(pos.y));\n\t\n\treturn a;\t\t\t\t   \t\n}\n\n\n\nfloat perlin_noise(vec2 pos)\n{\n\tfloat\tn;\n\t\n\tn = interpolate_noise(pos*0.0625)*0.5;\n\tn += interpolate_noise(pos*0.125)*0.25;\n\tn += interpolate_noise(pos*0.025)*0.225;\n\tn += interpolate_noise(pos*0.05)*0.0625;\n\tn += interpolate_noise(pos)*0.03125;\n    \n    return n;\n}\n\nfloat octave_noise(vec2 pos)\n{\n    float weight = 0.5,\n          scale = 1.0,\n          maxW = 0.0,\n          outN = 0.0;\n    for (int i = 0; i < 5; ++i) {\n        pos *= scale;\n        outN += weight * perlin_noise(pos);\n        \n        maxW += weight;\n        scale *= 2.0;\n        weight /= 2.0;\n    }\n    return outN / maxW;\n}\n\n\n\n\n//Now that we've got basic noise, let's try mixing them:\n\n#define PI 3.14159265359\n#define TWO_PI (PI * 2.0)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 seed = (fragCoord * 0.5) +\n        \t\t(iTime * 100.5);\n    vec4 clouds = vec4(octave_noise(seed),\n                       octave_noise(seed + 5631.0),\n                       octave_noise(seed + 8460.0),\n                       octave_noise(seed + 16564.0));\n    //As a backup, have some more cloud noise.\n    vec4 clouds2 = vec4(octave_noise(seed - 5829.0),\n                        octave_noise(seed - 12390.0),\n                        octave_noise(seed - 999.0),\n                        octave_noise(seed - 2430.0));\n    \n    fragColor = clouds;\n    \n    #define SEPARATOR_SIZE   3\n    #define SEPARATOR_SIZE_F 3.0\n    #define SEPARATOR (1.0 / SEPARATOR_SIZE_F)\n    \n    ivec2 separatorPos = ivec2(int(uv.x * SEPARATOR_SIZE_F),\n                               int(uv.y * SEPARATOR_SIZE_F));\n    int separatorI = separatorPos.x + (separatorPos.y * SEPARATOR_SIZE);\n    vec2 separatorT = (uv - vec2(separatorPos)*SEPARATOR)\n        \t\t\t  / SEPARATOR;\n    \n    //Use a border color to easily pick out each noise type.\n    vec3 borderColor = vec3(0.0);\n    \n    //Simple blending:\n    if (separatorI == 0) {\n        borderColor = vec3(1.0);\n        \n        vec2 blend = mix(clouds.rg, clouds.ba,\n                         0.5);\n        fragColor.rgb = vec3(mix(blend.x, blend.y, 0.5));\n    }\n    \n    //More interesting blending:\n    if (separatorI == 1) {\n        borderColor = vec3(1.0, 0.0, 1.0);\n        \n        fragColor.rgb = vec3(mix(clouds.r, clouds.g, clouds.b));\n        fragColor.rgb = min(clouds.aaa, fragColor.rgb);\n    }\n    \n    //\"Triangle\" blending:\n    if (separatorI == 2) {\n        borderColor = vec3(0.0, 1.0, 0.0);\n        \n        //Make a vector using a cloud value as the angle and \n        vec2 t = vec2(cos(clouds.a * TWO_PI),\n                      sin(clouds.a * TWO_PI));\n        t = 0.5 + (t * 0.5 * clouds2.r);\n        float valX = mix(clouds.r, clouds.g, t.x);\n        fragColor.rgb = mix(vec3(valX), clouds.bbb, t.y);\n    }\n    \n    //More complex interactions using pow():\n    if (separatorI == 3) {\n        borderColor = vec3(0.0, 0.0, 1.0);\n        vec4 oldClouds = clouds;\n        \n        clouds = smoothstep(0.0, 1.0, clouds);\n        float tMin = 0.3,\n              tMax = 0.9;\n        float v1 = mix(tMin, tMax, clouds.r),\n              v2 = mix((1.0/tMin), (1.0/tMax), clouds.g),\n        \t  v = mix(v1, v2, clouds.b);\n        float result = pow(clouds.a, v);\n        \n        result = clamp(result, 0.0, 1.0);\n        fragColor.rgb = vec3(result);\n        clouds = oldClouds;\n    }\n    \n    //More complex interactions using division:\n    if (separatorI == 4) {\n        borderColor = vec3(1.0, 1.0, 0.0);\n        \n        float result = clouds.r / max(clouds.g, clouds.b) * clouds.a;\n        \n        fragColor.rgb = vec3(result);\n    }\n    \n    //A position-based mixing:\n    if (separatorI == 5) {\n        borderColor = vec3(0.0, 1.0, 1.0);\n        \n        vec2 posOscillate = 0.5 + (0.5 * sin(uv * 20.0));\n        float result = mix(mix(clouds.r, clouds.g, posOscillate.x),\n                           mix(clouds.b, clouds.a, posOscillate.x),\n                           posOscillate.y);\n        \n        fragColor.rgb = vec3(result);\n    }\n    \n    //Unused:\n    if (separatorI == 6) {\n        return;\n    }\n    if (separatorI == 7) {\n        return;\n    }\n    \n    //Visualize how the above algorithms compare to plain noise:\n    if (separatorI == 8) {\n        borderColor = vec3(0.0);\n        fragColor.rgb = clouds.rrr;\n    }\n    \n    //Add the border color.\n    vec2 dim = abs(separatorT - vec2(0.5));\n    vec2 borderT2 = step(vec2(0.49), dim);\n    float borderT = max(borderT2.x, borderT2.y);\n    fragColor.rgb = mix(fragColor.rgb, borderColor, borderT);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}