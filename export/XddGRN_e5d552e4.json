{"ver":"0.1","info":{"id":"XddGRN","date":"1448386398","viewed":2709,"name":"3d color space visualization","username":"nmz","description":"Not very efficient at all, but a nice method to visualize various color spaces in 3d.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["3d","lab","xyz","colorspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//3D color space visualization by nmz (@stormoid)\n\n/*\n\tI needed to to proper CIE Lch blending for some project and\n\tI couldn't find quality code on the net for the conversions\n\tso I decided to write my own.\n\n\tThen as I was displaying the spaces in 2d to show them off\n\tI thought that it should be possible to use the hardware \n\tderivatives (fwidth) in order to show only the sRGB usable\n\tcolors of said spaces.\n\n\tThen I realized I could push this a little further by doing\n\tthis gradient check along a ray in the native 3d space of\n\tthose manifolds!\n\n\tI start by raymarching a bounding box to the relevant spaces\n\tand then perform gradient checking at every linear step in\n\torder to get the boundaries of the usable sRGB space.\n\n\n\tI inlcuded the forward and reverse transformations for sRGB, \n\tXYZ, Lab and Lch to linear rgb (see second text block) in \n\tthis shader (most are unused)\n*/\n\n\n/*\n\tA little more info about color-space linearity.\n\n\tin order to avoid confusion, I'm using srgb and rgb to represent\n\tsRGB and \"Linear RGB\" color spaces respectively.\n\n\t\"srgb\" color space is inversely correlated to the non-linear response of\n\tcomputer monitors, this should only be applied at the end of your shaders\n\tbecause working in sRGB (doing calculations in that space) will result\n\tin as much color distortion as failing to account for its existence!\n\n\t\"rgb\", is simply non \"monitor corrected\" colors, behaving linearly as you\n\tapply calculations.  Failling to inversely correct these colors (to sRGB)\n\tbefore sending the image to be displayed will result in you tweaking the colors\n\tof your images to compensate for the non-linearity and innacuraties of your\n\tcalculations.\n\n\tThis means that having your XYZ conversions perform RGB linearization\n\tand de-linearization is pointless when working in linear space (as we\n\tshould in all our shaders). That being said, it can indeed be needed\n\twhen working with sRGB corrected material (like most images)\n*/\n\n//Here you can define the color space you want to visualize\n//TYPE 1 = CIE Lab,  TYPE 2 = XYZ (CIE 1931), TYPE 3 = RGB\n#define TYPE 1\n\n//This is only used for the Lab and Lch spaces\n//You can radically change the mapping by varying those values\nconst vec3 wref =  vec3(.95047, 1.0, 1.08883); \n//const vec3 wref =  vec3(1.0,1.,1.);\n\n//If showing Lab space (Type 1), you can use this define to \n//see the difference betweem sRGB mapping and \"Adobe RGB\" mapping\n//#define ABODE_RGB\n\n#define MOUSE_Y_CUTS_SPACE\n\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nvec2 mo;\n\n//---------------------------------------------------------------------------------\n//--------------------------------Color Functions----------------------------------\n//---------------------------------------------------------------------------------\n\n//I'm keeping the functions self-contained, so that will inlcude subsets of each other\n//Example: the forward Lch function includes RGB->XYZ, XYZ->Lab and Lab-Lch\n\n//Equations from: https://en.wikipedia.org/wiki/Lab_color_space\n//and: https://en.wikipedia.org/wiki/SRGB\n//sRGB matrices from: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n\n//----------------------sRGB----------------------\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n//This is only useful if you have non-linear (sRGB) inputs and \n//want to convert them to linear for in-shader calculations\nfloat linearize(float t){ return mix(pow(((t + 0.055)/1.055), 2.4), t / 12.92, step(t, 0.04045)); }\nvec3 linearize(in vec3 c){ return vec3(linearize(c.x), linearize(c.y), linearize(c.z)); }\n\n//----------------------XYZ----------------------\nvec3 rgb2xyz(in vec3 c)\n{\n    return c*mat3(0.4124, 0.3576, 0.1805,\n          \t\t  0.2126, 0.7152, 0.0722,\n                  0.0193, 0.1192, 0.9505);\n}\n\nvec3 xyz2rgb(in vec3 c)\n{\n    vec3 rgb = c*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t      -0.9689,  1.8758, 0.0415,\n    \t\t\t\t   0.0557,  -0.2040, 1.0570);\n    return rgb;\n}\n\n//These are used for Lab and Lch functions\nfloat xyzF(float t){ return mix(pow(t,1./3.), 7.787037*t + 0.139731, step(t,0.00885645)); }\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }\n\n//----------------------CIE Lab----------------------\nvec3 rgb2lab(in vec3 c)\n{\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n    \n    c.x = xyzF(c.x/wref.x);\n\tc.y = xyzF(c.y/wref.y);\n\tc.z = xyzF(c.z/wref.z);\n\t\n\treturn vec3(max(0.,116.*c.y - 16.0), 500.*(c.x - c.y), 200.*(c.y - c.z));\n}\n\nvec3 lab2rgb(in vec3 c)\n{   \n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n    \t\t\t\twref.y*xyzR(lg),\n    \t\t\t\twref.z*xyzR(lg - 0.005*c.z));\n    #ifndef ABODE_RGB\n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t        -0.9689,  1.8758, 0.0415,\n                \t     0.0557,  -0.2040, 1.0570);\n\t#else\n    vec3 rgb = xyz*mat3( 2.0413690, -0.5649464, -0.3446944,\n\t\t\t\t\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t\t\t\t\t0.0134474, -0.1183897,  1.0154096);\n    #endif\n    return rgb;\n}\n\n//----------------------CIE Lch----------------------\nvec3 rgb2lch(in vec3 c)\n{\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n    c.x = xyzF(c.x/wref.x);\n\tc.y = xyzF(c.y/wref.y);\n\tc.z = xyzF(c.z/wref.z);\n\tvec3 lab = vec3(max(0.,116.0*c.y - 16.0), 500.0*(c.x - c.y), 200.0*(c.y - c.z)); \n    return vec3(lab.x, length(vec2(lab.y,lab.z)), atan(lab.z, lab.y));\n}\n\nvec3 lch2rgb(in vec3 c)\n{\n    c = vec3(c.x, cos(c.z) * c.y, sin(c.z) * c.y);\n    \n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n    \t\t\t\twref.y*xyzR(lg),\n    \t\t\t\twref.z*xyzR(lg - 0.005*c.z));\n    \n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n          \t\t        -0.9689,  1.8758, 0.0415,\n                \t     0.0557,  -0.2040, 1.0570);\n    \n    return rgb;\n}\n\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------\n\nfloat sbox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    float d=  sbox(p, vec3(1.));\n#ifdef MOUSE_Y_CUTS_SPACE\n#if (TYPE == 1)\n    d = max(d, -sbox(p + vec3(.9 + mo.y*0.35,0.0,0), vec3(1.)));\n#else\n    d = max(d, -sbox(p + vec3(1.4 + mo.y*0.35,0.0,0), vec3(1.)));\n#endif\n#endif\n    return d;\n} \n\nvec3 marchCol(in vec3 ro, in vec3 rd)\n{\n    float h = 1.0;\n    float d = 0.;\n    vec3 col = vec3(0);\n    vec3 colLast = vec3(0);\n    const float prc = 1e-8;\n    const float sz = 115.;\n    for( int i=0; i<240; i++ )\n    {\n        d += clamp(h,0.01,1.);\n        vec3 pos = ro+rd*d;\n    #if (TYPE == 1)\n        vec3 col2 = lab2rgb(vec3(pos.x*sz,pos.y*sz , pos.z*sz));\n    #elif (TYPE == 2)    \n        vec3 col2 = xyz2rgb(vec3(pos.x+0.5, pos.y+0.5, pos.z+0.5));\n    #else\n        vec3 col2 = vec3(pos.x+0.5, pos.y+0.5, pos.z+0.5);\n\t#endif\n        col2 = sRGB(col2);\n        \n        h = map(pos);\n        col2 = clamp(col2, 0., 1.);\n        \n        if (h < 0.)\n        if ((abs(col2.r-colLast.r) > prc)  && (abs(col2.g-colLast.g) > prc) && (abs(col2.b-colLast.b) > prc))\n        {\n        \tcol= col2;\n            break;\n        }\n        colLast = col2;\n    }\n\treturn col;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tmo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.15,1.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\tmo *= 4.;\n    \n    #if (TYPE == 1)\n\tvec3 ro = vec3(0.,-0.1,3.5);\n    #elif (TYPE == 2)\n    vec3 ro = vec3(0.,0.0,2.5);\n    #else\n    vec3 ro = vec3(0.,0.0,3.0);\n    #endif\n    vec3 rd = normalize(vec3(p,-1.5));\n    float rx = mo.x+time*0.1;\n    float ry = sin(time*0.6)*0.2;\n    ro = rotx(ro,ry), rd = rotx(rd, ry);\n    ro = roty(ro, rx), rd = roty(rd, rx);\n\t\n    vec3 col = marchCol(ro, rd);\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}