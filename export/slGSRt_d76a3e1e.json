{"ver":"0.1","info":{"id":"slGSRt","date":"1641213777","viewed":62,"name":"Shader-Studies: Truchet Pattern","username":"LeyMB","description":"A simple shader I made as part of my studies to improve my shader knowledge. Like my pattern shader, it subdivides the screen space into tiles. It then creates two patterns: a repeating pattern of red squares and one of blue rotating triangles.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["truchetpattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a simple shader based on this chapter of the book of shaders: https://thebookofshaders.com/09/\n\n// Many thanks to Patricio Gonzalez Vivo & Jen Lowe for their tutorials on thebookofshaders.com.\n// Their website is an invaluable resource when starting out with learning shaders and has helped me greatly\n\n\n// DrawBox function taken from here: https://thebookofshaders.com/09/\nfloat DrawBox(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n// my own Grid/tilize function\nvec2 MakeGrid(vec2 FragCoord, vec2 RowColumn, vec2 Resolution)\n{\n   vec2 st = gl_FragCoord.xy/Resolution;\n\n   st *= RowColumn;\n   st = fract(st);\n\n   return st;\n}\n\n// another Tiling function I made that can offset rows\nvec2 Tiling(vec2 FragCoord, float Zoom, float Offset, float RowOffset){\n    FragCoord *= Zoom;\n\n    // offsetting\n    FragCoord.x += step(1., mod(FragCoord.y, RowOffset)) * Offset;\n\n    return fract(FragCoord);\n}\n\n\n\nvec2 rotate(vec2 Coord, float _angle){\n    vec2 temp;\n\n    temp = Coord - 0.5;\n    temp =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * temp;\n    temp += 0.5;\n    return temp;\n}\n\n// this was taken from here https://thebookofshaders.com/09/\nvec2 SimpleTiling(vec2 FragCoord, float Zoom)\n{\n    vec2 temp;\n    temp = FragCoord * Zoom;\n    return fract(temp);\n}\n\n// this function was recreated from what Patricio Gonzalez Vivo posted here: https://thebookofshaders.com/09/\nvec2 RotateTiling(vec2 FragCoord)\n{\n\n    vec2 temp;\n    // scale up the coord system\n    temp = FragCoord * 2.0;\n\n    // indexing each cell based on its position\n    float index = 0.0;\n    index += step(1., mod(temp.x, 2.0));\n    index += step(1., mod(temp.y, 2.0)) * 2.0;\n\n    // clamp each cell between 0.0-1.0\n    FragCoord = fract(FragCoord);\n\n    float pi = 3.14159265358979323846;\n\n    // rotate cells according to their index\n    if(index == 1.0)\n    {\n        FragCoord = rotate(FragCoord, pi * 0.5);\n\n    } else if(index == 2.0)\n    {\n        FragCoord = rotate(FragCoord,  pi * (-0.5));\n\n    } else if(index == 3.0)\n    {\n        FragCoord = rotate(FragCoord, pi);\n    }\n\n\n    return FragCoord;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n\n    // Truchet-Tiling\n    vec2 TruchetTiles;\n\n    TruchetTiles = SimpleTiling(fragCoord.xy/iResolution.xy, 3.0);\n    TruchetTiles = RotateTiling(TruchetTiles);\n\n    // rotate TruchetTiles\n    TruchetTiles = SimpleTiling(TruchetTiles, 2.0);\n    TruchetTiles = rotate(TruchetTiles, -3.14159265358979 * iTime * 0.25);\n\n    color += vec3(step(TruchetTiles.x, TruchetTiles.y)) * vec3(0.0, 1.0, 1.0);\n\n\n    vec2 st = MakeGrid(fragCoord, vec2(3.0), iResolution.xy);\n\n\n    // draw red squares\n    float AmountRotations = 0.25;\n    st = rotate(st, sin(iTime) * 3.14159265358979 * AmountRotations);\n\n    color += vec3(DrawBox(st,vec2(0.7),0.01)) * vec3(0.7, 0.0, 0.0);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}