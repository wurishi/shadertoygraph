{"ver":"0.1","info":{"id":"ml3cW2","date":"1699655753","viewed":25,"name":"FINALE PROJECT","username":"akram","description":"MEKBAL Akram \n12312227","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material {\n    vec3 ambient;  // Composante ambiante\n    vec3 diffuse;  // Composante diffuse\n    vec3 specular; // Composante spéculaire\n};\n\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n\nfloat CheckerboardTexture(vec3 p, float squareSize) {\n    \n    vec3 uv = vec3(p.x, p.y, p.z) / squareSize;\n    float checker = mod(floor(uv.x) + floor(uv.y) + floor(uv.z), 2.0);\n    return checker;\n}\n\nvec3 ConcentricCirclesTexture(vec3 p, float radius) {\n    // Calculez la distance du point au centre\n    float distanceToCenter = length(p);\n\n    // Définissez un gradient de couleurs concentriques\n    vec3 colorCenter = vec3(5.0, 0.0, 0.0); // Couleur du centre\n    vec3 colorOuter = vec3(0.0, 0.0, 5.0); // Couleur à l'extérieur\n\n    // Interpolez la couleur en fonction de la distance\n    float t = distanceToCenter / radius;\n    vec3 interpolatedColor = mix(colorCenter, colorOuter, t);\n\n    return interpolatedColor;\n}\n\nfloat Axial(float x, float y, float z) {\n    // Calculer la distance du point au centre dans le plan XY\n    float r = sqrt(x * x + y * y);\n    \n    // Utiliser la coordonnée Z pour créer des feuilles concentriques\n    // * z or * r\n    return 0.5 + 0.5 * cos(3.1415927 * r) ;\n}\n\nMaterial Texture(vec3 p, int i, float sideLength) {\n    if (i == 1) {\n        //return Material(vec3(0.8, 0.5, 0.4)); // Your desired color\n        // Ajustez le rayon selon vos besoins\n        float radius = 2.0;\n        vec3 col = ConcentricCirclesTexture(p, radius);\n        return Material(col,col,col);\n        \n    } else if ( i == 0) {\n        return Material(vec3(5.0, .5, 1.0), vec3(0.0), vec3(0.0));\n    }\n    else if (i == 2) {\n        // Adjust the squareSize to control the size of the checker squares\n        float squareSize = 0.4; // Adjust this value as needed\n        float checker = CheckerboardTexture(p, squareSize);\n        vec3 col = vec3(0.9, 0.5, 0.1) + checker * vec3(0.1);\n        return Material(col,col,col);\n    }\n    else if (i == 3) {\n        // Utilisez la coordonnée Z pour appliquer la texture Axial\n        float axialValue = Axial(p.x, p.y, p.z);\n        vec3 col = vec3(axialValue);\n        return Material(col,col,col);\n    }\n    else {\n        return Material(vec3(0),vec3(0.,0.,0.),vec3(0.,0.,0.)); // Default color for other materials\n    }\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\nstruct Ellipsoid {\n    vec3 center; // Centre de l'ellipsoïde\n    vec3 radii;  // Demi-axes de l'ellipsoïde (semi-axes lengths)\n    int i;      // ID de texture\n};\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 oc = ray.o - ellipsoid.center;\n    vec3 invRadii = 1.0 / ellipsoid.radii;\n\n    float a = dot(ray.d * invRadii, ray.d);\n    float b = 2.0 * dot(oc * invRadii, ray.d);\n    float c = dot(oc * invRadii, oc) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant >= 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = min(t1, t2);\n\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            vec3 normal = normalize((p - ellipsoid.center) * invRadii);\n\n            x = Hit(t, normal, ellipsoid.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\n\nstruct Cylindre {\n    vec3 start;\n    vec3 end;\n    float radius; \n    int i;\n};\nbool IntersectCylinder(Ray ray, Cylindre cyl, out Hit hit) {\n    // Initialize the hit to a default value\n    hit.t = 1000.0;\n    \n    vec3 cylinderAxis = normalize(cyl.end - cyl.start);\n    vec3 oc = ray.o - cyl.start;\n    \n    float a = dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, ray.d - dot(ray.d, cylinderAxis) * cylinderAxis);\n    float b = 2.0 * dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, oc - dot(oc, cylinderAxis) * cylinderAxis);\n    float c = dot(oc - dot(oc, cylinderAxis) * cylinderAxis, oc - dot(oc, cylinderAxis) * cylinderAxis) - cyl.radius * cyl.radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    float h1 = dot(ray.o + t1 * ray.d - cyl.start, cylinderAxis);\n    float h2 = dot(ray.o + t2 * ray.d - cyl.start, cylinderAxis);\n    \n    if (discriminant >= 0.0) {\n        if (t1 >= 0.0 && h1 >= 0.0 && h1 <= length(cyl.end - cyl.start) && t1 < hit.t) {\n            vec3 hitPoint = Point(ray, t1);\n            vec3 normal = normalize(hitPoint - (cyl.start + h1 * cylinderAxis));\n            hit = Hit(t1, normal, cyl.i);\n        }\n        \n        if (t2 >= 0.0 && h2 >= 0.0 && h2 <= length(cyl.end - cyl.start) && t2 < hit.t) {\n            vec3 hitPoint = Point(ray, t2);\n            vec3 normal = normalize(hitPoint - (cyl.start + h2 * cylinderAxis));\n            hit = Hit(t2, normal, cyl.i);\n        }\n    }\n    \n    float tTopCap = dot((cyl.start - ray.o), cylinderAxis) / dot(ray.d, cylinderAxis);\n    float distanceTopCap = distance(Point(ray, tTopCap), cyl.start);\n    \n    if (tTopCap >= 0.0 && distanceTopCap <= cyl.radius && tTopCap < hit.t) {\n        hit = Hit(tTopCap, cylinderAxis, cyl.i);\n    }\n    \n    float tBottomCap = dot((cyl.end - ray.o), -cylinderAxis) / dot(ray.d, -cylinderAxis);\n    float distanceBottomCap = distance(Point(ray, tBottomCap), cyl.end);\n    \n    if (tBottomCap >= 0.0 && distanceBottomCap <= cyl.radius && tBottomCap < hit.t) {\n        hit = Hit(tBottomCap, -cylinderAxis, cyl.i);\n    }\n    \n    return hit.t < 1000.0;\n}\n\nstruct Capsule{\n    vec3 start;\n    vec3 end;\n    float radius;// Radius\n    int i;// Texture Id\n};\n\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n    // Initialize the hit to a default value\n    x = Hit(1000.0, vec3(0.0), -1);\n\n    // Check for intersection with the first sphere (start point)\n    Sphere sphere1 = Sphere(capsule.start, capsule.radius, capsule.i);\n    Hit sphereHit1;\n    bool hitSphere1 = IntersectSphere(ray, sphere1, sphereHit1);\n\n    // Check for intersection with the second sphere (end point)\n    Sphere sphere2 = Sphere(capsule.end, capsule.radius, capsule.i);\n    Hit sphereHit2;\n    bool hitSphere2 = IntersectSphere(ray, sphere2, sphereHit2);\n\n    // Check for intersection with the cylindrical part (the tube)\n    vec3 tubeDir = normalize(capsule.end - capsule.start);\n    vec3 oc = ray.o - capsule.start;\n    float a = dot(ray.d - dot(ray.d, tubeDir) * tubeDir, ray.d - dot(ray.d, tubeDir) * tubeDir);\n    float b = 2.0 * dot(ray.d - dot(ray.d, tubeDir) * tubeDir, oc - dot(oc, tubeDir) * tubeDir);\n    float c = dot(oc - dot(oc, tubeDir) * tubeDir, oc - dot(oc, tubeDir) * tubeDir) - capsule.radius * capsule.radius;\n\n    // Calculate the discriminant\n    float discriminant = b * b - 4.0 * a * c;\n\n    if(discriminant >= 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Check if t1 and t2 are within the bounds of the cylindrical part\n        float h1 = dot(ray.o + t1 * ray.d - capsule.start, tubeDir);\n        float h2 = dot(ray.o + t2 * ray.d - capsule.start, tubeDir);\n\n        if(t1 >= 0.0 && h1 >= 0.0 && h1 <= length(capsule.end - capsule.start)) {\n            if(t1 < x.t) {\n                vec3 hitPoint = Point(ray, t1);\n                vec3 normal = normalize(hitPoint - (capsule.start + h1 * tubeDir));\n                x = Hit(t1, normal, capsule.i);\n            }\n        }\n\n        if(t2 >= 0.0 && h2 >= 0.0 && h2 <= length(capsule.end - capsule.start)) {\n            if(t2 < x.t) {\n                vec3 hitPoint = Point(ray, t2);\n                vec3 normal = normalize(hitPoint - (capsule.start + h2 * tubeDir));\n                x = Hit(t2, normal, capsule.i);\n            }\n        }\n    }\n\n    // Check if there was an intersection with either of the spheres\n    if(hitSphere1 && sphereHit1.t < x.t) {\n        x = sphereHit1;\n    }\n\n    if(hitSphere2 && sphereHit2.t < x.t) {\n        x = sphereHit2;\n    }\n\n    return (hitSphere1 || hitSphere2 || x.t < 1000.0);\n}\n\nstruct Box {\n    vec3 min;  // Minimum corner\n    vec3 max;  // Maximum corner\n    int i;     // Texture ID\n};\n\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    // Initialize the hit to a default value\n    x = Hit(1000.0, vec3(0.0), -1);\n\n    // Calculate the intersection parameters for each axis\n    vec3 invDir = 1.0 / ray.d;\n    vec3 t1 = (box.min - ray.o) * invDir;\n    vec3 t2 = (box.max - ray.o) * invDir;\n\n    // Find the intersection intervals\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n\n    // Find the maximum of the minimums and the minimum of the maximums\n    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n    float tFar = min(min(tmax.x, tmax.y), tmax.z);\n\n    // Check if the intersection is valid\n    if (tNear > tFar || tFar < 0.0) {\n        return false;\n    }\n\n    // Check if the intersection point is in front of the ray origin\n    float t = (tNear > 0.0) ? tNear : tFar;\n    vec3 p = Point(ray, t);\n\n    // Calculate the normal at the intersection point\n    vec3 normal;\n    if (abs(p.x - box.min.x) < 0.0001) normal = vec3(-1.0, 0.0, 0.0);\n    else if (abs(p.x - box.max.x) < 0.0001) normal = vec3(1.0, 0.0, 0.0);\n    else if (abs(p.y - box.min.y) < 0.0001) normal = vec3(0.0, -1.0, 0.0);\n    else if (abs(p.y - box.max.y) < 0.0001) normal = vec3(0.0, 1.0, 0.0);\n    else if (abs(p.z - box.min.z) < 0.0001) normal = vec3(0.0, 0.0, -1.0);\n    else if (abs(p.z - box.max.z) < 0.0001) normal = vec3(0.0, 0.0, 1.0);\n\n    // Update the hit information\n    x = Hit(t, normal, box.i);\n\n    return true;\n}\n\nstruct Torus {\n    vec3 center;   // Center of the torus\n    float majorRadius;  // Major radius of the torus\n    float minorRadius;  // Minor radius of the torus\n    int i;    // Color of the torus\n};\n\nbool intersectTorus(Ray ray, Torus torus, out Hit hit) {\n    hit.t = -1.0;  // Initialize hit.t to a negative value to indicate no intersection\n\n    vec3 ro = ray.o - torus.center;\n    vec3 rd = ray.d;\n\n    float Ra2 = torus.majorRadius * torus.majorRadius;\n    float ra2 = torus.minorRadius * torus.minorRadius;\n\n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * rd.z * rd.z + k;\n    float k1 = k * n + Ra2 * ro.z * rd.z;\n    float k0 = k * k + Ra2 * ro.z * ro.z - Ra2 * ra2;\n\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n\n    float h = R * R - Q * Q * Q;\n    float z = 0.0;\n\n    if(h < 0.0) {\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    } else {\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\n\n    z = c2 - z;\n\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n\n    if(abs(d1) < 1.0e-4) {\n        if(d2 < 0.0) {\n            return false;  // No intersection\n        }\n        d2 = sqrt(d2);\n    } else {\n        if(d1 < 0.0) {\n            return false;  // No intersection\n        }\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\n    float result = 1e20;\n\n    h = d1 * d1 - z + d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        float t2 = -d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = t1;\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n\n    h = d1 * d1 - z - d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        float t2 = d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = min(result, t1);\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n    \n     if (result < 1e20) {\n    hit.t = result;  // Update the hit structure with the intersection depth\n\n    // Compute the normal vector\n    vec3 q = ray.o + ray.d * hit.t;\n    vec3 normal = normalize(vec3(\n        2.0 * (q.x - torus.center.x),\n        2.0 * (q.y - torus.center.y),\n        2.0 * (q.z - torus.center.z)\n    ));\n    hit.n = normal;\n\n    hit.i = torus.i;  // Assign the color or texture ID to the hit structure\n    return true;  // Intersection found\n}}\n\nmat3 rotateMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oneMinusC = 1.0 - c;\n    \n    mat3 rotationMatrix = mat3(\n        c + axis.x * axis.x * oneMinusC, \n        axis.x * axis.y * oneMinusC - axis.z * s, \n        axis.x * axis.z * oneMinusC + axis.y * s,\n        axis.y * axis.x * oneMinusC + axis.z * s,\n        c + axis.y * axis.y * oneMinusC, \n        axis.y * axis.z * oneMinusC - axis.x * s,\n        axis.z * axis.x * oneMinusC - axis.y * s, \n        axis.z * axis.y * oneMinusC + axis.x * s, \n        c + axis.z * axis.z * oneMinusC\n    );\n    return rotationMatrix;\n}\n\n\nRay rotateRay(Ray ray, vec3 axis, float angle) {\n    ray.d = normalize(rotateMatrix(axis, angle) * ray.d);\n    return ray;\n}\n\nEllipsoid rotateEllipsoid(Ellipsoid ellipsoid, vec3 axis, float angle) {\n    // Rotation du centre de l'ellipsoïde\n    ellipsoid.center = rotateMatrix(axis, angle) * ellipsoid.center;\n    // Rotation des demi-axes\n    ellipsoid.radii = rotateMatrix(axis, angle) * ellipsoid.radii;\n    return ellipsoid;\n}\n\nvec3 translate(vec3 center, vec3 translation) {\n    return center + translation;\n}\n\nvec3 homothetie (vec3 x, float scaleFactors) {\n    return x * scaleFactors;\n}\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(0.,0.,1.),1.,1);\n    Ellipsoid ellipsoid = Ellipsoid(vec3(-2., 4., 2.), vec3(1.0, 1., 4.), 2);\n    \n    const Cylindre cyl=Cylindre(vec3(-3.0, 0.0, 1.0), vec3(-3.0, 0.0, 3.0), 2., 3);\n    const Box box = Box(vec3(5., -1.0, 2.0), vec3(2.0, 1.0, 3.0), 2);\n    const Capsule cap=Capsule(vec3(0.,-2.,3.),vec3(0.,-2.,5.),1.,3);\n    \n    const Torus torus = Torus(vec3(5.0, -2.0, 5.0), 1.0, 0.3, 2);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    \n    // Appliquer une translation à l'ellipsoïde\n    //vec3 translationVector = vec3(5.0, -8.0, 2.0); // Les valeurs de translation souhaitées\n    //epil.center = epil.center + translationVector;\n    \n    //transaltion\n    //ellipsoid.center = translate(ellipsoid.center, translationVector);\n    \n    // Appliquer rotation\n    //ellipsoid = rotateEllipsoid(ellipsoid, vec3(0., 0., 1.), radians(20.0));\n    \n    //l’homothétie  \n    //ellipsoid.radii = homothetie(ellipsoid.radii, 2.);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if (IntersectEllipsoid(ray, ellipsoid, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if(IntersectCylinder(ray,cyl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectCapsule(ray,cap,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if (IntersectBox(ray, box, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if(intersectTorus(ray, torus, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(vec3 color,vec3 n, vec3 p)\n{\n    vec3 light=normalize(vec3(1,1,1));\n    \n    Hit osef;\n    if(!Intersect(Ray(p+n*0.01,light),osef))\n    {\n    \n    return color;\n    }\n    else \n    {\n    return vec3(0.01,.01,.01);\n    }\n}\n// Rendering\nvec3 Shade(Ray ray) {\n    // Intersection avec la scène\n    Hit x;\n    bool idx = Intersect(ray, x);\n\n    if (idx) {\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i, 0.5); // Utiliser une taille de côté de 0.5 pour le damier (ajustez selon vos besoins)\n\n        // Modèle d'éclairage de Phong\n        vec3 lightDirection = normalize(vec3(1, 1, 1)); // Direction de la lumière \n        vec3 normal = x.n; // Normale de la surface\n        vec3 viewDirection = normalize(-ray.d); // Direction de la vue\n\n        float ambient = 0.1; // Composante ambiante\n        float diffuse = max(dot(normal, lightDirection), 0.0); // Composante diffuse\n        float specular = pow(max(dot(reflect(-lightDirection, normal), viewDirection), 0.0), 32.0); // Composante spéculaire\n\n        vec3 color = mat.ambient * ambient + mat.diffuse * diffuse + mat.specular * specular;\n\n        return Color(color,x.n,p);\n    } else {\n        return Background(ray.d);\n    }\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}