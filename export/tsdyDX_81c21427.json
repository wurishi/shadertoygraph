{"ver":"0.1","info":{"id":"tsdyDX","date":"1601911432","viewed":134,"name":"25 - Glowy Mandala","username":"Krabcode","description":"Added some sinewaves together and used a symmetric mandala trick with cos(12.*atan2(cv.y, cv.x)) and distance from center","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["gradient","sine","symmetry","mandala"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define res iResolution\n\nfloat t;\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat getSine(float x, float y){\n    y += .5   *sin(0.8*x+y*6.);\n    y += .25  *sin(1.2*x-y*6.+t);\n    y += .125 *sin(2.9*x+y+t*.8);\n    y += .015 *sin(4.9*x+y+t*1.34);\n    return y;\n}\n\nfloat getSineNeighboursSum(vec2 cv){\n    float sum = 0.;\n    cv.y = fract(cv.y*4.)+.5;\n    for(float y = cv.y-2.; y <= cv.y+1.; y++){\n       sum += cubicPulse(0., .4, abs(getSine(cv.x, y)));\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 cv = (fragCoord.xy - .5 * res.xy) / res.y;\n    colorPoint[colorsPerGradient] gradient = colorPoint[](\n        colorPoint(0.0, hexToRgb(0x6a2c70)*.1),\n        colorPoint(0.2, hexToRgb(0x6a2c70)),\n        colorPoint(0.5, hexToRgb(0xb83b5e)),\n        colorPoint(0.75, hexToRgb(0xf08a5d)),\n        colorPoint(1., hexToRgb(0xeeecda)),\n        colorPoint(1., hexToRgb(0xeeecda))\n    );\n\n    t = iTime;\n    vec2 mandalaCoord = vec2(cos(12.*atan(cv.y, cv.x)), length(cv));\n    float y = getSineNeighboursSum(mandalaCoord);\n    y = pow(y, 1.0);\n    vec3 col = gradientColorAt(y, gradient);\n    fragColor = vec4(gammaCorrect(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int colorsPerGradient = 6;\n\n//--------------------------------------GRADIENT-----------------------------------\n//--------------------------------color point array logic--------------------------\n//-------------------------------------by Krabcode---------------------------------\n\nstruct colorPoint\n{\n    float pos;\n    vec3 val;\n};\n\ncolorPoint emptyColorPoint()\n{\n    return colorPoint(1.1, vec3(1.,0.,0.));\n}\n\nfloat map(float value, float start1, float stop1, float start2, float stop2)\n{\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat norm(float value, float start, float stop)\n{\n    return map(value, start, stop, 0., 1.);\n}\n\nint findClosestLeftNeighbourIndex(float pos, colorPoint[colorsPerGradient] gradient)\n{\n    for(int i = 0; i < 100; i++){\n        if(pos >= gradient[i].pos && pos <= gradient[i+1].pos){\n            return i;\n        }\n        if(i >= gradient.length()){\n            return 0;\n        }\n    }\n    return 0;\n}\n\nvec3 gradientColorAt(float normalizedPos, colorPoint[colorsPerGradient] gradient)\n{\n    float pos = clamp(normalizedPos, 0., 1.);\n    int leftIndex = findClosestLeftNeighbourIndex(pos, gradient);\n    int rightIndex = leftIndex + 1;\n    colorPoint A = gradient[leftIndex];    \n    colorPoint B = gradient[rightIndex];\n    float normalizedPosBetweenNeighbours = norm(pos, A.pos, B.pos);\n    return mix(A.val, B.val, normalizedPosBetweenNeighbours);\n}\n\nvec3 hexToRgb(int color)\n{\n    float rValue = float(color / 256 / 256);\n    float gValue = float(color / 256 - int(rValue * 256.0));\n    float bValue = float(color - int(rValue * 256.0 * 256.0) - int(gValue * 256.0));\n    return vec3(rValue / 255.0, gValue / 255.0, bValue / 255.0);\n}\n\n\nvec3 gammaCorrect(vec3 rgb)\n{\n    return pow(smoothstep(0., 1., rgb), vec3(1.0/2.2));\n}\n\nvec4 gammaCorrect(vec4 rgba)\n{\n    return vec4(gammaCorrect(rgba.rgb), 1.);\n}\n\n\n// find some cool gradients at https://colorhunt.co/\n\n/*\ncolorPoint[colorsPerGradient] gradient = colorPoint[](\n        colorPoint(0.00, hexToRgb(0x6a2c70)),\n        colorPoint(0.25, hexToRgb(0xb83b5e)),\n        colorPoint(0.50, hexToRgb(0xf08a5d)),\n        colorPoint(0.75, hexToRgb(0xeeecda)),\n        colorPoint(1.00, hexToRgb(0xeeecda)));\n*/","name":"Common","description":"","type":"common"}]}