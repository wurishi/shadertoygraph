{"ver":"0.1","info":{"id":"mlKSzK","date":"1686233030","viewed":100,"name":"Fork FixingPixe chanokin 156","username":"chanokin","description":"tried to explain myself what the computations mean\nCRT Styling Post Process, Improves the Quality of Pixel Art","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["scanlines","crt","postprocess","pixelart","shadowmask"],"hasliked":0,"parentid":"XsjSzR","parentname":"FixingPixelArt"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//   by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n// Emulated input resolution.\n#define pixel_width 32.0\n#if 0\n  // Fix resolution to set amount.\n  #define resizer (vec2(320.0, 160.0))\n#else\n  // Optimize for resize.\n  #define resizer (iResolution.xy/pixel_width)\n#endif\n\n// Hardness of scanline.\n//  8.0 = soft\n// 16.0 = medium\nfloat hardScan = 8.0;\n\n// Hardness of pixels in scanline.\n// 2.0 = soft\n// 4.0 = hard\nfloat hardPix = 4.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0/8.0 = extreme\nvec2 warp = vec2(1.0/4.0, 1.0/2.0); \n\n// Amount of shadow mask.\nfloat maskDark = 0.75;\nfloat maskLight = 1.1;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuming using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){\n    //return c <= 0.04045 ? c/12.92 : pow((c + 0.055)/1.055, 2.4);\n    return pow(c, 2.2); // straight up gamma coding \n}\nvec3 ToLinear(vec3 c){\n    return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));\n}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){\n    //return c < 0.0031308 ? c*12.92 : 1.055 * pow(c, 0.41666) - 0.055;\n    return pow(c, 0.45454545454545454545454545454545); // 0.4545... ~= 1.0/2.2 \n}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 SampleLinear(vec2 position, vec2 offset){\n    position = floor(position * resizer + offset) / resizer;\n  \n    // any coordinate of position is out of image \n    if (max(abs(position.x-0.5), abs(position.y-0.5)) > 0.5)  \n        return vec3(0.0,0.0,0.0);\n    \n    // -32.0 to get 'lowest' resolution image?\n    return ToLinear( texture(iChannel0, position.xy, -32.0).rgb );\n}\n\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){\n    pos = pos * resizer; // scale\n\n    // how far is the true pixel from the center\n    return ( 0.5 - fract(pos)); \n}\n    \n// 1D Gaussian.\nfloat Gauss(float pos, float scale) {\n    // scale here is likely (1 / sigma^2)\n    return exp( -scale * pos*pos);\n}\n\n// interpolate + apply gaussian convolution to a \n// 3-pixel horizontal window\nvec3 Horz3(vec2 position, float vertical_offset, float scale){\n    vec3 b = SampleLinear(position, vec2(-1.0, vertical_offset));\n    vec3 c = SampleLinear(position, vec2( 0.0, vertical_offset));\n    vec3 d = SampleLinear(position, vec2( 1.0, vertical_offset));\n    float dst = Dist(position).x;\n\n    // Convert distance to weight.\n    float wb = Gauss(dst - 1.0, scale);\n    float wc = Gauss(dst      , scale); // dst + 0\n    float wd = Gauss(dst + 1.0, scale);\n\n    // Return filtered sample.\n    return (b*wb + c*wc + d*wd) / (wb + wc + wd);\n}\n\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 position, float vertical_offset, float scale){\n    vec3 a = SampleLinear(position, vec2(-2.0, vertical_offset));\n    vec3 b = SampleLinear(position, vec2(-1.0, vertical_offset));\n    vec3 c = SampleLinear(position, vec2( 0.0, vertical_offset));\n    vec3 d = SampleLinear(position, vec2( 1.0, vertical_offset));\n    vec3 e = SampleLinear(position, vec2( 2.0, vertical_offset));\n    \n    float dst = Dist(position).x;\n    \n    // apply Gaussian envelope to interpolation weights\n    float wa = Gauss(dst - 2.0, scale);\n    float wb = Gauss(dst - 1.0, scale);\n    float wc = Gauss(dst      , scale); // dst + 0\n    float wd = Gauss(dst + 1.0, scale);\n    float we = Gauss(dst + 2.0, scale);\n    \n    // Return filtered sample.\n    return (a*wa + b*wb + c*wc + d*wd + e*we) / (wa + wb + wc + wd + we);\n}\n\n\n// Allow nearest three lines to affect pixel.\n// This is sort-of doing bilinear interpolation and\n// Gaussian filtering at the same time. Closer to bicubic  \n// due to 3 pixels taken into account but weights are a Gaussian curve\nvec3 TriGaussianInterpolation(vec2 position, float pixel_scale, float scanline_scale){\n    // interpolate 3 vertical pixels\n    vec3 a = Horz3(position, -1.0, pixel_scale); // above current pixel\n    vec3 b = Horz5(position,  0.0, pixel_scale); // current pixel\n    vec3 c = Horz3(position,  1.0, pixel_scale); // below current pixel\n    \n    float dst = Dist(position).y; // vertical distance to center of pixel\n    \n    // apply Gaussian envelope to interpolation weights\n    float wa = Gauss(dst - 1.0, scanline_scale); \n    float wb = Gauss(dst      , scanline_scale); // dst + 0\n    float wc = Gauss(dst + 1.0, scanline_scale);\n    \n    return a*wa + b*wb + c*wc;\n}\n\n// Distortion of scanlines, and end of screen alpha.\nvec2 Warp(vec2 pos){\n    // [0 -> 1] => [-0.5 -> 0.5]\n    pos = 2.0 * pos - 1.0; \n    // the closer pos is to 0,0 the less distortion is\n    // added to the multiplier\n    // because the coords are inverted, the corners are \n    // affected the most\n    pos *= vec2(1.0 + (pos.y*pos.y) * warp.y,  \n                1.0 + (pos.x*pos.x) * warp.x);\n\n    // get it back to the [0 -> 1] range\n    return (pos + 1.0) * 0.5;\n}\n\n// Shadow mask.\nvec3 Mask(vec2 pos, float mask_dark, float mask_light){\n    vec3 mask = vec3(mask_dark, mask_dark, mask_dark);\n\n    // pos.x += pos.x * pixel_width * 3.0;\n    pos.x += pixel_width * 3.0;\n    pos.x = fract(pos.x / pixel_width);\n\n    // simulating per-physical-pixel intensity\n    if(pos.x < 0.333) \n        mask.r = mask_light;\n    else if(pos.x<0.666) \n        mask.b = mask_light;\n    else \n        mask.g = mask_light;\n        \n    return mask;\n}\n\n// Draw dividing bars.\nbool is_bar(float pos, float bar, float width){\n    return abs(pos - bar) < width;\n}\n\n// Entry.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Unmodified.\n    vec2 norm_coord = fragCoord.xy/iResolution.xy; // uv\n    float third_of_width = iResolution.x*0.333;\n    float sixth_of_width = iResolution.x*0.666;\n    \n    \n    if(fragCoord.x < third_of_width){\n        // first third: resample\n        fragColor.rgb = SampleLinear(\n                            norm_coord + vec2(0.333, 0.0),\n                            vec2(0.0,0.0)\n                        );\n    }\n    else if(fragCoord.x < sixth_of_width){\n        // second third: distortion + scanlines\n        vec2 pos = Warp(norm_coord); // warp uv coord to get screen edge distortion\n        \n        // interpolate + gaussian filter 3x3 window\n        fragColor.rgb= TriGaussianInterpolation(pos, hardPix, hardScan);\n    }\n    else {\n        // last third: distortion + scanlines + 'bayer' masking\n        vec2 pos = Warp(norm_coord + vec2(-0.333, 0.0));\n        fragColor.rgb = TriGaussianInterpolation(pos, hardPix, hardScan) * \n                        Mask(fragCoord.xy, maskDark, maskLight)  + 0.001; \n        // mask should take in the distorted uv in my opinion\n    }    \n\n    fragColor.a = 1.0;  \n\n    if ( is_bar(fragCoord.x, iResolution.x * 0.333, 5.0) || \n         is_bar(fragCoord.x, iResolution.x * 0.666, 5.0) ) {\n      fragColor.r = 1.0; fragColor.g = 1.0; fragColor.b = 1.0; \n    }\n\n    fragColor.rgb= ToSrgb(fragColor.rgb);\n\n\n}\n\n","name":"Image","description":"","type":"image"}]}