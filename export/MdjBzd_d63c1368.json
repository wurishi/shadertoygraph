{"ver":"0.1","info":{"id":"MdjBzd","date":"1501791474","viewed":225,"name":"Landscape22","username":"Dude","description":"Landscape","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define MAXIMUM_STEPS 1290\n#define DISTANCE_THRESHOLD .3\n#define FAR_CLIP 120.0\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opDisplace( vec3 p, vec4 t )\n{\n    float d1 = sdPlane(p, t);\n    float d2 = (sin(1.9*p.x+(sin(p.z)*2.))*0.9-1.)*.3;\n    float d3 = cos(mod(p.z,133.))*0.3*sin(iTime*4.);\n    return d1+d2+d3;\n}\n\n/* ROTATIONS */\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat nearestSurface(vec3 rp) {\n    \n    float msd = 99999.;\n    vec4 plo = vec4(.0,.2,.0,.0);\n    \n    float orientation = 0.2;\n    msd = min(msd, opDisplace(rp, plo)); \n\n    return msd;\n}\n\n/* RAY MARCHING */\n\n//march a single ray\nvec4 marchRay(vec3 ro, vec3 rd) {\n\n    float d = 0.0; //distance marched\n    vec4 pc = vec4(0.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        \n        vec3 rp = ro + rd * d; //ray position\n        float ns = nearestSurface(rp);\n        d += ns;\n        \n        if (abs(ns) < DISTANCE_THRESHOLD*0.5) {\n            rp.xyz += 4.;\n            rp.xyz /= 8.;\n            vec4 clr = vec4(1.);\n            \n            pc = vec4(sin(rp.x), sin(rp.y), sin(rp.z), 1)*clr;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            pc = vec4(0.1, 0.3, 0.9, 1.);\n            pc *= 1.-smoothstep(0.02, 0.33, rd.y) + 0.8;\n            break;\n        }\n    }\n\n    return pc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0, 7, -20.+float(iFrame)/15.);\n\n    rY(ro, -cos(iTime) * .0006);\n    rY(rd, sin(iTime) * .02);\n    rX(rd, .5);\n    \n\tfragColor = marchRay(ro, rd);\n}\n\n","name":"Image","description":"","type":"image"}]}