{"ver":"0.1","info":{"id":"WsXcRn","date":"1583938698","viewed":192,"name":"Ancient Temple-v4","username":"jorge2017a1","description":"// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ancienttemplev4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Ancient Temple\" by Kali\n//https://www.shadertoy.com/view/4lX3Rj  ----modificado dia--11-03-2020\n\n//+ cambios de \n//https://www.shadertoy.com/view/XsfczB-----Russ\n\n\n\nconst int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,.8,1); \n///--------------------------------\nconst int Iterations=14;\nconst float detail=.00002;\nconst float Scale=2.;\n\nvec3 lightdir=normalize(vec3(0.,-0.3,-1.));\n\nfloat ot=0.;\nfloat det=0.;\nfloat hitfloor;\nfloat hitrock;\nfloat tt;\n///-----------------------------------\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n///---------------------------------\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n//----------------------------------------\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n\n///-------------------------------------\nfloat DE(vec3 pos) {\n\thitfloor=0.;\n\thitrock=0.;\n\tvec3 p=pos;\n    \n    p= rotate_y(p, iTime*0.09);\n    \n   \n\tfloat DEfactor=1.;\n\tot=1000.;\n    \n    \n\tfor (int i=0; i<Iterations; i++) {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\t//p = p - vec3(0.5,1.,0.5);\n        p = p - vec3(0.5,1.,0.7);\n\t}\n    \n    \n    float rr=length(pos+vec3(0.,-3.03,1.85-tt))-.017;\n    \n    float fl=pos.y-3.0;\n    \n    \n    float d=min(fl,length(p)/DEfactor-.0005);\n    \n\td=min(d,-pos.y+3.9);\n\n    \n    \n    \n    return d;\n}\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.2 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\n\n\n//-----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float time = iTime * .4;\n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n\n    \n    vec3 ro=vec3(0.5, 3.2,-0.8);\n   \n    vec3 rd=normalize(vec3(uv,1.));\n    \n \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    col += pow(hit.y,3.);\n    \n    col=col+pow(col,vec3(0.78902));\n    \n   \n    col=mix(vec3(length(col)),col,.85)*.95;\n    \n\tfragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}