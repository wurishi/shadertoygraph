{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"music","id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const int MAX_ITERATION = 128;\nconst float DELTA = 0.4;\nconst float PI = 3.1415926535897932384626433832795;\n\n\nconst float START_HUE = 0.0;\nconst float END_HUE   = 0.25;\nconst float START_SAT = 1.0;\nconst float END_SAT   = -0.4;\n\n\nfloat wrap (float value,float limit) {\n\tfloat result = mod(value,limit);\n\tif (result < 0.0) {result += limit;}\n\treturn result;\n}\n\nfloat hue2channel(float p, float q, float hue) {\n\thue = wrap(hue,1.0);\n\tif(hue < 1.0/6.0) return p + (q - p) * 6.0 * hue;\n\tif(hue < 1.0/2.0) return q;\n\tif(hue < 2.0/3.0) return p + (q - p) * (2.0/3.0 - hue) * 6.0;\n\treturn p;\t\n}\n\n\nvec4 hslToRgb(vec4 hsl){\n\n\t// hue is x\n\t// saturation is y\n\t// lightness is z\n\thsl.x = wrap(hsl.x,1.0);\n\t\n\tvec3 rgb;\n\t\n\tif(hsl.y == 0.0){\n\t\trgb.xyz = hsl.zzz; // achromatic\n\t} else {\n\t\t\n\t\tfloat q = (hsl.z < 0.5) ? (hsl.z * (1.0 + hsl.y)) : (hsl.z + hsl.y - hsl.z * hsl.y);\n\t\tfloat p = 2.0 * hsl.z - q;\n\t\trgb.x = hue2channel(p, q, hsl.x + 1.0/3.0);\n\t\trgb.y = hue2channel(p, q, hsl.x);\n\t\trgb.z = hue2channel(p, q, hsl.x - 1.0/3.0);\n\t}\n\t\n\treturn vec4(rgb.xyz,hsl.w);\n}\n\n\n\nbool isIntersecting(vec3 ray) {\n\n    float aspect = iResolution.x/iResolution.y;\n\n\tfloat x = wrap((ray.x + aspect)/20.0,1.0);\t\t\n\tfloat samplev = distance(vec2(0.0),texture(iChannel0,vec2(x)).xy) - 1.0;\n\t\n\t// trimming every once every two units\n\t// more like slicing :B\n\t// would have liked to have a smooth transition though...\n\t// ... but since it returns just a bool...\n\t// ... I'll probably try something else next time :] still learning\n\t\n\tfloat smoothTrim = smoothstep(0.0,1.0,mod(ray.z,2.0)/4.0);\n\treturn smoothTrim > 0.2 && ray.y < sin(ray.x*PI)*cos(ray.z*PI)*samplev * 2.0 - 1.0;\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\n\t// change coordinate system\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= aspect;\n\t\n\t//float time = iTime;\n\t\n\tfloat time = iTime*4.0;\n\n\t// to rotate the camera\n\tfloat angle = time/100.0*PI;\n\t\n\t// wavy movement\n\tfloat camY = cos(time/20.0 * PI)*3.0 + 4.5;\n\t// but still moving forward\n\tfloat camZ    = time/10.0;\n\t// we adapt the position of the screen\n\t// for a proper ray direction\n\tfloat screenY = camY-2.0;\n\tfloat screenZ = camZ+15.0;\n\t\n\t\n\t// our camera and the pixel it is looking at...\n\tvec3 camPos    = vec3(0.0,camY,camZ);\n\tvec3 pixelPos  = vec3(uv+vec2(0.0,screenY),screenZ);\n\t// ... gives us a direction\n\tvec3 direction = normalize(pixelPos-camPos);\n\n\t// rotate this direction 'cause it's cool\n\t// and I can show off my cool matrix\n\tmat3 Yrotation = mat3(\n\t\t\t-sin(angle),0.0,cos(angle),\n\t\t    0.0        ,1.0,0.0       ,\n\t\t    cos(angle) ,0.0,sin(angle)\t\t\n\t\t);\n\tdirection *= Yrotation;\n\t\n\t\n\t// starting point of the ray\n\tvec3 ray = pixelPos;\n\tfloat j = 0.0;\n\t/*\n\tfor(int i = 0; i < MAX_ITERATION; i++) {\n\t\tif (!isIntersecting(ray)) {\n\t\t\tj++;\n\t\t\tray += direction*DELTA;\n\t\t}\n\n\t\tif (int(j) != i) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\t//*/\n\t\n\t/* doesn't work in chrome  26.0.1410.64 / Win7\n\tfor(int i = 0; i < MAX_ITERATION; i++) {\n\t\tif (isIntersecting(ray)){\n\t\t\tbreak;\n\t\t}\n\t\tj++;\n\t\tray += direction*DELTA;\n\t}\n\t//*/\n\t\n\t//* maybe without break then...\n\tfor(int i = 0; i < MAX_ITERATION; i++) {\n\t\tif (!isIntersecting(ray)){\n\t\t\tj++;\n\t\t\tray += direction*DELTA;\n\t\t}\n\t}\n\t//*/\n\t\n\t\n\t// gradient color\n\tfloat gradient = float(j)/float(MAX_ITERATION);\t\n\tfloat hue = mix(START_HUE,END_HUE,gradient);\t\n\tfloat sat = mix(START_SAT,END_SAT,gradient);\n\t\n\tvec4 baseColor = hslToRgb(vec4(hue,sat,0.5,1.0));\t\n\t\n\n\tfragColor = baseColor;\n\t\n\t//texture overlay which fades in depth\n\t//vec4 texture = texture(iChannel1,ray.xz/10.0)*clamp((1.0-gradient*8.0),0.0,1.0) ;\n\t//fragColor = baseColor + mix(baseColor,texture,0.5);\n\t\n\tfragColor = 1.5 * baseColor;\n\t//*/\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msl3Dr","date":"1368003519","viewed":279,"name":"SoundMarch","username":"FrenchYann","description":"My first attempt at ray marching :3\nJust had an EurÃªka moment when I read the first 2 paragraphs of IÃ±igo Quilez's ray marching tutorial here\nhttps://iquilezles.org/articles/terrainmarching/terrainmarching.htm\nHave to continue reading now :D ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sound"],"hasliked":0,"parentid":"","parentname":""}}