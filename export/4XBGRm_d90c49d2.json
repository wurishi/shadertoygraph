{"ver":"0.1","info":{"id":"4XBGRm","date":"1708289366","viewed":29,"name":"moving 3d shape ","username":"ArmanD","description":"Still have this problem when calculating the normals with a too low angle.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","moving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_SPHERES = 2;\nconst int MAX_BOXES = 0;\nconst int MAX_POINTLIGHTS = 1;\n#define mx        \tiMouse.x/iResolution.x\n#define my        \tiMouse.y/iResolution.y\n#define t iTime\nfloat MAX_DIST = 50.;\nfloat SURF_DIST = 0.004;\nstruct Material{\nvec3 diff;\nvec3 reflectance;\n};\n\n    vec3 rotate(vec3 p,float angle,vec3 axis)\n{\n\tvec3 a = normalize(axis);\n    \tfloat s = sin(angle);\n   \tfloat c = cos(angle);\n    \tfloat r = 1.0 - c;\n   \tmat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n    \nstruct Sphere{\nvec3 pos;\nfloat r;\n//vec3 color;\n//Material m;\n};\nstruct PointLight{\n    vec3 pos;\n  //  vec3 color;\n   // float intensity;\n    };    \nstruct Box{\nvec3 pos;\nvec3 size;\nMaterial m;\n};\nstruct Scene{\nSphere spheres[MAX_SPHERES] ;\nPointLight pls[MAX_POINTLIGHTS];\n//Box boxes[MAX_BOXES];\n};\n    float boxDists(vec3 p,vec3 b,float r)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0)) - r\n\t\t+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n    \n    float sphereDists(vec3 p ,Sphere[MAX_SPHERES] sc){\n        float d =0.;\n        float prevD = MAX_DIST;\n        for(int i =0;i<MAX_SPHERES;i++){\n        Sphere s = sc[i];\n           d =0.;\n            d = length(p-s.pos+vec3(sin(cos(t)*sin(5.*p.x))/5.,sin(sin(t)*p.y)/3.,0.))-s.r;\n            d = min (d , prevD);\n            prevD = d;\n        }\n        return d;\n    }\n    float getDist(vec3 p, Scene sc){\n        float s = sphereDists(p ,sc.spheres);\n        //float b = boxDists(p , vec3(0.1,0.1,0.1),1.);\n        \n    return  min(s,p.y);\n    } \n    float glow = 0.;\nfloat march(vec3 ro , vec3 rd ,Scene sc){\n    float d =0.;\n    \n    float prevDs = MAX_DIST;\n    float minDs = MAX_DIST;\n    for( int i = 0;i<100;i++){\n    vec3 p = ro +rd*d;\n    float ds = getDist(p , sc);\n        minDs = min(ds , prevDs);\n        prevDs = ds;\n        d+=ds;\n        glow = 0.;//minDs;\n        if ( d > MAX_DIST )break; \n      \t \n            if(ds < SURF_DIST)break;\n   \n    }\n        return d;//fract(d/MAX_DIST)*MAX_DIST;\n}\nvec3 getNormal (vec3 p ,Scene sc){\nfloat d = getDist(p , sc);\nvec2 e = vec2 (SURF_DIST , 0. );\n \n    vec3 n = d-vec3 (\ngetDist(p-e.xyy,sc) ,\ngetDist(p-e.yxy,sc) ,\ngetDist(p-e.yyx,sc) );\nreturn normalize (n);\n}\nvec3 render(vec3 ro ,vec3 rd ,Scene sc){\n    float d = march (ro ,rd,sc);\n    vec3 p = ro + rd * d;\n    vec3 n = getNormal(p ,sc);\n    vec3 l = normalize(sc.pls[0].pos - p);\n    float dif = max ( dot(l , n),0.);\n    float d2 = march (p+n*SURF_DIST, l,sc);\n    if (d2 < length (sc.pls[0].pos-p)&&d < MAX_DIST) {dif *= 0.1;}\n    if( d >= MAX_DIST && glow <= 1.){\n    //dif = 1./glow;\n    }\n    return vec3(dif);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n float ratio = iResolution.y / iResolution.x;\nvec2 uv = (fragCoord.xy  / iResolution.x)- vec2 (0.5 , 0.5 *  ratio);\n    //Box bo[MAX_BOXES];\n    Sphere s = Sphere(vec3(0.,1.,0.),0.5);\n    Sphere s2 = Sphere(vec3(0,1.,0.),0.6);\n    Sphere sp[MAX_SPHERES] = Sphere[MAX_SPHERES](s,s2);\n    PointLight pl = PointLight(vec3(1.,3.,6));\n  // pl.pos.xz += 2.* vec2(cos(iTime),sin(iTime));\n    PointLight pls[MAX_POINTLIGHTS] = PointLight[MAX_POINTLIGHTS](pl);\n    Scene sc = Scene(sp , pls);// , bo);\n    float t2 = t;\n    vec3 ro = 6.*vec3(cos(t2),1./6.,sin(t2));\n    vec3 rd = normalize(vec3(uv.xy,1));\n    rd = rotate(rd ,0.01 , vec3( 1,0.,0.));\n    rd = rotate(rd,-t2-1.4,vec3(0,1,0));\n    vec3 col = render(ro , rd ,sc);\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}