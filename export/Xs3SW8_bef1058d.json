{"ver":"0.1","info":{"id":"Xs3SW8","date":"1458883893","viewed":467,"name":"Undertale Battle","username":"jackdavenport","description":"A recreation of Undertale's battle UI. Mostly an experiment for myself to test sprite encoding. No AI or bullets yet. Use arrow keys to move. Press 1 to injure yourself, and 2 to heal.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["game","pixel","sprite","art","battle","undertale","bullethell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thank you so much to 4rknova for the amazing sprite encoding tutorial!\n// Source: https://www.shadertoy.com/view/XtlGzN\n#define Q(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n\n#define BG 0.\n#define DT 1.\n#define BX 2.\n\n#define PLAYER_POS vec2(0.,0.)\n#define PLAYER_HEALTH vec2(1.,0.)\n#define PLAYER_LV   vec2(3.,0.)\n#define PLAYER_INVUL vec2(2.,0.)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\nvec4 soul(vec2 p, vec2 scale) {\n \n    vec4 col = vec4(0.);\n    vec2 grd = floor(p * scale);\n    \n    if(grd.x >= 0. && grd.y >= 0. &&\n       grd.x <= 15.&& grd.y >= 15.) {\n     \n        int y   = int(scale.y - grd.y + 10.);\n        float m = 0.;\n        \n        Q(0 ,BG,BG,DT,DT,BG,BG,BG,BG);\n        Q(1 ,BG,DT,DT,DT,DT,DT,BG,BG);\n        Q(2 ,DT,DT,DT,DT,DT,DT,DT,BG);\n        Q(3 ,DT,DT,DT,DT,DT,DT,DT,BG);\n        Q(4 ,DT,DT,DT,DT,DT,DT,DT,DT);\n        Q(5 ,DT,DT,DT,DT,DT,DT,DT,DT);\n        Q(6 ,DT,DT,DT,DT,DT,DT,DT,DT);\n        Q(7 ,DT,DT,DT,DT,DT,DT,DT,DT);\n        Q(8 ,DT,DT,DT,DT,DT,DT,DT,DT);\n        Q(9 ,DT,DT,DT,DT,DT,DT,DT,DT);\n        Q(10,BG,BG,DT,DT,DT,DT,DT,DT);\n        Q(11,BG,BG,DT,DT,DT,DT,DT,DT);\n        Q(12,BG,BG,BG,BG,DT,DT,DT,DT);\n        Q(13,BG,BG,BG,BG,DT,DT,DT,DT);\n     \tQ(14,BG,BG,BG,BG,BG,BG,DT,DT);\n        Q(15,BG,BG,BG,BG,BG,BG,DT,DT);\n        \n        float ldx = 15. - grd.x;\n        float rdx = grd.x;\n        float bit = 0.;\n        \n        if(grd.x >= 8.) bit = mod(m / pow(4., ldx), 4.);\n        else\t\t    bit = mod(m / pow(4., rdx), 4.);\n        bit = floor(bit);\n        \n        \t if(bit == BG) col = vec4(0.);\n        else if(bit == DT) col = vec4(1.,0.,0.,1.);\n        \n    }\n    \n    return col;\n    \n}\n\nvec4 box(vec2 p, vec2 scale) {\n \n    vec4 col = vec4(0.);\n    vec2 grd = floor(p * scale);\n    \n    if(grd.x >= 0. && grd.y >= 0. &&\n       grd.x <= 15.&& grd.y >= 15.) {\n     \n        int y   = int(scale.y - grd.y + 10.);\n        float m = 0.;\n        \n        Q(0 ,BX,BX,BX,BX,BX,BX,BX,BX);\n        Q(1 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(2 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(3 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(4 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(5 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(6 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(7 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(8 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(9 ,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(10,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(11,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(12,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(13,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(14,BX,BG,BG,BG,BG,BG,BG,BG);\n        Q(15,BX,BX,BX,BX,BX,BX,BX,BX);\n        \n        float ldx = 15. - grd.x;\n        float rdx = grd.x;\n        float bit = 0.;\n        \n        if(grd.x >= 8.) bit = mod(m / pow(4., ldx), 4.);\n        else\t\t    bit = mod(m / pow(4., rdx), 4.);\n        bit = floor(bit);\n        \n        \t if(bit == BG) col = vec4(0.);\n        else if(bit == BX) col = vec4(1.);\n        \n    }\n    \n    return col;\n    \n}\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel3, (0.5+re) / iChannelResolution[3].xy, -100.0 );\n}\n\nvec3 getScene(vec2 p) {\n \n    vec2 soulPos = loadValue(PLAYER_POS).xy;\n    float love   = loadValue(PLAYER_LV ).x;\n    float invul  = loadValue(PLAYER_INVUL).x; \n    \n    float invulFactor = 1.;\n    if(invul > 0.) {\n     \n        invulFactor = abs(sin(iTime * 10.));\n        \n    }\n    \n    vec4 col = vec4(0.);\n    col = soul(p - soulPos*vec2(1.,-1.), vec2(250.));\n    col = mix(box(p - vec2(.65,-.76), vec2(30.)), col, col.a * invulFactor);\n    \n    float health = loadValue(PLAYER_HEALTH).x;\n    float maxH   = 16. + (4. * love);\n    if(love == 20.) maxH = 99.;\n    \n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    if(uv.x > .1 && uv.x < .2 && uv.y > .1 && uv.y < .2) {\n     \n        col = vec4(1.,0.,0.,0.);\n        \n    }\n    if(uv.x > .1 && uv.x < (.1 + (health / maxH) * .1) && uv.y > .1 && uv.y < .2) {\n     \n        col = vec4(1.,1.,0.,0.);\n        \n    }\n    \n    uv = (-iResolution.xy + 2.0*gl_FragCoord.xy) / iResolution.y;\n    float f = PrintInt((uv-vec2(-1.55,-.55))*10.0, health);\n    col = mix(col, vec4(1.), f);\n    f = PrintInt((uv-vec2(-1.25,-.55))*10.0, maxH);\n    col = mix(col, vec4(1.), f);\n    \n    return col.xyz;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv   = fragCoord.xy / iResolution.xy * vec2(iResolution.x/iResolution.y,1.);\n    fragColor = vec4(getScene(uv),1.);\n    \n    //fragColor = texture(iChannel3, fragCoord / iResolution.xy);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_LEFT  vec2(37.5/256.0,0.)\n#define KEY_UP    vec2(38.5/256.0,0.)\n#define KEY_RIGHT vec2(39.5/256.0,0.)\n#define KEY_DOWN  vec2(40.5/256.0,0.)\n#define KEY_1     vec2(49.5/256.0,.5)\n#define KEY_2     vec2(50.5/256.0,.5)\n\n#define SPEED 3.\n\n#define LEFT_BOUND .685\n#define RIGHT_BOUND 1.085\n#define UP_BOUND   .875\n#define DOWN_BOUND .4785\n\n#define PLAYER_POS vec2(0.,0.)\n#define PLAYER_HEALTH vec2(1.,0.)\n#define PLAYER_LV   vec2(3.,0.)\n#define PLAYER_INVUL vec2(2.,0.)\n\n// BEGIN MEMORY CODE\n// BY THE AMAZING IQ\n// SOURCE: https://www.shadertoy.com/view/MddGzf\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }  \n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel3, (0.5+re) / iChannelResolution[3].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n// END MEMORY CODE\n\nvoid attackPlayer(float amount, inout float health, inout float invul, inout float maxHealth) {\n \n    if(invul > 0. && amount > 0.) return;\n    \n    if(amount > 0.) {\n     \n        health -= amount;\n        invul   = 1.;\n        \n    } else if(amount < 1.) {\n     \n        health += -amount;\n        \n    }\n    \n    health = clamp(health, 0., maxHealth);\n    \n}\n\nvoid healPlayer(float amount, inout float health, inout float invul, inout float maxHealth) {\n \n    attackPlayer(-amount, health, invul, maxHealth);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > 14. || fragCoord.y > 14.) return;\n    \n    vec2 pos = loadValue(PLAYER_POS).xy;   \n    float health = loadValue(PLAYER_HEALTH).x;\n    float lv     = loadValue(PLAYER_LV).x;\n    float invul  = loadValue(PLAYER_INVUL).x;\n    \n    float maxHealth = 16. + (4. * lv);\n    if(lv == 20.) maxHealth = 99.;\n    \n    if(iFrame == 0) {\n        \n        pos = mix(vec2(LEFT_BOUND,DOWN_BOUND),vec2(RIGHT_BOUND,UP_BOUND), .5);\n    \tlv  = 1.;\n        invul = 0.;\n        \n        lv = clamp(lv, 1., 20.);\n        maxHealth = 16. + (4. * lv);\n        health = maxHealth;\n        \n    }\n        \n    pos.x += (texture(iChannel2,KEY_RIGHT) - texture(iChannel2,KEY_LEFT)).x *  SPEED / iResolution.x;\n    pos.y += (texture(iChannel2,KEY_UP   ) - texture(iChannel2,KEY_DOWN)).x * -SPEED / iResolution.y;\n    \n    pos.x = clamp(pos.x, LEFT_BOUND, RIGHT_BOUND);\n    pos.y = clamp(pos.y, DOWN_BOUND, UP_BOUND   );\n \n    if(invul > 0.) {\n     \n        invul -= iTimeDelta;\n        invul = max(invul, 0.);\n        \n    }\n    \n    if(texture(iChannel2, KEY_1).x > 0.) {\n     \n        attackPlayer(2., health, invul, maxHealth);\n        \n    }\n    if(texture(iChannel2, KEY_2).x > 0.) {\n     \n        healPlayer(2., health, invul, maxHealth);\n        \n    }\n    \n    fragColor = vec4(0.);\n    storeValue(PLAYER_POS, vec4(pos,1.,1.), fragColor, fragCoord);\n    storeValue(PLAYER_HEALTH, vec4(health), fragColor, fragCoord);\n    storeValue(PLAYER_LV , vec4(lv)\t\t  , fragColor, fragCoord);\n    storeValue(PLAYER_INVUL, vec4(invul)  , fragColor, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"}]}