{"ver":"0.1","info":{"id":"fsBcRm","date":"1643227110","viewed":316,"name":"Nixie-style digital clock","username":"stegu","description":"If you ever want to know the time, but don't have the energy to move your eyes to the corner of the screen, use this! (Seriously, I did this to demo my shader-friendly character shapes . They're based on distance fields and can be quite useful.)","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["noise","distancefield","text","digits"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Display the current time with a retro Nixie-tube look\n// Stefan Gustavson (stegu on shadertoy.com) 2022-01-26\n// All code in the \"Image\" tab is public domain.\n// Functions in the \"Common\" tab are also public domain,\n// except where a separate license is specified.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.x);\n    float time = iTime;\n\n    vec2 p = -3.0+uv*50.0 - vec2(0.0,9.0);\n\n    float bbox = 1.0-max(max(1.0-aastep(-3.0, p.x), aastep(47.0, p.x)),\n                           max(1.0-aastep(-3.0, p.y), aastep(11.0, p.y)));\n\n    // Some relief for the GPU: exit early if we're in the black margins\n    if(bbox == 0.0) {\n        fragColor = vec4(vec3(0.0),1.0);\n        return;\n    }\n    \n    // If not, well, let's put that GPU to good use!\n    float secs = floor(mod(iDate.w, 60.0));\n    float mins = floor(mod(iDate.w, 3600.0)/60.0);\n    float hrs = floor(iDate.w/3600.0);\n    int h10 = int(floor(hrs/10.0));\n    int h1 = int(floor(mod(hrs, 10.0)));\n    int m10 = int(floor(mins/10.0));\n    int m1 = int(floor(mod(mins, 10.0)));\n    int s10 = int(floor(secs/10.0));\n    int s1 = int(floor(mod(secs, 10.0)));\n\n    vec2 wspace = vec2(6.5, 0.0);\n    vec2 nspace = vec2(3.5, 0.0);\n    float d = 1e10;\n    d = min(d, number(h10, p));\n    d = min(d, number(h1, p-wspace));\n    d = min(d, nixiecolon(p-wspace-1.45*nspace)-0.2);\n    d = min(d, number(m10, p-2.0*wspace-nspace));\n    d = min(d, number(m1, p-3.0*wspace-nspace));\n    d = min(d, nixiecolon(p-3.0*wspace-2.4*nspace)-0.2);\n    d = min(d, number(s10, p-4.0*wspace-2.0*nspace));\n    d = min(d, number(s1, p-5.0*wspace-2.0*nspace));\n\n    vec2 g; // For gradients returned from psrdnoise()\n\n    // Digit outlines\n    float core = 1.0-aastep(0.2, d);\n    // \"flare\" is a wide blurry region around the characters, and\n    // \"flarenoise\" is a spatio-temporal modulation of its extents\n    // (slight flickering, but not all characters at the same time)\n    float flarenoise = psrdnoise(vec2(p.x*0.1,5.0*time), vec2(0.0), 0.0, g);\n    float flare = 1.0-smoothstep(0.0, 2.5, d + 0.05*flarenoise);\n    flare *= flare; // A more rapid decline towards the edge\n    // \"glow\" is a variation in the intensity of the glowy cathode (core)\n    float glow = 0.8+0.2*psrdnoise(p - vec2(0.0, 2.0*time), vec2(0.0), 4.0*time, g);\n    // Now we mess up the distance field a little for the \"halo\" effect\n    d += 0.1*psrdnoise(p - vec2(0.0, 2.0*time), vec2(0.0), 8.0*time, g);\n    d += 0.05*psrdnoise(2.0*p - vec2(0.0, 4.0*time) + 0.15*g, vec2(0.0), -16.0*time, g);\n    // \"halo\" is a kind of flame/plasma cloud near the core. A real Nixie tube\n    // doesn't have this, but it adds some appealing visual detail.\n    // Looks more like hot filaments than \"cold cathodes\", but... oh, well.\n    float halo = 1.0-smoothstep(-0.3, 0.3, d);\n\n    // Brittle parameters! This scale/shift of p has a strong impact\n    // on the pattern at the edges of the grid through \"anodefade\".\n    vec3 anodedists = hexgrid(1.7*p+vec2(0.1,0.23));\n    float anodedist = anodedists.y - anodedists.x; // Voronoi cell borders\n    // Fade the hexagonal holes in the anode towards the edges\n    float anodefade = max(max(1.0-aasmoothstep(-2.2, -1.5, p.x), aasmoothstep(45.5, 46.2, p.x)),\n                          max(1.0-aasmoothstep(-2.0, -1.6, p.y), aasmoothstep(9.4, 10.0, p.y)));\n    float anode = 1.0 - aastep(0.1, anodedist - anodefade);\n\n    // Colors as named variables, if you want to tweak them\n    vec3 corecolor = vec3(1.0,0.7,0.0);\n    vec3 halocolor = vec3(1.0,0.5,0.0);\n    vec3 flarecolor = vec3(1.0,0.3,0.0);\n    vec3 anodecolor = vec3(0.2,0.1,0.1);\n    vec3 anodehighlightscolor = vec3(1.0,0.5,0.0);\n\n    float anodecolornoise = 0.02*psrdnoise(p*vec2(0.2,2.0), vec2(0.0), 0.0, g);\n    anodecolor += anodecolornoise*anodehighlightscolor; // Long variable names, I know\n\n    vec3 mixcolor = vec3(0.0); // Mix additively from black\n    mixcolor = mix(mixcolor, flarecolor, 0.5*flare);\n    mixcolor = mix(mixcolor, halocolor, 0.9*halo);\n    mixcolor = mix(mixcolor, corecolor, core*glow);\n    mixcolor = mix(mixcolor, anodecolor, anode);\n    mixcolor *= bbox; // AA-mask to black at the very edge of the bounding box\n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n\n// Compute the shortest distance from p\n// to a line segment from p1 to p2.\nfloat lined(vec2 p1, vec2 p2, vec2 p) {\n    vec2 p1p2 = p2 - p1;\n    vec2 v = normalize(p1p2);\n    vec2 s = p - p1;\n    float t = dot(v, s);\n    if (t<0.0) return length(s);\n    if (t>length(p1p2)) return length(p - p2);\n    return length(s - t*v);\n}\n\n// Compute the shortest distance from p to a circle\n// with center at c and radius r. (Extremely simple.)\nfloat circled(vec2 c, float r, vec2 p) {\n    return abs(length(p - c) - r);\n}\n\n// Compute the shortest distance from p to a\n// circular arc with center c from p1 to p2.\n// p1, p2 are in the +angle direction (ccw),\n// to resolve the major/minor arc ambiguity, so\n// specifying p1, p2 in the wrong order will\n// yield the complement to the arc you wanted.\n// If p1 = p2, the entire circle is drawn, but\n// you don't want to use this function to draw\n// a circle. Use the simple circled() instead.\n// If p1 and p2 have different distances to c,\n// the end of the arc will not look right. If\n// this is inconvenient, uncomment the 3rd line.\nfloat arcd(vec2 c, vec2 p1, vec2 p2, vec2 p) {\n\n    vec2 v1 = p1 - c;\n    vec2 v2 = p2 - c;\n    // Optional: make sure p1, p2 are both on the circle\n    // v2 = normalize(v2)*length(v1);\n    vec2 v = p - c;\n\n    vec2 w = vec2(dot(v, -vec2(-v1.y, v1.x)), dot(v, vec2(-v2.y, v2.x)));\n\n    if(dot(v1, vec2(-v2.y, v2.x)) >= 0.0) { // Arc angle <= pi\n        if(all(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p)); // nearest end\n        } else {\n            return abs(length(v) - length(v1)); // dist to arc\n        }\n    } else { // Arc angle > pi\n        if(any(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p));\n        } else {\n            return abs(length(v) - length(v1));\n        }\n    }\n}\n\n// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// A smoothstep() that blends to an aastep() under minification\nfloat aasmoothstep(float t1, float t2, float v) {\n\tfloat aw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n\tfloat sw = max(0.5*(t2-t1), aw);\n\tfloat st = 0.5*(t1+t2);\n\treturn smoothstep(st-sw, st+sw, v);\n}\n\n// Distance field of a hexagonal (simplex) grid\n// The return vector contains the distances to the\n// three closest points, sorted by magnitude.\nvec3 hexgrid(vec2 p) {\n\n    const float stretch = 1.0/0.8660; // No use for tiling here,\n    const float squash = 0.8660;  // use unmodified simplex grid\n\t\n    //  v.y = v.y + 0.0001; // needed w/ stretched grid (rounding errors)\n    p.y = p.y * stretch;\n    // Transform to grid space (axis-aligned, modified \"simplex\" grid)\n    vec2 uv = vec2(p.x + p.y*0.5, p.y);\n    // Determine which simplex we're in, with i0 being the \"base\"\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // o1 is the offset in simplex space to the second corner\n    float cmp = step(f0.y, f0.x);\n    vec2 o1 = vec2(cmp, 1.0-cmp);\n    // Enumerate the remaining simplex corners\n    vec2 i1 = i0 + o1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n    // Transform corners back to texture space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + o1.x - o1.y * 0.5, p0.y + o1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n    vec3 d = vec3(length(p-p0), length(p-p1), length(p-p2));\n    // Only three values - bubble sort is just fine.\n    d.yz = (d.y < d.z) ? d.yz : d.zy;\n    d.xy = (d.x < d.y) ? d.xy : d.yx;\n    d.yz = (d.y < d.z) ? d.yz : d.zy;\n    return d;\n}\n\n// The digits. Simple functions, only a lot of them.\n\n// These glyphs and their implementation as distance fields\n// are the original work of me (stefan.gustavson@gmail.com),\n// and the code below is released under the MIT license:\n// https://opensource.org/licenses/MIT\n// (If that is inconvenient for you, let me know. I'm reasonable.)\n//\n// Experts say mortals should not attempt to design character shapes.\n// \"It's just ten simple digits\", I thought, \"How hard can it be?\"\n// A week later, after countless little tweaks to proportions and\n// curvature, and with a notepad full of sketches and pen-and-paper\n// math, some of it horribly wrong because it was decades since I\n// solved this kind of equations by hand, I know the answer:\n// It can be *really* hard. But also loads of fun!\n//\nfloat nixie0(vec2 p) {\n    // Special hack instead of pasting together arcs and lines\n    float d = lined(vec2(2.0), vec2(2.0, 6.0), p);\n    return abs(d - 2.0);\n}\n\nfloat nixie1(vec2 p) {\n    float d1 = lined(vec2(2.0, 0.0), vec2(2.0, 8.0), p);\n    float d2 = lined(vec2(2.0, 8.0), vec2(1.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie1alt(vec2 p) { // Straight line\n    return lined(vec2(2.0, 0.0), vec2(2.0, 8.0), p);\n}\n\nfloat nixie2(vec2 p) {\n    const float x = 3.2368345; // Icky coordinates,\n    const float y = 4.4283002; // used twice below\n    float d1 = lined(vec2(4.25, 0.0), vec2(-0.25, 0.0), p);\n    float d2 = arcd(vec2(10.657842, -5.001899), // Also icky\n                    vec2(x, y), vec2(-0.25, 0.0), p);\n    float d3 = arcd(vec2(2.0, 6.0), vec2(x, y), vec2(0.0, 6.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie2alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(4.0, 0.0), vec2(0.0), p);\n    float d2 = lined(vec2(0.0), vec2(3.6, 4.8), p);\n    float d3 = arcd(vec2(2.0, 6.0), vec2(3.6, 4.8), vec2(0.0, 6.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie3(vec2 p) {\n    // Two round parts:\n    // float d1 = arcd(vec2(2.0, 2.1), vec2(-0.1, 2.1), vec2(2.0, 4.2), p);\n    // float d2 = arcd(vec2(2.0, 6.1), vec2(2.0, 4.2), vec2(0.1, 6.1), p);\n    // Angled top, more like classic Nixie tube digits:\n    float d1 = arcd(vec2(2.0, 2.25), vec2(-0.25, 2.25), vec2(2.0, 4.5), p);\n    float d2 = lined(vec2(2.0, 4.5), vec2(4.0, 7.75), p);\n    float d3 = lined(vec2(4.0, 7.75), vec2(0.0, 7.75), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie3alt(vec2 p) { // Same size loops\n    float d1 = arcd(vec2(2.0), vec2(0.0, 2.0), vec2(2.0, 4.0), p);\n    float d2 = arcd(vec2(2.0, 6.0), vec2(2.0, 4.0), vec2(0.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie4(vec2 p) {\n    // This digit is 5.0 units wide, most others are 4.0 or 4.5\n    float d1 = lined(vec2(4.0, 0.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(0.0, 2.0), p);\n    float d3 = lined(vec2(0.0, 2.0), vec2(5.0, 2.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie4alt(vec2 p) {\n    // This digit is 4.0 units wide, but looks cropped\n    float d1 = lined(vec2(4.0, 0.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(0.0, 2.0), p);\n    float d3 = lined(vec2(0.0, 2.0), vec2(4.0, 2.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie5(vec2 p) {\n    float d1 = lined(vec2(4.0, 7.75), vec2(0.5, 7.75), p);\n    float d2 = lined(vec2(0.5, 7.75), vec2(0.0, 4.5), p);\n    float d3 = lined(vec2(0.0, 4.5), vec2(2.0, 4.5), p);\n    float d4 = arcd(vec2(2.0, 2.25), vec2(-0.25, 2.25), vec2(2.0, 4.5), p);\n    return min(min(d1, d2), min(d3, d4));\n}\n\nfloat nixie5alt(vec2 p) {\n    float d1 = lined(vec2(4.0, 8.0), vec2(0.0, 8.0), p);\n    float d2 = lined(vec2(0.0, 8.0), vec2(0.0, 5.0), p);\n    float d3 = lined(vec2(0.0, 5.0), vec2(2.0, 5.0), p);\n    float d4 = arcd(vec2(2.0, 3.0), vec2(4.0, 3.0), vec2(2.0, 5.0), p);\n    float d5 = lined(vec2(4.0, 3.0), vec2(4.0, 2.0), p);\n    float d6 = arcd(vec2(2.0), vec2(0.0, 2.0), vec2(4.0, 2.0), p);\n    return min(min(min(d1, d2), min(d3, d4)), min(d5, d6));\n}\n\nfloat nixie6(vec2 p) {\n    float d1 = arcd(vec2(84.0/13.0, 2.25), vec2(3.0, 8.0), vec2(-0.25, 2.25), p);\n    float d2 = circled(vec2(2.0, 2.25), 2.25, p);\n    return min(d1, d2);\n}\n\nfloat nixie6alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(0.4, 3.2), vec2(3.0, 8.0), p);\n    float d2 = circled(vec2(2.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixie7(vec2 p) { // Ugly coordinates, but these expressions are exact\n    float d1 = lined(vec2(0.0, 7.75), vec2(0.25*sqrt(2259.0)-8.0, 7.75), p);\n    float d2 = arcd(vec2(-8.0, 12.0), vec2(2.5, 5.0), vec2(0.25*sqrt(2259.0)-8.0, 7.75), p);\n    float d3 = arcd(vec2(10.0, 0.0), vec2(2.5, 5.0), vec2(10.0-2.5*sqrt(13.0), 0.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie7alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(0.0, 8.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(1.0, 0.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie8(vec2 p) {\n    float d1 = circled(vec2(2.0, 2.2), 2.2, p);\n    float d2 = circled(vec2(2.0, 6.2), 1.8, p);\n    return min(d1, d2);\n}\n\nfloat nixie8alt(vec2 p) { // Same size loops\n    float d1 = circled(vec2(2.0), 2.0, p);\n    float d2 = circled(vec2(2.0, 6.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixie9(vec2 p) {\n    float d1 = arcd(vec2(-32.0/13.0, 5.75), vec2(1.0, 0.0), vec2(4.25, 5.75), p);\n    float d2 = circled(vec2(2.0, 5.75), 2.25, p);\n    return min(d1, d2);\n}\n\nfloat nixie9alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(3.6, 4.8), vec2(1.0, 0.0), p);\n    float d2 = circled(vec2(2.0, 6.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixieminus(vec2 p) {\n    return lined(vec2(0.5, 4.0), vec2(3.5, 4.0), p);\n}\n\nfloat nixieequals(vec2 p) {\n    float d1 = lined(vec2(0.5, 3.0), vec2(3.5, 3.0), p);\n    float d2 = lined(vec2(0.5, 5.0), vec2(3.5, 5.0), p);\n    return min(d1, d2);\n}\n\nfloat nixieplus(vec2 p) {\n    float d1 = lined(vec2(0.0, 4.0), vec2(4.0, 4.0), p);\n    float d2 = lined(vec2(2.0, 2.0), vec2(2.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixiedot(vec2 p) {\n    // circled with r=0 yields a point, but with more work\n    return length(p - vec2(2.0, 0.0));\n}\n\nfloat nixiecolon(vec2 p) {\n    float d1 = length(p - vec2(2.0));\n    float d2 = length(p - vec2(2.0, 5.0));\n    return min(d1, d2);\n}\n\n// End of MIT-licensed code\n\nfloat number(int n, vec2 p) {\n    switch(n) {\n        case 0: return nixie0(p);\n        case 1: return nixie1(p);\n        case 2: return nixie2(p);\n        case 3: return nixie3(p);\n        case 4: return nixie4(p);\n        case 5: return nixie5(p);\n        case 6: return nixie6(p);\n        case 7: return nixie7(p);\n        case 8: return nixie8(p);\n        case 9: return nixie9(p);\n        default: return 1e10;\n    }\n}\n\n","name":"Common","description":"","type":"common"}]}