{"ver":"0.1","info":{"id":"csdyz8","date":"1695147038","viewed":17,"name":"Curly integration","username":"frettini","description":"Integrating along a vector field using curl noise. ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["noise","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n    return;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":" #define PI 3.14159265359\n\n// https://www.shadertoy.com/view/XdGfRR\n// Created by David Hoskins. May 2018\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n \n vec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn (vec2(q) * UIF - 0.5)*2.0;\n}\n \n //---------------------------------\n \n // Perlin Noise\n // https://adrianb.io/2014/08/09/perlinnoise.html\n const int p[512] = int[512]( 151,160,137,91,90,15,                 \n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,   \n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n    \n    151,160,137,91,90,15,                 \n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,   \n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n);\n //const int permutations[2] = int[2](1,2);\n \nconst vec2 gradients[8] = vec2[8]( vec2(1.,1.), vec2(-1.,1.), vec2(1.,-1.), vec2(-1.,-1.), \n                                   vec2(1.,0.), vec2(-1.,0.), vec2( 0.,1.), vec2(0.,-1.));\n                                   \nconst vec3 gradients3D[12] = vec3[12]( vec3(1.,1.,0.),vec3(-1.,1.,0.),vec3(1.,-1.,0.),vec3(-1.,-1.,0.),\n                                      vec3(1.,0.,1.),vec3(-1.,0.,1.),vec3(1.,0.,-1.),vec3(-1.,0.,-1.),\n                                      vec3(0.,1.,1.),vec3(0.,-1.,1.),vec3(0.,1.,-1.),vec3(0.,-1.,-1.));\n \n vec2 Smooth(const vec2 t)\n {\n     return t * t * t * (10.0 + t * ( t * 6.0 - 15.0));\n }\n \n vec3 Smooth(const vec3 t)\n {\n     return t * t * t * (10.0 + t * ( t * 6.0 - 15.0));\n }\n \n float PerlinNoise(vec2 gridUV)\n {\n     uvec2 igridUV = uvec2(gridUV) & uvec2(255); // modulo 255\n     vec2 fgridUV = fract(gridUV);\n     vec2 smoothGridUV = Smooth(fgridUV);\n     \n     vec2 bottomLeft  = gradients[ p[p[igridUV.x] + int(igridUV.y) ]     % 8 ];\n     vec2 bottomRight = gradients[ p[p[ int(igridUV.x) + 1] + int(igridUV.y) ]   % 8 ];\n     vec2 topLeft     = gradients[ p[p[igridUV.x] + int(igridUV.y)+1 ]   % 8 ];\n     vec2 topRight    = gradients[ p[p[ int(igridUV.x) + 1] + int(igridUV.y)+1 ] % 8 ];\n     \n     float x1 = mix( dot(bottomLeft, fgridUV), dot(bottomRight, fgridUV - vec2(1., 0.)), smoothGridUV.x);\n     float x2 = mix( dot(topLeft, fgridUV - vec2(0., 1.)), dot(topRight, fgridUV - vec2(1., 1.)), smoothGridUV.x);\n     return (mix( x1, x2, smoothGridUV.y)+1.)/2.;\n     \n }\n \n  float PerlinNoise3D(vec3 gridUV)\n {\n     uvec3 igridUV = uvec3(gridUV) & uvec3(255); // modulo 255\n     vec3 fgridUV = fract(gridUV);\n     vec3 smoothGridUV = Smooth(fgridUV);\n     \n     vec3 aaa = gradients3D[ p[ p[ p[ igridUV.x] + int(igridUV.y) ] + int(igridUV.z)]     % 12 ];\n     vec3 aba = gradients3D[ p[ p[ p[ igridUV.x] + int(igridUV.y)+1 ]  + int(igridUV.z)]  % 12 ];\n     vec3 baa = gradients3D[ p[ p[ p[ int(igridUV.x) + 1] + int(igridUV.y) ] + int(igridUV.z)]       % 12 ];\n     vec3 bba = gradients3D[ p[ p[ p[ int(igridUV.x) + 1] + int(igridUV.y)+1 ]  + int(igridUV.z) ] % 12 ];\n     \n     vec3 aab = gradients3D[ p[ p[ p[ igridUV.x] + int(igridUV.y) ] + int(igridUV.z) + 1]     % 12 ];\n     vec3 abb = gradients3D[ p[ p[ p[ igridUV.x] + int(igridUV.y)+1 ]  + int(igridUV.z)+1]  % 12 ];\n     vec3 bab = gradients3D[ p[ p[ p[ int(igridUV.x) + 1] + int(igridUV.y) ] + int(igridUV.z)+1]       % 12 ];\n     vec3 bbb = gradients3D[ p[ p[ p[ int(igridUV.x) + 1] + int(igridUV.y)+1 ]  + int(igridUV.z) +1] % 12 ];\n     \n     float x1 = mix( dot(aaa, fgridUV), dot(baa, fgridUV - vec3(1., 0., 0.)), smoothGridUV.x);\n     float x2 = mix( dot(aba, fgridUV - vec3(0., 1., 0.)), dot(bba, fgridUV - vec3(1., 1., 0.)), smoothGridUV.x);\n     \n     float xz1 = mix( dot(aab, fgridUV - vec3(0., 0., 1.)), dot(bab, fgridUV - vec3(1., 0., 1.)), smoothGridUV.x);\n     float xz2 = mix( dot(abb, fgridUV - vec3(0., 1., 1.)), dot(bbb, fgridUV - vec3(1., 1., 1.)), smoothGridUV.x);\n     \n     float y1 = mix(x1, x2, smoothGridUV.y);\n     float y2 = mix(xz1, xz2, smoothGridUV.y);\n     \n     return mix( y1, y2, smoothGridUV.z);\n     \n }\n \nvec2 CurlNoise(vec2 gridUV)\n{\n    float eps = 0.0001;\n    float Dx = (PerlinNoise(gridUV+vec2(eps,0.)) - PerlinNoise(gridUV+vec2(-eps,0.))) / (eps * 2.0);\n    float Dy = (PerlinNoise(gridUV+vec2(0., eps)) - PerlinNoise(gridUV+vec2(0., -eps))) / (eps * 2.0);\n    return vec2(Dx, -Dy);\n}\n\nvec2 CurlNoise(vec3 gridUV)\n{\n    float eps = 0.0001;\n    float Dx = (PerlinNoise3D(gridUV+vec3(eps,0., 0.)) - PerlinNoise3D(gridUV+vec3(-eps,0., 0.))) / (eps * 2.0);\n    float Dy = (PerlinNoise3D(gridUV+vec3(0., eps, 0.)) - PerlinNoise3D(gridUV+vec3(0., -eps, 0.))) / (eps * 2.0);\n    return vec2(Dx, -Dy);\n}\n \nvec2 ValueNoise(vec2 gridUV)\n{\n    uvec2 ugridUV = uvec2(gridUV);\n    uvec2 bottomLeft = uvec2(gridUV);\n    uvec2 bottomRight = uvec2(gridUV) + uvec2(1U, 0U);\n    uvec2 topLeft = uvec2(gridUV) + uvec2(0U, 1U);\n    uvec2 topRight = uvec2(gridUV) + uvec2(1U, 1U);\n    \n    vec2 bottom = mix( hash22(bottomLeft), hash22(bottomRight), fract(gridUV.x) ); \n    vec2 top = mix( hash22(topLeft), hash22(topRight), fract(gridUV.x) ); \n    vec2 val = mix( bottom, top, fract(gridUV.y) ); \n    \n    return normalize(val);\n    \n}\n\n\nmat4 saturationMatrix( float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    \n    float oneMinusSat = 1.0 - saturation;\n    \n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red+= vec3( saturation, 0, 0 );\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green += vec3( 0, saturation, 0 );\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue += vec3( 0, 0, saturation );\n    \n    return mat4( red,     0,\n                 green,   0,\n                 blue,    0,\n                 0, 0, 0, 1 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    if(mod(iTime,75.0) < 2.08)\n    {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    const float eps = 0.0001;\n    \n    float gridScale = 4.0 + hash11(floor(iTime/2.08)) * 60.;\n    \n    //vec3 col = vec3(texture(iChannel1, uv));\n    vec3 col = vec3(0.);\n    \n    vec2 noiseUV = uv;\n    //int reps = max(1,int( pow( ValueNoise(uv*4.0 + iTime).x * 2., 6.0 )  ));\n    int reps = 5;\n    for(int i = 1; i < reps; i++)\n    {\n        col += vec3(texture(iChannel1, noiseUV));\n        \n        vec2 noiseDir = CurlNoise(vec3(noiseUV * (gridScale)+vec2(cos(iTime*0.1),sin(iTime*0.4))*4.0,iTime*2.08));\n        noiseUV += noiseDir*0.001f;\n    }\n    \n    for(int i = 1; i < reps; i++)\n    {\n        col += vec3(texture(iChannel1, noiseUV));\n        \n        vec2 noiseDir = CurlNoise(vec3(noiseUV * (gridScale)+vec2(sin(iTime*0.3),cos(iTime*0.6))*4.0,iTime*2.08) );\n        noiseUV -= noiseDir*0.01f;\n    }\n    \n    col /= float(reps-1)*2. ;\n    \n    fragColor = saturationMatrix( 1.001 ) * vec4(col, 1.0);\n    \n   \n}","name":"Buffer A","description":"","type":"buffer"}]}