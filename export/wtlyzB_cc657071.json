{"ver":"0.1","info":{"id":"wtlyzB","date":"1592493352","viewed":547,"name":"Atmosphere Learning","username":"DootNoot","description":"An extension of https://www.shadertoy.com/view/XtBXDz that I made to better understand atmospheric scattering.\nI also added a second light source to act as a \"moon\"!\nI know you can use an analytical approximation for the nested loops. I'm still learning.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["test","atmosphere","rayleigh","mie","scatering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926536\n#define time (iTime/10.)\n\nstruct ray_t{\n    vec3 origin;\n    vec3 direction;\n};\nstruct sphere_t{\n    vec3 origin;\n    float radius;\n};\n   \n    \n// scattering coefficients at sea level (m)\nconst vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6); // Rayleigh \nconst vec3 betaM = vec3(21e-6); // Mie\n\n// scale height (m)\n// thickness of the atmosphere if its density were uniform\nconst float hR = 7994.0; // Rayleigh\nconst float hM = 1200.0; // Mie\n\n\nfloat rayleigh_phase_func(float mu){\n    return 3.*(1.+mu*mu)/(16.*PI);\n}\n\n//A beloved classic\nconst float g = 0.76;\nfloat henyey_greenstein_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t\t(1. - g*g)\n\t/ //---------------------------------------------\n\t\t((4. * PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\n//This function came from https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n//It seems to be an extension of the HG phase function though\n//I don't actually use it anywhere\nfloat mie_phase_func(float mu){\n    return 3.*(1.-g*g)*(1.+mu*mu)/(8.*PI)/(2.+g*g)/pow(1.+g*g-2.*g*mu,1.5);\n}\n    \n//I haven't looked into the specifics of this function yet, I just copied it straight from https://www.shadertoy.com/view/XtBXDz\nbool intersects_sphere(in ray_t ray, in sphere_t sphere, inout float t0, inout float t1){\n    vec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return false;\n\tfloat thc = sqrt(radius2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\treturn true;\n}\n\n\nconst float earth_radius = 6360e3; // (m)\nconst float atmosphere_radius = 6420e3; // (m)\n\n//control the intensity and color of the light sources\nconst vec3 sun_power = vec3(20.0);\nconst vec3 moon_power = sun_power * vec3(0.2,0.2,0.35);\n\nconst int num_samples = 14;\nconst int num_samples_light = 3; //The original shader used 8, but I think you can get away with 3 (speedup will be substantial)\n\nconst sphere_t atmosphere = sphere_t(vec3(0.),atmosphere_radius);\nconst sphere_t earth = sphere_t(vec3(0.),earth_radius);\n\nbool get_sun_light(in ray_t ray, inout float opticalDepthR, inout float opticalDepthM){\n    float t0,t1;\n    intersects_sphere(ray, atmosphere,t0,t1);\n    \n    float march_pos = 0.;\n    float march_length = t1 / float(num_samples_light);\n    \n    for(int i=0; i<num_samples_light; i++){\n        vec3 s = ray.origin + ray.direction*(march_pos + 0.5*march_length);\n        float height = length(s)-earth_radius;\n        opticalDepthR += exp(-height/hR) * march_length;\n        opticalDepthM += exp(-height/hM) * march_length;\n        \n        march_pos += march_length;\n    }\n    return true;\n}\n\nvec3 get_incident_light(in ray_t ray){\n    vec3 sun_dir = normalize(vec3(.0, sin(time),cos(time))); //I need a better positioning method than this\n    \n    \n    if(iMouse.z>0.1){sun_dir = normalize(vec3(.0, sin(iMouse.x*2.*PI/iResolution.x - 1.),cos(iMouse.x*2.*PI/iResolution.x - 1.)));}//Mouse control instead of time\n    \n    vec3 moon_dir = -sun_dir; //moon is jus opposite of sun, but it doesn't need to be\n    \n    \n    \n    float t0,t1;\n    if(!intersects_sphere(ray, atmosphere, t0, t1)){return vec3(0.); }\n    \n    float march_length = t1 / float(num_samples);\n    \n    float mu = dot(sun_dir, ray.direction);\n    float muMoon = dot(moon_dir, ray.direction);\n    \n    float phaseR = rayleigh_phase_func(mu);\n    float phaseM = henyey_greenstein_phase_func(mu);\n    float phaseMoonR = rayleigh_phase_func(muMoon);\n    float phaseMoonM = henyey_greenstein_phase_func(muMoon);\n    \n    \n    //The accumulated extincion coefficients multiplied by the path length (optical depth = \"average density\")\n    float opticalDepthR = 0.;\n    float opticalDepthM = 0.;\n    float opticalDepthMoonR = 0.;\n    float opticalDepthMoonM = 0.;\n    \n    vec3 sumR = vec3(0.);\n    vec3 sumM = vec3(0.);\n    vec3 sumMoonM = vec3(0.);\n    vec3 sumMoonR = vec3(0.);\n    \n    float march_pos = 0.;\n    \n    for(int i=0; i<num_samples; i++){\n        vec3 s = ray.origin + ray.direction*(march_pos + 0.5*march_length); //sample middle of step\n        float height = length(s) - earth_radius;\n        \n        //sample densities\n        float hr = exp(-height / hR) * march_length;\n        float hm = exp(-height / hM) * march_length;\n        //Add to optical depth of primary ray - these variables will work for both the sun and moon\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        \n        //The moon is created by literally doing everything twice with extra \"moon\" variables\n        //I'm too lazy to find a better solution\n        ray_t light_ray = ray_t(s, sun_dir);\n        ray_t moon_ray = ray_t(s,moon_dir);\n        \n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float opticalDepthLightMoonR = 0.;\n        float opticalDepthLightMoonM = 0.;\n        \n        \n        bool overground = get_sun_light(light_ray, opticalDepthLightR,  opticalDepthLightM);\n        bool overgroundMoon = get_sun_light(moon_ray, opticalDepthLightMoonR, opticalDepthLightMoonM);\n        \n        if(overground || overgroundMoon){\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) \n                + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            \n            vec3 tauMoon = betaR * (opticalDepthR + opticalDepthLightMoonR) \n                + betaM * 1.1 * (opticalDepthM + opticalDepthLightMoonM);\n\n            vec3 attenuation = exp(-tau);\n            vec3 attenuationMoon = exp(-tauMoon);\n            \n            sumR += hr * attenuation;\n            sumM += hm * attenuation;\n            sumMoonR += hr * attenuationMoon;\n            sumMoonM += hm * attenuationMoon;\n        }\n        march_pos += march_length;\n    }\n    \n    \n    //Compute the final color by adding sun and moon lighting\n    vec3 col = sun_power * (sumR * phaseR * betaR +sumM * phaseM * betaM) \n        + moon_power * (sumMoonR * phaseMoonR * betaR + sumMoonM * phaseMoonM * betaM); \n    \n    //Draw circles around the celesteal bodies\n    //I know if-statements are bad\n    if(dot(ray.direction, sun_dir) > 0.9995)col *= (1.5,1.5,1.5);\n    if(dot(ray.direction, moon_dir) > 0.9995)col *= (1.9,1.9,1.9);\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy *2. - 1.;\n    uv *= vec2(16./9.,1.); //aspec correction\n    vec3 cameraCenter = vec3(0.,earth_radius+1.,0.);\n    if(iMouse.z>0.1){cameraCenter.y += 10e3 * iMouse.y/iResolution.y;}//Mouse control camera altitude\n    float cameraLength = 2.;\n    ray_t primary_ray = ray_t(cameraCenter, normalize(vec3(uv+vec2(0.,.5),cameraLength))); //I probably need to figure out camera transforms before making this better\n    vec3 col = get_incident_light(primary_ray);\n    col = pow(col*5.0 / (col*5.0+vec3(1)),vec3(2.2)); //Gamma correction from someone's comment in the original shader\n    fragColor = vec4(col,1.);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}