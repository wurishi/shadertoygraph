{"ver":"0.1","info":{"id":"Xlc3R4","date":"1468152522","viewed":1030,"name":"fluidcube","username":"zguerrero","description":"Trying to learn raymarching and distance fields technique...\nsome code is actually just copy-pasted from iq's website http://iquilezles.org\nthanks to him for sharing all that stuff!","likes":62,"published":1,"flags":32,"usePreview":0,"tags":["procedural","ray","cube","fluid","marching","distance","field"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float v = smoothstep(0.3, 0.8, length(vec2(0.5, 0.5) - uv));\n\tvec4 baseCol = texture(iChannel0, uv);    \n    \n    fragColor = mix(baseCol, pow(baseCol, vec4(3.0)), v);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float EPSILON = 0.01;\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rotationY(vec3 pos, float angle) {\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    vec3 rotPos;\n\trotPos.x = c * pos.x + s * pos.z;\n    rotPos.y = pos.y;\n\trotPos.z = -s * pos.x + c * pos.z;\n    \n    return rotPos;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n\treturn length(max(abs(pos) - size, 0.0));\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n\treturn length(pos) - radius;\n}\n\nfloat infinitePlane(vec3 pos, float height)\n{\n    return pos.y - height;\n}\n\nvec3 repeatTime(vec3 s)\n{\n    return fract(iTime*s)*3.14159265359*2.0;\n}\n\nvec3 noise(vec3 pos, vec3 k, vec3 p, vec3 s)\n{\n    vec3 t = repeatTime(s);\n    float X1 = cos(dot(pos.yz,k.yz) + p.x - t.x);\n    float Y1 = cos(dot(pos.zx,k.zx) + p.y - t.y);\n    float Z1 = cos(dot(pos.xy,k.xy) + p.z - t.z);\n\n    float X2 = cos(dot(vec2(Y1, Z1),k.yz) + p.x + t.x);\n    float Y2 = cos(dot(vec2(Z1, X1),k.zx) + p.y + t.y);\n    float Z2 = cos(dot(vec2(X1, Y1),k.xy) + p.z + t.z);\n \treturn vec3(X2, Y2, Z2); \n}\n\nfloat distfunc(vec3 pos)\n{\n    vec3 t = repeatTime(vec3(0.4,0.0,0.0));\n    float s1 = sin(t.x)*0.5+0.5;\n    float s2 = sin(t.x - 0.4)*0.5+0.5 + 0.2;\n    \n    float attenuationY = 1.0 - clamp(pos.y*0.25,0.0,1.0);\n    float attenuationXZ = 1.0 - clamp(length(pos.xz*0.05),0.0,1.0);\n    \n    vec3 n1 = noise(pos, vec3(1.4,1.5,1.25), vec3(0.0,1.0,2.0), vec3(0.2,0.5,0.1));\n\tfloat n2 = sin(length(pos.xz) - iTime*7.0);\n    vec3 nGround = (n2+n1*0.1)*attenuationXZ*(1.0 - s2);\n    vec3 nObj = n1*0.2*(1.0 - s2)*attenuationY - vec3(0.0,s1*6.0 - 3.0,0.0);\n    \n    float ground = infinitePlane(pos+nGround, 0.0);\n    vec3 rotPos = rotationY(pos, iTime);\n    float box1 = box(rotPos + nObj, vec3(1.5,1.5,1.5));\n    float box2 = box(rotPos + nObj, vec3(1.75,1.0,1.0));\n    float box3 = box(rotPos + nObj, vec3(1.0,1.0,1.75)); \n    float box4 = min(box1, min(box2, box3));\n    float sphere1 = sphere(pos + nObj, 3.0);\n\treturn smin(ground, mix(sphere1, box4, s1*0.9), 1.0);\n}\n\nvec2 rayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int MAX_ITER = 100;\n\tconst float MAX_DIST = 40.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n\t{\n\t\tdist = distfunc(pos);\n\t\ttotalDist += dist;\n\t\tpos += dist*rayDir;\n        \n        if(dist < EPSILON || totalDist > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return vec2(dist, totalDist);\n}\n\nvec3 skyBox(vec3 rayDir, float blur)\n{\n    vec3 skyColor1 = vec3(0.5,0.5,1.0);\n    vec3 skyColor2 = vec3(1.0,1.0,1.0);\n    vec3 groundColor1 = vec3(1.0,0.4,0.3);\n    vec3 clouds1 = noise(rayDir, vec3(4.0, 6.0, 3.5),  vec3(0.0, 1.0, 2.0), vec3(0.1, 0.0, 0.0));\n    vec3 clouds2 = noise(rayDir + clouds1*0.2, vec3(2.0, 3.0, 2.5),  vec3(0.0, 1.0, 2.0), vec3(-0.1, 0.05, 0.0))*0.5+0.5;\n    float c = (clouds2.x+clouds2.y+clouds2.z)*0.05;\n    \n    vec3 skyColor = mix(skyColor2+c, skyColor1, rayDir.y);\n    float m = smoothstep(0.0, blur, (rayDir.y+0.5)+sin(rayDir.x*20.0)*0.01+sin(rayDir.z*15.0)*0.01);\n    return mix(groundColor1, skyColor, m);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 calculateNormals(vec3 pos)\n{\n\tvec2 eps = vec2(0.0, EPSILON);\n\tvec3 n = normalize(vec3(\n\tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n\tdistfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n\tdistfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n\treturn n;\n}\n\nfloat calculateAO(vec3 pos, vec3 n)\n{\n\tfloat occ = 0.0;\n\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.1*float(i);\n\t\tvec3 aopos = pos + n*hr;\n\t\tfloat dd = distfunc(aopos);\n\t\tocc += dd;\n\t}\n\treturn mix(1.0, clamp(0.0, 1.0, occ), 1.0);   \n}\n\nfloat softshadow(vec3 pos, vec3 rayDir, float mint, float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = distfunc( pos + rayDir*t );\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 lighting(vec3 pos, vec3 rayDir)\n{\n    vec3 n = calculateNormals(pos);\n    \n    vec3 ambientColor = vec3(0.0,0.0,0.0);\n    vec3 diffuseColor = vec3(0.5,0.5,0.5);\n    vec3 specColor = vec3(1.0,1.0,1.0);\n    vec3 lightColor = vec3(1.0,1.0,0.8);\n    vec3 ssColor = vec3(0.1,0.1,0.3);\n    \n\tvec3 light = vec3(0.0, 2.0, 5.0);\n\n\n\tfloat s = softshadow(pos + n*0.15, light, 0.01, 20.0);\n\tfloat ao = calculateAO(pos, n);\n\tfloat diff = max(0.0, dot(normalize(light), n))*s;\n\tfloat fresnel = (1.0 - dot(n, -rayDir));\n\tvec3 r = reflect(normalize(rayDir), n);\n    float refl = softshadow(pos + n*0.15, r, 0.01, 20.0);\n\tfloat spec = pow(max (0.0, dot (r, rayDir)), 20.0);\n\n\tvec3 sky = skyBox(r,0.1);\n\tvec3 res = diffuseColor;\n\tres *= ambientColor*ao;\n\tres += diff*lightColor*0.5;\n    res += spec*lightColor*specColor*fresnel*ao;\n    res += sky*fresnel*0.25;\n    res += sky*0.2;\n    res\t+= (1.0 - refl)*0.5*diffuseColor;\n    res += (1.0 - diff)*ssColor;\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rotationSpeed = (iMouse.x/iResolution.x)*7.0;\n    float cameraDistance = 7.0;\n    float camX = cos(rotationSpeed)*cameraDistance;\n    float camY = 2.0 + (iMouse.y/iResolution.y)*10.0;\n    float camZ = sin(rotationSpeed)*cameraDistance;                 \n    vec3 cameraOrigin = vec3(camX, camY, camZ);\n\tvec3 cameraTarget = vec3(0.0,2.0,0.0);\n    \n\tvec2 screenPos = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n\tmat3 cam = setCamera(cameraOrigin, cameraTarget, 0.0 );\n    \n    vec3 rayDir = cam* normalize( vec3(screenPos.xy,1.0) );\n    vec2 dist = rayMarch(rayDir, cameraOrigin);\n    \n    vec3 sky = skyBox(rayDir, 0.75);\n    vec3 res;\n\tif(dist.x < EPSILON)\n    {\n        vec3 pos = cameraOrigin + dist.y*rayDir;\n        vec3 no = noise(pos, vec3(0.3,0.25,0.35), vec3(0.0,1.0,2.0), vec3(0.2,0.0,0.0));\n        float fogNoise = 1.0 + no.x*no.y*no.z;\n        float fog = clamp((dist.y - 18.0)*0.05, 0.0, 1.0);\n        float fogY = 1.0 - clamp(pos.y*0.5, 0.0, 1.0);\n        res = mix(lighting(pos, rayDir), sky, clamp(fogNoise*(fog+fogY*0.75), 0.0, 1.0));\n    }\n    else\n    {\n        res = sky;       \n    }\n\n\tfragColor = vec4(res, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}