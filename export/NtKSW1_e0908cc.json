{"ver":"0.1","info":{"id":"NtKSW1","date":"1640965322","viewed":151,"name":"Cathedral of Choices","username":"pticawr","description":"Wandering through a hyperbolic world of rooms and doorways","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","rooms","doorways"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst int MAX_ROOM_DEPTH = 12;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 40.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\nconst float DOOR_WIDTH = 1.5;\nconst float DOOR_HEIGHT = 0.8 + DOOR_WIDTH;\nconst float STEP_HEIGHT = 0.2;\nconst float ROOM_TIME = 6.0;\n\nstruct SceneD\n{\n    float d;\n    int rd;\n    int rn;\n    float ra;\n    vec3 rp;\n};\n\nfloat time()\n{\n    return mod(iTime, ROOM_TIME) / ROOM_TIME;\n}\n\nint timeDepth()\n{\n    return int(iTime / ROOM_TIME);\n}\n\nint roomDoorsByDepth(int depth)\n{\n    return 5 + int(3.0 + 3.0 * cos(float(depth) * 1237.1));\n}\n\nint nextDoorByDepth(int depth, int doors)\n{\n    return 1 + int(float(doors - 1) * 0.5 * (1.0 + sin(float(depth + doors) * 1343.5)));\n}\n\nfloat roomRadius(int n)\n{\n    return 1.4 * DOOR_WIDTH * float(n) * 0.5 / PI;\n}\n\nfloat doorAngle(int n)\n{\n    return 2.0 * PI / float(n);\n}\n\nfloat centerDist(int n1, int n2)\n{\n    return roomRadius(n1) * cos(doorAngle(n1) / 2.0) + roomRadius(n2) * cos(doorAngle(n2) / 2.0);\n}\n\nfloat nextDoorAngle()\n{\n    int doors = roomDoorsByDepth(timeDepth());\n    return doorAngle(doors) * float(nextDoorByDepth(timeDepth(), doors));\n}\n\nSceneD roomSDF(vec2 ey_, vec3 p_, float ra_, int rd_, int en_, int n_)\n{\n    vec2 ey = ey_;\n    int rdepth = rd_;\n    vec3 p = p_;\n    float ra = ra_;\n    int en = en_;\n    int n = n_;\n    \n    for (int r = 0; true; ++r)\n    {\n        float lenpxz = length(p.xz);\n        float pa = atan(p.z, p.x);\n        float ea = atan(-1.0, 0.0);\n        float da = doorAngle(n);\n        float rr = roomRadius(n);\n        float a = mod(2.0 * PI + pa - ea + da * 0.5, da) - da * 0.5;\n\n        if (r < MAX_ROOM_DEPTH && length(p.xz) >= rr)\n        {\n            float cta = dot(ey,ey) + dot(p.xz,p.xz) - 2.0 * dot(ey,p.xz);\n            float ctb = 2.0 * (dot(ey,p.xz) - dot(ey,ey));\n            float ctc = dot(ey,ey) - rr * rr;\n            if (ctb * ctb >= 4.0 * cta * ctc)\n            {\n                float ct = (-ctb + sqrt(ctb * ctb - 4.0 * cta * ctc)) / (2.0 * cta);\n                vec2 ctv = vec2(ey * (1.0-ct) + p.xz * ct);\n\n                int dn = (int((2.0 * PI + atan(ctv.y, ctv.x) - ea + da * 0.5) / da)) % n;\n                a = mod(4.0 * PI + pa - ea - float(dn) * da, 2.0 * PI);\n\n                vec2 urcv = normalize(vec2(p.x * cos(a) + p.z * sin(a), p.z * cos(a) - p.x * sin(a)));\n                int ndd = nextDoorByDepth(rdepth, n);\n                rdepth += 1;\n                int nextn = dn == ndd ? roomDoorsByDepth(rdepth) : 5 + ((23 * dn) % 7);\n                vec2 rcv = (centerDist(n, nextn) + 0.0) * urcv;\n\n                float vra = mod(PI + float(dn) * da, 2.0 * PI);\n                p = vec3(p.x - rcv.x, (dn == 0) ? p.y + STEP_HEIGHT : p.y - STEP_HEIGHT, p.z - rcv.y);\n                p = vec3(p.x * cos(vra) + p.z * sin(vra), p.y, -p.x * sin(vra) + p.z * cos(vra));\n                ey = ey - rcv;\n                ey = vec2(ey.x * cos(vra) + ey.y * sin(vra), -ey.x * sin(vra) + ey.y * cos(vra));\n                ra += vra;\n                en = n;\n                n = nextn;\n                continue;\n            }\n        }\n\n        float d = max(lenpxz - rr, rr - 0.2 - lenpxz);\n        float dw2 = DOOR_WIDTH * 0.5;\n        float ad = abs(lenpxz * sin(a));\n        d = max(d, -min(max(ad - dw2, p.y - DOOR_HEIGHT + dw2),\n            length(vec2(ad, p.y - DOOR_HEIGHT + dw2)) - dw2));\n        d = min(d, max(roomRadius(n) - 0.2 - distance(p, vec3(0.0,DOOR_HEIGHT + 0.2,0.0)), DOOR_HEIGHT + 0.2 - p.y));\n        d = min(d, max(max(max(p.y - STEP_HEIGHT, lenpxz - rr - 0.1),\n            -max(-p.y, lenpxz - rr)),\n            -(max(-STEP_HEIGHT-p.y, distance(vec2(0.0, -1.0) * centerDist(en, n), p.xz) - roomRadius(en)))));\n        return SceneD(d,rdepth,n,ra,p);\n    }\n}\n\nSceneD sceneSDF(vec3 e, vec3 p) {\n    return roomSDF(e.xz, p, 0.0, timeDepth(), 8, roomDoorsByDepth(timeDepth()));\n}\n\n// ##################################################\n\nvec3 colFromPoint(vec3 p, SceneD sd)\n{\n    float cd = length(sd.rp.xz);\n    if (abs(sd.rp.y) <= EPSILON)\n    {\n        return vec3(\n            (0.5 + float(sd.rn % 3) * 0.2) + 0.2 * (sin(cd * 53.0) * sin(sd.rp.x * 83.0) * sin(sd.rp.z * 37.0)),\n            0.1,\n            (0.5 + float((sd.rn + sd.rd) / 3 % 3) * 0.2) + 0.2 * (sin(cd * 59.0) * sin(sd.rp.x * 41.0) * sin(sd.rp.z * 79.0)));\n    }\n    else\n    {\n        vec3 rpm1 = vec3(0.5 * sd.rp.xyz + 5.0*mod(sd.rp.yzx, 0.1) * cos(31.9 * sd.rp.zxy));\n        vec3 rpm2 = vec3(0.5 * sd.rp.xzy + 3.0*mod(sd.rp.zyx, 0.166) * cos(22.1 * sd.rp.yxz));\n        return vec3(\n            0.4 + 0.05 * (sin((rpm1.x + rpm1.z) * 71.0) + sin((rpm1.y + rpm1.x) * 87.0)),\n            0.4 + 0.05 * (sin((rpm1.x + rpm2.z) * 71.0) + sin((rpm1.y + rpm1.x) * 87.0)),\n            0.6 + 0.1 * (sin((rpm2.x + rpm2.z) * 93.0) + sin((rpm2.y + rpm2.x) * 117.0)));\n    }\n    return vec3(0.5);\n}\n\n// ##################################################\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nSceneD shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        SceneD sd = sceneSDF(eye, eye + depth * marchingDirection);\n        if (sd.d < EPSILON) {\n\t\t\treturn SceneD(depth, sd.rd, sd.rn, sd.ra, sd.rp);\n        }\n        depth += sd.d;\n        if (depth >= end) {\n            break;\n        }\n    }\n    return SceneD(end, MAX_ROOM_DEPTH + 1, 2, 0.0, vec3(0.0));\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size * 0.5;\n    float z = size.y / tan(radians(fieldOfView) * 0.5);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 e, vec3 p) {\n    return normalize(vec3(\n        sceneSDF(e,vec3(p.x + EPSILON, p.y, p.z)).d - sceneSDF(e,vec3(p.x - EPSILON, p.y, p.z)).d,\n        sceneSDF(e,vec3(p.x, p.y + EPSILON, p.z)).d - sceneSDF(e,vec3(p.x, p.y - EPSILON, p.z)).d,\n        sceneSDF(e,vec3(p.x, p.y, p.z  + EPSILON)).d - sceneSDF(e,vec3(p.x, p.y, p.z - EPSILON)).d\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, float ra, vec3 rp, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(eye,p);\n    vec3 rpr = vec3(rp.x * cos(ra) - rp.z * sin(ra), rp.y, rp.x * sin(ra) + rp.z * cos(ra));\n    vec3 L = normalize(lightPos - rpr);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, float ra, vec3 rp, vec3 eye) {\n    const vec3 ambientLight = 0.8 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0.0,\n                          DOOR_HEIGHT + 0.1,\n                          0.0);\n    vec3 light1Intensity = vec3(0.9, 0.9, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, ra, rp, eye,\n                                  light1Pos,\n                                  light1Intensity);\n                                  \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// ##################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(90.0, iResolution.xy, fragCoord);\n    float t = 0.5 + 0.5 * sin(PI * time() - 0.5 * PI);\n    int doors = roomDoorsByDepth(timeDepth());\n    float rr = roomRadius(doors);\n    int ndoors = roomDoorsByDepth(timeDepth() + 1);\n    float nrr = centerDist(doors, ndoors) - roomRadius(ndoors);\n    float da = PI - nextDoorAngle();\n    float h = 0.8 + 0.01 * abs(sin(iTime * 5.0)) + STEP_HEIGHT * time();\n    vec3 tcv = vec3(sin((PI - da) * t), 0.0, -cos((PI - da) * t));\n    vec3 eye = mix(rr,nrr,time()) * tcv * (1.0 - sqrt(1.0 - 4.0*(0.5-t)*(0.5-t))) + vec3(0.0, h, 0.0);\n    vec3 eyeDir = normalize(vec3(sin(t * da), -0.1 + 0.10 * sin(2.0 * PI * time()), cos(t * da)));\n    \n    mat4 viewToWorld = viewMatrix(eye, eye + eyeDir, vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    SceneD sd = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (sd.d > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.0);\n    }\n    else\n    {\n        vec3 p = eye + sd.d * worldDir;\n\n        vec3 K_a = vec3(0.2, 0.2, 0.2);\n        vec3 K_d = colFromPoint(p, sd);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, sd.ra, sd.rp, eye);\n        \n        color = mix(color, vec3(0.0), sd.d / float(MAX_DIST));\n\n        fragColor = vec4(color, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}