{"ver":"0.1","info":{"id":"NsdSWS","date":"1633863912","viewed":97,"name":"Lapin crétin running higher FPS","username":"moiup","description":"Lapin crétin running animation. One can choose the Tracing algorithm. On the function SphereTrace (line 753), uncomment the wanted line and comment the unwanted line to render with a different method.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["animation","spheretracing","fps","running","lapincrtin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Common\nconst float INFINITY = 1e32;\n\nconst float DEG_TO_RAD = 0.0174533;\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed) {\n  return fract(sin(seed) * 43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed, in vec3 nor) {\n  float u = Hash(78.233 + seed);\n  float v = Hash(10.873 + seed);\n\n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a = 6.2831853 * v;\n  u = 2. * u - 1.;\n  return normalize(nor + vec3(sqrt(1. - u * u) * vec2(cos(a), sin(a)), u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p, out vec3 ro, out vec3 rd) {\n  float a = 3. * 3.14 * m.x;\n  float le = 3.8;\n\n  ro = vec3(20., 0., 5.);\n  ro *= rotate_z(3. * 3.14 * m.x);\n\n  vec3 ta = vec3(0., 0., 1.);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0., 0., 1.)));\n  vec3 vv = normalize(cross(uu, ww));\n  rd = normalize(p.x * uu + p.y * vv + le * ww);\n}\n\n// Main\n\nconst int Steps = 1000;\nconst float Epsilon = .05;// Marching epsilon\nconst float T = .5;\n\nconst float rA = 10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB = 40.;\n\n// Transforms\nvec3 rotateX(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca * p.x + sa * p.y, -sa * p.x + ca * p.y, p.z);\n}\n\nvec3 translateX(vec3 p, float tx) {\n  return vec3(p.x - tx, p.yz);\n}\n\nvec3 translateY(vec3 p, float ty) {\n  return vec3(p.x, p.y - ty, p.z);\n}\n\nvec3 translateZ(vec3 p, float tz) {\n  return vec3(p.xy, p.z - tz);\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nvec3 scaleX(vec3 p, float sx) {\n  return vec3(p.x / sx, p.yz);\n}\n\nvec3 scaleY(vec3 p, float sy) {\n  return vec3(p.x, p.y / sy, p.z);\n}\n\nvec3 scaleZ(vec3 p, float sz) {\n  return vec3(p.xy, p.z / sz);\n}\n\nvec3 scaleXYZ(vec3 p, vec3 s) {\n  return p / s;\n}\n\nvec3 scale(vec3 p, float s) {\n  return p / s;\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x, float R) {\n  float u = clamp(x / R, 0., 1.);\n  float v = (1. - u * u);\n  return v * v * v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nvec4 point(vec3 p, vec3 c, float e, float R, vec3 color) {\n  return vec4(color, e * falloff(length(p - c), R));\n}\n\n// Disk\n// p : point\n// c : center of disk\n// r : radius of disk\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 disk(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  vec3 cp = p - c;\n  vec3 u = vec3(1., 0., 0.);\n  float h = dot(cp, u);\n  h = h * h;\n  float d = dot(cp, cp);\n  float y = d - h * h;\n  if(y < r * r) {\n    return vec4(color, e * falloff(abs(h), R));\n  }\n  y = r - sqrt(y);\n  return vec4(color, e * falloff(sqrt(y * y + h * h), R));\n}\n\n// Circle\n// p : point\n// c : center of circle\n// r : radius of the circle\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 circle(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  vec3 n = p - c;\n  vec3 u = vec3(1., 0., 0.);\n  float h = dot(n, u);\n  float d = dot(n, n);\n  float y = d - h * h;\n  y = r - sqrt(y);\n  return vec4(color, e * falloff(sqrt(y * y + h * h), R));\n}\n\n// Segment\n// p : point\n// a : starting coordinates\n// b : ending coordinates\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 segment(vec3 p, vec3 a, vec3 b, float e, float R, vec3 color) {\n  vec3 u = (b - a) / length(b - a);\n  float l = dot(p - a, u);\n\n  if(l < 0.0) {\n    float dist = length(p - a);\n    return vec4(color, e * falloff(dist, R));\n  }\n\n  if(l < length(b - a)) {\n    float left = dot(p - a, p - a);\n    float right = dot(p - a, u) * dot(p - a, u);\n\n    return vec4(color, e * falloff(sqrt(left - right), R));\n  }\n\n  return vec4(color, e * falloff(length(p - b), R));\n}\n\nfloat box_bis(float px, float ax, float bx) {\n  if(px < ax) {\n    return ax - px;\n  }\n\n  if(px > bx) {\n    return px - bx;\n  }\n\n  return 0.0;\n}\n\n// Box\n// p : point\n// a : coordinates of the cube\n// b : coordinate of the cube\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 box(vec3 p, vec3 a, vec3 b, float e, float R, vec3 color) {\n  float d1 = box_bis(p.x, a.x, b.x);\n  float d2 = box_bis(p.y, a.y, b.y);\n  float d3 = box_bis(p.z, a.z, b.z);\n\n  return vec4(color, e * falloff(sqrt(d1 * d1 + d2 * d2 + d3 * d3), R));\n}\n\n// Sphere\n// p : point\n// c : center of sphere\n// r : radius of the sphere\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 sphere(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  return vec4(color, e * falloff(length(p - c) - r, R));\n}\n\n// Hemisphere\n// p : point\n// c : center of hemisphere\n// r : radius of the hemisphere\n// e : energy associated to skeleton\n// R : radius\n// color : color vector\nvec4 hemisphere(vec3 p, vec3 c, float r, float e, float R, vec3 color) {\n  vec3 n = p - c;\n  vec3 u = vec3(1.0, 0.0, 0.0);\n  if(dot(n, u) < 0.0) {\n    return disk(p, c, r, e, R, color);\n  }\n  return sphere(p, c, r, e, R, color);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nvec4 Blend(vec4 a, vec4 b) {\n  float denom = a.w + b.w;\n  vec3 color;\n  if(denom == 0.0){\n    color = (a.rgb +  b.rgb) / 2.0;\n  }\n  else {\n    color = ( a.w * a.rgb + b.w * b.rgb) / (a.w + b.w); \n  }\n\n  return vec4(color, denom);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Union(vec4 a, vec4 b) {\n  float v = max(a.w, b.w);\n  if(v == b.w){\n    return b;\n  }\n  return a;\n}\n\n// Intersection\n// a : filed function of left sub-tree\n// b : field function of right sub-tree\nvec4 Intersection(vec4 a, vec4 b) {\n  float v = min(a.w, b.w);\n  if(v == b.w){\n    return b;\n  }\n  return a;\n}\n\n// Difference\n// a : filed function of left sub-tree\n// b : field function of right sub-tree\nvec4 Difference(vec4 a, vec4 b) {\n  float comp = 2.0 * T - b.w;\n  float v = min(a.w, comp);\n\n  if(v == a.w){\n    return a;\n  }\n\n  return vec4(a.rgb, comp);\n}\n\n/**********************************/\n/* OBJECTS                        */\n/**********************************/\n// Rabbit ear\nvec4 lapin_oreille(vec3 p){\n    vec4 v;\n\n    v = Union(\n      disk(scaleXYZ(p, vec3(0.6, 0.7, 1.8)), vec3(0, 0, 0), 1.0, 1.0, 0.6, vec3(1, 1, 1)),\n      disk(translateX(scaleXYZ(p, vec3(0.5, 0.5, 1.6)), 0.2), vec3(0, 0, 0), 1.0, 1.0, 0.6, vec3(0.94, 0.80, 0.73))\n    );\n\n    return v;\n}\n\n// Rabbit eye\nvec4 lapin_oeil(vec3 p){\n    vec4 v;\n\n    v = Union(\n      disk(translateX(scale(p, 0.4), -0.3), vec3(0, 0, 0), 1.3, 1.0, 1.0, vec3(0.94, 0.80, 0.73)),\n      sphere(translateX(p, 0.3), vec3(0, 0, 0), 0.1, 1.0, 1.0, vec3(1, 1, 1))\n    );\n\n    v = Union(\n      v,\n      hemisphere(translateX(scale(p, 0.6), 1.0), vec3(0, 0, 0), 0.1, 1.0, 1.0, vec3(0, 0, 0))\n    );\n\n    return v;\n}\n\n// Rabbit mouth\nvec4 lapin_bouche(vec3 p){\n  vec4 v;\n  vec3 p_levre = scaleXYZ(translate(p, vec3(-0.1, 0, -1.0)), vec3(0.6, 0.45, 0.45));\n\n  v = Difference(\n    circle(p_levre, vec3(0, 0, 0), 3.0, 1.0, 0.5, vec3(0, 0, 0)),\n    box(scaleXYZ(translateZ(p_levre, -0.8), vec3(1.0, 3.0, 2.38)), vec3(-1, -1, -1), vec3(1, 1, 1), 1.0, 1.0, vec3(1.0, 1.0, 1.0))\n  );\n\n  v = Union(\n    v,\n    hemisphere(translate(p, vec3(-1.6, 0, 0)), vec3(0, 0, 0), 1.2, 1.0, 1.0, vec3(0.94, 0.80, 0.73))\n  );\n\n  return v;\n}\n\n// Rabbit head\nvec4 lapin_tete(vec3 p){\n    vec4 v;\n\n    v = sphere(scaleZ(p, 1.3), vec3(0, 0, 0), 2.0, 1.0, 1.0, vec3(1, 1, 1));\n\n    v = Blend(\n      v,\n      lapin_oreille(\n          rotateX(\n              translate(p, vec3(0, -1.7, -4.25)),\n              20.0 * DEG_TO_RAD\n              )\n          )\n  );\n\n  v = Blend(\n      v,\n      lapin_oreille(\n          rotateX(\n              translate(p, vec3(0, 1.7, -4.25)),\n              -20.0 * DEG_TO_RAD\n              )\n          )\n  );\n\n  v = Union(\n      v,\n      lapin_oeil(\n          translate(p, vec3(1.8, -1.3, -1.0))\n        )\n    );\n\n    v = Union(\n      v,\n      lapin_oeil(\n          translate(p, vec3(1.8, 1.3, -1.0))\n        )\n    );\n\n    v = Union(\n      v,\n      lapin_bouche(translate(p, vec3(2.5, 0, 0.5)))\n    );\n\n    return v;\n}\n\n// Rabbit belly\nvec4 lapin_ventre(vec3 p){\n    vec4 v;\n\n    v = Union(\n      sphere(scaleZ(p, 0.9), vec3(0, 0, 0), 2.0, 1.5, 1.0, vec3(1.0, 1.0, 1.0)),\n      sphere(translate(scaleXYZ(p, vec3(1.0, 1.1, 0.9)), vec3(1.1, 0, 0.11)), vec3(0, 0, 0), 1.1, 1.5, 1.0, vec3(0.94, 0.80, 0.73))\n    );\n\n    return v;\n}\n\n// Rabbit leg\nvec4 lapin_jambe(vec3 p){\n    vec4 v;\n\n    v = box(\n        p,\n        vec3(-0.5, -0.5, -0.5),\n        vec3(0.5, 0.5, 0.5),\n        1.3,\n        1.0,\n        vec3(1, 1, 1)\n    );\n\n    return v;\n}\n\n// Rabbit finger\nvec4 lapin_doigt(vec3 p){\n    vec4 v;\n\n    v = box(\n        scaleXYZ(p, vec3(0.25, 0.6, 0.4)),\n        vec3(-0.3, -0.3, -0.3),\n        vec3(0.3, 0.3, 0.3),\n        2.0,\n        1.7,\n        vec3(1, 1, 1)\n    );\n\n    return v;\n}\n\n// Rabbit hand\nvec4 lapin_main(vec3 p, float lr){\n    vec4 v;\n\n    p = scaleY(p, lr);\n    p = translateY(p, 2.0);\n\n    v = segment(\n        p,\n        vec3(0, -2.0, 0),\n        vec3(0, 2.0, 0),\n        3.0,\n        1.25,\n        vec3(1, 1, 1)\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            rotateZ(translate(p, vec3(0.8, 2.5, 0.0)), -30.0 * DEG_TO_RAD)\n        )\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            scaleXYZ(rotateZ(translate(p, vec3(0.4, 3.0, 0.0)), 0.0 * DEG_TO_RAD), vec3(0.7, 1.0, 1.0))\n        )\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            scaleXYZ(rotateZ(translate(p, vec3(-0.1, 3.0, 0.0)), 0.0 * DEG_TO_RAD), vec3(0.7, 1.0, 1.0))\n        )\n    );\n\n    v = Blend(\n        v,\n        lapin_doigt(\n            scaleXYZ(rotateZ(translate(p, vec3(-0.6, 2.8, 0.0)), 10.0 * DEG_TO_RAD), vec3(0.7, 1.0, 1.0))\n        )\n    );\n\n    return v;\n}\n\n\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p) {\n  vec4 v;\n    vec3 p_tete;\n    vec3 p_main;\n\n  p.z = -p.z;\n\n  p = scale(p, 0.6);\n\n    p_tete = translateZ(p, -3.0);\n\n    v = lapin_tete(rotateY(p_tete, sin(iTime * 7.0) * 10.0 * DEG_TO_RAD));\n\n    v = Blend(\n        v,\n        lapin_ventre(translateZ(p, 1.5))\n    );\n\n    // JAMBES\n    v = Blend(\n        v,\n        lapin_jambe(translate(rotateY(p, sin(iTime * 7.0) * 0.4), vec3(0, -1.1, 3.5)))\n    );\n\n    v = Blend(\n        v,\n        lapin_jambe(translate(rotateY(p, sin(iTime * 7.0) * -0.4), vec3(0, 1.1, 3.5)))\n    );\n\n    p_main = scaleXYZ(p, vec3(0.7, 1.0, 0.8));\n    v = Blend(\n        v,\n        lapin_main(rotateX(translateY(rotateY(p_main, sin(iTime * 7.0)), 1.0), -40.0 * DEG_TO_RAD), 1.0)\n    );\n\n    v = Blend(\n        v,\n        lapin_main(rotateX(translateY(rotateY(p_main, sin(iTime * -7.0)), -1.0), 40.0 * DEG_TO_RAD), -1.0)\n    );\n\n\n  return vec4(v.rgb, v.w - T);\n}\n\nfloat F(vec3 p){\n  return -Object(p).a;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p, out vec3 obj_colors) {\n  float eps = .0001;\n  vec3 n;\n  vec4 v = Object(p);\n  n.x = Object(vec3(p.x + eps, p.y, p.z)).w - v.w;\n  n.y = Object(vec3(p.x, p.y + eps, p.z)).w - v.w;\n  n.z = Object(vec3(p.x, p.y, p.z + eps)).w - v.w;\n  obj_colors = v.rgb;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  h = false;\n  const int nb_iter = 500;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for(int i = 0; i < nb_iter; i++) {\n    s = i;\n    vec3 p = o + t * u;\n    vec4 v = Object(p);\n    // Hit object\n    if(v.w > 0.) {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += Epsilon;\n    // Escape marched far away\n    if(t > rB) {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTraceOriginal(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  h = false;\n  int nb_iter = 180;\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n\n  for(int i = 0; i < nb_iter; i++) {\n    s = i;\n    vec3 p = o + t * u; // <=> d * t + o    (Keinert and al.)\n    vec4 v = Object(p); // <=> f(d * t + o) (Keinert and al.)\n    // Hit object\n    if(v.a > 0.) {\n      s = i;\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += max(Epsilon, abs(v.a) / 6.);\n    // Escape marched far away\n    if(t > rB) {\n      break;\n    }\n  }\n  return t;\n}\n\n// B. Keinert et al. Enhanced sphere tracing. In Proceedings of Smart Tools & Apps for Graphics, Eurographics Association, 2014.\nfloat SphereTraceOverRelaxing(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  h = false;\n  int i;\n  float omega = 1.25;\n  float lmbd = 4.0;\n  float coeff = omega / lmbd;\n  float delta_i = 0.0;\n  float f_pi_minus = 0.0;\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n  const int nb_iter = 100;\n\n\n  for( i = 0; i < nb_iter; i++) {\n    s = i;\n    vec3 p = o + t * u; // <=> d * t + o    (Keinert and al.)\n    float f_pi = F(p); // <=> f(d * t + o) (Keinert and al.)\n    \n    // Hit object\n    if(f_pi < 0.0) {\n      h = true;\n      return t;\n    }\n\n    f_pi = abs(f_pi);\n\n    if((f_pi + f_pi_minus)/lmbd < delta_i){\n      delta_i = -omega * delta_i;\n      omega = 1.0;\n      coeff = omega / lmbd;\n      \n      t += delta_i;\n      while(i < nb_iter) {\n        s = i;\n        p = o + t * u; // <=> d * t + o    (Keinert and al.)\n        f_pi = F(p); // <=> f(d * t + o) (Keinert and al.)\n        \n        // Hit object\n        if(f_pi < 0.0) {\n          h = true;\n          return t;\n        }\n\n        delta_i = max(Epsilon, coeff * f_pi);\n\n        // Move along ray\n        t += delta_i;\n        \n        i++;\n      }\n      return INFINITY;\n    }\n\n    delta_i = max(Epsilon, coeff * f_pi);\n    \n\n    f_pi_minus = f_pi;\n\n\n    // Move along ray\n    t += delta_i;\n  }\n\n  return INFINITY;\n}\n\n// B. Keinert et al. Enhanced sphere tracing. In Proceedings of Smart Tools & Apps for Graphics, Eurographics Association, 2014.\nfloat SphereTraceScreenSpace(vec3 o, vec3 u, float rB, out bool h, out int s) {\n  int i;\n  float pixelRadius = 0.001;\n  float omega = 1.4;\n  float lmbd = 4.0;\n  float coeff = omega / lmbd;\n  float delta_i = 0.0;\n  float f_pi_minus = 0.0;\n  float candidate_error = INFINITY;\n  float candidate_t = rB;\n  float functionSign = F(o) < 0.0 ? -1.0 : 1.0;\n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n  int nb_iter = 100;\n  float f;\n  float error;\n  h = false;\n\n\n  for( i = 0; i < nb_iter; i++) {\n    s = i;\n    f = F(u * t + o);\n    float signedRadius = functionSign * f;\n    float f_pi = abs(signedRadius);\n  \n    bool sorFail = omega > 1.0 && (f_pi + f_pi_minus < delta_i);\n    if(sorFail){\n      delta_i -= coeff * delta_i;\n      omega = 1.0;\n      lmbd = 40.0;\n      coeff = omega / lmbd;\n    }\n    else {\n      // delta_i = max(Epsilon * signedRadius, signedRadius * omega);\n      delta_i = max(Epsilon * signedRadius, signedRadius * coeff);\n      // delta_i = signedRadius * omega;\n    }\n\n    f_pi_minus = f_pi;\n    \n    error = f_pi / t;\n\n    if(!sorFail && error < candidate_error){\n      candidate_t = t;\n      candidate_error = error;\n    }\n\n    if(!sorFail && error < pixelRadius || t > rB){\n      break;\n    }\n\n    // Move along ray\n    t += delta_i;\n  }\n\n  if(t > rB && candidate_error > pixelRadius || i == nb_iter){\n    return INFINITY;\n  }\n\n  h = true;\n  return candidate_t;\n}\n\n\n\nfloat SphereTrace(vec3 o, vec3 u, float rB, out bool h, out int s){\n  // return Trace(o, u, rB, h, s);\n  // return SphereTraceOriginal(o, u, rB, h, s);\n  return SphereTraceOverRelaxing(o, u, rB, h, s);\n  // return SphereTraceScreenSpace(o, u, rB, h, s);\n}\n\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p, vec3 n, int a) {\n  if(a == 0) {\n    return 1.;\n  }\n\n  float ao = 0.;\n\n  for(int i = 0; i < a; i++) {\n    vec3 d = Cosine(581.123 * float(i), n);\n\n    int s;\n    bool h;\n    float t = SphereTrace(p, d, 10., h, s);\n    if(!h) {\n      ao += 1.;\n    } else if(t > 5.) {\n      ao += 1.;\n    }\n  }\n\n  ao /= float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd) {\n  return mix(vec3(.652, .451, .995), vec3(.552, .897, .995), rd.z * .5 + .5);\n}\n\nfloat Light(vec3 p, vec3 n) {\n  // point light\n  const vec3 lp = vec3(5., 10., 25.);\n\n  vec3 l = normalize(lp - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = pow(.5 * (1. + dot(n, l)), 2.);\n\n  bool h;\n  int s;\n  // float t = SphereTrace(p + .1 * n, l, 100., h, s);\n  if(!h) {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p, vec3 n, int a) {\n  if(a == 0)\n    return 1.;\n\n  // point light\n  const vec3 lp = vec3(5., 10., 25.);\n\n  vec3 l = normalize(lp - p);\n\n  float lo = 0.;\n\n  for(int i = 0; i < a; i++) {\n    vec3 d = Cosine(581.123 * float(i), n);\n    d = normalize(l + d * .15);\n    int s;\n    bool h;\n    float t = SphereTrace(p, d, 10., h, s);\n    if(!h) {\n      lo += 1.;\n    } else if(t > 100.) {\n      lo += 1.;\n    }\n  }\n\n  lo /= float(a);\n  return lo;\n\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n) {\n  vec3 c = .25 + .25 * background(n);\n  c += .15 * AmbientOcclusion(p + .1 * n, n, 0) * vec3(1., 1., 1.);\n  c += .35 * Light(p, n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n) {\n  float t = float(n) / (float(Steps - 1));\n  return .5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip) {\n  // Pixel coordinates\n  vec2 p = (-iResolution.xy + 2. * pixel) / iResolution.y;\n  if(pip == true) {\n    const float fraction = 1. / 4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x < iResolution.x * fraction) && (pixel.y < iResolution.y * fraction)) {\n      p = (-iResolution.xy * fraction + 2. * pixel) / (iResolution.y * fraction);\n      pip = true;\n    } else {\n      pip = false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy) {\n  // Picture in picture on\n  bool pip = true;\n\n  // Pixel\n  vec2 pixel = Pip(pxy, pip);\n\n  // Mouse\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  // Camera\n  vec3 ro, rd;\n  Ray(m, pixel, ro, rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100., hit, s);\n\n  // Position\n  vec3 pt = ro + t * rd;\n\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if(hit) {\n    // Compute normal\n    vec3 obj_colors;\n    vec3 n = ObjectNormal(pt, obj_colors);\n\n    // Shade object with light\n    rgb = Shade(pt, n) * obj_colors;\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip == true) {\n    rgb = ShadeSteps(s);\n  }\n\n  color = vec4(rgb, 1.);\n}\n","name":"Image","description":"","type":"image"}]}