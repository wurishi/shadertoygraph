{"ver":"0.1","info":{"id":"stKfzW","date":"1664198136","viewed":155,"name":"render texture text","username":"jt","description":"Renders text with alpha & border given by a texture of (ascii-)codes into a given rectangle.\nIntended mostly for environments outside of shadertoy, where custom textures can be supplied.\nUses distance thx to https://www.shadertoy.com/view/MsSfzc by Klems.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["text","texture","distance","ascii","render","chars","char"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/stKfzW render texture text by jt\n\n// Font generator by otaviogood https://github.com/otaviogood/shader_fontgen/blob/master/codepage_gen.html\n// Text rendering originally from https://www.shadertoy.com/view/MsSfzc [SH17C] Anisotropic Filtering by Klems\n// Rewritten for readability & usability.\n// Renders (alpha & border) a string of text given by an array of (ascii-)code into a given rectangle.\n\n// This work is licenced under a CC0 1.0 Universal License\n// https://creativecommons.org/publicdomain/zero/1.0/\n\n// tags: ascii, char, chars, distance, render, texture, text\n\n// (UPPERCASE and LOWERCASE would be more readable but bloat the string definition)\n#define UC 64\n#define LC 96\n\n#define TEXT_COORDS /*enable, if the texture is not already flipped*/\n\nvec4 text(vec2 pixelpos, vec2 start, vec2 end)\n{\n    pixelpos = (pixelpos - start) / (end - start);\n#ifdef TEXT_COORDS\n    pixelpos.y = 1.0 - pixelpos.y; // mirror globally: text-coordinate system starts in upper left corner\n#endif\n    pixelpos *= vec2(iChannelResolution[1]);\n\n    float alias = length(fwidth(pixelpos)) * 0.5; // (I don't understand this line)\n    ivec2 tile = ivec2(floor(pixelpos));\n    vec2 local = fract(pixelpos);\n#ifdef TEXT_COORDS\n    local.y = 1.0 - local.y; // unmirror locally: text-coordinate system starts in upper left corner - but letters in lower left corner\n#endif\n    //local.x = (local.x * 0.5 + 0.25); // skip gaps between chars\n    //local.y = (local.y * 0.75 + 0.125); // skip gaps between chars\n    vec3 color = vec3(0);\n    float opacity = 0.0;\n    if(tile.x >= 0 && tile.x < int(iChannelResolution[1].x)\n    && tile.y >= 0 && tile.y < int(iChannelResolution[1].y))\n    {\n        int char = int(255.0 * texelFetch(iChannel1, tile, 0).x);\n        int column = char & 0xf;\n        int row = 15 - (char >> 4);\n        float dist = texture(iChannel0, (vec2(column, row) + local) / 16.0).w;\n        float border = 0.05; // must be a positive value\n        opacity = smoothstep(+alias,-alias, dist - 0.5 - border);\n        color += smoothstep(+alias,-alias, dist - 0.5);\n    }\n\n    return vec4(color, opacity);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 color = vec3(0, 0, 0.5); // background\n/*\n    {\n        vec4 string = text(uv, vec2(0), vec2(1));\n        color = mix(color, string.rgb, string.a);\n    }\n*/\n    {\n        vec4 string = text(uv, vec2(0.0, 0.0), vec2(0.2, 0.3));\n        color = mix(color, string.rgb, string.a);\n    }\n\n    {\n        vec4 string = text(uv, vec2(0.2, 0.3), vec2(1.0, 1.0));\n        color = mix(color, string.rgb, string.a);\n    }\n\n    color = sqrt(color); // simple gamme\n    //color = pow(color, vec3(1.0 / 2.2)); // better gamma\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}