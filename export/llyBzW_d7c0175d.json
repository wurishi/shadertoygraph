{"ver":"0.1","info":{"id":"llyBzW","date":"1541955107","viewed":309,"name":"Local Binary Patterns","username":"snipstruis","description":"Local Binary Patterns, visualized as rgb332.\n\nI've been looking into LBP's as inputs to XNOR-net neural networks. In that case, each bit of the 8-bit output byte would be a single binary neuron.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["edgedetection","lbp","ed","localbinarypatterns","8bitcolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// stretch\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 rez = iResolution.xy*(iResolution.xy/iChannelResolution[1].xy);\n    fragColor = texture(iChannel0, fragCoord/rez);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 luma = vec3(0.2126,0.7152,0.0722); // weight of each channel to luma\nfloat get(vec2 uv){\n    return pow(dot(texture(iChannel0, uv/iChannelResolution[0].xy).xyz, luma),2.2f);\n}\n\nconst vec2[8] angles = vec2[8](\n    vec2( 1, 0),\n    vec2( 1, 1),\n    vec2( 0, 1),\n    vec2(-1, 1),\n    vec2(-1, 0),\n    vec2(-1,-1),\n    vec2( 0,-1),\n    vec2( 1,-1)\n);\n\n// use this to adjust according to the noise in the image\nconst float noiseFloor = 0.009;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if(fragCoord.x > iChannelResolution[0].x\n    || fragCoord.y > iChannelResolution[0].y){\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    \n    float center = get(fragCoord.xy);\n    int color=0;\n    for(int i=0; i<8; i++){\n        bool b = get(fragCoord.xy+angles[i]) > center+noiseFloor;\n        color |= b? 1<<i :0;\n    }\n    \n    // rgb332 visualization of byte \n    fragColor = vec4(pow(float((color   )&7)/8.f,1.f/2.2f),\n                     pow(float((color>>3)&7)/8.f,1.f/2.2f),\n                     pow(float((color>>6)&3)/4.f,1.f/2.2f),\n                     1.f);\n}","name":"Buf A","description":"","type":"buffer"}]}