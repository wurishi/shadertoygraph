{"ver":"0.1","info":{"id":"MtGfRR","date":"1547317051","viewed":63,"name":"illuminationphong","username":"caudya","description":"phong","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material {\n    float ka; // ambiant\n    float kd; // diffuse\n    float ks; // specular\n    float kn; // specular power\n};\n\n//Camera\nconst vec3 cameraPos = vec3(6, 4, -5);\nconst vec3 cameraTarget = vec3(3, 1, -8);\nconst float cameraFovY = 90.0;\n\nconst float distFoc = 1.0 / tan(radians(cameraFovY) / 2.0);\nconst vec3 dirCamera = normalize(cameraTarget - cameraPos);\n\n//Sphere\nconst vec3 spherePos = cameraTarget + vec3(0, 0, 0);\nconst float sphereRadius = 1.0;\nconst vec4 sphereColor = vec4(1.0, 0.0, 0.0, 1.0);\nconst Material sphereMat = Material(0.2, 0.7, 1.0, 50.0);\n\n//Light\nconst vec4 ambiantColor = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec3 lightPos = vec3(8.0, 10.0, -12.0);\n\n\nconst vec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n\nvec2 transfoFrag(in vec2 fragCoord);\nvoid computeCameraRayFromPixel(in vec2 uv, out vec3 rayDir);\nfloat raySphere(in vec3 rayPos, in vec3 rayDir, in vec3 spherePos, in float sphereRadius, out vec3 intersecS, out vec3 normalS);\nvec4 computePhongShading(in vec4 sphereCol, in Material sphereMat, in vec3 normalS, in vec3 L, in vec3 R, in vec3 V);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from x : -ratio, ratio, y : -1, 1) ratio : screenx / screeny\n    vec2 uv = transfoFrag(fragCoord);\n    \n    //vec3 spherePosMov = spherePos + vec3(cos(iTime) * 1.5, sin(iTime) * 1.5, 0.0);\n\n       vec3 rayPos = cameraPos;\n    vec3 rayDir;\n    \n    computeCameraRayFromPixel(uv, rayDir);\n    \n    vec3 intersecS, normalS;\n    \n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n\n    // Output to screen\n    if (distS > 0.0)\n    {\n        // unit-vector going from the surface point toward the light\n        vec3 L = normalize(lightPos - intersecS);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n        vec3 R = normalize(2.0 * normalS * dot(normalS, L) - L);\n        \n        // unit-vector going from the surface point toward the camera\n        vec3 V = normalize(cameraPos - intersecS);\n        \n        fragColor = computePhongShading(sphereColor, sphereMat, normalS, L, R, V);\n    }\n    else\n    {\n        fragColor = backgroundColor;\n    }\n}\n\nvec2 transfoFrag(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.y = uv.y * 2.0 - 1.0;\n    uv.x = uv.x * 2.0 - iResolution.x / iResolution.y;\n    \n    return uv;\n}\n\n\nvoid computeCameraRayFromPixel(in vec2 uv, out vec3 rayDir)\n{\n    vec3 repereCameraZ = dirCamera;\n    vec3 repereCameraX = normalize(cross(vec3(0, -1, 0), repereCameraZ));\n    vec3 repereCameraY = normalize(cross(repereCameraZ, repereCameraX));\n    \n    rayDir = normalize(distFoc * repereCameraZ + uv.x * repereCameraX - uv.y * repereCameraY);\n}\n\nfloat raySphere(in vec3 rayPos, in vec3 rayDir, in vec3 spherePos, in float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{\n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n\n        bool res = (t1 > 0.0) || (t2 > 0.0);\n        if (t1 > 0.0)\n        {\n            intersecS = rayPos + rayDir * t1;\n            normalS = normalize(intersecS - spherePos);\n            return t1;\n        }\n        else if (t2 > 0.0)\n        {\n            intersecS = rayPos + rayDir * t2;\n            normalS = normalize(intersecS - spherePos);\n            return t2;\n        }\n    }\n    \n    return di;\n}\n\nvec4 computePhongShading(in vec4 sphereCol, in Material sphereMat, in vec3 normalS, in vec3 L, in vec3 R, in vec3 V)\n{\n    vec3 a = sphereMat.ka * ambiantColor.rgb;\n    \n    float teta = dot(normalS, L);\n    float alpha = dot(R, V);\n    \n    \n    vec3 d = sphereMat.kd * sphereColor.rgb * lightColor.rgb * max(dot(normalS, L), 0.0);//* cos(teta);\n    \n    vec3 s = sphereMat.ks * lightColor.rgb * ((dot(normalS, L) > 0.0) ? 1.0 : 0.0) * pow(max(dot(R, V), 0.0), sphereMat.kn);// * pow(cos(alpha), sphereMat.kn);\n    \n    return vec4(a + d + s, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}