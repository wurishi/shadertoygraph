{"ver":"0.1","info":{"id":"lfdyDn","date":"1732675173","viewed":39,"name":"Inverse Kinematics Test V0","username":"8InfinityTaco8","description":"Learning some IK from a while back","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["invers","kinematicsik"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//gonna revise this later on at some point \n\nconst float PI = 3.14159265359;\nconst int NUM_SEGMENTS = 3;\nconst float SEGMENT_LENGTH = 0.2;\nconst float JOINT_RADIUS = 0.02;\n\n// Structure to store joints\nstruct Joint {\n    vec2 pos;\n    float angle;\n};\n\n// circle \nfloat drawCircle(vec2 uv, vec2 center, float radius) {\n    float d = length(uv - center);\n    return smoothstep(radius + 0.005, radius, d);\n}\n\n// Function to draw a line segment\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2, float thickness) {\n    vec2 dir = p2 - p1;\n    float len = length(dir);\n    dir = dir / len;\n    vec2 perpDir = vec2(-dir.y, dir.x);\n    \n    vec2 toUV = uv - p1;\n    float projLen = dot(toUV, dir);\n    float perpDist = abs(dot(toUV, perpDir));\n    \n    return (projLen >= 0.0 && projLen <= len && perpDist < thickness) ? 1.0 : 0.0;\n}\n\n// Function to solve IK using FABRIK (Forward And Backward Reaching Inverse Kinematics)\nJoint[NUM_SEGMENTS] solveIK(vec2 target, vec2 base) {\n    Joint[NUM_SEGMENTS] joints;\n    \n    // Initialize joints\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        joints[i].pos = base + vec2(float(i) * SEGMENT_LENGTH, 0.0);\n        joints[i].angle = 0.0;\n    }\n    \n    // FABRIK iteration\n    for(int iter = 0; iter < 10; iter++) {\n        // Forward reaching\n        joints[NUM_SEGMENTS-1].pos = target;\n        \n        for(int i = NUM_SEGMENTS-2; i >= 0; i--) {\n            vec2 dir = normalize(joints[i].pos - joints[i+1].pos);\n            joints[i].pos = joints[i+1].pos + dir * SEGMENT_LENGTH;\n        }\n        \n        // Backward reaching\n        joints[0].pos = base;\n        \n        for(int i = 1; i < NUM_SEGMENTS; i++) {\n            vec2 dir = normalize(joints[i].pos - joints[i-1].pos);\n            joints[i].pos = joints[i-1].pos + dir * SEGMENT_LENGTH;\n        }\n    }\n    \n    // Calculate angles\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        if(i < NUM_SEGMENTS-1) {\n            vec2 dir = joints[i+1].pos - joints[i].pos;\n            joints[i].angle = atan(dir.y, dir.x);\n        }\n    }\n    \n    return joints;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Get mouse position in UV space\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Base position of the arm\n    vec2 base = vec2(0.0, 0.0);\n    \n    // Solve IK\n    Joint[NUM_SEGMENTS] joints = solveIK(mouse, base);\n    \n    // Draw segments and joints\n    float color = 0.0;\n    \n    // Draw segments\n    for(int i = 0; i < NUM_SEGMENTS-1; i++) {\n        color += drawLine(uv, joints[i].pos, joints[i+1].pos, 0.005);\n    }\n    \n    // Draw joints\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        color += drawCircle(uv, joints[i].pos, JOINT_RADIUS);\n    }\n    \n    vec3 finalColor = vec3(color);\n    \n    if(color > 0.0) {\n        finalColor = vec3(0.2, 0.6, 1.0);\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}