{"ver":"0.1","info":{"id":"WsdyRn","date":"1600451662","viewed":86,"name":"Living in a Box - WIP","username":"neriakX","description":"This shader is based on some ray marching courses by Flopine, it's my first attempt and I'm a total noob :P\nIt's nothing special and I just keep learning from this. However I share it with you to hopefully get some constructive criticism fro you guys.\n","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4l2GDK","filepath":"https://soundcloud.com/neriakx/normality-2011","previewfilepath":"https://soundcloud.com/neriakx/normality-2011","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* inspired by Flopine's and evvvil's ray marching courses/videos on twitch <3\n\nthis is my first attempt in ray marching.\njust starting to mess around with (hopefully) simple stuff ...\nI took some functions from iq also => https://iquilezles.org/articles/distfunctions\n\nthere's a lot of stuff missing and funky things are happening :)\n\n*/\n\n#define bpm (121./60.)\n#define FOV .33\n#define ITER 128\n#define PI  (atan(1.0) * 4.0)\n#define TAU (atan(1.0) * 8.0)\n#define tt mod(iTime*1.,100.)\n\nfloat t;\nvec2 sc;\nvec3 np, no, al, po, ld;\n\n// iq's Tools\nfloat uni( float d1, float d2 ) { return min(d1,d2); }\nfloat sub( float d1, float d2 ) { return max(-d1,d2); }\nfloat isec( float d1, float d2 ) { return max(d1,d2); }\n\nfloat ssub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n// rotation function\nmat2 r2 (float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n//sphere\nfloat sp(vec3 p, float r) { return length(p)-r; }\n\n//diamond\nfloat di (vec3 p, float s) \n{\n    float lx = length(p.x);\n    float ly = length(p.y);\n    float lz = length(p.z);\n    return sqrt(lx+ly+lz)-s;   \n}\n\n// box\nfloat bo (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return length(max(q, 0.)) + min(0., max(q.x,max(q.y,q.z)));  \n}\n\n// Cylinder\nfloat cy (vec3 p, float r, float height) \n{\n    return max(length(p.xy)-r,abs(p.z)-height); \n}\n\n// the sphere\nvec2 bs (vec3 p)\n{\t\n    // bouncing sphere \n    p.x -= sin(tt); // sphere moves slightly left and right\n    p.y -= 1.6*sin(tt*bpm*2.); // bounces sphere up and down along the y-axis\n    vec2 h,t=vec2(sp(p, 2.),10.);\n    return t;\n}\n\n// the room\nvec2 rtr (vec3 p)\n{   \n  \t// moving room\n    p.yz *= r2(atan(sin(tt)*.5)); // rotate room along the y-axis (up'n'down)\n    p.xz *= r2(-tt); // rotate room alanong the x-axis (right)\n    vec2 h,t = vec2(-bo(p, vec3(20.,4.0,20.)),5.);\n\n    // cut the room with cylinders\n    float per = 2.5; //period - Wiederholungen - netter Wert 1.9 o. 2.5\n   \tp.xz = mod(p.xz, per)-per *0.5; // domain repeat of cylinders to cut the floor and ceiling\n\th=vec2(cy(p.xzy,0.7, 5.0),5.); // 1e10\n    t.x=ssub(h.x, t.x, 0.03); // smooth subtracts floor with cylinders\n    t.x*=0.8;\n    return t; \n}\n\n// the scene\nvec2 mp (vec3 p) \n{ \t\n    np=p;\n    vec2 h,t=rtr(p);\n    h=bs(p);\n   \tt=(t.x<h.x)?t:h;\n    return t;\n}\n\n// lighting\nfloat li (vec3 n, vec3 l)\n{\n  return max(0., dot(n, l));\n}\n\n// Camera\n vec3 cam (vec3 ro, vec2 uv, float fov)\n{\n    vec3 cw=normalize(vec3(0.,1.,1.)-ro),\n    \tcu=normalize(cross(cw, vec3(0.,0.,1.))),\n    \tcv=normalize(cross(cu,cw));\n    return mat3(cu,cv,cw)*normalize(vec3(uv,FOV));\n} \n\n// main raymarching function\nvec2 tr (vec3 ro, vec3 rd) \n{\n    vec2 h,t=vec2(0.1);\n    for(int i=0;i<ITER;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>40.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if (t.x>40.) t.x=0.;\n    return t;\n}\n\n// get Normals (iq)\nvec3 calcNormal( in vec3 po )\n{\t\n    vec2 e=vec2(.00035,-.00035);\n    return normalize(e.xyy*mp(po+e.xyy).x+\n        e.yyx*mp(po+e.yyx).x+\n        e.yxy*mp(po+e.yxy).x+\n        e.xxx*mp(po+e.xxx).x); \n}\n\n// AO\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.) \n// SSS\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n      \n    // ray_origin / camera\n    vec3 ro = vec3(0.,0.,6.), //ray origin is 0.,0.,6. in space - step back\n    rd=cam(ro,uv,FOV),\n    co,fo,ld=normalize(vec3(5.,3.8,5.));\n      \n    sc=tr(ro,rd); // sc.x = distance geometry, sc.y = colour\n    t=sc.x; // t is the result of the geometry\n    \n    if (t>0.) \n    {\t\n        po=ro+rd*t;\n        vec3 no=calcNormal(po),\n        al=vec3(0.,0.08,0.45); // albedo\n     \n        // Material colouring\n        if(sc.y<5.) al=vec3(0.);\n    \tif(sc.y>5.) al=vec3(1.);\n        if(sc.y>9.) al=vec3(0.48, 0.18, 0.01);\n        \n    \tfloat dif=li(no,ld), // diffuse\n    \tfr=pow(1.+dot(no,rd),4.), // fresnel\n        sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.); // specular by shane.\n    \tco=mix(sp+al*(a(.1)*a(.3)+.2)*(vec3(.2,.1,.2)*dif+s(.5)*1.5),fo,min(fr,.5)); // final lights\n        co=mix(co,vec3(0.022*sin(tt*bpm*2.),0.,0.045),1.-exp(-0.0011*t*t*t)); // add fog\n        \n        // Subtle vignette by Shane\n    \tuv = fragCoord/iResolution.xy;\n    \tco = mix(vec3(0), co, pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n          \n        fragColor = vec4(pow(co,vec3(0.45)),1.); // add gamma correction\n    }\n}","name":"Image","description":"","type":"image"}]}