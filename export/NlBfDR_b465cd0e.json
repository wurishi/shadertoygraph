{"ver":"0.1","info":{"id":"NlBfDR","date":"1651986008","viewed":142,"name":"cmykhexgrid","username":"HaleyHalcyon","description":"e","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"NdG3RV","parentname":"@&♡•~““&"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// square root of 3 because hexagon stuff\n#define SQRT3 (1.7320508)\n// two pi for rotation stuff\n#define TAU (6.283185307)\n// converts rgb hex code to a vec3\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n// saw wave to triangle wave\n#define ZIG(x) 1. - abs(1. - 2. * x)\n\n// calculate the distance from the center of a hexagon\nfloat hex(vec2 uv) {\n    const vec2 tileSize = vec2(1.0, SQRT3);\n    vec2 tiled = abs(tileSize - mod(uv, tileSize * 2.));\n    float diag = dot(tiled, tileSize / 2.);\n    float thres = step(1.0, diag);\n    return mix(\n        max(tiled.x, diag),\n        max(1. - tiled.x, 2. - diag),\n    thres);\n}\n\nfloat hexHelper(vec2 uv, float otherOne) {\n    const vec2 tileSize = vec2(1.0, SQRT3);\n    uv += otherOne * vec2(3., SQRT3);\n    vec2 tiled = abs(\n        tileSize * vec2(3., 1.) - mod(\n            uv, tileSize * vec2(6., 2.)\n        )\n    );\n    float diag = dot(tiled, tileSize);\n    \n    return step(max(tiled.x, diag * 0.5), 1.0);\n}\n\nfloat hex2(vec2 uv) {\n    return max(hexHelper(uv, 0.), hexHelper(uv, 1.));\n}\n\n// map the range [0, 1) to stripes of colors\nfloat map(float minv, float maxv, float x) {\n    if (minv == maxv) {return step(minv, x);}\n    return clamp(0., 1., (x - minv) / (maxv - minv));\n}\n\n// set to 1 to enable antialiasing\n#define ANTIALIAS 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / 15.);\n    // Scales coords so that the diagonals are all the same distance from the center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * 24.;\n    float turnMax = -TAU / 3.;\n    uv = vec2(\n        cos(time * turnMax) * uv.x + sin(time * turnMax) * uv.y,\n        sin(time * turnMax) * uv.x - cos(time * turnMax) * uv.y\n    );\n    \n    float dist = hex(uv);\n    float hexCol1 = hex2(uv);\n    float hexCol2 = hex2(uv + vec2(1.0, SQRT3));\n    vec3 baseCol = (\n        HEX(0x009BE8) * hexCol1 +\n        HEX(0xEB0072) * hexCol2 +\n        HEX(0xfff100) * (1. - hexCol1 - hexCol2)\n    );\n    \n    float distTemp = ZIG(fract(\n        1.5 * dist * dist +\n        -6. * time +\n        0.333 * hexCol1 +\n        -0.333 * hexCol2\n    ));\n#if ANTIALIAS == 1\n    float aaWidth = fwidth(distTemp) * 0.75;\n    float bright = \n        smoothstep(\n            -aaWidth, aaWidth, distTemp - 0.5\n        ) * smoothstep(\n            -fwidth(dist), fwidth(dist), 0.9 - dist\n        )\n    ;\n#else\n    float bright = min(\n        step(\n            0.5, distTemp\n        ), step(\n            dist, 0.9\n        )\n    );\n#endif\n    vec3 col = mix(HEX(0x010a31), baseCol, bright);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}