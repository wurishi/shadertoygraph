{"ver":"0.1","info":{"id":"3dXyRN","date":"1584217910","viewed":186,"name":"Living maze","username":"stb","description":"Not guaranteed solvable. Click & drag to see input pattern.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","maze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Originally posted to glslsandbox... somewhere :/\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define pi 3.14159265\n\n#define T .4*iTime\n\n// pill shape for walls\nfloat pill(vec2 p, vec2 d) {\n    return length( vec2(max(0., (dot(p, d))), abs(dot(p, vec2(d.y, -d.x)))) );\n}\n\n// for the input pattern, it's like Gabor noise\nfloat rStripes(vec2 p, vec2 o, float freq) {\n    float ang = 2. * pi * hash12(floor(p)-o);\n    vec2 dir = vec2(sin(ang), cos(ang));\n    float f;\n    \n\t// choose one\n    f = .5 + .5 * cos(2.*T+freq*pi*dot(p, dir));\n    //f = 2. * abs(fract(dot(freq*p, dir)+3.*T)-.5);\n    //f = 4. * pow(abs(fract(dot(freq*p, dir)+.5*T)-.5), 2.);\n    //f = fract(dot(freq*p, dir)+.5*T);\n    \n    return f;\n}\n// continuation of above\nfloat rStripesLin(vec2 p, float freq) {\n    vec3 o = vec3(-1., 0., 1.); \n    return\n        mix(\n            mix(\n                rStripes(p, o.zy, freq),\n                rStripes(p, o.yy, freq),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            mix(\n                rStripes(p, o.zx, freq),\n                rStripes(p, o.yx, freq),\n                smoothstep(0., 1., fract(p.x))\n            ),\n            smoothstep(0., 1., fract(p.y))\n\t\t);\n}\n\n// input pattern\nfloat map(in vec2 p) {\n    \n\tvec2 p_ = p;\n    p = floor(p);\n   \n    float f = 2.*rStripesLin(p/5., 1.);\n    \n    return f*1.75+.1;\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n    vec2 p = (fc-res/2.) / res.x;\n    \n    float zoom = 64.;\n    \n    p *= zoom;\n    \n    float f = 0.;\n    \n    vec3 o = vec3(-1., 0., 1.);\n    vec2 O[4];\n    O[0] = o.xy;\n    O[1] = o.zy;\n    O[2] = o.yx;\n    O[3] = o.yz;\n    \n    // value for wall direction\n    float rv = radians(90.*floor(map(p)));\n    \n    // initial wall\n    f = 2. * pill(fract(p)-.5, vec2(sin(rv), cos(rv)));\n    \n    // add walls from surrounding directions\n    for(int i=0; i<4; i++) {\n    \trv = radians(90.*floor(2.+map(p-O[i])));\n        vec2 sc = vec2(sin(rv), cos(rv));\n    \tif(dot(sc, O[i])>.5)\n            f = min(f, 2. * pill(fract(p)-.5, sc));\n    }\n    \n    // aa\n    f = smoothstep(.5-2./res.x*zoom, .5+2./res.x*zoom, f);\n    \n    // mouse input\n    if(p.x<(iMouse.x/res.x-.5)*zoom)\n    \tf = floor(map(p)) / 3.;\n    \n\tfo = vec4(vec3(f), 1.);\n}","name":"Image","description":"","type":"image"}]}