{"ver":"0.1","info":{"id":"cdl3DS","date":"1666738912","viewed":107,"name":"YinYang Modulus ","username":"ABCDEFG","description":"ORIGINAL:  https://www.shadertoy.com/view/3d2czy","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["modulus","trails"],"hasliked":0,"parentid":"msX3DB","parentname":"Fork YinYang CIRCLE"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ORIGINAL: https://www.shadertoy.com/view/3d2czy\n// By Omeometo,  and edited (shortened etc) by FabriceNeyret2 \n// I only added symbols, rotation, and trails. And positioned the points in a circle. \n// Yin-Yang by iq (inigo quilez)\n\nfloat yin(vec2 p) {\n\n    // Large circle squared distance \n    float a = dot(p,p); \n    // Medium circle: Squared distance in both directions minus absolute vertical distance\n    float b = a-abs(p.y);\n    // Inside and outside the medium circle. We need this only for the next step \n    float c = (b<0.0) ? p.y : p.x;\n    // This is a clever way of using the sign of the UVs to get the appropriate circles to be black or white \n    // (a-1) is >0 when inside the large circle. \n    // (b+0.23) is >0 when outside the small circle with radius 0.02 and inside a medium circle with radius 0.5 \n    //           The reason for that is b which is basically xÂ² - x, which peaks at -0.25\n    // c is negative and positive depending on where we are and if we are inside a medium circle \n    float d = (a-1.0)*(b+0.23)*c;  \n    // Background color and yinyang colors black or white \n    float r = (a>1.0) ? 0. : \n              (d>0.0) ? 1.0 :  \n                        0.0;\n                        return r;\n}\n\nvec2 rot(vec2 uv, float a) {\nreturn uv*mat2x2(cos(a), sin(a), -sin(a), cos(a));\n\n}\n\nvec2 getpos(float i,float p) {\np-=1.;\nreturn   vec2(cos(i*2.*3.14159/p)*.1, sin(i*2.*3.14159/p)*.1);\n}\n\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n        uv = 1.1 * ( u*2. - R ) / R.x;\n  \n    float p = 19.,\n          // From 2 to p\n          k = mod(floor(iTime),p-2.)+2., \n          r = .8/p,\n          mindist = 100.,\n          t = smoothstep(0.,1.,fract(iTime));\n          t = smoothstep(0.,1.,t);\n    vec3 col = vec3(0.);\n    float m2 = 0.;\n    float i2 = 0.;\n    vec2 uvNew = vec2(0.);\n    for(float i=1.; i<p; i++){ // 1 bis p iteration\n    \tfloat m = mod(i*k,p);  // 0 to p-1 \n        // Place balls in a circle \n        vec2 c = 4.* vec2( mix( getpos(i,p).x,getpos(m,p).x,t), mix(getpos(i,p).y, getpos(m,p).y, t));\n        float l =  length(uv-c)*20.;\n        mindist=min(mindist, l);\n        if(mindist == l) \n        {\n                // Keep track of closest ball \n                m2 = m;\n                i2 = i;\n                uvNew.xy = c;\n        }\n       \n    }\n\n    O = vec4(vec3(yin(rot(20.*(uv-uvNew),t*(2.*3.14159265359 )*sign(m2-i2)))),1.);\n      \n    // Moving UVs around \n    uv*=16.;\n    for(float i = 1.0; i < 4.0; i+=1.0){ \n    uv.x += cos(iTime+uv.y * i);\n   \tuv.y += sin(iTime+uv.x * i);\n    }\n      vec3 col2 = 0.5 + 0.5*cos(2.*iTime+uv.xyx+vec3(-5.,0.,0.));\n    // Old colors \n    vec4 pfragColor = texture(iChannel0, u.xy / R)*0.65;\n    O += pfragColor*vec4(col2,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}