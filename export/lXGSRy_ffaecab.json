{"ver":"0.1","info":{"id":"lXGSRy","date":"1720096094","viewed":39,"name":"supershape - gradient","username":"valvw","description":"supershape","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["supershape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nconst float a = 1.3;\nconst float b = 1.0;\n\n// Supershape formula\nfloat supershape(float theta, float m, float n1, float n2, float n3) {\n    float t1 = abs(cos(m * theta / 4.0) / a);\n    t1 = pow(t1, n2);\n    float t2 = abs(sin(m * theta / 4.0) / b);\n    t2 = pow(t2, n3);\n    float r = pow(t1 + t2, -1.0 / n1);\n    return r;\n}\n\n// Distance to the supershape surface\nfloat distanceToSupershape(vec3 p, float m1, float n11, float n12, float n13, float m2, float n21, float n22, float n23) {\n    float phi = atan(p.z, p.x);\n    float r1 = supershape(phi, m1, n11, n12, n13);\n\n    float theta = atan(p.y, length(vec2(p.x, p.z)));\n    float r2 = supershape(theta, m2, n21, n22, n23);\n\n    float r = r1 * r2;\n    vec3 ss = vec3(r * cos(theta) * cos(phi), r * sin(theta), r * cos(theta) * sin(phi));\n\n    return length(p - ss);\n}\n\n// Raymarching\nvec3 raymarch(vec3 ro, vec3 rd, float m1, float n11, float n12, float n13, float m2, float n21, float n22, float n23) {\n    float t = 0.0;\n    vec3 p;\n    const int maxSteps = 800;  \n    const float epsilon = 0.1;  \n    for (int i = 0; i < maxSteps; i++) {\n        p = ro + t * rd;\n        float dist = distanceToSupershape(p, m1, n11, n12, n13, m2, n21, n22, n23);\n        if (dist < epsilon) break;\n        t += dist * 0.1;  \n    }\n    return p;\n}\n\n// Normal at point p\nvec3 getNormal(vec3 p, float m1, float n11, float n12, float n13, float m2, float n21, float n22, float n23) {\n    float eps = 0.001;  \n    vec3 n;\n    n.x = distanceToSupershape(p + vec3(eps, 0, 0), m1, n11, n12, n13, m2, n21, n22, n23) - distanceToSupershape(p - vec3(eps, 0, 0), m1, n11, n12, n13, m2, n21, n22, n23);\n    n.y = distanceToSupershape(p + vec3(0, eps, 0), m1, n11, n12, n13, m2, n21, n22, n23) - distanceToSupershape(p - vec3(0, eps, 0), m1, n11, n12, n13, m2, n21, n22, n23);\n    n.z = distanceToSupershape(p + vec3(0, 0, eps), m1, n11, n12, n13, m2, n21, n22, n23) - distanceToSupershape(p - vec3(0, 0, eps), m1, n11, n12, n13, m2, n21, n22, n23);\n    return normalize(n);\n}\n\n// Lighting calculation\nvec3 lighting(vec3 p, vec3 normal) {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    float diff = max(dot(normal, lightDir), 0.0);\n\n    vec3 baseColor = vec3(0.5 + 0.5 * cos(p.x * 2.0 + iTime), 0.5 + 0.5 * sin(p.y * 2.0 + iTime), 0.5 + 0.5 * cos(p.z * 2.0 + iTime));\n\n    // Emission component for glow effect\n    vec3 emission = baseColor * 0.5;\n\n    // Ambient component\n    vec3 ambient = vec3(0.1); \n\n    // Final color\n    return baseColor * diff + ambient + emission;\n}\n\n// Rotation matrices\nmat3 rotateY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\nmat3 rotateX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera setup\n    vec3 camPos = vec3(0.0, 0.0, 3.0); \n    vec3 ro = camPos;\n\n    // Initial rotation\n    float initialYaw = 2.0;   \n    float initialPitch = PI * 0.4;  \n    float roll = -3.0;       \n\n    // Mouse rotation\n    float yaw = initialYaw - 2.0 * PI * (iMouse.x / iResolution.x - 0.5);\n    float pitch = initialPitch + PI * (iMouse.y / iResolution.y - 0.5);\n    mat3 rotation = yaw_pitch_roll(yaw, pitch, roll);\n    ro = rotation * ro;\n\n    vec3 rd = normalize(vec3(uv, -1.0));\n    rd = rotation * rd;\n\n    // Dynamic parameters for the supershape\n    float dynamicFactor1 = sin(iTime * 0.5) * 0.5 + 0.5;\n    float dynamicFactor2 = cos(iTime * 0.3) * 0.5 + 0.5;\n\n\n\nfloat m1 = 3.0 + 11.0 * sin(iTime * 0.8)  ;\nfloat n11 = 4.0 ;\nfloat n12 = -1.25 + 2.0 * sin(iTime * 1.0) ;\nfloat n13 = 23.5 + 2.0 * cos(iTime * 0.6) ;\n\nfloat m2 = 13.6 + 2.0 * cos(iTime * 1.1) ;\nfloat n21 = 5.5 + 1.0 * sin(iTime * 1.2) ;\nfloat n22 = -6.5  ;\nfloat n23 = 9.25 + 2.0 * sin(iTime * 1.4) ;\n\n\n\n\n    vec3 p = raymarch(ro, rd, m1, n11, n12, n13, m2, n21, n22, n23);\n    vec3 normal = getNormal(p, m1, n11, n12, n13, m2, n21, n22, n23);\n    vec3 color = lighting(p, normal);\n\n    vec3 bgColor = vec3(0.0);\n    if (length(color) < 0.01) {\n        bgColor = vec3(0.1, 0.1, 0.1) + 0.1 * uv.y;\n    }\n\n    fragColor = vec4(color + bgColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}