{"ver":"0.1","info":{"id":"Xd3SWH","date":"1458917487","viewed":706,"name":"Line Light","username":"Aradel","description":"Implemented something similar before in HLSL but included an if statement and the use of min. This annoyed me for quite some time but I never got around solving the problem. This implementation is branch free =)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["simple","prototype","linelight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct LineLight\n{\n    vec2 start;\n    vec2 stop;\n    vec4 color;\n};\n    \nfloat attenuation(float d);\n\nvoid mainImage( out vec4 color, in vec2 fragCoord )\n{\n    // Setup stuff\n    vec2 position \t= \tiResolution.xy * 0.5 + vec2(sin(iTime) * 125.0, 0.0);\n    float angle \t= \tiTime * 2.0;\n    vec2 dir\t\t=\tvec2(cos(angle), sin(angle));\n    \n    \n    LineLight light;\n    light.color = vec4(1.0, 0.35, 1.0, 1.0);\n    light.start = position - (dir * 150.0 * 0.5);\n\tlight.stop\t= position + (dir * 150.0 * 0.5);\n    \n    vec4 ambient = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    //Start of Shader\n    \n    float lineLength = length(light.start - light.stop); \n \n    // Project fragCoord on line\n    vec2 toPixel = fragCoord - position;  \n    vec2 line = normalize(light.stop - position);\n    vec2 projection = dot(toPixel, line) * line;\n    vec2 toLine = toPixel - projection;\n  \n    // Clamp Projection Length to Line Length\n    float projectionLength = clamp(length(projection), 0.0, lineLength * 0.5);\n    // +/- direction of center\n    vec2 projectionLine = normalize(projection) * projectionLength;\n\n    // Get Final Distances for attenuation calculation\n    float distToLight = length(toPixel - projectionLine);\n    \n    vec4 diffuse = texture( iChannel0, fragCoord / iResolution.xy ); \n       \n    float kd = 1.0; // Cause 2d and no normals\n    float ka = 0.05;\n   \tcolor = (ambient * ka) + (diffuse * (light.color * kd)) * attenuation(distToLight); \n}\n\nfloat attenuation(float d)\n{ \n    float Kc = 0.25;\n    float Kl = 0.1;\n    float Kq = 0.001;\n\treturn 1.0 / (Kc + Kl*d + Kq*d*d);\n}","name":"Image","description":"","type":"image"}]}