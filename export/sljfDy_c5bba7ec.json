{"ver":"0.1","info":{"id":"sljfDy","date":"1675267531","viewed":113,"name":"ABSMirror","username":"Uffe55","description":"Test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mirror","rotation","abs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define SURF_DIST .0005\n#define PI2 = 6.28318\n\nint AUTOMATICFOCAL = 0;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 rotTPR(vec3 p,float a,float b,float c)\n{\n    p.xz *= Rot(a);   p.yz *= Rot(b);   p.xy *= Rot(c);\n    return p;\n}\n\nfloat sdSegment(vec3 p,vec3 a,vec3 b,float R)\n{\n            float h = min(1.0,\n            max(0.0,dot(p-a,b-a) / dot(b-a,b-a)));\n    return length(p-a-(b-a)*h)-R;\n}\n\n //Capsule / Line - exact\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdBox(vec3 p , vec3 s){\n     p = abs(p)-s;  \n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSquareFrame3(vec3 p, vec3 bOut,vec3 bIn)\n{\n    float dist = 1000.0;\n        dist = min(dist, sdBox(p,bOut));\n        dist = max(dist, -sdBox(p,bIn));\n\n    return dist;\n}\n\nfloat sdXYZ(vec3 p){\n float dist =1000.0;\n    float s=0.16;// font size \n    vec3 pos = vec3(-2.3,0.0,0.0);\n    vec3  posR = vec3(s,0.0,0.0);\n    vec3  posU=  vec3(0.0,s,0.0);\n    vec3 px=p;\n    \n    //X\n    dist=min(dist,sdSegment(px,pos -posR+posU,pos+posR-posU,0.04));\n    dist=min(dist,sdSegment(px,pos -posR-posU,pos+posR+posU,0.04));\n    vec3 py=p;\n    \n    py.xz*=Rot(iTime*3.5);\n    //Y\n    pos = vec3(0.0,-2.3,0.0);\n    dist=min(dist,sdSegment(py,pos+posR-posU,pos,0.04));\n    dist=min(dist,sdSegment(py,pos-posR-posU,pos,0.04));\n    dist=min(dist,sdSegment(py,pos+posU,pos,0.04));\n    //Z\n     pos = vec3(0.0,0.0,-2.3);\n    dist=min(dist,sdSegment(p,pos+posR-posU,pos-posR-posU,0.04));\n    dist=min(dist,sdSegment(p,pos-posR+posU,pos+posR+posU,0.04));\n    dist=min(dist,sdSegment(p,pos-posR-posU,pos+posR+posU,0.04));\n    \nreturn dist;\n}\n\nfloat sdAxisLines(vec3 p, float segLen, vec3 position ,float spRadius)\n{\n    float dist = 1000.0;\n    vec3 k1 = vec3(segLen,0,0),\n         k2 = vec3(0,segLen,0),\n         k3 = vec3(0,0,segLen); \n    dist= min(dist,sdSegment (p,k1,-k1,0.05));\n    dist= min(dist,sdSegment (p,k2,-k2,0.05));\n    dist= min(dist,sdSegment (p,k3,-k3,0.05));\n  return dist;\n}\nfloat sdCavalette(vec3 p){\n      vec3 p1 = vec3(0.0,-8.0,3.0),\n           s = vec3(12.0, 0.1,12.0);\n           p += p1;\n\nreturn sdBox(p, s);\n}\n//Axis lines origo +XYZ\nfloat sceenAxis(vec3 p)\n{ \n    float dist = 1000.0;\n    dist = min(dist,sdAxisLines(p, 2.0, vec3(0.0) ,1.0));\n     //sphere\n    dist= min(dist,length(p) - 0.2);\n    //Letter XYZ\n    //dist = min(dist,sdXYZ(p)); //Letters XYZ\n   /* vec3 a=vec3(2.0,3.0,0.0),\n         b=vec3(4.0, -2.0,1.0);\n    //dist =min(dist,sdCapsule(  p, a,  b,  0.025 ));\n    //dist= min(dist,length(p-b) - 0.1);\n   */  \n  return dist;\n}\n\n// frame //Order of rotation tetha phi rho\nfloat SceenTPR(vec3 p)  \n{\n    float dist =1000.0;  \n    float side = 3.0;\n    float width = 0.25;\n    float thic = width*0.5;\n    vec3 boxOut = vec3( side ,side, width  );\n    vec3 boxIn = vec3( side-width+thic,side-width+thic ,width+width );\n    // Angles \n    float tetha = 0.785398,\n          phi   = -0.785398,\n          rho   = -0.4*iTime;\n          \n    p = rotTPR( p,tetha,phi,rho);\n    dist = min(dist, sdSquareFrame3( p,  boxOut, boxIn));\nreturn dist;\n}\n\nfloat sdBoxFrame(vec3 p){\n\n float dist =1000.0;\n    vec3  pos = p;  \n    float sc =1.8;\n    float a = 1.0;\n    float th= 0.25;\n    \n    vec3 s1=vec3(a )*sc;\n    vec3 s2=vec3(a +1.0 , a-th, a-th)*sc;\n    vec3 s3=vec3(a -th , a+ 1.0 , a-th)*sc;\n    vec3 s4=vec3(a -th,  a-th, a +1.0)*sc;\n   \n    dist = min(dist, sdBox(p,s1));\n    dist = max(dist,-sdBox(p,s3));\n    dist = max(dist,-sdBox(p,s2));\n    dist = max(dist,-sdBox(p,s4));\n  \nreturn dist;    \n}\n\nfloat sdSingleFold(vec3 p){\n  float dist=1000.0;\n  float space =3.6;\n  float multipelSpace = 1.0;\n  vec3 bp = p;//\n   \n          bp = abs(bp);\n          bp -= space ; \n             \n   bp.xy *= Rot(-.5*iTime);\n   bp.yz *= Rot(-.5*iTime);\n   bp.yz *= Rot(-0.2*iTime);\n  \n /*  */\n   dist = min(dist,sdBoxFrame( bp));\n   dist = min(dist,length(bp-0.9)-0.5);\n\nreturn dist;\n}\n\nfloat sdDouble(vec3 p){\n\n  float dist=1000.0;\n   vec3 n = vec3(2.,1.,0.0),\n        fl = vec3(0.0,-3.0,0.0),\n        bp = p;\n       for(float i =1.;i<2.;i++){\n              bp = abs(bp);\n              bp -= 2.0;\n             \n        }  \n      \n        bp.xz *= Rot(iTime*1.5);\n        p.yz *= Rot(iTime);\n        dist = min(dist,length(bp) - 1.29);\n        dist= max(dist, -sdBox( bp, vec3(1.0,1.0,1.0) )   );\n        \nreturn dist;\n}\n\nfloat sdFold(vec3 p){\n  float dist=1000.0;\n  float sx= 1.5, sy= 1.8, sz=2.3;\n // vec3 offs = vec3(s,s,s);\n  float space =1.555;//3.0;//\n  float multipelSpace = 1.0;\n  vec3 bp = p,\n       fv = vec3(1.0,1.0,1.0);\n     bp.xy *= Rot( 0.45);\n     bp.xz *= Rot(iTime* 0.25);\n    //bp.x-=8.;\n for(int i=1;i<4;i++){\n \n  bp.x=abs(bp.x);\n  bp.x-= space*sx;\n  \n }\n for(int i=1;i<2;i++){\n \n  bp.z=abs(bp.z);\n  bp.z-= space*sz;\n  //bp.y -=space; //sin(iTime);\n }\n  bp.y=abs(bp.y);\n  bp.y-= space * sy;\n //bp.y -= 5.0;\n //bp.xz *= Rot(iTime*0.8);bp.yz *= Rot(iTime);\n dist = min(dist,length(bp)-0.3);\n dist = min(dist,sdBoxFrame( bp));\nreturn dist;\n}\n\nfloat sceenSpace(vec3 p){\n   float dist=1000.0;\n   vec3 n = vec3(2.,1.,0.0),\n    fl = vec3(0.0,-3.0,0.0);\n   //dist= min(dist,sdFold(p));\n    dist= min(dist,sdSingleFold( p));\n    \n    dist = min(dist,sceenAxis( p));\n    //dist = min(dist,sdDouble(p));\n    //dist = min(dist,sdCavalette(p+fl)); // Box used like floor\n    return dist;\n}\nfloat GetDist(vec3 p) {\n     float d=1000.0;\n     //d = min(d,sceenAxis( p));// Axis lines,Letters XYZ\n     //d= min(d,SceenTPR(p)); // frame\n     //d = min(d,sdBoxFrame( p)); // Box-frame\n      //d = min(d,sdCavalette(p)); // Box used like floor\n    d = min(d,sceenSpace(p));  // Empty space to populate\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n// This is a LOOK AT ORIGO CAMERA.\n// Parameters: \n//  m Mouse, uv , ro (rayorgin out param), \n//  rodist (focal lenght) , zoom \nvec3 cameraGetRayDir(vec2 m, vec2 uv,  out vec3 ro, \n           float rodist,float zoom )\n{\nfloat phi = m.y * 6.28318 - 1.570796, \n      theta = -m.x * 6.28318;          \nvec3 vdir = vec3(0.0,1.0,0.0),            //normalized \n     nro = vec3(0.0,0.0,-1.0),            //normalized \n     foc,                                 //focal\n     right = vec3(1.0,0.0,0.0),\n     up ;                       \n     right.xz *= Rot(theta);                          \n     vdir.yz *= Rot(phi);                //normalized\n     vdir.xz *= Rot(theta);              //Rotate to view dir normalized\n     up = cross(right,vdir);             //UP normalized\n     foc= vdir * zoom;                   \n     ro = -vdir * rodist;   //ro is an \"out parameter\" position ray orgin\n     vec3 rayDirection = foc + uv.x * right + uv.y* up;\n     return  normalize(rayDirection);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(-9.0, -10.0,9.0);\n    //lightPos.xz *=Rot(iTime*0.2);\n    vec3 lig = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, lig), 0.0, 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., lig);\n    if(d<length(lightPos-p)) dif *= .4;\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    ////////////////////////parameters used by camera\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    float distRo = 25.0;// distanse to origo. change focal length\n    float zoom = 1.60; //aproximate zoom distRo/8.0 to keep size on screen\n                     // Greater value to zoom in.  \n    ///////////////////////////////end camera parameters\n     vec3 rd = cameraGetRayDir( m,uv,ro,distRo,zoom);\n     // note ro (ray orgin ) is passed by \"out parameter\" and used by RayMarch\n     \n     float d = RayMarch(ro, rd); \n    \n     float nuv= uv.y;    \n     vec3 col=vec3(0.4-nuv, 0.3-nuv , 0.4- nuv*0.1);\n    \n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        float dif=GetLight( p);\n        col = vec3(dif,dif,0.95*dif);\n    }\n   \n    fragColor = vec4(col,1.0);\n \n}","name":"Image","description":"","type":"image"}]}