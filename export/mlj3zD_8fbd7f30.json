{"ver":"0.1","info":{"id":"mlj3zD","date":"1673465147","viewed":181,"name":"VoronoiUVCoord","username":"MindToast451","description":"Voronoi uv coordinates. This is my first decent attempt at making some voronoi that can be used as uv's for texture placement. It works pretty good except for the edges of the cells. The edges create wretched smearing if faded.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n==== glenjohnsonart.com ====\nThis could be a very useful shader for many effects. \nOriginally I was developing this for creating details for a model of the sun.\nPlug this into a texture for some cool animated and varied tiling effects.\nHaving blended edges would be super useful, but I'm trying to work that out.\nIt works well with hard edges, or if you output noise without the uv color and use it to mask the edges.\nLet me know if you find this usefull as I have other 3d versions.\n\n*/\n\nvec4 hash4( vec2 p )\n{\n     return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 VoronoiUV(vec2 uv)\n{\n\n    float cellScale = 8.;\n    vec3 res = vec3(cellScale, cellScale, cellScale);\n    uv = uv * cellScale;\n    vec2 uvOffset = vec2(0.0,0.0);\n    float v = smoothstep( 0.4, 0.6, sin(iTime) );\t\n    vec3 col = vec3(0.);\n\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n    \n    // iq voronoise\n    float ua = 1.;\n    float vva = 4.;\n\tfloat k = 1.0 + 63.0*pow(2.0-vva,4.0);\n\tfloat vaa = 0.0;\n    float wtt = 0.0;     \n    // ---   \t   \t\n    \n\tfloat w1 = 0.0;\n    float w2 = 0.0;\n    vec3 va = vec3(0.0, 0.0, 0.0);\n    \n    float m_dist = 1.;    \n\t\n    vec4 m = vec4(0,0,0,1.);\n    vec2 mv = vec2(0,0);\n    for( int j=-3; j<=3; j++ )\n    for( int i=-3; i<=3; i++ )\n    {\n    \n        vec2 g = vec2( float(i),float(j) );\n        vec2 oN = random2(p + g);\n        vec2 ptt = random2(p + g);\n        vec2 ranRot = ptt;\n        ptt = .5 + .5*sin(iTime + 6.2831*ptt);\n        vec2 oo = .5 + .5*sin(6.2831*ptt );\n        \n        vec2 diff = g + ptt - f;\n        \n        float cellShrink = 1. + (ptt.x * (2.*oo.x));\n        float dist = length(diff * cellShrink);\n        m_dist = min(m_dist,dist);\n        \n            \n        col = vec3(ptt.x, ptt.y, 1.);\n\n        float edgeBlur = 0.1;\n        float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (m.w - dist)/pow(sin(oo.x) * .1 + edgeBlur, 1.0));\n        m.w = mix(m.w, dist, h);\n        //m.xyz = lerp(m.xyz, float3(mv.y, mv.x, res.x), h);\n        m.xyz = mix(m.xyz, col, h);\n         \n        float d = dot(diff, diff);\n              \n        \n        if(d < res.x){\n            res.y = res.x;\n            res.x = d;\n            res.z = ptt.x;\n        }else if (d < res.y){\n            res.y = d;\n        }       \n        \n        // mask\n        float w = exp(-5.0*d );\n        va += w*d;\n\t\tw1 += w;\n        w2 += w*w;\n        \n        // set mv to diff and add uv offset\n        mv = diff;\n        uvOffset = vec2(.0,.0);\n        \n        float rotSpeed = 1. * iTime;        \n        float rA = (ranRot.x - ranRot.y) * 10. * rotSpeed;\n        mat2 rotationMatrix = mat2(cos(rA), -sin(rA), sin(rA),  cos(rA));\n        mv.xy *= rotationMatrix;\n        \n        mv.x += (uvOffset.x + oN.x);\n        mv.y += (uvOffset.y + oN.x);\n        mv.x *= 1.0;\n        \n        m.x = mix(m.x, mv.y, h);\n        \t//m.x = 1.;\n        m.y = mix(m.y, mv.x, h);\n        m.z = mix(m.z, 0.0, h * 2.);        \n    }\n    \n    // Draw the min distance (distance field)\n    float round = 0.;\n    m += (m_dist * round);\n\t\n    col = vec3(m.xyz);\n   \tfloat mean = 0.3;// textureGrad( samp, uv, ddx*16.0, ddy*16.0 ).x;\n    vec3 resb = mean + (va-w1*mean)/sqrt(w2); \n    // Mask  \n    //return vec4(resb.xyz, 1.0f);\n    //return vec4(res.x, res.x,res.x, 1.0f);\n    vec3 resMask = mix(res,resb, 0.0);\n    //return vec4(resMask.x, resMask.x,resMask.x, 1.0f);\n    \n    // Show Voronoise\n    //return vec4((vaa/wtt),(vaa/wtt),(vaa/wtt),1.);\n    \n    // Time varying pixel color\n    //col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0.,2.,4.));\n\n    // Output to screen\n    return vec4(col.xy, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    fragColor = VoronoiUV(uv);\n}","name":"Image","description":"","type":"image"}]}