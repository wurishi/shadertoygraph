{"ver":"0.1","info":{"id":"DtK3Ry","date":"1684224407","viewed":132,"name":"the boundary","username":"Carandiru","description":"[fullscreen for maximum detail]\nhighly detailed view of bluenoise (modified by voronoi animation)  as the space between points rather than the points.\nparallax layers at multiple depths\n\n","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["voronoi","parallax","infinite","bluenoise"],"hasliked":0,"parentid":"NtBSRz","parentname":"voro-bluenoise testing "},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/stfXD8\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// [fullscreen for maximum detail]\n\n// highly detailed view of bluenoise (modified by voronoi animation)  as the space between points rather than the points.\n// parallax layers at multiple depths\n//\n// set scale to a lower value for a wider fov, and to see more parallax layers.\n\n#define SCALE 0.025\n#define SPEED 1.0\n\n#define bitset_size (128)\n#define bitset_row (bitset_size >> 2)\n#define bitset_row_half (bitset_row >> 1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 gap = iResolution.xy * SCALE;\n    \n    vec3 d = vec3(0);\n    \n    // testing and setting 128 bits depending on value <> 0.5\n    uvec4 bitset = uvec4(0u);\n    for (uint y = 0u ; y < 4u ; ++y) {\n        for (uint x = 0u ; x < uint(bitset_row) ; ++x) {\n            \n            // x*y defines \"layer\", scroll and offset\n            vec2 tile = (fragCoord.xy / vec2(x*y) + vec2(float(x) + iTime * SPEED,y));\n            // normalized\n            vec2 tile_uv = (tile / gap);\n\n            vec4 samp = textureLod(iChannel0, tile_uv, 0.0);\n\n            if (samp.r * 2.0f >= 0.5f) {\n                bitset[y] |= (1u << x);\n            }\n            d += samp.gba;\n        }\n    }\n    d /= 128.0f; // (128 >> 2) = 32 / row * 4 rows = 128\n    \n    uvec4 row[4];\n    // unpack 128 bits\n    for (uint y = 0u ; y < 4u ; ++y) {\n    \n        row[y].r = (bitset[y]) & 0xFFu;\n        row[y].g = (bitset[y] >> 8u) & 0xFFu;\n        row[y].b = (bitset[y] >> 16u) & 0xFFu;\n        row[y].a = (bitset[y] >> 24u) & 0xFFu;\n    }\n    \n    vec4 color = vec4(0);\n    \n    uint t = uint(iTime) & 3u;\n    float tf = fract(iTime);\n    \n    // normalize and mix 4 colors\n    color = vec4(row[0]) / 255.0f;\n    color = mix(color, vec4(row[1]) / 255.0f, 0.5f);\n    color = mix(color, vec4(row[2]) / 255.0f, 0.5f);\n    color = mix(color, vec4(row[3]) / 255.0f, 0.5f);\n    \n    color.rgb *= (2.0f * vec3(abs((d.z - d.y) - (d.y - d.x))));\n    \n    vec4 red = vec4(1.0,0.0,tf * 0.99,0.0) * (1.0f - vec4(row[t]) / 255.0f);\n    color += red * sqrt(0.5f*uv.y*0.5f*uv.x);\n    \n    vec3 orig = color.rgb;\n    float maxc = max(color.r, max(color.g, color.b));\n    \n    color.rgb += maxc * color.rgb;\n    color.rgb += pow(color.rgb, vec3(5.0f));\n    color.rgb = mix(color.rgb, orig, 0.5f);\n    \n    // pre-multiply alpha\n    color.rgb *= color.a;\n\n    fragColor = vec4(color.rgb, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/stfXD8\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define SCALE 64.0\n#define SPEED 1.0\n\nvec2 random2( vec2 p ) {\n    return textureLod(iChannel0, (p * iResolution.xy) / (1024.0f * SCALE), 0.0f).rg;\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= SCALE;\n    \n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec4 mDist = vec4(1.0f); // x least point distnace, y 2nd least point distance ....\n    \n    for(int j=-1; j<=1; ++j) {\n        for(int i=-1; i<=1; ++i) {\n            vec2 neighbour = vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            \n            // animate\n            point = 0.5f + 0.5f*sin(SPEED*iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n                        \n            float dist = dot(diff, diff); // lenght^2\n            \n            if(dist < mDist.x) {\n                mDist.w = mDist.z;\n                mDist.z = mDist.y;\n                mDist.y = mDist.x;\n                mDist.x = dist;\n            } \n            else if(dist < mDist.y) {\n                mDist.w = mDist.z;\n                mDist.z = mDist.y;\n                mDist.y = dist;\n            }\n            else if(dist < mDist.z) {\n                mDist.w = mDist.z;\n                mDist.z = dist;\n            }\n            else if(dist < mDist.w) {\n                mDist.w = dist;\n            }\n        }\n    }\n    \n    mDist = sqrt(mDist);\n    \n    float d0 = min(min(mDist.x,mDist.y),\n                   min(mDist.z,mDist.w));\n                  \n    float d = mix(mix(mDist.x,mDist.y,0.5f),\n                  mix(mDist.z,mDist.w,0.5f),0.5f);\n    \n    float d1 = max(max(mDist.x,mDist.y),\n                   max(mDist.z,mDist.w));\n                   \n    float col = 0.0f;\n    \n    // dither / add high frequency details (optional)\n    col = (d - d0) - textureLod(iChannel0, fragCoord/1024.0f, 0.0f).r * (1.0f/255.0f);\n    \n    fragColor = vec4(col, d0, d, d1);\n}","name":"Buffer A","description":"","type":"buffer"}]}