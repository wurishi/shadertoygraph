{"ver":"0.1","info":{"id":"WdfSRS","date":"1551653218","viewed":152,"name":"Ancient Coin","username":"spookyfox","description":"Needed to get this idea out of my head. I need to create perhaps a centerpiece for the coin as well as experiment with parameters for the procedurally generated glyphs. Alas I am sleepy ðŸ’¤.\n\nhttps://upload.wikimedia.org/wikipedia/commons/0/05/Palenque_gly","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tiling","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Many techniques from\n// https://iquilezles.org/articles/distfunctions.\n\nint   AA   = 1;\nfloat PI   = 3.14159265358;\nfloat PID2 = 1.57079632679;\nfloat PIM2 = 6.28318530718;\nfloat RT2  = 1.41421356237;\n\n// Tools\n\nfloat nrand(vec2 n) {\n    // https://www.shadertoy.com/view/4ssXRX\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    if(theta < 0.0) {\n        theta = PIM2 + theta;\n    }\n    return vec2(r, theta);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0));\n}\n\nfloat capsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec2 h) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat tube(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nmat3 rotateX(float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1.0, 0.0, 0.0, 0.0, cx, sx, 0.0, -sx, cx);\n}\n\nmat3 rotateY(float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0.0, -sy, 0.0, 1.0, 0.0, sy, 0.0, cy);\n\n}\n\nmat3 rotateZ(float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, sy, 0.0, -sy, cy, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat smoothMin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat subtract(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat smoothSubtract(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nvec3 bend(vec3 p, float k) {\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xy, p.z);\n}\n\nfloat repeat(float p, float c) {\n    return mod(p, c) - 0.5 * c;\n}\n\nvec4 tex(vec3 p, sampler2D s) {\n    // Inspired by https://www.shadertoy.com/view/4dj3Dw.\n\treturn texture(s, p.yz) + texture(s, p.xz) + texture(s, p.xy);\n}\n\n// Constructions\n\nfloat bars(vec3 p, float r) {\n    float s = 0.3 + 0.1 * r;\n    mat3 rot = rotateZ(PID2);\n    p += vec3(-2, -2.0, 0.8);\n    float d = capsule(rot * p, 3.0, s);\n    p.y += 0.5;\n    d = smoothMin(d, capsule(rot * p, 3.0, s), 0.1);\n    p.y += 0.5;\n    d = smoothMin(d, capsule(rot * p, 3.0, s), 0.1);\n    return d;\n}\n\nfloat wheel(vec3 p, float r) {\n    float d = sphere(p / vec3(1.0, 1.0, 0.5) + vec3(-3.3, 0.7, 0.8), 1.3 + 0.2 * r);\n    d = smoothMin(d, torus(rotateX(PID2) * (p + vec3(-3.3, 0.7, 0.8)), vec2(1.4, 0.2)), 0.3);\n    return d;\n}\n\nfloat glyph(vec3 p, float r) {\n    float d;\n    \n    float head = sphere(p / vec3(0.9, 2.2, 1.0) + vec3(-2.4, 0.0, 0.0), 1.0);\n    \n    float face = sphere(p / vec3(2.0, 1.8, 1.0), 1.0) - sin(p.x) * 0.5;\n    d = smoothMin(head, face, 0.8);\n    \n    float eyelid = sphere(bend(rotateY(-0.1) * rotateZ(r * 0.25) * p + vec3(-0.8, -0.3, 0.8), -0.7 + r) / vec3(1.2, 0.8, 1.0), 0.6);\n    d = smoothMin(d, eyelid, .3);\n    \n    float eye = sphere(p / vec3(1.0, 0.8, 1.0) + vec3(-0.8, 0.1, 0.8), 0.6);\n    d = smoothMin(eye, d, 0.1);\n    \n    vec3 pn = p + vec3(0.6, 0.5, 0.0);\n  \tpn *= rotateY(PI);\n    pn *= rotateZ(-0.3);\n    pn.y = pn.y + pn.x * (30. - pn.x) / 100.;\n    float nose = sphere(pn / vec3(1.0, 1.0, 0.7), 1.0 + r * 0.2) + sin(pn.x) * 0.5;\n    \n    float nostril = sphere(p + vec3(0.2, 0.9, 0.7), 0.5 + r * 0.2);\n    d = smoothMin(d, nose, 0.4);\n    d = smoothMin(nostril, d, 0.6);\n    \n    float hole = sphere(p + vec3(0.2, 1.3, 0.8), 0.2);\n    d = smoothSubtract(hole, d, 0.4);\n    \n    float mouth = sphere(bend(p + vec3(-0.5, 2., 0.0), -0.0) / vec3(1.0, 0.8, 0.8), 1.0 - r * 0.2);\n    d = smoothMin(d, mouth, 0.8);\n    \n    d = smoothMin(d, bars(p, r), 0.6);\n    \n    d = smoothMin(d, wheel(p, r), 0.6);\n    \n    float piece = sphere(bend(rotateZ(PI * 0.6) * (p + vec3(0.1, -1.7, 0.0)), -0.8 + 0.2 * r) / vec3(1.5, 0.7, 1.0), 0.7);\n    d = smoothMin(d, piece, 0.4);\n    \n    return d;\n}\n\nfloat coin(vec3 p) {\n    return cylinder(p, vec2(13.0, 0.8));\n}\n\nfloat rings(vec3 p) {\n    // TODO: Clean up.\n    p = vec3(toPolar(p.xy), p.z);\n    float r = 3.0;\n    p.x = mod(p.x, r) - 0.5 * r;\n    p.x /= r; \n    return tube(p, vec3(0.3, -0.4, 0.85));\n}\n\nfloat glyphs(vec3 p) {\n    // TODO: Clean up.\n    p = vec3(toPolar(p.xy), p.z);\n    p.x -= 0.45;\n    \n    float r = 3.0;\n    float ring = floor(p.x / r);\n    if (ring > 3.0 || ring < 1.0) {\n        return 100000.0;\n\t}\n    p.x = mod(p.x, r) - 0.5 * r;\n    p.x /= r;\n    \n    p.y /= PIM2;\n\tfloat theta = 1.0 / (4.0 * (ring + 2.0));\n    float pos = floor(p.y / theta);\n    p.y = mod(p.y, theta) - 0.5 * theta;\n    p.y /= theta;\n    \n    float f = nrand(vec2(ring, pos));\n \n    return glyph(rotateZ(PID2) * p / vec3(0.11) + vec3(1.5, 0.0, -3.0), f) * 0.11;\n}\n\nfloat map(vec3 p) {\n    float d;\n    \n    //float mx = iMouse.x / iResolution.x;\n    //p *= rotateY(mx * PIM2);\n    p *= rotateY(iTime);\n    \n    float r = 4.0 * PI;\n    d = coin(inverse(rotateX(PID2 + r)) * p);\n    \n    float dh = box(p, vec3(1.0));\n    d = subtract(dh, d);\n    \n    p.z = abs(p.z);\n    p.z -= 1.0;\n    p *= rotateX(PI * 1.0);\n    \n    float dr = rings(inverse(rotateX(r)) * p);\n    d = subtract(dr, d) + tex(p * 0.1, iChannel0).x * 0.1;\n    \n    float dg = glyphs(inverse(rotateX(r)) * p) + tex(p * 0.3, iChannel0).x * 0.02;\n    d = smoothMin(d, dg, 0.2);\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    // https://iquilezles.org/articles/normalsSDF\n    float h = 0.001;\n\tvec2 k = vec2(1.0, -1.0);\n    return normalize(\n        k.xxx * map(p + k.xxx * h) +\n        k.xyy * map(p + k.xyy * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.yyx * map(p + k.yyx * h));\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d;\n    float s = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = ro + rd * s;\n        d = map(p);\n        s += d;\n        if (d < 0.01) {\n            break;\n        }\n    }\n    return vec2(d, s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 c = vec3(0.0);\n    \n    // https://www.shadertoy.com/view/Xds3zN.\n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            vec2 o = vec2(i, j) / float(AA) - 0.5;\n    \t\tvec2 xy = (2.0 * (fragCoord.xy + o) - iResolution.xy) / iResolution.y;\n            \n\t\t\tvec3 ro = vec3(0.0, 0.0, -14.0);\n    \t\tvec3 rd = normalize(vec3(xy, 1));\n            vec2 dp = rayMarch(ro, rd);\n            \n            if (dp.x < 0.01) {\n                vec3 p = ro + rd * dp.y;\n                vec3 l = vec3(-5.0, 5.0, -3.0);\n                vec3 n = normal(p);\n                // Gold\n                // http://devernay.free.fr/cours/opengl/materials.html\n                vec3 kd = vec3(0.75164, 0.60648, 0.22648);\n                vec3 d = vec3(clamp(dot(n, normalize(l - p)), 0.0, 1.0));\n                vec3 ks = vec3(0.628281, 0.555802, 0.366065);\n                float es = 4.0;\n                vec3 v = normalize(ro - l);\n                vec3 h = normalize(v + l);\n                float s = dot(n, l) > 0.0 ? pow(clamp(dot(n, h), 0.0, 1.0), es) : 0.0;\n                //vec3 t = tex(p * 0.3, iChannel0).xyz * 0.2;\n                c += d * kd + s * ks;\n            }\n        }\n    }\n    c /= float(AA * AA);\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}