{"ver":"0.1","info":{"id":"lf3GzB","date":"1733606998","viewed":409,"name":"Directional Gabor Water Noise","username":"gehtsiegarnixan","description":"Fast directional Gabor noise with octaves, to emulate water waves for baking noise textures.","likes":16,"published":3,"flags":0,"usePreview":0,"tags":["noise","wave","sea","simulation","fast","water","cheap","normal","directional","gabor","wind","fractalbrownianmotion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a cheaper variant of gabor noise to make water like waves, but it's also capable \nof creating rain droplets, asteroid craters, and likely more.\n\nThe aim was to make Gabor noise much faster than its default version, allowing it to \nbe used in real-time applications for testing purposes before baking it into a texture. \nI made this analog to Voronoi noise to only sample the 8 neighboring cells and \ncorrected the wavelet amplitude to avoid creating edges. You can either bake it as a \nwhole, or for nice animated waves, you can bake each octave individually instead of \nanimating each wavelet. This allows you to achieve beautiful animated water effects at \na low cost. It seems ~4 octaves are more than enough. This noise is meant for creating \ndynamic water surfaces with directional flow.\n\nThis function comes with various global parameters for tweaking settings and debug views. \nAdmittedly, I'm not fully satisfied with this noise yet, and there are too many \nparameters. Feel free to comment suggestions for improvement. The shader includes mouse \ncontrols using the y-axis to zoom in.\n\nFor a simpler introduction, check out a single wavelet here:\nhttps://www.shadertoy.com/view/XcKGzh\n\nAnd an older implementation of directional flow that could benefit from this noise:\nhttps://www.shadertoy.com/view/7dtBWl\n*/\n\n// Switch SHOW_VALUES to enable different views:\n// 0 = colormap of height\n// 1 = simple Phong lighting of normals\n// 2 = normal vectors with quiver plot\n#define SHOW_VALUES 1\n\n// Add lines for the grid outlines\n#define SHOW_GRID\n\n// Debug view to show a single wavelet of ivec3(Octave, Position.xy)\n//#define SHOW_CELL ivec3(0,1,1)\n\n// Enable repeating tiling for repeating textures\n//#define TILING\n\n// Size of the noise cells for the first octave, range: 1-inf\n#define GRIDSIZE 4.0\n\n// Number of noise layers, range: 1-inf (will impact performance!)\n#define OCTAVES 6\n\n// Scaling of successive octaves GRIDSIZE, range: 1-inf\n#define LACUNARITY 2.0\n\n// Amplitude reduction of each successive octave, range: 0-1\n#define PERSISTENCE 0.5\n\n// Influence of the current octave's derivatives on the next octave's coordinates, range: 0-inf\n#define WAVE_DEFORMATION 2.0\n\n// Uncomment for animated wavelets; otherwise, the octaves move as a whole\n#define ANIMATED_WAVELET\n\n// Maximum variance from the main direction for wavelets, range: 0-1\n#define NOISE_STRENGTH 0.05\n\n// Disable for straight wavelets; the value sets the offset from center (0 makes rain)\n#define ROUNDED 2.0\n\n// Disable for vanilla sinus waves; otherwise, water-like waves\n#define WATER_WAVE\n\n// Nudge the water wave crest towards the movement direction, range: -0.99 to 0.99\n#define PUSH 0.2\n\n// Steepness of the water wave crest, range: 0 to 1 (can be higher)\n#define CREST 0.3\n\n// Simple sine wave for comparison\nfloat sinusWave(float gradient, float wavelength) {\n\n    // scale gradient\n    float frequency = TWO_PI / wavelength;\n    gradient *= frequency;\n    \n    // Calculate wave height at the original gradient\n    return sin(gradient);\n}\n\n// Nudge the x.5 values towards either the closed smaller or larger full number\nfloat nudge(float x, float push) {\n\n    // Rescale push to be a 0-1 value from -1 to 1\n    push = push * 0.5 + 0.5;\n    float grid = fract(x);\n\n    // Moving the half point towards\n    float nudged = 0.5 * clamp(grid          /        push,  0.0, 1.0) + \n                   0.5 * clamp((grid - push) / (1.0 - push), 0.0, 1.0);\n\n    // Add the floor again to negate fract\n    return floor(x) + nudged;\n}\n\n// Wave function controlling the cresent shape, could be better ...\n// See: https://www.desmos.com/calculator/njitivdjjj\nfloat crescent(float gradient, float crest) {\n\n    // approximating cresent shape of gerstner waves\n    float cosValue = cos(gradient);\n    return ((-cosValue - 1.0) / (4.0 * crest * (cosValue - 1.0) - 1.0)) - 1.0;\n}\n\n// More water-like wave height\n// See https://www.desmos.com/calculator/u95gjsesrr\nfloat waterWave(float gradient, float wavelength, float push, float crest) {\n\n    // Gradient calculation using nudge\n    float nudgedGradient = TWO_PI * (nudge(gradient / wavelength, push) + 0.5);\n    \n    // Calculate wave height using crescent function\n    return crescent(nudgedGradient, crest);\n}\n\n// Generates a Gabor wavelet with normals\n// See https://www.shadertoy.com/view/XcKGzh\nfloat wavelet(vec2 position, vec2 direction, float time, float wavelength) {\n\n    // Generate gradient\n    #ifdef ROUNDED                \n        // Offset the wave center for rounded waves\n        vec2 waveCenter = position + direction * ROUNDED;\n        // Maybe the offset should be separate to radius...\n\n        // Calculate the gradient as the distance from the wave center\n        float gradient = length(waveCenter);\n\n        // Direction of the spherical wave\n        vec2 waveDirection = safeNormalize(waveCenter);\n        \n    #else\n        // Calculate the gradient as the dot product with the current direction\n        float gradient = dot(position, direction);\n\n        // Direction of the straight wave\n        vec2 waveDirection = direction;\n    #endif\n\n    // Add time offset\n    // If using realistic waveSpeed, ensure the random time offset allows for one period variation.\n    gradient -= time * wavelength;\n    \n    // Sample wave\n    #ifdef WATER_WAVE\n        // Water-like wave\n        return waterWave(gradient, wavelength, PUSH, CREST);\n    #else\n        // Basic sine wave\n        return sinusWave(gradient, wavelength);\n    #endif\n}\n\n// Function to generate Gabor noise\nfloat gabor(vec2 position, uint gridSize, uvec2 seed, float time) {\n    // Scale the position by the grid size\n    position *= float(gridSize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 cellCoords = floor(position);\n    vec2 fractionalCoords = position - cellCoords;\n    \n    // Initialize the amplitude with zero vector\n    float waves = 0.0;\n    float weightSum = 0.0;\n        \n    // Loop over the 3x3 grid of cells around the current cell\n    for (int offsetX = -1; offsetX <= 1; offsetX++) {\n        for (int offsetY = -1; offsetY <= 1; offsetY++) {\n            // Calculate the offset vector\n            vec2 offset = vec2(offsetX, offsetY);          \n\n            // Current cell and fractional coordinates\n            vec2 currentCell = cellCoords + offset;\n            vec2 currentFractional = fractionalCoords - offset;\n\n            #ifdef TILING\n                // This makes the noise repeat between positions 0 and 1\n                currentCell = mod(currentCell, float(gridSize));\n            #endif\n            \n            // Independent random offset and direction\n            vec4 randomVector = hash42(currentCell + vec2(seed));\n            \n            // Generate a random direction angle\n            float angle = (randomVector.z - 0.5) * TWO_PI * NOISE_STRENGTH;\n            vec2 randomDirection = vec2(sin(angle), cos(angle));\n            \n            // Calculate the position and time offset by random noise\n            vec2 randomFractional = currentFractional - randomVector.xy;\n            float randomTime = time + randomVector.w;\n            \n            // Gauss is slightly prettier, but more expensive\n            #if 0\n                // Apply Gauss Normal distribution to distance with infinite fade\n                float weight = expDecay(dot(randomFractional, randomFractional), 1.0);\n\n                // Generate a mask to prevent weight touching search edges                     \n                vec2 borderMask = smoothstep(0., 1., 1.0 - abs((currentFractional - 0.5) / 1.5));\n                weight *= pow(borderMask.x * borderMask.y, 0.5); // pow optionalt\n                \n            #else \n                // Weight that falls off to 0 at 1\n                float weight = smoothstep(1., 0., length(randomFractional));\n            #endif\n            \n            #ifdef SHOW_CELL\n                if (ivec2(currentCell) == SHOW_CELL.yz) { // Debug setting\n            #endif\n            \n            // Generate Wavelet\n            float waveLength = 1.0; // Maybe parameter but got too many already and 1 is fine\n            float wave = wavelet(randomFractional, randomDirection, randomTime, waveLength);\n            \n            // Add wave and its weights to the waves\n            waves += wave * weight;\n            \n            #ifdef SHOW_CELL\n                } // Debug setting\n            #endif\n            \n            // Add weights\n            weightSum += weight;\n        }\n    }\n    \n    // Use a soft normalization factor that avoids harsh transitions and preserves variation\n    const float weightMax = 2.0; // Maybe be parameter but messes with normals, so maybe not\n    float softSum = smoothMin(weightSum, weightMax, -0.5); // smoothMax\n    \n    // Safe normalization, so check if sum is greater than a tiny threshold (only if weightMax = 0)\n    if (weightSum > SMALLEST_FLOAT) {    \n        return waves / softSum;        \n    } else {\n        return 0.0;\n    }\n}\n\n// Function for generating Gabor noise with two slightly offset neighbors\nvec3 gaborDDXY(vec2 position, float gridSize, uvec2 seed, float time) {\n\n    // Adjust tiny epsilon offset based on the grid size\n    float epsilon = 1.0 / (1024.0 * gridSize); // 1024 is abitrary\n    \n    // Sample 3 positions offset by small epsilon\n    float height =  gabor(position,                      uint(gridSize), seed, time);\n    float heightX = gabor(position + vec2(epsilon, 0.0), uint(gridSize), seed, time);\n    float heightY = gabor(position + vec2(0.0, epsilon), uint(gridSize), seed, time);\n    \n    // Calculate the partial derivatives\n    vec2 DDXY = (height - vec2(heightX, heightY));\n    \n    return vec3(height, DDXY); // Height and partial derivatives\n}\n\n// 2D Gabor Noise with Octaves\nvec4 octaveNoise(vec2 position, float gridSize, float time, int octaves, \n    float lacunarity, float persistence, float waveDeformation, uvec2 seed) {\n    \n    // Initialize the variables    \n    // For amplitude math, see: https://www.desmos.com/calculator/xgqeepapwn\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    vec3 heightDDXY = vec3(0.0); // height, partial derivative in XY direction\n    \n    // For each octave\n    for(int i = 0; i < octaves; ++i) {\n        \n        #ifdef SHOW_CELL\n            // Debug setting to only show one sampled cell\n            if (i == SHOW_CELL.x) {\n        #endif\n                \n        // Sample noise and apply amplitude\n        #ifdef ANIMATED_WAVELET\n            // With animated wavelets    \n            vec3 currentHeightDDXY = gaborDDXY(position, gridSize, seed, time) * amplitude;\n        #else \n            // With animated octaves\n            vec2 offset = vec2(0, time) / gridSize; // Not realistic!\n            vec3 currentHeightDDXY = gaborDDXY(position - offset, gridSize, seed, 0.0) * amplitude;\n        #endif  \n        \n        // Apply normal offset scaled by waveDeformation\n        position += currentHeightDDXY.yz * waveDeformation;\n        \n        // Add height and partial derivatives to result\n        heightDDXY += currentHeightDDXY;\n        \n        #ifdef SHOW_CELL\n            } // Closing debug setting\n        #endif\n                        \n        // Add up amplitude to normalize the result later\n        amplitudeSum += amplitude;\n        \n        // Increase frequency for the next octave\n        gridSize *= lacunarity;\n        \n        // Decrease amplitude for the next octave\n        amplitude *= persistence;\n        \n        // Change seed/offset noise so it is unique for the next octave\n        seed += uvec2(gridSize);\n    }\n    \n    // Normalize the result and the derivatives to 0-1 range\n    heightDDXY /= amplitudeSum;\n    \n    // Calculate the normal from partial derivative sum\n    float normalStrength = 256.0; // Maybe should be a variable\n    vec3 normal = normalize(vec3(heightDDXY.yz * normalStrength, 1.0));\n    \n    return vec4(normal, heightDDXY.x); // Normal in XYZ and height in W\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Square UVs with (0.5,0.5) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5; \n    \n    // If the mouse was not clicked, animate\n    float zoom = 1.1;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomSteps = 10.0;\n        float mouseZoom = (floor(mouse.y * zoomSteps) + \n                           smoothstep(0.75, 1.0, fract(mouse.y * zoomSteps))) \n                           / zoomSteps;\n        zoom = mix(1.8, 0.01, mouseZoom);\n    }\n    \n    // Apply zoom on coordinates (0.5,0.5) point\n    uv = (uv - 0.5) * zoom + 0.5;\n    \n    // animation speed of the waves\n    float time = iTime * 0.2;\n    \n    // Sample noise\n    vec4 noise = octaveNoise(uv, GRIDSIZE, time, OCTAVES, \n        LACUNARITY, PERSISTENCE, WAVE_DEFORMATION, uvec2(42071));\n    float height = noise.w;\n    vec3 normal = noise.xyz;\n    \n    #if SHOW_VALUES == 0\n        // Show height as colormap\n        vec3 color = viridis(height * 0.5 + 0.5);\n        \n    #elif SHOW_VALUES == 1\n        // Make base color slightly blueish based on height\n        vec3 color = mix(vec3(0.043,0.353,0.400), vec3(0.102,0.953,1.000), height * 0.5 + 0.5);\n        \n        // Apply lighting to show the normals too\n        const vec3 lightDir = normalize(vec3(1, 1, 0.5));\n        const vec3 ambientLight = vec3(0.000,0.192,0.482);\n        const vec3 sunColor = vec3(1.000,0.925,0.702);\n        color = phongLighting(color, normal, vec3(0,0,1), lightDir, ambientLight, sunColor, 1.0);\n        \n    #elif SHOW_VALUES == 2\n        // Show normals as 0-1 color\n        vec3 color = normal * 0.5 + 0.5;\n        \n        // Debug quiver plot for the normals\n        float maxGridSize = GRIDSIZE * pow(LACUNARITY, min(2.0, float(OCTAVES)));\n        color *= 1.0 - quiverPlot(uv, normal.xy, maxGridSize * 2.0);  \n    #endif\n    \n    #ifdef SHOW_GRID\n        // Add lines on the edges of the grid        \n        vec2 grid = abs(fract(uv) * 2.0 - 1.0);\n        float lines = 1.-max(grid.x, grid.y);\n        float aa = fwidth(lines);\n        float thickness = 0.01;\n        color *= smoothstep(thickness -aa, thickness +aa, lines);  \n    #endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// CONSTANTS ___________________________________________________________\n#define TWO_PI  6.28318530718\n#define SMALLEST_FLOAT (1.0 / float(0xffffffffU))\n\n// GENERIC FUNCTIONS ___________________________________________________\n\n// Safe Normalization using dot product and square root\nvec2 safeNormalize(vec2 vector) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLEST_FLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a default vector\n        return vec2(0,1);\n    }\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME uvec4(3480082861U, 2420690917U, 2149110343U, 1317666547U)\nvec4 hash42(vec2 p) {\n    uvec4 n = uvec4(p.xyxy) * VPRIME;\n    n = (n.x ^ n.y ^ n.z ^ n.w) * VPRIME.yzwx;\n    return vec4(n) * SMALLEST_FLOAT;\n}\n\n// Calculate the kinda Gaussian normal distribution value. Result at radius is 0.05\n#define LN_005 -2.99573227355 // negative natural logarithm of 0.05\nfloat expDecay(float sqrtdist, float radius) {\n\n    // Exponential decay formula\n    return exp(LN_005 * sqrtdist / (radius * radius));\n}\n\n// smooth Min for softness > 0 and max softness < 0. Softness range is -1 to 1\n// See: https://www.desmos.com/calculator/a4z1ospiqg\nfloat smoothMin(float a, float b, float softness) {\n    float transition = clamp(0.5 + 0.5 * (a-b) / softness, 0.0,1.0);\n    return mix(a, b, transition) - softness * transition * (1.0 - transition);\n}\n\n// LIGHTING FUNCTIONS _______________________________________________\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir, \n                   vec3 ambientLightColor, vec3 sunColor, float specularStrength) {\n    // Ambient\n    vec3 ambient = ambientLightColor * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 8.0);\n    vec3 specular = specularStrength * spec * sunColor;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// DEBUG FUNCTIONS _________________________________________________\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n\n    // constants that maybe should be input variables\n    const float lineThickness = 0.03;    // Thickness of the arrow line\n    const float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    const float maxSize = 0.8;           // Maximum arrow length (1 should be the max)\n    const float minSize = 0.1;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the direction vector length is almost 0\n    if (lenSq > SMALLEST_FLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        //return step(arrowDist, 0.0); // no AA\n        float blur = (gridSize * 1.0)/(size * 1080.);\n        return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}\n","name":"Common","description":"","type":"common"}]}