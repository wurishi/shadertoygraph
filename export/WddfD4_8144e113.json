{"ver":"0.1","info":{"id":"WddfD4","date":"1605140926","viewed":190,"name":"Moving circles illusion","username":"Corstiaan","description":"Recreating the crazy circle illusion in code.\nclick and drag to change direction","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// AntiAlias, scale with UV scale\nfloat aa(float localScale)\n{\n    float smoothness = 3.0;\n    return smoothness/iResolution.x*localScale*SCALE;\n}\n\n// SDF\nfloat sdfPoint(vec2 p)\n{\n    return length(p);\n}\n\nfloat sdfElipse(vec2 p, vec2 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Mask\nfloat Circle(vec2 p, float r, float blur)\n{\n    return 1.-thresh(length(p), r, aa(blur*1.5));\n}\n\nfloat Ring(vec2 p, vec2 radii, float blur)\n{\n    return band(length(p), radii.x, radii.y, aa(blur*1.5));\n}\n\nfloat Section(vec2 p, float degRot, vec2 degAngl, float repeat, float blur)\n{\n    degAngl += vec2(degRot * repeat);\n    degAngl = vec2(mod(degAngl.x, 360.), mod(degAngl.y, 360.));\n    \n    // draw smallest distance, inverse output if needed\n    float a1 = min(degAngl.x, degAngl.y);\n    float a2 = max(degAngl.x, degAngl.y);\n    \n    // halve delta (a2 and a2 in degrees)\n    float da = (a2-a1) / 2.;\n\n    // rotate to opposite of angles to give room to blur and aa\n    float rot = 180. + a1 + da;\n    p = Polar(p, -radians(rot/repeat));\n    \n    // repeat\n    p.y = fract(p.y/TWO_PI * repeat)*TWO_PI;\n    \n    // counter rotate angle to be on both sides of 180\n    a1 = mod(radians(180. - da),360.);\n    a2 = mod(radians(180. + da),360.);\n    \n    // scale antialias to radius (no division by zero)\n    float ab = p.x < 0.0000001 ? 2.*PI : (blur/p.x) / 2.*PI;\n    \n    float aa = aa(ab * repeat);\n    float sections;\n    \n    // which part to draw?\n    if (degAngl.y >= degAngl.x) sections =     band(p.y, a1, a2, aa);\n    else\t\t\t\t\t    sections = 1.- band(p.y, a1, a2, aa);\n    \n    return clamp(sections, 0., 1.);\n}\n\n\nfloat Elipse(vec2 p, float rot, vec2 r, float width, float sharp)\n{\n    p *= rot2d(rot);\n    return band(sdfElipse(p, r), 0.0, width, sharp);\n}\n\nfloat tween(float t, float start, float end)\n{\n    t =  max(0., min(1.,t));\n    return start + t * (end - start);\n}\n\nfloat tLoopOffset(float duration, float offset)\n{\n    return fract((iTime * SPEED - offset) / duration);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    UV *= SCALE;\n    vec2 mouse = (iMouse.xy / iResolution.xy) - 0.5;\n    vec2 cntr = vec2(0.);\n    vec3 brightness = vec3(0.5);\n    float blur = 1.;\n\n    // colors\n    vec4 col = \t  vec4(0.5,\t\t   0.4921875,  0.5, \t   1.0); // background\n    vec3 YELLOW = vec3(0.98046875, 0.76171875, 0.18359375);\n    vec3 BLUE =   vec3(0.08984375, 0.24609375, 0.8046875);\n\n    // time for rotation (1sec, normalized)\n    float nRotation = tLoopOffset(1.0, 0.); // seconds per rotation\n    \n    // play with this, is fun. (keep it an even number)\n    // 4 for the original, 10 is fun.\n    float nrofSections = 8.;\n    \n    // size of the 'edge' with cause the illusion\n    float maxRingOffset = .005;\n    // react to mouse\n    vec2 ringOffset = vec2(mouse.x * maxRingOffset, mouse.y * maxRingOffset);\n    \n    float ringA = Ring(UV + ringOffset, vec2(0.270, 0.400), blur);\n    float ringB = Ring(UV - ringOffset, vec2(0.270, 0.400), blur);\n    \n    float[] sections = float[4](0.,0.,0.,0.);\n    for (float i = 0.; i < 4.; i++) sections[int(i)] = Section(UV, nRotation * 360., vec2(i * 90.-blur, i * 90.+blur + 90.), nrofSections * 0.5, blur);\n    \n    vec4 shapes = vec4(0.);\n    \n    // back\n    shapes = blend(shapes, vec4(YELLOW, 1.), sections[0] * ringA);\n    shapes = blend(shapes, vec4(YELLOW, 1.), sections[1] * ringB);\n    shapes = blend(shapes, vec4(BLUE,   1.), sections[2] * ringA);\n    shapes = blend(shapes, vec4(BLUE,   1.), sections[3] * ringB);\n    \n    // front\n    shapes = blend(shapes, vec4(BLUE,   1.), sections[0] * ringB);\n    shapes = blend(shapes, vec4(BLUE,   1.), sections[1] * ringA);\n    shapes = blend(shapes, vec4(YELLOW, 1.), sections[2] * ringB);\n    shapes = blend(shapes, vec4(YELLOW, 1.), sections[3] * ringA);\n    \n    col = blend(col, shapes, shapes.a);\n\t    \n    // Output to screen\n    vec4 tex = texture(iChannel0, UV) * 0.8;\n    fragColor = col; // blendAdd(tex, col * col.w, 0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n#define sat(a) clamp(a,0.,1.)\n\nconst float SPEED = 0.8;\nconst float SCALE = 1.0;\nconst vec3 BRIGHTNESS = vec3(1.);\nconst vec4 BLUE = vec4(0.398,0.808,1.0, 1.0);\nconst vec4 WHITE = vec4(1.);\n\nfloat sgm(float f)\n{\n    float a = 15.;\n    return 1.0/(1.0 + exp(-(f-0.5)*a));\n}\n\nfloat clamp01(float n)\n{\n    return clamp(n,0.,1.);\n}\n\nfloat easeInQuad(float t) \n{\n    return t*t;\n}\n    \nmat2 rot2d(float deg)\n{\n    float rad = radians(deg);\n    return mat2(cos(rad), -sin(rad),\n                sin(rad), cos(rad));\n}\n\nvec2 Polar(vec2 p, float radRot)\n{\n    float rho = length(p);\n    float phi = fract((atan(p.y, p.x) + PI + radRot)/TWO_PI)*TWO_PI;\n    \n    return vec2(rho, phi);\n}\n\nvec4 blend(vec4 bot, vec4 top, float p)\n{\n \tvec3 bot2 = pow(bot.rgb, vec3(2.2));\n    vec3 top2 = pow(top.rgb, vec3(2.2));\n    float alpha = mix(bot.a, top.a, p);\n    \n    return vec4(pow(mix(bot2, top2, p), vec3(1.0 / 2.2)), alpha);\n}\n\nvec4 blendAdd(vec4 bot, vec4 top, float factor)\n{\n    float glow = 0.;\n    \n    top.rgb *= factor;\n    top.a *= (1.-glow) * factor;\n\n    vec3 rgb = top.rgb + (bot.rgb * (1.0 - top.a));\n    float a = top.a   + (bot.a   * (1.0 - top.a));\n\n    return vec4(rgb, a);\n}\n\nfloat thresh(float base, float val, float blur)\n{\n    // divides a gradient 0-1 in black and white with:\n    // base: the gradient / coordinate system\n    // val: middle of the threshold\n    // width: width of the threshold\n    return smoothstep(val-(blur/2.), val+(blur/2.), base);\n}\n\nfloat thick(float base, float val, float width, float blur)\n{\n    // 'thickness' around value\n    return 1. - thresh(abs(base - val) - width * 0.5, 0., blur);\n}\n\nfloat band(float base, float valA, float valB, float blur)\n{\n    // similar to thick but with to endpoints\n    return thick(base, (valB + valA) * 0.5, valB - valA, blur);\n}","name":"Common","description":"","type":"common"}]}