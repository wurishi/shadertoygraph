{"ver":"0.1","info":{"id":"X3fGRs","date":"1707982001","viewed":237,"name":"Production-ready atmosphere","username":"lowellcamp","description":"A hopefully easy to follow implementation of Unreal Engine's Production Ready Atmosphere, which renders atmospheres with arbitrary density distributions with minimal performance impact.\nRef: https://sebh.github.io/publications/egsr2020.pdf","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 skyView(float x, float r, float mu);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord / iResolution.xy);\n    \n    float r = mix(PLANET_RADIUS, ATMOSPHERE_RADIUS, smoothstep(0.0, 0.8, iMouse.y/iResolution.y - 0.1));\n    if (iMouse.xy == vec2(0.0)) {\n        r = PLANET_RADIUS + 0.1;\n    }\n    // mu: dot(viewDir, up)\n    float mu = uv.y * 2.0 - 1.0;\n    \n    \n    fragColor = vec4(skyView(uv.x, r, mu), 1.0);\n    // Uncomment to view the lookup tables\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord) / 2, 0); // The LUTs\n    \n    fragColor.rgb = ACES(fragColor.rgb);\n    \n    // Intense dither for very gradual gradients\n    float noise = texelFetch(iChannel1, ivec2(fragCoord) % 1024, 0).x;\n    fragColor.rgb += remap_tri(noise) * (1.0 / 63.0);\n}\n\n\n\nvec3 skyView(float x, float r, float mu) {\n    // Move detailed region to horizon's location\n    float horizon_sin = PLANET_RADIUS / r;\n    \n    float h_mu = -sqrt(1.0 - horizon_sin * horizon_sin);\n    \n    float y_max = sqrt(1.0 - h_mu);\n    float y_min = -sqrt(abs(-1.0 - h_mu));\n    \n    float y = (sign(mu - h_mu) * sqrt(abs(mu - h_mu)) - y_min) /\n        (y_max - y_min);\n    \n    vec2 uv = pixel_region(vec2(x, y), ivec2(iResolution.xy), SKYVIEW_RESOLUTION, SKYVIEW_ORIGIN);\n    return texture(iChannel0, uv).rgb;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ATMOSPHERE SETTINGS ============================================\n\n#define SUN_COLOR vec3(100.0)\n#define MOON_COLOR vec3(5.0)\n\n#define PLANET_RADIUS 6348.0\n#define ATMOSPHERE_DENSITY 1.0\n#define MIE_BOOST 1.0\n\n// Falloff for the various scattering types in km\n#define RAYLEIGH_FALLOFF 8.0\n#define MIE_FALLOFF 1.2\n#define OZONE_HEIGHT 25.0 \n#define OZONE_WIDTH 15.0\n\n// Unused here; translates from program to planetary units.\n#define ATMOSPHERE_UNIT 1000.0 \n\n// Only for preview purposes; not necessary for any 32-bit buffers.\n#define INDIRECT_MULTIPLIER 50.0\n\n\n// OTHER CONSTANTS ================================================\n\n#define TRANSMITTANCE_RESOLUTION ivec2(256, 64)\n#define SKYVIEW_RESOLUTION ivec2(256, 128)\n#define SKYVIEW_ORIGIN ivec2(0, TRANSMITTANCE_RESOLUTION.y)\n#define MULTISCATTER_RESOLUTION ivec2(32, 32)\n#define MULTISCATTER_ORIGIN ivec2(TRANSMITTANCE_RESOLUTION.x, 0)\n\n\n#define ATMOSPHERE_RADIUS (PLANET_RADIUS + RAYLEIGH_FALLOFF * log(256.0))\n#define SKY_H sqrt(ATMOSPHERE_RADIUS * ATMOSPHERE_RADIUS - PLANET_RADIUS * PLANET_RADIUS)\n\n\n#define ATM_REAL_DENSITY (ATMOSPHERE_DENSITY * 44.64 * 10e-6)\nconst vec3 rayleigh_scatter = vec3(5.802, 13.558, 33.1) * ATM_REAL_DENSITY;\nconst vec3 rayleigh_extinction = rayleigh_scatter;\n\nconst vec3 mie_scatter = vec3(3.996) * ATM_REAL_DENSITY * MIE_BOOST;\nconst vec3 mie_absorb = vec3(4.40) * ATM_REAL_DENSITY * MIE_BOOST;\nconst vec3 mie_extinction = mie_scatter + mie_absorb;\n\nconst vec3 ozone_absorb = vec3(0.650, 1.881, 0.085) * ATM_REAL_DENSITY;\nconst vec3 ozone_extinction = ozone_absorb;\n#undef ATM_REAL_DENSITY\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define GOLDEN_ANGLE 2.39996322972865332\n\n// Safe unsigned divisor\n#define d0u(x) max(x, 1e-8)\n#define d0(x) ((x) + 1e-7 * (step(0.0, x) - 0.5))\n// Convert a UV range so that no extrapolation occurs\n#define safeRange(uv, resolution) (((uv) - 0.5 / (resolution)) / (1.0 - 1.0 / (resolution)))\n#define unitRange(uv, resolution) ((0.5 / (resolution)) + (uv) * (1.0 - 1.0 / (resolution)))\n\n// Sample the safe range of a pixel region\nvec2 pixel_region( \n    vec2 uv, \n    ivec2 resolution, // The resolution of the texture to sample\n    ivec2 region_size, // The size of the region to sample\n    ivec2 region_origin // The lower corner of the region\n) {\n    // The safe range of the specified region in pixels\n    vec2 pixelPos = uv * (vec2(region_size) - 1.0) + vec2(region_origin) + 0.5;\n\n    return pixelPos / vec2(resolution);\n}\n\n// The UV coordinates of a pixel region,\n// where UVs at region_origin with UV (0.0, 0.0)\n// and the last pixels inside the region w/ UV (1.0, 1.0)\n#define region_uv(pixelPos, region_size, region_origin) (vec2((pixelPos) - (region_origin)) / vec2((region_size) - 1))\n\n// Remaps uniformly distributed noise into triangle-distributed noise in the [-0.5, 1.5] range.\n// Ref: https://www.shadertoy.com/view/4t2SDh\nfloat remap_tri( float noise )\n{\n\n    // Convert uniform distribution into triangle-shaped distribution.\n    float orig = noise * 2.0 - 1.0;\n    noise = orig * inversesqrt(abs(orig));\n    noise = max(-1.0, noise); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!\n    noise -= sign(orig) + 0.5;\n    \n    // Result is range [-0.5,1.5] which is\n    // useful for actual dithering.\n    return noise;\n}\n\n\n// DENSITY FUNCTIONS ==============================================\n\nstruct DensityLayer {\n    float exp_term;\n    float exp_scale;\n    float linear_term;\n    float constant_term;\n};\n\nstruct DensityProfile {\n    float h_ref;\n    DensityLayer lower;\n    DensityLayer upper;\n};\n\nconst DensityProfile rayleigh_density = DensityProfile(\n    0.0,\n    DensityLayer(0.0, 0.0, 0.0, 1.0),\n    DensityLayer(1.0, -1.0 / float(RAYLEIGH_FALLOFF), 0.0, 0.0)\n);\n\nconst DensityProfile mie_density = DensityProfile(\n    0.0,\n    DensityLayer(0.0, 0.0, 0.0, 1.0),\n    DensityLayer(1.0, -1.0 / float(MIE_FALLOFF), 0.0, 0.0)\n);\n\nconst DensityProfile ozone_density = DensityProfile(\n    OZONE_HEIGHT,\n    DensityLayer(0.0, 0.0,  1.0 / float(OZONE_WIDTH), 1.0),\n    DensityLayer(0.0, 0.0, -1.0 / float(OZONE_WIDTH), 1.0)\n);\n\nfloat getLayerDensity(const DensityLayer layer, const float height_rel) {\n    float density = (\n        layer.exp_term * exp(layer.exp_scale * height_rel) +\n        layer.linear_term * height_rel +\n        layer.constant_term\n    );\n    return clamp(density, 0.0, 1.0);\n}\n\nfloat getProfileDensity(const DensityProfile profile, const float height) {\n    float height_rel = height - profile.h_ref;\n    return height_rel > 0.0 ?\n        getLayerDensity(profile.upper, height_rel) :\n        getLayerDensity(profile.lower, height_rel);\n}\n\n// RAY STRUCT =====================================================\n\nstruct RayInfo {\n    float r; // Radius at the ray origin\n    float r2;\n    float mu; // dot(rayDir, up)\n    float rMu; // -t_closest\n    float d2; // Square of the closest distance between the line and the center of the planet\n};\n\nRayInfo new_RayInfo(const float r, const float r2, const float mu) {\n    return RayInfo(\n        r,\n        r2,\n        mu,\n        r * mu,\n        r2 * (1.0 - mu * mu)\n    );\n}\n\nRayInfo reverse(const RayInfo ray) {\n    return RayInfo(\n        ray.r,\n        ray.r2,\n        -ray.mu,\n        -ray.rMu,\n        ray.d2\n    );\n}\n\nRayInfo stepRay(const RayInfo ray, const float dist) {\n    float r2 = ray.r2 + 2.0 * dist * ray.rMu + dist * dist;\n    float r = sqrt(r2);\n    float mu = clamp((ray.rMu + dist) / r, -1.0, 1.0);\n    \n    return RayInfo(\n        r,\n        r2,\n        mu,\n        ray.rMu + dist,\n        ray.d2\n    );\n}\n\nRayInfo stepRay(const RayInfo ray, const float dist, const float rMu_sun, const float VoL, out RayInfo sun_i) {\n    RayInfo ray_i = stepRay(ray, dist);\n    float mu_sun_i = clamp((rMu_sun + dist * VoL) / ray_i.r, -1.0, 1.0);\n    sun_i = new_RayInfo(ray_i.r, ray_i.r2, mu_sun_i);\n    return ray_i;\n}\n\n\n// SPHERE INTERSECTIONS ==========================================\n\nbool intersects(const RayInfo ray, const float r_intersect) {\n    return ray.r < r_intersect || (r_intersect * r_intersect >= ray.d2) && ray.mu <= 0.0;\n}\n\n// Distance for a ray segment to enter a sphere.\n// Returns -1 if it doesn't.\nfloat distToEnter(const RayInfo ray, const float r_intersect) {\n    //if (ray.r < r_intersect) return -1.0; // Can't enter if it's inside\n    //if (ray.mu > 0.0) return -1.0; // Can't enter if it's pointed away\n    float discriminant = (r_intersect * r_intersect) - ray.d2;\n    //if (discriminant < 0.0) return -1.0; // Can't enter if it never gets close enough\n    \n    return max(-ray.rMu - sqrt(d0u(discriminant)), 0.0);\n}\n\n// Distance for a ray to exit a sphere.\n// Returns -1 if it doesn't.\nfloat distToExit(const RayInfo ray, const float r_intersect) {\n    //if (ray.r > r_intersect && ray.mu > 0.0) return -1.0; // Can't exit if it never enters from outside\n    float discriminant = (r_intersect * r_intersect) - ray.d2;\n    //if (discriminant < 0.0) return -1.0; // Can't exit if it never gets close enough\n\n    return max(-ray.rMu + sqrt(d0u(discriminant)), 0.0);\n}\n\nfloat rayLength(RayInfo ray, out bool intersects_ground) {\n    intersects_ground = intersects(ray, PLANET_RADIUS);\n    float ray_length;\n    if (intersects_ground) {\n        ray_length = distToEnter(ray, PLANET_RADIUS);\n    } else {\n        ray_length = distToExit(ray, ATMOSPHERE_RADIUS);\n    }\n    \n    return ray_length;\n}\n\n// PHASE FUNCTIONS ================================================================\n\nfloat rayleighPhaseFunction(const float nu) {\n    float k = 3.0 / (16.0 * PI);\n    return k * (1.0 + nu * nu);\n}\n\nfloat miePhaseFunction(const float g, const float nu) {\n    float k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);\n    return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);\n}\n\n\n\n// SAMPLING TRANSMITTANCE =========================================================\n\n#define transmittanceOut(ray, intersects_ground) _transmittanceOut(ray, intersects_ground, iChannel0, ivec2(iResolution.xy))\nvec3 _transmittanceOut(RayInfo ray, bool intersects_ground, sampler2D lut_tex, ivec2 iResolution) {\n    if (intersects_ground) return vec3(0.0);\n    \n    float toHorizon = sqrt(ray.r2 - PLANET_RADIUS * PLANET_RADIUS);\n\n    float d = distToExit(ray, ATMOSPHERE_RADIUS);\n    float d_min = ATMOSPHERE_RADIUS - ray.r;\n    float d_max = toHorizon + SKY_H;\n\n    vec2 x_muR = vec2(\n        (d - d_min) / (d_max - d_min),\n        toHorizon / SKY_H\n    );\n\n    vec2 uv = pixel_region(x_muR, ivec2(iResolution.xy), ivec2(TRANSMITTANCE_RESOLUTION), ivec2(0));\n    \n    return texture(lut_tex, uv).rgb;\n}\n\n#define transmittanceBetween(a, b, intersects_ground) _transmittanceBetween(a, b, intersects_ground, iChannel0, ivec2(iResolution.xy))\nvec3 _transmittanceBetween(RayInfo a, RayInfo b, bool intersects_ground, sampler2D lut_tex, ivec2 iResolution) {\n    if (intersects_ground) {\n        return min(\n            _transmittanceOut(reverse(b), false, lut_tex, iResolution) /\n            _transmittanceOut(reverse(a), false, lut_tex, iResolution),\n            vec3(1.0)\n        );\n    }\n    return min(\n        _transmittanceOut(a, false, lut_tex, iResolution) /\n        _transmittanceOut(b, false, lut_tex, iResolution),\n        vec3(1.0)\n    );\n}\n\n// TONEMAPPING ================================================================\n\nvec3 ACES(vec3 v) {\n   v *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// TRANSMITTANCE LUT ==============================================\n#define TRANSMITTANCE_SAMPLES 16\n\nRayInfo uv2RayInfo(vec2 uv);\nvec3 calcTransmission(RayInfo ray);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = region_uv(ivec2(fragCoord), TRANSMITTANCE_RESOLUTION, ivec2(0));\n    \n    if (any(notEqual(uv, clamp(uv, 0.0, 1.0)))) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        return;\n    }\n    \n    \n    RayInfo ray = uv2RayInfo(uv);\n    fragColor = vec4(calcTransmission(ray), 1.0);\n}\n\nRayInfo uv2RayInfo(vec2 uv) {\n    float x_mu = uv.x;\n    float x_r = uv.y;\n    \n    float toHorizon = SKY_H * x_r;\n    float r2 = toHorizon * toHorizon + PLANET_RADIUS * PLANET_RADIUS;\n    float r = sqrt(r2);\n\n    float d_min = ATMOSPHERE_RADIUS - r;\n    float d_max = toHorizon + SKY_H;\n    float d = d_min + x_mu * (d_max - d_min);\n\n    float mu = d == 0.0 ? 1.0 : (SKY_H * SKY_H - toHorizon * toHorizon - d * d) / (2.0 * r * d);\n    mu = clamp(mu, -1.0, 1.0);\n    \n    return new_RayInfo(r, r2, mu);\n}\n\nvec3 calcTransmission(RayInfo ray) {\n    if (intersects(ray, PLANET_RADIUS)) return vec3(0.0, 0.0, 0.0);\n    float stepDist = distToExit(ray, ATMOSPHERE_RADIUS) / float(TRANSMITTANCE_SAMPLES);\n\n    float rayleigh_depth = 0.0;\n    float mie_depth = 0.0;\n    float ozone_depth = 0.0;\n\n    float dist = 0.0;\n    for (int i = 0; i < TRANSMITTANCE_SAMPLES; i++) {\n        float weight_i = stepDist * ((i == 0 || i == TRANSMITTANCE_SAMPLES) ? 0.5 : 1.0);\n        float height_i = sqrt(dist * dist + 2.0 * dist * ray.rMu + ray.r2) - PLANET_RADIUS;\n\n        rayleigh_depth += weight_i * getProfileDensity(rayleigh_density, height_i);\n        mie_depth += weight_i * getProfileDensity(mie_density, height_i);\n        ozone_depth += weight_i * getProfileDensity(ozone_density, height_i);\n\n        dist += stepDist;\n    }\n\n    return exp(-(\n        rayleigh_extinction * rayleigh_depth +\n        mie_extinction * mie_depth +\n        ozone_extinction * ozone_depth\n    ));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// MULTI-SCATTERING LUT ========================================================\n\n#define SECOND_RAYS 64\n#define SECOND_STEPS 24\n\nvoid secondScatteringTrace(RayInfo viewRay, float ray_length, float LoU, float VoL, out vec3 lum, out vec3 lumFactor);\nvec3 calcIndirectLight(float r, float LoU);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = region_uv(ivec2(fragCoord), MULTISCATTER_RESOLUTION, MULTISCATTER_ORIGIN);\n    if (any(notEqual(uv, clamp(uv, 0.0, 1.0)))) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    float r = mix(PLANET_RADIUS, ATMOSPHERE_RADIUS, uv.y);\n    float LoU = 2.0 * uv.x - 1.0;\n    fragColor = vec4(INDIRECT_MULTIPLIER * calcIndirectLight(r, LoU),1.0);\n}\n\n\n\nvoid secondScatteringTrace(RayInfo viewRay, float ray_length, float LoU, float VoL, out vec3 lum, out vec3 lumFactor) {\n    lum = vec3(0.0);\n    lumFactor = vec3(0.0);\n    vec3 view_transmittance = vec3(1.0);\n    \n    bool intersectsGround = intersects(viewRay, PLANET_RADIUS);\n    \n    vec3 rayleigh_sum = vec3(0.0);\n    vec3 mie_sum = vec3(0.0);\n    \n    float rayleighPhaseValue = rayleighPhaseFunction(VoL);\n    float miePhaseValue = miePhaseFunction(0.8, VoL);\n    \n    float t = 0.0;\n    float stepDist = ray_length / float(SECOND_STEPS);\n    float dist = 0.25 * stepDist;\n    float rMu_sun = viewRay.r * LoU;\n    for (int i = 0; i < SECOND_STEPS; i++) {\n        RayInfo sun_i;\n        RayInfo view_i = stepRay(viewRay, dist, rMu_sun, VoL, sun_i);\n        float h_i = view_i.r - PLANET_RADIUS;\n        \n        float rayleigh_amt = getProfileDensity(rayleigh_density, h_i);\n        float mie_amt = getProfileDensity(mie_density, h_i);\n        \n        vec3 rayleighScattering = rayleigh_scatter * rayleigh_amt;\n        vec3 mieScattering = mie_scatter * mie_amt;\n        vec3 extinction = (\n            rayleigh_extinction * rayleigh_amt + \n            mie_extinction * mie_amt + \n            ozone_extinction * getProfileDensity(ozone_density, h_i)\n        );\n        vec3 sampleTransmittance = exp(-stepDist * extinction);\n        vec3 sunTransmittance = transmittanceOut(sun_i, intersects(sun_i, PLANET_RADIUS));\n        \n        vec3 isoScatter = rayleighScattering + mieScattering;\n        vec3 scatteringF = (isoScatter - isoScatter * sampleTransmittance) / extinction;\n        \n        vec3 rayleighInScatter = rayleighScattering * rayleighPhaseValue;\n        vec3 mieInScatter = mieScattering * miePhaseValue;\n        vec3 inScattering = (rayleighInScatter + mieInScatter) * sunTransmittance;\n        \n        \n        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n        \n        lum += view_transmittance * scatteringIntegral;\n        lumFactor += view_transmittance * scatteringF;\n    \n        dist += stepDist;\n        view_transmittance *= sampleTransmittance;\n    }\n}\n\n\nvec3 calcIndirectLight(float r, float LoU) {\n    vec3 sunDir = vec3(sqrt(1.0 - LoU * LoU), LoU, 0.0);\n    float r2 = r * r;\n    float LoH = sqrt(1.0 - LoU * LoU);\n    \n    vec3 lumTotal = vec3(0.0);\n    vec3 f_ms = vec3(0.0);\n    \n    for (int i = 0; i < SECOND_RAYS; i++) {\n        float cosPhi = 2.0 * (float(i) + 0.5) / float(SECOND_RAYS) - 1.0;\n        float sinPhi = sqrt(1.0 - cosPhi * cosPhi);\n        float theta = GOLDEN_ANGLE * float(i);\n        float sinTheta = sin(theta);\n        float cosTheta = cos(theta);\n        vec3 rayDir = vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);\n        \n        RayInfo sample_ray = new_RayInfo(r, r2, rayDir.y);\n        float VoL = dot(rayDir, sunDir);\n        \n        bool intersects_ground;\n        float ray_length = rayLength(sample_ray, intersects_ground);\n        \n        vec3 lum, lumFactor;\n        secondScatteringTrace(sample_ray, ray_length, LoU, VoL, lum, lumFactor);\n        \n        lumTotal += lum / float(SECOND_RAYS);\n        f_ms += lumFactor / float(SECOND_RAYS);\n    }\n    return lumTotal / (1.0 - f_ms);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// SKY-VIEW LUT =====================================================================\n#define SKY_VIEW_SAMPLES 48\n#define TIME_SPEED 0.1\n\nRayInfo skyViewRay(float uvy, float h);\n\nvec3 atmosphereColor(RayInfo viewRay, float LoU, float VoL);\n\n\nfloat curve(float x, float h) {\n    float a = x - h;\n    return a * abs(a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = region_uv(ivec2(fragCoord), SKYVIEW_RESOLUTION, SKYVIEW_ORIGIN);\n    if (any(notEqual(uv, clamp(uv, 0.0, 1.0)))) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    \n    float r = mix(PLANET_RADIUS, ATMOSPHERE_RADIUS, smoothstep(0.0, 0.8, iMouse.y/iResolution.y - 0.1));\n    if (iMouse.xy == vec2(0.0)) {\n        r = PLANET_RADIUS + 0.1;\n    }\n    \n    RayInfo viewRay = skyViewRay(uv.y, r);\n    float view_h = sqrt(1.0 - viewRay.mu * viewRay.mu);\n    \n    vec3 viewDir = vec3(\n        sin((uv.x + 0.25) * TWO_PI) * view_h,\n        viewRay.mu,\n        cos((uv.x + 0.25) * TWO_PI) * view_h\n    );\n    float timeOfDay = iTime * TIME_SPEED - 0.5;\n    vec3 sunDir = vec3(0, -sin(timeOfDay), cos(timeOfDay));\n    float VoL = dot(viewDir, sunDir);\n    \n    fragColor = vec4(atmosphereColor(viewRay, sunDir.y, VoL), 1.0);\n}\n\n\nRayInfo skyViewRay(float x_mu, float r) {\n    float r2 = r * r;\n    \n    // Move detailed region to horizon's location\n    float horizon_sin = PLANET_RADIUS / r;\n    \n    float h_mu = -sqrt(1.0 - horizon_sin * horizon_sin);\n    h_mu = 0.5 * h_mu + 0.5;\n    \n    float H = (1.0 - 2.0 * sqrt(h_mu - h_mu * h_mu)) / (2.0 * h_mu - 1.0);\n    \n    float mu_min = curve(-1.0, H);\n    float mu_max = curve( 1.0, H);\n    \n    float mu_here = curve(x_mu * 2.0 - 1.0, H);\n    \n    float mu = 2.0 * (mu_here - mu_min) / (mu_max - mu_min) - 1.0;\n    //mu = (2.0 * x_mu - 1.0);\n    \n    return new_RayInfo(r, r2, mu);\n}\n\nvec3 getIndirect(RayInfo lightRay) {\n    \n    vec2 uv = vec2(\n        lightRay.mu * 0.5 + 0.5,\n        (lightRay.r - PLANET_RADIUS) / (ATMOSPHERE_RADIUS - PLANET_RADIUS)\n    );\n    return texture(iChannel0, pixel_region(uv, ivec2(iResolution.xy), MULTISCATTER_RESOLUTION, MULTISCATTER_ORIGIN)).rgb / INDIRECT_MULTIPLIER;\n}\n\nvec3 atmosphereColor(RayInfo viewRay, float LoU, float VoL) {\n    bool intersects_ground;\n    float ray_length = rayLength(viewRay, intersects_ground);\n    \n    float rMu_sun = viewRay.r * LoU;\n    \n    float stepDist = ray_length / float(SKY_VIEW_SAMPLES);\n    \n    \n    vec3 total = vec3(0.0);\n    \n    vec3 rayleigh_sun = rayleigh_scatter * rayleighPhaseFunction(VoL);\n    vec3 mie_sun = mie_scatter * miePhaseFunction(0.8, VoL);\n    \n    \n    vec3 rayleigh_moon = rayleigh_scatter * rayleighPhaseFunction(-VoL);\n    vec3 mie_moon = mie_scatter * miePhaseFunction(0.8, -VoL);\n    \n    \n    float dist = 0.25 * stepDist;\n    for (int i = 0; i < SKY_VIEW_SAMPLES; i++) {\n        RayInfo sun_i;\n        RayInfo view_i = stepRay(viewRay, dist, rMu_sun, VoL, sun_i);\n        RayInfo moon_i = reverse(sun_i);\n        \n        vec3 view_transmittance = transmittanceBetween(viewRay, view_i, intersects_ground);\n        vec3 sun_transmittance = transmittanceOut(sun_i, intersects(sun_i, PLANET_RADIUS));\n        vec3 moon_transmittance = transmittanceOut(moon_i, intersects(moon_i, PLANET_RADIUS));\n        \n        float h_i = view_i.r - PLANET_RADIUS;\n        float mie_i = getProfileDensity(mie_density, h_i);\n        float rayleigh_i = getProfileDensity(rayleigh_density, h_i);\n        \n        vec3 total_scatter = mie_scatter * mie_i + rayleigh_scatter * rayleigh_i;\n        \n        total += stepDist * view_transmittance * (\n            SUN_COLOR * (\n                sun_transmittance * (\n                    rayleigh_sun * rayleigh_i +\n                    mie_sun * mie_i\n                ) +\n                total_scatter * getIndirect(sun_i)\n            ) +\n            MOON_COLOR * (\n                moon_transmittance * (\n                    rayleigh_moon * rayleigh_i +\n                    mie_moon * mie_i\n                ) +\n                total_scatter * getIndirect(moon_i)\n            )\n        );\n        \n        dist += stepDist;\n    }\n    //return transmittanceOut(viewRay, intersects_ground);\n    return total;\n}","name":"Buffer C","description":"","type":"buffer"}]}