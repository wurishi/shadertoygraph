{"ver":"0.1","info":{"id":"4ttyRB","date":"1543172977","viewed":334,"name":"Wobbly grid","username":"toocanzs","description":"One of the first raymarching shaders I've made that actually looks pretty cool. The idea came from watching this video https://youtu.be/QDfqgG8HJDQ?t=748 I wanted to test myself and see if I could create something similar ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["simple","raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define EPSILON 0.001\n#define FAR 1000.\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCross( in vec3 p, float size)\n{\n  float da = sdBox(p.xy,vec2(size));\n  float db = sdBox(p.yz,vec2(size));\n  float dc = sdBox(p.zx,vec2(size));\n  return min(da,min(db,dc));\n}\n\n#define PILLAR_SEP 160.\n#define PILLAR_WIDTH 10.\n#define FAME_SIZE 1.\n\nfloat frame(vec3 p)\n{\n    float d;\n    d = sdBox(p, vec3(FAME_SIZE));\n    d = max(d, -sdCross(p, FAME_SIZE*0.5));\n    return d;\n}\n\nfloat grid(vec3 q)\n{\n    q = mod(q,2.)-0.5*2.;\n    return frame(q);\n}\n\nfloat gridCross(vec3 q)\n{\n    float d;\n    q = mod(q, PILLAR_SEP)- 0.5*PILLAR_SEP;\n    d = grid(q);\n    d = max(sdCross(q, PILLAR_WIDTH), d);\n    return d;\n}\n\n\nfloat map(vec3 p)\n{\n    float d;\n   \tp.y += sin(p.x*0.0141231 + iTime*1.03123)*4.;\n    p.x += sin(p.z*0.0323124 + iTime*0.8345)*7.;\n    p.z += sin(p.x*0.022345 + iTime*0.73245)*6.;\n    vec3 q = p;\n    \n    \n    d = gridCross(q);\n    q += vec3(-PILLAR_WIDTH,-PILLAR_WIDTH*3.,-PILLAR_WIDTH);\n    q = mod(q , PILLAR_WIDTH*2.) - 0.5 * PILLAR_WIDTH*2.;\n    d = max(-sdCross(q, 6.), d);\n    return d;\n}\n#define steps 128\nfloat march(vec3 o, vec3 r, out float m)\n{\n    float t = 0.;\n    int i = 0;\n    for(i; i < steps; i++)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(d < EPSILON || t > FAR)\n        {\n            break;\n        }\n        t += d * 0.4;\n    }\n    m = float(i);\n    return min(FAR, t);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.*fragCoord - iResolution.xy )/ iResolution.y;\n    vec3 o = vec3(0,0,iTime*20.);\n    vec3 r = normalize(vec3(uv,1.));\n    \n    float m;\n    float d = march(o,r,m);\n    \n    vec3 fogCol = vec3(0.5,0.7,0.9)*0.7;\n    \n    vec3 col = vec3(fogCol);\n    float l = 1.-smoothstep(0., .95, d/FAR);\n    if(d < FAR)\n    {\n        m = (m / float(steps)) + 0.01;\n        float fog = (1.0 / (1.0 + m*m * 10.));\n        \n        col = vec3(fog);\n    }\n\tcol = mix(vec3(fogCol), col, l);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}