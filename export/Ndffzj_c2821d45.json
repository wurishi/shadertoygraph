{"ver":"0.1","info":{"id":"Ndffzj","date":"1645039270","viewed":87,"name":"Grid Exp","username":"mAmaro","description":"Just playing around with using smooth step to shad lines of a grid to visualize how space is warped.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid","polar","cartesian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GridCart  0x00000001u\n#define GridPolar 0x00000002u\n\nstruct grid\n{\n    vec2 OriginMask;\n    vec2 GridMask;\n};\n\nfloat ClipAtCellCount(vec2 uv, vec2 CellCount)\n{\n    CellCount *= 0.1;\n    float Result = 1.0;\n    if(uv.x > CellCount.x || uv.y > CellCount.y)\n    { Result = 0.0; }\n    return Result;\n}\n\nmat2 Rotate(float Theta)\n{\n    return mat2(cos(Theta), -sin(Theta),\n                sin(Theta),  cos(Theta));\n}\n\ngrid GetGrid(uint Type, float SubDivisions, vec2 Zoom, vec2 uv)\n{\n    grid Result;\n    SubDivisions *= 10.0;\n    float RadialComp = 1.0;\n    float PixelSize  = 1.0/iResolution.y;\n    \n    if(Type == GridPolar) {RadialComp = 1.0/uv.y;}\n    \n    //NOTE(): Smoothstep returns 0 for anything inside the bounds \n    //        and 1 for anything outside of it. Thats why the grid\n    //        is red but not the origin line. Inverting smoothstep fixes\n    //        that issue. \n    //        Multiplication => AND &&\n    //        Addition       => OR  ||\n    //NOTE(): vec2 smoothstep with the zoom comp work okay for uniform zoom\n    //        but if i want to have different zoom cooeff on the x and y. I need\n    //        to break them up. Unless zoom i use vector ops. zoom would be a vec2\n    //        with differenc coeff on x & y.\n    /*\n    vec2 originmask = 1.0 - smoothstep(zoom*0.001/distance(vec2(0.0), uv), zoom*0.002/distance(vec2(0.0), uv), abs(uv)); \n    vec2 gridmask   = smoothstep(zoom*0.01/distance(vec2(0.0), uv), zoom*0.03/distance(vec2(0.0), uv), fract(abs(uv) * 10.0));\n    */\n    \n    //TODO(): Understand this v\n    //smoothstep( radius - pix, radius + pix, abs(uv) )  \n#if 0\n    Result.OriginMask = 1.0 - \n    smoothstep(Zoom*0.001*RadialComp, Zoom*0.002*RadialComp, abs(uv)); \n    Result.GridMask   = \n    smoothstep(Zoom*0.01, Zoom*0.03, fract(abs(uv) * Granularity));\n#else\n    Result.OriginMask = 1.0 - \n    smoothstep(Zoom*0.001*(uv.y-PixelSize), Zoom*0.002*(uv.y+PixelSize), abs(uv)); \n    Result.GridMask   = \n    smoothstep(Zoom*0.01*(uv.y-PixelSize), Zoom*0.03*(uv.y+PixelSize), fract(abs(uv) * SubDivisions));\n#endif\n    \n    return Result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 NormMouse = iMouse.xy/iResolution.xy;\n\n    vec2  Zoom = 6.0 * NormMouse + 2.0;\n    //TODO(): How does this:\n    vec2  uv  = fragCoord/iResolution.xy; //Get normalize pos of fragment\n    float ar  = iResolution.x/iResolution.y; //Calc aspect ratio\n    uv.x     *= ar;  //Apply aspect ratio to x\n    uv -= vec2(0.5 * ar, 0.5); \n    // work out to be this:\n    //uv = (fragCoord -.5 * iResolution.xy ) /iResolution.y;\n    \n    float t   = 0.3 * iTime;\n    //uv *= Rotate(t);\n    uv *= Zoom;\n    uv.x = abs(uv.x);\n    \n    /// POLAR COORDS\n    uv = vec2(atan(uv.x, uv.y), length(uv));\n    \n    //               ADD MORE GRID CELLS HERE v\n    float ClipMask = ClipAtCellCount(uv, vec2(9.0, 10.0));\n    grid Grid = GetGrid(GridPolar, 1.0, Zoom, uv);\n    \n    vec3 Color = ClipMask *\n    (vec3(Grid.GridMask.x * Grid.GridMask.y) +\n    vec3(Grid.OriginMask.x, Grid.OriginMask.y, 0.0));\n    \n    //NOTE(): Adding tacky colors is a must\n    Color += vec3(uv.x * cos(t), uv.y *sin(t), 1.0) * ClipMask;\n    \n    // Output to screen\n    fragColor = vec4(Color, ClipMask);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//TODO(): Read article on anti aliasing an implement\n//TODO(): Make grids using other implementations an analyze them\n","name":"Common","description":"","type":"common"}]}