{"ver":"0.1","info":{"id":"wstBDN","date":"1605392211","viewed":105,"name":"1-2. 2D Basic Shapes","username":"rito15","description":"shapes","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/**************************************************************************************************\n * Basic Shapes\n **************************************************************************************************/\n// 점\nfloat Point(float2 uv, float2 p)\n{\n    return smoothstep(0.03, 0.02, length(uv - p));\n}\n\n// 선분 : 시작점, 끝점, 굵기\nfloat Line(float2 uv, float2 p1, float2 p2, float thickness, float smoothness)\n{\n    // zero div 회피\n    p1 += 0.000001;\n    p2 -= 0.000001;\n    \n    // 두께 반감\n    thickness *= 0.5;\n    \n    // 범위제한\n    thickness = max(0.005, thickness);\n    smoothness = clamp(smoothness, 0.0001, 1.);\n    \n    float w = abs(p2.x - p1.x);\n    float h = abs(p2.y - p1.y);\n    float len = sqrt(w*w + h*h); // 직선 길이(빗변 이용)\n    \n    float slope = (p2.y - p1.y)/(p2.x - p1.x); \t// 기울기\n    float2 center = (p2 + p1) * 0.5; \t\t\t// 중심점\n    \n    // 1. 두께 제한\n    // 기울기가 변해도 굵기, 부드러움이 유지되도록 계산\n    // smoothstep 내에 적용되는 실제 thickness는 빗변이 아니고 width 값이므로\n    // (len / width)를 곱해줌으로써 빗변 길이가 실제 thickness로 적용되도록 해줌\n    float th = thickness * (len / w);\n    float sm = smoothness * (len / w);\n    float line = smoothstep(th, th - sm, abs((uv.x - center.x) * slope - (uv.y - center.y)));\n    \n    // 2. 길이 제한\n    float revTh = (len * 0.5) * (len / h); // 제한선 두께\n    float revSm = smoothness * (len / h);  // 제한선 스무딩\n    line *= smoothstep(revTh , revTh - revSm, abs(-(uv.x - center.x) / slope - (uv.y - center.y)));\n    \n \treturn line;   \n}\n\n// Straight Vertical Line\n// 세로 직선 : x좌표, 굵기\nfloat SVLine(float2 uv, float posX, float thickness, float smoothness)\n{\n    return smoothstep(thickness * 0.5, thickness * 0.5 - smoothness, abs(uv.x - posX));\n}\n\n// 세로 쌍직선 : 중심 x좌표, 두 직선 사이 거리, 굵기\nfloat SDVLine(float2 uv, float posX, float dist, float thickness, float smoothness)\n{\n    return smoothstep(thickness * 0.5, thickness * 0.5 - smoothness, abs(abs(uv.x - posX) - dist * 0.5));\n}\n\n// 직사각형 : 중심점, 사이즈(너비, 높이)\nfloat Rect(float2 uv, float2 center, float2 size, float smoothness)\n{\n    size *= 0.5;\n    \n    float rect = smoothstep(size.x, size.x - smoothness, abs(uv.x - center.x)); // 세로\n         rect *= smoothstep(size.y, size.y - smoothness, abs(uv.y - center.y)); // 가로\n    \n    return rect;\n}\n\n// 직사각형 : 좌하단, 우상단 정점 좌표\nfloat RectP(float2 uv, float2 p1, float2 p2, float smoothness)\n{\n    float2 center = (p1 + p2) * 0.5;\n    float2 size = (p2 - p1) * 0.5;\n    \n    float rect = smoothstep(size.x, size.x - smoothness, abs(uv.x - center.x)); // 세로\n         rect *= smoothstep(size.y, size.y - smoothness, abs(uv.y - center.y)); // 가로\n    \n    return rect;\n}\n\n// 이등변삼각형\nfloat Triangle(float2 uv, float2 pos, float2 size, float smoothness)\n{\n    float center = 0.5; // 무게중심 맞출 경우 :  2.0/3.0;\n    \n    float2  uvTri = (uv - pos) / (size * 2.0);\n    float tri = smoothstep(center + smoothness,    center - smoothness,    uvTri.y + abs(uvTri.x * 2.));\n         tri *= smoothstep(center - smoothness*.5, center + smoothness*.5, uvTri.y + 1.);\n    return tri;\n}\n\n// 정삼각형\nfloat ETriangle(float2 uv, float2 pos, float size, float smoothness)\n{\n    size *= 1.5/sqrt(3.);\n    float center = 2./3.; // 무게중심 맞출 경우 :  2.0/3.0;\n    float2  uvTri = (uv - pos) / (size * 1.0);\n    float eqTri = smoothstep(center + smoothness,    center - smoothness,    uvTri.y + abs(uvTri.x * sqrt(3.)));\n         eqTri *= smoothstep(center - smoothness*.5, center + smoothness*.5, uvTri.y + 1.);\n    return eqTri;\n}\n\n// 원 : 중심좌표, 반지름\nfloat Circle(float2 uv, float2 center, float radius, float smoothness)\n{\n    return smoothstep(radius, radius - smoothness, length(uv - center));\n}\n\n// 원(타원) : 중심좌표, 사이즈(너비, 높이)\nfloat Circle(float2 uv, float2 center, float2 size, float smoothness)\n{\n    return smoothstep(1., 1. - smoothness, length((uv - center) / size * 2.));\n}\n\n// 원(타원) : 좌하단 정점, 우상단 정점 좌표\nfloat CircleP(float2 uv, float2 p1, float2 p2, float smoothness)\n{\n    float2 center = (p2 + p1) * 0.5;\n    float2 size = (p2 - p1) * 0.5;\n    \n    return smoothstep(1.0, 1.0 - smoothness, length((uv - center) / size));\n}\n\n// 물방울\nfloat Drop(float2 uv, float2 center, float2 size, float smoothness)\n{\n    float2 uvDrop = (uv - center) / (size * float2(1., 0.5));\n    uvDrop = -uvDrop;\n    \n    float k = max(min(-0.45 * (uvDrop.y - 0.5), 1.), 0.); // k = max(min(-y, 1), 0) 변형\n    float s = k * k * (2.5 - 2. * k);                     // s = k^2(3 - 2k) 변형\n    float dropBase = abs(uvDrop.x) + s;\n    float drop = smoothstep(0.5, 0.5 - smoothness, dropBase);\n    \n    // 상하 가로로 자르기\n    float dropClip = smoothstep(1.0, 0.5, abs(uvDrop.y + 0.2));\n    drop *= dropClip;\n    \n    // 물방울 하단부 원\n    float dropCircle = smoothstep(0.5, 0.5 - smoothness, length(uvDrop - float2(0., 0.5)));\n    dropCircle *= 1. - dropClip;\n    drop += dropCircle;\n    \n    drop = smoothstep(0., 1., drop);\n    \n    return drop;\n}\n\n// 하트\nfloat Heart(float2 uv, float2 center, float2 size, float smoothness)\n{\n    float2  uvHeart   = (uv - center) / (size * float2(1.15, 0.97));\n    float2  heartBase = float2(uvHeart.x, uvHeart.y - sqrt(abs(uvHeart.x)) * 0.7 + 0.18);\n    float heart = smoothstep(0.87, 0.87 - smoothness, length(heartBase));\n    return heart;\n}\n\n// 사인 그래프\nfloat SineWave(float2 uv, float2 pos, float frequency, float amplitude, float thickness, float smoothness)\n{\n    float2 suv = uv - pos;\n    float sBase = abs(sin(suv.x * frequency) + suv.y / amplitude);\n    return smoothstep(thickness + smoothness, thickness - smoothness, sBase);\n}\n\n// 세잎클로버\n\n// 네잎클로버\n\n// 나선 : Spiral\n\n/**************************************************************************************************\n * Calc Functions \n **************************************************************************************************/\n// Smooth Max\nfloat smax(float a, float b, float k)\n{\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n// Smooth Max\nfloat3 smax(float3 a, float3 b, float k)\n{\n    float3 h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n\n// Smooth Min\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn lerp(b, a, h) - k * h * (1.0 - h);\n}\n\n// 회전 : 기본 시계방향\nfloat2 Rotate(float2 org, float deg)\n{\n    float2x2 rotMat = float2x2(cos(deg), -sin(deg),\n                               sin(deg),  cos(deg));\n    return mul(rotMat, org);\n}\n\n/**************************************************************************************************\n * UV Functions \n **************************************************************************************************/\n// 타일링\nfloat2 UvTile(float2 uv, float2 size, float2 offset)\n{\n    return frac(uv * size) - offset;\n}\n\n// 회전\nfloat2 UvRotate(float2 uv, float rot)\n{\n    return Rotate(uv, rot);\n}\n\n// 스케일 박동\nfloat2 UvPulse(float2 uv, float range, float t)\n{\n    return uv * (1. + sin(t)* range);\n}\n\n// 꿀렁꿀렁 - a : x꿀렁, b : y꿀렁, c : 꿀렁 범위 / t : 시간\nfloat2 UvWave(float2 uv, float a, float b, float c, float t)\n{\n    float x = abs(uv.x) * a;\n    float y = abs(uv.y) * b;\n    float k;\n    \n    k = sin(x * y + t); // 기본\n    //k *= cos(x *b + cos(t)*0.5) * 0.5 + 0.5; \n    \n    float kkc = abs(k * k * c);\n    float w1 = 1. + kkc * a;\n    float w2 = 1. + kkc * b;\n    return float2(uv.x * w1, uv.y / w2);\n}\n\n// 진동\nfloat2 UvVibrate(float2 uv, float a, float b, float c, float t)\n{\n    float x = abs(uv.x) * a;\n    float y = abs(uv.y) * b;\n    float w = 1. + (sin(t*x * y + t) * sin(t*x * y + t) * c);\n    \n    return float2(uv.x * w, uv.y * w);\n}\n\n// 흩뿌리기\nfloat2 UvScatter(float2 uv, float2 scale)\n{\n    float x = uv.x;\n    float y = uv.y;\n    float2 s = 2. - float2(cos(x * scale) * cos(y * scale));\n    return uv * s;\n}\n\n/**************************************************************************************************\n * Screen Filter Functions \n **************************************************************************************************/\n// 모자이크\nfloat FilterMosaic(float2 uv, float scale, float smoothness)\n{\n    float2 uv2 = frac((uv - float2(0.5, 0.5)) * scale);\n    float2 mBase = uv2 - float2(0.5, 0.5);\n    float mosaic = smoothstep(0.5, 0.5 - smoothness, length(mBase));\n    return mosaic;\n}\n\n/**************************************************************************************************\n * Functions \n **************************************************************************************************/\n\nfloat Random11(float seed, float min, float max)\n{\n    float t = frac(sin(seed * 13.421 + 23.512) * 17593.39482);\n    return lerp(min, max, t);\n}\n\n\n// 0 : No Grids / 1 : 0.05 unit / 2 : 0.1 unit\n#define LEVEL_GRID_DEBUG 1\n\n// 0 : No Grids / 1 : Behind Shapes / 2 : In Front of Shapes\n#define LEVEL_SHOW_GRID 1\n\n// Draw Shape & Color\n#define DRAW_SHP_COL(s, c) shp += s; col += c;\n\n/**************************************************************************************************\n * Main\n **************************************************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV ================================================================================================\n    float2 uv  = fragCoord/iResolution.xy;\t\t\t\t\n    float2 uv0 = uv;                                                          // Full Screen  0.0 ~ 1.0\n    float2 uv1 = uv * 2.0 - 1.0;                                              // Full Screen -1.0 ~ 1.0\n    float2 uv2 = (uv - 0.5) * float2(iResolution.x/iResolution.y, 1.0) + 0.5; // Square Area  0.0 ~ 1.0\n    float2 uv3 = uv2 * 2.0 - 1.0;\t\t\t\t\t\t                      // Square Area -1.0 ~ 1.0\n    \n    // UV Effects ========================================================================================\n    //uv3 = UvTile(uv3, float2(2., 2.), float2(0.5));\n    //uv3 = UvRotate(uv3, iTime);\n    //uv3 = UvPulse(uv3, 0.01, iTime * 10.0);\n    //uv3 = UvWave(uv3, 0.5, 0.5, 0.1, iTime * 5.0);\n    //uv3 = UvVibrate(uv3, 1., -1., 0.50, iTime * 5.0);\n    //uv3 = UvScatter(uv3, float2(1000.0));\n    \n    // Final Variables ===================================================================================\n    float3 shp = float3(0.0);\t// Shape\n    float3 col = float3(0.0);\t// Color\n    float3 grd = float3(0.0);   // Debug Grids\n    \n    \n    /******************************************************************************************************************\n     * Body Start                                                                                                     *\n     ******************************************************************************************************************/\n    // Line - ( UV, PointA, PointB, Thickness, Smoothness )\n    float2 linePointA = float2(-0.3, 0.9);\n    float2 linePointB = float2(-0.6, 0.5);\n    float line = Line(uv3, linePointA, linePointB, 0.1, 0.05);\n    float3 colLine = line * float3(0.95, 0.2, 0.2);\n    \n    // Vertical Straight Line - ( UV, position X, Thickness, Smoothness )\n    float2 uvSvLine = UvPulse(uv3, 0.01, iTime * 15.0);\n    float svLine = SVLine(uvSvLine, -0.85, 0.1, 0.01);\n    float3 colSvLine = svLine * float3(0.2, 0.2, 0.8);\n    \n    // Vertical Straight line X 2 - ( UV, position X, Distance Between, Thickness, Smoothness )\n    float2 uvSdvLine = UvVibrate(uv3, 0.4, 0.0, sin(uv3.y * 50.)*0.005, iTime * 5.0);\n    float sdvLine = SDVLine(uvSdvLine, -0.85, 0.2, 0.1, 0.05);\n    float3 colSdvLine = sdvLine * float3(0.8, 1.0, 0.8);\n    \n    // Rectangle\n    //  ( UV, Center Position, float2(Width, Height), Smoothness )\n    // P( UV, Bottom Left Pos, Top Right Pos,         Smoothness )\n    float2 uvRect1 = UvRotate(uv3 - float2(0.0, 0.7), iTime * 2.);\n    float2 uvRect2 = UvScatter(uv3, float2(sin(iTime*1.)*0.5));\n    float rect1 = Rect (uvRect1, float2(0.0, 0.0), float2(0.4, 0.3), 0.1);\n    float rect2 = RectP(uvRect2, float2(0.3, 0.5), float2(0.8, 0.9), 0.05);\n    float3 colRect1 = rect1 * float3(0.9, 0.8, 0.4);\n    float3 colRect2 = rect2 * float3(0.4, 0.4, 0.9);\n    \n    // Isoceles Triangle ( UV, Center Position, float2(Width, Height), Smoothness )\n    float triangle = Triangle(uv3, float2(-0.4, 0.1), float2(0.2, 0.3), 0.02);\n    float3 colTriangle = triangle * GREEN;\n    \n    // Equilateral triangle ( UV, Center Position, Size, Smoothness )\n    float eTriangle = ETriangle(uv3, float2(-0.4, -0.6), 0.4, 0.01);\n    float3 colETriangle = eTriangle * float3(0.95, 0.20, 0.7);\n    \n    // Circle, Ellipse\n    //  ( UV, Center Position, Radius,                Smoothness )\n    //  ( UV, Center Position, float2(Width, Height), Smoothness )\n    // P( UV, Bottom Left Pos, Top Right Pos,         Smoothness )\n    float2 uvCircle1 = UvScatter(uv3, float2(200.) + sin(iTime)*100.);\n    float2 uvCircle2 = UvWave(uv3, 0.0, 1.0, 0.1, iTime * 2.0);\n    float2 uvCircle3 = UvWave(uv3, 0.0, 1.0, 0.1, iTime * 5.0);\n    float circle1 =  Circle(uvCircle1, float2(0.1, 0.1), 0.2, 0.01);\n    float circle2 =  Circle(uvCircle2, float2(0.5, 0.1), float2(0.3, 0.5), 0.4);\n    float circle3 = CircleP(uvCircle3, float2(0.5, 0.0), float2(1.0, 0.4), 0.4);\n    float3 colCircle1 = circle1 * float3(0.7, 0.5, 0.1);\n    float3 colCircle2 = circle2 * RED;\n    float3 colCircle3 = circle3 * BLUE;\n    \n    float circle2_3 = smax(circle2, circle3, 0.5);\n          circle2_3 = smoothstep(0.0, 0.5, circle2_3);\n    float3 colC23A = smax(colCircle2, colCircle3, 0.5);\n    float3 colC23B = circle2_3 * float3(0.7, 0.5, 0.9);\n    float3 colCircle2_3 = lerp(colC23A, colC23B, sin(iTime));\n    \n    // Water Drop - ( UV, Center, float2(Width, Height), Smoothness )\n    float2 uvDrop = UvWave(uv3 - float2(0.1, -0.5), 0.5, 0.5, 0.1, iTime * 4.0);\n    float drop = Drop(uvDrop, float2(0.0, 0.0), float2(0.3, 0.6), 0.1);\n    float3 colDrop = drop * float3(0.2, 0.9, 1.0);\n    \n    // Heart - ( UV, Center, float2(Width, Height), Smoothness )\n    float2 uvHeart   = UvWave(uv3 - float2(0.65, -0.55), 0.5, 0.5, 0.1, iTime * 5.0);\n    float heart      = Heart(uvHeart, float2(0.,0.), float2(0.3, 0.3), 0.05);\n    float heartShade = Heart(uvHeart, float2(0.,0.), float2(0.3, 0.3), 0.06);\n    float heartLight = smoothstep(1.0, -0.5, length(uvHeart - float2(-0.25, 0.5))) * 0.6 + 0.4;\n    \n    float gd = smoothstep(0. , 1.0, length(uv3));\n    float3 colHeart = float3(1. - gd * cos(uv.y + iTime), sin(uv.x + iTime), gd)\n                    * heartShade\n                    * heartLight;\n    \n    // Sine Graph - (UV, Pos, Frequency, Amplitude, Thickness, Smoothness)\n    float sWave = SineWave(uv3 - float2(iTime * 0.1, 0.), float2(0.1, -0.9), 10., 0.05, 0.2, 0.5);\n    float3 colSWave = sWave * WHITE;\n    \n    ////////////////////////////////////////////////////////////////////////////////////\n    // 별(십자) : TODO\n    float crossStarSize = 0.2;\n    float crossStarBlur = 0.2;\n    float crossStar = smoothstep(crossStarSize, crossStarSize - crossStarBlur, abs(uv2.x * uv2.y) * 5.);\n    \n    // 십자\n    float2 pos_cross = float2(0.5, 0.5);\n    float2 size_cross = float2(0.1, 0.2);\n    float blur_cross = 0.01;\n    float shp_cross = smoothstep(0.0, -blur_cross, min(\n                                     abs(uv.x - pos_cross.x) - size_cross.x, \n                                     abs(uv.y - pos_cross.y) - size_cross.y)\n                                );\n    // 직사각형\n    float2 pos_square = float2(-0.5, -0.5);\n    float2 size_square = float2(0.3, 0.2);\n    float blur_square = 0.01;\n    float shp_rect = smoothstep(0.0, -blur_square, max(\n        \t\t\t\t\t\t\tabs(uv.x - pos_square.x) - size_square.x,\n                                    abs(uv.y - pos_square.y) - size_square.y)\n                               );\n    \n    /******************************************************************************************************************\n     *                                                                                                       Body End *\n     ******************************************************************************************************************/\n    \n    \n    // Draw Shapes =======================================================================================\n    shp += heart;\n        \n    // Apply Colors ======================================================================================\n    col += colHeart * FilterMosaic(uv, 100., sin(iTime * 10.) * 0.1 + 0.3);\n    \n    // Draw Shapes & Colors ==============================================================================\n    DRAW_SHP_COL(svLine, colSvLine);\n    DRAW_SHP_COL(rect1, colRect1);\n    DRAW_SHP_COL(rect2, colRect2);\n    DRAW_SHP_COL(sdvLine, colSdvLine);\n    DRAW_SHP_COL(line, colLine);\n    DRAW_SHP_COL(triangle, colTriangle);\n    DRAW_SHP_COL(eTriangle, colETriangle);\n    DRAW_SHP_COL(circle1, colCircle1);\n    DRAW_SHP_COL(circle2_3, colCircle2_3);\n    DRAW_SHP_COL(drop, colDrop);\n    DRAW_SHP_COL(sWave, colSWave);\n    \n    shp = saturate(shp);\n    col = saturate(col);\n    \n    \n    // Debug Grids =======================================================================================\n    float2 uvGrd = uv2;\n    \n    //grd += debugCenterLine(uvGrd) * float(LEVEL_GRID_DEBUG);\n    grd += debugOutLine(uvGrd) * float(LEVEL_GRID_DEBUG);\n    grd += debugGrid(uvGrd, 0.05 * float(LEVEL_GRID_DEBUG) ) * 0.2;\n\n    // End Point =========================================================================================\n    fragColor.a = 1.0;\n    fragColor.rgb = shp * col;\n    \n    #if LEVEL_SHOW_GRID == 1\n    \n    fragColor.rgb += grd * (1. - shp);\n    \n    #elif LEVEL_SHOW_GRID == 2\n    \n    float3 grdWB = float3(step(0.001, grd.r+grd.g+grd.b));\n    fragColor.rgb = lerp(fragColor.rgb, grd, grdWB);\n    \n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**************************************************************************************************\n * DEFINITIONS : Unity Compatibility\n **************************************************************************************************/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat3\n\n#define frac(x)     fract(x)\n#define saturate(x) clamp(x, 0., 1.)\n\n#define atan2(x,y)    atan(y,x)\n#define tex2D(s,t)    texture(s,t)\n#define mul(mat,vec)  vec*mat;\n\n#define lerp(a,b,t) mix(a,b,t)\n\n/**************************************************************************************************\n * DEFINITIONS - Constant\n **************************************************************************************************/\n#define PI 3.141592653589793\n\n/**************************************************************************************************\n * DEFINITIONS - Function\n **************************************************************************************************/\n#define S(a, b, t) smoothstep(a, b, t)\n\n// Remap : (0 ~ 1) => (a, b)\n#define R01(t, a, b) (b - a) * t + a\n\n// Remap : (-1 ~ 1) => (a, b)\n#define R11(t, a, b) (b - a) * (1. - t) * 0.5 + a\n\n/**************************************************************************************************\n * DEFINITIONS - float3 Colors\n **************************************************************************************************/\n#define BLACK float3(0.0, 0.0, 0.0)\n#define WHITE float3(1.0, 1.0, 1.0)\n\n#define RED   float3(1.0, 0.0, 0.0)\n#define GREEN float3(0.0, 1.0, 0.0)\n#define BLUE  float3(0.0, 0.0, 1.0)\n\n#define YELLOW  float3(1.0, 1.0, 0.0)\n#define CYAN    float3(0.0, 1.0, 1.0)\n#define MAGENTA float3(1.0, 0.0, 1.0)\n\n/**************************************************************************************************\n * Functions\n **************************************************************************************************/\n\n\n/**************************************************************************************************\n * DEBUG Functions \n **************************************************************************************************/\nfloat3 debugCenterLine(float2 uv)\n{\n    if(uv.x > 0.498 && uv.x < 0.502 || uv.y > 0.498 && uv.y < 0.502)\n        return float3(1., 0., 0.);\n}\nfloat3 debugOutLine(float2 uv)\n{\n    if(uv.x > 1.0 && uv.x <= 1.004 || uv.x < 0.0 && uv.x >= -0.004)\n        return float3(0., 0., 1.);\n}\nfloat3 debugGrid(float2 uv, float interval)\n{\n    if(interval <= 0.0) return float3(0.);\n    \n    // interval마다 그리드 디버그\n    float grid = 0.;\n    float gridZ = 0.;\n    float2 gridXY = float2(0.);\n    \n    float th = 0.002; // thickness\n    \n    for(float f = interval; f < 1.0; f += interval)\n    {\n        // 가로선 || 세로선\n        if(uv.y >= f - th && uv.y <= f + th && uv.x > 0. && uv.x < 1. ||\n           uv.x >= f - th && uv.x <= f + th)\n        {\n            grid = 0.7;\n            gridXY = uv + float2(0.2, 0.4);\n            \n            if( frac(f * 4.) < 0.01 )\n            {\n                grid = 1.;\n                gridZ = 1.;\n            }\n        }\n    }\n    \n    return float3(0., grid, gridZ);\n    //return float3(gridXY, gridZ); //알록달록\n}","name":"Common","description":"","type":"common"}]}