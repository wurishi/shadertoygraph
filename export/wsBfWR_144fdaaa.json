{"ver":"0.1","info":{"id":"wsBfWR","date":"1589833535","viewed":63,"name":"Abstract 3d renderer","username":"SanQri","description":"Abstract 3d renderer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int TRIANGLES_COUNT = 12;\nconst int VERTICES_COUNT = 8;\nconst int LIGHT_SOURCES_COUNT = 1;\n\nconst float EPS = 0.0001;\n\nconst vec3 lightPositions[LIGHT_SOURCES_COUNT] = vec3[] (\n    vec3(-2., 2., 1.)\n);\nconst float intensities[LIGHT_SOURCES_COUNT] = float[] (\n    1.8\n);\n\nconst vec3 vertices[VERTICES_COUNT] = vec3[] (\n    vec3(1., 0., 0.), //1\n    vec3(0., 0., -1.), //2\n    vec3(-1., 0., 0.), //3\n    vec3(0., 0., 1.), //4\n    vec3(1., 2.5, 0.), //1\n    vec3(0., 2.5, -1.), //2\n    vec3(-1., 2.5, 0.), //3\n    vec3(0., 2.5, 1.) //4\n);\n\nconst int trinagleIndexes[TRIANGLES_COUNT * 3] = int[] (\n    0, 1, 2,\n    0, 2, 3,\n    0, 5, 1,\n    0, 4, 5,\n    0, 3, 7,\n    0, 7, 4,\n    6, 5, 4,\n    6, 4, 7,\n    6, 2, 1,\n    6, 1, 5,\n    6, 3, 2,\n    6, 7, 3\n);\n    \nconst vec3 triangleColor[TRIANGLES_COUNT] = vec3[] (\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9),\n    vec3(0.4, 0.7, 0.9)\n);\n\nmat4 t() {\n    float time = iTime * 1.025 + 5.4;\n    return mat4(\n        vec4(1. * cos(time), 0., sin(time), 0.),\n        vec4(0., 1., 0., -1.4),\n        vec4(-sin(time), 0., 1.* cos(time), 6.),\n        vec4(0., 0., 0., 1.)\n    );\n}\n\nvec3 v(int i) {\n    return (vec4(vertices[i], 1.) * t()).xyz;\n}\n\nvec3 normalOfTriangle(int index) {\n    int rootIndex = index * 3;\n    vec3 root = v(trinagleIndexes[rootIndex]);\n    vec3 d1 = v(trinagleIndexes[rootIndex + 1]) - root;\n    vec3 d2 = v(trinagleIndexes[rootIndex + 2]) - root;\n    vec3 n = cross(d1, d2);\n    return n;\n}\n\nbool sameSide(vec3 base, vec3 p1, vec3 p2) {\n    return dot(cross(base, p1), cross(base, p2)) >= 0.;\n}\n\nbool pointInsideTriangle(vec3 point, int triangleIndex, vec3 offset) {\n    int index = triangleIndex * 3;\n    vec3 a = v(trinagleIndexes[index]);\n    vec3 b = v(trinagleIndexes[index + 1]);\n    vec3 c = v(trinagleIndexes[index + 2]);\n    \n    float S = length(cross(a - b, c - b));\n    \n    float s1 = length(cross(point - a - offset, b - a));\n    float s2 = length(cross(point - c - offset, a - c));\n    float s3 = length(cross(point - b - offset, c - b));\n    \n    return s1 + s2 + s3 < S + EPS;\n    \n    \n    return sameSide(b - a, point - a, c - a) &&\n        sameSide(c - b, point - b, a - b) &&\n        sameSide(a - c, point - c, b - c);\n}\n\nbool testTriangle(int index, vec3 ray, out vec3 colission, float normalOffset) {\n    int rootVertexIndex = trinagleIndexes[index * 3];\n    vec3 normal = normalOfTriangle(index);\n    vec3 offset = normal * normalOffset;\n    vec3 rootVertex = v(rootVertexIndex) + offset;\n    \n    float t = dot(rootVertex, normal) / dot(ray, normal);\n    vec3 intersectionPoint = ray * t;\n    \n    colission = intersectionPoint;\n    \n    return pointInsideTriangle(intersectionPoint, index, offset);\n}\n\nfloat squareMagnitude(vec3 p1, vec3 p2) {\n    vec3 p = p1 - p2;\n    return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - vec2(1.);\n    \n    bool anyTriangle = false;\n    float minimalZ = 9999.;\n    int i = 0;\n    int triangleIndex = 0;\n    vec3 currentPoint;\n    vec3 ray = vec3(uv, 1.);\n    for (; i < TRIANGLES_COUNT; i++) {\n        if (testTriangle(i, ray, currentPoint, -0.1 * (0. + sin(iTime) * sin(iTime)))) {\n            if (minimalZ > currentPoint.z) {\n                minimalZ = currentPoint.z;\n            \ttriangleIndex = i;\n            \tanyTriangle = true;\n            }\n        }\n        if (testTriangle(i, ray, currentPoint, 0.)) {\n            if (minimalZ > currentPoint.z) {\n                minimalZ = currentPoint.z;\n            \ttriangleIndex = i;\n            \tanyTriangle = true;\n            }\n        }\n        if (testTriangle(i, ray, currentPoint, -0.3 * (0. + sin(iTime) * sin(iTime)))) {\n            if (minimalZ > currentPoint.z) {\n                minimalZ = currentPoint.z;\n            \ttriangleIndex = i;\n            \tanyTriangle = true;\n            }\n        }\n        if (testTriangle(i, ray, currentPoint, -0.8 * (0. + sin(iTime) * sin(iTime)))) {\n            if (minimalZ > currentPoint.z) {\n                minimalZ = currentPoint.z;\n            \ttriangleIndex = i;\n            \tanyTriangle = true;\n            }\n        }\n    }\n    \n    if (anyTriangle) {\n        vec3 c = triangleColor[triangleIndex].rgb;\n\n        vec3 normal = normalOfTriangle(triangleIndex);\n        i = 0;\n        float light = 0.3;\n        for (; i < LIGHT_SOURCES_COUNT; i++) {\n            vec3 dLight = currentPoint - lightPositions[i];\n            float d = dot(normal, dLight);\n            if (d > 0.) {\n                float angleCos = d / length(normal) / length(normal);\n                float distance = squareMagnitude(currentPoint, lightPositions[i]);\n            \tlight += (angleCos * 15. * intensities[i] / distance);\n            }\n        }\n\t\tc *= light;\n        fragColor = vec4(c, 1.0);\n    } else {\n        fragColor = vec4(0.22, 0.26, 0.3, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}