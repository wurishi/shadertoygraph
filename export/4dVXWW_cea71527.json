{"ver":"0.1","info":{"id":"4dVXWW","date":"1464420640","viewed":307,"name":"Smoother Rainbow","username":"JasonD","description":"HSV to RGB creates discontinuities in 1st order derivative: ugly lines and animation breaks.\n1. HSV to RGB\n2. sin() for RGB\n3. sin(sin(sin(...))) for RGB\n4. *custom ^2\n5. *custom ^3\n6. *custom ^4\n*see: https://www.shadertoy.com/view/ldyXD1","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["lines","rainbow","hsv","derivative","hsv2rgb","smoother","discontinuity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// Better Rainbow\n// May 23-28, 2016\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n#define COLOR_CYCLE_SPEED 0.1\n#define STRETCH_SCALE 3.0\n\n// ---- CONSTANTS ----------------------------------------------------------------\n\n#define PI 3.1415926535897932384626\n\n\n// ---- METHODS ----------------------------------------------------------------\n\n// hue = 0..1\n// 1/3 = red (odd, since it's normally 0)\nvec3 hue_to_rgb(float hue)\n{\n    // get rainbow color\n    float mag = mod(hue, 1.0 / 6.0) * 6.0; // 0..1\n    vec3 color = clamp(\n        abs(\n            fract(\n                vec3( hue + 2./3. ) + vec3(3,2,1) / 3.\n            ) * 6. - 3.\n        ) - 1., \n        0., \n        1.\n    );\n    return color;\n}\n\n// taken from my shader:\n// f(x)\n// https://www.shadertoy.com/view/ldyXD1\nfloat f_sin_sin_sin(float x)\n{\n    #define max sin(sin(sin(sin(sin(PI / 2.0)))))\n    return sin(sin(sin(sin(sin(x))))) / max;\n}\n\n// taken from my shader:\n// f(x)\n// https://www.shadertoy.com/view/ldyXD1\nfloat f_x_exp(float x, float exponent)\n{\n    float s = +1.0;\n\n    // cycle every sine wave\n    // so we only need to describe one\n    x = mod(x, PI * 2.0);\n\n    // mirror the second half of the sine wave\n    // with the first\n    // so we only need to describe the first half\n    if (x > PI) {\n        x = x - PI;\n        s = -1.0;\n    }\n    \n    // mirror the second quarter of the sine wave\n    // with the first quarter.\n    // so we only need to describe the first quarter.\n    float xx = PI / 2.0;\n    if (x > xx) {\n        x = xx - (x - xx);\n    }\n    \n    // now describe one quarter\n    // from 0..1\n    float p = x / xx;\n\n    // consider an upside-down, quadratic\n    // starting at (1,1)\n    // and going to the left, starting to accelerate downward in y\n    // as x goes from 1..0\n    \n    // this is it:\n    p = (p - 1.0);\n    p = pow(p, exponent); // quadratic or cubic or quartic, or other\n    p = 1.0 - p;\n    \n    // purpose of that is that we want a fast slope increase\n    // at the x=0 point, and no slope at the x=1\n    \n    // modify x (currently from 0..xx, the range of our quarter sine wave)\n    // so that it accounts for this new p from the quadratic.\n    // at x=0,p=0, and x=1,p=1\n    // so p(0..1)*xx(the max distance), x IS THE SAME.\n    // but inbetween, x rapidly gets away from 0,\n    // but slows to reach 1.\n    x = p * xx;\n    \n    return s * sin(x);    \n}\n\nvec3 better_rainbow_sin(float hue)\n{\n    float angle = hue * 2. * PI;\n    float r = 0.5 + 0.5 * sin(angle                    );\n    float g = 0.5 + 0.5 * sin(angle - 2. * PI      / 3.);\n    float b = 0.5 + 0.5 * sin(angle - 2. * PI * 2. / 3.);\n    vec3 color = vec3(r,g,b);\n    return color;\n}\n\nvec3 better_rainbow_fsinsinsin(float hue)\n{\n    float angle = hue * 2. * PI;\n    float r = 0.5 + 0.5 * f_sin_sin_sin(angle                    );\n    float g = 0.5 + 0.5 * f_sin_sin_sin(angle - 2. * PI      / 3.);\n    float b = 0.5 + 0.5 * f_sin_sin_sin(angle - 2. * PI * 2. / 3.);\n    vec3 color = vec3(r,g,b);\n    return color;\n}\n\nvec3 better_rainbow_fcustom(float hue, float exponent)\n{\n    float angle = hue * 2. * PI;\n    float r = 0.5 + 0.5 * f_x_exp(angle                    , exponent);\n    float g = 0.5 + 0.5 * f_x_exp(angle - 2. * PI      / 3., exponent);\n    float b = 0.5 + 0.5 * f_x_exp(angle - 2. * PI * 2. / 3., exponent);\n    vec3 color = vec3(r,g,b);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0..1\n    float hue = uv.x; // 0..1\n    hue += iTime * COLOR_CYCLE_SPEED;\n    hue += (uv.x - 0.5) * uv.y * STRETCH_SCALE;\n    \n    // ---- show all different rainbow options on different row slices:\n    \n    // for hue_to_rgb(), hue = 1/3 = red\n    // for all others, hue = 1/4 = red\n    \n\t// I want 0 to be red\n    // so fix this for most of them:\n    hue += 1. / 4.;\n    \n    #define NUM_FUNCTIONS 6.0\n    \n         if (uv.y < 1. / NUM_FUNCTIONS)        \n    {\n        vec3 color = better_rainbow_fcustom(hue, 4.0);\n        fragColor = vec4(color.rgb, 1.0); \n    } \n    else if (uv.y < 2. / NUM_FUNCTIONS)        \n    {\n        vec3 color = better_rainbow_fcustom(hue, 3.0);\n        fragColor = vec4(color.rgb, 1.0); \n    } \n    else if (uv.y < 3. / NUM_FUNCTIONS) \n    {\n        vec3 color = better_rainbow_fcustom(hue, 2.0);\n        fragColor = vec4(color.rgb, 1.0); \n    } \n    else if (uv.y < 4. / NUM_FUNCTIONS) \n    {\n        vec3 color = better_rainbow_fsinsinsin(hue);\n        fragColor = vec4(color.rgb, 1.0); \n    } \n    else if (uv.y < 5. / NUM_FUNCTIONS) \n    {\n        vec3 color = better_rainbow_sin(hue);\n        fragColor = vec4(color.rgb, 1.0); \n    } \n    else\n    {\n        // hue = 0..1\n        // hue = 1/3 = red\n        hue = hue \n            - 1. / 4. // undo the fix for the others\n            + 1. / 3.; // fix up for this one.\n        vec3 color = hue_to_rgb(hue);\n        fragColor = vec4(color.rgb, 1.0); \n    }\n}","name":"Image","description":"","type":"image"}]}