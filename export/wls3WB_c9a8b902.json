{"ver":"0.1","info":{"id":"wls3WB","date":"1557568900","viewed":310,"name":"Riemann Sphere Domain Coloring","username":"tpfto","description":"Domain coloring plot over the [url=https://en.wikipedia.org/wiki/Riemann_sphere]Riemann sphere[/url]. The function shown above is the example of [url=https://math.dartmouth.edu/~doyle/docs/icos/icos/icos.html]Doyle and McMullen[/url].","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["math","sphere","complex","domaincoloring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// domain coloring of the Doyle-McMullen iteration function on the Riemann sphere\n\n// domain coloring code from https://www.shadertoy.com/view/wtf3DN\n// sphere rendering forked from https://www.shadertoy.com/view/MssGRl by asalga\n\n// some constants\n\n#define PI 3.14159265359\n\n// range of the display\n\n#define SCALE 8.0\n\n// grid line spacing\n\n#define SPACING 0.125\n\n// from Fabrice Neyret, \n#define cmul(A, B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A, B) cmul( A, cinv(B) )\n#define cis(a) vec2( cos(a), sin(a) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\n\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\n\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified DLMF coloring, from https://www.shadertoy.com/view/WtXGWN\n\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// exponentiation using binary powering\nvec2 cpow( in vec2 z, in int n )\n{\n    if (n == 0) return vec2(1.0, 0.0);\n    if (n == 1) return z;\n    \n    if (n < 0) z = cinv(z);\n    n = abs(n);\n    \n    vec2 w = vec2(1.0, 0.0);\n    \n    for(int k = 0; k < 11; k++) { // should cover up to n == 1000\n        \n        if ((n & 1) == 1) w = cmul(w, z);\n\n        z = cmul(z, z);        \n        n >>= 1;\n\n        if (n < 2) break;\n    }\n        \n    return cmul(z, w);\n}\n\n// sphere normal\n\nvec3 getNormal(in vec2 c, in float r, in vec2 point)\n{\n\treturn mix(vec3(0.0, 0.0, 1.0), normalize(vec3(point - c, 0.0)), length(point - c)/r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    uv *= SCALE;\n    float r = 3.0; // sphere radius\n\t\n\tif( length(uv) < r)\n    {\n\t\tvec3 sphereNormal = vec3(getNormal(vec2(0.0), r, uv));\n\t\tvec3 dirLight = normalize(vec3(0.0, 0.0, 1.0));\n\t\tvec3 col = normalize(vec3(1.0)) * dot(sphereNormal, dirLight);\n\t\t\n\t\tfloat xa = sphereNormal.x, ya = sphereNormal.y;\n        float s = sqrt((1.0 - ya) * (1.0 + ya)), sx = sqrt((s - xa) * (s + xa));\n\n        // Riemann sphere variable\n        vec2 zz = sqrt((1.0 + ya)/(1.0 - ya)) * normalize(vec2(xa, sx));\n        // animate the variable, anticlockwise rotation\n        zz = cmul(zz, cis(0.1 * PI * iTime));\n        \n        // two steps of the Doyle-McMullen iteration; https://doi.org/10.1007/BF02392735\n        vec2 w = zz - cmul(12.0 * zz, cdiv(cmul(cpow(zz, 5) + vec2(11.0, 0.0), cpow(zz, 5)) - vec2(1.0, 0.0), cmul(11.0 * cpow(zz, 5), cpow(zz, 5) + vec2(6.0, 0.0)) - vec2(1.0, 0.0)));\n        w = w - cmul(12.0 * w, cdiv(cmul(cpow(w, 5) + vec2(11.0, 0.0), cpow(w, 5)) - vec2(1.0, 0.0), cmul(11.0 * cpow(w, 5), cpow(w, 5) + vec2(6.0, 0.0)) - vec2(1.0, 0.0)));\n        \n        float ph = atan(w.y, w.x), lm = log(0.0001 + length(w));\n    \n        vec3 c = smooth_dlmf(0.5 * (ph / PI));\n\n        c *= my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95);\n\t\t\n\t\tfragColor = vec4(0.2 + 2.5 * col * c, 1.0);\n\n\t} else {\n\n\t\tfragColor = vec4(0.16, 0.14, 0.13, 1.0);\n\n\t}\n}","name":"Image","description":"","type":"image"}]}