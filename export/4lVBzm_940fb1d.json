{"ver":"0.1","info":{"id":"4lVBzm","date":"1542125480","viewed":188,"name":"Voxel Marching (Movement)","username":"Opinder","description":"movement","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["movement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159\n\n#define sun vec3(0.2, 0.6, 0.4)\n#define sky vec3(0.39, 0.53, 0.95)\n#define render_distance 1024\n\nfloat getx() {return texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).r;}\nfloat gety() {return texture(iChannel0, vec2(0.5, 1.5) / iResolution.xy).r;}\nfloat getz() {return texture(iChannel0, vec2(0.5, 2.5) / iResolution.xy).r;}\n\nfloat a(vec2 pos) {\n    return abs((cos(pos.x * pi * 0.01) * cos(pos.y * pi * 0.01))) * 20.0 + 3.0 + getz();\n}\n\nfloat scene_dist(vec3 pos) {\n    float dist;\n    \n    if (abs((cos(pos.x * pi * 0.01) * cos(pos.z * pi * 0.01))) > (pos.y * 0.05)) {\n        dist = -1.0;\n    } else {\n        dist = 1.0;\n    }\n    \n    return dist;\n}\n\nmat3 rotate(mat3 v, vec3 r) {\n    //mat3 a = mat3(1, 0, 0, 0, cos(r.x), sin(r.x), 0, -sin(r.x), cos(r.x)); //pitch\n    //mat3 b = mat3(cos(r.y), 0, -sin(r.y), 0, 1, 0, sin(r.y), 0, cos(r.y)); //yaw\n    //mat3 c = mat3(cos(r.z), sin(r.z), 0, -sin(r.z), cos(r.z), 0, 0, 0, 1); //roll\n    \n    //d = a * b * c\n    mat3 d = mat3(cos(r.z)*cos(r.y), sin(r.z)*cos(r.y), -sin(r.y), cos(r.z)*sin(r.y)*sin(r.x) - sin(r.z)*cos(r.x), sin(r.z)*sin(r.y)*sin(r.x) + cos(r.z)*cos(r.x), cos(r.y)*sin(r.x), cos(r.z)*sin(r.y)*cos(r.x) + sin(r.z)*sin(r.x), sin(r.z)*sin(r.y)*cos(r.x) - cos(r.z)*sin(r.x), cos(r.y)*cos(r.x));\n    \n    return d * v;\n}\n\nmat3 camera(vec3 r) {\n    return mat3(sin(r.x)*cos(r.y), -sin(r.y), cos(r.x)*cos(r.y), sin(r.x)*sin(r.y)*sin(r.z) + cos(r.x)*cos(r.z), cos(r.y)*sin(r.z), cos(r.x)*sin(r.y)*sin(r.z) - sin(r.x)*cos(r.z), sin(r.x)*sin(r.y)*cos(r.z) - cos(r.x)*sin(r.z), cos(r.y)*cos(r.z), cos(r.x)*sin(r.y)*cos(r.z) + sin(r.x)*sin(r.z));\n    }\n\nfloat sum(vec3 v) {return v.x+v.y+v.z;} //{return dot(v, vec3(1.0));}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n    vec2 p = vec2(gety(), getx());\n    \n    vec3 camera_pos = vec3(p.x, floor(a(p - 0.5)), p.y);\n    vec3 camera_rot = vec3(2.0 * mouse.x * pi, -mouse.y * pi, 0);\n    mat3 camera_direction = camera(camera_rot);\n    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //pos and look coord\n    \n\tvec3 ray_dir = normalize(camera_direction[0] + uv.x*camera_direction[1] + uv.y*camera_direction[2]);\n    \n    //voxel trace\n    vec3 mask;\n    vec3 voxel_pos = vec3(floor(camera_pos));\n\tvec3 deltadist = abs(vec3(length(ray_dir)) / ray_dir);\n\tvec3 increment = sign(ray_dir);\n\tvec3 side = deltadist * (increment * (voxel_pos - camera_pos) + (increment * 0.5) + 0.5);\n    \n    int i;\n    \n    for (i; i < render_distance; i++) {\n\n        if (scene_dist(voxel_pos) < 0.0) {break;}\n\n        mask = step(side, side.yzx) * step(side, side.zxy);\n        side += deltadist * mask;\n        voxel_pos += increment * mask;\n    }\n    \n    vec3 color;\n    \n    if (i < render_distance) {\n\n        vec3 end_ray_pos = ray_dir / sum(mask * ray_dir) * sum(mask * (voxel_pos + vec3(lessThan(ray_dir, vec3(0))) - camera_pos)) + camera_pos;\n        \n        //texture pos\n        vec2 tex_uv = mod(vec2(sum(mask * end_ray_pos.yzx), sum(mask * end_ray_pos.zxy)), vec2(1.0));\n\n        //block\n        color = texture(iChannel1, tex_uv).xyz;\n            \n        //lighting\n        float light = length(sun * mask * (vec3(lessThan(ray_dir, vec3(0))) + 0.5));\n        float light_dist = min(float(i)/float(1024), 0.8);\n        color *= pow(light, 1.0 - light_dist);\n        \n    } else {\n        \n        //sky\n        color = sky * (0.8 + 0.7*uv.y*uv.y);\n        \n    }\n    \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.14159\n\n#define KEY_W 87\n#define KEY_S 83\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n\nfloat keyDown(int keyCode) {\n\treturn textureLod(iChannel1, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n\treturn textureLod(iChannel1, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat getx() {return texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).r;}\nfloat gety() {return texture(iChannel0, vec2(0.5, 1.5) / iResolution.xy).r;}\nfloat getz() {return texture(iChannel0, vec2(0.5, 2.5) / iResolution.xy).r;}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x == 0.5) {\n    \tvec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n        \n        float rot = 2.0 * mouse.x * pi;\n        float speed = 0.0234 * (keyDown(KEY_SHIFT) + 1.0);\n        \n        if (fragCoord.y == 0.5) {\n            float pos = getx();\n            if (keyDown(KEY_W) == 1.0) {pos += cos(rot) * speed;}\n            if (keyDown(KEY_S) == 1.0) {pos -= cos(rot) * speed;}\n            if (keyDown(KEY_A) == 1.0) {pos += sin(rot) * speed;}\n            if (keyDown(KEY_D) == 1.0) {pos -= sin(rot) * speed;}\n            fragColor = vec4(pos,0.0,0.0,1.0);\n        } else if (fragCoord.y == 1.5) {\n            float pos = gety();\n            if (keyDown(KEY_W) == 1.0) {pos += sin(rot) * speed;}\n            if (keyDown(KEY_S) == 1.0) {pos -= sin(rot) * speed;}\n            if (keyDown(KEY_A) == 1.0) {pos -= cos(rot) * speed;}\n            if (keyDown(KEY_D) == 1.0) {pos += cos(rot) * speed;}\n            fragColor = vec4(pos,0.0,0.0,1.0);\n        } else if (fragCoord.y == 2.5) {\n            float pos = getz();\n            if (keyDown(KEY_CTRL) == 1.0) {pos++;}\n            fragColor = vec4(pos,0.0,0.0,1.0);\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float getx() {return texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).r;}\nfloat gety() {return texture(iChannel0, vec2(0.5, 1.5) / iResolution.xy).r;}\nfloat getz() {return texture(iChannel0, vec2(0.5, 2.5) / iResolution.xy).r;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x == 0.5) {\n        if (fragCoord.y == 0.5) {\n            float pos = getx();\n            fragColor = vec4(pos,0.0,0.0,1.0);\n        } else if (fragCoord.y == 1.5) {\n            float pos = gety();\n            fragColor = vec4(pos,0.0,0.0,1.0);\n        } else if (fragCoord.y == 2.5) {\n            float pos = getz();\n            fragColor = vec4(pos,0.0,0.0,1.0);\n        }\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}