{"ver":"0.1","info":{"id":"3tBBzG","date":"1599157887","viewed":115,"name":"Some BRDF sample","username":"Shcherbakov","description":"Второй семпл с различными BRDF со второго стрима.\nStream: https://www.youtube.com/watch?v=AkJjbn1erPU","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FAR_INF = 1e10;\n\nfloat spheres_raycast(vec3 origin, vec3 dir, vec3 spherePos) {\n    vec3 sphereToCam = origin - spherePos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - 0.35 * 0.35;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nbool sphere_params(vec3 origin, vec3 dir, vec3 spherePos, inout float dist, out vec3 interPos, out vec3 interNorm) {\n    float d = spheres_raycast(origin, dir, spherePos);\n    if (d < dist) {\n        dist = d;\n        interPos = origin + dist * dir;\n        interNorm = normalize(interPos - spherePos);   \n        return true;\n    }\n    return false;\n}\n\nvec3 fresnel(vec3 F0, float cosTheta)\n{\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat ndfGGX(float cosLh, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (3.14 * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k)\n{\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaGGX(float cosLi, float cosLo, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -10);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1));\n    \n    float interDist = FAR_INF;\n    vec3 worldPos;\n    vec3 normal;\n    int halfCols = 4;\n    int halfRows = 2;\n    vec3 sphereColor = vec3(0, 0.5, 0.5);\n    vec3 lighting;\n    const float LIGHT_RAD = 8.0;\n    vec3 lightPos = vec3(LIGHT_RAD * sin(iTime), 0, LIGHT_RAD * cos(iTime));\n    float f1;\n    float metalness;\n    int interRow;\n    for (int x = -halfCols; x <= halfCols; ++x) {\n        for (int y = -halfRows; y <= halfRows; ++y) {\n            if (sphere_params(cameraPos, viewVec, vec3(x, y, 0), interDist, worldPos, normal)) {\n                f1 = float(x + halfCols) / float(halfCols * 2 + 2) + 1e-5;\n                metalness = float(y + halfRows) / float(halfRows * 2 + 2) + 1e-5;\n                interRow = y + halfRows;\n            }\n        }\n    }\n    if (interDist < FAR_INF) {\n        sphereColor = vec3(0.1, 0.5, 0.5);\n        vec3 extinction = vec3(0, 168, 107) / 255.0;\n        \n        const float F_DI = 0.04;\n        vec3 N = normal;\n        vec3 V = -viewVec;\n        vec3 toLight = lightPos - worldPos;\n        float atten = 1.0 / length(toLight);\n        vec3 L = toLight * atten;\n        atten *= 10.0;\n        vec3 H = normalize(V + L);\n        vec3 R = reflect(V, N);\n        vec3 F0 = mix(vec3(F_DI), sphereColor, metalness);\n        float NoV = max(dot(N, V), 0.0);\n        float NoL = max(dot(N, L), 0.0);\n        float HoL = max(dot(L, H), 0.0);\n        float NoH = max(dot(N, H), 0.0);\n        if (interRow == 0) {\n            float f = max(dot(N, L) + f1, 0.0) / (f1 + 1.0);\n            lighting = sphereColor * f * atten;\n        } else if (interRow == 1) {\n            lighting = sphereColor * (pow(NoL, 1.0 + f1) * pow(1.0 - dot(N, V), 1.0 - f1) + 0.1) * atten;\n        } else if (interRow > 1) {\n            float inFactor = max(0.0, dot(N, -L)) + (dot(N, -V) * 0.5 + 0.5);\n            vec3 indirect = vec3(inFactor) * extinction * f1;\n            lighting = (indirect + extinction * (dot(N, L) * 0.5 + 0.5)) * atten;\n        }\n    } else {\n        vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n    \tvec3 viewVec = normalize(vec3(uv, 1));\n        lighting = texture(iChannel0, viewVec).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(lighting,1.0);\n}","name":"Image","description":"","type":"image"}]}