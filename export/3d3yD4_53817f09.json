{"ver":"0.1","info":{"id":"3d3yD4","date":"1600910986","viewed":286,"name":"A Normal Sphere","username":"nothole","description":"Bare bones raytracer that renders a sphere and its normals.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raytracer","sphere","shader","normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rO = vec3(0.0); // The ray origin\n\nvec3 sO = vec3(0.0, 0.0, -5.0); // The sphere origin\nfloat sR = 2.0; // The sphere radius\nfloat sR2 = 2.0*2.0; // The sphere radius squared\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5); // Center rays with 0.5 \n    uv.x *= iResolution.x / iResolution.y; // Apply the aspect ratio\n    \n    vec3 rD = normalize(vec3(uv.x, uv.y, -1.0)); // Ray direction vector\n\n    vec3 col = vec3(0.2); // Color output\n    \n    vec3 A = sO - rO; // Difference between ray origin and sphere center\n    float B = dot(A, rD); // Lenght of vector A projected onto ray direction\n    float C2 = dot(A, A) - B*B; // The hypotenuse squared of triangle ABC\n    \n    // Check if ray has overshot sphere\n    if (C2 <= sR2) {\n        float tH = sqrt(sR2-C2); // Find distance of intersection on sphere\n        float t = B - tH;\n        vec3 hitP = rO + rD * t; // Get point of intersection on sphere\n        vec3 normal = normalize(hitP - sO); // Calculate normal from hit point\n        \n        col = normal; // Color normal\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}