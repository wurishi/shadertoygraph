{"ver":"0.1","info":{"id":"ls3GzS","date":"1453116576","viewed":462,"name":"sand relics","username":"raziel","description":"Playing around with noise and sdf to render some sandy dunes. Some lighting tricks picked up from Journey presentation. Plus thanks to iq for all the sdf resources. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","valuenoise","sand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- thanks to iq for all the ray-marching sdf info and awesomeness\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat value_noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 s = smoothstep(0.0, 1.0, f);\n    float nx0 = mix(rand(i + vec2(0.0, 0.0)), rand(i + vec2(1.0, 0.0)), s.x);\n    float nx1 = mix(rand(i + vec2(0.0, 1.0)), rand(i + vec2(1.0, 1.0)), s.x);\n    return mix(nx0, nx1, s.y);\n}\n\nfloat sdf_sbox(in vec3 p, in vec3 l)\n{\n  vec3 d = abs(p) - l;\n  return min(max(d.x, max(d.y, d.z)), length(max(d, 0.0)));\n}\n\nfloat sdf_cbox(in vec3 p, in float l)\n{\n    float fmax = 10000000.0;\n    float b0 = sdf_sbox(p, vec3(fmax, l, l));\n    float b1 = sdf_sbox(p, vec3(l, fmax, l));\n    float b2 = sdf_sbox(p, vec3(l, l, fmax));\n    return min(b0, min(b1, b2));\n}\n\nfloat intersect(vec3 p)\n{\n    const int no = 3;\n    float tot = 0.0;\n    vec2 q = p.xz * 0.35;\n    float a = 0.5;\n    float f = 1.0;\n    for (int i = 0; i < no; ++i)\n    {\n        tot += value_noise(q * f) * a;\n        a *= 0.5;\n        f *= 2.5;\n        q = q * mat2(0.5, -0.866, 0.866, 0.5) * 0.65;\n        q += vec2(2.5, 4.8);\n    }\n    \n    float d1 = p.y - tot * 2.0;\n    \n    vec3 qq = p;\n    qq.xz = mod(qq.xz, 5.0) - 2.5;\n    qq.y -= 2.0;\n    \n    const int mi = 3;\n    float sf = 3.0;\n    float dcc = 0.0;\n    float db = sdf_sbox(qq, vec3(0.5));\n    vec3 pp = qq;\n    for (int i = 0; i < mi; ++i)\n    {\n        pp.xy = pp.xy * mat2(0.5, -0.866, 0.866, 0.5);\n        vec3 ppm = pp;\n       \tppm = mod(ppm, 0.2) - 0.1;\n        dcc = sdf_cbox(ppm * sf, 0.1) / sf;\n        db = max(db, -dcc);\n        sf *= 1.5;      \n    }\n    \n    float d2 = max(db, length(qq) - 0.5);\n    return min(d1, d2);\n}\n\nfloat intersect_shadow(vec3 p)\n{   \n    vec3 qq = p;\n    qq.xz = mod(qq.xz, 5.0) - 2.5;\n    qq.y -= 2.0;\n    \n    const int mi = 3;\n    float sf = 3.0;\n    float dcc = 0.0;\n    float db = sdf_sbox(qq, vec3(0.5));\n    vec3 pp = qq;\n    for (int i = 0; i < mi; ++i)\n    {\n        pp.xy = pp.xy * mat2(0.5, -0.866, 0.866, 0.5);\n        vec3 ppm = pp;\n       \tppm = mod(ppm, 0.2) - 0.1;\n        dcc = sdf_cbox(ppm * sf, 0.1) / sf;\n        db = max(db, -dcc);\n        sf *= 1.5;      \n    }\n    \n    float d2 = max(db, length(qq) - 0.5);\n    return d2;\n}\n\nvec3 compute_normal(vec3 pos)\n{\n    vec3 eps = vec3(0.01, 0.0, 0.0);\n    vec3 pos00 = (pos + eps.xyy);\n    vec3 pos01 = (pos - eps.xyy);\n    vec3 pos10 = (pos + eps.yxy);\n    vec3 pos11 = (pos - eps.yxy);\n    vec3 pos20 = (pos + eps.yyx);\n    vec3 pos21 = (pos - eps.yyx);\n\tvec3 normal = vec3(intersect(pos00) - intersect(pos01), \n                       intersect(pos10) - intersect(pos11), \n                       intersect(pos20) - intersect(pos21));\n\treturn normalize(normal);\n}\n\nfloat compute_shadows(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.01;\n    for(int i = 0; i < 16; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = intersect_shadow(p);\n        res = min(res, max(d, 0.0) * 16.0 / t);\n        if (res < 0.001)\n            break;\n        t += d * 0.5;\n    }\n    \n    return res;\n}\n\nvec2 ray_march(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    float tmax = 120.0;\n    const int smax = 200;\n    float st = 0.0;\n    \n    for (int i = 0; i < smax; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float res = intersect(p);\n        if (res < 0.001 || t > tmax)\n            break;\n        t += res * 0.5;\n        st++;\n    }\n    \n    if (t < tmax)\n        return vec2(t, st / float(smax));\n    else\n        return vec2(-1.0, st / float(smax));\n}\n\n// --- some lighting tricks from \n// --- http://advances.realtimerendering.com/s2012/thatgamecompany/SandRenderingInJourney_thatgamecompany.pptx\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = (1.0 - rd.yyy) * vec3(0.5, 0.7, 0.98);\n    vec3 ld = normalize(vec3(1.0, 0.5, -1.0));\n    \n    vec2 res = ray_march(ro, rd);\n    if (res.x > 0.0)\n    {\n        vec3 pn = ro + res.x * rd;\n        vec3 n1 = compute_normal(pn);\n        vec3 n2 = normalize(textureLod(iChannel0, pn.xz * 3.0, 0.0).rgb);\n        vec3 nn1 = normalize(mix(n1, n2, 0.2));\n        vec3 nn2 = normalize(mix(n1, n2, 0.4));\n        \n        vec3 wv = vec3(sin(pn.xz * 4.0), 1.0);\n        wv = vec3(pn.x * 4.0 + wv.y);\n        wv = vec3(mod(wv.x, 1.1)) * 0.6 + 0.4;\n        \n        nn1 = normalize(mix(nn1, wv, 0.3));\n        \n        float sha = compute_shadows(pn + nn1 * 0.01, ld);\n        \n        nn1.y *= 0.3;\n        vec3 ndotl = clamp(2.0 * dot(nn1, ld) * sha * (1.0 - res.y), 0.0, 1.0) * vec3(0.55, 0.7, 0.6) + vec3(0.45, 0.3, 0.4);\n        col = ndotl * vec3(0.909, 0.686, 0.415) * 1.2;\n        col += (1.0 - ndotl) * vec3(0.36, 0.2, 0.176);\n        \n        nn2 = normalize(mix(nn2, wv, 0.3));\n        \n        nn2.y *= 0.3;\n        float ndotv = clamp(dot(nn2, -rd), 0.0, 1.0);\n        col += pow(1.0 - ndotv, 5.0) * vec3(1.0, 0.8, 0.6) * clamp(dot(nn2, ld), 0.0, 1.0);\n        \n        float fog = exp(-0.0003 * res.x * res.x);\n        col *= fog;\n        col += (1.0 - fog) * vec3(0.5, 0.7, 0.98);\n    }\n    \n    float sun = clamp(dot(rd, ld), 0.0, 1.0) * 0.5 + 0.5; \n    col += vec3(1.0, 0.8, 0.6) * 0.6 * pow(sun, 8.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xi[5];\n    xi[0] = vec2(0.0, 0.0);\n    xi[1] = vec2(0.25, 0.0);\n    xi[2] = vec2(-0.25, 0.0);\n    xi[3] = vec2(0.0, 0.25);\n    xi[4] = vec2(0.0, -0.25);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec3 cp = vec3(0.0, 2.9 + mo.y, 5.0 - iTime);\n    vec3 cu = normalize(vec3(0.0, 0.8, -0.2));\n    vec3 cr = vec3(1.0, 0.0, 0.0);\n    vec3 cf = normalize(cross(cu, cr));\n    float fl = 2.1;\n    \n    vec3 col = vec3(0.0);\n    const int nx = 1;\n    for (int i = 0; i < nx; ++i)\n    {\n        vec2 c_ss = (fragCoord.xy + xi[i]) / iResolution.xy;\n        vec2 c_cs = 2.0 * c_ss - 1.0;\n        c_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 rd = normalize(cf * fl + cr * c_cs.x + cu * c_cs.y);\n        col += render(cp, rd);\n    }\n    col /= float(nx);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}