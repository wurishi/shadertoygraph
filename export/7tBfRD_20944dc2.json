{"ver":"0.1","info":{"id":"7tBfRD","date":"1717603065","viewed":36,"name":"Implicit molecular surface","username":"PlathC","description":"3D implementation of the molecular SDF presented in Implicit Representation of Molecular Surfaces by Parulek et al.","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","sdf","molecular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float toroidalPatch(vec3 p, Atom atoms[2]) {\n    // Evaluate if we are in the toroidal patch\n    float g1ofp2 = sdSphere(projectToSolvent(p, atoms[1]), atoms[0].position, atoms[0].radius + ProbeRadius);\n    float g2ofp1 = sdSphere(projectToSolvent(p, atoms[0]), atoms[1].position, atoms[1].radius + ProbeRadius);\n    \n    if(max(g1ofp2, g2ofp1) <= 0.) {\n        return ProbeRadius - length(p - intersectionPoint(p, atoms));\n    }\n        \n    // if we are not in the patch we can compute the union of both atoms\n    return min(sdSphere(p, atoms[0].position, atoms[0].radius), sdSphere(p, atoms[1].position, atoms[1].radius));\n}\n\nfloat sphericalPatch(vec3 p, Atom atoms[3]) {\n    // Evaluate if we are in the spherical patch\n    bool b123 = isInAreaOfInfluence(p, Atom[](atoms[0], atoms[1]), atoms[2]) \n             && isInAreaOfInfluence(p, Atom[](atoms[0], atoms[2]), atoms[1])\n             && isInAreaOfInfluence(p, Atom[](atoms[1], atoms[2]), atoms[0]);\n    \n    if(b123) {\n        return ProbeRadius - length(p - tripleIntersectionPoint(p, atoms));\n    }\n    \n    // If we are not in the patch we can compute the union of the toroidal patch of each atom couples\n    float d1 = toroidalPatch(p, Atom[](atoms[0], atoms[1]));\n    float d2 = toroidalPatch(p, Atom[](atoms[0], atoms[2]));\n    float d3 = toroidalPatch(p, Atom[](atoms[1], atoms[2]));\n    \n    return min(min(d1, d2), d3);\n}\n\nfloat sdMolecule(vec3 p, Atom atoms[3]) {\n    float dist = MaxFloat;\n    \n    // Find each atom's neighboors.\n    for(uint i = 0u; i < 3u; i++) {\n        Atom currentAtom = atoms[i];\n        \n        float distanceFromAtom = sdSphere(p, currentAtom.position, currentAtom.radius);\n    \n        uint numberOfClosestAtoms = 0u;\n\n        Atom closestAtoms[2] = Atom[](\n            Atom(vec3(0.f), -1.f),\n            Atom(vec3(0.f), -1.f)\n        );\n\n        float lastDistance = MaxFloat;\n        for(uint j = 0u; j < 2u; j++) {\n            if(i == j) continue;\n            \n            float currentDistance = length(currentAtom.position - atoms[j].position);\n            if(currentDistance < (ProbeRadius * 2.f + currentAtom.radius + atoms[j].radius)) {\n                closestAtoms[numberOfClosestAtoms++] = atoms[j];\n            }\n        }\n        \n        if (numberOfClosestAtoms == 1u) {\n            dist = min(dist, toroidalPatch(p, Atom[](currentAtom, closestAtoms[0])));\n        } else if (numberOfClosestAtoms == 2u) {\n            dist = min(dist, sphericalPatch(p, Atom[](currentAtom, closestAtoms[0], closestAtoms[1])));\n        } else {\n            dist = min(dist, distanceFromAtom);\n        }\n    }\n    return dist;\n}\n\nRay computeRay(vec2 fragmentCoordinates) {\n\tvec2 uv = (2. * (fragmentCoordinates.xy / iResolution.xy) - 1.f);\n\n    // Pinhole model\n    vec3 pixelCamera = vec3(\n        uv.x * tan(DEG2RAD(90.f / 2.f)),\n        uv.y * tan((iResolution.y / iResolution.x) * DEG2RAD(90.f) / 2.f),\n        1.f\n    );\n\n    vec3 target  = vec3(0.f);\n    float xAngle = 0.;\n    float yAngle = 0.;\n\n    if( iMouse.z > 0.01) {\n        vec2 mousePosition = ( 2.f * (iMouse.xy / iResolution.xy) -1.f) * 360.f;\n        xAngle = mousePosition.y;\n        yAngle = mousePosition.x;\n    }\n    \n    Ray ray = Ray(vec3(0.f, -1.f, -7.f), normalize(pixelCamera - target));\n    \n    mat3 camRotation  = yRotationMatrix(DEG2RAD(yAngle));\n    camRotation      *= xRotationMatrix(DEG2RAD(xAngle));\n    ray.origin       *= camRotation;\n    ray.direction    *= camRotation;\n\n    return ray;\n}\n\n// Normal estimation by Inigo Quilez\n// Reference: https://iquilezles.org/articles/normalsSDF\nvec3 estimateNormal(vec3 p, Atom atoms[3]) {\n    const float eps = 0.00001f; \n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(sdMolecule(p+h.xyy, atoms) - sdMolecule(p-h.xyy, atoms),\n                          sdMolecule(p+h.yxy, atoms) - sdMolecule(p-h.yxy, atoms),\n                          sdMolecule(p+h.yyx, atoms) - sdMolecule(p-h.yyx, atoms)));\n}\n\nvec4 phong(vec3 rayOrigin, vec3 point, vec3 normal) {\n    const vec3 color = vec3(0.7f);\n    const float lightIntensity = 0.6f;\n    \n    vec3 lightDirection = normalize(rayOrigin - point);\n    vec3 viewerDirection = normalize(rayOrigin - point);\n    \n    vec3 halfWay = normalize(viewerDirection + lightDirection);\n    float lightDotNormal = max(dot(lightDirection, normal), 0.f);\n    \n    vec3 diffuse = color * lightDotNormal;\n    \n    float specularAngle = max(dot(normal, halfWay), 0.f);\n    float scaledSpecular = pow(specularAngle, 225.f);\n    vec3 specular = color * scaledSpecular;\n    \n    return vec4(lightIntensity * (color + diffuse + specular), 1.f);\n}\n\nvec4 render(vec2 fragmentCoordinates, Atom atoms[3]) {\n    Ray ray = computeRay(fragmentCoordinates);\n\n    vec4 outputColor = vec4(0.3f);\n    float t = 0.f;\n    uint stepNumber = 0u;\n    bool hit = false;\n    vec3 currentPosition;\n    while (t < MaxDistance && stepNumber++ < MaxSteps) {\n        currentPosition            = ray.origin + t * ray.direction;\n        float distanceFromMolecule = sdMolecule(currentPosition, atoms);\n\n        if(distanceFromMolecule <= Threshold) {\n            hit = true;\n            break;\n        }\n            \n        t += max( distanceFromMolecule, Threshold );\n    }\n    \n    if( hit ) \n        return phong(ray.origin, currentPosition, estimateNormal(currentPosition, atoms));\n    \n    return outputColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Atom atoms[3] = Atom[](\n        Atom(vec3(-1.5f - sin(iTime * 2.f), 0.f,                     0.), 1.1f),\n        Atom(vec3( 1.5f + sin(iTime * 2.f), 0.f,                     0.), 1.2f ),\n        Atom(vec3( 0.f ,                    sin(iTime * 1.2f) - 2.f, 0.), 1.f )\n    );\n    fragColor = render(fragCoord, atoms);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float Pi                 = 3.14159265359f;\nconst float MaxDistance        = 10.f;\nconst float Threshold          = 1e-2f;\nconst float StartingT          = 5.f;\nconst uint  MaxSteps           = 75u;\nconst float Epsilon            = 0.001f;\nconst uint MaxNewtonsIteration = 100u;\n\n// Reference: https://stackoverflow.com/a/61262594\nconst float MaxFloat = intBitsToFloat(0x7F800000);\n\n// R_p\nconst float ProbeRadius = 1.4f;\n\n#define DEG2RAD(deg) ((deg) * Pi / 180.f)\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Atom {\n    vec3 position;\n    float radius;\n};\n\nmat3 xRotationMatrix(float angle) {\n    return mat3(1.f, 0.f,         0.f,\n                0.f, cos(angle), -sin(angle),\n                0.f, sin(angle),  cos(angle));\n}\n\nmat3 yRotationMatrix(float angle) {\n    return mat3( cos(angle),  0.f, sin(angle),\n                 0.f,         1.f, 0.f,\n                -sin(angle),  0.f, cos(angle));\n}\n\n// f(p)\nfloat sdSphere(vec3 p, vec3 position, float r ) \n{\n    return length(p - position) - r;\n}\n\n// (∇f(p)/x, ∇f(p)/y, ∇f(p)/z)\nvec3 sgSphere( vec3 p, vec3 position, float r ) {\n    vec3 translated = p - position;\n    return translated / length(translated);\n}\n\n// p - f(p) * (∇f(p)/x, ∇f(p)/y)\nvec3 projectToSolvent(vec3 p, Atom atom) {\n    float gi = sdSphere(p, atom.position, atom.radius + ProbeRadius);\n    return p - gi * sgSphere(p, atom.position, atom.radius + ProbeRadius);\n}\n\nvec3 V(vec3 p, Atom atoms[2]) {\n    return vec3(\n        sdSphere(p, atoms[0].position, atoms[0].radius + ProbeRadius),\n        sdSphere(p, atoms[1].position, atoms[1].radius + ProbeRadius), \n        0.\n    );\n}\n\nmat3 M(vec3 p, Atom atoms[2]) {\n    vec3 grad1 = sgSphere(p, atoms[0].position, atoms[0].radius + ProbeRadius);\n    vec3 grad2 = sgSphere(p, atoms[1].position, atoms[1].radius + ProbeRadius);\n    return mat3(grad1, grad2, cross(grad1, grad2));\n}\n\n// x_{1-2}\nvec3 intersectionPoint(vec3 p, Atom atoms[2]) {\n    vec3 currentPoint = p;\n    \n#define DistanceToAtom(p, index) abs(sdSphere(p, atoms[index].position, atoms[index].radius + ProbeRadius))\n\n    float d1 = DistanceToAtom(currentPoint, 0);\n    float d2 = DistanceToAtom(currentPoint, 1);\t\n    \n    // Newton's iterative method\n    uint i = 0u;\n    while((d1 > Epsilon || d2 > Epsilon) && i < MaxNewtonsIteration) {\n        currentPoint -= V(currentPoint, atoms) * inverse(M(currentPoint, atoms));\n        d1 = DistanceToAtom(currentPoint, 0);\n        d2 = DistanceToAtom(currentPoint, 1);\n        i++;\n    }\n    \n#undef DistanceToAtom\n\n    return currentPoint;\n}\n\n// B_{i-j-k}\nbool isInAreaOfInfluence(vec3 p, Atom mainAtoms[2], Atom extension) {\n    vec3 p1 = projectToSolvent(p, mainAtoms[0]);\n    vec3 p2 = projectToSolvent(p, mainAtoms[1]);\n    float g1ofp2 = sdSphere(p2, mainAtoms[0].position, mainAtoms[0].radius + ProbeRadius);\n    float g2ofp1 = sdSphere(p1, mainAtoms[1].position, mainAtoms[1].radius + ProbeRadius);\n    \n    vec3 x12 = intersectionPoint(p, Atom[](mainAtoms[0], mainAtoms[1]));\n    float g3 = sdSphere(x12, extension.position, extension.radius + ProbeRadius);\n    return max(g1ofp2, g2ofp1) <= ProbeRadius && g3 <= 0.f;\n}\n\nvec3 tV(vec3 p, Atom atoms[3]) {\n    return vec3(\n        sdSphere(p, atoms[0].position, atoms[0].radius + ProbeRadius),\n        sdSphere(p, atoms[1].position, atoms[1].radius + ProbeRadius), \n        sdSphere(p, atoms[2].position, atoms[2].radius + ProbeRadius)\n    );\n}\n\nmat3 tM(vec3 p, Atom atoms[3]) {\n    vec3 grad1 = sgSphere(p, atoms[0].position, atoms[0].radius + ProbeRadius);\n    vec3 grad2 = sgSphere(p, atoms[1].position, atoms[1].radius + ProbeRadius);\n    vec3 grad3 = sgSphere(p, atoms[2].position, atoms[2].radius + ProbeRadius);\n    mat3 mat = mat3(grad1, grad2, grad3);\n    return inverse(mat);\n}\n\n// x_{1-2-3}\nvec3 tripleIntersectionPoint(vec3 p, Atom atoms[3]) {\n    vec3 currentPoint = p;\n    \n#define DistanceToAtom(p, index) abs(sdSphere(p, atoms[index].position, atoms[index].radius + ProbeRadius))\n\n    float d1 = DistanceToAtom(currentPoint, 0);\n    float d2 = DistanceToAtom(currentPoint, 1);\t\n    float d3 = DistanceToAtom(currentPoint, 2);\t\n    \n    // Newton's iterative method\n    uint i = 0u;\n    while((d1 > Epsilon || d2 > Epsilon || d3 > Epsilon) && i < MaxNewtonsIteration) {\n        currentPoint -= tV(currentPoint, atoms) * tM(currentPoint, atoms);\n        d1 = DistanceToAtom(currentPoint, 0);\n        d2 = DistanceToAtom(currentPoint, 1);\n        d3 = DistanceToAtom(currentPoint, 2);\n        i++;\n    }\n    \n#undef DistanceToAtom\n\n    return currentPoint;\n}\n\n","name":"Common","description":"","type":"common"}]}