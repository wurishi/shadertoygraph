{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec2 tA = vec2(0);\nfloat rA = 0.0;\n\nvec2 tB = vec2(0);\nfloat rB = 0.0;\n\nfloat cycle(float period, float stops) {\n    float u = fract(iTime/(period*stops));\n    return floor(u*stops);\n}\n\nfloat whichF, whichA, whichB;\n\nvec2 xformFwd(vec2 p, vec2 t, float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c)*p + t;\n}\n\nvec2 xformInv(vec2 p, vec2 t, float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c)*(p - t);\n}\n\nvec3 hue(float h) {\t\n\tvec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\nfloat sd(vec2 p, vec3 c) {\n    return c.z*length(p-c.xy);\n}\n\nvec3 cDisc(vec2 p) {           \n    const float r = 2.5;\n    float scl = r/length(p);\n    vec2 pc = p*scl;\n    return vec3(pc, scl > 1.0 ? -1.0 : 1.0);\n}\n\nvec3 cBox(vec2 p, vec2 b) {\n    \n    vec2 s = sign(p);\n    vec2 d = abs(p) - b;\n    float md = max(d.x, d.y);\n    if (md < 0.0) { // inside\n        if (md == d.x) { // \n            return vec3(p - s*vec2(d.x, 0), -1.);\n        } else {\n            return vec3(p - s*vec2(0, d.y), -1.);\n        }\n    } else {\n       \treturn vec3(clamp(p, -b, b), 1.); // outside\n    }\n    \n}\n\n\nfloat lsign(vec2 p1, vec2 p2, vec2 p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nvec3 lclosest(vec2 p, vec2 a, vec2 b) {\n    vec2 pc = mix(a, b, clamp(dot(p-a,b-a)/dot(b-a,b-a), 0., 1.));\n    return vec3(pc, length(p-pc));\n}\n\nvec3 lselect(vec3 pc1, vec3 pc2) {\n    return pc1.z < pc2.z ? pc1 : pc2;\n}\n\nvec3 cTri(vec2 p) {\n    \n    vec2 a = vec2(-3., -1.75);\n    vec2 b = vec2( 0.,  3.5);\n    vec2 c = vec2( 3., -1.75);\n    \n    float e = max(max(lsign(p, a, b), lsign(p, b, c)), lsign(p, c, a));\n    \n    vec3 pc1 = lclosest(p,a,b);\n    vec3 pc2 = lclosest(p,b,c);\n    vec3 pc3 = lclosest(p,c,a);\n        \n    vec3 pc = lselect(pc1, lselect(pc2,pc3));\n            \n    return vec3(pc.xy, sign(e));\n    \n}\n\nvec3 cCapsule(vec2 p, vec2 lr) {\n    vec2 a = vec2(0.5*lr.x, 0);\n    vec3 lc = lclosest(p, -a, a);\n    vec2 pd = p-lc.xy;\n    vec2 pc = lc.xy + pd*lr.y/lc.z;\n    return vec3(pc, sign(lc.z-lr.y));\n}\n\nvec3 cShape(vec2 p, float t) {\n    return t == 0.0 ? cTri(p) :\n    \tt == 1.0 ? cDisc(p) :\n    \tt == 2.0 ? cBox(p, vec2(3.0, 2.0)) :\n    \tcCapsule(p, vec2(4.0, 2.0));\n}\nvec3 shapeA(vec2 p) {\n    p = xformInv(p, tA, rA);\n    vec3 c = cShape(p, whichA);\n    return vec3(xformFwd(c.xy, tA, rA), c.z);\n}\n\nvec3 shapeB(vec2 p) {\n    p = xformInv(p, tB, rB);\n    vec3 c = cShape(p, whichB);\n    return vec3(xformFwd(c.xy, tB, rB), c.z);\n}\n\nfloat triwave(float x) {\n    return 2.0*abs(0.5*x-floor(0.5*x+0.5));\n}\n\nvec3 d2c(float d) {\n    \n    float n = floor(d*2.0); // ring spacing\n    float s = mod(n, 2.0);\n    float h;\n\n    if (d > 1e-6) {\n    \th = triwave(n/16.)*.33333;       \n    } else {\n        h = 0.83333 - (1.0-triwave(n/12.))*.1666;        \n    }\n    \n    return mix(hue(h)*(0.5*s + 0.5), vec3(1), 0.6);    \n    \n}\n\nvec2 projClosest(vec2 p, vec3 c) {\n    return c.z < 0.0 ? p : c.xy;\n}\n\n#define GLYPH_A  vec2(2.0 + 8.0 + 32.0 + 64.0 + 128.0 + 256.0 + 512.0 + 2048.0 + 4096.0 + 16384.0, 4.0)\n#define GLYPH_B  vec2(1.0 + 2.0 + 8.0 + 32.0 + 64.0 + 128.0 + 512.0 + 2048.0 + 4096.0 + 8192.0, 4.0)\n#define GLYPH_d  vec2(4.0 + 32.0 + 64.0 + 128.0 + 256.0 + 512.0 + 2048.0 + 4096.0 + 8192.0 + 16384.0, 4.0)\n#define GLYPH_M1 vec2(1.0 + 8.0 + 16.0 + 64.0 + 256.0 + 512.0 + 4096.0, 3.0)\n#define GLYPH_M2 vec2(2.0 + 8.0 + 16.0 + 128.0 + 1024.0 + 8192.0, 3.0)\n#define GLYPH_X  vec2(1.0 + 4.0 + 8.0 + 32.0 + 128.0 + 512.0 + 2048.0 + 4096.0 + 16384.0, 4.0)\n#define GLYPH_P1 vec2(2.0 + 8.0 + 64.0 + 512.0 + 8192.0, 3.0)\n#define GLYPH_P2 vec2(1.0 + 16.0 + 128.0 + 1024.0 + 4096.0, 3.0)\n#define GLYPH_K  vec2(1024.0 + 4096.0, 4.0)\n\n\nfloat glyphCover(inout vec2 p, vec2 gdata) {\n    p = floor(p);\n    float c;\n    if (p.x >= 0.0 && p.x < 3.0 && p.y >= 0.0 && p.y < 5.0) {\n        float bit = dot(p, vec2(1.0, -3.0)) + 12.0;\n        c = mod(floor(gdata.x / pow(2.0, bit)), 2.0);\n    } else {\n        c = 0.0;\n    }\n    p.x -= gdata.y;\n    return c;\n}\n            \n\n\nfloat text_legend(vec2 p) {\n    \n    float c = 0.0;\n    \n    if (whichF == 2.0) {\n        c += glyphCover(p, GLYPH_M1);\n        c += glyphCover(p, GLYPH_M2);\n        c += glyphCover(p, GLYPH_A); \n        c += glyphCover(p, GLYPH_X); \n        c += glyphCover(p, GLYPH_P1);\n    } \n    if (whichF != 1.0) {\n        c += glyphCover(p, GLYPH_d); \n        c += glyphCover(p, GLYPH_A); \n    } \n    if (whichF == 2.0) {\n        c += glyphCover(p, GLYPH_K); \n    }\n    if (whichF != 0.0) {\n        c += glyphCover(p, GLYPH_d); \n        c += glyphCover(p, GLYPH_B); \n    }\n    if (whichF == 2.0) {\n        c += glyphCover(p, GLYPH_P2); \n    }\n    return c;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    whichF = cycle(2.0, 3.0);\n    whichA = cycle(6.0, 4.0);\n    whichB = cycle(24.0, 4.0);\n    \n    float px = 24.0 / iResolution.x;\n    float txsz = 4.0;\n    \n\tvec2 p = (fragCoord.xy  - 0.5*iResolution.xy) * px;\n    \n    rA =  0.1*iTime;\n    rB = -0.2*iTime;\n\n    tB = vec2(6.0*sin(iTime*0.3), -3.0*cos(iTime*0.2));\n    \n    float dA = sd(p, shapeA(p));\n    float dB = sd(p, shapeB(p));\n    \n    vec2 q = vec2(5.0, 3.0);\n    \n    vec3 cA, cB;\n    float dqA=1., dqB=1., dq=1.;\n    \n    vec2 g = vec2(0);\n    \n    bool hit = false;\n    \n    for (int iter=0; iter<50; ++iter) {\n            \n        float ss = hit ? 0.1 : dq * 0.95 + 0.1;        \n\n        q -= ss*g;\n\n        cA = shapeA(q);\n        cB = shapeB(q);\n\n        dqA = length(q-cA.xy)*cA.z;\n        dqB = length(q-cB.xy)*cB.z;\n        dq = max(dqA, dqB);\n        \n        if (dq < 0.0) { \t\n            hit = true;\n        }\n\n        if (dq == dqA) {\n            g = cA.z * normalize(q-cA.xy);\n        } else {\n            g = cB.z * normalize(q-cB.xy);        \n        }\n        \n    }    \n    \n            \n    float d = whichF == 0.0 ? dA : whichF == 1.0 ? dB : max(dA, dB);\n        \n\tvec3 c = d2c(d);\n    \n    float o = abs(dA);\n    o = min(o, abs(dB));\n    o = min(o, abs(length(p-q)-3.0*px));\n    \n    o = min(o, max(length(p-cA.xy)-3.0*px, 0.0));\n    o = min(o, max(length(p-cB.xy)-3.0*px, 0.0));\n    o = smoothstep(o, 0.0, 0.25*px);\n    \n    vec2 tc = fragCoord / txsz - vec2(1.0, 1.0);\n        \n    float txt = text_legend(tc);\n    vec2 ac = (p - tA)/(txsz*px) + vec2(1.5, 2.5);\n    float ca = glyphCover(ac, GLYPH_A);\n\n    vec2 bc = (p - tB)/(txsz*px) + vec2(1.5, 2.5);\n    float cb = glyphCover(bc, GLYPH_B);\n    \n    \n    c = mix(c, vec3(0), 0.6*txt);\n    \n    c = o*c;\n\n    c = mix(c, vec3(1), 0.7*max(ca,cb));\n\n\n\n    fragColor = vec4(c,1.0);\n\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xtl3Wj","date":"1426715679","viewed":5113,"name":"sdf collision checking","username":"mattz","description":"Playing with ideas for collision checking. Background cycles through 3 different signed distance fields: dist to A, dist to B, and max(dA, dB) Note max(dA,dB) is only negative when shapes collide. Black dots are closest features on shapes and min of max.","likes":84,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","field","signed"],"hasliked":0,"parentid":"","parentname":""}}