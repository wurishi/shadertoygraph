{"ver":"0.1","info":{"id":"wslfD7","date":"1588432069","viewed":1373,"name":"Hosek-Wilkie Skylight Model","username":"pajunen","description":"An implementation of Hosek-Wilkie Skylight Model introduced in paper \"An Analytic Model for Full Spectral Sky-Dome Radiance\" in 2012.\n\nYou can move the sun using your mouse.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sky","analytic","hosek","wilkie","hosekwilkie","skylight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of 2012 Hosek-Wilkie skylight model\n\n// Ground albedo and turbidity are baked into the lookup tables\n#define ALBEDO 1\n#define TURBIDITY 3\n\n#define M_PI 3.1415926535897932384626433832795\n#define CIE_X 0\n#define CIE_Y 1\n#define CIE_Z 2\n\nfloat sample_coeff(int channel, int albedo, int turbidity, int quintic_coeff, int coeff) {\n    // int index = 540 * albedo + 54 * turbidity + 9 * quintic_coeff + coeff;\n    int index =  9 * quintic_coeff + coeff;\n\tif (channel == CIE_X) return kHosekCoeffsX[index];\n\tif (channel == CIE_Y) return kHosekCoeffsY[index];\n    if (channel == CIE_Z) return kHosekCoeffsZ[index];\n}\n\nfloat sample_radiance(int channel, int albedo, int turbidity, int quintic_coeff) {\n    //int index = 60 * albedo + 6 * turbidity + quintic_coeff;\n    int index = quintic_coeff;\n\tif (channel == CIE_X) return kHosekRadX[index];\n\tif (channel == CIE_Y) return kHosekRadY[index];\n\tif (channel == CIE_Z) return kHosekRadZ[index];\n}\n\nfloat eval_quintic_bezier(in float[6] control_points, float t) {\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tfloat t4 = t3 * t;\n\tfloat t5 = t4 * t;\n\t\n\tfloat t_inv = 1.0 - t;\n\tfloat t_inv2 = t_inv * t_inv;\n\tfloat t_inv3 = t_inv2 * t_inv;\n\tfloat t_inv4 = t_inv3 * t_inv;\n\tfloat t_inv5 = t_inv4 * t_inv;\n\t\t\n\treturn (\n\t\tcontrol_points[0] *             t_inv5 +\n\t\tcontrol_points[1] *  5.0 * t  * t_inv4 +\n\t\tcontrol_points[2] * 10.0 * t2 * t_inv3 +\n\t\tcontrol_points[3] * 10.0 * t3 * t_inv2 +\n\t\tcontrol_points[4] *  5.0 * t4 * t_inv  +\n\t\tcontrol_points[5] *        t5\n\t);\n}\n\nfloat transform_sun_zenith(float sun_zenith) {\n\tfloat elevation = M_PI / 2.0 - sun_zenith;\n\t\treturn pow(elevation / (M_PI / 2.0), 0.333333);\n}\n\nvoid get_control_points(int channel, int albedo, int turbidity, int coeff, out float[6] control_points) {\n\tfor (int i = 0; i < 6; ++i) control_points[i] = sample_coeff(channel, albedo, turbidity, i, coeff);\n}\n\nvoid get_control_points_radiance(int channel, int albedo, int turbidity, out float[6] control_points) {\n\tfor (int i = 0; i < 6; ++i) control_points[i] = sample_radiance(channel, albedo, turbidity, i);\n}\n\nvoid get_coeffs(int channel, int albedo, int turbidity, float sun_zenith, out float[9] coeffs) {\n\tfloat t = transform_sun_zenith(sun_zenith);\n\tfor (int i = 0; i < 9; ++i) {\n\t\tfloat control_points[6]; \n\t\tget_control_points(channel, albedo, turbidity, i, control_points);\n\t\tcoeffs[i] = eval_quintic_bezier(control_points, t);\n\t}\n}\n\nvec3 mean_spectral_radiance(int albedo, int turbidity, float sun_zenith) {\n\tvec3 spectral_radiance;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfloat control_points[6];\n        get_control_points_radiance(i, albedo, turbidity, control_points);\n\t\tfloat t = transform_sun_zenith(sun_zenith);\n\t\tspectral_radiance[i] = eval_quintic_bezier(control_points, t);\n\t}\n\treturn spectral_radiance;\n}\n\nfloat F(float theta, float gamma, in float[9] coeffs) {\n\tfloat A = coeffs[0];\n\tfloat B = coeffs[1];\n\tfloat C = coeffs[2];\n\tfloat D = coeffs[3];\n\tfloat E = coeffs[4];\n\tfloat F = coeffs[5];\n\tfloat G = coeffs[6];\n\tfloat H = coeffs[8];\n\tfloat I = coeffs[7];\n\tfloat chi = (1.0 + pow(cos(gamma), 2.0)) / pow(1.0 + H*H - 2.0 * H * cos(gamma), 1.5);\n\t\n\treturn (\n\t\t(1.0 + A * exp(B / (cos(theta) + 0.01))) *\n\t\t(C + D * exp(E * gamma) + F * pow(cos(gamma), 2.0) + G * chi + I * sqrt(cos(theta)))\n\t);\n}\n\nvec3 spectral_radiance(float theta, float gamma, int albedo, int turbidity, float sun_zenith) {\n\tvec3 XYZ;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfloat coeffs[9];\n\t\tget_coeffs(i, albedo, turbidity, sun_zenith, coeffs);\n\t\tXYZ[i] = F(theta, gamma, coeffs);\n\t}\n\treturn XYZ;\n}\n\n// Returns angle between two directions defined by zentih and azimuth angles\nfloat angle(float z1, float a1, float z2, float a2) {\n\treturn acos(\n\t\tsin(z1) * cos(a1) * sin(z2) * cos(a2) +\n\t\tsin(z1) * sin(a1) * sin(z2) * sin(a2) +\n\t\tcos(z1) * cos(z2));\n}\n\nvec3 sample_sky(float view_zenith, float view_azimuth, float sun_zenith, float sun_azimuth) {\n\tfloat gamma = angle(view_zenith, view_azimuth, sun_zenith, sun_azimuth);\n\tfloat theta = view_zenith; \n\treturn spectral_radiance(theta, gamma, ALBEDO, TURBIDITY, sun_zenith) * mean_spectral_radiance(ALBEDO, TURBIDITY, sun_zenith);\n}\n\n// CIE-XYZ to linear RGB\nvec3 XYZ_to_RGB(vec3 XYZ) {\n\tmat3 XYZ_to_linear = mat3(\n\t\t 3.24096994, -0.96924364, 0.55630080,\n\t\t-1.53738318,  1.8759675, -0.20397696,\n\t\t-0.49861076,  0.04155506, 1.05697151\n\t);\n\treturn XYZ_to_linear * XYZ;\n}\n\n// Clamps color between 0 and 1 smoothly\nvec3 expose(vec3 color, float exposure) {\n\treturn vec3(2.0) / (vec3(1.0) + exp(-exposure * color)) - vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv    = (fragCoord -0.5 * iResolution.xy) / iResolution.y;\n\tvec2 mouse = (iMouse.xy -0.5 * iResolution.xy) / iResolution.y;\n\n\tfloat mouse_angle = atan(mouse.x, mouse.y);\n\tfloat mouse_distance = clamp(length(mouse) * M_PI, 0.0, M_PI / 2.0 - 0.1);\n\n\tfloat pixel_angle = atan(uv.x,uv.y);\n\tfloat pixel_distance =  length(uv) * M_PI;\n\n\tif (pixel_distance > M_PI / 2.0) {\n\t\tfragColor = vec4(vec3(0.0), 1.0);\n\t\treturn;\n\t}\n\n\tfloat sun_zenith = mouse_distance;\n\tfloat sun_azimuth = mouse_angle;\n\n\tfloat view_zenith = pixel_distance;\n\tfloat view_azimuth = pixel_angle;\n\n\tvec3 XYZ = sample_sky(view_zenith, view_azimuth, sun_zenith, sun_azimuth);\n\tvec3 RGB = XYZ_to_RGB(XYZ);\n\n\tvec3 col = expose(RGB, 0.1);\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nThis source is published under the following 3-clause BSD license.\n\nCopyright (c) 2012 - 2013, Lukas Hosek and Alexander Wilkie\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * None of the names of the contributors may be used to endorse or promote \n      products derived from this software without specific prior written \n      permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nconst float kHosekCoeffsX[] = float[](\n-1.171419,\n-0.242975,\n-8.991334,\n9.571216,\n-0.027729,\n0.668826,\n0.076835,\n3.785611,\n0.634764,\n-1.228554,\n-0.291756,\n2.753986,\n-2.491780,\n-0.046634,\n0.311830,\n0.075465,\n4.463096,\n0.595507,\n-1.093124,\n-0.244777,\n0.909741,\n0.544830,\n-0.295782,\n2.024167,\n-0.000515,\n-1.069081,\n0.936956,\n-1.056994,\n0.015695,\n-0.821749,\n1.870818,\n0.706193,\n-1.483928,\n0.597821,\n6.864902,\n0.367333,\n-1.054871,\n-0.275813,\n2.712807,\n-5.950110,\n-6.554039,\n2.447523,\n-0.189517,\n-1.454292,\n0.913174,\n-1.100218,\n-0.174624,\n1.438505,\n11.154810,\n-3.266076,\n-0.883736,\n0.197010,\n1.991595,\n0.590782\n);\n\nconst float kHosekCoeffsY[] = float[](\n-1.185983,\n-0.258118,\n-7.761056,\n8.317053,\n-0.033518,\n0.667667,\n0.059417,\n3.820727,\n0.632403,\n-1.268591,\n-0.339807,\n2.348503,\n-2.023779,\n-0.053685,\n0.108328,\n0.084029,\n3.910254,\n0.557748,\n-1.071353,\n-0.199246,\n0.787839,\n0.197470,\n-0.303306,\n2.335298,\n-0.082053,\n0.795445,\n0.997231,\n-1.089513,\n-0.031044,\n-0.599575,\n2.330281,\n0.658194,\n-1.821467,\n0.667997,\n5.090195,\n0.312516,\n-1.040214,\n-0.257093,\n2.660489,\n-6.506045,\n-7.053586,\n2.763153,\n-0.243363,\n-0.764818,\n0.945294,\n-1.116052,\n-0.183199,\n1.457694,\n11.636080,\n-3.216426,\n-1.045594,\n0.228500,\n1.817407,\n0.581040\n);\n\nconst float kHosekCoeffsZ[] = float[](\n-1.354183,\n-0.513062,\n-42.192680,\n42.717720,\n-0.005365,\n0.413674,\n0.012352,\n2.520122,\n0.518727,\n-1.741434,\n-0.958976,\n-8.230339,\n9.296799,\n-0.009600,\n0.499497,\n0.029555,\n0.366710,\n0.352700,\n-0.691735,\n0.215489,\n-0.876026,\n0.233412,\n-0.019096,\n0.474803,\n-0.113851,\n6.515360,\n1.225097,\n-1.293189,\n-0.421870,\n1.620952,\n-0.785860,\n-0.037694,\n0.663679,\n0.336494,\n-0.534102,\n0.212835,\n-0.973552,\n-0.132549,\n1.007517,\n0.259826,\n0.067622,\n0.001421,\n-0.069160,\n3.185897,\n0.864196,\n-1.094800,\n-0.196206,\n0.575559,\n0.290626,\n0.262575,\n0.764405,\n0.134749,\n2.677126,\n0.646546\n);\n\nconst float kHosekRadX[] = float[](\n1.468395,\n2.211970,\n-2.845869,\n20.750270,\n15.248220,\n19.376220\n);\n\nconst float kHosekRadY[] = float[](\n1.516536,\n2.438729,\n-3.624121,\n22.986210,\n15.997820,\n20.700270\n);\n\nconst float kHosekRadZ[] = float[](\n1.234428,\n2.289628,\n-3.404699,\n14.994360,\n34.683900,\n30.848420\n);","name":"Common","description":"","type":"common"}]}