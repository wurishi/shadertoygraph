{"ver":"0.1","info":{"id":"dtKfzd","date":"1702408098","viewed":13,"name":"SlerpTest1","username":"limstudio","description":"SlerpTest1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["compare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n\n#define COS_MIN 0.996194698f\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nfloat rsqrt(float v){\n    return 1.f / sqrt(v);\n}\nvec2 rsqrt(vec2 v){\n    return vec2(1.f) / sqrt(v);\n}\nvec3 rsqrt(vec3 v){\n    return vec3(1.f) / sqrt(v);\n}\nvec4 rsqrt(vec4 v){\n    return vec4(1.f) / sqrt(v);\n}\n\n\nvoid sincos(in float r, out float s, out float c){\n    s = sin(r);\n    c = cos(r);\n}\nvoid sincos(in vec2 r, out vec2 s, out vec2 c){\n    s = sin(r);\n    c = cos(r);\n}\nvoid sincos(in vec3 r, out vec3 s, out vec3 c){\n    s = sin(r);\n    c = cos(r);\n}\nvoid sincos(in vec4 r, out vec4 s, out vec4 c){\n    s = sin(r);\n    c = cos(r);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvec4 quatFromAxisAngle(vec3 axis, float angle){\n    float angleHalf = angle * 0.5f;\n    float s = sin(angleHalf);\n    float c = cos(angleHalf);\n\n    axis = normalize(axis);\n\n    return vec4(axis * s, c);\n}\nvoid quatToAxisAngle(in vec4 q, out vec3 axis, out float angle){\n    q = normalize(q);\n\n    float c = q.w;\n    if (c < 0.f)\n        c *= -1.f;\n\n    float sInv = rsqrt(1.f - c * c);\n\n    axis = q.xyz * sInv;\n    angle = acos(c);\n}\n\n\nvec4 quatConjugate(vec4 q){\n    return vec4(-q.xyz, q.w);\n}\n\n\nvec4 quatNegate(vec4 q){\n    return -q;\n}\n\n\nvec4 quatInverse(vec4 q){\n    float l = dot(q, q);\n    vec4 c = quatConjugate(q);\n\n    return c / l;\n}\n\n\nvec4 quatMultiply(vec4 q0, vec4 q1){\n    return vec4(\n        (q0.w * q1.x) + (q0.x * q1.w) + (q0.y * q1.z) - (q0.z * q1.y),\n        (q0.w * q1.y) - (q0.x * q1.z) + (q0.y * q1.w) + (q0.z * q1.x),\n        (q0.w * q1.z) + (q0.x * q1.y) - (q0.y * q1.x) + (q0.z * q1.w),\n        (q0.w * q1.w) - (q0.x * q1.x) - (q0.y * q1.y) - (q0.z * q1.z)\n    );\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvec4 quatSimpleSlerp(vec4 q0, vec4 q1, float t){\n    float omgC = dot(q0, q1);\n    float omgSInv = rsqrt(1.f - omgC * omgC);\n    float omg = acos(omgC);\n\n    float factQ0 = sin((1.f - t) * omg) * omgSInv;\n    float factQ1 = sin(t * omg) * omgSInv;\n\n    return factQ0 * q0 + factQ1 * q1;\n}\n\n\nvec4 quatSlerp(vec4 q0, vec4 q1, float t){\n    float omgC = dot(q0, q1);\n    if (omgC < 0.f){\n        omgC *= -1.f;\n        q1 *= -1.f;\n    }\n    float omgSInv = rsqrt(1.f - omgC * omgC);\n    float omg = acos(omgC);\n\n    float factQ0 = sin((1.f - t) * omg) * omgSInv;\n    float factQ1 = sin(t * omg) * omgSInv;\n\n    return factQ0 * q0 + factQ1 * q1;\n}\n\n\nvec4 quatNlerp(vec4 q0, vec4 q1, float t){\n    float omgC = dot(q0, q1);\n    if (omgC < 0.f)\n        q1 *= -1.f;\n\n    float factQ0 = 1.f - t;\n    float factQ1 = t;\n\n    return normalize(factQ0 * q0 + factQ1 * q1);\n}\n\n\nvec4 quatMixlerp(vec4 q0, vec4 q1, float t){\n    float omgC = dot(q0, q1);\n    if (omgC < 0.f){\n        omgC *= -1.f;\n        q1 *= -1.f;\n    }\n\n    if (omgC > COS_MIN){\n        float factQ0 = 1.f - t;\n        float factQ1 = t;\n\n        return normalize(factQ0 * q0 + factQ1 * q1);\n    }\n\n    float omgSInv = rsqrt(1.f - omgC * omgC);\n    float omg = acos(omgC);\n\n    float factQ0 = sin((1.f - t) * omg) * omgSInv;\n    float factQ1 = sin(t * omg) * omgSInv;\n\n    return factQ0 * q0 + factQ1 * q1;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvec3 rotateVec(vec3 p, vec4 q){\n    vec4 pw = vec4(p, 0.f);\n\n    return quatMultiply(quatMultiply(q, pw), quatInverse(q)).xyz;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nfloat placeBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.f)) + min(max(q.x, max(q.y, q.z)), 0.f);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n#define CASE1\n\n\nvoid getProperties(in vec3 viewPos, out float curDist, out vec4 curColor){\n    curDist = 100.f;\n\n    float timeWithScale = iTime * 0.125f;\n    float t = sin(timeWithScale * 6.28318530718f) * 0.5f + 0.5f;\n\n#ifdef CASE0\n    {\n        const vec3 boxExtents = vec3(0.5f, 0.8f, 0.7f);\n\n        vec4 q0 = quatFromAxisAngle(vec3(0.6197647f, 0.0754496f, -0.7811524f), 1.431133221271f);\n        vec4 q1 = quatFromAxisAngle(vec3(-0.7264101f, 0.5687397f, 0.3858282f), 0.9200532857369f);\n\n        {\n            vec4 qRes = quatSimpleSlerp(q0, q1, t);\n\n            vec3 p = rotateVec(viewPos, qRes) - vec3(0.f, 0.f, 1.f);\n            float tmpDist = placeBox(p, boxExtents);\n            vec4 tmpColor = vec4(1.f, 0.f, 0.f, 0.f);\n\n            if (curDist > tmpDist){\n                curDist = tmpDist;\n                curColor = tmpColor;\n            }\n        }\n\n        {\n            vec4 qRes = quatSimpleSlerp(q0, quatNegate(q1), t);\n\n            vec3 p = rotateVec(viewPos, qRes) - vec3(0.f, 0.f, 1.f);\n            float tmpDist = placeBox(p, boxExtents);\n            vec4 tmpColor = vec4(0.f, 0.f, 1.f, 0.f);\n\n            if (curDist > tmpDist){\n                curDist = tmpDist;\n                curColor = tmpColor;\n            }\n        }\n    }\n#endif\n\n#ifdef CASE1\n    {\n        const vec3 boxExtents = vec3(0.2f, 0.5f, 0.3f);\n\n        vec4 q0 = quatFromAxisAngle(vec3(-0.9714498f, -0.2283106f, -0.5723685f), 1.087985991806f);\n        vec4 q1 = quatFromAxisAngle(vec3(0.8918646f, -0.1254735f, -0.4345502f), 2.6140669726892f);\n\n        {\n            vec4 qRes = quatSlerp(q0, q1, t);\n\n            vec3 p = rotateVec(viewPos, qRes) - vec3(0.f, 0.f, 1.f);\n            float tmpDist = placeBox(p, boxExtents);\n            vec4 tmpColor = vec4(1.f, 0.f, 0.f, 0.f);\n\n            if (curDist > tmpDist){\n                curDist = tmpDist;\n                curColor = tmpColor;\n            }\n        }\n\n        {\n            vec4 qRes = quatNlerp(q0, quatNegate(q1), t);\n\n            vec3 p = rotateVec(viewPos, qRes) - vec3(0.f, 0.f, 1.f);\n            float tmpDist = placeBox(p, boxExtents);\n            vec4 tmpColor = vec4(0.f, 0.f, 1.f, 0.f);\n\n            if (curDist > tmpDist){\n                curDist = tmpDist;\n                curColor = tmpColor;\n            }\n        }\n    }\n#endif\n\n#ifdef CASE2\n    {\n        const vec3 boxExtents = vec3(0.6f, 0.8f, 1.f);\n\n        vec4 q0 = quatFromAxisAngle(vec3(0.7875713f, 0.3614036f, -0.7291612f), 0.712295880198f);\n        vec4 q1 = quatFromAxisAngle(vec3(0.5596747f, 0.3833014f, -0.7347409f), 0.7048479633771f);\n\n        {\n            vec4 qRes = quatMixlerp(q0, quatNegate(q1), t);\n\n            vec3 p = rotateVec(viewPos, qRes) - vec3(0.f, 0.f, 1.f);\n            float tmpDist = placeBox(p, boxExtents);\n            vec4 tmpColor = vec4(0.f, 1.f, 0.f, 0.f);\n\n            if (curDist > tmpDist){\n                curDist = tmpDist;\n                curColor = tmpColor;\n            }\n        }\n\n        {\n            vec4 qRes = quatSlerp(q0, q1, t);\n\n            vec3 p = rotateVec(viewPos, qRes) - vec3(0.f, 0.f, 1.f);\n            float tmpDist = placeBox(p, boxExtents);\n            vec4 tmpColor = vec4(1.f, 0.f, 0.f, 0.f);\n\n            if (curDist > tmpDist){\n                curDist = tmpDist;\n                curColor = tmpColor;\n            }\n        }\n    }\n#endif\n}\nvec3 calNormal(vec3 viewPos){\n    const vec2 e = vec2(1.f, -1.f) * 0.5773f;\n    const float ep = 0.0005f;\n\n    float tmpDist;\n    vec4 tmpCol;\n\n    getProperties(viewPos + e.xyy * ep, tmpDist, tmpCol);\n    vec3 curNormal = e.xyy * tmpDist;\n\n    getProperties(viewPos + e.yyx * ep, tmpDist, tmpCol);\n    curNormal += e.yyx * tmpDist;\n\n    getProperties(viewPos + e.yxy * ep, tmpDist, tmpCol);\n    curNormal += e.yxy * tmpDist;\n\n    getProperties(viewPos + e.xxx * ep, tmpDist, tmpCol);\n    curNormal += e.xxx * tmpDist;\n\n    curNormal = normalize(curNormal);\n    return curNormal;\n}\nvec4 rayMarch(in vec3 rayOrigin, in vec3 rayDir){\n    const float distMax = 5.f;\n\n    float curDist = 0.f;\n\n    vec4 surfColor;\n    for (int i = 0; i < MAX_STEPS; ++i){\n        vec3 pos = rayOrigin + rayDir * curDist;\n        \n        float surfDist;\n        getProperties(pos, surfDist, surfColor);\n\n        if (surfDist < 0.0001f || curDist > distMax)\n            break;\n\n        curDist += surfDist;\n    }\n\n    if (curDist < distMax){\n        vec3 pos = rayOrigin + rayDir * curDist;\n\n        vec3 surfNormal = calNormal(pos);\n\n        float diff = clamp(dot(surfNormal, normalize(vec3(1.f, 0.5f, -0.7f))), 0.f, 1.f);\n        return surfColor * (diff * 0.5f + vec4(0.5f));\n    }\n\n    return vec4(0.f);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.f * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = vec3(0.f, 0.f, -2.f);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    fragColor = rayMarch(rayOrigin, rayDirection);\n    fragColor.a = 1.f;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n","name":"Image","description":"","type":"image"}]}