{"ver":"0.1","info":{"id":"Ws3XRs","date":"1572566182","viewed":1225,"name":"Basic Procedural Noise Terrain","username":"avcourt","description":"A very simple terrain generator.\n\nsee github.com/avcourt/terrain for a detailed description.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* Author: Andrew Vaillancourt\n* GitHub, Twitter: @avcourt\n*\n* For a detailed README see github.com/avcourt/terrain\n*\n*/\n\n// CONSTANTS, try playing around with some values\n\n// colors\nconst vec3 SKY_COL = vec3(0.76,0.94, 1.0);\nconst vec3 MTN_COL = vec3(0.4, 0.2, 0.0);\nconst vec3 ICE_COL = vec3(0.9, 0.9, 1.0);\nconst vec3 LIGHT_COL = vec3(0.95, 1.0, 0.89); // white, slightly yellow light\n\nconst float FOG_DENSITY = -0.04;\nconst float SKY = -1.0;                 // materialID for sky\nconst vec3 EPS = vec3(0.001, 0.0, 0.0); // smaller values = more detail when normalizing\nconst float MAX_DIST = 60.0;            // used when ray casting to limit ray length\nconst int RAYS = 30;                    // number of rays cast, set lower if framerate slows\nconst int FREQUENCY = 10;               // try lower values if framerate issues encountered\n\n// the following are used in terrain function\nconst float START_HEIGHT = 0.4;\nconst float WEIGHT = 0.6;\nconst float MULT = 0.35;\n\n\n\n// Simple 2d noise algorithm from http://shadertoy.wikia.com/wiki/Noise\n// I tweaked a few values\nfloat noise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(10000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n\n//generate terrain using above noise algorithm\nfloat terrain( vec2 p, int freq ) {\t\n\tfloat h = START_HEIGHT; // height, start at higher than zero so there's not too much snow/ice\n\tfloat w = WEIGHT; \t// weight\n\tfloat m = MULT; \t// multiplier\n\tfor (int i = 0; i < freq; i++) {\n\t\th += w * noise((p * m)); // adjust height based on noise algorithm\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\n// this function determines how to colour, based on y.pos \n// out of the 3 basics SKY, MTN, ICE, assigns -1.0, 0.0 or 1.0\nvec2 map( vec3 pos, int octaves ) {\n\t\n\tfloat dMin = MAX_DIST;\t// nearest intersection\n\tfloat d; \t\t// depth\n\tfloat materialID = SKY; // set default material id to sky\n\t\n\t// rocky terrain - MTN\n\tfloat h = terrain(pos.xz, octaves);\n\td = pos.y - h;\n\tif (d < dMin) { \n\t\tdMin = d;\n\t\tmaterialID = 0.0;\n\t}\n\t// ice -set IF-statement to false to remove ice\n\tif (true) {\n        float s = 0.05;\n\t\td = pos.y - s;\t\n\t\tif (d<dMin) { \n\t\t\tdMin = d;\n\t\t\tmaterialID = 1.0;\n\t\t}\n\t}\n\treturn vec2(dMin, materialID);\n}\n\n// ray casting funciton. ro = ray origin, rd = ray direction\n// returns materialID\nvec2 castRay( vec3 ro, vec3 rd, int freq) {\n\tfloat dist = 0.0;   // distance\n\tfloat delta = 0.2;  // step\n\tfloat material = -1.0;\n\tfor (int i = 0; i < RAYS; i++) {\n\t\tif (dist < MAX_DIST ) {\t// ignore if 'sky'\n\t\t\tdist += delta; \t\t// next step\n\t\t\tvec2 result = map(ro + rd*dist, freq); // get intersection\n\t\t\tdelta = result.x; \n\t\t\tmaterial = result.y; // set material id based on y pos\n\t\t} \n\t\telse break; //ignore 'sky'\n\t}\n\tif (dist > MAX_DIST) material = SKY; // if nothing intersects set as sky\n\treturn vec2(dist, material);\n}\n\n// calculates normal, try changing epsilon constant\nvec3 calcNormal( vec3 p, int freq) {\n\treturn normalize( vec3(map(p + EPS.xyy, freq).x - map(p-EPS.xyy, freq).x,\n\t\t\t       map(p+EPS.yxy, freq).x - map(p-EPS.yxy, freq).x,\n\t\t\t       map(p+EPS.yyx, freq).x - map(p-EPS.yyx, freq).x) );\n}\n\n\n\nvec3 render( vec3 ro, vec3 rd ) {\n\tconst int freq = FREQUENCY;\n\t\n\tvec3 color = SKY_COL; // base color is sky color\n\tvec2 res = castRay(ro, rd, freq);\n\t\n\tvec3 lightPos = normalize( vec3(1.0, 0.9, 0.0) ); // light position\n\t\n\tvec3 pos = ro + rd*res.x; // world position\n\t\n\t// material  = sky\n\tif (res.y < -0.5) {\n\t\tcolor = SKY_COL;\n\t\treturn color;\n\t}\n\t// now we can calculate normals for moutnains and ice\n    vec3 normal = calcNormal(pos, 10); \n\n\t// material = MTN \n\tif (res.y > -0.5 && res.y < 0.5 ) {\t\n        color = MTN_COL;\t\n\t\t// add light\n\t\tfloat ambient = clamp( 0.5 + 0.5 * normal.y, 0.0, 1.0); // ambient\n\t\tfloat diffuse = clamp( dot( normal, lightPos ), 0.0, 5.0); // diffuse\t\t\n\t\tcolor += (0.4 * ambient) * LIGHT_COL;\n\t\tcolor *= (1.9 * diffuse) * LIGHT_COL;\t\n\t}\n\t// material = ICE\n\tif (res.y > 0.5) {\n        color = ICE_COL;\n\t\t\t\n\t\t// add light\n\t\tfloat ambient = clamp( 0.5 + 0.5 * normal.y, 0.0, 1.0);     // ambient\n\t\tfloat diffuse = clamp( dot( normal, lightPos ), 0.0, 2.0);  // diffuse\n\t\n\t\tcolor += (0.3 * ambient) * LIGHT_COL;\n\t\tcolor *= (2.1 * diffuse) * LIGHT_COL;\n\t}\n\t\n\t// fog from http://in2gpu.com/2014/07/22/create-fog-shader/\n\tfloat fog = exp(FOG_DENSITY * res.x); \n\tcolor = mix(vec3(0.3,0.3,0.35), color, fog); \n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0; // bound screen coords to [0, 1]\n\tpos.x *= iResolution.x / iResolution.y; // set aspect ratio\n\n\t// camera\n\tfloat x = 0.0 + (2.5*iTime);\n\tfloat y = 3.0;\n    float z = 1.0;\n\tvec3 camPos = vec3(x, y, z); // set camera position\n\t\n\tconst vec3 up = vec3(0.0, 1.0, 0.0); // up vector\n\tvec3 camLook = vec3(camPos.x + 1.0, y*0.8, 0.0); // lookAt vector\n\t\n\t\n\tvec3 w = normalize( camLook - camPos );\n\tvec3 u = normalize( cross(w, up) );\n\tvec3 v = normalize( cross(u, w) );\n\t\n\tvec3 rd = normalize( pos.x*u + pos.y*v + 2.0*w );\n\t\n\t// render\n\tvec3 color = render(camPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}