{"ver":"0.1","info":{"id":"WsV3Dt","date":"1571217992","viewed":582,"name":"Another Triangular Voronoi","username":"bitless","description":"Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \nThanks to aiekick and iq for some code from https://www.shadertoy.com/view/ltK3WD and https://www.shadertoy.com/view/MdSGRc","likes":52,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","triangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: another triangular voronoi \n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration\n// Thanks to aiekick and iq for some code from https://www.shadertoy.com/view/ltK3WD and https://www.shadertoy.com/view/MdSGRc\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.1415926\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 rotate2D(vec2 _st, float _angle,vec2 m){\n   \n    _st -= m;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += m;\n    return _st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec2 m = vec2(0.5,0.5); \n    \n    if (iResolution.y > iResolution.x ) {\n        st.y *= iResolution.y/iResolution.x;\n        m.y *= iResolution.y/iResolution.x;\n    }       \n    else {\n        st.x *= iResolution.x/iResolution.y;\n        m.x *= iResolution.x/iResolution.y;\n    }\n    vec3 color = vec3(.0);\n\n\n\tst = rotate2D(st,PI*0.666666*((floor(mod(iTime,15.0)/5.0)-1.0)),m);  //rotation on 120 degrees\n    st = rotate2D(st,PI*0.666666*pow(smoothstep(0.0,1.0,mod(iTime+1.0,5.0))*(1.0-step(1.0,mod(iTime+1.0,5.0))),2.5),m);  //animate rotation cicle\n    // Scale\n    st -= m;\n    st *= sin(iTime*0.2)*1.0+3.0+cos(smoothstep(0.0,1.0,mod(iTime+1.0,5.0))*(1.0-step(1.0,mod(iTime+1.0,5.0)))*PI*2.0)*0.5; \n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    float m_dist = 9.;  // minimun distance\n\n    vec2 p; \n    vec4 f;\n    f.x = 9.;\n    \n    for(int x=-2;x<=2;x++)\n    for(int y=-2;y<=2;y++)\n    {\t\n        p = vec2(x,y); //neightbour\n        p += 0.5*sin(iTime*0.2+6.2831*random2(i_st+p)); //animate\n\t\tp += .5  - f_st;\n\n        f.y = max(abs(p.x)*.866 - p.y*.5, p.y); \n        if (f.y < f.x)\n        {\n            m_dist = f.x;\n            f.x = f.y;\n            f.zw = p;\n        }\n        else if( f.y < m_dist )\n\t\t{\n\t\t\tm_dist = f.y;\n\t\t}\n    }\n\t\n    m_dist -= f.x;\n    \n    vec3 n = vec3(0);\n    \n    if ( (f.x - (-f.z*.866 - f.w*.5)) \t<.0001) \tn = vec3(0.940,0.860,0.907); \n\tif ( (f.x - (f.z*.866 - f.w*.5))\t<.0001) \tn = vec3(0.970,0.949,0.888);\n\tif ( (f.x - f.w)\t\t\t\t\t<.0001) \tn = vec3(0.871,0.900,0.960);\n\t\n    color =  n*(0.6+length(f.x)); //base color + distance field shadow\n    color -= 0.45*pow(clamp(m_dist*4.0,0.0,1.0),0.2); //edges\n    color *= 1.0-smoothstep(0.0,10.0,mod(length(f.x)*100.0,15.0))*0.06; //gradient stripes\n    color *= 1.0-step(2.0,mod(length(f.x)*100.0,15.0))*0.05; //thin light stripes\n\n    fragColor = vec4(color,1.);\n}\n","name":"Image","description":"","type":"image"}]}