{"ver":"0.1","info":{"id":"MtycDV","date":"1537773030","viewed":192,"name":"Raymarched Sphere - Demo","username":"Balajanovski","description":"Simple demo which displays a sphere above a checkerboard.\n\nGithub repository:\nhttps://github.com/Balajanovski/graphics-demo","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","raymarched","sphere","shadows","raymarcher","raytraced","checkerboard","reflections","blinnphong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Math constants\n#define M_PI 3.1415926535897932384626433832795\n#define EPSILON 0.01f\n\n// Raymarching constants\n#define MAX_STEPS 300\n#define MAX_DIST 100.0\n#define FOV (M_PI / 2.0) // In radians\n\n// Size of a checkerboard tile\n#define CHECKERBOARD_TILE_SIZE 1.0\n\n// Collision IDs\n#define SPHERE 0\n#define PLANE 1\n\n// Signed-distance function of a sphere\nfloat sphereSDF(in vec3 pos, in float radius, in vec3 center) {\n    return length(pos + center) - radius;\n}\n\n// Signed-distance function of a plane\nfloat planeSDF(in vec3 pos, in vec4 normal) {\n    return dot(pos, normal.xyz) + normal.w;\n}\n\n// SDF of scene which tells you what you collide with\nfloat sceneSDF(in vec3 pos, out int collision_id) {\n    float d_sphere = sphereSDF(pos, 1.0, vec3(0, 0.3 * sin(iTime), 0));\n    float d_plane = planeSDF(pos, vec4(0.0, 1.0, 0.0, 2.0));\n\n    if (d_sphere <= d_plane) {\n        collision_id = SPHERE;\n        return d_sphere;\n    } else {\n        collision_id = PLANE;\n        return d_plane;\n    }\n}\n\n// SDF of scene which doesn't tell you what you collide with\nfloat sceneSDF(in vec3 pos) {\n    int collision_id;\n    return sceneSDF(pos, collision_id);\n}\n\n// Estimate the normal off of the scene sdf\nvec3 estimateNormal(in vec3 p) {\n    return normalize(vec3(\n            sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n            sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n            sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n        ));\n}\n\n// The blinn-phone BRDF\nvec3 blinnPhongContribForLight(in vec3 diffuse_color, in vec3 specular_color, in float alpha, in vec3 p, in vec3 eye,\n                          in vec3 lightPos, in vec3 lightIntensity, in float attenuation) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    // Light not visible from this point\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // Light reflection in opposite direction as viewer, apply only diffuse lighting\n    if (dotRV < 0.0) {\n        return lightIntensity * (diffuse_color * dotLN) * attenuation;\n    }\n\n    // Blinn - phong calculation\n    vec3 half_direction = normalize(normalize(L) + V);\n    float specular = pow(max(dot(half_direction, N), 0.0), 16.0);\n    return (lightIntensity * diffuse_color * dotLN * attenuation) +\n           (specular_color * pow(dotRV, alpha) * specular * attenuation);\n}\n\nvec3 blinnPhongIllumination(vec3 diffuse_color,\n                            vec3 specular_color, float alpha, float attenuation,\n                            vec3 light_pos, float light_intensity,\n                            vec3 point_pos, vec3 eye) {\n    vec3 light_I = light_intensity * vec3(1.0, 1.0, 1.0);\n\n    vec3 color = blinnPhongContribForLight(diffuse_color, specular_color, alpha, point_pos, eye,\n                                  light_pos,\n                                  light_I, attenuation);\n\n    return color;\n}\n\n// Determine the unit vector to march along\nvec3 rayDirection(in float fieldOfView, in vec2 size, in vec2 frag_coord) {\n    vec2 xy = frag_coord - size / 2.0;\n    float z = size.y / tan(fieldOfView / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// The raymarching algorithm\n// -------------------------\n// March along a ray by the distance to the nearest object\n// until that distance approaches zero (collision)\n// or it exceeds the max steps or max distance\nfloat raymarch(in vec3 eye, in vec3 ray_dir, out int collision_id) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        float d = sceneSDF(eye + depth * ray_dir, collision_id);\n        if (d < EPSILON) {\n            return depth;\n        }\n        depth += d;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Calculate penumbra shadows for free\n// Algorithm sourced from Inigo Quilez\n// URL: https://iquilezles.org/articles/rmshadows\nfloat shadow(in vec3 ray_origin, in vec3 ray_direction, in float min_t, \n             in float max_t, in float k) {\n    float res = 1.0;\n    for (float t = min_t; t < max_t; ) {\n        float dist = sceneSDF(ray_origin + ray_direction * t);\n        if (dist < EPSILON) {\n            return 0.0;\n        }\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return res;\n}\n\n// Determine what tile the point falls in on the checkerboard\n// to colour the tile\nvec3 checkerboard_color(vec3 p) {\n    vec3 pos = vec3(p.x, p.y, p.z - (0.7 * iTime));\n\n    // Checkerboard pattern\n    if ((mod(pos.x,(CHECKERBOARD_TILE_SIZE * 2.0)) < CHECKERBOARD_TILE_SIZE &&\n        mod(pos.z,(CHECKERBOARD_TILE_SIZE * 2.0)) > CHECKERBOARD_TILE_SIZE) ||\n\n        (mod(pos.x,(CHECKERBOARD_TILE_SIZE * 2.0)) > CHECKERBOARD_TILE_SIZE &&\n        mod(pos.z,(CHECKERBOARD_TILE_SIZE * 2.0)) < CHECKERBOARD_TILE_SIZE)) {\n            // White tile\n            return vec3(0.9, 0.9, 0.9);\n    } else {\n            // Black tile\n            return vec3(0.1, 0.1, 0.1);\n    }\n}\n\n// Main function\n// When an object is hit, perform the math magic to colour it\nvec3 calculate_color(vec3 eye, vec3 p, int collision_id, vec3 ray_dir) {\n\n    // Determine / define blinn-phong calculation components\n    vec3 ambient_color = vec3(0.2, 0.2, 0.2);\n    vec3 diffuse_color;\n    if (collision_id == SPHERE) {\n        diffuse_color = vec3(0.0, 1.0, 1.0);\n    } else if (collision_id == PLANE) {\n        diffuse_color = checkerboard_color(p);\n    }\n    vec3 specular_color = vec3(1.0, 1.0, 1.0);\n    float shininess = 20.0;\n\n    // Light attributes\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                              2.0,\n                              4.0 * cos(iTime));\n    float lightIntensity = 1.0f;\n\n    // Compute the ambient component of light\n    vec3 ambient_light = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambient_light * ambient_color;\n\n    // Compute if the point of calculation is obstructed by any objects from the light\n    vec3 shadow_ray = normalize(lightPos - p);\n    float shadow_factor = shadow(p + shadow_ray, shadow_ray, 0.0, MAX_DIST, 8.0);\n\n    // Add the diffuse and specular components\n    vec3 blinn_phong_contribution = blinnPhongIllumination(diffuse_color, specular_color, shininess, 0.5,\n                                    lightPos, lightIntensity, p, eye) * shadow_factor;\n    color += blinn_phong_contribution;\n\n    // Reflect light off of the sphere\n    if (collision_id == SPHERE) {\n        vec3 reflection_dir = ray_dir - (2.0 * dot(ray_dir, estimateNormal(p))\n                                * estimateNormal(p));\n\n        // March along ray till it intersects\n        int collision_id;\n        float dist = raymarch(p + reflection_dir, reflection_dir, collision_id);\n\n        vec3 reflected_color;\n        vec3 reflected_p = p + dist * reflection_dir;\n        if (dist > MAX_DIST - EPSILON) {\n            // Nothing was hit\n            // Create nice gradient effect for the background\n            reflected_color = vec3(0.0, .8-sqrt(reflection_dir.y * 5.0), .8-sqrt(reflection_dir.y * 5.0));\n        } else {\n\n            // Compute if the point of calculation is obstructed by any objects from the light\n            vec3 shadow_ray = normalize(lightPos - reflected_p);\n            float shadow_factor = shadow(reflected_p + shadow_ray, shadow_ray, 0.0, MAX_DIST, 8.0);\n\n            // Add blinn-phong brdf to reflection\n            reflected_color = ambient_light * ambient_color;\n            reflected_color += blinnPhongIllumination(checkerboard_color(reflected_p), specular_color, shininess, 0.5,\n                                                     lightPos, lightIntensity, p, eye)\n                                                     * shadow_factor;\n        }\n\n        // Lerp the reflection with the sphere's original colour\n        color = mix(color, reflected_color, 0.2);\n    }\n\n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ray_dir = rayDirection(FOV, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 0, 5);\n\n    int collision_id;\n    float dist = raymarch(eye, ray_dir, collision_id);\n\n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * ray_dir;\n\n    if (dist > MAX_DIST - EPSILON) {\n        // Nothing was hit\n        // Create nice gradient effect for the background\n        fragColor = vec4(0.0, .8-sqrt(ray_dir.y * 5.0), .8-sqrt(ray_dir.y * 5.0), 1.0);\n    } else {\n        // Something was hit\n        fragColor = vec4(calculate_color(eye, p, collision_id, ray_dir), 1.0);\n    }\n\n}","name":"Image","description":"","type":"image"}]}