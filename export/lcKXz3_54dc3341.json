{"ver":"0.1","info":{"id":"lcKXz3","date":"1715561629","viewed":62,"name":"4D polytope test","username":"TwentySeven","description":"Press space and move mouse to rotate in four dimensions. WASD to move. QE to move 4D. and RF to move up and down.\nRecent Changes: Exact SDF ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["4d"],"hasliked":0,"parentid":"lcGXDh","parentname":"4D Shapess"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//polytope code is in lines 155 - 191 of common\n// only 120 cell, 5 cell, 8 cell, and 24 cell are supported\n//       5,3,2     3,3,2    4,3,2    3,4,2\n//Ray March Settings\n#define STEPS 64\n#define EPS 0.001\n \n//Render Settings\n#define AO_STRENGTH 0.5\n#define SHADOWBLUR 0.01\nconst vec4 lidir= vec4(3,4,-5,3);\n//Volume Mode\n//#define SmoothAxis\n#define BLUR 1\n#define BLURWIDTH PI/2.\n\nvec4 sdf(vec4 p){\n\n/*\n                  fold count---------------+\n                    shlaffli symbol -+-+-+ |\n                                     | | | |        */\n// tetrahedron mode (accurate)\nfloat obj=polytope(p-vec4(0,0,1,0),5,3,2,15)-.15;\n\n// plane method (fast)\n//float obj=plane(fold(init(5,3,2),p,15),vec4(0,0,0,1),0.)-1.;\n\n\n\n\nvec3 col = \nform(obj,vec3(1,0,0));\nvec3 checker=(mod(round(p.x+.502)+round(p.y+.502)+round(p.z+.502)+round(p.w+.502),2.)>.5)?\nvec3(1):vec3(0.9);\nreturn vec4(sat(col)*checker,obj);\n\n}\n\nvec4 normal(vec4 p, float dist, float eps){\nreturn normalize(vec4(\nsdf(p+vec4(eps,0,0,0)).w-sdf(p+vec4(-eps,0,0,0)).w,\nsdf(p+vec4(0,eps,0,0)).w-sdf(p+vec4(0,-eps,0,0)).w,\nsdf(p+vec4(0,0,eps,0)).w-sdf(p+vec4(0,0,-eps,0)).w,\nsdf(p+vec4(0,0,0,eps)).w-sdf(p+vec4(0,0,0,-eps)).w));}\nmat4x4 march(Ray Camera, int steps){\nfloat t, h,hit=0.;\nvec4 p = Camera.ori;\nvec4 d=normalize(Camera.dir);\nvec3 c= vec3(0);\nvec4 n=vec4(0);\nint stpcnt=0;\nfor(int i = 0;i<steps; i++){\nt=sdf(p).w;\np=p+(d*t);\nh=length(p-Camera.ori);\nstpcnt+=1;\nif(t<EPS)hit=1.;\nif(t<EPS||h>500.)\n\nbreak;}\nn=normal(p,h,EPS);\n//c=sat(sdf(p).xyz);\nc=((n.xyz));\nreturn mat4(p.x,n.x,c.x,h,p.y,n.y,c.y,t,p.z,n.z,c.z,stpcnt,p.w,n.w,0,hit)\n;\n}\nfloat isinshadow( in vec4 ro, in vec4 d, float mint, float maxt, float w ){\n    float res = 1.0;\n    float ph = 1e20;\n    float t = mint;\n    for( int i=0; i<STEPS && t<maxt; i++ )\n    {\n        float h = sdf(ro + d*t).w;\n        \n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\nfloat AO( in vec4 pos, in vec4 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n  \n        float h = AO_STRENGTH;\n        float d = sdf( pos + (nor*h) ).w;\n        sca *= 0.5;\n    occ += (h-d)*sca;\n    \n    \n    return smoothstep(0.,1.,clamp( 1.0 - 1.5*occ, 0.0, 1.0 ));    \n}\nRender TurnToRender(Ray Cam, vec4 Lightpos,int steps){\nmat4 ma = march(Cam,steps);\nreturn Render(Cam,\ngetdis(ma),\ngetpos(ma),\ngetcol(ma),\ngetnor(ma),\nnormalize(Lightpos),\ngethit(ma)==1.);\n}\nRay Bounce(Ray r, int steps){\nmat4 ma = march(r, steps);\nreturn Ray(getpos(ma)+(getnor(ma)/10.),reflect(r.dir,getnor(ma)));\n}\nvec3 draw(Render Scene){\nvec3 clmov=vec3(iTime/100.,iTime/140.,iTime/200.);\nvec4 di=Scene.Camera.dir;\nfloat up=dot(di,vec4(0,1,0,0));\nfloat shadows=mix(0.5,1.,isinshadow(Scene.Position+(Scene.Normal/500.),Scene.LightDirection,0.,100.,SHADOWBLUR));\nfloat shading = sat((dot(Scene.Normal,Scene.LightDirection)+2.)/3.);\nvec3 col = sat(AO(Scene.Position,Scene.Normal))*sat(Scene.Color*shading*shadows);\nfloat cl1=texture(iChannel1,clmov.xzx+di.xzw*(1./up)).x;\nfloat cl2=texture(iChannel1,clmov.xyx+di.xzw*(.5/up)).y;\nfloat cl3=texture(iChannel1,clmov.xxx+di.xzw*(.25/up)).z;\nfloat cl4=texture(iChannel1,clmov.yzx+di.xzw*(.125/up)).w;\nfloat clouds = ((cl1+cl2+cl3+cl4)/3.)*mix(0.5,1.,up);\nvec3 sky =\nmix(vec3(.1,.3,.5),vec3(.4,.7,1),(1.+up)/2.)+\nmix(vec3(0,0,0),vec3(1,1,0),smoothstep(0.999,1.,dot(di,Scene.LightDirection)));\n\nvec3 skybox=max(sat(sky),dot(di,vec4(0,1,0,0))>0.?clouds:0.);\nreturn gethit(march(Scene.Camera,128))==1.?col:skybox;}\n\nvec4 loadValue4(in vec2 re){return texture(iChannel0,(.5+re)/iChannelResolution[0].xy,-100.).xyzw;}\nvec3 loadValue3(in vec2 re){return texture(iChannel0,(.5+re)/iChannelResolution[0].xy,-100.).xyz;}\nvec2 loadValue2(in vec2 re){return texture(iChannel0,(.5+re)/iChannelResolution[0].xy,-100.).xy;}\n//mainimage down here\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 screen=(fragCoord/iResolution.xy);\n    vec2 uv =\n\n    ((fragCoord-(iResolution.xy/2.))/128.);\n    float u=uv.x,v=uv.y;\n    vec4 campos= (loadValue4(vec2(0,0)))/128.;\n    vec2 mou = loadValue2(vec2(1,0));\nvec4 blue=(texture(iChannel2,fragCoord/iChannelResolution[2].xy));\nfloat[4] ob=float[4](blue.x,blue.y,blue.z,blue.w);\n    mou*= TAU;\n \n    mat4 camrom = mat4(loadValue4(vec2(11,0)),loadValue4(vec2(12,0)),loadValue4(vec2(13,0)),loadValue4(vec2(14,0)));\n    mat4 camrom2 = mat4(loadValue4(vec2(15,0)),loadValue4(vec2(16,0)),loadValue4(vec2(17,0)),loadValue4(vec2(18,0)));\n#ifdef SmoothAxis\nfloat std=1.;\n    vec4 dirc = vec4(uv,1,0.);\n    fragColor=vec4(0);\nvec4 camdir =normalize(dirc)*camrom2*camrom;\nRay Cam = Ray(campos,normalize(vec4(uv,1,0.))*camrom2*camrom);\nRender Scene = TurnToRender(Cam,lidir,STEPS);\nRender Scene1;\nvec3 col=draw(Scene);\nvec3 col2=draw(Scene);\n\nfloat dith=(texture(iChannel3,(fragCoord/iChannelResolution[3].xy)).x*2.)-1.;\n\nfloat sfd=00.;\nfor(int i = 0; i<int(BLUR); i++){\n//float var=mix(-BLURWIDTH,BLURWIDTH,(dith+(float(i)/float(BLUR)))/2.);\nfloat var=mix(-BLURWIDTH,BLURWIDTH,(blue.x/float(BLUR))+(float(i)/float(BLUR)));\ndirc = normalize(vec4(uv*cos(var),cos(var),sin(var)));\nsfd=Scene1.Depth;\n\n\n    camdir =dirc*camrom2*camrom;\n   Cam = Ray(campos,camdir);\n\n   Scene1 = TurnToRender(Cam,vec4(1.,1.5,-0.5,0.25),STEPS);\n\nif((Scene1.Depth>min(sfd,Scene.Depth))||!Scene1.Hit)continue;\ncol2=draw(Scene1);\n\n\n\n\n\n    }\n    fragColor = vec4(col2,1.0);\n    \n\n\n#else\n    vec4 dirc = vec4(uv,1,0.);\n    vec4 camdir =normalize(dirc)*camrom2*camrom;\n    Ray Cam = Ray(campos,camdir);\n    Render Scene = TurnToRender(Cam,lidir,STEPS);\n    vec3 col =draw(Scene);\n    fragColor = vec4(col,1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n#define PI 3.14159265359\n#define INF 1e10\n#define revolve(a,b) length(vec2(a,b))\n#define pmod(a,b) (mod(a+(b/2.),b)-(b/2.))\n#define sat(value) clamp(value,0.,1.)\nstruct Polytope{\nvec4 tpo;\nvec4 p1;\nvec4 q1;\nvec4 s1;\nvec4 r1;\n};\nfloat planize(vec4 p,float SDfunction){\nfloat edge=length(vec2(p.w,SDfunction));\nfloat hull=max(abs(p.w),SDfunction);\nreturn sign(SDfunction)==1.?edge:hull;\n}\nfloat mina(float a,float b,float c){return min(a,min(b,c));}\nfloat mina(float a,float b,float c,float d){return min(min(a,b),min(c,d));}\nfloat mina(float a,float b,float c,float d,float e){return min(min(a,b),min(c,min(d,e)));}\nfloat mina(float a,float b,float c,float d,float e,float f){return min(min(a,b),min(min(c,d),min(e,f)));}\nfloat mina(float a,float b,float c,float d,float e,float f,float g){return min(min(a,min(b,c)),min(min(d,e),min(f,g)));}\nfloat mina(float a,float b,float c,float d,float e,float f,float g,float h){return min(min(min(a,b),min(c,d)),min(min(e,f),min(g,h)));}\nfloat maxa(float a,float b,float c){return max(a,max(b,c));}\nfloat maxa(float a,float b,float c,float d){return max(max(a,b),max(c,d));}\n\nstruct Ray{\nvec4 ori;\nvec4 dir;\n};\nstruct Render{\nRay Camera;\nfloat Depth;\nvec4 Position;\nvec3 Color;\nvec4 Normal;\nvec4 LightDirection;\nbool Hit;\n};\n\n//OPERATIONS\nvec3 extrude(vec3 p, vec3 a,float factor){\nreturn(p - (a*clamp( dot(p,a)/dot(a,a),0.,factor)));}\nvec4 extrude(vec4 p, vec4 a,float factor){\nreturn(p - (a*clamp( dot(p,a)/dot(a,a),0.,factor)));}\nfloat blend( float a, float b, float k ){\n    k *= 1.0/(1.0-sqrt(0.5));\n    return max(k,min(a,b)) -\n           length(max(k-vec2(a,b),0.0));\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec4 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nvec4 cross4D(in vec4 u, in vec4 v, in vec4 w) {\n    float a=v.x*w.y-v.y*w.x, b=v.x*w.z-v.z*w.x, c=v.x*w.w-v.w*w.x,\n          d=v.y*w.z-v.z*w.y, e=v.y*w.w-v.w*w.y, f=v.z*w.w-v.w*w.z;\n    return vec4( u.y*f - u.z*e + u.w*d,\n                -u.x*f + u.z*c - u.w*b,\n                 u.x*e - u.y*c + u.w*a,\n                -u.x*d + u.y*b - u.z*a);\n}\n//SDFs\n    //Primitives\nfloat sphere(vec4 p, vec4 q, float s){\nreturn distance(p,q)-s;}\nfloat cylinder( vec4 p, vec4 a, vec4 b, float r ){\n  vec4  ba = b - a;\n  vec4  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat box(vec4 p, vec4 q, vec4 s){\nvec4 j = abs(p-q) - s;\nreturn length(max(j,0.0)) + min(max(max(j.x,j.y),max(j.z,j.w)),0.0);\n}\nfloat plane( vec4 p, vec4 n,float off){return dot(p,normalize(n))+off;}\n\n    //Geometrical\nfloat line( vec4 p, vec4 a, vec4 b){\n  vec4 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\nfloat triangle(vec4 p, vec4 a, vec4 b, vec4 c){\nvec4 ba=b-a,cb=c-b,ac=a-c,pa=p-a,pb=p-b,pc=p-c;\nvec4 flnor = vec4(cross(ba.xyz,ac.xyz),0.);\nvec4 nor = cross4D(flnor,ba,ac);\nfloat pl1 =abs(dot(pa,normalize(nor)));\nfloat pl2=abs(dot(pa,normalize(flnor)));\nreturn  \n         (sign(dot(cross4D(ba,nor,flnor),pa)) + \n          sign(dot(cross4D(cb,nor,flnor),pb)) + \n          sign(dot(cross4D(ac,nor,flnor),pc))<3.0) \n?min(length(pa-(ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ))),\nmin( length(pb-(cb*clamp( dot(pb,cb)/dot(cb,cb), 0.0, 1.0 ))),\n     length(pc-(ac*clamp( dot(pc,ac)/dot(ac,ac), 0.0, 1.0 ))))):\nlength(vec2(pl1,pl2))\n\n;} \nfloat quad( vec4 p, vec4 a, vec4 b, vec4 c){\n  vec4 d=a+(c-b);\n  vec4 ba = b - a; vec4 pa = p - a;\n  vec4 cb = c - b; vec4 pb = p - b;\n  vec4 dc = d - c; vec4 pc = p - c;\n  vec4 ad = a - d; vec4 pd = p - d;\n  vec4 flnor=vec4(cross((ba).xyz,(ad).xyz),0);\n  vec4 nor = cross4D(flnor,ba,ad);\nfloat pl1 =abs(plane(pa,nor,0.));\nfloat pl2=abs(plane(pa,flnor,0.));\n  return \n    (sign(dot(cross4D(ba,nor,flnor),pa)) +\n     sign(dot(cross4D(cb,nor,flnor),pb)) +\n     sign(dot(cross4D(dc,nor,flnor),pc)) +\n     sign(dot(cross4D(ad,nor,flnor),pd))<3.0)\n?mina(line(p,a,b),line(p,b,c),line(p,c,d),line(p,d,a))\n:length(vec2(pl1,pl2));\n}\nfloat quad(vec4 p, vec4 a, vec4 b, vec4 c,vec4 d){\nreturn min(triangle(p,a,b,c),triangle(p,c,d,a));}\nfloat tetrahedron(vec4 p, vec4 a, vec4 b, vec4 c, vec4 d){\n\nvec4 ba=b-a,cb=c-b,dc=d-c,ad=a-d,pa=p-a,pb=p-b,pc=p-c,pd=p-d;\nvec4 nor = cross4D(a-b,a-c,a-d);\n\nreturn   (sign(dot(cross4D(ba,-nor,ad),pa)) + \n          sign(dot(cross4D(cb,nor,ba),pb)) + \n          sign(dot(cross4D(dc,-nor,cb),pc)) + \n          sign(dot(cross4D(ad,nor,dc),pd))<4.0) ?\n    min(min(triangle(p,a,b,c),triangle(p,b,c,d)),min(triangle(p,c,d,a),triangle(p,d,a,b))):\n    abs(dot(p-a,normalize(nor)));\n\n}\nfloat orientedtetrahedron(vec4 p, vec4 a, vec4 b, vec4 c, vec4 d){\n\nvec4 ba=b-a,cb=c-b,dc=d-c,ad=a-d,pa=p-a,pb=p-b,pc=p-c,pd=p-d;\nvec4 nor = cross4D(a-b,a-c,a-d);\n\nreturn   sign(dot(cross4D(ba,-nor,ad),pa)) + \n          sign(dot(cross4D(cb,nor,ba),pb)) + \n          sign(dot(cross4D(dc,-nor,cb),pc)) + \n          sign(dot(cross4D(ad,nor,dc),pd))<4.0 ?\n    min(min(triangle(p,a,b,c),triangle(p,b,c,d)),min(triangle(p,c,d,a),triangle(p,d,a,b))):\n    dot(p-a,normalize(nor));\n\n}\n\n//exact sdf to a polytope\nfloat dihedral(int  x) {\n  return -cos(PI/float(x));\n}\nPolytope init(int PQ,int QR,int RP) {\n  float A = dihedral(PQ);\n  float B = dihedral(QR);\n  float C = dihedral(RP);\n\n  \n  vec4 P = vec4(1,0,0,0);\n  vec4 Q = vec4(A,sqrt(1.0 - A*A),0,0);\n  float a=((B-A*C)/(sqrt(1.0 - A*A)));\n  vec4 R = vec4(C,a,sqrt(1.0 - C*C - a*a),0);\n  mat3 mm = inverse(mat3(P.xyz,Q.xyz,R.xyz));\n  vec3 S3 = vec3(0,0,-.5)*mm;\n  float w = sqrt(1.0 - dot(S3,S3));\n  vec4 S = vec4(S3,w);\n\n\n\n  mat4 m = inverse(mat4(P,Q,R,S));\n  vec4 tpoint = normalize(P*m);\n  return Polytope(tpoint,P,Q,R,S);\n}\nvec4 fold(Polytope sym,vec4 pos,int NFOLDS) {\n  for (int i = 0; i < NFOLDS; i++) {\n    pos.x = abs(pos.x);\n    for (int j = 1; j < 4; j++) {\n      pos -= 2.0*min(0.0,dot(pos,vec4[4](sym.p1,sym.q1,sym.s1,sym.r1)[j]))*vec4[4](sym.p1,sym.q1,sym.s1,sym.r1)[j];\n    }\n  }\n  return pos;\n}\nfloat polytope(vec4 pos4,int shlA,int shlB,int shlC,int NFOLDS) {\nPolytope thing=init(shlA,shlB,shlC);\npos4 = fold(thing,pos4,NFOLDS);\nreturn orientedtetrahedron(pos4,\nthing.tpo,\nvec4(0,0,0,thing.tpo.w),\nvec4(0,0,thing.tpo.z,thing.tpo.w),\nvec4(0,thing.tpo.y,thing.tpo.z,thing.tpo.w));}\n\n\n    //Others\nfloat duocylinder(vec4 p,vec4 q,vec2 s) {\np=p-q;\n  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - s.xy;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat tiger(vec4 p,vec4 q,vec3 s){\np=p-q;\nreturn length(vec2(length(p.xz)-s.x,length(p.yw)-s.y))-s.z;}\nfloat torus(vec4 p,vec4 q,vec2 s){\np=p-q;\nreturn length(vec4(length(p.xz)-s.x,p.y,0.,p.w))-s.y;}\nfloat torisphere(vec4 p, vec4 q, vec2 s){\np=p-q;\nreturn length(vec4(length(p.xzy)-s.x,0.,0.,p.w))-s.y;}\nfloat bicone( vec4 p, vec4 a, vec4 b, float r1, float r2 ){\n\n  // sampling independent computations (only depend on shape)\n  vec4  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec4 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\nfloat boxwire( vec4 p, vec4 b, float e ){\n       p = abs(p  )-b;\n  vec4 q = abs(p+e)-e;\n  return min(min(min(\n      length(max(vec4(p.x,q.y,q.z,q.w),0.0))+min(max(max(p.x,q.y),max(q.z,q.w)),0.0),\n      length(max(vec4(q.x,p.y,q.z,q.w),0.0))+min(max(max(q.x,p.y),max(q.z,q.w)),0.0)),\n      length(max(vec4(q.x,q.y,p.z,q.w),0.0))+min(max(max(q.x,q.y),max(p.z,q.w)),0.0)),\n      length(max(vec4(q.x,q.y,q.z,p.w),0.0))+min(max(max(q.x,q.y),max(q.z,p.w)),0.0));\n}\nfloat boxwire2( vec4 p, vec4 b, float e ){\n       p = abs(p  )-b;\n  vec4 q = abs(p+e)-e;\n  return min(min(min(min(min(\n      length(max(vec4(p.x,p.y,q.z,q.w),0.0))+min(max(max(p.x,p.y),max(q.z,q.w)),0.0),\n      length(max(vec4(q.x,p.y,p.z,q.w),0.0))+min(max(max(q.x,p.y),max(p.z,q.w)),0.0)),\n      length(max(vec4(q.x,q.y,p.z,p.w),0.0))+min(max(max(q.x,q.y),max(p.z,p.w)),0.0)),\n      length(max(vec4(p.x,q.y,q.z,p.w),0.0))+min(max(max(p.x,q.y),max(q.z,p.w)),0.0)),\n      length(max(vec4(p.x,q.y,p.z,q.w),0.0))+min(max(max(p.x,q.y),max(p.z,q.w)),0.0)),\n      length(max(vec4(q.x,p.y,q.z,p.w),0.0))+min(max(max(q.x,p.y),max(q.z,p.w)),0.0));\n}\n\nfloat menger( in vec4 p ,int steps){\n   float d = box(p,vec4(0),vec4(1.0));\n\n   float s = 1.0;\n   for( int m=0; m<steps; m++ )\n   {\n      vec4 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec4 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.w);\n      float dd = max(r.w,r.x);\n      float de = max(r.x,r.z);\n      float df = max(r.y,r.w);\n      float c = (min(min(min(da,dd),min(db,dc)),min(de,df))-1.0)/s;\n\n      d = max(d,c);\n   }\n\n   return d;\n}\nfloat bezier( in vec4 pos, in vec4 A, in vec4 B, in vec4 C ){    \n    vec4 a = B - A;\n    vec4 b = A - 2.0*B + C;\n    vec4 c = a * 2.0;\n    vec4 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n\n\n\n//Matrix Stuffs\nmat4 RotationMatrix(vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,0,\n                0,0,0,1);\n}\nmat4 RotateXW(float angle){\nfloat s=sin(angle);\nfloat c=cos(angle);\nfloat oc=1.-c;\nreturn mat4(c,0,0,-s,0,1,0,0,0,0,1,0,s,0,0,c);}\nmat4 RotateZW(float angle){\nfloat s=sin(angle);\nfloat c=cos(angle);\nfloat oc=1.-c;\nreturn mat4(1,0,0,0,0,1,0,0,0,0,c,-s,0,0,s,c);}\nmat4 RotateYW(float angle){\nfloat s=sin(angle);\nfloat c=cos(angle);\nfloat oc=1.-c;\nreturn mat4(1,0,0,0,0,c,0,-s,0,0,1,0,0,s,0,c);}\nvec2 rotate(float x, float y, float angle){\nreturn\nvec2(\n (cos(angle)*x)+(sin(angle)*y),\n-(sin(angle)*x)+(cos(angle)*y));\n}\nfloat smin( float a, float b, float k ){\n    k *= 1.0/(1.0-sqrt(0.5));\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - k*0.5*(1.0+h-sqrt(1.0-h*(h-2.0)));\n}    \nvec4 smin( vec4 a, vec4 b, float j ){\n    vec4 k=vec4(j);\n    k *= 1.0/(1.0-sqrt(0.5));\n    vec4 h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - k*0.5*(1.0+h-sqrt(1.0-h*(h-2.0)));\n}    \nvec3 form(float dist,vec3 Color){\nreturn Color*(dist<=0.01?1.:0.);\n}\nvec3 blend(float dist1,float dist2,vec3 col1,vec3 col2 ,float blend){\nfloat bl=smoothstep(-1.,1.,dist2-dist1);\nfloat fac=smin(dist1,dist2,blend);\nreturn (sat(mix(col1,col2,1.-bl)*sat(mix(1.,-50.,fac))))\n\n\n;\n}\nvec4 getpos(mat4x4 info){\nreturn vec4(info[0][0],info[1][0],info[2][0],info[3][0]);\n}\nvec4 getnor(mat4x4 info){\nreturn vec4(info[0][1],info[1][1],info[2][1],info[3][1]);\n}\nvec3 getcol(mat4x4 info){\nreturn vec3(info[0][2],info[1][2],info[2][2]);\n}\nfloat getdis(mat4x4 info){\nreturn info[0][3];\n}\nfloat getdist(mat4x4 info){\nreturn info[1][3];\n}\nfloat getstep(mat4x4 info){\nreturn info[2][3];\n}\n\nfloat gethit(mat4x4 info){\nreturn info[3][3];\n}\nvec4 qmul(vec4 a, vec4 b){\n    return vec4(a.w*b.xyz + b.w*a.xyz + cross(a.xyz, b.xyz), a.w*b.w - dot(a.xyz, b.xyz));\n}\nvec4 qrot(vec4 q, vec4 p){\nreturn qmul(p,-qmul(q,-p));\n}\nfloat hash(vec3 p3){\n\tp3  = fract(p3 * .10311);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 clickStore\t= vec2(4.,  0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue1( in vec2 re, float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfragColour = vec4(0);\n    float click = 0.0;\n    float oldClick = loadValue1(clickStore);\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue1(clickStore, click,  fragColour, fragCoord);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float KEY_I\t\t= 73.5/256.0;\nconst float KEY_J\t\t= 74.5/256.0;\nconst float KEY_K\t\t= 75.5/256.0;\nconst float KEY_L\t\t= 76.5/256.0;\nconst float KEY_Q\t\t= 81.5/256.0;\nconst float KEY_E\t\t= 69.5/256.0;\nconst float KEY_R\t\t= 82.5/256.0;\nconst float KEY_F\t\t= 70.5/256.0;\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 angStore = vec2(10.0,  0.0);\nvec2 mcolxStore = vec2(11.0,  0.0);\nvec2 mcolyStore = vec2(12.0,  0.0);\nvec2 mcolzStore = vec2(13.0,  0.0);\nvec2 mcolwStore = vec2(14.0,  0.0);\nvec2 mcolx2Store = vec2(15.0,  0.0);\nvec2 mcoly2Store = vec2(16.0,  0.0);\nvec2 mcolz2Store = vec2(17.0,  0.0);\nvec2 mcolw2Store = vec2(18.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key){return texture( iChannel2, vec2(key, 0.25) ).x > .0;}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );}\nvec3 loadValue3( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;}\nvec2 loadValue2( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;}\nfloat loadValue1( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;}\nfloat loadValueA1( in vec2 re ){return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;}\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;}\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;}\nvec2 rot2D(inout vec2 p, float a)\n{return cos(a)*p - sin(a) * vec2(p.y, -p.x);}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec4 camPos;\n    vec2 rot;\n    vec4 ang;\n    vec4 mcolx;\n    vec4 mcoly;\n    vec4 mcolz;\n    vec4 mcolw;\n    vec4 mcolx2;\n    vec4 mcoly2;\n    vec4 mcolz2;\n    vec4 mcolw2;\n\n    if (iFrame == 0)\n    {\n        camPos = vec4(0.5,0.5,0.5,0.5);\n        rot = vec2(0,0);\n        ang = vec4(0,0,1,0);\n        mcolx=vec4(1,0,0,0);\n        mcoly=vec4(0,1,0,0);\n        mcolz=vec4(0,0,1,0);\n        mcolw=vec4(0,0,0,1);\n        mcolx2=vec4(1,0,0,0);\n        mcoly2=vec4(0,1,0,0);\n        mcolz2=vec4(0,0,1,0);\n        mcolw2=vec4(0,0,0,1);\n\n    }else\n    {\n        camPos = loadValue4(camStore);\n        rot = loadValue2(rotationStore);\n        ang = loadValue4(angStore);\n        mcolx = loadValue4(mcolxStore);\n        mcoly = loadValue4(mcolyStore);\n        mcolz = loadValue4(mcolzStore);\n        mcolw = loadValue4(mcolwStore);\n        mcolx2 = loadValue4(mcolx2Store);\n        mcoly2 = loadValue4(mcoly2Store);\n        mcolz2 = loadValue4(mcolz2Store);\n        mcolw2 = loadValue4(mcolw2Store);\n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n        rot=rot/2.;\n    \n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n    mat4 M = mat4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);\n    mat4 cammat = mat4(mcolx,mcoly,mcolz,mcolw);\n    mat4 cammat2 = mat4(mcolx2,mcoly2,mcolz2,mcolw2);\n    mat4 mX=RotationMatrix(vec3(0,1,0),rot.x);\n    mat4 mY=RotationMatrix(vec3(1,0,0),-rot.y);\n    mat4 mI=RotateXW(rot.x);\n    mat4 mJ=RotateZW(rot.y);\n    mat4 mK=RotateYW(rot.y);\n\nif (isKeyPressed(KEY_SPACE))\n\t{cammat=mI*mJ*cammat;mX=M;mY=M;}\ncammat=mX*cammat;\ncammat2=mY*cammat2;\n\nmcolx=cammat[0];mcoly=cammat[1];mcolz=cammat[2];mcolw=cammat[3];\nmcolx2=cammat2[0];mcoly2=cammat2[1];mcolz2=cammat2[2];mcolw2=cammat2[3];\n\n\n    \n        storeValue4(angStore,ang,  fragColour, fragCoord);\n        storeValue4(mcolxStore,mcolx,  fragColour, fragCoord);\n        storeValue4(mcolyStore,mcoly,  fragColour, fragCoord);\n        storeValue4(mcolzStore,mcolz,  fragColour, fragCoord);\n        storeValue4(mcolwStore,mcolw,  fragColour, fragCoord);\n        storeValue4(mcolx2Store,mcolx2,  fragColour, fragCoord);\n        storeValue4(mcoly2Store,mcoly2,  fragColour, fragCoord);\n        storeValue4(mcolz2Store,mcolz2,  fragColour, fragCoord);\n        storeValue4(mcolw2Store,mcolw2,  fragColour, fragCoord);\n    time = iTime - time;\n    float speed = time*256.;\n    \n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=4.0;\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{camPos +=(vec4(0,0,1,0) *cammat2*cammat)* speed;}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{camPos +=(vec4(0,0,-1,0)*cammat2*cammat)* speed;}\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{camPos +=(vec4(1,0,0,0) *cammat2*cammat)* speed;}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{camPos +=(vec4(-1,0,0,0)*cammat2*cammat) * speed;}\n  \tif (isKeyPressed(KEY_Q) || isKeyPressed(KEY_RIGHT))\n\t{camPos +=(vec4(0,0,0,1) *cammat2*cammat)* speed;}\n\tif (isKeyPressed(KEY_E) || isKeyPressed(KEY_LEFT))\n\t{camPos +=(vec4(0,0,0,-1)*cammat2*cammat) * speed;}\n    if (isKeyPressed(KEY_R) || isKeyPressed(KEY_RIGHT))\n\t{camPos +=(vec4(0,1,0,0) *cammat2*cammat)* speed;}\n\tif (isKeyPressed(KEY_F) || isKeyPressed(KEY_LEFT))\n\t{camPos +=(vec4(0,-1,0,0)*cammat2*cammat) * speed;}\n    \n    storeValue4(camStore, camPos,  fragColour, fragCoord);\n\n    storeValue1(timeStore, iTime,  fragColour, fragCoord);\n            \n}","name":"Buffer B","description":"","type":"buffer"}]}