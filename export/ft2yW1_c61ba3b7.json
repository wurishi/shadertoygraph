{"ver":"0.1","info":{"id":"ft2yW1","date":"1650307729","viewed":74,"name":"Statue in shadow","username":"rucksack","description":"Tried to do shadows a little better than last time.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// For easily pasting this into a project I'm working on\n#define time iTime\n\n// Raymarching parameters\n#define MAX_STEPS 200\n#define NEAR_ENOUGH 0.001\n#define TOO_FAR 15.0\n\n// Lighting parameters\n#define DIFFUSE_FACTOR  1.2\n#define SPECULAR_FACTOR .3\n#define SHININESS 4.\n\n#define BACKGROUND_COLOR .2*vec3(0.35686,0.14902,0.20392)\n#define SPECULAR_COLOR .4*vec3(0.95686,0.14902,0.40392)\n\n// Toggle animated light\n#define ANIMATE 1\n// Toggle green shadow emphasis\n//#define EMPHASIZE_SHADOW 1\n\n\n// From assignment template code in TDT4230\nfloat rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }\nfloat dither(vec2 uv) { return (rand(uv)*2. - 1.) / 512.; }\n\n\nfloat sphere(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\n// SDF from Inigo Iquilez\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Smooth operators by Inigo Iquilez\nfloat smooth_min(float a, float b, float k) {\n    float h = clamp( 0.5 + 0.5*(a-b)/k, 0.0, 1.0 );\n    return mix( a, b, h ) - k*h*(1.0-h);\n}\n\nfloat smooth_diff( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat distance_from_everything(vec3 point) {\n    float d = point.y;\n    d = smooth_min(d, capsule(point, vec3(0), vec3(0, 2, 0), 1.), 1.2);\n    vec3 eye_pos = vec3(.3, 1.8, -1.);\n    d = smooth_diff(sphere(point, eye_pos, .15), d, .05);\n    d = smooth_diff(sphere(point, vec3(-eye_pos.x, eye_pos.yz), .15), d, .05);\n    eye_pos.y -= .4;\n    eye_pos.x -= .1;\n    d = smooth_diff(capsule(point, eye_pos, vec3(-eye_pos.x, eye_pos.yz), .15), d, .05);\n    return d;\n}\n\nvec3 sun_position() {\n    float orbit_radius = 5.;\n#ifdef ANIMATE\n    return vec3(orbit_radius*cos(1.2*time), 2., orbit_radius*sin(1.2*time));\n#else\n    return vec3(-.5*orbit_radius, 1., -orbit_radius);\n#endif\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction) {\n    // How far we've traveled\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance;\n        // Check status - have we reached a surface?\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\nvec3 sample_sun(vec3 ray_origin, vec3 ray_direction) {\n    float d = 0.0;\n    float intensity = 0.;\n    float inside = 0.;\n    vec3 light = sun_position();\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on in fixed steps\n        d += 1.;\n        // Sample distance to light\n        intensity += pow(smoothstep(2., 0., length(point - light)), 3.);\n        // Sample negative values of the SDF\n        if (current_distance < NEAR_ENOUGH)\n            inside += abs(current_distance);\n        if (d > TOO_FAR)\n            break;\n    }\n    // Diminish intensity based on how obstructed the view of the sun was\n    return vec3(intensity) * exp(-10.*inside);\n}\n\n// Approach taken from https://iquilezles.org/articles/rmshadows\nfloat ray_shadow(vec3 ray_origin, vec3 ray_direction, vec3 light_position) {\n    // Start some distance along the rain to avoid counting shadow because we're close to the surface\n    float d = NEAR_ENOUGH;\n    float shade = 1.0;\n    float shadow_factor = 32.;\n    // Sign of the direction we're travelling,\n    // if this changes we know that we passed the light source.\n    vec3 side = sign(light_position - ray_origin);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance;\n        // Update to more significant shadow value\n        shade = min(shade, shadow_factor * current_distance / d);\n        // Only check if we've gone too far or gone beyond the light source\n        if (d > TOO_FAR || sign(light_position - point) != side)\n            break;\n    }\n    return max(shade, 0.);\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NEAR_ENOUGH, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\n\nvec3 lighting(vec3 point, vec3 camera, vec3 ray_direction, float dist) {\n    // Avoid casting specular highlight from the void\n    if (length(point - camera) > TOO_FAR*0.99)\n        return BACKGROUND_COLOR;\n\n    vec3 light_position = sun_position();\n\n    vec3 n = estimate_normal(point);\n    vec3 l = normalize(light_position-point);\n    vec3 c = normalize(camera-point);\n    vec3 r = reflect(-l, n);\n\n    // Standard phong lighting\n    float diffuse = max(dot(n, l), 0.);\n    float specular = pow(max(dot(r, -c), 0.), SHININESS);\n    vec3 surface_color = (.2*n+.8).rbg; // color values in the range [0.6, 1.0]\n    vec3 phong = DIFFUSE_FACTOR * diffuse * surface_color + SPECULAR_FACTOR * specular * SPECULAR_COLOR;\n\n    // Find soft shadow factor by marching from where you stand\n    float shade = ray_shadow(point, l, light_position);\n\n#ifdef EMPHASIZE_SHADOW\n    return vec3(l.x, 0., l.z) * SPECULAR_COLOR + (1.-shade) * vec3(0, 1, 0);\n#else\n    return mix(BACKGROUND_COLOR, phong, shade);\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    // Ray origin\n    vec3 camera = vec3(0., 1., -4.);\n    // Ray direction\n    vec3 ray_direction = vec3(xy, 1.);\n\n    float d = ray_march(camera, ray_direction);\n    \n    vec3 point = camera + ray_direction * d;\n    \n    vec3 base_color = lighting(point, camera, ray_direction, d);\n    base_color += sample_sun(camera, ray_direction);\n\n    fragColor = vec4(base_color + dither(fragCoord), 1.);\n}","name":"Image","description":"","type":"image"}]}