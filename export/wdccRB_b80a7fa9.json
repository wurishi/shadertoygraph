{"ver":"0.1","info":{"id":"wdccRB","date":"1601150159","viewed":142,"name":"progression","username":"neriakX","description":"just toying around ... heavily inspired by evvvvil's work. still work in progress.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by evvvil's ray marching videos on twitch <3\n\nconst float FOV=.55;\nconst int ITER=128;\nconst float PI=acos(-1.);\nconst float TAU=PI*2.;\n\nfloat t,tt,st;\nvec2 sc;\nvec3 np, no, al, po, ld, ro;\n\nfloat ssub( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h*(1.0 - h);\n}\n\n// rotation function\nmat2 r2 (float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n//sphere\nfloat sp(vec3 p, float r) { return length(p)-r; }\n\n//diamond\nfloat di (vec3 p, float s) \n{\n    float lx = length(p.x);\n    float ly = length(p.y);\n    float lz = length(p.z);\n    return sqrt(lx+ly+lz)-s;   \n}\n\n// octahedron\nfloat oh ( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// the thing\nvec2 bs (vec3 p)\n{   \n    np=p;\n    for(int i=0;i<5;i++) { // let'S clone and rotate stuff\n        np=abs(np)-vec3(2.,2.5,1.5);\n        np.xy *= r2(1.3+cos(tt*.5));\n        np.y -= 1.6*.5+sin(tt*.5);\n        np.xz *=r2(tt*.25);     \n    }\n    vec2 h,t=vec2(oh(np,2.3),10.); // octahedron iq\n    //vec2 h,t=vec2(di(np,1.5),10.); // my diamond\n    h=vec2(sp(np,1.45),5.); // mix with blue sphere\n    t=(t.x<h.x)?t:h;\n    t.x*=0.7; // reduce artifacts\n    return t;\n}\n\n\n// lighting\nfloat li (vec3 n, vec3 l)\n{\n  return max(0., dot(n, l));\n}\n\n// Camera\n vec3 cam (vec3 ro, vec2 uv, float fov)\n{\n    vec3 cw=normalize(vec3(0.)-ro),\n        cu=normalize(cross(cw, vec3(0.,1.,0.))),\n        cv=normalize(cross(cu,cw));\n    return mat3(cu,cv,cw)*normalize(vec3(uv,FOV));\n} \n\n// the scene\nvec2 mp (vec3 p) \n{   \n    p.xy*=r2((p.z-ro.z)*st*0.1);\n    vec2 h,t=bs(p);\n    t.x=max(t.x,-0.5*(length(p-ro)-2.)); // stopping our camera from colliding with things    \n    return t;\n}\n\n// main raymarching function\nvec2 tr (vec3 ro, vec3 rd) \n{\n    vec2 h,t=vec2(0.1);\n    for(int i=0;i<ITER;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>30.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if (t.x>30.) t.x=0.;\n    return t;\n}\n\n// get Normals (iq)\nvec3 calcNormal( in vec3 po )\n{   \n    vec2 e=vec2(.00035,-.00035);\n    return normalize(e.xyy*mp(po+e.xyy).x+\n        e.yyx*mp(po+e.yyx).x+\n        e.yxy*mp(po+e.yxy).x+\n        e.xxx*mp(po+e.xxx).x); \n}\n\n// AO\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.) \n// SSS\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.xy / iResolution.xy);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    tt=mod(iTime,100.);\n\tst=clamp(cos(tt),0.,1.); \n      \n    // ray_origin / camera\n    ro = vec3(0.,3.+sin(tt),17.+cos(tt*.5)); //ray origin\n    \n    vec3 rd=cam(ro,uv,FOV),\n    co,fo,ld=normalize(vec3(0.,0.,10.));\n    co=fo=vec3(0.55,0.22,0.05)-rd.y*.4;\n      \n    sc=tr(ro,rd); // sc.x = distance geometry, sc.y = colour\n    t=sc.x; // t is the result of the geometry\n    \n    if (t>0.) \n    {   \n        po=ro+rd*t;\n        vec3 no=calcNormal(po),\n        al=mix(vec3(0.,0.10,0.45),vec3(0.1,0.30,0.55),.5); // albedo\n     \n        // Material colouring\n        if(sc.y<5.) al=vec3(0.);\n        if(sc.y>5.) al=vec3(1.);\n        if(sc.y>9.) al=vec3(0.8, 0.3, 0.01);\n        \n        float dif=li(no,ld), // diffuse\n        fr=pow(1.+dot(no,rd),4.), // fresnel\n        sp=pow(max(dot(reflect(-ld,no),-rd),0.),55.); // specular by shane.\n        co=mix(sp+al*(a(.1)*a(.3)+.2)*(vec3(1.)*dif+s(.5)*1.5),fo,min(fr,.5)); // final lights\n        co=mix(co,vec3(0.12,0.03,0.01),1.-exp(-0.00015*t*t*t)); // add fog\n        \n        // Subtle vignette by Shane\n        uv = fragCoord/iResolution.xy;\n        co = mix(vec3(0.),co,pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),.125)*.5 +.5);\n          \n        \n    }\n    \n    fragColor = vec4(pow(co,vec3(0.45)),1.); // add gamma correction\n}","name":"Image","description":"","type":"image"}]}