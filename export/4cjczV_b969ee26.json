{"ver":"0.1","info":{"id":"4cjczV","date":"1722619388","viewed":57,"name":"Spherical Mapping Functions","username":"mxcop","description":"My testing of spherical mapping functions, for generating 3D radiance probe directions.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mapping","octahedral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14;\n\n#define MIRROR 1\n\nvec3 octahedral_unmap(vec2 e) {\n#if MIRROR\n    /* Source: <https://www.shadertoy.com/view/MdsfzN> */\n    vec2 m = abs(e - 0.5) + 0.5;\n    vec2 f = floor(m);\n    float x = f.x - f.y;\n    bool mirror = (x != 0.0); \n    if (mirror) e.xy = 1.0-e.xy;\n#endif\n    /* Provided by Alexander Sannikov */\n    e = fract(e);\n    e = e * 2.0 - vec2(1.0);\n    vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\n    if (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * sign(v.xy);\n    return normalize(v);\n}\n\n/* Provided by Alexander Sannikov */\nvec3 costheta_unmap(vec2 uv) {\n    float phi = uv.x * 2.0 * PI;\n    float theta = uv.y * PI;\n    return vec3(vec2(sin(phi), cos(phi)) * sin(theta), cos(theta));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy*2.0;\n    \n    vec3 col; \n    if (mod(iTime, 2.0) < 1.0)\n        col = (costheta_unmap(uv) + 1.0) * 0.5;\n    else\n        col = (octahedral_unmap(uv) + 1.0) * 0.5;\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}