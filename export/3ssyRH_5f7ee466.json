{"ver":"0.1","info":{"id":"3ssyRH","date":"1584162785","viewed":54,"name":"Lighting Demo cs 180 Project","username":"ncduncan111","description":"implicit geom proj","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Making chess pieces using raymarching and constructive solid geometry\n// Copy + paste all of this code into shadertoy and run it\n\n// Defines\n#define STEP_MAX 200\n#define DIST_MAX 100.0\n#define EPSILON 0.001\n\n#define WHITE 0.\n#define BLACK 1.\n#define FLOOR 2.\n\n\n// Get color based on which distance function was intersected with\nvec3 get_color(float key){\n    if(key == WHITE){\n        return vec3(.55, .55, .55);\n    } else if(key == BLACK){\n        return vec3(.25, .25, .25);\n    } else if(key == FLOOR){\n        return vec3(.3,.3,.3);   \n    } else{\n        return vec3(.4, .2, .2);\n    }\n}\n\n// Get material for phong reflectance \nvec3 get_mat(float key){\n    if(key == WHITE || key == BLACK){\n        return vec3(.8);\n    }else{\n        return vec3(.05);\n    }\n}\n\n// Signed distance functions defined here:\nfloat sphere_sdf( vec3 p, vec3 c, float r)\n{\n  return length(p - c) - r;\n}\n\n// Distance function for the floor\nfloat floor_sdf(vec3 p){\n    vec4 plane = vec4(0, 1, 0, 0);\n    return dot(p, plane.xyz) - plane.w;\n}\n\nfloat wall_sdf(vec3 p){\n    vec4 plane = vec4(0, 0, -1, -10);\n    return dot(p, plane.xyz) - plane.w;\n}\n\nvec2 black_sphere_sdf(vec3 p, vec3 c, float r){\n    return vec2(sphere_sdf(p, c, r), WHITE);   \n}\n\n// Combine all the distance functions for the scene in this function\nvec2 scene_sdf(vec3 p){\n    vec2 curr = black_sphere_sdf(p, vec3(0, 1, 8), 1.);\n    vec2 plane = vec2(floor_sdf(p), 2); \n    vec2 wall = vec2(wall_sdf(p), 2);\n    \n    if(plane.x < curr.x){\n        curr = plane;   \n    }\n    \n    if(wall.x < curr.x){\n        curr = wall;\n    }\n    return curr;\n}\n\n\n// Perform ray marching by finding the min distance ray can travel without hitting anything and iterating\nvec2 ray_march(vec3 cam_pos, vec3 cam_dir){\n    float t_near = 0.0;\n    for(int i = 0; i < STEP_MAX; i++){\n        vec3 p = cam_pos + cam_dir * t_near; // t_near is how far we can go along ray without hitting object\n        vec2 dist = scene_sdf(p);\n        t_near += dist.x;\n        // Check if we missed entirely or hit something\n        // > DIST_MAX then we missed all objects, less than EPSILON, we hit an object \n        if(t_near > DIST_MAX){ \n            return vec2(-1., -1);\n        }else if(dist.x < EPSILON){\n            return vec2(t_near, dist.y); \n        }\n    }\n    \n    return vec2(-1., -1);\n}\n\n\n\n\n// Get normal by approximating the gradient at some point in the scene\nvec3 normal_at(vec3 p){\n    float dist = scene_sdf(p).x;\n    return normalize(dist - vec3( \n        scene_sdf(p - vec3(0.01, 0, 0)).x,\n        scene_sdf(p - vec3(0, 0.01, 0)).x,\n        scene_sdf(p - vec3(0, 0, 0.01)).x\n    ));\n}\n\n\n\n// Add simple point lights to illuminate the scene\nvec3 get_light(vec3 p, vec3 color, vec3 mat, vec3 cam_pos){\n    vec3 l1_intensity = vec3(.1,.9,.1) * 4.;\n    vec3 l1 = vec3(0, 7, 7);\n    vec3 l1_dir = normalize(l1 - p);  // Direction vector from the point to light\n    float decay_l1 = (1. / length(p - l1));\n    \n    vec3 l2_intensity = vec3(.9,.1,.1) * 4.;\n    vec3 l2 = vec3(-2, .5, 4.);\n    vec3 l2_dir = normalize(l2 - p);  // Direction vector from the point to light\n    float decay_l2 = (1. / length(p - l2));\n    \n    vec3 l3_intensity = vec3(.1,.1,.9) * 4.;\n    vec3 l3 = vec3(2, .5, 4.);\n    vec3 l3_dir = normalize(l3 - p);  // Direction vector from the point to light\n    float decay_l3 = (1. / length(p - l3));\n    vec3 l_a = vec3(0.1);\n    \n    float p_s = 30.;\n    \n    vec3 norm = normal_at(p);  // Get the normal at the point\n    \n    // Coefficients for specular/diffuse\n    vec3 kd = vec3(color);\n    vec3 ks = vec3(mat);\n    \n    // Set up view direction\n    vec3 v = cam_pos - p;\n    v = normalize(v);\n    \n    vec3 half_vec_l1 = (l1_dir + v) / (length(l1_dir + v));\n    vec3 half_vec_l2 = (l2_dir + v) / (length(l2_dir + v));\n    vec3 half_vec_l3 = (l3_dir + v) / (length(l3_dir + v));\n    half_vec_l1 = normalize(half_vec_l1);\n    half_vec_l2 = normalize(half_vec_l2);\n    half_vec_l3 = normalize(half_vec_l3);\n    \n    float ndotl1 = dot(norm, l1_dir);  // Calculate diffuse color intensity as dot product of light direction and surface normal\n    ndotl1 = clamp(ndotl1, 0.0, 1.0);\n    \n    float shadow = ray_march(p + norm * EPSILON * 2., l1_dir).x;  // MUST ADD Epsilon to ensure don't accidently hit the floor\n    if(shadow < length(l1 - p) && shadow != -1.){  // Hit something between light and point so we're in a shadow\n        l1_intensity = .1 * l1_intensity;\n    }\n    color += kd * (ndotl1 * (l1_intensity * decay_l1));\n    \n    \n    float ndotl2 = dot(norm, l2_dir);  // Calculating dot for second light\n    ndotl2 = clamp(ndotl2, 0.0, 1.0);\n    \n    shadow = ray_march(p + norm * EPSILON * 2., l2_dir).x;  // MUST ADD Epsilon to ensure don't accidently hit the floor\n    if(shadow < length(l2 - p) && shadow != -1.){  // Hit something between light and point so we're in a shadow\n        l2_intensity *= .1;\n    }\n    \n    float ndotl3 = dot(norm, l3_dir);\n    ndotl3 = clamp(ndotl3, 0.0, 1.0);\n    \n    shadow = ray_march(p + norm * EPSILON * 2., l3_dir).x;\n    if(shadow < length(l3 - p) && shadow != -1.){\n        l3_intensity *= .1;   \n    }\n        \n    color += kd * (ndotl2 * l2_intensity * decay_l2);\n    color += kd * (ndotl3 * l3_intensity * decay_l3);\n    vec3 spec = pow(dot(half_vec_l1, norm),p_s) * ks * (l1_intensity * decay_l1);\n    spec += pow(dot(half_vec_l2, norm), p_s) * ks * (l2_intensity * decay_l2);\n    spec += pow(dot(half_vec_l3, norm), p_s) * ks * (l3_intensity * decay_l3);\n    return color + l_a + spec;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (0.5) * iResolution.xy)/iResolution.y;\n\n    vec3 cam_pos = vec3(0,1,0);\n    vec3 cam_dir = vec3(uv.x, uv.y, 1);\n    vec3 col = vec3(0);\n    vec2 t = ray_march(cam_pos, cam_dir);\n    if(t.x == -1.){\n        col = get_color(t.y) * (1. - (uv.y));\n    }else{\n        vec3 point = cam_pos + cam_dir * t.x;  // Point in the scene (for shading purposes)\n        vec3 color = get_color(t.y);\n        vec3 mat = get_mat(t.y);\n        vec3 new_col = get_light(point, color, mat, cam_pos);\n        // Rendering to screen\n        col = vec3(new_col);\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}