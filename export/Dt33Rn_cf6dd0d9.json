{"ver":"0.1","info":{"id":"Dt33Rn","date":"1682525637","viewed":117,"name":"3D Ray Tracing Scene","username":"yeraytm","description":"3D Ray Tracing project implementing different techniques as part of the Advanced Graphics Programming course at the UPC.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","noise","reflection","phong","fbm","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* 3D Ray Tracing Scene by yeraytm\nhttps://www.shadertoy.com/view/\n\nLicense: MIT License\n\nProject with educational purposes only, featuring:\n- Phong Shading\n- Hard Shadows\n- Reflection (1-Bounce & Fresnel)\n- Refraction\n- Cloud Sky generated with FBM\n- Checkerboard ground plane texture\n- Antialiasing\n- Camera and mouse interaction\n- Distance fog\n\nResources I used to learn about this topic:\n- thebookofshaders.com\n- youtube.com/@DarkoSupe\n- youtube.com/@TheArtofCodeIsCool\n*/\n\n#define HORIZON_DISTANCE 10000.0\n#define SURF_DIST 0.001\n#define PI 3.14159265359\n\nfloat random(vec2 uv)\n{\n    return fract(sin(\n        dot(uv.xy,\n        vec2(12.9898,78.233))) * \n        43758.5453123);\n}\n\nfloat noise(in vec2 uv)\n{\n    // Get integer and fractional parts\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec2 delta = vec2(1.,0.);\n    // Four corners of the tile\n    float BL = random(i);\n    float BR = random(i + delta.xy);\n    float TL = random(i + delta.yx);\n    float TR = random(i + delta.xx);\n    \n    // Smooth interpolation (Cubic Hermite)\n    f = f * f * (3.0 - 2.0 * f);\n    \n    // mix the corners\n    float bottom = mix(BL,BR, f.x);\n    float top = mix(TL,TR,f.x);\n    \n    return mix(bottom,top, f.y);\n}\n\nfloat fbm(in vec2 uv)\n{\n    float value = 0.0;\n    float amplitude = 0.5;\n    vec2 shift = vec2(100.0);\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(.5), sin(.5), -sin(.5), cos(.5));\n    \n    for (int i = 0; i < 8; ++i)\n    {\n        value += amplitude * noise(uv);\n        uv = rot * uv * 2.0 + shift;\n        amplitude *= 0.5;\n    }\n    \n    return value;\n}\n\n// X-RIGHT | Y-UP | Z-FORWARD\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    vec3 lookAt;\n    float zoom;\n} camera;\n\nstruct Light\n{\n    vec3 direction;\n    float ambient;\n} light;\n\nstruct Material\n{\n    vec3 color;      // Surface Color\n    float diffuse;   // Surface diffuse factor\n    float specular;  // Surface specular factor\n    float shininess; // Surface shininess intensity\n    float R0;        // Surface reflectiveness (if 0. no reflection is calculated)\n    float IOR;       // Index of Refraction (if 0. no refraction is calculated)\n} materialArray[7];\n\nstruct Plane\n{\n    float height;\n    Material material;\n} plane;\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material material;\n} sphereArray[6];\n\nstruct Ray\n{\n    vec3 direction;\n    vec3 origin;\n};\n\nstruct Hit              // Info about a surface hit\n{\n    float t;            // Distance from ray origin to intersection\n    vec3 p;             // Hit surface position\n    vec3 normal;        // Hit surface normal\n    Material material;  // Hit object material\n};\n\nvoid IntersectFloor(in Ray ray, inout Hit hit)\n{\n    // Floor Intersection\n    float t = (plane.height - ray.origin.y) / ray.direction.y;\n    \n    // t < hit.t to know if the object is closer than previous intersections\n    // If the plane is too close to the origin, don't detect it as a hit\n    // t > not exactly 0 as it creates artifacts in the plane\n    if(t < hit.t && t > SURF_DIST)\n    {        \n        hit.t = t;\n        hit.p = ray.origin + t * ray.direction;;\n        hit.normal = vec3(0, 1, 0);\n        hit.material = plane.material;\n        \n        float tileValue = mod(floor(mod(hit.p.x, 2.)) + floor(mod(hit.p.z, 2.)), 2.);\n        hit.material.color = vec3(tileValue);\n        \n        // To solve an artifact in shperes' reflection of the horizon (due to this fog-like effect)\n        if(ray.direction == camera.direction)\n            hit.material.color = mix(vec3(tileValue), vec3(0.8), hit.t/100.);\n    }\n}\n\nvoid IntersectSphere(in Ray ray, in Sphere sphere, inout Hit hit, in bool inside)\n{\n    /* Sphere Intersection\n    t1 = dot(OC, dir)\n    k = origin + t1 * dir\n    L1 = length(CK)\n    L2 = sqrt(pow(radius)-pow(L1))\n    t = t1 - L2\n    p = origin + t * dir\n    */\n    \n    vec3 OC = sphere.position - ray.origin;\n    float t1 = dot(OC, ray.direction);\n    \n    // If the sphere is too close to the origin, don't detect it as a hit\n    if(t1 > SURF_DIST)\n    {\n        vec3 k = ray.origin + t1 * ray.direction;\n        float L1 = length(k-sphere.position);\n    \n        float L2 = sqrt(sphere.radius*sphere.radius - L1*L1);\n        \n        float t = t1 - L2;\n        \n        if(inside)\n            t = t1 + L2;\n        \n        // t < hit.t to know if the object is closer than previous intersections\n        if(t < hit.t && L1 <= sphere.radius)\n        {\n            hit.t = t;\n            hit.p = ray.origin + t * ray.direction;\n            hit.normal = normalize(hit.p - sphere.position);\n            hit.material = sphere.material;\n        }\n    }\n}\n\nbool CheckIntersections(in Ray ray, inout Hit hit, in bool inside)\n{\n    hit.t = HORIZON_DISTANCE;\n    \n    IntersectFloor(ray, hit);\n    \n    for(int i = 0; i < sphereArray.length(); ++i)\n        IntersectSphere(ray, sphereArray[i], hit, inside);\n    \n    return hit.t < HORIZON_DISTANCE;\n}\n\nvec3 SkyBox(in Ray ray)\n{\n    vec3 white = vec3(0.85, 0.9, 1);\n    vec3 blue = vec3(0.2, 0.5, 1);\n    vec3 skyColor = mix(white, blue, ray.direction.y);\n    \n    // Plane (Sky) Intersection\n    float t = (-30.0 - ray.origin.y) / ray.direction.y;\n    vec3 p = ray.origin + t * ray.direction;\n    \n    // Clouds from FBM\n    float value = fbm(vec2(p.x * 0.035 + iTime/2.5, p.z * 0.09));\n    \n    return mix(white, skyColor, value * 2.4);\n}\n\nvec3 ComputeShading(in Ray ray, in bool rayIntersects, inout Hit hit)\n{\n    if(!rayIntersects)\n        return SkyBox(ray);\n    \n    // AMBIENT\n    vec3 ambient = light.ambient * hit.material.color;\n    \n    Hit shadowHit;\n    // If an intersection happens, this pixel is part of a shadow, so lit it only with ambient\n    if(CheckIntersections(Ray(light.direction, hit.p + hit.normal * SURF_DIST), shadowHit, false))\n        return ambient;\n        \n    /* We avoid having a negative diffuse and shininess coeficient (using max)\n    as it looks weird in some cases */\n    \n    // DIFFUSE\n    float diffuseCoef = dot(light.direction, hit.normal);\n    vec3 diffuse = hit.material.diffuse * max(diffuseCoef, 0.) * hit.material.color;\n    \n    // SPECULAR\n    float shininessCoef = max(dot(ray.direction, reflect(light.direction, hit.normal)), 0.);\n    shininessCoef = pow(shininessCoef, hit.material.shininess);\n    vec3 specular = hit.material.specular * shininessCoef * hit.material.color;\n    \n    return ambient + diffuse + specular;\n}\n\n// Wrapping function to get a color from a ray (direction and origin)\nvec3 ComputeRayColor(in Ray ray)\n{\n    Hit hit;\n    bool intersects = CheckIntersections(ray, hit, false);\n    return ComputeShading(ray, intersects, hit);\n}\n\nfloat ComputeFresnel(in vec3 direction, in Hit hit)\n{\n    // Schlick aproximation\n    float theta = 1. - dot(hit.normal, -direction);\n    float fresnel = pow(clamp(theta, 0., 1.), 5.);\n    fresnel *= 1. - hit.material.R0;\n    \n    if(hit.t < HORIZON_DISTANCE)\n        return fresnel + hit.material.R0;\n    \n    return 0.;\n}\n\nvec3 ComputeRefraction(in vec3 cameraDir, in Hit mainRayHit)\n{\n    // Refracted ray direction inside the sphere\n    vec3 refractionInDir = normalize(refract(cameraDir, mainRayHit.normal, mainRayHit.material.IOR));\n    \n    // Ray casted inside\n    Ray enterRay = Ray(refractionInDir, mainRayHit.p - mainRayHit.normal * SURF_DIST);\n    Hit enterHit;\n    bool enterIntersects = CheckIntersections(enterRay, enterHit, true);\n    \n    // Ray exiting the sphere and calculating its final color\n    vec3 refractionOutDir = normalize(refract(refractionInDir, -enterHit.normal, 1.0/mainRayHit.material.IOR));\n    Ray refractionRay = Ray(refractionOutDir, enterHit.p + enterHit.normal * SURF_DIST);\n    return ComputeRayColor(refractionRay);\n}\n\nvec3 Render()\n{\n    // Main Ray\n    Ray mainRay = Ray(camera.direction, camera.position);\n    Hit drawingHit;\n    bool rayIntersects = CheckIntersections(mainRay, drawingHit, false);\n    vec3 colorDirect = ComputeShading(mainRay, rayIntersects, drawingHit);\n    \n    // Material is refractive\n    if(drawingHit.material.IOR != 0.)\n        colorDirect = ComputeRefraction(camera.direction, drawingHit);\n    \n    // Material is NOT reflective\n    if(drawingHit.material.R0 == 0.)\n        return colorDirect;\n    \n    // Reflection Ray (from main ray intersection position)\n    vec3 reflectionDir = normalize(reflect(camera.direction, drawingHit.normal));\n    vec3 reflectionColor = ComputeRayColor(Ray(reflectionDir, drawingHit.p + drawingHit.normal * SURF_DIST));\n    \n    // Fresnel Calculation\n    float fresnelFactor = ComputeFresnel(camera.direction, drawingHit);\n    \n    return mix(colorDirect, reflectionColor, fresnelFactor);\n}\n\nvoid SetupScene()\n{   \n    materialArray = Material[7] (\n    /*Plane        */ Material(/*Color*/ vec3(0.9, 0.9, 0.9), /*Diffuse*/ 0.80, /*Specular*/ 1.00, /*Shininess*/ 05.0, /*R0*/ 0.01, /*IOR*/ 0.0     ),\n    /*Matte Red    */ Material(/*Color*/ vec3(0.9, 0.2, 0.2), /*Diffuse*/ 0.70, /*Specular*/ 0.70, /*Shininess*/ 20.0, /*R0*/ 0.00, /*IOR*/ 0.0     ),\n    /*Refl  Green  */ Material(/*Color*/ vec3(0.2, 0.9, 0.3), /*Diffuse*/ 0.75, /*Specular*/ 3.90, /*Shininess*/ 30.0, /*R0*/ 0.07, /*IOR*/ 0.0     ),\n    /*Refl  Purple */ Material(/*Color*/ vec3(0.9, 0.2, 0.9), /*Diffuse*/ 0.30, /*Specular*/ 3.90, /*Shininess*/ 30.0, /*R0*/ 0.10, /*IOR*/ 0.0     ),\n    /*Refract 1.0  */ Material(/*Color*/ vec3(1),             /*Diffuse*/ 0.50, /*Specular*/ 0.50, /*Shininess*/ 10.0, /*R0*/ 0.05, /*IOR*/ 1.0     ),\n    /*Refract Move */ Material(/*Color*/ vec3(1),             /*Diffuse*/ 0.50, /*Specular*/ 0.50, /*Shininess*/ 10.0, /*R0*/ 0.05, /*IOR*/ 1.0/1.5 ),\n    /*Refract Still*/ Material(/*Color*/ vec3(1),             /*Diffuse*/ 0.50, /*Specular*/ 0.50, /*Shininess*/ 10.0, /*R0*/ 0.05, /*IOR*/ 1.0/1.01)\n    );\n    \n    plane.height = -0.25;\n    plane.material = materialArray[0];\n    \n    sphereArray = Sphere[6] (\n        Sphere(/*Position*/ vec3( 0.00, 0.01,  0.00), /*Radius*/  0.25, materialArray[1]),\n        Sphere(/*Position*/ vec3( 1.00, 0.00,  0.00), /*Radius*/  0.25, materialArray[2]),\n        Sphere(/*Position*/ vec3( 0.00, 0.30, -1.00), /*Radius*/  0.25, materialArray[3]),\n        Sphere(/*Position*/ vec3( 0.00, 0.01,  1.00), /*Radius*/  0.25, materialArray[4]),\n        Sphere(/*Position*/ vec3(-1.00, 0.00,  0.00), /*Radius*/  0.25, materialArray[5]),\n        Sphere(/*Position*/ vec3(-1.00, 0.50, -1.00), /*Radius*/  0.25, materialArray[6])\n    );\n    \n    // Light direction should be normalized!\n    light.direction = normalize(vec3(0.5, 1.0, 0.9));\n    light.ambient = 0.25;\n    \n    // Sphere Movement\n    sphereArray[1].position.y = -sin(iTime) + 1.;\n    sphereArray[4].position.y = sin(iTime) + 1.;\n}\n\nmat2 Rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - vec2(1.);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    SetupScene();\n    \n    // Camera Rotation based on mouse input\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    camera.position = vec3(0, 0, -3);\n    camera.position.yz *= Rotate(-mouse.y * PI + 1.);\n    camera.position.xz *= Rotate(-mouse.x * PI * 2.); \n    \n    // The greater the zoom, the closer we get (the more disperse the rays will be)\n    camera.zoom = 1.75;\n    camera.lookAt = vec3(0, 0.5, 0);\n    \n    vec3 col = vec3(0);\n    \n    for(int AAIteration = 0; AAIteration < 4; ++AAIteration)\n    {\n        // Displace the coordinates for antialiasing from where we will cast the following ray\n        vec2 displace = uv + float(AAIteration) * vec2(dFdx(uv.x), dFdy(uv.y)) / 4.;\n        \n        // Calculate the local coordinate system of the camera with 3 new vectors that are orthonormal\n        vec3 camZ  = normalize(camera.lookAt - camera.position);\n        vec3 camX  = normalize(cross(vec3(0, 1, 0), camZ));\n        vec3 camY  = cross(camZ, camX);\n        \n        vec3 c = camera.position + camZ * camera.zoom;\n        vec3 i = c + displace.x * camX + displace.y * camY;\n        camera.direction = normalize(i-camera.position);\n        \n        col += Render();\n    }\n    \n    // Calculate the medium of the sum of outputting color from the 4 rays\n    col = col/(4.);\n    \n    // Output to screen\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}