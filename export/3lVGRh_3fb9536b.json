{"ver":"0.1","info":{"id":"3lVGRh","date":"1578280126","viewed":61,"name":"Cruz-v3","username":"jorge2017a1","description":"Cruz-v3","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cruzv3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst float pi = 3.141592653589793;\n\n\n\n\n///-------------------------------------------------\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n//-----------------------------------------------------\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///---------------------------------------------------\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - h * ba) - r;\n}\n\nfloat map(in vec3 p) \n{\n     float planeDist = p.y;\n    vec2 res;\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    d=1000.0; \n    p.z=p.z+4.0;\n    \n    \n    \n     float theta = sin(iTime);\n    float c = cos(theta);\n    float s = sin(theta);\n    mat3 m = mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n        );\n    p = m * p;\n    \n    \n    \n  \n    \n    \n    d=min(d,planeDist);\n    \n    \n    //repetir\n   ///// p.x=mod(p.x,20.0) -6.0;\n    //////p.z=mod(p.z,30.0) -6.0;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,4.0,5.0),vec3(1.0,8.0,1.0));   //vetical\n    //float bx1a = sdBox (p-vec3(0.,0.0,5.4),vec3(0.5,6.0,1.8));   //vertical cch1\n    \n    float bx2 = sdBox (p-vec3(0.,9.0,4.6),vec3(3.3,0.5,1.0));  //horizontal\n    float bx2a = sdBox (p-vec3(0.,9.0,4.6),vec3(3.0,0.4,1.0));  //horizontal\n    \n    float bx3 = sdBox (p-vec3(0.,0.5,5.0),vec3(3.0,0.5,2.0));  //escalon2\n    float bx4 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.0,0.5,3.0)); //escalon1\n    \n    float bx5 = sdBox (p-vec3(0.,0.25,5.0),vec3(4.5,0.25,4.0)); //escalon3 \n    \n    \n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    \n  \n    float dif1, dif2, dif3;\n    \n    \n    \n  \n    dif1=unionSDF(bx1,bx2);\n    dif1=unionSDF(dif1,bx3);\n    dif1=unionSDF(dif1,bx4);\n    dif1=unionSDF(dif1,bx2a);\n    dif1=unionSDF(dif1,bx5);\n    \n    \n    d=min(d, dif1);\n    \n    \n\n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(-1.0, 1.0) * 0.01;\n    return normalize(\n            e.xyy * map(p + e.xyy) +\n            e.yxy * map(p + e.yxy) +\n            e.yyx * map(p + e.yyx) +\n            e.xxx * map(p + e.xxx)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 p = fragCoord.xy / iResolution.xy;\n    p = 2.0 * p - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(1.0);\n    \n    vec3 ro = vec3(0.0, 2.0, -10.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    //vec3 rd = vec3(p, 1.0);\n    \n    \n    float t = 0.0;\n    float h = 0.001 * 2.0;\n    float tmax = 20.0;\n    for(int i = 0; i < 60; i++) {\n        if(h < 0.001 || t > tmax) continue;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    \n    if(t < tmax) {\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        vec3 lig = normalize(vec3(1.0));\n        float dif = clamp(dot(lig, nor), 0.0, 1.0);\n        float spe = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 32.0);\n        float fre = pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 3.0);\n        col *= (vec3(0.94, 0.66, 0.5) * dif + spe) * 0.9 + vec3(0.7, 0.2, 1.0) * fre * 0.5;\n        col = 0.9 * col + 0.1;\n    }\n    else {\n        col = vec3(0.5);\n    }\n    \n        fragColor = vec4(col,1.0);\n \t//= vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}