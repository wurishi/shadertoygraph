{"ver":"0.1","info":{"id":"WdjcWy","date":"1587273909","viewed":251,"name":"Conformal Droste effect (ver2)","username":"RadoKirov","description":"math behind this conformal mapping - http://www.ams.org/notices/200304/fea-escher.pdf","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["escher","conformal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Parameters\nfloat winding = 4.0;\nfloat numSpirals = 3.0;\n\nfloat u_f = 2.5; // scaling\n\nfloat speed = 3.0;\n\n// convert from cartisian to polar.\n// returns [r, theta] in x+iy = r e^i * theta\nvec2 polarz(in vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n// convert from polar to cartisian.\nvec2 cart(in vec2 c) {\n  return vec2(c.x * cos(c.y), c.x * sin(c.y));\n}\n\nvec2 powz(in vec2 c1, in vec2 c2) {\n  vec2 polarC = polarz(c1);\n\n  // (r * e ^ i theta) ^ (x + i y) = r ^ x * r ^ i y * e ^ i x theta * e ^ - y theta\n  // r ^ x * e ^ - y theta * e ^ i (x theta + log (r) y)\n  // |--------- r -------| * e ^ i |------- theta -----|\n\n  float r = pow(polarC.x, c2.x) * exp(-polarC.y * c2.y);\n  float theta = c2.x * polarC.y + log(polarC.x) * c2.y;\n\n  return cart(vec2(r, theta));\n}\n\n\n\nvec3 grid2(in vec2 uv) {\n\n  return (vec3(\n               0.2 * (uv.y * 2.0 - 1.0) + 0.5,\n               0.2 * (uv.x * 2.0 - 1.0) + 0.3,\n               0.2 * length(uv - 0.5) + 0.2));\n}\n\nvec2 conformal(in vec2 uv, float winding, float numSpirals) {\n  float P = log(u_f) / M_PI / 2.0;\n  vec2 alpha = vec2(winding / 4.0, numSpirals * P);\n  return powz(uv, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 e = conformal(c, winding, numSpirals);\n    \n    float t = iTime / speed;\n    e /= exp(log(u_f) * fract(t / log(u_f)));\n    while (abs(e.x) > 1.0 || abs(e.y) > 1.0) {\n      e /= u_f;\n    }\n    while (abs(e.x) < 1.0 / u_f && abs(e.y) < 1.0 / u_f) {\n      e *= u_f;\n    }\n    \n    fragColor = vec4(grid2(e + 1.0 / 2.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}