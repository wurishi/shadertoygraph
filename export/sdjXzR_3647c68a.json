{"ver":"0.1","info":{"id":"sdjXzR","date":"1619581840","viewed":149,"name":"Light in the Dark","username":"eyadnabeel","description":"Infinite bridge, using smooth blended CSG operations and sinusoid-displaced blobs. Water effects using sinusoid functions and Perlin noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","water","bridge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarcher adapted from implementation by Inigo Quilez\n\n#define GAMMA_CORRECTION\n#define MOTION\n#define DISTANCE_FOG\n\n// Material aliases\n#define WATER 0\n#define LAMBERT_RED 1\n#define BLOB 2\n\n// Camera Views\n#define VIEW_0\n//#define VIEW_1\n//#define MOUSE_CONTROL\n\n// Water Noise (NO NOISE -> 0, PERLIN -> 1, WORLEY -> 2)\n#define NOISE 1\n#define SINEWAVES\n\nconst float INFINITY = 99999999999999999.99f;\nconst float PI = 3.14159;\nconst float EPSILON = 0.0001f;\nconst float FAR_CLIP = 500.f;\nconst int RAY_STEPS = 256;\n\nvec2 random2(vec2 p, float seed) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * seed);\n}\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nfloat worley(vec2 uv, float seed) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor, seed); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâ€™s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat noise3( vec3 p ) {\n    vec3 noise = fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n    return max(noise.x, max(noise.y, noise.z));\n}\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint).xyz * 2.f - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\nfloat fbm( in vec3 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves = 2;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*perlinNoise3D(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\nbool equals(float a, float b){\n    return abs(a - b) < EPSILON;\n}\n\nbool equalsmargin(float a, float b, float m){\n    return abs(a - b) < m;\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sub(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat isect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec3 repeat(vec3 pos, float cx, float cy, float cz){\n    return vec3(mod(pos.x + 0.5f * cx, cx) - 0.5f * cx,\n                mod(pos.y + 0.5f * cy, cy) - 0.5f * cy,\n                mod(pos.z + 0.5f * cz, cz) - 0.5f * cz);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid computeray (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat infinite_plane_sdf(vec3 pos, float y){\n    return pos.y - y;\n}\n\nfloat sphere_sdf (vec3 ro, vec3 p, float r){\n    return length(ro - p) - r;\n}\n\nfloat box_sdf(vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(ro - p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat cylinder_sdf(vec3 ro, vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(ro.xz - p.xz)-2.0*ra+rb, abs(ro.y - p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat vert_cylinder_sdf(vec3 ro, vec3 p, float r, float h){\n    float s0 = box_sdf(ro, vec3(0.f, 1.f, 0.f) + p, vec3(r, 2.f * r, h), 0.1f);\n    float s1 = sphere_sdf(ro, vec3(0.f, 0.f, 0.f) + p, r);\n    return isect(s0, s1, 0.1f);\n\n}\n\nfloat arch_sdf(vec3 ro, vec3 p, float r1, float r2, float t){\n    float s0 = vert_cylinder_sdf(ro, p, r1, t);\n    float s1 = vert_cylinder_sdf(ro, p, r2, 2.f * t);\n    float d1 = sub(s1, s0, 0.1f);\n    return d1;\n}\n\nfloat steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 0; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir) * 0.8f, 2.f * dim.y * float(i), 0.f) + p, dim, 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir) * 0.8f) + p, dim.zyx, 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nfloat full_steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 1; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir), dim.y * float(i), 0.f) + p, vec3(dim.x, 2.f * float(i) * dim.y, dim.z), 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir)) + p, vec3(dim.z, dim.y, dim.x), 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\n\nvec2 map(vec3 p){\n    float d, mat, aTime = iTime/2.f;\n    \n    //BRIDGE\n    vec3 q = repeat(p, 12.f , 0.f, 0.f);\n    float a0 = arch_sdf(q, vec3(0.f), 7.f, 5.f, 2.f);\n    float a1 = arch_sdf(q, vec3(0.f), 8.f, 6.f, 1.5f);\n    float d0 = sub(a1, a0, 0.2f);\n    mat = float(LAMBERT_RED);\n    d = d0;\n    \n    \n    // FLOATING BLOBS\n    vec3 qs1 = repeat(p, 40.f, 0.f, 40.f);\n    vec3 qs2 = repeat(p, 10.f, 0.f, 10.f);\n    float f = 5.f;\n    float hf = 15.5f * cos(p.z/40.f);\n    vec3 h0 = vec3(f * cos(iTime/4.f), 15.f + (sin(p.x) + cos(p.z)) * sin(iTime) - hf * (sin(p.x/20.f) + cos(p.z/20.f)) * cos(iTime), f * sin(iTime/2.f));\n    vec3 h1 = vec3(5.f + -f * cos(iTime/4.f), 20.f + (sin(p.x) + cos(p.z)) * sin(iTime) + hf * (cos(p.x/20.f) + sin(p.z/20.f)) * sin(iTime), 5.f + -f * sin(iTime/2.f));\n    float s0 = sphere_sdf(qs1, h0, 3.5f);\n    float s1 = sphere_sdf(qs1, h1, 3.5f);\n    float d1 = smin(s0 * 0.5f, s1 * 0.5f, 2.f);\n    d = smin(d, d1, 3.f);\n    \n    \n    \n    \n    // WATER\n    #if NOISE == 0\n    float plane_noise = 0.f;\n    #elif NOISE == 1\n    float plane_noise = ((perlinNoise3D(p)) * (sin(iTime/5.f) + 1.1f) * 0.5f);\n    #elif NOISE == 2\n    float plane_noise = ((worley(p.xz/10.f, abs(sin(iTime) * cos(iTime/2.f)))) * (sin(iTime/5.f) + 1.1f) * 0.3f);\n    #endif\n    \n    #ifdef SINEWAVES\n    plane_noise += 2.f * cos(p.x/10.f - cos(iTime)) + 2.f * sin(p.z/15.f + sin(iTime));\n    plane_noise -= 2.5f;\n    #endif\n    \n    float d2 = infinite_plane_sdf(p, 0.25f + plane_noise);\n    d = smin(d, d2 * 0.6f, 0.f);\n    mat = equals(d, d2) ? float(WATER) : float(mat);\n\n    d = smin(d, d1, 0.f);\n    mat = equals(d, d1) ? float(BLOB) : float(mat);\n\n    \n    return vec2(d, mat);\n}\n\nvec3 calcNormal(in vec3 pos, float eps){\n    vec2 e = vec2(eps, 0.f);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\nfloat shadowcast(in vec3 ro, in vec3 rd){\n    float res = 1.f;\n    float t = 0.001f;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        float dist = map(pos).x;\n        if (res < 0.0000001){\n            break;\n        }\n        if (dist > FAR_CLIP){\n            break;\n        }\n        res = min(res, 10.f * dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    float res = 1.f;\n    float t = 0.001f;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        float dist = map(pos).x;\n        if (res < 0.0000001){\n            break;\n        }\n        if (t > light_dist){\n            return res;\n        }\n        if (dist > FAR_CLIP){\n            break;\n        }\n        res = min(res, 10.f * dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, out int mat){\n    float t = 0.f;\n    mat = -1;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        vec2 sdf = map(pos);\n        float dist = sdf.x;\n        mat = int(sdf.y);\n        if (abs(dist) < 0.0000001 * t){\n            break;\n        }\n        if (dist > FAR_CLIP){\n            break;\n        }\n        t += dist;\n    }\n    if (t > FAR_CLIP){\n        return -1.f;\n    }\n    return t;\n}\n\nvec3 watercast(in vec3 rd, in vec3 nor){\n    vec3 proj_rd_nor = dot(rd, nor)/dot(nor, nor) * nor;\n    vec3 rd_perp = rd - proj_rd_nor;\n    return rd - 2.f * dot(nor, rd) * nor;\n}\n\nvec3 calcmaterial(vec3 ro, vec3 pos, vec3 nor, int mat){\n        vec3 col = vec3(0.f);        \n        \n        // ambient light parameters\n        vec3 sky_light = vec3(0.f, 0.1f, 0.3f) * clamp(0.5f + 0.5f * nor.y, 0.f, 1.f);\n        \n        // light parameters\n        float aTime = iTime/2.f;\n        #ifdef MOTION\n        vec3 light_pos = vec3(7.f * sin(aTime) - iTime , 7.f, 7.f * cos(aTime));\n        #else\n        vec3 light_pos = vec3(7.f * sin(aTime) , 7.f, 7.f * cos(aTime));\n        #endif\n        vec3 light_dir = normalize(light_pos - pos);\n        vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f) * clamp(dot(nor, light_dir), 0.f, 1.f);\n\n        #ifdef MOTION\n        vec3 light2_pos = vec3(-7.f * cos(aTime) - iTime, 7.f, -7.f * sin(aTime));\n        #else\n        vec3 light2_pos = vec3(-7.f * cos(aTime), 7.f, -7.f * sin(aTime));\n        #endif\n        vec3 light2_dir = normalize(light2_pos - pos);\n        vec3 lambert_light2 = vec3(0.8f, 0.2f, 0.01f) * clamp(dot(nor, light2_dir), 0.f, 1.f);\n        \n\n        // bounce light (fake GI)\n        vec3 bounce_light = vec3(0.1f, 0.05f, 0.02f) * clamp(0.5f - 0.5f * nor.y, 0.f, 1.f);\n        \n        float t_shadow1 = shadowcast_pointlight(pos + nor * EPSILON * 0.0001f, light_dir, distance(light_pos, pos));\n        float t_shadow2 = shadowcast_pointlight(pos + nor * EPSILON * 0.0001f, light2_dir, distance(light2_pos, pos));\n         //t_shadow = 1.f;\n                \n        vec3 base_colour;\n        \n        switch(mat){\n            case WATER:\n            base_colour = vec3(0.f, 0.1f, 0.3f) * 0.05f;\n            break;\n            case LAMBERT_RED:\n            if (nor.y > nor.x){\n                base_colour  = texture(iChannel0, pos.xz/4.f).xyz;\n            } else {\n                base_colour  = texture(iChannel0, pos.xy/4.f).xyz;\n            }\n            base_colour *= vec3(0.9f, 0.2f, 0.4f);\n            break;\n            case BLOB:\n            base_colour = vec3(1.f, 0.4f, 0.3f);\n            break;\n        }\n        \n        // final colour evaluation\n        col = base_colour * lambert_light * 2.f * t_shadow1;\n        col += base_colour * lambert_light2 * 2.f * t_shadow2;\n        \n        col += base_colour * sky_light;\n        col += base_colour * bounce_light;\n        \n        \n        //col += sss/300000.f;\n        \n        return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    \n    // camera variance variable\n    #ifdef MOUSE_CONTROL\n    float u = 20.f * iMouse.x/iResolution.x;\n    float v = PI/2.f * iMouse.y/iResolution.y;\n    #endif\n    \n    // Camera parameters\n    #ifdef MOUSE_CONTROL\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d * cos(u), 30.f * abs(sin(v)), d * sin(u));\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_0\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d, 7.5f, 0.f);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_1\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(0.f, 5.f, d);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef MOTION\n    #ifndef VIEW_1\n    vec3 motion = vec3(-iTime, abs(sin(iTime)), 0.f);\n    #else\n    vec3 motion = vec3(-iTime, 0.f, 0.f);\n    #endif\n    eye += motion;\n    ref.x += motion.x;\n    #endif\n    float fov = 45.f;\n    \n    vec3 ro , rd;\n    computeray(eye, ref, ndc, fov, ro, rd);\n        \n    #ifdef DISTANCE_FOG\n    vec3 col = mix(vec3(0.f, 0.1f, 0.3f) * 0.3f, vec3(0.f, 0.1f, 0.3f) * 0.f, abs(ndc.y * 1.25f));     \n    #else\n    vec3 col = vec3(0.f);\n    #endif\n    int mat = -1;\n    float t = raycast(ro, rd, mat);\n    \n    vec3 rd_new, ro_new;\n    float t_new;\n    int mat_new = -1;\n    \n    if (mat == WATER){\n        ro_new = ro + t * rd;\n        rd_new = watercast(rd, calcNormal(ro_new, 0.000001f));\n        t_new = raycast(ro_new, rd_new, mat_new);\n        rd = normalize((ro_new + t_new * rd_new) - ro);\n        mat = mat_new;\n        t = distance(ro, ro_new + t_new * rd_new);\n        mat_new = WATER;\n    }\n    \n    if (t > 0.f){\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, 0.1f);\n        col = calcmaterial(ro, pos, nor, mat);\n        col *= 1.f - pow(t/FAR_CLIP, 2.f) * vec3(0.8f, 0.8f, 0.6f);\n        #ifdef DISTANCE_FOG\n        col += vec3(0.f, 0.1f, 0.3f) * 0.25f * (t/FAR_CLIP) * (t/FAR_CLIP) ;\n        #endif\n        if (mat_new == WATER){\n            col *= 0.35;\n        }\n    }\n    \n    #ifdef GAMMA_CORRECTION\n    // Gamma correction - https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=1990s - 38:00\n    col = pow(col, vec3(0.4545f));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,t);\n}","name":"Image","description":"","type":"image"}]}