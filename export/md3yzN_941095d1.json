{"ver":"0.1","info":{"id":"md3yzN","date":"1694802555","viewed":51,"name":"Sphere Ray Tracer","username":"Keilorus","description":"My first shader in shader toy :D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nstruct Hit\n{\n    vec3 position;\n    vec3 normal;\n};\n\nbool raycastSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius, out Hit hit)\n{\n    vec3 oc = rayOrigin - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, oc);\n    float c = dot(oc, oc) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) return false;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    float t = min(t1, t2);\n    \n    hit.position = rayOrigin + rayDir * t;\n    hit.normal = normalize(hit.position - sphereCenter);\n    \n    return true;\n}\n\nvec3 camPos = vec3(0.0, 0.0, 2.0);\nvec3 sphereCenter = vec3(0.0);\nfloat reflectivity = 0.1;\nfloat radius = 1.0;\n\nvec3 lightPos = vec3(-2.0, 2.0, 2.0);\nvec3 lightCol = vec3(1.0);\nfloat shininess = 32.0;\n\nvec3 computeColor(Hit hit)\n{\n    vec3 lightDir = normalize(lightPos - hit.position);\n    vec3 viewDir = normalize(camPos - hit.position);\n    \n    vec3 ambient = 0.2 * lightCol;\n    \n    vec3 diffuse = max(0.0, dot(lightDir, hit.normal)) * lightCol;\n    \n    vec3 halfDir = normalize(lightDir + viewDir);\n    vec3 specular = pow(max(0.0, dot(halfDir, hit.normal)), shininess) * lightCol;\n    \n    return ambient + diffuse + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    vec3 rayOrigin = camPos;\n    vec3 rayDir = vec3(ndc.x * aspectRatio, ndc.y, -1.0);\n    \n    vec3 col;\n    \n    Hit hit;\n    \n    if (raycastSphere(rayOrigin, rayDir, sphereCenter, radius, hit))\n    {\n        vec2 texUv = vec2(\n            0.5 + atan(hit.normal.z, hit.normal.x) / (2.0 * PI),\n            0.5 + asin(hit.normal.y) / PI\n            );\n\n        vec3 texCol = texture(iChannel1, texUv).xyz;\n    \n        vec3 sphereCol = computeColor(hit);\n        \n        vec3 reflectionDir = reflect(rayDir, hit.normal);\n        vec3 skyCol = texture(iChannel0, reflectionDir).xyz;\n        \n        col = texCol * sphereCol + skyCol * reflectivity;\n    }\n    else\n    {\n        col = texture(iChannel0, rayDir).xyz;;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}