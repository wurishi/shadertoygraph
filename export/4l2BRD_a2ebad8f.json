{"ver":"0.1","info":{"id":"4l2BRD","date":"1525556889","viewed":123,"name":"aafloor","username":"dahart","description":"Anti-aliased floor & fract functions","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["antialias","floor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define S(a,b,t) smoothstep(a,b,t)\n#define L(a,b,t) S(a,b,t*2.)*S(a,b,2.-t*2.)\nconst vec2 X = vec2(1.0, 0.0);\nconst vec3 nop = vec3(-1.0, 0.0, 1.0);\nconst float PI = 3.14159265358979323;\nconst float fMaxFloat = intBitsToFloat(0x7f7fffff);\nconst vec3 white = X.xxx;\nconst vec3 blue = vec3(.1, .5, 1.);\nconst vec3 black = X.yyy;\n\n// remap v from range [min1,max1] to range [min2,max2]\n// this is unlerp+lerp combined\nfloat remap(float v, float min1, float max1, float min2, float max2) {\n    return min2 + (max2 - min2) * (v - min1) / (max1 - min1);\n}\n\nfloat bias(float x, float b) { return pow(x,log(b)/log(0.5)); }\nfloat gain(float x, float g) { return (x<0.5) ? bias(2.*x,1.-g)/2. : 1. - bias(2.-2.*x,1.-g)/2.; }\n\n// aaFloor is similar to floor() but has a 2-pixel wide gradient between clamped steps\n// to allow the edges in the result to be anti-aliased.\nfloat aaFloor(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? x - fx : remap(fx, idx, 1., x-fx, x);\n}\n\n// Same as aaFloor; clamp except for a 2-pixel wide gradient along the edge\nfloat aaFract(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? fx : remap(fx, idx, 1., fx, 0.);\n}\n\n// escalator() is similar to aaFloor(), but takes a phase offset for animating\nfloat escalator(float x, float steps, float o) {\n    float dx = 1. / steps;\n    x = remap(x, 0., 1., -dx/2., 1.+dx/2.) + dx/2.;\n    float ex = (x - o*dx) * steps;\n    float ey = (aaFloor(ex) + o) * dx;\n    return clamp(ey, 0., 1.);\n}\n\nvec3 Void( vec2 uv )\n{\n    vec4 d, e;\n    float time = iTime + iMouse.x/iResolution.y;\n\tfloat color = 0.;\n    float dx = dFdx(uv).x * 2.;\n\n    float bx0 = -.1;\n    float bx1 = 1.1;\n    float by0 = -.1;\n    float by1 = 1.1;\n    vec2 buv = vec2(remap(uv.x, 0., 1., bx0, bx1), remap(uv.y, 0., 1., by0, by1));\n    float x = buv.x;\n    float y;\n    \n    float sx = sin(time);\n    float sy = cos(time);\n    \n    if (bool(0)) \n    {\n        // render a grating with increasing frequency, to force aliasing\n        y = 1./6. * aaFloor(4.+2.5*sin(pow(buv.x*sx*6. + buv.y*sy*6., 3.5)));\n        // compare aaFract() to regular fract()\n        if (bool(1)) y = aaFract(pow(buv.x*sx*10. + buv.y*sy*10., 2.5));\n        else         y = fract(pow(buv.x*sx*10. + buv.y*sy*10., 2.5));\n        return mix(black, white, y);\n    }\n    else\n    {\n        // render a plot of the escalator function\n        y = escalator(buv.x, 5., time);\n        //y = aaFloor(buv.x*5.)/5.;\n\n        if (abs(buv.y - y ) < dx) return white;\n        if (abs(buv.x - 0.) < dx) return blue;\n        if (abs(buv.x - 1.) < dx) return blue;\n        if (abs(buv.y - 0.) < dx) return blue;\n        if (abs(buv.y - 1.) < dx) return blue;\n        return black;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float margin = .5 * (iResolution.x - iResolution.y);\n\tvec2 uv = (fragCoord.xy - X*margin) / iResolution.yy;\n    if (uv.x >= 0.0 && uv.x <= 1.0) fragColor = vec4(Void(uv), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}