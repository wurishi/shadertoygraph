{"ver":"0.1","info":{"id":"WlSczt","date":"1595017322","viewed":225,"name":"nickak SDF Tutorial","username":"nickak","description":"SDF Tutorial, Introduction to Signed Distance Function programming","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ray marching\nconst int max_iterations = 256;\nconst float near_distance = 0.001;\nconst float far_distance = 30.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n\n\n//signed distance sphere formula\nfloat sdSphere( vec3 p, float r){\n\treturn length(p) -r;  \n}\n\n//signed distance box formula\nfloat sdBox( vec3 p, vec3 b ) {\n    \n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//distance field is the minumum of all visible objects\nfloat distanceField( vec3 p ) {\n\n    \n    //call various signed distance functions on p; the object\n\t//can be modified by operating on p, + vec3, is a translation\n    \n    float d1 = sdSphere( p+vec3(2,-2,0),  0.5 );\t//object 1\n    \n    float d = d1;\n    \n    float d2 = sdBox( p+vec3(2,2,0), vec3(0.5) );\t//object 2\n    \n    d = min(d,d2);\n    \n    float d3 = sdBox( p+vec3(-2,-2,0), vec3(0.5) );\t//object 3\n    \n    d = min(d,d3);\n\n    float d4 = sdSphere( p+vec3(-2,2,0), 0.5 );\t\t//object 4\n     \n    d = min(d,d4);\n    \n    return d;\n}\n\n//rayMarching is an attempt to locate an object at *here* where *here* = (eyePosition + dir), a RAY\n//if an object is found, return true\n//else return false\nbool rayMarching( vec3 eyePosition, vec3 dir, in float depth ) {\n    \n\tfloat t = 0.0, d = 0.0;\n    \n    for ( int i = 0; i < max_iterations; i++ ) {\n        \n        vec3 v = eyePosition + dir * t; \n        d = distanceField( v );\n        \n        if ( d < near_distance ) {\n            break;\n        }\n       \n        t += min( abs(d), 0.1 );\n        \n        if ( t > depth ) {\n            break;\n        }\n    }\n    \n    //object does not exist or was not found here\n    if ( d >= near_distance ) {\n        return false;\n    }\n\n    //object was found here\n    return true;\n}\n\n//fov = field of view\nvec3 viewspaceRayDir( float fov, vec2 screenSize, vec2 fragCoord ) {\n    \n\tvec2 xy = fragCoord - screenSize * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = screenSize.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 lookAtMatrix(vec3 eye, vec3 lookAt, vec3 up) {\n    \n\tvec3 f = normalize(lookAt - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat3(\n\t\tvec3(s),\n\t\tvec3(u),\n\t\tvec3(-f)\n\t);\n}\n\nstruct Camera {\n\tvec3 eyePosition;\n    vec3 lookAtPosition;\n    vec3 shaderRay;\n};\n\nCamera setupCamera( vec3 shaderRay ){\n    \n    Camera camera;\n    \n    float posx =  sin(iTime);\n    \n\tcamera.eyePosition = vec3( posx,5, 7);\n    \n\tcamera.lookAtPosition = vec3(0,0,0);\n    \n    camera.shaderRay  = lookAtMatrix(camera.eyePosition, camera.lookAtPosition, vec3(0,1,0) ) * shaderRay;\n\n\treturn camera;\n}\n\nvec4 march(Camera camera){\n    \n    float depth = far_distance;\n\tif ( rayMarching( camera.eyePosition, camera.shaderRay, depth ) ) {\n        return vec4(1); //white\n\t}\n\t\n\treturn vec4(0);\t//black    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //shaderRay is the ray into the scene for the current fragment pixel in the image.\n    //there are iResolution.x * y number of these and all are calculated simultaneously via gfxcard.\n\tvec3 shaderRay = viewspaceRayDir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\tCamera camera = setupCamera( shaderRay );\n\t\n    fragColor = march(camera);\n}","name":"Image","description":"","type":"image"}]}