{"ver":"0.1","info":{"id":"MsK3Rm","date":"1453848733","viewed":336,"name":"Crowded swirls","username":"ddsol","description":"It's just a swarm of swirls.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["swirls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define SMOOTH\n#define PI 3.1415926535897932384626433832795\n#define COUNT 100\n#define STEPS 9.\n#define BLUR .1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Web rgba format colors\n    //vec4 color1 = vec4(120,60,0,0.8) / vec4(255,255,255,1.0);\n    //float radius1 = 0.5+sin(iTime)*0.2; //Radius is relative to maxRadius\n    \n    //vec4 color2 = vec4(0,120,30, 1.0) / vec4(255,255,255,1);\n    //float radius2 = 0.85+sin(iTime*0.77)*0.15; //Radius is relative to maxRadius\n    \n    //make input colors  (sRGB) linear\n    float gamma = 2.2;\n    //color1.rgb = pow(color1.rgb, vec3(gamma));\n    //color2.rgb = pow(color2.rgb, vec3(gamma));\n\n    vec4 col = vec4(0);\n    \n    float maxRadius = min(iResolution.x, iResolution.y) * 0.5; //Radius of the circle in pixels\n    maxRadius *= .2;\n    float smoothing = 1.0/maxRadius; //Size of smoothing area relative to (double) unit circle\n\n    smoothing *= (1. + BLUR);\n        \n    for(int i=0;i<COUNT;i++){\n        vec4 color = vec4(texture(iChannel0, vec2(0.5, float(i)*1.7657/float(COUNT))).rgb,1.0);\n        vec3 rnd = texture(iChannel0, vec2(iTime/1000.0+float(i)/50.0, float(i)/float(COUNT))).rgb;\n\n        vec2 center = iResolution.xy * vec2(0.5); //Center of the circle in pixels\n        center += (rnd.xy-vec2(0.5))*iResolution.xy; //vec2(maxRadius / 4.0);\n\n        vec2 relative = fragCoord.xy - center; //Coordinate relative to center of circle in pixels\n        vec2 unit = relative / vec2(maxRadius); //Coordinate relatyive to center of circle in units -1.0 to 1.0 (double unit really).\n\n        float dist = length(unit); //Distance to center where 1 = at edge of maxRadius circle\n    \n        float spin = iTime*(2.0+mod(color.g*7.+color.b*3.+color.r*11.,1.)*7.0);\n\n        float radius2 = (0.1+abs(sin(iTime*.1+color.r*7.+color.g*11.+color.b*13.)))*.3;\n\n        if (dist<radius2+3.) {\n        \n            float ang;\n            float baseAng = atan(unit.y, unit.x)/PI*3.0+8.0+color.r*5.6789+dist*1./radius2-spin;\n\n            //Saturate the color:\n            float m=min(min(color.r,color.g),color.b);\n            //But not entirely:\n            m*=0.9;\n\n            color.r-=m;\n            color.g-=m;\n            color.b-=m;\n\n            color.rgb/=max(max(color.r,color.g),color.b);\n            color.a *= 2.;\n\n            #ifdef SMOOTH\n\n                #define HALFSTEPS ((STEPS - 1.)/2.)\n\n                ang = 0.;\n                float smear = smoothing / float(STEPS) * 2.;\n                for(float s=-HALFSTEPS;s<=HALFSTEPS;s++) {\n                    ang += mod(baseAng+s*smear/dist,2.);\n                }\n                ang /= STEPS;\n            #else\n                ang = mod(baseAng, 2.);\n            #endif\n\n            color.a*=ang*0.5;\n            //color.a=clamp(color.a*1.3,0.,1.);\n\n            #ifdef SMOOTH\n\n                //Use smoothstep to go from inside to outside circle to do anti-aliasing\n                color.a *= smoothstep(\n                    radius2 + smoothing,\n                    radius2 - smoothing,\n                    dist\n                );\n            #else\n                if (dist>radius2) {\n                    color.a = 0.;\n                }\n\n            #endif\n            col.rgb = col.rgb * (1.0 - color.a) + color.rgb * color.a;\n            col.a = col.a * (1.0 - color.a) + color.a;\n            col = clamp(col, 0., 1.);\n        }\n    }\n    \n    //Gamma correction (prevents color fringes)\n    //Turn color back to sRGB\n    col.rgb = pow(col.rgb, vec3(1.0 / gamma));\n    fragColor = col;\n    \n    //pre-multiply rgb because shadertoy has no real transparency.\n    fragColor.rgb *=fragColor.a;\n    \n}","name":"Image","description":"","type":"image"}]}