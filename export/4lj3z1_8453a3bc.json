{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// An attempt to create DLA-like particles flying in space (sort of),\n// unfortunately it runs a little bit slow... maybe can be optimized, maybe not?\n\n// Comment this out to disable scaling animation\n//#define SCALE_ANIMATION\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat hash(in float n){ return fract(n*43758.5453); }\n\nvec4 df(vec3 p, float anim, float scale)\n{\n    vec4 src[9];\n    vec4 dst[9];\n    \n    //float anim = iTime*.125; //(sin(iDate.w)+1.0)*.4999;\n    float anim_scale = .5;\n    \n    for(int i=0; i<3; ++i) {\n    \tfloat f = float(i)*(1.0/3.0);\n        float a = f*(M_PI*2.0);\n        float ds = .4*scale;\n        vec4 s = vec4(cos(a)*ds,sin(a)*ds,0,f+float(i*21));\n        dst[i] = s;\n    }\n\n    for(int lev=0; lev<6; ++lev) {\n        // Replicate:\n        for(int k=0; k<3; ++k) {\n          vec4 s = dst[k];\n          float ds = .2*scale;\n          float sw = floor(s.w);\n          float h = hash(sw) - .5;\n          float f = fract(s.w) + anim*h*anim_scale;\n          float a = h + f*(2.0*M_PI) + sw*.31;\n          src[k] = s + vec4(cos(a)*ds,sin(a)*ds,h*ds,1);\n          a += M_PI*2.0/3.0;\n          src[k+3] = s + vec4(cos(a)*ds,sin(a)*ds,ds,3);\n          a += M_PI*2.0/3.0;\n          src[k+6] = s + vec4(cos(a)*ds,sin(a)*ds,-ds,7);\n        }\n        if (lev==5) break;\n        // Copy only 3 closest to dst (idea how to optimize this, anyone?):\n        float dmax = 0.0;\n        vec4 o = src[0];\n        for(int k=0; k<3; ++k) {\n            float dmin = 1e32;\n            for(int i=0; i<9; ++i) {\n               vec4 s = src[i];\n               vec3 dp = p.xyz - s.xyz;\n               float d = dot(dp,dp);\n               if (d > dmax && d < dmin) { o = s; dmin = d; }\n            }\n            dst[k] = o;\n            dmax = dmin;\n        }\n        scale *= .5;\n        anim_scale *= 1.5;\n    }\n    \n    float dist = 6.0;\n    vec4 minp;\n    for(int i=0; i<9; ++i) {\n        vec4 s = src[i];\n        vec3 dp = p.xyz - s.xyz;\n    \tfloat d = length(dp)-.02;\n        if (d < dist) {\n\t\t\tdist = d;\n            minp = s;\n        }\n    }\n    float d = length(p.xyz)-.2;\n    if (d < dist) {\n        dist = d;\n        minp = vec4(0);\n    }\n    minp.w = max(0.0,dist);\n    //dist = min(dist, );\n    return minp;\n}\n\nfloat voro3(vec3 p)\n{\n\tvec3 sp = p - vec3(.5,.5,.5);\n    vec3 fp = fract(sp);\n    vec3 gp = sp - fp;\n\tfloat dmin = 1e32;\n    for(int i=0; i<2; i++)\n    for(int j=0; j<2; j++)\n    for(int k=0; k<2; k++)\n    {\n       vec3 hp = gp + vec3(float(i),float(j),float(k));\n       for(int seed=1; seed<8; ++seed) {\n          float seed1 = float(seed);\n          seed1 += fract(hp.x*234.12467 + hp.y*5472.1346 + hp.z*5725.1364);\n          vec3 dp = vec3(\n              hp.x + fract(seed1*2345.127+.317),\n              hp.y + fract(seed1*6234.171+.217),\n              hp.z + fract(seed1*7133.271+.171))\n              - p;\n          dmin = min(dmin,dot(dp,dp));\n       }\n    }\n\treturn dmin;\n}\n\nvec4 trace(vec3 p, vec3 n)\n{\n    float time = iTime;\n    float anim = time*.125;\n    float scale = 4.0;\n#ifdef SCALE_ANIMATION\n    scale += exp(-time*.5)*4.0;\n    if (time>24.0) {\n        scale += log(time+1.0-24.0)*2.0;\n    }\n#endif\n\tfloat d;\n    float lit = 0.0;\n    float cen = 0.0;\n    float halo = 0.0;\n    // It's quite slow... 13 steps is already too much for my GTX 460\n    const int steps = 13;\n    vec4 minp;\n    for(int k=0; k<steps; ++k) {\n    \tminp = df(p,anim,scale);\n        d = minp.w;\n        p += d*.95*n;\n        lit += 1.0/(d + 0.15);\n        float dcen = dot(p.xyz,p.xyz);\n        cen += 1.0/dcen;\n        halo += 1.0/(max(0.0,dcen-.2) + 0.15);\n    }\n    lit *= .2/float(steps);\n    lit = pow(lit,1.5);\n    \n    halo = halo*.007;\n\n    //lit += cen*texture(iChannel0,p.xy*.2).r*.1;\n    \n    //vec4 tex = texture(iChannel0,normalize(p-minp.xyz));\n    vec4 col = vec4(lit-d*.1+halo,lit*.95+halo,.3+lit*.08+halo,1);\n    //float bkg = df(vec3(n.xy*3.0,0), 4.0);\n    float bkg = voro3(n*4.0+vec3(0,0,anim*2.0))*2.0;\n                      //vec3(sin(n.z*4.0+anim)*3.0,sin(n.x*4.0-anim)*3.0,sin(n.y*4.0+anim)*3.0));\n    float star = max(0.0,1.0-voro3(n*32.0+vec3(0,0,anim*.1))*iResolution.x);\n    bkg += star*2.0*(bkg*.5+.8);\n    vec4 bkg_col = vec4(bkg,bkg,bkg,1);\n    return mix(col,bkg_col,d*.08);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    \n    float anim = iTime*.25;\n    \n    float a = iMouse.x / iResolution.x * 2.0 + cos(anim)*.2; // - 1.0;\n    float co = cos(a);\n    float si = sin(a);\n    const float ds = 10.0;\n    vec3 p1 = vec3(-ds*si, 0, -ds*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    //fragColor = trace(p1, n2);\n    \n    \n    a = -iMouse.y / iResolution.y * 2.0 + sin(anim*(2.0/3.0))*.2;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n    fragColor = trace(p2, n3);\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4lj3z1","date":"1426938891","viewed":518,"name":"Fractal atom","username":"tomkh","description":"Based on Mlj3zz","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","distancefield","dla"],"hasliked":0,"parentid":"","parentname":""}}