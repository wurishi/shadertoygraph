{"ver":"0.1","info":{"id":"3lsyRn","date":"1591281892","viewed":113,"name":"LtL cellular automata 01","username":"martinnovy","description":"Larger than Life cellular automata\n\nforked from https://www.shadertoy.com/view/4djBzR\n\nIf my output is blank, please click into it. (I am not sure why it is so, I am a beginner.)\n\nhttps://conwaylife.com/forums/viewtopic.php?f=11&t=2933","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["life","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.shadertoy.com/view/4djBzR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Moving average is stored in green channel\n    ///float s = texture(iChannel0, uv).g;\n    float s = texture(iChannel0, uv).r;\n    \n    float v = 1.0;\n    if (s == 0.0) {\n        v = 0.0;\n    }\n    vec3 purple = vec3(86.0, 20.0, 176.0) / 255.0;\n    vec3 gold = vec3(219.0, 214.0, 92.0) / 255.0;\n\n    vec3 col = smoothstep(gold, purple, vec3(mod(s + 0.5, 1.0))) * v;\n  \tfragColor = vec4(col, 1.0); \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://www.csun.edu/~kme52026/invariant.html\n\nstruct LTLRule {\n    float r;\n    float b1;\n    float b2;\n    float d1;\n    float d2;\n};\n    \n/**\n * Renders initial state on startup or mouse click.\n *\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n\t//return vec4(color, 1.0 - t/2.0);\n\t//return vec4(color, 1.0 - t/3.0);\n\t//return vec4(color, 1.0 - t/4.0);\n\t/////return vec4(color, 1.0 - t/14.0);\n    /////return vec4(color, 1.0 - t/8.0);\n    /////return vec4(color, 1.0 - t/6.0);\n    //return vec4(color, 1.0 - t/5.0);\n    //////return vec4(color, t/5.0);\n\t//return vec4(color, 0.75+t/4.0);\n    //return vec4(color, 1.0-(t/4.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //////////////// This was LTL rule 1,3,3,1,8 ///probably\n    // I adjusted the boundaries to be tolerant of floating-point imprecision and\n    // interpolation issues, neighborhood totals are not guaranteed to be exact.\n    //const LTLRule rule = LTLRule(1.0, 2.9, 3.1, 0.9, 8.9);\n    \n    //const LTLRule rule = LTLRule(1.0, 2.9, 3.1, 0.9, 7.9);\n    ////const LTLRule rule = LTLRule(1.0, 2.9, 3.1, 0.9, 3.9);\n\n    //const LTLRule rule = LTLRule(1.0, 2.9, 4.1, 0.9, 7.9);\n    //const LTLRule rule = LTLRule(1.0, 2.9, 3.1, 2.9, 4.5);\n\n    //const LTLRule rule = LTLRule(1.0, 2.9, 4.1, 0.9, 7.9);\n    //const LTLRule rule = LTLRule(2.0, 6.9, 8.1, 5.9, 10.5);\n\n    //const LTLRule rule = LTLRule(1.0, 2.5, 3.5, 1.5, 5.5);\n    //const LTLRule rule = LTLRule(1.0, 2.5, 3.5, 2.5, 5.5);\n    //const LTLRule rule = LTLRule(1.0, 1.5, 3.5, 2.5, 5.5);\n    //const LTLRule rule = LTLRule(1.0, 0.5, 4.5, 2.5, 5.5);\n    //const LTLRule rule = LTLRule(1.0, 0.5, 3.5, 2.5, 5.5);\n\n    //const LTLRule rule = LTLRule(1.0, 2.5, 3.5, 2.5, 4.5);\n    //const LTLRule rule = LTLRule(2.0, 6.5, 8.5, 5.5, 10.5);\n    //const LTLRule rule = LTLRule(2.0, 6.5, 11.5, 6.5, 10.5);\n    //const LTLRule rule = LTLRule(2.0, 6.5, 9.5, 6.5, 10.5);\n    //const LTLRule rule = LTLRule(3.0, 11.5, 14.5, 11.5, 19.5);\n    //const LTLRule rule = LTLRule(3.0, 11.5, 15.5, 11.5, 19.5);\n    //const LTLRule rule = LTLRule(3.0, 11.5, 16.5, 11.5, 19.5);\n    const LTLRule rule = LTLRule(3.0, 13.5, 19.5, 13.5, 23.5);\n\n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float total = 0.0;\n    for (float dx = -rule.r; dx <= rule.r; dx++) {\n      for (float dy = -rule.r; dy <= rule.r; dy++) {\n        vec2 txy = mod((fragCoord.xy + vec2(dx,dy)) / iResolution.xy, 1.0);\n        float val = texture(iChannel0, txy).x; \n        total += val;\n      }\n    }\n\n   vec2 stateAndAvg = texture(iChannel0, uv).xy;\n   float s = stateAndAvg.x;\n   float c = s;\n   if (s == 0.0) {\n       if (total >= rule.b1 && total <= rule.b2) {\n           c = 1.0;\n       }\n   } else {\n       if (total < rule.d1 || total > rule.d2) {\n           c = 0.0;\n       }\n   }\n\n   if (iFrame < 20 || iMouse.z > 0.) {\n\t   vec2 center = iResolution.xy * 0.5;\n       vec2 mouse = iMouse.xy;\n       float radius = 30.0;\n       if (iMouse.z > 0.) {\n           radius = max(distance(mouse, center), radius);\n       }\n       // Background layer\n\t   vec4 layer1 = vec4(1.0, 1.0, 1.0, 1.0);\n\t   // Circle\n       vec4 layer2 = circle(fragCoord.xy, center, radius, vec3(0.0, 0.0, 0.0));\n       ////////vec4 layer2 = circle(fragCoord.xy, center, radius, vec3(0.1, 1.0, 0.0));\n\t   \n       // Blend\n\t   ///fragColor = mix(layer1, layer2, layer2.a);\n       \n       ///\n       vec2 txy2 = mod(   fragCoord.xy  / iResolution.xy, 1.0);\n       fragColor =     texture(iChannel1, txy2);\n       \n       \n   } else {\n      fragColor = vec4(c, mod(stateAndAvg.y + (c / 196.0), 1.0), 0.0, 1.0);\n   }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}