{"ver":"0.1","info":{"id":"WlKSzt","date":"1583385079","viewed":117,"name":"Outdoor Lighting","username":"JentGent","description":"Raymarcher.\nSoft shadows + blue ambient light + yellow sunlight = daylight!\n\nI also implemented simple reflection and texturing (with value noise, as you can probably tell).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","lighting","shading","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nvec3 c = vec3(1., 1., 1.);\n\nconst float PI = 3.14159265358979323;\n\nfloat random(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 iteration) {\n    vec2 i = floor(iteration);\n    vec2 f = fract(iteration);\n    float a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    vec2 u = f * f * (3. - 2. * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat deSphere(vec3 from, vec3 center, float radius) {\n    return length(center - from) - radius;\n}\nfloat deTorus(vec3 from, vec3 center, float radius, float thickness) {\n    return length(vec2(length(center.xz - from.xz) - radius, center.y - from.y)) - thickness;\n}\nfloat deCuboid(vec3 from, vec3 center, vec3 dimensions) {\n    vec3 section = abs(center - from) - dimensions;\n    return length(max(section, 0.)) + min(max(section.x, max(section.y, section.z)), 0.);\n}\nfloat deUncappedCylinder(vec3 from, vec3 center, float radius) {\n    return length(center.yz - from.yz) - radius;\n}\nfloat deCappedCylinder(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2., center.x + capAt / 2.), from.yz)) - radius;\n}\nfloat deCapsule(vec3 from, vec3 center, float radius, float capAt) {\n    return length(vec3(from.x, center.yz) - vec3(clamp(from.x, center.x - capAt / 2., center.x + capAt / 2.), from.yz)) - radius;\n}\nfloat dePlane(vec3 from, vec3 center, vec3 normal) {\n    return dot(center - from, normalize(normal));\n}\n\nvec3 normalSphere(vec3 v, vec3 center) {\n    return normalize(center - v);\n}\n\nfloat deRound(float pd, float radius) {\n    float de = pd;\n    return de - radius;\n}\n\nfloat boolUnion(float pd, float pd2) {\n    return min(pd, pd2);\n}\nfloat boolSubtraction(float pd, float pd2) {\n    return max(pd, -pd2);\n}\nfloat boolIntersection(float pd, float pd2) {\n    return max(pd, pd2);\n}\n\nfloat smoothBoolUnion(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 + (pd - pd2) / smoothness / 2., 0., 1.);\n    return mix(pd, pd2, level) - smoothness * level * (1. - level);\n}\nfloat smoothBoolSubtraction(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd + pd2) / smoothness / 2., 0., 1. );\n    return mix(pd2, -pd, level) + smoothness * level * (1. - level);\n}\nfloat smoothBoolIntersection(float pd, float pd2, float smoothness) {\n    float level = clamp(0.5 - (pd - pd2) / smoothness / 2., 0., 1.);\n    return mix(pd, pd2, level) + smoothness * level * (1. - level);\n}\n\nfloat displace(float pd, vec3 from, vec3 dir, float size, float strength) {\n    vec3 p = from + dir * pd;\n    float d2 = sin(size * p.x) * sin(size * p.y) * sin(size * p.z) * strength;\n    return pd + d2;\n}\n\nvec3 rot(vec3 inp, float xRot, float yRot, float zRot, vec3 anchor) {\n    inp -= anchor;\n    mat2 rot = mat2(\n        cos(xRot), -sin(xRot),\n        sin(xRot), cos(xRot)\n    );\n    inp.yz *= rot;\n    rot = mat2(\n        cos(yRot), -sin(yRot),\n        sin(yRot), cos(yRot)\n    );\n    inp.xz *= rot;\n    rot = mat2(\n        cos(zRot), -sin(zRot),\n        sin(zRot), cos(zRot)\n    );\n    inp.xy *= rot;\n    inp += anchor;\n    return inp;\n}\n\nvec3 sun = normalize(vec3(3., -2., 2.));\nvec3 point = vec3(0., 0., 0.);\n\nvec3 cam = vec3(10., 8., -10.);\nfloat FOV = 0.5;\n\nuniform vec2 cursor;\n\nvec3 color = vec3(1.);\nfloat refl = 0.0;\nvec3 reflColor = vec3(1.);\n\nfloat scene(vec3 from, bool outColor, bool outRefl) {\n    \n    float trunkde = deCapsule(rot(from, 0., 0., PI/2., vec3(0., 5., 0.)), vec3(0., 5., 0.), 1.5, 10.);\n    float logde = deCuboid(from, vec3(0.), vec3(10., 1., 1.));\n    float groundde = dePlane(from, vec3(0., -1., 0.), vec3(0., -1., 0.));\n    float slopede = dePlane(from, vec3(0., 0., 7.), vec3(0., -1., 1.));\n    float spherede = mix(deSphere(from, vec3(-4., 1., -6.), 3.), deTorus(from, vec3(-4., 1., -6.), 2., 1.), 0.5 + cos(iTime) * 0.5);\n    \n    float de = min(trunkde, min(logde, min(groundde, min(spherede, slopede))));\n    vec3 ret = vec3(0.);\n    if(outColor || outRefl) {\n        if(de == trunkde) {\n            ret = vec3(0.7, 0.6, 0.);\n        }\n        if(de == logde) {\n            ret = vec3(0.5, 0.4, 0.);\n        }\n        if(de == groundde) {\n            ret = vec3(0., noise(from.xz * 0.5 + vec2(1.)) * 0.5 + 0.5, 0.);\n            refl = 0.005;\n        }\n        if(de == slopede) {\n            ret = vec3(noise(from.xz * 0.5), noise(from.xz * 0.5 + vec2(1.)), noise(from.xz * 0.5 + vec2(2.)));\n        }\n        if(de == spherede) {\n            ret = vec3(1.);\n        }\n        if(outColor) {\n            color = ret;\n        }\n        if(outRefl) {\n            reflColor = ret;\n        }\n    }\n    return de;\n    \n}\n\nvec3 getNormal(vec3 from) {\n    vec2 slopeOther = vec2(0.01, -0.01); \n    return normalize(\n        slopeOther.xxx * scene(from + slopeOther.xxx, false, false) +\n        slopeOther.xyy * scene(from + slopeOther.xyy, false, false) +\n        slopeOther.yyx * scene(from + slopeOther.yyx, false, false) + \n        slopeOther.yxy * scene(from + slopeOther.yxy, false, false)\n    );\n}\nvec3 reflNormal(vec3 dir, vec3 normal) {\n    return dir - normal * dot(dir, normal) * 2.;\n}\n\nvec3 render(vec3 from, vec3 dir) {\n    vec3 at = from;\n    float closest = 10000.;\n    float totalDE = 0.;\n    for(int iter = 0; iter < 200; iter += 1) {\n        if(totalDE > 100.) {\n            break;\n        }\n        color = vec3(1.);\n        refl = 0.0;\n        float de = scene(at, true, false);\n        at += dir * de;\n        totalDE += de;\n        if(de < closest) {\n            closest = de;\n        }\n        if(de < 0.01) {\n            vec3 normal = getNormal(at);\n            if(refl > 0.0) {\n                vec3 reflDir = reflNormal(dir, normal);\n                float bias = 0.04;\n                vec3 atRefl = at + normal * bias;\n                float reflDE = 0.;\n                for(int iter = 0; iter < 100; iter += 1) {\n                    if(reflDE > 400.) {\n                        break;\n                    }\n                    float deRefl = scene(atRefl, false, true);\n                    atRefl += reflDir * deRefl;\n                    if(deRefl < 0.03) {\n                        vec3 normalRefl = getNormal(atRefl);\n                        reflColor += vec3(0., 0.2, 0.3);\n                        color = color * (1. - refl) + clamp(reflColor * (clamp(dot(normalRefl, -sun), 0., 1.) * 0.7 + 0.3), 0., 1.) * refl;\n                    }\n                }\n            }\n            \n            float shade = 1.;\n            float bias = 0.04;\n            vec3 atShadow = at + normal * bias;\n            float shadowDE = 0.;\n            float penumbra = 0.1;\n            for(int iter = 0; iter < 100; iter += 1) {\n                if(shadowDE > 200.) {\n                    break;\n                }\n                float deShadow = scene(atShadow, false, false);\n                if(deShadow < 0.03) {\n                    shade = 0.;\n                    break;\n                }\n                shadowDE += deShadow;\n                atShadow += -sun * deShadow;\n                \n                float y = deShadow * deShadow / (2.1 * penumbra);\n                float d = sqrt(deShadow * deShadow - y * y);\n                shade = min(shade, 5. * d / max(0., shadowDE - y));\n                penumbra = deShadow;\n            }\n            shade = shade*shade*(3. - 2.*shade);\n            shade = max(shade, 0.);\n            shade *= clamp(dot(normal, -sun), 0., 1.);\n            float sunShade = shade;\n            color += vec3(0., 0.2, 0.3);\n            shade = shade * 0.7 + 0.3;\n            vec3 sunRGB = vec3(0.3, 0.29, 0.0);\n            return clamp(color * shade + sunRGB * sunShade, 0., 1.);\n        }\n    }\n    return vec3(0.3, 0.8, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    sun = rot(sun, 0., iTime * 0.5, 0., vec3(0.));\n    \n    float yaw = 0.8;\n    float pitch = 0.4;\n    \n    float xMap = fragCoord.x / iResolution.x - 0.5;\n    float yMap = fragCoord.y / iResolution.y - 0.5;\n    vec3 dir = normalize(vec3(xMap, yMap, FOV));\n    vec3 rotd = rot(dir, pitch, 0., 0., vec3(0.));\n    rotd = rot(rotd, 0., yaw, 0., vec3(0.));\n    dir = rotd;\n    \n    c = render(cam, dir);\n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}