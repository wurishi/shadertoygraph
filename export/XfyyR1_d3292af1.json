{"ver":"0.1","info":{"id":"XfyyR1","date":"1731447006","viewed":28,"name":"many uv transformations","username":"dvrbs","description":"uv transformations","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["uvs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 waveDistortion(vec2 uv, float time) {\n    uv.y += sin(uv.x * 10.0 + time) * 0.1;\n    uv.x += cos(uv.y * 10.0 + time) * 0.1;\n    return uv;\n}\n\nvec2 swirl(vec2 uv, vec2 center, float strength) {\n    vec2 offset = uv - center;\n    float angle = strength * length(offset);\n    float s = sin(angle);\n    float c = cos(angle);\n    offset = mat2(c, -s, s, c) * offset;\n    return offset + center;\n}\n\nvec2 hexTile(vec2 uv) {\n    vec2 q = vec2(uv.x, uv.y * 0.86602540378); // Scale Y by sqrt(3)/2\n    q = mod(q, 1.0) - 0.5;\n    return q;\n}\n\nvec2 circularZoom(vec2 uv, vec2 center, float zoom) {\n    float dist = length(uv - center);\n    float factor = exp(-dist * zoom);\n    return mix(center, uv, factor);\n}\n\nvec2 polarCoords(vec2 uv) {\n    float angle = atan(uv.y - 0.5, uv.x - 0.5);\n    float radius = length(uv - vec2(0.5));\n    return vec2(angle / (2.0 * 3.14159265359) + 0.5, radius);\n}\n\nvec2 rotatingSpiral(vec2 uv, float time, float frequency) {\n    float angle = atan(uv.y - 0.5, uv.x - 0.5) + time * frequency;\n    float radius = length(uv - vec2(0.5));\n    return vec2(cos(angle), sin(angle)) * radius + 0.5;\n}\n\nvec2 checkerboard(vec2 uv, float scale) {\n    uv *= scale;\n    uv = floor(uv) + mod(floor(uv.x) + floor(uv.y), 2.0) * 0.5;\n    return fract(uv / scale);\n}\n\nvec2 sineRipple(vec2 uv, vec2 frequency, float time, float amplitude) {\n    uv.x += sin(uv.y * frequency.y + time) * amplitude;\n    uv.y += sin(uv.x * frequency.x + time) * amplitude;\n    return uv;\n}\n\nvec2 pinchBulge(vec2 uv, vec2 center, float radius, float strength) {\n    vec2 offset = uv - center;\n    float dist = length(offset);\n    float factor = pow(dist / radius, strength);\n    return center + offset * factor;\n}\n\nvec2 kaleidoscope(vec2 uv, vec2 center, int mirrors) {\n    vec2 offset = uv - center;\n    float angle = atan(offset.y, offset.x);\n    float radius = length(offset);\n    angle = mod(angle, 2.0 * 3.14159265359 / float(mirrors));\n    return vec2(cos(angle), sin(angle)) * radius + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = waveDistortion(uv,iTime);\n    uv = swirl(uv,vec2(.5,.5),sin(iTime));\n    uv = hexTile(uv);\n    uv = circularZoom(uv,vec2(.5,.5),sin(iTime));\n    uv = polarCoords(uv);\n    uv = rotatingSpiral(uv,iTime,sin(iTime));\n    uv = checkerboard(uv, sin(iTime));\n    uv = sineRipple(uv, vec2(iTime),iTime, 1.0);\n    uv = pinchBulge(uv, vec2(.5,.5), 1.0,iTime);\n    uv = kaleidoscope(uv, vec2(.5,.5), int(iTime));\n    \n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n    //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}