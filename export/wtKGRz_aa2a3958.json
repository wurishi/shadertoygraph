{"ver":"0.1","info":{"id":"wtKGRz","date":"1612190099","viewed":49,"name":"24626.0","username":"jorge2017a1","description":"24626.0","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["246260"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define hit_background -1\n#define hit_sphere 1\n#define hit_plane 2\n#define hit_light 10\n\n#define pi 3.1415\n#define eps 0.0005\n#define INF 1e5\n\n#define max_bounces 4\n\n\n\n//========================================================================================================\n\n\nstruct Material {\n\tvec3 color;\t\t\n\tfloat refl;\t\t// reflection coefficient (0 - matt, 1 - mirror)\n};\n\n// Information about the intersection point of ray and any scene objects\nstruct Hit \n{\n\tint type;\t\t// object type\n\tvec3 pos;\t\t// point of intersection\n\tvec3 normal;\t\t// normal to object at intersection point\n\tMaterial material;\t// material of this object\n};\n\n\nstruct Sphere \n{\n\tvec3 crd;\t\t// coordinates\n\tfloat r;\t\t// radius\n\tMaterial material;\t// material\n};\n\n\t\n\n//========================================================================================================\n\n// field of view in degrees\nfloat fov = 90.0;\t\t\t\n\n// Objects in the scene\nconst int spheres_count = 2;\nconst int lights_count = 2;\nSphere spheres[spheres_count];\nSphere lights[lights_count];\n\nvoid setScene() \n{\n\tspheres[0] = Sphere(vec3(0.0, 1.0, 6.0 * cos(iTime)), 1.0, Material(vec3(0.8, 0.2, 0.2), 0.4));\n\tspheres[1] = Sphere(vec3(2.0, 1.0, 6.0 * sin(iTime)), 1.0, Material(vec3(0.2, 0.2, 0.8), 0.4));\n\tlights[0] = Sphere(vec3(3.0, 3.0, 3.0), 0.1, Material(vec3(1.0, 1.0, 1.0), 0.0));\n\tlights[1] = Sphere(vec3(-3.0, 3.0, 4.0), 0.1, Material(vec3(1.0, 1.0, 1.0), 0.0));\n\t\n\t// Move the light source\n\tlights[0].crd.xz = vec2(3.0 * cos(iTime), 3.0 * sin(iTime));\n\tlights[1].crd.y = 4.0 * abs(cos(iTime));\n}\n\n//========================================================================================================\n\nfloat intersectSphere(in vec3 ro, in vec3 rd, in Sphere sph) \n{\t\n\tvec3 oc = ro - sph.crd;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.r*sph.r;\n\tfloat d = b*b - c;\n\tif (d < 0.0) return INF;\n\tfloat t = -b - sqrt(d);\n\tif (t < 0.0) return INF;\n\treturn t;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd) \n{\n\t// Plane Equation: y = 0 = ro.y + t*rd.y\n\tfloat t = -ro.y/rd.y;\n\tif (t < 0.0)\n\t\treturn INF;\n\treturn t;\n}\n// Normal to the Plane\nvec3 nPlane(in vec3 pos)\n{\n\treturn vec3(0.0, 1.0, 0.0);\t\n}\n\n\n\nHit intersect(vec3 ro, vec3 rd) \n{\n\t\n\tfloat t = 150.0;\t\n\t\n\t// Info about the intersection\n\tint hit_type = hit_background;\t\t// type of intersection\n\tvec3 pos = vec3(0.0);\t\t\t// intersection point\n\tvec3 normal = vec3(0.0);\t\t// Normal at intersection point\n\tMaterial material = Material(vec3(0.5, 0.6, 0.7), 0.0);\n\t\n\t// Check intersections with spheres\n\tfor (int i = 0; i < spheres_count; i++) \n\t{\n\t\tfloat tmp = intersectSphere(ro, rd, spheres[i]);\n\t\tif (tmp < t) \n\t\t{\n\t\t\tt = tmp;\n\t\t\thit_type = hit_sphere;\n\t\t\tmaterial = spheres[i].material;\n\t\t\tpos = ro + rd*t;\n\t\t\tnormal = normalize(pos - spheres[i].crd);\n\t\t}\n\t}\n\t\n\t// Check intersection with Plane\n\tfloat tpla = iPlane(ro, rd);\n\tif (tpla < t)\n\t{\n\t\tt = tpla;\n\t\thit_type = hit_plane;\n\t\tmaterial.color = vec3(0.4, 0.4, 0.4);\n\t\tmaterial.refl = 0.2;\n\t\tpos = ro + rd*t;\n\t\tnormal = nPlane(pos);\n\t}\n\t\n\t// Check intersection with Light source\n\tfor (int i = 0; i < lights_count; i++)\n\t{\n\t\tfloat tmp = intersectSphere(ro, rd, lights[i]);\n\t\tif (tmp < t) \n\t\t{\n\t\t\tt = tmp;\n\t\t\thit_type = hit_light;\n\t\t\tmaterial = lights[i].material;\n\t\t\tpos = ro + rd*t;\n\t\t\tnormal = normalize(pos - lights[i].crd);\t\t\t\n\t\t}\n\t}\n\n\t// move the intersection point toward the camera a little, so the rays will not be blocked\n\tpos -= rd * eps;\n\t\n\treturn Hit(hit_type, pos, normal, material);\t\t\n}\n\nvec3 determineColor(Hit hit) \n{\n\t// if ray does not intersect scene object, no need to calculate further lighting\n\tif (hit.type == hit_background || hit.type == hit_light)\n\t\treturn hit.material.color;\n\t\n\tvec3 diffuse = vec3(0.0);\n\tvec3 ambient = vec3(0.2);\n\t\n\tfor (int i = 0; i < lights_count; i++) \n\t{\t\n\t\t// emit ray from this light source\n\t\tvec3 ro = hit.pos; \n\t\tvec3 rd = normalize(lights[i].crd - hit.pos);\n\t\t\n\t\tHit lightHit = intersect(ro, rd);\n\t\t\n\t\t// if the point light source is visible, add the diffuse component of this source\t\t\n\t\tif (lightHit.type == hit_light) \n\t\t\tdiffuse += (max(0.0, dot(rd, hit.normal))) * lightHit.material.color;\n\t}\n\t\n\tvec3 color = hit.material.color * clamp((diffuse + ambient), 0.0, 1.0);\n\t\n\treturn color;\n}\n\n\n// Ray tracing formula -> color = mix(color, reflColor, refl);\nvec3 traceRayX(vec3 ro, vec3 rd) \n{\t\t\n\tvec3 colors[max_bounces];\n\tfloat refls[max_bounces];\n\t\n\tfor (int i = 0; i < max_bounces; i++) {\n\t\tHit hit = intersect(ro, rd);\n\t\tcolors[i] = determineColor(hit);\n\t\trefls[i] = hit.material.refl;\n\t\t\n\t\tif (hit.type == hit_background || hit.type == hit_light)\n\t\t\tbreak;\n\t\t\n\t\tro = hit.pos;\n\t\trd = reflect(rd, hit.normal);\n\t}\n\t\n\tvec3 color = colors[max_bounces - 1];\n\t\n\tfor (int j = max_bounces - 2; j >= 0; j--) {\n\t\tcolor = mix(colors[j], color, refls[j]);\n\t}\n\treturn color;\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Set the scene objects\n\tsetScene();\n\t\n\t// Calculate the current pixel coordinates with the aspect ratio of the resolution\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) / vec2(1.0, iResolution.x / iResolution.y);\n\t\n\t// kFov > 0\n\tfloat kFov = 1.0 / tan(radians(fov / 2.0));\t\t\n\t\t\n\t// generate ray from the origin ro in the direction of rd\n\tvec3 ro = vec3 (0.0, 1.0, 9.0);\n\tvec3 rd = normalize(vec3 (uv, -kFov));\n\t\t\n\t// Ray tracing\n\tvec3 col = traceRayX(ro, rd);\n\t\n\tfragColor = vec4(col, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}