{"ver":"0.1","info":{"id":"wsyXzz","date":"1573531820","viewed":174,"name":"blue spheres and stuff","username":"cmarangu","description":"[url]https://www.youtube.com/watch?v=7pucdUfDhPc[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// /*\n// Current code for: blue spheres and stuff\n// Tags: 3d\n// Created: 2019 11/13\n// moved over from: https://www.shadertoy.com/view/tsGXzw\n// Description: slight modifications of my \"recursive reflections!\" https://www.shadertoy.com/view/wsyXzz\n\n// i know more\nconst float PI = 3.141592653589793238;\n\nconst vec3 suncol = vec3(1., 1., 1.);\n\nvec3 hadamard (vec3 a, vec3 b) {\n    return vec3(a.x*b.x, a.y*b.y, a.z*b.z);\n}\n\nfloat SDFplane (vec3 p) {\n\treturn p.y+2.+sin((p.x+p.z+iTime)*PI*2./4.)/4.;\n}\n\nfloat SDFsphere (vec3 p) {\n    float PH = 6.;\n    p = vec3(mod(p.x, 10.)-5., p.y+sin(floor(p.x/10.)*2.+iTime/4.*PI*2.), mod(p.z, PH*2.)-PH);\n    float SDFp = length(p)-2.;\n    return SDFp;\n}\n\nfloat SDF (vec3 p) {\n    float SDFp = 1e20;\n    SDFp = min(SDFp, SDFplane(p));\n    SDFp = min(SDFp, SDFsphere(p));\n    return SDFp;\n}\n\nvec3 dSDF (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nfloat idSDF (vec3 p) {\n    float SDFspherep = SDFsphere(p);\n    float SDFplanep = SDFplane(p);\n    if (SDFspherep < SDFplanep) {\n        return 1.;\n    }\n\treturn 0.;\n}\n\nfloat rxindex (vec3 p) {\n    float idSDFp = idSDF(p);\n    if (idSDFp == 0.) {\n        return (.5+.5*sin((p.x-p.z)*PI/6.))*1.+0.;\n    }\n    if (idSDFp == 1.) {\n        return .3;\n    }\n}\n\nvec3 sund () {\n    return normalize(vec3(cos(iTime*PI*2./4.), 1., sin(iTime*PI*2./4.) ));\n}\n\nvec3 TEX (vec3 p, vec3 d) {\n    vec3 col = vec3(1., 0., 0.);\n    vec3 dSDFp = dSDF(p);\n    float idSDFp = idSDF(p);\n    float czk = mod(floor(p.x)+floor(p.y)+floor(p.z), 2.);\n    if (idSDFp == 0.) {\n        czk = mod(floor(p.x)+floor(p.z), 2.);\n    \t// czk = .5+.3*czk;\n        col = vec3(0., .7, .7)*czk;\n    }\n    if (idSDFp == 1.) {\n        czk = 1.;\n        col = vec3(0., .7, .7)*czk;\n    }\n    vec3 lighting = vec3(1., 1., 1.);\n    // diffuse lighting\n    float ang = clamp(dot(sund(), dSDFp)/2.+1., 0., 1.);\n    ang = (dot(sund(), dSDFp)+1.)/2.;\n    // ang = clamp(dot(sund(), dSDFp), 0., 1.);\n   \tlighting = lighting*ang;\n    // ambient lighting\n    lighting = .3+lighting*.7;\n    // u cant have red light from a blue sun\n    col = hadamard(col, hadamard(lighting, suncol));\n    return col;\n}\n\nvec3 bg (vec3 d) {\n    vec3 col = vec3(0., 0., 100./255.);\n    col += suncol*pow( clamp(dot(sund(), d), 0., 1.),40. );\n    col = clamp(col, 0., 1.);\n    return col;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float rxcount = 0.;\n    float shiny = 1.;\n    vec3 finalcol = vec3(0., 0., 0.);\n    float distfromcam = 0.;\n    for (int i=0; i<200; ++i) {\n        float SDFp = SDF(p);\n        if (SDFp < 1e-2) {\n            p = p+d*SDFp*.995;\n            vec3 TEXpd = TEX(p, d);\n            float rxindexp = rxindex(p);\n            if (rxindexp == 0. || rxcount > 4.) {\n                // hits solid object, final color determined\n                finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n                return finalcol;\n            }\n            if (rxcount > 3.) {\n                // waaaay to many reflections reflect background col\n                break;\n            }\n            finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n            shiny = shiny*rxindexp;\n            d = reflect(d, dSDF(p));\n            p = p+d*.02;\n            ++rxcount;\n        }\n        float DE = SDFp;\n        if (0. < DE && DE < 10.) {\n            DE *= .7;\n        }\n        p = p+d*DE;\n        distfromcam += DE;\n        if (distfromcam > 155.) {\n            break;\n        }\n    }\n    // diverges waaaay out into the sky. reflect sky color\n    if (rxcount > 0.) {\n        return finalcol+bg(d)*shiny;\n    }\n    return bg(d);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) { maus.x = iResolution.x/2.; }\n    if (maus.y == 0.) { maus.y = iResolution.y/2.; }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n    float dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iResolution.x*10.+0., -PI/4., PI/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    float PI = PI;\n    vec3 retina = march(vec3(cos(iTime/4.*PI*2./2.)*3.-5., 0., -7.+mod(iTime, 4.)/4.*2.*6.), dir1);\n    fragColor = vec4(retina, 1.);\n}\n\n/*\n// Old code for: \"recursive reflections!\"\n// Tags: raymarching, recursive, reflections\n// Created: 2019 11/12\n// Description: Wow that looks awesome. I accomplished\n// what I was trying to do (recursive reflections where\n// you do cuurentColor*.7+reflectedStuff*.3 etc.) but as it\n// turns out, what I was trying to code wasn't the effect I\n// wanted to create; *tinted* reflectios like gold.\nconst vec3 suncol = vec3(1., 1., 1.);\n\nvec3 hadamard (vec3 a, vec3 b) {\n    return vec3(a.x*b.x, a.y*b.y, a.z*b.z);\n}\n\nfloat SDFplane (vec3 p) {\n\treturn p.y+2.;\n}\n\nfloat SDFsphere (vec3 p) {\n    float PH = 6.;\n    p = vec3(mod(p.x, 10.)-5., p.y, mod(p.z, PH*2.)-PH);\n    float SDFp = length(p)-2.;\n    return SDFp;\n}\n\nfloat SDF (vec3 p) {\n    float SDFp = 1e20;\n    SDFp = min(SDFp, SDFplane(p));\n    SDFp = min(SDFp, SDFsphere(p));\n    return SDFp;\n}\n\nvec3 dSDF (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nfloat idSDF (vec3 p) {\n    float SDFspherep = SDFsphere(p);\n    float SDFplanep = SDFplane(p);\n    if (SDFspherep < SDFplanep) {\n        return 1.;\n    }\n\treturn 0.;\n}\n\nfloat rxindex (vec3 p) {\n    float idSDFp = idSDF(p);\n    if (idSDFp == 0.) {\n        return .5+.5*sin((p.x+p.z)*3.141592/6.);\n    }\n    if (idSDFp == 1.) {\n        return .3;\n    }\n}\n\nvec3 sund () {\n    return normalize(vec3(cos(iTime), 1., sin(iTime) ));\n}\n\nvec3 TEX (vec3 p, vec3 d) {\n    vec3 col = vec3(1., 0., 0.);\n    vec3 dSDFp = dSDF(p);\n    float idSDFp = idSDF(p);\n    float czk = mod(floor(p.x)+floor(p.y)+floor(p.z), 2.);\n    if (idSDFp == 0.) {\n        col = vec3(0., .7, .7)*czk;\n    }\n    if (idSDFp == 1.) {\n        col = vec3(0., .7, .7)*czk;\n    }\n    vec3 lighting = vec3(1., 1., 1.);\n    // diffuse lighting\n    float ang = clamp(dot(sund(), dSDFp)/2.+1., 0., 1.);\n    ang = (dot(sund(), dSDFp)+1.)/2.;\n    // ang = clamp(dot(sund(), dSDFp), 0., 1.);\n   \tlighting = lighting*ang;\n    // ambient lighting\n    lighting = .3+lighting*.7;\n    // u cant have red light from a blue sun\n    col = hadamard(col, hadamard(lighting, suncol));\n    return col;\n}\n\nvec3 bg (vec3 d) {\n    vec3 col = vec3(0., 0., 100./255.);\n    col += suncol*pow( clamp(dot(sund(), d), 0., 1.),40. );\n    col = clamp(col, 0., 1.);\n    return col;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float rxcount = 0.;\n    float shiny = 1.;\n    vec3 finalcol = vec3(0., 0., 0.);\n    for (int i=0; i<100; ++i) {\n        float SDFp = SDF(p);\n        if (SDFp < 1e-3) {\n            p = p+d*SDFp*.995;\n            vec3 TEXpd = TEX(p, d);\n            float rxindexp = rxindex(p);\n            if (rxindexp == 0. || rxcount > 4.) {\n                // hits solid object, final color determined\n                finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n                return finalcol;\n            }\n            if (rxcount > 3.) {\n                // waaaay to many reflections reflect background col\n                break;\n            }\n            finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n            shiny = shiny*rxindexp;\n            d = reflect(d, dSDF(p));\n            p = p+d*.02;\n            ++rxcount;\n        }\n        float DE = SDFp;\n        if (0. < DE && DE < 50.) {\n            DE *= .7;\n        }\n        p = p+d*DE;\n    }\n    // diverges waaaay out into the sky. reflect sky color\n    if (rxcount > 0.) {\n        return finalcol+bg(d)*shiny;\n    }\n    return bg(d);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) { maus.x = iResolution.x/2.; }\n    if (maus.y == 0.) { maus.y = iResolution.y/2.; }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n    float dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iResolution.x*10.+0., -3.14/4., 3.14/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    float PI = 3.141592;\n    vec3 retina = march(vec3(cos(iTime/4.*3.141592*2./2.)*3.-5., 0., -7.+mod(iTime, 4.)/4.*2.*6.), dir1);\n    fragColor = vec4(retina, 1.);\n}\n/**/","name":"Image","description":"","type":"image"}]}