{"ver":"0.1","info":{"id":"stfGWB","date":"1622723918","viewed":134,"name":"Lattice Voronoi with F1,F2,F3,..","username":"weasel","description":"A simple shader to visualise the Voronoi zones in a lattice.\nIt is using a gram-schmidt like orthogonalization to make the lattice mostly orthogonal for smaller nearest neighbor check radius.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float grid(mat2 mat, vec2 pos) {\n    vec2 tpos = inverse(mat)*pos;\n    vec2 closest = tpos+mod(tpos+0.5, vec2(1))-0.5;\n    if (abs(tpos.x-closest.x) < 0.003/length(mat[0])\n     || abs(tpos.y-closest.y) < 0.003/length(mat[1]))\n        return 1.0;\n    return max(0.0, 20.0-1000.0*length(mat*(tpos - closest)));\n}\n\n#define REGIONS 4 // min 4\n#define CELLS 2\n\nfloat voronoi(inout mat2 mat, vec2 pos, vec2 show_cell, out int region) {\n    // optimization: find most orthogonal primitive cell\n    vec2 real1 = mat[1]-round(dot(mat[1], mat[0])/dot(mat[0], mat[0]))*mat[0];\n    vec2 real0 = mat[0]-round(dot(mat[0], real1)/dot(real1, real1))*real1;\n    real1 = real1-round(dot(real1, real0)/dot(real0, real0))*real0;\n    real0 = real0-round(dot(real0, real1)/dot(real1, real1))*real1;\n    mat = mat2(real0, real1);\n    \n    // find k-nearest neighbors\n    vec2 tpos = inverse(mat)*pos;\n    float d[REGIONS];\n    for (int i = 0; i < REGIONS; i++) d[i] = 1e6;\n    vec2 k[REGIONS];\n    for (int x = -CELLS; x <= CELLS; x++) {\n        for (int y = -CELLS; y <= CELLS; y++) {\n            vec2 kn = mod(tpos+0.5, vec2(1))+vec2(x, y)-0.5;\n            float dn = length(mat*kn);\n            for (int j = 0; j < REGIONS; j++) {\n                if (dn < d[j]) {\n                    for (int i = REGIONS - 1; i > j; i--) {\n                        k[i]=k[i-1];\n                        d[i]=d[i-1];\n                    }\n                    d[j] = dn;\n                    k[j] = kn;\n                    break;\n                }\n            }\n        }\n    }\n    // find the region which corresponds to show_cell\n    region = -1;\n    for (int i = 0; i < REGIONS - 1; i++)\n        if (length(k[i] - tpos - show_cell) < 1e-3)\n            region = i;\n    \n    // make some grid visuals with points and F1 voronoi edges\n    vec2 h = mat*(k[3]);\n    vec2 w = mat*(k[2]);\n    vec2 v = mat*(k[1]);\n    vec2 u = mat*(k[0]);\n    float edge = min(dot(0.5*(u+v), normalize(v-u)),\n                 min(dot(0.5*(u+w), normalize(w-u)),\n                     dot(0.5*(u+h), normalize(h-u))));\n    return max(0.0, (0.002-min(0.1*d[0], edge)) * 2000.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 mouse = iMouse.xy;\n    \n    // animate if mouse has never moved\n    if (length(mouse.xy) == 0.0)\n        mouse.x += iTime*50.0;\n\n    // make grid matrix\n    mat2 real = mat2(vec2(0.25, 0.0), mouse/iResolution.xy-0.5);\n    real[0] *= iResolution.xy/iResolution.y;\n    real[1] *= iResolution.xy/iResolution.y;\n    \n    // \"do voronoi\"\n    int vregion = -1;\n    vec2 pos = (uv-mouse)/iResolution.y + real[1];\n    float decoration = voronoi(real, pos, vec2(0), vregion);\n    \n    // draw most orthogonal grid instead of voronoi cells\n    //decoration = grid(real, pos);\n    \n    // define the colors used for the regions\n#define COLORS 6\n    vec3 colors[COLORS];\n    colors[0] = vec3(1,0,0);\n    colors[1] = vec3(0,1,0);\n    colors[2] = vec3(0,0,1);\n    colors[3] = vec3(1,1,0);\n    colors[4] = vec3(0,1,1);\n    colors[5] = vec3(1,0,1);\n    \n    // Output to screen\n    vec3 col = colors[vregion % COLORS] * 2.0 / float(2 + vregion / COLORS);\n    if (vregion < 0)\n        col = vec3(0);\n    fragColor = vec4(col + decoration, 1);\n} \n","name":"Image","description":"","type":"image"}]}