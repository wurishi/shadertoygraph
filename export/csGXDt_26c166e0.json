{"ver":"0.1","info":{"id":"csGXDt","date":"1681837635","viewed":233,"name":"needs more lube (music)","username":"crundle","description":"some experiments with the sound buffer. \nkinda hacky and bloated, but remarkably full sounding and chill in my opinion...","likes":16,"published":1,"flags":8,"usePreview":1,"tags":["sound","music","fm","filter","synth"],"hasliked":0,"parentid":"msVSzK","parentname":"DirtyLoFiBounce"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define displaybeats 16.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    initsound(iTime+startbeattime);\n    vec2 aud = vec2(0); vec3 tint = vec3(1.), vol = vec3(.5,1.5,3.); float m = 1.;\n    float uvd=uv.x*displaybeats, t = uvd*beat+floor(tb/displaybeats)*displaybeats*beat;\n    if(uv.y<.25) {m= mixer(t).x; aud = ch1(t)*m; tint = vec3(1.,.7,0.); vol =vec3(.5,1.5,3.)* chvol.x; }\n    else if(uv.y<.5) {m= mixer(t).y; aud = ch2(t)*m; tint = vec3(0.,.7,1.); vol =vec3(.5,1.5,3.)* chvol.y; }\n    else if(uv.y<.75) {m= mixer(t).z; aud = ch3(t)*m; tint = vec3(.6,.0,1.); vol =vec3(1.2,1.5,.8)* chvol.z;}\n    else {m= mixer(t).w; aud = ch4(t)*m; tint = vec3(1.,.0,.6); vol =vec3(1.2,1.5,1.)* chvol.w;}\n    \n\n        uv.y*=4.; uv.y=mod(uv.y,1.);\n        float aa=mix(aud.x,aud.y,smoothstep(0.3,0.7,uv.y));\n        vec3 col = vec3(.1+abs(aa)*m/vol)*(1.-step(aa,uv.y*8.-6.))*tint;\n        if(uv.y<0.5) col = vec3(.1+abs(aa)*m/vol)*step(-aa,uv.y*8.-2.)*tint;\n        if(fract(uvd)<.001*displaybeats) col = vec3(.25);\n        if(uvd<mod(iTime/beat,displaybeats)&&uvd+0.002*displaybeats>mod(iTime/beat,displaybeats)) {\n            col = mix(col,tint*m/vol,m);\n        }\n        if(  aud.x > uv.y*8.-6. -0.04 && aud.x < uv.y*8.-6. +0.04) {\n            col = tint*m/vol;\n        }\n        if(  -aud.y > uv.y*8.-2. -0.04 && -aud.y < uv.y*8.-2. +0.04) {\n            col = tint*m/vol;\n        }\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define UPSAMPLE\n#define US_SAMPLES 2.\n\nvec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    \n    initsound(time+startbeattime);\n    \n    \n    \n    vec2 sig = tone(time+startbeattime);\n    \n#ifdef UPSAMPLE   \n    float u = 1./(US_SAMPLES+1.);\n    float upsample = u/iSampleRate;\n    sig*=u;\n    for(float i =1.; i<= US_SAMPLES; i+=1.) {\n        sig += tone(time+startbeattime-upsample*i)*.5*u;\n        sig += tone(time+startbeattime+upsample*i)*.5*u;\n    }\n#endif\n    \n    return clamp(sig*mastervolume,-1.,1.);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define BPM 120.0\n#define PI 3.1415926538\n#define TAU 6.283182307\n#define beatratio (60./BPM)\n#define startbeat 0.\n#define startbeattime (startbeat*beat)\nfloat mastervolume, tb, beat;\n\nvoid initsound(float t) {\n    mastervolume = 0.5;\n    beat = beatratio;\n    tb = t/beat;\n}\n \n\n///OSC\n//\n//https://graphtoy.com/?f1(x,t)=abs(fract(x-.25)*2.-1)*2.-1&v1=true&f2(x,t)=.5+.5*(sin(t))&v2=false&f3(x,t)=(fract(x-.5)*2.-1)&v3=true&f4(x,t)=sin(x*%F0%9D%9C%8F)&v4=true&f5(x,t)=sign(sin((x)*%F0%9D%9C%8F))&v5=true&f6(x,t)=mix(mix(f3(x,t),f1(x,t),0.5),mix(f4(x,t),f5(x,t),.75),0.0)&v6=true&grid=1&coords=0,0,5.598088562516799\nfloat omni(float t, float freq, vec3 f, vec4 p) {\n    return mix(mix(\n    sin((t*freq+p.z)*TAU), //sine\n    sign(sin((t*freq+p.w)*TAU)), //square\n    f.x),mix(\n    (fract((t)*freq-.5+p.x)*2.-1.), //saw\n    abs(fract((t)*freq-.25+p.y)*2.-1.)*2.-1., //tri\n    f.y),f.z);\n}\n\nfloat sine(float t, float freq) {\n    return sin(TAU*freq*t);\n}\n\nfloat saw(float t, float freq) {\n    return fract(freq*t)*2.-1.;\n}\n\nfloat fsaw(float t, float freq, float cut) {\n\n    float x = freq*t-round(freq*t);\n    float w = min(0.5,0.5*freq/cut);\n    return mix(-2.*x-1., -2.*x+1., smoothstep(-w,w,x));\n}\n\nfloat lpfsaw(float t, float freq, float cut, float q) {\n    // Second approximation : we attenuate the resonance at the end of each cycle.\n    float omega_c = TAU*cut/freq; // relative\n    float wave = freq*t - floor(freq*t);\n    //float v = 1. - 2.*t; // Basic saw\n    float wave2 = -2.*exp(-omega_c*wave/q)*cos(omega_c*wave); // Response of 2nd order system\n    wave2 *= (1.-wave); // Attenuate resonance\n    return (2.*wave-1.)+wave2;\n}\n\nfloat lpfomni(float t, float freq, vec3 f, vec4 p, float cut, float q) {\n    // Second approximation : we attenuate the resonance at the end of each cycle.\n    float omega_c = TAU*cut/freq; // relative\n    float wave = omni(t,freq,f,p);\n    //float v = 1. - 2.*t; // Basic saw\n    float wave2 = -2.*exp(-omega_c*wave/q)*cos(omega_c*wave); // Response of 2nd order system\n    wave2 *= (1.-wave); // Attenuate resonance\n    return (2.*wave-1.)+wave2*.5;\n}\n\n/* Reso lowpass omni */\nfloat resoLpOmni(float time, float freq, vec3 f, vec4 p, float fa)\n{\n    \n    fa= sqrt(fa);\n\tfloat reso = 1.2;   \n    float c = pow(0.5, (128.0-fa*128.0)   / 16.0);\n  \tfloat r = pow(0.5, (reso*128.0+24.0) / 16.0);\n    \n    float v0,v1;\n    v0 = 0.0;\n    v1 = 0.0;\n    \n    for(int i = 0; i < 8; i++)\n    {\n          float history = float(8-i)*(1.0/44100.0);\n\n          float t = time - history;\n          float inp = omni(t,freq,f,p);\n          v0 =  (1.0-r*c)*v0  -  (c)*v1  + (c)*inp;\n  \t\t  v1 =  (1.0-r*c)*v1  +  (c)*v0;\n    }\n    \n    return v1;\n}\n\n\n\nfloat square(float t, float freq) {\n    return sign(sin(TAU*freq*t));\n}\n\nfloat fsquare(float t, float freq, float cut) {\n    return smoothstep(-1.,1.,(sin(TAU*freq*t))*cut)*2.-1.;\n}\n\n/// noise\n//\n\nfloat hash( float a) {\n    return fract(sin(a*2573.694)*785.23174);\n}\n\nvec2 hash22( vec2 a) {\n    return fract(dot(sin(a*2345.2467),vec2(6834.3723,7345.2734))*vec2(2367.8425,2654.2375));\n}\n\nvec2 noise(float t) {\n    return hash22(vec2(t,t*1.423))*2.-1.;\n}\n\nvec2 noise(float t, float freq) {\n    t *= freq;\n\n    float tt = fract(t);\n    float tn = t - tt;\n    tt = smoothstep(0.0, 1.0, tt);\n\n    vec2 n0 = noise(floor(tn + 0.0) / freq);\n    vec2 n1 = noise(floor(tn + 1.0) / freq);\n\n    return mix(n0, n1, tt);\n}\n\n///reverb stuff\n//\n\n\nvec2 verb_par(float t, float freq, vec3 cascades, vec3 decay) {\n    vec2 r = noise(t,freq*cascades.x) * decay.x;\n                + noise(t,freq*cascades.y) * decay.y\n                + noise(t,freq*cascades.z) * decay.z;\n    return r;\n}\n\n\n///distortion\n//\n\nvec2 distort(vec2 sig, float gain) {\n    return clamp(sig*gain,vec2(-1.),vec2(1.));\n}\n\n\n///FM\n//\n\n// iom = index of modulation\n// fc = carrier\n// fm = modulator\n// sine\n\n#define FMs(ti,fc,fm,iom) ((sin(TAU*fract((fc)*(ti))+(iom)*sin(TAU*fract((fm)*(ti))))))\n\n///NOTES\n//\n\n#define note(n) (440.*exp2(((n)-9.)/12.)) // middle C is 0.\n\n\n///SEQUENCE\n//\n\n#define seq(ti,pa,mo) (pa[int(mod( (ti)/(beat*(mo)) , float(pa.length()) )) ])\n\n\n///ENVELOPES\n//\n\nfloat impulse(float t, float atk) {\n  float h = (1./atk) * t;\n  return h * exp(1.0 - h);\n}\n\n\n// the adsr function has three arguments\n      // time, a vec4 with ADSR parameters and the value to decay to\nfloat adsr(float t, vec4 v, float s) {\n  v.xyw = max(vec3(2.2e-05), v.xyw);\n  // attack term\n  float ta = t/v.x;\n  // decay / sustain amplitude term\n  float td = max(s, 1.0-(t-v.x)*(1.0-s)/v.y);\n  // length / release term\n  float tr = (1.0 - max(0.0,t-(v.x+v.y+v.z))/v.w);\n  return max(0.0, min(ta, tr*td));\n}\nfloat adsr(float t, float atk, float dec, float dec_amp, float sus, float rel) {\n    return adsr(t,vec4(atk,dec,sus,rel),dec_amp);\n}\n\n\n\n/// piano\n//\n\nvec2 piano(float t, float fc, float dur) {\n    vec2 sig = vec2(0);\n    float k = fc*round(1000./fc);\n    float env = adsr(t,vec4(.02,.2,.2,.05)*dur,.4);\n    float env2 = adsr(t,vec4(.0,.2,.0,.1)*dur,.2);\n    sig += FMs(t,fc,fc,1.)*env;\n    sig += FMs(t,fc,fc*round(100./fc)+vec2(-.3,.5),8.)*env;\n    sig += FMs(t,k,fc,2.)*vec2(.1,.2)*env2;\n    k = fc*round(2000./fc);\n    sig += FMs(t,k,fc,8.)*vec2(.2,.1)*env2;\n    \n    return sig;\n}\n\n/// drums\n//\n\nvec2 kick(float t) {\n\n    vec2 sig = vec2(0.);\n    sig+=(fsquare(t,60.,10.))*impulse(t,0.005)*1.2;\n    sig+=(fsquare(t,30.,7.))*impulse(t,0.02)*1.;\n    sig+=(fsquare(t,20.,3.))*impulse(t,0.05)*0.6;\n    sig+=(sine(t,10.))*impulse(t,0.075)*0.6;\n    sig+=(sine(t,20.))*impulse(t,0.005)*1.2;\n    return sig;\n}\n\nvec2 snare(float t) {\n\n    vec2 sig = vec2(0.);\n    sig+=(fsquare(t,100.,10.))*impulse(t,0.005)*0.8;\n    sig+=(noise(t,1000.*impulse(t,0.02)+1000.))*impulse(t,0.02)*0.4;\n    sig+=(hash(t))*impulse(t,0.055)*0.2;\n    sig+=(sine(t,20.))*impulse(t,0.075)*0.4;\n    return sig;\n}\n\nvec2 hat1(float t) {\n    vec2 sig = vec2(0.);\n    sig+=(fsquare(t,600.,10.))*impulse(t,0.0005)*0.7;\n    sig+=(hash(t))*impulse(t,0.01);\n    return sig;\n}\n\n/// bass\n//\n\nvec2 bass(float t, float freq, float dur) {\n    float env = adsr(t, vec4(.01,.1,.0,.35)*dur,.6);\n    float fenv = 70.*adsr(t, vec4(.0,.2,.1,.05)*dur,.7)+20.;\n    float tonic = lpfomni(t,freq,vec3(0.,env,env),vec4(0.),fenv,100.)*env;\n    \n    vec2 sig = vec2(tonic);\n    \n    float renv = adsr(t-.02, vec4(.0,.1,.2,.2)*dur,.5)*.25;\n    \n    if(t>0.01)\n    {\n    vec2 r = verb_par(t,freq,vec3(.125,.75,1.55),vec3(1.,.2,exp(-t*5.)));\n    sig += vec2(lpfomni(t,freq+(r.x*.1)/t,vec3(0.),vec4(0.),fenv,2.),lpfomni(t,freq+(r.y*.1)/t,vec3(0.),vec4(0.),fenv,100.)) * renv;\n    sig -= lpfomni(t,freq,vec3(0.),vec4(0.),fenv,100.) * renv;\n    }\n    return distort(sig,1.5);\n}\n\nvec2 bassh(float t, float n, float dur) {\n    vec2 sig = bass(t,n,dur);\n    sig += bass(t,n*.5,dur)*.25;\n    for(float i = 2.; i < 4.; i+=1.) {\n       sig+=bass(t,n*i,dur)*i/8.;\n    }\n    return sig;\n}\n\n/// pad\n//\n\nvec2 keys(float t, float freq, float dur) {\n    float env = adsr(t, vec4(.1,.1,.0,.25)*dur,.9);\n    float fenv = 100.*(1.-adsr(t, vec4(.1,.1,.05,.05)*dur,.7))+50.;\n    float tonic = lpfomni(t,freq,vec3(.5,.5+.5*sin(t*beat*.25*TAU),env),vec4(.25,0.,.1,.2),fenv,100.)*env;\n    \n    vec2 sig = vec2(tonic);\n    \n    float renv = adsr(t-.02, vec4(.01,.15,.0,.35)*dur,.5)*.25;\n    \n    if(t>0.01)\n    {\n    vec2 r = verb_par(t,freq,vec3(.25,.75,1.55),vec3(exp(-t),exp(-t*1.),exp(-t*4.)));\n    sig += vec2(lpfomni(t,freq+(r.x*.1)/t,vec3(.5,.5,.5),vec4(.25,0.,.1,.2),fenv,100.),lpfomni(t,freq+(r.y*.1)/t,vec3(.5,.5,.5),vec4(.25,0.,.1,.2),fenv,100.)) * renv;\n    sig -= lpfomni(t,freq,vec3(.5,.5,.5),vec4(.25,0.,.1,.2),fenv,100.) * renv;\n    }\n    return sig;\n}\n\nvec2 keysh(float t, float n, float dur) {\n    vec2 sig = keys(t,n,dur);\n    for(float i = 2.; i < 4.; i+=1.) {\n       sig+=keys(t,n/i,dur)*i/8.;\n    }\n    return sig;\n}\n\nvec2 keyschord(float t, vec3 n, float dur) {\n    vec2 sig = keysh(t,n.x,dur);\n    sig += keysh(t-1.*beat,n.y,dur)*.75;\n    sig += keysh(t-2.*beat,n.z,dur)*.5;\n    return sig;\n}\n\n/// TRACK\n//\n\n\n#define nk(st,ti,no,du) keyschord(((ti)-((st)*beat)),note(no),du)\n#define nb(st,ti,no,du) bassh(((ti)-((st)*beat)),note(no),du)\n#define np(st,ti,no,du) piano(((ti)-((st)*beat)),note(no),du)\n\nvec4 chvol = vec4(.05,.15,.3,.08);\n\nvec2 ch1(float t) {\n    //timing\n    float tk4 = mod(t,beat*32.);\n    vec2 span = vec2(cos(t*(1./(beat*4.))*TAU),sin(t*(1./(beat*4.))*TAU))*.25+.75;\n    \n    //channels\n    vec2 kb=vec2(0);\n    \n    kb+=nk(-8.,tk4,vec3(2.,5.,12.)-2.,8.); //prefade\n    kb+=nk(0.,tk4,vec3(0.,4.,9.)-2.,8.);\n    kb+=nk(8.,tk4,vec3(3.,7.,14.)-2.,8.);\n    kb+=nk(16.,tk4,vec3(-2.,2.,7.)-2.,8.);\n    kb+=nk(24.,tk4,vec3(2.,5.,12.)-2.,8.);\n    \n    return kb*span*chvol.x;\n}\n\nvec2 ch2(float t) {\n    //timing\n    float tk = mod(t,beat*4.);\n    float tk3 = mod(t,beat*16.);\n\n    \n    //channels\n    vec2 b=vec2(0);\n    \n    b+=nb(0.,tk,-26.,1.);\n    b+=nb(1.5,tk3,-28.,1.5)*.75;\n    b+=nb(5.5,tk3,-28.,1.5)*.75;\n    b+=nb(9.5,tk3,-28.,1.5)*.75;\n    b+=nb(13.5,tk3,-28.,.75)*.75;\n    b+=nb(14.,tk3,-28.,1.)*.75;\n    b+=nb(2.5,tk,-26.,1.);\n    \n    return b*chvol.y;\n}\n\nvec2 ch3(float t) {\n    //timing\n    float tk = mod(t,beat*4.);\n    \n    //channels\n    vec2 dr=vec2(0);\n    \n    dr+=hat1(mod(t+beat*.25,beat))*.15*vec2(0.9,1.0);\n    dr+=hat1(mod(t+beat*.5,beat))*.3*vec2(0.9,1.0);\n    dr+=hat1(mod(t+beat,beat*2.))*.15*vec2(0.9,1.0);\n    dr+=kick(tk)*1.;\n    dr+=snare(mod(t+beat*2.,beat*4.))*.8*vec2(1.,.9);\n    \n    return dr*chvol.z;\n}\n\nvec2 ch4(float t) {\n    //timing\n    float tk3 = mod(t,beat*16.);\n\n    //channels\n    vec2 pp=vec2(0);\n    \n    float delt = .25, dec = .65, amp =1., pn = 0.;\n       \n    for(float i = 0.; i< 3.; i+=1.) {\n        vec2 pd = vec2(0.);\n        pd+=np(0.+delt*i,tk3,-4.+12.*i,.75);\n        pd+=np(.5+delt*i,tk3,-2.+12.*i,2.);\n        pd+=np(3.5+delt*i,tk3,-2.+12.*i,1.);\n        pd+=np(4.5+delt*i,tk3,2.+12.*i,3.);\n        pd+=np(7.5+delt*i,tk3,2.+12.*i,1.);\n        pd+=np(8.+delt*i,tk3,3.+12.*i,1.);\n        pd+=np(8.5+delt*i,tk3,0.+12.*i,2.);\n        pd+=np(11.5+delt*i,tk3,-2.+12.*i,1.);\n        pd+=np(12.5+delt*i,tk3,0.+12.*i,1.);\n        pd+=np(13.5+delt*i,tk3,-4.+12.*i,2.);\n        pd+=np(15.+delt*i,tk3,-4.+12.*i,1.);\n\n        \n        pp+=pd*amp*vec2(pn*.5+.5,(1.-pn)*.5+.5);\n        amp*=dec;\n        pn=mod(i,2.);\n    }\n\n    return pp*chvol.w;\n}\n\nvec4 mixer(float t) {\n     //return vec4(.05,.15,.3,.08);\n     t= mod(t,beat*166.);\n     float a = adsr(t,vec4(16.,0.,128.,16.)*beat,1.);\n     float b = adsr(t-32.*beat,vec4(16.,0.,96.,16.)*beat,1.);\n     float c = adsr(t-16.*beat,vec4(16.,0.,112.,16.)*beat,1.);\n     float d = adsr(t-64.*beat,vec4(16.,0.,64.,16.)*beat,1.);\n     return vec4(a,b,c,d);\n}\n\n\n     \nvec2 tone(float t) {\n    vec2 sig = vec2(0.);\n    sig+=ch1(t)*mixer(t).x;\n    sig+=ch2(t)*mixer(t).y;\n    sig+=ch3(t)*mixer(t).z;\n    sig+=ch4(t)*mixer(t).w;\n    //timing\n    /*\n    float tbeats = t/beat;\n    float tt= mod(t,beat);\n    float tk = mod(t,beat*4.);\n    float tk2 = mod(t,beat*8.);\n    float tk3 = mod(t,beat*16.);\n    float tk4 = mod(t,beat*32.);\n    //stereo panning\n    //float pan = cos(t*.25*TAU);\n    //vec2 span = vec2(cos(t*.25*TAU),sin(t*.25*TAU))*.25+.75;\n    \n    */\n\n    return sig;\n}\n\n\n","name":"Common","description":"","type":"common"}]}