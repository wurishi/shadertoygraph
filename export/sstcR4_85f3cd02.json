{"ver":"0.1","info":{"id":"sstcR4","date":"1653104041","viewed":240,"name":"vidca_test","username":"johnowhitaker","description":"controlling an nca with webcam input","likes":1,"published":1,"flags":34,"usePreview":0,"tags":["clip","nca"],"hasliked":0,"parentid":"7t2BRt","parentname":"Fire - CLIP Guided NCA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Apply zoom (can't figure out how to re-size buffers \n    // so this wastes a lot of compute updating the offscreen parts)\n    uv = uv/2.;\n\n    // Read the buffer\n    vec3 col = (texture(iChannel0, uv).xyz-vec3(0.5))*10. + vec3(0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int nh = 8;\nfloat b1[8] = float[8](-0.018896091729402542,-0.1327052116394043,0.14031440019607544,-0.022681420668959618,0.028853414580225945,-0.14262846112251282,0.13053663074970245,0.140178859233856);\nfloat w1[168] = float[168](-0.30962392687797546,0.19643975794315338,-0.28659337759017944,-0.019779805094003677,0.11155789345502853,-0.06368865817785263,-0.06975309550762177,0.13695043325424194,-0.032431963831186295,0.21628457307815552,0.183691143989563,0.21915023028850555,-0.06571774929761887,-0.20296426117420197,0.19089360535144806,-0.16985762119293213,0.025008486583828926,0.06936928629875183,0.04403321072459221,0.04773527383804321,0.015462702140212059,0.06851028650999069,-0.09032878279685974,-0.024833034723997116,0.1567198783159256,-0.04404614865779877,-0.30433306097984314,-0.21916595101356506,0.0014499120879918337,-0.099955715239048,0.10958701372146606,0.11303935945034027,-0.2039037048816681,0.024636387825012207,0.19486552476882935,-0.1328459233045578,0.0742124393582344,-0.06323360651731491,-0.10850143432617188,-0.0648147389292717,-0.07553626596927643,-0.07876988500356674,-0.2596271336078644,-0.042758695781230927,0.08875900506973267,0.10745503753423691,0.34817713499069214,0.21756918728351593,-0.10760129988193512,-0.02740877866744995,-0.2507961392402649,-0.0012527309590950608,-0.0037225009873509407,0.011783619411289692,-0.12259966880083084,0.1820487529039383,0.04859977960586548,0.14204904437065125,0.004851863253861666,0.10997352749109268,0.0530070923268795,0.09368178248405457,-0.013417022302746773,0.04864449054002762,-0.1580422818660736,0.024270005524158478,0.11944873631000519,0.047900259494781494,-0.0656810998916626,-0.013604704290628433,-0.05964971333742142,-0.3235073685646057,-0.10550405085086823,0.09288197755813599,0.27647438645362854,-0.12767106294631958,-0.11125489324331284,-0.07035500556230545,0.22745656967163086,0.06403478980064392,0.0010459825862199068,0.08034464716911316,0.07280614972114563,0.02285456471145153,2.1367059162002988e-05,0.2055475115776062,0.05324791744351387,0.240984246134758,0.20061153173446655,0.009587053209543228,0.1039135754108429,-0.10183631628751755,0.12005579471588135,0.0062584406696259975,-0.22279053926467896,-0.19449463486671448,0.19988630712032318,0.20122748613357544,0.04587841033935547,-0.10940045863389969,0.09352199733257294,0.16341812908649445,0.14879046380519867,0.173361673951149,0.11175286024808884,0.16047221422195435,-0.0039205304346978664,0.09782969206571579,-0.19343043863773346,0.13237810134887695,0.07460090517997742,-0.010030712932348251,0.04773510619997978,-0.1459740847349167,0.18282127380371094,-0.28130167722702026,0.1981057971715927,0.11126308888196945,-0.026848282665014267,-0.08442963659763336,-0.24028176069259644,0.05765833705663681,0.045844972133636475,0.08878068625926971,0.0722171887755394,0.050798144191503525,0.16971203684806824,-0.07496904581785202,-0.009410218335688114,-0.010454604402184486,-0.3978787362575531,-0.01666288822889328,0.06892330944538116,0.1354057341814041,-0.04480881616473198,0.1664588451385498,-0.1618335247039795,-0.15794993937015533,-0.10166142880916595,0.019291656091809273,0.005686131305992603,0.33346694707870483,-0.06761129945516586,-0.010699795559048653,-0.012581219896674156,0.10448729991912842,-0.08177457749843597,0.09293526411056519,0.23696385324001312,-0.08800967782735825,0.07905645668506622,0.008432564325630665,0.06733595579862595,0.01057855412364006,0.03933916240930557,0.049857139587402344,-0.41682714223861694,0.15652154386043549,-0.004954406525939703,-0.08069871366024017,0.20267347991466522,-0.08581168204545975,0.23293952643871307,0.04954773560166359,0.01649017259478569,0.05537641420960426,0.06407682597637177,0.03232642263174057);\nfloat w2[32] = float[32](0.05410518869757652,0.22323405742645264,0.058423660695552826,-0.023502705618739128,-0.025495899841189384,-0.13814599812030792,-0.01305859349668026,-0.05478227138519287,0.056569624692201614,-0.007639184128493071,-0.03417542204260826,-0.005739909131079912,-0.029659010469913483,-0.11392601579427719,0.06739930063486099,-0.017196184024214745,0.05888833850622177,-0.1765633076429367,0.014204276725649834,0.10446379333734512,-0.05449541285634041,-0.00477010989561677,-0.012800175696611404,-0.04081334173679352,0.02718610316514969,0.03435000404715538,0.04050403833389282,-0.020604901015758514,-0.0435326062142849,-0.08222267031669617,-0.0004739686264656484,0.04189455509185791);\n\n\n// Random Number Generator\n// From https://www.shadertoy.com/view/MsKGWz:\n// See Stack Overflow: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader/10625698#10625698\nfloat random_1( vec2 p )\n{\n    vec2 r = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    return fract( cos( mod( 12345678., 256. * dot(p,r) ) ) );\n}\n\n// Samples the neighbourhood (wrapping around where needed)\nvec2 coord (vec2 fragCoord, vec2 offset){\n    float x = mod(fragCoord.x + offset.x, iResolution.x);\n    float y = mod(fragCoord.y + offset.y, iResolution.y);\n    return vec2(x, y)/iResolution.xy;\n}\nvec4[9] sample_tex (vec2 fragCoord){\n    vec4 tex[9] = vec4[9](\n        (texture(iChannel0, coord(fragCoord, vec2(-1, 1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(0, 1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(1, 1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(-1, 0)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(0, 0)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(1, 0)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(-1, -1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(0, -1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(1, -1)))-0.5)*10.\n    );\n    return tex;\n}\n\n// The four kernels used\nvec4 ident(vec2 fragCoord, vec4[9] tex){\n    return tex[4]; // no offset\n}\nvec4 sobel_x(vec2 fragCoord, vec4[9] tex){\n    vec4 result = -1.*tex[0]-2.*tex[3]-1.*tex[6]+1.*tex[2]+2.*tex[5]+1.*tex[8];\n    return result;\n}\nvec4 sobel_y(vec2 fragCoord, vec4[9] tex){\n    vec4 result = -1.*tex[0]-2.*tex[1]-1.*tex[2]+1.*tex[6]+2.*tex[7]+1.*tex[8];\n    return result;\n}\nvec4 lap(vec2 fragCoord, vec4[9] tex){\n    vec4 result = 1.*tex[0]+2.*tex[1]+1.*tex[2]+2.*tex[3]-12.*tex[4]+2.*tex[5]+1.*tex[6]+2.*tex[7]+1.*tex[8]; // was an errant +2.\n    return result;\n}\n\n// Our activation function\nfloat relu(float x){\n    if (x > 0.){return x;}\n    return 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    \n    // Init \n    if (iFrame==0){fragColor = vec4(0.5);}\n    \n    if (uv.x< 0.55){ // ignore half the screen since we zoom anyway\n    \n        // If (noise>0.5) apply update\n        vec2 p = vec2(uv.x/2.+sin(iTime/1000.), uv.y/2.+cos(iTime/1000.));\n        float pp = random_1(p);\n        if (uv.y > 0.51){pp += 0.4;} // updates less likely for offscreen\n        if (pp < 0.5){\n            \n             // Sample BufC for kernels\n            vec4 tex[9] = sample_tex(fragCoord);\n\n            // Apply filters\n            vec4 id = ident(fragCoord, tex);\n            vec4 sx = sobel_x(fragCoord, tex);\n            vec4 sy = sobel_y(fragCoord, tex);\n            vec4 ll = lap(fragCoord, tex);\n            \n            // Sample webcam\n            vec2 cc = fragCoord*2.;\n            vec4 img = texture(iChannel1,cc/iResolution.xy);\n\n            // Create x (4 channels x 4 filters, per channel conv)\n            // + 5 rules\n            float x[21];\n            x[0] = id.x;x[1] = sx.x;x[2] = sy.x;x[3] = ll.x;\n            x[4] = id.y;x[5] = sx.y;x[6] = sy.y;x[7] = ll.y;\n            x[8] = id.z;x[9] = sx.z;x[10] = sy.z;x[11] = ll.z;\n            x[12] = id.w;x[13] = sx.w;x[14] = sy.w;x[15] = ll.w;\n            x[16]=img.r;x[17]=img.g;x[18]=img.b;x[19]=0.;x[20]=0.;\n\n\n            // First layer \n            float l1_out[nh];\n            for (int i = 0; i < nh; i++){\n                // Dot Product equivalent to:\n                // dot_product = x @ w1_i\n                float dot_product = 0.;\n                for (int j = 0; j < 16+5; j++){\n                    dot_product += x[j]*w1[i*(16+5)+j];\n                }\n                // Add bias then RELU\n                l1_out[i] = relu(dot_product+b1[i]);  ;\n            }\n\n            // Second layer\n            float l2_out[4];\n            for (int i = 0; i < 4; i++){\n                float dp2 = 0.;\n                for (int j = 0; j < nh; j++){\n                    dp2 += l1_out[j]*w2[i*nh+j];\n                }\n                l2_out[i] = dp2; \n            }\n\n            // Proposed update\n            vec4 y = vec4(l2_out[0], l2_out[1], l2_out[2], l2_out[3]);\n        \n            fragColor = (id + y)*0.1 + vec4(0.5);\n        }\n        else{\n            // Output as prev state\n            fragColor = texture(iChannel0, coord(fragCoord, vec2(0, 0)));\n        }\n        \n        // Init \n        if (iFrame==0){fragColor = vec4(0.5);}\n\n        // If (mouse down) paint grey around it\n        if(length(fragCoord.xy-iMouse.xy/2.)<(20.)){\n            if (iMouse.z>0.5){fragColor = vec4(0.5);}\n        }\n    \n        \n    \n    }\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}