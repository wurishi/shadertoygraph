{"ver":"0.1","info":{"id":"fsBXRV","date":"1621766569","viewed":264,"name":"Gamut Clipping","username":"SimonYeung","description":"An interactive demo testing the gamut clipping technique used for my blog post:\nhttps://simonstechblog.blogspot.com/2021/05/studying-gamut-clipping.html\n\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["oklab","gamutclipping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HUE_MODE                               2     // 0= use HUE defined below\n                                                     // 1= use mouse x position as HUE\n                                                     // 2= slowly changing HUE based of time\n#define HUE                                    64.0  // when HUE_MODE == 0, use this defined value for hue, in degree\n#define HUE_CHANGE_SPEED                       30.0  // when HUE_MODE == 2, the speed of HUE change\n#define DISPLAY_SATURATION_MODE                0     // set to 1 to display grey scale saturation\n#define IS_DISPLAY_GAMUT_CUSP_POINT            1\n#define IS_DISPLAY_GAMUT_CLIP_LINE             1\n#define IS_DISPLAY_sRGB_COLOR_NEAR_ZERO_LINE   1\n#define IS_DISPLAY_sRGB_COLOR_NEAR_ONE_LINE    1\n#define IS_DISPLAY_TEXT_HUE                    1\n#define IS_DISPLAY_TEXT_MOUSE_RGB_SAT          1\n#define IS_DISPLAY_TEXT_PROJECTED_RGB_SAT      1\n#define IS_DISPLAY_TEXT_CUSP_RGB_SAT           1\n#define IS_DISPLAY_OUT_OF_GAMUT_COLOR          0\n#define GAMUT_CLIP_L0                          0.5   // the lightness value projected to\n#define DRAW_SCALE_CL_MIN                      vec2(0.0, -0.05)\n#define DRAW_SCALE_CL_MAX                      vec2(0.5,  1.25)\n\nvec2 pxCoord_to_CL(vec2 pxPos)\n{\n    vec2 CL_range= DRAW_SCALE_CL_MAX - DRAW_SCALE_CL_MIN;\n    return (pxPos / iResolution.xy) * CL_range + DRAW_SCALE_CL_MIN;\n}\n\nvec2 CL_to_pxCoord(vec2 CL)\n{\n    vec2 CL_range= DRAW_SCALE_CL_MAX - DRAW_SCALE_CL_MIN;\n    return ((CL - DRAW_SCALE_CL_MIN)/CL_range)* iResolution.xy;\n}\n\nfloat drawCircleAtLC(vec2 pxCoord, LC circlePosLC, float circleRadius)\n{\n    return drawCircle(pxCoord, CL_to_pxCoord(circlePosLC.yx), circleRadius);\n}\n\nfloat OETF_rec709_f(float val)\n{\n\treturn val < 0.018 ? val * 4.5: 1.099 * pow(val, 0.45) - 0.099;\n}\n\nvec3 OETF_rec709(vec3 val)\n{\n\treturn vec3(OETF_rec709_f(val.r), OETF_rec709_f(val.g), OETF_rec709_f(val.b));\n}\n\n// h in radian\nvec3 oklab_LCh_to_Lab(float L, float C, float h) \n{\n    vec3 Lab;\n    Lab.x = L;\n    Lab.y = C * cos(h);\n    Lab.z = C * sin(h);\n    return Lab;\n}\n\n// h in radian\nvec3 oklab_pxCoord_to_Lab(vec2 pxPos, float h) \n{\n    vec2  CL= pxCoord_to_CL(pxPos);\n    return oklab_LCh_to_Lab(CL.y, CL.x, h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // draw gamut at specific hue\n#if HUE_MODE == 0\n    float hue = degree_to_radian(HUE);\n#elif HUE_MODE == 1\n    float hue = degree_to_radian(iMouse.x/iResolution.x * 360.);\n#else\n    float hue = degree_to_radian(mod(iTime * HUE_CHANGE_SPEED, 360.));\n#endif\n    float cos_h= cos(hue);\n    float sin_h= sin(hue);\n    \n    // convert pixel position to lightness and chroma\n    vec2  CL_px   = pxCoord_to_CL(fragCoord);\n    float sat_px  = CL_px.x / CL_px.y;\n    vec3  oklab_px= oklab_LCh_to_Lab(CL_px.y, CL_px.x, hue);\n    \n    // find gamut cusp\n    LC    cusp    = find_cusp(cos_h, sin_h);\n    \n    // project out of gamut point back to gamut boundary\n    LC    ProjectPtFrom= pxCoord_to_CL(iMouse.xy).yx;\n    LC    ProjectPtTo  = LC(GAMUT_CLIP_L0, 0);  // can also use cusp.x if want to project to lightness of cusp\n\tfloat t            = find_gamut_intersection(cos_h, sin_h, ProjectPtFrom.x, ProjectPtFrom.y, ProjectPtTo.x);\n\tfloat L_clipped    = ProjectPtTo.x * (1. - t) + t * ProjectPtFrom.x;\n\tfloat C_clipped    = t * ProjectPtFrom.y;\n    LC    LC_clipped   = LC(L_clipped, C_clipped);\n    vec3  projectedRGB = oklab_to_rgb( vec3(L_clipped, C_clipped * cos_h, C_clipped * sin_h));\n    \n    // convert pixel color to sRGB space\n    vec3 lin_sRGB    = oklab_to_rgb(oklab_px);\n    vec3 clipped_sRGB= clamp(lin_sRGB, 0., 1.);\n    \n    // compute output color\n    float epsilon0= 0.0025 * pow(clamp(CL_px.y, 0., 1.), 1.5);  // scale down epsilon when close to zero\n    bool isAnyChannelCloseToZeroR=abs(lin_sRGB.r) < epsilon0;\n    bool isAnyChannelCloseToZeroG=abs(lin_sRGB.g) < epsilon0;\n    bool isAnyChannelCloseToZeroB=abs(lin_sRGB.b) < epsilon0;\n    \n    float epsilon1= 0.005;\n    bool isAnyChannelCloseToOneR= abs(lin_sRGB.r-1.) < epsilon1;\n    bool isAnyChannelCloseToOneG= abs(lin_sRGB.g-1.) < epsilon1;\n    bool isAnyChannelCloseToOneB= abs(lin_sRGB.b-1.) < epsilon1;\n    \n    bool isOutOfGamut=  lin_sRGB.r != clipped_sRGB.r ||\n                        lin_sRGB.g != clipped_sRGB.g ||\n                        lin_sRGB.b != clipped_sRGB.b ;\n#if IS_DISPLAY_sRGB_COLOR_NEAR_ZERO_LINE\n    if (isAnyChannelCloseToZeroR)\n        fragColor = vec4(.4,0.,0.,1.);\n    else if (isAnyChannelCloseToZeroG)\n        fragColor = vec4(0.,.35,0.,1.);\n    else if (isAnyChannelCloseToZeroB)\n        fragColor = vec4(0.,0.,.45,1.);\n    else\n#endif\n#if IS_DISPLAY_sRGB_COLOR_NEAR_ONE_LINE\n    if (isAnyChannelCloseToOneR)\n        fragColor = vec4(1.,0.,0.,1.);\n    else if (isAnyChannelCloseToOneG)\n        fragColor = vec4(0.,1.,0.,1.);\n    else if (isAnyChannelCloseToOneB)\n        fragColor = vec4(0.,0.,1.,1.);\n    else\n#endif\n#if !IS_DISPLAY_OUT_OF_GAMUT_COLOR\n    if(isOutOfGamut)  // out of gamut\n        fragColor = vec4(0.5,0.5,0.5,1.);\n    else\n#endif\n    {\n        // within gamut\n#if DISPLAY_SATURATION_MODE\n        \n        fragColor = vec4(sat_px, sat_px, sat_px, 1.);\n#else\n        fragColor = vec4(OETF_rec709(clipped_sRGB), 1.);\n#endif\n    }\n\n    // draw current HUE in upper right corner\n#if IS_DISPLAY_TEXT_HUE\n    fragColor+=drawFloat(fragCoord-vec2(iResolution.x - 80., iResolution.y - 20.), radian_to_degree(hue), 3.0,2.0);\n#endif\n\n    // draw sRGB + saturation at mouse position at the lowest line\n#if IS_DISPLAY_TEXT_MOUSE_RGB_SAT\n    vec2 oklab_mouse_CL= pxCoord_to_CL(iMouse.xy);\n    vec3 oklab_mouse   = oklab_LCh_to_Lab(oklab_mouse_CL.y, oklab_mouse_CL.x, hue);\n    vec3 lin_sRGB_mouse= oklab_to_rgb(oklab_mouse);\n    float sat_mouse= oklab_mouse_CL.x / oklab_mouse_CL.y;\n    fragColor+=drawFloat(fragCoord-vec2(000.0, 0.0), lin_sRGB_mouse.r, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(100.0, 0.0), lin_sRGB_mouse.g, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(200.0, 0.0), lin_sRGB_mouse.b, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(350.0, 0.0), sat_mouse, 1.0,4.0);\n#endif\n    \n    // draw sRGB + saturation at projected gamut clipped position at the second lowest line\n#if IS_DISPLAY_TEXT_PROJECTED_RGB_SAT\n    float sat_project= C_clipped / L_clipped;\n    fragColor+=drawFloat(fragCoord-vec2(000.0, 20.0), projectedRGB.r, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(100.0, 20.0), projectedRGB.g, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(200.0, 20.0), projectedRGB.b, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(350.0, 20.0), sat_project, 1.0,4.0);\n#endif\n    \n    // draw sRGB + saturation at cusp at the third lowest line\n#if IS_DISPLAY_TEXT_CUSP_RGB_SAT\n    vec3  lin_sRGB_cusp= oklab_to_rgb(oklab_LCh_to_Lab(cusp.x, cusp.y, hue));\n    float sat_cusp     = cusp.y / cusp.x;\n    fragColor+=drawFloat(fragCoord-vec2(000.0, 40.0), lin_sRGB_cusp.r, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(100.0, 40.0), lin_sRGB_cusp.g, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(200.0, 40.0), lin_sRGB_cusp.b, 1.0,4.0);\n    fragColor+=drawFloat(fragCoord-vec2(350.0, 40.0), sat_cusp, 1.0,4.0);\n#endif\n    \n    // draw gamut cusp\n#if IS_DISPLAY_GAMUT_CUSP_POINT\n    fragColor+= drawCircleAtLC(fragCoord, cusp, 3.0);\n#endif\n\n    // draw mouse position, gamut project to position and gamut clipped position\n#if IS_DISPLAY_GAMUT_CLIP_LINE\n    fragColor+= drawCircleAtLC(fragCoord, ProjectPtFrom, 3.0);\n    fragColor+= drawCircleAtLC(fragCoord, ProjectPtTo  , 3.0);\n    fragColor+= drawCircleAtLC(fragCoord, LC_clipped   , 3.0);\n    \n    // draw project line\n    fragColor+= sdLine(fragCoord, CL_to_pxCoord(LC_clipped.yx), CL_to_pxCoord(ProjectPtTo.yx))*0.2;\n    fragColor+= sdLine(fragCoord, CL_to_pxCoord(ProjectPtFrom.yx), CL_to_pxCoord(ProjectPtTo.yx));\n#endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// some of the function are borrowed from the following shader toy source code\n// https://www.shadertoy.com/view/wdXBDS\n// https://www.shadertoy.com/view/WlGyDG\n// https://www.shadertoy.com/view/4lGSzV\n\nfloat degree_to_radian(float deg)\n{\n    return deg * (3.14159265359 /180.0);\n}\n\nfloat radian_to_degree(float rad)\n{\n    return rad * (180.0/3.14159265359);\n}\n\nfloat sdLine(in vec2 p,in vec2 a,in vec2 b)\n{\n    /// Project p onto the line ab, then return the distance from p` to p\n    \n\t// Use a as 'origin'\n    vec2 origin = a;    \n    vec2 p2 = p-origin;\n    vec2 b2 = b-origin;\n\n    // Compute the dot product of vectors and divide to get the ratio\n\tfloat lineRatio = dot(p2, b2)/dot(b2, b2);\n\n    // Clamp the ratio between 0.0 and 1.0\n    lineRatio = clamp(lineRatio, 0., 1.);\n\n    // Nearest point on AB\n    vec2 pointOnLine = b2*lineRatio;\n\n    // Return distance from line to point\n    return 1. - step(0.5, length(p2 - pointOnLine));\n}\n\n\n#define RESOLUTION .3\n\n// based on works of TimoKinnunen\n// draws float <value> at iDrawCoord-<charCoord>\n// works fine, but not for big decimals\nfloat drawFloat(in vec2 charCoord, float value,\n\t\tfloat digits, float decimals) {\n        \n    // round to closest dp\n    float dp_multiplier= pow(10., decimals);\n    value= round(value * dp_multiplier) / dp_multiplier;\n    \n\tcharCoord *= RESOLUTION*RESOLUTION;\n\tfloat bits = 0.;\n\tif(charCoord.y < 0. || charCoord.y >= 1.5 || charCoord.x < step(-value,0.)) return bits;\n\tfloat digitIndex = digits - floor(charCoord.x)+ 1.;\n\tif(- digitIndex <= decimals) {\n\t\tfloat pow1 = pow(10., digitIndex);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.;\n\t\tif(pivot < pow1) bits = 1792.*float(value < 0. && pivot >= pow1 * .1);\n\t\telse if(digitIndex == 0.) bits = 2.*float(decimals > 0.);\n\t\telse {\n        \tvalue = digitIndex < 0. ? fract(absValue) : absValue * 10.;\n            int x=int (mod(value / pow1, 10.));\n\t\t\tbits = x==0?480599.:x==1?139810.:x==2?476951.:x==3?476999.:x==4?350020.:x==5?464711.:x==6?464727.:x==7?476228.:x==8?481111.:x==9?481095.:0.;\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2., floor(fract(charCoord.x) * 4.) + floor(charCoord.y * 4.) * 4.), 2.));\n}\n\nfloat drawCircle(vec2 pxCoord, vec2 circlePos, float circleRadius)\n{\n    return float(length(pxCoord - circlePos) <= circleRadius);\n}\n\nvec3 rgb_to_oklab(vec3 c) \n{\n    float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n    float l_ = pow(l, 1./3.);\n    float m_ = pow(m, 1./3.);\n    float s_ = pow(s, 1./3.);\n\n    vec3 labResult;\n    labResult.x = 0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_;\n    labResult.y = 1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_;\n    labResult.z = 0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_;\n    return labResult;\n}\n\nvec3 oklab_to_rgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 rgbResult;\n    rgbResult.r = + 4.0767416621f *l - 3.3077115913f *m + 0.2309699292f *s;\n    rgbResult.g = - 1.2684380046f *l + 2.6097574011f *m - 0.3413193965f *s;\n    rgbResult.b = - 0.0041960863f *l - 0.7034186147f *m + 1.7076147010f *s;\n    return rgbResult;\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps \n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\n#define LC vec2\nLC find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_rgb(vec3( 1., S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = pow(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b), 1./3.);\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn LC( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    float cosh= a;\n    float sinh= b; // save the value here as b is redefined when using Halley's method...\n\n\t// Find the cusp of the gamut triangle\n\tLC cusp = find_cusp(a, b);\n\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\t\t\t\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3. * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3. * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3. * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6. * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6. * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6. * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.;\n\t\t\t\tfloat g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n                // no need to compare all 3 curves\n                float FLT_MAX= 3.402823466e+38;\n\t\t\t\tt_r = u_r >= 0.f ? t_r : FLT_MAX;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : FLT_MAX;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : FLT_MAX;\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n                \n                /*\n                // can use yellow/cyan/magenta dir to choose which curve similar to compute_max_saturation()\n                // but this will introduce small error as the upper clipping curves are not a straight lines\n                if (2.34945731 * cosh + 1.9070604 * sinh > 1.)\n                {\n                    // Red curve\n                    t += t_r;\n                }\n                else if (-1.20055326 * cosh + 0.63113099 * sinh > 1.)\n                {\n                    // Green curve\n                    t += t_g;\n                }\n                else\n                {\n                    // Blue curve\n                    t += t_b;\n                }\n                */\n                \n                \n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}","name":"Common","description":"","type":"common"}]}