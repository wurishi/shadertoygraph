{"ver":"0.1","info":{"id":"4XSfRG","date":"1729622236","viewed":81,"name":"Quantum Loop SpaghettiOs","username":"8InfinityTaco8","description":"This Uses the Same methods as the previous ones. This time i changed the rotation of the rays and used a Torus as the base shape. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","distancefield","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592;\nconst float fov = 1.; \nconst float raydist = 3.;\n\nfloat sdSphere(vec3 p, float s){\n    return length (p) - s;\n}\n\n// Torus SDF\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2 (c, -s, s, c);\n}\n\n\n\n//Distance to the Scene\nfloat map(vec3 p){\n    vec3 torusPos = vec3(0.);\n    \n    vec3 a = vec3(sin(iTime) * .2, cos(iTime) * .2, 0); // Sphere position    float sphere = sdSphere(p - spherePos, 1.); // Sphere sdf\n    //vec2 ab = vec2(sin(iTime) * .4, cos(iTime) * .4);\n    vec2 ab = vec2(.5 ,0.05);\n    \n    p.z -= iTime * .4; // forwared movment\n    p.xy *= rot2D(iTime); // Rotate aound the z axis\n    p = fract(p) - .5; //Space Repetition(spaced repetition can be applied to all 3 axes or just a singular axes)\n    //p.z = mod (p.z, .25) - .125; // spacing .25\n    //p.y *= abs(sin(iTime) * 1.); // Even smaller movement\n\n    float torus = sdTorus(p - torusPos , ab);\n    return min(torus, .05);\n}\n\n\nvec3 pallete(float t){\n     vec3 a = vec3(0.500, 0.500, 0.500);\n     vec3 b = vec3(0.500, 0.500, 0.500); \n     vec3 c = vec3(1.000, 1.000, 1.000);\n     vec3 d = vec3(-0.500, 0.333, 0.667);\n\n    return a + b * cos (6.28318*(c*t+d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n   //vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y * 4.; //(this can be scaled to determin sensitivity)\n   vec2 m = vec2(cos(iTime * .4), sin(iTime * .4)); \n\n   \n   //initialization\n   vec3 ro = vec3(0, 0, -raydist); // ray origin\n   vec3 rd = normalize(vec3(uv, fov)); // ray direction\n   vec3 col = vec3(0); // final pixel color\n   \n   float t = 0.; // total distance travelled\n   \n   \n   //vertical camera rotation replace uv with m for mouse\n   //ro.yz *= rot2D(-m.y);\n   //rd.yz *= rot2D(-m.y);\n\n   //horizontal camera rotation\n   //ro.xz *= rot2D(m.y);\n   //rd.xz *= rot2D(m.y);\n  \n   \n   \n   //vertical camera rotation replace uv with m for mouse\n   //ro.yz *= rot2D(atan(-m.y, -m.x));\n   //rd.yz *= rot2D(atan(-m.y,-m.x));\n\n   //horizontal camera rotation\n   //ro.xz *= rot2D(atan(-m.y, -m.x));\n   //rd.xz *= rot2D(atan(-m.y, -m.x));\n   \n   //Raymarching\n   int i;\n   for (i = 0; i < 500; i++){\n       vec3 p = ro + rd * t; // position along the ray\n       \n       p.xy *= rot2D(t*.2 * m.x); // rotate ray around axis\n       \n       p.x *= cos(t*(m.x+1.))*.2;\n       p.y *= atan(t*(m.x+1.))*.2;\n       \n       //p.z *= abs(atan(t*(m.x+1.))*.02);\n       \n\n\n       \n       p.y += sin(t*(m.y+1.))*.2; //wiggle ray\n       \n   \n       float d = map(p); // current distance to the scene\n       \n       t += d; // \"march\" the ray\n       \n       if (d < 0.001) break;\n       if (d > 500.) break;\n   }\n   \n   //coloring\n   col = vec3(t * 0.02); // color based on distance\n   col = pallete(t * 0.04 + float(i)*.001 + iTime *.4);\n   \n   fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}