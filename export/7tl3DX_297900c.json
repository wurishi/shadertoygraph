{"ver":"0.1","info":{"id":"7tl3DX","date":"1623026117","viewed":149,"name":"2D interference pattern creator","username":"HalbFettKaese","description":"Lets you define and display an arbitrary set of light emitters with set origin positions, frequencies and phase differences.\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","light","interference","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Code originally written by HalbFettKaese.\n *\n * Source on the wavelengths of the different colors:\n * https://turing.manhattan.edu/~mrifkind01/Homework_2/Colors.html\n *\n *\n * Patches:\n * - 2021-06-08: Added brightness diffusion over distance\n * - 2021-06-08: Added colors\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SQRT_THREE 1.7320508075688772\n#define ONE_THIRD 0.3333333333333333\n#define TWO_THIRDS 0.6666666666666667\n#define PI 3.141592653589793\n\nstruct Emitter {\n    vec3 color;\n    vec2 pos;\n    float phase;\n    float brightness;\n};\n\n// Parameters to adjust manually:\n\nconst float persistence = 5.; // The rate at which the drawn light fades away\nconst float speed = 5.; // The speed that the simulation runs at\nconst float base_intensity = 1.; // The light intensity by which the sources are normalized\nfloat frequency_scale = 1.; // Lower values for macroscopic scale\nconst Emitter[] emitters = Emitter[](\n    Emitter(vec3(1., 1., 1.), vec2(-ONE_THIRD * SQRT_THREE, -1), 0., 1.),\n    Emitter(vec3(1., 1., 1.), vec2(-ONE_THIRD * SQRT_THREE,  1), 0., 1.),\n    Emitter(vec3(1., 1., 1.), vec2(TWO_THIRDS * SQRT_THREE,  0), 0., 1.)\n);\n\n// Internal shader code:\n\nconst float decay_factor = pow(1. - pow(10., -persistence), speed);\n\nfloat getIntensity(float dist, Emitter e, float f) {\n    /* Divided by dist rather than distÂ² because in 2D, \n    *  the same intensity is spread over a circle of equal distance,\n    *  rather than a sphere. A real physical setup could realize this\n    *  by adding two mirrors parallel and close to the view plane or by using a\n    *  long, rod-shaped light source.\n    */\n    return e.brightness * \n               sin(\n                 dist * PI * f - \n                 speed * iTime + \n                 e.phase\n               )/base_intensity/dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = iMouse.xy;\n    if (offset == vec2(0)) offset = iResolution.xy/2.;\n    vec2 uv = (fragCoord - offset)/iResolution.xx;\n    uv *= 10.;\n    \n    vec3 sum = vec3(0);\n    for (int i = 0; i < emitters.length(); i++) {\n        Emitter e = emitters[i];\n        float dist = distance(uv, e.pos);\n        // Frequency of red light: 430-480 THz, so 4.5 on average\n        sum.r += e.color.r * getIntensity(dist, e, frequency_scale * 4.5); \n        // Frequency of green light: 540-580 THz, so 5.6 on average\n        sum.g += e.color.g * getIntensity(dist, e, frequency_scale * 5.6); \n        // Frequency of blue light: 610-670 THz, so 6.4 on average\n        sum.b += e.color.b * getIntensity(dist, e, frequency_scale * 6.4); \n        \n    }\n    \n    \n    vec3 previous;\n    if (iMouse.z>0.0) \n        previous = vec3(0.);\n    else\n        previous = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    vec3 result = max(sum*sum, previous * decay_factor);\n    \n    fragColor = vec4(result, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}