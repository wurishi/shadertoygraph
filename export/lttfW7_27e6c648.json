{"ver":"0.1","info":{"id":"lttfW7","date":"1539906966","viewed":185,"name":"background wave","username":"eiglow_","description":":)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TIME (iTime*1.)\n//#define TEMPO 170.\n//#define TIME (pow(mod(iTime*TEMPO/60.,1.), .4) + floor(iTime*TEMPO/60.))\n//#define MOUSE_CONTROL\n\n#define PI 3.1415\n#define HALF_PI 1.570796\n\nvec3 hsv2rgb(const vec3 c) {\n\tconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// static color\n//#define MAIN_THEME vec3(1.0, 0.3, 0.9)\n// rgb\n#define MAIN_THEME hsv2rgb(vec3(TIME/25., 1., 1.5))\n#define SECONDARY_THEME hsv2rgb(vec3(TIME/25. + 0.15, 1., 1.5))\n\n#define WAVE_COLOUR MAIN_THEME\n#define WAVE_FREQ (3.+sin(TIME/5.)*1.5)\n#define WAVE_PHASE (TIME)\n#define WAVE_THICKNESS (0.52+sin(TIME/8.+uv.x)*0.02)\n//#define WAVE_TILT (sin(TIME/6.)*1.)\n#define WAVE_AMP ((1.+sin(TIME/4.)/3.)*20.) \n#define WAVE_HEIGHT 0.25\n#define WAVE_BRIGHTNESS (5.+1.2*sin(TIME/3.))\n\n#define BG_GRADIENT_BOTTOM 0.5*SECONDARY_THEME\n#define BG_GRADIENT_TOP    (MAIN_THEME * 0.7+sin(TIME/8.)*0.05)\n\n#define STAR_QUANTITY 50.\n#define STAR_SIZE 0.5\n#define STAR_SPEED -1.\n\n\n\n// From:\n// https://amindforeverprogramming.blogspot.com.au/2013/07/random-floats-in-glsl-330.html\n//\nuint hash( uint x )\n{\n    x += x >> 11;\n\tx ^= x << 7;\n\tx += x >> 15;\n\tx ^= x << 5;\n\tx += x >> 12;\n\tx ^= x << 9;\n\treturn x;\n}\nfloat noise( const float f )\n{\n    return uintBitsToFloat( (hash( floatBitsToUint( f ) ) & 0x007FFFFFu) | 0x3F800000u ) - 1.0;\n}\n\nvec3 star(const vec2 uv, const float numberf, const float realTime, const float ratio)\n{\n    \n    // random position based on star number\n    vec2 position = vec2(noise(numberf)*ratio, noise(numberf+0.2));\n    \n    float depth = ((noise(numberf + 0.75))*2.5)-0.5;\n    // illusion of DOF\n    //float softness = abs(depth-(sin(HALF_PI*iTime))); //pulsing\n    float softness = 0.5+abs(depth); //static\n    // random size with a random pulser function and random ratio on it\n    float size =  0.005 + noise(numberf + 0.25) / 1000.;\n          size *= STAR_SIZE+1.+STAR_SIZE*(sin((numberf+realTime*.5)*(numberf*5.))/(STAR_SIZE*10.));\n          size -= depth/100.;\n          size += (softness-(depth/3.))/35.;\n    \n    // move horizontally based on depth, creates illusion of depth\n    //position.x += realTime*(1.-min(depth,1.))/50.;\n    position.x += STAR_SPEED * realTime*max(1.-(depth*8.),1.)/50.;\n#ifdef MOUSE_CONTROL\n    position += (iMouse.xy/10./iResolution.xy+.5)/(2.*depth)-.5;\n#endif\n    // circle around centre\n    //position = vec2(\n    //    0.5 + sin(PI*(position.x+iTime/3.)),\n    //    0.5 + sin(PI*(position.y+iTime/3.) + PI) / 2.\n    //);\n    // move randomly slightly\n    //position += vec2(\n    //    noise(numberf+floor(realTime*noise(numberf))+0.35),\n    //    noise(numberf+floor(realTime*noise(numberf))+0.45))\n    ///100.;\n    \n    // extra 1.1 and -0.05 for padding, to avoid stars appearing at the edge rather than sliding in properly\n    position.x = mod(position.x, 1.1*ratio) - 0.05*ratio;\n    \n    return \n        vec3(1.+noise(30.*numberf), 0.8+noise(20.*numberf), 0.3+noise(10.*numberf)) *\n        smoothstep(size, size-(softness/10.), length(position - uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/length(iResolution)*2.;\n    float ratio = iResolution.x/iResolution.y;\n    \n    vec3 col = mix(BG_GRADIENT_BOTTOM, BG_GRADIENT_TOP, uv.y);\n\n    // wave thing\n    float wave = (0.5+WAVE_HEIGHT+sin(uv.x*WAVE_FREQ+WAVE_PHASE)/WAVE_AMP)-uv.y;//*((0.5-uv.x)*WAVE_TILT);\n    wave = smoothstep(WAVE_THICKNESS+0.1, 1.-WAVE_THICKNESS, wave) * smoothstep(1.-WAVE_THICKNESS, WAVE_THICKNESS+0.1, wave);\n    \n    col *= 1.0+wave*WAVE_BRIGHTNESS*WAVE_COLOUR;\n    float i = STAR_QUANTITY;\n    while (i-- > 0.) col += star(uv, i, TIME, ratio);\n    // make colors over 1.0 bleed into white\n    col += vec3(max(col.g-1., 0.0)+max(col.b-1., 0.0), max(col.r-1., 0.0)+max(col.b-1., 0.0), max(col.r-1., 0.0)+max(col.g-1., 0.0));\n\tcol = mix(col, texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 0.9);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}