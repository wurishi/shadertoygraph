{"ver":"0.1","info":{"id":"4ljBzK","date":"1516514760","viewed":157,"name":"Pathtrace Final","username":"shemit","description":"final iteration.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["finaliterationpathtrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 3\n#define PI 3.141592653589793\n#define SPHERES 9\n\n// type:\n// 0: DIFFUSE\n// 1: EMISSIVE\nstruct Sphere {\n    float radius;\n    vec3 position;\n    float emission;\n    vec3 color;\n    int type;\n};\n\nstruct Camera {\n\tvec3 position;\n    vec3 direction;\n    vec3 up;\n    float fov;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct HitData {\n    Sphere sphere;\n    vec3 hitLocation;\n    vec3 normal;\n};\n\nvec2 gridify(vec2 uv, float split) {\n    return ceil(uv * split) / split;\n}\n\nRay makeRay(vec2 uv, Camera camera) {\n    // simplify the sensor width to be res.x / res.y\n    // simplify the sensor height to be 1.0\n    \n    // first solve for near clip plane:\n    // tan(FOV / 2.0) = midx / adj\n    // adj = (uv.x / 2.0) / tan(FOV / 2.0)\n    \n    float midx = 0.5 * iResolution.x / iResolution.y;\n    float midy = 0.5;\n    float clipDistance = midx / tan(camera.fov / 2.0);\n    \n    // origin of ray at clipDistance location will be:\n    // (clipDistance, 0.0, 0.0)\n    // i.e.\n    // f(midx, midy) = Ray(origin: 0.0, direction: 1.0)\n    \n    // 1. tackle the origin of the ray\n    // we make the assumption that up is orthogonal to \n    // diretion (should add in a check for this later)\n    // we are left to find the remaining basis, which is\n    // the cross product of the two\n    vec3 xbasis = normalize(cross(camera.direction, camera.up));\n    vec3 ybasis = camera.up;\n    vec3 zbasis = camera.direction;\n    \n    // multiply sensor dimensions by basis to get position of pixel\n    // in world space\n    vec3 x = (uv.x - midx) * xbasis;\n    vec3 y = (uv.y - midy) * ybasis;\n    vec3 z = clipDistance * zbasis;\n   \n    // add these all together\n    vec3 position = x + y + z;\n    \n    // normalize to get a unit vector from the position\n    vec3 direction = normalize(position);\n    \n    // then, add the camera position\n    vec3 origin = position + camera.position;\n    \n    \n    Ray ray = Ray(origin, direction);\n    return ray;\n}\n\nfloat intersect(Ray ray, Sphere sphere) {\n    float eps = 0.0000001;\n    float t = 0.0;\n\n    vec3 offset = sphere.position - ray.origin;\n    vec3 direction = ray.direction;\n    float dist = dot(offset, ray.direction);\n    \n    // Quadratic equation to solve for hit distance\n    float discriminant = dist * dist - \n        dot(offset, offset) + \n        sphere.radius * sphere.radius;\n    \n    if (discriminant < 0.0) {\n        return 99999999999.0;\n    } else {\n        discriminant = sqrt(discriminant);\n        t = dist - discriminant;\n        if (t > eps) {\n        \treturn t;   \n        } else {\n         \tt = dist + discriminant;\n            if (t > eps) {\n             \treturn t;   \n            }\n        }\n    }\n    \n    return 99999999999.0;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nHitData getHitData(Ray ray, Sphere spheres[SPHERES], vec2 uv) {\n    float minDistance = 999999999999999.0;\n    vec3 hitLocation = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    \n    Sphere closestSphere = spheres[0];\n\n    for (int i = 0; i < SPHERES; i++) {\n        Sphere sphere = spheres[i];\n        float d = intersect(ray, sphere);\n        if (d < minDistance) {\n            minDistance = d;\n            hitLocation = ray.origin + (ray.direction * minDistance);\n            normal = normalize(hitLocation - sphere.position);\n            closestSphere = sphere;\n\n            // Flip normals if we are inside of the sphere\n            if (length(sphere.position - ray.origin) < sphere.radius) {\n                normal = normal * -1.0;\n            }\n        }\n    }\n    \n    HitData hitData = HitData(closestSphere, hitLocation, normal);\n\treturn hitData;\n}\n\nvec3 processHitData(HitData hitData, vec2 uv, int idx) {\n    \n    vec3 bounce = vec3(0.0, 0.0, 0.0);\n    \n    if (hitData.sphere.type == 0) {\n\n        // Ray scatter randomize\n        // Get a random angle from 0 to 2 * PI\n        float rand1 = rand(\n            vec2(\n                uv.x * 1.32, \n                uv.y * 1.14\n            )) * 2.0 * PI;\n\n        // Get a random distance from 0 to 1\n        float rand2 = rand(\n            vec2(\n                uv.x * 1.932, \n                uv.y * 2.789\n            )\n        );\n\n        float rand2sqrt = sqrt(rand2);\n\n        // Coordinate system of bounce\n        // we let \"z\" (which we call w for this coordinate system)\n        // be the normal off of the sphere\n        \n        vec3 w = hitData.normal;\n\n        // We choose some generic vector to be \"x\".\n        // Make sure that it will not create a zero vector when crossed\n        // with \"z\".\n        vec3 u = abs(w.x) > 0.000001 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n        u = normalize(cross(u, w));\n        vec3 v = cross(w, u);\n\n        vec3 ubounce = cos(rand1) * rand2sqrt * u;\n        vec3 vbounce = sin(rand1) * rand2sqrt * v;\n        vec3 wbounce = normalize(sin(1.0 - rand2) * w);\n\n        bounce = normalize(ubounce + vbounce + wbounce);\n        //return vec3(rand1, 0.0, 0.0);\n\t\t\n    }\n    return bounce;\n}\n\nvec3 radiance(Ray ray, Sphere spheres[SPHERES], vec2 uv) {\n    HitData hitDatas[SAMPLES];\n    Ray original = ray;\n    \n    HitData hitData = getHitData(ray, spheres, uv);\n    vec3 color = hitData.sphere.color;\n    vec3 rad = hitData.sphere.emission * hitData.sphere.color;\n    \n    float maxReflectance = max(\n        max(hitData.sphere.color.x, hitData.sphere.color.y),\n        hitData.sphere.color.z\n    );\n    \n    if (hitData.sphere.emission > 0.999) {\n        return rad;\n    }\n    HitData prevHitData = hitData;\n    \n    for (int j = 0; j < SAMPLES; j++) {\n\t    vec3 bounce = processHitData(prevHitData, uv, j);\n        Ray newRay = Ray(prevHitData.hitLocation, bounce);\n        HitData hitData2 = getHitData(newRay, spheres, uv);\n        \n        vec3 newColor = hitData2.sphere.color;\n        color += (newColor / float(SAMPLES));\n        rad += hitData2.sphere.emission * hitData2.sphere.color;\n        \n        prevHitData = hitData2;\n    }\n    \n    //color = color / float(SAMPLES + 1);\n    return rad * color / float(SAMPLES + 1);\n    //return color;\n\n}\n\nvec3 pathtrace(vec2 uv, Camera camera, Sphere spheres[SPHERES]) {\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // TODO: Loop through this by samples/pixel\n    Ray ray = makeRay(uv, camera);\n    \n    // begin firing rays\n    vec3 color = radiance(ray, spheres, uv);\n   \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord / res.y;\n    \n    float split = 10000.0;\n    \n    vec3 position = vec3(0.0, 0.0, 0.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // We set the FOV to be 90 degrees\n    Camera camera = Camera(position, direction, up, PI / 2.0);\n    \n    // Scene setup\n    Sphere ceiling = Sphere(\n    \t1000.0,\n        vec3(0.0, 1003.0, 0.0),\n        0.0,\n        vec3(1.0, 0.0, 0.0),\n        0\n    );\n    Sphere left = Sphere(\n    \t1000.0,\n        vec3(1005.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere right = Sphere(\n    \t1000.0,\n        vec3(-1005.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere bottom = Sphere(\n    \t1000.0,\n        vec3(0.0, -1003.0, 0.0),\n        0.0,\n        vec3(0.0, 1.0, 1.0),\n        0\n    );\n    Sphere back = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, 1015.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere front = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, 990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere middle = Sphere(\n    \t1.0,\n        vec3(0.0, 2.0 * sin(1.5 * iTime), 8.0),\n        0.0,\n        vec3(0.0, 1.0, 0.0),\n        0\n    );\n    Sphere light = Sphere(\n    \t2.0,\n        vec3(0.0, 0.0, 11.5),\n        1.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere light2 = Sphere(\n    \t1.0,\n        vec3(-1.0, 0.0, 5.0),\n        1.0,\n        vec3(1.0, 1.0, 1.0),\n        0\n    );\n    Sphere spheres[SPHERES];\n    spheres[0] = middle;\n    spheres[1] = back;\n    spheres[2] = left;\n    spheres[3] = right;\n    spheres[4] = ceiling;\n    spheres[5] = bottom;\n    spheres[6] = front;\n    spheres[7] = light;\n    //spheres[8] = light2;\n    \n    vec2 grid = gridify(uv, split);\n    vec3 result = pathtrace(grid, camera, spheres);\n    \n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}