{"ver":"0.1","info":{"id":"lXfBzs","date":"1728774304","viewed":36,"name":"learning_experiment_8","username":"austinoxyz","description":"learning experiment, number 8\n\nmeh","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["experiment","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (2.*iTime)\n#define res (iResolution)\n#define PI (3.141592)\n\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318*(c*t+d));\n}\n\nmat2 rot2D(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle) {\n\treturn mix(dot(axis, p) * axis, p, cos(angle)) \n            + cross(axis, p) * sin(angle);\n}\n\nfloat sdf_box3(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf_box2(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdf_cross(in vec3 p) {\n  float da = sdf_box2(p.xy,vec2(1.0));\n  float db = sdf_box2(p.yz,vec2(1.0));\n  float dc = sdf_box2(p.zx,vec2(1.0));\n  return min(da,min(db,dc));\n}\n\nfloat menger(vec3 p) {\n    float d = sdf_box3(p, vec3(1.));\n    float s = 1.0;\n    for (int n=0; n<3; n++)\n    for (int m=0; m<3; m++) {\n        vec3 a = mod(p*s, 2.0)-1.0;\n        s *= 3.0;\n        vec3 r = 1.0 - 3.0*abs(a);\n        float c = sdf_cross(r)/s;\n        d = max(d, c);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - res.xy) / res.y;\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 col = vec3(0.);\n\n    // animation\n    float a = cos(time);\n    float j = floor(time/PI);\n    mat2 rot = rot2D((PI/4.)*cos(time)-(PI/4.));\n    if (mod(j, 2.) == 0.) {\n        rd.xz *= rot;\n    } else {\n        rd.yz *= rot;\n    }\n    \n    // raymarching\n    float c, t = 0.;\n    for (int i = 0; i < 80 && t < 100.; ++i) {\n        float h = menger(ro + rd*t);\n        if (h < 0.001) {\n            c = .2/t;\n            c = smoothstep(0., 1., c);\n            c = pow(c, 1.2);\n            break;\n        }\n        t += h;\n    }\n    \n    col = palette(1.2*c);\n    if (t > 100.)\n        col *= .23;\n    col = col;\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}