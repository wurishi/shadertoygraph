{"ver":"0.1","info":{"id":"WdlBD8","date":"1588154540","viewed":185,"name":"Day11: Cubic Bezier","username":"fluxatron","description":"Just practicing some maths and having fun with shadertoy!\n\nI researched these cubic bezier functions about 3-4 years back and was surprised to find I could code this in an hour without looking anything up! Weird how the brain retains such random info.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["cubicbezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// TYPES //////////////////////////////////////////////////////////////////////////////////\nstruct CubicBezierSegment\n{\n    vec2 A, B;   // Vertices A and B the line is drawn between\n\tvec2 CA, CB; // Control points for verts A/B control the shape\n};\n\nstruct BezierLook\n{\n    vec3 BezierCol;\n    vec3 HandleCol;\n    vec3 LineCol;\n    float BezierThicc;\n};\n    \nstruct Hit\n{\n    float Dist;\n    vec3 Col;\n};\n    \n\n// TRANSFORMATIONS ////////////////////////////////////////////////////////////////////////\nmat2 Rotate(float rads) \n{ \n    float s = sin(rads); \n    float c = cos(rads); \n    return mat2(c, s, \n               -s, c); \n}\n\n\n// SHAPES /////////////////////////////////////////////////////////////////////////////////\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\nfloat sdLineSegment(vec2 p, vec2 a, vec2 b, float halfThicc)\n{\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    float h = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // project ap onto ab\n\treturn length( ap - ab*h ) - halfThicc; // finds length of vec from p to the projection of p onto ab\n}\n\nvec2 SampleBezier(CubicBezierSegment seg, float t)\n{\n    // First degree\n    vec2 p11 = mix(seg.A, seg.CA, t);\n    vec2 p12 = mix(seg.CA, seg.CB, t);\n    vec2 p13 = mix(seg.CB, seg.B, t);\n\n    // Second degree\n    vec2 p21 = mix(p11, p12, t);\n    vec2 p22 = mix(p12, p13, t);\n\n    // Third degree\n    return mix(p21, p22, t);\n}\n\n\n// SCENE  /////////////////////////////////////////////////////////////////////////////////\nHit Closest(Hit a, Hit b)\n{\n    // Not sure how to be more performance with this as the ternary operator doesn't support structs :|\n    if (a.Dist <= b.Dist) \n    \treturn a;\n    else\n        return b;\n}\n\nHit HitSegment(vec2 p, CubicBezierSegment seg, BezierLook look)\n{\n    const int subdivs = 30;\n    \n    Hit hit;\n    hit.Dist = 999999.;\n    Hit newHit;\n    \n      \n    // Vertices\n    newHit.Col = look.HandleCol;\n    //newHit.Dist = sdCircle(p-seg.A, 0.02); hit = Closest(hit, newHit);\n    //newHit.Dist = sdCircle(p-seg.B, 0.02); hit = Closest(hit, newHit);\n    \n    // Control Points\n    newHit.Col = look.HandleCol*0.75;\n    newHit.Dist = sdCircle(p-seg.CA, 0.025); hit = Closest(hit, newHit);\n    newHit.Dist = sdCircle(p-seg.CB, 0.025); hit = Closest(hit, newHit);\n\n    // Lines\n    newHit.Col = look.LineCol;\n    newHit.Dist = sdLineSegment(p, seg.A, seg.CA, 0.); hit = Closest(hit, newHit);\n    newHit.Dist = sdLineSegment(p, seg.B, seg.CB, 0.); hit = Closest(hit, newHit);\n    \n\t// Cubic Bezier\n    newHit.Col = look.BezierCol;\n    vec2 last = SampleBezier(seg, 0.);\n    for (int i = 1; i <= subdivs; i++)\n    {\n        float t = float(i)/float(subdivs);\n        vec2 s = SampleBezier(seg, t);\n        \n       \tnewHit.Dist = sdLineSegment(p, last, s, look.BezierThicc*0.5); hit = Closest(hit, newHit);\n        \n        last = s;\n    }\n    \n    return hit;\n}\n\nvec3 Scene(vec2 p, float aspect, vec2 mouse)\n{\n    BezierLook look;\n    look.BezierCol = vec3(0.8,0.2,0.4);\n    look.LineCol = vec3(1,1,1)*0.5;\n    look.HandleCol = vec3(1,1,1);\n    look.BezierThicc = 0.02;\n    \n    vec2 v1 = vec2(-.75, 0);\n    vec2 v2 = vec2(0, 0);\n    vec2 v3 = vec2(.75, 0);\n    \n    CubicBezierSegment seg1;\n    seg1.A  = v1;\n    seg1.B  = v2;\n    seg1.CA = mouse;//v1 + 0.7* vec2(sin(iTime*.75), cos(iTime*.75));\n    seg1.CB = v2 - 0.5* vec2(cos(iTime*1.4), sin(iTime*1.4+1.));\n    \n    CubicBezierSegment seg2;\n    seg2.A  = v2;\n    seg2.B  = v3;\n    seg2.CA = v2 + v2-seg1.CB;\n    seg2.CB = v3 + 0.7* vec2(sin(iTime*.75), -cos(iTime*.75));\n    \n    \n    Hit closest;\n    closest.Dist = 9999999.;\n    closest = Closest(closest, HitSegment(p, seg1, look));\n    closest = Closest(closest, HitSegment(p, seg2, look));\n    \n    return closest.Col * smoothstep(0.005,0.,closest.Dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.yy; // -[aspect,1] to [aspect,1]\n    vec2 uvNorm = fragCoord/iResolution.xy; // [0,0] to [1,1]\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.yy;\n\n    vec3 col = vec3(0);\n    col = vec3(uvNorm,1) * 0.2;\n    col += Scene(uv, aspect, mouse);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}