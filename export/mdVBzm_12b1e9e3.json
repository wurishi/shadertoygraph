{"ver":"0.1","info":{"id":"mdVBzm","date":"1698089497","viewed":83,"name":"Blackish Hole","username":"Peace","description":"Simple physically inaccurate, though cool blackhole","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["hole","black"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 2048;\n#define SURFACE_DIST (2.0 / min(iResolution.x, iResolution.y))\nconst float PI = 3.14159265359;\n\n#define BH_POS vec3(cos(iTime * 0.2), sin(iTime * 0.2), 0)\n#define R 0.25\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    Ray ray;\n    float fov;\n};\nCamera camera;\n\nstruct SDFInfo\n{\n    float dist;\n    int id;\n};\n\nstruct Hit\n{\n    float dist;\n    float min_dist;\n    vec3 point;\n    vec3 normal;\n    int id;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 color;\n};\n\nvec3 getDir(vec2 uv)\n{\n     return normalize(vec3(uv, tan((PI - radians(camera.fov)) * 0.5)));\n}\n\nfloat hitAmount(Hit hit)\n{\n    return clamp((SURFACE_DIST * 2.0 - hit.min_dist) / SURFACE_DIST, 0.0, 1.0);\n}\n\nvec3 gammaCorrect(vec3 color, float gamma)\n{\n    return pow(color, vec3(1.0 / gamma));\n}\n\nfloat diffuse(vec3 normal, vec3 light_dir)\n{\n    return max(0.0, dot(normal, light_dir));\n}\n    \nfloat specular(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    vec3 halfway = normalize(light_dir + ray_dir);\n    return max(0.0, dot(normal, halfway));\n}\n\nvoid addSDF(inout SDFInfo sdf, SDFInfo new_sdf)\n{\n    if (sdf.dist <= new_sdf.dist)\n        return;\n    sdf = new_sdf;\n}\n\nSDFInfo SDF(vec3 point)\n{\n    SDFInfo sdf;\n    sdf.dist = 1e9;\n    addSDF(sdf, SDFInfo(length(point - BH_POS) - R, 1));\n    return sdf;\n}\n\nvec3 getNormal(vec3 point, float dist)\n{\n    vec2 e = vec2(0.002, 0.0);\n    return normalize(dist - vec3(SDF(point - e.xyy).dist, SDF(point - e.yxy).dist, SDF(point - e.yyx).dist));\n}\n\nHit raymarch(Ray ray)\n{\n    Hit hit;\n    hit.min_dist = 999999.0;\n    hit.point = ray.pos;\n    vec3 dir = ray.dir;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        SDFInfo sdf = SDF(hit.point);\n        float d = abs(sdf.dist);\n        if (d < hit.min_dist) \n        {\n            hit.min_dist = d;\n            hit.normal = getNormal(hit.point, hit.min_dist);\n            hit.id = sdf.id;\n            if (d <= SURFACE_DIST)\n                break;\n        }\n        float t = d * 0.03;\n        hit.point += dir * t;\n        hit.dist += t;\n        const float G = 0.5;\n        float b = 1.0 / pow(length(hit.point - BH_POS) - R * R, 2.0) * G;\n        dir += normalize(BH_POS - hit.point) * t * b;\n    }\n    \n    return hit;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) \n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) \n{\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res;\n    vec3 color = vec3(0);\n    \n    camera.fov = 90.0;\n    camera.ray.pos = vec3(0, 0, -1);\n    camera.ray.dir = getDir(uv);\n    vec2 m = (iMouse.x == 0.0 && iMouse.y == 0.0) ? (iMouse.xy + iResolution.xy * 0.5) : iMouse.xy;\n    camera.ray.dir = rotate(camera.ray.dir, vec3(0, -1, 0), m.x / iResolution.x * PI * 2.0 - PI);\n    camera.ray.dir = rotate(camera.ray.dir, vec3(1, 0, 0), m.y / iResolution.y * PI * 2.0 - PI);\n    \n    Hit hit = raymarch(camera.ray);\n    vec3 no_hit_col = texture(iChannel0, hit.point).rgb;\n    float hit_amount = hitAmount(hit);\n    if (hit_amount <= 0.0)\n    {\n        fragColor = vec4(no_hit_col, 1);\n        return;\n    }\n    \n    \n    Light light;\n    light.pos = vec3(600, 800, -500);\n    light.color = vec3(0.7);\n    vec3 light_dir = normalize(light.pos - hit.point);\n    \n    float spec = pow(specular(light_dir, normalize(camera.ray.pos - hit.point), hit.normal), 32.);\n    vec3 total_light = light.color * (0.02 + 0.5 * spec + diffuse(hit.normal, light_dir));\n\n    vec3 hit_col = (hit.id == 1) ? vec3(0) : no_hit_col;\n    color = gammaCorrect(total_light, 2.2) * hit_col;\n\n    fragColor = vec4(mix(no_hit_col, color, hit_amount), 1);\n}","name":"Image","description":"","type":"image"}]}