{"ver":"0.1","info":{"id":"cdyyzy","date":"1697620597","viewed":113,"name":"Tennis ball mapping","username":"gehtsiegarnixan","description":"I made this spheremapping function to map a 2D texture onto a sphere without edges and even pixel density using only 2 texture sampels. This uses the SDF of a tennis ball to merge the two samples.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["3d","uv","sphere","normal","mapping","seamless","tennis","spheremap","tennisball","tbn"],"hasliked":0,"parentid":"XdfGRn","parentname":"Apple"},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\nI created this algorithm to seamlessly tile a texture over a sphere \nwith little distortions and no edges. It uses only 2 texture lookups.\n\nThis works by having 2 spheremappings. One is rotated so the edges of the \nspheremapping do not meet. I created a mask the blend between the edges\nthat has the same pattern as a tennisball. This mapping includes normals \ntoo. The blend region is currently hidden by the glue-line, but you can \nmake it visible by enabling SHOWBLEND. \n\nThere are several global constants below to enable debug views of the\nmapping and mouse controls to look around.\n\nSee also my demo for tangent space matrix of spheremaps:\nhttps://www.shadertoy.com/view/ctXfDS\n*/\n\n// enables debug grid where the two mappings blend with each other\n// Green and Red are the upper and lower bounds of the weights\n// Blue and White is the edge where one tiling breaks\n//#define SHOWBLEND\n#define LINETHICKNESS 0.02\n\n// 1 no contrast, higher values increase contrast\n#define CONTRAST 16.0\n\n// enable to show the alpha/weights otherwise shows textures\n//#define SHOWALPHA\n\n// Signed distance function of a tennis ball, the glueline would be at 0.5\nfloat tennisballSDF (vec3 normal) {\n    // half pi to rescale radians to 0-1 range\n    float halfPI = 1.57079632;\n    \n    // combine halfs of SDF\n    float tennisballSDF;\n    if (normal.x > 0.) {\n        // poles\n        tennisballSDF = 1.- acos(abs(normal.z))/ (halfPI); \n    } else {\n        // seam of the edge between poles\n        tennisballSDF = acos(abs(normal.y))/ (halfPI); \n    }\n    return tennisballSDF;    \n}\n\n//Spherical mapping\nvec2 sphereMap(vec3 normal) {\n    // merkator projection\n    float u = 0.5 + atan(normal.y, normal.x) / (2.*3.1415);\n    float v = 0.5 + asin(normal.z) / 3.1415;\n    return vec2(u, v);\n}\n\n// TBN Matrix for the spheremapping above\nmat3 sphereTBNMatrix(vec3 normal) {\n    // vec3 poleAxis = vec3(0,0,1.);\n    // vec3 tangent = normalize(cross(poleAxis, normal));\n    vec3 tangent = normalize(vec3(-normal.y, normal.x, 0.));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\n// simple spheremap texture sampler\nmaterialVal sphereMapSample(sampler2D tex, vec3 normal, float scale) {\n    // sample spheremap\n    vec2 uv = sphereMap(normal);\n    \n    // apply scale\n    uv *= scale;    \n    \n    // sample tbn matrix\n    mat3 tbn = sphereTBNMatrix(normal);  \n    \n    // sample texture, since we hide the seam we can ignore mips\n    vec3 color = texture(tex, uv).xyz;\n\n    // sample normal, if you can obviously use a normal texture instead\n    vec3 tsNormal = HeightToNormal(tex, uv, iChannelResolution[0].xy, 4.0);\n    // translate normals to world space\n    vec3 wsNormal = tbn * tsNormal;\n\n    // pack everything into a struct\n    return materialVal(color, wsNormal, 0.);\n}\n\nmaterialVal tennisballmap(sampler2D tex, vec3 normal, float scale, float contrast) {  \n    // rotated spheremap to align with tennisball other side\n    vec3 rotatedNormal = vec3(-normal.x, normal.z, normal.y); \n\n    // sample textures\n    materialVal sphereA = sphereMapSample(tex, normal, scale);\n    materialVal sphereB = sphereMapSample(tex, rotatedNormal, scale);\n\n    // sample blend weight\n    float alpha = tennisballSDF(normal);\n    \n    // increase contrast of tennisball mask\n    float contrastAlpha = smoothContrast(alpha, contrast);\n\n    #ifdef SHOWALPHA\n        // show alpha/weights with best colormap for better readability\n        vec3 col = viridis(contrastAlpha);\n    #else    \n        // interpolate between mappings to remove edges and poles\n        vec3 col = mix(sphereA.color, sphereB.color, contrastAlpha);\n    #endif\n        \n    // since sphere B is rotated its normals need to be rotated as well\n    vec3 wsNormalB = vec3(-sphereB.normal.x, sphereB.normal.z, sphereB.normal.y);\n    \n    // interpolate normals, Slerp may be better, but I can't tell the differene\n    vec3 wsNormal = normalize(mix(sphereA.normal, wsNormalB, contrastAlpha));\n    \n    #ifdef SHOWBLEND\n        // overlaying the edges of the alpha mask\n        vec2 blend = step(abs(vec2(contrastAlpha, 1.-contrastAlpha)-0.1), vec2(LINETHICKNESS));\n\n        // edge of the mappings\n        float edgeA = step(alpha, LINETHICKNESS);;\n        float edgeB = step(tennisballSDF(rotatedNormal), LINETHICKNESS);\n\n        // join color\n        col = max(max(col, vec3(blend, edgeA)), vec3(edgeB));\n    #endif\n    \n    // pack everything into a struct\n    return materialVal(col, wsNormal, alpha);\n}\n\n// samples tennisball textures and applies tennis ball colors\nmaterialVal tennisball(sampler2D tex, vec3 normal, float scale, float contrast) {\n    // sample textures\n    materialVal ball = tennisballmap(tex, normal, scale, contrast);\n   \n    // center the mask on the line at 0.5\n    float line = abs(ball.mask-0.5)*2.;\n    \n    // calculate a little dark line around the glue edge\n    float glueWidth = 0.08;\n    float tintWidth = 0.04;\n    float tint = smoothstep(glueWidth + tintWidth, glueWidth - tintWidth, line);\n    \n    // define ball colors\n    vec3 glueColor = vec3(0.824,0.827,0.749) * tint;\n    vec3 feltColor = vec3(0.937,0.953,0.086) - (ball.color * 0.5);\n    \n    // caluclate smoothstep for weight between glue and felt\n    float stepWidth = 0.02;\n    float alpha = smoothstep(glueWidth - stepWidth,glueWidth + stepWidth, line);\n    \n    // blend colors\n    vec3 color = mix(glueColor, feltColor, alpha);\n    \n    // interpolate normals, Slerp may be better, but I can't tell the differene\n    vec3 wsNormal = normalize(mix(normal, ball.normal, alpha));\n    \n    return materialVal(color, wsNormal, ball.mask);\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n    } else {\n        mx = mm2(-iTime*.2+um.x*5.);\n        my = mm2(iTime*0.1+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float t = iSphere(ro,rd);\n    \n    vec3 lightDir = normalize(vec3(1,0,1));\n\n    // alternate between backgroudn and sphere mapping\n    vec3 color;\n    if (t > 0.) {\n        // Sphere mapping\n    \tvec3 normal = ro+rd*t;\n                \n        #if defined(SHOWBLEND) || defined(SHOWALPHA)\n            // sample albedo textures\n            materialVal cube = tennisballmap(iChannel0, normal, 10., CONTRAST);\n        \n            color = cube.color;\n        #else\n            // sample albedo textures\n            materialVal cube = tennisball(iChannel0, normal, 10., CONTRAST);\n            \n            // Apply lighting to show the normals too\n            color = phongLighting(cube.color, cube.normal, ro, lightDir);\n        #endif\n        \n    } else {\n        // Background mapping\n        vec3 normal = rd;\n        \n        // make tennisball sdf\n        float alpha = tennisballSDF(normal);\n        \n        // increase contrast a bit\n        alpha = smoothContrast(1.-alpha, 1.5);\n    \n        // apply best colormap\n        vec3 albedo = viridis(alpha);\n        \n        #if defined(SHOWBLEND) || defined(SHOWALPHA)\n            // make color a bit darker for better contrast with sphere\n            color = pow(albedo, vec3(1.5));\n        #else\n            // simple sun with halo\n            vec3 sun = sun(normal, lightDir);\n\n            // combine albedo and sunlight\n            color = albedo + sun;\n        #endif\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//_________________________GENERIC FUNCTIONS_____________________________________\n#define SUN_COLOR vec3(0.894,0.702,1.000)\n\n// Struct to hold material values\nstruct materialVal {\n    vec3 color;\n    vec3 normal;\n    float mask;\n};\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.35;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 1.5;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 36.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// This function creates a simple sun with a halo effect.\nvec3 sun(vec3 normal, vec3 lightDir) {\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) / 3.14159;\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 50.0) * 3.0;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * SUN_COLOR;\n}\n\n// Increases the steepness of Alpha while forcing 0-1 range and 1 sum\n// See desmos graph example https://www.desmos.com/calculator/n6gpory8yq\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    vec2 powAlpha = pow(vec2(alpha, 1.-alpha), vec2(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha.x/(powAlpha.x + powAlpha.y);\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal(sampler2D tex, vec2 uv, vec2 res, float strength) {\n    vec2 s = 1.0 / res;\n    \n    float textureOffset = 1.0;\n    \n    float p = texture(tex, uv).x;\n    float h1 = texture(tex, uv + s * vec2(textureOffset,0)).x;\n    float v1 = texture(tex, uv + s * vec2(0,textureOffset)).x;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return normalize(vec3(xy * strength, 1.0));\n}","name":"Common","description":"","type":"common"}]}