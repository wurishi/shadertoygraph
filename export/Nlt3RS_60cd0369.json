{"ver":"0.1","info":{"id":"Nlt3RS","date":"1636352980","viewed":189,"name":" Mandelbulb by seven_dc ","username":"seven_dc","description":"rotating mandelbulb raymarcher","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulbraymarch"],"hasliked":0,"parentid":"ssGGWc","parentname":"Flaming Mandelbulb"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 60\n#define MAX_DIST 2.5\n#define SURF_DIST .0001\n\n#define ITERATIONS 10\n#define BAILOUT 10.\n\nmat2 Rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\n\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec2 DE(vec3 pos) {\n    float POWER = 5. +sin(iTime)*2.;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    int i = 0;\n\tfor (i = 0; i < ITERATIONS ; i++) {\n\t\tr = length(z);\n\t\tif (r>BAILOUT) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, POWER-1.0)*POWER*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,POWER);\n\t\ttheta = theta*POWER;\n\t\tphi = phi*POWER;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn vec2(0.5*log(r)*r/dr,i);\n}\n\nvec2 GetDistance(vec3 point) {\n    vec3 p = point;\n    p.z -=  1.;\n    p.yz *= Rotate(iTime/2.);\n    p.xy *= Rotate(cos(iTime/5.));\n    return DE(p);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    vec2 d = vec2(0.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        d = GetDistance(point);\n        float surfaceDistance = d.x;\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance, d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    float diff = iTime/10.;\n    vec3 rayOrgin = vec3(0., 0., -1.);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    vec2 data = RayMarch(rayOrgin, rayDirection);\n  \n    float r = 0.;\n    float g = smoothstep(0.1,.5,1.-data.y/10.);\n    float b = 1.-data.y/10.;\n    \n    vec3 col = vec3(r,g,b);\n    if (data.x > 2.3) {\n        col *= .2;\n        col.b = uv.y + .3;\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}