{"ver":"0.1","info":{"id":"tstyDM","date":"1601062961","viewed":395,"name":"eindacor_kaleidoscope","username":"Eindacor_DS","description":"it's a kaleidoscope, you dolt!","likes":6,"published":1,"flags":2,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define MAIN_TRIANGLE_HEIGHT .5f\n#define TWOPI 6.28318530718f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n\n#define u_TimeScaleModifier 0.1f\n#define u_HexRadius .8f\n#define u_HexBorderThickness 0.f\n#define u_HexTriangleThickness 0.f\n#define u_HexCenterRadius 0.0f\n#define u_KaleidoscopeLevels 3\n#define u_BorderColor vec4(1.f, 1.f, 1.f, 1.f)\n#define u_TriangleColor vec4(1.f, 1.f, 1.f, 1.f)\n#define u_HexCenterColor vec4(1.f, 1.f, 1.f, 1.f)\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nbool isHexCenter(vec2 pos, float hexXIncrement, float hexYIncrement) {\n    float columnIndex = round(pos.x / hexXIncrement);\n    float rowIndex = round(pos.y / hexYIncrement);\n    return int(round(mod(abs(columnIndex), 2.f))) == int(round(mod(abs(rowIndex), 2.f)));\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec3 vec2Tovec3(vec2 vec) {\n    return vec3(vec.x, vec.y, 0.f);\n}\n\nstruct KaleidSampleData {\n    vec4 color;\n    vec2 uv;\n};\n\nvec2 getHexCenter(vec2 aspectUV, \n                    vec2 leftBottom, \n                    vec2 leftTop, \n                    vec2 rightBottom, \n                    vec2 rightTop,\n                    float aspectHexGridXIncrement, \n                    float hexGridYIncrement,\n                    float aspectHexRadius) {\n    vec2 hexCenter = vec2(-1.f, -1.f); \n\n    // // if uv is close to hexCenter -> hexDiagRight || hexDiagLeft, return border color\n    if (isHexCenter(leftBottom, aspectHexGridXIncrement, hexGridYIncrement)) {\n        vec2 hexDiagRight = leftBottom + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = leftTop + vec2(aspectHexRadius / 2.f, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagLeft - hexDiagRight));\n        vec2 sharedToRightTopVector = normalize(vec2(rightTop - hexDiagRight));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagRight));\n\n        vec3 crossRightTop = cross(vec2Tovec3(sharedEdgeVector), \n                                    vec2Tovec3(sharedToRightTopVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = (crossRightTop.z == crossUV.z) || \n            (crossRightTop.z < 0.f && crossUV.z < 0.f) || \n            (crossRightTop.z > 0.f && crossUV.z > 0.f) ? rightTop : leftBottom;\n    } else {\n        vec2 hexDiagRight = leftTop + vec2(aspectHexRadius, 0.f);\n        vec2 hexDiagLeft = rightBottom - vec2(aspectHexRadius, 0.f);\n        vec2 sharedEdgeVector = normalize(vec2(hexDiagRight - hexDiagLeft));\n        vec2 sharedToRightBottomVector = normalize(vec2(rightBottom - hexDiagLeft));\n        vec2 sharedToUVVector = normalize(vec2(aspectUV - hexDiagLeft));\n\n        vec3 crossRightBottom = cross(vec2Tovec3(sharedEdgeVector), \n                                        vec2Tovec3(sharedToRightBottomVector));\n        vec3 crossUV = cross(vec2Tovec3(sharedEdgeVector), \n                                vec2Tovec3(sharedToUVVector));\n\n        hexCenter = crossRightBottom.z == crossUV.z || \n            (crossRightBottom.z < 0.f && crossUV.z < 0.f) || \n            (crossRightBottom.z > 0.f && crossUV.z > 0.f) ? rightBottom : leftTop;\n    }\n\n    return hexCenter;\n}\n\nKaleidSampleData getKaleidoscopedUV(vec2 uv, \n                        AspectRatioData aspectRatioData, \n                        float hexRadius, \n                        float shortRadius, \n                        float angle,\n                        float hexGridXIncrement,\n                        float hexGridYIncrement) \n{\n    vec2 aspectUV = uv * aspectRatioData.scaleMatrix;\n\n    float aspectHexGridXIncrement = hexGridXIncrement;\n\n    float leftEdge = floor(aspectUV.x / aspectHexGridXIncrement) * aspectHexGridXIncrement;\n    float rightEdge = leftEdge + aspectHexGridXIncrement;\n    float bottomEdge = floor(aspectUV.y / hexGridYIncrement) * hexGridYIncrement;\n    float topEdge = bottomEdge + hexGridYIncrement;\n\n    KaleidSampleData kaleidSampleData;\n    kaleidSampleData.color = vec4(0.f, 0.f, 0.f, 0.f);\n    kaleidSampleData.uv = vec2(0.f, 0.f);\n    \n    vec2 leftBottom = vec2(leftEdge, bottomEdge);\n    vec2 leftTop = vec2(leftEdge, topEdge);\n    vec2 rightTop = vec2(rightEdge, topEdge);\n    vec2 rightBottom = vec2(rightEdge, bottomEdge);\n\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(aspectUV,\n                            leftBottom, \n                            leftTop, \n                            rightBottom, \n                            rightTop, \n                            aspectHexGridXIncrement, \n                            hexGridYIncrement,\n                            aspectHexRadius);\n\n    float offsetAngle = getOffsetAngle(hexCenter, aspectUV);\n    // mulitplying by 5 rotates the uv so the default orientation (0 radians) is facing downward\n    offsetAngle = mod(TWOPI - offsetAngle + 5.f * TWOPI / 6.f, TWOPI);\n    \n    int offsetIndex = int(round(floor(offsetAngle / angle)));\n         \n    //kaleidSampleData.color = vec4(float(offsetIndex) / 6.f, 0.f, 0.f, 1.f);\n\n    float rotation = float(offsetIndex) * angle;\n    \n    mat2x2 rotationMatrix = createRotationMatrix(rotation);\n\n    vec2 kaleidUV = (aspectUV - hexCenter) * rotationMatrix;\n    // kaleidUV is below 0,0 (upper left) with the perfect triangle inverted below \n    // (y flipped in hlsl)\n\n    float aspectRatio = aspectRatioData.aspectRatio;\n    float sampleY = kaleidUV.y / shortRadius;\n    // this identifies where it is in the triangle, not the image\n    float triangleXCoord = (kaleidUV.x + hexRadius / 2.f) / hexRadius; \n\n    float imageWidthAtScale = shortRadius * aspectRatio;\n    float imageTriangleDelta = imageWidthAtScale - hexRadius;\n    float sampleX = (imageTriangleDelta / 2.f + triangleXCoord * hexRadius) / imageWidthAtScale;\n\n    if (offsetIndex % 2 == 1) {\n        sampleX = 1.f - sampleX;\n    }\n\n    kaleidSampleData.uv = vec2(clamp(sampleX, 0.f, 1.f), clamp(sampleY, 0.f, 1.f));\n\n    if (u_HexTriangleThickness > .0001f) {\n        mat2x2 triangleTestRotationMatrix = createRotationMatrix(SIXTY_DEGREES / 2.f);\n        float thicknessCheck = u_HexTriangleThickness * .25f;\n\n        vec2 relocatedUV = kaleidUV * createRotationMatrix(SIXTY_DEGREES / 2.f);\n        float colorVal = smoothstep(thicknessCheck + AA, thicknessCheck - AA, abs(relocatedUV.x));\n        kaleidSampleData.color = mix(kaleidSampleData.color, u_TriangleColor, colorVal);\n\n        relocatedUV = kaleidUV * createRotationMatrix(-SIXTY_DEGREES / 2.f);\n        colorVal = smoothstep(thicknessCheck + AA, thicknessCheck - AA, abs(relocatedUV.x));\n        kaleidSampleData.color = mix(kaleidSampleData.color, u_TriangleColor, colorVal);\n    }\n\n    if (u_HexBorderThickness > .0001f) {\n        float borderThickness = 1.f - u_HexBorderThickness * .5f;\n        float borderVal = smoothstep(borderThickness - AA, borderThickness + AA, kaleidSampleData.uv.y);\n        kaleidSampleData.color = mix(kaleidSampleData.color, u_BorderColor, borderVal);\n    }   \n\n    if (u_HexCenterRadius > .0001f) {\n        float centerDist = distance(aspectUV, hexCenter);\n        float colorVal = smoothstep(u_HexCenterRadius * .5f + AA, \n                                            u_HexCenterRadius * .5f - AA, centerDist);\n\n        kaleidSampleData.color = mix(kaleidSampleData.color, u_HexCenterColor, colorVal);\n    }\n\n    return kaleidSampleData;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    KaleidSampleData kaleidSampleData;\n    kaleidSampleData.uv = fragCoord/iResolution.xy;\n\n    float shortRadius = u_HexRadius * sin(SIXTY_DEGREES);\n\n    float hexGridXIncrement = 1.5f * u_HexRadius;\n    float hexGridYIncrement = shortRadius;\n\n    float timeScale = iTime * .5f * u_TimeScaleModifier;\n\n    vec4 borderColorAgg = vec4(0.f, 0.f, 0.f, 0.f);\n    float borderColorVal = 0.f;\n\n    for (int i=0; i<u_KaleidoscopeLevels; i++) {\n        float noiseVal = hash(vec2(float(i), 0.f));\n        kaleidSampleData.uv += vec2(sin(timeScale + noiseVal), timeScale);\n        kaleidSampleData = getKaleidoscopedUV(\n            kaleidSampleData.uv, \n            aspectRatioData, \n            u_HexRadius, \n            shortRadius, \n            SIXTY_DEGREES,\n            hexGridXIncrement,\n            hexGridYIncrement);\n\n        borderColorAgg += kaleidSampleData.color;\n    }\n  \n    vec4 outColor = mix(texture(iChannel0, kaleidSampleData.uv), borderColorAgg, borderColorAgg.a);\n\n    outColor.a = 1.f;\n    fragColor = outColor;\n}\n","name":"Image","description":"","type":"image"}]}