{"ver":"0.1","info":{"id":"MtKBDR","date":"1543177978","viewed":130,"name":"Architecture1","username":"jkashimura","description":"taft","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\nconst float EPSILON = 0.001;\nconst vec3 deltax = vec3(EPSILON, 0., 0.);\nconst vec3 deltay = vec3(0., EPSILON, 0.);\nconst vec3 deltaz = vec3(0., 0., EPSILON);\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n    \n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    d = max(d, abs(p.y) - h);\n    return d;\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n\n\nfloat sphere(vec3 v, float r) {\n    return length(v) - r;\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.* s)) - s)));\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n//=======================\n\nShape Building(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  // Coordinate Systems\n\n    \n  vec3 g = c; // Ground\n  vec3 s = c; // Arch Bottom \n  vec3 f = c; // Arch Top\n   \n  vec3 s1 = c; //second arch bottom\n  vec3 f1 = c; //second arch top\n    \n  vec3 a = c; //wall\n  vec3 a1 = c; //2nd wall\n  vec3 a2 = c; //3rd wall\n  vec3 b = c; //door\n  vec3 j = c; //door bottom\n  vec3 h = c; //doorside\n  vec3 i = c; //backdoor\n  vec3 l = c; //line\n  vec3 l1 = c; //2nd line\n  vec3 l2 = c; //3rd line\n  vec3 dl = c; //door line\n  vec3 k = c; //door knob\n  vec3 w = c; //window\n  vec3 tl = c; //top line\n  vec3 tl1 = c; //2nd top line\n  vec3 tl2 = c; //3rd top line\n  vec3 tl3 = c; //4th topline \n  vec3 hl = c; //horizontal line  \n  vec3 hl1 = c; //2nd horizontal line  \n  vec3 hl2 = c; //3rd horizontal line  \n  vec3 hl3 = c; //4th horizontal line  \n  vec3 hl4 = c; //5th horizontal line  \n  vec3 hl5 = c; //6th horizontal line  \n  vec3 hl6 = c; //7th horizontal line  \n  vec3 hl7 = c; //8th horizontal line  \n  vec3 p = c; //picture frame\n  vec3 d1 = c; //2nd door\n    \n  // Arch Rectangle\n  vec4 iColor = vec4(1.,1.,0.8,1.);\n  float archBottom = fBox(s+vec3(0., -0.5, -5.), vec3(4., 2.0, 0.1));\n  \n  // Arch Sphere\n  f.y *= cos(sin(f.y*.22)*1.3);//stretch \n  float archTop = sphere(f+vec3(0.,0.2,-5.), 2.1);\n      \n \n    \n  // Ground\n  vec4 gColor = vec4(1.,.3,.3,1.); //brown\n  g.xy *= rot(radians(90.)); \n\n  float ground = fBox(g+vec3(2.,0.,2.), vec3(0.25, 3.25, 2000000.75));\n \n    \n  //wall\n  a.x = abs(a.x) - 3.9; //mirror\n  vec4 aColor = vec4(1.,.9,.8,1.); //beige\n  float wall = fBox(a+vec3(2.,-0.3, -5.), vec3(.2, 2.5, 7.));   \n  wall = fOpUnionStairs(ground, wall, 0.3, 1.2);\n    \n  //2nd wall\n  vec4 a1Color = vec4(.8,.85,.8,1.); //grey\n  float wall1 = fBox(a1+vec3(0., -2., -5.7), vec3(5., 1.5, 0.1)); \n  \n  //3rd wall\n  a2.x = abs(a2.x) - 2.5; //mirror\n  vec4 a2Color = vec4(1.,.9,.8,1.); //beige\n  float wall2 = fBox(a2+vec3(1.,0., -6.), vec3(.9, 1.4, .1));      \n  \n    \n  //doortop\n  vec4 bColor = vec4(1.,.4,.3,.1); //brown\n  b.y *= cos(sin(b.y*.3)*1.3);//stretch \n  float doortop = sphere(b+vec3(0.,-.3,-6.), 1.2);\n  doortop = fOpUnionStairs(doortop, wall1, .14, 4.); \n    \n  //doorbottom \n  float doorbottom = fBox(j+vec3(0., 0.5, -5.1), vec3(1.2, .8, 3.));\n    \n  //doorside\n  h.x = abs(h.x) - .1; //mirror\n  h.zx *= rot(radians(25.)); // Rotate\n  vec4 hColor = vec4(1.,.3,.3,1.); //brown\n  float doorside = fBox(h+vec3(.9,0.6, -5.), vec3(.2, .8, 1.));      \n  \n  //backdoor\n  vec4 sColor = vec4(1.,.3,.3,1.); //brown\n  float backdoor = fBox(s+vec3(0., 0.5, -6.), vec3(.5, .7, 1.)); \n    \n  //line\n  l.x = abs(l.x) - .005; //mirror\n  vec4 lColor = vec4(0.,0.,0.,1.); //black\n  l.zx *= rot(radians(25.)); // Rotate  \n  float line = fBox(l+vec3(.9, 0.6, -4.), vec3(.009, .77, .09));\n  \n  //2nd line\n  l1.x = abs(l1.x) - .13; //mirror\n  vec4 l1Color = vec4(0.,0.,0.,1.); //black\n  l1.zx *= rot(radians(25.)); // Rotate  \n  float line1 = fBox(l1+vec3(.87, 0.6, -4.), vec3(.01, .77, .11));\n  \n  \n  //3rdline\n  l2.x = abs(l2.x) - .27; //mirror\n  vec4 l2Color = vec4(0.,0.,0.,1.); //black\n  l2.zx *= rot(radians(25.)); // Rotate  \n  float line2 = fBox(l2+vec3(.87, 0.6, -3.9), vec3(.01, .77, .11));\n    \n  //top line\n  tl.x = abs(tl.x) - .016; //mirror\n  vec4 tlColor = vec4(0.,0.,0.,1.); //black\n  float topline = fBox(tl+vec3(0., -.7, -4.), vec3(.01, .47, .11));\n    \n  //2nd top line\n  tl1.x = abs(tl1.x) - .27; //mirror\n  vec4 tl1Color = vec4(0.,0.,0.,1.); //black\n  float topline1 = fBox(tl1+vec3(0., -.67, -4.), vec3(.01, .44, .11));\n    \n  //3rd topline\n  tl2.x = abs(tl1.x) - .3; //mirror\n  vec4 tl2Color = vec4(0.,0.,0.,1.); //black\n  float topline2 = fBox(tl2+vec3(0., -.5, -4.), vec3(.01, .3, .11));\n    \n  //4th topline\n  vec4 tl3Color = vec4(0.,0.,0.,1.); //black\n  float topline3 = fBox(tl3+vec3(0., -.22, -4.), vec3(.7, .02, .2));\n    \n  //doorline\n  vec4 dlColor = vec4(0.,0.,0.,1.); //black  \n  float doorline = fBox(dl+vec3(.0, 0.5, -5.), vec3(.01, .68, .11));\n    \n  //door knob\n  vec4 kColor = vec4(1.,0.8, 0.,1.); //gold\n  float knob = fBox(k+vec3(.0, 0.7, -5.), vec3(.05, .1, .11));\n    \n  //window\n  w.x = abs(w.x) - 0.5; //mirror\n  w.yx *= rot(radians(45.)); // Rotate   \n  float window = fBox(w+vec3(0.1, 0.23, -5.), vec3(.05, .05, 1.));\n   \n  //horizontal line\n  vec4 hlColor = vec4(0.,0.,0.,1.); //black\n  float horizline = fBox(hl+vec3(0., -.42, -4.), vec3(.65, .02, .2));\n    \n  //2nd horizontal line\n  vec4 hl1Color = vec4(0.,0.,0.,1.); //black\n  float horizline1 = fBox(hl1+vec3(0., -.64, -4.), vec3(.54, .02, .2));\n    \n  //3rd horizontal line\n  vec4 hl2Color = vec4(0.,0.,0.,1.); //black\n  float horizline2 = fBox(hl2+vec3(0., -.85, -4.), vec3(.47, .02, .2));\n    \n  //4th horizontal line\n  hl3.x = abs(hl3.x) - .13; //mirror\n  hl3.zx *= rot(radians(25.)); // Rotate \n  vec4 hl3Color = vec4(0.,0.,0.,1.); //black\n  float horizline3 = fBox(hl3+vec3(0.9, 1.2, -4.), vec3(.17, .02, .2));\n    \n  //5th horizontal line\n  hl4.x = abs(hl4.x) - .13; //mirror\n  hl4.zx *= rot(radians(25.)); // Rotate \n  vec4 hl4Color = vec4(0.,0.,0.,1.); //black\n  float horizline4 = fBox(hl4+vec3(0.9, .8, -4.), vec3(.17, .02, .2));\n  \n  //6th horizontal line\n  hl5.x = abs(hl5.x) - .13; //mirror\n  hl5.zx *= rot(radians(25.)); // Rotate \n  vec4 hl5Color = vec4(0.,0.,0.,1.); //black\n  float horizline5 = fBox(hl5+vec3(0.9, .67, -4.), vec3(.17, .02, .2)); \n    \n  //7th horizontal line\n  hl6.x = abs(hl6.x) - .13; //mirror\n  hl6.zx *= rot(radians(25.)); // Rotate \n  vec4 hl6Color = vec4(0.,0.,0.,1.); //black\n  float horizline6 = fBox(hl6+vec3(0.9, .3, -4.), vec3(.17, .02, .2));\n    \n  //8th horizontal line\n  hl7.x = abs(hl7.x) - .13; //mirror\n  hl7.zx *= rot(radians(25.)); // Rotate \n  vec4 hl7Color = vec4(0.,0.,0.,1.); //black\n  float horizline7 = fBox(hl7+vec3(0.9, 0., -4.), vec3(.17, .02, .2)); \n  \n    \n  //picture frame\n  p.xz *= rot(radians(60.)); // Rotate \n  vec4 pColor = vec4(.1,0.,0.,.1); //black\n  float picture = fBox(p+vec3(-1.6, 0.1, -2.5), vec3(.1, .23, .05)); \n \n  //second door\n  //d1.y *= cos(sin(d1.y*.2)*1.3);//stretch \n  d1.zx *= rot(radians(70.)); // Rotate \n  float door1 = fBox(d1+vec3(2., 0.9, -2.6), vec3(.5, 1.5, .1)); \n\n  //draw shapes to screen \n  shape.dist = min(shape.dist, ground); \n  shape.dist = max(archBottom, -archTop);\n  shape.dist = min(shape.dist, wall);\n  shape.dist = min(shape.dist, doortop);  \n  shape.dist = max(shape.dist, -doorbottom);            \n  shape.dist = min(shape.dist, doorside);\n  shape.dist = min(shape.dist, backdoor);\n  shape.dist = min(shape.dist, line);\n  shape.dist = min(shape.dist, line1);\n  shape.dist = min(shape.dist, line2);\n  shape.dist = min(shape.dist, doorline);\n  shape.dist = min(shape.dist, knob);\n  shape.dist = max(shape.dist, -window);\n  shape.dist = min(shape.dist, topline);\n  shape.dist = min(shape.dist, topline1);\n  shape.dist = min(shape.dist, topline2);\n  shape.dist = min(shape.dist, topline3);\n  shape.dist = min(shape.dist, wall1);\n  shape.dist = min(shape.dist, wall2);\n  shape.dist = min(shape.dist, horizline);\n  shape.dist = min(shape.dist, horizline1);\n  shape.dist = min(shape.dist, horizline2);\n  shape.dist = min(shape.dist, horizline3);\n  shape.dist = min(shape.dist, horizline4);\n  shape.dist = min(shape.dist, horizline5);\n  shape.dist = min(shape.dist, horizline6);\n  shape.dist = min(shape.dist, horizline7);\n  shape.dist = min(shape.dist, picture);\n  shape.dist = max(shape.dist, -door1);\n    \n  //mixing in the colors\n  shape.color = mix(shape.color, gColor, mixColors(ground, shape.dist, 0.0001));\n  shape.color = mix(shape.color, iColor, mixColors(archBottom, shape.dist, 0.0001));\n  shape.color = mix(shape.color, lColor, mixColors(line, shape.dist, 0.00001));\n  shape.color = mix(shape.color, sColor, mixColors(backdoor, shape.dist, 0.0001));\n  shape.color = mix(shape.color, aColor, mixColors(wall, shape.dist, 0.0001));\n  shape.color = mix(shape.color, a2Color, mixColors(wall2, shape.dist, 0.0001));\n  shape.color = mix(shape.color, hColor, mixColors(doorside, shape.dist, 0.001)); \n  shape.color = mix(shape.color, bColor, mixColors(doortop, shape.dist, .8)); \n  shape.color = mix(shape.color, l1Color, mixColors(line1, shape.dist, .001)); \n  shape.color = mix(shape.color, l2Color, mixColors(line2, shape.dist, .001)); \n  shape.color = mix(shape.color, dlColor, mixColors(doorline, shape.dist, .001)); \n  shape.color = mix(shape.color, kColor, mixColors(knob, shape.dist, .001)); \n  shape.color = mix(shape.color, tlColor, mixColors(topline, shape.dist, .001)); \n  shape.color = mix(shape.color, tl1Color, mixColors(topline1, shape.dist, .001)); \n  shape.color = mix(shape.color, tl2Color, mixColors(topline2, shape.dist, .001)); \n  shape.color = mix(shape.color, tlColor, mixColors(topline3, shape.dist, .001)); \n  shape.color = mix(shape.color, a1Color, mixColors(wall1, shape.dist, .00001)); \n  shape.color = mix(shape.color, hlColor, mixColors(horizline, shape.dist, .00001)); \n  shape.color = mix(shape.color, hl1Color, mixColors(horizline1, shape.dist, .00001)); \n  shape.color = mix(shape.color, hl2Color, mixColors(horizline2, shape.dist, .00001)); \n  shape.color = mix(shape.color, hl3Color, mixColors(horizline3, shape.dist, .00001)); \n  shape.color = mix(shape.color, hl4Color, mixColors(horizline4, shape.dist, .00001)); \n  shape.color = mix(shape.color, hl5Color, mixColors(horizline5, shape.dist, .00001)); \n  shape.color = mix(shape.color, hl6Color, mixColors(horizline6, shape.dist, .00001)); \n  shape.color = mix(shape.color, hl7Color, mixColors(horizline7, shape.dist, .00001)); \n  shape.color = mix(shape.color, pColor, mixColors(picture, shape.dist, .00001)); \n\n    \n  return shape; \n}\n\n\n\n\nShape map(vec3 c){\n  Shape taft = Building(c);\n  return taft;\n}\n\nfloat mapDist(vec3 c){\n  Shape taft = Building(c);\n  return taft.dist;\n}\n\nvec4 mapColor(vec3 c){\n  Shape taft = Building(c);\n  return taft.color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 cam = vec3(0., 0., 0.);\n\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n    \n \n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      //fragColor *= vec4(vec3(fc), 1.);\n      break;\n    }\n    scene += f * c.dist;\n  }\n\n}\n","name":"Image","description":"","type":"image"}]}