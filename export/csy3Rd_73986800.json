{"ver":"0.1","info":{"id":"csy3Rd","date":"1678916647","viewed":124,"name":"SDF Tiles","username":"Oneleven","description":"A method of obtaining vectors perpendicular to SDF direction in 2D plane and constructing tiles out of that.\nUse mouse :) ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sdf","tangent","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime\n#define PI 3.141592\n#define PIXEL 0.5/iResolution.y\n#define BORDERSIZE 180.\n\n#define SMOOTHNESS .04\n#define ROWS 30.0\n#define COLS 20.0\n\n//Smooth minimum by iq\n//https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n//SDF functions by iq\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n//https://www.shadertoy.com/view/tt23RR\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.86602540378,0.57735026919,1.73205080757);\n    \n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\n//https://www.shadertoy.com/view/tdGSDd\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sinTime(float time)\n{\n    return sin(time) * 0.5 + 0.5;\n}\n\nfloat getSDF(vec2 uv)\n{\n    float s1 = sdCircle(uv - (iMouse.xy - 0.5 * iResolution.xy)/iResolution.y, 0.05);\n    \n    float s2 = sdHexagram(uv, 0.05 + sinTime(T*0.5 + 0.5)*0.05);\n    float s3 = sdBox(uv - vec2(-0.6,0), vec2(0.02,(sinTime(T) * 0.1)));\n\n    float O = smin(s1,s2,SMOOTHNESS);\n    O = smin(O, s3, SMOOTHNESS);\n    return O;\n}\n\n//Hash without Sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//https://www.shadertoy.com/view/mdy3DR\nvec3 pal(float progress, vec3 scale, vec3 offset, vec3 minC, vec3 maxC)\n{\n    return (cos((progress * scale + offset + 1.0) * PI) * 0.5 + 0.5) * (maxC - minC) + minC;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float sdf = getSDF(uv);\n    \n    //get tangent via sampling two neibhoring pixels\n    vec2 up = uv + vec2(0,PIXEL);\n    vec2 right = uv + vec2(PIXEL,0);\n    vec2 tangent = normalize(vec2(getSDF(up) - sdf, sdf - getSDF(right)));\n\n    float rows = floor(sdf*ROWS);\n    float angle = atan(tangent.y,tangent.x)*COLS/PI + T * 0.5 * ((mod(rows,2.0)*2.0 - 1.0)); //used for border in commented line\n    float cols = floor(angle);\n    \n    float border = smoothstep(0.0, PIXEL * BORDERSIZE, abs(sin(sdf*ROWS*PI)));\n    //border *= smoothstep(0.0,0.2/rows,abs(sin(angle*PI))); //produces flickering\n    \n    vec3 col = vec3(0);\n    col = pal(hash12(vec2(rows,cols)), vec3(1.0, 1.3, 1.4), vec3(0.0, 0.25, 0.45), vec3(0.3,0.3,0.4), vec3(1.0,1.0,1.0))*border + (1.0 - border) * vec3(0.0, 0.4, 0.9);\n    \n    //DEBUG Uncomment\n    //col = vec3(tangent, 0);\n    //col = hash31(rows);\n    //col = hash31(cols);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}