{"ver":"0.1","info":{"id":"sl2cRc","date":"1650046794","viewed":84,"name":"Probably Slow Value Noise","username":"trigophers","description":"hmmmmm","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// visual studios rand()\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// hash to initialize the random seed (copied from Hugo Elias)\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n// http://amietia.com/lambertnotangent.html\n\nfloat frandCoord(int qx, int qy, int mult) {\n    srand( hash(qx+hash(qy+hash(1117*mult))));\n    return frand();\n}\n\nfloat smootherstep(float edge0, float edge1, float x) {\n  x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\nfloat easing(float a, float b, float x) {\n    return smootherstep(0.0, 1.0, x)*(b-a)+a;\n}\n\nfloat valueNoise(vec2 loc, int frame, float scale, float dir, vec2 dp) {\n    vec2 tfed = vec2((loc.x-dp.x), (loc.y-dp.y));\n    vec2 rots = vec2(cos(dir), sin(dir));\n    vec2 rotated = dp+vec2(tfed.x*rots.x-tfed.y*rots.y, tfed.y*rots.x+tfed.x*rots.y);\n\n    vec2 ws = mod(rotated, vec2(scale))/scale;\n\n    ivec2 pos = ivec2(rotated.x/scale, rotated.y/scale);\n\n    float a = frandCoord(pos.x, pos.y, 0);\n    float b = frandCoord(pos.x+1, pos.y, 0);\n    float c = frandCoord(pos.x, pos.y+1, 0);\n    float d = frandCoord(pos.x+1, pos.y+1, 0);\n    \n    float t1 = easing(a, b, ws.x);\n    float t2 = easing(c, d, ws.x);\n    float t3 = easing(t1, t2, ws.y);\n    \n    return t3;\n}\n\nfloat octaves(vec2 fragCoord, int octs, float scale) {\n    float c = 0.0;\n    float inverseD = -1.0;\n    float divisor = 1.0;\n    float oppDivisor = scale;\n    for (int i = 0; i < octs; i++) {\n        c += valueNoise(fragCoord, i, oppDivisor, float(i)/float(octs)*-3.0, vec2(-2000, -3000))/divisor;\n        \n        inverseD += 1.0/divisor;\n        divisor *= 2.0;\n        oppDivisor /= 2.0;\n    }\n    \n    return c/inverseD;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = octaves(fragCoord, 6, 128.0);\n    \n    // Output to screen\n    fragColor = vec4(vec3(c/(1.0+0.5+0.25+0.125)),1.0);\n}","name":"Image","description":"","type":"image"}]}