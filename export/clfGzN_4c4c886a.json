{"ver":"0.1","info":{"id":"clfGzN","date":"1671370786","viewed":135,"name":"Octal Man VM","username":"spalmer","description":"Same thing as oneshade's but in Octal!  :D","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["computer","simulator","assembly","interpreter","programming","lmc"],"hasliked":0,"parentid":"msBXDd","parentname":"Little Man Computer Simulator"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nfork of oneshade's http://shadertoy.com/view/msBXDd\n\nThis is a simulation of an \"octal man computer\", which is an octal-based variant of\na \"little man computer\", a simple educational model of a computer.\nSee details on wikipedia (http://en.wikipedia.org/wiki/Little_man_computer).\nYou can affect speed of the simulation by changing INSTRUCTION_DELAY in Buffer A.\n\nInstructions for this implementation:\n+-----------+---------+-------------------------------------------------------------+\n| Assembled | Syntax  | Operation                                                   |\n+-----------+---------+-------------------------------------------------------------+\n| 00xx      | OUT     | store the accumulator's value in the outbox                 |\n+-----------+---------+-------------------------------------------------------------+\n| 01xx      | ADD xx  | add the value at RAM address x to the accumulator           |\n+-----------+---------+-------------------------------------------------------------+\n| 02xx      | SUB xx  | subtract the value at RAM address x from the accumulator    |\n+-----------+---------+-------------------------------------------------------------+\n| 03xx      | STA xx  | store the accumulator's value in RAM at address x           |\n+-----------+---------+-------------------------------------------------------------+\n| 04xx      | LDA xx  | load the value at RAM address x into the accumulator        |\n+-----------+---------+-------------------------------------------------------------+\n| 05xx      | BRA xx  | \"branch\", jump to RAM address x and start executing the     |\n|           |         | program from there on                                       |\n+-----------+---------+-------------------------------------------------------------+\n| 06xx      | BRZ xx  | same as BRA, but only if the accumulator equals 0           |\n+-----------+---------+-------------------------------------------------------------+\n| 07xx      | BRP xx  | same as BRA, but only if the accumulator is positive (>= 0) |\n+-----------+---------+-------------------------------------------------------------+\n| 0xxx      | DAT xxx | store x at this instruction's address in RAM (must be       |\n|           |         | before the rest of your program and is only executed by     |\n|           |         | the assembler)                                              |\n+-----------+---------+-------------------------------------------------------------+\n\nDue to limitations of Octal encoding, some op codes would not fit, so\nsince INP wasn't implemented properly anyway, and HLT is rather useless\ndue to being really easy to compile to simply BRA to current address.\nSo I removed INP and swapped HLT and BRK.\n\n| 08xx      | INP     | load the value in the inbox into the accumulator            |\n+-----------+---------+-------------------------------------------------------------+\n| 0900      | HLT     | \"halt\", stop the program                                    |\n+-----------+---------+-------------------------------------------------------------+\n\nNote that the program reads from and writes to RAM but is also stored in RAM\nitself and as a result, can modify itself, which is a very useful feature.\n\nChallenges:\n - Count from 0 to 010\n - Compute the fibonacci sequence\n - Compute prime numbers (I suggest brute force first, its easier and also\n   probably more efficient for the amount of RAM you have available)\n - Write a \"functional\" program (emulate functions with branching)\n   Hint: your program will have to modify itself\n - Implement a recursive algorithm, this is not well charted territory for me\n   but I am certain that indefinite (THEORETICALLY indefinite, you do have\n   limited RAM) recursion can be implemented\n*/\n\n// Character codes in octal\nconst int\n    //SPACE = 040,\n    //HYPHEN = 055,\n    ZERO = 060,\n              a = 0141, b = 0142, c = 0143, d = 0144, e = 0145, f = 0146, g = 0147,\n    h = 0150, i = 0151, j = 0152, k = 0153, l = 0154, m = 0155, n = 0156, o = 0157,\n    p = 0160, q = 0161, r = 0162, s = 0163, t = 0164, u = 0165, v = 0166, w = 0167,\n    x = 0170, y = 0171, z = 0172;\n    \n// Modified version of font loader from http://shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, vec3 charColor, vec2 uv, vec2 pos, vec2 size, int char)\n{\n    uv = (uv - pos) / size + .5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - .5), vec2(.5)))) {\n        float val = textureGrad(iChannel1, charUv + fract(vec2(char, 15 - char / 16) / 16.), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid drawOctal(inout vec3 color, vec3 fontColor, vec2 uv, vec2 pos, vec2 digitSize, int num, int precis)\n{\n    float digitWidth = .5 * digitSize.x;\n    if (num < 0) drawChar(color, fontColor, uv, pos, digitSize, 45);\n    pos.x += digitWidth * float(precis);\n    num = abs(num);\n    for (int i=0; i < precis; ++i) {\n        int digit = num % 010;\n        drawChar(color, fontColor, uv, pos, digitSize, ZERO + digit);\n        num = (num - digit) / 010;\n        pos.x -= digitWidth;\n    }\n}\n\nconst int MAX_STR = 3;\n\nvoid drawString(in int[MAX_STR] str, int len, inout vec3 color, vec3 fontColor, \n                vec2 uv, vec2 pos, vec2 size, float space)\n{\n    for (int i=0; i < len; ++i) {\n        drawChar(color, fontColor, uv, pos, size, str[i]);\n        pos.x += space;\n    }\n}\n\n#define draw(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    float unit = 2. / iResolution.y;\n    vec3 color = vec3(0);\n\n    // Load registers\n    ivec4 registers = ivec4(texelFetch(iChannel0, ivec2(0100, 0), 0));\n    int pc     = registers.x,\n        acc    = registers.y,\n        inbox  = registers.z,\n        outbox = registers.w;\n\n    // Display RAM\n    vec2 padding = vec2(.015 * aspect, .05);\n    vec2 cellSize = vec2(.105 * aspect, .125);\n    vec2 halfCellSize = cellSize / 2.;\n\n    // Grid\n    vec2 cellUv = uv + halfCellSize;\n    vec2 cellId = clamp(floor(cellUv / cellSize), 0., 8.);\n    cellUv -= cellId * cellSize + halfCellSize;\n    if (uv.y < 8. * cellSize.y) draw(abs(cellUv.x), vec3(.2));\n    if (uv.x < 8. * cellSize.x) draw(abs(cellUv.y), vec3(.2));\n\n    // Draw memory cells\n    cellId = floor(uv / cellSize);\n    if (cellId.x >= 0. && cellId.x < 8. && cellId.y >= 0. && cellId.y < 8.) {\n        // Load mailbox\n        int slot = 010 * (7 - int(cellId.y)) + int(cellId.x);\n        int mailbox = int(texelFetch(iChannel0, ivec2(slot, 0), 0).x);\n\n        // Display RAM address\n        vec2 drawPos = cellId * cellSize + padding;\n        drawPos.y += 0.04;\n        drawOctal(color, vec3(0,.7,0), uv, drawPos, vec2(0.05), slot, 2);\n\n        // Display value\n        drawPos.y -= 0.05;\n        drawOctal(color, vec3(.7), uv, drawPos, vec2(0.07), mailbox, 3);\n        \n        // Brighten yellow cell currently being executed\n        if (slot == pc)\n            color *= vec3(1,1,0)/vec3(.7);\n    }\n\n    // Display registers\n    vec2 pos = vec2(.87890625 * aspect, .875);\n    vec2 ofs = vec2(.0, .0675);\n    \n    // Counter\n    drawString(int[](p, c, -1), 2, color, vec3(0, .2, 1), uv, pos + ofs, vec2(.05), .025);\n    drawOctal(color, vec3(1.0), uv, pos, vec2(0.1), pc, 3);\n    pos.y -= 0.15;\n\n    // Accumulator\n    drawString(int[](a, c, c), 3, color, vec3(0, .2, 1), uv, pos + ofs, vec2(.05), .025);\n    drawOctal(color, vec3(1.0), uv, pos, vec2(0.1), acc, 3);\n    pos.y -= 0.15;\n\n    // Inbox (unused)\n    drawString(int[](i, n, -1), 2, color, vec3(0, 0, .5), uv, pos + ofs, vec2(.05), .025);\n    drawOctal(color, vec3(1.0), uv, pos, vec2(0.1), inbox, 3);\n    pos.y -= 0.15;\n\n    // Outbox\n    drawString(int[](o, u, t), 3, color, vec3(0, .2, 1), uv, pos + ofs, vec2(.05), .025);\n    vec2 outboxUv = uv - pos;\n    float outboxIdx = round(-outboxUv.y / .15);\n    \n    // Outbox History\n    if (uv.x > 8. * cellSize.x && outboxIdx >= 0. && outboxIdx <= 2.) {\n        outboxUv.y += outboxIdx * .15;\n        int outboxHist = int(texelFetch(iChannel0, ivec2(0100 + int(outboxIdx), 0), 0).w);\n        drawOctal(color, vec3(exp2(-outboxIdx)), outboxUv, vec2(0), vec2(.1), outboxHist, 3);\n    }\n    \n    // Gamma correction\n    fragColor = vec4(sqrt(color), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define INSTRUCTION_DELAY 020\n\n// Op codes\nconst int \n    OUT = 0,\n    ADD = 1,\n    SUB = 2,\n    STA = 3,\n    LDA = 4,\n    BRA = 5,\n    BRZ = 6,\n    BRP = 7,\n//    INP = 8,\n//    HLT = 9,\n    DAT = 010;\n    \n// TODO could emulate HLT as something like OUT 0777\n    \n// INP can be emulated via a memory location via LDA\n\n// Note that, since DAT is effectively 0 after shifting and masking by 0777,\n// no special logic is required to handle assembling the DAT instruction\n// except allowing out-of-range operands at this phase.\n    \n#define Assemble(opcode, operand) \\\n    (((opcode << 6) | operand) & 0777)\n\n// Program\n// TODO I haven't gotten it doing anything fancy yet, barely got it working at all!\n// TODO I need to try to do all the challenges.  lol\n//const ivec2[] program = ivec2[](\nconst int[] program = int[](\n// first challenge: Outbox count from 1 to 010 and stop\n    Assemble(BRA, 0004),\n    Assemble(DAT, 0000), // storage for acc\n    Assemble(DAT, 0001), // increment\n    Assemble(DAT, 0007), // limit\n    Assemble(LDA, 0001),\n    Assemble(ADD, 0002), // add 1\n    Assemble(STA, 0001),\n    Assemble(OUT, 0077), // operand ignored\n    Assemble(LDA, 0003), // loop exit condition\n    Assemble(SUB, 0001),\n    Assemble(BRP, 0004),\n    Assemble(BRA, 0013), // HLT\n// this one doesn't stop at 010, just keeps counting\n//    Assemble(ADD, 0003),\n//    Assemble(OUT, 0077),\n//    Assemble(BRA, 0000),\n//    Assemble(DAT, 0001),\n// random data example tacked on to end\n    Assemble(DAT, 0076),\n    Assemble(DAT, 0543),\n    Assemble(DAT, 0210),\n    Assemble(DAT, 0777)\n);\n\nvoid mainImage(out vec4 data, vec2 addr) \n{\n    ivec2 iAddr = ivec2(addr);\n    if (iAddr.y != 0)\n        discard;\n    \n    data = texelFetch(iChannel0, iAddr, 0);\n    int slot = iAddr.x;\n    \n    if (iFrame < 2) {\n        data = vec4(0);\n        // Initialize registers\n        if (slot >= 0100) {\n            int execStart = 0; // always begins execution at location 0\n            // can branch over own reserved memory cells if want them before code at fixed locations\n            // program counter, accumulator, inbox, outbox\n            data = vec4(execStart, 0, 0, 0);\n        }\n        // Initialize RAM with pre-assembled program\n        else if (slot < program.length())\n            data = vec4(program[slot], 0, 0, 0);\n        return;\n    }\n    if (iFrame % INSTRUCTION_DELAY != 0)\n        return;\n    // Load registers\n    ivec4 reg = ivec4(texelFetch(iChannel0, ivec2(0100, 0), 0));\n    int pc     = reg.x,\n        acc    = reg.y,\n        inbox  = reg.z,\n        outbox = reg.w;\n    // Outbox history support\n    if (slot > 0100) {\n        if ((int(texelFetch(iChannel0, ivec2(pc & 077, 0), 0).x) >> 6) == OUT)\n            data = texelFetch(iChannel0, ivec2(slot-1,0), 0);\n        return;\n    }\n\n    //if (inbox == -1) discard; // old HLT support\n    // Load all of RAM\n    int[0100] box;\n    for (int i = 0; i < 0100; ++i)\n        box[i] = int(texelFetch(iChannel0, ivec2(i, 0), 0).x);\n\n    // Load current instruction\n    int instr = box[pc];\n    // advance program counter to next instruction\n    ++pc;\n\n    // Decode current instruction\n    int arg = instr & 077; // operand\n\n    // Execute current instruction\n    switch (instr >> 6) {\n        case ADD:\n            acc += box[arg];\n            acc &= 0777;\n            break;\n        case SUB:\n            acc -= box[arg];\n            acc &= 0777;\n            break;\n        case STA:\n            //box[arg] = acc; // nothing here will use it though\n            // Store updated memory state\n            if (slot <  0100 && slot == arg)\n                data.x = float(acc);\n            break;\n        case LDA:\n            acc = box[arg];\n            break;\n        case BRA:\n            pc = arg;\n            break;\n        case BRZ:\n            if (acc == 0)\n                pc = arg;\n            break;\n        case BRP:\n            if ((acc & 0x40) == 0) // acc >= 0)\n                pc = arg;\n            break;\n        case OUT:\n            outbox = acc;\n            break;\n        //case HLT:\n        //    inbox = -1;\n        //    break;\n        //case INP:\n        //    acc = inbox;\n        //    break;\n    }\n    // Store updated register state\n    if (slot == 0100)\n        data = vec4(pc, acc, inbox, outbox);\n}","name":"Buffer A","description":"","type":"buffer"}]}