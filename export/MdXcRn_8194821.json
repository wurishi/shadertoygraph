{"ver":"0.1","info":{"id":"MdXcRn","date":"1486672682","viewed":346,"name":"Ray Marching Path Tracer","username":"yumcyawiz","description":"test code of path tracer using ray marching","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//gamma\nvec3 vpow(vec3 p, float i) {\n\treturn vec3(pow(p.x, i), pow(p.y, i), pow(p.z, i));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //(0, 0) ~ (1, 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(vpow(texture(iChannel0, uv).xyz, 0.8), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//math\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy + vec2(iTime, iTime+1.0) ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 rotateX(vec3 p, float t) {\n    mat3 rot = mat3(1, 0, 0, 0, cos(t), sin(t), 0, -sin(t), cos(t));\n    return rot * p;\n}\nvec3 rotateZ(vec3 p, float t) {\n    mat3 rot = mat3(cos(t), sin(t), 0, -sin(t), cos(t), 0, 0, 0, 1);\n    return rot * p;\n}\nvec3 rotateY(vec3 p, float t) {\n    mat3 rot = mat3(cos(t), 0, -sin(t), 0, 1, 0, sin(t), 0, cos(t));\n    return rot * p;\n}\n\n\nstruct Obj {\n    float dist;\n    vec3 diffuseColor;\n    vec3 emitColor;\n};\n\n\n//primitive distance functions\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\n//operations\nObj opU(Obj d1, Obj d2) {\n    if(d1.dist < d2.dist) {\n        return d1;\n    }\n    else {\n        return d2;\n    }\n}\nObj opS(Obj d1, Obj d2) {\n    if(-d1.dist > d2.dist) {\n        return d1;\n    }\n    else {\n        return d2;\n    }\n}\nObj opI(Obj d1, Obj d2) {\n    if(d1.dist > d2.dist) {\n        return d1;\n    }\n    else {\n        return d2;\n    }\n}\n\n\n//distance field\nObj df(vec3 p) {\n    //floor\n    Obj obj1 = Obj(sdBox(p, vec3(3.0, 0.1, 3.0)), vec3(0.3, 0.3, 1.0), vec3(0));\n    //right\n    Obj obj2 = Obj(sdBox(p + vec3(3.0, -3.0, 0.0), vec3(0.1, 3.0, 3.0)), vec3(0.3, 1.0, 0.3), vec3(0)); \n    //back\n    Obj obj3 = Obj(sdBox(p + vec3(0.0, -3.0, -2.0), vec3(3.0, 3.0, 0.1)), vec3(1.0), vec3(0));\n    //left\n    Obj obj4 = Obj(sdBox(p + vec3(-3.0, -3.0, 0.0), vec3(0.1, 3.0, 3.0)), vec3(1.0, 0.3, 0.3), vec3(0));\n    //up\n    Obj obj5 = Obj(sdBox(p + vec3(0.0, -6.0, 0.0), vec3(3.0, 0.1, 3.0)), vec3(1.0), vec3(0));\n    //right box\n    Obj obj6 = Obj(sdBox(rotateY(p + vec3(1.2, -0.7, 1.2), 0.5), vec3(0.9, 0.9, 0.9)), vec3(1.0), vec3(0));\n    //left box\n    Obj obj7 = Obj(sdBox(rotateY(p + vec3(-1.0, -1.5, -0.2), -0.4), vec3(0.8, 1.5, 0.8)),  vec3(1.0), vec3(0));\n    //sphere\n    Obj obj8 = Obj(sdSphere(p + vec3(-1.5, -0.5, 2.0),  0.5), vec3(1.0), vec3(0));\n        \n    Obj obj;\n    obj = opU(obj1, obj2);\n    obj = opU(obj, obj3);\n    obj = opU(obj, obj4);\n    obj = opU(obj, obj5);\n    obj = opU(obj, obj6);\n    obj = opU(obj, obj7);\n    obj = opU(obj, obj8);\n    return obj;\n}\n\n\n//normal vector\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    Obj x1 = df(p + vec3(eps, 0, 0));\n    Obj x2 = df(p - vec3(eps, 0, 0));\n    Obj y1 = df(p + vec3(0, eps, 0));\n    Obj y2 = df(p - vec3(0, eps, 0));\n    Obj z1 = df(p + vec3(0, 0, eps));\n    Obj z2 = df(p - vec3(0, 0, eps));\n    return normalize(vec3(x1.dist - x2.dist, y1.dist - y2.dist, z1.dist - z2.dist));\n}\n\n\n//trace\nstruct Ray {\n    vec3 from; //ray start position\n    vec3 hitPos; //ray hit position\n    vec3 hitNormal; //normal vector\n    vec3 rayDir; //ray direction\n    float t; //traveled distance\n    int steps; //the number of steps\n    bool hit; //hit or not\n    Obj hitObj; //hit object\n};\n\nconst int maxSteps = 100; //maximum allowed steps\n\nRay trace(vec3 from, vec3 rayDir) {\n    vec3 p = vec3(0);\n    vec3 normal = vec3(0);\n    float t = 0.0;\n    int steps = 0;\n    bool hit = false;\n    Obj hitObj;\n    for(int i = 0; i < maxSteps; i++) {\n        p = from + t*rayDir;\n        Obj d = df(p);\n        if(d.dist < 0.001) {\n            p -= 0.001*rayDir;\n            hit = true;\n            normal = calcNormal(p);\n            hitObj = d;\n            steps = i;\n            break;\n        }\n        t += d.dist/1.1;\n    }\n    return Ray(from, p, normal, rayDir, t, steps, hit, hitObj);\n}\n\n\n//is point p visible from the light?\nbool isVisible(vec3 p, vec3 lightPos) {\n    Ray tr = trace(lightPos, normalize(p - lightPos));\n    if(distance(tr.hitPos, p) < 0.1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\n//shading\nconst int maxDepth = 10;\nconst float rr_prob = 0.2;\nvec3 shading(vec3 from, vec3 rayDir) {\n    vec3 ro = from;\n    vec3 rd = rayDir;\n    vec3 fcol = vec3(1.0);\n    vec3 tcol = vec3(0);\n    vec3 dcol = vec3(0);\n    \n    Ray tr = trace(ro, rd);\n    float weight = max(dot(tr.rayDir, tr.hitPos), 0.0);\n    \n    for(int j = 0; j < maxDepth; j++) {        \n        //if nothing hit\n        if(tr.hit == false) {\n            if(j == 0) {\n                return vec3(0.0);\n            }\n            else {\n                fcol = vec3(0.0);\n            }\n        }\n        \n        //light setting\n        vec3 lightPos = vec3(0, 5.8, -0.5) + vec3(2.0*rand(ro.xy + vec2(iFrame + j)) - 1.0, \n                                                  (2.0*rand(ro.yz + vec2(iFrame + j)) - 1.0)*0.01, \n                                                  2.0*rand(ro.xz + vec2(iFrame + j)) - 1.0);\n        vec3 lightColor = vec3(3);\n        \n\n        //direct illumination\n        vec3 dcol = vec3(0);\n        if(isVisible(tr.hitPos, lightPos)) {\n            vec3 lightDir = normalize(lightPos - tr.hitPos);\n            float g = max(dot(tr.hitNormal, lightDir), 0.0)*abs(dot(lightDir, vec3(0, -1, 0)))/pow(distance(tr.hitPos, lightPos), 1.0);\n            dcol = lightColor*g;\n        }\n\n        //update color\n        fcol *= tr.hitObj.diffuseColor;\n        tcol += fcol * dcol;\n        \n        //russian roulet\n        float rr = rand(vec2(iFrame) + vec2(j));\n        if(rr < rr_prob) {\n            break;\n        }\n        \n        //update weight\n        weight *= 1.0/(1.0 - rr_prob);\n\n        //update ro, rd\n        ro = tr.hitPos;\n        \n        rd = normalize(tr.hitNormal*0.5 + \n        vec3(2.0*rand(ro.xy + vec2(j)) - 1.0, \n        2.0*rand(ro.yz + vec2(j)) - 1.0, \n        2.0*rand(ro.xz + vec2(j)) - 1.0));\n        \n        /*\n        float r1 = (2.0*rand(ro.xy + vec2(j) + vec2(iFrame)) - 1.0) * 3.14/2.0;\n        float r2 = (2.0*rand(ro.yz + vec2(j) + vec2(iFrame)) - 1.0) * 3.14/2.0;\n        rd = rotateX(rotateZ(tr.hitNormal, r1), r2);\n        */\n        \n        //trace\n         tr = trace(ro, rd);\n    }\n    return tcol;\n}\n\n\n//the number of samples\nconst int maxSamples = 200;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //(-1, -1) ~ (1, 1) with antialiasing\n    vec2 uv = (2.0*fragCoord.xy + 2.0*vec2(2.0*rand(fragCoord) - 1.0, 2.0*rand(fragCoord+10.) - 1.0) - iResolution.xy) / iResolution.y;\n    //(0, 0) ~ (1, 1)\n    vec2 uvt = fragCoord.xy/iResolution.xy;\n    \n    //camera settings\n    vec3 camPos = vec3(0, 2.5, -6);\n    vec3 camFront = vec3(0, 0, 1);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camFront, camUp);\n    float focus = 1.5;\n    \n    //ray direction\n    vec3 rayDir = normalize(uv.x*camRight + uv.y*camUp + focus*camFront);\n    \n    if(iFrame < maxSamples) {\n        fragColor = (vec4(shading(camPos, rayDir), 1.0)/float(maxSamples) + texture(iChannel0, uvt));\n    }\n    else {\n        fragColor = texture(iChannel0, uvt);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}