{"ver":"0.1","info":{"id":"ssXXRs","date":"1619044185","viewed":106,"name":"Light placement accident","username":"jolle","description":"Was experimenting with a simple path tracer when I placed the light inside the ceiling plane, resulting in this neat circular artifact.\n\nNote: Artifact might depend on driver etc, so possibly it's a normal scene or a completely black scene.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["light","pathtracing","accident"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nstruct Plane { vec3 n; float d; vec3 c; };\nPlane planes[] = Plane[](\n    Plane(vec3( 0.0, 1.0, 0.0),  0.0, vec3(1.00, 1.00, 1.00)),\n    Plane(vec3( 0.0,-1.0, 0.0),-25.0, vec3(1.00, 1.00, 1.00)),\n    Plane(vec3( 1.0, 0.0, 0.0),-12.0, vec3(1.00, 0.25, 0.25)),\n    Plane(vec3(-1.0, 0.0, 0.0),-12.0, vec3(0.25, 0.25, 1.00)),\n    Plane(vec3( 0.0, 0.0,-1.0),-30.0, vec3(0.25, 1.00, 0.25)),\n    Plane(vec3( 0.0, 0.0, 1.0),  0.0, vec3(1.00, 1.00, 1.00))\n);\n\nstruct Sphere { vec3 p; float r; vec3 c; };\nSphere spheres[] = Sphere[](\n    Sphere(vec3(-3.0, 5.0, 20.0), 5.0, vec3(1.0, 1.0, 1.0)),\n    Sphere(vec3( 1.0, 2.0, 15.0), 2.0, vec3(1.0, 1.0, 0.0))\n);\n\nstruct PointLight { vec3 p; vec4 c; };\nPointLight lights[] = PointLight[](\n    PointLight(vec3(0.0, 25.0, 15.0), vec4(1.0, 1.0, 1.0, 1.5)));\n\nconst float pi = 3.1415926536;\n\nfloat sq(float x) { return x * x; }\n\nuint hash(uint x)\n{\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x) * 0x45d9f3bu;\n    x = (x >> 16u) ^ x;\n    return x;\n}\n\nuint hash(vec3 x)\n{\n    uvec3 u = floatBitsToUint(x);\n    return hash(u.z ^ hash(u.y ^ hash(u.x)));\n}\n\nuint hash(vec4 x)\n{\n    uvec4 u = floatBitsToUint(x);\n    return hash(u.w ^ hash(u.z ^ hash(u.y ^ hash(u.x))));\n}\n\nfloat floatFromHash(uint h)\n{\n    return uintBitsToFloat(h & 0x007FFFFFu | 0x3F800000u) - 1.0;\n}\n\nfloat noise(vec3 x) { return floatFromHash(hash(x)); }\n\nvec3 noiseVector(vec4 co)\n{\n    uint h1 = hash(co);\n    uint h2 = hash(h1 * 0x6d04955du);\n\tfloat a = floatFromHash(h1);\n    float b = floatFromHash(h2);\n    float z = b * 2.0 - 1.0;\n    float s = sqrt(1.0 - sq(z));\n    return vec3(cos(a * pi * 2.0 + vec2(0.0, -pi * 0.5)) * s, z);\n}\n\nstruct TraceResult { vec3 p; float d; vec3 n; vec3 c; } traceGeometry(vec3 from, vec3 dir, float maxDist)\n{\n    TraceResult result = TraceResult(vec3(0.0), maxDist, vec3(0.0, 1.0, 0.0), vec3(1.0));\n    for (int i = 0; i < planes.length(); ++i)\n    {\n        float pd = -dot(planes[i].n, dir);\n        if (pd <= 0.0)\n            continue;\n        vec3 p = planes[i].n * planes[i].d;\n\t\tvec3 f = from - p;\n        float od = dot(f, planes[i].n);\n        if (od <= 0.0)\n            continue;\n        float d = od / pd;\n        if (d < result.d)\n            result = TraceResult(from + dir * d, d, planes[i].n, planes[i].c);\n    }\n    for (int i = 0; i < spheres.length(); ++i)\n    {\n        vec3 v = from - spheres[i].p;\n        float dv = dot(dir, v);\n        if (dv >= 0.0)\n            continue;\n        float q = sq(dv) - dot(v, v) + sq(spheres[i].r);\n        if (q <= 0.0)\n            continue;\n        float d = -dv - sqrt(q);\n        if (d < result.d)\n        {\n            vec3 p = from + d * dir;\n            vec3 n = normalize(p - spheres[i].p);\n            result = TraceResult(p, d, n, spheres[i].c);\n        }\n    }\n    return result;\n}\n\nbool occluded(vec3 p0, vec3 p1)\n{\n    vec3 v = p1 - p0;\n    float md = length(v);\n    return traceGeometry(p0, v / md, md).d < md;\n}\n\nvec3 sampleLights(vec3 p, vec3 n)\n{\n    int lightIdx = abs(int(hash(vec4(iTime, p)))) % lights.length();\n\tif (occluded(p, lights[lightIdx].p))\n        return vec3(0.0);\n    vec3 c = lights[lightIdx].c.xyz * lights[lightIdx].c.w;\n    vec3 v = lights[lightIdx].p - p;\n    float d = length(v);\n    float a = 1.0 / (1.0 + d * 0.05);\n    float k = max(0.0, dot(n, v / d));\n    return c * k * a;\n}\n\nvec3 ray(vec3 p, vec3 v0)\n{\n    const float maxDistance = 10000.0;\n    TraceResult r0 = traceGeometry(p, v0, maxDistance);\n    vec3 c = vec3(0.0);\n    if (r0.d < maxDistance)\n    {\n        c = sampleLights(r0.p, r0.n) * r0.c;\n        vec3 v1 = noiseVector(vec4(iTime, r0.p));\n        v1 *= sign(dot(r0.n, v1));\n        TraceResult r1 = traceGeometry(r0.p + v1 * 0.001, v1, maxDistance);\n        if (r1.d < maxDistance)\n            c += sampleLights(r1.p, r1.n) * r1.c * r0.c;\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int convergenceFrames = 256;\n    const float fov = 1.8;\n    vec3 eye = vec3(0.0, 4.0, 0.0);\n    float ry = pi * 0.5;\n    float rx = pi;\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n    vec2 nudge = vec2(noise(vec3(iTime, fragCoord)), noise(vec3(-iTime, fragCoord)));\n\tvec2 uv = fov * (fragCoord.xy + nudge - iResolution.xy * 0.5) / iResolution.x;\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec3 color = ray(eye, dir);\n    vec3 previous_color = texture(iChannel0, fragCoord / iResolution.xy).xyz;\n    float frames = float(min(convergenceFrames, iFrame + 1));\n    color = (color + (frames - 1.0) * previous_color) / frames;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}