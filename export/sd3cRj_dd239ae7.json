{"ver":"0.1","info":{"id":"sd3cRj","date":"1714679198","viewed":49,"name":"Simple scene Gyroids play","username":"Vinicius_Jesus","description":"Simple scene","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["scene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat distSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat distTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdGyroid(vec3 p, float s, float t, float b)\n{\n    p *= s;\n    return abs(dot(sin(p), cos(p.zxy))-b)/s-t;\n}\n\nfloat map (in vec3 pos) \n{\n    vec3 q = pos;\n    float f = 8.0;\n    float radius = 0.5 + (sin(iTime) * 0.3) * sin(q.x * f) * sin(q.z * f) * sin(q.y * f);\n    float sphere = distSphere(pos, radius);\n    sphere *= 0.4;\n    \n    //pos.xz *= rot(iTime);\n    \n    float torus = distTorus(pos, vec2(1.5, 0.5));\n    float gyroid = sdGyroid(pos, 5.0, 0.03, .3);\n    float d2 = max(torus, gyroid*.8);\n    \n    //float d2 = pos.y - (-0.5);\n    //return min(d1, d2);\n\n    return min(sphere, d2);\n}\n\nvec3 calcNormal (in vec3 pos) \n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(\n        map(pos + e.xyy) - map(pos-e.xyy),\n        map(pos + e.yxy) - map(pos-e.yxy),\n        map(pos + e.yyx) - map(pos-e.yyx)\n    ));  \n}\n\nfloat castRay(in vec3 ray_origin, vec3 ray_direction) \n{\n    float dist_origin=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 position = ray_origin + ray_direction * dist_origin;\n        float dist_scene = map(position);\n        dist_origin += dist_scene;\n        if(dist_origin > MAX_DIST || abs(dist_scene) < SURF_DIST) break;\n    }\n    \n    return dist_origin;\n}\n\nvec3 rayDir(vec2 point, vec3 ray_origin, vec3 l, float zoom) {\n    vec3 f = normalize(l - ray_origin),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ray_origin + f * zoom,\n        i = c + point.x * r + point.y * u,\n        d = normalize(i - ray_origin);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 point = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 mouse_position = iMouse.xy/iResolution.xy;\n    \n    vec3 ray_origin = vec3(0., 0., 2.);\n    ray_origin.yz *= rot(-mouse_position.y * 3.14 + 1.);\n    ray_origin.xz *= rot(-mouse_position.x * 6.2831);\n    \n    vec3 ray_direction = rayDir(point, ray_origin, vec3(0,0,0), 1.5);\n    \n    //sky\n    vec3 col = vec3(0.5, .8, .9) - max(ray_direction.y, 0.)*.5;\n    \n    float dist = castRay(ray_origin, ray_direction);\n    \n    if(dist < MAX_DIST)\n    {\n        vec3 position = ray_origin + dist * ray_direction;\n        vec3 normal = calcNormal(position);\n        \n        vec3 sun_direction = normalize(vec3(0.8, 1.0, 0.2));  \n        \n        float sun_diffusion = clamp(dot(normal, sun_direction), 0.0, 1.0);\n        float sky_diffusion = clamp(0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float floor_diffusion = clamp(dot(normal, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        \n        col = vec3(0.6) * sun_diffusion;\n        col += vec3(0.5, .8, .9) * sky_diffusion;\n        col += vec3(0.5, .8, .9) * floor_diffusion;\n    }\n    \n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}