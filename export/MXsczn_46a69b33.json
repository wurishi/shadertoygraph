{"ver":"0.1","info":{"id":"MXsczn","date":"1726469310","viewed":157,"name":"The Lighthouse","username":"eliaszi","description":"The lighthouse Ar-Men, off the coast of Brittany.\n","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["sea","water","ocean","fog","storm","lighthouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// My first complete scene using raymarching.\n\n// The lighthouse is a composition using simple primitives.\n// The ocean is made with a stack of sine waves and some noise to emulate wind.\n\n// Barely any optimizations so performance is pretty bad.\n// The code could also use a clean-up too.\n\n\n\nconst float MATERIAL_SKY = 0.0;\nconst float MATERIAL_SEA = 1.0;\nconst float MATERIAL_ROCK = 10.0;\nconst float MATERIAL_LIGHTHOUSE = 100.0;\nconst float MATERIAL_LIGHTHOUSE_WINDOW_LEDGE = 101.0;\nconst float MATERIAL_LIGHTHOUSE_WINDOW = 102.0;\nconst float MATERIAL_LIGHTHOUSE_BEAM = 103.0;\n\nconst float MAX_DIST = 700.0;\n\nconst vec3 lighthouseOrigin = vec3(-40.0, 16.0, 220.0);\nconst vec3 lighthouseLantern = lighthouseOrigin + vec3(0.0, 25.0, 0.0);\n\n\n\nfloat odd(float v) {\n\t\n\treturn ceil(fract(v * 0.5));\n\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat smin( float a, float b, float k)\n{\n\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * h * k * (1.0/6.0);\n\n}\n\n\nmat2 rotationTriple(float a, float b, float c)\n{\n    return mat2(a/c, b/c, -b/c, a/c);\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\n\n// PRIMITIVES\n// https://iquilezles.org/articles/distfunctions/\n\n\nfloat dot2(vec2 v)\n{\n\n    return v.x * v.x + v.y * v.y;\n\n}\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderInfinite( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// UTILITY FUNCTIONS\n\n\nvec2 pickClosest( vec2 A, vec2 B )\n{\n\n    return (A.x < B.x) ? A : B;\n\n}\n\n\n\nvec2 pickFarthest( vec2 A, vec2 B )\n{\n\n    return (A.x > B.x) ? A : B;\n\n}\n\n\nfloat random(vec2 p) {\n\n  return fract(sin(dot(p, vec2(101.2, 973.0))) * 43758.5453123);\n\n}\n\n\nfloat randomSeed(float i, float s) {\n\n\treturn fract(fract(sin(i)) * s);\n\n}\n\n\nvec2 random2D(vec2 i) {\n\t\n\tfloat d = dot(i, vec2(22.9876, 34.4388));\n\n\treturn vec2( randomSeed( d, 3141592.65359 ), randomSeed( d, 2951414.95356 ) ) * 2.0 - 1.0;\n\n}\n\n\nfloat noise2D(vec2 p) {\n\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  float a = random(i);\n  float b = random(i + vec2(1, 0));\n  float c = random(i + vec2(0, 1));\n  float d = random(i + vec2(1, 1));\n\n  vec2 u = vec2(f * f * (3.0 - 2.0 * f));\n  \n  float ab = a + (b - a) * u.x;\n  float cd = c + (d - c) * u.x;\n  float ab_cd = ab + (cd - ab) * u.y;\n\n  return ab_cd;\n\n}\n\n\nfloat gradNoise2D(vec2 p) {\n\n    vec2 f = fract(p);\n\n\tvec2 fl = mod(floor(p), 20.0);\n\tvec2 ce = mod(ceil(p), 20.0);\n\n\tvec2 a = random2D(vec2(fl.x, fl.y));\n\tvec2 b = random2D(vec2(ce.x, fl.y));\n\tvec2 c = random2D(vec2(fl.x, ce.y));\n\tvec2 d = random2D(vec2(ce.x, ce.y));\n\n\tfloat da = dot(a, f - vec2(0.0, 0.0));\n\tfloat db = dot(b, f - vec2(1.0, 0.0));\n\tfloat dc = dot(c, f - vec2(0.0, 1.0));\n\tfloat dd = dot(d, f - vec2(1.0, 1.0));\n\t\n\tf = smoothstep(0.0, 1.0, f);\n\t\n\treturn 0.5 + mix( mix(da, db, f.x), mix(dc, dd, f.x), f.y );\n\n}\n\n\nfloat GradientNoise2D(vec2 p, int i, float d) {\n    \n    float f = 2.0;\n    float w = 0.5;\n    \n    float n = gradNoise2D(p) * w;\n    mat2 r = mat2(4.0/5.0, 3.0/5.0, -3.0/5.0, 4.0/5.0);\n    \n    for (int j=0; j<i; j++) {\n    \n        p = p * r;\n        w = w * d;\n        \n        n += gradNoise2D(p * f) * w;\n    \n        f = f * 2.0;\n    \n    }\n    \n    return n;\n\n}\n\n\nfloat sineB(vec2 rp, float time) {\n\n  // float a = sin((rp.x * 0.117351 + rp.y * 0.917892) + time);\n  // float b = sin((rp.x * 0.291752 + rp.y * 0.123639) + time);\n  \n  float a = sin((rp.x * 0.117351 + rp.y * 0.917892) + time);\n  float b = sin((rp.x * -0.991752 + rp.y * 0.123639) + time);\n\n  return mix(a, b, 0.6667);\n\n}\n\n\nfloat sineA(vec2 q, float time) {\n  \n  float o = sin(q.y + time);\n  \n  float s = sin(q.x + time);\n  \n  s += sin(2.0 * q.x + 0.4971 * o) * 0.5;\n  s += sin(4.0 * q.x + 1.1238 * o) * 0.25;\n  s += sin(8.0 * q.x + 2.5781 * o) * 0.125;\n\n  return s;\n\n}\n\n\n\nfloat paintedLetters( vec2 p )\n{\n    \n    float vth = 0.15;\n    float hth = vth * 0.85;\n\n    // A\n    p = p + vec2(2.35, 0.0);\n    vec2 w = vec2(0.8, 1.0);\n    float d1 = sdOrientedBox( p - vec2(0.5 * w.x, 1.0), vec2(0.0, -0.47) * w, vec2(0.49, 0.48) * w, hth * 1.02 );\n    float d2 = sdOrientedBox( p - vec2(0.5 * w.x, 1.0), vec2(1.0, -0.47) * w, vec2(0.51, 0.48) * w, vth * 0.92 );\n    float h1 = sdOrientedBox( p - vec2(0.0, 0.35), vec2(0.65, 0.5) * w, vec2(1.35, 0.5) * w, hth * 0.85 );\n    float ap = sdOrientedBox( p - vec2(0.5 * w.x, 1.48), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.2) * w, hth );\n    float t1 = sdOrientedBox( p - vec2(0.0 * w.x, 0.53), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.175) * w, hth );\n    float t2 = sdOrientedBox( p - vec2(1.0 * w.x, 0.53), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.2) * w, hth );\n    \n    float A = min(min(ap, min(t1, t2)), min(h1, min(d1, d2)));\n\n    // R\n    p = p + vec2(-1.35, 0.0);\n    w = vec2(0.8, 1.0);\n    float v1 = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    float a1 = abs(sdTunnel( p.yx - vec2(1.196, 0.6 - vth), vec2(0.24, 0.35))) - hth * 0.5;\n    d1 = sdOrientedBox( p - vec2(0.397 + vth * 0.5, 0.955), vec2(0.0, 0.01) * w, vec2(0.45 - hth, -0.414) * w, hth * 1.07 );\n    t1 = sdOrientedBox( p - vec2(0.41 * w.x, 0.53), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.35) * w, hth * 0.95 );\n    float R = min(v1, min(a1, min(d1, t1)));\n    \n    // hyphen\n    p = p + vec2(-1.1, 0.0);\n    w = vec2(0.8, 1.0);\n    float hyphen = sdOrientedBox( p - vec2(0.0, 0.95), vec2(-0.4, 0.0) * w, vec2(0.4, 0.0) * w, hth * 0.95 );    \n\n    // M\n    p = p + vec2(-0.43, 0.0);\n    w = vec2(0.8, 1.0);\n    v1 = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    float v2 = sdOrientedBox( p - vec2(1.0 * w.x - vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    \n    d1 = sdOrientedBox( p - vec2(vth * 0.6, 1.461), vec2(0.01, 0.0) * w, vec2(0.5 - hth, -0.5) * w, hth * 0.98 );\n    d2 = sdOrientedBox( p - vec2(1.0 * w.x - vth * 0.6, 1.461), vec2(-0.5 + hth, -0.5) * w, vec2(-0.01, 0.0) * w, hth * 0.98 );\n    ap = sdOrientedBox( p - vec2(0.5 * w.x, 0.99), vec2(0.0, -hth * 0.5) * w, vec2(0.0, hth * 0.5) * w, hth );\n    float M = min(v1, min(v2, min(ap, min(d1, d2))));\n\n    // E\n    p = p + vec2(-0.97, 0.0);\n    w = vec2(0.65, 1.0);\n    float v = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    \n    h1 = sdOrientedBox( p - vec2(0.0, hth * 0.5), vec2(0.0, 0.5) * w, vec2(1.0, 0.5) * w, hth );\n    float h2 = sdOrientedBox( p - vec2(0.0, 0.5), vec2(0.0, 0.5) * w, vec2(0.8, 0.5) * w, hth );\n    float h3 = sdOrientedBox( p - vec2(0.0, 1.0 - hth * 0.5), vec2(0.0, 0.5) * w, vec2(1.0, 0.5) * w, hth );\n    float E = min(v, min(h1, min(h2, h3)));\n    \n    // N\n    p = p + vec2(-0.78, 0.0);\n    w = vec2(0.7, 1.0);\n    v1 = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    v2 = sdOrientedBox( p - vec2(1.0 * w.x - vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    d1 = sdOrientedBox( p - vec2(0.5 * w.x, 1.0), vec2(-0.5 + hth * 1.1, 0.5 - hth * 0.25) * w, vec2(0.5 - hth * 1.1, -0.5 + hth * 0.25) * w, hth * 1.05 );\n    \n    float N = min(v1, min(v2, d1));\n    \n    return min(A, min(R, min(hyphen, min(M, min(E, N)))));\n\n}\n\n\nconst mat2 mr0 = mat2(0.7071, 0.7071, -0.7071, 0.7071);\nconst mat2 mr1 = mat2(0, 1, -1, 0);\nconst mat2 mr2 = mat2(7.0/24.0, 24.0/25.0, -24.0/25.0, 7.0/25.0);\nconst mat2 mr3 = mat2(48.0/73.0, 55.0/73.0, -55.0/73.0, 48.0/73.0);\n\n\nfloat waterMotion(vec3 rp, float time) {\n\n  if (rp.y > 10.0) { return rp.y; }\n\n  // level oscillation\n  float s = 40.0 + (sin(time * 0.01) * 10.0);\n  \n  vec2 q = rp.xz * 0.002;\n  \n  vec2 q0 = mr0 * q;\n  float a = sineA(q0, time * 0.8783);\n\n  vec2 q1 = mr1 * q;\n  float b = sineA(q1, time * 0.5631);\n\n  // large waves\n  s += a * 30.0 + b * 30.0;\n  \n  // medium waves\n  float c = sineB(mr2 * q0 * 8.0, time * 0.93);\n  c += sineB(mr3 * q1 * 16.0, time * 2.39) * 0.25;\n  \n  s += (c * 6.0);\n  \n  // lighthouse swell\n  \n  float dist = length(rp.xz / 29.0 - lighthouseOrigin.xz);\n  dist = 1.0 - smoothstep(10.0, 40.0, dist);\n  \n  s += dist * (10.0 + a * 10.0 + b * 10.0 + c * 5.0) * (3.0 + sin(iTime));\n  \n  // wind noise\n  \n  float n = GradientNoise2D( vec2(rp.x + iTime * 2.5, rp.z) * 0.011, 5, 0.4 );\n\n  float t = smoothstep(1000.0, 30000.0, rp.z);\n  \n  s -= (1.0 - t) * n * (24.0 + dist * 24.0);\n\n  return s * 0.75;\n\n}\n\n\n// MATERIAL FUNCTIONS\n\n\nfloat brickValueNoise2D(vec2 p, float width) {\n\n  \tvec2 q = floor(p);\n  \tfloat xo = odd(q.y);\t\n  \tq.x = floor(q.x / width - (xo * 0.5));\n\n    vec2 f = fract(q);\n\n\tvec2 fl = floor(q);\n\tvec2 ce = ceil(q);\n\n\tfloat a = random(vec2(fl.x, fl.y));\n\tfloat b = random(vec2(ce.x, fl.y));\n\tfloat c = random(vec2(fl.x, ce.y));\n\tfloat d = random(vec2(ce.x, ce.y));\n\t\n\treturn 0.25 + mix( mix(a, b, f.x), mix(c, d, f.x), f.y ) * 0.5;\n\n}\n\n\nfloat brickMortarLines(vec2 p, float width) {\n\t\n  \tvec2 q = floor(p);\n  \tfloat xo = odd(q.y);\t\n  \tq.x = floor((q.x / width - (xo * 0.5)));\n\n\tp = p / vec2(width, 1.0) - vec2(xo * 0.5, 0.0);\n\n\tfloat t = 0.1;\n\tfloat x = 1.0 - smoothstep(0.0, t/width, min(1.0, (abs(p.x - q.x))));\n\tfloat y = 1.0 - smoothstep(0.0, t, min(1.0, (abs(p.y - q.y))));\n\n\treturn max(x, y);\n\n}\n\n\nvec2 brickLuminance(vec3 p) {\n\n  vec2 q = vec2( (atan(p.z/p.x) * 0.5945) * 15.0, p.y );\n\n  float w = 2.0;\n  float n0 = 0.25 + brickValueNoise2D(q, w) * 0.65;\n  float n1 = brickMortarLines(q, w);\n\n  return vec2(n0, n1);\n\n}\n\n\n// SCENE OBJECTS\n\n\n\nvec3 getLightBeam(float i)\n{\n    \n    float t = iTime * 6.283184 / 20.0;\n    vec2 q = vec2(cos(t), sin(t));\n        \n    if (i != 0.0) {\n    \n       mat2 r = rotationTriple(63.0 * abs(i), 16.0 * i, 65.0 * abs(i));\n       q = q * r;\n    \n    }\n    \n    return vec3(q.x, 0.0, q.y);\n    \n}\n\n\nvec3 sdLighhouseBeam( vec3 p )\n{\n \n    p = p - lighthouseLantern;\n    \n    float t = iTime * 6.283184 / 20.0;\n    vec3 q = vec3(cos(t), 0.0, sin(t));\n    \n    float toLantern = length(p);\n    float r = 1.0 + toLantern * (0.03);\n\n    float n = GradientNoise2D( vec2(toLantern, p.z) * 0.02, 4, 0.5 );\n    r += n * (0.05 + toLantern * 0.01);\n\n    vec3 beam = q;\n    float d1 = sdCapsule( p, -beam * 0.1, beam * 3000.0, r + sin(toLantern * 0.36 + iTime * 0.1) * 0.05 );\n    \n    beam.xz = q.xz * rotationTriple(60.0, -11.0, 61.0);\n    float d2 = sdCapsule( p, -beam * 0.1, beam * 3000.0, r + sin(toLantern * 0.15 + 0.3456 + iTime * 0.2) * 0.06 );\n    \n    beam.xz = q.xz * rotationTriple(60.0, 11.0, 61.0);\n    float d3 = sdCapsule( p, -beam * 0.1, beam * 3000.0, r + sin(toLantern * 0.21 - 0.7456 + iTime * 0.168) * 0.04 );\n\n    // float d = min(d1, min(d2, d3));\n\n    return vec3(d1, d2, d3);\n\n}\n\n\nfloat sdLighthousePole( vec3 p )\n{\n\n    float a = sdCylinder(p - vec3(0, -0.2, 0), vec2(0.1 - p.y * 0.05, 0.05)) - 0.01;\n    float b = sdCylinder(p, vec2(0.15, 0.7)) - 0.01;\n    \n    \n    return smin(a, b, 1.0);\n\n}\n\n\nvec2 sdLighthouseBase( vec3 p )\n{\n\n    vec3 q = p - vec3(1.0, -13.5, 3.0);\n\n    float height = 6.6;\n    vec3 h = vec3(0, 0, 3);\n    float base = sdCylinder(q - clamp(q, -h, h), vec2(9.0, height)) - 0.1;\n\n    base = min(base, sdLighthousePole(p - vec3(4.0,  -height, 12.5)));\n    base = min(base, sdLighthousePole(p - vec3(2.0,  -height, 13.2)));\n    base = min(base, sdLighthousePole(p - vec3(0.0,  -height, 13.5)));\n    base = min(base, sdLighthousePole(p - vec3(-2.0, -height, 13.2)));\n    base = min(base, sdLighthousePole(p - vec3(-3.8, -height, 12.1)));\n    base = min(base, sdLighthousePole(p - vec3(-5.5, -height, 10.5)));\n    base = min(base, sdLighthousePole(p - vec3(-6.4, -height, 8.0)));\n    base = min(base, sdLighthousePole(p - vec3(-6.4, -height, 5.5)));\n    base = min(base, sdLighthousePole(p - vec3(-6.4, -height, 3.0)));\n    base = min(base, sdLighthousePole(p - vec3(-6.4, -height, 0.4)));\n    base = min(base, sdLighthousePole(p - vec3(-6.3, -height, -2.2)));\n    base = min(base, sdLighthousePole(p - vec3(-5.5, -height, -4.7)));\n    base = min(base, sdLighthousePole(p - vec3(-4.0, -height, -6.6)));\n    base = min(base, sdLighthousePole(p - vec3(-2.1, -height, -7.9)));\n    base = min(base, sdLighthousePole(p - vec3(0,    -height, -8.5)));\n    base = min(base, sdLighthousePole(p - vec3(2.0,  -height, -8.5)));\n    base = min(base, sdLighthousePole(p - vec3(4.0,  -height, -7.9)));\n    base = min(base, sdLighthousePole(p - vec3(6.0,  -height, -6.6)));\n    base = min(base, sdLighthousePole(p - vec3(7.6,  -height, -4.6)));\n    base = min(base, sdLighthousePole(p - vec3(8.3,  -height, -2.5)));\n    base = min(base, sdLighthousePole(p - vec3(8.5,  -height, -0.0)));\n    base = min(base, sdLighthousePole(p - vec3(8.5,  -height, 2.5)));\n    \n    return vec2(base, MATERIAL_LIGHTHOUSE);\n\n}\n\n\nvec2 sdLighthouseTower( vec3 p )\n{\n\n    float tower = sdCylinder(p, vec2(4.0, 20.2));\n    tower += p.y * 0.02 + exp((p.y + 30.0) * 0.06) * 0.02;\n    \n    float towerbase = sdCylinder(p - vec3(0, -6.8, 0), vec2(4.2, 0.25)) - 0.1;\n    tower = smin(tower, towerbase, 0.1);\n    \n    // Silo\n    float silo = sdCylinder(p - vec3(2.5, -3.9, -1.0), vec2(2.2, 3.4)) - 0.1;\n    tower = min(tower, silo);\n    \n    \n    // Platform\n    \n    float platform = sdCylinder(p - vec3(0, 20.0, 0), vec2(4.2, 0.25)) - 0.1;\n    float underPlatform = sdCylinder(p - vec3(0, 19.5, 0), vec2(3.4, 0.1)) - 0.1;\n    \n    tower = smin(platform, smin(tower, underPlatform, 0.25), 0.3);\n    \n    // float a = pow(abs(sin(9.0 * p.y)), 20.0);         \n    // float of = 1.57 * ceil(mod((18.0/17.0) * (6.0/5.0) * 2.25 * p.y - 1.57, 2.0))-1.0;\n    // float an = atan(p.z/p.x);\n    // float b = pow(abs(sin(10.0 * an + of)), 100.0);\n    \n    // tower += (a + (1.0 - a) * b) * 0.01;\n        \n    // Lantern Base\n    \n    float lanternBase = sdCylinder(p - vec3(0, 21.6, 0), vec2(2.8, 1.5));\n    tower = min(tower, lanternBase);\n    \n    float lanternBaseRim = sdCylinder(p - vec3(0, 23.1, 0), vec2(3.05, 0.1)) - 0.04;  \n    tower = min(tower, lanternBaseRim);\n    \n    vec2 Tower = vec2(tower, MATERIAL_LIGHTHOUSE);\n    \n    // Windows\n    \n    float offset = -1.8;\n    float step = 3.8;\n    \n    for (int i=0; i<6; i++) {\n    \n        float windowFrame = sdBox(vec3(-p.x, offset-p.y+step*float(i), -4.4-p.z+(p.y+20.0)*0.03), vec3(0.6, 0.85, 0.21));\n        Tower = pickClosest( vec2(windowFrame, MATERIAL_LIGHTHOUSE_WINDOW), Tower );\n\n        float window = sdBox(vec3(-p.x, offset-p.y+step*float(i), -4.0-p.z+(p.y+5.0)*0.03), vec3(0.45, 0.7, 0.20)) + 0.05;\n        // tower = max(-window, tower);\n        Tower = pickFarthest( vec2(-window, MATERIAL_LIGHTHOUSE_WINDOW), Tower );\n    \n    }\n    \n    return Tower;\n\n}\n\n\nvec2 sdLighthouse( vec3 p )\n{\n\n    // Foundation\n    vec2 lighthouse = sdLighthouseBase(p);\n    \n    \n    // Body\n    vec2 tower = sdLighthouseTower(p);\n    lighthouse = pickClosest(lighthouse, tower);\n    \n    float n = GradientNoise2D( vec2(atan(p.z/p.x) / 3.141592 * 7.0, p.y * 0.5), 5, 0.5 );\n    lighthouse.x += n * 0.1;\n    \n    for (int i=0; i<15; i++) {\n    \n        float an = float(i) * 3.141592 / 14.0;\n        vec2 pc = vec2(cos(an), sin(an));\n        \n        vec2 fencepost = vec2( sdVerticalCapsule(p - vec3(4.0 * pc.x, 20.4, 4.0 * pc.y), 1.4, 0.05), MATERIAL_LIGHTHOUSE );\n        lighthouse = pickClosest(lighthouse, fencepost);\n        \n        fencepost = vec2( sdVerticalCapsule(p - vec3(4.0 * -pc.x, 20.4, 4.0 * -pc.y), 1.4, 0.05), MATERIAL_LIGHTHOUSE );\n        lighthouse = pickClosest(lighthouse, fencepost);\n        \n    }\n    \n    vec2 q1 = vec2( length(p.xz) - 4.0, p.y - 21.8 );\n    \n    vec2 fence = vec2( sdCircle(q1, 0.05), MATERIAL_LIGHTHOUSE );\n    lighthouse = pickClosest(lighthouse, fence);\n    \n    \n    // Lantern\n    \n    vec2 lantern = vec2( sdCylinder(p - vec3(0, 24.9, 0), vec2(2.1, 1.7)), MATERIAL_LIGHTHOUSE );\n    //lantern.x += (p.y - 20.0) * 0.05;\n    lantern.x -= pow(abs(sin(6.0 * atan(p.z / p.x))), 20.0) * 0.1;\n    \n    lighthouse = pickClosest(lighthouse, lantern);\n    \n    vec2 lanternRoofRim = vec2( sdCylinder(p - vec3(0, 26.9, 0), vec2(2.4, 0.05)) - 0.05, MATERIAL_LIGHTHOUSE );\n    lighthouse = pickClosest(lighthouse, lanternRoofRim);\n    \n    float lanternHalfDome = sdSphere(p - vec3(0, 26.9, 0), 2.05); \n    lanternHalfDome -= pow(abs(sin(6.0 * atan(p.z / p.x))), 20.0) * 0.07;\n    \n    float lanternTop = sdSphere(p - vec3(0, 29.7, 0), 0.5);\n    vec2 lanternRoof = vec2(smin(lanternHalfDome, lanternTop, 0.75), MATERIAL_LIGHTHOUSE );\n    \n    lighthouse = pickClosest(lighthouse, lanternRoof);\n    \n    return lighthouse;\n\n}\n\n\nvec2 sdSeaSurface( vec3 p )\n{\n    \n    // return vec2(p.y, MATERIAL_SEA);\n    return vec2(p.y - waterMotion(p * vec3(29.0, 1.0, 29.0), iTime) * 0.05, MATERIAL_SEA);\n\n}\n\n\n// RENDERING FUNCTIONS\n\n\nvec2 scenePoint( vec3 p )\n{\n \n    vec2 d = vec2(MAX_DIST, MATERIAL_SKY);\n \n    vec3 q0 = (p - lighthouseOrigin);\n    vec2 q = mat2(0.7071, -0.7071, 0.7071, 0.7071) * q0.xz;\n    \n    float lighthouseBounds = sdBox(vec3(q.x, q0.y, q.y), vec3(40.0, 40.0, 40.0));\n    \n    if (lighthouseBounds < 0.0) {\n    \n        d = pickClosest(d, sdLighthouse(vec3(q.x, q0.y, q.y)));\n    \n    }\n\n    return pickClosest( sdSeaSurface(p), d);\n\n}\n\n\nvec2 castRay( vec3 ro, vec3 rd, out float t )\n{\n\n    vec2 d = scenePoint(ro);\n    t += d.x;\n    \n    vec3 rp = vec3(0.0);\n   \n    for ( int i=0; i<70; i++)\n    {\n    \n        rp = ro + rd * t;\n        d = scenePoint(rp);\n        \n        t += d.x;\n        \n        if (t >lighthouseOrigin.z + 30.0 && rd.y > 0.0) {\n        \n            d = vec2(MAX_DIST, MATERIAL_SKY);\n            t = MAX_DIST;\n            break;\n        \n        }\n        \n        if (abs(d.x) < 0.00001 || t > MAX_DIST) {\n        \n            break;\n        \n        }\n    \n    }\n    \n    return d;\n\n}\n\n\nfloat calcShadow( vec3 rp, vec3 rl, vec3 n )\n{\n\n    vec3 nro = rp + n * 0.01;\n    \n    float t = 0.0;\n    vec2 d = castRay(nro, rl, t);\n    \n    if (t < MAX_DIST) {\n    \n        return 1.0 / (1.0 + (pow(t, 2.0) * 0.001));\n    \n    }\n    \n    return 0.0;\n\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.00001 * t;\n    return normalize( e.xyy * scenePoint( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx * scenePoint( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy * scenePoint( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx * scenePoint( pos + e.xxx ).x );   \n}\n\n\nfloat pickClosestLightBean(vec3 b)\n{\n    return min(b.x, min(b.y, b.z));\n}\n\n\nfloat getLighting(vec3 ro, vec3 rd, vec3 rp, vec3 n)\n{\n\n    vec3 light = normalize( vec3(-1.5, -2.0, -3.5) ) * 1.5;\n    // vec3 light = normalize( vec3(-0.5, -2.0, 0.5) ) * 1.5;\n\n    float dif = max( 0.0, -dot( light, n ) );\n    \n    float shd = 1.0 - calcShadow(rp, -light, n);\n        \n    float occ = 0.5 + n.y * 0.5;\n    \n    // lighthouse beams\n    \n    float beamLight = 0.0;\n        \n    vec3 toLantern = rp - lighthouseLantern;\n    float toLanternDist = length(toLantern);\n    toLantern = normalize(toLantern);\n    \n    if (rp.y > 8.0 && rp.y < 45.0) {\n    \n        dif += dot(toLantern, n) * 1.5;\n    \n    }\n    \n    float lighthouseOcclusion = smoothstep(10.0, 120.0, toLanternDist);\n    float directIllumination = max(0.0, -dot(toLantern, n) );\n        \n    float lightBeamDistance = pickClosestLightBean(sdLighhouseBeam(rp));\n    \n    beamLight += exp(-lightBeamDistance * 0.01) * directIllumination * lighthouseOcclusion * 0.3333;\n    \n    if (lightBeamDistance < 0.0 && toLanternDist < 5.0)\n    {\n        \n        float lanternGlow = smoothstep(0.1, 1.0, -lightBeamDistance);\n        beamLight += lanternGlow * 1.0;\n    \n    }\n    \n    return (dif * 0.75) * (0.3 + shd * 0.7) + occ * (0.2 + shd * 0.3) + beamLight * 2.5;\n\n}\n\n\nvec2 getLighthouseLight(vec3 ro, vec3 rd)\n{\n    \n    vec3 b = sdLighhouseBeam(ro);\n    float d = pickClosestLightBean(b);\n    \n    float t = d;\n    vec3 rp = ro + rd * t;\n    \n    for (int i=0; i<100; i++) {\n        \n        b = sdLighhouseBeam(rp);\n        d = pickClosestLightBean(b);\n        \n        t += d;\n        \n        if (d < 0.01 || t >= MAX_DIST) {\n            \n            break;\n            \n        }\n        \n        rp = ro + rd * t;\n    \n    }\n    \n    vec2 e = vec2(1.0,-1.0)*0.001 * t;\n    \n    vec3 bn0 = sdLighhouseBeam( rp + e.xyy );\n    vec3 bn1 = sdLighhouseBeam( rp + e.yyx );\n    vec3 bn2 = sdLighhouseBeam( rp + e.yxy );\n    vec3 bn3 = sdLighhouseBeam( rp + e.xxx );\n    \n    vec3 n1 = normalize( e.xyy * bn0.x + \n                         e.yyx * bn1.x + \n\t\t\t\t\t     e.yxy * bn2.x + \n\t\t\t\t\t     e.xxx * bn3.x );   \n    float a1 = pow(max(0.0, dot(rd, -n1)), 2.0);\n    \n    vec3 n2 = normalize( e.xyy * bn0.y + \n                         e.yyx * bn1.y + \n\t\t\t\t\t     e.yxy * bn2.y + \n\t\t\t\t\t     e.xxx * bn3.y );   \n    float a2 = pow(max(0.0, dot(rd, -n2)), 2.0);\n    \n    vec3 n3 = normalize( e.xyy * bn0.z + \n                         e.yyx * bn1.z + \n\t\t\t\t\t     e.yxy * bn2.z + \n\t\t\t\t\t     e.xxx * bn3.z );   \n    float a3 = pow(max(0.0, dot(rd, -n3)), 2.0);\n    \n    //float a = (a1 + a2 + a3) * 0.3333;\n    a1 = 0.4 + a1 * 0.6;\n    a2 = 0.4 + a2 * 0.6;\n    a3 = 0.4 + a3 * 0.6;\n    \n    float a = a1 * a2 * a3;\n    \n    float n = GradientNoise2D( vec2(rp.x + iTime * 2.0, rp.z) * 0.05, 4, 0.5 );\n    a *= (0.5 + n * 0.5);\n    \n    float beamLight = exp(-(t - 0.0) * 0.002);\n    \n    float light = smoothstep(0.1, 1.0, beamLight * smoothstep(0.1, 1.0, 0.25 + a * 0.9));\n    \n    return vec2(t, light);\n\n}\n\n\nvec4 getMaterial(vec3 ro, vec3 rd, vec3 rp, vec3 n, float t, vec2 ob) \n{\n    \n    float l = 0.5;\n    float detail = exp(-t * 0.005);\n    // vec3 light = normalize( vec3(-1.0, -1.0, 0.5) );\n\n    // Sky color\n    vec3 brickColor = vec3(0.32, 0.28, 0.25);\n    vec3 skycolor = vec3(0.825, 0.8, 0.925) * 0.9 - rd.y * 0.5 + rd.x * 0.3;\n    vec3 col = skycolor;\n    \n    vec3 beam = getLightBeam(0.0);\n\n    // Sea color\n    if (t < MAX_DIST && ob.x < 0.1 )\n    {\n        \n        vec3 q = rp - lighthouseOrigin;\n        q.xz = mat2(0.7071, -0.7071, 0.7071, 0.7071) * q.xz;\n        \n        if (ob.y == MATERIAL_SEA)\n        {\n            \n            float ht = 1.0 - exp(-rp.z * 0.005);\n            col = mix(vec3(0.05, 0.25, 0.3), vec3(0.1, 0.15, 0.3), ht);\n\n            float d = length(rp.xz - lighthouseOrigin.xz);\n            d = 1.0 - smoothstep(0.0, 35.0, d);\n            \n            float ns = GradientNoise2D( vec2(rp.x + iTime * 2.5, rp.z) / 1.0, 5, 0.9 );\n            // ns = smoothstep(0.0, 1.0, ns);\n            \n            col = mix(col, vec3(1.0 + pow(d, 2.0) * 2.5 * ns), ns * pow(d, 0.5));\n        \n        } \n        else if (ob.y == MATERIAL_LIGHTHOUSE) \n        {\n                \n            float n0 = GradientNoise2D( vec2(atan(q.z/q.x) / 3.141592 * 7.0, q.y * 0.05), 4, 0.5 );\n            float n1 = GradientNoise2D( vec2(atan(q.z/q.x) / 3.141592 * 9.0, q.y * 0.5), 4, 0.5 );\n                            \n\n            if (rp.y < 9.1) \n            {\n                // foundation - dark\n                \n                vec2 brick = brickLuminance(q * vec3(1.0, 1.5, 1.0) - vec3(0.0, -1.4, 0.0));\n                col = brickColor * brick.x;\n                col += brick.y * 0.75 * detail;\n                \n                vec3 rust = mix(vec3(0.15, 0.1 + n0 * 0.1, 0.1), vec3(0.2 + n1 * 0.15, 0.1, 0.05), smoothstep(0.25, 0.9, n1));\n                col = mix(col, rust, smoothstep(0.5, 0.75, n0) * 0.75);\n            \n            }\n            else if (rp.y < 21.41 && rp.y > 9.1 && length(q.xz) <= 5.5) \n            {\n                // tower - dark section\n                \n                vec2 brick = brickLuminance(q * vec3(2.0, 3.0, 2.0) - vec3(0.0, -1.65, 0.0));\n                col = brickColor * brick.x;\n                col += brick.y * 0.95 * detail;\n                \n                col = col + smoothstep(0.4, 0.7, n0) * 0.2;\n                col = mix(col, vec3(0.4, 0.2, 0.05), smoothstep(0.4, 0.9, n1) * 0.75);\n            \n            }\n            else if (rp.y < 35.6 && rp.y > 21.41)\n            {\n\n                // tower - white section\n                \n                col = vec3(0.95);\n                vec2 brick = brickLuminance(q * vec3(2.0, 3.0, 2.0) - vec3(0.0, -1.65, 0.0));\n                \n                col = col * 0.85 + brick.x * 0.15;\n                col -= brick.y * 0.3 * detail;\n                \n                col = col - smoothstep(0.5, 0.7, n0) * 0.1;\n                \n                // stripes\n                if ((rp.y > 24.5 && rp.y < 24.8) || (rp.y > 27.5 && rp.y < 27.8)) \n                {\n                    \n                    col = col * 0.1;\n                \n                }\n                \n                // letters\n                \n                vec2 lpos = vec2( atan(q.z/q.x) * 1.9 + 0.45, (rp.y - 23.95) / 2.2 );\n                \n                if (paintedLetters(lpos) < 0.0) {\n    \n                    col = col * 0.1;\n    \n                }\n\n                \n            }\n            else if (rp.y < 39.25 && rp.y > 36.4 && length(q.xz) <= 4.0) \n            {\n                // tower - lanter base\n                \n                vec2 brick = brickLuminance(q * vec3(1.0, 2.0, 1.0) - vec3(0.0, -0.25, 0.0));\n                col = brickColor * brick.x;\n                col += brick.y * 0.65 * detail;\n            \n            }\n            \n            else if (rp.y < 42.8 && rp.y > 39.25)\n            {\n                \n                // lantern\n                \n                float ribs = pow(abs(sin(6.0 * atan(q.z / q.x))), 20.0);\n                \n                vec3 lanternCol = mix(vec3(0.95, 0.7, 0.65), vec3(0.95, 0.9, 0.85), smoothstep(0.0, 2.0, abs(rp.y - lighthouseLantern.y)) );\n                \n                col = mix(lanternCol, skycolor, 0.25);\n                \n                col = mix(lanternCol * 2.0, vec3(0.1), smoothstep(0.5, 0.75, ribs));\n                \n                float an = atan(q.z/q.x);\n                \n                float a = dot(beam, -vec3(cos(an), 0, sin(an)));\n                \n                col = col * (1.0 + a * 0.25);\n            \n            }\n\n            else\n            {\n                \n                float ns = GradientNoise2D( vec2(q.x, q.z) / 15.0, 5, 0.65 );\n                vec3 rust = mix(vec3(0.15, 0.1 + ns * 0.075, 0.05), vec3(0.3 - ns * 0.1, 0.14, 0.05), smoothstep(0.15, 0.65, n1));\n                \n                col = vec3(0.025, 0.09, 0.05) - ns * 0.25;\n                col = mix(col, rust, smoothstep(0.5, 0.9, ns));\n                \n            \n            }\n        \n        }\n        else if (ob.y == MATERIAL_LIGHTHOUSE_WINDOW) \n        {\n            \n            if (length(q.xz) + q.y * 0.03 < 3.77) {\n            \n            // if (abs(sin(rp.y * 7.68 - 0.75)) > 0.9) {\n                if (length(q.xz) <= 5.0 && (abs(sin(atan(q.z/q.x) * 48.0 + 0.1)) > 0.85 || abs(sin(rp.y * 7.65 - 0.5)) > 0.95)) {\n\n                    col = vec3(0.75);\n\n                }\n                else if (abs(q.y - 4.0) < 4.0)\n                {\n                    col = vec3(0.95, 0.9, 0.85) * 3.0;\n                }\n                else\n                {\n                \n                    col = vec3(0.05, 0.02, 0.1);\n                \n                }\n                \n                \n            }\n            else\n            {\n            \n                if (rp.y < 19.0) {\n            \n                    col = brickColor;\n                    \n                }\n                else\n                {\n                \n                    col = vec3(0.75);\n                \n                }\n            }\n        \n        }\n        else if (ob.y == MATERIAL_LIGHTHOUSE_BEAM)\n        {\n            \n            col = vec3(1.0, 0.98, 0.95) * 1.0;\n            \n        }\n        \n                \n        float occ = 0.5 + n.y * 0.5;\n        col = mix(col, skycolor, occ * 0.3333);\n        \n        l = getLighting(ro, rd, rp, n);\n        \n    }\n    \n    float fog = smoothstep(140.0, 300.0, t) - abs(rd.y) * 1.0;\n    \n    float ns = GradientNoise2D( vec2(rp.x + iTime * 50.0, rp.y) * 0.0015, 4, 0.5 );\n        \n    vec3 fogColor = vec3(0.95, 0.97, 1.0) * skycolor + 0.6 * (0.6 * ns - 0.2);\n    \n    col = mix(col, smoothstep(0.1, 1.0, fogColor), fog);\n    \n    l = mix(l, 1.0, fog);\n    \n    vec2 lhl = getLighthouseLight(ro, rd);\n    \n    if (lhl.x < t) {\n        \n        col = col * (1.0 + lhl.y);\n    \n    }\n    \n    \n    vec3 toLantern = normalize(lighthouseLantern - ro);\n    float beamblast = max(0.0, dot(beam, -toLantern)) * max(0.0, dot(toLantern, vec3(0.0, 0.0, 1.0)));\n    beamblast = smoothstep(0.75, 1.0, beamblast);\n    \n    float depth = exp(-t * 0.003);\n    col = col * (1.0 + (beamblast * 0.1 * depth));\n    \n    // col = smoothstep(0.15, 1.0, col);\n    \n    return vec4(col, l);\n\n}\n\n\n\nvec3 render( vec3 ro, vec3 rd, float t, vec2 ob ) {\n            \n    vec3 rp = ro + rd * t;\n    \n    vec3 n = calcNormal(rp, t);\n    vec4 mt = getMaterial(ro, rd, rp, n, t, ob);\n    \n    vec3 col = mt.rgb * mt.a;\n    \n    float fogT = smoothstep(0.0, 500.0, t);\n    \n    if (ob.y == MATERIAL_SEA && fogT < 1.0)\n    {\n            \n        vec3 rrd = reflect(rd, n);\n        vec3 rro = rp + n * 0.01;\n            \n        float rt = 0.0;\n        vec2 rob = castRay(rro, rrd, rt);\n        \n        vec3 rrp = rro + rrd * rt;\n        \n        vec3 rn = calcNormal(rrp, rt);\n        vec4 rmt = getMaterial(rro, rrd, rrp, rn, rt, rob);\n        vec3 rcol = rmt.rgb * rmt.a;\n        \n        col = mix(col - 0.1 * (1.0 - fogT), rcol, 0.3 * (1.0 - fogT));\n        \n    }\n\n    return col;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragCoord = fragCoord * 1.2;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = ((2.0 * fragCoord) - iResolution.xy) / iResolution.y;\n    \n    // Camera\n    \n    // 15.0, 0.2\n    float cameraHeight = 15.0;\n    float cameraPitch = 0.2;\n    \n    vec3 ro = vec3(0, cameraHeight, -4.0);\n    vec3 sp = vec3(0, cameraHeight + cameraPitch, 0);\n    vec3 rd = normalize( vec3(uv, 0.0) + sp - ro);\n\n    // Ray marching to the scene\n    float t = 0.0;\n    vec2 ob = castRay(ro, rd, t);\n\n    // Rendering the scene\n    vec3 col = render(ro, rd, t, ob);\n    \n    \n    float L = dot(smoothstep(0.05, 1.0, col), vec3(0.299, 0.587, 0.114));\n    \n    col = col * vec3(1.0, 0.98, 0.9);\n    col = mix(col, vec3(L), 0.5);\n    \n    col = mix(col, smoothstep(0.0, 0.95, col), 0.25);\n    \n    if (iTime < 8.0 && paintedLetters(uv * vec2(1.4, 1.2) - vec2(-0.08, -0.75)) < 0.0) {\n    \n        col = mix(vec3(1.0), col, smoothstep(7.0, 7.5, iTime));\n    \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}