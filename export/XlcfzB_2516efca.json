{"ver":"0.1","info":{"id":"XlcfzB","date":"1540063434","viewed":205,"name":"3D Ball Shader","username":"Hullburg","description":"Renders a ball in 3D w/o using polygons.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","ball","lightning","mapprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Hullburg\n\nconst float fov = radians(75.);\t// vertical field of view\nconst float dts = 1./tan(fov / 2.);\t// eye distance to screen / screen height\n\nconst float pi = radians(180.);\n\nfloat sqr(float num) {\n    return num*num;\n}\nfloat lsqr(vec3 v) {\n\treturn sqr(v.x)+sqr(v.y)+sqr(v.z);    \n}\nfloat lsqr(vec2 v) {\n\treturn sqr(v.x)+sqr(v.y);    \n}\n/*vec3 vsqr(vec3 v) {\n    return v*v;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mouse coord normalized\n    vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    m = iMouse.xy == vec2(0.) ? vec2(0) : m;\n    \n    \n    vec3 c = vec3(m.x*2., sin(iTime), m.y*4. + 2.);\t// ball center\n    float r = 1.;\t// ball radius\n    vec4 b = vec4(c, r);\t// ball\n    \n    vec3 o = vec3(0.,0., 0.);\t// camera pos\n    vec3 cdir = vec3(0., 0. ,0.);\t// camera direction.\n    \n    vec3 sun = normalize(vec3(1., 1., -1.));\t// dir to sun\n    vec3 lightColor = vec3(1., 0.9, 0.7);\n    //float lightPower = 40.;\n    //vec3 ambientColor = vec3(1., 0., 0.);\n    //vec3 diffuseColor = vec3(0., 0.5, 0.);\n    vec3 specColor = lightColor;//vec3(1., 1., 1.);\n    float shininess = 16.;\n    float screenGamma = 2.2;\n    //vec3 sl = -sun;\t// sun light direction\n    //float rca = 0.9 * 0.5*pi;\t// maximum reflection spread on rough surface.\n    \n\n    // Normalized pixel coordinates (from -1 to 1 w/o horizontal stretching)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    \n    vec3 l = normalize(vec3(uv, dts));\t// ray from eyes to screen.\n    \n    // Calculates first intersection of view ray and sphere\n    // https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\n    float delta = sqr(dot(l, (o-c))) - lsqr(o-c) + sqr(r);\n    float loi;\n    float dist1;\n    vec3 poi;\n    \n    vec3 nml;\n    vec3 ref;\n    //float refa;\n    vec2 geo;\n    \n    if (delta > 0.) {\n        loi = sqrt(delta);\t// how far ray travels through ball.\n        dist1 = -dot(l, (o-c)) - loi;\t// use +loi for back side.\n        dist1 += dist1 <= 0. ? 2.*loi : 0.;\t// Show inside of ball.\n        if (dist1 > 0.) {\n            poi = l * dist1;\t// where ray hits ball.\n\n            nml = (poi - c) / r;\t// point in ball space = surface normal.\n\n            ref = reflect(-sun, nml); // sun reflection.\n            //refa = acos(dot(ref, -l));\t//angle\n\n            \n        }\n    }\n    \n\n    // Pixel color;\n    vec3 col;\t// Surface color?\n    if (delta < 0. || dist1 < 0.) {\t// no poi.\n        //*\n\t\tcol = texture(iChannel3, l).rgb;\t// show background\n        /*\n\t\tcol.r *= pow(col.r,5.);\n        col.g *= pow(col.g,5.);\n        col.b *= pow(col.b,5.);\n\t\t//*/\n    } else {\n        \n        // 1. Map projection of texture on ball.\n        geo = vec2(atan(nml.x/nml.z), acos(nml.y/r));\t// geographic coord on ball (x is lattitude, y is longitude).\n        geo.x += iTime;\t// Spin ball.\n        vec2 proj;\n        \n        // Equirectangular\n        proj = geo;\n        \n        // Cassini\n        //proj.x = asin(cos(geo.x)*sin(geo.y));\n        //proj.y = atan(tan(geo.x)/cos(geo.y));\n        \n        // Ortographic\n        //proj = nml.xy;\n        \n        // Sinusoidal\n        //proj.x = geo.y*sin(geo.x);\n        //proj.y = geo.x;\n\n        /*\n        vec3 diffuseColor = texture(iChannel1, proj).rgb;\n        vec3 ambientColor = diffuseColor * 0.1;\n        //col.rgb = col.ggb;\n        \n        // 2. Sunlight.\n        // Uses Blinn-Phong model\n        // https://en.wikipedia.org/wiki/Blinnâ€“Phong_shading_model\n        float lambertian = max(0., dot(sun, nml));\n        float specular;\n        \n        if (lambertian > 0.) {\n            vec3 reflectDir = reflect(sun, nml);\n            float specAngle = max(0., dot(reflectDir, l));\n            float specular = pow(specAngle, shininess/4.);\n        }\n        vec3 colorLinear = ambientColor +\n            diffuseColor * lambertian * lightColor +\n            specColor * specular * lightColor;\n        \n        // apply gamma correction (assume ambientColor, diffuseColor and specColor\n  \t\t// have been linearized, i.e. have no gamma correction in them)\n  \t\tcol = pow(colorLinear, vec3(1.0/screenGamma));\n        col = vec3(specular);\n        \n        */// 3. Metallic/mirror Refelection.\n        //col *= 0.8;\n        col += 1. * texture(iChannel2, reflect(l, nml)).rgb;\n        col *= vec3(1.);\n        \n        // 4. Other\n        //col = vec3(refa / pi);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}