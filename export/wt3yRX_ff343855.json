{"ver":"0.1","info":{"id":"wt3yRX","date":"1609608632","viewed":64,"name":"Clock GMT","username":"m1ke","description":"A functional GMT clock. (12-hour version)\n\nR : Seconds\nG = minutes\nB : Hours","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["clock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n    vec2 pos;\n    float radius;\n    vec3 colour;\n};\nSphere newSphere(vec2 p, float r, vec3 c)\n{\n    Sphere s;\n    s.pos = p;\n    s.radius = r;\n    s.colour = c;\n    return s;\n}\nstruct Ring\n{\n    vec2 pos;\n    vec3 colour;\n    float radius;\n    float thickness;\n};\nRing newRing(vec2 p, float r, float t, vec3 c)\n{\n    Ring ri;\n    ri.pos = p;\n    ri.radius = r;\n    ri.thickness = t;\n    ri.colour = c;\n    return ri;\n}\n\nstruct Line\n{\n    vec2 a;\n    vec2 b;\n    float thickness;\n    float l;\n    vec3 colour;\n};\nLine newLine(vec2 a, vec2 b, float t, vec3 c)\n{\n    Line l;\n    l.a = a;\n    l.b = b;\n    l.thickness = t;\n    l.l = length(a-b);\n    l.colour = c;\n    return l;\n}\nfloat dstToLine(Line l, vec2 c)\n{\n\tfloat s1 = -l.b.y + l.a.y;\n\tfloat s2 = l.b.x - l.a.x;\n\treturn abs((c.x - l.a.x) * s1 + (c.y - l.a.y) * s2) / sqrt(s1*s1 + s2*s2);\n}\n\nbool inLine(Line l, vec2 p)\n{\n    return (p.x-l.thickness < max(l.a.x,l.b.x) && p.x+l.thickness > min(l.a.x,l.b.x) && p.y-l.thickness < max(l.a.y,l.b.y) && p.y+l.thickness > min(l.a.y,l.b.y) && dstToLine(l,p) < l.thickness);\n}\n\nbool inSphere(vec2 point, Sphere s)\n{\n    return length(point - s.pos) < s.radius;\n}\nbool inRing(vec2 point, Ring r)\n{\n    return !inSphere(point, newSphere(r.pos, r.radius, r.colour)) && inSphere(point, newSphere(r.pos, r.radius+r.thickness, r.colour));\n}\nvoid DrawSphere(inout vec3 col, vec2 p, Sphere s)\n{\n    if (inSphere(p, s))\n    {\n        col = s.colour;\n    }\n}\nvoid DrawLine(inout vec3 col, vec2 p, Line l)\n{\n    if (inLine(l, p))\n    {\n        col = l.colour;\n    }\n}\nvoid DrawRing(inout vec3 col, vec2 p, Ring r)\n{\n    if (inRing(p, r))\n    {\n        col = r.colour;\n    }\n}\nconst float PI = 3.14159265359;\n\nvec2 angle(float a, float l)\n{\n    return vec2(sin(a), cos(a)) * l * iResolution.x/5.0f;\n}\nvoid DrawMarks(inout vec3 col, vec2 p, vec2 middle)\n{\n    for (int i = 0; i < 12; i++)\n    {\n        float thisAngle = PI*2.0f * (float(i) / 12.0f);\n        vec2 thisRot = angle(thisAngle, 1.0f);\n        Line thisL = newLine(middle+thisRot*0.9f, middle+thisRot, 1.0f, vec3(0,0,0));\n        DrawLine(col, p, thisL);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    Sphere a = newSphere(iResolution.xy/2.0f,iResolution.x / 5.0f, vec3(1,1,1));\n    \n    DrawSphere(col, fragCoord, a);\n    \n    vec2 middle = iResolution.xy / 2.0f;\n    \n    float secondx = PI*2.0f * (iDate.w/60.0f);\n    vec2 secondrot = angle(secondx, 0.9f);\n    Line secondl = newLine(middle, vec2(middle +secondrot), 3.0f, vec3(1,0,0));\n    DrawLine(col, fragCoord, secondl);\n    \n    float minx = PI*2.0f * (iDate.w/60.0f/60.0f);\n    vec2 minrot = angle(minx, 0.7f);\n    Line minl = newLine(middle, vec2(middle +minrot), 3.0f, vec3(0,1,0));\n    DrawLine(col, fragCoord, minl);\n    \n    float hourx = PI*2.0f * (iDate.w/3600.0f/12.0f);\n    vec2 hourrot = angle(hourx, 0.6f);\n    Line hourl = newLine(middle, vec2(middle +hourrot), 3.0f, vec3(0,0,1));\n    DrawLine(col, fragCoord, hourl);\n    \n    DrawMarks(col, fragCoord, middle);\n    \n    Ring r = newRing(middle, iResolution.x/5.0f, 5.0f, vec3(0,0,0));\n    DrawRing(col, fragCoord, r);\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}