{"ver":"0.1","info":{"id":"3tcBWN","date":"1613036837","viewed":352,"name":"Soul 22","username":"okdalto","description":"I really enjoyed watching the movie Soul. Throughout the movie, I looked at the volumetric bodies and geometries.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","22","soul"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHTSTEP 20.0\n#define CHEEKRADIUS 0.3\n#define TRANSLUCENT 1\n#define OPAQUE 0\n#define AMBIENTCOLOR vec3(0.1, 0.2, 0.4)\n\nfloat hash13(vec3 p3) \n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid rotX(inout vec3 z, float s, float c) \n{\n   z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\n\nvoid rotY(inout vec3 z, float s, float c) \n{\n   z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\n\nvoid rotZ(inout vec3 z, float s, float c) \n{\n   z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\n\nvoid rotX(inout vec3 z, float a) \n{\n   rotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) \n{\n   rotY(z, sin(a), cos(a));\n}\n\nvoid rotZ(inout vec3 z, float a) \n{\n   rotZ(z, sin(a), cos(a));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) \n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n    \nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat body(in vec3 z)\n{    \n    float d1 = 1e+8;\n    z.y += 0.57;\n    \n    vec3 armPos = z;\n    armPos.x = abs(armPos.x);\n    armPos.x -= 0.35;\n    rotX(armPos, -0.3 * z.y);\n    rotZ(armPos, 0.7 * z.y + 0.2);\n    float arm = sdEllipsoid(armPos, vec3(0.08, 0.5, 0.15));\n    d1 = opSmoothUnion(d1, arm, 0.1);\n        \n    float torso = sdRoundCone(z - vec3(0.0, -0.1, 0.0), 0.34, 0.2, 0.5);\n    d1 = opUnion(d1, torso);\n    z.y -= 0.3;\n    float box = sdBox(z, vec3(0.5, 0.2, 0.5));\n    float d2 = opSmoothUnion(arm, torso, 0.05);\n    \n    return opUnion(d1, d2);\n}\n\nfloat head(vec3 z)\n{\n    z.y *= 1.32;\n    z.y -= 0.56;\n    return sdRoundCone(z, 0.68, 0.59, 0.12) - 0.1;\n}\n\nfloat cheek(vec3 z)\n{\n    z.x = abs(z.x);\n    z += vec3(-0.5, -0.27, 0.48);\n    float eyeballs = sdSphere(z, CHEEKRADIUS);\n    return eyeballs;\n}\n\nfloat horn(vec3 z)\n{\n    rotX(z, 0.1);\n    rotZ(z, 0.4);\n    float horn = sdCone(z - vec3(0.0, 1.32, 0.0), vec2(0.3, 0.7), 0.6);\n    return horn;\n}\n\nfloat eyelids(vec3 z)\n{\n    z.x = abs(z.x);\n    z.yz += vec2(-0.5, 0.58);\n    z.x += z.y * 0.05 - 0.15;\n    float d = sdSphere(z, 0.217);\n    z.y += 0.24;\n    float box = sdBox(z, vec3(0.3));\n    return opSubtraction(box, d);\n}\n\nfloat eyes(vec3 z)\n{\n    z.x = abs(z.x);\n    z.xyz += vec3(-0.15, -0.5, 0.58);\n    z.x += z.y * 0.05;\n    float eyeballs = sdSphere(z, 0.2);\n    return eyeballs;\n}\n\nfloat pupils(vec3 z)\n{\n    z.x = abs(z.x);\n    z.yz += vec2(-0.53, 0.76);\n    z.x += z.y * 0.05 - 0.15;\n    z.z *= 1.6;\n    float pupils = sdSphere(z, 0.055);\n    return pupils;\n}\n\nfloat highlights(vec3 z)\n{\n    z.x = abs(z.x - 0.02);\n    z.y -= 0.53;\n    z.xz += vec2(z.y * 0.05 - 0.15, 0.78);\n    float eyeballs = sdSphere(z, 0.005);\n    return eyeballs;\n}\n\nfloat eyebrows(vec3 z)\n{\n    z.yz += (-0.07, -0.04) * (sign(z.x) + 1.0) * 0.5;\n    z.x = abs(z.x);\n    rotZ(z, -z.x * 0.5);\n    rotY(z, -z.x);\n    z += vec3(-0.06, sin((z.x-0.06) * 50.0) * 0.05 - 0.77, 0.65);\n    return sdBox(z, vec3(.04,1.2*(0.023-smoothstep(-0.01, 0.12, z.x*0.1)),.01));\n}\n\nfloat mouth(vec3 z)\n{\n    z.yz += vec2(1.3, -0.24);\n    rotZ(z, z.x * 0.5 + 0.1);\n    float shape = sdBox(z, vec3(0.27,0.001,0.7));\n    return shape;\n}\n\nfloat mouthColor(vec3 z){\n    z.yz += vec2(-0.24, 1.3);\n    rotZ(z, z.x * 0.5 + 0.1);\n    float shape = sdBox(z, vec3(0.4,0.05,0.9));\n    return shape;\n}\n\nfloat teeth(vec3 z){\n    z.yz += vec2(-0.21, 0.72);\n    rotY(z, -z.x * 0.8);\n    rotZ(z, z.x * 3.0 + 0.06);\n    return sdRoundBox(z, vec3(0.1,0.04,0.002), 0.02);\n}\n\n\nvec3 getColor(float d){\n    vec3 c1 = vec3(0.5, 0.99, 0.65);\n    vec3 c2 = vec3(0, 0, 2);\n    float a = smoothstep(0.0, 0.3, d);\n    return mix(c1, c2, a);\n}\n\nvoid setColor(inout int material, in vec3 z, inout vec3 color)\n{\n    float dist = 1e+8;\n    vec3 headColor = vec3(0.5, 0.99, 0.65);\n    vec3 cheekColor = vec3(0.8, 0.6, 0.4);\n    float body = body(z);\n    if(dist > body)\n    {\n        material = 1;\n        color = headColor;\n        dist = body;\n    }\n    float cheek = cheek(z);\n    if(dist > cheek)\n    {\n        material = 1;\n        color = vec3(mix(headColor, cheekColor, smoothstep(CHEEKRADIUS*0.005, CHEEKRADIUS, -cheek * 1.2) ));\n        dist = cheek;\n    }    \n    float head = head(z);\n    float teeth = teeth(z);\n    if(dist > head)\n    {\n        material = 1;\n        color = headColor;\n        dist = head;\n    }\n    float horn = horn(z);\n    if(dist > horn)\n    {\n        material = 1;\n        color = headColor;\n        dist = horn;\n    }\n    float eyes = eyes(z);\n    if(dist > eyes)\n    {\n        material = 0;\n        color = vec3(1.0, 1.0, 0.8);\n        dist = eyes;\n    }\n    float eyelids = eyelids(z);\n    if(dist > eyelids)\n    {\n        material = 0;\n        color = vec3(173.0, 215.0, 228.0)/255.0;\n        dist = eyelids;\n    }\n    float eyebrows = eyebrows(z);\n    if(dist > eyebrows)\n    {\n        material = 0;\n        color = vec3(0.2, 0.1, 0.2);\n        dist = eyebrows;\n    }\n    float pupils = pupils(z);\n    if(dist > pupils)\n    {\n        material = 0;\n        float highlights = highlights(z);\n        if(dist > highlights)\n        {\n            color = vec3(1.0);\n        }\n        else\n        {\n            color = vec3(0.2, 0.1, 0.2);\n        }\n        dist = pupils;\n    }\n\n    float mouthColor = mouthColor(z);\n    if(dist > mouthColor)\n    {\n        if(dist > teeth)\n        {\n            color = vec3(1.0);\n            material = 0;\n        }\n        else\n        {\n            color = vec3(mix(headColor, headColor * 0.05, smoothstep(0.0, 0.1, -mouthColor) ));\n            material = 1;\n        }\n        dist = mouthColor;\n    }\n    if(dist > teeth)\n    {\n        material = 0;\n        color = vec3(218.0, 237.0, 236.0)/255.0;\n        dist = teeth;\n    }\n}\n\nfloat DE(in vec3 z)\n{\n    vec3 color = vec3(0.0);\n    float d = body(z);\n    \n    float head = head(z);\n    d = opSmoothUnion(d, head, 0.16);\n    float horn = horn(z);\n    d = opSmoothUnion(d, horn, 0.2);\n    float eyes = eyes(z);\n    d = opUnion(d, eyes);\n    float eyelids = eyelids(z);\n    d = opUnion(d, eyelids);\n    float eyebrows = eyebrows(z);\n    d = opUnion(d, eyebrows);\n    float pupils = pupils(z);\n    d = opUnion(d, pupils);\n    float mouth = mouth(z);\n    d = opSmoothSubtraction(mouth, d, 0.05);\n    float teeth = teeth(z);\n    d = opUnion(teeth, d);\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 ep = vec2(1e-4, 0);\n    return normalize(vec3(\n        DE(p + ep.xyy) - DE(p - ep.xyy),\n        DE(p + ep.yxy) - DE(p - ep.yxy),\n        DE(p + ep.yyx) - DE(p - ep.yyx)\n        ));\n}\n\nvec3 scatteringCoeff = vec3(0.9, 0.4, 0.08);\n\nfloat getDensity(vec3 rayPos)\n{\n    return clamp(-DE(rayPos) * 20.0, 0.0, 1.0) * smoothstep(1.6, -1.0, rayPos.y) * 3.0;\n}\n\nvec3 lightFunc(vec3 rayPos, vec3 lightDir, float lightLength)\n{\n    vec3 lightRayPos = rayPos;\n    float div = lightLength/LIGHTSTEP;\n    \n    vec3 col = vec3(1.0);\n    for(float s = 0.0; s < lightLength; s+=div)\n    {\n        lightRayPos += lightDir * div;\n        float density = getDensity(lightRayPos);\n        col *= exp(-density * div * scatteringCoeff * 12.0);\n    }\n    return col;\n}\n\nfloat HenyeyGreenstein( float sundotrd, float g) \n{\n   float gg = g * g;\n   return (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);\n}\n\n// Little tweak of Himalayas, Created by Reinder Nijhoff 2018\n// https://www.shadertoy.com/view/MdGfzh\nvoid marchVolume(inout vec3 col, vec3 rayPos, vec3 rayDir, vec3 cameraPos, vec3 lightPos, inout float T)\n{\n    float deltaStep = 0.007;\n    vec3 volumeCol = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n    for(int i = 0; i < 40; i++)\n    {\n        rayPos += rayDir * deltaStep;\n        float density = getDensity(rayPos);\n        if(density == 0.0)\n        {\n            break;\n        }\n        \n        vec3 lightDir = lightPos - rayPos;\n        float lightLength = length(lightPos - rayPos);\n        lightDir = normalize(lightDir);\n        \n        float sundotrd = dot(rayDir, -lightDir);\n                \n        float scattering =  mix( HenyeyGreenstein(sundotrd, 0.5),\n                                HenyeyGreenstein(sundotrd, -0.2), 0.5 );\n        vec3 S = 0.8 * density * (AMBIENTCOLOR + scattering * lightFunc(rayPos, lightDir, lightLength)) * scatteringCoeff;\n        vec3 sampleExtinction = max(vec3(1e-4), density * scatteringCoeff);\n        vec3 dTrans = exp(-sampleExtinction * deltaStep * 1e+2);\n        vec3 Sint = (S - S * dTrans) / sampleExtinction;\n        volumeCol += transmittance * Sint; \n        transmittance *= dTrans;\n    }\n    col *= abs(volumeCol);\n    T = transmittance.z;\n}\n\nvoid marchSDF(inout int material, inout vec3 surfaceCol, inout vec3 rayPos, vec3 rayDir, vec3 cameraPos, vec3 lightPos, inout float T){\n    float trvlDist = 0.0;\n    for(int i = 0; i < 32; i++){\n        float dist = DE(rayPos);\n        if(dist < 1e-3){\n            rayPos += rayDir * 1e-4;\n            vec3 lightDir = normalize(lightPos - rayPos);\n            vec3 N = getNormal(rayPos);\n            float ldotn = (dot(lightDir, N) + 1.0) * 0.5;\n            setColor(material, rayPos, surfaceCol);\n            if(material == 0){\n                T = 0.0;\n                surfaceCol *= ldotn * ldotn + AMBIENTCOLOR;\n            }\n            return;\n        }\n        trvlDist += dist;\n        rayPos = cameraPos + rayDir * trvlDist;\n    }\n}\n\n//background cloud from patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec3 c1 = vec3(0.2, 0.4, 1.0);\n    vec3 c2 = vec3(0.9, 0.2, 0.86);\n    float newTime = iTime * 0.5;\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    uv.x *= 0.2;\n    float noise = \n        snoise(\n            vec3(uv.yx * 1.4 + vec2(newTime, 0.), newTime) \n        );\n    \n    float a = smoothstep(0.0, 1.0, noise);\n    return mix(c1, c2, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float mousePosition = (iMouse.x/iResolution.x - 0.5) * 2.0 * 3.0;\n\n    vec3 cameraPos = vec3(sin(mousePosition), 0.1, cos(mousePosition)) * 5.0;\n    vec3 cameraFront = normalize(-cameraPos);\n    vec3 cameraRight = cross(vec3(0.0, 1.0, 0.0), cameraFront);\n    vec3 cameraUp = cross(cameraFront, cameraRight);\n    \n    vec3 rayDir = normalize(cameraFront * 3.0 + cameraRight * uv.x + cameraUp * uv.y);\n    vec3 rayPos = cameraPos;\n\n    float newTime = iTime * 1.2;\n    vec3 lightPos = vec3(sin(newTime), cos(newTime * 1.2), cos(newTime * 0.5));\n    \n    vec3 surfaceCol = vec3(0.0);\n    vec3 backgroundCol = clouds(rayDir);\n    int material = 0;\n    \n    float T = 1.0;\n    marchSDF(material, surfaceCol, rayPos, rayDir, cameraPos, lightPos, T);\n    if (material == TRANSLUCENT){\n        marchVolume(surfaceCol, rayPos, rayDir, rayPos, lightPos, T);\n    }\n    \n    vec3 finalCol = mix(surfaceCol, backgroundCol, T);\n    \n    fragColor = vec4(pow(finalCol, vec3(1.0/2.2)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n","name":"Common","description":"","type":"common"}]}