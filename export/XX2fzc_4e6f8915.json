{"ver":"0.1","info":{"id":"XX2fzc","date":"1729776093","viewed":133,"name":"planet with life","username":"nayk","description":"source  https://www.shadertoy.com/view/stsXDl https://www.shadertoy.com/view/MXjBRK https://www.shadertoy.com/view/l32fzG","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["planet","cosmos","life"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535897;\n\nfloat rand2(vec2 uv) {\n    return fract(sin(dot(uv, vec2(13.337, 61.998))) * 48675.75647);\n}\n\nvec2 rotate(vec2 uv, float a) {\n    return vec2(uv.y * cos(a) + uv.x * sin(a), uv.x * cos(a) - uv.y * sin(a));\n}\n\nvec2 rand2x2(vec2 uv) {\n    return vec2(rand2(uv), rand2(-uv));\n}\n\nvec3 rand2x3(vec2 uv) {\n    return vec3(rand2(uv), rand2(-uv), rand2(vec2(-uv.x - 5., uv.y + 1.)));\n}\n\nfloat perl(vec2 uv, float t) {\n    vec2 id = floor(uv);\n    vec2 loc = fract(uv);\n    vec2 sloc = smoothstep(0., 1., loc);\n    return mix(\n        mix(\n            dot(loc, rotate(vec2(1.), rand2(id) * (pi * 2. + t))),\n            dot(loc - vec2(1., 0.), rotate(vec2(1.), rand2(id + vec2(1., 0.)) * (pi * 2. + t))),\n            sloc.x\n        ),\n        mix(\n            dot(loc - vec2(0., 1.), rotate(vec2(1.), rand2(id + vec2(0., 1.)) * (pi * 2. + t))),\n            dot(loc - vec2(1., 1.), rotate(vec2(1.), rand2(id + vec2(1., 1.)) * (pi * 2. + t))),\n            sloc.x\n        ),\n        sloc.y\n    );\n}\n\nfloat fperl(vec2 uv, float t, float iter) {\n    float o = 0., k = 0., p = 1.;\n    for (float i = 0.; i < iter; i++) {\n        o += perl(uv * p, t * p) / p;\n        k += 1. / p;\n        p*=2.;\n    }\n    return o / k;\n}\n\nfloat vor(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 loc = fract(uv);\n    float o = 100.;\n    for (float x = -1.; x <= 1.; x++) {\n        for (float y = -1.; y <= 1.; y++) {\n            o = min(o, distance(sin(2.5 * pi * rand2x2(id + vec2(x, y))) * 0.8 + 0.2, loc - vec2(x, y)));\n        }\n    }\n    return o;\n}\n\nvec3 vorid3(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 loc = fract(uv);\n    float o = 1000.;\n    vec3 ou = vec3(0);\n    for (float x = -1.; x <= 1.; x++) {\n        for (float y = -1.; y <= 1.; y++) {\n            float d = distance(sin(2.5 * pi * rand2x2(id + vec2(x, y))) * 0.8 + 0.2, loc - vec2(x, y));\n            if (o > d) {\n                o = d;\n                ou = rand2x3(id + vec2(x, y));\n            }\n        }\n    }\n    return ou;\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 star(vec2 uv) {\n    float val = vor(uv * 3.);\n    val = 0.01 / val;\n    val = pow(val, 1.7);\n    vec3 col = vec3(val) * (vorid3(uv * 3.));\n    return col * fperl(uv / 2., 0., 2.);\n}\n\nvec3 fstar(vec2 uv, float iter, float t) {\n    vec3 o = vec3(0);\n    float p=1.;\n    for (float i = 0.; i < iter; i++) {\n        o += star(rotate(uv + vec2(0, t*0.201) / p, i) * p);\n        p*=1.5;\n    }\n    return o;\n}\n\nfloat fnebula(vec2 uv, float iter, float t) {\n    float o = 0., p=1.;\n    for (float i = 0.; i < iter; i++) {\n        o += fperl(rotate(uv + vec2(t, 0.) / p, i) * p / 2., 0., 6.);\n        p*=1.5;\n    }\n    return o;\n}\n#define size 035.\n\nvec2 Hash12(float t)\n{\n    float x = fract(sin(t * 36.3) * 453.2);\n    float y = fract(sin(t * 54.3) * 453.2);\n    \n    return vec2(x,y);\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n \nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n// -----------------------------------\n\nfloat easInOutCubic(float x){\n    if(x < 0.5)\n        return 4.*x*x*x;\n    return 1. - pow(-2.*x + 2., 3.) / 2.;\n}\n\n\n\nvec3 gradient(float t){\n    vec3 col1 = vec3(0.29,0.15,0.52);\n    vec3 col2 = vec3(0.48,0.6,0.93);\n    t = easInOutCubic(t);\n    return col1*t + col2*(1.-t);\n}\n\n\nuint hash(uint x)\n{\n    x^=x>>15;\n    x^=(x*x)|1u;\n    x^=x>>17;\n    x*=0x9E3779B9u;\n    x^=x>>13;\n    return x;\n}\n\nfloat hash(vec2 r)\n{\n    ivec2 v=ivec2(r);\n    return float(int(hash(uint(v.x+65535*v.y))))*4.6566129e-10;\n}\n\nfloat hash(vec3 r)\n{\n    ivec3 v=ivec3(r);\n    return float(int(hash(uint(v.x+1024*v.y+1048576*v.z))))*4.6566129e-10;\n}\n\nvec2 hash2(vec2 r)\n{\n    ivec2 v=ivec2(r);\n    uint h=hash(uint(v.x+65535*v.y));\n    return vec2(h&65535u,h>>16)/32768.0-1.0;\n}\n\nvec3 hash3(vec3 r)\n{\n    ivec3 v=ivec3(r);\n    uint h=hash(uint(v.x+1024*v.y+1048576*v.z));\n    return vec3(h&1023u,(h>>10)&1023u,(h>>20)&1023u)/512.0-1.0;\n}\n\n//==============================================================================\n// Noise functions with derivatives.\n\n#if 0\n// 2D value noise. Gradient in xy, value in z.\nvec3 noise2(vec2 r)\n{\n    vec2 i=floor(r),v=fract(r),k=vec2(0,1),t=v*v*v*(v*(v*6.0-15.0)+10.0);\n    float A=hash(i+k.xx);\n    float B=hash(i+k.yx);\n    float C=hash(i+k.xy);\n    float D=hash(i+k.yy);\n    return vec3(vec2(mix(B-A,D-C,t.y),mix(C-A,D-B,t.x))*30.0*v*v*(v*(v-2.0)+1.0),\n                mix(mix(A,B,t.x),mix(C,D,t.x),t.y));\n}\n\n// 3D value noise. Gradient in xyz, value in w.\nvec4 noise3(vec3 r)\n{\n    vec3 i=floor(r),v=fract(r),k=vec3(0,1,0),t=v*v*v*(v*(v*6.0-15.0)+10.0);\n    float A=hash(i+k.xxx);\n    float B=hash(i+k.yxx);\n    float C=hash(i+k.xyx);\n    float D=hash(i+k.yyx);\n    float E=hash(i+k.xxy);\n    float F=hash(i+k.yxy);\n    float G=hash(i+k.xyy);\n    float H=hash(i+k.yyy);\n    return vec4(mix(mix(vec3(B-A,C-A,E-A),vec3(D-C,G-E,F-B),t.yzx),\n                    mix(vec3(F-E,D-B,G-C),vec3(H-G,H-F,H-D),t.yzx),t.zxy)*30.0*v*v*(v*(v-2.0)+1.0),\n                mix(mix(mix(A,B,t.x),mix(C,D,t.x),t.y),\n                    mix(mix(E,F,t.x),mix(G,H,t.x),t.y),t.z));\n}\n#else\n// 2D gradient noise. Gradient in xy, value in z.\nvec3 noise2(vec2 r)\n{\n    vec2 i=floor(r),v=fract(r),k=vec2(0,1),t=v*v*v*(v*(v*6.0-15.0)+10.0);\n    vec2 A=hash2(i+k.xx); float a=dot(A,v-k.xx);\n    vec2 B=hash2(i+k.yx); float b=dot(B,v-k.yx);\n    vec2 C=hash2(i+k.xy); float c=dot(C,v-k.xy);\n    vec2 D=hash2(i+k.yy); float d=dot(D,v-k.yy);\n    return vec3(mix(vec2(b-a,c-a),vec2(d-c,d-b),t.yx)*30.0*v*v*(v*(v-2.0)+1.0)+\n                mix(mix(A,B,t.x),mix(C,D,t.x),t.y),\n                mix(mix(a,b,t.x),mix(c,d,t.x),t.y));\n}\n\n// 3D gradient noise. Gradient in xyz, value in w.\nvec4 noise3(vec3 r)\n{\n    vec3 i=floor(r),v=fract(r),k=vec3(0,1,0),t=v*v*v*(v*(v*6.0-15.0)+10.0);\n    vec3 A=hash3(i+k.xxx); float a=dot(A,v-k.xxx);\n    vec3 B=hash3(i+k.yxx); float b=dot(B,v-k.yxx);\n    vec3 C=hash3(i+k.xyx); float c=dot(C,v-k.xyx);\n    vec3 D=hash3(i+k.yyx); float d=dot(D,v-k.yyx);\n    vec3 E=hash3(i+k.xxy); float e=dot(E,v-k.xxy);\n    vec3 F=hash3(i+k.yxy); float f=dot(F,v-k.yxy);\n    vec3 G=hash3(i+k.xyy); float g=dot(G,v-k.xyy);\n    vec3 H=hash3(i+k.yyy); float h=dot(H,v-k.yyy);\n    return vec4(mix(mix(vec3(b-a,c-a,e-a),vec3(d-c,g-e,f-b),t.yzx),\n                    mix(vec3(f-e,d-b,g-c),vec3(h-g,h-f,h-d),t.yzx),t.zxy)*30.0*v*v*(v*(v-2.0)+1.0)+\n                mix(mix(mix(A,B,t.x),mix(C,D,t.x),t.y),\n                    mix(mix(E,F,t.x),mix(G,H,t.x),t.y),t.z),\n                mix(mix(mix(a,b,t.x),mix(c,d,t.x),t.y),\n                    mix(mix(e,f,t.x),mix(g,h,t.x),t.y),t.z));\n}\n#endif\n\n//==============================================================================\n// Simple fBm heightmap.\n// See also https://www.shadertoy.com/view/DtdyDl for slightly more advanced cases.\n\nvec4 height(vec3 r)\n{\n    float a=0.375,b=2.25,A=1.0,B=1.0;\n    vec4 ret=vec4(0);\n    for(int i=0;i<8;++i)\n    {\n        ret+=vec4(A*B,A*B,A*B,A)*noise3(B*r);\n        A*=a;\n        B*=b;\n    }\n    return ret;\n}\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( 2.*fragCoord - iResolution.xy ) / min( iResolution.x, iResolution.y);\n\n\nvec4 O=fragColor;\nvec2 C =fragCoord;\n O=vec4(0);\n    vec3 n1,q,r=iResolution,\n    d2=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(0.001, 0.5,3.),H(g*3.12),.8)*3./e/8e3\n    )\n    {\n       n1=g*d2;\n        \n        a=30.;\n       n1=mod(n1-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n           n1=.3-abs(n1);\n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.7+sin(iTime*.1001)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    15.5*3.,\n                    130,\n                    11.*5.\n                 );\n         }\n         g+=e=length(n1.yyyz)/s;\n    }\n    vec2 uv2 = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n    \n     vec2 uv3 = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n  \n        \n     uv3.x+=.75;\n     vec3 col3;\n      float t3 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t3);\n\tfloat co = cos(t3);\n\tmat2 ma = mat2(co, si, -si, co);\n    uint seed = 0x578437adU;\n    uint seed2 = 0x215791eU;\n    uint seed3 = 0x51ac1147U;\n    // Time varying pixel color\n    float px = perlinNoise(uv*5. +  iTime,1, 3, 0.5, 2.0,seed);\n    float py = perlinNoise(uv*5. +  iTime,1, 3, 0.5, 2.0,seed2);\n    float pp = perlinNoise(uv+vec2(0.01*iTime)+vec2(px,py),1, 6, 0.5, 2.0,seed3);\n    vec3 col32 = vec3((pp+1.)/2.);\n       float tt = iTime*0.000051;\n     \n    for(float i = 0.; i < size; i++)\n    {\n\n        vec2 dir= Hash12(i+tt) -.5; \n   \n        float d = length(uv2*.5-dir);\n \n        float brightness = 0.002+i*0.0001;\n        col3 += vec3(brightness*3.5 / d);\n        \n    \n    }   \n   \n    vec3 col = fstar(uv, 7., iTime / 5.);\n    col *= 10.;\n    col = pow(col, vec3(1));\n    col = col.r * vec3(1, 0.45, 0.4) + col.g * vec3(0.4, 0.4, 1) + col.b * vec3(1);\n    //col = col*mat3(1.,.45,.4,.4,.4,1.,1.,1.,1.);\n    col = vec3(0, 0, 0.05) + clamp(vec3(0, 0, 0.03) + col, vec3(0), vec3(1));\n\n        vec3 col2 = palette(length(uv) *.4 + iTime*.4);\n    float n4 = fnebula(uv, 7., iTime / 5.);\n uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; // Aspect ratio correction\n \n    // Animated light position (rotating around the center)\n    float t = iTime * 0.5; // Time-based animation speed\n    vec3 lightPos = vec3(sin(t), cos(t), 1.5); // Moving light position\n\n    // Surface normal at each point (simplified sphere shape)\n    vec3 normal = normalize(vec3(uv, 1.0));\n\n    // View direction (camera looking towards the center)\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n\n    // Gradient background\n    vec3 backgroundColor = mix(vec3(0.1, 0.1, 0.3), vec3(0.9, 0.3, 0.5), uv.y * 0.5 + 0.5);\n    \n    // Lighting calculations\n    vec3 lightDir = normalize(lightPos - normal);\n    float diffuse = max(dot(lightDir, normal), 0.0);\n\n    // Animated color palette for the object\n    vec3 baseColor = vec3(0.5 + 0.5 * sin(iTime), 0.5 + 0.5 * cos(iTime * 0.7), 0.7);\n\n    // Diffuse lighting (color influenced by light direction)\n    vec3 diffuseColor = diffuse * baseColor;\n\n    // Specular highlight (shiny effect)\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); // Shiny factor\n    vec3 specularColor = specular * vec3(1.0, 1.0, 1.0); // White highlight\n\n    // Fresnel effect (edge glow)\n    float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);\n    vec3 fresnelColor = fresnel * vec3(0.8, 0.9, 1.0); // Light blue glow at edges\n\n    // Final color combining all effects\n    vec3 color = backgroundColor + diffuseColor + specularColor + fresnelColor;\n\n    // Apply soft glow using exponential falloff for a smooth finish\n    float glow = exp(-length(uv) * 3.0);\n    color += glow * vec3(0.3, 0.5, 0.9); // Add soft glow effect\n\n    n4 = n4 * 0.4;\n    n4 = clamp(n4, 0., 1.);\n\n    n4 = 1. - n4;\n    n4 = 0.5 / n4;\n    n4 = n4 - 0.5;\n\n    vec3 vnb = n4 * vec3(0.7, 1.1, 1);\n    vnb = clamp(vnb*col2, vec3(0), vec3(1));\n    \n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n   \n     vec2 uv5=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n        uv5.x+=1.0*cos(iTime*0.2);\n      uv5.y+=1.0*sin(iTime*0.2);\n     uv5*=10.0*cos(iTime*0.2);\n  ;\n    vec3 col5=0.03125*vec3(0.433,0.3257,0.27655)*vnb + col*col3*color*2.*col32; // Cosmic latte (CIE xz=(0.345,0.345)).\n    vec3 ro=vec3(0,0,2);\n    vec3 rd=normalize(vec3(uv5,-1.5));\n    vec3 n=normalize(rd-dot(ro,rd)/dot(ro,ro)*ro),l=normalize(vec3(1));\n    float R=1.0,p=dot(ro,rd),d=p*p-dot(ro,ro)+R*R;\n    if(d>0.0)\n    {\n        float t=-p-sqrt(d);\n        vec3 r=ro+t*rd;\n        n=normalize(r);\n        vec4 q=vec4(cos(0.25*iTime)*normalize(vec3(2,5,1)),sin(0.25*iTime));\n        vec3 v=n+2.0*cross(q.xyz,cross(q.xyz,n)+q.w*n);                        // Rotate.\n        vec4 h=height(2.0*v+1.0);\n        h.xyz=h.xyz+2.0*cross(q.xyz,cross(q.xyz,h.xyz)-q.w*h.xyz);             // Un-rotate.\n        col5=mix(col5,mix(\n            vec3(0.025,0.1,0.5)*pow(max(dot(n,normalize(l-rd)),0.0),8.0),      // Ocean.\n            vec3(0.4,1.3,0.2)*(0.125+max(dot(normalize(n-0.25*h.xyz),l),0.0)), // Land.\n            smoothstep(-0.05,0.0,h.z+O.x)),smoothstep(0.0,fwidth(d),d));\n    }\n    col5+=(0.125+max(dot(n,l),0.0))*vec3(0.1,0.2,0.7)*exp(-17.0*max(-d,0.0)/(R*R))/(1.0+4.0*max(d,0.0)/(R*R)); // Atmosphere.\n    col5=mix(12.92*col5,1.055*pow(col5,vec3(1.0/2.4))-0.055,step(0.0031308,col5)); // sRGB\n    fragColor = vec4(col5, 1);\n     fragColor+= vec4(happy_star(uv3, anim) * vec3(0.35,0.2,1.15)*0.2, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}