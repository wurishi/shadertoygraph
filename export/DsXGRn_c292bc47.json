{"ver":"0.1","info":{"id":"DsXGRn","date":"1665759963","viewed":172,"name":"Ray Tracing Super Sampling","username":"LukasBoersma","description":"Simple comparison: normal pixel-perfect ray-tracing (left) versus the same shader with super sampling (right)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n// Hashing for pseudo-randomness\n// From here: https://stackoverflow.com/a/17479300/2956315\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n\nstruct Ray\n{\n    vec3 start;\n    vec3 dir;\n};\n\nstruct Surface\n{\n    bool hit;\n\n    vec3 pos;\n    vec3 normal;\n    vec3 diffuse;\n};\n\nconst Surface NO_HIT = Surface(false, vec3(0), vec3(0), vec3(0));\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nvec3 getCheckerBoardDiffuse(vec2 texCoords)\n{\n    ivec2 texI = ivec2(texCoords);\n    return (texI.x ^ texI.y) % 2 == 0 ? vec3(0,0,0) : vec3(1,1,1);\n}\n\nSurface traceGroundPlane(Ray viewRay)\n{\n    float dist = -viewRay.start.y / viewRay.dir.y;\n    if (dist < 0.0) return NO_HIT;\n    \n    vec3 pos = viewRay.start + dist * viewRay.dir;\n    pos.y = 0.0;\n\n    return Surface(true, pos, vec3(0,1,0), getCheckerBoardDiffuse(pos.xz));\n}\n\n\n\nRay getViewRay(vec2 fragCoord)\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 screenCoords = fragCoord.xy / iResolution.xy - vec2(0.5);\n    screenCoords.x *= aspectRatio;\n    \n    vec3 viewDirection = vec3(screenCoords.xy, 1.0);\n    viewDirection = rotation3dY(iTime/5.0) * viewDirection;\n    \n    return Ray(vec3(0,1.5 + sin(iTime/5.0),0), normalize(viewDirection));\n}\n\nconst int superSamplingFactor = 64;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0);\n    \n   \n    if(fragCoord.x < iResolution.x/2.0 - 5.0)\n    {\n        Ray viewRay = getViewRay(fragCoord);\n\n        Surface surface = traceGroundPlane(viewRay);\n\n        if(surface.hit)\n        {\n            color = surface.diffuse;\n        }\n        else\n        {\n            color = vec3(0.2, 0.5, 0.8);\n        }\n    }\n    else if(fragCoord.x > iResolution.x/2.0 + 5.0)\n    {\n        float randFactorY = 0.8 + 0.4 * random(fragCoord.x*75.1235 + fragCoord.y*57.3765);\n        \n        for(int dy = -superSamplingFactor/2; dy <= superSamplingFactor/2; dy++)\n        {\n            Ray viewRay = getViewRay(fragCoord + vec2(0, float(dy)*(0.5/(float(superSamplingFactor/2)))*randFactorY));\n\n            Surface surface = traceGroundPlane(viewRay);\n\n            if(surface.hit)\n            {\n                color += surface.diffuse;\n            }\n            else\n            {\n                color += vec3(0.2, 0.5, 0.8);\n            }\n        }\n        \n        color /= float(superSamplingFactor);\n    }\n    else\n    {\n        color = vec3(1,0,0);\n    }\n    \n    \n    fragColor.rgb = color;\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}