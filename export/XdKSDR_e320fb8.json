{"ver":"0.1","info":{"id":"XdKSDR","date":"1463853409","viewed":481,"name":"Voxel 3D CA","username":"akohdr","description":"Local rule (r=1) 3D cellular automata displayed as culled voxel volume.\nMouse rotates, iMouse.y controls culling, upper iMouse.y shows state.\n(volume currently 35 cube so preview animation works adjust #define SIDE accordingly)","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["voxel","automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Viewer - displays a voxel volume described by 2D tiled z-slices\n//\n#define EYE 90\n#define SIDE 35\n//#define SIDE 49\n#define T2D texture\n#define RES iResolution\n#define FRES_xy vec2(SIDE)\n#define FRES vec3(FRES_xy,SIDE)\n#define HALF (FRES/2.)\n#define FDIM vec3(floor(RES.xy/FRES.xy),FRES.z)\n\nbool isVoxel(out vec4 k, const in vec3 P)\n{\n    if(any(greaterThan(abs(P),HALF))) return false; \t// bounds check, kills repetition \n    vec3 p = P + HALF;\t\t  \t\t\t\t\t\t\t// recenter volume in viewport\n\tfloat z = p.z, w = FDIM.x;\t\t\t\t\t\t\t// inlined prj4Dto2D()\n    k = T2D(iChannel0, (FRES_xy * floor(vec2(mod(z,w),z/w)) + mod(p.xy,FRES_xy))/RES.xy);\n\n    if(iMouse.z>0.)\n\t    return dot(k.xyz,vec3(1))>3.*iMouse.y/RES.y;\t// mouse controled culling\n    else \n    \treturn dot(k.xyz,vec3(1))>1.2;\t\t\t\t\t// cull to yellow\n    //return k.w>0.;\t\t\t\t\t\t\t\t\t// anything but black\n}\n\nvoid mainImage(out vec4 k, vec2 P)\n{\n    float T, Rx = RES.x, Ry = RES.y;\n    vec2 uv = P/RES.xy,\n         u = (P - vec2(0,.5)*Ry)/Rx - vec2(.5,0);\n    \n    if(iMouse.z>0.){\n        if (iMouse.y>250.){ \n            k = T2D(iChannel0, uv); return; }\t\t\t// show state space\n        T = 5.*iMouse.x/Rx;  \t\t\t\t\t\t\t// mouse rotate\n    } else\n        T = float(iFrame)/256.; \t\t\t\t\t\t// slow rotate\n    \n    vec3 v = vec3(cos(T), 1, sin(T)),\n         r = mat3(u.x,    0,   .8,\n                    0,  u.y,    0,\n                  -.8,    0,  u.x) * v,\n         o = vec3(EYE,0,-EYE)*v.zyx,\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d * ( q*(f-o + .5) +.5), m;\n\n    for(int i=0; i<350; i++) {\n        float a=s.x, b=s.y, c=s.z;\n        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b));\n        f += m*q;\n        \n        if(isVoxel(k, f)) { \n            k += vec4(m.x>.0 ? 0. : m.y>.0 ? .6 : .3); \n            k *= .9-f.z/FRES.z;\t\t\t\t\t\t\t// cheap depth based faux lighting\n            return;} //early exit\n    }\n    k = vec4(P.y/iResolution.y); \t\t\t\t\t\t// background fade\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Automata - 3D state space maintained in looped buffer of 2D tiled z-slices\n//\n#define RES iResolution.xy\n#define SIDE 35\n//#define SIDE 49\n#define FRES_xy vec2(SIDE)\n#define FRES vec3(FRES_xy,SIDE)\n#define HALF (FRES/2.)\n#define FDIM vec3(floor(RES/FRES_xy),FRES.z)\n#define SPACE (FDIM.xy*FRES.xy)\n\n#define BLK vec4(0)\n#define GRY vec4(.5)\n#define WHT vec4(1)\n#define RED vec4(1,0,0,1)\n#define MAG vec4(1,0,1,1)\n#define PRP vec4(.5,0,.5,1)\n#define GRN vec4(0,1,0,1)\n#define YEL vec4(1,.8,0,1)\n#define BLU vec4(0,0,1,1)\n#define CYN vec4(0,1,1,1)\n#define ORG vec4(.4,.1,0,1)\n#define ANY vec4(-1)\n#define _ ANY\n\n#define VX(v,K) if(distance((v).xyz,q.xyz+.25)<.5)k=K;\n\nvec2 prj4Dto2D(const in vec4 p)\n{\n    float z = p.z, w = FDIM.x;\n    return FRES_xy * floor(vec2(mod(z,w), z/w)) + mod(p.xy, FRES_xy);\n}\n\nvec4 prj2Dto4D(const in vec2 p)\n{\n    return vec4(mod(p,FRES_xy), dot(floor(p/FRES_xy),vec2(1,FDIM.x)), 0);//iTime);\n}\n\n// mini-DSL for rule definitions / processing ==============================================\n#define RULE(n) void n(out vec4 r[28]){clrRule(r);\n#define APPLY(f) f(r);applyRule(q,r,k);if(k.w>0.)return;\n#define APPLY4(a,b,c,d) APPLY(a);APPLY(b);APPLY(c);APPLY(d);\n#define CK(x,y,z) if(noMatch(q+vec4(x,y,z,1),RV(vec3(x,y,z))))return;\n#define TK(x,y,z) if(noMatch(q+vec4(x,y,z,1),RV(vec3(x,y,z))))return false;\n#define RV(v) r[(int(dot(v+1.,vec3(1,9,3)))+1)]\n#define RQ(x,y,z) RV(vec3(x,y,z))\n#define WHEN RV(vec3(0))=\n#define OUT  r[0]=\n#define UX vec3(1,0,0)\n#define UY vec3(0,1,0)\n#define UZ vec3(0,0,1)\n\n// quanta/bounce pair definitions (keep things DRY)\n//#define TRV(n,v,K) RULE(n)WHEN BLK;RV(v)=K;OUT K;}\n//#define TRV(n,v,K) ARULE(n,v,BLK,K,K)\n//#define TRV2(n,m,K,v,L) TRV(n,v,K)TRV(m,-v,L)\n//#define TRV2(n,m,K,v,L) ARULE(n,v,BLK,K,K) ARULE(m,-v,BLK,L,L)\n//#define BNC(n,K,v,L) RULE(n)WHEN K;RV(v)=ORG;OUT L;}\n//#define BNC(n,K,v,L) ARULE(n,v,K,ORG,L)\n//#define BNC2(n,m,K,v,L) BNC(n,K,-v,L)BNC(m,L,v,K)\n//#define BNC2(n,m,K,v,L) ARULE(n,v,L,ORG,K) ARULE(m,-v,K,ORG,L)\n//#define TRVBNC(K,L,a,b,c,d,v) TRV2(a,b,K,v,L)BNC2(c,d,K,v,L)\n\n// refactored to use single abstract rule definition macro\n#define ARULE(n,v,A,B,C) RULE(n)WHEN A;RV(v)=B;OUT C;}\n#define TRVBNC(K,L,a,b,c,d,v) ARULE(a,v,BLK,K,K) ARULE(b,-v,BLK,L,L) ARULE(c,v,L,ORG,K) ARULE(d,-v,K,ORG,L)\n\n// rule processing =========================================================================\n\nbool noMatch(const in vec4 dp, const in vec4 K)\n{\n    return K != ANY && \n       K.rgb != texture(iChannel0, prj4Dto2D(dp)/RES).rgb;\n}\n\n// Efficiency over DRY...\n// although implementing similar logic matchRule/applyRule seperated for efficiency\n// CK/TK early exit when any match term thus whole rule predicate can't be satisfied\nbool matchRule(const in vec4 q, const in vec4 r[28])\n{\n    TK( 1, 1,-1)    TK( 1, 1, 0)    TK( 1, 1, 1)        \n    TK( 0, 1,-1)    TK( 0, 1, 0)    TK( 0, 1, 1)\n    TK(-1, 1,-1)    TK(-1, 1, 0)    TK(-1, 1, 1)\n      \n    TK( 1, 0,-1)    TK( 1, 0, 0)    TK( 1, 0, 1)\n    TK( 0, 0,-1)    TK( 0, 0, 0)    TK( 0, 0, 1)\n    TK(-1, 0,-1)    TK(-1, 0, 0)    TK(-1, 0, 1)\n        \n    TK( 1,-1,-1)    TK( 1,-1, 0)    TK( 1,-1, 1)\n    TK( 0,-1,-1)    TK( 0,-1, 0)    TK( 0,-1, 1)\n    TK(-1,-1,-1)    TK(-1,-1, 0)    TK(-1,-1, 1)\n        \n    return true;\n}\n\nvoid applyRule(const in vec4 q, const in vec4 r[28], inout vec4 k)\n{\n    CK( 1, 1,-1)    CK( 1, 1, 0)    CK( 1, 1, 1)        \n    CK( 0, 1,-1)    CK( 0, 1, 0)    CK( 0, 1, 1)\n    CK(-1, 1,-1)    CK(-1, 1, 0)    CK(-1, 1, 1)\n        \n    CK( 1, 0,-1)    CK( 1, 0, 0)    CK( 1, 0, 1)\n    CK( 0, 0,-1)    CK( 0, 0, 0)    CK( 0, 0, 1)\n    CK(-1, 0,-1)    CK(-1, 0, 0)    CK(-1, 0, 1)\n        \n    CK( 1,-1,-1)    CK( 1,-1, 0)    CK( 1,-1, 1)\n    CK( 0,-1,-1)    CK( 0,-1, 0)    CK( 0,-1, 1)\n    CK(-1,-1,-1)    CK(-1,-1, 0)    CK(-1,-1, 1)\n        \n    k = r[0];\n}\n    \n// local rules =============================================================================\n\n// YUCK!!!! but RULEM macro allows us to more easily define/visualize rules in source\n#define RULEM(fn,a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q,s,t,u,v,w,x,y,z,aa,bb,cc,o)void fn(out vec4 r[28]){r[0]=o;r[25]=a;r[26]=b;r[27]=c;r[16]=d;r[17]=e;r[18]=f;r[7]=g;r[8]=h;r[9]=i;r[22]=j;r[23]=k;r[24]=l;r[13]=m;r[14]=n;r[15]=p;r[4]=q;r[5]=s;r[6]=t;r[19]=u;r[20]=v;r[21]=w;r[10]=x;r[11]=y;r[12]=z;r[1]=aa;r[2]=bb;r[3]=cc;} \n#define SET(r,K) r[0]=r[1]=r[2]=r[3]=r[4]=r[5]=r[6]=r[7]=r[8]=r[9]=r[10]=r[11]=r[12]=r[13]=r[14]=r[15]=r[16]=r[17]=r[18]=r[19]=r[20]=r[21]=r[22]=r[23]=r[24]=r[25]=r[26]=r[27]=K;\n#define clrRule(r) SET(r,ANY)\n\n// These rules are currently meaningless, thrown together to generate something\n// I'm open to examples / suggestions / strategies to search the vast rule space.\n\n// Rules defined by a name, predicate (3x3x3 Moore neighbourhood) and output color\n// Predicate arranged as 3 Y-slices in decreasing y order\n// Each of 3x3 grids have x inc. to right and z inc. up\n// _ matches any color (maybe bad idea as compiler complains __ is reserved)\n\nRULEM(rBLUa, \t \tBLU, _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tORG)\n\nRULEM(rBLUb, \t \t _ , _ ,BLU,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tORG)\n\nRULEM(rBLUc, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ ,BLU,\t _ , _ , _ ,\t _ , _ , _ ,\tORG)\n\nRULEM(rBLUd, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\tBLU, _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tORG)\n\nRULEM(rBLUe, \t \t _ , _ , _ ,\t _ , _ , _ ,\tBLU, _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tORG)\n\nRULEM(rBLUf, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ ,BLU,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tORG)\n\nRULEM(rBLUg, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ ,BLU,\tORG)\n\nRULEM(rBLUh, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLK, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\tBLU, _ , _ ,\tORG)\n\n\n\nRULEM(rORGa, \t \t _ ,ORG, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,BLK, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tBLU)\n\nRULEM(rORGb, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,BLK,ORG,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tYEL)\n\nRULEM(rORGc, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,BLK, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,ORG, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tGRN)\n\nRULEM(rORGd, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t ORG,BLK, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tBLK)\n\nRULEM(rORGe, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ ,ORG, _ ,\n\t\t\t\t\t _ ,BLK, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tBLK)\n\nRULEM(rORGf, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,BLK, _ ,\t _ , _ , _ ,\t _ , _ ,ORG,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tRED)\n\nRULEM(rORGg, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,BLK, _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ ,ORG, _ ,\tORG)\n\nRULEM(rORGh, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ ,BLK, _ ,\t _ , _ , _ ,\tORG, _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tBLU)\n\n\n\nRULEM(rREDAGE, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,RED, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tBLU)\n\nRULEM(rGRNAGE, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,GRN, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tRED)\n\nRULEM(rBLUAGE, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,BLU, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tBLK)\n\nRULEM(rYELAGE, \t \t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ ,YEL, _ ,\t _ , _ , _ ,\n\t\t\t\t\t _ , _ , _ ,\t _ , _ , _ ,\t _ , _ , _ ,\tYEL)\n    \nvoid applyLocalRules(out vec4 k, const in vec2 p, const in vec4 q)\n{\n    vec4 r[28];\t\t   \t\t\t\t\t// rule buffer\n    k = texture(iChannel0, p/RES);\t// retrieve prior state\n    if(k!=BLU || k!=ORG) k=BLK;  \t\t// clear everything except...\n\n    // While current implementation uses first match early exit strategy\n    // rules should consider arbitrary application order\n    \n\tAPPLY4(rBLUa, rBLUb, rBLUg, rBLUh)    \n    APPLY4(rORGa, rORGb, rORGc, rORGd)\n    APPLY4(rORGe, rORGf, rORGg, rORGh)\n\tAPPLY4(rBLUe, rBLUf, rBLUc, rBLUd)    \n    APPLY4(rREDAGE, rGRNAGE, rBLUAGE, rYELAGE)\n}\n\n// initial condition =======================================================================\nvoid init(out vec4 k, vec2 p, vec4 q)\n{\n    VX(HALF,YEL)\n    VX(vec3(HALF)-1.,RED)\n}\n\n\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    k=BLK;\n    float z;\n    vec4 q = prj2Dto4D(p);\t\t\t\t\t\t\t\t// 4D state position\n    \n    if( \n      q.z>FDIM.z ||\t\t\t\t\t\t\t\t\t\t// ignore z-slices beyond volume\n      any(greaterThan(abs(q.xyz-HALF),HALF-1.))||\t\t// prevent cycling (BLK border)\n      any(greaterThan(p,SPACE))  \t\t\t\t\t\t// ignore partial z-slices\n        )return;\n    \n    float mt = mod(iTime,20.);\n    if(mt<.5)\t\t\t\t\t\t\t\t\t\t\t// periodic reset\n        init(k,p,q);\n    else\n        if(mt<10.)\t\t\t\t\t\t\t\t\t\t// fixed period generation\n\t\t    applyLocalRules(k,p,q);\n        else\n          \tk = texture(iChannel0,p/RES);\t\t\t\t// sustain state\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}