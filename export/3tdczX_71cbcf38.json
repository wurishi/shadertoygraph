{"ver":"0.1","info":{"id":"3tdczX","date":"1609623492","viewed":259,"name":"Happy New Year using a Scytale !","username":"sylvain69780","description":"** HAPPY NEW YEAR **\nMessage coded using a \"Scytale\", this is very old Greek cryptography. [url=https://en.m.wikipedia.org/wiki/Scytale]Scytale[/url]\n","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["helix","message"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Happy New Year using a Scytale !\n    --------------------------------\n\n    Happy new year to all the great Shadertoy community !\n    \n    Related references\n    \n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n    \n    How to texture a procedural object - BigWings aka The Art of Code\n    https://youtu.be/VaYyPTw0V84\n    \n    wave greek frieze 0: tuto  - Fabrice Neyrey\n    https://www.shadertoy.com/view/4ljBWd\n    \n    iResolution, iMouse, iDate, etc - Fabrice Neyrey \n    https://www.shadertoy.com/view/llySRh\n\n    \n*/\n\n#define MAX_STEPS 256\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime*.3\n\n#define PI 3.14159265\n#define TAU 6.283185\n#define iFont iChannel0\n\nvec3 modHelix(vec3 p, float r1) \n{\n    float tpr = atan(p.x, p.z);\n    float tp = tpr/TAU;\n    float turn = p.y-tp;      // counting the turns\n    float count=floor(turn);\n    float delta=fract(turn);\n    float ts=tp+count;\n    float x=r1*ts*TAU;\n    float an = atan(1.0/(TAU*r1));\n    // fix orientation regarding the slope\n    float y=delta;\n    x+=sin(an)*delta;\n    // distance calculation\n    float d = length(p.xz) - r1;\n    return vec3(d,x,y);\n}\n\nfloat char(vec2 p, int c) {\n  if (c==64 || fwidth(p.y)>0.5 ) return 0.0; // here I had problems with the borders because I'am a newbie \n  float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l).x;\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float r, float h )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\nfloat calcLight(vec3 n) {\n    float directionality=0.75;\n    float sharpness=0.5;\n    n = erot(n, vec3(0,1,0),0.0);\n    float spec = length(sin(n * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n    spec = spec + pow(spec, 10. * sharpness);\n    return spec;\n}\n\nvec3 animateHelix() {\n    float atime = mod(T*3.0,10.0);\n    float l = 1.0-(S(1.0,4.0,atime)-S(7.0,9.0,atime));\n    float r=10./TAU+3.0*l;\n    float s=1.1+l*3.0;\n    return vec3(r,s,atime);\n}\n\nvec4 niceHelix(vec3 p) {\n    float l=7.0;   // length of the cylinder\n    p.x-=-l*.5;\n    float charmax=51.0;\n    vec3 anime = animateHelix();\n    float rr=anime.x;\n    float m=2.0;\n    float rmin = 1.2;\n    float thickness=.2;\n    float spacing = anime.y;   \n    \n    vec3 pp = p;\n    pp.z+=rr-rmin-2.0*thickness; // move next to inner cylinder\n    pp.yz*=Rot(.35);\n    vec3 q = modHelix(pp.yxz/spacing,rr/spacing);\n    q.z-=.5; // center\n    q.xyz*=spacing;\n    float border = 0.0;\n    border=abs(q.z)-0.5;\n    float flag=0.0; // .1*sin(T*15.+q.y*5.);\n    float d=1e10;\n    if ( q.x+flag < d ) {\n        if ( border < -0.05 && q.y > 0.05 && q.y < charmax-0.05 ) m=1.0; // avoid issue with limit\n        d = q.x+flag ;\n        } // outer of the spiral   \n    float inner=-(q.x+thickness+flag);\n    if ( inner > d ) { d=inner; m=2.0; }\n    if ( border > d ) { d=border; m=2.0; }\n    \n    vec3 qq=q-vec3(0.3,charmax*(S(0.0,5.0,anime.z)-S(5.0,10.0,anime.z)),0.0);\n    if ( q.y < 0.0 ) {\n        m=2.0;\n        float upBorder=spacing*.5-q.z;\n        d=max(d,min(upBorder,min(1.0,-q.y)/spacing));\n    }\n    if ( q.y > charmax ) {\n        m=2.0;\n        float lowBorder=spacing*.5+q.z;\n        d=max(d,min(lowBorder,min(1.0,q.y-charmax)/spacing));\n    }\n    float cylinder = sdVerticalCapsule(p.yxz,rmin,l);\n    if ( cylinder < d ) { d=cylinder ; m=4.0; }\n    return vec4(d,m,q.yz);\n}\n\nfloat GetDist(vec3 p) {\n    vec4 q = niceHelix(p);\n    float d = q.x;\n    return d;\n}\n\nvec3 GetDistUV(vec3 p) {\n    vec4 q = niceHelix(p);\n    return q.yzw;\n}\n\nvec3 gc = vec3(0.0);\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    gc = vec3(0.0);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        // Ripped from Shaw\n        float at = .25 / (1. + dS * dS * dS * 400.);\n        vec3 gcc = vec3(1., .5, 0.)*.1; \n        gc += gcc * at;       \n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(f,vec3(0,1,0))),\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.xy;\n    vec3 col = vec3(0);\n    vec3 bgcol=vec3(.1+.01*Hash21(uv))*(.5-abs(uv.y));\n    \n    vec3 ro = vec3(0, 0, 10);\n    vec3 target = vec3(0);\n    if ( iMouse.x > 0.0) {\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float atime = mod(T*3.0,10.0);\n        float atime2=1.0-(S(0.0,4.0,atime)-S(5.0,9.0,atime));\n        ro = vec3(0, 0, 10);\n        vec3 ro2 = vec3(0, 0, 7);\n        ro=mix(ro2,ro,atime2);\n        ro.xz *= Rot(-.5*atime2);\n    }\n    \n    vec3 rd = GetRayDir(uv, ro, target, 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        vec3 q = GetDistUV(p);\n        float m=q.x;\n        vec2 suv=vec2(q.y,q.z+0.5);\n        float ks = 2.0; // specular \n        // https://iquilezles.org/articles/outdoorslighting\n        // lighting , in these few lines there is all the magic thanks to IQ tutorials\n        float occ = 1.0;\n        vec3  sun_lig = normalize( vec3(-0.2, 0.35, 0.5) );\n        float sun_dif = clamp(dot( n, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = step(MAX_DIST,RayMarch( p+0.01*n, sun_lig ));\n\t\tfloat sun_spe = ks*pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*n.y, 0.0, 1.0 ))*clamp(1.0-0.1*p.y,0.0,1.0);\n        if ( m < 2.0 ) {\n            col=vec3(0);\n            { \n            // Fabrice https://www.shadertoy.com/view/4ljBWd\n            vec2 U = fract(suv)-.5;\n            float v, d = length(U),                    // distance to tile center\n            t = 15.*sin( ( T+suv.x ) ), // note the time delay with position\n            a = t * max(0.,.5-d );               // angle ~time, and decrease with d\n            U *= Rot(a);   // rotate frame by angle(t,d)\n            v = U.y;                                   // pre-distortion pattern = vertical gradient.\n            col += smoothstep(-1.0,1.0,v/fwidth(v) );     //  right: ased clamp\n            int _c;                                          // prepare draw text\n            int idx=int(suv.x);\n            { int a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26,num0=48-64,num2=50-64,num1=49-64;\n            // message\n             _c = 64 + int[]( h,0,0,0,0,0,0,0,y,num2,a,0,0,0,0,0,0,0,e,num0,p,0,0,0,0,0,0,0,a,num2,p,0,0,0,0,0,0,0,r,num1,y,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n                            ) [idx];\n            }\n           if (_c != 64 ) { col=vec3(1)*char((fract(suv.yx)),_c); }\n           }\n           \n           \n        } else if ( m < 3.0 ) {\n            col+=vec3(.3,0,0);         \n            // gold\n            col = vec3(0.4,0.3,0.1);\n            vec3 r = reflect(rd, n);\n            col = calcLight(r) * vec3(.8,.8,.02)*.3;  //https://www.shadertoy.com/view/tlscDB\n            \n        } else if ( m < 4.0 ) {\n            col+=vec3(.2,0.2,0);            \n        } else if ( m < 5.0 ) {\n            col=vec3(0);\n            // BigWings tuto\n            col+=abs(n.z)*texture(iChannel1,p.xy/3.0).rgb;\n            col+=abs(n.y)*texture(iChannel1,p.xz/3.0).rgb;\n            col+=abs(n.x)*texture(iChannel1,p.yz/3.0).rgb;\n            col/=3.0;\n            col*=.3;\n        }\n  \t\tvec3 lin = vec3(0.0);\n        float suntime=1.0;\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha*suntime;  // seems the sun is raising\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ*2.0;\n        lin += bou_dif*vec3(0.40,1.00,0.40)*occ*2.0;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n    } else { col = bgcol; }\n    // Shane piece of advice, not totally understood yet how to tune it :-(\n    float fog = 1./(1. + d*.125*0.0 + d*d*.003);\n    col = mix(bgcol, col+gc, fog);    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}