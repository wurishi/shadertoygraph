{"ver":"0.1","info":{"id":"WscXD2","date":"1572872933","viewed":140,"name":"[inercia2019] raka","username":"Alien01","description":"My first entry. 2nd place at inercia2019 one scene compo.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["inercia2019"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raka\n// by @Alien01_\n// My first entry. 2nd place at inercia2019 one scene compo.\n\n#define PI 3.141592\n\n\n// From IQ's website\n// https://iquilezles.org/articles/distfunctions\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n// Also IQ's\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float a){\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n\nfloat square(vec2 uv, float r){\n  float a = step(uv.x, r/2.) - step(uv.x, -r/2.);\n  float b = step(uv.y, r/2.) - step(uv.y, -r/2.);\n  float c = a*b;\n  return c;\n}\n\nfloat gridShape(vec2 uv, float r){\n  return square(uv, r * 2.0);\n}\n\nfloat map(vec3 p, float iTime){\n  vec3 pt = p;\n  pt.yz *= rot((iTime * 0.5));\n  pt.xy *= rot(cos(iTime * 0.5 * PI));\n  pt.xy *= rot(0.5);\n  pt.yz *= rot(1.0);\n  pt.yz *= rot(PI/2.0);\n  float t = torus(pt, vec2(2.0, 0.5 * cos(iTime)));\n  vec3 ps1 = pt;\n  ps1.xz *= rot( iTime);\n  ps1.y -= 1.5 * cos(iTime * 2.0);\n  ps1.x -= 0.5;\n  float s1 = sphere(ps1, 0.5);\n  vec3 ps2 = pt;\n  ps2.xz *= rot( iTime);\n  ps2.y -= 1.5 * sin(iTime * 2.0);\n  ps2.x += 0.5;\n  float s2 = sphere(ps2, 0.5);\n  float s = smin(s2, s1, 2.0);\n  return smin(t,s, 0.3);\n}\n\nvec3 trace(vec2 uv, float iTime){\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  vec3 p = ro+rd;\n  float t = 0.;\n  int i = 0;\n  int iter = 64;\n  float d = 0.0;\n  for(i=0; i<iter; i++){\n      d = map(p, iTime);\n\t  t += d;\n\t  p += rd*d;\n\t  if(t > 100. ){\n        return vec3(0);\n      }\n      else if( d < 0.1){\n      return vec3(1.0-p.z);\n    }\n  }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  float gTime = iTime;\n  gTime *= 0.4;\n  \n  vec2 uv = fragCoord/iResolution.xy;\n  \n  uv.x -= 0.4;\n  uv.y -= 0.4;\n  uv *= 1.2;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec2 uv1 = uv;\n\n  float d = trace(uv, iTime).x;\n  d = smoothstep(d, 0.0, abs(cos(iTime)));\n \n  uv.yx *= rot(0.2 * gTime);\n  vec3 color = vec3(0.0);\n  \n  vec2 st = fract(uv * 15.) - 0.5;\n  vec2 stid = floor(uv) + 0.5;  \n  \n  \n  st *= rot(d);\n  color += 0.9*gridShape(st, d*0.16);\n  color += 0.5*gridShape(st, 0.4);\n  \n  \n  color *= mix(square(uv, 0.9), 0.8, d);  \n  uv /= 2.0;\n  \n  vec2 id = ceil(uv) - 0.5;\n  id *= rot( 0.5 * gTime * PI);\n  color += 0.5*gridShape(id, 0.4 );\n  \n  if ( id.y + id.x - 0.3  <  uv.y ){  \n    color = 1.0-color.zxy;\n  }\n\n  color.r *= 2.0;\n  color += vec3(0.2, 0.0, 0.4);\n  color *= 1.-dot(uv1,uv1) ;\n  fragColor = vec4(color,1.0);\n  \n}\n\n","name":"Image","description":"","type":"image"}]}