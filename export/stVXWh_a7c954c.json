{"ver":"0.1","info":{"id":"stVXWh","date":"1640648369","viewed":92,"name":"Graphic visualize","username":"HuntNight1337","description":"Visualize function","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["graph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define graphic_expand_rate 2.0\n#define ratio iResolution.x / iResolution.y / graphic_expand_rate\n#define field_size 10.\n#define PI 3.1415926535\n\n\n// INSERT YOUR FUNCTION HERE -----------\nfloat FUNCTION_TO_VISUALIZE(float x) {\n    //return sin(x) * cos(x);\n    return sin(x);\n    return cos(x);\n    return tan(x);\n    return 1.0;\n}\n// --------------------------------------\n\nfloat grid (vec2 uv, float width) {\n    width *= 1.0 / graphic_expand_rate;\n    uv = vec2(uv.x * ratio, uv.y);\n    uv *= field_size;\n    uv += width / 2.;\n    uv = fract(uv);\n    float grid = min(uv.x, uv.y);\n    grid = clamp(0.0, 1.0, grid);\n    grid = step(width, grid);\n    float target = 1.0 - grid;\n    return target;\n}\nfloat sceneGrid (vec2 uv) {    \n    float g = grid(uv, 0.03);\n    return clamp(0., 1., g);\n}\nfloat sceneMarks (vec2 uv) {\n    \n    uv = vec2(uv.x * ratio, uv.y);\n    uv *= field_size;\n    uv += 0.5;\n    uv = fract(uv) - 0.5;\n    \n\n    //return length(uv);\n    float lcheck = step(0.07, length(vec2(uv.x * graphic_expand_rate, uv.y)));\n    return 1. - clamp(0., 1., lcheck);\n}\nfloat sceneGraphic (vec2 uv) {\n    uv *= field_size;\n    uv = vec2(uv.x * ratio, uv.y);\n    float fVal = FUNCTION_TO_VISUALIZE(uv.x * PI);\n    float res = fVal - uv.y;\n    float hard = 1. - step(0.04, abs(res));\n    \n    float sstep = smoothstep(0.01, abs(res), 0.05);\n    sstep *= 0.5 * abs(sin(iTime) / 2. + 1.5);\n    return max(sstep, hard);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    uv.x += iTime / 20.;\n    uv.x += cos(iTime) / 1000.;\n\n    vec3 gradient = vec3(sin(uv.x + iTime), sin(uv.y), sin(uv.x + iTime)) * 0.8;\n\n    float gridA = sceneGrid(uv);\n    float marksA = sceneMarks(uv);\n    float graphA = sceneGraphic(uv);\n    \n    vec3 colGrid = mix(vec3(1), vec3(0.7), gridA);\n    vec3 colMarks = mix(colGrid, vec3(0.9, 0.3, 0.3), marksA * 0.7);\n    vec3 colFuncGraph = mix(colMarks, gradient, graphA);\n    fragColor = vec4(colFuncGraph, 1.0);\n}","name":"Image","description":"","type":"image"}]}