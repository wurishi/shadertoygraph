{"ver":"0.1","info":{"id":"llG3WD","date":"1474627596","viewed":150,"name":"raymarching - Adding Shapes","username":"harrisscott","description":"simple ray marching example with help from reddit, adding boxes to create a primitive cross shape.\ncredit to this post for the fundamental raymarching principals: https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","primitives","cross"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* ***************************************************** */\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n/* ***************************************************** */\nfloat Box(vec3 pos, vec3 b)\n{\n    return length(max(abs(pos)-b,0.0));\n}\n\n/* ***************************************************** */\nfloat Torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n/* ***************************************************** */\nfloat AddTheseTwoShapes(float firstShape, float secondShape)\n{\n   return min(firstShape, secondShape);\n}\n\n/* ***************************************************** */\nfloat BoxCross(vec3 pos)\n{\n    return AddTheseTwoShapes(AddTheseTwoShapes(Box(pos, vec3(2.0,0.5,0.5)),Box(pos, vec3(0.5,0.5,2.0))),Box(pos, vec3(0.5,2.0,0.5)));\n}\n\n/* ***************************************************** */\nfloat displacement(vec3 p)\n{\n   return sin(p.x)*sin(p.y)*sin(p.z);\n}\n\n/* ***************************************************** */\nfloat opDisplace( vec3 p )\n{\n    float d1 = Torus(p, vec2(1.0,1.0));\n    float d2 = displacement(p);\n    return d1+d2;\n}\n\nfloat opRep(vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return opDisplace(q);\n}\n               \n\n/* ***************************************************** */\nfloat distfunc(vec3 pos)\n{\n    return BoxCross(pos);\n}\n\n/* ***************************************************** */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraOrigin = vec3(4.0, 2.0*cos(iTime), 2.0*sin(iTime));\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    \n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\nscreenPos.x *= iResolution.x / iResolution.y; // Correct aspect ratio\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 100; // 100 is a safe number to use, it won't produce too many artifacts and still be quite fast\nconst float MAX_DIST = 20.0; // Make sure you change this if you have objects farther than 20 units away from the camera\nconst float EPSILON = 0.001; // At this distance we are close enough to the object that we have essentially hit it\n\n    \n    \n    float totalDist = 0.0;\nvec3 pos = cameraOrigin;\nfloat dist = EPSILON;\n\nfor (int i = 0; i < MAX_ITER; i++)\n{\n    // Either we've hit the object or hit nothing at all, either way we should break out of the loop\n    if (dist < EPSILON || totalDist > MAX_DIST)\n        break; // If you use windows and the shader isn't working properly, change this to continue;\n\n    dist = distfunc(pos); // Evalulate the distance at the current point\n    totalDist += dist;\n    pos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n}\n    if (dist < EPSILON)\n{\n    // Lighting code\n}\nelse\n{\n    gl_FragColor = vec4(0.0);\n}\n    vec2 eps = vec2(0.0, EPSILON);\nvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n    distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n    distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n    \n    float diffuse = max(0.0, dot(-rayDir, normal));\n    float specular = pow(diffuse, 32.0);\n    \n    vec3 color = vec3(diffuse + specular);\ngl_FragColor = vec4(color, 1.0);\n    \n\tfragColor = vec4(color,1.0);\n}\n/* ***************************************************** */\n\n","name":"Image","description":"","type":"image"}]}