{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n Written by Alan Wolfe\n http://demofox.org/\n http://blog.demofox.org/\n\n Minkowski Portal Refinement (MPR) is an algorithm usually used in physics code to be able\n to tell if two objects intersect.\n\n It does this by subtracting one shape from another (using minkowski sums) and seeing if the\n resulting shape contains the origin.  If so, the shapes overlap.\n\n So, in other words, MPR can also be used to tell if a shape contains the origin.\n\n An interesting thing about this is that you can represent shapes using \"support functions\"\n and you can combine these support functions in interesting ways. You can also use operators\n to transform and combine the output of those support functions.\n\n This is a 2d demonstration of using MPR to render 2d shapes that are created via minkowski\n sums, and represented using support functions.\n\n It does this by subtracting the pixel location from the shape, and then seeing if the resulting\n shape contains the origin.\n\n Brief explanation of 2d MPR algorithm here:\n http://xenocollide.snethen.com/mpr2d.html\n\n I put labels in the comments like (1b) that correspond to the labels in that link.\n\nFuture Possibilities:\n * get rotation and scaling working\n * calculate \"penetration depth of pixel\" to get a distance from edge to anti alias more cheaply.\n * put in a \"new support point is too close\" exit into the MPR loop for making smooth shapes cheaper.\n * optimize the code. it's fast, but there are surely plenty of ways to improve it.\n * Multiple shapes at once, affecting different color channels\n*/\n\n// the maximum number of MPR steps we will take\n#define MPR_MAXLOOPS 8\n\n// used to smooth the image by taking multiple samples. SMOOTHING_SAMPLES of 1 means no smoothing.\n// The samples are taken in an equally divided circle.\n#define SMOOTHING_SAMPLES 1\n#define SMOOTHING_DISTANCE (vec2(0.5,0.5) / iResolution.xy)\n\n// set this to 1 to see an overlay of how many loops were taken for each pixel.\n// Useful for tuning MPR_MAXLOOPS, it shows brighter red colors as the number of loops\n// taken gets closer to MPR_MAXLOOPS.  If it hits MPR_MAXLOOPS, it will show up in\n// yellow.\n#define DEBUG_VISUALIZE_LOOPS 0\n\n// tau aka 2pi\n#define TAU 6.28318530718\n\n//==================================================================================\n//                               OPERATION FUNCTIONS\n//==================================================================================\n//------- operations on the support functions\nvec2 Operation_Max (vec2 a, vec2 b, vec2 dir)\n{\n    // aka shrink wrap!\n    float da = dot(a, dir);\n    float db = dot(b, dir);\n    \n    return (da > db) ? a : b;\n}\n\nvec2 Operation_Lerp (vec2 a, vec2 b, float amount)\n{\n    return mix(a,b,amount);\n}\n\n//------- operations on the input pixel location.\nvec2 Operation_PixelRepeat (vec2 pixel, vec2 size, vec2 offset)\n{\n    return mod(pixel - offset, size) + offset;\n}\n\n//==================================================================================\n//                               SUPPORT FUNCTIONS\n//==================================================================================\n// All support functions return the point in the shape farthest along the dir vector.\nvec2 Support_HorizLine (float size, vec2 dir)\n{\n    return vec2(sign(dir.x)*size, 0.0);\n}\n\nvec2 Support_VertLine (float size, vec2 dir)\n{\n    return vec2(0.0,sign(dir.y)*size);\n}\n\nvec2 Support_Line (vec2 a, vec2 b, vec2 dir)\n{\n    return Operation_Max(a,b,dir);\n}\n\nvec2 Support_Triangle (vec2 a, vec2 b, vec2 c, vec2 dir)\n{\n    vec2 s = Operation_Max(a,b,dir);\n    s = Operation_Max(s,c,dir);\n    return s;\n}\n\nvec2 Support_Circle (float radius, vec2 dir)\n{\n    return dir * radius;\n}\n\nvec2 Support_Rectangle (vec2 size, vec2 dir)\n{\n    return vec2(sign(dir.x)*size.x, sign(dir.y)*size.y);\n}\n\nvec2 Support_Point (vec2 point, vec2 dir)\n{\n    return point;\n}\n\n//==================================================================================\n//                             MAIN SUPPORT FUNCTIONS\n//==================================================================================\n\nfloat Mode()\n{\n    return iTime / 2.0;\n}\n\nfloat ModePercent()\n{\n    return fract(Mode());\n}\n\n// this is the final support function of our rendered shape, which can be a combination\n// or transformation of other support functions.\nvec2 Support (vec2 dir, vec2 pixel)\n{\n    float g_mode = Mode();\n    float g_modePercent = ModePercent();\n    \n    // rotating swept triangle\n    if (g_mode >= 7.0) {\n        vec2 circlePoint = vec2(cos(TAU * g_modePercent), sin(TAU * g_modePercent)) * vec2(0.1,0.1);\n\t\treturn\n            Support_Triangle(vec2(-0.1,-0.1), vec2(0.0,0.1), vec2(0.1,-0.1), dir)\n            + Support_Line(-circlePoint, circlePoint, dir)\n            - pixel;\n    }       \n    // repeating swept max shape\n    else if (g_mode >= 6.0) {\n        pixel = Operation_PixelRepeat(pixel, vec2(0.3,0.3), vec2(-0.15,-0.15));\n        return\n            Operation_Max(Support_Circle(0.03,dir), Support_Point(vec2(0.1, 0.1), dir), dir)\n            + Support_HorizLine(0.0125, dir)\n            - pixel;\n    }    \n    // lerp circle to rectangle\n    else if (g_mode >= 5.0) {\n        return\n            Operation_Lerp(Support_Circle(0.3, dir), Support_Rectangle(vec2(0.5,0.1), dir), g_modePercent)\n            - pixel;\n    }       \n    // lerp triangle to circle\n    else if (g_mode >= 4.0) {\n        return\n            Operation_Lerp(Support_Triangle(vec2(-0.1,-0.1), vec2(0.0,0.1), vec2(0.1,-0.1), dir), Support_Circle(0.3, dir), g_modePercent)\n            - pixel;\n    }        \n    // swept circle\n    else if (g_mode >= 3.0) {\n        return Support_Circle(0.1, dir) + Support_HorizLine(0.15, dir) - pixel;\n    }    \n    // round box\n    else if (g_mode >= 2.0) {\n        return Support_Rectangle(vec2(0.16,0.08), dir) + Support_Circle(0.1, dir) - pixel;\n    }\n    // circle\n    else if (g_mode >= 1.0) {\n    \treturn Support_Circle(0.3, dir) - pixel;\n    }\n    // box\n    else {\n    \treturn Support_Rectangle(vec2(0.32,0.16), dir) - pixel;\n    }    \n}\n\n// must return a point deep inside of the resulting shape! If it doesn't, there will\n// be some weird visual problems.\nvec2 PointInside (inout vec2 pixel)\n{\n    return (\n        Support(vec2(-1.0, 0.0), pixel) +\n        Support(vec2( 1.0, 0.0), pixel) +\n        Support(vec2( 0.0,-1.0), pixel) +\n        Support(vec2( 0.0, 1.0), pixel))        \n\t* 0.25;\n}\n\n//==================================================================================\n//                                  MPR FUNCTIONS\n//==================================================================================\n\nbool LineSide (vec2 linePoint1, vec2 linePoint2, vec2 point)\n{\n\treturn (\n        (linePoint2.x - linePoint1.x)*(point.y - linePoint1.y) -\n        (linePoint2.y - linePoint1.y)*(point.x - linePoint1.x)\n    ) > 0.0;\n}\n\nbool MPR (vec2 pixel, out int loopCount)\n{    \n    //----------------------------\n    //----- portal discovery -----\n    //----------------------------\n    // (1b) obtain a point that we know lies somewhere deep within Bâ€“A\n    vec2 pointInside = PointInside(pixel);\n    \n    // (1c) get the support point in the direction to the origin.\n    vec2 toOrigin = normalize(-pointInside);    \n    vec2 supportToOrigin = Support(toOrigin, pixel);\n    \n    // (1d) get a support point in the perpendicular direction.  Since there are two possibilities,\n    // take the one that points towards the origin instead of away (dot product > 0)\n    vec2 toSupportToOrigin = normalize(supportToOrigin - pointInside);\n    vec2 perpendicularVec = normalize(vec2(-toSupportToOrigin.y, toSupportToOrigin.x));\n    if (dot(toOrigin, perpendicularVec) < 0.0) {\n        perpendicularVec *= vec2(-1.0,-1.0);\n        perpendicularVec = normalize(perpendicularVec);\n    }\n    vec2 supportToPerpendicular = Support(perpendicularVec, pixel);\n    \n    // (1e) we know have 3 points that form an angle & we know the origin lies in this angle.\n    // The 3 points are: supportToOrigin, pointInside, supportToPerpendicular.\n    // Our portal is the line from supportToOrigin to supportToPerpendicular.\n        \n    //-----------------------------\n    //----- portal refinement -----\n    //-----------------------------\n    for (int index = 0; index < MPR_MAXLOOPS; ++index)\n    {\n        // remember how many loops we've done\n        loopCount = index + 1;\n        \n        // (1f) if the origin is on the same side of our portal as the center is, we are know the\n        // shape contains the origin and we are done.\n        bool sideOrigin = LineSide(supportToOrigin, supportToPerpendicular, vec2(0.0,0.0));\n        bool sidePointInside = LineSide(supportToOrigin, supportToPerpendicular, pointInside);\n        if (sideOrigin == sidePointInside)\n            return true;\n        \n        // (1g) otherwise get a normal to the portal and get a support point along that normal.\n        // make sure the normal is pointing towards the origin!\n        vec2 portal = supportToPerpendicular - supportToOrigin;\n\t\tvec2 portalNormal = normalize(vec2(portal.y, -portal.x));\n        if (dot(portalNormal, toOrigin) < 0.0)\n            portalNormal *= -1.0;\n        vec2 newSupport = Support(portalNormal, pixel);\n        \n        // (1g) if the origin is on the outside side of this 2d plane, we have a miss\n        if (dot(portalNormal, newSupport) < dot(portalNormal, vec2(0.0,0.0)))\n            return false;\n        \n        // (1h/1i) the line from the center to the new support point bisects our angle.\n        // We need to see which side the origin is in, and make that be our new angle\n        // for the next iteration.\n        if (LineSide(pointInside, newSupport, supportToPerpendicular) ==\n            LineSide(pointInside, newSupport, vec2(0.0,0.0))) {\n\t\t\t//angle containing origin is made from the points:\n            //newSupport, supportToPerpendicular from pointInside\n            supportToOrigin = newSupport;\n\t\t}\n\t\telse {\n\t\t\t//angle containing origin is made from the points:\n            //newSupport, supportToOrigin from pointInside\n            supportToPerpendicular = newSupport;\n        }  \n    }\n    \n    // we hit the maximum number of loops, return a miss!\n    return false;\n}\n\n//==================================================================================\n//                                DRIVER CODE\n//==================================================================================\n\nvoid ApplyDebugColor (inout vec3 color, int loopCount)\n{\n    #if DEBUG_VISUALIZE_LOOPS\n    \tif (loopCount == MPR_MAXLOOPS)\n        \tcolor = vec3(1.0,1.0,0.0);\n    \telse \n    \t\tcolor = vec3(float(loopCount) / float(MPR_MAXLOOPS+1), 0.0, 0.0);\n    #endif\n}\n\nvec3 MPRColor (vec2 percent, inout int loopCount)\n{\n    #if SMOOTHING_SAMPLES <= 1\n    \treturn vec3(MPR(percent, loopCount) ? 1.0 : 0.0);\n    #else\n    \tint maxLoopCount = 0;\n    \tint hitCount = 0;\n    \n    \tfor (int i = 0; i < SMOOTHING_SAMPLES; ++i) {\n            float angle = TAU * float(i) / float(SMOOTHING_SAMPLES);\n            vec2 offset = vec2(cos(angle), sin(angle));\n            offset *= SMOOTHING_DISTANCE;\n\t\t\tif (MPR(percent + offset, loopCount))\n                hitCount++;\n            maxLoopCount = maxLoopCount < loopCount ? loopCount : maxLoopCount;\n    \t}\n    \n    \tloopCount = maxLoopCount;\n    \tfloat color = smoothstep(0.0, float(SMOOTHING_SAMPLES), float(hitCount));\n\t\treturn vec3(color);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set up our coordinate system\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.5,0.5));\n    percent.x *= aspectRatio;\n       \n    // figure out the color of our pixel\n    int loopCount = 0;\n    vec3 color = MPRColor(percent, loopCount);\n    \n    // apply debug coloring.\n    ApplyDebugColor(color, loopCount);\n    \n    // set the final color\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsjXWz","date":"1410981914","viewed":264,"name":"MPR 2d Rendering","username":"demofox","description":"This uses minkowski portal refinement in 2d to test whether a point is within a shape defined by a support function.  That support function could be the result of minkowski addition (for more complex shapes) or subtraction (collision detection for CSOs).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","vector","minkowskiportalrefinement","mikowksi","mpr"],"hasliked":0,"parentid":"","parentname":""}}