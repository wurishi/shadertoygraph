{"ver":"0.1","info":{"id":"sldSDH","date":"1639215634","viewed":475,"name":"Kuwaharas Painting (4k exe gfx)","username":"slerpy","description":"[url]https://www.pouet.net/prod.php?which=90414[/url]","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["4k","demoscene","kuwahara","tdf","exegfx","slerpy","tokiodemofest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(gl_FragCoord.xy);\n    vec4 acc = texelFetch(iChannel2, coord, 0);\n    acc /= acc.w;\n    fragColor = pow(1.43 * acc / (acc + 1.0), vec4(1) / 2.2);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int depth = 10;\nconst int paths = 1000;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 5) discard;\n    \n    float td = 1e32;\n    float ld = 1e32;\n    float ly = 0.0;\n\n    vec2 resolution = iResolution.xy;\n    fragCoord.x  /= 1.3;\n    resolution.x /= 1.3;\n\n    vec2 uv = 2.7 * rot(-0.83) * ((2.0 * fragCoord.xy) / resolution.y) + vec2(0.7, -0.4);\n    vec3 c = cyclic(uv.xyy, 2.0);\n    uv += 0.07 * c.xy;\n\n    for (int k = 0; k < paths; k += 7) {\n        float sw = 1.0;\n        vec2 luv = uv;\n\n        int path = k;\n        float bd = 1e32;\n\n        for (int d=0; d<depth; d++) {\n            vec2 lp = vec2(clamp(luv.x, 0.0, 1.0), 0);\n            float sd = length(luv - lp) / sw - 0.4 * exp(-0.34*float(d));\n            bd = min(bd, sd);\n\n            if (d > 4 && sd < ld) ld = sd;\n\n            if (bd < -0.01) {\n                ly = luv.y;\n                break;\n            }\n\n            bool f = bool(path & 1);\n            luv.x--;\n            luv *= rot(f ? 0.2 : -0.29);\n\n            float s = f != bool(d & 9) ? 1.5 : 1.02;\n            luv *= s; sw *= s;\n\n            if (sw > 2.6) break;\n\n            path >>= 1;\n        }\n\n        td = min(td, bd - 0.01*c.z);\n    }\n\n    uv = fragCoord.xy / resolution.xy;\n    uv += (c = cyclic(uv.xyx, 2.0)).xy;\n    vec3 h = cyclic(uv.xyx, 0.2);\n    ld = 0.35 * (1.0 - h.z - 3.0 * abs(c.x * c.y)) - ld;\n    td += 0.1 * pow(abs(c.x), 4.0);\n\n    vec2 m = smoothstep(-1.0, 1.0, vec2(td, ld) * resolution.y / 3.0);\n\n    float size = floor(resolution.y / 36.0);\n    vec2 v = (0.7 * h.xy + fragCoord.xy - vec2(resolution.x - 2.5 * size, 2.5 * size)) / size;\n    float b = length(max(abs(v) - 1.0, 0.0)) - 0.37;\n    m = mix(m, vec2(0.7, 1), 1.0-smoothstep(-1.0, 1.0, 4.0 * size * min(abs(b) - 0.15, sinmix(v))));\n    if (b < 2.0) ly = 0.0;\n\n    fragColor = mix(\n        vec4(0.030 * h.x - min(vec3(0.3, 0.2, 0.14) * ly, 0.05), 1),\n        vec4(1.0 - m.y * (1.0 + 0.5 * h.x) * vec3(0, 1, 0.85), 1),\n        m.x\n    );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int samples = 7;\nconst float radius = 2.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 5) discard;\n    \n    vec2 dir = vec2(0);\n    for (int k = 0; k < samples; k++) {\n        float a = (2.0 * pi * float(k)) / float(samples);\n        vec2 d = radius * vec2(cos(a), sin(a));\n        dir += d * lum(texture(iChannel0, (gl_FragCoord.xy + d) / iResolution.xy).xyz);\n    }\n\n    mat2 m = rot(atan(dir.y, dir.x));\n\n    int width  = int(8.0 * iResolution.y / 1440.0);\n    int height = int(4.0 * iResolution.y / 1440.0);\n\n    vec4 best_mean = vec4(0);\n    float best_var = 1e32;\n\n    for (int k=0; k<5; k++) {\n        ivec4 f = ivec4(k & 1, (k >> 1) & 1, 0, 0);\n        f.zw = 1 ^ f.xy;\n        f |= int(k == 4);\n\n        vec4 mean = vec4(0);\n        vec4 var = vec4(0);\n        int white = 0;\n\n        for (int x = -width * f.x; x <= width * f.z; x++)\n        for (int y = -height * f.y; y <= height * f.w; y++) {\n            vec2 uv = gl_FragCoord.xy + m * vec2(x, y);\n            vec4 col = texture(iChannel0, uv / iResolution.xy);\n            mean += col;\n            var += col * col;\n            white++;\n        }\n\n        mean /= float(white);\n        var = var / float(white) - mean * mean;\n        float var_sum = lum(var.xyz);\n\n        if (var_sum < best_var) {\n            best_mean = mean;\n            best_var = var_sum;\n        }\n    }\n\n    fragColor = best_mean;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 rv;\nvoid shuffle() {\n    rv = fract(sin(1e4*rv) + rv.wxyz);\n}\n\nvec4 bsdf_sample(vec3 n) {\n    float a = 2.0 * pi * rv.x;\n    float b = 2.0 * rv.y - 1.0;\n    float c = sqrt(1.0 - b*b);\n    shuffle();\n\n    vec3 h = vec3(c * cos(a), b, c * sin(a));\n    vec3 v = normalize(n + h);\n    return vec4(v, dot(v, n) / pi);\n}\n\nbool canvas = false;\n\nfloat trace(vec3 ro, vec3 rd) {\n    float t = 0.01;\n    for (int i=0; i<50; i++) {\n        vec3 p = ro + rd * t;\n\n        const float b = 0.014;\n        float c = length(max(abs(p) - vec3(sqrt(2.0), 1, 0.1) + b, 0.0)) - b;\n        float w = -p.z;\n        float d = min(c, w);\n        canvas = d == c;\n\n        t += d;\n    }\n\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0);\n\n    rv = 7.0 * cos(float(iFrame) + gl_FragCoord);\n    for (int i=0; i<8; i++) shuffle();\n\n    vec2 aa = rv.xy * 2.0 - 1.0;\n    vec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy + aa) / iResolution.y;\n\n    vec3 ro = vec3(0, 0, -4);\n    vec3 rd = normalize(vec3(uv, 3));\n\n    //ro.xz *= rot(-0.3);\n    //rd.xz *= rot(-0.3);\n\n    shuffle();\n    shuffle();\n    shuffle();\n\n    float t = trace(ro, rd);\n    vec3 p = ro + rd * t;\n\n    vec3 col = vec3(1);\n    vec3 norm = vec3(0, 0, -1);\n\n    if (canvas) {\n        vec2 uv = p.xy;\n        uv.x /= sqrt(2.0);\n\n        if (p.z < -0.09)\n        col *= texture(iChannel1, 0.5 + 0.5 * uv).xyz;\n\n        col *= 2.0 * fract(1800.0 * uv.x);\n        col *= 2.0 * fract(1800.0 * uv.y);\n        col *= vec3(1, 0.9, 0.8);\n    } else {\n        vec2 uv = p.xy;\n        col = 0.3 * vec3(1.0 - 0.3 * abs(cyclic(0.7 * uv.xyy, 2.0).y));\n        norm += 0.2 * cyclic(uv.xyy, 1.0);\n        norm /= length(norm);\n    }\n\n    vec4 samp = bsdf_sample(norm);\n    if (trace(p, samp.xyz) < 10.0) {\n        fragColor += vec4(0, 0, 0, 1);\n        return;\n    }\n\n    col *= max(samp.y + 0.5 * samp.x, 0.0) / samp.w;\n\n    fragColor += vec4(col, 1);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = acos(-1.0);\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 cyclic(vec3 p, float w) {\n  vec4 acc = vec4(0);\n  for (int i = 0; i < 7; i++) {\n    p.xy *= rot(0.6);\n    p.yz *= rot(0.5);\n    p.yz *= rot(0.4);\n    p += p + sin(p.yzx);\n    acc = w * acc + vec4(cross(sin(p.zxy), cos(p)), 1);\n  }\n\n  return acc.xyz / acc.w;\n}\n\nfloat lum(vec3 col) {\n    return dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\nfloat sinmix(vec2 p) {\n    float l=length(p),s=sqrt(.5),r=.25+.5*s-l;\n    mat2 m=mat2(s,s,-s,s); p=abs(m*p)*m;\n    return min(max(max(l-1.0,r),p.y),-min(r,p.y));\n}\n","name":"Common","description":"","type":"common"}]}