{"ver":"0.1","info":{"id":"stG3zw","date":"1637628858","viewed":111,"name":"mat4 Recursion Rainbow","username":"akohdr","description":"Apply mat4() and sin() recursively on slowly rotating field constructed with prime factors.\nResulting morphed space creates interesting rainbow effects, the evolving line density/contrast makes for good anti-alias testbed.  Includes four rook & radial AA.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["color","antialiasing"],"hasliked":0,"parentid":"Nly3Rm","parentname":"mat4 Recursion"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// needs gamma correction\n\n#define AA                       // uncomment to turn on anti aliasing\n#define RADIAL_AA\n#define FOUR_ROOK_AA\n\n#define ITS 7                      // iteration count\n#define SPEED 7e-2                 // global speed\n#define ZOOM 100.                  // zoom level\n//#define ORIGIN                   // highlight origin\n//#define DEBUG                    // flash any isnan red\n\n// performs two 2d offset rotations moving field origin in trefoil orbit\n#define ROTATE(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n//#define ROTATE(a) 1.   // no rotation\n//#define ROTATE(a) 2.   // see the bigger picture\n\n#define iR iResolution\n\nvoid calcImage( out vec4 k, in vec2 p )\n{\n    p*=ZOOM;\n\n    float wt = iTime*SPEED;        // wall time\n\n         wt += 2.5;                // starting time offset\n      \n          p *= .05;                // unzoom compensation\n          p -= iR.xy/2.;           // center coords\n          p += vec2(-1e3);         // offset\n          p *= ROTATE(wt);         // outer rotation\n\n     vec2 c  = p-iR.xy/2.;         // centered coords\n          c /= iR.y;               // aspect corrected/scaled\n          c *= ROTATE(-wt*3.);     // inner rotation\n          c += vec2(1);            // movement\n     \n     float t = wt+.2;              // local time\n    \n     vec4  P = vec4(2,3,5,7),      // primes\n          vx =  (P*c.x),           // x space component\n          vy =  (P*c.y);           // y space component\n        \n           k = vec4(0,0,0,1);      // initial condition\n    \n    for(int i=ITS; i>0; i--)      // iterate mat4 pipeline\n    {\n      // main transform\n      mat4 M = mat4(vx,vy,      \n                    t*P,\n                    k*(c.xyyx-1.5));\n                    \n      vec4 l = k;\n      k *= M;\n      k = sin(k/9.);\n      \n      #ifdef DEBUG\n          if(any(isnan(k))) k = l;\n      #endif\n    }\n    \n//    k = vec4(.5/length(k));    // grayscale\n//    k = normalize(k);\n\n    // show origin\n    #ifdef ORIGIN\n        k.g += smoothstep(.1,.0,length(c));\n    #endif\n    \n    // flash any isnan values red\n    #ifdef DEBUG\n       if(any(isnan(k))) k = vec4(mod(iTime,1.),0,0,0);\n    #endif\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n// shader is pretty much torture test for aliasing\n#ifdef AA\n    vec4 s = k = vec4(0);\n    \n#ifdef RADIAL_AA\n    for (float a=6.18; a>0.; a-=1.2){\n        calcImage(s,p+(a/9.)*vec2(cos(a), sin(a)));  \n        k = mix(k,s,.5);\n    }\n#endif\n    \n#ifdef FOUR_ROOK_AA\n    // apply four rook anti-aliasing \n    //   improves but doesn't eliminate issue in high contrast/freq. areas\n    float d1 = .125, d2 = .375;\n    calcImage(s,p+vec2( d1, d2));  k = mix(k,s,.5);\n    calcImage(s,p+vec2( d2,-d1));  k = mix(k,s,.5);\n    calcImage(s,p+vec2(-d2, d1));  k = mix(k,s,.5);\n    calcImage(s,p+vec2(-d1,-d2));  k = mix(k,s,.5);\n#endif\n    \n#else\n    calcImage(k,p);\n#endif\n}\n\n\n","name":"Image","description":"","type":"image"}]}