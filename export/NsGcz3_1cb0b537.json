{"ver":"0.1","info":{"id":"NsGcz3","date":"1672601333","viewed":182,"name":"acos_approx","username":"Carandiru","description":"testing an approximation of acos\n\nnative(grey)\n\napprox (light green blue - iq) *or* (saturated green - car)\n\nerror (logarithmic, 200x)","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["acos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// testing an approximation of acos\n\n// native(grey)\n\n// approx (light green blue - iq) *or* (saturated green - car)\n\n// error (logarithmic, 200x)\n\n#define ZOOM 4.5f            // larger = farther away\n\n#define ERROR_SCALE 200.0\n\n\n#define line_width 0.025\n#define grid_width 0.525\n\n#define pi (3.141592653589793)\n\n#define fma(a,b,c) (a*b+c)\n#define fnma(a,b,c) (-a*b+c)\n#define fms(a,b,c) (a*b-c)\n\n//                                       range[0.5 --- 1.0]\nfloat grid2( in vec2 uv, in float scale, in float thick ) // perfect, derived from https://www.shadertoy.com/view/ft2Bzw\n{\n    vec2 tile = floor(uv/scale);\n    vec2 tile_coord = fract(uv/scale) * 2.0 - 1.0;\n    \n    float max_norm = max(abs(tile_coord.x), abs(tile_coord.y)) * thick;\n    float square = smoothstep(0.5 - 2.0 * fwidth(max_norm), 0.5, max_norm);\n    \n    return(square);\n}\n\nfloat constrain(in float angle)\n{\n    angle = mod(angle, 2.0f * pi);\n    if (angle > pi) {\n        angle = angle - 2.0f * pi;\n    }\n    else if (angle < -pi) {\n        angle = angle + 2.0f * pi;\n    }\n    \n    return(angle);\n}\n\nfloat function_native(in float x, out uint id)\n{\n    id = 0u;\n    return(acos(x));\n}\n\n// iq's - version\nfloat sacos( float x )\n{\n    float y = abs( clamp(x,-1.0,1.0) );\n    float z = (-0.168577*y + 1.56723) * sqrt(1.0 - y);\n    return mix( 0.5*3.1415927, z, sign(x) );\n}\nfloat acos_approx( float x )\n{\n    const float t0 = 8.0f / 3.0f;\n    const float t1 = 1.0f / 3.0f;\n    \n    float a = sqrt(fma(x, 2.0f, 2.0f));\n    float b = sqrt(fnma(x, 2.0f, 2.0f)) * t1;\n    float c = sqrt(2.0f - a);\n    \n    return fms(t0, c, b);\n}\nfloat function_approx(in float x, out uint id)\n{\n    if (mod(iTime, 2.0f) < 1.0f) {\n        id = 1u;\n        return sacos(x);\n    }\n    else {\n        id = 2u;\n        return acos_approx(x);\n    }\n}\n\nfloat line(float width, float offset, float magnitude, float pixelwidth) {\n    float mid = 0.5f + offset;\n    return (smoothstep(mid - width, mid - width + pixelwidth, magnitude) - \n            smoothstep(mid + width, mid + width + pixelwidth, magnitude));\n}\n\nvoid sample_functions(out float samples[3], in float x)\n{    \n    uint id = 0u;\n    float sampling = 0.0f;\n    \n    sampling = max(0.0f, function_native(constrain(x), id));\n    samples[id] = sampling;\n    \n    sampling = max(0.0f, function_approx(constrain(x), id));\n    samples[id] = sampling;\n}\n\nconst vec3 native_acos = vec3(0.88888, 0.77777, 0.88888);\nconst vec3 approx_acos_iq = vec3(0.66666, 0.99607, 0.862745);\nconst vec3 approx_acos_me = vec3(0.43529, 0.98823, 0.533333);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y);\n    \n    // zoom and fit acos waveform\n    uv.y += 0.15f;   \n    uv *= ZOOM;\n    float pixelwidth = 1.0f / (iResolution.x);\n    vec3 color = vec3(0);\n    \n    float samples[3] = float[3](0.0f,0.0f,0.0f);\n    \n    sample_functions(samples, uv.x*0.5);\n    \n    bool selected_approx = 0.0f != samples[1]; // acos_approx() iq's version = true, my version = false \n    \n    color += native_acos * mix(0.0f, line(line_width, 0.0f + uv.y, samples[0], pixelwidth), 0.0f != samples[0]);\n    color += approx_acos_iq * mix(0.0f, line(line_width, 0.5f + uv.y, samples[1], pixelwidth), 0.0f != samples[1]);\n    color += approx_acos_me * mix(0.0f, line(line_width, 0.5f + uv.y, samples[2], pixelwidth), 0.0f != samples[2]);\n    \n    float g = grid2(uv, 0.25f, grid_width) * 0.25f;\n    \n    // error (logarithmic scaled 200x)\n    float error = samples[0] - mix(samples[2], samples[1], selected_approx);\n    color += (1.0f - g) * vec3(0.5f,0,0) * line(line_width * 4.0f, 0.0f + uv.y, 1.0f - exp(error * -ERROR_SCALE), pixelwidth);\n    \n    color = mix(vec3(g), color, ceil(color.x));\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}