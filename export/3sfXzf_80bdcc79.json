{"ver":"0.1","info":{"id":"3sfXzf","date":"1551784588","viewed":369,"name":"Graveless","username":"constantin","description":"Graveless is a throwback to those sweet 90s fps.\nIt's my first Shadertoy and was made in about 10 days.\nIt focuses more on technical experimentation than graphics and is still pretty unpolished.\n\n\nWASD / ZQSD - Move\nU / I - Rotate\nSpace - Fire","likes":6,"published":1,"flags":56,"usePreview":1,"tags":["raymarching","game","retro","doom","fps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final image\n\nconst bool debug = false;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ratio = iResolution.xy / screenSize;\n  \tvec2 uv = fragCoord / iResolution.xy / ratio;\n    vec2 debugUV = uv * .25;\n    \n    vec4 ui = texture(iChannel1, uv);\n    vec4 game = texture(iChannel0, uv);\n    vec4 weapon = texture(iChannel3, uv);\n    vec4 time = LoadValue(layoutTime, iChannel2);\n    vec4 playerData = LoadValue(layoutPlayerData, iChannel2);\n    \n\tif(playerData.x == 0.0)\n    {\n        float[12] dead = float[12](ch_y, ch_o, ch_u, ch_sp, ch_a, ch_r, ch_e, ch_sp, ch_d, ch_e, ch_a, ch_d);\n        fragColor = vec4(0,0,0,1);\n        for(int i = 0; i < 12; ++i)\n        fragColor += char(dead[i], fragCoord / 2.0 / ratio /  screenScale + vec2(-50,-25));\n        fragColor += print_number(playerData.y, vec2(26.5, 20), fragCoord.xy / 4.0 / ratio / screenScale, true, 5);\n        \n        return;\n    }\n    \n    fragColor = mix(mix(game, weapon, weapon.w), vec4(rayLightColor, 1), ui.w);\n    \n    if(debug && length(texture(iChannel2, debugUV)) > 0.0)\n    fragColor = texture(iChannel2, debugUV);\n    \n    // Screen flash hit\n    fragColor = mix(vec4(1,0,0,1), fragColor, clamp((time.x - playerData.w) * 10.0, 0.0, 1.0));\n\n    // Fade in\n    fragColor = mix(vec4(0,0,0,0), fragColor, clamp(iTime - 1.0, 0.0, 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////// Constants\n// Rendering\nconst float screenScale\t\t\t  = 1.0;\nconst vec2  screenSize            = vec2(320, 180) * screenScale;\nconst float maxDistance           = 100.0;\nconst int   maxSteps              = 300;\nconst float fogDistance\t\t\t  = 100.0;\nconst float epsilon               = .001;\nconst vec3  lightDirection        = vec3(.5,1,-1);\nconst float lightBanding          = 4.0;\nconst vec3  directionalLightColor = vec3(1,1,1);\nconst vec3  playerPointLightColor = vec3(1,1,1);\nconst vec3  rayLightColor         = vec3(0.57,0.9,0.67);\n\n// Data Layout\nconst vec2 layoutTime\t\t\t = vec2(0.5, 0.5); // x : Time, y : Time scale\nconst vec2 layoutPlayerTransform = vec2(1.5, 0.5); // xyz : Position, w : Rotations\nconst vec2 layoutPlayerCamera \t = vec2(2.5, 0.5); // x : Camera focal, y : Screenshake trauma, z : Current room\nconst vec2 layoutPlayerGun\t\t = vec2(3.5, 0.5); // xy : Last shot position, z : Last shot time, w : Last shot frame\nconst vec2 layoutPlayerData\t\t = vec2(4.5, 0.5); // x : Health, y : Score, z : Current gun, w : Last hit\nconst vec2 layoutPlayerHit\t\t = vec2(5.5, 0.5); // x : Damage\nconst vec2 layoutHit             = vec2(0.5, 1.5); // xyz : Hit position, w : Enemy index\nconst vec2 layoutEnemies \t\t = vec2(1.5, 1.5); // xyz : Position, w : Rotation\nconst vec2 layoutEnemiesData\t = vec2(1.5, 2.5); // x : Health, y : Last hit, z : Death time, w : Spawn time\nconst vec2 layoutEnemiesAI       = vec2(1.5, 3.5); // Second enemy : x : last target angle, y : last target time, z : last dash end\n\n// Controls\nconst float keyForward \t   = 87.5; // W\nconst float keyForwardAlt  = 90.5; // Z\nconst float keyBackward    = 83.5; // S\nconst float keyBackwardAlt = 83.5; // S\nconst float keyLeft \t   = 65.5; // A\nconst float keyLeftAlt\t   = 81.5; // Q\nconst float keyRight \t   = 68.5; // D\nconst float keyRightAlt    = 68.5; // D\nconst float keyRotateLeft  = 85.5; // U\nconst float keyRotateRight = 73.5; // I\nconst float keyFire\t\t   = 32.5; // Space\n\n// Player Data\nconst float playerSpeed = 20.0;\nconst float playerRotationSpeed = 3.0;\nconst float playerRadius = 0.5;\nconst float playerInvulnerability = .5;\nconst float cameraFocal = 2.0;\nconst float cameraShotFocal = 1.0;\nconst vec3  maxScreenshakeAngles = vec3(.3,.3,.2);\nconst float playerHeadBump = .17;\n\n// Enemy Data\nconst float enemyCount \t               = 10.0;\nconst float enemyRespawnTime           = 9999999.0;\nconst float firstEnemyCount            = 5.0;\nconst float firstEnemyAttackDistance   = 2.0;\nconst float firstEnemyAttackMinDamage  = 5.0;\nconst float firstEnemyAttackMaxDamage  = 10.0;\nconst float firstEnemyMoveSpeed\t\t   = 12.0;\nconst float secondEnemyAttackDistance  = 2.5;\nconst float secondEnemyAttackMinDamage = 5.0;\nconst float secondEnemyAttackMaxDamage = 10.0;\nconst float secondEnemyAttackCooldown  = 1.0;\nconst float secondEnemyAttackDuration  = 2.0;\nconst float secondEnemyMoveSpeed       = 22.0;\n\n// Weapon data\nconst float weaponCooldown = .65;\nconst float weaponDamage   = 3.5;\nconst float weaponRayRadius  = 0.1;\nconst float weaponRayDuration = weaponCooldown;\n\n// Physics Settings\nconst float collisionStepPerMeter = 10.0;\n\n// Initial Values\nconst vec4  initTime\t\t\t= vec4(0, 1, 0, 0);\nconst vec4  initPlayerTransform = vec4(0, 0, -3, 3.1415 * .5);\nconst vec4  initPlayerCamera\t= vec4(3.0, 0, 0, 0);\nconst vec4 \tinitPlayerGun\t\t= vec4(0, 0, 0, -1000);\nconst vec4  initPlayerData\t\t= vec4(99, 0, 0, 0);\nconst vec4  initPlayerHit\t\t= vec4(0,0,0,0);\nconst vec4\tinitFirstEnemyData\t= vec4(10,0,0,0);\nconst vec4\tinitSecondEnemyData\t= vec4(3, 0,0,0);\nconst vec4  initHit\t\t        = vec4(-1, -1, -1, -1);\nconst vec4  initEnemyAI         = vec4(0,0,0,0);\n\n////// Math\nconst float pi = 3.1415926535897932384626433832;\n\nfloat Sign(float f)\n{\n\treturn f < 0.0 ? -1.0 : 1.0;\n}\n\nvec2 Sign(vec2 v)\n{\n\treturn vec2(v.x < 0.0 ? -1.0 : 1.0, v.y < 0.0 ? -1.0 : 1.0);\n}\n\nfloat VMax(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat Random(vec2 seed)\n{\n    return fract(sin(dot(seed.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Random(float x, float y)\n{\n    return Random(vec2(x,y));\n}\n\nfloat Random(float seed)\n{\n    return fract(sin(seed) * 43758.5453123);\n}\n\nfloat RandomRange(float min, float max, float seed)\n{\n    return Random(seed) * (max - min) + min;\n}\n\nvec3 Project(vec3 a, vec3 b)\n{\n\treturn dot(a, b) * b;\n}\n\nfloat Banding(float value, float bandCount)\n{\n    return floor(value * bandCount) / bandCount;\n}\n\n////// Helper Functions\nvec4 LoadValue(vec2 position, sampler2D buffer)\n{\n    return texelFetch(buffer, ivec2(position), 0);\n}\n\nmat3 RotateX(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        1, 0, 0,\n        0, c, s,\n        0,-s, c\n    );\n}\n\nmat3 RotateY(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0,-s,\n        0, 1, 0,\n        s, 0, c\n    );\n}\n\nmat3 RotateZ(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, s, 0,\n       -s, c, 0,\n        0, 0, 1\n    );\n}\n\n\nvec3 GetScreenshake(float trauma, float time)\n{\n\tfloat shake = pow(trauma, 2.2);\n\treturn vec3(\n\t\tmaxScreenshakeAngles.x * shake * (Random(42314.1534, time * 10.0) * 2.0 - 1.0),\n\t\tmaxScreenshakeAngles.y * shake * (Random(56291.2783, time * 10.0) * 2.0 - 1.0),\n\t\tmaxScreenshakeAngles.z * shake * (Random(16912.2456, time * 10.0) * 2.0 - 1.0)\n\t);\n}\n\nvec3 GetCameraForward(float playerRotation, float trauma, float time)\n{\n\tvec3 screenshakeAngles = GetScreenshake(trauma, time);\n\tmat3 x = RotateX(screenshakeAngles.z);\n\tmat3 y = RotateY(screenshakeAngles.y);\n\tmat3 z = RotateZ(screenshakeAngles.x);\n\treturn x * y * z * vec3(cos(playerRotation), 0.0, sin(playerRotation));\n}\n\nvec3 GetCameraRight(float playerRotation, float trauma, float time)\n{\n\tvec3 screenshakeAngles = GetScreenshake(trauma, time);\n\tmat3 x = RotateX(screenshakeAngles.z);\n\tmat3 y = RotateY(screenshakeAngles.y + pi * .5);\n\tmat3 z = RotateZ(screenshakeAngles.x);\n\treturn x * y * z * vec3(cos(playerRotation), 0.0, sin(playerRotation));\n}\n\nvec3 GetCameraUp(float trauma, float time)\n{\n    vec3 screenshakeAngles = GetScreenshake(trauma, time);\n\tmat3 x = RotateX(screenshakeAngles.z);\n\tmat3 y = RotateY(screenshakeAngles.y);\n\tmat3 z = RotateZ(screenshakeAngles.x);\n    return x * y * z * vec3(0,1,0);\n}\n\n////// Signed Distance Fields\nstruct MarchingResult\n{\n\tfloat distance;\n\tint   index;\n};\n\n// Primitives\nMarchingResult Sphere(vec3 p, float radius, int index)\n{\n    MarchingResult o;\n    o.distance = length(p) - radius;\n    o.index = index;\n\treturn o;\n}\n\nMarchingResult Box(vec3 p, vec3 size, int index)\n{\n    MarchingResult o;\n    o.distance = VMax(abs(p) - size);\n    o.index = index;\n    return o;\n}\n\nMarchingResult Torus(vec3 p, float smallRadius, float largeRadius, int index)\n{\n    MarchingResult o;\n    o.distance = length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n    o.index = index;\n    return o;\n}\n\nMarchingResult Capsule(vec3 p, float r, float c, int index)\n{\n    MarchingResult o;\n    o.distance = mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n    o.index = index;\n    return o;\n}\n\nMarchingResult Cylinder(vec3 p, float r, float height, int index)\n{\n    MarchingResult o;\n\tfloat d = length(p.xz) - r;\n\to.distance = max(d, abs(p.y) - height);\n    o.index = index;\n\treturn o;\n}\n\n\nMarchingResult RoundedBox(vec3 p, vec3 size, float radius, int index)\n{\n    MarchingResult o;\n\tvec3 d = abs(p) - size; \n    o.distance = length(max(d,0.0)) - radius\n         + min(max(d.x,max(d.y,d.z)),0.0);\n    o.index = index;\n    return o;\n}\n\nMarchingResult Plane(vec3 p, vec3 normal, float distance, int index)\n{\n    MarchingResult o;\n    o.distance = dot(p, normal) + distance;\n    o.index = index;\n\treturn o;\n}\n\nMarchingResult LineSegment(vec3 p, vec3 a, vec3 b, int index)\n{\n    MarchingResult o;\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n\to.distance = length((ab*t + a) - p);\n    o.index = index;\n    return o;\n}\n\nMarchingResult Capsule(vec3 p, vec3 a, vec3 b, float r, int index)\n{\n\tMarchingResult o = LineSegment(p, a, b, index);\n    o.distance -= r;\n    return o;\n}\n\n\n// Domain Operations\nvoid Rotate(inout vec2 p, float angle)\n{\n    p = cos(angle) * p + sin(angle) * vec2(p.y, -p.x);\n}\n\nvoid Rotate45(inout vec2 p)\n{\n    p = (p + vec2(p.y, -p.x)) * sqrt(0.5);\n}\n\nfloat Mod1(inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat ModMirror1(inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c, 2.0) * 2.0 - 1.0;\n\treturn c;\n}\n\nfloat ModSingle1(inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tif (p >= 0.0)\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat ModInterval1(inout float p, float size, float start, float end)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p+halfsize, size) - halfsize;\n\n\tif (c > end)\n    {\n\t\tp += size*(c - end);\n\t\tc = end;\n\t}\n\n\tif (c <start)\n    {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\n\treturn c;\n}\n\nfloat ModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle =  pi / repetitions;\n\tfloat a = atan(p.y, p.x) * 0.5 + pi * 0.5 + angle / 2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a / angle);\n\ta = mod(a, angle) - angle / 2.0;\n\tp = vec2(cos(a), sin(a)) * r;\n\tif (abs(c) >= (repetitions / 2.0)) c = abs(c);\n\treturn c;\n}\n\nvec2 Mod2(inout vec2 p, vec2 size)\n{\n\tvec2 c = floor((p + size * 0.5) / size);\n\tp = mod(p + size * 0.5,size) - size * 0.5;\n\treturn c;\n}\n\nvec2 ModMirror2(inout vec2 p, vec2 size)\n{\n\tvec2 halfsize = size * 0.5;\n\tvec2 c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c, vec2(2.0, 2.0)) * 2.0 - vec2(1.0, 1.0);\n\treturn c;\n}\n\nvec2 ModGrid2(inout vec2 p, vec2 size)\n{\n\tvec2 c = floor((p + size * 0.5) / size);\n\tp = mod(p + size * .5, size) - size * 0.5;\n\tp *= mod(c, vec2(2.0, 2.0)) * 2.0 - vec2(1.0, 1.0);\n\tp -= size / 2.0;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c / 2.0);\n}\n\nvec3 Mod3(inout vec3 p, vec3 size)\n{\n\tvec3 c = floor((p + size * 0.5) / size);\n\tp = mod(p + size * 0.5, size) - size * 0.5;\n\treturn c;\n}\n\nfloat Mirror(inout float p, float dist)\n{\n\tfloat s = Sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 MirrorOctant(inout vec2 p, vec2 dist)\n{\n\tvec2 s = Sign(p);\n\tMirror(p.x, dist.x);\n\tMirror(p.y, dist.y);\n\tif (p.y > p.x) p.xy = p.yx;\n\treturn s;\n}\n\nfloat Reflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n\tplaneNormal = normalize(planeNormal);\n\tfloat t = dot(p, planeNormal) + offset;\n\tif (t < 0.0) p = p - (2.0 * t) * planeNormal;\n\treturn Sign(t);\n}\n\n// Combination Operations\nMarchingResult Union(MarchingResult r1, MarchingResult r2)\n{\n    if(r1.distance < r2.distance) return r1;\n    else return r2;\n}\n\nMarchingResult Substraction(MarchingResult r1, MarchingResult r2)\n{\n    MarchingResult o = r1;\n    if(-r1.distance > r2.distance)\n    {\n        o.distance      = -r1.distance;\n        o.index = r1.index;\n    }\n    else\n    {\n        o.distance      = r2.distance;\n        o.index = r2.index;\n    }\n    return o;\n}\n\nMarchingResult Intersection(MarchingResult r1, MarchingResult r2)\n{\n    MarchingResult o;\n    if(r1.distance > r2.distance)\n    {\n        o.distance      = r1.distance;\n        o.index = r1.index;\n    }\n    else\n    {\n        o.distance      = r2.distance;\n        o.index = r2.index;\n    }\n    return o;\n}\n\nMarchingResult UnionSoft(MarchingResult r1, MarchingResult r2, float r)\n{\n    MarchingResult o = Union(r1, r2);\n\tfloat e = max(r - abs(r1.distance - r2.distance), 0.0);\n\to.distance = min(r1.distance, r2.distance) - e*e*0.25/r;\n    return o;\n}\n\nMarchingResult UnionColumns(MarchingResult r1, MarchingResult r2, float radius, float number)\n{\n    MarchingResult o = Union(r1, r2);\n\n    number = number / 2.0 + 0.5;\n    \n    if ((r1.distance < radius) && (r2.distance < radius))\n    {\n\t\tvec2 p = vec2(r1.distance, r2.distance);\n\t\tfloat columnradius = radius * sqrt(2.0) / ((number - 1.0) * 2.0 + sqrt(2.0));\n\t\tRotate45(p);\n\n\t\tp.x -= sqrt(2.0) / 2.0 * radius;\n\t\tp.x += columnradius * sqrt(2.0);\n\n\t\tif (mod(number, 2.0) == 1.0) p.y += columnradius;\n        if(p.y < 0.0) p.y = -p.y;\n\n\t\tMod1(p.y, columnradius * 2.0);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, r1.distance);\n\t\to.distance = min(result, r2.distance);\n\t}\n    else o.distance = min(r1.distance, r2.distance);\n\n    return o;\n}\n\n// Scene\nMarchingResult Ray(vec3 p, vec4 time, sampler2D data)\n{\n    vec4 playerTransform = LoadValue(layoutPlayerTransform, data);\n    vec4 hit = LoadValue(layoutHit, data);\n    vec4 shot = LoadValue(layoutPlayerGun, data);\n    float normalizedDuration = clamp((time.x - shot.z) / weaponRayDuration, 0.0, 1.0);\n    float radius = mix(weaponRayRadius, 0.0, normalizedDuration);\n    MarchingResult result = Capsule(p, hit.xyz, vec3(shot.x, -.25, shot.y), radius, 300);\n   \n    result.distance /= 1.0 - normalizedDuration;\n    \n    return result;\n}\n\nMarchingResult Enemy0(vec3 p, vec4 transform, vec4 data, vec4 time, int index)\n{\n    vec3 baseP = p;\n    p -= transform.xyz;\n    p *= mix(.65, 1.0, clamp((time.x - data.y) * 10.0, 0.0, 1.0));\n    Rotate(p.xz, transform.w);\n    MarchingResult result = Capsule(p, 1.0, 0.8, 100 + index);\n    Mirror(p.z, 0.5);\n    Mirror(p.y, 0.5);\n    Rotate(p.xy, pi * .5);\n    Rotate(p.xz, pi * .25);\n    p.x += (p.y + .75) * sin(p.y * 5.0 + time.x * 2.0) * .1;\n    Rotate(p.xz, p.y);\n    result = UnionSoft(result, Capsule(p + vec3(0, 1.5, 0), 0.25, 1.5, 100 + index), .2);\n    \n    return result;\n}\n\nMarchingResult Enemy1(vec3 p, vec4 transform, vec4 data, vec4 time, int index)\n{\n    p -= transform.xyz;\n    p -= vec3(0, .3 + sin(time.x * 10.0 + float(index)) * .1, 0);\n    Rotate(p.xz, transform.w);\n    \n    MarchingResult result = Sphere(p, 0.5, 200 + index);\n    result = Union(result, Sphere(p - vec3(.3,0,0), 0.3, 100 + index));\n    result = Union(result, Sphere(p - vec3(.45,0,0), 0.2, 200 + index));\n    Mirror(p.z, 0.0);\n    Rotate(p.zy, mix(.3, 1.0, sin(time.x * 10.0) * .5 + .5));\n    p.z -= .8;\n    p.x += .3;\n    p.y -= .2;\n    \n    result = UnionSoft(result, Box(p, vec3(.5,.05,.7), 200 + index), .3);\n    return result;\n}\n\nMarchingResult PhysicsEnemy(vec3 p, vec4 transform, vec4 data, vec4 time, int index)\n{\n    p -= transform.xyz;\n    return Capsule(p, 1.0, 100.0, 0);\n}\n\nMarchingResult Enemies(vec3 p, sampler2D data, int ignoreEnemy)\n{\n    vec4 time = LoadValue(layoutTime, data);\n    MarchingResult result = Sphere(p + vec3(1000), 0.0, -1);\n    for(float i = 0.0; i < enemyCount; ++i)\n    if(ignoreEnemy != int(i))\n    {\n        vec4 enemyTransform = LoadValue(layoutEnemies + vec2(i, 0.0), data);\n        vec4 enemyData = LoadValue(layoutEnemiesData + vec2(i, 0.0), data);\n        if(enemyData.x > 0.0)\n        {\n            vec3 offset = ignoreEnemy != -1 ? vec3(0) : vec3(0, 3.0 * pow(clamp(1.0 - (time.x - enemyData.w) * RandomRange(.3, 3.2, i), 0.0, 1.0), 2.0), 0);\n            if(ignoreEnemy != -1) result = Union(result, PhysicsEnemy(p, enemyTransform, enemyData, time, int(i)));\n            else if(i < firstEnemyCount) result = Union(result, Enemy0(p + offset, enemyTransform, enemyData, time, int(i)));\n            else result = Union(result, Enemy1(p + offset, enemyTransform, enemyData, time, int(i)));\n        }\n    }\n    \n    return result;\n}\n\nMarchingResult ScenePhysics(vec3 p, sampler2D data, int ignoreEnemy)\n{\n    vec3 baseP = p;\n    float mP = ModSingle1(p.z, 100.0);\n    vec3 subP = p;\n    \n    p.y += 1.5;\n    MirrorOctant(p.xz, vec2(25));\n    Rotate(p.xz, pi * .5);\n    MarchingResult result = Box(p + vec3(25,0,0), vec3(26,10,1.25), 0);\n    \n    result = Union(Box(subP + vec3(0, -2, -50), vec3(4.5, 10, 26), 0), result);\n    result = Substraction(Box(subP + vec3(0, -2, -27), vec3(3, 400, 50), 0), result);\n    if(mP > 0.0)\n    {\n    \tresult = Union(Box(subP + vec3(0, -2, 50), vec3(4.5, 10, 26), 0), result);\n    \tresult = Substraction(Box(subP + vec3(0, -2, 25), vec3(3, 400, 50), 0), result);\n    }\n    \n    result = Union(result, Enemies(baseP, data, ignoreEnemy));\n\n    return result;\n}\n\nMarchingResult Fence(vec3 p, float index)\n{\n    vec3 subP = p;\n    p.y += 1.5;\n   \tvec2 octantIndex = MirrorOctant(p.xz, vec2(25));\n    Rotate(p.xz, pi * .5);\n    MarchingResult result = Box(p + vec3(25,0,0), vec3(26,1,1), 0);\n    result = UnionColumns(result, Box(p + vec3(25,-1,0), vec3(26,.3,.5), 0), 0.4, 5.0);\n    //result = UnionColumns(result, Box(p + vec3(25,0,0), vec3(26,.5,1), 0), 0.6, 2.0);\n  \tfloat i = ModInterval1(p.x, 1.0, -25.0, 25.0);\n    float height = mix(2.0, 3.0, sin(i * .3 + 10.0 * Random(index * 1.8723 + 12.9) + Random(index * 19287.891723 + 123.9) * pi) * .5 + .5);\n    Rotate(p.xz, p.y * 2.0);\n    Rotate(p.xy, Random(octantIndex + i + 123.190) * .015);\n    result = Union(result, Box(p - vec3(0,height,0), vec3(0.1, height, 0.1), 400));\n    result = UnionSoft(result, Box(p - vec3(0,height,0) * 2.0, vec3(.15), 400), .2);\n    \n    result = Substraction(Box(subP + vec3(0, -2, index == 0.0 ? -27 : 0), vec3(5.25, 4, 50), 0), result);\n    Mirror(subP.x, 3.0);\n    vec3 aP = subP + vec3(-1, 1, -50);\n    vec3 bP = subP + vec3(-1, 1, 50);\n    Rotate(aP.xy, aP.z);\n    Rotate(bP.xy, bP.z);\n    result = Union(result, Box(aP, vec3(.25,.25,25), 400));\n    if(index > 0.0) result = Union(result, Box(bP, vec3(.25,.25,25), 400));\n    Mirror(subP.z, 25.0);    \n    result = UnionColumns(result, Cylinder(subP - vec3(1,-99.0,0), 1.5, 100.0, 0), .2, 2.0);\n    \n    subP.x -= 1.0;\n    if(subP.y > 0.0)\n    Rotate(subP.xy, subP.y * subP.y * .01);\n    Rotate(subP.xz, subP.y);\n\tresult = Union(result, RoundedBox(subP, vec3(0.5, 10.0, 0.5), 0.5, 400));\n    \n    return result;\n}\n\nMarchingResult Ground(vec3 p, float index)\n{\n    MarchingResult result = Box(p + vec3(0,52,0), vec3(25,50,25), 0);\n    return Union(result, Box(p + vec3(0, 5, index == 0.0 ? -25 : 0), vec3(3, 3, 50), 0));\n}\n\nMarchingResult Vista(vec3 p, vec4 time)\n{\n    p.y -= 15.0;\n\tvec3 modP = p;\n    float index1 = ModInterval1(modP.y, 5.0, 0.0, 30.0);\n    modP = p;\n    \n    Rotate(modP.xy, -sin(time.x * .3 + index1 * .897) * .02);\n    //Rotate(modP.yz, sin(time.x * .5 + index1 * 1.243) * .01);\n    Rotate(modP.xz, index1 + index1 * time.x * .01);\n\n\tfloat index0 = ModMirror1(modP.x, 10.0);\n    ModInterval1(modP.y, 5.0, 0.0, 30.0);\n    Rotate(modP.xy, time.x);\n    \n    Rotate(modP.yz, pi * .5);\n\t\n\tMarchingResult final = Plane(p, vec3(0.0, 1.0, 0.0), 1.0, 0);\n    Rotate(modP.xz, modP.y);\n\tfinal = RoundedBox(modP, vec3(0.5, 1000000.0, 0.5), 0.5, 400);\n    \n    return final;\n}\n\nMarchingResult SceneRendering(vec3 p, sampler2D data)\n{  \n    //return ScenePhysics(p, data, -1);\n    vec4 playerTransform = LoadValue(layoutPlayerTransform, data);\n    vec4 time = LoadValue(layoutTime, data);\n    \n    vec3 baseP = p;\n    float mP = ModSingle1(p.z, 100.0);\n\t\n    float tmp = mP;\n\tMarchingResult result = Ground(p, mP);\n    result = UnionSoft(result, Enemies(baseP, data, -1), 2.0);\n    result = Union(result, Fence(p, mP));\n    result = Union(result, Vista(baseP, time));\n    \n    result = Union(result, Ray(baseP, time, data));\n    \n    return result;\n}\n\nvec3 ComputePhysicsNormal(vec3 p, float normalEpsilon, sampler2D data, int ignoreEnemy)\n{\n   return normalize(vec3(ScenePhysics(p + vec3(normalEpsilon, 0.0, 0.0), data, ignoreEnemy).distance - ScenePhysics(p + vec3(-normalEpsilon, 0.0, 0.0), data, ignoreEnemy).distance,\n                         ScenePhysics(p + vec3(0.0, normalEpsilon, 0.0), data, ignoreEnemy).distance - ScenePhysics(p + vec3(0.0, -normalEpsilon, 0.0), data, ignoreEnemy).distance,\n                         ScenePhysics(p + vec3(0.0, 0.0, normalEpsilon), data, ignoreEnemy).distance - ScenePhysics(p + vec3(0.0, 0.0, -normalEpsilon), data, ignoreEnemy).distance));\n}\n\nvec3 ComputeRenderingNormal(vec3 p, float normalEpsilon, vec2 resolution, sampler2D data)\n{\n   return normalize(vec3(SceneRendering(p + vec3(normalEpsilon, 0.0, 0.0), data).distance - SceneRendering(p + vec3(-normalEpsilon, 0.0, 0.0), data).distance,\n                         SceneRendering(p + vec3(0.0, normalEpsilon, 0.0), data).distance - SceneRendering(p + vec3(0.0, -normalEpsilon, 0.0), data).distance,\n                         SceneRendering(p + vec3(0.0, 0.0, normalEpsilon), data).distance - SceneRendering(p + vec3(0.0, 0.0, -normalEpsilon), data).distance));\n}\n\n// Lights\n\nvec3 GetPlayerPointLight(vec3 position, vec3 player, vec3 normal, float distance)\n{\n    return playerPointLightColor * Banding(min(.75, max(0.25, dot(normalize(player.xyz - position), normal) / distance * 2.5)), lightBanding);\n}\n\nvec3 GetDirectionalLight(vec3 normal)\n{\n    return directionalLightColor * Banding(max(0.0, dot(lightDirection, normal)) * .75, lightBanding);\n}\n\nvec3 GetRayLight(vec3 position, vec4 time, sampler2D data)\n{\n    return 2.0 * rayLightColor * max(0.0, Banding(1.0 / Ray(position, time, data).distance, lightBanding));\n}\n\n// Text rendering\n// https://www.shadertoy.com/view/XtsGRl\n\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\nvec2 res = vec2(0);\nvec2 print_pos = vec2(2,2);\n\n//Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nfloat get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return 0.0;\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv, bool ignoreClip, int maxLength)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.0;\n    \n\tfor(int i = maxLength;i >= 0;i--)\n    {\n        float clip = ignoreClip ? 1.0 : float(abs(number) > pow(10.0, float(i)) || i == 0); //Clip off leading zeros.\n        \n        float digit = mod(number / pow(10.0, float(i)),10.0);\n        \n        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;\n        \n        dec_pos.x += CHAR_SPACING.x * clip;\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gameplay\n\n// Helper functions\n\nfloat isKeyPressed(float key, sampler2D keyboard)\n{\n\treturn texture(keyboard, vec2(key / 256.0, 0)).x;\n}\n\nbool CorrectFragment(vec2 fragCoord, vec2 position)\n{\n    return length(fragCoord - position) < 1.0;\n}\n\nvec3 Move(vec3 position, vec3 movement, float radius, int ignoreEnemy)\n{\n    movement.y = 0.0;\n    vec3 direction = normalize(movement);\n    for(float i = 0.0; i < collisionStepPerMeter * length(movement); ++i)\n    {\n        float distance = min(0.0, ScenePhysics(position + movement / collisionStepPerMeter, iChannel1, ignoreEnemy).distance - radius);\n        vec3  normal = ComputePhysicsNormal(position + movement / collisionStepPerMeter, 0.001, iChannel1, ignoreEnemy);\n        vec3  normalRight = normalize(vec3(normal.z, 0, normal.x));\n        vec3  projectedDirection = Project(direction, normalRight);\n        vec3  slide = projectedDirection * -distance;\n\n        position += movement / collisionStepPerMeter + direction * distance + slide * .5;\n    }\n\n    return position;\n}\n\nvoid Fire(out vec4 fragColor, vec3 position, vec3 direction)\n{\n    float totalDistance = 0.0;\n    vec3 step = position;\n    MarchingResult result;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n    {\n        step = position + totalDistance * direction;\n        result = ScenePhysics(step, iChannel1, -1);\n        totalDistance += result.distance;\n        \n        if(result.distance <= epsilon || totalDistance > maxDistance) break;\n    }\n    \n    if(result.distance <= epsilon && result.index >= 100)\n    {\n        fragColor.w = float(result.index % int(enemyCount));\n    }\n    else fragColor = vec4(0,0,0,-1);\n\n    fragColor.xyz = step;\n}\n\nfloat GetGunDamage()\n{\n    float current = LoadValue(layoutPlayerData, iChannel1).z;\n    \n    if(current == 0.0) return weaponDamage;\n    return weaponDamage;\n}\n\nfloat GetCurrentRoom(vec3 position)\n{\n    return floor((position.z + 50.0) / 100.0);\n}\n\n// Core functions\n\nvoid Initialize(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = vec4(0,0,0,0);\n    if(CorrectFragment(fragCoord, layoutTime)) fragColor = initTime;\n    else if(CorrectFragment(fragCoord, layoutPlayerTransform)) fragColor = initPlayerTransform;\n    else if(CorrectFragment(fragCoord, layoutPlayerData)) fragColor = initPlayerData;\n    else if(CorrectFragment(fragCoord, layoutHit)) fragColor = initHit;\n    else if(CorrectFragment(fragCoord, layoutPlayerCamera)) fragColor = initPlayerCamera;\n    else for(float i = 0.0; i < enemyCount; ++i)\n    \t if(CorrectFragment(fragCoord, layoutEnemies + vec2(i, 0.0)))\n         {\n             float x = 1000.0;\n             float z = 1000.0;\n             fragColor = vec4(x, 0, z, 0);\n             break;\n         }\n    \t else if(CorrectFragment(fragCoord, layoutEnemiesData + vec2(i, 0.0)))\n         {\n             fragColor = i < firstEnemyCount ? initFirstEnemyData : initSecondEnemyData;\n             break;\n         }\n        else if(CorrectFragment(fragCoord, layoutEnemiesAI + vec2(i, 0.0)))\n        {\n            fragColor = initEnemyAI;\n            fragColor.y = RandomRange(-3.5f, 3.5f, fragCoord.x);\n    \t}\n}\n\nbool Input(out vec4 fragColor, vec2 fragCoord, vec4 time)\n{\n    fragColor = LoadValue(fragCoord, iChannel1);\n    \n    if(CorrectFragment(fragCoord, layoutPlayerTransform))\n    {\n        vec4 playerTransform = fragColor;    \n        vec3 direction = vec3(0,0,0);\n        vec4 time = LoadValue(layoutTime, iChannel1);\n\n        vec3 forward = GetCameraForward(playerTransform.w, 0.0, time.x);\n        vec3 right   = GetCameraRight(playerTransform.w, 0.0, time.x);\n\n        direction += forward * max(isKeyPressed(keyForward, iChannel0),  isKeyPressed(keyForwardAlt, iChannel0));\n        direction -= forward * max(isKeyPressed(keyBackward, iChannel0), isKeyPressed(keyBackwardAlt, iChannel0));\n        direction += right * max(isKeyPressed(keyRight, iChannel0),\t isKeyPressed(keyRightAlt, iChannel0));\n        direction -= right * max(isKeyPressed(keyLeft, iChannel0),\t isKeyPressed(keyLeftAlt, iChannel0));\n\t\tdirection.y = 0.0;\n        playerTransform.w += isKeyPressed(keyRotateLeft,  iChannel0) * iTimeDelta * playerRotationSpeed;\n        playerTransform.w -= isKeyPressed(keyRotateRight, iChannel0) * iTimeDelta * playerRotationSpeed;\n\n        if(length(direction) > 0.0)\n        {\n        \tplayerTransform.xyz = Move(playerTransform.xyz, normalize(direction) * time.y * iTimeDelta * playerSpeed, playerRadius, -1);\n        \tplayerTransform.y = sin(time.x * 10.0) * playerHeadBump + playerHeadBump;\n        }\n        else playerTransform.y = mix(playerTransform.y, 0.0, iTimeDelta * 9.0);\n\n        fragColor = playerTransform;\n\n        return true;\n    }\n    else if(CorrectFragment(fragCoord, layoutPlayerGun))\n    {\n        if(fragColor.z + weaponCooldown >= iTime) return true;\n        \n        vec4 playerTransform = LoadValue(layoutPlayerTransform, iChannel1);\n        float trauma = LoadValue(layoutPlayerCamera, iChannel1).y;\n        \n        if(isKeyPressed(keyFire, iChannel0) > 0.0)\n        {\n            fragColor.xy = playerTransform.xz + GetCameraForward(playerTransform.w, trauma, time.x).xz * 0.6 + GetCameraRight(playerTransform.w, trauma, time.x).xz * .25;\n            fragColor.z = iTime;\n            fragColor.w = float(iFrame);\n        }\n        \n        return true;\n    }\n    else if(CorrectFragment(fragCoord, layoutHit))\n    {\n        fragColor.w = initHit.w;\n        \n        vec4 playerTransform = LoadValue(layoutPlayerTransform, iChannel1);\n        vec4 time = LoadValue(layoutTime, iChannel1);\n        \n        vec3 cameraForward   = GetCameraForward(playerTransform.w, 0.0, time.x);\n        vec4 gunData = LoadValue(layoutPlayerGun, iChannel1);\n        \n        if(iFrame - int(gunData.w) < 2) Fire(fragColor, playerTransform.xyz, cameraForward);  \n        \n        return true;\n    }\n    \n    return false;\n\n}\n\nbool EnemiesMove(out vec4 fragColor, vec2 fragCoord, vec4 time)\n{\n    fragColor = LoadValue(fragCoord, iChannel1);\n\n    for(float i = 0.0; i < enemyCount; ++i)\n    if(CorrectFragment(fragCoord, layoutEnemies + vec2(i, 0.0)))\n    {\n        vec4 data = LoadValue(layoutEnemiesData + vec2(i, 0.0), iChannel1);\n        vec4 playerTransform = LoadValue(layoutPlayerTransform, iChannel1);\n        \n        if(pow((time.x - data.w), 2.0) * RandomRange(.3, 3.2, i) < 1.0) return true;\n        \n        if(data.x > 0.0)\n        {\n            vec3 direction = normalize(playerTransform.xyz - fragColor.xyz);\n            if(i < firstEnemyCount)\n            {                \n                if(length(playerTransform.xyz - fragColor.xyz) < firstEnemyAttackDistance) return true;\n\n               fragColor.xyz = Move(fragColor.xyz, direction * iTimeDelta  * firstEnemyMoveSpeed, 1.0, int(i));\n                fragColor.w = atan(direction.z, direction.x);\n            }\n            else\n            {                \n                vec4 ai = LoadValue(layoutEnemiesAI + vec2(i,0), iChannel1);\n                if(time.x < ai.y + secondEnemyAttackDuration);\n                fragColor.xyz = Move(fragColor.xyz, vec3(cos(ai.x), 0, sin(ai.x)) * iTimeDelta * secondEnemyMoveSpeed, 1.0, int(i));\n                fragColor.w = atan(direction.z, direction.x);\n            }\n        }\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool EnemiesAI(out vec4 fragColor, vec2 fragCoord, vec4 time)\n{\n    fragColor = LoadValue(fragCoord, iChannel1);\n\n    for(float i = 0.0; i < enemyCount; ++i)\n    if(CorrectFragment(fragCoord, layoutEnemiesAI + vec2(i, 0.0)))\n    {\n        if(i < firstEnemyCount)\n        {\n        }\n        else\n        {\n            if(time.x > fragColor.y + secondEnemyAttackDuration && time.x < fragColor.y + secondEnemyAttackDuration + secondEnemyAttackCooldown) fragColor.z = time.x;\n            else if(time.x > fragColor.y + secondEnemyAttackDuration + secondEnemyAttackCooldown)\n            {\n                vec4 transform = LoadValue(layoutEnemies + vec2(i, 0.0), iChannel1);\n                vec4 playerTransform = LoadValue(layoutPlayerTransform, iChannel1);\n                vec3 direction = normalize(playerTransform.xyz - transform.xyz);\n                fragColor.x = atan(direction.z, direction.x);\n                fragColor.y = time.x;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nbool EnemiesData(out vec4 fragColor, vec2 fragCoord, vec4 time)\n{\n    fragColor = LoadValue(fragCoord, iChannel1);\n    vec4 hit = LoadValue(layoutHit, iChannel1);\n\n    for(float i = 0.0; i < enemyCount; ++i)\n    if(CorrectFragment(fragCoord, layoutEnemiesData + vec2(i, 0.0)))\n    {\n        if(hit.w == i)\n        {\n            fragColor.x -= GetGunDamage();\n            fragColor.y = iTime;\n            if(fragColor.x <= 0.0) fragColor.z = time.x;\n            return true;\n        }\n\n        if(fragColor.x <= 0.0 && fragColor.z + enemyRespawnTime < time.x)\n        fragColor = i < firstEnemyCount ? initFirstEnemyData : initSecondEnemyData;\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool EnemiesAttack(out vec4 fragColor, vec2 fragCoord, vec4 time)\n{\n    fragColor = LoadValue(fragCoord, iChannel1);\n    \n    if(!CorrectFragment(fragCoord, layoutPlayerHit)) return false;\n\n    vec4 playerTransform = LoadValue(layoutPlayerTransform, iChannel1);\n    fragColor = initPlayerHit;\n\n    for(float i = 0.0; i < enemyCount; ++i)\n    {\n        vec4 data = LoadValue(layoutEnemiesData + vec2(i, 0.0), iChannel1);\n        if(data.x <= 0.0) return true;\n\n        vec4 transform = LoadValue(layoutEnemies + vec2(i, 0.0), iChannel1);\n\n        if(i < firstEnemyCount)\n        {\n            if(length(transform.xyz - playerTransform.xyz) <= firstEnemyAttackDistance)\n            {\n                fragColor.x = RandomRange(firstEnemyAttackMinDamage, firstEnemyAttackMaxDamage, iTime + float(i) + playerTransform.x);\n                return true;\n            }\n        }\n        else\n        {\n            if(length(transform.xyz - playerTransform.xyz) < secondEnemyAttackDistance)\n            {\n                fragColor.x = RandomRange(firstEnemyAttackMinDamage, secondEnemyAttackMaxDamage, iTime + float(i) + playerTransform.x);\n                return true;\n            }\n        }\n    }\n    \n    return true;\n}\n\nbool PlayerData(out vec4 fragColor, vec2 fragCoord, vec4 time)\n{\n    fragColor = LoadValue(fragCoord, iChannel1);\n    \n    if(!CorrectFragment(fragCoord, layoutPlayerData)) return false;\n    \n    vec4 hit = LoadValue(layoutHit, iChannel1);\n    vec4 playerHit = LoadValue(layoutPlayerHit, iChannel1);\n    \n    if(hit.w > -1.0 && LoadValue(layoutEnemiesData + vec2(hit.w, 0.0), iChannel1).x <= GetGunDamage())\n    fragColor.y += 1.0;\n    \n    if(playerHit.x > 0.0 && time.x > fragColor.w + playerInvulnerability)\n    {\n        fragColor.x = max(0.0, fragColor.x - playerHit.x);\n        fragColor.w = iTime;\n    }\n    \n    return true;\n}\n\nbool CameraFeedbacks(out vec4 fragColor, vec2 fragCoord, vec4 time)\n{\n    fragColor = LoadValue(fragCoord, iChannel1);\n    \n    if(CorrectFragment(fragCoord, layoutPlayerCamera))\n    {\n        vec4 gunData = LoadValue(layoutPlayerGun, iChannel1);\n        \n        fragColor.x = mix(fragColor.x, cameraFocal, iTimeDelta * 10.0);\n        \n        if(iFrame - int(gunData.w) < 2) fragColor.x = cameraShotFocal;\n        \n        vec4 playerHit = LoadValue(layoutPlayerHit, iChannel1);\n        if(playerHit.x > 0.0 && time.x > fragColor.w + playerInvulnerability) fragColor.y = playerHit.x / max(firstEnemyAttackMaxDamage, secondEnemyAttackMaxDamage);\n        else fragColor.y = mix(fragColor.y, 0.0, iTimeDelta * 9.0);\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool Time(out vec4 fragColor, vec2 fragCoord, out vec4 time)\n{\n    if(!CorrectFragment(fragCoord, layoutTime))\n    {\n        fragColor = LoadValue(fragCoord, iChannel1);\n        //time = LoadValue(layoutTime, iChannel1);\n        time.x = iTime; // Stop using custom time because of floating point precision\n        return false;\n    }\n    else\n    {\n        time = LoadValue(layoutTime, iChannel1);\n        //time.x += iTimeDelta * time.y;\n        time.x = iTime; // Stop using custom time\n        fragColor = time;\n        return true;\n    }\n}\n\nvoid RespawnEnemies(out vec4 fragColor, vec4 currentFragColor, vec2 fragCoord, float currentRoom, vec4 time)\n{\n    fragColor = currentFragColor;\n    for(float i = 0.0; i < enemyCount; ++i)\n    if(CorrectFragment(fragCoord, layoutEnemies + vec2(i, 0.0)))\n    {\n    \tfloat x = RandomRange(-20.0, 20.0, 128.123 + i * 123.43 + time.x);\n    \tfloat z = currentRoom * 100.0 + RandomRange(-20.0, 20.0, 18.143 + i * 83.12 + time.x);\n    \tfragColor = vec4(x, 0, z, 0);\n    \tbreak;\n    }\n    else if(CorrectFragment(fragCoord, layoutEnemiesData + vec2(i, 0.0)))\n    {\n    \tfragColor = i < firstEnemyCount ? initFirstEnemyData : initSecondEnemyData;\n        fragColor.w = iTime;\n    \tbreak;\n    }\n    else if(CorrectFragment(fragCoord, layoutEnemiesAI + vec2(i, 0.0)))\n    {\n   \t\tfragColor = initEnemyAI;\n    \tfragColor.y = RandomRange(-3.5f, 3.5f, fragCoord.x);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{    \n    if(iFrame == 0)\n    {\n        Initialize(fragColor, fragCoord);\n        return;\n    }\n    \n    float currentRoom = LoadValue(layoutPlayerCamera, iChannel1).z;\n    vec3 playerPosition = LoadValue(layoutPlayerTransform, iChannel1).xyz;\n    float newRoom = GetCurrentRoom(playerPosition);\n    \n    vec4 time;\n    \n\tif(Time(fragColor, fragCoord, time));\n    else if(Input(fragColor, fragCoord, time));\n  \telse if(EnemiesMove(fragColor, fragCoord, time));\n    else if(EnemiesData(fragColor, fragCoord, time));\n    else if(EnemiesAttack(fragColor, fragCoord, time));\n    else if(EnemiesAI(fragColor, fragCoord, time));\n    else if(CameraFeedbacks(fragColor, fragCoord, time));\n    else if(PlayerData(fragColor, fragCoord, time));\n        \n    if(currentRoom < newRoom && newRoom > 0.0)\n    {\n        currentRoom = newRoom;\n        RespawnEnemies(fragColor, fragColor, fragCoord, currentRoom, time);\n        if(CorrectFragment(fragCoord, layoutPlayerCamera)) fragColor.z = currentRoom; \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Rendering\n\nvoid ComputeMaterial(out vec4 fragColor, MarchingResult result, vec3 position, vec3 player, float distance, vec4 time)\n{\n    int index = result.index/100;\n    \n    if(index == 0)\n    {\n        vec3 normal = ComputeRenderingNormal(position, 0.01, iResolution.xy, iChannel0);\n        vec3 pointLight = GetPlayerPointLight(position, player, normal, distance);\n        vec3 directionalLight = GetDirectionalLight(normal);\n        vec3 rayLight = GetRayLight(position, time, iChannel0);\n        vec3 light = pointLight + directionalLight + rayLight;\n        \n        float color = Random(floor(position.xz * 5.0) + Random(floor(vec2(position.yz) * 5.0))) * .1 + .75;\n      \n        fragColor = mix(vec4(light * color, 1) * vec4(79.0/255.0, 69.0/255.0, 69.0/255.0, 1), vec4(.25, .25, .25, 1), clamp(distance / fogDistance, 0.0, 1.0));\n        fragColor = mix(fragColor, vec4(.25, .25, .25, 1), clamp((1.0 - position.y) / 20.0, 0.0, 1.0));\n        \n \t}\n   \telse if(index == 1) // First Enemy\n    {\n        vec3 normal = ComputeRenderingNormal(position, 0.01, iResolution.xy, iChannel0);\n        vec4 data = LoadValue(layoutEnemiesData + vec2(result.index % int(enemyCount), 0.0), iChannel0);\n        vec3 pointLight = GetPlayerPointLight(position, player, normal, distance);\n        vec3 directionalLight = GetDirectionalLight(normal);\n        vec3 rayLight = GetRayLight(position, time, iChannel0);\n        vec3 light = pointLight + directionalLight + rayLight;\n\n        fragColor = vec4(mix(rayLightColor, .9 * vec3(226.0 / 255.0, 159.0 / 255.0, 172.0 / 255.0), clamp((time.x - data.y) * 10.0, 0.0, 1.0)) * light, 1);\n        fragColor = mix(fragColor, vec4(.25, .25, .25, 1), clamp(distance / fogDistance, 0.0, 1.0));\n    }\n    else if(index == 2) // Second Enemy\n    {\n        vec3 normal = ComputeRenderingNormal(position, 0.01, iResolution.xy, iChannel0);\n        vec4 data = LoadValue(layoutEnemiesData + vec2(result.index % int(enemyCount), 0.0), iChannel0);\n        vec3 pointLight = GetPlayerPointLight(position, player, normal, distance);\n        vec3 directionalLight = GetDirectionalLight(normal);\n        vec3 rayLight = GetRayLight(position, time, iChannel0);\n        vec3 light = pointLight + directionalLight + rayLight;\n\n        fragColor = vec4(mix(rayLightColor, .3 * vec3(226.0 / 255.0, 159.0 / 255.0, 172.0 / 255.0), clamp((time.x - data.y) * 10.0, 0.0, 1.0)) * light, 1);\n        fragColor = mix(fragColor, vec4(.25, .25, .25, 1), clamp(distance / fogDistance, 0.0, 1.0));\n    }\n    else if(index == 3) // Ray\n    {\n        fragColor = mix(vec4(rayLightColor, 1), vec4(.25, .25, .25, 1), clamp(distance / fogDistance, 0.0, 1.0));\n    }\n    else if(index == 4) // Wires\n    {\n        vec3 normal = ComputeRenderingNormal(position, 0.001, iResolution.xy, iChannel0);\n        vec3 pointLight = GetPlayerPointLight(position, player, normal, distance);\n        vec3 directionalLight = GetDirectionalLight(normal);\n        vec3 rayLight = GetRayLight(position, time, iChannel0);\n        vec3 light = pointLight + directionalLight + rayLight;\n\n        fragColor = mix(vec4(light * vec3(.55, .35, .25) , 1), vec4(.25, .25, .25, 1), clamp(distance / fogDistance, 0.0, 1.0));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(fragCoord.x >= screenSize.x || fragCoord.y >= screenSize.y) discard;\n    \n\tvec4  time = vec4(iTime, 1, 0, 0); // LoadValue(layoutTime, iChannel0);\n    vec4  playerTransform = LoadValue(layoutPlayerTransform, iChannel0);\n    vec4  cameraData \t  = LoadValue(layoutPlayerCamera, iChannel0);\n    vec3  cameraPosition  = playerTransform.xyz;\n    vec3  cameraForward   = GetCameraForward(playerTransform.w, cameraData.y, time.x);\n    vec3  cameraRight     = GetCameraRight(playerTransform.w, cameraData.y, time.x);\n    vec3  cameraUp        = GetCameraUp(0.0, time.x);\n    float cameraFocal     = cameraData.x;\n\n    vec3 direction = normalize(cameraRight * (fragCoord.x / screenSize.x * 2.0 - 1.0) / (screenSize.y / screenSize.x) \n                             + cameraUp * (fragCoord.y / screenSize.y * 2.0 - 1.0)\n                             + cameraForward * cameraFocal);\n\n    float totalDistance = 0.0;\n    vec3 step = cameraPosition;\n    MarchingResult result;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n    {\n        step = cameraPosition + totalDistance * direction;\n        result = SceneRendering(step, iChannel0);\n        totalDistance += result.distance;\n        if(result.distance <= epsilon || totalDistance > maxDistance) break;\n    }\n    \n    ComputeMaterial(fragColor, result, step, playerTransform.xyz, totalDistance, time);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// UI\n\nconst float crosshairSize = .003 * screenScale;\nconst float crosshairShotSize = .02 * screenScale;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x >= screenSize.x || fragCoord.y >= screenSize.y) discard;\n    \n    vec4 playerData = LoadValue(layoutPlayerData, iChannel0);\n    \n    vec2 uv = fragCoord / screenSize;\n    \n    fragColor = vec4(0,0,0,0);\n    \n    vec4 gunData = LoadValue(layoutPlayerGun, iChannel0);\n    \n    float crosshair = mix(crosshairShotSize, crosshairSize, pow(clamp((iTime - gunData.z) * 5.5, 0.0, 1.0), 1.0/2.2));\n    vec2 size = vec2(crosshair, crosshair * iResolution.x / iResolution.y);\n    \n    if(uv.x > .5 - size.x && uv.x < .5 + size.x\n    && uv.y > .5 - size.y && uv.y < .5 + size.y)\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    float hit = mix(.25, 1.0, clamp((iTime - playerData.w) * 10.0, 0.0, 1.0));\n    \n    fragColor += print_number(playerData.x, vec2(2,2), fragCoord.xy / 2.0 / screenScale * hit, false, 2);\n    fragColor += print_number(playerData.y, vec2(135,81), fragCoord.xy / 2.0 / screenScale, true, 5);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// https://www.shadertoy.com/view/ldfSW2\n\n#define NSPC 256\n\n#define pi2 6.283185307179586476925286766559\n\n// hard clipping distortion\nfloat dist(float s, float d)\n{ //https://www.shadertoy.com/view/ldfSW2\n\treturn clamp(s * d, -1.0, 1.0);\n}\nvec2 dist(vec2 s, float d)\n{\n\treturn clamp(s * d, -1.0, 1.0);\n}\n\n// quantize\nfloat quan(float s, float c)\n{\n\treturn floor(s / c) * c;\n}\n\n// my resonant lowpass filter's frequency response\nfloat _filter(float h, float cut, float res)\n{\n\tcut -= 20.0;\n\tfloat df = max(h - cut, 0.0), df2 = abs(h - cut);\n\treturn exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\n// hash\nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n\t//return fract(sin(x * 110.082) * 13485.8372);\n}\nfloat nse_slide(float x)\n{\n\tfloat fl = floor(x);\n\treturn mix(nse(fl), nse(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\n// note number to frequency\nfloat ntof(float n)\n{\n\treturn 440.0 * pow(2.0, (n - 69.0) / 12.0);\n}\n\n// tb303 core\nvec2 synth(float tseq, float t)\n{\n\tvec2 v = vec2(0.0);\n\t\n\tfloat tnote = fract(tseq);\n\tfloat dr = 0.26;\n\tfloat amp = smoothstep(0.05, 0.0, abs(tnote - dr - 0.05) - dr) * exp(tnote * -1.0);\n\tfloat seqn = nse(floor(tseq));\n\t//float seqn = nse_slide(tseq);\n\tfloat n = 20.0 + floor(seqn * 38.0);//50.0 + floor(time * 2.0);\n\tfloat f = ntof(n);\n\t\n    float sqr = smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n    \n\tfloat base = f;//50.0 + sin(sin(t * 0.1) * t) * 20.0;\n\tfloat flt = exp(tnote * -1.5) * 50.0 + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n\tfor(int i = 0; i < NSPC; i ++)\n\t{\n\t\tfloat h = float(i + 1);\n\t\tfloat inten = 1.0 / h;\n\t\t//inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\t\t\n\t\tinten = mix(inten, inten * mod(h, 2.0), sqr);\n\t\t\n\t\tinten *= exp(-1.0 * max(2.0 - h, 0.0));// + exp(abs(h - flt) * -2.0) * 8.0;\n\t\t\n\t\tinten *= _filter(h, flt, 4.0);\n\t\t\n\t\t\n\t\tv.x += inten * sin((pi2 + 0.01) * (t * base * h));\n\t\tv.y += inten * sin(pi2 * (t * base * h));\n\t}\n\t\n\t\n\tfloat o = v.x * amp;//exp(max(tnote - 0.3, 0.0) * -5.0);\n\t\n\t//o = dist(o, 2.5);\n\t\n\treturn vec2(dist(v * amp, 2.0));\n}\n\n// heavy 909-ish bassdrum\nfloat kick(float tb, float time)\n{\n\ttb = fract(tb / 4.0) * 0.5;\n\tfloat aa = 5.0;\n\ttb = sqrt(tb * aa) / aa;\n\t\n\tfloat amp = exp(max(tb - 0.15, 0.0) * -10.0);\n\tfloat v = sin(tb * 100.0 * pi2) * amp;\n\tv = dist(v, 4.0) * amp;\n\tv += nse(quan(tb, 0.001)) * nse(quan(tb, 0.00001)) * exp(tb * -20.0) * 2.5;\n\treturn v;\n}\n\n// 909-ish open hihat\nfloat hat(float tb)\n{\n\ttb = fract(tb / 4.0) * 0.5;\n\tfloat aa = 4.0;\n\t//tb = sqrt(tb * aa) / aa;\n\treturn nse(sin(tb * 4000.0) * 0.0001) * smoothstep(0.0, 0.01, tb - 0.25) * exp(tb * -5.0);\n}\n\nfloat gate1(float t)\n{\n\t#define stp 0.0625\n\tfloat v;\n\tv = abs(t - 0.00 - 0.015) - 0.015;\n\tv = min(v, abs(t - stp*1. - 0.015) - 0.015);\n\tv = min(v, abs(t - stp*2. - 0.015) - 0.015);\n\tv = min(v, abs(t - stp*4. - 0.015) - 0.015);\n\tv = min(v, abs(t - stp*6. - 0.015) - 0.015);\n\tv = min(v, abs(t - stp*8. - 0.05) - 0.05);\n\tv = min(v, abs(t - stp*11. - 0.05) - 0.05);\n\tv = min(v, abs(t - stp*14. - 0.05) - 0.05);\n\t\n\treturn smoothstep(0.001, 0.0, v);\n}\n\n//// \n\nfloat Square(float x)\n{\n    return sign(sin(x));\n}\n\nfloat instrument(float freq, float time, float release)\n{\n    freq = 440.0*pow(freq/440.0,1.003); // spread\n    \n    float ph = 1.0;\n    ph *= sin(6.2831*freq*time);\n    ph *= 0.2+0.8*max(0.0,6.0-0.01*freq);\n    ph *= exp(-time*freq*0.2);\n    \n    float y = 0.0;\n    y += 0.70*Square(1.00*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n    y += 0.20*Square(2.01*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n    y += 0.20*Square(3.01*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n    y += 0.16*Square(4.01*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n    y += 0.13*Square(5.01*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n    y += 0.10*Square(6.01*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n    y += 0.09*Square(8.01*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n    y += 0.07*Square(9.01*6.2831*freq*time+ph)*exp(-0.5*release*freq*time);\n\n    y += 0.45*y*y*y;\n       \n    y *= 1.0 + 1.5*exp(-8.0*time);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\n    y *= 2.5-1.5*clamp( log2(freq)/10.0,0.0,1.0);\n\treturn y;\t\n}\n\nfloat Music(float time)\n{\n    float music = instrument(50.0, time, .05);\n    music += kick(mod(time * 9.0, 16.0), time) * .65;\n    music += hat(mod(time * 4.5, 16.0) - 5.0);\n    music += hat(mod(time * 4.5, 16.0) - 4.0);\n    music += instrument( 6.0, mod(time * 9.0, 16.0), .07) * .15;\n    music += instrument( 9.0, mod(time * 9.0, 16.0), .07) * .15;\n    music += instrument(13.0, mod(time * 9.0, 64.0), .07) * .15;\n    music += instrument(17.0, mod(time * 9.0, 64.0), .07) * .15;\n    return music;\n}\n\nfloat Effects(float time)\n{\n    float effects = 0.0;\n    return effects;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float music = Music(time);\n    float effects = Effects(time);\n    return vec2(music + effects) * clamp(time / 4.0, 0.0, 1.0);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Weapon\n\nMarchingResult Weapon(vec3 step, vec4 playerTransform, vec3 playerForward, vec3 playerUp, vec3 playerRight, vec4 time, float lastShot)\n{\n    float lastShotLerp = clamp((time.x - lastShot) * 1.4, 0.0, 1.0);\n    \n    step -= playerTransform.xyz;\n    step -= playerForward * 4.0;\n    step -= playerRight * 2.0;\n    step += playerUp * (1.6 + sin(time.x * 3.0) * .1);\n    Rotate(step.xz, playerTransform.w + pi * .5);\n    Rotate(step.yz, -0.3);\n    MarchingResult result = Box(step, vec3(.6, .5, .1), 0);\n    vec3 armStep = step;\n    Rotate(armStep.yz, -.5);\n    result = UnionSoft(result, Box(armStep + vec3(0,1.2,0.25), vec3(.4, 1, .2), 0), .3);\n\n    for(float i = 0.0; i < 3.0; ++i)\n    {\n        vec3 localStep = step - vec3(-0.5 + i * .5, 0, 0);\n        for(float j = 0.0; j < 2.0; ++j)\n        {\n            localStep.y -= 0.4;\n            Rotate(localStep.zy, mix(-0.5, mix(.4, .75, sin(time.x* 2.0) * .5 + .5), lastShotLerp));\n            Rotate(localStep.xy, (0.5 - i * .5) * .3);\n            localStep.y -= 0.4;\n            result = UnionSoft(result, Box(localStep, vec3(0.1, .4, 0.1), 0), .25);\n        }\n    }\n    \n    vec3 localStep = step;\n    localStep += playerForward * .25;\n    localStep += playerUp * .4;\n    Rotate(localStep.xy, -pi * .5);\n    for(float i = 0.0; i < 2.0; ++i)\n    {\n        localStep.y -= 0.3;\n        Rotate(localStep.zy, mix(-0.5, mix(.5, .75, sin(time.x* 2.0) * .5 + .5), lastShotLerp));\n        localStep.y -= 0.3;\n        result = UnionSoft(result, Box(localStep, vec3(0.1, .3, 0.1), 0), i == 0.0 ? .5 : .2);\n    }\n\n    return result;\n}\n\nMarchingResult Scene(vec3 step, vec4 playerTransform, vec3 playerForward, vec3 playerUp, vec3 playerRight, vec4 time, float lastShot)\n{\n    MarchingResult result = Weapon(step, playerTransform, playerForward, playerUp, playerRight, time, lastShot);\n    return result;\n}\n\nvec3 ComputeNormal(vec3 p, float normalEpsilon, vec4 playerTransform, vec3 playerForward, vec3 playerUp, vec3 playerRight, vec4 time, float lastShot)\n{\n   return normalize(vec3(Scene(p + vec3(normalEpsilon, 0.0, 0.0), playerTransform, playerForward, playerUp, playerRight, time, lastShot).distance - Scene(p + vec3(-normalEpsilon, 0.0, 0.0), playerTransform, playerForward, playerUp, playerRight, time, lastShot).distance,\n                         Scene(p + vec3(0.0, normalEpsilon, 0.0), playerTransform, playerForward, playerUp, playerRight, time, lastShot).distance - Scene(p + vec3(0.0, -normalEpsilon, 0.0), playerTransform, playerForward, playerUp, playerRight, time, lastShot).distance,\n                         Scene(p + vec3(0.0, 0.0, normalEpsilon), playerTransform, playerForward, playerUp, playerRight, time, lastShot).distance - Scene(p + vec3(0.0, 0.0, -normalEpsilon), playerTransform, playerForward, playerUp, playerRight, time, lastShot).distance));\n}\n\nvoid ComputeMaterial(out vec4 fragColor, MarchingResult result, vec3 position, float distance, vec4 time, vec4 playerTransform, vec3 playerForward, vec3 playerUp, vec3 playerRight, float lastShot)\n{\n    int index = result.index/100;\n\n    vec3 normal = ComputeNormal(position, 0.001, playerTransform, playerForward, playerUp, playerRight, time, lastShot);\n    vec3 directionalLight = GetDirectionalLight(normal);\n    vec3 rayLight = GetRayLight(position, time, iChannel0);\n    vec3 light = vec3(.3,.3,.3) + directionalLight * .5 + rayLight;\n\n    fragColor = vec4(light, 1) * vec4(250.0/255.0, 243.0/255.0, 221.0/255.0, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(fragCoord.x >= screenSize.x || fragCoord.y >= screenSize.y) discard;\n    \n\tvec4  time = vec4(iTime, 1, 0, 0); // LoadValue(layoutTime, iChannel0);\n    vec4  playerTransform = LoadValue(layoutPlayerTransform, iChannel0);\n    vec4  cameraData \t  = LoadValue(layoutPlayerCamera, iChannel0);\n    vec3  cameraPosition  = playerTransform.xyz;\n    vec3  cameraForward   = GetCameraForward(playerTransform.w, cameraData.y, time.x);\n    vec3  cameraRight     = GetCameraRight(playerTransform.w, cameraData.y, time.x);\n    vec3  cameraUp        = GetCameraUp(0.0, time.x);\n    float cameraFocal     = cameraData.x;\n\n    vec3 direction = normalize(cameraRight * (fragCoord.x / screenSize.x * 2.0 - 1.0) / (screenSize.y / screenSize.x) \n                             + cameraUp * (fragCoord.y / screenSize.y * 2.0 - 1.0)\n                             + cameraForward * cameraFocal);\n\n    float totalDistance = 0.0;\n    vec3 step = cameraPosition;\n    MarchingResult result;\n    \n    float lastShot = LoadValue(layoutPlayerGun, iChannel0).z;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n    {\n        step = cameraPosition + totalDistance * direction;\n        result = Scene(step, playerTransform, cameraForward, cameraUp, cameraRight, time, lastShot);\n        totalDistance += result.distance;\n        if(result.distance <= epsilon || totalDistance > maxDistance) break;\n    }\n    \n    if(result.distance <= epsilon)\n    ComputeMaterial(fragColor, result, step, totalDistance, time, playerTransform, cameraForward, cameraUp, cameraRight, lastShot);\n    else fragColor = vec4(0,0,0,0);\n}","name":"Buffer D","description":"","type":"buffer"}]}