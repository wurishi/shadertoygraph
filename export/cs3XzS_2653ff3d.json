{"ver":"0.1","info":{"id":"cs3XzS","date":"1681879940","viewed":2286,"name":"2D GI Test 2","username":"krisp","description":"Improved 2d path tracing with bidir, and interleaved gradient noise","likes":71,"published":1,"flags":0,"usePreview":0,"tags":["2d","raytracing","gi","globalillumination","bidirectional","interleavedgradientnoise","ign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define samples 8\n\n#define pi 3.1415926535\n\n// Scene definition is kinda inspired by .obj file formatting but idk if I'll keep it\n\nvec3 materials[] = vec3[](\nvec3(1.000,1.000,1.000),    // white\nvec3(1.000,0.067,0.157),    // red\nvec3(0.027,0.945,0.259),    // green\nvec3(0.118,0.253,0.992));   // blue\n\nvec2 points[] = vec2[](\nvec2(.1,-.25), \nvec2(.3,-.25), \nvec2(.1,-.05),\nvec2(.3,-.05), \nvec2(-.9,-.4), \nvec2(.8,-.4),  \nvec2(-.9,-1.), \nvec2(.8,1.),   \nvec2(-.4,-.3), \nvec2(-.2,-.3), \nvec2(-.4,-.1), \nvec2(-.2,-.1),\nvec2(-.05,-.05),\nvec2(-.05,-.15),\nvec2(0,-.1),\nvec2(-.1,-.1));\n\nint segmentCount = 15;\nivec3 segments[] = ivec3[](\nivec3(0,1,1),   // ivec3(a,b,c)\nivec3(0,2,1),   // a = endpoint a index\nivec3(1,3,1),   // b = endpoint b index\nivec3(2,3,1),   // c = material index\nivec3(4,5,0),\nivec3(4,6,0),\nivec3(5,7,0),\nivec3(8,9,3),\nivec3(8,10,3),\nivec3(9,11,3),\nivec3(10,11,3),\nivec3(12,14,2),\nivec3(14,13,2),\nivec3(13,15,2),\nivec3(15,12,2));\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Interleaved gradient noise\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat IGN(ivec2 p) {\n    return mod(52.9829189f * mod(.06711056f*float(p.x) + .00583715f*float(p.y), 1.), 1.);\n}\n\n// Ray intersection with line segment\nfloat segmentIntersect(vec2 ro, vec2 rd, vec2 a, vec2 b) {\n        vec2 v1 = ro - a;\n        vec2 v2 = b - a;\n        vec2 v3 = vec2(-rd.y, rd.x);\n\n        float d = dot(v2, v3);\n        float t1 = cross(vec3(v2,0), vec3(v1,0)).z / d;\n        float t2 = dot(v1, v3) / d;\n\n        if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0)) {\n            return t1;\n        }\n        return 1000.;\n}\n\n//ray intersection with scene\n//sceneIntersect.w is the distance, sceneIntersect.xyz is the color\nvec4 sceneIntersect(vec2 ro, vec2 rd) {\n    float v0 = 1000.;\n    vec3 col;\n\n    for(int i=0; i<segmentCount; i++) {\n\n        vec2 a = points[segments[i].x];\n        vec2 b = points[segments[i].y];\n        \n        float v1 = segmentIntersect(ro, rd, a, b);\n        if(v1<v0) {\n            col = materials[segments[i].z];\n            v0 = v1;\n        }\n    }\n    return vec4(col,v0);\n}\n\n//line segment SDF\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n//scene SDF\n//sceneDist.w is the distance, sceneDist.xyz is the color\nvec4 sceneDist(vec2 p) {\n    float v0 = 1000.;\n    vec3 col;\n\n    for(int i=0; i<segmentCount; i++) {\n\n        vec2 a = points[segments[i].x];\n        vec2 b = points[segments[i].y];\n        \n        float v1 = line(p, a, b);\n        if(v1<v0) {       \n            col = materials[segments[i].z];\n            v0 = v1;\n        }\n    }\n    return vec4(col,v0);\n}\n\nvec2 sceneNormal(vec2 p) {\n    vec2 epsilon = vec2(.001, -.001);\n    return normalize(vec2(sceneDist(p+epsilon.xx).w) - vec2(sceneDist(p-epsilon.xy).w,sceneDist(p-epsilon.yx).w));\n}\n\n// ACES Tonemapping\nvec3 ACESFilm(vec3 x) {\n\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n#define lightFalloff 2.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 col;\n    vec2 p = (2.*fragCoord-iResolution.xy-.5)/iResolution.x;\n    float rand = IGN(ivec2(fragCoord.xy));\n    \n    vec3 spot;\n    vec3 gi;\n    \n    vec2 lightPos = vec2(sin(iTime*.5)*.75,cos(iTime*.25)*.25+.25);\n\n    vec2 lightDir = normalize(vec2(sin(iTime*1.5),-1));\n    if (iMouse.z > 0.){\n        lightPos = vec2(2,-2)*iMouse.zw/iResolution.x-vec2(1.,.56);\n        lightDir = normalize(2.*iMouse.xy/iResolution.x-vec2(1.,.561)-lightPos);\n    }\n    float lightRad = .005;\n    \n    if (sceneIntersect(p, normalize(lightPos-p)).w > distance(p,lightPos)) {\n        spot = vec3(max((.5*float(dot(normalize(p-lightPos),lightDir))-.5)/lightRad+1.,0. ));\n    }\n    \n    vec2 hit;\n    for (int i=0; i<samples; i++) {\n        vec2 ro = lightPos;\n        float rot = .08*pi*((float(i)+rand)/float(samples)-.5) + atan(lightDir.y,lightDir.x);\n        vec2 rd = vec2(cos(rot),sin(rot));\n        vec2 lightDirSampled = rd;\n        \n        float d = sceneIntersect(ro, rd).w;\n        hit = ro + rd*d;\n        vec2 nor = sceneNormal(hit - rd*.01);\n        \n        ro = p;\n        rd = normalize(hit-p);\n        \n        // Circle arc for bounce light falloff just beause I thought it looked better than inverse square law :p\n        float hitDist = min(distance(p,hit)/lightFalloff,1.);\n        \n        vec4 lightRay = sceneIntersect(ro, rd);\n        d = lightRay.w;\n        \n        if (d + .01 > distance(p,hit)) {\n            gi += 1./float(samples) * lightRay.rgb * clamp(dot(-rd,nor),0.,1.) * ( 1.-sqrt(2.*hitDist-hitDist*hitDist) )\n            * (sceneDist(p).w > .0025 ? 1. : dot(sceneNormal(p),lightDirSampled)*.5+.5 );\n        }\n    }\n    \n    vec4 scene = sceneDist(p);\n    col = spot*.5 + gi*1.;\n    col *= scene.w > .0025 ? vec3(.25) : 3.*scene.rgb;\n    \n    // Tonemapping\n    \n    col = ACESFilm(col);\n    col = pow(col,vec3(1./2.2));\n    \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}