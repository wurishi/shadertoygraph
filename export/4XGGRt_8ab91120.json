{"ver":"0.1","info":{"id":"4XGGRt","date":"1718035020","viewed":23,"name":"gloopy asteroids 2","username":"milesd","description":"another shader assisted by chatgpt","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","asteroids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Infinite zoom through 3D shapes\n\n// Function to create a Perlin noise pattern\nfloat hash(vec3 p) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix(hash(i + vec3(0.0, 0.0, 0.0)), \n                        hash(i + vec3(1.0, 0.0, 0.0)), f.x),\n                   mix(hash(i + vec3(0.0, 1.0, 0.0)), \n                        hash(i + vec3(1.0, 1.0, 0.0)), f.x), f.y),\n               mix(mix(hash(i + vec3(0.0, 0.0, 1.0)), \n                        hash(i + vec3(1.0, 0.0, 1.0)), f.x),\n                   mix(hash(i + vec3(0.0, 1.0, 1.0)), \n                        hash(i + vec3(1.0, 1.0, 1.0)), f.x), f.y), f.z);\n}\n\n// Rotation matrix around the Y-axis\nmat3 rotationY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\n// Rotation matrix around the X-axis\nmat3 rotationX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Time variable for animation\n    float time = iTime * 0.4;\n    \n    // Camera position with weaving effect\n    vec3 ro = vec3(sin(time) * 2.0, cos(time) * 2.0, -2.0 + time);\n    \n    // Camera direction with tilting effect\n    vec3 target = vec3(0.0, 0.0, 1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    // Apply rotation to direction based on time\n    float turnAngle = 0.5 * sin(time);\n    float tiltAngle = 0.25 * cos(time);\n    mat3 turnRotation = rotationY(turnAngle);\n    mat3 tiltRotation = rotationX(tiltAngle);\n    rd = tiltRotation * turnRotation * rd;\n    \n    // Ray marching loop\n    float t = 0.0;\n    float maxDist = 50.0; // Maximum distance to march\n    float minDist = 0.01; // Minimum distance threshold\n    float scale = 5.0 + sin(time * 0.015) * 2.0;\n    float heightMap = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = ro + t * rd;\n\n        // Compute height map based on Perlin noise pattern\n        heightMap = 0.5 * noise(p * scale);\n        p += heightMap * normalize(p);\n\n        float d = length(mod(p, 2.0) - 1.0) - 0.4;\n        if (d < minDist || t > maxDist) break;\n        t += d * 0.9;\n    }\n    \n    // Generate color shift value\n    float value = 0.75 + 0.25 * sin(iTime);\n\n    // Compute color based on position\n    vec3 pos = ro + t * rd;\n    float c = noise(pos * scale);\n    vec3 sphereColor = mix(vec3(value, 0.5, 0.3), vec3(0.0), c);\n    \n    // Alter color based on bumpiness\n    sphereColor *= 1.0 + heightMap*0.1;\n    \n    // Lighten color based on bumpiness\n    vec3 lightColor = mix(sphereColor, vec3(1.0, 1.0, 1.0),  heightMap* 0.5);\n    \n    // Sky color\n    vec3 skyColor = vec3(0.7, 0.7, 0.9); // Light blue\n    \n    // Fade to sky color based on distance\n    float fade = exp(-t * 0.1);\n    vec3 finalColor = mix(skyColor, lightColor, fade);\n    \n    // Output the final color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}