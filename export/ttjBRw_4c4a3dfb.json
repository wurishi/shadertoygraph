{"ver":"0.1","info":{"id":"ttjBRw","date":"1599239552","viewed":220,"name":"Julia set pathtracing","username":"athibaul","description":"Combination of a pathtracer with a Julia set raymarcher.\nTODO: Use Multiple Importance Sampling to reduce noise and be able to use smaller lights.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["julia","mandelbrot","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    fragColor.rgb = texture(iChannel2, fragCoord.xy/iResolution.xy).rgb;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ITER 200\n#define SAMPLES 1\n#define BOUNCES 5\n#define STEPS 50\n\n// Complex number operations\nvec2 cmul( vec2 a, vec2 b )\n{\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); \n}\n\nvec2 cpow( vec2 a, float p )\n{\n    float rho = pow(length(a), p), theta = atan(a.y, a.x)*p;\n    return rho * vec2(cos(theta), sin(theta));\n}\n\n\n// Hash function by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n/*\nvec4 hash44(vec4 p4)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n*/\n\nint rand_num = 0;\nvec3 randomInHemisphere( vec3 n )\n{\n    // Pick a random vector in the half-sphere \n    // whose dot product with n is positive.\n    vec3 v;\n    for(int i=0;i<5;i++)\n    {\n        rand_num++;\n        v = hash31(float(rand_num)).xyz*2.-1.;\n        if(length(v) < 1.) break;\n    }\n    v /= length(v);\n    return v * sign(dot(v,n));\n}\n\n\nvec3 checker( in vec2 z )\n{\n    z *= 5.;\n    z -= floor(z);\n    return (z.x<0.5)!=(z.y<0.5) ? vec3(0.6) : vec3(0.9);\n}\n\nvec3 bands( in float v )\n{\n    v *= 5.; v -= floor(v);\n    return ((v<0.5)? 0.8:1.0) * vec3(0.9,0.6,0.2);\n}\n\nfloat juliaDistance( vec2 c, vec2 z )\n{\n    vec2 dz = vec2(1.);\n    //float dlz2 = 1.0;\n    float m2 = 1.0;\n    //vec2 z = vec2(0.);\n    int i;\n    for(i=0;i<ITER;i++)\n    {\n        // z = z*z + c except * is complex multiplication\n        dz = 2.*cmul(z,dz);\n        //dlz2 *= 4.0*m2;\n        z = cmul(z,z) + c;\n        m2 = dot(z,z);\n        if(m2>1e10) break;\n        //if(length(z)>1e5) break;\n    }\n    if(i >= ITER) return 0.;\n    //float G = log(length(z)) / pow(2., float(i));\n    float lz = sqrt(m2);\n    float d = lz*log(lz) / length(dz);\n    //float d = lz*log(lz) / sqrt(dlz2);\n    return d;\n}\n\nfloat map( vec3 p )\n{\n    vec2 c = vec2(0.28,-0.49);\n    float d = juliaDistance(c, p.xz) * 0.5;\n    d = max(d, p.y); // Cut at y=0\n    d = min(d, p.y+1.); // Back plane at y=-1\n    //d = max(d, -p.y-1.);\n    return d;\n}\n\nfloat worldIntersect( vec3 ro, vec3 rd )\n{\n    float d, t=0.;\n    vec3 p;\n    float horizlength = length(rd.xz);\n    // If we are above 0, walk all the way to y=0\n    if(ro.y > 0. && rd.y < 0.)\n        t -= ro.y/rd.y;\n    for(int i=0; i<STEPS; i++)\n    {\n        p = ro + t*rd;\n        // We know the object is entirely below y=0\n        if(p.y > 0. && rd.y > 0.) return -1.;\n        d = map(p);\n        if( d < 1e-4 ) break;\n        // We know the object depends only on x and z, \n        // so we can walk farther\n        t += d / horizlength;\n    }\n    // Don't go farther than the back plane\n    float tmax = -(ro.y+1.)/rd.y;\n    if(tmax > 0. && t > min(tmax, 5.)) return tmax;\n    return (t<5.)? t : -1.;\n}\n\nvec3 normal( vec3 p )\n{\n    vec2 e = 1e-4 * vec2(1.,-1.);\n    return normalize(\n        e.xxx * map(p + e.xxx) +\n        e.xyy * map(p + e.xyy) +\n        e.yxy * map(p + e.yxy) +\n        e.yyx * map(p + e.yyx)\n    );\n}\n\nvec3 worldGetColor( vec3 p )\n{\n    // Surface color at p\n    if(p.y > -0.99) return vec3(0.9,0.85,0.8);\n    return pow(texture(iChannel3, p.xz/4.).rgb, vec3(0.5));\n}\n\n\nconst float sunAngle = 1.0;\nconst float sunRelativeSolidAngle = pow(sin(sunAngle/2.),2.);\nconst vec3 sunPos = normalize(vec3(0., 1., 1.));\nconst vec3 sunRight = normalize(cross(sunPos, vec3(0.0,1.0,0.0)));\nconst vec3 sunUp = cross(sunRight, sunPos);\nvec3 skyColor( vec3 rd )\n{\n    //return texture(iChannel0, rd).rgb;\n    float factor = 0.5/sunRelativeSolidAngle;\n    \n    return dot(rd, sunPos) > cos(sunAngle) ? vec3(factor) : vec3(0.0);\n}\n\n// Several techniques are available to compute a Monte-Carlo estimate\n// We can either sample the BSDF, or the light source\n// Those different techniques are described in\n// https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf\n\nvec3 sampleLightSource( in vec3 n, inout float probability )\n{\n    rand_num++;\n    vec2 q = hash31(float(rand_num)).xy;\n    float theta = q.x*sunAngle, phi = q.y*2.*3.14159;\n    vec3 dir = cos(theta)*sunPos + sin(theta)*(cos(phi)*sunRight+sin(phi)*sunUp);\n    probability *= sin(theta) * step(0.0, dot(dir, n))/(4.*3.1416);\n    return dir;\n}\n\nvec3 sampleBSDF( in vec3 n, inout float probability )\n{\n    probability *= 1.0;\n    return randomInHemisphere(n);\n}\n\n\nvec3 chooseRayDirection( in vec3 n, inout float probability )\n{\n    // This might be a correct way to combine our different estimators\n    // but it is very likely that there are errors in there.\n    // Also, it would be better to use Multiple Importance Sampling to weigh\n    // correctly the results of the different samples.\n    rand_num++;\n    if(hash31(float(rand_num)).x < 0.5)\n    {\n        probability /= 0.5;\n        return sampleBSDF(n, probability);\n    }\n    else\n    {\n        probability /= 0.5;\n        return sampleLightSource(n, probability);\n    }\n}\n\nvec4 computeRayColor( vec3 ro, vec3 rd )\n{\n    vec3 col = vec3(1.);\n    float probability = 1.;\n    for(int i=0; i<BOUNCES; i++)\n    {\n        float d = worldIntersect(ro, rd);\n        if(d < 0.) break;\n        vec3 p = ro + d*rd;\n        vec3 n = normal(p);\n        // Sample a Lambertian diffuse BRDF, to go to the next ray\n        col *= worldGetColor(p);\n        rd = chooseRayDirection(n, probability);\n        ro = p + 0.01*rd;\n    }\n    col = col * skyColor(rd);\n    return vec4(col, probability);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rand_num += iFrame;\n    rand_num += int(1024.*texelFetch(iChannel1, ivec2(mod(fragCoord,1024.)), 0));\n    //z = cpow(z, 1./float(1<<ITER));\n    \n    //float d = juliaDistance(c, z);\n    \n    /*\n    vec3 col;\n    if(d <= 0.)\n    {\n        col = vec3(1.);\n    }\n    else\n    {\n    \tcol = bands(d*5.);\t\n    }\n\t*/\n    \n    /*vec3 ro = vec3(z.x, 0.0, z.y);\n    ro.xz = ro.zx;\n    vec3 rd = normalize(vec3(z.x, -1.0, 0.3+2.*z.y));\n    rd.xz = rd.zx;\n    rd.xz *= mat2(0.6,0.8,-0.8,0.6);\n\t*/\n    vec3 ro = vec3(2.0, 0.8, -0.8);\n    vec3 fwd = normalize(vec3(0.0,-0.5,0.0)-ro);\n    vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, fwd);\n    float fov = 0.4;\n    \n    vec3 col = vec3(0.);\n    float probability = 0.;\n    for(int i=0; i<SAMPLES; i++)\n    {\n        vec2 coo = fragCoord;\n        // Antialiasing: jitter samples inside pixel\n        coo += hash31(float(i+SAMPLES*iFrame)).xy;\n        vec2 z = 1.1*(2.*coo - iResolution.xy)/iResolution.y;\n        vec3 rd = normalize(fwd + fov*(z.x*right+z.y*up));\n        vec4 res = computeRayColor(ro, rd);\n        col += res.rgb * res.a;\n        probability += res.a;\n    }\n    if(probability > 0.)\n    \tcol /= probability;\n\t\n    \n    //float d = worldIntersect(ro, rd);\n    //col = vec3(0.3*d);\n    //vec3 p = ro+d*rd;\n    //vec3 col = 0.5*(1.+normal(p));\n    \n    \n    /*\n\t// Test validity of function randomInHemisphere\n    vec3 col = vec3(0.);\n    for(int i=0;i<SAMPLES;i++){\n        col += randomInHemisphere(vec3(1.,0.,0.))/float(SAMPLES); \n        col += randomInHemisphere(vec3(-1.,0.,0.))/float(SAMPLES); \n    }\n    //col = 0.5*(1.+col);\n   \t//col = 5.*abs(col-0.5);\n\t*/\n    \n    \n    \n    \n    \n    //vec3 rd = normalize(vec3(z.x, -1.0, z.y));\n    //col = texture(iChannel0, rd).xyz;\n\n    vec4 prev = texelFetch(iChannel2, ivec2(fragCoord), 0).rgba;\n    if(prev.a > 0.){\n    \tfloat a = probability / (probability + prev.a);\n    \tcol = col*a + prev.rgb * (1.-a);\n    \tprobability += prev.a;\n    }\n    \n    fragColor = vec4(col,probability);\n}","name":"Buffer A","description":"","type":"buffer"}]}