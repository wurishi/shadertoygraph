{"ver":"0.1","info":{"id":"4cKGWG","date":"1713210604","viewed":69,"name":"Mandelbulbie","username":"leftonred","description":"I encourage you to play around with the variables. Based on your system fps could be drop.\n\nfew years ago i couldn't even imagine how people can draw something like this. Now i'm part of this amazing community!.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbulb","abstract","3dfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 1.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265359;\n\n\n\nfloat mandelbulb_power = 10.;\nconst int mandelbulb_iter_num = 64;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat mandelbulb_sdf(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < mandelbulb_iter_num ; i++)\n\t{\n\t\tr = length(z);\n\t\tif (r>1.5) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n\n\t\tdr =  pow( r, mandelbulb_power-1.0)*mandelbulb_power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,mandelbulb_power);\n\t\ttheta = theta*mandelbulb_power;\n\t\tphi = phi*mandelbulb_power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = pos + zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t}\n\treturn 0.35*log(r)*r/dr;\n}\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return mandelbulb_sdf(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, out float steps) {\n    \n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        steps ++;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 calculateNormal(vec3 p) {\n    vec3 eps = vec3(EPSILON, 0.0, 0.0);\n    float nx = sceneSDF(p + eps.xyy) - sceneSDF(p - eps.xyy);\n    float ny = sceneSDF(p + eps.yxy) - sceneSDF(p - eps.yxy);\n    float nz = sceneSDF(p + eps.yyx) - sceneSDF(p - eps.yyx);\n    return normalize(vec3(nx, ny, nz));\n}\n\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float minMandelbulbPower = 1.5;\n    float maxMandelbulbPower = 8.0;\n    \n   \n\n    mandelbulb_power = minMandelbulbPower + \n        0.5 * (maxMandelbulbPower - minMandelbulbPower) * (sin(iTime / 7.0) + 1.0);\n    \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n\n    vec3 lp = vec3(0, 0.5, -4); \n      \n    vec3 eye = vec3(0, 1.5, -10.);\n      \n      \n      \n    float cameraRadius = 7.;\n    \n\n\n    \n            \n    eye.x = cameraRadius * cos(iTime / 7.) + lp.x;\n    eye.z = cameraRadius * sin(iTime / 7.) + lp.z; \n    eye.y = cameraRadius * cos(iTime / 7.) + lp.y;\n\n    vec3 dir = camera(eye, lp) * normalize(vec3(uv, -1)); // ray direction\n      \n      \n    \n    float steps = 0.;\n    \n\n    \n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST, steps);\n    \n    vec3 normal = calculateNormal(eye + dist * dir);\n\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.94, 0.95, 0.98, 0.0);\n\t\treturn;\n    }\n    \n    \n    float minAO = 0.; \n    float maxAO = 1.0; \n    \n\n    vec3 aoColor = vec3(0.50,0.17,0.80);\n\n    float ao = steps * 0.008;\n\tao = 1. - ao / (ao + 1.0);  // reinhard\n    ao = pow(ao, 2.);\n    ao = clamp(ao, minAO, maxAO);\n    float t = fract(iTime);\n    if(ao > steps * 0.01)\n    {\n        aoColor = vec3(0.98,0.98,0.93);\n    }\n    if(ao > steps * 0.045)\n    {\n        aoColor = vec3(1.,0.79,0.08);\n    }\n    \n    \n\n    vec3 coloredAO = aoColor * ao;\n\n    fragColor = vec4(vec3(coloredAO), 1.0);\n}","name":"Image","description":"","type":"image"}]}