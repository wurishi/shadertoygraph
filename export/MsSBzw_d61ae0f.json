{"ver":"0.1","info":{"id":"MsSBzw","date":"1499874525","viewed":186,"name":"polka dots - tbos","username":"nckrlf","description":"one of the exercises from chapter 9 of The Book of Shaders. I swear I didn't look at their solution until after I finished! I like my solution better anyway :p","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","dots","thebookofshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @nckrlf\n\nfloat circle(vec2 _st, float _size, float _smooth)\n{\n    float r = distance(_st, vec2(0.5));\n    float result = smoothstep(_size+_smooth, _size, r);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    fragColor = vec4(1.0, 0.0, 0.5, 1.0);\n\n    // tile\n    int N = 6;\n    st *= float(N);\n\n    // dx should be +/- 1.0 for alternating rows\n    float dx = step(1.0, mod(st.y, 2.0)) * 2.0 - 1.0;\n    // every other second dx should be 0.0\n    dx *= step(1.0, mod(iTime, 2.0));\n\tst.x += dx * fract(iTime);\n\n    // dy should act similarly to dx, but for columns\n    float dy = step(1.0, mod(st.x, 2.0)) * 2.0 - 1.0;\n    // add 1 to the time so dy is 0 when dx is non-zero and vice-versa.\n    dy *= step(1.0, mod(1.0+iTime, 2.0));\n    st.y += dy * fract(iTime);\n\n    st = fract(st);\n\n    float d = circle(st, 0.3, float(N) * 0.005);\n    vec3 color = vec3(1.0, 0.3, 0.6) * vec3(d);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}