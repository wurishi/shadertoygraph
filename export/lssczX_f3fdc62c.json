{"ver":"0.1","info":{"id":"lssczX","date":"1489216140","viewed":134,"name":"Space Popcorn","username":"kp1197","description":"my first attempt at raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nvec4 _texture(vec3 pos, float material)\n{\n    \n    if (material==0.) // ball\n    {\n    \tvec4 col = 0.9+0.4*textureLod(iChannel0, (0.1*(pos).xy + 0.1*(pos).yz * 0.1*pos.zx), 0.0);\n        return col * col;\n    }\n    else if (material==1.) // ground\n    {\n        return textureLod(iChannel1, (0.1*pos.xy + 0.1*pos.yz + vec2(0.0,time)), 0.0) + vec4(0.0,sin(time),1.0,0.0);\n    }\n    else if (material == 2.) // sky\n    {\n        return 0.5*textureLod(iChannel2, 0.01*time + 0.002*pos.xy, 0.0) + 0.5*textureLod(iChannel1, 0.1*time+0.003*pos.yx, 0.0);\n    }\n    else // default\n    {\n        return vec4(0.);\n    }\n}\n\nvec3 sphereCenter()\n{\n  return vec3(cos(-time), mod(3.*-time,30.)-20., sin(-time)+5.);   \n}\n\nvec3 lightPos()\n{\n    return vec3(sin(time),0.,1.);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 world_dist(vec3 pos)\n{\n    vec3 c = sphereCenter();\n    vec3 rel_pos = pos - c;\n    float spherecenterdist = length(rel_pos);\n    float displacement = 0.2*length(_texture(pos,1.));\n    float heightfield = pos.y + 1.0 + 0.2*sin(5.*spherecenterdist) / spherecenterdist + displacement;\n    float spheredisplacement = 0.5*length(sin(2.0*time) + _texture(1.*rel_pos,0.));\n    float spheredist = spherecenterdist - spheredisplacement;\n    float dist = smin(heightfield,spheredist,2.9);\n    float mat = heightfield < spheredist ? 1. : 0.;\n    return vec2(dist,mat);\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 e = vec3(0.0001,0.0,0.0);\n    float d1 = world_dist(pos+e.xyz).x - world_dist(pos-e.xyz).x;\n    float d2 = world_dist(pos+e.yxz).x - world_dist(pos-e.yxz).x;\n    float d3 = world_dist(pos+e.yzx).x - world_dist(pos-e.yzx).x;\n    return normalize(vec3(d1,d2,d3));\n}\n\nvoid rayMarch(vec3 r, vec2 uv, out vec4 fragColor)\n{\n    // distance to object + material of closest object\n    vec2 _d = world_dist(r);\n    \n    // distance from camera focal point\n    float d = 1.0;\n    \n    vec3 rayPos = r * d;\n    \n    // march\n    for(int march = 0; march <= 128; march++)\n    {\n        // if more than 20 units from camera...\n        if (d > 20.)\n        {\n            // sky\n            fragColor = _texture(vec3(uv,0.),1.);\n            return;\n        }\n        \n        // if less than eps units from object\n        if (_d.x < 0.05)\n        {\n            // calculate illumination\n            vec3 lightWorldVec = lightPos()-(rayPos);\n            float lightDist = length(lightWorldVec);\n            float brightness = 0.5 + (0.25/lightDist) * dot(normal(rayPos),lightWorldVec);\n            vec3 relPos = rayPos - sphereCenter();\n            float distFromSphere = length(relPos);\n            \n            if (_d.y == 0.)\n            {\n                fragColor = brightness * _texture(relPos,_d.y);\n            }\n            else\n            {\n                float _mix = 1./length(distFromSphere);\n                fragColor =_mix + brightness * _texture(rayPos, _d.y) + _mix*_mix*_texture(relPos,2.);\n            }\n            \n            // sample the material of the closest object\n            \n            return;\n        }\n        \n        // otherwise, recalculate distance to closest object\n        _d = world_dist(rayPos);\n        \n        // move ray to \n\t\td += 0.7*_d.x;\n        rayPos = r * d;\n    }\n    fragColor.x = 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y) - vec2(0.5 * (iResolution.x/iResolution.y), 0.5);\n    vec3 r = normalize(vec3(uv, 1.0));\n    rayMarch(r, uv, fragColor);\n}","name":"Image","description":"","type":"image"}]}