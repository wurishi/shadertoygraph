{"ver":"0.1","info":{"id":"DsXfWn","date":"1688597908","viewed":70,"name":"Orthographic camera in 2D","username":"Envy24","description":"See Image tab.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","ray","line","sphere","intersection","camera","projection","orthographic","parallel"],"hasliked":0,"parentid":"mdsfR7","parentname":"Perspective camera in 2D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Use mouse to drag camera.\n    3d version: https://www.shadertoy.com/view/flXXWn   \n    \n    Resulting image resolution is w=1., h = num_of_rays, where ray color represent pixel color.\n    This shader shows why distance from camera scene doesn't change scene scale.\n    No matter where you place camera (before scene), you still get same image.\n    Try different look_at points.\n*/\n\n#define SCENE_SCALE               ( 3. )\n#define ORIGIN                    ( vec2(2,0) )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_line(NDC, 0.), horizontal_line(NDC, 0.)) +\n        max(vertical_line(NDC, 0.), horizontal_line(NDC, 0.));\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n    \n    vec3 color = vec3(1.);\n         color -= x_axis(NDC)*0.5; color -= y_axis(NDC)*0.5;\n         color -= cellsSDF(NDC)*0.2;\n         \n    /* Scene */\n    vec2 sphere = vec2(4, 0);\n    float radius = 1.0;\n    vec3 sphere_col = vec3(0,1,1);\n    color = mix(color, sphere_col, SMAA(diskSDF_L2(NDC, sphere, radius)));\n    /* */\n         \n    /* Ortographic camera. */\n    vec2 look_at = sphere;\n    vec2 camera = iMouse.xy == vec2(0) ? vec2(-1, 0) : MP; // also viewport position\n    \n    vec2 f = normalize(look_at - camera); // forward\n    vec2 u = vec2(-f.y, f.x);             // up\n    \n    float vpHeight = 2.5; \n    /* Ortographic camera. */\n       \n    vec2 viewport_up =     camera + u * vpHeight * 0.5,\n         viewport_bottom = camera - u * vpHeight * 0.5;\n    \n    color = mix(color, vec3(0,0,1), 0.2*SMAA(arrowSDF_L2(NDC, camera, (camera+u), 0.001))); // up direction\n    color = mix(color, vec3(0,0,1), 0.2*SMAA(arrowSDF_L2(NDC, camera, (camera+f), 0.001))); // forward direction\n    color = mix(color, vec3(1,0,0), SMAA(segmentSDF_L2(NDC, viewport_bottom, viewport_up, 0.0))); // viewport\n    \n    const float num_of_rays = 10.; \n    float h = vpHeight / float(num_of_rays);\n    for (float i = 0.; i < num_of_rays; i += 1.)\n    {\n        vec2 ray = camera + u * (-vpHeight * 0.5 + h * 0.5 + h*i);\n        vec2 dir = f;\n\n        float d = ray_sphere_intersection(ray, dir, sphere, radius);     \n        vec3 ray_color = d == -1. ? vec3(0, 0, 0) : sphere_col;        \n        color = mix(color, ray_color, 0.5*SMAA(segmentSDF_L2(NDC, ray, ray + 999. * dir, 0.0)));       \n        color = mix(color, ray_color, 0.5*SMAA(diskSDF_L2(NDC, ray, 0.04)));\n        \n        if (d != -1.)\n        {\n            vec2 hit_point = ray + dir * d;\n            color = mix(color, vec3(1,0,0), SMAA(diskSDF_L2(NDC, hit_point, 0.04)));\n        }\n    }\n    \n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, camera, 0.04))); // camera   \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n// Points exactly at point E.\nfloat arrowSDF_L2(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.275, //      U--\n         U = C + up  * 0.10,  // B----C----E\n         D = C - up  * 0.10;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.275 ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\n// just change vec2 to vec3 for 3d\nfloat ray_sphere_intersection(\n    vec2 ray,\n    vec2 ray_dir,\n    vec2 sphere,\n    float r)\n{\n    sphere -= ray; // move sphere in ray coordinate system\n    \n    // Project sphere center on ray.\n    float dist = dot(sphere, ray_dir) /  dot(ray_dir, ray_dir);\n    vec2 sphere_to_ray_proj = dist * ray_dir;\n    float len = length(sphere_to_ray_proj - sphere);\n\n    // Check length between sphere center and projected point.\n    return \n        len > r || dist < 0. ? // ray-sphere intersection\n        //len > r ? // ray-line intersection\n            -1. : // no hit\n            dist-sqrt(r*r - len*len); // distance to hit point\n}","name":"Common","description":"","type":"common"}]}