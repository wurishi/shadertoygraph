{"ver":"0.1","info":{"id":"43lfD8","date":"1728353235","viewed":10,"name":"zedzraymar","username":"zedzee","description":"guh","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nconst float FOV = 75.0;\nconst float NEAR = 0.1;\nconst float FAR = 1000.0;\nconst float DEG_TO_RAD = M_PI / 180.0;\nconst int NUMBER_OF_STEPS = 32;\nconst float MINIMUM_HIT_DISTANCE = 0.001;\nconst float MAXIMUM_TRACE_DISTANCE = 1000.0;\nconst vec3 lightPos = vec3(-1.5, 1.0, 3.0);\nint sphereCount = 0;\n\nstruct Sphere {\n    float radius;\n    vec3 center;\n} spheres[256];\n\n\nfloat dstFromSphere(vec3 p, Sphere sphere) {\n    return length(p - sphere.center) - sphere.radius;\n}\n\nfloat map(vec3 p, Sphere sphere) {\n    float sphDst = dstFromSphere(p, sphere);\n    float displacement = sin(2.0 * p.x + iTime) * sin(5.0 * p.y + iTime) * sin(5.0 * p.z + iTime) * 0.25;    \n    sphDst += displacement;\n\n    return sphDst;\n}\n\nvec3 calcNormal(vec3 p, Sphere sphere) {\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = map(p + smallStep.xyy, sphere) - map(p - smallStep.xyy, sphere);\n    float gradientY = map(p + smallStep.yxy, sphere) - map(p - smallStep.yxy, sphere);\n    float gradientZ = map(p + smallStep.yyx, sphere) - map(p - smallStep.yyx, sphere);\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nmat4 createProjMat(float degFov, float aspect, float far, float near) {\n    float fov = degFov * DEG_TO_RAD;\n    float tanFov = tan(fov / 2.0);\n    float planeDiff = near - far;\n\n    return mat4(\n        vec4(1.0 / (aspect * tanFov), 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0 / tanFov, 0.0, 0.0),\n        vec4(0.0, 0.0, (far + near) / planeDiff, (2.0 * far * near) / planeDiff),\n        vec4(0.0, 0.0, -1.0, 0.0)\n    );\n}\n\nmat4 createViewMat(vec3 right, vec3 up, vec3 forward, vec3 pos) {\n    return mat4(\n        vec4(right.x, up.x, -forward.x, 0.0),\n        vec4(right.y, up.y, -forward.y, 0.0),\n        vec4(right.z, up.z, -forward.z, 0.0),\n        vec4(-dot(right, pos), -dot(up, pos), dot(forward, pos), 1.0)\n    );\n}\n\nvoid addSphere(float radius, vec3 center) {\n    Sphere sphere;\n    sphere.radius = radius;\n    sphere.center = center;\n    spheres[sphereCount - 1] = sphere;\n}\n\nvoid instanceSpheres() {\n    addSphere(1.0, vec3(0.0, 0.0, 10.0));\n}\n\nvec3 rayMarch(vec3 origin, vec3 direction, Sphere sph) {\n    float totalDst = 0.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 curPos = origin + totalDst * direction;\n\n        float dst = map(curPos, sph);\n\n        if (dst < MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calcNormal(curPos, sph);\n\n            vec3 dirToLight = normalize(lightPos - curPos);\n\n            float diffuseIntensity = max(0.0, dot(normal, dirToLight));\n            return vec3(1.0, 0.0, 0.0) * diffuseIntensity;\n        }\n\n        if (totalDst > MAXIMUM_TRACE_DISTANCE) {\n            break;\n        }\n\n        totalDst += dst;\n    }\n\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    // vec2 relUv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 ndc = uv * 2.0 - 1.0;\n\n    mat4 projMat = createProjMat(FOV, iResolution.x / iResolution.y, FAR, NEAR);\n    mat4 inverseProj = inverse(projMat);\n\n    mat4 viewMat = createViewMat(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0));\n    mat4 inverseView = inverse(viewMat);\n    \n    mat4 invProjView = inverseView * inverseProj;\n\n    vec3 direction = normalize((invProjView * vec4(ndc, 0.0, 1.0)).xyz);\n\n    Sphere sph;\n    sph.radius = 1.0;\n    sph.center = vec3(0.0, 0.0, 10.0);\n\n    fragColor = vec4(rayMarch(vec3(0.0), direction, sph), 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}