{"ver":"0.1","info":{"id":"WtKBDm","date":"1618735982","viewed":67,"name":"Siren","username":"AmanSachan","description":"Siren\nThis is a horrible monster :(","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animated","siren"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Aman Sachan, University of Pennsylvania\n// Github: https://github.com/Aman-Sachan-asach\n// LinkedIn: https://linkedin.com/in/amansachan1/\n// Personal Website: http://amansachan.com/\n\n//----------------\n// Global Objects\n//----------------\n\nCamera cam;\n\n//---------\n// Helpers\n//---------\n\nvoid initCamera()\n{\n\tcam.eye     = vec3(0.0, -5.0, 50.0);//vec3(0.0, 5.0, 15.0);\n    cam.target  = vec3(0.0, 0.0, 0.0);\n    \n\tcam.right   = vec3(1.0, 0.0, 0.0);\n\tcam.up      = vec3(0.0, 1.0, 0.0);\n\tcam.forward = vec3(0.0, 0.0, -1.0);\n  \n\tcam.zoom = 1.0;\n}\n    \nRay castRay(vec2 uv, Camera camera) \n{\n    float imgAspectRatio = iResolution.x / iResolution.y; // assuming width > height\n        \n    // Compute ndc space point from screenspace point //[-1,1] to [0,1] range\n    vec2 NDC_Space_Point = uv * 2.0 - 1.0;\n    \n    float tanFOV_Y_by2 = tan(FOV_Y *0.5 * deg2rad);\n    \n    vec3 cam_x = NDC_Space_Point.x * tanFOV_Y_by2 * imgAspectRatio * camera.right;\n    vec3 cam_y = NDC_Space_Point.y * tanFOV_Y_by2 * camera.up;\n\n    //convert to world space\n    vec3 ref = camera.eye + camera.forward;\n    vec3 p = ref + cam_x + cam_y; //facing the screen\n    \n    Ray ray;\n    ray.origin = camera.eye;\n    ray.dir = normalize(p - camera.eye);\n    return ray;\n}\n\n//------------------\n// Background Colors\n//------------------\n\n//large\nvec3 godRaySet1( in vec2 uv, inout float count, in vec3 oceanGradient )\n{\n    vec2 sunBeamOrigin;\n    float beamAngle;\n    \n    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );\n\t\n    for(float i=0.0; i<2.0; i++)\n    {\n        sunBeamOrigin = vec2(0.45 + i*0.5,5.0);\n        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 8.0, 2.5);\n        float t = (1.0+sin(iTime*2.5+0.1073))*0.5;\n        t = remap(t, 0.0,1.0,0.5,1.1);\n        beamAngle = abs(sin(0.0035*PI*t)) * noise;\n            \n        vec2 sunToPoint = normalize(uv - sunBeamOrigin);\n        float theta = acos(dot(sunToPoint, beamDir));\n        \n        if( theta < beamAngle )\n        {           \n            count += 1.0;\n            \n            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);\n            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_LARGE, 0.5);\n            return mix(OCEANBLUE3, godRayColor, beta*(uv.y+0.1));\n        }\n    }\n    \n    return vec3(0.0);\n}\n\n//medium\nvec3 godRaySet2( in vec2 uv, inout float count, in vec3 oceanGradient )\n{\n    vec2 sunBeamOrigin;\n    float beamAngle;\n    \n    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );\n\t\n    for(float i=0.0; i<4.0; i++)\n    {\n        sunBeamOrigin = vec2(0.25 + i*0.3,5.0);\n        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 1.75, 4.0);\n        float t = (1.0+sin(iTime*1.25+0.9873))*0.5;\n        t = remap(t, 0.0,1.0,0.75,1.25);\n        beamAngle = abs(sin(0.0035*PI*t)) * noise;\n            \n        vec2 sunToPoint = normalize(uv - sunBeamOrigin);\n        float theta = acos(dot(sunToPoint, beamDir));\n        \n        if( theta < beamAngle )\n        {           \n            count += 1.0;\n            \n            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);\n            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_LARGE, 0.5);\n            return mix(OCEANBLUE3, godRayColor, beta*(uv.y+0.1));\n        }\n    }\n    \n    return vec3(0.0);\n}\n\n//small\nvec3 godRaySet3( in vec2 uv, inout float count, in vec3 oceanGradient )\n{\n    vec2 sunBeamOrigin;\n    float beamAngle;\n    \n    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );//vec2(-0.2,-1.0);\n\n    for(float i=0.0; i<=10.0; i++)\n    {\n        sunBeamOrigin = vec2(0.25 + i*0.1,5.0);\n        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 0.35, 1.15);\n        float t = (1.0+sin(iTime*0.4+0.45678))*0.5;\n        t = remap(t, 0.0,1.0,0.5,1.0);\n        beamAngle = abs(sin(0.0035*PI*t)) * noise;\n            \n        vec2 sunToPoint = normalize(uv - sunBeamOrigin);\n        float theta = acos(dot(sunToPoint, beamDir));\n        \n        if( theta < beamAngle )\n        {\n            count += 1.0;\n            //float alpha = theta*0.15915; // 1/(2*PI) = 0.15915\n            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);\n            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_SMALL, 0.5);\n            return mix(OCEANBLUE3, godRayColor, beta*uv.y);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 calcBackgroundColor( in vec2 uv )\n{\n    vec3 oceanGradient = OCEANBLUE3;\n    float count = 0.0;\n    \n    vec3 c1 = godRaySet1( uv, count, oceanGradient );\n    c1 = mix(c1, oceanGradient, 1.0-luminance(c1));\n    \n    vec3 c2 = godRaySet2( uv, count, oceanGradient );\n    c2 = mix(c2, oceanGradient, 1.0-luminance(c2));\n    \n    vec3 c3 = godRaySet3( uv, count, oceanGradient )*0.85;\n    c3 = mix(c3, oceanGradient, 1.0-luminance(c3));\n\n    vec3 total = c1+c2+c3;\n    float t = abs(sin(iTime*0.2)); // in a 0.0 to 1.0 range\n    t = remap(t, 0.0, 1.0, 1.15, 1.95);\n    vec3 bgColor = mix(total, oceanGradient, t-luminance(total));\n    \n    return bgColor*0.6;//*0.35;\n}\n\n//--------------\n// Complex SDFs\n//--------------\n\nfloat SirenHead(vec3 p)\n{\n    float sdf;\n    \n    //Neck\n    vec3 transformed_p = scaleOp(p, vec3(1.4f, 3.0f, 1.4f));\n    transformed_p = translateOp(transformed_p, vec3(0.0f, -1.75f, 0.0f));\n    sdf = sdEllipsoid( transformed_p, vec3(0.8f, 0.95f, 0.45f) );\n    \n    //Head\n    transformed_p = translateOp(p, vec3(0.0f, -9.05f, -1.35f));\n    mat3 rot = invRotateX(20.0*deg2rad);\n    transformed_p = rot * transformed_p;\n    float headLower = sdEllipsoid( transformed_p, vec3(1.5f, 2.45f, 1.35f) );\n    transformed_p = translateOp(transformed_p, vec3(0.0f, -0.75f, 0.0f));\n    float headUpper = sdSphere( transformed_p, 1.85f );\n    float head = opSmoothUnion(headLower, headUpper, 0.95);\n    sdf = opSmoothUnion(head, sdf, 0.6);\n    \n    //Eyes & Eye Sockets\n    transformed_p = translateOp(p, vec3(-0.7f, -9.4f, -2.35f));\n    rot = invRotateX(20.0*deg2rad) * invRotateZ(20.0*deg2rad);\n    transformed_p = rot * transformed_p;    \n    float eyeSocket1 = sdEllipsoid( transformed_p, vec3(0.25f, 0.3f, 0.3f) );\n    float eye = sdSphere( transformed_p, 0.45f );\n    sdf = opSmoothSubtraction( eyeSocket1, sdf, 0.8 );\n    sdf = unionSDF( eye, sdf );\n    \n    transformed_p = translateOp(p, vec3(0.7f, -9.4f, -2.35f));\n    rot = invRotateX(-20.0*deg2rad) * invRotateZ(-20.0*deg2rad);\n    transformed_p = rot * transformed_p;    \n    float eyeSocket2 = sdEllipsoid( transformed_p, vec3(0.25f, 0.3f, 0.3f) );\n    eye = sdSphere( transformed_p, 0.45f );\n    sdf = opSmoothSubtraction( eyeSocket2, sdf, 0.8 );\n    sdf = unionSDF( eye, sdf );\n        \n    //Nose\n    \n    //Mouth\n    \n    //Lips\n    \n    //Nose to UpperLip Valley\n    return sdf;//eyeSocket;//sdf;\n}\n\nfloat SirenShoulders(vec3 p)\n{\n    //Shoulders\n    vec3 armStart = vec3(-4.05f, 5.0f, -0.2f);\n    vec3 armEnd = vec3(4.05f, 5.0f, -0.2f);\n    return sdCapsule( p, armStart, armEnd, 1.0f );\n}\n\nfloat SirenArms(vec3 p)\n{\n    float sdf;\n    const float armThickness = 0.7f;\n    \n    //Left Arm\n    vec3 armStart = vec3(4.05f, 5.35f, -0.2f);\n    vec3 armEnd = vec3(4.9f, 1.0f, -0.2f);\n    float leftArm = sdCapsule( p, armStart, armEnd, armThickness );\n    armStart = armEnd;\n    armEnd = armStart + vec3(-3.0f, -4.0f, -2.5f);\n    float leftArmLower = sdCapsule( p, armStart, armEnd, armThickness );\n    leftArm = unionSDF( leftArm, leftArmLower );\n    \n    //Right Arm\n    armStart = vec3(-4.05f, 5.35f, -0.2f);\n    armEnd = vec3(-4.9f, 1.0f, -0.2f);\n    float rightArm = sdCapsule( p, armStart, armEnd, armThickness );\n    armStart = armEnd;\n    armEnd = armStart + vec3(3.0f, -4.0f, -2.5f);\n    float rightArmLower = sdCapsule( p, armStart, armEnd, armThickness );\n    rightArm = unionSDF( rightArm, rightArmLower );\n    \n    sdf = unionSDF( leftArm, rightArm );\n    \n    return sdf;\n}\n\nfloat SirenTorso(vec3 p)\n{\n    //Base Torso\n    const float baseRadius = 1.5f;\n    const vec3 TorsoBaseDimensions = vec3(3.5f, 7.0f, 0.25f);\n    \n    vec3 transformed_p = scaleOp(p, vec3(3.0f, 2.5f, 1.2f));\n    transformed_p = translateOp(transformed_p, vec3(0.0f, 1.0f, 0.0f));\n    vec3 start = vec3(0.0f, TorsoBaseDimensions.y*0.35f, 0.0f);\n    vec3 end = start + vec3(0.0f, -1.5f, 0.0f);\n    float torsoTop = sdRoundCone(transformed_p, start, end, 1.35f, 0.85f);\n    transformed_p = translateOp(transformed_p, vec3(0.0f, 3.0f, 0.0f));\n    end = start + vec3(0.0f, 1.5f, 0.0f);\n    float torsoBottom = sdRoundCone(transformed_p, start, end, 1.25f, 0.85f);\n    float sdf = opSmoothUnion(torsoTop, torsoBottom, 0.3f); ;\n            \n    //SpinalCavityBend\n    transformed_p = opCheapBend_X( -0.02f, translateOp(p, vec3(0.0f, -0.8f, 1.85f)));\n    float carvedSpine = sdEllipsoid( transformed_p, vec3(0.35f,TorsoBaseDimensions.y*0.75f, 0.35f));\n    sdf = opSmoothSubtraction( carvedSpine, sdf, 0.75f );\n    \n    //Breasts\n    transformed_p = p;\n    transformed_p = rotateX(-0.45f)*transformed_p;\n    transformed_p.x = abs(p.x);\n    start = vec3(TorsoBaseDimensions.x*0.6f, TorsoBaseDimensions.y*0.35f, TorsoBaseDimensions.z+1.95f);\n    end = start + vec3(0.0f, 2.0f, 0.0f);\n    float breasts = sdRoundCone(transformed_p, start, end, 1.35f, 0.85f);\n    //Nipples\n    transformed_p = rotateX(0.2f)*transformed_p;\n    start += vec3(0.0f,-0.25f,0.65f);\n    end = start + vec3(0.0f,0.0f,0.1f);\n    float nipples = sdRoundCone(transformed_p, start, end, 0.1f, 0.075f);\n    breasts = opSmoothUnion(breasts, nipples, 0.2f);\n    sdf = opSmoothUnion(sdf, breasts, 0.75f);\n    \n    //Stomach\n    transformed_p = scaleOp(p, vec3(1.0f, 1.0f, 0.3f));\n    transformed_p = translateOp(transformed_p, vec3(0.0f, -1.75f, -2.6f));\n    start = vec3(0.0f, -TorsoBaseDimensions.y*0.35f, 0.0f);\n    end = start + vec3(0.0f, -2.5f, 0.0f);\n    float stomach = sdRoundCone(transformed_p, start, end, 1.25f, 2.25f);\n    transformed_p = rotateX(-1.5f)*p;\n    transformed_p = translateOp(transformed_p, vec3(0.0f, 1.5f, 3.5f));\n    float bellyButton = sdEllipsoid( transformed_p, vec3(0.15f,0.5f,0.15f) );\n    sdf = opSmoothUnion(sdf, stomach, 1.0f);\n    sdf = opSmoothSubtraction(bellyButton, sdf, 0.95f);\n    \n    return sdf;\n}\n\nvoid RotateTentacles( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat SirenTentacles(vec3 p, float bob, float pump)\n{\n    pModPolar(p.xz, 8.0f);\n    p.y += 5.5;\n    p.x = abs(p.x);\n    \n    float tentacleMovementScale = 10.0 * (saturate( (abs(p.y)-1.5) * 0.04 ));\n    float tentacleThicknessScale = 1.9 * (1.0 - saturate( abs(p.y) * 0.075 ));\n    //tentacleThicknessScale = tentacleThicknessScale * tentacleMovementScale;//*0.05;\n    \n    p.y -= bob*0.75;\n    p.x += pump*tentacleMovementScale;\n    \n    \n    p -= vec3( 1.0, -1.5, 0.0 );\n    RotateTentacles( p.xy, 0.25 * PI );\n    p.x -= sin( p.y * 1.5 + iTime * 5.0 ) * 0.2;\n    p.x = abs(p.x);\n    \n    float sdf = sdCapsule( p, vec3( 0.0, -20.0, 0.0 ), vec3( 0.0, 0.0, 0.0 ), tentacleThicknessScale );\n    return sdf;\n}\n\nfloat SirenLowerHalf(vec3 p)\n{\n    float t = iTime*10.0;\n    float N = N3(vec3(iResolution));\n    float theta     = t + N*TWO_PI;\n    float bob       = (cos(theta+cos(theta))+sin(2.0*theta)*0.2)*0.6;\n    float pumpTheta = (p.y+N*TWO_PI)*0.2+t;\n    float pump      = 2.0 * ( cos(pumpTheta+cos(pumpTheta))  +\n                              sin(2.0*pumpTheta)*0.2 +\n                              sin(4.0*pumpTheta)*0.02 );\n\n\n    p.y -= 0.1;\n    float tentacles = SirenTentacles(p, bob, pump);\n    \n    p.y += 6.3 - bob*0.2;    \n    vec3 pscaled = scaleOp(p, vec3(1.05, 1.9, 0.65));    \n    float torus1 = sdTorus(pscaled, vec2(2.75, 0.75));\n    float sdf = opSmoothUnion(torus1, tentacles, 0.95);\n    \n    p.y += 0.65;\n    pscaled = scaleOp(p, vec3(0.85,1.25,0.65));\n    float torus2 = sdTorus(pscaled, vec2(3.5,1.0));\n    sdf = opSmoothUnion(torus2, sdf, 0.95);\n    \n    return sdf;\n}\n\n\nfloat sceneSDF(vec3 p) \n{      \n    mat3 rot = invRotateZ(0.0*deg2rad) *\n        \t   invRotateX(0.0*deg2rad) * \n        \t   invRotateY(iTime);//*0.5);\n    p = rot * p;\n    \n    float sdf = 0.0f;    \n    sdf = opSmoothUnion(SirenTorso(p), SirenLowerHalf(p), 0.95);\n    sdf = opSmoothUnion(sdf, SirenHead(p), 0.5);\n    sdf = opSmoothUnion(sdf, SirenShoulders(p), 0.8);\n    sdf = opSmoothUnion(sdf, SirenArms(p), 0.4);\n    \n    return sdf;\n}\n\n//---https://www.shadertoy.com/img/themes/dark/play.png-------------\n// Sphere Tracing\n//----------------\n\n//Returns the 't' value at the point of intersection with the scene; \n//if it fails it returns a 't' value = 'end'\nfloat shortestDistanceToSurface(Ray ray, float start, float end) \n{\n    float t = start;\n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++) \n    {\n        float dist = sceneSDF(ray.origin + t * ray.dir);\n        if (dist < EPSILON) \n        {\n\t\t\treturn t;\n        }\n        t += dist;\n        if (t >= end) \n        {\n            return end;\n        }\n    }\n    return end;\n}\n\n//---------------------------------\n// Surface Properties and Lighting\n//---------------------------------\n\n//Calculate the gradient of the surface at 'p' by going a delta distance along every axis\n//Might be possible to do a dF/dx and dF/dy thing if the objects are close to the camera\n//Experiment with it because that is a hardware accelerated function\nvec3 calcNormal(vec3 p ) \n{\n    float t_atPoint = sceneSDF(p);\n    vec3 normal = vec3( sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - t_atPoint,\n                        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - t_atPoint,\n                        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - t_atPoint );\n    return normalize(normal);\n}\n\n//TODO: Create a simplified sceneSDF for shadows otherwise dont use it\nfloat calcSoftShadowCoeff( in vec3 ro, in vec3 rd, float k )\n{\n    // k = factor that controls penumbra intensity\n    float shadowIntensity = 1.0;\n    for( float t=MIN_T_SHADOWS; t < MAX_T_SHADOWS; )\n    {\n        //h = hit distance from test point which is the ray origin that was passed in\n        float h = sceneSDF(ro + t*rd);\n        if( h<EPSILON )\n        {\n            //point is too close to the test point and so this is likely just floating point error\n            return 0.0;\n        }\n            \n        shadowIntensity = min( shadowIntensity, k*h/t );\n        t += h;\n    }\n    return shadowIntensity;\n}\n\n//--------\n// Render\n//--------\n\nvec4 render( in Ray r, in float t, in vec2 uv )\n{\n    // Background Color\n    vec3 backgroundColor = calcBackgroundColor( uv );\n    if (t > MAX_DIST - EPSILON) \n    {\n        // Didn't hit anything\n        return vec4(backgroundColor,1.0);\n    }\n    \n    //Surface Coloration\n    vec3 p = r.origin + t*r.dir;\n    \n    vec3 surfaceNormal = calcNormal( p );\n    vec3 LightDir = vec3(0.0,0.0,1.0);// -r.dir;\n    \n    vec3 baseColor = EMERALD_GREEN;\n#if (DEBUG_NORMALS == 1)\n    baseColor = abs(surfaceNormal);\n#endif\n    \n    //assumes surfaceNormal and LightDir are normalized\n\tfloat lambert = max( dot(surfaceNormal, LightDir), 0.0 );\n    vec3 color = baseColor * lambert;\n\n    \n#if (SHADOWS == 1)\n    color *= calcSoftShadowCoeff( p, LightDir, 128.0 );\n#endif\n\n    return vec4(color, 1.0);\n}\n\n//------\n// Main\n//------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv coordinates are the same as Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tinitCamera();\n\t\n    vec4 totalColor = vec4(0.0);\n    //The AA implementation is just supersampling\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // offset pixel coordinates so as to imitate supersampling\n        vec2 offset = vec2(float(m),float(n)) / float(AA) - 0.5;\n        uv = (fragCoord + offset)/iResolution.xy;\n        Ray ray = castRay( uv, cam );\n#else\n        Ray ray = castRay( uv, cam ); \n#endif\n\n        float dist = shortestDistanceToSurface(ray, MIN_DIST, MAX_DIST);\n        vec4 renderColor = render(ray, dist, uv);\n\n#if (DEBUG_NORMALS == 1)\n    \ttotalColor += renderColor;\n#else\n\t\t// gamma correction --> 1/2.2 = 0.4545\n        vec3 gcColor = pow( renderColor.xyz, vec3(0.4545) );\n\t\ttotalColor += vec4( gcColor, renderColor.w );\n#endif\n        \n#if (AA>1)\n    }\n    totalColor /= float(AA*AA);\n#endif\n        \n    fragColor = totalColor;\n}\n\n//------------\n// References:\n//------------\n// https://www.shadertoy.com/view/XdGfDK\n// https://www.shadertoy.com/view/MdsBz2","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//change AA to 1 to turn of AntiAliasing --> greatly improves framerate\n#define AA 2\n#define DEBUG_NORMALS 0\n#define SHADOWS 0\n\n//-----------------\n// GlobalConstants\n//-----------------\n\n#define PI 3.14159265359\n#define TWO_PI 6.283185307179586\n#define deg2rad PI / 180.0\n#define NUM_NOISE_OCTAVES 5\n\nconst int MAX_RAYMARCH_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float MIN_T_SHADOWS = 0.001;\nconst float MAX_T_SHADOWS = 10.0;\nconst float EPSILON = 0.0001;\n\nconst float FOV_Y = 45.0;\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 WHITE = vec3(1.0);\nconst vec3 GREEN = vec3(1.0,0.0,0.0);\nconst vec3 BLUE  = vec3(0.0,0.0,1.0);\n\nconst vec3 EMERALD_GREEN = 1.0*vec3(30.0/255.0, 114.0/255.0, 87.0/255.0);\n\nconst vec3 NEON_RED = 1.50*vec3(200.0/255.0, 28.0/255.0, 35.0/255.0);\nconst vec3 RED = 0.50*vec3(200.0/255.0, 28.0/255.0, 35.0/255.0);\n\nconst vec3 ORANGE = vec3(40.0/255.0, 214.0/255.0, 81.0/255.0);\nconst vec3 VIOLET = vec3(192.0/255.0, 116.0/255.0, 224.0/255.0);\n\nconst vec3 PURPLE = vec3(131.0/255.0, 50.0/255.0, 252.0/255.0);\nconst vec3 PURPLE2 = vec3(94.0/255.0, 56.0/255.0, 175.0/255.0);\nconst vec3 INTENSE_PURPLE = 0.85*vec3(131.0/255.0, 50.0/255.0, 252.0/255.0);\n\nconst vec3 NEON_BLUE = 10.5*vec3(0.01, 98.0/255.0, 1.0);\nconst vec3 LIGHT_BLUE = 2.5*vec3(0.01, 98.0/255.0, 1.0);\nconst vec3 DARK_BLUE = 1.2*vec3(0.01, 98.0/255.0, 1.0);\n\nconst vec3 SUN_BEAM_SMALL = vec3(1.0, 252.0/255.0, 119.0/255.0);\nconst vec3 SUN_BEAM_MEDIUM = vec3(1.0, 252.0/255.0, 119.0/255.0);\nconst vec3 SUN_BEAM_LARGE = vec3(1.0, 252.0/255.0, 119.0/255.0);\n\nconst vec3 OCEANBLUE0 = vec3(0.0/255.0, 199.0/255.0, 255.0/255.0);\nconst vec3 OCEANBLUE1 = vec3(0.0/255.0, 162.0/255.0, 232.0/255.0);\nconst vec3 OCEANBLUE2 = vec3(0.0/255.0, 133.0/255.0, 242.0/255.0);\nconst vec3 OCEANBLUE3 = vec3(0.0/255.0, 91.0/255.0, 165.0/255.0);\nconst vec3 OCEANBLUE4 = vec3(14.0/255.0, 70.0/255.0, 135.0/255.0);\nconst vec3 OCEANBLUE5 = vec3(14.0/255.0, 55.0/255.0, 102.0/255.0);\nconst vec3 OCEANBLUE6 = vec3(13.0/255.0, 41.0/255.0, 73.0/255.0);\nconst vec3 OCEANBLUE7 = vec3(8.0/255.0, 26.0/255.0, 45.0/255.0);\nconst vec3 OCEANBLUE8 = vec3(3.0/255.0, 12.0/255.0, 20.0/255.0);\nconst vec3 OCEANBLUE9 = vec3(0.0/255.0, 4.0/255.0, 7.0/255.0);\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//--------------------------------------------------------------------------\n\n//---------\n// Structs\n//---------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Camera \n{\n    vec3 eye;\n    vec3 target;\t\t// the point the camera is focussed on\n    \n    vec3 right;\n    vec3 up;\n    vec3 forward;\n    \n    float zoom;\t\t\t// the zoom factor\n};\n\n//2D Cones of light for god rays\nstruct SunBeam\n{\n    vec2 origin;\n    vec2 dir;\n    float angle;\n};\n    \nstruct Intersection\n{\n    float t;\n    vec3 color;\n    uint objHit;\n};\n\n//--------------------------------------------------------------------------\n\n//---------\n// Helpers\n//---------\n\nfloat remap(in float value, in float original_min, in float original_max, in float new_min, in float new_max)\n{\n\treturn new_min + ( ((value - original_min) / (original_max - original_min)) * (new_max - new_min) );\n}\n\nfloat luminance(vec3 color_rgb)\n{\n    const vec3 weight = vec3(0.2125, 0.7154, 0.0721); //Weighting according to human eye perception\n    return dot(color_rgb, weight);\n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\n\nfloat rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat noise(float x) \n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    float result = mix(hash(i), hash(i + 1.0), u);\n    result = remap( result, 0.0, 1.0, 0.25, 1.5);\n    return result*1.5;\n}\n\nfloat fbm(float x, float persistence) \n{\n    const float diffReductionFactor = -0.1;\n    const float shift = 100.0;\n    \n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\t\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) \n    {\n\t\tv += a * noise(x) + diffReductionFactor;\n\t\tx = x * 2.0 + shift;\n\t\ta *= persistence;\n\t}\n\treturn v;\n}\n\n// 1D height returned using 2D point\nfloat N1(vec2 p, float freq, float persistence, float scale)\n{\n    float coord = p.x*freq;// + iTime * 5.0;\n    float height = fbm(coord, persistence)*scale;\n    return height;\n}\n\nfloat N2(vec2 p, float scale) { return 0.5*noise(p.x*0.1)*scale; }\n\nfloat N3(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n//--------------------------------------------------------------------------\n\n//------------\n// Basic SDFs\n//------------\n\n// ----- Signed and Exact -----\n    \n//sphere\nfloat sdSphere( vec3 p, float radius )\n{\n  return length(p)-radius;\n}\n\n//box\nfloat sdBox( vec3 p, vec3 boxDimensions )\n{\n\tvec3 d = abs(p) - boxDimensions;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 boxDimensions, float r )\n{\n\tvec3 d = abs(p) - boxDimensions;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))  - r;\n}\n\n//ellipsoid\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    //r = radius\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n//torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n    //t = vec2( ring radius, ring thickness )\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n//cone\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n//cone section\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    //h = height\n    //r1 = bottom radius;\n    //r2 = top radius;\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n//capped cylinder\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    //a = capsule cylinder start,\n    //b = capsule cylinder end,\n    // a and b dont take into account the hemispheres on either end of the capsule, \n    //thats why I've labeled them as cylinder start and end\n    //r = radius\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//equilateral triangle with thickness\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n#if 1\n    // distance bound\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n#else\n    // correct distance\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n#endif\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// ----- Unsigned -----\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n//--------------------------------------------------------------------------\n\n//------------\n// Operations\n//------------\n\n// All basic operations have to be done as their inverse operations because \n//we are taking the ray from world space into local space\n\n// ----- Rotations (CCW) -----\n//Rotation matrix to rotate about the X axis\nmat3 rotateX(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3( vec3(1, 0, 0 ),\n                 vec3(0, c, -s),\n                 vec3(0, s, c ) );\n}\n\n//Rotation matrix to rotate about the Y axis\nmat3 rotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3( vec3( c, 0, s),\n                 vec3( 0, 1, 0),\n                 vec3(-s, 0, c) );\n}\n\n//Rotation matrix to rotate about the Z axis\nmat3 rotateZ(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3( vec3(c, -s, 0),\n                 vec3(s,  c, 0),\n                 vec3(0,  0, 1) );\n}\n\n// ----- Axis Angle Rotation Matrix -----\nmat3 rotationAxisAngle(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         );\n}\n\n// ----- Inverse of the rotation matrix -----\n//Could do the actual inverse but for rotation matrices, i.e orthogonal matrices that is the\n// same as the transpose, which for simple cases of rotating about the X,Y, or Z axes can be\n// calculated by just negating the angle\n// So inverse(rotateX(theta)) = rotateX(-theta)\n\nmat3 invRotateX(float theta) { return rotateX(-theta); }\n\nmat3 invRotateY(float theta) { return rotateY(-theta); }\n\nmat3 invRotateZ(float theta) { return rotateZ(-theta); }\n\nmat3 invRotAxisAngle(vec3 axis, float angle) { return inverse(rotationAxisAngle(axis, angle)); }\n\n// ----- Scale, Translate, Repeat -----\n//Scaling isn't affected by the inverse because the scale factors are on the diagonal of the matrix\n//but we need to be careful not to change the distance between the points on the surface --> achieve\n//that by dividing the sample point by scale and then scaling the result as follows\n\nvec3 scaleOp(vec3 samplePoint, vec3 scale) { return samplePoint / scale; }\n\nvec3 translateOp(vec3 samplePoint, vec3 translation)  { return samplePoint + translation; }\n\nvec3 invTranslateOp(vec3 samplePoint, vec3 translation) { return samplePoint - translation; }\n\nvec3 repeatOp(vec3 samplePoint, vec3 center) { return (mod(samplePoint, center)-0.5*center); }\n\n// Polar Repeat function by Mercury\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle*0.5;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*0.5;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions*0.5)) c = abs(c);\n\treturn c;\n}\n\n// ----- Twists and Bends -----\nvec3 opTwist( vec3 p, float angle )\n{\n    float c = cos(angle*p.y);\n    float s = sin(angle*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    \n    return vec3(m*p.xz,p.y);\n}\n\n//pass this into the primitive as the sample point\nvec3 opCheapBend_X( in float k, in vec3 p )\n{\n    //const float k = 0.01f; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(p.x, m*p.yz);\n    return q;\n}\nvec3 opCheapBend_Y( in float k, in vec3 p )\n{\n    //const float k = 0.01f; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,s,-s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\nvec3 opCheapBend_Z( in float k, in vec3 p )\n{\n    //const float k = 0.01f; // or some other amount\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n\nfloat opDisplace1( vec3 p, float sdf1, float freq, float scale )\n{\n    float displacement = sin(freq*p.x) * sin(freq*p.y) * sin(freq*p.z);\n    return sdf1 + displacement*scale;\n}\n\nfloat opDisplace2( vec3 p, float sdf1, float scale )\n{\n    vec3 d = vec3(sin(1.0*p.x), sin(80.0*p.y), sin(80.0*p.z));\n    float y = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))  - 0.2;\n    return sdf1 + y*scale;\n}\n\n// ----- CSG -----\nfloat intersectSDF(float distA, float distB) { return max(distA, distB); }\n\nfloat unionSDF(float distA, float distB) { return min(distA, distB); }\n\nfloat differenceSDF(float distA, float distB) { return max(distA, -distB); }\n\n// ----- Smooth Min -----\n// polynomial smin\n// Easy to control and fast\n// k maps directly to blending band distance\nfloat smin( float distA, float distB, float k )\n{\n    //k values close to 0.5 as starting point\n    float h = clamp( 0.5+0.5*(distB-distA)/k, 0.0, 1.0 );\n    return mix( distB, distA, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n// ----- Bias -----\n// b is the bias value between 0.0 and 1.0\n// t is time\nfloat bias( float b, float t )\n{\n    return pow( t, log(b)/log(0.5f));\n}\n\n// ----- EaseIn -----\n// accelerating from zero velocity\nfloat EaseInQuart( float t )\n{\n    return t*t;\n}","name":"Common","description":"","type":"common"}]}