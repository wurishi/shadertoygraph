{"ver":"0.1","info":{"id":"wlfyRs","date":"1592778624","viewed":238,"name":"Strobe Lights Grid Shenanigans","username":"noobay","description":"Trying to be creative for once and play around with a grid, instead of having a specific goal in mind.\nThis time it's some strobe lights on a stick! (well, a grid)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["grid","flow","electricity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Random Grid Shenanigans\" by noobay. https://shadertoy.com/view/WlsyR2\n// 2020-06-21 22:06:13\n\n#define PI 3.14\n#define TARGET_COUNT 15\n#define GRID_CELL_SIZE 0.1\n#define RED vec3(1.0,0.0,0.0)\n#define GREEN vec3(0.0,1.0,0.0)\n#define BLUE vec3(0.0,0.0,1.0)\n\n#define SPEED_GROUP_ONE 0.20\n#define SPEED_GROUP_TWO 0.01\n\n#define DIMMNESS_GROUP_ONE 80.0\n#define DIMMNESS_GROUP_TWO 600.0\n\nvec2 getGridPosition(in vec2 uv)\n{\n\treturn vec2((uv.x / GRID_CELL_SIZE), (uv.y / GRID_CELL_SIZE));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized frag coordinates\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    \n    vec2 gridBoundUV = getGridPosition(uv);\n\n    vec2 cellBoundUV = gridBoundUV - round(gridBoundUV);\n    \n    float targetGroupOneIntensity = 0.0;\n    float targetGroupTwoIntensity = 0.0;\n \n    for (int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex)\n    {\n        float f_targetIndex = float(targetIndex);\n\n        float trigOffset = (PI / float(TARGET_COUNT)) * f_targetIndex;\n        vec2 targetPosition = vec2(sin(iTime + trigOffset) * SPEED_GROUP_ONE + tan(f_targetIndex + trigOffset), cos(iTime + trigOffset) * SPEED_GROUP_ONE + sin(f_targetIndex + trigOffset));\n        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);\n        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);\n\n        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) - length((gridBoundUV) - (edgeBoundPosition));\n\n    \ttargetGroupOneIntensity += length(GRID_CELL_SIZE / (distanceToTarget * DIMMNESS_GROUP_ONE)  / cellBoundUV) * GRID_CELL_SIZE;\n    \n    }\n\n    for (int targetIndex = 0; targetIndex < TARGET_COUNT; ++targetIndex)\n    {\n        float f_targetIndex = float(targetIndex);\n\n        float trigOffset = (PI / float(TARGET_COUNT)) * f_targetIndex;\n\n        vec2 targetPosition = vec2(sin(iTime + trigOffset) * SPEED_GROUP_TWO + sin(f_targetIndex + trigOffset), tan(iTime + trigOffset) * SPEED_GROUP_TWO + sin(f_targetIndex + trigOffset));\n        vec2 gridBoundTargetPosition = getGridPosition(targetPosition);\n        vec2 edgeBoundPosition = vec2(gridBoundTargetPosition.x, gridBoundTargetPosition.y);\n\n        float distanceToTarget = length(gridBoundUV - round(gridBoundTargetPosition)) - length((gridBoundUV) - (edgeBoundPosition));\n\n    \ttargetGroupTwoIntensity += length(GRID_CELL_SIZE / (distanceToTarget * DIMMNESS_GROUP_TWO)  / cellBoundUV) * GRID_CELL_SIZE;\n    \n    }\n\n\n    vec3 col = vec3(smoothstep(0.2, 1.0, targetGroupOneIntensity + targetGroupTwoIntensity));\n\n    col += vec3(targetGroupOneIntensity + sin(iTime), 0.0 , targetGroupTwoIntensity + cos(iTime));\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}