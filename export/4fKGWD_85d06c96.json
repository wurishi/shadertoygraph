{"ver":"0.1","info":{"id":"4fKGWD","date":"1713203457","viewed":163,"name":"Block Transfer","username":"incre_ment","description":"Shader version of an animation of made in Processing a couple years, back.\nDomain repetition in the x-direction.  Box SDF from IQ.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","blocks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader version of an animation of made in Processing a couple years, back.  \n// Domain repetition in the x-direction.  Thanks for the box SDF IQ!\n\n#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);   \n   float tt = fract(.5*iTime);\n   \n   // Rotate the whole scene\n   uv *= rotation(PI/4.);\n   \n   // Stars\n   // I'm sure there's a more elegant way to do this.  I create a grid\n   // and then place a star randomly in each grid space.  Didn't want to have \n   // to check neighbor cells, so the location of the star is multiplied by .7\n   // to keep the star located towards the center of the cell.\n   vec2 uvStars = uv * 30.;\n   vec2 starCell = floor(uvStars);\n   uvStars = fract(uvStars) * 2. - 1.;\n   float r1 = fract(sin(dot(starCell, vec2(1.0,12.0)))*15745.7342) * 2. - 1.;\n   float r2 = fract(sin(dot(starCell, vec2(1.0,43.0)))*13131.8234) * 2. - 1.;\n   float spark = 0.;\n   if (r2 > .3) spark = .1 * sin(TAU*(tt + r1));     \n     float ssize = r2 * .2;  \n   float star = length(uvStars - .7*vec2(r1,r2)) - ssize+spark;\n   col += smoothstep(.1,-.1,star);\n   \n   // Grid\n   float scale = 9.;\n   uv *= scale;\n   \n   float cellID = floor(uv.x);\n   uv.x = fract(uv.x)*2. - 1.;\n   \n   // Calculate blocks stacked on each side.\n   float numTop = floor(4.*fract(sin(5.232+3.3*cellID*.3)) + 1.75);\n   float numBot = floor(4.*fract(sin(8.12+8.8*cellID*.3)) + 1.75);\n   \n   float w = 2./iResolution.y;\n \n   // Calculate motion for and draw the transfer block\n   vec2 motion = vec2(0., tt);\n   for(float i = -5.; i < numTop; i++){\n     if (i == (numTop - 1.)){\n       motion = vec2(0.,tt*((scale + 2.)-(numTop + numBot)));\n     }\n     \n     // Calculate box SDF and draw\n     vec2 boxOffset = vec2(0., (scale/2.)-i);\n     float box = (sdBox(uv - boxOffset + motion, vec2(.85,.85/2.)));\n     col += smoothstep(w,-w,box);\n\n   }\n   \n   // Calculate motion for and draw stacked blocks.\n   motion = vec2(0., tt);\n   for(float i = -5.; i < numBot; i++){\n   \n     // Calculate box SDF and draw\n     vec2 boxOffset = vec2(0., -(scale/2.)+i);\n     float box = (sdBox(uv - boxOffset + motion, vec2(.85,.85/2.)));\n     col += smoothstep(w,-w,box);\n\n   }\n \n   fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"}]}