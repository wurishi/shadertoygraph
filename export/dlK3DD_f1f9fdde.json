{"ver":"0.1","info":{"id":"dlK3DD","date":"1684066412","viewed":42,"name":"BooleanThreeFbmWarping","username":"CycloneFox","description":"mixture of 3 fbm warping by boolean\ncorresponding to the 3 primary colors of light","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ch5"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\nfloat atan2(vec2 xy){\n    return xy.x == 0.0 ? sign(xy.y) * PI / 2.0 : atan(xy.y, xy.x);\n}\nvec2 xy2pol(vec2 xy){\n    return vec2(atan2(xy), length(xy));\n}\nvec2 pol2xy(vec2 pol){\n    return pol.y * vec2(cos(pol.x), sin(pol.y));\n}\n\nuvec4 k = uvec4(0x456789abu, 0x6789ab45u, 0x89ab4567u, 0xab456789u);\nuvec4 u = uvec4(1, 2, 3, 4);\nconst uint UINT_MAX = 0xffffffffu;\nuvec2 uhash22(uvec2 n){\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nfloat hash21(vec2 p){\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat vnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 2; j++){\n            v[i + 2 * j] = hash21(n + vec2(i, j));\n        }\n    }\n    return mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]);\n}\nfloat gtable2(vec2 lattice, vec2 p){\n    uvec2 n = floatBitsToUint(lattice);\n    uint idx = uhash22(n).x >> 29;\n    float u = 0.92387953 * (idx < 4u ? p.x : p.y);\n    float v = 0.38268343 * (idx < 4u ? p.y : p.x);\n    return((idx & 1u) == 0u ? u : -u) + ((idx & 2u) == 0u ? v : -v);\n}\nfloat pnoise21(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 2; j++){\n            v[i + j * 2] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat fbm21(vec2 p, float g){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 4; i++){\n        val += amp * (vnoise21(freq * p) - 0.5);\n        amp *= g;\n        freq *= 2.01;\n    }\n    return 0.5 * val + 0.5;\n}\nfloat base21(vec2 p){\n    return (mod(iTime, 10.0) < 5.0) ? fbm21(p, 0.5) : pnoise21(p);\n}\nfloat warp21(vec2 p, float g){\n    float val = 0.0;\n    for(int i = 0; i < 4; i++){\n        val = base21(p + g * vec2(cos(2.0 * PI * val), sin(2.0 * PI * val)));\n    }\n    return val;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord / min(iResolution.x, iResolution.y);\n    pos = 10.0 * pos + iTime;\n    vec3 f = vec3(warp21(pos, 1.0), warp21(pos + 7.0, 1.0), warp21(pos + 17.0, 1.0));\n    f -= 0.5;\n    fragColor.rgb = vec3(0.0);\n    float[8] x = float[](\n        max(max(f[0], f[1]), f[2]),\n        max(max(f[0], f[1]), -f[2]),\n        max(max(f[1], f[2]), -f[0]),\n        max(max(f[2], f[0]), -f[1]),\n        max(f[0], -min(f[1], f[2])),\n        max(f[1], -min(f[2], f[0])),\n        max(f[2], -min(f[0], f[1])),\n        max(-f[1], -min(f[2], f[0]))\n    );\n    for(int i = 0; i < 8; i++){\n        x[i] = step(x[i], 0.0);\n    }\n    vec3[8] col8 = vec3[](\n        vec3(1, 1, 1),\n        vec3(1, 1, 0),\n        vec3(0, 1, 1),\n        vec3(1, 0, 1),\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1),\n        vec3(0, 0, 0)\n    );\n    for(int i = 0; i < 8; i++){\n        fragColor.rgb += x[i] * col8[i];\n    }\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}