{"ver":"0.1","info":{"id":"WtlBW2","date":"1598020980","viewed":130,"name":"Inflated Parametric Curve","username":"arifr123","description":"The function 'c(t) ' defines a curve in 3D space which is then drawn using several gradient descent optimisations (over t).\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["gradientdescent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define sq(x) dot(x, x)\n\n// Hue from: https://www.shadertoy.com/view/ll2cDc\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )\n//#define hue(v)  ( .5 +      cos( 6.3*(v)  + vec3(0,23,21)  ) )\n\nvec3 c(float t)\n{\n    // ###################################\n    // This is the parametric curve drawn.\n    // Try changing it!\n    // ###################################\n    \n    float time = 0.5*iTime;\n    return vec3(sin(5.*t + 0.6*sin(time)), sin(2.*t + 0.6*sin(time + 2.*PI/3.)), sin(3.*t + 0.6*sin(time + 4.*PI/3.)));\n}\n\nconst float h = 0.01;  // 0.0001\n\nvec3 dC_dt(float t, vec3 C)\n{\n    return (c(t + h) - C) / h;\n    //return vec3(-sin(t), cos(t), 0);\n    //return vec3(cos(2.*t), cos(3.*t), cos(5.*t));\n}\n\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\n/*\nfloat sqDistanceToRay(float t, Ray ray)\n{\n    vec3 c_o = c(t) - ray.ro;\n    return sq(c_o) - sq(dot(c_o, ray.rd));\n}\n*/\n\nfloat dSqDistanceToRay_dt(float t, Ray ray)\n{\n    vec3 c_o = c(t);\n    vec3 dc_dt = (c(t + h) - c_o) / h;//dC_dt(t, c_o);\n    c_o -= ray.ro;\n    \n    return 2. * (dot(c_o, dc_dt) - dot(c_o, ray.rd) * dot(dc_dt, ray.rd));\n    //return 2. * (dot(c_o, dc_dt - ray.rd * dot(dc_dt, ray.rd)));\n}\n\n/*\nfloat minimizeDistanceToRay(float startT, Ray ray)\n{\n    float t = startT;\n    \n    for(int i = 0; i < 100; i++)\n    {\n        float deltaT = 0.01 * dSqDistanceToRay_dt(t, ray);\n        \n        t -= deltaT;\n        \n        if(abs(deltaT) < 0.001)\n        \tbreak;\n    }\n    \n    return t;\n}\n\nfloat multipleSectionMinimization(float minT, float maxT, int sectionNum, Ray ray)\n{\n    float sectionSize = (maxT - minT) / float(sectionNum);\n    \n    float bestT = 0.;\n    float minSqDist = 0.;\n    \n    for(int i = 0; i < sectionNum; i++)\n    {\n        float sectionStart = float(i)*sectionSize;\n        float t = minimizeDistanceToRay(sectionStart + sectionSize / 2., ray);\n        \n        float sqDist = sqDistanceToRay(t, ray);\n        \n        if(i == 0 || sqDist < minSqDist)\n        {\n            minSqDist = sqDist;\n            bestT = t;\n        }\n    }\n    \n    return bestT;\n}\n\nfloat momentumGradientDescent(float startT, Ray ray, float learningRate, float exponentialFactor)\n{\n    float t = startT;\n    float deltaT = 0.;\n    \n    for(int i = 0; i < 300; i++)\n    {\n        deltaT = exponentialFactor * deltaT - learningRate * dSqDistanceToRay_dt(t, ray);\n        \n        t += deltaT;\n    }\n    \n    return t;\n}\n\nconst float epsilon = 0.00000001;\nconst float beta1 = 0.9;  // 0.9\nconst float beta2 = 0.999;  // 0.999\nconst float alpha = 0.1;  // 0.001\nfloat adam(float startT, Ray ray)\n{\n    float t = startT;\n    float m = 0.;\n    float v = 0.;\n    \n    float beta1pow = beta1;\n    float beta2pow = beta2;\n    \n    for(int i = 0; i < 300; i++)\n    {\n        float grad = dSqDistanceToRay_dt(t, ray);\n        \n        m = beta1*m + (1.-beta1)*grad;\n        v = beta2*v + (1.-beta2)*sq(grad);\n        \n        float m_hat = m / (1. - beta1pow);\n        float v_hat = v / (1. - beta2pow);\n        \n        t -= alpha * m_hat/(sqrt(v_hat)+epsilon);\n        \n        beta1pow *= beta1;\n        beta2pow *= beta2;\n    }\n    \n    return t;\n}\n*/\n\nfloat dSqDistance_dt(float t, vec3 p)\n{\n    vec3 C = c(t);\n    return dot(C - p, dC_dt(t, C));\n}\n\nvec2 reverseRaymarching(float t, float cProjection, float r, Ray ray)\n{\n    vec3 p = ray.ro + cProjection * ray.rd;\n\n    for(int i = 0; i < 50; i++)\n    {\n        // Try changing to 0.1 :)\n        float deltaT = 0.005 * dSqDistance_dt(t, p);  // 0.01\n\n        t -= deltaT;\n\t\t\n        //if(abs(deltaT) < 0.01)\n        {\n            float deltaP = (sqrt(sq(c(t) - p)) - r);\n\n            p += deltaP * ray.rd;\n            cProjection += deltaP;\n            // p == ray.ro + cProjection * ray.rd\n\n            if(abs(deltaP) < 0.0001)\n            {\n                break;\n            }\n        }\n    }\n    \n    return vec2(t, cProjection);\n}\n\n\n\n// Try changing to 0.01 :)\nconst float minDelta = 0.001;  // 0.001\n/*\nvec3 closectIntersection(Ray ray, float minT, float maxT, float r)\n{\n    float bestT = 0.;\n    float minProjection = -1.;\n    \n    float t = minT + minDelta;\n    float learning_rate = 0.01 * sign(dSqDistanceToRay_dt(t, ray));\n    \n    float intersection = 0.;\n    \n    for(int i = 0; i < 1000 && t >= minT && t < maxT; i++)//while(t >= minT && t < maxT)\n    {   \n        vec3 c_o = c(t);\n        vec3 dc_dt = (c(t + h) - c_o) / h;//dC_dt(t, c_o);\n        c_o -= ray.ro;\n        \n        float deltaT = learning_rate * 2. * (dot(c_o, dc_dt) - dot(c_o, ray.rd) * dot(dc_dt, ray.rd));\n\n        if(abs(deltaT) < minDelta)\n        {\n            // Extreme\n            \n            if(learning_rate < 0.)\n            {\n                // Min\n                \n                float cProjection = dot(c_o, ray.rd);\n                \n                if(sq(c_o) - sq(cProjection) <= sq(r))\n                {\n                    // Intersection\n                    \n                    vec2 res = reverseRaymarching(t, cProjection, r, ray);\n                    cProjection = res[1];\n                    \n                    if(minProjection < 0. || (cProjection > 0. && cProjection < minProjection))\n                    {\n                        intersection = (1. - 1. / (1. + sq(mod(abs(bestT - res[0]), 2. * PI-0.1)))) / (1. + pow(10.*(minProjection - cProjection), 6.));\n                        \n                        minProjection = cProjection;\n                        bestT = res[0];\n                    }\n                }\n            }\n            \n            //while(sign(learning_rate) * sign(dSqDistanceToRay_dt(t, ray)) > 0.)\n            //{\n            //\tt += minDelta;\n            //}\n            \n            t += 30. * minDelta;  // 30\n\n            learning_rate *= -1.;\n        }\n        \n        t += deltaT;\n    }\n    \n    return vec3(bestT, minProjection, intersection);\n}\n*/\n\nvec2 cis(float a)\n{\n    return vec2(cos(a), sin(a));\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y - 0.5*iResolution.xy/iResolution.y;\n    \n    \n   \tvec2 angles = PI * (vec2(2., 1.) * iMouse.xy / iResolution.xy - vec2(1., 0.5));  // vec2([-PI, PI], [-PI/2, PI/2])\n    \n    if(abs(iMouse.x) < 1.)\n    {\n        angles = vec2(0., 0.);\n    }\n    \n    \n    vec2 cisXY = cis(angles.x);\n    vec2 cisRZ = cis(angles.y);\n    \n    vec3 ro = vec3(cisRZ.x * cisXY, cisRZ.y);\n    \n    vec3 right = vec3(-cisXY.y, cisXY.x, 0);\n    vec3 up = vec3(-cisRZ.y * cisXY, cisRZ.x);\n    vec3 forward = -ro;\n    \n    ro *= 6.;\n    \n    \n    float zoom = 2.;\n    \n    vec3 rd = normalize(uv.x * right + uv.y * up + zoom * forward);\n    \n    Ray ray = Ray(ro, rd);\n    \n    \n    float r = 0.2;\n    \n    float minT = 0., maxT = 2.*PI;\n    \n    \n    vec3 col = vec3(0);\n    \n    vec3 pureCol = vec3(0);\n    \n    \n    float bestT = 0.;\n    float minProjection = -1.;\n    \n    float t = minT + minDelta;\n    float learning_rate = 0.01 * sign(dSqDistanceToRay_dt(t, ray));  // 0.01\n    \n    float intersection = 0.;\n    \n    for(int i = 0; i < 1000 && t >= minT && t < maxT; i++)//while(t >= minT && t < maxT)\n    {   \n        vec3 c_o = c(t);\n        vec3 dc_dt = (c(t + h) - c_o) / h;//dC_dt(t, c_o);\n        c_o -= ray.ro;\n        \n        float deltaT = learning_rate * 2. * (dot(c_o, dc_dt) - dot(c_o, ray.rd) * dot(dc_dt, ray.rd));\n\n        if(abs(deltaT) < minDelta)\n        {\n            // Extreme\n            \n            if(learning_rate < 0.)\n            {\n                // Min\n                \n                float cProjection = dot(c_o, ray.rd);\n                \n                if(sq(c_o) - sq(cProjection) <= sq(r))\n                {\n                    // Intersection\n                    \n                    vec2 res = reverseRaymarching(t, cProjection, r, ray);\n                    cProjection = res[1];\n                    \n                    if(minProjection < 0. || (cProjection > 0. && cProjection < minProjection))\n                    {\n                        float closeAngle = 1. - 1. / (1. + sq(mod(abs(bestT - res[0]), 2. * PI - 0.1))); // 1. for far away and 0. for close.\n                        \n                        intersection = closeAngle / (1. + pow(10.*(minProjection - cProjection), 6.));\n                        \n                        \n                        minProjection = cProjection;\n                        bestT = res[0];\n                        \n                        \n                        float t = bestT;\n                        vec3 p = ray.ro + minProjection * ray.rd;\n\n\n                        vec3 normal = normalize(p - c(t));\n\n                        \n                        vec3 newPureCol = hue(t / (2.* PI)) * ((dot(normal, vec3(1, 0, 1)) + 1.)/2. + pow((dot(normal, normalize(vec3(1, 0, 1))) + 1.)/2., 30.));\n                        \n                        \n                        float alpha = closeAngle * 0.8 + (1. - closeAngle) * 1.;\n                        \n                    \tcol = alpha * newPureCol + (1. - alpha) * pureCol;\n                        \n                        pureCol = newPureCol;\n                    }\n                }\n            }\n            \n            //while(sign(learning_rate) * sign(dSqDistanceToRay_dt(t, ray)) > 0.)\n            //{\n            //\tt += minDelta;\n            //}\n            \n            t += 120. * minDelta;  // 30\n\n            learning_rate *= -1.;\n        }\n        \n        t += deltaT;\n    }\n    \n    \n    col = vec3(1, 1, 1) * intersection + (1. - intersection) * col;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}