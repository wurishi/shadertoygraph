{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// inspired by https://www.shadertoy.com/view/Md3SDf\n// make a sphere of eyes\n// using my voronoi shader https://www.shadertoy.com/view/432czK\n// sphere rendering from https://www.shadertoy.com/view/7tS3Wh\n\n#define PI 3.141592654\n#define GOLDEN_ANGLE 2.399963230\n\n\n// eye texture\nvec3 eye(float theta, float phi, float x) {\n    float l = sqrt(2.0 + sin(phi * 37.0 + 4.0*theta) - sin(phi * 17.0 - 4.0*theta));\n    // good eyecolors have no magenta or cyan\n    float b = .5*(sin(10.0 * x) + 1.);\n    float flicker = sin(20.0*iTime)*0.002 * (5.0 + phi);\n    vec3 mid = vec3(.7,.0,-1.4);\n    vec3 iris = l * mix(mix(vec3(.1,.5,.2), mid, b), mix(mid, vec3(.2,.4,.9), b), b);\n    float t = clamp(4.0*(0.9 - theta + l*0.01), 0.0, 1.0);\n    vec3 color = mix(vec3(1.0) * (t > 0.0 ? min(max(1.0 - 7.0*t, 0.0) + t*0.5, 1.0) : 1.0), iris, t);\n    color = mix(color, vec3(0.0), clamp(10.0*(0.4 + b*0.05 + flicker*flicker*5.5 - theta), 0.0, 1.0));\n    color += max(2.0 - 10.0*length(vec2(2.*(abs(theta - 0.4) - 0.1 + flicker), abs(abs(phi) - 1.7 + flicker) - 0.7)), 0.0);\n    color += sign(sin(phi))*max(10.7 - 10.0-length(vec2(theta - 1.0, 0.5*abs(phi) - PI/4.0)), 0.0);\n    return color * (1.0 - theta * theta * 0.1);\n}\n\n\nfloat points() {\n    return min(1.1 + iTime*iTime * 2.0, 100.0);\n}\n\nfloat sphere_distance(vec3 a, vec3 b) {\n    return sqrt(max(0.0, 2.0 - 2.0*dot(a, b)));\n}\n\nvec3 hash3(float p) {\n\treturn asin(fract(sin(p*vec3(1.21243, 1.85512, 2.5516)))*2.0 - 1.0) * .3;\n}\n\nvec4 voronoi(vec3 pos, float n, float shift) {\n    float point_radius = 0.7 / sqrt(n);\n    mat2 mat = mat2(GOLDEN_ANGLE, 1.0/n, (GOLDEN_ANGLE*5.0) - PI*2.0, 5.0/n);\n    vec2 scale = vec2(1.0 - pos.z*pos.z, 1.0);\n    mat2 mat_ortho;\n    mat2 inv;\n    if (scale.x > point_radius) {\n        vec2 real1 = mat[1]-round(dot(mat[1], scale * mat[0])/dot(mat[0], scale * mat[0]))*mat[0];\n        vec2 real0 = mat[0]-round(dot(mat[0], scale * real1)/dot(real1, scale * real1))*real1;\n        real1 = real1-round(dot(real1, scale * real0)/dot(real0, scale * real0))*real0;\n        real0 = real0-round(dot(real0, scale * real1)/dot(real1, scale * real1))*real1;\n        mat_ortho = mat2(real0, real1);\n        inv = inverse(mat_ortho);\n    }\n    else {\n        mat_ortho = mat;\n        inv = inverse(mat);\n    }\n    vec2 phi_z = vec2(2.0*atan(pos.y / (pos.x + length(pos.xy))), pos.z + shift);\n    vec2 x = round(inv * phi_z);\n    float closest = 7.0;\n    vec4 closest_pos = vec4(0.0);\n    for (float i = -2.0; i <= 2.0; i++) {\n        for (float j = -2.0; j <= 2.0; j++) {\n            vec2 phi_z = mat_ortho * (x + vec2(i, j));\n            float index = round(phi_z.y*n);\n            vec3 offset = hash3(index) * point_radius;\n            phi_z.y -= shift;\n            float r_sqr = 1.0 - phi_z.y*phi_z.y;\n            if (r_sqr > 0.0) {\n                float r = sqrt(r_sqr);\n                vec3 point = normalize(vec3(cos(phi_z.x)*r, sin(phi_z.x)*r, phi_z.y) + offset);\n                float d = sphere_distance(point, pos);\n                if (d < closest) {\n                    closest = d;\n                    closest_pos = vec4(point, index);\n                }\n            }\n        }\n    }\n    return closest_pos;\n}\n\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotate(vec3 pos, float phi, float theta) {\n    return rotateX(rotateX(pos, theta).yzx, phi).zxy;\n}\nvec3 sphere(vec2 uv, float phi, float theta) {\n    float uv_r = length(uv);\n    if (uv_r < 1.0) {\n        float aa = clamp((1.0 - uv_r)/fwidth(uv_r)*0.5, 0.0, 1.0);\n        vec3 pos = vec3(uv, sqrt(1.0-dot(uv,uv)));\n        float z = pos.z;\n        \n        // rotate sphere\n        pos = rotate(pos, phi, theta);\n        \n        // get spherical coordinates\n        float sin_theta = length(pos.xz);\n        float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.z) : 0.0;\n        float ball_theta = atan(sin_theta, pos.y);\n        \n        // evaluate voronoi\n        float n = points();\n        vec4 center = voronoi(pos, n, max(iTime - 7.0, 0.0)*0.2);\n        vec3 diff = center.xyz - pos;\n        vec3 tangent1 = vec3(center.y, -center.x, 0.0);\n        vec3 tangent2 = cross(center.xyz, tangent1);\n        float d = sphere_distance(center.xyz, pos) * sqrt(n);\n        \n        // return the distance to the voronoi cell center\n        return aa * eye(d, atan(dot(diff, tangent1), dot(diff, tangent2)), center.w);\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/min(iResolution.x, iResolution.y) * 2.0;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(sphere(uv, m.x * 10.0, m.y * 5.0), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cGfDV","date":"1734446260","viewed":85,"name":"Eyeball Ball","username":"weasel","description":"A fun eye texture to visualize voronoi shaders. Got the idea from https://www.shadertoy.com/view/Md3SDf","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","texture","eye"],"hasliked":0,"parentid":"","parentname":""}}