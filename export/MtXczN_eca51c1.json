{"ver":"0.1","info":{"id":"MtXczN","date":"1503695597","viewed":195,"name":"TravelLord","username":"xinux","description":"test","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfXWX","filepath":"https://soundcloud.com/helmer-ignacio-morales-aranda-1/escape-from-the-city-espa-ol","previewfilepath":"https://soundcloud.com/helmer-ignacio-morales-aranda-1/escape-from-the-city-espa-ol","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nmat3 rotX(float rot)\n{\n    return mat3(\n        vec3(1.0, .0, .0), \n        vec3(.0, cos(rot), -sin(rot)), \n        vec3(.0, sin(rot), cos(rot))\n        );\n}\n\nmat3 rotY(float rot)\n{\n    return mat3(\n        vec3(cos(rot), .0, sin(rot)), \n        vec3(.0, 1.0, .0), \n        vec3(-sin(rot), .0, cos(rot))\n        );\n}\n\nmat3 rotZ(float rot)\n{\n    return mat3(\n        vec3(cos(rot), -sin(rot), .0), \n        vec3(sin(rot), cos(rot), .0), \n        vec3(.0, .0, 1.0)\n        );\n}\n\nfloat displacement(vec3 p, float k)\n{\n\treturn sin(k*p.x)*sin(k*p.y)*sin(k*p.z);\n}\n\nvec4 scene(vec3 pos)\n{\n    float n = iTime;\n    \n    vec3 tPos = pos + vec3(0., 0., -iTime * 35.);\n    \n    vec3 c = texture(iChannel0, tPos.xz * 0.01 + 0.5).rgb;\n    //float noise = texture(iChannel0, tPos.xz / 100.).g * 2.;\n    //float noise = \n    float noise = (c.r + c.g + c.b) * 0.7;\n    float terrain = -tPos.y + noise\n        * sin(1.57 + tPos.x * 0.4) * 2.;\n    \n    pos *= rotX(-0.1);\n    pos *= rotY(-iTime * 3.14);\n    \n    float pillar = box(pos + vec3(0., -1., 2.) + sin(pos.y + iTime) / (sin(iTime) * 2. + 8.), vec3(0.2, 100., 0.2));\n    \n    float pillar_noise = texture(iChannel0, tPos.xy * 0.01).r;\n    pillar -= pillar_noise;\n    \n    float ground = smin(pillar, terrain, 3.);\n    \n    c = texture(iChannel3, tPos.xz * 0.1).rgb;\n    \n    vec3 pillar_c = texture(iChannel1, tPos.xy * 0.1 + vec2(iTime, -iTime * 2.5)).rgb;\n    \n    float pillar_c_w = min(1., ground + pillar);\n    \n    c = pillar_c * (1. - pillar_c_w) + c * pillar_c_w;\n    \n    return vec4(c, ground);\n    \n    //float n = iTime * 2.2;\n    //float rot = n * 0.4;\n    //pos += vec3(tan(n) * 0.5, cos(n / 2.) * 0.5, sin(n) * 0.5);\n    \n    //vec3 off = vec3(2.5);\n    \n    //float cells = sphere(mod(pos + off, 5.) - off, 1.5) + displacement(pos, 1.0 + tan(n) * 1.2);\n    //return cells;\n    //return max(cells, sphere(pos, 2.5 + tan(n) * 1.));\n    //return max(cells, sphere(pos, 7.) + displacement(pos, 1.0 + tan(n)) * 0.5);\n    //return smin(sphere(pos, 2.5), box(pos, vec3(1.5)), 1.);\n}\n\nfloat random1d(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraOrigin = vec3(.0, -0.4, 8.0);\n    cameraOrigin += vec3(sin(iTime) * 3., sin(iTime * 0.4) * 0.5, sin(iTime) * 1.); // gungis\n    //cameraOrigin += vec3(0., 0., -iTime * 25.); \n    vec3 cameraTarget = cameraOrigin + vec3(.0, -1., -10);\n    vec3 upDirection = vec3(.0, 1.0, .0);\n    upDirection *= rotZ(sin(iTime * 2.) * 0.1); // gungis\n    upDirection *= rotX(-abs(sin(iTime * 0.3)) * 0.7);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    screenPos += (vec2(random1d(iTime),random1d(iTime + 1.0)) - 0.5)* 0.02;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const float MAX_DIST = 80.0;\n    const float EPSILON = 0.001;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    vec3 color = vec3(0.);\n    vec4 dist_color = vec4(EPSILON, vec3(0.));\n\n    for(int i = 0; i < 200; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n        \n\t\tdist_color = scene(pos);\n        color = dist_color.rgb;\n        dist = dist_color.a;\n        \n        //dist = scene(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n    \n    vec3 bgColor = vec3(0.2, 0.3, 0.45) * 1.0;\n    vec3 fadeColor = vec3(0.3, 0.31, 0.3);\n    \n    if(dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            scene(pos + eps.yxx).a - scene(pos - eps.yxx).a,\n            scene(pos + eps.xyx).a - scene(pos - eps.xyx).a,\n            scene(pos + eps.xxy).a - scene(pos - eps.xxy).a));\n        \n        float diffuse = max(.0, dot(-rayDir, normal));\n        //float diffuse = max(.0, dot(normalize(vec3(0., -100., 5.)), normal));\n        float specular = pow(diffuse, 60.0);\n        \n        vec3 result = vec3(diffuse + specular);\n        \n        //color = color * 0.6 + fadeColor * 0.4;\n        result = result * normalize(fadeColor) * 0.8 + bgColor * 0.4 + 0.05;\n        \n        result *= color * 1.3;\n        \n        fragColor = vec4(result, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(texture(iChannel1, screenPos * 0.25 - 0.5 + vec2(0., iTime * 0.03)).rgb, 1.0) * 0.6;\n    }\n}","name":"Image","description":"","type":"image"}]}