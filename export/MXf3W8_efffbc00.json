{"ver":"0.1","info":{"id":"MXf3W8","date":"1707464763","viewed":190,"name":"Pathtracer3-2024-02-08","username":"banni","description":"Pathtracer","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    color = ACESFilm(color);\n    // convert from linear to sRGB for display\n    color = LinearToSRGB(color);\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nCommon functions taken from https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/\n*/\n\n\n// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\n\n// number of ray bounces allowed max\nconst int c_numBounces = 8;\n\n// a multiplier for the skybox brightness\nconst float c_skyboxBrightnessMultiplier = 2.0f;\n    \n// a pixel value multiplier of light before tone mapping and sRGB\nconst float c_exposure = 0.5f; \n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 8;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nconst float KEY_SPACE = 32.5/256.0;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nstruct Hitstruct\n{\n    float t;\n    vec3 n;\n    vec3 emissive;\n    float spec;\n    float roughness;\n    vec3 albedo;\n    vec3 specularColor;\n};\n\n//Inigo's box sdf - https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p, inout Hitstruct i)\n{\n    float d;\n    float d2;\n    //sphere\n    vec3 q = p;\n    d = length(q + vec3(0,.5 ,-1.7)) - 1.;\n    if (d < .001)\n    {\n        i.albedo = vec3(.9, .5, .1);\n        i.emissive = vec3(0);\n        i.spec = 0.3;\n        i.roughness = 0.2;\n        i.specularColor = vec3(.9);\n        return d;\n    }\n    //ground\n    q = p;\n    d2 = q.y + 1.5;\n    if (d2 < .001)\n    {\n        i.albedo = vec3(.9);\n        i.emissive = vec3(0);\n        i.spec = 1.;\n        i.roughness = 0.2;\n        i.specularColor = vec3(.5);\n        return d2;\n    }\n    d = min(d, d2);\n    \n    vec2 dim = vec2(2.5,.1);\n    vec2 off = vec2(2.5,0.);\n    d2 = sdBox(q - off.yxy, dim.xyx);\n    \n    //ceil\n    q = p;\n    if (d2 < .001)\n    {\n        i.albedo = vec3(.9);\n        i.emissive = vec3(0);\n        i.spec = 0.;\n        i.roughness = .0;\n        i.specularColor = vec3(0.);\n        return d2;\n    }\n    d = min(d,d2);\n    //right wall\n    q = p;\n    d2 = sdBox(q - off.xyy, dim.yxx);\n    if (d2 < .001)\n    {\n        i.albedo = vec3(.1, .9, .1);\n        i.emissive = vec3(0);\n        i.spec = 1.;\n        i.roughness = .0;\n        i.specularColor = vec3(.2, .9, .2);\n        return d2;\n    }\n    d = min(d,d2);\n    \n    //left wall\n    q = p;\n    d2 = sdBox(q + off.xyy, dim.yxx);\n    if (d2 < .001)\n    {\n        i.albedo = vec3(.9, .1, .1);\n        i.emissive = vec3(0);\n        i.spec = 1.;\n        i.roughness = .1;\n        i.specularColor = vec3(.9, .2, .2);\n        return d2;\n    }\n    d = min(d,d2);\n    \n    //back wall\n    q = p;\n    d2 = sdBox(q - off.yyx, dim.xxy);\n    if (d2 < .001)\n    {\n        i.albedo = vec3(.9);\n        i.emissive = vec3(0);\n        i.spec = 0.;\n        i.roughness = .0;\n        i.specularColor = vec3(0.);\n        return d2;\n    }\n    d = min(d,d2);\n    \n    //light \n    q = p;\n    d2 = sdBox(q - off.yxy + vec3(0,.09,1.1), dim.xyx * .5);\n    if (d2 < .001)\n    {\n        i.albedo = vec3(.9);\n        i.emissive = vec3(.1, .1, .9) * texture(iChannel3, -p.xz * .25).rgb * 20.;\n        i.spec = 0.;\n        i.roughness = .0;\n        i.specularColor = vec3(0.);\n        return d2;\n    }\n    d = min(d,d2);\n    return d;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(.001, 0.);\n    Hitstruct i;\n    return normalize(\n        vec3(\n            map(p + e.xyy,i) - map(p - e.xyy,i),\n            map(p + e.yxy,i) - map(p - e.yxy,i),\n            map(p + e.yyx,i) - map(p - e.yyx,i)\n        )\n    );\n}\n\nvoid Rayintersect(vec3 ro, vec3 rd, inout Hitstruct i)\n{\n    for (float t = 0.; t < 20.;)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p, i);\n        if (d < .001)\n        {\n            i.n = calcNormal(p);\n            i.t = t;\n            break;\n        }\n        t += d;\n    }\n}\n\nvec3 GetRayColor(vec3 ro, vec3 rd, inout uint rngstate)\n{\n    vec3 ret = vec3(0);\n    vec3 throughPut = vec3(1);\n    vec3 rayOrigin = ro;\n    vec3 rayDirection = rd;\n    for(int bounce = 0; bounce < 5; ++bounce)\n    {\n          Hitstruct i;\n          i.t = -1.;\n          Rayintersect(rayOrigin, rayDirection, i);\n          if (i.t < 0.)\n          {\n              ret += SRGBToLinear(texture(iChannel1, rayDirection).rgb) * throughPut * .5;\n              break;\n          }\n          rayOrigin = rayOrigin + rayDirection * i.t + i.n * .001;\n          \n          vec3 rdDiffuse = normalize(i.n + RandomUnitVector(rngstate));\n          vec3 raySpecular = normalize(reflect(rayDirection, i.n));\n          raySpecular = normalize(mix(raySpecular, rdDiffuse, i.roughness * i.roughness));\n          float doSpec = RandomFloat01(rngstate) < i.spec ? 1. : .0;\n          \n          \n          rayDirection = mix(rdDiffuse, raySpecular, doSpec);\n          ret += i.emissive * throughPut;\n          throughPut *= mix(i.albedo, i.specularColor, doSpec);\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngstate = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngstate), RandomFloat01(rngstate)) - 0.5f;\n    vec2 uv = (2. * (fragCoord.xy + jitter) - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0,0,-7);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    vec3 col = GetRayColor(ro, rd, rngstate);\n    \n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n\n    // show the result\n    fragColor = vec4(col, blend);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}