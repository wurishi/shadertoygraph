{"ver":"0.1","info":{"id":"3dfSRn","date":"1550360629","viewed":88,"name":"Cubesflower","username":"bignobody","description":"Playing with Raymarching and Moir√© patters and accidentally made this by overlapping cubes a little. As before, thanks to jlwong and iq for the tutorials!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define EPSILON 0.0001\n#define MAX_DIST 255.0\n\nfloat sphereSDF(vec3 p)\n{\n \treturn length(p)-1.0;   \n}\n\nfloat sdBox( in vec3 p, in vec2 b )\n{\n    vec3 d = abs(p)-vec3(b,sqrt(b.x*b.y));\n    return length(max(d,vec3(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n  //  return sphereSDF( q );\n    return sdBox(q, vec2(0.177,0.177));\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return opRep(p, vec3(0.4,0.4,0.4));\n}\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n\t        return depth;\n    \t}\n    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 castRay(float fov, vec2 imgSize, vec2 uv)\n{\n \tvec2 xy = uv - imgSize / 2.0;\n\tfloat z = imgSize.y / tan(radians(fov) / 2.0);\n\treturn normalize(vec3(xy, -z));   \n}\n\nvec3 estimateNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) \n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) \n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0.0,0.0,4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 dc = uv - vec2(0.5);\n\t//uv = uv * 2.0 - 1.0;\n    vec3 ray = castRay(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0,0.0,30.0-(iTime*0.5)); //vec3(0.0+cos(iTime),0.0+sin(iTime),50.0 - (iTime * 10.9));\n    float d = distToSurface(eye,ray, 0.0,MAX_DIST);\n    vec3 col = vec3(0.0);\n    vec3 p = eye + ray * d;\n   // vec3 col = estimateNormal(p) + vec3(sin(d*iTime), cos(d*iTime), cos(d*d*iTime));\n    //vec3 col = estimateNormal(p);\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n\n    if (d < MAX_DIST-EPSILON)\n    {\n\t   col = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    }\n    \n    \n    float t = iTime * 0.33;\n    mat3 m = mat3(cos(t),-sin(t),0.0,sin(t),cos(t),0.0,0.0,0.0,1.0);\n    mat3 sm = mat3(0.99,0.0,0.0,0.0,0.99,0.0,0.0,0.0,1.0);\n    //p = p * m;\n    \n    ray = ray * m;\n    ray = ray * sm;\n        \n    d = distToSurface(eye,ray, 0.0,MAX_DIST);\n    vec3 col2 = vec3(0.0,0.0,0.0);\n    if (d < MAX_DIST-EPSILON)\n    {\n\t\tp = eye + ray * d;     \t\n      \tcol2 = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    }\n    \n\t\n    col = mix(col,col2,0.5);\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}