{"ver":"0.1","info":{"id":"4cfSz4","date":"1704972205","viewed":136,"name":"Stereographic projection sphere","username":"SashaMogus","description":"Sphere goes weee.\nUse mouse to roll the sphere.\n\nEdit: Thank you for 5 likes!!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","projection","stereographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n#define PI 3.14159265359\n\nmat2 rot( in float a )\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// http://iquilezles.org/articles/intersectors/\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 calcColor( in vec2 uv )\n{\n    vec2 m = (iMouse.xy*2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    ro.yz *= rot(PI/2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.yz *= rot(PI/2.0);\n\n    vec3 col = vec3(0.0);\n    \n    float sphereSize = 0.5;\n    vec3 spherePos = vec3(0.0);\n    \n    vec2 isc = sphIntersect(ro, rd, spherePos, sphereSize);\n    vec3 p = ro + rd*isc.x;\n    vec3 renderP = p;\n    vec3 n = normalize(p);\n    bool table = isc.y < 0.0;\n    \n    if (table)\n    {\n        float table = -0.5;\n        float dtable = (table - ro.y) / rd.y;\n        p = ro + rd*dtable;\n        renderP = p;\n        n = vec3(0.0, 1.0, 0.0);\n        \n        vec3 projOrigin = spherePos + vec3(0.0, sphereSize-0.01, 0.0);\n        vec3 toProj = normalize(projOrigin - p);\n        isc = sphIntersect(p, toProj, spherePos, sphereSize);\n        p = p + toProj*isc.x;\n    }\n    \n    float d = length(ro - p);\n    \n    vec3 tex = normalize(p - spherePos);\n    if (iMouse.z > 0.0)\n    {\n        tex.xy *= rot(m.x);\n        tex.yz *= rot(m.y);\n    } else {\n        tex.yz *= rot(iTime);\n    }\n    \n    col += texture(iChannel0, tex.xz).xyz*0.5;\n    col += texture(iChannel0, tex.xy).xyz*0.5;\n    \n    // diffuse light\n    vec3 lightPos = vec3(-0.4, 1.5, -0.2);\n    vec3 toLight = normalize(lightPos - renderP);\n    col *= (0.3 + dot(n, toLight)*0.7);\n    \n    // specular light\n    vec3 h = normalize(rd + toLight);\n    float spec = pow(max(dot(n, h), 0.0), 2.0);\n    col += spec*0.4;\n    \n    // cast shadow\n    if (table)\n    {\n        isc = sphIntersect(renderP, toLight, spherePos, sphereSize);\n        if (isc.y > 0.0)\n        {\n            col *= 0.3;\n        }\n    }\n    \n    col /= length(uv)*0.1 + 1.0;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    #if AA > 1\n        for (int m = 0; m < AA; m += 1)\n        for (int n = 0; n < AA; n += 1)\n        {\n        {\n            col += calcColor(uv + (vec2(m, n)/iResolution.xy))/float(AA*AA);\n        }\n        }\n    #else\n        col = calcColor(uv);\n    #endif\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}