{"ver":"0.1","info":{"id":"ws2cDc","date":"1587485281","viewed":50,"name":"Tentacule test 4","username":"poipoi34","description":"a","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["c"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define PI 3.1415\n\n\n\nmat3 rotTentacule(vec3 p)\n{\n    float ampli = 2.;\n    float t = iTime - 0.2*length(p);\n    return rotY(cos(t) * ampli *1.7) * rotZ(sin(t) * ampli);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\nfloat smin( float a, float b)\n{\n\n    return smin(a,b,25.);\n}\n\nstruct RM{\n    float d;\n    int steps;\n};\n    \nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat GetDist(in vec3 p){\n    \n    \n    p = rotTentacule(p)*p;\n    p -= vec3(0,4,0);\n    vec3 pbox2 = rotZ(PI/4.)*p;\n    pbox2 -= vec3(3.7,1.6,0);\n    \n    vec3 pboxi = p;\n    \n    float dmin = sdBox(p,vec3(1,3,1));\n        \n    for (int i =0; i<8;i++)\n    {\n        pboxi = rotZ(PI/4.)*pboxi - vec3(3.7,1.6,0);\n        dmin = min(dmin,sdBox(pboxi,vec3(1,3,1)));\n    }\n        \n    \n    \n    //return min( sdBox(p,vec3(1,3,1)), sdBox(pbox2,vec3(1,3,1)) );\n    return dmin;\n}\n\n\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.1,0);\n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n    \n}\n\n\nvec3 derivativeDist (vec3 p)\n{\n    float d = GetDist(p);\n    float eps = 0.1;\n    vec2 e = vec2(eps,0);\n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy)/eps,\n        GetDist(p-e.yxy)/eps,\n        GetDist(p-e.yyx)/eps);\n    return n;\n}\n\nRM RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    int steps = 0;\n    for(int i=0;i<MAX_STEPS;i++){\n        steps = i;\n        vec3 p = ro + rd*d0;\n        float dS = GetDist(p)/10.;\n        d0 += dS;\n        if (d0>MAX_DIST || dS < SURF_DIST) break;\n    }\n\n    return RM(d0,steps);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    vec3 ro = vec3(0,0,-30.);\n    vec3 rd = normalize(vec3(uv,1.0));\n    RM rm = RayMarch(ro,rd);\n    \n    float d = rm.d;\n    \n    \n    \n    \n    vec3 col = vec3(0);\n\t\n    if (d<50.)\n    \tcol += 0.5+0.5*GetNormal(ro+rd*d); //normals\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nmat4 rot(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nvec3 crossProduct (vec3 p1,vec3 p2)\n{\n    return vec3(p1.y*p2.z-p1.z*p2.y,p1.z*p2.x-p1.x*p2.z,p1.x*p2.y-p1.y*p2.x);\n}\n\nfloat dBox(vec3 p,vec3 size)\n{\n    return length(max(vec3(0.,0.,0.),abs(p)-size/2.));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}","name":"Common","description":"","type":"common"}]}