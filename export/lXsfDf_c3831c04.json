{"ver":"0.1","info":{"id":"lXsfDf","date":"1729032016","viewed":32,"name":"Orbiter","username":"MattSzymonski","description":"Orbiting circle","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize the pixel coordinates (from -1 to 1) and maintain aspect ratio\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n\n    // Time-based rotation angle (for both circles)\n    float angle = iTime;\n\n    // Anti-aliasing factor\n    float blur = 1.5 / iResolution.x;\n\n    // First Circle Parameters\n    float c1_radius = 0.1;\n    float c1_borderThickness = 0.01;\n    vec4 c1_borderColor = vec4(1.0);\n    vec4 c1_fillColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Rotate circle 1 center position\n    vec2 c1_center;\n    c1_center.x = cos(angle) * c1_radius;\n    c1_center.y = sin(angle) * c1_radius;\n\n    // Calculate distance from circle 1's center\n    float c1_dist = length(uv - c1_center) - 0.2;\n\n    // First circle color\n    vec4 color = vec4(0.0);\n    color += smoothstep(blur, 0.0, abs(c1_dist) - c1_borderThickness) * c1_borderColor;\n    color += smoothstep(0.0, blur, c1_dist) * c1_fillColor;\n\n\n\n    // Second Circle Parameters\n    float c2_radius = 0.30;\n    float c2_borderThickness = 0.01;\n    vec4 c2_borderColor = vec4(1.0);\n    vec4 c2_fillColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Second circle is stationary at the bottom\n    vec2 c2_center = vec2(0.0, -0.0);\n\n    // Calculate distance from circle 2's center\n    float c2_dist = length(uv - c2_center) - c2_radius;\n\n    // Add second circle's color\n    color += smoothstep(blur, 0.0, abs(c2_dist) - c2_borderThickness) * c2_borderColor;\n    color += smoothstep(0.0, blur, c2_dist) * c2_fillColor;\n\n    // Output the final color\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}