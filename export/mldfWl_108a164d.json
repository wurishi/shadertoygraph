{"ver":"0.1","info":{"id":"mldfWl","date":"1701736562","viewed":36,"name":"cosmos fly mosaic","username":"nayk","description":"cosmos, rotate,sky, copypast","likes":4,"published":1,"flags":1,"usePreview":0,"tags":["rotate","sky","cosmos","copypast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* original https://www.shadertoy.com/view/cttXRl original https://www.shadertoy.com/view/lslyRn*/\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.0000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define S smoothstep\n#define TAU 6.283185\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(12.3,24.3));\n    p += dot(p, p+234.2);\n    return fract(p.x*p.y);\n}\n\nfloat Length(vec2 p, float k) {\n    \n    return pow(pow(abs(p.x), k)+pow(abs(p.y), k), 1./k);\n}\n\nvec3 Tile(vec2 uv, float level, float n, float k) {\n    float maxBlur = (1.+level*.1)*50./iResolution.y;//.05/level;\n    \n    float lev = 8.005/level;\n    \n    if(n<9.5) uv.x *= -1.;\n    if(fract(n*100000000000000.)<0.5) uv.y *= -1.0305;\n        \n        \n    uv +=.5005; \n    \n    float m, w;\n    w = maxBlur;//min(.1, 2.*fwidth(uv.y*lev));\n        \n    if(fract(n*200.3)<.12*level) {\n        if(n<.5005) uv = uv.yx;\n        w = maxBlur;//min(.1, 2.*fwidth(uv.y*lev));\n        m = S(w, -w, abs(fract(uv.y*lev)-.5005)-.25);\n    } else {\n        float d1 = Length(uv, k);\n       // w = maxBlur;//min(fwidth(d1)*5., maxBlur);\n\n        float c1 = S(.01, -.01, d1-1.005);\n        float t1 = c1*S(w, -w, abs(fract(d1*lev)-.5005)-.25);\n\n        float d2 = Length(uv-1.0005, k);\n        float w2 = w;//min(fwidth(d2)*5., maxBlur);\n\n        float c2 = S(.01, -.01, d2-1.);\n        float t2 = c2*S(w2, -w2, abs(fract(d2*lev)-.5)-.25);\n\n        m = mix(t1, t2, S(.025, -.025, d2-(1.-(level-1.)*.003)));\n    }\n    \n    return m*vec3(1);\n}\n\nvec2 sabs(vec2 p, float k) {\n    return sqrt(p*p+k);\n}\n\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.1; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n#define R(p,a,r) mix(a*dot(p,a),p,cos(r)) + sin(r)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvec3 color(float t) {\n  vec3 c1 = vec3(1.0, 0.0, 0.0);\n  vec3 c2 = vec3(0.0, 1.0, 0.0);\n  vec3 c3 = vec3(0.0, 0.0, 1.0);\n  vec3 c4 = vec3(1.0, 1.0, 0.0);\n  vec3 c5 = vec3(1.0, 0.0, 1.0);\n  vec3 c6 = vec3(0.0, 1.0, 1.0);\n\n  float r = cos(t) * 0.5 + 0.5;\n  if (r < 0.23) return mix(c1, c2, r * 5.0);\n  if (r < 0.44) return mix(c2, c3, (r - 0.2) * 5.0);\n  if (r < 0.65) return mix(c3, c4, (r - 0.4) * 5.0);\n  if (r < 0.86) return mix(c4, c5, (r - 0.6) * 5.0);\n  return mix(c5, c6, (r - 0.8) * 7.0);\n}\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\tvec2 M = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    uv *= 5.6;\n    \n    float k = 5.001;\n    \n    float cd = length(uv);\n    float t = M.x*1600.;\n    t = mod(iTime, 1160.);\n    uv *= Rot(t*TAU/16.+sin(t*TAU/8.)*cd*.25);\n    uv = vec2(8.*(atan(uv.x, uv.y)/6.2832+.5), log2(cd)-t);\n\n    vec2 gv = fract(uv)-.5;\n    vec2 id = mod( floor(uv), 16.);\n    \n    float n = Hash21(id);\n    \n    float shape = 2.;\n    float checker = floor(mod(id.x+id.y, 2.));\n    col = Tile(gv, 1., n, shape);\n    //col *= 0.; col += checker;\n    //if(gv.x>.48 || gv.y>.48) col = vec3(1,0,0);\n   vec4 fragColor2 = vec4(0);\n    vec3 p, r = iResolution, d = normalize(vec3((fragCoord-.5*r.xy)/r.y,0.7));  \n    float t2 = mod(iTime*0.5,4.);\n    \n    for(float i = 0., g = 0., e, s; i < 99.; ++i)\n    {\n        p = g * (d);\n         p.z = tan(iTime*0.2);\n          float t = mod(iTime*0.5,4.);\n   \n        p.z -= 0.60;\n        p = R(p, normalize(vec3(1,2,3)), iTime * 0.0);\n        s = 2.;\n p.z = tan(iTime*0.2);\n        for(int j = 0; j++ < 14;)\n        {\n            p = abs(p);\n            p = p.x < p.y ? p.zxy : p.zyx;\n            s *= e = 1.8 / min(dot(p, p), 1.3);\n   \n            p = p * e - vec3(15,3,2);\n        }\n\n        g += e = length(p.xz) / s;\n        fragColor2.rgb += color(iTime * 0.1 + cos(i)) * mix(r / r, H(log(s)), 0.7) * 0.08 * exp(-i * i * e);\n    }\n     \n    if(fract(n*2500.)<.25) {\n        vec2 gv2 = fract(gv*2.)-.5;\n        vec2 id2 = floor(gv*2.);\n        float n2 = Hash21(id2+id);\n        \n        col = Tile(gv2, 2., n2, shape);\n        //if(gv2.x>.48 || gv2.y>.48) col = vec3(0,1,0);\n    \n        if(fract(n2*25000.)<.25) {\n            vec2 gv3 = fract(gv2*2.)-.5;\n            vec2 id3 = floor(gv2*2.);\n            float n3 = Hash21(id+id2+id3);\n            \n            col = Tile(gv3, 4., n3, shape);\n           // if(gv3.x>.48 || gv3.y>.48) col = vec3(0,0,1);\n            \n            if(fract(n3*25.)<5.25) {\n                vec2 gv4 = fract(gv3*2.)-.5;\n                vec2 id4 = floor(gv3*2.);\n                float n4 = Hash21(id+id2+id3+id4);\n                \n                col = Tile(gv4, 8., n4, shape);\n                //if(gv4.x>.48 || gv4.y>.48) col = vec3(1,0,1);\n            }  \n        }    \n    }\n    \n   col = mix(col, vec3(.5), S(.8, .05, cd));\n    if(false) {\n        col *= 0.; \n        uv *= .5;\n        col += Tile(uv, 1., 1.8, 2.);\n        \n        if(uv.x<-.5 || uv.x>.5 || uv.y<-.5||uv.y>.5) col *= 0.61;//vec3(0,0,1);\n    }\n\tvec3 from=vec3(1.,.5,0.5)*col*fragColor2.xyz;\n\tfrom+=vec3(time*2.,time,-2.);\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n     fragColor*= pow(fragColor2, vec4(0.2));\n     \n  \n}\n","name":"Image","description":"","type":"image"}]}