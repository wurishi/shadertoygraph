{"ver":"0.1","info":{"id":"WdlyWN","date":"1584815249","viewed":53,"name":"heavy metal torus","username":"tristanwhitehill","description":"weee","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .3\n\nvec2 hash( vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*sin( (iTime*.04)*130.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s , c);\n    \n}\n\nfloat sine(float rate){\n    return sin(iTime*rate);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return (length(q)-t.y);\n}\nfloat GetDist (vec3 p){\n \n   float n = noise(20.5*(iResolution.xy*.05));\n    //put the shape to march to in a position and the last value of the vec4 is the radius\n\tvec4 shape = vec4(0.,1,2.,0.);\n    vec4 shape2 = vec4(0.,1.,2.,0.);\n    vec4 shape3 = vec4(0.,1.,2.,0.);\n    \n   vec3 bp = p-shape.xyz;\n    bp.xy *= rot(iTime);\n   vec3 bp2 = p-shape2.xyz;\n    bp2.xy *= rot(-iTime);\n   vec3 bp3 = p-shape3.xyz;\n    bp3.yz *= rot(iTime);\n        \n    //distance to shape from current position, position - shape xyz then - the radius\n    //float sDist =(length(p-(shape.xyz))-shape.w);\n    float bd = sdTorus(bp, vec2(sine(.9)*6.,0.3));\n    bd -= sin(p.x*.2*iTime*.03)*.2;\n    float bd2 = sdTorus(bp2, vec2(sine(.6)*5.,0.2));\n    bd2 -= cos(p.y*.2*iTime*.03)*.2;\n    float bd3 = sdTorus(bp3, vec2(sine(.8)*2.,0.2));\n    bd3 -= sin(p.x*.2*iTime*.03)*.2;\n    //plane distance is the camera's y value\n    float pDist = p.y+6.;\n    //distance till collision is the minimum of shapes distance + camera\n    float d = min(bd2, pDist);\n    d = min(d, bd);\n    d = min(d, bd3);\n    return d;\n    \n    \n}\n\n\nfloat rayMarch (vec3 rayO, vec3 rayD){\n    float distO = 0.;\n        //keeping track of origin of distance loop in vec3 space//\n        \n        //loop that manages a number of steps we take till our ray intersects with the object//\n    for(int i=0; i<MAX_STEPS; i++){\n            //sum the ray source and object orientation and multiply by the ray direction\n            vec3 p= rayO+distO*rayD;\n            //scene orientation//\n            float distSc = GetDist(p);\n            //update distance of step in corellation to scene orientation//\n            distO += distSc;\n            //check if in contact with minimum size of intersection flag, and also the max number \n            //of steps we want to take in the scene declared above//\n            if(distSc<SURF_DIST || distO>MAX_DIST) break;\n        }\n            return distO;\n        }\n    \nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(3, 7, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), .2, 1.);\n    float d = rayMarch(p+n*SURF_DIST*7., l);\n    if(d<length(lightPos-p)) dif *= 3.1;\n    \n    return dif;\n}\n\nfloat getLight2(vec3 p) {\n    vec3 lightPos = vec3(0, 20, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*6.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.3, 1.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized canvas// 0 in middle//\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     float n = noise(2.5*(iResolution.xy*.5));\n\n    vec3 col = vec3(.9,.0,.4);\n    vec3 col2 = vec3(.2,.0,.9);\n    \n    //ray Position//\n    vec3 rayO = vec3(0.,0.,-10.0);\n    \n    //ray Direction//\n    vec3 rayD = normalize(vec3(uv.x,uv.y,1.));\n   \n    float d = rayMarch(rayO,rayD);\n     vec3 p = rayO + rayD *d;\n     d /= 5.;\n    float dif = getLight(p);\n    float dif2 =getLight2(p);\n    col = vec3(dif*col);\n    col2 = vec3(dif2*col2);\n   \n    fragColor = vec4((col+col2),1.0);\n}","name":"Image","description":"","type":"image"}]}