{"ver":"0.1","info":{"id":"lcKGzz","date":"1712345737","viewed":59,"name":"Maw Cave","username":"plinko","description":"Raymarch shader that rotates rays and mixes different SDF's to shift between a cave, and the mouth of a creature.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Polynomial smooth min function taken from: https://www.shadertoy.com/view/Ml3Gz8\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0) / k;\n    return min(a,b) - h*h*h*k*(1./6.);\n}\n\n// The following sdf functions are pulled from: https://iquilezles.org/articles/distfunctions/\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Standard 2D rotation function\nmat2 rot2D(float angle) {\n\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n\n}\n\n// This function checks distance between raymarch points and SDFs\nfloat map(vec3 p)\n{\n    // TO TRANSLATE: change the \n    // TO SCALE: multiply or divide the input position p, then handle artifcats by multiplying sdf function by inverse of this scale\n    // TO ROTATE: swizzle the ray input position, excluding the axis that we want as the axis of rotation\n    // TO DO SPACE REPITITION: translate each cube, and mod it\n    \n    // Camera position translation\n    p.z += iTime*0.3;\n    p.y -= 0.6;\n    \n    // Tongue is just a series of space repeated spheres along the z axis\n    vec3 t = p;\n    t.y += 19.;\n    t.z = mod(t.z, 1.) - 0.5;\n    float tongue = sdSphere(t * vec3(.1,1.,1.), 2.1);\n    \n    // \"Drips\" from the teeth/stalactites\n    vec3 s1 = p;\n    vec3 s2 = p;\n       \n    //One of the spheres is slightly offset so that it looks more like a dripping effect\n    s2.y += 0.2;\n    \n    // Cone\n    vec3 c = p;\n    \n    // Rotate cone so that its upside down\n    c.yz *= rot2D(3.14);\n    \n    //Repeat cone and spheres along the x and z axis\n    c.xz = mod(c.xz,1.) - 0.5;\n    s1.xz = mod(s1.xz,1.) - 0.5;\n    s2.xz = mod(s2.xz,1.) - 0.5;\n    \n    // Spheres are gonna move downwards, use mod to make them repeat    \n    vec3 s1Pos = vec3(0.,-(mod(iTime*0.9, 5.5))+1.,0.);\n    vec3 s2Pos = vec3(0.,-(mod(iTime*0.9, 5.5))+1.,0.);\n    \n    // The reason we use the mix function here is so that the spheres don't linger past the point of them being \"visible\". This\n    // causes them to still contribute to colour even when they've disapeared, making the \"loop\" a lot more noticable unless\n    // this mix function is used to force it to a high value so that it fully disapears\n    float sphere1 = mix(0.,2.,sdSphere(s1 - s1Pos, 0.1+(s1.y*0.1)));\n    float sphere2 = mix(0.,2.,sdSphere((s2*0.5) - s2Pos, 0.1+(s1.y*0.1)));\n    \n    // Cone sdf with a couple translations\n    float cone = sdCone(c - vec3(0.,0.4,0.), vec2(0.3,1.3), 1.);\n    \n    // No SDF needed for the plane, the ray's y position can be used to represent it's \"height\" above the ground, and\n    // this can then be used during the smin distance blending\n    float plane = -p.y + 1.2;\n    \n    // Use smoothmin funciton to blend between SDF objects\n    return smin(smin(smin(smin(smin(sphere1, sphere2, 0.5), cone, 0.1), plane, 2.4), 1.3, 1.), tongue, 1.);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NOTE: the following code is my own, but heavily follows methodologies explained in the following video\n    // by youtuber kishimisu: https://www.youtube.com/watch?v=khblXafu7iA&ab_channel=kishimisu\n\n    // Set coordinate space to be from -1 to 1\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n   \n    // Ray origin will be 3 units behind the camera\n    vec3 ro = vec3(0, 0, -3.);\n    \n    // Now have each ray project 'out' of the screen\n    // NOTE: we can multiply uv.xy to change FOV here\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    \n    // Eventual final color\n    vec3 col = vec3(0.4,0.4,0.4);\n\n    // Total distance travelled\n    float t = 0.;\n    \n    // Time to raymarch\n    int i;\n    for(i = 0; i < 80; i++)\n    {\n        vec3 p = ro + rd * t; // this is a position along the ray, based on its origin and direction (t will change each march)\n        \n        p.xy *= rot2D(t*.5 * (sin(iTime*.5)*0.01+0.02)*rd.x);\n        \n        // Every \"step\" of the raymarch, check it's proximity to nearby SDF objects\n        float d = map(p); // this will also represent how far a ray can march \"safely\" without intersecting any objects\n        \n        t += d; //march the ray\n        \n        //this check will break if we are really close to an object or way too far from any object\n        if(d < 0.001 || t > 40.){break;}\n    }\n    \n    // clamp this value so that the colours aren't too intense\n    t = clamp(t, 0., 6.);\n    \n    // The red and blue channels are affected based on how many \"marches\" a ray needed to do, by using the iterator variable\n    // in the for loop\n    // The green channel changes back and forth, obscuring parts of the shader so that it looks like it's going between a \n    // cave and the mouth of a creature\n    col *= vec3(t*float(i)*0.005*sin(iTime*0.5)+0.3, t*0.1,t*float(i)*0.001);\n    \n    fragColor = vec4(col,1);\n    \n    \n}","name":"Image","description":"","type":"image"}]}