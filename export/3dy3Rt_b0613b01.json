{"ver":"0.1","info":{"id":"3dy3Rt","date":"1570710459","viewed":337,"name":"ShaderTober - Enchanted","username":"Flopine","description":"A small doodle with inktober's theme \"Enchanted\".","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voronoi","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n\nvec2 rand (vec2 x)\n{return fract(sin(vec2(dot(x, vec2(1.2,5.5)), dot(x, vec2(4.54,2.41))))*4.45);}\n\nfloat hash11 (float x)\n{return fract(sin(x*45.15)*124.5);}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.45,43.158)))*1245.5);}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a= atan(p.y,p.x);\n    float l = length(p);\n    float id = floor(a/per);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    if (abs(id) >= (rep/2.)) id = abs(id);\n    return id;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\n// voronoi function which is a mix between Book of Shaders : https://thebookofshaders.com/12/?lan=en\n// and iq article : https://iquilezles.org/articles/voronoilines\nvec3 voro (vec2 uv)\n{\n    vec2 uv_id = floor (uv);\n    vec2 uv_st = fract(uv);\n\n    vec2 m_diff;\n    vec2 m_point;\n    vec2 m_neighbor;\n    float m_dist = 10.;\n\n    for (int j = -1; j<=1; j++)\n    {\n        for (int i = -1; i<=1; i++)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = rand(uv_id + neighbor);\n            point = 0.5+0.5*sin(2.*PI*point+iTime);\n            vec2 diff = neighbor + point - uv_st;\n\n            float dist = length(diff);\n            if (dist < m_dist)\n            {\n                m_dist = dist;\n                m_point = point;\n                m_diff = diff;\n                m_neighbor = neighbor;\n            }\n        }\n    }\n\n    m_dist = 10.;\n    for (int j = -2; j<=2; j++)\n    {\n        for (int i = -2; i<=2; i++)\n        {\n            if (i==0 && j==0) continue;\n            vec2 neighbor = m_neighbor + vec2(float(i), float(j));\n            vec2 point = rand(uv_id + neighbor);\n            point = 0.5+0.5*sin(point*2.*PI+iTime);\n            vec2 diff = neighbor + point - uv_st;\n            float dist = dot(0.5*(m_diff+diff), normalize(diff-m_diff));\n            m_point = point;\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    return vec3(m_point, m_dist);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat od (vec3 p, float r)\n{return dot(p,normalize(sign(p)))-r;}\n\nfloat g1 = 0.;\nfloat room (vec3 p)\n{\n    p.y -= 5.;\n    p.y -= step(0.05,voro(p.xz).z)*0.05;\n    p.y += sin(length(p.xz*1.5)-iTime)*0.1;\n    \n    p.x -= step(0.05,voro(p.yz).z)*0.05;\n    p.x += sin(length(p.yz*1.5)-iTime)*0.1;\n    \n    float d = -box(p, vec3(10.,8.,15.));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat t_id;\nfloat g2 = 0.;\nfloat tentacles (vec3 p)\n{\n    p.xz *= rot(sin(iTime+p.y*0.8)*0.5);\n    t_id = moda(p.xz, 7.);\n\n    p.x -= 2.;\n    float d = cyl(p.xzy, 0.15 - p.y*0.1,3.);\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\n\nfloat gem (vec3 p)\n{\n    p.y -= 1.5;\n    p.xz *= rot(iTime);\n    p.xy *= rot(iTime);\n    p.y += sin(iTime)*0.5+0.5;\n    return stmin(od(p, 1.),box(p,vec3(0.9)),0.5,3.);\n}\n\nfloat SDF (vec3 p)\n{\n    return min(gem(p),min(room(p),tentacles(p)));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,2.,-5.5),\n        tar = vec3(0.,0.,0.),\n        rd = getcam(ro, tar, uv),\n        p = ro,\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p += d*rd;\n    }\n\n    float t = length(ro-p);\n    \n    col = vec3(shad);\n    col += g1 * step(voro(p.xz+p.yz).z,0.05) * vec3(0.,0.3,0.4);\n    col += g2 * vec3(hash11(t_id)*0.1,1.,hash11(t_id))*0.2;\n    \n    col = mix(col, vec3(0.2,0.2,0.3), 1.-exp(-0.018*t*t));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}