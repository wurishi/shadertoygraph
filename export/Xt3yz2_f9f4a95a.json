{"ver":"0.1","info":{"id":"Xt3yz2","date":"1533138762","viewed":355,"name":"Warping : Beier&Neely (Morphing)","username":"ttoinou","description":"I created a new morphing algorithm. After research I discovered it's a variant of an algorithm older than me called Beier-Neely. This is only the warping part with others weighting functions than the original algo. FYI : 1 morphing = blending of 2 warping","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["warping","line","deformation","image","morphing","beier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Beier & Neely Warping (Morphing)\" by ttoinou. https://shadertoy.com/view/MltyRS\n// 2018-08-01 15:50:06\n\nvoid mainImage( out vec4 col, in vec2 coord )\n{\n\tvec2 uv01 = coord.xy / iResolution.xy;\n    col = texture(iChannel0,uv01);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define SHOW_WARPING\n///#define SHOW_SEGMENT\n\n#define to01(x)  (clamp(x,0.0,1.0))\n#define to01_(x) (smoothstep(0.0,1.0,x))\n\n#define ABto01(x,a,b)  (to01( (x-a)/(b-a) ))\n#define ABto01_(x,a,b) (to01_( (x-a)/(b-a) ))\n\n#define ABtoCD(x,a,b,c,d)  (ABto01(x,a,b)*(d-c)+c)\n#define ABtoCD_(x,a,b,c,d) (ABto01_(x,a,b)*(d-c)+c)\n\nfloat SegmentsMax = 1000.;\n\nvec2[] I = vec2[] (\n  // rectangular img\n    vec2( 0 , 0 )\n  , vec2( 1000 , 0 )\n    \n  , vec2( 0 , 0 )\n  , vec2( 0 , 1000 )\n    \n  , vec2( 1000 , 1000 )\n  , vec2( 0 , 1000 )\n    \n  , vec2( 1000 , 1000 )\n  , vec2( 1000 , 0 )\n    \n    \n  // distortion vectors\n  , vec2( 0 , 150 )\n  , vec2( 200 , 220 )\n    \n  , vec2( 650 , 750 )\n  , vec2( 450 , 120 )\n);\n\nvec2[] J = vec2[] (\n  // rectangular img\n    vec2( 0 , 0 )\n  , vec2( 1000 , 0 )\n    \n  , vec2( 0 , 0 )\n  , vec2( 0 , 1000 )\n    \n  , vec2( 800 , 1000 )\n  , vec2( 0 , 1000 )\n    \n  , vec2( 800 , 1000 )\n  , vec2( 1000 , 0 )\n    \n    \n  // distortion vectors\n  , vec2( 0 , 150 )\n  , vec2( 400 , 420 )\n    \n  , vec2( 650 , 750 )\n  , vec2( 850 , 320 )\n);\n\nvec4 seg(vec2 P,vec2 A,vec2 B)\n{\n    vec4 r = vec4(.0);\n    \n    // centered around 0 now, A not mkjneeded anymore\n    B -= A;\n    P -= A;\n    \n    // compute normal of B\n    A = vec2(-B.y,B.x);\n    // is this faster ?\n    //r.x = A.y;\n    //A.y = A.x;\n    //A.x = -r.x;\n    \n    r.x = dot(P,B);\n    r.y = dot(P,A);\n    r.a = dot(B,B);\n    \n    r.z = clamp( r.x , .0 , r.a ) ;\n    \n    r.z = length(P - r.z*B/r.a);\n    //r.z = length(P-A);\n    \n    return r;\n}\n\nvoid colorSeg(out vec4 col, vec4 segCol, float dist, float thickness, float smooth_)\n{\n    col = mix(\n        col,\n        segCol,\n        segCol.a*smoothstep(thickness,.0, max(dist-smooth_,.0) )\n    );\n}\n\nfloat min2(vec2 v) { return (v.x<v.y) ? v.x : v.y;}\n\nvec2 viewport(vec2 coord)\n{\n    return (coord-iResolution.xy*.5)/min2(iResolution.xy)*2.;\n}\n\nvec2 normal(vec2 AB)\n{\n    return vec2(-AB.y,AB.x);\n}\n\n//#define epsilon (1e-3)\n#define epsilon (2e-3)\nbool PointInside01(vec2 M)\n{\n    return    M.x >= -epsilon && M.x <= 1.+epsilon\n           && M.y >= -epsilon && M.y <= 1.+epsilon\n    ;\n}\n\nvoid mainImage( out vec4 col, in vec2 coord )\n{\n\tvec2 uv01 = coord.xy / iResolution.xy;\n    vec2 uv = viewport(coord);\n    \n    col = 0.5 + 0.5*cos(iTime*.2+uv.xyxy+vec4(0,2,4,1));\n    \n    #ifdef SHOW_SEGMENT\n        vec2 P = viewport(iMouse.xy);\n        vec2 A = vec2( -.8 , cos(iTime) );\n        vec2 B = vec2( 1. , .6 );\n        vec4 P_AB = seg(P,A,B);\n        vec4 uv_AB = seg(uv,A,B);\n\n        vec2 C = (B-A)*P_AB.x/P_AB.a + A;\n        vec4 uv_AC = seg(uv,A,C);\n        vec4 uv_CP = seg(uv,C,P);\n\n\n\n        col = cos(uv_AB.y*vec4(7.,5.,3.,1.))*.5 +.5;\n\n        colorSeg(col,vec4(1.,.8,.0,1.),uv_AB.z,.01,.01);\n        colorSeg(col,vec4(.0,.4,.2,1.),uv_AC.z,.01,.01);\n        colorSeg(col,vec4(.2,.0,.9,1.),uv_CP.z,.01,.01);\n    #endif\n\n    #ifdef SHOW_WARPING\n        vec4 segmentsColor = vec4(1.,.0,.0,1.);\n        float segmentsOpacity = .4;\n        float MorphingTime = cos(iTime)*.5+.5;\n\n        // here interpolation between lines\n        for(int k = 0 ; k < J.length() ; k++ )\n        {\n            J[k] = mix( I[k] , J[k] , MorphingTime );\n        }\n\n        vec2  ImgViews  = vec2(iMouse.z > .5 ? 2. : 1.,1.);\n        float ImgAspect = .75;\n        float ImgMargin = .1;\n        vec2  TopRight   = viewport(iResolution.xy);\n        vec2  BottomLeft = viewport(vec2(.0));\n\n        vec2 ImgSize;\n        // to simplify, assuming screen X > screen Y\n        // and that it won't overfill with images in the Y axis\n        ImgSize.x = (TopRight.x - BottomLeft.x)*(1. - ImgMargin)/ImgViews.x;\n        ImgSize.y = ImgSize.x*ImgAspect;\n        vec2 ImgMargins = vec2( (TopRight - BottomLeft)-ImgViews*ImgSize )/ImgViews;\n\n        // this is forward mapping, not efficient at all\n        for(float x = .0 ; x < ImgViews.x ; x++ )\n            for(float y = .0 ; y < ImgViews.y ; y++ )\n            {\n                float i = x*ImgViews.y + y;\n                vec2 p = vec2(x,y);\n\n                vec2 BL = p*ImgSize + (p+.5)*ImgMargins + BottomLeft;\n                vec2 TR = BL + ImgSize;\n\n                vec2 M = (uv-BL)/(TR-BL);\n                vec2 Mwarped = vec2(.0);\n                vec4 colBuffer = vec4(.0);\n                float Msum = .0;\n                float Mcoeff;\n\n                if( PointInside01( M ) ) {\n\n                    for(int k = 0 ; k < I.length() ; k += 2 )\n                    {\n                        vec4 MAB = seg(M\n                           , ( (i==1.) ? I[k]   : J[k])/SegmentsMax\n                           , ( (i==1.) ? I[k+1] : J[k+1])/SegmentsMax\n                        );\n\n                        if(i==0.)\n                        {\n                            // weight function\n                            // MAB.a is segment length\n                            // MAB.z is distance from point to segment\n                            //Mcoeff = 1.; // mean affine transform\n                            \n                            //Mcoeff = exp(-8.*MAB.z*MAB.z/1.);\n                            //Mcoeff = 1./(1. + MAB.z/MAB.a);\n                            //Mcoeff = exp(-3.*MAB.z/MAB.a/1.);\n                            //Mcoeff = 1./(.2 + MAB.z );\n                            Mcoeff = exp(-5.*MAB.z/1.);\n                            Mcoeff = exp(-15.*MAB.z/sqrt(MAB.a) );\n                            Mcoeff = exp(-8.*MAB.z/sqrt(MAB.a) );\n                            Mcoeff = exp(-4.*MAB.z*MAB.z/MAB.a );\n                            \n                            // the more it decreases fast to 0\n                            // ==> the more it will interpolate\n                            // but will deform too much around the segment\n                            // while leaving the rest of the image the same\n                            // (with this example we can this why it's good\n                            // to introduce MAB.a in the formula)\n                            Mcoeff = exp(-150.*MAB.z/1.);\n                            \n                            // the slower it decreases to 0\n                            // the less it will interolate\n                            // and the more all the image will be deformed\n                            //Mcoeff = exp(-5.*MAB.z/1.);\n                            \n                            \n                            Mcoeff = exp(-6.*MAB.z*MAB.z/MAB.a );\n                            \n                            // cut tends to infinity ==> no effect\n                            // cut tends to 0 ==> discontinuities at perpendicular of\n                            //   segments vertex\n                            // cutoff ~1 ==> smooth effect, lets\n                            // areas perpendicular to the segment be more affected by the\n                            // segment warping effect\n                            // doesn't seem very useful, just an experiment\n                            float cut = 0.3;\n                            Mcoeff *= 1. - smoothstep( .0 , cut , MAB.x - MAB.a );\n                            Mcoeff *= 1. - smoothstep( .0 , -cut , MAB.x );\n                            \n                            //if( MAB.x < .0 || MAB.x > MAB.a ) Mcoeff = .0;\n                            \n                            Mwarped += ( \n                                  ( MAB.x * (I[k+1]-I[k])\n                                + MAB.y * normal(I[k+1]-I[k]) ) / MAB.a\n                                + I[k] ) * Mcoeff / SegmentsMax\n                            ;\n                            Msum += Mcoeff;\n                        }\n\n                        colorSeg(colBuffer,segmentsColor,MAB.z,.001,.001);\n\n\n                    }\n\n                    if(i==1.)\n                        Mwarped = M;\n                    else\n                        Mwarped /= Msum;\n\n                    if( PointInside01( Mwarped) )\n                    {\n                    \tcol = texture(iChannel0,Mwarped);\n                    \tcol += colBuffer*segmentsOpacity;\n                    }\n                }\n            }\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"}]}