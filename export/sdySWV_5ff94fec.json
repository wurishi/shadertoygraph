{"ver":"0.1","info":{"id":"sdySWV","date":"1635289320","viewed":466,"name":"Moomin Chasing Clouds","username":"ytt","description":"An animation attempt using SDF","likes":53,"published":1,"flags":0,"usePreview":1,"tags":["clouds","moomins"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Moomin Chasing Clouds\n//\n// Based on Inigo Quilez wonderful tutorials\n//\n// Inspired by Happy Jumping and the Moomin Japanese animated series opening\n// https://youtu.be/c0vmjpJk1eo?t=27\n//\n\n#define RENDER_MOOMIN\n#define RENDER_CLOUDS\n#define RENDER_FLOWERS\n#define RENDER_TREES\n#define RENDER_MOUNTAINS\n\n#define RENDER_EYES\n#define RENDER_EARS\n#define RENDER_MOUTH\n#define RENDER_ARMS\n#define RENDER_LEGS\n#define RENDER_TAIL\n\n#define ANIMATION_SPEED 1.0\n#define CAMERA_HEIGHT 0.0\n#define CAMERA_DISTANCE 0.0\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n#define MATERIAL_SKIN 1.0\n#define MATERIAL_EAR 2.0\n#define MATERIAL_EYE 3.0\n#define MATERIAL_PUPIL 4.0\n#define MATERIAL_MOUTH 5.0\n#define MATERIAL_GRASS 6.0\n#define MATERIAL_FLOWER1 7.0\n#define MATERIAL_FLOWER2 8.0\n#define MATERIAL_STEM 9.0\n#define MATERIAL_TREE1 10.0\n#define MATERIAL_TREE2 11.0\n#define MATERIAL_MOUNTAIN 12.0\n#define MATERIAL_CLOUD 13.0\n\n#define RUN_SPEED 5.5\n#define CLOUDS_SPEED 8.0\n#define CLOUDS_HEIGHT 10.0\n\nvec3 SUN_DIRECTION = normalize(vec3(0.5, 0.5, -0.6));\n\n#define PI05 1.57079\n#define PI 3.14159\n#define PI2 6.28318\n\nstruct ArmPose\n{\n\tvec3 armAngle;\n\tvec3 elbowAngle;\n\tvec3 wristAngle;\n\tfloat fingersAngle;\n};\n\nstruct LegPose\n{\n\tvec3 legAngle;\n\tfloat kneeAngle;\n\tvec3 footAngle;\n};\n\nstruct Pose\n{\n\tvec3 offset;\n\tvec3 rotation;\n\tfloat cameraOffset;\n\tvec3 headRotation1;\n\tfloat headRotation2;\n\tfloat earsAngle;\n\tfloat eyesOpenFactor;\n\tvec3 eyesDirection;\n\tfloat eyebrowsHeight;\n\tfloat cheeksFactor;\n\tfloat mouthFactor;\n\tvec3 bodyRotation;\n\tvec3 bodyCurve;\n\tvec3 tailRotation;\n\n\tArmPose leftArm;\n\tArmPose rightArm;\n\tLegPose leftLeg;\n\tLegPose rightLeg;\n};\n\n// Cubic Smin\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    k*=1.35; // This line is an adjustment to match the quadratic smin. It is safe to remove.\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax( float a, float b, float k )\n{\n    k*=1.35; // This line is an adjustment to match the quadratic smin. It is safe to remove.\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return max( a, b ) + h*h*h*k*(1.0/6.0);\n}\n\nvec2 smin(in vec2 a, vec2 b, float k) // material smooth min\n{\n\tfloat x = smin(a.x, b.x, k);\n\treturn vec2(x, a.x < b.x ? a.y : b.y);\n}\n\nvec2 smax(in vec2 a, vec2 b, float k) // material smooth max\n{\n\tfloat x = smax(a.x, b.x, k);\n\treturn vec2(x, a.x > b.x ? a.y : b.y);\n}\n\nvec2 min2(in vec2 a, vec2 b) // material min\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 max2(in vec2 a, vec2 b) // material max\n{\n\treturn a.x > b.x ? a : b;\n}\n\nfloat hash(float p)\n{\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\nfloat hash(vec3 p)\n{\n\tp  = fract(p * 0.1031);\n\tp += dot(p, p.yzx + 33.33);\n\treturn fract((p.x + p.y) * p.z);\n}\n\nfloat hash(vec2 p)\n{\n\treturn hash(p.xyx);\n}\n\nfloat noise(in vec3 pos)\n{\n\tvec3 p = floor(pos);\n\tvec3 f = fract(pos);\n\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat a = 7.2;\n\tfloat b = 9.3;\n\n\tfloat n = p.x + a * p.y + b * p.z;\n\n\tfloat res = mix(mix(mix(hash(n), hash(n + 1.0), f.x),\n\t\t\t\t\t\tmix(hash(n + a), hash(n + a + 1.0), f.x), f.y),\n\t\t\t\t\tmix(mix(hash(n + b), hash(n + b + 1.0), f.x),\n\t\t\t\t\t\tmix(hash(n + a + b), hash(n + a + b + 1.0), f.x), f.y), f.z);\n\treturn res;\n}\n\nfloat fbm(in vec3 p)\n{\n\tfloat f = 0.5 * noise(p);\n\tp *= 2.1; f += 0.25 * noise(p);\n\treturn f;\n}\n\nfloat linearstep(float edge0, float edge1, float x)\n{\n\treturn clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat getTimeSegment(float time, float start, float end)\n{\n\treturn clamp((time - start) / (end - start), 0.0, 1.0);\n}\n\nfloat easeIn(float time, float factor)\n{\n\treturn pow(time, factor);\n}\n\nfloat easeOut(float time, float factor)\n{\n\treturn 1.0 - pow(1.0 - time, factor);\n}\n\nfloat easeInOut(float time, float factor)\n{\n\treturn easeIn(time * 2.0, factor) * step(0.5, 0.5 - time) +\n\t\teaseOut(time * 2.0 - 1.0, factor) * step(0.5, time);\n}\n\nvec3 vec3x(in float x)\n{\n\treturn vec3(x, 0.0, 0.0);\n}\n\nvec3 vec3y(in float y)\n{\n\treturn vec3(0.0, y, 0.0);\n}\n\nvec3 vec3z(in float z)\n{\n\treturn vec3(0.0, 0.0, z);\n}\n\nfloat smoothNoise(float x)\n{\n\tfloat floorx = floor(x);\n\tfloat fractx = fract(x);\n\n\treturn mix(hash(floorx), hash(floorx + 1.0), smoothstep(0.0, 1.0, fractx));\n}\n\nfloat smoothNoise(float x, float f)\n{\n\tfloat floorx = floor(x);\n\tfloat fractx = fract(x);\n\n\treturn smoothstep(f, 0.0, fractx) * hash(floorx - 1.0) + smoothstep(0.0, f, fractx) * hash(floorx);\n}\n\nfloat sdSurface(in vec3 pos)\n{\n\treturn pos.y;\n}\n\nfloat sdSphere(in vec3 pos, float rad)\n{\n\treturn length(pos) - rad;\n}\n\nfloat sdEllipsoid(in vec3 pos, vec3 rad)\n{\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdArc(in vec3 pos, float len, float angle, float width, float taper)\n{\n\t// parameters\n\tvec2 sc = vec2(sin(angle), cos(angle));\n\tfloat ra = 0.5 * len / angle;\n\n\t// recenter\n\tpos.x -= ra;\n\n\t// reflect\n\tvec2 q = pos.xy - 2.0 * sc * max(0.0, dot(sc, pos.xy));\n\n\tfloat u = abs(ra) - length(q);\n\tfloat d2 = (q.y < 0.0) ? dot(q + vec2(ra, 0.0), q + vec2(ra, 0.0)) : u * u;\n\tfloat s = sign(angle);\n\n\tfloat t = (pos.y > 0.0) ? atan(s * pos.y, -s * pos.x) * ra : (s * pos.x < 0.0) ? pos.y : len - pos.y;\n\twidth = max(0.001, width - t * taper);\n\n\treturn sqrt(d2 + pos.z * pos.z) - width;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n\tfloat q = length(p.xz);\n\treturn max(dot(c.xy, vec2(q, p.y)), -h - p.y);\n}\n\nvec2 rotate(in vec2 pos, float angle)\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn pos * m;\n}\n\nvec3 rotate_yzx(in vec3 pos, vec3 angle)\n{\n\tpos.xz = rotate(pos.xz, angle.y);\n\tpos.xy = rotate(pos.xy, angle.z);\n\tpos.yz = rotate(pos.yz, angle.x);\n\n\treturn pos;\n}\n\nvec3 rotate_xzy(in vec3 pos, vec3 angle)\n{\n\tpos.yz = rotate(pos.yz, angle.x);\n\tpos.xy = rotate(pos.xy, angle.z);\n\tpos.xz = rotate(pos.xz, angle.y);\n\n\treturn pos;\n}\n\nfloat getGroundHeight(in vec3 pos)\n{\n\tpos *= vec3(0.1, 0.0, 0.1);\n\tpos.xz *= mat2(0.93, 0.34, -0.34, 0.93);\n\n\treturn -2.0 +\n\t\t0.9 * (sin(pos.x) + sin(pos.z)) +\n\t\t0.6 * (sin(2.0 * pos.x) + sin(2.0 * pos.z));\n}\n\nvoid mixPose(inout ArmPose pose1, in ArmPose pose2, float f)\n{\n\tpose1.armAngle = mix(pose1.armAngle, pose2.armAngle, f);\n\tpose1.elbowAngle = mix(pose1.elbowAngle, pose2.elbowAngle, f);\n\tpose1.wristAngle = mix(pose1.wristAngle, pose2.wristAngle, f);\n\tpose1.fingersAngle = mix(pose1.fingersAngle, pose2.fingersAngle, f);\n}\n\nArmPose getArmPose3(float time, vec3 noise)\n{\n\tArmPose p;\n\n\tfloat time1 = sin(PI2 * time);\n\n\tp.fingersAngle = 1.2;\n\tp.armAngle = vec3(-0.3, -0.9, 0.3) + time1 * vec3(0.0, -0.2, 0.0);\n\tp.elbowAngle = vec3(0.3, -1.2, 0.1) + time1 * vec3(0.5, -0.6, 0.0);\n\tp.wristAngle = vec3(0.0, 0.0, 0.0);\n\n\tnoise = 2.0 * noise - 1.0;\n\n\tp.armAngle += noise.x * vec3(0.0, 0.1, 0.2);\n\tp.elbowAngle += noise.y * vec3(0.0, 0.3, 0.0);\n\n\treturn p;\n}\n\nArmPose getArmPose1(float time, vec3 noise)\n{\n\tArmPose p;\n\n\tfloat time1 = sin(PI2 * time);\n\n\tp.armAngle = vec3(-2.0, -0.5, 0.3) + time1 * vec3(0.0, 0.2, 0.4);\n\tp.elbowAngle = vec3(0.0, 0.0, 0.0) + time1 * vec3(0.0, 0.3, 0.0);\n\tp.wristAngle = vec3(0.0, -0.2, 0.0) + time1 * vec3(0.0, -0.1, 0.0);\n\n\tp.armAngle += noise.x * vec3(0.0, 0.3, 0.2) - vec3(0.0, 0.0, 0.2);\n\tp.elbowAngle += noise.y * vec3(0.0, 1.0, 0.0);\n\tp.wristAngle += noise.z * vec3(0.0, -0.1, 0.0);\n\n\treturn p;\n}\n\n\nArmPose getArmPose2(float time, vec3 noise)\n{\n\tArmPose p;\n\n\tfloat time1 = sin(PI2 * time);\n\n\tp.fingersAngle = 1.2;\n\tp.armAngle = vec3(-2.0, 0.0, 0.5) + time1 * vec3(0.0, 0.2, 0.2);\n\tp.elbowAngle = vec3(0.5, 0.0, 1.0) + time1 * vec3(0.0, 0.1, 0.0);\n\tp.wristAngle = vec3(0.0, 0.0, 0.0) + time1 * vec3(0.0, 0.3, 0.0);\n\n\tnoise = 2.0 * noise - 1.0;\n\n\tp.armAngle += noise.x * vec3(0.0, 0.2, 0.2);\n\tp.elbowAngle += noise.y * vec3(0.0, 0.2, 0.0);\n\tp.wristAngle += noise.z * vec3(0.0, 0.0, 0.0);\n\n\treturn p;\n}\n\nArmPose getArmPose(float time, vec3 noise, float pose1Factor, float pose2Factor)\n{\n\tArmPose p = getArmPose1(time, noise);\n\tmixPose(p, getArmPose2(time, noise), pose1Factor);\n\tmixPose(p, getArmPose3(time, noise), pose2Factor);\n\n\treturn p;\n}\n\nLegPose getLegPose(float time, vec3 noise, float speed, float pose1Factor)\n{\n\tLegPose p;\n\tfloat time1, t1, t2;\n\n\ttime1 = fract(time);\n\n\tfloat hop = pose1Factor;\n\tfloat range = 1.3 * speed;\n\n\tt1 = getTimeSegment(time1, 0.0, 0.6 - 0.4 * hop);\n\tt2 = getTimeSegment(time1, 0.6 - 0.4 * hop, 1.0);\n\tp.legAngle = vec3x(0.5 + (1.0 - hop * 0.4) * range * (1.0 - 2.3 * (easeOut(t1, 1.3) - easeOut(t2, 1.3))));\n\n\ttime1 = fract(time + 0.2);\n\n\tt1 = getTimeSegment(time1, 0.0, 0.3);\n\tt2 = getTimeSegment(time1, 0.4, 0.7);\n\tp.kneeAngle = -0.7 + range * (-1.0 + 1.5 * (easeOut(t1, 1.2) - easeIn(t2, 1.5)));\n\n\tt1 = getTimeSegment(time1, 0.0, 0.5);\n\tt2 = getTimeSegment(time1, 0.5, 1.0);\n\tp.footAngle = vec3x(0.5 - 0.6 * (easeOut(t1, 2.0) - easeOut(t2, 2.0)));\n\n\treturn p;\n}\n\nPose getPose(float time)\n{\n\tPose pose;\n\tfloat time1, time2;\n\tvec3 n1, n2, n3;\n\n\tfloat poseDuration = 4.0;\n\tfloat mode0 = floor(hash(floor(time / poseDuration) - 1.0) * 4.0);\n\tfloat mode1 = floor(hash(floor(time / poseDuration)) * 4.0);\n\n\tfloat mixFactor = smoothstep(0.0, 0.2, fract(time / poseDuration));\n\tfloat armsPose1Factor = mix(step(abs(mode0 - 2.0), 0.0), step(abs(mode1 - 2.0), 0.0), mixFactor);\n\tfloat armsPose2Factor = mix(step(abs(mode0 - 3.0), 0.0), step(abs(mode1 - 3.0), 0.0), mixFactor);\n\n\tposeDuration = 5.5;\n\tmixFactor = smoothstep(0.0, 0.2, fract(time / poseDuration));\n\tmode0 = floor(hash(0.1 + floor(time / poseDuration) - 1.0) * 4.0);\n\tmode1 = floor(hash(0.1 + floor(time / poseDuration)) * 4.0);\n\tfloat legsPoseFactor = mix(step(abs(mode0 - 2.0), 0.0), step(abs(mode1 - 2.0), 0.0), mixFactor);\n\tlegsPoseFactor *= max(0.0, 1.0 - armsPose1Factor - armsPose2Factor);\n\n\ttime1 = time * 0.4; // noise change interval\n\tn1 = vec3(smoothNoise(time1, 0.3), smoothNoise(time1 + 3.0, 0.3), smoothNoise(time1 + 5.0, 0.3));\n\tn2 = vec3(smoothNoise(time1 + 2.0, 0.3), smoothNoise(time1 + 4.0, 0.3), smoothNoise(time1 + 1.0, 0.3));\n\tn3 = 0.5 * (n1 + n2);\n\n\tpose.leftArm = getArmPose(time, n2, armsPose1Factor, armsPose2Factor);\n\tpose.rightArm = getArmPose(time + 0.5, n1, armsPose1Factor, armsPose2Factor);\n\n\ttime1 = time * 0.4;\n\tfloat runSpeed = 0.15 * (RUN_SPEED + 1.3 * (cos(time1) + cos(time1 / 2.0) / 2.0 + cos(time1 / 3.0) / 3.0 + cos(time1 / 5.0) / 5.0));\n\n\tpose.leftLeg = getLegPose(time, n1, runSpeed, legsPoseFactor);\n\tpose.rightLeg = getLegPose(time + 0.5, n2, runSpeed, legsPoseFactor);\n\n\tpose.headRotation1 = vec3(0.3, 0.0, 0.0) + (n3 * 2.0 - 1.0) * vec3(0.7, 0.2, 0.4);\n\tpose.bodyRotation = vec3(-0.2 - 0.3 * n1.y, 0.0, 0.0);\n\tpose.tailRotation = (n3 * 2.0 - 1.0) * vec3(0.0, 0.5, 0.0) +\n\t\tvec3(0.0, 0.0, 0.1 + 1.6 * (pose.bodyRotation.x + 0.5)) +\n\t\t(0.4 + 0.6 * legsPoseFactor) * vec3(0.0, 0.3 * sin(time * PI2), -0.6 * pow(abs(sin(time * PI2 - 0.1)), 1.4));\n\tpose.bodyCurve = vec3(0.1 - 0.2 * runSpeed, 0.1 * sin(PI05 + time * PI2), 0.0);\n\n\ttime1 = time / 2.5; // ears bounces interval\n\tpose.earsAngle = 0.7 * abs(sin(time1 * 30.0)) * // speed and amplitude\n\t\tmax(0.2 - fract(time1), 0.0) * // duration\n\t\tstep(hash(floor(time1)), 0.5); // probability\n\n\tpose.eyesDirection = 0.2 * vec3(n3.x, n3.y, -3.0 + pose.headRotation1.x * 4.0);\n\n\ttime1 = time / 1.5; // eyes blink interval\n\ttime2 = fract(time1);\n\n\tfloat open0 = step(hash(floor(time1) - 1.0), 0.8); // open probability\n\tfloat open1 = step(hash(floor(time1)), 0.8); // open probability\n\tfloat isBlinking = step(hash(floor(time1)), 0.7); // blink probability\n\tfloat isOpened = step(2.0, open0 + open1);\n\n\tfloat openPosition = open0 * linearstep(0.3, 0.0, time2) + open1 * linearstep(0.0, 0.2, fract(time1));\n\tfloat blinkPosition = 1.0 - isBlinking * (linearstep(0.0, 0.05, time2) - linearstep(0.1, 0.2, time2));\n\tpose.eyesOpenFactor = (1.0 - isOpened) * openPosition + isOpened * blinkPosition;\n\tpose.eyebrowsHeight = (1.0 - isOpened) * (1.0 - openPosition) + isOpened * blinkPosition * 0.1;\n\tpose.cheeksFactor = (1.0 - isOpened) * (1.0 - openPosition);\n\n\tpose.mouthFactor = clamp(5.0 * (pose.headRotation1.x - 0.2), 0.0, 1.0);\n\n\tpose.offset = (1.0 - legsPoseFactor) * vec3(0.0, -0.4 * pow(abs(sin(time * PI2 - 0.1)), 1.4), 0.0);\n\tpose.offset += legsPoseFactor * vec3(0.0, -0.9 * abs(sin(time * PI2 - 0.2)), 0.2 * abs(sin(time * PI2 - 0.2)));\n\n\ttime1 = time * 0.4;\n\tfloat runDistance = -(RUN_SPEED * time + 1.5 * (sin(time1) + sin(time1 / 2.0) + sin(time1 / 3.0) + sin(time1 / 5.0)));\n\tfloat h = getGroundHeight(vec3(0.0, 0.0, runDistance));\n\tfloat hx = getGroundHeight(vec3(-SURF_DIST, 0.0, runDistance));\n\n\tpose.offset -= vec3(0.0, h - runSpeed * 0.1, runDistance);\n\tpose.rotation = vec3(0.0, 0.0, -0.6 * atan(hx - h, SURF_DIST));\n\n\treturn pose;\n}  \n\nvec2 sdEars(in vec3 pos, float angle)\n{\n\tfloat bounds = sdSphere(pos - vec3(0.0, 1.0, 0.0), 0.7);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tpos.x = abs(pos.x);\n\tpos.xy = rotate(pos.xy, -0.32 + angle);\n\tpos -= vec3(0.0, 0.9, 0.0);\n\n\tvec2 d1, d2;\n\tfloat y = -0.05;\n\td1 = vec2(sdEllipsoid(pos - vec3(0.14, y, 0.0), vec3(0.38, 0.5, 0.2)), MATERIAL_SKIN);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(-0.14, y, 0.0), vec3(0.38, 0.5, 0.2)), MATERIAL_SKIN);\n\td1 = smax(d1, d2, 0.03);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(0.0, y, 0.5), vec3(0.6,0.7,0.6)), MATERIAL_SKIN);\n\td1 = smax(d1, d2, 0.1);\n\n\td2 = vec2(sdEllipsoid(pos - vec3(0.0, y, -0.1), vec3(0.12, 0.33, 0.12)), MATERIAL_EAR);\n\td1 = smax(d1, vec2(-d2.x, d2.y), 0.05);\n\n\treturn d1;\n}\n\nvec2 sdArm(in vec3 pos, vec3 armAngle, vec3 elbowAngle, vec3 wristAngle, float fingersAngle)\n{\n\tfloat d1, d2, d3;\n\tvec3 pos1, pos2;\n\n\tpos1 = pos;\n\tpos1 = rotate_xzy(pos1, armAngle);\n\n\tfloat bounds = sdSphere(pos1 - vec3(0.9, 0.0, 0.0), 1.0);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\t// upper arm\n\tpos1.x -= 0.38;\n\td1 = sdEllipsoid(pos1 - vec3(0.52, 0.0, 0.0), vec3(0.54, 0.38, 0.38));\n\n\t// forearm\n\tpos1.x -= 0.77;\n\tpos1 = rotate_xzy(pos1, elbowAngle);\n\td2 = sdEllipsoid(pos1 - vec3(0.26, 0.0, 0.0), vec3(0.32, 0.26, 0.26));\n\td1 = smin(d1, d2, 0.1);\n\n\t// palm\n\tpos1.x -= 0.15;\n\tpos1 = rotate_xzy(pos1, wristAngle);\n\td2 = sdEllipsoid(pos1 - vec3(0.3, 0.0, 0.0), vec3(0.2, 0.22, 0.15));\n\td1 = smin(d1, d2, 0.1);\n\n\t// palm bend\n\td2 = sdEllipsoid(pos1 - vec3(0.4, 0.0, -0.2), vec3(0.05, 0.25, 0.07));\n\td1 = smax(d1, -d2, 0.1);\n\n\t// fingers\n\tpos2 = rotate_yzx(pos1, vec3(0.0, -0.4, 0.6));\n\tpos2 -= vec3(0.38, 0.0, 0.1);\n\tpos2 = rotate_yzx(pos2, fingersAngle * vec3(0.0, -1.5, -0.5));\n\td2 = sdEllipsoid(pos2 - vec3(0.05, 0.0, 0.0), vec3(0.1, 0.06, 0.06)); // thumb\n\n\tfloat spreadAngle = 0.2;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tpos2 = rotate_yzx(pos1, vec3(-0.3, -0.4, float(i) * spreadAngle - 0.5));\n\t\tpos2 -= vec3(0.4, 0.0, 0.15);\n\t\tpos2 = rotate_yzx(pos2, fingersAngle * vec3(0.0, -1.3, 0.0));\n\t\td3 = sdEllipsoid(pos2 - vec3(0.05, 0.0, 0.0), vec3(0.1, 0.06, 0.06)); // finger\n\t\td2 = min(d2, d3);\n\t}\n\td1 = smin(d1, d2, 0.06);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdLeg(in vec3 pos, vec3 legAngle, float kneeAngle, vec3 footAngle)\n{\n\tfloat d1, d2, d3;\n\tvec3 pos1, pos2;\n\tfloat s = 1.15; // scale\n\n\tpos1 = pos;\n\n\tpos1.xz = rotate(pos1.xz, legAngle.y);\n\tpos1.yz = rotate(pos1.yz, legAngle.x);\n\tpos1.xy = rotate(pos1.xy, legAngle.z);\n\n\tfloat bounds = sdSphere(pos1 - vec3(0.0, -1.0, 0.0), 1.0);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\t// thigh\n\tpos1.y += 0.3 * s;\n\td1 = sdEllipsoid(pos1 + vec3(0.0, 0.3 * s, 0.0), vec3(0.4, 0.6, 0.4) * s);\n\n\t// shin\n\tpos1.y += 0.6 * s;\n\tpos1.yz = rotate(pos1.yz, kneeAngle);\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.2 * s, 0.0), vec3(0.3, 0.34, 0.3) * s);\n\td1 = smin(d1, d2, 0.1);\n\n\t// foot\n\tpos1 += vec3(0.0, 0.38, -0.13) * s;\n\tpos1 = rotate_yzx(pos1, footAngle);\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.0, 0.3) * s, vec3(0.22, 0.15, 0.25) * s * 1.2);\n\td1 = smin(d1, d2, 0.1);\n\n\td2 = sdEllipsoid(pos1 + vec3(0.0, 0.3, 0.3) * s, vec3(0.4, 0.2, 0.5) * s);\n\td1 = smax(d1, -d2, 0.1);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdTail(in vec3 pos, vec3 angle)\n{\n\tfloat bounds = sdSphere(pos - vec3(0.0, -0.4, 0.7), 1.0);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tvec3 pos1 = pos;\n\n\tpos1 = pos;\n\tpos1 = rotate_yzx(pos1, angle);\n\tpos1.y = -pos1.y;\n\n\tfloat d1 = sdArc(pos1, 1.6, 0.7, 0.1, 0.04);\n\n\tpos1 += vec3(-0.93, -1.13, 0.0);\n\tpos1.xy = rotate(pos1.xy, -1.2);\n\tfloat d2 = sdArc(pos1, 0.2, 0.4, 0.15, 0.5);\n\td1 = smin(d1, d2, 0.1);\n\n\treturn vec2(d1, MATERIAL_SKIN);\n}\n\nvec2 sdEyelids(in vec3 pos, float openFactor, vec3 direction)\n{\n\tpos.x = abs(pos.x);\n\tpos.x -= 0.28;\n\n\tfloat bounds = sdSphere(pos, 0.3);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tfloat s = 1.1;\n\n\tfloat eyelidsBounds = sdSphere(pos, 0.18 * s);\n\n\t// eyelids\n\tvec3 pos1 = pos;\n\tfloat directionBias = direction.z * openFactor;\n\tpos1.xy = rotate(pos1.xy, -0.3 - 0.2 * directionBias);\n\tpos1.yz = rotate(pos1.yz, -0.4 - 0.3 * openFactor + 0.5 * directionBias); // eyelids meeting angle\n\tpos1.z = abs(pos1.z);\n\tpos1.y += 0.5;\n\tpos1.yz = rotate(pos1.yz, 0.1 + 0.4 * openFactor);\n\tpos1.y -= 0.5;\n\tfloat d = smax(sdEllipsoid(pos1, vec3(0.17 * s)), eyelidsBounds, 0.01);\n\n\treturn vec2(d, MATERIAL_SKIN);\n}\n\nvec2 sdEyes(in vec3 pos, vec3 direction)\n{\n\tdirection.x *= sign(pos.x);\n\tpos.x = abs(pos.x);\n\tpos.x -= 0.28;\n\n\tfloat bounds = sdSphere(pos, 0.3);\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\tfloat s = 1.1;\n\n\t// pupil distance\n\tfloat dist = length(pos - normalize(vec3(0.4, 1.0, -1.0) + direction));\n\n\t// eye\n\tfloat pupilSize = 0.87;\n\tfloat d = sdSphere(pos, 0.15 * s);\n\tfloat m = MATERIAL_EYE + step(dist, pupilSize) * (1.0 + 2.0 * (pupilSize - dist));\n\n\treturn vec2(d, m);\n}\n\nvec2 sdEyebrows(in vec3 pos, float height)\n{\n\tpos.x = abs(pos.x);\n\n\tpos.yz = rotate(pos.yz, 0.3);\n\tpos -= vec3(0.25, 0.46, -0.01);\n\tpos -= vec3(0.02, 0.2, 0.07) * height;\n\tpos.yz = rotate(pos.yz, 0.95);\n\tpos.xy = rotate(pos.xy, 0.2 - 0.1 * height);\n\tfloat d = sdEllipsoid(pos, vec3(0.25, 0.08, 0.25)) ;\n\n\treturn vec2(d, MATERIAL_SKIN);\n}\n\nvec2 sdMouth(in vec3 pos)\n{\n\tfloat d1, d2;\n\tfloat s = 0.2;\n\td1 = sdEllipsoid(pos, vec3(1.0 * s));\n\td2 = sdEllipsoid(pos + vec3(0.0, 0.0, -2.0) * s, vec3(2.0 * s));\n\td1 = smax(d1, d2, 0.1);\n\treturn vec2(d1, MATERIAL_MOUTH);\n}\n\nvec2 sdMoomin(in vec3 pos, inout Pose pose)\n{\n\tvec2 d1, d2, d3;\n\tvec3 pos1, pos2;\n\n\tpos += pose.offset;\n\tpos = rotate_xzy(pos, pose.rotation);\n\tpos.y -= 1.2;\n\tpos.z += 1.5;\n\n\tfloat bounds = MAX_DIST;\n\tbounds = min(bounds, sdSphere(pos - vec3(0.0, 2.0, 1.0), 1.6));\n\tbounds = min(bounds, sdSphere(pos - vec3(0.0, 0.2, 1.6), 2.2));\n\tbounds = min(bounds, sdSphere(pos - vec3(0.0, -0.0, 4.2), 1.4));\n\tif (bounds > 0.2) return vec2(bounds, 0.0); // optimization\n\n\t// head\n\tpos1 = pos - vec3(0.0, 1.6, 1.0);\n\tpos1 = rotate_yzx(pos1, pose.headRotation1 + vec3(0.4, 0.0, 0.0)); // head rotation\n\tpos1.y -= 0.3;\n\n\t// jaw\n\td1.x = sdEllipsoid(pos1 - vec3(0.0, -0.35, -0.7), vec3(0.65, 0.65, 0.7));\n\td2.x = sdEllipsoid(pos1 - vec3(0.0, -1.1, -0.5), vec3(1.2));\n\td1 = smax(d1, d2, 0.1);\n\n\td2.x = sdEllipsoid(pos1 - vec3(0.0, -0.2, -0.5), vec3(0.6, 0.3, 0.4) * (1.0 + 0.1 * pose.cheeksFactor));\n\td1 = smin(d1, d2, 0.25);\n\n\t// skull\n\tpos2 = pos1;\n\tpos2.yz = rotate(pos2.yz, pose.headRotation2); // head rotation\n\td2.x = sdEllipsoid(pos2 - vec3y(0.04), vec3(0.7, 0.91, 0.7));\n\td1 = smin(d1, d2, 0.2);\n\n\tpos2.yz = rotate(pos2.yz, 0.5);\n\tpos2 += vec3(0.0, 0.4, 0.1);\n\td2.x = sdEllipsoid(pos2, vec3(0.6, 0.6, 0.4));\n\n\td1 = smin(d1, d2, 0.2);\n\td1.y = MATERIAL_SKIN;\n\n#ifdef RENDER_EYES\n\tpos2 = pos1 - vec3(0.0, 0.05, -0.6);\n\n\t// eyes sockets\n\td2.x = sdSphere(vec3(abs(pos2.x) - 0.28, pos2.yz), 0.10);\n\td1.x = smax(d1.x, -d2.x, 0.2);\n\n\t// eyelids\n\td2 = sdEyelids(pos2 + vec3(0.0, 0.02, 0.0), pose.eyesOpenFactor, pose.eyesDirection);\n\td1 = smin(d1, d2, 0.09);\n\n\t// eyes\n\td2 = sdEyes(pos2 + vec3(0.0, 0.02, 0.0), pose.eyesDirection);\n\td1 = smin(d1, d2, 0.02);\n\n\td2 = sdEyebrows(pos2 + vec3(0.0, 0.3, 0.0), pose.eyebrowsHeight);\n\td1 = smin(d1, d2, 0.03);\n#endif\n\n#ifdef RENDER_EARS\n\t// ears\n\td2 = sdEars(pos1, pose.earsAngle);\n\td1 = smin(d1, d2, 0.05);\n#endif\n\n#ifdef RENDER_MOUTH\n\t// mouth\n\td2 = sdMouth(pos1 + vec3(0.0, 1.1 - 0.1 * pose.mouthFactor, 0.3));\n\td1 = smax(d1, vec2(-d2.x, d2.y), 0.04);\n#endif\n\n\tfloat t = 0.9; // taper\n\n\t// body\n\tpos1 = pos - vec3(0.0, 1.7, 1.1);\n\tpos1 = rotate_yzx(pos1,  pose.bodyRotation); // body rotation\n\n\tfloat y;\n\n\t// neck\n\ty = 0.5;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\td2 = vec2(sdEllipsoid(pos2 - vec3(0.0, -0.1, 0.1), vec3(0.6, 1.2, 0.7)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// shoulders\n\ty = 1.0;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// ribcage\n\ty = 1.6;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\td2 = vec2(sdSphere(pos2, 0.41 * (t + y)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.2);\n\n\t// belly\n\ty = 1.9;\n\tpos2 = rotate_yzx(pos1, pose.bodyCurve * y);\n\tpos2.y += y;\n\n\tfloat bellyStretch = 0.09 * abs(pose.leftLeg.legAngle.x - pose.rightLeg.legAngle.x);\n\td2 = vec2(sdEllipsoid(pos2 - vec3y(bellyStretch), 0.41 * (t + y) * vec3(1.0, 1.0 - bellyStretch, 1.0)), MATERIAL_SKIN);\n\td1 = smin(d1, d2, 0.1);\n\n#ifdef RENDER_ARMS\n\t// arms\n\ty = 0.9;\n\tvec3 armsPos = rotate_yzx(pos1, pose.bodyCurve * y);\n\tarmsPos.y += y;\n\tvec3 armOffset = vec3(0.0, 0.0, 0.2);\n\n\t// right arm\n\tpos2 = armsPos - armOffset;\n\td2 = sdArm(pos2, pose.rightArm.armAngle, pose.rightArm.elbowAngle, pose.rightArm.wristAngle, pose.rightArm.fingersAngle);\n\n\t// left arm\n\tpos2 = vec3(-armsPos.x, armsPos.yz) - armOffset; // mirror\n\td3 = sdArm(pos2, pose.leftArm.armAngle, pose.leftArm.elbowAngle, pose.leftArm.wristAngle, pose.leftArm.fingersAngle);\n\td2 = min2(d2, d3);\n\n\td1 = smin(d1, d2, 0.08);\n#endif\n\n#ifdef RENDER_LEGS\n\t// legs\n\ty = 1.8;\n\tvec3 legsPos = rotate_yzx(pos1, pose.bodyCurve * y);\n\tlegsPos.y += y;\n\tvec3 legOffset = vec3(0.4, 0.0, 0.0);\n\n\t// right leg\n\tpos2 = legsPos - legOffset;\n\td2 = sdLeg(pos2, pose.rightLeg.legAngle, pose.rightLeg.kneeAngle, pose.rightLeg.footAngle);\n\n\t// left leg\n\tpos2 = vec3(-legsPos.x, legsPos.yz) - legOffset; // mirror\n\td3 = sdLeg(pos2, pose.leftLeg.legAngle, pose.leftLeg.kneeAngle, pose.leftLeg.footAngle);\n\td2 = min2(d2, d3);\n#endif\n\n#ifdef RENDER_TAIL\n\t// tail \n\ty = 2.6;\n\tvec3 tailPos = rotate_yzx(pos1, pose.bodyCurve * y);\n\ttailPos.y += y - 0.5 * bellyStretch;\n\ttailPos.z -= 0.6 - 0.5 * bellyStretch;\n\n\td3 = sdTail(tailPos, pose.tailRotation + vec3(0.0, 1.57, 0.2));\n\n\td2 = min2(d2, d3);\n#endif\n\n\td1 = smin(d1, d2, 0.1);\n\n\treturn d1;\n}\n\nvec2 sdGrass(in vec3 pos)\n{\n\tfloat height = getGroundHeight(pos);\n\tvec2 d1 = vec2(sdSurface(pos - vec3(0.0, height, 0.0)), MATERIAL_GRASS);\n\treturn d1;\n}\n\nfloat getSkyTextureCloud(in vec2 uv)\n{\n\treturn fbm(vec3(uv + 10.0, 0.0)) * 1.8;\n}\n\nvec4 getCloudPosIndex(in vec2 uv, float time, float offset)\n{\n\ttime *= CLOUDS_SPEED + 0.2 * offset;\n\ttime += 1000.0 * offset;\n\n\tfloat grid = 32.0;\n\n\tfloat index = floor((uv.y + time) / grid);\n\n\tfloat origin = index * grid;\n\tfloat p = 0.05 * (origin - 1.2 * time);\n\tvec2 pos = uv;\n\n\tpos.y -= origin - time;\n\tpos.y -= 0.5 * grid;\n\tpos.x *= 1.2; // stretch\n\tpos.x += 8.0 * sin(p) + 5.0 * sin(2.0 * p + 2.0) + sin(3.0 * p + 2.0);\n\n\treturn vec4(pos.x, 0.0, pos.y, index);\n}\n\nvec3 getSkyTexture(in vec3 rd)\n{\n\tvec3 color = vec3(0.05, 0.4, 0.95);\n\n\tvec2 uv = rd.xz / rd.y; // uv map\n\tfloat cloud = getSkyTextureCloud(uv);\n\tvec3 cloudColor = mix(vec3(1.0, 0.75, 1.0), vec3(0.6, 0.3, 0.6), (cloud - 0.5) * 0.3);\n\n\tcolor = mix(color, cloudColor, clamp((cloud - 1.0) * 10.0, 0.0, 1.0));\n\n\t// fog\n\tcolor = mix(color, vec3(0.5, 0.85, 0.95), clamp(1.0 - 2.0 * rd.y, 0.0, 1.0));\n\n\treturn color;\n}\n\nvec2 sdFlowers(in vec3 pos)\n{\n\tfloat grid = 2.0;\n\tvec2 cellIndex = floor(pos.xz / grid);\n\tfloat h1 = hash(cellIndex);\n\tif (h1 < 0.9)\n\t{\n\t\treturn vec2(MAX_DIST, 0.0);\n\t}\n\n\tfloat h2 = hash(cellIndex + 0.1);\n\n\tvec3 cellOrigin = vec3(grid * (cellIndex.x + 0.5), 0.0, grid * (cellIndex.y + 0.5));\n\tcellOrigin.xz += 0.2 * grid * (h2 * 2.0 - 1.0);\n\tcellOrigin.y = getGroundHeight(cellOrigin);\n\n\tvec3 pos1 = pos - cellOrigin;\n\tfloat bounds = length(pos1) - 0.3;\n\tif (bounds > 0.3) return vec2(bounds, 0.0); // optimization\n\n\tfloat h3 = hash(cellIndex + 0.2);\n\tfloat h4 = hash(cellIndex + 0.3);\n\n\tfloat hx = getGroundHeight(cellOrigin - vec3(SURF_DIST, 0.0, 0.0));\n\tfloat hz = getGroundHeight(cellOrigin - vec3(0.0, 0.0, SURF_DIST));\n\tpos1.xy = rotate(pos1.xy, -atan(hx - cellOrigin.y, SURF_DIST));\n\tpos1.yz = rotate(pos1.yz, atan(hz - cellOrigin.y, SURF_DIST));\n\tpos1.xz = rotate(pos1.xz, PI * h4);\n\n\tfloat stemLength = 0.1 + 0.3 * h3;\n\tfloat s = 0.3 + 0.5 * h4;\n\n\tvec2 d1 = vec2(length(pos1.xz) - 0.05 * s, MATERIAL_STEM);\n\tvec2 d2 = vec2(pos1.y - stemLength * s, MATERIAL_STEM);\n\n\tpos1.y -= stemLength * s;\n\td1 = max2(d1, d2);\n\td2 = vec2(sdSphere(pos1, 0.1 * s), MATERIAL_FLOWER2);\n\td1 = min2(d1, d2);\n\n\tvec3 pos2 = pos1;\n\tpos2.y += 0.07 * s;\n\n\tfloat a = atan(pos2.x, pos2.z);\n\tfloat l = length(pos2.xz);\n\n\ta = mod(a, PI2 / 5.0) - PI2 / 10.0;\n\tpos2.x = l * cos(a);\n\tpos2.z = l * sin(a);\n\tpos2.xy = rotate(pos2.xy, 0.4);\n\n\td2 = vec2(sdEllipsoid(pos2 - vec3(0.07 + s * 0.1, 0.0, 0.0), s * 0.2 * vec3(1.5 , 0.3, 1.0)), MATERIAL_FLOWER1);\n\td1 = min2(d1, d2);\n\n\treturn d1;\n}\n\nvec2 sdMountains(in vec3 pos)\n{\n\tfloat bounds = 80.0 - length(pos);\n\tif (bounds > 20.0) return vec2(bounds, 0.0); // optimization\n\n\tvec3 pos1 = pos;\n\n\tfloat a = atan(pos1.x, pos1.z);\n\tfloat l = length(pos1.xz);\n\n\tfloat c = 8.0;\n\tfloat index = floor(c * a / PI2);\n\n\tfloat h1 = hash(index + 0.1) * 2.0 - 1.0;\n\tfloat h2 = hash(index + 0.2) * 2.0 - 1.0;\n\tfloat h3 = hash(index + 0.3);\n\tfloat h4 = hash(index + 0.4);\n\n\ta = mod(a, PI2 / c) - PI / c;\n\ta += h2 * 0.1;\n\n\tpos1.x = l * cos(a);\n\tpos1.z = l * sin(a);\n\n\tpos1.x -= 102.0;\n\tpos1.y += 5.0;\n\tpos1.yz = rotate(pos1.yz, 0.5 * h2);\n\n\tfloat d1 = sdEllipsoid(pos1, 12.0 * (vec3(1.0) + vec3(1.0, h3 * 0.5, h4 * 2.0)));\n\n\tif (d1 < 5.0)\n\t{\n\t\tpos1 = pos * 0.23;\n\t\td1 += 2.0 * (sin(pos1.x) + sin(pos1.z));\n\t\td1 *= 0.8;\n\t}\n\n\treturn vec2(d1, MATERIAL_MOUNTAIN);\n}\n\nvec2 sdTrees(in vec3 pos)\n{\n\tfloat bounds = 55.0 - abs(pos.x);\n\tif (bounds > 1.0) return vec2(bounds, 0.0); // optimization\n\n\tvec2 grid = vec2(130.0, 20.0);\n\tvec2 cellIndex = floor(pos.xz / grid);\n\tif (abs(cellIndex.x + 0.5) > 1.0)\n\t{\n\t\treturn vec2(MAX_DIST, 0.0);\n\t}\n\n\tfloat h1 = hash(cellIndex);\n\tif (h1 > 0.8)\n\t{\n\t\treturn vec2(MAX_DIST, 0.0);\n\t}\n\n\tfloat h2 = hash(cellIndex + 0.1) * 2.0 - 1.0;\n\tfloat h3 = hash(cellIndex + 0.2) * 2.0 - 1.0;\n\n\tvec3 cellOrigin = vec3(grid.x * (cellIndex.x + 0.5), 0.0, grid.y * (cellIndex.y + 0.5));\n\tcellOrigin.x += 4.0 * h2;\n\tcellOrigin.z += 5.0 * h3;\n\n\tbounds = length(pos.xz - cellOrigin.xz) - 4.0;\n\tif (bounds > 1.0) return vec2(bounds, 0.0); // optimization\n\n\tcellOrigin.y = getGroundHeight(cellOrigin);\n\n\tvec3 pos1 = pos - cellOrigin;\n\n\tfloat h4 = hash(cellIndex + 0.3) * 2.0 - 1.0;\n\tfloat h5 = hash(cellIndex + 0.4) * 2.0 - 1.0;\n\tpos1.yz = rotate(pos1.yz, 0.2 * h4);\n\tpos1.xy = rotate(pos1.xy, 0.2 * h5);\n\n\tfloat s = 0.8 + 0.2 * h4;\n\tvec3 pos2 = pos1;\n\n\tvec2 d1 = vec2(sdCone(pos2 - vec3y(11.0 * s), vec2(0.866, 0.5), 5.0 * s), MATERIAL_TREE1);\n\tvec2 d2 = vec2(sdCone(pos2 - vec3y(8.5 * s), vec2(0.866, 0.5), 6.5 * s), MATERIAL_TREE1);\n\td1 = min2(d1, d2);\n\n\td2 = vec2(length(pos1.xz) - 0.5 * s, MATERIAL_TREE2);\n\tfloat d3 = pos1.y - 2.0 * s;\n\td2.x = max(d2.x, d3);\n\n\td1 = min2(d1, d2);\n\n\treturn d1;\n}\n\nfloat mapClouds(in vec3 pos, float time)\n{\n\tfloat d1, d2;\n\n\tvec4 pi = getCloudPosIndex(pos.xz + vec2(0.0, 0.0), time, 0.0);\n\tvec3 pos1 = vec3(pi.x, pos.y - (CLOUDS_HEIGHT - 3.0), pi.z);\n\td1 = sdEllipsoid(pos1, vec3(4.0, 2.0, 4.0));\n\n\tpi = getCloudPosIndex(pos.xz - vec2(0.0, 0.0), time, 1.0);\n\tpos1 = vec3(pi.x, pos.y - (CLOUDS_HEIGHT + 3.0), pi.z);\n\td2 = sdEllipsoid(pos1, vec3(4.0, 2.0, 4.0));\n\td1 = min(d1, d2);\n\n\treturn d1;\n}\n\nvec2 map(in vec3 pos, float time, inout Pose pose, bool includeClouds)\n{\n\tvec2 d1, d2;\n\n\td1 = vec2(MAX_DIST, 0.0);\n\n#ifdef RENDER_MOOMIN\n\td1 = sdMoomin(pos, pose);\n#endif\n\n#ifdef RENDER_FLOWERS\n\td2 = sdFlowers(pos);\n\td1 = min2(d1, d2);\n#endif\n\n#ifdef RENDER_MOUNTAINS\n\td2 = sdMountains(pos + vec3z(pose.offset.z));\n\td1 = min2(d1, d2);\n#endif\n\n#ifdef RENDER_TREES\n\td2 = sdTrees(pos);\n\td1 = min2(d1, d2);\n#endif\n\n\td2 = sdGrass(pos); \n\td1 = min2(d1, d2);\n \n#ifdef RENDER_CLOUDS\n\tif (includeClouds)\n\t{\n\t\td2 = vec2(mapClouds(pos, time), MATERIAL_CLOUD);\n\t\td1 = min2(d1, d2);\n\t}\n#endif\n\n\treturn d1;\n}\n\n// inspired by iq, tdhooper, and klems - a way to prevent the compiler from inlining map() 4 times\nvec3 getNormal(in vec3 pos, float time, inout Pose pose)\n{\n\tvec3 n = vec3(0.0);\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tvec3 e = 0.5773 * (2.0 * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.0);\n\t\tn += e * map(pos + 0.0005 * e, time, pose, false).x;\n\t}\n\n\treturn normalize(n);\n}\n\nvec2 castRay(in vec3 ro, vec3 rd, float time, inout Pose pose, bool includeClouds) // ray origin, ray direction\n{\n\tfloat d = 0.0; // distance from ray origin\n\tfloat m = 0.0; // material\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + rd * d; // current position\n\t\tvec2 dm = map(pos, time, pose, includeClouds); // distance from current position to the scene\n\t\tm = dm.y;\n\n\t\tif (abs(dm.x) < SURF_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\td += dm.x;\n\n\t\tif (d > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn vec2(d, m);\n}\n\nfloat castCloudsRay(in vec3 ro, vec3 rd, float time) // ray origin, ray direction\n{\n\tfloat d = 0.0; // distance from ray origin\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + rd * d; // current position\n\t\tfloat d1 = mapClouds(pos, time); // distance from current position to the scene\n\n\t\tif (abs(d1) < SURF_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\td += d1;\n\n\t\tif (d > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn d;\n}\n\nfloat calcOcclusion(in vec3 pos, float time, vec3 nor, inout Pose pose)\n{\n\tfloat occlusion = 0.0; // occlusion\n\tfloat scale = 1.0; // scale\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat h = 0.01 + 0.11 * float(i) / 4.0;\n\t\tvec3 occlusionPos = pos + h * nor; // occlusion position\n\t\tfloat d = map(occlusionPos, time, pose, false).x;\n\t\tocclusion += (h - d) * scale;\n\t\tscale *= 0.95;\n\t}\n\n\treturn clamp(1.0 - 2.0 * occlusion, 0.0, 1.0);\n}\n\nfloat castShadow(in vec3 ro, vec3 rd, float time, inout Pose pose)\n{\n\tfloat result = 1.0;\n\tfloat t = 0.01; // position\n\n\tfloat maxT = MAX_DIST;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 pos = ro + t * rd;\n\t\tvec2 d = map(pos, time, pose, true);\n\t\tif (d.y > 0.0) // skip optimizations\n\t\t{\n\t\t\tresult = min(result, max(0.0, 16.0 * d.x / t)); // soft shadow\n\t\t}\n\n\t\tt += d.x;\n\n\t\tif (abs(d.x) < (t * 0.001) || t > maxT)\n\t\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nvec3 getMaterialColor(in vec2 dm, vec3 pos, vec3 nor, vec3 rd, float time, inout Pose pose)\n{\n\tvec3 color = vec3(0.0);\n\n\tvec3 posOffset = pos + nor * SURF_DIST; // point with a small offset\n\tvec3 material;\n\n\tif (dm.y < 0.5)\n\t{\n\t\tmaterial = vec3(1.0, 1.0, 0.0); // missing\n\t}\n\telse if (dm.y < MATERIAL_SKIN + 0.5)\n\t{\n\t\tmaterial = vec3(0.3, 0.3, 0.35);\n\t}\n\telse if (dm.y < MATERIAL_EAR + 0.5)\n\t{\n\t\tmaterial = vec3(0.5, 0.3, 0.3);\n\t}\n\telse if (dm.y < MATERIAL_EYE + 0.5)\n\t{\n\t\tmaterial = vec3(0.4);\n\t}\n\telse if (dm.y < MATERIAL_PUPIL + 0.5)\n\t{\n\t\tmaterial = vec3(0.02, 0.15, 0.6) * (0.2 + 0.8 * step(dm.y, MATERIAL_PUPIL + 0.06));\n\t}\n\telse if (dm.y < MATERIAL_MOUTH + 0.5)\n\t{\n\t\tmaterial = vec3(0.3, 0.15, 0.15);\n\t}\n\telse if (dm.y < MATERIAL_GRASS + 0.5)\n\t{\n\t\tmaterial = vec3(0.25, 0.25, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_FLOWER1 + 0.5)\n\t{\n\t\tmaterial = vec3(0.5);\n\t}\n\telse if (dm.y < MATERIAL_FLOWER2 + 0.5)\n\t{\n\t\tmaterial = vec3(0.5, 0.4, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_STEM + 0.5)\n\t{\n\t\tmaterial = vec3(0.2, 0.4, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_MOUNTAIN + 0.5)\n\t{\n\t\tmaterial = vec3(0.2, 0.3, 0.5);\n\t}\n\telse if (dm.y < MATERIAL_TREE1 + 0.5)\n\t{\n\t\tmaterial = vec3(0.04, 0.15, 0.1);\n\t}\n\telse if (dm.y < MATERIAL_TREE2 + 0.5)\n\t{\n\t\tmaterial = vec3(0.3, 0.05, 0.0);\n\t}\n\telse if (dm.y < MATERIAL_CLOUD + 0.5)\n\t{\n\t\tmaterial = vec3(0.6, 0.4, 0.5);\n\t}\n\n\tfloat occlusion = calcOcclusion(pos, time, nor, pose);\n\tfloat fresnel = clamp(1.0 + dot(rd, nor), 0.0, 1.0); // fresnel\n\n\t// sun\n\tfloat sunDiffuse = clamp(dot(nor, SUN_DIRECTION), 0.0, 1.0);\n\tfloat sunShadow = castShadow(posOffset, SUN_DIRECTION, time, pose);\n\n\tfloat bounceDiff = clamp(0.5 + 0.5 * dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0); // bounce diffuse, from the ground\n\n\tvec3 sunLight = sunDiffuse * 4.0 * vec3(0.7, 0.4, 0.3); // sun color\n\tsunLight *= vec3(sunShadow, pow(sunShadow, 2.0), pow(sunShadow, 4.0)); // sun shadow transition color\n\tsunLight += vec3(0.25, 0.25, 0.0) * bounceDiff; // bounce light\n\tsunLight += fresnel * 3.0 * vec3(0.6, 0.8, 1.2) * (0.5 + 0.5 * sunDiffuse) * (0.9 + 0.1 * clamp(sunShadow, 0.0, 1.0)); // sun fresnel\n\n\t// sky light\n\tvec3 skyDirection = normalize(vec3(0.0, 1.0, 0.0));\n\tfloat skyDiffuse = clamp(0.5 + 0.5 * dot(nor, skyDirection), 0.0, 1.0); // sky diffuse\n\tfloat skyReflection = smoothstep(0.3, 0.5, reflect(rd, nor).y); // sky reflection\n\tvec3 skyColor = vec3(0.1, 0.8, 1.0);\n\tvec3 skyLight = 0.3 * skyDiffuse * skyColor + 0.02 * skyReflection * skyColor;\n\n\tfloat fog = pow(smoothstep(5.0, 80.0, dm.x), 2.0);\n\tfog *= clamp(1.0 - rd.y * 6.0, 0.0, 1.0);\n\n\tcolor = material;\n\tcolor *= sunLight;\n\tcolor += skyLight;\n\tcolor *= occlusion;\n\tcolor = mix(color, vec3(0.5, 0.85, 0.95), fog);\n\n\treturn color;\n}\n\nfloat getCloudDensity(vec3 pos, float time)\n{\n\tvec4 pi = getCloudPosIndex(pos.xz, time, step(CLOUDS_HEIGHT, pos.y));\n\tvec3 pos1 = vec3(pi.x, pos.y, pi.z * 0.7);\n\tfloat index = pi.w;\n\n\tpos1.z += pos.z * 0.5;\n\tfloat density = fbm(0.55 * (pos1 + vec3(index * 10.0))) - 0.1;\n\tdensity *= 0.2;\n\tdensity *= smoothstep(0.0, -1.5, mapClouds(pos, time)); // shape mask\n\n\treturn clamp(density, 0.0, 1.0);\n}\n\nvec3 composeClouds(vec3 ro, vec3 rd, float time, float d, vec3 color)\n{\n\tfloat cd = castCloudsRay(ro, rd, time); // cloud distance\n\n\tfloat f = 1.0; // composition factor\n\tf -= 0.008 * max(cd - 40.0, 0.0); // clouds distance fog\n\n\tfor (int i = 0; i < 2; i++) // number of overlapping clouds\n\t{\n\t\tif (cd >= d || cd >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tfloat stepSize = 0.1;\n\t\tfor (int j = 0; j < 100; j++) // steps\n\t\t{\n\t\t\tif (cd >= d || f < 0.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec3 pos = ro + cd * rd;\n\n\t\t\tfloat density = getCloudDensity(pos, time);\n\t\t\tfloat density2 = 0.5 * (\n\t\t\t\tgetCloudDensity(pos + 0.1 * SUN_DIRECTION, time) +\n\t\t\t\tgetCloudDensity(pos + 0.2 * SUN_DIRECTION, time));\n\n\t\t\tvec3 stepColor = vec3(1.0, 0.5, 0.6);\n\t\t\tstepColor = mix(vec3(1.2), stepColor, clamp(density2 * 15.0, 0.0, 1.0)); // light\n\t\t\tstepColor = mix(vec3(0.2, 0.0, 0.1), stepColor, clamp(1.0 - density2 * 6.0, 0.0, 1.0)); // shadow\n\n\t\t\tcolor = mix(color , stepColor, density * f * 3.0);\n\t\t\tf -= density;\n\n\t\t\tcd += stepSize;\n\t\t}\n\n\t\tcd += castCloudsRay(ro + cd * rd, rd, time);\n\t}\n\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\n\ttime += 0.2;\n\ttime *= ANIMATION_SPEED;\n\n\tvec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 target = vec3(0.0, 1.0 + CAMERA_HEIGHT, -RUN_SPEED * time); // camera target\n\tfloat dist = 8.0 + CAMERA_DISTANCE; // camera distance\n\n\tfloat fov = 1.5; // field of view\n\n\tvec3 ro = vec3(0.0, 1.5 + CAMERA_HEIGHT, dist); // camera origin\n\n\tif (iMouse.z < 0.5)\n\t{\n\t\tvec2 an = vec2(-3.0 * sin(3.5 + time * 0.1), -0.7 + 0.5 * sin(1.0 + time * 0.2));\n\t\tdist = 10.0 + CAMERA_DISTANCE + 2.0 * sin(time * 0.3);\n\t\tfov = 1.2;\n\n\t\tvec3 dir = normalize(vec3(0.1, 0.3, 0.4)); // camera direction\n\t\tdir.yz = rotate(dir.yz, an.y);\n\t\tdir.xz = rotate(dir.xz, an.x);\n\t\tro = target + dir * dist;\n\t}\n\telse\n\t{\n\t\t// mouse camera angle\n\t\tvec2 an = vec2(3.0 + 12.0 * iMouse.x / iResolution.x, -3.0 * clamp(iMouse.y / iResolution.y, 0.0, 1.0));\n\n\t\tdist = 5.5 + CAMERA_DISTANCE + 2.0 * sin(time * 0.3);\n\t\tfov = 1.2;\n\n\t\tvec3 dir = normalize(vec3(0.1, 0.3, 0.4)); // camera direction\n\t\tdir.yz = rotate(dir.yz, an.y);\n\t\tdir.xz = rotate(dir.xz, an.x);\n\t\tro = target + dir * dist;\n\t}\n\n\tro.y = max(getGroundHeight(vec3(ro.x, 0.0, ro.z)) + 0.1, ro.y);\n\n\t// camera direction\n\tvec3 rdz = normalize(target - ro);\n\tvec3 rdx = normalize(cross(rdz, vec3(0.0, 1.0, 0.0)));\n\tvec3 rdy = cross(rdx, rdz);\n\tvec3 rd = normalize(uv.x * rdx + uv.y * rdy + fov * rdz);\n\n\tPose pose = getPose(time);\n\n\tvec2 dm = castRay(ro, rd, time, pose, false);\n\n\tvec3 color = vec3(0.0);\n\n\tif (dm.x < MAX_DIST)\n\t{\n\t\tvec3 pos = ro + dm.x * rd; // point in scene\n\t\tvec3 nor = getNormal(pos, time, pose); // point normal\n\t\tcolor = getMaterialColor(dm, pos, nor, rd, time, pose);\n\t}\n\telse\n\t{\n\t\t// sky texture\n\t\tcolor = getSkyTexture(rd);\n\t}\n\n#ifdef RENDER_CLOUDS\n\tcolor = composeClouds(ro, rd, time, dm.x, color);\n#endif\n\n\t// gamma correction\n\tcolor = pow(color, vec3(0.5));\n\n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}