{"ver":"0.1","info":{"id":"Mfcyz4","date":"1730306343","viewed":136,"name":"Polyrhythm visualizer fork","username":"firebreathz","description":"Inspired by these:\nhttps://www.youtube.com/watch?v=SthcxWPXG_E\nhttps://www.youtube.com/watch?v=lsAlFKXAMjM\nAudio stops after 3 minutes for reasons unknown to me.\n","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["music","visualizer"],"hasliked":0,"parentid":"XXjXzz","parentname":"Polyrhythm Visualizer"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = getBlurred(iChannel1,fragCoord-2.,2);\n    fragColor += getBlurred(iChannel1,fragCoord+vec2(2,-2),2);\n    fragColor += getBlurred(iChannel1,fragCoord+vec2(-2,2),2);\n    fragColor += getBlurred(iChannel1,fragCoord+2.,2);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel1,fragCoord,2);\n    fragColor *= 0.7;\n    fragColor += texelFetch(iChannel1,ivec2(fragCoord),0);\n    fragColor *= 0.01;\n    fragColor += texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Random function stolen from here: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec4 getBlurred( sampler2D image, vec2 coord , int blurAmount ){\n    ivec2 bottomLeft = (ivec2(coord)-(1<<(blurAmount-1)))>>blurAmount;\n    vec4 a = texelFetch(image,bottomLeft,blurAmount);\n    vec4 b = texelFetch(image,bottomLeft+ivec2(1,0),blurAmount);\n    vec4 c = texelFetch(image,bottomLeft+ivec2(0,1),blurAmount);\n    vec4 d = texelFetch(image,bottomLeft+ivec2(1,1),blurAmount);\n    \n    vec2 offset = (coord/float(1<<blurAmount)) - vec2(bottomLeft);\n    offset -= 0.5;\n    //offset *= (3.-2.*offset)*offset;\n    vec4 l = mix(a,c,offset.y);\n    vec4 r = mix(b,d,offset.y);\n    return mix(l,r,offset.x);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 penta[5] = vec4[5](vec4(1,0.42,0.42,1),vec4(0.93,0.72,0,1),vec4(0,0.92,0.63,1),vec4(0,0.8,1,1),vec4(0.9,0.53,1,1));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float constraint = min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/constraint;\n    float dist = sqrt(dot(uv,uv)); // Distance from center\n    float ang = atan(uv.x,uv.y); // Angle from top center of screen (clockwise=positive, counterclockwise=negative)\n    fragColor = vec4(0.1);\n    fragColor.rgb -= 0.01*dist*dist*dist+0.0015*random(fragCoord); // Vignette with dithering\n    float ring = round(dist*55.-5.);\n    if(ring>-0.5&&ring<20.5){\n        int note = int(ring);\n        note -= 5*(note/5); // Get which note in the scale this ring represents (determines its color)\n        float center = ring*0.0181818+0.09090909;\n        float cyc = fract(0.00262856483459*iTime*(332.+ring))*6.28318530718+ang;\n        if(cyc>6.28318530718){cyc -= 6.28318530718;}\n        if(cyc<0.){cyc += 6.28318530718;}\n        if(cyc<1./(dist*constraint)){cyc *= 1. - dist*constraint; cyc += 1.;}\n        else{cyc *= center + .5;}\n        cyc = clamp(cyc,0.,5.5);\n        vec4 bg = vec4(0.05);\n        vec4 head = mix(penta[note],vec4(0),-1.+clamp(fract(0.00262856483459*iTime*(332.+ring))*6.28318530718,0.,1.));\n        vec4 ringCol = mix(head,bg,cyc);\n        \n        float off = abs(dist-center);\n        fragColor = mix(ringCol,fragColor,clamp((off-0.06)*constraint,0.,1.)); // Anti-aliasing\n        \n        for(float i = ring; i < 21.; i++){\n            cyc = fract(0.00262856483459*iTime*(332.+i))*6.28318530718+ang;\n            if(cyc>3.1415926536){cyc -= 6.28318530718;}\n            if(cyc<-3.1415926536){cyc += 6.28318530718;}\n            cyc = 1.-clamp(abs(cyc*dist)*10.,0.,1.);\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= cyc;\n            cyc *= clamp((dist-0.083)*200.,0.,1.);\n            if(i == ring){cyc *= clamp((center-dist+0.008)*100.,0.,1.);}\n            fragColor += 0.3*vec4(cyc);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor -= 0.2;\n    fragColor = max(fragColor,0.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor  = getBlurred(iChannel0,fragCoord+vec2(0, 4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(0,-4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2( 4,0),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-4,0),1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord-2.,1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(2,-2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-2,2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+2.,1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord,2);\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor  = getBlurred(iChannel0,fragCoord+vec2(0, 4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(0,-4),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2( 4,0),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-4,0),1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord-2.,1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(2,-2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+vec2(-2,2),1);\n    fragColor += getBlurred(iChannel0,fragCoord+2.,1);\n    fragColor *= 0.7;\n    fragColor += getBlurred(iChannel0,fragCoord,1);\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}