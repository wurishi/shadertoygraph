{"ver":"0.1","info":{"id":"ddKXzR","date":"1680690451","viewed":66,"name":"Sphere Voronoi Cells","username":"Nemerix","description":"Voronoi cells, but on a sphere\nclick and drag to rotate","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"dlXGDl","parentname":"Learning voronoi tracking"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define SHOW_VORONOI_BUFFER\n#define OUT_OF_BOUNDS vec3(0.0, 0.0, 123456789.0)\n\nvec4 background(vec3 rd)\n{\n  float t1 = clamp( -rd.z, 0.0, 1.0);\n  float t2 = clamp(rd.z, 0.0, 1.0);\n  return mix(mix(vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.8, 1.0), t2), vec4(0.5, 0.5, 0.2, 1.0), t1);\n}\n\nvec3 sphereTrace(vec3 ro, vec3 rd, float r)\n{\n  float xd = dot(ro, rd);\n  float xx = dot(ro, ro);\n  float d2 = xx - xd * xd;\n  if (d2 > 1.0) return OUT_OF_BOUNDS;\n  float t = -xd - sqrt(xd*xd - xx + r*r);\n  return ro+t*rd;\n}\n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    //c = vec4(iMouse.xy / iResolution.xy, iMouse.z, 1.0);\n    //return;\n    c = vec4(vec3(0.0), 1.0);\n#ifdef SHOW_VORONOI_BUFFER\n    c = texelFetch(iChannel0, ivec2(f), 0);\n    uint id = uint(c.x);\n    c = ParticleCol(id);\n    return;\n#endif\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0 * f - iResolution.xy) /iResolution.x;\n    vec2 m = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n    m *= vec2(-2.0, 1.0) * PI;\n    \n    vec3 cameraPos = 4.5 * vec3(cos(m.x)*sin(m.y), sin(m.x)*sin(m.y), cos(m.y));\n    //mat2 cameraRot = mat2(cos(PI_2 * vec4(0, 3, 1, 0) + iTime));\n    //cameraPos.xy = cameraRot * cameraPos.xy;\n    vec3 cameraDirection = -normalize(cameraPos);\n    float nearPlane = 2.0;\n    vec3 cameraUp = vec3(0.0, 0.0, 1.0);\n    cameraUp = cameraUp - dot(cameraUp, cameraDirection) * cameraDirection;\n    cameraUp = normalize(cameraUp);\n    vec3 cameraRight = cross(cameraDirection, cameraUp);\n    vec3 rd = normalize(nearPlane*cameraDirection + uv.x*cameraRight + uv.y*cameraUp);\n    \n    c = background(rd);\n    \n    vec3 trace = sphereTrace(cameraPos, rd, 1.0);\n    if (trace != OUT_OF_BOUNDS)\n    {\n      vec2 pixel = SphereToPixel(trace);\n      c = texelFetch(iChannel0, ivec2(pixel*iResolution.xy + 0.5), 0);\n      c = ParticleCol(uint(c.x));\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define PI_2 PI / 2.0\n  \nconst uint kPlaneCount = 11u;\nconst uint kPartsPerPlane = 16u;\nconst uint kNumParts = kPlaneCount * kPartsPerPlane;\nconst float kPartAngleStep = 2.0*PI / float(kPartsPerPlane);\nconst float kPlaneAngleStep = 2.0*PI / float(kPlaneCount);\nconst float inclination = 60.0 * PI / 180.0;\nconst float sinIncl = sin(inclination);\nconst float cosIncl = cos(inclination);\nconst float particleAlt = 1.085;\nconst float particleW = 0.2; // angular velocity\n\nconst vec4[] colors = vec4[7](\nvec4(1,0,0,1),\nvec4(1,0.5,0,1),\nvec4(1,1,0,1),\nvec4(0,1,0,1),\nvec4(0,1,1,1),\nvec4(0,0,1,1),\nvec4(1,0,1,1));\n\nconst float[] intensities = float[8](\npow(1.0/8.0, 1.0/2.2),\npow(2.0/8.0, 1.0/2.2),\npow(3.0/8.0, 1.0/2.2),\npow(4.0/8.0, 1.0/2.2),\npow(5.0/8.0, 1.0/2.2),\npow(6.0/8.0, 1.0/2.2),\npow(7.0/8.0, 1.0/2.2),\npow(8.0/8.0, 1.0/2.2));\n\n#define ParticleAngles(i) vec2(float(i % kPartsPerPlane) * kPartAngleStep + iTime*particleW, float(i / kPartsPerPlane) * kPlaneAngleStep)\n#define ParticlePos(i) particleAlt * vec3(cos(i.x)*cos(i.y) + sin(i.x)*cosIncl*sin(i.y), -cos(i.x)*sin(i.y) + sin(i.x)*cosIncl*cos(i.y), sin(i.x)*sinIncl)\n#define ParticleCol(i) colors[(i / kPartsPerPlane) % 7U] * intensities[(i % kPartsPerPlane) % 8U]\n\n#define PixelToCyl(i) vec2(i.x * (2.0*PI/iResolution.x), clamp(i.y * (2.0/iResolution.y) - 1.0, -1.0, 1.0))\n#define CylToSphere(i) vec3(cos(i.x) * sqrt(1.0-i.y*i.y), sin(i.x) * sqrt(1.0-i.y*i.y), i.y)\n\n#define SphereToPixel(i) vec2(0.5 + atan(i.y, i.x) / (2.0 * PI), 0.5 + 0.5*i.z)\n\n#define VorBuffer(xy) texelFetch(iChannel0, ivec2(xy), 0)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// inserts the given new id if it's closer than one of the existing ones\nvoid tryInsert(inout vec4 ids, inout vec4 dists, in float newId, in float newDist)\n{\n  if (newDist >= dists.w || newId == 0.0) return;\n  if (any(equal(ids, vec4(newId)))) return;\n  if (newDist < dists.x)\n  {\n    ids = vec4(newId, ids.xyz);\n    dists = vec4(newDist, dists.xyz);\n    return;\n  }\n  if (newDist < dists.y)\n  {\n    ids = vec4(ids.x, newId, ids.yz);\n    dists = vec4(dists.x, newDist, dists.yz);\n    return;\n  }\n  if (newDist < dists.z)\n  {\n    ids = vec4(ids.xy, newId, ids.z);\n    dists = vec4(dists.xy, newDist, dists.z);\n    return;\n  }\n  ids = vec4(ids.xyz, newId);\n  dists = vec4(dists.xyz, newDist);\n}\n\n// distance between a point and the center of a particle w/ given ID\nfloat particleDist(vec2 thisPos, float particle)\n{\n  vec2 angles = ParticleAngles(uint(particle));\n  vec3 pos = ParticlePos(angles);\n  vec2 pixelCyl = PixelToCyl(thisPos);\n  vec3 pixelPos = CylToSphere(pixelCyl);\n  float dist = dot(pixelPos - pos, pixelPos - pos);\n  //dist = (particle == 0) ? 999999.0 : dist;\n  return dist;\n}\n\nconst int nOffsets = 5;\nconst ivec2 offsets[nOffsets] = ivec2[nOffsets](ivec2(0, 0),\nivec2(1, 0), ivec2(0, 1), ivec2(-1, 0), ivec2(0, -1)\n//ivec2(3, 0), ivec2(0, 3), ivec2(-3, 0), ivec2(0, -3),\n//ivec2(9, 0), ivec2(0, 9), ivec2(-9, 0), ivec2(0, -9)\n);\n\n// main image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  ivec2 thisPixel = ivec2(fragCoord);\n  vec4 ids = vec4(0.0);\n  vec4 dists = vec4(999999999.0);\n  \n  for (int offsetIdx = 0; offsetIdx < nOffsets; ++offsetIdx)\n  {\n    ivec2 otherPixel = (thisPixel + offsets[offsetIdx]) % ivec2(iResolution.xy);\n    //ivec2 otherPixel = thisPixel + offsets[offsetIdx];\n    vec4 otherIds = VorBuffer(otherPixel);\n    for(int i = 0; i < 4; i++)\n    { \n      tryInsert(ids, dists, otherIds[i], particleDist(fragCoord, otherIds[i]));\n    } \n  }\n  \n  int hash = 0;\n  for (int i = 0; i < 1; ++i)\n  {\n    hash = thisPixel.x * 98689 + thisPixel.y * 69313 + iFrame * 3307 + hash * 26227;\n    //hash = thisPixel.x + thisPixel.y * 1200;\n    float otherId = 1.0 + float(uint(hash) % kNumParts);\n    //otherId = 4U;\n    tryInsert(ids, dists, otherId, particleDist(fragCoord, otherId));\n  }\n  fragColor = ids;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //if (fragCoord != vec2(0.0, 0.0)) return;\n    if (iFrame == 0)\n    {\n      fragColor = vec4(0.5, 0.5, 0, 1);\n      return;\n    }\n    if (iMouse.z > 0.0)\n    {\n      fragColor = vec4(iMouse.xy / iResolution.xy, 0, 1);\n      return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}