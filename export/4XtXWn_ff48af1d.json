{"ver":"0.1","info":{"id":"4XtXWn","date":"1718945922","viewed":52,"name":"Klaus Nomi Is Tense Today","username":"multiphonic","description":"Happy accident with ChatGPT. Glitchy and lofi.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["audio","visualizer","equalizer","geometric"],"hasliked":0,"parentid":"43tXWn","parentname":"Square Wiggler 2"},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Square Wiggler\" by multiphonic. https://shadertoy.com/view/4XdSWn\n// 2024-06-20 08:45:21\n\n#define NUM_ROWS 12 // Number of rows\n#define MAX_CIRCLES 12 // Maximum number of circles in a row\n#define ALIASING_AMOUNT 0.001 // Amount of anti-aliasing (0.0 for hard edges, higher values for smoother edges)\n#define Y_PERSPECTIVE_WARP 0.96 // Y perspective warp control (0 for linear, values > 0 for exponential)\n#define BASE_LUMINOSITY 0.52 // Base luminosity of the circles\n#define TRANSPARENCY 0.5 // Transparency control (0.0 for fully transparent, 1.0 for fully opaque)\n#define ANGLE 1.9 // Angle control (-1.0 for left, 1.0 for right, 0.0 for center)\n#define BASS_SIZE_BOOST 1.7 // Size boost for the \"Bass\" circles\n#define INTENSITY 0.1 // Intensity control for music reactivity\n#define DIRECTION -1.0 // Direction of the push (-1.0 for left, 1.0 for right)\n#define NUM_SIDES 3 // Number of sides for the polygons (3 for triangles)\n#define INVERT_COLOR 0\n\nfloat getBand(int row) {\n    return texture(iChannel0, vec2(float(row) / float(NUM_ROWS), 0.5)).r;\n}\n\nvoid drawPolygon(inout vec3 color, vec2 uv, vec2 center, float size, float luminosity, int sides) {\n    float angle = 2.0 * 3.14159265359 / float(sides);\n    vec2 dist = abs(uv - center) / size;\n    float d = 1.0;\n    for (int i = 0; i < sides; i++) {\n        float a = angle * float(i);\n        d = min(d, abs(dist.x * cos(a) + dist.y * sin(a)));\n    }\n    float polygon = smoothstep(ALIASING_AMOUNT, -ALIASING_AMOUNT, d - 1.0);\n    color += vec3(luminosity) * polygon;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0); // Black background\n\n    // Parameters for the polygons\n    float basePolygonSize = 0.05; // Base size of the polygons\n    float yPosStart = 0.1; // Starting Y position of the first row (10% from the bottom)\n    float ySpacing = 0.4 / float(NUM_ROWS - 1); // Vertical spacing between rows to fit in the bottom half\n\n    // Calculate the aspect ratio and scaling factor\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 scaledUv = vec2(uv.x * aspectRatio, uv.y);\n\n    for (int row = 0; row < NUM_ROWS; row++) {\n        // Calculate the number of polygons in the current row based on the row index\n        float numPolygons = mix(5.0, float(MAX_CIRCLES), pow(float(row) / float(NUM_ROWS - 1), Y_PERSPECTIVE_WARP));\n\n        // Calculate the Y position for the current row\n        float yPos = yPosStart + float(row) * ySpacing;\n\n        // Calculate the size of polygons in the current row based on the perspective warp\n        float polygonSize = basePolygonSize * pow(1.0 - float(row) / float(NUM_ROWS - 1), Y_PERSPECTIVE_WARP);\n\n        // Apply the bass size boost to the first few rows\n        if (row < NUM_ROWS / 4) {\n            polygonSize *= BASS_SIZE_BOOST;\n        }\n\n        // Calculate the spacing between the polygons\n        float spacing = 1.0 / numPolygons;\n\n        // Get the band value for the current row\n        float bandValue = getBand(row) * INTENSITY * DIRECTION;\n\n        for (int i = 0; i < int(numPolygons); i++) {\n            // Calculate the position of each polygon, left justified\n            float xPos = float(i) * spacing;\n\n            // Apply the angle offset\n            xPos += ANGLE * (0.5 - xPos);\n\n            // Apply the band value for music reactivity\n            xPos += bandValue;\n\n            // Calculate the center position of the polygon\n            vec2 polygonCenter = vec2(xPos * aspectRatio, yPos);\n\n            // Draw the polygon and its mirrored versions\n            drawPolygon(color, scaledUv, polygonCenter, polygonSize, BASE_LUMINOSITY * TRANSPARENCY, NUM_SIDES);\n            drawPolygon(color, scaledUv, vec2((1.0 - xPos) * aspectRatio, yPos), polygonSize, BASE_LUMINOSITY * TRANSPARENCY, NUM_SIDES);\n            drawPolygon(color, scaledUv, vec2(xPos * aspectRatio, 1.0 - yPos), polygonSize, BASE_LUMINOSITY * TRANSPARENCY, NUM_SIDES);\n            drawPolygon(color, scaledUv, vec2((1.0 - xPos) * aspectRatio, 1.0 - yPos), polygonSize, BASE_LUMINOSITY * TRANSPARENCY, NUM_SIDES);\n        }\n    }\n\n    // Handle color overloading by mirroring values that go beyond 1.0\n    color = abs(fract(color * 0.5) * 2.0 - 1.0);\n\n    // Ensure the color does not exceed 1.0 (white)\n    color = clamp(color, 0.0, 1.0);\n\n    // Apply color inversion if enabled\n    if (INVERT_COLOR == 1) {\n        color = vec3(1.0) - color;\n    }\n\n    // Output the final color\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}