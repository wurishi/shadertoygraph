{"ver":"0.1","info":{"id":"lcXcRB","date":"1723246710","viewed":181,"name":"RESTLESS EMBERS","username":"alro","description":"\"The trick is not minding that it hurts.\"","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["3d","voronoi","fire","voxel","curl","glow","particle","spark","ember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Exploring particle rendering in Shadertoy. Use mouse to move camera.\n    \n    WIP to be cleaned up later\n\n    Buffer A: Camera\n    Cube A: 3D voronoi particle tracking\n    Buffer B: Camera facing particle rendering using voxel marching\n    Image: Bloom and tonemapping\n    \n    As with all voronoi tracking, some particles disappear\n    Because of the simplistic ray-particle intersection test, the particles flicker and are cut off\n    Hoping the movement and bloom hide the errors\n*/\n\nconst float bloomStrength = 2.75;\n\n//-------------------------------- Bicubic blur --------------------------------\n\n// https://www.shadertoy.com/view/Dl2SDW\n\n// Cubic B-spline weighting\nvec2 w0(vec2 a){\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nvec2 w1(vec2 a){\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nvec2 w2(vec2 a){\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nvec2 w3(vec2 a){\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 is the amplitude function\nvec2 g0(vec2 a){\n    return w0(a) + w1(a);\n}\n\n// h0 and h1 are the two offset functions\nvec2 h0(vec2 a){\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nvec2 h1(vec2 a){\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 bicubic(sampler2D tex, vec2 uv, vec2 textureLodSize, float lod){\n\t\n    uv = uv * textureLodSize + 0.5;\n    \n\tvec2 iuv = floor(uv);\n\tvec2 f = fract(uv);\n\n    // Find offset in texel\n    vec2 h0 = h0(f);\n    vec2 h1 = h1(f);\n\n    // Four sample points\n\tvec2 p0 = (iuv + h0 - 0.5) / textureLodSize;\n\tvec2 p1 = (iuv + vec2(h1.x, h0.y) - 0.5) / textureLodSize;\n\tvec2 p2 = (iuv + vec2(h0.x, h1.y) - 0.5) / textureLodSize;\n\tvec2 p3 = (iuv + h1 - 0.5) / textureLodSize;\n\t\n    // Weighted linear interpolation\n    // g0 + g1 = 1 so only one is needed for a mix\n    vec2 g0 = g0(f);\n    return mix( mix(textureLod(tex, p3, lod), textureLod(tex, p2, lod), g0.x),\n                mix(textureLod(tex, p1, lod), textureLod(tex, p0, lod), g0.x), g0.y);\n}\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n\n    vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n    vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n\n    vec4 floorSample = bicubic(s, uv, lodSizeFloor.xy, floor(lod));\n    vec4 ceilSample = bicubic(s, uv, lodSizeCeil.xy, ceil(lod));\n\n    return mix(floorSample, ceilSample, fract(lod));\n}\n\nvec4 getBlur(sampler2D s, vec2 uv, float blur){\n    float maxLod = floor(log2(iChannelResolution[0].x));\n    float lod = mix(0.0, maxLod-1.0, blur);\n    return textureBicubic(s, uv, lod);\n}\n\n//----------------------------- Tonemapping and output ------------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    if(bloomStrength > 0.0){\n        vec3 bloom = getBlur(iChannel0, uv, 0.2).rgb;\n        bloom += getBlur(iChannel0, uv, 0.35).rgb;\n        bloom += getBlur(iChannel0, uv, 0.55).rgb;\n        bloom += getBlur(iChannel0, uv, 0.6).rgb;\n        bloom /= 4.0;\n        col += bloomStrength * bloom;\n    }\n    \n    // Tonemapping\n    col = ACESFilm(col);\n    \n    col = gamma(col);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Track mouse movement and resolution change between frames and set camera position.\n*/\n\n#define CAMERA_DIST (float(width) * 1.05)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(2.9, 1.7);\n                mouse = vec2(0);\n            }\n            \n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p){\n   vec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n  \n  return mat4(vec4(xaxis, 0.0), vec4(yaxis, 0.0), vec4(-zaxis, 0.0), vec4(camera, 1.0));\n}\n\nmat4 perspective(float fieldOfView, float aspect, float near, float far) {\n    float f = tan(PI * 0.5 - 0.5 * radians(fieldOfView));\n    float rangeInv = 1.0 / (near - far);\n\n    return mat4(\n      f / aspect, 0.0, 0.0, 0.0,\n      0.0, f, 0.0, 0.0,\n      0.0, 0.0, (near + far) * rangeInv, -1.0,\n      0.0, 0.0, near * far * rangeInv * 2.0, 0.0\n    );\n}\n\n// https://www.shadertoy.com/view/Nd3fR2\nvec3 afmhot(float t) {\n  const vec3 c0 = vec3(-0.020390, 0.009557, 0.018508);\n  const vec3 c1 = vec3(3.108226, -0.106297, -1.105891);\n  const vec3 c2 = vec3(-14.539061, -2.943057, 14.548595);\n  const vec3 c3 = vec3(71.394557, 22.644423, -71.418400);\n  const vec3 c4 = vec3(-152.022488, -31.024563, 152.048692);\n  const vec3 c5 = vec3(139.593599, 12.411251, -139.604042);\n  const vec3 c6 = vec3(-46.532952, -0.000874, 46.532928);\n  return clamp(c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6))))), 0.0f, 1.0f);\n}\n\nvec3 getColour(float t){\n    return invGamma(afmhot(smoothstep(0.15, 1.15, t)));\n}\n\n// https://www.shadertoy.com/view/4dfGzs\nvec3 traceVoxels(vec3 org, vec3 rayDir, vec2 fragCoord, mat4 invViewMatrix){\n    \n\tvec3 cell = floor(org);\n\tvec3 delta = 1.0 / rayDir;\n\tvec3 dir = sign(rayDir);\n    \n    vec3 mask = vec3(0);\n\tvec3 axisDist = (cell - org + 0.5 + dir * 0.5) * delta;\n    \n    vec3 col = vec3(0);\n    \n    mat4 perspectiveMatrix = perspective(FOV, iResolution.x / iResolution.y, 0.0, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    for(int i = ZERO; i < 256; i++){\n\n        vec4 data = getData(cell, iChannel1);\n        float core = smoothstep(120.0, 0.0, length(data.xyz));\n\n        //https://stackoverflow.com/questions/8608844/resizing-point-sprites-based-on-distance-from-the-camera\n        float spriteWidth = mix(0.0, 0.0015, data.a/duration) * smoothstep(130.0, 0.0, length(data.xyz));\n        vec4 eyePos = invViewMatrix * vec4(data.xyz, 1.0); \n        vec4 projCorner = perspectiveMatrix * vec4(0.5 * spriteWidth, 0.5 * spriteWidth, eyePos.z, eyePos.w);\n        float size = 1280.0 * projCorner.x / projCorner.w;\n        \n        vec4 clip = perspectiveMatrix * eyePos;\n        clip.xyz /= clip.w;  \n        clip.xy = clip.xy * 0.5 + 0.5;\n        clip.x *= iResolution.x / iResolution.y;\n\n\n        float dist = length(uv - clip.xy);\n        if(dist < size && length(data.xyz) < 0.5 * float(width)){\n            col += getColour(data.a/duration * core) * core;\n            break;\n        }\n        \n        // Create 1 for whichever component is smallest and 0 for others\n\t\tmask = step(axisDist.xyz, axisDist.yzx) * step(axisDist.xyz, axisDist.zxy);\n        // Step axis-delta amount along the minimum axis and 0 for others\n\t\taxisDist += mask * dir * delta;\n        // Increment cell\n        cell += mask * dir;\n\n        // Return when outside the domain\n        if( (dir.x < 0.0 && cell.x < -0.5*scale.x) || \n            (dir.x > 0.0 && cell.x >= 0.5*scale.x) || \n            (dir.y < 0.0 && cell.y < -0.5*scale.y) || \n            (dir.y > 0.0 && cell.y >= 0.5*scale.y) || \n            (dir.z < 0.0 && cell.z < -0.5*scale.z) || \n            (dir.z > 0.0 && cell.z >= 0.5*scale.z)){\n            return col;\n        }\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(FOV, fragCoord, iResolution.xy);\n\n    //----------------- Define a camera -----------------\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    rayDir = (viewMatrix * vec4(rayDir, 0.0)).xyz;\n\n    //---------------------------------------------------\n\n    mat4 invViewMatrix = inverse(viewMatrix);\n    \n    vec2 intersections = intersectAABB(cameraPos, rayDir, vec3(-0.5*scale-1.0), \n                                                          vec3(0.5*scale+1.0));\n    if(insideAABB(cameraPos, vec3(-0.5*scale-1.0), vec3(0.5*scale+1.0))){\n        intersections.x = 0.0;\n    }\n    vec3 col = vec3(0);\n    if(intersections.x >= 0.0 && (intersections.x < intersections.y)){\n        vec3 p = cameraPos + rayDir * max(0.0, intersections.x);\n        \n        vec3 data = traceVoxels(p, rayDir, fragCoord, invViewMatrix);\n        col += data;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2024 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\nconst float res = 8.0;\nconst float duration = 10.0;\n\n#define GAMMA 2.2\n#define INV_GAMMA (1.0/GAMMA)\n#define PI 3.14159\n#define TWO_PI (2.0*PI)\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\n#define FOV 60.0\n\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(INV_GAMMA));\n}\n\nvec3 invGamma(vec3 col){\n\treturn pow(col, vec3(GAMMA));\n}\n\n// Side length of domain\n// Max 184 as we use 4 channnels of a 1024 cubemap\n// For single channel data the max would be 293\nconst uint width = 128u;\nconst uint maxIdx = width * width * width;\nconst vec3 scale = vec3(width);\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\n// ----------------- Data lookup -----------------\n\nvec3 idxToPoint(uint idx){\n    return min(scale, vec3(idx % width, \n                           uint(float(idx)/float(width)) % width, \n                           uint(float(idx)/float(width * width))));\n}\n\nuint pointToIdx(vec3 p){\n    p = clamp(p, vec3(0), scale-1.0);\n    return uint(p.z * float(width * width) + p.y * float(width) + p.x);\n}\n\nvec3 idxToDir(uint idx){\n       \n    uint face = uint(float(idx)/float(1024u * 1024u));\n    vec2 fragCoord = vec2(idx % 1024u, uint(float(idx)/float(1024u)) % 1024u) + 0.5;\n    vec2 uv = 2.0 * (fragCoord/1024.0) - 1.0;\n\n    vec3 rayDir;\n    switch(face){\n        case 0u: rayDir = vec3( 1,  -uv.yx); break;\n        case 1u: rayDir = vec3(-1,  -uv.y, uv.x); break;\n        case 2u: rayDir = vec3(uv.x,   1,  uv.y); break;\n        case 3u: rayDir = vec3(uv.x,  -1,  -uv.y); break;\n        case 4u: rayDir = vec3(uv.x, -uv.y,  1); break;\n        case 5u: rayDir = vec3(-uv,  -1);  break;\n    }\n\n    return rayDir;\n}\n\nvec4 getData(vec3 p, samplerCube s){\n    p += vec3(0.5 * scale);\n    p = clamp(p, vec3(0), scale-1.0);\n    return texture(s, idxToDir(pointToIdx(floor(p))));\n}\n\n//-------------------------- AABB -------------------------\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 boxMin, vec3 boxMax){\n    float eps = 1e-4;\n\treturn  (p.x > boxMin.x-eps) && (p.y > boxMin.y-eps) && (p.z > boxMin.z-eps) && \n\t\t\t(p.x < boxMax.x+eps) && (p.y < boxMax.y+eps) && (p.z < boxMax.z+eps);\n}\n\nbool testAABB(vec3 org, vec3 dir, vec3 boxMin, vec3 boxMax){\n    return insideAABB(org, boxMin, boxMax);\n\tvec2 intersections = intersectAABB(org, dir, boxMin, boxMax);\n\t\n    if(insideAABB(org, boxMin, boxMax)){\n        intersections.x = 1e-4;\n    }\n    \n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//---------------------------- Noise ----------------------------\n\n// 5th order polynomial interpolation\nvec3 fade(vec3 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 p){\n\n    // Offset to vary look\n    //p += floor(0.5*iTime);\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = fade(f);\n    \n    /*\n    * For 1D, the gradient of slope g at vertex u has the form h(x) = g * (x - u), where u \n    * is an integer and g is in [-1, 1]. This is the equation for a line with slope g which \n    * intersects the x-axis at u.\n    * For N dimensional noise, use dot product instead of multiplication, and do \n    * component-wise interpolation (for 3D, trilinear)\n    */\n    return mix( mix( mix( dot( hash(i + vec3(0.0,0.0,0.0)), f - vec3(0.0,0.0,0.0)), \n              dot( hash(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0)), \n              dot( hash(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n    mix( mix( dot( hash(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0)), \n              dot( hash(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0)), \n              dot( hash(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\n//---------------------------- Curl ----------------------------\n\n// https://atyuwen.github.io/posts/bitangent-noise/\nvec3 computeCurl(vec3 p){\n\n    const float eps = 1e-4;\n\n    float dx = noise(p + vec3(eps, 0, 0)) - noise(p - vec3(eps, 0, 0));\n    float dy = noise(p + vec3(0, eps, 0)) - noise(p - vec3(0, eps, 0));\n    float dz = noise(p + vec3(0, 0, eps)) - noise(p - vec3(0, 0, eps));\n\n    vec3 noiseGrad0 = vec3(dx, dy, dz)/(2.0 * eps);\n\n    // Offset position for second noise read\n    p += 1000.5;\n\n    dx = noise(p + vec3(eps, 0, 0)) - noise(p - vec3(eps, 0, 0));\n    dy = noise(p + vec3(0, eps, 0)) - noise(p - vec3(0, eps, 0));\n    dz = noise(p + vec3(0, 0, eps)) - noise(p - vec3(0, 0, eps));\n\n    vec3 noiseGrad1 = vec3(dx, dy, dz)/(2.0 * eps);\n\n    noiseGrad1 = normalize(noiseGrad1);\n    noiseGrad1 = normalize(noiseGrad1);\n    vec3 curl = cross(noiseGrad0, noiseGrad1);\n\n    return normalize(curl);\n}\n\nvec4 getInitial(vec3 p){\n    vec3 pos = p + res * (2.0 * hash(p.xyz + floor(5.0 * iTime)) - 1.0);\n    return vec4(pos, duration * hash13(pos));\n}\n\nvoid swap(inout vec4 particle, vec3 pos, vec3 offset) {\n    vec4 neighbour = getData(pos + offset, iChannel0);\n    if (length(pos - neighbour.xyz) < length(pos - particle.xyz)){\n         particle = neighbour;\n    }\n}\n\n//-------------------------------- Storage --------------------------------\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    \n    vec3 rd = abs(rayDir);\n\n    uint face;\n    if(rd.x > rd.y && rd.x > rd.z){\n        face = rayDir.x > 0.0 ? 0u : 1u;\n    }else if(rd.y > rd.z){\n        face = rayDir.y > 0.0 ? 2u : 3u;\n    }else{\n        face = rayDir.z > 0.0 ? 4u : 5u;\n    }\n\n    uint idx = face * 1024u * 1024u + uint(fragCoord.y) * 1024u + uint(fragCoord.x);\n    \n    if(idx > 0u && idx < maxIdx){\n    \n        vec3 pos = idxToPoint(idx) - 0.5 * float(width);\n        \n        vec4 a = getData(pos, iChannel0);\n        \n        if(a.w <= 0.0 || (length(pos - a.xyz) > res && mod(pos.x, res) < 1.0 && mod(pos.y, res) < 1.0)){\n            fragColor = getInitial(pos);\n        }else{\n        \n            // Find nearest particle\n            \n            swap(a, pos, vec3(-1,-1,-1));\n            swap(a, pos, vec3(-1,-1,0));\n            swap(a, pos, vec3(-1,-1,1));\n\n            swap(a, pos, vec3(-1,0,-1));\n            swap(a, pos, vec3(-1,0,0));\n            swap(a, pos, vec3(-1,0,1));\n\n            swap(a, pos, vec3(-1,1,-1));\n            swap(a, pos, vec3(-1,1,0));\n            swap(a, pos, vec3(-1,1,1));\n\n\n            swap(a, pos, vec3(0,-1,-1));\n            swap(a, pos, vec3(0,-1,0));\n            swap(a, pos, vec3(0,-1,1));\n\n            swap(a, pos, vec3(0,0,-1));\n            //swap(a, pos, vec3(0,0,0));\n            swap(a, pos, vec3(0,0,1));\n\n            swap(a, pos, vec3(0,1,-1));\n            swap(a, pos, vec3(0,1,0));\n            swap(a, pos, vec3(0,1,1));\n            \n            \n            swap(a, pos, vec3(1,-1,-1));\n            swap(a, pos, vec3(1,-1,0));\n            swap(a, pos, vec3(1,-1,1));\n\n            swap(a, pos, vec3(1,0,-1));\n            swap(a, pos, vec3(1,0,0));\n            swap(a, pos, vec3(1,0,1));\n\n            swap(a, pos, vec3(1,1,-1));\n            swap(a, pos, vec3(1,1,0));\n            swap(a, pos, vec3(1,1,1));\n            \n            vec3 cu = computeCurl(0.015 * a.xyz) + computeCurl(0.025 * a.xyz);\n\n            a.xyz += 0.25 * cu;\n            a.w = max(0.0, a.w - 0.01);\n            a.w *= saturate(length(cu));\n\n            fragColor = a;\n       }\n    }else{\n       fragColor = vec4(0);\n    }\n}","name":"Cube A","description":"","type":"cubemap"}]}