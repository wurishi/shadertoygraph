{"ver":"0.1","info":{"id":"csByWd","date":"1688317765","viewed":60,"name":"Belousov-Zhabotinsky Automata","username":"tomato","description":"This is my attempt to model the belousov-Zhabotinsky chemical reaction\nBuffer A to stores previous generation. The blue channel is used to carry the reaction state\n\ninspiration: https://www.youtube.com/watch?v=t_HcBAO_Yas&ab_channel=Acerola","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d","belousovzhabotinsky","cellularautomata"],"hasliked":0,"parentid":"cd2cRd","parentname":"Smooth Li fe"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CHEM vec3(0.1,0.1,1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float state = texture(iChannel0, uv / SCALE).b;\n    vec4 col = vec4(CHEM, 1.);\n    col.b = state;\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BRUSH_SIZE 20.\n#define SLOW 10\n\n#define MAX_STATE 1.\n#define G .1\n\n// Returns sum of neighbors and number of neighbors\nfloat get_neighbors(ivec2 p) {\n    float sum = 0.;\n    for (int x = -1; x < 2; x++)\n        for (int y = -1; y < 2; y++) {\n            sum += texelFetch(iChannel1, ivec2(mod((vec2(p) + vec2(x, y) + iResolution.xy), iResolution.xy)), 0).b;\n        }\n    return sum / 8.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(0.);\n    \n    if (iFrame == 0) // initial noise texture\n        col.b = texture(iChannel0, uv).r;\n    else if (iFrame % SLOW != 0) // wait\n        col = texture(iChannel1, uv);\n        //if (col.b == 1.0) col = vec4(1.0);\n    else {\n    \n        float next = get_neighbors(ivec2(fragCoord));\n        next += G;\n        if (next >= MAX_STATE) next = 0.0; // reset to 0 state\n        col.b = next;\n    }\n    \n    if (iMouse.z > 0.5 && length(iMouse.xy / SCALE - fragCoord.xy) < BRUSH_SIZE)\n        col.b = 0.;\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SCALE 1.","name":"Common","description":"","type":"common"}]}