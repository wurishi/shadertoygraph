{"ver":"0.1","info":{"id":"MscSz8","date":"1457581275","viewed":363,"name":"Sphere Smooth movement","username":"sagar_unityDev","description":"Showcases smooth movement of spheres through each other.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// as learned from the excellent tutorial by @uint9\n// http://9bitscience.blogspot.de/2013/07/raymarching-distance-fields_14.html\n// distance functions by iq\n\nconst int RM_STEPS = 64;\nconst float RM_TOLERANCE = 0.001;\nconst float FOCAL_LENGTH = 1.2;\nconst float NEAR = 0.01;\nconst float FAR = 5.0;\n\nfloat sdSphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y + 0.1;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(100.,0.1,0.1));\n  float db = sdBox(p.yzx,vec3(0.1,100.,0.1));\n  float dc = sdBox(p.zxy,vec3(0.1,0.1,100.));\n  return smin(da,smin(db,dc, 64.), 64.);\n}\n \n\nfloat sdf(vec3 p) {\n  //p.x = mod(p.x, 0.5) - 0.25;\n  //p.z = mod(p.z, 1.0) - 0.5;\n  float sphere = sdSphere(p, 0.1);\n  float plane = sdPlane(p);\n  float offset = mod(iTime,4.0) <= 2.0 ? mix(0.5, -0.5, mod(iTime,2.0)*0.5) : mix(-0.5, 0.5, mod(iTime,2.0)*0.5);\n  float sphere1 = sdSphere(vec3(p.x+offset, p.y, p.z), 0.1);\n  //sphere = min(1., sdCross(p));\n  sphere = smin(sphere, sphere1, 32.);\n  return min(sphere, plane);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tsdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n\t\tsdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n\t\tsdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))));\n}\n\nfloat getShadow(vec3 p0, vec3 p1, float k) {\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0 * RM_TOLERANCE;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0;\n\tfor(int i = 0; i < RM_STEPS; ++i)\n\t{\n\t\tfloat d = sdf(p0 + rd * t);\n\t\tif(d < RM_TOLERANCE)\n\t\t\treturn 0.0;\n\t\tf = min(f, k * d / t);\n\t\tt += d;\n\t\tif(t >= maxt)\n\t\t\tbreak;\n\t}\n\treturn f;\n}\n\nvoid raymarch(vec3 ro, vec3 rd, out int steps, out float t) {\n\tt = 0.0;\n    for(int j = 0; j < RM_STEPS; ++j) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if(d < RM_TOLERANCE) {\n         \tsteps = j;   \n            break;\n        }\n        t += d;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eye = vec3(0, 0, -1.0);\n    vec3 up = vec3(0, 1.0, 0);\n    vec3 right = vec3(1.0, 0, 0);\n\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.y = uv.y * iResolution.y/iResolution.x;\n    \n    vec3 ro = eye;\n    vec3 rd = normalize(cross(right, up) * FOCAL_LENGTH + right * uv.x + up * uv.y);\n\n    vec4 lightColor1 = vec4(0.8, 1.0, 1.0, 1.0);\n    vec3 lightPosition1 = vec3(\n        sin(iTime) * 2.0,\n        2.0,\n        cos(iTime) * 2.0\n    );\n    vec4 lightColor2 = vec4(1.0, 1.0, 0.8, 1.0);\n    vec3 lightPosition2 = vec3(\n        cos(iTime) * 2.0,\n        2.0,\n        sin(iTime) * 2.0\n    );\n    \n    vec4 ambientColor = vec4(vec3(0.1),1.0);\n    vec4 color = vec4(0.9); // Sky color\n    \n    // rotate camera\n\tmat3 rot = rotationXY( vec2( 0.4, 0.0 ) );\n\trd = rot * rd;\n\tro = rot * ro;  \n\n    float t = 0.0;\n    int i = 0;\n    raymarch(ro, rd, i , t);\n    \n    vec3 p;\n    if(t > NEAR && t < FAR) {\n    \tp = ro + rd * t;\n        vec3 lightDirection1 = normalize(lightPosition1 - p);\n        vec3 lightDirection2 = normalize(lightPosition2 - p);\n        \n    \tfloat lightIntensity1 = 0.0;\n        float lightIntensity2 = 0.0;\n    \tfloat shadow1 = getShadow(p, lightPosition1, 8.0);\n        float shadow2 = getShadow(p, lightPosition2, 8.0);\n        \n        if(shadow1 > 0.0) {\n            lightIntensity1 = clamp(\n                dot(getNormal(p), lightDirection1), 0.0, 1.0\n            ) * shadow1;\n        }\n        if(shadow2 > 0.0) {\n            lightIntensity2 = clamp(\n                dot(getNormal(p), lightDirection2), 0.0, 1.0\n            ) * shadow2;\n        }\n        \n        color = smoothstep(\n            vec4(0.0),\n            vec4(1.8),\n            lightColor1 * lightIntensity1 +\n           \tlightColor2 * lightIntensity2 +\n           \tambientColor * (1.0 - lightIntensity1 * lightIntensity2));\n    }\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}