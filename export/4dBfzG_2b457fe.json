{"ver":"0.1","info":{"id":"4dBfzG","date":"1500826411","viewed":1216,"name":"[SH17C] 2D line distance field","username":"etale_cohomology","description":"Lines are easy, right? But distance fields are hard =)\nWe explore some ways of computing the 2D signed/unsigned distance field for a line.\n\nPlease do correct any inaccuracies! I'm just a newbie trying to learn =)\n\nUse mouse to move the 2nd point around.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","math","tutorial","line","distance","field"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Signed distance field for a line.\n// Everything \"above\" is black, everything \"below\" is white (hopefully!)\n\n// First formula stolen from Chapter 1 of\n// https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000&context=facpub\n// Other formulas courtesy of Shadertoy, ollj, Klems, valentingalea.\n\n// The distance field for a subset of the plane is a scalar field that\n// encodes the distance from each point of the plane to that subset of the plane.\n// (A scalar field on a vector space V over a field F is a map from the vector space V\n// to its field of scalars F. We use the terms \"distance field\" and \"distance function\"\n// interchangeably, since a distance field on a real vector space is an example of a scalar field,\n// because a distance is just a (non-negative) real number, and the field of scalars of a real\n// vector space is, well, the real numbers!)\n\n// In other words, let R2 be the plane, let S be a subset of the plane R2.\n// Then R2 is a vector space and its field of scalars is the\n// field of real numbers R. The distance field for S is a scalar field on R2 whose value at each\n// point in R2 is the (smallest) distance from that point to S.\n\n// In every vector space, every inner-product induces a norm, and every norm induces a metric.\n// Since the plane R2 (also known as 2-dimensional Euclidean space) is a vector space, its\n// inner-product (which you could call the Euclidean inner-product, or the dot product) induces\n// a norm (which you could call the Euclidean norm, or the Euclidean length, or the Euclidean length\n// function), and this norm induces a metric (which you could call the Euclidean metric, or the\n// Euclidean distance, or the Euclidean distance function.)\n// Recall that a metric (aka. distance function) on a vector space V|F is a\n// positive-definite subadditive symmetric map from V x V to the reals.\n// (Example: the Euclidean metric on R2 is a metric.)\n// In particular, distance functions are, by definition, non-negative everywhere!\n\n// A signed distance function SDF, however, relaxes this requirement by allowing negative values.\n// This allows SDF to store topological information about S, namely, about\n// the exterior of S and the interior of S, in such a way a point in R2 has positive distance\n// if it's in the exterior of S, zero distance if it's in the boundary of S,\n// and negative distance if it's in the interior of S. (I don't know if the implications hold\n// the other way!)\n\n// This sounds super nice from the point of view of mathematics, and, from the point of view of\n// computer graphics, it's very useful. It allows us to render the subset S whose signed\n// distance field we have! (I don't think we need the full weight of the signed distance field,\n// though. For many purposes, a (vanilla) distance field seems to do the job.)\n\n// As far as I know, the problem of deriving the signed distance field in analytic closed-form\n// for an arbitrary subset of the plane R2, given some algebraic/analytic representation of S,\n// is in general very hard. As far as I know, there's no known general algorithm to do so, and\n// currently it's done on a case-by-case basis.\n// And in 3-dimensional space it seems to be even harder.\n\n// The simplest subsets of the plane R2 seem to be, in a way that I'm sure can be made precise,\n// R2 itself, the empty set, the singletons, and the lines.\n// So, each of these must have a signed distance function associated to them.\n// The signed distance field for R2 and for the empty set should be trivial, taking constant\n// values everywhere.\n\n// In this shader, we explore some ways of computing the signed and the unsigned distance field\n// for a line on R2. Note that we talk about *the* signed distance field for a line (and also\n// about *the* unsigned distance field for a line), since the distance from a given point to a \n// given line is unique (as long as we don't change our definition of \"distance\", and there are many\n// possible definitions!). However, even though the distance from a given point to a given line is a\n// unique number, there's many ways to arrive at that number.\n\n// Don't confuse the distance function of the vector space R2 with the distance function for a line\n// on R2.\n// The distance function of R2 is a way of measuring the distance between any two points.\n// The distance function for a line on R2 is a way of measuring the distance from any point in R2 to\n// that line. The distance function for a line on R2, confusingly, is based on the distance function\n// of R2, since the distance function of R2 is the \"universal\" way of measuring distances on R2!\n// Even more confusingly, the \"standard\" distance function of R2, which is called the Euclidean\n// distance function, is not the only possible distance function that one can place on R2 (but we\n// won't get into this).\n\n// We use the terms \"point\", \"vertex\", and \"position vector\" interchangeably.\n\n#define LINE_THICKNESS 4.\n\n// ------------------------------------------------------------------------------------------------\n// There's 3 major types of norm-related products for 2D vectors:\n//   0) the dot product\n//   1) the cross-norm product\n//   2) the norm product.\n// The dot product is related to the cosine of 2 vectors.\n// The cross-norm product is related to the sine of 2 vectors.\n// The norm product is the product of the norms of 2 vectors.\n// We include implementations of all 3 products, for didactic purposes.\n// Note that GLSL includes 1 of these already: the dot product!\n\n// In terms of angles, the dot product is the norm product times the cosine of the angle.\nfloat dot_product(vec2 vec_a, vec2 vec_b){\n    return vec_a.x * vec_b.x + vec_a.y * vec_b.y;\n}\n\n// Compute the signed-norm of the cross-product of two 2-dimensional vectors!\n// We call this the cross-norm product =)\n// In terms of angles, the cross-norm product is the norm product times the sine of the angle.\n// This is also the exterior product of two 2-dimensional vectors. The exterior product of two\n// 2-dimensional vectors is a 2-vector. But, over 2 dimensions, a 2-vector is a pseudoscalar,\n// which is dual to a scalar and behaves somewhat like a scalar. 2-vectors form a vector space\n// called the 2nd exterior power. 2-vectors are part of a family of objects called n-vectors, or\n// multivectors.\n// A plain, vanilla vector is a 1-vector, and can be interpreted as an oriented\n// line segment. A 2-vector can be interpreted as an oriented area. A 3-vector can be interpreted as\n// an oriented volume, but in 2 dimensions there's no 3-vectors!\n// Multivectors are used to construct a very powerful and useful structure associated to any\n// vector space: its exterior algebra. The exterior algebra of Euclidean n-space is a Hopf algebra,\n// and, as such, it's closely related to quantum groups, which are also Hopf algebras.\n// https://en.wikipedia.org/wiki/Exterior_algebra\n// https://en.wikipedia.org/wiki/Multivector\n// https://en.wikipedia.org/wiki/Quantum_group\nfloat crossnorm_product(vec2 vec_a, vec2 vec_b){\n    return vec_a.x * vec_b.y - vec_a.y * vec_b.x;\n}\n\n// The norm product of 2 vectors is just the product of their norms.\nfloat norm_product(vec2 vec_a, vec2 vec_b){\n    return length(vec_a) * length(vec_b);\n}\n\n// ------------------------------------------------------------------------------------------------\n// One possible way of computing the signed distance field for a line on the plane!\n// We specify a line by two points that the line passes through. There's many\n// ways of specifying a line, and this is just one of them that I happen to like!\n// This function is the MEAT of the whole shader. You realy need to understand\n// WHY this gives the signed distance function of a line on the plane.\n// I still don't understand it, so I'm not doing much explanation!\n// This function gives the signed distance from an arbitrary point `uv` in the plane\n// to a line that passes through vert_A and vert_B.\n// Formula stolen from Chapter 1 of\n// https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000&context=facpub\nfloat sdf_line0(vec2 uv, vec2 vert_A, vec2 vert_B){\n    float delta_y = vert_B.y - vert_A.y;\n    float delta_x = vert_B.x - vert_A.x;\n    float slope = delta_y / delta_x;  // Slope of the line given 2 vertices on the line\n    float y_intersect = vert_A.y - slope * vert_A.x;  // This is the y-coordinate of the point (0,y) in R2 that is also in the line\n\n    // There's many representations for a line. This is just one of them:  ax + by + c = 0.\n    // Namely, a line on the plane R2 is the set of all points (x,y) in R2 that satisfy\n    // the equation  ax + by + c = 0.\n    // The letters `a`, `b`, and `c` are real numbers, and they encode information\n    // about the slope of the line and the points it passes through!\n    float coeff_a = slope;\n    float coeff_b = -1.;\n    float coeff_c = y_intersect;\n    float norm = sqrt(coeff_a * coeff_a + coeff_b * coeff_b);\n    float standard_form = coeff_a * uv.x + coeff_b * uv.y + coeff_c;\n\n    // Why does this end up being the signed distance to our line? I'm not sure, yet!\n    // But I stole the idea from Chapter 1 of\n    // https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000&context=facpub\n    return standard_form / norm;\n}\n\n// A compact, unreadable version of the signed distance field above!\nfloat sdf_line1(vec2 uv, vec2 vert_A, vec2 vert_B){\n    float slope = (vert_B.y - vert_A.y) / (vert_B.x - vert_A.y);\n    float standard_form = slope * uv.x - uv.y + vert_A.y - slope * vert_A.x;\n    float norm = sqrt(slope * slope + 1.);\n    return standard_form / norm;\n}\n\n// ollj's signed function function using vector arithmetic. Sweet!\nfloat sdf_line2(vec2 uv, vec2 vert_A, vec2 vert_B){\n    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel!\n    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B\n    // The vector-projection of vector X to vector Y is a scalar multiple of vector Y.\n    vec2 vector_projection_AP_AB = dvec_AB * (dot(dvec_AP, dvec_AB) / dot(dvec_AB, dvec_AB));\n    vec2 dvec_uv_vproj_AP_AB = uv - vector_projection_AP_AB;\n    return sign(dvec_uv_vproj_AP_AB.x * dvec_AB.y) * length(dvec_uv_vproj_AP_AB);  // This is the (signed) distance!\n}\n\n// ollj's signed distance function using atan2\n// Mirror by axis that is rotated by `angle * .5` per fragment, almost identical to planar rotation\n#define rotate_2D(r) mat2(sin(r + vec4(1., 0, 0, -1.) * asin(1.)))\n// rotate_alt(r) returns wrong x-value, but may save a multiplication\n// #define rotate_alt(r) mat2(sin(r + vec4(0, 0, 0, -asin(1.))))\nfloat sdf_line3(vec2 uv, vec2 vert_A, vec2 vert_B){\n    vec2 dvec_AB = vert_A - vert_B;\n    float angle = atan(dvec_AB.y, dvec_AB.x);  // Compute angle using atan2; it has branching, and it's slow.\n    uv = rotate_2D(angle) * uv;  //  Rotate vertex `uv` by `angle`\n    return -uv.y;  // Signed distance!\n    // return abs(uv.y);  // Unsigned distance!\n}\n\n// ollj's signed distance function using atan2\n// sdf_line4 is like to sdf_line3, but more explicit, and possibly with less memory use\nfloat sdf_line4(vec2 uv, vec2 vert_A, vec2 vert_B){\n    vec2 dvec_AB = vert_A - vert_B;\n    float angle = atan(dvec_AB.y, dvec_AB.x);  // Compute angle using atan2; it has branching, and it's slow.\n    vec2 some_vector = vec2(sin(angle), sin(angle - asin(1.)));\n    return -dot(uv, some_vector);  // Signed distance!\n    //return abs(dot(uv, some_vector));  // Unsigned distance!\n}\n\n// SDF for a line, Klems edition\nfloat sdf_line5(vec2 uv, vec2 vert_A, vec2 vert_B) {\n    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel!\n    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B\n    vec2 dvec_AB_rotated = dvec_AB.yx;  // Rotate by pi/2 radians, by \"hand\"\n    dvec_AB_rotated.y *= -1.;           // Rotate by pi/2 radians, by \"hand\"\n    float vector_projection_AP_ABr_snorm = dot(dvec_AP, normalize(dvec_AB_rotated));  // This is the signed-norm of the vector-projection of dvec_AP to dvec_AB_rotated\n    return vector_projection_AP_ABr_snorm;  // And such signed-norm ends up being the signed distance we're after!\n}\n\n// SDF for a line, found in a comment by valentingalea on https://www.shadertoy.com/view/XllGDs\n// So far, the most elegant version! Also the sexiest, as it leverages the power of\n// the exterior algebra =)\n// Also, 10 internet cookies to whoever can figure out how to make this work for line SEGMENTS! =D\nfloat sdf_line6(vec2 st, vec2 vert_a, vec2 vert_b){\n    vec2 dvec_ap = st - vert_a;      // Displacement vector from vert_a to our current pixel!\n    vec2 dvec_ab = vert_b - vert_a;  // Displacement vector from vert_a to vert_b\n\tvec2 direction = normalize(dvec_ab);  // We find a direction vector, which has unit norm by definition!\n    return crossnorm_product(dvec_ap, direction);  // Ah, the mighty cross-norm product!\n    //return crossnorm_product(dvec_ap, direction) / dot_product(dvec_ab, dvec_ab);  // I thought this would work, but it doesn't: AA is all messed up!\n}\n\n// ------------------------------------------------------------------------------------------------\n// Unsigned distance to a line for an arbitrary point `uv` in the plane!\n// Compact, unreadable version!\nfloat udf_line0(vec2 uv, vec2 vert_A, vec2 vert_B){\n    float slope = (vert_B.y - vert_A.y) / (vert_B.x - vert_A.y);\n    float standard_form = slope * uv.x - uv.y + vert_A.y - slope * vert_A.x;\n    float norm = sqrt(slope * slope + 1.);\n    return abs(standard_form / norm);  // This is the (unsigned) distance!\n}\n\n// There's an alternative way of computing the unsigned distance field for a line,\n// which is the one I see all the time on Shadertoy.\n// It uses the vector-projection of the position vector `uv` to the displacement vector from\n// vertA to vertB.\n// This function can be made into a SIGNED distance function, courtesy of ollj's comments.\nfloat udf_line1(vec2 uv, vec2 vert_A, vec2 vert_B){\n    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel/point!\n    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B\n    // The vector-projection of vector X to vector Y is a scalar multiple of vector Y.\n    vec2 vector_projection_AP_AB = dvec_AB * (dot(dvec_AP, dvec_AB) / dot(dvec_AB, dvec_AB));  // So, this is a scalar multiple of dvec_AB\n    return distance(uv, vector_projection_AP_AB);  // This is the (unsigned) distance!\n}\n\n// ------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // Normalize pixel coordinates!\n    vec2 mouse_uv = (2. * iMouse.xy - iResolution.xy) / iResolution.y;  // Normalize mouse coordinates!\n\n    // We've chosen to specify a line by 2 vertices in the line. Well, here they are, in all of their glory\n    vec2 line_vert_A = vec2(.0, .0);\n    vec2 line_vert_B = mouse_uv;  // vec2(.1, .1);\n\n    // Try any of these!\n    //float line = sdf_line0(uv, line_vert_A, line_vert_B);  // Using scalar arithmetic\n    //float line = sdf_line1(uv, line_vert_A, line_vert_B);  // Using scalar arithmetic\n    //float line = sdf_line5(uv, line_vert_A, line_vert_B);  // ollj's version using vector arithmetic!\n    //float line = sdf_line3(uv, line_vert_A, line_vert_B);  // ollj's version using atan2!\n    //float line = sdf_line4(uv, line_vert_A, line_vert_B);  // ollj's version using atan2!\n    //float line = sdf_line5(uv, line_vert_A, line_vert_B);  // Klems's version!\n    float line = sdf_line6(uv, line_vert_A, line_vert_B);  // valentingalea's version!\n    //float line = udf_line0(uv, line_vert_A, line_vert_B);  // Using scalar arithmetic\n    //float line = udf_line1(uv, line_vert_A, line_vert_B);  // Using vector arithmetic\n\n    // The distance field (whether signed or unsigned) for a subset S ends up storing just *too* much\n    // information about S. Often, all we want is to know which points are \"very close\" to S.\n    // (What \"very close\" means, numerically, ends up being an artistic choice for the programmer.)\n    // But the distance field of S has way more information than simply what's \"very close\" to S, and\n    // we must discard that information in a natural, pretty way. (Otherwise, we will not only color\n    // points that are \"very close\" to S, but also points that are \"not that close\" to S, and even\n    // points that are \"somewhat faraway but not too much\" from S.)\n    // So, we compose the signed/unsigned distance function with a smooth \"squashing\" function, which\n    // makes the transition from regions of positive distance to regions of zero distance less\n    // gradual and more abrupt, but still smooth.\n    // And there's another, equivalent way to justify this \"squashing\".\n    // The distance field (whether signed or unsigned) for a subset S ends up giving, in a precise\n    // sense, information about the boundary of S. But boundaries are always closed, nowhere dense\n    // sets (and conversely!).\n    // In particular, this means that, on the plane R2, boundaries always have measure zero.\n    // Recall that the boundary of S will be the subset of R2 where the distance function takes the\n    // value zero. So, if we were to simply color the boundary of S (ie. the points in R2 where the\n    // distance function evaluates to zero), then this boundary will be full of jaggies. (Even more\n    // precisely, it's going to be unclear what EXACTLY is the boundary of S, since floating-point\n    // arithmetic resembles open-set \"arithmetic\", meaning boundary sets cannot be effectively\n    // computed. This implies that, after doing lots of floating-point operations, there's no such\n    // thing as being EXACTLY zero. There's only a notion of being \"close\" to zero, ie. being in some\n    // open set around zero. Example: 0.1 + 0.2 - 0.3 is not zero when using floating-point\n    // arithmetic, but it's a number \"very close\" to zero.)\n    // And this is no-bueno for rendering. Well, it's not REALLY bad, but, without some extra\n    // processing, it makes for ugly boundaries. Namely, the boundaries will be full of jaggies, and\n    // we hate jaggies.\n    // So, a \"smooth-squash function\" simultaneously solves the problem of being \"too spread out\n    // and \"too localized\". It's a win-win (win).\n    // Finally, what is this \"smooth-squash function\" we've been talking about? There's uncountably-\n    // many choices for such a function, but GLSL has a nice built-in function that does the job:\n    // smoothstep().\n    float line_thickness = LINE_THICKNESS / iResolution.y;\n    line = smoothstep(.0, line_thickness, line);  // Try commenting this out, and see the full generality of the distance function!\n\n    fragColor.rgb = vec3(line);\n}\n","name":"Image","description":"","type":"image"}]}