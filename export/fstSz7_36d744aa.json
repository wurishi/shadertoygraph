{"ver":"0.1","info":{"id":"fstSz7","date":"1632863763","viewed":120,"name":"Goopy Lava Lamp","username":"zheck","description":"Lava lamp using smoothmin to make goopy lava with spheres","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","sphere","lava","lamp","smooth","min","smoothmin","subtraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Configurable parameters //\n#define NUM_SPHERE 20\n#define RNG_SEED 4321\n\n#define ANIMATION_SPEED 0.25\n#define BLEND_STRENGTH 0.3\n#define GLASS_HEIGHT 2.0\n#define MAX_RADIUS 0.15\n#define METAL_HEIGHT 0.55\n#define MIN_RADIUS 0.1\n#define SPREAD 0.2\n#define ZOOM 2.5\n\n#define GLASS_BASE_POSITION vec3(0.0, 0.3, 0.0)\n#define LAVA_COLOR vec3( 0.1, 0.6, 0.2)\n#define LAMP_ORIGIN vec3( 0.0, -0.5, 0.0)\n\n#define CAM_CONTROL true\n/////////////////////////////\n\n// Constants / Data //\nconst int maxIterations = 100;\nconst float epsilon = 0.0001;\nconst float PI = 3.1415;\nconst float searchLimit = 25.0;\nconst vec3 cameraTarget = vec3( 0.0, 0.0, 0.0);\nvec3 possibleColor = LAVA_COLOR;\nvec3 rayOrigin = vec3( 0.0, 0.0, ZOOM );\n\nconst int Lava   = 1;\nconst int Glass  = 2;\n\nstruct sphere\n{\n    vec3 position;\n    float radius;\n    float height;\n};\n\nsphere[NUM_SPHERE] spheres;\n//////////////////////\n\nfloat hash1( int x ) \n{\n    uint n = uint(x + RNG_SEED);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( int x ) \n{\n    uint n = uint(x + RNG_SEED);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 2376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat easeInOutQuint(float number)\n{\n    return number < 0.5 ? 16.0 * number * number * number * number * number : 1.0 - pow(-2.0 * number + 2.0, 5.0) / 2.0;\n}\n\nvec2 getMouseUV()\n{\n    if( !CAM_CONTROL )\n        return vec2(0.5);\n        \n    vec2 uv = iMouse.xy/iResolution.xy;\n    if(iMouse.xy == vec2(0.0))\n        uv += vec2(0.5);\n    return uv;\n\n}\n\nmat2 rotation2d(float angle)\n{\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nvec3 getRayDirection(vec2 uv)\n{\n    vec2 mouseUV = getMouseUV();\n    rayOrigin.yz *= rotation2d(mix(-PI/2.0, PI/2.0, mouseUV.y));\n    rayOrigin.xz *= rotation2d(mix(-PI, PI, mouseUV.x));\n    \n    vec3 cameraForward = normalize(cameraTarget - rayOrigin);\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));\n    \n    vec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + cameraForward);\n    return rayDirection;    \n}\n\nfloat smoothMin(float dstA, float dstB, float k)\n{\n    float h = max(k-abs(dstA-dstB), 0.0) / k;\n    return min(dstA, dstB) - h*h*h*k*1.0/6.0;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdfSphere(sphere s)\n{\n    return length(s.position) - s.radius;\n}\n\nfloat sdfCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat mapMetal(in vec3 position)\n{\n    vec3  basePosition = vec3(0.0, 0.3, 0.0) - LAMP_ORIGIN;\n    vec3  baseMetalTop = vec3(0,-METAL_HEIGHT,0);\n    vec3  baseMetalBottom = vec3(0.0);\n    float baseMetalTopRadius = 0.7;\n    float baseMetalBottomRadius = 0.45;\n    float baseMetal = sdfCone(position + basePosition, \n                                baseMetalBottom, \n                                baseMetalTop, \n                                baseMetalTopRadius, \n                                baseMetalBottomRadius);\n                                \n    float bottomCut   = sdfCone(position + basePosition - vec3(0.0, 0.1, 0.0), \n                                baseMetalBottom, \n                                baseMetalTop, \n                                baseMetalTopRadius * 0.9, \n                                baseMetalBottomRadius * 0.9);\n    baseMetal = opSmoothSubtraction(bottomCut, baseMetal, 0.1);\n    \n    vec3 capPosition = basePosition - vec3(0.0f,GLASS_HEIGHT,0.0f);\n    vec3 capMetalTop = vec3(0.0);\n    vec3 capMetalBottom = vec3(0.0,0.2,0.0);\n    float capMetalTopRadius = 0.25;\n    float capMetalBottomRadius = 0.2;\n    float capMetal = sdfCone(position + capPosition, \n                             capMetalTop, \n                             capMetalBottom, \n                             capMetalTopRadius, \n                             capMetalBottomRadius);\n                             \n                             \n    float capCutout = sdfCone(position + capPosition + vec3(0.0, 0.1, 0.0), \n                              capMetalTop, \n                              capMetalBottom, \n                              capMetalTopRadius * 0.75, \n                              capMetalBottomRadius * 0.75);\n                              \n    capMetal = opSmoothSubtraction(capCutout, capMetal, 0.1);\n    return min(baseMetal, capMetal);\n}\n\nfloat mapLavaAndMetal(in vec3 position)\n{\n    for(int i = 0; i < NUM_SPHERE; i++ )\n    {\n        float oneHash = hash1(i);\n        vec3 threeHash = hash3(i);\n        \n        float sphereRadius = clamp(oneHash, MIN_RADIUS, MAX_RADIUS);\n        vec3 sphereSpawn = vec3( (threeHash * 2.0) - 1.0 ) * SPREAD;\n        sphereSpawn.y = GLASS_BASE_POSITION.y + sphereRadius;\n        vec3 topPoint = vec3(0.0f, -GLASS_HEIGHT + sphereRadius + 0.25, 0.0f);\n        float timeline = easeInOutQuint((sin(iTime * oneHash * ANIMATION_SPEED) + 1.0f ) * 0.5f);\n        sphereSpawn = mix(topPoint, sphereSpawn, timeline);\n        \n        vec3 spherePos = position + sphereSpawn - LAMP_ORIGIN;\n        \n        spheres[i] = sphere(spherePos, sphereRadius, timeline);\n    }\n    float currentMin = sdfSphere(spheres[0]);\n    \n    for(int i = 1; i < NUM_SPHERE; i++ )\n    {\n        currentMin = smoothMin(currentMin, sdfSphere(spheres[i]), BLEND_STRENGTH * spheres[i].height + 0.15);\n    }\n\n    float metalMin = mapMetal(position);\n    possibleColor = LAVA_COLOR;\n    if( metalMin < currentMin )\n    {\n        currentMin = metalMin;\n        possibleColor = vec3(0.5);\n    }\n\n    return currentMin;\n}\n\nfloat mapGlass(in vec3 position)\n{\n    vec3 cylinderPosition = GLASS_BASE_POSITION - LAMP_ORIGIN;\n    return sdfCone(position + cylinderPosition, vec3(0,0,0), vec3(0,GLASS_HEIGHT,0), 0.7, 0.25);\n}\n\nvec3 calculateNormal( in vec3 position, in int material )\n{\n    vec2 e = vec2(epsilon, 0.0);\n    vec3 normal = vec3(0.0f);\n    switch(material)\n    {\n        case Lava:\n        {\n            normal = normalize(mapLavaAndMetal(position) - vec3(mapLavaAndMetal(position-e.xyy),\n                                    mapLavaAndMetal(position-e.yxy),\n                                    mapLavaAndMetal(position-e.yyx) ) );\n            break;\n        }\n        \n        case Glass:\n        {\n            normal = normalize(mapGlass(position) - vec3(mapGlass(position-e.xyy),\n                                    mapGlass(position-e.yxy),\n                                    mapGlass(position-e.yyx) ) );\n            break;\n        }\n    }\n    return normal;\n}\n\nfloat raycast( in vec3 rayOrigin, in vec3 rayDirection, in float searchLimit, in int material )\n{\n    float travelDistance = 0.0;\n    for( int i = 0; i < maxIterations; i++ )\n    {\n        vec3 position = rayOrigin + travelDistance * rayDirection;\n        float rayPointToObject = 0.0f;\n        switch(material)\n        {\n            case Lava:\n            {\n                rayPointToObject = mapLavaAndMetal(position);\n                break;\n            }\n            \n            case Glass:\n            {\n                rayPointToObject = mapGlass(position);\n                break;\n            }\n        }\n\n        if( rayPointToObject < epsilon )\n           break;   \n        \n        travelDistance += rayPointToObject;\n        if( travelDistance > searchLimit )\n           break;\n    }   \n    if( travelDistance > searchLimit )\n        travelDistance = 0.0;\n    return travelDistance;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2.0 * fragCoord - iResolution.xy ) / min( iResolution.x, iResolution.y);\n    vec3 rayDirection = getRayDirection(uv);\n    vec3 color = texture(iChannel0, rayDirection).xyz;\n    \n    float lavaNmetal  = raycast(rayOrigin, rayDirection, searchLimit, Lava);\n    float glass = raycast(rayOrigin, rayDirection, searchLimit, Glass);\n    \n    if( lavaNmetal > 0.0 )\n    {\n        vec3 lavaCollisionPoint = rayOrigin + lavaNmetal * rayDirection;\n        vec3 normal = calculateNormal( lavaCollisionPoint, Lava );\n        color = possibleColor * exp(dot(normal, rayDirection)) + vec3(0.25f, 0.25f, 0.25);\n        color *= mix(texture(iChannel0, reflect(rayDirection, normal)).xyz, color, 0.9);\n    }\n    if( glass > 0.0 )\n    {\n        vec3 glassCollisionPoint = rayOrigin + glass * rayDirection;\n        vec3 normal = calculateNormal( glassCollisionPoint, Glass );\n        vec3 glassColor = vec3((dot(normal, rayDirection) + 1.0 ) * .5 + 0.1);\n        if( lavaNmetal > 0.0 )\n        {\n            vec3 metalCollisionPoint = rayOrigin + lavaNmetal * rayDirection;\n            if( distance(rayOrigin, glassCollisionPoint) < distance(rayOrigin, metalCollisionPoint))\n                color += glassColor;\n        }\n        else\n            color += glassColor;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}