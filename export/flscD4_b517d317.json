{"ver":"0.1","info":{"id":"flscD4","date":"1649330440","viewed":66,"name":"Projet-Thibault","username":"thibault","description":"Projet portail  ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["projet"],"hasliked":0,"parentid":"NsBBWG","parentname":"textures 10/03"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n    bool isPortail;\n    bool side;//vrai -> portail de droite / faux -> portail de gauche\n};\n\nvec3 rotateOnY(in vec3 p, float a){\n    float ca = cos(a);\n    float sa = sin(a);\n    \n    return vec3(ca*p.x-sa*p.z, p.y, sa*p.x+ca*p.z);\n}\n\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdbEllipsoidV2( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+iTime);\n    float  s = sin(10.0*p.y+iTime);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 opCheapBend(in vec3 p )\n{\n    float k = 1.0; // or some other amount\n    float c = cos(k*p.x+iTime/2.);\n    float s = sin(k*p.x+iTime/2.);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nSurface scene(in vec3 p) {\n    Surface d = Surface(DIST_MAX, vec3(0.), false, false);\n    vec3 e = opTwist(p);\n    vec3 t = p *6.;\n    float d1 = sdSphere(p,0.5)+sin(t.x+iTime)*sin(t.y+iTime)*sin(t.z+iTime)/5.;\n    //float d2 = sdSphere(p+vec3(-1.5,0.,0.),1.);\n    //vec2 rot = rotateOnY(vec2(p.x, p.z), 0.9);\n   // vec3 p1 = rotateOnY(p, 0.3);  \n    \n    vec3 color = vec3(0.902, 0.902, 0.980);\n    \n    float ellipse = sdbEllipsoidV2(rotateOnY(p+vec3(-1.5, 0., 1.), -0.7/*sin((2.*PI)/2.)*/), vec3(0.5,1.,0.2));\n    float ellipse2 = sdbEllipsoidV2(rotateOnY(p+vec3(1.5, 0., -1.), cos(PI)), vec3(0.5,1.,0.2));\n\n    if(d1<d.t) {\n        d = Surface(d1,color, false, false);\n    }\n    if(ellipse<d.t){\n        d = Surface(ellipse, vec3(0.502, 0.502, 0.502), true, true);\n    }\n    \n    if(ellipse2<d.t){\n        d = Surface(ellipse2, vec3(1.000, 0.855, 0.725), true, false);\n    }\n    return d;\n    //return Surface(d1,vec3(1.,1.,3.));\n}\n\nSurface scene2(in vec3 p) {//scene du portail de droite\n    Surface d = Surface(DIST_MAX, vec3(0.), false, false);\n    float d1 = sdOctahedron(opTwist(p),0.6);\n    //float d2 = sdSphere(p+vec3(-1.5,0.,0.),1.);\n    //vec2 rot = rotateOnY(vec2(p.x, p.z), 0.9);\n   // vec3 p1 = rotateOnY(p, 0.3);  \n    vec3 color = vec3(0.118, 0.565, 1.000);\n    \n    return Surface(d1,color, false, false);\n    //return Surface(d1,vec3(1.,1.,3.));\n}\n\nSurface scene3(in vec3 p) {//scene du portail de gauche\n    Surface d = Surface(DIST_MAX, vec3(0.), false, false);\n   \n    float d1 = sdTorus(opCheapBend(vec3(cos(PI/4.)*p.x-sin(PI/4.)*p.y,sin(PI/4.)*p.x+cos(PI/4.)*p.y, p.z)), vec2(0.5, 0.1));\n    //float d2 = sdSphere(p+vec3(-1.5,0.,0.),1.);\n    //vec2 rot = rotateOnY(vec2(p.x, p.z), 0.9);\n   // vec3 p1 = rotateOnY(p, 0.3);  \n    vec3 color = vec3(0.498, 1.000, 0.000);\n    \n    return Surface(d1,color, false, false);\n    //return Surface(d1,vec3(1.,1.,3.));\n}\n\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c, s.isPortail, s.side);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0.), false, false);\n}\n\nSurface march2(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene2(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c, s.isPortail, s.side);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(1.), false, false);\n}\n\nSurface march3(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene3(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c, s.isPortail, s.side);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(1.), false, false);\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p, vec3 ro) {\n    // p is the current pixel coord, in [-1,1]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 20.;\n    float d = DP/2.;\n    //vec3 ro = vec3(d*cos(6.0*m.x),DP/5.0,d*sin(6.0*m.x) );\n    //vec3 ro = vec3(d,1.,sin(6.*m.x));\n    //vec3 ro = vec3(d*cos(6.0*m.x),(DP/2.0)*(m.y*4.),d*sin(6.0*m.x) );\n\n    //vec3 ro = vec3(0.,0.,-7.);\n\n    // target point\n    //vec3 ta = vec3(0.0,DP/10.0,0.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.8);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    vec3 ro = vec3(5.*cos(6. * iMouse.x/R.y),1.,5.*sin(6. * iMouse.x/R.y));\n    //vec3 ro = vec3(5.*cos(6.+iTime/2.),1.,5.*sin(6.+iTime/2.));\n    \n    Ray r = camRay(uv, ro);\n    Surface s = march(r);\n    vec3 c = s.c;\n    \n    if(s.isPortail == true){//test de la surface touchée\n        vec3 test = ro ;//+ vec3(cos(PI/2.),0.,cos(PI/4.));\n        if(s.side == true){//test du coté\n            r = camRay(uv, test);\n            s = march2(r);\n        }else{\n            r = camRay(uv, test);\n            s = march3(r);\n        }\n        //c = shade(s,r);\n        //s.c = vec3(0., 0., 1.);\n    }\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}