{"ver":"0.1","info":{"id":"fsdBDM","date":"1657030959","viewed":290,"name":"example: using dual quaternions","username":"jt","description":"An example using dual quaternions for rotation and translation.\nWORK IN PROGRESS! I've just started to learn about dual quaternions.\nNevertheless this example might be useful for other beginners.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["quaternion","rotation","translation","dual","quaternions","pose","dualquaternions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/fsdBDM\n// example: using dual quaternions (2022 by jt)\n\n// WARNING: please check before using this code - I've just started to learn about dual quaternions! \n\n// Variants:\n// https://www.shadertoy.com/view/fdtfWM example: using quaternions\n// https://www.shadertoy.com/view/7dcBDj example: using rodrigues vectors\n\n// tags: dual, quaternion, rotation, quaternions\n\n// NOTE: using vec4 here would be more concise - but when quaternions have their own type,\n//       the type-checking done by the glsl compiler can be used to detect errors\n//       caused by accidentally confusing vec4 with quaternions\n//       (e.g. accidentally multiplying a quaternion with an axis-angle, both stored in vec4).\n//       Also in mathematical notation usually the real part is written first, followed by the imaginary part:\n//       w + xi + yj + zk while the vec4 constructor expects x, y, z, w.\n//       When defining a quaternion type the mathematical order can be chosen.\n//       Last but not least using an own type for quaternions allows to overload functions, like norm\n//       (this becomes increasingly valuable when introducing more systems,\n//        like complex numbers, dual numbers, dual quaternions...)\n\n// https://en.wikipedia.org/wiki/Quaternion\nstruct quat\n{\n    float s;\n    vec3 v;\n};\n\n// NOTE: https://en.wikipedia.org/wiki/Quaternion#Quaternions_and_the_space_geometry\n// NOTE: The cross-product of the vector-parts of any quaternions p, q can be expressed by (pq - qp)/2\n//       (the scalar part of this expression always evaluates to zero)\n//       (the expression pq - qp is apparently called \"commutator\")\n// NOTE: The dot-product of all four components of quaternions p, q can be expressed by (pq* + qp*)/2\n//       (where * denotes the quaternion conjugate, i.e. negation of the vector-part)\n// NOTE: This is straight forward but cumbersome to check - use e.g. Maxima:\n//       % quaternion-multiplication (in component form)\n//       a_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*a_2 - b_1*b_2 - c_1*c_2 - d_1*d_2;\n//       b_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*b_2 + b_1*a_2 + c_1*d_2 - d_1*c_2;\n//       c_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*c_2 - b_1*d_2 + c_1*a_2 + d_1*b_2;\n//       d_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) :=a_1 * d_2 + b_1 * c_2 - c_1 * b_2 + d_1 * a_2;\n//       % evaluate squared norm |q|^2 = qq* = a^2 + b^2 + c^2 + d^2\n//       a_3(a,b,c,d,a,-b,-c,-d);b_3(a,b,c,d,a,-b,-c,-d);c_3(a,b,c,d,a,-b,-c,-d);d_3(a,b,c,d,a,-b,-c,-d);\n//       % evaluate (pq - qp)\n//       a_3(a,b,c,d,A,B,C,D)-a_3(A,B,C,D,a,b,c,d);b_3(a,b,c,d,A,B,C,D)-b_3(A,B,C,D,a,b,c,d);c_3(a,b,c,d,A,B,C,D)-c_3(A,B,C,D,a,b,c,d);d_3(a,b,c,d,A,B,C,D)-d_3(A,B,C,D,a,b,c,d);\n//       % evaluate (pq* + qp*)\n//       a_3(a,b,c,d,A,-B,-C,-D)+a_3(A,B,C,D,a,-b,-c,-d);b_3(a,b,c,d,A,-B,-C,-D)+b_3(A,B,C,D,a,-b,-c,-d);c_3(a,b,c,d,A,-B,-C,-D)+c_3(A,B,C,D,a,-b,-c,-d);d_3(a,b,c,d,A,-B,-C,-D)+d_3(A,B,C,D,a,-b,-c,-d);\n\nquat quat_identity()\n{\n    return quat(1.0, vec3(0.0, 0.0, 0.0));\n}\n\nquat conjugate(quat q)\n{\n    return quat(q.s,-q.v);\n}\n\nfloat norm_squared(quat q)\n{\n    return q.s * q.s + dot(q.v, q.v);\n}\n\nfloat norm(quat q)\n{\n    return sqrt(norm_squared(q));\n}\n\nquat mul(float s, quat q)\n{\n    return quat(s * q.s, s * q.v);\n}\n\nquat div(quat q, float s)\n{\n    return quat(q.s / s, q.v / s);\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat normalify(quat q) // NOTE: can't reuse function name normalize here\n{\n    return div(q, norm(q));\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\n//quat inverse(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat invert(quat q) // NOTE: can't reuse function name inverse here\n{\n    return div(conjugate(q), norm_squared(q));\n}\n\nquat neg(quat q)\n{\n    return quat(-q.s,-q.v);\n}\n\nquat add(quat a, quat b)\n{\n    return quat(a.s + b.s, a.v + b.v);\n}\n\nquat sub(quat a, quat b)\n{\n    return quat(a.s - b.s, a.v - b.v);\n}\n\nquat mul(quat a, quat b)\n{\n    return quat(a.s * b.s - dot(a.v, b.v), a.s * b.v + b.s * a.v + cross(a.v, b.v));\n}\n\nquat div(quat a, quat b)\n{\n    return mul(a, invert(b));\n}\n\nquat angle_axis(float angle, vec3 axis)\n{\n    return quat(cos(angle / 2.0), normalize(axis) * sin(angle / 2.0)); // NOTE: normalize can be omitted in case of unit-vector\n}\n\nquat axis_angle(vec3 axis, float angle)\n{\n    return quat(cos(angle / 2.0), normalize(axis) * sin(angle / 2.0)); // NOTE: normalize can be omitted in case of unit-vector\n}\n/*\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula#Vector_formulation\n    //return p + 2.0 * cross(q.v, cross(q.v, p)) + 2.0 * cross(q.v, q.s * p); // cross-product is distributive\n    //return p + 2.0 * cross(q.v, q.s * p) + 2.0 * cross(q.v, cross(q.v, p)); // vector addition is commutative\n    //return p + 2.0 * q.s * cross(q.v, p) + 2.0 * cross(q.v, cross(q.v, p)); // scalar can be factored-out\n    // translate variable names\n    vec3 x = p;\n    float a = q.s;\n    vec3 omega = q.v;\n    return x + 2.0 * a * cross(omega, x) + 2.0 * cross(omega, cross(omega, x)); // Euler Rodrigues' Formula\n}\n*/\n/*\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula#Statement\n    // translate variable names\n    vec3 v = p;\n    float c = q.s;\n    float s = length(q.v);\n    vec3 k = q.v / s;\n    //return v + 2.0 * cross(s*k, cross(s*k, v) + c * v); // distribute cross-product...\n    //return v + 2.0 * cross(s*k, cross(s*k, v)) + 2.0 * cross(s*k, c * v); // factor-out scalar...\n    //return v + 2.0 * s*s*cross(k, cross(k, v)) + 2.0 * s*c*cross(k, v); // rewrite perpendicular component...\n    // NOTE: apply identity cross(k, cross(k, v)) == dot(v, k) * k - v, the perpendicular component of v with respect to k\n    //return v + 2.0 * s*s*(dot(v, k) * k - v) + 2.0 * s*c*cross(k, v); // swap terms...\n    //return v + 2.0 * s*c*cross(k, v) + 2.0 * s*s*(dot(v, k) * k - v); // distribute product...\n    //return v - 2.0 * s*s*v + 2.0 * s*c*cross(k, v) + 2.0 * s*s*(dot(v, k) * k); // factor-out...\n    //return (1.0 - 2.0 * s*s)*v + 2.0 * s*c*cross(k, v) + 2.0 * s*s*(dot(v, k) * k); // apply trigonometric identities...\n    // NOTE: trigonometric identities\n    // (sin phi)^2 == (1 - cos(2 phi)) / 2\n    // (sin phi)(cos phi) == (sin(2 phi)) / 2\n    // NOTE: this changes the angle by factor two, which cancels-out the half in the angle-axis quaternion definition!\n    //       unfortunately this \"glue-code\" works only for half the angles (reset the timer when comparing both versions!)\n    float S = sin(2.0 * asin(s));\n    float C = cos(2.0 * acos(c));\n    //return (1.0 - (1.0 - C))*v + S*cross(k, v) + (1.0 - C)*(dot(v, k) * k); // cleanup...\n    return C*v + S*cross(k, v) + (1.0 - C)*(dot(v, k) * k); // Rodrigues' Rotation Formula\n}\n*/\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return mul(mul(q, quat(0.0, p)), invert(q)).v; // NOTE: in case of unit-quaternion reciprocal can be replaced by conjugate\n}\n/*\nvec3 rotate(vec3 p, quat q) // NOTE: using overload with swapped arguments for inverse rotation - is this practical or just confusing?\n{\n    return mul(mul(reciprocal(q), quat(0.0, p)), q).v; // NOTE: in case of unit-quaternion reciprocal can be replaced by conjugate\n    // return 2.0 * (cross(q.v, p) * q.s + dot(q.v, p) * q.v) + (q.s * q.s - dot(q.v, q.v)) * p; // NOTE: multiplying-out & simplifying gives this equation after several steps - a different way to write the Rodrigues' Formula\n}\n*/\nmat3 quat_to_mat3(quat q)\n{\n    return\n        mat3\n        (\n            rotate(q, vec3(1,0,0)),\n            rotate(q, vec3(0,1,0)),\n            rotate(q, vec3(0,0,1))\n        );\n}\n\nmat4 quat_to_mat4(quat q)\n{\n    return\n        mat4\n        (\n            vec4(rotate(q, vec3(1,0,0)), 0.0),\n            vec4(rotate(q, vec3(0,1,0)), 0.0),\n            vec4(rotate(q, vec3(0,0,1)), 0.0),\n            vec4(0.0,    0.0,    0.0,    1.0)\n        );\n}\n\n\nmat4 make_proj_mat(float focal_length)\n{\n    return\n        mat4\n        (\n            vec4(focal_length, 0.0, 0.0, 0.0),\n            vec4(0.0, focal_length, 0.0, 0.0),\n            vec4(0.0, 0.0, 0.0, 1.0),\n            vec4(0.0, 0.0, 0.0, 0.0)\n        );\n}\n\n// https://en.wikipedia.org/wiki/Dual_quaternion\n// see e.g. https://www.xbdev.net/misc_demos/demos/dual_quaternions_beyond/paper.pdf\nstruct dual_quat\n{\n    quat real;\n    quat imag;\n};\n\ndual_quat dual_quat_identity()\n{\n    return dual_quat(quat(1.0, vec3(0.0, 0.0, 0.0)), quat(0.0, vec3(0.0, 0.0, 0.0)));\n}\n\ndual_quat pose(quat rotation, vec3 translation)\n{\n    return dual_quat(rotation, div(mul(quat(0.0, translation), rotation), 2.0));\n}\n\nquat rotation(dual_quat d)\n{\n    return d.real;\n}\n\nvec3 translation(dual_quat d)\n{\n    return mul(2.0, mul(d.real, conjugate(d.imag))).v; // XXX can we omit scalar just like that? is it guaranteed to be 0? XXX\n}\n\ndual_quat add(dual_quat a, dual_quat b)\n{\n    return dual_quat(add(a.real, b.real), add(a.imag, b.imag));\n}\n\ndual_quat sub(dual_quat a, dual_quat b)\n{\n    return dual_quat(sub(a.real, b.real), sub(a.imag, b.imag));\n}\n\ndual_quat mul(dual_quat a, dual_quat b)\n{\n    return dual_quat(mul(a.real, b.real), add(mul(a.real, b.imag), mul(a.imag, b.real)));\n}\n\ndual_quat mul(float s, dual_quat d)\n{\n    return dual_quat(mul(s, d.real), mul(s, d.imag));\n}\n\ndual_quat div(dual_quat d, float s)\n{\n    return dual_quat(div(d.real, s), div(d.imag, s));\n}\n\n// NOTE: Only dual quaternions with non-zero real part (i.e. rotation) have inverses!\ndual_quat invert(dual_quat d) // NOTE: can't reuse function name inverse here\n{\n    // d = (a + e b)\n    // d^-1 = (a^-1 - e a^-1 b a^-1)\n    // proof:\n    // d d^-1 = (a + e b) (a^-1 - e a^-1 b a^-1)\n    //        = a a^-1 + e b a^-1 - e a a^-1 b a^-1 + e e b a^-1 b a^-1\n    //        =   1    + e        0                 + 0\n    //        = 1\n    quat i = invert(d.real);\n    return dual_quat(i, neg(mul(i, mul(d.imag, i))));\n}\n\n/*\ndual_quat div(dual_quat a, dual_quat b) XXX\n{\n    //float bb = norm_squared(b);\n    quat bb = dual_quat(mul(b.real, b.real), add(mul(b.real, b.imag), mul(b.imag, b.real)));;\n    return dual_quat(add(div(mul(a.real, b.real), bb), div(sub(mul(b.real, a.imag), mul(a.imag, b.real)), bb));\n}\n*/\n/*\ndual_quat conjugate(dual_quat d) XXX apparently three different types of conjugates are being used XXX\n{\n    return dual_quat(conjugate(d.real), conjugate(d.imag));\n}\n*/\n// see e.g. https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/other/dualQuaternion/index.htm\nvec3 transform(dual_quat d, vec3 p) // NOTE: expects d to be (rotation-)normalized (parameter-order mimics 4x4 matrix multiplication)\n{\n    return mul(mul(d, dual_quat(quat_identity(), quat(0.0, p))), dual_quat(conjugate(d.real),neg(conjugate(d.imag)))).imag.v;\n}\n\n// unfortunately the norm of a dual quaternion is a dual scalar so we need the dual scalar implementation, too\n\n// https://en.wikipedia.org/wiki/Dual_number\n// (perhaps also http://fs.unm.edu/DualNumbers.pdf ?)\nstruct dual\n{\n    float real;\n    float imag;\n};\n\ndual add(dual a, dual b)\n{\n    return dual(a.real + b.real, a.imag + b.imag);\n}\n\ndual sub(dual a, dual b)\n{\n    return dual(a.real - b.real, a.imag - b.imag);\n}\n\ndual mul(dual a, dual b)\n{\n    return dual(a.real * b.real, a.real * b.imag + a.imag * b.real);\n}\n\ndual div(dual a, dual b)\n{\n    return dual(a.real / b.real, (a.imag * b.real - a.real * b.imag) / (b.real * b.real));\n}\n\nfloat norm(dual d)\n{\n    // derivation: |d|^2 = d d* = (a + e b) (a - e b) = a^2 + eab - eba - e^2b^2 = a^2\n    // \"Note however, that this is not a 'norm' is the sense that |z| = 0 does not imply z = 0.\" https://math.stackexchange.com/questions/3254067/how-to-compute-norm-of-a-vector-of-dual-numbers\n    return sqrt(d.real * d.real);\n}\n\nfloat norm_squared(dual d)\n{\n    // derivation: |d|^2 = d d* = (a + e b) (a - e b) = a^2 + eab - eba - e^2b^2 = a^2\n    // \"Note however, that this is not a 'norm' is the sense that |z| = 0 does not imply z = 0.\" https://math.stackexchange.com/questions/3254067/how-to-compute-norm-of-a-vector-of-dual-numbers\n    return d.real * d.real;\n}\n\n// norm, according to https://team.inria.fr/imagine/files/2014/10/skinning_dual_quaternions.pdf\n// (alternative link: https://www.cs.utah.edu/~ladislav/kavan06dual/kavan06dual.html )\n// NOTE: dual quaternion (r + e t) units have unit rotation and no translation: |r| = 1 and t = 0 \ndual norm(dual_quat d) // XXX Is this a 'norm' in the usual sense? Or does it have the same problems as the dual norm? XXX\n{\n    // derivation: backwards from squared dual quaternion norm\n    // (|r| + e <r, t> / |r|)^2 = |r|^2 + e |r| <r, t> / |r| + e <r, t> / |r| * |r| + e^2 <r, t>^2 / |r|^2\n    //                          = |r|^2 + e <r, t> + e <r, t> + 0\n    //                          = |r|^2 + e 2 <r, t>\n    //                          NOTE: <r,t> = dot-product of quaternions r, t treated as vectors with four components\n    float q = norm(d.real);\n    return dual(q, (d.real.s * d.imag.s + dot(d.real.v, d.imag.v)) / q);\n}\n\n// reminder: squaring a dual number (a + e b)(a + e b) = (aa + 2eab + eebb) = (aa + 2eab)\ndual norm_squared(dual_quat d) // XXX Is this a 'norm' in the usual sense? Or does it have the same problems as the dual norm? XXX\n{\n    // derivation: |d|^2 = d d* = (r + e t) (r* + e t*) = r r* + e r t* + e t r* + e^2 t*^2\n    //                   = |r|^2 + e (r t* + t r*)\n    //                   = |r|^2 + e 2 <r,t>\n    //                   NOTE: (r t* + t r*)/2 = <r,t> = dot-product of quaternions r, t treated as vectors with four components\n    //float q = norm(d.real);\n    //return dual(q*q, 2.0 * q * (d.real.s * d.imag.s + dot(d.real.v, d.imag.v)) / q);\n    return dual(norm_squared(d.real), 2.0 * (d.real.s * d.imag.s + dot(d.real.v, d.imag.v)));\n}\n\n// Yet another division-function: divide dual quaternion (q + e Q) by dual scalar (s + e S):\n//     q + e Q   (q + e Q) * (s - e S)   q s + e Q s - e q S - e e Q S   q s + e Q s - e q S   q s + e (Q s - q S)   q s + e (Q s - q S)\n//     ------- = --------------------- = ----------------------------- = ------------------- = ------------------- = -------------------\n//     s + e S   (s + e S) * (s - e S)   s s + e S s - e s S - e e S S   s^2 + e S s - e S s   s^2 + e (s S - S s)           s^2\ndual_quat div(dual_quat dq, dual ds)\n{\n    //dual scale = dual(ds.real * ds.real, ds.real * ds.imag - ds.imag * ds.real); // dual part evaluates to 0\n    float scale = ds.real * ds.real;\n    return div(dual_quat(mul(ds.real, dq.real), sub(mul(ds.real, dq.imag), mul(ds.imag, dq.real))), scale);\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\ndual_quat normalify(dual_quat d) // NOTE: can't reuse function name normalize here\n{\n    // NOTE: <r,t> = dot-product of quaternions r, t treated as vectors with four components\n    // Division by norm |r + e t| = |r| + e <r, t> / |r| results in (using above definition of div):\n    //       r + e t          r |r| + e (t |r| - r <r, t> / |r|)\n    // -------------------- = ---------------------------------- =\n    // |r| + e <r, t> / |r|                  |r|^2\n    // which can be rewritten to (using R = r / |r|, T = t / |r| to improve readability)\n    // = r / |r| + e (t / |r| - r / |r| <r / |r|, t / |r|>) = R + e (T - R <R, T>)\n    // NOTE: Compare to just dividing by rotation-scale (below) this includes the extra term -R <R, T>\n    return div(d, norm(d)); // XXX TODO: VERIFY! XXX\n}\n\n// TODO: Check if above normalify is the correct way, compare to normalize_by_rotation below.\n\n// NOTE: The rotation quaternion must be unit while the translation may be not (zero translation is OK).\n//       So let's assume rotation and translation have been scaled by the same real scalar s:\n//       real = s*r, imag = s*t which we can determine from the rotational part: s = |real|\ndual_quat normalize_by_rotation(dual_quat d)\n{\n    // r / |r| + e t / |r|\n    float s = norm(d.real);\n    return dual_quat(div(d.real, s), div(d.imag, s));\n}\n\n// dual quaternion blending, according to https://team.inria.fr/imagine/files/2014/10/skinning_dual_quaternions.pdf\n// (alternative link: https://www.cs.utah.edu/~ladislav/kavan06dual/kavan06dual.html )\n// \"The angles of rotation in DLB and ScLERP always differ by less than 8.15 degrees [...]\n//  The amount of translation always differs by less than 15% [...]\n//  DLB is coordinate invariant, shortest path and 'almost' constant speed.\"\ndual_quat blend(dual_quat a, dual_quat b, float t)\n{\n    dual_quat combined = add(mul(1.0 - t, a), mul(t, b));\n    dual scale = norm(combined);\n    return div(combined, scale);\n}\n\n#define pi 3.1415926\n\nvec2 project(mat4 projection, vec3 v)\n{\n    vec4 w = projection * vec4(v, 1.0);\n    return vec2(w) / w.w;\n}\n\nquat yaw_pitch_roll(float Yaw, float Pitch, float Roll)\n{\n    return\n        mul\n        (\n            angle_axis(Pitch, vec3(1,0,0)),\n            mul\n            (\n                angle_axis(Yaw, vec3(0,1,0)),\n                angle_axis(Roll, vec3(0,0,1))\n            )\n        );\n}\n\nquat get_camera_rotation()\n{\n    float Pitch = 0.05 * 2.0 * pi * iTime;\n    float Yaw = 0.2 * 2.0 * pi * iTime;\n    float Roll = 0.3 * 2.0 * pi * iTime;\n\n    return yaw_pitch_roll(Yaw, Pitch, Roll);\n}\n\nvec3 get_camera_position()\n{\n    return vec3(0.5 * cos(0.3 * 2.0 * pi * iTime), 0.5 * sin(0.2 * 2.0 * pi * iTime), 1.0);\n}\n\nfloat draw_line(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - h * ba);\n}\n\nfloat draw_quad(vec2 A, vec2 B, vec2 C, vec2 D, vec2 p)\n{\n    return min(min(draw_line(A, B, p), draw_line(B, C, p)), min(draw_line(C, D, p), draw_line(D, A, p)));\n}\n/*\nfloat draw_diagonals(vec2 A, vec2 B, vec2 C, vec2 D, vec2 p)\n{\n    return min(draw_line(A, C, p), draw_line(B, D, p));\n}\n\nfloat spot(float s, vec2 q, vec2 p)\n{\n    vec2 a = vec2( s, s);\n    vec2 b = vec2(-s, s);\n    return draw_diagonals(q - a, q - b, q + a, q + b, p);\n}\n*/\nfloat draw_cube(mat4 projection, dual_quat camera_pose, vec3 cube_position, float cube_size, vec2 p)\n{\n    vec3 v000 = cube_position + vec3(-1,-1,-1) * cube_size;\n    vec3 v001 = cube_position + vec3(-1,-1,+1) * cube_size;\n    vec3 v010 = cube_position + vec3(-1,+1,-1) * cube_size;\n    vec3 v011 = cube_position + vec3(-1,+1,+1) * cube_size;\n    vec3 v100 = cube_position + vec3(+1,-1,-1) * cube_size;\n    vec3 v101 = cube_position + vec3(+1,-1,+1) * cube_size;\n    vec3 v110 = cube_position + vec3(+1,+1,-1) * cube_size;\n    vec3 v111 = cube_position + vec3(+1,+1,+1) * cube_size;\n\n    vec2 V000 = project(projection, transform(camera_pose, v000));\n    vec2 V001 = project(projection, transform(camera_pose, v001));\n    vec2 V010 = project(projection, transform(camera_pose, v010));\n    vec2 V011 = project(projection, transform(camera_pose, v011));\n    vec2 V100 = project(projection, transform(camera_pose, v100));\n    vec2 V101 = project(projection, transform(camera_pose, v101));\n    vec2 V110 = project(projection, transform(camera_pose, v110));\n    vec2 V111 = project(projection, transform(camera_pose, v111));\n    /*\n    // compare to transform by rotation & displacement\n    quat camera_rotation = rotation(camera_pose);\n    vec3 camera_translation = translation(camera_pose);\n    vec2 V000 = project(projection, rotate(v000, camera_rotation) + camera_translation);\n    vec2 V001 = project(projection, rotate(v001, camera_rotation) + camera_translation);\n    vec2 V010 = project(projection, rotate(v010, camera_rotation) + camera_translation);\n    vec2 V011 = project(projection, rotate(v011, camera_rotation) + camera_translation);\n    vec2 V100 = project(projection, rotate(v100, camera_rotation) + camera_translation);\n    vec2 V101 = project(projection, rotate(v101, camera_rotation) + camera_translation);\n    vec2 V110 = project(projection, rotate(v110, camera_rotation) + camera_translation);\n    vec2 V111 = project(projection, rotate(v111, camera_rotation) + camera_translation);\n    */\n    return\n        min\n        (\n            min\n            (\n                draw_quad(V000, V001, V011, V010, p),\n                draw_quad(V100, V101, V111, V110, p)\n            ),\n            min\n            (\n                min(draw_line(V000, V100, p), draw_line(V001, V101, p)),\n                min(draw_line(V011, V111, p), draw_line(V010, V110, p))\n            )\n        );\n    /*\n    return\n        min\n        (\n            min\n            (\n                min(spot(0.02, V000, p), spot(0.02, V001, p)),\n                min(spot(0.02, V010, p), spot(0.02, V011, p))\n            ),\n            min\n            (\n                min(spot(0.02, V100, p), spot(0.02, V101, p)),\n                min(spot(0.02, V110, p), spot(0.02, V111, p))\n            )\n        );\n        */\n}\n\n//#define BLEND // uncomment to test blending between camera poses\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 projection = make_proj_mat(1.0/*focal length*/);\n    //mat4 projection = make_proj_mat(1.0 + 0.5 * cos(iTime)/*focal length*/);\n    //o = projection * view * model * i\n\n    quat camera_rotation = get_camera_rotation();\n    vec3 camera_position = get_camera_position();\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float o = 1.0;\n#ifdef BLEND\n    // use dual quaternions to blend between camera pose p0 and p1 (and then to rotate points)\n    {\n        dual_quat p0 = pose(yaw_pitch_roll(0.0, 0.0, 0.0), vec3(1,0,2));\n        // NOTE: interpolation appears to break when |angle difference| > pi\n        dual_quat p1 = pose(yaw_pitch_roll(pi / 2.0, 0.0, 0.0), vec3(0,1,2));\n        //dual_quat p1 = pose(yaw_pitch_roll(+pi, 0.0, 0.0), vec3(0,1,2));\n        //dual_quat p1 = pose(yaw_pitch_roll(-pi, 0.0, 0.0), vec3(0,1,2));\n    \n        float t = 0.5 + 0.5 * cos(2.0 * pi * iTime * 0.2);\n        o = min(o, draw_cube(projection, blend(p0, p1, t), vec3(0,0,0)/*cube_position*/, 0.25/*cube_size*/, p));\n    }\n#else\n    // use dual quaternion only to rotate points\n    {\n        o = min(o, draw_cube(projection, pose(camera_rotation, camera_position), vec3(0,0,0)/*cube_position*/, 0.25/*cube_size*/, p));\n        //o = min(o, draw_cube(projection, mul(pose(quat_identity(), camera_position), pose(camera_rotation, vec3(0))), vec3(0,0,0)/*cube_position*/, 0.25/*cube_size*/, p));\n    }\n#endif\n    vec3 col = vec3(0.0);\n    //col = max(col, mix(vec3(1.0), vec3(0.0), smoothstep(0.00, 0.01, o)));\n    col = max(col, mix(vec3(1.0), vec3(0.0), smoothstep(0.00, 5./iResolution.y, o)));\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}