{"ver":"0.1","info":{"id":"4fjGDW","date":"1704228411","viewed":84,"name":"Hydrogen Wavefunction","username":"Borusse29","description":"a visualization of the wave function of a single electron in a hydrogen atom as a solution to the SchrÃ¶dinger's equation","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["physics","wavefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _n            6       // n > 0\n#define _l            3       // 0 <= l < n\n#define _m_l          1       // -l <= m_l <= l\n\n#define MODE          1       // 0: 2d slice rotating around z-axiz\n                              // 1: 3d Isosurface\n                              \n#define FUNCTION_MODE 1       // 0: wave function\n                              // 1: proability density function\n\n#define SCALE         200.0   // 1 unit = SCALE * a_0 (a_0 is Bohr radius)\n#define VALUE         1e9     // determens brightness (in MODE 0) and threshold (for isosurface in MODE 1)\n                              // (VALUE will be squared when displaying probability density)\n#define SHOW_GRADIENT 1\n\n// MODE 1 parameters\n#define SLICE         0       // slice geometry in half to see inside\n#define SURFACE_COLOR 0       // 0: distance to camera                      | in MODE 1, FUNCTION_MODE 0, the sign\n                              // 1: Lambertian reflectance (normal shading) | of the imaginary part will be shown\n                              // 2: (complex) phase of psi (FUNCTION_MODE 0 only)\n#define USE_CG        1       // apply color gradient to (aesthetical) surface color\n#define STEPS         500     // contiunity of surface\n#define MOUSE_CONTROL 1       // use mouse to rotate camera\n#define OSC_CAM_ANG   1       // 0: constant angle (CAMERA_ANGLE); \n                              // 1: oscillating angle\n#define CAMERA_ANGLE  0.3     // camera rotation (CAMERA_ANGLE in [-pi; pi])\n\n#define _a_0          5.2917721090e-11\n#define _e            2.7182818284\n#define _pi           3.1415926535\n\nvec3 gradient(float a)\n{\n    a = max(a, 0.);\n    return a * vec3(2.*a, 2.*a-1., 1.-a);\n}\n\nvec3 log_gradient(float a)\n{\n    return gradient(log(log(log(a+1.)+1.)+1.));\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 radiant_gradient(float a) // a in radiants!\n{\n    return vec3(.5) * cos(vec3(a)+2.*_pi*vec3(.0, .33, .67)) + vec3(.5);\n}\n\nint factorial(int n)\n{\n    int m = 1;\n    for (int i = 2; i <= n; i++) \n        m *= i;\n    return m;\n}\n\n// b >= 0 !\nint iipow(int a, int b)\n{\n    if (b == 0) return 1;\n    int n = a;\n    for (int i = 1; i < b; i++) {\n        n *= a;\n    }\n    return n;\n}\n\nfloat fipow(float a, int b)\n{\n    if (b == 0) return 1.;\n    float n = a;\n    for (int i = 1; i < abs(b); i++) {\n        n *= a;\n    }\n    if (b > 0)\n        return n;\n    return 1./n;\n}\n\nfloat generaized_bin_coefficient(float a, int k)\n{\n    if (k==0) return 1.;\n    float prod = a;\n    for (float b = a - 1.; b >= a - float(k-1); b--)\n        prod *= b;\n    return prod / float(factorial(k));\n}\n\nfloat complex_phase(vec2 z)\n{\n    return mod(atan(z.y/z.x) + _pi +_pi*float(z.x>0.), 2.*_pi);\n}\n\nvec3 cartesian_to_polar(vec3 p)\n{\n    return vec3(length(p), acos(p.z/length(p)), complex_phase(p.yx));\n}\n\nfloat L(int n, int l, float x)\n{\n    float sum = 0.;\n    for (int k = 0; k <= n-l-1; k++) {\n        sum += float(iipow(-1, k+1) * factorial(n+l) * factorial(n+l))\n               / float(factorial(n-1-l-k) * factorial(2*l+1+k) * factorial(k))\n               * pow(x, float(k));\n    }\n    return sum;\n}\n\nfloat Pml(int m, int l, float x)\n{\n    float sum = 0.;\n    for (int k = m; k <= l; k++) {\n        sum += float(factorial(k)) / float(factorial(k-m))\n               * fipow(x, k-m)\n               * generaized_bin_coefficient(float(l), k)\n               * generaized_bin_coefficient(float(l+k-1)/2., l);\n    }\n    return float(iipow(-1, m)\n           * iipow(2, l))\n           * pow(1.-x*x, float(m)/2.)\n           * sum;\n}\n\n// I'm not sure whether I handled negative m_l correctly\nfloat P(int m, int l, float x){\n    if (m < 0) return float(iipow(-1, -m))\n                      * float(factorial(l+m))\n                      / float(factorial(l-m))\n                      * Pml(-m, l, x);\n    return Pml(m, l, x);\n}\n\nvec2 psi(int n, int l, int m_l, float r, float theta, float phi)\n{\n    #if SLICE == 1 && MODE == 1\n    if (phi < _pi) return vec2(0.);\n    #endif\n    \n    float rho = 1.*r/(float(n)*_a_0); // where: Z = 1; Z: q/e of nucleus (number of protons)\n              \n    float R = - sqrt(float(factorial(n-l-1)) / (2.*float(n)*pow(float(factorial(n+l)), 3.)))\n              * pow(float(n), -float(l)-1.5) * pow(_a_0, -1.5)   //   pow(1./(float(n)*_a_0), float(l)+1.5) | ugly trick to stay within range of\n              * fipow(r/_a_0, l)                                 // fipow(r, l)                             | single percision floating point numbers\n              * L(n, l, 2.*rho)\n              * pow(_e, -rho);\n              \n    vec2 Y = float(iipow(-1, m_l))\n              * sqrt( float((2*l+1)*factorial(l-abs(m_l))) \n                      /(4.*_pi * float(factorial(l+abs(m_l)))))\n              * P(m_l, l, cos(theta))\n              * vec2(cos(float(m_l)*phi), sin(float(m_l)*phi));\n\n    return R*Y;\n}\n\n\n#define EPSILON 0.002\n// TODO wow, this is ugly...\nvec3 surface_normal(int n, int l, int m_l, vec3 p, float s)\n{\n    vec3 dx = vec3(EPSILON,0.,0.);\n    vec3 dy = vec3(0.,EPSILON,0.);\n    vec3 dz = vec3(0.,0.,EPSILON);\n    \n    vec3 pxp = cartesian_to_polar(p + dx);\n    vec3 pyp = cartesian_to_polar(p + dy);\n    vec3 pzp = cartesian_to_polar(p + dz);\n    vec3 pxm = cartesian_to_polar(p - dx);\n    vec3 pym = cartesian_to_polar(p - dy);\n    vec3 pzm = cartesian_to_polar(p - dz);\n    \n    vec2 axpi = psi(n, l, m_l, s*pxp.r, pxp.y, pxp.z);\n    vec2 axmi = psi(n, l, m_l, s*pxm.r, pxm.y, pxm.z);\n    vec2 aypi = psi(n, l, m_l, s*pyp.r, pyp.y, pyp.z);\n    vec2 aymi = psi(n, l, m_l, s*pym.r, pym.y, pym.z);\n    vec2 azpi = psi(n, l, m_l, s*pzp.r, pzp.y, pzp.z);\n    vec2 azmi = psi(n, l, m_l, s*pzm.r, pzm.y, pzm.z);\n    \n#if FUNCTION_MODE == 0\n     return -normalize(vec3(axpi.x - axmi.x*axmi.x,\n                            aypi.x - aymi.x*aymi.x,\n                            azpi.x - azmi.x*azmi.x));\n#else\n    return -normalize(vec3(axpi.x*axpi.x + axpi.y*axpi.y - axmi.x*axmi.x - axmi.y*axmi.y,\n                           aypi.x*aypi.x + aypi.y*aypi.y - aymi.x*aymi.x - aymi.y*aymi.y,\n                           azpi.x*azpi.x + azpi.y*azpi.y - azmi.x*azmi.x - azmi.y*azmi.y));\n#endif\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv0 = fragCoord/iResolution.x;\n    vec2 uv = 2.*uv0 - vec2(1., iResolution.y/iResolution.x);\n    fragColor = vec4(0.); \n\n#if SHOW_GRADIENT == 1 && (MODE == 0 || (FUNCTION_MODE == 0 && SURFACE_COLOR == 2) || (FUNCTION_MODE == 1 && SLICE == 1))\n    \n    #if FUNCTION_MODE == 1 && (MODE == 0 || SLICE == 1)\n    if (uv0.x < .25 && uv0.y < .02) {\n        fragColor = vec4(log_gradient(200.*uv0.x), 1.);\n        return;\n    }\n    #else \n    if (uv0.x < .1 && uv0.y < .1) {\n        fragColor = vec4(radiant_gradient(complex_phase(uv0-vec2(.05))), 1.);\n        return;\n    }\n    #endif\n\n#endif\n\n#if MODE == 0 //0\n    \n    float r = SCALE*_a_0*length(uv);\n    float theta = complex_phase(uv.yx);\n    vec2 psi = psi(_n, _l, _m_l, r, theta, iTime-_pi*float(uv.x<0.)); \n    \n#if FUNCTION_MODE == 0\n    vec3 col = radiant_gradient(complex_phase(psi)) * min(abs(psi.x)/VALUE*.5, 1.);\n#elif FUNCTION_MODE == 1\n    vec3 col = log_gradient((psi.x*psi.x+psi.y*psi.y) / (VALUE*VALUE));\n#endif\n\n    fragColor = vec4(col, 1.);\n    return;\n    \n#else //0\n\n#define STEPSIZE 10./float(STEPS)  //0.025\n\n#if MOUSE_CONTROL == 0\n    float t = iTime+.5*_pi;\n    #if OSC_CAM_ANG == 0\n    float t2 = CAMERA_ANGLE;\n    #else\n    float t2 = .33*(t-.5*_pi);\n    #endif\n#else\n    float t = 2.*_pi*iMouse.x/iResolution.x;\n    float t2 = -_pi*iMouse.y/iResolution.y+_pi/2.;\n    if (t2 == _pi/2.) t2 = CAMERA_ANGLE;\n#endif\n    vec3 ro = vec3(-cos(t)*abs(cos(t2)), -sin(t)*abs(cos(t2)), sin(t2));\n    float d = 0.;\n\n    mat3 cm = mat3(  cos(-t2)*cos(t),  cos(-t2)*sin(t), sin(-t2) ,  // cm = mat3( cos(t),  sin(t),  0.,  * mat3( cos(ay),  0.,  sin(ay),\n                    -sin(t),          cos(t),         0.      ,  //           -sin(t),  cos(t),  0.,               0.,  1.,  0.     ,   \n                    -sin(-t2)*cos(t), -sin(-t2)*sin(t), cos(-t2) ); //            0.,      0.,      1.)         -sin(ay),  0.,  cos(ay))\n    vec3 rd = cm * normalize(vec3(1., uv)); \n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 polar = cartesian_to_polar(ro);\n        vec2 psi = psi(_n, _l, _m_l, SCALE*_a_0*polar.x, polar.y, polar.z);\n\n#if FUNCTION_MODE == 0 // 1\n\n        if (abs(psi.x) > VALUE) {\n    #if SURFACE_COLOR == 2\n            fragColor = vec4(radiant_gradient(complex_phase(psi)), 1.);\n    #else\n            float value = .27*sign(psi.y)+.55;\n    \n        #if USE_CG == 1\n            fragColor = vec4(gradient(.8*value+.2), 1.);\n        #else\n            fragColor = vec4(vec3(value), 1.);\n        #endif\n\n        #if SURFACE_COLOR == 0\n            fragColor *= .004*SCALE*log(1.5-.75*d)+1.;\n        #else\n            vec3 normal = surface_normal(_n, _l, _m_l, ro, SCALE*_a_0);\n            fragColor *= .5*dot(normal, normalize(vec3(1.,-1.,2.)))+.5;\n        #endif\n    #endif\n\n#elif FUNCTION_MODE == 1 //1\n        float p = psi.x*psi.x+psi.y*psi.y;\n        \n        if (p > VALUE*VALUE) {\n    \n    #if SLICE == 1\n        fragColor = vec4(log_gradient(p/(VALUE*VALUE)), 1.);\n    #else\n        #if SURFACE_COLOR == 0\n            float value = log(1.45-.75*d)+1.;\n        #else\n            vec3 normal = surface_normal(_n, _l, _m_l, ro, SCALE*_a_0);\n            float value = .3*dot(normal, normalize(vec3(1.,-1.,2.)))+.55;\n        #endif\n    \n        #if USE_CG == 1\n            fragColor = vec4(gradient(value), 1.);\n        #else\n            fragColor = vec4(vec3(value), 1.);\n        #endif\n    #endif\n    \n#endif //1\n            return;\n        }\n        \n        ro += STEPSIZE * max(polar.r, .05) * rd; // stepsize multiplied by distance to origin to allow for fewer steps\n        d += STEPSIZE * max(polar.r, .05);\n        \n        // performance\n        if (d > 1.4) {\n            return;\n        }\n    }\n    \n#endif //0\n}","name":"Image","description":"","type":"image"}]}