{"ver":"0.1","info":{"id":"ldcyRn","date":"1517718215","viewed":1708,"name":"SDF Raymarching Experiment","username":"EvilSpirit","description":"This is my first experiment with signed distance field rendering with raymarching algorithm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 xyz;\n\nfloat Sphere(vec3 pos, float r) {\n    return length(xyz - pos) - r;\n} \n\nfloat Union(float a, float b) {\n\treturn min(a, b);\n}\n\nfloat Difference(float a, float b) {\n\treturn max(a, -b);\n}\n\nfloat Box(vec3 pos, vec3 b) {\n  vec3 d = abs(xyz) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat Torus( vec3 pos, vec2 t ) {\n  vec2 q = vec2(length(xyz.xy - pos.xy) - t.x, xyz.z - pos.z);\n  return length(q) - t.y;\n}\n\nfloat Sin() {\n\treturn length(vec2(xyz.x, 10.0 * sin(xyz.x)));\n}\n\nfloat body() {  \n    float r = Difference(\n                    Union(\n                        Sphere(vec3(20.0, -20.0, 0.0), 40.0),\n                        Sphere(vec3(100.0, -40.0, 0.0), 60.0)\n                    ),\n                    Box(vec3(-20.0, -40.0, 0.0), vec3(50.0, 21.0, 30.0))\n                );\n    \tr = Union(r, Torus(vec3(-20.0, -40.0, 0.0), vec2(50.0, 10.0)));\n        r = Union(r, xyz.y + 150.0);\n\t\treturn r;\n}\n\nfloat body(vec3 pos) {\n\txyz = pos;\n    return body();\n}\n\nconst float EPSILON = 0.01;\nvec3 EstimateNormal(vec3 p) {\n    return normalize(vec3(\n        body(vec3(p.x + EPSILON, p.y, p.z)) - body(vec3(p.x - EPSILON, p.y, p.z)),\n        body(vec3(p.x, p.y + EPSILON, p.z)) - body(vec3(p.x, p.y - EPSILON, p.z)),\n        body(vec3(p.x, p.y, p.z  + EPSILON)) - body(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nconst int STEPS = 60;\nconst float TOL = 0.001;\nvec3 raymarch(vec3 pos, vec3 dir) {\n    for(int i = 0; i < STEPS; i++) {\n        xyz = pos;\n    \tfloat d = body();\n        if(d < TOL) return pos;\n        pos += dir * d;\n    }\n    return pos;\n}\nvec3 u, v, n;\nvec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\nvec3 lightDir1 = normalize(vec3(-1.0, 1.0, 1.0));\n\nvec4 pixel(vec2 frag) {\n    vec3 ray = normalize(vec3((frag / iResolution.x - 0.5) * 2.0, 1.0));\n    xyz = vec3((frag - iResolution.xy / 2.0) * 0.1, -200.0);\n    vec3 start = u * xyz.x + v * xyz.y + n * xyz.z;\n    ray = u * ray.x + v * ray.y + n * ray.z;\n    vec3 trace = raymarch(start, ray);\n    vec3 normal = EstimateNormal(trace);\n    \n    vec3 light = max(dot(normal, lightDir), 0.0) * vec3(1.0, 0.7, 0.7) * 0.5;\n    vec3 shadow = raymarch(trace + lightDir * 600.0, -lightDir);\n    if(length(shadow - trace) > 0.01) {\n    \tlight = vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 light1 = max(dot(normal, lightDir1), 0.0) * vec3(0.7, 0.7, 1.0) * 0.5;\n    vec3 shadow1 = raymarch(trace + lightDir1 * 600.0, -lightDir1);\n    if(length(shadow1 - trace) > 0.01) {\n    \tlight1 = vec3(0.0, 0.0, 0.0);\n    }\n    \n    //vec3 col = 1.0 - vec3(length(trace - start)) / 300.0;\n    \n    if(length(trace - start) > 600.0) {\n    \treturn vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        vec3 col = vec3((light + light1) * 0.8 + 0.2);\n    \treturn vec4(col,1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime;\n    u = vec3(cos(angle), 0.0, -sin(angle));\n    v = vec3(0.0, 1.0, 0.0);\n    n = vec3(sin(angle), 0.0, cos(angle));\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    float count = 0.0;\n    const int aa = 1;\n    for(int i = -aa; i <= aa; i++) {\n\t    for(int j = -aa; j <= aa; j++) {\n            //if(i !=0 && j != 0) continue;\n    \t\tresult += pixel(fragCoord + vec2(i, j) / float(aa) / 3.0);\n            count += 1.0;\n        }\n    }\n    fragColor = result / count;\n}","name":"Image","description":"","type":"image"}]}