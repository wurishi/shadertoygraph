{"ver":"0.1","info":{"id":"MlB3WV","date":"1432430911","viewed":407,"name":"Worley Fractal bump+mouse","username":"104","description":"Bump-mapping based on a worley fractal noise pattern. Use mouse to move light around. See also https://www.shadertoy.com/view/MtSGWK for a similar experiment using triangles","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","mouse","texture","worley","bump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\nMaking a worley fractal is sorta weak, because each iteration generates entirely new\ncells, unrelated to the \"parent\" cells. So you end up with what looks like a bunch of\nlayers overlayed, instead of a clean tessellation.\n\nBut that effect might just be what you're looking for. It has a soft, crumpled look.\n\nCompare this to a similar fractal noise pattern based on just tessellating triangles:\nhttps://www.shadertoy.com/view/MtSGWK\n\nThe triangle version looks much \"sharper\" and harder, because the edges ar retained\nfor each iteration. So it looks like a single surface, tessellated.\n\nThis worley version looks more \"blurred\", because edges are re-built each iteration.\n\n*/\n\n// -------------------------------------------------------\n// parameters...\n\n\n// 0 = no coloring; just see bump effect\n// 1 = stylized by distance\n// 2 = reveal raw distance (typical worley)\n#define COLOR_MODE 1\n\n\nconst int iterationCount = 10;\n\n// normally this should be 0.5 to cut cells in half each iteration.\n// small amounts are cool too though like 0.1.\n// greater than 1 doesn't make much sense considering the algo, and <0 is just nonsense.\nconst float iterationSizeFactor = .5;\n\nconst float iterationNormalInfluenceFactor = 0.79;\n\nconst float iterationColorInfluenceFactor = 0.68;\n\n\n\n\n\n// -------------------------------------------------------\n// utilities\n// c64 palette because why not.\nvec3 color0 = vec3(0,0,0);// black\nvec3 color1 = vec3(1,1,1);// white\nvec3 color2 = vec3(0.41,0.22,0.17);// red\nvec3 color3 = vec3(0.44,0.64,0.70);// cyan\nvec3 color4 = vec3(0.44,0.24,0.53);// violet\nvec3 color5 = vec3(0.35,0.55,0.26);// green\nvec3 color6 = vec3(0.21,0.16,0.47);// blue\nvec3 color7 = vec3(0.72,0.78,0.44);// yellow\nvec3 color8 = vec3(0.44,0.31,0.15);// orange\nvec3 color9 = vec3(0.26,0.22,0);// brown\nvec3 colorA = vec3(0.60,0.40,0.35);// light red\nvec3 colorB = vec3(0.27,0.27,0.27);// grey1\nvec3 colorC = vec3(0.42,0.42,0.42);// grey2\nvec3 colorD = vec3(0.60,0.82,0.52);// light green\nvec3 colorE = vec3(0.42,0.37,0.71);// light blue\nvec3 colorF = vec3(0.58,0.58,0.58);// grey3\nvec3 getPalette(int i)\n{\n    if(i == 0) return color6;\n    if(i == 1) return color3;\n    if(i == 2) return color5;\n    if(i == 3) return color9;\n    if(i == 4) return color7;\n    return color8;\n}\n\n\n\nfloat nsin(float a)\n{\n    return (sin(a)+1.)/2.;\n}\nfloat rand(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 rand(vec2 n)\n{\n \treturn vec2(rand(n.x*23.62-300.0+n.y*34.35),rand(n.x*45.13+256.0+n.y*38.89)); \n}\n\n// returns (dx, dy, distance)\nvec3 worley(vec2 n,float s)\n{\n    vec3 ret = vec3(s * 10.);\n    // look in 9 cells (n, plus 8 surrounding)\n    for(int x = -1;x<2;x++)\n    {\n        for(int y = -1;y<2;y++)\n        {\n            vec2 xy = vec2(x,y);// xy can be thought of as both # of cells distance to n, and \n            vec2 cellIndex = floor(n/s) + xy;\n            vec2 worleyPoint = rand(cellIndex);// random point in this cell (0-1)\n            worleyPoint += xy - fract(n/s);// turn it into distance to n. ;\n            float d = length(worleyPoint) * s;\n            if(d < ret.z)\n                ret = vec3(worleyPoint, d);\n        }\n    }\n    return ret;\n}\n\n\nvec4 applyLighting(vec4 inpColor, vec2 uv, vec3 normal, vec3 LightPos, vec4 LightColor, vec4 AmbientColor)\n{\n    if(distance(uv.xy, LightPos.xy) < 0.01) return vec4(1.,0.,0.,1.);\n    vec3 LightDir = vec3(LightPos.xy - uv, LightPos.z);\n    float D = length(LightDir);// distance for attenuation\n    vec3 N = normalize(normal);\n    vec3 L = normalize(LightDir);\n    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);\n    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;\n    vec3 Intensity = Ambient + Diffuse;\n    vec3 FinalColor = inpColor.rgb * Intensity;\n    return vec4(FinalColor, inpColor.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scrollOffset = vec2(iTime * iResolution.x / 17., 0.0);\n    vec2 uv = fragCoord.xy + scrollOffset;\n    \n    vec2 lightPosXY = vec2(nsin(iTime * 1.66), nsin(iTime * 1.99));\n    lightPosXY = (lightPosXY * 0.75) + 0.125;// not so big movement\n    lightPosXY *= iResolution.xy;\n    lightPosXY += scrollOffset;\n    if(iMouse.z > 0.)\n\t    lightPosXY = iMouse.xy + scrollOffset;\n    \n    fragColor = vec4(vec3(0.5), 1.0);// background\n\n    // compute the normal for this fragment by subdividing.\n    float wsize = iResolution.x;\n    vec2 normal = vec2(0.);\n    float influenceFactor = 1.0;\n    \n    float colorMix = 1.0;\n    \n    for(int i = 0; i < iterationCount; ++ i)\n    {\n        vec3 w = worley(uv, wsize);\n\t\tnormal.xy += influenceFactor * w.xy;\n        wsize *= iterationSizeFactor;\n        influenceFactor *= iterationNormalInfluenceFactor;\n\n        float tintAmt = w.z / wsize;\n        \n        // i don't really understand why this looks so much better at low size factors.\n        if(iterationSizeFactor < 0.5)\n\t        tintAmt = tintAmt * iterationSizeFactor;\n        \n#if COLOR_MODE == 1\n        fragColor = vec4(mix(fragColor.rgb, getPalette(i), tintAmt * colorMix), 1.0);\n#endif\n#if COLOR_MODE == 2\n        fragColor = vec4(vec3(tintAmt), 1.0);\n#endif\n        colorMix *= iterationColorInfluenceFactor;\n    }\n    \n    // lighting\n#if COLOR_MODE != 2\n    vec3 lightPos = vec3(lightPosXY, iResolution.x / 2.);\n    vec4 lightColor = vec4(0.95,0.9,0.9,1.);\n    vec4 ambientColor = vec4(0.5,0.5,0.9,1.);\n\tfragColor = applyLighting(fragColor, uv, vec3(normal, 2.5), lightPos, lightColor, ambientColor);\n    \n    // show light position.\n    if(distance(uv, lightPosXY) < iResolution.x / 75.)\n        fragColor = vec4(1.0,1.0,0.,1.0);\n#endif\n}\n\n","name":"","description":"","type":"image"}]}