{"ver":"0.1","info":{"id":"csjSWh","date":"1670234077","viewed":109,"name":"First try perlin noise","username":"RJVB09","description":"My \"still not so great\" but working perlin noise. Implemented without any optimization.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//RNG is not mine btw\nvec3 random3(vec3 c) \n{\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nvec3 smoothStep(vec3 x)\n{\n    return 6.0 * pow(x,vec3(5.0)) - 15.0 * pow(x,vec3(4.0)) + 10.0 * pow(x,vec3(3.0));\n}\n\nfloat lerp3d(float o, float x, float y, float z, float xy, float xz, float yz, float xyz, vec3 target)\n{\n    target = smoothStep(target);\n    return mix(mix(mix(o,z,target.z),mix(x,xz,target.z),target.x),mix(mix(y,yz,target.z),mix(xy,xyz,target.z),target.x),target.y);\n}\n\nfloat perlin(vec3 pos)\n{\n    vec3 oPos = mod(pos,vec3(1.0));\n    vec3 xPos = oPos - vec3(1.0,0.0,0.0);\n    vec3 yPos = oPos - vec3(0.0,1.0,0.0);\n    vec3 zPos = oPos - vec3(0.0,0.0,1.0);\n    \n    vec3 xyPos = oPos - vec3(1.0,1.0,0.0);\n    vec3 xzPos = oPos - vec3(1.0,0.0,1.0);\n    vec3 yzPos = oPos - vec3(0.0,1.0,1.0);\n    \n    vec3 xyzPos = oPos - vec3(1.0,1.0,1.0);\n    \n    \n    vec3 oRandom = normalize(random3(floor(pos) + vec3(0.0,0.0,0.0)));\n    vec3 xRandom = normalize(random3(floor(pos) + vec3(1.0,0.0,0.0)));\n    vec3 yRandom = normalize(random3(floor(pos) + vec3(0.0,1.0,0.0)));\n    vec3 zRandom = normalize(random3(floor(pos) + vec3(0.0,0.0,1.0)));\n    \n    vec3 xyRandom = normalize(random3(floor(pos) + vec3(1.0,1.0,0.0)));\n    vec3 xzRandom = normalize(random3(floor(pos) + vec3(1.0,0.0,1.0)));\n    vec3 yzRandom = normalize(random3(floor(pos) + vec3(0.0,1.0,1.0)));\n    \n    vec3 xyzRandom = normalize(random3(floor(pos) + vec3(1.0,1.0,1.0)));\n    \n    \n    float outputValue = lerp3d(dot(oPos,oRandom),dot(xPos,xRandom),dot(yPos,yRandom),dot(zPos,zRandom),dot(xyPos,xyRandom),dot(xzPos,xzRandom),dot(yzPos,yzRandom),dot(xyzPos,xyzRandom),oPos);\n    \n    return outputValue;\n}\n\nfloat fractalNoise(vec3 pos, float freq, float oct, float per, float lac)\n{\n    float noise = 0.0;\n    float currentFreq = 1.0;\n    float currentAmp = 1.0;\n    float totalAmp = 1.0;\n    for (float i = 0.; i < oct; i += 1.)\n    {\n        noise += currentAmp * perlin(pos*freq*currentFreq);\n        currentFreq *= lac;\n        currentAmp *= per;\n        totalAmp += currentAmp;\n    }\n\n    return noise/totalAmp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float frequency = 0.1;\n    int octaves = 10;\n    float persistence = 0.5;\n    float lacunarity = 2.0;\n    \n    float noise = fractalNoise(vec3(fragCoord.x + iTime * 10.0,fragCoord.y + iTime * 10.0,iTime * 10.0),frequency,float(octaves),persistence,lacunarity);\n    \n    \n    // Time varying pixel color\n    vec3 col = noise + vec3(1.0)/2.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}