{"ver":"0.1","info":{"id":"NtVBD3","date":"1665386517","viewed":100,"name":"Floaties - Learning","username":"dgobera","description":"A test about having some shapes floating around.\nCan’t figure out yet why it breaks after number of particles exceeds 399.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 particleData(int pIndex, int pDataOffset) {\n\n    // convert the particle index into the xy coordinates in the input texture \n    // where the data for that particle is stored\n    float fragIndex = float(pIndex + pDataOffset);\n    float fragsPerRow = iChannelResolution[0].x;\n    float rowIndex = floor(fragIndex / fragsPerRow);\n    float colIndex = mod(fragIndex, fragsPerRow);\n\n    // read the corresponding fragment from the input buffer\n    // each contains the x,y coordinates for each particle\n    vec4 pData = texelFetch(iChannel0, ivec2(colIndex, rowIndex), 0);\n    \n    return pData;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized 0-1 coordinates, but adjust for aspect ratio, so one axis may go beyond 1\n    vec2 uv = fragCoord/iResolution.y;\n    float xScale = iResolution.x / iResolution.y;\n\n    // constants for colors and sizes\n    const vec3 pColorHSB = vec3(194.0/360.0, 0.64, 0.99);\n    const vec3 bgAColorHSB = vec3(202.0/360.0, 0.85, 0.55);\n    const vec3 bgBColorHSB = vec3(202.0/360.0, 0.85, 0.73);\n    \n    vec3 pColor = hsb2rgb(pColorHSB);\n    const float particleAlpha = 0.7;\n    const float particleRadius = 0.02;\n    float aaBlur = 1.5 / iResolution.y;\n\n    // get metadata from input buffer, first fragment\n    vec4 metadata = texelFetch(iChannel0, ivec2(0, 0), 0);\n    int particleCount = int(metadata[0]);\n    int pDataOffset = int(metadata[1]);\n\n    // gradient background\n    vec3 bgColA = hsb2rgb(bgAColorHSB);\n    vec3 bgColB = hsb2rgb(bgBColorHSB);\n    vec3 bgColor = mix(bgColA, bgColB, uv.y);\n    \n    vec3 col = bgColor;\n\n    // draw each particle\n    for (int i = 0; i < particleCount; i++) {\n        // read the particle data from the input buffer\n        vec4 pData = particleData(i, pDataOffset);\n        vec2 center = pData.xy;\n        center.x *= xScale;\n        \n        // oscillating radius\n        float speedFactor = pData[2];\n        float radius = particleRadius * (1.0 + (sin(iTime * speedFactor) * 0.3));\n    \n        float circleDist = 0.0;\n        float circleThres = radius;\n    \n        // normal way to draw a circle, measuring distance to center\n        circleDist = distance(center, uv);\n        \n\n        // faster circle approximation using dot product\n        // https://thebookofshaders.com/07/\n        // not sure yet why * 4, but the radius is not equivalent\n        //vec2 circleDistVec = uv - center;\n        //circleDist = dot(circleDistVec, circleDistVec) * 4.0;\n        //circleThres = radius * 2.0;\n        \n\n        // mix with previous particles, with alpha\n        float circleAlpha = 1.0 - smoothstep(circleThres, circleThres + aaBlur, circleDist);\n        col = mix(col, pColor, circleAlpha * particleAlpha);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int numParticles = 399;\n    const int pDataOffset = 1;\n    const float noiseSeed = 300.0;\n    \n    // each cell or frag stores a bit of metadata or info of a particle\n    vec4 outQuad = vec4(0.0);\n    float fragsPerRow = iResolution.x;\n    int fragIndex = int(floor(fragCoord.y) * fragsPerRow + floor(fragCoord.x));\n    \n    // first frag contains metadata\n    if (fragIndex == 0) {\n        //  0: particle count\n        //  1: fragment offset where particle data starts\n        //  2: unused\n        //  3: unused\n        outQuad[0] = float(numParticles);\n        outQuad[1] = float(pDataOffset);\n        \n    } else if (fragIndex < numParticles + pDataOffset) {\n\n        // store information about each particle in each fragment\n        //  0: center x\n        //  1: center y\n        //  2: pulsating speed factor\n        //  3: unused\n        int pIndex = fragIndex - pDataOffset;\n        \n        // random xy coordinates for each\n        vec2 noiseX = vec2(float(pIndex), float(pIndex + 1));\n        outQuad[0] = gold_noise(noiseX, noiseSeed);\n        \n        vec2 noiseY = vec2(float(pIndex + 10), float(pIndex + 11));\n        outQuad[1] = gold_noise(noiseY, noiseSeed);\n        \n        // random pulsating speed factor\n        // range 0.5 - 2.5\n        float speedFactor = sin(float(pIndex)) + 1.2;\n        outQuad[2] = speedFactor;\n    }\n    \n    \n\n    fragColor = outQuad;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nfloat sinWithCenter(float x, float centerY, float amplitude, float cycleWidth) {\n    float xFactor = (2.0 * PI) / cycleWidth;\n    float sinY = sin(x * xFactor) * amplitude + centerY;\n    return sinY;\n}\n\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Gold Noise ©2015 dcerisano@standard3d.com\n// - based on the Golden Ratio\n// - uniform normalized distribution\n// - fastest static noise generator function (also runs at low precision)\n// - use with indicated fractional seeding method. \nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n","name":"Common","description":"","type":"common"}]}