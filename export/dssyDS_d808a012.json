{"ver":"0.1","info":{"id":"dssyDS","date":"1687208356","viewed":181,"name":"golden mirror","username":"Carandiru","description":"virtual sandbox for a mirror shaped like the golden ratio spiral in 3D (raymarched)\nThe x,y axis is the spiral, and the z axis is infinite. \nlike a unrolled cylinder.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["mirror","golden","ratio"],"hasliked":0,"parentid":"DlK3Dy","parentname":"red mercury"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -golden mirror-\n//\n// virtual sandbox for a mirror shaped like the golden ratio spiral in 3D (raymarched)\n//\n// The x,y axis is the spiral, and the z axis is infinite. \n// like a unrolled cylinder.\n//\n//\n//\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/dssyDS\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define BOUNCES 5 // up-to ~30 on nv-ampere gpu\n\n#define SIZE 40.0\n#define INTENSITY 2000.0\n\n//#define WARP_MODE // uncomment to see space bend at super luminal speed....\n\n\nconst vec3 light_color = vec3(1.0, 0.9, 0.7);\n\n// boxmapping / triplanar projection - https://www.shadertoy.com/view/MtsGWH - iq\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat golden_spiral(vec2 p, float scale, float zoom) {\n    \n    float r = length(p);\n    \n    float theta = atan(p.x,p.y);\n   \n    float logspiral = log(r)/log(GOLDEN_RATIO) + theta;\n   \n    return sin(scale*logspiral -zoom);\n    \n}\n\nfloat map( in vec3 p )\n{\n  //  return length(p-vec3(0.0,1.0,0.0))-1.5;\n    \n#ifdef WARP_MODE\n    float warp = iTime*iTime;\n#else\n    float warp = iTime;\n#endif\n    return( golden_spiral(p.xy, 1.0, warp) );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// quality stars\n#define scale (0.72)\n#define star_maximum_luminance (10000.0)\n#define distance_maximum_out (150.0)\n\nuvec3 murmur3( in uvec3 u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\nvec3 unorm(uvec3 n) { return(fract(vec3(n) * (1.0 / float(0xffffffffU)))); }\n\nvec3 hash33(in vec3 m) \n{\n    uvec3 mu = floatBitsToUint(m * GOLDEN_RATIO) | 0x1u;\n\n    mu = murmur3(mu);\n\n    return(1.0f - unorm(mu));\n}\n\nfloat rand(in vec3 st) {\n  vec3 r = hash33(st) * GOLDEN_RATIO_ZERO;\n  return fract(r.z * 111.111111 * 111.111111 + r.y * 111.111111 + r.x);\n}\n\nfloat pixel_stars(in vec3 st, in float t) {\n  float r = rand(round(st));\n  return 0.000001 + smoothstep(0.995*t, 1.0, r);\n}\n\nfloat stars(in vec3 st, in float t) {\n  return(pixel_stars(st, t));\n}\n\nfloat background(vec3 dir, float d)\n{\n    d = 1.0f / (1.0f + d*d);\n    \n    float den = abs(dir.y); den = 1.0-den; den=den*den*den*den; den*=.1;\n    \n    float n = stars(scale * (dir*(1.0 - d)*iResolution.y), 1.0f - den);\n    \n\t\n\treturn d * star_maximum_luminance * pow(n*0.95f+den,22.0);\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bn = textureLod(iChannel1, fragCoord.xy / 1024.0f, 0.0).r;\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // camera movement\t\n        float an = 0.2*iTime;\n        vec3 ro = vec3( 0.333333f * cos(an), 0.333333f * sin(an), 2.0f * PI );\n        vec3 ta = vec3( 0.0, 1.0, 0.0 );\n        \n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        \n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + GOLDEN_RATIO * ww );\n        vec3 ll = rd;\n        vec3 col = vec3(0);\n        \n        float intensity = INTENSITY;\n        float tran = 1.0f;\n        \n        // bounces\n        for ( int bounce = 0; bounce < BOUNCES; ++bounce ) \n        {\n            // raymarch\n            const float tmax = 2.0f*PI;\n            float t = 1.0;\n            for( int i=0; i<128; i++ )\n            {\n                vec3 pos = ro + rd*t;\n                float h = map(pos);\n                if( h<0.0001 ) break;\n                t += h;\n                if( t>tmax ) break;\n            }\n\n            if( t<tmax )\n            {\n                vec3 pos = ro + rd*t;\n                \n                vec3 N = calcNormal( pos, 0.001 );\n\n                float NdotL = 1.0f - max(0.0f, dot(N, -rd));\n                \n                t = t * SIZE * tran + tran;\n                \n                vec3 light = light_color / (1.0f + t*t); \n                                                \n                // reflection bounce\n                rd = normalize(reflect(rd, N));\n                vec3 back = mix(col, vec3(background(-rd, t)), bvec3(all(equal(col, vec3(0)))));\n                \n                col += (NdotL) * light * intensity * abs((rd.z-ll.z));\n                col += (NdotL) * back * light * intensity;\n                \n                ro = pos + rd*bn*0.00625f; // offset bounce away from actual intersection / reflection\n                tran = t;\n\n             }\n             else {\n             \n                 col += background(rd, t*SIZE);\n                 break;\n             }\n             \n        } // bounce\n        \n        // to gamma space\n        col = sqrt( col );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    tot = tot + bn * 17.0f/255.0f;\n    \n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820) // 1618033988\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n#define GOLDEN_ANGLE (2.399963229728653)\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n","name":"Common","description":"","type":"common"}]}