{"ver":"0.1","info":{"id":"ltGXWK","date":"1514662766","viewed":320,"name":"Quadruple Precision Mandelbrot","username":"mazander","description":"Quadruple Precision Mandelbrot Fractal with multiple zoom targets.\n\nEmulated quadruple precision GLSL library Created by Henry Thasler (https://www.thasler.com/blog/blog/glsl-part5)\nBased on the QD library (http://crd-legacy.lbl.gov/~dhbailey/mpdist/)\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandel","quadrupleprecision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// emulated quadruple precision GLSL library\n// created by Henry Thasler (thasler.org/blog)\n// based on the QD library (http://crd-legacy.lbl.gov/~dhbailey/mpdist/)\n\n// inline double quick_two_sum(double a, double b, double &err)\nvec2 quick_2sum(float a, float b)\n{\n    float s = a + b;                       // double s = a + b;\n    return vec2(s, b-(s-a));       // err = b - (s - a);\n}\n\n/* Computes fl(a+b) and err(a+b).  */\n// inline double two_sum(double a, double b, double &err)\nvec2 two_sum(float a, float b)\n{\n    float v,s,e;\n\n    s = a+b;                               // double s = a + b;\n    v = s-a;                               // double bb = s - a;\n    e = (a-(s-v))+(b-v);   // err = (a - (s - bb)) + (b - bb);\n\n    return vec2(s,e);\n}\n\nvec2 split(float a)\n{\n    float t, hi;\n    t = 8193. * a;\n    hi = t - (t-a);\n    return vec2(hi, a-hi);\n}\n\nvec3 three_sum(float a, float b, float c)\n{\n    vec2 tmp;\n    vec3 res;// = vec3(0.);\n    float t1, t2, t3;\n    tmp = two_sum(a, b); // t1 = qd::two_sum(a, b, t2);\n    t1 = tmp.x;\n    t2 = tmp.y;\n\n    tmp = two_sum(c, t1); // a  = qd::two_sum(c, t1, t3);\n    res.x = tmp.x;\n    t3 = tmp.y;\n\n    tmp = two_sum(t2, t3); // b  = qd::two_sum(t2, t3, c);\n    res.y = tmp.x;\n    res.z = tmp.y;\n\n    return res;\n}\n\n//inline void three_sum2(double &a, double &b, double &c)\nvec3 three_sum2(float a, float b, float c)\n{\n    vec2 tmp;\n    vec3 res;// = vec3(0.);\n    float t1, t2, t3;       // double t1, t2, t3;\n    tmp = two_sum(a, b); // t1 = qd::two_sum(a, b, t2);\n    t1 = tmp.x;\n    t2 = tmp.y;\n\n    tmp = two_sum(c, t1); // a  = qd::two_sum(c, t1, t3);\n    res.x = tmp.x;\n    t3 = tmp.y;\n\n    res.y = t2 + t3;      // b = t2 + t3;\n    return res;\n}\n\nvec2 two_prod(float a, float b)\n{\n    float p, e;\n    vec2 va, vb;\n\n    p=a*b;\n    va = split(a);\n    vb = split(b);\n\n    e = ((va.x*vb.x-p) + va.x*vb.y + va.y*vb.x) + va.y*vb.y;\n    return vec2(p, e);\n}\n\nvec4 renorm(float c0, float c1, float c2, float c3, float c4)\n{\n    float s0, s1, s2 = 0.0, s3 = 0.0;\n    vec2 tmp;\n\n    // if (QD_ISINF(c0)) return;\n\n    tmp = quick_2sum(c3,c4); // s0 = qd::quick_two_sum(c3, c4, c4);\n    s0 = tmp.x;\n    c4 = tmp.y;\n\n    tmp = quick_2sum(c2,s0); // s0 = qd::quick_two_sum(c2, s0, c3);\n    s0 = tmp.x;\n    c3 = tmp.y;\n\n    tmp = quick_2sum(c1,s0); // s0 = qd::quick_two_sum(c1, s0, c2);\n    s0 = tmp.x;\n    c2 = tmp.y;\n\n    tmp = quick_2sum(c0,s0); // c0 = qd::quick_two_sum(c0, s0, c1);\n    c0 = tmp.x;\n    c1 = tmp.y;\n\n    s0 = c0;\n    s1 = c1;\n\n    tmp = quick_2sum(c0,c1); // s0 = qd::quick_two_sum(c0, c1, s1);\n    s0 = tmp.x;\n    s1 = tmp.y;\n\n    if (s1 != 0.0) {\n        tmp = quick_2sum(s1,c2); // s1 = qd::quick_two_sum(s1, c2, s2);\n        s1 = tmp.x;\n        s2 = tmp.y;\n\n        if (s2 != 0.0) {\n            tmp = quick_2sum(s2,c3); // s2 = qd::quick_two_sum(s2, c3, s3);\n            s2 = tmp.x;\n            s3 = tmp.y;\n            if (s3 != 0.0)\n                s3 += c4;\n            else\n                s2 += c4;\n        } else {\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;\n            if (s2 != 0.0){\n                tmp = quick_2sum(s2,c4); // s2 = qd::quick_two_sum(s2, c4, s3);\n                s2 = tmp.x;\n                s3 = tmp.y;}\n            else{\n                tmp = quick_2sum(s1,c4); // s1 = qd::quick_two_sum(s1, c4, s2);\n                s1 = tmp.x;\n                s2 = tmp.y;}\n        }\n    } else {\n        tmp = quick_2sum(s0,c2); // s0 = qd::quick_two_sum(s0, c2, s1);\n        s0 = tmp.x;\n        s1 = tmp.y;\n        if (s1 != 0.0) {\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;\n            if (s2 != 0.0){\n                tmp = quick_2sum(s2,c4); // s2 = qd::quick_two_sum(s2, c4, s3);\n                s2 = tmp.x;\n                s3 = tmp.y;}\n            else{\n                tmp = quick_2sum(s1,c4); // s1 = qd::quick_two_sum(s1, c4, s2);\n                s1 = tmp.x;\n                s2 = tmp.y;}\n        } else {\n            tmp = quick_2sum(s0,c3); // s0 = qd::quick_two_sum(s0, c3, s1);\n            s0 = tmp.x;\n            s1 = tmp.y;\n            if (s1 != 0.0){\n                tmp = quick_2sum(s1,c4); // s1 = qd::quick_two_sum(s1, c4, s2);\n                s1 = tmp.x;\n                s2 = tmp.y;}\n            else{\n                tmp = quick_2sum(s0,c4); // s0 = qd::quick_two_sum(s0, c4, s1);\n                s0 = tmp.x;\n                s1 = tmp.y;}\n        }\n    }\n\n    return vec4(s0, s1, s2, s3);\n\n}\n\nvec4 renorm4(float c0, float c1, float c2, float c3)\n{\n    float s0, s1, s2 = 0.0, s3 = 0.0;\n    vec2 tmp;\n    // if (QD_ISINF(c0)) return;\n\n    tmp = quick_2sum(c2,c3); // s0 = qd::quick_two_sum(c2, c3, c3);\n    s0 = tmp.x;\n    c3 = tmp.y;\n\n    tmp = quick_2sum(c1,s0); // s0 = qd::quick_two_sum(c1, s0, c2);\n    s0 = tmp.x;\n    c2 = tmp.y;\n\n    tmp = quick_2sum(c0,s0); // c0 = qd::quick_two_sum(c0, s0, c1);\n    c0 = tmp.x;\n    c1 = tmp.y;\n\n    s0 = c0;\n    s1 = c1;\n    if (s1 != 0.0) {\n        tmp = quick_2sum(s1,c2); // s1 = qd::quick_two_sum(s1, c2, s2);\n        s1 = tmp.x;\n        s2 = tmp.y;\n\n        if (s2 != 0.0){\n            tmp = quick_2sum(s2,c3); // s2 = qd::quick_two_sum(s2, c3, s3);\n            s2 = tmp.x;\n            s3 = tmp.y;}\n        else{\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;}\n    } else {\n        tmp = quick_2sum(s0,c2); // s0 = qd::quick_two_sum(s0, c2, s1);\n        s0 = tmp.x;\n        s1 = tmp.y;\n        if (s1 != 0.0){\n            tmp = quick_2sum(s1,c3); // s1 = qd::quick_two_sum(s1, c3, s2);\n            s1 = tmp.x;\n            s2 = tmp.y;}\n        else{\n            tmp = quick_2sum(s0,c3); // s0 = qd::quick_two_sum(s0, c3, s1);\n            s0 = tmp.x;\n            s1 = tmp.y;}\n    }\n\n    return vec4(s0, s1, s2, s3);\n}\n\nvec3 quick_three_accum(float a, float b, float c)\n{\n    vec2 tmp;\n    float s;\n    bool za, zb;\n\n    tmp = two_sum(b, c); // s = qd::two_sum(b, c, b);\n    s = tmp.x;\n    b = tmp.y;\n\n    tmp = two_sum(a, s); // s = qd::two_sum(a, s, a);\n    s = tmp.x;\n    a = tmp.y;\n\n    za = (a != 0.0);\n    zb = (b != 0.0);\n\n    if (za && zb)\n        return vec3(a,b,s);\n\n    if (!zb) {\n        b = a;\n        a = s;\n    } else {\n        a = s;\n    }\n\n    return vec3(a,b,0.);\n}\n\n// inline qd_real qd_real::ieee_add(const qd_real &a, const qd_real &b)\nvec4 qs_ieee_add(vec4 _a, vec4 _b)\n{\n    vec2 tmp=vec2(0.);\n    vec3 tmp3=vec3(0.);\n    int i, j, k;\n    float s, t;\n    float u, v;   // double-length accumulator\n    float x[4] = float[4](0.0, 0.0, 0.0, 0.0);\n    float a[4], b[4];\n\n    a[0] = _a.x;\n    a[1] = _a.y;\n    a[2] = _a.z;\n    a[3] = _a.w;\n\n    b[0] = _b.x;\n    b[1] = _b.y;\n    b[2] = _b.z;\n    b[3] = _b.w;\n\n    i = j = k = 0;\n    if (abs(a[i]) > abs(b[j]))\n        u = a[i++];\n    else\n        u = b[j++];\n    if (abs(a[i]) > abs(b[j]))\n        v = a[i++];\n    else\n        v = b[j++];\n\n    tmp = quick_2sum(u,v); // u = qd::quick_two_sum(u, v, v);\n    u = tmp.x;\n    v = tmp.y;\n\n    while (k < 4) {\n        if (i >= 4 && j >= 4) {\n            x[k] = u;\n            if (k < 3)\n                x[++k] = v;\n            break;\n        }\n\n        if (i >= 4)\n            t = b[j++];\n        else if (j >= 4)\n            t = a[i++];\n            else if (abs(a[i]) > abs(b[j])) {\n                t = a[i++];\n            } else\n                t = b[j++];\n\n        tmp3 = quick_three_accum(u,v,t)  ; // s = qd::quick_three_accum(u, v, t);\n        u = tmp3.x;\n        v = tmp3.y;\n        s = tmp3.z;\n\n        if (s != 0.0) {\n            x[k++] = s;\n        }\n    }\n\n    // add the rest.\n    for (k = i; k < 4; k++)\n        x[3] += a[k];\n    for (k = j; k < 4; k++)\n        x[3] += b[k];\n\n    // qd::renorm(x[0], x[1], x[2], x[3]);\n    // return qd_real(x[0], x[1], x[2], x[3]);\n    return renorm4(x[0], x[1], x[2], x[3]);\n}\n\n// inline qd_real qd_real::sloppy_add(const qd_real &a, const qd_real &b)\nvec4 qs_sloppy_add(vec4 a, vec4 b)\n{\n    float s0, s1, s2, s3;\n    float t0, t1, t2, t3;\n\n    float v0, v1, v2, v3;\n    float u0, u1, u2, u3;\n    float w0, w1, w2, w3;\n\n    vec2 tmp;\n    vec3 tmp3;\n\n    s0 = a.x + b.x;       // s0 = a[0] + b[0];\n    s1 = a.y + b.y;       // s1 = a[1] + b[1];\n    s2 = a.z + b.z;       // s2 = a[2] + b[2];\n    s3 = a.w + b.w;       // s3 = a[3] + b[3];  \n\n    v0 = s0 - a.x;        // v0 = s0 - a[0];\n    v1 = s1 - a.y;        // v1 = s1 - a[1];\n    v2 = s2 - a.z;        // v2 = s2 - a[2];\n    v3 = s3 - a.w;        // v3 = s3 - a[3];\n\n    u0 = s0 - v0;\n    u1 = s1 - v1;\n    u2 = s2 - v2;\n    u3 = s3 - v3;\n\n    w0 = a.x - u0;        // w0 = a[0] - u0;\n    w1 = a.y - u1;        // w1 = a[1] - u1;\n    w2 = a.z - u2;        // w2 = a[2] - u2;\n    w3 = a.w - u3;        // w3 = a[3] - u3; \n\n    u0 = b.x - v0;        // u0 = b[0] - v0;\n    u1 = b.y - v1;        // u1 = b[1] - v1;\n    u2 = b.z - v2;        // u2 = b[2] - v2;\n    u3 = b.w - v3;        // u3 = b[3] - v3;\n\n    t0 = w0 + u0;\n    t1 = w1 + u1;\n    t2 = w2 + u2;\n    t3 = w3 + u3;\n\n    tmp = two_sum(s1, t0); // s1 = qd::two_sum(s1, t0, t0);\n    s1 = tmp.x;\n    t0 = tmp.y;\n\n    tmp3 = three_sum(s2, t0, t1); // qd::three_sum(s2, t0, t1);\n    s2 = tmp3.x;\n    t0 = tmp3.y;\n    t1 = tmp3.z;\n\n    tmp3 = three_sum2(s3, t0, t2); // qd::three_sum2(s3, t0, t2);\n    s3 = tmp3.x;\n    t0 = tmp3.y;\n    t2 = tmp3.z;\n\n    t0 = t0 + t1 + t3;\n\n    // qd::renorm(s0, s1, s2, s3, t0);\n    return renorm(s0, s1, s2, s3, t0); // return qd_real(s0, s1, s2, s3);\n}\n\nvec4 qs_add(vec4 _a, vec4 _b)\n{\n    return qs_sloppy_add(_a, _b);\n    //  return qs_ieee_add(_a, _b);\n}  \n\nvec4 qs_mul(vec4 a, vec4 b)\n{\n    float p0, p1, p2, p3, p4, p5;\n    float q0, q1, q2, q3, q4, q5;\n    float t0, t1;\n    float s0, s1, s2;\n    vec2 tmp;\n    vec3 tmp3;\n\n    tmp = two_prod(a.x, b.x); // p0 = qd::two_prod(a[0], b[0], q0);\n    p0 = tmp.x;\n    q0 = tmp.y;\n\n    tmp = two_prod(a.x, b.y); // p1 = qd::two_prod(a[0], b[1], q1);\n    p1 = tmp.x;\n    q1 = tmp.y;\n\n    tmp = two_prod(a.y, b.x); // p2 = qd::two_prod(a[1], b[0], q2);\n    p2 = tmp.x;\n    q2 = tmp.y;\n\n    tmp = two_prod(a.x, b.z); // p3 = qd::two_prod(a[0], b[2], q3);\n    p3 = tmp.x;\n    q3 = tmp.y;\n\n    tmp = two_prod(a.y, b.y); // p4 = qd::two_prod(a[1], b[1], q4);\n    p4 = tmp.x;\n    q4 = tmp.y;\n\n    tmp = two_prod(a.z, b.x); // p5 = qd::two_prod(a[2], b[0], q5);\n    p5 = tmp.x;\n    q5 = tmp.y;\n\n    /* Start Accumulation */\n    tmp3 = three_sum(p1, p2, q0); // qd::three_sum(p1, p2, q0);\n    p1 = tmp3.x;\n    p2 = tmp3.y;\n    q0 = tmp3.z;\n\n    /* Six-Three Sum  of p2, q1, q2, p3, p4, p5. */\n    tmp3 = three_sum(p2, q1, q2); // qd::three_sum(p2, q1, q2);\n    p2 = tmp3.x;\n    q1 = tmp3.y;\n    q2 = tmp3.z;\n\n    tmp3 = three_sum(p3, p4, p5); // qd::three_sum(p3, p4, p5);\n    p3 = tmp3.x;\n    p4 = tmp3.y;\n    p5 = tmp3.z;\n\n    /* compute (s0, s1, s2) = (p2, q1, q2) + (p3, p4, p5). */\n    tmp = two_sum(p2, p3); // s0 = qd::two_sum(p2, p3, t0);\n    s0 = tmp.x;\n    t0 = tmp.y;\n\n    tmp = two_sum(q1, p4); // s1 = qd::two_sum(q1, p4, t1);\n    s1 = tmp.x;\n    t1 = tmp.y;\n\n    s2 = q2 + p5;\n    tmp = two_sum(s1, t0); // s1 = qd::two_sum(s1, t0, t0);\n    s1 = tmp.x;\n    t0 = tmp.y;\n    s2 += (t0 + t1);\n\n    /* O(eps^3) order terms */\n    s1 += a.x*b.w + a.y*b.z + a.z*b.y + a.w*b.x + q0 + q3 + q4 + q5;\n\n    return renorm(p0, p1, s0, s1, s2); // qd::renorm(p0, p1, s0, s1, s2);\n}\n\nfloat ds_compare(vec2 dsa, vec2 dsb)\n{\n    if (dsa.x < dsb.x) return -1.;\n    else if (dsa.x == dsb.x)\n    {\n        if (dsa.y < dsb.y) return -1.;\n        else if (dsa.y == dsb.y) return 0.;\n            else return 1.;\n            }\n    else return 1.;\n}\n\nfloat qs_compare(vec4 qsa, vec4 qsb)\n{\n    if(ds_compare(qsa.xy, qsb.xy)<0.) return -1.; // if (dsa.x < dsb.x) return -1.;\n    else if (ds_compare(qsa.xy, qsb.xy) == 0.) // else if (dsa.x == dsb.x)\n    {\n        if(ds_compare(qsa.zw, qsb.zw)<0.) return -1.; // if (dsa.y < dsb.y) return -1.;\n        else if (ds_compare(qsa.zw, qsb.zw) == 0.) return 0.;// else if (dsa.y == dsb.y) return 0.;\n            else return 1.;\n            }\n    else return 1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\n    float a = 0.4*iTime;\n\tfloat tz = 0.5 - 0.5 * cos(a);\n\n        // array of zoom targets: x + yi\n    vec2[] zoomTargets = vec2[] (\n        vec2(-1.25067, 0.02012),\n        vec2(-0.235125, 0.827215),\n        vec2(-0.74635, 0.11022),\n        vec2(-0.925, 0.266),\n        vec2(-0.745428, 0.113009),\n        vec2(-0.7479, 0.099983)\n    );\n    \n    // select zoom target\n    vec2 target = zoomTargets[int(a / 6.28318530718) % 6];\n    vec2 targetNext = zoomTargets[int(a / 6.28318530718 + 1.0) % 6];\n    \n    \n    vec4 zo = vec4(pow(0.5, 15.0 * tz), 0.0, 0.0, 0.0);\n\n    vec4 cx = vec4(p.x, 0.0, 0.0, 0.0);\n    vec4 cy = vec4(p.y, 0.0, 0.0, 0.0);\n   \t\n\tcx = qs_add(qs_mul(cx, zo), vec4(target.x, 0.0, 0.0, 0.0));\n\tcy = qs_add(qs_mul(cy, zo), vec4(target.y, 0.0, 0.0, 0.0));\n    \n    float n = 0.0;\n\t\n    vec4 tmp;\n    vec4 zx = cx;\n    vec4 zy = cy;\n    vec4 two = vec4(2.0, 0., 0., 0.); \n    \n    vec4 e_radius = vec4(4.0, 0., 0., 0.);   // no sqrt available so compare with radius^2 = 2^2 = 2*2 = 4\n    \n    for( int i=0; i <1500; i++ )\n    {\n\t\ttmp = zx;\n        zx = qs_add(qs_add(qs_mul(zx, zx), -qs_mul(zy, zy)), cx);\n        zy = qs_add(qs_mul(qs_mul(zy, tmp), two), cy);\n\n        if( qs_compare(qs_add(qs_mul(zx, zx), qs_mul(zy, zy)), e_radius) > 0.)\n        {\n            // http://linas.org/art-gallery/escape/escape.html\n            n += 1. - log(log(length(vec2(zx.x, zy.x)))) /log(2.);     \n            break;   \n        }\n        n += 1.0;\n    }\n    \n\n    if(n < 1500.0 ) {\n        fragColor = vec4((-cos(n * vec3(0.025, 0.08, 0.12)) + 1.0) * 0.5, 1.0);\n\n    } else {\n        // black center\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n        \n}\n\n","name":"Image","description":"","type":"image"}]}