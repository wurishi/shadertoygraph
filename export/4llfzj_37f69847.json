{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//#define GALAXY\n\nstruct PointLight {\n    vec2 pos;\n    vec3 col;\n    float intensity;\n};\n\nfloat palette( in float a, in float b, in float c, in float d, in float x ) {\n    return a + b * cos(6.28318 * (c * x + d));\n}\n    \n// 2D Noise from IQ\nfloat Noise2D( in vec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat ComputeFBM( in vec2 pos )\n{\n    float amplitude = 0.75;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < 6; ++i)\n    {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 0.5;\n        pos *= 2.2;\n    }\n    return sum / maxAmp;\n}\n\n// Same function but with a different, constant amount of octaves\nfloat ComputeFBMStars( in vec2 pos )\n{\n    float amplitude = 0.75;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < 5; ++i)\n    {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 0.5;\n        pos *= 2.0;\n    }\n    return sum / maxAmp * 1.15;\n}\n\nvec3 BackgroundColor( in vec2 uv ) {\n    \n    // Sample various noises and multiply them\n    float noise1 = ComputeFBMStars(uv * 5.0);\n    float noise2 = ComputeFBMStars(uv * vec2(15.125, 25.7));\n    float noise3 = ComputeFBMStars((uv + vec2(0.5, 0.1)) * 4.0 + iTime * 0.35);\n    float starShape = noise1 * noise2 * noise3;\n    \n    // Compute star falloff - not really doing what i hoped it would, i wanted smooth falloff around each star\n    float falloffRadius = 0.2;\n    float baseThreshold = 0.6; // higher = less stars\n    \n    starShape = clamp(starShape - baseThreshold + falloffRadius, 0.0, 1.0);\n    \n    float weight = starShape / (2.0 * falloffRadius);\n    return weight * vec3(noise1 * 0.55, noise2 * 0.4, noise3 * 1.0) * 6.0; // artificial scale just makes the stars brighter\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0;\n    \n    vec4 finalColor;\n    \n    #ifdef GALAXY\n    \n    vec2 samplePt = scrPt;\n    \n    // Warp noise domain\n    float swirlStrength = 2.5;\n    float dist = length(samplePt);\n    float theta = dist * swirlStrength - iTime * 0.225;\n    mat2 rot;\n    \n    // cache calls to sin/cos\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    samplePt *= rot;\n    samplePt *= 3.0;\n    \n    float noiseVal = ComputeFBM(samplePt + sin(iTime * 0.03125));\n    float maxIntensity = 1.65; // kinda is the galaxy radius/size?\n    noiseVal *= clamp(pow(maxIntensity - dist, 5.0) * (1.0 / maxIntensity), 0.0, 1.0);\n    \n    // Lighting\n    PointLight l1;\n    l1.pos = vec2(0);\n    l1.col = mix(vec3(0.75, 0.5, 0.3), vec3(0.55, 0.4, 0.95), clamp(dist * 0.5, 0.0, 1.0) + (sin(iTime * 0.5) * 0.5 + 0.5) * 0.5);\n    l1.intensity = 4.0;\n    \n    vec3 l1Col = l1.col * l1.intensity * 1.0 / pow(length(l1.pos - samplePt), 0.5);\n    //vec4 finalColor = vec4(BackgroundColor(fragCoord.xy * 0.25), 1.0);\n    //vec4 finalColor = vec4(l1Col * noiseVal, 1.0);\n    finalColor = vec4(mix(BackgroundColor(fragCoord.xy * 0.125), l1Col * noiseVal, pow(noiseVal, 1.0)), 1.0);\n    \n    #else // Milky Way    \n    \n\t// Define density for some shape representing the milky way galaxy\n    \n    float milkywayShape;\n    \n    // Distort input screen pos slightly so the galaxy isnt perfectly axis aligned\n    float galaxyOffset = (cos(scrPt.x * 5.0) * sin(scrPt.x * 2.0) * 0.5 + 0.5) * 0.0;\n    \n    // Apply a slight rotation to the screen point, similar to the galaxy\n    float theta = length(scrPt) * 0.25; // Visualy tweaked until it looked natural\n    mat2 rot;\n    \n    // cache calls to sin/cos(theta)\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    vec2 rotatedScrPt = scrPt * rot;\n    \n    float noiseVal = ComputeFBM(rotatedScrPt * 5.0 + 50.0 + iTime * 0.015625 * 1.5);\n    \n    rotatedScrPt += vec2(noiseVal) * 0.3;\n    \n    float centralFalloff = clamp(1.0 - length(scrPt.y + galaxyOffset), 0.0, 1.0);\n    float xDirFalloff = (cos(scrPt.x * 2.0) * 0.5 + 0.5);\n    \n    float centralFalloff_rot = 1.0 - length(rotatedScrPt.y + galaxyOffset);\n    float xDirFalloff_rot = (cos(rotatedScrPt.x * 2.0) * 0.5 + 0.5);\n    \n    // Falloff in y dir and x-dir fade\n    float lowFreqNoiseForFalloff = ComputeFBM(rotatedScrPt * 4.0 - iTime * 0.015625 * 1.5); // 1/64\n    //float lowFreqNoiseForFalloff_offset = ComputeFBM(rotatedScrPt * 1.5 + 0.005 * lowFreqNoiseForFalloff);\n    milkywayShape = clamp(pow(centralFalloff_rot, 3.0) - lowFreqNoiseForFalloff * 0.5, 0.0, 1.0) * xDirFalloff_rot;\n    \n    // Lighting\n    vec3 color;\n    \n    // desired brown color\n    //vec3 brown = vec3(0.35, 0.175, 0.15) * 17.0;\n    //vec3 mainColor = vec3(0.925, 1.0, 0.8) * 10.0;\n    //color = mix(brown, mainColor, pow(milkywayShape, 1.0)) * 2.0 * milkywayShape;\n    \n    // Cosine-based pallette: http://dev.thi.ng/gradients/\n    // there is also a famous IQ article on this and a less famous shader on my profile\n    color.r = palette(0.5, -1.081592653589793, 0.798407346410207, 0.0, pow(milkywayShape, 1.0));\n    color.g = palette(0.5, 0.658407346410207, 0.908407346410207, 0.268407346410207, pow(milkywayShape, 1.0));\n    color.b = palette(0.5, -0.201592653589793, 0.318407346410207, -0.001592653589793, pow(milkywayShape, 1.0));\n    \n    /* dont do this\n    color.r += 0.5 * palette(0.5, -0.481592653589793, 0.798407346410207, 0.0, pow(noiseVal, 1.0));\n    color.g += 0.5 * palette(0.5, 0.428407346410207, 0.908407346410207, 0.268407346410207, pow(noiseVal, 0.5));\n    color.b += 0.5 * palette(0.5, -0.001592653589793, 0.318407346410207, -0.001592653589793, pow(noiseVal, 1.0));\n    */\n    \n    // Experimented with removing color, worked out decently\n    float removeColor = (pow(milkywayShape, 10.0) + lowFreqNoiseForFalloff * 0.1) * 5.0;\n    color -= vec3(removeColor);\n    \n    // Add some blue to the background\n    vec3 backgroundCol = BackgroundColor(fragCoord.xy * 0.125) * pow(centralFalloff, 0.5) * pow(xDirFalloff, 0.5);\n    vec3 blueish = vec3(0.2, 0.2, 0.4);\n    backgroundCol += blueish * (5.0 - milkywayShape) * pow(centralFalloff_rot, 2.0) * lowFreqNoiseForFalloff * pow(xDirFalloff, 0.75);\n    \n    vec3 whiteish = vec3(0.5, 1.0, 0.85);\n    backgroundCol += whiteish * 0.95 * pow(centralFalloff, 1.5) * lowFreqNoiseForFalloff * pow(xDirFalloff, 2.0);\n    \n    \n    finalColor = vec4(mix(backgroundCol, color, milkywayShape), 1);\n    \n    #endif\n    \n\tfragColor = finalColor;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4llfzj","date":"1512501740","viewed":3845,"name":"Galaxy/Nebula and Stars","username":"jgkling","description":"space waow","likes":62,"published":1,"flags":0,"usePreview":1,"tags":["procedural","noise","star","space","galaxy"],"hasliked":0,"parentid":"","parentname":""}}