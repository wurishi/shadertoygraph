{"ver":"0.1","info":{"id":"3dXyzH","date":"1584100733","viewed":320,"name":"RGB Halftone 2","username":"voax","description":"RGB Halftone effect on a triangular/hexagonal grid. Mouse controls angle/scale.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["rgb","halftone","triangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float size = 15.0; // length of edges of grid\nfloat angle = 0.0;\n#define SEPERATE_CHANNELS\n\nconst float sin30 = 0.5;\nconst float cos30 = 0.86602540378; // = sin60 = sqrt(3) / 2.0\nconst float sqrt3 = sqrt(3.0);\n\nbool feq(float a, float b) { return abs(a-b) < 1e-5; }\nfloat lengthSq(vec2 v) { return dot(v,v); }\n\nvec2 triangleCell(vec2 xy) {\n    vec2 pos = xy / vec2(size * sin30, size * cos30);\n    vec2 i = floor(pos);\n    vec2 r = fract(pos);\n    if(feq(mod(i.x, 2.), 1.) ^^ feq(mod(i.y, 2.), 1.)) { \n        if (r.x + r.y < 1.0)\n            i.x--; \n    } \n    else { \n        if(r.x - r.y < 0.0)\n            i.x--; \n    }\n    return i;\n}\n\nmat2 rotm(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\nvec2 findNearest(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 nearest = a;\n    float best_distSq = lengthSq(p-a);\n    float f;\n    if ( (f=lengthSq(p-b)) < best_distSq) {\n    \tbest_distSq = f;\n        nearest = b;\n    }\n    if ( (f=lengthSq(p-c)) < best_distSq) {\n    \tbest_distSq = f;\n        nearest = c;\n    }\n    return nearest;\n}\n\nvec2 nearestTriangleVertex(vec2 xy) {\n    vec2 i = triangleCell(xy);\n    \n    vec2 origin = vec2(i) * vec2(size * sin30, size * cos30);\n    vec2 x = origin;\n    vec2 y = origin + vec2(size, 0);\n    vec2 z = origin + vec2(size * 0.5, 0);\n    \n    if (feq(mod(i.y, 2.), 1.) ^^ feq(mod(i.x, 2.), 1.))\n    {\n        x.y += size * cos30;\n        y.y += size * cos30;\n    }\n    else\n        z.y += size * cos30;\n    \n    vec2 nearest_vertex = findNearest(xy, x, y, z);\n    return nearest_vertex;\n}\n\nvec3 halftone_dist(vec2 xy, mat2 m) {\n    vec2 rxy = m * xy;\n    \n    vec2 triangle_xy = nearestTriangleVertex(m * xy) * m;\n    \n    float dSq = lengthSq(xy - triangle_xy);\n    \n    vec2 uv = triangle_xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(2.2));\t// convert texture to linear gamma\n    float maxCircleSizeSq = 0.25 * size * size; // max circle size = 0.5 * size\n    // radius = sqrt(linear color) * maxCircleSize\n    vec3 radiusSq = vec3(col.x, col.y, col.z) * maxCircleSizeSq;\n    return dSq / radiusSq; // return ratio distance^2 / radius^2\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.5) {\n        size = mix(3., 100., iMouse.y / iResolution.y);\n        angle = 360.0 * iMouse.x / iResolution.x;\n    }\n    \n    mat2 mb = rotm(radians( 0.0 + angle));\n    \n    vec3 ratio;\n#ifdef SEPERATE_CHANNELS\n    mat2 mr = rotm(radians(15.0 + angle));\n    mat2 mg = rotm(radians(45.0 + angle));\n    mat2 ma = rotm(radians(45.0 + angle));\n\n    ratio.r = halftone_dist(fragCoord, mr).r;\n    ratio.g = halftone_dist(fragCoord, mg).g;\n    ratio.b = halftone_dist(fragCoord, mb).b;\n#else\n    ratio = halftone_dist(fragCoord, mb);\n#endif\n    \n    vec3 col = vec3(1.);\n    if (ratio.r > 1.0) col.r = 0.;\n    if (ratio.g > 1.0) col.g = 0.;\n    if (ratio.b > 1.0) col.b = 0.;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}