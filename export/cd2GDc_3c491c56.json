{"ver":"0.1","info":{"id":"cd2GDc","date":"1668257363","viewed":116,"name":"i accidentally a shader","username":"selwynsimsek","description":"trying things out","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["boop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MljSD1","filepath":"https://soundcloud.com/rxaxrxe/spooktober2","previewfilepath":"https://soundcloud.com/rxaxrxe/spooktober2","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n\nfloat x(float t,float delta,float a, float b, float A, float B){\nreturn A*sin((a*t)+delta);\n}\nfloat y(float t,float delta,float a, float b, float A, float B){\nreturn B*sin(b*t);\n}\nfloat xd(float t,float delta,float a, float b, float A, float B){\nreturn A* a*cos((a*t)+delta);\n}\nfloat yd(float t,float a, float b, float A, float B){\nreturn B*b*cos(b*t);\n}\nfloat xdd(float t,float delta,float a, float b, float A, float B){\nreturn -1.0*A * a * a * sin((a*t)+delta);\n}\nfloat ydd(float t,float a, float b, float A, float B){\nreturn -1.0* B * b * b * sin(b*t);\n}\nfloat f(float t,float u,float v,float a, float b, float A, float B){\nfloat xd=xd(t,0.0,a,b,A,B);\nfloat yd=yd(t,a,b,A,B);\nfloat x=x(t,0.0,a,b,A,B);\nfloat y=y(t,0.0,a,b,A,B);\n\n   return (-2.0*xd*(u-x))+(-2.0*yd*(v-y));\n}\nfloat f_prime(float t,float u,float v,float a,float b,float A,float B){\nfloat x=x(t,0.0,a,b,A,B);\nfloat delta=0.0;\nfloat y=y(t,0.0,a,b,A,B);\nfloat xd = xd(t,0.0,a,b,A,B);\nfloat xdd = xdd(t,delta,a,b,A,B);\nfloat yd = yd(t,a,b,A,B);\nfloat ydd = ydd(t,a,b,A,B);\nreturn (-2.0*xdd*(u-x))+(2.0*xd*xd*(u-x))+(-2.0*ydd*(v-y))+(2.0*yd*yd*(v-y));\n}\n\nfloat newtonRaphson(float x_n,float u,float v,float a,float b,float A,float B){\n // Implements the Newton Raphson step \n return x_n - ((f(x_n,u,v,a,b,A,B)/f_prime(x_n,u,v,a,b,A,B)));\n}\n\nvec2 determine_t(float u, float v, float delta, float a,float b,float A,float B){\nfloat distToCurve_sq =5.0;\nfloat t_est=0.0;\n    for(int i=0;i<3000;i++){\n    //t_est=newtonRaphson(t_est,u,v);\n    //float trial_t=0.2;\n    //t_est=0.0;\n    float trial_t = 0.003*float(i);\n    //trial_t=newtonRaphson(trial_t,u,v);\n    float new_dist = ((u-x(trial_t,delta,a,b,A,B))*(u-x(trial_t,delta,a,b,A,B))) + ((v-y(trial_t,delta,a,b,A,B))*(v-y(trial_t,delta,a,b,A,B)));\n    if(new_dist<=distToCurve_sq){\n    t_est=trial_t;\n    distToCurve_sq=new_dist;\n    }\n    }\n    return vec2(distToCurve_sq,t_est);\n}\n\n//float determine_t_2(float u, float v,float delta){\n// Try to use Newton-Raphson to determine the SDF.\n//float trial_t=0.0;\n//for(int i=0;i<10;i++){\n//trial_t=newtonRaphson(trial_t,u,v);\n//}\n//return ((u-x(trial_t,delta))*(u-x(trial_t,delta))) + ((v-y(trial_t,delta))*(v-y(trial_t,delta)))//;\n\n//}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat wave = texture( iChannel0, vec2(0,0.75) ).x;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv-vec2(1,1);\n    uv.x*=(iResolution.x/iResolution.y);\n    uv=rotate2d(sin(3.1415*0.1*iTime)+wave)*uv;\n   \n    // second texture row is the sound wave\n uv=(wave*3.0)/(0.3+wave*3.0)*uv*3.0;\n    /// Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float t_est=0.5;\n    float u = uv.x;\n    float v = uv.y;\n    float a =5.0;\n    float b=4.0;\n    float A=1.0;\n    float B=1.0;\n    \n    vec2 res=determine_t(u,v,wave*PI,a,b,A,B);\n    float distToCurve_sq=res.x;\n    distToCurve_sq*=3.0;\n    float t=res.y;\n    //float distToCurve_sq = ((u-x(t_est))*(u-x(t_est))) + ((v-y(t_est))*(v-y(t_est)));\n    float distSq = uv.x*uv.x+uv.y*uv.y;\n    // Output to screen\n    //if(distToCurve_sq>=0.001)fragColor = vec4(vec3(0.0,0.0,0.0),1.0);\n    //else{    // create pixel coordinates\n    \n\t// first texture row is frequency data\n\tfloat fft  = texture( iChannel0, vec2(0,0.25) ).x; \n\t\n    // second texture row is the sound wave\n         wave = texture( iChannel0, vec2(1,0.75) ).x;\n\t\n\t// convert frequency to colors\n\t//vec3 col = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n    //vec3 col=vec3(wave,wave,wave);\n    // add wave form on top\t\n\t//col += 1.0 -  smoothstep( 0.0, 0.15, abs(wave - uv.y) \n    vec3 base_col=vec3(0.05,0.2,0.9);\n    vec3 end_col=vec3(0.9,0.1,0.1);\n    vec3 interp_col = (1.0-wave)*base_col + wave*end_col;\n\t\n    col = tanh(0.003/distToCurve_sq)*(0.5 + 0.5*(3.0*wave*+vec3(distToCurve_sq*t,(wave-1.0)*distToCurve_sq*t,wave)));\n    col=tanh(0.003/distToCurve_sq)*interp_col;\n\t// output final color\n\tfragColor = vec4(col,1.0);\n    //}\n}\n","name":"Image","description":"","type":"image"}]}