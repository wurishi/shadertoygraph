{"ver":"0.1","info":{"id":"WsyXWy","date":"1652883661","viewed":83,"name":"tooth surface simulate ","username":"yanglian","description":"利用x^4 +y^4+z^4 - x^2 - y^2 - z^2 = 0模拟一个数学表面","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mathsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 4\n#define AANUM 2\n#define step_x 0.001\n#define step_y 0.001\nvec3 directionCamera(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size /2.0;\n    float z = size.y /2.0 / tan(radians(fov/2.0));\n    return vec3(xy, z);//from - to\n}\nfloat sdf(vec3 p)\n{\n    p *=p;\n    vec3 pp = p;\n    vec3 pppp = pp * pp;\n    return pppp.x + pppp.y + pppp.z - pp.x - pp.y - pp.z;\n}\nvec3 nor(vec3 p)\n{\n    float epsilon = 0.0001;\n    return normalize(vec3(\n    (pow((p.x + epsilon), 4.0) + pow((p.y), 4.0) + pow((p.z), 4.0) - pow((p.x + epsilon), 2.0)\n        - pow((p.y), 2.0) - pow((p.z), 2.0)) / (2.0 * epsilon),\n     (pow((p.x), 4.0) + pow((p.y + epsilon), 4.0) + pow((p.z), 4.0) - pow((p.x), 2.0)\n        - pow((p.y + epsilon), 2.0) - pow((p.z), 2.0)) / (2.0 * epsilon),\n     (pow(p.x, 4.0) + pow(p.y, 4.0) + pow((p.z + epsilon), 4.0) - pow(p.x, 2.0)\n        - pow(p.y, 2.0) - pow((p.z + epsilon), 2.0)) / (2.0 * epsilon)\n    ));\n}\nvec3 shader(vec3 color_back, vec3 light_pos, vec3 eye, vec3 dir)\n{\n    vec3 col;\n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    vec3 color_ambient = vec3(0.0, 0.0, 0.8);\n    float delta = 0.05;\n    float abies = 0.01;\n    float dis = 0.0;\n    float dis_before = 2.0;\n    for(int i = 0; i < 300; ++ i)\n    {  \n        dis = sdf(eye + dir * delta);\n        if(abs(dis) < abies)\n            break;\n        if(dis * dis_before < 0.0)\n        {\n            //进行迭代\n            float delta2 = delta - 0.05;\n            float delta1 = delta;\n            for(int j = 0; j < 10; ++ j)\n            {\n                delta = (delta1 + delta2) / 2.0;\n                if(sdf(eye + dir * delta2) * sdf(eye + dir * delta) < 0.0)\n                {\n                    delta1 = delta;\n                }\n                else\n                {\n                    delta2 = delta;\n                }\n            }\n            break;\n        }\n        delta += 0.05;\n    }\n    //找到了该点，进行着色\n    if(delta > 300.0 * 0.05 - 0.1)\n        return color_back;\n    vec3 pos = eye + dir * delta;\n    vec3 normal_point = nor(pos);\n    vec3 am = color_ambient * (0.5 * max(dot(normal_point, normalize(light_pos - pos)), 0.0) + 0.5);\n    vec3 sp = light_color * pow(max(dot(reflect(normalize(light_pos - pos), normal_point), - dir), 0.0), 32.0);\n\tcol = am + sp;        \n    return col;\n}\nmat4 lookat(vec3 eye, vec3 to, vec3 up)\n{\n    vec3 totoEye = normalize(to - eye);\n    vec3 right = normalize(cross(totoEye, up));\n    vec3 up2 = normalize(cross(right, totoEye));\n    return mat4(\n\tvec4(right, 0.0),\n\tvec4(up2, 0.0),\n\tvec4(totoEye, 0.0),\n\tvec4(eye, 1.0)\n\t); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy + vec2(.5) - iResolution.xy)/min(iResolution.x, iResolution.y);\n    p = p * 2.0;\n    vec3 eye = vec3(5.0 *  sin(iTime * 2.0), 0.0, 5.0 * cos(iTime*2.0));\n    vec3 color_back = vec3(.5, .2, .2) * (1.0 - 0.1*length(p));\n    vec3 light_pos = vec3(-2.0, 1.0, 2.0);\n#if AA == 1\n    vec3 direction = directionCamera(45.0, iResolution.xy, fragCoord);\n    vec3 dir = normalize((lookat(eye, vec3(.0, .0, .0), vec3(.0, 1.0, .0)) * vec4(direction, .0)).xyz);\n    fragColor = vec4(shader(color_back, light_pos, eye, dir), 1.0);\n#else\n    vec3 color_sample = vec3(0.0, 0.0, 0.0);\n    for(int i = 0; i < AANUM; ++ i)\n    {\n        for(int j = 0; j < AANUM; ++ j)\n        {\n            vec2 sample_coord = vec2(fragCoord.x - step_x + float(i) * 2.0 * step_x / float(AANUM), \n                               fragCoord.y - step_y + float(j) * 2.0 * step_y / float(AANUM));\n            vec3 direction_aa = directionCamera(45.0, iResolution.xy, sample_coord);\n            vec3 dir_aa = normalize((lookat(eye, vec3(.0, .0, .0), vec3(.0, 1.0, .0)) * vec4(direction_aa, .0)).xyz);\n        \tcolor_sample += shader(color_back, light_pos, eye, dir_aa);\n        }\n    }\n    color_sample /= float(AA);\n    fragColor = vec4(color_sample, 1.0);\n#endif\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}