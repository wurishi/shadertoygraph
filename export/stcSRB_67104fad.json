{"ver":"0.1","info":{"id":"stcSRB","date":"1639316022","viewed":903,"name":"[TDF2021] Butterflies in the Sky","username":"Kamoshika","description":"25 minutes live coding @Tokyo Demo Fest 2021 Shader Showdown Final\n\nTokyo Demo Fest 2021\nhttps://tokyodemofest.jp/","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["cloud","livecoding","butterflies","butterfly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Watch the recording of the live coding on YouTube.\n// https://youtu.be/bp37xTVNRrM?t=16035\n\n// Added spaces, comments, etc. to the code.\n\n#define time iTime\n#define hash(x) fract(sin(x) * 1763.2632)\n#define saturate(x) clamp(x, 0., 1.)\nconst float pi = acos(-1.);\nconst float pi2 = acos(-1.) * 2.;\nconst float N = 50.; // Number of butterflies.\n\n// Rotation matrix in two dimensions.\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat rt = 1e5; // Length of ray to butterfly's wings (result).\nvec3 rn; // Normal vector (result).\nfloat rid; // Butterfly ID (result).\nvec2 ruv; // UV coordinates of wings (result).\n// Perform raycasting (intersection detection) to butterfly's wings (planes).\nvoid intersect(vec3 ro, vec3 rd, vec3 ce, mat2 M, float id, float s) {\n    // Right wing rotates in the opposite direction of the left wing, so we change the matrix.\n    // Note that sin(-x) equals -sin(x), and cos(-x) equals cos(x).\n    M[0][1] *= s;\n    M[1][0] *= s;\n    \n    vec3 n = vec3(vec2(0, 1) * M, 0); // Normal vector.\n    float t = dot(ce - ro, n) / dot(rd, n); // Length of ray to plane (wing).\n    if(t < 0. || t > rt) return; // The wing is behind the camera, or farther than wings so far.\n    vec3 q = ro + t * rd - ce; // Local coordinates of ray tip.\n    q.yx *= M; // Rotate the coordinates backwards to get UV coordinates.\n    if(q.x * s < 0.) return; // Remove unwanted wings.\n    \n    // Erase all parts of the plane except the butterfly's wings.\n    vec2 p = q.xz;\n    p.x = abs(p.x) * 0.8;\n    if(p.x > sin(p.y * 50.) * 0.025 + 0.4 + p.y * 0.4) return;\n    if(p.y < 0.) p *= 1.5;\n    p.y = abs(p.y);\n    if(length(p) > sin(atan(p.y, p.x) * 2.) + smoothstep(0.1, 0., p.y) * 0.3) return;\n    \n    // For the back side of the wing, reverse the normal vector.\n    if(dot(rd, n) > 0.) n *= -1.;\n    \n    // Update results because the wing is closer to camera than wings so far.\n    // Note that there are some \"return;\" processes above here.\n    rt = t;\n    rn = n;\n    rid = id;\n    ruv = q.xz;\n}\n\n// HSV to RGB function.\nvec3 hsv(float h, float s, float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.) * 6. - 3.;\n    res = saturate(abs(res) - 1.);\n    res = (res - 1.) * s + 1.;\n    res *= v;\n    return res;\n}\n\n// 3D value noise function.\n// reference:\n// https://www.shadertoy.com/view/4ttGDH\nfloat n3d(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 b = vec3(13, 193, 9);\n    vec4 h = vec4(0, b.yz, b.y + b.z) + dot(i, b);\n    f = f * f * (3. - 2. * f);\n    h = mix(hash(h), hash(h + b.x), f.x);\n    h.xy = mix(h.xz, h.yw, f.y);\n    return mix(h.x, h.y, f.z);\n}\n\n// fBm noise function.\nfloat fbm(vec3 p) {\n    float ac = 0., a = 1.;\n    for(int i = 0; i < 5; i++) {\n        ac += n3d(p * a) / a;\n        a *= 2.;\n    }\n    return ac - 0.5;\n}\n\n// Cloud density.\n// range [0.0, 1.0]\nfloat density(vec3 p) {\n    return saturate(fbm(p * 0.5) - p.y * 0.03 - 0.7);\n}\n\n// Square wave for camera movement.\n#define odd(x) step(1., mod(x, 2.))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalization of coordinates.\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    \n    vec3 col = vec3(0); // Color.\n    \n    float cam = odd(time * 0.2); // Variable for camera switching.\n    float L = 4. + odd(time * 0.4 - 1.) * 4.; // Camera distance from z-axis.\n    vec3 ro = vec3(0, 0, time); // Ray origin (Camera position).\n    ro.xy = mix(vec2(0, L), vec2(L * 0.5, 0), cam); // Switch ray origin.\n    vec3 rd = normalize(vec3(uv, -2)); // Ray direction.\n    rd = mix(vec3(-rd.x, rd.z, rd.y), vec3(rd.z, rd.y, -rd.x), cam); // Switch ray direction.\n    //rd = vec3(-rd.x, rd.z, rd.y);\n    \n    // Prepare to draw butterflies (Raycasting to 2N wings (planes)).\n    // (Find the butterfly ID, etc. of the wing closest to the camera.)\n    for(float i = 0.; i < N; i++) {\n        float T = i / N + time * 0.1;\n        float id = i / N + floor(T); // Butterfly ID.\n        vec3 ce = vec3(0, 0, ro.z + fract(T) * 14. - 7.); // Coordinates of butterfly center.\n        mat2 M = rot(sin(T * 50. + hash(id) * pi2)); // Rotation matrix.\n        \n        // Randomly move butterflies.\n        ce.xy += hash(vec2(1.1, 1.2) * id) * 6. - 3.;\n        ce.xy += sin(vec2(5, 7) * time * 0.2 + hash(id * 1.3) * pi2);\n        \n        intersect(ro, rd, ce, M, id, 1.); // Left wing.\n        intersect(ro, rd, ce, M, id, -1.); // Right wing.\n    }\n    \n    /* vec2 p = uv;\n    p.x = abs(p.x) * 0.8;\n    if(p.x > sin(p.y * 50.) * 0.025 + 0.4 + p.y * 0.4) return;\n    if(p.y < 0.) p *= 1.5;\n    p.y = abs(p.y);\n    if(length(p) > sin(atan(p.y, p.x) * 2.) + smoothstep(0.1, 0., p.y) * 0.3) return; */\n    \n    vec3 ld = normalize(vec3(-5, 2, -2)); // Light direction.\n    \n    if(rt < 100.) { // Ray hit a butterfly.\n        float h = hash(rid);\n        ruv.x = abs(ruv.x); // Make the pattern symmetrical.\n        float w = fbm(vec3(ruv, hash(rid * 1.2) * 500.)); // Variable for domain warping.\n        h += fbm(vec3(ruv + w * 5., hash(rid * 1.1) * 500.)) * 0.3; // Add some domain warping.\n        col += hsv(h, 0.8, fract(h * 5. + hash(rid * 1.3))); // Pattern of wings.\n        col *= smoothstep(-1., -0.93, sin(atan(ruv.y, ruv.x) * 40.)); // Black lines.\n        rn.x += fbm(vec3(ruv * 10., hash(rid * 1.3) * 500.)); // Add some noise to normal vector.\n        rn = normalize(rn);\n        float diff = max(dot(ld, rn), 0.); // Diffuse.\n        float spec = pow(max(dot(reflect(ld, rn), rd), 0.), 20.); // Specular.\n        float m = 0.6; // Metalness.\n        float lp = 5.; // Light power.\n        \n        col *= diff * (1. - m) * lp + spec * m * lp + 0.3;\n    } else { // Ray didn't hit a butterfly.\n        col += vec3(0.5, 0.6, 0.9) * 0.1; // Sky.\n        col = mix(col, vec3(1), pow(max(dot(ld, rd), 0.), 100.) * 2.); // Sun.\n    }\n    \n    // Draw Cloud (Volume raymarching).\n    // Note that we need to draw only the clouds that exist in front of the butterflies.\n    vec3 rp = ro; // Ray position.\n    float tra = 1.; // Transparency.\n    float rs = 1.; // Ray step.\n    float t = 0.; // Ray length.\n    float den; // Cloud density.\n    float ac = 0.; // Accumulation of cloud color.\n    for(int i = 0; i < 20; i++) {\n        if(t > rt) break; // Stop when the ray reaches a butterfly's wing.\n        den = density(rp + t * rd);\n        ac += tra * den;\n        tra *= 1. - den;\n        if(tra < 0.001) break;\n        t += rs;\n    }\n    col += ac;\n    \n    // Gamma correction.\n    col = pow(col, vec3(1. / 2.2));\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}