{"ver":"0.1","info":{"id":"llyBRy","date":"1542917952","viewed":526,"name":"Raymarching Example - Jamie","username":"Jamie_Pendergast","description":"Comment-based tutorial","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// the more, the better defined the shape is\n#define Marches 1000\n\n// a small number\n#define Epsilon 0.001\n\nfloat animate(float speed)\n{\n    return speed * iTime / 10.;\n}\n\nvec2 sceneDistanceFunction(vec3 point)\n{\n    return vec2(length(point) - 1., cos(point.y * 10.));\n}\n\n\n// uses the ray direction to compute sky color\nvec3 sky(vec3 rd)\n{\n    return vec3(rd.z);\n}\n\nvec3 estimateNormal(vec3 point)\n{\n    vec3 epsilon = vec3(Epsilon,0.0,0.0);\n    return normalize(vec3(\n        \n        // use the scene distance function\n        // to estimate the normal by \n        // using the distance at the point\n        // offset by a small value (epsilon)\n    \tsceneDistanceFunction(point - epsilon).x - sceneDistanceFunction(point + epsilon).x,\n        sceneDistanceFunction(point - epsilon.yxy).x - sceneDistanceFunction(point + epsilon.yxy).x,\n        sceneDistanceFunction(point - epsilon.yyx).x - sceneDistanceFunction(point + epsilon.yyx).x\n    ));\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec2 dist = vec2(0.);\n    vec3 point = ro;\n    \n   \tfor(int march = 0; march < Marches; ++march)\n    {\n        \n        // if the distance is greater than some big value,\n        // we return the sky color.\n        \n        vec2 sampling = sceneDistanceFunction(point);\n        if(sampling.x > 100.) return sky(rd);\n        dist.x += sampling.x;\n       \n        \n        dist.y = sampling.y;\n        \n        // update 'point' based on the distance\n        point = ro + rd * dist.x;\n    }\n    \n    vec3 light = normalize(vec3(0.5,0.5,1.));\n    vec3 normal = estimateNormal(point);\n    \n    // standard lighting method\n    float lambert = max(dot(light,normal),0.25);\n    \n    vec3 base = vec3(sin(dist.y * 2.), sin(dist.y * 6.), sin(dist.y * 12.));\n    return base * lambert;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    \n    // correct the aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n    // a little bit from the origin\t\n    vec3 ro = vec3(0.,0.,-2.);\n    \n    // ray direction is the uv and a bit forward\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    vec3 color = render(ro,rd);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}