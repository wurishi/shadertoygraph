{"ver":"0.1","info":{"id":"NlcSRl","date":"1639542277","viewed":191,"name":"Non-primitive Bravais Transition","username":"crowemagnon","description":"An animated non-primitive bravais lattice showing a transition from a square to a hexagon","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["nonprimitivebravaislattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PERIOD 16.\n\n// Line function taken from our lord and savior IQ\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdLine( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/(dot(ba,ba)),0.0, 1.0);\n    return pa-ba*h;\n}\nfloat sdLineLength( in vec2 p, in vec2 a, in vec2 b)\n{\n    return length(sdLine(p,a,b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    float pi_time = iTime*2.*PI/10.0;\n\n\n    // This turns our square lattice to a hexagonal lattice\n    float x0 =  0.25 + 0.25/2. + 0.5*0.2499*max(-1., min(1., 3.0*sin(4.*pi_time)));\n    // float x1 = 0.75 - 0.2499*sin(4.*pi_time);\n    float x1 = 1.0 - x0;\n\n    /* If I were going strictly bravais motivated here, only x0 would be necessary.\n     * \"i\"  -> \"invariant\" to say these points are static, not parametized\n     * The idea here is to take the rhombus lattice (a bravais lattice) and turn it \n     * to a hexagonal lattice (non bravais)\n     */ \n    vec2 r0 = vec2(x0, 0.5);\n    vec2 r0_i = vec2(0.0, 0.5);\n    vec2 r1 = vec2(x1, 0.0);\n    vec2 r1_i = vec2(1.0, 0.0);\n    vec2 r2 = vec2(x1, 1.0);\n    vec2 r2_i = vec2(1.0, 1.0);\n\n    // Capture frag coord into convenient UV variable, transform!\n    float zoom = (1.0 - 0.07*pow(sin(pi_time), 2.));\n    float aspect = iResolution.x/iResolution.y;\n    vec2 drift = vec2(iTime*0.0001, 0.1*sin(pi_time));\n    vec2 uv = zoom\n        *PERIOD*(fragCoord.xy/iResolution.xy - 0.5 + drift);\n\n    uv.x*=aspect;\n\n    // Index and fract feed into each other - index is used to know if this is odd or even\n    // and whether the cell should be offset or not\n    // First, find out if we should be offset or not\n    vec2 indexUVProto = floor(uv);\n    vec2 columnOffset = + vec2(0., mod(indexUVProto,2.0)/2.0);\n\n    vec2 indexUV = floor(uv + columnOffset);\n    vec2 fractUV = fract(uv + columnOffset); \n\n\n    // Correct indexUV accounting for which cell we're in. By far the most finicky part\n    // first calclute shortest vector to line\n    // \"bottom\" line\n    vec2 sd_1 = sdLine(fractUV , r0, r1);\n    // \"top\" line\n    vec2 sd_2 = sdLine(fractUV , r0, r2);\n\n\n    /* Make some \"debug colors\" so that we can see which area we're tageting\n     */\n\n    // black out the area we want to target\n    float sd_1_debug_intensity = 1.0 - max(\n        // First line, give angled section\n        0.5 + 0.5*sign(sd_1.x),\n        // Sign of sd_2, gives halfway point\n        0.5 + 0.5*sign(sd_2.y)\n    );\n    vec3 sd_1_debug_color = vec3(\n        sd_1_debug_intensity\n    );\n\n    // black out the area we want to target\n    float sd_2_debug_intensity = 1.0 - max(\n        // First line, give angled section\n        0.5 + 0.5*sign(sd_2.x),\n        // Sign of sd_2, gives halfway point\n        0.5 + 0.5*sign(-sd_1.y)\n    );\n    vec3 sd_2_debug_color = vec3(\n        sd_2_debug_intensity\n    );\n\n    // Reduce index by one if we're \"to the left\"\n    indexUV.x -= max(sd_1_debug_intensity, sd_2_debug_intensity);\n    // Up in y if we're \"to the left above\"\n    indexUV.y += sd_2_debug_intensity * (0.5 - 0.5*sign(columnOffset.y - 0.25));\n    // Down in y if we're \"to the left below\"\n    indexUV.y -= sd_1_debug_intensity * (0.5 + 0.5*sign(columnOffset.y - 0.25));\n\n    /* We draw the cell walls with the shortest distance function of the point\n     * to the line which is finally put into the smoothstep function\n     */\n\n    // 2 angled lines\n    float intensity = min(sdLineLength(fractUV, r0, r1) ,sdLineLength(fractUV, r0, r2));\n    // First, middle horizontal line\n    intensity = min(intensity, sdLineLength(fractUV, r0_i, r0));\n    // Botom hirozontal line\n    intensity = min(intensity, sdLineLength(fractUV, r1_i, r1));\n    // Top hirozontal line\n    intensity = min(intensity, sdLineLength(fractUV, r2_i, r2));\n\n\n    float edge = 0.0;\n    float margin = 0.045*zoom; \n\n    // Turn distance field to line\n    intensity = 1.0 - smoothstep(\n        edge + margin,\n        edge + 0.0,\n        intensity\n    );\n\n\n    vec3 cell_color = vec3(\n        0.5 + 0.5*sin(indexUV.y + 2.*pi_time)*sin(indexUV.y + 6.*pi_time),\n        0.5 + 0.5*cos(indexUV.y/2. + 2.*pi_time),\n        1.0\n    );\n\n    vec3 color_mix = mix(\n        vec3(0.), \n        cell_color, \n        intensity\n    );\n\n    fragColor = vec4(color_mix, 1.0);\n}","name":"Image","description":"","type":"image"}]}