{"ver":"0.1","info":{"id":"cslGRS","date":"1666389894","viewed":193,"name":"PixelSpirit Playground","username":"dgobera","description":"Learning through @patriciogv’s PixelSpirit cards.\nhttp://pixelspiritdeck.com/\n\nWork in progress, will probably take me a few weeks… to even get through the basic set.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Functions for individual cards\n\nvoid card0Void(inout vec3 col, in vec2 uv) {\n    col = vec3(0.);\n}\n\nvoid card1Justice(inout vec3 col, in vec2 uv) {\n    col = vec3(step(0.5, uv.x));\n}\n\nvoid card2Strength(inout vec3 col, in vec2 uv) {\n    float curvyX = 0.5 + sin(uv.y * TWO_PI) * 0.075;\n    col = vec3(smoothstep(curvyX, curvyX + AA, uv.x));\n}\n\nvoid card3Death(inout vec3 col, in vec2 uv) {\n    col = vec3(step(0.5, uv.x/2.+uv.y/2.));\n}\n\nvoid card4TheWall(inout vec3 col, in vec2 uv) {\n    float width = 0.05;    \n    float mask = stroke(uv.x, 0.5, width);\n    \n    col = vec3(mask);\n}\n\nvoid card5Temperance(inout vec3 col, in vec2 uv) {\n    float width = 0.03;\n   \n    float curveShift = sin(uv.y * TWO_PI - iTime) * 0.06;\n    \n    // three curvy vertical lines\n    float mask = 0.;\n    float centerX = 0.5;\n    mask = max(mask, stroke(uv.x, centerX + curveShift, width, AA));\n    \n    centerX = 0.5 - (width * 3.);\n    mask = max(mask, stroke(uv.x, centerX + curveShift, width, AA));\n\n    centerX = 0.5 + (width * 3.);\n    mask = max(mask, stroke(uv.x, centerX + curveShift, width, AA));\n    \n    col = vec3(mask);\n}\n\nvoid card6Branch(inout vec3 col, in vec2 uv) {\n    float width = 0.1;\n    float diagonal = uv.x + (1. - uv.y);\n    float mask = step(1. - (width / 2.), diagonal);\n    mask = min(mask, 1. - step(1. + (width / 2.), diagonal));\n  \n    col = vec3(mask);\n}\n\nvoid card7HangedMan(inout vec3 col, in vec2 uv) {\n    float width = 0.1;\n    float diagonalDownUp = uv.y;\n    float mask = stroke(uv.x, diagonalDownUp, width);\n    \n    float diagonalUpDown = 1. - uv.y;\n    mask = max(mask, stroke(uv.x, diagonalUpDown, width));\n    \n    col = vec3(mask);\n}\n\nvoid card8HighPriestess(inout vec3 col, in vec2 uv) {\n    float width = 0.05;\n    float radius = 0.5;\n    vec2 center = vec2(0.5, 0.5);\n    float mask = 0.;\n    \n    // initial solution: draw a circle, subtract a smaller one\n    {\n        float dToCenter = distance(uv, center);\n        mask = step(radius - (width / 2.), dToCenter);\n        mask = min(mask, 1. - step(radius + (width / 2.), dToCenter));\n    }\n    \n    // from the card: stroke based on the distance to center\n    {\n        float sdf = circleSDF(uv);\n        mask = stroke(sdf, radius, width, AA);\n    }\n    \n    col = vec3(mask);\n}\n\n\nvoid card9Moon(inout vec3 col, in vec2 uv) {\n    float radiusL = 0.3;\n    float radiusS = 0.23;\n    float mask = 0.;\n    \n    // initial solution: draw a circle, subtract a smaller one\n    {\n        vec2 centerL = vec2(0.5, 0.5);\n        vec2 centerS = vec2(0.6, 0.57);\n        mask = 1. - step(radiusL, distance(uv, centerL));\n        mask -= 1. - step(radiusS, distance(uv, centerS));\n    }\n    \n    // from the card: use a helper fill function\n    {\n        float sdfMain = circleSDF(uv);\n        mask = fill(sdfMain, radiusL * 2., AA);\n        \n        vec2 holeOffset = vec2(0.1, 0.05);\n        float sdfHole = circleSDF(uv - holeOffset);\n        mask -= fill(sdfHole, radiusS * 2., AA);\n        \n    }\n    \n    col = vec3(mask);\n}\n\nvoid card10Emperor(inout vec3 col, in vec2 uv) {\n\n    float sideSmall = 0.1;\n    float sideLarge = 0.5;\n    float strokeWidth = 0.1;\n    float center = 0.5;\n    float mask = 0.;\n    \n    // initial solution: draw a square, intersecting two thick lines\n    {\n        float holeSize = sideLarge - strokeWidth;\n        float largeSq = stroke(uv.y, center, sideLarge);\n        largeSq = min(largeSq, stroke(uv.x, center, sideLarge));\n\n        // subtract a smaller square, leaving just the outline\n        float hole = stroke(uv.y, center, holeSize);\n        hole = min(hole, stroke(uv.x, center, holeSize));\n        largeSq -= hole;\n\n        // finally add a small square inside\n        float smallSq = stroke(uv.y, center, sideSmall);\n        smallSq = min(smallSq, stroke(uv.x, center, sideSmall));\n        mask = max(largeSq, smallSq);\n    }\n    \n    // from the card: generate an SDF for the square, then stroke and fill different regions\n    {\n        float sdf = rectSDF(uv, vec2(1.));\n        mask = stroke(sdf, sideLarge, strokeWidth);\n        mask = max(mask, fill(sdf, sideSmall));\n    }\n    \n    col = vec3(mask);\n}\n\n\nvoid card11Hierophant(inout vec3 col, in vec2 uv) {    \n    \n    // sdf's for a rect and a cross, both at the center\n    float sdRect = rectSDF(uv, vec2(1.0));\n    float sdCross = crossSDF(uv, 1.);\n\n    // fill a rect, from which we'll erase cross-shaped portions\n    float mask = fill(sdRect, 0.5);\n\n    // erase the center area in a cross shape, leaving 4 squares in the corners\n    mask = min(mask, step(1., sdCross));\n    \n    // make a pattern of repeating crosses growing outwards\n    // multiply by 4 to make it 4 times smaller\n    float repeatingCross = fract(sdCross * 4.);\n\n    // subtract this pattern from the squares\n    mask = min(mask, step(0.5, repeatingCross));\n    \n    // draw the cross in the middle\n    mask = max(mask, fill(sdCross, 0.5));    \n\n    // final two outer rects\n    mask = max(mask, stroke(sdRect, 0.75, 0.025, AA));\n    mask = max(mask, stroke(sdRect, 0.65, 0.05, AA));\n\n    col = vec3(mask);\n}\n\nvoid card12Tower(inout vec3 col, in vec2 uv) {\n    float mask = 0.;\n    const float width = 0.01;\n    \n    // filled rect\n    float sdRect = rectSDF(uv, vec2(0.5, 1.));\n    float rectMask = fill(sdRect, 0.6);\n    \n    // first attempt: draw rect minus diagonal, then diagonal minus rect\n    {\n        // diagonal line\n        float diagonal = uv.x + uv.y;\n        float diagonalMask = step(1. - (width / 2.), diagonal);\n        diagonalMask = min(diagonalMask, 1. - step(1. + (width / 2.), diagonal));\n\n\n        // subtract the diagonal\n        mask = diagonalMask + (-1. * rectMask);\n        mask = max(mask, rectMask + (-1. * diagonalMask));\n    }\n    \n    // from card: use a flip function\n    {\n        float diagonal = (uv.x + uv.y) * 0.5;\n        float diagMask = stroke(diagonal, 0.5, width);\n        mask = diagMask;\n        mask = invert(rectMask, diagMask);\n    }\n    \n    col = vec3(mask);\n}\n\nvoid card13Merge(inout vec3 col, in vec2 uv) {\n\n    const float radius = 0.5;\n    const float width = 0.05;\n    \n    float sdCircle1 = circleSDF(vec2(uv.x + 0.15, uv.y));\n    float sdCircle2 = circleSDF(vec2(uv.x - 0.15, uv.y));\n    \n    float circle1 = stroke(sdCircle1, radius, width, AA);\n    float circle2 = fill(sdCircle2, radius, AA);\n    \n    float mask = invert(circle1, circle2);;\n    col = vec3(mask);\n}\n\nvoid card14Hope(inout vec3 col, in vec2 uv) {\n    \n    // draw a vesica (two intersected shifted circles)\n    float vsdf = vesicaSDF(uv, 0.15);\n    float mask = fill(vsdf, 0.5, AA);\n    \n    // flip colors where a diagonal area intersects\n    float sdDiagonal = diagonalSDF(uv);\n    \n    mask = invert(mask, fill(sdDiagonal, 0.5, AA));\n    \n    col = vec3(mask);\n}\n\n\nvoid card15Temple(inout vec3 col, in vec2 uv) {\n    \n    const float largeSize = 0.5;\n    const float smallSize = largeSize / 2.;\n    \n    // inverted triangle\n    vec2 uv1 = vec2(uv.x, 1. - uv.y);\n    float sdTri1 = triangleSDF(uv1);\n    float tri1 = fill(sdTri1, largeSize, AA);\n    \n    // negative smaller triangle, shifted upwards\n    vec2 uv2 = vec2(uv.x, uv.y - (smallSize / 2.));\n    float sdTri2 = triangleSDF(uv2);\n    float tri2 = fill(sdTri2, smallSize, AA);\n    \n    // make the small triangle invert the large one\n    float mask = invert(tri1, tri2);\n    \n    col = vec3(mask);\n}\n\nvoid card16Summit(inout vec3 col, in vec2 uv) {\n\n    const float vShift = 0.1;\n    const float triBorderWidth = 0.1;\n    const float shapeSize = vShift * 4.;\n\n    // circle \n    vec2 uv1 = vec2(uv.x, uv.y - vShift);\n    float sdCircle = circleSDF(uv1);\n    float ring = stroke(sdCircle, shapeSize, 0.07, AA);\n\n    // triangle\n    vec2 uv2 = vec2(uv.x, uv.y + vShift);\n    float sdTri = triangleSDF(uv2);\n    float triangle = fill(sdTri, shapeSize, AA);\n\n    // triangle border, negative\n    float negativeTri = fill(sdTri, shapeSize + triBorderWidth, AA);\n    negativeTri = 1. - negativeTri;\n    \n    // intersect ring with negative triangle for border\n    float mask = min(ring, negativeTri);\n    \n    mask = max(mask, triangle);\n    \n    col = vec3(mask);\n}\n\nvoid card17Diamond(inout vec3 col, in vec2 uv) {\n\n    float sdRhom = rhombusSDF(uv);    \n    \n    float mask = fill(sdRhom, 0.4, AA);\n    mask = max(mask, stroke(sdRhom, 0.5, 0.05, AA));\n    mask = max(mask, stroke(sdRhom, 0.62, 0.03, AA));\n    \n    col = vec3(mask);\n}\n\nvoid card18Hermit(inout vec3 col, in vec2 uv) {\n\n    float sdTri = triangleSDF(uv);\n    float sdRhom = rhombusSDF(vec2(uv.x, uv.y));\n    \n    float tri = fill(sdTri, 0.5, AA);\n    float rhom = fill(sdRhom, 0.4, AA);\n    \n    float mask = invert(tri, rhom);\n    \n    col = vec3(mask);\n}\n\nvoid card19Intuition(inout vec3 col, in vec2 uv) {\n\n    // transform coordinates to rotate everything\n    vec2 coord = rotate(uv, sin(iTime));\n\n    // large main triangle\n    float sdTri1 = triangleSDF(coord);\n    \n    // short and wide triangle to subtract from the bottom\n    vec2 uv2 = coord;\n    uv2.y = coord.y + 0.2;\n    float sdTri2 = triangleSDF(uv2);\n    \n    // dividing them produces this result. not entirely sure why yet\n    float sdCombined = sdTri1 / sdTri2;    \n    float mask = fill(sdCombined, 0.5, AA);\n    \n    //mask = sdCombined;\n    \n    col = vec3(mask);\n}\n\nvoid card20Stone(inout vec3 col, in vec2 uv) {\n    \n    vec2 coord = rotate(uv, radians(45.));\n\n    \n    float sdSquare = rectSDF(coord, vec2(1.));\n    \n    \n    float mask = fill(sdSquare, 0.5);\n    mask *= 1. - stroke(coord.x, 0.5, 0.03, AA);\n    mask *= 1. - stroke(coord.y, 0.5, 0.03, AA);\n\n    col = vec3(mask);\n}\n\nvoid card21Mountain(inout vec3 col, in vec2 uv) {\n    \n    vec2 coord = rotate(uv, radians(45.));\n    \n    float sdSquare1 = rectSDF(coord, vec2(1.));\n    float sdSquare2 = rectSDF(coord + 0.2, vec2(1.));\n    float sdSquare3 = rectSDF(coord - 0.2, vec2(1.));\n    \n    float border = stroke(sdSquare1, 0.4, 0.1, AA);\n    \n    float mask;\n    mask = fill(sdSquare2, 0.3, AA);\n    mask = max(mask, fill(sdSquare3, 0.3, AA));\n    mask *= 1. - border;\n    mask = max(mask, fill(sdSquare1, 0.4, AA));\n    \n    col = vec3(mask);\n}\n\nvoid card22Shadow(inout vec3 col, in vec2 uv) {\n    \n    vec2 coord = uv;\n    coord.y += 0.05;\n    coord = rotate(coord, radians(45.));\n    float sdShadow = rectSDF(coord, vec2(1.));\n\n    vec2 coord2 = uv;\n    coord2.y -= 0.05;\n    coord2 = rotate(coord2, radians(45.));\n    float sdSquare = rectSDF(coord2, vec2(1.));\n\n    float mask;\n    mask = fill(sdShadow, 0.4, AA);\n    mask = max(mask, fill(sdSquare, 0.4, AA));\n    mask *= 1. - fill(sdSquare, 0.38, AA);\n    \n    col = vec3(mask);\n}\n\nvoid card23Opposite(inout vec3 col, in vec2 uv) {\n    \n    vec2 coord = uv;\n    coord.x += 0.08;\n    coord = rotate(coord, radians(45.));\n    \n    float sdSquare1 = rectSDF(coord, vec2(1.));\n    \n    vec2 coord2 = uv;\n    coord2.x -= 0.08;\n    coord2 = rotate(coord2, radians(45.));\n    \n    float sdSquare2 = rectSDF(coord2, vec2(1.));\n\n    float mask = fill(sdSquare1, 0.4, AA);\n    mask = invert(mask, fill(sdSquare2, 0.4, AA));\n    \n    col = vec3(mask);\n}\n\nvoid card24Oak(inout vec3 col, in vec2 uv) {\n\n    const float width = 0.04;\n    const float large = 0.4;\n\n    vec2 coord1 = rotate(uv, radians(45.));\n    float sq1 = rectSDF(coord1, vec2(1.));\n\n    const float sideHalfSq = pow(large / 2., 2.);\n    const float shift = sqrt(sideHalfSq * 2.) / 2.;\n    vec2 coord2 = vec2(uv.x, uv.y + shift);\n    coord2 = rotate(coord2, radians(45.));\n    float sq2 = rectSDF(coord2, vec2(1.));\n\n    // stroke the large square, and subtract the small one\n    float mask = 0.;\n    mask = max(mask, stroke(sq1, large, width, AA));\n    mask *= 1. - fill(sq2, 0.315);\n    \n    // stroke the small square, intersecting with the large one so it\n    // only draws the top triangle\n    float bottom = stroke(sq2, 0.325, width, AA);\n    bottom *= fill(sq1, large, AA);\n    mask = max(mask, bottom);\n    \n    // stroke the small square at a smaller size\n    float smallStroke = stroke(sq2, 0.2, width, AA);\n    mask = max(mask, smallStroke);\n    \n    col = vec3(mask);\n}\n\nvoid card25Ripples(inout vec3 col, in vec2 uv) {\n\n    const float lineWidth = 0.04;\n    const float sqSize = 0.3;\n    const float hShift = 0.08;\n\n    vec2 coord = rotate(uv, radians(45.));\n    coord += hShift * 2.;\n    float sq1 = rectSDF(coord, vec2(1.));\n    coord -= hShift;\n    float sq2 = rectSDF(coord, vec2(1.));\n    coord -= hShift;\n    float sq3 = rectSDF(coord, vec2(1.));\n    coord -= hShift;\n    float sq4 = rectSDF(coord, vec2(1.));\n\n    float mask = stroke(sq1, sqSize, lineWidth, AA);\n    mask = max(mask, stroke(sq2, sqSize, lineWidth, AA));\n    mask = max(mask, stroke(sq3, sqSize, lineWidth, AA));\n    mask = max(mask, stroke(sq4, sqSize, lineWidth, AA));\n    \n    col = vec3(mask);\n}\n\nvoid card26Empress(inout vec3 col, in vec2 uv) {\n\n    const float lineWidth = 0.1;\n    const float sizeOuter = 0.75;\n    float mask = 0.;\n    \n    float sdPenta = polySDF(uv, 5);\n    vec2 uvRotated = rotate(uv, radians(180.));\n    float sdPentaDown = polySDF(uvRotated, 5);\n    \n    // my initial solution:\n    {\n        float size = sizeOuter;\n        mask = fill(sdPenta, size, AA);\n\n        size -= lineWidth * 1.4;\n        mask *= 1. - stroke(sdPenta, size, lineWidth, AA);\n\n        size -= lineWidth * 1.3;\n        mask *= 1. - stroke(sdPentaDown, size, lineWidth, AA);\n\n        size -= lineWidth * 1.;\n        mask *= 1. - stroke(sdPenta, size, lineWidth, AA);\n\n        size -= lineWidth * 1.;\n        mask *= 1. - stroke(sdPentaDown, size, lineWidth, AA);\n\n        size -= lineWidth * 1.1;\n        mask *= 1. - stroke(sdPenta, size, lineWidth, AA);\n\n        size -= lineWidth * 1.1;\n        mask *= 1. - stroke(sdPentaDown, size, lineWidth, AA);\n    }\n    \n    // from the card\n    {\n        mask = fill(sdPenta, 0.75);\n        mask = min(mask, fill(fract(sdPenta * 5.), 0.5, AA));\n        \n        float down = fill(sdPentaDown, 0.6);\n        down = min(down, fill(fract(sdPentaDown * 5.), 0.45, AA));\n        \n        mask = mask * (1. - down);\n    }\n\n    col = vec3(mask);\n}\n\nvoid card27Bundle(inout vec3 col, in vec2 uv) {\n\n    const float lineWidth = 0.1;\n    \n    // generate the SDFs for the hexagons\n    // instead of rotating, just flip the coordinates\n    vec2 coord = uv.yx;\n    float hexaOut = hexSDF(coord);\n    \n    float hexaIn1 = polySDF(coord - vec2(0.11, 0.), 6);\n    float hexaIn2 = polySDF(coord - vec2(-0.06, -0.1), 6);\n    float hexaIn3 = polySDF(coord - vec2(-0.06, 0.1), 6);\n    \n    // draw the shapes\n    float mask = stroke(hexaOut, 0.6, lineWidth, AA);\n    mask = max(mask, fill(hexaIn1, 0.15, AA));\n    mask = max(mask, fill(hexaIn2, 0.15, AA));\n    mask = max(mask, fill(hexaIn3, 0.15, AA));\n    \n    col = vec3(mask);\n}\n\nvoid card28Devil(inout vec3 col, in vec2 uv) {\n\n    const float lineWidth = 0.05;\n\n    vec2 coord = rotate(uv, radians(180.));\n    float sdStar = starSDF(coord, 5, 0.1);\n    float sdCircle = circleSDF(uv);\n    \n    float mask = stroke(sdCircle, 0.8, lineWidth, AA);\n    mask *= 1. - fill(sdStar, 0.7, AA);\n    mask = max(mask, stroke(sdStar, 0.4, lineWidth * 2., AA));\n\n    col = vec3(mask);\n}\n\nvoid card29Sun(inout vec3 col, in vec2 uv) {\n\n    float sdStar = starSDF(uv, 16, 0.1);\n    float mask = fill(sdStar, 0.86, AA);\n\n    float lines = 0.;\n    for (int i = 0; i < 8; i++) {\n    \n        float angle = radians(45. * float(i));\n        vec2 triUV = rotate(uv, angle);\n        triUV.y -= 0.2;\n        float sdTri = polySDF(triUV, 3);\n\n        mask = max(mask, fill(sdTri, 0.2, AA));\n        lines = max(lines, stroke(sdTri, 0.2, 0.02, AA));\n    }\n    \n    mask *= 1. - lines;\n    \n    float sdCenter = polySDF(uv, 8);\n    mask *= 1. - stroke(sdCenter, 0.1, 0.03, AA);\n    \n    col = vec3(mask);\n}\n\nvoid card30Star(inout vec3 col, in vec2 uv) {\n\n    float sdStar1 = starSDF(uv.yx, 6, 0.1);\n    float sdStar2 = starSDF(uv, 6, 0.1);\n    float sdRays = raysSDF(uv, 8);\n\n    float mask = 0.;\n    \n    // rays in the background\n    mask = max(mask, stroke(sdRays, 0.5, 0.15, AA));\n    \n    // outer star and outlines\n    mask *= 1. - stroke(sdStar2, 0.75, 0.2, AA);\n    mask = max(mask, fill(sdStar2, 0.75, AA));\n    mask *= 1. - stroke(sdStar2, 0.65, 0.1, AA);\n\n    // inner star outline\n    mask *= 1. - stroke(sdStar1, 0.3, 0.07, AA);\n\n    col = vec3(mask);\n}\n\nvoid card31Judgement(inout vec3 col, in vec2 uv) {\n\n    float sdRays = raysSDF(uv, 28);\n    float sdRect = rectSDF(uv, vec2(0.3));\n\n    // horizon\n    float mask = 1. - step(0.5, uv.y);\n    \n    // rays\n    float raysMask = stroke(sdRays, 0.5, 0.15, AA);\n    mask = invert(mask, raysMask);\n    \n    // center square\n    mask *= 1. - fill(sdRect, 1., AA);\n    mask = max(mask, fill(sdRect, 0.8, AA));\n\n    col = vec3(mask);\n}\n\nvoid card32WheelOfFortune(inout vec3 col, in vec2 uv) {\n\n    float sdRays = raysSDF(uv, 8);\n    float sdOct = polySDF(uv, 8);\n\n    float mask = 0.;\n    \n    // rays\n    mask = max(mask, stroke(sdRays, 0.5, 0.18, AA));\n    mask *= fill(sdOct, 0.5, AA);\n    mask *= 1. - fill(sdOct, 0.25, AA);\n    \n    // inner and outer shape\n    mask = max(mask, stroke(sdOct, 0.19, 0.04, AA));\n    mask = max(mask, stroke(sdOct, 0.6, 0.1, AA));\n\n    col = vec3(mask);\n}\n\nvoid card33Vision(inout vec3 col, in vec2 uv) {\n\n    float vesSDFv = vesicaSDF(uv, 0.25);\n    float vesSDFh = vesicaSDF(uv.yx, 0.4);\n    float sdRays = raysSDF(uv, 50);\n    float sdCircle = circleSDF(vec2(uv.x, uv.y - 0.03));\n\n    float mask = fill(sdRays, 0.2, AA);\n    mask *= fill(vesSDFv, 0.8, AA);\n    \n    // eye outline\n    mask *= 1. - fill(vesSDFh, 0.67, AA);\n    mask = max(mask, stroke(vesSDFh, 0.67, 0.04, AA));\n\n    // inner eye\n    float iris = stroke(sdCircle, 0.25, 0.04, AA);\n    iris *= fill(vesSDFh, 0.67, AA);\n    mask = max(mask, iris);\n\n    col = vec3(mask);\n}\n\nvoid card34Lovers(inout vec3 col, in vec2 uv) {\n\n    float sdHeart = heartSDF(uv);\n\n    float mask = fill(sdHeart, 0.5, AA);\n    mask *= 1. - stroke(polySDF(uv, 3), 0.15, 0.05, AA);\n\n    col = vec3(mask);\n}\n\nvoid card35Magician(inout vec3 col, in vec2 uv) {\n\n    const float shift = 0.15;\n    const float width = 0.06;\n    const float radius = 0.4;\n    float mask = 0.;\n    \n    // initial solution: when drawing the cutouts, mask it so it only affects the top or bottom half\n    {\n    \n        float sdCircle1 = circleSDF(uv - vec2(shift, 0.));\n        float sdCircle2 = circleSDF(uv + vec2(shift, 0.));\n\n        float circle1 = stroke(sdCircle1, radius, width, AA);\n        float circle2Cutout = stroke(sdCircle2, radius, width * 2.2, AA);\n        circle2Cutout *= step(0.5, uv.y);\n        circle1 *= 1. - circle2Cutout;\n\n        float circle2 = stroke(sdCircle2, radius, width, AA);\n        float circle1Cutout = stroke(sdCircle1, radius, width * 2.2, AA);\n        circle1Cutout *= step(0.5, 1. - uv.y);\n        circle2 *= 1. - circle1Cutout;\n\n        mask = max(circle1, circle2);\n    }\n    \n    // card solution: use mirroring to split each circle in two slices\n    {\n        uv.x = invert(uv.x, step(0.5, uv.y));\n\n        float sdCircle1 = circleSDF(uv - vec2(shift, 0.));\n        float sdCircle2 = circleSDF(uv + vec2(shift, 0.));\n\n        mask = stroke(sdCircle1, 0.4, 0.075, AA);\n        mask = bridge(mask, sdCircle2, 0.4, 0.075, AA);\n    }\n\n    col = vec3(mask);\n}\n\nvoid card36Link(inout vec3 col, in vec2 uv) {\n\n    const float shift = 0.1;\n    const float size = 0.25;\n    const float width = 0.07;\n\n    vec2 coord1 = rotate(vec2(uv.x, uv.y - shift), radians(45.));\n    vec2 coord2 = rotate(vec2(uv.x, uv.y + shift), radians(45.));\n\n    float sdRect1 = rectSDF(coord1, vec2(1.));\n    float sdRect2 = rectSDF(coord2, vec2(1.));\n\n    float splitMask = step(0.5, uv.x);\n\n    // draw the top left normally, then bottom left as bridge\n    float leftSide = (1. - splitMask) * stroke(sdRect1, size, width, AA);\n    leftSide = (1. - splitMask) * bridge(leftSide, sdRect2, size, width, AA);\n    \n    // add the bottom left normally then top right as bridge\n    float rightSide = splitMask * stroke(sdRect2, size, width, AA);\n    rightSide = splitMask * bridge(rightSide, sdRect1, size, width, AA);\n    \n    // the two rhombus at the edges\n    float sdRhom1 = rhombusSDF(vec2(uv.x, uv.y - 0.4));\n    float sdRhom2 = rhombusSDF(vec2(uv.x, uv.y + 0.4));\n    float rhom = fill(sdRhom1, 0.1, AA);\n    rhom = max(rhom, fill(sdRhom2, 0.1, AA));\n    \n    // put it all together\n    float mask = max(leftSide, rightSide);\n    mask = max(mask, rhom);\n    \n    col = vec3(mask);\n}\n\nvoid card37HoldingTogether(inout vec3 col, in vec2 uv) {\n\n    const float shift = 0.123;\n\n    uv.x = mix(1. - uv.x, uv.x, step(0.5, uv.y));\n\n    vec2 coord1 = rotate(vec2(uv.x + shift, uv.y), radians(45.));\n    vec2 coord2 = rotate(vec2(uv.x - shift, uv.y), radians(45.));\n\n    float sdRect1 = rectSDF(coord1, vec2(1.));\n    float sdRect2 = rectSDF(coord2, vec2(1.));\n\n    float mask = stroke(sdRect1, .354, .242, AA);\n    mask = bridge(mask, sdRect2, 0.354, 0.242, AA);\n    \n    col = vec3(mask);\n}\n\nvoid card38Chariot(inout vec3 col, in vec2 uv) {\n    \n    const float size = 0.55;\n    const float width = 0.07;\n    \n    float maskV = step(0.7, uv.y);\n    maskV = max(maskV, step(0.7, 1. - uv.y));\n\n    float maskH = step(0.66, uv.x);\n    maskH = max(maskH, step(0.66, 1. - uv.x));\n\n    float sqSDF1 = rectSDF(uv, vec2(1.));\n    float sqSDF2 = rectSDF(rotate(uv, radians(45.)), vec2(1.));\n    \n    float square = stroke(sqSDF1, size, width, AA);\n    float rhom = stroke(sqSDF2, size, width, AA);\n\n    float mask = maskV * square;\n    mask = bridge(mask, sqSDF2, size, width, AA);    \n    float leftRight = maskH * (1. - maskV) * bridge(mask, sqSDF1, size, width, AA);\n    \n    mask = max(mask * maskV, leftRight);\n    col = vec3(mask);\n}\n\n\nconst float durationCard = 3.;\nconst int numCards = 39;\n\nvoid runCardAtIndex(int cardIndex, inout vec3 col, vec2 uv) {\n\n    // for testing, uncomment to freeze at a particular card\n    //cardIndex = 38;\n\n    switch(cardIndex) {\n        case 0:\n            card0Void(col, uv);\n            break;\n        case 1:\n            card1Justice(col, uv);\n            break;\n        case 2:\n            card2Strength(col, uv);\n            break;\n        case 3:\n            card3Death(col, uv);\n            break;\n        case 4:\n            card4TheWall(col, uv);\n            break;\n        case 5:\n            card5Temperance(col, uv);\n            break;\n        case 6:\n            card6Branch(col, uv);\n            break;\n        case 7:\n            card7HangedMan(col, uv);\n            break;\n        case 8:\n            card8HighPriestess(col, uv);\n            break;\n        case 9:\n            card9Moon(col, uv);\n            break;\n        case 10:\n            card10Emperor(col, uv);\n            break;\n        case 11:\n            card11Hierophant(col, uv);\n            break;\n        case 12:\n            card12Tower(col, uv);\n            break;\n        case 13:\n            card13Merge(col, uv);\n            break;\n        case 14:\n            card14Hope(col, uv);\n            break;\n        case 15:\n            card15Temple(col, uv);\n            break;\n        case 16:\n            card16Summit(col, uv);\n            break;\n        case 17:\n            card17Diamond(col, uv);\n            break;\n        case 18:\n            card18Hermit(col, uv);\n            break;\n        case 19:\n            card19Intuition(col, uv);\n            break;\n        case 20:\n            card20Stone(col, uv);\n            break;\n        case 21:\n            card21Mountain(col, uv);\n            break;\n        case 22:\n            card22Shadow(col, uv);\n            break;\n        case 23:\n            card23Opposite(col, uv);\n            break;\n        case 24:\n            card24Oak(col, uv);\n            break;\n        case 25:\n            card25Ripples(col, uv);\n            break;\n        case 26:\n            card26Empress(col, uv);\n            break;\n        case 27:\n            card27Bundle(col, uv);\n            break;\n        case 28:\n            card28Devil(col, uv);\n            break;\n        case 29:\n            card29Sun(col, uv);\n            break;\n        case 30:\n            card30Star(col, uv);\n            break;\n        case 31:\n            card31Judgement(col, uv);\n            break;\n        case 32:\n            card32WheelOfFortune(col, uv);\n            break;\n        case 33:\n            card33Vision(col, uv);\n            break;\n        case 34:\n            card34Lovers(col, uv);\n            break;\n        case 35:\n            card35Magician(col, uv);\n            break;\n        case 36:\n            card36Link(col, uv);\n            break;\n        case 37:\n            card37HoldingTogether(col, uv);\n            break;\n        case 38:\n            card38Chariot(col, uv);\n            break;\n    }\n\n}\n\n\nfloat progressAtTime(float time) {\n    // I worked this out step by step using https://graphtoy.com\n    float progress = (time + durationCard) / durationCard;\n    progress = floor(progress);\n    \n    // make the timing pattern repeat after numCards cycles\n    progress = fract(progress / float(numCards)) * float(numCards);\n    \n    // smooth crossfading between cards\n    progress = progress + smoothstep(durationCard - 1., durationCard, \n                            fract(time / durationCard) * durationCard);\n                            \n    return progress;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates 0-1 preserving aspect ratio, so might be >1 in one dimension\n    // shift it to ensure 0.5 is at the center\n    float resFactor = 1. / iResolution.y;\n    vec2 uv = fragCoord * resFactor;\n    uv.x -= (iResolution.x - iResolution.y) * resFactor / 2.;\n\n    // figure out which cards we should be showing, and how much of it\n    // use time to compute current card index, going up in steps according to duration\n    float progress = progressAtTime(iTime);\n    \n    // find the index of the current card and the next one\n    int cardIndex = int(floor(progress));\n    int nextCardIndex = cardIndex < (numCards - 1) ? cardIndex + 1 : 0;\n    float transitionProgress = progress - floor(progress);\n    \n    // draw the content of the two cards involved in the transition\n    vec3 col1 = vec3(0.);\n    vec3 col2 = vec3(0.);\n    runCardAtIndex(cardIndex, col1, uv);\n    runCardAtIndex(nextCardIndex, col2, uv);\n\n    vec3 col = mix(col1, col2, transitionProgress);\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define TWO_PI (2. * PI)\n\n// amount of anti-alias blur\n#define AA (1.5 / 576.0)\n\n\n// same as stroke(), but with anti-alias with 'aaBlur' strength\nfloat stroke(float pos, float center, float width, float aaBlur) {\n    float halfBlur = aaBlur / 2.;\n    float mask = smoothstep(center - halfBlur, center + halfBlur, pos + width / 2.);\n    mask = min(mask, 1. - smoothstep(center - halfBlur, center + halfBlur, pos - width / 2.));\n\n    return mask;\n}\n\n// returns 1 for 'pos' values within the 'width' range around 'center'\n// kind of a range version of step\nfloat stroke(float pos, float center, float width) {\n    return stroke(pos, center, width, 0.);\n}\n\n// returns 1 for 'pos' values smaller than (inside) 'size'\n// basically an inverted step\nfloat fill(float pos, float size, float aaBlur) {\n    float halfBlur = aaBlur / 2.;\n    return 1. - smoothstep(size - halfBlur, size + halfBlur, pos);\n}\n\nfloat fill(float pos, float size) {\n    return fill(pos, size, 0.);\n}\n\nfloat invert(float value, float percent) {\n    float inverted = 1. - value;\n    return mix(value, inverted, percent);\n}\n\nvec2 rotate(vec2 coord, float angleRad) {\n\n    mat2 rotMat = mat2(cos(angleRad), -sin(angleRad),\n                       sin(angleRad), cos(angleRad));\n    \n    vec2 rotated = coord - 0.5;\n    rotated = rotated * rotMat;\n    rotated += 0.5;\n    \n    return rotated;\n}\n\nfloat bridge(float col, float pos, float center, float width, float aaBlur) {\n    col *= 1. - stroke(pos, center, width * 2., aaBlur);\n    col = max(col, stroke(pos, center, width, aaBlur));\n    return col;\n}\n\n\n\n\n// ----- SDF of some shapes ----\n\nfloat circleSDF(vec2 uv) {\n    // distance to the origin\n    float df = length(uv - 0.5);\n    // multiply so it gets to 1 when the diameter is 1\n    df *= 2.;\n    return df;\n}\n\nfloat rectSDF(vec2 uv, vec2 size) {\n    // transform the space to shrink it and work on one half to be mirrored\n    // shift the origin to the center of the canvas\n    uv = uv * 2. - 1.;\n    \n    // horizontal and vertical field, with abs to mirror around the origin line\n    float horiz = abs(uv.y / size.y);\n    float vert = abs(uv.x / size.x);\n    \n    // add them, which leaves the rect intersection with < 1. and everything else >1\n    float df = max(horiz, vert);\n    \n    // the return value is a rect field, with <1 inside\n    return df;\n}\n\nfloat crossSDF(vec2 uv, float size) {\n    // union together two rects\n    vec2 qSize = vec2(0.25, size);\n    float sd = min(rectSDF(uv, qSize.xy), \n                   rectSDF(uv, qSize.yx));\n    return sd;\n}\n\nfloat vesicaSDF(vec2 uv, float shift) {\n    vec2 offset = vec2(shift * 0.5, 0.);\n    float sd = max(circleSDF(uv + offset),\n                   circleSDF(uv - offset));\n    return sd;\n}\n\nfloat diagonalSDF(vec2 uv) {\n    return (uv.x + uv.y) * 0.5;\n}\n\nfloat triangleSDF(vec2 uv) {\n    // transform the space so the triangle is in the center, 0-1\n    uv = (uv * 2. - 1.) * 2.;\n    \n    // adding x and y gives us a diagonal. abs-ing it mirrors it and gives us the top of the triangle\n    const float sharpness = 0.866025; // from the card. this I think produces a 60 deg angle\n    float sd = (abs(uv.x) * sharpness) + (uv.y * 0.5);\n    \n    // combine with a horizontal gradient to make the \"floor\"\n    sd = max(sd, -uv.y * 0.5);\n    \n    return sd;\n}\n\nfloat rhombusSDF(vec2 uv) {\n    // up-pointing triangle\n    float sdUp = triangleSDF(vec2(uv.x, uv.y));\n    \n    // combine with a down-pointing triangle, shifted down\n    float sdDown = triangleSDF(vec2(uv.x, 1. - uv.y));\n    \n    float sd = max(sdUp, sdDown);\n    \n    return sd;\n\n}\n\nfloat polySDF(vec2 uv, int sides) {\n    vec2 coord = uv * 2. - 1.;\n    \n    float a = atan(coord.x, coord.y) + PI;\n    float r = length(coord);\n    float v = TWO_PI / float(sides);\n    float sd = cos(floor(0.5 + a / v) * v - a) * r;\n    \n    return sd;\n}\n\nfloat hexSDF(vec2 uv) {\n    vec2 coord = abs(uv * 2. - 1.);\n    \n    float sd = coord.x * 0.866025 + coord.y * 0.5;\n    sd = max(abs(coord.y), sd);\n    return sd;\n\n}\n\nfloat starSDF(vec2 uv, int sides, float stretch) {\n    vec2 st = uv.yx * 4. - 2.;\n    \n    float a = atan(st.y, st.x) / TWO_PI;\n    float seg = a * float(sides);\n    a = (floor(seg) + 0.5) / float(sides);\n    a += mix(stretch, -stretch, step(0.5, fract(seg)));\n    a *= TWO_PI;\n    \n    float sd = abs(dot(vec2(cos(a), sin(a)), st));\n    \n    return sd;\n}\n\n\nfloat raysSDF(vec2 uv, int sides) {\n    vec2 coord = uv - 0.5;\n    float sd = atan(coord.y, coord.x) / TWO_PI * float(sides);\n    sd = fract(sd);\n    \n    return sd;\n}\n\nfloat heartSDF(vec2 uv) {\n    \n    vec2 uv2 = uv - vec2(0.5, 0.8);\n    float r = length(uv2) * 5.;\n    uv2 = normalize(uv2);\n    \n    float sd = (uv2.y * pow(abs(uv2.x), 0.67)) /\n               (uv2.y + 1.5) - 2. * uv2.y + 1.26;\n    sd = r - sd;\n    \n    return sd;\n}\n\n\n","name":"Common","description":"","type":"common"}]}