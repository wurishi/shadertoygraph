{"ver":"0.1","info":{"id":"ttXfWX","date":"1597871963","viewed":611,"name":"CAO","username":"JacobC","description":"Trying to generate fake AO with one pass of the ray marcher. I added the occlusion to show it, you can slide the bar with the cursor by clicking the canvas.","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","test","ao","bleeding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"CAO\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n// Set it to 1. if runs slow\n#define AA 2.\n// Set it to 1 to add color bleeding\n#define CB 0\n\n#define Pi 3.141592\n#define T iTime\n\nstruct mat\n{\n    float depth;\n    vec3 col;\n    vec3 bleed;\n    float ao;\n};\n    \nfloat torus(in vec3 p, in vec2 r)\n{\n   return length(vec2(length(p.xz) - r.x, p.y)) - r.y; \n}\n\nfloat cylinder( vec3 p, float r, float h, float s)\n{\n  return length(vec2(max(length(p.xz) - r + s, 0.), \n                     max(abs(p.y) - h, 0.))) - s;\n}\n\nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    // mapping distance\n    // like a point light caster from:\n    // http://wiki.ogre3d.org/tiki-index.php?page=-Point+Light+Attenuation\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat Uop(in mat a, in mat b)\n{\n    float s = max(a.depth, b.depth);\n    float ao = map(s, 1., 1.4, 7.2);\n    s = map(s, 1., .7, 1.8);\n    \n    return mat(\n        min(a.depth, b.depth),\n        a.depth < b.depth ? a.col : b.col,\n        a.bleed * mix(a.depth > b.depth ? a.col : b.col, vec3(1.), s), // Compute color bleeding\n        a.ao * ao // Computing AO\n    );\n}\n\n#define op0 vec3(0., -.3, -4.7)\n#define op1 vec3(-4.5, 1., -1.)\n#define op2 vec3(0., -101., 0.)\n#define op3 vec3(.0, 1., 0.)\n#define op4 vec3(0., .5, 4.3)\n\n#define oc0 vec3(3., 0., 1.5) / Pi\n#define oc1 vec3(1.5, 3., 0.) / Pi\n#define oc2 vec3(3.) / Pi\n#define oc3 vec3(3., 1.5, 0.) / Pi\n#define oc4 vec3(0., 1.5, 3.) / Pi\n\nmat scene(in vec3 p)\n{\n    vec3 q = p;\n    vec3 bl = vec3(1.);\n    q -= op0;\n    q.xz *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    q.xy *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    mat o0 = mat(torus(q, vec2(2., .8)), oc0, bl, 1.);\n    q = p;\n    q -= op1;\n    q.xz *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    mat o1 = mat(cube(q, vec3(2.), .5), oc1, bl, 1.);\n    mat o2 = mat(cube(p - op2, vec3(100.), .0), oc2, bl, 1.);\n    mat o3 = mat(torus(p - op3, vec2(0., 2.)), oc3, bl, 1.);\n    q = p;\n    q -= op4;\n    q.xy *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    mat o4 = mat(cylinder(q, 2., 2., max(sin(T) * 2., .2)), oc4, bl, 1.);\n    \n    \n    float k = 10.;\n    float l = 100.;\n    mat o = Uop(o0, o1);\n    o = Uop(o, o2);\n    o = Uop(o, o4);\n    o = Uop(o, o3);\n    \n    return o;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\n#define NUM_STEPS 255\n#define MIN_DIST .01\n#define MAX_DIST 64.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth;\n        if (s.depth < MIN_DIST)\n        \treturn mat(t, s.col, s.bleed, s.ao);\n        if (t > MAX_DIST)\n            break;\n    }\n    return mat(t, vec3(-1.), vec3(-1.), -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return u * p.x + v * p.y - w;\n}\n\n#define gd vec3(3.)\n#define sk vec3(1.5, 2.1, 3.)\n\n#define l0 vec3(0., 6., 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n    \t\t\n            vec2 uv = (st - n - iResolution.xy * .5) / iResolution.y;\n\t\t\tvec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            float xx = (iMouse.z > 0.) ? ms.x : sin(T) * .6;\n            \n            float sn = sin(ms.x);\n            \n            vec3 o = vec3(sin(Pi * T * .1) * 2., 1., cos(Pi * T * .1) * 2.) * 6.;\n            vec3 t = vec3(0., 0., 0.);\n            vec3 d = camera(uv, o, t);\n            \n            vec3 back = mix(gd, sk, d.y * .5 + .5);\n            vec3 col = vec3(0.);\n            \n            mat m = marcher(o, d);\n            \n            if (m.ao >= 0.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p);\n                \n                back = mix(gd, sk, n.y * .5 + .5) / Pi;\n                if (uv.x > xx) \n                {\n                    col += back;\n                \tcol *= m.col * m.ao * .5;\n                    #if CB\n                    col *= m.bleed;\n                    #endif\n                }\n                else\n                    col += m.ao;\n            }\n            else\n                col = back / Pi;\n            \n            float sz = 3. / iResolution.y;\n            col *= smoothstep(sz * .5, sz, abs(uv.x - xx));\n            \n            f_col += col;            \n        }\n    }\n    \n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col), 1.);\n}","name":"Image","description":"","type":"image"}]}