{"ver":"0.1","info":{"id":"wsXXDs","date":"1552563241","viewed":189,"name":"MusicFormatV0.00001","username":"znsoft333","description":"my old tracker test ,\ntry to use melody export .h and convert to glsl ","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["music","patterns","sequence","format","buzz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{float t = iTime;//+fragCoord.x;\n    \n    int s = getSeqPos(t);\nint p = getPatPos(t);\n\n    \n        \n    Instrument ins = createInstrument( 0, s, p);\n //* sin(float(ins.alldata[1]))\n    fragColor = sin(vec4(dot(fragCoord-iTime,fragCoord + iTime)* sin(float(ins.alldata[1]))  ));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define PI2 6.2831 \n#define char int\n#define ARRAY []=char[](\n#define bpm 100.0 \n#define instrNums 3\n#define trackLen 8\n#define tracks 1\n//every pattern is 16 bytes len\nchar patterns ARRAY 65,65,65,53,65,65,65,53,65,65,65,53,65,65,65,53,64,64,64,53,65,65,65,53,67,67,67,53,64,64,64,53,65,65,65,53,67,67,67,53,65,65,65,49,67,67,67,49,68,68,68,49,65,65,65,49,67,67,67,49,68,68,68,37,67,67,67,51,68,68,68,51,70,70,70,51,67,67,67,51,68,68,68,51,70,70,70,51,67,67,67,51,67,67,67,51,67,67,67,48,67,67,67,48,67,67,67,48,67,67,67,48,67,67,67,48,67,67,67,48,67,67,67,48,65,65,65,36);\nchar seqPat ARRAY 1,2,3,4,5,6,7,8,0);// here pattern sequence on tracks\nchar instr  ARRAY 1,-1,0,0,33,53,7,0,17,48,61,1,20,0,0,105, 0,-1,0,0,20,4,7,12,16,3,40,1,38,0,0,0, 4,-1,0,1,-1,-1,7,10,15,1,0,0,1,0,0,0);\n\n#define bps 4. * bpm  / 60.0\n// if value of field < 0 that mean get value for this field from track number abs()\nstruct Instrument{\n/*\t0  int osc; //0 - sin; 1 - fract ; sqr ; noice ; saw ; saw * saw ; saw * sin ; FM\n    1  int note;\n    2  int toNote;//note decay\n    3  int offset;//not use\n    4  int volume;\n    5  int len;/// not use \n    6  int attack; /// not use \n    7  int decay; /// \n    8  int sustain; /// not use \n    9  int phase;\n    10 int delay; /// \n    11 int echos;/// not use if 0\n    12 int fade;\n    13 int reso;\n    14 int resoLevel;/// not use if 0\n    15 int filter;/// not use\n*/\n    char[16] alldata;\n};\n    \n\n//get position in sequence of patterns\nint getSeqPos(float t){\n   // return int(floor(bps * t/16.0)); \nreturn (int(floor(bps * t ))/16)% trackLen;\n}    \n//get position of note in pattern\nint getPatPos(float t){\n    return int(floor(bps * t))%16;\n\n}  \n//get position in note\nfloat getNotePos(float t){\n    return fract(bps * t);\n}    \n//get value from channel/track\nchar getCurValue(int seqPos, int patPos, int track){\n\tchar patN = seqPat[(track-1)*tracks+seqPos];\n    if(patN==0)return 0;\n    patN--;\n\treturn patterns[patN*16+patPos];\n}\n  \n\n//calc note\nfloat ntof(float n)\n{\n\treturn 440.0 * pow(2.0, (n-127. ) / 12.0) * bps ;\n}\n   \n\nfloat FM(float t,float f,float p){\n\n    return sin(f*PI2*t+  // base freq\n                    (3.124+7.14*sin(t/PI2))\n                    *sin(p*f*PI2*t)// FM Modulation\n                   );\n\n}\n\nfloat tri(float t,float f, float p)\n{\n    return abs(fract(t * f - p) )*2.0-1.0;\n}\n\nfloat saw(float t,float f, float p)\n{\n\treturn fract(t * f + p) * 2.0 - 1.0;\n}\n\nfloat sqr(float t,float f, float p)\n{\n    return step(fract(t * f), p/31.)*2.0-1.0;\n}\n\nfloat sawmsaw(float t,float f, float p){\n\treturn (fract(t*(f-p))*fract(t*(f+p)))* 2.0 - 1.0;\n}\n\nfloat sinw(float t,float f, float p){\n\treturn sin( t*f*PI2+p/15.);\n}\n\nfloat noise(float t,float f, float p){\n\treturn fract(sin(t*f*PI2)*(p+1.5)*31.)*2.0-1.;\n}\n\nfloat decay2(float time,float len,float param){\n    return exp(param * time);\n\n}\n\nfloat zfilter(float h, float cut, float res,float time)\n{\n    h += fract(time * res);\n\treturn clamp(h * cut+h,-1.,1.);\n}\n\n\n\nfloat osc(int type,float time,float freq,float phase){\n    //0 - sin; 1 - fract ; sqr ; noice ; saw ; saw * saw ; saw * sin ; FM\n\tif(type == 0)return sinw(time, freq, phase);\n    if(type == 1)return tri(time, freq, phase);\n\tif(type == 2)return sqr(time, freq, phase);\n\tif(type == 3)return noise(time, freq, phase);\n    if(type == 4)return saw(time, freq, phase);\n\tif(type == 5)return sawmsaw(time, freq, phase);\n\tif(type == 6)return FM(time, freq, phase);\n\t\n    return 0.0;\n}\n\n\n\nfloat finstrument(float time,int type,float note,float offset,float phase,float decay,float notedecay,float cut,float res ){\n    float freq = ntof(note)+offset;\n    freq *= exp(notedecay * time);\n    float y = osc(type,time,freq,phase);\n\tif(cut!=.0&&res!=.0)\n        y = zfilter(y,cut, res,time);\n        y *= decay2(time,0.,decay);\n\treturn y;\n}\n\n\n/*\t0int osc; //0 - sin; 1 - fract ; sqr ; noice ; saw ; saw * saw ; saw * sin ; FM\n    1int note;\n    2int toNote;\n    3int offset;\n    4int volume;\n    5int len;\n    6int attack; /// not use if 0\n    7int decay; /// not use if 0\n    8int sustain; /// not use if 0\n    9int phase;\n    10int delay; /// not use if 0\n    11int echos;/// not use if 0\n    12int fade;\n    13int reso;\n    14int resoLevel;/// not use if 0\n    15int filter;/// not use if 0\n*/\n\nfloat instrument(float time,int type,int note,int offset, int vol, int phase,int decay,int notedecay,int cut,int res){\n\tif(note ==0) return .0;\n    \n    float n = float(note);\n    float p = float(phase)/31.0;\n    float d = float(decay-63)/31.0;\n    float n2 = notedecay==0?0.: float(notedecay-63)/100.0;;\n    float c = float(cut)/63.0;\n    float r = float(res)/63.0;\n    float o = float(offset);\n    \n    \n    return finstrument(time,type,n,o,p,d ,n2,c,r);\n}\n\n\nvec2 getSample(Instrument i, float t){\nfloat n = getNotePos(t);\nfloat y = instrument(n,i.alldata[0], i.alldata[1], i.alldata[3], i.alldata[4],i.alldata[9],i.alldata[7],i.alldata[2],i.alldata[13],i.alldata[14]);\nreturn vec2(y);\n}\n\n\nInstrument createInstrument(int i, int s, int p){\n    Instrument ins;\n        for(int j=0;j<16;j++){\n        char value = instr[i*16+j];\n        if(value<0) value = getCurValue(s, p, -value);\n \t\t\tins.alldata[j]=value;\n        }\n    return ins;\n}    \n\n\n//vec2 getTrackSample(i,s,p,t){\n\n\nvec2 getSampleAll(float t)\n{\n    int s = getSeqPos(t);\nint p = getPatPos(t);\n\n    \n    vec2 smp = vec2(0.);\n    for(int i=0;i<instrNums;i++){\n\n        \n    Instrument ins = createInstrument( i, s, p);\n        if(ins.alldata[1]==0)continue;\n        float d = 0.;\n        float amp =  float(ins.alldata[4])/255.;;\n        float da = float(ins.alldata[12])/64.;\n        float dd = float(ins.alldata[10])*bps;\n            for(int e=0;e<=ins.alldata[11];e++){// echoes\n    \t\t\tsmp += getSample(ins,t+d) * amp ;\n                amp =da; \n                d+=dd;\n            }\n    \n    \n    }   \n    return smp;\n}  \n\nvec2 mainSound( in int samp,float time)\n{\n\n    return getSampleAll( time);\n}","name":"Common","description":"","type":"common"}]}