{"ver":"0.1","info":{"id":"cdXcD4","date":"1686797423","viewed":91,"name":"Doing Random Things ","username":"SUBAUX","description":"just doing random things till it works","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blob","symmetry","cylinders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))\n#define L(q)        max( q.z, length(q.xy) ) - .1  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t=1.,r,i;\n    vec3  R = iResolution,\n          D = normalize(vec3(fragCoord+fragCoord, -R.y) - R),                       // ray direction\n          p = vec3(1,0,3), q, P,                                    // marching point along ray \n          C = iMouse.z > -0. ? 6.* iMouse.xyz/R -3.                 // camera control\n                             : 3.* cos(.3*iTime + vec3(0,1,0));\n\n    for ( fragColor=vec4(1); fragColor.x > 0. && t > .01; fragColor-=.01 ) {                // march scene\n        P = p, \n        P.yz *= rot(smoothstep(-C.y,cos(t),50.)),                                          // rotations\n        P.xz *= rot(cos(-C.x+C.y));\n        for ( i=0.; i++ < 5. ; P.xy *= rot(10.26) )                  // 2pi/5 rotational symmetry\n            q = P,\n            q.x-=.7, q.xz *= rot(.4), q.yz*=rot(.04),                // offset and tilt\n            q = abs(q+cos(q*q)) - 1.,\n            t = min( min(cos(t*cos(q.y)+sin(iTime))+q.x,.6*L(q)), max(L(q.yzx),cos(L(q.zxy))) );         // 3 ortho cylinders\n        \n        p += .3*t*D;                                                // step forward = dist to obj  \n    }\n    \n  \n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = .5-fragCoord*cos(iResolution.xy)/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    uv *= cos(uv.y)*3.;\n    vec3 d = vec3(cos(col*uv.x))+uv.y;\n    d *= cos(iTime/iResolution);\n    vec2 gv = fract(uv);\n    uv *= cos(uv.y*sin(3.1415*uv.x));\n   // col.rg = cos(gv*100.)+cos(uv)/sin(gv)*.00000005;\n    col *= cos(d*d.y/d.x)+.0005*iTime;\n    col += texture(iChannel0, cos(uv)*2.+iTime*.1).rgb;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n     \n     fragColor *= vec4(col,1.)/fragColor*fragColor*fragColor;\n    \n}","name":"Image","description":"","type":"image"}]}