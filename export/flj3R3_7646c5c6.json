{"ver":"0.1","info":{"id":"flj3R3","date":"1624382162","viewed":124,"name":"MurmurHash vs Perlin Noise Hash ","username":"TheTurk","description":"Quick comparison between MurmurHash ([url]https://www.shadertoy.com/view/stjGRR[/url]) and the hash function that is used in the original Perlin Noise implementation (right). ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlinnoise","gradient","random","hash","whitenoise","murmur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector. The vector is hashed by simply treating as a \n// sequence of bytes. MurmurHash is the natural choice for this task because it works \n// on 4 byte sequences which happens to be also the length of the uint data type.\n\nuint murmurHash(uvec2 x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nint permutation[512]= int[512](151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n    151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n);\n\n// hash function used in the original Perlin Noise implementation https://mrl.cs.nyu.edu/~perlin/noise/\n// uses a nested hash function in the form hash(hash(x) + y)\nuint perlinHash(uvec3 x) {\n    return uint(permutation[permutation[permutation[int(x.x)] + int(x.y)] + int(x.z)]);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float value;\n    if (position.x < 0.0) {\n        uint seed = 0x578437adU; // can be set to something else if you want a different set of random values\n        uint hashValue = murmurHash(uvec2(uint(fragCoord.x), uint(fragCoord.y)), seed); \n        value = float(hashValue) / float(0xffffffffU); // convert to float in range [0, 1]\n    } else {\n        uint hashValue = perlinHash(uvec3(uint(int(fragCoord.x) % 255), uint(int(fragCoord.y) % 255), 0U));\n        value = float(hashValue) / 255.0; // convert to float in range [0, 1]\n    }\n\n    vec3 color = vec3(value);\n    color *= smoothstep(0.0, 3.0, (abs(position.x) - 0.004) * iResolution.y);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}