{"ver":"0.1","info":{"id":"css3WM","date":"1666227478","viewed":113,"name":"Fork perlin Ink haleyhalcy 367","username":"HaleyHalcyon","description":"Supports 3 dither types and adjustment of distortion strength. Change them by changing #defines in the source","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"7d3yW7","parentname":"perlin Ink Blot Zoom"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TURN 6.283185307\n#define HEX(x) vec3((ivec3(x)>>ivec3(16,8,0))&255)/255.\n\n\n// How many layers to render.\n#define COUNT 20.\n\n// How many layers in a loop.\n// Set it to a multiple of number of colors per loop\n#define LAYERSPERLOOP 4.\n\n// How quickly to fade far layers in.\n// e.g. 1./3. makes the layer fade in over the course of moving 3 layers' distance closer.\n#define FARFADE 1./4.\n\n// How quickly to fade close layers out.\n#define CLOSEFADE 2./1.\n\n// How zoomed in the whole picture should be.\n#define ALLSCALE 1.0\n\n// How distorted the outer rims of the image are.\n// This works by changing the time variable depending on the distance from the center\n#define DISTORT 0.25\n\n// How far zoomed out each new layer should be.\n// Must be above 0.\n#define LAYERSCALE 4.\n\n// The time multiplier.\n// 1.0 = loop once every second, 0.5 = loop once every 2 seconds, etc.\n#define SPEED 1./4.\n\n// How to dither. (Mainly used for the purposes of exporting a GIF with a low file size.)\n// 0 = do not dither.\n// 1 = use ordered dithering (cross hatch).\n// 2 = use static noise dithering.\n// 3 = use \"dancing\" noise dithering.\n#define DITHERTYPE 0\n\n// How many steps there should be in the dithered image.\n// Must be an integer of at least 1.\n#define DITHERSTEPS 1.\n\n// Random integers used for Perlin noise.\nuint rand[] = uint[] (\n244u, 69u,224u, 39u,208u,151u,201u,255u,189u,202u,157u, 92u,206u,154u,199u,194u,\n232u,101u,216u,134u, 62u,242u,163u,248u,140u,183u,120u, 90u,215u, 30u,211u,186u,\n150u,100u, 57u,106u,118u,142u, 61u,246u, 11u,230u,141u, 55u,147u,180u, 27u,226u,\n 99u,125u,122u, 13u,  2u,112u,192u, 60u,137u, 80u,198u,252u, 94u,245u,162u,113u,\n 24u,146u, 49u,110u,253u, 81u, 10u,165u,109u,115u,218u,  0u,254u,129u, 71u, 88u,\n187u,114u,176u,243u,  7u, 87u, 45u,209u, 23u,168u,103u,121u, 93u,153u, 22u,133u,\n 34u, 78u,241u,182u,221u, 38u,136u,104u, 18u,105u,164u, 65u, 91u, 25u,132u,119u,\n174u,173u, 15u,170u, 29u, 37u,212u,210u, 44u,169u,181u,251u,  4u,  8u,229u, 79u,\n 32u, 21u,203u,214u, 75u, 12u,225u, 97u, 40u, 35u, 28u, 64u,231u, 19u,185u,123u,\n236u, 77u,238u,  5u,128u,179u,127u, 48u, 72u,156u,190u, 54u,124u,250u,205u,161u,\n228u, 56u,158u,207u,148u, 17u, 95u, 52u,111u,126u, 36u, 74u,197u,152u,160u, 20u,\n219u,130u, 66u,239u,240u,  6u,108u, 47u,116u,213u,237u,138u, 70u, 33u, 26u, 46u,\n 96u, 53u, 41u,200u, 59u, 58u,135u, 83u,235u, 31u,131u, 63u, 42u,  1u,149u,139u,\n247u,  9u,159u, 73u, 98u,222u, 68u, 51u, 67u,144u, 82u,233u,177u,155u,178u, 50u,\n143u, 84u,184u, 85u,217u,166u,193u,145u, 89u,107u,172u, 76u,117u,196u, 86u,220u,\n  3u,171u,223u, 16u,167u,195u,191u,102u, 14u,188u,227u,234u,204u,249u, 43u,175u\n);\n\n// fade function defined by ken perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(rand[(x + rand[y]) & 255u]) / 255. + time) * TURN;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// perlin generator\nfloat perlin(vec2 uv, float offset) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n  offset = fract(offset);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n\n#if DITHERTYPE == 1\n/* ordered dithering */\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 1;\n    return float((xy.x ^ xy.y) * 2 + xy.y)/ 4.;\n}\nfloat threshold(vec2 xyf) {\n    return (\n        crosshatch(xyf) +\n        crosshatch(xyf / 2.) / 4. +\n        crosshatch(xyf / 4.) / 16.+\n        crosshatch(xyf / 8.) / 64. +\n        0.5 / 256.\n    );\n}\n#elif DITHERTYPE == 2 || DITHERTYPE == 3\nfloat threshold(vec2 xyf) {\n    return 1. - float(rand[\n        (\n            uint(256. + xyf.x) + rand[uint(256. + xyf.y) & 255u]\n        ) & 255u\n    ]) / 256.;\n}\n#endif\n\n/* color mapping */\nvec3 colormap(vec4 rgba) {\n    \n    const vec3 c1 = HEX(0x009be8);\n    const vec3 c2 = HEX(0xeb0072);\n    const vec3 c3 = HEX(0xfff100);\n    const vec3 c4 = HEX(0x010a31);\n    \n    vec3 cA = mix(c1, c2, step(rgba.r, rgba.g));\n    vec3 cB = mix(c3, c4, step(rgba.b, rgba.a));\n    return mix(cA, cB, step(max(rgba.r, rgba.g), max(rgba.b, rgba.a)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    \n    float distSq = uv.x * uv.x + uv.y * uv.y;\n    float t = fract(iTime * SPEED);\n\n    uv *= ALLSCALE;\n\n    vec4 colors = vec4(0);\n    \n    // smaller is more back (drawn first)\n    for (float i = 0.; i < COUNT; i++) {\n        // depth. larger is more back\n        float z = COUNT - (i + t * LAYERSPERLOOP);\n        float z2 = z + (1. - distSq) * DISTORT;\n        float darken = clamp(\n            (- i - (t - 2.) * LAYERSPERLOOP) * FARFADE\n            , 0., 1.\n        );\n        vec4 layerRGB = floor(\n            clamp(\n            mod(\n                vec4(i) + vec4(0, 1, 2, 3),\n                4.\n            ) - 2.\n            , 0., 1.)\n        );\n        vec4 layerCol = layerRGB * (1. - darken);\n        float fade = smoothstep(\n            0., 1., (z + 1.) * CLOSEFADE\n        );\n        vec2 uvScale = uv * (\n            max(0.01, z2 * LAYERSCALE)\n        );\n        float noise =\n        perlin(\n            uvScale + vec2(31, 23) * fract(i / LAYERSPERLOOP),\n            fract(z2 * 0.25 - i / LAYERSPERLOOP + 0.0)\n        ) + ( // filter out center so we don't run into any ink\n           clamp(0.8 * length(uv) + 0.4 * z - 1., -1., 0.)\n        ) + ( // make outside more dense to restrict space\n           clamp(0.5 * length(uvScale) - 1.2, 0., 1.)\n        );\n        noise += perlin(\n            uvScale * 2.25 + vec2(31, 23) * fract(i / LAYERSPERLOOP) + vec2(51, 67),\n            fract(z2 * 0.25 + i / LAYERSPERLOOP + 0.2)\n        );\n        float smoothing = fwidth(noise) * 0.75;\n        float v = smoothstep(\n            -smoothing, smoothing, noise - 0.1\n        );\n        \n        // blend (layers don't bleed and act opaque)\n        colors = mix(colors, layerCol, v * fade);\n    }\n    /*\n    rgb = vec3(\n        perlin(\n            uv * 16.,\n            t\n        )\n    );*/\n    \n    \n#if DITHERTYPE != 0\n#if DITHERTYPE == 3\n    vec4 thres = vec4(0, 1, 0, 1) + vec4(1, -1, 1, -1) * threshold(fragCoord + vec2(51, 33) * floor(256. * t));\n#else\n    vec4 thres = vec4(0, 1, 0, 1) + vec4(1, -1, 1, -1) * threshold(fragCoord);\n#endif\n    colors = clamp(\n    (floor(DITHERSTEPS * colors) + step(thres, fract(DITHERSTEPS * colors))) / DITHERSTEPS\n    , vec4(0.), vec4(1.));\n#endif\n    vec3 col = colormap(\n        colors\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}