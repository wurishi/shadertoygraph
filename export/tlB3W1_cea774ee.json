{"ver":"0.1","info":{"id":"tlB3W1","date":"1559318384","viewed":77,"name":"recursivesd","username":"JabberSnatch","description":"fractals","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat4 perspective_inverse_hfov(float n, float f, float alpha, float aspect)\n{\n\tfloat tan_half_alpha = tan(alpha * 0.5) / 1.0;\n\treturn mat4(\n\t\ttan_half_alpha, 0.0, 0.0, 0.0,\n\t\t0.0, aspect * tan_half_alpha, 0.0, 0.0,\n\t\t0.0, 0.0, 0.0, (f-n)/(-2.0*f*n),\n\t\t0.0, 0.0, 1.0, (f+n)/(2.0*f*n)\n\t);\n}\n\nvec3 compute_ray_matrix(mat4 perspective_inverse, vec2 clip_coord)\n{\n\tvec4 target = vec4(clip_coord, 1.0, 1.0);\n\tvec4 ray_direction = perspective_inverse * target;\n\tray_direction = ray_direction / ray_direction.w;\n\treturn normalize(ray_direction.xyz);\n}\n\nmat3 roty(float alpha)\n{\n    return mat3(\n        cos(alpha), 0.0, sin(alpha),\n        0.0, 1.0, 0.0,\n        -sin(alpha), 0.0, cos(alpha)\n    );\n}\n\nmat3 rotx(float alpha)\n{\n    return mat3(\n       1.0, 0.0, 0.0,\n       0.0, cos(alpha), sin(alpha),\n       0.0, -sin(alpha), cos(alpha)\n    );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCube(vec3 p, float r)\n{\n    return max(max(abs(p.x), abs(p.y)), abs(p.z)) - r;\n}\n\nfloat sdDiamond(vec3 p, float r)\n{\n    return ((abs(p.x) + abs(p.y) + abs(p.z)) - r) / sqrt(3.0);\n}\n\n#if 1\nconst float kRecursionCount = 8.0;\nfloat scene(vec3 p)\n{\n    vec3 o = (p - vec3(0.0, 0.0, 2.0)) * roty(iTime * 0.2) * rotx(iTime * 0.2);\n    float d = 1000000000.0;\n\n    float rec = 0.0;\n    vec3 cp = vec3(0.0);\n\n    for (; rec < kRecursionCount; rec+=1.0)\n    {\n        float radius = pow(2.0, -rec);\n        float offset = 1.0 - radius;\n        vec3 lp = (o - cp*pow(2.0,-rec+1.0)) + vec3(offset);\n\n#if 1\n        if (rec > 3.0)\n        {\n            d = max(d, -sdDiamond(lp, radius *1.0* (kRecursionCount/rec)));\n        }\n#endif\n        if (rec == 2.0)\n           d = min(d, sdSphere(lp, radius));\n\n        cp = (cp * 2.0) + max(sign(lp), 0.0);\n    }\n\n    return d;\n}\n#endif\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.0001;\n\treturn normalize(\n\t\t   vec3(scene(p + vec3(delta, 0.0, 0.0)) - scene(p - vec3(delta, 0.0, 0.0)),\n\t\t   \t\tscene(p + vec3(0.0, delta, 0.0)) - scene(p - vec3(0.0, delta, 0.0)),\n\t\t\t\tscene(p + vec3(0.0, 0.0, delta)) - scene(p - vec3(0.0, 0.0, delta))));\n}\n\n\n#if 0\nfloat scene(vec3 p)\n{\n    vec3 lp = (p - vec3(0.0, -0.5, 2.0)) * roty(iTime * 0.2);\n\n    //z *= smoothstep(0.0, 1.0, lp.y) * 0.1;\n\n    float alpha = atan(lp.z, lp.x);\n    float d = (length(lp.xz) - 1.0);// - (1.0 - smoothstep(0.0, 1.0, lp.y)));\n    float z = lp.y;\n\n    float alpharep = 3.1415926536 * 0.01;\n    alpha = (mod(alpha + alpharep*0.5, alpharep) - alpharep*0.5);\n\n    float zrep = 0.05;\n    float zcount = 1.0 / zrep;\n    float zi = floor((z + zrep*0.5)/zrep);\n    z = mod(z + zrep*0.5, zrep) - zrep*0.5;\n    if (zi > zcount) z += zrep*(zi - zcount);\n    if (zi < 0.0) z += zrep*zi;\n\n    float geom =\n    //scene_fract(vec3(d, alpha, z));\n    sdSphere(vec3(d, alpha, z), 0.01);\n    return geom;\n}\n#endif\n\n\nfloat fresnel_term(vec3 l, vec3 n, float ior_out, float ior_in)\n{\n\tfloat c = max(dot(l, n), 0.0);\n\tfloat g_squared = ((ior_in * ior_in) / (ior_out * ior_out)) - 1.0 + (c * c);\n\tif (g_squared < 0.0) return 1.0;\n\tfloat g = sqrt(g_squared);\n\tfloat gmc = g - c;\n\tfloat gpc = g + c;\n\tfloat T0 = c*gpc - 1.0;\n\tfloat T1 = c*gmc + 1.0;\n\tfloat result = 0.5 * ((gmc * gmc)/(gpc * gpc)) * (1.0 + ((T0 * T0) / (T1 * T1)));\n\treturn result;\n}\n\nfloat ndf_term(vec3 h, vec3 n, float alpha)\n{\n#if 0\n    float sqr_alpha = alpha * alpha;\n    float exponent = 2.0/sqr_alpha - 2.0;\n    return pow(max(0.0, dot(h, n)), exponent) / (3.1415926536 * sqr_alpha);\n#else\n    float hdn = max(0.0, dot(h, n));\n    float pi = 3.1415926536;\n    float sqr_alpha = alpha * alpha;\n    float den = hdn*hdn * (sqr_alpha - 1.0) + 1.0;\n    return (sqr_alpha * step(0.0, hdn)) / (pi * den * den);\n#endif\n}\n\nfloat shadowing_term(vec3 v, vec3 n, float alpha)\n{\n    float vdn = max(0.0, dot(v, n));\n    float sqr_alpha = alpha * alpha;\n    float den = sqrt(sqr_alpha + (1.0 - sqr_alpha)*vdn*vdn);\n    return (2.0 * vdn) / (vdn + den);\n}\n\nfloat brdf(vec3 n, vec3 l, vec3 v, float D, float F, float G)\n{\n    return (D * G * (1.0+F)) / (4.0 * dot(n, l) * dot(n, v));\n}\n\nconst float kStepCount = 64.0;\nconst float kShadowStep = 64.0;\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n\tfloat aspect_ratio = iResolution.y / iResolution.x;\n\tfloat fov = 30.0 * 3.1415926534 / 180.0;\n\tfloat near = 0.001;\n\tfloat far = 10000.0;\n\tvec2 clip_coord = ((frag_coord / iResolution.xy) - 0.5) * 2.0;\n\n    vec3 rd = compute_ray_matrix(perspective_inverse_hfov(near, far, fov, aspect_ratio), clip_coord);\n    vec3 p = vec3(0.);\n    float i = 0.;\n    for (; i < kStepCount; i+=1.0)\n    {\n        float d = scene(p);\n        p += rd * d;\n        if (d < 0.001) break;\n    }\n\n    vec3 v = -rd;\n    vec3 n = normal(p);\n    float roughness = 0.9;\n\n    vec3 l0;\n    {\n    vec3 lp = vec3(3.0, -1.0, 2.0);\n    vec3 l = normalize(lp-p);\n    vec3 h = normalize(l+v);\n \tfloat F = fresnel_term(l, n, 1.0, 1.5);\n    float D = ndf_term(h, n, roughness);\n    float G = shadowing_term(v, n, roughness) * shadowing_term(l, n, roughness);\n\n    vec3 sp = lp;\n    int srm_step = 0;\n    float srm_dist = scene(sp);\n\tfor (; float(srm_step) < kShadowStep; srm_step++)\n\t{\n\t\tsp -= l * srm_dist;\n        srm_dist = scene(sp);\n        if (srm_dist < 0.005)\n           break;\n   \t}\n    float occlusion = max(0.0, 1.0 - distance(p, sp));\n    l0 = vec3(0.1, 0.2, 0.7) * 10.0 * brdf(n, l, v, D, F, G) * max(0.0, dot(l, n)) * occlusion;\n    }\n\n    vec3 l1;\n    {\n    vec3 lp = vec3(-2.0, 1.0, 0.0);\n    vec3 l = normalize(lp-p);\n    vec3 h = normalize(l+v);\n \tfloat F = fresnel_term(l, n, 1.0, 2.0);\n    float D = ndf_term(h, n, roughness);\n    float G = shadowing_term(v, n, roughness) * shadowing_term(l, n, roughness);\n\n    vec3 sp = lp;\n    int srm_step = 0;\n    float srm_dist = scene(sp);\n\tfor (; float(srm_step) < kShadowStep; srm_step++)\n\t{\n\t\tsp -= l * srm_dist;\n        srm_dist = scene(sp);\n        if (srm_dist < 0.005)\n           break;\n   \t}\n    float occlusion = max(0.0, 1.0 - distance(p, sp));\n    l1 = vec3(0.95, 0.4, 0.1) * 15.0 * brdf(n, l, v, D, F, G) * max(0.0, dot(l, n)) * occlusion;\n    }\n\n    frag_color.xyz = l0 + l1;\n    return;\n    float test = 1.0 - (i / kStepCount);\n    frag_color.xyz *= test*test;\n}\n","name":"Image","description":"","type":"image"}]}