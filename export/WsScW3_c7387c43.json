{"ver":"0.1","info":{"id":"WsScW3","date":"1633871927","viewed":316,"name":"Voropoints 3","username":"spalmer","description":"fork of [url]https://shadertoy.com/view/WdXcRN[/url] actually, simplified back to points, but using same 8-neighbor lists and shared buffer.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","particles","neighbors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork simplifying Voroshapes 2D at https://shadertoy.com/view/WdXcRN\n// (which is not yet public because it's still buggy as hell)\n// heck I just now debugged this toy after year or so!\n// see also Basic : Voronoi Tracking by gijs at https://shadertoy.com/view/WltSz7\n// which is a deconstruction of https://shadertoy.com/view/3ty3Dy\n// which is a deconstruction of https://shadertoy.com/view/ttyGWw\n// see also https://shadertoy.com/view/wtyGWc\n// I went down this rabbit-hole and found lots of variants:\n// one by cornusammonis: https://shadertoy.com/view/XsjyRm\n// one by wyatt: https://shadertoy.com/view/4lVfzh\n// I think the original is: rory618's https://shadertoy.com/view/XsjyRm but could be wrong\n// fabrice's https://shadertoy.com/view/WtK3zt\n// https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks\n//   said it ref'd all the way back to unnick:  https://shadertoy.com/view/ttK3Rc\n// nope, try stb's https://shadertoy.com/view/4sK3WK\n// Michael0884 gathered a playlist https://shadertoy.com/playlist/4XdXR8\n// must try out the jump flood idea\n// see also Voropoints 4 https://shadertoy.com/view/Nsy3D1\n\n#define BufferA iChannel0\n#define BufASize ivec2(iChannelResolution[0].xy)\n\n// beware dangling else issues; use {} just in case, requires do to allow trailing semicolon\n#define DR(_od, _oc, _oi, _nd, _nc, _ni) \\\ndo { float _Nd = (_nd); \\\n    if ((_od) <= 0. ? (_Nd <= 0. && (_ni) < (_oi)) : _Nd < (_od)) { \\\n        _od = _Nd; _oc = (_nc); _oi = (_ni); \\\n    } \\\n} while(false)\n//if (sd <= 0. && nearest <= 0.) { // new hit but already had a hit? overlap must be dealt with\n//            // the order of the list is fairly random from our POV here (sorted by distance from center of cell)\n//            // HACK depth sort by id to prevent order changing - helps but actually causes other problems\n//            if (c.x+c.y*shapesperrow < closest.x+closest.y*shapesperrow) {\n//                closest = c; nearest = sd; \n//            }\n//        } else // because we don't want just the \"most negative value\" shown\n\t\t\n//od <= 0. ? _nd <= 0. && ni > oi : _nd < od \n//        (_nd <= 0. &&  && ni < oi) \\\n//     || ((_nd > 0. || od > =.) && _nd < od)) \\\n    \nvec3 dotcolor(int id) //int i, int j)\n{\n\tconst float phi = .5/(sqrt(5.)+1.);\n    ivec2 c = id2coord(id);\n    int i = c.x, j = c.y;\n\treturn sin(\n        vec3(0,2,4)+2.*pi\n               * float(id) / float(totalshapes)\n              ) * .5 + .5; //vec3(1); //o.c; //texelFetch(BufferA, ivec2(i + shapesperrow, j + shaperows), 0).xyz;\n} // * phi\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 R = iResolution.xy;\n    vec2 Q = StoQ(p, R);\n//    vec2 m = StoQ(iMouse.xy, R);\n//    vec2 mo = iMouse.z < 0. ? m : StoQ(iMouse.zw, R);\n    // Q coordinates are -1..1 vertically, -1.778..1.778 horizontally, usually\n    float nearest = 9e9; int ni = -1;\n    // q coordinates are 0..(boxW,boxH)-1\n    // FIXME honestly this doesn't seem centered, not ideal.  But I think it's due to the\n    // tiny buffer sizes not being factors of the aspect ratio.  Which isn't a big deal.\n    vec2 q = QtoWorld(Q); //(Q + vec2(1.778,1)) * .5 * float(boxH-0); // main buffer scale, offset\n    ivec2 iq = ivec2(q);\n    vec3 col = vec3(1);\n  #if 0\n    // check also the nearest shapes according to the neighbor buffer of the neighboring cells\n    int[8*5] neighbors; // different plus pattern\n    loadNeighbors40(BufferA, iq, ivec2(shapesperrow, shaperows), neighbors);\n    ivec2 closest = ivec2(-1);\n    for (int i = IZERO+neighbors.length(); i-- > 0; ) {\n        ivec2 c = id2coord(neighbors[i]);\n        Object o = loadObject(BufferA, c);\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n        DR(nearest, closest, sd, c);\n    }\n    col = dotcolor(coord2id(closest));\n  #elif 0\n    // check also the nearest shapes according to the neighbor buffer of the neighboring cells\n    int[8] n; int[8*4] neighbors;\n    vec4 npack; // temp FIXME couldn't find way to unpack directly into an offset of the big array\n    npack = texelFetch(BufferA, iq           , 0);\n    unpackNeighbors(npack, n);\n    for (int i = 0; i < 8; ++i) neighbors[i    ] = n[i];\n    npack = texelFetch(BufferA, iq+ivec2(1,0), 0);\n    unpackNeighbors(npack, n);\n    for (int i = 0; i < 8; ++i) neighbors[i+8  ] = n[i];\n    npack = texelFetch(BufferA, iq+ivec2(0,1), 0);\n    unpackNeighbors(npack, n);\n    for (int i = 0; i < 8; ++i) neighbors[i+8*2] = n[i];\n    npack = texelFetch(BufferA, iq+ivec2(1,1), 0);\n    unpackNeighbors(npack, n);\n    for (int i = 0; i < 8; ++i) neighbors[i+8*3] = n[i];\n    ivec2 closest = ivec2(-1);\n    for (int i = IZERO+neighbors.length(); i-- > 0; ) {\n        ivec2 c = id2coord(neighbors[i]);\n        Object o = loadObject(BufferA, c);\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n \t\tDR(nearest, closest, sd, c);\n    }\n    col = dotcolor(coord2id(closest));\n  #elif 1\n    // only check the nearest shapes according to the neighbor buffer here\n    int[8] neighbors;\n    vec4 npack = texelFetch(BufferA, ivec2(q), 0);\n    unpackNeighbors(npack, neighbors);\n    for (int i = neighbors.length(); i-- > 0; ) {\n        int nn = neighbors[i];\n        ivec2 c = id2coord(nn);\n        Object o = loadObject(BufferA, c);\n        vec3 albedo = dotcolor(nn);\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n\t\tDR(nearest, col, ni, sd, albedo, nn);\n    }\n  #elif 0\n    // bruteforce all objects\n    for (int j = 0; j < shaperows; ++j) {\n\t for (int i = 0; i < shapesperrow; ++i) {\n        Object o = loadObject(BufferA, ivec2(i,j));\n        vec3 albedo = dotcolor(coord2id(ivec2(i,j)));\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n\t\tDR(nearest, col, ni, sd, albedo, nn);\n     }\n    }\n  #elif 1\n    // debug the nearby neighbor field as colored lines to the nearest objects\n    int[8] neighbors;\n    vec4 npack = texelFetch(BufferA, ivec2(q), 0);\n    unpackNeighbors(npack, neighbors);\n    for (int i = neighbors.length(); i-- > 0; ) {\n        int nn = neighbors[i];\n        ivec2 c = id2coord(nn);\n        Object o = loadObject(BufferA, c);\n        vec3 albedo = dotcolor(nn);\n        float scl = radius*.2; // leave room for lines\n        vec2 co = vec2(iq)+.5 \n        , lo = co + .02 * sin(vec2(.5*pi,0)+2.*pi*float(i)/float(neighbors.length())) // wiggle spread keeps lines from hiding behind one another so much\n        , op = o.p - co;\n        op = co + (length(op) > .45 ? .45*normalize(o.p - lo) : op);\n        float ld = dseg(q, op, lo) - .02;\n        if (nn == 0 && iq != ivec2(0)) ld = 9e9;\n        float sd; // signed distance to shape from q\n        sd = dshape((q - o.p)/scl) * scl;\n        sd = abs(sd - .25) - .02;\n        sd = min(sd, ld);\n\t\tDR(nearest, col, ni, sd, albedo, nn);\n    }\n  #else\n    // debug the nearby neighbor field as colors\n    col = texelFetch(BufferA, ivec2(q), 0).rgb //texture(BufferA, q / iChannelResolution[0].xy).rgb //\n    \t/ float(totalshapes*totalshapes);\n    nearest = -1.;\n  #endif\n    float cov = clamp(.5 - iResolution.y/float(boxH)*nearest, 0., 1.); //1.; //\n    float checker = float((iq.x^iq.y)&1); //.5; //\n    col = mix(vec3(.47 + .06 * checker), col, cov);\n    if (any(greaterThanEqual(iq, ivec2(boxW, boxH)))) col *= 0.; // out of bounds of grid\n    col = pow(col, vec3(1.0/2.2)); // gamma correct to sRGB\n\to = vec4(col, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define IZERO min(iFrame, 0)\n// \"constant\" uniform prevents loop unrolling\n\n// presently works ok at 5,3 but much higher and\n// all the collision stops working, probably due to\n// bad neighbor lists FIXME\n// fixed bug and got it working up to 4*16, 4*9,\n// any higher and it freaks out though\nconst int boxW = 4*16; //5; //7; //3; //32; //64; //128; //256; //320;\nconst int boxH = 4*9; //3; //4; //2; //18; //36; //72; //144; //180;\nconst int shaperows = boxH;\nconst int shapesperrow = boxW * 3 / 4; //boxW - 4; //int(float(boxW) / 3. / radius);\nconst int totalshapes = shapesperrow*shaperows;\nconst ivec2 shapePosVelOffset = ivec2(0,boxH);\n//const ivec2 shapeOriAvelSizeOffset = ivec2(boxW,0);\n//const ivec2 shapeAlbedoOffset = ivec2(boxW,boxH);\nconst float pi = 3.1415927; //acos(-1.); //\n\nconst float radius = .45; //.4; //.498; //.33; //.5; // of all balls\n\n\n// the shapes go in the space left over after\n// reserving a zone for the playfield nearest-points buffer\n\nconst int\n  rNear    = 0 // basically 1/4 buffer used for voronoi nearest lists, (region 0)\n, rPosVel  = 1 // 1/4 used for the shape locations and velocities (region 1)\n//, rOriSize = 2 // 1/4 used for the shape orientations and angular velocities, size, and shape (region 2)\n//, rColor   = 3 // and 1/4 used for material albedo and something else (region 3)\n;\n\nivec3 region(ivec2 q)\n{\n    ivec2 b = ivec2(boxW,boxH);\n    bvec2 c = lessThanEqual(b, q);\n    int r = 0;\n    if (c.x) { r += 1; q.x -= boxW; }\n    if (c.y) { r += 2; q.y -= boxH; }\n    if (any(lessThanEqual(b, q))) r += 4; // unused part of buffer\n    return ivec3(q, r);\n}\n\nint subregion(ivec2 q)\n{\n    q %= ivec2(boxW, boxH);\n    return q.y * shapesperrow + q.x;\n}\n\nint coord2id(ivec2 c)\n{\n    return c.x + c.y * shapesperrow;\n}\n\nivec2 id2coord(int id)\n{\n    return ivec2(id % shapesperrow, id / shapesperrow);\n}\n\n// 8 ids per texel idea from https://shadertoy.com/view/3sXyz4\n\n// for helping cram 8 neighbors into 1 texel\nint two2one(ivec2 two)\n{\n    return two.x + totalshapes * two.y;\n}\n\nivec2 one2two(int one)\n{\n    return ivec2(one % totalshapes, one / totalshapes);\n}\n\n\nvec4 packNeighbors(int[8] n)\n{\n    vec4 packed;\n    for (int i = 4, j = 8; i-- > 0; j -= 2) {\n        ivec2 two = ivec2(n[j-2], n[j-1]);\n        packed[i] = float(two2one(two));\n    }\n    return packed + .5;\n}\n\nvoid unpackNeighbors(vec4 packed, out int[8] n)\n{\n    for (int i = 4, j = 8; i-- > 0; j -= 2) {\n        ivec2 two = one2two(int(packed[i]));\n        n[j-2] = two.x;\n        n[j-1] = two.y;\n    }\n}\n// unpack directly into an offset of the big array\nvoid unpackNeighbors(vec4 packed, int offset, out int[8*5] n)\n{\n    for (int i = 4, j = 8+offset; i-- > 0; j -= 2) {\n        ivec2 two = one2two(int(packed[i]));\n        n[j-2] = two.x;\n        n[j-1] = two.y;\n    }\n}\n\nvoid loadNeighbors(sampler2D ch, ivec2 q, ivec2 r, out int[8] n)\n{\n\tq = clamp(q, ivec2(0), r-1);\n\tvec4 np = texelFetch(ch, q, 0);\n    unpackNeighbors(np, n);\n}\n\nvoid loadNeighbors(sampler2D ch, ivec2 q, ivec2 r, int o, out int[8*5] n)\n{\n\tq = clamp(q, ivec2(0), r-1);\n\tvec4 np = texelFetch(ch, q, 0);\n    unpackNeighbors(np, 8*o, n);\n}\n\nvoid loadNeighbors40(sampler2D ch, ivec2 q, ivec2 r, out int[8*5] n)\n{\n    loadNeighbors(ch, q           , r, 0, n);\n    loadNeighbors(ch, q+ivec2(1,0), r, 1, n);\n    loadNeighbors(ch, q+ivec2(0,1), r, 2, n);\n    loadNeighbors(ch, q-ivec2(1,0), r, 3, n);\n    loadNeighbors(ch, q-ivec2(0,1), r, 4, n);\n}\n\nstruct Object\n{\n    vec2 p;\n    vec2 v;\n//    float r; // rotation in turns\n//    float z; // size,scale - always 1\n//    int k; // kind of shape - always a ball\n//    int _; // nothing, yet\n//    vec4 c; // color\n};\n    \nObject loadObject(sampler2D buf, ivec2 c)\n{\n    Object o;\n    vec4 v0 = texelFetch(buf, c + ivec2(boxW,0), 0);\n    //vec4 v1 = texelFetch(buf, c + ivec2(0,boxH), 0);\n    //vec4 v2 = texelFetch(buf, c + ivec2(boxW,boxH), 0);\n    o.p = v0.xy; o.v = v0.zw;\n    //o.r = v1.x; o.z = v1.y; o.k = int(v1.z);\n    //o.c = v2;\n    return o;\n}\n\nObject loadObject(sampler2D buf, int id)\n{\n    return loadObject(buf, id2coord(id));\n}\n\n// signed distance\nfloat dball(vec2 p)\n{\n    return length(p) - 1.;\n}\n\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a;\n    return length(p - b*clamp(dot(p,b)/dot(b,b), 0., 1.));\n}\n\nfloat dshape(vec2 q)\n{\n    return dball(q);\n}\n\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n\n// Q is signed, aspect-corrected, -1..1 space (goes past 1 on sides)\n// centers a unit circle in the window.\n// World is 0,0 .. boxW-1,boxH-1 grid\nvec2 QtoWorld(vec2 q)\n{\n    return (q + vec2(1.778,1)) * .5 * float(boxH-0); // main buffer scale, offset\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BufferA iChannel0\n\nbool init(out vec4 o, ivec2 q, ivec3 r)\n{\n    // HACK to fix thumbnail!\n    if (iFrame > 2) { //if (iFrame != 0) { //\n        o = texelFetch(BufferA, q, 0);\n        return false;\n    }\n    int sid = coord2id(r.xy); //r.x + shapesperrow*r.y; //\n    o = vec4(0);\n    const float phi = (sqrt(5.) + 1.)/2.;\n    vec3 rnd = sin(vec3(sid + ivec3(0,2,4)) * phi * 32.1);\n    int ts = totalshapes, spr = shapesperrow;\n    switch (r.z) {\n        case rNear:\n        //\to = vec4(sid, -1,-1,-1);\n        \to = vec4(sid + ts * sid); // set all 8 to the same neighbor id for now;\n        \to += vec4(-1, 1, -spr, spr); // the 8 immediate neighbors\n        \to += vec4(-1-spr, 1+spr, 1-spr, spr-1)*float(ts);\n        //\to = mod(o, float(ts*ts));\n        \tfor (int i = 0; i < 4; ++i)\n        \to = max(o, vec4(0));\n        \to = min(o, vec4(ts*ts-1));\n        \tbreak; // they'll mix themselves up as updates occur\n        case rPosVel:\n        \to.xy = vec2(r.xy) + .5;\n        \to.zw = vec2(0);\n        \to.x += o.y * .01;\n        \tbreak;\n    //    case rOriSize:\n    //    \to.x = rnd.x;\n    //    \to.y = rnd.y*.125+.375;\n    //    \to.z = float(int(3.*(rnd.x-rnd.y)) & 3);\n    //    \tbreak; // zw? TODO\n    //    case rColor:\n    //   \to.rgb = .5 + .5*cos(float(sid)+vec3(0,2,4));\n    //    \to.a = 1.; // TODO\n    //    \tbreak;\n    }\n    return true;\n}\n\n// made more relative so can use same fn for other objects and walls\n// d is actually the distance to overlap along pn, dot product already done by caller\n// relmass is our mass divided by total mass\nbool bounce(inout vec2 p, inout vec2 v, vec2 pn, float d, float relmass)\n{\n    bool r = d < 0.;\n    if (r) {\n        float omrm = (1.-relmass);\n        p -= pn * d * omrm;\n        float nv = dot(pn, v);\n        if (nv < 0.) { // FIXME needs rel velocity\n            const float crest = .96; //.2; // // FIXME gaining energy due to fraction overstep handling; don't be too bouncy!\n            float boing = (1. + crest) * omrm; //1.98; //1.+crest; //\n        \tv -= boing * pn * nv;\n        }\n    }\n    return r;\n}\n\nbool bouncewall(inout vec2 p, inout vec2 v, vec2 pn, float pd)\n{\n    float d = dot(p, pn) - pd; // - radius;\n    return bounce(p, v, pn, d, 0.);\n}\n\nvoid motion(inout vec4 o, ivec2 q)\n{\n    int id = coord2id(q);\n    vec2 p = o.xy, v = o.zw;\n    float dt = iTimeDelta;\n    dt = clamp(dt, 1./144., 1./30.);\n    float r = radius; //texelFetch(BufferA, q + ivec2(0, boxH), 0).y; // obtain Object.z size from quadrant 2\n    if (iMouse.z > 0.5) {\n        vec2 mb = QtoWorld(StoQ(abs(iMouse.xy), iResolution.xy))\n        , d = mb - p;\n        v += d * exp2(-.31 * dot(d,d)) * dt * 15.; // spring force from mouse to nearby shapes\n    }\n    p += v * dt;\n    ivec2 sr = ivec2(boxW, boxH); //shapesperrow, shaperows); // bug!\n  #if 1\n    // TODO collide with neighbors\n    int neighbors[8]; //*5]; //\n    loadNeighbors(BufferA, ivec2(floor(p)), sr, neighbors);\n    //loadNeighbors40(BufferA, q, sr, neighbors);\n    for (int i = IZERO+neighbors.length(); i-- > 0; ) {\n        // probably shouldn't use same bounce fn as walls anyway\n        // since this is a pixel shader, we're really limited in what we can do\n        // regarding updating multiple objects state at once;\n        // it all happens in one tick, the relative order of each update \n        // doesn't matter; objects' state spans more than one pixel and \n        // everything must be updated in sync, but the double buffering helps.\n        // So the pixels aren't really fighting with each other, but\n        // they must all be updated in concert, with forces balancing.\n        int nn = neighbors[i];\n        if (nn == id) continue; // don't collide w/ self!\n        Object o = loadObject(BufferA, id2coord(nn));\n        vec2 po = o.p; float ro = radius; //o.z;\n        vec2 rd = normalize(p - po);\n        float dr = distance(p, po) //dot(p, rd) //\n            - r - ro;\n        bounce(p, v, rd, dr, .5);\n    }\n  #else\n    // a spring force instead of actual collision\n    int neighbors[8]; //*5]; //\n    loadNeighbors(BufferA, q, sr, neighbors);\n    for (int i = IZERO+neighbors.length(); i-- > 0; ) {\n        int nn = neighbors[i];\n        if (nn == id) continue; // don't push self!\n        Object o = loadObject(BufferA, id2coord(nn));\n        vec2 po = o.p; float ro = radius;\n        vec2 rd = normalize(p - po);\n        //if (dot(v, rd) <= 0.) break;\n        float dr = distance(p, po) //dot(p, rd) //\n            - r - ro;\n        float K = 5.5;\n        v -= K * min(dr, 0.) * rd; // one-sided springs, no \"pull\" force, for fakie collision\n        // but since it's undamped etc. it's unstable as heck.  I'm only using simple Euler integration.\n    }\n  #endif\n    // collide with walls\n    bouncewall(p, v, vec2(0, 1), r);\n    bouncewall(p, v, vec2(1, 0), r);\n    bouncewall(p, v, vec2(0,-1), r-float(boxH));\n    bouncewall(p, v, vec2(-1,0), r-float(boxW));\n    vec2 f = vec2(0, -.9);  // gravity force // TODO * mass\n    v += f * dt;\n    v *= exp2(-.5*dt); // damping\n    o = vec4(p, v);        \t\n}\n\nvoid rotion(inout vec4 o, ivec2 q)\n{\n    float r = o.x, s = o.y; int k = int(o.z);\n    float dt = iTimeDelta;\n    // will probably need to do all the physics in this thread too, but only output orientation\n    // for now they just constantly don't rotate\n    //o.x = fract(o.x + .05*dt);\n}\n\nvoid insertNeighbor(inout int[8] ns, inout float[8] ds, int n, float d)\n{\n    for (int i = 0; i < ns.length(); ++i) \n        if (ns[i] == n)\n            return; // already in list! don't add again\n    \n    for (int i = 0; i < ns.length(); ++i) {\n        //if (ns[i] == n) break; //return; // already in list! don't add again\n        if (d >= ds[i]) continue;\n        // push rest down\n        for (int j = ns.length(); --j > i;) {\n            ds[j] = ds[j-1]; \n            ns[j] = ns[j-1];\n        }\n        // and insert here\n        ds[i] = d;\n        ns[i] = n;\n        break;\n    }\n}\n\nvoid distanceNeighbors(ivec2 q, int[8] ns, out float[8] ds)\n{\n    vec2 p = vec2(q) + .5;\n    for (int i = IZERO+ns.length(); i-- > 0; ) {\n        if (ns[i] >= totalshapes) continue; // skip bad ids\n        ivec2 c = id2coord(ns[i]);\n        Object o = loadObject(BufferA, c);\n        //vec4 posvel = texelFetch(BufferA, c + ivec2(shapesperrow, 0), 0);\n\t    //vec4 orisize = texelFetch(BufferA, c + ivec2(0, shaperows), 0);\n\t//    int sh = o.k; //int(orisize.z);\n        float scl = 1.; //o.z; //orisize.y;\n        vec2 local = p - o.p; //posvel.xy;\n        //vec2 cs = sin(vec2(.5*pi, 0) + 2.*pi*orisize.x);\n        //mat2 rot = mat2(cs*vec2(1,-1),cs.yx);\n        //local = local * rot;\n        float sd = dshape(local/scl/*, sh*/) * scl;\n        ds[i] = sd;\n    }\n}\n\nvoid mergeNeighbors(ivec2 q, inout int[8] ns, inout float[8] ds, int[8] xs)\n{\n    float[8] xd;\n    distanceNeighbors(q, xs, xd);\n    for (int i = xs.length()+IZERO; i-- > 0; ) {\n    // FIXME don't bother loading and unpacking if new id is already in the list?\n        // TODO insertion sort new id into list based on distance\n        insertNeighbor(ns, ds, xs[i], xd[i]);\n    }\n}\n\n//void mergeNeighbors1(ns, ds, sd, id)\n//{\n//    insertNeighbor(ns, ds, id, sd);\n//}\n\nvoid updateNeighbors(inout vec4 o, ivec2 q)\n{\n  #if 1\n    // not using loadNeighbors40, so just updates 8 at a time as it unpacks each neighbor list\n    vec4 npack = o; //texelFetch(BufferA, q, 0);\n    int[8] ns;\n    float[8] ds;\n    int[8] nnext;\n    for (int i = 0; i < 8; ++i) { nnext[i] = -1; ds[i] = 3.4e38; }\n    #if 1 // just let it insert them all, at least the order will be correct\n    unpackNeighbors(npack, nnext);\n    mergeNeighbors(q, ns, ds, nnext);\n    #else\n    unpackNeighbors(npack, ns);\n    distanceNeighbors(q, ns, ds); \n    #endif\n    npack = texelFetch(BufferA, ivec2(1,0) + q, 0);\n    unpackNeighbors(npack, nnext);\n    mergeNeighbors(q, ns, ds, nnext);\n    npack = texelFetch(BufferA, ivec2(0,1) + q, 0);\n    unpackNeighbors(npack, nnext);\n    mergeNeighbors(q, ns, ds, nnext);\n    npack = texelFetch(BufferA, ivec2(-1,0) + q, 0);\n    unpackNeighbors(npack, nnext);\n    mergeNeighbors(q, ns, ds, nnext);\n    npack = texelFetch(BufferA, ivec2(0,-1) + q, 0);\n    unpackNeighbors(npack, nnext);\n    mergeNeighbors(q, ns, ds, nnext);\n    // If objects are about the size of the cells, 8 is probably enough.\n    // But when they're like half the size of the cells,\n    // can fit maybe 4 into one cell, and occasionally the configuration\n    // requires more neighbors than 8 and one gets lost temporarily.\n    // This kludge usually rescues them eventually.\n    #if 1\n    // merge some random id's in case some objects got lost\n    for (int j = IZERO+0; j < 8; ++j) nnext[j] = (j + ((iFrame & 255)<<3))%totalshapes;\n    mergeNeighbors(q, ns, ds, nnext);\n    #endif\n    // somehow I see that objects can still become \"lost\"\n    // where no cells include it as neighboring, \n    // if too many objects are allowed to fit into one cell.\n    o = packNeighbors(ns);\n  #else\n    // bruteforce nearest neighbors\n    vec2 p = vec2(q) + .5;\n    float[8] ds; int[8] ns;\n    //for (int i = 0; i < 8; ++i) ns[i] = -1;\n    vec4 npack = texelFetch(BufferA, q, 0); //loadNeighbors(BufferA, q);\n    //unpackNeighbors(npack, ns);\n    //distanceNeighbors(q, ns, ds); // just let it insert them all, at least the order will be correct\n    for (int j = 0; j < shaperows; ++j) {\n\t for (int i = 0; i < shapesperrow; ++i) {\n        int id = coord2id(ivec2(i,j));\n        Object o = loadObject(BufferA, ivec2(i,j));\n        float scl = radius;\n        float sd; // signed distance to shape from q\n        sd = dshape((p - o.p)/scl) * scl;\n\t    //mergeNeighbors1(ns, ds, sd, id);\n        insertNeighbor(ns, ds, id, sd);\n     }\n    }\n    o = packNeighbors(ns);\n  #endif\n}\n\nvoid tick(inout vec4 o, ivec2 q, ivec3 r)\n{\n    switch (r.z) {\n        case rNear:\n        \tupdateNeighbors(o, r.xy);\n        \tbreak;\n        case rPosVel:\n        \tmotion(o, r.xy);\n        \tbreak;\n    //    case rOriSize:\n    //    \trotion(o, r.xy); //o.x = 0.; // HACK no rotation\n    //    \tbreak;\n    //    case rColor:\n    //    \tbreak;\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    ivec2 q = ivec2(p);\n    ivec3 r = region(q);\n    if (init(o, q, r)) return;\n    tick(o, q, r);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}