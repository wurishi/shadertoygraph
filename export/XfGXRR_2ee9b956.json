{"ver":"0.1","info":{"id":"XfGXRR","date":"1714867567","viewed":173,"name":"Navier-Stokes using Transport","username":"weasel","description":"Navier-Stokes equation solver, but using the shadertoy version of the transport equation, which is to sample the image at the right offset.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"4cGXRR","parentname":"Navier-Stokes Stabilized"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // output Buffer A to screen\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    float rho = data.z;\n    vec3 col = vec3(data.xy * 4.0 + 0.5, 0.0);\n    vec2 uv_col2 = texture(iChannel1, uv).xy;\n    // fractal texture to avoid loss of detail for stretched uv's\n    vec3 col2 = (texture(iChannel2, uv_col2).rgb + texture(iChannel2, uv_col2 * iChannelResolution[2].xy / 4.0).rgb) * 0.8 - 0.3;\n    //vec3 col2 = texture(iChannel2, uv_col2).rgb;\n    col2 = pow(col2 + 0.15, vec3(1.5));\n    col2 = mix(col2, vec3(0.0), shape(fragCoord));\n    fragColor = vec4(mix(col, col2, 1.0) * rho + vec3(data.w, 0.0, 0.0), 1.0);\n    //fragColor = vec4(uv_col2, 0.0, 1.0);\n    //fragColor = vec4(vec3(rho), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// use Navier-Stokes equations\n// rho Dv/Dt = f - grad p + eta * laplace v + (zeta + eta/3) * grad (div v)\n// -drho/dt = div (rho v)\n// Equation of state:\n// p = C*rho\n//\n// fragColor = vec4(vx, vy, rho, 0.0);\n\n#define DT 0.5\n\n#define ETA 1.2\n#define ZETA 0.5\n\n#define C 3.5\n\n#define IN0(x, y) texture(iChannel0, (fragCoord + vec2(float(x), float(y))) / iResolution.xy)\n#define IN(x, y) texture(iChannel0, (fragCoord - v*DT + vec2(float(x), float(y))) / iResolution.xy)\n\n// fluid sim using separate transport and interaction handling\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        vec2 uv = (fragCoord + 0.5) / iResolution.xy;\n        vec4 col = texture(iChannel1, uv);\n        col.xy -= 0.5;\n        col.xy *= 10.0;\n        col.z = 1.0;\n        col.w = 0.0;\n        fragColor = col;\n        return;\n    }\n    vec2 accel = vec2(0.0, 0.0);\n    if (iMouse.z > 0.0) {\n        vec2 dx = iMouse.xy - fragCoord;\n        float d = length(dx);\n        accel = 1.0 * normalize(vec2(dx.y, -dx.x) + dx) * exp(-d*d/1000.0);\n    }\n    \n    // Do an RK4 inspired search for the point that gets transported to fragCoord in one step.\n    vec4 b = IN0(0, 0);\n    vec2 k1 = b.xy + accel * DT * 0.5;\n    vec2 v = k1 / 2.0; // Read from transported field!\n    b = IN(0, 0); // reset velocity to the one at a half flow step\n    /*vec2 k2 = b.xy;\n    v = k2 / 2.0;\n    \n    b = IN(0, 0);\n    vec2 k3 = b.xy;\n    v = k3;\n    \n    b = IN(0, 0);\n    vec2 k4 = b.xy;\n    \n    v = (k1 + 2.0*k2 + 2.0*k3 + k4) / 6.0 + accel * DT;*/\n    v = b.xy + accel * DT;\n    \n    \n    b = IN(0, 0);\n    vec4 dbdx = (IN(1.5, 0) - IN(-1.5, 0)) / 2.0 / 1.5;\n    vec4 dbdy = (IN(0, 1.5) - IN(0, -1.5)) / 2.0 / 1.5;\n    \n    vec4 laplace_b = (IN(1.5, 0) + IN(-1.5, 0) + IN(0, 1.5) + IN(0, -1.5) - 4.0 * b) / (2.0 * 1.5 * 1.5);\n    // d/dx div_v:\n    // (0,-1)  ( 0,0)  (0, 1)\n    // (2, 0)  (-4,0)  (2, 0)\n    // (0, 1)  ( 0,0)  (0,-1)\n    // - laplace x\n    // (0,-1)  (-1,0)  (0, 1)\n    // (1, 0)  ( 0,0)  (1, 0)\n    // (0, 1)  (-1,0)  (0,-1)\n    // this is the least reliable term...\n    vec2 grad_div_v = vec2((-IN(-1.5, 1.5).y - IN(0, 1.5).x + IN(1.5, 1.5).y\n                           + IN(-1.5, 0).x              + IN(1.5, 0).x\n                           + IN(-1.5, 1.5).y - IN(0, 1.5).x - IN(1.5, 1.5).y) / (4.0*1.5*1.5) + 0.5 * laplace_b.x,\n                           (-IN(-1.5, 1.5).x + IN(0, 1.5).y + IN(1.5, 1.5).x\n                           - IN(-1.5, 0).y              - IN(1.5, 0).y\n                           + IN(-1.5, 1.5).x + IN(0, 1.5).y - IN(1.5, 1.5).x) / (4.0*1.5*1.5) + 0.5 * laplace_b.y);\n    \n    // Drho/Dt = -rho * div v\n    // changed to Drho/Dt = -rho * div v + laplace rho\n    // to dampen out soundwaves, as they are difficult numerically\n    float div_v = dbdx.x + dbdy.y;\n    float drho_dt_div_rho = -div_v;\n    \n    // equation of state\n    //float p = C*b.z;\n    vec2 grad_p_div_rho = C*vec2(dbdx.z, dbdy.z)/b.z;\n    \n    // material derivative Dv/Dt = 1/rho (f - grad p)\n    // Euler equation:\n    //vec2 Dv_Dt = accel - grad_p_div_rho;\n    // Navier-Stokes equation:\n    vec2 Dv_Dt = accel - grad_p_div_rho + (ETA * laplace_b.xy + (ZETA + ETA/3.0) * grad_div_v) / b.z;\n    \n    // Now that the acceleration is known the transport from above is slightly invalid.\n    // However it is still mostly correct, so just add a little correction for large accelerations.\n    // Find a better approximation of the position that flows in to the currently computed position.\n    vec2 dx = (b.xy + Dv_Dt * DT - v) * 1.;\n    if (length(dx) > length(v)*0.05) {\n        dx = normalize(dx) * length(v)*0.05;\n    }\n    float error = length(b.xy + Dv_Dt * DT - v) * 0.0; // set to a higher value to show acceleration estimation error\n    \n    // find the position, that flows to this position in one step\n    b = IN(dx.x, dx.y); // this leads to funny runaway effects depending on the choice above\n    \n    v = b.xy + Dv_Dt * DT;\n    // limit v for stability\n    float max_v = DT*100.0*min(b.z, 5.0);\n    if (length(v) > max_v) {\n        v = normalize(v) * max_v;\n    }\n    // prevent fluid entering the shape\n    if (shape(fragCoord + 2.0 * v * DT) > 0.5) {\n        v *= 0.5;\n        if (shape(fragCoord + 2.0 * v * DT) > 0.5) {\n            v *= 0.5;\n        }\n    }\n    // drho/dt = -b rho\n    // -> solution rho(t) = rho0 * exp(-b*t)\n    float rho = (b.z + laplace_b.z * 2.0*1.5*1.5/8.0) * exp(min(drho_dt_div_rho * DT, 1.0));\n    rho = mix(clamp(rho, 0.0, 100.0), 1.0, 0.01); // correct any total mass loss over time\n    if (shape(fragCoord) > 0.5) {\n        rho = mix(b.z + laplace_b.z * 2.0*1.5*1.5/8.0, 1.0, 0.01);\n    }\n    \n    // no-slip boundary condition\n    v *= 1.0 - shape(fragCoord);\n    \n    fragColor = vec4(v, rho, error);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define INA(x, y) texture(iChannel0, (fragCoord + vec2(float(x), float(y))) / iResolution.xy)\n#define INB(x, y) texture(iChannel1, (fragCoord + vec2(float(x), float(y))) / iResolution.xy)\n\n#define DT 0.5\n\n// Transport uv coordinates of the image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if (iFrame == 0) {\n        fragColor = vec4(uv, 0.0, 0.0);//texture(iChannel2, uv);\n        return;\n    }\n    \n    vec2 v = INA(0, 0).xy * DT;\n    //fragColor = mix(INB(-v.x, -v.y), uv.xyyy, 0.001); // gradually restore original\n    fragColor = INB(-v.x, -v.y);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float shape(vec2 pos) {\n    // shape for collisions\n    vec2 pos0 = vec2(150.0, 200.0);\n    float r0 = 50.0;\n    vec2 pos1 = vec2(330.0, 200.0);\n    float r1 = 100.0;\n    float s0 = length(pos - pos0) - r0;\n    float s1 = length(pos - pos1) - r1;\n    return clamp((-min(s0, s1)) * 1.0, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"}]}