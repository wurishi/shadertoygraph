{"ver":"0.1","info":{"id":"wdVcDR","date":"1614370665","viewed":375,"name":"Boulder Dash Game","username":"etcher","description":"This is a tribute to my favorite game when I was a child. I was trying to recreate everything very carefully. 20 caves, 5 levels of difficulty.\n   F2 - go to cave choose screen\n   Ctrl - fire. (in caves - will eat/push without movement)\n   Arrows - move.","likes":11,"published":1,"flags":48,"usePreview":1,"tags":["2d","game","retro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----------------------------------------------------------------------------\n// Created by Evgenii Davydenko in 2021\n//\n// used some ideas from:\n//      Inigo Quilez:   https://www.shadertoy.com/view/Ms3XWN\n//      Timothy Lottes: https://www.shadertoy.com/view/XsjSzR\n// -----------------------------------------------------------------------------\n\nfloat toLinear1(float c)\n{\n    return (c <= 0.04045) ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4);\n}\n\nvec3 toLinear(vec3 c)\n{\n    return vec3(toLinear1(c.r), toLinear1(c.g), toLinear1(c.b));\n}\n\nfloat toSrgb1(float c)\n{\n    return (c < 0.0031308) ? c * 12.92 : 1.055 * pow(c, 0.41666) - 0.055;\n}\n\nvec3 toSrgb(vec3 c)\n{\n    return vec3(toSrgb1(c.r), toSrgb1(c.g), toSrgb1(c.b));\n}\n\nvec3 mask(vec2 pos)\n{\n    const float maskDark=0.6;\n    const float maskLight=2.0;\n\n    pos.x += pos.y * 3.0;\n    vec3 mask = vec3(maskDark);\n    pos.x = fract(pos.x / 6.0);\n\n    if (pos.x < 0.333) mask.r = maskLight;\n    else if (pos.x < 0.666) mask.g = maskLight;\n    else mask.b = maskLight;\n\n    return mask;\n}\n\nvec2 fragCoord2UV(vec2 fc)\n{\n    vec2 fitNum = floor(iResolution.xy / TIT_RES_F);\n    float scale = max(min(fitNum.x, fitNum.y), 1.0);\n    vec2 fc2 = remap(vec2(0.0), TIT_RES_F * vec2(float(scale)), vec2(0.0), TIT_RES_F, fc);\n    fc2 -= floor((remap(vec2(0.0), TIT_RES_F * vec2(float(scale)), vec2(0.0), TIT_RES_F, iResolution.xy) - TIT_RES_F) / vec2(2.0));\n    return fc2 / iResolution.xy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord2UV(fragCoord);\n\n    vec3 col = toLinear(texture(iChannel0, uv).rgb);\n    col *= mask(fragCoord.xy);\n    col = toSrgb(col);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define UNLOCK_CAVES\n\n//----------------------------------------------------------------------------------------------------------\n// CELLS\n//----------------------------------------------------------------------------------------------------------\n\nconst int CELL_VOID          = 0x0;\nconst int CELL_DIRT          = 0x1;\nconst int CELL_WALL          = 0x2;\nconst int CELL_MAGIC_WALL    = 0x3;\nconst int CELL_EXIT          = 0x4;\nconst int CELL_TITAN_WALL    = 0x7;\nconst int CELL_FIREFLY       = 0x8;\nconst int CELL_BOULDER       = 0x10;\nconst int CELL_DIAMOND       = 0x14;\nconst int CELL_EXPL_VOID     = 0x1B;\nconst int CELL_EXPL_DIAMOND  = 0x20;\nconst int CELL_ENTRANCE      = 0x25;\nconst int CELL_BUTTERFLY     = 0x30;\nconst int CELL_AMOEBA        = 0x3A;\n\nconst int CELL_ROCKFORD      = 0x41;\nconst int CELL_EXPL_ROCKFORD = 0x42;\n\nconst int CELL_INVALID = 100;\nconst int CELL_NO_FILL = -1;\n\nconst ivec4 CELL_VOID4      = ivec4(CELL_VOID, 0, 0, 1);\n\n//----------------------------------------------------------------------------------------------------------\n// LETTERS\n//----------------------------------------------------------------------------------------------------------\n\nconst int _ = 0;\nconst int A = 1;\nconst int B = 2;\nconst int C = 3;\nconst int D = 4;\nconst int E = 5;\nconst int F = 6;\nconst int G = 7;\nconst int H = 8;\nconst int I = 9;\nconst int J = 10;\nconst int K = 11;\nconst int L = 12;\nconst int M = 13;\nconst int N = 14;\nconst int O = 15;\nconst int P = 16;\nconst int Q = 17;\nconst int R = 18;\nconst int S = 19;\nconst int T = 20;\nconst int U = 21;\nconst int V = 22;\nconst int W = 23;\nconst int X = 24;\nconst int Y = 25;\nconst int Z = 26;\nconst int L_DIAMOND   = 27;\nconst int L_COMMA     = 28;\nconst int L_COLON     = 29;\nconst int L_SEMICOLON = 30;\nconst int L_SLASH     = 31;\nconst int L_OPEN_BRACKET  = 32;\nconst int L_CLOSE_BRACKET = 33;\nconst int L_ASTERISK      = 34;\n\n//----------------------------------------------------------------------------------------------------------\n// GAME DIMENSIONS\n//----------------------------------------------------------------------------------------------------------\n\nconst ivec2 GAM_RES   = ivec2(320, 192);\nconst  vec2 GAM_RES_F =  vec2(GAM_RES);\nconst ivec2 CEL_RES   = ivec2(16, 16);\nconst  vec2 CEL_RES_F =  vec2(CEL_RES);\nconst ivec2 CEH_RES   = ivec2(16, 8);\nconst  vec2 CEH_RES_F =  vec2(CEH_RES);\nconst ivec2 TIT_RES   = ivec2(320, 200);\nconst  vec2 TIT_RES_F =  vec2(TIT_RES);\nconst ivec2 SPR_RES   = ivec2(8, 16);\nconst  vec2 SPR_RES_F =  vec2(SPR_RES);\nconst ivec2 SPH_RES   = ivec2(8, 8);\nconst  vec2 SPH_RES_F =  vec2(SPH_RES);\nconst ivec2 FNT_RES   = ivec2(8, 8);\nconst  vec2 FNT_RES_F =  vec2(FNT_RES);\nconst ivec2 CAV_SIZ   = ivec2(40, 22);\nconst  vec2 CAV_SIZ_F =  vec2(CAV_SIZ);\nconst ivec2 LOG_SIZ   = ivec2(20, 6);\nconst  vec2 LOG_SIZ_F =  vec2(LOG_SIZ);\nconst ivec2 LOG_RES   = LOG_SIZ * CEH_RES;\nconst  vec2 LOG_RES_F =  vec2(LOG_RES);\nconst ivec2 BOU_SIZ   = ivec2(18, 15);\nconst  vec2 BOU_SIZ_F =  vec2(BOU_SIZ);\nconst ivec2 PIX_ASP   = ivec2(2, 1);\n\n//----------------------------------------------------------------------------------------------------------\n// KEYBOARD\n//----------------------------------------------------------------------------------------------------------\n\n#define KEY_DOWN(i)   texelFetch(iChannel3, ivec2(i, 0), 0).x > 0.5   // Shadertoy\nconst int KEY_F2     = 113;\nconst int KEY_CTRL   = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_LT_ARR = 37;\nconst int KEY_UP_ARR = 38;\nconst int KEY_RT_ARR = 39;\nconst int KEY_DN_ARR = 40;\n\n//----------------------------------------------------------------------------------------------------------\n// GAME STATES\n//----------------------------------------------------------------------------------------------------------\nconst int GAME_STATE_LOGO_SCREEN  = 0;\nconst int GAME_STATE_START_SCREEN = 1;\nconst int GAME_STATE_CAVE         = 2;\n\n//----------------------------------------------------------------------------------------------------------\n// CAVE STATES\n//----------------------------------------------------------------------------------------------------------\nconst int CAVE_STATE_FADE_IN     = 1;\nconst int CAVE_STATE_SPAWNING    = 2;\nconst int CAVE_STATE_ALIVE       = 4;\nconst int CAVE_STATE_EXIT_OPENED = 8;\nconst int CAVE_STATE_EXITED      = 16;\nconst int CAVE_STATE_PAUSED      = 32;\nconst int CAVE_STATE_TIME_OUT    = 64;\nconst int CAVE_STATE_GAME_OVER   = 128;\nconst int CAVE_STATE_FADE_OUT    = 256;\n\nconst int CAVE_STATE_INIT        = CAVE_STATE_FADE_IN | CAVE_STATE_SPAWNING | CAVE_STATE_ALIVE;\n\nbool isState(const int state, const int value)\n{\n    return (state & value) > 0;\n}\n\nvoid setState(inout int state, const int value)\n{\n    state = state | value;\n}\n\nvoid delState(inout int state, const int value)\n{\n    state = state & ~value;\n}\n\n//----------------------------------------------------------------------------------------------------------\n// DIRECTIONS\n//----------------------------------------------------------------------------------------------------------\nconst ivec2 DIR_NONE  = ivec2( 0,  0);\nconst ivec2 DIR_UP    = ivec2( 0,  1);\nconst ivec2 DIR_RT    = ivec2( 1,  0);\nconst ivec2 DIR_DN    = ivec2( 0, -1);\nconst ivec2 DIR_LT    = ivec2(-1,  0);\nconst ivec2 DIR_RT_UP = DIR_RT + DIR_UP;\nconst ivec2 DIR_RT_DN = DIR_RT + DIR_DN;\nconst ivec2 DIR_LT_DN = DIR_LT + DIR_DN;\nconst ivec2 DIR_LT_UP = DIR_LT + DIR_UP;\nconst ivec2 DIR_DN2   = DIR_DN + DIR_DN;\n\nconst ivec2[4] DIRS = ivec2[4](DIR_LT, DIR_UP, DIR_RT, DIR_DN);\nconst int DIR_TURN_LT   = -1;\nconst int DIR_TURN_RT   =  1;\nconst int DIR_TURN_NONE =  0;\n\nconst ivec2[8] LINE_DIRS = ivec2[8](ivec2(0, -1), ivec2(1, -1), ivec2(1, 0), ivec2(1, 1), ivec2(0, 1), ivec2(-1, 1), ivec2(-1, 0), ivec2(-1, -1));\n\n//----------------------------------------------------------------------------------------------------------\n// DATA COORDS\n//----------------------------------------------------------------------------------------------------------\n\nconst ivec2 TX_DATA_RECT        = ivec2(CAV_SIZ.x - 1, CAV_SIZ.y);  // last useful coordinates\nconst ivec2 TX_CAVE             = ivec2(CAV_SIZ.x - 1, CAV_SIZ.y - 1);  // top-right corner of cave data area\nconst ivec2 TX_GAME_DATA        = ivec2( 0, CAV_SIZ.y);  // GameData: gGameState, gCave, gLevel, gLives\nconst ivec2 TX_GAME_FRAMES      = ivec2( 1, CAV_SIZ.y);  // GameData: gFrames ivec2(animFrameLast, gameFrameLast), gScore, gHighScore\nconst ivec2 TX_CAVE_STATE       = ivec2( 2, CAV_SIZ.y);  // CaveData: gCaveState, gFade, gIsStripes, cAmoebaMagWallTime\nconst ivec2 TX_CAVE_TIME        = ivec2( 3, CAV_SIZ.y);  // CaveData: gStartFrame, gAuxFrame, gTimeLeft, gMagicWallStarted\nconst ivec2 TX_CAVE_COLOR0      = ivec2( 4, CAV_SIZ.y);  //\nconst ivec2 TX_CAVE_COLOR1      = ivec2( 5, CAV_SIZ.y);  //\nconst ivec2 TX_CAVE_COLOR2      = ivec2( 6, CAV_SIZ.y);  //\nconst ivec2 TX_DIAMONDS         = ivec2( 7, CAV_SIZ.y);  // CaveData: gDiamondsRequired, cDiamondValue, cDiamondBonusValue, gDiamondsHarvested\nconst ivec2 TX_PLAYER           = ivec2( 8, CAV_SIZ.y);  // CaveData: ivec2 gPlayerCoord, gAmoebaState, gFlashAlpha\nconst ivec2 TX_CAMERA           = ivec2( 9, CAV_SIZ.y);  // CaveData: vec4 gCamPos\n\n//----------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//----------------------------------------------------------------------------------------------------------\n\n#define lerp(v0, v1, t)   mix(v0, v1, t)\n#define remaps(x0, x1, y0, y1, v)   saturate(remap(x0, x1, y0, y1, v))\n#define saturate(x)   clamp(x, 0.0, 1.0)\n\n#define REMAP_FORMULA   (y1 - y0) / (x1 - x0) * (v - x0) + y0\nfloat remap(float x0, float x1, float y0, float y1, float v) {return REMAP_FORMULA;}\nvec2  remap(vec2 x0, vec2 x1, vec2 y0, vec2 y1, vec2 v)      {return REMAP_FORMULA;}\nvec3  remap(vec3 x0, vec3 x1, vec3 y0, vec3 y1, vec3 v)      {return REMAP_FORMULA;}\nvec4  remap(vec4 x0, vec4 x1, vec4 y0, vec4 y1, vec4 v)      {return REMAP_FORMULA;}\n\nint   modint(  int x,   int m) {return (x % m + m) % m;}\nivec2 modint(ivec2 x, ivec2 m) {return (x % m + m) % m;}\nivec3 modint(ivec3 x, ivec3 m) {return (x % m + m) % m;}\nivec4 modint(ivec4 x, ivec4 m) {return (x % m + m) % m;}\n\n\nfloat rand21(vec2 p)\n{\n    p = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n//----------------------------------------------------------------------------------------------------------\n// MISC\n//----------------------------------------------------------------------------------------------------------\n\n#define COLOR01(c)   vec3(c) / vec3(255)\n\n#define CaveStateArr   ivec4[CAV_SIZ.x * CAV_SIZ.y]\n#define getCell(cave, coord)         cave[coordToCaveStateArrIndex(coord)]\n#define setCell(cave, coord, cell)   cave[coordToCaveStateArrIndex(coord)] = cell\n\nconst float ANIM_FRAME_DURATION        = 0.04 * 1.0;\nconst int   ANIM_FRAMES_IN_GAME_FRAME  = 3;\nconst int   GAME_FRAMES_PER_SECOND     = int(1.0 / ANIM_FRAME_DURATION) / ANIM_FRAMES_IN_GAME_FRAME;\nconst float CAMERA_PAN_PER_ANIM_FRAME  = 0.27;\nconst int   EXPLOSION_DURATION_GF      = 3;  // in game frames\nconst float ENTRANCE_DURATION_SEC      = 3.4; // entrance delay in seconds\nconst int   ENTRANCE_DURATION_AF       = int(ENTRANCE_DURATION_SEC / ANIM_FRAME_DURATION); // entrance delay in anim frames\nconst int   ENTRANCE_DURATION_GF       = ENTRANCE_DURATION_AF / ANIM_FRAMES_IN_GAME_FRAME; // entrance delay in game frames\nconst float FADE_IN_DURATION_SEC       = 1.7;   // fade duration in seconds\nconst float FADE_IN_DELTA              = ANIM_FRAME_DURATION / FADE_IN_DURATION_SEC;   // value per anim frame\nconst float FADE_OUT_DURATION_SEC      = 0.52;   // fade duration in seconds\nconst float FADE_OUT_DELTA             = ANIM_FRAME_DURATION / FADE_OUT_DURATION_SEC;   // value per anim frame\nconst float EXIT_COOLDOWN_SEC          = 1.4; // time after score transfered until fade out\nconst int   EXIT_COOLDOWN_AF           = int(EXIT_COOLDOWN_SEC / ANIM_FRAME_DURATION);\nconst float DEATH_COOLDOWN_SEC         = 1.4; // time after death until listening to fire button to fade out\nconst int   DEATH_COOLDOWN_AF          = int(DEATH_COOLDOWN_SEC / ANIM_FRAME_DURATION);\nconst float GAME_OVER_COOLDOWN_SEC     = 3.0; // time when game over and you clicked fire until fade out. actually 1.4\nconst int   GAME_OVER_COOLDOWN_AF      = int(GAME_OVER_COOLDOWN_SEC / ANIM_FRAME_DURATION);\nconst int   INT_MAX                    = 0x7FFFFFFF; // +2,147,483,647\nconst int   INIT_CAM_OFFSET            = 8; // maximum camera offset from player position on cave init\nconst int   NUMBER_OF_LIVES            = 3;\nconst float STRIPES_DURATION_SEC       = 2.56;\nconst float STRIPES_DELTA              = ANIM_FRAME_DURATION / STRIPES_DURATION_SEC;\nconst int   SCROLL_SPEED               = 2;\n\nconst int   AMOEBA_OVERCOOKED_NUM = 200 / 1;\nconst float AMOEBA_SLOW_PROB      = 4.0 / 128.0;\nconst float AMOEBA_FAST_PROB      = 0.25;\n\n\nconst int MWALL_STATE_DORMANT = 0;\nconst int MWALL_STATE_ACTIVE  = 1;\nconst int MWALL_STATE_EXPIRED = 2;\n\nconst int AMOEBA_STATE_GROWING    = 0;\nconst int AMOEBA_STATE_COOKED     = 1;\nconst int AMOEBA_STATE_OVERCOOKED = 2;\n\nconst int ROCKFORD_STATE_LT   = 0;\nconst int ROCKFORD_STATE_RT   = 1;\nconst int ROCKFORD_STATE_IDLE = 2;\n\nconst int ROCKFORD_ANIM_LENGTH = 8;\nconst int ROCKFORD_IDLE_COOLDOWN = 4;\n\nconst vec3 FLASH_COLOR = COLOR01(ivec3(224, 224, 224));\n\n//----------------------------------------------------------------------------------------------------------\n// GAME AND CAVE DATA STRUCTURES\n//----------------------------------------------------------------------------------------------------------\nstruct GameData\n{\n    int   gGameState;  // [W]: Global game state: 0=logo screen, 1=cave selection screen, 2=playing cave\n    int   gScore;      // [W]\n    int   gHighScore;  // [W]\n    int   gCave;       // [W]: current cave playing or selected (1-base cause we need negatives for init state)\n    int   gLevel;      // [W]: difficulty level 1-5\n    int   gLives;      // [W]: number of lives\n    ivec4 gFrames;     // [W]: animFrameLast, gameFrameLast, animFrame, gameFrame\n    bool  gIsCaveInit; // [W]: Init flag for the cave. Will be converted to negative value for gCave on save\n};\n\nstruct CaveData\n{\n    // Cave Constants\n    vec3  cColor0;            // [W]: Cave Color 1\n    vec3  cColor1;            // [W]: Cave Color 2\n    vec3  cColor2;            // [W]: Cave Color 3\n    ivec4 cDiamondsNeeded;    // diamonds needed for levels 1-4\n    int   cDiamondsNeeded5;   // diamonds needed for level 5\n    int   cDiamondValue;      // [W]: write needed for render\n    int   cDiamondBonusValue; // [W]: write needed for render\n    int   cAmoebaMagWallTime; // [W]: Amoeba slow growth time at 3% in seconds || Magic Wall active time in seconds\n    ivec4 cCaveTime;          // Cave time in seconds for levels 1-4\n    int   cCaveTime5;         // Cave time in seconds for level 5\n\n    // Cave Globals\n    int   gCaveState;         // [W]: Cave state: spawning, alive, dead, exited\n    int   gStartFrame;        // [W]: When cave was started in global anim frames.\n    int   gAuxFrame;          // [W]: Some auxiliary anim frame. Needed death time, exit time, etc.\n    vec4  gCamPos;            // [W] Camera position in world space for last updated frame, target camera position\n    ivec2 gPlayerCoord;       // [W]: Coords of player\n    float gTimeLeft;          // [W]: Time left in seconds\n    int   gDiamondsHarvested; // [W]\n    int   gDiamondsRequired;  // [W]: write needed for render\n    int   gMagicWallStarted;  // [W] When magic started in cave game frame time\n    float gFade;              // [W] Cave fade value, Fade In during cave start and fade out when cave finished.\n    int   gAmoebaState;       // [W]\n    float gStripesAlpha;      // [W] stipes alpha.\n    float gFlashAlpha;        // [W] flash alpha.\n\n    ivec4 cellState; // [W]\n};\n\n//----------------------------------------------------------------------------------------------------------\n// CAVE CONSTANTS\n//----------------------------------------------------------------------------------------------------------\n\nconst CaveData cd1 = CaveData( // flash is correct\n    COLOR01(ivec3(159, 82, 3)), COLOR01(ivec3(96, 96, 96)), COLOR01(ivec3(192, 192, 192)),\n    ivec4(12, 12, 12, 12), 12, 10, 15, 20, ivec4(150, 110, 70, 40), 30,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(3, 19), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd2 = CaveData( // flash is correct\n    COLOR01(ivec3(106, 33, 120)), COLOR01(ivec3(59, 83, 255)), COLOR01(ivec3(175, 223, 70)),\n    ivec4(10, 12, 9, 13), 10, 20, 50, 20, ivec4(150, 110, 70, 70), 70,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(18, 2), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd3 = CaveData(\n    COLOR01(ivec3(47, 95, 0)), COLOR01(ivec3(138, 65, 152)), COLOR01(ivec3(234, 161, 248)),\n    ivec4(24, 23, 24, 23), 21, 15, 0, 0, ivec4(150, 100, 90, 80), 70,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(3, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd4 = CaveData(\n    COLOR01(ivec3(27, 51, 237)), COLOR01(ivec3(154, 70, 76)), COLOR01(ivec3(250, 166, 172)),\n    ivec4(36, 36, 36, 36), 36, 5, 20, 20, ivec4(120, 100, 80, 60), 50,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(1, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd5 = CaveData(\n    COLOR01(ivec3(59, 83, 255)), COLOR01(ivec3(106, 33, 120)), COLOR01(ivec3(155, 179, 255)),\n    ivec4(6, 6, 6, 6), 6, 30, 0, 20, ivec4(10, 10, 10, 10), 10,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(3, 18), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd6 = CaveData( // flash is correct\n    COLOR01(ivec3(120, 64, 0)), COLOR01(ivec3(113, 65, 218)), COLOR01(ivec3(234, 161, 248)),\n    ivec4(4, 5, 6, 7), 8, 50, 90, 20, ivec4(150, 120, 90, 60), 30,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(1, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd7 = CaveData(\n    COLOR01(ivec3(8, 64, 212)), COLOR01(ivec3(138, 65, 152)), COLOR01(ivec3(192, 192, 192)),\n    ivec4(4, 6, 7, 8), 8, 40, 60, 20, ivec4(150, 120, 100, 90), 80,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(3, 3), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd8 = CaveData(\n    COLOR01(ivec3(127, 50, 0)), COLOR01(ivec3(138, 65, 152)), COLOR01(ivec3(250, 166, 172)),\n    ivec4(15, 20, 25, 25), 25, 10, 20, 75, ivec4(120, 120, 120, 120), 120,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(20, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd9 = CaveData(\n    COLOR01(ivec3(122, 38, 44)), COLOR01(ivec3(33, 110, 189)), COLOR01(ivec3(155, 179, 255)),\n    ivec4(10, 15, 20, 20), 20, 10, 20, 20, ivec4(120, 110, 100, 90), 80,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(20, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd10 = CaveData(\n    COLOR01(ivec3(27, 51, 237)), COLOR01(ivec3(128, 128, 128)), COLOR01(ivec3(255, 178, 99)),\n    ivec4(16, 16, 16, 16), 16, 10, 0, 20, ivec4(15, 15, 15, 15), 15,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(1, 19), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd11 = CaveData(\n    COLOR01(ivec3(154, 70, 76)), COLOR01(ivec3(59, 83, 255)), COLOR01(ivec3(155, 179, 255)),\n    ivec4(75, 75, 80, 85), 90, 5, 10, 20, ivec4(150, 150, 130, 130), 120,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(7, 11), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd12 = CaveData(\n    COLOR01(ivec3(8, 64, 212)), COLOR01(ivec3(159, 82, 3)), COLOR01(ivec3(192, 192, 192)),\n    ivec4(12, 12, 12, 12), 12, 25, 60, 20, ivec4(150, 130, 120, 110), 100,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(13, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd13 = CaveData(\n    COLOR01(ivec3(64, 64, 64)), COLOR01(ivec3(159, 82, 3)), COLOR01(ivec3(255, 178, 99)),\n    ivec4(6, 6, 6, 6), 6, 50, 0, 20, ivec4(120, 120, 150, 150), 240,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(20, 3), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd14 = CaveData(\n    COLOR01(ivec3(127, 50, 0)), COLOR01(ivec3(138, 65, 152)), COLOR01(ivec3(250, 166, 172)),\n    ivec4(19, 19, 14, 16), 21, 20, 0, 20, ivec4(180, 170, 160, 160), 160,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(3, 3), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd15 = CaveData(\n    COLOR01(ivec3(59, 83, 255)), COLOR01(ivec3(154, 70, 76)), COLOR01(ivec3(155, 179, 255)),\n    ivec4(14, 14, 14, 14), 14, 10, 0, 4, ivec4(20, 20, 20, 20), 20,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(8, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd16 = CaveData(\n    COLOR01(ivec3(27, 51, 237)), COLOR01(ivec3(159, 82, 3)), COLOR01(ivec3(255, 178, 99)),\n    ivec4(50, 55, 60, 70), 80, 5, 8, 140, ivec4(160, 155, 150, 145), 140,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(18, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd17 = CaveData(\n    COLOR01(ivec3(96, 96, 96)), COLOR01(ivec3(159, 82, 3)), COLOR01(ivec3(248, 192, 44)),\n    ivec4(30, 35, 40, 42), 45, 10, 20, 20, ivec4(150, 145, 140, 135), 130,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(3, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd18 = CaveData(\n    COLOR01(ivec3(154, 70, 76)), COLOR01(ivec3(59, 83, 255)), COLOR01(ivec3(155, 179, 255)),\n    ivec4(15, 20, 20, 25), 30, 10, 20, 8, ivec4(120, 120, 120, 120), 140,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(20, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd19 = CaveData(\n    COLOR01(ivec3(127, 50, 0)), COLOR01(ivec3(113, 65, 218)), COLOR01(ivec3(255, 178, 99)),\n    ivec4(12, 15, 15, 15), 12, 10, 20, 20, ivec4(150, 150, 150, 150), 150,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(1, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);\nconst CaveData cd20 = CaveData(\n    COLOR01(ivec3(27, 51, 237)), COLOR01(ivec3(154, 70, 76)), COLOR01(ivec3(155, 179, 255)),\n    ivec4(6, 6, 6, 6), 6, 30, 0, 3, ivec4(20, 20, 20, 20), 20,\n    CAVE_STATE_INIT, 0, INT_MAX, vec4(0.0), ivec2(3, 20), 0.0, 0, 0, INT_MAX, 1.0, AMOEBA_STATE_GROWING, 0.0, 0.0, CELL_VOID4\n);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//----------------------------------------------------------------------------------------------------------\n// MAP DEFINITIONS\n//----------------------------------------------------------------------------------------------------------\nconst int csz = 32;\nconst uint cave1[csz] = uint[csz](0xd0c0b0au,0x1410000eu,0x9323c00u,0x9014200u,0x942021eu,0x25021e10u,0x26040403u,0xffffff12u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave2[csz] = uint[csz](0x57010003u,0x14100058u,0x9323c08u,0x8014202u,0x1420226u,0x4202260fu,0x4140308u,0x14031042u,0x3184204u,0x20420414u,0x40041403u,0x2260501u,0x260b0140u,0x12014002u,0x14400226u,0x25041403u,0x12041512u,0xffffff16u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave3[csz] = uint[csz](0x34363200u,0x14100237u,0x9326400u,0x4032500u,0xff142704u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave4[csz] = uint[csz](0x73706e00u,0x1077u,0x1400u,0x3012500u,0x81162604u,0x4040a08u,0xb0a3000u,0x40a1081u,0x12300004u,0xa18810bu,0x30000404u,0x20810b1au,0x4040au,0xff0b2230u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave5[csz] = uint[csz](0xd0c0b0au,0x14000eu,0x9ff00u,0x2008700u,0x87071628u,0xc140200u,0xc0a3000u,0x1040a10u,0x325050au,0xc120405u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave6[csz] = uint[csz](0x0u,0x0u,0x0u,0x3012500u,0x80162704u,0x3030a08u,0xa108000u,0x80000303u,0x3030a18u,0xa208000u,0x14000303u,0xa080c09u,0xc11140au,0x140a1208u,0x1a080c19u,0xc21140au,0x800a2208u,0x3031008u,0x10108000u,0x80000303u,0x3031018u,0x10208000u,0x14000303u,0xa081209u,0x12111410u,0x14101208u,0x1a081219u,0x12211410u,0xff102208u,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave7[csz] = uint[csz](0x16151400u,0x1017u,0x3200u,0x3018200u,0x8200040au,0x40a0601u,0x9018200u,0x8200040au,0x40a0c01u,0x30a4100u,0x314040du,0x5040805u,0x8080314u,0x3140804u,0xb04080bu,0x80e0314u,0x1d820e04u,0x40a03u,0xa061d82u,0x1d820004u,0x40a09u,0xa0c1d82u,0x1d410004u,0x14040d03u,0x23080524u,0x8241405u,0x14082308u,0x23080b24u,0xe24140bu,0x250e2308u,0x26041403u,0xffffff14u);\nconst uint cave8[csz] = uint[csz](0xa080702u,0x8100009u,0x2286400u,0x7014200u,0x1c42020cu,0x7a020b05u,0x2021513u,0x14060414u,0x4140e04u,0x4221416u,0x140c2214u,0x14251622u,0x7270403u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave9[csz] = uint[csz](0x5040301u,0x8100006u,0x2325a00u,0x6041400u,0x14042214u,0x40c22u,0x3142505u,0xc070142u,0xf014202u,0x1c42020cu,0x42020b05u,0x20b0d1cu,0x8110e43u,0x100c1402u,0x14120e00u,0xe411213u,0xff02080fu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave10[csz] = uint[csz](0xd0c0b0au,0xeu,0x0u,0x2008700u,0x87071628u,0xc140200u,0x3015001u,0x2480309u,0x54030803u,0x3080501u,0x7060150u,0x3125003u,0x12540509u,0x50050805u,0x5070612u,0x4040125u,0xffff0412u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave11[csz] = uint[csz](0xfb8c8964u,0x141033u,0x78f000u,0xa058200u,0x1000d0du,0x19820a0cu,0xd0d0au,0x420a1f01u,0x2091211u,0x9131140u,0xc072502u,0xff0c0804u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave12[csz] = uint[csz](0x0u,0x0u,0x0u,0x30d2500u,0x54162704u,0x3110405u,0x11041554u,0xb058005u,0xc2080311u,0x11150401u,0xc2040d00u,0xd0d0607u,0xc2060d00u,0x9090809u,0xc2080d00u,0x5050a0bu,0x820a0d00u,0xf030603u,0x6040008u,0x4100454u,0xffffff04u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave13[csz] = uint[csz](0x97660400u,0x8100064u,0x2506400u,0x30a4200u,0x14420409u,0x42040903u,0x409031eu,0x9160942u,0xf0c4200u,0x5420211u,0x4202090bu,0x2090b0fu,0x90b1942u,0x131c4202u,0x414010bu,0x30e1403u,0x14031814u,0x4140322u,0x15231416u,0x4141425u,0xffff1126u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave14[csz] = uint[csz](0x3b023c00u,0x14100066u,0x9323c00u,0x50a4200u,0xe420412u,0x42041205u,0x4120512u,0x12051642u,0x6024204u,0x242020bu,0x42020b0au,0x20f0e02u,0xb120242u,0x41e8102u,0x8000404u,0x1e810520u,0x40409u,0x810a2008u,0x4040e1eu,0xf200800u,0x4140325u,0xffff1627u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave15[csz] = uint[csz](0xd0c0b0au,0xeu,0x0u,0x2008700u,0x87071628u,0xc140200u,0xc015400u,0xf880212u,0x8040409u,0x4030825u,0xffff0712u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave16[csz] = uint[csz](0x3020100u,0x1004u,0x2800u,0x3122500u,0x3a030a04u,0x5420314u,0x70021e12u,0x21e1305u,0x1e140550u,0x1505c102u,0xffff021eu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave17[csz] = uint[csz](0x0u,0x1000u,0x0u,0xa0a8100u,0x70000d0du,0x30c0b0bu,0x30a0cc1u,0xa10c10du,0x14c10d03u,0x500d030au,0x20c0816u,0xc071648u,0x617c102u,0x1bc10403u,0xc1040306u,0x403061fu,0x4030325u,0xffff1427u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave18[csz] = uint[csz](0x1f1e1d01u,0x8100020u,0x2506400u,0x4024200u,0xf42030au,0x41010a0du,0x2030e0cu,0x30f0c43u,0x16140402u,0xff031425u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave19[csz] = uint[csz](0x7e817801u,0x107bu,0x3200u,0x3012500u,0x81042704u,0x4041308u,0x140a0800u,0x60a07c2u,0xa074308u,0x10810206u,0x40413u,0xc2141208u,0x8060a0fu,0x60a0f43u,0x13188102u,0x8000404u,0x2081141au,0x40413u,0xff142208u,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\nconst uint cave20[csz] = uint[csz](0x0u,0x0u,0x0u,0x2008700u,0x87071628u,0xc140200u,0x30bd001u,0xb800203u,0x60307u,0x3060b43u,0xa0b4302u,0x8500203u,0x25030307u,0x9040303u,0xffffff0au,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu,0xffffffffu);\n\n//----------------------------------------------------------------------------------------------------------\n\nstruct Fuse\n{\n    int type;\n    ivec2 coord;\n};\n\nstruct JoystickState\n{\n    ivec2 dir;\n    bool  isFirePressed;\n};\n\nJoystickState getJoystickState()\n{\n    JoystickState res;\n    res.isFirePressed = KEY_DOWN(KEY_CTRL);\n\n    res.dir = ivec2(0);\n    res.dir += KEY_DOWN(KEY_LT_ARR) ? DIR_LT : DIR_NONE;\n    res.dir += KEY_DOWN(KEY_UP_ARR) ? DIR_UP : DIR_NONE;\n    res.dir += KEY_DOWN(KEY_RT_ARR) ? DIR_RT : DIR_NONE;\n    res.dir += KEY_DOWN(KEY_DN_ARR) ? DIR_DN : DIR_NONE;\n    res.dir *= res.dir.x != 0 ? ivec2(1, 0) : ivec2(0, 1);  // horizontal is in priority\n\n    return res;\n}\n\nvoid storeObject(ivec2 c, ivec2 cCurr, int o, inout int v)\n{\n    v = (all(equal(c, cCurr))) ? o : v;\n}\n\nvoid drawLine(ivec2 c, ivec2 cCurr, int o, inout int v, int length, int dir)\n{\n    for (int i=1; i<=length; i++) {\n        storeObject(c, cCurr, o, v);\n        c += LINE_DIRS[dir];\n    }\n}\n\nvoid drawRect(ivec2 c, ivec2 cCurr, int o, inout int v, int width, int height, int oFill)\n{\n    for (int i=0; i<width; i++)\n    {\n        for (int j=0; j<height; j++)\n        {\n            ivec2 c2 = ivec2(c.x + i, c.y + j);\n            if ((i == 0) || (j == 0) || (i == (width - 1)) || (j == (height - 1)))\n            {\n                storeObject(c2, cCurr, o, v);\n            }\n            else if (oFill >= 0)\n            {\n                storeObject(c2, cCurr, oFill, v);\n            }\n        }\n    }\n}\n\nvoid nextRandom(inout int randSeed1, inout int randSeed2)\n{\n    int tempRand1;\n    int tempRand2;\n    int carry;\n    int result;\n\n    tempRand1 = (randSeed1 & 0x00000001) * 0x00000080;\n    tempRand2 = (randSeed2 >> 1) & 0x0000007F;\n    result = (randSeed2) + (randSeed2 & 0x00000001) * 0x00000080;\n    carry = (result > 0x000000FF) ? 1 : 0;\n    result = result & 0x000000FF;\n    result = result + carry + 0x13;\n    carry = (result > 0x000000FF) ? 1 : 0;\n    randSeed2 = result & 0x000000FF;\n    result = randSeed1 + carry + tempRand1;\n    carry = (result > 0x000000FF) ? 1 : 0;\n    result = result & 0x000000FF;\n    result = result + carry + tempRand2;\n    randSeed1 = result & 0x000000FF;\n}\n\nint decCave(uint cave[csz], int i)\n{\n    return int((cave[clamp(i / 4, 0, csz-1)] >> (8 * (i % 4))) & 0xFFu);\n}\n\nint generateCave(ivec2 c, int caveIndex, int level)\n{\n    c.y = -c.y + CAV_SIZ.y + 1;\n    int res = CELL_INVALID;\n\n    uint cave[csz];\n    if (caveIndex == 1)  cave = cave1;\n    if (caveIndex == 2)  cave = cave2;\n    if (caveIndex == 3)  cave = cave3;\n    if (caveIndex == 4)  cave = cave4;\n    if (caveIndex == 5)  cave = cave5;\n    if (caveIndex == 6)  cave = cave6;\n    if (caveIndex == 7)  cave = cave7;\n    if (caveIndex == 8)  cave = cave8;\n    if (caveIndex == 9)  cave = cave9;\n    if (caveIndex == 10) cave = cave10;\n    if (caveIndex == 11) cave = cave11;\n    if (caveIndex == 12) cave = cave12;\n    if (caveIndex == 13) cave = cave13;\n    if (caveIndex == 14) cave = cave14;\n    if (caveIndex == 15) cave = cave15;\n    if (caveIndex == 16) cave = cave16;\n    if (caveIndex == 17) cave = cave17;\n    if (caveIndex == 18) cave = cave18;\n    if (caveIndex == 19) cave = cave19;\n    if (caveIndex == 20) cave = cave20;\n\n    int randSeed1 = 0;\n    int randSeed2 = decCave(cave, level - 1);\n\n    // fill all with titanium\n    for(int x=0; x<40; x++)\n    {\n        for (int y=0; y<=23; y++)\n        {\n            storeObject(ivec2(x, y), c, CELL_TITAN_WALL, res);\n        }\n    }\n\n    // random cave cells\n    for(int y=3; y<=23; y++)\n    {\n        for(int x=0; x<=39; x++)\n        {\n            int obj = CELL_DIRT;\n            nextRandom(randSeed1, randSeed2);\n            for (int i=0; i<=3; i++)\n            {\n                if (randSeed1 < decCave(cave, 9 + i))\n                {\n                    obj = decCave(cave, 5 + i);\n                }\n            }\n            storeObject(ivec2(x, y), c, obj, res);\n        }\n    }\n\n    // titanium border\n    drawRect(ivec2(0, 2), c, CELL_TITAN_WALL, res, CAV_SIZ.x, CAV_SIZ.y, CELL_NO_FILL);\n\n    // explicitly placed cells\n    for (int i=13; decCave(cave, i) != 0xFF; i++)\n    {\n        int code = decCave(cave, i);\n        int obj = code & 0x3F;\n\n        switch(3 & (code >> 6))\n        {\n            case 0: // single cell\n                storeObject(ivec2(decCave(cave, ++i), decCave(cave, ++i)), c, obj, res);\n                break;\n\n            case 1: // line\n                drawLine(ivec2(decCave(cave, ++i), decCave(cave, ++i)), c, obj, res, decCave(cave, ++i), decCave(cave, ++i));\n                break;\n\n            case 2: // filled rectangle\n                drawRect(ivec2(decCave(cave, ++i), decCave(cave, ++i)), c, obj, res, decCave(cave, ++i), decCave(cave, ++i), decCave(cave, ++i));\n                break;\n\n            case 3: // rectangle\n                drawRect(ivec2(decCave(cave, ++i), decCave(cave, ++i)), c, obj, res, decCave(cave, ++i), decCave(cave, ++i), CELL_NO_FILL);\n                break;\n        }\n    }\n\n    return res;\n}\n//----------------------------------------------------------------------------------------------------------\n// FUNCTIONS FOR GAME AND RENDER\n//----------------------------------------------------------------------------------------------------------\n\nbool isInCave(ivec2 coord)\n{\n    return (coord.x >= 0) && (coord.x <= TX_CAVE.x) && (coord.y >= 0) && (coord.y <= TX_CAVE.y);\n}\n\nvec4 loadValue(ivec2 coord)\n{\n    return texelFetch(iChannel0, coord, 0);\n}\n\nivec4 loadCaveValue(ivec2 uvi)  // for cave cells\n{\n    return isInCave(uvi) ? ivec4(loadValue(uvi)) : ivec4(0);\n}\n\nvoid loadCaveData(inout CaveData cd, ivec2 uvi)\n{\n    vec4 v;\n\n    v = loadValue(TX_CAVE_STATE);\n    cd.gCaveState = int(v.r);\n    cd.gFade = v.g;\n    cd.gStripesAlpha = v.b;\n    cd.cAmoebaMagWallTime = int(v.a);\n\n    v = loadValue(TX_CAVE_TIME);\n    cd.gStartFrame = int(v.r);\n    cd.gAuxFrame = int(v.g);\n    cd.gTimeLeft = v.b;\n    cd.gMagicWallStarted = int(v.a);\n\n    v = loadValue(TX_CAVE_COLOR0);\n    cd.cColor0 = v.rgb;\n\n    v = loadValue(TX_CAVE_COLOR1);\n    cd.cColor1 = v.rgb;\n\n    v = loadValue(TX_CAVE_COLOR2);\n    cd.cColor2 = v.rgb;\n\n    v = loadValue(TX_DIAMONDS);\n    cd.gDiamondsRequired = int(v.r);\n    cd.cDiamondValue = int(v.g);\n    cd.cDiamondBonusValue = int(v.b);\n    cd.gDiamondsHarvested = int(v.a);\n\n    v = loadValue(TX_PLAYER);\n    cd.gPlayerCoord = ivec2(v.rg);\n    cd.gAmoebaState = int(v.b);\n    cd.gFlashAlpha = v.a;\n\n    v = loadValue(TX_CAMERA);\n    cd.gCamPos = v;\n\n    cd.cellState = loadCaveValue(uvi);\n}\n\nvoid loadGameData(inout GameData gd)\n{\n    vec4 v;\n\n    v = loadValue(TX_GAME_DATA);\n    gd.gGameState = int(v.r);\n    gd.gCave = abs(int(v.g));\n    gd.gIsCaveInit = v.g < 0.0;\n    gd.gLevel = int(v.b);\n    gd.gLives = int(v.a);\n\n    v = loadValue(TX_GAME_FRAMES);\n    gd.gFrames = ivec4(int(v.r), int(v.g), 0, 0);\n    gd.gScore = int(v.b);\n    gd.gHighScore = int(v.a);\n}\n\n//----------------------------------------------------------------------------------------------------------\n\nvoid saveValue(ivec2 coord, vec4 v, inout vec4 fragColor, ivec2 uvi)\n{\n    fragColor = (coord == uvi) ? v : fragColor;\n}\n\nvoid saveCaveValue(ivec4 v, inout vec4 fragColor, ivec2 uvi)\n{\n    fragColor = isInCave(uvi) ? vec4(v) : fragColor;\n}\n\nvoid saveCaveData(CaveData cd, inout vec4 fragColor, ivec2 uvi)\n{\n    vec4 o;\n\n    o.r = float(cd.gCaveState);\n    o.g = cd.gFade;\n    o.b = cd.gStripesAlpha;\n    o.a = float(cd.cAmoebaMagWallTime);\n    saveValue(TX_CAVE_STATE, o, fragColor, uvi);\n\n    o.r = float(cd.gStartFrame);\n    o.g = float(cd.gAuxFrame);\n    o.b = cd.gTimeLeft;\n    o.a = float(cd.gMagicWallStarted);\n    saveValue(TX_CAVE_TIME, o, fragColor, uvi);\n\n    o = vec4(cd.cColor0, 0.0);\n    saveValue(TX_CAVE_COLOR0, o, fragColor, uvi);\n\n    o = vec4(cd.cColor1, 0.0);\n    saveValue(TX_CAVE_COLOR1, o, fragColor, uvi);\n\n    o = vec4(cd.cColor2, 0.0);\n    saveValue(TX_CAVE_COLOR2, o, fragColor, uvi);\n\n    o.r = float(cd.gDiamondsRequired);\n    o.g = float(cd.cDiamondValue);\n    o.b = float(cd.cDiamondBonusValue);\n    o.a = float(cd.gDiamondsHarvested);\n    saveValue(TX_DIAMONDS, o, fragColor, uvi);\n\n    o = vec4(cd.gPlayerCoord, cd.gAmoebaState, cd.gFlashAlpha);\n    saveValue(TX_PLAYER, o, fragColor, uvi);\n\n    o = cd.gCamPos;\n    saveValue(TX_CAMERA, o, fragColor, uvi);\n\n    saveCaveValue(cd.cellState, fragColor, uvi);\n}\n\nvoid saveGameData(GameData gd, inout vec4 fragColor, ivec2 uvi)\n{\n    vec4 o;\n\n    o.r = float(gd.gGameState);\n    o.g = float(gd.gCave * (gd.gIsCaveInit ? -1 : 1));\n    o.b = float(gd.gLevel);\n    o.a = float(gd.gLives);\n    saveValue(TX_GAME_DATA, o, fragColor, uvi);\n\n    o = vec4(gd.gFrames.xy, gd.gScore, gd.gHighScore);\n    saveValue(TX_GAME_FRAMES, o, fragColor, uvi);\n}\n\nvec2 getCamTargetPos(ivec2 playerCoord)\n{\n    vec2 margins = GAM_RES_F / CEL_RES_F / 2.0;\n    return clamp(vec2(playerCoord) + vec2(0.5), margins, CAV_SIZ_F - margins);\n}\n\nvec4 initCamPos(ivec2 pc)\n{\n    ivec2 dir;\n    dir.x = (pc.x > (CAV_SIZ.x / 2)) ? -1 : 1;\n    dir.y = (pc.y > (CAV_SIZ.y / 2)) ? -1 : 1;\n    ivec2 camPos = pc + ivec2(INIT_CAM_OFFSET * 2, INIT_CAM_OFFSET) * dir;\n    return vec4(getCamTargetPos(camPos), getCamTargetPos(pc));\n}\n\nvec4 updateCameraPos(inout vec4 camPos, ivec2 playerCoord)\n{\n    const vec2 threshold = vec2(6.0, 2.0);\n    vec2 camPosTarget = getCamTargetPos(playerCoord);\n    vec2 mask = vec2(greaterThan(abs(vec2(playerCoord) + vec2(0.5) - camPos.xy), threshold));\n    camPos.zw = lerp(camPos.zw, camPosTarget, mask);\n\n    vec2 dif = camPos.zw - camPos.xy;\n    vec2 dirIndex = sign(dif);\n    camPos.xy += dirIndex * min(vec2(CAMERA_PAN_PER_ANIM_FRAME), abs(dif));\n\n    return camPos;\n}\n\nbool isIntermission(int caveIndex)\n{\n    return (caveIndex % 5) == 0;\n}\n\nvoid updateCaveAnim(inout int gAuxFrame, inout vec4 gCamPos, inout int gCaveState, inout float gFade, ivec2 gPlayerCoord,\n                    inout float gStripesAlpha, inout float gTimeLeft,\n                    inout GameData gd, inout int scoreToAdd\n                    )\n{\n    bool isIntermissionLevel = isIntermission(gd.gCave);\n    updateCameraPos(gCamPos, gPlayerCoord);\n    gStripesAlpha = max(0.0, gStripesAlpha - STRIPES_DELTA);\n\n    if (!isState(gCaveState, CAVE_STATE_FADE_IN) &&\n        !isState(gCaveState, CAVE_STATE_SPAWNING) &&\n        !isState(gCaveState, CAVE_STATE_EXITED) &&\n        !isState(gCaveState, CAVE_STATE_GAME_OVER) &&\n        !isState(gCaveState, CAVE_STATE_TIME_OUT) &&\n        !isState(gCaveState, CAVE_STATE_PAUSED) &&\n        !isState(gCaveState, CAVE_STATE_FADE_OUT))\n    {\n        gTimeLeft = max(0.0, gTimeLeft - ANIM_FRAME_DURATION);\n        if (gTimeLeft == 0.0)\n        {\n            setState(gCaveState, CAVE_STATE_TIME_OUT);\n            gd.gLives = (isIntermissionLevel || !isState(gCaveState, CAVE_STATE_ALIVE)) ? gd.gLives : gd.gLives - 1;\n            gAuxFrame = gd.gFrames.x;\n        }\n    }\n\n    // cave fade in\n    if (isState(gCaveState, CAVE_STATE_FADE_IN))\n    {\n        gFade = saturate(gFade - FADE_IN_DELTA);\n        if (gFade == 0.0)\n        {\n            delState(gCaveState, CAVE_STATE_FADE_IN);\n        }\n    }\n\n    // transferring time to score when exited\n    if (isState(gCaveState, CAVE_STATE_EXITED) && (gAuxFrame == INT_MAX))\n    {\n        const float scoreIncrement = 2.0;\n        int scoreAddition = int(round(gTimeLeft - max(0.0, gTimeLeft - scoreIncrement)));  // 2 per anim frame, 1 per tv scan\n        gTimeLeft = max(0.0, gTimeLeft - scoreIncrement);\n        scoreToAdd += scoreAddition;\n\n        if (gTimeLeft <= 0.0)\n        {\n            gAuxFrame = gd.gFrames.x;\n        }\n    }\n    else if (!isState(gCaveState, CAVE_STATE_ALIVE) && gAuxFrame == INT_MAX)\n    {\n        if (!isIntermissionLevel)\n        {\n            gd.gLives -= 1;\n        }\n        gAuxFrame = gd.gFrames.x;\n    }\n\n    bool isAuxTimeSet = gAuxFrame != INT_MAX;\n    int auxTimeDelta = gd.gFrames.x - gAuxFrame;\n    bool isFadingOut = false;\n\n    if (!isState(gCaveState, CAVE_STATE_GAME_OVER))\n    {\n        isFadingOut = isFadingOut || (  // Exited\n            isState(gCaveState, CAVE_STATE_EXITED) &&\n            isAuxTimeSet &&\n            (auxTimeDelta > EXIT_COOLDOWN_AF)\n        );\n        isFadingOut = isFadingOut || (  // Player Death\n            !isState(gCaveState, CAVE_STATE_ALIVE) &&\n            isAuxTimeSet &&\n            (auxTimeDelta > DEATH_COOLDOWN_AF) &&\n            KEY_DOWN(KEY_CTRL)\n        );\n        isFadingOut = isFadingOut || (  // Time Out\n            isState(gCaveState, CAVE_STATE_TIME_OUT) &&\n            isAuxTimeSet &&\n            (auxTimeDelta > DEATH_COOLDOWN_AF) &&\n            KEY_DOWN(KEY_CTRL)\n        );\n        if (isFadingOut && (gd.gLives == 0))  // Game Over Start Timer\n        {\n            isFadingOut = false;\n            setState(gCaveState, CAVE_STATE_GAME_OVER);\n            gAuxFrame = gd.gFrames.x;\n            auxTimeDelta = 0;\n        }\n    }\n\n    isFadingOut = isFadingOut || (  // Game Over\n        isState(gCaveState, CAVE_STATE_GAME_OVER) &&\n        (auxTimeDelta > GAME_OVER_COOLDOWN_AF)\n    );\n\n    if (isFadingOut)\n    {\n        setState(gCaveState, CAVE_STATE_FADE_OUT);\n    }\n\n    bool isGameOver = false;\n    bool isNextLevel = false;\n\n    if (isState(gCaveState, CAVE_STATE_FADE_OUT))\n    {\n        gFade = saturate(gFade + FADE_OUT_DELTA);\n        if (gFade == 1.0)\n        {\n            gd.gIsCaveInit = true;\n\n            if (isState(gCaveState, CAVE_STATE_GAME_OVER))\n            {\n                isGameOver = true;\n            }\n            else if (isState(gCaveState, CAVE_STATE_EXITED) || isIntermissionLevel)\n            {\n                isNextLevel = true;\n            }\n        }\n    }\n\n    if (isGameOver)\n    {\n        gd.gLives = NUMBER_OF_LIVES;\n        gd.gCave = 1;\n        gd.gLevel = 1;\n        gd.gGameState = GAME_STATE_START_SCREEN;\n    }\n\n    if (isNextLevel)\n    {\n        gd.gCave += 1;\n        if (gd.gCave > 20)\n        {\n            gd.gCave = 1;\n            gd.gLevel = max(((gd.gLevel + 1) % 6), 1);\n        }\n    }\n}\n\nint coordToCaveStateArrIndex(ivec2 coord)\n{\n    return coord.y * CAV_SIZ.x + coord.x;\n}\n\nbool isUpdateNeeded(ivec4 cell)\n{\n    return cell.w == 0;\n}\n\nbool isAbleToRollOff(ivec4 cellDn)\n{\n    return  (cellDn.x == CELL_BOULDER && cellDn.y == 0) ||\n            (cellDn.x == CELL_DIAMOND && cellDn.y == 0) ||\n             cellDn.x == CELL_WALL;\n}\n\nbool isPushSucceeded(float rand)\n{\n    return fract(rand * 26698.123852) < 1.0 / 8.0;\n}\n\nvoid setFalling(inout ivec4 cell, bool isFalling)\n{\n    cell.y = isFalling ? 1 : 0;\n}\n\nbool isFalling(ivec4 cell)\n{\n    return cell.y == 1;\n}\n\nbool isHitExplosive(ivec4 cell, ivec4 cellDn)\n{\n    return isFalling(cell) &&\n        (\n            cellDn.x == CELL_ROCKFORD ||\n            cellDn.x == CELL_FIREFLY ||\n            cellDn.x == CELL_BUTTERFLY\n        );\n}\n\nvoid setUpdated(inout ivec4 cell, bool isUpdated)\n{\n    cell.w = isUpdated ? 1 : 0;\n}\n\nivec2 getDirection(inout int dirIndex, int turn)\n{\n    dirIndex = modint((dirIndex + turn), 4);\n    return DIRS[dirIndex];\n}\n\nvoid updateCaveGame(\n                    inout int gCaveState,\n                    inout ivec2 gPlayerCoord,\n                    inout ivec4 cellState,\n                    inout int gDiamondsHarvested,\n                    inout int gMagicWallStarted,\n                    inout int gAmoebaState,\n                    inout float flashAlpha,\n                    inout int gAuxFrame,\n                    inout int scoreToAdd,\n\n                    const int cDiamondsRequired,\n                    const int cDiamondValue,\n                    const int cDiamondBonusValue,\n                    const int cAmoebaMagWallTime,\n                    const ivec2 cellCoord,\n                    const int animFrame,\n                    const int gameFrame,\n                    const int gStartFrame,\n\n                    float rand\n                    )\n{\n\n    if (KEY_DOWN(KEY_SPACE))\n    {\n        bool isPaused = isState(gCaveState, CAVE_STATE_PAUSED);\n        if (isPaused)\n        {\n            delState(gCaveState, CAVE_STATE_PAUSED);\n            gAuxFrame = INT_MAX;\n        }\n        else\n        {\n            setState(gCaveState, CAVE_STATE_PAUSED);\n            gAuxFrame = animFrame;\n        }\n    }\n\n    if (isState(gCaveState, CAVE_STATE_FADE_IN) ||\n        isState(gCaveState, CAVE_STATE_EXITED) ||\n        isState(gCaveState, CAVE_STATE_PAUSED) ||\n        isState(gCaveState, CAVE_STATE_TIME_OUT) ||\n        isState(gCaveState, CAVE_STATE_GAME_OVER) ||\n        isState(gCaveState, CAVE_STATE_FADE_OUT))\n    {\n        return;\n    }\n\n    CaveStateArr cave;\n\n    for (int x=0; x<CAV_SIZ.x; x++)\n    {\n        for (int y=0; y<CAV_SIZ.y; y++)\n        {\n            ivec2 coord = ivec2(x, y);\n            ivec4 cell = ivec4(loadValue(coord));\n            cell.w = 0;  // need update\n            setCell(cave, coord, cell);\n        }\n    }\n\n    flashAlpha = max(0.0, flashAlpha - 1.0);\n\n    int mWallStartDelta = gameFrame - gMagicWallStarted;\n    int mWallState = (mWallStartDelta < 0) ? MWALL_STATE_DORMANT :\n                     (mWallStartDelta < (cAmoebaMagWallTime * GAME_FRAMES_PER_SECOND) ) ? MWALL_STATE_ACTIVE : MWALL_STATE_EXPIRED;\n\n    int amoebaNum = 0;\n    bool isAmoebaGrowing = false;\n    float amoebaProb = (animFrame - (gStartFrame + ENTRANCE_DURATION_AF)) > int(float(cAmoebaMagWallTime) / ANIM_FRAME_DURATION) ? AMOEBA_FAST_PROB : AMOEBA_SLOW_PROB;\n\n    JoystickState joy = getJoystickState();\n\n    for (int y=CAV_SIZ.y-1; y>=0; y--)\n    {\n        for (int x=0; x<CAV_SIZ.x; x++)\n        {\n            ivec2 coord = ivec2(x, y);\n            ivec4 cell = getCell(cave, coord);\n\n            if (!isUpdateNeeded(cell))\n            {\n                continue;\n            }\n\n            Fuse fuse = Fuse(CELL_VOID, ivec2(0));\n\n            if (cell.x == CELL_ROCKFORD)\n            {\n                gPlayerCoord = coord;\n\n                cell.y = (all(equal(joy.dir, DIR_RT))) ? cell.y | ROCKFORD_STATE_RT : cell.y;\n                cell.y = (all(equal(joy.dir, DIR_LT))) ? cell.y & ~ROCKFORD_STATE_RT : cell.y;\n                bool joyIdle = all(equal(joy.dir, DIR_NONE));\n                cell.yz = (!((cell.y & ROCKFORD_STATE_IDLE) > 0) && joyIdle) ? ivec2(cell.y | ROCKFORD_STATE_IDLE, animFrame) : cell.yz;\n                cell.y = (!joyIdle) ? cell.y & ~ROCKFORD_STATE_IDLE : cell.y;\n\n                ivec2 coordTarget = coord + joy.dir;\n                ivec4 cellTarget = getCell(cave, coordTarget);\n                bool isMoved = false;\n\n                if (cellTarget.x == CELL_VOID || cellTarget.x == CELL_DIRT)\n                {\n                    isMoved = true;\n                }\n                else if (cellTarget.x == CELL_DIAMOND)\n                {\n                    gDiamondsHarvested += 1;\n                    scoreToAdd += (isState(gCaveState, CAVE_STATE_EXIT_OPENED)) ? cDiamondBonusValue : cDiamondValue;\n                    isMoved = true;\n                    if (gDiamondsHarvested == cDiamondsRequired)\n                    {\n                        setState(gCaveState, CAVE_STATE_EXIT_OPENED);\n                        flashAlpha = 1.0;\n                    }\n                }\n                else if (cellTarget.x == CELL_EXIT)\n                {\n                    if (isState(gCaveState, CAVE_STATE_EXIT_OPENED))\n                    {\n                        setState(gCaveState, CAVE_STATE_EXITED);\n                        isMoved = true;\n                    }\n                }\n                else if (cellTarget.x == CELL_BOULDER)\n                {\n                    if ((joy.dir == DIR_LT || joy.dir == DIR_RT) && !isFalling(cellTarget))\n                    {\n                        ivec2 coordBoulderTarget = coordTarget + joy.dir;\n                        ivec4 cellBoulderTarget = getCell(cave, coordBoulderTarget);\n                        if (cellBoulderTarget.x == CELL_VOID && isPushSucceeded(rand))\n                        {\n                            setCell(cave, coordBoulderTarget, cellTarget);\n                            isMoved = true;\n                        }\n                    }\n                }\n\n                setUpdated(cell, true);\n\n                if (isMoved)\n                {\n                    if (joy.isFirePressed)\n                    {\n                        setCell(cave, coordTarget, CELL_VOID4);\n                    }\n                    else\n                    {\n                        setCell(cave, coordTarget, cell);\n                        setCell(cave, coord, CELL_VOID4);\n                        gPlayerCoord = coordTarget;\n                    }\n                }\n                else\n                {\n                    setCell(cave, coord, cell);\n                }\n            }\n\n            else if (cell.x == CELL_BOULDER || cell.x == CELL_DIAMOND)\n            {\n                ivec2 coordDn = coord + DIR_DN;\n                ivec4 cellDn = getCell(cave, coordDn);\n                ivec2 boulderMoveDir = DIR_NONE;\n\n                if (cellDn.x == CELL_VOID)\n                {\n                    boulderMoveDir = DIR_DN;\n                }\n                else if (cellDn.x == CELL_MAGIC_WALL && isFalling(cell))\n                {\n                    boulderMoveDir = DIR_DN2;\n                }\n                else if (isAbleToRollOff(cellDn))\n                {\n                    if (getCell(cave, coord + DIR_LT).x == CELL_VOID && getCell(cave, coord + DIR_LT_DN).x == CELL_VOID)\n                    {\n                        boulderMoveDir = DIR_LT;\n                    }\n                    else if (getCell(cave, coord + DIR_RT).x == CELL_VOID && getCell(cave, coord + DIR_RT_DN).x == CELL_VOID)\n                    {\n                        boulderMoveDir = DIR_RT;\n                    }\n                }\n\n                if (boulderMoveDir == DIR_DN2)\n                {\n                    if (mWallState == MWALL_STATE_DORMANT)\n                    {\n                        mWallState = MWALL_STATE_ACTIVE;\n                        gMagicWallStarted = gameFrame;\n                    }\n                    setCell(cave, coord, CELL_VOID4);\n                    ivec2 coordTarget = coord + DIR_DN2;\n                    ivec4 cellTarget = getCell(cave, coordTarget);\n                    if ((mWallState == MWALL_STATE_ACTIVE) && (cellTarget.x == CELL_VOID))\n                    {\n                        int cellType = (cell.x == CELL_BOULDER) ? CELL_DIAMOND : CELL_BOULDER;\n                        cellTarget = ivec4(cellType, 1, 0, 1); // is falling and updated\n                        setCell(cave, coordTarget, cellTarget);\n                    }\n                }\n                else if (any(notEqual(boulderMoveDir, DIR_NONE)))\n                {\n                    setFalling(cell, true);\n                    setUpdated(cell, true);\n                    setCell(cave, coord + boulderMoveDir, cell);\n                    setCell(cave, coord, CELL_VOID4);\n                }\n                else if (isHitExplosive(cell, cellDn))\n                {\n                    fuse.type = (cellDn.x == CELL_BUTTERFLY) ? CELL_EXPL_DIAMOND : CELL_EXPL_VOID;\n                    fuse.coord = coordDn;\n                }\n                else\n                {\n                    setFalling(cell, false);\n                    setUpdated(cell, true);\n                    setCell(cave, coord, cell);\n                }\n            }\n\n            else if (cell.x == CELL_MAGIC_WALL)\n            {\n                cell.y = (mWallState == MWALL_STATE_ACTIVE) ? 1 : 0;\n                cell.w = 1;\n                setCell(cave, coord, cell);\n            }\n\n            else if (cell.x == CELL_FIREFLY || cell.x == CELL_BUTTERFLY)\n            {\n                setUpdated(cell, true);\n\n                //explosion\n                for (int v=0; v<4; v++)\n                {\n                    ivec4 cellNearby = getCell(cave, coord + DIRS[v]);\n                    if ((cellNearby.x == CELL_ROCKFORD) || (cellNearby.x == CELL_AMOEBA))\n                    {\n                        fuse.type = (cell.x == CELL_BUTTERFLY) ? CELL_EXPL_DIAMOND : CELL_EXPL_VOID;\n                        fuse.coord = coord;\n                    }\n                }\n\n                // movement\n                int dirIndex = cell.y;\n                ivec2 dirLeft = getDirection(dirIndex, DIR_TURN_LT);\n                ivec2 coordLeft = coord + dirLeft;\n\n                if (getCell(cave, coordLeft).x == CELL_VOID)\n                {\n                    cell.y = dirIndex;\n                    setCell(cave, coordLeft, cell);\n                    setCell(cave, coord, CELL_VOID4);\n                }\n                else\n                {\n                    dirIndex = cell.y;\n                    ivec2 dirAhead = DIRS[dirIndex];\n                    ivec2 coordAhead = coord + dirAhead;\n                    if (getCell(cave, coordAhead).x == CELL_VOID)\n                    {\n                        cell.y = dirIndex;\n                        setCell(cave, coordAhead, cell);\n                        setCell(cave, coord, CELL_VOID4);\n                    }\n                    else\n                    {\n                        getDirection(cell.y, DIR_TURN_RT);\n                        setCell(cave, coord, cell);\n                    }\n                }\n            }\n\n            else if (cell.x == CELL_AMOEBA)\n            {\n                bool isCooked = (gAmoebaState == AMOEBA_STATE_COOKED);\n                bool isOverCooked = (gAmoebaState == AMOEBA_STATE_OVERCOOKED);\n                if (isCooked || isOverCooked)\n                {\n                    ivec4 cellNew = (isCooked) ? ivec4(CELL_DIAMOND, 0, 0, 1) : ivec4(CELL_BOULDER, 0, 0, 1);\n                    setCell(cave, coord, cellNew);\n                }\n                else\n                {\n                    amoebaNum += 1;\n\n                    rand = fract(rand + dot(vec2(coord), vec2(315.51, 781.64)));\n                    bool isWantToSpawn = rand < amoebaProb;\n                    ivec2 growCoord = coord + DIRS[int(fract(rand * 12378.1356) * 4.0) % 4];\n                    ivec4 growCell = getCell(cave, growCoord);\n\n                    if (isWantToSpawn && ((growCell.x == CELL_VOID) || (growCell.x == CELL_DIRT)))\n                    {\n                        isAmoebaGrowing = true;\n                        amoebaNum += 1;\n                        setCell(cave, growCoord, ivec4(CELL_AMOEBA, 0, 0, 1));\n                    }\n                }\n\n                if (!isAmoebaGrowing)\n                {\n                    for(int i=0; i<4; i++)\n                    {\n                        int growCellType = getCell(cave, coord + DIRS[i]).x;\n                        isAmoebaGrowing = isAmoebaGrowing || ((growCellType == CELL_VOID) || (growCellType == CELL_DIRT));\n                    }\n                }\n            }\n\n            else if (cell.x == CELL_EXPL_VOID)\n            {\n                if (cell.y >= EXPLOSION_DURATION_GF)\n                {\n                    setCell(cave, coord, CELL_VOID4);\n                }\n                else\n                {\n                    cell.y += 1;\n                    setCell(cave, coord, cell);\n                }\n            }\n\n            else if (cell.x == CELL_EXPL_DIAMOND)\n            {\n                if (cell.y >= EXPLOSION_DURATION_GF)\n                {\n                    setCell(cave, coord, ivec4(CELL_DIAMOND, 0, 0, 1));\n                }\n                else\n                {\n                    cell.y += 1;\n                    setCell(cave, coord, cell);\n                }\n            }\n\n            else if (cell.x == CELL_EXPL_ROCKFORD)\n            {\n                if (cell.y >= (EXPLOSION_DURATION_GF - 1))\n                {\n                    delState(gCaveState, CAVE_STATE_SPAWNING);\n                    setCell(cave, coord, ivec4(CELL_ROCKFORD, ROCKFORD_STATE_IDLE, animFrame, 1));\n                }\n                else\n                {\n                    cell.y += 1;\n                    setCell(cave, coord, cell);\n                }\n            }\n\n            else if (cell.x == CELL_ENTRANCE)\n            {\n                if (cell.y >= ENTRANCE_DURATION_GF)\n                {\n                    setCell(cave, coord, ivec4(CELL_EXPL_ROCKFORD, 0, 0, 1));\n                }\n                else\n                {\n                    cell.y = min(cell.y + 1, ENTRANCE_DURATION_GF);\n                    setCell(cave, coord, cell);\n                }\n            }\n\n            else if (cell.x == CELL_EXIT)\n            {\n                setCell(cave, coord, ivec4(CELL_EXIT, (isState(gCaveState, CAVE_STATE_EXIT_OPENED)) ? 1 : 0, 0, 1));\n            }\n\n            else  // CELL_VOID, CELL_DIRT, CELL_WALL, CELL_TITAN_WALL\n            {\n                cell.w = 1;\n                setCell(cave, coord, cell);\n            }\n\n            if (fuse.type != CELL_VOID)\n            {\n                for (int x=fuse.coord.x-1; x<=fuse.coord.x+1; x++)\n                {\n                    for (int y=fuse.coord.y-1; y<=fuse.coord.y+1; y++)\n                    {\n                        ivec2 explCoord = ivec2(x, y);\n                        ivec4 explCell = getCell(cave, explCoord);\n                        if (explCell.x != CELL_TITAN_WALL)\n                        {\n                            setCell(cave, explCoord, ivec4(fuse.type, 0, 0, 1));\n                        }\n                        if (explCell.x == CELL_ROCKFORD)\n                        {\n                            delState(gCaveState, CAVE_STATE_ALIVE);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    gAmoebaState = (!isAmoebaGrowing) ? AMOEBA_STATE_COOKED : gAmoebaState;\n    gAmoebaState = (amoebaNum > AMOEBA_OVERCOOKED_NUM) ? AMOEBA_STATE_OVERCOOKED : gAmoebaState;\n    cellState = isInCave(cellCoord) ? getCell(cave, cellCoord) : ivec4(0);\n}\n\nGameData getGameData()\n{\n    GameData gd;\n\n    if (iFrame == 0)\n    {\n        gd.gGameState = GAME_STATE_LOGO_SCREEN;\n        gd.gScore = 0;\n        gd.gHighScore = 0;\n        gd.gCave = 1;\n        gd.gIsCaveInit = false;\n        gd.gLevel = 1;\n        gd.gFrames = ivec4(0);\n        gd.gLives = NUMBER_OF_LIVES;\n    }\n    else\n    {\n        loadGameData(gd);\n    }\n\n    gd.gFrames.z = int(iTime / ANIM_FRAME_DURATION);\n    gd.gFrames.w = gd.gFrames.z / ANIM_FRAMES_IN_GAME_FRAME;\n\n    return gd;\n}\n\nvoid addBonusLife(inout int gLives, inout float gStripesAlpha)\n{\n    gLives = min(9, gLives + 1);\n    gStripesAlpha = 1.0;\n}\n\nvoid updateScore(int scoreToAdd, inout int gScore, inout int gHighScore, inout int gLives, inout float gStripesAlpha)\n{\n    int newScore = gScore + scoreToAdd;\n    if ((newScore / 500) > (gScore / 500))\n    {\n        addBonusLife(gLives, gStripesAlpha);\n    }\n    gScore = newScore;\n    gHighScore = max(gScore, gHighScore);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 uvi = ivec2(fragCoord);\n\n    if ((uvi.x > (TX_DATA_RECT.x)) || (uvi.y > TX_DATA_RECT.y))\n    {\n        discard;\n    }\n\n    GameData gd = getGameData();\n    int animFrameLast = gd.gFrames.x;\n    int gameFrameLast = gd.gFrames.y;\n    int animFrame = gd.gFrames.z;\n    int gameFrame = gd.gFrames.w;\n\n    float rand = fract(sin(float(animFrame % 1000)) * 43758.5453123);\n\n    bool isNeedGameUpdate = gameFrame > gameFrameLast;\n    bool isNeedAnimUpdate = animFrame > animFrameLast;\n\n    bool isKeyF2 = KEY_DOWN(KEY_F2);\n    bool isKeyCtrl = KEY_DOWN(KEY_CTRL);\n    bool isKeyRt = KEY_DOWN(KEY_RT_ARR);\n    bool isKeyLt = KEY_DOWN(KEY_LT_ARR);\n    bool isKeyUp = KEY_DOWN(KEY_UP_ARR);\n    bool isKeyDn = KEY_DOWN(KEY_DN_ARR);\n\n    if (gd.gGameState == GAME_STATE_LOGO_SCREEN)\n    {\n        if (isKeyF2)\n        {\n            gd.gGameState = GAME_STATE_START_SCREEN;\n        }\n    }\n    else if (gd.gGameState == GAME_STATE_START_SCREEN)\n    {\n        if (isKeyCtrl)\n        {\n            gd.gGameState = GAME_STATE_CAVE;\n            gd.gIsCaveInit = true;\n            gd.gScore = 0;\n        }\n\n        if (isNeedGameUpdate)\n        {\n            #ifdef UNLOCK_CAVES\n                int caveInc = isKeyRt ? 1 : isKeyLt ? -1 : 0;\n                gd.gCave = clamp(gd.gCave + caveInc, 1, 20);\n            #else\n                int caveInc = isKeyRt ? 5 : isKeyLt ? -5 : 0;\n                gd.gCave = clamp(gd.gCave + caveInc, 1, 16);\n            #endif\n\n\n            int levelInc = isKeyUp ? 1 : isKeyDn ? -1 : 0;\n            gd.gLevel = clamp(gd.gLevel + levelInc, 1, 5);\n        }\n    }\n    else\n    {\n        if (isKeyF2)\n        {\n            gd.gLives = NUMBER_OF_LIVES;\n            gd.gCave = 1;\n            gd.gLevel = 1;\n            gd.gGameState = GAME_STATE_START_SCREEN;\n        }\n    }\n\n    bool isCavePlaying = (gd.gGameState == GAME_STATE_CAVE);\n    bool isPlayGameUpdate = isCavePlaying && isNeedGameUpdate;\n    bool isPlayAnimUpdate = isCavePlaying && isNeedAnimUpdate;\n\n    CaveData cd;\n\n    if (gd.gIsCaveInit && isCavePlaying)\n    {\n        if (gd.gCave == 1)  cd = cd1;\n        if (gd.gCave == 2)  cd = cd2;\n        if (gd.gCave == 3)  cd = cd3;\n        if (gd.gCave == 4)  cd = cd4;\n        if (gd.gCave == 5)  cd = cd5;\n        if (gd.gCave == 6)  cd = cd6;\n        if (gd.gCave == 7)  cd = cd7;\n        if (gd.gCave == 8)  cd = cd8;\n        if (gd.gCave == 9)  cd = cd9;\n        if (gd.gCave == 10) cd = cd10;\n        if (gd.gCave == 11) cd = cd11;\n        if (gd.gCave == 12) cd = cd12;\n        if (gd.gCave == 13) cd = cd13;\n        if (gd.gCave == 14) cd = cd14;\n        if (gd.gCave == 15) cd = cd15;\n        if (gd.gCave == 16) cd = cd16;\n        if (gd.gCave == 17) cd = cd17;\n        if (gd.gCave == 18) cd = cd18;\n        if (gd.gCave == 19) cd = cd19;\n        if (gd.gCave == 20) cd = cd20;\n\n        bool isLevel5 = (gd.gLevel == 5);\n        cd.gDiamondsRequired = (isLevel5) ? cd.cDiamondsNeeded5 : cd.cDiamondsNeeded[gd.gLevel - 1];\n        cd.gTimeLeft = (isLevel5) ? float(cd.cCaveTime5) : float(cd.cCaveTime[gd.gLevel - 1]);\n\n        cd.gStartFrame = animFrame;\n        cd.gCamPos = initCamPos(cd.gPlayerCoord);\n        int cellType = generateCave(uvi, gd.gCave, gd.gLevel);\n        cd.cellState = ivec4(cellType, 0, 0, 1);\n\n        if (isIntermission(gd.gCave))\n        {\n            addBonusLife(gd.gLives, cd.gStripesAlpha);\n        }\n\n        gd.gIsCaveInit = false;\n    }\n    else if (isCavePlaying)\n    {\n        loadCaveData(cd, uvi);\n    }\n\n    int scoreToAdd = 0;\n\n    if (isPlayGameUpdate)\n    {\n        updateCaveGame(\n            cd.gCaveState, cd.gPlayerCoord, cd.cellState, cd.gDiamondsHarvested, cd.gMagicWallStarted,\n            cd.gAmoebaState, cd.gFlashAlpha, cd.gAuxFrame, scoreToAdd,\n            cd.gDiamondsRequired, cd.cDiamondValue, cd.cDiamondBonusValue, cd.cAmoebaMagWallTime,\n            uvi, animFrame, gameFrame, cd.gStartFrame, rand\n        );\n    }\n    if (isPlayAnimUpdate)\n    {\n        updateCaveAnim(cd.gAuxFrame, cd.gCamPos, cd.gCaveState, cd.gFade, cd.gPlayerCoord, cd.gStripesAlpha, cd.gTimeLeft, gd, scoreToAdd);\n    }\n\n    updateScore(scoreToAdd, gd.gScore, gd.gHighScore, gd.gLives, cd.gStripesAlpha);\n\n    gd.gFrames.xy = gd.gFrames.zw;\n\n    saveCaveData(cd, fragColor, uvi);\n    saveGameData(gd, fragColor, uvi);\n\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//----------------------------------------------------------------------------------------------------------\n// FUNCTIONS FOR GAME AND RENDER\n//----------------------------------------------------------------------------------------------------------\n\nbool isInCave(ivec2 coord)\n{\n    return (coord.x >= 0) && (coord.x <= TX_CAVE.x) && (coord.y >= 0) && (coord.y <= TX_CAVE.y);\n}\n\nvec4 loadValue(ivec2 coord)\n{\n    return texelFetch(iChannel0, coord, 0);\n}\n\nivec4 loadCaveValue(ivec2 uvi)  // for cave cells\n{\n    return isInCave(uvi) ? ivec4(loadValue(uvi)) : ivec4(0);\n}\n\nvoid loadCaveData(inout CaveData cd, ivec2 uvi)\n{\n    vec4 v;\n\n    v = loadValue(TX_CAVE_STATE);\n    cd.gCaveState = int(v.r);\n    cd.gFade = v.g;\n    cd.gStripesAlpha = v.b;\n    cd.cAmoebaMagWallTime = int(v.a);\n\n    v = loadValue(TX_CAVE_TIME);\n    cd.gStartFrame = int(v.r);\n    cd.gAuxFrame = int(v.g);\n    cd.gTimeLeft = v.b;\n    cd.gMagicWallStarted = int(v.a);\n\n    v = loadValue(TX_CAVE_COLOR0);\n    cd.cColor0 = v.rgb;\n\n    v = loadValue(TX_CAVE_COLOR1);\n    cd.cColor1 = v.rgb;\n\n    v = loadValue(TX_CAVE_COLOR2);\n    cd.cColor2 = v.rgb;\n\n    v = loadValue(TX_DIAMONDS);\n    cd.gDiamondsRequired = int(v.r);\n    cd.cDiamondValue = int(v.g);\n    cd.cDiamondBonusValue = int(v.b);\n    cd.gDiamondsHarvested = int(v.a);\n\n    v = loadValue(TX_PLAYER);\n    cd.gPlayerCoord = ivec2(v.rg);\n    cd.gAmoebaState = int(v.b);\n    cd.gFlashAlpha = v.a;\n\n    v = loadValue(TX_CAMERA);\n    cd.gCamPos = v;\n\n    cd.cellState = loadCaveValue(uvi);\n}\n\nvoid loadGameData(inout GameData gd)\n{\n    vec4 v;\n\n    v = loadValue(TX_GAME_DATA);\n    gd.gGameState = int(v.r);\n    gd.gCave = abs(int(v.g));\n    gd.gIsCaveInit = v.g < 0.0;\n    gd.gLevel = int(v.b);\n    gd.gLives = int(v.a);\n\n    v = loadValue(TX_GAME_FRAMES);\n    gd.gFrames = ivec4(int(v.r), int(v.g), 0, 0);\n    gd.gScore = int(v.b);\n    gd.gHighScore = int(v.a);\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Font\n//----------------------------------------------------------------------------------------------------------\nconst ivec2[35] letters = ivec2[35](\n    ivec2(0, 0),\n    ivec2(1736402791, 1850983),\n    ivec2(1734836031, 4155199),\n    ivec2(124223294, 4089607),\n    ivec2(1731673887, 2045799),\n    ivec2(117931903, 8324927),\n    ivec2(117901063, 8324927),\n    ivec2(2003271550, 8259335),\n    ivec2(1734829927, 6776703),\n    ivec2(471612990, 4070428),\n    ivec2(1617395260, 6316128),\n    ivec2(523724647, 6764319),\n    ivec2(117931903, 460551),\n    ivec2(1801675619, 6518655),\n    ivec2(2139060071, 6778751),\n    ivec2(1667465022, 4088675),\n    ivec2(2134836999, 4155239),\n    ivec2(1731690092, 3958631),\n    ivec2(1061119847, 4155239),\n    ivec2(1616936767, 4065086),\n    ivec2(471604252, 8330268),\n    ivec2(1734836095, 6776679),\n    ivec2(1736392220, 6776679),\n    ivec2(2139060067, 6513515),\n    ivec2(1013409639, 6776636),\n    ivec2(471604252, 6513470),\n    ivec2(235372415, 8337436),\n    ivec2(1094587400, 529470),\n    ivec2(1579020, 0),\n    ivec2(1579008, 6168),\n    ivec2(1579020, 6168),\n    ivec2(403441155, 4218928),\n    ivec2(404232240, 3151896),\n    ivec2(404232204, 792600),\n    ivec2(4282148352, 26172)\n);\n\nconst ivec2[10] digits = ivec2[10](\n    ivec2(1734836030, 4089703),\n    ivec2(404258430, 1580060),\n    ivec2(470712191, 4092728),\n    ivec2(812089150, 8269848),\n    ivec2(2134390840, 197435),\n    ivec2(1617395518, 8324927),\n    ivec2(1734836030, 4065087),\n    ivec2(470681351, 8352056),\n    ivec2(1734836030, 4089662),\n    ivec2(2117606414, 4089703)\n);\n\nfloat sampleFont(ivec2 glyph, ivec2 coord)\n{\n    ivec2 idx = coord % FNT_RES;\n    return (((glyph[idx.y / 4] >> (8 * (idx.y % 4) + idx.x)) & 1) > 0) ? 1.0 : 0.0;\n}\n\nfloat printInt(ivec2 c, int value, int maxDigits)\n{\n    float res = 0.0;\n    if ((c.x >= 0) && (c.x < maxDigits * CEH_RES.x) && (c.y >= 0) && (c.y < CEH_RES.y))\n    {\n        int i = maxDigits - 1 - c.x / CEH_RES.x;\n        int div = (i==0) ? 1 : (i==1) ? 10 : (i==2) ? 100 : (i==3) ? 1000 : (i==4) ? 10000 : 100000;\n        res = sampleFont(digits[(value/div) % 10], ivec2(c.x / 2, c.y));\n    }\n    return res;\n}\n\nfloat printLetter(ivec2 c, int letter)\n{\n    return ((c.x >= 0) && (c.x < CEH_RES.x) && (c.y >= 0) && (c.y < CEH_RES.y)) ? sampleFont(letters[letter], ivec2(c.x / 2, c.y)) : 0.0;\n}\n\nfloat printWord8(ivec2 c, int word[8])\n{\n    float res = 0.0;\n    if ((c.x >= 0) && (c.x < 8 * CEH_RES.x) && (c.y >= 0) && (c.y < CEH_RES.y))\n    {\n        int i = c.x / CEH_RES.x;\n        res = sampleFont(letters[word[i]], ivec2(c.x / 2, c.y));\n    }\n    return res;\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Logo Bottom\n//----------------------------------------------------------------------------------------------------------\n\nconst ivec4 logoHS[57] = ivec4[57](\n    ivec4(0),\n    ivec4(1431655765, 1431655765, 21845, 0),\n    ivec4(1431655765, 1431655765, 1342199125, 1409306624),\n    ivec4(1409373185, 67437573, 1410663445, 1397781),\n    ivec4(1114129, 22085969, 1162936337, 17745),\n    ivec4(1430327553, 1145132353, 1078281281, 16453),\n    ivec4(285479172, 1364480340, 1364463876, 20820),\n    ivec4(356586821, 88408133, 356843588, 5445),\n    ivec4(286347537, 290525521, 20753, 2862612480),\n    ivec4(167774212, 2181071360, 167805440, 2048),\n    ivec4(170557952, 134350850, 2318010370, 512),\n    ivec4(2281867914, 2323810306, 2290256002, 35458),\n    ivec4(134744074, 176818184, 8915080, 138),\n    ivec4(2863311530, 2863311530, 2863311530, 0),\n    ivec4(1437226666, 1433032106, 1431983466, 1431590224),\n    ivec4(2861935253, 2862983845, 2863245993, 2147516416),\n    ivec4(2158657578, 2192212650, 2192212650, 2158658218),\n    ivec4(2687148074, 2687148074, 2687148074, 2687148074),\n    ivec4(2685009930, 2685050890, 2863308810, 2863311530),\n    ivec4(713687040, 713697930, 2861181578, 2861214346),\n    ivec4(2863180456, 2863180456, 44739240, 44696234),\n    ivec4(0, 1073741824, 1342193664, 1343180800),\n    ivec4(357897556, 89458005, 22348117, 4032151637),\n    ivec4(2684395520, 2819401728, 2852366863, 2860755587),\n    ivec4(2150269098, 2148171818, 2147647498, 2147516418),\n    ivec4(2687148074, 2687148074, 2687148074, 2687148074),\n    ivec4(2863311530, 2685053610, 2685050890, 2863310890),\n    ivec4(2861214346, 713730698, 713697930, 2861181578),\n    ivec4(2863278762, 2860559018, 2860558976, 2863311488),\n    ivec4(1409044543, 2146459644, 4290838512, 4278255360),\n    ivec4(1431655765, 1431655765, 4291777877, 3221209087),\n    ivec4(715238049, 178793128, 44731050, 11141802),\n    ivec4(2863180456, 2863311530, 43690, 1073758208),\n    ivec4(2729091754, 2729091754, 33450, 1342525445),\n    ivec4(2863311530, 2863311530, 43690, 1364279633),\n    ivec4(2861214346, 2861214346, 43650, 1430607173),\n    ivec4(2863311530, 715827882, 2730, 1427461377),\n    ivec4(4227922944, 4227919872, 4278255360, 4293984192),\n    ivec4(2952769535, 2952769535, 2952769535, 4294950911),\n    ivec4(11141290, 44695722, 2863311530, 2863311530),\n    ivec4(1073758208, 1073758208, 1252674218, 1252674218),\n    ivec4(1342525445, 1342525445, 1364545541, 1364545877),\n    ivec4(1364283729, 1364283729, 1431392593, 1431393617),\n    ivec4(1430607173, 21829, 1430323200, 1430607173),\n    ivec4(1427461397, 1427461397, 1427461397, 1427461397),\n    ivec4(0, 2863136768, 2863180456, 2863180456),\n    ivec4(0, 2863267840, 2863311530, 2863311530),\n    ivec4(16728060, 0, 0, 0),\n    ivec4(4290838512, 4278255360, 4227922944, 4026593280),\n    ivec4(1073719979, 3221487363, 196611, 196611),\n    ivec4(1073760938, 1073954816, 1073758208, 16384),\n    ivec4(1342525781, 1364545541, 1364545877, 20821),\n    ivec4(1095849297, 1431388497, 1431393617, 21841),\n    ivec4(88429893, 1430586693, 1430607173, 21761),\n    ivec4(1426085125, 1431590144, 1431590228, 21844),\n    ivec4(0, 1430607168, 1430607173, 21829),\n    ivec4(0, 1431655765, 1431655765, 21845)\n);\n\nconst int logoPattern[LOG_SIZ.x * LOG_SIZ.y] = int[LOG_SIZ.x * LOG_SIZ.y](\n    1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,\n    13,13,13,13,13,13,13,13,13,14,15,16,17,18,19,20,0,0,0,0,\n    0,0,0,0,0,0,0,0,21,22,23,24,25,26,27,28,0,0,0,0,\n    0,0,0,0,0,0,0,0,29,30,31,32,33,34,35,36,0,0,0,0,\n    0,0,0,0,0,0,0,0,37,38,39,40,41,42,43,44,45,46,46,46,\n    0,0,0,0,0,0,0,0,47,48,49,50,51,52,53,54,55,56,56,56\n);\n\nconst mat4x3 logoColors = mat4x3(\n    COLOR01(ivec3(0, 0, 0)),\n    COLOR01(ivec3(1, 78, 157)),\n    COLOR01(ivec3(33, 110, 189)),\n    COLOR01(ivec3(192, 192, 192))\n);\n\n//----------------------------------------------------------------------------------------------------------\n// Boulder Dash Title\n//----------------------------------------------------------------------------------------------------------\n\nconst ivec4 bdHS[12] = ivec4[12](\n    ivec4(0),\n    ivec4(4294967295, 4294967295, 4294967295, 4294967295),\n    ivec4(4294574073, 4294574073, 4294574073, 4294574073),\n    ivec4(4177590528, 4177590528, 4177590528, 4177590528),\n    ivec4(16318713, 16318713, 16318713, 16318713),\n    ivec4(16711935, 16711935, 16711935, 16711935),\n    ivec4(16711935, 16711935, 983103, 3),\n    ivec4(983043, 16711743, 16711935, 16711935),\n    ivec4(4294967295, 4294967295, 268386303, 16712703),\n    ivec4(67043583, 1073680383, 4294967295, 4294967295),\n    ivec4(3103848704, 3103832320, 2835396864, 4177570048),\n    ivec4(4025483263, 4008701935, 3954109103, 4294963182)\n);\n\nconst int bdPattern[BOU_SIZ.x * BOU_SIZ.y] = int[BOU_SIZ.x * BOU_SIZ.y](\n    0,0,3,1,9,3,5,4,2,1,3,5,3,0,0,0,0,0,\n    0,0,3,1,1,3,5,4,2,1,3,5,3,0,0,0,0,0,\n    0,0,3,5,3,3,5,4,0,2,3,5,3,0,0,0,0,0,\n    0,0,3,5,3,3,1,5,2,1,3,1,1,0,0,0,0,0,\n    0,0,3,5,3,3,5,4,2,0,3,5,3,0,0,0,0,0,\n    0,0,3,5,3,0,2,6,2,1,3,5,3,10,11,0,0,0,\n    0,0,3,1,8,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    2,1,7,2,1,3,1,5,2,1,3,1,7,2,1,3,5,4,\n    2,1,5,2,1,3,1,5,2,1,3,1,5,2,1,3,5,4,\n    2,0,4,2,3,3,5,4,2,0,3,5,4,2,0,3,1,6,\n    2,1,6,2,3,3,5,4,2,0,3,5,4,2,5,3,1,7,\n    2,1,7,2,3,3,5,4,2,0,3,5,4,2,0,3,5,4,\n    2,0,4,2,1,3,5,4,2,0,3,1,6,2,1,3,1,6,\n    2,1,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n);\n\nconst mat4x3 bdColors = mat4x3(\n    COLOR01(ivec3(-255)),\n    COLOR01(ivec3(1, 78, 157)),\n    COLOR01(ivec3(33, 110, 189)),\n    COLOR01(ivec3(161, 238, 255))\n);\n\n//----------------------------------------------------------------------------------------------------------\n// Title Scrolling Back\n//----------------------------------------------------------------------------------------------------------\n\nconst ivec4 scrollSprite = ivec4(2846467236, 2863312301, 2593802826, 2863323866);\nconst mat4x3 scrollColors = mat4x3(\n    COLOR01(ivec3(0, 0, 0)),\n    COLOR01(ivec3(1, 78, 157)),\n    COLOR01(ivec3(33, 110, 189)),\n    COLOR01(ivec3(161, 238, 255))\n);\nconst vec3 titleLightGray = COLOR01(ivec3(192, 192, 192));\nconst ivec4 scrollingFrame = ivec4(8, 56, 311, 191);\n\n//----------------------------------------------------------------------------------------------------------\n// Sprites\n//----------------------------------------------------------------------------------------------------------\nstruct Sprite\n{\n    ivec4 bot;  // bottom 8x8 pixel\n    ivec4 top;  //    top 8x8 pixel\n};\n\nSprite getSpriteEmpty()\n{\n    Sprite sprite = Sprite(ivec4(0), ivec4(0));\n    return sprite;\n}\n\nSprite getSpriteInvalid()\n{\n    Sprite sprite = Sprite(ivec4(3840206052, 3840206052, 3840206052, 3840206052), ivec4(3840206052, 3840206052, 3840206052, 3840206052));\n    return sprite;\n}\n\nSprite getSpriteRockfordWalkLeft(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(3221487631, 399556612, 62915200, 62915248), ivec4(41943680, 176687776, 178260616, 640));\n    Sprite sprite1 = Sprite(ivec4(3222274108, 131126288, 62915200, 62915248), ivec4(41943680, 176687776, 178260616, 640));\n    Sprite sprite2 = Sprite(ivec4(873476156, 63968528, 62915200, 62915248), ivec4(178258560, 176687752, 41945760, 0));\n    Sprite sprite3 = Sprite(ivec4(222301424, 62914880, 62915200, 62915248), ivec4(178258560, 176687752, 41945760, 0));\n    Sprite sprite4 = Sprite(ivec4(22021056, 62914896, 62915200, 62915248), ivec4(178258560, 176687752, 41945760, 0));\n    Sprite sprite5 = Sprite(ivec4(22024176, 62914896, 62915200, 62915248), ivec4(41943680, 176687776, 178260616, 640));\n    Sprite sprite6 = Sprite(ivec4(873476156, 63968528, 62915200, 62915248), ivec4(41943680, 176687776, 178260616, 640));\n\n    switch (animFrame % 8)\n    {\n        case 0: return sprite0;\n        case 1: return sprite0;\n        case 2: return sprite1;\n        case 3: return sprite2;\n        case 4: return sprite3;\n        case 5: return sprite4;\n        case 6: return sprite5;\n        case 7: return sprite6;\n    }\n}\n\nSprite getSpriteRockfordIdleBlink(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(68172860, 131073040, 62915200, 600322700), ivec4(41945760, 579340960, 178268840, 2080));\n    Sprite sprite1 = Sprite(ivec4(68172860, 131073040, 62915200, 600322700), ivec4(41945760, 715655840, 178268840, 2080));\n    Sprite sprite2 = Sprite(ivec4(68172860, 131073040, 62915200, 600322700), ivec4(41945760, 715655840, 178268840, 2080));\n    Sprite sprite3 = Sprite(ivec4(68172860, 131073040, 62915200, 600322700), ivec4(41945760, 579340960, 178268840, 2080));\n    Sprite sprite4 = Sprite(ivec4(68172860, 131073040, 62915200, 600322700), ivec4(41945760, 579340960, 178266760, 2080));\n\n    switch (animFrame % 8)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite3;\n        case 4: return sprite4;\n        case 5: return sprite4;\n        case 6: return sprite4;\n        case 7: return sprite4;\n    }\n\n}\n\nSprite getSpriteRockfordIdleTap(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(71056384, 131073040, 62915200, 600313520), ivec4(41945760, 579340960, 178266760, 2080));\n    Sprite sprite1 = Sprite(ivec4(68172860, 131073040, 62915200, 600313520), ivec4(41945760, 579340960, 178266760, 2080));\n\n    if ((animFrame % 8) < 4)\n    {\n        return sprite0;\n    }\n    else\n    {\n        return sprite1;\n    }\n}\n\nSprite getSpriteRockfordIdleTapBlink(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(71056384, 131073040, 62915200, 600313520), ivec4(41945760, 579340960, 178268840, 2080));\n    Sprite sprite1 = Sprite(ivec4(71056384, 131073040, 62915200, 600313520), ivec4(41945760, 715655840, 178268840, 2080));\n    Sprite sprite2 = Sprite(ivec4(71056384, 131073040, 62915200, 600313520), ivec4(41945760, 715655840, 178268840, 2080));\n    Sprite sprite3 = Sprite(ivec4(71056384, 131073040, 62915200, 600313520), ivec4(41945760, 579340960, 178268840, 2080));\n    Sprite sprite4 = Sprite(ivec4(68172860, 131073040, 62915200, 600313520), ivec4(41945760, 579340960, 178266760, 2080));\n\n    switch (animFrame % 8)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite3;\n        case 4: return sprite4;\n        case 5: return sprite4;\n        case 6: return sprite4;\n        case 7: return sprite4;\n    }\n\n}\n\nSprite getSpriteRockfordIdle()\n{\n    return getSpriteRockfordIdleBlink(ROCKFORD_ANIM_LENGTH - 1);\n}\n\nSprite getSpriteDirt()\n{\n    return Sprite(ivec4(76615940, 286344453, 1176069208, 1448355145), ivec4(1385571665, 1364269336, 610551109, 1141915909));\n}\n\nSprite getSpriteBoulder()\n{\n    return Sprite(ivec4(153092736, 707406504, 2862787210, 1789027978), ivec4(4200261290, 4268418726, 1069022622, 66063852));    Sprite sprite = Sprite(ivec4(0), ivec4(0));\n}\n\nSprite getSpriteDiamond(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(37749056, 266341328, 894970532, 3221389313), ivec4(3937047893, 1073229812, 224397968, 58720832));\n    Sprite sprite1 = Sprite(ivec4(37749056, 266341008, 984100852, 3221394773), ivec4(3579215873, 1073228452, 245369808, 58720832));\n    Sprite sprite2 = Sprite(ivec4(37749056, 245369168, 1073229812, 3579226793), ivec4(3221389313, 984098132, 266341328, 58720832));\n    Sprite sprite3 = Sprite(ivec4(37749056, 224397328, 1073228452, 3937058813), ivec4(3221394773, 894967812, 266341008, 58720832));\n    Sprite sprite4 = Sprite(ivec4(37749056, 203425808, 984098132, 4294885373), ivec4(3579226793, 805838852, 245369168, 58720832));\n    Sprite sprite5 = Sprite(ivec4(37749056, 203426128, 894967812, 4294879913), ivec4(3937058813, 805840212, 224397328, 58720832));\n    Sprite sprite6 = Sprite(ivec4(37749056, 224397968, 805838852, 3937047893), ivec4(4294885373, 894970532, 203425808, 58720832));\n    Sprite sprite7 = Sprite(ivec4(37749056, 245369808, 805840212, 3579215873), ivec4(4294879913, 984100852, 203426128, 58720832));\n\n    switch (animFrame % 8)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite3;\n        case 4: return sprite4;\n        case 5: return sprite5;\n        case 6: return sprite6;\n        case 7: return sprite7;\n    }\n}\n\nSprite getSpriteExplosionVoid(int frameIndex)\n{\n    const int animLength = 4;\n\n    Sprite sprite0 = Sprite(ivec4(786432, 823329728, 76026256, 83898663), ivec4(638066823, 877400100, 856426688, 0));\n    Sprite sprite1 = Sprite(ivec4(0, 53477376, 71577968, 218104092), ivec4(486805580, 79704092, 3072, 0));\n    Sprite sprite2 = Sprite(ivec4(0, 0, 202113984, 50331696), ivec4(51130560, 201326640, 0, 0));\n\n    if (frameIndex < 0 || frameIndex > (animLength - 1))\n    {\n        return getSpriteInvalid();\n    }\n\n    switch (frameIndex % animLength)\n    {\n        case 0: return sprite1;\n        case 1: return sprite0;\n        case 2: return sprite1;\n        case 3: return sprite2;\n    }\n}\n\nSprite getSpriteExplosionDiamond(int frameIndex)\n{\n    Sprite sprite0 = Sprite(ivec4(3145728, 12595203, 49932, 12291), ivec4(3221422080, 789504, 13104, 50343987));\n    Sprite sprite1 = Sprite(ivec4(38536128, 152092720, 671101068, 2147598371), ivec4(1210171395, 276836352, 3289386544, 20971724));\n    Sprite sprite2 = Sprite(ivec4(37749696, 147852592, 739521164, 2495726115), ivec4(1239540359, 277099276, 68161072, 20972480));\n    Sprite sprite3 = Sprite(ivec4(37749696, 198184368, 769930860, 2666125179), ivec4(2105138159, 466893548, 93327024, 20972480));\n\n    switch (frameIndex % 4)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite3;\n    }\n}\n\nSprite getSpriteExplosionRockford(int frameIndex)\n{\n    Sprite sprite0 = Sprite(ivec4(0, 0, 202113984, 50331696), ivec4(51130560, 201326640, 0, 0));\n    Sprite sprite1 = Sprite(ivec4(0, 53477376, 71577968, 218104092), ivec4(486805580, 79704092, 3072, 0));\n    Sprite sprite2 = Sprite(ivec4(786432, 823329728, 76026256, 83898663), ivec4(638066823, 877400100, 856426688, 0));\n\n    switch (frameIndex % 3)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n    }\n}\n\nSprite getSpriteButterfly(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(1073889281, 2685292553, 4164940847, 1456843178), ivec4(46137728, 2822394917, 3759132683, 2147696642));\n    Sprite sprite1 = Sprite(ivec4(537399300, 537661448, 943469612, 383003048), ivec4(46137728, 674763812, 268963848, 537665548));\n    Sprite sprite2 = Sprite(ivec4(136315920, 136315920, 136315920, 46137728), ivec4(46137728, 136315920, 137364512, 137364512));\n\n    switch (animFrame % 8)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite2;\n        case 4: return sprite1;\n        case 5: return sprite0;\n        case 6: return sprite0;\n        case 7: return sprite0;\n    }\n}\n\nSprite getSpriteFirefly(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(4294967295, 3937135275, 3758874635, 3800818315), ivec4(3800818315, 3758874635, 3937135275, 4294967295));\n    Sprite sprite1 = Sprite(ivec4(2863311530, 2147647490, 2325908130, 2346879970), ivec4(2346879970, 2325908130, 2147647490, 2863311530));\n    Sprite sprite2 = Sprite(ivec4(0, 715664040, 804794360, 783822520), ivec4(783822520, 804794360, 715664040, 0));\n    Sprite sprite3 = Sprite(ivec4(2863311530, 3221143550, 3132013230, 3090069550), ivec4(3090069550, 3132013230, 3221143550, 2863311530));\n\n    switch ((animFrame / 2) % 4)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite3;\n    }\n}\n\nSprite getSpriteWall()\n{\n    return Sprite(ivec4(2324299776, 3486486415, 2829582336, 4244437240), ivec4(2324299776, 3486486415, 2829582336, 4244437240));\n}\n\nSprite getSpriteTitaniumWall()\n{\n    return Sprite(ivec4(2863311530, 2391714474, 2189593226, 2863311530), ivec4(2863311530, 2391714474, 2189593226, 2863311530));\n}\n\nSprite getSpriteEntrance(int gameFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(2147658410, 2147647490, 2147647490, 2147647490), ivec4(2147647490, 2147647490, 2147647490, 2863300610));\n    Sprite sprite1 = Sprite(ivec4(2863311530, 2391714474, 2189593226, 2863311530), ivec4(2863311530, 2391714474, 2189593226, 2863311530));\n\n    switch (gameFrame % 2)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n    }\n}\n\nSprite getSpriteMagicWall(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(3132764208, 4294950847, 2896956428, 4244438268), ivec4(3132764208, 4294950847, 2896956428, 4244438268));\n    Sprite sprite1 = Sprite(ivec4(2391673868, 3486486415, 3099078704, 4244437240), ivec4(2391673868, 3486486415, 3099078704, 4244437240));\n    Sprite sprite2 = Sprite(ivec4(2341143299, 3486486415, 3907567808, 4244437240), ivec4(2341143299, 3486486415, 3907567808, 4244437240));\n    Sprite sprite3 = Sprite(ivec4(3402285248, 3486502863, 2880111363, 4294966267), ivec4(3402285248, 3486502863, 2880111363, 4294966267));\n    Sprite spriteInactive = getSpriteWall();\n\n    switch (animFrame)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite3;\n        case 4: return spriteInactive;\n    }\n}\n\nSprite getSpriteAmoeba(int animFrame)\n{\n    Sprite sprite0 = Sprite(ivec4(1486184485, 1431656021, 1431655765, 1431655765), ivec4(1431655765, 626431317, 1448449365, 1613060245));\n    Sprite sprite1 = Sprite(ivec4(1448433813, 2505463125, 2505450840, 1431655765), ivec4(1431655765, 2505594198, 1431655766, 1486181973));\n    Sprite sprite2 = Sprite(ivec4(1431655765, 626562390, 626533720, 1431672150), ivec4(1431721301, 2505610584, 1431737688, 1448432981));\n    Sprite sprite3 = Sprite(ivec4(1448433813, 2505463125, 2505450840, 1431655765), ivec4(2505397589, 156771670, 2505385302, 1486181973));\n\n    switch ((animFrame / 2) % 4)\n    {\n        case 0: return sprite0;\n        case 1: return sprite1;\n        case 2: return sprite2;\n        case 3: return sprite3;\n    }\n}\n\nSprite getSpriteUindefined()\n{\n    // return Sprite(ivec4(1313772435, 3840162105, 1313772435, 3840162105), ivec4(1313772435, 3840162105, 1313772435, 3840162105));  // diagonal lines\n    // return Sprite(ivec4(859032780, 859032780, 859032780, 859032780), ivec4(859032780, 859032780, 859032780, 859032780));  // checker\n    // return Sprite(ivec4(0, 806105100, 204475440, 62915520), ivec4(62915520, 204475440, 806105100, 0));  // cross\n    return Sprite(ivec4(0, 1880911900, 477109360, 130025408), ivec4(130025408, 477109360, 1880911900, 0));  // cross with shadow\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Draw Sprites\n//----------------------------------------------------------------------------------------------------------\n\nvec4 sampleSprite(Sprite sprite, mat4x3 colors, ivec2 c)\n{\n    ivec2 idx = modint(c, CEL_RES) / PIX_ASP;;\n    ivec4 l = sprite.bot;\n    if (idx.y > SPR_RES.y / 2 - 1)\n    {\n        l = sprite.top;\n        idx.y -= SPR_RES.y / 2;\n    }\n    int i = l[idx.y / 2];\n    int colorIndex = i >> (2 * ((idx.y % 2) * SPR_RES.x + idx.x)) & 3;\n    vec3 color = colors[colorIndex];\n    return vec4(saturate(color), step(-0.5, color.r));\n}\n\nvec4 sampleHalfSprite(ivec4 sprite, mat4x3 colors, ivec2 c)\n{\n    ivec2 idx = modint(c, CEH_RES) / PIX_ASP;\n    int i = sprite[idx.y / 2];\n    int colorIndex = i >> (2 * ((idx.y % 2) * SPH_RES.x + idx.x)) & 3;\n    vec3 color = colors[colorIndex];\n    return vec4(saturate(color), step(-0.5, color.r));\n}\n\nbool onOffNoise(int frame, vec4 f, float s)\n{\n    float x = float(frame);\n    return (sin(f.w * f.x * x) + sin(f.w * f.y * x) + sin(f.w * f.z * x) + s) > 0.0;\n}\n\nvec4 drawCellRockford(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)\n{\n    int localFrame = animFrame - state.z;\n    int cycle = max(localFrame / ROCKFORD_ANIM_LENGTH - ROCKFORD_IDLE_COOLDOWN, 0);\n    bool isBlinking = onOffNoise(cycle + 46, vec4(0.77, 1.0, 1.79, 3.38), -0.48);\n    bool isTapping = onOffNoise(cycle + 113, vec4(1.0, 1.81, 3.41, 0.21), 0.0);\n\n    bool isIdle = (state.y & ROCKFORD_STATE_IDLE) > 0;\n    bool isRight = (state.y & ROCKFORD_STATE_RT) > 0;\n\n    Sprite sprite;\n\n    if (isIdle)\n    {\n        if ((cycle == 0) || (!isBlinking && !isTapping))\n        {\n            sprite = getSpriteRockfordIdle();\n        }\n        else if (isBlinking && !isTapping)\n        {\n            sprite = getSpriteRockfordIdleBlink(localFrame);\n        }\n        else if (!isBlinking && isTapping)\n        {\n            sprite = getSpriteRockfordIdleTap(localFrame);\n        }\n        else\n        {\n            sprite = getSpriteRockfordIdleTapBlink(localFrame);\n        }\n    }\n    else\n    {\n        sprite = getSpriteRockfordWalkLeft(animFrame);\n    }\n\n    coord.x = (!isIdle && isRight) ? CEL_RES.x - 1 - coord.x : coord.x;\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellVoid(float stripesAlpha, mat4x3 colors, ivec2 coord, int animFrame)\n{\n    vec4 res = vec4(0.0);\n\n    if (stripesAlpha > 0.0)\n    {\n        coord /= PIX_ASP;\n        if (((coord.y + 1) % 4) == 0)\n        {\n            animFrame = animFrame % 100;\n            float r = rand21(vec2(coord + ivec2(animFrame, -animFrame)));\n            int colorIndex = int(r * 4.0);\n            vec3 color = colors[min(colorIndex, 3)];\n            return vec4(saturate(color), step(-0.5, color.r));\n        }\n    }\n\n    return res;\n}\n\nvec4 drawCellDirt(ivec4 state, mat4x3 colors, ivec2 coord)\n{\n    Sprite sprite = getSpriteDirt();\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellBoulder(ivec4 state, mat4x3 colors, ivec2 coord)\n{\n    Sprite sprite = getSpriteBoulder();\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellDiamond(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)\n{\n    Sprite sprite = getSpriteDiamond(animFrame);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellWall(ivec4 state, mat4x3 colors, ivec2 coord)\n{\n    Sprite sprite = getSpriteWall();\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellTitaniumWall(ivec4 state, mat4x3 colors, ivec2 coord)\n{\n    Sprite sprite = getSpriteTitaniumWall();\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellMagicWall(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)\n{\n    Sprite sprite = getSpriteMagicWall((state.y == 1) ? (animFrame % 4) : 4);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellFirefly(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)\n{\n    Sprite sprite = getSpriteFirefly(animFrame);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellButterfly(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)\n{\n    Sprite sprite = getSpriteButterfly(animFrame);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellAmoeba(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)\n{\n    Sprite sprite = getSpriteAmoeba(animFrame);\n    colors[1] = COLOR01(ivec3(75, 88, 0));\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellExit(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)\n{\n    Sprite sprite = getSpriteEntrance((state.y == 0) ? 1 : gameFrame);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellEntrance(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)\n{\n    Sprite sprite = getSpriteEntrance(gameFrame);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellExplosionVoid(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)\n{\n    Sprite sprite = getSpriteExplosionVoid(state.y);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellExplosionDiamond(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)\n{\n    Sprite sprite = getSpriteExplosionDiamond(state.y);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellExplosionRockford(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)\n{\n    Sprite sprite = getSpriteExplosionRockford(state.y);\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCellUndefined(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)\n{\n    Sprite sprite = getSpriteUindefined();\n    return sampleSprite(sprite, colors, coord);\n}\n\nvec4 drawCell(ivec4 state, mat4x3 colors, ivec2 coordCell, int animFrame, int gameFrame, float stripesAlpha)\n{\n    int cellType = int(state.x);\n\n    vec4 col = vec4(0.0);\n\n         if (cellType == CELL_VOID)          col = drawCellVoid(stripesAlpha, colors, coordCell, animFrame);\n    else if (cellType == CELL_ROCKFORD)      col = drawCellRockford(state, colors, coordCell, animFrame);\n    else if (cellType == CELL_DIRT)          col = drawCellDirt(state, colors, coordCell);\n    else if (cellType == CELL_BOULDER)       col = drawCellBoulder(state, colors, coordCell);\n    else if (cellType == CELL_DIAMOND)       col = drawCellDiamond(state, colors, coordCell, animFrame);\n    else if (cellType == CELL_WALL)          col = drawCellWall(state, colors, coordCell);\n    else if (cellType == CELL_TITAN_WALL)    col = drawCellTitaniumWall(state, colors, coordCell);\n    else if (cellType == CELL_MAGIC_WALL)    col = drawCellMagicWall(state, colors, coordCell, animFrame);\n    else if (cellType == CELL_FIREFLY)       col = drawCellFirefly(state, colors, coordCell, animFrame);\n    else if (cellType == CELL_BUTTERFLY)     col = drawCellButterfly(state, colors, coordCell, animFrame);\n    else if (cellType == CELL_AMOEBA)        col = drawCellAmoeba(state, colors, coordCell, animFrame);\n    else if (cellType == CELL_ENTRANCE)      col = drawCellEntrance(state, colors, coordCell, gameFrame);\n    else if (cellType == CELL_EXIT)          col = drawCellExit(state, colors, coordCell, gameFrame);\n    else if (cellType == CELL_EXPL_VOID)     col = drawCellExplosionVoid(state, colors, coordCell, gameFrame);\n    else if (cellType == CELL_EXPL_DIAMOND)  col = drawCellExplosionDiamond(state, colors, coordCell, gameFrame);\n    else if (cellType == CELL_EXPL_ROCKFORD) col = drawCellExplosionRockford(state, colors, coordCell, gameFrame);\n    else                                     col = drawCellUndefined(state, colors, coordCell, gameFrame);\n\n    return col;\n}\n\nfloat coordMask(ivec2 coord, ivec4 frame)\n{\n    return ((coord.x >= frame.x) && (coord.x <= frame.z) && (coord.y >= frame.y) && (coord.y <= frame.w)) ? 1.0 : 0.0;\n}\n\nvec4 drawFade(ivec2 coordWS, mat4x3 colors, int animFrame, float gFade, bool isFadingOut)\n{\n    vec4 res = vec4(0.0);\n\n    ivec2 coordScroll = ivec2(coordWS.x, coordWS.y - animFrame * SCROLL_SPEED);\n    ivec2 coordCellScroll = modint(coordScroll, CEL_RES);\n    res.rgb = drawCellTitaniumWall(ivec4(0), colors, coordCellScroll).rgb;\n\n    vec2 cellIndex = vec2(((isFadingOut) ? coordWS * ivec2(2) : coordWS) / CEL_RES);\n    float r = rand21(cellIndex + vec2(17.0, 17.0));\n    res.a = step(r, gFade);\n\n    return res;\n}\n\nvec4 drawCaveCells(ivec2 coord, mat4x3 colors, int animFrame, int gameFrame, float stripesAlpha, float gFade,\n                   int gCaveState, vec2 camPosWS)\n{\n    vec4 outCaveColor = vec4(0.0);\n\n    if ((coord.x < 0) || (coord.y < 0) || (coord.x >= GAM_RES.x) || (coord.y >= GAM_RES.y))\n    {\n        return outCaveColor;\n    }\n\n    ivec2 coordWS = ivec2(camPosWS * CEL_RES_F) - GAM_RES / 2 + coord;\n    ivec2 cellIndex = coordWS / CEL_RES;\n    ivec2 coordCell = coordWS % CEL_RES;\n\n    bool isFadingOut = isState(gCaveState, CAVE_STATE_FADE_OUT);\n\n    // for safety if we sample state outside of cave data\n    if (cellIndex.x >= 0 && cellIndex.x < CAV_SIZ.x && cellIndex.y >= 0 && cellIndex.y < CAV_SIZ.y)\n    {\n        ivec4 cellState = ivec4(texelFetch(iChannel0, cellIndex, 0));\n        outCaveColor = drawCell(cellState, colors, coordCell, animFrame, gameFrame, stripesAlpha);\n    }\n\n    vec4 fadeTitanium = drawFade(coordWS, colors, animFrame, gFade, isFadingOut);\n    outCaveColor = lerp(outCaveColor, fadeTitanium, fadeTitanium.a);\n\n    return outCaveColor;\n}\n\nvec3 drawCaveBackground(float gFlashAlpha)\n{\n    return (gFlashAlpha > 0.0) ? FLASH_COLOR : vec3(0.0);\n}\n\nvec4 drawUI(ivec2 coord, vec3 color0, vec3 color1, int gDiamondsRequired, int cDiamondValue, int cDiamondBonusValue,\n            int gDiamondsHarvested, int gCaveState, float gTimeLeft, int gScore, int gLives, int gCave, int gLevel,\n            int animFrame, int gAuxFrame)\n{\n    vec4 res = vec4(0.0);\n    vec4 col0 = vec4(color0, 1.0);\n    vec4 col1 = vec4(color1, 1.0);\n    const int y = TIT_RES.y - 8;\n\n    bool isSpawning = isState(gCaveState, CAVE_STATE_SPAWNING);\n    bool isFadingIn = isState(gCaveState, CAVE_STATE_FADE_IN);\n    bool isFadingOut = isState(gCaveState, CAVE_STATE_FADE_OUT);\n    bool isExitOpened = isState(gCaveState, CAVE_STATE_EXIT_OPENED);\n    bool isExited = isState(gCaveState, CAVE_STATE_EXITED);\n    bool isTimeOut = isState(gCaveState, CAVE_STATE_TIME_OUT);\n    bool isPaused = isState(gCaveState, CAVE_STATE_PAUSED);\n    bool isGameOver = isState(gCaveState, CAVE_STATE_GAME_OVER);\n    bool isIntermission = ((gCave % 5) == 0);\n    bool isTopInfoVisible = ((animFrame - gAuxFrame) % 135) < 35;\n    bool isMovingToNextLevel = isFadingOut && (isIntermission || isExited);\n\n    if (isMovingToNextLevel)\n    {\n        gCave += 1;\n        if (gCave > 20)\n        {\n            gCave = 1;\n            gLevel = max(((gLevel + 1) % 6), 1);\n        }\n    }\n\n    if (isGameOver)\n    {\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x, y), int[8](G, _, A, _, M, _, E, _)));\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 11, y), int[8](O, _, V, _, E, _, R, _)));\n    }\n    else if (isPaused && isTopInfoVisible && !(isFadingIn || isFadingOut))\n    {\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x, y), int[8](S, P, A, C, E, B, A, R)));\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](T, O, _, R, E, S, U, M)));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 18, y), E));\n    }\n    else if (isSpawning && isIntermission)\n    {\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x, y), int[8](B, _, O, _, N, _, U, _)));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 9, y), S));\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 12, y), int[8](L, _, I, _, F, _, E, _)));\n    }\n    else if (isSpawning || isFadingOut)\n    {\n        res = lerp(res, col0, printWord8(coord - ivec2(0, y), int[8](P, L, A, Y, E, R, _, _)));\n        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 7, y), 1, 1));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 8, y), L_COMMA));\n        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 10, y), gLives, 1));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 12, y), M));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 13, y), (gLives > 1) ? E : A));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 14, y), N));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 16, y), gCave - gCave / 5));\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 17, y), L_SLASH));\n        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 18, y), gLevel, 1));\n    }\n    else if (isTimeOut && isTopInfoVisible)\n    {\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 4, y), int[8](O, U, T, _, O, F, _, _)));\n        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 11, y), int[8](T, I, M, E, _, _, _, _)));\n    }\n    else\n    {\n        if (isExitOpened)\n        {\n            res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x, y), L_DIAMOND));\n            res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 2, y), L_DIAMOND));\n        }\n        else\n        {\n            res = lerp(res, col1, printInt(coord - ivec2(CEH_RES.x, y), gDiamondsRequired, 2));\n        }\n        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 3, y), L_DIAMOND));\n        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 4, y), cDiamondValue, 2));\n        res = lerp(res, col1, printInt(coord - ivec2(CEH_RES.x * 7, y), gDiamondsHarvested, 2));\n        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 10, y), int(ceil(gTimeLeft)), 3));\n        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 14, y), gScore, 6));\n    }\n    return res;\n}\n\nvec3 drawCave(ivec2 coord, GameData gd)\n{\n    CaveData cd;\n    loadCaveData(cd, ivec2(0, 0));\n\n    mat4x3 colors = mat4x3(\n        COLOR01(ivec3(-255)),\n        cd.cColor0,\n        cd.cColor1,\n        cd.cColor2\n    );\n\n    vec3 backColor = drawCaveBackground(cd.gFlashAlpha);\n    vec4 caveColor = drawCaveCells(coord, colors, gd.gFrames.x, gd.gFrames.y, cd.gStripesAlpha, cd.gFade, cd.gCaveState, cd.gCamPos.xy);\n    vec4 uiColor = drawUI(coord, colors[3], colors[2], cd.gDiamondsRequired, cd.cDiamondValue, cd.cDiamondBonusValue,\n                          cd.gDiamondsHarvested, cd.gCaveState, cd.gTimeLeft, gd.gScore, gd.gLives, gd.gCave, gd.gLevel,\n                          gd.gFrames.x, cd.gAuxFrame);\n\n    vec3 col;\n    col = lerp(backColor, caveColor.rgb, caveColor.a);\n    col = lerp(col, uiColor.rgb, uiColor.a);\n\n    return col;\n}\n\nvec3 drawLogoBottom(ivec2 coord)\n{\n    ivec2 cellIdx = coord / CEH_RES;\n\n    if (coord.x < 0 || coord.x > (LOG_RES.x - 1) || coord.y < 0 || coord.y > (LOG_RES.y - 1))\n    {\n        return vec3(0.0);\n    }\n\n    int idx = cellIdx.y * LOG_SIZ.x + cellIdx.x;\n    ivec4 sprite = logoHS[logoPattern[idx]];\n    return sampleHalfSprite(sprite, logoColors, coord).rgb;\n}\n\nfloat drawRectangle(vec2 uv, vec2 bottomLeft, vec2 widthHeight)\n{\n    vec2 widthHeightHalf = widthHeight / 2.0;\n    vec2 s = step(abs(uv - bottomLeft - widthHeightHalf), widthHeightHalf);\n    return s.x * s.y;\n}\n\nvec3 drawStartBottom(ivec2 coord, int gCave, int gHighScore, int gLevel, int gScore)\n\n{\n    const vec3 backColor = COLOR01(ivec3(0, 0, 0));\n    const vec3 blueColor = COLOR01(ivec3(33, 110, 189));\n    const vec3 greyColor = COLOR01(ivec3(192, 192, 192));\n\n    vec3 res = backColor;\n\n    for (int i=3; i<40; i+=9)\n    {\n\n        res = lerp(res, blueColor, coordMask(coord, ivec4(0, i, TIT_RES.x - 1, i)));\n    }\n\n    int y = 4;\n    res = lerp(res, greyColor, printWord8(coord - ivec2(0, y), int[8](_, C, A, V, E, L_COLON, _, _)));\n    #ifdef UNLOCK_CAVES\n        res = lerp(res, (gCave % 5) == 0 ? vec3(0.8, 0.0, 0.4) : blueColor, printLetter(coord - ivec2(CEH_RES.x * 7, y), gCave - gCave / 5));\n    #else\n        res = lerp(res, blueColor, printLetter(coord - ivec2(CEH_RES.x * 7, y), gCave - gCave / 5));\n    #endif\n    res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](L, E, V, E, L, L_COLON, _, _)));\n    res = lerp(res, blueColor, printInt(coord - ivec2(CEH_RES.x * 17, y), gLevel, 1));\n    y += 9;\n    res = lerp(res, blueColor, printInt(coord - ivec2(0, y), 1, 1));\n    res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 2, y), int[8](P, L, A, Y, E, R, _, _)));\n    res = lerp(res, blueColor, printInt(coord - ivec2(CEH_RES.x * 10, y), 1, 1));\n    res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 12, y), int[8](J, O, Y, S, T, I, C, K)));\n    y += 9;\n\n    if ((gScore == 0) && (gHighScore == 0))\n    {\n        res = lerp(res, greyColor, printWord8(coord - ivec2(0, y), int[8](P, R, E, S, S, _, B, U)));\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 8, y), int[8](T, T, O, N, _, T, O, _)));\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 16, y), int[8](P, L, A, Y, _, _, _, _)));\n        y += 9;\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 2, y), int[8](W, I, T, H, _, C, H, R)));\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](I, S, _, G, R, A, Y, _)));\n        y += 9;\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 2, y), int[8](B, Y, _, P, E, T, E, R)));\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](_, L, I, E, P, A, _, _)));\n    }\n    else\n    {\n        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x, y), gHighScore, 6));\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 8, y), int[8](H, I, G, H, _, _, _, _)));\n        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 13, y), 0, 6));\n        y += 9;\n        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x, y), gScore, 6));\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 8, y), int[8](L, A, S, T, _, _, _, _)));\n        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 13, y), 0, 6));\n        y += 9;\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x, y), int[8](P, L, Y, R, _, _, _, _)));\n        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 6, y), 1, 1));\n        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 13, y), int[8](P, L, Y, R, _, _, _, _)));\n        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 18, y), 2, 1));\n    }\n    return res;\n}\n\nvec4 drawBoulderDash(ivec2 coord, mat4x3 colors)\n{\n    ivec2 cellIdx = coord / CEH_RES;\n    cellIdx += ivec2(-1, -8);\n\n    if (coord.x < 16 || coord.x > 303 || coord.y < 64 || coord.y > 183)\n    {\n        return vec4(0.0);\n    }\n\n    int idx = cellIdx.y * BOU_SIZ.x + cellIdx.x;\n    ivec4 sprite = bdHS[bdPattern[idx]];\n    return sampleHalfSprite(sprite, bdColors, coord);\n}\n\nvec3 drawScrollingTitle(ivec2 coord, int animFrame)\n{\n    float mask = coordMask(coord, scrollingFrame);\n    vec3 res = sampleHalfSprite(scrollSprite, scrollColors, coord - ivec2(0, animFrame)).rgb * mask;\n\n    float frameMask = saturate(coordMask(coord, ivec4(0, 48, 319, 199)) - coordMask(coord, ivec4(8, 56, 311, 191)));\n    res = lerp(res, titleLightGray, frameMask);\n\n    vec4 boulderDash = drawBoulderDash(coord, bdColors);\n    res = lerp(res, boulderDash.rgb, boulderDash.a);\n    return res;\n}\n\nvec3 drawTitleScreen(ivec2 coord, GameData gd)\n{\n    vec3 col = drawScrollingTitle(coord, gd.gFrames.x);\n\n    if (gd.gGameState == GAME_STATE_LOGO_SCREEN)\n    {\n        col += drawLogoBottom(coord);\n    }\n    else\n    {\n        col += drawStartBottom(coord, gd.gCave, gd.gHighScore, gd.gLevel, gd.gScore);\n    }\n\n    return col;\n}\n\nvec3 drawGame(ivec2 coord)\n{\n    GameData gd;\n    loadGameData(gd);\n\n    vec3 col;\n\n    if (gd.gGameState == GAME_STATE_CAVE)\n    {\n        col = drawCave(coord, gd);\n    }\n    else\n    {\n        col = drawTitleScreen(coord, gd);\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 coord = ivec2(fragCoord);\n    if ((coord.x < 0) || (coord.y < 0) || (coord.x >= TIT_RES.x) || (coord.y >= TIT_RES.y))\n    {\n        discard;\n    }\n    fragColor = vec4(drawGame(coord), 1.0);\n\n}","name":"Buffer A","description":"","type":"buffer"}]}