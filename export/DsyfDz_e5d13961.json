{"ver":"0.1","info":{"id":"DsyfDz","date":"1698182254","viewed":284,"name":"[phreax] chroma dance","username":"phreax","description":"Getting closer to my vision of intricate, curved, ever transforming yet playful and light forms.\n\nThe base is a kifs of a twisted torus knot rendered with a transparency raymarcher and some motion blur.\n\nVariation of\nhttps://www.shadertoy.com/view/msXGWj","likes":23,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","kifs","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldcGR2","filepath":"https://soundcloud.com/royalty-free-music-btm/royalty-free-music-download-epic-cinematic-inspiring-creative-commons","previewfilepath":"https://soundcloud.com/royalty-free-music-btm/royalty-free-music-download-epic-cinematic-inspiring-creative-commons","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"[phreax] dancing smoke\" by None. https://shadertoy.com/view/-1\n// 2023-10-20 16:17:40\n\n// Fork of \"[phreax] dancing smoke\" by phreax. https://shadertoy.com/view/msXGWj\n// 2023-10-20 16:11:52\n\n// Copyright Michael Thomas a.k.a phreax, 2022 \n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright Michael Thomas a.k.a phreax/jiagual, 2023 \n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n\n#define PI 3.141592\n#define BPM 110. \n#define SIN(x)(sin(x) * .5 + .5)\n#define hue(v)(.6 + .6 * cos(6.3 * (v) + vec3(0, 23, 21)))\n#define SYMMETRICAL 0\n#define PALETTE 2\n#define S(t1, d) smoothstep(t1, t1+d, iTime)\n#define time iTime\n\nfloat tt;\n\nvec3 ro;\n\nfloat smoothPulse(float offset, float multiplier) {\n    float beatLength = 60.0 / (BPM / multiplier); // Calculate the time for each beat\n    float time = mod(iTime + offset, beatLength); // Adjust time by offset and wrap within a single beat period\n    float halfBeat = beatLength / 2.0; // Half of the beat length\n\n    // Generate a pulse that smoothly rises to 1 at the middle of the beat period and falls back to 0\n    if (time < halfBeat) {\n        return smoothstep(0.0, halfBeat, time); // Smoothly increase from 0 to 1 over half a beat period\n    } else {\n        return smoothstep(0.0, -halfBeat, time - beatLength); // Smoothly decrease from 1 to 0 over half a beat period\n    }\n}\n\nvec3 saturate(vec3 c) {\n    // Clamp the input between 0.0 and 1.0\n    return clamp(c, vec3(0.0), vec3(1.0));\n}\n\nmat2 rot2(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// from \"Palettes\" by iq. https://shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn saturate(a + b * cos(6.28318 * (c * t + d)));\n}\n\n\n\nvec3 desaturate(vec3 color, float factor) {\n    // Calculate the luminance of the original color\n    float luminance = dot(color, vec3(0.299, 0.587, 0.114));\n\n    // Create the grayscale version of the color\n    vec3 gray = vec3(luminance);\n\n    // Blend the original color with the grayscale color based on the desaturation factor\n    return mix(color, gray, factor);\n}\n\nvec3 getPal(int id, float t) {\n\n\tid = id % 9;\n\n\tvec3 col = pal(t, vec3(.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, -0.33, 0.33));\n\tif (id == 1) col = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.10, 0.20));\n\tif (id == 2) col = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.), vec3(0.55, 0.21, 0.09));\n\tif (id == 3) col = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 0.5), vec3(0.8, 0.90, 0.30));\n\tif (id == 4) col = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 0.7, 0.4), vec3(0.0, 0.15, 0.20));\n\tif (id == 5) col = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));\n\tif (id == 6) col = pal(t, vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.0, 0.25, 0.25));\n    if( id == 7 ) col = pal( t, vec3(0.330, 0.733, 0.837), vec3(0.971, 0.004, 0.283), vec3(0.459, 1.056, 0.908), vec3(4.891, 2.260, 4.497));\n    if( id == 8 ) col = pal( t, vec3(0.677, 0.649, 0.588), vec3(0.190, 0.548, 0.715), vec3(0.331, 1.511, 0.403), vec3(6.184, 4.673, 2.544));\n\n\n\treturn col;\n}\n\n\n// by Nusan\nfloat rnd(float t) {\n\treturn fract(sin(t * 784.685) * 827.542);\n}\n\nfloat curve(float t, float d) {\n\tfloat g = t / d;\n\treturn mix(rnd(floor(g)), rnd(floor(g) + 1.0), pow(smoothstep(0.0, 1.0, fract(g)), 7.));\n}\n\nfloat pulseAt(float timestamp, float attack, float release) {\n    // Calculate time relative to the pulse point\n    float time = iTime - timestamp;\n\n    // Normalize attack/release times (assumes attack and release are in seconds)\n    float normAttack = 1.0 / attack;\n    float normRelease = 1.0 / release;\n\n    // Generate pulse\n    float pulse = 0.0;\n    if (time > 0.0) {\n        if (time < attack) {\n            // Attack phase - ramp up to peak\n            pulse = 0.5 - 0.5 * cos(time * normAttack * 3.14159);\n        } else if (time < (attack + release)) {\n            // Release phase - ramp down to 0\n            pulse = 0.5 + 0.5 * cos((time - attack) * normRelease * 3.14159);\n        } else {\n            // Resting phase\n            pulse = 0.0;\n        }\n    }\n\n    return pulse;\n}\n\n\nvec3 transform(vec3 p) {\n\tfloat a =  0.3*time  + .2*curve(time, 3.9)+4.* pulseAt(37., .5, 8.)+\n    3.* pulseAt(41.4, .5, 4.) + 5.*smoothPulse(3., 8.) * S(17., 1.) +  3.* pulseAt(54.5, .8, 4.);\n\tfloat a2 = 2.1*time+ .3*curve(time, 2.1) + 4.*smoothPulse(0., 8.) +\n    5.* pulseAt(37., .8, 4.)+4.*pulseAt(45.8, .5, 4.)+4.* pulseAt(41.4, .5, 8.) + 6.* pulseAt(50., .8, 8.);\n\n\n\t// rotate object\n    p.xz *= rot2(a);\n    p.xy *= rot2(a2);\n\treturn p;\n}\n\nfloat map(vec3 p) {\n\n\tvec3 bp = p;\n\n\tp = transform(p);\n\n    \n\t#if SYMMETRICAL\n    p.yz = abs(p.yz)-.3;\n    \n\t#endif\n    \n\n\n\n\t// torus\n\tfloat r1 = 1.5 + .3*smoothPulse(3., 8.);\n    \n\tfloat r2 = mix(0.1, 0.4, SIN(tt * .3));\n    \n\tvec2 cp = vec2(length(p.xz) - r1, p.y);\n\n\n\t// torus knots by BigWings\n\tfloat a = atan(p.z, p.x);\n    cp *= rot2(2. * a + .8*tt);\n\n\tcp *= vec2(3., .3);\n\tcp.x = abs(cp.x) - .3;\n\tcp *= rot2(3. * a + 1.*tt);\n\n\t// kifs\n\tfloat n = 6.;\n\tfor (float i = 0.; i < n; i++) {\n\n\t\tcp.y = abs(cp.y) - .05 * (.5 * sin(.4*tt) + .9) - .03*smoothPulse(4., 8.)*S(9., .5);\n\n\t\tcp *= rot2(0.1 * a * sin(0.1 * time));\n\t\tcp -= i * 0.01 / n;\n\t}\n\n\n\tfloat d = length(cp) - r2;\n\n\td = max(.09 * d, - length(bp.xy - ro.xy) - 4.);\n\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n\n\tfloat zoom = .99;;\n\t\n\tfloat cz = -9. + mix(2., 3.5, S(8.5, 1.)) * (smoothPulse(4., 8.) + .5*pulseAt(37., .5, 4.)+.4*pulseAt(46., .5, 2.));\n    \n    \n\tro = vec3(0, .0, cz);\n\tvec3 lp = vec3(0, 1, cz);\n\tvec3 rd = normalize(vec3(uv, .7));\n\n\tvec3 p = ro;\n\tvec3 col;\n\n\tfloat t, d = 0.1;\n\n\ttt = time * 2.;\n\n\tfloat acc = 0.001;\n\tfor (float i = .0; i < 200.; i++) {\n\n\t\td = map(p);\n\n\t\tif (t > 150.) break;\n\n\t\t// Phantom mode https://www.shadertoy.com/view/MtScWW\n\t\tacc += .01 + d * .4;\n\t\td = max(abs(d), 0.00002);\n\n\t\tt += d;\n\t\tp += rd * d;\n\n\n\t\tcol += 2. * clamp(1., 0., .7 * abs(cz) / (acc * acc));\n\n\t\tfloat sl = dot(p, p);\n\n\t\t/// col *= 0.5*getPal(PALETTE, 1.-0.15*sqrt(sl)+0.2*p.z+.25*iTime+curve(iTime, 8.));\n\t\tcol *= .55 * getPal(PALETTE, .2*time + 1. - 0.26 * sqrt(sl) + 0.3 * p.z + mix(3.0, 4.0, SIN(curve(time, 4.))));\n       \n        col *= vec3(.85, .83, .9);\n        col = clamp(vec3(1.), vec3(0.0), col);\n        //col = 1. - col;\n\t}\n\n\tif (d < 0.001) {\n\t\tvec2 e = vec2(0.0035, -0.0035);\n\t\tvec3 n = normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) +\n                           e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n\n\t\tvec3 l = normalize(lp - p);\n\t\tfloat dif = max(dot(n, l), .0);\n\t\tfloat spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n\t\tfloat sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n\n\t\tcol *= mix(1., .2 * spe + .3 * (dif + 2.5 * sss), .2);\n\n\t\tcol = clamp(vec3(1.), vec3(0), col);\n\t}\n\n        col = vec3(0.922, 1.000, 1.000) * mix(.7, 0.2, length(uv) - .75) - pow(col, vec3(1.4)) * 2.5;\n\n    col = desaturate(col, .3);\n    \n    vec3 previousColor = texture(iChannel0, ((fragCoord - .5 * iResolution.xy) * zoom / iResolution.xy + 0.5)).rgb;\n\n    if(dot(previousColor, previousColor) > 0.0001) {\n\t col = mix(col, previousColor, .85);\n    }\n    \n\n\tfragColor = vec4(col, 1.0 - t * 0.3);\n}","name":"Buffer A","description":"","type":"buffer"}]}