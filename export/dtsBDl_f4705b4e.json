{"ver":"0.1","info":{"id":"dtsBDl","date":"1693822384","viewed":51,"name":"music visualization 3d_0","username":"bhxj","description":"一个球。\n可能在高手眼里，这种将极坐标解出来的行为，非常憨批吧。","likes":0,"published":1,"flags":64,"usePreview":0,"tags":["3d","disco"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4ddGD7","filepath":"https://soundcloud.com/virtual-riot/virtual-riot-did-i-mention-i","previewfilepath":"https://soundcloud.com/virtual-riot/virtual-riot-did-i-mention-i","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat texture_fftw(float uvx, float freq_step, float count)\n{\n    float freq = 0.0;\n    for (float offset = 0.0; offset < freq_step * (count + 0.1); offset += freq_step)\n    {\n        freq += texture(iChannel0, vec2(offset + uvx, 0.0)).r;\n    }\n    freq /= (count + 1.0);\n    freq = freq * freq;\n    return freq;\n}\n\nfloat texture_fftw2(float uvx, float freq_step, float count)\n{\n    float freq = 0.0;\n    for (float offset = 0.0; offset < freq_step * (count + 0.1); offset += freq_step)\n    {\n        freq += texture(iChannel0, vec2(fract(offset + uvx), 0.0)).r;\n    }\n    freq /= (count + 1.0);\n    freq = freq * freq;\n    return freq;\n}\nfloat texture_fftw3(float uvx, float freq_step, float count)\n{\n    float freq = 0.0;\n    float total = 0.0;\n    float mid_factor = count * 0.5;\n    for (float offset = 0.0; offset < freq_step * (count + 0.1); offset += freq_step)\n    {\n        float fatcor = mid_factor - abs(offset/freq_step - mid_factor) + 1.0;\n        //fatcor = pow(fatcor, 1.2);\n        freq += fatcor * texture(iChannel0, vec2(fract(offset + uvx), 0.0)).r;\n        total += fatcor;\n    }\n    freq /= total;\n    freq = freq * freq;\n    return freq;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p) - r;\n}\n\nfloat radius = 1.0;\nfloat sdf(vec3 p)\n{\n    float ret = sdSphere(p, radius);\n    return ret;\n}\n\n\nconst float EPSILON=.0001;\nfloat rayMarch(vec3 eye,vec3 ray,float end,int maxIter)\n{\n    float depth=0.;\n    for(int i=0;i<maxIter;i++)\n    {\n        vec3 pos = eye + depth*ray;\n        float dist = sdf(pos);\n        depth += dist;\n        if(dist < EPSILON || dist >= end)\n        {\n            break;\n        }\n    }\n    return depth;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float eps = 0.0001;\n    const vec3 h = vec3(eps,0.0,0.0);\n    return normalize(\n        vec3(sdf(p + h.xyy)-sdf(p - h.xyy),\n             sdf(p + h.yxy)-sdf(p - h.yxy),\n             sdf(p + h.yyx)-sdf(p - h.yyx)));\n}\n\nconst float PI = 3.141592653;\nconst float HPI = PI * 0.5;\nconst float DPI = PI * 2.0;\nvec2 xyz_to_gis(vec3 pos)\n{\n\tfloat len_xyz = length(pos);\n\tfloat sin_lat = pos.z / len_xyz;\n\tfloat lat = asin(sin_lat);\n\n\tfloat len_xy = length(pos.xy);\n\tfloat lon = 0.0;\n\tif (len_xy <= 0.001)\n\t{\n\t\tif (pos.z > 0.0)\n\t\t{\n\t\t\tlat = HPI;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlat = -HPI;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfloat cos_lon = pos.x / len_xy;\n\t\tlon = acos(cos_lon);\n\n\t\tif(abs(pos.y) < 0.00001)\n\t\t{\n\t\t\tif(pos.x > 0.0)\n\t\t\t{\n\t\t\t\tlon = 0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlon = PI;\n\t\t\t}\n\t\t}\n\t\telse if (pos.y < 0.0)\n\t\t{\n\t\t\tlon = -lon;\n\t\t}\n\t}\n\treturn vec2(lon, lat);\n}\nvec3 gis_to_xyz(vec2 pos)\n{\t\t\n\tfloat cos_lat = cos(pos.y);\n\tfloat rad_lon = pos.x;\n\treturn vec3(\n\t\tcos_lat * cos(rad_lon),\n\t\tcos_lat * sin(rad_lon),\n\t\tsin(pos.y));\n}\nvec3 rotate_X(vec3 pos, float rad)\n{\n\tfloat cos_v = cos(rad);\n\tfloat sin_v = sin(rad);\n\tmat3 rotateX = mat3(1.0, 0.0   , 0.0  ,\n\t                    0.0, cos_v , sin_v,\n\t                    0.0, -sin_v, cos_v );\n\treturn rotateX * pos;\n}\nvec3 rotate_Y(vec3 pos, float rad)\n{\n\tfloat cos_v = cos(rad);\n\tfloat sin_v = sin(rad);\n\tmat3 rotateY = mat3(cos_v, 0.0, -sin_v,\n\t                    0.0  , 1.0, 0.0   ,\n\t                    sin_v, 0.0, cos_v  );\n\treturn rotateY * pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    vec2 view_offset = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n    vec3 ray;\n    vec3 view_pos;\n    float near_dis = 3.5;\n    if(true)\n    {   \n        radius = 1.35;\n        float fov = (45.0 / 180.0) * PI;    \n        view_offset = view_offset * near_dis * tan(fov * 0.5);  \n        view_pos = vec3(0.0, 0.0, near_dis);  \n        ray = vec3(view_offset, 0.0) - view_pos;\n        ray = normalize(ray);\n    }\n    else\n    {\n        view_pos = vec3(view_offset, near_dis);  \n        ray = vec3(view_offset, 0.0) - view_pos;\n        ray = normalize(ray);\n    }\n    vec3 pos;\n    //vec3 normal;\n    float end = 20.0;\n    int   maxIter = 256;\n    float depth = rayMarch(view_pos,ray,end,maxIter);\n    bool hit = false;\n    if(depth < end)\n    {\n        pos = view_pos + depth * ray;\n        hit = true;\n        //normal = calcNormal(pos);\n        \n    } \n\n\n    vec3 xyx_pos = rotate_X(pos.xyz, HPI);\n\tvec2 gis_pos = xyz_to_gis(xyx_pos);\n\n\tfloat frame0 = 0.015;\n\tfloat frame1 = 0.135;\n\tvec2 grid;\n    vec2 gis_uv;\n    float fftw = 0.0;\n\tvec2 normaloffset;\n\tfloat rotate = 0.3 * iTime;\n\t\n\tvec3 V = -ray;\n\tvec3 RN;\n\tvec3 RBT;\n\tvec3 RT;\n    \n    float step_count = 64.0;\n    if(hit)\n\t{\n\t\tvec2 step_rad = vec2(DPI / step_count, DPI / step_count);\n\t\tvec2 gis = (gis_pos + vec2(rotate, 0.0)) / step_rad;\n\t\t\n\t\tfloat v_lon = fract(gis.x);\n\t\tgrid.x = smoothstep(frame0, frame1, v_lon) - smoothstep(1.0 - frame1, 1.0 - frame0, v_lon);\n\t\tfloat v_lat = fract(gis.y);\n\t\tgrid.y = smoothstep(frame0, frame1, v_lat) - smoothstep(1.0 - frame1, 1.0 - frame0, v_lat);\n\t\t\n\t\t\n\t\t\n\t\t//tbn\n\t\t{\n            vec2 gis_temp = (floor(gis) + vec2(0.5)) * step_rad;\n\t\t\tvec3 pos = gis_to_xyz(gis_temp - vec2(rotate, 0.0));\n\t\t\tpos = rotate_X(pos, -HPI);\n\t\t\tRN = normalize(pos);\n\t\t\t\n\t\t\tvec3 top_pos = gis_to_xyz(gis_temp - vec2(rotate, 0.029));\n\t\t\ttop_pos = rotate_X(top_pos, -HPI);\n\t\t\t\n\t\t\tRBT = normalize(top_pos - pos);\n\t\t\tRT = normalize( cross(RBT, RN) );\n\t\t\t\n\t\t}\n\t\t//normal offset\n\t\t{\n\t\t\t//left (-1.0, 0.0) \n\t\t\tfloat left = -1.0 + smoothstep(frame0, frame1, v_lon);\n\t\t\tleft *= max(sign( v_lon - frame0 ), 0.0);\n\t\t\tleft *= max(sign( frame1 - v_lon ), 0.0);\n\t\t\t//right (0.0, 1.0) \n\t\t\tfloat right = smoothstep(1.0 - frame1, 1.0 - frame0, v_lon);\n\t\t\tright *= max(sign( v_lon - (1.0 - frame1) ), 0.0);\n\t\t\tright *= max(sign( (1.0 - frame0) - v_lon), 0.0);\n\t\t\t\n\t\t\tnormaloffset.x = left + right;\n\t\t\t\n\t\t\t//bottom (-1.0, 0.0)\n\t\t\tfloat bottom = -1.0 + smoothstep(frame0, frame1, v_lat);\n\t\t\tbottom *= max(sign( v_lat - frame0 ), 0.0);\n\t\t\tbottom *= max(sign( frame1 - v_lat ), 0.0);\n\t\t\t//top  (0.0, 1.0) \n\t\t\tfloat top = smoothstep(1.0 - frame1, 1.0 - frame0, v_lat);\n\t\t\ttop *= max(sign( v_lat - (1.0 - frame1) ), 0.0);\n\t\t\ttop *= max(sign( (1.0 - frame0) - v_lat), 0.0);\n\t\t\t\n\t\t\tnormaloffset.y = bottom + top;\n\t\t}\n        //fftw\n        {\n            vec2 gis_temp = floor(gis) * step_rad;\n            gis_uv.x = fract((gis_temp.x + PI) / DPI) * 2.0;\n            gis_uv.x = fract(gis_uv.x);\n            //if(gis_uv.x > 1.0)\n            {\n                //gis_uv.x = 2.0 - gis_uv.x;\n            }\n            gis_uv.y = gis_temp.y / PI + 0.5;\n            //fftw = texture_fftw(gis_uv.x, 0.125 / (step_count * 0.5), 8.0);\n            \n            fftw = texture_fftw3(gis_uv.x, 0.25 / (step_count * 0.5), 16.0);\n            \n            fftw = 0.2 +  fftw * 0.6;\n        }\n\t}\n\tif(hit)\n\t{\n\t\tvec3 R = reflect(-V, normalize( RN + normaloffset.x * RT * 0.175 + normaloffset.y * RBT * 0.175) );\n\t\tvec3 color_ref_cube = texture(iChannel1, R).rgb;     \n\t\t//color_ref_cube *= texture(iChannel2, gis_uv).rgb;\n        color_ref_cube *= color_ref_cube;\n        color_ref_cube *= grid.x;\n\t\tcolor_ref_cube *= grid.y;\n        \n        color_ref_cube = pow(color_ref_cube, vec3(1.0, 2.0, 2.0));\n\t\t//if(abs(fftw - gis_uv.y) < 1.0 / step_count)\n        if(fftw - gis_uv.y > 0.0)\n        {\n            color_ref_cube.g += 0.40 * grid.x * grid.y;\n            //color_ref_cube = mix(color_ref_cube, vec3(0.3, 1.0, 0.0), 0.25 * grid.x * grid.y);\n        }\t\n\t\t//vec3 mask = texture(iChannel1, RN).rgb;\n\t\t//color_ref_cube *= mask;\n\n\t\tcolor += color_ref_cube;\n        \n        color += 0.40 * vec3(abs(sin(iTime)),\n                             abs(sin(iTime + HPI)),\n                             abs(sin(iTime + PI))) * (1.0 - grid.x) * (1.0 - grid.y); \n\t}\n    else\n    {\n        color += texture(iChannel1, ray).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}