{"ver":"0.1","info":{"id":"XfSSWt","date":"1706928185","viewed":99,"name":"Square Vogel Golden Spiral","username":"chronos","description":"Simply using a uniformly parameterized square instead of a circle ( the square analog of cosine and sine ).\nShows the resulting distribution for different number of sample points. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","spiral","bokeh","square","angle","kernel","fibonacci","sunflower","diagram","vogel","phyllotaxis","spread","golden","layout","ratio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Square Vogel Golden Spiral by chronos\n    \n\n    Simply using a uniformly parameterized square instead of a circle ( the square analog of cosine and sine ).\n    Shows the resulting distribution for different number of sample points. \n    It's not perfect, but it looks more than good enough to use for e.g path tracing, where we want\n    'uncorrelated'/'irregular' (but approximately evenly distributed) points.\n\n*/\n\n\nconst float PI  = 3.14159265;\nconst float PHI = (1. + sqrt(5.))/2.;\n\nfloat ramp(float a, float b, float t)\n{\n    return clamp((t-a)/(b-a), 0., 1.);\n}\n\nvec2 square(float t)\n{\n    t = fract(t);\n    float x = 2.*(ramp( 3./8., 1./8., t) + ramp(5./8., 7./8., t)) - 1.;\n    t = fract(t + 2./8.);\n    float y = 2.*(ramp( 1./8., 3./8., t) * ramp(7./8., 5./8., t)) -1.;\n    return vec2( x, y );\n}\n\nvec3 colmap(float t)\n{\n    vec3 center = vec3(1)/3.;\n    vec3 offset = vec3(2., -1, -1) / 3.;\n    \n    vec3 ax = normalize(vec3(1));\n    \n    return center + offset * cos(t) + cross(ax, offset) * sin(t);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.1;\n    vec2 uv = zoom*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = zoom*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float ps = 2. / iResolution.y;\n    \n    vec3 color = vec3(0);\n    \n    if(length(iMouse.xy) < 10.) mouse = square(iTime/3.);\n    \n    float N = 1000. * ((mouse.y + zoom)/zoom *.5 * .75 + 0.025 );\n    float min_dist = 9e9;\n    float min_r = 9e9;\n    float min_t = 0.;\n    \n    for(float i = 0.5; i < N; i++)\n    {\n        float r = float(i)/N;\n        \n        #if 1\n        float t = PHI * i;\n        #else\n        float t = i / (PHI * PHI);\n        #endif\n        \n        vec2 p = square(t) * sqrt(r);\n                \n        float d = length(p-uv);\n        \n        if(d < min_dist)\n        {\n            min_dist = d;\n            min_r = r;\n            min_t = t;\n        }\n    }\n    \n    vec3 voronoi_color = colmap(min_t);\n    color = voronoi_color * mix(0., .05, (square(iTime/12.).x + 1.)*.5);\n    //color = mix(color, vec3(1), smoothstep(ps, -ps, length(uv-square(iTime/12.))-0.01));\n    \n    vec3 dot_color = vec3(min_r, 0.1, 1.-min_r)*0.99;\n    color = mix(color, vec3(0), smoothstep(ps, -ps, min_dist-0.01-2.*ps));\n    float alpha = smoothstep(ps, -ps, min_dist-0.01);\n    color = mix(color, dot_color, alpha);\n    \n    vec2 q = abs(min(.5*(uv+1.), 1.-.5*(uv+1.)));\n    \n    float d = min(q.x, q.y);\n    alpha = smoothstep(ps, 0., d);\n    \n    color = mix(color, vec3(.5), alpha);\n    color *= smoothstep(ps, -ps, abs(uv.x) - 1.);\n    color *= smoothstep(ps, -ps, abs(uv.y) - 1.);\n    \n    color = sqrt(tanh(color * color));\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}