{"ver":"0.1","info":{"id":"McG3DD","date":"1712923678","viewed":69,"name":"Planet thingy (ray traced)","username":"Artificialvoid1","description":"So this is an attempt at making a ray tracer, diffuse lighting kinda broken, the orange is supposed to be a star. There is a point light inside Sphere2.\n\nUpdate, i completely redid this and I’m trying hard not to use buffers as I’m working on iOS. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//note: add sphere light\n\nsphere Sphere1 = sphere(vec3(-70, -50, 150), 100.0, vec3(0,0,1));\nsphere Sphere2 = sphere(\n    vec3(150, 100,300),\n    100.0,\n    vec3(1,0,0)\n);\n\n//EXTRA FUNCTIONS\n\nvec3 suntexture( vec2 uv ) {\n    vec3 col = vec3(texture(iChannel1, uv/vec2(0.5)+vec2(iTime/500.0)).x);\n    \n    vec3 inverted_basecolor = vec3(0.2, 0.7, 1.0);\n    vec3 basecolor = vec3(1.0) - (col * inverted_basecolor);\n    return basecolor * vec3(1.0, 0.5, 0);\n}\n\n//normal vector on a sphere\nvec3 sphereNormal( vec3 point ) {\n    vec3 gradient = vec3(2) * point;\n    return normalize(gradient);\n}\n\n\n//RAY CALCULATION\n\nrayres cast_ray(vec3 origin, vec3 direction, sphere OBJ, rayres previous) {\n    \n    float t = dot(OBJ.position - origin, direction);\n    vec3 P = origin + (direction * vec3(t));\n    float Yf = distance(OBJ.position, P);\n    float Xf = sqrt(OBJ.radius * OBJ.radius + Yf * Yf);\n    vec3 t1 = origin + (direction * vec3(t-Xf));\n    \n    if (Yf <= OBJ.radius) {\n        rayres results = rayres(\n        OBJ,\n        OBJ.color,\n        t1,\n        P\n        );\n        return results;\n    } else if (previous.color != vec3(0)) {\n        return previous;\n    } else {\n        rayres results = rayres(\n            sphere(vec3(0), 0.0, vec3(0)),\n            vec3(0,0,0),\n            vec3(0,0,0),\n            P\n        );\n        return results;\n    }\n}\n\n//MAIN IMAGE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    //setting up the ray direction\n    float Xoffset = -0.5 * 16.0;\n    float Yoffset = -0.5 * 9.0;\n    \n    float xdiv = 16.0/iResolution.x;\n    float ydiv = 9.0/iResolution.y;\n    float distToSun;\n    float distToP;\n        \n    //gather all data to cast a ray\n    vec3 origin = vec3(0, 0, -15);\n    float faceX = xdiv * fragCoord.x;\n    float faceY = ydiv * fragCoord.y;\n    vec3 target = vec3(faceX + Xoffset, faceY + Yoffset, -1);\n    vec3 rayDir = normalize(target - origin);\n    \n    \n    //cast ray\n    rayres rayResults = cast_ray(origin, rayDir, Sphere1, rayres(\n            sphere(vec3(0), 0.0, vec3(0)),\n            vec3(0,0,0),\n            vec3(0,0,0), vec3(0)));\n        \n    rayResults = cast_ray(origin, rayDir, Sphere2, rayResults);\n    \n    \n    if (rayResults.color == vec3(0)) {\n        //if ray hits nothing\n        col = vec3(0);\n        distToSun = distance(rayResults.P, Sphere2.position);\n        distToP = distance(rayResults.P, Sphere1.position);\n        vec2 offsetC = vec2(iTime/7.0);\n        vec4 noiseTexture = texture(iChannel2, (fragCoord/vec2(300.0))+offsetC);\n        \n        if (noiseTexture.x >= 0.9 && noiseTexture.z >= 0.9) {\n            col = vec3(1);\n        } else if (noiseTexture.x >= 0.9) {\n            col = vec3(1,0,0);\n        } else if (noiseTexture.z >= 0.95) {\n            col = vec3(1);\n        }\n    } else {\n        col = rayResults.color;\n    }\n    \n    if (col == vec3(1,0,0)) {\n        //ray hits the sun\n    \n        vec2 uv = getpointOnSphere(rayResults.hit);\n        \n        vec3 col2 = suntexture(uv);\n        col = col2;\n        distToSun = distance(rayResults.P, Sphere2.position);\n        distToP = distance(rayResults.P, Sphere1.position);\n    \n    } else if (col == vec3(0,0,1)) {\n        //ray hits planet\n        vec2 uv = getpointOnSphere(rayResults.hit);\n        \n        vec3 col2 = texture(iChannel0, uv + vec2(iTime/200.0 , iTime/40.0 )).xyz;\n\n        col2 = vec3(1.0 - col2.r,1.0 - col2.g,1.0 - col2.b);\n        col = vec3(1, 1, 0);\n        col *= col2;\n        \n        col = vec3(1.0 - col.r,1.0 - col.g,1.0 - col.b);\n        distToSun = distance(rayResults.hit, Sphere2.position);\n        distToP = distance(rayResults.P, Sphere1.position);\n  \n    }\n        //bloom\n    \n        float distToSurface = distToSun - Sphere2.radius;\n        \n        float distToPS = distToP - Sphere1.radius;\n        \n        if (distToPS >= 0.0) {\n            \n            col = mix(vec3(1,0.6,0), col, distToSurface/50.0);\n            col = mix(vec3(1,1,1), col, distToPS/140.0);   \n            col = mix(vec3(1,0.6,0.3), col, distToPS/150.0);\n        }\n    \n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159\n//VARIABLES\n\nstruct sphere {\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nstruct rayres {\n    sphere object;\n    vec3 color;\n    vec3 hit;\n    vec3 P;\n};\n\nvec2 getpointOnSphere(vec3 p) {\n  float theta = atan(p.x, p.z);\n  \n  float radius = length(p);\n\n  float phi = acos(p.y / radius);\n  float raw_u = theta / (2.0 * pi);\n\n  float u = 1.0 - (raw_u + 0.5);\n  float v = 1.0 - phi / pi;\n\n  return vec2(u, v);\n}\n\n//noise\nfloat hash(vec2 uv)\n{\n    return fract(sin(7.289 * uv.x + 11.23 * uv.y) * 23758.5453);\n}","name":"Common","description":"","type":"common"}]}