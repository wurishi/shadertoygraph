{"ver":"0.1","info":{"id":"ttdczn","date":"1608404115","viewed":140,"name":"RTAO","username":"Shcherbakov","description":"Ray tracing ambient occlusion sample from stream: https://www.youtube.com/watch?v=s9O08T9XD3g&ab_channel=GraphicsMonster","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n  float off = 1.5*sin( 0.01*iTime );\n  \n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n     \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n    if( h.x<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n  if( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-5, -5, 10), vec3(-5, 5, 10), vec3(5, 5, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-5, -5, 10), vec3(5, 5, 10), vec3(5, -5, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    float intersectionSpecular;\n    for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n        float hitDist = ray_sphere_intersection(SPHERES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = SPHERES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = normalize(intersectionPos - SPHERES[i].pos);\n            intersectionSpecular = SPHERES[i].specular;\n        }\n    }\n\n    for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n        float hitDist = ray_triangle_intersection(TRIANGLES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = TRIANGLES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = TRIANGLES[i].normal;\n            intersectionSpecular = TRIANGLES[i].specular;\n        }\n    }\n    \n    vec4 sdf = intersect(cameraPos * 2.0 - vec3(2, -1, 0), viewVec);\n    if (sdf.x > 0.0 && sdf.x < intersectionDist) {\n        intersectionDist = sdf.x;\n        intersectionColor = vec3(1, 0, 0);\n        intersectionPos = sdf.yzw * 2.0 - vec3(2, -1, 0);\n        intersectionNormal = calcNormal(sdf.yzw);\n        intersectionSpecular = 0.0;\n    }\n\n    vec3 lighting = intersectionColor * SKY_COLOR;\n    \n    float ao = 0.0;\n    const int AO_SAMPLES = 64;\n    const float RAY_DIST = 1.5;\n    vec3 aoStartPos = intersectionPos + intersectionNormal * 1e-2;\n    for (int i = 0; i < AO_SAMPLES; ++i) {\n        vec3 sampleDir = texture(iChannel0, vec2((float(i) + 0.5) / 64.0, 0)).rgb * 2.0 - 1.0;\n        if (dot(intersectionNormal, sampleDir) < 0.0) {\n            sampleDir = -sampleDir;\n        }\n        sampleDir = normalize(sampleDir);\n        \n        float t = RAY_DIST;\n        bool itersected = false;\n        for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n            float hitDist = ray_sphere_intersection(SPHERES[i], aoStartPos, sampleDir);\n            if (hitDist < t) {\n                t = hitDist;\n            }\n        }\n\n        for (uint i = 0u; i < TRIANGLES_COUNT && !itersected; ++i) {\n            float hitDist = ray_triangle_intersection(TRIANGLES[i], aoStartPos, sampleDir);\n            if (hitDist < t) {\n                t = hitDist;\n            }\n        }\n        vec4 aoSdf = intersect(aoStartPos, sampleDir);\n        if (aoSdf.x > 0.0 && aoSdf.x < min(t, RAY_DIST)) {\n            t = aoSdf.x;\n        }\n        \n        ao += 1.0 - (RAY_DIST - t) / RAY_DIST;\n    }\n    ao /= float(AO_SAMPLES);\n    fragColor.xyz = vec3(ao);\n    lighting *= ao;\n\n    bool shadow = false;\n    vec3 shadowCastPos = intersectionPos - SUN_DIR * 0.001;\n    for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n        float hitDist = ray_sphere_intersection(SPHERES[i], shadowCastPos, -SUN_DIR);\n        shadow = shadow || hitDist < FAR_INF;\n    }\n\n    for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n        float hitDist = ray_triangle_intersection(TRIANGLES[i], shadowCastPos, -SUN_DIR);\n        shadow = shadow || hitDist < FAR_INF;\n    }\n    \n    vec4 shadowSdf = intersect(shadowCastPos * 2.0 - vec3(2, -1, 0), -SUN_DIR);\n    shadow = shadow || shadowSdf.x > 0.0;\n\n    if (!shadow) {\n        lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor * ao;\n        if (intersectionSpecular != 0.0)\n            lighting += pow(max(0.0, dot(reflect(-SUN_DIR, intersectionNormal), viewVec)), intersectionSpecular);\n    }\n    fullLighting += lighting;\n\n    fragColor.xyz = pow(fullLighting, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"}]}