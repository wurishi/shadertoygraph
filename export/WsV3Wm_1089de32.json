{"ver":"0.1","info":{"id":"WsV3Wm","date":"1570328530","viewed":130,"name":"Fractal Fragments (Julia Set)","username":"zerovolts","description":"Mandelbrot + Voronoi + Noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define MAX_ITER 2000\n#define VORONOI_CELL_COUNT 128\n#define PI 3.141592\n#define TAU 6.28318\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Source: https://www.shadertoy.com/view/Ms2SD1\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// Source: https://www.shadertoy.com/view/Ms2SD1\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 complex_mul(vec2 c1, vec2 c2) {\n    return vec2(\n        (c1.x * c2.x) - (c1.y * c2.y),\n        (c1.x * c2.y) + (c1.y * c2.x)\n    );\n}\n\n// Returns the number of iterations before escaping above 2, or max_iter.\nint mandelbrot(vec2 coord, int max_iter) {\n    // vec2 z = vec2(0);\n    vec2 z = coord;\n    vec2 c = vec2(.355, .355);\n    for (int i = 0; i < max_iter; i++) {\n        z = complex_mul(z, z) + c;\n        if (length(z) > 2.0) return i;\n    }\n    return max_iter;\n}\n\n// Returns the Voronoi cell index that the point falls in\nint voronoi(vec2 position) {\n    vec2 points[VORONOI_CELL_COUNT];\n    float minDist = 100000.0;\n    int nearestIndex = -1;\n    for (int i = 0; i < VORONOI_CELL_COUNT; i++) {\n        points[i] = random2(vec2(float(i), float(i)));\n        points[i] = 0.5 + 1.0 * sin((iTime / 8.0) + TAU * points[i]);\n        float dist = distance(position, points[i]);\n        if (dist < minDist) {\n            minDist = dist;\n            nearestIndex = i;\n        }\n    }\n    return nearestIndex;\n}\n\nvec2 rotate(vec2 coord, float angle) {\n    float sinFactor = sin(angle);\n    float cosFactor = cos(angle);\n    mat2 rotation = mat2(cosFactor, sinFactor, -sinFactor, cosFactor);\n    return coord * rotation;\n}\n\n// Takes a fragCoord and transforms it into a usable coordinate\nvec2 camera(vec2 fragCoord, vec2 center, float zoom, float angle) {\n    float min_dimension = min(iResolution.x, iResolution.y);\n    vec2 normalized_coord = (fragCoord - 0.5 * iResolution.xy) / min_dimension;\n    return rotate(normalized_coord * zoom, angle) + center;\n}\n\nvec3 subsample(vec2 mandelbrot_coord, vec2 voronoi_coord) {\n    int max_iter = min(int(iTime * 8.0), MAX_ITER);\n    int mandel = mandelbrot(mandelbrot_coord, max_iter);\n    float mandel_norm = float(mandel) / float(max_iter);\n\n    int voronoi_index = voronoi(voronoi_coord);\n    float voronoi_norm = (float(voronoi_index) / float(VORONOI_CELL_COUNT));\n\n    vec3 color;\n    if (mandel < max_iter) {\n        float variance = sin(mandel_norm * TAU * 16.0) / 8.0 + 0.4;\n        color = hsv2rgb(vec3(\n            sin((mandel_norm * TAU / 8.0) + (iTime * TAU / 32.0) + (voronoi_norm * TAU / 16.0)) / 2.0 + 0.5,\n            variance,\n            variance\n        ));\n    } else {\n        float height = 0.0;\n        for (int i = 1; i < 16; i++) {\n            vec2 right_movement = vec2(-iTime / 32.0, 0);\n            height += noise((voronoi_coord + vec2(1, 0) + rotate(right_movement, 0.0)) * float(i) * 32.0) / float(i);\n            height += noise((voronoi_coord + vec2(0, 1) + rotate(right_movement, TAU / 3.0)) * float(i) * 32.0) / float(i);\n            height += noise((voronoi_coord + rotate(right_movement, TAU / 3.0 * 2.0)) * float(i) * 32.0) / float(i);\n        }\n        height /= 2.0;\n        height += 0.5;\n        color = hsv2rgb(vec3(\n            iTime / 16.0 + height / 8.,\n            height / 4.0 + 0.4,\n            height / 4.0 + 0.4\n        ));\n    }\n\n    return color;\n}\n\nmat4x2 split_fragment(vec2 fragCoord) {\n    float distToCenter = 0.25;\n    return mat4x2(\n        vec2(fragCoord.x - distToCenter, fragCoord.y - distToCenter),\n        vec2(fragCoord.x + distToCenter, fragCoord.y + distToCenter),\n        vec2(fragCoord.x + distToCenter, fragCoord.y - distToCenter),\n        vec2(fragCoord.x - distToCenter, fragCoord.y + distToCenter)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    mat4x2 subsamples = split_fragment(fragCoord);\n\n    // vec2 mandelbrot_center = vec2(-1.483, 0);\n    // vec2 mandelbrot_center = vec2(-0.09, 0.650004);\n    vec2 mandelbrot_center = vec2(-0.091069, 0.65899);\n    float mandelbrot_zoom = (8.0 / float(pow(1.5, iTime / 2.0)));\n    float mandelbrot_angle = 0.;//iTime / 8.0;\n    mat4x2 mandelbrot_coords = mat4x2(\n        camera(subsamples[0], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle),\n        camera(subsamples[1], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle),\n        camera(subsamples[2], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle),\n        camera(subsamples[3], mandelbrot_center, mandelbrot_zoom, mandelbrot_angle)\n    );\n\n    vec2 voronoi_center = vec2(0.5);\n    float voronoi_zoom = 1.0;\n    float voronoi_angle = iTime / -16.0;\n    mat4x2 voronoi_coords = mat4x2(\n        camera(subsamples[0], voronoi_center, voronoi_zoom, voronoi_angle),\n        camera(subsamples[1], voronoi_center, voronoi_zoom, voronoi_angle),\n        camera(subsamples[2], voronoi_center, voronoi_zoom, voronoi_angle),\n        camera(subsamples[3], voronoi_center, voronoi_zoom, voronoi_angle)\n    );\n\n    // Uncomment to apply anti-aliasing\n    vec3 col = vec3(0);\n    col += subsample(mandelbrot_coords[0], voronoi_coords[0]);\n    //col += subsample(mandelbrot_coords[1], voronoi_coords[1]);\n    //col += subsample(mandelbrot_coords[2], voronoi_coords[2]);\n    //col += subsample(mandelbrot_coords[3], voronoi_coords[3]);\n    //col /= 4.;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}