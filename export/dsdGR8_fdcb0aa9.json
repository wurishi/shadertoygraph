{"ver":"0.1","info":{"id":"dsdGR8","date":"1677232613","viewed":65,"name":"Quad Bezier chain - distance 2D","username":"MatheoMoinet","description":"Chaining together multiple quadratic bezier curves","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","bezier","spline","distance","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =========== Bezier Curves Definitions ===========================================================================================================================================================\n\nvoid createAllBezierCurves(){\n    // Curve 1\n    vec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    \n    vec2[3] bezier_1_init_pts = vec2[](\n            v0,\n            v1,\n            v2\n    );\n    vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_1_addi_pts;\n    bezier_1_addi_pts[0] = vec2(-1., -0.5);\n    bezier_1_addi_pts[1] = vec2(-1., -1.);\n    bezier_1_addi_pts[2] = vec2(0.2, 0.7);\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_1_Bs_dist_coef;\n    bezier_1_Bs_dist_coef[0] = 1.0;\n    bezier_1_Bs_dist_coef[1] = 0.5;\n    bezier_1_Bs_dist_coef[2] = 1.;\n    BezierCurve bezier1 = createBezierCurve(bezier_1_init_pts, bezier_1_addi_pts, bezier_1_Bs_dist_coef, 4);\n    \n    // Curve 2\n    vec2[3] bezier_2_init_pts = vec2[](\n        vec2(0.0,0.0),\n        vec2(1.2,0.),\n        vec2(1., -0.5)\n    );\n    vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_2_addi_pts;\n    //bezier_2_addi_pts[0] = vec3(-10., -1., 0.);\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] bezier_2_Bs_dist_coef;\n    //bezier_2_Bs_dist_coef[0]=1.;\n    BezierCurve bezier2 = createBezierCurve(bezier_2_init_pts, bezier_2_addi_pts, bezier_2_Bs_dist_coef, 1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mousePosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    createAllBezierCurves();\n    initBezierCurves();\n    \n    float d = sdBezier(position);\n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d); // ripples\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 3.0, (abs(d) - 0.003) * iResolution.y));\n    \n    if (iMouse.z > 0.0) {\n        float dm = sdBezier(mousePosition);\n        color = mix(color, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(position-mousePosition)-abs(dm))-0.0025));\n        color = mix(color, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(position-mousePosition)-0.015));\n    }\n    \n    fragColor = vec4(color, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int bezier_nbr_curves = 2;\nconst int bezier_nbr_segments = 5; //Total nbr of segments of all curves\n#define BEZIER_MAX_NBR_ADDI_SEGMENTS 4 //Max nbr of segments for one curve\n\n\n\n\n\n\n//From FabriceNeyret2 https://www.shadertoy.com/view/llySRh\n// --- key toggles -----------------------------------------------------\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel3,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel3,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n// --- events ----------------------------------------------------------\n\n// --- mouse side events https://www.shadertoy.com/view/3dcBRS\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n// ------------------\n\n\n\n// ========= Bezier Struct and Globals =======================================================================================================================\nstruct BezierSegment {\n    vec2 A,B,C;  //Control points\n};\n\nstruct BezierCurve {\n    vec2[3] init_ctrl_points;\n    vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] addi_ctrl_points;\n    float[BEZIER_MAX_NBR_ADDI_SEGMENTS] Bs_dist_coef;\n    int curve_id;\n    int nbr_segments;\n    int segment_arr_offset;\n};\nBezierCurve[bezier_nbr_curves] bezier_curves;\nint new_curve_arr_offset=0;\nint new_curve_id = 0;\nBezierSegment[bezier_nbr_segments] bezier_all_segments;\n\n\n// ============= Bezier Basic Functions =========================================================================================================================================================\n\nvec2 bezierFunc( vec2 A, vec2 B, vec2 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return (1.0-t)*(1.0-t)*A + 2.0*(1.0-t)*t*B + t*t*C; // b(t) = (1-t)^2*A + 2(1-t)t*B + t^2*C\n}\n\nvec2 bezier_dx( vec2 A, vec2 B, vec2 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return 2.0*(t-1.0)*A + 2.0*(1.0-2.0*t)*B + 2.0*t*C; // b'(t) = 2(t-1)*A + 2(1-2t)*B + 2t*C\n}\n\nvec2 bezier_dx_dx( vec2 A, vec2 B, vec2 C, float t ){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    return 2.0*A - 4.0*B + 2.0*C; // b\"(t) = 2*A - 4*B + 2*C\n}\n\n// ============= Bezier Setup Functions =========================================================================================================================================================\n\nBezierSegment bezierGetSegment(BezierCurve bezier_curve, int segment_i){\n    return bezier_all_segments[bezier_curve.segment_arr_offset+segment_i];\n}\nvoid bezierSetSegment(BezierCurve bezier_curve, int segment_i, BezierSegment segment){\n    bezier_all_segments[bezier_curve.segment_arr_offset+segment_i] = segment;\n}\n\nvoid bezierCreateSegments(BezierCurve bezier_curve){\n    int seg_idx = bezier_curve.segment_arr_offset;\n    bezier_all_segments[seg_idx].A = bezier_curve.init_ctrl_points[0];\n    bezier_all_segments[seg_idx].B = bezier_curve.init_ctrl_points[1];\n    bezier_all_segments[seg_idx].C = bezier_curve.init_ctrl_points[2];\n    for (int i=0; i<bezier_curve.nbr_segments-1; i++){\n        int seg_idx = bezier_curve.segment_arr_offset+i+1;\n        vec2 A = bezier_all_segments[seg_idx-1].C;\n        vec2 C = bezier_curve.addi_ctrl_points[i];\n        vec2 prevB = bezier_all_segments[seg_idx-1].B;\n        vec2 B = A + (A-prevB)*bezier_curve.Bs_dist_coef[i];\n        bezier_all_segments[seg_idx].A = A;\n        bezier_all_segments[seg_idx].B = B;\n        bezier_all_segments[seg_idx].C = C;\n    }\n}\n\nvoid bezierInitSegmentLength(BezierCurve b_curve){\n    float acc_length_offset = 0.;\n    for (int i=0; i<b_curve.nbr_segments; i++){\n        BezierSegment seg = bezierGetSegment(b_curve, i);\n        bezierSetSegment(b_curve, i, seg);\n    }\n}\n\nvoid initBezierSegments(BezierCurve bezier_curve){\n    bezierCreateSegments(bezier_curve);\n    bezierInitSegmentLength(bezier_curve);\n}\n\nvoid initBezierCurves(){\n    for (int i=0; i<bezier_curves.length(); i++){\n        initBezierSegments(bezier_curves[i]);\n    }\n}\n\nBezierCurve createBezierCurve( vec2[3] init_ctrl_points,  vec2[BEZIER_MAX_NBR_ADDI_SEGMENTS] addi_ctrl_points,  float[BEZIER_MAX_NBR_ADDI_SEGMENTS] Bs_dist_coef,  int nbr_of_segments){\n    int curve_id = new_curve_id++;\n    int segment_arr_offset = new_curve_arr_offset;\n    new_curve_arr_offset += nbr_of_segments;\n    BezierCurve bezier_curve = BezierCurve(init_ctrl_points, addi_ctrl_points, Bs_dist_coef, curve_id, nbr_of_segments, segment_arr_offset);\n    bezier_curves[curve_id] = bezier_curve;\n    return bezier_curve;\n}\n\n// ======================================================================================================================================================================\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){ //Taken from IQ's shader : https://www.shadertoy.com/view/ldj3Wh\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        // 1 root\n        res = vec2(dot2(d+(c+b*t)*t),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        \n        // 3 roots, but only need two\n        float dis = dot2(d+(c+b*t.x)*t.x);\n        res = vec2(dis,t.x);\n        dis = dot2(d+(c+b*t.y)*t.y);\n        if( dis<res.x ) res = vec2(dis,t.y );\n    }\n    res.x = sqrt(res.x);\n    return res;\n}\n\nvec2 sdBezier(vec2 pos, BezierCurve bezier_curve, BezierSegment segment){\n    vec2 A = segment.A, B = segment.B, C = segment.C;\n    vec2 res = sdBezier(pos, A,B,C);\n    return res;\n}\n\nvec2 sdBezier(vec2 pos, BezierCurve bezier_curve){ // sd for multy segment bezier curve\n    vec2 best_res = vec2(1e10);\n    for (int i=0; i<bezier_curve.nbr_segments; i++){   \n        BezierSegment currentSegment = bezierGetSegment(bezier_curve,i);\n        vec2 res = sdBezier(pos, bezier_curve, currentSegment);\n        if (res.x < best_res.x ){ //&& res.y>=0. && res.y<=1.\n            best_res = res;\n            best_res.y += float(i); \n        }\n    }\n    return best_res;\n}\n\nfloat sdBezier(vec2 p) {\n    float d=1e8;\n    for (int i=0; i<bezier_nbr_curves; i++){\n        BezierCurve bezier_curve = bezier_curves[i];\n        d = min(d,sdBezier(p, bezier_curve).x);\n    }\n    return d;\n}","name":"Common","description":"","type":"common"}]}