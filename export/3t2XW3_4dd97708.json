{"ver":"0.1","info":{"id":"3t2XW3","date":"1567469031","viewed":124,"name":"Playing with Links","username":"gressettd","description":"Playing with tiling shapes with overlapped tiling. Written for clarity, not optimization.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tile","mesh","shape","link"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592;\nconst float SQRT3 = 1.73205; \nconst float VW = 0.1;\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.141592));\n}\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(PI * 2.0 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\nfloat sdCircle( highp vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat Map(float value, float old_lo, float old_hi, float new_lo, float new_hi)\n{\n    float old_range = old_hi - old_lo;\n    float new_range = new_hi - new_lo;\n    return (((value - old_lo) * new_range) / old_range) + new_lo;\n}\n\n\n    \n// cvcc = convex / concave:\n// link shape control, ranging from -1 (concave) to 1 (convex)\nfloat sdLink(in highp vec2 p, float cvcc)\n{\n    float rv = 0.0;\n    \n    \n    float md = sdCircle(p, 1.0);\n    \n    \n    float rs = 0.0;\n    float disp = 0.0;\n    float dist = 0.0;\n    \n    // side circle radii\n    rs = (2.0 * abs(cvcc))+1.0; \n    \n    // compute displacement of side circles\n    if(sign(cvcc) > 0.0)\n    {\n         // hack to keep vesica length about same.\n         // just a linear mapping between the \n         // extremes of the convexity to to side circle displacement,\n         // bent with a power function to adapt to the non-linearity \n         // of the result. \n         float inp = pow(1.0-cvcc,2.1);\n         float xl = Map(inp, 0.0, 1.0, SQRT3*VW,  VW * PI * SQRT3);\n        \n         disp = rs - xl;\n    } else\n    {\n        // cut into about half the middle circle \n        disp = rs + 0.5;\n    }\n    \n    // our shape is either the intersection of two circles (vesica),\n    // or the subtraction of two circles from a center one (axehead) ...\n    // since intersection is max(a,b) and subtraction is max(a,-b),\n    // we can use the sign of our argument to control \n    // which we're doing ...\n    float ld = sdCircle(vec2(p.x + disp, p.y),rs) * sign(cvcc);\n    float rd = sdCircle(vec2(p.x - disp, p.y),rs) * sign(cvcc);\n    \n    dist = max(md, ld);\n    dist = max(dist, rd);\n    \n    return dist;\n}\n\nhighp vec4 GridTile(vec2 uv, float rep)\n{\n    highp float sp = 1.0 / rep;\n    highp vec2 div = uv / sp;\n    highp vec2 grid = floor(div);\n    \n    // cell coordinates, with origin in the center\n    // of the cell.\n    highp vec2 gc = 2.0*fract(div) - vec2(1.0,1.0) ;\n    return vec4(grid,gc);\n}\n\n\nhighp vec2 Rotate2D(highp vec2 v, float a) \n{\n\t\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\thighp mat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat XNor(vec2 p)\n{\n    return abs(p.x + p.y - 1.0);\n}\n\nvec2 RotateGridLink(highp vec2 pos, vec2 grid, bool linkAngled, highp float scaleFactor)\n{\n    highp vec2 shpCoord = scaleFactor * pos;\n    \n    if(linkAngled) // either rotate by 45 degrees or 90 degrees, \n        // depending on both grid position and \"linkAngled\" argument\n        shpCoord = Rotate2D(shpCoord, (2.0*mod(grid.x + grid.y,2.0)-1.0) * (PI/4.0));\n    else\n        shpCoord = Rotate2D(shpCoord, XNor(grid) * (PI/2.0));\n    \n    return shpCoord;\n        \n}\n\n\nhighp vec3 ComputeDispLink(\n    highp vec2 coord, \n    highp vec2 grid, \n    float rep,\n    highp vec2 disp,\n    highp float scaleFactor, \n    float cvcc, \n    bool linkAngled)\n{\n   \n    \n    highp vec2 gridB = grid + disp;\n    highp vec2 tXcoord = coord - (2.0 * disp);\n    \n    highp vec2 s = RotateGridLink(tXcoord, gridB, linkAngled, scaleFactor);\n    \n    highp float distB = sdLink(s, cvcc);\n    \n    return vec3(distB, gridB);\n}\n\nhighp vec3 MinDist(highp vec3 a, highp vec3 b)\n{\n    if(a.x<b.x)return a;\n    return b;\n}\n    \n\nvec4 ComputeLinkGrid(\n    highp vec2 uv, \n    float cvcc, \n    float rep, \n    float gridAngle, \n    bool linkAngled,\n\tfloat softness)\n{\n    vec4 rv;\n    uv = Rotate2D(uv,-gridAngle);\n    \n    \n    highp vec4 gridInfo = GridTile(uv, rep);\n    highp vec2 grid = gridInfo.xy;\n    highp vec2 cellCoord = gridInfo.zw;\n    \n    \n    // union all surrounding tiles, since they overlap this one\n    highp float scaleFactor = 0.7;\n    highp vec3 tzz = ComputeDispLink(cellCoord, grid, rep, vec2(0.0,0.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tnn = ComputeDispLink(cellCoord, grid, rep, vec2(-1.0,-1.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tzn = ComputeDispLink(cellCoord, grid, rep, vec2(0.0,-1.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tpn = ComputeDispLink(cellCoord, grid, rep, vec2(1.0,-1.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tnz = ComputeDispLink(cellCoord, grid, rep, vec2(-1.0,0.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tpz = ComputeDispLink(cellCoord, grid, rep, vec2(1.0,0.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tnp = ComputeDispLink(cellCoord, grid, rep, vec2(-1.0,1.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tzp = ComputeDispLink(cellCoord, grid, rep, vec2(0.0,1.0),scaleFactor,cvcc,linkAngled);\n    highp vec3 tpp = ComputeDispLink(cellCoord, grid, rep, vec2(1.0,1.0),scaleFactor,cvcc,linkAngled);\n    \n    highp vec3 winner;\n    winner = MinDist(tzz,tnn);\n    winner = MinDist(winner,tzn);\n    winner = MinDist(winner,tpn);\n    winner = MinDist(winner,tnz);\n    winner = MinDist(winner,tpz);\n    winner = MinDist(winner,tnp);\n    winner = MinDist(winner,tzp);\n    winner = MinDist(winner,tpp);\n            \n\thighp float minDist = winner.x;\n    highp vec2 minGrid = winner.yz;\n \n    // 4d color control out, as is my convention\n    float intensity = pow(clamp(-minDist,0.0,1.0), softness);\n    rv = vec4(intensity,minGrid.x, minGrid.y,minDist);\n    return rv;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    highp vec2 uv = fragCoord/float(iResolution.y);\n    // uv.y *= float(iResolution.y) / float(iResolution.x); // use with sdLink test below\n    // uv = 2.0*uv - vec2(1.0,1.0);\n       \n    // animation control\n    float switchSeconds = 10.0;\n    float tm= sin(mod(iTime,switchSeconds));\n    float frm = step(0.5,mod(iTime,switchSeconds) /switchSeconds);\n    float rot = step(0.5,mod(iTime,switchSeconds * 10.0) / (switchSeconds*10.0)) * PI/4.0;\n    float softness = Map(sin(iTime / 10.0),-1.0,1.0, 0.25, 0.75);\n\n    \n    // shaping\n    vec4 cc = ComputeLinkGrid(uv, tm, 8.0, rot, frm==0.0, softness);\n    \n    // coloration\n    vec2 grid = cc.yz; // which cell controls color\n        \n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n    float t = Random2D(grid);\n    vec4 col = ComputeWaveGradientRGB(t,bias,scale,freq,phase);\n    \n    // use intensity shape info\n    col *=  cc.x;\n    col = pow(col,vec4(0.6));\n    \n    /*\n    float dist = sdLink(uv,tm);\n    float intensity = pow(clamp(-dist,0.0,1.0), softness);\n    vec3 col = intensity * vec3(0.4,0.4,1.0);\n\t*/\n    \n    fragColor = vec4(col.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}