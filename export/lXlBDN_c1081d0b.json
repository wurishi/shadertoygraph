{"ver":"0.1","info":{"id":"lXlBDN","date":"1728515248","viewed":15,"name":"viscosity","username":"darnok","description":"viscosity torus","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","viscosity"],"hasliked":0,"parentid":"433SW7","parentname":"template raymarching"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 applyDirectionalBlur(vec2 uv, vec2 direction, vec2 texel)\n{\n    vec4 color = texture(iChannel1, uv) * BLUR_WEIGHTS[0];\n    \n    for (int i = 1; i < 5; i++)\n    { \n        vec2 offset = texel * direction * BLUR_OFFSETS[i];\n        color += texture(iChannel1, uv + offset) * BLUR_WEIGHTS[i];\n        color += texture(iChannel1, uv - offset) * BLUR_WEIGHTS[i];\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = vec2(1.0) / iResolution.xy;\n    vec4 color = applyDirectionalBlur(uv, BLUR_DIRECTION_V, texel);\n    \n    float maskBufferA = max(0., sign(texture(iChannel0, uv).r));\n    float maskBufferBlur = 1. - maskBufferA;\n    \n    vec3 buffACol = vec3(maskBufferA * texture(iChannel0, uv).r);\n    vec3 buffBCol = maskBufferBlur * color.g * vec3(0.6, 0.9, 0.1);\n    fragColor = vec4(buffACol + buffBCol, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI     3.14159265\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h*h*h*k*(1.0 / 6.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xy)-t.x,p.z) )-t.y;\n}\n\nfloat angle(vec2 v){\n    float angle = atan(v.x, v.y);  // atan2\n    return angle;\n    \n    float degrees = 180. * angle / PI;\n    return mod((360. + degrees), 360.);\n}\n\nconst vec2 BLUR_DIRECTION_H = vec2(1.0, 0.0); // horizontal pass\nconst vec2 BLUR_DIRECTION_V = vec2(0.0, 1.0); // vertical pass\nconst float BLUR_OFFSETS[5] = float[](0.0, 1.0, 2.0, 3.0, 4.0);\nconst float BLUR_WEIGHTS[5] = float[](0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n// Function Operator\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\n\n// Distance to the scene\nfloat map(vec3 p) {\n    vec3 p1 = p;\n    p1.xy += vec2(\n    0.1 * cos(angle(p1.xy) * 5. + iTime * 1.),\n    0.1 * sin(angle(p1.xy) * 5. + iTime * 1.));\n\n    p1.xy += vec2(\n    0.1 * cos(angle(p1.xy) * 2.),\n    0.1 * sin(angle(p1.xy) * 2.));\n\n    p1.xy += vec2(\n    0.05 * cos(angle(p1.xy) * 8. - iTime * 1.),\n    0.05 * sin(angle(p1.xy) * 8. - iTime * 1.));\n    \n    float torus = sdTorus(p1, vec2(2.1, .05));\n    \n    \n    vec3 p2 = p;\n    p2.xy += vec2(\n    0.12 * cos(angle(p2.xy) * 4.),\n    0.12 * sin(angle(p2.xy) * 4.));\n\n    p2.xy += vec2(\n    0.09 * cos(angle(p2.xy) * 6. - iTime * 1.),\n    0.09 * sin(angle(p2.xy) * 6. - iTime * 1.));\n\n    p2.xy += vec2(\n    0.05 * cos(angle(p2.xy) * 13. + iTime * 1.),\n    0.05 * sin(angle(p2.xy) * 13. + iTime * 1.));\n\n    float torus2 = sdTorus(p2, vec2(2.1, .0375));\n    \n    \n    vec3 p3 = p;\n    p3.xy += vec2(\n    0.11 * cos(angle(p3.xy) * 7.),\n    0.11 * sin(angle(p3.xy) * 7.));\n\n    p3.xy += vec2(\n    0.07 * cos(angle(p3.xy) * 15. - iTime * 1.),\n    0.07 * sin(angle(p3.xy) * 15. - iTime * 1.));\n\n    p3.xy += vec2(\n    0.085 * cos(angle(p3.xy) * 2. + iTime * 1.),\n    0.085 * sin(angle(p3.xy) * 2. + iTime * 1.));\n\n    float torus3 = sdTorus(p3, vec2(2.1, .025));\n\n    return smin(smin(torus, torus2, 0.1), torus3, 0.1);\n    return min(min(torus, torus2), torus3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);                     // ray origin\n    vec3 rd = normalize(vec3(uv, 1));             // ray direction\n    \n    float t = 0.;                                 // total distance travelled\n    \n    // Vertical camera rotation\n    //ro.yz *= rot2D(-PI/2.);\n    // Horizontal camera rotation\n    //ro.xz *= rot2D(0.);\n    \n    // Raymarching\n    vec3 p;\n    float i;\n    for (i = 0.; i < 80.; i++) {\n        p = ro + rd * t;                     // position along the ray\n\n        float d = map(p);                         // current distance to the scene\n\n        t += d;                                   // \"march\" the ray\n        \n        //col = vec3(i) / 80.;                    // iteration count\n        \n        if (d < .001 || t > 100.) break;          // early stop\n    }\n    \n    // Coloring\n    float mask = max(0., sign(1. - t / 100.));\n    float shadow = min(1., mask * abs(p.z) / 0.05);\n    float col = mask - pow(shadow * 0.9, 3.) * 0.45;\n    \n    float glow = i / (80. * 2.); // add glow\n    glow = glow * 1.5;\n    \n    float sizeCircle = 4.\n        + sin(iTime * 3.5) * 0.25\n        + sin(iTime * 12.8) * 0.11\n        + sin(iTime * 30.7) * 0.05\n        + sin(iTime * 10.2) * 0.07;\n    float circle = sign(1. - length(uv) * sizeCircle);\n    float circleShadow = 1. - max(0., (1. - length(uv) * sizeCircle));\n    circle = max(0., circle - pow(circleShadow, 10.) * 0.5);\n    \n    fragColor = vec4(col + circle, glow + circle, 0., 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 applyDirectionalBlur(vec2 uv, vec2 direction, vec2 texel)\n{\n    vec4 color = texture(iChannel0, uv) * BLUR_WEIGHTS[0];\n    \n    for (int i = 0; i < 5; i++)\n    { \n        vec2 offset = texel * direction * BLUR_OFFSETS[i];\n        color += texture(iChannel0, uv + offset) * BLUR_WEIGHTS[i];\n        color += texture(iChannel0, uv - offset) * BLUR_WEIGHTS[i];\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = vec2(1.0) / iResolution.xy;\n    vec4 color = applyDirectionalBlur(uv, BLUR_DIRECTION_H, texel);\n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"}]}