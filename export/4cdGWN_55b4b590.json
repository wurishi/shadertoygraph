{"ver":"0.1","info":{"id":"4cdGWN","date":"1711714912","viewed":94,"name":"forest second attempt","username":"0x177","description":"forest second attempt","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"McdGDH","parentname":"fractal tree"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 230.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define li lightPos.xz * Rot(iTime*0.1)\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 1.0; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 64.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 1.0, -0.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(sin(p.x)*324153.0+sin(p.y)*32123.0);\n}\n\nfloat noise(vec2 p) {\n    return sin(p.x)+sin(p.y);\n}\n\nfloat noise_smooth(vec2 n)\n{\n    vec2 fn = floor(n);\n    vec2 sn = smoothstep(vec2(0),vec2(1),fract(n));\n    \n    float h1 = mix(hash(fn),hash(fn+vec2(1,0)),sn.x);\n    float h2 = mix(hash(fn+vec2(0,1)),hash(fn+vec2(1)),sn.x);\n    return mix(h1,h2,sn.y);\n}\n\nfloat fbm(vec2 p) {\n    float h = 0.0;\n    float a = 0.3;\n    float f = 2.5;\n    \n    for (float i = 0.0; i<3.0; i++) {\n        h += a * noise(p);\n        a *= 0.5;\n        p = p*f*Rot(3.1415/4.0)-h*0.4;\n    }\n    \n    return h;\n}\n\nfloat cap( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec2 tree(vec3 q,float l,float angle) {\n    float d = 999.0;\n    float m = 3.0;\n    vec3 p = q;\n    float len = l;\n    \n    // improved performance a little\n    mat2 r = Rot(angle); \n    \n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    \n    int i = 0;\n    \n    while (i<16) {\n        float b = cap(p,vec3(0.0),vec3(0.0,len,0.0),0.1);\n        d = min(d,b);\n        m = (d==b && i == 15) ? 1.0 : m;\n        \n        p.y -= len;\n        p.xy *= r;\n        p.xz *= r;\n        // i did this out of desperation and thank god i did\n        p.x = abs(p.x);\n        \n        len *= 0.67;\n        \n        i += 1;\n    }\n    \n    return vec2(d,m);\n}\n\nvec2 GetDist(vec3 p) {    \n    p.y += 3.0;\n    \n    vec2 d = vec2(999.0,0.0);\n    \n    float plane = p.y;\n    \n    float displ = fbm(p.xz*0.2)*4.0;\n    \n    plane -= displ;\n    \n    d.x = min(d.x,plane);\n    \n    float n = noise_smooth(p.xz);\n    \n    if (n>0.6) {\n        d -= 0.5;\n        d = vec2(d.x-0.3,2.0);\n    }\n    \n    p.y -= displ;\n    \n    vec3 q = vec3(mod(abs(p.x),16.0)-8.0,\n                  p.y,\n                  mod(abs(p.z),16.0)-8.0);\n                  \n    vec2 id = vec2(floor(abs(p.x)/16.0),\n                   floor(abs(p.z)/16.0));\n    \n    vec3 ap = vec3(noise_smooth(id-4.5)*9.0);\n    \n    ap.y = 0.0;\n    \n    vec2 tr = tree(q+ap,3.0,3.14159/4.0+(hash(id*10.0)*0.9)); \n    tr.x *= 0.5;\n    \n    d.x = min(d.x,tr.x);\n    \n    d.y = (d.x==tr.x) ? tr.y : d.y;\n    \n    return d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n  vec3 blinn_phong(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n\n    return ambientFactor + diffuseFactor + specularFactor;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 sky(vec3 p, vec3 rd,vec3 l) {\n    vec3 col = vec3(0.0);\n    float sun = 0.01 / (1.0-dot(rd,normalize(l)));\n    // lmao\n    col = mix(vec3(0.529,0.808,0.922),vec3(0.529,0.808,0.922),2.0 * noise_smooth(vec2(length(1.4*rd.xz),rd.y)));\n    \n    col += sun * 0.1;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 l = lightPos;\n    l.xz = li;\n    l.y *= 0.1;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3)*10.0;\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.5);\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n    \n    vec3 p = ro + rd * d;\n    vec3 bg = sky(p,rd,l);\n    vec3 col = bg;\n\n    if(d<MAX_DIST) {\n        vec3 n = GetNormal(p);\n        // plane\n        if (rm.y == 0.0) {\n            col = vec3(0.42,0.286,0.169) * 0.5 * texture(iChannel1,p.xz*1.2).xyz;\n        } else if (rm.y == 1.0) { //leaves\n            col = vec3(0.5,1.0,0.4);\n        } else if (rm.y == 2.0) { //grass\n            col = vec3(0.0,0.286,0.169) * hash(p.xz);\n        } else if (rm.y == 3.0) { // branch\n            col = vec3(0.42,0.286,0.169) * texture(iChannel2,p.xy*1.2).xyz;\n        }\n        col *= blinn_phong(p,l,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro);\n        col *= ambientOcclusion(p+n*0.1,n);\n        col *= softshadow(p,l,0.1,50.);\n        col = mix(col,bg,1.0 - exp(-0.00004*d*d));\n        //col *= 1.3;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}