{"ver":"0.1","info":{"id":"sdd3DM","date":"1629988716","viewed":123,"name":"Ordered dither with TPDF offsets","username":"mystran","description":"Here we try using 2x2 ordered dither to get 4x \"fake quantization levels\" and then dither those levels with TPDF to even out the expected value. Idea is that the ordered part puts the bulk of the noise at high frequencies without having to filter.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["dithertest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float levels = 4.; // number of quantisation levels, must be at least 2\n\nuint hash(uint x)\n{\n    x ^= x >> 16; x *= 0x7feb352du; \n    x ^= x >> 15; x *= 0x846ca68bu; \n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash2tf(uint x, uint y)\n{\n    // take a hash, split it into components\n    uint h = hash(uint(x)+(uint(y)<<16));\n    \n    return float((h>>16)+(h&0xffffu)) / float(0xffffu);\n}\n\nvec3 dither(vec3 c, uvec2 xy)\n{\n    uint t = uint(iFrame);\n    // compute noise\n    float h = hash2tf(xy.x + t*12345u, xy.y) - 1.;\n    \n    // shift the rows of the ordered dither every other frame\n    // this gives a more even checkerboard pattern over time\n    h += float( ((xy.x^xy.y)&1u)*2u + ((t^xy.y)&1u)) - 1.75;\n    \n    // normalizing to 1 step allows some banding in the ordered dither\n    // dividing by 2 instead should mostly avoid this at the cost of more noise\n    h *= 1./4.;\n    \n    float g = levels-1.;\n    return clamp(round(c*g + h) / g, 0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c = texture(iChannel0,uv.xy).xyz;\n    \n    if(abs(iMouse.x - fragCoord.x) < iResolution.x*.25) \n    {\n        c = dither(c, uvec2(fragCoord.xy));\n    }\n\telse if(iMouse.y < .5*iResolution.y) c = round(c*(levels-1.)) / (levels-1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}