{"ver":"0.1","info":{"id":"msXyz8","date":"1719333752","viewed":29,"name":"ClusteringColor by CIEDE2000","username":"shiyuugo","description":"CIEDE2000\n\nhttps://github.com/yuki-koyama/color-util/blob/master/include/color-util/CIEDE2000.hpp\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["clustering","ciede2000"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int ind = 15;\nvec3 colors[ind] = vec3[](\n    vec3( 0.0, 0.0, 0.0), \n    vec3( 1.0, 0.0, 0.0 ),    \n    vec3( 1.0, 1.0, 0.0 ),\n    vec3( 1.0, 0.0, 1.0 ),\n    vec3( 0.0, 1.0, 0.0 ),    \n    vec3( 0.0, 1.0, 1.0 ),\n    vec3( 0.0, 0.0, 1.0 ),    \n    vec3( 1.0, 0.85, 0.6 ),    \n    vec3( 0.9, 0.55, 0.6 ),    \n    vec3( 0.5, 0.5, 0.35 ),    \n    vec3( 1.0, 0.85, 0.6 ),    \n    vec3( 0.8, 0.6, 0.5 ),  \n    vec3( 0.1, 0.7, 0.5 ), \n    vec3( 1.0, 0.9, 0.9 ),\n    vec3( 1.0, 1.0, 1.0 )\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n\n    vec3 res = col;\n    float nearest = 9999.0;\n    for (int i = 0; i < ind; i++) {\n    \n    \n        float dist = compare(colors[i], col);\n        \n        if (dist < nearest) {\n            nearest = dist;\n            res = colors[i];\n        }\n    }\n\n    if(iMouse.z>0.0) res =col;\n    col = uv.x < 0.03 ? colors[int(uv.y * float(ind))] : res;\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// CIEDE2000 \n// reference: \n// https://github.com/yuki-koyama/color-util/blob/master/include/color-util/CIEDE2000.hpp\n\nconst float epsilon = 0.00001;\n\nfloat my_sin(float x) { return sin(radians(x)); }\nfloat my_cos(float x) { return cos(radians(x)); }\nfloat my_atan(float y, float x) {\n    float v = degrees(atan(y, x));\n    return (v < 0.0) ? v + 360.0 : v;\n}\n\nfloat get_h(float a, float b) {\n    bool a_and_b_are_zeros = (abs(a) < epsilon)&&(abs(b) < epsilon);\n    return a_and_b_are_zeros ? 0.0 : my_atan(b, a);\n}\n\nfloat get_delta_h(float C1, float C2, float h1, float h2) {\n    float diff = h2 - h1;\n    return (C1 * C2 < epsilon) ? 0.0 :\n    (abs(diff) <= 180.0) ? diff :\n    (diff > 180.0) ? diff - 360.0 :\n    diff + 360.0;\n}\n\nfloat get_h_bar(float C1, float C2, float h1, float h2) {\n    float dist = abs(h1 - h2);\n    float sum = h1 + h2;\n    return (C1 * C2 < epsilon) ? h1 + h2 :\n    (dist <= 180.0) ? 0.5 * sum :\n    (sum < 360.0) ? 0.5 * (sum + 360.0) :\n    0.5 * (sum - 360.0);\n    \n}\n\nfloat calculate_CIEDE2000(vec3 Lab1, vec3 Lab2) {\n    float L1 = Lab1.x;\n    float a1 = Lab1.y;\n    float b1 = Lab1.z;\n    float L2 = Lab2.x;\n    float a2 = Lab2.y;\n    float b2 = Lab2.z;\n    \n    float C1_ab = sqrt(a1 * a1 + b1 * b1);\n    float C2_ab = sqrt(a2 * a2 + b2 * b2);\n    float C_ab_bar = 0.5 * (C1_ab + C2_ab);\n    float G = 0.5 * (1.0 - sqrt(pow(C_ab_bar, 7.0) / (pow(C_ab_bar, 7.0) + pow(25.0, 7.0))));\n    float a_1 = (1.0 + G) * a1;\n    float a_2 = (1.0 + G) * a2;\n    float C1 = sqrt(a_1 * a_1 + b1 * b1);\n    float C2 = sqrt(a_2 * a_2 + b2 * b2);\n    float h1 = get_h(a_1, b1);\n    float h2 = get_h(a_2, b2);\n    \n    float delta_L = L2 - L1;\n    float delta_C = C2 - C1;\n    float delta_h = get_delta_h(C1, C2, h1, h2);\n    float delta_H = 2.0 * sqrt(C1 * C2) * my_sin(0.5 * delta_h);\n    \n    float L_bar = 0.5 * (L1 + L2);\n    float C_bar = 0.5 * (C1 + C2);\n    float h_bar = get_h_bar(C1, C2, h1, h2);\n    \n    float T = 1.0 - 0.17 * my_cos(h_bar - 30.0) + 0.24 * my_cos(2.0 * h_bar) +\n    0.32 * my_cos(3.0 * h_bar + 6.0) - 0.20 * my_cos(4.0 * h_bar - 63.0);\n    \n    float delta_theta = 30.0 * exp(-((h_bar - 275.0) / 25.0) * ((h_bar - 275.0) / 25.0));\n    \n    float R_C = 2.0 * sqrt(pow(C_bar, 7.0) / (pow(C_bar, 7.0) + pow(25.0, 7.0)));\n    float S_L = 1.0 + (0.015 * (L_bar - 50.0) * (L_bar - 50.0)) / sqrt(20.0 + (L_bar - 50.0) * (L_bar - 50.0));\n    float S_C = 1.0 + 0.045 * C_bar;\n    float S_H = 1.0 + 0.015 * C_bar * T;\n    float R_T = -my_sin(2.0 * delta_theta) * R_C;\n    \n    const float k_L = 1.0;\n    const float k_C = 1.0;\n    const float k_H = 1.0;\n    \n    float deltaL = delta_L / (k_L * S_L);\n    float deltaC = delta_C / (k_C * S_C);\n    float deltaH = delta_H / (k_H * S_H);\n    \n    float delta_E_squared = deltaL * deltaL + deltaC * deltaC + deltaH * deltaH + R_T * deltaC * deltaH;\n    \n    return sqrt(delta_E_squared);\n}\n\n//--- RGB2Lab\nvec3 rgb2xyz(vec3 c) {\n    vec3 tmp;\n    tmp.x = (c.r > 0.04045) ? pow((c.r + 0.055) / 1.055, 2.4) : c.r / 12.92;\n    tmp.y = (c.g > 0.04045) ? pow((c.g + 0.055) / 1.055, 2.4) : c.g / 12.92;\n    tmp.z = (c.b > 0.04045) ? pow((c.b + 0.055) / 1.055, 2.4) : c.b / 12.92;\n    return 100.0 * tmp * mat3(0.4124, 0.3576, 0.1805, 0.2126, 0.7152, 0.0722, 0.0193, 0.1192, 0.9505);\n}\nvec3 xyz2lab(vec3 c) {\n    vec3 n = c / vec3(95.047, 100.0, 108.883);\n    vec3 v;\n    v.x = (n.x > 0.008856) ? pow(n.x, 1.0 / 3.0) : (7.787 * n.x) + (16.0 / 116.0);\n    v.y = (n.y > 0.008856) ? pow(n.y, 1.0 / 3.0) : (7.787 * n.y) + (16.0 / 116.0);\n    v.z = (n.z > 0.008856) ? pow(n.z, 1.0 / 3.0) : (7.787 * n.z) + (16.0 / 116.0);\n    return vec3((116.0 * v.y) - 16.0, 500.0 * (v.x - v.y), 200.0 * (v.y - v.z));\n}\n\nvec3 rgb2lab(vec3 c) {\n    vec3 lab = xyz2lab(rgb2xyz(c));\n    return vec3(lab.x / 100.0, 0.5 + 0.5 * (lab.y / 127.0), 0.5 + 0.5 * (lab.z / 127.0));\n}\n\n\nfloat compare(vec3 rgb1, vec3 rgb2) {\n    vec3 lab1 = rgb2lab(rgb1);\n    vec3 lab2 = rgb2lab(rgb2);\n    return calculate_CIEDE2000(lab1, lab2);\n}\n","name":"Common","description":"","type":"common"}]}