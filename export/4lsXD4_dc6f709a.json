{"ver":"0.1","info":{"id":"4lsXD4","date":"1436877919","viewed":203,"name":"Displacement mapping","username":"Kyroaku","description":"Simple test for displacement mapping based on diffuse texture.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["displacement","texture","bump","displacementmapping","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"precision mediump float;\n\n#define MAX_MARCH_STEPS\t\t128\n#define MAX_MARCH_DISTANCE\t0.01\n\nstruct Fragment\n{\n    float depth;\n    vec3 material;\n};\n\nstruct PointLight\n{\n    vec3 position;\n    vec3 color;\n};\n\nfloat dSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat dSphereBumped(vec3 p, float r, vec3 c)\n{\n    return length(p) - r - c.r*0.1;\n}\n\nfloat dPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat dPlaneBumped(vec3 p, vec3 c)\n{\n    return p.y - c.r * 0.1;\n}\n\nFragment minF(Fragment a, Fragment b)\n{\n    if(a.depth < b.depth) return a;\n    else return b;\n}\n\nFragment map(vec3 p)\n{\n    vec3 c = texture(iChannel0, p.xz*0.1).xyz;\n    vec3 c2 = texture(iChannel0, p.xz*1.0).xyz;\n    \n    vec3 matGround = vec3(1.0, 0.6, 0.2);\n    vec3 matBall = vec3(0.7, 0.5, 0.3);\n    \n    Fragment f;\n    f = \t\tFragment(dSphereBumped(p - vec3(0.0, 1.5, 0.0), 1.0, c2), matBall);\n    f = minF(f, Fragment(dPlaneBumped(p, c), matGround));\n    return f;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 t = vec2(0.01, 0.0);\n    return normalize(\n        vec3(\n        map(p+t.xyy).depth - map(p-t.xyy).depth,\n        map(p+t.yxy).depth - map(p-t.yxy).depth,\n        map(p+t.yyx).depth - map(p-t.yyx).depth )\n        );\n}\n\nmat3 lookAt(vec3 p, vec3 t, vec3 u)\n{\n    vec3 z = normalize(t - p);\n    vec3 x = normalize(cross(z, u));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nFragment ray(vec3 ro, vec3 rd)\n{\n    float depth = 0.0;\n    for(int i = 0; i < MAX_MARCH_STEPS; i++)\n    {\n        Fragment f = map(ro + rd * depth);\n        depth += f.depth;\n        if(f.depth < MAX_MARCH_DISTANCE)\n        {\n            f.depth = depth;\n            return f;\n        }\n    }\n    return Fragment(-1.0, vec3(0.0, 0.0, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 cp = vec3(cos(iTime)*6.0, 6.0, sin(iTime)*6.0);\n    vec3 ct = vec3(0.0, 0.0, -2.0);\n    vec3 cu = vec3(0.0, 1.0, 0.0);\n    mat3 cam = lookAt(cp, ct, cu);\n    \n    vec3 rd = cam * normalize(vec3(p, 2.5));\n    \n    Fragment f = ray(cp, rd);\n    vec3 pos = cp + rd*f.depth;\n    \n    vec3 n = normal(pos);\n    float diffuse = dot(n, normalize(vec3(0.0, 2.0, 1.0)));\n    \n    vec3 color = f.material * diffuse;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}