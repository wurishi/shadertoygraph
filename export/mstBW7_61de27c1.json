{"ver":"0.1","info":{"id":"mstBW7","date":"1697264325","viewed":83,"name":"Bresenham circle","username":"dimitr","description":"Line is drawn with DDA usage, circle - with Bresenham algorithm","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pixel","dda","bresenham"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // output\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec4 CANVAS_COLOR = vec4(0.4f, 0.4f, 0.4f, 1.0f);\nconst vec2 CELL_SIZE = vec2(5.0f, 5.0f);\n\nconst vec4 GAP_COLOR = vec4(0.0f, 0.0f, 0.0f, 1.0f);\nconst vec2 GAP_SIZE = vec2(1.0f, 1.0f);\n\nconst vec4 DRAW_COLOR = vec4(0.0f, 0.8f, 0.2f, 1.0f);\n\nconst vec2 ENLARGED_CELL_SIZE = CELL_SIZE + GAP_SIZE;\n\nfloat vecEqual(vec2 v0, vec2 v1)\n{\n    vec2 v = v1 - v0;\n    float vDist = dot(v, v);\n    return float(vDist < 0.01f);\n}\n\nvec4 getCell( vec2 pixelFragCoord )\n{\n    vec2 fullCell = CELL_SIZE + GAP_SIZE;\n    vec2 cellIdx = floor(pixelFragCoord / fullCell);\n    vec4 cellBounds = vec4(0.0f, 0.0f, 1.0f, 1.0f); // just spaceholder\n    cellBounds.x = cellIdx.x * fullCell.x;\n    cellBounds.y = cellIdx.y * fullCell.y;\n    cellBounds.z = cellBounds.x + fullCell.x;\n    cellBounds.w = cellBounds.y + fullCell.y;\n    return cellBounds;\n}\n\nfloat isCellPixel( vec2 pixelFragCoord )\n{\n    vec4 cell = getCell(pixelFragCoord);\n    float insideCell = float(!(pixelFragCoord.x >= cell.z - GAP_SIZE.x || pixelFragCoord.y >= cell.w - GAP_SIZE.y));\n    return insideCell;\n}\n\nfloat isUnderMouse( vec2 pixelFragCoord, vec2 mousePixelCoord )\n{\n    vec4 pixelCell = getCell(pixelFragCoord);\n    vec4 mouseCell = getCell(mousePixelCoord);\n    return vecEqual(pixelCell.xy, mouseCell.xy) * isCellPixel(pixelFragCoord);\n}\n\nvec4 getCanvasColor( vec2 pixelFragCoord ) \n{\n    float insideCell = isCellPixel(pixelFragCoord);\n    return CANVAS_COLOR * insideCell + GAP_COLOR * (1.0f - insideCell);\n}\n\nvec4 getDrawnColor ( vec2 pixelFragCoord, vec2 mousePixelCoord )\n{\n    float insideCell = isCellPixel(pixelFragCoord);\n    float underMouse = isUnderMouse(pixelFragCoord, mousePixelCoord);\n    vec4 drawnColor = insideCell * (underMouse * DRAW_COLOR + (1.0f - underMouse) * CANVAS_COLOR) + (1.0f - insideCell) * GAP_COLOR;\n    return drawnColor;\n}\n\nfloat isLinePixel (vec2 pixelFragCoord, vec2 startCell, vec2 stopCell)\n{\n    // DDA\n    vec4 pixelCell = getCell(pixelFragCoord);\n    vec2 cellCenter = pixelCell.xy + CELL_SIZE * 0.5f;\n    vec2 v = (stopCell - startCell) / (CELL_SIZE + GAP_SIZE);\n    vec2 startCenter = startCell + CELL_SIZE * 0.5f;\n    vec2 stopCenter = stopCell + CELL_SIZE * 0.5f;\n    float insideLine = 0.0f;\n    vec2 enlargedStep = CELL_SIZE + GAP_SIZE;\n\n    if (abs(v.x) < 0.001f && abs(v.y) < 0.001f)\n    {\n        // just point\n        return vecEqual(pixelCell.xy, startCell);\n    }\n    if (abs(v.x) > abs(v.y))\n    {\n        // use tanQ\n        float tanQ = v.y / v.x;\n        float steps = floor(abs(v.x));\n        float stepSign = v.x / abs(v.x);\n        for (float i = 0.0f; i < steps + 0.001f; i += 1.0f)\n        {\n            float curX = i * enlargedStep.x * stepSign - GAP_SIZE.x * stepSign;\n            float curY = curX * tanQ;\n            vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n            vec4 curCell = getCell(curCoord);\n            insideLine += vecEqual(curCell.xy, pixelCell.xy);\n        }\n    }\n    else {\n        // use cotanQ\n        float cotanQ = v.x / v.y;\n        float steps = floor(abs(v.y));\n        float stepSign = v.y / abs(v.y);\n        for (float i = 0.0f; i < steps + 0.001f; i += 1.0f)\n        {\n            float curY = i * enlargedStep.y * stepSign - GAP_SIZE.y * stepSign;\n            float curX = curY * cotanQ;\n            vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n            vec4 curCell = getCell(curCoord);\n            insideLine += vecEqual(curCell.xy, pixelCell.xy);\n        }\n    }\n    return insideLine;\n}\n\nfloat inSymmetricCirclePixels(vec2 pixelFragCoord, vec2 circleCenter, int x, int y)\n{\n    float insideCircle = 0.0f;\n    vec4 pixelCell = getCell(pixelFragCoord);\n    // Q1\n    vec2 p0 = circleCenter + vec2(float(x), float(y)) * ENLARGED_CELL_SIZE;\n    vec2 p1 = circleCenter + vec2(float(y), float(x)) * ENLARGED_CELL_SIZE;\n    vec4 cell0 = getCell(p0);\n    vec4 cell1 = getCell(p1);\n    insideCircle += vecEqual(cell0.xy, pixelCell.xy) + vecEqual(cell1.xy, pixelCell.xy);\n    // Q2\n    vec2 p2 = circleCenter + vec2(float(-x), float(y)) * ENLARGED_CELL_SIZE;\n    vec2 p3 = circleCenter + vec2(float(y), float(-x)) * ENLARGED_CELL_SIZE;\n    vec4 cell2 = getCell(p2);\n    vec4 cell3 = getCell(p3);\n    insideCircle += vecEqual(cell2.xy, pixelCell.xy) + vecEqual(cell3.xy, pixelCell.xy);\n    // Q3\n    vec2 p4 = circleCenter + vec2(float(-x), float(-y)) * ENLARGED_CELL_SIZE;\n    vec2 p5 = circleCenter + vec2(float(-y), float(-x)) * ENLARGED_CELL_SIZE;\n    vec4 cell4 = getCell(p4);\n    vec4 cell5 = getCell(p5);\n    insideCircle += vecEqual(cell4.xy, pixelCell.xy) + vecEqual(cell5.xy, pixelCell.xy);\n    // Q4\n    vec2 p6 = circleCenter + vec2(float(x), float(-y)) * ENLARGED_CELL_SIZE;\n    vec2 p7 = circleCenter + vec2(float(-y), float(x)) * ENLARGED_CELL_SIZE;\n    vec4 cell6 = getCell(p6);\n    vec4 cell7 = getCell(p7);\n    insideCircle += vecEqual(cell6.xy, pixelCell.xy) + vecEqual(cell7.xy, pixelCell.xy);\n    // this function may check the same cell twice in 45 degrees and 90 degrees cases, \n    // so the answer is 2.0f, but we need to return\n    // 1.0f or 0.0f in that case too\n    return float(insideCircle > 0.001f);\n}\n\nfloat isCirclePixel(vec2 pixelFragCoord, vec2 startCell, float radius)\n{\n    vec2 circleCenter = startCell + ENLARGED_CELL_SIZE * 0.5f;\n    float onCircle = 0.0f;\n    radius = floor(radius / ENLARGED_CELL_SIZE.x); // now radius is in cell sizes\n    // Bresenham algorithm\n    int r = int(radius);\n    int x = 0;\n    int y = r;\n    int p = 3 - 2 * r;\n    while (x <= y) // only Q1 is calculated\n    {\n        onCircle += inSymmetricCirclePixels(pixelFragCoord, circleCenter, x, y); // current point\n        x = x + 1;\n        int pSign = int(p >= 0);\n        y = pSign * (y - 1) + (1 - pSign) * y;\n        p = pSign * (p + 4 * (x - y) + 10) + (1 - pSign) * (p + 4 * x + 6);\n    }\n    return onCircle;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lineColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n    vec4 mouseColor = vec4(0.0f, 0.8f, 0.2f, 1.0f);\n    vec4 circleColor = vec4(0.3f, 0.0f, 0.7f, 1.0f);\n    \n    float radius = 200.0f;\n\n    float curAngle = iTime;\n    \n    vec4 pixelCell = getCell(fragCoord);\n    vec4 mouseCell = getCell(iMouse.xy);\n    float curTime = floor(iTime);\n    float angle = curTime / 60.0f * 3.14 * 2.0f;\n    vec2 curVec = vec2(radius * cos(-angle), radius * sin(-angle)) * 0.8f;\n    vec2 originCoord = mouseCell.xy + curVec;\n    vec4 originCell = getCell(originCoord);\n    \n    float insideCell = isCellPixel(fragCoord);\n    float insideLine = isLinePixel(fragCoord, originCell.xy, mouseCell.xy);\n    float onCircle = isCirclePixel(fragCoord, mouseCell.xy, radius);\n    float underMouse = isUnderMouse(fragCoord, iMouse.xy);\n    vec4 bgColor = insideCell * CANVAS_COLOR + (1.0f - insideCell) * GAP_COLOR;   \n    vec4 circleFilledColor = onCircle * circleColor;\n    vec4 lineFilledColor = insideLine * lineColor;\n    bgColor *= (1.0f - insideLine) * (1.0f - onCircle);\n    circleFilledColor *= (1.0f - insideLine);\n    lineFilledColor *= (1.0f - underMouse);\n    vec4 finalColor = bgColor + circleFilledColor + lineFilledColor + underMouse * mouseColor;\n    fragColor = finalColor * insideCell + (1.0f - insideCell) * GAP_COLOR;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}