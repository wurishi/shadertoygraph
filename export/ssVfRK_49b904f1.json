{"ver":"0.1","info":{"id":"ssVfRK","date":"1658831182","viewed":164,"name":"Quad shading test","username":"Xnum","description":"...","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HEIGHT_MAP iChannel0\n\nprecision highp float;\n\nconst float roughness = 0.1f;\nconst float metallness = 1.0f;\nconst vec3 lightColor = vec3(1.0, 0.7, 0.56);\nvec3 F0 = vec3(0.4f);\nconst float heightScale = 40.0f;\n\n#define LIGHT_HEIGHT 100.0f\n\n/* returns height [0-1] */\nfloat getHeight(vec2 pixPos){\n    return texture(HEIGHT_MAP, 1.0 * pixPos / iResolution.xy).r * heightScale;\n}\n\nfloat h(float u, float v){\n    return getHeight(vec2(u, v));\n}\n\nvec3 getNormal1(vec2 pixPos){\n\n    float x = pixPos.x;\n    float y = pixPos.y;\n    \n    float h_x = (h(x + 1.0f, y) - h(x - 1.0f, y)) * 0.5f;\n    float h_y = (h(x, y + 1.0f) - h(x, y - 1.0f)) * 0.5f;\n    \n    vec3 n = vec3(-h_x, -h_y, 1.0); \n    \n    return normalize(n);\n  \n}\n\nvec3 getNormal2(vec2 pixPos){\n\n    float x = pixPos.x;\n    float y = pixPos.y;\n    \n    vec2 right = vec2(min(iResolution.x, x + 1.0), y);\n    vec2 up    = vec2(x, min(iResolution.y, y + 1.0));\n    vec2 left  = vec2(max(0.5,x - 1.0), y);\n    vec2 down  = vec2(x, max(0.5, y - 1.0));\n    \n    vec3 me = vec3(x, y, getHeight(vec2(x,y)));\n    \n    \n    vec3 p1 = vec3(right, getHeight(right)) - me;\n    vec3 p2 = vec3(up, getHeight(up)) - me;\n    \n    vec3 n1 = normalize(cross(p1, p2));\n    \n    p1 = vec3(left, getHeight(left)) - me;\n    \n    vec3 n2 = cross(p2, p1);\n    \n    p2 = vec3(down, getHeight(down)) - me;\n    \n    vec3 n3 = cross(p1, p2);\n    \n    p1 = vec3(right, getHeight(right)) - me;\n    \n    vec3 n4 = cross(p2, p1);\n    \n    return normalize( (n1 + n2 + n3 + n4) / 4.0); \n}\n\n/* this is wrong */\nvec3 getNormal3(vec2 pixPos){\n      \n    float height = getHeight(pixPos);\n    float upHeight = getHeight(pixPos + vec2(0,-1));\n\tfloat rightHeight = getHeight(pixPos + vec2(1,0));\n    \n    return normalize(vec3(height - upHeight, height - rightHeight, 1.0)); \n}\n\nvec3 getNormal4(vec2 pixPos){\n\n    float x = pixPos.x;\n    float y = pixPos.y;\n    // sample the height map:\n    float fx0 = h(x-1.0,y), fx1 = h(x+1.0,y);\n    float fy0 = h(x,y-1.0), fy1 = h(x,y+1.0);\n\n    // the spacing of the grid in same units as the height map\n    float eps = 1.0f ;\n\n    // plug into the formulae above:\n    vec3 n = normalize(vec3((fx0 - fx1)/(2.0*eps), (fy0 - fy1)/(2.0*eps), 1.0));\n    return n;\n}\n\nvec3 getNormal(vec2 pixPos){\n    //return getNormal1(pixPos);\n    return getNormal2(pixPos);\n    //return getNormal3(pixPos);\n    //return getNormal4(pixPos);\n}  \n\n\n//#define DEBUG_NORMAL\n#define DEBUG_DIFFUSE\n//#define DEBUG_SPECULAR\n\n//#define USE_NORMAL\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 col = vec4(1.0);\n    \n    /* pixel position [0.5, iResolution.x + 0.5] */\n    vec2 pixelPos = fragCoord;\n    vec4 mousePos = iMouse;\n    \n    vec3 lightPosition = vec3(iMouse.xy, 100);\n    vec3 position = vec3(pixelPos.xy, 0.0f);\n\n\n     vec3 viewPos = vec3(\n        (iResolution.x - mod(iResolution.x, 10.0f)) * 0.5f,\n        (iResolution.y - mod(iResolution.y, 10.0f)) * 0.5f,\n         1.0f);\n         \n#ifdef USE_NORMAL\n    vec3 N = getNormal(pixelPos);\n#else\n    vec3 N = vec3(0.0, 0.0, 1.0);\n#endif\n\n    vec3 L = normalize(lightPosition - position);\n    float D = length(lightPosition - position);\n    vec3 V = normalize(viewPos - position);\n    vec3 R = reflect(-L, N);\n    float attenuation = 1.0f / (D * D);\n    \n    float height = getHeight(pixelPos);\n    \n    vec4 ambient = 0.4 * vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 diffuse = vec4(lightColor * max(dot(N, L), 0.0), 1.0);\n    \n    vec4 specular = vec4(vec3(1.0f, 1.0f, 1.0f) * 1.0 * pow(max(dot(V, R), 0.0), 32.0f), 1.0f);\n    \n    vec4 objColor = vec4(getHeight(pixelPos)) / heightScale;\n    \n    col = objColor * (ambient + diffuse + specular);\n    \n    fragColor = col;\n    \n    #ifdef DEBUG_NORMAL\n    fragColor = vec4(N, 1.0);\n    #endif\n    \n    #ifdef DEBUG_DIFFUSE\n    fragColor = vec4(pow(max(attenuation, 0.0f) * 1000.0, 0.4545));\n    #endif\n    \n    #ifdef DEBUG_SPECULAR\n    fragColor = specular;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define INV_SQRT_PI 0.56418958354\n\nfloat saturate(float value){\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat DistributionGGXTR(vec3 normal, vec3 halfVector, float roughnessCoefficient)\n{\n\tvec3 n = normal;\n\tvec3 h = halfVector;\n\tfloat alpha = roughnessCoefficient;\n\t\n\tfloat squaredAlpha = alpha * alpha;\n\tfloat NdotH = max(dot(n, h), 0.0f);\n\tfloat squaredNdotH = NdotH * NdotH;\n\t\n\tfloat nom = pow(roughnessCoefficient, 2.0f);\n\tfloat denom = PI * pow(pow(dot(normal, halfVector), 2.0f) * (pow(squaredAlpha, 2.0f) - 1.0f) + 1.0f, 2.0f);\n\t\n\treturn nom / denom;\n\n}\n\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n\tfloat nom = NdotV;\n\tfloat denom = NdotV * (1.0 - k) + k;\n\t\n\treturn nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n\tfloat NdotV = max(dot(N, V), 0.0);\n\tfloat NdotL = max(dot(N, L), 0.0);\n\tfloat ggx1 = GeometrySchlickGGX(NdotV, k);\n\tfloat ggx2 = GeometrySchlickGGX(NdotL, k);\n\t\n\treturn ggx1 * ggx2;\n}\n\nvec3 FresnelSchlick(float cosTheta, vec3 F0)\n{\n\treturn F0 + (1.0f - F0) * (1.0f - pow(cosTheta, 5.0f));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}  \n\n\n","name":"Common","description":"","type":"common"}]}