{"ver":"0.1","info":{"id":"lfySDD","date":"1715178433","viewed":13,"name":"TestLineCap","username":"rkgekk","description":"Basic line cap","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circle","cap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\nvec4 bg_color = vec4(1.0, 1.0, 1.0, 1.0);\nfloat screen_wide = 2.0;\n\nstruct UniformsLine {\n    mat4 modelViewProjection;\n    vec4 color;\n    vec2 dash;\n    float width;\n};\n\nstruct LineDashVertex {\n    vec3 position;\n    vec3 normal;\n    vec4 color;\n    float len;\n};\n\nstruct LineDashFragment {\n    vec4 position;\n    vec4 color;\n    vec2 halfWidth;\n    vec3 len;\n};\n\nstruct CapJoinVertex {\n    vec3 position;\n    vec3 normal;\n    vec4 color;\n    vec2 direction;\n};\n\nstruct CapJoinFragment {\n    vec4 position;\n    vec4 color;\n    vec3 radius;\n    float direction;\n};\n\nCapJoinFragment vertexCapJoin(CapJoinVertex v, UniformsLine ubo) {\n    CapJoinFragment result;\n\n    vec3 norm = ubo.width * v.normal;\n    result.position = ubo.modelViewProjection * vec4(v.position.xyz + vec3(norm.xy, 0.0), 1.0);\n    //result.position = vec4(v.normal.xyz, 1.0);\n\n    result.radius = norm;\n    result.color = v.color * ubo.color;\n    result.direction = dot(v.direction, v.normal.xy);\n    return result;\n}\n\nvec4 fragCapJoin(CapJoinFragment f) {\n    float resolution_y = iResolution.y;\n    float kOnePixel = screen_wide / resolution_y;\n    //float kAntialiasingPixelsCount = 1.5;\n    float kAntialiasingPixelsCount = kOnePixel * 1.5;\n\n    float smallRadius = f.radius.z - kAntialiasingPixelsCount;\n    float stepValue = 1.0 - smoothstep(\n        smallRadius * smallRadius,\n        f.radius.z * f.radius.z,\n        f.radius.x * f.radius.x + f.radius.y * f.radius.y\n    );\n    vec4 color = f.color;\n    return color * stepValue * step(0.0, f.direction);\n}\n\nLineDashFragment vertexDashedLine(LineDashVertex v, UniformsLine ubo) {\n    LineDashFragment result;\n\n    vec2 normal = v.normal.xy;\n    float halfWidth = ubo.width;\n    float forInterpolateDiff = v.normal.z * halfWidth;\n    result.halfWidth = vec2(forInterpolateDiff, halfWidth);\n    vec4 lineWidthOffset = vec4(v.position.xyz + vec3(normal, 0.0) * ubo.width, 1.0);\n    result.position = ubo.modelViewProjection * lineWidthOffset;\n\n    result.color = v.color * ubo.color;\n    //result.color = v.color;\n    result.len = vec3(v.len, ubo.dash);\n    return result;\n}\n\nvec4 fragDashedLine(LineDashFragment f) {\n    float resolution_y = iResolution.y;\n    float kOnePixel = screen_wide / resolution_y;\n    //float kAntialiasingPixelsCount = 1.5;\n    float kAntialiasingPixelsCount = kOnePixel * 1.5;\n\n    float currentW = abs(f.halfWidth.x);\n    float diff = f.halfWidth.y - currentW;\n    float alpha = mix(0.0, 1.0, clamp(diff / kAntialiasingPixelsCount, 0.0, 1.0));\n\n    float partLength = f.len.y + f.len.z;\n    float dashLineColor = 1.0 - step(f.len.y, mod(f.len.x, partLength));\n\n    vec4 color = f.color * alpha * dashLineColor;\n    //vec4 color = vec4(f.color.xyz, f.color.a * alpha * dashLineColor);\n\n    return color;\n}\n\nstruct LineType {\n    vec2 p0;\n    vec2 p1;\n    vec2 tangent;\n    vec2 normal;\n    float half_width;\n    float dash;\n    float gap;\n    vec4 color;\n};\n\nstruct CapType {\n    vec2 center;\n    vec2 direction;\n    vec4 color;\n};\n\nstruct RectType {\n    vec2 start;\n    vec2 end;\n    float width;\n};\n\nUniformsLine make_line_ubo(mat4 mvp, LineType line) {\n    UniformsLine ubo;\n    ubo.modelViewProjection = mvp;\n    ubo.color = line.color;\n    ubo.dash = vec2(line.dash, line.gap);\n    ubo.width = line.half_width;\n    return ubo;\n}\n\nLineType make_line(RectType rect, float dash, float gap, vec4 color) {\n    LineType line;\n    line.half_width = rect.width * 0.5;\n    //line.half_width = rect.width;\n    line.tangent = normalize(rect.end - rect.start);\n    line.normal = vec2(-line.tangent.y, line.tangent.x);\n    line.p0 = rect.start;\n    line.p1 = rect.end;\n    line.dash = dash;\n    line.gap = gap;\n    line.color = color;\n    \n    return line;\n}\n\nstruct LineVertexBuffer {\n    LineDashVertex v0;\n    LineDashVertex v1;\n    LineDashVertex v2;\n    LineDashVertex v3;\n};\n\nmat4 make_id() {\n    return mat4 (\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nLineVertexBuffer make_line_vb(LineType line) {\n    LineVertexBuffer vb;\n    \n    float line_len = length(line.p1 - line.p0);\n\n    vb.v0.position = vec3(line.p0, 0.0);\n    vb.v0.normal = vec3(line.normal, -1.0);\n    //vb.v0.color = vec4(1.0, 0.0, 0.0, 1.0);\n    vb.v0.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v0.len = 0.0;    \n\n    vb.v1.position = vec3(line.p0, 0.0);\n    vb.v1.normal = vec3(-line.normal, 1.0);\n    //vb.v1.color = vec4(0.0, 1.0, 0.0, 1.0);\n    vb.v1.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v1.len = 0.0;\n\n    vb.v2.position = vec3(line.p1, 0.0);\n    vb.v2.normal = vec3(line.normal, -1.0);\n    //vb.v2.color = vec4(0.0, 0.0, 1.0, 1.0);\n    vb.v2.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v2.len = line_len;    \n\n    vb.v3.position = vec3(line.p1, 0.0);\n    vb.v3.normal = vec3(-line.normal, 1.0);\n    vb.v3.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v3.len = line_len;    \n\n    return vb;\n}\n\nstruct CapVertexBuffer {\n    CapJoinVertex v0;\n    CapJoinVertex v1;\n    CapJoinVertex v2;\n};\n\nCapVertexBuffer make_cap_vb(vec2 pos, vec2 dir) {\n    float kSqrt3 = sqrt(3.0);\n    float radius = 1.0;\n    \n    CapVertexBuffer vb;\n    vb.v0.position = vec3(pos, 0.0);\n    vb.v0.normal = vec3(-radius * kSqrt3, -radius, radius);\n    vb.v0.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v0.direction = dir;\n    \n    vb.v1.position = vec3(pos, 0.0);\n    vb.v1.normal = vec3(radius * kSqrt3, -radius, radius);\n    vb.v1.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v1.direction = dir;\n    \n    vb.v2.position = vec3(pos, 0.0);\n    vb.v2.normal = vec3(0.0, 2.0*radius, radius);\n    vb.v2.color = vec4(1.0, 1.0, 1.0, 1.0);\n    vb.v2.direction = dir;\n    \n    return vb;\n}\n\nmat3 rot_matrix(vec3 R, float a) {\n    float c = cos(a); float s = sin(a);\n    float x = R.x; float y = R.y; float z = R.z;\n    return mat3(\n        c + (1.0 - c)*x*x  , (1.0 - c)*x*y + s*z, (1.0 - c)*x*z - s*y,\n        (1.0 - c)*x*y - s*z, c + (1.0 - c)*y*y  , (1.0 - c)*y*z + s*x,\n        (1.0 - c)*x*z - s*y, (1.0 - c)*y*z - s*x, c + (1.0 - c)*z*z\n    );\n}\n\nvec2 rotate(vec2 p, vec2 z, float a) {\n    mat3 rot_mat = rot_matrix(vec3(0.0, 0.0, 1.0), a);\n    return (vec3((p - z), 0.0)*rot_mat).xy + z;\n}\n\nvec3 make_barycentric(vec4 V0, vec4 V1, vec4 V2, vec4 P) {\n    vec4 A1 = V1 - V0;\n    vec4 B1 = P - V0;\n    vec4 A2 = V2 - V1;\n    vec4 B2 = P - V1;\n    vec4 A3 = V0 - V2;\n    vec4 B3 = P - V2;\n    float inv_area = 1.0 / determinant(mat2(A1.xy, A2.xy));\n    float w1 = determinant(mat2(A1.xy, B1.xy))*inv_area;\n    float w2 = determinant(mat2(A2.xy, B2.xy))*inv_area;\n    float w3 = determinant(mat2(A3.xy, B3.xy))*inv_area;\n    return vec3(w1, w2, w3);\n}\n\n//https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 resolution = iResolution.xy;\n    float aspect = resolution.x/resolution.y;\n    vec2 uv = (screen_wide*fragCoord - resolution)/resolution.y;\n    \n    float kOnePixel = screen_wide / resolution.y;\n    float kHalfPixel = kOnePixel * 0.5;\n    \n    vec2 line_start = vec2(0.0, 0.0);\n    vec2 line_end = vec2(1.5, 0.0);\n    vec4 line_color = vec4(1.0, 0.0, 0.0, 1.0);\n    float line_width = kOnePixel * 100.0;\n    float line_dash = 0.5;\n    float line_gap = 0.2;\n    \n    float alpha_rad = iTime*PI;\n    \n    line_end = rotate(line_end, line_start, alpha_rad);\n    \n    vec4 result_color = bg_color;\n    \n    float line_len = length(line_end - line_start);\n    vec2 line_direction = line_end - line_start;\n    \n    RectType rect = RectType(line_start, line_end, line_width);\n    LineType line = make_line(rect, line_dash, line_gap, line_color);\n\n    UniformsLine line_ubo = make_line_ubo(make_id(), line);\n\n    LineVertexBuffer line_vb = make_line_vb(line);\n    LineDashFragment line_frag0 = vertexDashedLine(line_vb.v0, line_ubo);\n    LineDashFragment line_frag1 = vertexDashedLine(line_vb.v1, line_ubo);\n    LineDashFragment line_frag2 = vertexDashedLine(line_vb.v2, line_ubo);\n    LineDashFragment line_frag3 = vertexDashedLine(line_vb.v3, line_ubo);\n    \n    line_frag0.position = vec4(line_frag0.position.xyz / line_frag0.position.w, 1.0);\n    line_frag1.position = vec4(line_frag1.position.xyz / line_frag1.position.w, 1.0);\n    line_frag2.position = vec4(line_frag2.position.xyz / line_frag2.position.w, 1.0);\n    line_frag3.position = vec4(line_frag3.position.xyz / line_frag3.position.w, 1.0);\n    \n    vec4 P = vec4(uv.xy, 0.0, 1.0);\n    \n    vec3 t1_w = make_barycentric(line_frag0.position, line_frag1.position, line_frag2.position, P);\n    if(t1_w.x >= 0.0 && t1_w.y >= 0.0 && t1_w.z >= 0.0) {\n        \n        LineDashFragment f;\n        f.position  = line_frag0.position  * t1_w.y + line_frag1.position  * t1_w.z + line_frag2.position  * t1_w.x;\n        f.color     = line_frag0.color     * t1_w.y + line_frag1.color     * t1_w.z + line_frag2.color     * t1_w.x;\n        f.halfWidth = line_frag0.halfWidth * t1_w.y + line_frag1.halfWidth * t1_w.z + line_frag2.halfWidth * t1_w.x;\n        f.len       = line_frag0.len       * t1_w.y + line_frag1.len       * t1_w.z + line_frag2.len       * t1_w.x;\n        vec4 color = fragDashedLine(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    vec3 t2_w = make_barycentric(line_frag1.position, line_frag3.position, line_frag2.position, P);\n    if(t2_w.x >= 0.0 && t2_w.y >= 0.0 && t2_w.z >= 0.0) {\n        \n        LineDashFragment f;\n        f.position  = line_frag1.position  * t2_w.y + line_frag3.position  * t2_w.z + line_frag2.position  * t2_w.x;\n        f.color     = line_frag1.color     * t2_w.y + line_frag3.color     * t2_w.z + line_frag2.color     * t2_w.x;\n        f.halfWidth = line_frag1.halfWidth * t2_w.y + line_frag3.halfWidth * t2_w.z + line_frag2.halfWidth * t2_w.x;\n        f.len       = line_frag1.len       * t2_w.y + line_frag3.len       * t2_w.z + line_frag2.len       * t2_w.x;\n        vec4 color = fragDashedLine(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    CapVertexBuffer cap_vb = make_cap_vb(line_end, line_direction);\n    CapJoinFragment cap_frag0 = vertexCapJoin(cap_vb.v0, line_ubo);\n    CapJoinFragment cap_frag1 = vertexCapJoin(cap_vb.v1, line_ubo);\n    CapJoinFragment cap_frag2 = vertexCapJoin(cap_vb.v2, line_ubo);\n    \n    vec3 t3_w = make_barycentric(cap_frag0.position, cap_frag1.position, cap_frag2.position, P);\n    if(t3_w.x >= 0.0 && t3_w.y >= 0.0 && t3_w.z >= 0.0) {\n        //result_color = vec4(0.0, 1.0, 0.0, 1.0);\n        CapJoinFragment f;\n        f.position  = cap_frag0.position  * t3_w.y + cap_frag1.position  * t3_w.z + cap_frag2.position  * t3_w.x;\n        f.color     = cap_frag0.color     * t3_w.y + cap_frag1.color     * t3_w.z + cap_frag2.color     * t3_w.x;\n        f.radius    = cap_frag0.radius    * t3_w.y + cap_frag1.radius    * t3_w.z + cap_frag2.radius    * t3_w.x;\n        f.direction = cap_frag0.direction * t3_w.y + cap_frag1.direction * t3_w.z + cap_frag2.direction * t3_w.x;\n        vec4 color = fragCapJoin(f);\n        result_color = mix(result_color, color, color.a);\n    }\n    \n    fragColor = result_color;\n}","name":"Image","description":"","type":"image"}]}