{"ver":"0.1","info":{"id":"3syGzG","date":"1570403367","viewed":352,"name":"Charged interacting solitons","username":"michael0884","description":"A simulation of the most simple classical field model with charged solitonic particle-like waves that have a long-range interaction, similar to the EM field.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["waves","simulation","particles","physics","nonlinear","classicalfieldtheory","electromagnetic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec4 U = SAMPLR(BF, pos);\n    vec4 dU_dt = SAMPLR(AF, pos);\n    \n     float A = 2.*PI*length(U.xy); //the complex field A module\n    float B = 2.*PI*length(U.zw); //the complex field B module\n    float charge = 50.*(U.z*dU_dt.w - U.w*dU_dt.z); //charge in this frame of reference\n    fragColor.xyz = vec3(0.1,0.3,0.7)*charge - vec3(0.8,0.1,0.)*charge + 0.3*vec3(0.1,0.8,0.1)*A*A;\n    \n   // float scale = 0.5*length((iMouse.xy-size*0.5)/size);\n   // fragColor.xyz = FieldPotential(U).xyz;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define size iResolution.xy\n#define SAMPLR(a, pos) texture((a), (pos)/size)\n#define AF iChannel0\n#define BF iChannel1\n//scales\n#define dt 0.28\n#define dx 0.5\n#define border 0.01\n//nonlinearity\n#define K 0.03\n\n#define PI 3.14159265\n\n\n//how charges interact (+ to -)\n#define polarity -1.\n//-1 is the correct one, but is sometimes unstable\n//-1 is + is attracted to -\n//1 is + is attracted to +\n\n//vacuum noise cancelling \n#define noise_cancl 0.002\n\n//distance between particles in the initial condition\n#define distance 110.\n\n#define charge_coupling .15\n#define interaction_field_frequency  0.07\n\nfloat FieldPotential(vec4 fval)\n{\n    float A = 2.*PI*length(fval.xy); //the complex field A module\n    float B = 2.*PI*length(fval.zw); //the complex field B module\n    return K*(cos(A) + polarity*charge_coupling*(cos(A)*cos(B) - cos(B))) // the long range interaction potential  and the particle core\n        \t- polarity*interaction_field_frequency*dot(fval.zw,fval.zw) ; // the mass of the interaction field, without this everything is unstable\n    //basically A is the core field of the particle\n\t//and B is the charge field that is coupled to A in such a way that if A = 0 then B is just a wave field\n    //or in other words this potential is = to 1, which is a constant thus the force is zero\n\t//that makes B behave like a long-range interaction field \n}\n\n#define eps 0.005\n\nvec4 FieldForce(vec4 fval)\n{\n    vec2 d = vec2(eps,  0.);\n    //numerical gradient of the field potential\n    return 0.5*vec4( FieldPotential(fval+d.xyyy)-FieldPotential(fval-d.xyyy),\n                 FieldPotential(fval+d.yxyy)-FieldPotential(fval-d.yxyy),\n                 FieldPotential(fval+d.yyxy)-FieldPotential(fval-d.yyxy),\n                 FieldPotential(fval+d.yyyx)-FieldPotential(fval-d.yyyx) )/eps;\n}\n    \n\nvec4 SpinnerU(vec2 pos)\n{\n    float d = dot(pos,pos)*dx*dx/20.;\n    float ampl = 0.5*exp(-d);\n    return vec4(ampl,0,0.15/(1. + 0.1*d),0);\n}\n\nvec4 SpinnerdUdt(vec2 pos)\n{\n    float d = dot(pos,pos)*dx*dx/20.;\n    float ampl = 0.5*exp(-dot(pos,pos)*dx*dx/10.);\n    return vec4(0,ampl,0,0.15/(1. + 0.1*d));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//the value of the field is iChannel1, time derivative is iChannel0\n\nvec4 Laplacian(sampler2D F, vec2 pos)\n{\n    vec4 a = SAMPLR(F, pos);\n\tvec4 x0 = SAMPLR(F, pos + vec2(-1,0));\n    vec4 x1 = SAMPLR(F, pos + vec2(1,0));\n    vec4 y0 = SAMPLR(F, pos + vec2(0,1));\n    vec4 y1 = SAMPLR(F, pos + vec2(0,-1));\n \n\treturn (x0+x1+y0+y1-4.f*a)/(dx*dx);\n}\n\nvoid mainImage( out vec4 dU_dt, in vec2 pos)\n{   \n    vec4 U = SAMPLR(BF, pos);\n    dU_dt = SAMPLR(AF, pos);\n    \n    dU_dt += dt*(Laplacian(BF, pos) + FieldForce(U)*vec4(1,1,polarity,polarity));\n    \n    //eraser\n    if(iMouse.z>0.)\n        dU_dt *= 1.-0.4*exp(-pow(length(iMouse.xy-pos)/30.,2.));\n    \n    //initial conditions\n    if(iFrame <1) {\n        float charge = 2.*floor(mod((pos.y+pos.x + 0.5*distance)/distance,2.))  - 1.;\n    \tdU_dt = charge*SpinnerdUdt(mod(pos,vec2(distance,distance)) -0.5*vec2(distance,distance));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 U, in vec2 pos)\n{   \n    U = SAMPLR(BF, pos);\n    vec4 dU_dt = SAMPLR(AF, pos);\n    \n    U += dt*dU_dt;\n    \n    //mouse interaction\n    //if(iMouse.z>0.)\n       // U += SpinnerU(pos-iMouse.xy);\n    \n    //border conditions\n   // U *= 0.9+0.1*clamp(pos.x/size.x, 0., border)*clamp(pos.y/size.y, 0., border)/(border*border);\n   // U *=  0.9+0.1*clamp(1.-pos.x/size.x, 0., border)*clamp(1.-pos.y/size.y, 0., border)/(border*border);\n    \n    \n     //vacuum noise cancelling, also kills the particles after some time\n    {\n        float f_energy = dot(U,U) + dot(dU_dt,dU_dt);\n        if(f_energy < noise_cancl)\n        {\n            float k = (1.-0.01*f_energy/noise_cancl);\n            U *= k;\n        }\n    }\n    \n    //initial conditions\n    if(iFrame <1) {\n    \tU = SpinnerU(mod(pos,vec2(distance,distance)) -0.5*vec2(distance,distance));\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}