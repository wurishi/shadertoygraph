{"ver":"0.1","info":{"id":"XlSyDh","date":"1508315396","viewed":96,"name":"Blob rendering + soft shadows","username":"theFrenchDutch","description":"TP blobs","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs\n// Eric Galin\n\nconst int Steps = 500;\nconst float Epsilon = 0.01; // Marching epsilon\nconst int StepsShadow = 100;\nconst float EpsilonShadow = 0.1; // Marching epsilon for shadows\nconst float T=0.5;\n\nconst float rA=18.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\nconst float rAShadow = 0.5;\n\nconst float overRelaxation = 1.2;\n\nconst float minAttenShadow = 0.2; // Limit how much shadows reduce the light received.\nconst float shadowSoftFactor = 1.0; // Amount of softness; 1.0 = soft, 0.0 = hard\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nvec4 point(vec3 p, vec3 col, vec3 c, float e,float R)\n{\n  return vec4(col.rgb, e)*falloff(length(p-c),R);\n}\n\n// Bubble skeleton\n// p : point\n// c : center of bubble\n// r : radius of bubble\n// e : energy associated to skeleton\n// R : large radius\nvec4 bubble(vec3 p, vec3 col, vec3 c, float r, float e,float R)\n{\n  float dist = length(p - (normalize(p - c) * r));\n  return vec4(col.rgb, e)*falloff(dist,R);\n}\n\n// Segment skeleton\n// p : point\n// a : first point of segment\n// b : second point of segment\n// e : energy associated to skeleton\n// R : large radius\nvec4 segment(vec3 p, vec3 col, vec3 a, vec3 b, float e, float R)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  float dist = length( pa - ba*h );\n  return vec4(col.rgb, e)*falloff(dist,R);\n}\n\n// Disk skeleton\n// p : point\n// c : disk center\n// n : disk normal\n// r : disk radius\n// e : energy associated to skeleton\n// R : large radius\nvec4 disk(vec3 p, vec3 col, vec3 c, vec3 n, float r, float e, float R)\n{\n  vec3 q = p - (dot(p - c, n) * n);\n  float r2 = length(q - c);\n  if(r2 > r)\n  \tq = c + normalize(q - c) * r;\n  \n  float dist = length(p - q);\n  return vec4(col.rgb, e) * falloff(dist, R);\n}\n\n// Circle skeleton\n// p : point\n// c : disk center\n// n : disk normal\n// r : disk radius\n// e : energy associated to skeleton\n// R : large radius\nvec4 circle(vec3 p, vec3 col, vec3 c, vec3 n, float r, float e, float R)\n{\n  vec3 q = p - (dot(p - c, n) * n);\n  float r2 = length(q - c);\n  q = c + normalize(q - c) * r;\n  \n  float dist = length(p - q);\n  return vec4(col.rgb, e) * falloff(dist, R);\n}\n\n\nvec4 plan(vec3 p, vec3 col, vec3 c, vec3 n, float e, float R)\n{      \n   float h = -dot(p - c, n);\n   float d = distance(p, p + h * n);\n   return vec4(col.rgb, e) * falloff(d, R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Blend(vec4 a,vec4 b)\n{\n    return a + b;\n}\n\n// Negative Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 NegBlend(vec4 a,vec4 b)\n{\n    return a - b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Union(vec4 a,vec4 b)\n{\n    return max(a, b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Intersection(vec4 a,vec4 b)\n{\n    return min(a, b);\n}\n\n// Subtraction\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 Subtract(vec4 a,vec4 b)\n{\n    return min(a, 2.0*T-b);\n}\n\n// Potential field of the object\n// p : point\nvec4 object(vec3 p)\n{\n  p.z = -p.z;\n  /*float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n                  point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  v=Subtract(v,point(p,vec3(-2.0, 1.0, -1.0),1.0,5.5));\n  v = Blend(v, segment(p, vec3(-5.0, 0.0, 0.0), vec3(5.0, 0.0, 0.0), 1.0, 2.5));\n  v = Blend(v, segment(p, vec3(0.0, -5.0, 0.0), vec3(0.0, 5.0, 0.0), 1.0, 2.5));\n  v = Blend(v, disk(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 4.0, 1.0, 1.0));*/\n  \n  vec3 red = vec3(1.0, 0.0, 0.0);\n  vec3 green = vec3(0.5, 0.5, 0.6);\n  vec3 blue = vec3(0.0, 0.0, 1.0);\n  float timeMod = sin(iTime * 5.0);\n    \n  vec4 v = segment(p, green, vec3(-6.0, 0.0, 0.0), vec3(6.0, 0.0, 0.0), 1.0, 1.5);\n  v = Blend(v, circle(p, mix(blue, red, timeMod * 0.5 + 0.5), vec3(5.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 3.0 - timeMod, 1.0, 1.0));\n  v = Blend(v, circle(p, mix(blue, red, timeMod * 0.5 + 0.5), vec3(-5.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 3.0 - timeMod, 1.0, 1.0));\n  v = Subtract(v, circle(p, red, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 3.0, 1.0, 1.0));\n  v = Blend(v, bubble(p, mix(red, blue, timeMod * 0.5 + 0.5), vec3(0.0, 0.0, 0.0), 2.5 + timeMod, 1.0, 0.5));\n  v = Subtract(v, disk(p, red, vec3(-1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 4.0, 1.0, 1.0));\n  v = Subtract(v, disk(p, red, vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 4.0, 1.0, 1.0));\n  v = Blend(v, disk(p, green, vec3(0.0, -3.0, 0.0), vec3(0.0, 1.0, 0.0), 8.0, 1.0, 1.0));\n  v.w = v.w - T;\n  return v;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  vec4 v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).w - v.w;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).w - v.w;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).w - v.w;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out vec3 col)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    vec4 v = object(p);\n    // Hit object\n      if (v.w > 0.0)\n      {\n          s=i;\n          h = true;\n          col = v.rgb;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(float rayA, int Steps, float Epsilon,\n                  vec3 o, vec3 u,\n                  out bool h, out int s, out vec3 col, out float shadow)\n{\n  h = false;\n\n  // Don't start at the origin, instead move a little bit forward\n  float t=rayA;\n\n  for(int i=0; i<Steps; i++)\n  {\n      s=i;\n      vec3 p = o+t*u;\n      vec4 v = object(p);\n    \n      // Soft Shadows\n      shadow = min(shadow, abs(v.w)/4.0);\n    \n      // Hit object\n      if (v.w > 0.0)\n      {\n          s=i;\n          h = true;\n          col = v.rgb;\n          shadow = 0.0;\n          break;\n      }\n      \n      // Move along ray with over-relaxation\n      t += max(Epsilon, abs(v.w)/4.0);\n      \n      // Escape marched far away\n      if (t > rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.5, 0.2, 0.0), vec3(0.4, 0.9, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n, vec3 col)\n{\n  // Directional light\n  const vec3 lightColor = vec3(2.0, 2.0, 2.0);\n  vec3 l = normalize(vec3(1, -1, 1));\n  l = rotateY(l, iTime * 0.25);\n    \n  // Soft Shadows\n  bool hit = false;\n  int s;\n  vec3 col2;\n  float shad = 9999999.0;\n  float t = SphereTrace(rAShadow, StepsShadow, EpsilonShadow, p, -l, hit, s, col2, shad);\n  float atten = clamp(shad / (shadowSoftFactor * 0.1), 0.0, 1.0) * (1.0 - minAttenShadow) + minAttenShadow;\n  \n    \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n    \n  col = diff * col * (lightColor * atten);\n\n  return col;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, -2.0, 25.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  ro = rotateX(ro, -0.5);\n  rd = rotateX(rd, -0.5);\n  ro = rotateY(ro, 3.5);\n  rd = rotateY(rd, 3.5);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  vec3 col;\n  float shadow = 9999999.0;\n  float t = SphereTrace(rA, Steps, Epsilon, ro, rd, hit, s, col, shadow);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n, col);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}