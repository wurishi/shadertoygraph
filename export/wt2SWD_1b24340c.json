{"ver":"0.1","info":{"id":"wt2SWD","date":"1566036384","viewed":264,"name":"Blubbly Jubbly","username":"shau","description":"Beeple inspired noise and smin","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["3d","beeple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise(vec2 uv, float s1, float s2, float t1, float t2, float c1) {\n\treturn clamp(hash33(vec3(uv.xy * s1, t1)).x +\n\t\thash33(vec3(uv.xy * s2, t2)).y, c1, 1.);\n}\n\n// particles (Andrew Baldwin)\n// stolen from Galvanize by Virgill \nfloat snow(vec3 direction) {\n\tfloat help = 0.0;\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uvx = vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy / iResolution.xy;\n\tfloat acc = 0.0;\n\tfloat DEPTH = direction.y*direction.y-0.3;\n\tfloat WIDTH =0.1;\n\tfloat SPEED = 0.1;\n\tfor (int i=0;i<10;i++) {\n\t\tfloat fi = float(i);\n\t\tvec2 q = uvx*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .04;\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\n\t\thelp = acc;\n\t}\n\treturn help;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec2 uv = U/R;\n    vec3 pc = vec3(0.0);\n    vec4 core = texture(iChannel0, uv),\n         particles = texture(iChannel1, uv),\n         grid = texture(iChannel2, uv);\n    \n    float cx = 1. - abs(uv.x - .5) * 2.,\n          n = noise(uv, 64., 16., float(iFrame), float(iFrame), .96);\n\n    pc = vec3(0.4) * pow(cx,0.5) + vec3(1.) * pow(cx,3.) * n;\n    \n    if (core.w != FAR) {\n        pc = core.xyz;\n    }\n    \n    pc += clamp(particles.xyz, 0.0, 1.0);\n    \n    if (grid.w < core.w) {\n        pc += grid.xyz * 0.3 * step(0.8, T);// *step(sin(T*0.2), 0.9); \n    }\n    \n    pc += snow(normalize(vec3(0.1,2.0,0.2)))*0.4;\n\n    C = vec4(pc,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 30.0\n#define PI 3.14159\n#define T iTime\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z) * UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec2 hash22(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//fabrice\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nvec3 camera(\n    vec2 U, \n    vec2 r, \n    inout vec3 ro, \n    inout vec3 la, \n    inout vec3 lp, \n    float fl,\n    float t\n) {\n\n    la = vec3(0.0, 0.0, 0.0);\n    ro = vec3(0.0, 1.0 + sin(t*0.05)*3.0, -8.0);\n    lp = vec3(6,-5,-2);\n    \n    ro.xz *= rot(t*0.3);\n    \n    vec2 uv = (U - r*.5)/r.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0 * PI / repetitions;\n    float a = atan(p.y, p.x) + angle / 2.0;\n    float r = length(p);\n    float c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n//IQ\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba*h) - r;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*Scene*/\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Distance functions IQ\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p/r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat dfRing(vec3 p , vec2 t, float ma, float at) {\n    p.y += at;\n    p.y = mod(p.y, ma) - (ma*0.5);\n    return sdTorus(p, t);\n}\n\nfloat blob(vec3 p) {\n    float m = (sin(p.y*2.0) + 1.0)*0.12+ \n              (sin((p.y+T*0.4)*5.0) + 1.0)*0.05;\n    p.xz *= 1.0 + m;\n    pMod(p.y, 14.0);\n    pModPolar(p.xz, 12.0 + sin(p.y+T*0.)*2.0);\n    float el = sdEllipsoid(p - vec3(2.8,0,0), \n                           vec3(1.4,2.6,1.4) - n3D(p*4.0)*0.04);\n    return smin(el, sdCapsule(p, vec3(0,2.6,0), vec3(0,-2.6,0), 2.0), 1.4);\n}\n    \nfloat map(vec3 p) {\n    \n    //rings\n    float rings = dfRing(p, \n                         vec2(4.0, 0.1), \n                         12.0, \n                         T*-2.0);\n    rings = min(rings, dfRing(p - vec3(0.0, 3.0, 0.0), \n                              vec2(5.0, 0.14), \n                              17.0, \n                              T*-5.0));\n    rings = min(rings, dfRing(p - vec3(0.0, 8.0, 0.0), \n                              vec2(3.5, 0.04), \n                              25.0, \n                              T*-5.0));\n    rings = min(rings, dfRing(p - vec3(0.0, 5.0, 0.0), \n                              vec2(4.5, 0.04), \n                              35.0, \n                              T*-5.0));\n    \n    //core\n    float core = smin(blob(vec3(p.x, p.y+T, p.z)),\n                   blob(vec3(p.x, p.y+T-35.0, p.z)),\n                   1.0);\n    \n    return min(rings, core);\n}\n\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx) + e.xxy * map(p + e.xxy) + \n\t\t\t\t\t e.xyx * map(p + e.xyx) + e.yyy * map(p + e.yyy));   \n}\n\nfloat march(vec3 ro, vec3 rd) {\n    \n    float t = 0.0;\n    \n    for (int i = 0; i < 120; i++) {\n        float si = map(ro + rd * t);\n        if (abs(si) < EPS || t > FAR) {\n            break;\n        }\n        t += si * 0.8; //abs?\n    }\n    \n    return t;\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec3 pc = vec3(0),\n         ro,\n         la,\n         lp;\n    \n    vec3 rd = camera(U, R, ro, la, lp, 1.4, T);\n    \n    float si = march(ro, rd);\n    \n    float mint = FAR;\n    if (si>0.0 && si<FAR) {\n        mint = si;\n        vec3 p = ro + rd*si;\n        vec3 n = normal(p);\n        vec3 ld = normalize(lp-p);\n        float ao = AO(p, n);\n        float df = max(0.05, dot(ld,n));\n        pc = mix(vec3(1)*ao, vec3(1)*df, 0.3);\n    }\n    \n    C = vec4(pc,mint);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/* Particles */\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec3 h3 = 2.0 * (hash33(vec3(U+20.0+T, float(iFrame))) - 0.5);\n    vec2 uv = U/R,\n         xz = sign(h3.xz)*3.0 + h3.xz;\n    \n    C = texture(iChannel0, uv);\n    \n    if (C==vec4(0)) {\n        C = vec4(xz.x, h3.y*20.0, xz.y, max(0.2, h3.x * .3));\n    }\n    if (C.y>20.0) {\n        C = vec4(xz.x, -20.0 + h3.y, xz.y, max(0.2, h3.x * .2));    \n    }\n    \n    vec3 r = vec3(C.x, 0.0, C.z);\n    r.xz *= rot(.1*C.w);\n    C.xz = r.xz;\n    C.y += C.w * .3;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*Render Particles*/\n\n//IQ - Intesectors, sphere and box functions\n//https://iquilezles.org/www/index.htm\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.) return -1.0;\n\treturn -b - sqrt(h);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec3 pc = vec3(0),\n         ro,\n         la,\n         lp;\n    \n    vec3 rd = camera(U, R, ro, la, lp, 1.4, T);\n    vec4 buf = texture(iChannel0,U/R);\n    vec4 scene = texture(iChannel2,U/R);\n\n    float mint = FAR;\n    for (float i = 0.0; i<30.0; i+=1.0) {\n        vec4 sp = texture(iChannel1, vec2(i+0.5, 100.5)/R);  \n        float si = sphIntersect(ro, rd, sp);\n        if (si>0.0 && si<mint && si<scene.w) {\n            mint = si;\n            float sd = sphDensity(ro, rd, sp, FAR);\n            pc = vec3(0.1) * sd*sd*sd;\n            pc += vec3(0.4) * pow(sd, 16.0);\n        }\n    }\n    pc += buf.xyz*0.9;\n    \n    \n    C = vec4(pc, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/* Grid */\n\nvec2 nearest(vec2 a, vec2 b) {\n    float s = step(a.x, b.x);\n    return a*s + (1.0-s)*b;\n}\n\nvec2 map(vec3 p) {\n    p.y -= T*0.6;\n    p.xz *= 1.0 + sin(p.y*0.5)*0.1;\n    p.xz *= rot(sin(p.y*0.05)*0.3);\n    float at = sin(T*0.6);\n    float r = 4.0 + at * 1.0;\n    pMod(p.y, 1.4 + at*0.01);\n    pModPolar(p.zx, 12.0);\n    float balls = length(p - vec3(0.0,0.0,r)) - 0.1; //spheres\n    \n    float grid = sdCapsule(p, vec3(0.0,1.0,r), vec3(0.0,-1.0,r), 0.016);\n    vec3 p2 = vec3(1.0,0.0,r);\n    p2.xz *= rot(0.2618);\n    p.x = abs(p.x);\n    grid = min(grid, sdCapsule(p, vec3(0.0,0.0,r), p2, 0.016));\n    \n    return nearest(vec2(grid, 1.0), vec2(balls, 2.0));\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n    \n    float t = 0.0, id = 0.0;\n    \n    for (int i = 0; i < 120; i++) {\n        vec2 si = map(ro + rd * t);\n        if (abs(si.x) < EPS) {\n            id = si.y;\n            break;\n        }\n        t += si.x;\n        if (t>FAR) break;\n    }\n    \n    return vec2(t, id);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n\n    vec3 pc = vec3(0),\n         ro,\n         la,\n         lp;\n    \n    vec3 rd = camera(U, R, ro, la, lp, 1.4, T);\n    vec2 si = march(ro, rd);\n    float mint = FAR;\n  \n    if (si.y>0.0) {\n        mint = si.x;\n        if (si.y==2.0) pc = vec3(FAR/(si.x*8.0));  \n        float at = step(sin(T*0.4), 0.2);\n        if (si.y==1.0 && at>0.0) pc = vec3(FAR/(si.x*8.0));\n    }\n    \n    C = vec4(pc, mint);\n}","name":"Buffer D","description":"","type":"buffer"}]}