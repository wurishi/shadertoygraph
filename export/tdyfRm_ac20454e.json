{"ver":"0.1","info":{"id":"tdyfRm","date":"1626907424","viewed":54,"name":"OctahedronEnvironmentMaps","username":"programiao","description":"OctahedronEnvironmentMaps","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["environmentmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat map(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; i++)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\n\n#define PI 3.14159265\n//Number of samples to sample the envmap (max 4096)\n#define SAMPLES 500.0\n//Material roughness\n#define ROUGHNESS 1.0\n//Exposure of the scene\n#define EXPOSURE 3.0\n//Display background with the following opacity \n#define BACKGROUND_VISIBLE 0.5\n//distance of the camera from the sphere\n#define CAM_DISTANCE 2.0\nvec3 cam = vec3(0.0,0.0,5.0);\nvec4 sphere = vec4(0.0,0.0,0.0f,1.0);\nvec3 diffuse = vec3(1.0,1.0,1.0);\nvec3 spec = vec3(1.0, 1.0,1.0);\nvec3 background = vec3(.3); \n\nfloat fresnel(float v)\n{\n    return pow(1.0-cos(v), 5.0);\n}\n\n\nvec2 m1(vec3 normal)\n{\n    vec3 absNormal = abs(normal);\n    float sumAbs = absNormal.x + absNormal.y + absNormal.z;\n    vec2 uv;\n    if (normal.z >= 0.0f)\n    {\n        uv.x = normal.x / sumAbs;\n        uv.y = normal.y / sumAbs;\n    }\n\telse\n    {\n        uv.x = 1.0f - absNormal.y / sumAbs;\n        uv.y = 1.0f - absNormal.x / sumAbs;\n        uv.x = normal.x >= 0.0f ? uv.x : -uv.x;\n        uv.y = normal.y >= 0.0f ? uv.y : -uv.y;\n    }\n    \n    uv.x = uv.x * 0.5 + 0.5;\n    uv.y = uv.y * 0.5 + 0.5;\n    return uv;\n}\nfloat hitSphere(vec3 dir, vec3 center, float radius)\n{\n    float a = dot(dir, dir);\n    float b = dot(2.0*dir, cam-center);\n    float c = dot(cam-center, cam-center) - pow(radius, 2.0);\n    \n    float sDelta = sqrt(pow(b, 2.0) - (4.0*a*c));\n    float t = (-b - sDelta)/(2.0 * a);\n    float t1 = (-b + sDelta)/(2.0 * a);\n\treturn max(min(t,t1),0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (uv - vec2(0.5)) * 2.0 * vec2(1.0, iResolution.y/iResolution.x);\n    \n    float time = iTime * 0.3;\n    cam = CAM_DISTANCE * vec3(cos(time), cos(time), sin(time));\n    \n    vec3 forward = normalize(vec3(sphere)-cam);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    vec3 dir = (right * cuv.x);\n    dir += (up * cuv.y);\n    dir += forward;\n    dir = normalize(dir);\n    \n    float t = hitSphere(dir, sphere.xyz, sphere.w);\n    vec3 normal = normalize((cam + t*dir) - sphere.xyz);\n\n    vec2 uvOct = m1(normal);\n    vec4 light = texture(iChannel0, uvOct);\n    light = t < 1.0 ? vec4(0.0,0.0,0.0,0.0) : light;\n    fragColor = light;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 m1(vec3 normal)\n{\n    vec3 absNormal = abs(normal);\n    float sumAbs = absNormal.x + absNormal.y + absNormal.z;\n    vec2 uv;\n    if (normal.z >= 0.0f)\n    {\n        uv.x = normal.x / sumAbs;\n        uv.y = normal.y / sumAbs;\n    }\n\telse\n    {\n        uv.x = 1.0f - absNormal.y / sumAbs;\n        uv.y = 1.0f - absNormal.x / sumAbs;\n        uv.x = normal.x >= 0.0f ? uv.x : -uv.x;\n        uv.y = normal.y >= 0.0f ? uv.y : -uv.y;\n    }\n    return uv;\n}\n\nvec3 m2(vec2 uv)\n{\n    uv = uv * 2.0 - 1.0;\n    vec3 normal = vec3(uv.x, uv.y, 1.0 - abs(uv.x) - abs(uv.y));\n    float t = clamp( -normal.z , 0.0, 1.0);\n    normal.x += normal.x >= 0.0 ? -t : t;\n    normal.y += normal.y >= 0.0 ? -t : t;\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 co = normalize(m2(uv));\n    \n\tfragColor = vec4(texture(iChannel0, co).rgb, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}