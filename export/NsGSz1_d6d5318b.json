{"ver":"0.1","info":{"id":"NsGSz1","date":"1634297125","viewed":158,"name":"Newtons Fractal","username":"atilo","description":"Visualizer of the Newton's Fractal.\n\nInspired by https://www.youtube.com/watch?v=-RdOwhmqP5s","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// DEFINITIONS - Please experiment\n// rootLen = len(roots) = len(colors)\n\nfloat scale = 4.;\nint iterations = 100;\nvec2 offset = vec2(0, 0);\n\n// Number of roots of the function\nint rootLen = 5;\n// vec2 as a + bi\nvec2[] roots = vec2[](\n    vec2(0.66235898, 0.56227951),\n    vec2(0.66235898, -0.56227951),\n    vec2(0, 1),\n    vec2(0, -1),\n    vec2(-1.32471796, 0)\n);\nvec3[] colors = vec3[](\n    vec3(0.247,0.624,0.745), // #3F9FBE\n    vec3(0.788,0.329,0.239), // #C9543D\n    vec3(0.373,0.537,0.294), // #5F894B\n    vec3(1.,0.961,0.208),    // #FFF535\n    vec3(0.694,0.451,0.49)   // #B1737D\n);\n\nvec2 function(vec2 z) {\n    // z^5 + z^2 - z + 1\n    return c_pow(z, 5) + c_pow(z, 2) - z + vec2(1, 0);\n}\n\nvec2 derivative(vec2 z) {\n    // 5z^4 + 2z - 1\n    return c_mul( c_pow(z, 4), 5. ) + c_mul(z, 2.) - vec2(1, 0);\n}\n\n// DONT CHANGE ANYTHING PAST THIS LINE\n\n\n\n\n\nvec2 newtonStep(vec2 z) {\n    // Newton's algorithm step\n    return z - c_div( function(z), derivative(z) );\n}\n\nvec3 closestColor(vec2 z, int iterations) {\n    // Newton's algorithm\n    for(int i = 0; i<iterations; i++) {\n        z = newtonStep(z);\n    }\n    \n    // Determine closest\n    int closest = -1;\n    float minDistance = infinity;\n    for(int i = 0; i<rootLen; i++) {\n        float dist = distance(roots[i], z);\n        if(dist < minDistance) {\n            closest = i;\n            minDistance = dist;\n        }\n    }\n    \n    // Return color of closest\n    return colors[closest];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // x-Normalized pixel coordinates\n    // Can be interpreted as complex plane\n    vec2 z = fragCoord/iResolution.x;\n    \n    // Shift (0, 0) to center and scale\n    z -= vec2(.5, .5 * 9. / 16.);\n    z += offset;\n    z *= scale;\n    \n    // Output to screen\n    fragColor = vec4(closestColor(z, iterations), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float infinity = 1.0 / 0.0; // IEEE 754 trickery\n\n// z1 * z2\nvec2 c_mul(vec2 z1, vec2 z2) {\n    // z1 = a + bi\n    // z2 = c + di\n    float a = z1[0];\n    float b = z1[1];\n    float c = z2[0];\n    float d = z2[1];\n    \n    return vec2(a*c - b*d, a*d + b*c);\n}\n\n// z * x\nvec2 c_mul(vec2 z, float x) {\n    // Simplifies to vector-scalar multiplication\n    return z * x;\n}\n\n// z1 / z2\nvec2 c_div(vec2 z1, vec2 z2) {\n    // z1 = a + bi\n    // z2 = c + di\n    float a = z1[0];\n    float b = z1[1];\n    float c = z2[0];\n    float d = z2[1];\n    \n    float denom = c*c + d*d;\n    \n    float real = (a*c + b*d) / denom;\n    float imag = (b*c - a*d) / denom;\n    \n    return vec2(real, imag);\n}\n\n// z^p\nvec2 c_pow(vec2 z, int p) {\n    vec2 result = z;\n    \n    for(int i = 1; i<p; i++) {\n        result = c_mul(result, z);\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}