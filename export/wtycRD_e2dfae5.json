{"ver":"0.1","info":{"id":"wtycRD","date":"1663326216","viewed":46,"name":"snowman-1","username":"urbans","description":"snowman","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["snowman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\nfloat sdPlane(vec3 pos, float elev)\n{\n    return pos.y + elev;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat2 rotate(float theta)\n{\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n\nfloat sdSnowman(vec3 pos){\n\n    float t = fract(iTime);\n    float y = 1.0*t*(1.0-t);\n    vec3 cen = vec3(0.0,y,0.0);\n    \n    pos=pos-cen;\n\n    float d1 = sdSphere(pos, 0.25);\n    float d2 = sdSphere(vec3(pos.x, pos.y-0.3, pos.z), 0.18);\n    float d3 = sdSphere(vec3(pos.x, pos.y-0.53, pos.z), 0.13);\n    float eyes = sdSphere(vec3(pos.x-0.12, pos.y-0.56, abs(pos.z)-0.04), 0.016);\n    float cone = sdRoundCone(vec3(pos.y-0.51, pos.x-0.03, pos.z), 0.04, 0.01, 0.2);\n    float hat = sdCappedCylinder(vec3(pos.x, pos.y-0.65, pos.z), 0.09, 0.1);\n    float hatHandle = sdTorus(vec3(pos.y-0.7, pos.x, pos.z+0.1), vec2(0.03,0.01));\n    float buttons1 = sdSphere(vec3(pos.x-0.24, abs(pos.y-0.01)-0.07, pos.z), 0.016);\n    float buttons2 = sdSphere(vec3(pos.x-0.17, abs(pos.y-0.30)-0.06, pos.z), 0.016);\n    \n    float d;\n    d = min(d1,d2);\n    d = min(d,d3);\n    d = min(d,eyes);\n    d = min(d, cone);\n    d = min(d, hat);\n    d = min(d, hatHandle);\n    d = min(d, buttons1);\n    d = min(d, buttons2);\n    return d;\n}\n\nfloat map(vec3 pos){\n    \n    float snowman = sdSnowman(pos);\n    float dfloor = sdPlane(pos, 0.15);    \n    float d;\n    d = min(snowman,dfloor);\n\n    return d;\n}\n\nvec3 calcNormal(in vec3 pos){\n     vec2 e = vec2(0.0001, 0.0);\n     return normalize(vec3( map(pos+e.xyy) - map(pos-e.xyy),\n                            map(pos+e.yxy) - map(pos-e.yxy),\n                            map(pos+e.yyx) - map(pos-e.yyx) ));\n     \n}\n\nfloat castRay ( in vec3 ro, vec3 rd){\n\n    float t = 0.0;\n    for(int i=0; i<100; i++){\n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        if (h<0.0001) \n            break;\n        \n        t+=h;\n        \n        if (t>20.0)\n            break;\n    }\n    if(t>20.0) t*=-1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    float an = iTime;\n\n    vec3 ro = vec3(0.0,0.4, 1.2);\n    // iq rotation\n    //vec3 ta = vec3(0.0,0.0,0.0);\n    //vec3 ww = normalize(ta - ro);\n    //vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    //vec3 vv = normalize(cross(uu,ww));\n    //vec3 rd = normalize(vec3(p.x * uu + p.y * vv + 1.5 * ww));\n    \n    vec3 rd = normalize(vec3(p, -1.5));\n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7*rd.y; // sky\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*rd.y));\n\n    float theta = iTime / 5.0;\n    theta -= 5.0 * iMouse.x/iResolution.x;\n    rd.xz *= rotate(theta);\n    ro.xz *= rotate(theta);\n    \n\n    float t = castRay(ro, rd);\n    \n    if(t > 0.0){\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(0.2); // default albedo\n        \n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 1.0+cos(iTime/10.0)));\n        // sun diffuse\n        float sun_dif = clamp( dot(nor, sun_dir), 0.0, 1.0);\n        // sun shadow\n        float sun_sha = step(castRay(pos + nor*0.001, sun_dir),0.0);\n        // sky diffuse\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,1.0,0.0)), 0.0, 1.0);\n        // bounce diffuse - to control & reduce the blacks\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n        \n        col  = mate * vec3(7.0, 4.0, 3.0) * sun_dif * sun_sha;\n        col += mate * vec3(0.5, 0.8, 0.9) * sky_dif;\n        col += mate * vec3(0.7, 0.3, 0.3) * bou_dif;\n        //col=nor.zzz;\n    }\n\n    col = pow(col, vec3(0.4545)); // gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}