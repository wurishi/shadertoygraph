{"ver":"0.1","info":{"id":"NlcBWf","date":"1665774310","viewed":36,"name":"CS4710 - Shader Project 1","username":"StevenJSweeney","description":"3D solid made of multiple primitives that moves non-linearly with non-linear noise and wacky patterns.  Has an issue where I don't know how to clamp textures to objects, especially moving ones","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["beginner","classwork"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        0.0, c, -s,\n        0.0, s, c,\n        1.0, 0.0, 0.0\n    );\n}\n\nmat3 rotateZ(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        0.0, 0.0, 1.0,\n        c, -s, 0.0,\n        s, c, 0.0\n    );\n}       \n\nbool calcScene (vec3 camera, vec3 direction, out vec3 outPosition) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        //position based on ray values\n        vec3 position = camera * sin(iTime) * 1.1 - vec3(-10.0, -10.0, 300.0) + direction * t;\n        position.x = position.x + 10.0 * cos(iTime * 2.0);\n        position.y = position.y + 10.0 * sin(iTime * 2.0);\n        \n        //define shape(s) in the image\n        float dist = opSmoothUnion(sdBoxFrame(rotateZ(iTime) * position, vec3(3.0, 1.0, 3.0), 4.0f),\n                                   opSmoothUnion(\n                                       sdSphere(rotateZ(iTime) * position - vec3 (0.0, 5.0, 0.0), 3.0f),\n                                       sdSphere(rotateZ(iTime) * position - vec3 (0.0, -5.0, 0.0), 3.0f),\n                                       3.0f),\n                                   4.0f);\n        \n        //check for ray hit\n        if (dist <= 0.001) {\n            outPosition = position;\n            return true;\n        }\n        t += dist;\n    }\n    //if ray does not hit after 50 loops, then...\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    \n    vec3 col = vec3(texture(iChannel0, uv + vec2(0.5, 0.5)).rgb);\n    col = col + vec3(texture(iChannel1, uv + vec2(0.5 + cos(3.0 * iTime), 0.5 + sin(3.0 * iTime))).rrr/2.0);\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 camera = vec3(10, 10, -100);\n    \n    vec3 direction = normalize(vec3(uv.x * iResolution.x/iResolution.y, uv.y, 5));\n    vec3 directiondx = normalize(vec3((uv.x * iResolution.x/iResolution.y)+0.001, uv.y, 5));\n    vec3 directiondy = normalize(vec3(uv.x * iResolution.x/iResolution.y, uv.y+0.001, 5));\n    \n    vec3 position;\n    vec3 positiondx;\n    vec3 positiondy;\n    \n    vec3 normal = vec3(0, 0, 1);\n    \n    if (calcScene(camera, direction, position) &&\n        calcScene(camera, directiondx, positiondx) &&\n        calcScene(camera, directiondy, positiondy))\n    {\n        vec3 downVec = normalize(positiondy - position);\n        vec3 rightVec = normalize(positiondx - position);\n        normal = normalize(cross(downVec, rightVec));\n        normal.z = -normal.z;\n        \n        vec3 lightDir = normalize(vec3(-(iMouse.xy/iResolution.xy) - vec2(0.5), 1.0));\n        \n        col = (vec3(texture(iChannel2, uv + vec2(0.5, 0.5)).rgb)) + (vec3(texture(iChannel2, uv + vec2(0.5, 0.5)).rgb)) * (clamp(dot(-lightDir,normal) + pow(dot(-direction,reflect(-lightDir,normal)),15.0),0.0,1.0));\n    }\n    \n\n    // Mouse position varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(0.05*(iMouse.xyx)+uv.xyx+vec3(0, 2, 4));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}