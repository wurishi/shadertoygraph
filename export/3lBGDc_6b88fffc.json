{"ver":"0.1","info":{"id":"3lBGDc","date":"1561301730","viewed":449,"name":"404 ERROR","username":"KilledByAPixel","description":"Short looping fractal for a 404 error page.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","zoom","pixel","matrix","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Infinity Matrix - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 3.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 2;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\nconst int glyphs[glyphSize*glyphCount] = int[]\n(\t// glyph sheet\n\t0x01110, 0x11011, \n\t0x11011, 0x11011,\n\t0x11011, 0x11111, \n\t0x11011, 0x00011,\n\t0x01110, 0x00011\n);\t//  0        4\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 10;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0), pow(gsfi,8.0), pow(gsfi,9.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nconst float loopTime = 2.;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0.,0.0,0.); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3\n    (\n    \tmix(-0.05, 0.1, RandFloat(419*glyphPosLast.x + 773*glyphPosLast.y)),\n   \t\tmix(0.5, 3.0, RandFloat(929*glyphPosLast.x + 499*glyphPosLast.y)),\n      \t1.0\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color.x += myColor.x*f;;\n        color.y = max(color.y, myColor.y*f);\n    color.z = max(color.z, myColor.z*pow(f, 1.3));\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // brighten\n    //color += vec3(0.05);\n    \n    //color.x+=.95;\n    \n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.01*sin(9.0*uv.y + pi*2.0*iTime/loopTime);\n\tuv.y += 0.01*sin(2.0*uv.x + 0.8*iTime/loopTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return i % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    \n    if (iterations%2==0)\n     \treturn ivec2(2,2);\n    else\n     \treturn ivec2(1,4);\n    /*\n    // count valid pixels in glyph\n    int g = GetFocusGlyph(iterations-1);\n    int c = 0;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n            c += (1 & (glyphRow >> 4*x));\n    }\n\n    // find a random valid pixel in glyph\n    c -= RandInt(iterations) % c;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n        {\n            c -= (1 & (glyphRow >> 4*x));\n            if (c == 0)\n                return ivec2(glyphSize - 1 - x, glyphSize - 1 - y/glyphCount);\n        }\n    }*/\n}\n  \nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos)\n{ \n    if (glyphPos == focusPos)\n        return GetFocusGlyph(iterations); // inject correct glyph     \n            \n    return (glyphPos.x+glyphPos.y)%2;\n    \n    int seed = iterations + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return RandInt(seed) % glyphCount; \n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\nuv.x*=1.5;\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = (iTime+1.)*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}