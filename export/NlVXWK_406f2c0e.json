{"ver":"0.1","info":{"id":"NlVXWK","date":"1641367502","viewed":295,"name":"Voxel terrain raytraced","username":"Balint","description":"Voxels","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"NtVSWK","parentname":"DDA voxel tracing 3D"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DISTANCE = 200.0;\nconst int MAX_STEPS = 750;\nconst float PI = 3.141592654;\nconst vec3 SUN = normalize(vec3(1, 3, 2));\nconst vec3 AMBIENT = vec3(0.5, 1.0, 1.0);\n\nconst int STONE = 0;\nconst int DIRT = 1;\nconst int GRASS = 2;\nconst int SNOW = 3;\nconst int WATER = 4;\nconst int SAND = 5;\nconst vec3[] COLORS = vec3[](\n    vec3(0.5),\n    vec3(0.5, 0.33, 0.16),\n    vec3(0.16, 0.5, 0.16),\n    vec3(0.9, 0.9, 1.0),\n    vec3(0.1, 0.2, 1.0),\n    vec3(0.7, 0.6, 0.0)\n);\n\nbool isSolid(vec3 pos) {\n    vec3 cellPos = floor(pos);\n    return length(cellPos) < 5.0;\n}\n\nfloat noise(vec2 pos) {\n    float gain = 2.1;\n    \n    float weight = 1.0;\n    float frequency = 1.0;\n    float totalWeight = 0.0;\n    float res = 0.0;\n    for (int i = 0; i < 8; i++) {\n        res += texture(iChannel0, pos * frequency).r * weight;\n        totalWeight += weight;\n        weight /= gain;\n        frequency *= 2.0;\n    }\n    \n    return res / totalWeight;\n}\n\nint getBlock(vec3 cell) {\n    if (cell.y < 90.0) {\n        return WATER;\n    }\n\n    float height = noise(cell.xz / 20000.0) * 200.0 + 10.0;\n    if (cell.y < height - 2.0) {\n        return STONE;\n    } else if (cell.y < height - 1.0) {\n        return DIRT;\n    } else if (cell.y < height) {\n        float snowLimit = noise(cell.xz / 500.0) * 10.0 + 125.0;\n        float sandLimit = noise(cell.xz / 40.0 + 100.0) * 3.0 + 92.0;\n        \n        if (height > snowLimit) {\n            return SNOW;\n        } else if (height < sandLimit) {\n            return SAND;\n        }\n        return GRASS;\n    }\n    return -1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor.rgb = AMBIENT;\n    float angle = PI / 5.0;\n    mat2 rot = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n\n    vec3 ro = vec3(0, 180, -iTime * 30.0);\n    vec3 rd = normalize(vec3((fragCoord - iResolution.xy / 2.0) / iResolution.y, -1));\n    rd.zy = rot * rd.zy;\n    \n    vec3 pos = ro;\n    vec3 cell = floor(ro);\n    vec3 lastCell = cell;\n    \n    vec3 nextEdge = vec3(greaterThan(rd, vec3(0)));\n    vec3 steps = (nextEdge - fract(pos)) / rd;\n    vec3 originalStepSizes = abs(1.0 / rd);\n    vec3 rdSign = sign(rd);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        float stepSize = min(steps.x, min(steps.y, steps.z));\n        pos += rd * stepSize;\n        vec3 stepAxis = vec3(lessThanEqual(steps, vec3(stepSize)));\n        cell += stepAxis * rdSign;\n        steps += originalStepSizes * stepAxis - stepSize;\n    \n        int block = getBlock(cell);\n        if (block > -1) {\n            vec3 normal = lastCell - cell;\n            \n            int face;\n            vec2 uv;\n            if (normal.z > 0.999) {\n                uv = pos.xy;\n                face = 0;\n            } else if (normal.z < -0.999) {\n                uv = (pos.xy - 0.5) * vec2(-1, 1) + 0.5;\n                face = 1;\n            } else if (normal.x > 0.999) {\n                uv = (pos.zy - 0.5) * vec2(-1, 1) + 0.5;\n                face = 2;\n            } else if (normal.x < -0.999) {\n                uv = pos.zy;\n                face = 3;\n            } else if (normal.y > 0.999) {\n                uv = (pos.xz - 0.5) * vec2(1, -1) + 0.5;\n                face = 4;\n            } else {\n                uv = pos.xz;\n                face = 5;\n            }\n            \n            vec3 color = COLORS[block];\n            \n            color -= texture(iChannel1, floor(cell) / 32.0).rrr * 0.2;\n            float diffuse = max(dot(normal, SUN), 0.1);\n            fragColor.rgb = color * (diffuse + AMBIENT);\n            return;\n        }\n        lastCell = cell;\n    }\n    \n}","name":"Image","description":"","type":"image"}]}