{"ver":"0.1","info":{"id":"mlyBzz","date":"1701776338","viewed":68,"name":"vt220 by sprash3 FORK","username":"smlk0","description":"just playing around","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","retro","screen","crt","font","terminal","multipass","curved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"vt220 coding at night edition\" by sprash3. https://shadertoy.com/view/XdtfzX\n\n#define WIDTH 0.48\n#define HEIGHT 0.3\n#define CURVE 3.0\n#define SMOOTH 0.004\n#define SHINE 0.66\n\n#define BEZEL_COL vec4(0.8, 0.8, 0.6, 0.0)\n\n#define REFLECTION_BLUR_ITERATIONS 5\n#define REFLECTION_BLUR_SIZE 0.04\n\nprecision highp float;\n\nvec2 CurvedSurface(vec2 uv, float r)\n{\n    return r * uv/sqrt(r * r - dot(uv, uv));\n}\n\nvec2 crtCurve(vec2 uv, float r, bool content, bool shine)\n{\n    r = CURVE * r;\n    //if (iMouse.z > 0.) r *= exp(0.5 - iMouse.y/iResolution.y);\n    uv = (uv / iResolution.xy - 0.5) / vec2(iResolution.y/iResolution.x, 1.) * 2.0;\n\tuv = CurvedSurface(uv, r);\n\tif(content) uv *= 0.5 / vec2(WIDTH, HEIGHT);\n    uv = (uv / 2.0) + 0.5;        \n   \t//if(!shine) if (iMouse.z > 0.) uv.x -= iMouse.x/iResolution.x - 0.5;\n    \n\treturn uv;    \n}\n\nfloat roundSquare(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// standard roundSquare\nfloat stdRS(vec2 uv, float r)\n{\n    return roundSquare(uv - 0.5, vec2(WIDTH, HEIGHT) + r, 0.05);\n}\n\n// Calculate normal to distance function and move along\n// normal with distance to get point of reflection\nvec2 borderReflect(vec2 p, float r)\n{\n    float eps = 0.0001;\n    vec2 epsx = vec2(eps,0.0);\n    vec2 epsy = vec2(0.0,eps);\n    vec2 b = (1.+vec2(r,r))* 0.5;\n    r /= 3.0;\n    \n    p -= 0.5;\n    vec2 normal = vec2(roundSquare(p-epsx,b,r)-roundSquare(p+epsx,b,r),\n                       roundSquare(p-epsy,b,r)-roundSquare(p+epsy,b,r))/eps;\n    float d = roundSquare(p, b, r);\n    p += 0.5;\n    return p + d*normal;\n}\n\nvoid mainImage(out vec4 c, in vec2 fragCoord) {    \n \n    c = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec2 uvC = crtCurve(fragCoord, 1., true, false); \t// Content Layer\n    vec2 uvS = crtCurve(fragCoord, 1., false, false);\t// Screen Layer\n    vec2 uvE = crtCurve(fragCoord, 1.25, false, false);\t// Enclosure Layer\n      \n    const float ambient = 0.2;\n\n    // Ambient\n\tc += max(0.0, ambient - 0.3*distance(uvS, vec2(0.5,0.5))) *\n\t        smoothstep(SMOOTH, -SMOOTH, stdRS(uvS, 0.0));\n        \n\t// Inner Border               \n\tc += BEZEL_COL * ambient * 0.7 *\n\t        smoothstep(-SMOOTH, SMOOTH, stdRS(uvS, 0.0)) * \n\t        smoothstep(SMOOTH, -SMOOTH, stdRS(uvE, 0.05));\n    \n\t// Corner\n\tc -= (BEZEL_COL )* \n\t        smoothstep(-SMOOTH*2.0, SMOOTH*10.0, stdRS(uvE, 0.05)) * \n\t        smoothstep(SMOOTH*2.0, -SMOOTH*2.0, stdRS(uvE, 0.05));\n\n\t// Outer Border\n\tc += BEZEL_COL * ambient *\n\t       \tsmoothstep(-SMOOTH, SMOOTH, stdRS(uvE, 0.05)) * \n\t        smoothstep(SMOOTH, -SMOOTH, stdRS(uvE, 0.15)); \n    \n\t// Inner Border Reflection\n\tfor(int i = 0; i < REFLECTION_BLUR_ITERATIONS; i++) {\n\t    \tvec2 uvR = borderReflect(uvC + (vec2(rand(uvC+float(i)), rand(uvC+float(i)+0.1))-0.5)*REFLECTION_BLUR_SIZE, 0.05);\n\t    \tc += (PHOSPHOR_COL - BEZEL_COL*ambient) * texture(iChannel0, uvR) / float(REFLECTION_BLUR_ITERATIONS) * \n\t\t        smoothstep(-SMOOTH, SMOOTH, stdRS(uvS, 0.0)) * \n\t\t\t\tsmoothstep(SMOOTH, -SMOOTH, stdRS(uvE, 0.05));\n\t}\n    \n    // Bloom using composed MipMaps\n\tc += (textureLod(iChannel0, uvC, 3.) + \n              textureLod(iChannel0, uvC, 4.) + \n              textureLod(iChannel0, uvC, 5.))\n            * smoothstep(0., -SMOOTH*20., stdRS(uvS, -0.02)) * 0.5;\n\n    if (uvC.x > 0. && uvC.x < 1. && uvC.y > 0. && uvC.y < 1.)\n    \tc += texture(iChannel0, uvC);\n} ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define FONT_SIZE vec2(10.,20.)\n#define ROWCOLS vec2(80., 24.)\n\n// Some Plasma stolen from dogeshibu for testing\nfloat feed(vec2 uv)\n{\n    uv /= iResolution.xy;\n    uv *= ROWCOLS; // 80 by 24 characters\n    uv = ceil(uv);\n    uv /= ROWCOLS;\n    vec4 texColor = texture(iChannel0, uv);\n    return texColor.r * 17.0;\n}\n\n// Font Rendering\n// Can be done much better in the future...\n#define l(y,a,b) roundLine(p, vec2(float(a), float(y)), vec2(float(b), float(y)))\nfloat roundLine(vec2 p, vec2 a, vec2 b) \n{\n\tb -= a + vec2(1.0,0.);\n\tp -= a;\n    float f = length(p-clamp(dot(p,b)/dot(b,b),0.0,1.0)*b);\n\tif (iResolution.y < 320.) // attempt to get rid of aliasing on small resolution\n\t\treturn smoothstep(1.0, 0.9, f);    \n    else if (iResolution.y < 720.)\n\t\treturn smoothstep(0.75, 0.5, f);    \n\telse\n\t\treturn smoothstep(1., 0., f);    \n}\n\nfloat vt220Font(vec2 p, float c)\n{\n    if (c < 1.) return 0.;\n    if(p.y > 16.){\n        if(c > 2.) return 0.0;\n\t\tif(c > 1.) return l(17,1,9);\n    }\n    if(p.y > 14.){\n\t\tif(c > 16.) return l(15,3,8);\n\t\tif(c > 15.) return l(15,1,8);\n\t\tif(c > 14.) return l(15,1,3)+ l(15,7,9);\n\t\tif(c > 13.) return l(15,2,8);\n\t\tif(c > 12.) return l(15,1,9);\n\t\tif(c > 11.) return l(15,2,8);\n\t\tif(c > 10.) return l(15,1,3)+ l(15,6,8);\n\t\tif(c > 9.) return l(15,4,6);\n        if(c > 8.) return l(15,2,4)+ l(15,5,7);\n\t\tif(c > 7.) return l(15,2,8);\n\t\tif(c > 6.) return l(15,2,8);\n\t\tif(c > 5.) return l(15,2,8);\n\t\tif(c > 4.) return l(15,2,9);\n\t\tif(c > 3.) return l(15,1,8);\n\t\tif(c > 2.) return l(15,2,9);\n    }\n    if(p.y > 12.){\n\t\tif(c > 16.) return l(13,2,4)+ l(13,7,9);\n\t\tif(c > 15.) return l(13,2,4)+ l(13,7,9);\n\t\tif(c > 14.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 13.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 12.) return l(13,1,3);\n\t\tif(c > 11.) return l(13,4,6);\n\t\tif(c > 10.) return l(13,2,4)+ l(13,5,9);\n\t\tif(c > 9.) return l(13,2,8);\n\t\tif(c > 8.) return l(13,2,4)+ l(13,5,7);\n\t\tif(c > 7.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 6.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 5.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 4.) return l(13,1,3)+ l(15,2,9);\n\t\tif(c > 3.) return l(13,1,4)+ l(13,7,9);\n\t\tif(c > 2.) return l(13,1,3)+ l(13,6,9);\n    }\n    if(p.y > 10.){\n\t\tif(c > 16.) return l(11,1,3);\n\t\tif(c > 15.) return l(11,2,4)+ l(11,7,9);\n\t\tif(c > 14.) return l(11,1,9);\n\t\tif(c > 13.) return l(11,7,9);\n\t\tif(c > 12.) return l(11,2,5);\n\t\tif(c > 11.) return l(11,4,6);\n\t\tif(c > 10.) return l(11,3,5)+ l(11,6,8);\n\t\tif(c > 9.) return l(11,4,6)+ l(11,7,9);\n\t\tif(c > 8.) return l(11,1,8);\n\t\tif(c > 7.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 6.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 5.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 4.) return l(11,1,3);\n\t\tif(c > 3.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 2.) return l(11,2,9);\n    }\n    if(p.y > 8.){\n\t\tif(c > 16.) return l(9,1,3);\n\t\tif(c > 15.) return l(9,2,8);\n\t\tif(c > 14.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 13.) return l(9,4,8);\n\t\tif(c > 12.) return l(9,4,8);\n\t\tif(c > 11.) return l(9,4,6);\n\t\tif(c > 10.) return l(9,4,6);\n\t\tif(c > 9.) return l(9,2,8);\n\t\tif(c > 8.) return l(9,2,4)+ l(9,5,7);\n\t\tif(c > 7.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 6.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 5.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 4.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 3.) return l(9,1,4)+ l(9,7,9);\n\t\tif(c > 2.) return l(9,7,9);\n    }\n    if(p.y > 6.){\n\t\tif(c > 16.) return l(7,1,3);\n\t\tif(c > 15.) return l(7,2,4)+ l(7,7,9);\n\t\tif(c > 14.) return l(7,2,4)+ l(7,6,8);\n\t\tif(c > 13.) return l(7,5,7);\n\t\tif(c > 12.) return l(7,7,9);\n\t\tif(c > 11.) return l(7,2,6);\n\t\tif(c > 10.) return l(7,2,4)+ l(7,5,7);\n\t\tif(c > 9.) return l(7,1,3)+ l(7,4,6);\n\t\tif(c > 8.) return l(7,1,8);\n\t\tif(c > 7.) return l(7,2,8);\n\t\tif(c > 6.) return l(7,2,8);\n\t\tif(c > 5.) return l(7,2,8);\n\t\tif(c > 4.) return l(7,2,8);\n\t\tif(c > 3.) return l(7,1,8);\n\t\tif(c > 2.) return l(7,2,8);\n    }\n    if(p.y > 4.){\n\t\tif(c > 16.) return l(5,2,4)+ l(5,7,9);\n\t\tif(c > 15.) return l(5,2,4)+ l(5,7,9);\n\t\tif(c > 14.) return l(5,3,7);\n\t\tif(c > 13.) return l(5,6,8);\n\t\tif(c > 12.) return l(5,1,3)+ l(5,7,9);\n\t\tif(c > 11.) return l(5,3,6);\n\t\tif(c > 10.) return l(5,1,5)+ l(5,6,8);\n\t\tif(c > 9.) return l(5,2,8);\n\t\tif(c > 8.) return l(5,2,4)+ l(5,5,7);\n\t\tif(c > 7.) return 0.;\n\t\tif(c > 6.) return 0.;\n\t\tif(c > 5.) return 0.;\n\t\tif(c > 4.) return 0.;\n\t\tif(c > 3.) return l(5,1,3);\n\t\tif(c > 2.) return 0.;\n    }\n    if(p.y > 2.){\n\t\tif(c > 16.) return l(3,3,8);\n\t\tif(c > 15.) return l(3,1,8);\n\t\tif(c > 14.) return l(3,4,6);\n\t\tif(c > 13.) return l(3,1,9);\n\t\tif(c > 12.) return l(3,2,8);\n\t\tif(c > 11.) return l(3,4,6);\n\t\tif(c > 10.) return l(3,2,4)+ l(3,7,9);\n\t\tif(c > 9.) return l(3,4,6);\n\t\tif(c > 8.) return l(3,2,4)+ l(3,5,7);\n\t\tif(c > 7.) return l(3,2,4)+ l(3,6,8);\n\t\tif(c > 6.) return l(3,1,3)+ l(3,4,7);\n\t\tif(c > 5.) return l(3,2,4)+ l(3,6,8);\n\t\tif(c > 4.) return 0.;\n\t\tif(c > 3.) return l(3,1,3);\n\t\tif(c > 2.) return 0.;\n    }\n    else{\n\t\tif(c > 7.) return 0.;\n\t\tif(c > 6.) return l(1,2,5)+ l(1,6,8);\n    }\n    return 0.0;      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float val = 0.;\n    \n   \tvec2 uv = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n   \tvec2 uvT = vec2(80, 24) * FONT_SIZE * uv / iResolution.xy;\n   \tvec2 uvG = floor(ROWCOLS * uv / iResolution.xy);\n    \n\tfragColor = vt220Font(uvT - uvG * FONT_SIZE, feed(fragCoord.xy)) * PHOSPHOR_COL;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PHOSPHOR_COL vec4(0.2, 1.0, 0.2, 0.)\n\nprecision highp float;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n","name":"Common","description":"","type":"common"}]}