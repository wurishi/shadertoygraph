{"ver":"0.1","info":{"id":"4lXyz8","date":"1503343430","viewed":121,"name":"Simple Raymarcher With Shadows","username":"Assossa","description":"Simple raymarcher with shadows\n\nCamera ray code from https://www.shadertoy.com/view/XlBXWR","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxRender = 10e4; // Max distance to ray march\nconst float epsilon = 0.001; // Margin of error\nconst vec3 light = vec3(1.5, 1.5, -1.5); // Light position\nconst vec3 up = vec3(0, 1, 0);\n\n// Spheres\nint sphereCount = 2;\nvec3 sphereCenters[2];\nfloat sphereRadius[2];\nfloat floorHeight = -2.0;\n\n// Find distance between sphere and ray\nfloat sphereDistance(vec3 p, vec3 center, float radius) {\n    return distance(p, center) - radius;\n}\n\n// Find normal of sphere from hit location\nvec3 sphereNormal(vec3 p, vec3 center) {\n    return normalize(p - center);\n}\n\n// Get the hit location for a sphere and ray\nfloat sphereHit(vec3 o, vec3 d, vec3 center, float radius) {\n    // Keep track of the distance we have traveled\n    float dist = 0.0;\n    \n    // Kill the marching if we go too far\n    while(dist <= maxRender) {\n        // Get distance to sphere\n        float tempDist = sphereDistance(o, center, radius);\n        \n        // Add it to our distance counter and update the ray origin\n        dist += tempDist;\n        o += d * tempDist;\n        \n        // If we hit a sphere, then return the hit\n        if(tempDist <= epsilon) return dist;\n    }\n    \n    // We didn't hit anything\n    return -1.0;\n}\n\n// Get the hit for the floor\nfloat floorHit(vec3 o, vec3 d, float height) {\n    float du = dot(d, up);\n    if(du == 0.0) return -1.0;\n    \n    float dist = dot(vec3(0, height, 0) - o, up) / du;\n    if(dist < 0.0) return -1.0;\n    \n    return dist;\n}\n\nvec2 findHit(vec3 origin, vec3 ray, int ignore) {    \n    // Find a hit\n    float hit = maxRender;\n    int hitID = -1;\n    \n    for(int i = 0; i < sphereCount; i++) {\n        if(i == ignore) continue;\n    \tfloat tempHit = sphereHit(origin, ray, sphereCenters[i], sphereRadius[i]);\n        if(tempHit < hit  && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = i;\n        }\n    }\n    \n    if(ignore != -1) {\n        // Check for hit with floor\n        float tempHit = floorHit(origin, ray, floorHeight);\n        if(tempHit < hit && tempHit >= 0.0) {\n            hit = tempHit;\n            hitID = -1;\n        }\n    }\n    \n    return vec2(hit == maxRender ? -1.0 : hit, hitID);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Create ray for current pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 0.0, -3.0);\n    \n    // Initialize the spheres\n    sphereCenters[0] = vec3(0.0);\n    sphereCenters[1] = vec3(cos(iTime) * 1.8, sin(iTime) * 1.8, -0.8);\n    sphereRadius[0] = 1.0;\n    sphereRadius[1] = 0.5;\n    \n    // Find a hit\n    vec2 tempHit = findHit(origin, ray, -10);\n    float hit = tempHit.x;\n    int hitID = int(tempHit.y);\n    \n    // If no hit, then use the sky color\n    if(hit < 0.0) {\n        fragColor = vec4(0.3, 0.5, 0.7, 1.0);\n        return;\n    }\n    \n    // Find hit point & light direction\n    vec3 hitPoint = origin + (ray * hit);\n    vec3 lightDir = normalize(light - hitPoint);\n    \n    // Find if we need a shadow\n    vec2 shadowHit = findHit(hitPoint, lightDir, hitID);\n    float shadow = shadowHit.y >= 0.0 ? 0.5 : 0.0;\n    \n    // Find the normal of the sphere and the diffuse lighting from the normal\n    vec3 nml = hitID == -1 ? vec3(0, 1, 0) : sphereNormal(hitPoint, sphereCenters[hitID]);\n    float diffuse = max(dot(nml, lightDir) + 0.4 - shadow, 0.0) * 0.95;\n    \n    fragColor = vec4(vec3(diffuse), 1.0);\n}","name":"Image","description":"","type":"image"}]}