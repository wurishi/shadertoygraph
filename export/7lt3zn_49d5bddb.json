{"ver":"0.1","info":{"id":"7lt3zn","date":"1635631011","viewed":100,"name":"Shader royale@inercia 2021 entry","username":"Exca","description":"My entry to the point of dropping out for inercia 2021 shader royale.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","twister"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat fft = 0.0;\nfloat ffts = 0.0;\nfloat ffti = 0.0;\nfloat beat = 0.0;\nfloat beatstep = 0.0;\n\nvec3 repeat( vec3 p, vec3 c)\n{\n  vec3 q = vec3(0.0);\n  vec3 q2 = mod( p+ 0.5*c,c)-0.5*c;\n  return q2;\n}\n\nvec3 rotate( vec3 p, float x, float y, float z){\n  mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  \n  return rotx*roty*rotz*p;\n}\n\n\n\nvec3 smoothUnion(vec3 a, vec3 b, float k)\n{\n  float h = clamp(0.5 + 0.5*(b.x-a.x)/k,0.0, 1.0);\n  float d = mix(b.x,a.x,h)-k*h*(1.0-h);\n  float s = step(a.x, b.x);\n  return vec3(d, mix(a.y, b.y, s),0.0);\n}\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize(target-cam);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  \n  return normalize( forward*fov + right*uv.x + up*uv.y);\n}\n\nfloat sphere( vec3 p, float r){\n  return length(p)-r;\n}\n\nfloat roundcube( vec3 p, vec3 b, float r){\n  vec3 d = abs(p)-b;\n  return min( max( d.x, max( d.y, d.z) ), 0.0)+length(max(d,0.0))-r;\n}\n\nfloat ground( vec3 p, float h){\n  return p.y -h;\n}\nvec3 Union(vec3 a, vec3 b){\n  return a.x < b.x ? a : b;\n}\n\nvec3 map( vec3 p ){\n  \n  vec2 id = floor(p.xz/8.0+0.5);\n  \n  vec3 cp = rotate(\n    repeat(p, vec3(8.0, 0.0, 8.0)), \n    sin(p.y*0.1)*0.2, \n    ffts*sin(id.y+id.x+ ffti*4.0+ iTime+p.y+ffti*5.0)*2.0+sin(iTime*0.33+p.y-ffti*2.0)*4.0+ffti*5.0, \n    cos(p.y*0.1)*0.2 \n\n  );\n  vec3 c = vec3( roundcube(cp, vec3(0.4, 29.0, 0.4), 0.2), 1.0, 0.0);\n  \n  float h1 = texture(iChannel0, p.xz*0.1+vec2(iTime*0.01-ffti*0.25, iTime*0.015)).r*0.5* (0.5+fft*1.0);\n  float h2 = texture(iChannel0, p.xz*0.1+vec2(iTime*0.015+0.17*ffti, -iTime*0.015)).r*0.5 * (0.25+ffts*2.0);\n  \n  float h = mix(h1,h2,0.5);\n  \n  vec3 gr = vec3( ground(p, h*2.0), 2.0, h);\n  \n  return smoothUnion(c,gr,2.5);\n  \n  return vec3(sphere(p, 0.5), 1.0, 0.0);\n}\nvec3 normal( vec3 p ){\n  vec3 c = map(p);\n  vec2 e = vec2( 0.1, 0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x);\n}\n\nfloat diffuse( vec3 p , vec3 l, vec3 n){\n  return max(0.0, dot(n, normalize(l-p)));\n}\n\nvec3 march(vec3 cam, vec3 rd, out vec3 p, out float t)\n{\n  for(int i = 0; i < 100; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t+=r.x;\n    if(r.x < 0.01){\n      return r;\n    }\n    if(t > 50.0){\n      t = 50.0;\n      return vec3(-1.0);\n    }\n  }\n  t = 50.0;\n  return vec3(-1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 col = vec3(1.0);\n  \n  // Disabled ffts&i as no continous/smooth one\n  fft = texture(iChannel1, vec2(0.25,0.5)).r*0.25;\n  ffts = fft*0.0;\n  ffti = fft*0.0;\n  //ffts = texture(iChannel1, vec2(0.25,0.5)).r;\n  ///ffti = texture(iChannel1, vec2(0.25,0.5)).r;\n  \n  beat = floor(iTime*1.45);\n  beat = mod( beat/4.0, 8.0);\n  beatstep = fract( iTime*2.0);\n  \n  float travel = 3.0;\n  \n  float time = iTime*0.2;\n  \n  vec3 cam = vec3(\n    sin(time)*6.,\n    2. + cos(time),\n    cos(time)*6.+time\n  );\n  vec3 target = vec3(\n    0.0, \n    1.5+  cos(time*0.5), \n    time + cos(time*4.0)\n  );\n  vec3 light = vec3( sin(iTime)+5.0, 4.0, time+sin(time));\n  float fov = 0.5;\n  \n  \n  if(beat < 2.0){\n    uv*= sin(uv);\n  }\n  else if(beat < 4.0){\n    uv *= 1.0 + sin(uv.x*20.0 + time)*0.2 + cos(uv.y*20. + time)*0.2;\n  }\n  else if(beat < 6.0){\n    uv *= 1.0 - sin(uv.x*20.0 + time)*0.2 - cos(uv.y*20. - time)*0.2;  \n  }\n  \n  \n  vec3 rd = getcam( cam, target, uv, fov);\n  \n  \n  \n  vec3 p = vec3(0.0);\n  vec3 res = march( cam, rd, p, travel);\n  \n  vec3 n = normal(p);\n  if(res.y < 0.5){\n    // Bg\n  }\n  else if(res.y < 1.5){\n    //ground mat\n    col = vec3(0.0,0.7,0.9)*diffuse(p, light, n);\n  }\n  else if(res.y < 2.5){\n    //twister\n    float ly = abs(sin((p.y+iTime)*10.0));\n    col = mix(vec3(0.0,0.7,0.9), vec3(1.0, 0.7, 0.0), res.z*0.5)*diffuse(p, light, n);\n    col += smoothstep(1.0, 4.0, p.y)*(0.5/ly);\n  }\n  \n  col = mix( col, vec3(0.0,0.45,0.90), smoothstep( 10.0, 20.0, travel));\n  \n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}