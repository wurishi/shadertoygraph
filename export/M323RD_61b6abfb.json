{"ver":"0.1","info":{"id":"M323RD","date":"1708276038","viewed":285,"name":"ENORD Explorer","username":"Kali","description":"The robot of my shader from ENORD 6kb intro by LIA. https://www.shadertoy.com/view/fdd3Dl \nThis was an early WIP. Inspired by The Explorer 4k intro by the great Virgill.\nMouse enabled","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","volumetriclight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float t,det=.005, maxdist=100.,lidist=0., drohit=0., roadhit=0., coneinside=0.,drofract, drodist, drocone, droroty, drorotx;\nvec3 from, dronedir, dronepos, licolor=vec3(1.,.85,.7), mcolor=vec3(0.,1.,0.);\nvec2 uv;\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat3 lookat(vec3 dir, vec3 up) \n{\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 path(float t)\n{\n    float s=sin(t*.1),c=cos(t*.05);\n    vec3 p=vec3(vec2(s*s,c*c*c)*5.,t);\n    p.y+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\n    return p;\n}\n\nfloat fractal(vec2 p, float anim, int iter)\n{\n    p=abs(10.-mod(p,20.))-10.;\n    float ot=1000.;\n    for (int i=0; i<iter; i++)\n    {\n        p=abs(p)/clamp(p.x*p.y,.25,1.)-2.;\n        ot=min(ot,abs(p.y)+.7*anim*fract(abs(p.x)*.1+iTime*.5+float(i)*.25));\n        \n    }\n    ot=exp(-5.*ot);\n    return ot;\n}\n\nfloat box(vec3 p, vec3 l)\n{\n    vec3 c=abs(p)-l;\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat kset(vec3 p)\n{\n    float m=100.;\n    p=fract(p*.2);\n    for (int i=0; i<5;i++)\n    {\n        p=abs(p)/dot(p,p)-.8;\n        m=min(m,abs(length(p)-2.));\n    }\n    return exp(-1.*m);\n}\n\n\n\nfloat road(vec3 p)\n{\n    mat2 rot1=rot(p.z*.01);\n    mat2 rot2=rot(radians(-30.*sign(p.y)));\n    p.y=-abs(p.y)-3.;\n    float z=p.z;\n    float d=p.y+3.;\n    p.z=mod(p.z,10.)-5.;\n    float der=1., sc=1.5;\n    float m=100.;\n    for (int i=0; i<5; i++)\n    {\n        p=abs(p);\n        p=p-1.;\n        p.xz*=rot1;\n        p.yz*=rot1;\n        p.xy*=rot2;\n    }\n    d=max(d, -box(p,vec3(5.,5.,20.)));\n    return d*.6;\n}\n\nfloat lightcone(vec3 p)\n{\n    p-=dronepos;\n    p=lookat(dronedir,vec3(0.,1.,0.))*p;\n    return 1.;\n}\n\n\n\nfloat de(vec3 p)\n{\n    vec3 p2=p;\n    p-=dronepos;\n    p=lookat(dronedir,vec3(0.,1.,0.))*p;\n    p.xz*=rot(drorotx);\n    p.yz*=rot(droroty);\n    vec3 p3=p;\n    drocone=max(length(p.xy)+p.z*.25+.3,p.z+2.8);\n    p.yz*=rot(-droroty*step(1.15,abs(p.x)));\n    drofract=fractal(p.xy*.5,0.,4);\n    float dro=length(p)-3.+pow(drofract,.1)*.3;\n    dro=max(dro,-length(p+vec3(0.,0.,3.))+.6);\n    p.x=abs(abs(p.x)-1.1)-.1;\n    dro=max(dro,-abs(p.x)+.07)*.6;\n    p=p3;\n    p.z+=2.;\n    float drolight=length(p)-.5;\n    p=p2;\n    p.xy-=path(p.z).xy;\n    float roa=road(p);\n    float d=min(dro,drolight);\n    drocone=max(drocone,-roa+.1);\n    d=min(d,drocone);\n    d=min(d,roa+.2);\n    drohit=step(dro,d);\n    roadhit=step(roa,d);\n    coneinside=step(drocone,d);\n    lidist=.1/(.002+drolight*drolight*2.);\n    //dronefract+=lidist*5.;\n    if (coneinside>.5 && d<.1) return clamp(abs(d),.2,.25);\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(0.,det);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat st=.05;\n\tfloat ao=0.;\n    for(float i=0.; i<6.; i++ ) {\n        float td=st*i*i;\n        float d=de(p+n*td);\n        ao+=max(0.,(td-d)/td);\n    }\n    return clamp(1.-ao*.3,0.,1.);\n}\n\n\nvec3 shade(vec3 p)\n{\n    vec3 n=normalize(p-dronepos);\n    p.xy-=path(p.z).xy;\n    float c=0.;\n    if(coneinside<.5) c+=(fractal(p.xy,1.,6)*abs(n.z)+fractal(p.xz,1.,6)*abs(n.y)+fractal(p.yz,1.,6)*abs(n.x));\n    c=max(coneinside*.05,c*(1.-drohit)+drohit*drofract*.5); // optimizar\n    c=c*(1.-drohit)+drohit*drofract*.5; // optimizar\n    //c+=.1/(.2+abs(drocone))*roadhit;\n    return vec3(c*c,c,c*c*c);\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float lion=1.;\n    vec3 p, col=vec3(0.),cl=col;;\n    float dl=0.;\n    float d, td=0.,f,foff;\n    float h=(.5-hash(gl_FragCoord.xy+iTime*10.))*.2;\n    //lion=step(.5,fract(iTime*10.))+.5;\n    for (int i=0; i<100; i++)\n    {\n        p=from+td*dir;\n        d=de(p)*(1.+h);\n        if (d<det || td>maxdist) break;\n        td+=d;\n        f=smoothstep(.2,.3,abs(.5-fract(t*.015-p.z*.005)));\n        f=1.;\n        det*=1.+td*.00*(1.-f);\n        col+=shade(p)/(2.+d*d*30.)*exp(-.001*td*td)*(1.-f)*step(1.,td)*.5;\n        //dl+=lidist;\n        foff=exp(-.2*distance(p,dronepos));\n        cl+=coneinside/(1.+d*d)*mix(mcolor,licolor,f)*foff;\n    }\n//    licolor.xy*=rot(floor(t*.2)*.3);\n//    licolor=normalize(abs(licolor));\n    if (d<.1) {\n        float fade=exp(-.0001*td*td*td);\n    //todo: reflejar en el frente del dron el color de la luz\n//        float fr=pow(drofract,.3);\n//        float li=lidist;\n//        float dhit=drohit;\n        //float fcol=kset(p)*.2;\n        vec2 e=vec2(0.,.2);\n        vec3 n=normal(p);\n        float camli=max(0.,dot(dir,-n));\n        vec3 cuadp=fract(p*2.);\n        float cuad=smoothstep(.1,.0,min(cuadp.z,min(cuadp.x,cuadp.y)));\n        //cuad=1.;\n        col+=camli*(.3+cuad*.2)*fade*f*roadhit*mix(vec3(1.),licolor,lion);\n        col+=f*drohit*.2*camli;\n        //g+=n*exp(-.002*td*td)*(1.-drohit);\n        float fr=pow(drofract,.3);\n        col-=f*smoothstep(.8,.9,fr)*drohit*.2;\n        col+=f*smoothstep(.31,.3,fr)*drohit*.2;\n        //float ns = dot(n,normal(p+e.yxx));\n        //ns += dot(n,normal(p+e.xyx));\n        //ns += dot(n,normal(p+e.xxy));\n        //col+=smoothstep(3.,2.,ns)*f*(1.-drohit)*licolor*fade*licolor*camli*2.;\n        col+=.5/(.0+drocone)*licolor*f*roadhit*lion*foff;\n        col+=smoothstep(10.,0.,drocone)*licolor*roadhit*f*lion*3.*foff;\n        if (roadhit>.5) col=mix(col,col*max(ao(p,n),max(0.,1.-drocone*.15)),f);\n    } \n    return col+cl*lion*.07+lidist*(.01+lion)*licolor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s=sin(iTime*.25), c=cos(iTime*.5);\n    if (iMouse.z<.1) {\n        drorotx=s*s*s*s*s*2.;\n        droroty=c*c*c;\n    } else {\n        droroty=(iMouse.y/iResolution.y-.5)*4.;\n        drorotx=(iMouse.x/iResolution.x-.5)*5.;\n    }\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    uv*=1.5;\n    if (abs(uv.y)<1.){\n    t=iTime*7.;\n    from=path(t+18.)+vec3(5.,0.,0.);\n    vec3 adv=path(t+1.);\n    dronepos=path(t+10.);\n    vec3 droneadv=path(t+12.);\n    dronedir=dronepos-droneadv; \n    //dronedir.yz*=droroty;\n    vec3 dir=normalize(vec3(uv,.7));\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\n    //from.xz*=rot(t);\n    //dir.xz*=rot(t);\n    \n    vec3 col=march(from, dir);\n    \n    // Output to screen\n    fragColor=vec4(col,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}