{"ver":"0.1","info":{"id":"XlBcWz","date":"1508153017","viewed":104,"name":"Merging heat zones","username":"Fading_Pixel","description":"Two \"Heat Zones\" that merge as they get closer. The equation for it is :\nmin(min(distance(zone1,p),distance(zone2,p)),(distance(zone1,p)*distance(zone2,p))/strength)-size ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPSILON = 0.001;\nint MAX_STEPS = 100;\nfloat MAX_DIST = 100.0;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat boxSDF(vec3 p, vec3 size, float r) {\n    vec3 d = abs(p) - (size / 2.0) + r;\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance - r;\n}\n\nfloat sphereSDF(vec3 p, float size) {\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    float strength = 10.0;\n    float size = 1.0;\n    vec3 zone1 = vec3(vec2(sin(iTime*0.5)*3.0),0.0);\n    vec3 zone2 = vec3(vec2(sin(iTime*0.5)*-3.0),0.0);\n    float sdf = min(min(distance(zone1,p),distance(zone2,p)),(distance(zone1,p)*distance(zone2,p))/strength)-size;\n    return sdf;\n}\n\nfloat March(vec3 Dir, vec3 eye) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + (Dir*depth));\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 interp(vec3 a,vec3 b,float t) {\n    return a + ((b-a)*t);\n}\n\nvec3 Light(vec3 p, vec3 eye, vec3 Amb, vec3 Diff, vec3 Spec) {\n    float IntensitySpec = 0.4;\n    float IntensityDiff = 0.4;\n    float shine = 10.0;\n    vec3 source = vec3(sin(2.0*iTime)*5.0,cos(2.0*iTime)*5.0,0.0);\n    //source = vec3(0.0,0.0,0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(source - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float millis = iTime*25.0;\n    vec3 color = vec3(sin(millis/10.0)*127.0+127.0,sin(millis/10.0+85.0)*127.0+127.0,sin(millis/10.0+175.0)*127.0+127.0);\n    //Amb = interp(N,Amb,(1.0+cos(iTime))/2.0);\n    Amb = color / 255.0;\n    vec3 col = Amb * 0.5;\n    if (dot(L,N) < 0.0) {\n        return col;\n    }\n    if (dot(R,V) < 0.0) {\n        col += (Diff * IntensityDiff * dot(L,N));\n        return col;\n    }\n    col += (Diff * IntensityDiff * dot(L,N));\n    col += (Spec * pow(dot(R,V),shine));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(sin(iTime)*5.0,cos(iTime)*5.0,6.5);\n    //eye = vec3(0.0,0.0,6.5);\n    vec3 center = vec3(0.0,0.0,0.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n    mat3 Matrix = viewMatrix(eye,center,up);\n    vec3 dir = rayDirection(90.0,iResolution.xy,fragCoord);\n    float mDist = March(Matrix * dir,eye);\n    vec3 point = eye + (mDist * (Matrix * dir));\n    vec3 light = Light(point, eye, vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0));\n    if (mDist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    fragColor = vec4(light, 1.0);\n}","name":"Image","description":"","type":"image"}]}