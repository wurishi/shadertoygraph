{"ver":"0.1","info":{"id":"4tKGzc","date":"1475920698","viewed":475,"name":"Stable Flow","username":"huwb","description":"Left - 2 phase flow, all pixels with the same anim phase. Right - the phase offset varies per-pixel along flow to yield a more stable appearance. Cycle counts used to break up repetition over time. LMB: texture weights.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["flow","advection","2phase"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT license, copyright Huw Bowles 2018\n\n// 2 phase flow with 'stationary' blend weights\n\n// based on flow work published by max & becker: http://www.heathershrewsbury.com/dreu2010/wp-content/uploads/2010/07/FlowVisualizationUsingMovingTextures.pdf\n// which was popularised in cg and extended by vlachos: http://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf .\n// shout out to Filip Strugar who independently invented it: http://vertexasylum.com/2010/10/30/gpu-based-water-simulator-thingie/\n\n// flow is used to advect a texture through a velocity field perpetually. to avoid\n// large distortion, the texture coordinates are reset periodically. to hide the reset/jump,\n// 2 samples are taken from the texture, and weighted such that the weight is 0 when the\n// texture coordinates reset.\n\n// the weight looks like the below for texture sample 1 and 2 (T1 and T2)\n\n// weight\n// |\n// |\\T1   /\\T2   /\n// | \\   /  \\   /\n// |  \\ /    \\ /\n// |   X      X   ...\n// |  / \\    / \\\n// | /   \\  /   \\\n// |/     \\/     \\\n//-----------------\n//      time\n\n// this is shown on the left hand side of the render.\n\n// the phase (horizontal shift on the time axis) is a free variable. the left side of the render\n// shows the result when the phase is 0 for all pixels - all texture samples blend in and out\n// together which gives the noticeable pulsing effect. vlachos address this by using a world space\n// phase offset.\n\n// i started to experiment with this phase - this is effected by offsetting time before computing\n// the samples/weights. this offset varies across the pixels in the direction of texture flow, \n// so that transition in texture weights move with the texture and help to hide phasing. click\n// to see the weights visualised, and to see the motion produced by the time offset on the RHS.\n\n// this phase shift should increase along the path of the flow. for this shader, the flow is\n// computed as the derivative of a noise texture, so the integral is the noise value itself. in\n// other scenarios this integral may be harder to compute.\n\n// the phase shift produces a compression, similar to a doppler effect. this can be corrected\n// by scaling the texture coordinates - see the commented out code around uv_scl below. i choose\n// not to do this in this shader so that the LHS and RHS show corresponding texture features and\n// demonstrate the difference.\n\n// another trick i found is to jump the texture coordinate at the end of each animation cycle.\n// roll2() returns a counter for each sample's animation and can be used to offset uvs.\n\n// tex sample with smoothstep interpolation\nvec4 texturess( vec2 uv );\n\n// flow code - rolling texture samples. this will produce the graph in the header above. params:\n// in: time\n// out: two displacement values in [-1,1) for the two texture samples (multiply these values by surface velocity to get texture coordinate offset)\n// out: weight for each texture sample - graph above\n// out: anim cycle counter for each sample\nvoid roll2( float t, out vec2 v, out vec2 a, out vec2 cycleCount)\n{\n    vec2 phase = t + vec2(0.0, 0.5);\n    v = fract(phase);\n    cycleCount = phase - v;\n    a = 1.0 - 2.0 * abs( v - 0.5 );\n    v = 2.*v - 1.; // put in [-1,1) \n}\n\nvec2 GetFlow( vec2 texcoord, out float phase, out float speed )\n{\n    vec2 eps = vec2(.125/256.,0.);\n    float scl = 85.;\n    texcoord.x += 10.5;\n    float noise = texturess(texcoord/scl).x;\n    float noiseX_ = texturess(texcoord/scl-eps.xy).x;\n    float noiseX = texturess(texcoord/scl+eps.xy).x;\n    float noiseY_ = texturess(texcoord/scl-eps.yx).x;\n    float noiseY = texturess(texcoord/scl+eps.yx).x;\n    \n    speed = .5;\n    phase = noise;\n    \n    return normalize(vec2(noiseX-noiseX_,noiseY-noiseY_));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // preamble\n    vec2 texcoord = fragCoord.xy / iResolution.xy;\n    bool STATIONARY = texcoord.x > .5;\n    // make sure same function is lerped on both sides\n    if( texcoord.x < .5 ) texcoord.x += .5;\n    texcoord.x *= iResolution.x/iResolution.y;\n    \n    float phase;\n    float speed;\n    vec2 dir = GetFlow( texcoord, phase, speed );\n    \n    // use stationary flow? LHS vs RHS\n    phase = STATIONARY ? phase : 0.;\n    float amp = 0.125;\n    \n    // 2 phase rolling offset and weight\n    vec2 disp, wts, cycles;\n    roll2( iTime*speed + phase, disp, wts, cycles );\n    disp *= amp;\n    \n    // optional - this will help adjust the texture scale for the stationary version, which\n    // can produce some compression\n    float uv_scl = 1.;\n    //if( STATIONARY ) uv_scl = 0.5;\n    \n    // take two texture samples. use cycle count to offset UVs to break up patterns over time.\n    vec2 cycleOffset = vec2(0.1, 0.07);\n    vec3 s0 = texture( iChannel0, uv_scl*(1.19 + texcoord + disp.x*dir) + cycleOffset*cycles.x ).xyz;\n    vec3 s1 = texture( iChannel0, uv_scl*(1.19 + texcoord + disp.y*dir) + cycleOffset*(cycles.y+1.0) ).xyz;\n\n    // result is blend of two samples using rolling weights (ascii diagram above)\n    fragColor.xyz = mix( s0, s1, wts.y );\n    \n    fragColor = smoothstep(0.,1.,fragColor);\n    fragColor.x *= 1.4;\n    fragColor.y *= 1.1;\n    \n    // show weights if mouse clicked\n    if( texcoord.y < iMouse.y/iResolution.y )\n    {\n        vec3 wtcol = smoothstep(0.0,1.,pow(vec3(wts.x,wts.y,0.),vec3(1.)));\n        fragColor.rgb = mix(fragColor.rgb, wtcol, .5);\n    }\n    \n    // very important black bars to make the experience much more cinematic\n    fragColor *= fragCoord.y < iResolution.y/9. ? 0. : 1.;\n    fragColor *= fragCoord.y > (iResolution.y*8./9.) ? 0. : 1.;\n    fragColor *= abs(fragCoord.x-iResolution.x/2.)<1.5 ? 0. : 1.;\n}\n\n// use smoothstep to make noise c2 smooth\nvec4 texturess( vec2 uv )\n{\n    //return texture( iChannel0, uv, -10.0 );\n    \n    vec2 x = uv * 256. - .5;\n    vec2 f = fract(x);\n    \n    // remove fractional part\n    x -= f;\n    \n    // apply smoothstep to fractional part\n    f = f*f*(3.0-2.0*f);\n    \n    // reapply fractional part\n    x += f;\n    \n    uv = (x+.5) / 256.;\n    \n    return texture( iChannel1, uv );\n}\n","name":"Image","description":"","type":"image"}]}