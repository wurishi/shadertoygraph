{"ver":"0.1","info":{"id":"4Xl3RX","date":"1707763971","viewed":99,"name":"MyTower","username":"gest","description":"No comments","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n\t#define texture2D texture\n\t#define textureCube texture\n\t#define u_texture0 iChannel0\n\t#define u_texture1 iChannel1\n\t#define u_textureCube0 iChannel0\n\t#define u_textureCube1 iChannel1\n#endif\n\n#define SUPER_GRAPHIC_CARD\n\n#ifdef SUPER_GRAPHIC_CARD\n\t#define SOFT_SHADOW\n#endif\n\nfloat time;\n#define FAR 200.\n#define ID_NONE -1.\n#define ID_HOUSE 1.\n#define ID_STAIRS 2.\n#define ID_VASE 3.\n#define ID_BALL 4.\nvec3 sunDir;\n\nfloat sdBox( vec3 p, vec3 b ) { \n\tvec3 d = abs(p) - b;   \n\treturn length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); \n}\n\n//https://www.shadertoy.com/view/NddfRl\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n ) {\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n\t#if 1\n\t\tfloat dia = length(wh);\n\t\tp = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n\t\tfloat lid = clamp(floor(p.x/dia+0.5),0.0,n-1.0);\n\t\tp.x = p.x - lid*dia;\n\t\tp = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n\t#else\n\t\tfloat dia2 = dot(wh,wh);\n\t\tp = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n\t\tfloat lid = clamp(floor(p.x/dia2+0.5),0.0,n-1.0);\n\t\tp.x = p.x - lid*dia2;\n\t\tp = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n\t#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat dfStairs(vec3 p, vec4 sizeSteps, float countSteps) {\n\tfloat d = sdStairs(p.xy, sizeSteps.xy, countSteps )*0.8;\n\tfloat d_bet = TF_BETWEEN(p.z, sizeSteps.z);\n\td = AND(d, d_bet);\n\t\n\tTF_ROTATE(p.xy, PI - atan(sizeSteps.y, sizeSteps.x));\n\tfloat d_cut = TF_AFTER(p.y, sizeSteps.w);\n\td = AND(d, - d_cut);\n\t\n\treturn d;\n}\n\nfloat glow = 0.;\nbool calcGlow = true;\n\nfloat map(vec3 p, inout Object object) {\t\n\tvec3 q;\n\tfloat d;\n\n\tconst float countSteps = 10.;\n\tconst vec4 sizeSteps = vec4(1.0, 0.5, 2., 0.4);\n\t\n\tobject = Object(FAR, ID_NONE, p);\n\t\n\tObject HOUSE = Object(FAR, ID_HOUSE, p);\n\t{\n\t\tq = p;\n\t\td = TF_BOX2D(q.xz, vec2(10));\n\t\td = abs(d) - 1.;\n\t\t//TF_REPLICA(q.y, 10.);\n\t\tTF_REPLICA(q.y, countSteps * sizeSteps.y * 2.);\n\t\tTF_TRANSLATE(q.y, -5.);\n\t\tTF_REPLICA_ANGLE(q.xz, 4.,0.);\n\t\tfloat d_cut = AND( TF_BOX_ROUND(q.xy, vec2(0, 2.), 6.), TF_AFTER(q.y, 0.) );\n\t\td = AND(d, -d_cut);\n\t\tHOUSE.distance = d;\n\t}\n\tobject = OR(object, HOUSE);\n\n\tfor (float i = 0.; i<4.; i++) {\n\t\tq = p;\n\t\tTF_ROTATE(q.xz, (2.*PI)/4.*i);\n\t\tTF_TRANSLATE(q, vec3(\n\t\t\t-countSteps * sizeSteps.x * 0.5,\n\t\t\tcountSteps * sizeSteps.y*i,\n\t\t\t7.\n\t\t));\n\t\tTF_REPLICA(q.y, countSteps * sizeSteps.y * 4.);\n\t\t\t\n\t\tObject STAIRS = Object(FAR, ID_STAIRS, q);\n\t\t{\n\t\t\td = dfStairs(q, sizeSteps, countSteps);\n\t\t\tfloat d_box = TF_BOX3D(q - vec3(-2.,0,0), vec3(2,0.5,2));\n\t\t\td = OR(d, d_box);\n\t\t\tSTAIRS.distance = d*0.8;\n\t\t}\n\t\tobject = OR(object, STAIRS);\n\t\t\n\t\tObject VASE = Object(FAR, ID_VASE, q);\n\t\t{\n\t\t\tfloat r = 0.5 + 0.3*cos(q.y*3.5);\n\t\t\tTF_TRANSLATE(q.xz, vec2(-3.,1.));\n\t\t\td = TF_BALL(q.xz, r);\n\t\t\td = abs(d) - 0.02;\n\t\t\td = AND(d, TF_BETWEEN2(q.y, 0., 2.));\n\t\t\tVASE.distance = d*0.7;\n\t\t\tVASE.position = q;\n\t\t}\n\t\tobject = OR(object, VASE);\n\n\t\tObject BALL = Object(FAR, ID_BALL, q);\n\t\t{\n\t\t\td = TF_BALL(q - vec3(0,4,0), 0.0);\n\t\t\tBALL.distance = d;\n\t\t}\n\t\tobject = OR(object, BALL);\n\t\t\n\t\tif (calcGlow) glow += 1.3/pow(BALL.distance, 2.);\n\t}\n\t\n    return object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps) {   \n    vec2 e = vec2(eps, 0);\n    return normalize(map(p) - vec3(\n\t\tmap(p-e.xyy),\n\t\tmap(p-e.yxy),\n\t\tmap(p-e.yyx)\n\t));\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps;\n\tfor (float i = 0.; i < 200.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = abs(ray.object.distance) < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps = i + 1.;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nfloat softShadow( Ray ray, float k ) {\n    float shade = 1.0;\n    ray.distance = ray.near;    \n\tfloat steps = 1.;\n    for ( int i = 0; i < 50; i++ ) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n        ray.object.distance = map(ray.position);\n        shade = min( shade, smoothstep( 0.0, 1.0, k * ray.object.distance / ray.distance)); \n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += min( ray.object.distance, ray.far / ray.steps * 2. ); \n        if (ray.distance > ray.far ) break; \n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n    return min( max( shade, 0.0 ) + 0.2, 1.0 ); \n}\n\nvec3 SkyCol (vec3 ro, vec3 rd, vec3 sunDir) {\n\tfloat sd = clamp (dot(sunDir, rd), 0., 1.);\n\t//vec3 skyCol = mix(vec3(1), vec3 (0.5, 0.75, 1.), rd.y+0.2);\n\tvec3 skyCol = mix(vec3 (0.5, 0.75, 1.), vec3(1), rd.y+0.2);\n\tvec3 col = skyCol;\n\tcol += 0.5 * vec3 (1., 0.4, 0.2) * pow (sd, 256./2.);\n\tcol += 0.5 * vec3 (1., 0.8, 0.7) * pow (sd, 1024./2.);\n\treturn col;\n}\n\nvec3 lighting(Ray ray, vec3 lightDir, vec3 m_color) {\n\tfloat sh = 1.;\n\t#ifdef SOFT_SHADOW\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin = ray.position;\n\t\t\tray1.direction = lightDir;\n\t\t\tray1.steps = 30.;\n\t\t\tray1.far = 10.;\n\t\t}\n\t\tsh = softShadow(ray1, 10.);\n\t#endif\n\tfloat back = max (dot (ray.normal, - normalize (vec3 (lightDir.x, 0., lightDir.z))), 0.);\n\tfloat diff = max (dot(lightDir, ray.normal), 0.0);\n\tfloat spec = pow (clamp(dot(normalize((ray.direction + lightDir) / 2.0), ray.normal), 0.0, 1.0),64.);\n\treturn m_color * (0.2 + 0.2*back + sh*0.8*diff) + sh*0.9*spec;\n}\n\n//https://www.shadertoy.com/view/Mtf3zM\nfloat Brick (vec2 p) {\n\tvec2 q = p / vec2 (2., 1.);\n\tif (mod(floor(q.y), 2.)==0.) q.x += 0.5;\n\tq = smoothstep (0.02, 0.04, abs (fract (q + 0.5) - 0.5));\n\treturn q.x*q.y;\n}\nfloat Brick (vec3 p, vec3 n) {\n\tvec3 b = vec3(Brick(p.zy), Brick(p.xz), Brick(p.xy));\n\treturn dot(b,n);\n}\n\nfloat Square (vec2 p) {\n\tvec2 q = p;\n\tq = smoothstep (0.02, 0.04, abs (fract (q + 0.5) - 0.5));\n\treturn q.x*q.y;\n}\nfloat Square (vec3 p, vec3 n) {\n\tvec3 b = vec3(Square(p.zy), Square(p.xz), Square(p.xy));\n\treturn dot(b,n);\n}\n\nvec3 getMaterial (Ray ray) { \n\tvec3 q = ray.object.position;\n\tvec3 p = ray.position;\n\tvec3 n = ray.normal;\n\tvec3 m_color = vec3(1); \n\n\tif (ray.object.id==ID_HOUSE) {\n\t\tm_color = vec3 (0.5, 0.4, 0.3);\n\t\tp /= 1.0;\n\t\tm_color *= Brick(p, abs(n));\n\t} else if (ray.object.id==ID_STAIRS) {\n\t\tm_color = vec3 (0.9, 0.3, 0.2);\n\t\tp /= 1.0;\n\t\tif (n.y>0.) m_color *= Square(p, abs(n));\n\t} else if (ray.object.id==ID_VASE) {\n\t\tm_color = SkyCol (ray.origin, reflect(ray.direction, n), sunDir);\n\t}\n\n\treturn m_color;    \n}\n\nvec3 Render(Ray ray) {  \n\tcalcGlow = true;\n\tfloat steps = rayMarch(ray);\n\t\n\tvec3 col;\n\n\tif (ray.distance<ray.far) {   \n\t\tcalcGlow = false;\n        ray.normal = mapNormal(ray.position, 0.001);\n\t\tif (ray.object.id==ID_VASE) {\n\t\t\tvec3 q = ray.object.position;\n\t\t\tTF_REPLICA_ANGLE(q.xz, 12., 0.);\n\t\t\tTF_ROTATE(ray.normal.xz, 0.5 * PI * q.x/length(q.xz));\n\t\t}\n\t\tvec3 m_Color = getMaterial(ray);\n\t\tvec3 lightDir = sunDir;\n\t\tcol = lighting(ray, lightDir, m_Color);\n\t\t\n\t\t//Туман\n\t\tconst float fogStart = 25.;\n\t\tconst vec3 fogColor = vec3(2);\n\t\tcol = mix(col, fogColor, clamp((ray.distance-fogStart)/(ray.far-fogStart), 0., 1.));\n    } else {\n    \tcol = SkyCol (ray.origin, ray.direction, sunDir);\n\t}\n\t\n\tcol += 0.06 * glow * vec3 (1., 0.4, 0.2);\n\tcol = pow(col, vec3(1./2.2));\n   \treturn col;\n}\n\nfloat smoothTime (float timeStart, float timeStop, float time) {\n\t#if 0\n\t\t//С задержкой\n\t\treturn smoothstep(timeStart, timeStop, time);\n\t#else\n\t\t//Без задержки\n\t\treturn (time - timeStart) / (timeStop - timeStart);\n\t#endif\n}\n\nstruct PathSector {\n\tvec3 posA, posB;\n\tfloat timeA, timeB;\n};\n\nvec3 Path(float time) {\n\tfloat id = floor(time/16.+0.5);\n\ttime = mod(time, 16.);\n\tvec3 p1 = vec3(-7., id*20. +  0.,  7);\n\tvec3 p2 = vec3( 7., id*20. +  5.,  7);\n\tvec3 p3 = vec3( 7., id*20. + 10., -7);\n\tvec3 p4 = vec3(-7., id*20. + 15., -7);\n\tvec3 p5 = vec3(-7., id*20. + 20.,  7);\n\t\n\tvec3 pos;\n\t\n\t#if 1\n\t\tconst int sectors = 4;\n\t\tPathSector s[sectors];\n\t\ts[0] = PathSector(p1, p2, 0., 4.);\n\t\ts[1] = PathSector(p2, p3, 4., 8.);\n\t\ts[2] = PathSector(p3, p4, 8., 12.);\n\t\ts[3] = PathSector(p4, p5, 12., 16.);\n\t\t\n\t\tfor (int i=0; i<sectors; i++) {\n\t\t\tif (time<s[i].timeB) {\n\t\t\t\t//Линейная функция Безье\n\t\t\t\tpos = mix(s[i].posA, s[i].posB, smoothTime(s[i].timeA, s[i].timeB, time));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t#else\n\t\tif (time<4.0) {\n\t\t\tpos = mix(p1, p2, smoothTime(0., 4., time));\n\t\t} else if(time<8.0) {\n\t\t\tpos = mix(p2, p3, smoothTime(4., 8., time));\n\t\t} else if(time<12.0) {\n\t\t\tpos = mix(p3, p4, smoothTime(8., 12., time));\n\t\t} else if(time<16.0) {\n\t\t\tpos = mix(p4, p5, smoothTime(12., 16., time));\n\t\t}\n\t#endif\n\tpos.y += 3.;\n\treturn pos;\n}\n\nvoid main() {  \n\ttime = u_time*1.;\n\t\n\tfloat aspect = u_canvas.x/u_canvas.y;\n\tvec2 uv = gl_FragCoord.xy/u_canvas.xy;\n\tuv = uv - 0.5;\n\n\tvec2 mouse = u_mouse.xy / u_canvas.xy - 0.5;\n\tif (u_mouse.xy==vec2(0)) mouse = vec2(0);\n\t\n    vec2 ori = vec2(\n        u_mouse.z==0. ? radians(10.)/* + sin(time)*PI/4.*/ : radians(10.) + mouse.y*PI*2.,\n        u_mouse.z==0. ? 0./*cos(time)*PI/8.*/ : mouse.x*PI*2.\n    );\n\tori.x = clamp(ori.x, -PI/2., PI/2.);\n\t//ori.x = clamp(ori.x, -PI/2., 0.);\n\n\tCamera cam;\n\t{\n\t\tcam.fov     = 60. ;\n\t\tcam.aspect\t= aspect;\n\t\tcam.origin  = Path(time - 1.);\n\t\tcam.target\t= Path(time + 1.);\n\t\tcam.target.y = cam.origin.y;\n\t\tcam.up \t\t= vec3(0, 1, 0);\n\t\tcam.vMat \t= TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t\tcam.tMat\t= mat3(1);//TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t}\n\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= FAR;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 150.;\n\t}\n\n\tsunDir = normalize (vec3(0,20,-30));\n\t\n\tvec3 col= Render(ray);\n\t\n\tgl_FragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\tmat3 vMat, tMat;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n\tmat3 pMat, uMat;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec3 \tposition;\t//Координатв поверхности объекта\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\t\t//\"+\" -колебание в найденной точке, \"-\"\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor\t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right*cam.aspect + uv.y * cam.up;\n\tcam.pMat \t\t= mat3(cam.right, cam.up, cam.forward);\n\tvec3 u \t\t\t= - cam.forward.y * cam.forward;\n\tfloat f \t\t= 1. / sqrt (1. - cam.forward.y * cam.forward.y);\n\tcam.uMat \t\t= mat3 (\n\t\tf * vec3 (- cam.forward.z, 0., cam.forward.x), \n\t\tf * vec3 (u.x, 1. + u.y, u.z), \n\t\tvec3 (cam.forward.x, cam.forward.y, cam.forward.z)\n\t);\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.tMat * cam.origin;\n\t\tray.direction \t= cam.tMat * normalize( cam.pMat * cam.vMat * vec3(uv.x*cam.aspect, uv.y, cam.factor));\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n//-------------------функции трансформации и позиционирования объектов сцены\n//Допустимая ошибка (для удаления артефактов) 1./min(u_canvas.x, u_canvas.y)\nfloat EPS = 0.3;\n//Функция расстояния до фигуры со скругленными ребрами (объединение и сглаживание с увеличением на R)\n//float d - сглаживание фигуры\n//vec2 d - объединение и сглаживание двух фигур\n//vec3 d - объединение и сглаживание трех фигур\n//vec4 d - объединение и сглаживание четырех фигур\n#define TF_ROUND(d, R) (length(max(d, 0.)) - (R))\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2) со скругленными ребрами\n//Функция расстояния до капсулы, если два размера 0\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-(S), R)\n#define TF_BOX_ROUND1(p, S, R) TF_ROUND(abs(p)-(S) + R, R)\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2)\n#define TF_BOX(p, S) TF_BOX_ROUND(p, S, EPS)\n//#define TF_BOX(p, S) TF_ROUND(abs(p) - (S) - EPS, EPS)\n#define TF_BOX1(p, S) TF_BOX_ROUND(p, S, 0.)\n#define TF_BOX3D(p, S) max(abs((p).x)-(S).x, max(abs((p).y)-(S).y, abs((p).z)-(S).z))\n#define TF_BOX2D(p, S) max(abs((p).x)-(S).x, abs((p).y)-(S).y)\n//Функция расстояния до шара (p vec3) или круга (p vec2)\n#define TF_BALL(p, R) TF_ROUND(abs(p), R)\n//Эллипс\n#define TF_ELLIPSE3D(p, r) min ((r).x, min((r).y, (r).z)) * TF_BALL(p/(r), 1.)\n#define TF_ELLIPSE2D(p, r) min ((r).x, (r).y) * TF_BALL(p/(r), 1.)\n//Функция расстояния до пространства ДО p1\n#define TF_BEFORE(p, p1) p - (p1)\n#define TF_BEFORE1(p, p1) TF_ROUND(p - (p1) + EPS, EPS)\n//Функция расстояния до пространства ПОСЛЕ p1\n#define TF_AFTER(p, p1) TF_ROUND(-p + (p1) + EPS, EPS)\n//Функция расстояния до симметричного пространства МЕЖДУ -p1 и +p1\n//#define TF_BETWEEN(p, p1) TF_ROUND(abs(p) - (p1) + EPS, EPS)\n#define TF_BETWEEN(p, p1) abs(p) - (p1)\n//Функция расстояния до несимметричного пространства МЕЖДУ p1 и p2\n//#define TF_BETWEEN2(p, p1, p2) TF_ROUND( abs(p - 0.5*(p1+p2)) - 0.5*(p2-p1) + EPS, EPS)\n#define TF_BETWEEN2(p, p1, p2) abs(p - 0.5*((p1)+(p2))) - 0.5*((p2)-(p1))\n//Перемещение пространства p (float p...vec4 p)\n#define TF_TRANSLATE(p, d) p -= d;\n//Масштаб\n#define TF_SCALE(p, s) p /= s\n//Вращение пространства p (vec2 p)\n#if 0\n\t#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p\n#else\n\t#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)\n#endif\n#define TF_ROTATE_MAT2(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TF_ROTATE_X(a) mat3(1.0,    0.0, 0.0,       0.0, cos(a), -sin(a),   0.0, sin(a), cos(a))\n#define TF_ROTATE_Y(a) mat3(cos(a), 0.0, -sin(a),   0.0, 1.0, 0.0,   \t    sin(a), 0.0, cos(a))\n#define TF_ROTATE_Z(a) mat3(cos(a), -sin(a), 0.0,   sin(a), cos(a), 0.0,   \t0.0, 0.0, 1.0)\n//Отражение пространства p (float p...vec4 p)\n#define TF_MIRROR(p, d) p = abs(p) - (d)\n//Разбиение пространства на повторяющиеся. Возвращает id центра ячейки\n//float p - пространство 1D\n//vec2 p - пространство 2D\n//vec3 p - пространство 3D\n#define TF_REPLICA(p, d) \\\n\tfloor((p)/(d) + 0.5);\\\n\tp = mod((p) + 0.5*(d), d) - 0.5*(d)\n//Разбиение пространства на повторяющиеся в диапазоне id от ida до idb включительно. Возвращает id центра ячейки\n#define TF_REPLICA_LIMIT(p, d, ida, idb) \\\n\tfloor((p)/(d) + 0.5);\\\n\tp = p-(d)*clamp(floor((p)/(d) + 0.5), ida, idb)\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p. Возвращает id сектора\t\n#if 0\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /n + off, 2.*PI)/(2.* PI /n));\\\n\t\tfloat _p_ = mod(atan(p.x, p.y) + PI /n + off, 2.* PI /n) - PI /n;\\\n\t\tp = length(p.xy) * vec2(sin(_p_),cos(_p_))\n#else\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /(n) + off, 2.*PI)/(2.* PI /(n)));\\\n\t\tTF_ROTATE(p.xy, -off);\\\n\t\tTF_ROTATE(p.xy, (2.* PI /(n)) * floor ( atan(p.x, p.y)/(2.* PI /(n)) + 0.5 ) )\n#endif\t\n\n//Возвращает для момента u_time номер отрезка времени 0,1,2...\n//      -------         -------\n//     |       |       |       |\n//_____|       |_______|       |\n#define TF_TIMER(u_time, intervalCount, intervalDuration) mod(floor(u_time/(intervalDuration)), (intervalCount))\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn min(distA, distB);\n\t//if (distB<distA) return distB; return distA;\n\t//return mix(distA, distB, step(distB, distA)); \n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn max(distA, distB);\n\t//if (distB>distA) return distB; return distA;\n\t//return mix(distA, distB, step(distA, distB)); \n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\n#if 0\n\tfloat AND( float distA, float distB, float k ) {\n\t\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\t\treturn mix( distB, distA, h ) + k*h*(1.-h);\n\t}\n#else\n\tfloat AND( float distA, float distB, float k ) {\n\t\treturn - OR (- distA, - distB, k);\n\t}\n#endif\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n\n//Сложение / Объединение / ИЛИ\n//object = OR(objectA, objectB)\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Сложение / Объединение / ИЛИ  \n//object = OR(objectA, objectB, k)\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Умножение / Пересечение / И\n//object = AND(objectA, objectB)\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Умножение / Пересечение / И\n//object = AND(objectA, objectB, k)\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\n//object = NOT(objectA)\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n","name":"Common","description":"","type":"common"}]}