{"ver":"0.1","info":{"id":"Nsf3Dl","date":"1617302150","viewed":408,"name":"slime simulation","username":"MarvelousBilly","description":"https://www.youtube.com/watch?v=X-iSQQgOd1A\n\nEdit: new, bad, hideous anti aliasing!","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["slime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = borders * fragCoord/iResolution.xy;\n    \n    vec3 col = texelFetch(iChannel0, ivec2(p), 0).xxx;\n    \n    vec3 sum = vec3(0.);\n    int scale = 3;\n    if(scale % 2 == 0){\n        scale --; //needs to be an odd number to work.\n    }\n    int scale2 = scale/2;\n    //wow! bad anti aliasing! amazing!\n    for(int offsetX = -scale2; offsetX <= scale2; offsetX ++){\n        for(int offsetY = -scale2; offsetY <= scale2; offsetY ++){\n            int sampleX = int(p.x) + offsetX;\n            int sampleY = int(p.y) + offsetY;\n            if(sampleX >= 0 && sampleX < int(borders.x) && sampleY >= 0 && sampleY < int(borders.y)){\n                sum += texelFetch(iChannel0, ivec2(sampleX,sampleY),0).rgb;\n            }\n        }\n    }\n    sum/=float(scale*scale);\n    //if(distance(vec2(x,y),borders/2.) > spread/2.){\n    //   col += vec3(0.1);\n    //}\n    fragColor = vec4(sum,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float numAgents = 5000.; //amount of agents\nfloat spread = 360.;  //spread of starting positions\nvec2 borders = vec2(640.,360.); //resolution of image (streched to fit screen)\n\nfloat pi = 3.14159;\nuint hash(int In){\n    uint state = uint(In);\n    state ^= 2747636419u;\n    state *- 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435792u;\n    return state;\n}\nfloat maxHash = 4294967295.;\n\n        \nfloat diffuseSpeed = 3.; //speed of diffusion\nfloat evapSpeed = 0.1; //speed of evaporation\n\nfloat moveSpeed = 1.; //movement speed of agents\nfloat turnSpeed = radians(30.9); //turning speed of agents\n\nfloat sensorAngleSpacing = 0.79; //radians apart from sensor in front of agent\nfloat sensOffset = 15.0; //units away from agent\nfloat sensorSize = 3.0; //size of sensor\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Agent {\n    vec2 pos;\n    float ang;\n};\n\n\nfloat randomAngle(int randomSeed){\n    float ang = float(randomSeed)/maxHash;\n    ang = ang * 2. * pi;\n    return ang;\n}\n\n\nfloat sense(Agent agent, float ang){\n    float sensAngle = agent.ang + ang;\n    vec2 sensDir = vec2(cos(sensAngle), sin(sensAngle));\n    vec2 sensCen = agent.pos + sensDir * sensOffset;\n    float sum = 0.;\n    \n    for(int offsetX = -int(sensorSize); offsetX <= int(sensorSize); offsetX ++){\n        for(int offsetY = -int(sensorSize); offsetY <= int(sensorSize); offsetY ++){\n        \n            vec2 pos = sensCen + vec2(offsetX, offsetY);\n            \n            if(pos.x >= 0. && pos.x < iResolution.x && pos.y >= 0. && pos.y < iResolution.y){\n                sum += texelFetch(iChannel1, ivec2(pos),0).x;\n\n            }\n        }\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float width = borders.x;\n    float height = borders.y;\n    \n    int index = int(fragCoord.y ) * int(width) + int(fragCoord.x);\n     //below highest point, and to the left of farthest right value on the the highest point's row\n     //or, just below highest point and index < numAgents\n    if( index <= int(numAgents) && fragCoord.y <= (numAgents)*width){\n        if(fragCoord.x >= numAgents){ return; }\n\n        if(iTime == 0. || iFrame == 0){ //setup\n        \n            int x = int(index);\n            \n            int h = int(hash(x));\n            \n            int randomDist = int(hash(x + h)); \n            float d = abs(float(randomDist) / maxHash)*spread;\n            float ang = randomAngle(int(hash(x)));\n\n            vec2 c = borders.xy / 2.;\n            vec2 newP = vec2(c.x + cos(ang) * d, c.y + sin(ang) * d); \n            fragColor = vec4(newP,ang-pi,1.);\n            return;\n        }\n\n        Agent agent;\n\n        vec4 p = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        agent.pos = p.xy;\n        agent.ang = p.z;\n        \n        int h = int(hash(int(fragCoord.x)));\n        int intoHash = int(agent.pos.y * width + agent.pos.x)+h;\n        uint random = hash(intoHash);\n\n\n        float wF = sense(agent, 0.);\n        float wL = sense(agent, sensorAngleSpacing);\n        float wR = sense(agent, -sensorAngleSpacing);\n        \n        float rSS = float(random) / maxHash;\n        \n        if(wF > wL && wF > wR){ //continue forward\n            agent.ang += 0.;\n        }\n        else if(wF < wL && wF < wR){ // turn randomly\n            agent.ang += (rSS - 0.5) * 2. * turnSpeed;\n        }\n        else if(wR > wL){\n            agent.ang -= rSS * turnSpeed;\n        }\n        else if(wL > wR){\n            agent.ang += rSS * turnSpeed;\n        }\n\n\n        vec2 dir = vec2(cos(agent.ang), sin(agent.ang));\n        vec2 newPos = agent.pos + dir * moveSpeed;\n\n        if(newPos.x < 0. || newPos.x >= borders.x || newPos.y < 0. || newPos.y >= borders.y){\n        //if(distance(newPos, borders/2.) > spread/2.){\n            newPos = agent.pos - dir * moveSpeed * iTimeDelta;\n            \n            \n            float ang = randomAngle(int(random));\n            agent.ang = ang;\n        }\n        agent.pos = newPos;\n\n        fragColor = vec4(agent.pos,agent.ang,1.0);\n    }\n    else{\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float width = borders.x;\n    float height = borders.y;\n\n    vec3 agent = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    if(iTime == 0.){\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n    float d = 1000.;\n    for(int i = 0; i < int(numAgents); i++){\n        vec2 indexPosition = vec2(mod(float(i),width), floor(float(i) / width));\n\n        vec2 Pgi = texelFetch(iChannel0, ivec2(indexPosition), 0).xy; //point given current i, is position stored in BufA\n        d = min(d, distance(Pgi, fragCoord));\n    }\n    vec4 oVal = texelFetch(iChannel1, ivec2(fragCoord.xy),0);\n    vec3 col;\n    if(d < 1.){\n        col = vec3(1.); //points of dots\n    }\n    else if(iTime != 0.){ //fade / dont clear bg\n        vec4 sum = vec4(0.);\n        \n        for(int offsetX = -1; offsetX <= 1; offsetX ++){\n            for(int offsetY = -1; offsetY <= 1; offsetY ++){\n                int sampleX = int(fragCoord.x) + offsetX;\n                int sampleY = int(fragCoord.y) + offsetY;\n                if(sampleX >= 0 && sampleX < int(iResolution.x) && sampleY >= 0 && sampleY < int(iResolution.y)){\n                    sum += texelFetch(iChannel1, ivec2(sampleX,sampleY),0);\n                }\n            }\n        }\n        vec4 blurResult = sum / 9.;\n        vec4 diffusedVal = mix(oVal, blurResult, diffuseSpeed * iTimeDelta);\n        vec4 diffusedAndEvapVal = max(vec4(0.), diffusedVal - evapSpeed * iTimeDelta);\n        col = vec3(diffusedAndEvapVal); \n    }\n    else{\n        col = vec3(0.);\n    }\n    fragColor = vec4(col,1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}