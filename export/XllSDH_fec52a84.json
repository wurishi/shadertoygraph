{"ver":"0.1","info":{"id":"XllSDH","date":"1436443604","viewed":311,"name":"aji's cornell box","username":"aji","description":"canonical raytracing, testing ray-shape intersections using equations, and reacting to the closest shape. no GI or AO unfortunately, extra credit for anybody who can add it","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// materials\n#define HORIZON 0\n#define LAMB_GRAY 1\n#define LAMB_BLUE 2\n#define LAMB_YELL 3\n#define MIRROR 4\n#define GLASS 5\n#define MIRROR_RED 6\n\n#define MAXDEPTH 20\n#define MAXSAMP 1\n#define MAXSAMPF 1.0\n\n#define IOR 1.14\n\n#define TAU 6.283185307179586\n\nfloat planeDist(vec3 p, vec3 n, vec3 p0, vec3 v)\n{\n    return dot(p - p0, n) / dot(v, n);\n}\n\nvoid plane(in vec3 p, in vec3 n, in int mymat, in vec3 p0, in vec3 v, inout int mat, inout float t, inout vec3 sn)\n{\n    if (dot(v, n) < 0.0) {\n        float myt = planeDist(p, n, p0, v);\n        vec3 at = abs(p0 + myt * v);\n        if (0.0 < myt && myt < t && max(at.x, max(at.y, at.z)) <= 1.00001) {\n            mat = mymat;\n            t   = myt;\n            sn  = n;\n        }\n    }\n}\n\nvoid sphere(in vec3 c, in float r, in int mymat, in vec3 p0, in vec3 v, inout int mat, inout float t, inout vec3 sn)\n{\n    vec3 diff = p0 - c;\n    float b = dot(v, diff);\n    float D = b*b - dot(diff, diff) + r*r;\n    if (D > 0.0) {\n        float sq = sqrt(D);\n        float myt = min(-b + sq, -b - sq);\n        if (0.0 < myt && myt < t) {\n            mat = mymat;\n            t   = myt;\n            sn  = normalize(p0 + v * myt - c);\n        }\n    }\n}\n\nvoid scene(in vec3 p0, in vec3 v, inout int mat, inout float t, inout vec3 sn)\n{\n    plane(vec3( 0.0, -1.0,  0.0), vec3( 0.0,  1.0,  0.0), LAMB_GRAY, p0, v, mat, t, sn);\n    plane(vec3( 0.0,  1.0,  0.0), vec3( 0.0, -1.0,  0.0), LAMB_GRAY, p0, v, mat, t, sn);\n    plane(vec3(-1.0,  0.0,  0.0), vec3( 1.0,  0.0,  0.0), LAMB_BLUE, p0, v, mat, t, sn);\n    plane(vec3( 1.0,  0.0,  0.0), vec3(-1.0,  0.0,  0.0), LAMB_YELL, p0, v, mat, t, sn);\n    plane(vec3( 0.0,  0.0, -1.0), vec3( 0.0,  0.0,  1.0), LAMB_GRAY, p0, v, mat, t, sn);\n    plane(vec3( 0.0,  0.0,  1.0), vec3( 0.0,  0.0, -1.0), LAMB_GRAY, p0, v, mat, t, sn);\n\n    sphere(vec3(0.4, -0.6 + 0.6 * abs(sin(3.0*iTime)), 0.4), 0.39, MIRROR, p0, v, mat, t, sn);\n    sphere(vec3(0.3, -0.6 + 0.5 * abs(sin(3.0*iTime + 1.0)), -0.6), 0.39, GLASS, p0, v, mat, t, sn);\n    sphere(vec3(-0.5, -0.6 + 0.55 * abs(sin(3.0*iTime + 2.0)), 0.0), 0.39, MIRROR_RED, p0, v, mat, t, sn);\n}\n\nvec3 lookat(vec3 p0, vec3 at, vec2 uv, float fov)\n{\n    vec3 v = normalize(at - p0);\n    float sin_el = v.y;\n    float cos_el = cos(asin(sin_el));\n    float sin_az = -v.x / cos_el;\n    float cos_az = -v.z / cos_el;\n    uv *= tan(radians(fov));\n    return normalize(vec3(\n         uv.x*cos_az + uv.y*sin_az*sin_el + v.x,\n                       uv.y       *cos_el + v.y,\n        -uv.x*sin_az + uv.y*cos_az*sin_el + v.z\n    ));\n}\n\nvec4 matColor(int mat)\n{\n    if      (mat == 1) return vec4(1.0, 1.0, 1.0, 1.0);\n    else if (mat == 2) return vec4(0.0, 0.5, 1.0, 1.0);\n    else if (mat == 3) return vec4(1.0, 0.2, 0.0, 1.0);\n    else if (mat == 4) return vec4(1.0, 1.0, 1.0, 1.0);\n    else               return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 directLight(vec3 p, int mat, vec3 sn)\n{\n    vec3 light = vec3(0.0, 0.5, 0.0);\n    vec3 lv = light - p;\n    float ld = length(lv);\n\n    lv = normalize(lv);\n\n    vec3 _sn;\n    int _mat;\n    float t = 10.0;\n    scene(p, lv, _mat, t, _sn);\n\n    float en;\n    if (t < ld) {\n        en = 0.3;\n    } else {\n        en = clamp(dot(lv, sn), 0.3, 1.0);\n    }\n\n    return en * matColor(mat) / (1.0 + ld * ld);\n}\n\nfloat noise(float x)\n{\n    return mod(14057.0*x + 12589.0*x*x + 88289.0*x*x*x + 103967.0*x*x*x*x, 1.0);\n}\n\nvec4 sampleray(vec3 p0, vec3 v)\n{\n    int mat;\n    float t;\n    vec3 sn;\n    vec4 color = vec4(1.0);\n\n    for (int depth=0; depth<MAXDEPTH; depth++) {\n        t = 10.0;\n        scene(p0, v, mat, t, sn);\n\n        if (mat == MIRROR) {\n            p0 = p0 + t * v + 0.001 * sn;\n            v = reflect(v, sn);\n        } else if (mat == MIRROR_RED) {\n            p0 = p0 + t * v + 0.001 * sn;\n            v = reflect(v, sn);\n            color *= vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (mat == GLASS) {\n            if (dot(v, sn) < 0.0) {\n                p0 = p0 + t * v - 0.001 * sn;\n                v = refract(v, sn, 1.0/IOR);\n            } else {\n                p0 = p0 + t * v + 0.001 * sn;\n                v = refract(v, sn, IOR);\n            }\n            color *= vec4(0.0, 1.0, 1.0, 1.0);\n        } else {\n            p0 = p0 + t * v + 0.001 * sn;\n            break;\n        }\n    }\n\n    return directLight(p0, mat, sn) * color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 p0 = vec3(\n        5.0 * cos(iTime * 0.5),\n        1.5 * sin(iTime * 0.2),\n        5.0 * sin(iTime * 0.5)\n    );\n    vec3 at = vec3(0.0);\n    vec3 v = lookat(p0, at, uv, 26.0);\n\n    fragColor = sampleray(p0, v);\n}\n\n","name":"Image","description":"","type":"image"}]}