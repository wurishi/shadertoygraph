{"ver":"0.1","info":{"id":"slc3Wj","date":"1636716658","viewed":76,"name":"Newton's Fractal 2","username":"kowalski_analytics","description":"You want to solve z⁵ + z² - z + 1 = 0, you know calc, you don't know factoring. Good news!\n\nYou just guess some x and improve!\na) find the linear approximation at x\nb) move to the x-intercept\nc) repeat!\n\nHowever, when the linear approximation is almo","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 200\n\nvec2 zoomC = vec2(-0.648705, 0.115672);\nfloat zoomrate = 2.;\n\n#define N 5\nvec2 roots[N] = vec2[N](vec2(-1,0), vec2(0,1), vec2(0,-1), vec2(0.7, 0.7), vec2(0.7,-0.7));\nvec3 colors[N] = vec3[N](vec3(1., .7, .7), vec3(1., .3, .3), vec3(1., 1., 0.), vec3(.3, .3, 1.), vec3(.7, 1., .7) );\n                        // pink, red, yellow, blue, green\n\nint closest(vec2 z){\n    int k = 0;\n    for (int i = 0; i < N; i++) {\n        if (length(z - roots[k]) > length(z - roots[i])) k = i;\n    }\n    return k;\n}\n\nvec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 div(vec2 a, vec2 b) {\n    float d = b.x * b.x + b.y * b.y;\n    if (d == 0.0) {\n        d = 0.001;\n    }\n    return vec2 (a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / d;\n}\n\nvec2 f(vec2 x) {\n    vec2 total = vec2(1.0, 0.0);\n    for (int i = 0; i < N; i++) {\n        total = mul(total, x - roots[i]);\n    }\n    return total;\n}\n\nvec2 f_deriv(vec2 x) {\n    vec2 total = vec2(0.0, 0.0);\n    for (int i = 0; i < N; i++) {\n        vec2 subtotal = vec2(1.0, 0.0);\n        for (int j = 0; j < N; j++) {\n            if (i != j) subtotal = mul(subtotal, x - roots[j]);\n        }\n        total += subtotal;\n    }\n    return total;\n}\n\nvec2 scale( vec2 x ) {\n    float zoom = exp(-zoomrate * iTime);\n    \n    x -= iResolution.xy/2.;\n    x /= iResolution.y;\n    x *= 2.;\n    \n    x *= zoom;\n    x += zoomC * (1. - zoom);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 z = scale(fragCoord);\n    vec4 m = vec4(scale(iMouse.xy), iMouse.zw);\n    \n    if ( m.z > 0.0 ) {\n        roots[0] = m.xy;\n    }\n    \n    for (int i = 0; i < ITERATIONS; i++) {\n        z -= div(f(z), f_deriv(z));\n    }\n    \n    fragColor = vec4(colors[closest(z)], 1.0);\n}","name":"Image","description":"","type":"image"}]}