{"ver":"0.1","info":{"id":"MltyDj","date":"1534203749","viewed":151,"name":"maycrash|Curvature - Hoffman1987","username":"theGiallo","description":"Curvature 6 measures from paper \"Segmentation and Classification of Range Images\" by R.Hoffman & A.K.Jain, 1987 (plus some more)","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["normal","curvature","hoffman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if !BEAUTIFUL_FLOATING_POINT_ART\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float H_SCALE = H_SCALE_EXPR;// */ 100.0;//0.01 + 500.0 * sin01( iTime * TAU / 2.0 );\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 p;\n    p.xy = fragCoord.xy;\n    vec2 uv = p.xy / iResolution.xy;\n    p.z = texture( iChannel0, uv, 0.0 ).r * H_SCALE;\n\n    // Output to screen\n    vec3 Np = texture( iChannel1, uv ).xyz;\n    \n    float kpq_avg = 0.0;\n    float kpq_min = 1e30;\n    float kpq_max = 0.0;\n    vec3  dir_min = vec3(0,0,0), dir_max = vec3(0,0,0);\n    float sign_avg = 0.0;\n    vec3 dir_by_kpq_avg = vec3(0.0);\n    vec3 dir_over_kpq_avg = vec3(0.0);\n    vec3 dir_by_abs_kpq_avg = vec3(0.0);\n    vec3 dir_over_abs_kpq_avg = vec3(0.0);\n    \n    for ( int j = WINDOW_MIN; j != WINDOW_MAX; ++j )\n    {\n    \tfor ( int i = WINDOW_MIN; i != WINDOW_MAX; ++i )\n    \t{\n            if ( i == 0 && j == 0 )\n            {\n                continue;\n            }\n            \n            vec3 q;\n            q.xy = p.xy + vec2(i,j);\n            vec2 uv_q = q.xy / iResolution.xy;\n  \t\t\tq.z = texture( iChannel0, uv_q, 0.0 ).r * H_SCALE;\n            vec3 Nq = texture( iChannel1, uv_q, 0.0 ).xyz;\n            vec3 dir = normalize( q - p );\n            #if 0\n            float t = 0.01;\n            vec3 dN = ( p + t * Np - ( q + t * Nq ) );\n            vec3 dp = q-p;\n            float s = sign( dot(dN,dN) - dot(dp,dp) );\n            #else\n            float t = 0.01;\n            vec3 dN = t * Np - dir - t * Nq;\n            float s = sign( dot(dN,dN) - 1.0 );\n            #endif\n            s = s == 0.0 ? 1.0 : s;\n            float kpq = distance(Np,Nq) / ( distance(p,q) * CURVATURE_SCALE ) * s;\n            sign_avg += s;\n\n            dir_by_kpq_avg += dir * kpq;\n            dir_over_kpq_avg += dir / kpq;\n            dir_by_abs_kpq_avg += dir * abs( kpq );\n            dir_over_abs_kpq_avg += dir / abs( kpq );\n\n            kpq_avg += kpq;\n            dir_min = abs( kpq_min ) < abs( kpq ) ?  dir_min : dir;\n            dir_max = abs( kpq_max ) > abs( kpq ) ?  dir_max : dir;\n            kpq_min = abs( kpq_min ) < abs( kpq ) ?  kpq_min : kpq;\n            kpq_max = abs( kpq_max ) > abs( kpq ) ?  kpq_max : kpq;\n        }\n    }\n    kpq_avg /= float(WINDOW_AREA);\n    sign_avg /= float(WINDOW_AREA);\n    dir_by_kpq_avg /= float(WINDOW_AREA);\n    dir_over_kpq_avg /= float(WINDOW_AREA);\n    dir_by_abs_kpq_avg /= float(WINDOW_AREA);\n    dir_over_abs_kpq_avg /= float(WINDOW_AREA);\n    \n    float kpq_mean = ( kpq_min + kpq_max ) * 0.5f;\n    float kpq_gauss = kpq_min * kpq_max;\n    float kpq_ratio = kpq_min / kpq_max;\n    \n    vec2 muv = iMouse.xy / iResolution.xy;\n    \n    fragColor.b = 0.0;\n    if ( length( muv - 0.5 ) < 0.025 )\n    {\n    \tfragColor.xyz = vec3(p.z)/H_SCALE;\n    } else\n    if ( length( muv - 0.5 ) < 0.05 )\n    {\n    \tfragColor.xyz = vec3(p.z)/H_SCALE;\n        fragColor.xyz = vec3( sign_avg*0.5 + 0.5 );\n    } else\n    if ( length( muv - 0.5 ) < 0.1 )\n    {\n        fragColor.xyz = rgb_from_dir( Np );\n    } else\n    if ( length( muv - 0.5 ) < 0.15 )\n    {\n    \tfragColor.xyz = Np * 0.5 + 0.5;\n    } else\n    {\n        if ( muv.x < 0.25 && muv.y < 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_avg );\n            fragColor.g = -min( 0.0, kpq_avg );\n        } else\n        if ( muv.x < 0.25 && muv.y >= 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_mean );\n            fragColor.g = -min( 0.0, kpq_mean );\n        } else\n        if ( muv.x < 0.5 && muv.y < 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_min ) * 10.0;\n            fragColor.g = -min( 0.0, kpq_min ) * 10.0;\n        } else\n        if ( muv.x < 0.5 && muv.y >= 0.5 )\n        {\n            fragColor.r = max( 0.0, kpq_max );\n            fragColor.g = -min( 0.0, kpq_max );\n        } else\n        if ( muv.x < 0.75 && muv.y < 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_ratio );\n            fragColor.g = -min( 0.0, kpq_ratio );\n        } else\n        if ( muv.x < 0.75 && muv.y >= 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_gauss ) * 500.0;\n            fragColor.g = -min( 0.0, kpq_gauss ) * 500.0;\n        } else\n        if ( muv.x < 0.875 && muv.y < 0.5 )\n        {\n            fragColor.rgb = rgb_from_dir( dir_min );\n        } else\n        if ( muv.x < 0.875 && muv.y >= 0.5 )\n        {\n            fragColor.rgb = rgb_from_dir( dir_max );\n        } else\n        if ( muv.x <= 1.0 && muv.y < 0.5 )\n        {\n            fragColor.rgb = rgb_from_dir( /*normalize*/( dir_by_kpq_avg ) );\n            //fragColor.rgb = rgb_from_dir( /*normalize*/( dir_by_abs_kpq_avg ) );\n        } else\n        if ( muv.x <= 1.0 && muv.y >= 0.5 )\n        {\n            fragColor.rgb = rgb_from_dir( dir_over_kpq_avg );\n           \t//fragColor.rgb = rgb_from_dir( dir_over_abs_kpq_avg );\n        }\n        //fragColor.rg *= 4.0;\n    }\n    fragColor.a = 1.0;\n}\n#endif\n\n#if BEAUTIFUL_FLOATING_POINT_ART\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float H_SCALE = /*H_SCALE_EXPR* */ 0.1 * sin( iTime * TAU / 20000000.0 );\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 p;\n    p.xy = fragCoord.xy;\n    vec2 uv = p.xy / iResolution.xy;\n    p.z = texture( iChannel0, uv, 0.0 ).r * H_SCALE;\n\n    // Output to screen\n    vec3 Np = texture( iChannel1, uv ).xyz;\n    \n    float kpq_avg = 0.0;\n    float kpq_min = 1e30;\n    float kpq_max = 0.0;\n    vec3  dir_min = vec3(0,0,0), dir_max = vec3(0,0,0);\n    float sign_avg = 0.0;\n    \n    for ( int j = WINDOW_MIN; j != WINDOW_MAX; ++j )\n    {\n    \tfor ( int i = WINDOW_MIN; i != WINDOW_MAX; ++i )\n    \t{\n            vec3 q;\n            q.xy = p.xy + vec2(i,j);\n            vec2 uv_q = q.xy / iResolution.xy;\n  \t\t\tq.z = texture( iChannel0, uv_q, 0.0 ).r * H_SCALE;\n            vec3 Nq = texture( iChannel1, uv_q, 0.0 ).xyz;\n            vec3 dir = normalize( q - p );\n            #if 0\n            float t = 0.01;\n            vec3 dN = ( p + t * Np - ( q + t * Nq ) );\n            vec3 dp = q-p;\n            float s = sign( dot(dN,dN) - dot(dp,dp) );\n            #else\n            float t = 0.01;\n            vec3 dN = t * Np - dir - t * Nq;\n            float s = sign( dot(dN,dN) - 1.0 );\n            #endif\n            s = s == 0.0 ? 1.0 : s;\n            float kpq = distance(Np,Nq) / ( distance(p,q) * CURVATURE_SCALE ) * s;\n            sign_avg += s;\n            \n            kpq_avg += kpq;\n            dir_min = abs( kpq_min ) < abs( kpq ) ?  dir_min : dir;\n            dir_max = abs( kpq_max ) > abs( kpq ) ?  dir_max : dir;\n            kpq_min = abs( kpq_min ) < abs( kpq ) ?  kpq_min : kpq;\n            kpq_max = abs( kpq_max ) > abs( kpq ) ?  kpq_max : kpq;\n        }\n    }\n    kpq_avg /= float(WINDOW_W);\n    sign_avg /= float(WINDOW_W);\n    \n    float kpq_mean = ( kpq_min + kpq_max ) * 0.5f;\n    float kpq_gauss = kpq_min * kpq_max;\n    float kpq_ratio = kpq_min / kpq_max;\n    \n    vec2 muv = iMouse.xy / iResolution.xy;\n    \n    fragColor.b = 0.0;\n    if ( length( muv - 0.5 ) < 0.05 )\n    {\n    \tfragColor.xyz = vec3(p.z)/H_SCALE;\n        fragColor.xyz = vec3( sign_avg*0.5 + 0.5 );\n    } else\n    if ( length( muv - 0.5 ) < 0.1 )\n    {\n    \tfragColor.xyz = Np * 0.5 + 0.5;\n        fragColor.xyz = rgb_from_dir( Np );\n    } else\n    {\n        if ( muv.x < 0.25 && muv.y < 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_avg );\n            fragColor.g = -min( 0.0, kpq_avg );\n        } else\n        if ( muv.x < 0.25 && muv.y >= 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_mean );\n            fragColor.g = -min( 0.0, kpq_mean );\n        } else\n        if ( muv.x < 0.5 && muv.y < 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_min ) * 10.0;\n            fragColor.g = -min( 0.0, kpq_min ) * 10.0;\n        } else\n        if ( muv.x < 0.5 && muv.y >= 0.5 )\n        {\n            fragColor.r = max( 0.0, kpq_max );\n            fragColor.g = -min( 0.0, kpq_max );\n        } else\n        if ( muv.x < 0.75 && muv.y < 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_ratio );\n            fragColor.g = -min( 0.0, kpq_ratio );\n        } else\n        if ( muv.x < 0.75 && muv.y >= 0.5 )\n        {\n            fragColor.r =  max( 0.0, kpq_gauss ) * 500.0;\n            fragColor.g = -min( 0.0, kpq_gauss ) * 500.0;\n        } else\n        if ( muv.y < 0.5 )\n        {\n            fragColor.rgb = rgb_from_dir( dir_min );\n        } else\n        if ( muv.y >= 0.5 )\n        {\n            fragColor.rgb = rgb_from_dir( dir_max );\n        }\n        fragColor.rg *= 4.0;\n    }\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Normals estimated by fitting a plane to a neighborhood of 5x5 pixels,\n// by least squares.\n// Red channel treated as height value of a heightmap.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float H_SCALE = H_SCALE_EXPR;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 p = texture( iChannel0, uv );    \n\n    vec2  A[] = vec2 [25](vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0),\n                          vec2(0),vec2(0),vec2(0),vec2(0),vec2(0)  );\n    float b[] = float[25](0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0,\n                          0.0,0.0,0.0,0.0,0.0  );\n\tfor ( int i = -2; i != 3; ++i )\n    {\n\t\tfor ( int j = -2; j != 3; ++j )\n    \t{\n\t\t\tvec2 p_c = fragCoord + vec2( i, j );\n\t\t\tvec2 p_uv = p_c / iResolution.xy;\n            vec4 p_v = texture( iChannel0, p_uv, 0.0 );\n            int I = i + 2;\n            int J = j + 2;\n            int idx = I * 5 + J;\n            vec3 v = vec3( -i, -j, p_v.r * H_SCALE );\n\t\t\tA[idx] = v.xy;\n            b[idx] = v.z - p.z * H_SCALE;\n    \t}\n    }\n    \n    mat2 AT_A = mat2(0);\n   \tfor ( int i = 0; i != 25; ++i )\n    {\n    \tfor ( int c = 0; c != 2; ++c )\n        {\n            for ( int r = 0; r != 2; ++r )\n    \t\t{\n\t\t        AT_A[c][r] += A[i][r] * A[i][c];\n\t\t\t}\n        }\n    }\n    \n    mat2 iAT_A = inverse( AT_A );\n\n\n    vec2 noz = vec2(0,0);// = inverse( AT_A ) * AT * b;\n    \n\tfor ( int i = 0; i != 25; ++i )\n    {\n        for ( int c = 0; c != 2; ++c )\n    \t{\n\t    \tfor ( int r = 0; r != 2; ++r )\n\t    \t{\n                noz[c] += iAT_A[c][r] * A[i][c] * b[i];\n            }\n        }\n    }\n    \n    vec3 n;\n    vec2 noz2 = noz * noz;\n    n.z = 1.0 / ( noz2.x + noz2.y + 1.0 );\n    n.xy = noz * n.z;\n    n = normalize( n );\n\tfragColor = vec4(n,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define KEY_SPACE 0x20\n#define KEY_V 86\n#define KEYBOARD_CHANNEL iChannel1\n#define KEYBOARD_TOGGLE(key) ( texelFetch( KEYBOARD_CHANNEL, ivec2(key,2),0 ).x > 0. )\n#define HAS_TO_SHOW_DEBUG_SPHERE KEYBOARD_TOGGLE( KEY_SPACE )\n#define VIDEO KEYBOARD_TOGGLE( KEY_V )\n\nfloat gauss_blurr_5_kernel[5] = float[5]( 0.06136, 0.24477, 0.38774, 0.24477, 0.06136 );\nfloat gauss_blurr_3_kernel[3] = float[3]( 0.27901, 0.44198, 0.27901 );\nfloat gauss_blurr_1_kernel[1] = float[1]( 1. );\n#define GAUSS_KERNEL_SIDE 1\n//#define GAUSS_KERNEL gauss_blurr_#GAUSS_KERNEL_SIDE#_kernel\n#if GAUSS_KERNEL_SIDE == 1\n#define GAUSS_KERNEL gauss_blurr_1_kernel\n#endif\n#if GAUSS_KERNEL_SIDE == 3\n#define GAUSS_KERNEL gauss_blurr_3_kernel\n#endif\n#if GAUSS_KERNEL_SIDE == 5\n#define GAUSS_KERNEL gauss_blurr_5_kernel\n#endif\n\nfloat sphere_radius = 0.9;\nvec4 sphere( vec2 fragCoord, vec2 iResolution )\n{\n    vec4 ret;\n    vec2 uvc = ( fragCoord - iResolution.xy * 0.5 ) / ( iResolution.y * 0.5 );\n    float r = sphere_radius;\n    float d = min( r, length(uvc.xy)  ) / r;\n    ret.w = 1.0 - d * d;\n    ret.xy = uvc.xy;\n    ret.z = ret.w;\n    float _in = float( ret.w > 0.0 );\n    ret.xyz = normalize( ret.xyz ) * _in + vec3(0,0,1) * ( 1.0 - _in );\n    \n    return ret;\n}\n\n\n// default was 3\n#define WINDOW_W 3\n#define WINDOW_MAX ( WINDOW_W / 2 + 1)\n#define WINDOW_MIN ( - ( WINDOW_W / 2 ) )\n#define WINDOW_AREA (WINDOW_W * WINDOW_W)\n\n#define H_SCALE_EXPR (iResolution.y * 0.5 * sphere_radius)\n#define CURVATURE_SCALE 0.09\n#define BEAUTIFUL_FLOATING_POINT_ART 0\n\n#define TAU   6.2831853\n#define PI    3.14159265\n\nfloat sin01( float a ) { return 0.5 + 0.5 * sin( a ); }\n\n// NOTE(theGiallo): h in [0,1)\nvec3\nrgb_from_hsv( vec3 hsv )\n{\n\tvec3 ret;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\nvec3\nrgb_from_dir( vec3 dir )\n{\n    #if 1\n    return rgb_from_hsv( vec3( dir.x == dir.y && dir.x == 0.0 ? 0.0 : ( atan( dir.y, dir.x ) + PI ) / TAU,\n                               dir.x == dir.y && dir.x == 0.0 ? 0.0 : 1.0,\n                               dir.z * 0.5 + 0.5 ) );\n    #else\n    return vec3( dir * 0.5 + 0.5 );\n    #endif\n}\nvec3\nrgb_from_dir_line( vec3 dir )\n{\n    #if 1\n    float h = dir.x == dir.y && dir.x == 0.0 ? 0.0 : ( atan( dir.y, dir.x ) + PI ) / TAU;\n    h = h > 0.5 ? h - 0.5 : h; \n    //h *= 2.0;\n    return rgb_from_hsv( vec3( h,\n                               dir.x == dir.y && dir.x == 0.0 ? 0.0 : 1.0,\n                               dir.z * 0.5 + 0.5 ) );\n    #else\n    return vec3( dir * 0.5 + 0.5 );\n    #endif\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c = texture( iChannel3, uv );\n    #if 0\n    fragColor = c;\n    #elif 0\n    fragColor.xyz = vec3(length(c.xyz)/3.0);\n    #else\n    fragColor.xyz = vec3((c.r+c.g+c.b)/3.0);\n    #endif\n    \n    \n    if ( HAS_TO_SHOW_DEBUG_SPHERE )\n    {\n    \tvec4 sph = sphere( vec2( fragCoord ), iResolution.xy );\n    \tfragColor.rgb = vec3(sph.w);\n\t} else\n    if ( VIDEO )\n    {\n    \tvec4 c = texture( iChannel2, uv );\n    \tfragColor.xyz = vec3((c.r+c.g+c.b)/3.0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// gaussian blurr x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ret = vec4(0);\n    for ( int i = -( GAUSS_KERNEL_SIDE / 2 ); i != GAUSS_KERNEL_SIDE / 2 + 1; ++i )\n    {\n        vec4 c = texelFetch( iChannel0, ivec2(fragCoord) + ivec2(i,0), 0 );\n        ret += c * GAUSS_KERNEL[i + GAUSS_KERNEL_SIDE / 2];\n    }\n    fragColor = ret;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// gaussian blurr y\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ret = vec4(0);\n    for ( int i = -( GAUSS_KERNEL_SIDE / 2 ); i != GAUSS_KERNEL_SIDE / 2 + 1; ++i )\n    {\n        vec4 c = texelFetch( iChannel0, ivec2(fragCoord) + ivec2(0,i), 0 );\n        ret += c * GAUSS_KERNEL[i + GAUSS_KERNEL_SIDE / 2];\n    }\n    fragColor = ret;\n}","name":"Buf D","description":"","type":"buffer"}]}