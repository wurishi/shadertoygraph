{"ver":"0.1","info":{"id":"cljfRK","date":"1694245773","viewed":66,"name":"multi-obj and broad with checker","username":"tomcat7479","description":"对底部地面棋盘的边缘进行校正","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mulitmodelsdf","broadchecker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592658\n#define N 3\n#define sphere_id 1.0\n#define cuboid_id 2.0\n#define torus_id 3.0\n#define plane_id 4.0\n\n#define iter_precision 1e-4\n#define iter_count 200\n#define min_iter_distance 0.1\n#define max_iter_distance 200.0\n\n// 绘制网格的三种算法mod, xor, smooth xor\nfloat grid_mod(vec3 p, float weight) {\n    vec2 grid = floor(p.xz);\n    return weight * mod(grid.x + grid.y, 2.0);\n}\n\n// floor和round的区别：floor是直接丢弃小数部分，而round是四舍五入之后变为整数\nfloat grid_xor(vec3 p, float weight) {\n    ivec2 grid = ivec2(round(p.xz + 0.1));\n    float xor = float((grid.x ^ grid.y) & 1);\n    return weight * xor;\n}\n\nfloat grid_smooth_xor(vec3 p, float weight) {\n    vec2 s = sign(fract(p.xz) - 0.5);\n    return weight * (0.5 - 0.5 * s.x * s.y);\n}\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 model_pos, vec3 ray_pos, float cr) {\n    vec3 z = normalize(model_pos - ray_pos); // 指向模型的方向确定为z轴\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0); // 确定的是y轴的方向，注意未必与z是垂直关系\n    vec3 x = normalize(cross(z, cp)); \n    vec3 y = cross(x, z);\n    return mat3(x, y, z);\n}\n\nfloat sdfPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdfSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdfCuboid(vec3 p, vec3 center, vec3 edge) {\n    p -= center;\n    vec3 q = abs(p) - edge / 2.0;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdfTorus(vec3 p, vec3 center, float r, float R) {\n    p -= center;\n    vec2 q = vec2(length(p.xz) - R, p.y);\n    return length(q) - r;\n}\n\nvec2 compose(vec3 p, vec3 sphere_center, vec3 cuboid_center, vec3 torus_center, \n             float sphere_radius, vec3 cuboid_edge, float torus_r, float torus_R) {\n    float d_sphere = sdfSphere(p, sphere_center, sphere_radius);\n    float d_torus = sdfTorus(p, torus_center, torus_r, torus_R);                    \n    float d_cuboid = sdfCuboid(p, cuboid_center, cuboid_edge);\n    float d_plane = sdfPlane(p) + max(sphere_radius, max(torus_r, cuboid_edge.z / 2.0));\n    float d_min = d_sphere;\n    float id = sphere_id;\n    if (d_torus < d_min) {\n        d_min = d_torus;\n        id = torus_id;\n    } \n    if (d_cuboid < d_min) {\n        d_min = d_cuboid;\n        id = cuboid_id;\n    }\n    if (d_plane < d_min) {\n        d_min = d_plane;\n        id = plane_id;\n    }\n    return vec2(d_min, id);\n}\n\nfloat triangle_signal(float x) {\n    float h = fract(x * 0.5) - 0.5;\n    return 1.0 - 2.0 * abs(h);\n}\n\nfloat center_difference_tri_signal(float x, float delta) {\n    float dy = triangle_signal(x + 0.5 * delta) - triangle_signal(x - 0.5 * delta);\n    return dy / delta;\n}\n\nvec3 calNormal(vec3 p, vec3 sphere_center, vec3 cuboid_center, vec3 torus_center, \n             float sphere_radius, vec3 cuboid_edge, float torus_r, float torus_R) {\n    const float h = 1e-4;\n    const vec2 k = vec2(1.0, -1.0);\n    vec3 part1 = k.xyy * compose(p + k.xyy * h, sphere_center, cuboid_center, torus_center, \n                                                sphere_radius, cuboid_edge, torus_r, torus_R).x;\n    vec3 part2 = k.yyx * compose(p + k.yyx * h, sphere_center, cuboid_center, torus_center, \n                                                sphere_radius, cuboid_edge, torus_r, torus_R).x;\n    vec3 part3 = k.yxy * compose(p + k.yxy * h, sphere_center, cuboid_center, torus_center, \n                                                sphere_radius, cuboid_edge, torus_r, torus_R).x;\n    vec3 part4 = k.xxx * compose(p + k.xxx * h, sphere_center, cuboid_center, torus_center, \n                                                sphere_radius, cuboid_edge, torus_r, torus_R).x;\n    return normalize(part1 + part2 + part3 + part4);\n}\n\nvec2 rayMarch(vec3 ray_o, vec3 ray_d, vec3 sphere_center, vec3 cuboid_center, vec3 torus_center, \n             float sphere_radius, vec3 cuboid_edge, float torus_r, float torus_R) {\n    float t = min_iter_distance;\n    vec2 res = vec2(-1.0);\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ray_o + t * ray_d;\n        vec2 compose = compose(p, sphere_center, cuboid_center, torus_center, \n                                 sphere_radius, cuboid_edge, torus_r, torus_R);\n        if (compose.x < iter_precision) {\n            res = vec2(t, compose.y);\n            break;\n        }\n        t += compose.x;\n        res.x = t;\n    }\n    return res;\n}\n\nfloat softShadow(vec3 ray_o, vec3 ray_d, vec3 sphere_center, vec3 cuboid_center, vec3 torus_center, \n             float sphere_radius, vec3 cuboid_edge, float torus_r, float torus_R, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    for (float t = min_iter_distance; t < max_iter_distance; ) {\n        vec3 p = ray_o + t * ray_d;\n        vec2 h = compose(p, sphere_center, cuboid_center, torus_center, \n                                 sphere_radius, cuboid_edge, torus_r, torus_R);\n        if (h.x < 0.001) {\n            return 0.0;\n        }\n        float y = h.x * h.x / (2.0 * ph);\n        float d = sqrt(h.x * h.x - y * y);\n        res = min(res, k * d / max(0.0, t - y));\n        ph = h.x;\n        t += h.x;\n    }\n    return res;\n}\n\nfloat checkBroad(vec3 p, vec3 ddx, vec3 ddy) {\n    vec3 delta = max(ddx, ddy) + 1e-2;\n    float dx = center_difference_tri_signal(p.x, delta.x);\n    float dz = center_difference_tri_signal(p.z, delta.z);\n    return 0.5 - 0.5 * dx * dz;\n}\n\nvec3 render(in vec2 uv, vec2 px, vec2 py) {\n    float amb_strength = 0.31;\n    float diff_strength = 0.31;\n    float spec_strength = 0.31;\n    float spec_brightness = 100.0;\n\n    vec3 bg_color = vec3(0.63, 0.74, 0.94);\n    vec3 sphere_color = vec3(0.05, 0.68, 0.59);\n    vec3 cuboid_color = vec3(0.89, 0.7, 0.21);\n    vec3 torus_color = vec3(0.13, 0.38, 0.85);\n    vec3 plane_color = vec3(0.64, 0.62, 0.64);\n    vec3 color = bg_color;\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(2.0, 3.0, 2.0);\n\n    float shadow_k = 3.0;\n\n    vec3 sphere_center = vec3(-2.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    vec3 cuboid_center = vec3(0.0, 0.0, 0.0);\n    vec3 cuboid_edge = vec3(1.0, 1.0, 1.0);\n\n    vec3 torus_center = vec3(2.0, 0.0, 0.0);\n    float torus_r = 0.4;\n    float torus_R = 1.0;\n\n    vec3 lookAt = vec3(-0.4, 0.0, 0.0);\n\n    float focus_distance = 1.0;\n\n    vec3 ro = vec3(4.0 * sin(iTime / PI), 2.0, 4.0 * cos(iTime / PI));\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, focus_distance));\n    vec2 rayMarch = rayMarch(ro, rd, sphere_center, cuboid_center, torus_center, \n                                 sphere_radius, cuboid_edge, torus_r, torus_R);\n    float id = rayMarch.y;    \n    if (rayMarch.x < max_iter_distance) {\n        vec3 p = ro + rayMarch.x * rd;\n        vec3 n = normalize(calNormal(p, sphere_center, cuboid_center, torus_center, \n                                 sphere_radius, cuboid_edge, torus_r, torus_R));\n    \n        if (id > 0.9 && id < 1.9) {\n            color = sphere_color;\n        } else if (id > 1.9 && id <= 2.1) {\n            color = cuboid_color;\n        } else if (id > 2.9 && id < 3.1) {\n            color = torus_color;\n        } else if (id > 3.9 && id < 4.1) {\n            vec3 rdx = normalize(camera * vec3(px, focus_distance));\n            vec3 rdy = normalize(camera * vec3(py, focus_distance));\n            vec3 ddx = ro.y * (rdx / rdx.y - rd / rd.y);\n            vec3 ddy = ro.y * (rdy / rdy.y - rd / rd.y);\n            float res = checkBroad(p, ddx, ddy);\n            color = plane_color + 0.2 * res;\n        }  \n        \n        vec3 ambient = color * light_color * amb_strength;\n\n        float diff_cos = clamp(dot(n, normalize(light_pos - p)), 0.0, 1.0);\n        p += iter_precision * n;\n        float shadow_d = softShadow(p, normalize(light_pos - p), sphere_center, cuboid_center, torus_center, \n                                 sphere_radius, cuboid_edge, torus_r, torus_R, shadow_k);\n        diff_cos *= shadow_d;\n        vec3 diffuse = light_color * diff_cos * diff_strength;\n\n        vec3 refL = normalize(reflect(light_pos - p, n));\n        float spec_cos = clamp(dot(refL, rd), 0.0, 1.0);\n        vec3 specular = light_color * pow(spec_cos, spec_brightness) * spec_strength;\n\n        color = ambient + diffuse + specular;\n    }                             \n    return color;\n}\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = 2.0 * (vec2(float(i), float(j)) / float(N) - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            vec2 px = fix(fragCoord + vec2(1.0, 0.0) + offset);\n            vec2 py = fix(fragCoord + vec2(0.0, 1.0) + offset);\n            color += render(uv, px, py);\n        }\n    }\n    return color / float(N * N);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}