{"ver":"0.1","info":{"id":"wtlfR7","date":"1603659222","viewed":364,"name":"sky_model","username":"myrkott","description":"Basic sky shader that simulates atmospheric scattering with raymarching.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Basic procedural sky shader that simulates atmospheric scattering (Mie and Rayleigh) with\n// raymarching. The implementation largely follows the approach of the Scratchapixel tutorial\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/\n// simulating-colors-of-the-sky and was written with accuracy in mind, not speed. Multiple\n// scattering is not taken into account.\n//\n// SPP can be increased to, e.g, 4 or 8 to produce anti-aliasing. Increasing the\n// NUM_PRIMARY_STEPS and/or NUM_SECONDARY_STEPS of the raymarcher will make the rendering more\n// accurate but also slower. There are some other options and parameters that can be tweaked as\n// well :)\n//\n// Author: Johan NysjÃ¶\n\n#define SPP 1\n#define NUM_PRIMARY_STEPS 30\n#define NUM_SECONDARY_STEPS 10\n#define RAYLEIGH_SCATTERING_ENABLED 1\n#define MIE_SCATTERING_ENABLED 1\n#define EQUIRECTANGULAR_VIEW_ENABLED 0\n#define ANIMATION_ENABLED 1\n#define EXPOSURE 1.0\n#define SUN_DIRECTION vec3(0.0, -1.0, 10.0)\n#define SUN_INTENSITY 2.0\n#define DISPLAY_SUN 0\n\n#define PI 3.141592\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n    float t_min;\n    float t_max;\n};\n\nstruct HitInfo {\n\tfloat t_min;\n    float t_max;\n};\n\nstruct Camera {\n\tvec3 eye;\n    vec3 center;\n    vec3 up;\n    float fovy;\n    float aspect;\n};\n\nvoid generate_ray(Camera camera, vec2 uv, out Ray ray)\n{\n\tvec3 f = normalize(camera.center - camera.eye);\n    vec3 s = cross(f, normalize(camera.up));\n    vec3 u = cross(s, f);\n    \n    float half_width = tan(0.5 * camera.fovy);\n    float half_height = camera.aspect * half_width;\n    float x = 2.0 * uv.x - 1.0;\n    float y = 2.0 * uv.y - 1.0;\n    \n    ray.origin = camera.eye;\n    ray.direction = normalize(f + x * half_width * s + y * half_height * u);\n}\n\n// Converts a 2D equirectangular texture coordinate to a 3D ray direction, which is stored in\n// the output ray along with the origin.\nvoid generate_ray_equirect(vec3 origin, vec2 uv, out Ray ray)\n{\n    uv = clamp(uv, 0.0, 1.0);\n\n    float theta = PI * (2.0 * uv.s - 1.0);\n    float phi = PI * (uv.t - 0.5);\n    float x = cos(phi) * sin(theta);\n    float y = sin(phi);\n    float z = cos(phi) * cos(theta);\n\n    ray.origin = origin;\n    ray.direction = normalize(vec3(x, y, z));\n}\n\n// R2 low-discrepancy sequence\n// Reference: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 ldseq_r2(float index)\n{\n    float phi = 1.324717957;\n    return fract(vec2(index / phi, index / (phi * phi)));\n}\n\nfloat hash2d(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.2331))) * 43758.5453);\n}\n\nstruct SkyParams {\n    vec3 earth_center;\n\tfloat earth_radius_km;\n    float atmosphere_radius_km;\n    vec3 mie_scattering;\n    vec3 rayleigh_scattering;\n    float mie_scale_height_km;\n    float rayleigh_scale_height_km;\n    float mie_phase_g;\n    vec3 sun_direction;\n    vec3 sun_intensity;\n    float sun_size_rad;\n};\n\n// Ray-sphere intersection test that finds the distance to the closest (t_min) and farthest\n// (t_max) intersection points between a ray and a solid sphere. Returns true if the ray hits\n// the sphere and false otherwise.\nbool sphere_hit(vec3 sphere_center, float sphere_radius, Ray ray, out HitInfo hit_info)\n{\n    vec3 oc = ray.origin - sphere_center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere_radius * sphere_radius;\n    \n    float discriminant = b * b - a * c;\n    if (discriminant > 0.0) {\n\t\thit_info.t_min = max(ray.t_min, (-b - sqrt(discriminant)) / a);\n        hit_info.t_max = (-b + sqrt(discriminant)) / a;\n        return hit_info.t_max > ray.t_min && hit_info.t_max < ray.t_max;\n    }\n\n    return false;\n}\n\nfloat rayleigh_phase_function(float cos_theta)\n{\n\treturn 0.75 * (1.0 + cos_theta * cos_theta);\n}\n\nfloat mie_phase_function(float cos_theta, float g)\n{\n    float g2 = g * g;\n\treturn 1.5 * ((1.0 - g2) * (1.0 + cos_theta * cos_theta)) /\n        ((2.0 + g2) * pow(1.0 + g2 - 2.0 * g * cos_theta, 1.5));\n}\n\nvec3 beer_lambert(vec3 sigma_t, float path_length_km)\n{\n    return exp(-sigma_t * path_length_km);\n}\n\n// NOTE: visibility is the same as transmittance in this case\nvec3 raymarch_visibility(vec3 world_pos, int num_steps, SkyParams sky_params)\n{\n\tRay world_ray;\n    world_ray.origin = world_pos;\n    world_ray.direction = -sky_params.sun_direction;\n    world_ray.t_min = 1e-3;\n    world_ray.t_max = 1e6;\n    \n    vec3 visibility = vec3(1.0, 1.0, 1.0);\n    HitInfo hit_info;\n    if (sphere_hit(sky_params.earth_center, sky_params.earth_radius_km, world_ray, hit_info)) {\n        visibility = vec3(0.0, 0.0, 0.0);\n    }\n    else if (sphere_hit(sky_params.earth_center, sky_params.atmosphere_radius_km, world_ray,\n                        hit_info)) {\n        world_ray.t_min = hit_info.t_min;\n        world_ray.t_max = hit_info.t_max;\n\n        float path_length_km = world_ray.t_max - world_ray.t_min;\n        float step_length_km = path_length_km / float(num_steps);\n\n        float t = world_ray.t_min;\n        while (t < world_ray.t_max) {\n            vec3 sample_pos = world_ray.origin + (t + 0.5 * step_length_km) * world_ray.direction;\n            float height_km = max(0.0, length(sample_pos - sky_params.earth_center) -\n                                  sky_params.earth_radius_km);\n\n#if RAYLEIGH_SCATTERING_ENABLED\n            float rayleigh_scaling = exp(-height_km / sky_params.rayleigh_scale_height_km);\n            visibility *= beer_lambert(sky_params.rayleigh_scattering * rayleigh_scaling,\n                                       step_length_km);\n#endif\n\n#if MIE_SCATTERING_ENABLED            \n            float mie_scaling = exp(-height_km / sky_params.mie_scale_height_km);\n            visibility *= beer_lambert(sky_params.mie_scattering * mie_scaling,\n                                       step_length_km);\n#endif\n\n            t += step_length_km;\n        }\n    }\n    \n    return visibility;\n}\n\nvoid raymarch(Ray world_ray, int num_primary_steps, int num_secondary_steps, SkyParams sky_params,\n              out vec3 transmittance, out vec3 luminance)\n{\n    float path_length_km = world_ray.t_max - world_ray.t_min;\n    float step_length_km = path_length_km / float(num_primary_steps);\n\n    transmittance = vec3(1.0, 1.0, 1.0);\n    luminance = vec3(0.0, 0.0, 0.0);\n    float t = world_ray.t_min;\n    while (t < world_ray.t_max) {\n        vec3 sample_pos = world_ray.origin + (t + 0.5 * step_length_km) * world_ray.direction;\n        float height_km = max(0.0, length(sample_pos - sky_params.earth_center) -\n                              sky_params.earth_radius_km);\n\n        vec3 visibility = raymarch_visibility(sample_pos, num_secondary_steps, sky_params);\n        float cos_theta = dot(sky_params.sun_direction, -world_ray.direction);\n\n#if RAYLEIGH_SCATTERING_ENABLED\n        float rayleigh_scaling = exp(-height_km / sky_params.rayleigh_scale_height_km);        \n        transmittance *= beer_lambert(sky_params.rayleigh_scattering * rayleigh_scaling,\n                                      step_length_km);\n#endif\n\n#if MIE_SCATTERING_ENABLED\n        float mie_scaling = exp(-height_km / sky_params.mie_scale_height_km);        \n        transmittance *= beer_lambert(sky_params.mie_scattering * mie_scaling,\n                                      step_length_km);\n#endif\n\n#if RAYLEIGH_SCATTERING_ENABLED\n        luminance += transmittance * sky_params.rayleigh_scattering * rayleigh_scaling *\n            visibility * rayleigh_phase_function(cos_theta) * sky_params.sun_intensity *\n            step_length_km;\n#endif        \n\n#if MIE_SCATTERING_ENABLED        \n        luminance += transmittance * sky_params.mie_scattering * mie_scaling *\n            visibility * mie_phase_function(cos_theta, sky_params.mie_phase_g) *\n            sky_params.sun_intensity * step_length_km;\n#endif\n\n        t += step_length_km;\n    }\n}\n\nvec3 tonemap_aces(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);   \n}\n\nvec3 lin2srgb(vec3 color)\n{\n \treturn pow(color, vec3(0.454));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // NOTE: the Mie and Rayleigh scattering parameter values used here are based on the values\n    // used by Bruneton and Neyret in the paper Precomputed Atmospheric Scattering, EGSR, 2008\n    SkyParams sky_params;\n    sky_params.earth_center = vec3(0.0, 0.0, 0.0);\n    sky_params.earth_radius_km = 6360.0;\n    sky_params.atmosphere_radius_km = 6420.0;\n    sky_params.mie_scattering = vec3(3.0e-3);\n    sky_params.rayleigh_scattering = vec3(4.8e-3, 1.35e-2, 3.31e-2);\n    sky_params.mie_scale_height_km = 1.2;\n    sky_params.rayleigh_scale_height_km = 8.0;\n    sky_params.mie_phase_g = 0.76;\n    sky_params.sun_direction = normalize(SUN_DIRECTION);\n    sky_params.sun_intensity = vec3(SUN_INTENSITY);\n    sky_params.sun_size_rad = radians(0.5334);\n\n    Camera camera;\n#if 1 // view the atmosphere from earth\n    float height = ANIMATION_ENABLED != 0 ? mod(2.0 * iTime, 20.0) + 0.1 : 0.1;\n    camera.eye = vec3(0.0, sky_params.earth_radius_km + height, 0.0);\n    camera.center = vec3(0.0, sky_params.earth_radius_km + height, -1.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n    camera.fovy = radians(125.0);\n#else // view the atmosphere from outer space!\n    camera.eye = vec3(0.0, 0.0, 4.0 * sky_params.earth_radius_km);\n    camera.center = vec3(0.0, 0.0, 0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n    camera.fovy = radians(60.0);\n#endif\n    camera.aspect = iResolution.y / iResolution.x;\n\n    vec2 rnd = vec2(hash2d(uv), hash2d(uv + 0.1));\n\n   \tvec3 output_color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < SPP; ++i) {\n        int sample_idx = (SPP * iFrame + i) % 1000;\n        vec2 aa_offset = fract(ldseq_r2(float(sample_idx)) + rnd) / iResolution.xy;\n        \n    \tRay world_ray;\n#if EQUIRECTANGULAR_VIEW_ENABLED\n        generate_ray_equirect(camera.eye, uv + aa_offset, world_ray);\n#else\n        generate_ray(camera, uv + aa_offset, world_ray);\n#endif\n    \tworld_ray.t_min = 1e-3;\n    \tworld_ray.t_max = 1e6;\n\n    \tHitInfo hit_info;\n    \tif (sphere_hit(sky_params.earth_center, sky_params.atmosphere_radius_km, world_ray,\n                       hit_info)) {\n        \tworld_ray.t_min = hit_info.t_min;\n        \tworld_ray.t_max = hit_info.t_max;\n \n            // Check if the ray intersects the earth surface and clamp t_max to the intersection\n            // point if that is the case (no need to raymarch beneath the surface, won't reach\n            // any sunlight there...)\n            bool earth_hit = sphere_hit(sky_params.earth_center, sky_params.earth_radius_km,\n                                        world_ray, hit_info);\n            world_ray.t_max = earth_hit ? max(hit_info.t_min, world_ray.t_min) : world_ray.t_max;\n\n            // Calculate athmospheric scattering with raymarching\n            vec3 transmittance = vec3(1.0, 1.0, 1.0);\n            vec3 luminance = vec3(0.0, 0.0, 0.0);\n        \traymarch(world_ray, NUM_PRIMARY_STEPS, NUM_SECONDARY_STEPS, sky_params,\n                     transmittance, luminance);\n            output_color += luminance;\n            \n#if DISPLAY_SUN\n            // Display the sun as a disk with the specified angular diameter (radians), taking\n            // occlusion from the earth into account. Here we don't need to perform an actual\n            // disk intersection test but can just check the angle between the primary ray\n            // direction and the outgoing sun direction, which is cheaper and simpler :)\n            float sun_cos_theta = dot(sky_params.sun_direction, -world_ray.direction);\n    \t\tif (!earth_hit && sun_cos_theta >= cos(0.5 * sky_params.sun_size_rad)) {\n    \t\t\toutput_color += transmittance * sky_params.sun_intensity;   \n    \t\t}\n#endif\n    \t}\n    }\n    output_color /= float(SPP);\n    \n    output_color *= EXPOSURE;\n    output_color = tonemap_aces(output_color);\n    output_color = lin2srgb(output_color);\n\n    fragColor = vec4(output_color, 1.0);\n}","name":"Image","description":"","type":"image"}]}