{"ver":"0.1","info":{"id":"WscfDN","date":"1609933567","viewed":262,"name":"Integrate BRDF LUT","username":"inode","description":"Integrate BRDF LUT with height corrected Smith Geometry term\nCompare with BlackOps fit","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int BRDF_SAMPLE_COUNT = 2048;\n\nconst float PI = 3.14159265358979323846;\nfloat roughness = 0.0;\nfloat metallic = 0.0;\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nfloat V_SmithGGXCorrelated(float A2, float NoV, float NoL)\n{\n\tfloat LambdaV = NoL * sqrt((NoV - A2 * NoV) * NoV + A2);\n\tfloat LambdaL = NoV * sqrt((NoL - A2 * NoL) * NoL + A2);\n\tfloat v = 0.5 / (LambdaV + LambdaL);\n\treturn v;\n}\n\nfloat Vis_Smith( float A2, float NoV, float NoL )\n{\n\tfloat Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * A2) + A2 );\n\tfloat Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * A2) + A2 );\n\treturn 1.0 / ( Vis_SmithV * Vis_SmithL );\n}\n\nfloat VanDerCorpus(int n, int base) {\n    float invBase = 1.0 / float(base);\n    float denom   = 1.0;\n    float result  = 0.0;\n\n    for(int i = 0; i < 32; ++i)\n    {\n        if(n > 0)\n        {\n            denom   = mod(float(n), 2.0);\n            result += denom * invBase;\n            invBase = invBase / 2.0;\n            n       = int(float(n) / 2.0);\n        }\n    }\n\n    return result;\n}\n\nvec2 Hammersley(int i, int N) {\n    return vec2(float(i)/float(N), VanDerCorpus(i, 2));\n}  \n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n    float a = roughness*roughness;\n\t\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}\n\nvec2 PrefilteredDFG_Approx(float Roughness, float NoV)\n{\n\t// [ Lazarov 2013, \"Getting More Physical in Call of Duty: Black Ops II\" ]\n\t// Adaptation to fit our G term.\n\t// Blinn-Phong\n\t\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\n\t// Anything less than 2% is physically impossible and is instead considered to be shadowing\n\t// In ES2 this is skipped for performance as the impact can be small\n\t// Note: this is needed for the 'specular' show flag to work, since it uses a SpecularColor of 0\n\t// AB.y *= saturate(50.0 * SpecularColor.g);\n\treturn AB;\n}\n\nfloat RoughnessToGloss(float Roughness)\n{\n    // return sqrt(1.0 - Roughness * Roughness);\n    return 1.0 - sqrt(Roughness);\n}\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec2 EnvDFGPolynomial(float Roughness, float NoV)\n{\n\t// https://knarkowicz.wordpress.com/2014/12/27/analytical-dfg-term-for-ibl/\n\tfloat gloss = RoughnessToGloss(Roughness);\n\tfloat x = gloss;\n\tfloat y = NoV;\n\n\tfloat b1 = -0.1688;\n\tfloat b2 = 1.895;\n\tfloat b3 = 0.9903;\n\tfloat b4 = -4.853;\n\tfloat b5 = 8.404;\n\tfloat b6 = -5.069;\n\tfloat bias = saturate(min(b1 * x + b2 * x * x, b3 + b4 * y + b5 * y * y + b6 * y * y * y));\n\n\tfloat d0 = 0.6045;\n\tfloat d1 = 1.699;\n\tfloat d2 = -0.5228;\n\tfloat d3 = -3.603;\n\tfloat d4 = 1.404;\n\tfloat d5 = 0.1939;\n\tfloat d6 = 2.661;\n\tfloat delta = saturate(d0 + d1 * x + d2 * y + d3 * x * x + d4 * x * y + d5 * y * y + d6 * x * x * x);\n\tfloat scale = delta - bias;\n\t\n    return vec2(scale, bias);\n    \n\t// bias *= saturate(50.0 * SpecularColor.y);\n\t// return SpecularColor * scale + bias;\n}\n\nvec2 IntegrateBRDF(float NdotV, float roughness) {\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    for(int i = 0; i < BRDF_SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, BRDF_SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis_0 = (G * VdotH) / (NdotH * NdotV);\n                     \n            // float Vis = Vis_Smith(roughness * roughness, NdotV, NdotL);\n            // float G_Vis = Vis * 4.0 * NdotL * VdotH / NdotH;\n           \t\n            float a2 = pow(roughness, 4.0);\n            float Vis = V_SmithGGXCorrelated(a2, NdotV, NdotL);\n            float G_Vis = Vis * 4.0 * NdotL * VdotH / NdotH;\n            \n            // G_Vis = abs(G_Vis - G_Vis_0);\n            // G_Vis = G_Vis_0;\n            \n            float Fc = pow(1.0 - VdotH, 5.0);\n\t\t\t\t\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(BRDF_SAMPLE_COUNT);\n    B /= float(BRDF_SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x > iResolution.y)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    float NdotV = uv.x;\n    float Roughness = uv.y;\n    \n    vec2 res0 = IntegrateBRDF(NdotV, Roughness);\n    vec2 res1 = PrefilteredDFG_Approx(Roughness, NdotV);\n    vec2 res2 = EnvDFGPolynomial(Roughness, NdotV);\n        \n    vec2 res = abs(res0 - res1);\n    // vec2 res = res0;\n    fragColor = vec4(res.x, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}