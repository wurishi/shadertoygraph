{"ver":"0.1","info":{"id":"ftjGzW","date":"1623440176","viewed":77,"name":"gammatest2","username":"hellotanjent","description":"This shader generates test bars for calibrating your monitor against the sRGB standard and also serves as a torture-test for monitor response time. See code comments for details.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test","gamma","monitor","calibration","responsetime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis shader generates test bars for calibrating your monitor against the sRGB\nstandard and also serves as a torture-test for monitor response time.\n\nTo use, click the \"Go Fullscreen\" button at the bottom right of the shader and\nview the monitor from 3-5 feet away.\n\nIn a \"perfect\" result the color blocks will appear flat and motionless.\nIn a \"decent\" result the blocks will appear to have a faint wave pattern.\nIn a \"bad\" result will have very bright or dark waves.\n\nA monitor can be perfectly color-calibrated and still display waves in this test\n- the test is _very_ picky about the monitor is displaying _exactly_ what the\nGPU is sending it.\n\nThe following things will all cause the waves to be more visible:\n\n- Non-native resolution\n- Display scaling not at 100%\n- Non-sRGB color space\n- Compressed color signals like YUV422, YUV420 YCbCr422, YCbCr420, etcetera.\n- \"Limited\" dynamic range color output\n- Too-high or too-low contrast, brightness, or gamma\n- Very high refresh rates\n- \"Fastest\" monitor overdrive modes\n- GSYNC or FreeSync turned on (in some cases, not all)\n- Sharpening filters\n- Black stabilizer filters\n- Inter-pixel interference inside the panel itself (mostly on VA panels)\n\n*/\n\nfloat gamma(float x) {\n  x = clamp(x, 0.0, 1.0);\n  // srgb standard\n  x = (x < 0.0031308) ? 12.92 * x : (1.0 + 0.055) * pow(x, 1.0 / 2.4) - 0.055;\n  \n  // gamma 2.2\n  //x = pow(x, 1.0 / 2.2);\n  return x;\n}\n\nfloat bit(float x, int bit) {\n    x = fract(x * exp2(float(-bit - 1)));\n    return x < 0.5 ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Divide the screen into 7 vertical stripes and make each one a different color.\n    float barX = floor(7.0 * fragCoord.x / iResolution.x) + 1.0;\n    float r = bit(barX, 0);\n    float g = bit(barX, 1);\n    float b = bit(barX, 2);\n    vec4 barColor = vec4(r, g, b, 1.0);\n\n    // Make each horizontal region 1/2 the brightness of the one above it.\n    int barY = int(8.0 * fragCoord.y / iResolution.y);\n    barColor *= exp2(float(barY - 8));\n    \n    // Make a moving horizontal wave pattern with a bit of a flat top and bottom.\n    float waveX = sin((iTime * 2.7 + 15.0 * fragCoord.x / iResolution.x) * 2.0 * 3.14159);\n    waveX *= 1.05;\n    waveX = clamp(waveX * 0.5 + 0.5, 0.0, 1.0);\n\n    // Interpolate between the pure color and a \"checkerboard\" version of the color\n    // based on the wave pattern.\n    float checker = (bit(fragCoord.x, 0) + bit(fragCoord.y, 0)) == 1.0 ? 0.0 : 1.0;\n    \n    // Invert the checkerboard every other frame - this will cause the monitor's\n    // response time to have a huge effect on the wave visibility.\n    if ((iFrame & 1) == 0) checker = 1.0 - checker;\n    checker = checker * 2.0 - 1.0;\n\n    fragColor = mix(barColor, barColor + barColor * float(checker), waveX);\n    \n    // Convert from linear color to inverse-gamma-corrected color.\n    // When displayed on a calibrated monitor, this will turn back into linear color.\n    fragColor.r = gamma(fragColor.r);\n    fragColor.g = gamma(fragColor.g);\n    fragColor.b = gamma(fragColor.b);\n   \n}","name":"Image","description":"","type":"image"}]}