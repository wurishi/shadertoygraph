{"ver":"0.1","info":{"id":"4tBXzm","date":"1442350377","viewed":111,"name":"raytracing test0001","username":"fscur","description":"raytracing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nstruct Pixel\n{\n    vec3 position;\n    vec3 normal;\n    vec4 color;\n    float reflectivity;\n};\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec4 color;\n    float reflectivity;\n};\n\nstruct Triangle\n{\n\tvec3 A;\n    vec3 B;\n    vec3 C;\n    vec4 color;\n    float reflectivity;\n};\n    \nstruct Plane\n{\n    vec3 position;\n    vec3 normal;\n};\n    \nstruct DirLight\n{\n    vec3 position;\n    vec3 direction;\n    float intensity;\n    vec4 color;\n};\n    \nstruct PointLight\n{\n    vec3 position;\n    vec4 color;\n    float intensity;\n    float range;\n};\n       \n//ray \n// p = ro + t * rd\n    \n//plane \n// (p . n) - (a . n) = 0\n    \n//sphere\n// (p - c) . (p - c) - r^2 = 0\n\nbool RayPlaneIntersection(in Ray r, in Plane pl, out float t, out vec3 n)\n{\n    float intersect = dot(r.direction, pl.normal);\n    \n    if (intersect == 0.0)\n        return false;\n    \n    t = (dot(pl.position, pl.normal) - dot(r.origin, pl.normal))/intersect;\n    \n    if (t < 0.0)\n        return false;\n    \n    n = pl.normal;\n    \n    return true;\n}   \n    \n    \nbool RayTriangleIntersection(in Ray r, in Triangle tri, out float t, out vec3 n)\n{\n    vec3 normal = normalize(cross(tri.C - tri.A, tri.B - tri.A));\n    \n    float intersect = dot(r.direction, normal);\n    \n    if (intersect == 0.0)\n    \treturn false;\n    \n    t = (dot(tri.A, normal) - dot(r.origin, normal))/intersect;\n    \n    if (t < 0.0)\n        return false;\n    \n    n = normal;\n    \n    vec3 p = r.origin + r.direction * t;\n    \n    float a = p.x - tri.A.x;\n    float b = tri.B.x - tri.A.x;\n    float c = tri.C.x - tri.A.x;\n    \n    float d = p.y - tri.A.y;\n    float e = tri.B.y - tri.A.y;\n    float f = tri.C.y - tri.A.y;\n    \n    float u = ((b * f) - (e * c));\n    \n    if (u == 0.0)\n    {\n    \ta = p.x - tri.A.x;\n        b = tri.B.x - tri.A.x;\n        c = tri.C.x - tri.A.x;\n\n        d = p.z - tri.A.z;\n        e = tri.B.z - tri.A.z;\n        f = tri.C.z - tri.A.z;\n        \n        u = ((b * f) - (e * c));\n    }\n    \n    float beta = ((a * f) - (d * c)) / u;\n    float gamma;\n    \n    if (f == 0.0)\n        gamma = (a - (beta * b)) / c;\n    else\n        gamma = (d - (beta * e)) / f;\n    \n    float alpha = 1.0 - beta - gamma;\n    \n    if (alpha >= 0.0 && alpha <= 1.0 &&\n        beta >= 0.0 && beta <= 1.0 &&\n    \tgamma >= 0.0 && gamma <= 1.0)\n        return true;\n    \n    return false;\n}   \n   \nbool RaySphereIntersection(in Ray r, in Sphere s, out float t, out vec3 n)\n{ \n    //t^2 ( P1 . P1) + 2t (P1 . (P0-C)) + ((P0 - c) . (P0 - c)) - r^2 = 0\n    // -b +- sqrt(b^2-4.a.c) / 2.a\n    \n    vec3 p0 = r.origin;\n    vec3 p1 = r.direction;\n    vec3 p2 = p0 - s.center;\n    float r2 = s.radius * s.radius;\n    \n    float a = dot(p1, p1);\n    float b = 2.0 * dot(p1, p2);\n    float c = dot(p2, p2) - r2;\n    \n    float delta = pow(b, 2.0) - 4.0 * a * c;\n    \n    if (delta < 0.0)\n        return false;\n    \n    float deltaSqr = sqrt(delta); \n    \n    float t0 = (-b + deltaSqr) / (2.0 * a);\n    float t1 = (-b - deltaSqr) / (2.0 * a);\n    \n    if (t1 > t0)\n        t = t0;\n    else\n        t = t1;\n    \n    if (t < 0.0)\n        return false;\n    \n    vec3 p = p0 + p1 * t;\n    n = normalize(p - s.center);\n    \n    return true;\n}\n\nvec4 CalcDirLight(DirLight light, Pixel pixel)\n{\n    float diffuse = clamp(dot(-light.direction, pixel.normal), 0.0, 1.0) * light.intensity;\n    return light.color * pixel.color * diffuse;\n}\n\nvec4 CalcPointLight(PointLight light, Pixel pixel)\n{\n    float oneOverRangeSqr = 1.0 / pow(light.range, 2.0);\n    vec3 lightDir = pixel.position - light.position;\n    float distanceToPoint = length(lightDir);\n    float attenuation = 1.0 - pow(distanceToPoint, 2.0) * oneOverRangeSqr;\n    \n    lightDir = normalize(lightDir);\n    \n    float diffuse = clamp(dot(-lightDir, pixel.normal), 0.0, 1.0) * light.intensity;\n    return light.color * pixel.color * diffuse * clamp(attenuation, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect; \n    \n    float near = 2.0;\n    float far = 5.0;\n    vec3 camRight = vec3(1.0, 0.0, 0.0);\n    vec3 camUp    = vec3(0.0, 1.0, 0.0);\n    vec3 camDir   = vec3(0.0, 0.0, 1.0);\n    vec3 camPos   = vec3(0.0, 4.0, 15.5);\n    \n    camPos = vec3(sin(time) * 20.0, 5.0, cos(time) * 20.0); \n     \n    vec3 eye = camPos;\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    camDir = normalize(target - eye);\n    camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n    camUp = normalize(cross(camDir, camRight));\n    camRight = normalize(cross(camUp, camDir));\n    \n    mat4 rotationMatrix = mat4\n        (camRight.x, camRight.y, camRight.z, 0.0,\n         camUp.x, camUp.y, camUp.z, 0.0,\n         camDir.x, camDir.y, camDir.z, 0.0,\n         0.0, 0.0, 0.0, 1.0); \n    \n    mat4 translationMatrix = mat4\n        (1.0, 0.0, 0.0, -camPos.x,\n         0.0, 1.0, 0.0, -camPos.y,\n         0.0, 0.0, 1.0, -camPos.z,\n         0.0, 0.0, 0.0, 1.0); \n    \n    mat4 viewMatrix = rotationMatrix * translationMatrix;\n    \n    vec4 rayEnd = viewMatrix * vec4(uv, near, 1.0);\n    \n    Ray r;\n    r.origin = camPos.xyz;\n    r.direction = rayEnd.xyz;\n    \n    \n    Plane pl;\n    pl.position = vec3(0.0);\n    pl.normal = vec3(0.0, 1.0, 0.0);\n    \n    Sphere spheres[2];\n    \n    spheres[0].center = vec3(-1.5, 1.0, 0.0);\n    spheres[0].radius = 1.0;\n    spheres[0].color = vec4(0.1, 0.1, 0.1, 1.0);\n    spheres[0].reflectivity = 0.0;\n    \n    spheres[1].center = vec3(1.5, 1.0, 0.0);\n    spheres[1].radius = 1.0;\n    spheres[1].color = vec4(1.0, 0.0, 0.0, 1.0);\n    spheres[1].reflectivity = 0.0;\n    \n    vec4 color = vec4(0.0);\n    \n    DirLight dirLight;\n    dirLight.position = vec3(1.0, 1.0, -1.0);\n    dirLight.direction = -normalize(dirLight.position);\n    dirLight.color = vec4(1.0);\n    dirLight.intensity = 1.0;\n    \n    PointLight pointLight;\n    pointLight.position = vec3(sin(time) * 3.0, 3.0, cos(time) * 3.0);\n    //pointLight.position = vec3(3.0, 3.0, 0.0);\n    \n    pointLight.color = vec4(1.0);\n    pointLight.intensity = 1.0;\n    pointLight.range = 5.0;\n    \n    float t = 10000.0;\n    float t1 = 10000.0;\n    float ref = 0.0;\n    vec3 n1;\n    vec3 n;\n    \n    Triangle triangles[4];\n    triangles[0].A = vec3(-5.0, 0.0, -5.0);\n    triangles[0].B = vec3(5.0, 0.0, -5.0);\n    triangles[0].C = vec3(5.0, 0.0, 5.0);\n    triangles[0].color = vec4(0.0, 1.0, 1.0, 1.0);\n    triangles[0].reflectivity = 0.0;\n    \n    triangles[1].A = vec3(5.0, 0.0, 5.0);\n    triangles[1].B = vec3(-5.0, 0.0, 5.0);\n    triangles[1].C = vec3(-5.0, 0.0, -5.0);\n    triangles[1].color = vec4(1.0, 1.0, 0.0, 1.0);\n    triangles[1].reflectivity = 0.0;\n    \n    triangles[2].A = vec3(-5.0, 0.0, 5.0);\n    triangles[2].B = vec3(5.0, 0.0, 5.0);\n    triangles[2].C = vec3(5.0, 5.0, 5.0);\n    triangles[2].color = vec4(1.0, 1.0, 1.0, 1.0);\n    triangles[2].reflectivity = 1.0;\n    \n    triangles[3].A = vec3(5.0, 5.0, 5.0);\n    triangles[3].B = vec3(-5.0, 5.0, 5.0);\n    triangles[3].C = vec3(-5.0, 0.0, 5.0);\n    triangles[3].color = vec4(1.0, 1.0, 1.0, 1.0);\n    triangles[3].reflectivity = 1.0;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        Triangle tri = triangles[i];\n        float st = 1000.0;\n        vec3 sn;\n        \n        if (RayTriangleIntersection(r, tri, st, sn))\n        {\n            if (st < t)\n            {\n                t = st;\n                n = sn;\n                color = tri.color;\n                ref = tri.reflectivity;\n            }\n        }\n    }\n    \n    /*\n    if (RayPlaneIntersection(r, pl, t1, n1))\n    {\n        if (t1 < t)\n        {\n            t = t1;\n            n = n1;\n            color = vec4(0.0, 1.0, 0.0, 1.0);\n        }\n    }\n    */\n    \n    for(int i = 0; i < 2; i++)\n    {\n        Sphere s = spheres[i];\n        float st = 1000.0;\n        vec3 sn;\n        \n        if (RaySphereIntersection(r, s, st, sn))\n        {\n            if (st < t)\n            {\n                t = st;\n                n = sn;\n                color = s.color;\n                ref = s.reflectivity;\n            }\n        }\n    }\n    \n    Pixel pixel;\n    pixel.position = r.origin + t * r.direction;\n    pixel.normal = n;\n    pixel.reflectivity = ref;\n    \n    float shadowFactor = 1.0;\n    \n    \n    \n    \n    if (t < 10000.0);\n    {\n        t = 10000.0;\n        n = vec3(0.0);\n        \n        vec3 lightPixel = pointLight.position - pixel.position;\n        float lightPixelDist = length(lightPixel);\n        Ray r2;\n        r2.origin = pixel.position;\n        r2.direction = normalize(lightPixel);\n        r2.origin += r2.direction * 0.001;\n            \n        for(int i = 0; i < 4; i++)\n        {\n            Triangle tri = triangles[i];\n            float st = 1000.0;\n            vec3 sn;\n\n            if (RayTriangleIntersection(r2, tri, st, sn))\n            {\n                if (st < t)\n                {\n                    shadowFactor = 0.0;\n                }\n            }\n        }\n        \n        /*\n        if (RayPlaneIntersection(r, pl, t1, n1))\n        {\n            if (t1 < t)\n            {\n                shadowFactor = 0.0;\n            }\n        }\n*/\n        for(int i = 0; i < 2; i++)\n        {\n            Sphere s = spheres[i];\n            float st = 1000.0;\n            vec3 sn;\n\n            if (RaySphereIntersection(r2, s, st, sn))\n            {\n                if (st < t)\n                {\n                    shadowFactor = 0.0;\n                }\n            }\n        }\n        \n        if (pixel.reflectivity > 0.0)\n        {\n            Ray r3;\n            r3.origin = pixel.position;\n            r3.direction = reflect(r.direction, pixel.normal);\n            r3.origin += r3.direction * 0.001;\n\n            for(int i = 0; i < 4; i++)\n            {\n                Triangle tri = triangles[i];\n                float st = 1000.0;\n                vec3 sn;\n\n                if (RayTriangleIntersection(r3, tri, st, sn))\n                {\n                    if (st < t)\n                    {\n                        t = st;\n                        n = sn;\n                        color = tri.color * pixel.reflectivity;\n                    }\n                }\n            }\n\n            /*\n            if (RayPlaneIntersection(r, pl, t1, n1))\n            {\n                if (t1 < t)\n                {\n                    shadowFactor = 0.0;\n                }\n            }\n    */\n            for(int i = 0; i < 2; i++)\n            {\n                Sphere s = spheres[i];\n                float st = 1000.0;\n                vec3 sn;\n\n                if (RaySphereIntersection(r3, s, st, sn))\n                {\n                    if (st < t)\n                    {\n                        t = st;\n                        n = sn;\n                        color = mix(color, s.color, pixel.reflectivity);\n                    }\n                }\n            }\n            \n            //pixel.position = r.origin + t * r.direction;\n    \t\t//pixel.normal = n;\n    \t\t//pixel.reflectivity = ref;\n        }\n    }\n    \n    \n    pixel.color = color;\n    vec4 ambientLightTerm = color * 0.2;\n    vec4 dirLightTerm = CalcDirLight(dirLight, pixel);\n    vec4 pointLightTerm = CalcPointLight(pointLight, pixel);\n    fragColor = ambientLightTerm + (dirLightTerm + pointLightTerm) * shadowFactor;\n    \n    //fragColor = dirLightTerm;\n    //fragColor = pointLightTerm;\n} ","name":"Image","description":"","type":"image"}]}