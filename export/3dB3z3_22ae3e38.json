{"ver":"0.1","info":{"id":"3dB3z3","date":"1549458029","viewed":366,"name":"Painting substance","username":"SolalDR","description":"Based on Sobel & Kuwahara filter ","likes":4,"published":1,"flags":2,"usePreview":0,"tags":["sobel","kuwahara"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 strokeColor = vec3(1., 1., 1.);\n    vec3 colMask = sobel(iChannel0, step/iResolution[0], step/iResolution[1], uv);\n    vec3 stroke = strokeColor*colMask;\n\n    \n    // Output to screen\n    if(stroke.x > 0.8){\n        fragColor = vec4(1. - stroke, 0.);\n    } else {\n        vec4 color = kuwahara(iChannel0, uv, iResolution.xy, 20);\n    \tfragColor = vec4(color.xyz, 0.);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/********************\n*       SOBEL \n*********************/\n\n// Use these parameters to fiddle with settings\nfloat step = 1.3;\n\nfloat intensity(in vec4 color){\n\treturn sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));\n}\n\nvec3 sobel(sampler2D tex, float stepx, float stepy, vec2 center){\n\t// get samples around pixel\n    float tleft = intensity(texture(tex,center + vec2(-stepx,stepy)));\n    float left = intensity(texture(tex,center + vec2(-stepx,0)));\n    float bleft = intensity(texture(tex,center + vec2(-stepx,-stepy)));\n    float top = intensity(texture(tex,center + vec2(0,stepy)));\n    float bottom = intensity(texture(tex,center + vec2(0,-stepy)));\n    float tright = intensity(texture(tex,center + vec2(stepx,stepy)));\n    float right = intensity(texture(tex,center + vec2(stepx,0)));\n    float bright = intensity(texture(tex,center + vec2(stepx,-stepy)));\n \n\t// Sobel masks (see http://en.wikipedia.org/wiki/Sobel_operator)\n\t//        1 0 -1     -1 -2 -1\n\t//    X = 2 0 -2  Y = 0  0  0\n\t//        1 0 -1      1  2  1\n\t\n\t// You could also use Scharr operator:\n\t//        3 0 -3        3 10   3\n\t//    X = 10 0 -10  Y = 0  0   0\n\t//        3 0 -3        -3 -10 -3\n \n    float x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n    float y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n    float color = sqrt((x*x) + (y*y));\n    return vec3(color,color,color);\n}\n\n/********************\n*       Kuwahara\n*********************/\n\nvec4 kuwahara(sampler2D tex, vec2 uv, vec2 resolution, int radius){\n    float n = float((radius + 1) * (radius + 1));\n    vec3 m[4];\n    vec3 s[4];\n    for (int k = 0; k < 4; ++k) {\n        m[k] = vec3(0.0);\n        s[k] = vec3(0.0);\n    }\n\n    for (int j = -radius; j <= 0; ++j)  {\n        for (int i = -radius; i <= 0; ++i)  {\n            vec3 c = texture(tex, uv + vec2(i,j) / resolution).rgb;\n            m[0] += c;\n            s[0] += c * c;\n        }\n    }\n\n    for (int j = -radius; j <= 0; ++j)  {\n        for (int i = 0; i <= radius; ++i)  {\n            vec3 c = texture(tex, uv + vec2(i,j) / resolution).rgb;\n            m[1] += c;\n            s[1] += c * c;\n        }\n    }\n\n    for (int j = 0; j <= radius; ++j)  {\n        for (int i = 0; i <= radius; ++i)  {\n            vec3 c = texture(tex, uv + vec2(i,j) / resolution).rgb;\n            m[2] += c;\n            s[2] += c * c;\n        }\n    }\n\n    for (int j = 0; j <= radius; ++j)  {\n        for (int i = -radius; i <= 0; ++i)  {\n            vec3 c = texture(tex, uv + vec2(i,j) / resolution).rgb;\n            m[3] += c;\n            s[3] += c * c;\n        }\n    }\n\n\n    float min_sigma2 = 1e+2;\n    vec4 color = vec4(0.);\n    for (int k = 0; k < 4; ++k) {\n        m[k] /= n;\n        s[k] = abs(s[k] / n - m[k] * m[k]);\n\n        float sigma2 = s[k].r + s[k].g + s[k].b;\n        if (sigma2 < min_sigma2) {\n            min_sigma2 = sigma2;\n            color = vec4(m[k], 1.0);\n        }\n    }\n    return color;\n}\n","name":"Common","description":"","type":"common"}]}