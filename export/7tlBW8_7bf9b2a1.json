{"ver":"0.1","info":{"id":"7tlBW8","date":"1651134400","viewed":284,"name":"Quadric normals","username":"breslin","description":"breslin added normals (and to show off the normals, a little texture and lighting)\n\n\n","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["quadrics","raytrace"],"hasliked":0,"parentid":"fl3SDN","parentname":"Tracing Quadrics"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//forked from https://www.shadertoy.com/view/fl3SDN\n//so i (breslin) could test calculating normals.\n\n// recommended readin':\n// A Generalization of Algebraic Surface Drawing, J. Blinn, 1982\n// http://papers.cumincad.org/data/works/att/6094.content.pdf\n// Ray Tracing Arbitrary Objects on the GPU, A. Wood et al, 2004\n// http://www.cs.otago.ac.nz/staffpriv/mccane/publications/ivcnz_2004_wood.pdf\n// Real-Time GPU Rendering of Piecewise Algebraic Surfaces, C. Loop and J. Blinn, 2006\n// http://charlesloop.com/LoopBlinn06.pdf\n\nconst mat4 cylinder = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0,-0.25\n);\n\nconst mat4 sphere = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, 4.0, 0.0, 0.0,\n    0.0, 0.0, 4.0, 0.0,\n    0.0, 0.0, 0.0,-1.0\n);\n\nconst mat4 ellipticParaboloid = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, 4.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0\n);\n\nconst mat4 hyperbolicParaboloid = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0,-4.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0\n);\n\nconst mat4 circularCone = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0,-4.0, 0.0, 0.0,\n    0.0, 0.0, 4.0, 0.0,\n    0.0, 0.0, 0.0, 0.01\n);\n\nconst mat4 quadraticPlane = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 1.0, 0.0, 0.0\n);\n\nconst mat4 hyperbolicPlane = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 2.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 2.0, 0.0, 0.0\n);\n\nconst mat4 intersectingPlanes = mat4(\n    0.0, 1.0, 0.0, 0.0,\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0\n);\n\nconst float EPSILON = 0.000001;\n\nconst int samples = 1; //per x,y per fragment\n\n//unity parlance\nfloat saturate(float f) { return clamp(f,0.,1.); }\nvec3 saturate(vec3 v) {return clamp(v,0.,1.);}\n\n// note: returns true/false bool plus an out vec3 \"point\"\nbool getPointAtTime(in float t, in vec4 ro, in vec4 rd, out vec3 point) {\n    if (t < 0.0) {\n        return false;\n    }\n\n    point = ro.xyz + t * rd.xyz;\n    \n    //constrain to a box\n    return all(greaterThanEqual(point, vec3(-0.5 - EPSILON))) && all(lessThanEqual(point, vec3(0.5 + EPSILON)));\n}\n\n//-- texture breslin ripped from iq\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*13.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash3( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash3( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nvec3 mytexture( vec3 p, vec3 n, float matid )\n{\n    p*=50.;\n\tp += 0.1;\n\tvec3 ip  = floor(p/20.0);\n\tvec3 fp  = fract(0.5+p/20.0);\n    \n    float gridSize = 5.;\n\n\tfloat id = fract(sin(dot(ip,vec3(127.1, 311.7, 74.7))) *58.5453123);\n\tid = mix( id, 0.3, matid );\n\t\n\tfloat f = mod( ip.x + mod(ip.y + mod(ip.z, 2.0), 2.0), 2.0 );\n\t\n\tfloat g = 0.5 + 1.0*noise( p * mix( vec3(0.2+0.8*f,1.0,1.0-0.8*f), vec3(1.0), matid) );\n    \n\tg *= mix( smoothstep( 0.03, 0.04, abs(fract(fp.x*gridSize)-0.5) )*\n\t          smoothstep( 0.03, 0.04, abs(fract(fp.z*gridSize)-0.5) ),\n\t\t\t  1.,\n\t\t\t  1.-smoothstep(0.,.9, saturate(sin(iTime/5.))));\n\tvec3 col = 0.5 + 0.5*sin( 1.0 + 2.0*id + vec3(0.0,1.0,2.0) );\n\treturn col * g;\n}\n//-- end texture\n\n//adapted from https://iquilezles.org/articles/intersectors\nbool intersectBox(in vec4 ro, in vec4 rd, out vec4 outPos)\n{\n    vec3 m = 1.0/rd.xyz;\n    vec3 n = m*ro.xyz;\n    vec3 k = abs(m);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return false; // no intersection\n    outPos = ro + rd * tN;\n    return true;\n}\n\n//utils\nmat4 rotateX(in float rads) {\n    return mat4(\n        1.0, 0.0,       0.0,        0.0,\n        0.0, cos(rads), -sin(rads), 0.0,\n        0.0, sin(rads), cos(rads),  0.0,\n        0.0, 0.0,       0.0,        1.0\n    );\n}\n\nmat4 rotateY(in float rads) {\n\treturn mat4(\n        cos(rads),  0.0, sin(rads), 0.0,\n        0.0,        1.0, 0.0,       0.0,\n        -sin(rads), 0.0, cos(rads), 0.0,\n        0.0,        0.0, 0.0,       1.0\n    );\n}\n\n// note: returns true/false bool, and out variable 'point'\nbool intersectQuadric(in mat4 shape, in vec4 ro, in vec4 rd, out vec3 point) {\n    vec4 rda = shape * rd;\n    vec4 roa = shape * ro;\n    \n    //quadratic equation\n    float a = dot(rd, rda);\n    float b = dot(ro, rda) + dot(rd, roa);\n    float c = dot(ro, roa);\n    \n    if (abs(a) < EPSILON) {\n        if (abs(b) < EPSILON) {\n            return getPointAtTime(c, ro, rd, point);\n        }\n        \n        return getPointAtTime(-c/b, ro, rd, point);\n    }\n\n    float square = b*b - 4.0*a*c;\n\n    if (square < EPSILON) {\n        return false; //no hit\n    }\n\n    float temp = sqrt(square);\n    float denom = 2.0 * a;\n\n    float t1 = (-b - temp) / denom;\n    float t2 = (-b + temp) / denom;\n    \n    //draw both sides but pick the closest point\n    vec3 p1 = vec3(0.0);\n    vec3 p2 = vec3(0.0);\n\n    bool hasP1 = getPointAtTime(t1, ro, rd, p1);\n    bool hasP2 = getPointAtTime(t2, ro, rd, p2);\n    \n    if (!hasP1) {\n        point = p2;\n        return hasP2;\n    }\n    \n    if (!hasP2) {\n        point = p1;\n        return true;\n    }\n\n    if (t1 < t2) {\n        point = p1;\n    } else {\n        point = p2;\n    }\n\n    return true;\n}\n\n// breslin's addition. learned from K. Perlin\nvec3 quadricSurfaceNormal(mat4 Q, vec3 P) {\n\n    float a = Q[0][0], b = Q[0][1], c = Q[0][2], d = Q[0][3],\n          e = Q[1][0], f = Q[1][1], g = Q[1][2], h = Q[1][3],\n          i = Q[2][0], j = Q[2][1], k = Q[2][2], l = Q[2][3],\n          m = Q[3][0], n = Q[3][1], o = Q[3][2];\n          \n    float x = P.x, y = P.y, z = P.z;      \n    \n    float aa = a+a, ff = f+f, kk = k+k;\n    float be = b+e, ci = c+i, gj = g+j;\n    \n    vec3 ret = vec3(\n            aa *x + be *y + ci *z + (d+m),\n            be *x + ff *y + gj *z + (h+n),\n            ci *x + gj *y + kk *z + (l+o)\n    );\n    \n    // or maybe it's clearer to write it like this:\n    ret = vec3 (\n            2.*x*Q[0][0]          + y*  (Q[0][1]+Q[1][0]) + z*  (Q[0][2]+Q[2][0]) + (Q[0][3]+Q[3][0]),\n            x*  (Q[0][1]+Q[1][0]) + 2.*y*Q[1][1]          + z*  (Q[1][2]+Q[2][1]) + (Q[1][3]+Q[3][1]),\n            x*  (Q[0][2]+Q[2][0]) + y*  (Q[1][2]+Q[2][1]) + 2.*z*Q[2][2]          + (Q[2][3]+Q[3][2])\n    );\n    \n    // if you know a better way, please share\n    \n              \n    // rotate the normals along with the objects\n    float rotAmount = iTime;\n    \n    // copied from mainImage below,\n    // where the rotation matrix is applied to the return value of DrawQuadric(),\n    // which is a vec3. so why does he use a mat4 matrix?\n    mat4 rotMatrix = rotateX(rotAmount) * rotateY(rotAmount * 0.5);\n    \n    ret = normalize((rotMatrix * vec4(ret,1.)).xyz);\n\n    vec3 cameraPos = vec3(0.,0.,1.);\n\n    // if backside, flip the normal\n    if (dot(cameraPos,ret) > 0.)\n        ret *= -1.;\n\n    return ret;\n}\n\n\nvec3 drawQuadric(in mat4 shape, in vec4 ro, in vec4 rd) {\n    vec3 collPoint = vec3(0.0);\n    \n    /* //animate the quadric paramaters, if you dare!\n    \n    shape = mat4(shape[0]*vec4(1.,1.,1.,1. + sin(iTime/5.)*.3),\n                 shape[1]*vec4(1.,1.,1.,1. + sin(iTime/5.)*.3),\n                 shape[2]*vec4(1.,1.,1.,1. + sin(iTime/5.)*.3),\n                 shape[3]*vec4(1.,1.,1.,1. + sin(iTime*5.)));\n    \n    shape = shape + mat4(\n                         sin(iTime*.02)*shape[0][0],sin(iTime*.2)*shape[0][1],sin(iTime*1.8)*shape[0][2],sin(iTime*2.8)*shape[0][3],\n                         sin(iTime*.22)*shape[1][0],sin(iTime*.4)*shape[1][1],sin(iTime*2.8)*shape[1][2],sin(iTime*4.8)*shape[1][3],\n                         sin(iTime*.42)*shape[2][0],sin(iTime*.6)*shape[2][1],sin(iTime*3.8)*shape[2][2],sin(iTime*6.8)*shape[2][3],\n                         sin(iTime*.82)*shape[3][0],sin(iTime*.8)*shape[3][1],sin(iTime*4.8)*shape[3][2],sin(iTime*8.8)*shape[3][3]\n                        );\n    */\n\n    //intersect the bounding box first and use the intersected origin for solving the quadric\n    //idea from mla: https://www.shadertoy.com/view/wdlBR2\n    if (intersectBox(ro, rd, ro) && intersectQuadric(shape, ro, rd, collPoint)) {\n\n        // breslin added the light and normal stuff here. standard stuff, just cosmetics. thanks for inspiration, iq!\n        vec3 lightPos  = normalize(vec3(sin(iTime*.1), sin(iTime*.2), -1.));\n        vec3 cameraPos = vec3(0.,0.,1.);\n        vec3 normal = quadricSurfaceNormal(shape, collPoint);\n        vec3 tex = mytexture(collPoint, normal, shape[0][0]); // use shape[0][0] as the boolean pseudorandom for texture material\n        vec3 ref = reflect(cameraPos,normal); // i.e., 2.*normal*(dot(normal, -cameraPos)) +cameraPos;\n        float fre = saturate(1.0+dot(normal, cameraPos));\n        \n        float distance = 1.;\n        \n        // ambient light\n        vec3 amb = .025*vec3(.4,.5,1.);\n        \n        // diffuse light\n        float NdotL = dot(normal, lightPos);\n        float intensity = saturate(NdotL);\n        vec3 diffuse = .85*intensity * vec3(1.,1.,.8) / distance; // really, linear falloff?\n        \n\t\t// specular light, with the Blinn-Phong half vector\n\t\tvec3 H = normalize(lightPos - cameraPos); //  half vector between the light and view vector\n\t\tfloat NdotH = saturate(dot(normal, H));\n\t\tintensity = pow(saturate(NdotH), 35.);\n\t\tfloat spec = 5.5*intensity / distance;\n        spec *= saturate(tex.r-tex.b); // make it stronger for different (colored) texture pieces\n        \n        //special purpose from rainforest example (phong, not blinn-phong):\n        //float spe = 666.6*pow(saturate(dot(ref,lightPos)), 5.0) * (0.05+.95*pow(fre, 5.)); // the last term amps backlighting rim\n            \n        float rim = .025*pow(fre,8.); // modify fresnel to use as a rim light\n\n        // sum it all up and add a color filter\n        vec3 ret = tex*(diffuse+amb+spec+rim) * vec3(1.,1.,.8);\n        \n        return ret;\n        \n    } else {\n        //otherwise return black (as the main image calls this for each shape)\n        return vec3(0.);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //camera\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0 - 1.0, 1.0);\n    rayTarget.y /= aspectRatio;\n    vec3 rayPosition = vec3(0.0, 0.0, -10.0);\n    \n    vec2 rayStep = (1.0 / iResolution.xy) / float(samples);\n    \n    //rotate all of the objects\n    float rotAmount = iTime;\n    mat4 rotMatrix = rotateX(rotAmount) * rotateY(rotAmount * 0.5);\n    \n    vec3 result = vec3(0.0);\n    \n    for (int y=0; y<samples; y++) {\n        for (int x=0; x<samples; x++) {\n            vec3 rayDir = normalize(rayTarget + vec3(rayStep * vec2(x, y), 0.0) - rayPosition);\n            vec4 newDir = vec4(rayDir, 0.0) * rotMatrix;\n\n            //quadrics\n            vec3 pixel = vec3(0.0);\n\n            pixel += drawQuadric(cylinder, vec4(rayPosition - vec3(-3.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(sphere, vec4(rayPosition - vec3(-1.5, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(ellipticParaboloid, vec4(rayPosition - vec3(0.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(hyperbolicParaboloid, vec4(rayPosition - vec3(1.5, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(circularCone, vec4(rayPosition - vec3(3.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(quadraticPlane, vec4(rayPosition - vec3(-2.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(hyperbolicPlane, vec4(rayPosition - vec3(0.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(intersectingPlanes, vec4(rayPosition - vec3(2.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n        \n            result += clamp(pixel, 0.0, 1.0);\n        }\n    }\n    \n    result /= float(samples*samples);\n    \n    result = pow(result, vec3(.4545));\n    \n    fragColor = vec4(result, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}