{"ver":"0.1","info":{"id":"DdGcWm","date":"1696179846","viewed":28,"name":"try to understandtheintroduction","username":"YLArtistry","description":"t","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["t"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// add option for color movement by time with 4 color chanels\n// vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n// break down the color chanels\nvec3 palette(float t)\n{\n    vec3 a = vec3(3., 0.5, 0.5);\n    vec3 b = vec3(-3.0, 0., 0.);\n    vec3 c = vec3(3.1, 3.1, 3.1);\n    vec3 d = vec3(0., 0.3, 0.);\n     \n    return a + b*cos(6.1*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // make ratio of screen from 'x' resolution to be beetwin 0. to 1.\n    // vec2 uv = fragCoord / iResolution.xy;\n    // make center 0.,0. from being .5, .5 and makes xy -0.5 to 0.5 from 0 to 1 \n    // uv = uv - 0.5;\n    // make xy -1. to 1 from -.5 to .5\n    // uv = uv * 2.;\n    //\n    // to make it pretty\n    // vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    //\n    // to make that d is not streached when used \n    // vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    // uv.x *= iResolution.x / iResolution.y;\n    //\n    // to make it pretty\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    // make the color palette go to the middle and not in every fract\n    vec2 uv0 = uv;\n    \n    // just letting iterations be ready?\n    vec3 finalcolor = vec3(0.0);\n    \n    // make loop of the fracts over *4 *4 *4 exc\n    for (float i = 0.0; i < 2.; i++)\n    {\n        // make double of the smaller versions\n        // uv *= 2.0;\n        // make UV coordinates in the range [0, 1]. (make smaller version od main uv)\n        // uv = fract(uv);\n        // center the uv\n        // uv -= 0.5;\n        //\n        // more elegant\n        // can change the \"uv * X\" for different maches of the patern\n        uv = fract(uv * 2.) - 0.5;\n\n        // make the uv more detailed\n        uv *= 2.0;\n\n        // make what use 'd' be 360' from 0 to 1\n        // float d = length(uv);\n        // make use of the exponential function to increase variations\n        float d = length(uv) * exp(-length(uv0));\n\n\n        // color\n        // vec3 col = vec3(.5, 0., 0.);\n        // adds the palette chanels\n        // vec3 col = palette(d);\n        // add time off set the gradient shift and evolve\n        // vec3 col = palette(d + iTime);\n        // assigning the uv0 to the palette so the color palette go to the middle and not in every fract\n        // vec3 col = palette(length(uv0) + iTime);\n        // reduce time speed\n        // vec3 col = palette(length(uv0) + iTime*.1);\n        // adds i to the palette input make a color offset\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.1);\n\n\n        // make a sin distance function (make everything inside the black ring negative and the boundery 0 and everything outside positive\n        // d -= 0.5;\n        // make a sin from the center, without parameters will make a dot\n        // d = sin(d);\n        // with parameters make the sin waves closer and rings start to show\n        // d = sin(d*8.)/8.;\n        // make a loop of rings cos the sin is moveing\n        d = sin(d*8. + iTime)/8.;\n\n        //make the negative positive (the boundery is 0)\n        d = abs(d);\n\n        // makes the transition from \"0\" to \"1\" with no 0 to 1 = no gradient\n        // d = step(0.1, d);\n        // make the transition with a gradient - the 1st is the gradient the 2nd is the transition\n        d = smoothstep(0.09, 0.1, d);\n        // some kind of inversion\n        // d = 1. / d;\n\n        // where the transition is closer to 1, the color becomes more intense, and where it's closer to 0, the color becomes more transparent.\n        // col *= d;\n        // set the ground for adding iterations\n        finalcolor += col * d;\n    }\n    \n    // set final color as the output\n    // fragColor = vec4(col, 1.);\n    // no change only type for adding iterations\n    fragColor = vec4(finalcolor, 1.);\n}\n","name":"Image","description":"","type":"image"}]}