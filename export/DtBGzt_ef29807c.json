{"ver":"0.1","info":{"id":"DtBGzt","date":"1673902185","viewed":4088,"name":"Cube Castle","username":"mhnewman","description":"CLICK FOR MORE CASTLES!\n\nEach castle is randomly generated. Click on the image!","likes":108,"published":1,"flags":32,"usePreview":0,"tags":["procedural","cube","voxel","forest","castle","fantasy","worldbuilding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/llccD2 Brute Force Accumulation.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pow(texture(iChannel0, fragCoord / iResolution.xy), vec4(0.75));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float blockSize = 4.0;\nconst float blockHeight = 5.0;\nconst float maxFloor = 7.0;\n\nfloat hash1(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2) {\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec3 p3) {\n    p3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nvec2 hash2(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 hash4(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(5.3983, 5.4427, 6.9371, 7.1283));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(5.3983, 5.4427, 6.9371, 7.1283));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 run(vec2 pos) {    \n    float height = 0.0;\n    for (int i = 0; i < 20; ++i) {\n        float id = float(i);\n        id += iTime + 0.2;\n        float top = floor(1.0 + maxFloor * hash1(id));\n        vec2 center = 12.0 * hash2(id) - 6.0;\n        vec2 size = floor(0.45 * (0.5 + hash2(id + 0.1)) * (maxFloor - top + 2.0));\n        if (pos.x > center.x - size.x &&\n            pos.x < center.x + size.x &&\n            pos.y > center.y - size.y &&\n            pos.y < center.y + size.y) {\n\n            height = max(height, top);\n        }\n    }\n    \n    vec2 center = 6.0 * hash2(iTime + 0.1) - 3.0;\n    vec2 size = vec2(1.0);\n    if (pos.x > center.x - size.x &&\n        pos.x < center.x + size.x &&\n        pos.y > center.y - size.y &&\n        pos.y < center.y + size.y) {\n\n        height = max(height, maxFloor);\n    }\n\n    return vec4(height);\n}\n\nvec4 runFlag() {\n    return vec4(floor(6.0 * hash2(iTime + 0.1) - 3.0), 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = floor(fragCoord - 0.5 * iResolution.xy);\n\n    vec4 frame = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    vec4 last = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy);\n    float restart = step(abs(frame.y - iResolution.x - iResolution.y), 0.5);\n    restart *= float(iMouse.z < 0.5 || last.z > 0.5);\n\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    vec4 flag = texture(iChannel0, vec2(0.5, 1.5) / iResolution.xy);\n    if (restart < 0.5) {\n        frame.x = step(5.0, iTime) * step(0.8, hash1(iTime));\n        fragColor = run(pos);\n        flag = runFlag();\n    }\n\n    frame.y = iResolution.x + iResolution.y;\n    frame.z = mix(1.0, frame.z + 1.0, restart);\n    frame.w = restart;\n\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n        fragColor = frame;\n    else if (fragCoord.x < 2.0 && fragCoord.y < 1.0)\n        fragColor = iMouse;\n    else if (fragCoord.x < 1.0 && fragCoord.y < 2.0)\n        fragColor = flag;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define BufA(pos) texture(iChannel0, (floor(pos + 0.5 * iResolution.xy) + 0.5) / iResolution.xy).x\n\nfloat buildWindow(vec2 pos) {\n    vec4 h = hash4(vec2(pos.x, iTime));\n    if ((h.w > 0.4 &&\n         (mod(pos.y, blockSize) == floor(0.5 * blockSize - 0.5))) ||\n        (h.w < 0.6 &&\n         (mod(pos.y, blockSize) == floor(0.5 * blockSize + 0.5)))) {\n        vec2 h2 = hash2(vec3(pos.x, floor(pos.y / blockSize), iTime));\n        float windowSize = floor(1.0 + 3.0 * h.x);\n        float windowStart = floor(0.5 + 1.5 * h.y) + floor(1.3 * h2.x);\n        float windowSkip = floor(2.0 * h.z + 0.9) + floor(1.3 * h2.y);\n        return floor(4.0 * (4.0 * windowSkip + windowStart) + windowSize);\n    }\n    return 0.0;\n}\n\nvec4 run(vec2 pos) {\n    vec2 block = floor(pos.xy / blockSize);\n    float center = BufA(block);\n    float height = blockHeight * center;\n    float window = 0.0;\n    float roof = 0.0;\n    float tree = 0.0;\n    float flag = 0.0;\n    \n    if (height > 0.5) {\n        if ((mod(pos.x, blockSize) < 0.5 && BufA(block + vec2(-1.0, 0.0)) < center) ||\n            (mod(pos.x, blockSize) > blockSize - 1.5 && BufA(block + vec2(1.0, 0.0)) < center)) {\n            height += 1.0 + mod(pos.x + pos.y, 2.0);\n            window = buildWindow(pos);\n        } else if ((mod(pos.y, blockSize) < 0.5 && BufA(block + vec2(0.0, -1.0)) < center) ||\n            (mod(pos.y, blockSize) > blockSize - 1.5 && BufA(block + vec2(0.0, 1.0)) < center)) {\n            height += 1.0 + mod(pos.x + pos.y, 2.0);\n            window = buildWindow(pos.yx);\n        } else if (hash1(vec2(height, iTime)) < 0.3) {\n            float dist = blockSize * 3.0;\n            vec2 p = pos - blockSize * block;\n            for (float x = -4.0; x < 4.5; x += 1.0) {\n                for (float y = -4.0; y < 4.5; y += 1.0) {\n                    if (BufA(block + vec2(x, y)) < center - 0.5) {\n                        float d = max(abs(blockSize * (x + 0.5) - p.x - 0.5), abs(blockSize * (y + 0.5) - p.y - 0.5));\n                        dist = min(dist, 0.6 * d - 0.1);\n                    }\n                }\n            }\n            roof = height + dist;\n        } else if (center < 2.5) {\n            bool garden = true;\n            for (float x = -1.0; x < 1.5; x += 1.0) {\n                for (float y = -1.0; y < 1.5; y += 1.0) {\n                    garden = garden && (BufA(block + vec2(x, y)) > center - 0.5);\n                }\n            }\n            if (garden) {\n                height = 0.0;\n                tree = 1.0;\n            }\n        }\n    } else {\n        for (float x = -1.0; x < 1.5; x += 1.0) {\n            for (float y = -1.0; y < 1.5; y += 1.0) {\n                vec2 offset = vec2(x, y);\n                vec2 id = block + offset;\n                float clear = 0.0;\n                for (float u = -1.0; u < 1.5; u += 1.0) {\n                    for (float v = -1.0; v < 1.5; v += 1.0) {\n                        clear += BufA(id + vec2(u, v));\n                    }\n                }\n                if (clear < 0.5 && hash1(vec3(id, iTime + 0.2)) < 0.4) {\n                    vec2 treeCenter = blockSize * hash2(vec3(id, iTime));\n                    float treeSize = 1.0 + 3.0 * hash1(vec3(id, iTime + 0.1));\n                    treeCenter += blockSize * offset;\n                    float t = treeSize - distance(treeCenter, pos.xy - blockSize * block);\n                    tree = max(tree, 4.0 * t);\n                }\n            }\n        }\n    }\n    \n    vec4 h = hash4(iTime + 0.1);\n    \n    vec4 flagCenter = texture(iChannel0, vec2(0.5, 1.5) / iResolution.xy);\n    vec2 flagPole = blockSize * flagCenter.xy + vec2(2.0, 2.0) + floor((2.0 * blockSize - 4.0) * h.xy);\n    if (pos == flagPole)\n        height = blockHeight * maxFloor + 7.0 + floor(3.0 * h.w);\n    \n    for (float y = 1.0; y < 1.5 + floor(3.0 * h.z); y += 1.0)\n        if (pos == flagPole + vec2(0.0, y))\n            flag = blockHeight * maxFloor + 6.0 + 0.25 * floor(1.0 + 3.0 * h.w);\n    \n    return vec4(height, window, roof - tree, flag);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = floor(fragCoord - 0.5 * iResolution.xy);\n\n    vec4 frame = texture(iChannel0, vec2(0.5) / iResolution.xy);\n\n    fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    if (frame.w < 0.5) {\n        fragColor = run(pos);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/llccD2 Brute Force Accumulation.\n// Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n\nconst float sphericalAberration = 0.1;\nconst float vignetting = 0.5;\nconst vec3 backgroundColor = vec3(0.0);\nconst int maxIter = 600;\nconst int shadowIter = 100;\nbool snow = false;\n\n// Set Camera will position and aim the camera.\n//   eye := The location of the camera.\n//   center := The location at which the camera is looking.\n//   focalDist := Center of focus\n//   blurAmount := Amount of depth of field\n//   Return value := Camera focal length.\nfloat setCamera(out vec3 eye, out vec3 center, out float focalDist, out float blurAmount) {\n    focalDist = 200.0;\n    blurAmount = 0.02;    \n    \n    vec2 m = vec2(0.2, 0.6);\n    m *= 6.283185 * vec2(1.0, 0.25);    \n    float dist = 220.0;\n    center = vec3(0.0, 0.0, 2.0 * blockSize);\n    eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    return 6.0;\n}\n\nbool scene(vec3 pos) {\n    vec4 buf = texture(iChannel1, (floor(pos.xy + 0.5 * iResolution.xy) + 0.5) / iResolution.xy);\n    bool castle = pos.z < buf.x;\n\n    float windowBlock = floor(pos.z / blockHeight);\n    float windowPos = pos.z - blockHeight * windowBlock;\n    float windowSize = mod(buf.y, 4.0);\n    float windowStart = mod(floor(buf.y / 4.0), 4.0);\n    float windowSkip = 1.0 + floor(buf.y / 16.0);\n    bool window = (windowPos > blockHeight - windowSize - 0.5) &&\n                  (windowBlock > windowStart - 0.5) &&\n                  (mod(windowBlock - windowStart, windowSkip) < 0.5);\n                  \n    bool roof = pos.z < buf.z;\n    bool tree = (pos.z < -buf.z && hash1(pos + 0.1) < 0.7);\n    bool flag = pos.z > floor(buf.w) - 0.5 && pos.z < buf.w + 4.0 * fract(buf.w) - 1.0;\n    return (castle && !window) || roof || tree || flag;\n}\n\n// Voxel Hit returns true if the voxel at pos should be filled.\nbool voxelHit(vec3 pos, float time) {\n    return scene(pos) || (snow && scene(pos - vec3(0.0, 0.0, 1.0)));\n}\n\n// Voxel Color returns the color at pos with normal vector norm.\nvec3 voxelColor(vec3 pos, vec3 norm) {\n    if (snow && !scene(floor(pos)))\n        return vec3(1.0);\n    vec3 p = floor(pos);\n    float h = hash1(p);\n    vec3 ground = mix(vec3(0.5, 0.3, 0.1), vec3(0.3, 0.2, 0.1), h);\n    vec3 castle = mix(vec3(0.9, 0.9, 0.85), vec3(0.7), h);\n    vec3 roof = mix(vec3(0.3, 0.4, 0.7), vec3(0.2, 0.3, 0.6), h);\n    vec3 tree = mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.5, 0.2), h);\n    vec3 flag = mix(vec3(1.0, 0.0, 0.0), vec3(0.7, 0.0, 0.0), h);\n    \n    vec4 buf = texture(iChannel1, (floor(pos.xy) + floor(0.5 * iResolution.xy) + 0.5) / iResolution.xy);\n    vec3 color = mix(roof, tree, step(buf.z, 0.0));\n    color = mix(color, flag, step(max(buf.z, -buf.z), p.z - 0.5));\n    color = mix(color, castle, step(pos.z, buf.x));\n    return mix(color, ground, step(pos.z, 0.01));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Fill in the functions above.\n// The engine below does not need to be modified.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat castRay(vec3 eye, vec3 ray, float time, int iter, out float dist, out vec3 norm) {\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    \n    vec3 dim = vec3(0.0);\n    for (int i = 0; i < iter; ++i) {\n        if (pos.z < 0.0 || voxelHit(pos, time)) {\n            dist = dot(dis - ris, dim);\n            norm = -dim * rs;\n            return 1.0;\n        }\n    \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        \n        dis += dim * ris;\n        pos += dim * rs;\n    }\n\n    if (ray.z < 0.0) {\n        dist = -eye.z / ray.z;\n        norm = vec3(0.0, 0.0, 1.0);\n        return 1.0;\n    }\n\treturn 0.0;\n}\n\nvec3 pass(vec2 coord, float time) {\n    vec3 eye, center;\n    float focalDist, blurAmount;\n    float zoom = setCamera(eye, center, focalDist, blurAmount);\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n\n    // Anti aliasing\n    vec2 hash = hash2(vec3(time, coord));\n    vec2 xy = (2.0 * (coord + hash - 0.5) - iResolution.xy) / iResolution.y;\n    \n    // Spherical aberration\n    xy /= cos(sphericalAberration * (1.0 + 0.3 * hash1(vec3(time, coord))) * length(xy));\n    \n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    // Depth of field    \n    hash = hash2(vec3(time + 0.1, coord));\n    float a = sqrt(hash.x);\n    float b = a * cos(6.283185 * hash.y);\n    float c = a * sin(6.283185 * hash.y);\n\n    vec3 target = eye + ray * focalDist / dot(ray, forward);\n    eye += focalDist * blurAmount * (b * right + c * up);\n    ray = normalize(target - eye);\n    \n    // Cast Ray\n    float dist;\n    vec3 norm;\n    float hit = castRay(eye, ray, time, maxIter, dist, norm);\n    vec3 pos = eye + dist * ray;\n\n    vec3 color = voxelColor(pos - 0.001 * norm, norm);\n    \n    // Ambient occlusion\n    pos += 0.001 * norm;\n\n    vec3 z = norm;\n    vec3 x = normalize(cross(z, vec3(-0.36, -0.48, 0.8)));\n    vec3 y = normalize(cross(z, x));\n\n    hash = hash2(vec3(time + 0.2, coord));\n    a = sqrt(hash.x);\n    b = a * cos(6.283185 * hash.y);\n    c = a * sin(6.283185 * hash.y);\n    a = sqrt(1.0 - hash.x);\n    vec3 shadeDir = b * x + c * y + a * z;\n    color *= 1.0 - castRay(pos, shadeDir, time, shadowIter, dist, norm);\n    \n    return mix(backgroundColor, color, hit);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 frame = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    snow = frame.x > 0.5;\n    \n    // Render pass\n\tvec3 color = pass(fragCoord, iTime);\n    \n    // Vignetting\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    color *= vignetting * pow((1.0 - uv.x * uv.x) * (1.0 - uv.y * uv.y), 0.2) + 1.0 - vignetting;\n    \n    // Accumulate color\n    vec3 oldColor = texture(iChannel2, fragCoord.xy / iResolution.xy).rgb;\n    fragColor = vec4(mix(oldColor, color, 1.0 / frame.z), 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}