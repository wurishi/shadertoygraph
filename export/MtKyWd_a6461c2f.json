{"ver":"0.1","info":{"id":"MtKyWd","date":"1538232749","viewed":626,"name":"Philosopher Stoned","username":"stb","description":"Mouse-enabled!","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","ray","marching","kaleidoscopic","kifs","function","system","iterated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tPhilosopher Stoned\n\tstb - late September 2018\n\n*/\n\nconst int\tMaxRaySteps\t= 128;\t\t// # ray steps b4 bailout\nconst float\tMaxDist\t\t= 3.3;\t\t// ray distance b4 bailout\nconst float\tFudgeFactor\t= 1.;\t\t// accuracy/speed\n#define\tAccuracy\t2. / iResolution.x\t// ray marching surface threshold\n#define NormAcc\t\t2. / iResolution.x\t// surface normal accuracy\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\nvoid rotateXY(inout vec3 p, vec2 axy) {\n    p.yz = rotate(p.yz, axy.y);\n    p.xz = rotate(p.xz, axy.x);\n}\n\nvec3 fold(in vec3 p, in vec3 n) {\n    n = normalize(n);\n    p -= n * max(0., 2.*dot(p, n));\n    return p;\n}\n\nfloat mapDE(in vec3 p) {\n\tfloat f;\n    \n    const float I = 64.;\n    for(float i=0.; i<I; i++) {\n        rotateXY(p, vec2(10.-.024273*iTime, .0045*iTime));\n        //p = abs(p);\n        \n        p = fold(p, vec3(1., -1., 0.));\n        p = fold(p, vec3(-1., 0., -1.));\n        p -= .125*.025 / ((i+1.)/I);\n        \n    }\n    \n    f = length(p)-.007;\n    return f;\n}\n\nvec3 mapSky(in vec3 p) {\n    p = normalize(p);\n    return\n        max(\n            vec3(0.),\n            1.25 * vec3(1., 1.2, 1.5)\n            * vec3(.5+.25*(sin(3.*p.x)+sin(3.*p.y)))\n            + vec3(.4, .2, .1)\n            - .25\n       \t);\n}\n\nvec3 getNorm(vec3 p) {\n\tvec3 d = vec3(NormAcc, -NormAcc, 0.);\n    return normalize(vec3(mapDE(p+d.xzz) - mapDE(p+d.yzz), mapDE(p+d.zxz) - mapDE(p+d.zyz), mapDE(p+d.zzx) - mapDE(p+d.zzy)));\n}\n\n// uses iq's soft shadows\n/*float getShadow(vec3 hit, vec3 lightDir, float lightDist) {\n\tfloat dist;\n\tfloat k = 132.; // shadow hardness\n\tfloat totalDist = 2. / k; // starting distance based on shadow hardness\n\tfloat res = 1.;\n\tfor(int steps=0; steps<MaxRaySteps; steps++) {\n\t\tvec3 P = hit + totalDist * lightDir;\n\t\tdist = mapDE(P);\n\t\tif(dist < Accuracy) return 0.;\n        if(totalDist >= min(MaxDist, lightDist)) break;\n\t\tres = min(res, k*dist/float(steps));\n\t\ttotalDist += dist;\n\t}\n\treturn res;\n}*/\n\n// source lost; if this is yours, speak up :)\nfloat getAO(vec3 hit, vec3 norm) {\n    const float ns = 16.;\n    float AO = 0.;\n    float d = .1;\n    for(float i=1.; i<ns; i++) {\n    \tfloat dist = mapDE(hit+d*norm*i/ns);\n        AO += .875 * ns / d * dist / i;\n    }\n    return clamp(AO/ns, 0., 1.);\n}\n\n\n// returns last and total distances from a ray traced from camPos to rayDir\nvec2 march(vec3 camPos, vec3 rayDir) {\n\tfloat dist;\n\tfloat totalDist = 0.;\n\tvec3 p;\n\tfor(int steps=0; steps<MaxRaySteps; steps++) {\t\n\t\tp = camPos + totalDist * rayDir;\n\t\tdist = mapDE(p) * FudgeFactor;\n        totalDist += dist;\n\t\tif(dist<Accuracy || totalDist>MaxDist) break;\n\t}\n    return vec2(dist, totalDist);\n    \n}\n\nvec3 getColor(vec3 hit, vec3 rayDir, vec2 dists) {\n    \n    vec3 col = vec3(0.);\n    \n    // a surface was hit, do some shading\n    if(dists.x < Accuracy) {\n\t\tvec3 norm = getNorm(hit);\n\n        vec3 diffuse = vec3(1., .7, .5) * mapSky(norm);\n        \n        // angle of incidence\n        float aoi = pow(1.-dot(norm, -rayDir), 1.);\n        \n        // ambient occlusion\n        float ao = pow(getAO(hit, norm), 4.) * 2.;\n        \n        // initial color\n        col = diffuse;\n        \n        // reflected sky\n        vec3 ref = mapSky(normalize(reflect(rayDir, norm)));\n\t\t\n        // mix in reflections\n        col = mix(col, ref, aoi);\n        \n        // apply ao\n        col *= ao;\n        \n        // mix sky into color (fog effect)\n        col = mix(col, mapSky(rayDir), pow(dists.y/MaxDist, 2.));\n        \n    } else {\n        // return sky only, for there's nothing else\n        col = mapSky(rayDir);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv\t\t= (fc-.5*res) / res.y;\n    vec2 mPos\t= (iMouse.xy-.5*res) / res.y;\n\t\n    vec3 rayBeg\t\t= vec3(0., 0., -3.);\n    vec3 rayDir\t\t= normalize(vec3(uv, 1.*2.));\n    \n    vec2 camRotXY = iMouse.z > 0. ? 4. * mPos.xy : vec2(.75+.0353*iTime, .75+.0485*iTime);\n    rotateXY(rayBeg, camRotXY);\n    rotateXY(rayDir, camRotXY);\n    \n    vec2 dists\t= march(rayBeg, rayDir);\n    vec3 hit\t= rayBeg + dists.y * rayDir;\n    vec3 col = getColor(hit, rayDir, dists);\n    \n\tfo = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}