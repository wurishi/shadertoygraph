{"ver":"0.1","info":{"id":"ctdGWl","date":"1683336968","viewed":143,"name":"lil' 2D guy just walkin' around","username":"jakecariello","description":"answers the question: how would a 2d actor see?\n\nTODO:\n- clean up the redundant code for buildScene / drawing (need to consolidate these)\n- comes with the above, but gotta do optimization bc this is slowwww + redundant","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["inprogress"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    B_BUFF[0] = vec2(-.4 * A, .9 * A);\n    B_BUFF[1] = vec2(-.8 * A, .8 * A);\n    B_BUFF[2] = vec2(-.10 * A, .3 * A);\n    B_BUFF[3] = vec2(-.9 * A, .4 * A);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n\n    \n    float theta = 2. * PI * iTime / 5.;\n    vec2 l = lem(A * .9, theta);\n    vec2 tl = tanLem(A * .9, theta);\n    vec3 col = vec3(0);\n    \n    for (float t = -PI / 2.; t < PI / 2.; t += (2. * PI / 2.) / 10.) {\n        vec4 rm = rayMarch(l, r2(t) * tl);\n        col += rm.rgb * line(uv, l, l + rm.w * r2(t) * tl, MARKER_WEIGHT / 2.);\n    }\n    \n    col += vec3(1, 0, 0) * line(uv, vec2(-A, A), vec2(-A, -A));\n    col += vec3(0, 1, 0) * line(uv, vec2(A, A), vec2(A, -A));\n    col += vec3(0, 0, 1) * line(uv, vec2(A, -A), vec2(-A, -A));\n    col += vec3(1, 1, 0) * line(uv, vec2(A, A), vec2(-A, A));\n    \n    col += vec3(.6, 1, 1) * circle(uv, vec2(A * .75), .1);\n    col += vec3(1, .6, 1) * circle(uv, vec2(-A * .75), .1);\n   \n    col += vec3(.6, .6, 1) * circle(uv, vec2(-A * .6, 0.), .05);\n    col += vec3(1, .6, .6) * circle(uv, vec2(A * .6, 0.), .05);\n    \n    col += vec3(1) * circleFill(uv, l, .02);\n    \n    col += vec3(.6, 1, .6) * bezier(uv, 4, 8, .00025); // p, N, steps, r\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define A 0.45\n\n#define PI 3.14159265\n#define S(a, b, t) smoothstep(a, b, t)\n#define MARKER_WEIGHT .01\n\n// for ray marching\n#define MAX_STEPS 20\n#define EPSILON .01\n#define MAX_DIST 10.\n#define K_FACTOR 0.\n\n\nmat2 r2(float theta) {\n    float s = sin(theta), c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n// lemniscate!\n// (r^2) = (a^2) * cos(2 * theta)\n// parametric equation from: https://archive.lib.msu.edu/crcmath/math/math/l/l200.htm\nvec2 lem(float a, float theta) {\n    return vec2(\n        a * cos(theta) / (1. + pow(sin(theta), 2.)),\n        a * sin(theta) * cos(theta) / (1. + pow(sin(theta), 2.)));\n}\n\n// normalized tangent to lemniscate!\nvec2 tanLem(float a, float theta) {\n    vec2 here = lem(a, theta);\n    vec2 ahead = lem(a, theta + EPSILON);\n    return normalize(ahead - here);\n}\n\n// random 2d -> 1d\nfloat rand21(vec2 v){\n  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// map HSL -> RGB\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n#define B_MAX_N 10\n// compute iterative N-bezier, return point at t\n// NOTE: to use this method, set B_BUFF to control points (B_STATE is overwritten internally)\nvec2 B_BUFF[B_MAX_N], B_STATE[B_MAX_N];\nvec2 bezier(int N, float t) {\n    for (int i = 0; i < N; i += 1) {\n        B_STATE[i] = B_BUFF[i];\n    }\n    for (int n = N; n > 0; n -= 1) {\n        for (int i = 0; i < N - 1; i += 1) {\n            B_STATE[i] = mix(B_STATE[i], B_STATE[i + 1], t);\n        }\n    }\n    return B_STATE[0];\n}\n\n// smoothmin function for metaball effect\n// from: https://github.com/glslify/glsl-smooth-min/blob/master/poly.glsl\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\nvec4 smin(vec4 a, vec4 b, float k) {\n  vec4 h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n///// SIGNED DISTANCE FUNCTIONS (for drawing + ray marching)\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    vec2 c = a + ba * t;\n    return length(c - p) - r;\n}\n\nfloat sdBezier(vec2 p, int N, int steps, float r) {\n    float d = MAX_DIST;\n    vec2 previous = B_BUFF[0];\n    for(int step = 0; step <= steps; step += 1) {\n        float s = float(step) / float(steps);\n        vec2 current = bezier(N, s);\n        d = smin(d, sdLine(p, previous, current, r), K_FACTOR);\n        previous = current;\n    }\n    return d;\n}\n\n///// DRAWING UTILS\nfloat circle(vec2 p, vec2 c, float r) {\n    float d =  sdCircle(p, c, r); \n    return S(-MARKER_WEIGHT / 2., 0., d) * S(MARKER_WEIGHT / 2., 0., d);\n}\n\nfloat circleFill(vec2 p, vec2 c, float r) {\n    float d =  sdCircle(p, c, r); \n    return S(MARKER_WEIGHT / 2., 0., d);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float r) {\n    return S(r / 2., 0., sdLine(p, a, b, 0.));\n}\nfloat line(vec2 p, vec2 a, vec2 b) { return line(p, a, b, MARKER_WEIGHT); }\n\nfloat bezier(vec2 p, int N, int steps, float r) {\n    return S(MARKER_WEIGHT, 0., sdBezier(p, N, steps, r));\n}\n\n///// RAY MARCHING UTILS\n// scene = (r, g, b, d), where d is distance\nvoid add(inout vec4 scene, vec4 object) {\n    float dd = object.w - scene.w;\n    scene.rgb = mix(scene.rgb, object.rgb, S(.01, -.01, dd));\n    scene.w = smin(scene.w, object.w, K_FACTOR);\n}\n\n// distance from p to the scene's surfaces, initialized with floor plane\nvec4 buildScene(vec2 p) {\n    //vec4 scene = vec4(vec3(1), abs(p.y - .5));\n    //add(scene, vec4(vec3(1), abs(p.y + .5)));\n    vec4 scene = vec4(vec3(1.), sdLine(p, vec2(-.5, 100.), vec2(-.5, -100.), MARKER_WEIGHT / 2.));\n    add(scene, vec4(vec3(1.), sdLine(p, vec2(.5, 100.), vec2(.5, -100.), MARKER_WEIGHT / 2.)));\n    //add(scene, vec4(vec3(1, 0, 0), sdSphere(p, vec4(0, 2, 1, 0.5))));\n    \n    add(scene, vec4(vec3(1, 0, 0), sdLine(p, vec2(-A, A), vec2(-A, -A), MARKER_WEIGHT / 2.)));\n    add(scene, vec4(vec3(0, 1, 0), sdLine(p, vec2(A, A), vec2(A, -A), MARKER_WEIGHT / 2.)));\n    add(scene, vec4(vec3(0, 0, 1), sdLine(p, vec2(A, -A), vec2(-A, -A), MARKER_WEIGHT / 2.)));\n    add(scene, vec4(vec3(1, 1, 0), sdLine(p, vec2(A, A), vec2(-A, A), MARKER_WEIGHT / 2.)));\n    \n    add(scene, vec4(vec3(.6, 1, 1), sdCircle(p, vec2(A * .75), .1)));\n    add(scene, vec4(vec3(1, .6, 1), sdCircle(p, vec2(-A * .75), .1)));\n    add(scene, vec4(vec3(.6, .6, 1), sdCircle(p, vec2(-A * .6, 0.), .05)));\n    add(scene, vec4(vec3(1, .6, .6), sdCircle(p, vec2(A * .6, 0.), .05)));\n    \n    add(scene, vec4(vec3(.6, 1, .6), sdBezier(p, 4, 5, .00025)));\n    \n    //add(scene, vec4(vec3(0, 1, 0), sdCapsule(p, vec3(1, 1, 0), vec3(3, 1, 0), .25)));\n    //add(scene, vec4(vec3(0, 0, 1), sdTorus(p, vec3(0, 2. * (sin(iTime) + 1.) / 2., 0), vec2(2., .25))));\n    //add(scene, vec4(vec3(1, 1, 0), sdCube(p, vec4(-3, 2, 0, 1))));\n    //add(scene, vec4(vec3(0, 1, 1), sdCylinder(p, \n    //    vec3(1. + 2. * sin(iTime), 2, 1. + 2. * cos(iTime)), vec3(1. - 2. * sin(iTime), 2, 1. - 2. * cos(iTime)), .25)));\n\n    return scene;\n}\n\n// perform a ray march from ro in direction rd\n// ro: ray origin\n// rd: ray direction\nvec4 rayMarch(vec2 ro, vec2 rd) {\n    vec4 L = vec4(0);\n    float dL = 2. * EPSILON;\n    vec2 dir = normalize(rd), p = ro;\n    for (int i = 0; i < MAX_STEPS; i += 1) {\n        vec4 scene = buildScene(p);\n        dL = scene.w;\n        L.rgb = scene.rgb;\n        L.w += dL;\n        if (L.w > MAX_DIST || dL < EPSILON) break;\n        p = ro + dir * L.w;\n    }\n    return L;\n}\n\n// surface normal at point P\n// calculates 3D \"gradient\" (surface normal points along gradient)\nvec2 normal(vec2 p) {\n    float d = buildScene(p).w;\n    vec2 e = vec2(EPSILON, 0);\n    vec2 g = d - vec2(\n        buildScene(p - e.xy).w,\n        buildScene(p - e.yx).w);\n    vec2 n = vec2(g.y, -g.x);\n    //#ifdef FUZZ\n    //float fuzz = FUZZ_AMPLITUDE * (cos(2. * PI * iTime / 4. * FUZZ_FREQ)  + 1.) / 2.;\n    //#else\n    //float fuzz = 0.;\n    //#endif\n    //n = (rotate(c, fuzz * PI / 2. * ((rand21(n.xy + n.xz + p.yz) - .5))) * vec4(n, 1)).xyz;\n    return normalize(n);\n}\n\n// calculate lighting value at point p for light position l\nfloat light(vec2 p, vec2 l) {\n    vec2 lp = l - p;\n    vec2 n = normal(p);\n    // diffuse light: measures \"alignment\" between...\n    // 1. lp: unit vector pointing from point to light source\n    // 2: n: the point's surface unit normal\n    // maximized when n == lp\n    float diff = clamp(dot(n, normalize(lp)), 0., 1.);\n    // distance to light from p (need to offset away from surface to prevent ray marching prematurely exiting)\n    float dl = rayMarch(p + n * EPSILON * 2., lp).w;\n    if (dl < length(lp)) diff *= .4;\n    return clamp(diff, .2, 1.);  \n}\n","name":"Common","description":"","type":"common"}]}