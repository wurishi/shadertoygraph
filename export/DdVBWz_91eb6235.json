{"ver":"0.1","info":{"id":"DdVBWz","date":"1699567982","viewed":28,"name":"RayTracer - M1 Info - Lyon 1","username":"p1907354","description":"Master 1 Informatique UniversitÃ© Claude Bernard Lyon 1- UE Informatique graphique - Lancer de rayon \n\n","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["raytracer","phong","tranformation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*------------- CONSTANTS -------------*/\n\n#define PI 3.1415926535\n#define MAX_BOUNCES 3 // 1 => no reflection \n#define EPSILONE 1e-3\n#define OCC_LEN 8.\n\n/*-------------------------------------*/\n/*------------- EXTERNALS -------------*/\n// copy from https://www.shadertoy.com/view/4sc3z2\n#define MOD3 vec3(.18001,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n// copy from https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat hash( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n/*-------------------------------------*/\n/*-------- Objects Definitions --------*/\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int iMat;\n    mat4 transform;\n};\n\nstruct Plane{\n    vec3 normal;\n    vec3 point;\n    int iMat;\n    mat4 transform;\n};\n\nstruct Cylinder{ \n    vec3 min; \n    vec3 max; \n    float radius; \n    int iMat;\n    mat4 transform;\n};\n\nstruct Capsule{\n    vec3 min;\n    vec3 max;\n    float radius;\n    int iMat;\n    mat4 transform;\n};\n\nstruct Ellipsoid{\n    vec3 center;\n    vec3 abc;\n    int iMat;\n    mat4 transform;\n};\n\nstruct Circle{\n    vec3 center;\n    vec3 normal;\n    float radius;\n    int iMat;\n    mat4 transform;\n};\n\nstruct Cube \n{\n    vec3 min; // minimum position\n    vec3 max; // maximum position \n    int iMat;\n    mat4 transform;\n};\n\nvec3 center(vec3 min,vec3 max) {\n    return (min+max)/2.;\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Hit {\n    float time;\n    vec3 normal;\n    vec3 obj_point;\n    vec3 center;\n    int iMat;\n};\n\nstruct Light {\n    bool is_directional;\n    // Directional Light Source\n    vec3 direction;\n    // point Light Source\n    vec3 origin;\n    vec3 intensity;\n};\n\nstruct Material {\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n\n    float shininess;\n    float roughness;\n    float transparency;\n    float refractive_i;\n};\n\nstruct Pattern {\n    vec3 color;\n    mat4 transform;\n};\n\n/*-------------------------------------*/\n/*-------- Transform Functions --------*/\n\n// Identity Matrix\nmat4 mat_i() {\n    return mat4(1.);\n}\n\n// Translation Matrix\nmat4 mat_t(vec3 t) {\n    return mat4(\n        vec4(1.  ,0.  ,0.  ,0.), // first column\n        vec4(0.  ,1.  ,0.  ,0.), // second column\n        vec4(0.  ,0.  ,1.  ,0.), // third column\n        vec4(t.x ,t.y ,t.z ,1.)  // fourth column\n    );\n}\n\n// Scale Matrix\nmat4 mat_s(vec3 s) {\n    return mat4(\n        vec4(s.x, 0. , 0. , 0.), // first column\n        vec4(0. , s.y, 0. , 0.), // second column\n        vec4(0. , 0. , s.z, 0.), // third column\n        vec4(0. , 0. , 0. , 1.)  // fourth column\n    );\n}\n\n// Transformation Matrix \n// the object is replaced at \n// the origin of the world\n// o: center of the transformed object  \nmat4 mat_tMt(vec3 o, mat4 M) {\n    return mat_t(o) * M * mat_t(-o);\n}\n\n// X-axis Rotation Matrix\nmat4 mat_rx(float r) {\n    return mat4(\n        vec4(1.,0.     ,0.    ,0.),\n        vec4(0.,cos(r) ,sin(r),0.),\n        vec4(0.,-sin(r),cos(r),0.),\n        vec4(0.,0.     ,0.    ,1.)\n    );\n}\n\n// Y-axis Rotation Matrix\nmat4 mat_ry(float r) {\n    return mat4(\n        vec4(cos(r),0.,-sin(r),0.),\n        vec4(0.    ,1.,0.     ,0.),\n        vec4(sin(r),0.,cos(r) ,0.),\n        vec4(0.    ,0.,0.     ,1.)\n    );\n}\n\n// Z-axis Rotation Matrix\nmat4 mat_rz(float r) {\n    return mat4(\n        vec4(cos(r) ,sin(r),0.,0.),\n        vec4(-sin(r),cos(r),0.,0.),\n        vec4(0.     ,0.    ,1.,0.),\n        vec4(0.     ,0.    ,0.,1.)\n    );\n}\n\n// U-axis Rotation Matrix\nmat4 mat_ru(vec3 u,float theta) {\n    float ic=1.-cos(theta);\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat4(\n        vec4(u.x*u.x*ic+c    ,u.x*u.y*ic+s*u.z,u.x*u.z*ic-s*u.y,0.),\n        vec4(u.x*u.y*ic-s*u.z,u.y*u.y*ic+c    ,u.y*u.z*ic+s*u.x,0.),\n        vec4(u.x*u.z*ic+s*u.y,u.y*u.z*ic-s*u.x,u.z*u.z*ic+c    ,0.),\n        vec4(0.              ,0.              ,0.              ,1.)\n    );\n}\n\n// Shearing transformation\nmat4 mat_sh(float xy,float xz,float yx,float yz,float zx,float zy) {\n    return mat4(\n        vec4(1.,yx,zx,0.),\n        vec4(xy,1.,zy,0.),\n        vec4(xz,yz,1.,0.),\n        vec4(0.,0.,0.,1.)\n    );\n}\n\n// Transform point p with matrix M  \nvec4 transform_p(vec3 p,mat4 M) {\n    return M*vec4(p,1.);\n}\n\n// Transform point p with inverse matrix of M  \nvec4 transform_pi(vec3 p,mat4 M) {\n    mat4 Mi=inverse(M);\n    return Mi*vec4(p,1.);\n}\n\n// Transform normal vector n with matrix M  \nvec4 transform_nit(vec3 n,mat4 M) {\n    mat4 Mi=inverse(M);\n    mat4 MiT=transpose(Mi);\n    return MiT*vec4(n,0.);\n}\n\n// Transform direction vector d with matrix M  \nvec4 transform_d(vec3 d,mat4 M) {\n    return M*vec4(d,0.);\n}\n\n// Transform direction vector d with inverse matrix of M  \nvec4 transform_di(vec3 d,mat4 M) {\n    mat4 Mi=inverse(M);\n    return Mi*vec4(d,0.);\n}\n\n// Return new ray transformed by M   \nRay transform_ray(Ray ray,mat4 M) {\n    vec3 origin=transform_pi(ray.origin,M).xyz;\n    vec3 direction=transform_di(ray.direction,M).xyz;\n    return Ray(origin,direction);\n}\n\n/*-------------------------------------*/\n/*-------- Intersect Functions --------*/\n\n// P(t) = o+d*t\nvec3 point(Ray r,float t) {\n    return r.origin + r.direction*t;\n}\n\n// Sphere intersection\n// ray : The ray\n// hit : Returned intersection information\nbool intersect(Sphere sph,Ray ray,out Hit hit) {\n    Ray obj_space_ray=transform_ray(ray,sph.transform);\n\n    vec3 oc=obj_space_ray.origin-sph.center;\n    float a=dot(obj_space_ray.direction,obj_space_ray.direction);\n    float b=2.*dot(oc,obj_space_ray.direction);\n    float c=dot(oc,oc)-sph.radius*sph.radius;\n    float d=b*b-4.*a*c;\n    if(d>0.) {\n        float t=(-b-sqrt(d))/(2.*a);\n        if(t>0.) {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            vec3 obj_space_n=normalize(obj_space_p-sph.center);\n            vec3 wld_space_n=normalize(transform_nit(obj_space_n,sph.transform).xyz);\n            if (dot(wld_space_n,-ray.direction) < 0.) { \n                wld_space_n=-wld_space_n;\n            }\n            hit=Hit(t,wld_space_n,obj_space_p,sph.center,sph.iMat);\n            \n            return true;\n        }\n    }\n    \n    return false;\n}\n\n// Plane intersection\n// ray : The ray\n// hit : Returned intersection information\nbool intersect(Plane pln,Ray ray,out Hit hit)\n{\n    Ray obj_space_ray=transform_ray(ray,pln.transform);\n    float t=-dot(obj_space_ray.origin-pln.point,pln.normal)/dot(obj_space_ray.direction,pln.normal);\n    if(t>0.)\n    {\n        vec3 obj_space_p=point(obj_space_ray,t);\n        vec3 wld_space_n=normalize(transform_nit(pln.normal,pln.transform).xyz);\n        hit=Hit(t,wld_space_n,obj_space_p,pln.point,pln.iMat);\n        return true;\n    }\n    return false;\n}\n\nvoid swap(inout float a,inout float b)\n{\n    float buff=a;\n    a=b;\n    b=buff;\n}\n\n// Cube intersection\n// ray : The ray\n// hit : Returned intersection information\nbool intersect(Cube cbe,Ray ray,inout Hit hit) \n{\n    Ray obj_space_ray=transform_ray(ray,cbe.transform);\n\n    /*x axis*/\n    float txMin=(cbe.min.x-obj_space_ray.origin.x)/obj_space_ray.direction.x;\n    float txMax=(cbe.max.x-obj_space_ray.origin.x)/obj_space_ray.direction.x;\n    if(txMin>txMax) swap(txMin,txMax);\n\n    /*y axis*/\n    float tyMin=(cbe.min.y-obj_space_ray.origin.y)/obj_space_ray.direction.y;\n    float tyMax=(cbe.max.y-obj_space_ray.origin.y)/obj_space_ray.direction.y;\n    if(tyMin>tyMax) swap(tyMin,tyMax);\n\n    /*z axis*/\n    float tzMin=(cbe.min.z-obj_space_ray.origin.z)/obj_space_ray.direction.z;\n    float tzMax=(cbe.max.z-obj_space_ray.origin.z)/obj_space_ray.direction.z;\n    if(tzMin>tzMax) swap(tzMin,tzMax);\n\n    vec3 n; // normal\n\n    /* get greatest min and max */\n    float tMin=txMin;\n    if(obj_space_ray.direction.x>0.) \n    {\n        n=vec3(-1,0,0);\n    } else {\n        n=vec3(1,0,0);\n    }\n\n    float tMax=(txMax<tyMax) ? txMax:tyMax;\n    if(tyMin>tMin)\n    {\n        tMin=tyMin;\n        if(obj_space_ray.direction.y>0.)\n        {\n            n=vec3(0,-1,0);\n        } else {\n            n=vec3(0,1,0);\n        }\n    }\n\n    if(txMin>tyMax || tyMin>txMax) return false;\n    if(tMin>tzMax || tzMin>tMax) return false;\n\n    if(tzMin>tMin) \n    {\n        tMin=tzMin;\n        if(obj_space_ray.direction.z>0.)\n        {\n            n=vec3(0,0,-1);\n        } else {\n            n=vec3(0,0,1);\n        }\n    }\n    if(tzMax<tMax) tMax=tzMax;\n\n    if(tMin<=0.) return false;\n\n    vec3 obj_space_p=point(obj_space_ray,tMin);\n    vec3 wld_space_n=normalize(transform_nit(n,cbe.transform).xyz);\n    hit=Hit(tMin,wld_space_n,obj_space_p,center(cbe.min,cbe.max),cbe.iMat);\n\n    return true;\n}\n\nbool intersect(Ellipsoid ell,Ray ray,out Hit hit) {\n    Ray obj_space_ray=transform_ray(ray,ell.transform);\n    \n    vec3 co=obj_space_ray.origin-ell.center;\n    vec3 inv=1./(ell.abc*ell.abc);\n    float a=dot(obj_space_ray.direction*obj_space_ray.direction,inv);\n    float b=2.*dot((co)*obj_space_ray.direction,inv);\n    float c=dot(co*co,inv)-1.;\n\n    float d=b*b-4.*a*c;\n\n    if(d>0.) {\n        float t=(-b-sqrt(d))/(2.*a);\n\n        if(t>0.) {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            vec3 obj_space_n=normalize((obj_space_p-ell.center)/(ell.abc*ell.abc));\n            vec3 wld_space_n=normalize(transform_nit(obj_space_n,ell.transform).xyz);\n            hit=Hit(t,wld_space_n,obj_space_p,ell.center,ell.iMat);\n            \n            return true;\n        }\n    }\n    hit.time=-1.;\n    return false;\n}\n\n// Circle intersection\n// ray : The ray\n// hit : Returned intersection information\nbool intersect(Circle clc,Ray ray,out Hit hit)\n{\n    Ray obj_space_ray=transform_ray(ray,clc.transform);\n\n    float t=-dot(obj_space_ray.origin-clc.center,clc.normal)/dot(obj_space_ray.direction,clc.normal);\n    if(t>0.)\n    {\n        vec3 obj_space_p=point(obj_space_ray,t);\n        vec3 op=obj_space_p-clc.center;\n        if(length(op)<=clc.radius) \n        {\n            vec3 wld_space_n=normalize(transform_nit(clc.normal,clc.transform).xyz);\n            hit=Hit(t,wld_space_n,obj_space_p,clc.center,clc.iMat);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    return false;\n}\n\n// Cylinder intersection\n// ray : The ray\n// hit : Returned intersection information\nbool intersect(Cylinder cyl,Ray ray,out Hit hit) {\n    Ray obj_space_ray=transform_ray(ray,cyl.transform);\n    float nx=obj_space_ray.origin.x-cyl.min.x;\n    float ny=obj_space_ray.origin.y-cyl.min.y;\n    float a=obj_space_ray.direction.x*obj_space_ray.direction.x+obj_space_ray.direction.y*obj_space_ray.direction.y;\n    float b=2.*(nx*obj_space_ray.direction.x+ny*obj_space_ray.direction.y);\n    float c=nx*nx+ny*ny-cyl.radius*cyl.radius;\n    float d=b*b-4.*a*c;\n    if(d>0.)\n    {\n        float t=(-b-sqrt(d))/(2.*a);\n        if(t>0.)\n        {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            if(obj_space_p.z>cyl.min.z && obj_space_p.z<cyl.max.z) {\n                vec3 cyBT=cyl.max-cyl.min;//bot->top\n                vec3 proj=cyl.min+(dot(cyBT,obj_space_p-cyl.min)/dot(cyBT,cyBT))*cyBT;\n                vec3 obj_space_n=normalize(obj_space_p-proj);\n                vec3 wld_space_n=normalize(transform_nit(obj_space_n,cyl.transform).xyz);\n                hit=Hit(t,wld_space_n,obj_space_p,center(cyl.min,cyl.max),cyl.iMat);\n                return true;\n            }\n        }\n    }\n    \n    if(obj_space_ray.direction.z>0.) {\n        float t=-dot(obj_space_ray.origin-cyl.min,vec3(0.,0.,-1.))/dot(obj_space_ray.direction,vec3(0.,0.,-1.));\n        if(t>0.)\n        {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            vec3 op=obj_space_p-cyl.min;\n            if(length(op)<=cyl.radius) \n            {\n                vec3 wld_space_n=normalize(transform_nit(vec3(0.,0.,-1.),cyl.transform).xyz);\n                hit=Hit(t,wld_space_n,obj_space_p,center(cyl.min,cyl.max),cyl.iMat);\n                return true;\n            }\n        }\n    } else {\n        float t=-dot(obj_space_ray.origin-cyl.max,vec3(0.,0.,1.))/dot(obj_space_ray.direction,vec3(0.,0.,1.));\n        if(t>0.)\n        {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            vec3 op=obj_space_p-cyl.max;\n            if(length(op)<=cyl.radius) \n            {\n                vec3 wld_space_n=normalize(transform_nit(vec3(0.,0.,1.),cyl.transform).xyz);\n                hit=Hit(t,wld_space_n,obj_space_p,center(cyl.min,cyl.max),cyl.iMat);\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Capsule intersection\n// ray : The ray\n// hit : Returned intersection information\nbool intersect(Capsule cap,Ray ray,out Hit hit) {\n    bool ret=false;\n    Ray obj_space_ray=transform_ray(ray,cap.transform);\n    float nx=obj_space_ray.origin.x-cap.min.x;\n    float ny=obj_space_ray.origin.y-cap.min.y;\n    float a=obj_space_ray.direction.x*obj_space_ray.direction.x+obj_space_ray.direction.y*obj_space_ray.direction.y;\n    float b=2.*(nx*obj_space_ray.direction.x+ny*obj_space_ray.direction.y);\n    float c=nx*nx+ny*ny-cap.radius*cap.radius;\n    float d=b*b-4.*a*c;\n    if(d>0.) {\n        float t=(-b-sqrt(d))/(2.*a);\n        if(t>0.) {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            if(obj_space_p.z>=cap.min.z && obj_space_p.z<=cap.max.z) {\n                vec3 u=cap.max-cap.min;\n                vec3 proj=cap.min+(dot(u,obj_space_p-cap.min)/dot(u,u))*u;\n                vec3 obj_space_n=normalize(obj_space_p-proj);\n                vec3 wld_space_n=normalize(transform_nit(obj_space_n,cap.transform).xyz);\n                hit=Hit(t,wld_space_n,obj_space_p,center(cap.min,cap.max),cap.iMat);\n                ret=true;\n            } \n        }\n    }\n    \n    // semi sphere\n    vec3 oc=obj_space_ray.origin-cap.min;\n    a=dot(obj_space_ray.direction,obj_space_ray.direction);\n    b=2.*dot(oc,obj_space_ray.direction);\n    c=dot(oc,oc)-cap.radius*cap.radius;\n    d=b*b-4.*a*c;\n    if(d>0.) {\n        float t=(-b-sqrt(d))/(2.*a);\n        if(t>0.) {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            vec3 obj_space_n=normalize(obj_space_p-cap.min);\n            vec3 wld_space_n=normalize(transform_nit(obj_space_n,cap.transform).xyz);\n            if(dot(obj_space_n,vec3(0,0,-1))<0.) ret=false;\n            Hit h=Hit(t,wld_space_n,obj_space_p,center(cap.min,cap.max),cap.iMat);\n            if(hit.time>h.time) hit=h;\n            ret=true;\n        }\n    }\n    \n    // semi sphere\n    oc=obj_space_ray.origin-cap.max;\n    a=dot(obj_space_ray.direction,obj_space_ray.direction);\n    b=2.*dot(oc,obj_space_ray.direction);\n    c=dot(oc,oc)-cap.radius*cap.radius;\n    d=b*b-4.*a*c;\n    if(d>0.) {\n        float t=(-b-sqrt(d))/(2.*a);\n        if(t>0.) {\n            vec3 obj_space_p=point(obj_space_ray,t);\n            vec3 obj_space_n=normalize(obj_space_p-cap.max);\n            vec3 wld_space_n=normalize(transform_nit(obj_space_n,cap.transform).xyz);\n            if(dot(obj_space_n,vec3(0,0,1))<0.) ret=false;\n            Hit h=Hit(t,wld_space_n,obj_space_p,center(cap.min,cap.max),cap.iMat);\n            if(hit.time>h.time) hit=h;\n            ret=true;\n        }\n    }\n    \n    return ret;\n}\n\n\nSphere sph;\nPlane pln;\nPlane pln2;\nPlane pln3;\nCube cbe;\nCube cbe2;\nCylinder cyl;\nCapsule cap;\nEllipsoid ell;\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool intersect(Ray ray,out Hit hit)\n{\n    hit=Hit(1000.,vec3(0),vec3(0.),vec3(0.),-1);\n    Hit current;\n    bool ret=false;\n\n    if(intersect(sph,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    if(intersect(ell,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    if(intersect(pln,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    if(intersect(pln2,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    if(intersect(pln3,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    if(intersect(cbe,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    if(intersect(cyl,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    if(intersect(cap,ray,current) && current.time<hit.time)\n    {\n        hit=current;\n        ret=true;\n    }\n    return ret;\n}\n\n/*-------------------------------------*/\n/*-------- Patterns Functions --------*/\n\nfloat fct_cos(float s) {\n    return (cos(iTime*s)+1.)/2.;\n} \n\nint stripe_pattern_x(in vec3 p) {\n    p.x+=EPSILONE;\n    if(p.x<0.) \n        return int(p.x)%2==0?1:0;\n    return int(p.x)%2;\n}\n\nint stripe_pattern_y(in vec3 p) {\n    p.y+=EPSILONE;\n    if(p.y<0.) \n        return int(p.y)%2==0?1:0;\n    return int(p.y)%2;\n}\n\nint stripe_at_object(mat4 transform,vec3 obj_point,bool on_x) {\n    vec3 pattern_point=transform_pi(obj_point,transform).xyz;\n    if(on_x) \n        return stripe_pattern_x(pattern_point);\n    return stripe_pattern_y(pattern_point);\n}\n\nvec3 gradient_pattern(in vec3 c1,in vec3 c2,float p) {\n    return mix(c1,c2,p);\n}\n\nvec3 center_gradiant_at_object(mat4 transform,vec3 obj_point,vec3 c1,vec3 c2,vec3 center) {\n    vec3 pattern_point=transform_pi(obj_point,transform).xyz;\n    float mix=length(pattern_point-center)*.5;\n    return gradient_pattern(c1,c2,mix);\n}\n\nvec3 gradiant_at_object(mat4 transform,vec3 obj_point,vec3 c1,vec3 c2) {\n    vec3 pattern_point=transform_pi(obj_point,transform).xyz;\n    float mix=pattern_point.x-floor(pattern_point.x);\n    return gradient_pattern(c1,c2,mix);\n}\n\nint ring_pattern(in vec3 p) {\n    return int(sqrt(p.x*p.x+p.y*p.y+p.z*p.z))%2;\n}\n\nint ring_at_object(mat4 transform,vec3 obj_point) {\n    vec3 pattern_point=transform_pi(obj_point,transform).xyz;\n    return ring_pattern(pattern_point);\n}\n\nint checker_pattern(in vec3 p) {\n    vec3 u=p+EPSILONE; // avoid noise \n    return (int(floor(u.x))+int(floor(u.y))+int(floor(u.z)))%2==0?0:1;\n}\n\nint checker_at_object(mat4 transform,vec3 obj_point) {\n    vec3 pattern_point=transform_pi(obj_point,transform).xyz;\n    return checker_pattern(pattern_point);\n}\n\nfloat flat_checker_pattern(in vec3 p)\n{\n    // Filter kernel\n    vec3 w=fwidth(p)+EPSILONE;\n    // Box box filter\n    vec3 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return .5-(.5*i.x*i.y)+(.5*i.x*i.z)+(.5*i.z*i.y);\n}\n\nfloat flat_checker_at_object(mat4 transform,vec3 obj_point) {\n    vec3 pattern_point=transform_pi(obj_point,transform).xyz;\n    return flat_checker_pattern(pattern_point);\n}\n\nvec3 perturbed_point(vec3 p) {\n    float noise=perlin_noise(p);\n    return p+0.45*noise;\n}\n\n// Compute color\n// i : Texture index\n// p : point\nMaterial pattern_at(vec3 center,vec3 p,int i) {\n    vec3 color;\n    \n    if(i==0) { // red\n        Pattern pattern;\n        pattern.color=vec3(.9,.3,.35);\n        pattern.transform=mat_i();\n\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n        \n        mat.roughness=0.25;//fct_cos(.25);\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    if (i==1) { // green\n        Pattern pattern;\n        pattern.color=vec3(.3,.9,.32);\n        pattern.transform=mat_i();\n\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n\n        mat.roughness=0.15;//(cos(iTime)+1.)/2.;\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    if (i==2) { // blue \n        Pattern pattern;\n        pattern.color=vec3(.3,.32,.9);\n        pattern.transform=mat_i();\n\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n\n        mat.roughness=.05;//(cos(iTime)+1.)/2.;\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    if(i==3) { // stripe pattern\n        Pattern pattern;\n        pattern.transform=mat_tMt(center,mat_s(vec3(.2,1.,.2)));\n        //pattern.transform=mat_i();\n        float sp=float(stripe_at_object(pattern.transform,p,true));\n        pattern.color=vec3(0.)+sp*vec3(1.);\n\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n\n        mat.roughness=1.,//(cos(iTime)+1.)/2.;\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    if(i==4) { // center gradient pattern\n        Pattern pattern;\n        pattern.transform=mat_i();\n        pattern.color=center_gradiant_at_object(pattern.transform,p,vec3(.9,.15,.15),vec3(.15,.15,.9),center);\n\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n\n        mat.roughness=fct_cos(.5);\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    \n    if(i==5) { // gradient pattern\n        Pattern pattern;\n        pattern.transform=mat_t(vec3(.5,0.,0.))*mat_tMt(center,mat_rz(radians(iTime*20.)));\n        pattern.color=gradiant_at_object(pattern.transform,perturbed_point(p),vec3(.9,.3,.35),vec3(.3,.32,.9));\n\n        Material mat;mat_i();//\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n\n        mat.roughness=1.,//(cos(iTime)+1.)/2.;\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    if(i==6) { // ring pattern\n        Pattern pattern;\n        pattern.transform=mat_tMt(center,mat_s(vec3(.2)))*mat_tMt(center,mat_rx(radians(90.)));\n        float rp=float(ring_at_object(pattern.transform,perturbed_point(p)));\n        pattern.color=vec3(.6,.12,.7)+rp*vec3(.2,.44,.15);\n\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n\n        mat.roughness=fct_cos(.25);\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    if(i==7) { // checker pattern\n        Pattern pattern;\n        pattern.color=vec3(0.,0.,0.);\n        pattern.transform=mat_tMt(center,mat_s(vec3(.5)));\n        float check=float(checker_at_object(pattern.transform,p));\n\n        pattern.color=pattern.color+check*vec3(1.);\n\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color;\n\n        mat.roughness=0.0,//(cos(iTime)+1.)/2.;\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    if(i==8) {\n        Pattern pattern;\n        pattern.transform=mat_tMt(center,mat_s(vec3(1.5)));\n        float f=flat_checker_at_object(pattern.transform,p);\n        pattern.color=vec3(.4,.5,.7)+f*vec3(.1);\n        Material mat;\n        mat.ambiant=pattern.color*.5;\n        mat.diffuse=pattern.color*f;\n\n        mat.roughness=.12,//(cos(iTime)+1.)/2.;\n        mat.specular=vec3(.9)*(1.12-mat.roughness);\n        mat.shininess=512.*(1.02-mat.roughness);\n        return mat;\n    }\n    return Material(vec3(0),vec3(0),vec3(0),0.,0.,0.,0.);\n}\n\n/*-------------------------------------*/\n/*------------- Rendering -------------*/\n\nLight sun;\nLight pl;\n\nvec3 sky_color(vec3 d){\n    float transition = pow(smoothstep(0.02, .5, d.z), 0.4);\n    return mix(vec3(0.52, 0.77, 1),vec3(0.12, 0.43, 1),transition);\n}\n\nvec3 background(in Ray ray,Light light){\n    vec3 spotlightDir;\n    vec3 spotlightCol;\n    if(light.is_directional){\n        spotlightDir=light.direction;\n    } else {\n        spotlightDir=normalize(light.origin-ray.origin);\n    }\n\n    spotlightCol=light.intensity;\n    \n    return sky_color(ray.direction)+spotlightCol*pow(max(dot(ray.direction,spotlightDir),0.),5000.);\n}\n\nfloat is_shadowed(vec3 p,vec3 l,float magnitude,bool is_sun) {\n    Hit hit;\n    Ray ray=Ray(p,l);\n    bool obstructed=intersect(ray,hit);\n    if(is_sun && obstructed) return 0.;\n    if(obstructed && hit.time<magnitude) return 0.;\n    return 1.;\n}\n\nvec3 hemisphere(float seed,vec3 n) {\n    float a=fract(sin(176.19*seed));// Uniform randoms\n    float b=fract(sin(164.19*seed));\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n   \n    return d;\n}\n\nfloat seed;\nfloat ambient_occlusion(vec3 p,vec3 n,int N) {\n    float num_occluded=0.;\n    for(int i=0; i<N; ++i) {\n        vec3 d=normalize(hemisphere(seed+float(i),n));\n        Hit hit;\n        if(intersect(Ray(p+EPSILONE*d,d),hit) && hit.time<=OCC_LEN)\n            num_occluded+=1.*dot(d,n);\n    }\n\n    return num_occluded/float(N);\n}\n\nvec3 lighting(Light l,Material m,vec3 n,vec3 v,vec3 p) {\n    vec3 ldir=l.direction;\n    float len2l=1.;\n    if (!l.is_directional) {\n        ldir=l.origin-p;\n        len2l=dot(ldir,ldir);\n        ldir=normalize(ldir);\n    }\n\n    float shadow=is_shadowed(p+EPSILONE*n,ldir,sqrt(len2l),l.is_directional);\n\n    // ambiant \n    vec3 ambiant=m.ambiant*l.intensity/len2l*(1.-ambient_occlusion(p,n,10));\n\n    // diffuse\n    float diff=max(dot(ldir,n),0.);\n    vec3 diffuse=diff*m.diffuse;\n\n    // specular\n    vec3 h=normalize(ldir-v);\n    float spec=pow(max(dot(h,n),0.), m.shininess); // blinn\n    // vec3 r=reflect(-ldir,n);\n    // float spec=pow(max(dot(r,-v),0.), m.shininess); // phong\n    vec3 specular=spec*m.specular;\n\n    //return vec3((1.-ambient_occlusion(p,n,20)));\n    return ambiant+shadow*l.intensity*(diffuse+specular);\n}\n\nvec3 color_at(Ray ray,Light light)\n{\n    vec3 color;\n   \n    vec3 sky_color=background(ray,light);\n\n    float multiplier=1.;\n    for(int i=0; i<MAX_BOUNCES; ++i) {\n        Hit hit;\n        bool idx=intersect(ray,hit);\n\n        if (!idx)\n        {\n            color+=sky_color*multiplier;\n            break;\n        }\n\n        vec3 p=point(ray,hit.time);\n        Material mat=pattern_at(hit.center,hit.obj_point,hit.iMat);\n        \n        vec3 reflectionDir=reflect(ray.direction,hit.normal);\n\n        color+=lighting(light,mat,hit.normal,ray.direction,p)*multiplier;\n\n        multiplier*=.25;\n\n        vec3 offset=mat.roughness*hemisphere(seed,hit.normal);\n        vec3 ref_normal=normalize(hit.normal+offset);\n        ray.origin=p+EPSILONE*ref_normal;\n        ray.direction=reflect(ray.direction,ref_normal);\n    }\n\n    return color-vec3(.1);\n}\n\n\n/*-------------------------------------*/\n/*------- Scene Initialization -------*/\n\nvoid init_scene() {\n\n    sph.center=vec3(0.,0.,3.);\n    sph.radius=1.;\n    sph.iMat=4;\n    sph.transform=mat_t(vec3(2.,3.,0.))*mat_tMt(sph.center,mat_s(vec3(1.,1.,fct_cos(.25)+.1)));\n\n    cbe.min=vec3(-2.,-1.,2.);\n    cbe.max=vec3(-4.,1.,4.);\n    cbe.iMat=7;\n    cbe.transform=mat_t(vec3(1.,0.,0.))*mat_tMt(center(cbe.min,cbe.max),mat_ru(normalize(vec3(1.,1.,1.)),radians(iTime*25.)));\n\n    cyl.min=vec3(4.,0.,2.);    \n    cyl.max=vec3(4.,0.,4.);\n    cyl.radius=1.;\n    cyl.iMat=3;\n    cyl.transform=mat_t(vec3(5.,0.,0.))*mat_tMt(center(cyl.min,cyl.max),mat_sh(0.,0.,0.,cos(iTime),0.,0.));\n    \n    cap.min=vec3(2.,0.,2.);    \n    cap.max=vec3(2.,0.,4.);\n    cap.radius=.5;\n    cap.iMat=4;\n    cap.transform=mat_t(vec3(3.,1.,0.))*mat_tMt(center(cap.min,cap.max),mat_ry(radians(45.)));\n\n    ell.center=vec3(-6.,0.,3.);\n    ell.abc=vec3(1.5,1.,1.);\n    ell.iMat=4;\n    ell.transform=mat_t(vec3(0.,2.,0.))*mat_tMt(ell.center,mat_s(vec3(.75+fct_cos(1.)/4.,1.,1.)));\n\n    pln.normal=vec3(0.,0.,1.);\n    pln.point=vec3(0.,0.,0.);\n    pln.iMat=6;\n    pln.transform=mat_s(vec3(1.));\n    \n    pln2.normal=vec3(0.,1.,0.);\n    pln2.point=vec3(0.,-20.,0.);\n    pln2.iMat=8;\n    pln2.transform=mat_i();\n\n    pln3.normal=vec3(1.,0.,0.);\n    pln3.point=vec3(-20.,0.,0.);\n    pln3.iMat=8;\n    pln3.transform=mat_i();\n    \n    sun.is_directional=true;\n    sun.direction=normalize(vec3(1.,1.,.5));\n    sun.intensity=vec3(.9);\n\n    pl.is_directional=false;\n    pl.origin=vec3(0.,8.,7.);//vec3(8.*abs(cos(iTime))/.35,8.*abs(sin(iTime))/.35,cos(iTime)+8.);\n    pl.intensity=vec3(1.);\n} \n\n/*-------------------------------------*/\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 set_camera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    seed = hash(uv);// + fract(1.12345314312*iTime);//uv.x - uv.y * 3.43121412313 + fract(1.12345314312*iTime);\n\n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=17.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,2.);\n    mat3 ca=set_camera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n\n    init_scene();\n    fragColor = vec4(color_at(Ray(ro,rd),sun),1.);\n}","name":"Image","description":"","type":"image"}]}