{"ver":"0.1","info":{"id":"csscDN","date":"1686861593","viewed":121,"name":"Trippy Metal Factory","username":"rgbGuy","description":"raymarch","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define SURF_DIST 0.0001\n#define ZFAR 100.\n\nfloat smoothMax(float a, float b, float k)\n{\n    return log(exp(k*a) + exp(k*b))/k;\n}\n\nfloat smoothMin(float a, float b, float k)\n{\n    return -smoothMax(-a,-b,k);\n}\n\nstruct Ray{\n    vec3 ori;\n    vec3 dir; //this shouldn't be normalized as it is the point in space from which the ray passes\n};\n\nfloat sphereSDF(vec3 p, vec3 c, float r){\n    return length(p-c)-r;\n}\n\nfloat planeSDF(vec3 p, vec3 c)\n{\n    p.y += 0.08*sin(iTime*5.0 + 15.*p.x + 4.*p.y*sin(5.*p.z));\n    return p.y - c.y;\n}\n\nfloat boxSDF(vec3 p, vec3 c, vec3 R)\n{\n    return length(max(abs(p - c) - R, 0.0));\n}\n\nfloat sceneSDF(vec3 p){\n    //return sphereSDF(p, vec3(0,0,2), 0.5);\n    float sd = planeSDF(p, vec3(0, -0.5, 0));\n    \n    for(float i = -1.; i < 2.; i = i + 1.)\n    {\n        sd = smoothMin(sphereSDF(p, vec3(i*1.1,0.4*sin(2.*iTime + i),2), 0.3), sd, 7.);\n    }\n    //sd = smoothMin(sd, boxSDF(p, vec3(0,0.4*sin(iTime),2), vec3(0.5) * sin(iTime)), 10.);\n    return sd;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.01);\n    vec3 n = vec3(sceneSDF(p)) - vec3(sceneSDF(p-e.yxx),\n                                      sceneSDF(p-e.xyx),\n                                      sceneSDF(p-e.xxy));\n    return normalize(n);\n}\n\nfloat RayMarch(Ray r){\n\n    float D = 0.;\n    vec3 p = vec3(0);\n    \n    for(float i = 0.; i < float(MAX_STEPS); i = i+1.)\n    {\n        p = r.ori + D * r.dir;\n        float dS = sceneSDF(p);\n        D = D + dS;\n        if(dS < SURF_DIST || D > ZFAR) break;\n    }\n    \n    return D;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3.*sin(iTime), 2., 3.*sin(iTime));\n    vec3 lightDir = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    float intensity = clamp(dot(n, lightDir), 0., 1.);\n    \n    //shadows\n    float d = RayMarch(Ray(p+n*SURF_DIST*2., lightDir));\n    if(d < length(lightPos-p)) intensity *= 0.1;\n\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord / iResolution.y) - vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    Ray ray = Ray(vec3(0), vec3(uv, 1.));\n    vec3 col = texture(iChannel0, ray.dir).xyz;\n    \n    float d = RayMarch(ray);\n    vec3 pointOnSurface = ray.ori+d*ray.dir;\n\n    float light = GetLight(pointOnSurface);\n    \n    vec3 normal = getNormal(pointOnSurface);\n    //vec3 cubeMap = texture(iChannel0, normal).xyz;\n    if(d < ZFAR)\n    {\n        vec3 reflected = reflect(ray.dir, normal);\n        vec3 refTex = texture(iChannel0, reflected).rgb;\n        col = vec3(refTex);\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}