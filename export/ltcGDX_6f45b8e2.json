{"ver":"0.1","info":{"id":"ltcGDX","date":"1472255586","viewed":727,"name":"RespectThePixel","username":"jnorberg","description":"scale/rotate a pixel-art-piece while preserving the chunky pixels (zoomed in view to highlight the effect of the filtering)","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["pixelartscalerotate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this main-shader just zooms in on Buf A to make it easier to see the\n// result of the anti-aliasing.\n\n// the cool stuff is in Buf A\n\nfloat zoom = 4.0; // use an integer for prettier zoom\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x /= zoom * iResolution.x;\n    fragCoord.y /= zoom * iResolution.y;\n    \n    fragColor = texture ( iChannel0, fragCoord );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2016-08-26 jnorberg\n\n// the \"pixelartSample\" function is what I'm trying to show here\n// the goal is to have smooth AA-lines while preserving\n// the shape of the texels\n\n// inspired by \"Better Filtering\" https://www.shadertoy.com/view/XsfGDn\n\nvec2 pixelartSample( vec2 uv, float pixelsPerTexel )\n{\n    // uv pointing at texels (so btw. 0..width/heigh as opposed to btw. 0..1)\n    // the pixels PerTexel describes how many render-target pixels fits inside a texel\n    vec2 i = floor( uv + 0.5 ) - 0.5;\n    vec2 f = fract( uv + 0.5 ) - 0.5;\n    f = clamp( f * pixelsPerTexel, -1.0 , 1.0 ) * 0.5 + 0.5;\n\n    return i+f;\n}\n\n\n\n\n\n\n\n\n\nvec2 kTexRecip = vec2( 1.0/256.0, 1.0/32.0 );\nvec2 kFrame = vec2( 40.0, 32.0 );\nvec2 kCenter = vec2( 20.0, 16.0);\n\nvec2 AnimateUV( vec2 uv, float z, float t )\n{\n    float angle = t * 0.05;\n    float kS = sin( angle );\n\tfloat kC = cos( angle );\n\n\tuv -= kCenter;\n\n    // rotate\n    uv = vec2(\n       \tkC*uv.x - kS*uv.y,\n       \tkS*uv.x + kC*uv.y\n    );\n\n    float animFrame = floor( fract( t * 0.9 ) * 6.0 );\n    \n    float zr = 1.0 / z;\n    uv *= vec2( zr, zr ); // zoom\n\n    // center\n   \tuv += kCenter;\n\n    // animated frames of cat\n    uv.x -= animFrame * kFrame.x;\n\tuv = mod( uv, kFrame );\n    uv.x += animFrame * kFrame.x;\n\n    return uv;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float z0 = 11.0 - 7.0 * cos( iTime * 0.1 );\n    vec2 uv0 = AnimateUV( fragCoord, z0, iTime );\n\n    // simulate nearest neigbor to contrast btw. filter-modes\n    float lim = fragCoord.x - iResolution.x / 8.0;\n    if ( lim > 0.0 )\n    {\n        z0 = 10000000.0;\n    }\n    else if ( lim > -1.0 )\n    {\n        fragColor = vec4(0,0,0,0);\n            return;\n    }\n    \n    // the point of this example\n    uv0 = pixelartSample( uv0, z0 ) * kTexRecip;\n\n    fragColor = texture ( iChannel0, uv0 );\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}