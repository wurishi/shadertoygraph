{"ver":"0.1","info":{"id":"3tSfzz","date":"1599991554","viewed":110,"name":"Simple SDF Radar","username":"dr3w","description":"A simple shader used to draw a radar using signed distance fields.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distancefields","sdf","radar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Colours\n#define BACKGROUND_COLOUR   \t\tvec4(0.0,0.0,0.0,1.0)\n#define RADAR_CIRCLE_COLOUR \t\tvec4(102.0/255.0, 217.0/255.0, 255.0/255.0,1.0)\n#define RADAR_OUTER_CIRCLE_COLOUR\tvec4(1.0,1.0,1.0,1.0)\n#define RADAR_CIRCLE_THICKNESS \t\t0.008\n#define RADAR_SINGLE_ROTATION_TIME  4.0\t\t\n\n// Maths constants\nconst float PI \t\t\t\t\t=   3.14159265359;\n\n// Transformation functions\n\n//-----------------------------------------------------------------\n\nvec2 Rotate2D(vec2 pos, float angle)\n{\n\treturn pos * mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n//-----------------------------------------------------------------\n\n// Move towards destination then reset once reached\nvec2 MoveTowardsDestination(vec2 dest, vec2 pos, float currentTime, float desiredTime)\n{\n    float speed = distance(pos,dest) / desiredTime;\n    float t = fract(speed * currentTime);\n\treturn mix(pos,dest,t);\n}\n\n//-----------------------------------------------------------------\n\n// Distance Field functions \n\n//-----------------------------------------------------------------\n\nfloat Circle(vec2 pos, vec2 centre, float radius)\n{\n    return length(pos - centre) - radius;\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat Line(float x, float gradient,float start)\n{\n   float y = x * gradient + start; \n   return y;\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat Segment(vec2 pos, vec2 v0, vec2 v1, float thickness)\n{\n    // Find vector from current pixel to start of line\n \tvec2 a = pos - v0; \n    \n    // Find vector between start and end line points\n    vec2 b = v1 - v0;\n    \n    // Normalize b so we can project a onto b\n    vec2 bNorm = normalize(b);\n    \n    // Scalar projection of a onto b\n    float proj = dot(a, bNorm);\n    \n    // Only care about fragments that project onto the line between v0 and v1\n    // otherwise we don't get a line segment\n    proj = clamp(proj, 0.0, length(b));\n    \n    // Create vector of length a in the direction of b\n    vec2 proj_a_to_b = bNorm * proj;\n    \n    // Get vector orthogonal to b, gives us vector perpendicular to line segment\n    // that we can use to test if the pixel is on the line.\n    vec2 rejc_vec = a - proj_a_to_b;\n    \n    // if length < 0 then pixel is on the line\n    return length(rejc_vec) - thickness;\n}\n\n//---------------------------------------------------------------------------------------\n\n// Draw Distance Field functions \n\n//---------------------------------------------------------------------------------------\n\nvec4 Outline(float d, float edge, float thickness, vec4 colour)\n{\n    return colour * (smoothstep(edge-thickness, edge,d) * (1.0-smoothstep(edge,edge+thickness,d)));\n}\n\n//---------------------------------------------------------------------------------------\n\nvec4 Fill(float d, vec4 colour)\n{\n \treturn colour * (1.0- smoothstep(0.0,0.01,d));   \n}\n\n//---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Remap coordinates in range [-3.0,3.0] to [-2.0,2.0] with centre of image (0,0)\n    // Note: x and y different ranges to account for aspect ratio to stop the radar looking squashed\n    uv = (uv - vec2(0.5)) * vec2(3.0,2.0);\n    \n    // --- Radar circle\n    \n    // Define radar circles, returning distance of pixel to each circle\n    float outmostCircle2   = Circle(uv,vec2(0.0), 0.4);\n    float outmostCircle    = Circle(uv,vec2(0.0), 0.3);\n    float outerCircle      = Circle(uv,vec2(0.0), 0.2);\n    float innerCircle \t   = Circle(uv,vec2(0.0), 0.1);\n    float centreCircle     = Circle(uv,vec2(0.0), 0.03);\n            \n    // --- Radar line segment points\n    vec2 v0 = vec2(0.0);\n    vec2 v1 = vec2(0.56);\n    \n    // Calculate speed for single rotation around circle\n    float outmostCirclePerimeter = 2.0 * PI * 0.8;\n    float speed = outmostCirclePerimeter / RADAR_SINGLE_ROTATION_TIME;\n    \n    // Rotate v1 so our line rotates around radar\n    vec2 newV1 = Rotate2D(v1,-speed * iTime);\n    \n    // Define line segment, returning distance of pixel to line\n    float segment = Segment(uv,vec2(0.0),newV1,0.001);\n    \n    // Line segment trail gradient based\n    vec2  newUV \t\t = Rotate2D(uv,speed * iTime);\n    float angle     \t = atan(newUV.y,newUV.x);\n    float newUVLength    = length(newUV);\n    float lineAngle \t= atan(v1.y, v1.x);\n   \tfloat diff      = angle - lineAngle;\n    \n    // Define size of our trail\n    const float MIN_ANGLE = 0.0;\n    const float MAX_ANGLE = 2.0;\n    \n    // Find if pixel part of trail if its within angle range and pixel within radar circle,\n    // defined by radius 0.8\n    float drawTrailPixel = step(MIN_ANGLE,diff) \n        * (1.0- step(MAX_ANGLE,diff))\n        * (1.0 -step(0.8,newUVLength));\n   \n    // Fade to background colour as we get further from line segment\n    float n = smoothstep(MIN_ANGLE,MAX_ANGLE,diff);\n    vec4 trailColour = RADAR_CIRCLE_COLOUR * (1.0 -n);\n       \n    // --- Radar blips \n    \n    // Move radar blip towards centre of radar\n    vec2 blipPos = MoveTowardsDestination(vec2(-0.1,0.1),vec2(-0.5,0.5),iTime,10.0);\n    \n    // Define radar blips, returning distance of pixel to each circle\n    float blip1 = Circle(uv,vec2(0.3,0.4),0.05);\n    float blip2 = Circle(uv,blipPos,0.05);\n    float blip3 = Circle(uv,vec2(-0.25,-0.25),0.05);\n\tfloat blip4 = Circle(uv,vec2(0.5,-0.25),0.05);\n    \n    // Only show blips as they are swept over by line trail\n    vec4 blipColour = vec4(0.0);\n    // Fade to background colour as our blip pixel gets closer to MAX_ANGLE as defined by n  \n    blipColour = step(1.0,drawTrailPixel) * \n          smoothstep(vec4(1.0),BACKGROUND_COLOUR,vec4(n));\n\n    // --- Draw\n    vec4 col = \n        Fill(segment,RADAR_CIRCLE_COLOUR) +\n        drawTrailPixel * trailColour\n       +Outline(outmostCircle2, 0.4, RADAR_CIRCLE_THICKNESS,RADAR_OUTER_CIRCLE_COLOUR)\n       +Outline(outmostCircle, 0.3, RADAR_CIRCLE_THICKNESS,RADAR_CIRCLE_COLOUR)\n       +Outline(outerCircle, 0.2, RADAR_CIRCLE_THICKNESS,RADAR_CIRCLE_COLOUR)\n       +Outline(innerCircle, 0.1, RADAR_CIRCLE_THICKNESS,RADAR_CIRCLE_COLOUR)\n       +Outline(centreCircle, 0.03, RADAR_CIRCLE_THICKNESS,RADAR_OUTER_CIRCLE_COLOUR)\n        + Fill(blip1,blipColour)\n        + Fill(blip2,blipColour)\n        + Fill(blip3,blipColour)\n        + Fill(blip4,blipColour);\n \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}