{"ver":"0.1","info":{"id":"Xf23zt","date":"1707477522","viewed":218,"name":"LBM fluid simulation","username":"flo72","description":"Lattice Boltzmann fluid simulation. Use the mouse to draw an arbitrary obstacle. Works well in full-screen mode.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["fluidsimulation","latticeboltzmann","karmanvortexstreet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool isObj(ivec2 p){\n    return (texelFetch(iChannel1,p*2,0).r==1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    ivec2 site = ivec2(floor(fragCoord/2.0));\n    //only one pixel out of 4 stores the moments\n    float t = texelFetch(iChannel0,2*site+1,0).r;\n    \n    vec3 color =vec3(pow(t,.6));\n    \n    if(isObj(site)) color=vec3(.1,.2,.7);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//4 pixels are used to store the 9 distribution functions\nfloat getF(ivec2 i,int k){\n    return texelFetch(iChannel0,2*i+pn[k/3],0)[k%3]; \n}\n\nbool isObj(ivec2 p){\n    return (texelFetch(iChannel1,p*2,0).r==1.);\n}\n\nfloat getDye(ivec2 p, ivec2 i) {\n    vec2 R = iResolution.xy;\n    ivec2 LatSize = ivec2(R.xy / 2.0);\n    float period = R.y / 39.;\n    float frac = .75;\n\n    //periodic in y direction\n    if(p.y == LatSize.y)\n        p.y = 0;\n    if(p.y == -1)\n        p.y = LatSize.y - 1;\n\n    // left edge\n    if(p.x == -1)\n        return ((float(p.y % int(period)) > period * frac) ? 1. : 0.);\n\n    // check object\n    else if(isObj(p))\n        return texelFetch(iChannel0, 2 * i + 1, 0).r;\n    else\n        return texelFetch(iChannel0, 2 * p + 1, 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R=iResolution.xy;\n    \n    ivec2 LatSize = ivec2(R/2.0);\n    \n    ivec2 i = ivec2(floor(fragCoord/2.0));\n    if( i.x >= LatSize.x || i.y >= LatSize.y )\n    {\n        return;\n    }\n    ivec2 it = ivec2(fragCoord) - 2*i;//it takes values (0,0),(0,1),(1,0),(1,1)\n    \n    vec2 v;\n    float rho,t;\n    float f[9],fb[9],feq[9];\n    //setting boundary condition\n    eqDist(fb,vs,1.0);\n    \n    f[0]=getF(i,0);\n    if(iFrame==1|| f[0]==0. ) //initialisation\n    {\n       eqDist(f,vec2(0),1.0);\n       t=0.;\n    }\n    else \n    {\n        //STREAMING STEP\n        for(int k=0;k<9;k++){\n            ivec2 p = i-ivec2(e[k]);\n    \n            //periodic in y direction\n            if(p.y==LatSize.y) p.y=0;\n            if(p.y==-1) p.y=LatSize.y-1;\n            \n            // left and right edges\n            if(p.x==-1) f[k]=fb[k];\n            else if(p.x==LatSize.x) f[k]=w[k];\n            \n            //check object\n            else if(isObj(p)) f[k]=getF(i,bounce[k]);\n            else f[k]=getF(p,k);        \n        }\n        \n        rho=0.;\n        for(int k=0;k<9;k++) rho += f[k];\n        \n        v=vec2(0);\n        for(int k=0;k<9;k++) v += e[k]*f[k];\n        v /=rho;\n        \n        //velocity cap for stability\n        float norm = length(v);\n        if(norm > vs.x+.1) v *=(vs.x+.1)/norm; \n        \n        //RELAX TOWARD EQUILIBRIUM \n        eqDist(feq,v,rho);\n        for(int k=0;k<9;k++)\n        f[k] = (1.-tau) * f[k] + tau * feq[k];\n        \n        //calculate color\n        ivec2 iv = ivec2(sign(v));\n        float c00 = getDye(i, i);\n        float c10 = getDye(i - ivec2(iv.x, 0), i);\n        float c01 = getDye(i - ivec2(0, iv.y), i);\n        float c11 = getDye(i - iv, i);\n        vec2 av = abs(v);\n        float t1 = (1. - av.x) * c00 + av.x * c10;\n        float t2 = (1. - av.x) * c01 + av.x * c11;\n        t = (1. - av.y) * t1 + av.y * t2;\n \n    }\n    if(it.x==0&&it.y==0)\n        fragColor.rgb = vec3(f[0],f[1],f[2]);\n    else if(it.x==1&&it.y==0)\n        fragColor.rgb = vec3(f[3],f[4],f[5]);\n    else if(it.x==0&&it.y==1)\n        fragColor.rgb = vec3(f[6],f[7],f[8]);\n    else \n        fragColor.rgb = vec3(t,v);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//4 pixels are used to store the 9 distribution functions\nfloat getF(ivec2 i,int k){\n    return texelFetch(iChannel0,2*i+pn[k/3],0)[k%3]; \n}\n\nbool isObj(ivec2 p){\n    return (texelFetch(iChannel1,p*2,0).r==1.);\n}\n\nfloat getDye(ivec2 p, ivec2 i) {\n    vec2 R = iResolution.xy;\n    ivec2 LatSize = ivec2(R.xy / 2.0);\n    float period = R.y / 39.;\n    float frac = .75;\n\n    //periodic in y direction\n    if(p.y == LatSize.y)\n        p.y = 0;\n    if(p.y == -1)\n        p.y = LatSize.y - 1;\n\n    // left edge\n    if(p.x == -1)\n        return ((float(p.y % int(period)) > period * frac) ? 1. : 0.);\n\n    // check object\n    else if(isObj(p))\n        return texelFetch(iChannel0, 2 * i + 1, 0).r;\n    else\n        return texelFetch(iChannel0, 2 * p + 1, 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R=iResolution.xy;\n    \n    ivec2 LatSize = ivec2(R/2.0);\n    \n    ivec2 i = ivec2(floor(fragCoord/2.0));\n    if( i.x >= LatSize.x || i.y >= LatSize.y )\n    {\n        return;\n    }\n    ivec2 it = ivec2(fragCoord) - 2*i;//it takes values (0,0),(0,1),(1,0),(1,1)\n    \n    vec2 v;\n    float rho,t;\n    float f[9],fb[9],feq[9];\n    //setting boundary condition\n    eqDist(fb,vs,1.0);\n    \n    f[0]=getF(i,0);\n    if(iFrame==1|| f[0]==0. ) //initialisation\n    {\n       eqDist(f,vec2(0),1.0);\n       t=0.;\n    }\n    else \n    {\n        //STREAMING STEP\n        for(int k=0;k<9;k++){\n            ivec2 p = i-ivec2(e[k]);\n    \n            //periodic in y direction\n            if(p.y==LatSize.y) p.y=0;\n            if(p.y==-1) p.y=LatSize.y-1;\n            \n            // left and right edges\n            if(p.x==-1) f[k]=fb[k];\n            else if(p.x==LatSize.x) f[k]=w[k];\n            \n            //check object\n            else if(isObj(p)) f[k]=getF(i,bounce[k]);\n            else f[k]=getF(p,k);        \n        }\n        \n        rho=0.;\n        for(int k=0;k<9;k++) rho += f[k];\n        \n        v=vec2(0);\n        for(int k=0;k<9;k++) v += e[k]*f[k];\n        v /=rho;\n        \n        //velocity cap for stability\n        float norm = length(v);\n        if(norm > vs.x+.1) v *=(vs.x+.1)/norm; \n        \n        //RELAX TOWARD EQUILIBRIUM \n        eqDist(feq,v,rho);\n        for(int k=0;k<9;k++)\n        f[k] = (1.-tau) * f[k] + tau * feq[k];\n        \n        //calculate color\n        ivec2 iv = ivec2(sign(v));\n        float c00 = getDye(i, i);\n        float c10 = getDye(i - ivec2(iv.x, 0), i);\n        float c01 = getDye(i - ivec2(0, iv.y), i);\n        float c11 = getDye(i - iv, i);\n        vec2 av = abs(v);\n        float t1 = (1. - av.x) * c00 + av.x * c10;\n        float t2 = (1. - av.x) * c01 + av.x * c11;\n        t = (1. - av.y) * t1 + av.y * t2;\n \n    }\n    if(it.x==0&&it.y==0)\n        fragColor.rgb = vec3(f[0],f[1],f[2]);\n    else if(it.x==1&&it.y==0)\n        fragColor.rgb = vec3(f[3],f[4],f[5]);\n    else if(it.x==0&&it.y==1)\n        fragColor.rgb = vec3(f[6],f[7],f[8]);\n    else \n        fragColor.rgb = vec3(t,v);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 e[9] = vec2[](vec2(0,0),vec2(1,0),vec2(-1,0),vec2(0,1),vec2(0,-1),\n                    vec2(1,1),vec2(-1,-1),vec2(-1,1),vec2(1,-1));\nfloat w[9] =float[](4./9.,1./9.,1./9.,1./9.,1./9.,1./36.,1./36.,1./36.,1./36.);\n\nivec2 pn[3]= ivec2[](ivec2(0,0),ivec2(1,0),ivec2(0,1));\n\nint bounce[9]=int[](0,2,1,4,3,6,5,8,7);\n\n\nvoid eqDist(inout float f[9], in vec2 v, in float rho){\n    float vv= 3./2.*dot(v,v);\n    for(int k=0;k<9;++k){\n        float d=3.*dot(e[k],v);\n        f[k]=rho*w[k]*(1. + d + d*d/2. - vv);\n    }\n}\n\nfloat tau = 1.8;\nvec2 vs=vec2(0.3,0);\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4 pixels are used to store the 9 distribution functions\nfloat getF(ivec2 i,int k){\n    return texelFetch(iChannel0,2*i+pn[k/3],0)[k%3]; \n}\n\nbool isObj(ivec2 p){\n    return (texelFetch(iChannel1,p*2,0).r==1.);\n}\n\nfloat getDye(ivec2 p, ivec2 i) {\n    vec2 R = iResolution.xy;\n    ivec2 LatSize = ivec2(R.xy / 2.0);\n    float period = R.y / 39.;\n    float frac = .75;\n\n    //periodic in y direction\n    if(p.y == LatSize.y)\n        p.y = 0;\n    if(p.y == -1)\n        p.y = LatSize.y - 1;\n\n    // left edge\n    if(p.x == -1)\n        return ((float(p.y % int(period)) > period * frac) ? 1. : 0.);\n\n    // check object\n    else if(isObj(p))\n        return texelFetch(iChannel0, 2 * i + 1, 0).r;\n    else\n        return texelFetch(iChannel0, 2 * p + 1, 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R=iResolution.xy;\n    \n    ivec2 LatSize = ivec2(R/2.0);\n    \n    ivec2 i = ivec2(floor(fragCoord/2.0));\n    if( i.x >= LatSize.x || i.y >= LatSize.y )\n    {\n        return;\n    }\n    ivec2 it = ivec2(fragCoord) - 2*i;//it takes values (0,0),(0,1),(1,0),(1,1)\n    \n    vec2 v;\n    float rho,t;\n    float f[9],fb[9],feq[9];\n    //setting boundary condition\n    eqDist(fb,vs,1.0);\n    \n    f[0]=getF(i,0);\n    if(iFrame==1|| f[0]==0. ) //initialisation\n    {\n       eqDist(f,vec2(0),1.0);\n       t=0.;\n    }\n    else \n    {\n        //STREAMING STEP\n        for(int k=0;k<9;k++){\n            ivec2 p = i-ivec2(e[k]);\n    \n            //periodic in y direction\n            if(p.y==LatSize.y) p.y=0;\n            if(p.y==-1) p.y=LatSize.y-1;\n            \n            // left and right edges\n            if(p.x==-1) f[k]=fb[k];\n            else if(p.x==LatSize.x) f[k]=w[k];\n            \n            //check object\n            else if(isObj(p)) f[k]=getF(i,bounce[k]);\n            else f[k]=getF(p,k);        \n        }\n        \n        rho=0.;\n        for(int k=0;k<9;k++) rho += f[k];\n        \n        v=vec2(0);\n        for(int k=0;k<9;k++) v += e[k]*f[k];\n        v /=rho;\n        \n        //velocity cap for stability\n        float norm = length(v);\n        if(norm > vs.x+.1) v *=(vs.x+.1)/norm; \n        \n        //RELAX TOWARD EQUILIBRIUM \n        eqDist(feq,v,rho);\n        for(int k=0;k<9;k++)\n        f[k] = (1.-tau) * f[k] + tau * feq[k];\n        \n        //calculate color\n        ivec2 iv = ivec2(sign(v));\n        float c00 = getDye(i, i);\n        float c10 = getDye(i - ivec2(iv.x, 0), i);\n        float c01 = getDye(i - ivec2(0, iv.y), i);\n        float c11 = getDye(i - iv, i);\n        vec2 av = abs(v);\n        float t1 = (1. - av.x) * c00 + av.x * c10;\n        float t2 = (1. - av.x) * c01 + av.x * c11;\n        t = (1. - av.y) * t1 + av.y * t2;\n \n    }\n    if(it.x==0&&it.y==0)\n        fragColor.rgb = vec3(f[0],f[1],f[2]);\n    else if(it.x==1&&it.y==0)\n        fragColor.rgb = vec3(f[3],f[4],f[5]);\n    else if(it.x==0&&it.y==1)\n        fragColor.rgb = vec3(f[6],f[7],f[8]);\n    else \n        fragColor.rgb = vec3(t,v);\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    if(iFrame==1){\n        color=vec3(0);\n        //if(length(fragCoord-vec2(iResolution.x/6.,iResolution.y/2.))<5.)\n        //    color=vec3(1);\n    }    \n    else color=texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    \n    if(length(fragCoord-iMouse.xy) < 5.) color=vec3(1);\n    fragColor = vec4(color,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}