{"ver":"0.1","info":{"id":"stjcWz","date":"1649533026","viewed":488,"name":"Dice Triplets - A Matching Game","username":"GraphXDoses","description":"No clock, no score, no pressure!\nWell..if you overflow the tray, you lose :D Enjoy!\n\nPS: Two levels, for two different playstyles are available in \"Common\".\n","likes":7,"published":1,"flags":96,"usePreview":0,"tags":["2d","game","dice","puzzle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MlSXRR","filepath":"https://soundcloud.com/user-617788213/smooth-jazz-ambient?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/user-617788213/smooth-jazz-ambient?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Post proccessing & final output to screen.\n\n/////////////////////////////////////////////////////////\n\n#define gamma(fc, p) vec3(pow(fc.r, p), pow(fc.g, p), pow(fc.b, p))\n\nvoid main()\n{\n    if( texelFetch(iChannel2, ivec2(0), 0).z == 0. ) {\n        O = texture(iChannel0, U/R);\n    } else {\n        O = mix(\n        texture(iChannel0, U/R),\n        texture(iChannel1, U/R),\n        nlerp( texelFetch(iChannel2, ivec2(ACT_FRM, 0), 0)-30.,\n                texelFetch(iChannel2, ivec2(ACT_FRM, 0), 0)+90.,\n                float(iFrame) )\n        );\n    }\n    O.rgb = gamma(max(O.rgb, 0.), 1.5);\n    O.a = 1.;\n}\n\n\n// Update 5/1/2023:\n\n// - Added phong lighting on dice carvings.\n// - Blocked user from exploiting tray size,\n//   during level change without time resetting the game.\n\n/////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Global scope stuff.\n\n/////////////////////////////////////////////////////////\n\n#define main() mainImage( out vec4 O, vec2 U )\n#define saturate(x) clamp(x, 0., 1.)\n#define nlerp(t0, t1, t) saturate((t-t0)/(t1-t0))\n#define R iResolution.xy\n\n// TODO: Add more levels?\n#define LEVEL 0\n\n#if LEVEL == 0                      // LEVEL 0:\n                                    // Board holds many dice, but tray is only 3 places wide!\n                                    // Long play is promoted here but combinations must be\n                                    // meticulously calculated, no room for error.\n// Triplet occurance in board\nconst int diceWeights[6] = int[6](\n    15, // 1's\n    15, // 2's\n    15, // 3's\n    15, // 4's\n    15, // 5's\n    15  // 6's\n);\n#define TRAY_CAP 3\n#else                               // LEVEL 1:\n                                    // Board has less dice than LEVEL0, but the file like formation\n                                    // retains the level of difficulty presented. The notion here is to\n                                    // reserve (if needed) some dice on the tray - which ofcourse is larger\n                                    // this time - to allow \"strategic\" combinations with upcoming dice.\n                                    // This level promotes quickplay philosophy.\nconst int diceWeights[6] = int[6](\n    5, // 1's\n    5, // 2's\n    5, // 3's\n    5, // 4's\n    5, // 5's\n    5  // 6's\n);\n#define TRAY_CAP 5\n#endif\n\nconst int[6] NUMS = int[6]( 16, 68, 84, 325, 341, 365 );\nfloat SCALE = 12.3, bevel = 0.05, shadow = 0.1, outline = 0.01;\n\n#define HIT     344\n#define TRAY    ivec2(HIT+1, HIT+TRAY_CAP)\n#define TC      600\n#define RSRV    ivec2(TRAY.y+2, TRAY.y+2+TRAY_CAP)\n#define ACT_FRM RSRV.y+1\n#define MATCH   ACT_FRM+1\n\nfloat uvBoard(inout float sf, inout vec2 u, int x_axis, bool decimate ) {\n    sf = SCALE;\n    u -= vec2((1./SCALE)*(float(x_axis)/2.), -0.2);\n    u *= SCALE;\n\n    float ip = u.x;\n    ip = floor(u.x)+float(x_axis);\n    ip = ip > float(x_axis-1) || ip < -1. ? -1. : ip;\n    u = decimate ? vec2(fract(u.x)-.5, u.y)*(1.-shadow*2.+outline*2.) : u;\n\n    return ip;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer used for displaying outcome screens.\n\n/////////////////////////////////////////////////////////////\n\n// This following section of code I borrowed from FabriceNeyret2's shader\n// https://www.shadertoy.com/view/llySRh\n\n/////////////////////////////////////////////////////////////\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy;\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0\n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ),\n                       dfdx, dfdy );\n}\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  u.x-=.5;\n#define C(c) spc O+= char(u,64+CAPS+c);\n// NB: use either char.x ( pixel mask ) or char.w ( distance field + 0.5 )\n\n#define draw(s, sf) smoothstep((1./R.y)*sf, -(1./R.y)*sf, s)\n#define get(id)  texelFetch(iChannel0, ivec2(id, 0), 0)\n\n/////////////////////////////////////////////////////////////\n\nvoid main()\n{\n    O = vec4(0);\n\n    if( get(0).z != 0. ) {\n        vec2 u = (U-R*.5)/R.y;\n        float sf = 1.;\n        if( get(0).z == 1. ) { // Win screen\n            vec2 abv = ( u+vec2(0.26,0) )*10., blw = ( u+vec2(0.175,0.065) )*20.;\n            u = abv;\n\n\n            caps C(19) C(21) C(3) C(3) C(5) C(19) C(19) C(-31)\n\n            u = blw;\n\n            caps C(5) C(13) C(16) C(20) C(25) spc C(2) C(15) C(1) C(18) C(4)\n\n        } else if( get(0).z == -1. ) { // Fail screen\n            vec2 abv = ( u+vec2(0.18,0) )*10., blw = ( u+vec2(0.2,0.065) )*20.; //0.22\n            u = abv;\n\n\n            caps C(6) C(1) C(9) C(12)// C(-18) C(-18)\n\n            u = blw;\n\n            caps C(20) C(18) C(1) C(25) spc C(15) C(22) C(5) C(18) C(6) C(12) C(15) C(23)\n        }\n\n        O += draw_char().wwww;\n        O = vec4(1.-saturate(draw((1.-O*2.), 12.)));\n    }\n    O.a = 1.;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Logic buffer.\n\n/////////////////////////////////////////////////////////\n\n#define hash(p)  (mod((p*2654435761.), pow(2., 32.)) / pow(2., 32.))\n#define get(id)  texelFetch(iChannel0, ivec2(id, 0), 0)\n\nvec3 calcBoardSize(int[6] l) {\n    int g = 0;\n    int[6] pool;\n    float res = 0.;\n    // Find occuring dice ( weight > 0 )\n    for(int s=0; s<6; s++) {\n        if(l[s] > 0) {\n            pool[g] = l[s];\n            g++;\n        } else { continue; }\n    }\n    // Find board dimentions\n    for(int s=0; s<g; s++) {\n        res += float(pool[s])*3.;\n    }\n    for(float s=2.; s<8.; s++) {\n        float q = s*3.;\n        // Board dimentions validity check. If invalid board is presented, draw no board.\n        if( mod(res, q) == 0. ) {\n            float temp1 = res/q, temp2 = res/temp1;\n            if( all(lessThanEqual(vec2(temp1, temp2), vec2(21, 16))) ) {\n                float mi = min(temp1, temp2), ma = max(temp1, temp2);\n                if(mi<=16. && ma>16.) return vec3(ma, mi, res);\n                return vec3(mi, ma, res);\n            } else { continue; }\n        } else { continue; }\n    }\n    return vec3(0);\n}\n\nvoid init(int id, inout vec4 O) {\n    if( iFrame == 0 ) {\n        O = vec4(0);\n        if (id == 0 ) O = vec4(iDate.a,0,0,0);\n        if (id == 1 ) O = vec4(calcBoardSize(diceWeights),0);\n        if (id >= 2 && id <= 7) O = vec4((id-2) % 6,diceWeights[(id-2) % 6]*3,0,0);\n        if (id == TC ) O = vec4(TRAY_CAP);\n    } else if(iFrame == 1) {\n        // Place the total number of dice, sequentially.\n        if( id >= 8 && id < int(get(1).z)+8 ) {\n            int g = 0;\n            int[6] pool;\n            for(int s=0; s<6; s++) {\n                int len = int(get(s+2).y);\n                if(len > 0) {\n                    pool[g] = int(get(s+2).x);\n                    g++;\n                } else { continue; }\n            }\n            O = vec4(pool[(id-8)%g],0,0,1);\n        }\n    } else if( iFrame == 2 ) {\n        // Shuffle dice, vertically.\n        // This way it is guaranteed for each dice to appear at least once in a column,\n        // thanks to the previous sequential order configuration.\n        if( id >= 8 && id < int(get(1).z)+8 ) {\n            int[336] pool;\n            for(int s=0; s<int(get(1).z); s++) {\n                pool[s] = int(get(s+8).x);\n            }\n            for(int s=int(get(1).z)-1; s>0; s--) {\n                int j = int(hash(get(0).x) * float(s)) % int(get(1).y);\n                j += int(get(1).y)*int(float(s)/get(1).y);\n                j = j % int(get(1).z);\n                int temp   = pool[s];\n                pool[s] = pool[j];\n                pool[j] = temp;\n            }\n            O = vec4(pool[(id-8)],-1,0,1);\n            if( (id-8) % int(get(1).y) == int(get(1).y)-1 ) O.a = 2.;\n        }\n    }\n}\n\nvoid main()\n{\n    O = texelFetch(iChannel0, ivec2(U), 0);\n    int id = int((U.x + U.y*R.x) - floor(R.x/2.));\n\n    init(id, O);\n\n    // Accepting clicks for proccessing after 150 frames\n    // ( required for board to settle ), as long as the game is still on.\n    if( iFrame > 150 && iMouse.w > 0.5 && get(0).z == 0. && (TRAY_CAP == int(get(TC).x))) {\n\n        // For a click to be considered meaningful, it has to hit\n        // an active dice( alpha value of 2 ), given it occured a proper amount of frames\n        // after the last meaningful hit. If there is no last meaningful hit, time delay restriction\n        // has no effect.\n\n        if( texelFetch(iChannel1, ivec2(iMouse.xy), 0).a == 2.\n        && iFrame > int(get(ACT_FRM).z + ( get(MATCH).x > 0. ? 46. : 31. ) ) ) {\n\n            if( get(TRAY.y).z == 0. && id == 0 ) {\n                O.y++;\n                if( O.y == get(1).z ) { O.z = 1.; } // If the total meaningful hits, equal the total amount of dice, its a win!\n            }\n\n            // Stores hit time permanently( Has no life time. )\n            if( id == ACT_FRM ) { O = vec4(iFrame); }\n\n\n            if( id==HIT || ( id>=TRAY.x && id<=TRAY.y ) || ( id>=2 && id<=7 ) ) {\n                // Locates both targeted and diadochic dice.\n                vec2 u = (iMouse.xy - R*.5)/R.y;\n                float sf, ip = uvBoard(sf, u, int(get(1).x), true );\n                int col = int((get(1).y) * ip);\n                int tID, dID = -1;\n                for(int i=8+col+(int(get(1).y))-1; i>8+col-1; i--) {\n                    if(get(i).a == 2.) {\n                      tID = i;\n                      if(get(i-1).a == 1.) dID = i-1;\n                      break;\n                    }\n                }\n                // Stores the occurances of target dice, recorded to have been in tray.\n                if( id>=2 && id<=7 ) {\n                    if( get(id).x == get(tID).x ) { O = get(id); O.z++; }\n                }\n                if( id==HIT ) {\n                    // Hit registration\n                    O = vec4(tID,dID,iFrame,0); // Hit time here is stored temporarily( with a short life time ).\n                } else {\n                    int mark=-1, occ=0;\n                    // Iterate through the tray to find the next empty space.\n                    for(int i=TRAY.x; i<=TRAY.y; i++) {\n                        if( all(equal(get(i), vec4(0))) ) { mark=i; break; } else continue;\n                    }\n                    vec4[TRAY_CAP] pool; for(int i=0; i<TRAY_CAP; i++) { pool[i] = get(i+TRAY.x); }\n                    mark-=TRAY.x;\n                    // Backtrack checking for similar dice.\n                    for(int j=mark-1; j>=0; j--) {\n                        if( get(pool[j].x).x == get(tID).x ){\n                            mark = j+1+TRAY.x;\n                            occ = 1;\n                            break;\n                        }\n                    }\n                    O.y = 0.;\n\n                    // Y component of dice in tray are states, with:\n                    // 0: idle\n                    // 1: moving from board position, towards tray position.\n                    // 2: shift one position( tray ) to the right.( make way for incoming dice )\n                    // 3: shift three positions( tray ) to the left.( take the space of the previously matched )\n                    // 4: vanish.( confirmed matched )\n\n                    // If similar dice are found, reorder tray.\n                    if( occ == 1 ) {\n                        if( id==mark )\n                        { O = vec4(tID,1,iFrame,1); }\n                        else if( id>mark ) {\n                            O = get(id-1);\n                            if(get(id-1).z > 150.) { O.y = 2.; O.a = 1.; }\n                        }\n                    } else if( occ == 0 ) {\n                        if( id==mark+TRAY.x )\n                        { O = vec4(tID,1,iFrame,1); }\n                    }\n                }\n            }\n        }\n    }\n\n    if( get(ACT_FRM).z > 0. && iFrame == int(get(ACT_FRM).z+30.) ) {\n        // Overflow check.\n        if( id == 0 ) {\n            if( get(TRAY.y).z > 0. && mod(get( get(get(HIT).x).x+2. ).z, 3.) != 0. ) O.z = -1.;\n        }\n\n        // Checking for matches.\n        if( ( id>=TRAY.x && id<=TRAY.y ) || ( id>=RSRV.x && id<=RSRV.y || id == MATCH ) ) {\n            float n = get(get(HIT).x).x;\n            int mark=-1;\n            if( mod(get( n+2. ).z, 3.) == 0. ) {\n                for(int i=TRAY.x; i<=TRAY.y; i++) {\n                    if( get(get(i).x).x == n ) { mark=i; break; }\n                }\n                if( id >= mark ) {\n                    O = get(min(id+3, TRAY.y+1));\n                    if(O.z > 0.) { O.y = 3.; O.a = 1.; }\n                } else {\n                    O = get(id);\n                }\n                if( id>=RSRV.x && id<=RSRV.y ) {\n                    O = get((id-RSRV.x)+TRAY.x);\n                    if( (id-RSRV.x)+TRAY.x >= mark && (id-RSRV.x)+TRAY.x <= TRAY.y ) {\n                        if( get(O.x).x == n ) {\n                            O = vec4(get((id-RSRV.x)+TRAY.x).x, 4, mark, 1);\n                        }\n                    }\n                }\n                // Match indicator switch.\n                if( id == MATCH ) {\n                    O = vec4(1);\n                }\n            }\n        }\n    }\n\n    // Reserve reset.\n    if( id>=RSRV.x && id<=RSRV.y ) { if(get(id).a == 0. && get(id).y == 4.) { O = vec4(0); } }\n\n    // Changes taking place during hit's life.\n    if( get(HIT).z > 0. ) {\n\n        if( id==HIT ) {\n            if( get(HIT).w<1. ) {\n                O.a = nlerp( get(HIT).z, get(HIT).z+30., float(iFrame) );\n            } else {\n                O = vec4(0);\n            }\n        }\n        if( id == int(get(HIT).x) ) {\n            O.a = 0.;\n            O.z = max(O.z, get(HIT).w);\n        }\n        if( id == int(get(HIT).y) && int(get(HIT).y) != -1 ) { O.a = 1. + get(HIT).w; }\n\n        if( ( id>=TRAY.x && id<=TRAY.y ) ) {\n            if( get(id).w > 0. ) {\n                if( get(id).y == 2. ) {\n                    O.w = 1. - nlerp( get(ACT_FRM).z, get(ACT_FRM).z+15., float(iFrame) );\n                } else { O.w = 1. - get(HIT).w; }\n            }\n        }\n    }\n\n    // Changes taking place according to dice in tray dynamic.\n    if( iFrame > int(get(ACT_FRM).z+30.) ) {\n        if( ( id>=TRAY.x && id<=TRAY.y ) || ( id>=RSRV.x && id<=RSRV.y ) ) {\n            if( get(id).w > 0. ) {\n                if( get(id).y == 3. ||  get(id).y == 4. ) {\n                    O.w = 1. - nlerp( get(ACT_FRM).z-30., get(ACT_FRM).z+46., float(iFrame) );\n                }\n            }\n        } else if( id == MATCH && get(MATCH).x == 1. ) {\n            O = vec4(1) * float((1.-nlerp( get(ACT_FRM).z-30., get(ACT_FRM).z+46., float(iFrame) ) > 0.) );\n        }\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer used for drawing art elements.\n\n/////////////////////////////////////////////////////////\n\nconst int TOTAL_LAYERS = 6;\n\n#define ss(v) smoothstep(0., 1., v)\n#define dot2(v) dot(v,v)\n#define L_SOURCE (vec3(0,-0.5,1))\n\n#define hexToRGB(c) vec3(c >> 16, (c >> 8) & 255, c & 255) / 255.\n#define getLogic(id) texelFetch(iChannel0, ivec2(id, 0), 0)\n#define spacing(n) (1.-shadow*1.9)*float(n)\n#define boardRel(id) vec2( floor(float(id-8) / getLogic(1).y)-(getLogic(1).x/2.-float(TRAY_CAP)/2.), 2.-(shadow-outline*3.) + ((getLogic(1).y-mod(float(id-8), getLogic(1).y)-1.)/2.)*.77 )\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 bitBox(vec2 uv, vec2 size, int n)\n{\n    vec2 bsize = vec2(n);\n    uv += size; uv /= size/(float(n)/2.);\n    vec2 p = uv;\n    uv = floor(uv);\n    if ( any(greaterThan(uv, bsize-1.)) || any(lessThan(uv, vec2(0))) ) return vec3(1e8);\n    return vec3(p-(uv+.5), (uv.x + uv.y*bsize.x) );\n}\n\nvoid aStack(inout float layer, in float sdf) { layer = min(layer, sdf); }\n\nfloat dfMask(in float sdf, float sf) {sdf = smoothstep((1./R.y)*sf, (-1./R.y)*sf, sdf); return saturate(sdf);}\n\nint hasDot(int id, int num) { return (num >> id) & 1; }\n\nfloat layer[TOTAL_LAYERS] = float[TOTAL_LAYERS](\n    1., 1., 1., 1., 1., 1.\n);\nvec3 color[TOTAL_LAYERS]  = vec3[TOTAL_LAYERS](\n    vec3(31./255.), vec3(15./255.), vec3(0), vec3(1), hexToRGB(0xd6b38b), vec3(0)\n);\n\nvoid layering(vec2 uv, int n) {\n    vec3 id = bitBox(uv-vec2(0., shadow), vec2(.5-(bevel+shadow)), 3);\n    aStack(layer[3], sdBox(uv-vec2(0., shadow), vec2(.5-(bevel+shadow)))-bevel);\n    aStack(layer[4], sdBox(uv, vec2(.5-(bevel+shadow)))-bevel);\n    aStack(layer[5], min(layer[3], layer[4])-outline);\n\n    if ( hasDot(int(id.z), NUMS[n%6]) == 1 ) aStack(layer[2], length(id.xy)-.4);\n}\n\nvoid dotPhong(inout vec3 c, vec2 u, float t)\n{\n    vec2 ww = bitBox(u-vec2(0., shadow), vec2(.5-(bevel+shadow)), 3).xy*2.;\n    vec3 tmp = vec3( pow(dot(vec3(ww, sqrt(1.-dot2(ww)) ), normalize(L_SOURCE)), 5.));\n    c = max(mix(c, color[4]*.4*t, tmp), c);\n}\n\nvoid main()\n{\n    O = vec4(vec3(51./255.),0);\n    vec2 u = (U - R*.5)/R.y, q = u, uzo = q;\n    ivec2 BOARD_DIM = ivec2(getLogic(1).xy);\n    float sf=1., ip = uvBoard(sf, q, BOARD_DIM.x, false );\n\n    // RENDERING OF TRAY //\n\n    q += vec2(float(BOARD_DIM.x/2), 2);\n    aStack(layer[0], sdBox(q-vec2(0., shadow*2.-outline*3.), vec2(.5*float(TRAY_CAP)-outline*5., .5+outline))-bevel);\n    aStack(layer[1], sdBox(q-vec2(0., shadow/2.), vec2((.5*float(TRAY_CAP)), .5-(shadow/sf)))-bevel);\n    layer[1] = max(layer[1], layer[0]);\n    O = mix(O, vec4(color[0], 1), dfMask(layer[0], sf));\n    O = mix(O, vec4(color[1], 1), dfMask(layer[1], sf));\n\n    // RENDERING OF DICE IN BOARD //\n\n    sf, ip = uvBoard(sf, u, BOARD_DIM.x, true );\n\n    u.y -= 7.5*(cos(min(iTime*(1.5+(float(BOARD_DIM.x)-ip)/10.), acos(-1.)))+1.)/2.;\n\n    vec2 p = u;int cols = int(ip);\n\n    for(int rows=0; rows<BOARD_DIM.y; rows++) {\n        float dS = getLogic(8+(rows)+(cols*BOARD_DIM.y)).a;\n        if(dS == 0.) continue;\n\n        u+=vec2( 0. , -spacing(BOARD_DIM.y-rows)/2.1);\n\n        layering(u, int(getLogic(8+(rows)+(cols*BOARD_DIM.y)).x));\n\n        for(int i=TOTAL_LAYERS-1; i>1; i--)\n        {\n            vec3 c;\n            sf = SCALE;\n            if(i==3) {\n                c = mix(\n                    mix(color[i], hexToRGB(0x65625d)*1.5, nlerp(120., 150., float(iFrame))),\n                    color[i],\n                    saturate(getLogic(8+(rows)+(cols*BOARD_DIM.y)).a - 1.)\n                );\n            } else { c = color[i]; }\n            if (i == 2) { sf = SCALE*3.; dotPhong(c, u, dS/2.); }\n            O = mix(O, vec4(c, dS), dfMask(layer[i], sf));\n            layer[i] = 1.;\n        }\n\n        u = p;\n    }\n\n    q += vec2((float(TRAY_CAP)/2.)-.5, -(shadow+outline));\n    p = q;\n    sf, ip = uvBoard(sf, uzo, TRAY_CAP, true );\n    uzo+=vec2( 0. , 1.5+shadow/2. );\n\n    // RENDERING OF IDLE DICE IN TRAY //\n\n    if( ip>-1. && int(ip)<TRAY_CAP ) {\n        if( getLogic(TRAY.x+int(ip)).z > 150. && getLogic(TRAY.x+int(ip)).w == 0. ) {\n\n            layering(uzo, int(getLogic(getLogic(TRAY.x+int(ip)).x).x));\n\n            for(int i=TOTAL_LAYERS-1; i>1; i--)\n            {\n                sf = i==2 ? SCALE*3. : SCALE;\n                O.rgb = mix(O.rgb, color[i], dfMask(layer[i], sf));\n                if (i == 2) { dotPhong(O.rgb, uzo, 1.); }\n                layer[i] = 1.;\n            }\n        }\n    }\n\n    // RENDERING OF MOVING DICE IN/TOWARDS TRAY //\n\n    if( getLogic(MATCH).x == 1. ) {\n        for(int s=RSRV.x; s<=RSRV.y; s++) {\n            if( getLogic(s).y == 0. || getLogic(s).a == 0. ) { continue; }\n\n            if( getLogic(s).y == 4. ) {\n                p.x -= float(s-RSRV.x);\n                p *= (1.-shadow*2.+outline*2.);\n            }\n\n            layering(p, int(getLogic(getLogic(s).x).x));\n\n            for(int i=TOTAL_LAYERS-1; i>1; i--)\n            {\n                sf = i==2 ? SCALE*3. : SCALE;\n                O.rgb = mix(mix(O.rgb, color[i], dfMask(layer[i], sf)), O.rgb, ss(cos(getLogic(s).a*3.)*.5+.5));\n                \n                layer[i] = 1.;\n                if (i == 2) {dotPhong(O.rgb, p, getLogic(s).a); }\n            }\n            p = q;\n        }\n    }\n\n    for(int s=TRAY.x; s<=TRAY.y; s++) {\n        if( getLogic(s).y == 0. || getLogic(s).a == 0. ) { continue; }\n\n\n        if( getLogic(s).y == 1. ) {\n            p.x -= mix( boardRel(int(getLogic(s).x)).x, float(s-TRAY.x), ss(getLogic(getLogic(s).x).z) );//0. );\n            p *= (1.-shadow*2.+outline*2.);\n            p.y -= mix(boardRel(int(getLogic(s).x)).y, 0., ss(1.-getLogic(s).a) );\n        } else if( getLogic(s).y == 2. ) {\n            p.x -= mix( float(s-TRAY.x-1), float(s-TRAY.x), ss(1.-getLogic(s).a) );//0. );\n            p *= (1.-shadow*2.+outline*2.);\n        } else if( getLogic(s).y == 3. ) {\n            p.x -= mix( float(s-TRAY.x+3), float(s-TRAY.x), ss(1.-getLogic(s).a) );//0. );\n            p *= (1.-shadow*2.+outline*2.);\n        }\n\n        layering(p, int(getLogic(getLogic(s).x).x));\n\n        for(int i=TOTAL_LAYERS-1; i>1; i--)\n        {\n            sf = i==2 ? SCALE*3. : SCALE;\n            O.rgb = mix(O.rgb, color[i], dfMask(layer[i], sf));\n            if (i == 2) { dotPhong(O.rgb, p, 1.); }\n            layer[i] = 1.;\n        }\n        p = q;\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"}]}