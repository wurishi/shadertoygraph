{"ver":"0.1","info":{"id":"Ml3GDN","date":"1469484510","viewed":164,"name":"raymarching project","username":"darthxander","description":"raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VIEW\n\nconst float EPSILON = .0001;\nconst int MAX_STEPS = 255;\nconst float PI = 3.1415926535;\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nmat3 rotatex(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat3(1., 0., 0.,\n                0., c, -s,\n                0., s, c);\n}\n\nmat3 rotatey(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat3(c, 0, s,\n                0, 1, 0,\n                -s, 0, c);\n}\n        \nmat3 rotatez(float a) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat3(c, -s, 0,\n                s, c, 0,\n                0, 0, 1);\n}\n    \nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat cappedCylinderSDF(vec3 p, vec2 h) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat boxSDF(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat smoothUnionSDF(float distA, float distB, float k) {\n    return smin(distA, distB, k);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat wheelSDF(vec3 p) {\n    mat3 rz = rotatez(3.142/2.0);\n    mat3 rx = rotatex(3.142/2.0);\n    mat3 rs1 = rotatex(-.5*3.142/6.0);\n   \tmat3 rs2 = rotatex(-1.5*3.142/6.0);\n    mat3 rs3 = rotatex(-2.5*3.142/6.0);\n    \n    vec2 wheelSize = vec2(.3, .2);\n    float wheelThickness = .03;\n    float outer = cappedCylinderSDF(p*rz, wheelSize);\n    float inner = cappedCylinderSDF(p*rz, vec2(wheelSize.x - wheelThickness, wheelSize.y+.5));\n    float rim = differenceSDF(outer, inner);\n     \n    vec3 ps = p;\n    ps.yz = abs(ps.yz);\n    \n    vec3 treadSize = vec3(wheelSize.y, .01, .02);\n    vec3 treadOffset = vec3(0, wheelSize.x + treadSize.y/2.0, 0);\n    float tread1 = boxSDF(ps*rs1 - treadOffset, treadSize);\n    float tread2 = boxSDF(ps*rs2 - treadOffset, treadSize);\n    float tread3 = boxSDF(ps*rs3 - treadOffset, treadSize);\n    float treads = min(min(tread1, tread2), tread3);\n    \n    float tire = unionSDF(rim, treads);\n    \n    float frame1 = boxSDF(p, vec3(.05, wheelSize.x*.99, .05));\n    float frame2 = boxSDF(p*rx, vec3(.05, wheelSize.x*.99, .05));\n    \n    float frame = smoothUnionSDF(frame1, frame2, .05);\n    \n    return unionSDF(tire, frame);\n}\n\nfloat columnSDF(vec3 p, vec2 rh) {\n    float columnRadius = rh.r/1.2;\n    float columnHeight = rh.y/2.0;\n    const float pillarInsets = 20.0;\n    const float insetRange = .84;\n    \n    float column = cappedCylinderSDF(p, vec2(columnRadius, columnHeight));\n    const float aInc = (2.0*PI)/pillarInsets;\n    mat3 rot = rotatey(aInc);\n    vec3 insetPos = vec3(0.0, 0.0, columnRadius);\n    for(float a = 0.0; a < 2.0*PI; a += aInc) {\n        float inset = cappedCylinderSDF(p - insetPos, \n              vec2(.6*columnRadius*PI/pillarInsets, columnHeight*insetRange));\n        column = differenceSDF(column, inset);\n        insetPos = rot*insetPos;\n    }\n    \n    float bottom = -1.0*columnHeight*insetRange;\n    float bottomRange = (bottom + columnHeight);\n    float bottomRingHeight = bottom - bottomRange/2.5;\n    float bottomRingWidth = bottomRange/5.0;\n    float bottomRing = torusSDF(p - vec3(0.0, bottomRingHeight, 0.0), vec2(columnRadius, bottomRingWidth));\n    column = unionSDF(column, bottomRing);\n    \n    float smallBottomRingWidth = bottomRange/20.0;\n    float smallBottomRingHeight = bottomRingHeight + bottomRingWidth + smallBottomRingWidth;\n    float smallBottomRing = torusSDF(p - vec3(0.0, smallBottomRingHeight, 0.0), vec2(columnRadius, smallBottomRingWidth));\n    column = unionSDF(column, smallBottomRing);\n    \n    float baseWidth = ((bottomRingHeight - bottomRingWidth) + columnHeight)/2.0;\n    float baseHeight = bottomRingHeight - bottomRingWidth - baseWidth;\n    float base = boxSDF(p - vec3(0.0, baseHeight, 0.0), vec3(columnRadius*1.2, baseWidth, columnRadius*1.2));\n    column = unionSDF(column, base);\n    \n    float top = columnHeight*insetRange;\n    float topRange = bottomRange;\n    float smallTopRing = torusSDF(p - vec3(0.0, -smallBottomRingHeight, 0.0), vec2(columnRadius, smallBottomRingWidth));\n    column = unionSDF(column, smallTopRing);\n\n    float topBoxWidth = baseWidth/3.0;\n    float topBoxHeight = columnHeight - topBoxWidth;\n    float topBox = boxSDF(p - vec3(0.0, topBoxHeight, 0.0), vec3(columnRadius*1.2, topBoxWidth, columnRadius*1.2));\n    float smallTopBoxWidth = topBoxWidth*1.8;\n    float smallTopBoxHeight = topBoxHeight - topBoxWidth - smallTopBoxWidth;\n    float smallTopBox = boxSDF(p - vec3(0.0, smallTopBoxHeight, 0.0), vec3(columnRadius*1.05, smallTopBoxWidth, columnRadius*1.05));\n    float cap = smoothUnionSDF(topBox, smallTopBox, .05);\n    column = unionSDF(column, cap);\n    \n    float topRingWidth = bottomRingWidth/2.0;\n    float topRingHeight = smallTopBoxHeight - smallTopBoxWidth - topRingWidth;\n    float topRing = torusSDF(p - vec3(0.0, topRingHeight, 0.0), vec2(columnRadius, topRingWidth));\n    column = unionSDF(column, topRing);\n    \n    \n    return column;\n}    \n\nfloat sceneSDF(vec3 p) {\n    \n    //float scene = boxSDF(p - vec3(0.0, -1.3, 0.0), vec3(2.1, .1, 2.1));\n    //vec3 np = p * rotatexz(iTime*.5);\n    //float column = columnSDF(np, vec2(.2, 2.4));\n    //float column2 = columnSDF(p - vec3(1.8, 0.0, 1.8), vec2(.2, 2.4));\n    //float column3 = columnSDF(p - vec3(-1.8, 0.0, 1.8), vec2(.2, 2.4));\n    //float column4 = columnSDF(p - vec3(-1.8, 0.0, -1.8), vec2(.2, 2.4));\n    //scene = unionSDF(scene, column);\n    //scene = unionSDF(scene, column2);\n    //scene = unionSDF(scene, column3);\n    //scene = unionSDF(scene, column4);\n \t//return column;\n    \n    /*\n    vec3 np = p * rotateyz(iTime*0.0);\n    //float scene = columnSDF(p, vec2(.25, 2.8));\n    float cube = boxSDF(np, vec3(1.5, 1.5, 1.5));\n    float sphere = sphereSDF(p, 2.0 + .5*sin(iTime));\n  \tfloat scene = intersectSDF(cube, sphere);\n    \n    float torus = torusSDF(p, vec2(.8, .9));\n    \n    scene = differenceSDF(scene, torus);\n    \n    float box1 = boxSDF(np + vec3(0.0, sin(iTime*1.5)*3.0, 0.0), vec3(.1, 1.5, .1));\n    float box2 = boxSDF(np + vec3(0.0, 0.0, sin(iTime*1.5 + 3.14/2.0)*3.0), vec3(.1, .1, 1.5));\n    \n    float box3 = boxSDF(np, vec3(.9, .1, .1));\n    box3 = differenceSDF(box3, boxSDF(np, vec3(.1, .11, .11)));\n    \n    float k = 0.0;\n    \n    float boxes = smoothUnionSDF(box1, box2, k);\n    boxes = smoothUnionSDF(boxes, box3, k);\n    \n    scene = smoothUnionSDF(boxes, scene, .1);\n    \n\treturn scene;\n\t*/\n    \n    vec3 ps = p;\n    ps.xz = abs(ps.xz);\n    \n    return wheelSDF(ps - vec3(.3, 0., .4));\n    \n}\n\nvec3 directionToMarch(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nfloat shortestDistanceToScene(vec3 start, vec3 direction, float maxDist) {\n    float depth = 0.0; \n    for(int i = 0; i < MAX_STEPS; i++){\n        float dist = sceneSDF(start + depth*direction);\n        if(dist < EPSILON) {\n            return depth;\n        }\n        if(dist >= maxDist) {\n        \treturn -1.0;\n        }\n        depth += dist;\n    }\n    return -1.0;\n}\n\nvec3 estimateGradient(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 ambientColor(Material material) {\n    return material.ambient;\n}\n\nvec3 diffuseColor(Material material, Light light, vec3 L_m, vec3 N) {\n    float dotLN = dot(L_m, N);\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return material.diffuse * dotLN * light.color;\n}\n\nvec3 specularColor(Material material, Light light, vec3 L_m, vec3 N, vec3 V) {\n    vec3 R = reflect(-L_m, N);\n    float dotRV = dot(R, V);\n    if (dotRV < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return material.specular * pow(dotRV, material.shininess) * light.color;\n}\n\nvec3 phongIllumination(Material material, Light light, vec3 p, vec3 N, vec3 V) {\n\tvec3 L_m = normalize(light.position - p);\n    return diffuseColor(material, light, L_m, N) + specularColor(material, light, L_m, N, V);\n}\n\nvec3 phongReflectionModel(Material material, vec3 p, vec3 eye) {\n    vec3 N = estimateGradient(p);\n    vec3 V = normalize(eye - p);\n    vec3 color = ambientColor(material);\n    Light light;\n    \n    light = Light(vec3(sin(iTime)*4.0, 2.0, cos(iTime)*4.0), vec3(1.0));\n    color += phongIllumination(material, light, p, N, V);\n    \n    light = Light(vec3(3.0, 0.0, -3.0), vec3(1.0));\n    color += phongIllumination(material, light, p, N, V);\n    \n    return color;\n}\n    \nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 offwhite = vec3(1.0, .94, .94);\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 lightBlue = vec3(0.0, .7, .7);\n    vec3 dimBlue = vec3(0.0, .2, .2);\n    Material blueM = Material(dimBlue, lightBlue, white, 20.0);\n    Material blackM = Material(vec3(.15, .15, .15), vec3(.3, .3, .3), white, 20.0);\n    Material offwhiteM = Material(offwhite*.5, offwhite*.8, white, 30.0);\n    Material metal = Material(vec3(.6, .6, .6), vec3(.65, .65, .65), white, 50.0);\n    \n    #ifdef VIEW\n\tvec3 eye = vec3(0, 2, -8);\n    eye = eye * rotatey(iMouse.x/150.0);\n   \n    mat4 view = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    #else\n    float viewHeight = 1.3;\n    vec3 eye = vec3(-1.0, viewHeight-.3, -1.0);\n    mat4 view = viewMatrix(eye, vec3(0.0, viewHeight, 0.0), vec3(0.0, 1.0, 0.0));\n    #endif\n    \n    vec3 dir = directionToMarch(45.0, iResolution.xy, fragCoord);\n    \n    \n    vec3 sceneDir = (view*(vec4(dir, 0.0))).xyz;\n    \n    \n    float dist = shortestDistanceToScene(eye, sceneDir, 200.0);\n    vec3 p = eye + dist*sceneDir;\n    \n    if(dist == -1.0) {\n        fragColor = vec4(vec3(0.0, .9, 0.0), 1.0);\n    }\n    else {\n        vec3 col = phongReflectionModel(blackM, p, eye);\n        fragColor = vec4(col, 1.0);\n    }\n\t\n}","name":"Image","description":"","type":"image"}]}