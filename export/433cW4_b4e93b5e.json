{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define NUM_LAYERS 6\n#define PI 3.14159265359\n\nfloat hash21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    \n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    float total_amplitude = 0.0;\n    \n    for(int i = 0; i < 5; i++) {\n        value += amplitude * noise(p * frequency);\n        total_amplitude += amplitude;\n        amplitude *= 0.5;\n        frequency *= 2.0;\n        p += vec2(3.14, 2.72);\n    }\n    \n    return value / total_amplitude * 0.8 + 0.2;\n}\n\nvec3 auroraColor(float t) {\n    vec3 a = vec3(0.2, 0.4, 0.3);\n    vec3 b = vec3(0.5, 0.6, 0.3);\n    vec3 c = vec3(0.8, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.2, 0.3);\n    vec3 color = a + b * cos(2.0 * PI * (c * t + d));\n    \n    return max(color, vec3(0.15));\n}\n\nvec3 addStars(vec2 uv, vec3 col, float iTime) {\n    float clusterScale = 100.0;\n    float stars = 0.0;\n\n    vec2 scaledUV1 = uv * 500.0 + vec2(1.23, 3.45);\n    float rand1 = hash21(scaledUV1);\n    vec2 clusterCoord1 = floor(scaledUV1 / clusterScale);\n    float clusterSeed1 = hash21(clusterCoord1 + vec2(10.0, 20.0));\n    float twinkle1 = sin((iTime + clusterSeed1 * 5.0) * (1.0 + rand1 * 4.0)) * (0.15 + rand1 * 0.05) \n                     + (1.0 - (0.15 + rand1 * 0.05));\n    stars += step(0.99, rand1) * 0.3 * twinkle1;\n\n    vec2 scaledUV2 = uv * 300.0 + vec2(6.78, 9.01);\n    float rand2 = hash21(scaledUV2);\n    vec2 clusterCoord2 = floor(scaledUV2 / clusterScale);\n    float clusterSeed2 = hash21(clusterCoord2 + vec2(30.0, 40.0));\n    float twinkle2 = sin((iTime + clusterSeed2 * 6.0) * (1.0 + rand2 * 3.0)) * (0.15 + rand2 * 0.1)\n                     + (1.0 - (0.15 + rand2 * 0.1));\n    stars += step(0.998, rand2) * 0.6 * twinkle2;\n\n    vec2 scaledUV3 = uv * 200.0 + vec2(2.34, 5.67);\n    float rand3 = hash21(scaledUV3);\n    vec2 clusterCoord3 = floor(scaledUV3 / clusterScale);\n    float clusterSeed3 = hash21(clusterCoord3 + vec2(50.0, 60.0));\n    float twinkle3 = sin((iTime + clusterSeed3 * 7.0) * (1.0 + rand3 * 2.5)) * (0.15 + rand3 * 0.15)\n                     + (1.0 - (0.15 + rand3 * 0.15));\n    stars += step(0.999, rand3) * 1.5 * twinkle3;\n\n    vec2 sparkleUV = uv * 150.0 + vec2(4.56, 7.89);\n    float sparkleRand = hash21(sparkleUV);\n    vec2 clusterCoordS = floor(sparkleUV / clusterScale);\n    float clusterSeedS = hash21(clusterCoordS + vec2(70.0, 80.0));\n    float sparkle = pow(sin((iTime + clusterSeedS * 8.0) * (1.0 + sparkleRand * 3.0)) * 0.5 + 0.5, 2.0)\n                    * (0.2 + sparkleRand * 0.2);\n    stars += step(0.9995, sparkleRand) * sparkle * 0.5;\n\n    return col + vec3(stars) * (0.2 - length(col) * 0.3);\n}\n\nvec3 atmosphere(vec2 uv, vec3 color) {\n    float a = pow(1.0 - min(abs(uv.y + 0.2), 1.0), 2.0);\n    vec3 c = vec3(0.0, 0.1, 0.2);\n    float s = a * 0.4 * (1.0 - length(color));\n    \n    return mix(color, c, s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.02, 0.03, 0.06);\n    col = addStars(uv, col, iTime);\n    \n    vec3 aurora = vec3(0.0);\n    for(int i = 0; i < NUM_LAYERS; i++) {\n        float fi = float(i);\n        float speed = 0.08 + fi * 0.02;\n        float scale = 1.5 + fi * 0.3;\n        float intensity = 0.35 / (fi + 1.0) + 0.2;\n        vec2 auroraUV = uv;\n        \n        auroraUV.x += iTime * speed * 0.2;\n        \n        float curtain = fbm(vec2(auroraUV.x * scale, iTime * 0.15));\n        curtain = pow(curtain, 1.1);\n        \n        float y = sin(auroraUV.x * 2.0 + iTime * 0.5) * 0.2;\n        auroraUV.y += y;\n        \n        float aurora_shape = pow(max(0.0, 1.0 - abs(auroraUV.y + 0.4 + curtain * 0.3)), 1.3 + fi * 0.4);\n        aurora_shape *= smoothstep(0.0, 0.15, curtain);\n        aurora_shape *= smoothstep(-0.2, 0.0, auroraUV.y + 0.5);\n        \n        vec3 auroraCol = auroraColor(fi / float(NUM_LAYERS) + curtain * 0.2 + iTime * 0.05);\n        aurora += aurora_shape * auroraCol * intensity * 1.4;\n    }\n    \n    col += aurora;\n    \n    vec3 glow = vec3(0.0);\n    for(float i = 1.0; i < 4.0; i++) {\n        vec2 gUV = uv * (1.0 - i * 0.03);\n        float gr = pow(max(0.0, 0.5 - abs(gUV.y + 0.6)), 2.2);\n        \n        glow += gr * auroraColor(iTime * 0.1) * 0.2;\n    }\n    \n    col += glow;\n    col = atmosphere(uv, col);\n    col = pow(col, vec3(0.9));\n    \n    float v = 1.0 - smoothstep(0.8, 1.8, length(uv));\n    \n    col *= mix(0.8, 1.0, v);\n    col = mix(col, vec3(dot(col, vec3(0.299, 0.587, 0.114))), -0.2);\n    col = max(col, vec3(0.02, 0.03, 0.06));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"433cW4","date":"1735196014","viewed":101,"name":"A Simple Aurora","username":"yannnm","description":"The northern (or southern) lights","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["lights","aurora","auroraborealis","northern","southern","auroraaustralis"],"hasliked":0,"parentid":"","parentname":""}}