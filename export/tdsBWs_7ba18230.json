{"ver":"0.1","info":{"id":"tdsBWs","date":"1589349701","viewed":116,"name":"Quake strafe jump angle graph","username":"heartoftheforce","description":"Graph showing the relationship between speed, angle relative to direction of movement and acceleration.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["graph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CONFIGURATION\n#define M_PI 3.1415926535897932384626433832795\n#define MaxVelocity 320.0\n// function sampling range\nvec2 xRange = vec2(-M_PI, M_PI);\n// drawn range of the Y axis\nvec2 yRange = vec2(-MaxVelocity, MaxVelocity) * 2.0;\n\n// colours\nconst vec3 background = vec3(1.0, 1.0, 1.0);\nconst vec3 axes = vec3(0.0, 0.0, 0.0);\n\n// function plot line thickness in pixels\nconst float thickness = 5.0;\n\n// function to sample\n#define Acceleration 10.0\n#define DeltaTime 0.01\n\nvec3 calcPrevVelocity()\n{\n    return vec3(MaxVelocity * 3.0 * (sin((M_PI / -2.0) + iTime * 0.25) + 1.0) * 3.0, 0, 0);\n}\n\nfloat f(float angle)\n{\n    vec3 prevVelocity = calcPrevVelocity();\n    vec3 accelDir = vec3(cos(angle), sin(angle), 0);\n    float projVel = dot(prevVelocity, accelDir);\n    float accelVel = Acceleration * DeltaTime;\n\n    if(projVel + accelVel > MaxVelocity) \n        accelVel = MaxVelocity - projVel;\n  \n    if(accelVel < 0.0)\n        return 0.0;\n    else\n  \t \treturn projVel + accelVel;\n}\n\nfloat o()\n{\n    vec3 prevVelocity = calcPrevVelocity();\n   \tfloat prevLength = length(prevVelocity);\n    float accelVel = Acceleration * DeltaTime;\n    float projMax = MaxVelocity - accelVel;\n\n    float theta;\n    if (prevLength <= projMax)\n        theta = acos(dot(vec3(1,0,0), prevVelocity) / prevLength);\n    else\n        theta = acos(projMax / prevLength);\n\n    return theta;\n}\n\n\n// IMPLEMENTATION\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real)\n{\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real)\n{\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius)\n{\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 actualYRange = yRange;\n\t\n\tfloat x = xRange.x + (xRange.y - xRange.x) * (fragCoord.x / iResolution.x);\n\tfloat y = f(x);\n    float optimalAngle = o();\n    \n    float actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n    vec4 plot;\n    if(abs(x) - optimalAngle < 0.01 && optimalAngle - abs(x) < 0.01)\n    {\n        plot = vec4(1.0, 0.0, 0.0, 1);\n    }\n    else\n    {\n        // plot dot :)\n        float dotX = xRange.x + fract(iTime) * (xRange.y - xRange.x);\n\n        vec3 funcColour = vec3(0.0, 0.0, 1.0);\n        // plot colour\n        float distY = abs(y - actualY);\n        plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n    }\n    \n    // axis colour\n    vec4 xAxis = vec4(axes, coverage(realXToPixels(abs(x)), thickness));\n    vec4 yAxis = vec4(axes, coverage(realYToPixels(abs(actualY)), thickness));\n    vec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(vec4(1.0), foreground, foreground.a);\n}","name":"Image","description":"","type":"image"}]}