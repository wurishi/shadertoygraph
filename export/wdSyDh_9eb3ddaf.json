{"ver":"0.1","info":{"id":"wdSyDh","date":"1586531549","viewed":282,"name":"❤️ for lug00ber","username":"Alie","description":"Just ❤️ for lug00ber :P\n\nQuick hack as a background for the revision 2020 livestream during his DJ set. Expect code to look like a quick hack.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","heart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 100\n#define kEPSILON 0.001\n    \nfloat dist(in vec3 p){\n    // Rotate\n    R(p.xz, iTime*.3);\n    // Scale Z to flatten\n    p.z *= 1.7;\n    // Shift on Y to form heart\n    //p.y -= smoothstep(0., 1., abs(p.x)) / 2.;\n    //p.y -=pow(abs(p.x)/2.,1.7)*1.3;\n    p.y -=pow(abs(p.x)/2.,-p.y*.3+1.5)*1.3;\n    // Scale X to widen\n    p.x *=.8;\n \treturn length(p) - 1.5;   \n}\n\n// Gets the normal\nvec3 normal(in vec3 p) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = dist(p);\n \treturn normalize(vec3(\n        dist(p + eps.xyy) - baseDist,\n        dist(p + eps.yxy) - baseDist,\n        dist(p + eps.yyx) - baseDist\n        ));\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in vec3 d, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(d, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\nvec4 iC(vec3 p, vec3 d,vec3 ba, vec3 bb){\n\tvec3 a=(ba-p)/d, // near\n\tb=(bb-p)/d, // far\n\tf=max(a,b), // furthest\n\tn=min(a,b); // nearest\n\tfloat x=min(f.x,min(f.y,f.z)), // furthest plane\n\tdist=max(n.x,max(n.y,n.z)), // nearest plane\n\to=dist<0.?x:dist; // nearest in front\n\t//if(dist>=x||o<0.) return vec4(0,0,0,-100.); // d>=x = invalid, o>t = behind other geometry, o<0 behind\n\t\n\tvec3 normal = normalize(step(kEPSILON,abs(a-dist))-step(kEPSILON,abs(b-dist)))*sign(dist);\n\t//h.m=m;\n    return vec4(normal, dist);\n}\n\nvec3 bkg(in vec3 p, in vec3 d, bool heart, vec2 uv) {\n    vec4 box = iC(p, d, vec3(-100.), vec3(100.));\n    p += d * box.w;\n    if (heart) {\n    \t//float spec = (p.y < -99. && p.x>10. && abs(p.z+30.) < 30.) ? 1. : 0.;\n    \tfloat spec = p.y > -99. ? 0. : \n        (1.-smoothstep(40., 50., abs(p.x-50.))) * (1.-smoothstep(30., 40., abs(p.z+30.)));\n        //    && p.x>10. && abs(p.z+30.) < 30.) ? 1. : 0.;\n        return vec3(1,.2,.2) * (dot(d, normalize(vec3(3,2,-1)))*.3+.7) + spec;\n    }\n    \n    vec3 col = vec3(d.y *.5 + .5);\n    \n    return col;\n  //  return abs(box.zxy); \n}\n\n// The main marching loop\nvec3 marchRay(in vec3 p, in vec3 d, vec2 uv) {\n    float td = 0.;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        float result = dist(p);\n        td += result;\n        if ((p.z) > 3.0) { break; }\n        \n        p += d * result * 0.6;\n        \n        if (result < kEPSILON * td) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tvec3 n = normal(p);\n            d = reflect(d, n);\n            return bkg(p, d, true, uv);\n        }\n    }\n    // Ray did not hit, background\n    vec3 col = bkg(p, d, false, uv)*.6 + vec3(.2, .3, 1.);\n    \n\tcol = col*pow(clamp(0., 1., 1.2-length(uv)),.75);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    vec2 uv2 = uv;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 cp = vec3(0,.5,-4.5);\n    vec3 rd = normalize(vec3(uv, 1)); \n\n    // Time varying pixel color\n    vec3 col = marchRay(cp, rd, uv2);\n\t//col = col*pow(clamp(0., 1., 1.-length(uv2)),.75);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}