{"ver":"0.1","info":{"id":"fstGRr","date":"1629063672","viewed":137,"name":"Shards - 2","username":"birdbird","description":"Variation of Shards - 1.\nUsing log polar-tiling (https://www.osar.fr/notes/logspherical) to create an infitely zooming shader. (again)\nThe colors are done with the help of the spectrum response function here: https://www.shadertoy.com/view/wlSBzD","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["spectrum","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = acos(-1.);\n\n//https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map_range(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\n//https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat map(vec2 uv) {\n    int iterations = 5;\n    vec2 ouv = uv;\n\n    uv = abs(mod(uv, 1.)*4. - 2.);\n    \n    for(int i = 0; i < iterations; i ++) {\n        float fi = float(i);\n        float fit = float(iterations);\n        uv = abs(uv - (vec2(cos(iTime/4.) + (fi/fit)*1. )));\n        uv *= 1.6;        \n        uv = rotateUV(uv, map_range(ouv.x,-1.,1., 0.5, 5.) );\n    }\n    \n    return sdBox(uv, vec2(0.2));\n}\n\n//https://www.shadertoy.com/view/MsGSRd\nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        map(uv+d.xy)-map(uv-d.xy),\n        map(uv+d.yx)-map(uv-d.yx)\n    )/delta;\n}\n\n// https://www.shadertoy.com/view/wlSBzD\nvec3 SpectrumPoly(in float x) {\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv_o = uv;\n    uv /= dot(uv,uv);\n    \n    //Log polar-tiling -> https://www.osar.fr/notes/logspherical/\n    vec2 pos = vec2(log(length(uv)), atan(uv.y, uv.x));\n    pos *= 1./pi;\n    pos = fract(pos) - 0.5;   \n    uv = pos;\n    uv.x += iTime/2. + 5700.;\n\n    //Lightning\n    vec2 norm = normalize(getGrad(uv, 0.011));\n    float l_speed = 4.;\n    vec2 lightpos = vec2(sin(iTime*l_speed), cos(iTime*l_speed));\n    float light = abs(dot(norm, normalize(lightpos)));  \n    vec3 color = SpectrumPoly(sin(light*2. + sin(iTime/3.))*0.5 + 0.5)*1.4;\n    \n    //Shine\n    float mask = (1. - pow(length(uv_o),0.2))*map_range(sin(iTime), -1.,1., 1.8, 2.);\n    color += vec3(mask,mask,mask*0.78);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}