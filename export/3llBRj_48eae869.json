{"ver":"0.1","info":{"id":"3llBRj","date":"1597581562","viewed":98,"name":"DG Celtic Torc","username":"DG622","description":"attempt at using a torus to make celtic broach c/o Art of Code","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["toruscelticart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this is care of a torus tutorial 'trteefoil knots' from Art of Code Aug 2020\n//with a lot of the code from the raymarching template and taken from other tutorials\n//from The Art of Code\n\nfloat N21 (vec2 p){\n \tp = fract(p* vec2( 273.53, 375.47));\n    p+=dot(p, p + 27.357);\n    return fract(p.x*p.y);\n}\n\nfloat smoothNoise (vec2 uv){// this is essentiually a mixing function /tiling\n \n    vec2 lv = fract(uv);//these 2 go together fract giving the fraction and floor the integer of the cells\n    vec2 id = floor(uv);\n   \n    lv = lv * lv *(3.0 - 2.0 *lv);//interpolation for dummies video but this is essentially a smoothstep\n    \t\t\t\t\t\t\t\n    \n    float bl =fract( N21(id));//bottom left// fract here for the sky goes with the N21 fract if using N21a dont need it\n    float br = N21(id + vec2(1, 0));//bottom right\n    float b = mix( bl, br, lv.x);//so mix them to get the bottom line using the local uv.x              \n    \n    float tl = N21(id + vec2(0, 1));//top left etc\n    float tr = N21(id + vec2(1, 1));\n    float t = mix( tl, tr, lv.x);\n       \n    return mix(b, t, lv.y);    \n}\n\nfloat smoothNoise2 (vec2 uv, float flag ){//layering\n   float c;\n    if(flag > 1.0){ c = smoothNoise(uv*4.);  // So (uv * frequency ) * Amplitude\n    \tc+= smoothNoise(uv* 8. ) * .5;//add another layer/octave, each time double the frequency \n    \t\t\t\t\t\t\t\t//and halve the amplitude\n    \tc+= smoothNoise(uv* 16. ) * .25;\n    \tc+= smoothNoise(uv* 32. ) * .125;\n    \tc+= smoothNoise(uv* 65. ) * .0625;\n    }else    c+= smoothNoise(uv* 320.0 ) *0.0167;\n   \n    return c/2.5;\t\t\t\t\t\t//need to divide by a factor to make sure c does not breach 1.0\n}\n\n\nmat2 Rot (float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n    \n}\n\n\t\n\n\tfloat sphere (vec4 dim, vec3 p){\n\t\t\tfloat retValue = length(p - dim.xyz)-dim.w;\n\t\t\treturn retValue;\n\t\t\t\t}\n      \n    \n     float GetDist(vec3 p){\n\t\tfloat retVal;\n        //retVal = twister(p);\n        \t\t//gives you multiple copies\n         \t\t//p.y-=1.4;\n         \t\t//p.x+=0.9;\n             \t//retVal = min(retVal,twister(p));\n         \n        float a;\n        float r1 = 2.5;//larger diameter\n        float r2 = 0.01;//thinner strands this for the band though    \t\n    \tfloat noise = smoothNoise2(p.xz, 1.0);\n      \n    \tvec2 cp = vec2(length(p.xz*0.9)-r1, p.y);    \t          \n       \ta = atan(p.x, p.z);  \n         \n    \tif(a  > -2.9 && a < 2.9 ){ //a runs from - pie to pie\n        \tcp*=Rot(a*19.0);//more curls\n        \tcp.y = abs(cp.y*1.5)-0.07;//* tighter (as in metal)twined, minus is closer/tighter\n    \t\tr2 = 0.1;\n        \n    \t} else cp = vec2(length(p.xz*0.9)-0.0, p.y);//so need to set cp diameter to zero;\n                 \n    \tcp.y = abs(cp.y+noise) - 0.1;//this gives the central strand\n    \tretVal = length(cp)-r2;\n         //xxx\n     \n         float dSphere = sphere(vec4(0.75,-0.10+noise,-2.6,0.4),p);\n         float dSphereL = sphere(vec4(-0.75,-0.10+noise,-2.6,0.4),p);\n         float dPlane = dot(vec3(p.x,p.y,p.z+2.9), normalize(vec3 (0.0,0.0,-1.0)));//the vec 3 is the normal of the plane\n         \t\t\t\t\t\t\n           \t\t\t\t\t//dSphere = abs(dSphere);// hollows it out the goblet so the fluid sphere shows        \n         float d = max(dSphere, dPlane) - 0.01;//max gives intersection of a plane, the number: thickness\n\t\t float d2 = max(dSphereL, dPlane);        \n         d = min(d, d2); \n                           \n         retVal = min(d, retVal); \n         \n         retVal = min (retVal, p.y+5.0);\n         return retVal*0.4;\n         \n        }\n\n\n     float RayMarch(vec3 ro, vec3 rd){\n            float dO = 0.0;\n            float retVal;\n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO * rd;\n                retVal = GetDist(p);\n               \n           \t\tfloat dS = retVal;\n                dO += dS;\n                if( dS < 0.01 || dO > 100.0){\n                    break;\n                    }\n              }\n          \tretVal = dO;\n            return retVal;           \n       }\n\n\t\tvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            float d = GetDist(p);          \t\n          \n            vec3 n = d - vec3(GetDist(p-e.xyy),GetDist(p-e.yxy), GetDist(p-e.yyx));           \n            n = normalize(n);\n            return n;           \n       }\n        float GetLight(vec3 p){\n         \tvec3 lightPos = vec3( 3.0, 6.0, -7.0);\n\n         // lightPos.xz += vec2(sin(iTime*2.0), cos(iTime*2.0));\n            vec3 light = normalize(lightPos - p);\n            vec3 n = GetNormal(p);           \n            float dif = clamp(dot(n,light), 0.0, 1.0);// so no negative numbers, last one just a value\n            //for the shadow\n            float retVal  = RayMarch(p + n * 0.01 * 3.0, light);//this 3.0 is a work around\n            float d = retVal;\n            if (d < length (lightPos - p )) dif *= 0.1;                                                    \n          \n            return dif;\n        }\n  \nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \t\tvec3 RGB = vec3(0.0);\n    \t\tvec3 RGB1 = vec3(0.83, 0.69, 0.22);//gold\n    \t\tvec3 RGB2 = vec3(0.621, 0.273, 0.277);\n\t\t\tvec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;   \n\t\t\t      \n          \n   \t\t\tvec2 m = iMouse.xy/iResolution.xy;    \n    \t\tvec3 col = vec3(0.0);    \n    \t\tvec3 ro = vec3(0, 3, -5);\n    \t\tro.yz *= Rot(-m.y*3.14+1.);\n    \t\tro.xz *= Rot(-m.x*6.2831);\n    \n    \t\tvec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    \t\t\n            float d = RayMarch(ro,rd);\n\t\t\t\n   \n            vec3 p= ro+rd*d;\n            float diff = GetLight(p);\n    if (p.y> -1.0) {RGB = RGB1;\n                  }else RGB = RGB2;\n    \t\tfloat c = max(smoothstep(0.9, -.100,uv.y),\tsmoothNoise2(uv, 3.0)); //cloud\n    if (d > 100.0) {col =vec3(c);\n                   }else col = vec3(RGB*diff);//multiply as background needs to remain black\n   //as per suggestion re reflections.\n    if (d < 100.0) {\n        vec3 n = GetNormal(p);\n        vec3 r = reflect (rd, n);\n       col+=texture(iChannel0, r).rgb;\n        //col+= RGB2.r;\n            col*=0.5;\n    }\n    \n    \n    \n    \t//\tcol = pow(col, vec3(0.4545));   //gamma correction                  \n            fragColor = vec4(col, 0.1);\n}","name":"Image","description":"","type":"image"}]}