{"ver":"0.1","info":{"id":"MsjfRG","date":"1500987272","viewed":2119,"name":"Aurora Lights","username":"Mattenii","description":"Some aurora lights using Fractal Brownian Motion (FBM) and Perlin noise.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Noise functions\nfloat hash(vec2 co) { return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); }\nfloat hash(float x, float y) { return hash(vec2(x, y)); }\n\nfloat shash(vec2 co)\n{\n\tfloat x = co.x;\n\tfloat y = co.y;\n\t\n\tfloat corners = (hash(x-1., y-1.) + hash(x+1., y-1.) + hash(x-1., y+1.) + hash(x+1., y+1.))/16.;\n\tfloat sides   = (hash(x-1., y) + hash(x+1., y) + hash(x, y-1.) + hash(x, y+1.))/8.;\n\tfloat center  = hash(co) / 4.;\n\t\n\treturn corners + sides + center;\n}\n\nfloat noise(vec2 co)\n{\n\tvec2 pos  = floor(co);\n\tvec2 fpos = co - pos;\n\t\n\tfpos = (3.0 - 2.0*fpos)*fpos*fpos;\n\t\n\tfloat c1 = shash(pos);\n\tfloat c2 = shash(pos + vec2(0.0, 1.0));\n\tfloat c3 = shash(pos + vec2(1.0, 0.0));\n\tfloat c4 = shash(pos + vec2(1.0, 1.0));\n\t\n\tfloat s1 = mix(c1, c3, fpos.x);\n\tfloat s2 = mix(c2, c4, fpos.x);\n\t\n\treturn mix(s1, s2, fpos.y);\n}\n\nfloat pnoise(vec2 co, int oct)\n{\n\tfloat total = 0.0;\n\tfloat m = 0.0;\n\t\n\tfor(int i=0; i<oct; i++)\n\t{\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(0.5, float(i));\n\t\t\n\t\ttotal += noise(freq * co) * amp;\n\t\tm += amp;\n\t}\n\t\n\treturn total/m;\n}\n\n\n// FBM: repeatedly apply Perlin noise to position\nvec2 fbm(vec2 p, int oct)\n{\n\treturn vec2(pnoise(p + vec2(iTime, 0.0), oct), pnoise(p + vec2(-iTime, 0.0), oct));\n}\n\nfloat fbm2(vec2 p, int oct)\n{\n\treturn pnoise(p + 10.*fbm(p, oct) + vec2(0.0, iTime), oct);\n}\n\n// Calculate the lights themselves\nvec3 lights(vec2 co)\n{\n\tfloat d,r,g,b,h;\n\tvec3 rc,gc,bc,hc;\n\t\n\t// Red (top)\n\tr = fbm2(co * vec2(1.0, 0.5), 1);\n\td = pnoise(2.*co+vec2(0.3*iTime), 1);\n\trc = vec3(1, 0.0, 0.0) * r * smoothstep(0.0, 2.5+d*r, co.y) * smoothstep(-5., 1., 5.-co.y-2.*d);\n\t//rc = vec3(1., 0.1, 0.0) * clamp(1.0-r-16.0*r*pow(co.y-r-0.7,2.0), 0.0, 1.0);\n\t\n\t// Green (middle)\n\tg = fbm2(co * vec2(2., 0.5), 4);\n\tgc = 0.8*vec3(0.5,1.0,0.0) * clamp(2.*pow((3.-2.*g)*g*g,2.5)-0.5*co.y, 0.0, 1.0) * smoothstep(-2.*d, 0.0, co.y) * smoothstep(0.0, 0.3, 1.1+d-co.y);\n    \n\tg = fbm2(co * vec2(1.0, 0.2), 2);\n\tgc += 0.5*vec3(0.5,1.0,0.0) * clamp(2.*pow((3.-2.*g)*g*g,2.5)-0.5*co.y, 0.0, 1.0) * smoothstep(-2.*d, 0.0, co.y) * smoothstep(0.0, 0.3, 1.1+d-co.y);\n    \n\t\n\t// Blue (bottom)\n\th = pnoise(vec2(5.0*co.x, 5.0*iTime), 1);\n\thc = vec3(0.0, 0.8, 1.0) * pow(h+0.1,2.0) * smoothstep(-2.*d, 0.0, co.y+0.2) * smoothstep(-h, 0.0, -co.y-0.4);\n\t\n\treturn rc+gc+hc;\n}\n\n// Some water, turned off in main because it looks pretty bad\nvec3 water(vec2 co)\n{\n\tfloat n = fbm2(co*100.0, 2);\n\tvec3 col = vec3(0.3,0.3,0.4)*n*n * smoothstep(0.6, 0.8, 1.0-co.y);\n\t\n\treturn col;\n}\n\n// Simple Perlin mountains (yes, they change over time :D)\nvec3 landscape(vec2 co)\n{\n\tfloat n = pnoise(vec2(20.0*co.x, 0.1*iTime), 2);\n\t\n\tif (co.y < n*0.2+0.1)\n\t\treturn vec3(0.0);\n\t\n    vec3 col = vec3(0.5*pow(co.y-1.,2.));\n    \n    vec2 sco = co*500.0;\n\tif (hash(floor(sco)) < 0.005)\n    {\n        float s1 = hash(floor(sco)*floor(sco));\n        float s2 = max(1.-2.*distance(vec2(0.5),fract(sco)), 0.0);\n\t\treturn col + vec3(s1*s2);\n    }\n\n\treturn col;\n}\n\n// The main image!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 co = fragCoord.xy/float(iResolution.y);\n    \n    vec3 col = vec3(0.0);\n\t\n\t// Landscape\n\tcol += landscape(co);\n\t\n\t// Aurora (with some transformation)\n    float s = 0.1*sin(iTime);\n\t//float f = 0.6+uv.x*(0.4+uv.x*(-1.5-s+uv.x*(1.3+s)));\n    float f = 0.3+0.4*pnoise(vec2(5.*uv.x, 0.3*iTime),1);\n\tvec2 aco = co;\n\taco.y -= f;\n\taco *= 10.*uv.x+5.0;\n\tcol += 0.5*lights(aco)\n           * (smoothstep(0.3, 0.6, pnoise(vec2(10.*uv.x, 0.3*iTime),1))\n           +  0.5*smoothstep(0.5, 0.7, pnoise(vec2(10.*uv.x,iTime),1)));\n\t\n\t// Water\n\t//col += water(co);\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}