{"ver":"0.1","info":{"id":"fdfGWM","date":"1616008634","viewed":126,"name":"BMTH - Sempiternal Album Cover","username":"pontusasp","description":"Bring Me The Horizon - Sempiternal album cover with a shifting chromatic aberration effect.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["chromaticaberration","bmth","sempiternal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 p;\nfloat aspect;\n\nvec3 circle(vec2 sp, float r, float bt) {\n    vec3 c = vec3(0.);\n    for (int i = 0; i < 3; i++) {\n        float dist = length(sp-p);\n        \n        c[i] = smoothstep(r - bt/2., r - bt/5., dist) - smoothstep(r + bt/5., r + bt/2., dist);\n    \n        sp -= sin(p * 3.1415 / 2.) * vec2(.003, .002);\n    }\n    return c;\n}\n\nvec3 sempiternal(vec2 pos) {\n    vec3 c = vec3(0.);\n \n    float border = .014;\n    float bigR = .428;\n    c += circle(pos, bigR + .022, border);\n    c += circle(pos, bigR, border);\n    \n    float bound = bigR - border;\n    float r = (bound-border) / 5.;\n    \n    for (float x = 0.; x < bound; x += r*2.) {\n        for (float xy = 0.; xy < 1.1; xy += 1.)\n        for (float y = 0.; y < bound; y += r*2.) {\n            for (float mx = 1.; mx >= -1.; mx -= 2.) {\n                for (float my = 1.; my >= -1.; my -= 2.) {\n                \n                    \n                    vec2 sp = vec2((x * 0.86) * mx, y * my - (x/(bound-r-border))*r*2. + r * xy);\n                    sp += pos;\n\n                    if (length(sp - pos) + r < bound)\n                        c += circle(sp, r, border);\n                    //else c += vec3(1., .0,.0) * circle(sp, r, border);\n                    \n                    \n                    if (y == -y) break;\n                }\n                if (x == -x) break;\n            }\n        }\n    }\n    \n    for (float x = r; x < bound-r; x += r*2.) {\n        for (float xy = 0.; xy < 1.1; xy += 1.)\n        for (float y = 0.; y < bound; y += r*2.) {\n            for (float mx = 1.; mx >= -1.; mx -= 2.) {\n                for (float my = 1.; my >= -1.; my -= 2.) {\n                \n                \n                    vec2 sp = vec2((x * 0.86) * mx, y * my - (x/(bound-r-border))*r*2. + r * xy);\n                    sp += pos;\n\n                    if (length(sp - pos) + r < bound)\n                        c += circle(sp, r, border);\n                    //else c += vec3(.0,1.,.0) * circle(sp, r, border);\n                    \n                    \n                    if (y == -y) break;\n                }\n                if (x == -x) break;\n            }\n        }\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = (fragCoord - .5 * iResolution.xy) / iResolution.y; // Neater pixel coord calculation, vector op's in rest of code &\n    vec3 c = vec3(.0);                                     // c now initialized, thanks FabriceNeyret2 :)\n    \n    vec2 panning = vec2(\n        cos(iTime)/2.,\n        sin(iTime)/2.\n    );\n    \n    p += panning;\n    c += sempiternal(panning);\n    \n    //c += circle(vec2(sin(iTime/2.) * 2. / 3., .0), .2, .02); // left to right\n    //c += circle(vec2(-sin(iTime/2.) * 2. / 3., .0), .2, .02); // right to left\n    //c += circle(vec2(.0, .0), (1.+sin(iTime / 4.)) / 2., .03); // smaller bigger\n\n    // Output to screen\n    fragColor = vec4(c,1.);\n}","name":"Image","description":"","type":"image"}]}