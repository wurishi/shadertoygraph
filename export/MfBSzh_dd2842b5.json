{"ver":"0.1","info":{"id":"MfBSzh","date":"1706187839","viewed":81,"name":"Reverberation test","username":"TambakoJaguar","description":"I wanted to create a reverberation with diffusion since a long time. I finally did it and could manage it all by myself without reading papers and so, besides that I lost time because of the problem explained on line 88 ;)\nComments welcome as usual!","likes":1,"published":1,"flags":8,"usePreview":0,"tags":["sound","music","diffusion","notes","dsp","reverberation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float freq = getFreq(iTime);\n    float ampn = getEnvelope(mod(iTime, note_length)/note_length, note_length, attack_time, release_time);\n    float amp = ampn*getAmp(iTime);\n    \n    vec3 col1 = vec3(0.);\n    vec3 col2 = vec3(0.);\n    col1.r = smoothstep(250., 375., freq)*amp;\n    col1.g = smoothstep(500., 375., freq)*amp;\n    float ramp = getReverb(iTime, false, true);\n    col2.b = 1.5*pow(ramp, 0.35);\n    col2.g = 0.9*pow(col2.b, 2.5);\n    \n    // Draws blurry circles with arp notes in the green/yellow/red left one and reverb in the blue right one\n    vec2 uv = fragCoord/iResolution.xx;\n    float rfact = iResolution.x/iResolution.y;\n    float c1amp = smoothstep (0.1 + 0.33*amp, 0.2*amp, distance(vec2(0.4*rfact, 0.5), uv*rfact));\n    float c2amp = smoothstep (0.25 + 1.2*ramp, 0.15 + 0.8*ramp, distance(vec2(0.6*rfact, 0.5), uv*rfact));\n\n    // Output to screen\n    fragColor = vec4(col1*c1amp + col2*c2amp, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound(int samp, float time)\n{\n    return getMainSound(time);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"// note frequencies\n#define FC  261.626\n#define FCH 277.183\n#define FD  293.665\n#define FDH 311.127\n#define FE  329.628\n#define FF  349.228\n#define FFH 369.994\n#define FG  391.995\n#define FGH 415.305\n#define FA  440.000\n#define FAH 466.164\n#define FB  493.883\n\nfloat repeat_time = 4.;                      // After how many seconds the arp repeats\n\nvec4 chord_notes = vec4(FC, FE, FG, FC*2.);  // Notes which will be played by the arp\nfloat note_length = 0.2;                     // Length of every note in seconds\nfloat attack_time = 0.03;                   // Attack time of every note in seconds\nfloat release_time = 0.12;                   // Release time of every note in seconds\nfloat nb_chords = 2.;                        // Number of times that the arp is repeated per \"cycle\"\nfloat wave_factor = 0.3;                     // 0.: sine wave, 1.: square wave, but you can morph between both\n\nfloat rev_decay = 3.;                        // Decay time of the reverv in seconds, but it's just an approximation             \nfloat rev_rise_fac = 5.;                     // Factor how much shorter the rise time of the reverb is in comparison with the decay time\nfloat rev_delay = 0.03;                      // Delay in seconds between the arp and the start of the reverb\nfloat rev_wet = 0.5;                         // Reverb dry/wet. 0.: totally dry, you only hear the arp. 1.: totally wet, you only hear the reverb\nfloat rev_amp = 25.;                         // Amplification of the reverb, yes, it's quite high\nfloat time_window = 4.;                      // Time window to calculate the convolution of the reverb. Should be higher than the decay, ideally the double\nint nb_samples = 3000;                       // Number of samples for reverb diffusion. I set it to 3000 for a rather good quality, but if you computer is slow at compiling, you can set lower, althought it's starting to be quite bad underneath 1000\nint nb_samples_disp = 300;                   // Number of samples to show the reverb. It's better that it's low, so that it's not stressing the GPU and the quality stays okay\n\nfloat main_volume = 0.5;                     // Main volume of the arp and reverb together\n\n#define stereo_reverb                        // If activated, the reverb will be in stereo, which sound much nicer, especially with headphones, but it will take more time to compile\n\nfloat hash( float n )\n{\n    return fract(sin(861.571*fract(sin(n)*755.5453123)));\n}\n\nfloat getAmp(float time)\n{\n    float time2 = mod(time, repeat_time);\n    \n    return time2<nb_chords*note_length*4.?1.:0.;\n}\n\nfloat getFreq(float time)\n{\n    float time2 = mod(time, repeat_time);\n    \n    float nnb = floor(mod(time2, note_length*4.)/note_length);\n    return nnb==0.?chord_notes.x:(nnb==1.?chord_notes.y:(nnb==2.?chord_notes.z:chord_notes.w));\n}\n\nfloat getWave(float time)\n{\n   float freq = getFreq(time);\n   return 2.*smoothstep(-wave_factor, wave_factor, sin(6.2831*freq*time)) - 1.0;\n}\n\nfloat getEnvelope(float time, float note_length, float attack_time, float release_time)\n{\n    return smoothstep(0., attack_time, time)*smoothstep(note_length, note_length - release_time, time);\n}\n\nfloat getSound(float time)\n{\n    float sound = getWave(time)*getEnvelope(mod(time, note_length)/note_length, note_length, attack_time, release_time);\n    float amp = getAmp(time);\n\n    return sound*amp;\n}\n\nfloat getReverbInt(float time)\n{\n    return exp(-5./rev_decay*time)*(1. - exp(-5.*rev_rise_fac*time/rev_decay));\n}\n\nfloat getReverb(float time, bool right_channel, bool fordisp)\n{\n    int nbsamples = fordisp?nb_samples_disp:nb_samples;\n    float rev_sound = 0.;\n    float rand_time;\n    for (int s = 0; s < nbsamples; ++s)\n    {\n        // time*17.834 is very bad, it introduces noise!!!\n        //rand_time = time_window*pow(hash(time*17.834 + float(s)*0.2845), 3.);\n        rand_time = time_window*pow(hash(float(s)*(right_channel?2.3427:3.2845)), 1.5);\n        float rstime = -rev_delay + time - rand_time;\n        if (rstime>0.)\n        {\n            float rev_int = getReverbInt(rand_time);\n            float sound = fordisp?getAmp(rstime)*max(0.5, getEnvelope(mod(rstime, note_length)/note_length, note_length, attack_time, release_time)):getSound(rstime);\n            rev_sound+= sound*rev_int;\n        }\n    }\n    rev_sound/= float(nbsamples);  \n    \n    return rev_sound;\n}\n\nvec2 getMainSound(float time)\n{\n    float sound = getSound(time);\n    \n    #ifdef stereo_reverb\n    float rev_sound_l = rev_amp*time_window*(getReverb(time, false, false));\n    float rev_sound_r = rev_amp*time_window*(getReverb(time, true, false));\n    vec2 rev_sound = vec2(rev_sound_l, rev_sound_r);\n    vec2 sound_rev;\n    #else\n    float rev_sound = rev_amp*time_window*(getReverb(time, false));\n    float sound_rev;\n    #endif\n    sound_rev = main_volume*(rev_wet<0.5?(sound + 2.*rev_wet*rev_sound):(rev_sound + (2. - 2.*rev_wet)*sound));\n    \n    return vec2(sound_rev);\n}\n","name":"Common","description":"","type":"common"}]}