{"ver":"0.1","info":{"id":"NtyGW1","date":"1637683312","viewed":281,"name":"Hyperbolic triangle groups","username":"TotallyReal","description":"Tiling the hyperbolic plane using the triangle groups + adding a bit of dynamics for the animation.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["dynamics","trianglegroups","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nA bit about triangle groups:\n\nStart with one triangle and take its reflections through each of its edges. Then for each reflection, \ntake its reflection through each of its edges (one of them will be the original triangle). Continue like\nthis until you cover the whole plane.\n\nIn general, the triangles that we get this way can intersect one another. To avoid messy images, if\ntwo such triangles intersect, we want them to be exactly the same. For example, if we look at triangle \nreflections around a single vertex, they all have the same angle near that vertex. Hence, this angle must\ndivide 2*PI for this overlap=identical condition, and unless the triangle is an isosceles triangle, the\nangle must divide PI. In other words all the angles should be of the form PI/N for some integer N.\n\nWe now have the three angles PI/L, PI/N and PI/M.\nIn the Euclidean geometry, the sum of the angles in a triangle is PI, so that 1/L + 1/M + 1/N = 1.\nIn a spherical geometry the sum will be larger than 1 and in the hyperbolic geometry (in this sketch) it is \nsmaller than 1.\nChange the SHOW_REFLECTIONS to \"true\" in order to see the triangles.\n\nIn non Euclidean geometry, the \"lines\" are no longer straight, and instead are defined by shortest path between \ntwo points. These are called geodesics.\n\nOnce you have a single trianle defined by three geodesics, we can move each point outside the triangle\ninto it using a sequence of reflections. If a point is not inside the triangle, then one of the geodesics\nseparates it from the triangle, so we take its reflection though that geodesic (change the ONLY_TRIANGLE\nto true to see the 3 geodesics defining it). A bit of math magic shows that each point will eventually \nfind its way into your original triangle, and no matter the order of your reflections, \nit will end up at the same place.\n\nFinally, add some texture to your triangle, and use the procedure above to spread it out to the whole plane.\n\n*/\n\n\n// Use the Poincare disk model\nconst bool POINCARE = false; \n\n// Only see the triangle which is the fundamental\n// domain (from which we take the texture and reflect it).\nconst bool ONLY_TRIANGLE = false;\n\n// darken domains which need odd number of steps to get to the main fundamental domain.\nconst bool SHOW_REFLECTIONS = false;\n\n// ------------------------------ Triangle Group ------------------------------\n\n// Assumption: We need L,M,N such that 1/L + 1/M + 1/N < 1.\n//             At most one of them can be 2, so assume that N>=2 while L,M>=3.\n\n// Find out how to do it in preprocessing and not using consts.\nconst int TRI_N = 2;\nconst int TRI_M = 3;\nconst int TRI_L = 13;\n\nconst float PI = 3.1415926535;\nconst float THETA_0 = PI/float(TRI_N);\nconst float THETA_1 = PI/float(TRI_M);\nconst float THETA_2 = PI/float(TRI_L);\n// Just so I won't forget how I did this computation...  again...\n// https://drive.google.com/file/d/1-58AlL_sq_QeO1ii6bDwq5L-8qYL2_Gg/view?usp=sharing\nconst float TRI_b = (cos(THETA_0)*cos(THETA_1) + cos(THETA_2))/(sin(THETA_0)*sin(THETA_1));\n\nconst mat2 TRI_mat2 = mat2(1.,0.,0.,1.);\n\nconst float TRI_Y1 = (TRI_b + sqrt(TRI_b*TRI_b - 1.));\nconst float TRI_X1 = -TRI_Y1 / tan(THETA_1);\nconst float TRI_R1 = sqrt(TRI_Y1*TRI_Y1 + TRI_X1*TRI_X1);\nconst mat2 TRI_mat1 = mat2(TRI_X1+TRI_R1, TRI_X1-TRI_R1, 1., 1.);\n\nconst float TRI_Y0 = 1.;\nconst float TRI_X0 = TRI_Y0 / tan(THETA_0);\nconst float TRI_R0 = sqrt(TRI_Y0*TRI_Y0 + TRI_X0*TRI_X0);\nconst mat2 TRI_mat0 = mat2(TRI_X0-TRI_R0, -(TRI_X0+TRI_R0), 1., -1.);\n\n\n// ------------------------------ Complex field operations ------------------------------\n\n\nconst vec2 comp_1 = vec2(1., 0.);\nconst vec2 comp_I = vec2(0., 1.);\n\nvec2 compMult(vec2 z, vec2 w){\n    return vec2(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 compInv(vec2 z){\n    float d = z.x*z.x + z.y*z.y;\n    return vec2(z.x/d, -z.y/d);\n}\n\nvec2 compDiv(vec2 numerator, vec2 denominator){\n    return compMult(numerator, compInv(denominator));\n}\n\n// assumption: neither z nor op(z) is infinity.\nvec2 mobius(mat2 op, vec2 z){\n    vec2 numerator = op[0][0]*z + vec2(op[0][1], 0.);\n    vec2 denominator = op[1][0]*z + vec2(op[1][1], 0.);\n    return compDiv(numerator, denominator);\n}\n\n//transform a complex number from the Poincare disc to the upper half plane\nvec2 fromPoincare(vec2 z){\n    // z -> -i*(z-1)/(z+1)\n    vec2 numerator = z - comp_1;\n    vec2 denominator = z + comp_1;\n\tvec2 w = compDiv(numerator, denominator);\n    return - compMult(w, comp_I);\n}\n\n//transform a complex number from the upper half plane to the Poincare disc\nvec2 toPoincare(vec2 z){\n    // z -> (1+iz)/(1-iz)\n    vec2 w = compMult(z, comp_I);//vec2(z.y, -z.x);\n    vec2 numerator = w + comp_1;\n    vec2 denominator = comp_1 - w;\n\treturn compMult(numerator, compInv(denominator));\n}\n\n\n// ------------------------------ Fundamental domains ------------------------------\n\nconst int MAX_STEPS = 16;\n\n// assumption: point.y>0 (positive imaginary part).\n// operations: z->  z+1, z-1, and z->-1/z\nvec2 toFundamentalDomainLattices(vec2 point, out int reflections){\n    int steps = 0;\n    while (steps<MAX_STEPS){\n        // Change point.x by an integer and move it to [-0.5, 0.5].\n        point.x -= floor(point.x+0.5);\n        \n        float d = length(point);\n        if (d>1.)  // in the fundamental domain\n            return point;\n            \n        // apply z -> -1/z = -conj(z)/|z|^2\n        point.x *= -1.;\n        point/=(d*d);\n        steps ++;            \n    }\n\n}\n\n// assumption: point.y>0 (positive imaginary part).\n// corresponds to the triangle for (N, M, infinity).\nvec2 toFundamentalDomainTriangleInfinity(vec2 point, out int reflections, int N, int M){\n    reflections = 0;\n    int steps = 0;\n    // should be moved to uniforms, together with N,M.\n    float x_N = N>0?cos(PI/float(N)):1.;\n    float x_M = M>0?cos(PI/float(M)):1.;\n    while (steps<MAX_STEPS){\n        // translate by jumps of size 2*(x_M+x_N) to end in [-x_M, x_M+2*x_N].\n        float n = floor((point.x+x_M)/(2.*(x_M+x_N)));\n        point.x -= 2.*(x_M+x_N)*n;\n        reflections += 2*int(abs(n));\n        //reflect through x=x_N if needed\n        if (point.x > x_N){\n            reflections += 1;\n            point.x = (2.*x_N)-point.x;\n        }\n        \n        float d = length(point);\n        if (d>1.)  // in the fundamental domain\n            return point;\n            \n        // apply z -> -1/z = -conj(z)/|z|^2\n        point/=(d*d);\n        reflections += 1;\n        steps ++;            \n    }\n    return vec2(0.);\n}\n\n/*\nChecks if z is in the positive side of the geodesic defined by the given operation (namely op^(-1)(z)\nhas a positive real value). If so, reflect it and return 1. Otherwise do not change it and return 0.\n*/\nint reflectThrough(vec2 z, mat2 op, out vec2 result){\n    result = z;\n    vec2 u = mobius(inverse(op), z);\n    if (u.x>0.)\n        return 0;\n    u.x *= -1.;\n    result = mobius(op, u);\n    return 1;        \n}\n\n// assumption: point.y>0 (positive imaginary part).\nvec2 toFundamentalDomainTriangle(vec2 point, out int reflections){\n    reflections = 0;\n    int steps = 0;\n    while (steps<MAX_STEPS){\n        int extra = \n            reflectThrough(point, TRI_mat0, point) + \n            reflectThrough(point, TRI_mat1, point) +\n            reflectThrough(point, TRI_mat2, point);\n        if (extra==0)\n            return point;\n        reflections += extra;\n        steps ++;            \n    }\n    return point;\n\n}\n\n// ------------------------------ geometric actions ------------------------------\n\nmat2 rotation(float angle){\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nmat2 shearing(float t){\n    return mat2(1., t, 0., 1.);\n}\n\n// ------------------------------ main ------------------------------\n\nconst float minY = 0.;\nconst float maxY = 2.;\nconst vec3 WHITE = vec3(1.);\nconst vec3 BLACK = vec3(0.);\n\nconst vec2 OUT_OF_BOUNDS = vec2(0., -1.);\n\n/**\n * Transform the fragCoord to the coordinate in our hyperbolic space.\n * The fog is just to make the edges more foggy...\n */\nvec2 spaceCoordinate(vec2 fragCoord, out float fog){\n    fog = 1.;\n    vec2 v;\n    if (POINCARE){\n        // move origin to the center of the screen, and normalize so that y goes from -1 to 1 and the\n        // ratio between width and height is preserved.\n        vec2 uv = (fragCoord.xy-iResolution.xy/2.)/(0.5*iResolution.y);\n        \n        float d = length(uv);\n        if (d>0.95)\n            fog = (1.-d)/0.05;\n            \n        v = fromPoincare(uv);\n    } else {\n        // Normalized pixel coordinates as follows:\n        //     1. x is symmetric with 0 in the middle of the screen, and\n        //     2. y goes from minY to maxY.\n        vec2 uv = (fragCoord-vec2(iResolution.x/2.,0))*(maxY-minY)/iResolution.y;\n        uv += vec2(0, minY);\n        \n        if (uv.y<0.1)\n            fog = uv.y/0.1;\n            \n        v = uv;\n    }\n    \n    if (v.y<=0.){ // outside the upper half plane should not have coordinates.        \n        return OUT_OF_BOUNDS;\n    }\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fog = 1.;\n    vec2 v = spaceCoordinate(fragCoord, fog);\n    \n    // outside of the upper half plane paint with black.\n    if (v == OUT_OF_BOUNDS){\n        fragColor = vec4(BLACK,1.0);\n        return;\n    }\n    \n    if (ONLY_TRIANGLE){\n        // Use this part to see the triangle which is the fundamental\n        // domain (from which we take the texture and reflect it).\n        fragColor = vec4(\n            step(mobius(inverse(TRI_mat0), v).x,0.),\n            step(mobius(inverse(TRI_mat1), v).x,0.),\n            step(mobius(inverse(TRI_mat2), v).x,0.),\n            1.);\n        return;\n    }\n    \n    \n    // add dynamics - move the whole tiling.\n    float t = iTime/2.;\n    mat2 m = rotation(-t)*shearing(t);//*rotation(t/10.);\n    // Consider moving the matrix to a fundamental domain also.\n    // This should be a uniform operation over all pixels, and \n    // can help decrease the MAX_STEPS.\n    // Right now, after enough time passes, there are many points\n    // that don't get to the fundamental domain after MAX_STEPS steps.\n    v = mobius(m,v);\n    \n    // Move point to the fundamental domain, and paint according to its corresponding point in the texture.\n    int reflections = 0;\n    v = toFundamentalDomainTriangle(v, reflections);\n    //v = toFundamentalDomainTriangleInfinity(v, reflections, 0, 0);\n    reflections %= 2;\n    \n    float coef = 1.;\n    if (SHOW_REFLECTIONS)\n        coef = (1.+float(reflections))/2.;\n        \n        \n    // add second dynamics to move the location in the texture from which we choose the pixels.\n    /*v += 2.*vec2(cos(iTime/7.), sin(-iTime/5.));\n    v *= (cos(iTime/10.)*0.2 + 0.6);\n    v = rotation(iTime/8.)*v;*/\n        \n    fragColor = vec4(1.2*texture(iChannel0, v/maxY).rgb*fog*coef,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}