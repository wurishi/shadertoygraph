{"ver":"0.1","info":{"id":"WsfcDS","date":"1585423919","viewed":69,"name":"Filtered Raymarching scene","username":"mothman","description":"filtering as used in https://iquilezles.org/articles/checkerfiltering/checkerfiltering.htm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","patterns","filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DIST 0.01\n#define THRESHOLD 0.01\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat GetDist(vec3 p, out int id)\n{\n\n    vec4 c = vec4(0.0,1.90,6.0,1.0);\n    float circ = length(p-c.xyz)-c.w;\n    float plane = p.y+1.0; \n    float plane2 = sdPlane(p,vec4(-1,0,0,7));\n    float plane3 = sdPlane(p,vec4(0,0,-1,15));\n    float minval = min(plane,circ);\n    \n    if(minval <= SURFACE_DIST)\n    {\n        if(minval == circ) id = 1;\n        if(minval== plane) id = 2;\n   \n        \n    }\n    return minval;\n}\nfloat RayMarch(vec3 ro, vec3 rd,out int id){\n    float d = 0.0;\n    vec3 p = ro;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        p  = ro + rd*d;\n        float dS = GetDist(p,id);\n        d += dS;\n        if(dS < SURFACE_DIST || d > MAX_DISTANCE) break;\n    }\n    return d;\n}\nvec3 GetNormal( vec3 p){\n   vec3 norm = vec3(0);\n   vec2 e = vec2(0.01,0.0);\n   int id = 0;\n   float d = GetDist(p,id);\n   norm = vec3(d) - vec3( GetDist(p-e.xyy,id),GetDist(p-e.yxy,id),GetDist(p-e.yyx,id));\n   return normalize(norm);\n}\nvoid calcCamera(out vec3 ro, out vec3 ta)\n{\n    float an = sin(0.1*iTime);\n  ro = vec3( 6.0*cos(an), 1., 6.0+5.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 6.0 );\n}\nvoid calcRayForPixel(in vec2 pix,out vec3 Ro, out vec3 Rd)\n{\n    vec2 p =(2.0*pix - iResolution.xy)/iResolution.y;\n    vec3 ro, rd,ta;\n    calcCamera(ro,ta);\n    \n    vec3 ww = normalize(ta - ro); //from ray origin to target\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)));// y-up boiz\n    vec3 vv = normalize(cross(uu,ww));\n    Ro = ro;\n    Rd = normalize( p.x * uu + p.y * vv + 2.0*ww);\n}\nfloat Light( vec3 p )\n{\n    vec3 lightSource = vec3(2.*sin(iTime),5. , 6.+2.*cos(iTime));\n    vec3 l = normalize(lightSource - p);\n    vec3 n = GetNormal(p);\n    float diff = max(dot(n,l),0.0);\n    int id = 0;\n    float d = RayMarch(p+n*SURFACE_DIST*2.,l,id);\n    if(d < length(p-lightSource)) diff = 0.01;\n    return diff;\n}\nvec2 texCoords( vec3 p ,int id )\n{\n    vec2 m;\n    if(id == 2)\n    {\n        m = p.xz;\n    }\n    return 2.0*m;\n}\n// triangular signal\nvec2 tri( in vec2 x )\n{\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\nfloat checkersTexture(in vec2 p)\n{\n    vec2 s = sign(fract(p*0.5)-0.5);\n    return 0.5 - 0.5*s.x*s.y;\n}\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n       // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n\n          \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   vec3 ro,rd;\n   vec3 ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n   calcRayForPixel(fragCoord + vec2(0.0,0.0)  ,ro,rd);\n   calcRayForPixel(fragCoord + vec2(1.0,0.0)  ,ddx_ro,ddx_rd);\n   calcRayForPixel(fragCoord + vec2(0.0,1.0)  ,ddy_ro,ddy_rd);\n   \n   int id = 0;\n   float d = RayMarch(ro,rd,id);\n   float ddx = RayMarch(ddx_ro,ddx_rd,id);\n   float ddy = RayMarch(ddy_ro,ddy_rd,id);\n   \n   vec3 p = ro + rd*d;\n   vec3 px = ddx_ro + ddx_rd *ddx;\n   vec3 py = ddy_ro + ddy_rd *ddy;  \n   float dif  = Light(p);\n   vec3 color = vec3(0.0f);\n    if(id == 2){\n       vec2 uv = texCoords(p , id);\n       vec2 uvx = texCoords(px , id)-uv;\n       vec2 uvy = texCoords(py , id)-uv;\n       color = vec3(1.0)*checkersTextureGradBox(uv,uvx,uvy);\n       // color = vec3(1.0)*checkersTexture(uv); // unfiltered pattern.\n        dif+=0.06;\n        color *=dif;\n        \n    }\n    else if( id ==1 ){\n        color = vec3(1.0f);\n        dif +=0.08;     \n        color *=dif;\n        \n    }\n   \n   color = pow( color, vec3(0.4545) );\n   fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}