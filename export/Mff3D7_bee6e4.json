{"ver":"0.1","info":{"id":"Mff3D7","date":"1703128868","viewed":23,"name":"perlinnoisetest","username":"hppz","description":"test for fbm","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//random vector\nfloat hash( vec2 p )\n{\n    float n = p.x + p.y*57.0;\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash21(vec2 p)\n{\n    //计算p与一个固定向量的点积,转化为float\n\tfloat h = dot(p,vec2(125.,250.5));\n\t\n    return  -1.+2.*fract(sin(h)*43758.5453);\n}\n\nvec2 hash22(vec2 p)\n{\n    //p乘以一个固定矩阵\n    p = p*mat2(1111,222.2,333.3,144.4);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453);\n    //随time变化，返回2维向量\n\treturn sin(p * 3.141 + iTime);\n}\n\n\nfloat perlinNoiseLerp(float l, float r, float t)\n{\n    t = ((6.0 * t - 15.0) * t + 10.0) * t * t * t;\n    return mix(l, r, t);\n}\n\n\nfloat perlin_noise(vec2 p)\n{\n    //pi和pf（像素坐标和相对于格子的偏移）\n\tvec2 pi = floor(p);\n    //\n    vec2 pf = p-pi;\n    \n    //计算uv\n    vec2 uv = pf*pf*(3.-2.*pf);\n    \n    //四个点ABCD=0,0\\0,1\\1,0\\1,1\n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float temp0 = perlinNoiseLerp(f00,f10,uv.x);\n    float temp1 = perlinNoiseLerp(f01,f11,uv.x);\n    float noiseValue = perlinNoiseLerp(temp0, temp1, uv.y);\n    //去除黑边\n    return noiseValue = (noiseValue + .5) / 2.0;\n   \n}\n\n\nfloat noise_one_octave(vec2 p){\n    float r = 0.0;\n    //0.125* :柔和过度\n    //*30. 扩大30倍密度/频率\n\tr += 0.125*abs(perlin_noise(p*30.));\n    return r;\n}\n\nfloat fbm( vec2 p )\n{\n   p *= 4.;\n   float a = 1., r = 0., s=0.;\n    \n   for (int i=0; i<5; i++) {\n     //每次频率翻倍，强度减半\n     r += a*abs(perlin_noise(p)); s+= a; p *= 2.; a*=.5;\n   }\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv *= vec2(iResolution.x/iResolution.y,1.);\n     \n    float f = fbm(uv);\n    //float f = noise_one_octave(uv);\n    \n    vec3 lightColor = vec3(1.0);\n\t\n    vec3 color = vec3(lightColor * f);\n   \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}