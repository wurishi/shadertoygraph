{"ver":"0.1","info":{"id":"4cXfW4","date":"1723727455","viewed":61,"name":"Gaussian Sinc","username":"MartyMcFly","description":"\"Image Interpolation via Gaussian-Sinc Interpolators with Partition of Unity\" \nSupposedly better interpolator than Lanczos.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["gaussian","lanczos","sinc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n\nfloat sinc(float x)\n{\n    return abs(x) < 1e-4 ? 1.0 : sin(PI * x) / (PI * x);\n}\n\nfloat window_lanczos( float x )\n{\n    const float tau = 2.0;\n    return abs(x) > 2.0 ? 0.0 : sinc(x / tau) * sinc(x);   \n}\n\nfloat window_gaussiansinc(float x)\n{\n    const float a = 1.0/3.0;\n    const float b = 1.0/2.0;\n    const float lambda = 0.04588808;  //hand-evaluated, the formula in the paper is wrong\n    float window = sinc(x) * exp(-a*x*x);    \n    float improved = lambda * x * sin(PI * x) * exp(-b*x*x);    \n    return window + improved;\n}\n\nvec4 get_texture(sampler2D s, vec2 uv)\n{\n    return texture(s, uv);\n}\n\nvec4 resample_lanczos(sampler2D s, vec2 uv)\n{\n    vec2 size = vec2(textureSize(s, 0));\n    vec2 iuv = uv * size; \n\n    vec2 center = floor(iuv - 0.5) + 0.5;\n    \n    float wsum = 0.0;\n    vec4 res = vec4(0.0);\n    \n    for(int x = -2; x <= 3; x++)\n    for(int y = -2; y <= 3; y++)\n    {\n        vec2 offs = vec2(x, y);\n        vec2 read_uv = (center + offs) / size;        \n        vec2 kernel_xy = iuv - (center + offs);\n        float kernel = window_lanczos(kernel_xy.x) * window_lanczos(kernel_xy.y);\n        \n        res += get_texture(s, read_uv) * kernel;\n        wsum += kernel;\n    }\n    \n    return res / wsum;\n}\n\nvec4 resample_gaussiansinc(sampler2D s, vec2 uv)\n{\n    vec2 size = vec2(textureSize(s, 0));\n    vec2 iuv = uv * size;\n    vec2 center = floor(iuv - 0.5) + 0.5;\n    \n    float wsum = 0.0;\n    vec4 res = vec4(0.0);\n    \n    for(int x = -2; x <= 3; x++)\n    for(int y = -2; y <= 3; y++)\n    {\n        vec2 offs = vec2(x, y);\n        vec2 read_uv = (center + offs) / size;        \n        vec2 kernel_xy = iuv - (center + offs);\n        float kernel = window_gaussiansinc(kernel_xy.x) * window_gaussiansinc(kernel_xy.y);\n        \n        res += get_texture(s, read_uv) * kernel;\n        wsum += kernel;\n    }\n    \n    return res / wsum;\n}\n\nvec4 resample_catrom_5taps(sampler2D s, vec2 uv)\n{\n    vec2 size = vec2(textureSize(s, 0));\n    vec2 UV = uv * size;\n    vec2 tc = floor(UV - 0.5) + 0.5;\n\tvec2 f = UV - tc;\n\tvec2 f2 = f * f; \n\tvec2 f3 = f2 * f;\n    \n    vec2 w0 = f2 - 0.5 * (f3 + f);\n\tvec2 w1 = 1.5 * f3 - 2.5 * f2 + 1.0;\n\tvec2 w3 = 0.5 * (f3 - f2);\n\tvec2 w12 = 1.0 - w0 - w3;\n\n    vec4 ws[3];    \n    ws[0].xy = w0;\n\tws[1].xy = w12;\n\tws[2].xy = w3;\n\n\tws[0].zw = tc - 1.0;\n\tws[1].zw = tc + 1.0 - w1 / w12;\n\tws[2].zw = tc + 2.0;\n\n\tws[0].zw /= size;\n\tws[1].zw /= size;\n\tws[2].zw /= size;\n\n    vec4 ret;\n    ret  = get_texture(s, vec2(ws[1].z, ws[0].w)) * ws[1].x * ws[0].y;    \n    ret += get_texture(s, vec2(ws[0].z, ws[1].w)) * ws[0].x * ws[1].y;    \n    ret += get_texture(s, vec2(ws[1].z, ws[1].w)) * ws[1].x * ws[1].y;    \n    ret += get_texture(s, vec2(ws[2].z, ws[1].w)) * ws[2].x * ws[1].y;    \n    ret += get_texture(s, vec2(ws[1].z, ws[2].w)) * ws[1].x * ws[2].y;    \n    float normfact = 1.0 / (1.0 - (f.x - f2.x)*(f.y - f2.y) * 0.25); //PG23: closed form for the weight sum\n    return ret * normfact;   \n}\n\n\n//Stolen from Fabrice Neyret. Always fascinating how convoluted and unreadable he can make easy things\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) \n{\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\n\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) O += char(U,64+CAPS+c);spc \n\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n\nvoid mainImage( out vec4 o, in vec2 p )\n{   \n    vec2 uv = p/iResolution.xy;\n    \n    float zoom_ease = abs(fract(iTime*0.15) - 0.5)*2.0-0.5;\n    zoom_ease *= 3.0;\n    zoom_ease = clamp(zoom_ease * 1.5 + 0.5, 0.0, 1.0);\n    zoom_ease = smoothstep(0.0, 1.0, zoom_ease);\n    \n    //float zoom_ease = sin(iTime*0.7)*2.5;\n    //zoom_ease *= inversesqrt(1.0 + zoom_ease*zoom_ease);\n    //zoom_ease = zoom_ease * 0.5 + 0.5;\n    \n    float scale = mix(0.3, 0.15, zoom_ease);//0.2; \n    \n    vec2 mouseshift = iMouse.xy / iResolution.xy; \n    if(mouseshift.x == 0.0 && mouseshift.y == 0.0) mouseshift = vec2(0.55,0.41);\n    \n    \n    vec2 shift = mix(vec2(scale)*0.5, vec2(1.0-scale*0.5), mouseshift);       \n    \n    vec2 zoomed_uv = uv;\n    zoomed_uv = fract(zoomed_uv * 2.0)/2.0;    \n    zoomed_uv = (zoomed_uv - 0.5) * scale + shift;   \n     \n    vec3 col = texture(iChannel0, zoomed_uv).rgb;\n    vec4 O = vec4(0);\n    \n    if(uv.y > 0.5)\n    {\n        if(uv.x > 0.5)\n        {        \n            col = resample_catrom_5taps(iChannel0, zoomed_uv).rgb;\n            \n            vec2 U = (uv + vec2(-0.5, -0.5)) * vec2(iResolution.x / iResolution.y, 1.0) * 20.0; U.y-=0.05; U.x-=4.2;  \n            caps C(3) low C(1)C(20)C(13)C(21)C(12)C(12)C(-51) caps C(18) low C(15)C(13) spc C(-43)C(-51) caps C(20) low C(1)C(16)\n        }\n        else        \n        {\n            col = col;\n            vec2 U = (uv + vec2(0.0, -0.5)) * vec2(iResolution.x / iResolution.y, 1.0) * 20.0; U.y-=0.05;  U.x-=6.5;      \n            caps C(2) low C(9)C(12)C(9)C(14)C(5)C(1)C(18)\n        }            \n    }\n    else\n    {\n        if(uv.x > 0.5)\n        {\n            col = resample_gaussiansinc(iChannel0, zoomed_uv).rgb;\n            \n            vec2 U = (uv + vec2(-0.5, 0.0)) * vec2(iResolution.x / iResolution.y, 1.0) * 20.0; U.y-=0.05;U.x-=5.1;         \n            caps C(7) low C(1)C(21)C(19)C(19)C(9)C(1)C(14) spc caps C(19) low C(9)C(14)C(3)\n        }            \n        else \n        {\n            col = resample_lanczos(iChannel0, zoomed_uv).rgb;            \n            \n            vec2 U = uv * vec2(iResolution.x / iResolution.y, 1.0) * 20.0; U.y-=0.05;  U.x-=6.55;      \n            caps C(12) low C(1)C(14)C(3)C(26)C(15)C(19)  // \"Resol\"\n        }\n    }\n    \n    col *= step(0.11, fract(uv.y*2.0));\n    \n    float edge_sdf = min(abs(uv.x-0.5)*iResolution.x, abs(uv.y-0.5)*iResolution.y);\n    col *= smoothstep(2.0, 3.0, edge_sdf);\n    col += smoothstep(2.5, 1.5, edge_sdf);\n    \n    float font = draw_char().x;    \n    col += font;\n    o = col.xyzz;\n}","name":"Image","description":"","type":"image"}]}