{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const int c_terramarch_steps = 64;\nconst int c_grassmarch_steps = 32;\nconst float c_maxdist = 200.;\nconst float c_grassmaxdist = 3.;\nconst float c_scale = .05;\nconst float c_height = 6.;\nconst float c_rslope = 1. / (c_scale * c_height);\nconst float c_gscale =  15.;\nconst float c_gheight = 1.5;\nconst float c_rgslope = 1. / (c_gscale * c_gheight);\nconst vec3 c_skycolor = vec3(.59, .79, 1.);\n\nfloat ambient = .8;\n\nfloat hash(in float p) { return fract(sin(p) * 43758.2317); }\nfloat hash(in vec2 p) { return hash(dot(p, vec2(87.1, 313.7))); }\nvec2 hash2(in float p) {\n\tfloat x = hash(p);\n\treturn vec2(x, hash(p+x));\n}\nvec2 hash2(in vec2 p) { return hash2(dot(p, vec2(87.1, 313.7))); }\n\nfloat noise(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash(F), \t\t\t hash(F+vec2(1.,0.)), f.x),\n\t\tmix(hash(F+vec2(0.,1.)), hash(F+vec2(1.)),\t  f.x), f.y);\n}\n\nvec2 noise2(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash2(F), \t\t\t  hash2(F+vec2(1.,0.)), f.x),\n\t\tmix(hash2(F+vec2(0.,1.)), hash2(F+vec2(1.)),\tf.x), f.y);\n}\n\nfloat fnoise(in vec2 p) {\n\treturn .5 * noise(p) + .25 * noise(p*2.03) + .125 * noise(p*3.99);\n}\n\nstruct ray_t {\n\tvec3 o, d;\n};\n\t\nstruct xs_t {\n\tfloat l;\n\tvec3 pos, nor;\n\tfloat occlusion;\n};\n\t\nstruct tree_t {\n\tvec2 pos;\n\tfloat r;\n};\n\nxs_t empty_xs(float maxdist) {\n\treturn xs_t(maxdist, vec3(0.), vec3(0.), 0.);\n}\n\nxs_t ray_xs(in ray_t ray, float dist) {\n\treturn xs_t(dist, ray.o + ray.d * dist, vec3(0.), 0.);\n}\n\t\nfloat height(in vec2 p) {\n\tfloat n = fnoise(p * c_scale); \n\treturn (n - .5) * c_height;\n}\n\nvec2 wind_displacement(in vec2 p) {\n\treturn noise2(p*.1+iTime) - .5;\n}\n\nfloat grass_height(in vec3 p) {\n\tfloat base_h = height(p.xz);\n\tfloat depth = 1. - (base_h - p.y) / c_gheight;\n\tvec2 gpos = (p.xz + depth * wind_displacement(p.xz));\n\treturn base_h - noise(gpos * c_gscale) * c_gheight;\n}\n\nvec3 grass_normal(in vec3 p) {\n\treturn vec3(0.,1.,0.);\n}\n\nxs_t trace_terrain(in ray_t ray, float Lmax) {\n\tfloat L = 0.;\n\tfor (int i = 0; i < c_terramarch_steps; ++i) {\n\t\tvec3 pos = ray.o + ray.d * L;\n\t\tfloat h = height(pos.xz);\n\t\tfloat dh = pos.y - h;\n\t\tif (dh < .005*L) break;\n\t\tL += dh;// * c_rslope;\n\t\tif (L > Lmax) break;\n\t}\n\treturn ray_xs(ray, L);\n}\n\nxs_t trace_grass(in ray_t ray, float Lmin, float Lmax) {\n\tfloat L = Lmin;\n\tfor (int i = 0; i < c_grassmarch_steps; ++i) {\n\t\tvec3 pos = ray.o + ray.d * L;\n\t\tfloat h = grass_height(pos);\n\t\tfloat dh = pos.y - h;\n\t\tif (dh < .005*L) break;\n\t\tL += dh * c_rgslope;\n\t\tif (L > Lmax) break;\n\t}\n\tvec3 pos = ray.o + ray.d * L;\n\tfloat occlusion = 1. - 2.*(height(pos.xz) - pos.y) / c_gheight;\n\treturn xs_t(L, pos, grass_normal(pos), (L>Lmax)?1.:min(1.,occlusion));\n}\n\nvec3 shade_grass(in xs_t xs) {\n\tvec2 typepos = xs.pos.xz + wind_displacement(xs.pos.xz);\n\tfloat typemask1 = fnoise(2.5*typepos);\n\tfloat typemask2 = pow(fnoise(.4*typepos), 3.);\n\tfloat typemask3 = step(.71,fnoise(.8*typepos));\n\tvec3 col1 = vec3(.6, .87, .5);\n\tvec3 col2 = vec3(.7, .73, .4)*.3;\n\tvec3 col3 = vec3(1., 1., .1);\n\tvec3 col4 = vec3(1., .4, .7);\n\tvec3 color = mix(mix(mix(col1, col2, typemask1),\n\t\t\tcol3, typemask2), col4, typemask3) * ambient;\n\tcolor *= xs.occlusion;\n\treturn color;\n}\n\nray_t lookAtDir(in vec3 uv_dir, in vec3 pos, in vec3 at) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0.,1.,0.));\n\tvec3 u = cross(r, f);\n\treturn ray_t(pos, normalize(uv_dir.x * r + uv_dir.y * u + uv_dir.z * f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 pos = vec3(uv, 0.);\n\tpos += vec3(sin(.3*sin(iTime*.18)), 0., sin(.2*cos(iTime*.18)))*20.;\n\tpos += vec3(30., 5.+height(pos.xz), 10.);\n\n\tray_t ray = lookAtDir(normalize(vec3(uv, 3.)), pos, vec3(0.));\n\t\n\tvec3 color = vec3(0.);\n\n\txs_t xs = empty_xs(c_maxdist);\n\txs_t terr = trace_terrain(ray, xs.l);\n\tif (terr.l < xs.l) {\n\t\txs = trace_grass(ray, terr.l, terr.l+c_grassmaxdist);\n\t}\n\t\n\tif (xs.l < c_maxdist) {\n\t\tcolor = shade_grass(xs);\n\t\tcolor = mix(color, c_skycolor, smoothstep(c_maxdist*.35, c_maxdist, xs.l));\n\t} else {\n\t\tcolor = c_skycolor;\n\t}\n\t\n\t// gamma correction is for those who understand it\n\t//fragColor = vec4(pow(color, vec3(2.2)), 1.);\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdsGzS","date":"1373725136","viewed":4721,"name":"polyanka","username":"w23","description":"Solskogen 2013 remote partyprod.\nI thought that Cloudy Terrain by iq (https://www.shadertoy.com/view/MdlGW7) was awesome, so I tried to get familiar with techniques behind it. Basically, I got everything wrong and then ran out of time before a deadline.","likes":53,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","grass","unfinished","partyprod"],"hasliked":0,"parentid":"","parentname":""}}