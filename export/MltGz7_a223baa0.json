{"ver":"0.1","info":{"id":"MltGz7","date":"1595944782","viewed":166,"name":"cavernous space","username":"Daedelus","description":"making old shaders public, experimenting with fake emissive lights via sdf, iirc this was 20 minutes as shader showdown practice","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["cavernousspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOV 0.2\n\nvoid pR(inout vec2 p, float a)\n{\n    float sa = sin(a), ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n}\n\nfloat mapE(vec3 p, out float m)\n{\n    p.y += sin(p.z * 0.3) * 0.75;\n    m = sign(p.x);\n    p.x = abs(p.x);\n    p.x -= 1.0;\n    pR(p.xy, p.z);\n    p.x += sin(p.z * 0.125 + iTime) * 0.25;\n    return length(p.xy) - 0.01 - pow(sin(p.z * 2.0 + iTime * 12.0) * 0.5 + 0.5, 12.0) * 0.01;\n}\n\nfloat map(vec3 p, out float m)\n{\n    float dist = mapE(p, m);\n    \n    float cavern = -(length(p.xy * vec2(0.25, 1.0)) - 1.0) + texture(iChannel1, p.xz * 0.05).x - texture(iChannel1, p.xz * 0.25).x * 0.2;\n    if(cavern < dist)\n    {\n        dist = cavern;\n        m = 0.0;\n    }\n    \n    return dist;\n}\n\n#define NORMAL_FUNC(map, normal) float map(vec3 p){float m;return map(p, m);}vec3 normal(vec3 p, float s){vec2 e = vec2(0.01, 0.0);return normalize(vec3(map(p + e.xyy),map(p + e.yxy),map(p + e.yyx)) - s);}\n\nNORMAL_FUNC(map, normal)\nNORMAL_FUNC(mapE, normalE)\n\nvec4 triplanar(sampler2D tex, vec3 p, vec3 n)\n{\n    n = abs(n);\n    n /= n.x + n.y + n.z;\n    return texture(tex, p.yz) * n.x +\n        texture(tex, p.xz) * n.y +\n        texture(tex, p.xy) * n.z;\n}\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n};\n\nMaterial material(float m, vec3 is, vec3 n)\n{\n    Material o;\n    o.albedo;\n    o.emissive;\n    if(m == 0.0)\n    {\n        o.albedo = pow(triplanar(iChannel0, is * 0.5, n).xyz * 1.5, vec3(4.0));\n    }\n    else if(m == 1.0)\n    {\n        o.albedo = vec3(0.0);\n        o.emissive = vec3(0.0, 1.0, 1.0) + 2.0 * pow(sin(is.z * 2.0 + iTime * 12.0) * 0.5 + 0.5, 120.0);\n    }\n    else if(m == -1.0)\n    {\n        o.albedo = vec3(0.0);\n        o.emissive = vec3(1.0, 0.0, 1.0) + 2.0 * pow(sin(is.z * 2.0 + iTime * 12.0) * 0.5 + 0.5, 120.0);\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 nE, n, c, is, o = vec3(0.0, 0.0, iTime), d = vec3(0.0, 0.0, 1.0);\n    pR(d.xz, uv.x * FOV);\n    pR(d.yz, uv.y * FOV);\n    \n    float m, mE, s, t = 0.1;\n    for(int i = 0; i < 500; ++i)\n    {\n        is = o + d * t;\n        s = map(is, m) * 0.5;\n        t += s;\n        if(s<=0.0||t>40.0)\n            break;\n    }\n    \n    n = normal(is, s);\n    \n    s = mapE(is, mE);\n    nE = -normalE(is, s);\n    \n    Material mtl = material(m, is, n);\n    Material mtlE = material(mE, is, nE);\n    \n    float attenuation = pow(max(map(is + nE * s * 0.5) / (s * 0.5), 0.0), 0.25);\n    \n    c = mix(mtl.emissive + mtl.albedo * attenuation * mtlE.emissive * max(0.0, dot(n, nE)) / (1.0 + pow(s, 6.0)), mix(vec3(0.8, 0.6, 0.2), vec3(0.1, 0.3, 0.5), pow(abs(d.y), 0.25)), min(t / 40.0, 1.0));\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}