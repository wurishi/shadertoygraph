{"ver":"0.1","info":{"id":"MXX3zS","date":"1707620494","viewed":57,"name":"raytracer working lesgo","username":"badatcode123","description":"its a very basic raytracer","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray\n{\n  vec3 dir;\n  vec3 origin;\n  vec3 color;\n};\nstruct sphere\n{\n  vec3 pos;\n  float r;\n  vec3 col;\n};\nvoid ray_sphere(in vec3 ro,in vec3 rd,in vec3 ce,in float r,out float t,out bool hit)\n{\n  vec3 a = ro-ce;\n  float b = 2.0*dot(rd,a);\n  float c = dot(a,a)-r*r;\n  float discrim = b*b-4.0*c;\n  hit = discrim >=0.0;\n  if (hit)\n  {\n    t = -(b+b)-2.0*sqrt(c)/2.0;\n  }\n}\n\nvoid check_int(in vec3 ro,vec3 rd,out float t,bool hit)\n{\n  ray_sphere(ro,rd,vec3(0,0,0),25.0,t,hit);\n}\n\nvoid shoot_ray(in vec3 ro,in vec3 rd,in int bounces, out vec3 col)\n{\n   ray ray;\n   ray.dir = rd;\n   ray.origin = ro;\n   ray.color = vec3(1.0);\n   bool hit;\n   int i;\n   for (i=0;i < bounces;i++)\n   {\n      float int_dist = 500.0;\n      hit = false;\n      float t;\n      ray_sphere(ray.origin,ray.dir,vec3(0,0,0),25.0,t,hit);\n      col = vec3(float(hit));\n   }\n\n}\nvoid rotate(vec3 pos, vec3 dir, out vec3 outpos)\n{\n   outpos.z = pos.y*sin(dir.x)+pos.z*cos(dir.x);\n   outpos.x = pos.x*cos(dir.y)+outpos.z*sin(dir.y);\n   outpos.y = pos.y*cos(dir.x)-pos.z*sin(dir.x);\n   outpos.z = outpos.z*cos(dir.y)-pos.x*sin(dir.y);\n}\nvoid get_pixl_col(out vec3 col,vec2 coord,int bounces,vec2 cam_dir,vec3 cam_pos)\n{\n   vec3 outpos;\n   rotate(normalize(vec3(coord,350)),vec3(cam_dir,0),outpos);\n   shoot_ray(cam_pos,normalize(outpos),bounces,col);\n}\nfloat key(in int keynum)\n{\n   return float(texelFetch(iChannel0,ivec2(keynum,0),0).x);\n}\n\nvoid move_cam(out vec2 mouse_pos,out vec3 cam_pos)\n{\n   int W = 87;\n   int S = 83;\n   int A = 65;\n   int D = 68;\n   mouse_pos = (iMouse.yx-(iResolution.yx/2.0))/100.0;\n   mouse_pos.x *= -1.0;\n   if (false)\n   {\n   //I thought camera rotation would be so easy... how naive I was\n     cam_pos.x += (key(W)-key(S))*5.0*sin(mouse_pos.y)+(key(A)-key(D))*5.0*cos(mouse_pos.y);\n     cam_pos.z += (key(W)-key(S))*-5.0*cos(mouse_pos.y)+(key(A)-key(D))*-5.0*sin(mouse_pos.y);\n   }\n   else\n   {\n     cam_pos = vec3(0,0,-100);\n   }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int bounce = 1;\n    vec2 coord = fragCoord-(iResolution.xy/2.0);\n    vec3 col;\n    vec2 mouse_pos;\n    vec3 cam_pos;\n    move_cam(mouse_pos,cam_pos);\n    get_pixl_col(col,coord,1,mouse_pos,cam_pos);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}