{"ver":"0.1","info":{"id":"NlfcWS","date":"1648760442","viewed":77,"name":"Pool table","username":"sasilles","description":"This is my solution for the first computer graphics assignment.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["balls","table","pool","billiard","cue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2.0 * texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = sqrt(fragColor.rgb);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int materialNo = 11;\nMaterial materials[materialNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int spheresNo = 16;\nSphere spheres[spheresNo];\n\nconst int triangleNo = 4;\nTriangle triangles[triangleNo];\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-50.0, 1.0, 20.0);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0, 0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1, 0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z> 0.0 || data2.x >= 0.0)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy)) * 0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord / iResolution.xy * 2.0 - 1.0) * 1.0 * normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z >= 0.0)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.0)\t//mouse released\n        data2 = -mod(uv, 2.0 * pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectTriangle(Ray ray, Triangle t)\n{\n    vec3 ab = t.b - t.a;\n    vec3 ac = t.c - t.a;\n    vec3 ap = ray.p0 - t.a;\n\n    vec3 f = cross(ray.v, ac);\n    vec3 g = cross(ap, ab);\n    \n    float coeff = 1.0 / dot(f, ab);\n    \n    float t0 = coeff * dot(g, ac);\n    float u0  = coeff * dot(f, ap);\n    float v0 = coeff * dot(g, ray.v);\n    \n    vec3 n = -normalize(cross(ab, ac));\n    if(t0 >= 0.0 && u0 >= 0.0 && v0 >= 0.0 && 1.0 - u0 - v0 >= 0.0)\n        return TraceResult(t.id, n, t0);\n    else\n        return TraceResult(t.id, vec3(0), ray.tmax); // no intersection\n}\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r * s.r;\n    float discriminant = b * b - 4.0 * a * c;\n    if(discriminant < 0.0)\n        return TraceResult(s.id, vec3(0), ray.tmax); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(s.id, normal, t);\n}\n\nTraceResult intersectPlane(Ray ray, Plane p)\n{\n    float t = dot(p.q0 - ray.p0, p.n) / dot(ray.v, p.n);\n    return TraceResult(p.id, p.n, t);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(-1, vec3(0), ray.tmax);\n    \n    for (int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n        {\n            res = res2;\n        }\n    }\n    \n    for (int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n        {\n            res = res2;\n        }\n    }\n    \n    for (int i = 0; i < triangleNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n        {\n            res = res2;\n        }\n    }\n    \n    return res;\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz, 1.);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr)\n{\n    vec3 p = ray.p0 + ray.v * tr.t;\n    vec3 n = tr.n;\n    \n    const int lightNum = 2;\n    vec3 lightPos[lightNum];\n    lightPos[0] = vec3(0, 20, 0);\n    lightPos[1] = vec3(0, 20, 40);\n    \n    vec3 col = vec3(0); // remains 0 if in shadow\n    for (int i = 0; i < lightNum; ++i)\n    {\n        vec3 l = lightPos[i] - p;\n        float lightDist = length(l);\n        l /= lightDist; // normalized direction to the light\n\n        Ray shadowray = Ray(p + 0.001 * n, 0.001, l, lightDist); /* p0, tmin, v, tmax */\n        TraceResult res = raycast(shadowray);\n\n        if(res.t == shadowray.tmax)\n        {\n            vec3 v = -ray.v;\n\n            // diffuse\n            float costheta = max(dot(n, l), 0.0);\n            vec3 k_d = materials[tr.id].diffuse / pi;\n\n            // specular\n            vec3 toLight = normalize(lightPos[i] - p);\n            vec3 toEye = -ray.v;\n            vec3 k_s = materials[tr.id].specular;\n\n            vec3 h = normalize(toLight + toEye);\n            float si = pow(clamp(dot(h, n) ,0.0, 1.0), 100.);\n\n            // sum\n            col += (k_d + si * k_s) * costheta;\n        }\n    }\n\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Materials\n    materials[0] = Material(vec3(0, 0, 1), vec3(0.02)); // matte blue\n    materials[1] = Material(vec3(1, 1, 1), vec3(0.2)); // shiny white\n    materials[2] = Material(vec3(1, 0, 0), vec3(0.7)); // shiny red\n    materials[3] = Material(vec3(0, 0.6, 0), vec3(0.7)); // shiny green\n    materials[4] = Material(vec3(0, 0, 1), vec3(0.7)); // shiny blue\n    materials[5] = Material(vec3(1, 0.9, 0), vec3(0.7)); // shiny yellow\n    materials[6] = Material(vec3(1, 0.4, 0), vec3(0.7)); // shiny orange\n    materials[7] = Material(vec3(0.5, 0, 1), vec3(0.7)); // shiny purple\n    materials[8] = Material(vec3(0.5, 0, 0), vec3(0.7)); // shiny dark red\n    materials[9] = Material(vec3(0, 0, 0), vec3(0.7)); // shiny black\n    materials[10] = Material(vec3(0.5, 0.3, 0), vec3(0.1)); // matte brown\n\n    // Pool table\n    planes[0] = Plane(0, vec3(0), normalize(vec3(0,1,0)));\n\n    // White Ball\n    spheres[0] = Sphere(1, vec3(0, 1, 0), 1.0);\n\n    // Balls in triangle\n    spheres[1] = Sphere(5, vec3(0, 1, 35), 1.0);\n    \n    spheres[2] = Sphere(2, vec3(-1, 1, 36.6), 1.0);\n    spheres[3] = Sphere(4, vec3(1, 1, 36.6), 1.0);\n    \n    spheres[4] = Sphere(6, vec3(-2, 1, 38.4), 1.0);\n    spheres[5] = Sphere(9, vec3(0, 1, 38.4), 1.0);\n    spheres[6] = Sphere(3, vec3(2, 1, 38.4), 1.0);\n    \n    spheres[7] = Sphere(5, vec3(-3, 1, 40.2), 1.0);\n    spheres[8] = Sphere(8, vec3(-1, 1, 40.2), 1.0);\n    spheres[9] = Sphere(4, vec3(1, 1, 40.2), 1.0);\n    spheres[10] = Sphere(7, vec3(3, 1, 40.2), 1.0);\n    \n    spheres[11] = Sphere(3, vec3(-4, 1, 42), 1.0);\n    spheres[12] = Sphere(7, vec3(-2, 1, 42), 1.0);\n    spheres[13] = Sphere(8, vec3(0, 1, 42), 1.0);\n    spheres[14] = Sphere(2, vec3(2, 1, 42), 1.0);\n    spheres[15] = Sphere(6, vec3(4, 1, 42), 1.0);\n    \n    // Cue\n    const int cueMat = 10;\n    float moveDiff = 2.0 * sin(iTime * 5.0);\n    vec3 cueA = vec3(0, 1, -4.0 - moveDiff);\n    float cueBCZ = -44.0 - moveDiff;\n    triangles[0] = Triangle(cueMat, cueA, vec3(-0.5, 1.5, cueBCZ), vec3(0.5, 1.5, cueBCZ));\n    triangles[1] = Triangle(cueMat, cueA, vec3(0.5, 1.5, cueBCZ), vec3(0.5, 0.5, cueBCZ));\n    triangles[2] = Triangle(cueMat, cueA, vec3(0.5, 0.5, cueBCZ), vec3(-0.5, 0.5, cueBCZ));\n    triangles[3] = Triangle(cueMat, cueA, vec3(-0.5, 0.5, cueBCZ), vec3(-0.5, 1.5, cueBCZ));\n\n    vec3 eye; vec2 data;                    // This will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax <= result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result);\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3 * prev + 0.7 * fragColor; // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Sphere\n{\n    int id;\n    vec3 c;  // center\n    float r; // radius\n};\n\nstruct Plane\n{\n    int id;\n    vec3 q0; // any point on the plane\n    vec3 n;  // normal\n};\n\nstruct Triangle\n{\n    int id;\n    vec3 a; // top\n    vec3 b; // bottom left\n    vec3 c; // bottom right\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    int id;\n    vec3 n;  // normal vector on surface\n    float t; // distance taken on ray\n};\n\nstruct Material\n{\n    vec3 diffuse;  // adjust the color (range for each value: [0, 1])\n    vec3 specular; // adjust shininess\n};\n","name":"Common","description":"","type":"common"}]}