{"ver":"0.1","info":{"id":"WtlSD4","date":"1602174511","viewed":180,"name":"Filtered Cubemap Generation Test","username":"olano","description":"Test for Monte-Carlo cube map generation code. All mips generated simultaneously from by Monte-Carlo sampling into packed locations in BufferA (would make more sense as a compute shader). Filtering kernel uses VGGX distribution.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cubemap","vggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Test shader for Monte-Carlo cube map filtering\n// controllable defines and such in the Common tab.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if VIEW == VIEW_CUBE\n    // display as an unwrapped cube\n    vec2 texcoord = fragCoord / iResolution.xy;\n    vec2 face = floor(texcoord * vec2(4,3));\n    vec2 FaceUV = fract(texcoord * vec2(4,3)) * 2. - 1.;\n\n    uint Face = ((face == vec2(2,1)) ? 0u :\n                 (face == vec2(0,1)) ? 1u :\n                 (face == vec2(1,2)) ? 2u :\n                 (face == vec2(1,0)) ? 3u :\n                 (face == vec2(1,1)) ? 4u :\n                 (face == vec2(3,1)) ? 5u :\n                 6u);\n    if (Face == 6u) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    uint Mip = DISPLAY == DISPLAY_SMOOTH ? 0u : DisplayMip;\n    uint TopFaceSize = iDims.x * iDims.y;\n    uint MipChainSize = (TopFaceSize * 4u - 1u) / 3u;      \n    uvec2 MipSize = iDims.xy >> Mip;\n    uint MipBase = (TopFaceSize - MipSize.x * MipSize.y) * 4u / 3u;\n\n    uvec2 MipCoord = uvec2((FaceUV*0.5+0.5) * vec2(MipSize));\n    uint MipOffset = MipCoord.y * MipSize.x + MipCoord.x;\n    uint FaceOffset = MipBase + MipOffset;\n    uint Offset = Face * MipChainSize + FaceOffset;\n    Offset = Face * MipChainSize + MipBase + MipOffset;\n    ivec2 tc = ivec2(Offset % uint(iChannelResolution[0].x),\n                     Offset / uint(iChannelResolution[0].x));\n    fragColor = texelFetch(iChannel0, tc, 0);\n#else\n    vec2 texcoord = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, texcoord);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// display as an unwrapped cube map, or as the raw texture data\n#define VIEW_CUBE   1\n#define VIEW_TEX\t2\n#define VIEW VIEW_CUBE\n\n// show texels as big blocks, or equivalent smoothing but at full res\n#define DISPLAY_TEXELS\t1\n#define DISPLAY_SMOOTH\t2\n#define DISPLAY DISPLAY_SMOOTH\n\n// source texture from cube map or flat equirectangular projection\n// for SOURCE_2D, need to install Shadertoy Custom Textures browser plugin\n// then drag a png or jpg texture into the Buffer A / iChannel1 texture slot\n#define SOURCE_CUBE\t\t1\n#define SOURCE_2D\t\t2\n#define SOURCE SOURCE_CUBE\n\n// what size base cube map resolution for level 0. \n// Since shadertoy buffers are the same size as the display window, 128x128 is \n// about the biggest that'll work unless you go full screen \nconst uvec2 iDims = uvec2(128,128);\n\n// all mip levels are always computed. Which should be displayed?\n//const uint DisplayMip = 0u;\n#define DisplayMip uint(mod(iTime,log2(float(iDims.x+1u))))\n\n// how many Monte-Carlo samples in filtering\nconst uint iSamples = 1024u;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// do environment lookup, either using source cube map or equirectangular 2D texture\nvec3 EnvLookup(vec3 direction)\n{\n#if SOURCE == SOURCE_CUBE\n    return textureLod(iChannel0, direction, 0.).rgb;\n#else\n    vec2 uv = vec2(atan(direction.x, direction.z) * (0.5 / 3.1415926) + 0.5,\n                   1.0 - acos(direction.y) * (1.0 / 3.1415926));\n    return textureLod(iChannel1, uv, 0.).rgb;\n#endif\n}\n\n\n// Duff et al., Building an Orthonormal Basis, Revisited, JCGT v6n1, 2017\n// Given N, compute T and B vectors to form an (arbitrarily oriented) orthonormal basis\nmat3 OrthonormalBasis(vec3 N)\n{\n    float sign = N.z >= 0. ? 1. : -1.;\n    float a = -1. / (sign + N.z);\n    float b = N.x * N.y * a;\n    vec3 T = vec3(1. + sign * N.x * N.x * a, sign * b, -sign * N.x);\n    vec3 B = vec3(b, sign + N.y * N.y * a, -N.y);\n    return mat3(T, B, N);\n}\n\n//GGX shadowing and/or masking\nfloat GGXGeometric(float NdotV, float kSquared)\n{\n    return 2. * NdotV/(NdotV + sqrt(kSquared + (1. - kSquared)*NdotV*NdotV));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec3 DTid = uvec3(uint(fragCoord.y) * uint(iResolution.x) + uint(fragCoord.x));\n    uint TopFaceSize = iDims.x * iDims.y;\n    uint MipChainSize = (TopFaceSize * 4u - 1u) / 3u;\n    uint Face = DTid.x / MipChainSize;\n    uint FaceOffset = DTid.x - Face * MipChainSize;\n    if (Face > 5u) return;\n    \n    // which MIP?\n    uint Mip = uint(1. - 0.5 * log2(float(4u * TopFaceSize - 3u * FaceOffset) / float(TopFaceSize)));\n    uvec2 MipSize = iDims.xy >> Mip;\n    vec2 fMipScale = 1. / vec2(MipSize);\n    uint MipBase = (TopFaceSize - MipSize.x * MipSize.y) * 4u / 3u;\n    uint MipOffset = FaceOffset - MipBase;\n    \n    // texel direction\n    uvec2 MipCoord = uvec2(MipOffset % MipSize.x, MipOffset / MipSize.x);\n    vec2 FaceUV = vec2(MipCoord * 2u + 1u) * fMipScale - 1.;\n    vec3 N = ((Face == 0u) ? vec3( 1, FaceUV.y,-FaceUV.x) :\n              (Face == 1u) ? vec3(-1, FaceUV.y, FaceUV.x) :\n              (Face == 2u) ? vec3( FaceUV.x, 1,-FaceUV.y) :\n              (Face == 3u) ? vec3( FaceUV.x,-1, FaceUV.y) :\n              (Face == 4u) ? vec3( FaceUV.x, FaceUV.y, 1) :\n              (Face == 5u) ? vec3(-FaceUV.x, FaceUV.y,-1) : \n              vec3(0));\n    mat3 TBN = OrthonormalBasis(normalize(N));\n    \n    // Estimate roughness for this texel, assuming normal incidence (V=N)\n#if DISPLAY == DISPLAY_SMOOTH\n    float TexelSA = 4. * pow(dot(N, N), -1.5) / float(TopFaceSize >> (2u*DisplayMip));\n#else\n    float TexelSA = 4. * pow(dot(N, N), -1.5) / float(MipSize.x*MipSize.y);\n#endif\n    float fRoughness = (TexelSA - 12.5664)*TexelSA / ((TexelSA + 12.5664)*TexelSA - 118.435);\n    fRoughness = sqrt(clamp(fRoughness,0.,1.));\n    float fRoughnessSquared = fRoughness * fRoughness;\n    \n    // Fibonacci sequence rotation by 2*pi*0.754877669 each sample\n    vec2 dir = vec2(1, 0);\n    mat2 rot = mat2(0.0306425008, 0.999530408, -0.999530408, 0.0306425008);\n\n    vec3 TotalColor = vec3(0);\n    for (uint i = 0u; i < iSamples; ++i)\n    {\n        // sample GGX distribution\n        float rSquared = fract(float(i) * 0.569840296);\n        vec3 t = vec3(sqrt(rSquared) * dir, sqrt(1. - rSquared));\n        dir = dir * rot;\n\n        vec3 Lt = normalize(vec3(-fRoughness * t.xy, t.z));\n        vec3 Lw = TBN * Lt;\n        vec3 SampleColor = EnvLookup(Lw);\n\n        // accumulate weighted sample\n        float SmithGL = GGXGeometric(clamp(Lt.z,0.,1.), fRoughnessSquared);\n        TotalColor += SampleColor * SmithGL;\n    }\n    TotalColor /= float(iSamples);\n    \n    fragColor = vec4(TotalColor,1);\n}","name":"Buffer A","description":"","type":"buffer"}]}