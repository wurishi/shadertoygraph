{"ver":"0.1","info":{"id":"lXXGzn","date":"1707119422","viewed":53,"name":"Hotel corridor","username":"moziz","description":"Looking for the room as usual.\n\nTODO:\n- Needs better lighting either through windows or some light fixtures.\n- Carpet pattern\n- Doors\n- Trees and night sky outside the window","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","run","hotel","moody"],"hasliked":0,"parentid":"NtcyDN","parentname":"Fork Fort Fizz moziz 286"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.141592654;\nconst float fovAngle = pi / 4.;\n\n\nconst vec3 color_wood   = vec3(137., 74.,  47. ) / 255.;\nconst vec3 color_carpet = vec3(202., 63.,  63. ) / 255.;\nconst vec3 color_wall   = vec3(143., 176., 130.) / 255.;\nconst vec3 color_trim   = vec3(245., 189., 163.) / 255.;\n\nconst float room_z_ext = 1.25;\n\n\nmat4 rotMat(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    return (rotMat(axis, angle) * vec4(p, 0)).xyz;\n}\n\nfloat sdf_sphere(vec3 p, vec3 c, float r)\n{\n    return length(c - p) - r;\n}\n\nfloat sdf_plane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) - h;\n}\n\nfloat sdf_box(vec3 p, vec3 c, vec3 e)\n{\n    vec3 q = abs(p - c) - e;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene_window(float d, vec3 p)\n{\n    vec3 p_window = vec3(p.x, mod(p.y, 16.), p.z);\n    d = max(d, -sdf_box(p_window, vec3(-1.7, 8., 1.5 - room_z_ext), vec3(0.3, 2.5, .75)));\n    d = min(d, sdf_box(p_window, vec3(-1.4, 8., 0.7 - room_z_ext), vec3(0.1, 2.5, 0.05)));\n    d = min(d, sdf_box(p_window, vec3(-1.8, 8., 1.9 - room_z_ext), vec3(0.05, 2.5, 0.05)));\n    d = min(d, sdf_box(p_window, vec3(-1.8, 8., 1.1 - room_z_ext), vec3(0.05, 2.5, 0.05)));\n    vec3 p_window_vspoke = vec3(p_window.x, 8. + mod(p_window.y, 1.), p_window.z);\n    d = min(d, sdf_box(p_window_vspoke, vec3(-1.8, 8., 1.5 - room_z_ext), vec3(0.05, 0.05, 0.75)));\n    \n    return d;\n}\n\nfloat scene(vec3 p)\n{\n    float d = 1e12;\n    \n    // Twisting corridor\n    //float twist = 32. - p.y / 32.;\n    //p.x = p.x * cos(twist) - p.z * sin(twist);\n    //p.z = p.z * cos(twist) + p.x * sin(twist);\n\n    d = min(d, -sdf_box(p, vec3(0,0,0), vec3(1.5, 128., room_z_ext)));\n    \n    // Pillars & beams\n    vec3 p_supports = vec3(abs(p.x), mod(p.y, 8.), p.z);\n    d = min(d, sdf_box(p_supports, vec3(1.5, 4., 0), vec3(0.3, 0.3, room_z_ext)));\n    d = min(d, sdf_box(p_supports, vec3(0, 4., room_z_ext), vec3(1.5, 0.3, 0.3)));\n    \n    // Door\n    vec3 p_door = vec3(p.x, mod(p.y, 16.), p.z);\n    d = max(d, -sdf_box(p_door, vec3(2., 0.66, 1.1 - room_z_ext), vec3(0.75, 0.66, 1.1)));\n\n    d = scene_window(d, p);\n    \n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float eps = 0.001;\n    const vec2 h = vec2(eps,0);\n    return normalize(\n        vec3(\n            scene(p+h.xyy) - scene(p-h.xyy),\n            scene(p+h.yxy) - scene(p-h.yxy),\n            scene(p+h.yyx) - scene(p-h.yyx)\n        )\n    );\n}\n\nbool march(in vec3 rayOrig, in vec3 rayDir, in int stepsMax, in float stepLengthMax, out float dist)\n{\n    for (int i = 0; i < stepsMax; ++i)\n    {\n        vec3 p = vec3(rayOrig + rayDir * dist);\n        float d = scene(p);\n\n        if (d < 0.002)\n            return true;\n\n        dist += min(stepLengthMax, d);\n    }\n    \n    return false;\n}\n\nvec3 color(in vec3 p, in float depth)\n{\n    vec3 cout = vec3(1, 0, 1);\n    \n    if (p.z < -room_z_ext + 0.01) { // Floor\n        if (abs(p.x) < 0.75) {\n            cout = color_carpet + texture(iChannel0, p.xy * vec2(1, 1.)).x;\n            //cout *= mod(floor(abs(sin(p.y) * tan(p.x * 1.9 - 1.5)) * 4.), 4.) / 4.;\n            cout += mod(floor(sin(p.x * 4.) * cos(p.y * 2.) * 5.), 5.) / 16.;\n        } else {\n            vec2 plank_p = vec2(floor(p.x * 4.), floor((p.y + mod(floor(p.x * 4.), 2.)) / 3.));\n            vec2 sample_p = plank_p / 128.;\n            cout = color_wood + texture(iChannel0, sample_p).x * 0.25;\n        }\n    } else if (p.x < -1.9) {\n        cout = vec3(0);\n    //} else if (sdf_box(p, vec3(p.x, mod(p.y, 4.) - 8., p.z), vec3(2., 2., 2.)) < 0.) {\n    //    cout = vec3(1.);\n    } else { // Walls & ceiling\n        cout = color_wall;\n    }\n    \n    return cout;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    float walk_dist = mod(-iTime * 8., 128.);\n    vec3 rayOrig = vec3(sin(walk_dist) * 0.05, walk_dist, 1.6 + abs(sin(walk_dist)) * 0.1 - room_z_ext);\n    \n    vec3 rayDir = rotate(\n        rotate(\n            vec3(0,0,1),\n            vec3(0,1,0),\n            -(uv.x - .5) * aspectRatio * fovAngle\n        ),\n        vec3(1,0,0),\n        (uv.y - .5) * fovAngle - pi/1.8\n    );\n    \n    float hitDist = 0.01;\n    bool hit = march(rayOrig, rayDir, 256, .5, hitDist);\n    vec3 hitPos = rayOrig + rayDir * hitDist;\n    vec3 normal = calcNormal(hitPos);\n    \n    vec3 color = color(hitPos, hitDist);\n    vec3 lit = color * (\n        // Flashlight\n        (dot(rayDir, normalize(vec3(sin(iTime * 12.) * 0.05, -1, -0.24 - cos(iTime * 16.) * 0.05))) - 0.66) * 24. / (hitDist)\n    );\n    \n    lit *= vec3(-dot(normal, rayDir));\n   \n    // Output to screen\n    //fragColor = vec4(rayDir, 1);\n    //fragColor = vec4(normal, 1.);\n    fragColor = vec4(lit, 1.);\n}\n","name":"Image","description":"","type":"image"}]}