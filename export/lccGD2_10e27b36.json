{"ver":"0.1","info":{"id":"lccGD2","date":"1712150285","viewed":29,"name":"Dashboard clock","username":"Don_Lampito","description":"Shader for displaying clock dial in simple style like car dashboard gauges.\nhttp://www.shadermess.com","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","time","clock","dasboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592;\nconst float TAU = PI * 2.0;\n\nconst vec3 handColorSeconds = vec3(1.0, 0.0, 0.0);\nconst vec3 handColorMinutes = vec3(1.0, 1.0, 0.4);\nconst vec3 handColorHours = vec3(0.9, 0.7, 0.1);\nconst vec3 dialColorHours = vec3(0.0, 0.9, 1.0);\nconst vec3 dialColorMinutes = vec3(0.0, 0.5, 0.8);\nconst vec3 backgroundColor = vec3(0.0, 0.1, 0.15);\n\n\nfloat distCircle(vec2 p, vec2 center, float r) {\n\treturn distance(vec2(p.x, p.y), vec2(center.x, center.y)) - r;\n}\n\nfloat angle(vec2 v1, vec2 v2) {\n\tvec2 difference = v2 - v1;\n\treturn atan(difference.y, difference.x);\n}\n\nvec2 rotate(vec2 p, float angle, vec2 pivot) {\n    float x = p.x;\n    float y = p.y;\n    float s = sin(angle);\n    float c = cos(angle);\n\n    float rX = pivot.x + (x - pivot.x) * c - (y - pivot.y) * s;\n    float rY = pivot.y + (x - pivot.x) * s + (y - pivot.y) * c;\n\n    return vec2(rX, rY);\n}\n\n\nfloat isLeft(vec2 P0, vec2 P1, vec2 P2) {\n    return ( (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y) );\n}\n\nbool pointInRectangle(in vec2 p, in vec2 tl, in vec2 tr, in vec2 br, in vec2 bl, in float angle, in vec2 pivot) {\n    tl = rotate(tl, angle, pivot);\n    tr = rotate(tr, angle, pivot);\n    bl = rotate(bl, angle, pivot);\n    br = rotate(br, angle, pivot);\n\n    return (isLeft(tl, tr, p) > 0.0 && isLeft(tr, br, p) > 0.0 && isLeft(br, bl, p) > 0.0 && isLeft(bl, tl, p) > 0.0);\n}\n\nbool updateHand(vec2 p, vec2 center, vec2 aspectRatio, float radius, float topWidth, float bottomWidth, float rot) {\n    float topY = center.y - radius;\n    if (pointInRectangle(p, vec2(center.x - topWidth, topY), vec2(center.x + topWidth, topY), vec2(center.x + bottomWidth, center.y), vec2(center.x - bottomWidth, center.y), rot, center)) {\n        return true;\n    }\n    \n    return false;\n}\n\nvec4 updateDial(vec2 p, vec2 center, float radius) {\n    float dist = distCircle(p, center, radius);\n    \n\tif (dist <= 0.0) {\n        float ang = angle(center, p) + PI / 2.0;\n        float rim;\n        float segmentCount;\n        float segmentCut;\n\n        //Hours\n        rim = step(0.8, 1.0 + dist / radius);\n\t\tsegmentCount = 12.0;\n\t\tsegmentCut = 0.9;\n\t\trim *= fract((ang - PI / segmentCount * (1.0 - segmentCut)) / TAU * segmentCount);\n\t\trim = step(segmentCut, rim);\n\t\tif (rim > 0.0) {\n            return vec4(dialColorHours * rim, 1.0);\n        }\n        //Minutes & seconds\n        rim = step(0.9, 1.0 + dist / radius);\n        segmentCount = 60.0;\n        segmentCut = 0.8;\n        rim *= fract((ang - PI / segmentCount * (1.0 - segmentCut)) / TAU * segmentCount);\n        rim = step(segmentCut, rim);\n        return vec4(mix(backgroundColor, dialColorMinutes, rim), 1.0);\n\t} else {\n\t\treturn vec4(0.0);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    uv *= aspectRatio;\n    float scale = 0.9;\n    float radius = 0.5 * scale;    \n\n    vec4 color = vec4(0.0);\n\tvec2 center = vec2(0.5, 0.5) * aspectRatio;\n    float seconds = iDate.w * TAU / 60.0;\n    float centerRadius = 0.048 * scale;\n    float distCenter = distCircle(uv, center, centerRadius);\n    if (distCenter <= 0.0) {\n        float rim = step(0.75, 1.0 - distCenter / -centerRadius);\n        color = mix(vec4(0.0, 0.3, 0.5, 1.0), vec4(0.0, 0.2, 0.3, 1.0), rim); \n    } else if (updateHand(uv, center, aspectRatio, radius * 0.95, 0.005 * scale, 0.01 * scale, seconds)) { //Seconds\n        color = vec4(handColorSeconds, 1.0);\n    } else if (updateHand(uv, center, aspectRatio, radius * 0.95, 0.01 * scale, 0.02 * scale, seconds / 60.0)) { //Minutes\n        color = vec4(handColorMinutes, 1.0);\n    } else if (updateHand(uv, center, aspectRatio, radius * 0.6, 0.01 * scale, 0.02 * scale, seconds / 3600.0 * 5.0)) { //Hours\n        color = vec4(handColorHours, 1.0);\n    } else if(color.a <= 0.0) {\n        color = updateDial(uv, center, radius); \n    }\n\n\n    fragColor = color;\n}\n\n","name":"Image","description":"","type":"image"}]}