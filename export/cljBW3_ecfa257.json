{"ver":"0.1","info":{"id":"cljBW3","date":"1694555712","viewed":153,"name":"Chess musicbox","username":"boyar","description":"Simple shader with chessbord, pawns and simple prime music box","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["3d","shader","chess","begginer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\nfloat smoothUnion ( float d1, float d2, float k ) \n{\n    //return min(d1, d2);\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubtraction ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n\n//float sdSphere (vec3 p, vec3 offset, float r )\n//{\n//  return length(p - offset) - r;\n//}\n\nfloat sdSphere (vec3 p, vec3 offset, vec3 size, float r )\n{\n  vec3 v = p - offset;\n  v = vec3(v.x / size.x, v.y / size.y, v.z / size.z);\n  return length(v) - r;\n}\n\nfloat sdPawn (in vec3 p, in vec3 origin ) \n{\n  float pawn = smoothUnion(\n      sdSphere(p, vec3(origin.x, 0.5 + origin.y, origin.z), vec3(1, 1, 1), 0.1),\n      sdSphere(p, vec3(origin.x, 0.3 + origin.y, origin.z), vec3(0.5, 1, 0.5), 0.1),\n      0.1);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.15 + origin.y, origin.z), vec3(0.6, 1, 0.6), 0.1),\n      0.2);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.1 + origin.y, origin.z), vec3(1.5, 0.7, 1.5), 0.1),\n      0.2);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.1 + origin.y, origin.z), vec3(1, 0.2, 1), 0.1),\n      0.2);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.35 + origin.y, origin.z), vec3(0.6, 0.2, 0.6), 0.1),\n      0.2);\n  return pawn;\n}\n\nfloat sdPawn (in vec3 p, in vec2 coords ) \n{\n  float pawn = sdPawn (p, vec3(coords.x * .5 - 1.75, -0.1, coords.y * .5 - 1.75) );\n  return pawn;\n}\n\nfloat sdBox ( in vec3 pos, in vec3 size, in vec3 origin )\n{\n    vec3 pt = abs ( pos - origin) - size;\n    return length ( max ( pt, 0.0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), 0.0 );\n}\n\nfloat sdPlane ( vec3 p, vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat sdScene(vec3 p)\n{\n  float board = sdBox(p, vec3(2.1, 0.1, 2.1), vec3(0., -0.1, 0.));\n  board = min(board, sdPawn(p, vec2(int(iTime * 2. / 30.  + 80000.) % 8, 0)));  \n  board = min(board, sdPawn(p, vec2(int(-iTime * 3. / 30.  + 80000.) % 8, 6))); \n  board = min(board, sdPawn(p, vec2(int(iTime * 5. / 30.  + 80000.) % 8, 2)));  \n  board = min(board, sdPawn(p, vec2(int(-iTime * 7. / 30.  + 80000.) % 8, 4))); \n  board = min(board, sdPawn(p, vec2(int(-iTime * 11. / 30. + 80000.) % 8, 7)));  \n  board = min(board, sdPawn(p, vec2(int(iTime * 13. / 30. + 80000.) % 8, 1))); \n  board = min(board, sdPawn(p, vec2(int(iTime * 17. / 30. + 80000.) % 8, 3)));  \n  board = min(board, sdPawn(p, vec2(int(-iTime * 19. / 30. + 80000.) % 8, 5))); \n  return board;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 1.5, 6); // ray origin that represents camera position\n  vec3 lp = vec3(0);\n  \n  float cameraRadius = 1.0;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n  \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n  if (d > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d;\n\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(0, 5, 0);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n    col = dif * vec3(1, 1, 1) + backgroundColor * .2;\n    \n    if (length(p.y) < PRECISION) {\n        int position = int(floor(p.x * 2.) + floor(p.z * 2.)) + 100;\n        if (position - position/2*2 == 1) {\n            col = dif * vec3(1, 1, 1);\n        } else {\n            col = dif * vec3(0.3, 0.3, 0.3);\n        }\n        \n    } else {\n\n        if (p.z < 0.) {\n            col = dif * vec3(1, 1, 1);\n        } else {\n            col = dif * vec3(0.3, 0.3, 0.3);\n        }\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float C = 261.63;\nconst float D = 293.66;\nconst float E = 329.63;\nconst float F = 349.23;\nconst float G = 392.00;\nconst float A = 440.00;\nconst float B = 493.88;\nconst float C0 = 130.81;\nconst float E0 = 164.81;\nconst float G0 = 196.00;\nconst float C2 = 65.41;\nconst float E2 = 82.41;\nconst float G2 = 98.00;\n\nconst float[] notes = float[] (B, D, E0, F, C0, G, E, C);\nconst float[] timings = float[] (1./2., 1./3., 1./5., 1./7., 1./11., 1./13., 1./17., 1./19.);\n\nvec2 noteFreq(float freq, float time) {\n    return vec2(sin(6.2831 * freq * time) * exp(-3.0 * time));\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 result;\n    float nt = time - floor(time / 30.) * 30.;\n    if (nt < 1.5) {\n        result += vec2( sin(6.2831*C2*nt)*exp(-3.0*nt)/25. );\n        result += vec2( sin(6.2831*C*nt)*exp(-3.0*nt)/25. );\n        result += vec2( sin(6.2831*E*nt)*exp(-3.0*nt)/25. );\n        result += vec2( sin(6.2831*G*nt)*exp(-3.0*nt)/25. );\n    }\n    else\n    for (int note = 0; note < notes.length(); note++) {\n    //for (int note = 0; note < 1; note++) {\n        float t = time - floor(time / timings[note] / 30.) * timings[note] * 30.;\n        if (t > 0.)\n            result+= vec2( sin(6.2831*notes[note]*time)*exp(-3.0*t)/25. );\n    }\n\n    return result;\n}","name":"Sound","description":"","type":"sound"}]}