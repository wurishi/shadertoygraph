{"ver":"0.1","info":{"id":"ddSXRw","date":"1670037653","viewed":150,"name":"Simple Absorb Effect","username":"Cirno","description":"A simple 2D effect.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 hash2(vec2 p)\n{\n    return fract(sin(p * mat2(1.29898, 8.1314, 7.8233,  1.5926)) * 4375.85453);\n}\n\nconst float PHASEGAP = 0.7f;\n\nfloat mapTime(float x) \n{\n    if(x<PHASEGAP)\n    {    \n        x = x/PHASEGAP;\n    }\n    else\n        x = 1.-(x-PHASEGAP)/(1.-PHASEGAP);\n    return x;\n}\n\nconst vec4 basicColor = vec4(0.2f,0.7f,1.0f,1.0f);\nconst vec4 dark1Color = vec4(0.867,0.247,0.914,1.0);\nconst vec4 dark2Color = vec4(0.);\n\nvec4 colorMap(float factor)\n{\n    vec4 color;\n    float f = 1.0f; //left values\n    float tempF;\n\n    tempF = smoothstep(0.0,0.85,factor);\n    color = tempF*basicColor;\n    f-=tempF;\n\n    tempF = smoothstep(0.0,0.45,factor)*f;\n    color += tempF*dark1Color;\n    f-=tempF;\n\n    color += f* dark2Color;\n\n    return color;\n}\n\nfloat dotSelf(vec2 v)\n{\n    return dot(v,v);\n}\n\nvoid frostBoomEffect(in vec2 uv, in float t,in float forks, out vec4 color) \n{\n    \n    \n    float centerDisNorm = length(uv)*0.7071067;// normalize distance to [0,1]\n    float deg = atan(uv.y,uv.x)*1.5915494580+t*t*2.+centerDisNorm*(1.+2.*t)*.5;\n    vec2 dir = uv;\n    vec2 vdir = vec2(uv.y,-uv.x);\n    color = vec4(0.);\n    // lines\n    {\n    float puv = fract(deg*forks*0.3);\n    float particlesEnergyLevel = step(0.7f,puv);\n    puv = (puv-0.7f)*3.333f;//[0,1]\n    float timeFactor = max(0.,t-0.4f);\n    float x2 = centerDisNorm*1.-(t-0.4f)*1.5;\n    float distanceFactor = (max(0.,-x2*(x2-0.4)*100.))*(1.2-centerDisNorm*1.75); //[0,0.2]\n    float edgeFactor = (.5-abs(.5-puv))*2.;\n    \n    float totalFactor = max(0.,timeFactor*distanceFactor)*edgeFactor;\n    particlesEnergyLevel*=totalFactor;\n    color += vec4(particlesEnergyLevel)*vec4(0.6,0.7,0.9,1.0);\n    }\n    \n    // the circle\n    {\n    float x = min(t*1.5f-centerDisNorm,1.0f); // to build a circle effect\n    float t2=mapTime(x);\n    \n    float distanceDecay = 1.-(centerDisNorm+.5)*t;\n    float energyLevel = max(0.,t2*distanceDecay);\n    energyLevel*=sin(deg*forks)*0.1+0.9;\n    \n    color+=colorMap(energyLevel)*vec4(0.2,0.7,0.9,1.0);\n    }\n    \n    \n    \n    //shinings\n    {\n    const float PXSIZE=10.0;\n    vec2 newUV = (uv+normalize(dir+vdir*t*t*10.)*4./(t*10.+1.))*PXSIZE;\n   \n    vec2 suv = fract(newUV);\n    newUV=floor(newUV)/PXSIZE;\n    vec2 noise = hash2(newUV);\n    float v = noise.x*noise.y*forks*0.3;\n    float distanceFactor = max(0.,1.-centerDisNorm*1.3);\n    float shiningFactor = step(0.5,v);\n    float smoothEdgeFactor = max(0.,.5*shiningFactor-dotSelf(suv-vec2(0.5))*2.);\n    smoothEdgeFactor*=smoothEdgeFactor;\n    float timeFadeFactor = mapTime(t);\n    float totalFactor=max(0.,shiningFactor*distanceFactor*smoothEdgeFactor*timeFadeFactor);\n    color += totalFactor*vec4(0.6,0.7,0.9,1.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x*=aspectRatio;\n    \n    uv = uv*2.0-1.0;\n    uv.x-=aspectRatio-1.;\n    float time = fract(-iTime*0.33f);\n    if(uv.x>1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    frostBoomEffect(uv,time,5.0,fragColor);\n}","name":"Image","description":"","type":"image"}]}