{"ver":"0.1","info":{"id":"mds3Wl","date":"1667040143","viewed":88,"name":"Other atan2 comparison","username":"Envy24","description":"Drad point with mouse.\nComparison built-in atan2, and atan2 from this shader: https://www.shadertoy.com/view/7lVBRw\nBut think visualization doesn't show difference between built-in and original atan2 (from link).\nOnly difference is points (-N, 0).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["comparison","atan2"],"hasliked":0,"parentid":"csf3Wl","parentname":"atan2 comparison"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) )    // PS - pixel size\n#define UNIT                      ( 8.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define MOUSE_NDC(scale)          ( (2.*iMouse.xy-R.xy) / R.y * scale )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    /**\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]\n    \n    return SC - origin;              // shift to new origin.\n}\n\n// original version from: https://www.shadertoy.com/view/7lVBRw\nfloat atan2(float y, float x)\n{\n   const float PI = 3.1415926535897932;\n   float alpha = atan(y / x);\n   if( 0.0   <= x && 0.0   <= y){return alpha;} // Q1\n   if( 0.0   <= x && y <= 0.0){  return 2.0 * PI + alpha;} // Q4\n   if( x <  0.0   && 0.0   <  y){return PI + alpha;} // Q2\n   if( x <  0.0   && y <  0.0){  return PI + abs(alpha);} // Q3\n}\n// modified version\nfloat atan2m1(float y, float x)\n{\n   const float PI = 3.1415926535897932;\n   float v = PI - atan(y, -x);\n   float sc = // special case.\n        abs(y) < 1e-7 && abs(x) > 1e-7 ?\n            0. :\n            1.;\n   return v * sc;\n}\n// modified version (equal to GLSL built-in atan(y, x))\nfloat atan2m2(float y, float x)\n{\n    const float PI = 3.1415926535897932;\n    float alpha = atan(y / x);\n    float sign_ = y >= 0. ? 1. : -1.;   \n    float sc = // special case.\n        abs(y) < 1e-7 && abs(x) < 1e-7 ?\n            0. :\n            1.;\n    return \n        x < 0. ?\n            sc*sign_*PI + alpha :\n            sc*alpha;\n}\n\n#define SCENE_SCALE ( 1.5 )\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0));\n  \n#define func(y, x) ( atan(y, x) )   // GLSL built-in function\n//#define func(y, x) ( atan2(y, x) )\n#define dfdx(y, x, delta) ( ( func((y)-(delta), (x)-(delta)) - func((y)+(delta), (x)+(delta)) ) )\n  \n          //NDC = normalize(NDC);\n    float f = func(NDC.y, NDC.x);\n    vec3 color = vec3(1.);\n\n    /* Axis */\n         color -= x_axis(NDC); color -= y_axis(NDC);\n                 \n    /* Function v = (cos(atan2(y, x)), sin(atan2(y, x)) */\n         color = mix( color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, vec2(cos(f), sin(f)), 0.25*UNIT)) );\n         \n    /* Single point */\n    vec2 P = MOUSE_NDC(SCENE_SCALE);\n        f = func(P.y, P.x);\n        color = mix( color, vec3(0,1,0), SMAA(segmentSDF_L2(NDC, vec2(cos(f), sin(f)), P, 0.)) );\n        \n        color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, P, 3.*UNIT)) );\n        color = mix( color, vec3(0,1,1), SMAA(diskSDF_L2(NDC, vec2(cos(f), sin(f)), 3.*UNIT)) );\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}","name":"Common","description":"","type":"common"}]}