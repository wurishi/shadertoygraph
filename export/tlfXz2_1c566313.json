{"ver":"0.1","info":{"id":"tlfXz2","date":"1563546809","viewed":113,"name":"Multi material raymarcher","username":"vlams1","description":"Clone of my first raymarcher, with multi material support.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 1000.0\n#define PRECISION 0.0002\n#define MAXIMUMDISTANCE 1000.0\n\n//Scene\nscene SDFpass(vec3 rayPos) {\n    material boxmat = material(4, vec3(1.0,0.3,0.3));\n    material spheremat = material(4, vec3(0.3,0.3,1.0));\n    material planemat = material(4, vec3(0.3,1.0,0.3));\n    \n    scene box = SDFbox(rayPos,vec3(0.0), vec3(2.0), 0.5, boxmat);\n    scene sphere = SDFsphere(rayPos, vec3(sin(iTime)*2.5,sin(iTime*0.7),cos(iTime)*0.25), 3.0, spheremat);\n    scene plane = SDFplane(rayPos, -3.0, planemat);\n    return SDFunionSmooth(SDFunionSmooth(box,sphere,2.0), plane, 4.0);\n}\n\n\n\n//Normals\nvec3 getNormal(vec3 rayPos) {\n    vec2 offset = vec2(PRECISION,0.0);\n    return normalize(vec3(\n        SDFpass(rayPos + offset.xyy).dist - SDFpass(rayPos - offset.xyy).dist,\n        SDFpass(rayPos + offset.yxy).dist - SDFpass(rayPos - offset.yxy).dist,\n        SDFpass(rayPos + offset.yyx).dist - SDFpass(rayPos - offset.yyx).dist));\n}\n\n\n\n//Triplanar mapping\nvec3 textureTriplanar(vec3 rayPos, vec3 normal, sampler2D tex, vec3 scale, float snap, float blur) {\n    vec3 x = textureGrad(tex, rayPos.zy * scale.zy, vec2(blur), vec2(blur)).xyz;\n    vec3 y = textureGrad(tex, rayPos.xz * scale.xz, vec2(blur), vec2(blur)).xyz;\n    vec3 z = textureGrad(tex, rayPos.xy * scale.xy, vec2(blur), vec2(blur)).xyz;\n    vec3 blend = pow(abs(normal), vec3(snap));\n    return (x * blend.x + y * blend.y + z * blend.z ) / (blend.x + blend.y + blend.z);\n}\n\n\n\n//Lighting\n\n//Infinite directional light\nfloat lightDirectional(vec3 normal, vec3 lightDir) {\n    return dot(lightDir,normal);\n}\n//Ambient occlusion\nfloat lightAmbientOcclusion(vec3 rayPos, vec3 normal, float size, float iterations, float intensity) {\n    float ambientOcclusion = 0.0;\n    for (float i = 1.0; i <= iterations; i++) {\n        float dist = size * i;\n        ambientOcclusion += max((dist - SDFpass(rayPos + normal * dist).dist) / dist, 0.0);\n    }\n    return 1.0 - ambientOcclusion * intensity;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy; //UVs\n    vec2 uvn = uv * 2.0 - 1.0;\n    \n    vec4 mouse = vec4(iMouse.xy / iResolution.xy * 2.0 - 1.0,iMouse.zw); //Mouse input\n    \n    vec3 camPos = vec3(-sin(radians(iTime*5.0))*7.0,4.0,-cos(radians(iTime*5.0))*7.0); //Basic camera setup\n    vec3 camRot = vec3(-25.0,iTime*5.0,0.0); //Camera rotation\n    \n    scene scene;\n    \n    vec3 rayPos = camPos; //Set ray position\n    vec3 rayDir = normalize(vec3(uvn.x, uvn.y * iResolution.y / iResolution.x,1.0)); //FOV\n    float rayDist;\n    \n    //Rotation matrix (Camera rotation)\n    rayDir = vec3(rayDir.x * cos(radians(camRot.z)) + rayDir.y * sin(radians(camRot.z)),\n                  rayDir.y * cos(radians(camRot.z)) + rayDir.x * -sin(radians(camRot.z)),\n                  rayDir.z);\n    rayDir = vec3(rayDir.x,\n                  rayDir.y * cos(radians(camRot.x)) + rayDir.z * sin(radians(camRot.x)),\n                  rayDir.z * cos(radians(camRot.x)) + rayDir.y * -sin(radians(camRot.x)));\n    rayDir = vec3(rayDir.x * cos(radians(camRot.y)) + rayDir.z * sin(radians(camRot.y)),\n                  rayDir.y,\n                  rayDir.z * cos(radians(camRot.y)) + rayDir.x * -sin(radians(camRot.y)));\n\t\n    vec3 color;\n    material mat;\n    \n    vec3 normal; //Init normal\n    float dist; //Init distance\n    float lowestDist = MAXIMUMDISTANCE; //Init lowest distance\n    \n    vec3 lightDir = normalize(vec3(-sin(radians(iTime*5.0))*8.0,8.0,-cos(radians(iTime*5.0))*8.0));\n    \n    for (float i = 0.0; i < ITERATIONS; i++) { //SDF passes\n        scene = SDFpass(rayPos);\n        rayDist = scene.dist; //SDF pass\n        if (rayDist < PRECISION) { //Collision\n            normal = getNormal(rayPos); //Calculate normal\n            break;\n        }\n        if (dist > MAXIMUMDISTANCE) {\n            scene.scenemat = material(1, vec3(0.3,0.6,1.0));\n            break;\n        }\n        rayPos += rayDist * rayDir; //Move ray\n        dist += rayDist;\n        lowestDist = min(rayDist, lowestDist);\n\t}\n    \n    mat = scene.scenemat;\n    \n    if (mat.sampler == 0) {\n        color = mat.col * textureTriplanar(rayPos, normal, iChannel0, vec3(0.25),5.0,pow(dist/200.0,3.0)) * lightDirectional(normal, lightDir) * lightAmbientOcclusion(rayPos, normal, 0.5, 3.0, 0.2);\n    } if (mat.sampler == 1) {\n        color = texture(iChannel1, rayDir).xyz * mat.col;\n    } if (mat.sampler == 2) {\n        color = mat.col * textureTriplanar(rayPos, normal, iChannel2, vec3(0.25),5.0,pow(dist/200.0,3.0)) * lightDirectional(normal, lightDir) * lightAmbientOcclusion(rayPos, normal, 0.5, 3.0, 0.2);\n    } if (mat.sampler == 3) {\n        color = mat.col * textureTriplanar(rayPos, normal, iChannel3, vec3(0.25),5.0,pow(dist/200.0,3.0)) * lightDirectional(normal, lightDir) * lightAmbientOcclusion(rayPos, normal, 0.5, 3.0, 0.2);\n    } if (mat.sampler == 4) {\n        color = mat.col * lightDirectional(normal, lightDir) * lightAmbientOcclusion(rayPos, normal, 0.5, 3.0, 0.2);\n    }\n    \n    fragColor = vec4(color,1.0) *  2.0; //Render to screen\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Math\n\n\n\n//Bidirectional modulo\nfloat biMod(float devidend, float devisor) {\n    return mod(devidend + devisor, devisor * 2.0) - devisor;\n} vec2 biMod(vec2 devidend, vec2 devisor) {\n    return mod(devidend + devisor, devisor * 2.0) - devisor;\n} vec3 biMod(vec3 devidend, vec3 devisor) {\n    return mod(devidend + devisor, devisor * 2.0) - devisor;\n}\n\n\n\n//Structs\n\n//Material\nstruct material {\n    int sampler;\n    vec3 col;\n};\n\n//Scene\nstruct scene {\n    float dist;\n    material scenemat;\n};\n\n\n//SDF\n\n\n\n//Shapes\n\n//Sphere\nscene SDFsphere(vec3 rayPos, vec3 pos, float radius, material mat) {\n    return scene(length(rayPos - pos) - radius, mat);\n}\n//Box\nscene SDFbox(vec3 rayPos, vec3 pos, vec3 scale, float radius, material mat)\n{\n  vec3 dist = abs(rayPos - pos) - scale;\n  return scene(length(max(dist,0.0)) - radius + min(max(dist.x,max(dist.y,dist.z)),0.0),mat);\n}\n//Infinite Plane\nscene SDFplane(vec3 rayPos, float height, material mat) {\n    return scene(rayPos.y - height, mat);\n}\n\n//Operations\n\n//Union\nscene SDFunion(scene a, scene b) {\n    if (a.dist < b.dist) {return a;} else {return b;}\n}\nscene SDFunionSmooth(scene a, scene b, float smth) {\n    scene re;\n    if (a.dist < b.dist) {re = a;} else {re = b;}\n    float h = clamp( 0.5 + 0.5*(a.dist - b.dist)/smth, 0.0, 1.0 );\n    re.dist = mix( a.dist, b.dist, h ) - smth*h*(1.0-h);\n\tre.scenemat.col = mix( a.scenemat.col, b.scenemat.col, h );\n    return re;\n}\n\n//Intersection\nscene SDFintersect(scene a, scene b) {\n    if (a.dist > b.dist) {return a;} else {return b;}\n}\n\n//Subtraction\nscene SDFsubtract(scene a, scene b) {\n    scene r;\n    if (a.dist > -b.dist) {r = a;} else {r = b;}\n    r.dist = max(a.dist,-b.dist);\n    return r;\n}","name":"Common","description":"","type":"common"}]}