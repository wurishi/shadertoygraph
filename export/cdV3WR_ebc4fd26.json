{"ver":"0.1","info":{"id":"cdV3WR","date":"1678400859","viewed":91,"name":"New Pride Flag","username":"Mojomajor","description":"https://outrightinternational.org/sites/default/files/styles/coh_x_large/public/2022-11/new-pride-flag-01.jpg?itok=UA9jM-CV","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["flag","new","pride"],"hasliked":0,"parentid":"ld3Bzr","parentname":"LGBTQ pride flag colormap"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define DEBUG_NO_POSTEFFECT\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI2 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n#ifdef DEBUG_NO_POSTEFFECT\n    col = texture(iChannel0, uv).rgb;\n#else\n    // Zoom\n    uv = uv * 2.0 - 1.0;\n    uv *= 0.9;\n    uv = (uv + 1.0) * 0.5;\n\n    // Lens distortion\n    vec2 dir = uv - vec2(0.5);\n    uv += dir * dot(dir, dir) * 0.2;\n    \n    float it = sin(iTime*3.);\n    // Chromatic aberration\n    vec2 offset = vec2(1.+it, 1.0) * 0.025*it/2.;\n    \n    col.r = texture(iChannel0, uv - offset).r;\n    col.g = texture(iChannel0, uv).g;\n    col.b = texture(iChannel0, uv + offset).b;\n    \n    // Vignette\n    vec2 d = abs(uv - vec2(0.5)) * 1.6;\n    \n    d = d*d;\n    float toPow = saturate(1.1 - dot(d, d));\n    col.rgb *= toPow*toPow*toPow;\n#endif\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// t âˆˆ [0, 1]\nvec4 flag(float t) {\n    if (t <= 1./6.) {\n        return vec4(0.89, 0.01, 0.01, 1.);\n    } else if (t <= 2./6.) {\n        return vec4(1., 0.55, 0., 1.);\n    } else if (t <= 3./6.) {\n        return vec4(1., 0.93, 0., 1.);\n    } else if (t <= 4./6.) {\n        return vec4(0., 0.5, 0.15, 1.);\n    } else if (t <= 5./6.) {\n        return vec4(0., 0.3, 1., 1.);\n    } else {\n        return vec4(0.46, 0.03, 0.53, 1.);\n    }\n}\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define TRIANGLE_DIST 0.25\n// 0,5\n#define TRIANGLE_OFFSET .65\n\n\nvec4 squares(vec2 uv, int N) {\n  vec2 st = uv;\n\n  // N: Number of sides of your shape\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TWO_PI/float(N);\n\n  // Shaping function that modulate the distance\n  float d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  return  vec4(1.0-smoothstep(.5,.51,d));\n}\n\nmat2 rotate2D(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    float t = uv.x*7.-2.*iTime+uv.y*3.;\n\n    // wind\n    uv.y += sin(t)*.03;\n    \n    // flag\n    float y = sin(uv.y*3.1415*6.);\n    float w = fwidth(y);\n    vec4 outCol = flag(1.-uv.y);\n    \n    \n    // triangles\n    vec2 st = uv;\n    \n    st.x*=aspectRatio*1.54;\n    st.x-=.0;\n    st.y-=.505;\n    st*=1.4;\n    st = rotate2D(0.5*PI*3.) * st;\n    \n    st.x-=0.009;\n    st.y-=TRIANGLE_OFFSET;\n    vec4 sq = squares(st,3);\n    sq.rgb=vec3(0.,0.,0.); // black\n    outCol = mix(outCol,sq,sq.a);\n    \n    float distT = (sin(iTime)*0.5+0.5)*0.05;\n    \n    st.y+=TRIANGLE_DIST+distT;\n    sq = squares(st,3);\n    sq.rgb=vec3(97, 57, 21)/255.; // brown\n    outCol = mix(outCol,sq,sq.a);\n    \n    st.y+=TRIANGLE_DIST+distT;\n    sq = squares(st,3);\n    sq.rgb=vec3(116, 215, 238)/255.; // baby blue\n    outCol = mix(outCol,sq,sq.a);\n    \n    st.y+=TRIANGLE_DIST+distT;\n    sq = squares(st,3);\n    sq.rgb=vec3(255, 175, 200)/255.; // pink\n    outCol = mix(outCol,sq,sq.a);\n\n    st.y+=TRIANGLE_DIST+distT;\n    sq = squares(st,3);\n    sq.rgb=vec3(1.,1.,1.);\n    outCol = mix(outCol,sq,sq.a);\n    \n    // cutoff\n    outCol.rgb *= smoothstep(w, .0, abs(uv.y-.5)-.5+w);\n    // shadow\n    outCol *= .7+cos(t)*.3;\n    fragColor = outCol;\n}","name":"Buffer A","description":"","type":"buffer"}]}