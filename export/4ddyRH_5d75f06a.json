{"ver":"0.1","info":{"id":"4ddyRH","date":"1518149300","viewed":89,"name":"Paw Metaballs - nmaga","username":"nmaga23","description":"Paw Metaballs for CIS566","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 300;\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateMatZ(float angle) {\n\tfloat rad = radians(angle);\n\treturn mat3(\n\t\tvec3(cos(rad), -sin(rad), 0.0),\n\t\tvec3(sin(rad), cos(rad), 0.0),\n\t\tvec3(0.0, 0.0, 1.0)\n\t);\n}\n\nfloat smin( float a, float b) {\n    float k = 10.0;\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sphereSDF0(vec3 p) {\n    return length(p) - 0.25;\n}\n\nfloat sphereSDF1(vec3 p) {\n\treturn length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 1.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF2(vec3 p) {\n\treturn length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 2.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF3(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 3.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF4(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 4.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF5(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 5.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF6(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 6.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF7(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 7.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sphereSDF8(vec3 p) {\n    return length(p + vec3(0.0, abs(.75 * sin(((iTime * .7) + (.4 * 8.0) )/ 1.0)), 0.0)) - 0.13;\n}\n\nfloat sceneSDF(vec3 p) {\n\tfloat group1 = smin(sphereSDF1(p * rotateMatZ(0.0)), sphereSDF2(p * rotateMatZ(45.0)));\n    float group2 = smin(sphereSDF3(p * rotateMatZ(90.0)), sphereSDF4(p * rotateMatZ(135.0)));\n    float group3 = smin(sphereSDF5(p * rotateMatZ(180.0)), sphereSDF6(p * rotateMatZ(225.0)));\n    float group4 = smin(sphereSDF7(p * rotateMatZ(270.0)), sphereSDF8(p * rotateMatZ(315.0)));\n    float group5 = smin(group1,group2);\n    float group6 = smin(group3,group4);\n    return smin(smin(group5, group6), sphereSDF0(p));\n}\n\nfloat march(vec3 rayOrigin, vec3 direction) {\n\tfloat dist = MIN_DIST;\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 pos = rayOrigin + dist * direction;\n\t\tfloat dt = sceneSDF(pos);\n\t\tif(dt < EPSILON) {\n\t\t\treturn dist;\n\t\t}\n\t\tdist += dt;\n\t\tif(dist >= MAX_DIST) {\n\t\t\treturn MAX_DIST;\n\t\t}\n\t}\n\treturn MAX_DIST;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(45.0) / 2.0);\n    \n    \n    vec3 eye = vec3(0.0, 0.0, 5.0);\n\tvec3 dir = normalize(vec3(xy, -z));\n\tfloat distance = march(eye, dir);\n\n\tif(distance >= MAX_DIST - 2.0 * EPSILON) {\n\t\tfragColor = vec4(1.0,1.0,1.0,1.0);\n        return;\n\t}\n\n\tfragColor = vec4(0.0,0.0,0.0,0.0);\n    \n}","name":"Image","description":"","type":"image"}]}