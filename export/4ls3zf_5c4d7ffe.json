{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// credits go to iq and his awesome articles about distance maps:\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/rmshadows\n\n// --- GLOBALS ---\n\nconst float e = 2.71828182845904523536028747135266249;\n\n// sun\nconst vec3 sun = vec3(-0.2, 1.0, 0.5);\n\nconst vec3 amb = vec3(0.01);\nconst vec3 bg = vec3(0.01, 0.01, 0.014);\n\n// --- FUNCTIONS ---\n\n// http://www.java-gaming.org/index.php?topic=28018.0\nfloat Rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 Map(in vec3 p) {\n    float id = 0.0;\n    float d = 1000.0;\n    \n    // sphere\n    float s = length(p - vec3(0.0, 0.5, 0.0)) - 0.6;\n    // block\n    float b = length(max(abs(p - vec3(0.0, 0.5, 0.0)) - vec3(0.4), 0.0)) - 0.1;\n    \n    // main shape\n    float m = max(b, -s);\n    if (m < d) {\n        d = m;\n        id = 1.0;\n    }\n    \n    // sphere 2\n    float x = length(p - vec3(0.0 + pow(sin(iTime * 0.6), 3.0), 0.5, 0.0 + pow(sin(iTime * 0.6 + 0.7853), 3.0))) - 0.3\n        + 0.01 * sin(p.x * 50.0) * sin(p.y * 50.0) * sin(p.z * 50.0);\n    if (x < d) {\n        d = x;\n        id = 3.0;\n    }\n    \n    // ground\n    float g = p.y;\n    if (g < d) {\n        d = g;\n        id = 2.0;\n    }\n    \n    return vec2(d, id);\n}\n\nvec3 MapNormal(in vec3 p) {\n    vec3 e = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    \n    n.x = Map(p + e.xyy).x - Map(p - e.xyy).x;\n    n.y = Map(p + e.yxy).x - Map(p - e.yxy).x;\n    n.z = Map(p + e.yyx).x - Map(p - e.yyx).x;\n    \n    return normalize(n);\n}\n\nvec2 Shoot(in vec3 ro, in vec3 rd) {\n    float t = 0.2;\n    for (int i = 0; i < 256; ++i) {\n        // map\n        vec2 m = Map(ro + rd * t);\n        if (m.x < 0.0001)\n            // we hit something\n            return vec2(t, m.y);\n        t += m.x;\n    }\n    return vec2(-1.0, 0.0);\n}\n\nfloat Shadow(in vec3 p, in vec3 n, in vec2 uv) {\n    vec3 ro = p + n * 0.001;\n    vec3 rd = sun;\n    \n    float res = 1.0;\n    float t = Rand(uv) * 0.04 + 0.002;\n    \n    for (int i = 0; i < 64; ++i) {\n        // map\n        float m = Map(ro + rd * t).x;\n        res = min( res, 10.0 * m / t );\n        if(res < 0.0001)\n            break;\n        t += clamp(m, 0.01, 0.02);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 Draw(in vec3 ro, in vec3 rd, in vec2 uv) {\n    // background\n    vec3 c = bg;\n    \n    // intersect the ray with geometry\n    vec2 res = Shoot(ro, rd);\n    \n    if (res.y > 0.5) {\n        // hit point\n        vec3 p = ro + rd * res.x;\n        \n        // normal\n        vec3 n = MapNormal(p);\n        \n        vec3 r = reflect(sun, n);\n        float sp = 0.0;\n        float s = 1.0;\n        \n        if (res.y < 1.5) {\n            // main shape\n            c = vec3(1.0, 0.2, 0.2);\n            sp = 0.8;\n            s = 4.0;\n        }\n        \n        else if (res.y < 2.5) {\n            // ground\n            c = vec3(0.4);\n        }\n        \n        else if (res.y < 3.5) {\n            // sphere 2\n            c = vec3(0.1, 0.3, 1.0);\n            sp = 1.0;\n            s = 20.0;\n        }\n        \n        // light\n        float dif = max(dot(n, sun), 0.0);\n        float shd = 0.0;\n        if (dif > 0.0)\n            shd = Shadow(p, n, uv);\n        float spe = sp * max(pow(max(dot(r, rd), 0.0), s), 0.0) * dif;\n        \n        c = clamp((spe + dif * c) * shd + amb * c * smoothstep(-1.5, 1.0, n.y), 0.0, 1.0);\n        \n        // fog\n        float f = pow(e, -pow(res.x*0.3, 2.0));\n        c = mix(bg, c, f);\n    }\n    \n    return c;\n}\n\n// --- MAIN ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // uv coords\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // create a ray\n    float d = 2.0;\n    vec3 ro = vec3(cos(iTime * 0.1) * d, 1.1, sin(iTime * 0.1) * d);\n    vec3 ta = vec3(0.0, 0.5, 0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(uv2.x * uu + uv2.y * vv + 2.0 * ww);\n    \n    // get color\n    vec3 color = Draw(ro, rd, uv);\n    \n    // gamma\n    color = sqrt(color);\n    \n    // output\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ls3zf","date":"1423996631","viewed":198,"name":"First Distance Map","username":"chuckeles","description":"My first attempt to use a distance map","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","map","distance"],"hasliked":0,"parentid":"","parentname":""}}