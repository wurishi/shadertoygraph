{"ver":"0.1","info":{"id":"clffzn","date":"1693262886","viewed":77,"name":"SDF Repository","username":"Luggen","description":"Repository for reusable code and test bed relating to SDF raymarching and rendering.\nClick-drag to change camera angle.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDF Repository\n//\n\n// Settings\n//\n#define MAX_STEPS          256\n#define MAX_TRACE_DISTANCE 8.0f\n#define MIN_DISTANCE       0.001f\n#define CAMERA_ORBIT       3.5f\n#define CAMERA_CENTER      v3(0.0f, 0.6f, 0.2f)\n#define TURNTABLE_CAMERA   0\n\n#define ALBEDO      0\n#define DIFFUSE     0\n#define SPECULAR    0\n#define FRESNEL     0\n#define ENVIRONMENT 0\n#define AO          0\n#define SHADOW      0\n#define NORMAL      0\n\n// Scene\n//\n#define ALBEDO_COLOR(linearColor) ((linearColor) * 0.3f)\n\nmaterial groundMat    = material(ALBEDO_COLOR(GREY(0.4f)), 0.8f);\nmaterial ballAMat     = material(ALBEDO_COLOR(MAGENTA),    0.4f);\nmaterial ballBMat     = material(ALBEDO_COLOR(CITRUS),     0.4f);\nmaterial boxMat       = material(ALBEDO_COLOR(LIME),       0.6f);\nmaterial capsuleMat   = material(ALBEDO_COLOR(CYAN),       0.5f);\nmaterial capsCutMat   = material(ALBEDO_COLOR(MELON_RED),  0.7f);\nmaterial cylinderMat  = material(ALBEDO_COLOR(PURPLE),     0.3f);\nmaterial torusMat     = material(ALBEDO_COLOR(GREY(0.8f)), 0.2f);\nmaterial torusBallMat = material(ALBEDO_COLOR(AQUA),       0.4f);\nmaterial coneMat      = material(ALBEDO_COLOR(ICE),        0.4f);\nmaterial coneBallMat  = material(ALBEDO_COLOR(ROSE),       0.2f);\n\n#define CELL(x, y) (v2(x, y) * 1.4f)\n\nSDF SDF_Scene(v3 P)\n{\n\tSDF ground = SDF(P.z, groundMat);\n\t\n\tSDF smoothBalls;\n\t{\n\t\tf32 t0 = Abs(MulAdd(Frac(iTime * 0.25f), 2.0, -1.0f));\n\t\tf32 t1 = SmoothStep(0.4f, 0.6f, t0);\n\t\tf32 t2 = SmoothStep(0.7f,0.8f, t0);\n\t\t\n\t\tv3  sphereAP    = v3(CELL(-1, 0), Lerp(-0.1f, 0.5f, t1));\n\t\tv3  sphereBP    = Lerp(sphereAP, v3(sphereAP.xy, sphereAP.z + 0.75f), t2);\n\t\t\n\t\tSDF sphereA     = SDF_Sphere(P - sphereAP, 0.1f, Lerp(ballBMat, ballAMat, t2));\n\t\tSDF sphereB     = SDF_Sphere(P - sphereBP, Lerp(0.1f, 0.2f, t2),  ballBMat);\n\t\t\n\t\tsmoothBalls = Op_SmoothUnion(sphereA, sphereB, 0.5f);\n\t\t\n\t\tground     = Op_SmoothCut(ground, smoothBalls, 3.0f);\n\t\tground.mat = groundMat;\n\t}\n\t\n\tSDF box;\n\t{\n\t\tf32 t0 = Abs(MulAdd(Frac(iTime * 0.15f), 2.0f, -1.0f));\n\t\tf32 t1 = SmoothStep(0.4f, 0.5f, t0);\n\t\tf32 t2 = SmoothStep(0.6f, 0.65f, t0);\n\t\tf32 t3 = MulAdd(Frac((iTime * 0.15f) + 0.55f), 9.0f, -4.5f);\n\t\tf32 t4 = SmoothT(Frac(Clamp01(t3)));\n\t\t\n\t\tv3  boxP   = v3(CELL(0, 0), Lerp(0.2f, 0.9f, t1));\n\t\tv3  localP = P - boxP;\n\t\t\n\t\tm3   R = XRotation(t4 * -TAU);\n\t\tlocalP = R * localP;\n\t\t\n\t\tbox = SDF_Box(localP, v3(0.2f, 0.2f, 0.2f), boxMat);\n\t\tbox = Op_Inflate(box, t2 * 0.1f);\n\t}\n\t\n\tSDF capsule;\n\t{\n\t\tv3 capP   = v3(CELL(1, 0), 0.6f);\n\t\tv3 localP = P - capP;\n\t\t\n\t\tf32 t0 = Abs(MulAdd(Frac(iTime * 0.15f), 12.0f, -6.0f));\n\t\tf32 t1 = SmoothT(Clamp01(t0 - 3.0f));\n\t\tf32 t2 = SmoothT(Clamp01(t0 - 4.0f));\n\t\t\n\t\tv3  boxP0  = v3(capP.xy, capP.z + 0.8f);\n\t\tv3  boxP1  = v3(capP.xy, capP.z + 0.3f);\n\t\tv3  boxP   = Lerp(boxP0, boxP1, t1);\n\t\tSDF cutBox = SDF_Box(P - boxP, v3(0.5f, 0.5f, 0.35f), capsCutMat);\n\t\t\n\t\tf32 radius     = Lerp(0.2f, 0.35f, t2);\n\t\tf32 halfHeight = 0.25f;\n\t\tcapsule  = SDF_Capsule(localP, halfHeight, radius, capsuleMat);\n\t\tSDF core = SDF_Capsule(localP, halfHeight, 0.05f,  capsuleMat);\n\t\t\n\t\tcapsule = Op_Onion(capsule, Lerp(0.25f, 0.04f, t2));\n\t\tcapsule = Op_SmoothUnion(capsule, core, 8.0f);\n\t\tcapsule = Op_Cut(capsule, cutBox);\n\t}\n\t\n\tSDF cylinder;\n\t{\n\t\tf32 t0         = Abs(MulAdd(Frac(iTime * 0.15f), 16.0f, - 8.0f));\n\t\tf32 t1         = SmoothT(Clamp01(t0 - 4.5f));\n\t\tv3  cylP       = v3(CELL(-1, 1), Lerp(-1.0f, 0.5f, t1));\n\t\tv3  localP     = P - cylP;\n\t\tf32 radius     = 0.25f;\n\t\tf32 halfHeight = 0.4f;\n\t\t\n\t\tcylinder = SDF_Cylinder(localP, halfHeight, radius, cylinderMat);\n\t\t\n\t\tf32 curRadius     = radius;\n\t\tf32 curHalfHeight = halfHeight;\n\t\tf32 curZ          = localP.z;\n\t\tf32 curOffT       = 5.0f;\n\t\tfor (s32 index = 0; index < 4; ++index)\n\t\t{\n\t\t\tcurRadius     *= 0.8f;\n\t\t\tcurHalfHeight *= 0.9f;\n\t\t\tcurOffT       += 0.15f;\n\t\t\tf32 t          = SmoothT(Clamp01(t0 - curOffT));\n\t\t\tcurZ          -= curHalfHeight * t;\n\t\t\t\n\t\t\tSDF curCyl = SDF_Cylinder(v3(localP.xy, curZ), curHalfHeight, curRadius, cylinderMat);\n\t\t\tcylinder   = Op_Union(cylinder, curCyl);\n\t\t}\n\t\t\n\t\tf32 t2      = SmoothT(Clamp01(t0 - 4.0f));\n\t\tf32 t3      = 1.0f - SmoothT(Clamp01(t0 - 5.5f));\n\t\tv3 gateP    = v3(cylP.xy, 0.0f);\n\t\tSDF gate    = SDF_Box(P - gateP, v3(Min(t2, t3) *0.35f, 0.35f, 0.2f), groundMat);\n\t\tv3 chamberP = v3(cylP.xy, -0.6f);\n\t\tSDF chamber = SDF_Box(P - chamberP, v3(0.5f, 0.5f, 0.5f), groundMat);\n\t\t\n\t\tground = Op_Cut(ground, chamber);\n\t\tground = Op_Cut(ground, gate);\n\t}\n\t\n\tSDF torus;\n\t{\n\t\tf32 t0 = MulAdd(Frac(iTime * 0.2f), 16.0f, -8.0f);\n\t\tf32 t1 = Max(t0, 0.0f);\n\t\tf32 t2 = Frac(t1 / 4.0f); // 2 reps\n\t\tf32 t3 = Frac(t1 / 8.0f); // 1 rep\n\t\tf32 t4 = 1.0f - Abs(MulAdd(t3, 2.0f, -1.0f)); // Triangle\n\t\tf32 t5 = Sin(t2 * TAU); // Torus rotation curve\n\t\tf32 t6 = SmoothT(Min(t4 * 4.0f, 1.0f)); // Triangle to ease-in-out\n\t\tf32 t7 = Abs(MulAdd(Frac((iTime * 0.2f) + 0.22f), 16.0f, -8.0f)) - 2.5f;\n\t\tf32 t8 = SmoothT(Clamp01(t7)); // Ball radius curve\n\t\t\n\t\tv3  torusP  = v3(CELL(1, 1), 0.4f);\n\t\tv3  localP  = P - torusP;\n\t\tf32 rOuter  = 0.35f;\n\t\tf32 rInner  = Lerp(0.1f, 0.05f, t8);\n\t\t\n\t\tm3  R  = YRotation(-(t5 * t5 * Sign(t5)) * t6);\n\t\tlocalP = R * localP;\n\t\t\n\t\ttorus = SDF_Torus(localP, rOuter, rInner, torusMat);\n\t\t\n\t\tf32 radBall = SmoothT(t3) * 2.0f * TAU;\n\t\tv3  ballP   = v3(v2(Cos(radBall), Sin(radBall)) * rOuter, 0.0f);\n\t\tf32 rBall   = rInner * 2.0f * t8;\n\t\tSDF ball    = SDF_Sphere(localP - ballP, rBall, torusBallMat);\n\t\t\n\t\ttorus = Op_SmoothUnion(torus, ball, 8.0f);\n\t}\n\t\n\tSDF cone;\n\t{\n\t\tf32 t0 = Abs(MulAdd(Frac(iTime * 0.2f), 12.0f, -6.0f));\n\t\tf32 t1 = SmoothT(Clamp01(t0 - 2.0f));\n\t\tf32 t2 = SmoothT(Clamp01(t0 - 3.0f));\n\t\t\n\t\tv3  coneP  = v3(CELL(0, 1), 0.0f);\n\t\tf32 rA     = Lerp(0.4f, 0.3f, t1);\n\t\tf32 rB     = Lerp(0.25f, 0.15f, t1);\n\t\tf32 height = Lerp(0.4f, 1.0f, t2);\n\t\tv3  localP = P - coneP;\n\t\t\n\t\tcone = SDF_CapCone (localP, height, rA, rB, coneMat);\n\t\t\n\t\tv3  hollowP = v3(0.0f, 0.0f, height * 0.5f);\n\t\tf32 rHollow = t2 * 0.3f;\n\t\tSDF hollow  = SDF_Sphere(localP - hollowP, rHollow, coneMat);\n\t\tSDF ball    = SDF(hollow.distance + 0.05f, coneBallMat);\n\t\t\n\t\tcone = Op_Cut  (cone, hollow);\n\t\tcone = Op_Union(cone, ball);\n\t}\n\t\n\tSDF result = smoothBalls;\n\tresult = Op_Union(result, box);\n\tresult = Op_Union(result, capsule);\n\tresult = Op_Union(result, cylinder);\n\tresult = Op_Union(result, torus);\n\tresult = Op_Union(result, cone);\n\tresult = Op_Union(result, ground);\n\t\n\treturn result;\n}\n\n// Raymarching\n//\nstruct traceResult\n{\n\tv3   hitP;\n\tf32  traceDistance;\n\tSDF  hitSDF;\n\tbool hit;\n};\n\ntraceResult TraceScene(v3 rayOrigin, v3 ray)\n{\n\ttraceResult result = traceResult(v3(0.0f), MIN_DISTANCE, NULL_SDF, false);\n\t\n\tfor (s32 stepIndex = 0; stepIndex < MAX_STEPS; ++stepIndex)\n\t{\n\t\tv3 P = rayOrigin + (ray * result.traceDistance);\n\t\tSDF curSample = SDF_Scene(P);\n\t\tif (Abs(curSample.distance) < MIN_DISTANCE)\n\t\t{\n\t\t\tresult.hitP   = P;\n\t\t\tresult.hitSDF = curSample;\n\t\t\tresult.hit    = true;\n\t\t\tbreak;\n\t\t}\n\t\tresult.traceDistance += curSample.distance;\n\t\tif (result.traceDistance > MAX_TRACE_DISTANCE)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nf32 TraceShadow(v3 surfaceP, v3 normal, v3 lightDir, f32 invSourceSize)\n{\n\tsurfaceP += normal * MIN_DISTANCE;\n\tf32 traceDistance = MIN_DISTANCE;\n\tf32 result = 1.0f;\n\tfor (s32 stepIndex = 0; stepIndex < MAX_STEPS; ++stepIndex)\n\t{\n\t\tv3 P = surfaceP - (lightDir * traceDistance);\n\t\tSDF curSample = SDF_Scene(P);\n\t\tif (Abs(curSample.distance) < MIN_DISTANCE)\n\t\t{\n\t\t\tresult = 0.0f;\n\t\t\tbreak;\n\t\t}\n\t\tresult = Min(result, invSourceSize * (curSample.distance / traceDistance));\n\t\ttraceDistance += curSample.distance;\n\t\tif (traceDistance > MAX_TRACE_DISTANCE)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nf32 CalcAO(v3 P, v3 normal)\n{\n\tf32 dStep  = MIN_DISTANCE;\n\tf32 result = 0.0f;\n    f32 scale  = 1.0f;\n\tfor (s32 index = 0; index < 5; ++index)\n\t{\n\t\tdStep     += 0.01f;\n\t\tv3  stepP  = P + (normal * dStep);\n\t\tf32 dScene = SDF_Scene(stepP).distance;\n        scale     *= 0.95f;\n        result    += (dStep - dScene) * scale;\n\t}\n\treturn Clamp01(1.0f - (2.0f * result));\n}\n\nv3 CalcNormal(v3 P, f32 distance)\n{\n\tv3 Pd = P + 0.001f;\n\t\n\tf32 dX = SDF_Scene(v3(Pd.x, P.yz)).distance;\n\tf32 dY = SDF_Scene(v3(P.x,  Pd.y, P.z)).distance;\n\tf32 dZ = SDF_Scene(v3(P.xy, Pd.z)).distance;\n\t\n\treturn Normalize(v3(dX, dY, dZ) - distance);\n}\n\nv3 CalcSky(v3 ray)\n{\n\treturn Lerp(GREY(0.7f), AQUA, ray.z);\n}\n\nv3 CalcSkyDome(v3 ray, v3 sunDir, v3 sunColor)\n{\n\tv3 sun = Power(Max(Dot(ray, -sunDir), 0.0f), 50.0f) * sunColor;\n\treturn CalcSky(ray) + sun;\n}\n\n// TODO: Proper roughness\nv3 CalcEnvironment(v3 ray, f32 roughness)\n{\n\tv3 skyColor = CalcSky(ray);\n\t// Ground\n\tf32 rHorizon = 0.1f + (roughness * 0.5f);\n\tf32 tHorizon = SmoothStep(-rHorizon, rHorizon, ray.z);\n\treturn Lerp(groundMat.albedo, skyColor, tHorizon);\n}\n\n// Main\n//\nvoid mainImage(out v4 fragColor, in v2 fragCoord )\n{\n\t// View coordinates\n\tv2 halfRes    = iResolution.xy * 0.5f;\n\tv2 filmCoords = (fragCoord - halfRes) / halfRes.x;\n\t\n\t// Camera setup\n#if TURNTABLE_CAMERA\n\tf32 yaw   = iTime * 0.2f;\n\tf32 pitch = -0.2 * PI;\n#else\n\tv2 deviceCursor = v2(0.2f, -0.15f);\n\t// Only read mouse cursor position if click has occurred.\n\tif (Max(iMouse.z, iMouse.w) != 0.0f)\n\t{\n\t\tv2 normCursor = iMouse.xy / iResolution.xy;\n\t\tdeviceCursor  = (normCursor * 2.0f) - 1.0f;\n\t}\n\tf32 yaw   = deviceCursor.x * PI;\n\tf32 pitch = Min(deviceCursor.y, 0.0f) * PI;\n#endif\n\tv3 yawVector = v3(Sin(yaw), Cos(yaw), 0.0f);\n\t\n\t// Right-hand world coordinates\n\t// X = forward, Y = left, Z = up\n\tv3 cameraY = v3(Perp(yawVector.xy), 0.0f);\n\tv3 cameraX = (yawVector * Cos(pitch)) + (Z_AXIS * Sin(pitch));\n\tv3 cameraZ = Cross(cameraX, cameraY);\n\t\n\tv3 cameraP = CAMERA_CENTER - (cameraX * CAMERA_ORBIT);\n\t\n\tv3 ray  = Normalize(cameraX - (cameraY * filmCoords.x) + (cameraZ * filmCoords.y));\n\tv3 rayP = cameraP;\n\t\n\tv3 sunDir   = Normalize(v3(1.0f, 2.0f, -2.0f));\n\tv3 sunColor = IVORY * 3.0f;\n\t\n\ttraceResult mainTrace = TraceScene(cameraP, ray);\n\t\n\tv3 resultColor = CalcSkyDome(ray, sunDir, sunColor * 0.5f);\n\t\n\tif (mainTrace.hit)\n\t{\n\t\tmaterial mat = mainTrace.hitSDF.mat;\n\t\t\n\t\tv3  P      = mainTrace.hitP;\n\t\tf32 d      = mainTrace.hitSDF.distance;\n\t\tv3  normal = CalcNormal(P, d);\n\t\t\n\t\t// Surface shading\n\t\tf32 diffuse = Max(-Dot(normal, sunDir), 0.0f);\n\t\tf32 shadow  = TraceShadow(P, normal, sunDir, 16.0f);\n\t\tf32 ao      = CalcAO(P, normal);\n\t\t\n\t\tv3  halfV    = Normalize(sunDir + ray);\n\t\tf32 tSpec    = 1.0f - mat.roughness;\n\t\tf32 specular = Power(Max(-Dot(halfV, normal), 0.0f), 1.0f + (50.0f * tSpec));\n\t\t\n\t\tf32 fresnel  = Power(1.0f - Max(-Dot(normal, ray), 0.0f), 1.0f + (2.0f * tSpec));\n\t\t\n\t\tv3  envRay   = Reflect(ray, normal);\n\t\tv3  envColor = CalcEnvironment(envRay, mat.roughness);\n\t\t\n\t\tv3 diffuseLight  = diffuse * shadow * ao * mat.albedo * sunColor;\n\t\tv3 envLight      = envColor * mat.albedo;\n\t\tv3 specularLight = specular * ao * shadow * diffuse * tSpec * ALBEDO_COLOR(sunColor);\n\t\tv3 fresnelLight  = fresnel * envColor;\n\t\t\n        v3 resultLight   = diffuseLight + specularLight + fresnelLight + envLight;\n\t\t\n\t\tresultLight = InvSquared(resultLight * 0.5f);\n\t\t\n\t\t// Horizon\n\t\tf32 depth   = mainTrace.traceDistance / MAX_TRACE_DISTANCE;\n\t\tresultColor = Lerp(resultLight, resultColor, Power(depth, 4.0f));\n\t\t\n#if   ALBEDO\n\t\tresultColor = mat.albedo;\n#elif DIFFUSE\n\t\tresultColor = diffuseLight;\n#elif SPECULAR\n\t\tresultColor = specularLight;\n#elif FRESNEL\n\t\tresultColor = fresnelLight;\n#elif ENVIRONMENT\n\t\tresultColor = envLight;\n#elif AO\n\t\tresultColor = v3(ao);\n#elif SHADOW\n\t\tresultColor = v3(shadow);\n#elif NORMAL\n\t\tresultColor = normal;\n#endif\n\t}\n#if (ALBEDO | DIFFUSE | SPECULAR | FRESNEL | ENVIRONMENT | AO | SHADOW | NORMAL) == 0\n\t// Gamma correction\n\tresultColor = SquareRoot(resultColor);\n#endif\n\tfragColor = v4(resultColor, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Colors\n//\n#define WHITE        v3(1.0f,  1.0f,  1.0f )\n#define BLACK        v3(0.0f,  0.0f,  0.0f )\n#define IVORY        v3(1.0f,  1.0f,  0.9f )\n#define RED          v3(1.0f,  0.0f,  0.0f )\n#define GREEN        v3(0.0f,  1.0f,  0.0f )\n#define BLUE         v3(0.0f,  0.0f,  1.0f )\n#define YELLOW       v3(1.0f,  1.0f,  0.0f )\n#define CITRUS       v3(0.9f,  1.0f,  0.1f )\n#define CYAN         v3(0.0f,  1.0f,  1.0f )\n#define LIGHT_ORANGE v3(1.0f,  0.8f,  0.0f )\n#define ORANGE       v3(1.0f,  0.8f,  0.1f )\n#define AQUA         v3(0.1f,  0.5f,  1.0f )\n#define EMERALD      v3(0.2f,  1.0f,  0.5f )\n#define NEON_GREEN   v3(0.0f,  1.0f,  0.2f )\n#define LIME         v3(0.7f,  1.0f,  0.2f )\n#define SLIME        v3(0.8f,  1.0f,  0.1f )\n#define KALE         v3(0.3f,  0.7f,  0.2f )\n#define PURPLE       v3(0.7f,  0.3f,  0.9f )\n#define MAGENTA      v3(1.0f,  0.0f,  1.0f )\n#define ROSE         v3(1.0f,  0.1f,  0.2f )\n#define VIOLET       v3(0.8f,  0.5f,  0.8f )\n#define PINK         v3(1.0f,  0.6f,  0.6f )\n#define FIERY_RED    v3(1.0f,  0.2f,  0.1f )\n#define COBALT       v3(0.1f,  0.1f,  0.5f )\n#define WALNUT       v3(0.3f,  0.2f,  0.25f)\n#define SILK         v3(0.85f, 0.9f,  0.9f )\n#define COAL         v3(0.1f,  0.08f, 0.12f)\n#define ICE          v3(0.3f,  0.8f,  0.9f )\n#define MELON_RED    v3(1.0f,  0.1f,  0.2f )\n#define GREY(v)      v3(v)\n\n// API override\n//\n#define u32 uint\n#define s32 int\n#define f32 float\n#define v2  vec2\n#define v3  vec3\n#define v4  vec4\n#define m2  mat2\n#define m3  mat3\n#define m4  mat4\n#define i2  ivec2\n#define i3  ivec3\n\n#define Cos        cos\n#define Sin        sin\n#define ATan       atan\n#define Abs        abs\n#define Sign       sign\n#define Min        min\n#define Max        max\n#define Clamp      clamp\n#define Frac       fract\n#define Floor      floor\n#define Ceil       ceil\n#define Exp        exp\n#define Lerp       mix\n#define SmoothStep smoothstep\n#define Dot        dot\n#define Cross      cross\n#define Normalize  normalize\n#define Length     length\n#define SquareRoot sqrt\n#define Distance   distance\n#define Reflect    reflect\n#define Power      pow\n#define Sample     texture\n\n// Math utility\n//\n#define Clamp01(value) clamp(value, 0.0f, 1.0f)\n\n#define TAU 6.28318530718f\n#define PI  3.14159265359f\n#define INF 1000000.0f\n\n#define X_AXIS v3(1.0f, 0.0f, 0.0f)\n#define Y_AXIS v3(0.0f, 1.0f, 0.0f)\n#define Z_AXIS v3(0.0f, 0.0f, 1.0f)\n\nv2 Perp(v2 V)\n{\n\treturn v2(-V.y, V.x);\n}\n\nvoid DeriveAxis(v3 X, v3 pole, out v3 Y, out v3 Z)\n{\n\tZ = Normalize(pole - (X * Dot(X, pole)));\n\tY = Cross(X, Z);\n}\n\nf32 SmoothT(f32 t)\n{\n\treturn t * t * (3.0f - (2.0f * t));\n}\n\nf32 InvSquared(f32 t)\n{\n\tt = 1.0f - t;\n\treturn 1.0f - (t * t);\n}\n\nv3 InvSquared(v3 t)\n{\n\tt = 1.0f - t;\n\treturn 1.0f - (t * t);\n}\n\n#define MulAdd(value, mul, add) (((value) * (mul)) + (add))\n\nm2 Rotation(f32 rad)\n{\n\tf32 c = Cos(rad);\n\tf32 s = Sin(rad);\n\treturn m2( c, s,\n\t\t\t  -s, c);\n}\n\nm3 XRotation(f32 rad)\n{\n\tf32 c = Cos(rad);\n\tf32 s = Sin(rad);\n\treturn m3(1.0f, 0.0f, 0.0f,\n\t\t\t  0.0f,    c,    s,\n\t\t\t  0.0f,   -s,    c);\n}\n\nm3 YRotation(f32 rad)\n{\n\tf32 c = Cos(rad);\n\tf32 s = Sin(rad);\n\treturn m3(c,    0.0f,    s,\n\t\t\t  0.0f, 1.0f, 0.0f,\n\t\t\t  -s,   0.0f,    c);\n}\n\nm3 ZRotation(f32 rad)\n{\n\tf32 c = Cos(rad);\n\tf32 s = Sin(rad);\n\treturn m3( c,   s,    0.0f,\n\t\t\t  -s,   c,    0.0f,\n\t\t\t  0.0f, 0.0f, 1.0f);\n}\n\n// SDF Functions\n//\n#define material  v4\n#define albedo    xyz\n#define roughness w\n\nstruct SDF\n{\n\tf32 distance;\n\tmaterial mat;\n};\n\n#define NULL_SDF SDF(INF, material(0.0f))\n\nSDF SDF_Sphere(v3 P, f32 radius, material m)\n{\n\treturn SDF(Length(P) - radius, m);\n}\n\nSDF SDF_Box(v3 P, v3 extent, material m)\n{\n\tv3  D      = Abs(P) - extent;\n\tf32 dOuter = Length(Max(D, 0.0f));\n\tf32 dInner = Min(Max(D.x, Max(D.y, D.z)), 0.0f);\n\treturn SDF(dInner + dOuter, m);\n}\n\nSDF SDF_Line(v3 P, v3 start, v3 end, f32 radius, material m)\n{\n\tv3  V = end - start;\n\tf32 t = Clamp01(Dot(P - start, V) / Dot(V, V));\n\tv3  PLine = start + (t * V);\n\treturn SDF(Distance(PLine, P) - radius, m);\n}\n\nSDF SDF_Capsule(v3 P, f32 halfHeight, f32 radius, material m)\n{\n\tf32 dy = Clamp(P.z, -halfHeight, halfHeight);\n\tv2  D     = v2(Length(P.xy), P.z - dy);\n\treturn SDF(Length(D) - radius, m);\n}\n\nSDF SDF_Cylinder(v3 P, f32 halfHeight, f32 radius, material m)\n{\n\tf32 dx     = Length(P.xy) - radius;\n\tf32 dy     = Abs(P.z) - halfHeight;\n\tf32 dOuter = Length(Max(v2(dx, dy), 0.0f));\n\tf32 dInner = Min(Max(dx, dy), 0.0f);\n\treturn SDF(dInner + dOuter, m);\n}\n\nSDF SDF_Torus(v3 P, f32 outerRadius, f32 innerRadius, material m)\n{\n\tf32 x = Length(P.xy) - outerRadius;\n\treturn SDF(Length(v2(x, P.z)) - innerRadius, m);\n}\n\n#if 0\n// NOTE: Interpretation of https://www.shadertoy.com/view/tsSXzK.\nSDF SDF_CapCone(v3 P, v3 A, v3 B, f32 rA, f32 rB, material m)\n{\n\tv3 AB     = B - A;\n\tv3 localP = P - A;\n\t\n\tf32 l2LocalP = Dot(localP, localP);\n\tf32 l2AB     = Dot(AB, AB);\n\t\n\tf32 t0       = Dot(localP, AB) / l2AB;\n\t\n\tf32 xPlaneP  = SquareRoot(l2LocalP - (t0 * t0 * l2AB));\n\t\n\tf32 rPick    = (t0 < 0.5f) ? rA : rB;\n\tf32 xCornerP = Max(xPlaneP - rPick, 0.0f);\n\tf32 t1       = Abs(t0 - 0.5f) - 0.5f;\n\t\n\tf32 xSideY   = rB - rA;\n\tf32 l2Side   = (xSideY * xSideY) + l2AB;\n\t\n\tf32 xSideP   = xPlaneP - rA;\n\tf32 tSide0   = ((xSideY * xSideP) + (t0 * l2AB)) / l2Side;\n\ttSide0       = Clamp01(tSide0);\n\t\n\tf32 xLineP   = tSide0 * xSideY;\n\tf32 xLineD   = xSideP - xLineP;\n\tf32 tDif     = t0 - tSide0;\n\t\n\tf32 dSign    = (xLineD < 0.0f && t1 < 0.0f) ? -1.0f : 1.0f;\n\t\n\tf32 d20      = (xCornerP * xCornerP) + (t1   * t1   * l2AB);\n\tf32 d21      = (xLineD   * xLineD)   + (tDif * tDif * l2AB);\n\t\n\tf32 distance = dSign * SquareRoot(Min(d20, d21));\n\t\n\treturn SDF(distance, m);\n}\n#endif\n// Local space conversion\nSDF SDF_CapCone(v3 P, f32 height, f32 rA, f32 rB, material m)\n{\n\tf32 l2P      = Dot(P, P);\n\tf32 h2       = height * height;\n\t\n\tf32 t0       = P.z / height;\n\t\n\tf32 xPlaneP  = Length(P.xy);\n\t\n\tf32 rPick    = (t0 < 0.5f) ? rA : rB;\n\tf32 xCornerP = Max(xPlaneP - rPick, 0.0f);\n\tf32 t1       = Abs(t0 - 0.5f) - 0.5f;\n\t\n\tf32 xSideY   = rB - rA;\n\tf32 l2Side   = (xSideY * xSideY) + h2;\n\t\n\tf32 xSideP   = xPlaneP - rA;\n\tf32 tSide0   = ((xSideY * xSideP) + (t0 * h2)) / l2Side;\n\ttSide0       = Clamp01(tSide0);\n\t\n\tf32 xLineP   = tSide0 * xSideY;\n\tf32 xLineD   = xSideP - xLineP;\n\tf32 tDif     = t0 - tSide0;\n\t\n\tf32 dSign    = (xLineD < 0.0f && t1 < 0.0f) ? -1.0f : 1.0f;\n\t\n\tf32 d20      = (xCornerP * xCornerP) + (t1   * t1   * h2);\n\tf32 d21      = (xLineD   * xLineD)   + (tDif * tDif * h2);\n\t\n\tf32 distance = dSign * SquareRoot(Min(d20, d21));\n\t\n\treturn SDF(distance, m);\n}\n\n// TODO: Parabola?\n\n// TODO: Bezier3\n\n// TODO: Bezier4\n\n// SDF Operators\n//\nSDF Op_Union(SDF a, SDF b)\n{\n\tif (a.distance < b.distance)\n\t\treturn a;\n\telse \n\t\treturn b;\n}\n\n// Cut a by b\nSDF Op_Cut(SDF a, SDF b)\n{\n\tb.distance = -b.distance;\n\tif (b.distance > a.distance)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nSDF Op_Intersect(SDF a, SDF b)\n{\n\tif (a.distance > b.distance)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nf32 SmoothFunction(f32 dA, f32 dB, f32 sharpness)\n{\n\tf32 d = (dB - dA) * sharpness;\n\tf32 t = Clamp01(d + 0.5f);\n\tf32 m = (t * (1.0f - t) * 0.5f) / sharpness;\n\treturn Lerp(dB, dA, t) - m;\n}\n\nSDF Op_SmoothUnion(SDF a, SDF b, f32 sharpness)\n{\n\tf32 dA = a.distance;\n\tf32 dB = b.distance;\n\tf32 d = (dB - dA) * sharpness;\n\tf32 t = Clamp01(d + 0.5f);\n\tf32 m = (t * (1.0f - t) * 0.5f) / sharpness;\n\treturn SDF(Lerp(dB, dA, t) - m, Lerp(b.mat, a.mat, t));\n}\n\n// Cut a by b\nSDF Op_SmoothCut(SDF a, SDF b, f32 sharpness)\n{\n\tf32 dA = a.distance;\n\tf32 dB = -b.distance;\n\tf32 d = (dB - dA) * -sharpness;\n\tf32 t = Clamp01(d + 0.5f);\n\tf32 m = (t * (1.0f - t) * 0.5f) / -sharpness;\n\treturn SDF(Lerp(dB, dA, t) - m, Lerp(b.mat, a.mat, t));\n}\n\nSDF Op_SmoothIntersect(SDF a, SDF b, f32 sharpness)\n{\n\tf32 dA = a.distance;\n\tf32 dB = b.distance;\n\tf32 d = (dB - dA) * -sharpness;\n\tf32 t = Clamp01(d + 0.5f);\n\tf32 m = (t * (1.0f - t) * 0.5f) / -sharpness;\n\treturn SDF(Lerp(dB, dA, t) - m, Lerp(b.mat, a.mat, t));\n}\n\nSDF Op_Hollow(SDF a, f32 extent, f32 bias)\n{\n\ta.distance = Abs(a.distance - (bias * extent)) - extent;\n\treturn a;\n}\n\nSDF Op_Inflate(SDF a, f32 amount)\n{\n\ta.distance -= amount;\n\treturn a;\n}\n\nSDF Op_Onion(SDF a, f32 thickness)\n{\n\tf32 extent = thickness * 0.5f;\n\tf32 period = thickness * 2.0f;\n\tf32 d = (a.distance + extent) / period;\n\td     = 1.0f - Abs(MulAdd(Frac(d), 4.0f, -2.0f));\n\td    *= extent;\n\t// Maintain outside of shape\n\ta.distance = Max(d, a.distance);\n\treturn a;\n}","name":"Common","description":"","type":"common"}]}