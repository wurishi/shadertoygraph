{"ver":"0.1","info":{"id":"ts2cDm","date":"1586796052","viewed":78,"name":"moon over water","username":"inco","description":"My 1st glsl generated image/animation. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2dimage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2;\n}\n\nfloat rand(vec2 co){\n      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Star(vec2 uv, float x, float y)\n{\n    x *= 2.0;\n    y /= 2.0;\n\tfloat dist = length(vec2(uv.x + x - 0.9, uv.y-y));\n    return smoothstep(0.008, 0.001, dist);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 skyColor = vec3(0.1);\n    \n    float x = uv.x;\n    \n    float m = abs(cos(iTime+x*18.0)*0.05);\n    \n    float y = uv.y+m;\n    \n\t//waves\n\tfloat wave0 = Rect(vec2(x, uv.y+abs(cos(-0.1+iTime+x*18.0)*0.05)), -1.5, 1.5, -0.0, 0.7, 0.005);\n    float wave1 = Rect(vec2(x, uv.y+abs(cos(0.05+iTime+x*18.0)*0.05)), -1.5, 1.5, -0.13, 0.0, 0.005);\n    float wave2 = Rect(vec2(x, uv.y+abs(cos(-0.10+iTime+x*18.0)*0.05)), -1.5, 1.5, -0.28, -0.13, 0.005);\n    float wave3 = Rect(vec2(x, y), -1.5, 1.5, -0.55, -0.28, 0.005);\n    \n    //sun, but it's actually moon\n    //creating vars to avoid stars later\n    //but in the end they weren't needed\n    vec2 moonPos = vec2(uv.x + 0.3, uv.y - 0.3);\n    float moonRadius = 0.16;\n    float moonBlur = 0.12;\n    float dist = length(moonPos);\n    float moon = smoothstep(moonRadius, moonBlur, dist);\n    \n    //stacking waves into one pixel data\n    vec3 waves = (skyColor*wave0) + (vec3(0.2, 0.5, 0.9)*wave1) + (vec3(0.35, 0.6, 0.8)*wave2) + (vec3(0.56, 0.76, 0.85)*wave3);\n\n    vec3 moonMask = (vec3(0.9, 0.35, 0.1))*moon*5.0;   \n    \n    //scales from left to right\n    vec3 pct = vec3(uv.x+0.37);\n\n    vec3 starMask = vec3(0.0);\n    for(int i=0; i <= 70; i=i+1)\n    {\n        float star1 = Star(uv, rand(vec2(iDate.z, i)), rand(vec2(i, i)));\n        float star2 = Star(uv, rand(vec2(iDate.z, i)), rand(vec2(i, i)));\n    \tstarMask += vec3(rand(vec2(iTime/700000.0, i)))*star1;\n    }\n\n    \n    //black magic happens here\n    \n    //gradient for halfmoon\n    vec3 halfMoon = mix(vec3(0.0), moonMask, pct); //pct\n    \n    \n\t//po odjęciu pomarańczowego księżyca od gwiazd na masce z gwiazdami zostają nam niebieskie gwiazdy\n    starMask -= moonMask;\n    vec3 col = max(waves*0.6,halfMoon);\n    //więc bierzemy inną wartość niż niebieską, która dla białej gwiazdy przyjmuje wartość 1.0\n    col = max(col, starMask.r);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}