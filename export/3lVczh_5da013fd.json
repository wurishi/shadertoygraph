{"ver":"0.1","info":{"id":"3lVczh","date":"1611598131","viewed":354,"name":"The Queen's Gambit - A Tribute","username":"Atchafalaya","description":"I've been training with SDF modeling for the past weeks. And after watching The Queen's Gambit, I dedided to model a pawn then a rook and I found myself with all chess pieces modeled with SDFs. So I decided I would combine everything in a beautiful scene.","likes":15,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","sdf","chess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment first line of the common tab to enable reflections.\n// WARNING: the shader takes around 3 times longer to compile with reflections enabled!\n//\n// Created by Selim Tirellil - Atchafalaya/2021\n// \n// I've been training with SDF modeling for the past weeks. And after watching\n// The Queen's Gambit, I dedided to model a pawn then a rook and I found myself\n// with all chess pieces modeled with SDFs. So I decided I would combine everything\n// in a beautiful scene. This short checkmate, the Scholar's mate, is the first\n// game Beth, the main character, plays in the mini-series.\n//\n// To optimise the world distance evaluation, I split up the pieces in two sections:\n// - The static pieces:\n//      Each type of piece is evaluated only once and duplicated using the symmetries\n//      of the board to fill all its spots (rooks and kings are exemples of this)\n// - The animated pieces:\n//      Here, I chose the pieces that would move in a way that keep symmetries as much\n//      as possible to keep the distance evaluation the cheapest possible. For instance,\n//      the two black and white pawns are rendered by evaluating only one pawn, but it\n//      is the symmetry plane that moves instead of the pieces themselves. This is\n//      done as well with the two queens (the symmetry point moves in way that keeps\n//      the black queen still), the two black derpy horses and two bishops (one moving,\n//      one still).\n// Also, all the pieces have bounding volumes so that the raymarching algorithm\n// bails quickly if the piece is far away.\n//\n// If you have any recommandation on how to further improve compilation time, feel free\n// to leave a comment. That would be appreciated.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / R;\n    vec4 col = texture(iChannel0, uv);\n    // w channel of buffer A is 0 if the ray hit the sky and 1 otherwise\n    if (col.w > 0.) \n    {\n        // Tone mapping\n        col.xyz = 0.5 * pow(col.xyz, vec3(0.4));\n        // Custom \"gamma correction\" to enhance mid tones\n        // while still keeping contrast\n        col.xyz += 0.1 * sin(PI * col.xyz);\n    }\n    fragColor = vec4(col.xyz, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define REFLECTIONS\n\n// UNIFORMS\n#define R iResolution.xy\n#define M iMouse\n\n// GENERAL\n#define FOCAL                  4.\n#define CAMERA_DISTANCE        30.\n#define I_MAX                  150\n#define FAR                    60.\n#define BOARD_UNIT             2.3\n#define METERS_PER_BOARD_UNIT  0.04   // used for point light attenuation\n#define EPS                    0.01\n#define PI                     3.141592653589793\n\n// ANIMATION\n// durations in seconds\n#define MOVE_DURATION 1.\n#define WAIT_DURATION 0.5\n#define TURN_DURATION (WAIT_DURATION + MOVE_DURATION)\n\n// MATERIALS\n#define BOARD_WHITE 0u\n#define BOARD_BLACK 1u\n#define WOOD        2u\n#define CHESS_WHITE 3u\n#define CHESS_BLACK 4u\n\nstruct Material\n{\n    vec3 diffuse;\n    float roughness;\n    float reflectiveness;\n};\n\nconst Material materials[] = Material[](\n    Material(vec3(0.9)            , 0.4, 0.25),   // BOARD_WHITE\n    Material(vec3(0.05)           , 0.4, 0.25),   // BOARD_BLACK\n    Material(vec3(0.0)            , 0.9, 0.05),   // WOOD\n    Material(vec3(0.95, 0.95, 0.9), 0.6, 0.20),   // CHESS_WHITE\n    Material(vec3(0.05)           , 0.6, 0.15)    // CHESS_BLACK\n);\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~~~~~~~~~~~~~ Camera ~~~~~~~~~~~~~~\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nmat3 rot(vec2 angle)\n{\n    vec2 cc = cos(angle);\n    vec2 ss = sin(angle);\n    return mat3(vec3(cc.x      , 0.  , ss.x      ),\n\t\t\t\tvec3(ss.x*ss.y , cc.y, -ss.y*cc.x),\n                vec3(-cc.y*ss.x, ss.y, cc.x*cc.y ));\n}\n\nvoid getCamera(vec2 uv, vec4 mouse, float time, out vec3 ro, out vec3 rd)\n{\n    vec2 angle = vec2(0.8 * PI - sin(0.25 * time), 0.4);\n    if (max(mouse.z, mouse.w) > 0.)\n    {\n        angle = mouse.xy * vec2(4., -0.5);\n        angle += vec2(0., 0.2);\n    }\n    mat3 rotCam = rot(angle);\n    ro = rotCam * vec3(0., 0., CAMERA_DISTANCE);\n    ro += vec3(0., -1., 0.);\n    rd = rotCam * normalize(vec3(uv, -FOCAL));\n\n}\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~~~~~~~~~ Hash and noise ~~~~~~~~~~~\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash function from Dave_Hoskins' shader https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p)\n{\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz+33.33);\n    return fract((p.xxy + p.yxx)*p.zyx);\n}\n\n// from iq's website https://iquilezles.org/articles/gradientnoise\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~~~~~~~ SDFs and operations ~~~~~~~~\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// SDFs from iq's website\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere(vec3 o, float r, vec3 p)\n{\n    return length(p - o) - r;\n}\n\nfloat sdBox(vec3 b, vec3 p)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundedBox(vec3 b, float r, vec3 p)\n{\n\treturn sdBox(b, p) - r;\n}\n\nfloat sdHPlane(float h, vec3 p)\n{\n    return p.y - h;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 r, vec3 p)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus(vec2 t, vec3 p)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundCone(vec3 a, vec3 b, float r1, float r2, vec3 p)\n{\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 x =  pa*l2 - ba*y;\n    float x2 = dot(x, x);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCone(vec2 c, float h, vec3 p)\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat det( vec3 a, vec3 b, in vec3 v ) { return dot(v,cross(a,b)); }\n\nfloat sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n{\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    \n    vec3  d21 = b2-b1;\n    vec3  d10 = b1-b0;\n    vec3  d20 = (b2-b0)*0.5;\n\n    vec3  n = normalize(cross(d10,d21));\n\n    float a = det(b0,b2,n);\n    float b = det(b1,b0,n);\n    float d = det(b2,b1,n);\n    vec3  g = b*d21 + d*d10 + a*d20;\n\tfloat f = a*a*0.25-b*d;\n\n    vec3  z = cross(b0,n) + f*g/dot(g,g);\n    float t = clamp( dot(z,d10-d20)/(a+b+d), 0.0 ,1.0 );\n    vec3 q = mix(mix(b0,b1,t), mix(b1,b2,t),t);\n    \n    float k = dot(q,n);\n    return length(q);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a, float b, float k)\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat sdKing(vec3 p)\n{\n    float d0 = sdBox(vec3(1., 1.9, 1.), p - vec3(0., 0.9, 0.));\n    if (d0 > 30. * EPS)\n    {\n        return d0;\n    }\n    // body\n    vec3 p0 = p - vec3(0., 0.55, 0.);\n    float r = 0.28 + pow(0.45 - p0.y, 2.) / 7.;\n    d0 = sdCappedCylinder(1.55, r, p0);\n    // head\n    vec3 p1 = p - vec3(0., 1.326, 0.);\n    float d1 = sdSolidAngle(p1, vec2(cos(1.045), sin(1.045)), 0.9);\n    d0 = smin(d0, d1, 0.001) - 0.02;\n    // head/crown\n    vec3 p2 = p - vec3(0., 2.3, 0.);\n    float d2 = sdSphere(vec3(0.), 0.1, p2);\n    d0 = smin(d0, d2, 0.03);\n    vec3 p3 = p - vec3(0., 2.54, 0.);\n    vec3 r3 = vec3(0.13 + 0.46 * p3.y,\n                   0.16,\n                   0.03 - 0.1 * p3.y);\n    float d3 = sdRoundedBox(r3, 0.02, p3);\n    d0 = smin(d0, d3, 0.04);\n    vec3 p4 = p - vec3(0., 2.71, 0.);\n    p4.y = -p4.y;\n    float period = 0.102;\n    p4.x = p4.x - period * (clamp(round(p4.x / period) + 0.5, -1.5, 2.5) - 0.5);\n    float d4 = sdTriPrism(p4, vec2(0.07));\n    d0 = smax(d0, -d4, 0.03);\n    vec3 p5 = p - vec3(0., 1.62, 0.);\n    float d5 = sdEllipsoid(vec3(0.48, 0.07, 0.48), p5);\n    d0 = smin(d0, d5, 0.03);\n    vec3 p6 = p - vec3(0., 1.72, 0.);\n    float d6 = sdEllipsoid(vec3(0.43, 0.07, 0.43), p6);\n    d0 = smin(d0, d6, 0.03);\n    // base\n    vec3 p7 = p - vec3(0., -1., 0.);\n    float d7 = sdTorus(vec2(0.43, 0.5), p7);\n    d7 = max(d7, -sdHPlane(0., p7));\n    d0 = smin(d0, d7, 0.05);\n    float d8 = sdEllipsoid(vec3(0.77, 0.08, 0.77), p - vec3(0., -0.54, 0.));\n    d0 = smin(d0, d8, 0.05);\n    // stripes\n    float d9 = sdTorus(vec2(0.578, 0.01), p - vec3(0., -0.425, 0.));\n    d0 = smax(d0, -d9, 0.05);\n    float d10 = sdTorus(vec2(0.548, 0.01), p - vec3(0., -0.345, 0.));\n    d0 = smax(d0, -d10, 0.05);\n    return d0;\n}\n\nfloat sdQueen(vec3 p)\n{\n    float d0 = sdBox(vec3(1., 1.65, 1.), p - vec3(0., 0.65, 0.));\n    if (d0 > 30. * EPS)\n    {\n        return d0;\n    }\n    // body\n    vec3 p0 = p - vec3(0., 0.5, 0.);\n    float r = 0.28 + pow(0.4 - p0.y, 2.) / 6.;\n    d0 = sdCappedCylinder(1.5, r, p0) - 0.02;\n    // head\n    vec3 p1 = p - vec3(0., 1.9, 0.);\n    float d1 = sdCappedCylinder(0.2, r - 0.1, p1);\n    d0 = smax(d0, -d1, 0.03);\n    vec3 p2 = p  - vec3(0., 2.05, 0.);\n    float a = mod(atan(p2.z, p2.x) + PI / 8., PI / 4.) - PI / 8.;\n    float l = length(vec2(p2.x, p2.z));\n    p2 = vec3(p2.y, l * cos(a), l * sin(a));\n    float d2 = sdCappedCylinder(0.6, 0.12, p2);\n    d0 = smax(d0, -d2, 0.07);\n    vec3 p3 = p - vec3(0., 2.15, 0.);\n    float d3 = sdCone(vec2(sin(PI / 5.), cos(PI / 5.)), 0.22, p3);\n    d0 = smin(d0, d3, 0.05);\n    float d4 = sdSphere(vec3(0., 2.18, 0.), 0.09, p);\n    d0 = smin(d0, d4, 0.03);\n    vec3 p5 = p - vec3(0., 1.4, 0.);\n    float d5 = sdEllipsoid(vec3(0.5, 0.07, 0.5), p5);\n    d0 = smin(d0, d5, 0.03);\n    vec3 p6 = p - vec3(0., 1.51, 0.);\n    float d6 = sdEllipsoid(vec3(0.42, 0.07, 0.42), p6);\n    d0 = smin(d0, d6, 0.03);\n    // base\n    vec3 p7 = p - vec3(0., -1., 0.);\n    float d7 = sdTorus(vec2(0.43, 0.5), p7);\n    d7 = max(d7, -sdHPlane(0., p7));\n    d0 = smin(d0, d7, 0.05);\n    float d8 = sdEllipsoid(vec3(0.77, 0.08, 0.77), p - vec3(0., -0.55, 0.));\n    d0 = smin(d0, d8, 0.05);\n    // stripes\n    float d9 = sdTorus(vec2(0.586, 0.01), p - vec3(0., -0.425, 0.));\n    d0 = smax(d0, -d9, 0.05);\n    float d10 = sdTorus(vec2(0.553, 0.01), p - vec3(0., -0.345, 0.));\n    d0 = smax(d0, -d10, 0.05);\n    return d0;\n}\n\nfloat sdBishop(vec3 p)\n{\n    float d0 = sdBox(vec3(1., 1.55, 1.), p - vec3(0., 0.45, 0.));\n    if (d0 > 30. * EPS)\n    {\n        return d0;\n    }\n    // body\n    float r = 0.2 + 1.2 * pow(1. - p.y, 2.) / 8.;\n    d0 = sdCappedCylinder(1., r, p);\n    // head\n    float d1 = sdRoundCone(vec3(0., 1.2, 0.), vec3(0., 1.7, 0.), 0.34, 0.05, p);\n    d0 = smin(d0, d1, 0.05);\n    float d2 = sdSphere(vec3(0., 1.75, 0.), 0.08, p);\n    d0 = smin(d0, d2, 0.02);\n    vec3 p3 = p - vec3(0., 0.86, 0.);\n    float d3 = sdEllipsoid(vec3(0.33, 0.08, 0.33), p3);\n    d0 = smin(d0, d3, 0.03);\n    vec3 p4 = rot(vec2(0., PI / 6.)) * p;\n    p4 -= vec3(0., 1.3, -0.58);\n    // head slit, mouth ... ?\n    float d4 = sdBox(vec3(0.5, 0.3 , 0.01 * (1. - 2. * clamp(p4.y, -1., 1.))), p4) - 0.015;\n    d0 = smax(d0, -d4, 0.05);\n    // base\n    vec3 p5 = p - vec3(0., -1., 0.);\n    float d5 = sdTorus(vec2(0.4, 0.46), p5);\n    d5 = max(d5, -sdHPlane(0., p5));\n    d0 = smin(d0, d5, 0.05);\n    float d6 = sdEllipsoid(vec3(0.68, 0.08, 0.68), p - vec3(0., -0.55, 0.));\n    d0 = smin(d0, d6, 0.05);\n    // stripes\n    float d7 = sdTorus(vec2(0.496, 0.01), p - vec3(0., -0.425, 0.));\n    d0 = smax(d0, -d7, 0.05);\n    float d8 = sdTorus(vec2(0.474, 0.01), p - vec3(0., -0.37, 0.));\n    d0 = smax(d0, -d8, 0.05);\n    return d0;\n}\n\nfloat sdKnight(vec3 p)\n{\n    float d0 = sdBox(vec3(1., 1.55, 1.), p - vec3(0., 0.45, 0.));\n    if (d0 > 30. * EPS)\n    {\n        return d0;\n    }\n    p.x = abs(p.x);\n    // body\n    vec3 p0 = rot(vec2(0., -0.32)) * (p - vec3(0., 0.25, 0.)) + vec3(0., 0., 0.15);\n    float rx = 0.4 + 0.3 * smoothstep(0.4, -1., p0.y);\n    float rz = 0.8 - 0.3 * smoothstep(-1., 1., p0.y);\n    d0 = sdEllipsoid(vec3(rx, 1.3, rz), p0);\n    vec3 p1 = p - vec3(0., -1., 0.);\n    float d1 = sdTorus(vec2(0.43, 0.5), p1);\n    d1 = max(d1, -sdHPlane(0., p1));\n    d0 = smin(d0, d1, 0.2);\n    vec3 p2 = p - vec3(0., -0.45, 0.);\n    float d2 = sdEllipsoid(vec3(0.66, 0.1, 0.78), p2);\n    d0 = smin(d0, d2, 0.03);\n    // head\n    vec3 p3 = rot(vec2(0., 0.3)) * (p - vec3(0., 1.3, 0.));\n    rx = 0.35 - 0.12 * smoothstep(-0.3, 0.5, p3.y);\n    float d3 = sdEllipsoid(vec3(rx, 0.45, 0.75), p3);\n    // head/chin\n    d3 = smax(d3, -sdCappedCylinder(0.4, 0.25, (p3 - vec3(0., -0.42, 0.33)).yxz), 0.2);\n    // head/mouth\n    d3 = smax(d3, -sdCappedCylinder(0.4, 0.05, (p3 - vec3(0., 0., 0.7)).yxz), 0.1);\n    d0 = smin(d0, d3, 0.15);\n    // head/eyes\n    vec3 p4 = p - vec3(0.23, 1.55, 0.);\n    float d4 = sdEllipsoid(vec3(0.1, 0.05 + 0.04 * smoothstep(0.1, -0.1, p4.z), 0.1), p4);\n    d0 = smax(d0, -d4, 0.08);\n    // head/mane\n    vec3 p5 = p - vec3(0., 0.8, 0.);\n    float freq = 5.7;\n    float notch = atan(p5.y, p5.z);\n    notch = fract(freq * notch);\n    notch = pow(notch, 2.);\n    notch = 4. * notch * (1. - notch);\n    float d5 = sdBezier(p, vec3(0., 1.72,  0.2 ),\n                           vec3(0., 2.25, -1.25),\n                           vec3(0., -0.2, -0.7 )) - 0.075 - 0.025 * notch;\n    d0 = smin(d0, d5, 0.04);\n    // head/nostrils\n    vec3 p6 = rot(vec2(0., -0.6)) * (p - vec3(0.11, 1.33, 0.65));\n    float rxz = 0.035 + 0.035 * smoothstep(-0.1, 0.1, p6.y);\n    float d6 = sdEllipsoid(vec3(rxz, 0.07, rxz), p6);\n    d0 = smax(d0, -d6, 0.02);\n    // notches\n    vec3 p7 = rot(vec2(0., -0.25))\n            * rot(vec2(0.8, 0.))\n            * (p - vec3(0.47, 0.2, -0.28));\n    float d7 = sdEllipsoid(vec3(0.05,\n                                0.3 + 0.4  * smoothstep(-0.1, 0.1, p7.y),\n                                0.05 - 0.025 * smoothstep(-0.1, 0.8, p7.y)), p7);\n    d0 = smax(d0, -d7, 0.02);\n    vec3 p8 = rot(vec2(0., -0.35))\n            * rot(vec2(0.6, 0.))\n            * (p - vec3(0.485, 0.2, -0.08));\n    float d8 = sdEllipsoid(vec3(0.05,\n                                0.3 + 0.4  * smoothstep(-0.1, 0.1, p8.y),\n                                0.05 - 0.025 * smoothstep(-0.1, 0.8, p8.y)), p8);\n    d0 = smax(d0, -d8, 0.02);        \n    return d0;\n}\n\nfloat sdRook(vec3 p)\n{\n    float d0 = sdBox(vec3(1., 1.25, 1.), p - vec3(0., 0.2, 0.));\n    if (d0 > 30. * EPS)\n    {\n        return d0;\n    }\n    float r = 0.4 + (pow(1. - p.y, 2.) / 8.);\n    d0 = sdCappedCylinder(1., r, p);\n    vec3 p1 = p - vec3(0., 1.15, 0.);\n    float d1 = sdCappedCylinder(0.13, 0.52, p1) - 0.01;\n    d0 = smin(d0, d1, 0.15);\n    vec3 p2 = p - vec3(0., 1.25, 0.);\n    float d2 = sdCappedCylinder(0.1, 0.32, p2) - 0.08;\n    float a = mod(atan(p2.z, p2.x) + PI / 8., PI / 4.) - PI / 8.;\n    float l = length(vec2(p2.x, p2.z));\n    p2 = vec3(l * cos(a), p2.y, l * sin(a));\n    d2 = smin(d2, sdBox(vec3(0.65, 0.1, 0.06), p2), 0.02);\n    d0 = smax(d0, -d2, 0.03);\n    vec3 p3 = p - vec3(0., 0.935, 0.);\n    float d3 = sdEllipsoid(vec3(0.45, 0.1, 0.45), p3);\n    d0 = smin(d0, d3, 0.02);\n    vec3 p4 = p - vec3(0., -1., 0.);\n    float d4 = sdTorus(vec2(0.5, 0.45), p4);\n    d4 = max(d4, -sdHPlane(0., p4));\n    d0 = smin(d0, d4, 0.05);\n    float d5 = sdEllipsoid(vec3(0.8, 0.08, 0.8), p - vec3(0., -0.55, 0.));\n    d0 = smin(d0, d5, 0.05);\n    float d6 = sdTorus(vec2(0.66, 0.01), p - vec3(0., -0.45, 0.));\n    d0 = smax(d0, -d6, 0.05);\n    float d7 = sdTorus(vec2(0.63, 0.01), p - vec3(0., -0.38, 0.));\n    d0 = smax(d0, -d7, 0.05);\n    return d0;\n}\n\nfloat sdPawn(vec3 p)\n{\n    float d0 = sdBox(vec3(1., 1.15, 1.), p - vec3(0., 0.1, 0.));\n    if (d0 > 30. * EPS) { return d0; }\n    d0 = sdCappedCylinder(1., 0.15 + (pow(1. - p.y, 2.) / 6.), p);\n    float d1 = sdSphere(vec3(0., 1., 0.), 0.3, p);\n    d0 = smin(d0, d1, 0.05);\n    float d2 = sdEllipsoid(vec3(0.25, 0.1, 0.25), p - vec3(0., 0.7, 0.));\n    d0 = smin(d0, d2, 0.05);\n    vec3 q = p - vec3(0., -1., 0.);\n    float d3 = sdTorus(vec2(0.5, 0.36), q);\n    d3 = max(d3, -sdHPlane(0., q));\n    d0 = smin(d0, d3, 0.05);\n    float d4 = sdEllipsoid(vec3(0.65, 0.05, 0.65), p - vec3(0., -0.6, 0.));\n    d0 = smin(d0, d4, 0.05);\n    float d5 = sdTorus(vec2(0.5, 0.01), p - vec3(0., -0.52, 0.));\n    d0 = smax(d0, -d5, 0.1);\n    float d6 = sdTorus(vec2(0.47, 0.01), p - vec3(0., -0.43, 0.));\n    d0 = smax(d0, -d6, 0.1);\n    return d0;\n}\n\nfloat sdBoard(vec3 p)\n{\n    float d0 = sdRoundedBox(vec3(4. * BOARD_UNIT + 0.2, 0.35, 4. * BOARD_UNIT + 0.2), 0.1, p - vec3(0., -1.5, 0.));\n    if (d0 > 30. * EPS) { return d0; }\n    vec3 p1 = p - vec3(0., -1.08, 0.);\n    p1.x = p1.x - BOARD_UNIT * clamp(round(p1.x / BOARD_UNIT), -3., 3.);\n    float d1 = dot(p1.xy, normalize(vec2(.5, -1.)));\n    d1 = max(d1, dot(p1.xy, normalize(vec2(-.5, -1.))));\n    d1 = max(d1, abs(p1.z) - 4. * BOARD_UNIT);\n    d0 = max(d0, -d1);\n    vec3 p2 = p - vec3(0., -1.08, 0.);\n    p2.z = p2.z - BOARD_UNIT * clamp(round(p2.z / BOARD_UNIT), -3., 3.);\n    float d2 = dot(p2.zy, normalize(vec2(.5, -1.)));\n    d2 = max(d2, dot(p2.zy, normalize(vec2(-.5, -1.))));\n    d2 = max(d2, abs(p2.x) - 4. * BOARD_UNIT);\n    d0 = max(d0, -d2);\n    return d0;\n}\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~~~~~~~ Ray-marching algorithm ~~~~~~~~\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nstruct RMResult{\n  \tfloat dist;\n    float id;\n};\n\nRMResult map(vec3 p, float time)\n{\n    float d = FAR;\n    float id = -1.;\n            \n    {// board\n        float d0 = sdBoard(p);\n        if (d0 < d)\n        {\n            d = d0;\n            id = 0.5;\n        }\n    }\n    {// chess pieces\n        // turns\n        time = mod(time, 10. * TURN_DURATION);    \n        float move1w, move1b, move2w, move2b, move3w, move3b, move4w, checkmate, backToStart;\n        backToStart = clamp(time - 9. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION;\n        move1w =    clamp(time - 0. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        move1b =    clamp(time - 1. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        move2w =    clamp(time - 2. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        move2b =    clamp(time - 3. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        move3w =    clamp(time - 4. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        move3b =    clamp(time - 5. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        move4w =    clamp(time - 6. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        checkmate = clamp(time - 7. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;\n        \n        // static pieces\n        vec3 p0 = vec3(-abs(p.x), p.y, -abs(p.z));\n        float d0 = sdRook(p0 + vec3(3.5, 0., 3.5) * BOARD_UNIT);\n        d0 = min(d0, sdKnight(vec3(-abs(p.x), p.yz) + vec3(2.5, 0., 3.5) * BOARD_UNIT));\n        d0 = min(d0, sdBishop(vec3(-p.x, p.y, -abs(p.z)) + vec3(1.5, 0., 3.5) * BOARD_UNIT));\n        vec3 p1 = vec3(p.xy, -abs(p.z));\n        float sdVanish = sdBox(vec3(0.5 * BOARD_UNIT, 2.2, 0.5 * BOARD_UNIT),\n                              p - vec3(-0.5 * BOARD_UNIT, 1., 3.5 * BOARD_UNIT));\n        sdVanish = max(sdVanish, - (noise(p) - 0.5 + checkmate));\n        float sdKing = sdKing(p1 + vec3(0.5, 0., 3.5) * BOARD_UNIT);\n        sdKing = max(sdKing, -sdVanish);\n        d0 = min(d0, sdKing);\n        // static pawns\n        float c = BOARD_UNIT;\n        float l = 3.;\n        vec3 p2 = vec3(-p.x, p.y, -abs(p.z)) + vec3(-0.5, 0., 2.5) * BOARD_UNIT;\n        p2.x = p2.x - c * clamp(round(p2.x / c), -l-1., l) - (c + p2.x) * 0.5 * (sign(p2.x + 0.5 * c) + sign(0.5 * c - p2.x));\n        sdVanish = sdBox(vec3(0.5 * BOARD_UNIT, 2.2, 0.5 * BOARD_UNIT),\n                         p - vec3(-1.5 * BOARD_UNIT, 1., 2.5 * BOARD_UNIT));\n        sdVanish = max(sdVanish, - (noise(p) - 0.5 + move4w));\n        float sdStaticPawns = max(sdPawn(p2), - sdVanish);\n        d0 = min(d0, sdStaticPawns);\n\n        // moving pawns\n        vec3 origPawn = vec3(0.5, 0., 2.5) * BOARD_UNIT;\n        vec3 destPawn = vec3(0.5, 0., 0.5) * BOARD_UNIT;\n        vec3 p3 = vec3(-p.x,\n                       p.y,\n                       abs(p.z\n                           - 0.5 * mix(0., origPawn.z - destPawn.z, move1w)\n                           + 0.5 * mix(0., origPawn.z - destPawn.z, move1b)));\n        p3.xy -= mix(origPawn, destPawn, move1w).xy;\n        p3.z -= origPawn.z + 0.5 * mix(0., destPawn.z - origPawn.z, move1w);\n        p3.z -= 0.5 * mix(0., destPawn.z - origPawn.z, move1b);\n        d0 = min(d0, sdPawn(p3));\n        // moving queen\n        vec3 origQueen  = vec3(-0.5, 0.,  3.5) * BOARD_UNIT;\n        vec3 destQueen  = vec3(3.5 , 0., -0.5) * BOARD_UNIT;\n        vec3 origQueen2 = destQueen;\n        vec3 destQueen2 = vec3(1.5 , 0., -2.5) * BOARD_UNIT;\n        vec3 moveQueen = mix(vec3(0.), origQueen  - destQueen , move2w)\n                       + mix(vec3(0.), origQueen2 - destQueen2, move4w);\n        float z4sym = p.z - 0.5 * moveQueen.z;\n        vec3 p4 = vec3(p.xy, -abs(z4sym));\n        p4 += vec3(-0.5, 0., 3.5) * BOARD_UNIT;\n        p4 -= 0.5 * vec3(moveQueen.x * (1. - sign(z4sym)), 0., moveQueen.z);\n        float dQueen = sdQueen(p4);\n        // moving knights\n        vec3 origKnight = vec3(-2.5, 0., -3.5) * BOARD_UNIT;\n        vec3 destKnight = vec3(-1.5, 0., -1.5) * BOARD_UNIT;\n        vec3 p5 = vec3(-abs(p.x), p.y, -p.z);\n        vec3 knightMove = vec3(mix(0., destKnight.x - origKnight.x, move2b),\n                               8. * move2b * (1. - move2b),\n                               mix(0., destKnight.z - origKnight.z, move2b))\n                          * 0.5 * (1. + sign(p.x));\n        knightMove += vec3(mix(0., destKnight.x - origKnight.x, move3b),\n                           8. * move3b * (1. - move3b),\n                           mix(0., destKnight.z - origKnight.z, move3b))\n                      * 0.5 * (1. - sign(p.x));\n        p5 -= origKnight + knightMove;\n        mat3 rotMove = rot(vec2(0., PI * (move2b * (1. + sign(p.x))\n                                        + move3b * (1. - sign(p.x)))));\n        p5 = rotMove * p5;\n        float dKnight = sdKnight(p5);\n        d0 = min(d0, dKnight);\n        // moving bishop\n        vec3 origBishop = vec3(1.5, 0., -3.5) * BOARD_UNIT;\n        vec3 destBishop = vec3(-1.5, 0., -.5) * BOARD_UNIT;\n        vec3 p6 = vec3(-p.x, p.y, -abs(p.z));\n        vec3 bishopMove = mix(vec3(0.), destBishop - origBishop, move3w);\n        p6 -= origBishop + 0.5 * bishopMove * (1. - sign(p.z));\n        d0 = min(d0, sdBishop(p6));\n                \n        if (d0 < d || dQueen < d)\n        {\n            if (d0 < dQueen){\n                d = d0;\n                if (p.z < 0.)\n                {\n                    // white pieces id\n                    id = 1.5;\n                }\n                else\n                {\n                    // black pieces id\n                    id = 2.5;\n                }\n            }\n            else \n            {\n                d = dQueen;\n                \n                if (p.z < 3. * BOARD_UNIT)\n                {\n                    // white pieces id\n                    id = 1.5;\n                }\n                else\n                {\n                    // black pieces id\n                    id = 2.5;\n                }\n            }\n        }\n    }\n    return RMResult(d, id);\n}\n\n// from iq's article https://iquilezles.org/articles/normalsSDF\nvec3 gradient( in vec3 p, float time )\n{\n    const float h = EPS * EPS;\n    vec3 n = vec3(0.0);\n    for(int i = int(min(time, 0.)); i < 4; i++)\n    {\n        vec3 e = 0.5773 * ( 2.0 * vec3((((i + 3) >> 1 ) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * map(p + e * h, time).dist;\n    }\n    return normalize(n);\n}\n\nRMResult raymarch(float time, vec3 ro, vec3 rd, out float t)\n{\n\tt = 0.;\n    vec3 p = ro + t * rd;\n    RMResult s = map(p, time);\n    float isInside = sign(s.dist);\n    for(int i = 0; i < I_MAX; i++)\n    {\n        float inc = isInside * s.dist;\n        if (min(abs(p.z - 3. * BOARD_UNIT), abs(p.z)) < 0.5 * BOARD_UNIT)\n        {\n            inc *= 0.7;         // dirty hack to fix domain discontinuity near z=0 and z=3*BOARD_UNIT plane \n            if (abs(p.x - 1.5 * BOARD_UNIT) < 0.5 * BOARD_UNIT)\n                inc *= 0.6;     // fix annoying artefacts on the moving bishop that I couldn't remove otherwise\n        }\n        if (t + inc < FAR && abs(s.dist) > EPS) \n        {\n\t\t\tt += inc;\n\t        p = ro + t * rd;\n            s = map(p, time);\n        }\n        else\n        {\n            if (t + inc > FAR)\n            {\n               s.id = -1.;\n            }\n            break;\n        }\n    }\n    return s;\n}\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// ~~~~~~~~ Lighting utilities ~~~~~~~~~~\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nstruct Light\n{\n    vec3 color;\n    vec3 pos;\n};\n\nvec3 getWoodColor(vec3 p, vec3 normal, sampler2D wood)\n{\n    vec3 n = abs(normal);\n    vec2 fetch = n.x > n.y && n.x > n.z ? vec2(0.5 * p.z, p.y) :\n                              n.y > n.z ? vec2(p.x, p.z) * 0.5 :\n                                          vec2(0.5 * p.x, p.y);\n    return textureLod(wood, fetch, 0.).xyz;\n}\n\n//Schlick approx\nvec3 fresnelTermApprox(vec3 toEye, vec3 halfVec)\n{\n    vec3 minVal = vec3(0.005);\n    return minVal + (1. - minVal)*pow(1. - dot(toEye, halfVec), 5.);\n}\n\nfloat microfacetDistribution(vec3 toEye, vec3 reflectedRay, float roughness)\n{\n    float alpha = roughness * roughness;\n    float dotER = dot(toEye, reflectedRay);\n    float f = (dotER * alpha - dotER) * dotER + 1.;\n    return alpha / (PI * f * f);\n}\n\nvec3 illuminate(vec3 toLight, vec3 toEye, vec3 normal, vec3 lightColor, Material material)\n{\n    float dnl = dot(normal, toLight);\n    if (dnl < 0. || dot(toEye, normal) < 0.) return vec3(0.);\n    float ooToLightLength = 1. / length(toLight);\n    toLight *= ooToLightLength;\n    vec3 hvec = normalize(toLight + toEye);\n    vec3 fresnel = fresnelTermApprox(toEye, hvec);\n    vec3 specularContrib, diffuseContrib;\n    if (material.roughness < 1.)\n    {\n        float D = microfacetDistribution(normal, hvec, material.roughness);\n        specularContrib = fresnel * D;\n    }\n    else\n    {\n        specularContrib = vec3(0.);\n    }\n    diffuseContrib = (1./PI) * (1. - fresnel) * material.diffuse;\n\t\n    dnl *= ooToLightLength;\n    vec3 result = lightColor * (specularContrib + diffuseContrib);\n    ooToLightLength /= METERS_PER_BOARD_UNIT / BOARD_UNIT;\n    result *= dnl * ooToLightLength * ooToLightLength;\n    return result;\n}\n\nvec3 getAmbiant(vec3 p, RMResult s, vec3 normal, vec3 wood, vec3 sky){\n    vec3 col;\n    Material mat;\n    if (s.id < 0.)\n    {\n        // skybox\n        col = sky;\n    }\n    else if (s.id < 1.)\n    {\n        // board\n        if (max(abs(p.x), abs(p.z)) > 4. * BOARD_UNIT)\n        {\n            mat = Material(wood, materials[WOOD].roughness, materials[WOOD].reflectiveness);\n        }\n        else\n        {\n            vec2 ss = sin((PI / BOARD_UNIT) * p.xz);\n            uint matIndex = sign(ss.x) * sign(ss.y) < 0. ? BOARD_BLACK : BOARD_WHITE;\n            mat = materials[matIndex];\n        }\n    }\n    else if (s.id < 2.)\n    {\n        // white chess piece\n        mat = materials[CHESS_WHITE];\n    }\n    else if (s.id < 3.)\n    {\n        // black chess piece\n        mat = materials[CHESS_BLACK];\n    }\n    if (s.id > 0.)\n    {\n        col = mat.diffuse;\n    }\n    return col;\n}\n\n// Diffuse and specular contribution of a point light\nvec3 getColor(vec3 p, RMResult s, vec3 normal, vec3 toLight, vec3 toEye, Light light,\n              vec3 wood, vec3 sky, out float reflectiveness)\n{\n    vec3 col;\n    if (s.id < 0.)\n    {\n        // skybox\n        col = sky;\n        reflectiveness = 0.;\n    }\n    else if (s.id < 1.)\n    {\n        // board\n        Material boardMat;\n        if (max(abs(p.x), abs(p.z)) > 4. * BOARD_UNIT)\n        {\n            boardMat = Material(wood, materials[WOOD].roughness, materials[WOOD].reflectiveness);\n        }\n        else\n        {\n            vec2 ss = sin((PI / BOARD_UNIT) * p.xz);\n            uint matIndex = sign(ss.x) * sign(ss.y) < 0. ? BOARD_BLACK : BOARD_WHITE;\n            boardMat = materials[matIndex];\n        }\n        col = illuminate(toLight, toEye, normal, light.color, boardMat);\n        reflectiveness = boardMat.reflectiveness;\n    }\n    else if (s.id < 2.)\n    {\n        // white chess piece\n        col = illuminate(toLight, toEye, normal, light.color, materials[CHESS_WHITE]);\n        reflectiveness = materials[CHESS_WHITE].reflectiveness;\n    }\n    else if (s.id < 3.)\n    {\n        // black chess piece\n        col = illuminate(toLight, toEye, normal, light.color, materials[CHESS_BLACK]);\n        reflectiveness = materials[CHESS_BLACK].reflectiveness;\n    }\n    return col;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const Light lights[] = Light[](\n    Light(vec3(0.95, 0.85, 0.95), vec3(9.,  40., 0. )),\n    Light(vec3(0.85, 0.95, 0.85), vec3(-9., 40., 0. )),\n    Light(vec3(0.2,  0.2,  0.9 ), vec3(0.,  8., -6.)),\n    Light(vec3(0.7,  0.7,  0.2 ), vec3(0.,  8., 6. ))\n);\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    float t;\n    RMResult s = raymarch(iTime, ro, rd, t);\n    vec3 p = ro + t * rd;\n    vec3 normal = gradient(p, iTime);    \n\n    float reflectiveness;\n    vec3 sky = textureLod(iChannel0, rd, 0.).xyz;\n    vec3 wood = getWoodColor(p, normal, iChannel1);\n    vec4 col;\n    col.xyz = getAmbiant(p, s, normal, wood, sky);\n    col.w = 0.;\n    if (s.id > 0.){\n        col.w = 1.;\n        col.xyz *= 0.3;\n        mat3 lightRot = rot(vec2(iTime, 0.));\n        // main lighting\n        for (uint i = 0u; i < uint(lights.length()); i++)\n        {\n            Light light = lights[i];\n            vec3 toLight = lightRot * light.pos - p;\n            vec3 toEye = -rd;\n            col.xyz += getColor(p, s, normal, toLight, toEye, light, wood, sky, reflectiveness);\n        }\n#ifdef REFLECTIONS\n        // reflection\n        vec3 refl = reflect(rd, normal);\n        float t2;\n        RMResult s2 = raymarch(iTime, p + EPS * normal, refl, t2);\n        vec3 p2 = p + EPS * normal + t2 * refl;\n        vec3 normal2 = gradient(p2, iTime);\n        sky = textureLod(iChannel0, refl, 0.).xyz;\n        wood = getWoodColor(p2, normal2, iChannel1);\n        float reflectiveness2;\n        vec3 colRefl = getAmbiant(p, s, normal2, wood, sky);\n        \n        for (uint i = 0u; i < uint(lights.length()); i++)\n        {\n            Light light = lights[i];\n            colRefl += getColor(p2, s2, normal2, lightRot * light.pos - p2, -refl, light, wood, sky, reflectiveness2);\n        }\n\n        col.xyz = mix(col.xyz, colRefl, reflectiveness);\n#endif\n        // Ambiant occlusion\n        float ao = mix(0., 1., clamp(0., 1., map(p + 0.05 * normal, iTime).dist / 0.05));\n        col *= ao;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R) / R.y;\n    vec3 ro, rd;\n    vec4 mouse = vec4(2. * M.xy / R - 1., M.zw);\n    getCamera(uv, mouse, iTime, ro, rd);\n    fragColor = render(ro, rd);\n}","name":"Buffer A","description":"","type":"buffer"}]}