{"ver":"0.1","info":{"id":"Xtjfzc","date":"1517411234","viewed":147,"name":"GPU raymarching demo","username":"verminator04","description":"Raymarching sample code","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int renderDepth = 400;\n\nconst vec3 background = vec3(0.2, 0.2, 0.8);\nconst vec3 white = vec3(0.8, 0.8, 0.8);\nconst vec3 gray = vec3(0.3, 0.3, 0.3);\nconst vec3 black = vec3(0, 0, 0);\nconst vec3 red = vec3(0.8, 0.2, 0.2);\nconst vec3 green = vec3(0.2, 0.8, 0.2);\nconst vec3 blue = vec3(0.2, 0.2, 0.8);\nconst vec3 lightPos = vec3(0, 10, 10);\n\nconst int KEY_r = 82;\n\n\n////////////////////////////////////////////////////////////////////////////////////////\n// Forward declaration of the method where all the actual scene design happens\n// This is the method where all the fun happens\n\nfloat getSdf(vec3 p);\n\n////////////////////////////////////////////////////////////////////////////////////////\n// Camera config\n\nvec3 getRayDir(vec3 camDir, vec2 fragCoord) {\n    vec3 yAxis = vec3(0, 1, 0);\n    vec3 xAxis = normalize(cross(camDir, yAxis));\n    yAxis = normalize(cross(xAxis, camDir));\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = 2.0 * q - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    return normalize(p.x * xAxis + p.y * yAxis + 5.0 * camDir);\n}\n\nvec3 loadCameraPos() {\n    // Read camera state in polar coordinates from iChannel0\n    // State is stored at (0,0) in the iChannel0 texture, as [azimuthAngle, polarAngle, radius]\n    vec3 camState = texelFetch(iChannel0, ivec2(0.0, 0.0), 0).xyz;\n    return camState.z * normalize(vec3(\n        cos(camState.x) * cos(camState.y),\n        sin(camState.y),\n        sin(camState.x) * cos(camState.y)));\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// Signed distance field functions\n// With thanks to https://iquilezles.org/articles/distfunctions\n\n// Geometry functions\n\nfloat sphere(vec3 p) {\n    return length(p) - 1.0 /* radius */;\n}\n\nfloat cube(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0 /* radius */);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.1 /* soft edges */;\n}\n\nfloat torus(vec3 p) {\n    vec2 t = vec2(3.0 /* major radius */, 0.5 /* minor radius */); \n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, normalize(n.xyz)) + n.w;\n}\n\n// Mathematical operations\n\t\n// polynomial smooth min\n// From https://iquilezles.org/articles/smin\nfloat smin(float a, float b) {\n    float k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Rotation\nvec3 rotateXZ(vec3 p, float t) {\n    float c = cos(t);\n    float s = sin(t);\n    mat3  m = mat3(\n        c,0,-s,\n        0,1,0,\n        s,0,c);\n    return m * p;\n}\n\n// Repeat\nvec3 repeat(vec3 p) {\n    return vec3(mod(p.x + 2.0, 4.0) - 2.0, p.y, mod(p.z + 2.0, 4.0) - 2.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// Lighting and shading\n\nfloat weightNearZero(float f, float r) {\n    return max(r - abs(fract(f + r) - r), 0.0) / r;\n}\n\nvec3 getFloorColor(vec3 pt) {\n    float d = getSdf(pt);\n    float gridWeight = max(weightNearZero(pt.x, 0.025), weightNearZero(pt.z, 0.025));\n    float sdfIsocline = weightNearZero(d, 0.05);\n    float distanceTaper = smoothstep(1.0, 0.0, (d - 3.0) / 3.0);\n    float sdfWeight = distanceTaper * sdfIsocline;\n    \n    if (sdfWeight > gridWeight) {\n        return mix(white, blue, sdfWeight);\n    } else {\n        return mix(white, black, gridWeight);\n    }\n}\n\nfloat getSdfWithPlane(vec3 p) {\n    return min(getSdf(p), plane(p, vec4(0,1,0,1)));\n}\n\nfloat diffuse(vec3 point,vec3 normal) {\n    return clamp(dot(normal, normalize(lightPos - point)), 0.0, 1.0);\n}\n\nfloat specular(vec3 point,vec3 normal, vec3 e) {\n    return pow(clamp(dot(e, reflect(-normalize(lightPos - point), normal)), 0.0, 1.0), 4.0);\n}\n\nfloat getShadow(vec3 pt) {\n    vec3 lightDir = normalize(lightPos - pt);\n    float kd = 1.0;\n    int step = 0;\n    float t = 0.1;\n\n    for (int step = 0; step < renderDepth; step++) {\n        float d = getSdf(pt + t * lightDir);\n        if (d < 0.001) {\n            kd = 0.0;\n        } else {\n            kd = min(kd, 16.0 * d / t);\n        }\n        t += d;\n        if (t > length(lightPos - pt) || step >= renderDepth || kd < 0.001) {\n            break;\n        }\n    }\n    return kd;\n}\n\nvec3 getGradient(vec3 pt) {\n    return normalize(vec3(\n        getSdfWithPlane(vec3(pt.x + 0.0001, pt.y, pt.z)) - getSdfWithPlane(vec3(pt.x - 0.0001, pt.y, pt.z)),\n        getSdfWithPlane(vec3(pt.x, pt.y + 0.0001, pt.z)) - getSdfWithPlane(vec3(pt.x, pt.y - 0.0001, pt.z)),\n        getSdfWithPlane(vec3(pt.x, pt.y, pt.z + 0.0001)) - getSdfWithPlane(vec3(pt.x, pt.y, pt.z - 0.0001))));\n}\n\nvec3 illuminate(vec3 pt) {\n    vec3 color;\n\n    if (abs(pt.y + 1.0) < 0.001) {\n        color = getFloorColor(pt);\n    } else {\n        color = white;\n    }\n\tvec3 gradient = getGradient(pt);\n    float ambient = 0.25;\n    float diff = diffuse(pt, gradient);\n    float spec = specular(pt, gradient, normalize(loadCameraPos()));\n    float shadow = getShadow(pt);\n    return (ambient + (0.75 * diff + 0.25 * spec) * shadow) * color;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// Raymarch loop\n\nvec3 raymarch(vec3 rayorig, vec3 raydir) {\n\tbool showRenderDepth = (texelFetch(iChannel1, ivec2(KEY_r, 0.0), 0).x > 0.0);\n    vec3 pos = rayorig;\n    float d = getSdfWithPlane(pos);\n    int work = 0;\n    int step = 0;\n\n    for (; step < renderDepth; step++) {\n        work++;\n        pos = pos + raydir * d;\n        d = getSdfWithPlane(pos);\n        if (abs(d) < 0.001) {\n            break;\n        }\n    }\n\n    return showRenderDepth\n        ? vec3(float(renderDepth - work) / float(renderDepth))\n        : (step < renderDepth) ? illuminate(pos) : background;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// Scene description\n//\n// EXPERIMENT FREELY HERE\n\nfloat getSdf(vec3 p) {\n//    float t = sin(iTime);\n//    t = t * length(p) / 10.0;\n//    p = rotateXZ(p, t);\n//    p.x = mod(p.x + 2.0, 4.0) - 2.0;\n//    p.z = mod(p.z + 2.0, 4.0) - 2.0;\n    return sphere(p);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n// main() method\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 camPos = loadCameraPos();\n    vec3 camDir = normalize(-camPos);\n    vec3 rayDir = getRayDir(camDir, fragCoord);\n    fragColor = vec4(raymarch(camPos, rayDir), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file is the keyboard and mouse controls for the camera; there's no 3D here.\n// For 3D rendering, go to the 'Image' tab (above)\n//\n// Controls:\n//   Mouse controls camera\n//   Left, Right arrows pivot camera around origin\n//   Up, Down arrows raise and lower camera around origin\n//   Z, X keys dolly camera in and out towards origin\n//   Key 0: go to overhead view\n\n#define tex(aa, bb) (.x)\n#define MAX_POLAR_ANGLE (3.141592 / 2.0 - 0.05)\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP   \t= 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_Z\t\t= 90;\nconst int KEY_X\t\t= 88;\nconst int KEY_0\t\t= 48;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (fragCoord.x >= 2.0 || fragCoord.y >= 1.0) {\n        discard;\n    }\n\n    vec4 state = texelFetch(iChannel0, ivec2(0.0, 0.0), 0);\n    vec4 prevMouse = texelFetch(iChannel0, ivec2(1.0, 0.0), 0);\n    float azimuthAngle = state.x;\n    float polarAngle = state.y;\n    float radius = state.z;\n\n    if (radius < 0.001) {\n        radius = 20.0;\n    }\n    \n    azimuthAngle += texelFetch(iChannel1, ivec2(KEY_LEFT, 0.0), 0).x / 15.0;\n    azimuthAngle -= texelFetch(iChannel1, ivec2(KEY_RIGHT, 0.0), 0).x / 15.0;\n    polarAngle = clamp(polarAngle + texelFetch(iChannel1, ivec2(KEY_UP, 0.0), 0).x / 15.0, 0.0, MAX_POLAR_ANGLE);\n    polarAngle = clamp(polarAngle - texelFetch(iChannel1, ivec2(KEY_DOWN, 0.0), 0).x / 15.0, 0.0, MAX_POLAR_ANGLE);\n    radius = clamp(radius - texelFetch(iChannel1, ivec2(KEY_Z, 0.0), 0).x, 1.0, 60.0);\n    radius = clamp(radius + texelFetch(iChannel1, ivec2(KEY_X, 0.0), 0).x, 1.0, 60.0);\n    \n    if (texelFetch(iChannel1, ivec2(KEY_0, 0.0), 0).x > 0.0) {\n        azimuthAngle = 0.0;\n        polarAngle = MAX_POLAR_ANGLE;\n    }\n    \n    vec4 m = iMouse / iResolution.xxxx;\n    if (m.z > 0.0 && prevMouse.z > 0.0) {\n        azimuthAngle += (m.x - prevMouse.x) * 2.0;\n        polarAngle -= (m.y - prevMouse.y) * 2.0;\n        if (polarAngle < 0.05) { polarAngle = 0.05; }\n        if (polarAngle > MAX_POLAR_ANGLE) { polarAngle = MAX_POLAR_ANGLE; }\n    }\n\n    if (fragCoord.x < 1.0) {\n\t    fragColor = vec4(azimuthAngle, polarAngle, radius, 0.0);\n    } else {\n\t    fragColor = m;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}