{"ver":"0.1","info":{"id":"4fffW4","date":"1723774586","viewed":59,"name":"progressive unbiased pathtracing","username":"bitshifter","description":"another noobs work in progress","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pathtrace","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 hdrColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n  vec3 ldrColor = hdrColor / (hdrColor + vec3(1.0)); // Reinhard operation\n\n  vec3 gamColor = pow(ldrColor, vec3(1.0 / 2.2)); // gamma correction\n\n  fragColor = vec4(gamColor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Sphere {\n  float radius;\n  vec3 origin;\n  vec3 diffuse;\n  vec3 emission;\n} sphereX; // the null object (background)\n\nSphere sphere0 = Sphere(1.5,vec3(0.0,5.0,0.0),vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0)); // light\nSphere sphere1 = Sphere(100.0,vec3(0.0,-105.0,0.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0)); // floor\nSphere sphere2 = Sphere(100.0,vec3(0.0,105.0,0.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0)); // ceiling\nSphere sphere3 = Sphere(100.0,vec3(-105.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,0.0,0.0)); // left wall\nSphere sphere4 = Sphere(100.0,vec3(105.0,0.0,0.09),vec3(1.0,0.0,0.0),vec3(0.0,0.0,0.0)); // right wall\nSphere sphere5 = Sphere(100.0,vec3(0.0,0.0,-105.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0)); // near wall\nSphere sphere6 = Sphere(100.0,vec3(0.0,0.0,105.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0)); // far wall\nSphere sphere7 = Sphere(1.5,vec3(-2.5,-3.5,0.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0)); // left ball\nSphere sphere8 = Sphere(1.5,vec3(2.5,-3.5,0.0),vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0)); // right ball\n\nSphere info_sphere;\nfloat  info_dist;\n\nvoid intersectSphere (in vec3 rayOrg, in vec3 rayDir, in Sphere sphere)\n{\n  vec3 v = sphere.origin - rayOrg;\n  float b = dot(v,rayDir);\n  float d = b * b - dot(v,v) + sphere.radius * sphere.radius;\n  if (d < 0.0) return;\n  float root = sqrt(d);\n  float t = b - root; // tmin\n//if (t < 0.0) t = b + root; // tmax\n  if ((t > 0.0) && (t < info_dist)) {\n    info_dist = t;\n    info_sphere = sphere;\n  }\n}\n\nvoid intersectScene (in vec3 rayOrg, in vec3 rayDir)\n{\n  info_sphere = sphereX;\n  info_dist = 1.0e+6;\n\n  intersectSphere(rayOrg,rayDir,sphere0);\n  intersectSphere(rayOrg,rayDir,sphere1);\n  intersectSphere(rayOrg,rayDir,sphere2);\n  intersectSphere(rayOrg,rayDir,sphere3);\n  intersectSphere(rayOrg,rayDir,sphere4);\n  intersectSphere(rayOrg,rayDir,sphere5);\n//intersectSphere(rayOrg,rayDir,sphere6);\n  intersectSphere(rayOrg,rayDir,sphere7);\n  intersectSphere(rayOrg,rayDir,sphere8);\n}\n\nuint rng_state;\n\nfloat randomFloat01()\n{ // 0 ... 1\n  uint w = ((rng_state >> ((rng_state >> 28u) + 4u)) ^ rng_state) * 277803737u;\n  rng_state = rng_state * 747796405u + 2891336453u; // advance state for next call\n  return float((w >> 22u) ^ w) / 4294967295.0;\n}\n\nvec3 rayFromPixel (in vec3 origin, in vec2 fragCoord)\n{\n  vec2 center = iResolution.xy * 0.5;\n\n  float angle = radians(90.0);\n  float focal = center.x / tan(angle * 0.5);\n\n  float jitterX = randomFloat01();\n  float jitterY = randomFloat01();\n\n  float projX = fragCoord.x - center.x - jitterX; // jitter integer border\n  float projY = fragCoord.y - center.y - jitterY; // from - 0.5 to + 0.5\n  float projZ = focal;\n  float projW = 1.0;\n\n  // lookAt\n  vec3 target = vec3(0.0, 0.0, 0.0);\n  vec3 updir = vec3(0.0, 1.0, 0.0);\n\n  vec3 axisZ = normalize(target - origin);\n  vec3 axisX = normalize(cross(updir,axisZ));\n  vec3 axisY = normalize(cross(axisZ,axisX));\n\n  vec3 point = axisX  * projX +\n               axisY  * projY +\n               axisZ  * projZ +\n               origin * projW;\n\n  return normalize(point - origin);\n}\n\nvec3 diffuseScatter (in vec3 normal)\n{\n  float pi = radians(180.0);\n  float a = randomFloat01() * 2.0 * pi;\n  float z = randomFloat01() * 2.0 - 1.0;\n  float r = sqrt(1.0 - z * z);\n  float x = cos(a) * r;\n  float y = sin(a) * r;\n  return normalize(normal + vec3(x,y,z));\n}\n\nvec3 colorPixel (in vec2 fragCoord)\n{\n  vec3 rayOrg = vec3(0.0, 0.0, 15.0); // world space\n  vec3 rayDir = rayFromPixel(rayOrg,fragCoord);\n\n  vec3 energy = vec3(1.0, 1.0, 1.0);\n  vec3 color = vec3(0.0, 0.0, 0.0);\n\n  while ((energy.r + energy.g + energy.b) != 0.0) // fragile\n  {\n    intersectScene(rayOrg,rayDir);\n\n    if (info_sphere == sphereX) {\n    //color += vec3(0.0, 0.0, 0.0) * energy;\n      break; // hit background\n    }\n\n    color += energy * info_sphere.emission;\n\n    if ((info_sphere.emission.r +\n         info_sphere.emission.g +\n         info_sphere.emission.b) != 0.0) {\n      break; // hit light source\n    }\n\n    vec3 point = rayOrg + rayDir * info_dist;\n    vec3 normal = normalize(point - info_sphere.origin);\n\n    vec3 refDir = diffuseScatter(normal);\n\n    energy *= info_sphere.diffuse * dot(refDir,normal);\n\n    rayOrg = point;\n    rayDir = refDir;\n  }\n\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float linear = iResolution.x * fragCoord.y + fragCoord.x;\n  rng_state = uint(linear * (iTime + 1.0)); // change state over time\n\n  vec3 oldColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  vec3 newColor = colorPixel(fragCoord);\n\n#if 0\n  float alpha = 1.0 / float(iFrame + 1);\n  vec3 mixColor = mix(oldColor, newColor, alpha));\n#else\n  float alpha = float(iFrame) / float(iFrame + 1);\n  vec3 mixColor = mix(newColor, oldColor, alpha);\n#endif\n\n  fragColor = vec4(mixColor, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}