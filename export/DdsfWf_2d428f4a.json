{"ver":"0.1","info":{"id":"DdsfWf","date":"1694710697","viewed":28,"name":"Shenanigans","username":"Wasserwecken","description":"...","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdffbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Eric Dolch, 2023\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this work in any\n// commercial product, website or project. You cannot\n// sell this work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 buf = texture(iChannel0, uv);\n\n    fragColor = vec4(pow(buf.xyz, vec3(0.45454545)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PIH 1.57079632679\n#define PI 3.14159265359\n#define PI2 6.28318530717\n#define RADPERDEG 0.017453292519\n#define DEGPERRAD 57.29577951308\n#define GOLDANGLE 2.39996322973\n#define INVALIDCOLOR vec3(1,0,1)\n\n#define VEC_X vec3(1,0,0)\n#define VEC_Y vec3(0,1,0)\n#define VEC_Z vec3(0,0,1)\n\n#define RAY_TOLERANCE 0.001\n#define RAY_MAXSTEPS 512\n#define RAY_MAXDISTANCE 128.0\n#define RAY_STARTBOOST 0.01\n#define RAY_NORMALLIFT 0.001\n\n#define NORMALSAMPLEDIST 0.002\n#define HEMI_SAMPLES 8.0\n#define WHITE_NOISE_SCALE 5461.5461;\n\n\n\n\n// ---------------------------------------------------------------------------\n// STRUCTURES\n// ---------------------------------------------------------------------------\nstruct Ray\n{\n\tvec3 pos;\n\tvec3 dir;\n};\n\nstruct Hit\n{\n    vec3 pos;\n    float dist;\n    float margin;\n    float material;\n    int steps;\n};\n\nstruct Material\n{\n    vec3 albedo;\n    float metallic;\n    float roughness;\n};\n\nstruct ShadeInfo\n{\n    float viewDot;\n    float isSpec;\n    vec3 colorDiff;\n    vec3 colorSpec;\n    mat3 spaceDiff;\n    mat3 spaceSpec;\n    float coneDiff;\n    float coneSpec;\n};\n\n\n\n\n// ---------------------------------------------------------------------------\n// RANDOM GENERATORS\n// https://www.shadertoy.com/view/4djSRW\n// ---------------------------------------------------------------------------\nfloat random(float p)\n{\n    p *= WHITE_NOISE_SCALE;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat random(vec2 p)\n{\n    p *= WHITE_NOISE_SCALE;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat random(vec3 p)\n{\n    p *= WHITE_NOISE_SCALE;\n\tp  = fract(p * .1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec2 randomVec2(float p)\n{\n    p *= WHITE_NOISE_SCALE;\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 randomVec2(vec2 p)\n{\n    p *= WHITE_NOISE_SCALE;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 randomVec2(vec3 p)\n{\n    p *= WHITE_NOISE_SCALE;\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yzx+33.33);\n    return fract((p.xx+p.yz)*p.zy);\n}\n\nvec3 randomVec3(float p)\n{\n    p *= WHITE_NOISE_SCALE;\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 randomVec3(vec2 p)\n{\n    p *= WHITE_NOISE_SCALE;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 randomVec3(vec3 p)\n{\n    p *= WHITE_NOISE_SCALE;\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz+33.33);\n    return fract((p.xxy + p.yxx)*p.zyx);\n}\n\n\n\n\n// ---------------------------------------------------------------------------\n// ROTATIONS and VECTORS\n// https://www.shadertoy.com/view/4djSRW\n// ---------------------------------------------------------------------------\n\n// Point distribution in a unit sphere based on a Vogel disk.\n// http://www.cedconsultingllc.com/uncategorized/distributing-points-on-a-sphere/\n// https://en.wikipedia.org/wiki/Golden_angle\n// -index: Id of the point to generate\n// -count: Number of total points on the spehre\n// -rotation: Rotates the whole sphere in radians around the z-axis\n// -angle: Between 0 and 2 Pi, limits distribution such that PI will be a hemiphere and 2 Pi the complete sphere\n// -returns: Unit vector within the limited sphere\nvec3 sampleVogelSphere(in float index, in float count, in float rotation, in float angle)\n{\n    float theta = index * GOLDANGLE + rotation;\n    float range = ((1.0 + index) * angle) / (count * PI) - 1.0;\n    float radius = sin(acos(range));\n    return vec3(cos(theta) * radius, sin(theta) * radius, -range);\n}\n\n// Gram Schmidt method for generating a rotation matrice.\n// https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n// -z: Direction to look at (expected to be normalized!)\n// -returns: A rotaion matrix to rotate vec3(0,0,1) to the desired direction\nmat3 lookAt(in vec3 z)\n{\n    vec3 a = abs(z.y) < 0.99 ? VEC_Y : VEC_X;\n    vec3 x = normalize(cross(z, a));\n    vec3 y = cross(x, z);\n    return mat3(x, y, z);\n}\n\n// Generates a rotation matrix from the given euler anlges\n// https://en.wikipedia.org/wiki/Euler_angles\n// -angles: Angles in radians\n// -returns: Rotation matrix ordered by YXZ\nmat3 rotate(in vec3 angles)\n{\n    vec3 s = sin(angles.yxz);\n    vec3 c = cos(angles.yxz);\n    return mat3(\n        vec3(c.x*c.z + s.x*s.y*s.z,  c.z*s.x*s.y - c.x*s.z,  c.y*s.x),\n        vec3(c.y*s.z              ,  c.y*c.z              ,  -s.y   ),\n        vec3(c.x*s.y*s.z - c.z*s.x,  c.x*c.z*s.y + s.x*s.z,  c.x*c.y)\n    );\n}\n\n// Creates rays by a defintion of camera-parameters.\n// Their origin is the position of the camera and pointing in the given direction, spread by the FOV.\n// -uv: 2D-coordinates of the canvas, expected to be normalized to 0-1\n// -pos: Position of the camera in the scene\n// -dir: Direction where the camera looks at\n// -fov: Field of view of the camera in degrees, defines the spread of the rays.\n// -returns: Structure of position and direction of a camera ray\nRay camera(in vec2 uv, in vec3 pos, in vec3 dir, in float fov)\n{\n    mat3 rot = lookAt(dir);\n    float stretch = tan((fov * RADPERDEG) / 2.0);\n    vec2 plane = (uv * 2.0 - 1.0) * stretch;\n    vec3 ray = normalize(vec3(plane.xy, 1.0));\n    dir = rot * ray;\n    return Ray(pos, dir);\n}\n\n// ---------------------------------------------------------------------------\n// SHADING and LIGHT\n// ---------------------------------------------------------------------------\n\n// Only a part of Schlicks aproximation and combined with roughness\n// https://www.desmos.com/calculator/hgxci9w0kl?lang=de\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\n// -nDotV: dot product of the normal and the view direction\n// -roughness: roughness of the surface\n// -returns: Specular probability between 0 = diffuse and 1 = specular\nfloat FresnelFactor(float nDotV, float roughness)\n{\n    float smth = (1.0 - roughness) * (1.0 - roughness);\n    return smth + smth * (1.0 - smth) * pow(1.0 - nDotV, 5.0);\n}\n\n// Caclulates common values for the surface shading that are independend of the incoming light\n// -material: material properties to work with\n// -normal: normal of the surface (normalized)\n// -viewDir: view direction (incoming)\n// result: Collection of variables for incoming light rays to combine and use\nShadeInfo shadePrepare( in Material material,\n                        in vec3 normal,\n                        in vec3 viewDir)\n{\n    float viewDot = dot(normal, -viewDir);\n    float fresnel = FresnelFactor(viewDot, material.roughness);\n    float isSpec = mix(fresnel, 1.0, material.metallic);\n    vec3 F0 = mix(vec3(1.0), material.albedo, material.metallic);\n    \n    vec3 colorDiff = material.albedo;\n    vec3 colorSpec = material.albedo * F0;\n    \n    mat3 spaceDiff = lookAt(normal);\n    mat3 spaceSpec = lookAt(reflect(viewDir, normal));\n    \n    float coneDiff = PI;\n    float coneSpec = PI * material.roughness * material.roughness;\n    \n    return ShadeInfo(viewDot,\n                     isSpec,\n                     colorDiff,\n                     colorSpec,\n                     spaceDiff,\n                     spaceSpec,\n                     coneDiff,\n                     coneSpec);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax(in float a, in float b, in float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat sdPlane(in vec3 point)\n{\n    return point.y;\n}\n\nfloat sdSphere(in vec3 point, in float radius)\n{\n  return length(point) - radius;\n}\n\nfloat sdBox(in vec3 point, in vec3 size)\n{\n  vec3 diff = abs(point) - size;\n  float dominant = min(max(diff.x, max(diff.y, diff.z)), 0.0);\n  return length(max(diff, 0.0)) + dominant;\n}\n\nfloat sdSphereGrid(in vec3 point)\n{\n    vec3 index = floor(point);\n    point = fract(point) - 0.5;\n    return sdSphere(point, 0.48 * random(index));\n}\n\nfloat sdCubeGrid(in vec3 point)\n{\n    vec3 index = floor(point);\n    mat3 turn = rotate(randomVec3(index) * iTime * 1.5);\n    point.xz = fract(point.xz);\n    point = turn * (point - 0.5);\n    return sdBox(point, vec3(0.2 * random(index)));\n}\n\nfloat sdTerrain(in vec3 point, in float rayLength)\n{\n    mat3 offset = rotate(vec3(iTime * 0.0, GOLDANGLE, 0.5));\n    float inflation = 0.1;\n    float smoothing = 0.3;\n    float amplitude = 1.0;\n    float dist = point.y;\n    \n    for (int i = 0; i < 16; i++ )\n    {\n        // No need for details if the point to too far away from the surface\n        if (dist > amplitude)\n            break;\n            \n        // evaluate new octave\n        float octave = sdSphereGrid(point) * amplitude;\n        float smoothAmpl = smoothing * amplitude;\n        float inflatAmpl = inflation * amplitude;\n\n        // Clamp the octave to the terrain (dist) with a margin (inflatAmpl)\n        octave = smax(octave, dist - inflatAmpl, smoothAmpl);\n        \n        // Merge the clamped octave with the current terrain as new terrain\n        dist = smin(octave, dist , smoothAmpl);\n\n        // prepare next octave, the offset breaks regularities\n        point = (offset * point) * 2.0;     \n        amplitude *= 0.5;\n    }\n   return dist;\n}\n\nvec2 mergeSDFs(vec2 currentDistMat, vec2 newDistMat)\n{\n    float isNew = step(newDistMat.x, currentDistMat.x);\n    return mix(currentDistMat, newDistMat, isNew);\n}\n\n// Define the scene to trace for. This will place / combine / repeat\n// SDF's to reassemble the overall structure.\n// -point: current position of a ray.\n// -returns: Closest distance to the scene (x) and the corresponding material Id (y)\nvec2 sceneDistance(in vec3 point, in float rayLength)\n{\n    // init return value\n    vec2 distMat = vec2(RAY_MAXDISTANCE, 0.0);\n    vec3 tempPos;\n\n    // build\n    distMat = mergeSDFs(distMat, vec2(sdPlane(point + vec3(0.0, -0.0, 0.0)), 2.5));\n    distMat = mergeSDFs(distMat, vec2(sdTerrain(point, rayLength), 0.5));\n    distMat = mergeSDFs(distMat, vec2(sdCubeGrid(point), 1.5));\n\n    // result\n    return distMat;\n}\n\n// Evaluates the normals at a given point in the scene.\n// This samples four nearby points averages their results.\n// https://iquilezles.org/articles/normalsSDF/\n// -point: position in the scene\n// returns: estimated normal at scene position\nvec3 sceneNormal(in vec3 point, in float rayLength)\n{\n    vec2 s = vec2(+1, -1);\n    return normalize(\n        s.xyy * sceneDistance(point + s.xyy * NORMALSAMPLEDIST, rayLength).x + \n        s.yyx * sceneDistance(point + s.yyx * NORMALSAMPLEDIST, rayLength).x + \n        s.yxy * sceneDistance(point + s.yxy * NORMALSAMPLEDIST, rayLength).x + \n        s.xxx * sceneDistance(point + s.xxx * NORMALSAMPLEDIST, rayLength).x\n    );\n}\n\nvec4 sampleChannelFbm(in vec2 point, in sampler2D channel, in int iterations)\n{\n    vec4 color = vec4(0);\n    float amplitude = 1.0;\n    float height;\n    for (int i = 0; i < iterations; i++)\n    {\n        color += texture(channel, point) * amplitude;\n        height += amplitude;\n        point *= 2.0;\n        amplitude *= 0.5;\n    }\n    return color / height;\n}\n\nMaterial sceneMaterial(in vec3 point, in vec3 normal, in float materialId)\n{\n    if (materialId < 1.0)\n    {\n        point.xz += point.y * 0.2;\n        vec3 albedo1 = pow(sampleChannelFbm(point.xz * 16.0, iChannel2, 3).xyz, vec3(2.0));\n        vec3 albedo2 = pow(sampleChannelFbm(point.xy * 0.25, iChannel1, 1).xyz, vec3(2.0));\n        vec3 albedo = mix(albedo2, albedo1, abs(dot(normal, VEC_Y)));\n        float roughness = clamp(albedo.x * 3.0, 0.2, 0.8);\n        return Material(albedo, 0.0, roughness);\n    }\n    else if (materialId < 2.0)\n    {\n        return Material(vec3(0.72, 0.45, 0.21), 1.0, 0.1);\n    }\n    else\n    {\n        return Material(vec3(0.05, 0.12, 0.12), 0.0, 0.01);\n    }\n}\n\n// Marching a single ray through the scene until it \"hits\" something.\n// A hit is considered if the current position of the ray gets very close\n// to any scene object, defined by the SDF's distance.\n// https://en.wikipedia.org/wiki/Ray_marching\n// -pos: start position of the ray\n// -dir: direction where to march\n// -returns: Summary of the hit\nHit rayMarch(in vec3 pos, in vec3 dir)\n{\n    // initialise the marching parameters (pos, dist, margin, material, steps)\n    Hit hit = Hit(pos + (dir * RAY_STARTBOOST), RAY_STARTBOOST, RAY_STARTBOOST, -1.0, 0);\n    \n    // Trace until\n    //   -the ray touches the surface\n    //   -the max distance is reached (ray goes out of the scene?)\n    //   -the step count limit is reached\n    while (hit.margin > RAY_TOLERANCE\n        && hit.dist < RAY_MAXDISTANCE\n        && hit.steps < RAY_MAXSTEPS)\n    {            \n        // get current distance and material\n        vec2 distMat = sceneDistance(hit.pos, hit.dist);\n\n        // update state\n        hit.steps += 1;\n        hit.margin = distMat.x;\n        hit.material = distMat.y;\n        hit.dist += hit.margin;\n        hit.pos += hit.margin * dir;\n    }\n    \n    // set final material\n    hit.material = hit.dist < RAY_MAXDISTANCE ? hit.material : -1.0;\n    hit.material = hit.steps < RAY_MAXSTEPS ? hit.material : -2.0;\n    return hit;\n}\n\n\n\n// Global illumination loop, that coordinates the trace\n// of consecutive rays known as \"bounces\".\n// -pos: start position of a ray (usually the camera position)\n// -dir: initial direction of a ray\n// -returns: Structure of number of steps, the position & the normal & the material at the hit.\nvec4 traceScene(in vec3 pos, in vec3 dir)\n{\n    Hit hit = rayMarch(pos, dir);\n    \n    if (hit.material < -1.0) // to many steps\n        return vec4(INVALIDCOLOR, -1.0);\n    if (hit.material < -0.0) // too far\n        return vec4(texture(iChannel0, dir).xyz, RAY_MAXDISTANCE);\n        \n    else\n    {\n        vec3 result = vec3(0.0);\n        vec3 normal = sceneNormal(hit.pos, hit.dist);\n        vec3 nextMarchPos = hit.pos + normal * RAY_NORMALLIFT;\n        float offset = random(normal + hit.pos) * PI2;\n        \n        Material material = sceneMaterial(hit.pos, normal, hit.material);\n        ShadeInfo info = shadePrepare(material, normal, dir);\n        \n        //return vec3(material.roughness);\n        \n        for (float s = 0.0; s < HEMI_SAMPLES; s++)\n        {\n            vec3 lightDir;\n            bool isDiffuse = random(offset + s) > info.isSpec;\n            \n            if (isDiffuse)\n                lightDir = info.spaceDiff * sampleVogelSphere(s, HEMI_SAMPLES, offset, info.coneDiff);\n            else\n            {\n                lightDir = info.spaceSpec * sampleVogelSphere(s, HEMI_SAMPLES, offset, info.coneSpec);\n                lightDir = dot(lightDir, normal) < 0.0 ? reflect(lightDir, normal) : lightDir;\n            }\n\n            Hit shadow = rayMarch(nextMarchPos, lightDir);\n            if (shadow.material < -1.0) // to many steps\n                result += INVALIDCOLOR;\n            if (shadow.material < 0.0) // no occlusion\n            {\n                float lightDot = dot(normal, lightDir);\n                vec3 lightColor = texture(iChannel0, lightDir).xyz;\n                vec3 surface = isDiffuse ? info.colorDiff * lightDot : info.colorSpec;\n                result += surface * lightColor;\n            }\n        }\n\n        return vec4(result / HEMI_SAMPLES, hit.dist);\n    }\n}\n\nbool isCache(in vec2 fragCoord, in float size)\n{\n    ivec2 pixel = ivec2(mod(fragCoord, size));\n    int id = int(mod(float(iFrame), size * size));\n    return (id != (pixel.x + (pixel.y * int(size))));\n}\n\n// Entry point of the fragment shader\n// Prepares the initial camera rays.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (isCache(fragCoord, 2.0))\n    {\n        fragColor = texture(iChannel3, uv);\n        return;\n    }\n\n    float r = random(PI) * iTime * 0.2;\n    vec3 camPos = vec3(0.0, 0.25, iTime*0.1) * 0.5;\n    vec3 camDir = normalize(vec3(1.0, -0.2, sin(iTime * 0.1)));\n    Ray ray = camera(uv, camPos, camDir, 60.0);\n    fragColor = vec4(traceScene(ray.pos, ray.dir));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// COPIED FROM https://www.shadertoy.com/view/tltGDM\n\n/*\nlicence.txt from Unity built-in shader source:\n\nCopyright (c) 2016 Unity Technologies\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\nOriginal code was translated and adapted for ShaderToy by P.Z.\n*/\n\nconst vec4 _LightColor0 = vec4(256.0);\nconst  float _Exposure = 1.0;\nconst vec3 _GroundColor = vec3(.369, .349, .341) * 0.2;\nconst float _SunSize = 0.2;\nconst float _SunSizeConvergence = 4.0;\nconst vec3 _SkyTint = vec3(0.5);\nconst float _AtmosphereThickness = 1.0; \n#define OUTER_RADIUS 1.025 \n#define kRAYLEIGH (mix(0.0, 0.0025, pow(_AtmosphereThickness,2.5))) \n#define kMIE 0.0010 \n#define kSUN_BRIGHTNESS 20.0 \n#define kMAX_SCATTER 50.0 \n#define MIE_G (-0.990) \n#define MIE_G2 0.9801 \n#define SKY_GROUND_THRESHOLD 0.02 \n#define SKYBOX_COLOR_IN_TARGET_COLOR_SPACE 0 \nconst vec3 ScatteringWavelength = vec3(.65, .57, .475);\nconst vec3 ScatteringWavelengthRange = vec3(.15, .15, .15);    \nconst float kOuterRadius = OUTER_RADIUS; \nconst float kOuterRadius2 = OUTER_RADIUS*OUTER_RADIUS;\nconst float kInnerRadius = 1.0;\nconst float kInnerRadius2 = 1.0;\nconst float kCameraHeight = 0.0001;\nconst float kHDSundiskIntensityFactor = 15.0;\nconst float kSunScale = 400.0 * kSUN_BRIGHTNESS;\nconst float kKmESun = kMIE * kSUN_BRIGHTNESS;\nconst float kKm4PI = kMIE * 4.0 * 3.14159265;\nconst float kScale = 1.0 / (OUTER_RADIUS - 1.0);\nconst float kScaleDepth = 0.25;\nconst float kScaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\nconst float kSamples = 2.0;\n\nfloat Scale(float inCos)\n{\n\tfloat x = 1.0 - inCos;\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nfloat SunAttenuation(vec3 lightPos, vec3 ray)\n{\n\tfloat EyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), _SunSizeConvergence);\t\t\n\tfloat temp = pow(1.0 + MIE_G2 - 2.0 * MIE_G * (-EyeCos), pow(_SunSize,0.65) * 10.);\n\treturn (1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + EyeCos * EyeCos) / max(temp,1.0e-4));\t\n}\n\nvec3 SunDirection(float time)\n{\n    //time = 10.0;\n    float sunSpeed = time * 0.05;\n    float sunAngle = mix(70.0, 290.0, sin(sunSpeed) * 0.5 + 0.5) * RADPERDEG;\n    float sunTilt = 30.0 * RADPERDEG;\n\treturn rotate(vec3(sunAngle, 0.0, sunTilt)) * vec3(0, -1, 0);\n}\n\nvec4 ProceduralSkybox(vec3 ro, vec3 rd)\n{\n    vec3 _WorldSpaceLightPos0 = SunDirection(iTime);\n    vec3 kSkyTintInGammaSpace = _SkyTint;\n    vec3 kScatteringWavelength = mix(ScatteringWavelength-ScatteringWavelengthRange,ScatteringWavelength+ScatteringWavelengthRange,vec3(1,1,1) - kSkyTintInGammaSpace);\n    vec3 kInvWavelength = 1.0 / (pow(kScatteringWavelength, vec3(4.0)));\n    float kKrESun = kRAYLEIGH * kSUN_BRIGHTNESS;\n    float kKr4PI = kRAYLEIGH * 4.0 * 3.14159265;\n    vec3 cameraPos = vec3(0,kInnerRadius + kCameraHeight,0);\n    vec3 eyeRay = rd;\n    float far = 0.0;\n    vec3 cIn, cOut;\n    if(eyeRay.y >= 0.0)\n    {\n        far = sqrt(kOuterRadius2 + kInnerRadius2 * eyeRay.y * eyeRay.y - kInnerRadius2) - kInnerRadius * eyeRay.y;\n        vec3 pos = cameraPos + far * eyeRay;\n        float height = kInnerRadius + kCameraHeight;\n        float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));\n        float startAngle = dot(eyeRay, cameraPos) / height;\n        float startOffset = depth*Scale(startAngle);\n        float sampleLength = far / kSamples;\n        float scaledLength = sampleLength * kScale;\n        vec3 sampleRay = eyeRay * sampleLength;\n        vec3 samplePoint = cameraPos + sampleRay * 0.5;\n        vec3 frontColor = vec3(0.0, 0.0, 0.0);\n        for (int i=0; i<2; i++)\n        {\n            float height = length(samplePoint);\n            float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));\n            float lightAngle = dot(normalize(_WorldSpaceLightPos0.xyz), samplePoint) / height;\n            float cameraAngle = dot(eyeRay, samplePoint) / height;\n            float scatter = (startOffset + depth*(Scale(lightAngle) - Scale(cameraAngle)));\n            vec3 attenuate = exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));\n            frontColor += attenuate * (depth * scaledLength);\n            samplePoint += sampleRay;\n        }\n        cIn = frontColor * (kInvWavelength * kKrESun);\n        cOut = frontColor * kKmESun;\n    }\n    else\n    {\n        far = (-kCameraHeight) / (min(-0.001, eyeRay.y));\n        vec3 pos = cameraPos + far * eyeRay;\n        float cameraScale = Scale(dot(-eyeRay, pos));\n        float lightScale = Scale(dot(normalize(_WorldSpaceLightPos0.xyz), pos));\n        float sampleLength = far / kSamples;\n        float scaledLength = sampleLength * kScale;\n        vec3 sampleRay = eyeRay * sampleLength;\n        vec3 samplePoint = cameraPos + sampleRay * 0.5;\n        vec3 frontColor = vec3(0.0, 0.0, 0.0);            \n        float height = length(samplePoint);\n        float d = exp(kScaleOverScaleDepth * (kInnerRadius - height));\n        float scatter = d*(lightScale + cameraScale) - exp((-kCameraHeight) * (1.0/kScaleDepth))*cameraScale;\n        vec3 attenuate = exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));\n        frontColor += attenuate * (d * scaledLength);\n        samplePoint += sampleRay;\n        cIn = frontColor * (kInvWavelength * kKrESun + kKmESun);\n        cOut = clamp(attenuate, 0.0, 1.0);\n    }\n    vec3 groundColor = _Exposure * (cIn + _GroundColor*_GroundColor * cOut);\n    vec3 skyColor = _Exposure * (cIn * (0.75 + 0.75 * dot(normalize(_WorldSpaceLightPos0.xyz), -eyeRay) * dot(normalize(_WorldSpaceLightPos0.xyz), -eyeRay))); \n    float lightColorIntensity = clamp(length(_LightColor0.xyz), 0.25, 1.0);\n    vec3 sunColor = kHDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * _LightColor0.xyz / lightColorIntensity;\t    \n    vec3 ray = -rd;\n    float y = ray.y / SKY_GROUND_THRESHOLD;\n    vec3 color = mix(skyColor, groundColor, clamp(y,0.0,1.0));\n    if(y < 0.0) color += sunColor * SunAttenuation(normalize(_WorldSpaceLightPos0.xyz), -ray);\n    return vec4(sqrt(color),1.0);      \n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sphere( vec3 p, vec3 c,float s )\n{\n\treturn length(p-c)-s;\n}\n\nfloat box (vec3 p, vec3 c, vec3 s)\n{\n\tfloat x = max(p.x - c.x - s.x, c.x - p.x - s.x);\n\tfloat y = max(p.y - c.y - s.y, c.y - p.y - s.y);   \n\tfloat z = max(p.z - c.z - s.z, c.z - p.z - s.z);\n\treturn max(max(x,y),z);\n}\n\nfloat map (vec3 p)\n{\n\tfloat a = box(p,vec3(0.0),vec3(1000));\n\tfloat b = sphere(p,vec3(0.0),300.0);\n\treturn max(-b,a);\n}\n\nvec4 raymarch (vec3 ro, vec3 rd)\n{\n\tfor (int i=0;i<16;i++)\n\t{\n\t\tfloat t = map(ro);\n\t\tif (t<0.001) return ProceduralSkybox(ro,rd);     \n\t\tro+=t*rd;\n\t}\n\treturn vec4(0,0,0,1);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n\tfragColor = raymarch(vec3(0),rayDir);\n}","name":"Cube A","description":"","type":"cubemap"}]}