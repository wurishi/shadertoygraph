{"ver":"0.1","info":{"id":"WtcGD7","date":"1576485366","viewed":199,"name":"Sake shader （blend color）","username":"ligaobo","description":"学习一下Pheema的颜色融合方法，同时对源代码做了一些修改和注释","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["blenddifferrentcolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ref: https://www.shadertoy.com/view/XtVfzd\n\nconst float eps = 1e-3;\nconst float pi = 3.1415926535;\nconst vec3 z_up = vec3(0.0, 0.0, 1.0);\n\nfloat rand(vec2 p) { \n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat mod2(float p, float a) {\n    return p - a * floor(p / a);\n}\n\nvec2 mod2(vec2 p, vec2 a) {\n    return vec2(mod2(p.x, a.x), mod2(p.y, a.y));\n}\n\nfloat sdf_circle(vec2 p, vec2 o, float r) {\n    return length(p - o) - r;\n}\n\nfloat sdf_ring(vec2 p, float r, float lineWidth) {\n    float outer = sdf_circle(p, vec2(0, 0), r + 0.5 * lineWidth);\n    float inner = sdf_circle(p, vec2(0, 0), r - 0.5 * lineWidth);\n    \n    return max(-inner, outer);\n}\n\nfloat sdf(vec2 p) {\n    return min(sdf_ring(p, 0.75, 0.175), sdf_ring(p, 0.35, 0.175));\n}\n\nfloat sake_displacement(vec2 p, vec2 p0) {\n    float dist = length(p - p0);\n    vec2 dir = normalize(p - p0);\n     \n    float k = 5.0;\n    float omega = 20.0;\n    float basewave = 0.5 * sin(k * dist - mod2(omega * iTime, 2.0 * pi)) + 0.5;\n    float k2 = 22.0;\n    float omega2 = 44.0;\n    float subwave = 0.5 * sin(k2 * dist - mod2(omega2 * iTime, 2.0 * pi)) + 0.5;\n    float k3 = 45.0;\n    float omega3 = 90.0;\n    float subwave2 = 0.5 * sin(k3 * dist - mod2(omega3 * iTime, 2.0 * pi)) + 0.5;\n    \n    basewave = 2.0 * pow(basewave, 4.0) + 0.3 * pow(subwave, 2.0) + 0.09 * subwave2;\n        \n    float amp = min(1.0 / sqrt(eps + dist), 1.0);\n    amp *= basewave;\n    \n    float outer_r = 0.82;\n    amp += 100.0 * step(outer_r, length(p)) * (length(p) - outer_r) * (length(p) - outer_r);\n    \n    amp = 1.0 - exp(-amp);\n    \n    amp *= step(length(p0), 0.85);\n    \n    return -0.1 * amp;\n}\n\nvec3 sake_normal(vec2 p, vec2 p0) {\n    float dfx = sake_displacement(p + vec2(1.0, 0.0) * eps, p0) - sake_displacement(p - vec2(1.0, 0.0) * eps, p0);\n    float dfy = sake_displacement(p + vec2(0.0, 1.0) * eps, p0) - sake_displacement(p - vec2(0.0, 1.0) * eps, p0);\n    return normalize(vec3(dfx, dfy, 2.0 * eps));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.xy;\n    vec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 displaced_pos = pos;\n    float sake_depth = 0.0;\n    vec3 normal;\n    {\n        vec2 mouse_pos = (2.0 * iMouse.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n        if (iMouse.x == 0.0 && iMouse.y == 0.0) {\n            mouse_pos = vec2(-0.5, -0.5) + 0.1 * vec2(2.0 * noise(iTime) - 1.0, 2.0 * noise(iTime + 11.52) - 1.0);\n        }\n\n        const float max_sake_depth = 0.4;\n        sake_depth = mod2(0.05 * iTime, max_sake_depth) * step(length(mouse_pos), 0.85);\n\n        normal = sake_normal(pos, mouse_pos);   \n        vec3 refract_dir = refract(-z_up, normal, 1.4);\n\n        vec2 displacement = refract_dir.xy / refract_dir.z * sake_depth;\n\n        displaced_pos += displacement;\n    }\n\n    vec3 ring_color = vec3(0.1, 0.1, 0.6);\n    vec3 ring_edge_color = vec3(0.3, 0.6, 0.9);\n    ring_color = mix(ring_edge_color, ring_color, smoothstep(-0.02, 0.02, -sdf(displaced_pos)));\n    \n    vec3 cup_color = vec3(0.98, 0.98, 0.98);  \n    vec3 color = mix(ring_color, cup_color, smoothstep(0.0, 0.02, sdf(displaced_pos)));\n    \n    //求取球形高度（将碗视为半球形）\n    float h = sqrt(max(0.0, 1.0 - dot(pos, pos)));\n    vec3 N = normalize(vec3(-pos, h));\n    color *= mix(0.8, 1.0, dot(N, vec3(0.0, 0.0, 1.0)));\n    \n    //清酒颜色\n    const float max_sake_h = 0.8;\n    float sake_h = h - (1.0 - max_sake_h);\n    color *= mix(vec3(1.0), vec3(0.8, 0.8, 0.0), 1.0 - exp(-0.3 * sake_h)); \n    \n    // reflection\n    vec3 light_dir = normalize(vec3(3.0, 2.0, 1.0));\n    vec3 ref_dir = reflect(-z_up, normal);\n    vec3 ref_color = 3.0 * vec3(1.0, 1.0, 1.0) * smoothstep(0.8, 0.9, dot(ref_dir, light_dir));\n    ref_color += 0.5 * noise(2.0 * ref_dir.xy);\n    ref_color *= 1.0 - exp(-2.0 * sake_depth);\n    \n    color += 1.0 * ref_color;\n    \n    //碗沿\n    color = mix(color, cup_color * 0.6, smoothstep(0.86, 0.87, length(pos)));\n    //“碗的厚度”\n    color = mix(color, cup_color * 0.1, smoothstep(0.91, 0.92, length(pos)));\n    //垂直点光源衰减近似模拟\n    color *= 1.0 - 0.5 * length(uv) * length(uv);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}