{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// 13 with 3 dice roll!\n\n// Running slow? Turn off roll, exclamation mark, or reduce DOF samples \n#define ENABLE_ROLL\t\t\t\t1\n#define ENABLE_EXCLAMATION_MARK\t1\n#define NUM_DOF_SAMPLES\t\t\t12\t\t// Was 24 - but that crashes some browsers!\n#define APERTURE_RADIUS\t\t\t0.05\t// Was 0.1\n\n#define INFINITY\t\t\t\t999999.9\n#define GROUND_UV_SIZE\t\t\t8.0\n#define DOT_SIZE\t\t\t\t0.15\n#define\tDOT_COLOUR\t\t\t\tvec3(0.1,0.1,0.2)\n#define DOT_NORMAL_DELTA\t\t0.5\n#define DICE_COLOUR\t\t\t\tvec3(0.9,0.9,0.8)\n#define LIGHT_POS\t\t\t\tvec3(-1.0,19.0,-2.0)\n#define SPECULAR_POWER\t\t\t16.0\n#define PI\t\t\t\t\t\t3.1415926535\n#define FLASH_BRIGHTNESS\t\t16.0\n#define FLASH_SPEED\t\t\t\t8.0\n#define WIN_COLOUR\t\t\t\tvec3(0.1,0.06,0.01)\n#define WIN_BORDER_COLOUR\t\tvec3(0.1,0.01,0.01)\n#define WIN_WIDTH\t\t\t\t0.12\n#define WIN_BORDER_WIDTH\t\t0.05\n#define OTT_COLOUR\t\t\t\tvec3(0.01,0.1,0.02)\n#define OTT_BORDER_COLOUR\t\tvec3(0.1,0.01,0.01)\n#define OTT_WIDTH\t\t\t\t0.12\n#define OTT_BORDER_WIDTH\t\t0.05\n#define SCORE_COLOUR\t\t\tvec3(0.06,0.01,0.1)\n#define SCORE_BORDER\t\t\t0.9\n#define GROUND_BRIGHTNESS\t\t0.20\n#define SPOTLIGHT_SIZE\t\t\t3.0\n#define SKY_COLOUR\t\t\t\tvec3(0.2,0.3,0.4)\n#define GAME_TIME\t\t\t\t40.0\t\t\t// One game every this number of seconds\n#define THROW_TIME\t\t\t\t6.0\t\t\t\t// Length of time for a dice throw\n#define INTRO_TIME\t\t\t\t10.0\t\t\t// Time for attract mode at the start\n#define OUTRO_START\t\t\t\t(INTRO_TIME + THROW_TIME * 3.0)\n#define OUTRO_TIME\t\t\t\t(GAME_TIME - OUTRO_START)\n\n// ================================================================================================\n\nfloat AbsMin(vec2 a) {return min(abs(a.x),abs(a.y));}\nfloat AbsMax(vec2 a) {return max(abs(a.x),abs(a.y));}\nfloat AbsMin(vec3 a) {return min(min(abs(a.x),abs(a.y)),abs(a.z));}\nfloat AbsMax(vec3 a) {return max(max(abs(a.x),abs(a.y)),abs(a.z));}\nfloat AbsMin(mat3 a) {return min(min(AbsMin(a[0]),AbsMin(a[1])),AbsMin(a[2]));}\nfloat AbsMax(mat3 a) {return max(max(AbsMax(a[0]),AbsMax(a[1])),AbsMax(a[2]));}\n\n// ================================================================================================\n\nvoid Rand(inout vec2 seed) {seed = fract(vec2(dot(vec3(seed,1.0),vec3(50.755634,40.415474,17.326130)),dot(vec3(seed,1.0),vec3(20.906185,28.452110,13.468413))));}\t// Chosen with love\nvec2 FRand(inout vec2 seed) {Rand(seed); return seed;}\nvec2 NRand(inout vec2 seed) {Rand(seed); return seed * 2.0 - 1.0;}\nvec3 VRand(inout vec2 seed) {Rand(seed); vec3 v; v.xy = seed; Rand(seed); v.z = seed.x; return normalize(v - 0.5);}\nvec4 QRand(inout vec2 seed) {Rand(seed); vec4 q; q.xy = seed; Rand(seed); q.zw = seed; return normalize(q - 0.5);}\n\n// ================================================================================================\n\nmat3 Transpose(mat3 m)\n{\n\tmat3 t;\n\n\tt[0] = vec3(m[0].x,m[1].x,m[2].x);\n\tt[1] = vec3(m[0].y,m[1].y,m[2].y);\n\tt[2] = vec3(m[0].z,m[1].z,m[2].z);\n\n\treturn t;\n}\n\nmat3 MatrixFromQuat(vec4 quat)\n{\n\tvec4 qx = 2.0 * quat * quat.x;\n\tvec4 qy = 2.0 * quat * quat.y;\n\tvec4 qz = 2.0 * quat * quat.z;\n\tvec4 qw = 2.0 * quat * quat.w;\n\n\tmat3 m = mat3(\n\t\t\t\tvec3(1.0 - (qy.y + qz.z), qx.y + qw.z, qx.z - qw.y),\n\t\t\t\tvec3(qx.y - qw.z, 1.0 - (qx.x + qz.z), qy.z + qw.x),\n\t\t\t\tvec3(qx.z + qw.y, qy.z - qw.x, 1.0 - (qx.x + qy.y)));\n\treturn m;\n}\n\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n\tfloat sa = sin(angle * 0.5);\n\tfloat ca = cos(angle * 0.5);\n\t\n\treturn vec4(axis * sa, ca);\n}\n\nvec4 GetQuatForDiceValueOnTop(int val)\n{\n\tif (val == 1) {return vec4(0.70710678,-0.70710678,0.0,0.0);}\n\tif (val == 2) {return vec4(0.0,0.0,1.0,0.0);}\n\tif (val == 3) {return vec4(-0.70710678,0.0,0.0,0.70710678);}\n\tif (val == 4) {return vec4(0.0,0.70710678,0.70710678,0.0);}\n\tif (val == 5) {return vec4(0.0,0.0,0.0,1.0);}\n\n\treturn vec4(0.70710678,0.70710678,0.0,0.0);\n}\n\nfloat GetDistanceSqFromLineSegmentToPoint(vec2 line1, vec2 line2, vec2 pt)\n{\n\tfloat dprod = dot(pt    - line1, line2 - line1);\n\tfloat len2  = dot(line2 - line1, line2 - line1);\n\n\tfloat t = clamp(dprod / len2, 0.0, 1.0);\n\t\n\tvec2 ip\t\t= line1 + (line2 - line1) * t;\n\tvec2 delta\t= pt - ip;\n\n\treturn dot(delta,delta);\n}\n\n\n\n#define CHECK_POINT(a)\t\t\t\t\t{vec2 near = pt - a; min_dist_sq = min(min_dist_sq, dot(near,near));}\n#define CHECK_LINE(a,b)\t\t\t\t\t{min_dist_sq = min(min_dist_sq, GetDistanceSqFromLineSegmentToPoint(a, b, pt));}\n#define CHECK_CIRCLE(a,r)\t\t\t\t{float d = length(pt - a) - r; min_dist_sq = min(min_dist_sq, d*d);}\n#define CHECK_SEMICIRCLE(a,r,s)\t\t\t{vec2 near = pt - a; float behind = dot(near, s); if (behind < 0.0) {near -= behind * s;}; near = a + normalize(near) * r; float d = dot(pt - near, pt - near); min_dist_sq = min(min_dist_sq, d);}\n#define BEND(p) {p.x -= 0.5; p.y += p.x*p.x*0.2; p.x *= 1.0-p.y*0.15;p.x += 2.0; }\n\nvec3 IntersectOneTwoThree(vec2 pt, ivec4 flash_mode)\n{\n\tpt += vec2(-2.0,-1.0);\n\t\n\tBEND(pt);\n\n\tif (pt.x < 0.0 || pt.x > 4.0 || pt.y < -2.0 || pt.y > 1.5)\n\t{\n\t\treturn vec3(0,0,0);\n\t}\n\n\tfloat min_dist_sq = INFINITY;\n\n\tif (pt.x < 1.8)\n\t{\n\t\tCHECK_SEMICIRCLE(vec2(1.0707, -0.0707), 0.4, vec2(0.7071,0.7071));\n\t\tCHECK_LINE(vec2(1.353553, -0.353553), vec2(0.453553, -1.253553));\n\t\tCHECK_LINE(vec2(0.453553, -1.253553), vec2(1.5, -1.353553));\n\t}\n\telse\n\t{\n\t\tCHECK_LINE(vec2(2.1, 0.4), vec2(2.15,-1.0));\n\t\tCHECK_LINE(vec2(2.75, 1.0), vec2(3.3,1.0));\n\t\tCHECK_LINE(vec2(3.3,1.0), vec2(2.75,0.25));\n\t\tCHECK_SEMICIRCLE(vec2(2.75,-0.5), 0.75, vec2(1.0,0.0));\n\t}\n\n\tvec3 colour = vec3(0,0,0);\n\n\tif (min_dist_sq < (OTT_WIDTH + OTT_BORDER_WIDTH) * (OTT_WIDTH + OTT_BORDER_WIDTH))\n\t{\n\t\tcolour = (min_dist_sq < OTT_WIDTH * OTT_WIDTH) ? OTT_COLOUR : OTT_BORDER_COLOUR;\n\n\t\tif (pt.x < 1.7)\n\t\t{\n\t\t\tif (flash_mode.w == 2)\n\t\t\t{\n\t\t\t\tcolour *= FLASH_BRIGHTNESS;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (flash_mode.w == 13)\n\t\t\t{\n\t\t\t\tcolour *= FLASH_BRIGHTNESS;\n\t\t\t}\n\t\t\telse\n\t\t\tif (flash_mode.w == 1)\n\t\t\t{\n\t\t\t\tif (pt.x < 2.4)\n\t\t\t\t{\n\t\t\t\t\tcolour *= FLASH_BRIGHTNESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\tif (flash_mode.w == 3)\n\t\t\t{\n\t\t\t\tif (pt.x > 2.4)\n\t\t\t\t{\n\t\t\t\t\tcolour *= FLASH_BRIGHTNESS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn colour;\n}\n\n#if ENABLE_ROLL\n\nvec3 IntersectRoll(vec2 pt, ivec4 flash_mode)\n{\n\tpt += vec2(-2.5,-2.5);\n\t\n\tBEND(pt);\n\t\n\tif (pt.x < 0.0 || pt.x > 3.5 || pt.y < -0.2 || pt.y > 1.7)\n\t{\n\t\treturn vec3(0,0,0);\n\t}\n\t\n\tfloat min_dist_sq = INFINITY;\n\n\tif (pt.x < 2.4)\n\t{\n\t\tCHECK_LINE(vec2(0.2, 1.0), vec2(0.2,0.0));\n\t\tCHECK_CIRCLE(vec2(1.7, 0.5), 0.5);\n\t\tpt.y += (0.7 - pt.x)*(0.7 - pt.x) * 2.0;\n\t\tCHECK_LINE(vec2(0.2, 0.95), vec2(0.8,0.95));\t\n\t}\n\telse\n\t{\n\t\tCHECK_LINE(vec2(2.7, 1.5), vec2(2.7,0.0));\n\t\tCHECK_LINE(vec2(3.2, 1.5), vec2(3.2,0.0));\n\t}\n\t\n\tvec3 colour = vec3(0,0,0);\n\n\tif (min_dist_sq < (WIN_WIDTH + WIN_BORDER_WIDTH) * (WIN_WIDTH + WIN_BORDER_WIDTH))\n\t{\n\t\tcolour = (min_dist_sq < WIN_WIDTH * WIN_WIDTH) ? WIN_COLOUR : WIN_BORDER_COLOUR;\n\n\t\tfloat fx = float(flash_mode.z);\n\t\t\n\t\tfloat flash_x = dot(vec4(-0.14167, 1.7875, -0.7333, 0.0875), vec4(fx, fx*fx, fx*fx*fx, fx*fx*fx*fx));\n\n\t\tif (pt.x < flash_x)\n\t\t{\n\t\t\tcolour *= FLASH_BRIGHTNESS;\n\t\t}\n\t}\n\n\treturn colour;\n}\n\n#endif\n\nvec3 IntersectWin(vec2 pt, ivec4 flash_mode)\n{\n\tpt *= 1.1;\n\tpt.x += 10.0;\n\t\n\tif (pt.x < 0.0)\n\t{\n\t\treturn vec3(0,0,0);\n\t}\n\t\n\tpt.y += pt.x - pt.x*pt.x * 0.05;\n\tpt.y *= 0.6 + pt.x * 0.24 - pt.x*pt.x*0.014;\n\t\n\tif (pt.x > 17.5 || pt.y < -0.6 || pt.y > 1.5)\n\t{\n\t\treturn vec3(0,0,0);\n\t}\n\n\tfloat min_dist_sq = INFINITY;\n\n\tpt.x -= pt.y * pt.y * clamp(pt.x - 14.0, -1.0, 1.0) * -0.3;\n\n\tif (pt.x > 12.8)\n\t{\n\t\tCHECK_LINE(vec2(13.0,1.0), vec2(13.6,0.0));\n\t\tCHECK_LINE(vec2(13.6,0.0), vec2(14.0,0.6));\n\t\tCHECK_LINE(vec2(14.0,0.6), vec2(14.4,0.0));\n\t\tCHECK_LINE(vec2(14.4,0.0), vec2(15.0,1.0));\n\t\n\t\tCHECK_LINE(vec2(15.35,0.7), vec2(15.35,0.0));\n\t\n\t\tCHECK_LINE(vec2(15.8,0.75), vec2(15.8,0.0));\n\t\tCHECK_LINE(vec2(15.8,0.75), vec2(16.5,0.0));\n\t\tCHECK_LINE(vec2(16.7,0.85), vec2(16.5,0.0));\n\t\n\t\t#if ENABLE_EXCLAMATION_MARK\n\t\t{\n\t\t\tCHECK_LINE(vec2(17.1,0.9), vec2(17.0, 0.3));\n\t\t\tCHECK_POINT(vec2(17.0,0.0));\n\t\t}\n\t\t#endif\n\t}\n\n\tvec3 colour = vec3(0,0,0);\n\n\tif (min_dist_sq < (WIN_WIDTH + WIN_BORDER_WIDTH) * (WIN_WIDTH + WIN_BORDER_WIDTH))\n\t{\n\t\tcolour = (min_dist_sq < WIN_WIDTH * WIN_WIDTH) ? WIN_COLOUR : WIN_BORDER_COLOUR;\n\n\t\tfloat fx = float(flash_mode.x);\n\t\t\n\t\tfloat flash_x = dot(vec4(-1.00,6.35,-3.85,0.80), vec4(1, fx, fx*fx, fx*fx*fx));\n\n\t\tif (pt.x < flash_x + 13.0)\n\t\t{\n\t\t\tcolour *= FLASH_BRIGHTNESS;\n\t\t}\n\t}\n\n\tif (pt.y > 0.0 && pt.y < 0.8 && pt.x > 0.0 && pt.x < 12.9 - pt.y * 0.3 && fract(pt.x) < SCORE_BORDER)\n\t{\n\t\tcolour = SCORE_COLOUR;\n\n\t\tif (pt.x < float(flash_mode.y))\n\t\t{\n\t\t\tcolour *= FLASH_BRIGHTNESS;\n\t\t}\n\t}\n\n\treturn colour;\n}\n\nvec3 GetGroundColour(vec2 xz, ivec4 flash_state)\n{\n\tif (flash_state.y > 13)\n\t{\n\t\tflash_state.y = 26 - flash_state.y;\n\t}\n\t\n\tvec2\tground_uv\t\t= xz / GROUND_UV_SIZE;\n\tvec3\tground_colour\t= texture(iChannel0, ground_uv).rgb * GROUND_BRIGHTNESS;\n\tfloat\tlighting\t\t= smoothstep(0.0, 1.0, 1.0 - dot(ground_uv,ground_uv) / SPOTLIGHT_SIZE);\n\tvec3\twin\t\t\t\t= IntersectWin(xz, flash_state);\n\t#if ENABLE_ROLL\n\tvec3\troll\t\t\t= IntersectRoll(xz, flash_state);\n\t#else\n\tvec3\troll\t\t\t= vec3(0,0,0);\n\t#endif\n\tvec3\tonetwothree\t\t= IntersectOneTwoThree(xz, flash_state);\n\n\treturn ground_colour * lighting + win + roll + onetwothree;\n}\n\nvec3 GetSkyColour(float y)\n{\n\treturn SKY_COLOUR * y;\n}\n\nvec3 IntersectGroundSky(vec3 ray_pos, vec3 ray_dir, ivec4 flash_state)\n{\n\tif (ray_dir.y >= 0.0)\n\t{\n\t\treturn GetSkyColour(ray_dir.y);\n\t}\n\n\tvec3 ground_pos = ray_pos - ray_dir * ray_pos.y / ray_dir.y;\n\n\treturn GetGroundColour(ground_pos.xz, flash_state);\n}\n\n\nfloat IntersectUnitBox(vec3 ray_pos, vec3 ray_dir)\n{\n\tfloat ans = INFINITY;\n\t\n\t{ float t = (-1.0 - ray_pos.x) / ray_dir.x; if (t < ans) {vec3 ip = ray_pos + ray_dir * t; if (ip.y >= -1.0 && ip.z >= -1.0 && ip.y <= +1.0 && ip.z <= +1.0) {ans = t;}}}\n\t{ float t = (+1.0 - ray_pos.x) / ray_dir.x; if (t < ans) {vec3 ip = ray_pos + ray_dir * t; if (ip.y >= -1.0 && ip.z >= -1.0 && ip.y <= +1.0 && ip.z <= +1.0) {ans = t;}}}\n\t{ float t = (-1.0 - ray_pos.y) / ray_dir.y; if (t < ans) {vec3 ip = ray_pos + ray_dir * t; if (ip.x >= -1.0 && ip.z >= -1.0 && ip.x <= +1.0 && ip.z <= +1.0) {ans = t;}}}\n\t{ float t = (+1.0 - ray_pos.y) / ray_dir.y; if (t < ans) {vec3 ip = ray_pos + ray_dir * t; if (ip.x >= -1.0 && ip.z >= -1.0 && ip.x <= +1.0 && ip.z <= +1.0) {ans = t;}}}\n\t{ float t = (-1.0 - ray_pos.z) / ray_dir.z; if (t < ans) {vec3 ip = ray_pos + ray_dir * t; if (ip.x >= -1.0 && ip.y >= -1.0 && ip.x <= +1.0 && ip.y <= +1.0) {ans = t;}}}\n\t{ float t = (+1.0 - ray_pos.z) / ray_dir.z; if (t < ans) {vec3 ip = ray_pos + ray_dir * t; if (ip.x >= -1.0 && ip.y >= -1.0 && ip.x <= +1.0 && ip.y <= +1.0) {ans = t;}}}\n\t\n\treturn ans;\n}\n\n// Intersection with a unit rounded cube. x^4 + y^4 + z^4 == 1.0. Returns t or INFINITY\nfloat IntersectUnitDice(vec3 e, vec3 d)\n{\n\t// Approximate with unit box.\n\tfloat cur_t = IntersectUnitBox(e,d);\n\n\tif (cur_t == INFINITY)\n\t{\n\t\treturn INFINITY;\n\t}\n\n\tvec4 cubic_terms;\n\t\n\tcubic_terms.x =  4.0 * (d.x*d.x*d.x*d.x + d.y*d.y*d.y*d.y + d.z*d.z*d.z*d.z);\n\tcubic_terms.y = 12.0 * (d.x*d.x*d.x*e.x + d.y*d.y*d.y*e.y + d.z*d.z*d.z*e.z);\n\tcubic_terms.z = 12.0 * (d.x*d.x*e.x*e.x + d.y*d.y*e.y*e.y + d.z*d.z*e.z*e.z);\n\tcubic_terms.w =  4.0 * (d.x*e.x*e.x*e.x + d.y*e.y*e.y*e.y + d.z*e.z*e.z*e.z);\n\t\n\tvec3 cur_pos = e + cur_t * d;\n\tfloat  cur_ft  = dot(vec3(1.0,1.0,1.0), cur_pos * cur_pos * cur_pos * cur_pos);\n\tfloat  cur_out = abs(cur_ft - 1.0);\n\t\n\tconst int   MAX_ITERS   = 4;\n\tconst float NEAR_ENOUGH = 0.03;\n\t\n\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t{\n\t\tfloat cur_dt = dot(vec4(cur_t*cur_t*cur_t, cur_t*cur_t, cur_t, 1.0), cubic_terms);\n\t\t\n\t\tfloat next_t = cur_t + (1.0 - cur_ft) / cur_dt;\n\t\t\n\t\tvec3\tnext_pos = e + next_t * d;\n\t\tfloat\tnext_ft  = dot(vec3(1.0,1.0,1.0), next_pos * next_pos * next_pos * next_pos);\n\t\t\n\t\tfloat next_out = abs(next_ft - 1.0);\n\t\t\n\t\tcur_t   = next_t;\n\t\tcur_ft  = next_ft;\n\t\tcur_pos = next_pos;\n\t\tcur_out = next_out;\n\t}\n\n\tif (cur_out <= NEAR_ENOUGH)\n\t{\n\t\treturn cur_t;\n\t}\n\telse\n\t{\t\n\t\treturn INFINITY;\n\t}\n}\n\n\n// The dots of the dice... and tweaks the normals\n#define CHECK_DOT(x,y) {vec2 r = p - (vec2(x,y) * 2.2 * DOT_SIZE); if (dot(r,r) <= DOT_SIZE * DOT_SIZE) {dnorm = r; return DOT_COLOUR;}}\n\nvec3 DiceColour(vec2 p, int val, out vec2 dnorm)\n{\n\tdnorm = vec2(0,0);\n\n\tif (val == 1) {CHECK_DOT(0.0,0.0);}\n\tif (val == 2) {CHECK_DOT(-1.0,-1.0); CHECK_DOT(+1.0,+1.0);}\n\tif (val == 3) {CHECK_DOT(-1.0,-1.0); CHECK_DOT(0.0,0.0); CHECK_DOT(+1.0,+1.0);}\n\tif (val == 4) {CHECK_DOT(-1.0,-1.0); CHECK_DOT(-1.0,+1.0); CHECK_DOT(+1.0,-1.0); CHECK_DOT(+1.0,+1.0);}\n\tif (val == 5) {CHECK_DOT(-1.0,-1.0); CHECK_DOT(-1.0,+1.0); CHECK_DOT(+1.0,-1.0); CHECK_DOT(+1.0,+1.0); CHECK_DOT(0.0,0.0);}\n\tif (val == 6) {CHECK_DOT(-1.0,-1.0); CHECK_DOT(-1.0,+1.0); CHECK_DOT(0.0,-1.0); CHECK_DOT(0.0,+1.0); CHECK_DOT(+1.0,-1.0); CHECK_DOT(+1.0,+1.0);}\n\n\treturn DICE_COLOUR;\n}\n\nvoid GetDiceColourReflectionRay(in vec3 dice_pos, in mat3 dice_mat, in vec3 local_ipos, in vec3 ray_dir, out vec4 out_colour, out vec3 out_reflect_ray_pos, out vec3 out_reflect_ray_dir)\n{\n\t// Normal and colour including the dots.\n\tvec3 local_inorm\t= normalize(local_ipos * local_ipos * local_ipos);\n\tvec3 diffuse_colour\t= DICE_COLOUR;\n\t\n\t\t\tif (abs(local_inorm.x) > AbsMax(local_inorm.yz)) {vec2 dnorm; diffuse_colour = DiceColour(local_ipos.yz, (local_inorm.x) < 0.0 ? 1 : 6, dnorm); local_inorm -= DOT_NORMAL_DELTA * vec3(0.0, dnorm);}\n\telse\tif (abs(local_inorm.y) > AbsMax(local_inorm.zx)) {vec2 dnorm; diffuse_colour = DiceColour(local_ipos.zx, (local_inorm.y) < 0.0 ? 2 : 5, dnorm); local_inorm -= DOT_NORMAL_DELTA * vec3(dnorm.y, 0.0, dnorm.x);}\n\telse\tif (abs(local_inorm.z) > AbsMax(local_inorm.xy)) {vec2 dnorm; diffuse_colour = DiceColour(local_ipos.xy, (local_inorm.z) < 0.0 ? 3 : 4, dnorm); local_inorm -= DOT_NORMAL_DELTA * vec3(dnorm,0);}\n\t\n\t// Into world space.\n\tvec3 world_ipos\t\t= local_ipos * dice_mat + dice_pos;\n\tvec3 world_inorm\t= local_inorm * dice_mat;\n\tvec3 world_ireflect\t= reflect(ray_dir, world_inorm);\n\tvec3 world_to_light\t= normalize(LIGHT_POS - world_ipos);\n\t\n\tfloat diffuse\t= clamp(dot(world_to_light, world_inorm),-0.5, 1.0);\n\tfloat specular\t= clamp(dot(world_to_light, world_ireflect), 0.0, 1.0);\n\tfloat fres\t\t= 1.0 - max(dot(world_inorm , -ray_dir),0.0);\n\n\tdiffuse += 0.5;\n\tdiffuse *= 0.67;\n\tdiffuse *= diffuse;\n\t\n\tfres *= fres;\n\tspecular = pow(specular, SPECULAR_POWER);\n\n\tout_colour\t\t\t= vec4(diffuse_colour * diffuse + vec3(specular), fres);\n\tout_reflect_ray_pos\t= world_ipos;\n\tout_reflect_ray_dir = world_ireflect;\n}\n\nvoid GetDicePos(inout vec2 seed, float throw_time, int final_score, out vec3 out_dice_pos, out mat3 out_dice_mat)\n{\n\tvec2 dice_end_pos0 = NRand(seed) * 8.0 + vec2( 0.0,-4.0);\n\tvec2 dice_end_pos1 = NRand(seed) * 6.0 + vec2( 0.0,-2.0);\n\tvec2 dice_end_pos2 = NRand(seed) * 4.0 + vec2( 0.0, 0.0);\n\tvec2 dice_end_pos3 = NRand(seed) * 2.0 + vec2(-2.0, 0.0);\n\n\t// The rotations at the end of each bounce of the dice.\n\tvec4 dice_end_quat0 = QRand(seed);\n\tvec4 dice_end_quat1 = QRand(seed);\n\tvec4 dice_end_quat2 = QRand(seed);\n\tvec4 dice_end_quat3 = GetQuatForDiceValueOnTop(final_score);\n\n\t// And the axis of rotation of the spins for each bounce of the dice.\n\tvec3 dice_spin_axis0 = VRand(seed);\n\tvec3 dice_spin_axis1 = VRand(seed);\n\tvec3 dice_spin_axis2 = vec3(0.0, 1.0, 0.0);\n\n\t// How high each dice bounces.\n\tvec4 dice_heights = vec4(FRand(seed), FRand(seed)) * vec4(7.0, 6.0, 1.0, 0.0) + 2.0;\n\n\t// These are the control points of each bounce spline.\n\tvec3 dice_mid_pos0 = vec3(mix(dice_end_pos0, dice_end_pos1, 0.55), dice_heights.x).xzy; // .55 for a bit of air resistance!\n\tvec3 dice_mid_pos1 = vec3(mix(dice_end_pos1, dice_end_pos2, 0.55), dice_heights.y).xzy;\n\tvec3 dice_mid_pos2 = vec3(mix(dice_end_pos2, dice_end_pos3, 0.55), dice_heights.z).xzy;\n\n\t// Now we can work out the rough distance of each spline.\n\tvec3 dice_distances = vec3(\n\t\t\t\t2.0 * length(vec3(dice_end_pos0, 0).xzy - dice_mid_pos0),\n\t\t\t\t2.0 * length(vec3(dice_end_pos1, 0).xzy - dice_mid_pos1),\n\t\t\t\t2.0 * length(vec3(dice_end_pos2, 0).xzy - dice_mid_pos2));\n\n\t// And how long it takes for each dice to travel each spline.\n\tvec3 dice_timings = vec3(dice_distances) * vec3(0.05,0.06,0.07) + vec3(0.0, 0.0, 1.0);\n\n\t// So! Which bounce and how long into that bounce?\n\tfloat\tdice_bounce_t\t\t= 0.0;\t// 0 to 1 for bounces 0 to 2.\n\tfloat\tdice_spins\t\t\t= 0.0;\t// Multiple of 2pi. How many times the dice spins about its axis.\n\tfloat\tdice_s\t\t\t\t= 0.0;\n\tfloat\tdice_bobble\t\t\t= 0.0;\n\tvec3\tdice_spin_axis\t\t= vec3(0,0,0);\n\tvec3\tspline_cp_p0\t\t= vec3(0,0,0);\n\tvec3\tspline_cp_p1\t\t= vec3(0,0,0);\n\tvec3\tspline_cp_p2\t\t= vec3(0,0,0);\n\tvec4\tspline_cp_q0\t\t= vec4(0,0,0,1.0);\n\tvec4\tspline_cp_q1\t\t= vec4(0,0,0,1.0);\n\n\tif (throw_time < dice_timings.x)\n\t{\n\t\tdice_bounce_t\t\t= throw_time / dice_timings.x;\n\t\tdice_spins\t\t\t= ceil(dice_timings.x + 1.0) * (2.0 * PI);\n\t\tdice_s\t\t\t\t= dice_bounce_t;\n\t\tdice_spin_axis\t\t= dice_spin_axis0;\n\t\tspline_cp_p0\t\t= vec3(dice_end_pos0, 1.0).xzy;\n\t\tspline_cp_p1\t\t= dice_mid_pos0;\n\t\tspline_cp_p2\t\t= vec3(dice_end_pos1, 1.0).xzy;\n\t\tspline_cp_q0\t\t= dice_end_quat0;\n\t\tspline_cp_q1\t\t= dice_end_quat1;\n\t}\n\telse\n\tif (throw_time < dice_timings.x + dice_timings.y)\n\t{\n\t\tdice_bounce_t\t\t= (throw_time - dice_timings.x) / dice_timings.y;\n\t\tdice_spins\t\t\t= ceil(dice_timings.y + 1.0) * (2.0 * PI) * (seed.x < 0.5 ? -1.0 : 1.0);\n\t\tdice_s\t\t\t\t= dice_bounce_t;\n\t\tdice_spin_axis\t\t= dice_spin_axis1;\n\t\tspline_cp_p0\t\t= vec3(dice_end_pos1, 1.0).xzy;\n\t\tspline_cp_p1\t\t= dice_mid_pos1;\n\t\tspline_cp_p2\t\t= vec3(dice_end_pos2, 1.0).xzy;\n\t\tspline_cp_q0\t\t= dice_end_quat1;\n\t\tspline_cp_q1\t\t= dice_end_quat2;\n\t}\n\telse\n\t{\n\t\tdice_bounce_t\t\t= (throw_time - dice_timings.x - dice_timings.y) / dice_timings.z;\n\t\tdice_spins\t\t\t= (dice_timings.z + 3.5) * (2.0 * PI) * (seed.y < 0.5 ? -1.0 : 1.0);\n\t\tdice_s\t\t\t\t= clamp(dice_bounce_t * 0.6, 0.0, 1.0);\n\t\tdice_s\t\t\t\t= 2.0 * dice_s - dice_s*dice_s;\n\t\tdice_spin_axis\t\t= dice_spin_axis2;\n\t\tspline_cp_p0\t\t= vec3(dice_end_pos2, 1.0).xzy;\n\t\tspline_cp_p1\t\t= dice_mid_pos2;\n\t\tspline_cp_p2\t\t= vec3(dice_end_pos3, 1.0).xzy;\n\t\tspline_cp_q0\t\t= dice_end_quat2;\n\t\tspline_cp_q1\t\t= dice_end_quat3;\n\t\tdice_bobble\t\t\t= 1.0;\n\t}\n\t\n\t// Get the end points of the splines.\n\tfloat p = clamp(dice_bounce_t, 0.0, 1.0);\n\tfloat n = 1.0 - p;\n\n\tvec3 pos;\n\n\tpos  = spline_cp_p0 * n*n;\n\tpos += spline_cp_p1 * n*p * 2.0;\n\tpos += spline_cp_p2 * p*p;\n\n\tvec4 lerp_quat = normalize(spline_cp_q0 * n + spline_cp_q1 * p);\n\tvec4 spin_quat = QuatFromAxisAngle(dice_spin_axis, dice_s * dice_spins);\n\n\tout_dice_pos\t= pos;\n\tout_dice_mat\t= MatrixFromQuat(lerp_quat) * MatrixFromQuat(spin_quat);\n\t\n\tout_dice_pos.y += (1.0 - AbsMax(out_dice_mat)) * dice_bobble;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// How far into our current game?\n\tfloat the_time = iTime + 0.1;\n\tfloat game_number\t= floor(the_time / GAME_TIME);\n\tfloat game_time\t\t= fract(the_time / GAME_TIME) * GAME_TIME;\n\t\n\t// What time did we start playing?\n\tfloat start_time = iDate.w - iTime;\n\n\t// Set the seed for the game.\n\tvec2 seed = iDate.yz * vec2(0.001, 0.030) + cos((game_number + 1.0) * vec2(0.707106781,1.23456789));\n\n\tRand(seed);\n\tRand(seed);\n\n\t// Which dice scores are we going to get in this game?\n\tvec3 scores_throw;\n\t\n\tscores_throw.xy = floor(seed.xy * 6.0) + 1.0; Rand(seed);\n\tscores_throw.z\t= floor(seed.x  * 6.0) + 1.0; Rand(seed);\n\n\t//scores_throw = vec3(6.0,1.0,6.0); // To test winning\n\t\n\t// Camera stuff.\n\tvec3\tcam_pos\t\t= vec3(0.0, 7.0,-4.0);\n\tvec3\tcam_focus\t= vec3(0.0, 1.0, 0.0);\n\n\t// Game state.\n\tvec3\tdice_pos\t= vec3(-2.0, 1.0, 0.0);\n\tmat3\tdice_mat\t= mat3(1.0);\n\tivec4\tflash_state\t= ivec4(0,0,0,0);\n\n\t// Global fade.\n\tfloat\tvignette = 1.0;\n\n\t// Which mode are we in?\n\tint\t\tthrow_number\t= 0;\n\tfloat\tthrow_time\t\t= 0.0;\n\n\tif (game_time < INTRO_TIME)\n\t{\n\t\t// In intro - two camera pans.\n\t\tif (game_time < INTRO_TIME * 0.5)\n\t\t{\n\t\t\tcam_pos.x = game_time - INTRO_TIME + 4.0;\n\t\t\tcam_pos.y = 5.0;\n\t\t\tcam_pos.z = -6.0;\n\n\t\t\tfloat angle = clamp(game_time / (0.8 * INTRO_TIME * 0.5), 0.0, 1.0);\n\t\t\t\n\t\t\tflash_state.y = int(abs(sin(angle * (2.25 * PI))) * 19.0 * angle);\n\t\t\tflash_state.w = int(angle * 2.25) + 1;\n\t\t\t\n\t\t\tif (flash_state.y >= 13)\n\t\t\t{\n\t\t\t\tint flash = int(fract(iTime * FLASH_SPEED) * 2.0);\n\t\t\t\t\n\t\t\t\tflash_state.y = 13;\n\t\t\t\tflash_state.x = flash * 4;\n\t\t\t\tflash_state.z = flash * 4;\n\t\t\t\tflash_state.w = flash * 13;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcam_pos.x = 3.0;\n\t\t\tcam_pos.y = 3.0 - game_time * 0.12;\n\t\t\tcam_pos.z = -5.0 + game_time - INTRO_TIME * 0.5;\n\n\t\t\tint flash = int(fract(iTime * FLASH_SPEED) * 2.0);\n\t\t\t\n\t\t\tflash_state.y = flash * 13;\n\t\t\tflash_state.z = flash * 4;\n\t\t\tflash_state.x = flash * 4;\n\t\t\tflash_state.w = flash * 13;\n\t\t}\n\n\t\tvignette = INTRO_TIME - 0.5 - game_time;\n\t}\n\telse\n\tif (game_time >= OUTRO_START)\n\t{\n\t\t// In outro.\n\n\t\t// Set seed for this throw.\n\t\tseed += vec2(game_number, 2) * vec2(3.1415926535,2.71828128);\n\n\t\tRand(seed);\n\t\tRand(seed);\n\n\t\t// Where the dice finished the game.\n\t\tGetDicePos(seed, THROW_TIME, int(scores_throw.z), dice_pos, dice_mat);\n\n\t\t// Flash WIN?\n\t\tfloat total_score = dot(scores_throw, vec3(1.0));\n\t\t\n\t\tif (total_score == 13.0)\n\t\t{\n\t\t\t// Exciting camera pans!\n\t\t\tfloat pan_t = (game_time - OUTRO_START) / OUTRO_TIME;\n\n\t\t\tvec2 pan_seed = game_number * vec2(1.73205080,2.23606797);\n\t\t\tvec3 offset_a = VRand(pan_seed) * vec3(9.0,7.0,3.0);\n\t\t\tvec3 offset_b = VRand(pan_seed) * vec3(9.0,7.0,3.0);\n\n\t\t\tcam_pos += mix(offset_a,offset_b,pan_t);\n\t\t\t\n\t\t\t{\n\t\t\t\tfloat zoom_angle\t= pan_t * 12.0 * PI;\n\t\t\t\tfloat zoom\t\t\t= (1.0 - cos(zoom_angle)) * 0.2;\n\t\t\t\t\n\t\t\t\tcam_pos\t\t= mix(cam_pos, dice_pos, zoom);\n\t\t\t\tcam_focus\t= mix(cam_focus, dice_pos, zoom);\n\t\t\t}\n\n\t\t\t// Flash 13!\n\t\t\tint flash = int(fract(iTime * FLASH_SPEED) * 2.0);\n\t\t\n\t\t\tflash_state.x = 4 * flash;\n\t\t\tflash_state.z = 4 * flash;\n\t\t\tflash_state.w = 13 * flash;\n\t\t\t\n\t\t\tflash_state.y = int(fract(iTime) * 14.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Sad camera pan\n\t\t\tfloat r = (game_time - OUTRO_START) / OUTRO_TIME;\n\t\t\t\n\t\t\tr = smoothstep(0.0, 1.0, r * 0.5) * 2.0;\n\t\t\t\n\t\t\tcam_pos.y -= r * 6.0;\n\t\t\tcam_pos.x += r * 3.0;\n\t\t\t\n\t\t\tcam_focus\t= mix(cam_focus, dice_pos, r * 2.5);\n\t\t\tcam_pos\t\t= mix(cam_pos,   dice_pos, r * 0.6);\n\n\t\t\tflash_state.y = int(total_score);\n\t\t}\n\t\n\t\t// Fade out at end.\n\t\tvignette = (GAME_TIME - 1.0) * 0.25 - game_time * 0.25;\n\t}\n\telse\n\t{\n\t\t// Fade in quickly.\n\t\tvignette = (game_time - INTRO_TIME) * 10.0;\n\n\t\t// Main game. Which throw? And how long into the current throw?\n\t\tthrow_number\t= int(floor((game_time - INTRO_TIME) / THROW_TIME));\t// 0,1,2\n\t\tthrow_time\t\t= game_time - (INTRO_TIME + float(throw_number) * THROW_TIME);\n\n\t\t// Set seed for this throw.\n\t\tseed += vec2(game_number, throw_number) * vec2(3.1415926535,2.71828128);// + (start_time * 0.001 * iDate.zz);\n\t\t\n\t\tRand(seed);\n\t\tRand(seed);\n\n\t\t// Integer scores for this throw.\n\t\tint dice_score = int(throw_number == 0 ? scores_throw.x : (throw_number == 1 ? scores_throw.y : scores_throw.z));\n\n\t\tGetDicePos(seed, throw_time, dice_score, dice_pos, dice_mat);\n\n\t\tfloat score_to_display = 0.0;\n\n\t\tif (throw_number == 1)\n\t\t{\n\t\t\tscore_to_display = scores_throw.x;\n\t\t}\n\t\telse\n\t\tif (throw_number == 2)\n\t\t{\n\t\t\tscore_to_display = scores_throw.x + scores_throw.y;\n\t\t}\n\t\t\n\t\tif (throw_time > 3.0)\n\t\t{\n\t\t\tfloat max_score_to_display = max((throw_time - 3.0) * 10.0, 0.0) + score_to_display;\n\n\t\t\tscore_to_display += float(dice_score);\n\t\t\tscore_to_display = min(score_to_display, max_score_to_display);\n\t\t}\n\n\t\tflash_state.y = int(score_to_display);\n\t\tflash_state.z = int(clamp(throw_time * 15.0, 0.0, 4.0));\n\t\tflash_state.w = (flash_state.z == 4) ? (throw_number + 1) : 0;\n\n\t\tif (flash_state.y == 13 && dot((scores_throw),vec3(1.0)) == 13.0)\n\t\t{\n\t\t\t// Flash 13!\n\t\t\tint flash = int(fract(iTime * FLASH_SPEED) * 2.0);\n\t\t\n\t\t\tflash_state.x = 4 * flash;\n\t\t\tflash_state.w = int(fract(iTime) * 2.0) * 13;\n\t\t}\n\t}\n\n\tmat3\tdice_inv_mat = Transpose(dice_mat);\n\n\t// Find screen and ray.\n\tvec3\tcam_fwd\t\t= normalize(cam_focus - cam_pos);\n\tvec3\tcam_right\t= normalize(cross(vec3(0.0,1.0,0.0),cam_fwd));\n\tvec3\tcam_up\t\t= normalize(cross(cam_fwd,cam_right));\n\t\n\tvec2\tscreen_size\t= vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2\tscreen_pos\t= screen_size * (uv * 2.0 - 1.0);\n\n\tvec3\tcentre_ray_pos\t\t= cam_pos;\n\tvec3\tcentre_ray_target\t= cam_pos + cam_fwd + screen_pos.x * cam_right + screen_pos.y * cam_up;\n\tvec3\tcentre_ray_dir\t\t= normalize(centre_ray_target - centre_ray_pos);\n\n\t// Raytrace scene.\n\tvec3 ray_pos = centre_ray_pos;\n\tvec3 ray_dir = centre_ray_dir;\n\n\tvec3 ray_colour;\n\n\tvec3 dice_local_space_ray_pos = (ray_pos - dice_pos) * dice_inv_mat;\n\tvec3 dice_local_space_ray_dir = ray_dir * dice_inv_mat;\n\t\t\n\tfloat t_a = IntersectUnitDice(dice_local_space_ray_pos, dice_local_space_ray_dir);\n\n\tbool hit_dice_a = t_a < INFINITY;\n\n\tif (hit_dice_a)\n\t{\n\t\tvec4 dice_colour;\n\t\tvec3 reflect_ray_pos;\n\t\tvec3 reflect_ray_dir;\n\n\t\tGetDiceColourReflectionRay(\n\t\t\tdice_pos,\n\t\t\tdice_mat,\n\t\t\tdice_local_space_ray_pos + t_a * dice_local_space_ray_dir,\n\t\t\tray_dir,\n\t\t\tdice_colour,\t\t// out\n\t\t\treflect_ray_pos,\t// out\n\t\t\treflect_ray_dir);\t// out\n\n\t\t// Intersect ground with reflection ray... or other dice?\n\t\tvec3 reflected_ground_colour = IntersectGroundSky(reflect_ray_pos, reflect_ray_dir, flash_state);\n\n\t\tray_colour = dice_colour.rgb + dice_colour.a * reflected_ground_colour;\n\t}\n\telse\n\t{\n\t\tif (ray_dir.y >= -0.05)\n\t\t{\n\t\t\t// Just sky intersection.\n\t\t\tray_colour = GetSkyColour(ray_dir.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Ground.\n\t\t\tvec3 ground_pos = ray_pos - ray_dir * ray_pos.y / ray_dir.y;\n\n\t\t\tray_colour = GetGroundColour(ground_pos.xz, flash_state);\n\n\t\t\t// And reflection.\n\t\t\tvec3 reflect_ray_pos = ground_pos;\n\t\t\tvec3 reflect_ray_dir = ray_dir * vec3(1.0,-1.0,1.0);\n\n\t\t\tvec3 dice_local_space_reflect_ray_pos = (reflect_ray_pos - dice_pos) * dice_inv_mat;\n\t\t\tvec3 dice_local_space_reflect_ray_dir = reflect_ray_dir * dice_inv_mat;\n\n\t\t\tfloat t_a = IntersectUnitDice(dice_local_space_reflect_ray_pos, dice_local_space_reflect_ray_dir);\n\n\t\t\tbool hit_dice_a = t_a < INFINITY;\n\n\t\t\tif (hit_dice_a)\n\t\t\t{\n\t\t\t\tvec4 dice_colour;\n\t\t\t\tvec3 second_reflect_ray_pos;\n\t\t\t\tvec3 second_reflect_ray_dir;\n\n\t\t\t\tGetDiceColourReflectionRay(\n\t\t\t\t\tdice_pos,\n\t\t\t\t\tdice_mat,\n\t\t\t\t\tdice_local_space_reflect_ray_pos + t_a * dice_local_space_reflect_ray_dir,\n\t\t\t\t\treflect_ray_dir,\n\t\t\t\t\tdice_colour,\t\t\t\t// out\n\t\t\t\t\tsecond_reflect_ray_pos,\t\t// out\n\t\t\t\t\tsecond_reflect_ray_dir);\t// out\n\n\t\t\t\tray_colour += dice_colour.rgb * 0.25;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Depth of field!\n\t\t\t\tvec3 total_dof = ray_colour;\n\n\t\t\t\tfloat focal_plane\t\t= length(dice_pos - cam_pos);\n\t\t\t\tfloat aperture_radius\t= APERTURE_RADIUS;\n\n\t\t\t\tvec3 dof_target = centre_ray_pos + centre_ray_dir * focal_plane;\n\n\t\t\t\tfor (int dof_sample = 0; dof_sample < NUM_DOF_SAMPLES; dof_sample++)\n\t\t\t\t{\n\t\t\t\t\tfloat angle = float(dof_sample);\n\t\t\t\t\tfloat radius = angle * (1.0 / float(NUM_DOF_SAMPLES));\n\t\t\t\t\t\n\t\t\t\t\tvec2 dof_delta\t\t= vec2(sin(angle),cos(angle)) * radius;\n\t\t\t\t\tvec3 dof_ray_start\t= centre_ray_pos + cam_right * dof_delta.x * aperture_radius + cam_up * dof_delta.y * aperture_radius;\n\t\t\t\t\tvec3 dof_ray_dir\t= normalize(dof_target - dof_ray_start);\n\t\t\t\t\tvec3 dof_ground_pos = dof_ray_start - dof_ray_dir * dof_ray_start.y / dof_ray_dir.y;\n\t\t\t\t\tvec3 dof_colour\t\t= GetGroundColour(dof_ground_pos.xz, flash_state);\n\t\t\t\t\t\t\n\t\t\t\t\ttotal_dof += dof_colour;\n\t\t\t\t}\n\n\t\t\t\tray_colour = total_dof / float(NUM_DOF_SAMPLES + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply vignette.\n\tvec2  dmid\t= uv - vec2(0.5);\n\tfloat scale = clamp(vignette, 0.0, 1.0) - dot(dmid,dmid);\n\n\tfragColor = vec4(ray_colour * scale, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsB3zV","date":"1390916916","viewed":882,"name":"13","username":"mzadami","description":"Get 13 from 3 dice rolls to win.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["game","raytrace","physics","dice"],"hasliked":0,"parentid":"","parentname":""}}