{"ver":"0.1","info":{"id":"tsjyWD","date":"1586699343","viewed":146,"name":"inverting tiles","username":"julianlumia","description":"0kay now im done playing:)\nthe code is a complete hacked together mess but I like the look","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Tile Generator v2. (WIP)\" by julianlumia. https://shadertoy.com/view/Ws2cWD\n// 2020-04-12 13:26:43\n\n// Fork of \"Islamic Tile Generator (WIP)\" by julianlumia. https://shadertoy.com/view/tdScWD\n// 2020-04-12 08:06:23\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define S(a, b, t) smoothstep(a, b, t)\n\n// inigo quilez\nfloat sdTri(  vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \nvec2 centuv = uv;\n    \n    \n    \n    \n    \n    \n    float dp = dot(uv*4.,uv*2.)*.3;\n uv /= dp;\n uv.y=sin(uv-vec2(iTime*.5)).y;\n    uv *= .5;\n    \n vec3 col = vec3(0);\n float d = 10e6;\n float triA;\n \n    uv = fract(vec2(uv.x-0.0,uv.y-.5)) -.5;\n uv *= 1.;\n    vec2 cuv = uv;\n\n float wave =20.;\n float wavemultip = 0.05;//sin(iTime*0.5)*.2+0.2*.9;\n float offset = (sin(iTime*0.3)*2.)*0.03;\n vec2 uv2;\n vec2 objsize =vec2(abs(uv.x*1.)*.001+0.00001,5.);\n for(int i = 0; i <4; ++i)\n {\n  uv = vec2((uv)*rot(float(.25)*pi));\n  vec2 wpos = vec2(uv.x+sin(uv.y*wave)*wavemultip,uv.y)*1.;\n  triA = sdBox(wpos+offset, objsize);\n float   triB = sdBox(wpos-offset, objsize);\n triA = min(triB, triA);       \n float   triC = sdBox(vec2(uv.x+sin(uv.y*wave-pi)*wavemultip,uv.y)-offset, objsize);\n float   triD = sdBox(vec2(uv.x+sin(uv.y*wave-pi)*wavemultip,uv.y)+offset, objsize);\n triC = min(triC, triD);\n triA = min(triC, triA);\nif( triA < d)\n {\n  d = triA;\n  }\n } \n float c;   \n   // vec2 cuv = uv;\n    \nfloat tr6;    \nfloat tr5;    \n\n    \n  wave =25.;\n  wavemultip = 0.02;//sin(iTime*0.5)*.2+0.2*.9;\n  offset = (sin(iTime*0.6)*0.5)*0.06;\n  uv2;\n  objsize =vec2(abs(centuv.x*3.)*.01+0.009,1.);\n    for(int i = 0; i <5; ++i)\n {\n  centuv = vec2((centuv)*rot(float(.25)*pi));\n  vec2 wpos = vec2(centuv.x+sin(centuv.y*wave)*wavemultip,centuv.y)*1.;\n  tr6 = sdBox(wpos+offset, objsize);\n float   triB = sdBox(wpos-offset, objsize);\n tr6 = min(triB, tr6);       \n float   triC = sdBox(vec2(centuv.x+sin(centuv.y*wave-pi)*wavemultip,centuv.y)-offset, objsize);\n float   triD = sdBox(vec2(centuv.x+sin(centuv.y*wave-pi)*wavemultip,centuv.y)+offset, objsize);\n triC = min(triC, triD);\n tr6 = min(triC, tr6);\nif( tr6 < tr5)\n {\n  tr5 = tr6;\n  }\n } \n    \n    \n    \n    \n    \n    \n    \n    \ncuv*= .5;\n    cuv += vec2(0.0,0.);\n\ncuv = abs(cuv)-.2;\n    for(int i = 0; i <1; ++i)\n  {\ncuv += vec2(-0.);\n\n      cuv = vec2((cuv)*rot(float(.25)*pi));\n\ncuv = abs(cuv)-.1+(offset);\n     //   cuv = vec2((cuv)*rot(float(.05)*pi));\n      c = sdOctogon(vec2((cuv.x)+float(i)*.2,cuv.y+float(i)*.05),.16);\n      \n   float c2 = c +0.001;\n   c = max(c,-c2);\n if( c < d)\n  {\n   c = c;\n  }\n } \n float ca = sdOctogon(vec2((uv.x),uv.y),.36);\n    \n     float cat = sdCircle(vec2((centuv.x),centuv.y),.1);\n\n    cat *= .5;\n float c2a = ca -0.3;\n ca = max(ca,c2a);\n    ca += .0;\n// triA = min(triA,-ca);\n triA = min(triA,c);\n d = min(d, triA);\n  //  cat = min(-cat,tr5);\n       // cat = smin(cat,d,.5);\n\n    d = max(d, -cat);\n        cat = min(-cat,tr5);\n\n    d = max(-d, cat);\n\n//cat = max(cat,tr5);\n //       d = min(d, -cat);\n\n    col += smoothstep(0.01,.001/iResolution.y,-d);\n col += vec3(sin(cuv.y*1.*iTime)*.4,sin(cuv.y*.5*iTime),sin(cuv.y*0.06*iTime)+.0)*0.5;\n // col *= .6;\n       col*=1.3;\n col=smoothstep(0.0,2.,col);\n col=pow(col, vec3(0.4545));\n fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}