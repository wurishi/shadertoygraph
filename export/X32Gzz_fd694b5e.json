{"ver":"0.1","info":{"id":"X32Gzz","date":"1708127753","viewed":115,"name":"Analytic Motion Blur","username":"chronos","description":"Brute force numerical approximation on top.\nAnalytic Motion Blur on the bottom.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["simple","blur","line","motion","numerical","analytic","segment","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seg(vec2 a, vec2 b, vec2 p)\n{\n    p-=a; b-=a;\n    return length(b * clamp(dot(p,b)/dot(b,b), 0., 1.)-p);\n}\n\nfloat rampstep(float a, float b, float x)\n{\n    return clamp((x-a)/(b-a), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float ps = 2. / iResolution.y;\n    vec3 color = vec3(0);\n\n    if(length(iMouse.xy) < 10.) mouse = vec2(.1 + cos(iTime)*.3, 0); // idle animation\n    \n    float r = .25; // radius\n    \n    float speed = abs(mouse.x);// 0.5;\n    \n    vec2 p = vec2(0, -.5);\n    vec2 a = p - vec2(speed, 0); // start point\n    vec2 b = p + vec2(speed, 0); // end point\n\n    // Numerical integration loop on top\n    float steps = 100.;\n    for(float t = 0.; t < 1.; t+=1./steps)\n    {\n        vec2 q = vec2((b.x-a.x)*fract(t) + a.x, 0.5);// path from a to b\n        float d = length(uv - q) - r; // circle sdf\n        color += smoothstep(ps, -ps, d) / steps; // remember to normalize!\n    }\n    \n    float d = seg(a, b, uv)-r; // line segment sdf\n    \n    // Using pythagoras to get cross section of disc for a given offset from the axis of movement\n    float offcenter = sqrt(max(r*r - pow(p.y-uv.y, 2.), 0.));\n    float offcenter_decay = offcenter / r; // normalized to 0-1\n    \n    // In general, you have to project onto movement direction, but here it's just the x-axis\n    \n    // ramp up from      start.x - offcenter      to      start.x + offcenter\n    float rampup     = rampstep(a.x - offcenter, a.x + offcenter, uv.x);\n    \n    // ramp up from      end.x - offcenter      to      end.x + offcenter\n    float rampdown   = rampstep(b.x + offcenter, b.x - offcenter, uv.x);\n    \n    // notice that the r factor here can cancel with the 'offcenter_decay' denominator :)\n    float convolution = min(rampup, rampdown) * offcenter_decay * 2.*r/length(b-a); \n    \n    // Draw analytic motion blur of particle\n    color += convolution * smoothstep(ps, -ps, d);\n    \n    // Remember that you have to take the exposure time ( framerate ) into account for actual use cases.\n    \n    color = pow(color, vec3(1. / 2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}