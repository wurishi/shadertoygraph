{"ver":"0.1","info":{"id":"XfXyDH","date":"1721058554","viewed":32,"name":"Cool Patches","username":"NamespaceLynn","description":"Implementation of Ray Tracing Gems' Cool Patches\nIn the video presentation, the author describes that the code in the article is missing epsilons, but that those were added in the GitHub code... Well - I still can't find any :))","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","coolpatches","smoothsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Tracing Gems article: \n// https://research.nvidia.com/publication/2019-03_cool-patches-geometric-approach-raybilinear-patch-intersections\n\n// Video presentation:\n// https://developer.nvidia.com/siggraph/2019/video/sig931-vid\n\n// GitHub code from article:\n// https://github.com/Apress/ray-tracing-gems/tree/master/Ch_08_Cool_Patches_A_Geometric_Approach_to_Ray-Bilinear_Patch_Intersections\n\n#define infinity 1e38f\n\nfloat CopySign( float mag, float sgn )\n{\n    return abs( mag ) * sign( sgn );\n}\n\nmat2 Rot2D( float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    return mat2( c, -s, s, c );\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    float t;\n};\n\nRay MakeRay( vec3 origin, vec3 direction, float t )\n{\n    Ray r;\n    r.origin = origin;\n    r.direction = direction;\n    r.t = t;\n    return r;\n}\n\nstruct HitRecord\n{\n    bool hit;\n    vec3 color;\n    vec3 normal;\n    float dist;\n};\n\nstruct Patch\n{\n    vec3 uv00;                     // uv00----A----uv10\n    vec3 uv10;                     // |\t\t\t      |\n    vec3 uv01;                     // D\t\t\t      B\n    vec3 uv11;                     // |\t\t\t      |\n    vec3 quadrilateralPlaneNormal; // uv01----C----uv11\n};\n\nPatch MakePatch( vec3 uv00, vec3 uv10, vec3 uv01, vec3 uv11 )\n{\n    Patch p;\n    p.uv00 = uv00;\n    p.uv10 = uv10;\n    p.uv01 = uv01;\n    p.uv11 = uv11;\n    p.quadrilateralPlaneNormal = cross( p.uv10 - p.uv00, p.uv01 - p.uv11 );\n    return p;\n}\n\n// Find if the ray intersects the patch\nHitRecord IntersectPatch( Patch p, Ray r )\n{\n    HitRecord record;\n    record.hit = false;\n\n    // Calculate displacement vectors for 2 edges of the patch\n    vec3 bVec = p.uv11 - p.uv10; // uv10 to uv11\n    vec3 dVec = p.uv01 - p.uv00;; // uv00 to uv01\n\n    // Get direction vectors from the ray's origin to uv00 and uv10\n    vec3 originToUV00 = p.uv00 - r.origin;\n    vec3 originToUV10 = p.uv10 - r.origin;\n\n    // Solve for 'u'\n    // The formula is 'a + (b * u) + (c * u^2) = 0', which has 2 solutions\n    float u1;\n    float u2;\n\n    // First calculate 'a', 'b', and 'c'\n    float a = dot( cross( originToUV00, r.direction ), dVec );\n    float c = dot( p.quadrilateralPlaneNormal, r.direction );\n    float b = dot( cross( originToUV10, r.direction ), bVec ) - (a + c);\n\n    // Calculate the (squared) determinant to determine if there's an intersection\n    float sqrDeterminant = (b * b) - (4.0f * a * c);\n    if (sqrDeterminant < 0.0f)\n    {\n        // Return false if there's no intersections\n        return record;\n    }\n    // Calculate the determinant\n    float det = sqrt( sqrDeterminant ); // Ouch!\n\n    // If the length of 'quadrilateralPlaneNormal' (and therefore also 'c') is 0, the patch is a trapezoid\n    if (c == 0.0f)\n    {\n        // The formula is now 'a + (b * u) = 0', which only has 1 solution\n        // Set 'u1' equal to this solution\n        u1 = (-a / b);\n        // Set 'u2' to an invalid number outside of [0, 1]\n        u2 = -1.0f;\n    }\n    // If the patch is not a trapezoid\n    else\n    {\n        // Vieta's formula for the product of the roots tells us that 'u1 * u2 = a / c'\n        // We substitute either 'u1' or 'u2' for the stable root, to be able to compute the other\n        float stableRoot = (-b - CopySign( det, b )) / 2.0f;\n        u2 = (a / stableRoot);\n        u1 = (stableRoot / c);\n    }\n\n    // Calculate the final UVs (if an intersection is present)\n    vec2 uv;\n\n    // If 'u1' is within the valid range [0, 1]\n    if ((0.0f <= u1) && (u1 <= 1.0f))\n    {\n        // 'onEdgeA' and 'onEdgeC' (points) define a line segment\n        // 'onEdgeA = ((1 - u) * uv00) + (u * uv10)'\n        // 'onEdgeC = ((1 - u) * uv01) + (u * uv11)'\n        vec3 onEdgeA = mix( originToUV00, originToUV10, u1 ); // Point on edge A\n\n        // The displacement vector of the line defined by the two edge points on A and C can be calculated\n        // by interpolating between the line at 'u = 0' (dVec) and 'u = 1' (bVec), based on 'u'\n        // We call this vector 'uLineVec'\n        vec3 uLineVec = mix( dVec, bVec, u1 ); // Vector from 'onEdgeA' to 'onEdgeC'\n\n        // The intersection point has these 2 formulas:\n        // - 'origin + (t * direction)'\n        // - 'onEdge0 + v * (onEdge1 - onEdge0)'\n        // A third, more accurate, method is to calculate the vector orthogonal to both 'direction' and 'uLineVec'\n        vec3 orthogonal = cross( r.direction, uLineVec);\n\n        // The following is due to \"vector algebra optimizations\"\n        float d = dot( orthogonal, orthogonal );\n        orthogonal = cross( orthogonal, onEdgeA );\n\n        // Calculate the distance the ray has to travel to the intersection point\n        // And calculate 'v' (from the uv-coordinates)\n        float dist = dot( orthogonal, uLineVec ) / d;\n        float v = dot( orthogonal, r.direction );\n\n        // Check if the intersection point is within reach of the ray\n        // And if the intersection point is within the patch's bounds\n        bool inRange = (dist > 0.0f) && (dist <= r.t);\n        bool onPatch = (0.0f <= v) && (v <= d);\n\n        // If the intersection is valid\n        if (inRange && onPatch)\n        {\n            record.hit = true;\n\n            r.t = dist;\n\n            uv = vec2( u1, v / d );\n        }\n    }\n    // If 'u2' is within the valid range [0, 1]\n    if ((0.0f <= u2) && (u2 <= 1.0f))\n    {\n        // See comments from the code in the if-statement above\n\n        vec3 onEdgeA = mix( originToUV00, originToUV10, u2 );\n        vec3 uLineVec = mix( dVec, bVec, u2 );\n        vec3 orthogonal = cross( r.direction, uLineVec );\n        float d = dot( orthogonal, orthogonal );\n        orthogonal = cross( orthogonal, onEdgeA );\n\n        float dist = dot( orthogonal, uLineVec ) / d;\n        float v = dot( orthogonal, r.direction );\n        bool inRange = (dist > 0.0f) && (dist <= r.t);\n        bool onPatch = (0.0f <= v) && (v <= d);\n        if (inRange && onPatch)\n        {\n            record.hit = true;\n\n            r.t = dist;\n\n            uv = vec2( u2, v / d );\n        }\n    }\n\n    // Set necessary ray data when an intersection is found\n    if (record.hit)\n    {\n        // Set the normal vector\n        // Which is the vector orthogonal to both the vector (from uv00) to the 'u' and the vector to the 'v'\n        vec3 toU = mix( (p.uv10 - p.uv00), (p.uv11 - p.uv01), uv.y );\n        vec3 toV = mix( dVec, bVec, uv.x );\n        // Visualizing the normal shows that it is clearly wrong...\n        // However, this code is basically copied from my C++ renderer, so I am unsure why...\n        record.normal = normalize( cross( toU, toV ) );\n\n        // Uncomment for backface culling\n        //if (dot( record.normal, r.direction ) > 0.0f) { record.hit = false; return record; }\n        \n        // Color based on the UVs\n        record.color = vec3( uv, 0.0 );\n        \n        // Set the distance to the intersection\n        record.dist = r.t;\n    }\n\n    // Return true if an intersection was found\n    return record;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv [-1, 1]\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Patch\n    Patch p = MakePatch( vec3( -1.0, -1.0 + sin( iTime ) * 2.0, 1 ), vec3( -3.0 + sin( 0.333 * iTime ) * 0.5, -0.5, 1 ), vec3( -1, 0.5, -1 ), vec3( -2, -0.5, -1.0 + sin( 0.666 * iTime ) ) );\n    //Patch p = MakePatch( vec3( -1, 1, 1 ), \n    //                     vec3(  1, 1, 1 ), \n    //                     vec3( -1, 0, 1 ), \n    //                     vec3(  1, 0, 1 ) );\n    \n    // Primary ray\n    vec3 rayPos = vec3( 0, 0, -1 );\n    vec3 rayDir = vec3( normalize( vec3( uv * 0.75, 1 ) ) );\n    vec2 mousePos = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    mat2 horizontalRot = Rot2D( -mousePos.x );\n    mat2 verticalRot = Rot2D( -mousePos.y );\n    rayPos.yz *= verticalRot;\n    rayPos.xz *= horizontalRot;\n    rayDir.yz *= verticalRot;\n    rayDir.xz *= horizontalRot;\n    rayDir = normalize( rayDir );\n    Ray r = MakeRay( rayPos, rayDir, infinity );\n    \n    // Intersect the ray with the patch\n    HitRecord record = IntersectPatch( p, r );\n\n    // Output to screen\n    fragColor = vec4( record.hit ? record.color : texture( iChannel0, r.direction ).xyz, 1.0 );\n}","name":"Image","description":"","type":"image"}]}