{"ver":"0.1","info":{"id":"4cGcDm","date":"1731939169","viewed":796,"name":"[SESSIONS] Stairway to SESSIONS","username":"Kamoshika","description":"Code Graphics @ SESSIONS 2024 (Tokyo, Japan)\nhttps://sessions-party.com/\n\nThankfully, it won 3rd place out of 26 entries (including つぶやきGLSL, Classic GLSL and OpenProcessing)!","likes":64,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","globalillumination","pathtracing","stairs","stairway"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// If you don't hear the sound, please click on ⏸→⏮→▶.\n// 音が聞こえない場合、 ⏸→⏮→▶ を順にクリックしてください\n\n\n// 光源（球体）が動く速さをShadertoyのMusicに合うように変更済み\n// 元のコード original code:\n// https://twigl.app?ol=true&ss=-OByoIJjHjrBlwts2Y5p\n\n//#define DEBUG\n\n#ifdef DEBUG\n  #define AA 0\n#else\n//-----------------GPUの処理能力に応じて変更-------------------\n  #define AA 3\n//-----------------------------------------------------------\n#endif\n\n// 乱数\n#define hash(x) fract(sin(x) * 43758.5453123)\n\n// オブジェクトの種類\n#define SPHERE 0\n#define WALL 1\n#define STAIR_UP 2\n#define STAIR_SIDE 3\n\n// 文字のサイズ\n#define CHAR_SIZE ivec2(4, 8)\n\nconst float BPM = 114.; // 追加\n\nconst int maxDepth = 6;               // レイの経路の深さの最大値\nconst float PI = acos(-1.);           // 円周率\nconst float PI2 = PI * 2.;            // τ\nconst float EPS = 0.0001;             // パストレーシングなどに使う微小量\nconst float FAR = 1e3;                // 最大描画距離\nconst float stairWidth = 2.;          // 階段の横幅\nconst float tileGrooveWidth = 0.005;  // タイルの溝の幅\nconst float tileRaCurvature = 0.03;   // タイルの縁の曲率半径\nconst float lightSize = 0.4;          // 光源（球体）の半径\nconst vec3 lightColor = vec3(30.);    // 光源（球体）の発光色\nvec3 lightPos = vec3(0);              // 光源（球体）の中心の座標\nfloat pathSeed = 0.;                  // パストレーシングで使う乱数のシード\n\n// ピクセルフォント\n// 参考：美咲フォント \"misaki_gothic_2nd_4x8\"\n// https://littlelimit.net/misaki.htm\nconst uint ch_2 = 0x4A2448E0u;\nconst uint ch_0 = 0x4AAEAA40u;\n//const uint ch_4 = 0x26AAE220u;\nconst uint ch_4 = 0x26AAF220u;\nconst uint ch_C = 0x4A888A40u;\nconst uint ch_E = 0xE88C88E0u;\nconst uint ch_I = 0xE44444E0u;\nconst uint ch_L = 0x888888E0u;\nconst uint ch_M = 0xAEEEAAA0u;\nconst uint ch_N = 0xCAAAAAA0u;\nconst uint ch_O = 0x4AAAAA40u;\nconst uint ch_S = 0x4A842A40u;\nconst uint ch_T = 0xE4444440u;\nconst uint ch_W = 0xAAAEEEA0u;\n\n// nの各ビットを出力\nbool extract_bit(uint n, int b) {\n    return bool(1U & (n >> b));\n}\n\n// 単一の文字を出力\nbool sprite(uint spr, ivec2 I) {\n    int bit = (CHAR_SIZE.x - 1 - I.x) + I.y * CHAR_SIZE.x;\n    bool bounds = 0 <= I.x && I.x < CHAR_SIZE.x && 0 <= I.y && I.y < CHAR_SIZE.y;\n    return bounds && extract_bit(spr, bit);\n}\n\n// 1Dの乱数（シードを更新）\nfloat random() {\n    return hash(pathSeed++);\n}\n\n// 3Dの乱数\nfloat hash13(vec3 p) {\n    return hash(dot(p, vec3(127.1, 311.7, 74.7)));\n}\n\n// HSVからRGBへの変換\nvec3 hsv(float h, float s, float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.);\n    res = clamp(abs(res * 6. - 3.) - 1., 0., 1.);\n    res = (res - 1.) * s + 1.;\n    return res * v;\n}\n\n// 画面上の座標からレイの方向を算出\nvec3 rayDir(vec2 uv, inout vec3 dir, float fov) {\n    dir = normalize(dir);\n    vec3 u = abs(dir.y) < 0.999 ? vec3(0, 1, 0) : vec3(0, 0, 1);\n    vec3 side = normalize(cross(dir, u));\n    vec3 up = cross(side, dir);\n    return normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI));\n}\n\n// ベクトルvを回転軸axで角度aだけ回転\nvec3 rot3D(vec3 v, float a, vec3 ax) {\n    ax = normalize(ax);\n    return mix(dot(ax, v) * ax, v, cos(a)) - sin(a) * cross(ax, v);\n}\n\n// 被写界深度\nvoid dof(inout vec3 ro, inout vec3 rd, vec3 dir, float L, float factor) {\n    float r = sqrt(random());\n    float a = random() * PI2;\n    vec3 v = vec3(r * vec2(cos(a), sin(a)) * factor, 0);\n    vec3 diro = vec3(0, 0, -1);\n    float d = dot(dir, diro);\n    float va = acos(d);\n    vec3 vax = abs(d) < 0.999 ? cross(dir, diro) : dir.yzx;\n    v = rot3D(v, va, vax);\n    ro += v;\n    rd = normalize(rd * L - v);\n}\n\n// 物体の色を算出\nvec3 objColor(vec3 p, int type, bool isGroove, vec3 n) {\n    if(isGroove) {\n        return vec3(0.8);\n    }\n    \n    if(type == SPHERE) {\n        return vec3(0);\n    }\n    \n    vec3 ID = floor(p * float(CHAR_SIZE.y) + n * 0.5);\n    //float h = hash13(mod(ID, 1e3) + float(type) * 0.1328); // 長時間経過時の精度対策でmod()\n    float h = hash13(mod(ID, 5e2) + float(type) * 0.1328); // 長時間経過時の精度対策でmod()\n    if(ID.y + ID.z > h * 40. + 8.) {\n        return vec3(0.9, 0.7, 0.5);\n    }\n    \n    vec3 col = hsv(0.4 - h * 0.1, 0.9, 0.1 + h * 0.5);\n    if(type != STAIR_SIDE) {\n        return col;\n    }\n    \n    const uint[] str = uint[](ch_W, ch_E, ch_L, ch_C, ch_O, ch_M, ch_E, // len = 7\n                              ch_T, ch_O, // len = 2\n                              ch_S, ch_E, ch_S, ch_S, ch_I, ch_O, ch_N, ch_S, // len = 8\n                              ch_2, ch_0, ch_2, ch_4); // len = 4\n    const int numLine = 4;\n    const int[numLine] lenArr = int[](7, 2, 8, 4);\n    const int[numLine] posArr = int[](0, lenArr[0], lenArr[0] + lenArr[1], lenArr[0] + lenArr[1] + lenArr[2]);\n    \n    ivec2 I = ivec2(ID.x, mod(ID.y, float(CHAR_SIZE.y * (numLine + 1))));\n    \n    int line = numLine - I.y / CHAR_SIZE.y;\n    if(line == numLine) {\n        return col;\n    }\n    int len = lenArr[line];\n    I.x += len * CHAR_SIZE.x / 2 - 1;\n    int index = I.x / CHAR_SIZE.x;\n    if(index < 0 || index >= len) {\n        return col;\n    }\n    \n    I.y = I.y % CHAR_SIZE.y;\n    I.x -= index * CHAR_SIZE.x;\n    index += posArr[line];\n    \n    return sprite(str[index], I) ? vec3(0.9) : col;\n}\n\n// エミッションの色\nvec3 emission(int type) {\n    return type == SPHERE ? lightColor : vec3(0);\n}\n\n// 3次元空間上の点ceを通り、normalを法線ベクトルとする平面とレイの交差判定関数\n// （normalは正規化されていなくてもよい）\nfloat plaIntersect(vec3 ro, vec3 rd, vec3 ce, vec3 normal) {\n    float front1 = -dot(rd, normal);\n    vec3 oc = ro - ce;\n    float front2 = dot(oc, normal);\n    return front2 / front1;\n}\n\n// 3次元空間上の点ceを通り、normalを法線ベクトルとする平面とレイの交差判定関数\n// （normalは正規化されていなくてもよい）\nfloat plaIntersect2(vec3 ro, vec3 rd, vec3 ce, vec3 normal) {\n    float front1 = -dot(rd, normal);\n    vec3 oc = ro - ce;\n    float front2 = dot(oc, normal);\n    if(front1 <= 0. || front2 <= 0.) {\n        return -1.; // 平面の裏側が見えている場合、または平面がカメラの後方にある場合は負の値を返す\n    }\n    return front2 / front1;\n}\n\n// 球面とレイの交差判定関数\nfloat sphIntersect2(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float c = dot(oc, oc) - ra * ra;\n    if(c <= 0.) { // 球面の裏側は描画しない\n        return -1.;\n    }\n    float b = dot(oc, rd);\n    float h = b * b - c;\n    if(h < 0.) {\n        return -1.;\n    }\n    return -b - sqrt(h);\n}\n\n// カメラ（ro）から物体表面まで飛ばしたレイの長さ\nfloat castRay(vec3 ro, vec3 rd) {\n    float t = FAR;\n    \n    float w = 0.5 - step(0., rd.x);\n    float tWall = plaIntersect2(ro, rd, vec3(-w * 2. * stairWidth, 0, 0), vec3(w, 0, 0));\n    if(tWall > 0.) {\n        t = min(t, tWall);\n    }\n    \n    float tLight = sphIntersect2(ro, rd, lightPos, lightSize);\n    if(tLight > 0.) {\n        t = min(t, tLight);\n    }\n    \n    float tBound = 0.;\n    if(ro.y > -ro.z) {\n        vec2 rp = ro.yz + t * rd.yz;\n        if(rp.x > -rp.y) {\n            return t;\n        }\n        tBound = plaIntersect2(ro, rd, vec3(0), vec3(0, 1, 1));\n    }\n    \n    vec2 rp = ro.yz + tBound * rd.yz;\n    float i = floor((rp.x - rp.y) * 0.5);\n    vec3 ce = vec3(0, i, -1. - i);\n    float tStairUp = plaIntersect2(ro, rd, ce, vec3(0, 1, 0));\n    float tStairSide = plaIntersect2(ro, rd, ce, vec3(0, 0, 1));\n    float tStair = (tStairUp > 0. && tStairSide > 0.) ? min(tStairUp, tStairSide) : max(tStairUp, tStairSide);\n    \n    float temp = t;\n    if(tStair > 0.) {\n        t = min(t, tStair);\n    }\n    rp = ro.yz + t * rd.yz;\n    if(rp.x > -rp.y) {\n        return temp;\n    }\n    \n    return t;\n}\n\n// 被写界深度の焦点まで伸ばしたレイの長さ\nfloat focusIntersect(vec3 ro, vec3 rd) {\n    float t = FAR;\n    // ro.yとro.zがともに整数でDOF無しのとき、この関数内でplaIntersectの代わりにplaIntersect2を使うとなぜかバグる\n    // どうして？…Why?\n    float w = 0.5 - step(0., rd.x);\n    //float tWall = plaIntersect2(ro, rd, vec3(-w * 2. * stairWidth, 0, 0), vec3(w, 0, 0));\n    float tWall = plaIntersect(ro, rd, vec3(-w * 2. * stairWidth, 0, 0), vec3(w, 0, 0));\n    if(tWall > 0.) {\n        t = min(t, tWall);\n    }\n    \n    const float height = -0.5;\n    //float tBound = plaIntersect2(ro, rd, vec3(0, height, 0), vec3(0, 1, 1));\n    float tBound = plaIntersect(ro, rd, vec3(0, height, 0), vec3(0, 1, 1));\n    if(tBound > 0.) {\n        t = min(t, tBound);\n    }\n    \n    return t;\n}\n\n// 物体の種類\nint objType(vec3 p) {\n    if(abs(p.x) > stairWidth - EPS) {\n        return WALL;\n    }\n    \n    vec3 q = p - lightPos;\n    const float r = lightSize + EPS;\n    if(dot(q, q) < r * r) {\n        return SPHERE;\n    }\n    \n    p.yz = abs(fract(p.yz) - 0.5);\n    if(p.y < p.z) {\n        return STAIR_SIDE;\n    }\n    \n    return STAIR_UP;\n}\n\n// 法線ベクトルを計算する（タイルの凹凸は含まない）\nvec3 calcNormal(vec3 p, int type) {\n    if(type == WALL) {\n        return vec3(-sign(p.x), 0, 0);\n    }\n    \n    if(type == STAIR_SIDE) {\n        return vec3(0, 0, 1);\n    }\n    \n    if(type == STAIR_UP) {\n        return vec3(0, 1, 0);\n    }\n    \n    return (p - lightPos) / lightSize;\n}\n\n// タイルの凹凸\nfloat bumpFunc(vec3 p, vec3 n) {\n    p = abs(p);\n    vec2 uv = n.y > 0.5 ? p.zx : n.z > 0.5 ? p.xy : p.yz;\n    if(uv.y > uv.x) {\n        uv = uv.yx;\n    }\n    uv.y -= tileGrooveWidth + tileRaCurvature;\n    const float ra2 = tileRaCurvature * tileRaCurvature;\n    if(uv.y > 0.) {\n        return EPS + ra2;\n    }\n    \n    if(uv.y < -tileRaCurvature) {\n        return EPS;\n    }\n    \n    float h = -uv.y * uv.y;\n    return EPS + ra2 + h;\n}\n\n// 参考: \"Maze Lattice\" by Shane\n// https://www.shadertoy.com/view/llGGzh\n// タイルの凹凸ベクトル\n// コードは改変済み\nvec3 bumpMap(vec3 p, vec3 n, out bool isGroove) {\n    const float bumpFactor = 0.5;\n    const vec2 e = vec2(EPS, 0);\n    \n    const float interval = 1. / 8.;\n    const float h = interval * 0.5;\n    p = mod(p - h, interval) - h;\n    float ref = bumpFunc(p, n);\n    isGroove = (ref == EPS);\n    vec3 grad = (vec3(bumpFunc(p - e.xyy, n),\n                      bumpFunc(p - e.yxy, n),\n                      bumpFunc(p - e.yyx, n)) - ref) / e.x;\n    grad /= 2. * sqrt(ref); // sqrt(x) の微分\n    grad -= n * dot(n, grad);\n    return normalize(n + grad * bumpFactor);\n}\n\n// 三角波 周期:2, 振幅:1\nfloat triWave(float x) {\n    x -= 0.5;\n    x *= 0.5;\n    float res = abs(fract(x) - 0.5) - 0.25;\n    return res * 4.;\n}\n\n// 範囲[-1, 1.]の間で等間隔にn個の値を取る滑らかな階段状のノイズ\nfloat stepNoise(float x, float n) {\n    const float factor = 0.3;\n    float i = floor(x);\n    float f = x - i; // fract(x)\n    float u = smoothstep(0.5 - factor, 0.5 + factor, f);\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res /= (n - 1.) * 0.5;\n    return res - 1.;\n}\n\n// 光源（球体）の位置を動かす\nvoid moveLightPos() {\n    //float T = iTime - 0.7829;\n    //float T = iTime * BPM / 60. * 0.5 - 0.15; // 追加\n    float T = - 1.25 - 0.7829 + iTime * BPM / 60. * 0.5; // 追加\n    lightPos.y += abs(sin(T * PI2)) * 1.3;\n    T += triWave(T / 4.) * 2.; // 時間停止のために三角波を足す\n    lightPos += vec3(0, 1, -1) * T;\n    lightPos.x += cos(T * PI) * 0.5;\n}\n\n// カメラの位置・向きを動かす\nvoid moveCamera(inout vec3 ro, inout vec3 dir) {\n    float T = - 1.25 + iTime * BPM / 60. * 0.5; // 追加\n    //ro.yz += vec2(1, -1) * iTime;\n    ro.yz += vec2(1, -1) * T;\n    ro.y += abs(sin(ro.z * PI)) * 0.13;\n    ro += sin(vec3(5, 7, 9) * iTime) * 0.01;\n    dir.x += stepNoise(iTime * 0.4, 3.) * 0.8;\n    dir.y += stepNoise(iTime * 0.4 - 500., 3.) * 0.4;\n    dir += sin(vec3(7, 9, 5) * iTime - 500.) * 0.01;\n    dir = normalize(dir);\n}\n\n// vを天頂として極座標phi, thetaだけ回転させたベクトル\nvec3 jitter(vec3 v, float phi, float sinTheta, float cosTheta) {\n    vec3 zAxis = normalize(v);\n    vec3 xAxis = normalize(cross(zAxis.yzx, zAxis));\n    vec3 yAxis = cross(zAxis, xAxis);\n    return (xAxis * cos(phi) + yAxis * sin(phi)) * sinTheta + zAxis * cosTheta;\n}\n\n// パストレーシングをする\n// 参考: \"パストレーシング - Computer Graphics - memoRANDOM\" by Shocker_0x15\n// https://rayspace.xyz/CG/contents/path_tracing/\n// 参考: \"GLSL smallpt\" by Zavie\n// https://www.shadertoy.com/view/4sfGDB\n// コードは改変済み\nvec3 pathTrace(vec3 ro, vec3 rd) {\n    vec3 acc = vec3(0);\n    vec3 mask = vec3(1);\n    \n    for(int depth = 0; depth < maxDepth; depth++) {\n        float t = castRay(ro, rd);\n        if(t >= FAR) {\n            break;\n        }\n        ro += t * rd;\n        int type = objType(ro);\n        vec3 n0 = calcNormal(ro, type);\n        vec3 n = n0;\n        bool isGroove = false;\n        if(type != SPHERE) {\n            n = bumpMap(ro, n0, isGroove);\n        }\n        \n        ro += n0 * EPS;\n        vec3 objC = objColor(ro, type, isGroove, n0);\n        vec3 objE = emission(type);\n        \n        vec3 e = vec3(0);\n        vec3 l0 = lightPos - ro;\n        float cosA_max = sqrt(1. - lightSize * lightSize / dot(l0, l0));\n        float cosA = mix(cosA_max, 1., random());\n        vec3 l = jitter(l0, random() * PI2, sqrt(1. - cosA * cosA), cosA);\n        \n        float tl = castRay(ro, l);\n        type = objType(ro + tl * l);\n        \n        if(type == SPHERE) {\n            vec3 em = emission(type);\n            float omega = PI2 * (1. - cosA_max); // オブジェクトの表面から見たときの光源（球体）の立体角\n            // おそらく正規化LambertだがPIで割らなくてもいいかも(その場合emの値を変えるだけ)\n            e += (em * max(dot(l, n), 0.) * omega) / PI;\n        }\n        \n        const float rough = 0.01;\n        vec3 nl = reflect(rd, n);\n        //if(isGroove) {rough = 0.9; nl = n;}\n        \n        const float c = 1.; // GlossyなマテリアルのNext Event Estimationについて要検証\n        //float c = rough;\n        acc += mask * (objE + objC * e * c); // 要検証\n        mask *= objC;\n        \n        float ur = random() * rough; // 要検証\n        rd = jitter(nl, random() * PI2, sqrt(ur), sqrt(1. - ur));\n    }\n    \n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0); // 画面上の色\n    \n    lightPos = vec3(0, lightSize, 0.);\n    moveLightPos(); // 光源（球体）を動かす\n    \n    vec3 ro = vec3(0, 0, 5); // カメラの位置（レイの原点）\n    vec3 dir = vec3(0, 0, -1); // カメラの向き\n    moveCamera(ro, dir); // カメラの位置と向きを動かす\n    float fov = 60.; // FOV（視野角）範囲：(0., 180.)\n    \n    float L = focusIntersect(ro, dir); // 被写界深度の焦点まで伸ばしたレイの長さ\n    \n    for(int m = 0; m < AA; m++) { // アンチエイリアシング\n        for(int n = 0; n < AA; n++) {\n            vec2 of = vec2(m, n) / float(AA) - 0.5; // オフセット\n            vec2 uv = ((fragCoord + of) * 2. - iResolution.xy) / min(iResolution.x, iResolution.y); // 画面上の座標を正規化\n            pathSeed += hash13(vec3(uv + of, fract(iTime * 0.1)));\n            \n            vec3 rd = rayDir(uv, dir, fov); // レイの向き\n            \n            // 被写界深度\n            vec3 ros = ro;\n            vec3 rds = rd;\n            dof(ros, rds, dir, L, 0.15);\n            \n            col += pathTrace(ros, rds); // パストレーシング\n        }\n    }\n    col /= float(AA * AA); // 色の平均をとる\n    \n    //if(col.r > 1. || col.g > 1. || col.b > 1.) col = vec3(1, 0, 0); // saturationチェック\n    col = clamp(col, 0., 1.);\n    \n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    \n    // 口径食（vignetting）\n    vec2 p = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.5);\n    \n    // パストレーシングで得られた色の分散を低減するために前のフレームの色を合成する\n    //col = mix(col, texture(backbuffer, gl_FragCoord.xy / resolution).rgb, 0.2);\n    \n#ifdef DEBUG\n    col = vec3(0);\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y); // 画面上の座標を正規化\n    vec3 rd = rayDir(uv, dir, fov); // レイの向き\n    float t = castRay(ro, rd);\n    ro += t * rd;\n    int type = objType(ro);\n    vec3 n0 = calcNormal(ro, type);\n    bool isGroove = false;\n    vec3 n = n0;\n    if(type != SPHERE) {\n        n = bumpMap(ro, n0, isGroove);\n    }\n    col += exp(-t * t * 0.03) * (n * 0.5 + 0.5);\n#endif\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}