{"ver":"0.1","info":{"id":"4fB3Wc","date":"1704683570","viewed":67,"name":"Mandatory poorly made julia set","username":"quarts","description":"Mostly just an implementation of this: https://www.youtube.com/watch?v=uc2yok_pLV4&t=478s\nA lot easier than i would have thought.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of https://www.youtube.com/watch?v=uc2yok_pLV4&t=478s\n\nfloat max_iterations = 100.0;\n\n// Generates color from pallete\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.138, 0.498, 0.318);\n    vec3 b = vec3(0.248, 0.648, 0.378);\n    vec3 c = vec3(1.258, 0.718, 1.000);\n    vec3 d = vec3(-1.412, -0.652, 0.558);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Next Zn^2 + C Iteration\nvec2 nextIteration(vec2 current, vec2 k) {\n    \n    // Zn^2\n    float zr = current.x * current.x - current.y * current.y;\n    float zi = 2.0 * current.x * current.y;\n    \n    // Add Constant\n    return vec2(zr, zi) + k;\n}\n\n// Returns mod squared\nfloat mod2(vec2 z) {\n    return z.x * z.x + z.y * z.y;\n}\n\n// Computes iterations untill threshold or max iteration\nfloat computeIterations(vec2 z0, vec2 k) {\n    vec2 zn = z0;\n    float iteration = 0.0;\n    while (mod2(zn) < 4.0 && iteration < max_iterations) {\n        zn = nextIteration(zn, k);\n        iteration++;\n    }\n    return iteration;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Makes points centred and accounts for resolution\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv = uv*1.5;\n    \n    vec2 k = vec2(sin(iTime/2.0)*0.9,cos(iTime/2.0)*0.9);\n    float value = computeIterations(uv, k)/max_iterations;\n    \n    vec3 col = vec3(palette(value));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}