{"ver":"0.1","info":{"id":"tsffDr","date":"1588076785","viewed":129,"name":"Art : Menger Sponge Fabrication","username":"Gijs","description":"Tried to animate the process of folding a menger sponge.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fasdu89fpsd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float boxDistance(vec3 p, vec3 b){\n\tvec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat fractalDistance(vec3 p){\n   \n    float s = 1.;\n    float t = iTime;\n    \n    //T total time the animation needs\n    float T = 8.*4.;\n    //make t run from [-T, 10.] indefinitely\n    t = mod(t, T + 10.) - T;\n    \n    //if t = -T nothing is done.\n    //if t = 0 everything is done.\n    for(int i=0; i<4; i++){\n        if(t++>0.) p = abs(p);\n        if(t++>0.) p -= 2./3.;\n        if(t++>0.) p *= 3., s *= 3.;\n        if(t++>0.) if(p.y<p.x) p.xy = p.yx;\n        if(t++>0.) if(p.z<p.x) p.xz = p.zx;\n        if(t++>0.) p.x += 1.;\n        if(t++>0.) p.x = abs(p.x);\n        if(t++>0.) p.x -= 1.;\n    }\n    \n   \tfloat dis = boxDistance(p, vec3(1));\n    \n    return dis/s;\n}\n\nfloat axisDistance(vec3 p){\n    return MAX_MARCH;\n    \n    float x = length(p.yz);\n    float y = length(p.xz);\n    float z = length(p.xy);\n    float d = min(min(x,y),z)-0.01;\n    d = max(d, length(p)-3.);\n    return d;\n}\n\nfloat floorDistance(vec3 p){\n    return abs(p.y + 3.);\n}\n\nfloat sceneDistance(vec3 p){\n    float dis = MAX_MARCH;\n    \n    float f1 = fractalDistance(p);\n    dis = min(dis, f1);\n    \n    float f2 = floorDistance(p);\n    dis = min(dis, f2);\n    \n    float f3 = axisDistance(p);\n    dis = min(dis, f3);\n\n    return dis;\n}\n\nvec3 sceneColor(vec3 p){\n    float dis = MAX_MARCH;\n    vec3  col = vec3(1);\n    \n    float f1 = fractalDistance(p);\n    if(f1<dis){\n        dis = f1;\n        col = vec3(.5);\n\t}\n    \n    float f2 = floorDistance(p);\n    if(f2<dis){\n        dis = f2;\n        col = vec3(.9,.6,.5);\n    }\n    \n    float f3 = axisDistance(p);\n    if(f3<dis){\n        dis = f3;\n        col = vec3(.3);\n    }\n\n    return col;\n}  \n\n\n//returns 1 if hit\n//return 0 if indeterminate\n//if -1 is no hit\n\nint raymarch(in    vec3  ori,   //origin\n             in    vec3  dir,   //direction\n             inout int   steps, //steps taken\n             inout float t,     //distance travelled\n             in    float eps,   //epsilon: when we count a small distance as a hit\n             inout float mdis,  //minimum distance found\n             inout float mangle //minimum angle found\n            ){\n    for(;steps<MAX_STEPS; steps++){\n        if(t > MAX_MARCH) return -1;\n        float dis = sceneDistance(ori + dir*t);\n        mdis = min(mdis, dis);\n        mangle = min(mangle, dis/t);\n        if(dis<t*eps) return 1;  \n        t += dis;\n    } \n    \n    return 0;\n}\n\nvec3 sceneNormal(vec3 p, float eps){\n    eps = max(eps, 1e-8);\n    vec2 k = vec2(1,-1);\n    vec2 d = k*eps;\n    return normalize( k.xyy*sceneDistance( p + d.xyy ) + \n                      k.yyx*sceneDistance( p + d.yyx ) + \n                      k.yxy*sceneDistance( p + d.yxy ) + \n                      k.xxx*sceneDistance( p + d.xxx ) );\n}\n\nfloat sceneShadow(vec3 p, float eps){\n    vec3 dir = SUN_VECTOR;\n    int steps = 0;\n    float t = 0.;\n    float mdis = MAX_MARCH;\n    float mangle = 1.;\n    int res = raymarch(p, dir, steps, t, eps, mdis, mangle); \n    \n    return float(res == -1) * min(mangle/SUN_SIZE, 1.) ;\n}\n\nfloat sceneOcclusion(vec3 p, vec3 n){\n    float o = 1.;\n    float s = OCL_SPREAD;               \n    float k = OCL_INTENS;  \n    float d = s;           \n\n    for (int i = 0; i < OCL_SAMPLES; ++i) {\n        o -= (d - sceneDistance(p + n * d)) * k;\n        d += s;\n        k *= 0.5;\n    }\n    \n    return o;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float minResolution = min(iResolution.x,iResolution.y);\n    \n    vec3 camDir = normalize(CAM_LOOK-CAM_POS);\n    vec3 camRight = cross(camDir, vec3(0,1,0));\n    vec3 camUp = cross(camRight, camDir);\n    \n    for(int i=1; i<=AA; i++)\n    for(int j=1; j<=AA; j++){      \n        vec2 p = fragCoord.xy + vec2(i,j)/float(AA);\n\n        vec2 uv = (p*2. -iResolution.xy)/minResolution*CAM_ZOOM;\n\n        vec3 ori = CAM_POS;\n        vec3 dir = normalize(camDir + uv.x*camRight + uv.y*camUp);\n        int steps = 0;\n        float t = 0.;\n        float eps = DETAIL*CAM_ZOOM/minResolution;\n        float mdis = MAX_MARCH;\n        float mangle = 1.;\n        int res = raymarch(ori, dir, steps, t, eps, mdis, mangle);\n\n        vec3 col = SKY_COLOR;\n        if(res == 1){\n            vec3 hitPos = ori + dir*t;\n            vec3 hitColor = sceneColor(hitPos);\n            vec3 hitNormal = sceneNormal(hitPos, t*eps*.001);\n            vec3 hitReflect = reflect(dir, hitNormal);\n\n            float diffuse = max(dot(hitNormal,SUN_VECTOR),0.);\n            float shadow = 1.;\n            if(diffuse>0.) shadow = sceneShadow(hitPos, t*eps);\n            float occlusion = sceneOcclusion(hitPos, hitNormal);\n            float specular = pow( clamp( dot( SUN_VECTOR, hitReflect ), 0.0, 1.0 ),16.0);\n            \n            col = hitColor*(occlusion*SKY_COLOR + diffuse*shadow*SUN_COLOR*(1. + specular));\n\n        }\n\n        fragColor += vec4(col,1.0);\n    }\n    \n    fragColor /= float(AA*AA);\n    \n    fragColor = pow(fragColor,vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Raymarching\n#define DETAIL       1.5\n#define MAX_STEPS    128\n#define MAX_MARCH    100.\n\n//Lighting\n#define SKY_COLOR     vec3(.45,.56,1.)\n#define SUN_VECTOR    normalize(vec3(1,2,1))\n#define SUN_COLOR     vec3(1.)*.5\n#define SUN_SIZE      .05\n\n//Occlusion\n#define OCL_SPREAD  1.\n#define OCL_INTENS  0.15\n#define OCL_SAMPLES 4\n\n//Camera\n#define CAM_POS  vec3(cos(iTime*.1),.5,sin(iTime*.1))*7.\n#define CAM_LOOK vec3(0,0.,0)\n#define CAM_ZOOM .5\n\n//Anti-Aliasing\n#define AA 1\n\n\n","name":"Common","description":"","type":"common"}]}