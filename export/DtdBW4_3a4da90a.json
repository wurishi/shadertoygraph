{"ver":"0.1","info":{"id":"DtdBW4","date":"1701247880","viewed":26,"name":"vis1","username":"matdombrock","description":"vis1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CONTRAST 1.0\n#define SCALE 1.0\n#define MAX_ITER 100\n#define SLOWNESS 8.0\n\n// Function to calculate the Mandelbrot set\nvec2 mandelbrot(vec2 c, vec2 z, int iter) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (length(z) > 2.0) break;\n        vec2 temp = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        z = temp;\n        iter++;\n    }\n    return vec2(float(iter) / float(MAX_ITER), length(z));\n}\n\n// The main function that ShaderToy will call to color each pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize the fragment coordinates to the range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Sample the audio data from iChannel0. The y-coordinate is set to 0.5 to sample the middle of the texture.\n    // The texture function returns a vec4 where each component corresponds to a color channel (red, green, blue, alpha).\n    vec4 data = texture(iChannel0, vec2(uv.x, 0.5));\n\n    // Average the red, green, and blue channels of the audio data to get a single value\n    float sum = (data.r + data.g + data.b) / SCALE;\n\n    float time = sin(iTime / SLOWNESS);\n    \n    // Calculate the Mandelbrot set\n    float mx = sin(time);\n    float my = sin(mod(data.g + time, 0.5));\n    float ux = sin(uv.x * time);\n    float uy = sin(uv.y * time);\n    vec2 c = vec2(3.0*(ux - mx), 2.0*(uy - my));\n    vec2 z = vec2(0.0, 0.0);\n    \n    // Alt values\n    vec2 c1 = vec2(3.0*(data.r - mx), 2.0*(data.b - 0.5));\n    vec2 z1 = vec2(0.0, 0.0);\n    \n    c = mix(c, c1, data.r * 0.5);\n    z = mix(z, z1, data.b * 0.5);\n    \n    vec2 m = mandelbrot(c, z, 0);\n    // Compare the audio value with the y-coordinate of the fragment.\n    // The step function returns 0.0 if the first argument is greater than the second, and 1.0 otherwise.\n    float y = step(sum, uv.y) / (3.0 - CONTRAST);\n\n    // Set the color of the fragment.\n    // If the audio value is greater than the y-coordinate, the fragment is colored white; otherwise, it is colored black.\n    vec4 col1 = vec4(vec3(y, 0.1, 0.5-y), 1.0);\n    vec4 col2 = vec4(0.9-m.x, 0.1, 0.9-m.y, 1.0);\n    \n    vec4 col3 = mix(col1, col2, sin(time) * 0.5);\n    vec4 col4 = vec4(1) - vec4(data.b, data.r, data.g, 1.0);\n    fragColor = mix(col3, col4, sin(time) * 0.5);\n\n    //fragColor = col1;\n}","name":"Image","description":"","type":"image"}]}