{"ver":"0.1","info":{"id":"cs3yDH","date":"1695180456","viewed":86,"name":"Sketch #15: 3D Camera","username":"MOONtyzoo","description":"Based on tutorials from https://www.scratchapixel.com/\nLearned how to use LocalToWorld matrices for the camera. The code is messy/inefficient but I'm proud I got the math correct.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nfloat smoothmix(float a, float b, float x)\n{\n    return (1.0-smoothstep(0.0, 1.0, x))*a + smoothstep(0.0, 1.0, x)*b;\n}\n\nfloat random(float x)\n{\n    return fract(439029.0*sin(x));\n}\n\nfloat random(vec2 uv)\n{\n    return fract(439029.0*sin(dot(uv, vec2(85.3876, 9.38532))));\n}\n\nvec2 randomGradientVec(vec2 uv)\n{\n    float angle = 2.0*PI*random(uv);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat noise(in vec2 uv, in float sampleNum)\n{\n    /*\n        Creates gradients at sample points\n        \n        Quadrants 1, 2, 3, 4 correspond to letters d, c, a, b\n    */\n    vec2 uv_i = floor(uv*sampleNum);\n    vec2 uv_f = fract(uv*sampleNum);\n    float time_i = floor(iTime);\n    float time_f = fract(iTime);\n    \n    vec2 gradA = randomGradientVec(uv_i);\n    vec2 gradB = randomGradientVec(uv_i + vec2(1.0, 0.0));\n    vec2 gradC = randomGradientVec(uv_i + vec2(0.0, 1.0));\n    vec2 gradD = randomGradientVec(uv_i + vec2(1.0, 1.0));\n    \n    /*\n        Dot product and interpolation to get noise value at each pixel\n    */\n    float valA = dot(uv_f, gradA);\n    float valB = dot(uv_f - vec2(1.0, 0.0), gradB);\n    float valC = dot(uv_f - vec2(0.0, 1.0), gradC);\n    float valD = dot(uv_f - vec2(1.0, 1.0), gradD);\n    float valAB = smoothmix(valA, valB, uv_f.x);\n    float valBC = smoothmix(valC, valD, uv_f.x);\n    float val = 0.8*smoothmix(valAB, valBC, uv_f.y) + 0.5;\n    \n    return val;\n}\n\nmat4 cameraLookAt(vec3 from, vec3 to)\n{\n    vec3 forward = normalize(from-to);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    mat4 mat =  mat4(right.x, right.y, right.z, 0.0,\n                up.x, up.y, up.z, 0.0,\n                forward.x, forward.y, forward.z, 0.0,\n                from.x, from.y, from.z, 1.0);\n                \n    return inverse(mat);\n}\n\n// Returns 1 inside the point and 0 outside\nfloat drawVertex(in vec2 p, in vec3 screenVertex)\n{\n    return 1.0 - smoothstep(0.0, 0.005, length(screenVertex.xy - p) - 0.05/screenVertex.z);\n}\n\n// Returns 1 inside the edge and 0 outside (sv is screenVertex)\nfloat drawEdge(in vec2 p, in vec3 sv1, in vec3 sv2)\n{\n    vec2 lineVec = vec2(sv2.x - sv1.x, sv2.y - sv1.y);\n    vec2 pVec = vec2(p.x - sv1.x, p.y - sv1.y);\n    \n    float distToLine = length(cross(vec3(normalize(lineVec), 0.0), vec3(pVec, 0.0)));\n    float distAlongLine = dot(lineVec, pVec)/dot(lineVec, lineVec); // 0 at sv1 and 1 at sv2\n    \n    float depth = (1.0-distAlongLine)*sv1.z + distAlongLine*sv2.z;\n    \n    float val = 1.0 - smoothstep(0.0, 0.005, distToLine - 0.005/depth);\n    val *= step(0.0, distAlongLine)*step(distAlongLine, 1.0);\n    return val;\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    /*\n        Vertex & Edge data\n    */\n    const int gridNum = 5;\n    vec3[gridNum*gridNum] gridVertices;\n    ivec2[gridNum*gridNum*2] gridEdges;\n    for (int i = 0; i < gridNum; i++)\n    {\n        for (int j = 0; j < gridNum; j++)\n        {\n            int index = i + gridNum*j;\n            \n            //setting vertices\n            vec2 pos = vec2(float(i), float(j)) - vec2(float(gridNum)/2.0 - 0.5);\n            gridVertices[index] = vec3(pos.x, 1.5*(noise(pos, 0.6)-0.5), pos.y);\n            \n            //setting edges\n            if (i < gridNum - 1)\n            {gridEdges[index*2] = ivec2(index, index + 1);}\n            if (j < gridNum - 1)\n            {gridEdges[index*2 + 1] = ivec2(index, index + gridNum);}\n        }\n    }\n    \n    /*\n        Move camera around the scene\n    */\n    vec3 cameraPos = (sin(iTime)/2.0 + 2.0)*vec3(3.0*cos(iTime), sin(2.0*iTime)+2.0, 3.0*sin(iTime));\n    mat4 cameraWorldToLocal = cameraLookAt(cameraPos, vec3(0.0, 0.0, 0.0));\n    \n    /*\n        Transform vertices to screen space\n    */\n    vec3[gridNum*gridNum] screenVertices; // xy is screen pos but z keeps the 3D depth value\n    \n    for (int i = 0; i < gridNum*gridNum; i++)\n    {\n        // Find vertex in camera local coordinates\n        vec3 vertexPosWorld = gridVertices[i];\n        vec3 vertexPosCamera = (cameraWorldToLocal * vec4(vertexPosWorld, 1.0)).xyz;\n        \n        // Project onto screen\n        screenVertices[i].x = -vertexPosCamera.x/vertexPosCamera.z;\n        screenVertices[i].y = -vertexPosCamera.y/vertexPosCamera.z;\n        screenVertices[i].z = -vertexPosCamera.z;\n    }\n    \n    /*\n        Draw screen vertices / edges\n    */\n    \n    // val determines if the color shows (1 or 0)\n    float val = 1.0;\n    for (int i = 0; i < gridNum*gridNum; i++)\n    {\n        val *= 1.0-drawVertex(uv, screenVertices[i]);\n    }\n    for (int i = 0; i < gridNum*gridNum*2; i++)\n    {\n        vec3 sv1 = screenVertices[gridEdges[i].x];\n        vec3 sv2 = screenVertices[gridEdges[i].y];\n        val *= 1.0-drawEdge(uv, sv1, sv2);\n    }\n    val = 1.0-val;\n    \n    vec3 outputColor = hsv2rgb(vec3(0.0, 0.0, val));\n    fragColor = vec4(outputColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}