{"ver":"0.1","info":{"id":"DsfGDH","date":"1666978880","viewed":67,"name":"Light interaction single detail","username":"jean80it","description":"Light interaction single detail","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["lightinteractionsingledetail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is part of several I wrote to create animations\n// to support a presentation about Quantum Electrodynamics.\n// it is not supposed to be \"proof\" for anything, but to provide \n// good visualization of some concepts to help intuition.\n\n\n#define PI 3.1415926\n\n#define sqr(x) (x * x)\n\n#define deg2rad(x) (x * PI / 180.0)\n\n#define rad2deg(x) (x * 180.0 / PI)\n\nfloat AAK = 0.001;  // anti aliasing constant: \n                    // determines how wide is transition \n                    // between inside and outside of an SDF\n                    // while drawing\n\nfloat sdCircle(vec2 uv, float r)\n{\n    return length(uv) - max(0.0, r);\n}\n\nfloat sdEllipse(vec2 uv, float r)\n{\n    return length(uv) - max(0.0, r);\n}\n\nfloat sdEllipse(vec2 p, vec2 r)\n{\n    return length(p * r.x / r) - r.x;\n}\n\nfloat sdOutline(float sd, float thickness)\n{\n    return abs(sd) - thickness * 0.5;\n}\n\nfloat drawSdMask(float sd)\n{\n    return smoothstep(AAK, -AAK, sd);\n}\n\nvec2 translate(vec2 p, vec2 newPos)\n{\n    return p - newPos;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    mat2 r = mat2(\n        cos(a), sin(a),\n        -sin(a), cos(a)\n        );\n        \n    return p * r;\n}\n\nvoid drawSd(float sd, inout vec3 c, vec3 newCol)\n{\n    float m = drawSdMask(sd);\n    c = mix(c, newCol, m);\n}\n\nvoid drawSd(float sd, inout vec3 c, vec3 newCol, float alpha)\n{\n    float m = drawSdMask(sd) * alpha;\n    c = mix(c, newCol, m);\n}\n\nvec3 gradient(float sd, float r1, float r2, vec3 col1, vec3 col2)\n{\n    return sqrt(mix(col1 * col1, col2 * col2, smoothstep(r1, r2, sd)));\n}\n\nvec3 circularGradient(vec2 uv, vec2 center, float r1, float r2, vec3 col1, vec3 col2)\n{\n    return gradient(sdCircle(translate(uv, center), 0.0), r1, r2, col1, col2);\n}\n\nfloat fnLineC(vec2 pos, vec2 norm)\n{\n    return -dot(pos, norm); \n}\n\nfloat sdLine(vec2 uv, float A, float B, float C, float thickness)\n{\n    return abs(A * uv.x + B * uv.y + C) - thickness * 0.5;\n}\n\nfloat sdRect(vec2 p, vec2 size) \n{\n    vec2 d = abs(p) - size / 2.0;\n    return max(d.x, d.y);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdVector(in vec2 p, in float len, in float thickness, in float appPointR, vec2 arrowHeadSize)\n{\n    vec2 arrowLineSize = vec2(thickness, len);\n    float c = sdRect(p - vec2(0.0, (arrowLineSize.y - arrowHeadSize.y) / 2.0), arrowLineSize - vec2(0.0, arrowHeadSize.y));\n    c = min(c, sdEllipse(p, vec2(appPointR)));\n    c = min(c, sdTriangleIsosceles(p - vec2(0.0, arrowLineSize.y), vec2(arrowHeadSize.x, -arrowHeadSize.y)));\n    \n    return c;\n}\n\nfloat sdSquiggle(vec2 uv, vec2 A, vec2 B, float thickness, float offs)\n{\n    vec2 lv = (B - A);  // longitudinal vector, in the AB direction\n    vec2 lvn = normalize(lv);  // longitudinal vector, normalized\n    float lC = dot(lvn, A);\n    \n    vec2 ov = vec2(lv.y, -lv.x);  // orthogonal vector\n    vec2 ovn = vec2(lvn.y, -lvn.x);\n    float oC = dot(ovn, A);\n\n    float lDist = (dot(lvn, uv) - lC) / length(lv);  // distance from ortho line\n    \n    if (lDist < 0.0) return distance(uv, A);\n    if (lDist > 1.0) return distance(uv, B);\n    \n    float perturb = (sin(lDist * 20.0 + offs) * 0.07 +\n                    sin(lDist * 31.5 + offs * 1.3) * 0.08) *\n                    smoothstep(0.0, 0.5, lDist) *\n                    smoothstep(1.0, 0.5, lDist);\n    \n    float oDist = dot(ovn, uv - perturb * ovn) - oC;  // distance from line\n\n    return abs(oDist) - thickness;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\nfloat sdHLine(vec2 p, float thickness)\n{\n    return abs(p.y) - thickness * 0.5; \n}\n\nfloat sdVLine(vec2 p, float thickness)\n{\n    return abs(p.x) - thickness * 0.5; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1), aspect correct\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 center = vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n\n    // configuration\n    float particleSize = 0.05;\n    vec2 gradDispl = particleSize * vec2(0.25, 0.25);\n    float gradSize = particleSize * 1.5;\n    \n    vec3 colOrange = vec3(1.0, 0.45, 0.35);\n    vec3 colTeal = vec3(0.4, 0.5, 1.0);\n    \n    float thickness = 0.01;\n    \n    vec3 colBackground = clamp(sqrt(mix(sqr(vec3(0.25, 0.2, 0.1)), \n                                   sqr(vec3(0.1, 0.22, 0.3)), \n                                   uv.y + uv.x / 2.0)),\n                                   0.0, 1.0);\n\n    vec3 col = colBackground;\n    \n    float time = 1.5 * fract(iTime * 0.2);\n    \n    vec2 pos = center;\n\n    float r = 2.0 * time - 1.0;\n\n    drawSd(sdCircle(translate(uv, pos), particleSize),\n            col,\n            circularGradient(uv, pos + gradDispl, 0.00, gradSize, colOrange, colTeal));\n\n    drawSd(sdOutline(sdEllipse(translate(uv, pos), r), thickness), \n            col, \n            vec3(1.0));\n    \n    \n    drawSd(sdVLine(translate(uv, vec2(center.x + r, 0.0)), thickness),\n            col, \n            vec3(0.5, 0.5, 1.0),\n            smoothstep(1.0, 0.0, time));\n    \n    \n    drawSd(\n        sdVector(rotate(translate(uv, vec2(center.x + r, 0.5)), deg2rad(-90.0)), 0.15, thickness, thickness * 0.5, vec2(0.02, 0.03)),\n        col, \n        vec3(0.5, 0.5, 1.0),\n        smoothstep(1.0, 0.0, time));\n\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}