{"ver":"0.1","info":{"id":"WscfRl","date":"1605752118","viewed":476,"name":"binary phosphors","username":"Carandiru","description":"prototyping a phosphor delay for gui rendering\n\neffect best viewed *fullscreen*","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["binary","crt","font","temporal","phosphor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WscfRl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n#define shade r\n#define alpha g\n#define shadealpha ra\n\nconst vec3 gui_green = vec3(266.666e-3f, 913.725e-3f, 537.254e-3f);\nconst vec3 gui_bleed = vec3(619.607e-3f, 1.0f, 792.156e-3f);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // bufferA = even frames\n    // bufferB = odd frames\n   \n    vec2 gui, gui_prev;\n    \n    {\n        vec2 grey_alpha[2] = vec2[2](textureLod(iChannel0, uv, 0.0f).shadealpha,\n                                     textureLod(iChannel1, uv, 0.0f).shadealpha);\n        \n\t\tuint cur_frame = uint(iFrame) & 1u;\n        uint prev_frame = 1u - cur_frame; \n        \n        gui = grey_alpha[cur_frame];\n        gui_prev = grey_alpha[prev_frame];\n    }\n    \n    float blurDecay = clamp(iTimeDelta * BURNINTIME, 0.0f, 1.0f);\n\tblurDecay = max(0.0f, blurDecay - gui_prev.shade);\n    \n    vec3 color;\n    \n    color = mix((gui_bleed - blurDecay), gui_green * gui.shade, blurDecay);\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SPEED 6.0\n#define BURNINTIME 50.0\n\n// modified font code, originally from https://www.shadertoy.com/view/4dc3zr\n// thanks <Flyguy>\n\nconst float pi = atan(1.0)*4.0;\nconst float tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 12.0;\nconst float row_spacing = 2.5f * scale;\nconst uint max_line = 19u;\n\nconst vec2 digitSize = vec2(1.0,1.5) * scale;\nconst vec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\nfloat dfDigitBinary(vec2 origin, bool b, vec2 uv)\n{\n\tuv -= origin;\n\n\tfloat dist = 1e6;\n\t\n\tif(!b)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\t/*else*/\n\t\n    dist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n    return dist;\n}\n\n//Distance to a binary number\nfloat dfBinary(vec2 origin, uint bits, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = float(max_line - 1u);\n\t\n    for (uint i = 0u ; i < max_line ; ++i) {\n        \n    \tvec2 pos = digitSpacing * vec2(offs,0.0);  \n        \n        --offs;\n        \n\t\tdist = min(dist, dfDigitBinary(pos, bool(bits & 1u), uv));\n        \n\t\tbits >>= 1;        \n    }\n\treturn dist;\t\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WscfRl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (0 != (iFrame & 1))\t\t// only update on even frames, otherwise leave untouched\n    {\n        fragColor = textureLod(iChannel1, fragCoord.xy / iResolution.xy, 0.0f);\n        return;\n    }\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n    \n    float t = iTime * SPEED;\n    \n    uint bits = 0u;\n    \n    for (uint i = 0u ; i < max_line ; ++i) {\n        \n    \tbool b = bool(step(0.5f,textureLod(iChannel0, (vec2(float(i) - t, 0.0f)) / iChannelResolution[0].xy, 0.0).r));\n    \n        bits |= uint(b) << i;\n    }\n\n    float dist = 1e6;\n\tvec2 pos = -digitSpacing * vec2(max_line,1.0)/2.0;\n    pos.y -= row_spacing;\n    \n    uint ut = uint(t);\n    \n    { // row\n        dist = min(dist, dfBinary(pos, ~ut, uv));\n        pos.y += row_spacing;\n    }\n    { // row\n        dist = min(dist, dfBinary(pos, bits, uv));\n        pos.y += row_spacing;\n    }\n    { // row\n        dist = min(dist, dfBinary(pos, ut, uv));\n        pos.y += row_spacing;\n    }\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n    \n    fragColor = vec4(shade);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WscfRl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (0 == (iFrame & 1))\t\t// only update on odd frames, otherwise leave untouched\n    {\n        fragColor = textureLod(iChannel1, fragCoord.xy / iResolution.xy, 0.0f);\n        return;\n    }\n    \n    vec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - aspect/2.0;\n    \n    float t = iTime * SPEED;\n    \n    uint bits = 0u;\n    \n    for (uint i = 0u ; i < max_line ; ++i) {\n        \n    \tbool b = bool(step(0.5f,textureLod(iChannel0, (vec2(float(i) - t, 0.0f)) / iChannelResolution[0].xy, 0.0).r));\n    \n        bits |= uint(b) << i;\n    }\n\n    float dist = 1e6;\n\tvec2 pos = -digitSpacing * vec2(max_line,1.0)/2.0;\n    pos.y -= row_spacing;\n    \n    uint ut = uint(t);\n    \n    { // row\n        dist = min(dist, dfBinary(pos, ~ut, uv));\n        pos.y += row_spacing;\n    }\n    { // row\n        dist = min(dist, dfBinary(pos, bits, uv));\n        pos.y += row_spacing;\n    }\n    { // row\n        dist = min(dist, dfBinary(pos, ut, uv));\n        pos.y += row_spacing;\n    }\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n    \n    fragColor = vec4(shade);\n}","name":"none","description":"","type":"buffer"}]}