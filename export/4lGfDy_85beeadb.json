{"ver":"0.1","info":{"id":"4lGfDy","date":"1549476059","viewed":481,"name":"Real spherical harmonics","username":"uchapow","description":"Change the values of l & m with the mouse.","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["spherical","harmonics","orbital","atomic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define c00 0.2820947918 // 1/2 * sqrt(1/pi)\n\n#define c10 0.4886025119 // 1/2 * sqrt(3/pi)\n\n#define c20 0.3153915653 // 1/4 * sqrt(5/pi)\n#define c21 1.0925484305 // 1/2 * sqrt(15/pi)\n#define c22 0.5462742152 // 1/4 * sqrt(15/pi)\n\n#define c30 0.3731763326 // 1/4 * sqrt(7/pi)\n#define c31 0.4570457995 // 1/4 * sqrt(21/2pi)\n#define c32 1.4453057210 // 1/4 * sqrt(105/pi)\n#define c33 0.5900435899 // 1/4 * sqrt(35/(2pi))\n\n#define c40 0.1057855469 // 3/16 * sqrt(1/pi)\n#define c41 0.6690465436 // 3/4 * sqrt(5/2pi)\n#define c42 0.4730873480 // 5/8 * sqrt(5/pi)\n#define c44 0.6258357350 // 3/16 * sqrt(35/pi)\n#define c43 1.7701307697 // 3/4 * sqrt(35/(2pi))\n\n#define c50 0.1169503220 // 1/16 * sqrt(11/pi)\n#define c51 0.4529466511 // 1/16 * sqrt(165/pi)\n#define c52 2.3967683924 // 1/8 * sqrt(1155/pi)\n\n#define c60 0.0635692022 // 1/32 * sqrt(13/pi)\n#define c61 0.5826213625 // 1/16 * sqrt(273/pi)\n#define c62 0.4606026297 // 1/32 * sqrt(1365/(2pi))\n\n#define c72 0.2212663462 // 3/32 * sqrt(35/(2pi))\n\n\nfloat Ylm(int l, int m, in vec3 u)\n{\n\tif (l == 0) return c00;\n    \n    if (l == 1) {\n        if (m ==-1) return c10 * u.y;\n    \tif (m == 0) return c10 * u.z;\n        else \t\treturn c10 * u.x; \t\t\n    }\n    \n    if (l == 2) {\n        if (m ==-2) return c22 * 2.0 * u.x*u.y;\n        if (m ==-1) return c21 * u.y*u.z;\n    \tif (m == 0) return c20 * 3.0*u.z*u.z - c20;\n        if (m == 1) return c21 * u.z*u.x;\n        else \t\treturn c22 * (u.x*u.x - u.y*u.y);\n    }\n    \n    if (l == 3) {\n    \tif (m ==-3) return c33 * u.y*(3.0*u.x*u.x - u.y*u.y);\n        if (m ==-2) return c32 * 2.0 * u.x*u.y*u.z;\n        if (m ==-1) return c31 * u.y*(4.0*u.z*u.z - u.x*u.x - u.y*u.y);\n\t\tif (m == 0) return c30 * u.z*(5.0*u.z*u.z - 3.0);\n\t\tif (m == 1) return c31 * u.x*(4.0*u.z*u.z - u.x*u.x - u.y*u.y);\n\t\tif (m == 2)\treturn c32 * u.z*(u.x*u.x - u.y*u.y);\n        else \t\treturn c33 * u.x*(u.x*u.x - 3.0*u.y*u.y);\n    }\n    \n    if (l == 4) {\n        if (m ==-4) { return c44 * 4.0 * u.x*u.y*(u.x*u.x - u.y*u.y); }\n        if (m ==-3) { return c43 * u.y*u.z*(3.0*u.x*u.x - u.y*u.y); }\n        if (m ==-2) { return c42 * 2.0 * u.x*u.y*(7.0*u.z*u.z - 1.0); }\n        if (m ==-1) { return c41 * u.y*u.z*(7.0*u.z*u.z - 3.0); }\n        if (m == 0) { float z2 = u.z*u.z; return c40 * (35.0*z2*z2 - 30.0*z2 + 3.0); }\n        if (m == 1) { return c41 * u.x*u.z*(7.0*u.z*u.z - 3.0); }\n        if (m == 2) { return c42 * (u.x*u.x - u.y*u.y)*(7.0*u.z*u.z-1.0); }\n        if (m == 3) { return c43 * u.x*u.z*(u.x*u.x - 3.0*u.y*u.y); }\n        else \t\t{ float x2 = u.x*u.x, y2 = u.y*u.y; return c44 * ( x2*(x2 - 3.0*y2) - y2*(3.0*x2 - y2) );}\n    }\n    \n    return c00;\n}\n\n\n\n\n\nfloat _sgn, _dist;\nint _l, _m;\n\nfloat map(in vec3 r)\n{\n    float rho = length(r);\n    vec3 u = r / rho;\n    \n    float a = Ylm(_l,_m,u);\n    \n\n    _sgn = sign(a);\n    _dist = rho;\n    \n    //return rho - abs(a);\n\treturn rho - mix(abs(a), c00, clamp(2.0*cos(iTime), 0.0, 1.0));\n}\n\n\nvec3 calcNormal (in vec3 r)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize(vec3(\n           map(r+eps.xyy) - map(r-eps.xyy),\n           map(r+eps.yxy) - map(r-eps.yxy),\n           map(r+eps.yyx) - map(r-eps.yyx)\n    ));\n}\n\n\nfloat trace(in vec3 ro, in vec3 rd)\n{\n    float t = 1.0, tmax = 10.0;\n    float d;\n    \n    for (int i=0; i<160; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < 0.001 || t > tmax) break;\n        t += d*0.2;\n    }\n    \n    return t;\n}\n\n\n\nmat3 setCamera(in vec3 ro, in vec3 rt, in float cr)\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = 2.0*vec3(sin(iTime), 0.0, cos(iTime));\n    vec3 rd = normalize(vec3(uv, -2.2));\n    \n    vec3 ta = vec3(0.0);\n    mat3 ca = setCamera(ro, ta, 0.0);\n    rd = ca * rd;\n    \n    \n    _l = int(5.0 - 5.0*iMouse.y/iResolution.y);\n    float k = 2.0 * float(_l) + 1.0;\n    _m = int(k * iMouse.x/iResolution.x - 0.5*k);\n    \n    \n    float t = trace(ro, rd);\n    \n    \n    vec3 col = vec3(1.0-length(uv*5.0)*0.05);\n    \n    if (t < 10.0)\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mat = mix(vec3(0.8,0.5,0.0), vec3(0.0,0.2,0.8), _sgn);\n        \n        float occ = clamp(2.0*_dist, 0.0, 1.0);\n        float dif = 1.0 + 0.8*nor.y;\n        float spe = pow(max(dot(normalize(nor - rd), nor), 0.0), 140.0);\n\n        \n        col = mat * (dif * occ + spe);\n    }\n    \n    \n    \n    // Print Y l,m\n    \n    const float w = 64.0 / 1024.0;\n    const vec2 tileY = vec2(9.0, 10.0);\n    const vec2 tile_ = vec2(13.0, 13.0);\n    vec2 tileL = vec2(_l, 12.0);\n    vec2 tileM = vec2(abs(_m), 12.0);\n    \n    vec2 pix = fragCoord/iResolution.xy;\n    vec2 Ypos = pix*4.0 + vec2(0.25, -3.0);\n    vec2 Lpos = pix*12.0 + vec2(-1.25, -9.0);\n    vec2 Mpos = pix*12.0 + vec2(-1.25, -11.0);\n    \n\tif (Ypos.x < 1.0 && Ypos.y > 0.0)\n        col -= texture(iChannel0, mix(tileY*w, (tileY + 1.0)*w, Ypos)).rrr;\n\tif (Lpos.x > 0.0 && Lpos.x < 1.0 && Lpos.y > 0.0 && Lpos.y < 1.0)\n        col -= texture(iChannel0, mix(tileL*w, (tileL + 1.0)*w, Lpos)).rrr;\n    if (_m < 0)\n    {\n        if (Mpos.x > 0.0 && Mpos.x < 1.0 && Mpos.y > 0.0)\n            col -= texture(iChannel0, mix(tile_*w, (tile_ + 1.0)*w, Mpos)).rrr;\n\n        Mpos.x -= 0.5;\n        if (Mpos.x > 0.0 && Mpos.x < 1.0 && Mpos.y > 0.0)\n            col -= texture(iChannel0, mix(tileM*w, (tileM + 1.0)*w, Mpos)).rrr;\n    }\n    else\n    {\n        if (Mpos.x > 0.0 && Mpos.x < 1.0 && Mpos.y > 0.0)\n            col -= texture(iChannel0, mix(tileM*w, (tileM + 1.0)*w, Mpos)).rrr;\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}