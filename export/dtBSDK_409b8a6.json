{"ver":"0.1","info":{"id":"dtBSDK","date":"1676586618","viewed":318,"name":"Space Reactor","username":"Kali","description":"Applying operations and transformations to spheres with a rotating twist effect","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","space","reactor","rotatingstructures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float det=.01,st=.1,sph;\nvec3 pos;\n\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat de(vec3 p)\n{\n    float s=sin(iTime*2.);\n    p.xz*=rot(iTime-p.y*.4);\n    p.xy*=rot(iTime-p.z*.2);\n    sph=length(p)-1.-length(sin(p*3.))*.2;\n    sph-=s*s*.5;\n    pos=p;\n    float d=length(p)-2.;\n    d=max(d,-length(p.xy)+3.);\n    d=max(d,-length(p.xz)+3.);\n    d=max(d,-length(p.yz)+3.);\n    d-=length(sin(p*3.))*.9;\n    d=min(d,sph);\n    return d*.25;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(0.,det);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\nvec3 march(vec3 from, vec3 dir) \n{\n    float td=0.,d,maxdist=30.,g=0.,ref=0.;\n    vec3 p=from,col=vec3(.0);\n    for (int i=0; i<100; i++)\n    {\n        p+=dir*d;\n        d=de(p);\n        if (td>maxdist) break;\n        if (d<det&&ref<1.) \n        {\n            ref+=1.;\n            vec3 n=normal(p);\n            dir=reflect(dir,n);\n            p+=det*dir;\n        }\n        //td+=st;\n        td+=d;\n        g=max(g,.15/(.1+sph*.5));\n    }\n    if (d<.1) \n    {\n        //vec3 ldir=normalize(vec3(2.,1.,-1.));\n        vec3 ldir=normalize(-p);\n        vec3 n=normal(p);\n        float amb=.3;\n        float dif=max(0.,dot(ldir,n))*.5;\n        vec3 ref=reflect(dir,n);\n        float spe=pow(max(0.,dot(ldir,ref)),10.)*.5;\n        col=normalize(abs(fract(pos)-.5))*(amb+dif)+spe;\n    }\n    else\n    {\n        p=maxdist*dir;\n        if (ref==1.) p=dir;\n        p*=length(p.xy)*.015;\n        p+=vec3(.3,.2,.1);\n        for (int i=0; i<10; i++)\n        {\n            p=abs(p)/dot(p,p)-.78;\n        }\n        col+=dot(p,p)*.005*p;\n    }\n    return col+g*vec3(1.5,.7,.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 dir=normalize(vec3(uv,1.));\n    float s=sin(iTime*.5);\n    float c=cos(iTime*.5);\n    dir.xy*=rot(s*.2);\n    vec3 from=vec3(c*c*c*2.,0.,-10.+s*s*3.);\n    vec3 col=march(from, dir);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}