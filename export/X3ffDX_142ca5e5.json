{"ver":"0.1","info":{"id":"X3ffDX","date":"1729023773","viewed":57,"name":"Octahedral Flux","username":"8InfinityTaco8","description":"This uses kishimisu's \"An introduciton to Raymarching\" tutorial on youtube\n\nhttps://youtu.be/khblXafu7iA?si=CGrK1kNh92VrSonf\n\nyou can use your mouse to control the rotation ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","distancefield","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Sined Distance for a Cube\nfloat sdOctahedron (vec3 p, float s){\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * .57735027;\n}\n\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2 (c, -s, s, c);\n}\n\nfloat map(vec3 p){\n    \n    p.z += iTime * .4; //Forward movement\n    p.xy = (fract(p.xy) - .5);//spacing 1\n    p.z = mod (p.z, .25) - .125; // spacing .25\n    \n    float box = sdOctahedron(p, .15); // passing vec3 to sdBox (just multiply to scale)\n    \n    return min(box, 2.);\n}\n\n\nvec3 pallete(float t){\n     vec3 a = vec3(0.500, 0.500, 0.500);\n     vec3 b = vec3(0.500, 0.500, 0.500); \n     vec3 c = vec3(1.000, 1.000, 1.000);\n     vec3 d = vec3(-0.500, 0.333, 0.667);\n\n    return a + b * cos (6.28318*(c*t+d));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n   vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y * 4.; //(this can be scaled to determin sensitivity)\n\n   \n   //initialization\n   vec3 ro = vec3(0, 0, -3); // ray origin\n   vec3 rd = normalize(vec3(uv, 1)); // ray direction\n   vec3 col = vec3(0); // final pixel color\n   \n   float t = 0.; // total distance travelled\n   \n   //default circular motion if mouse not licked\n   if (iMouse.z <= 0.) m = vec2(cos(iTime*.4), sin(iTime*.4));\n   \n   //Raymarching\n   int i;\n   for (i = 0; i < 80; i++){\n       vec3 p = ro + rd * t; // position along the ray\n       \n       p.xy *= rot2D(t*.2 * m.x); // rotate ray around axis\n       \n       p.y += sin(t*(m.y+1.))*.2; //wiggle ray\n   \n       float d = map(p); // current distance to the scene\n       \n       t += d; // \"march\" the ray\n       \n       if (d < 0.001) break;\n       if (d > 100.) break;\n   }\n   \n   //coloring\n   col = pallete(t * 0.04 + float(i)*.001 + iTime *.4); // color based on distance\n   //col = pallete(length(uv) + i *.4 + iTime*.4);\n   \n   fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}