{"ver":"0.1","info":{"id":"stBcDR","date":"1649497376","viewed":155,"name":"RTW speed run","username":"lukasino1214","description":"bruh","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["bruh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool material_scatter(const in Ray r_in, const in HitRecord rec, out vec3 attenuation, out Ray scattered) {\n    if(rec.material.type == LAMBERTIAN) {\n        vec3 rd = normalize(rec.normal + random_in_unit_sphere(g_seed));\n        scattered = Ray(rec.p, rd);\n        if(rec.material.texture_type == CHECKER) {\n            attenuation = checker_texture(rec.p);\n        } else if(rec.material.texture_type == NOISE) {\n            attenuation = vec3(.5*(1. + sin(rec.normal.x*rec.p.z + 5.*fbm((rec.normal.x*.5)*rec.p, 7))));\n        } else {\n            attenuation = rec.material.albedo;\n        }\n        return true;\n    } else if(rec.material.type == METAL) {\n        vec3 rd = reflect(r_in.direction, rec.normal);\n        scattered = Ray(rec.p, normalize(rd + rec.material.v * random_in_unit_sphere(g_seed)));\n        attenuation = rec.material.albedo;\n        return true;\n    } else if(rec.material.type == DIELECTRIC) {\n        vec3 outward_normal, refracted;\n        vec3 reflected = reflect(r_in.direction, rec.normal);\n        float ni_over_nt, reflect_prob, cosine;\n        \n        attenuation = vec3(1.0);\n        if (dot(r_in.direction, rec.normal) > 0.0) {\n            outward_normal = -rec.normal;\n            ni_over_nt = rec.material.v;\n            cosine = dot(r_in.direction, rec.normal);\n            cosine = sqrt(1.0 - rec.material.v * rec.material.v * (1.0 - cosine * cosine));\n        } else {\n            outward_normal = rec.normal;\n            ni_over_nt = 1.0 / rec.material.v;\n            cosine = -dot(r_in.direction, rec.normal);\n        }\n        \n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n\t        reflect_prob = schlick(cosine, rec.material.v);\n        } else {\n            reflect_prob = 1.0;\n        }\n        \n        if (hash1(g_seed) < reflect_prob) {\n            scattered = Ray(rec.p, reflected);\n        } else {\n            scattered = Ray(rec.p, refracted);\n        }\n        return true;\n    }\n    return false;\n}\n\nbool hitable_hit(const in Hitable hb, const in Ray r, const in float t_min, const in float t_max, inout HitRecord rec) {\n    // always a sphere\n    vec3 oc = r.origin - hb.center;\n    float b = dot(oc, r.direction);\n    float c = dot(oc, oc) - hb.radius * hb.radius;\n    float D = b * b - c;\n    if (D < 0.0) return false;\n\n\tfloat s = sqrt(D);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\tfloat t = t1 < t_min ? t2 : t1;\n    if (t < t_max && t > t_min) {\n        rec.t = t;\n        rec.p = r.origin + t * r.direction;\n        rec.normal = (rec.p - hb.center) / hb.radius;\n        get_sphere_uv(rec.normal, rec.u, rec.v);\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\nbool world_hit(const in Ray r, const in float t_min, const in float t_max, out HitRecord rec) {\n    rec.t = t_max;\n    bool hit = false;\n    \n    /*if (hitable_hit(Hitable(vec3(0.0, 0.0, -1.0), 0.5),r,t_min,rec.t,rec)) {\n        hit = true; \n        rec.material = Material(LAMBERTIAN, vec3(0.1, 0.2, 0.5), 0.0, NONE);\n    }\n\tif (hitable_hit(Hitable(vec3(0.0, -100.5, -1.0), 100.0),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.material = Material(LAMBERTIAN, vec3(0.8, 0.8, 0.0), 0.0, CHECKER);\n    }\n\tif (hitable_hit(Hitable(vec3(1.0, 0.0, -1.0),.5),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.material = Material(METAL, vec3(0.8, 0.6, 0.2), 0.1, NONE);\n    }\n\tif (hitable_hit(Hitable(vec3(-1.0, 0.0,-1.0), 0.5),r,t_min,rec.t,rec)) {\n        hit = true; \n        rec.material = Material(DIELECTRIC, vec3(0.0), 1.5, NONE);\n    }\n\tif (hitable_hit(Hitable(vec3(-1,0, -1.0), -0.45),r,t_min,rec.t,rec)) {\n        hit = true;\n        rec.material = Material(DIELECTRIC, vec3(0.0), 1.5, NONE);\n    }*/\n    \n    \n    \n    if (hitable_hit(Hitable(vec3(0.0, -1000.0, -1.0), 1000.0),r,t_min,rec.t,rec)) hit = true, rec.material = Material(LAMBERTIAN,vec3(.5),0., NONE);\n  \tif (hitable_hit(Hitable(vec3( 0.0, 1.0, 0.0),1.0),r,t_min,rec.t,rec))         hit = true, rec.material = Material(DIELECTRIC,vec3(0),1.5, NONE);\n    if (hitable_hit(Hitable(vec3(-4.0, 1.0, 0.0), 1.0),r,t_min,rec.t,rec))        hit = true, rec.material = Material(LAMBERTIAN,vec3(.4,.2,.1),0., NONE);\n\tif (hitable_hit(Hitable(vec3( 4.0, 1.0, 0.0), 1.0),r,t_min,rec.t,rec))        hit = true, rec.material = Material(METAL     ,vec3(.7,.6,.5),0., NONE);\n    \n    int NO_UNROLL = min(0,iFrame);\n    for (int a = -11; a < 11+NO_UNROLL; a++) {\n        for (int b = -11; b < 11+NO_UNROLL; b++) {\n            float m_seed = float(a) + float(b) / 1000.0;\n            vec3 rand1 = hash3(m_seed);            \n            vec3 center = vec3(float(a)+.9 * rand1.x, 0.2, float(b) + 0.9 * rand1.y); \n            float choose_mat = rand1.z;\n            \n            if (distance(center,vec3(4.0, 0.2, 0.0)) > 0.9) {\n                if (choose_mat < 0.8) { // diffuse\n                    if (hitable_hit(Hitable(center, 0.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.material = Material(LAMBERTIAN, hash3(m_seed)* hash3(m_seed), 0.0, NONE);\n                    }\n                } else if (choose_mat < 0.95) { // metal\n                    if (hitable_hit(Hitable(center,0.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.material = Material(METAL, 0.5 * (hash3(m_seed) + 1.0), 0.5 * hash1(m_seed), NONE);\n                    }\n                } else { // glass\n                    if (hitable_hit(Hitable(center, 0.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.material = Material(DIELECTRIC, vec3(0.0), 1.5, NONE);\n                    }\n                }\n            }\n        }\n    }\n    \n    return hit;\n}\n\nvec3 color(in Ray r) {\n    vec3 col = vec3(1);  \n\tHitRecord rec;\n    \n    for (int i=0; i<MAX_RECURSION; i++) {\n    \tif (world_hit(r, 0.001, MAX_FLOAT, rec)) {\n            Ray scattered;\n            vec3 attenuation;\n            if (material_scatter(r, rec, attenuation, scattered)) {\n                col *= attenuation;\n                r = scattered;\n            } else {\n                return vec3(0.0);\n            }\n\t    } else {\n            float t = 0.5 * r.direction.y + 0.5;\n            col *= mix(vec3(1.0),vec3(0.5, 0.7, 1.0), t);\n            return col;\n    \t}\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\n    if (ivec2(frag_coord) == ivec2(0)) {\n        frag_color = iResolution.xyxy;\n    } else {\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\n        \n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\n        float aspect = iResolution.x/iResolution.y;\n        vec3 lookfrom = vec3(10,6,10);\n        vec3 lookat = vec3(0);\n        \n        Camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 20., aspect, .01, 100.);\n        Ray r = camera_get_ray(cam, uv);\n        vec3 col = color(r);\n        \n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \n\t        frag_color = vec4(col,1.0) + texelFetch(iChannel0, ivec2(frag_coord), 0);\n        } else {        \n\t        frag_color = vec4(col,1.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 1e5\n#define MAX_RECURSION (16+min(0,iFrame))\n#define PI 3.14159265359\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\n#define NONE 0\n#define CHECKER 1\n#define NOISE 2\n\n#define SKY 1\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat schlick(float cosine, float ior) {\n    float r0 = (1.-ior)/(1.+ior);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\n\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \n                      out vec3 refracted) {\n    float dt = dot(v, n);\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\n    if (discriminant > 0.) {\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\n        return true;\n    } else { \n        return false;\n    }\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\n}\n\n\nfloat noise(const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(const in vec3 p, const in int octaves) {\n    float accum = 0.;\n    vec3 temp_p = p;\n    float weight = 1.;\n     \n    for (int i=0; i<octaves; i++) {\n        accum += weight * noise(temp_p);\n        weight *= .5;\n        temp_p *= 2.;\n    }\n    return abs(accum);\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Texture {\n    int type;\n    vec3 col;\n};\n\nstruct Material {\n    int type;\n    vec3 albedo;\n    float v;\n    int texture_type;\n    //Texture tex_albedo;\n    //Texture emit;\n};\n\nstruct HitRecord {\n    float t;\n    float u;\n    float v;\n    vec3 p;\n    vec3 normal;\n    Material material;\n};\n\nstruct Hitable {\n    vec3 center;\n    float radius;\n};\n\nstruct Camera {\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\n    float lens_radius;\n};\n\nCamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \n                    const in float vfov, const in float aspect, const in float aperture, \n                    const in float focus_dist) {\n    Camera cam;    \n    cam.lens_radius = aperture / 2.;\n    float theta = vfov*3.14159265359/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    return cam;\n}\n    \nRay camera_get_ray(Camera c, vec2 uv) {\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return Ray(c.origin + offset, \n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));\n}\n\nvoid get_sphere_uv(vec3 p, inout float u, inout float v) {\n    float theta = acos(-p.y);\n    float phi = atan(-p.z, p.x) + PI;\n\n    u = phi / (2.0 * PI);\n    v = theta / PI;\n}\n\nvec3 checker_texture(vec3 p) {\n    float sines = sin(10.0 * p.x) * sin(10.0 * p.y) * sin(10.0 * p.z);\n    if (sines < 0.0) {\n        return vec3(0.0);\n    } else {\n        return vec3(1.0);\n    }\n}","name":"Common","description":"","type":"common"}]}