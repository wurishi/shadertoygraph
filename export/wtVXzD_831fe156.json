{"ver":"0.1","info":{"id":"wtVXzD","date":"1584688429","viewed":79,"name":"Disk Sampling Pattern (partial)","username":"iradicator","description":"Construction of a normalized uniform disk sampling pattern based on initial good guess and correction as needed.\n(initial non improved version for readability).\nFor more details, check out https://iradicator.com/normalized-uniform-disk-pattern/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","sampling","pattern","disk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_FLT 3.402823e+38\n#define EPSILON 1.192093e-07\n\n//////////////\n// Controls //\n//////////////\n\n#define IS_ANIMATED 0\n\nint L = 6;\nint S = 8;\n\n//////////////////////////\n// Guess Based Approach //\n//////////////////////////\n\nint N(int L, int S)\n{\n    return 1 + S * (L * (L + 1) / 2);\n}\n\nvec2 disk(int i, int L, int S)\n{\n\tif (i == 0) // first branch\n    {\n        return vec2(0.0); // innermost ring (l=0)\n    }\n    float x2 = float(2 * (i - 1)) / float(S);    \t\n    int l = int(floor(sqrt(x2))); // initial guess        \n    if (x2 >= float(l * ( l + 1)))  // second branch\n    {\n\t\t++l; // guess correction\n\t}\n    int s = i - N(l-1, S);\n    \n    float r = float(l) / float(L-1);   \n\tfloat theta = 2.0 * PI * float(s) / float(S*l);\n    \n    return r * vec2(cos(theta), sin(theta));    \n}\n\n////////////////////\n// Driver Program //\n////////////////////\n\nfloat sdDisk(vec2 p, int L, int S)\n{\n    float d = MAX_FLT;    \n    for (int i = 0; i < N(L-1,S); ++i)\n    {                     \n        vec2 q = disk(i, L, S);\n        d = min(d, length(p - q));        \n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv *= 1.2 * vec2(aspect, 1.0);\n        \n    float d = sdDisk(uv, max(1,L), max(1,S));\n    d = step(0.01, d);\n\t\n    vec3 bg_col = vec3(61, 15, 43) / 255.0;\n    vec3 fg_col = vec3(255, 246, 143) / 255.0;\n    vec3 col = mix(fg_col, bg_col, d);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}