{"ver":"0.1","info":{"id":"Wt2yzm","date":"1594007222","viewed":127,"name":"Ray Marching and CSG","username":"LiamHz","description":"Result from following along with Jamie Wong's ray marching CSG tutorial","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["csg","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marching parameters\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nconst float PI = 3.1415926535;\n\nstruct Light {\n    vec3 position;\n    vec3 intensity;\n};\n\n// Affine transforms\nmat4 rotationX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4( 1, 0, 0, 0,\n                 0, c,-s, 0,\n                 0, s, c, 0,\n                 0, 0, 0, 1);\n}\n\nmat4 rotationZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4( c,-s, 0, 0,\n                 s, c, 0, 0,\n                 0, 0, 1, 0,\n                 0, 0, 0, 1);\n}\n\n\n// Constructive Solid Geometry (CSG) operations\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// SDF for a cube centered at the origin with width = height = length = 2.0\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n// SDF for a sphere centered at the origin\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n// SDF for a cylinder centered at the origin, \n// a and b are endpoints of the cylinder\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// Absolute of the return value is distance to surface\n// Sign indicates if point is inside (-) or outside (+) surface\nfloat sceneSDF(vec3 p) {\n    // Note: Transformations can be applied by using the inverse \n    //       of the desired transformation matrix\n    //       EX: p + vec3(-1, 0, 0) will move the SDF 1 unit to the right\n    \n    // Note: Transformations must preserve the distances between points\n    //       EX: sdf(p / scalingFactor) --> will result in distorted distances\n    //           sdf(p / scalingFactor) * scalingFactor --> won't distort\n    \n    // Note: Understimating the distance is better than overestimating\n    //       For non-uniform scaling multiply by the minimum of the components\n    //       EX: sdf(p / vec3(x, y, z)) * min(x, min(y, z))\n    \n    float cubeD   = cubeSDF(p);\n    float sphereD = sphereSDF((p) / 1.2, 1.0) * 1.2;\n    \n    float cS = 1.2;   // Cylinder scaling factor\n    float cR = 0.6 + sin(iTime) * 0.4;\n    float xCylD = cylinderSDF(p, vec3(-1,  0,  0)*cS, vec3(1, 0, 0)*cS, cR);\n    float yCylD = cylinderSDF(p, vec3( 0, -1,  0)*cS, vec3(0, 1, 0)*cS, cR);\n    float zCylD = cylinderSDF(p, vec3( 0,  0, -1)*cS, vec3(0, 0, 1)*cS, cR);\n    \n    float sR = 0.2;         \t // Sphere radius\n    float sT = sin(iTime) * 2.0; // Transform scaler\n    float sUp       = sphereSDF(p - vec3( 0, 1, 0)*sT, sR);\n    float sDown     = sphereSDF(p - vec3( 0,-1, 0)*sT, sR);\n    float sLeft     = sphereSDF(p - vec3(-1, 0, 0)*sT, sR);\n    float sRight    = sphereSDF(p - vec3( 1, 0, 0)*sT, sR);\n    float sForward  = sphereSDF(p - vec3( 0, 0, 1)*sT, sR);\n    float sBack     = sphereSDF(p - vec3( 0, 0,-1)*sT, sR);\n\n    float uniCyls          = unionSDF(xCylD, unionSDF(yCylD, zCylD));\n    float interCircCube    = intersectSDF(cubeD, sphereD);\n    float diffCircCubeCyls = differenceSDF(interCircCube, uniCyls);\n    float sixSpheres       = unionSDF(unionSDF(unionSDF(sUp, sDown),\n                                      unionSDF(sLeft, sRight)),\n                                      unionSDF(sForward, sBack));\n\n    float combo = unionSDF(diffCircCubeCyls, sixSpheres);\n\n    return combo;\n}\n\n// Return shortest distance from the eye to the scene surface along ray \nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection,\n                                float initialDepth, float maxDepth) {\n    float depth = initialDepth;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // dist is distance from surface\n        // Negative dist indicates surface intersection\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= maxDepth) {\n            return maxDepth;\n        }\n    }\n    return maxDepth;\n}\n            \n\n// Return normalized direction to march in from the eye point for a single pixel\nvec3 getRayDirection(float fov, vec2 resolution, vec2 fragCoord) {\n    // Move origin from bottom left to center of screen\n    vec2 xy = fragCoord - resolution / 2.0;\n    \n    // Get the z-distance from pixel given resolution and vertical FoV\n    // Diagram shows that: tan(radians(fov)/2) == (resolution.y * 0.5) / z\n    // Diagram: https://stackoverflow.com/a/10018680\n    // Isolating for z gives\n    float z = (resolution.y * 0.5) / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// Estimate normal of surface at point p by sampling nearby points\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 getLightContrib(vec3 p, vec3 eye, vec3 k_d, vec3 k_s, float shininess, Light light) {\n    vec3 N = estimateNormal(p);             // Normal\n    vec3 L = normalize(light.position - p); // Light vector\n    vec3 V = normalize(eye - p);            // View vector\n    vec3 R = normalize(reflect(-L, N));     // Reflect vector\n    \n    float diff = max(dot(L, N), 0.0);\n    float spec = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 diffuse  = k_d * diff;\n    vec3 specular = k_s * spec;\n\n    return light.intensity * (diffuse + specular);\n}\n\nvec3 getLighting(vec3 p, vec3 eye) {\n    // Use surface normal as ambient color\n    vec3 N = estimateNormal(p);\n    vec3 normalAmbient = (N + vec3(1)) / 2.0;\n    \n    vec3 k_a = vec3(0.3);\n    vec3 k_d = normalAmbient;\n    vec3 k_s = vec3(1.0);\n    float shininess = 8.0;\n\n\n    vec3 ambientLight = vec3(0.2);\n    vec3 lighting = ambientLight * k_a * normalAmbient;\n\n    Light light1;\n    light1.intensity = vec3(0.4);\n    light1.position  = vec3(4.0 * sin(iTime), 2.0, 4.0 * cos(iTime));\n\n    Light light2;\n    light2.intensity = vec3(0.4);\n    light2.position  = vec3(2.0 * sin(0.4 * iTime), 2.0 * cos(0.4 * iTime), 2.0);\n\n    lighting += getLightContrib(p, eye, k_d, k_s, shininess, light1);\n    lighting += getLightContrib(p, eye, k_d, k_s, shininess, light2);\n\n    return lighting;\n}\n\n// center: Center of scene\nmat4 getLookAtMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat4(vec4(s, 0), vec4(u, 0), vec4(-f, 0), vec4(0, 0, 0, 1));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 resolution = iResolution.xy;\n    \n    vec3 eye = vec3(sin(iTime) * 5.0, 4, cos(iTime) * 5.0);\n    vec3 viewDir = getRayDirection(45.0, resolution, gl_FragCoord.xy);\n\n    // Transform from view to world space\n    mat4 viewToWorld = getLookAtMatrix(eye, vec3(0), vec3(0, 1, 0));\n    vec3 worldDir    = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    // Didn't hit anything\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    // Point of intersection of view ray with surface\n    vec3 p = eye + dist * worldDir;\n\n    vec3 lighting = getLighting(p, eye);\n    vec3 outColor = lighting;\n\n    fragColor = vec4(outColor, 1);\n}\n","name":"Image","description":"","type":"image"}]}