{"ver":"0.1","info":{"id":"3tGGRt","date":"1579551957","viewed":155,"name":"bobbie gay solar system","username":"bobbiebum","description":"this is my shader, suck on my balls","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["balls","gay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//just puts Buffer A onto the screen\nvoid mainImage(out vec4 O,vec2 U){\n    O=texture(iChannel0,U/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//camera ray calculating function\nvec3 cam(vec2 uv,vec3 ro,vec3 look){\n    //direction the camera looks\n    vec3 Z=normalize(look-ro);\n\n    vec3 X=normalize(cross(vec3(0,1,0),Z));\n    vec3 Y=cross(Z,X);\n\n    return normalize(Z+X*uv.x+Y*uv.y);\n}\n//function for creating a sphere\nvoid sphere(vec3 p,int i,vec3 pos,float radius,out float d,out int id){\n    float sphere=length(p-pos)-radius;\n    if(d>sphere){d=sphere;id=i;}\n}\n//function for creating a line\nvoid line(vec3 p,int i,vec3 a,vec3 b,float radius,out float d,out int id){\n  vec3 pa=p-a,ba=b-a;float line=length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.,1.))-radius;\n  if(d>line){d=line;id=i;}\n}\n\nfloat map(vec3 p,out int id){\n    float d=p.y;\n    \n    id=d==p.y?0:id;\n\n    float t=sin(iTime);\n    float y=cos(iTime);\n    vec3 a=vec3(0,1,1);\n    vec3 b=vec3(0,0,0);\n    vec3 c=sqrt(cross(a,b));\n    \n/* \n\tsphere(p,2,a,.1,d,id);\n    sphere(p,2,b,.1,d,id);\n    sphere(p,2,c,.1,d,id);\n    \n    line(p,3,a,b,.03,d,id);\n    line(p,3,a,c,.03,d,id);\n    line(p,3,b,c,.03,d,id);\n    line(p,3,vec3(0),b,.03,d,id);\n    line(p,3,vec3(0),c,.03,d,id);\n    line(p,3,vec3(0),a,.03,d,id);    \n*/   \n    sphere(p,6,vec3(0,1,0),t*.1+.5,d,id);\n    \n    //box round circle\n    sphere(p,2,vec3(0,0,0),.05,d,id);\n    sphere(p,2,vec3(t*1.,1,y*1.),.05,d,id);\n    sphere(p,2,vec3(y*1.,1,-t*1.),.05,d,id);\n    sphere(p,2,vec3(-y*1.,1,t*1.),.05,d,id);\n    sphere(p,2,vec3(-t*1.,1,-y*1.),.05,d,id);\n    sphere(p,2,vec3(0,2,0),.05,d,id);\n    \n    //box bottom\n    line(p,3,vec3(t*1.,1,y*1.),vec3(0,0,0),.01,d,id);\n    line(p,3,vec3(y*1.,1,-t*1.),vec3(0,0,0),.01,d,id);\n    line(p,3,vec3(-y*1.,1,t*1.),vec3(0,0,0),.01,d,id);\n    line(p,3,vec3(-t*1.,1,-y*1.),vec3(0,0,0),.01,d,id);\n    \n    //box top\n    line(p,3,vec3(t*1.,1,y*1.),vec3(0,2,0),.01,d,id);\n    line(p,3,vec3(y*1.,1,-t*1.),vec3(0,2,0),.01,d,id);\n    line(p,3,vec3(-y*1.,1,t*1.),vec3(0,2,0),.01,d,id);\n    line(p,3,vec3(-t*1.,1,-y*1.),vec3(0,2,0),.01,d,id);\n    \n    \n    //return closest distance\n    return d;\n}\n\n//rendering! ignore it for now\n\n#define STEPS 80\n#define FAR 70.\n#define epsilon .005\n\nvoid march(vec3 ro,vec3 rd,out vec3 p,out float dO,float MAX,float MIN,out int id){\n    float dS=MIN;\n    for(int i=0;i<STEPS;i++){\n        p=ro+rd*dO;\n        if(dO>MAX){id=1;break;}\n        if(dS<MIN*dO)break;\n        dS=map(p,id);\n        dO+=dS;\n    }    \n}\nvec3 normal(vec3 p){\n    int id;\n    float d=map(p,id);\n    vec2 e=vec2(0.001,0); \n    return normalize(d-vec3(\n        map(p-e.xyy,id),\n        map(p-e.yxy,id),\n        map(p-e.yyx,id)));\n}\nvec3 light(vec3 n,vec3 r,vec3 l,float softness,float shine,float samount,vec3 col){\n\treturn col*(clamp((dot(n,normalize(l))+softness)/(1.+softness*2.),0.0,1.0)\n                +pow(max(dot(l,r),0.),shine)*samount);\n}\n\nvoid reflection(vec3 ro,out vec3 rd,out vec3 p,out float d,out vec3 n,out int id){\n    float d0;\n    rd=reflect(rd,n);\n    march(ro+n*epsilon*d,rd,p,d0,FAR-d,epsilon,id);\n    d+=d0;\n    n=normal(p);\n}\n\nvoid render(vec3 ro,vec3 rd,out vec4 comp){\n\tvec3 p,col;float d;int id;\n    march(ro,rd,p,d,FAR,epsilon,id);\n    \n    if(id==1){return;}\n        \n    vec3 n=normal(p),r=reflect(rd,n);\n    \n    for(int q=0;q<20;q++){\n        if(id==6){reflection(p,rd,p,d,n,id);}\n    }\n    \n    if(id>1){\n        if(id==2)col=vec3(1);\n        if(id==3)col=vec3(1,0,0);\n        if(id==4)col=vec3(0,1,0);\n        if(id==5)col=vec3(0,0,1);\n      \n    \tvec3 a=(light(n,r,vec3(0,-1,0),.7,5.,.2,vec3(.04))\n    \t\t\t+light(n,r,normalize(vec3(1,1,0)),0.,10.,.8,vec3(.2,.2,1))\n\t\t\t\t+light(n,r,normalize(vec3(-.5,.7,.5)),0.,10.,.8,vec3(1,.2,.2))\n\t\t\t\t+light(n,r,normalize(vec3(.5,.7,.5)),0.,100.,.8,vec3(.2,1,.2)))*.8\n        \t\t;\n    \tcomp.xyz=a*col;\n    }\n    \n    if (id==0) {\n        float d0;\n        march(p,vec3(0,1,0),p,d0,FAR,epsilon,id);\n        comp.xyz+=(.05+step(FAR,d0))\n            \t*smoothstep(.5,.48,abs(fract(p.z)-.5))\n        \t\t*smoothstep(.5,.48,abs(fract(p.x)-.5))\n            \t*max(1.-length(p.xz)/10.,0.)\n        \t\t;\n    }\n    comp.xyz=pow(comp.xyz,vec3(.4545));\n}\nvoid mainImage(out vec4 O,vec2 U){\n    if(U.y<1.){return;}\n    \n    vec2 uv=(2.*U-iResolution.xy)/iResolution.y,mouse=(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 look=vec3(0,1,0),\n    ro=vec3(sin(mouse.x+3.),-mouse.y,cos(mouse.x+3.))*9.+look,\n    rd=cam(uv*.2,ro,look);\n    \n    render(ro,rd,O);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}