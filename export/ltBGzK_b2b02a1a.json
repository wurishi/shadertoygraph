{"ver":"0.1","info":{"id":"ltBGzK","date":"1430349348","viewed":2910,"name":"2D Distance Field Visualization","username":"chronos","description":"A simple 2D distance field visualization to experiment with signed distance functions.\nMouse down to specify eye-position, drag to specify ray direction.","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","visualization","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float signedDistanceHorizontal( in vec2 position ) { return position.y; }\nfloat signedDistanceVertical  ( in vec2 position ) { return position.x; }\n\nfloat signedDistanceSphere(in vec2 position, float radius ) { return length(position)-radius; }\nfloat signedDistanceBox(in vec2 p, in vec2 b) { return length(max((abs(p)-b),0.0)); }\n\nfloat unionOperation(in float d1, in float d2 ) { return min(d1,d2); }\n\nfloat scene(in vec2 position ) {\n    float sphere_radius = 0.25;\n\n    vec2 sphere_position = vec2(1.0, sin(iTime)) / 4.0;\n    sphere_position = position - sphere_position;\n\n    vec2 box_position = vec2(0.0, 0.5);\n    vec2 box_size     = vec2(pow(sin(iTime), 2.0), 0.25);\n    \n    // Compute distance functions\n    float plane_distance = signedDistanceVertical(position - vec2(sin(iTime/2.0)-0.75,0.0));\n    float sphere_distance = signedDistanceSphere(sphere_position, sphere_radius );\n\tfloat box_distance = signedDistanceBox(position - box_position, box_size);\n    \n    // Compose distance functions\n    float result = unionOperation(plane_distance, sphere_distance);\n    result = unionOperation(box_distance, result);\n    return result;\n}\n\n// Draws contour lines (level set, isolines)  in gray and zero set in blue.\nvec3 isolines(in vec3 position, float offset) {\n    float l = mod(offset * 08.0, 1.0);\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 border_color = vec3(0.0, 0.0, 1.);\n    float bands = clamp(-100.0 * l * (l - 0.2), 0.0, 1.0);\n    color *= bands;\n    color = mix(color * 0.05, border_color, 1.0-smoothstep(0.00, 0.015, abs(offset)));\n    return color;\n}\n\n// lifted from https://www.shadertoy.com/view/Mss3zH\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n    if(dot(a-b,a-b) == 0.0) return 1.0;\n    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m  = abs(iMouse) / iResolution.xyxy;\n    vec2 c = 2.0 * uv - 1.0;\n    m = 2.0 * m - 1.0;\n    \n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    m.xz *= aspect_ratio; \n    \n    float distance = scene(c);\n    \n    vec3 color = isolines(vec3(c, 0.0), distance);\n    \n    // Mouse input:\n    vec2 mouse_down = m.zw;\n    vec2 mouse_drag = m.xy;\n    vec2 eye = normalize(mouse_drag-mouse_down);\n    vec2 p = mouse_down;\n    \n    for(int i = 0; i < 10; i++) {\n        float sample_distance = scene(p);\n    \tif(sample_distance < 0.01) break;\n    \tfloat cm = 8.0*(length(c - p) - sample_distance); // abs(sample_distance)\n        float circle = smoothstep(0.01, 0.05, cm) * smoothstep(0.01, 0.05, 0.1-cm);\n        color = mix(vec3(0.2, 1.0, 0.2), color, 1.0-circle);\n        p = p + eye * sample_distance;\n    }\n\n    if(any(notEqual(mouse_down, mouse_drag))) {\n    \tfloat d = distanceToSegment(mouse_down, p, c);\n    \tcolor = mix(vec3(1.0, 1.0, 0.0), color, smoothstep(0.005, 0.01, d));\n   \t}\n    color = mix(vec3(0.0, 1.0, 1.0), color, smoothstep(0.03, 0.04, length(c - mouse_down)));\n    color = mix(vec3(1.0, 1.0, 1.0), color, smoothstep(0.03, 0.04, length(c - mouse_drag)));\n\n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    \n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}