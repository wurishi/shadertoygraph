{"ver":"0.1","info":{"id":"7d2XRK","date":"1620625243","viewed":157,"name":"slime mold duo","username":"csgradle","description":"slime mold with two species that separate each other","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["slime","buffer","mold","slimemould","slimemold"],"hasliked":0,"parentid":"fsSSzy","parentname":"slime mold buffers"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 col = texture(iChannel1, uv);\n    \n    \n    //col = vec4(col.x*col.x, col.y*col.y, col.z*col.z, 0.);\n    fragColor = vec4(col.r, 0.,col.b,0.);\n} \n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0.,0.); \n    ivec2 iFragCoord = ivec2(fragCoord); // change pixel location to int\n    int id = int(toID(iFragCoord.xy));\n    \n    //if(iFragCoord.x < PARTICLES && iFragCoord.y == 0) { // only run if the pixel is in the particle slots\n    if(id < PARTICLES){ \n        if(iFrame == 0) { // start conditions; set pos and dir to random\n            fragColor.xy = getRandomPos(float(id));\n            //fragColor.z = getRandomDir(float(id));\n            fragColor.z = getDirOut(fragColor.xy);\n        }\n        \n        if(iFrame>0) { // update every frame\n        \n            // get angle and the velocity, update position\n            fragColor.z = getParticleDir(fragCoord.xy);\n            float angle = getParticleDir(fragCoord.xy);\n            vec2 vel = vec2(cos(angle), sin(angle));\n            vec2 pos = getParticlePos(fragCoord.xy);\n            fragColor.xy = pos + vel * PARTICLE_SPEED * 0.01;\n            \n            \n            vec2 ratio = vec2(iResolution.y/iResolution.x,1.);\n            \n            // get trail strength\n            \n            // red\n            float front = texture(iChannel1, (pos + offset(angle, SEARCH_LEN)) * ratio + 0.5).r*10.;\n            float left = texture(iChannel1, (pos + offset(angle-SEARCH_ANGLE, SEARCH_LEN)) * ratio + 0.5).r*10.;\n            float right = texture(iChannel1, (pos + offset(angle+SEARCH_ANGLE, SEARCH_LEN)) * ratio + 0.5).r*10.;\n            //blue\n            float front2 = texture(iChannel1, (pos + offset(angle, SEARCH_LEN)) * ratio + 0.5).b*10.;\n            float left2 = texture(iChannel1, (pos + offset(angle-SEARCH_ANGLE, SEARCH_LEN)) * ratio + 0.5).b*10.;\n            float right2 = texture(iChannel1, (pos + offset(angle+SEARCH_ANGLE, SEARCH_LEN)) * ratio + 0.5).b*10.;\n            \n            // turn the particles based on the tail strength in front of them\n            float turnAngle = angle;\n            if(mod(id,2.)== 0) { // if red \n                if(front+left+right+left2+right2>0.) {\n                    turnAngle = \n                        ( (angle * front) \n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * left\n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * right\n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * left2\n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * right2)\n                        / (front+left+right+left2+right2);\n                /*\n                    turnAngle = \n                        (angle * front \n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * left \n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * right\n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * right2\n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * left2)\n                        / (front+left+right+right2+left2);*/\n                }\n            } else { // if blue\n                if(front2+left2+right2+left+right>0.) {\n                    turnAngle = \n                        ( (angle * front2) \n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * left2\n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * right2\n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * left\n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * right )\n                        / (front2+left2+right2+left+right);\n                /*\n                    turnAngle = \n                        (angle * front2 \n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * left2 \n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * right2\n                        + (angle-SEARCH_ANGLE*STEER_STRENGTH) * right\n                        + (angle+SEARCH_ANGLE*STEER_STRENGTH) * left)\n                        / (front2+left2+right2+right+left);\n                        */\n                }\n            }\n            fragColor.z = turnAngle + (Hash11(float(id)+iDate.w)-0.5)*0.1;\n            \n            \n            // check for bounds and give it a new random direction when it touches the edge\n            float X = iResolution.x/iResolution.y/2.-PARTICLE_RADIUS*2.;\n                float Y = 0.5-PARTICLE_RADIUS;\n            \n            if(getParticlePos(iFragCoord.xy).x > X) {\n                fragColor.x = X;\n                fragColor.z = getRandomDir(float(id));\n            }\n            if(getParticlePos(iFragCoord.xy).x < -X) {\n                fragColor.x = -X;\n                fragColor.z = getRandomDir(float(id));\n            }\n            if(getParticlePos(iFragCoord.xy).y > Y) {\n                fragColor.y = Y;\n                fragColor.z = getRandomDir(float(id));\n            }\n            if(getParticlePos(iFragCoord.xy).y < -Y) {\n                fragColor.y = -Y;\n                fragColor.z = getRandomDir(float(id));\n            }\n\n        }\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame==0) fragColor = vec4(0.);\n    if(iFrame >0) {\n\n        vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n        float sumRed = 0.;\n        float sumBlue = 0.;\n        for(int i = 0; i < PARTICLES; i++) {\n            vec2 pos = getParticlePos(toPos(i));\n            float d = 1.-step(PARTICLE_RADIUS,length(uv-pos));\n            if(mod(i,2.)== 0) sumRed += d;\n            if(mod(i,2.)== 1) sumBlue += d;\n        }\n        sumRed = min(1., sumRed);\n        sumBlue = min(1., sumBlue);\n        \n        /*\n        vec4 blur = vec4(0.);\n        for(int y = -1; y <= 1; y++) {\n            for(int x = -1; x <= 1; x++) {\n                blur += texelFetch(iChannel1, ivec2(fragCoord.xy)+ivec2(x,y), 0);\n                \n            }\n        }\n        blur /= 9.;\n        */\n        \n        vec2 st = fragCoord / iResolution.xy;\n        vec4 blur = texture(iChannel1, st, 1.1);\n        \n        fragColor = clamp(vec4(sumRed, 0., sumBlue, 0.) + blur - 0.005,0.,1.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PARTICLES 5000\n#define PARTICLE_RADIUS 0.003\n#define PARTICLE_SPEED 0.4\n#define SEARCH_ANGLE 0.3\n#define STEER_STRENGTH 5.\n#define SEARCH_LEN 0.02\n\n#define getParticlePos(p) texelFetch(iChannel0, ivec2(p), 0).xy\n#define getParticleDir(p) texelFetch(iChannel0, ivec2(p), 0).z\n\n#define offset(angle, len) vec2(cos(angle)*len, sin(angle)*len)\n#define mod(a, b) a - int(b * floor(float(a)/float(b)))\n\n#define toID(p) int(float(p.x) + float(p.y)*float(iResolution.x))\n#define toPos(id) vec2(mod(id,iResolution.x), floor(float(id)/float(iResolution.y)))\n\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec2 getRandomPos(in float x) {\n    //return Hash12(x+iDate.w)-0.5;\n    float a = Hash11(x+iDate.w) * 2. * 3.1415926;\n    float r = 0.5 * sqrt(Hash11(x+iDate.w+34.223));\n\n    // If you need it in Cartesian coordinates\n    float xx = r * cos(a);\n    float y = r * sin(a);\n    return vec2(xx,y);\n}\n/*\nvec2 getRandomPos(in float x) {\n    if(mod(int(x), 2.)==0) return vec2(-1., Hash11(x+iDate.w)-0.5); \n    return vec2(1., Hash11(x+iDate.w)-0.5); \n}\n*/\nfloat getRandomDir(in float x){\n    return Hash11(x+iDate.w+30.)*2.*3.14159265;\n}\nfloat getDirOut(in vec2 p) {\n    return atan(p.y/p.x) + 3.1415926 * step(0., -p.x);\n}","name":"Common","description":"","type":"common"}]}