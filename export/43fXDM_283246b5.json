{"ver":"0.1","info":{"id":"43fXDM","date":"1709921416","viewed":93,"name":"Simple Solar Eclipse","username":"berelium","description":"A simple eclipse effect using SDFs. I'm excited for the 2024 solar eclipse, I'll be in a city where I get a perfect view for some photography. Use the mouse to change the moon position!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["simple","sdf","circle","glow","eclipse","blackbody","solar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A simple solar eclipse effect. Achieved with SDF functions. \n// There is mouse interaction to choose the moon's position on click.\n// Added parabola  shape to the moon. Added blackbody palette option.\n// Updated: 3/11/2024\n\n#define USE_BLACKBODY\n#define bias 25. / iResolution.x\n\nvec2 bend(vec2 p, float a) {\n    return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// Thanks to @EvilRyu for the smin/smax function : https://www.shadertoy.com/view/4dtXRn\nfloat smax(float a, float b, float k)\n{\n    float x = exp(k * a);\n    float y = exp(k * b);\n    return (a * x + b * y) / (x + y);\n}\n\n// Thanks to @Shane for his function roughly derived from plancks law\nvec3 blackbody(float i) {\n    float T = 1400.0 + 1400.0 * i; // temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L, vec3(5.0)) * (exp(1.43876719683e5 / (T * L)) - 1.0);\n    return 1.0 - exp(-50e7 / L); // exposure level\n}\n\n\nfloat sun( in vec2 uv ) {\n    float d = 1.0 / length(uv);\n    float i = 5.0;\n    \n#ifndef USE_BLACKBODY\n    d *= 0.8;        // Radius\n    i = 15.0;\n#endif\n    d = pow(d, i); // Itensity\n    \n    return d;\n}\n\nfloat mrad = 0.35;\nfloat moon( in vec2 uv ) {\n    vec2 p = vec2(0);\n    \n    if(iMouse.z > 0.0) {\n        p = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    } else {        \n        float x = sin(2.0 + iTime * 0.125) * 2.0; // Example linear path\n        float y = x * x * 0.05; // Quadratic function for parabolic path with peak at (0,0)\n\n        p = vec2(x, y);\n        p *= smax(0.1, distance(p, vec2(0)) + 0.1, 0.1);\n        \n        p = bend(p, 0.5);\n    }\n    \n    float d = length(uv - p) - mrad;\n\n    d = smoothstep(mrad, mrad+bias, d);\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0);\n    float _sun = sun(uv);\n    float _moon = moon(uv);\n    \n    col += _sun * \n#ifdef USE_BLACKBODY\n        blackbody(smoothstep(0.1, 15., _sun));\n#else\n        vec3(0.886,0.329,0.094);\n#endif\n    col *= _moon;\n    \n#ifdef USE_BLACKBODY\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n#else\n    col = 1.0 - exp( -col );\n#endif\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}