{"ver":"0.1","info":{"id":"3l2GDK","date":"1561155502","viewed":288,"name":"nova 2019 livecoding round 1","username":"lovelyH","description":"This is shader that I have writen on Nova 2019 demoparty during livecoding.\nI made copy after competitioin, and comented out stuff for Bonzomatic so iit will run on shadertoy.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["livecoding","nova","2019","demopary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 410 core\n\n//uniform float fGlobalTime; // in seconds\n//uniform vec2 v2Resolution; // viewport resolution (in pixels)\n\n//uniform sampler1D texFFT; // towards 0.0 is bass / lower freq, towards 1.0 is higher / treble freq\n//uniform sampler1D texFFTSmoothed; // this one has longer falloff and less harsh transients\n//uniform sampler1D texFFTIntegrated; // this is continually increasing\n//uniform sampler2D texChecker;\n//uniform sampler2D texNoise;\n//uniform sampler2D texTex1;\n//uniform sampler2D texTex2;\n//uniform sampler2D texTex3;\n//uniform sampler2D texTex4;\n//float fMidiKnob;\n\n//layout(location = 0) out vec4 out_color; // out_color must be written in order to see anything\n\n//#define time fGlobalTime\n#define time iTime\n#define E 0.001\n#define INF 1000.0\n\n\nvec2 rot( vec2 p, float l){\n\tfloat s=sin(l),c=cos(l);\n\treturn vec2(\n\t\tc*p.x-s*p.y,\n\t\ts*p.x+c*p.y );\n}\n\n\nfloat mlight;\nint mmat;\n\nfloat map(vec3 p){\n\tfloat r=p.z, rc;\n\tvec3 ph;\n\tmlight= INF;\n\tmmat= 0;\n\t\n\tph= p;\n\tph.y= abs(abs(ph.y)-3.0)-3.0;\n\tr= max( r, -max( abs(ph.x)-2.0, abs(ph.y)-2.0 ) );\n\t\n\t// col\n\tph =p;\n\tph.x= abs(ph.x)-9.0;\n\tph.y= abs(abs(abs(ph.y)-9.0)-6.0)-3.0;\n\tr= min( r, length(ph.xy)-1.0 );\n\t\n\tph =p;\n\tph.x= abs(ph.x)-3.0;\n\tph.y= abs(ph.y)-18.0;\n\tr= min( r, length(ph.xy)-1.0 );\n\t//ce\n\tr= min( r, 10.0 - p.z );\n\tph.x= abs(ph.x);\n\tph.z -= 15.0;\n\tph.xz = rot( ph.xz, .3 );\n\tr= max( r,  ph.z );\n\t\n\t//b\n\tph= p;\n\tph.xy= abs(ph.xy)-5.0;\n\tph.y= abs(ph.y)-5.0;\n\tph.z -= .5;\n\tr= min( r, max( abs( length(ph)-.5 ) -.1, ph.z ) );\n\tph.z -= .1 * sin(7.*time);\n\tmlight= min( mlight, length(ph)+.1 );\n\t\n\t//f\n\t//float fp= .5+.3*sin(time) + texture( texFFT, .1 ).r * 200.0;\n    float fp= .5+.3*sin(time);\n\t//float fs= .1*time + 20.*texture( texFFTIntegrated, .2 ).r ;\n    float fs= time;\n\tph=p;\n\tph.z -= 5.;\n\tph.y -= 6.0;\n\tph.xz= rot( ph.xz, .4*fs);\n\tph.yz= rot( ph.yz, .5*fs );\n\t//if( 0.004 < texture( texFFT, .3 ).r )\n    if( mod( time, 5.0 ) < .5 )\n\t\tph.yz= ph.xz;\n\tph.xy= rot( ph.xy, 5.*fs );\n\tph.xy= abs(ph.xy)-fp;\n\tmlight= min( mlight, length(ph)+.1 );\n\tph.yz= rot( ph.yz, .4*fs );\n\tph.xy= rot( ph.xy, 6.*fs );\n\tph.xy= abs(ph.xy)-fp;\n\tmlight= min( mlight, length(ph)+.1 );\n\t\n\t//ct\n\tr= max( r, max(abs(p.x)-12.0, abs(p.y)-21.0 ) );\n\t\n\t//w\n\trc= p.z + 1.0 + .5 * sin(time);\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmmat= 1;\n\t}\n\t\n\tr= min( r, mlight );\n\treturn r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 r= vec3(0);\n\tfloat power= 1.0;\n\tfor(int pa=0;pa<2;pa++){\n\t\tvec3 p;\n\t\tfloat t=0.0, dis, light= INF;\n\t\tbool hit= false;\n\t\tfor(int a=0;a<0x100;a++){\n\t\t\tp= sp + t * dir;\n\t\t\tdis= map(p);\n\t\t\tlight= min( light, mlight );\n\t\t\tif( dis < E ){\n\t\t\t\thit= true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt += dis;\n\t\t}\n\t\tint mat= mmat;\n\t\tfloat plight= mlight;\n\t\t\n\t\tif( hit ){\n\t\t\tvec3 n= normalize(vec3(\n\t\t\t\tmap(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n\t\t\t\tmap(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n\t\t\t\tmap(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n\t\t\t));\n\t\t\t\n\t\t\tvec3 c= mat==1 ? vec3(.1,.5,.9) : vec3(1);\n\t\t\t\n\t\t\tr += power* clamp( c\n\t\t\t\t* .1\n\t\t\t\t* (.5 + .5 *dot(n,-dir) )\n\t\t\t\t* (.5 + .5 *dot(n,vec3(0,0,1)) )\n\t\t\t\t* clamp( 1.0 - 0.01*t, 0.0, 1.0 )\n\t\t\t\t+ (.5 / (1.0 + plight ) )\n\t\t\t\t, 0.0, 1.0 );\n\t\t\t\n\t\t\tif( mat==1 ){\n\t\t\t\tpower *= 0.3;\n\t\t\t\tdir= reflect( dir, n );\n\t\t\t\tsp = p + 4.0 * E * dir;\n\t\t\t}else{\n\t\t\t\tpower= 0.0;\n\t\t\t}\n\t\t}else{\n\t\t\t// sky\n\t\t\tpower = 0.0;\n\t\t}\n\t\tr += vec3(.9,.5,.1) * (2.0 / (1.0 + light ));\n\t\tif( power < E )break;\n\t}\n\treturn r;\n}\n\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\tuv *= 2.0;\n\n  //vec2 m;\n  //m.x = atan(uv.x / uv.y) / 3.14;\n  //m.y = 1 / length(uv) * .2;\n  //float d = m.y;\n\n  //float f = texture( texFFT, d ).r * 100;\n  //m.x += sin( fGlobalTime ) * 0.1;\n  //m.y += fGlobalTime * 0.25;\n\n  //vec4 t = plas( m * 3.14, fGlobalTime ) / d;\n  //t = clamp( t, 0.0, 1.0 );\n  //out_color = f + t;\n\t\n\t\n\tvec3 c, dir;\n\t\n\tif( mod( time, 9.0) < 3.0 ){\n\t\tc= vec3(\n\t\t\t0.0 + sin(.2*time),\n\t\t\t20.0 + sin(.3*time),\n\t\t\t7.0 + sin(.4*time)\n\t\t);\n\t\tdir= normalize(vec3(uv.x,uv.y,-4.0));\n\t\tdir.yz = rot( dir.yz, 1.4 + .1 * sin(.15*time) );\n\t\tdir.xy = rot( dir.xy, 3.1415926535989 + .1 * sin(.15*time) );\n\t}\n\telse if( mod( time, 9.0) < 6.0 ){\n\t\tc= vec3(\n\t\t\t50.0 + sin(.2*time),\n\t\t\t0.0 + sin(.3*time),\n\t\t\t3.0 + sin(.4*time)\n\t\t);\n\t\tdir= normalize(vec3(uv.x,uv.y,-4.0));\n\t\tdir.yz = rot( dir.yz, 1.4 + .1 * sin(.15*time) );\n\t\tdir.xy = rot( dir.xy, 3.1415926535989/2.0 + .1 * sin(.15*time) );\n\t}\n\telse{\n\t\tc= vec3(\n\t\t\t40.0 * sin(.2*time),\n\t\t\t40.0 * cos(.2*time),\n\t\t\t7.0 + sin(.4*time)\n\t\t);\n\t\tdir= normalize(vec3(uv.x,uv.y,-4.0));\n\t\tdir.yz = rot( dir.yz, 1.4 + .1 * sin(.15*time) );\n\t\tdir.xy = rot( dir.xy, 3.1415926535989 -.2*time);\n\t}\n\t\n\t\n\tfragColor.xyz = render( c, dir );\n}\n","name":"Image","description":"","type":"image"}]}