{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct PointLight {\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\nstruct Material {\n    vec3 color;\n    float reflectivity;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material material;\n};\n    \nstruct Trace {\n   bool hit;\n   vec3 pos;\n   vec3 normal;\n};\n    \nconst int SAMPLES = 4;\nconst int LIGHT_COUNT = 3;\nconst int SPHERE_COUNT = 4;\nconst int BOUNCES = 5;\nPointLight lights[LIGHT_COUNT];\nSphere spheres[SPHERE_COUNT];\n\n// from stack overflow\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// yeah probably no good\nvec3 rand3(vec2 co){\n    return normalize(vec3(\n        rand(co)-0.5,\n        rand(co + vec2(1.0)),\n        rand(co + vec2(-1.0))\n    )-vec3(0.5));\n}\n\nTrace traceSphere(vec3 origin, vec3 ray, Sphere sphere) {\n    Trace trace = Trace(false, vec3(0.0), vec3(0.0));\n    \n    float rayDotSphere = dot(origin-sphere.pos, ray);\n    float sphereDist = length(origin - sphere.pos);\n    float discriminant = rayDotSphere*rayDotSphere - sphereDist*sphereDist + sphere.radius*sphere.radius;\n    if (discriminant >= 0.0) {\n    \tfloat t = -rayDotSphere - sqrt(discriminant);\n        if (t > 0.0) {\n            trace.hit = true;\n        \ttrace.pos = origin + ray * t;\n        \ttrace.normal = normalize(trace.pos - sphere.pos);\n        }\n    }\n    return trace;\n}\n\nfloat occlusion(Trace trace, vec3 ray, float dist) {\n    float occ = 0.0;\n    for (int i = 0; i < SPHERE_COUNT; i++) {\n        Trace innerTrace = traceSphere(trace.pos, ray, spheres[i]);\n        float depth = distance(innerTrace.pos, trace.pos);\n        if (innerTrace.hit && depth < dist) {\n            occ = 1.0;\n        }\n    }\n    return occ;\n}\n\nvec3 diffuseColor(PointLight light, Trace trace) {\n    vec3 connector = normalize(light.pos - trace.pos);\n    float attenuation = light.intensity / distance(light.pos, trace.pos);\n    \n    if (occlusion(trace, connector, distance(light.pos, trace.pos)) > 0.0) {\n        attenuation = 0.0;\n    }\n    \n    return max(dot(connector, trace.normal) * light.color * attenuation, 0.0);\n}\n\nvec3 traceRay(vec3 origin, vec3 ray) {\n    vec3 surfaceColor = vec3(0.0);\n    float attenuation = 1.0;\n\n    for (int b = 0; b < BOUNCES; b++) {\n    \tfloat closestDepth = 999.0;\n    \tTrace closestTrace = Trace(false, vec3(0.0), vec3(0.0));\n        int closestTraceIndex = 0;\n        Material material = Material(vec3(1.0), 0.0);\n        \n    \tfor (int i = 0; i < SPHERE_COUNT; i++) {\n        \tTrace trace = traceSphere(origin, ray, spheres[i]);\n            float depth = distance(origin, trace.pos);\n        \tif (trace.hit && depth < closestDepth) {\n            \tclosestDepth = depth;\n            \tclosestTrace = trace;\n                closestTraceIndex = i;\n                material = spheres[i].material;\n        \t}\n    \t}\n        \n        float totalAttentuate = attenuation*(1.0-material.reflectivity);\n    \tif (closestTrace.hit) {\n        \t//surfaceColor += ambient * totalAttentuate;\n        \t/*for (int j = 0; j < LIGHT_COUNT; j++) {\n            \tsurfaceColor += diffuseColor(lights[j], closestTrace) * totalAttentuate;\n        \t}*/\n            for (int k = 0; k < SAMPLES; k++) {\n                vec2 seed = ray.xy + vec2(float(k));\n                vec3 randVec = rand3(seed);\n                if (dot(randVec, closestTrace.normal) < 0.0) {\n                    randVec *= -1.0;\n                }\n            \tsurfaceColor += material.color * (1.0-occlusion(closestTrace, randVec, 999.0)) * texture(iChannel0, randVec).rgb * totalAttentuate / float(SAMPLES);\n            }\n    \t} else {\n            surfaceColor += material.color*texture(iChannel0, ray).rgb * totalAttentuate;\n            break;\n        }\n        attenuation *= material.reflectivity;\n        origin = closestTrace.pos;\n        ray = normalize(ray + 2.0 * closestTrace.normal);\n    }\n    return surfaceColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = 2.0 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy;\n    vec2 uvMouse = 2.0 * (iMouse.xy - iResolution.xy * 0.5) / iResolution.yy;\n    vec3 camera = vec3(1.0, 1.0, -2.0);\n\n    lights[0] = PointLight(vec3(0.0, 3.0, 3.0), vec3(1.0), 2.5);\n    lights[1] = PointLight(vec3(-1.0, -2.0, 2.0), vec3(1.0, 0.5, 0.1), 1.0);\n    \n    spheres[0] = Sphere(\n        vec3(2.0*cos(iTime), 2.0*sin(iTime), 9.0),\n        2.0,\n    \tMaterial(vec3(1.0), 0.8)\n    );\n    spheres[1] = Sphere(\n        vec3(uvMouse * (7.0 - camera.z) / -camera.z, 10.0),\n        2.0,\n        Material(vec3(0.5, 0.8, 1.0), 0.2)\n    );\n    spheres[2] = Sphere(\n        vec3(0.0, -1005.0, 0.0),\n        1000.0,\n        Material(vec3(0.5, 0.5, 0.5), 0.2)\n    );\n    spheres[3] = Sphere(\n        vec3(4.0*sin(iTime), 4.0*cos(iTime), 7.0),\n        1.0,\n    \tMaterial(vec3(1.0), 0.8)\n    );\n\n    \n    vec3 ray = normalize(vec3(uv * camera.xy, 0.0) - vec3(0.0, 0.0, camera.z));\n   \t\n    vec3 surfaceColor = traceRay(vec3(0.0, 0.0, camera.z), ray);\n    fragColor = vec4(surfaceColor, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tB3Rz","date":"1426538577","viewed":234,"name":"Bae Tracer","username":"marmph","description":"bae caught me tracin","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracer"],"hasliked":0,"parentid":"","parentname":""}}