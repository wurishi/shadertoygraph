{"ver":"0.1","info":{"id":"4dVcRy","date":"1522483883","viewed":908,"name":"Old Film Look","username":"saabi","description":"Renders video with an old film look.\n\nYou can adjusts settings at the start of the code in Buf A","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["film"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = vec4(0.0);\n    for (float i=0.0; i<10.0; i++) {\n        c += texture(iChannel0, uv + vec2(0.0,i/iResolution.y));\n    }\n    fragColor = c/10.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float scale = 0.57 * 0.7;\nconst float separation = 1.2;\nconst float filmWidth = 1.4;\nconst float smallJitterProbability = 0.82;\nconst vec2 smallJitterDisplacement = vec2(0.03);\nconst float largeJitterProbability = 0.05;\nconst vec2 largeJitterDisplacement = vec2(0.3);\nconst float angleJitter = 60.0*3.1415/180.0;\nconst float angleProbability = 0.15;\nconst float contrast = 2.0;\nconst float brightness = 1.2;\nconst float vignettePower = 3.0;\nconst float sepiaStrength = 1.0;\n\nfloat time() {\n    return iTime * 0.0101;\n}\n\nfloat hash(float n) {\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nvec2 hash2(vec2 n) {\n \treturn vec2(hash(n.x*23.62-300.0+n.y*34.35),hash(n.x*45.13+256.0+n.y*38.89)); \n}\n\nfloat worley(vec2 c, float time) {\n    float dis = 1.0;\n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++){\n            vec2 p = floor(c)+vec2(x,y);\n            vec2 a = hash2(p) * time;\n            vec2 rnd = 0.5+sin(a)*0.5;\n            float d = length(rnd+vec2(x,y)-fract(c));\n            dis = min(dis, d);\n        }\n    return dis;\n}\n\nfloat worley2(vec2 c, float time) {\n    float w = 0.0;\n    float a = 0.5;\n    for (int i = 0; i<2; i++) {\n        w += worley(c, time)*a;\n        c*=2.0;\n        time*=2.0;\n        a*=0.5;\n    }\n    return w;\n}\nfloat worley5(vec2 c, float time) {\n    float w = 0.0;\n    float a = 0.5;\n    int i = 0;\n    for (int i = 0; i<5; i++) {\n        w += worley(c, time)*a;\n        c*=2.0;\n        time*=2.0;\n        a*=0.5;\n    }\n    return w;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 jitter(vec2 uv, vec2 s, float seed) {\n\treturn vec2(rand(vec2(time(),seed))-0.5, rand(vec2(time(),seed+0.11))-0.5)*s;    \n}\n\nvec2 rot(vec2 coord, float a) {\n    float sin_factor = sin(a);\n    float cos_factor = cos(a);\n    return coord * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n}\n\nvec4 vignette(vec2 uv, float strength) {\n    float l = length(uv);\n    l = pow(l, vignettePower);\n\treturn 1.0 - vec4(vec3(l)*strength,1.0);\n}\n\nvec4 bw(vec4 c) {\n    float v = c.r*.15+c.g*.8 + c.b*.05;\n    return vec4(vec3(v),1.0);\n}\n\nvec4 sepia(vec4 c, float s) {\n\tfloat or = (c.r * .393) + (c.g *.769) + (c.b * .189);\n\tfloat og = (c.r * .349) + (c.g *.686) + (c.b * .168);\n\tfloat ob = (c.r * .272) + (c.g *.534) + (c.b * .131);\n    return vec4(or,og,ob,1.0);\n}\n\nvec4 frame(vec2 uv, float fn) {\n    if (abs(uv.x) > 0.5 || abs(uv.y) > 0.5) return vec4(0.0);\n\n    float strength = 64.0;\n    float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (iTime * 10.0);\n\tvec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n\n    vec4 i = texture( iChannel0 , uv+0.5);\n    float fnn = floor((fn+0.5)/separation)+float(iFrame);\n    fnn = mod(fnn/20.0,1.0);\n    float fj = rand(vec2(fnn, 0.34))*2.;\n\n    \n    vec4 ic = vec4(((i.rgb-0.5)*contrast-0.5+brightness)*fj,1.0);\n    ic *= vignette(uv*2.5, 0.2);\n    vec4 bwc = bw(ic);\n    \n    uv.x *= 100.0 + iTime*.10;\n    uv.y *= 100.;\n    float dis = worley5(uv/64.0, + iTime*50.0);\n    vec3 c = mix(vec3(-1.0), vec3(10.), dis);\n    vec4 spots = vec4(clamp(c,0.0,1.0), 1.0);\n    \n\treturn mix(i, sepia(bwc,1.0), sepiaStrength)*(1.0-grain) * spots;\n}\n\nvec4 film(vec2 uv) {\n    float wm = 0.5 + (filmWidth-1.0)/4.0;\n    float ww = (filmWidth-1.0)*0.1;\n    float ax = abs(uv.x);\n    if (ax > filmWidth/2.0 || (ax > wm-ww && ax < wm+ww && mod(floor(uv.y*12.0),2.0) == 1.0))\n\t    return vec4(vec3(1.0), 1.0);\n\n    uv.x *= 2000.10 ;\n    uv.y *= 5.;\n    float dis = worley2(uv/64.0, + iTime*50.0);\n    vec3 c = mix(vec3(1.0), vec3(-30.6), dis);\n    return vec4(clamp(1.0-c*c,0.0,1.0), 1.0);\n}\n\n\nvec4 final(vec2 uv, float aspect) {\n    float smallJitterTrigger = rand(vec2(time(),0.125));\n    float largeJitterTrigger = rand(vec2(time(),0.122));\n    vec2 juv = uv;\n    juv += ((smallJitterTrigger > smallJitterProbability) ? vec2(0.) : jitter(uv, smallJitterDisplacement,0.01));\n    juv += ((largeJitterTrigger > largeJitterProbability) ? vec2(0.) : jitter(uv, largeJitterDisplacement,0.01));\n\n    float rotationTrigger = rand(vec2(time(),0.123));\n\tjuv = (rotationTrigger > angleProbability) ? juv : rot(juv, (rand(vec2(time(),0.14))-0.5)*angleJitter);\n    \n    vec2 fuv = vec2(juv.x*aspect, (mod(juv.y+0.5,separation)-0.5));\n\n    return (frame(fuv, juv.y)  + film(vec2(juv.x*aspect,juv.y))) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord)/iResolution.xy - 0.5);\n    vec2 vuv = uv;\n    uv /= scale;\n    float aspect = iResolution.y/iResolution.x;\n    uv *= vec2(1.0,aspect);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = final(uv, aspect) * vignette(vuv*1.5,0.5);\n}","name":"Buf A","description":"","type":"buffer"}]}