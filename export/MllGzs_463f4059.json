{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357-7.5312) * 43758.236237153);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn 2.*vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-1.;\n}\n\nfloat vnoise(vec2 x)//Value noise\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return  2.*mix(mix( hash(p),hash(p + vec2(1.,0.)),f.x),\n                  mix( hash(p+vec2(0.,1.)), hash(p+1.),f.x),f.y)-1.;\n            \n}\n\nmat2 m2= mat2(.8,.6,-.6,.8);\n\n\nfloat dvnoise(vec2 p)//Value noise + value noise with rotation\n{\n    return .5*(vnoise(p)+vnoise(m2*p));    \n}\n\nfloat iqnoise( in vec2 x )//iqnoise adapted from voronoise (Perlin noise)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-1; j<=2; j++ )//kernel limitations to increase performances :\n    for( int i=-1; i<=2; i++ )//4x4 instead of 5x5\n    {\n        if(i+j>3||i+j<-1)continue;//kernel limitations to increase performances :\n        if(i-j>2||i-j<-2)continue;//removes 4 corners\n        vec2 g = vec2( float(i),float(j) );\n\t\tfloat o = hash( p + g );\n\t\tvec2 r = g - f ;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww =  1.0-smoothstep(0.0,1.4142,sqrt(d));\n\t\tva += o*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\nfloat gnoise( in vec2 p )// gradient noise from iq\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\nconst int m0=-2,m1=1;\nfloat voronoise(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    //vec2 r = vec2(2.);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=m0; i<=m1; i++) \n\tfor (int j=m0; j<=m1; j++) \n\tfor (int k=m0; k<=m1; k++)\n\t{\n\t\tvec3 o = vec3(i, j, k);       \t\t\n        vec3 pp = fp +o +hash(ip - o);\n        float d = dot(pp, pp)*.5;\n        d=clamp(d,0.,1.);d=sqrt(d);\n        //d = d*d*(3.0-2.0*d);       \n        d = d*d*d*(d*(d*6. - 15.) + 10.);\n        float w =  1.0-d;//smoothstep(0.0,1.,d);\n        va += w*d;\n        wt += w;\n\t}    \n    return va/wt;\n}\n\nvec2 hash2b( vec2 p )\n{\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-2; i<=1; i++) \n\tfor (int j=-2; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);       \t\t\n        vec2 pp = fp +o -hash2b(ip - o)+.5;\n        float d = dot(pp, pp)*.5;\n        d=clamp(d,0.,1.);d=sqrt(d);\n        //d = d*d*(3.0-2.0*d);       \n        d = d*d*d*(d*(d*6. - 15.) + 10.);\n        float w =  1.0-d;//smoothstep(0.0,1.,d);\n        va += w*d;\n        wt += w;\n\t}    \n    return va/wt*2.-1.;\n}\n\n\nfloat noise( vec2 p){\n    \n    if(p.y>0.){\n    if(p.x>0.)return dvnoise(p);\n        return vnoise(p);}\n    if(p.x>0.)return iqnoise(p);\n    return gnoise(p*.5);\n    //return (voronoise(p*.5))*1.;\n}\n\nfloat fbm( vec2 p ) {\n\t\n\tfloat f=4.,a=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<6;i++){\t\n\t\tr += a\t* abs(noise( p*f ) );       \n\t\ta *= .5; f *=2.;\n\t}\n\treturn r/2.;\n}\n\n\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p = 2.*fragCoord.xy /iResolution.xy-1.;\n\tfloat seed = 1.;\n\tfloat r;\n\tr = (noise(p*10.))+.5;\n    r = fbm(p*4.);\n    r = 2.*r-1.;\n\tfragColor = clamp(vec4(r*r, r*r*r, r, 1.0),0.,1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MllGzs","date":"1424524483","viewed":348,"name":"Comparing noises","username":"guil","description":"upper left : standard value noise    upper right : value noise + value noise with rotation\nlower left : gradient noise              lower right : perlin version of iqnoise from voronoise\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlin"],"hasliked":0,"parentid":"","parentname":""}}