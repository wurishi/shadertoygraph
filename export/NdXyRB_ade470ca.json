{"ver":"0.1","info":{"id":"NdXyRB","date":"1642248916","viewed":159,"name":"Macroscopic LBM Shallow Water","username":"NicoEl","description":"Based on:\nMacroscopic Lattice Boltzmann for Shallow Water Equations (MacLABSWE) by Jian Guo Zhou\nhttps://arxiv.org/abs/1902.02999\n\nSpace: Toggle View Mode\nQ: Toggle Force Input Mode (Height / Velocity Injection)\nW: Toggle Water\nR: Reset Simulation","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["fluid","lbm","latticeboltzmann","shallowwater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Macroscopic LBM Shallow Water by Nico Ell\n// Contact: nico@nicoell.dev\n\n\n// ----------------------------------------------------------\n// Triangulator by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/lllGRr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define ITR 50\n#define FAR 1000.\n#define BASECOLOR vec3(0.05,0.1,0.85)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(0.934, 0.358, -0.358, 0.934);\nfloat tri(in float x){return abs(fract(x)-0.5);}\n\nfloat heightmap(in vec2 p)\n{\n    vec2 uv = (p.xy * .005);\n    uv.y += .45;\n    uv.x -= 0.5;\n    float waterDepth = texture(iChannel0, uv).z;\n    float terrainHeight = texture(iChannel0, uv).w;\n    if (ReadKey(iChannel3, kToggleWater, true))\n    {\n        return terrainHeight;\n    } else\n    {\n        return (terrainHeight + waterDepth);\n    }\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y)+1e-9;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.5;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.5, iq.z+.5);\n    vec2 p2 = vec2(iq.x+.5, iq.z-.5);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.5*sw, iq.z+.5*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.5*sw,.5*sw),vec2(-.5,.5),vec2(.5,-.5), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 3.)*.9;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.01;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n// ----------------------------------------------------------\n\n// From https://www.shadertoy.com/view/Xdy3zG\n//fancy function to compute a color from the velocity\nvec4 computeColor(float normal_value)\n{\n    vec3 color;\n    if(normal_value<0.0) normal_value = 0.0;\n    if(normal_value>1.0) normal_value = 1.0;\n    float v1 = 0.01/7.0;\n    float v2 = 2.0/7.0;\n    float v3 = 3.0/7.0;\n    float v4 = 4.0/7.0;\n    float v5 = 5.0/7.0;\n    float v6 = 6.0/7.0;\n    //compute color\n    if(normal_value<v1)\n    {\n      float c = normal_value/v1;\n      color.x = 140.*(1.-c);\n      color.y = 70.*(1.-c);\n      color.z = 19.*(1.-c) + 91.*c;\n    }\n    else if(normal_value<v2)\n    {\n      float c = (normal_value-v1)/(v2-v1);\n      color.x = 0.;\n      color.y = 255.*c;\n      color.z = 91.*(1.-c) + 255.*c;\n    }\n    else if(normal_value<v3)\n    {\n      float c = (normal_value-v2)/(v3-v2);\n      color.x =  0.*c;\n      color.y = 255.*(1.-c) + 128.*c;\n      color.z = 255.*(1.-c) + 0.*c;\n    }\n    else if(normal_value<v4)\n    {\n      float c = (normal_value-v3)/(v4-v3);\n      color.x = 255.*c;\n      color.y = 128.*(1.-c) + 255.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v5)\n    {\n      float c = (normal_value-v4)/(v5-v4);\n      color.x = 255.*(1.-c) + 255.*c;\n      color.y = 255.*(1.-c) + 96.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v6)\n    {\n      float c = (normal_value-v5)/(v6-v5);\n      color.x = 255.*(1.-c) + 107.*c;\n      color.y = 96.*(1.-c);\n      color.z = 0.;\n    }\n    else\n    {\n      float c = (normal_value-v6)/(1.-v6);\n      color.x = 107.*(1.-c) + 223.*c;\n      color.y = 77.*c;\n      color.z = 77.*c;\n    }\n    return vec4(color.r/255.0,color.g/255.0,color.b/255.0,1.0);\n}\n\n// ----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 velocityHeight = texture(iChannel0, uv);\n    \n    vec4 mixedColor;\n    if (!ReadKey(iChannel3, kViewMode, true))\n    {\n        if (ReadKey(iChannel3, kToggleWater, true))\n        {\n            mixedColor = vec4(computeColor((velocityHeight.w / MaxShallowWaterDepth)).xyz, 1.0);\n        }\n        else\n        {\n            mixedColor = vec4(computeColor((velocityHeight.z / MaxShallowWaterDepth)).xyz, 1.0);\n        }\n    }\n    else\n    {\n        vec2 eps = vec2(0.1, 0.0);\n    \n        vec2 st = fragCoord.xy / iResolution.xy;\n        float finv = tan(40.0 * 0.5 * pi / 180.0);\n        float aspect = iResolution.x / iResolution.y;\n        st.x = st.x * aspect;\n        st = (st - vec2(aspect * 0.5, 0.95)) * finv;\n\n        vec3 ro = vec3(0., 75., 0.);\n        vec3 rd = normalize(vec3(st, .5));\n\n        float rz = march(ro,rd);\n        vec3 col = vec3(0.);\n\n        if ( rz < FAR ) \n        {\n            vec3 pos = ro+rz*rd;\n            vec3 nor= normal(pos);\n            vec3 ligt = normalize(vec3(-.2, 0.05, -0.2));\n\n            float dif = clamp(dot( nor, ligt ), 0., 1.);\n            float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0), 3.);\n            vec3 brdf = 2.*vec3(0.10,0.11,0.1);\n            brdf += 1.9*dif*vec3(.8,1.,.05);\n            col = BASECOLOR;\n            col = col*brdf + fre*0.5*vec3(.7,.8,1.);\n        }\n        col = clamp(col,0.,1.);\n        col = pow(col,vec3(.9));\n        col *= pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1);\n        \n        mixedColor = vec4(col, 1.0);\n    }\n\n\n    fragColor = mixedColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Very bad \"wind\"\nvec2 GetWind(vec2 uv)\n{\n\treturn sin(iTime) * WindAmplitude * vec2(-cos(uv.y * pi * 4.0), 0);\n}\n\nfloat GetTerrainHeight(vec2 uv)\n{\n\tfloat h = (0.4 * max(cos(uv.x * pitwo), cos(uv.y * pitwo)) + 0.6);\n\treturn h * TerrainHeightScale;\n}\n\nstruct Config\n{\n\t// ----------------------------------------------------------\n\t// governing parameters\n\tfloat g;\n\tfloat DeltaX; // LatticeSize at which Simulation is performed\n\tfloat dMax; // Maximum Depth of Water in Meter\n\n\t// ----------------------------------------------------------\n\t// derived parameters\n\tfloat DeltaT;\n\tfloat vMin; // min viscosity derived from d\n\tfloat e; // particle speed\n\tfloat uMagMax; // maximum magnitude of velocity\n\tfloat hMax; // maximum\n\n\tfloat Cb; // Bed Friction Coefficient\n\n\tvec4 dnms;\n};\n\nConfig initCfg()\n{\n\tConfig cfg;\n\n\tcfg.g = Gravity;\n\tcfg.DeltaX = LatticeSize; // LatticeSize at which Simulation is performed\n\tcfg.dMax = MaxShallowWaterDepth; // Maximum Depth of Water in Meter\n\n\t// ----------------------------------------------------------\n\t// Derive parameters from g, DeltaX and dMax to support stable simulation\n\n\tcfg.DeltaT = cfg.DeltaX / sqrt(cfg.g * cfg.dMax);\n\t// Min supported Viscosity for Stability\n\tcfg.vMin = sqrt(cfg.g * cfg.dMax) * cfg.DeltaX / 6.0;\n\tcfg.vMin *= ViscosityModifier;\n\tcfg.e = (6.0 * cfg.vMin) / cfg.DeltaX;\n\tcfg.uMagMax = cfg.e / 6.0;\n\n\tcfg.Cb = BedFrictionCoefficient;\n\n\t// Premultiply denominators\n\tfloat ePow2 = cfg.e * cfg.e;\n\n\t// ePow2 == cfg.dMax * cfg.g;\n\t// cfg.DeltaX == (cfg.e * cfg.e) / cfg.g;\n\n\tcfg.dnms.x = 1. / (6. * ePow2);\n\tcfg.dnms.y = 1. / (3. * ePow2);\n\tcfg.dnms.z = 1. / (2. * ePow2 * ePow2);\n\tcfg.dnms.w = 1. / ePow2;\n\n\treturn cfg;\n}\nvoid readSimData(vec2 uv, out vec2 u, out float d)\n{\n\tvec3 r = texture(iChannel0, uv).xyz;\n\tu = r.xy;\n\td = r.z;\n}\n\nvec3 macLABSWE(Config cfg, vec2 fragCoord)\n{\n\t// 5 6 7\n\t//\t\\|/     // D2Q9\n\t// 0-C-1    // Unweighted raw vectors\n\t//\t/|\\     // These need to be weighted with MacroscopicParticleSpeed\n\t// 2 3 4\n\tconst vec2 latticeDirs[8] = vec2[](vec2(-1, 0), vec2(1, 0), vec2(-1, -1), vec2(0, -1), vec2(1, -1), vec2(-1, 1), vec2(0, 1), vec2(1, 1));\n\tconst vec2 forceWeights = vec2(1.0 / 3.0, 1.0 / 12.0);\n\n\tvec2 texelSize = vec2(1.0) / iResolution.xy;\n\tvec2 uv = fragCoord * texelSize;\n\n\t// ----------------------------------------------------------\n\tvec2 externalForce = vec2(0., 0.);\n\texternalForce += GetWind(uv);\n\tfloat heightInjection = 0.;\n\n\t// User Force Input\n\tif (ReadKey(iChannel3, kMouseInputType, true))\n\t{\n\t\tif (iMouse.z > 0.1 && distance(iMouse.xy, fragCoord) < MouseRadius)\n\t\t{\n\t\t\texternalForce += MouseForce;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (iMouse.z > 0.1 && distance(iMouse.xy, fragCoord) < MouseRadius)\n\t\t{\n\t\t\theightInjection = MouseHeightInjection;\n\t\t}\n\t}\n\n\t// ----------------------------------------------------------\n\tfloat dCenterHalf;\n\tfloat zb = GetTerrainHeight(uv);\n\tvec2 uNew;\n\tfloat dNew;\n\n\t// ----------------------------------------------------------\n\t// Center Lattice\n\t{\n\t\tvec2 u;\n\t\tfloat d;\n\t\t// readSimDataCube(uv, cubeFaceIdx, u, d);\n\t\treadSimData(uv, u, d);\n\t\td += heightInjection;\n\t\tdCenterHalf = d * 0.5;\n\n\t\tfloat feq_c = -5. * cfg.g * d * cfg.dnms.x;\n\t\tfeq_c -= 2.0 * dot(u, u) * cfg.dnms.y;\n\n\t\tdNew = feq_c * d + d;\n\t}\n\n\t// ----------------------------------------------------------\n\t// Neighbours\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tbool isDiagonalLattice = !(i == 0 || i == 1 || i == 3 || i == 6);\n\t\tvec2 e_i = -latticeDirs[i] * cfg.e;\n\t\tvec2 uv_i = uv - latticeDirs[i] * texelSize;\n\n\t\tvec2 u_i;\n\t\tfloat d_i;\n\t\treadSimData(uv_i, u_i, d_i);\n\t\tfloat zb_i = GetTerrainHeight(uv_i); // seabed elevation\n\n\t\t// ----------------------------------------------------------\n\t\t// Local Equilibrium\n\t\tfloat eDotu = dot(e_i, u_i);\n\t\tfloat feq_i = cfg.dnms.x * (cfg.g * d_i - dot(u_i, u_i));\n\t\tfeq_i += eDotu * (eDotu * cfg.dnms.z + cfg.dnms.y);\n\t\tfeq_i *= isDiagonalLattice ? 0.25 * d_i : d_i;\n\n\t\t// ----------------------------------------------------------\n\t\t// Force Term\n\t\tfloat dAverage = 0.5 * d_i + dCenterHalf;\n\t\tvec2 bTau = cfg.Cb * u_i * length(u_i); // bed sheer stress\n\t\tvec2 f = externalForce - bTau;\n\n\t\tfloat relDepth = cfg.g * dAverage * cfg.dnms.w; // relative water depth in range 0..1 (if within stability limits)\n\t\tfloat f_i = relDepth * (zb_i - zb);\n\t\tf_i += cfg.DeltaT * cfg.dnms.w * dot(e_i, f);\n\t\tf_i *= isDiagonalLattice ? 1. / 12. : 1. / 3.;\n\n\t\t// ----------------------------------------------------------\n\t\t// Accumulate\n\t\tfloat dNew_i = feq_i + f_i;\n\t\tdNew += dNew_i;\n\t\tuNew += e_i * dNew_i;\n\t}\n\n\t// ----------------------------------------------------------\n\t// Velocity Division\n\tif (dNew > 0.)\n\t{\n\t\t// Enforce Stability conditions\n\t\tuNew = uNew / dNew;\n\n\t\tdNew = smoothmin(dNew, 0.96 * cfg.dMax, 0.2 * cfg.dMax);\n\n\t\tfloat uMag = length(uNew);\n\t\tif (uMag > 0.)\n\t\t{\n\t\t\tuNew /= uMag;\n\t\t\tuNew *= min(uMag, cfg.uMagMax);\n\t\t}\n\t}\n\telse\n\t{\n\t\tuNew = vec2(0., 0.);\n\t\tdNew = 0.;\n\t}\n\n\treturn vec3(uNew, dNew);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 texelSize = vec2(1.) / iResolution.xy;\n\tvec2 uv = fragCoord * texelSize;\n\tConfig cfg = initCfg();\n\n\tif (ReadKey(iChannel3, kResetSimulation, false) || iFrame == 0)\n\t{\n\t\tvec2 initVelocity = vec2(cfg.uMagMax, 0);\n\t\tfloat initHeight = RelInitialWaterDepth * MaxShallowWaterDepth;\n\t\tfloat terrainHeight = GetTerrainHeight(uv);\n\n\t\tfragColor = vec4(initVelocity, max(initHeight - terrainHeight, 0.0), terrainHeight);\n\t\treturn;\n\t}\n\n\tvec3 ud = macLABSWE(cfg, fragCoord);\n\n\tfragColor = vec4(ud, GetTerrainHeight(uv));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.141\n#define pitwo 6.28318\n\n#define Gravity 9.81\n// LatticeSize at which Simulation is performed\n#define LatticeSize 5.5\n// Maximum Depth of Water in Meter\n#define MaxShallowWaterDepth 5.0\n#define RelInitialWaterDepth 0.75\n// Guaranteed stable at 1.0\n#define ViscosityModifier 1.\n#define BedFrictionCoefficient 0.0\n#define TerrainHeightScale 5.\n#define WindAmplitude .0\n\n// User Input\n#define MouseRadius 25.0\n#define MouseForce vec2(10., 0)\n#define MouseHeightInjection .1\n\n// Keys\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\nconst int kViewMode = kSpace;\nconst int kMouseInputType = kQ;\nconst int kResetSimulation = kR;\nconst int kToggleWater = kW;\n\nbool ReadKey(sampler2D textureChannel, int key, bool toggle )\n{\n\tfloat keyVal = texture( textureChannel, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat smoothmin(float a, float b, float k)\n{\n    // Inigo Quilez; https://iquilezles.org/articles/smin\n\tfloat h = max(k - abs(a - b), 0.0) / k;\n\treturn min(a, b) - h * h * k * (1.0 / 4.0);\n}\n","name":"Common","description":"","type":"common"}]}