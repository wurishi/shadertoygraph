{"ver":"0.1","info":{"id":"43jXzW","date":"1710328510","viewed":59,"name":"n-gon SDF hardcoding tutorial","username":"wd4q5dy","description":"[code]\np -= 2.0*min(dot(k.wy,p),0.0)*k.wy;\np -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n[/code]\nk is a vec4 because it reduces vec2(-k.x, k.y) (in the original) to k.wy\n\nhope it helps\n([url]https://www.shadertoy.com/view/MtKcWW[/url])","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","polygon","ngon","regular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttps://www.shadertoy.com/view/MtKcWW\nSDF for any N: (uses lots of trigs, NOT recommended)\n\nfloat sdNGon (vec2 p, float r, float n) {\n    float an = 6.2831853/n;\n    float he = r*tan(0.5*an);\n    \n    r = abs(r);\n    p = -p.yx;\n    float bn = an * floor(atan(p.y,p.x)/an + 0.5);\n    vec2 cs = vec2(cos(bn),sin(bn));\n    p = mat2(cs.x,-cs.y,cs.y,cs.x)*p;\n\n    return length(p-vec2(r,clamp(p.y,-he,he)))*sign(p.x-r);\n}\n\n*/\n\n/*\n\nHardcoding N-gons:\n\nlet (1)  =>  p -= 2.0*min(dot(k.wy,p),0.0)*k.wy;\nlet (2)  =>  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n\n** (1) and (2) are put alternately\n\nif N is odd (works for all integer N > 2 but there is a better way for even N):\n\n    line 78  ->  p.y = -p.y;\n    \n    line 80:\n    \n    every (1) and (2) gives support to 2 extra sides\n    \n    a pentagon would have (1) (2) (1)\n    a heptagon would have (1) (2) (1) (2)\n    a  nonagon would have (1) (2) (1) (2) (1)\n       (9-gon)\n\nif N is even (does NOT work for odd N):\n\n    line 62  ->   p = abs(p);\n    \n    line 64:\n\n    every (1) and (2) gives support to 4 extra sides\n    \n    a square  and a hexagon would have (1)\n    a octagon and a decagon would have (1) (2)\n                    (10-gon)\n*/\n\nfloat sdOctagon(vec2 p, float r) {\n    const int sides = 8; // e.g. octagon (8 sides)\n    const float pi = 3.14159265358;\n    const vec4 k = vec4(cos(pi/float(sides)), sin(pi/float(sides)), tan(pi/float(sides)), -cos(pi/float(sides)));\n    \n    r = abs(r);\n\n    p = abs(p); // as N is even\n    \n    p -= 2.0*min(dot(k.wy,p),0.0)*k.wy; // (1) (up to 4 sides)\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy; // (2) (up to 8 sides)\n    \n\tp -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHeptagon(vec2 p, float r) {\n    const int sides = 7; // e.g. heptagon (7 sides)\n    const float pi = 3.14159265358;\n    const vec4 k = vec4(cos(pi/float(sides)), sin(pi/float(sides)), tan(pi/float(sides)), -cos(pi/float(sides)));\n    \n    r = abs(r);\n\n    p.y = -p.y; // as N is odd\n    \n    p -= 2.0*min(dot(k.wy,p),0.0)*k.wy; // (1) (up to 2 sides)\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy; // (2) (up to 4 sides)\n    p -= 2.0*min(dot(k.wy,p),0.0)*k.wy; // (1) (up to 6 sides)\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy; // (2) (up to 8 sides)\n    \n\tp -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n    return length(p)*sign(p.y);\n}\n\n\n\n\n\n\nfloat map(vec2 p) {\n    float d;\n    if (mod(iTime, 3.0) < 1.5) {\n        d = sdHeptagon(p, cos(iTime) * 0.25 + 0.5);\n    } else {\n        d = sdOctagon(p, cos(iTime) * 0.25 + 0.5);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // iq's shading https://iquilezles.org/\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    float d = map(p);\n    vec3 col = (d<0.0) ? vec3(0.6,0.8,1.0) : vec3(0.9,0.6,0.3);\n    col *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 1.0 + 0.2*cos(128.0*abs(d));\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if (iMouse.z > 0.001) {\n        d = map(m);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}