{"ver":"0.1","info":{"id":"MfVyRc","date":"1732217437","viewed":81,"name":"Spinning Parallax Grid","username":"log22222","description":"heavily inspired by a similar effect from the Overdrive 2 demo by Titan","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["grid","loop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\n\nvec3 drawline(vec3 col_i, float coord, float offset, float zoom_off, float width, float period, vec3 color) {\n\tif( mod( abs(coord + offset * zoom_off) , period) > width){\n        col_i = color;\n    };\n    return col_i;\n}\n\n\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\nvec3 scratchlike_color(float hue, float sat, float val){\n    return hsv2rgb( vec3( mod(hue, 1.0),sat,val));\n}\n\nvec2 rotate_uv(float degr, vec2 uv){\n    float rot_x = float(uv.x * cos(degr))+(uv.y * sin(degr));\n    float rot_y = float(uv.y * cos(degr)) - (uv.x * sin(degr));\n    \n    return vec2( rot_x , rot_y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord-iResolution.xy/2.0)/iResolution.x)*250.0;\n    \n    //float rot_x = float(uv.x * cos(iTime/4.0))+(uv.y * sin(iTime/4.0));\n    //float rot_y = float(uv.y * cos(iTime/4.0)) - (uv.x * sin(iTime/4.0));\n    \n    //uv = vec2( rot_x , rot_y );\n    \n    uv = rotate_uv(iTime/4.0, uv);\n    \n    vec2 offset = vec2(sin(iTime/20.)*20., -sin(iTime/20.)*20.) * 25.0;\n    \n    float zoomlvl = 2. + (1.5 - pow(sin(iTime/1.), 4.)*1.5);\n    \n    uv = uv * zoomlvl;\n\n    // Time varying pixel color\n    \n    //vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n    vec3 col = scratchlike_color(0.1,0.65,0.9);\n    \n    vec3 cl_1 = vec3(0.0, 0.0, 0.0);\n    \n    float sigma_linecount = 6.0;\n    \n    for(float i = 1.0; i <= sigma_linecount; i++)\n    {\n        \n        float mscale = 10.;\n        \n        float istep = i/sigma_linecount;\n        \n        float istep_mscaled = istep * mscale;\n        \n        vec2 local_uv = rotate_uv(istep_mscaled/60. * sin(iTime/5.), uv);\n        \n        cl_1 = scratchlike_color(0. + istep_mscaled/sigma_linecount/(14.0 + sin(iTime)) + sin(iTime/2.)/25.0,0.65,0.9-istep_mscaled/12.);\n        \n        float powfc = 1.25 + (0.5 + cos(iTime/2.)/2.);\n        \n        float curved_i = pow(istep_mscaled, powfc);\n        float opposite_c_i = pow(sigma_linecount, powfc) - curved_i;\n    \n        col = drawline(col, local_uv.x, offset.x, (0.0 + curved_i /7.0), 14. + curved_i * 2.9, 15. + curved_i*4. , cl_1);\n        col = drawline(col, local_uv.y, offset.y, (0.0 + curved_i /7.0), 14. + curved_i * 2.9, 15. + curved_i*4. , cl_1);\n    }\n    \n    \n    \n    \n    /*\n    cl_1 = scratchlike_color(.09);\n    \n    col = drawline(col, uv.x, offset.x, 1.15, 14, 22, cl_1);\n    col = drawline(col, uv.y, offset.y, 1.15, 14, 22, cl_1);\n    \n    cl_1 = scratchlike_color(.14);\n    \n    col = drawline(col, uv.x, offset.x, 1.3, 22, 36, cl_1);\n    col = drawline(col, uv.y, offset.y, 1.3, 22, 36, cl_1);\n    \n    cl_1 = scratchlike_color(.2);\n    \n    col = drawline(col, uv.x, offset.x, 1.45, 35, 52, cl_1);\n    col = drawline(col, uv.y, offset.y, 1.45, 35, 52, cl_1);\n    */\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n}\n\n","name":"Image","description":"","type":"image"}]}