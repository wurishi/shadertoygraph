{"ver":"0.1","info":{"id":"msSfDy","date":"1690079438","viewed":54,"name":"2023_SWS3005_10","username":"Amelia0711","description":"\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID: SWS3005_10\n//\n// GROUP NUMBER: 10\n//\n// STUDENT NAME: JIN YANG\n// NUS User ID.: t0930457\n//\n// STUDENT NAME: WANG JINYU\n// NUS User ID.: t0929954\n//\n// STUDENT NAME: XIE XINZE\n// NUS User ID.: t0930288\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n// Art references:\n// https://www.bilibili.com/video/BV1vb41127Y8\n// https://www.youtube.com/watch?v=q3A80BPjci4\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 70.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 1;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 1;\nconst int NUM_SPHERES = 7;\nconst int NUM_CUBES = 30;\n\nconst int NUM_SHADOW_RAYS =\n    10; // Number of shadow rays for soft shadows. More rays means higher\n        // quality shadows but slower rendering.\nconst float LIGHT_RADIUS =\n    0.5; // Radius of the light source. Larger radius means softer shadows.\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n  vec3 o; // Ray Origin.\n  vec3 d; // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n  // The plane equation is Ax + By + Cz + D = 0.\n  float A, B, C, D;\n  int materialID;\n};\n\nstruct Sphere_t {\n  vec3 center;\n  float radius;\n  int materialID;\n};\n\nstruct Cube_t {\n  vec3 rad;\n  vec3 center;\n  int materialID;\n  mat4 M;\n};\n\nstruct Light_t {\n  vec3 position; // Point light 3D position.\n  vec3 I_a;      // For Ambient.\n  vec3 I_source; // For Diffuse and Specular.\n};\n\nstruct Material_t {\n  vec3 k_a;  // Ambient coefficient.\n  vec3 k_d;  // Diffuse coefficient.\n  vec3 k_r;  // Reflected specular coefficient.\n  vec3 k_rg; // Global reflection coefficient.\n  float n;   // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCube_t Cube[NUM_CUBES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\nfloat random(int seed) {\n  return fract(sin(float(seed) * 12.9898) * 43758.5453);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene() {\n  // Horizontal plane.\n  Plane[0].A = 0.0;\n  Plane[0].B = 1.0;\n  Plane[0].C = 0.0;\n  Plane[0].D = 0.0;\n  Plane[0].materialID = 0;\n\n  // Vertical plane.\n  // Plane[1].A = 0.0;\n  // Plane[1].B = 0.0;\n  // Plane[1].C = 1.0;\n  // Plane[1].D = 3.5;\n  // Plane[1].materialID = 0;\n\n  // Center bouncing sphere.\n  Sphere[0].center = vec3(0.0, 2.5, 0.0);\n  Sphere[0].radius = 1.0;\n  Sphere[0].materialID = 1;\n\n  for (int i = 1; i < 7; i++) {\n    // Calculate the angle for the current sphere, each sphere is 60 degrees\n    // apart\n    float angle =\n        float(i) *\n        60.0; // Convert to radians if needed (angle * 3.14159 / 180.0)\n\n    // Convert the angle to radians since cos and sin in GLSL expect radians\n    angle = radians(angle);\n\n    // Calculate the x and z positions using the sin and cos of the angle\n    float x = 1.5 * cos(angle + iTime);\n    float z = 1.5 * sin(angle + iTime);\n\n    // Set the sphere properties\n    Sphere[i].center = vec3(x, 2.5, z);\n    Sphere[i].radius = 0.3;\n    Sphere[i].materialID = 2;\n  }\n\n  // cubes\n  float angle = abs(sin(0.07 * iTime)) * 360.0;\n  for (int i = 0; i < NUM_CUBES; i++) {\n    float r = 0.13 * (2.0 * random(i) + 0.5);\n    Cube[i].rad = vec3(r, r, r);\n    float x = 2.5 * (2.0 * random(i) - 1.0);\n    float z = 2.5 * (2.0 * random(i + 2) - 1.0);\n    float y = (2.0 * random(i) - 1.0) * 0.3;\n    float height = mod(y + iTime * (0.01 + y), 20.0) - 2.0;\n    Cube[i].center = vec3(x, height, z);\n    Cube[i].materialID = 3;\n    // float angle = abs(sin(0.07 * iTime)) * 360.0;\n    Cube[i].M =\n        mat4(vec4(cos(angle / 180.0 * PI), 0, sin(angle / 180.0 * PI), 0),\n             vec4(0, 1, 0, 0),\n             vec4(-sin(angle / 180.0 * PI), 0, cos(angle / 180.0 * PI), 0),\n             vec4(0, 0, 0, 1)) *\n        mat4(vec4(1, 0, 0, 0), vec4(0, 1, 0, 0), vec4(0, 0, 1, 0),\n             vec4(-Cube[i].center, 1));\n  }\n\n  // Ground material.\n  Material[0].k_d = vec3(0.8, 0.521612, 0.148968) / 2.0;\n  Material[0].k_a = vec3(0.0);\n  Material[0].k_r = vec3(0.0);\n  Material[0].k_rg = vec3(1.0);\n  Material[0].n = 64.0;\n\n  // Red material.\n  Material[1].k_d = vec3(0.3, 0.0, 0.0);\n  Material[1].k_a = 0.2 * Material[1].k_d;\n  Material[1].k_r = 2.0 * Material[1].k_d;\n  Material[1].k_rg = 0.5 * Material[1].k_r;\n  Material[1].n = 64.0;\n\n  // Purple material.\n  Material[2].k_d = vec3(0.467454, 0.114388, 0.530699);\n  Material[2].k_a = 0.2 * Material[2].k_d;\n  Material[2].k_r = vec3(1.0, 1.0, 1.0);\n  Material[2].k_rg = 0.5 * Material[2].k_r;\n  Material[2].n = 128.0;\n\n  // Silver material.skip ray tracing\n  Material[3].k_d = vec3(0.5, 0.5, 0.5);\n  Material[3].k_a = 0.2 * Material[3].k_d;\n  Material[3].k_r = 0.5 * Material[3].k_d;\n  Material[3].k_rg = 0.5 * Material[3].k_r;\n  Material[3].n = 64.0;\n\n  // Light 0.\n  Light[0].position = vec3(-4.0, 8.0, 0.0);\n  Light[0].I_a = vec3(0.1, 0.1, 0.1);\n  float gb = 0.6 + 0.4 * sin(iTime);\n  Light[0].I_source = vec3(1.0, gb, gb);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                    out float t, out vec3 hitPos, out vec3 hitNormal) {\n  vec3 N = vec3(pln.A, pln.B, pln.C);\n  float NRd = dot(N, ray.d);\n  float NRo = dot(N, ray.o);\n  float t0 = (-pln.D - NRo) / NRd;\n  if (t0 < tmin || t0 > tmax)\n    return false;\n\n  // We have a hit -- output results.\n  t = t0;\n  hitPos = ray.o + t0 * ray.d;\n  hitNormal = normalize(N);\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin,\n                    in float tmax) {\n  vec3 N = vec3(pln.A, pln.B, pln.C);\n  float NRd = dot(N, ray.d);\n  float NRo = dot(N, ray.o);\n  float t0 = (-pln.D - NRo) / NRd;\n  if (t0 < tmin || t0 > tmax)\n    return false;\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin,\n                     in float tmax, out float t, out vec3 hitPos,\n                     out vec3 hitNormal) {\n  // https://dawn-innocent-934.notion.site/Line-Intersection-with-Sphere-f942bbb6b00c43ebb341f01da78175b0\n  vec3 oc = ray.o - sph.center;\n  float a = dot(ray.d, ray.d);\n  float b = 2.0 * dot(oc, ray.d);\n  float c = dot(oc, oc) - sph.radius * sph.radius;\n  float discriminant = b * b - 4.0 * a * c;\n  if (discriminant < 0.0) {\n    return false;\n  }\n  float sqrtDiscriminant = sqrt(discriminant);\n  float root = (-b - sqrtDiscriminant) / (2.0 * a);\n  if (root < tmin || tmax < root) {\n    root = (-b + sqrtDiscriminant) / (2.0 * a);\n    if (root < tmin || tmax < root) {\n      return false;\n    }\n  }\n  t = root;\n  hitPos = ray.o + t * ray.d;\n  hitNormal = normalize(hitPos - sph.center);\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin,\n                     in float tmax) {\n  float t;\n  vec3 hitPos, hitNormal;\n  return IntersectSphere(sph, ray, tmin, tmax, t, hitPos, hitNormal);\n}\n\nbool IntersectCube(in Cube_t cube, in Ray_t ray, in float tmin, in float tmax,\n                   out float t, out vec3 hitPos, out vec3 hitNormal) {\n  vec3 sco = (cube.M * vec4(ray.o, 1.0)).xyz;\n  vec3 scd = normalize((transpose(inverse(cube.M)) * vec4(ray.d, 1.0)).xyz);\n  vec3 m = 1.0 / scd;\n  vec3 n = m * sco;\n  vec3 k = abs(m) * cube.rad;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n\n  float tN = max(max(t1.y, t1.z), t1.x);\n  float tF = min(min(t2.y, t2.z), t2.x);\n\n  if (tN > tF || tF < 0.0)\n    return false;\n  if (tN < tmin || tN > tmax)\n    return false;\n  t = tN;\n  hitPos = (inverse(cube.M) * vec4((sco + t * scd), 1.0)).xyz;\n  hitNormal =\n      (transpose(inverse(cube.M)) *\n       vec4((-sign(ray.d) * step(t1.zxy, t1.xyz) * step(t1.yzx, t1.xyz)), 1.0))\n          .xyz;\n  return true;\n}\n\nbool IntersectCube(in Cube_t cube, in Ray_t ray, in float tmin, in float tmax) {\n\n  vec3 sco = (cube.M * vec4(ray.o, 1.0)).xyz;\n  vec3 scd = normalize((transpose(inverse(cube.M)) * vec4(ray.d, 1.0)).xyz);\n  vec3 m = 1.0 / scd;\n  vec3 n = m * sco;\n  vec3 k = abs(m) * cube.rad;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n\n  float tN = max(max(t1.y, t1.z), t1.x);\n  float tF = min(min(t2.y, t2.z), t2.x);\n\n  if (tN > tF || tF < 0.0)\n    return false;\n  if (tN < tmin || tN > tmax)\n    return false;\n  return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                   in Material_t mat, in Light_t light) {\n  if (inShadow) {\n    return light.I_a * mat.k_a;\n  } else {\n    vec3 R = reflect(-L, N);\n    float N_dot_L = max(0.0, dot(N, L));\n    float R_dot_V = max(0.0, dot(R, V));\n    float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\n    return light.I_a * mat.k_a +\n           light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n  }\n}\n\nfloat random(vec3 seed) {\n  return fract(sin(dot(seed, vec3(12.9898, 78.233, 54.5321))) * 43758.5453);\n}\n\n#define M_PI 3.14159265358979323846\n#define OCTAVES 4\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\nfloat rand(vec2 co, float l) { return rand(vec2(rand(co), l)); }\nfloat rand(vec2 co, float l, float t) { return rand(vec2(rand(co, l), t)); }\n\nfloat perlin(vec2 p, float dim, float time) {\n  vec2 pos = floor(p * dim);\n  vec2 posx = pos + vec2(1.0, 0.0);\n  vec2 posy = pos + vec2(0.0, 1.0);\n  vec2 posxy = pos + vec2(1.0);\n\n  float c = rand(pos, dim, time);\n  float cx = rand(posx, dim, time);\n  float cy = rand(posy, dim, time);\n  float cxy = rand(posxy, dim, time);\n\n  vec2 d = fract(p * dim);\n  d = -0.5 * cos(d * M_PI) + 0.5;\n\n  float ccx = mix(c, cx, d.x);\n  float cycxy = mix(cy, cxy, d.x);\n  float center = mix(ccx, cycxy, d.y);\n\n  return center * 2.0 - 1.0;\n}\n\nfloat fbm(vec2 p, float dim, float time) {\n  float total = 0.0;\n  float amplitude = 1.0;\n  float max_value = 0.0; // keeps track of the maximum possible value\n  for (int i = 0; i < OCTAVES; i++) {\n    total += perlin(p, dim, time) * amplitude;\n    max_value += amplitude;\n    p *= 2.0;\n    amplitude *= 0.5;\n  }\n  return (total / max_value) * 0.5 + 0.5;\n}\nvec3 skyColorRamp(float t) {\n  const int num_stops = 9;\n  const vec3 colors[num_stops] = vec3[](\n      vec3(0.181164, 0.033105, 0.012983), vec3(0.126195, 0.0, 0.000395),\n      vec3(0.386429, 0.005983, 0.005983), vec3(0.763173, 0.552263, 0.07056),\n      vec3(1.0, 0.939709, 0.164785) / 1.5, vec3(0.437206, 0.090197, 0.599671),\n      vec3(0.407207, 0.067224, 0.272683), vec3(0.600957, 0.004732, 0.006262),\n      vec3(0.0, 0.0, 0.0));\n  float factors[num_stops] =\n      float[](0.0, 0.148, 0.612, 0.646, 0.681, 0.736, 0.877, 0.910, 0.923);\n\n  for (int i = 0; i < num_stops - 1; i++) {\n    if (t >= factors[i] && t <= factors[i + 1]) {\n      float local_t = (t - factors[i]) / (factors[i + 1] - factors[i]);\n      return mix(colors[i], colors[i + 1], local_t);\n    }\n  }\n\n  return vec3(0.0); // Return black if no stop is found (shouldn't happen if t\n                    // is in [0, 1])\n}\n\nfloat contrast(float value, float contrastAmount) {\n  float middle = 0.5;\n  return mix(middle, value, contrastAmount);\n}\n\nvec3 BlueSky(float y, vec2 position, vec2 sunPosition) {\n  vec3 topColor = vec3(0.0, 0.5, 0.8);     // color at the top of the sky\n  vec3 horizonColor = vec3(0.7, 0.9, 1.0); // color at the horizon\n  vec3 skyColor = mix(horizonColor, topColor, sqrt(y));\n\n  // Calculate sun color based on the distance from the sun position\n  float sunSize = 0.02;\n  float sunGlowSize = 0.3;\n  vec3 sunColor = vec3(1.0, 1.0, 0.9); // orange-yellow sun color\n  float sunDistance = length(position - sunPosition);\n\n  // Full sun color inside sunSize, linear fade to sky color up to sunGlowSize\n  vec3 color =\n      mix(sunColor, skyColor, smoothstep(sunSize, sunGlowSize, sunDistance));\n\n  return color;\n}\n\nvec3 colorDodge(vec3 a, vec3 b) { return a / (1.0 - b); }\n\nvec3 Background(vec3 rayDir) {\n  // z is the height of the sky (Blender coordinates).\n  // We need to convert rayDir, which is a direction vector, to a\n  // 3D position on the sky.\n  float z = rayDir.y;\n  float speed = 0.05;\n  float scale = 25.0;\n  float mainTextureBrightness =\n      contrast(fbm(vec2(z * scale, iTime * speed), 2.0, 0.0), 2.0) + 0.5;\n\n  float brightBandsTextureBrightness =\n      contrast(fbm(vec2(z * scale / 2.0, iTime * speed * 2.0), 1.0, 0.0), 2.0) +\n      0.5;\n\n  vec3 color = skyColorRamp(z) * mainTextureBrightness;\n  // Apply color dodge to make the bright bands brighter\n  color = colorDodge(color, vec3(1.0 - brightBandsTextureBrightness));\n\n  if (iTime < 3.0) {\n    vec3 blueSky = BlueSky(z, vec2(rayDir.x, rayDir.z), vec2(-1.0, -1.0));\n    if (iTime < 2.0) {\n      return blueSky;\n    }\n    return 1.0 - z > iTime - 2.0 ? blueSky : color;\n  }\n\n  return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs+\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(in Ray_t ray, out bool hasHit, out vec3 hitPos, out vec3 hitNormal,\n             out vec3 k_rg) {\n  // Find whether and where the ray hits some object.\n  // Take the nearest hit point.\n\n  bool hasHitSomething = false;\n  float nearest_t =\n      DEFAULT_TMAX;       // The ray parameter t at the nearest hit point.\n  vec3 nearest_hitPos;    // 3D position of the nearest hit point.\n  vec3 nearest_hitNormal; // Normal vector at the nearest hit point.\n  int nearest_hitMatID;   // MaterialID of the object at the nearest\n                          // hit point.\n\n  float temp_t;\n  vec3 temp_hitPos;\n  vec3 temp_hitNormal;\n  bool temp_hasHit;\n\n  /////////////////////////////////////////////////////////////////////////////\n  // TASK:\n  // * Try interesecting input ray with all the planes and spheres,\n  //   and record the front-most (nearest) interesection.\n  // * If there is interesection, need to record hasHitSomething,\n  //   nearest_t, nearest_hitPos, nearest_hitNormal,\n  //   nearest_hitMatID.\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////\n  // TASK: WRITE YOUR CODE HERE. //\n  /////////////////////////////////\n\n  // Intersect ray with all the planes\n  for (int i = 0; i < NUM_PLANES; i++) {\n    if (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t,\n                       temp_hitPos, temp_hitNormal)) {\n      if (temp_t < nearest_t) {\n        nearest_t = temp_t;\n        nearest_hitPos = temp_hitPos;\n        nearest_hitNormal = temp_hitNormal;\n        nearest_hitMatID = Plane[i].materialID;\n        hasHitSomething = true;\n      }\n    }\n  }\n\n  // Intersect ray with all the spheres\n  for (int i = 0; i < NUM_SPHERES; i++) {\n    if (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t,\n                        temp_hitPos, temp_hitNormal)) {\n      if (temp_t < nearest_t) {\n        nearest_t = temp_t;\n        nearest_hitPos = temp_hitPos;\n        nearest_hitNormal = temp_hitNormal;\n        nearest_hitMatID = Sphere[i].materialID;\n        hasHitSomething = true;\n      }\n    }\n  }\n\n  // CUbe\n  for (int i = 0; i < NUM_CUBES; i++) {\n    temp_hasHit = IntersectCube(Cube[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                temp_t, temp_hitPos, temp_hitNormal);\n\n    if (temp_hasHit && temp_t < nearest_t) {\n      hasHitSomething = true;\n      nearest_t = temp_t;\n      nearest_hitPos = temp_hitPos;\n      nearest_hitNormal = temp_hitNormal;\n      nearest_hitMatID = Cube[i].materialID;\n    }\n  }\n\n  // One of the output results.\n  hasHit = hasHitSomething;\n  if (!hasHitSomething) {\n    return Background(ray.d);\n  }\n\n  vec3 I_local = vec3(0.0); // Result color will be accumulated here.\n\n  /////////////////////////////////////////////////////////////////////////////\n  // TASK:\n  // * Accumulate lighting from each light source on the nearest hit\n  // point.\n  //   They are all accumulated into I_local.\n  // * For each light source, make a shadow ray, and check if the\n  // shadow ray\n  //   intersects any of the objects (the planes and spheres)\n  //   between the nearest hit point and the light source.\n  // * Then, call PhongLighting() to compute lighting for this light\n  // source.\n  /////////////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////\n  // TASK: WRITE YOUR CODE HERE. //\n  /////////////////////////////////\n  for (int i = 0; i < NUM_LIGHTS; i++) {\n    vec3 lightDir = normalize(Light[i].position - nearest_hitPos);\n\n    int numShadowedRays = 0;\n    for (int j = 0; j < NUM_SHADOW_RAYS; j++) {\n      // Sample a random point within the light source's radius\n      vec3 lightSample =\n          Light[i].position +\n          LIGHT_RADIUS * normalize(vec3(random(vec3(lightDir.x, i, j)),\n                                        random(vec3(j, i, lightDir.x)),\n                                        random(vec3(i, j, lightDir.x))) -\n                                   vec3(0.5));\n      vec3 toLight = lightSample - nearest_hitPos;\n\n      Ray_t shadowRay;\n      shadowRay.o = nearest_hitPos;\n      shadowRay.d = normalize(toLight);\n\n      bool inShadow = false;\n      for (int k = 0; k < NUM_SPHERES; k++) {\n        if (IntersectSphere(Sphere[k], shadowRay, DEFAULT_TMIN,\n                            length(toLight))) {\n          inShadow = true;\n          break;\n        }\n      }\n      for (int k = 0; k < NUM_PLANES; k++) {\n        if (IntersectPlane(Plane[k], shadowRay, DEFAULT_TMIN,\n                           length(toLight))) {\n          inShadow = true;\n          break;\n        }\n      }\n\n      if (inShadow) {\n        numShadowedRays++;\n      }\n    }\n\n    // Compute the fraction of shadow rays that were not in shadow\n    float unshadowedFraction =\n        float(NUM_SHADOW_RAYS - numShadowedRays) / float(NUM_SHADOW_RAYS);\n\n    // Compute lighting as before, but scale by the unshadowed\n    // fraction\n    I_local += unshadowedFraction *\n               PhongLighting(lightDir, nearest_hitNormal, -ray.d, false,\n                             Material[nearest_hitMatID], Light[i]);\n  }\n\n  // Populate output results.\n  hitPos = nearest_hitPos;\n  hitNormal = nearest_hitNormal;\n  k_rg = Material[nearest_hitMatID].k_rg;\n\n  return I_local;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  InitScene();\n\n  // Scale pixel 2D position such that its y coordinate is in\n  // [-1.0, 1.0].\n  vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n  // Position the camera.\n  vec3 cam_pos = vec3(2.0, 0.2, 2.0);\n  vec3 cam_lookat = vec3(0.0, 10.0 * sin(iTime / 5.0 - 5.0) + 4.0, 0.0);\n  vec3 cam_up_vec = vec3(0.0, 1.0, 0.0);\n\n  // Set up camera coordinate frame in world space.\n  vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n  vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n  vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n  // Create primary ray.\n  float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n  Ray_t pRay;\n  pRay.o = cam_pos;\n  pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis +\n                     pixel_pos_z * cam_z_axis);\n\n  // Start Ray Tracing.\n  // Use iterations to emulate the recursion.\n\n  vec3 I_result = vec3(0.0);\n  vec3 compounded_k_rg = vec3(1.0);\n  Ray_t nextRay = pRay;\n\n  for (int level = 0; level <= NUM_ITERATIONS; level++) {\n    bool hasHit;\n    vec3 hitPos, hitNormal, k_rg;\n\n    vec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n\n    I_result += compounded_k_rg * I_local;\n\n    if (!hasHit)\n      break;\n\n    compounded_k_rg *= k_rg;\n\n    nextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n  }\n\n  fragColor = vec4(I_result, 1.0);\n}","name":"Image","description":"","type":"image"}]}