{"ver":"0.1","info":{"id":"dtjfzm","date":"1693916923","viewed":54,"name":"Basic Aurora 2","username":"gigaherz","description":"Second version of my aurora effect. It uses a different projection (fisheye instead of rectangular).\nThere's still some mathematical weirdness at the top which I haven't been able to figure out.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["aurora"],"hasliked":0,"parentid":"ctjfR1","parentname":"Basic Aurora"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// v2.1. \n// There's still some mathematical weirdness near the top of the screen.\n// I'm sure it would be obvious why it's wrong if I figured out what's happening, but as a proof of concept, I call it good enough.\n\n// SHADER NOISE\n//\t<https://www.shadertoy.com/view/4dS3Wd>\n//\tBy Morgan McGuire @morgan3d, http://graphicscodex.com\n//\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u)-0.5f;\n}\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y-0.5f;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z)-0.5f;\n}\n\nfloat noiseOctaves(vec2 x) {\n    return\n        noise(x) + \n        noise(x*2.0+x)*0.5 + \n        noise(x*4.0+x*2.0)*0.25 + \n        noise(x*8.0+x*4.0)*0.125;\n}\n\nfloat noiseOctaves(vec3 x) {\n    return\n        noise(x) + \n        noise(x*2.0+x)*0.5 + \n        noise(x*4.0+x*2.0)*0.25 + \n        noise(x*8.0+x*4.0)*0.125;\n}\n// END SHADER NOISE\n\n// STARFIELD\n// Copied from another of my shadertoys\n// at https://www.shadertoy.com/view/ldSXRK\nfloat Fetch(vec2 uvDisp, vec2 fragCoord)\n{\n\tvec2 uvS = (fragCoord.xy+uvDisp);\n\tvec2 uv = (fragCoord.xy+uvDisp) / iResolution.xy;\n    vec2 uvT0 = uvS / iChannelResolution[0].xy;\n    vec2 uvT1 = uvS / iChannelResolution[1].xy;\n        \n    /* TODO: Use procedural noise generation */\n    vec2 noise1 = texture(iChannel0, uvT0).rg;\n    float noise2 = texture(iChannel1, uvT1).r;\n    \n    vec2 c = 1.0-abs(sin((uvS+noise1)*10.0));\n    c=exp(log(c)*2.0);\n    \n    float v = c.x * c.y * max(0.0, noise2);\n    \n\treturn v;\n}\n\n/* shitty blur, replace with better one */\nfloat Blur(vec2 fragCoord)\n{\n    float c0 = 1.0, c1 = 2.0, c2 = 1.0;\n    float c3 = 2.0, c4 = 4.0, c5 = 2.0;\n    float c6 = 1.0, c7 = 2.0, c8 = 1.0;\n    float k1 = 0.1;\n    \n    float s0 = c0 * Fetch(vec2(-1,-1), fragCoord);\n    float s1 = c1 * Fetch(vec2( 0,-1), fragCoord);\n    float s2 = c2 * Fetch(vec2( 1,-1), fragCoord);\n    float s3 = c3 * Fetch(vec2(-1, 0), fragCoord);\n    float s4 = c4 * Fetch(vec2( 1, 0), fragCoord);\n    float s5 = c5 * Fetch(vec2( 0, 0), fragCoord);\n    float s6 = c6 * Fetch(vec2(-1, 1), fragCoord);\n    float s7 = c7 * Fetch(vec2( 0, 1), fragCoord);\n    float s8 = c8 * Fetch(vec2( 1, 1), fragCoord);\n    float st = (s0+s1+s2+s3+s4+s5+s6+s7+s8);    \n    \n    return k1*st;\n}\n// END STARFIELD\n\n// Here begins the mess.\n\nmat3 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c);\n}\n\nmat3 rotateY(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0, s,\n        0, 1, 0,\n       -s, 0, c);\n}\n\nmat3 rotatez(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c,-s, 0,\n        s, c, 0,\n        0, 0, 1);\n}\n\n#define DEG2RAD 0.0174533f\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0f - 1.0f;\n    \n    // perspective (I probably should be using matrix calculations here instead of trig)\n    vec3 origin = vec3(0,0,0);\n\n    float yaw = 0.0f;\n    float pitch = 30.0f;\n    \n    // give the horizon a slight curvature\n    pitch += abs(pow(uv.x,2.0f) * 2.0f);\n    \n    vec2 view_a = vec2(pitch,yaw) * DEG2RAD;\n    \n    float fov_x = 90.0f; // only want half here\n    float fov_y = fov_x * iResolution.y / iResolution.x;\n    vec2 fov = vec2(fov_x, fov_y) * 0.5f * DEG2RAD;\n    \n    vec2 ray_a = view_a + uv.yx * fov;\n    \n    mat3 xr = rotateX(ray_a.x);\n    mat3 yr = rotateY(ray_a.y);\n    \n    mat3 rotation = xr * yr;\n    \n    vec3 ray = rotation * vec3(0,0,1);\n    \n    bool mirror = ray.y < 0.0f;\n    ray.y=abs(ray.y);\n    \n    // aurora\n    float start = 10000.0f;\n    float end = 80000.0f;\n    float brightness = 25.0f;\n    \n    // view range\n    float fade_start = 100000.0f;\n    float fade_end = 200000.0f;\n    \n    \n\tfloat v= Blur(ray_a * 180.0f);\n    \n    v = exp(log(v)*3.0)*7.0;\n    \n    float slope = clamp(length(ray.xz)/ray.y,0.0f,1.0f);\n        \n    float steps = clamp(25.0f/(1.0f-slope), 25.0f, 200.0f);\n    \n    vec3 outc = vec3(0,0,0);\n    float outv = 0.0f;\n    \n    vec3 prevpoint = vec3(0,0,0);\n    float prevvalue = 0.0f;\n    for(float i=0.0f;i<=steps;i++)    \n    {    \n        float fi = i/steps;\n        float elevation = mix(start, end, fi);\n        \n        // intersect ray with elevation\n        vec2 intersection = vec2(\n            elevation * ray.x / ray.y,\n            elevation * ray.z / ray.y);\n        vec3 curpoint = vec3(intersection.x, elevation, intersection.y);\n            \n        float h_distance = length(intersection);\n            \n        if (h_distance > fade_end)\n        {\n            continue;\n        }\n        \n        float coef = 1.0f;\n        if (h_distance > fade_start)\n        {\n            coef = 1.0f - (h_distance-fade_start)/(fade_end-fade_start);\n        }\n        \n        vec3 timeOffset = iTime * vec3(0.025f, 0.0f, -0.25f);        \n        vec2 xzOffset = intersection * 0.000005f + timeOffset.xz;\n        float yOffset = fi*0.01f + noiseOctaves(xzOffset) * 1.35f + timeOffset.y;\n\n        vec3 posOffset = vec3(xzOffset, yOffset);\n            \n        // noise values\n        float hue = noiseOctaves(timeOffset + posOffset + vec3(1.0f, 2.0f, 0.0f));\n        float value = abs(hue);\n        \n        hue = hue * 15.0f - fi;\n        \n        value = clamp(2.5f-value*50.0f,0.0f,1.0f);\n        \n        value = coef * (brightness / steps) * min(i,1.0f) * (1.0f-pow(fi,0.15f)) * value;               \n        \n        float curvalue = value;\n        \n        if (i > 0.0f)\n        {\n            // integrate (doesn't really do what I expected but looks slightly better)\n            float base = length(curpoint-prevpoint) * 0.0007f; // some time constant. I don't even know\n            \n            float mn = min(value,prevvalue);\n            float mx = max(value,prevvalue);\n            float area = base * (mx+mn) * 0.5f;\n            \n            value = area;\n        \n            // accumulate     \n            vec3 color = hue >= 0.0f ? mix(vec3(0,1,0),vec3(0,0,1),hue) : mix(vec3(0,1,0),vec3(1,0,1),-hue);\n            outc += value * color;\n            outv += value;\n        }\n        prevvalue = curvalue;\n        prevpoint = curpoint;\n    }\n    \n    float cyan = max(0.0f, outv-1.0f);\n    float white = max(0.0f, outv-2.0f);\n    \n    outc = vec3(\n        outc.x + white,\n        outc.y,\n        outc.z + cyan\n    );\n    \n    outc = mix(vec3(v,v,v), outc * 0.6f, sqrt(outv));\n    \n    if (mirror)\n    {\n        outc = outc * vec3(0.25f,0.30f,0.75f) + vec3(0.0f,0.1f,0.35f);\n    }    \n    \n    // Output to screen\n    fragColor = vec4(outc,1.0);\n}","name":"Image","description":"","type":"image"}]}