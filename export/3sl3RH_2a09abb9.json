{"ver":"0.1","info":{"id":"3sl3RH","date":"1562231454","viewed":311,"name":"Melody of nature","username":"skaplun","description":"Water taken from @mrange - https://www.shadertoy.com/view/Wl2Gzc\nTrees are by @ikuto and @iq - https://www.shadertoy.com/view/wtf3DB","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["noise","water","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BG vec3(82.)/255.\n#define SUN vec3(249., 240., 212.)/255.\nvec3 sampleTex(in Ray inray, out float minDist, bool noEdges){\n    HitRecord rec;\n    vec3 bg = BG;\n    if(plane_hit(inray, Plane(vec3(0.), vec3(0., 0., -1.)), rec)\n       && ((abs(rec.p.x) <= 4. && rec.p.y <= 2.) || noEdges)){\n        rec.p.x += .25;\n        minDist = rec.t;\n        if(distance(rec.p.x, -1.5) <= 2.25 && distance(rec.p.y, .75) <= 1.){    //body\n            vec2 texCoord = (rec.p.xy - vec2(-1.5, .75))/vec2(2.25, 1.);\n            texCoord = texCoord * .5 + vec2(.5, .4);\n            texCoord = abs(texCoord);\n            vec2 sunCoord = texCoord * iResolution.xy/iResolution.yy;\n            bg = mix(bg, SUN, smoothstep(.325, .275, distance(sunCoord, vec2(1.25, .05)))); \n            bg = mix(bg, SUN, .5 * smoothstep(.55, .3, distance(sunCoord, vec2(1.25, .05))));\n            return bg * (1. - texelFetch(iChannel0, ivec2(texCoord * iResolution.xy), 0).r)\n                      * max(step(rec.p.x, -3.45), 1. - makeGrass(rec.p.xy * vec2(1., 1.5)));\n        }else if(distance(rec.p.x, 1.75) <= 1.5 && rec.p.y < .5){   //neck\n            return bg * (1. - makeGrass(rec.p.xy * vec2(1., 1.2 + .5 * sin(rec.p.x * 40.))));\n        }else if(distance(rec.p.x, 3.75) <= .5 && rec.p.y < .75){   //head\n            return bg * step(.1, makeHead(rec.p.xy - vec2(.25, 0.)));\n        }\n        return bg;\n    }\n    minDist = 100000.;\n    return bg;\n}\n\nvec3 makeClr(in Ray inray, bool noEdges){\n    float minDist;\n    vec3 clr = sampleTex(inray, minDist, noEdges);\n    HitRecord rec;\n    if(plane_hit(inray, Plane(vec3(0.), vec3(0., -1., 0.)), rec) && rec.t < minDist){\n        if((abs(rec.p.x) <= 4. && distance(rec.p.z, 3.) <= 3.) || noEdges){\n            vec4 s = sea(rec.p.xz * vec2(4., 8.) - vec2(0., iTime * 4.), .05);\n            float h = s.x;    \n            vec3 nor = s.yzw;\n            vec3 reflected = reflect(inray.dir, nor);\n            clr = sampleTex(Ray(rec.p, reflected), minDist, noEdges);\n        }else{\n            float f = mod(floor(rec.p.z) + floor(rec.p.x), 2.);\n            clr = .4 + f * vec3(.6);\n        }\n        \n    }\n    return clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = smoothstep(.33, .5, sin(iTime));\n    vec3 origin = vec3(8. * sin(ang), 1. + ang * 3., 8. * abs(cos(ang)));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0., 0., -.5), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    vec3 clr = makeClr(Ray(origin, dir), abs(origin.x) < 1.);\n    fragColor = vec4(clr, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SIZE                0.25\n#define MAX_DEPTH           7\n#define SPLIT_ANGLE         PI / 6.0\n#define LENGTH_VARIATOPN    0.5\n#define STACK_SIZE (MAX_DEPTH + 1)\n\nstruct Branch{\n    vec2  pos;\n    float len;\n    float angle;\n    float width;\n    int   depth;\n};\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat udLine(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat render(in vec2 uv, vec2 start, float size, float modifier){\n    float color = step(uv.y, -.15);\n    uv.y = abs(uv.y);\n    Branch stack[MAX_DEPTH + 1];\n    stack[0] = Branch(start, size, 0.0, 0.01, 0);\n    float branchID = 1.0;\n    \n    for (int stackPos = 0; stackPos >= 0; branchID += 1.0){\n        Branch branch = stack[stackPos--];\n        float prob = hash11(9375.264*branchID);\n        branch.angle += 0.05*(.5 * prob);\n        \n        float len = branch.len * (1.0 + LENGTH_VARIATOPN * (prob-0.5));\n        vec2 start = branch.pos;\n        vec2 end = start + vec2(len*sin(branch.angle), len*cos(branch.angle));\n        float ud =  udLine(uv, start, end);\n        \n        color = max(color, smoothstep(branch.width * 1.5, branch.width, ud));\n        \n        if (branch.depth < MAX_DEPTH){\n            float len = branch.len * (0.6);\n            float width = max(0.001, branch.width * 0.7);\n            \n            for(float i=-1.; i<2.; i++){\n                float ang = branch.angle + SPLIT_ANGLE * i;\n                float prob = i == 0.\n                                ?.2\n                                :abs(ang) > abs(branch.angle)\n                                          ?.15\n                                          :.35;\n                \n                ang += float(branch.depth)/float(MAX_DEPTH) * .5;\n                if(hash11(branchID + i*.173749 + 37.39 * modifier) > prob)\n                    stack[++stackPos] = Branch(end, len, ang, width, branch.depth+1);\n            }\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame == 0){\n        vec2 uv = fragCoord/iResolution.yy;\n        uv.x = 2. - uv.x;\n        uv.x -= .2;\n        uv.y -= .15;\n        float clr = 0.;\n        clr += render(uv, vec2(.15, 0.), SIZE * .6, 11.);\n        clr = max(clr, render(uv, vec2(.3, 0.), SIZE * .8, 13.));\n        clr = max(clr, render(uv, vec2(.5, 0.), SIZE * .9, 1.));\n        clr = max(clr, render(uv, vec2(.6, 0.), SIZE, 6.));\n        clr = max(clr, render(uv, vec2(.8, 0.), SIZE * .8, 5.55));\n        clr = max(clr, render(uv, vec2(1., 0.), SIZE * .9, 22.));\n        clr = max(clr, render(uv, vec2(1.1, 0.), SIZE * 1.1, 34.));\n        clr = max(clr, render(uv, vec2(1.3, 0.), SIZE * 1.2, 47.));\n        clr = max(clr, render(uv, vec2(1.45, 0.), SIZE, 51.));\n        clr = max(clr, render(uv, vec2(1.6, 0.), SIZE * .75, 57.));\n    \n        fragColor = vec4(vec3(clr), 1.);\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Plane{ vec3 origin; vec3 normal; };\nstruct Ray{ vec3 origin, dir; };\nstruct HitRecord{ float t; vec3 p; vec3 normal; };\n\nfloat time;\n    \nbool plane_hit(in Ray inray, in Plane plane, out HitRecord rec) {\n    float denom = dot(plane.normal, inray.dir);\n    if (denom > 1e-6) {\n        vec3 p0l0 = plane.origin - inray.origin;\n        float t = dot(p0l0, plane.normal) / denom;\n        \n        rec.t = t;\n        rec.p = inray.origin + inray.dir * rec.t;\n        rec.normal = -plane.normal;\n        return true;\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nvec3 hash(vec3 p){\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat makeGrass(vec2 uv){\n    uv.x += 1.;\n    float seed = uv.x - mod(uv.x, .015);\n    return step(uv.y, .05 + abs(hash(vec3(seed)).x) * .3)/* * step(1.5, uv.x)*/;\n}\n\nfloat makeHead(vec2 uv){\n    return (step(.1, distance(uv.x, 3.1)) + step(.7, uv.y) + step(distance(distance(uv.x, 3.1), .05), .03) * step(.05, mod(uv.y + .03, .1)))\n         * (step(.05, distance(uv.x, 3.27)) + step(.4, uv.y))\n         * (step(.05, distance(uv.x, 3.4)) + step(.42, uv.y))\n         * (step(.08, distance(uv.x, 3.55)) + step(.9, uv.y) + step(distance(distance(uv.x, 3.55), .04), .0225) * step(.05, mod(uv.y, .1)))\n         * (step(.07, distance(uv.x, 3.7)) + step(.4, uv.y))\n         * (step(.05, distance(uv.x, 3.825)) + step(.32, uv.y))\n         * (step(.125, distance(uv.x, 4.)) + step(4.5 - uv.x, uv.y))\n         * step(.1, uv.y);\n}\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nconst float gravity = 30.0;\nconst float waterTension = .01;\n\nvec2 wave(in float t, in float a, in float w, in float p) {\n  float x = t;\n  float y = a*sin(t*w + p);\n  return vec2(x, y);\n}\n\nvec2 dwave(in float t, in float a, in float w, in float p) {\n  float dx = 1.0;\n  float dy = a*w*cos(t*w + p);\n  return vec2(dx, dy);\n}\n\nvec2 gravityWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return wave(t, a ,k, w*time);\n}\n\nvec2 capillaryWave(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return wave(t, a, k, w*time);\n}\n\nvec2 gravityWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt(gravity*k*tanh(k*h));\n  return dwave(t, a, k, w*time);\n}\n\nvec2 capillaryWaveD(in float t, in float a, in float k, in float h) {\n  float w = sqrt((gravity*k + waterTension*k*k*k)*tanh(k*h));\n  return dwave(t, a, k, w*time);\n}\n\nmat2 mrot(in float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nmat2 mtrans(in mat2 m) {\n  return mat2(m[0][0], m[1][0], m[0][1], m[1][1]);\n}\n\nvec4 sea(in vec2 p, in float ia) {\n  float y = 0.0;\n  vec3 d = vec3(0.0);\n\n  float k = .75;\n  float kk = 1.5;\n  float a = ia * 0.59;\n  float aa = 1./(kk*kk);\n\n  float h = 10.0;\n  \n  float angle = 0.0;\n\n  for (int i = 0; i < 3; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += gravityWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = gravityWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n\n  for (int i = 3; i < 7; ++i) {\n    mat2 fr = mrot(angle);\n    mat2 rr = mtrans(fr);\n    vec2 pp = fr*p;\n    y += capillaryWave(pp.y + float(i), a, k, h).y;\n    vec2 dw = capillaryWaveD(pp.y + float(i), a, k, h);\n    \n    vec2 d2 = vec2(0.0, dw.x);\n    vec2 rd2 = rr*d2;\n    \n    d += vec3(rd2.x, dw.y, rd2.y);\n\n    angle += float(i);\n    k *= kk;\n    a *= aa;\n  }\n  \n  vec3 t = normalize(d);\n  vec3 nxz = normalize(vec3(t.z, 0.0, -t.x));\n  vec3 nor = cross(t, nxz);\n\n  return vec4(y, nor);\n}","name":"Common","description":"","type":"common"}]}