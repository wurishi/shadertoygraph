{"ver":"0.1","info":{"id":"ltSGDh","date":"1428490784","viewed":4074,"name":"Tw15t3r","username":"dila","description":"Twister for vpro. The camera shake idea is from iq's \"Hell\".","likes":61,"published":1,"flags":0,"usePreview":1,"tags":["twister","tornado"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat map(vec3 pos, float q)\n{\n    float so = q;\n    float sr = atan(pos.z,pos.x);\n    so += pos.y * 0.5;\n    so += sin(pos.y*75.0+sr-iTime) * 0.005;\n    so += sin(pos.y*125.0+sr-iTime*10.0) * 0.004;\n    float ro = pos.y*10.0-iTime;\n    pos.xz += vec2(cos(ro), sin(ro)) * 0.07;\n\tfloat d = sdCappedCylinder(pos, vec2(so, 10.0));\n    float k = pos.y;\n    return smin(d,k,10.0);\n}\n\nvec3 surfaceNormal(vec3 pos)\n{\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz,0.0) - map(pos - delta.xyz,0.0);\n    normal.y = map(pos + delta.yxz,0.0) - map(pos - delta.yxz,0.0);\n    normal.z = map(pos + delta.zyx,0.0) - map(pos - delta.zyx,0.0);\n    return normalize(normal);\n}\n\nfloat trace(vec3 o, vec3 r, float q)\n{\n\tfloat t = 0.0;\n    float ta = 0.0;\n    for (int i = 0; i < 8; ++i) {\n        float d = map(o + r * t, q);\n        t += d * 1.0;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    float tn = texture(iChannel0,vec2(iTime*0.1,0.0)).x;\n    tn = tn * 2.0 - 1.0;\n    r *= zrot(sin(tn)*0.2) * xrot(-pi*0.05+sin(tn)*0.1);\n    \n    vec3 o = vec3(0.0, 0.15, -0.5);\n    \n    float t = trace(o, r, 0.0);\n    vec3 world = o + r * t;\n    vec3 sn = surfaceNormal(world);\n    \n    vec3 vol = vec3(0.0);\n    \n    for (int i = 0; i < 3; ++i) {\n        float rad = 0.2+float(1+i)/3.0;\n        float tt = trace(o,r,rad);\n        vec3 wa = o + r * tt;\n        float atlu = atan(wa.x,wa.z) - tt * 4.0 + iTime;\n        float atlv = acos(wa.y/length(wa)) + tt * 4.0;\n        vec3 at = texture(iChannel0, vec2(atlu,atlv)).xxx;\n        vol += at / 3.0;\n    }\n    \n    float prod = max(dot(sn, -r), 0.0);\n    \n    float fd = map(world, 0.0);\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd * 10.0);\n    \n    vec3 sky = vec3(148.0,123.0,120.0) / 255.0;\n    \n    vec3 fgf = vec3(210.0,180.0,140.0) / 255.0;\n    vec3 fgb = vec3(139.0,69.0,19.0) / 255.0;\n    vec3 fg = mix(fgb, fgf, prod);\n    \n    vec3 back = mix(fg, sky, 1.0-fog);\n    \n    vec3 mmb = mix(vol, back, 0.8);\n    \n    vec3 fc = mmb * vec3(1.0);\n    \n\tfragColor = vec4(fc, 1.0);\n}","name":"","description":"","type":"image"}]}