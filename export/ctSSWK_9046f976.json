{"ver":"0.1","info":{"id":"ctSSWK","date":"1676806681","viewed":126,"name":"Fluids via density invariance","username":"mio85","description":"Inviscid fluid dynamics simulation based on:\nMartin Guay, Fabrice Colin, Richard Egli. Simple and Fast Fluids. GPU Pro, 2011, GPU Pro, 2, pp.433-444. inria-00596050\nThe fluid is interactive, you can introduce external forces dragging the mouse around.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This simply shows some images for debugging or the final image\n\n#define MODE 0\n\n#if MODE == 0\n// Standard smoke-like mode\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fluidProperties = texture(iChannel0, uv);\n    fragColor = vec4(fluidProperties.aaa, 1.0);\n}\n\n#elif MODE == 1\n// Debug fluid properties mode\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fluidProperties = texture(iChannel0, uv);\n    fragColor = vec4(fluidProperties.rgb, 1.0);\n}\n\n#elif MODE == 2\n// Debug mouse input mode\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 mouseForce = texture(iChannel1, uv);\n    fragColor = vec4(mouseForce.rgb, 1.0);\n}\n\n#endif\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fluid dynamics simulation on GPU based on:\n// Martin Guay, Fabrice Colin, Richard Egli. Simple and Fast Fluids. GPU Pro, 2011, GPU Pro, 2, pp.433-444. inria-00596050\n// All space and time scaling has been skipped since this script is done pixel by pixel and frame by frame respectively\n\n#define HALF_PI 3.141592653589793/2.0\n#define CENTER vec2(0.5, 0.5)\n#define IN_RADIUS 0.2\n#define OUT_RADIUS 0.25\n#define DEFAULT_DENSITY 0.1\n#define K 0.05\n#define EXTERNAL_FORCE_MULT 0.5\n\n// The following 2 functions convert between 2 different value ranges: [-1,1] (I'll call it vector space) and [0,1] (I'll call it color space)\nvec2 vec2ToRG( in vec2 v )\n{\n    // *0.5+0.5 is done to fit the range [-1,1] into [0,1]\n    return v * 0.5 + 0.5;\n}\n\nvec2 RGToVec2( in vec2 rg )\n{\n    // This does the opposite, it transforms something from the range [0,1] into [-1,1]\n    return (rg - 0.5) * 2.0;\n}\n\nvec3 loadFluidProperties( in vec2 uv )\n{\n    vec3 fp = texture(iChannel0, uv).rgb;\n    return vec3(RGToVec2(fp.xy), fp.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        // This places the big circle of fluid ink at the very beginning and also initializes the momentum to 0 everywhere (which is 0.5 when fitting into [0,1])\n        float xy2uv = 1.0 / max(iResolution.x, iResolution.y);  // ratio between pixel space and UV space (here UV space is not relative to each screen axis size but instead it is relative to the size of a single axis)\n        vec2 uv = fragCoord * xy2uv;\n        vec2 center_uv = vec2(iResolution.xy * xy2uv * CENTER);\n        vec2 diffToCenter = center_uv - uv;\n        float distToCenter = length(diffToCenter);\n        fragColor = vec4(0.5, 0.5, DEFAULT_DENSITY, smoothstep(1.0, 0.0, (distToCenter - IN_RADIUS) / (OUT_RADIUS - IN_RADIUS)));\n        // These others are just for debugging purposes since I'm still quite a noob XD:\n        //fragColor = vec4(0.5, 0.5, step(distToCenter, IN_RADIUS), 0.0);\n    }\n    else {\n        // This is the actual fluid dynamics solver code\n        // First a few preliminary things that will be needed later in the code\n        vec2 xy2uv = 1.0 / iResolution.xy;  // ratio between pixel space and UV space (here UV space is relative to each screen axis size since we use it to read from one of the buffers)\n        vec2 uv = fragCoord * xy2uv;\n        // I retrieve fluid properties data (fp) from last frame in both current and neighboring pixels\n        vec3 fpO = loadFluidProperties(uv);  // current pixel (O stands for \"original\" XD)\n        vec3 fpN = loadFluidProperties((fragCoord + vec2(0.0, 1.0)) * xy2uv);  // North neighbor\n        vec3 fpS = loadFluidProperties((fragCoord + vec2(0.0, -1.0)) * xy2uv);  // South neighbor\n        vec3 fpW = loadFluidProperties((fragCoord + vec2(-1.0, 0.0)) * xy2uv);  // West neighbor\n        vec3 fpE = loadFluidProperties((fragCoord + vec2(1.0, 0.0)) * xy2uv);  // East neighbor\n        float divMomentum = (fpE.x - fpW.x) * 0.5 + (fpN.y - fpS.y) * 0.5;\n        vec2 gradDensity = vec2(fpE.z - fpW.z, fpN.z - fpS.z) * 0.5;\n        \n        // Conservation of mass phase\n        float newDensity = fpO.z - ( dot(fpO.xy, gradDensity) + (fpO.z * divMomentum) );\n        \n        // Conservation of momentum phase which is based on semi-lagrangian advection of fluid momentum (Stam99)\n        // I also use this phase to advect other properties since advection affects every property\n        vec2 advectFrom = fragCoord - fpO.xy;\n        vec3 advectedFP = texture(iChannel0, advectFrom * xy2uv).rga;  // note that the texture must already perform clamping when retrieval from out of borders (as in GL_CLAMP_TO_EDGE)\n        vec2 advectedMomentum = RGToVec2(advectedFP.xy);\n        float advectedInk = advectedFP.z;\n        \n        // Final phase: external forces addition, clamping momentum for stability and boundary conditions imposition\n        vec2 externalForces = RGToVec2(texture(iChannel1, uv).rg);\n        vec2 finalMomentum = advectedMomentum + externalForces * EXTERNAL_FORCE_MULT - K * gradDensity;\n        if (fragCoord.x < 1.0 || fragCoord.x > (iResolution.x - 1.0))\n        {\n            finalMomentum.x = 0.0;\n        }\n        if (fragCoord.y < 1.0 || fragCoord.y > (iResolution.y - 1.0))\n        {\n            finalMomentum.y = 0.0;\n        }\n        float finalMomentumNorm = length(finalMomentum);\n        if (finalMomentumNorm > 1.0)\n        {\n            finalMomentum = finalMomentum / finalMomentumNorm;  // this clamps the momentum to have a norm of 1.0 at most\n        }\n        vec4 newFluidProperties = vec4(finalMomentum, clamp(newDensity, 0.0, 1.0), advectedInk);\n        \n        // The updated fluid properties are written to the buffer for next frame and for representation as well\n        fragColor = vec4(vec2ToRG(newFluidProperties.xy), newFluidProperties.zw);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Mouse input external force calculation using \"memory\" of last input and a mask to obtain the vector forces\n\n#define PI 3.141592653589793\n#define HALF_PI 3.141592653589793/2.0\n#define INV_RADIUS_DIST_VEC 1.0/0.1\n#define RADIUS_MASK 0.05\n\nvec2 vec2ToRG( in vec2 v )\n{\n    // *0.5+0.5 is done to fit the range [-1,1] into [0,1]\n    return v * 0.5 + 0.5;\n}\n\nvec2 RGToVec2( in vec2 rg )\n{\n    // This does the opposite, it transforms something from the range [0,1] into [-1,1]\n    return (rg - 0.5) * 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.0) {\n        float xy2uv = 1.0 / max(iResolution.x, iResolution.y);  // ratio between pixel space and UV space\n        vec2 uv = fragCoord * xy2uv;\n        vec2 center_uv = vec2(iMouse.xy * xy2uv);\n        vec2 diffToCenter = uv - center_uv;\n        float distToCenter = length(diffToCenter);\n        float inputDistIntensity = sin(clamp(distToCenter * INV_RADIUS_DIST_VEC * HALF_PI, 0.0, PI));\n        vec2 inputDistVec = diffToCenter / distToCenter * inputDistIntensity;\n        vec2 lastInputDistVec = RGToVec2(texture(iChannel0, fragCoord / iResolution.xy).ba);\n        float inputMaskIntensity = smoothstep(0.0, 1.0, (RADIUS_MASK - distToCenter) / RADIUS_MASK);\n        vec2 force = vec2ToRG(lastInputDistVec * inputMaskIntensity);\n        fragColor = vec4(force, vec2ToRG(inputDistVec));\n        // These others are just for debugging purposes since I'm still quite a noob XD:\n        //fragColor = vec4(vec2ToRG(inputDistVec), inputMaskIntensity, 1.0);\n        //fragColor = vec4(inputDistVec, inputDistIntensity, 1.0);\n        //fragColor = vec4(vec2ToRG(inputDistVec), 0.5, 0.5);\n        //fragColor = vec4(diffToCenter / distToCenter * 0.5 + 0.5, inputDistIntensity, 0.5);\n    }\n    else {\n        fragColor = vec4(0.5, 0.5, 0.5, 0.5);  // cleans the full buffer when not pressed, 0.5 is 0 fit to the range [0,1]\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}