{"ver":"0.1","info":{"id":"lcKSDt","date":"1718172530","viewed":119,"name":"Water In Cup","username":"March3rd","description":"This is a test shader for rendering water in glass cup.\nTurn the camera with your mouse.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["volume","wave","water","fract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Transform {\n    vec3 position;\n    vec3 rotation;\n};\nvec3 rotateX(vec3 vec, float radian) {\n    vec3 result;\n    float s = sin(radian);\n    float c = cos(radian);\n    result.x = vec.x;\n    result.y = vec.y * c + vec.z * s;\n    result.z = vec.y * (-s) + vec.z * c;\n    return result;\n}\nvec3 rotateY(vec3 vec, float radian) {\n    vec3 result;\n    float s = sin(radian);\n    float c = cos(radian);\n    result.x = vec.x * c + vec.z * (-s);\n    result.y = vec.y;\n    result.z = vec.x * s + vec.z * c;\n    return result;\n}\nvec3 rotateZ(vec3 vec, float radian) {\n    vec3 result;\n    float s = sin(radian);\n    float c = cos(radian);\n    result.x = vec.x * c + vec.y * s;\n    result.y = vec.x * (-s) + vec.y * c;\n    result.z = vec.z;\n    return result;\n}\nvec3 rotate(vec3 vec, vec3 radian) {\n    return rotateY(rotateX(rotateZ(vec, radian.z), radian.x), radian.y);\n}\nvec3 rotateInv(vec3 vec, vec3 radian) {\n    return rotateZ(rotateX(rotateY(vec, -radian.y), -radian.x), -radian.z);\n}\nvec3 transform(vec3 vec, Transform t, bool isVec) {\n    vec = rotate(vec, radians(t.rotation));\n    if (!isVec) {\n        vec += t.position;\n    }\n    return vec;\n}\nvec3 transformInv(vec3 vec, Transform t, bool isVec) {\n    if (!isVec) {\n        vec += -t.position;\n    }\n    vec = rotateInv(vec, radians(t.rotation));\n    return vec;\n}\n\nstruct Box {\n    vec3 semi_edge;\n    Transform transform;\n};\nfloat intersect(Box box, vec3 ro, vec3 rd) {\n    ro = transformInv(ro, box.transform, false);\n    rd = transformInv(rd, box.transform, true);\n    vec3 t = -ro / rd;\n    vec3 delta_t = abs(box.semi_edge / rd);\n    vec3 t_near = t - delta_t;\n    vec3 t_far = t + delta_t;\n    float t_entry = max(max(t_near.x, t_near.y), t_near.z);\n    float t_exit = min(min(t_far.x, t_far.y), t_far.z);\n    if (t_entry < t_exit && t_exit > 0.0) {\n        if (t_entry > 0.0) return t_entry;\n        else return t_exit;\n    }\n    return -1.0;\n}\nvec3 getNormal(Box box, vec3 pos) {\n    pos = transformInv(pos, box.transform, false);\n    vec3 apos = abs(pos) - box.semi_edge;\n    vec3 mask = vec3(\n        step(apos.y, apos.x) * step(apos.z, apos.x)\n        , step(apos.x, apos.y) * step(apos.z, apos.y)\n        , step(apos.x, apos.z) * step(apos.y, apos.z)\n    );\n    return transform(sign(pos) * mask, box.transform, true);\n} \n\n\nstruct Sphere {\n    float radius;\n    Transform transform;\n};\nfloat intersect(Sphere sphere, vec3 ro, vec3 rd) {\n    vec3 d = sphere.transform.position - ro;\n    float dist = dot(d, rd);\n    vec3 h = d - rd * dist;\n    float delta = sphere.radius * sphere.radius - dot(h, h); \n    if (delta > 0.0) {\n        delta = sqrt(delta);\n        if (dist - delta > 0.0) return dist - delta;\n        else return dist + delta;\n    } else {\n        return -1.0;\n    }\n}\nvec3 getNormal(Sphere sphere, vec3 pos) {\n    return normalize(pos - sphere.transform.position);\n} \n\n\nstruct Camera {\n    float fov;\n    float aspect;\n    Transform transform;\n};\nvec3 castRay(Camera camera, vec2 uv) {\n    float semi_height = tan(radians(camera.fov * 0.5));\n    float semi_width = semi_height * camera.aspect;\n    vec3 dir = vec3(mix(-semi_width, semi_width, uv.x), mix(-semi_height, semi_height, uv.y), 1.0);\n    return transform(normalize(dir), camera.transform, true);\n}\n\nfloat schlickFresnel(vec3 rd, vec3 normal, float eta) {\n    float f0 = pow((eta - 1.0) / (eta + 1.0), 2.0);\n    return f0 + (1.0 - f0) * pow(1.0 - abs(dot(rd, normal)), 5.0);\n}\n\n//#define SPHERE\n#define BOX\nCamera camera;\n#ifdef SPHERE\nSphere outer;\nSphere inner;\n#endif\n#ifdef BOX\nBox outer;\nBox inner;\n#endif\nfloat lod = 0.0;\nfloat open = 0.4;\nfloat view = 1.5;\nfloat step_size = 0.02;\nfloat eta = 0.7;\nfloat fluid_eta = 0.86;\nvec3 ext = vec3(1.5, 8.1, 9.56);\nvec3 albedo = vec3(0.985, 0.24, 0.18);\nfloat epsilon = 0.001;\n\n\nstruct RT {\n    vec3 radiance;\n    vec3 transmittance;\n    vec3 ro;\n    vec3 rd;\n};\nRT createRT(vec3 ro, vec3 rd) {\n    RT rt;\n    rt.radiance = vec3(0.0);\n    rt.transmittance = vec3(1.0);\n    rt.ro = ro;\n    rt.rd = rd;\n    return rt;\n}\nRT mergeRT(RT old, RT new) {\n    old.radiance += old.transmittance * new.radiance;\n    old.transmittance *= new.transmittance;\n    old.ro = new.ro;\n    old.rd = new.rd;\n    return old;\n}\n\n\nvoid initScene() {\n    camera.fov = 75.0;\n    camera.aspect = 1.2;\n    camera.transform.position = vec3(0.0, 0.0, -view);\n    camera.transform.rotation = vec3(-0.0, 0.0, 0.0);\n\n#ifdef SPHERE\n    outer.radius = 0.5f;\n    inner.radius = 0.48f;\n#endif\n#ifdef BOX\n    outer.semi_edge = vec3(0.5f);\n    inner.semi_edge = vec3(0.48f);\n#endif\n    outer.transform.position = vec3(0.0, 0.0, 0.0);\n    outer.transform.rotation = vec3(0.0, 0.0, 0.0);\n    inner.transform.position = vec3(0.0, 0.0, 0.0);\n    inner.transform.rotation = vec3(0.0, 0.0, 0.0);\n}\n\n\nRT renderOuterShellFront(vec3 ro, vec3 rd) {\n    RT rt = createRT(ro, rd);\n    float dist = intersect(outer, ro, rd);  \n    if (dist > 0.0) {\n        ro += rd * dist;\n        if (ro.y < open) {\n            vec3 normal = getNormal(outer, ro);\n            vec3 rd_reflect = reflect(rd, normal);\n            vec3 rd_refract = refract(rd, normal, eta);\n            float fresnel = schlickFresnel(rd, normal, eta);\n            rt.radiance += texture(iChannel0, rd_reflect, lod).rgb * fresnel;\n            rt.transmittance *= 1.0 - fresnel;\n            rt.ro = ro + rd_refract * epsilon;\n            rt.rd = rd_refract;\n        } else {\n            rt.ro = ro + rd * epsilon;\n        }\n    }\n    return rt;\n}\nRT renderInnerShellFront(vec3 ro, vec3 rd) {\n    RT rt = createRT(ro, rd);\n    float dist = intersect(inner, ro, rd);  \n    if (dist > 0.0) {\n        ro += rd * dist;\n        if (ro.y < open) {\n            vec3 normal = getNormal(inner, ro);\n            vec3 rd_reflect = reflect(rd, normal);\n            vec3 rd_refract = refract(rd, normal, 1.0 / eta);\n            if (length(rd_refract) > 0.0) {\n                float fresnel = schlickFresnel(rd_refract, normal, eta);\n                rt.transmittance *= 1.0 - fresnel;\n                rt.ro = ro + rd_refract * epsilon;\n                rt.rd = rd_refract;\n            } else {\n                rt.radiance += texture(iChannel0, rd_reflect, lod).rgb;\n                rt.transmittance *= 0.0;\n                \n            }\n        } else {\n            rt.ro = ro + rd * epsilon;\n        }\n        \n    }\n    return rt;\n}\n\n\nstruct Wave {\n    float c_y;\n    float a;\n    float c_x; \n    float c_z; \n    float w;\n};\n#define WAVE_NUM 4\nWave wave[WAVE_NUM];\n#define WAVE_FACTOR .25;\n\nvoid initWave() {\n    wave[0].c_y = -0.12;\n    wave[0].a = 0.085 * WAVE_FACTOR;\n    wave[0].c_x = 8.5;\n    wave[0].c_z = -7.2;\n    wave[0].w = 2.3 * WAVE_FACTOR;\n    \n    wave[1].c_y = 0.1;\n    wave[1].a = 0.056 * WAVE_FACTOR;\n    wave[1].c_x = -5.5;\n    wave[1].c_z = 7.2;\n    wave[1].w = 2.5 * WAVE_FACTOR;\n    \n    wave[2].c_y = 0.15;\n    wave[2].a = 0.02 * WAVE_FACTOR;\n    wave[2].c_x = 6.5;\n    wave[2].c_z = 5.2;\n    wave[2].w = 2.2 * WAVE_FACTOR;\n    \n    wave[3].c_y = -0.2;\n    wave[3].a = 0.135 * WAVE_FACTOR;\n    wave[3].c_x = 7.5;\n    wave[3].c_z = 4.2;\n    wave[3].w = 1.9 * WAVE_FACTOR;\n}\n\nfloat waveSurface(Wave wave, vec3 pos) {\n    return wave.c_y + wave.a * sin(wave.c_x * pos.x + wave.c_z * pos.z + wave.w * iTime);\n}\n\nvec3 waveGrad(Wave wave, vec3 pos) {\n    float g_x = wave.a * wave.c_x * cos(wave.c_x * pos.x + wave.c_z * pos.z + wave.w * iTime);\n    float g_z = wave.a * wave.c_z * cos(wave.c_x * pos.x + wave.c_z * pos.z + wave.w * iTime);\n    return vec3(-g_x, 1.0, -g_z);\n}\n\nfloat fluidSurface(vec3 ro) {\n    float v = 0.0;\n    for (int i = 0; i < WAVE_NUM; i ++) {\n        v += waveSurface(wave[i], ro);\n    }\n    return v;\n}\nvec3 fluidNormal(vec3 ro) {\n    vec3 v = vec3(0.0);\n    for (int i = 0; i < WAVE_NUM; i ++) {\n        v += waveGrad(wave[i], ro);\n    }\n    return normalize(v);\n}\n\nRT renderMediaSurface(vec3 ro, vec3 rd) {\n    RT rt = createRT(ro, rd);\n    float dist = intersect(inner, ro, rd);  \n    if (dist > 0.0) {\n        vec3 normal = getNormal(inner, ro);\n        float empty_dist = 0.0;\n        do {\n            if (ro.y < fluidSurface(ro)) {\n                vec3 rd_reflect = reflect(rd, normal);\n                vec3 rd_refract = refract(rd, normal, fluid_eta);\n                float fresnel = schlickFresnel(rd, normal, fluid_eta);\n                rt.radiance = texture(iChannel0, rd_reflect, lod).rgb * fresnel;\n                rt.transmittance *= 1.0 - fresnel;\n                rt.ro = ro + rd_refract * epsilon;\n                rt.rd = rd_refract;\n                return rt;\n            }\n            else {\n                empty_dist += step_size;\n                ro += rd * step_size;\n                normal = fluidNormal(ro);\n            }\n        } while (empty_dist < dist);\n    }\n    return rt;\n}\n\n\nRT renderMediaVolume(vec3 ro, vec3 rd) {\n    RT rt = createRT(ro, rd);\n    float dist = intersect(inner, ro, rd); \n    float searched_dist = 0.0;\n    float depth = 0.0;\n    while (searched_dist < dist) {\n        searched_dist += step_size;\n        ro += rd * step_size;\n        if (ro.y < fluidSurface(ro)) {\n            depth += step_size;\n            if (abs(0.2 - texture(iChannel1, vec3(ro.x, ro.y - 0.4 * iTime, ro.z)).r) < epsilon) {\n                rt.radiance += exp(-ext * depth) * vec3(1.0);\n                rt.transmittance *= 0.0;\n                break;\n            }\n        }\n    }\n    rt.radiance += (1.0 - exp(-ext * depth)) * albedo;\n    rt.transmittance *= exp(-ext * depth);\n    return rt;\n}\n\nRT renderInnerShellBack(vec3 ro, vec3 rd) {\n    RT rt = createRT(ro, rd);\n    float dist = intersect(inner, ro, rd);  \n    if (dist > 0.0) {\n        ro += rd * dist;\n        if (ro.y < open) {\n            vec3 normal = -getNormal(inner, ro);\n            vec3 rd_reflect = reflect(rd, normal);\n            vec3 rd_refract = refract(rd, normal, eta);\n            float fresnel = schlickFresnel(rd, normal, eta);\n            rt.radiance += texture(iChannel0, rd_reflect, lod).rgb * fresnel;\n            rt.transmittance *= 1.0 - fresnel;\n            rt.ro = ro + rd_refract * epsilon;\n            rt.rd = rd_refract;\n        } else {\n            rt.ro = ro;\n        }\n    }\n    return rt;\n}\n\nRT renderBG(vec3 transmittance, vec3 rd) {\n    RT rt = createRT(vec3(0.0), rd);\n    if (transmittance.x == 1.0 && transmittance.y == 1.0 && transmittance.z == 1.0) {\n        rt.radiance = texture(iChannel0, rd).rgb;\n    } else {\n        rt.radiance = texture(iChannel0, rd, lod).rgb;\n    }\n    rt.transmittance = vec3(0.0f);\n    return rt;\n}\n\n#define CONTROL_CAMERA\n//#define CONTROL_OBJ\n\nvoid control() {\n    vec2 move = (iMouse.xy / iResolution.xy - 0.5);\n    move.y *= 180.0;\n    move.x *= 360.0;\n    if (iMouse.z > 0.0) {\n#ifdef CONTROL_OBJ\n        outer.transform.rotation.y = iMouse.x;\n        outer.transform.rotation.x = -iMouse.y;\n        inner.transform.rotation.y = iMouse.x;\n        inner.transform.rotation.x = -iMouse.y;\n#endif\n#ifdef CONTROL_CAMERA\n        camera.transform.position.x = view * cos(radians(move.y)) * cos(radians(-90.0 + move.x));\n        camera.transform.position.z = view * cos(radians(move.y)) * sin(radians(-90.0 + move.x));\n        camera.transform.position.y = view * sin(radians(move.y));\n        camera.transform.rotation.y = move.x;\n        camera.transform.rotation.x = -move.y;\n#endif\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initScene();\n    control();\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 rd = castRay(camera, uv);\n    vec3 ro = camera.transform.position;\n    RT rt = createRT(ro, rd);\n    rt = mergeRT(rt, renderOuterShellFront(rt.ro, rt.rd));\n    rt = mergeRT(rt, renderInnerShellFront(rt.ro, rt.rd));\n    initWave();\n    rt = mergeRT(rt, renderMediaSurface(rt.ro, rt.rd));\n    //rt = mergeRT(rt, renderBubble(rt.ro, rt.rd));\n    rt = mergeRT(rt, renderMediaVolume(rt.ro, rt.rd));\n    rt = mergeRT(rt, renderInnerShellBack(rt.ro, rt.rd));\n    rt = mergeRT(rt, renderBG(rt.transmittance, rt.rd));\n    fragColor = vec4(rt.radiance,1.0);\n}","name":"Image","description":"","type":"image"}]}