{"ver":"0.1","info":{"id":"tdyyDt","date":"1604001179","viewed":632,"name":"3d smoke effect from 2d textures","username":"wnu","description":"Using raymarching and a 2d smoke simulation we can create a 3d smoke effect that looks not bad. This volumetrically adds values of the intersection between two 2d smoke simulation textures at 90 degree angles from each other (XY, ZY planes). ","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["3d2dsmokefluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = U/R -0.5;\n    uv.x *= R.x/R.y;\n    uv *= 2.;\n    \n    //x and y axis rotations\n    mat4 rot = rotationMatrix(vec3(0.,1.,0.),2.*PI*iMouse.x/R.x);\n    mat4 rotY = rotationMatrix(vec3(1.,0.,0.),0.5*PI*(0.));\n    \n    //Volumetric Raymarching\n    \n    vec3 pos = vec3(0.,0.,0.2);\n    pos = (rot*rotY*vec4(pos,1.)).xyz;\n\n    //angled down direction rays\n    vec3 pd = normalize(vec3(uv*2. - vec2(0.,0.3),-1.));\n    pd = (rot*rotY*vec4(pd,1.)).xyz;\n    \n    \n    float t = 0.;\n    float count = 0.;\n    vec3 col = vec3(0.);\n    \n    for(int i;i<255; i++){\n        vec3 p = pos + t*pd;\n        p.xzy += 0.5;\n        vec3 p2 = pos + (t+0.015)*pd;\n        p2.xzy += 0.5;\n        \n\n    \tvec4 tOut1 = texture(iChannel0,p.xy);\n        vec4 tOut12 = texture(iChannel0,p.zy);\n        \n        //Interaction of xy, zy plane values\n        float val1 = tOut1.w*tOut12.w;\n        float mi1 = min(tOut1.w,tOut12.w);\n\n        //repeat for point a little further\n        vec4 tOut2 = texture(iChannel0,p2.xy);\n        vec4 tOut22 = texture(iChannel0,p2.zy);\n        \n        float val2 = tOut2.w*tOut22.w;\n        float mi2 = min(tOut2.w,tOut22.w);\n        \n        //could use break when p.z or p.x out of readable range to limit for loop iters\n        //volumetric (additive) coloring works really well\n        if(val1>0.000001&&val1>val2){\n            count += 1.;\n            col += vec3(mi1*val1)/2.;   \n        }\n        t+= 0.0018;\n    }\n    \n    col /= count;\n    \n    //increase low vals to make smoke more visible\n    col = exp((1./3.5)*log(col));\n    \n    C = vec4(col,1.);\n    \n    //uncomment below to see original 2d smoke sim used above\n    \n    //vec4 tex = texture(iChannel0,U/R);\n    //C = vec4(vec3(tex.w),1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Altered Copy of 2d smoke in \"Me And My Neighborhood\" from wyatt at https://www.shadertoy.com/view/WtsSz2\n//His explanation\n// wyattflanders.com/MeAndMyNeighborhood.pdf\n\n#define LOOKUP(COORD) texture(iChannel0,(COORD)/iResolution.xy)\n\n\nvec4 Field (vec2 position) {\n    // Rule 1 : All My Energy transates with my ordered Energy\n    vec2 velocityGuess = LOOKUP (position).xy;\n    vec2 positionGuess = position - velocityGuess;\n    for(int i;i<2;i++){\n    \tvelocityGuess = LOOKUP (position).xy;\n    \tpositionGuess = positionGuess - velocityGuess;\n    }\n\treturn LOOKUP (positionGuess);\n}\n\n\n\n\nvoid mainImage( out vec4 Energy, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    \n    \n    \n    vec2 Me = U;\n    Energy  =  Field(Me);\n    // Neighborhood :\n    vec4 pX  =  Field(Me + vec2(1,0));\n    vec4 pY  =  Field(Me + vec2(0,1));\n    vec4 nX  =  Field(Me - vec2(1,0));\n    vec4 nY  =  Field(Me - vec2(0,1));\n    \n    // Rule 2 : Disordered Energy diffuses completely :\n    Energy.b = (pX.b + pY.b + nX.b + nY.b)/4.0;\n    \n    // Rule 3 : Order in the disordered Energy creates Order :\n    vec2 Force;\n    Force.x = nX.b - pX.b;\n    Force.y = nY.b - pY.b;\n    Energy.xy += Force/4.0;\n    \n    // Rule 4 : Disorder in the ordered Energy creates Disorder :\n    Energy.b += (nX.x - pX.x + nY.y - pY.y)/3.;\n    \n    \n\t//add source:\n    Energy.w += 4.*smoothstep(0.006,0.003,length(U/R-vec2(0.5,0.1)))/30.; \n    \n    // Gravity effect :\n    Energy.y += Energy.w/300.; \n    \n    //Fase pressure and dye\n    Energy.z *= 0.999;\n    Energy.w *= 0.9999;\n\n    \n    // Mass concervation :\n    Energy.w += (nX.x*nX.w-pX.x*pX.w+nY.y*nY.w-pY.y*pY.w)/4.;\n    \n    //Boundary conditions :\n    if(Me.x<10.||Me.y<10.||iResolution.x-Me.x<10.||iResolution.y-Me.y<10.)\n    {\n    \t//Energy.xy *= 0.;\n        Energy *= 0.;\n    }\n    \n    //Fade dye at the top\n    Energy.w *= smoothstep(0.,10.,Me.x)*smoothstep(0.,10.,Me.y)*smoothstep(0.,100.,R.x-Me.x)*smoothstep(0.,200.,R.y-Me.y);\n    \n    // Mouse input  :  \n    if (iMouse.z > 0. && length(Me-iMouse.xy) < 10.) {\n        //Energy.w = 1.;\n       \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}