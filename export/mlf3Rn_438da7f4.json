{"ver":"0.1","info":{"id":"mlf3Rn","date":"1672583214","viewed":18,"name":"ferris wheel","username":"schmu","description":"ferris wheel","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ferriswheel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.14159265359\n# define TAU 6.28318530718\n# define TIMESCALE 3.0\n\nstruct Ray \n{\n    vec3 o;\n    vec3 d;\n};\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec3 rotate( in vec3 p, in vec3 r)\n{\n    float sx = sin(r.x);\n    float cx = cos(r.x);\n    float sy = sin(r.y);\n    float cy = cos(r.y);\n    float sz = sin(r.z);\n    float cz = cos(r.z);\n\n    p = vec3(p.x, cx*p.y - sx*p.z, sx*p.y + cx*p.z);\n    p = vec3(cy*p.x + sy*p.z, p.y, -sy*p.x + cy*p.z);\n    p = vec3(cz*p.x - sz*p.y, sz*p.x + cz*p.y, p.z);\n    \n    return p;\n}\n\nfloat getAngle( in vec3 pos )\n{\n    float angle = TAU/22.0;\n    float sector = round(atan(pos.z, pos.y)/angle);\n    return angle*sector;\n}\n\nfloat sdSphere( vec3 pos, in vec3 p, in float r )\n{\n    return length(pos - p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 d )\n{\n    vec3 q = abs(p) - d;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// r = sphere's radius\n// h = cutting's plane's position\n// t = thickness\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float w = sqrt(r*r-h*h);\n    \n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\nfloat sdWheel( vec3 pos, float t )\n{\n    pos.x = abs(pos.x);\n    \n    float cutout = sdCappedCylinder(pos, vec3(0.1, 0.0, 0.0), vec3(-0.1, 0.0, 0.0), 0.395);\n    float rings = sdCappedCylinder(pos, vec3(0.04, 0.0, 0.0), vec3(0.05, 0.0, 0.0), 0.4);\n    rings = max(-cutout, rings);\n    \n    pos.yz = mat2(cos(t), -sin(t), sin(t), cos(t)) * pos.yz;\n    float an = getAngle(pos);\n    pos.yz = mat2(cos(an), -sin(an), sin(an), cos(an)) * pos.yz;\n    \n    float beams = min(sdBox(pos-vec3(0.045, 0.2, 0.0), vec3(0.003, 0.2, 0.003)), \n                      sdBox(pos-vec3(0.02, 0.395, 0.0), vec3(0.02, 0.001, 0.001))-0.001);\n    beams = min(beams, sdCappedCylinder(pos, vec3(0.0399, 0.0, 0.0), vec3(-0.399, 0.0, 0.0), 0.015));\n    \n    return min(beams, rings);\n}\n\nfloat sdGondola( vec3 pos, float t )\n{\n    pos = pos + vec3(0.0, 0.04, 0.0);\n    pos.yz = mat2(cos(t), -sin(t), sin(t), cos(t)) * pos.yz;\n    float an = getAngle(pos);\n    pos.yz = mat2(cos(-t), -sin(-t), sin(-t), cos(-t)) * pos.yz;\n    \n    vec3 p = vec3(0.0, 0.395, 0.0);\n    p.yz = mat2(cos(-t), -sin(-t), sin(-t), cos(-t)) * p.yz;\n    p.yz = mat2(cos(-an), -sin(-an), sin(-an), cos(-an)) * p.yz;\n    \n    pos -= p;\n    float bottom = sdCutHollowSphere(pos, 0.032, -0.01, 0.001);\n    pos.yz = mat2(cos(TAU/2.0), -sin(TAU/2.0), sin(TAU/2.0), cos(TAU/2.0)) * pos.yz;\n    float top = sdCutHollowSphere(pos, 0.04, -0.025, 0.001);\n    float pole = sdCappedCylinder(pos, vec3(0.0, 0.03, 0.0), vec3(0.0, -0.03, 0.0), 0.002);\n    pole = min(pole, sdCappedCylinder(pos, vec3(0.0, 0.007, 0.0), vec3(0.0, 0.008, 0.0), 0.01));\n    return min(min(top, bottom), pole);\n}\n\nfloat sdBeams( vec3 pos )\n{\n    pos.x = abs(pos.x) - 0.04;\n    pos.z = abs(pos.z);\n    float beams = sdCappedCylinder(pos, vec3(0.0, 0.0, 0.0), vec3(0.1, -0.6, 0.15), 0.013);\n    \n    beams = min(beams, sdCappedCone(pos, 0.04, 0.013, 0.005));\n    \n    return beams;\n}\n\nfloat map( in vec3 pos ) \n{   \n    float scaledTime = iTime*TIMESCALE;\n    float d = -25.0;\n    float t = (scaledTime + d*sin(-1.0/d*scaledTime))/62.8318530718;\n    \n    float plane = pos.y + 0.5;\n    \n    float wheel = sdWheel(pos, t);\n    float gondola = sdGondola(pos, t);\n    float beams = sdBeams(pos);\n    float ferrisWheel = min(min(wheel, gondola), beams);\n    \n    return min(ferrisWheel, plane);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.000001, 0.0);\n    return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                          map(pos+e.yxy)-map(pos-e.yxy),\n                          map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat Raycast(Ray r)\n{\n    float t = 0.0;\n    \n    for (int i=0; i<100; i++) \n    {\n        vec3 pos = r.o + t*r.d;\n        \n        float h = abs(map(pos));\n        if(h < 0.000001)\n        {\n            break;\n        }\n        \n        \n        t += h;\n        if (t > 20.0)\n        {\n            break;\n        }\n        \n    }\n    \n    if (t > 20.0 ) \n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // environment\n    Ray sun;\n    sun.o = vec3(0.0);\n    sun.d = normalize(vec3(1.0, 1.0, 0.5));\n    vec3 sunCol = vec3(7.0, 5.0, 3.0);\n    vec3 skyCol = vec3(0.2, 0.45, 0.9);\n    vec3 bounceCol = vec3(0.25, 0.15, 0.1);\n    \n    // camera\n    //float angle = iTime*0.4;\n    float angle = 10.0*iMouse.x/iResolution.x;\n    \n    Ray r;\n    r.o = vec3(1.0*sin(angle), 0.0, 1.0*cos(angle));\n    //r.o = vec3(0.0, 0.0, 1.0);\n    vec3 forward = normalize(vec3(0.0) - r.o);\n    vec3 up = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 right = normalize(cross(up, forward));\n    r.d = normalize(uv.x*up + uv.y*right + 1.5*forward);\n    //r.d = normalize(vec3(uv, -1.5));\n    \n    \n    vec3 col = skyCol - 0.3*r.d.y + pow(2.71828182846, -2.0*uv.y)*0.5;\n    \n    // raymarching\n    float t = Raycast(r);\n    \n    if (t > 0.0) \n    {\n        vec3 pos = r.o + t*r.d;\n        vec3 normal = calcNormal(pos);\n        \n        vec3 mat = vec3(0.2);\n        \n        float sunDiffuse = clamp(dot(normal, sun.d), 0.0, 1.0);\n        float skyDiffuse = clamp(dot(normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        \n        Ray s;\n        s.o = pos + normal*0.001;\n        s.d = sun.d;\n        \n        float sunShadow = step(Raycast(s), 0.0001);\n        col  = mat * sunDiffuse * sunCol * sunShadow;\n        col += mat * skyDiffuse * skyCol;\n        \n        float bounceDiffuse = clamp(dot(normal, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        col += bounceDiffuse * bounceCol;\n    }\n\n    col = pow(col, vec3(0.4545));\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}