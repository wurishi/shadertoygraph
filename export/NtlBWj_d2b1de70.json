{"ver":"0.1","info":{"id":"NtlBWj","date":"1673115238","viewed":174,"name":"cube torus","username":"bradjamesgrant","description":"can't think of a background","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//change AA depending on specs\n#define AA 2.\n#define segments 15.0\n#define PI 3.14159\n#define TAU PI*2.0\n#define ZERO min(iFrame,0)\n#define boxScale .9\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\n\nfloat opRepLim( in float p, in float c, in float l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec2 rot(vec2 p,float a){\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(s,c,-c,s);\n}\nfloat sdRingBox( vec3 p, vec3 b)\n{\n  p*=1.4;\n  float angper = TAU/segments;\n  vec2 origin = vec2(0.0,.7);\n  float angle = iTime+atan(p.y,p.x)*2.;\n  vec3 pivotSpot = normalize(vec3(p.x,p.y,0.))*origin.y;\n  \n  \n  float r = length(p.xy)-origin.y;\n  vec2 twistCoords = vec2(r,p.z);\n  vec2 new = rot(twistCoords,(iTime+angle)/(2.));\n  r = new.x; p.z = new.y;\n  p.z = opRepLim(p.z,.13*((1.1+.6*max(0.0,sin(iTime)))*boxScale),1.);\n  r = opRepLim(r,.11*((1.1+.6*max(0.0,cos(PI/2.+iTime)))*boxScale),1.);\n  \n  //because angle is -x,x, ends up being 2x wide, so we divide by 2.\n  angle = mod(angle+angper,angper)-angper/2.;\n  p.xy = vec2(angle,r);\n  b.x/=boxScale;\n  vec3 q = abs(p) - b;\n  //subtracting at end of sdf creates 'rounded' cubes\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-.01;\n}\n\nfloat map(vec3 p){\n    return sdRingBox(p,boxScale*vec3((TAU/segments)-.22,0.05,.06));\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.001,0.0);\n    return normalize(vec3(map(p+e.xyy), map(p+e.yxy),map(p+e.yyx)));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 rm(vec3 ro, vec3 rd){\n    vec3 p;\n    float t, d, r;\n    for(int i =0; i<1000; i++){\n        p = ro+t*rd;\n        d = map(p);\n        if(d>10.)\n            break;\n        if(d<0.0001){\n            t+=d;\n            p=ro+t*rd;\n            vec3 n =  getNormal(p);\n            float fre = clamp(1.0+dot(n,rd),0.0,1.0);\n            float AO =calcAO(p,n,iTime);\n            return (1.0-pow(fre,2.))*AO*(.5+.5*abs(n.y)*vec3(0.4,0.8,0.9));\n        }\n        t+=d*.6;\n    }\n    float ratio = pow(abs(rd.y/rd.z),3.);\n    return mix(vec3(.0,.0,.0),vec3(.7,.2,.68),ratio);\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.,0.,0.);\n    for(float m = 0.;m<AA;m++){\n    \tfor(float n = 0.;n<AA;n++){\n        vec2 uv = (fragCoord+(vec2(m,n)/AA)-(iResolution.xy*.5))/iResolution.x;\n        vec3 ro = vec3(cos(iTime),0.,sin(iTime))*20.;\n        ro = vec3(0.,0.,-1.0);\n        vec3 cf = -normalize(ro);\n        vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = cf+(uv.x*cs + uv.y*cu)*5.5;\n\n        vec3 rd = normalize(uuv-ro);\n        col += rm(ro,rd);\n        }\n     }\n     col/=AA*AA;\n        // Output to screen\n        col = pow(col, vec3(1.0/2.2));\n        fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}