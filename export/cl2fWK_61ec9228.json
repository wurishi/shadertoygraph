{"ver":"0.1","info":{"id":"cl2fWK","date":"1694591913","viewed":96,"name":"raytraced voxel experiments","username":"Variadicism","description":"This raytracing implementation has voxels that reflect, refract, and emit light. It has downsampling and twinkle filter effects I'm experimenting with. Feel free to try out the many settings! Check out BitBucket for source history! :)","likes":0,"published":1,"flags":32,"usePreview":1,"tags":["raytracing","reflection","refraction","filter","voxel","twinkle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 fromBuffer(sampler2D buffer, vec2 position) {\n    return texture(buffer, downsampled(position)/iResolution.xy);\n}\n\nvec3 colorFor(vec2 position) {\n    return fromBuffer(iChannel1, position).xyz;\n}\n\n// vec2 position (in pixels)\n// 0 <= color <= 1; the alpha is ignored.\nvoid mainImage(out vec4 color, in vec2 position) {\n    color = vec4(colorFor(position), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// v1.1.0.1\n\n///////////////////////////// TYPES //////////////////////////////////\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n    vec3 color;\n    float emission;\n    float opacity;\n    float reflectivity;\n    float refraction;\n};\n\nstruct Voxel {\n\tvec3 origin;  // point of lowest x, y, and z\n    Material material;\n};\n\nstruct RayHit {\n    Ray ray;\n\tint index;\n\tfloat distance;\n    vec3 position;\n    Material material;\n    vec3 normal;\n    vec2 texCoords;\n    int face;\n    bool originIn;  // whether the origin is inside a voxel\n};\n\n///////////////////////////// CONSTANTS //////////////////////////////////\n\n// Factual:\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITY = 1e9;\nconst float SQRT2 = 1.41421356237;\n\nconst float AIR_REFRACTION_INDEX = 1.000293;\nconst float GLASS_REFRACTION_INDEX = 1.52;\n\n// Utility:\n\nconst int NO_OBJECT = -1;\n\nconst int ANY_FACE = -1;\nconst int TOP = 0;\nconst int BOTTOM = 1;\nconst int POSX = 2;\nconst int NEGX = 3;\nconst int POSZ = 4;\nconst int NEGZ = 5;\n\n/////////////////////////// SETTINGS //////////////////////////////////////\nconst vec3 BACKGROUND_COLOR = vec3(0.7);\nconst Material BACKGROUND_SURFACE = Material(BACKGROUND_COLOR, 0.0, 1.0, 0.0, 0.0);\n\nconst int DOWNSAMPLING = 1;\n\nconst int MAX_BOUNCE_DEPTH = 2;                                  // reflection & refraction step depth\nconst int MAX_BOUNCES = int(pow(2.0, float(MAX_BOUNCE_DEPTH)));  // Each hit may result in a reflection and a refraction.\n\nconst float AMBIENT_INTENSITY = 0.5;\nconst float MAX_SPECULAR_SHINE = 20.0;\n\nconst float MAX_CAMERA_ROTATION = 2.0*PI;\nconst float CAMERA_PITCH_WITHOUT_HOP = -PI/8.0;\nconst vec3 FOCAL_POINT = vec3(0.0);             // The location the camera points at\nconst float FOCAL_LENGTH = 2.0;\nconst float MAX_EYE_DISTANCE = 25.0;\nconst float HOP_MIN_PITCH = PI/8.0;\nconst float HOP_DURATION = 0.0;                 // 0.0 to disable hop\nconst float HOP_PEAK_PITCH = -PI/2.0;\n\n// Derived; do not change!\n\nconst float DOWNSAMPLING_F = float(DOWNSAMPLING);\n\n// SCENE ITEMS:\n\nconst int NUMBER_OF_VOXELS = 12;\nVoxel VOXELS[NUMBER_OF_VOXELS] = Voxel[](\n    // origin                        color                emission opacity reflectivity refraction\n    // (int, int, int)               0.0 <= rgb <= 1.0    0.0+     0.0-1.0 0.0-1.0\n    // green 90% reflective at origin\n    Voxel(vec3(0),          Material(vec3(0.0, 1.0, 0.0), 0.0,     1.0,    0.9,         0.0)),\n    // plain black\n    Voxel(vec3(0, -1, 0),   Material(vec3(0.0),           0.0,     1.0,    0.0,         0.0)),\n    // plain white\n    Voxel(vec3(1, -1, 0),   Material(vec3(1.0),           0.0,     1.0,    0.0,         0.0)),\n    // plain brown\n    Voxel(vec3(-2, 1, 0),   Material(vec3(0.6, 0.3, 0.0), 0.0,     1.0,    0.0,         0.0)),\n    // 25% opaque, 25% reflective cyan glass\n    Voxel(vec3(-2, 1, -1),  Material(vec3(0.0, 1.0, 1.0), 0.0,     0.25,   0.25,        GLASS_REFRACTION_INDEX)),\n    // 55% opaque, 35% reflective blue glass\n    Voxel(vec3(0, -1, -2),  Material(vec3(0.0, 0.0, 1.0), 0.0,     0.55,   0.35,        GLASS_REFRACTION_INDEX)),\n    // 35% opaque non-reflective red glass\n    Voxel(vec3(-1, 0, -5),  Material(vec3(0.5, 0.0, 0.0), 0.0,     0.35,   0.0,         GLASS_REFRACTION_INDEX)),\n    // perfectly clear, 20% reflective glass\n    Voxel(vec3(-3, 1, -4),  Material(vec3(0.0),           0.0,     0.0,    0.2,         GLASS_REFRACTION_INDEX)),\n    // perfect mirror\n    Voxel(vec3(3, -1, -1),  Material(vec3(0.6),           0.0,     1.0,    1.0,         0.0)),\n    // green light\n    Voxel(vec3(1, 10, -1),  Material(vec3(0.0, 1.0, 0.0), 0.25,    1.0,    0.0,         0.0)),\n    // yellow light\n    Voxel(vec3(-9, 9, 9),   Material(vec3(1.0, 1.0, 0.0), 1.0,     1.0,    0.0,         0.0)),\n    // dim light blue light\n    Voxel(vec3(0, -1, -5),  Material(vec3(0.2, 0.2, 1.0), 1.0,     1.0,    0.0,         0.0)));\n\n/////////////////////////// BASE UTILITIES ////////////////////////////////\n\n// MATH:\nfloat root(float value, float root) {\n\treturn exp(log(value) / root);\n}\n\nint intmod(int base, int modulo) {\n    return int(mod(float(base), float(modulo)));\n}\n\nvec3 pitchYawVector(float pitch, float yaw) {\n    return vec3(\n        cos(yaw)*cos(pitch),\n        sin(pitch),\n        sin(yaw)*cos(pitch));\n}\n\n// TRANSFORMATIONS:\nvec3 apply(vec3 vector, mat4 transformation) {\n\tvec4 vector4d = vec4(vector, 1.0);\n    vec4 transformedVector4d = vector4d * inverse(transformation);\n    return transformedVector4d.xyz;\n}\n\nmat4 translate(vec3 translation) {\n    mat4 result = mat4(1.0);\n    result[3].xyz = translation;\n    return result;\n}\n\nmat4 scale(vec3 scale) {\n    mat4 result = mat4(1.0);\n    result[0][0] = scale.x;\n    result[1][1] = scale.y;\n    result[2][2] = scale.z;\n    return result;\n}\n\nmat4 rotate(vec3 axis, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    return mat4(mat3(\n        cosA + axis.x*axis.x*(1.0-cosA), axis.x*axis.y*(1.0-cosA) - axis.z*sinA, axis.x*axis.z*(1.0-cosA) + axis.y*sinA,\n        axis.x*axis.y*(1.0-cosA) + axis.z*sinA, cosA + axis.y*axis.y*(1.0-cosA), axis.y*axis.z*(1.0-cosA) - axis.x*sinA,\n        axis.x*axis.z*(1.0-cosA) - axis.y*sinA, axis.y*axis.z*(1.0-cosA) + axis.x*sinA, cosA + axis.z*axis.z*(1.0-cosA)));\n}\n\n// QUADRATICS:\nstruct QuadraticResult {\n    int results;\n    float largerResult;\n    float smallerResult;\n};\nconst QuadraticResult NO_SOLUTION = QuadraticResult(0, 0.0, 0.0);\n\nQuadraticResult solveQuadratic(float a, float b, float c) {\n    if (a == 0.0)\n        return NO_SOLUTION;\n\n    float ac4 = 4.0*a*c;\n    float b2 = b*b;\n    if (ac4 > b2)\n        return NO_SOLUTION;\n\n    float squareRoot = sqrt(b2 - ac4);\n    if (squareRoot == 0.0)\n        return QuadraticResult(1, -b/(2.0*a), 0.0);\n    else\n        return QuadraticResult(2, (-b + squareRoot)/(2.0*a), (-b - squareRoot)/(2.0*a));\n}\n\n///////////////////////////////// RAYTRACING ////////////////////////////////////////\n\n// RAYS:\n\nvec3 rayAt(Ray ray, float distance) {\n\treturn ray.origin + ray.direction * distance;\n}\n\nRayHit noHit(Ray ray) {\n    return RayHit(ray, NO_OBJECT, INFINITY, vec3(INFINITY), BACKGROUND_SURFACE, vec3(0.0), vec2(0.0), ANY_FACE, false);\n}\n\nRayHit closer(RayHit hit1, RayHit hit2) {\n\tif (hit2.distance < 0.0 || hit1.distance <= hit2.distance)\n\t\treturn hit1;\n\telse\n\t\treturn hit2;\n}\n\n// VOXELS:\n\nRayHit hitFor(Ray ray, int objectIndex, int excludedFace) {\n    Voxel voxel = VOXELS[objectIndex];\n    mat4 toVoxelSpace = translate(-voxel.origin);\n    mat4 fromVoxelSpace = translate(voxel.origin);\n\n    // https://iquilezles.org/articles/boxfunctions\n\n    Ray rayInVoxelSpace = Ray((toVoxelSpace*vec4(ray.origin,1.0)).xyz, (toVoxelSpace*vec4(ray.direction,0.0)).xyz);\n\n    vec3 s = -sign(rayInVoxelSpace.direction);\n    vec3 t1 = (-rayInVoxelSpace.origin + s*0.5)/rayInVoxelSpace.direction;\n    vec3 t2 = (-rayInVoxelSpace.origin - s*0.5)/rayInVoxelSpace.direction;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if(tN > tF || tF < 0.0)\n        return noHit(ray);\n    bool originIn = tN <= 0.0;\n    /* branched */ vec3 normal;\n    /* branched */ vec2 texCoords;\n    /* branched */ int face;\n    if(t1.x > t1.y && t1.x > t1.z) {\n        normal = fromVoxelSpace[0].xyz*s.x;\n        texCoords = rayInVoxelSpace.origin.yz + rayInVoxelSpace.direction.yz*t1.x;\n        face = (5 + int(s.y))/2;\n    } else if(t1.y > t1.z) {\n        normal = fromVoxelSpace[1].xyz*s.y;\n        texCoords = rayInVoxelSpace.origin.zx + rayInVoxelSpace.direction.zx*t1.y;\n        face = (1 + int(s.x))/2;\n    } else {\n        normal = fromVoxelSpace[2].xyz*s.z;\n        texCoords = rayInVoxelSpace.origin.xy + rayInVoxelSpace.direction.xy*t1.z;\n        face = (9 + int(s.z))/2;\n    }\n    float distance = originIn || face == excludedFace ? tF : tN;\n    \n\n    return RayHit(ray, objectIndex, distance, rayAt(ray, distance), voxel.material, normal, texCoords, face, originIn);\n}\n\n// CLOSED FORM RAY TRACING FUNCTIONS:\n\nRayHit traceHitExcludingFace(Ray ray, int excludedIndex, int excludedFace) {\n\tRayHit hit = noHit(ray);\n\t\n\tfor (int objectIndex = 0; objectIndex < NUMBER_OF_VOXELS; objectIndex++) {\n        if (objectIndex != excludedIndex || excludedFace != ANY_FACE)\n            hit = closer(hit, hitFor(ray, objectIndex, objectIndex == excludedIndex ? excludedFace : ANY_FACE));\n\t}\n\n\treturn hit;\n}\n\nRayHit traceHitExcluding(Ray ray, int excludedIndex) {\n    return traceHitExcludingFace(ray, excludedIndex, ANY_FACE);\n}\n\nRayHit traceHit(Ray ray) {\n\treturn traceHitExcludingFace(ray, NO_OBJECT, ANY_FACE);\n}\n\nRayHit traceRefraction(RayHit start) {\n    vec3 refractionDirection = normalize(refract(\n        start.ray.direction,\n        start.normal,\n        AIR_REFRACTION_INDEX/start.material.refraction));\n    Ray refractedRay = Ray(start.position, refractionDirection);\n    RayHit refractedHit = hitFor(refractedRay, start.index, start.face);\n\n    if (start.originIn) {\n        return refractedHit;\n    } else {\n        vec3 exitDirection = normalize(refract(\n            refractedHit.ray.direction,\n            refractedHit.normal,\n            refractedHit.material.refraction/AIR_REFRACTION_INDEX));\n\n        Ray exitingRefractedRay = Ray(refractedHit.position, exitDirection);\n        return traceHitExcluding(exitingRefractedRay, start.index);\n    }\n}\n\nRayHit traceReflection(RayHit start) {\n    Ray reflectedRay = Ray(start.position, reflect(start.ray.direction, start.normal));\n    return traceHitExcluding(reflectedRay, start.index);\n}\n\n// OTHER UTILITIES:\n\nvec2 downsampled(vec2 pos) {\n    return floor(pos/DOWNSAMPLING_F)*DOWNSAMPLING_F + DOWNSAMPLING_F/2.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer does not actually output color!\n// Instead, it will give the position (vec3) of a ray hit and  the index of the voxel that it hit (int) inside a vec4.\n// In a real engine, Buffers A and B would probably be one buffer outputting a more complex data type because some\n// calculations are repeated this way, but this is as close as I can get to that with Shadertoy's fragment shaders.\n// This will be used by both Buffer B and the final fragment shader.\n\n// Apparently, Shadertoy doesn't give its special uniforms to Common, so I have to copy and paste. :|\n\n/////////////////////////////////////// COPIED UTILITIES //////////////////////////////////////////////\n// CAMERA:\n\nvec4 getMouse() {\n    if (clamp(iMouse.x, 0.0, iResolution.x) != iMouse.x || clamp(iMouse.y, 0.0, iResolution.y) != iMouse.y)\n        // Center the mouse by default.\n        return vec4(iResolution.x/2.0, iResolution.y/2.0, iResolution.x/2.0, iResolution.y/2.0);\n    else return iMouse;\n}\n\nfloat getRightYaw() {\n    return (1.0 - getMouse().x/iResolution.x*2.0)*MAX_CAMERA_ROTATION/2.0;\n}\n\nfloat getEyeYaw() {\n    // eyeYaw = 0 -> facing right (toward +x), eyeYaw = pi/2 -> facing forward (toward +z)\n    return getRightYaw() + PI/2.0;\n}\n\nvec3 getEye() {\n    vec4 mouse = getMouse();\n    float eyeDistance = MAX_EYE_DISTANCE*(iResolution.y - mouse.y)/iResolution.y;\n\n    /* branched */ float pitch;\n    if (HOP_DURATION > 0.0) {\n        float hopProgress = mod(iTime, HOP_DURATION)/HOP_DURATION;\n        float hopProgressAlongArc = 4.0*(1.0 - hopProgress)*hopProgress;\n\n        pitch = HOP_MIN_PITCH + (HOP_PEAK_PITCH - HOP_MIN_PITCH)*hopProgressAlongArc;\n    } else {\n        pitch = CAMERA_PITCH_WITHOUT_HOP;\n    }\n\n    return -eyeDistance*pitchYawVector(pitch, getEyeYaw());\n}\n\nRay getRayForPixel(vec2 pixel) {\n    vec3 eye = getEye();\n    vec3 forward = normalize(FOCAL_POINT - eye);\n    vec3 right = pitchYawVector(0.0, getRightYaw());\n    vec3 up = cross(forward, right);\n\n\tvec2 posNormalized = 2.0*pixel/iResolution.xy - 1.0;\n\n\treturn Ray(eye,\n        normalize(forward*FOCAL_LENGTH + right*posNormalized.x*iResolution.x/iResolution.y + up*posNormalized.y));\n}\n\n/////////////////////////////////////// IMPLEMENTATION //////////////////////////////////////////////\n\nvoid mainImage(out vec4 color, in vec2 position) {\n    RayHit hit = traceHit(getRayForPixel(position));\n    color = vec4(hit.position, hit.index);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer starts with a RayHit traced from the camera in Buffer A and finds the color at that\n// location. This includes calculating texturing, lighting, reflection, refraction, etc.\n\n// Apparently, Shadertoy doesn't give its special uniforms to Common, so I have to copy and paste. :|\n/////////////////////////////////////// COPIED UTILITIES //////////////////////////////////////////////\n\n// CAMERA:\n\nvec4 getMouse() {\n    if (clamp(iMouse.x, 0.0, iResolution.x) != iMouse.x || clamp(iMouse.y, 0.0, iResolution.y) != iMouse.y)\n        // Center the mouse by default.\n        return vec4(iResolution.x/2.0, iResolution.y/2.0, iResolution.x/2.0, iResolution.y/2.0);\n    else return iMouse;\n}\n\nfloat getRightYaw() {\n    return (1.0 - getMouse().x/iResolution.x*2.0)*MAX_CAMERA_ROTATION/2.0;\n}\n\nfloat getEyeYaw() {\n    // eyeYaw = 0 -> facing right (toward +x), eyeYaw = pi/2 -> facing forward (toward +z)\n    return getRightYaw() + PI/2.0;\n}\n\nvec3 getEye() {\n    vec4 mouse = getMouse();\n    float eyeDistance = MAX_EYE_DISTANCE*(iResolution.y - mouse.y)/iResolution.y;\n\n    /* branched */ float pitch;\n    if (HOP_DURATION > 0.0) {\n        float hopProgress = mod(iTime, HOP_DURATION)/HOP_DURATION;\n        float hopProgressAlongArc = 4.0*(1.0 - hopProgress)*hopProgress;\n\n        pitch = HOP_MIN_PITCH + (HOP_PEAK_PITCH - HOP_MIN_PITCH)*hopProgressAlongArc;\n    } else {\n        pitch = CAMERA_PITCH_WITHOUT_HOP;\n    }\n\n    return -eyeDistance*pitchYawVector(pitch, getEyeYaw());\n}\n\nRay getRayForPixel(vec2 pixel) {\n    vec3 eye = getEye();\n    vec3 forward = normalize(FOCAL_POINT - eye);\n    vec3 right = pitchYawVector(0.0, getRightYaw());\n    vec3 up = cross(forward, right);\n\n\tvec2 posNormalized = 2.0*pixel/iResolution.xy - 1.0;\n\n\treturn Ray(eye,\n        normalize(forward*FOCAL_LENGTH + right*posNormalized.x*iResolution.x/iResolution.y + up*posNormalized.y));\n}\n\n// BUFFER:\n\nvec4 fromBuffer(sampler2D buffer, vec2 position) {\n    return texture(buffer, downsampled(position)/iResolution.xy);\n}\n\n/////////////////////////////////////// IMPLEMENTATION //////////////////////////////////////////////\n\n// SHINE FUNCTIONS:\n\nfloat diffuseIllumination(RayHit hit, Voxel emissiveVoxel) {\n\treturn max(dot(normalize(hit.normal), normalize(emissiveVoxel.origin - hit.position)), 0.0);\n}\n\nvec3 specularShine(RayHit hit, Voxel emissiveVoxel) {\n    vec3 hitToEye = normalize(getEye() - hit.position);\n\tvec3 hitToLight = normalize(emissiveVoxel.origin - hit.position);\n\tvec3 reflectionToEye = -reflect(hitToLight, hit.normal);\n\t\n\treturn clamp(emissiveVoxel.material.color * pow(max(dot(hitToEye, reflectionToEye), 0.0), MAX_SPECULAR_SHINE), 0.0, 1.0);\n}\n\n// COLORING FUNCTIONS:\n\nvec4 baseColorAt(RayHit hit) {\n\tif (hit.index < 0)\n\t\treturn vec4(BACKGROUND_COLOR, 1.0);\n\n    float materialColorStrength = min(1.0, hit.material.emission + AMBIENT_INTENSITY);\n\tvec3 baseColor = hit.material.color*materialColorStrength;\n\tfor (int i = 0; i < NUMBER_OF_VOXELS; i++) {\n        if (VOXELS[i].material.emission > 0.0 && hit.index != i) {\n            Voxel emissiveVoxel = VOXELS[i];\n            Ray positionToLightRay = Ray(hit.position, normalize(emissiveVoxel.origin - hit.position));\n            RayHit lightHit = traceHitExcluding(positionToLightRay, hit.index);\n            if (lightHit.index == i)\n                baseColor += (1.0 - materialColorStrength) *\n                    (diffuseIllumination(hit, emissiveVoxel)*emissiveVoxel.material.color + \n                    specularShine(hit, emissiveVoxel));\n            // TODO: if it hits something else and that thing is transparent, apply some of its color. (Refraction? Reflection?)\n        }\n\t}\n\n    float baseColorOpacity = hit.material.opacity*(1.0 - hit.material.reflectivity);\n\treturn vec4(baseColor*baseColorOpacity, baseColorOpacity);\n}\n\n// MAIN TRACING:\n\nvec3 colorFor(RayHit start) {    \n    /**\n     * My old C.F.R.T. only did one level of refraction with no subsequent refractions or reflections. This fixes that.\n     * To avoid recursion prohibited in GLSL :(, I've made my own stack memory for ray hits and opacity remainders.\n     * The hits array always starts with the hit of the starting ray.\n     * At bounce = 0, the hits array will be filled by reflecting the ray around.\n     * At bounce increment, the largest new 1 bit represents the index of the hit to change to refraction.\n     * When one hit is changed, every subsequent hit (to the end of the array) must be recalculated with new reflection hits.\n     * The end result is iterating depth-first through all possible combinations of reflection and refraction hits.\n     */\n    /* mutable */ RayHit hits[MAX_BOUNCE_DEPTH + 1] =\n        // Yes, this initialization has to be adjusted with `noHit`s if you change BOUNCE_DEPTH. Sorry.\n        RayHit[](start, noHit(start.ray), noHit(start.ray));\n    vec4 startColor = baseColorAt(start);\n    /* mutable */ vec4 color = startColor;\n    /* mutable */ float opacityClaims[MAX_BOUNCE_DEPTH] =\n        // And this initialization has to be filled with `1.0`s for BOUNCE_DEPTH changes as well. :|\n        float[](1.0, 1.0);\n    for (int bounce = 0; bounce <= MAX_BOUNCES; bounce++) {\n        /* mutable */ bool updating = bounce == 0;\n        /* mutable */ float opacityRemaining = 1.0 - startColor.w;\n        for (int bounceDepth = 1; bounceDepth <= MAX_BOUNCE_DEPTH; bounceDepth++) {\n            /* mutable */ float opacityClaim;\n            RayHit prevHit = hits[bounceDepth - 1];\n            if (updating) {\n                hits[bounceDepth] = traceReflection(prevHit);\n                opacityClaim = prevHit.material.reflectivity*prevHit.material.opacity;\n            } else if (mod(float(bounce), pow(2.0, float(MAX_BOUNCE_DEPTH - bounceDepth))) == 0.0) {\n                updating = true;\n                hits[bounceDepth] = traceRefraction(prevHit);\n                if (prevHit.originIn)\n                    hits[bounceDepth].normal = -hits[bounceDepth].normal;\n                opacityClaim = 1.0 - prevHit.material.opacity;\n            } else {\n                opacityClaim = opacityClaims[bounceDepth - 1];\n            }\n\n            opacityClaims[bounceDepth - 1] = opacityClaim;\n            if (updating)\n                color += baseColorAt(hits[bounceDepth])*opacityRemaining*opacityClaim;\n            opacityRemaining *= opacityClaim;\n        }\n    }\n    \n    return color.xyz;\n}\n\nvoid mainImage(out vec4 color, in vec2 position) {\n    vec4 hitPosAndIndex = fromBuffer(iChannel0, position);\n    // TODO: derive the hit info from the parameters given instead of recalculating it all.\n    RayHit hit = hitFor(getRayForPixel(position), int(hitPosAndIndex.w), ANY_FACE);\n    \n    color = vec4(colorFor(hit), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}