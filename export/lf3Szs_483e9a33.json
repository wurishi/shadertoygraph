{"ver":"0.1","info":{"id":"lf3Szs","date":"1714313161","viewed":53,"name":"Multiple triangle intersection","username":"Chama_lo","description":"Using the shader to intersect multiple triangle intersection with some cool color stuff.\nNewt step is procedural triangle generation and free camera movement","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["triangleintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Parameter\n// Define an array of triangles\nconst int numTriangles = 50; // Set the number of triangles\n\n\n// Define the structure for a triangle\nstruct Triangle {\n    vec3 V1;\n    vec3 V2;\n    vec3 V3;\n};\n\n\n// Function to generate a random float between min and max\nfloat randomFloat(float min, float max, float seed) {\n    return fract(sin(seed) * 43421.6 +iTime/2.0) * (max - min) + min;\n}\n\n// Function to generate a random vector within a given range\nvec3 randomVector(vec3 minValues, vec3 maxValues, float seed) {\n    return vec3(\n        randomFloat(minValues.x, maxValues.x, seed),\n        randomFloat(minValues.y, maxValues.y, seed + 1.0),\n        randomFloat(minValues.z, maxValues.z, seed + 2.0)\n    );\n}\n\n// Function to randomly populate the triangle array\nTriangle[numTriangles] populateTriangleArray(Triangle[numTriangles] triangles) {\n\n    for (int i = 0; i < numTriangles; i++) {\n        // Generate random vertices for the triangle within a certain range\n        vec3 vertex1 = randomVector(vec3(-3.0, -3.0, 1.0), vec3(3.0, 3.0, 100.0), float(i));\n        vec3 vertex2 = randomVector(vec3(-3.0, -3.0, 1.0), vec3(3.0, 3.0, 100.0), float(i + 1));\n        vec3 vertex3 = randomVector(vec3(-3.0, -3.0, 1.0), vec3(3.0, 3.0, 100.0), float(i + 2));\n        \n        // Add the triangle to the array\n        Triangle triangle;\n        triangle.V1 = vertex1;\n        triangle.V2 = vertex2;\n        triangle.V3 = vertex3;\n        \n        triangles[i] = triangle;\n    }\n    \n    /*\n    //-- manualy edit the second triangle --\n\n    // Create instances of Coord for each vertex of the triangle\n    vec3 vertex1 =vec3 (0.0, 0.0, 20.0);\n    vec3 vertex2 = vec3(-0.5, 0.0, 5.0);\n    vec3 vertex3 = vec3(0.0, -0.5, 5.0);\n\n    // Initialize the triangle using the Coord instances\n    Triangle myTriangle;\n    myTriangle.V1 = vertex1;\n    myTriangle.V2 = vertex2;\n    myTriangle.V3 = vertex3;\n        \n    triangles[1] = myTriangle;\n    */\n    \n    return triangles;\n}\n\n\n// Function to intersect a ray with a single triangle\nfloat intersectTriangle(vec3 origineRayon, vec3 directionRayon,Triangle myTriangle)\n{\n    // V1, V2, V3 are the vertices of the triangle\n    vec3 edge1 = myTriangle.V2 - myTriangle.V1;\n    vec3 edge2 = myTriangle.V3 - myTriangle.V1;\n    vec3 h = cross(directionRayon, edge2);\n    float a = dot(edge1, h);\n    \n    if (abs(a) < 0.0001) // Check if ray is parallel to the triangle\n    {\n        return 0.0;\n    }\n    \n    float f = 1.0 / a;\n    vec3 s = origineRayon - myTriangle.V1;\n    float u = f * dot(s, h);\n    \n    if (u < 0.0 || u > 1.0)\n        return 0.0;\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(directionRayon, q);\n    \n    if (v < 0.0 || (u + v) > 1.0)\n        return 0.0;\n    \n    float t = f * dot(edge2, q);\n    \n    if (t > 0.0001) // Check if the intersection is in front of the ray origin\n        return t;\n    else\n        return 0.0;\n}\n\n\n// Function to intersect a ray with multiple triangles and find the closest intersection\nfloat intersectMultipleTriangles(vec3 origineRayon, vec3 directionRayon, Triangle[numTriangles] triangles) {\n\n    float closestDistance = 0.0;\n    \n    for (int i = 0; i < numTriangles; i++) \n    {\n        Triangle currentTriangle = triangles[i];\n        float Actualdistance = intersectTriangle(origineRayon, directionRayon, currentTriangle);\n        \n        if (Actualdistance > 0.0 && (closestDistance == 0.0 || Actualdistance < closestDistance)) {\n            closestDistance = Actualdistance;\n        }\n    }\n    \n    return closestDistance;\n}\n\n// Main function to render the scene\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \n    Triangle triangles[numTriangles];\n    \n    // Populate the triangle array with random triangles\n    triangles = populateTriangleArray(triangles);\n    \n    /*\n    //Made first triangle hand made\n    \n    // Create instances of Coord for each vertex of the triangle\n    vec3 vertex1 =vec3 (0.0, 0.0, 20.0);\n    vec3 vertex2 = vec3(0.5, 0.0, 5.0);\n    vec3 vertex3 = vec3(0.0, 0.5, 5.0);\n\n    // Initialize the triangle using the Coord instances\n    Triangle myTriangle;\n    myTriangle.V1 = vertex1;\n    myTriangle.V2 = vertex2;\n    myTriangle.V3 = vertex3;\n        \n    triangles[0] = myTriangle;\n    */\n\n    \n    //---- CAMERA HANDLE ----//\n    \n    //initialise Camera Origin\n    vec3 camOrigin;\n    camOrigin.x = 0.0 +sin(iTime+5.0)/5.0;\n    camOrigin.y = 0.0 +sin(iTime)/5.0;\n    camOrigin.z = -3.0;\n\n    vec4 outputColor= vec4 (0.0,0.0,0.0,0.0);\n\n    \n    \n    //fragCoord go from 0,0 to iResolution.x, iResolution.y\n \n    //fragCoord.y / iResolution.y-0.5 go from -0.5 to 0.5\n    \n    //Calcul du ratio de l'écran\n    float ratio = iResolution.y/iResolution.x;\n    \n    \n    //ScreePixel vec2 (x,y)\n    // -0.5, 0,5  bord en haut à gauche  \n    // 0.5 ,-0,5  bord en bas à droite\n    vec2 ScreePixel = vec2 (fragCoord.x / iResolution.x-0.5,(fragCoord.y / iResolution.y-0.5)*ratio );\n    \n    \n    \n    //direction du rayon Caméra écran projeté sur l'écran\n    vec3 RayDir = vec3(ScreePixel.x-camOrigin.x,ScreePixel.y -camOrigin.y, 0.0-camOrigin.z);\n    \n    //---- CAMERA HANDLE END-//\n\n    // Find intersection with multiple triangles\n    float distance = intersectMultipleTriangles(camOrigin, RayDir, triangles);\n    \n    // Set color based on intersection distance\n    if (distance != 0.0) {\n        fragColor = vec4(sin(iTime+5.2)+2.0 / distance*2.0, sin(iTime+3.2)+2.0 / distance*2.0,sin(iTime)+2.0 / distance*2.0, 0.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n\n\n","name":"Image","description":"","type":"image"}]}