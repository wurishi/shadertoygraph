{"ver":"0.1","info":{"id":"WdVBzc","date":"1607795790","viewed":186,"name":"Raymarching SDF Example","username":"Heasmo","description":"I've been learning raymarching with signed distance functions from Inigo Quilez. So I thought I'd share a test project that went well :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdfraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, vec3 offset, float radius)\n{\n    return length(p - offset) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 c, vec3 b, float r)\n{\n    vec3 q = abs(p - c) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec4 texcube( sampler2D tex, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( tex, p.yz );\n\tvec4 y = texture( tex, p.zx );\n\tvec4 z = texture( tex, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nfloat sdf_smin(float a, float b, float k)\n{\n\tfloat res = exp(-k*a) + exp(-k*b);\n\treturn -log(max(0.0001,res)) / k;\n}\n\nfloat map(in vec3 pos)\n{\n    float sphere1 = sdSphere(pos, vec3(0.f, cos(iTime) * .5f, 0.f), .25f);\n    float sphere2 = sdSphere(pos, vec3(sin(iTime), sin(iTime) * .25f, cos(iTime)), (sin(iTime) + 2.f) * .1f);\n    float box1 = sdBox(pos, vec3(sin(iTime), 0.f, cos(iTime)), vec3(.25f), .01f);\n    float box2 = sdBox(pos, vec3(1.f, .0f, 1.f), vec3(.25f, 1.f, .5f), .1f);\n    float plane1 = pos.y + .25f;\n    float sphere3 = sdSphere(pos, vec3(0.f), 5.f);\n    \n    return sdf_smin(plane1, sdf_smin(sphere1, sdf_smin(box2, sphere2, 4.f), 4.f), 4.f);\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, time ).x );\n#else\n    // klems's trick to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat castRay(in vec3 ro, vec3 rd, out int a)\n{\n    float t = 0.f;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        \n        if (h < .001f) break;\n        \n        t += h;\n        if (t > 20.f) break;\n        a++;\n    }\n    if (t > 20.f) t = -1.f;\n    return t;\n}\n\nfloat shadow(in vec3 ro, vec3 rd, out int a)\n{\n    float t = 0.f;\n    float res = 1.f;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        \n        if (h < .001f) break;\n        res = min(res, 32.f*h/t);\n        t += h;\n        if (t > 20.f) break;\n        a++;\n    }\n    if (t > 20.f) t = -1.f;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.f*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float an = 10.f * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(1.f*sin(an), .5f, 1.f*cos(an));\n    vec3 ta = vec3(.0f, .0f, 0.f);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.5f*ww);\n    \n    vec3 col = vec3(.65f, .8f, 1.f) - .5f * rd.y * 2.f;\n    \n    int a = 0;\n    float t = castRay(ro, rd, a);\n    \n    if (t > -.5f)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, t);\n        \n        vec3 mate = texcube( iChannel0, 0.5*pos, nor ).xyz;\n        const vec3 sun_dir = normalize(vec3(.8f, .4f, .2f));\n        \n        float sun_dif = clamp(dot(nor, sun_dir), .0f, 1.f) * .25f;\n        \n        int aa = 0;\n        \n        float sun_shadow = shadow(pos + nor * .001f, sun_dir, aa);\n        float sky_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, 1.f, .0f)), .0f, 1.f);\n        float bounce_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, -1.f, .0f)), .0f, 1.f);\n        \n        col = mate * vec3(7.f, 4.f, 3.f) * sun_dif * sun_shadow;\n        col += mate * vec3(.5f, .8f, .9f) * sky_dif;\n        col -= smoothstep(pow(float(a), .75f) * .1f, 0.f, .5f) * .075f;\n        \n        col += mate*vec3(.7f, .3f, .2f) * bounce_dif;\n    }\n    \n    col = pow(col, vec3(.4545f));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}