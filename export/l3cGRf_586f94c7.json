{"ver":"0.1","info":{"id":"l3cGRf","date":"1716834440","viewed":108,"name":"{Orange Voronoi}","username":"inverse_transpose","description":"Voronoi","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define GRID\n\nvec2 hash22(in vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.4, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\n#define SIN_ARG hash22(current) * 5.67891 +iTime*.85\n\n// Using Inigo Quilez's algorithm to more correctly\n// approximate the distance to the closest border,\n// allowing much more consistent border widths and\n// isoline rendering.\nvec3 voronoi(in vec2 uv)\n{\n    vec2 ip = floor(uv);\n    vec2 fp = fract(uv);\n    vec3 result;\n    \n    result.x = 100000.0;\n    \n    float mDist = 10000.0;\n    vec2 mOffset = vec2(0.0);\n    vec2 mPoint = vec2(100.0);\n    \n    // Determine the closest point.\n    for (float i = -1.0; i <= 1.01; i += 1.0)\n    for (float j = -1.0; j <= 1.01; j += 1.0)\n    {\n        vec2 offset = vec2(i, j);\n        vec2 current = ip + offset;\n        vec2 p = offset - fp + .25*sin(SIN_ARG);\n        \n        float l = dot(p, p);\n        if (l < mDist)\n        {\n            mDist = l;\n            mOffset = offset;\n            mPoint = p;\n        }\n    }\n    \n    // Now determine the distance to the closest border.\n    mDist = 1000.0;\n    for (float i = -2.0; i <= 2.01; i += 1.0)\n    for (float j = -2.0; j <= 2.01; j += 1.0)\n    {\n        vec2 offset = mOffset + vec2(i, j);\n        vec2 current = ip + offset;\n        vec2 p = offset - fp + .25*sin(SIN_ARG);\n        \n        if (dot(mPoint - p, mPoint - p) > 0.000001)\n            mDist = min(mDist, dot(.5*(mPoint + p), normalize(p - mPoint)));\n    }\n    result.x=sqrt(mDist);\n    result.yz = mPoint;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv.x += iTime*0.05;\n    uv.y += iTime*0.07;\n    uv *= 5.0;\n    \n    vec3 result = voronoi(uv);\n\n    if (!(.0 > result.x) && result.x < .000001)\n    {\n      fragColor = vec4(1,1,0,1);\n      return;\n    }\n\n\n#define COL_CLICK vec3(.4,.7,.5)\n#define COL vec3(1, .5, .1)\n\n    vec3 col;\n    \n    col = (iMouse.z>.5?COL:vec3(.45))*result.x*(.5 + .5*sin(100.5*result.x));\n\n    // Render the border.\n    col += (iMouse.z>.5?vec3(.1):COL)*smoothstep(.70,  .00, result.x     );\n    col += (iMouse.z>.5?vec3(.1):COL)*smoothstep(.01, -.01, result.x-.125);\n    \n    // Render the closest point.\n    col += smoothstep(.005,  -.005, length(result.yz)-.0250)*(iMouse.z>.5?COL_CLICK:COL*2.);\n    col += smoothstep(.100,  -.045, length(result.yz)-.0125)*(iMouse.z>.5?COL_CLICK:COL*1.25);\n\n#ifdef GRID\n    vec2 gv = fract(uv)-.5;\n    col+=smoothstep( .4,  .5, gv.x)*COL;\n    col+=smoothstep(-.4, -.5, gv.x)*COL;\n    if (abs(gv.x)>.48)col=COL*6.5;\n    col+=smoothstep( .4,  .5, gv.y)*COL;\n    col+=smoothstep(-.4, -.5, gv.y)*COL;\n    if (abs(gv.y)>.48)col=COL*6.5;\n#endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}