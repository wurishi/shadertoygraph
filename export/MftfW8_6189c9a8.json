{"ver":"0.1","info":{"id":"MftfW8","date":"1733045466","viewed":191,"name":"Perlin/Simplex noise sample","username":"andanteyk","description":"HLSL version: see\nhttps://gist.github.com/andanteyk/ce0a5eb497074e0bcbf5600ef8bc20a3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 uv = vec4(fragCoord / iResolution.yy * 4.0, iTime * 0.2, iTime * 0.1);\n\n    vec3 color;\n    \n    // comment/uncomment the line below:\n    \n    //color = value2(vec2(uv)).xxx; // 2D value\n    //color = value3(vec3(uv)).xxx; // 3D value\n    \n    //color = perlin2(vec2(uv)).xyz; // 2D perlin, derivative & value\n    //color = perlin2(vec2(uv)).zzz; // 2D perlin, value\n    //color = perlin3(vec3(uv)).xyz; // 3D perlin, derivative\n    //color = perlin3(vec3(uv)).www; // 3D perlin, value\n    //color = perlin4dual(uv)[0].xyz; // 4D perlin, derivative(xyz)\n    //color = perlin4dual(uv)[1].xxx; // 4D perlin, value\n    \n    //color = simplex2(vec2(uv)).xyz; // 2D simplex, derivative & value\n    //color = simplex2(vec2(uv)).zzz; // 2D simplex, value\n    color = simplex3(vec3(uv)).xyz; // 3D simplex, derivative\n    //color = simplex3(vec3(uv)).www; // 3D simplex, value\n    //color = simplex4dual(uv)[0].xyz; // 4D simplex, derivative(xyz)\n    //color = simplex4dual(uv)[1].xxx; // 4D simplex, value\n\n    //color = curl2(vec3(uv)).xyz; // 3D curl\n\n    //color = simplex3(domainRotation(vec3(uv))).www; // 3D simplex, value (with domain rotation)\n\n    fragColor = vec4((color + 1.0) * 0.5, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int permutation[512] = int[512](\n151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n);\n\nconst vec3 grad3vecs[] = vec3[](\n    vec3(1, 1, 0), \n    vec3(-1, 1, 0),\n    vec3(1, -1, 0),\n    vec3(-1, -1, 0),\n    vec3(1, 0, 1),\n    vec3(-1, 0, 1),\n    vec3(1, 0, -1),\n    vec3(-1, 0, -1),\n    vec3(0, 1, 1),\n    vec3(0, -1, 1),\n    vec3(0, 1, -1),\n    vec3(0, -1, -1)\n);\n\nconst vec4 grad4vecs[] = vec4[](\n    vec4(0, -1, -1, -1),\n    vec4(0, -1, -1, +1),\n    vec4(0, -1, +1, -1),\n    vec4(0, -1, +1, +1),\n    vec4(0, +1, -1, -1),\n    vec4(0, +1, -1, +1),\n    vec4(0, +1, +1, -1),\n    vec4(0, +1, +1, +1),\n\n    vec4(-1, 0, -1, -1),\n    vec4(-1, 0, -1, +1),\n    vec4(-1, 0, +1, -1),\n    vec4(-1, 0, +1, +1),\n    vec4(+1, 0, -1, -1),\n    vec4(+1, 0, -1, +1),\n    vec4(+1, 0, +1, -1),\n    vec4(+1, 0, +1, +1),\n\n    vec4(-1, -1, 0, -1),\n    vec4(-1, -1, 0, +1),\n    vec4(-1, +1, 0, -1),\n    vec4(-1, +1, 0, +1),\n    vec4(+1, -1, 0, -1),\n    vec4(+1, -1, 0, +1),\n    vec4(+1, +1, 0, -1),\n    vec4(+1, +1, 0, +1),\n\n    vec4(-1, -1, -1, 0),\n    vec4(-1, -1, +1, 0),\n    vec4(-1, +1, -1, 0),\n    vec4(-1, +1, +1, 0),\n    vec4(+1, -1, -1, 0),\n    vec4(+1, -1, +1, 0),\n    vec4(+1, +1, -1, 0),\n    vec4(+1, +1, +1, 0)\n);\n\nfloat rand2(vec2 pos)\n{\n    return float(permutation[(int(pos.x) & 255) + permutation[(int(pos.y) & 255)]]) / 256.0;\n}\n\nvec2 grad2(vec2 pos)\n{\n    int p = permutation[(int(pos.x) & 255) + permutation[(int(pos.y) & 255)]];\n\n    return grad3vecs[uint(p) % uint(12)].xy;\n    //return vec2(cos(p / 256.0 * 6.283185), sin(p / 256.0 * 6.283185));\n}\n\nfloat rand3(vec3 pos)\n{\n    return float(permutation[(int(pos.x) & 255) + permutation[(int(pos.y) & 255) + permutation[int(pos.z) & 255]]]) / 256.0;\n}\n\nvec3 grad3(vec3 pos)\n{\n    int p = permutation[(int(pos.x) & 255) + permutation[(int(pos.y) & 255) + permutation[int(pos.z) & 255]]];\n\n    return grad3vecs[uint(p) % uint(12)];\n    //return vec3(cos((p / 16) * 0.392699) * cos((p & 15) * 0.392699), cos((p / 16) * 0.392699) * sin((p & 15) * 0.392699), sin((p / 16) * 0.392699));\n}\n\nvec4 grad4(vec4 pos)\n{\n    int p = permutation[(int(pos.x) & 255) + permutation[(int(pos.y) & 255) + permutation[(int(pos.z) & 255) + permutation[int(pos.w) & 255]]]];\n\n    return grad4vecs[uint(p) & uint(0x1f)];\n}\n\nfloat interpolate3(float x, float y, float t)\n{\n    return x + (y - x) * (3.0 - t * 2.0) * t * t;\n}\n\nfloat interpolate5(float x, float y, float t)\n{\n    return x + (y - x) * t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat interpolate3derivative(float x, float y, float t)\n{\n    return x + (y - x) * t * (6.0 - t * 6.0);\n}\n\nfloat interpolate5derivative(float x, float y, float t)\n{\n    return x + (y - x) * t * t * (t * (t * 30.0 - 60.0) + 30.0);\n}\n\n// 2D value noise\nvec3 value2(vec2 pos)\n{\n    vec2 intpos0 = floor(pos);\n    vec2 intpos1 = intpos0 + vec2(1.0, 1.0);\n    vec2 fracpos = pos - intpos0;\n\n    vec2 p00 = vec2(intpos0.x, intpos0.y);\n    vec2 p01 = vec2(intpos0.x, intpos1.y);\n    vec2 p10 = vec2(intpos1.x, intpos0.y);\n    vec2 p11 = vec2(intpos1.x, intpos1.y);\n\n    float value00 = rand2(p00);\n    float value01 = rand2(p01);\n    float value10 = rand2(p10);\n    float value11 = rand2(p11);\n\n    float intp0 = interpolate3(value00, value01, fracpos.y);\n    float intp1 = interpolate3(value10, value11, fracpos.y);\n    float intp  = interpolate3(intp0, intp1, fracpos.x);\n\n    return vec3(intp).xxx;\n}\n\n// 3D value noise\nvec3 value3(vec3 pos)\n{\n    vec3 intpos0 = floor(pos);\n    vec3 intpos1 = intpos0 + vec3(1.0, 1.0, 1.0);\n    vec3 fracpos = pos - intpos0;\n\n    vec3 p000 = vec3(intpos0.x, intpos0.y, intpos0.z);\n    vec3 p001 = vec3(intpos0.x, intpos0.y, intpos1.z);\n    vec3 p010 = vec3(intpos0.x, intpos1.y, intpos0.z);\n    vec3 p011 = vec3(intpos0.x, intpos1.y, intpos1.z);\n    vec3 p100 = vec3(intpos1.x, intpos0.y, intpos0.z);\n    vec3 p101 = vec3(intpos1.x, intpos0.y, intpos1.z);\n    vec3 p110 = vec3(intpos1.x, intpos1.y, intpos0.z);\n    vec3 p111 = vec3(intpos1.x, intpos1.y, intpos1.z);\n\n    float value000 = rand3(p000);\n    float value001 = rand3(p001);\n    float value010 = rand3(p010);\n    float value011 = rand3(p011);\n    float value100 = rand3(p100);\n    float value101 = rand3(p101);\n    float value110 = rand3(p110);\n    float value111 = rand3(p111);\n\n    float intp00 = interpolate3(value000, value001, fracpos.z);\n    float intp01 = interpolate3(value010, value011, fracpos.z);\n    float intp10 = interpolate3(value100, value101, fracpos.z);\n    float intp11 = interpolate3(value110, value111, fracpos.z);\n    float intp0  = interpolate3(intp00, intp01, fracpos.y);\n    float intp1  = interpolate3(intp10, intp11, fracpos.y);\n    float intp   = interpolate3(intp0, intp1, fracpos.x);\n\n    return vec3(intp).xxx;\n}\n\n// 2D perlin noise (∂f/∂x, ∂f/∂y, f)\nvec3 perlin2(vec2 pos)\n{\n    vec2 intpos0 = floor(pos);\n    vec2 intpos1 = intpos0 + vec2(1.0, 1.0);\n    vec2 fracpos = pos - intpos0;\n\n    vec2 p00 = vec2(intpos0.x, intpos0.y);\n    vec2 p01 = vec2(intpos0.x, intpos1.y);\n    vec2 p10 = vec2(intpos1.x, intpos0.y);\n    vec2 p11 = vec2(intpos1.x, intpos1.y);\n\n    vec2 grad00 = grad2(p00);\n    vec2 grad01 = grad2(p01);\n    vec2 grad10 = grad2(p10);\n    vec2 grad11 = grad2(p11);\n\n    float value00 = dot(grad00, pos - p00);\n    float value01 = dot(grad01, pos - p01);\n    float value10 = dot(grad10, pos - p10);\n    float value11 = dot(grad11, pos - p11);\n\n    float intp0  = interpolate5(value00, value01, fracpos.y);\n    float intp1  = interpolate5(value10, value11, fracpos.y);\n    float intp   = interpolate5(intp0, intp1, fracpos.x); \n\n    float tx = interpolate5(0.0, 1.0, fracpos.x);\n    float ty = interpolate5(0.0, 1.0, fracpos.y);\n    vec2 tp = vec2(interpolate5derivative(0.0, 1.0, fracpos.x), interpolate5derivative(0.0, 1.0, fracpos.y));\n\n    vec2 alphap = grad00 + (grad01 - grad00) * ty + (value01 - value00) * vec2(0.0, tp.y);\n    vec2 betap  = grad10 + (grad11 - grad10) * ty + (value11 - value10) * vec2(0.0, tp.y);\n    vec2 p = alphap + (betap - alphap) * tx + (intp1 - intp0) * vec2(tp.x, 0.0);\n\n    return vec3(p, intp);\n}\n\n// 3D perlin noise (∂f/∂x, ∂f/∂y, ∂f/∂z, f)\nvec4 perlin3(vec3 pos)\n{\n    vec3 intpos0 = floor(pos);\n    vec3 intpos1 = intpos0 + vec3(1.0, 1.0, 1.0);\n    vec3 fracpos = pos - intpos0;\n\n    vec3 p000 = vec3(intpos0.x, intpos0.y, intpos0.z);\n    vec3 p001 = vec3(intpos0.x, intpos0.y, intpos1.z);\n    vec3 p010 = vec3(intpos0.x, intpos1.y, intpos0.z);\n    vec3 p011 = vec3(intpos0.x, intpos1.y, intpos1.z);\n    vec3 p100 = vec3(intpos1.x, intpos0.y, intpos0.z);\n    vec3 p101 = vec3(intpos1.x, intpos0.y, intpos1.z);\n    vec3 p110 = vec3(intpos1.x, intpos1.y, intpos0.z);\n    vec3 p111 = vec3(intpos1.x, intpos1.y, intpos1.z);\n\n    vec3 grad000 = grad3(p000);\n    vec3 grad001 = grad3(p001);\n    vec3 grad010 = grad3(p010);\n    vec3 grad011 = grad3(p011);\n    vec3 grad100 = grad3(p100);\n    vec3 grad101 = grad3(p101);\n    vec3 grad110 = grad3(p110);\n    vec3 grad111 = grad3(p111);\n\n    float value000 = dot(grad000, pos - p000);\n    float value001 = dot(grad001, pos - p001);\n    float value010 = dot(grad010, pos - p010);\n    float value011 = dot(grad011, pos - p011);\n    float value100 = dot(grad100, pos - p100);\n    float value101 = dot(grad101, pos - p101);\n    float value110 = dot(grad110, pos - p110);\n    float value111 = dot(grad111, pos - p111);\n\n    float intp00 = interpolate5(value000, value001, fracpos.z);\n    float intp01 = interpolate5(value010, value011, fracpos.z);\n    float intp10 = interpolate5(value100, value101, fracpos.z);\n    float intp11 = interpolate5(value110, value111, fracpos.z);\n    float intp0  = interpolate5(intp00, intp01, fracpos.y);\n    float intp1  = interpolate5(intp10, intp11, fracpos.y);\n    float intp   = interpolate5(intp0, intp1, fracpos.x); \n\n\n    vec3 t = vec3(interpolate5(0.0, 1.0, fracpos.x), interpolate5(0.0, 1.0, fracpos.y), interpolate5(0.0, 1.0, fracpos.z));\n    vec3 tp = vec3(interpolate5derivative(0.0, 1.0, fracpos.x), interpolate5derivative(0.0, 1.0, fracpos.y), interpolate5derivative(0.0, 1.0, fracpos.z));\n\n    vec3 d00p = grad000 + (grad001 - grad000) * t.z + (value001 - value000) * vec3(0, 0, tp.z);\n    vec3 d01p = grad010 + (grad011 - grad010) * t.z + (value011 - value010) * vec3(0, 0, tp.z);\n    vec3 d10p = grad100 + (grad101 - grad100) * t.z + (value101 - value100) * vec3(0, 0, tp.z);\n    vec3 d11p = grad110 + (grad111 - grad110) * t.z + (value111 - value110) * vec3(0, 0, tp.z);\n    vec3 d0p  = d00p + (d01p - d00p) * t.y + (intp01 - intp00) * vec3(0, tp.y, 0);\n    vec3 d1p  = d10p + (d11p - d10p) * t.y + (intp11 - intp10) * vec3(0, tp.y, 0);\n    vec3 dp   = d0p + (d1p - d0p) * t.x + (intp1 - intp0) * vec3(tp.x, 0, 0);\n\n\n    return vec4(dp, intp);\n}\n\n// 4D perlin noise\nfloat perlin4(vec4 pos)\n{\n    vec4 intpos0 = floor(pos);\n    vec4 intpos1 = intpos0 + vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 fracpos = pos - intpos0;\n\n    vec4 p0000 = vec4(intpos0.x, intpos0.y, intpos0.z, intpos0.w);\n    vec4 p0001 = vec4(intpos0.x, intpos0.y, intpos0.z, intpos1.w);\n    vec4 p0010 = vec4(intpos0.x, intpos0.y, intpos1.z, intpos0.w);\n    vec4 p0011 = vec4(intpos0.x, intpos0.y, intpos1.z, intpos1.w);\n    vec4 p0100 = vec4(intpos0.x, intpos1.y, intpos0.z, intpos0.w);\n    vec4 p0101 = vec4(intpos0.x, intpos1.y, intpos0.z, intpos1.w);\n    vec4 p0110 = vec4(intpos0.x, intpos1.y, intpos1.z, intpos0.w);\n    vec4 p0111 = vec4(intpos0.x, intpos1.y, intpos1.z, intpos1.w);\n    vec4 p1000 = vec4(intpos1.x, intpos0.y, intpos0.z, intpos0.w);\n    vec4 p1001 = vec4(intpos1.x, intpos0.y, intpos0.z, intpos1.w);\n    vec4 p1010 = vec4(intpos1.x, intpos0.y, intpos1.z, intpos0.w);\n    vec4 p1011 = vec4(intpos1.x, intpos0.y, intpos1.z, intpos1.w);\n    vec4 p1100 = vec4(intpos1.x, intpos1.y, intpos0.z, intpos0.w);\n    vec4 p1101 = vec4(intpos1.x, intpos1.y, intpos0.z, intpos1.w);\n    vec4 p1110 = vec4(intpos1.x, intpos1.y, intpos1.z, intpos0.w);\n    vec4 p1111 = vec4(intpos1.x, intpos1.y, intpos1.z, intpos1.w);\n\n    float grad0000 = dot(grad4(p0000), pos - p0000);\n    float grad0001 = dot(grad4(p0001), pos - p0001);\n    float grad0010 = dot(grad4(p0010), pos - p0010);\n    float grad0011 = dot(grad4(p0011), pos - p0011);\n    float grad0100 = dot(grad4(p0100), pos - p0100);\n    float grad0101 = dot(grad4(p0101), pos - p0101);\n    float grad0110 = dot(grad4(p0110), pos - p0110);\n    float grad0111 = dot(grad4(p0111), pos - p0111);\n    float grad1000 = dot(grad4(p1000), pos - p1000);\n    float grad1001 = dot(grad4(p1001), pos - p1001);\n    float grad1010 = dot(grad4(p1010), pos - p1010);\n    float grad1011 = dot(grad4(p1011), pos - p1011);\n    float grad1100 = dot(grad4(p1100), pos - p1100);\n    float grad1101 = dot(grad4(p1101), pos - p1101);\n    float grad1110 = dot(grad4(p1110), pos - p1110);\n    float grad1111 = dot(grad4(p1111), pos - p1111);\n\n    float intp000 = interpolate5(grad0000, grad0001, fracpos.w);\n    float intp001 = interpolate5(grad0010, grad0011, fracpos.w);\n    float intp010 = interpolate5(grad0100, grad0101, fracpos.w);\n    float intp011 = interpolate5(grad0110, grad0111, fracpos.w);\n    float intp100 = interpolate5(grad1000, grad1001, fracpos.w);\n    float intp101 = interpolate5(grad1010, grad1011, fracpos.w);\n    float intp110 = interpolate5(grad1100, grad1101, fracpos.w);\n    float intp111 = interpolate5(grad1110, grad1111, fracpos.w);\n    float intp00  = interpolate5(intp000, intp001, fracpos.z);\n    float intp01  = interpolate5(intp010, intp011, fracpos.z);\n    float intp10  = interpolate5(intp100, intp101, fracpos.z);\n    float intp11  = interpolate5(intp110, intp111, fracpos.z);\n    float intp0   = interpolate5(intp00, intp01, fracpos.y);\n    float intp1   = interpolate5(intp10, intp11, fracpos.y);\n    float intp    = interpolate5(intp0, intp1, fracpos.x); \n\n\n    return intp;\n}\n\n// 4D perlin noise's derivative (∂f/∂x, ∂f/∂y, ∂f/∂z, ∂f/∂w)\nvec4 perlin4derivative(vec4 pos)\n{\n    vec4 intpos0 = floor(pos);\n    vec4 intpos1 = intpos0 + vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 fracpos = pos - intpos0;\n\n    vec4 p0000 = vec4(intpos0.x, intpos0.y, intpos0.z, intpos0.w);\n    vec4 p0001 = vec4(intpos0.x, intpos0.y, intpos0.z, intpos1.w);\n    vec4 p0010 = vec4(intpos0.x, intpos0.y, intpos1.z, intpos0.w);\n    vec4 p0011 = vec4(intpos0.x, intpos0.y, intpos1.z, intpos1.w);\n    vec4 p0100 = vec4(intpos0.x, intpos1.y, intpos0.z, intpos0.w);\n    vec4 p0101 = vec4(intpos0.x, intpos1.y, intpos0.z, intpos1.w);\n    vec4 p0110 = vec4(intpos0.x, intpos1.y, intpos1.z, intpos0.w);\n    vec4 p0111 = vec4(intpos0.x, intpos1.y, intpos1.z, intpos1.w);\n    vec4 p1000 = vec4(intpos1.x, intpos0.y, intpos0.z, intpos0.w);\n    vec4 p1001 = vec4(intpos1.x, intpos0.y, intpos0.z, intpos1.w);\n    vec4 p1010 = vec4(intpos1.x, intpos0.y, intpos1.z, intpos0.w);\n    vec4 p1011 = vec4(intpos1.x, intpos0.y, intpos1.z, intpos1.w);\n    vec4 p1100 = vec4(intpos1.x, intpos1.y, intpos0.z, intpos0.w);\n    vec4 p1101 = vec4(intpos1.x, intpos1.y, intpos0.z, intpos1.w);\n    vec4 p1110 = vec4(intpos1.x, intpos1.y, intpos1.z, intpos0.w);\n    vec4 p1111 = vec4(intpos1.x, intpos1.y, intpos1.z, intpos1.w);\n\n    vec4 grad0000 = grad4(p0000);\n    vec4 grad0001 = grad4(p0001);\n    vec4 grad0010 = grad4(p0010);\n    vec4 grad0011 = grad4(p0011);\n    vec4 grad0100 = grad4(p0100);\n    vec4 grad0101 = grad4(p0101);\n    vec4 grad0110 = grad4(p0110);\n    vec4 grad0111 = grad4(p0111);\n    vec4 grad1000 = grad4(p1000);\n    vec4 grad1001 = grad4(p1001);\n    vec4 grad1010 = grad4(p1010);\n    vec4 grad1011 = grad4(p1011);\n    vec4 grad1100 = grad4(p1100);\n    vec4 grad1101 = grad4(p1101);\n    vec4 grad1110 = grad4(p1110);\n    vec4 grad1111 = grad4(p1111);\n\n    float value0000 = dot(grad0000, pos - p0000);\n    float value0001 = dot(grad0001, pos - p0001);\n    float value0010 = dot(grad0010, pos - p0010);\n    float value0011 = dot(grad0011, pos - p0011);\n    float value0100 = dot(grad0100, pos - p0100);\n    float value0101 = dot(grad0101, pos - p0101);\n    float value0110 = dot(grad0110, pos - p0110);\n    float value0111 = dot(grad0111, pos - p0111);\n    float value1000 = dot(grad1000, pos - p1000);\n    float value1001 = dot(grad1001, pos - p1001);\n    float value1010 = dot(grad1010, pos - p1010);\n    float value1011 = dot(grad1011, pos - p1011);\n    float value1100 = dot(grad1100, pos - p1100);\n    float value1101 = dot(grad1101, pos - p1101);\n    float value1110 = dot(grad1110, pos - p1110);\n    float value1111 = dot(grad1111, pos - p1111);\n\n    float intp000 = interpolate5(value0000, value0001, fracpos.w);\n    float intp001 = interpolate5(value0010, value0011, fracpos.w);\n    float intp010 = interpolate5(value0100, value0101, fracpos.w);\n    float intp011 = interpolate5(value0110, value0111, fracpos.w);\n    float intp100 = interpolate5(value1000, value1001, fracpos.w);\n    float intp101 = interpolate5(value1010, value1011, fracpos.w);\n    float intp110 = interpolate5(value1100, value1101, fracpos.w);\n    float intp111 = interpolate5(value1110, value1111, fracpos.w);\n    float intp00  = interpolate5(intp000, intp001, fracpos.z);\n    float intp01  = interpolate5(intp010, intp011, fracpos.z);\n    float intp10  = interpolate5(intp100, intp101, fracpos.z);\n    float intp11  = interpolate5(intp110, intp111, fracpos.z);\n    float intp0   = interpolate5(intp00, intp01, fracpos.y);\n    float intp1   = interpolate5(intp10, intp11, fracpos.y);\n    float intp    = interpolate5(intp0, intp1, fracpos.x); \n\n\n    vec4 t = vec4(\n        interpolate5(0.0, 1.0, fracpos.x), \n        interpolate5(0.0, 1.0, fracpos.y), \n        interpolate5(0.0, 1.0, fracpos.z),\n        interpolate5(0.0, 1.0, fracpos.w));\n    vec4 tp = vec4(\n        interpolate5derivative(0.0, 1.0, fracpos.x),\n        interpolate5derivative(0.0, 1.0, fracpos.y), \n        interpolate5derivative(0.0, 1.0, fracpos.z),\n        interpolate5derivative(0.0, 1.0, fracpos.w));\n\n    vec4 d000p = grad0000 + (grad0001 - grad0000) * t.w + (value0001 - value0000) * vec4(0, 0, 0, tp.w);\n    vec4 d001p = grad0010 + (grad0011 - grad0010) * t.w + (value0011 - value0010) * vec4(0, 0, 0, tp.w);\n    vec4 d010p = grad0100 + (grad0101 - grad0100) * t.w + (value0101 - value0100) * vec4(0, 0, 0, tp.w);\n    vec4 d011p = grad0110 + (grad0111 - grad0110) * t.w + (value0111 - value0110) * vec4(0, 0, 0, tp.w);\n    vec4 d100p = grad1000 + (grad1001 - grad1000) * t.w + (value1001 - value1000) * vec4(0, 0, 0, tp.w);\n    vec4 d101p = grad1010 + (grad1011 - grad1010) * t.w + (value1011 - value1010) * vec4(0, 0, 0, tp.w);\n    vec4 d110p = grad1100 + (grad1101 - grad1100) * t.w + (value1101 - value1100) * vec4(0, 0, 0, tp.w);\n    vec4 d111p = grad1110 + (grad1111 - grad1110) * t.w + (value1111 - value1110) * vec4(0, 0, 0, tp.w);\n    vec4 d00p = d000p + (d001p - d000p) * t.z + (intp001 - intp000) * vec4(0, 0, tp.z, 0);\n    vec4 d01p = d010p + (d011p - d010p) * t.z + (intp011 - intp010) * vec4(0, 0, tp.z, 0);\n    vec4 d10p = d100p + (d101p - d100p) * t.z + (intp101 - intp100) * vec4(0, 0, tp.z, 0);\n    vec4 d11p = d110p + (d111p - d110p) * t.z + (intp111 - intp110) * vec4(0, 0, tp.z, 0);\n    vec4 d0p = d00p + (d01p - d00p) * t.y + (intp01 - intp00) * vec4(0, tp.y, 0, 0);\n    vec4 d1p = d10p + (d11p - d10p) * t.y + (intp11 - intp10) * vec4(0, tp.y, 0, 0);\n    vec4 dp = d0p + (d1p - d0p) * t.x + (intp1 - intp0) * vec4(tp.x, 0, 0, 0);\n\n    return dp;\n}\n\n// 4D perlin noise (∂f/∂x, ∂f/∂y, ∂f/∂z, ∂f/∂w, f, f, f, f)\nmat2x4 perlin4dual(vec4 pos)\n{\n    vec4 intpos0 = floor(pos);\n    vec4 intpos1 = intpos0 + vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 fracpos = pos - intpos0;\n\n    vec4 p0000 = vec4(intpos0.x, intpos0.y, intpos0.z, intpos0.w);\n    vec4 p0001 = vec4(intpos0.x, intpos0.y, intpos0.z, intpos1.w);\n    vec4 p0010 = vec4(intpos0.x, intpos0.y, intpos1.z, intpos0.w);\n    vec4 p0011 = vec4(intpos0.x, intpos0.y, intpos1.z, intpos1.w);\n    vec4 p0100 = vec4(intpos0.x, intpos1.y, intpos0.z, intpos0.w);\n    vec4 p0101 = vec4(intpos0.x, intpos1.y, intpos0.z, intpos1.w);\n    vec4 p0110 = vec4(intpos0.x, intpos1.y, intpos1.z, intpos0.w);\n    vec4 p0111 = vec4(intpos0.x, intpos1.y, intpos1.z, intpos1.w);\n    vec4 p1000 = vec4(intpos1.x, intpos0.y, intpos0.z, intpos0.w);\n    vec4 p1001 = vec4(intpos1.x, intpos0.y, intpos0.z, intpos1.w);\n    vec4 p1010 = vec4(intpos1.x, intpos0.y, intpos1.z, intpos0.w);\n    vec4 p1011 = vec4(intpos1.x, intpos0.y, intpos1.z, intpos1.w);\n    vec4 p1100 = vec4(intpos1.x, intpos1.y, intpos0.z, intpos0.w);\n    vec4 p1101 = vec4(intpos1.x, intpos1.y, intpos0.z, intpos1.w);\n    vec4 p1110 = vec4(intpos1.x, intpos1.y, intpos1.z, intpos0.w);\n    vec4 p1111 = vec4(intpos1.x, intpos1.y, intpos1.z, intpos1.w);\n\n    vec4 grad0000 = grad4(p0000);\n    vec4 grad0001 = grad4(p0001);\n    vec4 grad0010 = grad4(p0010);\n    vec4 grad0011 = grad4(p0011);\n    vec4 grad0100 = grad4(p0100);\n    vec4 grad0101 = grad4(p0101);\n    vec4 grad0110 = grad4(p0110);\n    vec4 grad0111 = grad4(p0111);\n    vec4 grad1000 = grad4(p1000);\n    vec4 grad1001 = grad4(p1001);\n    vec4 grad1010 = grad4(p1010);\n    vec4 grad1011 = grad4(p1011);\n    vec4 grad1100 = grad4(p1100);\n    vec4 grad1101 = grad4(p1101);\n    vec4 grad1110 = grad4(p1110);\n    vec4 grad1111 = grad4(p1111);\n\n    float value0000 = dot(grad0000, pos - p0000);\n    float value0001 = dot(grad0001, pos - p0001);\n    float value0010 = dot(grad0010, pos - p0010);\n    float value0011 = dot(grad0011, pos - p0011);\n    float value0100 = dot(grad0100, pos - p0100);\n    float value0101 = dot(grad0101, pos - p0101);\n    float value0110 = dot(grad0110, pos - p0110);\n    float value0111 = dot(grad0111, pos - p0111);\n    float value1000 = dot(grad1000, pos - p1000);\n    float value1001 = dot(grad1001, pos - p1001);\n    float value1010 = dot(grad1010, pos - p1010);\n    float value1011 = dot(grad1011, pos - p1011);\n    float value1100 = dot(grad1100, pos - p1100);\n    float value1101 = dot(grad1101, pos - p1101);\n    float value1110 = dot(grad1110, pos - p1110);\n    float value1111 = dot(grad1111, pos - p1111);\n\n    float intp000 = interpolate5(value0000, value0001, fracpos.w);\n    float intp001 = interpolate5(value0010, value0011, fracpos.w);\n    float intp010 = interpolate5(value0100, value0101, fracpos.w);\n    float intp011 = interpolate5(value0110, value0111, fracpos.w);\n    float intp100 = interpolate5(value1000, value1001, fracpos.w);\n    float intp101 = interpolate5(value1010, value1011, fracpos.w);\n    float intp110 = interpolate5(value1100, value1101, fracpos.w);\n    float intp111 = interpolate5(value1110, value1111, fracpos.w);\n    float intp00  = interpolate5(intp000, intp001, fracpos.z);\n    float intp01  = interpolate5(intp010, intp011, fracpos.z);\n    float intp10  = interpolate5(intp100, intp101, fracpos.z);\n    float intp11  = interpolate5(intp110, intp111, fracpos.z);\n    float intp0   = interpolate5(intp00, intp01, fracpos.y);\n    float intp1   = interpolate5(intp10, intp11, fracpos.y);\n    float intp    = interpolate5(intp0, intp1, fracpos.x); \n\n\n    vec4 t = vec4(\n        interpolate5(0.0, 1.0, fracpos.x), \n        interpolate5(0.0, 1.0, fracpos.y), \n        interpolate5(0.0, 1.0, fracpos.z),\n        interpolate5(0.0, 1.0, fracpos.w));\n    vec4 tp = vec4(\n        interpolate5derivative(0.0, 1.0, fracpos.x),\n        interpolate5derivative(0.0, 1.0, fracpos.y), \n        interpolate5derivative(0.0, 1.0, fracpos.z),\n        interpolate5derivative(0.0, 1.0, fracpos.w));\n\n    vec4 d000p = grad0000 + (grad0001 - grad0000) * t.w + (value0001 - value0000) * vec4(0, 0, 0, tp.w);\n    vec4 d001p = grad0010 + (grad0011 - grad0010) * t.w + (value0011 - value0010) * vec4(0, 0, 0, tp.w);\n    vec4 d010p = grad0100 + (grad0101 - grad0100) * t.w + (value0101 - value0100) * vec4(0, 0, 0, tp.w);\n    vec4 d011p = grad0110 + (grad0111 - grad0110) * t.w + (value0111 - value0110) * vec4(0, 0, 0, tp.w);\n    vec4 d100p = grad1000 + (grad1001 - grad1000) * t.w + (value1001 - value1000) * vec4(0, 0, 0, tp.w);\n    vec4 d101p = grad1010 + (grad1011 - grad1010) * t.w + (value1011 - value1010) * vec4(0, 0, 0, tp.w);\n    vec4 d110p = grad1100 + (grad1101 - grad1100) * t.w + (value1101 - value1100) * vec4(0, 0, 0, tp.w);\n    vec4 d111p = grad1110 + (grad1111 - grad1110) * t.w + (value1111 - value1110) * vec4(0, 0, 0, tp.w);\n    vec4 d00p = d000p + (d001p - d000p) * t.z + (intp001 - intp000) * vec4(0, 0, tp.z, 0);\n    vec4 d01p = d010p + (d011p - d010p) * t.z + (intp011 - intp010) * vec4(0, 0, tp.z, 0);\n    vec4 d10p = d100p + (d101p - d100p) * t.z + (intp101 - intp100) * vec4(0, 0, tp.z, 0);\n    vec4 d11p = d110p + (d111p - d110p) * t.z + (intp111 - intp110) * vec4(0, 0, tp.z, 0);\n    vec4 d0p = d00p + (d01p - d00p) * t.y + (intp01 - intp00) * vec4(0, tp.y, 0, 0);\n    vec4 d1p = d10p + (d11p - d10p) * t.y + (intp11 - intp10) * vec4(0, tp.y, 0, 0);\n    vec4 dp = d0p + (d1p - d0p) * t.x + (intp1 - intp0) * vec4(tp.x, 0, 0, 0);\n\n    return mat2x4(dp, vec4(intp, intp, intp, intp));\n}\n\n// 2D simplex noise (∂f/∂x, ∂f/∂y, f)\nvec3 simplex2(vec2 pos)\n{\n    float skewConstant = 0.5 * (sqrt(3.0) - 1.0);\n    float unskewConstant = (sqrt(3.0) - 3.0) / 6.0;\n\n    vec2 skewedIntpos0 = floor(pos + (pos.x + pos.y) * skewConstant);\n    vec2 intpos0 = skewedIntpos0 + (skewedIntpos0.x + skewedIntpos0.y) * unskewConstant;\n    vec2 offset0 = pos - intpos0;\n\n    vec2 intOffset1 = offset0.x > offset0.y ? vec2(1, 0) : vec2(0, 1);\n\n    vec2 skewedIntpos1 = skewedIntpos0 + intOffset1;\n    vec2 intpos1 = skewedIntpos1 + (skewedIntpos1.x + skewedIntpos1.y) * unskewConstant;\n    vec2 offset1 = pos - intpos1;\n\n    vec2 skewedIntpos2 = skewedIntpos0 + vec2(1.0, 1.0);\n    vec2 intpos2 = skewedIntpos2 + (skewedIntpos2.x + skewedIntpos2.y) * unskewConstant;\n    vec2 offset2 = pos - intpos2;\n\n    vec2 gradient0 = grad2(skewedIntpos0);\n    vec2 gradient1 = grad2(skewedIntpos1);\n    vec2 gradient2 = grad2(skewedIntpos2);\n\n    float t0 = 0.5 - (offset0.x * offset0.x + offset0.y * offset0.y);\n    t0 = t0 < 0.0 ? 0.0 : t0 * t0 * t0 * t0;\n    float n0 = t0 * dot(gradient0, offset0);\n\n    float t1 = 0.5 - (offset1.x * offset1.x + offset1.y * offset1.y);\n    t1 = t1 < 0.0 ? 0.0 : t1 * t1 * t1 * t1;\n    float n1 = t1 * dot(gradient1, offset1);\n\n    float t2 = 0.5 - (offset2.x * offset2.x + offset2.y * offset2.y);\n    t2 = t2 < 0.0 ? 0.0 : t2 * t2 * t2 * t2;\n    float n2 = t2 * dot(gradient2, offset2);\n\n\n    vec2 dt0 = t0 * gradient0 - 8.0 * pow(t0, 3.0 / 4.0) * dot(gradient0, offset0) * offset0;\n    vec2 dt1 = t1 * gradient1 - 8.0 * pow(t1, 3.0 / 4.0) * dot(gradient1, offset1) * offset1;\n    vec2 dt2 = t2 * gradient2 - 8.0 * pow(t2, 3.0 / 4.0) * dot(gradient2, offset2) * offset2;\n\n\n    return (70.0 * vec3(dt0 + dt1 + dt2, n0 + n1 + n2));\n}\n\n// 3D simplex noise (∂f/∂x, ∂f/∂y, ∂f/∂z, f)\nvec4 simplex3(vec3 pos)\n{\n    float skewConstant = 1.0 / 3.0;\n    float unskewConstant = -1.0 / 6.0;\n\n    vec3 skewedIntpos0 = floor(pos + (pos.x + pos.y + pos.z) * skewConstant);\n    vec3 intpos0 = skewedIntpos0 + (skewedIntpos0.x + skewedIntpos0.y + skewedIntpos0.z) * unskewConstant;\n    vec3 offset0 = pos - intpos0;\n\n    vec3 intOffset1 = \n        offset0.x > offset0.y ? \n            offset0.y > offset0.z ? vec3(1, 0, 0) :   // xyz\n            offset0.z > offset0.x ? vec3(0, 0, 1) :   // zxy\n            vec3(1, 0, 0) :                           // xzy\n            offset0.z > offset0.y ? vec3(0, 0, 1) :   // zyx\n            offset0.x > offset0.z ? vec3(0, 1, 0) :   // yxz\n            vec3(0, 1, 0);                            // yzx\n    vec3 intOffset2 = \n        offset0.x > offset0.y ? \n            offset0.y > offset0.z ? vec3(1, 1, 0) :   // xyz\n            offset0.z > offset0.x ? vec3(1, 0, 1) :   // zxy\n            vec3(1, 0, 1) :                           // xzy\n            offset0.z > offset0.y ? vec3(0, 1, 1) :   // zyx\n            offset0.x > offset0.z ? vec3(1, 1, 0) :   // yxz\n            vec3(0, 1, 1);                            // yzx\n\n    vec3 skewedIntpos1 = skewedIntpos0 + intOffset1;\n    vec3 intpos1 = skewedIntpos1 + (skewedIntpos1.x + skewedIntpos1.y + skewedIntpos1.z) * unskewConstant;\n    vec3 offset1 = pos - intpos1;\n\n    vec3 skewedIntpos2 = skewedIntpos0 + intOffset2;\n    vec3 intpos2 = skewedIntpos2 + (skewedIntpos2.x + skewedIntpos2.y + skewedIntpos2.z) * unskewConstant;\n    vec3 offset2 = pos - intpos2;\n\n    vec3 skewedIntpos3 = skewedIntpos0 + vec3(1.0, 1.0, 1.0);\n    vec3 intpos3 = skewedIntpos3 + (skewedIntpos3.x + skewedIntpos3.y + skewedIntpos3.z) * unskewConstant;\n    vec3 offset3 = pos - intpos3;\n\n    vec3 gradient0 = grad3(skewedIntpos0);\n    vec3 gradient1 = grad3(skewedIntpos1);\n    vec3 gradient2 = grad3(skewedIntpos2);\n    vec3 gradient3 = grad3(skewedIntpos3);\n\n    float t0 = 0.5 - dot(offset0, offset0);\n    t0 = t0 < 0.0 ? 0.0 : t0 * t0 * t0;\n    float n0 = t0 * dot(gradient0, offset0);\n\n    float t1 = 0.5 - dot(offset1, offset1);\n    t1 = t1 < 0.0 ? 0.0 : t1 * t1 * t1;\n    float n1 = t1 * dot(gradient1, offset1);\n\n    float t2 = 0.5 - dot(offset2, offset2);\n    t2 = t2 < 0.0 ? 0.0 : t2 * t2 * t2;\n    float n2 = t2 * dot(gradient2, offset2);\n\n    float t3 = 0.5 - dot(offset3, offset3);\n    t3 = t3 < 0.0 ? 0.0 : t3 * t3 * t3;\n    float n3 = t3 * dot(gradient3, offset3);\n\n    vec3 dt0 = t0 * gradient0 - 6.0 * pow(t0, 2.0 / 3.0) * dot(gradient0, offset0) * offset0;\n    vec3 dt1 = t1 * gradient1 - 6.0 * pow(t1, 2.0 / 3.0) * dot(gradient1, offset1) * offset1;\n    vec3 dt2 = t2 * gradient2 - 6.0 * pow(t2, 2.0 / 3.0) * dot(gradient2, offset2) * offset2;\n    vec3 dt3 = t3 * gradient3 - 6.0 * pow(t3, 2.0 / 3.0) * dot(gradient3, offset3) * offset3;\n\n\n    return (32.0 * vec4(dt0 + dt1 + dt2 + dt3, n0 + n1 + n2 + n3));\n}\n\n// 4D simplex noise\nfloat simplex4(vec4 pos)\n{\n    float skewConstant = (sqrt(5.0) - 1.0) / 4.0;\n    float unskewConstant = (sqrt(5.0) - 5.0) / 20.0;\n\n    vec4 skewedIntpos0 = floor(pos + dot(pos, vec4(1.0, 1.0, 1.0, 1.0)) * skewConstant);\n    vec4 intpos0 = skewedIntpos0 + dot(skewedIntpos0, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset0 = pos - intpos0;\n\n    mat2x4 order = mat2x4(0, 1, 2, 3, offset0);\n\n    // sort order by order[1] (offset0)\n    order = order[1].x > order[1].y ? mat2x4(order[0].yxzw, order[1].yxzw) : order;\n    order = order[1].z > order[1].w ? mat2x4(order[0].xywz, order[1].xywz) : order;\n    order = order[1].x > order[1].z ? mat2x4(order[0].zyxw, order[1].zyxw) : order;\n    order = order[1].y > order[1].w ? mat2x4(order[0].xwzy, order[1].xwzy) : order;\n    order = order[1].y > order[1].z ? mat2x4(order[0].xzyw, order[1].xzyw) : order;\n\n    mat4x4 unit4x4 = mat4x4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n    vec4 intOffset1 = unit4x4[int(order[0][3])];\n    vec4 intOffset2 = intOffset1 + unit4x4[int(order[0][2])];\n    vec4 intOffset3 = intOffset2 + unit4x4[int(order[0][1])];\n\n    vec4 skewedIntpos1 = skewedIntpos0 + intOffset1;\n    vec4 intpos1 = skewedIntpos1 + dot(skewedIntpos1, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset1 = pos - intpos1;\n\n    vec4 skewedIntpos2 = skewedIntpos0 + intOffset2;\n    vec4 intpos2 = skewedIntpos2 + dot(skewedIntpos2, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset2 = pos - intpos2;\n\n    vec4 skewedIntpos3 = skewedIntpos0 + intOffset3;\n    vec4 intpos3 = skewedIntpos3 + dot(skewedIntpos3, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset3 = pos - intpos3;\n\n    vec4 skewedIntpos4 = skewedIntpos0 + vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 intpos4 = skewedIntpos4 + dot(skewedIntpos4, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset4 = pos - intpos4;\n\n\n    vec4 gradient0 = grad4(skewedIntpos0);\n    vec4 gradient1 = grad4(skewedIntpos1);\n    vec4 gradient2 = grad4(skewedIntpos2);\n    vec4 gradient3 = grad4(skewedIntpos3);\n    vec4 gradient4 = grad4(skewedIntpos4);\n\n    float t0 = 0.5 - dot(offset0, offset0);\n    t0 = t0 < 0.0 ? 0.0 : t0 * t0 * t0;\n    float n0 = t0 * dot(gradient0, offset0);\n\n    float t1 = 0.5 - dot(offset1, offset1);\n    t1 = t1 < 0.0 ? 0.0 : t1 * t1 * t1;\n    float n1 = t1 * dot(gradient1, offset1);\n\n    float t2 = 0.5 - dot(offset2, offset2);\n    t2 = t2 < 0.0 ? 0.0 : t2 * t2 * t2;\n    float n2 = t2 * dot(gradient2, offset2);\n\n    float t3 = 0.5 - dot(offset3, offset3);\n    t3 = t3 < 0.0 ? 0.0 : t3 * t3 * t3;\n    float n3 = t3 * dot(gradient3, offset3);\n\n    float t4 = 0.5 - dot(offset4, offset4);\n    t4 = t4 < 0.0 ? 0.0 : t4 * t4 * t4;\n    float n4 = t4 * dot(gradient4, offset4);\n\n    /*\n    vec3 dt0 = t0 * gradient0 - 8.0 * pow(t0, 3.0 / 4.0) * dot(gradient0, offset0) * offset0;\n    vec3 dt1 = t1 * gradient1 - 8.0 * pow(t1, 3.0 / 4.0) * dot(gradient1, offset1) * offset1;\n    vec3 dt2 = t2 * gradient2 - 8.0 * pow(t2, 3.0 / 4.0) * dot(gradient2, offset2) * offset2;\n    vec3 dt3 = t3 * gradient3 - 8.0 * pow(t3, 3.0 / 4.0) * dot(gradient3, offset3) * offset3;\n    vec3 dt4 = t4 * gradient4 - 8.0 * pow(t4, 3.0 / 4.0) * dot(gradient4, offset4) * offset4;\n    */\n\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n}\n\n// 4D simplex noise (∂f/∂x, ∂f/∂y, ∂f/∂z, ∂f/∂w, f, f, f, f)\nmat2x4 simplex4dual(vec4 pos)\n{\n    float skewConstant = (sqrt(5.0) - 1.0) / 4.0;\n    float unskewConstant = (sqrt(5.0) - 5.0) / 20.0;\n\n    vec4 skewedIntpos0 = floor(pos + dot(pos, vec4(1.0, 1.0, 1.0, 1.0)) * skewConstant);\n    vec4 intpos0 = skewedIntpos0 + dot(skewedIntpos0, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset0 = pos - intpos0;\n\n    mat2x4 order = mat2x4(0, 1, 2, 3, offset0);\n\n    // sort order by order[1] (offset0)\n    order = order[1].x > order[1].y ? mat2x4(order[0].yxzw, order[1].yxzw) : order;\n    order = order[1].z > order[1].w ? mat2x4(order[0].xywz, order[1].xywz) : order;\n    order = order[1].x > order[1].z ? mat2x4(order[0].zyxw, order[1].zyxw) : order;\n    order = order[1].y > order[1].w ? mat2x4(order[0].xwzy, order[1].xwzy) : order;\n    order = order[1].y > order[1].z ? mat2x4(order[0].xzyw, order[1].xzyw) : order;\n\n    mat4x4 unit4x4 = mat4x4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n    vec4 intOffset1 = unit4x4[int(order[0][3])];\n    vec4 intOffset2 = intOffset1 + unit4x4[int(order[0][2])];\n    vec4 intOffset3 = intOffset2 + unit4x4[int(order[0][1])];\n\n    vec4 skewedIntpos1 = skewedIntpos0 + intOffset1;\n    vec4 intpos1 = skewedIntpos1 + dot(skewedIntpos1, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset1 = pos - intpos1;\n\n    vec4 skewedIntpos2 = skewedIntpos0 + intOffset2;\n    vec4 intpos2 = skewedIntpos2 + dot(skewedIntpos2, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset2 = pos - intpos2;\n\n    vec4 skewedIntpos3 = skewedIntpos0 + intOffset3;\n    vec4 intpos3 = skewedIntpos3 + dot(skewedIntpos3, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset3 = pos - intpos3;\n\n    vec4 skewedIntpos4 = skewedIntpos0 + vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 intpos4 = skewedIntpos4 + dot(skewedIntpos4, vec4(1.0, 1.0, 1.0, 1.0)) * unskewConstant;\n    vec4 offset4 = pos - intpos4;\n\n\n    vec4 gradient0 = grad4(skewedIntpos0);\n    vec4 gradient1 = grad4(skewedIntpos1);\n    vec4 gradient2 = grad4(skewedIntpos2);\n    vec4 gradient3 = grad4(skewedIntpos3);\n    vec4 gradient4 = grad4(skewedIntpos4);\n\n    float t0 = 0.5 - dot(offset0, offset0);\n    t0 = t0 < 0.0 ? 0.0 : t0 * t0 * t0;\n    float n0 = t0 * dot(gradient0, offset0);\n\n    float t1 = 0.5 - dot(offset1, offset1);\n    t1 = t1 < 0.0 ? 0.0 : t1 * t1 * t1;\n    float n1 = t1 * dot(gradient1, offset1);\n\n    float t2 = 0.5 - dot(offset2, offset2);\n    t2 = t2 < 0.0 ? 0.0 : t2 * t2 * t2;\n    float n2 = t2 * dot(gradient2, offset2);\n\n    float t3 = 0.5 - dot(offset3, offset3);\n    t3 = t3 < 0.0 ? 0.0 : t3 * t3 * t3;\n    float n3 = t3 * dot(gradient3, offset3);\n\n    float t4 = 0.5 - dot(offset4, offset4);\n    t4 = t4 < 0.0 ? 0.0 : t4 * t4 * t4;\n    float n4 = t4 * dot(gradient4, offset4);\n\n    vec4 dt0 = t0 * gradient0 - 8.0 * pow(t0, 3.0 / 4.0) * dot(gradient0, offset0) * offset0;\n    vec4 dt1 = t1 * gradient1 - 8.0 * pow(t1, 3.0 / 4.0) * dot(gradient1, offset1) * offset1;\n    vec4 dt2 = t2 * gradient2 - 8.0 * pow(t2, 3.0 / 4.0) * dot(gradient2, offset2) * offset2;\n    vec4 dt3 = t3 * gradient3 - 8.0 * pow(t3, 3.0 / 4.0) * dot(gradient3, offset3) * offset3;\n    vec4 dt4 = t4 * gradient4 - 8.0 * pow(t4, 3.0 / 4.0) * dot(gradient4, offset4) * offset4;\n\n    float sum = 27.0 * (n0 + n1 + n2 + n3 + n4);\n\n    return mat2x4(27.0 * (dt0 + dt1 + dt2 + dt3 + dt4), sum, sum, sum, sum);\n}\n\n// 3D curl noise (by 3D simplex noise)\nvec3 curl(vec3 pos)\n{\n    float delta = 0.001;\n    mat3x3 v = mat3x3(pos, pos + vec3(123.456, 789.012, 345.678), pos + vec3(901.234, 567.890, 123.456));\n\n    float pxpx = (simplex3(v[0] + vec3(+delta, 0, 0)).w - simplex3(v[0] + vec3(-delta, 0, 0)).w) / (2.0 * delta);\n    float pxpy = (simplex3(v[0] + vec3(0, +delta, 0)).w - simplex3(v[0] + vec3(0, -delta, 0)).w) / (2.0 * delta);\n    float pxpz = (simplex3(v[0] + vec3(0, 0, +delta)).w - simplex3(v[0] + vec3(0, 0, -delta)).w) / (2.0 * delta);\n    float pypx = (simplex3(v[1] + vec3(+delta, 0, 0)).w - simplex3(v[1] + vec3(-delta, 0, 0)).w) / (2.0 * delta);\n    float pypy = (simplex3(v[1] + vec3(0, +delta, 0)).w - simplex3(v[1] + vec3(0, -delta, 0)).w) / (2.0 * delta);\n    float pypz = (simplex3(v[1] + vec3(0, 0, +delta)).w - simplex3(v[1] + vec3(0, 0, -delta)).w) / (2.0 * delta);\n    float pzpx = (simplex3(v[2] + vec3(+delta, 0, 0)).w - simplex3(v[2] + vec3(-delta, 0, 0)).w) / (2.0 * delta);\n    float pzpy = (simplex3(v[2] + vec3(0, +delta, 0)).w - simplex3(v[2] + vec3(0, -delta, 0)).w) / (2.0 * delta);\n    float pzpz = (simplex3(v[2] + vec3(0, 0, +delta)).w - simplex3(v[2] + vec3(0, 0, -delta)).w) / (2.0 * delta);\n\n    return vec3(pzpy - pypz, pxpz - pzpx, pypx - pxpy);\n}\n\n// 3D curl noise - alternative implementation (by 3D simplex noise)\nvec3 curl2(vec3 pos)\n{\n    vec4 a = simplex3(pos);\n    vec4 b = simplex3(pos + vec3(123.456, 789.012, 345.678));\n\n    return cross(a.xyz, b.xyz);\n}\n\n// domain rotation in 3D\n// usage: someNoise(domainRotation(pos))\nvec3 domainRotation(vec3 pos)\n{\n    return vec3(\n        pos.x + (pos.x + pos.z) * -0.211324865405187 + pos.y * 0.577350269189626,\n        (pos.x + pos.z) * -0.577350269189626 + pos.y * 0.577350269189626,\n        pos.z + (pos.x + pos.z) * -0.211324865405187 + pos.y * 0.577350269189626);\n}\n","name":"Common","description":"","type":"common"}]}