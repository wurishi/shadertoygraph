{"ver":"0.1","info":{"id":"dtcSzM","date":"1685276940","viewed":171,"name":"Edge Detection - Naitronbomb","username":"Naitronbomb","description":"Canny Edge Detection","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["detection","edge","canny"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 normal = texelFetch(iChannel0, ivec2(fragCoord) % textureSize(iChannel0, 0), 0);\n    \n    vec4 guassian = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    vec4 sobel = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    \n    vec4 canny = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    // Output to screen\n    fragColor = canny;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gaussian filter\n// Actual kernel width is (2*k + 1)\nconst int k = 2;\nconst float stddev = 1.0;\n\nconst float expCoef = 0.15915494309189535;\nvec4 guassianFilter(sampler2D channel, ivec2 coord) {\n    int width = (2*k + 1);\n    vec4 total = vec4(0.0);\n    for (int i = 1; i <= width; i++) {\n        for (int j = 1; j <= width; j++) {\n            float mag = float((i-(k+1))*(i-(k+1)) + (j-(k+1))*(j-(k+1)));\n            float coefficient = (expCoef/(stddev*stddev))*exp(-mag/(2.0*(stddev*stddev)));\n            total += coefficient * texelFetch(channel, (coord + ivec2(i-(k+1),j-(k+1))) % textureSize(channel, 0), 0);\n        }\n    }\n    return total;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = guassianFilter(iChannel0, ivec2(fragCoord));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Sobel operator\nfloat toGray(vec4 color) {\n    return 0.2126*color.x + 0.7152*color.y + 0.0722*color.z;\n}\n\nconst mat3 sobelMatrixX = mat3(\n   1.0, 2.0, 1.0,\n   0.0, 0.0, 0.0,\n   -1.0, -2.0, -1.0\n);\nconst mat3 sobelMatrixY = mat3(\n   1.0, 0.0, -1.0,\n   2.0, 0.0, -2.0,\n   1.0, 0.0, -1.0\n);\nvec2 sobel(sampler2D channel, ivec2 coord) {\n    vec2 g = vec2(0.0);\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 coef = vec2(sobelMatrixX[i][j],sobelMatrixY[i][j]);\n            g += coef*toGray(texelFetch(channel, coord+ivec2(i-1,j-1), 0));\n        }\n    }\n    return g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(sobel(iChannel1, ivec2(fragCoord)),0.0,0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Thresholding and edge tracking\n// Threshold values range from 0-1\nconst float lowThreshold = 0.3;\nconst float highThreshold = 0.7;\n\nbool hasStrong(sampler2D channel, ivec2 coord) {\n    bool strong = false;\n    strong = strong || (texelFetch(channel, coord + ivec2(-1,-1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(0,-1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(1,-1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(-1,0), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(1,0), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(-1,1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(0,1), 0).x > 0.5);\n    strong = strong || (texelFetch(channel, coord + ivec2(1,1), 0).x > 0.5);\n    return strong;\n}\n\nbool threshold(float angle, sampler2D channel, ivec2 coord) {\n    if (angle < 22.5 || angle >= 157.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(-1,0), 0));\n        float right = length(texelFetch(channel, coord + ivec2(1,0), 0));\n        return current >= left && current >= right;\n    } else if (angle < 67.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(-1,-1), 0));\n        float right = length(texelFetch(channel, coord + ivec2(1,1), 0));\n        return current >= left && current >= right;\n    } else if (angle < 112.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(0,-1), 0));\n        float right = length(texelFetch(channel, coord + ivec2(0,1), 0));\n        return current >= left && current >= right;\n    } else if (angle < 157.5) {\n        float current = length(texelFetch(channel, coord, 0));\n        float left = length(texelFetch(channel, coord + ivec2(-1,1), 0));\n        float right = length(texelFetch(channel, coord + ivec2(1,-1), 0));\n        return current >= left && current >= right;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 sobel = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    \n    float mag = length(sobel.xy);\n    float angle = 57.2957795131*abs(atan(sobel.y,sobel.x));\n    \n    bool isMax = threshold(angle, iChannel2, ivec2(fragCoord));\n    vec4 thresholded = vec4(0.0,0.0,0.0,1.0);\n    if (isMax && mag >= highThreshold) {\n        thresholded = vec4(1.0);\n    } else if (isMax && mag >= lowThreshold && hasStrong(iChannel3, ivec2(fragCoord))) {\n        thresholded = vec4(1.0);\n    }\n\n    // Output to screen\n    fragColor = thresholded;   \n}","name":"Buffer C","description":"","type":"buffer"}]}