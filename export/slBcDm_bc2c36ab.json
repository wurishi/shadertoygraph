{"ver":"0.1","info":{"id":"slBcDm","date":"1649779531","viewed":313,"name":"Patched Fibonacci sphere Voronoi","username":"stegu","description":"The classic \"Worley noise\" F2-F1, the difference between distances to the two closest closest neighbors in a point set. This computes correct 1st and 2nd neighbors at *all* points, by using a 3x3 search window and one small extra patch at each pole.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sphere","barycentric","inverse","fibonacci","chamfer"],"hasliked":0,"parentid":"7lByW1","parentname":"fig:Fibdist"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The number of points, N, can be anything from 13 to around\n    // 2e6 (!), without affecting the speed of the algorithm.\n    const float FibonacciN = 43.0;\n\n    const float sphere_size = 1.0; // Unit sphere\n\n    const vec3 bgcolor = vec3(0.1, 0.2, 0.1);\n    const vec3 spherecolor = vec3(0.3, 0.3, 0.3);\n    const vec3 spotcolor = vec3(0.7,0.7,0.5);\n    const vec3 isolinecolor = vec3(0.7,0.3,0.0);\n    const vec3 edgecolor = vec3(0.7,0.7,0.5);\n\n    // Default view: fit unit circle in viewport\n    vec3 uvw;\n    uvw.xy = (2.0*fragCoord- iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = 1.1*pow(0.98,iMouse.y-abs(iMouse.w));\n    uvw.xy = zoom*uvw.xy;\n    // uvw is scaled but kept unrotated\n    float sphere_mask = 1.0 - aastep(sphere_size, length(uvw.xy));\n    // Early exit outside object - big saving in distant views\n    if(sphere_mask == 0.0) {\n        fragColor = vec4(bgcolor, 1.0);\n        return;\n    }\n\n    // Fake sphere z in unit circle, set to 0.0 beyond the rim\n    uvw.z = sqrt(max(0.0, sphere_size*sphere_size-dot(uvw.xy,uvw.xy)));\n\n    // Spin vertically (rotate only the texcoords)\n    float el = 3.5*sin(iTime*sqrt(3.0/FibonacciN));\n    float Se = sin(el);\n    float Ce = cos(el);\n    // Spin horizontally\n    float az = 7.0*sin(iTime*sqrt(2.0/FibonacciN));\n    float Sa = sin(az);\n    float Ca = cos(az);\n    mat3 R = mat3(1.0,0.0,0.0, 0.0,Ce,-Se, 0.0,Se,Ce);\n    R *= mat3(Ca,0.0,Sa, 0.0,1.0,0.0, -Sa,0.0,Ca);\n    mat3 Ri = transpose(R); // orthonormal, hence inverse = tranpose\n\n    vec3 v = normalize(R*uvw); // Rotate and rescale to unit sphere\n\n\t// Pattern feature sizes scale with sqrt(N)\n\tfloat isolinestep = 0.5/sqrt(FibonacciN); // Linear distances here\n\tfloat spotsize = 0.1/sqrt(FibonacciN); // Remember to use sqrt(d.x)\n\n\t// Find the two closest N-Fib-sphere points to v\n    vec2 d;\n    vec4 p0, p1;\n\tinverseSF3x3(v, FibonacciN, p0, p1, d);\n    float d0 = sqrt(d.x); // Worley would call d0 \"F1\",\n\tfloat d1 = sqrt(d.y); // and d1 would be \"F2\".\n\n\tfloat spots = 1.0-aastep(spotsize, sqrt(d.x));\n    // Beware that auto-derivs are wonky at edges where d1-d0 has a cusp\n    float edges = 1.0-aastep(0.05/sqrt(FibonacciN), d1-d0);\n    float isolines = 0.0;\n    for(float n = 1.0; n < 8.0; n++) {\n        isolines = max(isolines, aaline((n-mod(iTime,1.0))*isolinestep, d1-d0, 3.0));\n    }\n\n    vec3 mixcolor = spherecolor;\n\tmixcolor = mix(mixcolor, isolinecolor, isolines);\n    mixcolor = mix(mixcolor, spotcolor, spots);\n\tmixcolor = mix(mixcolor, edgecolor, edges);\n    mixcolor = mix(bgcolor, mixcolor, sphere_mask); // AA of the outline\n\n    fragColor = vec4(mixcolor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Anti-aliased implicit line around v == t, in the spirit of\n// aastep(), with line width w specified in fragment space (pixels)\nfloat aaline(float t, float v, float w) {\n  float fw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n  return smoothstep(t-0.5*w*fw-fw, t-0.5*w*fw+fw, v)\n\t- smoothstep(t+0.5*w*fw-fw, t+0.5*w*fw+fw, v);\n}\n\n// The first \"fracmodphi()\" below works with WebGL 1.0.\n// The second version is much better, but requires WebGL 2.0.\n#if 0\n#define m1 0.618033988749895\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction)\n\treturn k * m1 - floor(k * m1);\n}\n#else\nfloat fracmodphi(float k) {\n    // Thanks to @mla for this more predictable version,\n    // invoking the angelic powers of integer arithmetic.\n    // 1) Realize that fract(n*p/q) = ((n*p)%q)/q = (((n%q)*p)%q)/q\n    // 2) Use F23/F24 as a rational approximation of (sqrt(5)-1)/2\n    uint p = 28657u, q = 46368u;\n    uint n = uint(k);\n    return float(n%q*p%q)/float(q);\n}\n#endif\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n\n// Compute point k on N-point fibsphere (helper for other functions)\n//\nvec3 evalSFpoint(float k, float N) {\n\tfloat phi = 2.0*PI*fracmodphi(k);\n\tfloat cosTheta = 1.0 - (2.0*k + 1.0)*(1.0/N);\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\treturn vec3(cos(phi)*sinTheta, sin(phi)*sinTheta,cosTheta);\n}\n\n// Compute neighbors in the local Cartesian map, and their distances.\nfloat evalNearest(float N, vec2 B, vec2 i, vec2 c, vec3 v, out vec4 p) {\n    float cosTheta = dot(B, i + c) + (1.0-1.0/N);\n    // The expression below is a hardware-friendly way (?) of saying\n    // \"if(abs(cosTheta)>1.0) cosTheta = 1.0-abs(cosTheta);\"\n\tcosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n\tp.w = floor(N*0.5 - cosTheta*N*0.5);\n\tp.xyz = evalSFpoint(p.w, N);\n\treturn dot(v-p.xyz, v-p.xyz);\n}\n\n//\n// Find the 2 nearest neighbors on an N-point Fibonacci sphere.\n// Evolved version of an algorithm from the article \"Spherical\n// Fibonacci Mapping\" by Keinert et al, ACM Trans. on Graphics\n// 34 (2015), 6, 193.\n//\n// Return two neighbors, with points, indices and distances.\n// p0.xyz is the location of neighbor 0, p0.w is its index.\n// Similarly for p1.\n// d contains the squared distances from v to each of the neighbors\n// in the order p0, p1.\n// p0 is the closest point, p1 the second closest.\n//\n// Watching out for duplicates around the poles, we need to patch\n// only a single error in the search (see the last few lines below).\n//\n// This function is Copyright 2022 by Stefan Gustavson.\n// It is released under the terms of the MIT license:\n// https://opensource.org/licenses/MIT\n// (\"Use freely for any purpose, but keep the attribution\")\n//\nvoid inverseSF3x3(vec3 v, float N,\n                  out vec4 p0, out vec4 p1, out vec2 d01) {\n\tfloat phi = min(atan(v.y, v.x), PI); // min() to dodge NaN\n\tfloat cosTheta = v.z;\n\tfloat k = max(2.0, floor(\n\t\tlog(N * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))\n\t\t/ log(PHI*PHI)));\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 = floor(Fk * PHI + 0.5);\n\tmat2 B = mat2(\n\t\t2.0*PI*fracmodphi(F0+1.0) - 2.0*PI*(PHI-1.0), -2.0*F0/N,\n\t\t2.0*PI*fracmodphi(F1+1.0) - 2.0*PI*(PHI-1.0), -2.0*F1/N);\n\tmat2 invB = inverse(B);\n\tvec2 c = round(invB * vec2(phi, cosTheta - (1.0-1.0/N)));\n\n\tvec2 Bvec = vec2(B[0][1],B[1][1]);\n\t// Compute all nine neighbors first, *then* find closest point\n\t// (Sorting is more efficient with all values available)\n    float d[9];\n    vec4 p[9];\n    d[0] = evalNearest(N, Bvec, vec2(-1.0, -1.0), c, v, p[0]);\n    d[1] = evalNearest(N, Bvec, vec2(-1.0, 0.0), c, v, p[1]);\n    d[2] = evalNearest(N, Bvec, vec2(-1.0, 1.0), c, v, p[2]);\n    d[3] = evalNearest(N, Bvec, vec2(0.0, -1.0), c, v, p[3]);\n    d[4] = evalNearest(N, Bvec, vec2(0.0, 0.0), c, v, p[4]);\n    d[5] = evalNearest(N, Bvec, vec2(0.0, 1.0), c, v, p[5]);\n    d[6] = evalNearest(N, Bvec, vec2(1.0, -1.0), c, v, p[6]);\n    d[7] = evalNearest(N, Bvec, vec2(1.0, 0.0), c, v, p[7]);\n    d[8] = evalNearest(N, Bvec, vec2(1.0, 1.0), c, v, p[8]);\n\n\t// Partial sort: Pick p[0], p[1] as the two closest points\n    // (by a \"joint selection-swap sort\" in one pass over the data)\n    float dtemp;\n   \tvec4 ptemp;\n\n    // Trash p[1] if it's a duplicate of p[0] (happens in cell 2)\n    if(p[1].w == p[0].w) { // trash p1\n    p[1] = vec4(0.0, 0.0, 0.0, -1.0); // Set invalid k\n\t\td[1] = 12.0; // More than the sphere diameter squared\n\t}\n\n    if(d[1] < d[0]) { // Make sure d[0] is smallest\n        dtemp = d[0];\n        d[0] = d[1];\n        d[1] = dtemp;\n        ptemp = p[0];\n        p[0] = p[1];\n        p[1] = ptemp;\n    }\n    for(int i = 2; i<9; i++) {\n        if(d[i] < d[1]) { // If smaller than d[1]\n            if(p[0].w != p[i].w) { // *and* not a duplicate of p[0]\n                d[1] = d[i];    // Replace p[1] with p[i]\n                p[1] = p[i];\n                if(d[1] < d[0]) { // If smaller also than d[0]:\n                    dtemp = d[0];   // Swap p[1] and p[0]\n                    d[0] = d[1];    // (i.e. set p[0] to p[i], and\n                    d[1] = dtemp;   // keep old p[0] as new p[1])\n                    ptemp = p[0];\n                    p[0] = p[1];\n                    p[1] = ptemp;\n                }\n            }\n        }\n    }\n    p0 = p[0];\n    p1 = p[1];\n    d01 = vec2(d[0], d[1]);\n    \n    // Patch up the one error: cell 1/N-2 sometimes misses cell 4/N-5\n\n    if((p0.w == 1.0) && (p1.w != 4.0)) {\n        float knew = 4.0;\n\t\tvec3 pnew = evalSFpoint(knew, N);\n\t\tfloat dnew = dot(v-pnew, v-pnew);\n\t\tif(dnew < d01.y) { // If point 4 is closer than current p1\n\t\t\tp1 = vec4(pnew, knew); // replace p1\n\t\t\td01.y = dnew;\n\t\t}\n    }\n    if((p0.w == N-2.0) && (p1.w != N-5.0)) {\n        float knew = N-5.0;\n\t\tvec3 pnew = evalSFpoint(knew, N);\n\t\tfloat dnew = dot(v-pnew, v-pnew);\n\t\tif(dnew < d01.y) { // If point N-5 is closer than current p1\n\t\t\tp1 = vec4(pnew, knew); // replace p1\n\t\t\td01.y = dnew;\n\t\t}\n    }\n}\n","name":"Common","description":"","type":"common"}]}