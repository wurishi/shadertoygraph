{"ver":"0.1","info":{"id":"XfdXzr","date":"1713515008","viewed":100,"name":"IDW Texture Data","username":"MusixNotMusic","description":"Inverse distance weighting\ntexture data \nvec3<x, y, z> z: value <x, y> normalized coordination\n[Ref] https://www.shadertoy.com/view/ft23zV","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["idwtexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_POINTS 256\n\nfloat distancePower = 2.;\nfloat neighbourDistanceThreshold = 2.5;\nfloat exactThreshold = 0.001; // if we are very close to a point then avoid a divide by zero and set to exact weight of the point\n\nvec3 heatmapGradient(float t) {\n\treturn clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\nvec3 palette(float v) {\n    return heatmapGradient(mod((v-11.)*.1,1.));\n}\n\nfloat isoline(float val, float lg, float ref, float pas, float thickness) {\n    float v = abs(mod(val - ref + pas * .5, pas) - pas * .5) / lg - .1 * thickness;\n    return smoothstep(.2, .8, v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float sumOfAllInverseDistances = 0.;\n    float inverseDistances = 0.;\n    float interpolatedValue = 0.;  \n    \n    float size = sqrt(float(NUM_POINTS));\n    \n    for (int i = 0; i < NUM_POINTS; ++i) \n    {\n        vec3 pos = texture(iChannel0, vec2(mod(float(i), size), float(i) / size)).xyz;\n        if (length(pos) < 0.4) continue;\n        \n        float dist = max(exactThreshold, length(uv - pos.xy));  \n        if (dist < neighbourDistanceThreshold) \n        {                            \n            inverseDistances = 1. / pow(dist, distancePower);\n            sumOfAllInverseDistances += inverseDistances;\n        }\n        interpolatedValue += pos.z * inverseDistances;\n    }\n    interpolatedValue /= sumOfAllInverseDistances;\n    \n    float lg = 2.*length(vec2(dFdx(interpolatedValue), dFdy(interpolatedValue)));\n\tfloat k1 = isoline(interpolatedValue, lg, .05, .2, 1.),\n       \t  k2 = isoline(interpolatedValue, lg, .025, .05, .01);\n    \n    // paletize value\n    vec3 col = palette(2.5 * interpolatedValue - 1.5); \n    \n    // apply isoline to color\n\tcol *= (.3+(k1*.7));\n    col *= (.7+(k2*.3));\n    \n    //vignette\n    //col *= pow(30.0 * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .2);\n    \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}