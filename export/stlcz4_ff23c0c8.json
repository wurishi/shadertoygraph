{"ver":"0.1","info":{"id":"stlcz4","date":"1647600980","viewed":93,"name":"test CRT","username":"Wassimulator","description":"CRT thingy WOP","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SCANLINES\n\n#define SCREEN_SHAPE\n#define LIGHT_EFFECTS\n\n//#define CURVE_MASK_TO_SCREEN\n#define SCREEN_CURVE_RADIUS\t\t5.0\n#define SCREEN_CORNER_RADIUS\t0.1\n#define BRIGHTNESS      \t\t2.5\n#define PIXEL_SHARPNESS   \t\t3.0\n#define LINE_SHARPNESS\t\t\t6.0\n#define MASK_STRENGTH\t\t\t0.35\n#define MASK_SCALE\t\t\t\t600.0\n\n\n\n\n\n\n#define IRES\t\tvec2( 256, 239 )\n\n\nconst float PI = 3.14159265;\n\n\n#define gaussian(a,b)\texp2((a)*(a)*-(b))\n\n\nvec2 curveScreen( vec2 uv ) {\n    float r = PI*0.5/SCREEN_CURVE_RADIUS;\n    float d = 1.0-cos(uv.x*r)*cos(uv.y*r);\t\t//distance to screen\n    float s = cos(r);\t\t\t\t\t\t\t//scale factor to re-fit window\n    return uv / (1.0-d) * s;\n}\n\n\nfloat discardCorners( vec2 pos ) {\n    pos = abs(pos);\n    pos.x = pos.x*1.333-0.333;\t\t\t\t\t\t\t\t\t\t\t// 4:3 aspect ratio correction\n    if( min(pos.x, pos.y) < 1.0-SCREEN_CORNER_RADIUS ) return 1.0;\t\t// not near corner -- break early\n    float d = distance( pos, vec2(1.0-SCREEN_CORNER_RADIUS) );\n    return float( d<SCREEN_CORNER_RADIUS );\n}\n\n\nvec3 getSample( vec2 pos, vec2 off ) {\n\t//get nearest emulated sample\n\tpos = floor(pos*IRES) + vec2(0.5) + off;\n\tvec3 col = vec3(0.0);\n\tif ( pos.x>=0.0 && pos.x<=IRES.x && pos.y>=0.0 && pos.y<=IRES.y ) {\n        col = texelFetch( iChannel3, ivec2(pos), 0).rgb;\n        col = pow( ( (col + 0.055) / 1.055), vec3(2.4) );\t\t// SRGB => linear\n\t}\n\treturn col;\n}\n\n\nvec3 getScanline( vec2 pos, float off ) {\n\t// 3-tap gaussian filter to get colour at arbitrary point along scanline\n    float d = 0.5-fract(pos.x*IRES.x);\n\tvec3 ca = getSample( pos, vec2(-1.0, off ) );\n\tvec3 cb = getSample( pos, vec2( 0.0, off ) );\n\tvec3 cc = getSample( pos, vec2( 1.0, off ) );\n\tfloat wa = gaussian( d-1.0, PIXEL_SHARPNESS );\n\tfloat wb = gaussian( d,     PIXEL_SHARPNESS );\n\tfloat wc = gaussian( d+1.0, PIXEL_SHARPNESS );\n\treturn ( ca*wa + cb*wb + cc*wc ) / ( wa+wb+wc);\n}\n\n\nvec3 getScreenColour( vec2 pos ) {\n\t//Get influence of 3 nearest scanlines\n    float d = 0.5-fract(pos.y*IRES.y);\n\tvec3 ca = getScanline( pos,-1.0 ) * gaussian( d-1.0, LINE_SHARPNESS );\n\tvec3 cb = getScanline( pos, 0.0 ) * gaussian( d,     LINE_SHARPNESS );\n\tvec3 cc = getScanline( pos, 1.0 ) * gaussian( d+1.0, LINE_SHARPNESS );\n    return ca + cb + cc;\n}\n\n\nvec3 ACESFilm( vec3 x ) {\n    return clamp((x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord / iResolution.xy;\n   \tpos = pos*2.0 - 1.0;\n    pos.x *= iResolution.x/iResolution.y*0.75;\t\t\t\t\t\t// 4:3 aspect\n    \n\n    pos = curveScreen(pos);\t\t\t\t\t\t\t\t\t\t\t// curve screen\n\n    \n    if(max( abs(pos.x), abs(pos.y) )<1.0) {\t\t\t\t\t\t\t// skip everything if we're beyond the screen edge\n    \t\n        vec3 col = vec3(1.0);\n        \n\n        col *= discardCorners(pos);                                //screen shape\n\n        \n        col *= 1.0 - sqrt(length(pos)*0.25);\t\t\t\t\t\t// vignette\n      \n        pos = pos*0.5 + 0.5;\n\n        #ifdef SCANLINES\n\t\tcol *= getScreenColour( pos );\n        #else\n        col *= getSample( pos, vec2(0.0) );\n        #endif\n\n    \t//col *= texelFetch( iChannel1, ivec2(fragCoord), 0).rgb;\t\t\t\t// draw mask flat (moire fix)\n     \n        \n\t\tcol *= BRIGHTNESS;\n    \tcol = ACESFilm(col);                                              // light effects\n\n    \n    \tcol = pow( col, vec3(1.0/2.4) ) * 1.055 - 0.055;\t\t\t// linear => SRGB\n        \n    \t//col = texelFetch( iChannel1, ivec2(fragCoord), 0).rgb;\n    \n    \tfragColor = vec4( col, 1.0 );\n    }\n}","name":"Image","description":"","type":"image"}]}