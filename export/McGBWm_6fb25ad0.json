{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n  Copyright Michael Sakharov 2024\n  All Rights Reserved\n\n  This code is proprietary and confidential.\n  Unauthorized copying, modification, distribution, or use of this work\n  in any form, in whole or in part, is strictly prohibited.\n\n  This includes but is not limited to:\n  - Commercial or non-commercial use\n  - Integration into other projects\n  - Training AI/ML models\n  - Creating derivative works\n  - Redistributing or hosting the code outside of Shadertoy\n\n  Permitted uses:\n  - Forking and modification within Shadertoy's platform only\n  - Studying the code for educational purposes\n  \n  Note: Forked versions must maintain this copyright notice and\n  cannot be used outside of Shadertoy without permission.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    col.rgb /= col.w;\n    \n    col.rgb *= 4.0;\n    \n    col.rgb = (col.rgb * (2.51 * col.rgb + 0.03)) / (col.rgb * (2.43 * col.rgb + 0.59) + 0.14);\n    col.rgb = pow(col.rgb, vec3(0.4545));\n    \n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// ==================== Camera Stuff ==================== \n\nmat3 getCameraMatrix(vec3 ro, vec3 lookAt) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\nvoid getRoRd(vec2 fragCoord, vec2 resolution, vec4 imouse, float time, out vec3 ro, out vec3 rd)\n{    \n    vec2 uv = fragCoord/resolution.xy;\n    vec2 p = (2.0*fragCoord-resolution.xy)/resolution.y;\n    \n    // Orbit camera controls\n    vec2 mouse = imouse.xy/resolution.xy;\n    float camDist = 8.0;\n    \n    if (imouse.xy == vec2(0.0)) {\n        mouse = vec2(0.0, 0.7);\n    }\n    \n    // Convert mouse position to spherical coordinates\n    float azimuth = (mouse.x * 2.0 - 1.0) * 3.141592;\n    float elevation = (mouse.y - 0.5) * 3.141592;\n    \n    // Calculate camera position\n    ro = vec3(\n        camDist * cos(elevation) * cos(azimuth),\n        camDist * sin(elevation),\n        camDist * cos(elevation) * sin(azimuth)\n    );\n    \n    // Look at origin\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    mat3 camMat = getCameraMatrix(ro, lookAt);\n    rd = camMat * normalize(vec3(p, 2.0));\n\n}\n\n// ==================== End Of Camera Stuff ==================== ","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"volume","id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n  Copyright Michael Sakharov 2024\n  All Rights Reserved\n\n  This code is proprietary and confidential.\n  Unauthorized copying, modification, distribution, or use of this work\n  in any form, in whole or in part, is strictly prohibited.\n\n  This includes but is not limited to:\n  - Commercial or non-commercial use\n  - Integration into other projects\n  - Training AI/ML models\n  - Creating derivative works\n  - Redistributing or hosting the code outside of Shadertoy\n\n  Permitted uses:\n  - Forking and modification within Shadertoy's platform only\n  - Studying the code for educational purposes\n  \n  Note: Forked versions must maintain this copyright notice and\n  cannot be used outside of Shadertoy without permission.\n*/\n\nfloat noise(vec3 x) {\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<4; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * textureLod(iChannel2,(s * x)/32.0,0.0).x;\n    }\n    return r;\n}\n\nvec2 galaxyDensity(vec3 pos) {\n    float centerDist = length(pos.xz);\n    float rotFade = smoothstep(2.5 - 1.0, 2.5 + 1.0, centerDist);\n    float rotStr = centerDist * 0.7 * rotFade;\n    \n    vec2 rot = vec2(\n        pos.x * cos(rotStr) + pos.z * sin(rotStr),\n        -pos.x * sin(rotStr) + pos.z * cos(rotStr)\n    );\n    \n    float arms = abs(mod(atan(rot.y, rot.x) * (1.0 / 3.141592653591) + 0.5, 1.0) - 0.5);\n    arms = smoothstep(0.5, 0.0, arms) * 4.0;\n    \n    vec3 noisePos = mix(\n        pos,\n        vec3(rot.x, pos.y, rot.y),\n        0.4 * rotFade\n    );\n    \n    float clouds = pow(noise(noisePos * 2.5), 2.0);\n    arms = mix(arms, clouds, 0.7);\n    \n    float bulge = centerDist < 0.0 ? 2.0 : \n                 centerDist < 2.0 ? 2.0 * (1.0 - centerDist / 2.0) : 0.0;\n    \n    vec2 density = vec2(max(arms, bulge), max(clouds, 0.0));\n    float normDist = clamp(1.0 - (centerDist / 5.0), 0.0, 1.0);\n    density.x *= normDist;\n    \n    float normYDist = exp(-2.0 * pow(abs(pos.y) / 0.5, 2.0));\n    density.x *= normYDist;\n    \n    density.x *= 1.0;\n    density.y = density.x * smoothstep(0.4, 0.5, density.y * 2.0);\n    \n    return density;\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro;\n    vec3 rd;\n    getRoRd(fragCoord, iResolution.xy, iMouse, iTime, ro, rd);\n    \n    vec3 scatter = vec3(0.220,0.557,1.000);\n    \n    vec3 acc = vec3(0.0);\n    float totDens = 0.0;\n    float dustDens = 0.0;\n    \n    vec3 pos = ro + rd * (20.0/16.0) * hash12(fragCoord + iTime);\n    \n    for(int i = 0; i < 16; i++) {\n        vec2 dens = galaxyDensity(pos) * (20.0/16.0);\n        float dist = length(pos) / 8.0;\n        \n        dustDens += dens.y * 512.0 * dist * dist * dist;\n        totDens += dens.x;\n        \n        vec3 inscatter = dens.x * scatter;\n        acc += inscatter * exp(-(totDens + dustDens) * scatter);\n        \n        pos += rd * (20.0/16.0);\n    }\n    \n    if (iMouse.z > 0.0) {\n        fragColor = vec4(acc, 1.0);\n        return;\n    }\n    \n    vec4 prev = texture(iChannel1, fragCoord / iResolution.xy);\n    fragColor = vec4(prev.rgb + acc, prev.w + 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"McGBWm","date":"1734090796","viewed":145,"name":"Galactic Swirl","username":"TheNuclearWolf","description":"The obvious next step to learning volumetric stuff is to make a galaxy.\n","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["galaxy"],"hasliked":0,"parentid":"","parentname":""}}