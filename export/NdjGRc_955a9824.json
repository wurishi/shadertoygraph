{"ver":"0.1","info":{"id":"NdjGRc","date":"1617743221","viewed":87,"name":"Easter egg attack!","username":"xernobyl","description":"Happy easter!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sd_box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nfloat sd_sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat scene(vec3 ray_pos, vec3 ray_origin) {\n    float a = 0.5 * ray_pos.z + 2.0 * iTime;\n    \n    vec3 r0;\n    r0.xy = vec2(ray_pos.x * cos(a) - ray_pos.y * sin(a),\n                      ray_pos.x * sin(a) + ray_pos.y * cos(a));\n    r0.z = ray_pos.z;\n\n    \n    \n    float d0 = sd_sphere(fract((r0) / 2.5) * 2.5 - 1.25, 0.5);\n    \n    \n    a = -0.5 * ray_pos.z - 4.0 * iTime;\n    \n    ray_pos.xy = vec2(ray_pos.x * cos(a) - ray_pos.y * sin(a),\n                      ray_pos.x * sin(a) + ray_pos.y * cos(a));\n\n    float d1 = sd_box(fract((ray_pos) / 5.0) * 5.0 - 2.5, vec3(1.0, 1.0, 10.0));\n    \n    return opSmoothUnion(d0, d1, 0.25);\n}\n\n\nvec3 scene_normal(vec3 p, vec3 ray_origin) {\n  const float h = 0.01;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(k.xyy * scene(p + k.xyy * h, ray_origin) + \n                   k.yyx * scene(p + k.yyx * h, ray_origin) + \n                   k.yxy * scene(p + k.yxy * h, ray_origin) + \n                   k.xxx * scene(p + k.xxx * h, ray_origin));\n}\n\n    \nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvec3 sRGB(vec3 linear)\n{\n  vec3 a = 12.92 * linear;\n  vec3 b = 1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055;\n  vec3 c = step(vec3(0.0031308), linear);\n  return mix(a, b, c);\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 ray_dir = vec3(frag_coord / iResolution.xy * 2.0 - 1.0, -1.0 / 4.0);\n  ray_dir.x *= iResolution.x / iResolution.y;\n  ray_dir = normalize(ray_dir);\n\n  vec3 ray_origin = vec3(0.0, 0.0, -10.0 * iTime + sin(iTime));\n  vec3 ray_pos = ray_origin;\n  \n  int max_iterations = 128;\n  float total_distance = 0.0;\n\n  for (int max_iterations = 0; max_iterations < 64; ++max_iterations) {\n    float dist = scene(ray_pos, ray_origin);\n    total_distance += dist;\n\n    ray_pos = ray_origin + total_distance * ray_dir;\n\n    if (dist < 0.0001) {\n      break;\n    }\n  }\n\n  vec3 n = scene_normal(ray_pos, ray_origin);\n  \n  vec3 col = pal(total_distance * .25 + iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  \n  col = 2.0 * col * -dot(n, ray_dir);\n  col *= clamp(1.0 / (total_distance - 1.0), 0.0, 1.0);\n  \n  frag_color = vec4(sRGB(col), 0.0);\n}\n","name":"Image","description":"","type":"image"}]}