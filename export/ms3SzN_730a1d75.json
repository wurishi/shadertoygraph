{"ver":"0.1","info":{"id":"ms3SzN","date":"1679457427","viewed":150,"name":"generative art cubemap","username":"lalaoopybee","description":"drag mouse around! this is my [url=https://www.shadertoy.com/view/ds3SzN]generative art shader[/url] in action.\nfirst try at what's been dubbed the  \"hill climbing algorithm\"?\ntrying to make actual random is not easy.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["procedural","generative","npr","hillclimb"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    fragColor=texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/XsjfDD\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //init image\n    vec2 mousePt=iMouse.xy;\n    if(iMouse.xy==vec2(0)) mousePt=vec2(.75, .5)*iResolution.xy;\n    \n    float rotX = (mousePt.x / iResolution.x) * 2. * PI;\n    float rotY = (mousePt.y / iResolution.y) * PI;\n    vec2 uv = 2.5 * (fragCoord.xy - .5 * iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));\n    vec3 camU = cross(camR,camD);\n   \tvec3 dir =  normalize(uv.x * camR + uv.y * camU + camD);\n    fragColor = texture(iChannel0, dir);\n    \n    //random noise prevents artifacting?\n    float noise=hash13(vec3(fragCoord, iTime))*.5+.5;\n    fragColor.rgb+=noise*.1;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415927\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3){\n\tp3=fract(p3*.1031);\n    p3+=dot(p3, p3.zyx+31.32);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nvec2 hash23(vec3 p3){\n\tp3=fract(p3 * vec3(.1031, .1030, .0973));\n    p3+=dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th){\n    float l=length(b-a);\n    vec2 d=(b-a)/l;\n    vec2 q=(p-(a+b)*.5);\n    q=mat2(d.x,-d.y,d.y,d.x)*q;\n    q=abs(q)-vec2(l,th)*.5;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//make structure tensor from partial derivative using sobel\nmat3 sobelX=mat3(\n    -1., 0., 1.,\n    -2., 0., 2.,\n    -1., 0., 1.\n);\n\nmat3 sobelY=mat3(\n    1., 2., 1.,\n    0., 0., 0.,\n    -1., -2., -1.\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n\n    vec3 gradX=vec3(0.);\n    vec3 gradY=vec3(0.);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            vec2 offsetUV=vec2(i-1, j-1)/iResolution.xy;\n            vec3 col=texture(iChannel0, uv+offsetUV).rgb;\n            gradX+=sobelX[i][j]*col;\n            gradY+=sobelY[i][j]*col;\n        }\n    }\n    gradX*=.25;\n    gradY*=.25;\n    \n    float e=dot(gradX, gradX);\n    float f=dot(gradX, gradY);\n    float g=dot(gradY, gradY);\n    fragColor=vec4(e, f, g, 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//blur structure tensor, calc eigenvectors. this is the etf.\n#define K 3\n#define SIGMA 1.8\n\nfloat gaussian(vec2 pos){\n    float left=1./(2.*PI*SIGMA*SIGMA);\n    float right=exp(-dot(pos, pos)/(2.*SIGMA*SIGMA));\n    return left*right;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 sum=vec4(0.);\n    for(int i=0;i<2*K+1;i++){\n        for(int j=0;j<2*K+1;j++){\n            vec2 offset=vec2(i-K, j-K);\n            float weight=gaussian(offset);\n            \n            vec2 offsetUV=offset/iResolution.xy;\n            vec3 efg=texture(iChannel0, uv+offsetUV).rgb;\n            sum+=vec4(efg, 1.)*weight;\n        }\n    }\n    vec3 efg=sum.rgb/sum.a;\n    \n    float e=efg.x, f=efg.y, g=efg.z;\n    float l1=(e+g+sqrt(pow(e-g, 2.)+4.*f*f))*.5;\n    vec2 eigen=vec2(l1-e, -f);\n    fragColor=vec4(-eigen.y, eigen.x, 0., 1.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//with help from zznewclear13\nvec2 strokeSize=vec2(3., 12.);\nfloat frequency=.1;//[0., 1.]\n\nvoid getStrokeColorAlpha(vec2 fragCoord, vec2 gridIndex, float gridSize, out vec3 color, out float alpha){\n    float randomNum=hash13(vec3(gridIndex, iFrame));\n    if(randomNum>=frequency){\n        color=vec3(1.);\n        alpha=0.;\n        return;\n    }\n    \n    vec2 randomGridOffset=hash23(vec3(gridIndex, iTime));\n    vec2 centerCoord=(gridIndex+randomGridOffset)*gridSize;\n    vec2 centerUV=centerCoord/iResolution.xy;\n    vec2 centerDir=textureLod(iChannel1, centerUV, 0.).rg;\n    color=textureLod(iChannel0, centerUV, 0.).rgb;\n    vec2 nDir=normalize(centerDir);\n    \n    vec2 p=fragCoord;\n    vec2 a=centerCoord+nDir*.5*strokeSize.y;\n    vec2 b=centerCoord-nDir*.5*strokeSize.y;\n    float th=strokeSize.x;\n    float sdBox=sdOrientedBox(p, a, b, th);\n    alpha=smoothstep(1.5, 0., sdBox);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    if(iFrame==0){\n        fragColor=texture(iChannel0, uv);\n        return;\n    }  \n    \n    //strokeSize*=iResolution.y/360.;\n    float gridSize=length(strokeSize+2.);\n    vec2 gridIndex=floor(fragCoord/gridSize);\n    \n    vec3 color=texture(iChannel2, uv).rgb; \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec3 strokeColor;\n            float strokeAlpha;\n            getStrokeColorAlpha(fragCoord, gridIndex+vec2(i, j), gridSize, strokeColor, strokeAlpha);\n            color=mix(color, strokeColor, strokeAlpha);       \n        }\n    }\n\n    fragColor=vec4(color, 1.);\n}","name":"Buffer D","description":"","type":"buffer"}]}