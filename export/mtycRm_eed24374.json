{"ver":"0.1","info":{"id":"mtycRm","date":"1700568266","viewed":39,"name":"JUMPJUMP","username":"DGMKPixy","description":"Tutorial of Iñigo Quiles.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["terrain","shaderart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 100\n#define MAX_RAY_MARCHING 20.0\n#define SPHERE_RADIUS 0.25\n\nfloat sdGuy( in vec3 pos )\n{\n    return length(pos) - SPHERE_RADIUS; // Creamos la esfera\n}\n\nfloat map( in vec3 pos)\n{\n    float d1 = sdGuy(pos);\n    float d2 = pos.y + SPHERE_RADIUS; // Creamos el suelo\n    \n    //Creamos un Cubo\n    //vec3 cubeSize = vec3(0.5,0.5,0.5);\n    //vec3 q = abs(pos) - cubeSize;\n    //float d3 = length(max(q, vec3(0.,0.,0.))) + min(max(max(q.x, q.y), q.z), 0.);\n    \n    return min(d1, d2); // Con lo que choquemos antes, lo devolvemos\n}\n\nvec3 GetNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(pos + e.xyy) - map(pos - e.xyy),\n                          map(pos + e.yxy) - map(pos - e.yxy),\n                          map(pos + e.yyx) - map(pos - e.yyx) ) );\n}\n\nfloat CastRayMarching(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    float t = 0.0;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        vec3 pos = rayOrigin + t*rayDirection; // Ecuación de la recta\n        float distanceTo = map(pos);\n        if(distanceTo < 0.) // Encontramos un punto\n            break;\n        t += distanceTo;\n        if( t > MAX_RAY_MARCHING) break;\n    }\n    \n    if(t > MAX_RAY_MARCHING) t = -1.;\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    float an = 10.*iMouse.x/iResolution.x; //iTime;\n\n    vec3 rayOrigin = vec3(1.*sin(an),0.,1.*cos(an)); // Camara trás de mi\n    \n    vec3 ta = vec3(0.);\n    vec3 ww = normalize( ta - rayOrigin );\n    vec3 uu = normalize( cross(ww, vec3(0., 1., 0.)) );\n    vec3 vv = normalize( cross(uu, ww));\n    vec3 rayDirection = normalize(p.x*uu + p.y*vv + 1.5*ww); // Apuntando hacia mi\n    \n    vec3 col = vec3(0.4, 0.75, 1.) - .7*rayDirection.y;\n    col = mix( col, vec3(.7,.75,.8), exp(-10.*rayDirection.y));\n    \n    float t = CastRayMarching(rayOrigin, rayDirection);\n    if (t > 0.) // Pasarán por aquí todos los puntos dentro de la esfera\n    {\n        vec3 pos = rayOrigin + t*rayDirection;\n        vec3 normal = GetNormal(pos);\n        \n        vec3 mate = vec3(0.2);\n        \n        //vec3 sunDirection = normalize(vec3(5. * cos(iTime), 5., 2.5* sin(iTime)));\n        vec3 sunDirection = normalize(vec3(0.8, 0.4, 0.2));\n        float sunShadow = step(CastRayMarching(pos+normal*0.001, sunDirection), 0.);\n        float sunDiff = clamp(dot(normal, sunDirection), 0.0, 1.0);\n        float skyDiff = clamp(0.5 + 0.5*dot(normal, vec3(0.,1.,0.)), 0.0, 1.0);\n        float bouDiff = clamp(0.5 + 0.5*dot(normal, vec3(0.,-1.,0.)), 0.0, 1.0); // Bounce light\n        \n        col = mate*vec3(7.0,5.0,3.0) * sunDiff * sunShadow;\n        col += mate*vec3(0.5,0.8,0.9) * skyDiff;\n        col += mate*vec3(0.7,0.3,0.2) * bouDiff;\n    }\n\n    col = applyGammaCorrection(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nfloat S(in float delta)\n{\n    return 3. * pow(delta, 2.) - 2. * pow(delta, 3.);\n}\n\nfloat N(in float x, in float z)\n{\n    //return a_ij + \n    //    (b_ij - a_ij) * S(x - i) +\n    //    (c_ij - a_ij) * S(z - j) +\n    //    (a_ij - b_ij - c_ij + d_ij) * S(x - i) * S(z - j);   \n    return 0.;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 applyGammaCorrection(in vec3 col)\n{\n    return pow( col, vec3(0.4545) );\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nvec3 doRotation(in vec3 pos, in float xAngle, in float yAngle, in float zAngle)\n{\n    return pos * rotateX(xAngle) * rotateY(yAngle) * rotateZ(zAngle);\n}","name":"Common","description":"","type":"common"}]}