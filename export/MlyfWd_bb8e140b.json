{"ver":"0.1","info":{"id":"MlyfWd","date":"1553066439","viewed":2998,"name":"SNN/Kuwahara Filter","username":"kam19_77","description":"Left -> Symmetric Nearest Neighbor Filter\nRight -> Kuwahara Filter","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["filter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int half_width = 5;\n\n// Calculate color distance\nfloat CalcDistance(in vec3 c0, in vec3 c1) {\n    vec3 sub = c0 - c1;\n    return dot(sub, sub);\n}\n\n// Symmetric Nearest Neighbor\nvec3 CalcSNN(in vec2 fragCoord) {\n\tvec2 src_size = iResolution.xy;\n    vec2 inv_src_size = 1.0f / src_size;\n    vec2 uv = fragCoord * inv_src_size;\n    \n    vec3 c0 = texture(iChannel0, uv).rgb;\n    \n    vec4 sum = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    \n    for (int i = 0; i <= half_width; ++i) {\n        vec3 c1 = texture(iChannel0, uv + vec2(+i, 0) * inv_src_size).rgb;\n        vec3 c2 = texture(iChannel0, uv + vec2(-i, 0) * inv_src_size).rgb;\n        \n        float d1 = CalcDistance(c1, c0);\n        float d2 = CalcDistance(c2, c0);\n        if (d1 < d2) {\n            sum.rgb += c1;\n        } else {\n            sum.rgb += c2;\n        }\n        sum.a += 1.0f;\n    }\n \tfor (int j = 1; j <= half_width; ++j) {\n    \tfor (int i = -half_width; i <= half_width; ++i) {\n            vec3 c1 = texture(iChannel0, uv + vec2(+i, +j) * inv_src_size).rgb;\n            vec3 c2 = texture(iChannel0, uv + vec2(-i, -j) * inv_src_size).rgb;\n            \n            float d1 = CalcDistance(c1, c0);\n            float d2 = CalcDistance(c2, c0);\n            if (d1 < d2) {\n            \tsum.rgb += c1;\n            } else {\n                sum.rgb += c2;\n            }\n            sum.a += 1.0f;\n\t\t}\n    }\n    return sum.rgb / sum.a;\n}\n\n// Kuwahara\nvec3 CalcKuwahara(in vec2 fragCoord) {\n    vec2 src_size = iResolution.xy;\n    vec2 inv_src_size = 1.0f / src_size;\n    vec2 uv = fragCoord * inv_src_size;\n    \n    float n = float((half_width + 1) * (half_width + 1));\n    float inv_n = 1.0f / n;\n    \n    vec3 col = vec3(0, 0, 0);\n    \n    float sigma2 = 0.0f;\n    float min_sigma = 100.0f;\n    \n    vec3 m = vec3(0, 0, 0);\n    vec3 s = vec3(0, 0, 0);\n    \n    \n    for (int j = -half_width; j <= 0; ++j) {\n        for (int i = -half_width; i <= 0; ++i) {\n            vec3 c = texture(iChannel0, uv + vec2(i, j) * inv_src_size).rgb;\n            m += c;\n            s += c * c;\n        }\n    }\n    \n    m *= inv_n;\n    s = abs(s * inv_n - m * m);\n    \n    sigma2 = s.x + s.y + s.z;\n    if (sigma2 < min_sigma) {\n        min_sigma = sigma2;\n        col = m;\n    }\n    \n    m = vec3(0, 0, 0);\n    s = vec3(0, 0, 0);\n    \n    for (int j = -half_width; j <= 0; ++j) {\n        for (int i = 0; i <= half_width; ++i) {\n            vec3 c = texture(iChannel0, uv + vec2(i, j) * inv_src_size).rgb;\n            m += c;\n            s += c * c;\n        }\n    }\n    \n    m *= inv_n;\n    s = abs(s * inv_n - m * m);\n    \n    sigma2 = s.x + s.y + s.z;\n    if (sigma2 < min_sigma) {\n        min_sigma = sigma2;\n        col = m;\n    }\n    \n    m = vec3(0, 0, 0);\n    s = vec3(0, 0, 0);\n    \n    for (int j = 0; j <= half_width; ++j) {\n        for (int i = 0; i <= half_width; ++i) {\n            vec3 c = texture(iChannel0, uv + vec2(i, j) * inv_src_size).rgb;\n            m += c;\n            s += c * c;\n        }\n    }\n    \n    m *= inv_n;\n    s = abs(s * inv_n - m * m);\n    \n    sigma2 = s.x + s.y + s.z;\n    if (sigma2 < min_sigma) {\n        min_sigma = sigma2;\n        col = m;\n    }\n    \n    m = vec3(0, 0, 0);\n    s = vec3(0, 0, 0);\n    \n    for (int j = 0; j <= half_width; ++j) {\n        for (int i = -half_width; i <= 0; ++i) {\n            vec3 c = texture(iChannel0, uv + vec2(i, j) * inv_src_size).rgb;\n            m += c;\n            s += c * c;\n        }\n    }\n    \n    m *= inv_n;\n    s = abs(s * inv_n - m * m);\n    \n    sigma2 = s.x + s.y + s.z;\n    if (sigma2 < min_sigma) {\n        min_sigma = sigma2;\n        col = m;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 inv_src_size = 1.0f / src_size;\n    vec2 uv = fragCoord * inv_src_size;\n    \n    float center = iMouse.x * inv_src_size.x;\n    float width = 3.0f * inv_src_size.x * 0.5f;\n    \n    if (uv.x <= center - width) {\n    \tfragColor.rgb = CalcSNN(fragCoord);\n    } else if (uv.x >= center + width) {\n        fragColor.rgb = CalcKuwahara(fragCoord);\n    } else {\n        fragColor.rgb = vec3(0, 0, 0);\n    }\n    \n    fragColor.a = 1.0f;\n}","name":"Image","description":"","type":"image"}]}