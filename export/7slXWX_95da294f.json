{"ver":"0.1","info":{"id":"7slXWX","date":"1619379914","viewed":94,"name":"472_raymarch_wip3","username":"asneakyfatcat","description":"continuing project to learn raymarching. Tried noise distortion but I haven't gotten it dialed in as noise makes everything look shit with a small epsilon value so maybe its due to float precision.","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["phong","raymarch","blinn","soundcloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llsSzB","filepath":"https://soundcloud.com/hospitalrecords/villem-alpha-rhythm-the-maker-1","previewfilepath":"https://soundcloud.com/hospitalrecords/villem-alpha-rhythm-the-maker-1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I would add more to this but it's turned into spaghetti code by this point.\n// With what I learned from this project it would be better to just start over\n// and design a new shader from the ground up(see lighting / material ID / camera clusterfuck)\n\n// todo: add texture mapping (triplanar mapping?)\n//       get noise distortion to be smooth\n//       find out how to dial in frequency range on sound texture\n//       add in more flight falloff. (turn down the absurd ammount of ambient light)\n\n\nconst int max_steps=255;\nconst float min_dist=0.;\nconst float max_dist=100.;\nconst float epsilon=0.0001;\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// unused, wanted to see if I could use structs in glsl/shadertoy\nstruct material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shine;\n};\n// primitive operations http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat intersect(float a,float b){\n    return max(a,b);\n}\nvec2 U(vec2 a,vec2 b){\n    if(a.x<b.x){return a;}\n    else return b;\n    //return vec2(min(a.x,b.x),a.y+b.y);\n}\nfloat difference(float a, float b){\n    return max(a,-b);\n}\n// smooth min https://www.shadertoy.com/view/MtdBzs\nvec2 sMin(vec2 a, vec2 b,float c){\n        float h = max(c-abs(a.x-b.x), 0.0);\n        vec2 t = vec2(0.);\n        if(a.x<b.x){t=a;}\n        else t=b;\n        return vec2(t.x - h*h*h/(6.0*c*c),t.y);\n}\n\n// SDF primitives https://iquilezles.org/articles/distfunctions\n\nfloat plane(vec3 p, vec3 n, float h){\n    return dot(p,normalize(n))+h;\n}\n\nfloat sphere(vec3 p,float r){\n    // point, radius\n    return length(p)-r;\n}\nfloat torus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat boxFrame( vec3 p, vec3 b, float e )\n{\n\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkers(vec2 p)\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec2 scene(vec3 p){\n    vec3 pp = p;\n    pp.y-=3.;\n    float theta=cos(iTime*.5);\n    pp*=mat3(vec3(cos(theta),0.,sin(theta)),vec3(0.,1.,0.),vec3(-sin(theta),0.,cos(theta)));\n    p.x=mod(p.x,5.)-2.5;\n    p.z=mod(p.z,5.)-2.5;\n    vec2 s; // second term is material id\n    s=vec2(sphere(p,1.),1.);\n    s.x=difference(s.x,octahedron(p,.5*cos(iTime)+1.));\n    //float warp=texture2D(iChannel1,cos(p.yy+iTime*.1));\n    //s+=warp*.7;\n    float t = torus(vec3(p.x,p.y+3.*cos(iTime),p.z),vec2(1.,.2));\n        s=sMin(s,vec2(t,s.y+2.),1.3);\n    float pln = plane(p,vec3(0.,1.,0.),1.);\n    s=U(vec2(pln,2.),s);\n    \n    \n    // x frequency, y current level? been a long time since I made a shader with sound idr\n    float sound = .9+.5*smoothstep(.5,1.,texture(iChannel0,vec2(.135,.05)).x);\n    float size = 1.*sound;\n    vec2 b = vec2(boxFrame(pp,vec3(size),.1),4.);\n    vec2 o = vec2(octahedron(pp,2.*size),4.);\n    vec2 sp = vec2(sphere(pp,.7*size*cos(iTime*.5)+.7*size),4.);\n    //o.x=difference(o.x,sp.x);\n    vec2 m = mix(b,o,.5*cos(iTime)+.5);\n    m.x=difference(m.x,sp.x);\n    //m.x+=texture2D(iChannel1,abs(vec2(sin(pp.z*1.),cos(pp.z*1.))))*1.;\n    s=U(m,s);\n\n    //return torus(p,vec2(1.,.2));\n    //return sphere(p,1.)+torus(p,vec2(1.,3.));\n    //s=U(plane(p,vec3(0,1.,0),1.),s);\n    return s;\n}\n\n// glulookat implementation\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml\n// from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// add function to calculate normals\n// uses tetrahedron gradient approximation voodoo bullshit technique\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p ){\n    const float h = epsilon;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ).x + \n                      k.yyx*scene( p + k.yyx*h ).x + \n                      k.yxy*scene( p + k.yxy*h ).x + \n                      k.xxx*scene( p + k.xxx*h ).x );\n}\n\n// return distance to surface\nvec2 toSurface(vec3 eye, vec3 dir, float start, float end){\n    float depth = start;\n    vec2 r = vec2(end,-1.);\n    for (int i=0; i<max_steps; i++){\n        vec2 dist = scene(eye+depth*dir);\n        if(dist.x<epsilon){\n            return vec2(depth,r.y);\n        }\n        depth += dist.x;\n        if(depth >= end){\n            return r;\n        }\n        r.y = dist.y;\n    }\n    return r;\n}\n\n// soft shadow function from https://iquilezles.org/articles/rmshadows\n// same as tosurface but with an extra line that computes penumbra by seing how close it is to hitting\n// i have no clue why I didn't just extend my toSurface function as I already had to extend it for material id\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = scene(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 rayDir(vec2 fragCoord, vec2 res, float fov){\n    vec2 xy = fragCoord.xy - res.xy/2.0;\n    // calculate z\n    float z = (res.x/2.)/tan(radians(fov)/2.);\n    return normalize(vec3(xy,z));\n}\n\n// color contrib from each light as there are no glsl arrays\nvec3 perLight(vec3 ambient, vec3 diffuse, vec3 specular, float shine, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity,float s, float matID){\n    vec3 n=normal(p);\n    vec3 ldir=lightPos-p;\n    float ldist=length(ldir);\n    \n    ldist=ldist*ldist;\n    ldir=normalize(ldir);\n\n    float lambertian = max(dot(ldir,n),0.);\n    float l=max(dot(-ldir,n),0.);\n    //float lambertian = clamp(dot(ldir, n),0.,1.);\n    float spec=0.0;\n    \n    float shadow=0.;\n    vec3 s_loc=p+n;\n    vec3 s_dir=ldir;\n    float dst=softshadow(s_loc,s_dir,min_dist,max_dist,30.);\n    \n    \n    if(dst<max_dist){\n        //shadow=dst/(max_dist-min_dist);\n        //return vec3(0.);\n        shadow=1.-dst;\n    }\n    // torus\n    if(matID==3.){\n        diffuse=checkers(p.zx)*vec3(.0,.5,.4);\n        ambient=vec3(.0,.5,.9)*.4;\n    }\n    // hovering thing\n    if(matID==4.){\n        diffuse=2.*vec3(.0,.2,.4);\n        ambient=vec3(.0,.5,.9)*.4;\n    }\n    // nvm \n    // couldn't get mat id working, set below certain y to checker for plane instead\n    // really wish I could start over with what I know now, this turned into spaghetti code\n    //if(p.y<=-.99){\n    //\n    //plane\n    if(matID==2.){\n        diffuse=checkers(p.zx)*vec3(.0,.2,.4);\n        ambient=vec3(.0,.5,.9)*.4;\n    }\n    \n    vec3 color = lightIntensity*diffuse*lambertian;\n        // ignore specular if camera light\n    if(s==0.){\n        return color;\n    }\n    \n    if(lambertian>0.){\n        vec3 vdir=normalize(eye-p);\n        vec3 hdir=normalize(ldir+vdir);\n        \n        spec=pow(max(dot(hdir,n),0.),shine);\n    }\n    color = (color+spec*specular)/ldist+ambient*lambertian*.5;\n    \n    return mix(color,color*.1,shadow);\n    //return shadow*color;\n    //return vec3(0.);\n}\n\nvec3 blinnPhong(vec3 ambient, vec3 diffuse, vec3 specular, float shine, vec3 point, vec3 eye,float matID){\n    // gave a bit of fake lambertian shading from the top direction to the ambient as well\n    //vec3 color=vec3(.05*ambient*max(dot(normal(point),vec3(0.,5.,-5.)),0.));\n    vec3 color=vec3(ambient*.00);\n    vec3 light0_pos=vec3(2.*cos(iTime),4.+sin(iTime*.25),-2.*sin(iTime));\n    vec3 intensity=vec3(2.9);\n    \n    color += perLight(ambient,diffuse,specular,shine,point,eye,light0_pos,intensity*2.,1.,matID);\n    light0_pos=eye;\n    //point=-1.*point;\n    color += perLight(ambient,diffuse,specular,shine,point,eye,light0_pos,vec3(.1),0.,matID);\n    //color += perLight(-2.*ambient,diffuse,vec3(0.),0.,point,eye,light0_pos*.4,vec3(1.));\n    return color;\n}\n\n// fog function from https://www.shadertoy.com/view/MtdBzs\nvec3 applyFog(vec3 rgb, float dist)\n{\n    vec3 fogColor = vec3(0.20, 0.3, 0.5);\n    //float startDist = mix(spectrum1.x*200.,30.,.5);\n    float startDist= 10.;\n    float fogAmount = 1.0 - exp(-(dist-8.0) * (1.0/startDist));\n    return mix(rgb, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // setup coord system 0,1\n    // convert from 0,1 to -1,1 to play nice with sin/cos\n    // fix aspect ratio\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv = uv*2.0 - 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(0.,2.,-7.);\n    vec3 dir = rayDir(fragCoord,iResolution.xy,120.);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.,3.,0.), vec3(0.0, 1.0, 0.0));\n    float theta=acos(-1.)+.8*cos(iTime*.2);\n    mat3 yrot=mat3(vec3(cos(theta),0.,sin(theta)),vec3(0.,1.,0.),vec3(-sin(theta),0.,cos(theta)));\n    vec3 worldDir = (viewToWorld*vec4(dir,0.)).xyz*yrot;\n    vec2 dist = toSurface(eye,worldDir,min_dist,max_dist);\n    vec3 p=eye+dist.x*worldDir;\n    vec3 color=vec3(0.);\n    //vec3 pN = normal(p);\n    \n    if(dist.x > (max_dist - epsilon)){\n        //texture(iChannel0,uv);\n        //color = texture(iChannel2,vec2(uv.x,uv.y,0.)).xyz;\n        color=vec3(0.);\n    }\n    else{\n    \n        //fragColor = vec4(0.,1.,1.,1.);\n        //fragColor = vec4(pN*.5+.5,1.);\n        // change this back from dist to steps before end of distance reached\n        float fake_distance_occlusion = (1.-(dist.x/max_dist));\n        color=fake_distance_occlusion*blinnPhong(vec3(0.,.6,.7),vec3(0.,.6,.7),vec3(2.),100.,p,eye,dist.y);\n        // gamma correction\n        color=pow(color,vec3(1./2.2));\n        //fragColor=vec4(color,1.);\n    }\n    color=applyFog(color,dist.x);\n    fragColor=vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}