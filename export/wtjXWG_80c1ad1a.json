{"ver":"0.1","info":{"id":"wtjXWG","date":"1566999902","viewed":106,"name":"cube anime v3-1","username":"jorge2017a1","description":"cube anime v3","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cubeanimev31"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created by BaconPapa in 2019-05-14\n//modificado por jorge2017a1 --2019-08-28\n\n\n#define ZOOM 1.5\n#define MAX_STEPS 100\n#define MIN_DISTANCE 0.0001\n#define MAX_DISTANCE 50.\nconst vec3 _lightPos = vec3(-2., 5., -1.);\nconst vec3 _lightPos2 = vec3(2., 5., 1.);\nconst vec3 _lightDir = vec3(0., -.5, 1.);\n\n//const vec3 _lightColor = vec3(.92, 0.85, 0.99);\n//const vec3 _lightColor = vec3(.92, 0.54, 0.79);\nconst vec3 _lightColor = vec3(.92, 0.8, 0.93);\n\n\nconst float _pointIntense = .3;\nconst float _parallelIntense = 0.4;\nconst float _shadowMin = .01;\nconst float _shadowMax = 50.;\nconst float _shadowIntense = 1.;\nconst float _sphereSmooth = .15;\nconst float _k = 15.;\n\nvec3 getRay(in vec3 ro, in vec3 lookAt, in vec2 uv) {\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    return normalize(uv.x * r + uv.y * u + f * ZOOM);\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat opSU ( float d1, float d2, float k ) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdf(in vec3 p) {\n    \n    //vec3 c1 = vec3(0., 1. + .25 * sin(4. * iTime) + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 c2 = vec3(0., .5 - .25 * sin(4. * iTime) + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 c3 = vec3(.25 * sin(2. * iTime), .75 + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 c4 = vec3(-.25 * sin(2. * iTime), .75 + 0.25 * sin(iTime * 4.), 0.);\n    //vec3 b = vec3(0., .75 + 0.25 * sin(iTime * 4.), 0.);\n    \n    \n    vec3 c1 = vec3(-1.0,1.0,-1.0);\n    vec3 c2 = vec3(2.0,1.0,0.0);\n    vec3 c3 = vec3(-2.0,1,-1.0);\n    vec3 c4 = vec3(1.0,0.5,-2);\n    vec3 b = vec3(0., .75 + 0.25 * sin(iTime * 4.), 0.);\n    \n    \n    float r = .5;\n    float sphere1 = sdSphere(p, c1, r);\n    float sphere2 = sdSphere(p, c2, r);\n    float sphere3 = sdSphere(p, c3, r);\n    float sphere4 = sdSphere(p, c4, r);\n    float plane = sdPlane(p);\n    float box = sdBox(b - p, vec3(.5, .5, .5)); \n    \n    \n    /*\n\tfloat d = opSU(sphere1, sphere2, _sphereSmooth);\n    d = opSU(d, sphere3, _sphereSmooth);\n    d = opSU(d, sphere4, _sphereSmooth);\n    d = opSS(d, box, .1);\n    d = opSU(d, plane, .8);\n    */\n    \n    float d;\n    d = min(sphere1, sphere2);\n    d = min(d, sphere3);\n    d = min(d, sphere4);\n    d = min(d, box);\n    d = min(d, plane);\n    \n    \n    return d;\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd) {\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i ++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdf(p);\n        dO += dS;\n        if(dS < MIN_DISTANCE || dO > MAX_DISTANCE) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(in vec3 p) {\n    float d = sdf(p);\n    vec2 e = vec2(MIN_DISTANCE, 0);\n    return normalize(vec3(\n        sdf(p + e.xyy) - d,\n        sdf(p + e.yxy) - d,\n        sdf(p + e.yyx) - d\n        ));\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0;\n    for(float h = mint;h<maxt;){\n        vec3 p = ro + rd * h;\n        float s = sdf(p);\n        h += s;\n        if (s <= MIN_DISTANCE) {\n            return 0.0;\n        }\n        res = min(res, k * s / h);\n    }\n    return res;\n}\n\nvec3 getLight(in vec3 p) {\n    vec3 n = getNormal(p);\n    vec3 ld = normalize(_lightPos - p);\n    vec3 ld2 = normalize(_lightPos2 - p);\n    float lParallel = clamp(dot(n, -_lightDir), 0., 1.) * _parallelIntense;\n    float lPoint = clamp(dot(n, ld), 0., 1.) * _pointIntense;\n    float lPoint2 = clamp(dot(n, ld2), 0., 1.) * _pointIntense;\n    lParallel = lParallel * pow(shadow(p, -_lightDir, _shadowMin, _shadowMax, _k), _shadowIntense);\n    lPoint = lPoint * pow(shadow(p, ld, _shadowMin, _shadowMax, _k), _shadowIntense);\n    lPoint2 = lPoint2 * pow(shadow(p, ld2, _shadowMin, _shadowMax, _k), _shadowIntense);\n    \n    //return (lPoint + lParallel + lPoint2) * _lightColor;\n    //return vec3(lPoint* _lightColor.x , lParallel* _lightColor.y , lPoint2* _lightColor.z) * _lightColor*2.0;\n     return vec3(lPoint* _lightColor.x , lParallel* _lightColor.y , lPoint2* _lightColor.z) * _lightColor*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(5. * sin(iTime / 2.), 4. , 5. * cos(iTime / 2.));\n    vec3 lookAt = vec3(0., .5, 0.);\n    vec3 col = vec3(0., 0., 0.);\n    vec3 rd = getRay(ro, lookAt, uv);\n\tfloat d = rayMarching(ro, rd);\n    vec3 p = ro + d * rd;\n    // Output to screen\n    fragColor = vec4(getLight(p), 1.);\n}","name":"Image","description":"","type":"image"}]}