{"ver":"0.1","info":{"id":"Wd3cRM","date":"1600677908","viewed":306,"name":"4DCube","username":"Fogrex","description":"4 dimention cube with ray marching.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["4dcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define saturate(a) clamp(a, 0.0, 1.0)\nvec4 LIGHT_VECTOR = normalize(vec4(1,1,1,1));\nconst float NEAR = 0.5;\nconst int STEP4 = 32;\nconst int STEP = 256;\nconst float minDist = 0.01;\n\n// rotation(xw, yz) oion 4D\nvec4 rotate4(vec4 p, float rot)\n{\n    mat4 r = mat4(\n        cos(-rot), 0.0, 0.0, -sin(-rot),\n        0.0,        1.0, 0.0, 0.0,\n        0.0,\t\t0.0, 1.0, 0.0,\n        sin(-rot), 0.0, 0.0, cos(-rot)\n    );\n\n    return (r * p);\n}\n\n//transform function(inverse)\nvec3 transform(vec3 pos, vec3 move, vec3 rot)\n{\n    vec4 p = vec4(pos - move, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\n// translate function(inverse)\nvec3 translate(vec3 pos, vec3 move)\n{\n   \n    return pos - move;\n}\n\n// rotation function(inverse)\nvec3 rotate(vec3 pos, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\n\n// 4D cube(0.6x0.6x0.6)(rotating)\nfloat map4(vec4 pos)\n{\n  vec4 p = rotate4(pos - vec4(0.0, 0.0, 0.0, 1.5), iTime * 1.3);\n  vec4 q = abs(p) - vec4(0.7);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z, q.w))),0.0);\n}\n\n// calculation normal in 4D\nvec4 calcNorm4(vec4 pos)\n{\n    vec2 d = vec2(0.0001, 0.0);\n    vec4 grad = vec4(\n        map4(pos+d.xyyy)-map4(pos-d.xyyy),\n        map4(pos+d.yxyy)-map4(pos-d.yxyy),\n        map4(pos+d.yyxy)-map4(pos-d.yyxy),\n        map4(pos+d.yyyx)-map4(pos-d.yyyx)\n    );\n    return normalize(grad);\n}\n\n// lighting with lambert in 4D\nfloat lighting4(vec4 pos)\n{\n    return saturate(dot(calcNorm4(pos), -LIGHT_VECTOR));\n}\n\n// raymarching in 4D\nvec4 raymarch4(vec3 origin)\n{\n    vec4 pos = vec4(0.0);\n    vec4 dir = normalize(vec4(origin, NEAR));\n    float val = 0.0;\n    \n    for(int i=0;i<STEP4;i++)\n    {\n     \tval = map4(pos);  \n        if(val < minDist)\n        {\n            return vec4(vec3(lighting4(pos)) * 0.9 + 0.1, 1.0);\n        }\n        pos += dir * val;\n    }\n    return vec4(0.0);\n}\n\n// 3D Cube(1x1x1)(rendering area)\nfloat box(vec3 p) {\n  vec3 q = abs(p) - vec3(1.0);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// raytracing\nvec4 raytracing(vec3 pos, vec3 dir)\n{\n    \n    vec4 col;\n    float d;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = max(box(pos), minDist);\n        pos += dir * d;\n        if(d > minDist) continue;\n        col = raymarch4(pos);\n        if(col.a != 0.0) return col;\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 fc = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(fc, NEAR));\n    vec3 pos = vec3(0.0);\n    \n    \n    // camera moving\n    pos = translate(pos, vec3(0.0,0.0,1.4));\n    \n    //camera rotating\n    float rx = (iMouse.x/iResolution.x*2.0 - 1.0) * PI;\n    float ry = (iMouse.y/iResolution.y*2.0 - 1.0) * PI * 0.5;\n    pos = rotate(pos, vec3(ry,-rx,0.0));\n    ray = rotate(ray, vec3(ry,-rx,0.0));\n    \n    \n    fragColor = raytracing(pos, ray);\n    //fragColor = texture(iChannel0, (fc * 0.5 + 0.5) * 0.5);\n}","name":"Image","description":"","type":"image"}]}