{"ver":"0.1","info":{"id":"NlXSWM","date":"1625742412","viewed":51,"name":"Raymarched Spheres experiment","username":"Trivaxy","description":"Learning raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITERS = 255;\nconst int SPHERES = 3;\nconst float PRECISION = 0.0001;\nconst float MAX_DEPTH = 15000.0;\nconst float FLOOR_LEVEL = -1.5;\nconst vec3 LIGHT_POS = vec3(0, 2, 2);\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n    vec3 color;\n};\n\nstruct RayMarchResult\n{\n    float depth;\n    Sphere sphere;\n    bool hitFloor;\n    bool inShadow;\n};\n\nstruct PosInfo\n{\n    float sceneDistance;\n    Sphere closest;\n};\n\nfloat sdSphere(vec3 pos, Sphere sphere)\n{\n    return length(pos - sphere.pos) - sphere.radius;\n}\n\nvec3 calcNormal(vec3 pos, Sphere sphere)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdSphere(pos + e.xyy, sphere) +\n      e.yyx * sdSphere(pos + e.yyx, sphere) +\n      e.yxy * sdSphere(pos + e.yxy, sphere) +\n      e.xxx * sdSphere(pos + e.xxx, sphere));\n}\n\nPosInfo distToScene(vec3 pos)\n{\n    Sphere spheres[SPHERES] = Sphere[]\n    (\n        Sphere(vec3(-0.25, 0, 2), 0.5, vec3(0.27, 0.27, 0.85)),\n        Sphere(vec3(-2.5, 0, 0), 0.8, vec3(0.89, 0.63, 0.23)),\n        Sphere(vec3(3, 1, -3), 2.0, vec3(0.8, 0.3, 0.5))\n    );\n    \n    for (int i = 0; i < SPHERES; i++)\n    {\n        spheres[i].pos.y += sin(iTime + float(i)) * (spheres[i].radius / 5.0);\n        spheres[i].pos.z += sin(iTime + float(i));\n    }\n    \n    PosInfo info;\n    info.sceneDistance = 100000.0;\n    \n    for (int i = 0; i < SPHERES; i++)\n    {\n        float dist = sdSphere(pos, spheres[i]);\n        if (dist < info.sceneDistance)\n        {\n            info.sceneDistance = dist;\n            info.closest = spheres[i];\n        }\n    }\n    \n    return info;\n}\n\nRayMarchResult rayMarch(vec3 ro, vec3 rd)\n{\n    RayMarchResult result;\n    \n    for (int i = 0; i < MAX_ITERS; i++)\n    {\n        vec3 rp = ro + rd * result.depth;\n        \n        PosInfo info = distToScene(rp);\n        result.depth += info.sceneDistance;\n        result.sphere = info.closest;\n        \n        // touches sphere or ray gone too far\n        if (info.sceneDistance < PRECISION || result.depth >= MAX_DEPTH)\n            break;\n            \n        // ray hit the floor, check if in shadow\n        if (rp.y <= FLOOR_LEVEL)\n        {\n            rp.y = FLOOR_LEVEL;\n            result.hitFloor = true;\n            \n            vec3 lightDir = normalize(LIGHT_POS - rp);\n            float distToLight = length(LIGHT_POS - rp);\n            \n            \n        }\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 cam = vec3(0, 1.0, 6); // camera position\n    vec3 rd = vec3(normalize(vec3(uv, -1))); // ray direction\n    vec3 col;\n    \n    RayMarchResult result = rayMarch(cam, rd);\n    vec3 pos = cam + rd * result.depth;\n    \n    if (result.hitFloor)\n    {\n        col = vec3(0.4, 0.4, 0.9);\n        if (result.inShadow)\n            col *= 0.2f;\n    }\n    else if (result.depth >= MAX_DEPTH)\n        col = vec3(0.7, 0.7, 1);\n    else\n    {\n        vec3 norm = calcNormal(pos, result.sphere);\n        vec3 lightDir = normalize(LIGHT_POS - pos);\n        float dif = clamp(dot(norm, lightDir), 0.2, 1.0);\n        col = vec3(dif) * result.sphere.color;\n    }\n        \n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}