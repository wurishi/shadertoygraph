{"ver":"0.1","info":{"id":"7dsfzl","date":"1645247050","viewed":109,"name":"ray-axis aligned box intersectio","username":"Envy24","description":"ray-axis aligned box intersection","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ray","intersection","box","mapping","spherical","inverse"],"hasliked":0,"parentid":"7lB3D1","parentname":"ray sphere intersection __"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BACKGROUND (vec4(normalize(1.0 - rayDir), 1.0))\n#define R iResolution\n\nfloat shootRayInAxisAlignedBox(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 boxSize,\n    inout vec3 outNormal)\n{\n\tvec3 m = vec3(1.0) / rayDir;\n\tvec3 n = m * ray;\n\tvec3 k = abs(m) * boxSize;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n    \n    vec3 yzx = vec3(t1.y, t1.z, t1.x);\n\tvec3 zxy = vec3(t1.z, t1.x, t1.y);\n    outNormal = -sign(rayDir) * step(yzx, t1) * step(zxy, t1);\n    \n\treturn (tN > tF || tF < 0.0) ?\n        -1.0 :        // no hit\n        min(tN, tF);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    /* Perspective camera with lookat (Blender). */\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n    camera = rotateAroundY(camera, iTime);\n    camera = rotateAroundX(camera, 0.4);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n    \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = R.x / R.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n\n\n    /* Ray tracing */\n    vec3 outNormal;\n    vec3 boxSize = vec3(sinOSC(0.1, 1.0, iTime), cosOSC(0.1, 1.0, iTime * 0.66), 1.0);\n    float t = shootRayInAxisAlignedBox(ray, rayDir, boxSize, outNormal);\n    /* Ray tracing */\n    \n    /* Shading */\n    vec4 color = \n        t >= 0.0 ?\n            //normalize(vec4(t,t,t,1.0)) :\n            //vec4(outNormal, 1.0) :\n            vec4((normalize(outNormal) + vec3(1.0)) * 0.5, 1.0) :\n            BACKGROUND;\n    /* Shading */\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/* Returns cosine modulated value in range [min, max]. */\nfloat cosOSC(in float min, in float max, in float T)\n{\n    float v = (cos(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}