{"ver":"0.1","info":{"id":"tlGyWR","date":"1610770708","viewed":153,"name":"kawaii empty bottle","username":"tono","description":"kawaii","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["kawaii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = acos(-1.);\nfloat w = 0.;\nfloat randomd = 0.;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n//https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat map(vec3 p)\n{\n    float t = floor(iTime) + pow(fract(iTime ),6.);\n    float t2 = floor(iTime /2.) + pow(fract(iTime /2.),6.);\n    randomd = pow( length( random( floor(p.yz/ (pi *2.) + pi * 2.)  + floor(iTime) ) ),3. )* 10.;\n   // if(randomd < 3.)return 1.;\n  // p.x = abs(p.x) - 5.5;\n   // p.yz= sin(p.yz) * 2.;\n   // p.x = sin(p.x) * 2.4;\n    p.xz *= rot(t * 2.);\n    float o = sdOctahedron(p,1.);\n    float shape = (clamp( sin(t * pi/2.) * 1. ,0.,1.));\n    float shape2= abs(sin(t2 * pi/2.) * 1.);\n    \n    o = mix(mix( sdRoundBox(p,vec3(.8),.1),length(p) - 1., shape ),o,shape2 );\n    return o;\n}\n\nfloat march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i< 66; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        float d = map(rp);\n        if(abs(d) < 0.01)\n        {\n            return depth;\n        }\n        depth += d;\n    }\n    depth *= -1.;\n    return depth;\n}\n\n\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat wmap(vec3 p)\n{\n    float t = floor(iTime) + pow(fract(iTime),6.);\n    float o = sin( (p.y + 0.1 ) * 2.) - ( cos(sin(t * 1.3) * 2.14) / 1.2 ) + .6;\n        p.xz *= rot(0.01);\n    \to -= simplex3d(p * 1.7 - t)/(9.) ;\n    o = max(map(p) , o);\n    return o;\n}\n\nfloat wmarch(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    float bdepth = 0.;\n    w = wmap(cp + rd * 0.01);\n    for(int i = 0;  i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        float d = wmap(rp);\n        //float bd = map(rp);\n        if(abs(d) < 0.01)\n        {\n            return depth;\n        }\n        depth += d;\n    }\n    return -depth;\n}\n\nfloat getWaterThickness(vec3 cp , vec3 rd)\n{\n    float thickness = 0.;\n    for(int i = 0; i < 44 ; i++)\n    {\n        vec3 rp = cp + rd * (thickness + 0.001);\n        float d = wmap(rp);\n        if(d < 0.)\n        {\n            return thickness;\n        }\n        thickness += d;\n    }\n    return thickness;\n}\n\n//https://qiita.com/keim_at_si/items/c2d1afd6443f3040e900\n\nvec3 hsv2rgb(float h, float s , float v)\n{\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float reresol = 40.;\n    p = floor(p * (reresol * iResolution.x/iResolution.y)) / (reresol * iResolution.x/iResolution.y);\n    float r = random( vec2(floor(iTime)/100.) );\n\tvec3 col = vec3(0.,0.5,1.);\n    //col = mix(hsv2rgb(r,r,1.),col,.8);\n    p.y *= -1.;\n    \n    vec3 forward = vec3(0.,0.,0.);\n    //forward.z += time;\n    vec3 cp = vec3(0.,1.,-5.) + forward;\n    \n    cp.y += sin(iTime);\n    vec3 target = vec3(0.) + forward;\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 4.;\n\tvec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    float d = march(cp,rd);\n    if(d > 0.)\n    {\n        col *= 0.;\n        vec2 e = vec2(0.,0.01);\n        vec3 pos = cp + rd * d;\n        vec3 N = -normalize(map(pos) - vec3(map(pos - e.xyy),map(pos - e.yxy),map(pos - e.yyx)));\n        float wd = wmarch(cp , rd);\n        \n        vec3 sun = normalize(-vec3(2.,4.,8.));\n        float wstep = 3.;\n        float bstep = 2.5;\n        float sp = 0.;\n        if(wd > 0. )\n        {\n        \tvec3 wpos = cp + rd * wd;\n            vec3 wN = normalize(wmap(wpos) - vec3(wmap(wpos - e.xyy),wmap(wpos - e.yxy),wmap(wpos - e.yyx)));\n            float sp2 = max(0.,dot(rd,reflect(wN,sun)));\n            float diff = max(0. , dot(N,sun)) * .7 + .3;\n            float thickness = getWaterThickness(wpos,rd);\n            float wrim = max(0.,1. - abs(dot(wN , rd)));\n            wrim =  pow(wrim,3.) * 1.1;\n            vec3 wcolor = hsv2rgb(r,r,1. ) * 2.;\n            sp2 = pow(sp2 , 2.) + .1;\n            col = floor( (sp2 * vec3(1.) + diff * wcolor + (thickness * 13.)) * wstep + wrim * vec3(1.)) / wstep;\n            //vec3(0.,.4,.9)\n        }\n        \n        //入れ物の色\n        sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,5.) / 2.;\n        float rim = max(0.,1. - abs(dot(N , rd)));\n        rim = pow(rim , 30.);\n        float diff = max(0. , dot(N,sun)) * .5 + .5;\n        col += step(length(col),0.1) * floor( (diff * vec3(0.8,0.4,1.) * 1.5 + rim * vec3(1.7) ) * bstep ) / bstep;\n        \n   \t\tfloat t = 1. - exp( -0.003 * d * d *d );\n    \tcol = mix(col,vec3(0.,0.5,1.),t);\n    }\n   // vec2 uv = fragCoord.xy / iResolution.xy;\n   // col = mix(texture2D(backbuffer,uv).rgb,col,.2);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}