{"ver":"0.1","info":{"id":"DdGfzt","date":"1698506345","viewed":48,"name":"Optimization: Momentum Method","username":"chronos","description":"Heavy ball / momentum method optimization method.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient","derivative","plot","optimization","numerical","descent","momentum"],"hasliked":0,"parentid":"DsGBRt","parentname":"Optimization: Gradient Descent"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat func(float x)\n{\n    return \n         .33*cos(x * PI + 0.4) +\n         .1*(.5 + 0.5 * sin(x * PI*8. + 0.4))\n         ;\n}\n\n\nfloat func_derivative(float x)\n{\n    return \n        -.33*sin(x * PI + 0.4) * PI\n        +\n        .1*(0.5 * cos(x * PI*8. + 0.4))* PI*8.\n        ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    if(length(iMouse.xy) < 10.) mouse = vec2(0.1, 0);\n\n    float pix_size = 2. / iResolution.y;\n    vec3 color = vec3(0);\n    \n    \n    float axes = .25 * smoothstep(1.5*pix_size, pix_size/2., min(abs(uv.x), abs(uv.y)) );\n    color = mix(color, vec3(1), axes);\n    \n    float X = uv.x;\n    float Y = func(X);\n    \n    \n    float d = distance(uv, vec2(X, Y));\n    float f = smoothstep(2. * pix_size, pix_size*.75, d);\n    \n    color = mix(color, vec3(1), f);\n    \n    \n    // tangent check\n    vec2 mousepoint = vec2(mouse.x, func(mouse.x));\n    float m = distance(mousepoint, uv);\n    float ma = smoothstep(5. * pix_size, pix_size*4., m);\n    \n    vec2 tangent = vec2(1., func_derivative(mouse.x));\n    \n    vec2 normal = normalize( vec2(1,-1) * tangent.yx );\n    \n    float tangent_dist = abs(dot((uv - mousepoint), normal));\n    float tangent_alpha = smoothstep(1.5 * pix_size, pix_size*1., tangent_dist) * .5;\n    tangent_alpha *= float(m < 1.);\n    color = mix(color, vec3(0,.5,.5), tangent_alpha);\n    color = mix(color, vec3(0,1,0), ma);\n    \n    \n    float momentum_decay_factor = 0.9;\n    \n    float r = 5. * pix_size;\n    int numsteps = 100;\n    float x = mouse.x;\n    float y = func(x);\n    float dydx = func_derivative(x);\n    float stepsize = 1./float(numsteps);\n    \n    float dw = 0.;\n    \n    for(int stp = 0; stp < numsteps; stp++)\n    {\n        float t = float(stp)/float(numsteps-1);\n        \n        float t_max = fract(iTime);\n        \n        if(t > t_max) break;\n        \n        vec3 particle_color = mix(vec3(0,0,1), vec3(0, 1, 0), t);\n        particle_color /= length(particle_color);\n        \n        vec2 pos = vec2(x, y);\n        float dist = distance(uv, pos);\n        float alpha = smoothstep(r+pix_size/2., r-pix_size/2., dist);\n        color = mix(color, particle_color, alpha);\n        \n        dw = momentum_decay_factor * dw - stepsize * dydx;\n        \n        x = x + dw;\n        \n        y = func(x);\n        dydx = func_derivative(x);\n    }\n    \n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}