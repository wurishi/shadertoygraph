{"ver":"0.1","info":{"id":"NldcD7","date":"1659958523","viewed":150,"name":"Black hole with ring simulation","username":"valena","description":"Hello there! I made a cool simulation of Black hole's gravitational lensing.\n\nThis algorithm is similar to raymarching, except rays travel by the constant step and turn to the side of black hole\n\nBecouse of constat step size, it is not thery efficient.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","space","blackhole","gravity","lensing"],"hasliked":0,"parentid":"sl3cWn","parentname":"Black hole with gravity lensing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color;\n    \n    color = texture(iChannel0, uv).rgb;\n    \n    color += vec3(0.5) * max(0.0, 1.0 - length(uv * 2.0 - 1.0)) * 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265\n\nuniform sampler2D u_skytex;\nuniform sampler2D u_ringtex;\n\nuniform vec2 u_resolution;\nuniform float u_cameraAngle;\nuniform vec3 u_cameraDir;\nuniform vec3 u_cameraPos;\n\nuniform float u_time;\n\nvec3 getColor2(vec2 coord)\n{\n\tvec3 c1 = vec3(129.0 / 255.0, 178.0 / 255.0, 1.0);\n\tvec3 c2 = vec3(1);\n\n\tfloat k1 = coord.y;\n\tfloat k2 = 1.0 - coord.y * 0.5;\n\n\treturn (c1 * k1 + c2 * (1.0 - k1)) * k2;\n}\n\nvec3 getRayDir(vec3 cameraDir, vec2 coord)\n{\n    float cameraAngle = PI / 2.0;\n\t//vec2 coord = ((gl_FragCoord.xy - u_resolution / 2.0) / u_resolution.y);\n\tvec3 xAxis = normalize(vec3(-cameraDir.z, 0, cameraDir.x)) * tan(cameraAngle / 2.0);\n\t//vec3 xAxis = vec3(0, 0, 1);\n\tvec3 yAxis = normalize(cross(cameraDir, xAxis)) * tan(cameraAngle / 2.0) * -1.0;\n\tvec3 result = normalize(cameraDir + xAxis * coord.x + yAxis * coord.y);\n\n\treturn (result);\n}\n\nfloat getRingDist(vec3 pos, vec3 ringSize)\n{\n\tvec3 center = normalize(pos);\n\tcenter.y = 0.0;\n\tcenter *= (ringSize.y + ringSize.x) / 2.0;\n\tvec3 d = pos - center;\n\tfloat ringW = (ringSize.y - ringSize.x) / 2.0 * 1.5;\n\n\tvec2 coord2d = vec2(length(vec2(d.x, d.z)), d.y);\n\n\tif (length(d) / ringW > 1.0)\n\t\treturn 1.0;\n\treturn length(coord2d / vec2(ringW, ringSize.z * 13.0));\n}\n\nvec3 traceTheRay(vec3 rayOPos, vec3 rayODir)\n{\n\tvec3 rayPos = rayOPos;\n\tvec3 rayDir = rayODir;\n\tint iter;\n\tint maxIter = 3000;\n\tfloat step = 0.25;\n\tfloat maxRange = 50.0;\n\n\tint suctionProbability = 0;\n\n\tfloat G = 1.5;\n\n\tvec3 ringSize = vec3(5, 20, 0.2);\n\n\tvec3 ringPos;\n\tbool touchedRing = false;\n\tfloat minRingDist = 1.0;\n\n\tfor (iter = 0; iter < maxIter; iter++)\n\t{\n\t\tfloat d = length(rayPos);\n\t\tfloat f = G / (d * d);\n\t\tfloat ringDist;\n\t\tvec3 norm = normalize(-rayPos);\n\n\t\trayDir = normalize(rayDir + norm * f * step);\n\n\t\trayPos += rayDir * step;\n\n\t\tif (!touchedRing && length(rayPos.xz) < ringSize.y && length(rayPos.xz) > ringSize.x && rayPos.y < ringSize.z && rayPos.y > -ringSize.z)\n\t\t{\n\t\t\ttouchedRing = true;\n\t\t\tringPos = rayPos;\n\t\t}\n\n\t\tringDist = getRingDist(rayPos, ringSize);\n\n\t\tif (ringDist < minRingDist)\n\t\t\tminRingDist = ringDist;\n\n\t\tif (length(rayPos) > maxRange)\n\t\t\tbreak;\n\n\t\tif (length(rayPos) < ringSize.x && \n\t\t\tlength(rayPos) < length(rayPos - rayDir * step) + 0.01)\n\t\t\tsuctionProbability++;\n\t\telse\n\t\t\tsuctionProbability = 0;\n\n\t\tif (suctionProbability >= 30)\n\t\t\tbreak;\n\t}\n\tif (touchedRing)\n\t{\n\t\tvec2 uv;\n\n\t\tuv.y = length((length(ringPos.xz) - ringSize.x) / (ringSize.y - ringSize.x));\n\t\tuv.x = 0.5 + atan(ringPos.x, ringPos.z) / (2.0 * PI);\n\t\t\n\t\tuv.x += u_time / 100.0 * PI;\n\n\t\tuv.x -= floor(uv.x);\n\n\t\treturn getColor2(uv) * minRingDist + vec3(1) * (1.0 - minRingDist);\n\t}\n\tif (length(rayPos) < 10.0)\n\t\treturn vec3(0);\n\treturn vec3(0.0) * minRingDist + vec3(1) * (1.0 - minRingDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camPitch = PI / 4.80;\n    float camYaw = 0.0;\n    float cameraDist = 35.0;\n    \n    camPitch += (iMouse.xy / iResolution.xy + 0.5).y * PI;\n    camYaw += (iMouse.xy / iResolution.xy + 0.5).x * PI * 2.0;\n    \n    vec3 cameraPos = cameraDist * vec3(cos(camYaw) * cos(camPitch), sin(camPitch), sin(camYaw) * cos(camPitch));\n    vec3 cameraDir = -normalize(cameraPos);\n    \n\tvec2 screenUV = ((fragCoord.xy - iResolution.xy / 2.0) / iResolution.y);\n\tvec3 rayDir = getRayDir(cameraDir, screenUV);\n\n\tfragColor = vec4(traceTheRay(cameraPos, rayDir), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}