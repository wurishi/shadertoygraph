{"ver":"0.1","info":{"id":"mlsSzl","date":"1675596857","viewed":99,"name":"Weichwolf - 08","username":"Weichwolf","description":"Raymarching procedural Terrain","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define F0(p) vec3( 1 , 1.- 2.*p)\n\nconst float MIN_DIST = 0.0001;\nconst float MAX_DIST = 200.;\nconst float EPSILON = .5;\nconst float SCALE = 0.02;\n\nfloat height(vec3 pos)\n{\n    pos.x = pos.x * SCALE;\n    pos.z = pos.z * SCALE - iTime * 0.02;\n    pos = fract(pos);\n\n    return texture(iChannel0, F0(pos.zx)).w * 3.;\n}\n\nfloat terrain( vec3 p, vec3 n)\n{\n    p.y -= height(p);\n    return dot(p,n);\n}\n\nfloat map(vec3 pos)\n{   \n    float p1 = terrain(pos, normalize(vec3(0.,1.,0.)));\n    \n\treturn p1;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n  }\n\t\nvec3 raydir(vec2 size, vec2 fragCoord) {\n    vec2 xy = size * -.5 + fragCoord;\n    return normalize(vec3(xy, -size.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 pos = vec3(.0, .5, 0.);\n   pos.y += height(pos);\t   \n   \n   vec3 dir = raydir(iResolution.xy, fragCoord);   \n   vec4 col = vec4(0.);\n   float depth = MIN_DIST;\n   float d = map(pos + dir * depth); \n   bool hit = true;\n          \n    while(d > depth * MIN_DIST)\n    {\t          \n       d = map(pos + dir * depth); \n\n       depth += d;\n\n       if(depth > MAX_DIST) {\n           hit = false;\n           break;\n       }\n    }   \n\n    vec3 lightDirection = normalize(vec3(0.5, 0.7, -1.0));\n\n    vec3 diffuse = max(dot(lightDirection, normal(pos + dir * depth)), 0.) * vec3(1.0, 0.9, 0.7);\n    vec3 ambient = vec3(0.3, 0.25, 0.2);\n\n    if (hit)\n       col = vec4(diffuse + ambient, 1.0);\n       //col = vec4(normal(pos + dir * depth), 1.0);\n    else \n       col = vec4(mix(vec3(1.0, 0.4, 0.1), vec3(1.0, 0.8, 0.3), dir.y), 1.0);       \n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define OCTAVES 11.\n#define hash(p) fract(sin(dot(vec2(p), vec2(0.4, 0.6))))\n#define hash2(p) fract(tan(dot(vec2(hash(p)), vec2(152.4, 262.6))))\n#define hash3(p) fract(atan(dot(vec2(hash2(p)), vec2(722.4, 522.6))))\n#define hash4(p) fract(sin(dot(vec2(hash3(p)), vec2(53234122.4, 44321622.6))))\n\nfloat map(vec2 fragCoord, float octave)\n{\n    fragCoord.x = mod(fragCoord.x,iResolution.x);\n    fragCoord.y = mod(fragCoord.y,iResolution.y);\n    \n    float scale = pow(2., octave);  \n    vec2 uv = fragCoord*scale/iResolution.xy;            \n    \n    vec2 uv11 = floor(uv); \n    vec2 uv12 = uv11;\n    vec2 uv21 = uv11;\n    vec2 uv22 = uv11;    \n\n    uv12.x = mod(uv12.x + 1., scale);\n    uv21.y = mod(uv21.y + 1., scale);\n    uv22.x = mod(uv22.x + 1., scale);\n    uv22.y = mod(uv22.y + 1., scale);\n\n    float h11 = hash4(uv11) / scale;\n    float h12 = hash4(uv12) / scale;\n    float h21 = hash4(uv21) / scale;\n    float h22 = hash4(uv22) / scale;    \n       \n    return mix(mix(h11, h12, fract(uv.x)), mix(h21, h22, fract(uv.x)), fract(uv.y));\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{       \n    if( iFrame>1 )\n    {\n        discard;\n    }\n        \n    float height;\n\n    for(float i = 2.; i<=OCTAVES; i++) {                  \n        height += map(fragCoord, i);    \n    }\n\n    fragColor = vec4(vec3(0.), smoothstep(0.0, 1.0, height * 3.));\n}\n ","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.28318530718*440.0*time));\n}\n\n","name":"Sound","description":"","type":"sound"}]}