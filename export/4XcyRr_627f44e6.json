{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// This shader applies a cubic spline filter to random colors\n// by blending the basis function weights between different\n// spline types. \n//\n// This allows us to smoothly blend between different interpolation\n// types, e.g. between any combination of\n//\n//     - Linear\n//     - C01 continuous cubic (Catmull-Rom)\n//     - C02 continuous cubic (See Common tab)\n//     - C12 continuous cubic (B-spline)\n//\n// This can be useful to gracefully fall back to a less\n// pathological variant which might under certain circumstances\n// result in some fairly nasty artifacts, like ringing patterns\n// from over and undershoots. \n//\n// This works because the basis functions are linear combinations\n// of their coefficients, which means that linear combinations of\n// basis functions are equivalent to linear combinations of filters\n//\n// Lower left:   Blend between Linear and 0th and 2nd order continous cubic splines\n// Lower middle: Blend between Linear and 0th and 1st order continous cubic splines\n// Lower right:  Blend between 0th and 1st order and 0th and 1st order continous cubic splines\n// Upper left:   Blend between Linear and 1st and 2nd order continous cubic splines\n// Upper middle: Blend between 0th and 2nd order and 1st and 2nd order continous cubic splines\n// Upper right:  Blend between 0th and 1st order and 1st and 1nd order continous cubic splines\n\n// http://www.jcgt.org/published/0009/03/02/\nvec3 pcg3d(ivec3 u) {\n    uvec3 v = uvec3(u) * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    \n    return vec3(v) / float(0xFFFFFFFFu);\n}\n\n// Helper function to sample the random colors, converted to RGB\nvec3 fi(vec2 p) {\n    return pcg3d(ivec3(floor(p), 4));\n}\n\n// Nearest interpolation\nvec3 fN(vec2 p) {\n    return fi(p);\n}\n\n// Cubic interpolation\nvec3 fC(vec2 p, mat4 C) {\n    vec2 i = floor(p-0.5);\n    vec2 f = fract(p-0.5);\n    \n    vec3 fmm = fi(i+vec2(-1, -1));\n    vec3 f0m = fi(i+vec2( 0, -1));\n    vec3 f1m = fi(i+vec2( 1, -1));\n    vec3 f2m = fi(i+vec2( 2, -1));\n    \n    vec3 fm0 = fi(i+vec2(-1,  0));\n    vec3 f00 = fi(i+vec2( 0,  0));\n    vec3 f10 = fi(i+vec2( 1,  0));\n    vec3 f20 = fi(i+vec2( 2,  0));\n\n    vec3 fm1 = fi(i+vec2(-1,  1));\n    vec3 f01 = fi(i+vec2( 0,  1));\n    vec3 f11 = fi(i+vec2( 1,  1));\n    vec3 f21 = fi(i+vec2( 2,  1));\n\n    vec3 fm2 = fi(i+vec2(-1,  2));\n    vec3 f02 = fi(i+vec2( 0,  2));\n    vec3 f12 = fi(i+vec2( 1,  2));\n    vec3 f22 = fi(i+vec2( 2,  2));\n    \n    vec2 cm = C[0][0]*f*f*f + C[0][1]*f*f + C[0][2]*f + C[0][3];\n    vec2 c0 = C[1][0]*f*f*f + C[1][1]*f*f + C[1][2]*f + C[1][3];\n    vec2 c1 = C[2][0]*f*f*f + C[2][1]*f*f + C[2][2]*f + C[2][3];\n    vec2 c2 = C[3][0]*f*f*f + C[3][1]*f*f + C[3][2]*f + C[3][3];\n    \n    vec3 fm = fmm*cm.x + f0m*c0.x + f1m*c1.x + f2m*c2.x;\n    vec3 f0 = fm0*cm.x + f00*c0.x + f10*c1.x + f20*c2.x;\n    vec3 f1 = fm1*cm.x + f01*c0.x + f11*c1.x + f21*c2.x;\n    vec3 f2 = fm2*cm.x + f02*c0.x + f12*c1.x + f22*c2.x;\n        \n    return fm*cm.y + f0*c0.y + f1*c1.y + f2*c2.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Split into 3x2 grid\n    vec2 r = iResolution.xy / vec2(3.0, 2.0);\n    vec2 i = floor(fragCoord.xy / r);\n    vec2 f = fragCoord.xy - i * r;\n    \n    vec2 p = (2.0*f - r.xy) / r.yy;\n    \n    // Zoom out a bit\n    p *= 4.0;\n    \n    // We only blend the weights whenever we click the mouse button\n    float t;\n    if (iMouse.z >= 0.0) t = iMouse.x / iResolution.x;\n        \n    // Blend the kernel weights\n    mat4 C;\n    if (i == vec2(0.0, 0.0)) C = L   * (1.0 - t) + C02 * t; // Lower left\n    if (i == vec2(1.0, 0.0)) C = L   * (1.0 - t) + C01 * t; // Lower middle\n    if (i == vec2(2.0, 0.0)) C = C02 * (1.0 - t) + C01 * t; // Lower right\n    if (i == vec2(0.0, 1.0)) C = L   * (1.0 - t) + C12 * t; // Upper left\n    if (i == vec2(1.0, 1.0)) C = C02 * (1.0 - t) + C12 * t; // Upper middle\n    if (i == vec2(2.0, 1.0)) C = C01 * (1.0 - t) + C12 * t; // Upper right\n   \n    // Blend the section-specific interpolations based on \n    // the horizontal mouse position if the left mouse button \n    // is clicked. Otherwise revert to nearest. \n    if (iMouse.z >= 0.0) {\n        fragColor = vec4(fC(p, C), 1.0);\n    } else {\n        fragColor = vec4(fN(p), 1.0);\n    }\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0 / 2.2));\n    \n    // Borders\n    if (any(lessThanEqual(f, vec2(1.5)))) fragColor.xyz = vec3(0.0);\n    if (any(greaterThanEqual(fragCoord.xy, iResolution.xy-1.5))) fragColor.xyz = vec3(0.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/*\n    We want to generate a piecewise cubic curve \n    \n        y(t) = B_{-1}(t) y_{-1} + B_{0}(t) y_{0} + B_{1}(t) y_{1} + B_{1}(t) y_{1}\n    \n    where the basis functions\n    \n        B_{i}(t) = a_{i} t^3 + b_{i} t^2 + c_{i} t + d_{i}\n        \n    combined with a interpolation parameter 0<=t<=1 reconstructs the controls \n    points y_i based on some constraints which then determine the basis function\n    coefficients a_i, b_i, c_i and d_i. \n    \n    Specifically, the constraints are typically imposed on a combination of the \n    function itself, its first derivative, and its second derivative. \n    \n    In the matrices below each (visual) row represent a, b, c and d \n    for B_{-1}, B_{0}, B_{1} and B_{2}, respectively. \n    \n    In practice you can choose between preserving two out of three out of the\n    0th, 1st and 2nd order derivatives at the piecewise curve segments, each\n    with its own set of compromises.\n    \n*/\n\n// Linear interpolation \"spline\"\n//\n// See basis functions: https://www.wolframalpha.com/input?i=plot+0%2C+1-t%2C+t%2C+0%2C+from+0+to+1\n//\n// This is a special case where most of the basis function\n// coefficients are zero to make it easier to blend between a \n// linear interpolation and a cubic interpolation. \n//\n// Technically you could formulate it as two additions constraints \n// on the second derivative, which gives us our four constraints\n// and have this pop out as a solution:\n//\n//     y(0)   = y_0\n//     y(1)   = y_1\n//     y''(0) = 0\n//     y''(1) = 0\n//\nconst mat4 L = mat4(\n     0.0,  0.0,  0.0, 0.0,\n     0.0,  0.0, -1.0, 1.0, \n     0.0,  0.0,  1.0, 0.0, \n     0.0,  0.0,  0.0, 0.0\n);\n\n// Cubic Spline interpolation spline with continuous 0th and 2nd order derivatives, \n// but not 1st order.\n//\n// See basis functions: https://www.wolframalpha.com/input?i=plot+-1%2F6*t%5E3+%2B++3%2F6*t%5E2+%2B+-2%2F6*t+%2B+0%2F6%2C++3%2F6*t%5E3+%2B+-6%2F6*t%5E2+%2B+-3%2F6*t+%2B+6%2F6%2C++-3%2F6*t%5E3+%2B++3%2F6*t%5E2+%2B++6%2F6*t+%2B+0%2F6%2C++1%2F6*t%5E3+%2B++0%2F6*t%5E2+%2B+-1%2F6*t+%2B+0%2F6%2C+from+0+to+1\n// Alternative: https://www.wolframalpha.com/input?i=plot+++-1%2F6*%28t-0%29*%28t-1%29*%28t-2%29%2C++3%2F6*%281%2Bt%29*%28t-1%29*%28t-2%29%2C+-3%2F6*%281%2Bt%29*%28t-0%29*%28t-2%29%2C++1%2F6*%281%2Bt%29*%28t-0%29*%28t-1%29%2C+from+0+to+1\n//\n// As far as I can tell this one doesn't have an established name.\n// \n// This is an interesting cubic spline because it's not as smooth as \n// a Catmull-Rom spline (defined below), but it's not as bent as the\n// linear interpolation. It also overshoots slightly less than the \n// Catmull-Rom spline, which causes slightly less ringing artifacts. \n//\n// There's two equivalent constraints for this particular spline interpolation:\n//\n//     y(-1) = y_{-1}\n//     y( 0) = y_{ 0}\n//     y(+1) = y_{+1}\n//     y(+2) = y_{+2}\n//\n// and \n//\n//     y(0)   = y_{ 0}\n//     y(1)   = y_{+1}\n//     y''(0) = y_{-1} + 2y_{ 0} - y_{+1}\n//     y''(1) = y_{ 0} + 2y_{+1} - y_{+2}\n// \n// The first formulation requires that all control points are recoverable from \n// the interpolation itself, which in practice means that any cubic function can \n// be exactly resampled under translation.\n// \n// The second formulation requires that the values are continous at the edge of\n// the interpolation region as well as the discretized derivative using the \n// control points. \n//\nconst mat4 C02 = mat4(\n    -1.0/6.0,  3.0/6.0, -2.0/6.0, 0.0/6.0, \n     3.0/6.0, -6.0/6.0, -3.0/6.0, 6.0/6.0, \n    -3.0/6.0,  3.0/6.0,  6.0/6.0, 0.0/6.0, \n     1.0/6.0,  0.0/6.0, -1.0/6.0, 0.0/6.0\n);\n\n// Catmull-Rom spline with continous 0th and 1st order derivatives\n//\n// See basis functions: https://www.wolframalpha.com/input?i=plot++-1%2F2*t%5E3%2B+2%2F2*t%5E2-1%2F2*t%2B0%2F2%2C++3%2F2*t%5E3-5%2F2*t%5E2%2B+0%2F2*t%2B2%2F2%2C+-3%2F2*t%5E3%2B+4%2F2*t%5E2%2B+1%2F2*t%2B0%2F2%2C++1%2F2*t%5E3-1%2F2*t%5E2%2B+0%2F2*t%2B0%2F2%2C+from+0+to+1\n//\n// This is typically the canonical cubic interpolation spline, which is\n// constructed to give a smooth result, meaning the 1st order derivatives \n// are continous across piecewise splines. \n// \n// A consequence of this is that the 2nd order derivatives are discontinous,\n// and there's quite consequential overshoot potential. \n//\n// The constraints here are\n// \n//     y(0)   = y_{ 0}\n//     y(1)   = y_{+1}\n//     y'(0) = (y_{-1} - y_{-1}) / 2\n//     y'(1) = (y_{+2} - y_{ 0}) / 2\n//\nconst mat4 C01 = mat4(\n    -1.0/2.0,  2.0/2.0, -1.0/2.0, 0.0/2.0,\n     3.0/2.0, -5.0/2.0,  0.0/2.0, 2.0/2.0,\n    -3.0/2.0,  4.0/2.0,  1.0/2.0, 0.0/2.0,\n     1.0/2.0, -1.0/2.0,  0.0/2.0, 0.0/2.0\n);\n\n// Cubic B-spline with continous 1st and 2nd order derivatives\n//\n// See basis functions: https://www.wolframalpha.com/input?i=plot++-1%2F6*t%5E3%2B3%2F6*t%5E2-3%2F6*t%2B1%2F6%2C++3%2F6*t%5E3-6%2F6*t%5E2%2B0%2F6*t%2B4%2F6%2C++-3%2F6*t%5E3%2B3%2F6*t%5E2%2B3%2F6*t%2B1%2F6%2C++1%2F6*t%5E3%2B0%2F6*t%5E2%2B0%2F6*t%2B0%2F6%2C+from+0+to+1\n//\n// This variant results in a curve that does not reproduce the \n// control points, but instead it's much smoother than the other \n// variants mentioned above. \n//\n// The constraints are\n//\n//     y'(0)  = (y_{-1} - y_{-1}) / 2\n//     y'(1)  = (y_{+2} - y_{ 0}) / 2\n//     y''(0) = y_{-1} + 2y_{ 0} - y_{+1}\n//     y''(1) = y_{ 0} + 2y_{+1} - y_{+2}\n//\n// with an additional constraints of \n//\n//     B_{-1}(0) = 0\n//     B_{-1}(1) = 0\n//     B_{+2}(0) = 0\n//     B_{+2}(1) = 0\n// \n// to make sure that y(1) of the left segment is the same as y(0) of \n// the right segment and vice versa. \nconst mat4 C12 = mat4(\n    -1.0/6.0,  3.0/6.0, -3.0/6.0, 1.0/6.0, \n     3.0/6.0, -6.0/6.0,  0.0/6.0, 4.0/6.0, \n    -3.0/6.0,  3.0/6.0,  3.0/6.0, 1.0/6.0, \n     1.0/6.0,  0.0/6.0,  0.0/6.0, 0.0/6.0\n);","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4XcyRr","date":"1734620832","viewed":187,"name":"Interpolating interpolations","username":"mv","description":"Left click and move horizontally to blend between different interpolations\n","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["blending","interpolation","splines"],"hasliked":0,"parentid":"","parentname":""}}