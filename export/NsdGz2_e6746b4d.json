{"ver":"0.1","info":{"id":"NsdGz2","date":"1630236199","viewed":317,"name":"Phasor noise","username":"xavierchermain","description":"My implementation of Procedural Phasor Noise (Tricard et al. 2019): https://hal.inria.fr/hal-02118508","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","phasor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////\n# define PI 3.141592\n# define TWO_PI 6.283185\n//! Maximum value for a 32 bit unsigned integer\n# define MAXUINT 0xffffffffu\n\n//! Ordinary frequency (measured in hertz)\n# define FREQUENCY 50.\n//! Orientation of the main frequency direction\n# define ORIENTATION 0.\n//! The cell size defined in the normalized texture space [0, 1]^2\n# define CELL_SIZE 0.061075\n//! The number of impulses per cell\n# define N_IMPULSES 16\n//! Seed of the pseudo random number generator\n# define SEED 1\n\n//! To choose the profile of the noise\n# define PROFILE_SINE\n// # define PROFILE_SAWTOOTH\n// # define PROFILE_SQUARE\n// # define PROFILE_NONE\n\n//! To see the grid\n// # define GRID\n//! See the content of the cells without it being mixed with the content of\n//! neighboring cells\n// # define VIEW_CELL_CONTENT\n\n//! Hash function with 2D input and 2D output.\n//! See Hash Functions for GPU Rendering by Jarzynski and Olano\n//! JCGT 2020\n//! Paper: http://jcgt.org/published/0009/03/02/\n//! Shadertoy: https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n/*! Returns the probability density function (PDF) of a centered Gaussian\n    with standard deviation std_dev\n    \\param p The position of evaluation\n    \\param std_dev The standard deviation of the Gaussian*/\nfloat gaussian_pdf_2d(const vec2 p, const float std_dev)\n{\n    float std_dev_sqr = std_dev * std_dev;\n    // 1. / TWO_PI \\approx 0.1591549\n    return 0.1591549 / std_dev_sqr * exp(-0.5 * dot(p, p) / std_dev_sqr);\n}\n\n/*! Gives the instantaneous phase\n    \\param p The position for evaluation\n    \\param omega The angular frequency\n    \\param u The main direction of the frequency\n    \\param phase The initial phase */\nfloat instantaneous_phase(const vec2 p, const float omega, const vec2 u, \n                          const float phase){\n    return omega * dot(p, u) + phase;\n}\n\n/*! Gives the phasor at 2D position p. A phasor is defined for a position \n    p, an angular frequency omega along direction u and a phase.\n    Source: https://en.wikipedia.org/wiki/Phasor,\n            https://en.wikipedia.org/wiki/Angular_frequency and\n            https://hal.archives-ouvertes.fr/hal-02118508/document\n    \\param p The position for evaluation\n    \\param omega The angular frequency\n    \\param u The main direction of the frequency\n    \\param phase The initial phase\n    \\param std_dev The standard deviation of the Gaussian */\nvec2 phasor(vec2 p, float omega, vec2 u, float phase, float std_dev)\n{\n    float instantaneous_phase_v =\n        instantaneous_phase(p, omega, u, phase);\n    return gaussian_pdf_2d(p, std_dev) * vec2(cos(instantaneous_phase_v),\n                                              sin(instantaneous_phase_v));\n}\n\n/*! Gives the sum of phasors with ordinary frequency f, in a cell, for a\n    position p into the cell.\n    \\param cell_index_2d The 2D cell index\n    \\param p The position in the current cell space\n    \\param f The ordinary frequency\n*/\nvec2 phasors_in_cell(const ivec2 cell_index_2d, const vec2 p, const float f)\n{\n    // Hash function input. Use the cell index.\n    uvec2 hash_input = uvec2(cell_index_2d + SEED);\n\tvec2 sum_of_phasors = vec2(0.0);\n    // The kernel envelop is a gaussian. Its maximum range is one cell,\n    // which enables us to cover only the direct neighboring cells.\n    const float std_dev = CELL_SIZE / 3.;\n    // Add N_IMPULSES into the cell\n\tfor(int i = 0; i < N_IMPULSES; ++i){\n        // Get a random position in the cell. It will be the impulse \n        // position. In unsigned normalized space [0, 1]^2\n        vec2 impulse_position = vec2(pcg2d(hash_input)) / float(MAXUINT);\n        // Distance between p and the impulse position, scaled by CELL_SIZE\n\t\tvec2 distance_p_impulse = (p - impulse_position) * CELL_SIZE;\n        // The random position of the impulse implies that the phase is\n        // random. So it is fixed to zero.\n\t\tsum_of_phasors += phasor(distance_p_impulse, f * TWO_PI,\n            vec2(cos(ORIENTATION), sin(ORIENTATION)), 0., std_dev);\n        // Offset hash input\n        hash_input.x += 227u;\n        hash_input.y += 13u;\n\t}\n\treturn sum_of_phasors;\n}\n\n/*! Evaluate the phasor noise \n    \\param uv Surface position\n    \\param f The ordinary frequency */\nvec2 phasor_noise(vec2 uv, float f)\n{   \n    // uv in the grid space\n\tvec2 uv_grid = uv / CELL_SIZE;\n    // Integer part\n\tivec2 cell_index_2d = ivec2(uv_grid);\n    // Fractional part\n\tvec2  distance_grid = uv_grid - vec2(cell_index_2d);\n\tvec2 noise = vec2(0.0);\n    # ifdef VIEW_CELL_CONTENT\n        noise = phasors_in_cell(cell_index_2d, distance_grid, f);\n    # else\n        // Go through the neighboring direct cells\n        for (int j = -1; j <= 1; j++) {\n            for (int i = -1; i <= 1; i++) {\n                noise += phasors_in_cell(cell_index_2d + ivec2(i, j),\n                                         distance_grid - vec2(i, j),\n                                         f);\n            }\n        }\n    # endif\n    return noise;\n}\n\n/*! Rectangular wave\n    \\param x Input (real value)\n    \\param r % black */\nfloat rectangular_wave(float x, float r)\n{\n\treturn mod(x, TWO_PI) > TWO_PI * r ? 1.0 : 0.0;\n}\n\nfloat sawtooth_wave(float x)\n{\n\treturn mod(x, TWO_PI) / TWO_PI;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Surface coordinate in normalized space \n    vec2 uv = fragCoord / iResolution.y;\n    // Get the phasor at uv\n    vec2 phasor_noise_v = phasor_noise(uv, FREQUENCY);\n    // Phase of the phasor (Eq. 9, Tricard et al. 2019)\n    // Polar angle of the vector phasor_noise_v\n    float phase = atan(phasor_noise_v.y, phasor_noise_v.x);\n    // Profile synthesis\n    # ifdef PROFILE_SQUARE\n        vec3 phasor_noise_profile = vec3(rectangular_wave(phase, 0.5));\n    # endif\n    # ifdef PROFILE_SAWTOOTH\n        vec3 phasor_noise_profile = vec3(sawtooth_wave(phase));\n    # endif\n    # ifdef PROFILE_SINE\n        vec3 phasor_noise_profile = vec3((sin(phase) + 1.) * 0.5);\n    # endif\n    # ifdef PROFILE_NONE\n        vec3 phasor_noise_profile = vec3((phase + PI) / TWO_PI);\n    # endif\n    \n    fragColor = vec4(phasor_noise_profile, 1.0);\n    \n    #ifdef GRID\n        // Calculates the distance in x and y with the edge on the left and\n        // bottom, respectively (in the cell space).\n        vec2 distance_grid = fract(uv / CELL_SIZE);\n        // Blackened 10 % in x and y of the cells\n        fragColor *= step( 0.1, distance_grid.x);\n        fragColor *= step( 0.1, distance_grid.y);\n    #endif\n}\n","name":"Image","description":"","type":"image"}]}