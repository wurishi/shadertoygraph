{"ver":"0.1","info":{"id":"7sfGWM","date":"1657243739","viewed":90,"name":"ly180_8) final","username":"jckl","description":"final\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"7dXGWM","parentname":"ly180_6) final"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.001\n\n// BEGIN RAND GEN FROM GEEKSCODE: \n// https://www.geeks3d.com/20100831/shader-library-noise-and-pseudo-random-number-generator-in-glsl/ \nint LFSR_Rand_Gen(in int n)\n{\n  // <<, ^ and & require GL_EXT_gpu_shader4.\n  n = (n << 13) ^ n; \n  return (n * (n*n*15731+789221) + 1376312589) & 0x7fffffff;\n}\n\nfloat LFSR_Rand_Gen_f( in int n )\n{\n  return float(LFSR_Rand_Gen(n));\n}\n\n\nfloat noise3f(in vec3 p)\n{\n  ivec3 ip = ivec3(floor(p));\n  vec3 u = fract(p);\n  u = u*u*(3.0-2.0*u);\n\n  int n = ip.x + ip.y*57 + ip.z*113;\n\n  float res = mix(mix(mix(LFSR_Rand_Gen_f(n+(0+57*0+113*0)),\n                          LFSR_Rand_Gen_f(n+(1+57*0+113*0)),u.x),\n                      mix(LFSR_Rand_Gen_f(n+(0+57*1+113*0)),\n                          LFSR_Rand_Gen_f(n+(1+57*1+113*0)),u.x),u.y),\n                 mix(mix(LFSR_Rand_Gen_f(n+(0+57*0+113*1)),\n                          LFSR_Rand_Gen_f(n+(1+57*0+113*1)),u.x),\n                      mix(LFSR_Rand_Gen_f(n+(0+57*1+113*1)),\n                          LFSR_Rand_Gen_f(n+(1+57*1+113*1)),u.x),u.y),u.z);\n\n  return 1.0 - res*(1.0/1073741824.0);\n}\n// END RAND GEN FROM GEEKSCODE\n\n\n\nfloat sdf_sphere(vec3 p) {\n    return length(p) - 1.; \n}\n\nfloat sdf_sphere(vec3 p, float r) {\n    return length(p) - r; \n}\n\nfloat sdf_planez(vec3 p) {\n    return -p.z;\n}\n\nfloat sdf_planey(vec3 p) {\n    return -p.y;\n}\n\nfloat sdf_planex(vec3 p) {\n    return -p.x;\n}\n\nfloat sdf_cyly(vec3 p, float r, float distort) {\n    return pow(length(vec2(sdf_planex(p), sdf_planez(p)))-r,distort);\n}\n\nfloat sdf_cylx(vec3 p, float r, float distort) {\n    return pow(length(vec2(sdf_planey(p), sdf_planez(p)))-r,distort);\n}\n\nfloat sdf_cylz(vec3 p, float r, float distort) {\n    return pow(length(vec2(sdf_planey(p), sdf_planex(p)))-r,distort);\n}\n\nfloat sdf_spiral(vec3 p) {\n    return dot(sin(p*9.), cos(p.zxy*9.))*.1;\n}\nfloat sdf_gyroid(vec3 p, float c1) //0.8 is good\n{\n    return abs(sin(p.x)*cos(p.y) + sin(p.y)*cos(p.z)+sin(p.z)*cos(p.x))/c1;\n}\n\nvec3 to_catenoid(vec3 p) {\n    return vec3(cos(p.y) * cosh(p.x), sin(p.y)*cosh(p.x), sin(p.z)*cosh(p.x));\n}\n\nvec3 to_catenoid_var(vec3 p) {\n    return vec3(p.z * cos(p.y) * cosh(p.x/p.z), p.z*sin(p.y)*cosh(p.x/p.z), p.y);\n}\n\nvec3 to_helicoid(vec3 p) {\n    return vec3(sin(p.y) * sinh(p.x), -1.*cos(p.y)*sinh(p.x), p.y);\n}\n\nvec3 to_bonnet(vec3 p, float g) {\n\n    return cos(g)*to_catenoid(p) + sin(g)*to_helicoid(p);\n}\n\nfloat sdf_shape1(vec3 p, float c1, float c2, float c3) {\n return length(vec2(\n                    sdf_cyly(p, c1,0.8), \n                    sdf_cylx(p, c2,0.8))\n               )-c3;\n}\n\nfloat sdf_shape2(vec3 p, float lfo1, float lfo2, float noise) {\n     return length(vec4(\n                            sdf_gyroid(p,0.8), \n                            sdf_shape1(p,3.2,1.2 + lfo1,0.007), \n                            sdf_gyroid(p*(((sin(iTime * noise * 0.01)+1.)*p)), 0.8),\n                            sdf_shape1(p,3.2,1.2 + lfo2 ,0.007)\n                         )\n                    )-8.;\n}\n\nvec4 rotate_translate(vec4 p, vec3 r, vec3 t) {\n    float cos_a = cos(r.x);\n    float cos_b = cos(r.y);\n    float cos_c = cos(r.z);\n    \n    float sin_a = sin(r.x);\n    float sin_b = sin(r.y);\n    float sin_c = sin(r.z);\n    \n    mat4 m = mat4(\n            vec4(cos_a*cos_b,sin_a*cos_b,-sin_b,0.),\n            vec4(cos_a*sin_b*sin_c-sin_a*cos_c,sin_a*sin_b*sin_c+cos_a*cos_c,cos_b*sin_c,0.),\n            vec4(cos_a*sin_b*cos_c-sin_a*sin_c,sin_a*sin_b*cos_c+cos_a*sin_c,cos_b*cos_c,0.),\n            vec4(t.x,t.y,t.z,1.)\n         );\n     \n     return m*p;\n              \n\n}\n\n\n\n\n// COMPOSING SIGNED DISTANCE FUNCTIONS FOR RAY MARCHING\n// BOUNDLESS AND UNBOUNDED GEOMETRIES\n// JACK KILGORE CS180 DEMO \nfloat scene_dist (vec3 p) {\n    float d = 0.;\n    float lfo1 = sin(iTime)+1.;\n    float lfo2 = cos(iTime)+1.;\n    \n    vec3 rotate = vec3(iTime*0.3,iTime *0.3,0.);\n    p = rotate_translate(vec4(p.x,p.y,p.z,0.),rotate,vec3(0.)).xyz; \n    \n    // MAP POINT ONTO A CATANOID-LIKE SURFACE\n    // NON-EUCLIDEAN SPACE NOW\n    //p = to_bonnet(p,1.24);\n\n    \n    //2 RING\n    float prim4 = sdf_shape1(p,0.7+lfo1,0.7+lfo1,0.3+lfo2);\n    d = prim4;\n    \n    // MODULATING GYROID\n    float prim2_1 = sdf_gyroid(p,0.8+lfo2*5.8);\n    //d = prim2_1;\n    \n    // THE INTERSECTION OF SPHER2RING and GYROID\n    //d = length(vec2(prim4,prim2_1))-0.1;\n    \n    return d;\n}\n\nfloat ray_march (vec3 r_orig, vec3 r_dir) {\n    float d0 = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = r_orig + d0 * r_dir;\n        float d_incr = scene_dist(p);\n        d0 += d_incr;\n        if(d_incr < SURFACE_DIST || d0 > MAX_DIST) break;\n    }\n    return d0;\n}\n\nvec3 get_normal(vec3 p) {\n    float d = scene_dist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        scene_dist(p-e.xyy),\n        scene_dist(p-e.yxy),\n        scene_dist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 get_light( vec3 p, vec3 eye_pos) {\n    int NUM_LIGHT = 2;\n   vec3[] light_pos = vec3[](vec3(12.,6.,7.),vec3(-1.,8.2,-10.));\n   vec3[] light_intensity = vec3[](0.8* vec3(120.,120.,120.),2.3 * vec3(120.,120.,120.));\n    float ambient = 0.12;\n    vec3 shading = vec3(0.);\n    for(int i =0; i< NUM_LIGHT; i++)\n    {\n        float rad = length(p-light_pos[i]);\n        vec3 light_dir = normalize(light_pos[i] - p);\n        vec3 energy = light_intensity[i] * (1./(rad * rad));\n        vec3 norm = get_normal(p);\n\n        float diffuse = clamp(dot(norm, light_dir),0.,1.);\n        \n        shading += energy *(diffuse);\n        //shading = vec3((0.5*sin(iTime*1.400)+ 0.9)*shading.x, (0.5*sin(iTime*1.400) + 0.9)*shading.y,(0.5*sin(iTime*1.400) + 1.)*shading.z);\n    }\n    \n    shading += vec3(ambient);\n    if(shading.x<=0.1 &&shading.y<=0.1 &&shading.z<=0.1) {\n       shading = vec3(0.1);\n    }\n    return shading;\n}\n\n\nvec3 get_ray_dir(float fov, vec2 size, vec2 frag_coord) {\n    vec2 xy = frag_coord - size / 2.;\n    float z = size.y / tan(radians(fov) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 view_mat(vec3 eye_pos, vec3 look_at_pos, vec3 up) {\n    vec3 f = normalize(look_at_pos - eye_pos);\n    vec3 s = normalize(cross(f,up));\n    vec3 u = cross(s,f);\n    \n    mat4 t      = mat4(\n                vec4(1.,0.,0.,0.),\n                vec4(0.,1.,0.,0.),\n                vec4(0.,0.,1.,0.),\n                vec4(-eye_pos.x,-eye_pos.y,-eye_pos.z,1.)\n    );\n                \n                \n    \n    mat4 result = mat4(\n                vec4(s,0.0),\n                vec4(u,0.0),\n                vec4(-f, 0.0),\n                vec4(0., 0., 0., 1.)\n    );\n    \n    return result*t;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 100.;\n    float tra = mod(iTime,fov);\n    vec3 view_dir = get_ray_dir(fov, iResolution.xy, fragCoord);\n    vec3 eye_pos = vec3((0. * cos(1. * iTime)) +3.0, (1. * sin(0.01 * iTime)) + 4.2, (0.00 *cos(0.01 * iTime)) + 4.9);    \n    mat4 view_world = view_mat(eye_pos, vec3(0.,0.,0.),vec3(0.,1.,0.));\n    vec3 r_dir = normalize(view_world * vec4(view_dir,0.)).xyz;\n       \n    float d = (ray_march(eye_pos, r_dir));\n    vec3 col = vec3(d);    \n    vec3 p = eye_pos + r_dir * d;\n    \n    col = get_light(p,eye_pos);\n        \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}