{"ver":"0.1","info":{"id":"WlSXRz","date":"1564731087","viewed":90,"name":"Simple RayTracing","username":"Nocks_on","description":"test of raytracing\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF 10000.\n#define PI 3.141592\n\nvec3 cameraPos = vec3(0., 0., 10.);\nvec3 lightDir = normalize(vec3(1., 1., 1.));\nfloat eps = 0.001;\n\nvec3[2] sphere_center = vec3[](\n\tvec3(-0.5, 0., 0.),\n    vec3(0.5, 0., 0.)\n);\nfloat[2] sphere_radius = float[](\n    0.5,\n    0.5\n);\nvec3[1] box_center = vec3[](\n\tvec3(0., 0., 0.)\n);\nvec3[1] box_size = vec3[](\n\tvec3(0.5, 0.5, 0.5)\n);\n\nmat3 rotateMatX(float angle) {\n\treturn mat3(\n        1, 0, 0, \n        0, cos(angle), -sin(angle),\n        0, sin(angle), cos(angle)\n    );\n}\n\nmat3 rotateMatY(float angle) {\n\treturn mat3(\n        cos(angle), 0, -sin(angle),\n        0, 1, 0,\n        sin(angle), 0, cos(angle)\n    );\n}\n\nmat3 rotateMatZ(float angle) {\n\treturn mat3(\n        cos(angle), -sin(angle), 0,\n        sin(angle), cos(angle), 0,\n        0, 0, 1\n    );\n}\n\n\nfloat distSphere(vec3 r, vec3 center, float radius) {\n\treturn length(r-center) - radius;\n}\n\nfloat distBox(vec3 r, vec3 center, vec3 size) {\n\treturn length(max(abs(r - center) - size, 0.0));\n}\n\nfloat distFunc(vec3 r) {\n    float min_dist = INF;\n    for (int i = 0; i < 1; i++) {\n    \tfloat dist = distBox(r, box_center[i], box_size[i]);\n        if (dist < min_dist) {\n        \tmin_dist = dist;\n        }\n    }\n    return min_dist;\n}\n\nvec3 normalFunc(vec3 r) { //get Normal vector\n\treturn normalize(vec3(\n    \tdistFunc(r) - distFunc(vec3(r.x+eps, r.y, r.z)),\n        distFunc(r) - distFunc(vec3(r.x, r.y+eps, r.z)),\n        distFunc(r) - distFunc(vec3(r.x+eps, r.y, r.z+eps))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    vec3 col;\n    \n    vec3 ray = normalize(vec3(uv, 0.) - cameraPos);\n    vec3 cur = cameraPos;\n    \n    float t = iTime;\n    float angle1 = t*2.*PI/5.0;\n    float angle2 = t*2.*PI/7.5;\n    lightDir = normalize(vec3(sin(angle1), 0.5*sin(angle2), cos(angle1)));\n    \n    for (int i = 0; i < 16; i++) {\n        vec3 transformed = rotateMatZ(angle2) * rotateMatY(angle2) * rotateMatX(angle2) * cur;\n    \tfloat dist = distFunc(transformed);\n        if (dist < eps) {\n        \tvec3 normal = normalFunc(transformed);\n            float diff = dot(normal, lightDir);\n            col = vec3(clamp(diff, 0.05, 0.95));\n            break;\n        }\n        cur += ray * dist;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}