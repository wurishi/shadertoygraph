{"ver":"0.1","info":{"id":"tdtcDs","date":"1607497514","viewed":287,"name":"Atmospheric scattering (Nishita)","username":"AlexApps99","description":"WIP","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["skybox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on:\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.0;\nconst float Hm = 1200.0;\nconst float PI = radians(180.0);\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6, 33.1e-6);\nconst vec3 betaM = vec3(21e-6);\nconst float kInfinity = uintBitsToFloat(0x7F800000u);\n#define angle -0.95 * PI * ((iMouse.y / iResolution.y) - 0.5)\n#define sunDirection vec3(0.0, cos(angle), -sin(angle))\n\nbool solveQuadratic(float a, float b, float c, inout float x1, inout float x2) \n{ \n    if (b == 0.0) { \n        // Handle special case where the the two vector ray.dir and V are perpendicular\n        // with V = ray.orig - sphere.centre\n        if (a == 0.0) return false; \n        x1 = 0.0; x2 = sqrt(-c / a); \n        return true; \n    } \n    float discr = b * b - 4.0 * a * c; \n \n    if (discr < 0.0) return false; \n \n    float q = (b < 0.f) ? -0.5f * (b - sqrt(discr)) : -0.5f * (b + sqrt(discr)); \n    x1 = q / a; \n    x2 = c / q; \n \n    return true; \n} \n\nbool raySphereIntersect(const vec3 orig, const vec3 dir, const float radius, inout float t0, inout float t1) \n{ \n    // They ray dir is normalized so A = 1 \n    float A = dir.x * dir.x + dir.y * dir.y + dir.z * dir.z; \n    float B = 2.0 * (dir.x * orig.x + dir.y * orig.y + dir.z * orig.z); \n    float C = orig.x * orig.x + orig.y * orig.y + orig.z * orig.z - radius * radius; \n \n    if (!solveQuadratic(A, B, C, t0, t1)) return false; \n \n    if (t0 > t1) t0 = t1, t1 = t0; // Verify this\n \n    return true; \n} \n\nvec3 computeIncidentLight(const vec3 orig, const vec3 dir, float tmin, float tmax)\n{ \n    float t0, t1;\n    if (!raySphereIntersect(orig, dir, atmosphereRadius, t0, t1) || t1 < 0.0) return vec3(0.0); \n    if (t0 > tmin && t0 > 0.0) tmin = t0; \n    if (t1 < tmax) tmax = t1; \n    uint numSamples = 16u; \n    uint numSamplesLight = 8u; \n    float segmentLength = (tmax - tmin) / float(numSamples); \n    float tCurrent = tmin; \n    vec3 sumR = vec3(0.0), sumM = vec3(0.0); // mie and rayleigh contribution \n    float opticalDepthR = 0.0, opticalDepthM = 0.0; \n    float mu = dot(dir, sunDirection); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction \n    float phaseR = 3.f / (16.f * PI) * (1.0 + mu * mu); \n    float g = 0.76f; \n    float phaseM = 3.f / (8.f * PI) * ((1.f - g * g) * (1.f + mu * mu)) / ((2.f + g * g) * pow(1.f + g * g - 2.f * g * mu, 1.5f)); \n    for (uint i = 0u; i < numSamples; ++i) { \n        vec3 samplePosition = orig + (tCurrent + segmentLength * 0.5f) * dir; \n        float height = length(samplePosition) - earthRadius; \n        // compute optical depth for light\n        float hr = exp(-height / Hr) * segmentLength; \n        float hm = exp(-height / Hm) * segmentLength; \n        opticalDepthR += hr; \n        opticalDepthM += hm; \n        // light optical depth\n        float t0Light, t1Light; \n        raySphereIntersect(samplePosition, sunDirection, atmosphereRadius, t0Light, t1Light); \n        float segmentLengthLight = t1Light / float(numSamplesLight), tCurrentLight = 0.0; \n        float opticalDepthLightR = 0.0, opticalDepthLightM = 0.0; \n        uint j; \n        for (j = 0u; j < numSamplesLight; ++j) { \n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5f) * sunDirection; \n            float heightLight = length(samplePositionLight) - earthRadius; \n            if (heightLight < 0.0) break; \n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight; \n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight; \n            tCurrentLight += segmentLengthLight; \n        } \n        if (j == numSamplesLight) { \n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1f * (opticalDepthM + opticalDepthLightM); \n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z)); \n            sumR += attenuation * hr; \n            sumM += attenuation * hm; \n        } \n        tCurrent += segmentLength; \n    } \n \n    // We use a magic number here for the intensity of the sun (20). We will make it more\n    // scientific in a future revision of this lesson/code\n    \n    if (!(iMouse.x == 0.0 && iMouse.y == 0.0)) {\n        if (iMouse.x/iResolution.x < 0.25) {\n        \treturn (sumR * betaR * phaseR) * 20.0;\n    \t} else if (iMouse.x/iResolution.x > 0.75) {\n    \t\treturn (sumM * betaM * phaseM) * 20.0;\n    \t}\n    }\n    \n    return (sumR * betaR * phaseR + sumM * betaM * phaseM) * 20.0;\n} \n\n\nmat3 getCamera(vec3 z) {\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z);\n}\n\n/*void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 sun_dir = normalize(vec3(cos(iTime), sin(iTime), 0.0));\n\tvec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mo;\n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n        mo = vec2(0.0, 0.5);\n    else\n        mo = iMouse.xy / iResolution.xy;\n    mo.x *= 2.0 * PI;\n    vec3 ro = vec3(sin(mo.x), tan((mo.y - 0.5) * PI), cos(mo.x));\n    vec3 rd = getCamera(normalize(ro)) * vec3(uv, - 1.0);\n    fragColor = vec4(texture(iChannel0, rd).xyz, 1.0);\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat y = 2.0 * (fragCoord.y + 0.5) / float(iResolution.y - 1.0) - 1.0;\n    float x = 2.0 * (fragCoord.x + 0.5) / float(iResolution.x - 1.0) - 1.0;\n    float z2 = x * x + y * y; \n    if (z2 <= 1.0) { \n        float phi = atan(y, x); \n        float theta = acos(1.0 - z2); \n        vec3 dir = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi)); \n        // 1 meter above sea level\n        fragColor = vec4(computeIncidentLight(vec3(0.0, earthRadius + 1.0, 0.0), dir, 0.0, kInfinity), 0.0); \n    } else {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}