{"ver":"0.1","info":{"id":"MfdSDs","date":"1714662341","viewed":101,"name":"Boids of Prey (VPT)","username":"gunthern","description":"Flocking based on Craig Reynolds' Boids: http://www.red3d.com/cwr/boids/\nFork of https://www.shadertoy.com/view/Mf3XRf, which did not use Voronoi Point Tracking. Thanks @spalmer and @FabriceNeyret2 for tips on implementing this.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["compute","flocking","boids","boid","agents","agent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Boids of Prey\" by gunthern. https://shadertoy.com/view/Mf3XRf\n// 2024-05-02 15:01:42\n\n// This version uses Voronoi point tracking optimization: \n// https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;   \n    vec4 col = texture(iChannel0, uv);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Scatter boids throughout the space\nvoid init(inout vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = vec4(0.0);\n    \n    // Boids\n    if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount) {\n        fragColor = vec4(\n            random(fragCoord + vec2(1.0, 2.0)) + 1.0, // Position X + Marker\n            random(fragCoord + vec2(3.0, 4.0)), // Position Y + State\n            random(fragCoord + vec2(5.0, 6.0)) * 2.0 - 1.0, // Direction X\n            random(fragCoord + vec2(7.0, 8.0)) * 2.0 - 1.0 // Direction Y\n        );\n        \n        return;\n    }\n    \n    // Predators\n    else if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount + predatorCount) {\n        fragColor = vec4(\n            random(fragCoord + vec2(1.0, 2.0)) + 2.0, // Position X + Marker\n            random(fragCoord + vec2(3.0, 4.0)), // Position Y + State\n            random(fragCoord + vec2(5.0, 6.0)) * 2.0 - 1.0, // Direction X\n            random(fragCoord + vec2(7.0, 8.0)) * 2.0 - 1.0 // Direction Y\n        );\n        \n        return;\n    }\n    \n    else discard;\n\n}\n\nvoid update(inout vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 mousePos = iMouse.xy;\n\n    // Boids\n    if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount) {\n    \n        float boidsSeen = 0.0;\n        float predatorsSeen = 0.0;\n        float spacingCount = 0.0;\n        \n        vec2 posVectors = vec2(0.0);\n        vec2 dirVectors = vec2(0.0);\n        vec2 spacingVectors = vec2(0.0);\n        \n        vec2 predatorVectors = vec2(0.0);\n        \n        vec2 thisBoidPos = fract(fragColor.xy) * iResolution.xy;\n        vec2 thisBoidDir = fragColor.zw;\n        \n        bool boidEaten = fragColor.x >= 3.0 ? true : false;\n        \n        bool mouseSeen = false;\n        \n        if (!boidEaten) {\n            vec4 idArray = texelFetch(iChannel1, ivec2(thisBoidPos), 0);\n            int[4] id = int[4](int(idArray.x), int(idArray.y), int(idArray.z), int(idArray.w));\n            for (int i=0; i<4; i++) {\n                ivec2 coord = ivec2(int(mod(float(id[i]), iResolution.x)), int(float(id[i]) / iResolution.x));\n                if (coord != ivec2(fragCoord)) {\n                    vec4 entity = texelFetch(iChannel0, coord, 0);\n                    vec2 entityPos = fract(entity.xy) * iResolution.xy;\n                    float dist = distance(thisBoidPos, entityPos);\n                    vec3 dp = loopDistPosition(thisBoidPos, entityPos, dist, iResolution.xy);\n                    entityPos = dp.xy;\n                    dist = dp.z;\n                    \n                    if (dist < boidSearchRange) {\n                        if (entity.x >= 2.0 && entity.x < 3.0) {\n                            if (iTime > predatorEatDelay && dist < predatorEatRange) {\n                                boidEaten = true;\n                                break;\n                            }\n                            predatorsSeen++;\n                            predatorVectors += thisBoidPos - entityPos;\n                        }\n\n                        else if (entity.x < 2.0) {\n                            boidsSeen++;\n                            posVectors += entityPos - thisBoidPos;\n                            dirVectors += entity.zw;\n\n                            if (dist < boidSpacingDist) {\n                                spacingCount++;\n                                spacingVectors += thisBoidPos - entityPos;\n                            }\n                        }\n                    }\n                }\n            }\n                \n            if (!boidEaten) {\n                    if (iMouse.z > 0.0) {\n                        float dist = distance(thisBoidPos, mousePos);\n                        if (dist < mouseSearchRange) mouseSeen = true;\n                    }\n\n                    if (iFrame > 1) {\n\n                        vec2 randomDir = vec2(\n                                random(fragCoord + sin(iTime)) * 2.0 - 1.0,\n                                random(fragCoord + sin(iTime*0.5)) * 2.0 - 1.0\n                             );\n\n                        if (mouseSeen) {\n                            thisBoidDir = normalize(mouseAttract ? mousePos - thisBoidPos : thisBoidPos - mousePos) * mouseStrength\n                            + thisBoidDir * (1.0 - mouseStrength);\n                        }\n\n                        if (boidsSeen > 0.0) {\n                            thisBoidDir = \n                                normalize(posVectors / boidsSeen) * boidAttractStrength\n                                + thisBoidDir * (1.0 - boidAttractStrength);\n\n                            thisBoidDir = \n                                normalize(dirVectors / boidsSeen) * boidAlignStrength\n                                + thisBoidDir * (1.0 - boidAlignStrength);\n\n                            if (spacingCount > 0.0) {\n                                thisBoidDir = normalize(spacingVectors / spacingCount) * 0.75\n                                + thisBoidDir * 0.25;\n                            }\n\n                            thisBoidDir = randomDir * boidRandomStrength + thisBoidDir * (1.0 - boidRandomStrength);\n                        }\n\n                        if (predatorsSeen > 0.0) {\n                            thisBoidDir =\n                                normalize(predatorVectors / predatorsSeen) * boidPredatorAvoidance\n                                + thisBoidDir * (1.0 - boidPredatorAvoidance);\n                        }\n                    }\n\n                    fragColor.xy = \n                        mod(\n                            (thisBoidPos + thisBoidDir * boidSpeed) / iResolution.xy,\n                            vec2(1.0)\n                        ) + vec2(1.0, clamp(predatorsSeen + (mouseSeen && !mouseAttract ? 1.0 : 0.0), 0.0, 1.0));\n                    fragColor.zw = thisBoidDir;\n\n            }\n            else fragColor = vec4(fragColor.x + 3.0, fragColor.y, 1.0, 0.0);\n        }\n        \n        else {\n            fragColor -= vec4(0.0, 0.0, 0.025, 0.0);\n        }\n        \n        return;\n    }\n\n    // Predators\n    else if (int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) < boidCount + predatorCount) {\n        \n        float boidsSeen = 0.0;\n        float predatorsSeen = 0.0;\n        \n        vec2 boidVectors = vec2(0.0);\n        vec2 predatorVectors = vec2(0.0);\n        \n        vec2 thisPredatorPos = fract(fragColor.xy) * iResolution.xy;\n        vec2 thisPredatorDir = fragColor.zw;\n        \n        float boidsEaten = max(floor(fragColor.y) * 0.01 - 0.01, 0.0);\n        \n        bool mouseSeen = false;\n        \n        vec4 idArray = texelFetch(iChannel1, ivec2(thisPredatorPos), 0);\n        int[4] id = int[4](int(idArray.x), int(idArray.y), int(idArray.z), int(idArray.w));\n        for (int i=0; i<4; i++) {\n            ivec2 coord = ivec2(int(mod(float(id[i]), iResolution.x)), int(float(id[i]) / iResolution.x));\n            if (coord != ivec2(fragCoord)) {\n                vec4 entity = texelFetch(iChannel0, coord, 0);\n                vec2 entityPos = fract(entity.xy) * iResolution.xy;\n                float dist = distance(thisPredatorPos, entityPos);\n                vec3 dp = loopDistPosition(thisPredatorPos, entityPos, dist, iResolution.xy);\n                entityPos = dp.xy;\n                dist = dp.z;\n                \n                if (dist < predatorSearchRange * clamp(floor(boidsEaten)*0.1, 1.0, 3.0)) {\n                    if (entity.x >= 2.0 && entity.x < 3.0) {\n                        if (dist < predatorSpacingDist * clamp(floor(boidsEaten)*0.1, 1.0, 3.0)) {\n                            predatorsSeen++;\n                            predatorVectors += thisPredatorPos - entityPos;\n                        }\n                    }\n\n                    else if (entity.x < 2.0) {\n                        boidsSeen++;\n                        boidVectors += entityPos - thisPredatorPos;\n                        if (iTime > predatorEatDelay && dist < predatorEatRange) {\n                            boidsEaten++;\n                        }\n                    }\n                \n                }\n                \n            }\n\n        }\n        \n        if (iMouse.z > 0.0) {\n                float dist = distance(thisPredatorPos, mousePos);\n                if (dist < mouseSearchRange) mouseSeen = true;\n        }\n        \n        if (iFrame > 1) {\n        \n            vec2 randomDir = vec2(\n                    random(fragCoord + sin(iTime)) * 2.0 - 1.0,\n                    random(fragCoord + sin(iTime*0.5)) * 2.0 - 1.0\n                 );\n\n            if (boidsSeen > 0.0) {\n                thisPredatorDir = \n                    normalize(boidVectors / boidsSeen) * predatorAttractStrength\n                    + thisPredatorDir * (1.0 - predatorAttractStrength);\n\n                thisPredatorDir = randomDir * predatorRandomStrength + thisPredatorDir * (1.0 - predatorRandomStrength);\n            }\n            \n            if (mouseSeen) {\n                    thisPredatorDir = normalize(mouseAttract ? mousePos - thisPredatorPos : thisPredatorPos - mousePos) * mouseStrength\n                    + thisPredatorDir * (1.0 - mouseStrength);\n            }\n\n            if (predatorsSeen > 0.0) {\n                thisPredatorDir =\n                    normalize(predatorVectors / predatorsSeen) * 0.85\n                    + thisPredatorDir * 0.15;\n            }\n            \n        }\n        \n        fragColor.xy = \n            mod(\n                (thisPredatorPos + thisPredatorDir * (predatorSpeed - clamp(boidsEaten*0.05, 0.0, predatorSpeed*0.75))) / iResolution.xy,\n                vec2(1.0)\n            ) + vec2(2.0, floor(boidsEaten * 100.0));\n        fragColor.zw = thisPredatorDir;\n        \n        return;\n    }\n    \n    else discard;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    mouseAttract = (texelFetch(iChannel2, ivec2(32, 2), 0).x) > 0.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iFrame == 0) {\n        init(fragColor, fragCoord);\n    }\n    \n    else {\n        fragColor = texture(iChannel0, uv);\n        update(fragColor, fragCoord);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Change these parameters for different behavior\n#define boidCount 10000\n\n#define predatorCount 16\n\n#define boidSearchRange 100.0\n#define boidSpeed 0.5\n#define boidSpacingDist 7.0\n#define boidAttractStrength 0.4\n#define boidAlignStrength 0.6\n#define boidRandomStrength 0.01\n#define boidPredatorAvoidance 0.7\n\n#define predatorSearchRange 200.0\n#define predatorSpeed 1.0\n#define predatorAttractStrength 0.7\n#define predatorRandomStrength 0.01\n#define predatorSpacingDist 20.0\n#define predatorEatRange 10.0\n#define predatorEatDelay 3.0\n\n#define mouseStrength 0.99\n#define mouseSearchRange 300.0\n\n#define fade 0.92\n#define boidDrawSize 2.0\n#define predatorDrawSize 3.5\n\nbool mouseAttract = false;\n\nfloat random(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n\ta += dot(a, a + 24.45);\n\treturn fract(a.x * a.y * a.z);\n}\n\nvec3 loopDistPosition(vec2 thisPos, vec2 otherPos, float dist, vec2 res) {\n    vec2 otherPos0 = otherPos - res;\n    vec2 otherPos1 = otherPos - vec2(0.0, res.y);\n    vec2 otherPos2 = otherPos + vec2(res.x, -res.y);\n    vec2 otherPos3 = otherPos - vec2(res.x, 0.0);\n    vec2 otherPos4 = otherPos + vec2(res.x, 0.0);\n    vec2 otherPos5 = otherPos - vec2(res.x, -res.y);\n    vec2 otherPos6 = otherPos + vec2(0.0, res.y);\n    vec2 otherPos7 = otherPos + res;\n\n    if (dist > distance(thisPos, otherPos0)) {\n        dist = distance(thisPos, otherPos0);\n        otherPos = otherPos0;\n    }\n    if (dist > distance(thisPos, otherPos1)) {\n        dist = distance(thisPos, otherPos1);\n        otherPos = otherPos1;\n    }\n    if (dist > distance(thisPos, otherPos2)) {\n        dist = distance(thisPos, otherPos2);\n        otherPos = otherPos2;\n    }\n    if (dist > distance(thisPos, otherPos3)) {\n        dist = distance(thisPos, otherPos3);\n        otherPos = otherPos3;\n    }\n    if (dist > distance(thisPos, otherPos4)) {\n        dist = distance(thisPos, otherPos4);\n        otherPos = otherPos4;\n    }\n    if (dist > distance(thisPos, otherPos5)) {\n        dist = distance(thisPos, otherPos5);\n        otherPos = otherPos5;\n    }\n    if (dist > distance(thisPos, otherPos6)) {\n        dist = distance(thisPos, otherPos6);\n        otherPos = otherPos6;\n    }\n    if (dist > distance(thisPos, otherPos7)) {\n        dist = distance(thisPos, otherPos7);\n        otherPos = otherPos7;\n    }\n    return vec3(otherPos, dist);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Insertion sort from https://www.shadertoy.com/view/wlBBW1\nvoid insertionSort(inout ivec4 idArray, inout vec4 distArray, int sortId, float sortDist){\t\n    if (any(equal(ivec4(sortId), idArray))) return;\n    if (sortDist < distArray[0]) idArray = ivec4(sortId, idArray.xyz), distArray = vec4(sortDist, distArray.xyz);\n    else if(sortDist < distArray[1]) idArray = ivec4(idArray.x, sortId, idArray.yz), distArray = vec4(distArray.x, sortDist, distArray.yz);\n    else if(sortDist < distArray[2]) idArray = ivec4(idArray.xy, sortId, idArray.z), distArray = vec4(distArray.xy, sortDist, distArray.z);\n    else if(sortDist < distArray[3]) idArray = ivec4(idArray.xyz, sortId), distArray = vec4(distArray.xyz, sortDist);\n    idArray = idArray.xyzw;\n    distArray = distArray.xyzw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec4 idArray = ivec4(-1);\n    vec4 distArray = vec4(1e20);\n    ivec2 coord = ivec2(fragCoord);\n    \n    // Get current vec4 of closest points for this pixel, and same for up, down, left, right\n    ivec4 previous = ivec4(texelFetch(iChannel1, coord, 0));\n    ivec4 up = ivec4(texelFetch(iChannel1, coord+ivec2(0,1), 0));\n    ivec4 down = ivec4(texelFetch(iChannel1, coord-ivec2(0,1), 0));\n    ivec4 left = ivec4(texelFetch(iChannel1, coord-ivec2(1,0), 0));\n    ivec4 right = ivec4(texelFetch(iChannel1, coord+ivec2(1,0), 0));\n    ivec4[5] candidates = ivec4[5](previous, up, down, left, right);\n    \n    // Loop over array of points to sort closest points\n    for (int i=0; i<5; i++) {\n        for (int j=0; j<4; j++) {\n            int id = candidates[i][j];\n            ivec2 cCoord = ivec2(int(mod(float(id), iResolution.x)), int(float(id) / iResolution.x));\n            vec4 candidate = texelFetch(iChannel0, cCoord, 0);\n            vec2 cPos = fract(candidate.xy) * iResolution.xy;\n            float dist = distance(fragCoord, cPos);\n            dist = loopDistPosition(fragCoord, cPos, dist, iResolution.xy).z;\n            insertionSort(idArray, distArray, id, dist);\n        }\n    }\n    \n    // Do the same thing with n randomly selected other points\n    for (int n=0; n<1; n++) {\n        int id = int(random(fragCoord + vec2(iTime, iTime*0.5)) * float(boidCount+predatorCount));\n        ivec2 cCoord = ivec2(int(mod(float(id), iResolution.x)), int(float(id) / iResolution.x));\n        vec4 candidate = texelFetch(iChannel0, cCoord, 0);\n        vec2 cPos = fract(candidate.xy) * iResolution.xy;\n        float dist = distance(fragCoord, cPos);\n        dist = loopDistPosition(fragCoord, cPos, dist, iResolution.xy).z;\n        insertionSort(idArray, distArray, id, dist);\n    }\n    \n    fragColor = vec4(idArray);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel2, uv);\n    fragColor = col * (col.x + col.y + col.z > 0.2 ? fade : 1.0);\n    \n    // Render\n    vec4 idArray = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    int[4] id = int[4](int(idArray.x), int(idArray.y), int(idArray.z), int(idArray.w));\n    for (int i=0; i<4; i++) {\n        vec4 entity = texelFetch(\n            iChannel0, \n            ivec2(int(mod(float(id[i]), iResolution.x)), int(float(id[i]) / iResolution.x)), \n            0\n        );\n        vec2 p = fract(entity.xy) * iResolution.xy;\n        if (entity.x >= 2.0 && entity.x < 3.0) {\n            if (distance(p, fragCoord) < predatorDrawSize + min(floor(entity.y)*0.001, 1.0)) {\n                fragColor = vec4(0.9 + sin(iTime)*0.1, 0.0, 0.0 + sin(iTime*0.5)*0.25, 1.0);\n            }\n        }\n        else if (entity.x < 3.0) {\n            if (distance(p, fragCoord) < boidDrawSize) {\n                fragColor = entity.y >= 1.0 ? \n                    vec4(0.0, 0.75 + cos(iTime)*0.25, 0.5 + cos(iTime*0.5)*0.25, 1.0) : \n                    vec4(0.0, 0.25 + cos(iTime*0.3)*0.25, 0.9 + cos(iTime*0.7)*0.1, 1.0);\n            }\n        }\n        else if (entity.z > 0.0) {\n            if (distance(p, fragCoord) < boidDrawSize * (1.0+entity.z)) {\n                fragColor = vec4(entity.z+0.5, entity.z+0.5, 0.0, 1.0);\n            }\n        }\n        else if (entity.z <= 0.0 && entity.z > -20.0 && col.x + col.y + col.z < 0.2) {\n            if (distance(p, fragCoord) < boidDrawSize * max((2.0+entity.z), 1.5)) {\n                fragColor = vec4(entity.z, entity.z, 0.0, 1.0);\n            }\n        }\n    }\n\n    // Buffer A debug\n    //fragColor = texture(iChannel0, uv*.1);\n    \n    // Buffer B debug\n    //fragColor = texture(iChannel1, uv) * 0.001;\n}","name":"Buffer C","description":"","type":"buffer"}]}