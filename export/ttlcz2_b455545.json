{"ver":"0.1","info":{"id":"ttlcz2","date":"1593128418","viewed":54,"name":"DixImac ShaderTemplate","username":"Kaeylos","description":"ShaderTemplate for the IMAC game DixImac created by JulesFouchy\n\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["imacraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat random(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec2 computeUV(vec2 fragCoord) {\n    // Normalized and centered coordinates (from -0.5 to 0.5) using same unit on both axis\n\tvec2 uv = (fragCoord-.5 - 0.5*(iResolution.xy-1.))/(iResolution.y-1.);  \n\tuv *= 2.; // scale to have 1 radius (from -1 to 1)\n    uv *= 1.5; // scale to have 1.5 unit for the y axes\n    return uv;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 seed = vec2(803., 2.); // Change seed if you want\n    float u_rand = random(seed); // Random number generated using hard coded seed\n    \n    vec2 uv = computeUV(fragCoord);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+vec3(uv, u_rand)+vec3(0,2,4)); // Time varying pixel color\n    \n    if( abs(uv.y) > 1.5 || abs(uv.x) > 1.) { col = vec3(0.);} // uv coordinate mask\n    fragColor = vec4(col,1.0); // Output color to screen\n}","name":"Image","description":"","type":"image"}]}