{"ver":"0.1","info":{"id":"wdj3D1","date":"1548790904","viewed":135,"name":"Noise Review","username":"nr4","description":"Some noises","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["noise","sound","perlin","value","multifreqency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Noise Review\n* Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n*\n* This program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Update: Made it scroll\n// Update 2: Normalization of multi-frequency code\n\n// Global constants\nconst vec3 c = vec3(1., 0., -1.);\n\n// Hash function\nfloat rand(float x)\n{\n    return fract(sin(dot(x*c.xx-1. ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// One-dimensional value noise\nfloat value_noise_1d(float t)\n{\n    float i = floor(t);\n    t = fract(t);\n    return mix(-1.+2.*rand(i), -1.+2.*rand(i+1.), smoothstep(0., 1., t));\n}\n\n// One-dimensional perlin noise\nfloat derivative_noise_1d(float t)\n{\n    float i = floor(t);\n    t = fract(t);\n    t = ((6.*t-15.)*t+10.)*t*t*t;\n    return mix(-1.+2.*rand(i), -1.+2.*rand(i+1.), t);\n}\n\n// Make noise multi-frequency\n#define mf(noise, x, fmin, fmax, alpha, dst) \\\n{\\\n    dst = 0.;\\\n    float a = 1., nf = 0.;\\\n    for(float f = fmin; f<fmax; f = f*2.)\\\n    {\\\n        dst += a*noise(f*(x));\\\n        a *= alpha;\\\n        nf += 1.;\\\n    }\\\n    dst *= (1.-alpha)/(1.-pow(alpha, nf));\\\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float a = 1.5/iResolution.y;\n    \n    if(mod(floor(iTime), 2.) == 0.) // Single-freqency\n    {\n        if(uv.y > 0.)\n        {\n            uv = 4.*(uv-.25);\n            float d = abs(uv.y - value_noise_1d(5.*uv.x-iTime))-.01;\n            col = mix(c.yyy, col, smoothstep(-a, a, -d));\n        }\n        else\n        {\n            uv = 4.*(uv+.25);\n            float d = abs(uv.y - derivative_noise_1d(5.*uv.x-iTime))-.01;\n            col = mix(c.yyy, col, smoothstep(-a, a, -d));\n        }\n    }\n    else // Multi-Frequency\n    {\n        if(uv.y > 0.)\n        {\n            uv = 4.*(uv-.25);\n            float d;\n            mf(value_noise_1d, uv.x-.2*iTime, 4., 1000., .45, d);\n            d = abs(uv.y - d)-.01;\n            col = mix(c.yyy, col, smoothstep(-a, a, -d));\n        }\n        else\n        {\n            uv = 4.*(uv+.25);\n            float d;\n            mf(derivative_noise_1d, uv.x-.2*iTime, 4., 1000., .45, d);\n            d = abs(uv.y - d)-.01;\n            col = mix(c.yyy, col, smoothstep(-a, a, -d));\n        }\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Noise Review\n* Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n*\n* This program is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Update 1: removed time glitch with mod\n\n// define VALUE for value noise, nothing gives perlin\n#define VALUE\n\n// Global constants\nconst vec3 c = vec3(1., 0., -1.);\n\n// Hash function\nfloat rand(float x)\n{\n    return fract(sin(dot(x*c.xx-1. ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// One-dimensional value noise\nfloat value_noise_1d(float t)\n{\n    float i = floor(t);\n    t = fract(t);\n    return mix(-1.+2.*rand(i), -1.+2.*rand(i+1.), smoothstep(0., 1., t));\n}\n\n// One-dimensional perlin noise\nfloat derivative_noise_1d(float t)\n{\n    float i = floor(t);\n    t = fract(t);\n    t = ((6.*t-15.)*t+10.)*t*t*t;\n    return mix(-1.+2.*rand(i), -1.+2.*rand(i+1.), t);\n}\n\n// Make noise multi-frequency\n#define mf(noise, x, fmin, fmax, alpha, dst) \\\n{\\\n    dst = 0.;\\\n    float a = 1., nf = 0.;\\\n    for(float f = fmin; f<fmax; f = f*2.)\\\n    {\\\n        dst += a*noise(f*(x));\\\n        a *= alpha;\\\n        nf += 1.;\\\n    }\\\n    dst *= (1.-alpha)/(1.-pow(alpha, nf));\\\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    time = mod(time, 4.);\n    \n    const float f = 440.,\n        tau = 2.*acos(-1.);\n    float d = 0.;\n    \n    if(mod(floor(time), 2.) == 0.) // Single-freqency\n    {\n#ifdef VALUE\n            d = value_noise_1d(tau * f * time);\n#else\n            d = derivative_noise_1d(tau * f * time);\n#endif\n    }\n    else // Multi-Frequency\n    {\n#ifdef VALUE\n            mf(value_noise_1d, tau * f * time, 110., 1000., .45, d);\n#else\n            mf(derivative_noise_1d, tau * f * time, 110., 1000., .45, d);\n#endif\n    }\n    \n    return vec2(d);\n}","name":"Sound","description":"","type":"sound"}]}