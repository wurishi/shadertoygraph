{"ver":"0.1","info":{"id":"lcK3Wd","date":"1713454937","viewed":103,"name":"Penrose pentagram","username":"mikceroese","description":"Spinning neon pink penrose tiling","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["neon","penrose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GR = (1.0+sqrt(5.0))/2.0; // Golden ratio, diagonal of regular pentagon\nconst float GRI = 1.0/GR; // Inverse of the golden ratio\nconst float PI = 3.14159265; // Pi (duh)\nconst float DG_72 = PI/2.5; // 72 degrees\nconst float DG_36 = PI/5.0; // 36 degrees\nconst float COS_DG_36 = cos(DG_36); // Cosine of 36 degrees\nconst float SIN_DG_36 = sin(DG_36); // Sine of 36 degrees\nconst float DG_18 = PI/10.0; // 18 degrees\n\nconst vec2 SUN_TRI_A = vec2(0,0); // First half-dart vertex\nconst vec2 SUN_TRI_B = vec2(1,0); // Second half-dart vertex\nconst vec2 SUN_TRI_C = vec2(cos(DG_36),sin(DG_36)); // Third half-dart vertex\nconst float SUN_TRI_AREA = sin(DG_18)*cos(DG_18); // Area of a half-dart at step 0\n\nvoid triangle_area(out float area, out float height, in vec2 A, in vec2 B, in vec2 C)\n{\n    //Returns the area and height of a triangle (assuming the B-C is the base)\n    area = abs((A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y))/2.0);\n    height = 2.0*area/length(B-C);    \n}\n\nvoid is_p_in_tri(out bool is_in, out float dist, in vec2 P, in float target_area, in vec2 A, in vec2 B, in vec2 C)\n{\n    //Returns whether or not a point lies within a triangle of a given area, \n    //and how far it is from its nearest side.\n    \n    float area = 0.0, new_area;\n    float min_dist = 1.0, new_dist;\n    \n    triangle_area(new_area,new_dist,P,A,B);\n    min_dist = min(min_dist,new_dist);\n    area += new_area;\n    triangle_area(new_area,new_dist,P,B,C);\n    min_dist = min(min_dist,new_dist);\n    area += new_area;\n    triangle_area(new_area,new_dist,P,C,A);\n    min_dist = min(min_dist,new_dist);\n    area += new_area;\n    \n    dist = min_dist;    \n    \n    float area_diff = abs(area-target_area);\n    if(area_diff<1e-6){    \n        is_in = true;\n    } else {\n        is_in = false;\n    }\n    \n}\n\nvoid kite_or_dart(out bool tile, out float dist, in float r, in float phi, in int steps){\n    // Output 1 if the tile is a kite, or 0 if it is a dart.\n    // Output the distance to the nearest side of the tile.\n    \n    // Map every input to the same half-dart (radial simmetry, yay!)\n    // Angles are mirrored every 2 half-darts: 0ยบ to 36ยบ and back to 0ยบ\n    float new_phi = DG_36-abs(DG_36-(mod(phi,DG_72)));\n    // Radii are constrained to the triangle\n    // Small values are bumped up a little\n    // Big values are brought down to prevent them from strayin too far,\n    // down to the distance to the point of intersection between \n    // the uv vector and the far side of the triangle (or smaller)\n    float max_r = 1.0/(cos(new_phi)-sin(new_phi)*(COS_DG_36-1.0)/SIN_DG_36);\n    //float new_r = clamp(r,1e-6,max_r); // Using this one produces black outside\n    float new_r = max_r-abs(max_r-mod(r,2.0*max_r)); // This one mirrors the pattern outside-in\n    \n    vec2 uv = new_r*vec2(cos(new_phi),sin(new_phi));\n    \n    // The area of the tiles is always reduced by the inverse of the\n    // golden ratio every step, so you know the area they should\n    // have if you count the steps\n    float target_dart_area = SUN_TRI_AREA;\n    float target_kite_area = 0.0;\n    \n    // The Penrose Sun always starts as 10 half-darts\n    bool is_kite = false;\n    vec2 a = SUN_TRI_A;\n    vec2 b = SUN_TRI_B;\n    vec2 c = SUN_TRI_C;\n    \n    vec2 d, e, f;\n    bool is_in;\n    \n    // At every step\n    for (int i = 0; i<steps; i++){\n        // Precalc the area of kites and darts for next step\n        target_kite_area = target_dart_area*GRI;\n        target_dart_area = target_dart_area*(1.0-GRI);\n        // Split the current triangle\n        if (is_kite){\n            // For kites, we need two cuts\n            e = b+(a-b)/GR;\n            f = b+(c-b)/GR;\n            is_p_in_tri(is_in,dist,uv,target_kite_area,f,c,a);\n            if(is_in){\n                b = c;\n                c = a;\n                a = f;\n                //is_kite = true;\n            } else {\n                is_p_in_tri(is_in,dist,uv,target_kite_area,e,f,b);\n                if(is_in){\n                    c = b;\n                    a = e;\n                    b = f;\n                    //is_kite = true;\n                } else {\n                    is_p_in_tri(is_in,dist,uv,target_dart_area,f,e,a);\n                    c = a;\n                    a = f;\n                    b = e;\n                    is_kite = false;\n                }\n            }\n        }else{\n            // For darts, we need one cut\n            d = a+(b-a)/GR;      \n            is_p_in_tri(is_in,dist,uv,target_kite_area,d,c,a);\n            if(is_in){\n                b = c;\n                c = a;\n                a = d;\n                is_kite = true;                \n            } else {\n                is_p_in_tri(is_in,dist,uv,target_dart_area,c,d,b);\n                a = c;\n                c = b;\n                b = d;\n                //is_kite = false;\n            }\n        }\n    }\n    \n    tile = is_kite;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord *2.0 - iResolution.xy) / iResolution.y;\n    // Obatin distance to center and angle from +X axis\n    float r = length(uv);\n    float phi = atan(uv.x,uv.y) + PI;\n    // Define the number of subdivisions\n    int steps_1 = 3;\n    int steps_2 = 5;\n    \n    float factor = (sin(iTime*0.42)+1.0)/2.0;\n    \n    phi += sin(iTime*0.2+1.0) + r*sin(iTime*0.2);\n    \n    bool tile_1, tile_2;\n    float d_1, d_2;\n    \n    kite_or_dart(tile_1,d_1,r,phi,steps_1);\n    kite_or_dart(tile_2,d_2,r,phi,steps_2);\n    \n    d_1 = float(steps_1)*sqrt(d_1)/sqrt(r);\n    d_2 = float(steps_2)*sqrt(d_2)/sqrt(r);\n    \n    vec3 color_1 = vec3((0.6*float(tile_1)+0.5*float(!tile_1))/d_1,(0.1*float(tile_1)+0.3*float(!tile_1))/d_1,(0.5*float(tile_1)+0.4*float(!tile_1))/d_1);\n    vec3 color_2 = vec3((0.4*float(tile_2)+0.8*float(!tile_2))/d_2,(0.05*float(tile_2)+0.2*float(!tile_2))/d_2,(0.3*float(tile_2)+0.6*float(!tile_2))/d_2);\n\n    // Output to screen\n    fragColor = vec4(0.6*(factor*color_1+(1.0-factor)*color_2),1.0);\n}","name":"Image","description":"","type":"image"}]}