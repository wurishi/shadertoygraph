{"ver":"0.1","info":{"id":"lcGcWz","date":"1731698132","viewed":77,"name":"combination fratal star","username":"nayk","description":"source https://www.shadertoy.com/view/lfyyzR https://www.shadertoy.com/view/McycRD","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","color","rotate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R  iResolution.xy\n\n#define T (2.2 + iTime*0.)  // start time & speed\n#define H(v) (cos(((v)+.5)*6.2832 + radians(vec3(0, 60, 120)))*.5+.5)  // hue\nmat2 A(float v)  // rotate\n{\n    float c = cos(v*3.1416),\n          s = sin(v*3.1416);\n    return mat2(c, s, -s, c);\n}\nfloat pattern(vec2 p)\n{\np.xy*=A(iTime*1.01);\n    float x = p.x, y = p.y;\n    return sqrt(x*x + y*y);\n    // reminder to modify/disable w in Q() below if using a different pattern\n    // for another cool pattern: \n    // try removing the sqrt from this, set time/1e3, and change w to max(1., r*.003)\n}\n\n\n# define NUM_LAYERS 8.\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare) {\n    float d = length(uv);\n    float m = .05/d;    \n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*flare;\n    uv *= Rot(3.1415/4.); // 45 degg, pi/4 radians\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*.3*flare;\n    m *= smoothstep(1.,.2,d);\n    \n    return m;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(424.34,342.21));\n    p += dot(p, p+34.32);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv)-.5; //gv=grid uv\n    vec2 id = floor(uv);\n    \n    for(int y=-1;y<=1;y++) {\n        for(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x,y);\n            \n            float n = Hash21(id+offs); // pseudorandom fract\n            float size = fract(n*345.32);\n\n            float star = Star(gv-offs-vec2(n,fract(n*34.))+.5, smoothstep(.85,1.,size));\n            \n            vec3 color = sin(vec3(.3,.1,.9)*fract(n*3245.23)*11.33)*.5+.5;\n            color *= vec3(1.,.5,1.+size);\n            \n            star *= sin(iTime*3.+n*6.2831)*.5+1.;\n            \n            col += star*size*color;\n       }\n    }\n    return col;\n}\n\n// from iq: https://www.shadertoy.com/view/Mt3BDj\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 k = vec3(-.866, .5, .577);\n    p.xy = abs(p.yx);\n  \n    p.xy -= 2.*min(dot(k.xy, p.xy), 0.0)*k.xy;\n      p.xy*=A(iTime*1.01);\n    vec2 d = vec2(\n        length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y-h.x), \n        max(-p.z-h.y, 0.));\n          \n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// used below\n#define Q(id, s) g = id + vec2(i%2, i/2)*s; \\\n                 r = pattern(g*o); \\\n                 z = cos(r*t)*.5+.5; \\\n                 w = max(1., r*r*.001); \\\n                 d = min(d, sdHexPrism(p - vec3(o*g, -z -w), vec2(.4, 0))-.05); \\\n                 d = min(d, length(p - vec3(o*g, -z -w))-.15);\n\n// domain repetition: https://iquilezles.org/articles/sdfrepetition/\n// modified for hex tiles\nfloat map(vec3 p)\n{\n \n    float t = T*6.2832,\n          d = 1e20, r, z, w;\n    \n    vec2 o = vec2(1, 1.732);\n  \n     vec2 \n         id1 = round(p.xy/o),\n         id2 = round(p.xy/o+.5)-.5,\n         s1 = sign(p.xy-id1*o),\n         s2 = sign(p.xy-id2*o),\n         id, s, g;\n    \n     \n    for (int i=0; i<2; i++)\n    {\n        Q(id1, s1)\n        Q(id2, s2)\n    }\n    return d;\n}\n\nvec3 norm(vec3 p)\n{\n\n    float h = 0.002;\n    vec2 k = vec2(1, -1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\n// quick 2d hex coords by Fabrice\nvec2 hex(vec2 u)\n{\n\n    vec2 o = vec2(.5, .866),\n         a = mod(u,   o+o)-o,\n         b = mod(u-o, o+o)-o;\n         a.xy*=A(iTime*0.51);\n         b.xy*=A(iTime*0.51);\n              \n    return dot(a,a) < dot(b,b) ? a : b;\n}\nvec2 N(float angle){\n    return vec2(sin(angle), cos(angle));\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n  vec2 uv = (U-.5*iResolution.xy)/iResolution.y;\n     \n    float i = 0., d = i, s, z, l, n;\n     vec2 mouse = iMouse.xy/iResolution.xy; //getting mouse coordinates and normalizing them. \n    uv *= 1.25;\n    vec3 col = vec3(0);\n \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.)*3.1415)*.5;\n    \n     vec2 M = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    float t3 = iTime * .02;\n    \n    uv += -M*3.;\n    \n    uv *= Rot(t3);\n    \n    vec3 col2 = vec3(0);\n    \n    for(float i=0.;i<1.;i+=1./NUM_LAYERS){\n    float depth = fract(i+t3);\n    float scale = mix(20., .5, depth);\n    float fade = depth* smoothstep(1., .9, depth);\n    col2 += StarLayer(uv*scale+i*454.23-M*3.)*fade;\n    }\n    vec2 n2 = N((5./6.)*3.1415); //n for normal\n    float d2 = dot(uv-vec2(.5,0),n2);\n    uv -= n2*max(0.,d2)*2.;\n        \n    n2 = N((2./3.)*3.1415);\n    float scale=1.;\n    uv.x+=.5;\n    for (int i=0; i < 4; i++) {\n        uv *=3.; // to get 3 times the space to put the whole chape on one line segment\n        scale*=3.;\n        uv.x -= 1.5; // to get the origin at the center of the right line.\n    \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv -= n2*min(0.,dot(uv,n2))*2.; // now you can bend that line  \n    }\n    \n\n    \n    d2 = length(uv - vec2(clamp(uv.x, -1., 1.), 0));\n    col += smoothstep(1./iResolution.y,.0,d2/scale); // turning gradient into a solid line.\n    uv /= scale;\n    col += texture(iChannel0, uv*2.-iTime*.05).rgb;\n    //col.rg += uv/scale; // visualising results.\n    vec2 //R = iResolution.xy,  // set in common\n         m ,  // from time\n               h;\n    \n    vec3 o = vec3(0, 0, -35./(cos(iTime)+1.5)),      // camera\n         u = normalize(vec3(U - R/2., R.y)),  // coords\n         c = vec3(0), p, t, b, k;\n    \n    mat2 rh = A(cos(iTime)/2.),  // rotate horizontal\n         rv = A((cos(iTime)+.5)/2.);    // vertical\n    \n    for (; i++<50.;)  // raymarch\n    {\n        p = u*d + o;\n      \n        s = map(p);  // sdf\n        c += min(s, .005/s);\n        if (s < 1e-2 || d > 1e3) break;\n        d += s*.7;\n    }\n    \n    b = exp(log(1.-c)*.99) * log(c*2.7);              // metallic sheen\n    b = clamp(b*b, .001, 1e3/dot(p.xy, p.xy));        // clamp\n    l = dot(norm(p), normalize(vec3(0, 0, -1e2)-p));  // light\n    h = hex(p.xy);                                    // 2d hex coords\n    n = pattern(p.xy-h);                              // movement pattern\n    z = cos(n*T*6.2832)*.5+.5;                        // used for color & shading\n    k = H(.6-z);                                      // color gradient\n    t;            // texture\n    \n    c *= 0.;  // reset c\n    c += t    // texture\n       * z    // shade z\n       * l;   // light\n  \n    c += c * pow(max(l, 0.), 1e2) * 1.5;  // bright spot\n    c -= k * .4 * c;   // color\n    c += -b * (z+.1);  // sheen\n    c = max( c*c,  // contrast & flip -\n             round(min(.1/length(h), 1.)*z  // 2d lights\n             * (k*.5+.5) * .9));            // color\n    \n    C = vec4(min(exp(log(c)/2.2), 1.), 1);\n    C*=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}