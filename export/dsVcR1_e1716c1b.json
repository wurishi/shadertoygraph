{"ver":"0.1","info":{"id":"dsVcR1","date":"1695826572","viewed":59,"name":"metric shenanigans","username":"pb","description":"the surface for refraction is affected by a non-euclidean metric that is similar to the schwarzschild black hole metric.  for GR enthusiasts - this is NOT an attempt to make a realistic picture.  click LEFT for screwed up metric, click RIGHT for normal","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["refraction","metric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//see Buffer A please\n\n//let play for 30 seconds OR click right half for regular euclidean metric OR\n//bottom left or upper left for non euclidean versions 1 and 2 \n\n//version 2 (click the bottom left) is really funky, the background should be a static grid\n//of spheres rotating in the xy plane, watch how it sends the spheres on wild orbits\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n\n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//warning: this is not realistic physically nor is it exactly correct geometrically\n//only fiddling around, it creates a pretty funky space\n\nvec3 ro,rd,pp;\nvec3 light;\nbool hitOrb;\nfloat totdist;\n#define pi 3.14159265\nbool metricFlag=true;\n#define eps 1e-6\n#define m3id mat3(1,0,0,0,1,0,0,0,1)\nfloat[] param = float [] (-1.5, 1., 2., 1., 0., .3);\n\n\nmat3 m3(vec3 p) {\n    return mat3(1,0,0,0,1,0,0,0,1);\n   \n}\n\nmat3 mt(vec3 p) {\n\n    //metric matrix here\n    //convert to spherical\n    float r = length(p);  //only need radius for now\n    //float theta = asin(p.z/r);\n    //float phi = atan(p.y/p.x);\n\n    //make your own\n    return mat3( (r-1.)/max(r,eps), 0., 0., 0., r/max((1.-r),eps), 0., 0., 0., 0. );\n         \n   \n}\n\nmat2 rot(float an) {return mat2(cos(an),sin(an),-sin(an),cos(an));}\n\nfloat dist_func01(vec3 p) {\n\n    hitOrb = false;\n    \n    mat3 mm = metricFlag ? mt(p) : m3id;\n    \n    //distance to refractive orb is affected by the \"metric\" matrix: mt from above\n    float orb = sqrt(dot(p,mm*p)) - param[3] ; \n\n\n    p.xz *= rot(iTime/4.);\n    p = mod(p-2.,4.)-2.;\n    float dist = length(p - vec3(0,0,param[4]) ) - param[5];\n    if ( orb  < dist ) {\n        dist = orb;\n        hitOrb = true;\n    }\n    return dist;\n}\n\nvec3 gradient(vec3 p) {\n\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = .0001 * dpn; \n\n    vec3 df = dpn.xxx * dist_func01(p+dp.xxx) +\n              dpn.yyx * dist_func01(p+dp.yyx) +\n              dpn.xyy * dist_func01(p+dp.xyy) +\n              dpn.yxy * dist_func01(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n  \n    float  rf = .8;  //have some fun change this\n    \n    float tt = mod(iTime,30.);\n    \n    metricFlag = iMouse.x/iResolution.x < .5;\n    \n    if (iMouse.w == 0.) {\n    \n        metricFlag = tt > 5.;\n    }\n    \n    light = normalize( vec3( 0, -1, -1) ) ;\n    xy = (2.*xy - iResolution.xy) / iResolution.y;\n    \n    if (metricFlag) xy *=3.;\n    rd = normalize( vec3(xy,1.) );\n    \n    if (metricFlag) { \n       param[0] = -.6; param[1]=1.; param[2]=.001; param[3]=.05; param[4]=2.; param[5]=.1;\n       \n       if (  (tt > 20. && iMouse.w == 0. )|| (iMouse.w !=0. && iMouse.y/iResolution.y < .5) ) {\n           param[3] = .5;\n           param[0] = -.5;\n           \n           rd.yz *= rot(-47./5.);\n       }\n       else {\n           rd.yz  *= rot(iTime/5.);\n       }\n       \n       \n    }\n    \n    \n    ro = vec3(0.,0.,param[0]);\n    \n    vec3 p = ro;\n    \n    \n    float init_eps=1e-8;\n    float n=0.,dist,threshold=init_eps;\n    totdist=0.;\n    vec3 color=vec3(0.);\n    float pc = 0.;\n\n    for(;n<300.;n++) {\n        \n        dist = dist_func01(p);\n        \n        if ( dist < init_eps && hitOrb )  {\n\n            mat3 mm = metricFlag ? mt(p) : m3id;\n            \n            vec3 pp = p - param[1]*dist*rd;\n            vec3 nn = gradient(pp);\n            \n            vec3 rd2 =  refract( rd, nn, rf);  \n            \n            vec3 rd3 = mm * rd2;  //ray direction vector affected by \"metric\"\n            \n            p = pp + param[2]*rd3; \n                   \n            rd = rd2;\n            \n            color += vec3( 15.,3.,0.);\n            \n            pc += 1.;           \n        \n        }\n          \n        else if ( dist < threshold && !hitOrb ) {\n          \n            color += 2.*vec3(.3,.5,.8);          \n            vec3 nn = gradient(p+dist*rd) ;\n            color *= max(0.,dot(nn,light));\n            break;   \n           \n        }\n        \n        else {\n            p += dist * rd;\n        }\n        \n \n        totdist += dist;\n        threshold = init_eps * (1. + totdist*50. );\n \n \n    }\n    \n    color *= exp(-totdist*totdist/600.);\n    \n    float sqpc = sqrt(pc);\n    color.r += .2*sqpc;\n    color.g += .05*sqpc;\n    \n    rgba = vec4(color,1.);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}