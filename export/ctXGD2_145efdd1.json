{"ver":"0.1","info":{"id":"ctXGD2","date":"1672390886","viewed":202,"name":"Bezier Spline UV Texture","username":"ligaobo","description":"Given a quadratic bezier spline, calculates an UV mapping along it. The U coord is tangent to the spline and calculated with analytical integratiion, while V is perpendicular and make use of SDFs.","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["spline"],"hasliked":0,"parentid":"NltBRB","parentname":"Bezier Spline UV Texture Mapping"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The displayed spline control points\n#define KNOT_COUNT 19\nvec2 spline[] = vec2[KNOT_COUNT](\n    vec2(0.00, 0.10),\n    vec2(0.20, 0.10),\n    vec2(0.20, 0.60),\n    vec2(0.20, 0.90),\n    vec2(0.40, 0.90),\n    vec2(0.60, 0.90),\n    vec2(0.60, 0.50),\n    vec2(0.60, 0.10),\n    vec2(0.80, 0.10),\n    vec2(1.60, 0.10),\n    vec2(1.60, 0.30),\n    vec2(1.60, 0.50),\n    vec2(1.10, 0.50),  \n    vec2(0.80, 0.50),\n    vec2(0.80, 0.75),\n    vec2(0.80, 0.95),\n    vec2(1.40, 0.80),\n    vec2(1.60, 0.75),\n    vec2(1.80, 0.75)\n);\n\n// The width of the UV mapped region around the spline\n#define PATH_WIDTH 0.20\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// Roots of the cubic equation for the closest point to a bezier.\n// From: https://www.shadertoy.com/view/MdXBzB by tomkh\nvec4 FindCubicRoots(float a, float b, float c)\n{\n    float p = b - a * a / 3.0, p3 = p * p * p;\n    float q = a * (2.0 * a * a - 9.0 * b) / 27.0 + c;\n    float d = q * q + 4.0 * p3 / 27.0;\n    float offset = -a / 3.0;\n    if (d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0, 1.0) / 3.0);\n        return vec4(offset + uv.x + uv.y, 0, 0, 1.0);\n    }\n\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v) * 1.732050808;\n    return vec4(vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset, 3.0);\n}\n\n// Returns 1.0 if the two vector are clockwise sorted, -1.0 otherwise\nfloat GetWinding(vec2 a, vec2 b)\n{\n    return 2.0 * step(a.x * b.y, a.y * b.x) - 1.0;\n}\n\n// Returns the signed distance from a point to a bezier curve\n// Mostly from: https://www.shadertoy.com/view/MdXBzB by tomkh\nvec2 BezierSDF(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    float dotbb = dot(b, b);\n\n    vec3 k = vec3(3.0 * dot(a, b), 2. * dot(a, a) + dot(d, b), dot(d, a)) / dotbb;\n    vec4 t = FindCubicRoots(k.x, k.y, k.z);\n    vec2 tsat = saturate(t.xy);\n\n    vec2 dp1 = d + (c + b * tsat.x) * tsat.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b * tsat.y) * tsat.y;\n    float d2 = dot(dp2, dp2);\n\n    // Find closest distance and t\n    vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n\n    // Check the distance sign\n    float s = GetWinding(r.zw, 2.0 * b * r.y + c);\n    \n    return vec2(s * sqrt(r.x), r.y);\n}\n\n// Calc the length of a quadratic bezier at the start/end points and at the specified value for the parameter t.\n// X = length of the bezier up to \"t\" \n// Y = total length of the curve\nvec2 BezierCurveLengthAt(vec2 A, vec2 B, vec2 C, float t)\n{\n    // Bezier curve function:\n    // f(t) = t^2(A - 2B + C) + t(2B - 2A) + A\n\n    // Calc the bezier curve derivative (velocity function):\n    // f'(t) = t(2A-4B+2C) + 2B - 2A = a1t + b1\n    vec2 a1 = 2.0 * (A - 2.0 * B + C);\n    vec2 b1 = 2.0 * (B - A);\n\n    // Calc the velocity function magnitude:\n    // ||f'(t)|| = sqrt(t^2 * k1 + t * k2 + k3)\n    float k1 = dot(a1, a1);\n    float k2 = 2.0 * dot(a1, b1);\n    float k3 = dot(b1, b1);\n\n    // Reparametrize for easier integration\n    // t^2k1 + tk2 + k3 = k1((t + k4)^2 + k5)\n    float k4 = 0.5f * k2 / k1;\n    float k5 = k3 / k1 - k4 * k4;\n\n    // Calculate the definite integrals of the velocity function to obtain the distance function\n    // solution to this integral form is from: https://en.wikipedia.org/wiki/List_of_integrals_of_irrational_functions\n    // S ||f'(t)|| dt = 0.5 * sqrt(k1) * [(k4 + t) * sqrt((t + k4)^2 + k5) + k5 ln(k4 + t + sqrt((t + k4)^2 + k5))]  \n    vec3 ti = vec3(0.0, t, 1.0); // calc at all three integration bounds at once\n    vec3 vt = sqrt((ti + k4) * (ti + k4) + k5);\n    vec3 sdft = sqrt(k1) * 0.5 * ((k4 + ti) * vt + k5 * log(abs(k4 + ti + vt)));\n    return sdft.yz - sdft.x;\n}\n\n\n// Decompose a give location into its distance from the closest point on the spline. \n// and the length of the spline up to that point.\n// Returns a vector where:\n// X = signed distance from the spline\n// Y = spline parameter t at the closest point [0, 1]\n// Z = spline length at the closest point\nvec3 ToSplineLocalSpace(vec2 p)\n{\n    vec3 splineUV = vec3(3e10, 0, 0);\n    float totalLen = 0.0; // the length of the whole spline\n\n    // For each bezier segment\n    for (int i = 0; i < KNOT_COUNT - 1; i += 2)\n    {\n        vec2 A = spline[i], B = spline[i + 1], C = spline[i + 2];  \n        // This is to prevent 3 colinear points, but there should be better solution to it.\n        B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C))); \n        // Current bezier curve SDF\n        vec2 bezierSDF = BezierSDF(A, B, C, p);\n        // Curve lengths\n        vec2 lenIntegrals = BezierCurveLengthAt(A, B, C, saturate(bezierSDF.y));\n            \n        if (abs(bezierSDF.x) < abs(splineUV.x))\n        {\n            // Save the SDF and lenght of the spline up to the closest point to the specified one\n            float curLength = lenIntegrals[0] + totalLen;        \n            splineUV = vec3(bezierSDF.x, (saturate(bezierSDF.y) + 0.5 * float(i)) / float(KNOT_COUNT), curLength);\n        }\n        \n        // Sum bezier segments length\n        totalLen += lenIntegrals[1];\n    }\n\n    return splineUV;\n}\n\nvec2 ScaleUV(vec3 splineUV, float scale)\n{\n    return fract(vec2(splineUV.z, splineUV.x + 0.5 * PATH_WIDTH) * scale);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord /iResolution.y;\n\n    // Get the signed distance to bezier curve and calc an uv field\n    vec3 splineUV = ToSplineLocalSpace(uv);\n    \n    fragColor = vec4(0.0, 0.4, 0.5, 1.0);\n    if (splineUV.x >= -0.5 * PATH_WIDTH \n        && splineUV.x <= 0.5 * PATH_WIDTH \n        && splineUV.y >= 0.0 \n        && splineUV.y <= 1.0)\n    {\n        // Animate UV scale\n        float uvScale = round(4.5 + 6.0 * fract(0.2 * iTime));\n        vec2 scaledUV = ScaleUV(splineUV, uvScale);\n\n        // Animate between UV and texture display\n        vec4 colorUV = vec4(scaledUV.xyx, 1.0);\n        vec4 colorTextured = texture(iChannel0, scaledUV);        \n        fragColor = mix(colorUV, colorTextured, saturate(abs(2.0 * uv.x - 4.0 * fract(0.2 * iTime))));\n    }\n    \n    {\n        float de = 1e20, dp = 1e20;\n        for (int i=0; i < KNOT_COUNT; i++) {\n            // 控制点距离场\n            dp = min(dp, length(uv - spline[i]));\n            if (i > 0)\n            {\n                vec2 pa = uv - spline[i], ba = spline[i - 1] - spline[i];\n                de = min(de, length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)));\n            }\n        }\n        \n        vec3 color = vec3(0.0);\n        color = mix(color, vec3(1.0, 0.8, 0.0), 1.0 - smoothstep(0.0, fwidth(de), de - 0.0015));\n        fragColor.rgb += color;\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 1.0), smoothstep(0.01, 0.0, abs(splineUV.x)));\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), 1.0 - smoothstep(0.0, fwidth(dp), dp - 0.015));\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}