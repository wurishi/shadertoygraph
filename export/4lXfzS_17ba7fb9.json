{"ver":"0.1","info":{"id":"4lXfzS","date":"1512196140","viewed":280,"name":"Triangle distance in 2D","username":"madware","description":"Getting the distance to the triangle in 2D space alongside with its barycentric coords and checking if a point is in triangle or not","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","barycentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cross2(v0, v1) v0.x * v1.y - v0.y * v1.x\n#define IsIn(b) all(greaterThan(b, vec3(0.)))\n\nfloat lineDistanceWork(in vec2 p0, in vec2 p0p, in vec2 p1p, in vec2 p0p1, in vec2 p)\n{\n    vec2 p0p1Norm = normalize(p0p1);\n    \n    float t = dot(p0p, p0p1Norm);    \n    float nearestDistance = abs(cross2(p0p, p0p1Norm));\n        \n    return mix(\n        nearestDistance*nearestDistance,\n        min(dot(p0p,p0p), dot(p1p,p1p)),\n        float(t <= 0.0 || t*t >= dot(p0p1,p0p1))\n    );  \n}    \n\nfloat lineDistance(in vec2 p0, in vec2 p1, in vec2 p)\n{\n    vec2 p0p = p - p0;\n    vec2 p1p = p - p1;\n    vec2 p0p1 = p1 - p0;\n    \n    return sqrt(lineDistanceWork(p0, p0p, p1p, p0p1, p));  \n}\n\nfloat triangleDistance(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p, out vec3 barycentric)\n{\n    vec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n    \n    float a = cross2(e0, e1);\n    \n    //Calculate distance to the triangle as a min distance to it's edges\n    float dst = \n        sqrt(min(min\n        (\n            lineDistanceWork(p0, v0, v1, e0, p),\n            lineDistanceWork(p1, v1, v2, e1, p)\n        ),  lineDistanceWork(p2, v2, v0, e2, p)));\n    \n    //Using simplified 2d version of barycentric coords\n    vec2 bar2 = vec2(cross2(v1, v2), cross2(v2, v0)) / a;\n    barycentric = vec3(bar2, 1.0 - bar2.x - bar2.y);\n    \n    bool isInside = IsIn(barycentric);\n    //When we inside a triangle the distance is negative\n    return dst * mix(1.0, -1.0, float(isInside));    \n}\n\nvec2 rotate(vec2 inVec, float a)\n{\n    float cs = cos(a);\n    float sn = sin(a);\n    mat2 m =\n        mat2(  cs, -sn,\n               sn,  cs );\n    return m * inVec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 cntr = vec2(0.5, 0.5);\n    cntr.x = cntr.x / iResolution.y * iResolution.x;\n    \n    vec2 a = cntr + rotate(vec2(-0.2, -0.125), iTime);\n    vec2 b = cntr + rotate(vec2( 0.2, -0.125), iTime) * 0.7;\n    vec2 c = cntr + rotate(vec2( 0.0, -0.125 + 0.2 * tan(3.1416 / 3.0)), iTime) * 1.3;\n    \n    vec3 baryc;\n    float dst = triangleDistance(a, b, c, uv, baryc) * 5.0;    \n        \n    fragColor = vec4(\n        (0.8 + 0.2*cos(120.0*dst)) * mix(mix(\n            baryc, \n            vec3(0.97, 0.37, 0.0) * (1.0 - dst*.3), \n            float(dst > 0.0)\n        ), vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(dst))), 1.0);\n}","name":"Image","description":"","type":"image"}]}